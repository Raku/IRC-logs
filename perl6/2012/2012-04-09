[00:02] *** xinming joined
[00:17] *** jeffreykegler joined
[00:19] *** jeffreykegler left
[00:33] <sorear> colomon: same here

[00:48] *** wolfman2000 left
[00:48] *** HarryS joined
[00:56] *** nif_ joined
[00:57] *** nif left
[01:00] *** nif_ left
[01:03] *** nif joined
[01:09] <lichtkind> TimToady: in S03: "Returns the list on the left unless any of them are EMPTY, " you mean any element?

[01:15] *** onega joined
[01:15] *** onega left
[01:17] <sorear> lichtkind: EMPTY is gone

[01:20] <lichtkind> you mean the special word EMPTY?

[01:20] <lichtkind> or E ?

[01:21] <sorear> both.

[01:22] <lichtkind> wha?

[01:22] <lichtkind> why

[01:22] <lichtkind> i just added it :)

[01:23] <sorear> EMPTY and E are part of the Old Iterator Model

[01:23] <sorear> which is still documented in S07, but that's supposed to change

[01:26] *** scott__ joined
[01:31] <lichtkind> so it shouldbe deleted out of S03 too

[01:32] <lichtkind> sorear: thank you

[01:36] *** havenn joined
[01:43] *** havenn left
[01:45] <lichtkind> good night

[01:49] *** raiph left
[01:49] *** lichtkind left
[01:50] *** tokuhirom left
[01:50] *** tokuhirom joined
[01:55] *** tokuhirom left
[02:09] *** whiteknight left
[02:12] *** IngisKahn left
[02:19] *** orafu left
[02:19] *** orafu joined
[02:24] *** benabik joined
[02:35] *** Chillance left
[02:40] *** vlixes joined
[02:46] <vlixes> pernatiy: 

[02:46] *** vlixes left
[02:51] *** conntrack left
[02:53] *** nif left
[02:54] *** nif joined
[02:58] *** nif left
[03:13] *** wolfman2000 joined
[03:14] *** thelazydeveloper left
[03:15] *** envi_ joined
[03:18] *** araujo left
[03:33] *** thou joined
[03:34] *** vlixes joined
[03:34] *** vlixes left
[03:39] *** fgomez left
[03:39] *** fgomez joined
[03:41] *** envi_ left
[03:44] *** nif joined
[03:56] *** fgomez left
[03:56] *** fgomez joined
[03:57] *** IngisKahn joined
[04:19] *** nif left
[04:20] *** nif joined
[04:28] *** nif left
[04:43] *** spaceships left
[04:43] *** spaceships joined
[04:45] *** spaceships left
[04:51] *** lestrrat left
[04:52] *** lestrrat joined
[05:13] *** birdwindupbird joined
[05:53] *** lestrrat left
[05:54] *** lestrrat joined
[06:00] *** araujo joined
[06:00] *** araujo left
[06:00] *** araujo joined
[06:15] *** xinming left
[06:34] *** xinming joined
[06:51] *** tarch joined
[07:15] <dalek> specs: a950494 | moritz++ | S02-bits.pod:

[07:15] <dalek> specs: [S02] fix POD error

[07:15] <dalek> specs: review: https://github.com/perl6/specs/commit/a950494055

[07:19] <moritz> S02 says: "In support of OO encapsulation, there is a new fundamental datatype: P6opaque. External access to opaque objects is always through method calls, even for attributes."

[07:19] <moritz> but currently we consider P6opaque not a type in the usual sense, but a representation. Right?

[07:19] <moritz> how can we rephrase that to make it clearer?

[07:20] <sorear> s/datatype/representation/

[07:20] <sorear> at the time that was written, we didn't have a distinct name for reprs yet

[07:20] <sorear> o/ moritz 

[07:21] <moritz> \o sorear 

[07:21] <moritz> and the "external" refers to from outside the current class, rightß

[07:21] <moritz> s/ß/?/

[07:22] <dalek> specs: d689826 | moritz++ | S02-bits.pod:

[07:22] <dalek> specs: P6opaque is a data representation, not a type

[07:22] <dalek> specs: review: https://github.com/perl6/specs/commit/d689826724

[07:23] <moritz> sorear++ deserves some credit too

[07:26] <dalek> specs: 8c10e33 | moritz++ | S02-bits.pod:

[07:26] <dalek> specs: [S02] update type object .gist-ification

[07:26] <dalek> specs: review: https://github.com/perl6/specs/commit/8c10e33d6e

[07:28] *** fglock joined
[07:34] <moritz> std: my Int|Str $error

[07:34] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Multiple prefix constraints not yet supported at /tmp/T0T3VVdFIT line 1:␤------> my Int⏏|Str $error␤Malformed my at /tmp/T0T3VVdFIT line 1:␤------> my Int⏏|Str $error␤    expecting any of:␤  multi_de…

[07:34] <moritz> S02/Polymorphic types/ says this should be allowed

[07:34] <moritz> should I mark the whole section as conjectural?

[07:34] <moritz> or delete it outright?

[07:37] * moritz goes with the former

[07:37] <dalek> specs: 30713e3 | moritz++ | S02-bits.pod:

[07:37] <dalek> specs: [S02] polymorphic types are speculative at best

[07:37] <dalek> specs: 

[07:37] <dalek> specs: mark them as conjectural

[07:37] <dalek> specs: review: https://github.com/perl6/specs/commit/30713e376d

[07:45] *** sporous left
[07:45] *** sporous joined
[07:46] *** sporous left
[07:50] *** sporous joined
[08:04] *** Trashlord left
[08:07] *** Trashlord joined
[08:09] <moritz> f [1, 2, 3]; f my @ = 1, 2, 3;   sub f (\x) {  # how can I check if x will flatten as 3 elements or as 1 in list context? }

[08:10] *** pomysl left
[08:10] *** Trashlord left
[08:11] *** snearch joined
[08:13] <dalek> specs: 80afe38 | moritz++ | S02-bits.pod:

[08:13] <dalek> specs: [S02] change a heading

[08:13] <dalek> specs: 

[08:13] <dalek> specs: the described behavior really depends on the type, not on the container type

[08:13] <dalek> specs: (that is, @a = 1, 2, 3 and $a = [1, 2, 3] stringify the same way)

[08:13] <dalek> specs: review: https://github.com/perl6/specs/commit/80afe387f5

[08:14] *** fsergot joined
[08:17] <fsergot> hi o/

[08:19] *** Trashlord joined
[08:19] <tadzik> o/

[08:20] *** Trashlord left
[08:21] *** Trashlord joined
[08:23] <moritz> \o fsergot, tadzik, *

[08:24] <moritz> p6: my %h = a => 1, b => 2, 'a b' => 3; sub f { <a b> }; sub g { [<a b> ] }; say %h{ f }; say %h{ g }

[08:24] <p6eval> niecza v15-6-gefda208: OUTPUT«1 2␤3␤»

[08:24] <p6eval> ..pugs: OUTPUT«12␤3␤»

[08:24] <p6eval> ..rakudo 4373f0: OUTPUT«1 2␤1 2␤»

[08:29] *** Trashlord left
[08:32] <moritz> I'm pretty sure that niecza++ is right and rakudo is wrong

[08:32] *** Trashlord joined
[08:32] <moritz> std: @ $_

[08:32] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at /tmp/bJBzzKomLy line 1:␤------> <BOL>⏏@ $_␤Use of uninitialized value $first in string eq at STD.pm line 66416.␤Use of uninitialized value $first in string lt at STD.pm lin…

[08:35] <dalek> specs: 01ed12c | moritz++ | S02-bits.pod:

[08:35] <dalek> specs: [S02] sigils are not available as prefix operators

[08:35] <dalek> specs: 

[08:35] <dalek> specs: std and the compilers do not implement it, neither is it use in the spec or

[08:35] <dalek> specs: the test suilte

[08:35] <dalek> specs: review: https://github.com/perl6/specs/commit/01ed12c389

[08:36] *** thou left
[08:40] *** Trashlord left
[08:41] *** snearch left
[08:41] <dalek> specs: f583892 | moritz++ | S02-bits.pod:

[08:41] <dalek> specs: [S02] do not use conjectural stuff in unrelated examples

[08:41] <dalek> specs: review: https://github.com/perl6/specs/commit/f583892f34

[08:41] *** Trashlord joined
[08:43] *** NamelessTee joined
[08:46] *** Trashlord left
[08:46] <dalek> specs: 20e3235 | moritz++ | S02-bits.pod:

[08:46] <dalek> specs: [S02] delete note on intrinsic hash iterator state

[08:46] <dalek> specs: 

[08:46] <dalek> specs: We do try to learn from p5's mistakes. The fact that hashes can be

[08:46] <dalek> specs: passed to routines without flattening them into a list means that

[08:46] <dalek> specs: intrinsic iterators would cause way too much action at a distance.

[08:46] <dalek> specs: review: https://github.com/perl6/specs/commit/20e32350ee

[08:48] *** Trashlord joined
[08:51] <jnthn> morning

[08:56] *** Trashlord left
[08:59] *** dwierenga left
[09:00] *** dwierenga joined
[09:28] *** fgomez left
[09:29] *** envi_ joined
[09:49] *** fsergot left
[09:52] *** spider-mario joined
[09:57] *** fsergot joined
[10:10] *** fsergot left
[10:11] *** scott__ left
[10:33] *** pernatiy left
[10:47] *** xinming left
[10:51] *** sftp left
[10:51] *** sftp joined
[11:02] *** lestrrat left
[11:02] *** lestrrat joined
[11:11] *** Trashlord joined
[11:15] *** thelazydeveloper joined
[11:16] *** pernatiy joined
[11:32] *** xinming joined
[11:32] *** fsergot joined
[12:13] *** Chillance joined
[12:17] <moritz> std: my ($a, $b); ($a, $, $b) = 1..3

[12:17] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Unsupported use of $, variable; in Perl 6 please use .join() method at /tmp/RbrBhuZI1y line 1:␤------> my ($a, $b); ($a, $,⏏ $b) = 1..3␤Parse failed␤FAILED 00:00 44m␤»

[12:17] <moritz> std: my ($a, $, $b) = 1..3

[12:17] <p6eval> std 1ad3292: OUTPUT«ok 00:00 43m␤»

[12:18] *** NamelessTee left
[12:18] *** JimmyZ joined
[12:21] <moritz> p6: class A { our sub b() { 'A::b' } }; say A::{'&b'}

[12:21] <p6eval> niecza v15-6-gefda208: OUTPUT«sub b() { ... }␤»

[12:21] <p6eval> ..rakudo 4373f0: OUTPUT«Method 'at_key' not found for invocant of class 'A'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1190␤  in block <anon> at /tmp/McTNGNVsui:1␤␤»

[12:21] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "{'&"␤    at /tmp/Lxwp4JCNDc line 1, column 44␤»

[12:21] <moritz> niecza++

[12:23] *** JimmyZ left
[12:23] <moritz> niecza: say lines[0]

[12:23] <p6eval> niecza v15-6-gefda208: OUTPUT«Land der Berge, Land am Strome,␤»

[12:24] *** JimmyZ joined
[12:24] *** brrt joined
[12:26] *** wolfman2000 left
[12:27] *** brrt left
[12:32] *** hundskatt left
[12:38] <moritz> p6: sub st() { 'string' }; say str.uc

[12:38] <p6eval> pugs: OUTPUT«*** No such subroutine: "&str"␤    at /tmp/yRvsK50CQy line 1, column 28 - line 2, column 1␤»

[12:38] <p6eval> ..niecza v15-6-gefda208: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'str' used at line 1␤␤Potential difficulties:␤  &st is declared but not used at /tmp/gW0TC6I48c line 1:␤------> sub st⏏() { 'string' }; say str.uc␤␤Unhandled exception: Check failed␤␤  …

[12:38] <p6eval> ..rakudo 4373f0: OUTPUT«use of uninitialized value of type str in string context␤␤»

[12:38] <moritz> p6: sub st() { 'string' }; say st.uc

[12:38] <p6eval> pugs, rakudo 4373f0, niecza v15-6-gefda208: OUTPUT«STRING␤»

[12:39] <moritz> p6: say st.uc; sub st() { 'string' }

[12:39] <p6eval> pugs, rakudo 4373f0, niecza v15-6-gefda208: OUTPUT«STRING␤»

[12:39] <moritz> std: say st.uc; sub st() { 'string' }

[12:39] <p6eval> std 1ad3292: OUTPUT«ok 00:00 42m␤»

[12:39] <moritz> S02 is full of scary stuff. This example above should be forbidden.

[12:39] <moritz> "It is illegal for a provisional subroutine call to be followed by a

[12:39] <moritz> colon postfix, since such a colon is allowed only on an indirect object,

[12:39] <moritz> or a method call in dot form."

[12:41] <pmichaud> p6: say st++;  sub st() { 'string' }

[12:41] <p6eval> pugs: OUTPUT«*** Can't modify constant item: VStr "string"␤    at /tmp/Kevvd4lZeY line 1, column 5-9␤»

[12:41] <p6eval> ..niecza v15-6-gefda208: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/cYbwm0bQZi line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65) ␤  at /home/p6eval/niecza/lib/…

[12:41] <p6eval> ..rakudo 4373f0: OUTPUT«Cannot assign to a non-container␤  in sub postfix:<++> at src/gen/CORE.setting:1242␤  in block <anon> at /tmp/7AovGytkNF:1␤␤»

[12:42] <moritz> that section (S02/Bare identifies/) has other scary stuff

[12:42] <moritz> erm, S02/Bare identifiers/

[12:42] *** NamelessTee joined
[12:42] <pmichaud> yes, it does

[12:43] <moritz> like a block about how predeclared unary subs parse an argument list of just one argument

[12:43] <pmichaud> I wonder if any of it is really fossil

[12:43] <moritz> I hope most is

[12:43] <pmichaud> oh, I'm certain that part is fossil

[12:45] <pmichaud> ...although I'm not finding it based on a search for "unary"

[12:45] <moritz> "Based on the signature of the subroutine declaration, there are only four ways that an argument list can be parsed:"

[12:45] <moritz> that's the section I'm referring to

[12:46] <moritz> it's not very explicit in there, but why list those four ways of parsing signatures when there's no distinction?

[12:46] <pmichaud> yes, I agree.  We'll want TimToady to either confirm that it's now fossil or clarify

[12:47] <moritz> I'll just swing the sledgehammer since I'm fairly confident it's fossil. If it's not, I won't be mad at TimToady++ for using 'git revert'

[12:47] <moritz> forgiveness > permission and all that :-)

[12:47] <pmichaud> moritz++

[12:50] *** mtk joined
[12:55] *** lichtkind joined
[12:56] <lichtkind> moin

[12:57] *** PacoAir joined
[13:00] <pmichaud> niecza:  class ABC { our sub xyz() { 'xyz' } };  say ABC.WHO.WHAT

[13:00] <p6eval> niecza v15-6-gefda208: OUTPUT«Stash()␤»

[13:00] <pmichaud> niecza:  class ABC { our sub xyz() { 'xyz' } };  say ABC::.WHAT

[13:00] <p6eval> niecza v15-6-gefda208: OUTPUT«Stash()␤»

[13:00] <pmichaud> niecza++

[13:00] <pmichaud> rakudo:  class ABC { our sub xyz() { 'xyz' } };  say ABC.WHO.WHAT

[13:00] <p6eval> rakudo 4373f0: OUTPUT«Stash()␤»

[13:00] <pmichaud> rakudo:  class ABC { our sub xyz() { 'xyz' } };  say ABC::.WHAT

[13:00] <p6eval> rakudo 4373f0: OUTPUT«ABC()␤»

[13:00] *** lichtkind_ joined
[13:00] <pmichaud> rakudo--

[13:01] * [Coke] drinks a coffee and yawns.

[13:01] <[Coke]> # 04/08/2012 - rakudo++ ; niecza (95.33%); pugs (39.69%)

[13:01] <[Coke]> "niecza",     20349,     2,   749,  1530, 22630, 24118

[13:01] <[Coke]> "pugs"  ,      8472,     2,  3151,  1615, 13240, 23979

[13:01] <[Coke]> "rakudo",     21345,    31,   638,  1888, 23902, 24128

[13:01] <[Coke]> p: say 21345*.4-8472

[13:01] <p6eval> pugs: OUTPUT«66␤»

[13:02] *** lichtkind left
[13:02] *** lichtkind_ is now known as lichtkind

[13:05] *** PacoAir left
[13:09] *** plutoid joined
[13:11] <moritz> std: uc\ .lc

[13:11] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Unsupported use of bare 'uc'; in Perl 6 please use .uc if you meant $_, or use an explicit invocant or argument at /tmp/2Mz3u2gb2x line 1:␤------> uc⏏\ .lc␤Check failed␤FAILED 00:00 40m␤»

[13:12] <moritz> std: sub f() { }; f\ .lc

[13:12] <p6eval> std 1ad3292: OUTPUT«ok 00:00 41m␤»

[13:13] <moritz> std: my $foo; .$foo

[13:13] <p6eval> std 1ad3292: OUTPUT«ok 00:00 41m␤»

[13:15] <[Coke]> masak, au, moritz: hey, if pugs had "so", we could pretty easily hit the 40% mark. ;)

[13:15] <moritz> [Coke]: I've already tried :/

[13:16] <lichtkind> moritz: i heard that EMPTY and E are about to go and i was tempted to remove according pieces of S02

[13:16] <lichtkind> but its now just out of the tablets

[13:16] <moritz> lichtkind: have fun :-)

[13:16] <dalek> specs: 39ac2b0 | moritz++ | S02-bits.pod:

[13:16] <dalek> specs: [S02] remove parsing fossils

[13:16] <dalek> specs: 

[13:16] <dalek> specs: parsing is now a lot more regular than it used to be. Std, rakudo and niecza

[13:16] <dalek> specs: already worked that way, it is only the spec that still had the old

[13:17] <dalek> specs: irregularities

[13:17] <dalek> specs: review: https://github.com/perl6/specs/commit/39ac2b0682

[13:17] <lichtkind> moritz: thanks but i still fighting with my rakudo patch getting less and less fun

[13:17] *** wolfman2000 joined
[13:18] *** skids joined
[13:19] *** lichtkind left
[13:20] <dalek> specs: f5d00a5 | moritz++ | S02-bits.pod:

[13:20] <dalek> specs: [S02] tiny wording update

[13:20] <dalek> specs: 

[13:20] <dalek> specs: we do not call arrays stored a scalar "array ref" anymore

[13:20] <dalek> specs: review: https://github.com/perl6/specs/commit/f5d00a57f7

[13:21] *** [particle] left
[13:26] *** [particle] joined
[13:27] *** JimmyZ left
[13:29] <pmichaud> locally: 

[13:29] <pmichaud> > say (1,2,6 ... *)[10]

[13:29] <pmichaud> Unable to decude sequence

[13:29] <pmichaud> > say (1,2,6 ... *).elems

[13:29] <pmichaud> Inf

[13:30] <pmichaud> this differs from current nom:

[13:30] <pmichaud> r: say (1,2,6 ... *)[10]

[13:30] <p6eval> rakudo 4373f0: OUTPUT«Nil␤»

[13:30] <pmichaud> r: say (1,2,6 ... *).elems

[13:30] <p6eval> rakudo 4373f0: OUTPUT«Inf␤»

[13:31] <pmichaud> okay, that part remains the same-ish (because of laziness)

[13:31] *** JimmyZ joined
[13:31] <pmichaud> anyway, locally I've written sequence to produce an infinite sequence of failures when it cannot deduce the sequence

[13:31] <pmichaud> still not sure that's.... correct.

[13:32] <moritz> what about stringification of such a sequence?

[13:33] <dalek> specs: 025f410 | moritz++ | S02-bits.pod:

[13:33] <dalek> specs: [S02] remove fossil from the times we had "want"

[13:33] <dalek> specs: review: https://github.com/perl6/specs/commit/025f410f29

[13:33] <pmichaud> it's still stringifying to "..." because of laziness.

[13:33] <pmichaud> otoh, we get

[13:33] *** lichtkind joined
[13:34] <moritz> can't we just reify the first, say, 8 or 10 items, and stringify them plus a ... ?

[13:34] <moritz> because '...' alone is very unhelpful

[13:34] <pmichaud> I agree

[13:34] <moritz> even <LAZY LIST> would be more helpful than ...

[13:34] <pmichaud> would we reify the next 8 or 10 items on each stringification, though?

[13:35] <moritz> sorry, I meant to say we stringify the first 8 or 10 items

[13:35] <moritz> and reify as necessary

[13:35] <pmichaud> yes, I understood that

[13:35] <pmichaud> my point being:

[13:35] <pmichaud> my @a = 1 .. *;

[13:35] <pmichaud> say ~@a;   # produces "1 2 3 4 5 6 7 8 ..."

[13:36] <pmichaud> but now the first eight elements of @a have been reified, so

[13:36] <pmichaud> say ~@a;  # produces "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ..."

[13:36] <pmichaud> i.e., do we always reify the first N items of any lazy component we encounter?

[13:37] <moritz> I wouldn't say so

[13:37] <pmichaud> so, what's the deciding factor?

[13:37] <moritz> just do   self[^10] ~ ' ...' or so

[13:37] <moritz> (and check that self[^10] actually returned 10 items; if not, no need to add the '...' }

[13:38] <pmichaud> I don't think it quite works that way.  Let me check.

[13:38] <moritz> we do store reify elements

[13:38] <pmichaud> that's not what I'm referring to

[13:39] <moritz> self.gimme(10) < 10 ?? self.join(' ') !! self.[^10].join(' ') ~ ' ...'

[13:39] <pmichaud> .join is the part that does the '...'

[13:39] <lichtkind> is a gimme some sort of official method?

[13:40] <moritz> pmichaud: then maybe we need a (possibly private) low-level join that isn't that smart

[13:40] <pmichaud> currently .join works by stringifying all of the list elements and pushing them into a ResizableStringArray

[13:40] <moritz> or a join with an item count limit that disregards laziness

[13:41] *** Trashlord left
[13:42] *** Trashlord joined
[13:43] <pmichaud> what do we do with a list that has 15 elements and then a lazy component?  Do we leave the lazy component alone?

[13:43] <moritz> yes

[13:43] <pmichaud> so, if we had

[13:43] <[Coke]> p: say 1...2

[13:43] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "2"␤    expecting operator, ":", "," or term postfix␤    at /tmp/iImo2stOFT line 1, column 9␤»

[13:44] <pmichaud> say ~(<a b c d e f g h i j k l m n o>, 1, 2, 6 ... *)

[13:44] <pmichaud> you'd be okay with   "a b c d e f g h i j k l m n o ..."   as the result?

[13:45] <moritz> yes, though it would probably be even better include all reified elements

[13:45] *** Trashlord left
[13:45] <pmichaud> that would be all of the reified elements of the sequence, though.

[13:45] <pmichaud> that's kind of my point.

[13:45] <moritz> so, restart: include all already reified elements, and reifiy more only if less then 8 have been reified

[13:46] <pmichaud> so, actually, it would've come out as "a b c d e f g h i j ..."

[13:46] <[Coke]> I dislike that the gist is changing all the time here.

[13:46] <[Coke]> s/all the time/at all/ , really.

[13:46] *** Trashlord joined
[13:47] <pmichaud> keep in mind that sequences reify one element at a time, including for the elements on the lhs list.  Either that or we don't use gather/take to generate sequences.

[13:47] <pmichaud> or we have to do something else really bizarre-ish

[13:47] <pmichaud> if I have

[13:47] <pmichaud> my $seq := (< a b c d e f g h i j k l m n o>, 1, 2, 6 ... *);

[13:48] <pmichaud> then at this point, $seq has zero reified elements

[13:48] <pmichaud> when I request

[13:48] <moritz> well, we can always call   @result.gimme($lhs.elems)  before leaving the sequence operator

[13:48] <pmichaud> as long as $lhs.elems isn't infinite, yes.

[13:48] <moritz> correct

[13:49] <moritz> but there's no need to lazify parts of the return list that have already been eagerly evaluated

[13:49] <pmichaud> I don't follow that statement.

[13:49] <moritz> which we do in order to determine the generator

[13:50] <pmichaud> we determine the generator lazily, though.

[13:50] <pmichaud> i.e., we determine the generator at the point where it's needed, not a-priori

[13:51] <pmichaud> and the whole sequence is a gather/take loop, which implies laziness on each element

[13:51] <pmichaud> (i.e., there's one take per element)

[13:53] <pmichaud> I suppose it could be written such that it returns the equivalent of (@lhs, gather/take)   instead of a single gather/take that also handles the @lhs elements, but that feels odd-ish

[13:53] *** thelazydeveloper left
[13:53] <pmichaud> regardless

[13:53] <pmichaud> going back to stringification, given

[13:54] <pmichaud> say ~(< a b c d e f g h i j k l m n o >, 1, 2, 6 ... *)

[13:54] <pmichaud> even if we .gimme the lhs, we end up with a stringification of "a b c d e f g h i j k l m n o 1 2 6 ..."

[13:54] <pmichaud> I guess that might be okay.  

[13:55] <moritz> +1

[13:56] <moritz> (sorry, got called away)

[13:56] <moritz> r: say (1, 2, 3 ... 1).perl

[13:56] <p6eval> rakudo 4373f0: OUTPUT«(1,).list␤»

[13:56] <pmichaud> I'm just not very keen on saying that the @lhs of a sequence should be eagerly evaluated at the time the sequence is created, though.

[13:57] <moritz> if the LHS already is eager, why not?

[13:57] <pmichaud> you mean if it's already reified

[13:57] <pmichaud> so, really   @return.gimme(@lhs.gimme(0))

[13:57] <pmichaud> instead of @lhs.elems

[13:57] <moritz> yes

[13:58] <moritz> in your example it's a literal; there's no point in making a literal lazy

[13:58] <pmichaud> well, the sequence operator doesn't always know that it's getting a literal

[13:58] *** bluescreen10 joined
[13:59] <moritz> right

[13:59] <moritz> but if it does, Nicholas Clark has argued (and I agree with it) that we should deduce the sequence as early as possible, in order to fail as early as possible

[13:59] <pmichaud> sure, but that's a totally different area of code --

[13:59] <moritz> which means compile time for literal LHSs

[14:00] <pmichaud> I'm not sure I agree with that, even if this example.

[14:00] <colomon> moritz++

[14:01] <pmichaud> I mean, just from an API perspective I'm not sure how that should be handled.

[14:02] <moritz> the compiler checks if the LHS is constant-foldable, and if yes, passes a named argument to sub SEQUENCE

[14:02] <moritz> (just one possibility)

[14:02] <pmichaud> yeah, I'm not sure I like that approach, unless we're doing that for all operators

[14:03] <moritz> in your absence we had some more discussion on constant folding and purity of operators

[14:03] <pmichaud> because it's really a call to infix:<...> that is being generated, not a call to SEQUENCE

[14:04] <pmichaud> just to be clear, I agree fully with the notion of detecting errors as early as possible (more)

[14:05] <moritz> and it seems that TimToady++ is in favor of assuming that things that look pure (like infix:<+>) can be assumed to be pure, even if technically a .Numeric call trigged by infix:<+> might be impure. My point is that we try to embrace constant folding on a rather broad scale

[14:05] <pmichaud> it's not entirely clear to me that constant arguments should turn a lazy operator into a more eager one

[14:06] <pmichaud> if I have    my $b = 6;   say (1, 2, $b ... *).[1];    

[14:06] <pmichaud> it will compile and run just fine

[14:06] <pmichaud> you're saying that  

[14:06] <pmichaud> say (1, 2, 6 ... *)[1]   

[14:06] <pmichaud> should produce a compile-time exception

[14:06] <moritz> correct

[14:07] <moritz> if somebody wants (1, 2, $b ... *).[1] to return 2, they can write 2 right away

[14:07] <pmichaud> well, the .[1] could be an expression

[14:07] * colomon wants to note that his previous moritz++ was for spec cleanups and had nothing to do with this discussion, which hadn't actually appeared on his IRC client for some reason.

[14:08] <moritz> but it's almost certainly a programming error to write a sequence whose autodeduction fails

[14:08] *** Trashlord left
[14:08] <moritz> even if only early elements are acceessed

[14:08] <pmichaud> anyway, I'm willing to table the constant folding discussion for now... that's really not the point of the ticket nor what I'm interested (or able) to solve at the moment.

[14:08] <moritz> ok

[14:08] <pmichaud> the ticket would have the same failure mode even if the lhs were held in @list

[14:09] <pmichaud> reifying 10 elements of an infinite list for stringification sounds a bit much to me

[14:09] <pmichaud> I could probably live with 8.

[14:09] <moritz> I'm not really attached to the number 10

[14:09] <pmichaud> would 4 be too few?

[14:10] <moritz> I just want to note that stringification is an eager operation by nature

[14:10] <pmichaud> oh, I know that well.

[14:10] <pmichaud> but "eager" currently stops in the face of infinity.

[14:10] <moritz> but only where we can detect that infinity

[14:10] <moritz> so it's not something you should rely on

[14:11] <pmichaud> combine that with what you just wrote above about stringification and you get what we have now

[14:11] <moritz> for example  (1, 2, 4 ... 7) is infinite but not detected as infinite

[14:11] <moritz> r: say ~(1, 2, 4 ... 7)

[14:11] <pmichaud> and stringification doesn't stop in that case

[14:11] <pmichaud> because it's eager

[14:11] <p6eval> rakudo 4373f0: OUTPUT«(timeout)»

[14:11] <moritz> anyway, I'd be fine with 4 too, though I'd like 6 or 8 better

[14:12] <moritz> only time will tell what a sensible number is, and it'll be easy to change later

[14:12] <moritz> do whatever you see fit

[14:12] <moritz> colomon: glad you like my spec cleanup

[14:12] <pmichaud> yes, the spec cleanups are excellent.  moritz++

[14:13] <moritz> colomon: I didn't even mean to do one, I just planned to skim some specs and take notes about how slushy/solid the different parts are

[14:13] <dalek> specs: ac1d1b1 | moritz++ | S02-bits.pod:

[14:13] <dalek> specs: [S02] update hash binding wording

[14:13] <dalek> specs: 

[14:13] <dalek> specs: remove the sentence about binding slurpy hashes in a signature, because

[14:13] <dalek> specs: they are not really bound in the same way that ::= or := binds

[14:13] <dalek> specs: review: https://github.com/perl6/specs/commit/ac1d1b12ab

[14:15] <dalek> specs: c0582b7 | moritz++ | S02-bits.pod:

[14:15] <dalek> specs: [S02] putting an IO object is list context does not return all lines

[14:15] <dalek> specs: 

[14:15] <dalek> specs: it is a far too common operation, and would make handling of IO objects much harder.

[14:15] <dalek> specs: Rather be explicit if you want its .lines

[14:15] <dalek> specs: review: https://github.com/perl6/specs/commit/c0582b7167

[14:16] <colomon> moritz: polishing the spec is important work that most of us ignore unless an issue smacks us in the face.  :)

[14:17] <colomon> I'm starting to think that sequence deduction is something that's going to be frowned upon by "Perl 6 Best Practices"...

[14:18] <pmichaud> oh, I doubt that.  I think it's very useful an elegant in the common cases.

[14:18] <pmichaud> *and

[14:18] <moritz> well, I can imagine advise like "only use automatic sequence deduction for literal left-hand sides" or so

[14:18] * [Coke] errs on the side of cheating when running pugs spec tests.

[14:18] <moritz> time will tell

[14:19] *** thou joined
[14:21] <colomon> The thing is, WhateverCodes make explicit generators clean and elegant too.  And if you always use them, you don't have to worry about a host of special rules.

[14:21] <colomon> r: say 1, 1, 2, 4 ... 16

[14:21] <p6eval> rakudo 4373f0: OUTPUT«1 1 2 4 8 16␤»

[14:22] <colomon> r: say -1, 2, 4 ... 16

[14:22] <p6eval> rakudo 4373f0: OUTPUT«unable to deduce sequence␤  in method Str at src/gen/CORE.setting:8203␤  in method Stringy at src/gen/CORE.setting:674␤  in method join at src/gen/CORE.setting:1059␤  in method Str at src/gen/CORE.setting:4862␤  in method gist at src/gen/CORE.setting:5156␤  in sub …

[14:22] <colomon> r: say 2, 4 ... 16

[14:22] <p6eval> rakudo 4373f0: OUTPUT«2 4 6 8 10 12 14 16␤»

[14:22] <moritz> r: say -1, 2, -4 ... -16

[14:22] <p6eval> rakudo 4373f0: OUTPUT«-1 2 -4 8 -16␤»

[14:24] <colomon> I guess there aren't that many different cases.  :)

[14:24] <moritz> ok, I'm done with S02

[14:24] <moritz> except the note that S02/Properties/ might need some wording updates

[14:25] <moritz> at least I haven't seen anybody in #perl6 talk about "properties" when talking about traits and runtime mix-ins

[14:26] <pmichaud> traits/runtime mixins used to be called properties

[14:26] <moritz> and S02 still calls them that way

[14:26] <pmichaud> as in they were a special type of property

[14:26] <moritz> it also contains gems like

[14:26] <moritz> "Properties are accessed just like attributes because they are in fact

[14:26] <moritz> attributes of some class or other, even if it's an anonymous singleton

[14:26] <moritz> class generated on the fly for that purpose.  "

[14:27] <moritz> afaict all interesting stuff with traits and mixins goes through methods these days

[14:27] <moritz> but I'm not sure what exactly was meant when that paragraph was written, so I'll leave it be

[14:29] *** nif joined
[14:30] <moritz> though I am tempted to swing the sledge hammer a final time on S02 :-9

[14:32] <geekosaur> there was a point when mixing stuff into a class generated anonymous singleton classes

[14:32] <dalek> specs: 67e83a4 | moritz++ | S02-bits.pod:

[14:32] <dalek> specs: [S02] remove section on "Properties"

[14:32] <dalek> specs: 

[14:32] <dalek> specs: it seems that "properties" refer to either traits or run-time mixins with

[14:32] <dalek> specs: infix but.

[14:32] <dalek> specs: Both are described much more accurately and less out-of-date in S12 and S14

[14:32] <dalek> specs: review: https://github.com/perl6/specs/commit/67e83a4377

[14:33] <moritz> geekosaur: that's mostly still the case (though I don't know if it's really singleton)

[14:33] <moritz> geekosaur: but the whole blurb about accessing properties as attributes looks totally wrong

[14:33] <geekosaur> I think the expected mechanism changed a lot with refinements to the meta object model

[14:33] <moritz> if you do  $x but True, it mixes in a method named Bool (because True is part of the Bool enum). No new attribute, no attribute access

[14:33] <cognominal> jnthn, problems with qbootstrap, not investigated yest, https://gist.github.com/2343861

[14:34] *** tokuhirom joined
[14:34] <geekosaur> it was being viewed as something similar to "but" (not identical to, as you noted)

[14:34] *** plutoid left
[14:34] <moritz> otoh is if you write  sub f($x is rw) { }, the 'is rw' trait (which seems to be a "property" too) doesn't mix in anything, it simply sets a single bit in the parameter object

[14:35] <moritz> so I think we're better off without that section

[14:35] <moritz> ok, 13 S02 commits in one day. Not bad :-9

[14:36] *** spider-mario left
[14:36] <tadzik> your spelling of "awesome" is funny :)

[14:37] <moritz> :-)

[14:40] <moritz> in S03/Term precedence/, do we really need that many examples?

[14:41] <moritz> "Any literal from S02/Literals, for examples quoted strings or numbers"

[14:42] <colomon> oh no, he's not stopping at S02!  ;)

[14:43] <moritz> colomon: should I?

[14:43] <colomon> heck no!

[14:43] <tadzik> CODING SPREE

[14:43] <colomon> (that's as in, don't stop, moritz++!)

[14:44] <moritz> I was really surprised how much cruft I found in S02

[14:44] <moritz> after all we usually cite it as an example of the more stable synopsis

[14:49] <pmichaud> I'm getting a spectest failure in S32-exceptions/misc.t -- known?

[14:49] <pmichaud> throws_like 'sub postbla:sym<foo>() { }', X::Syntax::Extension::Category, category => 'postbla';

[14:49] *** thelazydeveloper joined
[14:50] <moritz> yes. My fault somehow.

[14:50] <moritz> sorry about that.

[14:51] <pmichaud> hmmmm

[14:51] <pmichaud> r: say (1,2,6).list.gimme(0)

[14:51] <p6eval> rakudo 4373f0: OUTPUT«0␤»

[14:51] <pmichaud> r: say (1,2,6).list.gimme(1)

[14:51] <p6eval> rakudo 4373f0: OUTPUT«1␤»

[14:52] <pmichaud> using @result.gimme(@left.gimme(0))  isn't going to work :-(

[14:52] *** leprevost joined
[14:52] <dalek> specs: 8639cf5 | moritz++ | S03-operators.pod:

[14:52] <dalek> specs: [S03] Rat / Rat also produces a Rat

[14:52] <dalek> specs: review: https://github.com/perl6/specs/commit/8639cf59ab

[14:52] <dalek> roast: e33900b | coke++ | / (11 files):

[14:52] <dalek> roast: pugs fudge

[14:52] <dalek> roast: review: https://github.com/perl6/roast/commit/e33900bbd0

[14:53] <dalek> Pugs.hs: 7c322e4 | coke++ | t/spectest.data:

[14:53] <dalek> Pugs.hs: run (fudged) tests

[14:53] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/7c322e4b77

[14:53] <dalek> Pugs.hs: 83ce35c | coke++ | t/spectest.data:

[14:53] <dalek> Pugs.hs: track failure modes

[14:53] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/83ce35c028

[14:53] <pmichaud> maybe .gimme(*)

[14:53] <moritz> pmichaud: that's probably related to the storage of lists which I and masak recently compalined about

[14:54] <pmichaud> moritz: you're wanting lists to reify a bit more eagerly than they do now.

[14:54] <moritz> r: say (1, 2, 6).list.DUMP

[14:54] <p6eval> rakudo 4373f0: OUTPUT«List<-1505048396>(:items(▶Mu), :nextiter(ListIter<-1505048420>(:reified(▶Mu), :rest(RPA<-1505048448>(1, 2, 6)), :list(List<-1505048396>))))␤»

[14:55] <colomon> moritz: actually, shouldn't the division bit explain that Rat is only returned if the result fits in a Rat?

[14:55] <colomon> r: say (1/10000000000000000000000000000000000000).WHAT

[14:55] <p6eval> rakudo 4373f0: OUTPUT«Num()␤»

[14:55] <moritz> pmichaud: at least I don't see any possible gains from storing List(:items(Mu), :reified($x)) separately from $x

[14:55] <moritz> thought that might be related to the flattening thing

[14:55] <pmichaud> it is.

[14:56] <pmichaud> $x might have things that flatten

[14:56] *** birdwindupbird left
[14:56] <pmichaud> in this particular case, $x is a Parcel, not a List

[14:57] <moritz> pmichaud: at some point you really must explain how that flattening information is stored

[14:57] <moritz> colomon: probably

[14:57] <pmichaud> moritz: by virtue of being (1) Iterable and (2) not in a scalar container

[14:58] *** jaldhar left
[14:58] <moritz> pmichaud: which part is or is not in a scalar container? and how do we test that?

[14:59] <pmichaud> the elements of the unreified part of the List

[14:59] *** PacoAir joined
[14:59] <moritz> then I don't see how that's related to having a layer with an empty reified part

[15:00] *** fsergot left
[15:00] <pmichaud> given your example:

[15:00] <pmichaud>    (1,2,6)  is a Parcel

[15:00] <pmichaud> (1,2,6) is a List

[15:00] <pmichaud> sorry

[15:00] <pmichaud> (1,2,6).list is a List

[15:00] <pmichaud> we haven't done anything to request that List to reify any of its elements, so its reified part is empty

[15:04] * [Coke] opens a few more tickets on Pugs.hs for masak.

[15:04] <moritz> so if I understand this correctly, in the case of Parcel.list we could construct a List in the first place which has all elements reified

[15:04] <pmichaud> Perhaps.

[15:04] <moritz> at least if the Parcel is reified

[15:04] <pmichaud> Parcel's don't *reify*

[15:04] <pmichaud> all Parcels are already reified.

[15:04] <pmichaud> they're... constant.

[15:04] <moritz> then can't we just always do it?

[15:05] <pmichaud> when I tried it, bad things happened.

[15:05] <moritz> (construct a flatter list in the first place)

[15:05] <pmichaud> ummm, no

[15:05] <pmichaud> (1, 2, @a)   has how many elements?

[15:05] <pmichaud> depends on the context.

[15:05] <moritz> ok

[15:05] <pmichaud> or the way in which it's used

[15:05] <pmichaud> the Parcel itself consists of 1, 2, and @a

[15:06] <moritz> but doesn't the .list in Parcel.list already imply a context?

[15:06] <pmichaud> r:   my @a = <a b c>;  say (1, 2, @a).list.elems

[15:06] <p6eval> rakudo 4373f0: OUTPUT«5␤»

[15:06] <moritz> r: my @a = <a b c>;  say (1, 2, @a)[2]

[15:06] <p6eval> rakudo 4373f0: OUTPUT«a␤»

[15:07] <pmichaud> if you just put the 1, 2, and @a directly into the reified part, you'd get 3 for .elems

[15:07] <moritz> r: my @a = <a b c>;  say (1, 2, @a).list.[2]

[15:07] <p6eval> rakudo 4373f0: OUTPUT«a␤»

[15:07] <moritz> ok

[15:08] <pmichaud> so, reification still involves iteration

[15:09] <dalek> specs: 228a486 | moritz++ | S03-operators.pod:

[15:09] <dalek> specs: Note that infix:</> sometimes does not fit into Rat. colomon++

[15:09] <dalek> specs: review: https://github.com/perl6/specs/commit/228a486a39

[15:09] <pmichaud> and we tend to do that lazily.

[15:09] <pmichaud> we can be less lazy by doing .gimme(*), though

[15:09] <pmichaud> so, I'm guessing:

[15:09] <pmichaud> r:  say (1,2,3).list.gimme(*)

[15:09] <p6eval> rakudo 4373f0: OUTPUT«3␤»

[15:09] <pmichaud> r: say (1, 2, 3, 4..*).gimme(*)

[15:09] <p6eval> rakudo 4373f0: OUTPUT«Method 'gimme' not found for invocant of class 'Parcel'␤  in block <anon> at /tmp/jA8Goc7xta:1␤␤»

[15:09] <pmichaud> r: say (1, 2, 3, 4..*).list.gimme(*)

[15:09] <p6eval> rakudo 4373f0: OUTPUT«3␤»

[15:09] <pmichaud> so maybe I need @result.gimme(@left.gimme(*))

[15:10] <pmichaud> but that does tend to make @left a little eager

[15:11] <pmichaud> r:  my @a = <a b c>;  say (1, 2, 3, @a).list.gimme(*)

[15:11] <p6eval> rakudo 4373f0: OUTPUT«6␤»

[15:11] *** vlixes joined
[15:11] <pmichaud> r:   say (1,2,3).map(*+2).gimme(*)

[15:11] <p6eval> rakudo 4373f0: OUTPUT«3␤»

[15:12] <dalek> specs: 7ed1788 | moritz++ | S03-operators.pod:

[15:12] <dalek> specs: [S03] note that $x div $y == floor($x/$y) does not always hold

[15:12] <dalek> specs: review: https://github.com/perl6/specs/commit/7ed17880cf

[15:13] <moritz> I'm fine with .Str being a bit more eager

[15:13] <pmichaud> .Str is already eager

[15:13] <pmichaud> I don't know what you mean by "more eager"

[15:13] <pmichaud> you mean, as in 'strictly eager' ?

[15:13] <moritz> I don't know what you mean by 'strictly eager'

[15:14] <moritz> I think we have a problem with terminology here

[15:14] <pmichaud> mostly eager means "evaluate until you think you might have an infinity and then stop"

[15:14] <moritz> I'll try to rephrase

[15:14] <pmichaud> strictly eager means "evaluate even if you might have an infinity, if you get to a known infinity then fail"

[15:15] <moritz> I don't mind .Str being a bit more eager than pmichaud's "eager"

[15:15] <pmichaud> .Str is already eager.

[15:16] <pmichaud> note that what we're really talking about is .join, not .Str

[15:16] <pmichaud> .Str on a List calls join

[15:16] <moritz> so what's the behavior called when we simply go on and on, even if it might be infinite?

[15:16] <pmichaud> strictly eager

[15:16] <moritz> 17:14 < pmichaud> strictly eager means "evaluate even if you might have an  infinity, if you get to a known infinity then fail"

[15:16] <moritz> that's not the same

[15:17] <pmichaud> what's the difference?

[15:17] <pmichaud> note there's a difference between   "might be infinite" and "known infinite"

[15:17] <pmichaud> 1..*   is known infinite

[15:17] <moritz> well, if I write  strictly-eager (1..*).map: .say

[15:18] <moritz> it would fail

[15:18] <moritz> with your definition of "strictly eager"

[15:18] <moritz> but i can very well imagine cases where we want it to not fail, but simply keep on running

[15:18] *** estrabd left
[15:18] <moritz> or is (1..*).map: $something; already "possibly infinite"?

[15:18] <moritz> and not "known infinite"?

[15:18] <pmichaud> note that Rakudo doesn't really implement "known infinite" yet.

[15:19] <pmichaud> but I'd conjecture that 1..* would be "known infinite"

[15:19] <pmichaud> anything involving map is likely to be "possibly infinite"

[15:19] <pmichaud> because it's always possible for the map to contain a 'last'

[15:19] *** estrabd joined
[15:20] <pmichaud> s/likely to be/likely to be at most/

[15:20] *** nif left
[15:21] *** estrabd left
[15:21] *** spaceships joined
[15:21] <pmichaud> let's look at what Rakudo does do at the moment

[15:21] <pmichaud> the .infinite method has three possible return values:  False, True, and Mu

[15:21] <pmichaud> False means "I know this list to be finite"

[15:21] <pmichaud> True means "I know this list to be infinite"

[15:22] <pmichaud> Mu means "I don't know if the list is finite or infinite"

[15:22] *** estrabd joined
[15:22] <moritz> r: say (1, 2, 4 ... 7).infinite

[15:22] <p6eval> rakudo 4373f0: OUTPUT«Mu()␤»

[15:22] <moritz> r: say (1, 2, { last } ... *).infinite

[15:22] <p6eval> rakudo 4373f0: OUTPUT«True␤»

[15:22] <pmichaud> the use of whatever star means the programmer has requested the list to be treated as infinite

[15:23] <pmichaud> as known-infinite

[15:23] <pmichaud> (even if it's not actually infinite)

[15:24] *** estrabd is now known as estrabd1

[15:26] *** estrabd1 left
[15:27] <pmichaud> r:  say (1,2,3).list.flattens

[15:27] <p6eval> rakudo 4373f0: OUTPUT«Mu()␤»

[15:28] *** estrabd joined
[15:28] <moritz> phenny: ask TimToady can we please get rid of S03/Named unary precedence/? Not even std implements sin() as such, there is no list or rule which built-ins should be unary prefixes instead of listops, and back when we had defined() such a prefix in rakudo, it caused quite some confusion.

[15:28] <phenny> moritz: I'll pass that on when TimToady is around.

[15:28] *** estrabd left
[15:31] <masak> oh hai, #perl6

[15:31] * masak is slowly emerging out of Easter offline-hood

[15:31] <moritz> oh hai masak

[15:32] <moritz> masak: I hope it's OK that I borrowed your sledge hammer without asking first :-)

[15:32] *** JimmyZ left
[15:33] <masak> moritz: absolutely. the more who submit tickets, the better.

[15:34] <pmichaud> these are sledgehammer patches

[15:35] <moritz> masak: I think there's also an unsubmitted rakudobug in today's backlog, kind of as a delayed Easter egg for you :-)

[15:35] <pmichaud> there are probably a couple :)

[15:36] <moritz> (I meant the one with %h{<a b>} vs. %h{[<a b>]}

[15:36] * pmichaud backlogs

[15:37] <moritz> p6: my %h = a => 1, b => 2, 'a b' => 3; say %h{[<a b>]}

[15:37] <p6eval> pugs, niecza v15-6-gefda208: OUTPUT«3␤»

[15:37] <p6eval> ..rakudo 4373f0: OUTPUT«1 2␤»

[15:37] <moritz> looks like over-eager flattening to me

[15:37] * masak submits rakudobug

[15:38] <masak> moritz++ # for floating it up to the present

[15:38] <pmichaud> p6:  my @a = 0..5;  say @a[ [2, 3] ]

[15:38] <p6eval> pugs, niecza v15-6-gefda208: OUTPUT«2␤»

[15:38] <p6eval> ..rakudo 4373f0: OUTPUT«2 3␤»

[15:38] *** LylePerl left
[15:38] <masak> wow, you guys've been... active in the spec department.

[15:38] <pmichaud> I think rakudo might be right here.

[15:38] *** nif joined
[15:38] <pmichaud> Since [2,3] is Positional, the result is a slice.

[15:38] <moritz>  p6:  my @a = 0..5;  say @a[ [2, 3], 0 ]

[15:38] <p6eval> pugs: OUTPUT«20␤»

[15:38] <p6eval> ..niecza v15-6-gefda208: OUTPUT«2 0␤»

[15:38] <p6eval> ..rakudo 4373f0: OUTPUT«2 3 0␤»

[15:39] <masak> pmichaud: I'll note that in the rakudobug.

[15:39] <moritz> pmichaud: I'm pretty sure in this example rakudo is wrong

[15:39] <pmichaud> I'm certain rakudo is wrong there.

[15:39] <pmichaud> oh, wait, maybe not

[15:39] <moritz> in general [] should never be implicitly flattened

[15:39] <pmichaud> well, it's not really being flattened here.

[15:40] <pmichaud> what's happening is that we're getting a slice of   (@a[ [2,3] ], @a[0])

[15:40] <moritz> it's been treated as two elements rathar than one. To me that's flattening

[15:40] <pmichaud> r:  my @a = <a b c d e>;  say @a[ [2, 3], 0 ].perl

[15:40] <p6eval> rakudo 4373f0: OUTPUT«(("c", "d"), "a")␤»

[15:40] <pmichaud> right

[15:40] <pmichaud> it's not really "flattening"

[15:41] <moritz> I'm pretty sure that's wrong too

[15:41] <pmichaud> I'm not sure what "right" would be here.

[15:41] <moritz> if it descends into [], then the return value shouldn't flatten

[15:41] * masak .oO( it's not really flattening if it's all true ) :P

[15:42] <pmichaud> you're saying that scalar-ness should trump Positional-ness

[15:42] <moritz> yes

[15:42] <moritz> well

[15:42] *** LylePerl joined
[15:42] <pmichaud> i.e., the fact that something is scalar should prevent it from being treated as a Positional

[15:42] <moritz> I'm not sure it should trump it, but at some level it should be preserved at least

[15:43] <masak> I think I agree.

[15:43] <moritz> I find ('c', 'a') and (('c', 'd').item, 'a') acceptable outcomes

[15:43] <TimToady> I only like the first

[15:43] <phenny> TimToady: 15:28Z <moritz> ask TimToady can we please get rid of S03/Named unary precedence/? Not even std implements sin() as such, there is no list or rule which built-ins should be unary prefixes instead of listops, and back when we had defined() such a prefix in rakudo, it caused quite some confusion.

[15:43] <moritz> though currently I think that the former makes more sense, because .[] is not specced as hyper

[15:45] <pmichaud> okay, so a Positional (or anything?) in a scalar container shouldn't slice

[15:45] <TimToady> I think only the first makes sense, because a subscript is a LoL, and the second level list is still just a list, and [] doesn't interpolate into it

[15:45] <moritz> pmichaud: anything in a scalar container shouldn't slice

[15:46] <moritz> p6: say 1 E 2

[15:46] <TimToady> the rules of list interpolation don't change just becuase we're inside [1,2,3; 4,5,6; 7,8,9]

[15:46] <p6eval> rakudo 4373f0: OUTPUT«===SORRY!===␤Confused␤at /tmp/onCGs1dB16:1␤»

[15:46] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "E"␤    expecting operator, ":" or ","␤    at /tmp/avaB7uzPXn line 1, column 7␤»

[15:46] <p6eval> ..niecza v15-6-gefda208: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/XsIFpZUHRM line 1:␤------> say 1 ⏏E 2␤␤Parse failed␤␤»

[15:47] <pmichaud> this really doesn't have anything to do with list interpolation, at least not in Rakudo's case.

[15:47] <moritz> std: 1 E 2

[15:47] <pmichaud> anyway, I can fix it now.

[15:47] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/J4AYZnGtxp line 1:␤------> 1 ⏏E 2␤    expecting any of:␤       infix or meta-infix␤    infixed function␤       statement modifier loop␤Parse failed␤FAILED 00:00 41m␤»

[15:47] <dalek> specs: 5bb498e | moritz++ | S03-operators.pod:

[15:47] <dalek> specs: [S03] get rid of infix:<E>, which seems to be a fossil.

[15:47] <dalek> specs: 

[15:47] <dalek> specs: lichtkind++

[15:47] <dalek> specs: review: https://github.com/perl6/specs/commit/5bb498e88d

[15:50] *** tokuhirom left
[15:50] *** tokuhirom joined
[15:50] *** Psyche^ joined
[15:51] *** Patterner left
[15:51] *** Psyche^ is now known as Patterner

[15:54] *** tokuhirom left
[15:56] <masak> pmichaud: https://rt.perl.org/rt3/Ticket/Display.html?id=112362

[15:56] *** nif left
[15:56] <pmichaud> masak: testing fix now :)

[15:57] <pmichaud> (well, waiting for compile to finish)

[15:57] * masak backlogs

[15:58] *** nif joined
[15:58] <pmichaud> locally:

[15:58] <pmichaud> > my @a = <a b c d e>;  say @a[2,3]

[15:58] <pmichaud> c d

[15:58] <pmichaud> > my @a = <a b c d e>;  say @a[[2,3]]

[15:58] <pmichaud> c

[15:58] <pmichaud> > my @a = <a b c d e>;  say @a[[2,3], 0]

[15:59] <pmichaud> c a

[15:59] <pmichaud> > my %h = a => 1, b => 2, 'a b' => 3;  say %h{[<a b>]}

[15:59] <pmichaud> 3

[15:59] <pmichaud> spectesting now

[16:00] <masak> pmichaud++

[16:04] <masak> moritz: oh, you meant the spec-destroying sledgehammer, not the rakudo-breaking sledgehammer ;)

[16:04] * masak has too many sledgehammers nowadays

[16:05] <pmichaud> how can someone have too many sledgehammers?

[16:05] <moritz> masak: well, not destroying, I hope. Just removing some loose parts :-)

[16:05] <moritz> pmichaud: if they don't fit into the bike shed anymore, you have a problem :-)

[16:05] <pmichaud> "cruft-removing"

[16:06] <moritz> p6: my @a; @a.assign: 1, 2, 3; say @a

[16:06] <p6eval> niecza v15-6-gefda208: OUTPUT«Unhandled exception: Unable to resolve method assign in class Array␤  at /tmp/YS__OqrSFJ line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65) ␤  at /hom…

[16:06] <p6eval> ..rakudo 4373f0: OUTPUT«Method 'assign' not found for invocant of class 'Array'␤  in block <anon> at /tmp/rdZgpdAQbb:1␤␤»

[16:06] <p6eval> ..pugs: OUTPUT«*** No such method in class Array: "&assign"␤    at /tmp/ocWZZFviX2 line 1, column 8-26␤»

[16:06] <pmichaud> moritz: depends on the color of the bikeshed, I think.  Besides, you might have enough to completely construct a new bikeshed out of sledgehammers, assuming also that they're the right color.

[16:06] <moritz> p6: my @a; @a.STORE: 1, 2, 3; say @a

[16:06] <p6eval> rakudo 4373f0: OUTPUT«1 2 3␤»

[16:06] <p6eval> ..niecza v15-6-gefda208: OUTPUT«Unhandled exception: Unable to resolve method STORE in class Array␤  at /tmp/OYYOlFsj63 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65) ␤  at /home…

[16:06] <p6eval> ..pugs: OUTPUT«*** No such method in class Array: "&STORE"␤    at /tmp/1CXlfIsbC7 line 1, column 8-25␤»

[16:08] <dalek> rakudo/nom: f911bae | pmichaud++ | src/core/operators.pm:

[16:08] <dalek> rakudo/nom: Remove unused generate() function.

[16:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f911baeef1

[16:08] <dalek> rakudo/nom: 2c9f46f | pmichaud++ | src/core/Any.pm:

[16:08] <dalek> rakudo/nom: Don't treat scalar Positionals as slices.  Fixes RT #112362.

[16:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2c9f46fa09

[16:11] <masak> if you think of it as "cruft-removing", not "destroying", consider using a different name for the tool you're doing it with than "sledgehammer" :P

[16:12] <moritz> high-power LASER?

[16:12] <moritz> chain saw?

[16:12] <masak> :)

[16:12] <[Coke]> pickaxe

[16:12] <pmichaud> sledgescalpel

[16:13] <pmichaud> +3 scalpel of cruft-removal

[16:13] <masak> pmichaud++ # always makes up the coolest tools

[16:13] <moritz> pmichaud++ indeed

[16:14] <pmichaud> high-pressure spec washer

[16:15] <PerlJam> a "sledgescalpel" sounds like a katana to me.

[16:15] <pmichaud> spec-katana

[16:15] <moritz> pmichaud: did your spectest run with that patch find any passing TODO tests?

[16:15] <pmichaud> oh, yeah, it did.  in uniq.t

[16:16] <moritz> spec-tacular

[16:16] <moritz> maybe deserves more direct coverage

[16:16] <pmichaud> yes, I think more direct coverage is appropriate.

[16:16] <pmichaud> afk, lunch

[16:16] <moritz> I'll look into it 

[16:18] *** sudokode left
[16:19] *** HarryS left
[16:21] <moritz> std: sub foo() { }; foo.[]

[16:21] <p6eval> std 1ad3292: OUTPUT«ok 00:00 42m␤»

[16:25] *** HarryS joined
[16:26] <dalek> specs: 392d905 | moritz++ | S03-operators.pod:

[16:26] <dalek> specs: [S03] remove postfix parsing constraint

[16:26] <dalek> specs: review: https://github.com/perl6/specs/commit/392d905718

[16:26] <moritz> "If the next item after the list operator is either an infix operator

[16:26] <moritz> or a term, a syntax error is reported.  "

[16:26] <moritz> I'm not allowed to use a term after a listop?

[16:26] <moritz> say 1; # forbidden

[16:26] <moritz> :-)

[16:27] <moritz> std: sub foo() { }; foo+1

[16:27] <p6eval> std 1ad3292: OUTPUT«ok 00:00 42m␤»

[16:27] <moritz> p6: sub foo() { }; foo+1

[16:28] <p6eval> rakudo 4373f0: OUTPUT«use of uninitialized value of type Nil in numeric context␤»

[16:28] <p6eval> ..pugs, niecza v15-6-gefda208:  ( no output )

[16:28] <moritz> p6: sub foo($) { }; foo$_

[16:28] <p6eval> rakudo 4373f0: OUTPUT«===SORRY!===␤Confused␤at /tmp/QroLrQ8mF3:1␤»

[16:28] <p6eval> ..niecza v15-6-gefda208: OUTPUT«===SORRY!===␤␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/u8HuGH8Fs_ line 1:␤------> sub foo($) { }; foo⏏$_␤␤Parse failed␤␤»

[16:28] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ")"␤    expecting formal parameter␤    at /tmp/XPQAnP1el6 line 1, column 10␤»

[16:28] <moritz> well, that's incosistent

[16:29] <moritz> if "listop with args requires whitespace or parens" holds, whe isn't foo+1 forbidden?

[16:34] <dalek> specs: 28401ee | moritz++ | S03-operators.pod:

[16:34] <dalek> specs: [S03] update to current parsing reality (postfix after listop)

[16:34] <dalek> specs: review: https://github.com/perl6/specs/commit/28401eef20

[16:36] *** wooden_ left
[16:37] <moritz> p6: say (0 && 0).perl

[16:37] <p6eval> pugs, rakudo 4373f0, niecza v15-6-gefda208: OUTPUT«0␤»

[16:37] <moritz> p6: say (0 && 0, ).perl

[16:37] <p6eval> pugs, rakudo 4373f0: OUTPUT«(0,)␤»

[16:37] <p6eval> ..niecza v15-6-gefda208: OUTPUT«(0, )␤»

[16:37] <moritz> S03 says: The C<&&> and C<||> operators are smarter about list context

[16:37] <moritz> and return C<()> on failure in list context rather than C<Bool::False>.

[16:37] <moritz> The operators still short-circuit, but if either operator would return

[16:37] <moritz> a false value, it is converted to the null list in list context so

[16:37] <moritz> that the false results are self-deleting.  

[16:38] <moritz> fossil from the want() days?

[16:42] * [Coke] suspects he needs to update his spec test runs to do pugs/rakudo/niecza sequentially, not in parallel

[16:44] <dalek> specs: ebb02bc | moritz++ | S03-operators.pod:

[16:44] <dalek> specs: [S03] remove fossil from back when we had want()

[16:44] <dalek> specs: review: https://github.com/perl6/specs/commit/ebb02bcb00

[16:44] <dalek> specs: 7bd51c7 | moritz++ | S03-operators.pod:

[16:44] <dalek> specs: [S03] more idiomatic usage of junctions

[16:44] <dalek> specs: review: https://github.com/perl6/specs/commit/7bd51c71dc

[16:49] <moritz> p6: 1 > 2 > die("never reached")

[16:49] <p6eval> pugs, rakudo 4373f0, niecza v15-6-gefda208:  ( no output )

[16:50] <dalek> specs: 9dc9676 | moritz++ | S03-operators.pod:

[16:50] <dalek> specs: [S03] fix layout of ASCII table

[16:50] <dalek> specs: review: https://github.com/perl6/specs/commit/9dc9676214

[16:52] <lichtkind> want is gone?

[16:53] <moritz> long

[16:54] <moritz> removed Mon Jul 27 18:54:44 2009 +0000

[16:54] <moritz> which is almost 3 years ago

[16:54] <lichtkind> moritz: missed that , im not  always around

[16:54] <lichtkind> and replaced by what?

[16:55] <moritz> lichtkind: by objects that react smartly to contextualizers

[16:57] <lichtkind> moritz: thanks

[17:00] <moritz> std: sub foo :($a, $b) { }

[17:00] <p6eval> std 1ad3292: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/SR_eTR5ktx line 1:␤------> sub foo :($a, ⏏$b) { }␤  $a is declared but not used at /tmp/SR_eTR5ktx line 1:␤------> sub foo :(⏏$a, $b) { }␤ok 00:00 41m␤»

[17:02] <moritz> this concludes my skimming of S03.

[17:09] *** jaffa4 joined
[17:09] <jaffa4> hi'

[17:10] <jaffa4> how to get the enviromental variable in perl 6?

[17:10] *** nif left
[17:11] <TimToady> %*ENV

[17:12] <sorear> good * #perl6

[17:12] <[Coke]> jaffa4: FYI, you can search through the synopses:

[17:12] <[Coke]> https://www.google.com/search?ie=UTF-8&oe=UTF-8&domains=perlcabal.org&sitesearch=perlcabal.org%2Fsyn%2F&q=environment+variables&btnG=Google+Search+the+Synopses

[17:14] <[Coke]> (though to be fair, %*ENV is not immediately obvious from that search)

[17:15] <[Coke]> # 04/09/2012 - rakudo++ ; niecza (95.33%); pugs (40.08%)

[17:15] <[Coke]> "niecza",     20350,     1,   749,  1530, 22630, 24118

[17:15] <[Coke]> "pugs"  ,      8556,     2,  3226,  1635, 13419, 23979

[17:15] <[Coke]> "rakudo",     21345,    31,   638,  1888, 23902, 24128

[17:15] <jaffa4> Is pugs still developed?

[17:16] <benabik> It's more developed again than still.

[17:16] <sorear> jaffa4: It's been picked up in the last month or two

[17:17] <jaffa4> SO there are three more developed implementations of Perl 6 at the moment then

[17:17] <sorear> it was only passing like 5% of the spectests at the beginning of the year

[17:17] <[Coke]> I'm not sure where that 5% number keeps coming from.

[17:17] <jaffa4> and now is it 40%?

[17:18] <sorear> [Coke]: memory

[17:19] <TimToady> that's 40% of what rakudo passes, not 40% of all the tests, I believe

[17:21] <jaffa4> while (<dic>) , how to translate that?

[17:22] <TimToady> for $dic.lines

[17:22] <[Coke]> sorear: https://gist.github.com/1476841#file_perl6_pass_rates - line 190

[17:22] <TimToady> assuming you did my $dic = open "filename"

[17:22] *** wolfman2000 left
[17:22] <jaffa4> yes, assuming.

[17:23] <[Coke]> anyway, pugs hasn't been under active dev for some time, but au++ has kept it building, which means we can fudge the spec tests so that pugs can run them and we can see what DOES need to be changed/added/removed (a lot)

[17:23] <TimToady> though if you really hate the sigil you can theoretically now do 'my \dic = open...' and then dic.lines

[17:24] <[Coke]> (some of that 40% does come from patches to Pugs, rather than spectestfudging)

[17:24] <TimToady> and probably even works in niecza

[17:24] <TimToady> n: my \foo = $*IN; for foo.lines { .say }

[17:24] <p6eval> niecza v15-6-gefda208: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil…

[17:25] <TimToady> r: my \foo = $*IN; for foo.lines { .say }

[17:25] <p6eval> rakudo 4373f0: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/HCuZOUHXQH:1␤»

[17:25] <benabik> ...  What does p6eval attach to $*IN?

[17:26] <TimToady> .au national anthem

[17:26] <sorear> .at

[17:26] <TimToady> yeah that

[17:26] <sorear> .au's would be in English

[17:26] <TimToady> I thought it was Strine

[17:28] <jaffa4> This compiles  for (<dic>) {, I wonder why

[17:28] <sorear> strange, just checked my email this morning and I seem to have received the entire 20+ message Parrot packaging thread overnight

[17:28] <benabik> n: <dic>.perl.say

[17:28] <p6eval> niecza v15-6-gefda208: OUTPUT«"dic"␤»

[17:28] <sorear> jaffa4: why shouldn't it?  (<dic>) is an acceptable if somewhat weird 1-element list literal

[17:29] <[Coke]> I'm assuming some of those postings were delayed because <not subscriber>. maybe.

[17:29] *** nif joined
[17:30] <sorear> [Coke]: you didn't start running the comparisons until after pugs had been improved a bit

[17:31] *** Radium joined
[17:31] <TimToady> n: while (<dic>) {...}

[17:31] <p6eval> niecza v15-6-gefda208: OUTPUT«===SORRY!===␤␤This appears to be Perl 5 code at /tmp/xay84Orrk7 line 1:␤------> while ⏏(<dic>) {...}␤␤Parse failed␤␤»

[17:32] <benabik> std: for (<dic>) {...}

[17:32] <p6eval> std 1ad3292: OUTPUT«ok 00:00 41m␤»

[17:32] <TimToady> 'course, that looks like both P5 and P6 code...

[17:32] <benabik> true

[17:32] *** havenn joined
[17:33] <TimToady> but we could outlaw that form specially, I suppose

[17:33] <moritz> though the more idiomatic p6 code would be loop { ... }

[17:33] <TimToady> std: do {...} while 1;

[17:33] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Unsupported use of do...while; in Perl 6 please use repeat...while at /tmp/rM5VRcvzvH line 1:␤------> do {...} while 1⏏;␤Parse failed␤FAILED 00:00 41m␤»

[17:33] <TimToady> like that is

[17:33] <moritz> since <dict>.Bool is always true

[17:33] <benabik> "don't iterate over a one element list"?

[17:33] <TimToady> with parens

[17:34] <TimToady> with a single identifier element

[17:34] <moritz> benabik: well, while-iterating a constant, one element list isn't very intelligent

[17:34] <TimToady> more interesting would be trying to detect use of globs

[17:35] <TimToady> moritz: thing is, <HANDLE> inside a for is also somewhat idiomatic P5

[17:35] <sorear> n: say ?<0>

[17:35] <p6eval> niecza v15-6-gefda208: OUTPUT«False␤»

[17:36] <TimToady> hard to know when to knock the training wheels off the bike...

[17:36] *** tarch left
[17:36] *** tarch joined
[17:37] <sjohnson> heh

[17:37] <sorear> I at least was taught very early to always write that while(defined($_ = <HANDLE>)) and never for(<HANDLE>) because the latter takes O(N) space

[17:42] <moritz> TimToady: what do you think of my proposal to remove named unary prefix (or at least don't put any operator into that category by default)?

[17:42] *** tomaw joined
[17:44] <[Coke]> seen au?

[17:44] <aloha> au was last seen in #perl6 5 days 4 hours ago saying "rehi pmichaud! \o </timeDilatedConversation>".

[17:45] <TimToady> moritz: still thinking about it

[17:45] <moritz> TimToady: ok

[17:48] <TimToady> would probably force temp/let to be parsed as pseudo-declarators with pseudo-assignments if we went that direction, since listops are too loose to be the target of an assignment

[17:49] <TimToady> and I still wonder whether there aren't a bunch of trig functions that mathematically minded people will think of as unaries

[17:49] <TimToady> but I can see the arguments for simplification too

[17:49] *** nif left
[17:51] <jaffa4> What does this do $*ENV{FOO}?

[17:52] <TimToady> calls the FOO function

[17:52] <diakopter> moritz: typo in 392d90

[17:52] <TimToady> and then fails to find $*ENV, since it's %*ENV

[17:52] <TimToady> actually, does that first

[17:52] <TimToady> or wait, it's dynamic, so no

[17:53] <moritz> TimToady: I'm OK with special-casing let and temp, it needs to be more than a simple listop anyway

[17:53] <TimToady> you want %*ENV<FOO>

[17:53] <jaffa4> just wonder what the old syntax does

[17:53] <TimToady> fails two ways :)

[17:55] *** Trashlord joined
[17:59] *** sudokode joined
[18:14] *** wolfman2000 joined
[18:14] <moritz> TimToady: if we define prefix:<sin>, then 'sin $x' works, but 'sin($x)' stops working, unless we break the rules

[18:15] <moritz> (either the rule that name + () is always a normal sub call, or we provide both &sin and prefix:<sin>, which makes overloading for user defined types harder again)

[18:17] *** pernatiy left
[18:17] <TimToady> this seems to be confusing two different issues

[18:18] <TimToady> we might want to unify the parsing of anything that starts with an identifier a bit more than we do

[18:19] <TimToady> if prefix:<sin> calls sin() because it's an identifier, then the unariness of it would be independent of the naming issue

[18:19] <TimToady> it goes back to that "how keywordy are the keywords anyway?" issue

[18:20] <moritz> but then what happens if there's prefix:<sin> and a &sin?

[18:20] <TimToady> and unifying ident parsing might speed up the parser too

[18:20] <TimToady> in that case you'd either get shadowing or illegal redefinition, I suppose

[18:21] <TimToady> but anyway, it's not a trivial decision :)

[18:21] <jaffa4> rakudo: ~[**] 5, 4

[18:21] <p6eval> rakudo 4373f0:  ( no output )

[18:21] <jaffa4> rakudo: print ~[**] 5, 4

[18:21] <p6eval> rakudo 4373f0: OUTPUT«625»

[18:21] <moritz> well, the shadowing would lead to different semantics

[18:21] <moritz> than you're used to

[18:21] <jaffa4> rakudo: print ~[**] 2,3

[18:21] <p6eval> rakudo 4373f0: OUTPUT«8»

[18:22] <jaffa4> rakudo: print ~[**] 2,3,2

[18:22] <p6eval> rakudo 4373f0: OUTPUT«512»

[18:22] <moritz> say sin pi, 6; # 06

[18:22] * TimToady wonders how much of a niecza's DFA tables are dedicated to parsing identifiers...

[18:22] <moritz> sub sin($x) { $x.sin }; say sin pi, 6 # dispatch failure

[18:22] <moritz> that's not very intuitive

[18:22] <jaffa4> TimToady: because?

[18:23] <moritz> I think that, independently of identifier unificiation, having some builtins as prefix ops and others as listops is a can of worms

[18:24] <PerlJam> moritz: I 100% agree, fwiw

[18:26] <TimToady> jaffa4: it is not clear to me which thing you're asking about

[18:28] <jaffa4> my mistake, my question was out of place.

[18:28] <TimToady> why does [**] behave as it does?  why do I wonder things?  why do I wonder that particular thing? :)

[18:29] *** estrabd joined
[18:29] *** brrt joined
[18:30] *** Trashlord left
[18:31] <jaffa4> rakudo: print ~[+] 1,3,4,5

[18:31] <p6eval> rakudo 4373f0: OUTPUT«13»

[18:31] <jaffa4> rakudo: print [+] 1,3,4,5

[18:31] <p6eval> rakudo 4373f0: OUTPUT«13»

[18:32] <jaffa4> What does ~ do?

[18:32] <moritz> jaffa4: see S03

[18:32] <TimToady> stringifies, but that's redundant with print

[18:32] <PerlJam> jaffa4: you should learn about leading ~, + and ?   They're quite useful.

[18:32] *** havenn left
[18:33] <moritz> and you should read S03. It's very useful.

[18:34] <jaffa4> You know about the complains that C++ is complicated , what will they about Perl 6?

[18:34] <jaffa4> not a problem for me, just saying

[18:35] <PerlJam> jaffa4: "I'm so glad Perl 6 isn't like C++!"

[18:35] <TimToady> or "I wish Perl 6 ran as fast as C++..."

[18:36] <pmichaud> "I wish I could code C++ as fast as I can code Perl 6"  :-P

[18:36] <colomon> I wish I could code C++ as easily / tersely as I can code Perl 6.

[18:37] <colomon> (That's what I say now.)

[18:37] *** nif joined
[18:38] <colomon> That is to say, C++ lets you do some very powerful stuff, but it invariably takes at least 5x the code it would take to do it in Perl 6.  

[18:38] <PerlJam> "Any comparison betwen Perl 6 and C++ fails to do Perl 6 justice"

[18:38] <colomon> On the other hand, I wish Perl 6 were as fast as C++.  :)

[18:38] <moritz> ""Any comparison betwen Perl 6 and C++ fails to do C++ injustice"

[18:39] <PerlJam> moritz++

[18:39] <pmichaud> Perl 6 *is* as fast as C++, it's only the implementations of Perl 6 that are slower.

[18:40] <timotimo> :D

[18:41] *** Araq joined
[18:42] <pmichaud> > say ~(1, 2, 4 ... *)

[18:42] <pmichaud> 1 2 4 8 ...

[18:42] <[Coke]> moritz: I have a version of so that works for "say so 3", but fails on "ok(so 3,'whee')" with a multi error.

[18:43] <moritz> r: use Test; ok(so 3, 'whee')

[18:43] <p6eval> rakudo 4373f0: OUTPUT«===SORRY!===␤Twigil-Variable constants not yet implemented. Sorry. ␤at lib/Test.pm6:3␤»

[18:43] <moritz> eeks

[18:43] <[Coke]> wow!

[18:43] <pmichaud> > say ~(1, 2, 6 ... *)

[18:43] <pmichaud> Unable to decude sequence

[18:43] <moritz> [Coke]: then you have probably defined it as a subroutine/listop, not as a prefix

[18:44] <moritz> pmichaud++

[18:44] * pmichaud fixes typo in exception message

[18:44] <[Coke]> moritz: \o/

[18:45] <dalek> rakudo/nom: 5f7a220 | pmichaud++ | src/core/Exception.pm:

[18:45] <dalek> rakudo/nom: Fix typo:  decude => deduce.

[18:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5f7a220517

[18:45] <[Coke]> $ ./pugs -MTest -e 'ok(so 1,"whee")'

[18:45] <[Coke]> ok 1 - whee

[18:45] <pmichaud> however...

[18:45] <pmichaud> > say ~( 1, 2, 6 ... *)

[18:45] <pmichaud> Unable to decude sequence

[18:45] <pmichaud> > say ~(0, 1, 2, 6 ... *)

[18:45] <pmichaud> 0 1 2 6 ...

[18:45] <dalek> specs: e8e8192 | moritz++ | S03-operators.pod:

[18:45] <dalek> specs: [S03] grammar; diakopter++

[18:45] <dalek> specs: review: https://github.com/perl6/specs/commit/e8e8192d51

[18:45] <tadzik> r: say so Cool

[18:45] <p6eval> rakudo 4373f0: OUTPUT«False␤»

[18:48] <dalek> Pugs.hs: 2512b2d | coke++ | / (2 files):

[18:48] <dalek> Pugs.hs: Add basic "so" && run spectest

[18:48] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/2512b2da72

[18:48] <[Coke]> evalbot: rebuild pugs

[18:48] <[Coke]> p6eval: help?

[18:48] <p6eval> [Coke]: Usage: <(star|pugs|nqp|b|std|niecza|rakudo|nom|p|n|r)(?^::\s) $perl6_program>

[18:48] <tadzik> evalbot rebuild pugs

[18:48] <p6eval> OK (started asynchronously)

[18:48] *** birdwindupbird joined
[18:48] <[Coke]> ah, thanks.

[18:49] <moritz> won't work.

[18:49] <moritz> the rebuild infrastructure isn't up yet

[18:49] <moritz> I really need to do that tonight

[18:49] <[Coke]> aw, sadface!

[18:51] <[Coke]> moritz: you added the opcode, but the opcode by itself is only available internally, I think. had to expose it with the second line in https://github.com/perl6/Pugs.hs/commit/2512b2da720f9a7041736eb0b791858fe9912103

[18:51] <[Coke]> and I had originally copied the line above with "spre" - your hint led me to "pre".

[18:51] <[Coke]> moritz++

[18:54] <moritz> [Coke]: glad it helped :-)

[18:58] <dalek> rakudo/nom: 3bd91f5 | pmichaud++ | src/core/Any.pm:

[18:58] <dalek> rakudo/nom: Force .join to reify at least 4 elements of a list (if available).

[18:58] <dalek> rakudo/nom: 

[18:58] <dalek> rakudo/nom: This should help with infinite lists that currently produce "..."

[18:58] <dalek> rakudo/nom: -- now it will at least produce the first four elements of such a list.

[18:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3bd91f5b80

[18:58] <pmichaud> to me, 3bd91f5 is a code smell, but we'll put it in for now anyway.

[18:59] *** xenu left
[18:59] <moritz> pmichaud: why? because it hardcodes a constant?

[19:00] <pmichaud> and 4 is a little arbitrary

[19:00] <pmichaud> and it doesn't help when the infinite part is more than four elements from the beginning

[19:00] <pmichaud> > say ~(<a b c d>, 1, 2 ... *)

[19:00] <pmichaud> a b c d ...

[19:03] *** havenn joined
[19:06] <dalek> roast: a3a3d3d | moritz++ | S02-types/flattening.t:

[19:06] <dalek> roast: RT #112362, arrays in hash and array slices

[19:06] <dalek> roast: review: https://github.com/perl6/roast/commit/a3a3d3d218

[19:06] *** wolfman2000 left
[19:07] <pmichaud> I will admint that  "a b c d ..."  is at least a little better than "...", but it still feels misleading.

[19:07] <pmichaud> *admit

[19:07] <moritz> yes, better solutions are always welcome :-)

[19:07] <moritz> if we just knew how many items we could reify effortlessly...

[19:08] <pmichaud> it also depends on the meaning of "effortless"  :-)

[19:10] <dalek> evalbot: 94851d9 | moritz++ | build.pl:

[19:10] <dalek> evalbot: copy stuff to feather3 after building

[19:10] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/94851d96f1

[19:14] <moritz> wow, the network connection to feather is really laggy

[19:14] <tadzik> yeah

[19:19] *** brrt left
[19:21] <dalek> evalbot: e6fe2ea | moritz++ | build.pl:

[19:21] <dalek> evalbot: fix thinko

[19:21] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/e6fe2ea0f8

[19:23] <moritz> when I do rsync via ssh, can I surpress the message of the day (motd) that ssh prints?

[19:23] <moritz> s/can/how can/

[19:23] <moritz> sorry for off-topic, but necessary for the evalbot stuff

[19:24] <TimToady> well, my rsync manpage talks about --no-motd

[19:25] <moritz> ah, nice.

[19:25] <moritz> I've search the ssh manpage so far

[19:25] <moritz> pugs: say so 1

[19:25] <p6eval> pugs: OUTPUT«1␤»

[19:25] <moritz> pugs: say so 1, 2

[19:25] <p6eval> pugs: OUTPUT«12␤»

[19:25] *** nif is now known as boy``

[19:26] <dalek> evalbot: ca2838e | moritz++ | sync.pl:

[19:26] <dalek> evalbot: no motd for rsync copying

[19:26] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/ca2838e3d7

[19:27] *** estrabd left
[19:27] *** estrabd joined
[19:29] *** estrabd left
[19:29] *** sunnavy left
[19:29] *** estrabd joined
[19:30] <masak> sorear: not writing 'for (<HANDLE>)' is sage advice in Perl 5 -- for exactly the reason you specify. but the reason ceases to hold in Perl 6, and that's why we write it again. :)

[19:30] <masak> I don't expect that this will be news to you in any way whatsoever.

[19:30] <masak> but it might be for others.

[19:30] <masak> lazy lists makes 'for $fh.lines' the natural idiom in Perl 6.

[19:31] <masak> I realized this back in 2008, while writing November, and submitting dozens of bug reports.

[19:32] *** tarch left
[19:33] <masak> one of my earliest tickets was about using 'while' instead of 'for': https://rt.perl.org/rt3/Ticket/Display.html?id=57226

[19:35] *** boy`` is now known as girl``

[19:35] *** girl`` is now known as car``

[19:36] <[Coke]> recent feather slowness was probably me. (autounfudge pugs dangerous)

[19:36] <masak> p6: class A { my $.x = 7; say $.x }

[19:36] <p6eval> pugs: OUTPUT«*** Undeclared variable: ("$__SELF__",MkPad (padToList [("$_",PELexical {pe_type = (mkType "Scalar"), pe_proto = <Scalar:0xf6d87055>, pe_flags = MkEntryFlags {ef_isContext = True}, pe_store = <ref:0xf6d8fbb5>}),("@_",PELexical {pe_type = (mkType "Array"), pe_proto = <Array:…

[19:36] <p6eval> ..niecza v15-6-gefda208: OUTPUT«===SORRY!===␤␤Variable $.x used where no 'self' is available at /tmp/jtk2jdOd09 line 1:␤------> class A { my $.x = 7; say ⏏$.x }␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 136…

[19:36] <p6eval> ..rakudo 4373f0: OUTPUT«===SORRY!===␤Variable $.x used where no 'self' is available␤at /tmp/fO0hUvwsvF:1␤»

[19:36] <masak> r: class A { my $.x = 7; say $.x }

[19:36] <p6eval> rakudo 4373f0: OUTPUT«===SORRY!===␤Variable $.x used where no 'self' is available␤at /tmp/RPGnuPfYFR:1␤»

[19:36] * masak updates https://rt.perl.org/rt3/Ticket/Display.html?id=59118

[19:37] <masak> can we talk about this one a bit? I just noticed it's my oldest submitted ticket which is still open. :)

[19:38] *** havenn left
[19:38] *** car`` is now known as nough``

[19:38] <masak> please read through the ticket thread if you want to participate. notice that it's about 'my $.a', not 'has $.a'.

[19:38] <masak> the issue at hand is something like "directly in the class body, what does 'self' mean?"

[19:38] <moritz> std: class A { my $.x; say $.x }

[19:38] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Variable $.x used where no 'self' is available at /tmp/IUpM5zUn4X line 1:␤------> class A { my $.x; say ⏏$.x }␤Check failed␤FAILED 00:00 42m␤»

[19:39] <masak> or, hm. maybe the question is not like that.

[19:39] <masak> somewhere halfway through the thread, the thing about 'my $.b = x($.a)' comes up.

[19:39] <moritz> the question is really "why the blody heck do we allow 'my' plus a variable syntax that is tyed to a class, not to a lexical scope?"

[19:40] <moritz> it's just wrong(tm)

[19:40] <masak> oh right, moritz and I disagreed on this point last time we talked about it.

[19:40] <masak> now I remember.

[19:40] <masak> we basically have two different self-consistent mental factorings of the solution space.

[19:41] <moritz> in your mental model, does the $.x desguar to self.x too?

[19:41] <masak> yes.

[19:41] <masak> can we avoid the question of 'my' and dot syntax for the moment?

[19:41] <masak> it's not essential for the discussion I want to have.

[19:41] <moritz> yes, we can, if forget about the ticket too :-)

[19:41] <masak> no, the ticket is slightly different.

[19:41] <moritz> *if we forget

[19:42] <masak> and I believe having 'self' be defined in the class body is defendable, useful, and worthwhile.

[19:42] <masak> b: class A { say self }

[19:42] <p6eval> b 922500: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/bX8QyJyqVN:22)␤»

[19:42] <masak> alpha: class A { say self }

[19:42] <moritz> and it would simply be the type object?

[19:42] <masak> yes.

[19:43] <moritz> TimToady: --no-motd did not work :/

[19:43] <masak> I believe it was, at some point or other, in rakudo.

[19:43] <moritz> motd still printed

[19:43] <moritz> masak: I agree that a point can be made for it

[19:44] <moritz> masak: though I also want to note that we compose our classes later than we did in the 'alpha' days

[19:44] <benabik> I think --no-motd is only for rsync daemons, not SSH connections.

[19:44] <masak> that's a fair point but ultimately not a show-stopper.

[19:44] <masak> 'A' is defined from 'class A {' and onwards.

[19:44] <moritz> masak: so the chances to get useful behavior out of using 'self' in a partially constructed class

[19:44] <moritz> masak: agreed

[19:45] <masak> and composition only changes the symbol slightly by doing various hand-wavey fixup thingies.

[19:45] <moritz> ... are lower

[19:45] <moritz> like, adding superclasses and roles

[19:45] <masak> class A { my $x = 2; my $y = 2 * $x } # perfectly defined

[19:46] <masak> class A { my $.x = 2; my $.y = 2 * $.x } # should also be OK, IMO

[19:46] *** nough`` is now known as nif

[19:46] <moritz> just think about what that implies

[19:46] <moritz> it implies that 'my $.x' installs a public method x

[19:46] <masak> right.

[19:46] <moritz> and some storage inside the class

[19:47] <moritz> so it's not 'my' anymore at all

[19:47] <moritz> it's available from outside the class

[19:47] <masak> waitwait.

[19:47] <masak> so are 'has $.x' variables.

[19:47] <masak> "it's not 'private' anymore at all" -- same argument.

[19:47] <masak> look, we're having this discussion again anyway...

[19:47] <masak> :)

[19:47] <moritz> yes. That's what 'has' means. But 'my' means 'only available inside this lexical scope'

[19:48] <masak> 'has' means "declare me an instance-private container". 'my' means "declare me a scope-private container".

[19:48] <masak> how you choose to share them by other means is up to you.

[19:48] <masak> binding can break encapsulation too.

[19:48] <masak> so can passing arguments to a routine.

[19:48] <moritz> masak: yes, of course we're having this discussion. This discussion comes up every time this ticket is being discussed, because we have some problems implementing stuff that violates principles that hold everywhere else in the specs

[19:49] <moritz> well, 'my' is always related to lexcical scopes.

[19:49] <moritz> Except in that one single case

[19:49] <masak> I'm not aware what principles those would be. I don't see the inconsistencies you seem to see.

[19:50] <moritz> that a 'my' creates something which is very visible from outside the block is declared in

[19:50] <masak> I kinda like the way the spec factors this. I would just like it to be fully consistent in the way this ticket proposes.

[19:50] <masak> moritz: hm, but it's like these are two different axes, and that's why I don't have a problem with it.

[19:50] <masak> moritz: 'has $.foo' = private attr + accessor. 'my $.bar' = lexical var + accessor.

[19:51] <masak> clearly that's the way the things in S12 were meant.

[19:51] <moritz> the difference is that that in 'has $.foo', the accessor is also has-scoped

[19:51] <moritz> if we could make accessors in 'my $.x' also lexically scoped, I'd be fine

[19:52] *** Araq left
[19:52] <masak> yeah, but we both know that makes no sense. :)

[19:52] <moritz> but then '$.x' would mean different things depending on whether we had 'my $.x' predeclared or not

[19:52] <moritz> masak: which is why I'm against that whole thing

[19:52] <masak> because you feel it's not a smooth, consistent feature surface.

[19:53] <moritz> correct

[19:53] <moritz> I feel it violates the current simplicity of the 'my' declarator

[19:54] <masak> yeah. I think I understand your argument -- and I think I did last time, too.

[19:54] <masak> I basically disagree on that feeling, that it somehow violates the simplicity of 'my'.

[19:54] <moritz> I understand yours too, I just don't share them

[19:54] <moritz> I guess that, again, we have to agree to disagree

[19:55] <moritz> if we could just find a syntax for class attributes that is more coherent with the rest of the design...

[19:57] <masak> I just went off looking for a blog post I wrote years ago. about class attributes.

[19:57] <masak> that was the day I felt I understood them.

[19:57] <moritz> can't we just use   has $|foo;  to be a class attribute?

[19:57] <masak> eek

[19:57] <moritz> then it's tied to the class, and not to a lexical scope

[19:57] <masak> but this is my point -- and perhaps the core of our disagreement -- I deeply *like* that Perl 6 doesn't have real class attributes.

[19:57] <masak> that it re-uses 'my' (and 'our') for storing things "at class level".

[19:58] <moritz> then use class A { has $x }

[19:58] <masak> what? no.

[19:58] <moritz> erm, s/has/my/

[19:58] <masak> that's just a private attribute without a twigil.

[19:58] <moritz> sorry, bad concentration

[19:58] <masak> sure, if I don't care about the accessor I will write 'my $x'. of course.

[19:58] <moritz> oh, one more thing

[19:58] <masak> but it's kinda nice that I can still choose to get the accessor.

[19:59] <moritz> how do you assign new values to a 'my $.x' variable?

[19:59] <masak> I think this might be one of the *very* few contientious areas of the spec. we should treat carefully.

[19:59] <masak> in the sense that if you go in and just change something indiscriminately there, we might have an edit war on our hands.

[19:59] <masak> that's not a threat, just an observation. ;)

[19:59] <moritz> well, I think it's really a symptom of a more general design problem

[20:00] <masak> I genuinely, deeply *like* the way things are factored in the spec.

[20:00] <masak> I don't think it's a symptom of deeper problems.

[20:00] <masak> I think it's a neat unification/simplification.

[20:00] <masak> the only thing is that I wish that 'self' would be defined and mean 'type object' in the class scope, too.

[20:00] <moritz> you can't expect  class { my $.x; $.x = 3 } to work, unless you either break how $.x is looked up, or by implicitly generating an rw-accessor

[20:01] <masak> oh, troo.

[20:01] <masak> that's a new point. hadn't thought of that.

[20:01] <masak> I'm fine with that being illegal, though.

[20:01] <moritz> so, how would assign a new value to such a variable?

[20:02] <masak> shouldn't go assigning to accessors that weren't explicitly made rw.

[20:02] <masak> moritz: the usual way. at declaration.

[20:02] <masak> that's fine with 'has $.x = 2' too, no?

[20:02] *** vlixes left
[20:02] <jnthn> evening from St\o/ckholm

[20:02] <masak> jnthn! \o/

[20:03] <moritz> masak: well, but that only gives you a constant. In the case of 'has $.x', you can assign to $!x

[20:03] <jnthn> Wow. It's hard to find an open restaurant here on an Easter Monday evening!

[20:03] <moritz> masak: do you want 'my $.x' to generate a '$!x' too, which is looked up specially?

[20:03] <masak> moritz: no.

[20:04] <masak> moritz: in the case of 'my $.x', you can assign to $x.

[20:04] <jnthn> my $.x just declares a my $x

[20:04] <masak> I really don't see that problem.

[20:04] <jnthn> our $.x just declares an our $x

[20:04] <jnthn> And then it installs an accessor

[20:04] <masak> moritz: feels like you're just doing yourself a disservice by refusing to see the parallels here.

[20:04] <moritz> masak: no, I just missed that 'my $.x' installed a 'my $x'

[20:04] <moritz> ok, then there's only a minor problem remaining

[20:04] <jnthn> See declare_variable iirc in Actions.pm, the branch for lexicals.

[20:05] <masak> er.

[20:05] <masak> I've been discussing with you all this time and you've been assuming there's no 'my $x'!?

[20:05] <masak> that... explains a lot.

[20:05] <masak> :)

[20:05] <jnthn> ...should I save myself backlogging this conversation? <grin>

[20:05] <masak> no, it's still interesting.

[20:05] <moritz> well, 'has $.x' also doesn't create an $x

[20:05] <masak> I might re-read it now.

[20:05] <masak> *sigh*

[20:05] <masak> moritz: please take a moment to re-adjust your world view.

[20:06] <masak> it really does make sense, I promise!

[20:06] *** leprevost left
[20:06] <moritz> masak: ok, I'll try

[20:06] <masak> thanks.

[20:06] <moritz> one more question

[20:06] <moritz> if I augment a class, can I assign to $x or $.x somehow?

[20:07] <masak> no, it's still a lexical, and the accessor's still read-only.

[20:07] <masak> in a way, you get lexical scope encapsulation.

[20:07] <masak> that's a feature, not a bug.

[20:07] <jnthn> nom: class Foo { my $.x; }; Foo.x = 42; say Foo.x;

[20:07] <p6eval> rakudo 3bd91f: OUTPUT«42␤»

[20:07] <moritz> ok. So it's not a "proper" class variable

[20:07] <masak> hrm.

[20:07] <jnthn> readonly, you say? :)

[20:07] <masak> moritz: no, and it never was.

[20:07] <masak> jnthn: arguably the accessor should be readonly.

[20:07] <jnthn> masak: Arguably.

[20:07] * masak submits an arguable rakudobug

[20:08] <jnthn> masak: Wait.

[20:08] * masak waits

[20:08] <jnthn> masak: Let me at least explain why it's the way it is.

[20:08] <moritz> ok, back to the original question

[20:08] <jnthn> What are you applying the "is rw" trait to in this case?

[20:08] <moritz> should we declare self implicitly in the class body?

[20:08] <moritz> I'm +0.5 on it

[20:08] <jnthn> Well, since it's a my, you've got no attribute meta-object.

[20:08] <masak> jnthn: the auto-created method.

[20:08] <jnthn> Which is what the rw is normally set on

[20:08] <masak> jnthn: just like with an accessor on a 'has' variable.

[20:09] <jnthn> masak: What is responsible for installing the accessor?

[20:09] <masak> jnthn: the... ClassHOW?

[20:09] <jnthn> masak: The ClassHOW doesn't know about lexicals. Wrong plane. :)

[20:09] <jnthn> masak: And the ClassHOW doesn't even install the ones for attributes.

[20:09] <moritz> Attribute does, no?

[20:09] <jnthn> masak: It calls .compose on Attribute, which is in charge of accessor generation.

[20:10] <masak> moritz: I feel like, we could disallow it for now and say that 'self' is illegal there, but 10 years down the line when Perl 6.1 is out we would still switch it on and have it mean the type object.

[20:10] <jnthn> I'm kinda -0.5 to self meaning the type object in the class body.

[20:10] <masak> jnthn: ok, I see what you mean, and I know lexicals don't have a HOW.

[20:10] <jnthn> masak: Yeah. And so the trait would just apply to the variable at the moment.

[20:10] <masak> jnthn: well then, what generates the accessor today?

[20:11] <jnthn> masak: Currently the actions just generate the PAST::Block that looks it up and code-objectify it and call .^add_method

[20:11] <masak> I'm not so worried about how to make the trait apply to the method. that can always be sugared to DTRT.

[20:11] <masak> jnthn: why are you -0.5 on self meaning the type object?

[20:11] <masak> jnthn: and did you read the RT ticket in the backlog? :)

[20:11] <jnthn> masak: Well, it's more that with "has" traits always apply to the Attribute meta-object, and it feels reasonable that traits with "my" should always apply to the container.

[20:12] <masak> granted.

[20:12] <moritz> but Scalar knows nothing about the surrounding class

[20:12] <moritz> so it has trouble installing an accessor in it, no?

[20:13] <jnthn> moritz: Thus why we cook the method up in the Actions rather than have something else do so.

[20:13] <masak> it's just, it feels more important to have 'is rw' latch on to the accessor, because that's what Least Surprise tells us will happen. so I'm willing to inject some magic/sugar there.

[20:13] <jnthn> masak: but then *every* trait would latch on to the accessor, not the variable, which is inconsistent with what traits on a "my" always do

[20:13] <jnthn> Whereas traits on a "has" - whatever the twigil - always latch on to the Attribute.

[20:14] <masak> hm.

[20:14] <jnthn> masak: It feels like we get to pick our symmetry. :)

[20:14] <masak> when you say "*every*", what set of things are you quantifying over?

[20:14] <masak> jnthn: yes, just like in my discussion with moritz++

[20:14] <jnthn> has <variable> <trait>+

[20:15] <jnthn> Every trait there

[20:15] <jnthn> As for your other questoin...

[20:15] <jnthn> Because has $.x = self # here self does *not* mean the type object, and there's no curlies to indicate the change of scope. It's confusing enough that self exists in the initializer. :)

[20:16] <jnthn> Without having it mean something else in the surrounding lexical scope.

[20:16] <masak> moritz: ah, here's the blog post: http://strangelyconsistent.org/blog/i-can-haz-constant

[20:16] <masak> it just had a silly name, so I couldn't grep for it easily ;)

[20:16] *** ashleydev left
[20:17] <masak> jnthn: not sure I agree... 'has' scope is special in exactly that way, that it "narrows" the meaning of 'self' from being the type object to being an instance.

[20:17] <masak> that's what 'has' *does*.

[20:17] <masak> so it's not so much a strange rule or exception, as a logical application of 'has' scoping.

[20:18] *** Radium left
[20:18] <masak> so it's not strange to me at all that 'my $x = self' and 'has $.x = self' will have very different views of 'self'.

[20:18] <jnthn> masak: Well, I did only -0.5 it, not -1 :)

[20:18] <masak> just like 'my $foo = BEGIN ...' will have a very different view of stuff too.

[20:19] <jnthn> nom: class Foo { has $.x, $.y; }

[20:19] <p6eval> rakudo 3bd91f: OUTPUT«===SORRY!===␤Variable $.y used where no 'self' is available␤at /tmp/vX7vvTlKrR:1␤»

[20:19] <jnthn> Also, the current rules catch this one. :)

[20:19] *** ashleydev joined
[20:19] <moritz> yes, we'd have to give up on that one if we made self the current class

[20:19] * pmichaud tries to catch up with backscroll... fails

[20:19] <jnthn> o/ pmichaud 

[20:20] *** Radium joined
[20:21] <masak> er.

[20:21] <lichtkind> moritz: how did you the 2 line git commit comment

[20:21] <masak> std: my $a, $b;

[20:21] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Variable $b is not predeclared (declarators are tighter than comma, so maybe your 'my' signature needs parens?) at /tmp/LN0ezudJjd line 1:␤------> my $a, ⏏$b;␤Check failed␤FAILED 00:00 42m␤»

[20:21] <masak> look at that parenthetical addendum.

[20:21] <masak> 'has' should clearly have something similar.

[20:22] <masak> std: class A { has $.x, $.y; }

[20:22] <p6eval> std 1ad3292: OUTPUT«===SORRY!===␤Variable $.y used where no 'self' is available at /tmp/rgYJMRx2r4 line 1:␤------> class A { has $.x, ⏏$.y; }␤Check failed␤FAILED 00:00 42m␤»

[20:22] <masak> TimToady: ^

[20:22] <jnthn> masak: Apart from that one *is* an error always. And $.y would not be.

[20:22] <masak> jnthn: yeahbut.

[20:22] <jnthn> masak: Though, we could probably find a way to make it an error.

[20:22] <masak> if you write code like that... :)

[20:22] <jnthn> ...somehow...

[20:22] <moritz> masak: note that 'has' has a tighter precedence than infix:<,>

[20:22] *** lichtkind_ joined
[20:22] <masak> moritz: so does 'my'.

[20:22] <moritz> right

[20:23] <masak> so. non-issue.

[20:23] <masak> just put in a better error message.

[20:23] <moritz> lichtkind: with my text editor :-)

[20:23] <moritz> lichtkind: also UNIX shell allow you to write multi linux arguments on the command line

[20:23] <moritz> git add File.pod

[20:24] <moritz> git commit -m 'some message <return><return>rest of message here'

[20:24] <masak> lichtkind: git allows you to write commit comments in $EDITOR.

[20:25] *** Radium left
[20:25] *** lichtkind left
[20:25] *** lichtkind_ is now known as lichtkind

[20:27] <masak> moritz: hm. I just re-read my blog post. it contains less of the insights I've had about 'my $.foo' than I remembered.

[20:27] <masak> basically it dismisses 'my $foo' as not being enough. I think 'my $.foo' mostly fixes that.

[20:27] <masak> but -- as you point out -- it's not exactly "class-level attributes".

[20:27] <pmichaud> I'm sure this doesn't resolve the issue, but one could always do:   class A { my $.x;  A.x = 3; }

[20:27] <masak> it's more "package-level attributes".

[20:28] <pmichaud> i.e., we have a way of accessing the class inside of the body without having to use 'self' to do it.

[20:28] <jnthn> $?CLASS.x = 3; # :)

[20:28] <pmichaud> that also.

[20:29] <masak> that's nice.

[20:30] *** Radium joined
[20:30] *** Radium left
[20:30] *** Radium joined
[20:30] <moritz> pmichaud: at your convenience, could you please take a look at https://rt.perl.org/rt3//Ticket/Display.html?id=112148 ?

[20:30] <masak> if you really want to forbid 'self' directly in the class block until everyone realizes that it's a good idea, then so be it ;)

[20:30] <pmichaud> it would somewhat bug me to have 'self' in the class block because it would then potentially scope into subs

[20:30] <masak> oh!

[20:31] <jnthn> pmichaud++

[20:31] <masak> well, that *is* a valid objection, I think.

[20:31] <masak> that might bother me too.

[20:31] <pmichaud> class A { my $.x;  my sub foo() { say $.x; } }    # huh?

[20:31] <moritz> and also

[20:31] <jnthn> class A { has $.x;  my sub foo() { say $.x; } } # wtf :)

[20:31] *** PacoAir left
[20:32] <masak> "Can't access attribute on type object, silly"

[20:32] <jnthn> I didn't put "silly" in the error :P

[20:32] <masak> but yeah, it *might* just miss out on useful error messages at compile time.

[20:32] *** bruges left
[20:32] *** y3llow left
[20:32] *** Radium left
[20:34] *** Radium joined
[20:34] *** Radium left
[20:34] *** y3llow joined
[20:34] *** bruges joined
[20:35] <masak> s/silly/sillybear/ # :P

[20:35] <moritz> ok, masak is going to kill me for this...

[20:36] <moritz> can't we have SELF in the class to mean $?CLASS?

[20:36] * moritz runs far and fast

[20:36] *** y3llow left
[20:37] *** y3llow joined
[20:37] <jnthn> macro SELF { quasi { $?CLASS } }; # but this'd have to be COMPILING-y I guess...

[20:38] *** Radium joined
[20:38] *** Radium left
[20:38] <masak> moritz: :P

[20:39] *** Radium joined
[20:39] *** Radium left
[20:39] *** y3llow left
[20:39] <masak> moritz-- # I'm not into violence, but here's for general tastelessness :)

[20:39] *** Radium joined
[20:39] *** Radium left
[20:39] *** y3llow joined
[20:39] <pmichaud> sledgehammers and katana seem to be the meme of the day today

[20:39] *** Radium joined
[20:39] <masak> jnthn: yeah, maybe $?COMPILING::CLASS ? :)

[20:40] <jnthn> Or maybe COMPILING::<$?CLASS> 

[20:42] *** y3llow left
[20:42] <masak> or maybe that.

[20:42] <masak> pmichaud++ # p6c mail to the Debian packagers

[20:42] *** y3llow joined
[20:43] *** birdwindupbird left
[20:43] *** Radium left
[20:44] *** Radium joined
[20:44] *** Radium left
[20:44] <pmichaud> bbl # errand

[20:44] *** Radium joined
[20:44] *** Radium left
[20:44] <lichtkind> this .Int is almost like in rebol

[20:45] *** Radium joined
[20:45] *** Radium left
[20:45] *** Radium joined
[20:45] *** Radium left
[20:45] <lichtkind> what is $?COMPILING ?

[20:45] *** Radium joined
[20:45] *** Radium left
[20:45] <masak> lichtkind: probably a thinko on my part.

[20:45] <masak> lichtkind: I liked jnthn++'s suggestion better.

[20:46] *** Radium joined
[20:46] *** Radium left
[20:46] *** nif left
[20:46] <masak> I mean, that's what I meant.

[20:46] *** Radium joined
[20:46] *** Radium left
[20:46] <masak> moritz++ # all those spec commits

[20:46] *** Radium joined
[20:46] *** Radium left
[20:47] *** Radium joined
[20:47] <moritz> wow, masak has --'ed me. I wonder if that's happened before

[20:47] *** ChanServ sets mode: +o masak

[20:47] *** Radium left
[20:47] <masak> moritz: :)

[20:47] <jnthn> I haven't seen masak write moritz-- before

[20:48] *** masak sets mode: +b *!*@117.203.11.193

[20:48] *** ChanServ sets mode: -o masak

[20:48] * pmichaud searches the backlog for moritz--  :)

[20:49] <moritz> it has happened! http://irclog.perlgeek.de/perl6/2011-07-03#i_4052937

[20:49] <jnthn> Oh gee, I thought masak had got his @ out to kick moritz++ for a moment then! :P

[20:49] <masak> what am I, a savage? :)

[20:49] <pmichaud> moritz++   # just to even things out

[20:49] <pmichaud> afk

[20:49] <moritz> masak: if you need to ask... :-)

[20:50] <masak> everyone's against me all of a sudden :P

[20:50] * masak .oO( hmph! can't even de-karma a well-liked community member. nepotism! )

[20:57] <lichtkind> masak: but you know what $*Compiling is?

[20:57] <jaffa4> Is it possible to make an exe using nicze out of perl 6 files?

[20:57] *** NamelessTee left
[20:57] <moritz> https://gist.github.com/2346494 # that's the other result of my trawling through S0{1,2,3}

[20:58] *** Radium joined
[20:58] *** Radium left
[20:58] *** Radium joined
[20:58] *** Radium left
[20:58] <moritz> oh, one more scoping oddity

[20:58] *** Radium joined
[20:58] *** Radium left
[20:58] <moritz> S02 says that 'anon sub foo { }' should make &foo available within the blockc

[20:58] <moritz> *block

[20:59] *** Radium joined
[20:59] *** Radium left
[20:59] *** ChanServ sets mode: +o masak

[20:59] *** Radium joined
[20:59] <moritz> somehow that sounds both convenient and odd to me

[20:59] *** masak sets mode: -b *!*@117.203.11.193

[20:59] <jnthn> moritz: I think that was a recent additoin rather than fossil, fwiw

[20:59] *** masak sets mode: +b *!*@117.203.*.*

[20:59] *** ChanServ sets mode: -o masak

[21:00] <masak> lichtkind: yes, that's just a dynamic variable.

[21:00] <moritz> on indeed, Date:   Wed Jan 11 15:31:43 2012 -0800

[21:00] <moritz> allow anon name to be used for recursion

[21:01] <moritz> so, that "just" needs to be special-cased in the actions somewhere, right?

[21:01] <masak> yeah.

[21:03] <jnthn> yeah

[21:03] <jnthn> in routine_def

[21:06] *** ggoebel left
[21:07] *** ggoebel joined
[21:08] *** samlh joined
[21:09] *** bluescreen10 left
[21:09] *** Radium left
[21:09] <samlh> moritz: s/ either// https://github.com/perl6/specs/commit/28401eef20#L0R3069

[21:10] *** skids left
[21:10] <moritz> samlh: thanks

[21:10] *** NamelessTee joined
[21:11] <dalek> specs: 98a47db | moritz++ | S03-operators.pod:

[21:11] <dalek> specs: [S03] grammar fix, samlh++

[21:11] <dalek> specs: review: https://github.com/perl6/specs/commit/98a47db89b

[21:13] <dalek> specs: 536a483 | moritz++ | S04-control.pod:

[21:13] <dalek> specs: [S04] note one more that &eval does not catch exceptions

[21:13] <dalek> specs: review: https://github.com/perl6/specs/commit/536a483309

[21:15] <moritz> pugs: foo: say "goto"; goto foo;

[21:15] <p6eval> pugs: OUTPUT«goto␤*** No such subroutine: "&goto"␤    at /tmp/8VM9jggNB9 line 1, column 18-26␤»

[21:18] <moritz> S04 contains surprisingly little insanity that I was able to detect, compared to S02 and S03

[21:22] <dalek> specs: 0fe2de0 | moritz++ | S05-regex.pod:

[21:22] <dalek> specs: [S05] s:g/Perl6/Perl 6/

[21:22] <dalek> specs: review: https://github.com/perl6/specs/commit/0fe2de0e47

[21:23] *** havenn joined
[21:26] <masak> something tells me moritz++ is reading through the synopses, one by one. :)

[21:27] *** bluescreen10 joined
[21:28] <jnthn> masak: http://i0.kym-cdn.com/photos/images/newsfeed/000/210/119/+_2acc5a8841f8752904d37f90a8014829.png?1322693145 :P

[21:30] <masak> :P

[21:32] * masak is https://www.google.com/search?tbm=isch&q=captain+obvious

[21:32] <Juerd> 21:14 < moritz> wow, the network connection to feather is really laggy

[21:32] <Juerd> moritz: Still?

[21:35] *** daxim left
[21:38] <gfldex> in S32 it says "method Str subst(Str $self: Regex $search, Str $replacement);"

[21:39] <gfldex> that Str $replacement is a lie

[21:39] <gfldex> it's can be a callable too

[21:39] *** tokuhirom joined
[21:39] <gfldex> at least in rakudo

[21:39] <masak> r: say "OH HAI".subst(/HAI/, { "YAY" })

[21:39] <p6eval> rakudo 3bd91f: OUTPUT«OH YAY␤»

[21:40] <masak> r: say "OH HAI".subst(/HAI/, 42)

[21:40] <p6eval> rakudo 3bd91f: OUTPUT«OH 42␤»

[21:40] <masak> r: say "OH HAI".subst(/HAI/, (1, 2, 3))

[21:40] <p6eval> rakudo 3bd91f: OUTPUT«OH 1 2 3␤»

[21:40] <masak> it can be anything, really.

[21:40] <masak> I remember there being an RT ticket about that, which pmichaud++ weighed in on.

[21:41] <masak> that was sort of the first sign for us that many signatures that were spec'd narrowly as a single type should really be casts instead, because that's the way we expect Perl to work.

[21:42] <masak> ah, here: https://rt.perl.org/rt3/Ticket/Display.html?id=57756

[21:42] <masak> heh, PIR :P

[21:43] *** tokuhirom left
[21:43] <gfldex> i had a look into Str.pm because http://rosettacode.org/wiki/URL_decoding#Perl_6 is fairly ugly

[21:43] <gfldex> is there no nice way to do that?

[21:45] <masak> yeah. that doesn't look very idiomatic.

[21:45] <masak> the brace style wastes vertical space.

[21:46] <masak> and if there are several regexen referring to each other, why ain't they in a grammar?

[21:47] <masak> procedural string concatenation is almost always a code smell to me nowadays.

[21:47] <masak> could easily have been a [~] and a map.

[21:47] * masak attempts a rewrite

[21:49] <jnthn> nom: say "http%3A%2F%2Ffoo%20bar%2F".subst(/'%'(<[0..9A..F]>**2)/, -> $/ { chr(:16(~$0)) }, :g)

[21:49] <p6eval> rakudo 3bd91f: OUTPUT«http://foo bar/␤»

[21:49] <masak> right.

[21:50] <masak> I realized that halfway through the rewrite: "waitaminite, all this does is..." what jnthn++ suggests :)

[21:50] <jnthn> nom: say "http%3A%2F%2Ffoo%20bar%2F".subst(/'%'(<[0..9A..F]>**2)/, -> ($ord as Str) { chr(:16($ord)) }, :g)

[21:50] <p6eval> rakudo 3bd91f: OUTPUT«http://foo bar/␤»

[21:50] <jnthn> Unpacking ftw :)

[21:50] <masak> "as"?

[21:50] <jnthn> masak: Coercion.

[21:50] * masak thought "as" was gone

[21:51] <gfldex> that's pretty now

[21:51] <gfldex> at least for perlist eyes :)

[21:51] <masak> gfldex: feel free to replace it on RC.

[21:51] <jnthn> masak: Yeah, but nobody does the new syntax yet.

[21:51] <gfldex> masak: will do

[21:51] <jnthn> masak: and working code on RC for the win :)

[21:51] <masak> *nod*

[21:51] <jnthn> Unpacking a Match object with sub-signatures is cute though :)

[21:52] <masak> aye :)

[21:52] <jnthn> Guess somebody has probably done it before...

[21:53] *** jaffa4 left
[21:53] *** havenn left
[21:55] *** havenn joined
[21:55] *** havenn left
[21:55] *** samlh left
[22:02] <masak> 'night, #perl6

[22:04] *** lexu joined
[22:05] *** brrt joined
[22:05] *** lexu left
[22:07] *** lexu joined
[22:08] *** nif joined
[22:09] <lichtkind> godd night masak 

[22:11] <sjohnson> hey TimToady, OT question:  was p5's // operator your idea?

[22:11] <sjohnson> in case you're curious, i do like it quite a lot

[22:11] <sjohnson> but not sure who to credit for the idea when i rant and rave about it to others

[22:12] *** pomysl joined
[22:12] *** pomysl left
[22:12] *** pomysl joined
[22:12] *** lexu left
[22:13] *** nif left
[22:14] *** nif joined
[22:18] <tadzik> （　｀ー´）

[22:19] <jnthn> Sleep time...teaching stuff tomorrow...

[22:19] <jnthn> No p6 tuits today :(

[22:19] <jnthn> 'night o/

[22:20] <tadzik> 'night as well

[22:21] *** whiteknight joined
[22:23] *** jaldhar joined
[22:25] *** brrt left
[22:25] *** brrt joined
[22:29] *** tokuhirom joined
[22:30] *** jferrero left
[22:37] * felher loves MAIN-subs. Are they borrowed from somewhere?

[22:39] *** [particle] left
[22:39] *** jferrero joined
[22:43] <lichtkind> felher: what you mean by main sub?

[22:43] <sjohnson> tadzik: :)

[22:44] <lichtkind> sjohnson: hai, thanks for following me :)

[22:44] *** bluescreen10 left
[22:44] <sjohnson> lichtkind: following you on what?

[22:45] <lichtkind> twitter

[22:45] <lichtkind> kephra_lk lk stand for lichtkind and leistungskurs :)

[22:46] <felher> lichtkind: if you have a sub MAIN(Str $blar) in a script, perl6 automagically parses commandline arguments of that script and passes that to MAIN. It also checks if you have really supplied exactly one argument (int this case) and auto-generates as usage message for you. Thats what i meant with MAIN-sub :)

[22:47] <sjohnson> lichtkind: i don't think i have you on my twitter account.. i hardly use it

[22:48] <sjohnson> i hate twitter, to be honest

[22:48] <sjohnson> i see people addicted to it here at work, like it's crack

[22:48] <sjohnson> i just looked at what the hell they're tweeting about, and it's impossible to understand or follow

[22:48] <lichtkind> sjohnson: yes you have to keep it on arms lengths

[22:48] <sjohnson> maybe it's the new solitare, as far as wasting time at work

[22:48] <lichtkind> :)

[22:49] <sjohnson> not to say i hate all social media though, i use facebook here and there

[22:49] <lichtkind> oh its another johnson :)

[22:49] <lichtkind> i like it sometimes ebcause i get to information form certain sources fast

[22:49] *** NamelessTee left
[22:50] *** bluescreen10 joined
[22:50] <lichtkind> its also good for my writings + im info junky anyway reading a lot

[22:50] <sjohnson> lichtkind: for sure, i just need to subscribe to actual interesting stuff, i guess :)

[22:50] <lichtkind> so it actually saves me time  i read much less blogs since twitter

[22:50] <sjohnson> yeah, perhaps that's what i need to do

[22:51] <sjohnson> register a news twitter account, so none of my friends whine when they see i haven't added them ;)

[22:51] <lichtkind> sjohnson: yes but the professional twitterer post lots of stuff, and so short before unsubscribe randal schwarz becuase i never wanted know he actually enjoys watching leno

[22:51] *** xinming left
[22:53] <sjohnson> :)

[22:53] *** xinming joined
[23:01] *** brrt left
[23:01] *** zipf joined
[23:01] *** tyatpi joined
[23:03] *** zipf left
[23:34] * [Coke] thinks http://blogs.perl.org/users/shlomi_fish/2012/04/the-perl-april-fools-gag-that-could-have-been.html needs some hugs.

[23:47] *** VXZ left
[23:47] *** Chillance left
[23:50] *** xinming_ joined
[23:52] *** xinming left
[23:52] *** havenn joined
[23:53] *** jaldhar left
[23:55] *** plobsing left
