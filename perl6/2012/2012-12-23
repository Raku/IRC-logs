[00:00] <timotimo> wouldn't a zen-slice[] copy a list?

[00:05] <timotimo> i must be misunderstanding coroutines :|

[00:06] <timotimo> or maybe binding or lazyness or something entirely different.

[00:07] *** bot48 joined
[00:15] *** bot48 left
[00:16] <timotimo> hm, i would have liked to gist this and feed it to p6eval, but could as well just sprunge it

[00:16] <timotimo> http://sprunge.us/AOFJ

[00:17] <timotimo> the only surprise i can't get rid of is that each of the combinations is apparently a parcel with a list as second argument, but i can't really turn it into a single parcel, because that just flattens the outermost list into utter unhelpfulnes

[00:17] <timotimo> also it's very interesting how the number of elements you take out of the outermost lazy list causes the first element to be longer, that seems kind of unnatural :D

[00:18] *** bot48 joined
[00:19] <timotimo> http://sprunge.us/DbKJ - sample output for [^30], sample output for [^10]: http://sprunge.us/NIbe

[00:25] *** rurban1 left
[00:26] *** MayDaniel left
[00:27] <timotimo> and i can't run the perl6-debugger because it's saying "Missing or wrong version of dependency 'src/gen/Metamodel.pm'" and i can't install it via panda because github is down :|

[00:44] *** slayer101_ joined
[00:53] *** ServerSage joined
[01:21] *** rurban joined
[01:22] *** slayer101_ left
[01:23] *** bowtie left
[01:29] *** pmurias left
[01:31] *** rurban left
[01:33] *** rummik left
[01:33] *** rummik joined
[01:38] *** Celelibi joined
[01:40] *** PacoAir left
[01:44] *** cognominal joined
[02:00] *** mj41 joined
[02:07] *** thou_ joined
[02:09] *** slayer101_ joined
[02:11] <diakopter> urp. github still down.

[02:11] <diakopter> scheduled or unscheduled?

[02:12] <sorear> diakopter: failures during scheduled maintance, Chernobyl style

[02:12] <sorear> diakopter: https://status.github.com/messages

[02:13] <diakopter> if only this were distributed.. oh wait.

[02:15] *** rurban joined
[02:22] *** skids joined
[02:28] *** mj41 left
[02:34] *** MikeFair_ left
[02:36] *** rurban left
[02:38] <cognominal> unlike chernobyl, the fallout reaches France.

[02:49] *** mj41 joined
[02:54] *** mj41 left
[02:54] *** FROGGS_ joined
[02:58] *** FROGGS left
[03:00] <[Coke]> No such method 'length' for invocant of type 'Str'

[03:03] *** Chillance left
[03:22] <diakopter> No such method 'resurrect' for invocant of type 'github'

[03:23] <sorear> [Coke]: length is gone, sorry.  did you mean "chars"?

[03:26] *** cognominal left
[03:26] *** mj41 joined
[03:26] *** cognominal joined
[03:31] *** mj41 left
[03:46] *** mj41 joined
[04:09] *** slayer101_ left
[04:14] *** cognominal left
[04:14] *** raiph left
[04:19] *** cognominal joined
[04:23] *** slayer101_ joined
[04:25] *** cognominal_ joined
[04:26] *** cognominal left
[04:26] *** snarkyboojum_ is now known as snarkyboojum

[04:30] *** cognominal_ left
[04:34] *** slayer101_ left
[04:35] *** hash_table left
[04:36] *** slayer101_ joined
[04:39] *** chubbyLady joined
[04:40] *** chubbyLady left
[05:11] *** telex left
[05:18] *** telex joined
[05:21] *** aindilis joined
[05:29] *** lolage left
[05:31] *** telex left
[05:37] *** telex joined
[05:40] *** slayer101_ left
[05:42] *** mj41 left
[05:58] *** mj41 joined
[06:06] *** rurban joined
[06:10] *** rurban left
[06:27] *** noggle left
[06:28] *** noggle joined
[06:37] *** rurban joined
[06:39] *** cognominal joined
[06:42] *** rurban left
[06:53] *** cognominal left
[07:01] *** cognominal joined
[07:05] *** noggle left
[07:06] *** mj41 left
[07:09] *** rurban joined
[07:11] *** noggle joined
[07:16] *** rurban left
[07:21] *** mj41 joined
[07:28] *** mj41 left
[07:34] *** cognominal left
[07:35] *** cognominal joined
[07:37] *** FROGGS_ left
[07:43] <moritz> timotimo: yes, perl-6.de is lots out of date

[07:44] *** mj41 joined
[07:48] <moritz> I guess I should update it, but so far I have too many other things on Perl 6 TODO heap

[07:58] <moritz> I'm putting the source code on https://github.com/moritz/perl-6.de

[07:58] <moritz> if anybody wants to help, just ask for a commit bit

[08:07] *** cognominal left
[08:07] *** cognominal joined
[08:10] *** rurban joined
[08:11] *** SamuraiJack joined
[08:15] *** cognominal left
[08:16] *** gaussblurinc joined
[08:16] *** cognominal joined
[08:18] *** rurban left
[08:23] *** cognominal left
[08:24] <moritz> timotimo: are you still looking for stuff to hack on?

[08:24] <moritz> timotimo: rakudo's substr-rw doesn't understand *-1

[08:25] <moritz> n: my $a = '1234'; say substr($a, 1, 1, '42)

[08:25] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse argument list at /tmp/EBV219gS1w line 1:‚ê§------> [32mmy $a = '1234'; say substr([33m‚èè[31m$a, 1, 1, '42)[0m‚ê§Couldn't find final ')'; gave up at /tmp/EBV219gS1w line 1:‚ê§------> [32mmy $a = '1234'; say subs‚Ä¶

[08:25] *** cognominal joined
[08:25] <moritz> n: my $a = '1234'; say substr($a, 1, 1, '42')

[08:25] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´4‚ê§¬ª

[08:25] <moritz> erm, what?

[08:26] <moritz> r: my $a = '1234'; say substr($a, 1, 1, '42')

[08:26] <p6eval> rakudo c8de2e: OUTPUT¬´Too many positional parameters passed; got 4 but expected between 2 and 3‚ê§  in sub substr at src/gen/CORE.setting:2339‚ê§  in block  at /tmp/eT3nbR6ttb:1‚ê§‚ê§¬ª

[08:27] *** donghongbo joined
[08:30] *** cognominal left
[08:34] *** cognominal joined
[08:39] *** xinming left
[08:39] *** kaare_ joined
[08:41] *** cognominal left
[08:41] *** GlitchMr joined
[08:43] *** xinming joined
[08:44] *** cognominal joined
[08:45] *** rurban joined
[08:54] *** popl joined
[08:54] *** rurban left
[08:55] *** spider-mario joined
[08:56] *** mj41 left
[09:01] *** mj41 joined
[09:03] <moritz> timotimo: I've updated perl-6.de a bit; still needs lots of updating

[09:07] *** cognominal left
[09:07] *** mj41 left
[09:09] <moritz> n: say do for ^4 { $_ ** 2 }

[09:09] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Nil‚ê§¬ª

[09:10] <moritz> n: say Date.today

[09:10] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared name:‚ê§        'Date' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ‚ê§  at /home/p‚Ä¶

[09:11] *** cognominal joined
[09:16] *** cognominal_ joined
[09:16] <GlitchMr> I've lately moved to Arch. I like how repositories have Rakudo Star 2012.11.

[09:16] <popl> I considered moving to Arch Linux.

[09:16] *** cognominal left
[09:17] <popl> my laptop is on the way out anyways, though.

[09:17] <popl> So I have Slackware and a broken Parrot

[09:17] <popl> and no Perl6

[09:17] <popl> oh well

[09:18] <popl> OH, that was not the topic of conversation. My apologies.

[09:19] * moritz reminds masak++ to publish a p6advent post today

[09:21] *** FROGGS_ joined
[09:23] <FROGGS_> morning

[09:23] <moritz> \o FROGGS_ 

[09:24] <FROGGS_> moritz: is github/rakudo an org now?

[09:25] *** popl left
[09:25] <FROGGS_> I'm asking because of the commit bit I'd like to have

[09:26] <bbkr> wordpress on advent calendar destroys code thinking it's HTML :( I've posted comment under masak IPv4 post about usefulnes of <?{}>

[09:26] <bbkr> rakudo: $_ = "Go 127.666.0.1, I said! He went to 173.194.32.32."; say .Str for m:g/ ( (\d ** 1..3) <?{ 0 < $0 < 255 }> ) ** 4 % "." /;

[09:26] <p6eval> rakudo c8de2e: OUTPUT¬´173.194.32.32‚ê§¬ª

[09:26] <moritz> FROGGS_: it is, but I still can't hand them out on a whim

[09:27] <FROGGS_> moritz: k

[09:27] <moritz> FROGGS_: you need to have submitted a CLA, and the majority of the developers need to agree, and none object

[09:28] <FROGGS_> I sent the CLA right before 2012.11 release

[09:31] <FROGGS_> moritz: what can I do to get the devs feedback? making a gist so that they can reply there? or send a mail to some address?

[09:40] *** tcpr1347 left
[09:41] *** Psyche^ joined
[09:42] *** Patterner left
[09:42] *** Psyche^ is now known as Patterner

[09:45] *** mj41 joined
[09:45] *** rurban joined
[09:52] *** rurban left
[09:57] *** cognominal_ left
[10:02] *** cognominal_ joined
[10:04] *** rindolf joined
[10:06] <moritz> FROGGS_: talk to jnthn and pmichaud 

[10:07] <moritz> FROGGS_: you have my +1

[10:07] *** ivan`` joined
[10:15] *** ps joined
[10:15] *** ps is now known as Guest90247

[10:15] <FROGGS_> moritz: thanks, and thanks, will do :o)

[10:16] *** cognominal_ left
[10:16] <GlitchMr> I wanted to put problem 1 solution

[10:16] <GlitchMr> It looked like this:

[10:16] <GlitchMr> say [+] grep * %% (3|5), ^1000;

[10:17] <GlitchMr> The problem is that somebody already has done that...

[10:17] <GlitchMr> Exactly like that

[10:17] <moritz> GlitchMr: what are you talking about?

[10:17] <GlitchMr> https://github.com/perl6/perl6-examples/blob/master/euler/prob001-grondilu.pl

[10:18] <moritz> so, what's the problem?

[10:18] <GlitchMr> But well, the problem is probably so simple that it's hard to think of other Perl6ish solution.

[10:18] <rindolf> What is %%?

[10:19] <rindolf> Is it numeric reminder?

[10:19] <GlitchMr> Divides by operator

[10:19] <rindolf> remainder sorry.

[10:19] <rindolf> Ah.

[10:19] <rindolf> Why not a simple "%"?

[10:19] <GlitchMr> Because % is modulo

[10:19] <GlitchMr> 3 % 2 == 1, but 3 %% 2 == False.

[10:19] <rindolf> Ah, hah.

[10:19] <GlitchMr> But opposite of modulo would work too

[10:20] <GlitchMr> !($a % $b) is just like ($a %% $b)

[10:20] <moritz> rindolf: you can look up operators on http://doc.perl6.org/language/operators

[10:20] <GlitchMr> %% is actually useful operator :-).

[10:21] <GlitchMr> The $a % $b == 0 I often see in other programming languages annoys me.

[10:21] <rindolf> http://doc.perl6.org/language/operators#infix+%25%25 - this link does not work in Firefox with JS blacklisted.

[10:21] <GlitchMr> !($a % $b) is even more annoying.

[10:21] *** cognominal_ joined
[10:22] <moritz> rindolf: I know there's some trouble with the anchor links

[10:22] <moritz> the browsers don't quite agree on what needs escaping and what not

[10:22] <moritz> and I haven't figured it out yet

[10:22] <rindolf> moritz: OK.

[10:23] <rindolf> I tend to avoid doing that and use custom id="..."

[10:25] <GlitchMr> print(sum(i for i in range(1000) if i % 3 == 0 or i % 5 == 0))

[10:25] <GlitchMr> I believe it would look like this in Python

[10:30] <GlitchMr> Now for Rubyish way

[10:30] <GlitchMr> puts (1..999).select {|i| i % 3 == 0 or i % 5 == 0 }.inject(:+)

[10:30] <GlitchMr> You can write really short programs in Perl 6.

[10:33] <GlitchMr> Of course, you can write Ruby in Perl 6

[10:33] <GlitchMr> say (1..999).grep(-> $i { $i % 3 == 0 or $i % 5 == 0 }).reduce(&[+])

[10:33] <GlitchMr> Close enough

[10:39] *** jokar left
[10:42] *** Guest90247 left
[10:44] *** cognominal_ left
[10:46] *** rurban joined
[10:49] *** cognominal joined
[10:51] *** cognominal left
[10:53] *** pmurias joined
[10:55] *** PacoAir joined
[10:57] *** rurban left
[11:00] *** Kharec joined
[11:03] *** PacoAir left
[11:03] *** PacoAir joined
[11:17] <masak> hola, #perl6

[11:17] <masak> sorry I haven't prepared a slot 23 post yet.

[11:17] <masak> I completely forgot...

[11:17] <masak> if you have the patience for it, I'll have one ready in a couple hours.

[11:19] <moritz> what would be the alternative? you prepare it for tomorrow, and somebody else does a post fo today?

[11:19] <masak> I guess.

[11:20] <masak> up to you folks and bots.

[11:23] <GlitchMr> Illegally post-declared types

[11:24] <GlitchMr> Forward goto is disallowed in Niecza?

[11:32] <GlitchMr> rn: https://gist.github.com/4363016

[11:32] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/BFHqh1Q8Y1:13‚ê§------> [32mzero[33m‚èè[31m:[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modifier‚ê§‚Ä¶

[11:32] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Illegally post-declared types:‚ê§  'no' used at line 34‚ê§   'yes' used at line 23‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 11‚Ä¶

[11:32] <GlitchMr> std: https://gist.github.com/4363016

[11:32] <felher> masak: I think we can wait a couple of hours :)

[11:32] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Illegally post-declared types:‚ê§      'no' used at line 34‚ê§   'yes' used at line 23‚ê§Check failed‚ê§FAILED 00:00 43m‚ê§¬ª

[11:32] <GlitchMr> So, I cannot have forward labels?

[11:33] <GlitchMr> "must enclose the label in quotes"

[11:33] <GlitchMr> oh, ok

[11:34] *** rummik left
[11:35] *** rummik joined
[11:36] <moritz> masak: I agree with felher 

[11:38] *** donghongbo left
[11:39] <FROGGS_> IMO quality is much more important than beeing on time

[11:40] <FROGGS_> masak: (and your posts tend to be good)

[11:43] <jnthn> morning o/

[11:43] <phenny> jnthn: 21 Dec 21:51Z <FROGGS> tell jnthn I have a patch that allows one to import multis from two different modules (like the trait_mod:<is>), but one thing remains open: the dump of the list of dispatchers is incomplete, even if all dispatchers work

[11:43] <phenny> jnthn: 21 Dec 22:05Z <moritz> tell jnthn YOU MAKED BRANCH outer-bound BUT I MERGED IT KXTHXBY

[11:43] <jnthn> kthx by...whom? :P

[11:43] * jnthn will be about for a little bit :)

[11:44] <jnthn> FROGGS_: What does "list of discpatchers" mean? Maybe it's easiest if I can see a patch...

[11:44] <moritz> by CEILING CAT

[11:44] <moritz> jnthn: I think FROGGS_ talks about the list of signatures in the error message

[11:44] <FROGGS_> moritz: correct

[11:44] <jnthn> ah, those'd be dispatch*ee*s :P

[11:45] *** Kharec left
[11:45] <jnthn> Anyway, I can probably spot any issues by looking at the patch

[11:45] <FROGGS_> jnthn: I can't show you right now

[11:45] <jnthn> ok

[11:45] <jnthn> I'm gonna be fairly tied up with family stuff, but may find the odd moment in the next few days

[11:45] <FROGGS_> currently I'm traveling

[11:46] <pmurias> jnthn: what do uninitialised lexicals contain in nqp? NQPMu?

[11:46] <jnthn> Best bet is to gist it and phenny me it.

[11:46] <jnthn> pmurias: For scalars, yes

[11:46] <FROGGS_> jnthn: I will be too, no hurry

[11:46] <jnthn> @ and % are automatically initialized with an empty array/hash

[11:46] <FROGGS_> jnthn: k

[11:46] *** rurban joined
[11:46] <moritz> now I wanted to remove the sink ROADMAP item, and found that we had none :-)

[11:47] <jnthn> moritz: aww!

[11:47] <jnthn> moritz: Noticed it got merged. Yay. \o/

[11:47] <jnthn> moritz++

[11:47] <FROGGS_> cool

[11:47] <FROGGS_> how much is the parse time now?

[11:48] <moritz> not much changed

[11:48] <FROGGS_> k

[11:48] <moritz> still between 1 and 4 minutes, depending on the machine I run it on

[11:48] <FROGGS_> one minute? wow

[11:49] <moritz> jnthn: any idea for medium-sized rakudo hacking projects?

[11:49] <moritz> FROGGS_: I've got a new workstation at $work

[11:49] <moritz> it managed the parsing stage in 62s or so

[11:49] <FROGGS_> had 80s right before the slow-down patch, now got 240s

[11:49] <moritz> erm, what?

[11:50] <moritz> the slow-down part of the patch has been reverted

[11:50] <FROGGS_> the patch that added set operators

[11:50] <moritz> FROGGS_: are you on up-to-date nom branch?

[11:50] * jnthn has just kicked off a build

[11:50] <FROGGS_> ohh, then I should pull :o)

[11:50] <FROGGS_> no

[11:50] <moritz> yes, you should :-)

[11:50] <FROGGS_> ya

[11:51] <jnthn> moritz: Hm, lemme glance the ROADMAP for things :)

[11:51] *** pmurias left
[11:51] <moritz> one that sounds like fun ins NFG strings... but I think it's way too much work

[11:51] <jnthn> moritz: Where did the logical cascades work get to?

[11:53] <moritz> jnthn: it mostly works, but there were some trouble setting $_ and/or $! in the thunks

[11:53] <jnthn> ah, ok

[11:53] <jnthn> orelse too?

[11:53] <jnthn> There could be some things in regexes

[11:53] *** pmurias joined
[11:54] <moritz> yes, orelese too

[11:54] <moritz> though I'm not sure of the corner cases there

[11:54] <jnthn> The array variable interpolation is...difficult.

[11:54] <moritz> hm, might still be a TODO

[11:54] <jnthn> But OTOH not a huge amount of code to write.

[11:55] *** rurban left
[11:55] <jnthn> The problem is that it involves some fairly dynamic NFA stuff

[11:56] <jnthn> Doing ~~ inside regexes may well be more accessible.

[11:56] <moritz> what's the "missing bits of enums" in the Language Features section?

[11:56] <jnthn> I'm not sure

[11:56] <jnthn> Do non-numeric enums work?

[11:56] <jnthn> I'm sure I saw a comment the other day in Actions that suggested not.

[11:56] <moritz> r: my enum A a => 'b', c => 'd'; say c

[11:56] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed my‚ê§at /tmp/Y3RWkIw78A:1‚ê§------> [32mmy enum A [33m‚èè[31ma => 'b', c => 'd'; say c[0m‚ê§    expecting any of:‚ê§        scoped declarator‚ê§¬ª

[11:57] <moritz> r: enum A (a => 'b', c => 'd'); say c

[11:57] <p6eval> rakudo c8de2e: OUTPUT¬´c‚ê§¬ª

[11:57] <jnthn> The sigspace changes are also an option.

[11:57] <pmurias> jnthn: are there any specific method names I should use for conversions to nqp numbers,ints and strings? (I currently use to_n,to_i,to_s)

[11:57] <jnthn> .Num, .Int, .Str :)

[11:57] <moritz> r: enum A (a => 'b', c => 1); say c

[11:57] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Type error in enum. Got 'Int' Expected: 'Str'‚ê§at /tmp/1khutqr76M:1‚ê§------> [32menum A (a => 'b', c => 1)[33m‚èè[31m; say c[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement ‚Ä¶

[11:57] <moritz> are those supposed to work?

[11:58] <jnthn> r: enum A (a => 'b', 'c'); say c

[11:58] <p6eval> rakudo c8de2e: OUTPUT¬´c‚ê§¬ª

[11:58] <moritz> well, maybe I'm doing the rest of p6cc first :-)

[11:58] <jnthn> r: enum A (a => 'b', 'c'); say c.perl

[11:58] <p6eval> rakudo c8de2e: OUTPUT¬´A::c‚ê§¬ª

[11:58] <jnthn> r: enum A (a => 'b', 'c'); say c.value

[11:58] <p6eval> rakudo c8de2e: OUTPUT¬´c‚ê§¬ª

[11:58] <jnthn> Hm, seems they do work

[11:58] <moritz> r: enum A (a => 'x', 'c'); say c.value

[11:58] <pmurias> jnthn: isn't Int a bigint rather then something the op add_i wants?

[11:58] <p6eval> rakudo c8de2e: OUTPUT¬´y‚ê§¬ª

[11:58] <jnthn> Maybe consider the spectest

[11:58] <moritz> ok

[11:58] <jnthn> pmurias: In Perl 6, but NQP doesn't use bigints natively 

[11:59] <jnthn> pmurias: In reality, all the numeric ops in NQP are floating point.

[11:59] <jnthn> The only way to get an int is with the native types stuff.

[11:59] <jnthn> Well, plus literals I guess

[12:00] <jnthn> This is to avoid having to multi-dispatch all the operators.

[12:00] <jnthn> moritz: I think STD has got a decent solution on the sigspace things.

[12:00] <pmurias> and nqp::add_i?

[12:00] <jnthn> pmurias: Yes, if you do that it's integer addition of course

[12:00] <jnthn> pmurias: I meant what + does

[12:01] <jnthn> It always (in Actions) spits out nqp::add_n

[12:01] *** gattschardo joined
[12:01] <jnthn> My plan was to change it to add_i in the optimizer when both sides are integers.

[12:02] <jnthn> moritz: Don't take the :D/:U/:T task as I've plans for that (which will involve some notable changes)

[12:02] <pmurias> that would acutally hurt performance in js

[12:02] <pmurias> as javascript has no integers

[12:03] <jnthn> moritz: If you want to do something REALLY evil...masak's macro grant doesn't cover textual macros, and now that I did that refactor that puts the target/orig off in a struct that all cursors share throughout the parse, they're actually kinda doable ;)

[12:04] <jnthn> pmurias: Optimizer doesn't have to do the same thing for all backends ;)

[12:05] <jnthn> moritz: Another small task that may be fun and isn't a huge amount of work: look up $*LAST_NIBBLE in STD, and port the related bits to Rakudo.

[12:05] <jnthn> moritz: It does runaway string detection.

[12:06] <jnthn> It's a nice error improvement for a probably quite modest amount of work. :)

[12:06] <jnthn> Other possibility there: implement suppose. I didn't get around to it yet, and we could use it in a few places.

[12:06] *** fgomez joined
[12:07] <jnthn> (today we get bogus TTIAR errors sometimes, when the next thing actually isn't a term...)

[12:07] <jnthn> moritz: Hope that lot provides some ideas ;)

[12:08] *** gaussblurinc left
[12:08] <moritz> jnthn: it does, takk

[12:09] <jnthn> var saa god :)

[12:13] <gattschardo> is there a simple way to load (or reload) a .pl file in rakudo when using it as a shell?

[12:13] *** LlamaRider left
[12:13] *** LlamaRider joined
[12:14] <FROGGS_> slurp and eval?

[12:15] <jnthn> Heh, could do that.

[12:15] <jnthn> "use" won't look for it.

[12:15] <jnthn> r: evalfile

[12:15] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§    evalfile used at line 1‚ê§‚ê§¬ª

[12:15] <jnthn> hm, probably misremembering...I thought there was a builtin that did slurp/eval for you

[12:16] <jnthn> but yeah, eval slurp 'file.pl' 

[12:16] <gattschardo> well, slurp/eval works, thanks

[12:16] *** am0c joined
[12:16] <gattschardo> just thought there might be something built in

[12:16] <jnthn> And if you repeat it, it'll slurp it afresh

[12:16] * jnthn realizes that this is probably a cute debugger prompt idiom too...

[12:17] <jnthn> Since eval slurp 'foo.pl' at the debugger prompt would let you debug foo.pl :)

[12:18] <GlitchMr> In Perl 5, do is enough

[12:18] <GlitchMr> do 'foo.pl'

[12:19] <GlitchMr> But not like eval slurped files is good idea

[12:23] *** MayDaniel joined
[12:25] *** rindolf left
[12:26] *** rindolf joined
[12:27] *** noggle left
[12:28] *** noggle joined
[12:35] *** GlitchMr left
[12:37] *** GlitchMr joined
[12:38] *** LlamaRider left
[12:40] *** GlitchMr_ joined
[12:42] *** GlitchMr left
[12:42] *** GlitchMr_ left
[12:44] *** mj41 left
[12:47] *** mj41 joined
[12:47] *** rurban joined
[12:47] *** jokar joined
[12:50] *** GlitchMr joined
[12:51] *** rurban left
[12:52] *** pmurias left
[12:52] *** pmurias joined
[12:52] *** mj41 left
[12:55] *** GlitchMr left
[13:04] *** FROGGS_ left
[13:05] *** FROGGS_ joined
[13:14] <jnthn> OK, enough for today :) o/

[13:15] <moritz> bye

[13:17] *** GlitchMr joined
[13:20] *** mj41 joined
[13:24] *** donghongbo joined
[13:27] *** isBEKaml joined
[13:30] *** GlitchMr left
[13:33] <isBEKaml> hola, #perl6!

[13:35] *** SamuraiJack left
[13:37] *** Chillance joined
[13:40] *** not_gerd joined
[13:40] <not_gerd> hello, #perl6

[13:41] <isBEKaml> rn: sub froo($xx, $yy?)  { say "x is $xx" ~  $yy.defined ?? " with yy as $yy." !! ""; }; froo(24);

[13:41] <p6eval> rakudo c8de2e: OUTPUT¬´use of uninitialized value of type Any in string context  in sub froo at /tmp/y0LWn_zjkK:1‚ê§‚ê§ with yy as .‚ê§¬ª

[13:41] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1287 (warn @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/uZzmxBKJTo line 1 (froo @ 4) ‚ê§‚Ä¶

[13:42] <not_gerd> moritz: one way to make html ids from arbitrary strings: https://gist.github.com/4363369

[13:42] <not_gerd> horribly slow on Rakudo, though :(

[13:42] <isBEKaml> rn: sub froo($xx, $yy?)  { say "x is $xx" ~  $yy.defined ?? " with yy as $yy." !! ""; }; froo(24); froo(24, 42)

[13:42] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1287 (warn @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/PKLdLjr8FA line 1 (froo @ 4) ‚ê§‚Ä¶

[13:42] <p6eval> ..rakudo c8de2e: OUTPUT¬´use of uninitialized value of type Any in string context  in sub froo at /tmp/UjkC3z7vvW:1‚ê§‚ê§ with yy as .‚ê§ with yy as 42.‚ê§¬ª

[13:43] <isBEKaml> is that correct? This was out of p6book. :)

[13:45] <isBEKaml> rn: sub froo($xx, $yy?)  { say "x is $xx" ~  ($yy.defined ?? " with yy as $yy." !! ""); }; froo(24); froo(24, 42)

[13:45] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´x is 24‚ê§x is 24 with yy as 42.‚ê§¬ª

[13:45] <isBEKaml> oh, parens. how I love you. :|

[13:46] *** SamuraiJack joined
[13:47] *** rurban joined
[13:50] <pmurias> jnthn: why do we have BUILDPLAN?

[13:50] <pmurias> jnthn: why do we construct and execute the plan instead of just doing the work?

[13:51] <moritz> because doing the work takes time

[13:52] <pmurias> so it's supposed to avoid doing the traversal every time?

[13:52] <moritz> yes

[13:54] <pmurias> would be nice to have that mentioned in comments

[13:54] <not_gerd> rn: constant @x = []; constant @y = @x; say @x =:= @y; my @u = []; my @v = @u; say @u =:= @v

[13:54] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´True‚ê§False‚ê§¬ª

[13:54] <not_gerd> doesn't that violate least surprise?

[13:55] <not_gerd> (assuming it's not a bug, of course)

[13:55] <moritz> IMHO it's a bug

[13:55] <moritz> assigning to a constant

[13:55] *** rurban left
[13:56] <isBEKaml> OOC, what does =:= mean?

[13:56] <isBEKaml> equality both by type and values?

[13:57] *** SamuraiJack left
[13:57] <not_gerd> isBEKaml: container identity, ie both variables are bound to the same thing

[13:58] <isBEKaml> not_gerd: ah, thanks. 

[13:58] *** mikemol joined
[14:00] * not_gerd just got a 10x speedup by replacing constant with my

[14:02] <isBEKaml> not_gerd: the difference is 0.5 sec on my machine (between constant and my)

[14:03] <isBEKaml> "my" being the faster one. It took 5 secs to just go through encoding and decoding two strings. 

[14:03] *** donghongbo left
[14:04] <not_gerd> isBEKaml: my @foo = 0..5, 10..20 creates a new array, whereas constant @foo = ... just binds the right-hand side

[14:04] <not_gerd> ==> fast iteration in case of my, slow iteration in case of constant

[14:04] *** lolage joined
[14:04] <moritz> you can work around it by slapping .list on the RHS

[14:05] <moritz> but it's really a bug in rakudo

[14:05] <moritz> it should do proper list assingment

[14:05] *** FROGGS_ left
[14:06] <isBEKaml> not_gerd: I can see that. Also, s/:=/=/g gives me 2.5 sec running time. :)

[14:06] *** SamuraiJack joined
[14:08] <moritz> nr: my @a = 1..5; say @a.WHAT

[14:08] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´Array()‚ê§¬ª

[14:09] <isBEKaml> moritz: do we know if variable bindings are slow on rakudo? 

[14:09] *** am0c left
[14:09] <isBEKaml> moritz: that is, $var := $another-var or $var := literal-stuff

[14:12] <moritz> isBEKaml: they aren't slow

[14:12] <moritz> isBEKaml: they are only slow if they lead to multiple evaluations in later code

[14:14] *** bowtie joined
[14:15] *** GlitchMr joined
[14:22] *** rurban joined
[14:22] <isBEKaml> moritz: sorry if I sound a bit confused - do "multiple evaluations" also include lookups? The way I see it, they shouldn't (ideally) slow things down, right? 

[14:23] <moritz> isBEKaml: I'm talking about multiple evaluations of lazy lists and stuff like that

[14:23] <moritz> isBEKaml: not lookups

[14:25] <not_gerd> rn: my $n = 42; /a ** $n/

[14:25] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quantifier quantifies nothing‚ê§at /tmp/4yt24UZp5x:1‚ê§------> [32mmy $n = 42; /a ** [33m‚èè[31m$n/[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modif‚Ä¶

[14:25] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´Potential difficulties:‚ê§  Unsupported use of atom ** $n as separator; nowadays please use atom+ % $n at /tmp/lhcsayHHjd line 1:‚ê§------> [32mmy $n = 42; /a ** $n[33m‚èè[31m/[0m‚ê§‚ê§¬ª

[14:25] <isBEKaml> moritz: wheww... okay. :)

[14:27] *** rurban left
[14:27] *** FROGGS joined
[14:29] <isBEKaml> moritz: where can I find the full index of all functions documented in doc.perl6.org?

[14:29] <isBEKaml> moritz: or is that what we have right on the first page?

[14:30] <moritz> http://doc.perl6.org/#Routines

[14:30] <moritz> though that doesn't list the operators from language/operators

[14:30] <isBEKaml> moritz: okay, I guess I'll start with some string functions. .subst, .trans and stuff like that. :)

[14:35] *** cibs joined
[14:40] *** spider-mario left
[14:48] *** FROGGS left
[14:55] *** cibs left
[14:57] *** rurban joined
[14:58] *** rurban left
[15:00] *** mikemol left
[15:01] <masak> ok, starting to write the macros advent post now.

[15:03] *** cibs joined
[15:05] <felher> masak: btw: here is my Perl6 and Haskell solution. The Haskell solution is quite long and not very efficient. But since I have little to no experience with Haskell and am quite busy, I was happy to get it working at all and then left it there :)

[15:06] <felher> masak: https://gist.github.com/4363849

[15:07] *** isBEKaml left
[15:07] * masak looks

[15:08] <masak> felher: nice.

[15:08] <masak> your solution is more... composable than mine.

[15:08] <masak> felher: looks like you can get rid of 'list' almost anywhere.

[15:09] <masak> felher: because of currying, when the left side and right side end in the same terms, you can just remove them, like in an equation.

[15:09] <felher> masak: oh, right. Point free ftw :)

[15:09] <masak> felher: your Perl 6 solution looks like what I wanted to write all along.

[15:09] <masak> kudos.

[15:10] <masak> filterWith, nice.

[15:12] <felher> masak: thanks. I updated the gist to make the haskell version more point-free :)

[15:13] <masak> \o/

[15:13] * masak .oO( resistance is point-free )

[15:13] <felher> :D

[15:15] <felher> masak: btw. Your haskell version is much shorter and much more efficient I guess. I just was too lazy to look up Set and MultiSet :)

[15:17] <masak> I got #haskell to help me with those.

[15:18] <masak> my Haskell port is a straight port of my Perl 6, which was a straight port of the Python.

[15:18] <masak> I essentially innovated nothing along the way.

[15:21] <felher> masak: nothing wrong with that as long as it gives you a nice solution :)

[15:23] *** mikemol joined
[15:24] *** SamuraiJack left
[15:26] <masak> r: macro checkpoint { state $n = 0; my $i = ++$n; quasi { say "CHECKPOINT $i" } }; checkpoint; say "foo"; checkpoint; say "bar"; checkpoint

[15:26] <p6eval> rakudo c8de2e: OUTPUT¬´CHECKPOINT 1‚ê§foo‚ê§CHECKPOINT 2‚ê§bar‚ê§CHECKPOINT 3‚ê§¬ª

[15:26] <masak> \o/

[15:29] *** donghongbo joined
[15:31] <not_gerd> bye, #perl6

[15:31] *** not_gerd left
[15:31] *** donghongbo left
[15:32] *** rummik left
[15:32] <masak> what's the biggest difference between C's textual macros and Perl 5's source filters?

[15:32] *** lorn left
[15:32] <felher> r: macro checkpoint { state $n = 0; quasi { say "CHECKPOINT {++$n}" } }; checkpoint for ^3; say "foo"; checkpoint; say "bar"; checkpoint

[15:32] <p6eval> rakudo c8de2e: OUTPUT¬´CHECKPOINT 1‚ê§CHECKPOINT 2‚ê§CHECKPOINT 3‚ê§foo‚ê§CHECKPOINT 4‚ê§bar‚ê§CHECKPOINT 5‚ê§¬ª

[15:32] *** rummik joined
[15:33] <felher> r: macro checkpoint { state $n = 0; ++$n; quasi { say "CHECKPOINT {$n}" } }; checkpoint for ^3; say "foo"; checkpoint; say "bar"; checkpoint

[15:33] <p6eval> rakudo c8de2e: OUTPUT¬´CHECKPOINT 3‚ê§CHECKPOINT 3‚ê§CHECKPOINT 3‚ê§foo‚ê§CHECKPOINT 3‚ê§bar‚ê§CHECKPOINT 3‚ê§¬ª

[15:33] *** lorn joined
[15:34] <felher> Ah, i think i got why there is a $n and a $i :)

[15:34] <masak> closure semantics.

[15:34] <felher> yep :) sweet :)

[15:35] <masak> r: macro checkpoint { my $i = ++(state $n); quasi { say "CHECKPOINT $i" } }; checkpoint; say "foo"; checkpoint; say "bar"; checkpoint

[15:35] <p6eval> rakudo c8de2e: OUTPUT¬´CHECKPOINT 1‚ê§foo‚ê§CHECKPOINT 2‚ê§bar‚ê§CHECKPOINT 3‚ê§¬ª

[15:36] <diakopter> masak: lol point-free

[15:36] <masak> felher: it's sweet, yes. it's like the code you're dealing with is alive, and smiling at you. it's not just text, it's *behavior*. :)

[15:36] <felher> masak: indeed :)

[15:36] <masak> felher: the more I program, the more I realize that we're all Dr Frankenstein. we're putting behavior into dead matter. and we're slowly getting increasingly good at it.

[15:37] <masak> the future, barring some major cataclysm, will be awesome.

[15:38] <felher> yeah :)

[15:44] * masak is on a roll with this advent post

[15:51] *** isBEKaml joined
[15:59] *** hash_table joined
[16:00] <masak> r; macro checkpoint { my $i = ++(state $n); quasi { say "CHECKPOINT $i" } }; checkpoint; for ^5 { checkpoint }; checkpoint

[16:01] <masak> r: macro checkpoint { my $i = ++(state $n); quasi { say "CHECKPOINT $i" } }; checkpoint; for ^5 { checkpoint }; checkpoint

[16:01] <p6eval> rakudo c8de2e: OUTPUT¬´CHECKPOINT 1‚ê§CHECKPOINT 2‚ê§CHECKPOINT 2‚ê§CHECKPOINT 2‚ê§CHECKPOINT 2‚ê§CHECKPOINT 2‚ê§CHECKPOINT 3‚ê§¬ª

[16:01] <masak> this nicely illustrates a difference between macros and subs.

[16:02] *** GlitchMr left
[16:04] *** erkan joined
[16:04] *** erkan left
[16:04] *** erkan joined
[16:07] <timotimo> is there a problem regarding the 23rd advent post?

[16:08] <masak> working on it.

[16:08] <masak> (I meant to write it yesterday, but forgot)

[16:11] <timotimo> that's fine :)

[16:12] *** birdwindupbird joined
[16:17] *** GlitchMr joined
[16:26] *** Vlavv left
[16:33] *** Vlavv_ joined
[16:42] *** david joined
[16:44] *** david left
[16:44] <isBEKaml> rn: my $foo = "boo"; say $foo.subst(rx:m/boo/, "far", :mm); #NYI?

[16:44] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unrecognized adverb :m(1) at /tmp/IYfl8z2IpH line 1:‚ê§------> [32mmy $foo = "boo"; say $foo.subst(rx[33m‚èè[31m:m/boo/, "far", :mm); #NYI?[0m‚ê§‚ê§Regex modifier m not valid on regex literal at /tmp/IYfl8z2IpH line 1:‚ê§------> ‚Ä¶

[16:44] <p6eval> ..rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Adverb m not allowed on rx‚ê§at /tmp/MuMFtXSjoB:1‚ê§------> [32my $foo = "boo"; say $foo.subst(rx:m/boo/[33m‚èè[31m, "far", :mm); #NYI?[0m‚ê§¬ª

[16:45] <masak> I don't think rx takes adverbs at all.

[16:45] <masak> by spec, I mean.

[16:45] <isBEKaml> masak: well then, the spec needs change. :)

[16:45] <isBEKaml> S05

[16:45] <GlitchMr> unlink Perl6 || true

[16:45] <GlitchMr> https://aur.archlinux.org/packages/ra/rakudo/PKGBUILD

[16:45] <GlitchMr> Interesting use of || true

[16:55] *** mj41 left
[16:58] *** birdwindupbird left
[17:01] *** mj41 joined
[17:07] <masak> advent post published: http://perl6advent.wordpress.com/2012/12/23/day-23-macros/

[17:07] <tadzik> yay

[17:07] <tadzik> masak++

[17:10] *** mj41 left
[17:10] *** isBEKaml left
[17:15] <felher> <3 "A Song of Ice and Fire" reference

[17:18] <masak> "A textual macro is a sword without a hilt. There's no safe way to grasp it."

[17:18] <masak> :)

[17:25] <felher> masak++ # nice blog post about macros that makes you wish the end of the next year is already here :)

[17:27] <masak> I don't promise all of those things will be in place by the end of next year. ;)

[17:27] <masak> two of the points are within the current grant.

[17:34] *** SamuraiJack joined
[17:45] *** azawawi joined
[17:52] <felher> masak: oh, there is a solution on Wikipedia for python. Is that the one you translated to Perl 6 and then to Haskell?

[17:58] <masak> felher: it is.

[17:58] <masak> I renamed all the variables and eliminated some of the Python boilerplate that Perl 6 doesn't need. (such as checking whether a hash entry exists before incrementing it)

[18:01] <felher> masak: I see :)

[18:04] <azawawi> hi

[18:04] <phenny> azawawi: 02 Dec 18:44Z <japhb> ask azawawi Would you mind using a different pastebin than the one at paste.debian.net (or configuring it to keep the pastes for longer), because they are expiring quite quickly (sometimes faster than I can backlog if I've been AFK for a couple days)?

[18:04] <phenny> azawawi: 03 Dec 04:53Z <japhb> tell azawawi your 1 == any(range) benchmark is now in perl6-bench, with two range limits to show scaling; but note that sorear says it may be somewhat problematic against smart implementations (but at least it notices the difference between smart and not)

[18:07] *** Abcxyz joined
[18:07] *** tcpr1347 joined
[18:08] <azawawi> http://feather.perl6.nl:3030/   # Farabi (with a Perl backend / JS Frontend), Web-based REPL, Run, Open file autocomplete... simple Perl 6 syntax highlighting... etc... etc :) 

[18:09] *** spider-mario joined
[18:11] * azawawi nap &

[18:11] *** azawawi left
[18:26] <GlitchMr> What macros are useful for?

[18:27] <GlitchMr> Making gotos?

[18:28] <diakopter> r: macro foo { quasi { {{{ macro boo { 1 } }}} } }; foo

[18:28] <p6eval> rakudo c8de2e: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block : Unknown QAST node type NQPMu‚ê§¬ª

[18:28] *** mj41 joined
[18:30] <diakopter> r: macro foo { quasi { say {{{ macro boo { quasi { {{{ 3 }}} } } }}} } }; foo

[18:30] <p6eval> rakudo c8de2e: OUTPUT¬´===SORRY!===‚ê§Method 'flat' not found for invocant of class 'NQPMu'‚ê§¬ª

[18:36] *** mtk left
[18:38] *** mtk joined
[18:40] *** xilo_ joined
[18:50] *** Kharec joined
[18:56] <hoelzro> hooray, heredoc hilighting! \o/

[18:56] <GlitchMr> :-)

[19:02] <timotimo> masak: that was a good post :)

[19:04] *** aindilis left
[19:05] *** aindilis joined
[19:12] <masak> timotimo: thanks. it did feel like it had something going for it. :)

[19:13] <GlitchMr> I've done Niecza Arch module. I guess I can upload it now?

[19:14] <GlitchMr> It looks like this: https://github.com/GlitchMr/arch-niecza

[19:18] <masak> GlitchMr: what are macros useful for? I like the quote in the latest advent post as an answer to that question.

[19:19] <masak> GlitchMr: I don't think you need anyone's permission to upload a Niecza Arch module. even if you do, forgiveness > permission.

[19:20] <GlitchMr> well, ok

[19:20] <GlitchMr> https://aur.archlinux.org/packages/niecza/

[19:28] <GlitchMr> Arch already had nice Rakudo Perl package, so why not Niecza?

[19:34] <masak> GlitchMr++

[19:35] <Abcxyz> (1..5 ==> reverse) ==> [\+]

[19:35] <Abcxyz> r: (1..5 ==> reverse) ==> [\+]

[19:35] <p6eval> rakudo c8de2e:  ( no output )

[19:35] <GlitchMr> "bash" as dependency is there just for fun (it's meaningless).

[19:35] <Abcxyz> r: say (1..5 ==> reverse) ==> [\+]

[19:35] <p6eval> rakudo c8de2e: OUTPUT¬´5 4 3 2 1‚ê§¬ª

[19:35] <GlitchMr> (but it's used in /usr/bin/niecza)

[19:36] <Abcxyz> r: say 1..5 ==> reverse ==> [\+]

[19:36] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix ==> instead‚ê§at /tmp/quldCkupyL:1‚ê§------> [32msay 1..5 ==> reverse ==>[33m‚èè[31m [\+][0m‚ê§¬ª

[19:38] <sorear> good * #perl6

[19:38] <Abcxyz> I think the parenthesis should be redundant in this, right?

[19:38] <GlitchMr> They aren't because of bug

[19:38] <PerlJam> Greetings 

[19:38] <GlitchMr> std: say 1..5 ==> reverse ==> [\+]

[19:38] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix ==> instead at /tmp/CPBOrQQm3a line 1:‚ê§------> [32msay 1..5 ==> reverse [33m‚èè[31m==> [\+][0m‚ê§Parse failed‚ê§FAILED 00:00 42m‚ê§¬ª

[19:39] <tadzik> in case you missed it: an open-source geeky board game:https://github.com/TableTopSecurity/d0x3d-the-game

[19:39] <Abcxyz> Is operator: ==> right associative or left associative?

[19:39] <Abcxyz> Where can I find these detailed information?

[19:40] <GlitchMr> http://doc.perl6.org/language/operators says it's neither

[19:40] <masak> it's a statement terminator.

[19:40] <hoelzro> masak++ # GoT reference

[19:41] <Abcxyz> OK... @_@

[19:41] <tadzik> heh, masak puts GoT references in his blogposts

[19:41] <tadzik> you could say that...

[19:41] <tadzik> ( ‚Ä¢_‚Ä¢)>‚åê‚ñ†-‚ñ†

[19:42] <tadzik> it is known

[19:42] <tadzik> (‚åê‚ñ†_‚ñ†)

[19:42] <tadzik> YEEEEEAH

[19:45] <masak> ;)

[19:47] <Abcxyz> What is GoT reference?

[19:48] <tadzik> GoT is Game of Thrones, a book

[19:48] <tadzik> the beginning to a long series of books :)

[19:49] <hoelzro> a very good series of books if you've got the time =)

[19:49] <tadzik> yeah, you need plenty of time. And winder is coming

[19:49] <hoelzro> indeed

[19:52] <Abcxyz> I see...

[19:52] <Abcxyz> I have some for Perl6 some bug reports and lots of new ideas.

[19:53] <Abcxyz> Is this the right place to discuss these?

[19:53] <tadzik> sure

[19:53] *** FROGGS joined
[19:54] <Abcxyz> 1.

[19:54] <Abcxyz> r: print$_

[19:54] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/1nZf4GbVMG:1‚ê§------> [32mprint[33m‚èè[31m$_[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modifier‚Ä¶

[19:55] <Abcxyz> :r say 3x$_

[19:55] <FROGGS> r: say 3x$_

[19:55] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/EXdrOZgj7K:1‚ê§------> [32msay 3[33m‚èè[31mx$_[0m‚ê§    expecting any of:‚ê§        whitespace‚ê§¬ª

[19:56] <FROGGS> hi Abcxyz 

[19:56] <flussence> that one seems self-explanatory

[19:56] <Abcxyz> Yes

[19:56] <Abcxyz> Are all the white spaces mandatory in Perl6 now?

[19:56] <Abcxyz> In Perl5 all these work fine.

[19:56] <FROGGS> I think so, yes

[19:56] <tadzik> not all of them, surely

[19:57] <tadzik> but some of them, yes

[19:57] <FROGGS> std: print$_

[19:57] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of bare 'print'; in Perl 6 please use .print if you meant $_, or use an explicit invocant or argument at /tmp/VZePAZqOpi line 1:‚ê§------> [32mprint[33m‚èè[31m$_[0m‚ê§Two terms in a row (listop with args requires whitespac‚Ä¶

[19:57] <flussence> the ones between [<alnum>|<punct>] ** 2 usually are

[19:57] <Abcxyz> Will this improve in the future? Since most of them are so obvious according to context: there is no ambiguity at all.

[19:59] *** hash_table left
[19:59] <FROGGS> if withspaces around x arn't mandatory, you don't know if x in 3x$_ is suffix, infix or prefix

[20:00] <Abcxyz> I see.

[20:00] <Abcxyz> That's why Perl5 accepts them, but Perl6 rejects.

[20:00] <Abcxyz> Since Perl5 doesn't have to distinguish these?

[20:01] <FROGGS> Perl 5 only has infixes, right?

[20:01] <Abcxyz> I guess so.

[20:01] <FROGGS> except [] and () and stuff

[20:01] <huf> and +

[20:01] <FROGGS> but these can't appear as infix

[20:01] <FROGGS> right

[20:01] <huf> and a ton of others :)

[20:01] <Abcxyz> Yes.

[20:01] <FROGGS> I'm not a language pro, just a "user"

[20:02] <Abcxyz> Fine.

[20:02] <Abcxyz> Usually I include whtespace in my one liner character countings.

[20:02] <Abcxyz> That's why I checked these...

[20:03] <masak> FROGGS: it's "whitespace", singular, as a mass noun.

[20:03] <Abcxyz> Yes.

[20:03] <FROGGS> ahh, see, everyday I learn something ;o)

[20:03] <masak> Abcxyz: even where there is no ambiguity, someone could define new operators and there would be ambiguity.

[20:04] <Abcxyz> Right.

[20:04] <Abcxyz> That is what is different in Perl6 from Perl5 now.

[20:04] <Abcxyz> So many possibilities of new operators.

[20:04] <doy> where are the rules for where whitespace is required documented?

[20:05] <Abcxyz> I don't think it is fully documented.

[20:05] <Abcxyz> But Perl5 uses heuristics to parse.

[20:05] <Abcxyz> So usually it understands you and does the right thing.

[20:05] <Abcxyz> Just like when you talk to a people face to face, you don't have to be grammatically correct, but they understand you.

[20:06] <Abcxyz> That's human language, right?

[20:06] <Abcxyz> And a lot of time Perl5 is parsing in that way.

[20:06] <doy> perl 5 only uses heuristics in very specific places, and i can't think of any that involve whitespace (except for a few annoying things that are newline-sensitive)

[20:08] <Abcxyz> I guess I would define it this way:

[20:08] <Abcxyz> When there is ambiguity, one of them makes the most possible sense, then interpret it this way.

[20:09] <Abcxyz> For example

[20:09] <Abcxyz> The defined-or operator: //

[20:09] <Abcxyz> and the regexp matching operator: //

[20:10] <Abcxyz> If there is ambiguity, Perl5 interprets it as defined-or

[20:10] <doy> "one of them makes the most sense" is only usually true

[20:10] <Abcxyz> Since you can always write the other in the form: m//

[20:10] <masak> doy: if you count STD.pm6 as documentation, it's all in there.

[20:10] <huf> Abcxyz: can you even have defined-or in a position to confuse it with //?

[20:11] <masak> doy: otherwise, the rule is quite simple: the operator after a term is infix if there's whitespace in-between or post(circum)fix if not.

[20:11] <Abcxyz> Maybe not, but the parser is not smart enough to distinguish that.

[20:11] <Abcxyz> Yet.

[20:11] <Abcxyz> So it uses heuristics directly in this case.

[20:11] <doy> masak: thanks, that was what i was curious about

[20:12] <doy> huf: yes, you can

[20:12] <Abcxyz> And another case, but we almost don't realize:

[20:12] <Abcxyz> 1..10

[20:12] <masak> Abcxyz: in Perl 6, an empty match // is disallowed.

[20:12] <Abcxyz> 1. . 0

[20:12] <Abcxyz> This is ambiguity.

[20:12] <Abcxyz> But we almost always mean 1 .. 10

[20:12] <masak> Abcxyz: and in the case of 1..10, Perl 6 disallows '1.' as a number :)

[20:13] <masak> you see, we put great thought into this. :)

[20:13] <Abcxyz> So the parse treats it that way, the most possible one, being understanding.

[20:13] <masak> ...whereas in Perl 6, we try to make the underlying parsing sane rather than DWIMmy.

[20:13] <masak> will probably scale better to derived dialects of Perl 6.

[20:13] <Abcxyz> What does it mean by: disallowing '1.' as a number?

[20:13] <masak> std: 1.

[20:13] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Decimal point must be followed by digit at /tmp/rEFlzRG2zo line 1:‚ê§------> [32m1.[33m‚èè[31m<EOL>[0m‚ê§Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/rEFlzRG2zo line 1 (EOF):‚ê§------> [32m1.[33m‚èè[31m<EOL>‚Ä¶

[20:14] <masak> means it's not allowed.

[20:14] <Abcxyz> ...

[20:14] <Abcxyz> That sounds scary to me.

[20:14] <masak> boo!

[20:14] *** pmurias left
[20:15] <Abcxyz> Since it means if I am Copy and Pasting the numerical results from other program's output into my perl script, I have to modify these every time?

[20:15] <Abcxyz> Before, perl is always the most flexible and versatile language in these kind of things...

[20:16] <timotimo> quote it and parse it with a simple regex?

[20:16] <doy> if you're copying and pasting numbers that use , as a decimal point, you have to modify them every time too

[20:16] <doy> there are all kinds of number formats, it's a bit unreasonable to expect perl to parse all of them

[20:16] <Abcxyz> I don't have to.

[20:16] <masak> also, it's *output*. when was the last time you saw "1." or similar in output?

[20:16] <Abcxyz> use pdl [ STRING ]

[20:16] <Abcxyz> if there is comma: ,

[20:17] <Abcxyz> use qw{ STRING } if there is whitespace

[20:17] <Abcxyz> So easy.

[20:18] <Abcxyz> Many language does this: in C: double d = 1.;

[20:19] <Abcxyz> Although you don't have to.

[20:19] <masak> r: say "1. 2. 3.".subst(/<?after \d> \./, "", :g)

[20:19] <p6eval> rakudo c8de2e: OUTPUT¬´1 2 3‚ê§¬ª

[20:19] <Abcxyz> But some language enforces the decimal point.

[20:19] <masak> so easy.

[20:19] <masak> you have a *programming language* at your fingertips.

[20:19] <masak> slightly wrongly formatted output shouldn't hinder you.

[20:20] <masak> r: say "1. 2.0 3".subst(/<?after \d> \. <!before \d>/, "", :g)

[20:20] <p6eval> rakudo c8de2e: OUTPUT¬´1 2.0 3‚ê§¬ª

[20:20] <Abcxyz> I know, there can always be work arounds.

[20:20] <masak> this isn't even that.

[20:20] <masak> it's just adapting output before you paste it as code. :)

[20:21] <Abcxyz> :r say 1

[20:21] <Abcxyz> :r say 1.0

[20:21] <masak> r: say 1.0

[20:21] <p6eval> rakudo c8de2e: OUTPUT¬´1‚ê§¬ª

[20:21] <Abcxyz> :r say 1.

[20:21] <Abcxyz> :r say 0.1

[20:21] <Abcxyz> :r say .1

[20:21] <masak> r: say 1.

[20:21] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/TfkY83FcTT:1‚ê§------> [32msay 1.[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        dotty method or postfix‚ê§¬ª

[20:21] *** pmurias joined
[20:21] <masak> r: say .1

[20:21] <p6eval> rakudo c8de2e: OUTPUT¬´0.1‚ê§¬ª

[20:22] <Abcxyz> In all these forms, only "1." is rejected.

[20:22] <masak> aye.

[20:23] <masak> that's the form that is causing trouble with things like infix:<..> and method dot.

[20:23] <Abcxyz> Just make the regexp greedy then...

[20:23] <timotimo> r: sub postfix:<.>($i) { $i }; say 1.;

[20:23] <p6eval> rakudo c8de2e: OUTPUT¬´1‚ê§¬ª

[20:23] <timotimo> i win.

[20:23] <masak> timotimo: :)

[20:23] <Abcxyz> As in 1..10, we always mean 1 .. 10 without even notice there is such underlying ambiguity.

[20:24] <FROGGS> masak: how do you make multiline commit messages in git with a subject? do you add \n's to -m="" ?

[20:24] <masak> Abcxyz: yes, but the parser is already in the 'number' rule, parsing the term.

[20:24] <masak> Abcxyz: it's won't back out if it already saw '1.', and then it won't understand '.10'

[20:24] <masak> Abcxyz: "Just make the regexp greedy" is more like the problem, not the solution.

[20:25] <masak> FROGGS: I tend to write them in $EDITOR...

[20:25] <masak> FROGGS: but in a Unix environment, you can just hit Enter until you terminate the quote.

[20:25] <masak> FROGGS: (in Windows, not so much)

[20:25] <FROGGS> okay, thanks

[20:26] <Abcxyz> Yes, I agree it is a implementation difficulty.

[20:26] <timotimo> i believe you can type \ before hitting enter in DOS.

[20:26] <Abcxyz> I just mean that in real life the meaning is almost certain, as my previous definition for heuristics, the most possible interpretation is clearly there.

[20:27] <masak> Abcxyz: indeed.

[20:27] <doy> r: sub postfix:<.> (Int $a) { $a }; say 1.

[20:27] <masak> Abcxyz: and Perl 5 takes that road.

[20:27] <p6eval> rakudo c8de2e: OUTPUT¬´1‚ê§¬ª

[20:27] <Abcxyz> Right.

[20:27] <masak> Abcxyz: Perl 6 doesn't. it lets every rule do its thing.

[20:28] <masak> which leads naturally to '1.' being disallowed.

[20:28] <doy> r: sub postfix:<.> (Int $a) { $a }; say 1. + 2.

[20:28] <p6eval> rakudo c8de2e: OUTPUT¬´3‚ê§¬ª

[20:28] <Abcxyz> I can imagine it is because the practical way we implements it.

[20:28] <masak> r: sub postfix:<.> (Int $a) { $a }; say 1..10

[20:28] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/_qp7pQyZa0:1‚ê§------> [32msub postfix:<.> (Int $a) { $a }; say 1..[33m‚èè[31m10[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        state‚Ä¶

[20:28] <masak> Abcxyz: no, it's because it's *consistent*.

[20:29] <masak> Abcxyz: I explained the reasons to you. did you understand them when I did?

[20:29] <Abcxyz> I guess partly.

[20:29] *** SamuraiJack left
[20:29] <masak> I agree that it is a fair bit different from how Perl 5 does it.

[20:29] <Abcxyz> Yes.

[20:30] <masak> that's because the guy who wrote the Perl 5 parser is involved in this project too, and he chose what he percieves to be a better way this time.

[20:30] <Abcxyz> He has changed. :)

[20:30] <masak> his code sure has :)

[20:30] *** stevan_ left
[20:31] <timotimo> it would be a real shame if perl6 were just perl5 reheated

[20:31] *** stevan_ joined
[20:32] <Abcxyz> It is not impossible to solve it in the grammar - rule system. But probably that will bring in a lot extra complexity to the grammar just to solve this one small problem, and it might be simpler just to make the rules easier to the computer.

[20:32] <lue> hello world o/

[20:32] <timotimo> not using the knowledge you gained from the previous version to create not only a "new" version , but also an "improved version" ... that would be sad

[20:34] <doy> masak: why doesn't ltm fix that?

[20:34] <doy> shouldn't .. be a priority over .?

[20:35] <Abcxyz> It is not easy.

[20:35] <Abcxyz> It takes a lot of work.

[20:36] <Abcxyz> And it only solve a small problem, so it probably won't be a priority when there are other things to improve now.

[20:36] <Abcxyz> Unless for perfectionism

[20:37] <FROGGS> phenny: tell jnthn that this is my questionable patch: https://github.com/FROGGS/rakudo/commit/ebf6acec98780f15a58d0183fc888d213da2b43d

[20:37] <phenny> FROGGS: I'll pass that on when jnthn is around.

[20:39] <masak> doy: because LTM decides which alternation wins. if the parser is already inside a term, parsing it, the decision between a decimal dot and the '..' isn't up to LTM, the decimal dot automatically wins as being part of the term.

[20:39] <masak> Abcxyz: if you're building a language that's meant to be extended, it makes a whole lot of sense to keep exceptions to a minimum.

[20:39] <masak> lue! \o/

[20:40] <doy> so effectively, it's just because .. is infix and . is postfix?

[20:40] <lue> .oO(If C<1.> was allowed, what would happen in C<1...10> ?)

[20:41] <masak> doy: oh! in your case with the postfix, it's because there's no whitespace.

[20:41] <masak> as I said above, that's how infix is distinguished from post(circum)fix.

[20:41] *** stevan_ left
[20:41] <masak> lue: also a good point.

[20:42] <doy> masak: hmmm

[20:42] * lue also personally never liked how "1." looked visually.

[20:42] <doy> so infix operators are only disambiguated by whitespace then

[20:42] <doy> it's only relevant if there's an ambiguity?

[20:43] <doy> postfix operators just always win if there is no whitespace, but postfix operators fail to even be considered if there is intervening whitespace

[20:43] <doy> is that it?

[20:44] <masak> if there's no whitespace, and both a postfix operator and an infix operator (not necessaarily of the same length) can match, the postfix wins.

[20:44] <masak> if there's whitespace, only infix operators are considered.

[20:46] <doy> okay

[20:46] <doy> that makes sense

[20:47] *** slayer101_ joined
[20:48] <masak> what's more, it keeps making sense as new terms and operators are added in derived Perl 6 dialects. :)

[20:48] <doy> yeah

[20:49] <doy> perl 6's whitespace rules have just always been something that seemed a bit odd and confusing to me

[20:49] <doy> but i feel like that's probably because i just don't know what they are

[20:50] <doy> in perl 5, you can get by almost entirely with just "word boundaries are equivalent to whitespace", or something along those lines, perl 6 does things a bit differently

[20:51] *** hash_table joined
[20:52] <moritz> masak++ # macro advent post

[20:52] <doy> i think some amount of documentation/spec that explains exactly what those rules are would be helpful

[20:52] *** sid_ joined
[20:53] <masak> doy: I agree.

[20:53] <masak> it's information that just sits in STD.pm6, the compilers, and the brains of old regulars like me :P

[20:54] <masak> should be documented somewhere.

[20:54] <Abcxyz> Is it possible to define an operator "...^*" other than "...^" ?

[20:54] * moritz calls for a braindump

[20:54] <moritz> Abcxyz: yes, if I understood the question correctly

[20:55] <moritz> the longest operator wins, in case of doubt

[20:55] <timotimo> r: sub infix:<...^*>($a, $b) { say "i have $a and $b"; $a...^$b }; say 5...^*10;

[20:55] <p6eval> rakudo c8de2e: OUTPUT¬´i have 5 and 10‚ê§5 6 7 8 9‚ê§¬ª

[20:55] <timotimo> easiest to just try

[20:55] *** cognominal joined
[20:56] <Abcxyz> So after I've defined that, will this work without whitespace? "1, *+1, ...^*>10"

[20:56] <Abcxyz> Sorry, "1,*+1...^*>10"

[20:56] <moritz> Abcxyz: why don't you just try it?

[20:57] <Abcxyz> :r 1,*+1...^*>10

[20:57] <masak> it's 'r' and then ':'

[20:57] <Abcxyz> r: 1,*+1...^*>10

[20:57] <p6eval> rakudo c8de2e:  ( no output )

[20:57] <masak> and you need to 'say' your output.

[20:57] <Abcxyz> r: say 1,*+1...^*>10

[20:57] <p6eval> rakudo c8de2e: OUTPUT¬´1 2 3 4 5 6 7 8 9 10‚ê§¬ª

[20:58] *** sid_ left
[20:59] <Abcxyz> r: sub infix:<< ...^*> >>($a, $b){}; say 1,*+1...^*>10

[20:59] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[20:59] *** stevan_ joined
[20:59] <masak> WhateverCode.new is what '*+1' comes out looking like.

[20:59] <Abcxyz> r: say 1,*+1...^*>10

[20:59] <p6eval> rakudo c8de2e: OUTPUT¬´1 2 3 4 5 6 7 8 9 10‚ê§¬ª

[21:00] <masak> er, '*+(1...^*>10)', I mean.

[21:00] <Abcxyz> Interesting.

[21:01] <masak> actually, I'm not 100% sure where the '>' ends up in the AST.

[21:02] <Abcxyz> So it interprets it as: ( 1, ( * + ( 1 infix:<< ...^*> >> 10 ) ) )

[21:02] *** GlitchMr left
[21:05] *** hash_table left
[21:05] <Abcxyz> :r 1, * + Nil

[21:05] <masak> 'r', then ':'

[21:05] <Abcxyz> ...

[21:06] <masak> it's short for 'rakudo:'

[21:06] <moritz> :wq!

[21:06] * hugme hugs moritz, good vi(m) user!

[21:06] <Abcxyz> r: 1, * + Nil

[21:06] <p6eval> rakudo c8de2e:  ( no output )

[21:06] <LoRe> do not use :wq, use :x instead

[21:06] * masak hugs moritz, too, even though he probably did it intentionally ;)

[21:06] <masak> LoRe: nono, use ZZ :)

[21:06] *** FROGGS left
[21:06] <timotimo> no, pull the plug and do everything with swap files

[21:06] <Abcxyz> r: say 1, * + Nil

[21:06] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:07] <LoRe> or that, but :wq is harmful

[21:07] <diakopter> rn: :wq

[21:07] <Abcxyz> I fogot the 'say' again

[21:07] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362:  ( no output )

[21:07] <Abcxyz> r: say 1, * + Nil

[21:07] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:08] <Abcxyz> r: sub infix:<< ...^*> >>($a, $b){}; say 1,*+1...^*>10

[21:08] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:09] <Abcxyz> It's the same thing.

[21:09] <tadzik> LoRe: how is wq harmful?

[21:09] <LoRe> tadzik: it always writes the file, even if it is unchanged, :x only writes if modified

[21:09] *** FROGGS_ joined
[21:10] <moritz> r: sub infix:<< ...^*> >>($a, $b){ 'blubb'}; say 1,*+1...^*>10

[21:10] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:10] <moritz> r: sub infix:¬´...^*>¬ª($a, $b){ 'blubb'}; say 1,*+1...^*>10

[21:10] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:10] <LoRe> ok, it's not that harmful, but changes timestamps

[21:10] <timotimo> you need to call it

[21:10] <Abcxyz> r: say 1, * + 'blubb'

[21:10] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:10] <timotimo> the * + is doing the conversion

[21:10] <tadzik> yeah, :x seems saner

[21:10] <Abcxyz> That' how it reads

[21:10] <moritz> r: sub infix:¬´...^*>¬ª($a, $b){ 'blubb'}; say 1,+1...^*>10

[21:10] <p6eval> rakudo c8de2e: OUTPUT¬´1blubb‚ê§¬ª

[21:10] <moritz> timotimo++

[21:11] *** bruges joined
[21:14] <masak> nice. http://paulgraham.com/fix.html # via @sheeshee++

[21:15] <moritz> I disagree with some of the details, but in general, yes, nice

[21:16] <masak> there's certainly room for disagreement.

[21:16] <diakopter> Perl 6: No other language has enough of anything

[21:17] <moritz> (including insanity)

[21:18] <masak> or "Perl 6: Perl 5 is a kludge."

[21:18] <masak> guess that one's almost too obvious to state.

[21:18] <Abcxyz> So even the Perl group consider this as true?

[21:18] <diakopter> Perl 6: Where else will you find the kitchen sink?

[21:18] <masak> Abcxyz: everyone is entitled to their own opinions. everyone isn't entitled to their own facts. ;)

[21:19] <timotimo> everyone is unentitled?

[21:19] <masak> Perl 5 *is* a kludge. one that makes bazillions out in the industry each day, but still a kludge.

[21:20] <Abcxyz> I think Perl5 is really nice, except for so many historical vestiges that cannot be thrown away for compatibility sake.

[21:20] <masak> Perl 6 is very much sitting down and saying "there are *good* things in there. let's put them on a sane foundation and see what language we get."

[21:20] <lue> .oO(Perl 6: There's too big a leap required to get to P7)

[21:20] <Abcxyz> The regexp is a big surprise to me, since before I was using C++ to treat streams...

[21:20] <masak> (this was what my 24th slot post was gonna be about, btw) :)

[21:21] <lue> masak: what specifically?

[21:21] <masak> lue: "You should think of Perl 6 more as Perl 16" :)

[21:21] <masak> lue: nothing specifically. the whole *language* is a rewrite according to that kind of thinking.

[21:23] <diakopter> Perl 6: No ho-hum. Just tra-la-la.

[21:23] <lue> (I'll assume you didn't mean P16 < P6)

[21:24] <diakopter> Perl 6: 100 years ahead, but 12 years behind, so 88 years ahead.

[21:24] <masak> diakopter: *lol*

[21:25] <flussence> 88MPH?!?

[21:30] <flussence> something I was thinking about recently, a generic HTTP test suite would be useful to have. Trying to figure out how it'd be automated is pretty hard though...

[21:30] <masak> mocks.

[21:30] <masak> if you can mock time, surely you can mock HTTP ;)

[21:30] <lue> perl6: "because I" ==> (say so $_);

[21:30] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Sorry, do not know how to handle this case of a feed operator yet.‚ê§at /tmp/ETZ8Sg20EY:1‚ê§------> [32m"because I" ==> (say so $_)[33m‚èè[31m;[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§¬ª‚Ä¶

[21:30] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: Feed ops NYI‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1435 (die @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3353 (infix:<==>> @ 4) ‚ê§  at /tmp/xQb4gHHohG line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting li‚Ä¶

[21:30] <masak> flussence: https://en.wikipedia.org/wiki/Mock_object

[21:31] <masak> flussence: https://github.com/jnthn/test-mock

[21:31] <flussence> ooh, pre-existing stuff

[21:32] <masak> :)

[21:32] *** stevan_ left
[21:33] <diakopter> Perl 6: Because no one blithely loves recursive Death Marches enough

[21:34] <cognominal> that's perl 6..*    the developpers have almost finished their first take to reify the sequence beginning to gather the first version number.

[21:34] <flussence> masak: I have a sort-of plan for doing it already, it'd be a runtime-agnostic list of instructions for what requests and responses are supposed to happen, then I write a bailador app (or whatever) to implement those. It wouldn't necessarily have to be perl6-specific either :)

[21:35] <cognominal> I suppose that 6..** with hyperwhatever is infinity and beyond

[21:36] <diakopter> Perl 6: Because no one had taken Second System Syndrome far enough yet

[21:37] <masak> diakopter: note that's pg's original one's weren't overly bitter.

[21:37] <masak> ones*

[21:37] <lue> Perl 6: No-one had yet created their language with -Ofun

[21:37] <masak> I'm pretty sure that's not strictly true :)

[21:38] <diakopter> masak: truly one can state those entirely non-bitterly; blithely even

[21:38] <diakopter> some people love death marches

[21:38] <timotimo> well, if laughs are equivalent to fun, LOLCODE would certainly be a contestant.

[21:40] <diakopter> masak: embrace the fail; it loves you anyway

[21:40] <masak> I... guess.

[21:41] <diakopter> I mean, one could talk about redefining success..

[21:42] <diakopter> or just leaving it uselessly ambiguous

[21:46] <Abcxyz> r: say sub infix:¬´...^*>¬ª($a, $b) is looser(&infix:<+>){ 'blubb' }

[21:46] <p6eval> rakudo c8de2e: OUTPUT¬´sub+{precedence} infix:<...^*>>($a, $b) { ... }‚ê§¬ª

[21:46] <Abcxyz> r: say 1,*+1...^*>10

[21:46] <p6eval> rakudo c8de2e: OUTPUT¬´1 2 3 4 5 6 7 8 9 10‚ê§¬ª

[21:47] <timotimo> that .perling is misleading

[21:47] <Abcxyz> r: sub infix:¬´...^*>¬ª($a, $b) is looser(&infix:<+>){ 'blubb' }; say 1,*+1...^*>10

[21:47] <p6eval> rakudo c8de2e: OUTPUT¬´1WhateverCode.new()‚ê§¬ª

[21:47] <Abcxyz> r: sub infix:¬´...^*>¬ª($a, $b) is looser(&infix:<+>){ 'blubb' }; say 1,+1...^*>10

[21:47] <p6eval> rakudo c8de2e: OUTPUT¬´1blubb‚ê§¬ª

[21:49] *** mj41 left
[21:57] *** slayer101_ left
[21:59] *** pmurias left
[22:01] *** pmurias joined
[22:01] *** kaare_ left
[22:02] *** Kharec left
[22:03] <Abcxyz> r: say given 9 { 0 when $_ %% 3; 1 }

[22:03] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/bsaYNIOHpY:1‚ê§------> [32msay given 9 [33m‚èè[31m{ 0 when $_ %% 3; 1 }[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§¬ª

[22:04] <Abcxyz> r: sub s () { given 9 { 0 when $_ %% 3; 1 } }; say s;

[22:04] <p6eval> rakudo c8de2e: OUTPUT¬´1‚ê§¬ª

[22:04] <Abcxyz> Why this does not return 0 ?

[22:06] <masak> Abcxyz: because statement-mod 'when' doesn't leave the contextualizer block.

[22:06] <masak> the ordinary 'when' does.

[22:09] <Abcxyz> so $_ is Nil?

[22:10] <Abcxyz> I am translating my previous Perl5 ProjectEuler code into Perl6.

[22:10] <Abcxyz> So all these are working code in Perl5.

[22:11] <Abcxyz> It's good way to find bugs also.

[22:11] <masak> in Perl 5, statement-mod 'when' does leave the contextualizer block.

[22:11] <masak> but that's a bug in Perl 5, not in the Perl 6 implementations ;)

[22:11] <masak> (IMNSHO)

[22:11] <Abcxyz> What does it mean by leaving the contextulizer block? How does that effect $_?

[22:12] <masak> r: sub s () { given 9 { when $_ %% 3 { 0 }; 1 } }; say s;

[22:12] <p6eval> rakudo c8de2e: OUTPUT¬´0‚ê§¬ª

[22:12] <masak> does that answer your question?

[22:12] <Abcxyz> Yes,

[22:12] <Abcxyz> but what is the meaning of your previous sentence?

[22:13] <Abcxyz> Is there a link I can read on this?

[22:14] *** mj41 joined
[22:15] <masak> S04, I guess.

[22:21] *** stevan_ joined
[22:22] <doy> r: sub s () { given 9 { return 0 when $_ %% 3; 1 } }; say s

[22:22] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/L1ou2HrobS:1‚ê§------> [32m 9 { return 0 when $_ %% 3; 1 } }; say s[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§¬ª

[22:22] <doy> r: sub s () { given 9 { return 0 when $_ %% 3; 1 } }; say s;

[22:22] <p6eval> rakudo c8de2e: OUTPUT¬´0‚ê§¬ª

[22:24] <masak> that first one is arguably a bug.

[22:24] <masak> r: sub s {}; say s

[22:24] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/LJm1RVH5Du:1‚ê§------> [32msub s {}; say s[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§¬ª

[22:25] * masak submits rakudobug

[22:26] <masak> std: sub s {}; say s

[22:26] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No delimiter found at /tmp/0ivzQQ5JQE line 1 (EOF):‚ê§------> [32msub s {}; say s[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 42m‚ê§¬ª

[22:26] <masak> std: sub s {}; say s;

[22:26] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Regex not terminated at /tmp/kOLlJYIE3C line 1 (EOF):‚ê§------> [32msub s {}; say s;[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 43m‚ê§¬ª

[22:26] <masak> right.

[22:26] <masak> it's the 's;' case that is wrongly parsed.

[22:28] <masak> 'night, #perl6

[22:31] *** mcglk joined
[22:35] <pmurias> jnthn: ping

[22:36] <pmurias> masak: 'night

[22:36] <Abcxyz> night

[22:38] <gattschardo> std: sub s {}; say s();

[22:38] <p6eval> std a8bc48f: OUTPUT¬´ok 00:00 42m‚ê§¬ª

[22:41] *** sftp joined
[22:43] *** cognominal left
[22:50] <Abcxyz> std: sub s {}; say s();

[22:50] <p6eval> std a8bc48f: OUTPUT¬´ok 00:00 42m‚ê§¬ª

[22:50] <Abcxyz> std: sub s {}; say s()

[22:50] <p6eval> std a8bc48f: OUTPUT¬´ok 00:00 43m‚ê§¬ª

[22:50] <Abcxyz> std: sub s {}; say s

[22:50] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No delimiter found at /tmp/WZYxiQM5mo line 1 (EOF):‚ê§------> [32msub s {}; say s[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 42m‚ê§¬ª

[22:50] <Abcxyz> std: sub s {}; say s;

[22:50] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Regex not terminated at /tmp/xKF_rk8RnY line 1 (EOF):‚ê§------> [32msub s {}; say s;[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 43m‚ê§¬ª

[22:51] <Abcxyz> It seems that Perl6 does not understand bareword functions well.

[22:52] <diakopter> r: sub s { 55 }; say s;

[22:52] <p6eval> rakudo c8de2e: OUTPUT¬´55‚ê§¬ª

[22:52] <diakopter> r: sub s { say 55 }; s

[22:52] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/fATj0WLr68:1‚ê§------> [32msub s { say 55 }; s[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modifier‚ê§‚Ä¶

[22:52] <diakopter> r: sub s { say 55 }; s;

[22:52] <p6eval> rakudo c8de2e: OUTPUT¬´55‚ê§¬ª

[22:52] <diakopter> r: sub s { say 55 }; s‚ê§

[22:52] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/O5CgWGj9zh:2‚ê§------> [32m<BOL>[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement modifier‚ê§        statem‚Ä¶

[22:53] <Abcxyz> In: "for lines() { ... }", the parenthesis cannot be omitted neither.

[22:53] <Abcxyz> I guess this should be a bug for now.

[22:53] <diakopter> rn: for (lines) { .say }

[22:53] <p6eval> rakudo c8de2e: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdteil du inmi‚Ä¶

[22:53] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdtei‚Ä¶

[22:54] <Abcxyz> What happens if you remove the "()"

[22:54] <diakopter>  rn: for lines { .say }

[22:54] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/DDJpTN5vRR:1‚ê§------> [32mfor lines { .say }[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        method arguments‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        stat‚Ä¶

[22:54] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Missing block at /tmp/5Ve7vISWzO line 1 (EOF):‚ê§------> [32mfor lines { .say }[33m‚èè[31m<EOL>[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[22:55] <Abcxyz> r: for lines { .say }

[22:55] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/cf3jsPDorE:1‚ê§------> [32mfor lines { .say }[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        method arguments‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§        stat‚Ä¶

[22:55] <Abcxyz> r: for (lines) { .say }

[22:55] <p6eval> rakudo c8de2e: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdteil du inmi‚Ä¶

[22:55] <Abcxyz> 123

[22:55] <Abcxyz> r: for lines() { .say }

[22:55] <p6eval> rakudo c8de2e: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdteil du inmi‚Ä¶

[22:55] <timotimo> r: say glob

[22:55] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§    glob used at line 1‚ê§‚ê§¬ª

[22:56] <timotimo> r: say qp/./.^methods

[22:56] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/piWNoX8QHs:1‚ê§------> [32msay qp/.[33m‚èè[31m/.^methods[0m‚ê§    expecting any of:‚ê§        dotty method or postfix‚ê§¬ª

[22:57] *** REPLeffect left
[22:57] *** mj41 left
[22:57] *** REPLeffect joined
[23:00] *** spider-mario left
[23:06] *** xenoterracide joined
[23:09] *** cognominal joined
[23:17] *** REPLeffect left
[23:17] *** REPLeffect joined
[23:25] *** PacoAir left
[23:28] *** Tim-Tom joined
[23:33] <Abcxyz> How do you express this idea?

[23:33] <Abcxyz> my @list = 5..10; say 0 ...^ * -> $idx { @list[$idx] > 8 }

[23:35] *** rindolf left
[23:35] *** pmurias left
[23:35] <Tim-Tom> Abcxyz: I'm not sure what you're attempting. Do you want to report all elements of list that are greater than 8, create a list of true false values for items greater than 8?

[23:37] *** mj41 joined
[23:39] <Tim-Tom> Abcxyz: As it is, what you've written would report false until it gets to the 4th element, then report true for 3 elements, then false for all eternity (perhaps with warnings about undef). Which is probably not what you intended

[23:40] <Abcxyz> I wanted to get all the index for @list that contains the elems le 8

[23:40] <Abcxyz> my @list = 5..10; say @list[  0 ...^ * -> $idx { @list[$idx] > 8 }  ]

[23:40] <Abcxyz> With this I hope to print: 5 6 7 8

[23:42] *** xinming left
[23:42] <Abcxyz> Because: "my @list = 5..10; say @list[  0 ...^ @list[*] > 8  ]" Definite does not do what I want, the * in @list[*] is used as @list.elems instead.

[23:43] <Tim-Tom> Well if your end result is supposed to be 5,6,7,8, you probably want "my @list = 5..10; say @list.grep: * <= 8"

[23:44] *** xinming joined
[23:44] <Abcxyz> Yeah, maybe I should do that.

[23:44] <Abcxyz> I just wanted to make the * really functional.

[23:45] <Abcxyz> In a sense that they may be more interesting sequences that it can express directly.

[23:45] <Abcxyz> But I can't foresee that yet.

[23:45] <Tim-Tom> But if you want to go via indexes, you really want 0 ..^ @list

[23:45] <Tim-Tom> or the equivalent just ^@list

[23:48] <Abcxyz> I want to make the "* > 8" in "0, *+1 ...^ * > 8" a more powerful function.

[23:48] <Tim-Tom> Sorry, that should apparently be ^+@list

[23:48] <Abcxyz> I know.

[23:48] <Abcxyz> I wanted to know how to express something beyond the * > 8.

[23:49] <Abcxyz> Like @list[*] > 8

[23:50] <Abcxyz> Or rank(*) > 8

[23:50] <Tim-Tom> Ah. The simple answer is to just use the subroutine form. so 0, *+1 ...^ { @list[$^a] <= 8 }

[23:51] <Tim-Tom> Or -> $a { @list[$a] <= 8} if you don't like the automatic parameters

[23:51] <Abcxyz> Yes!

[23:51] <Abcxyz> This is exactly what I want!

[23:51] <Abcxyz> Thanks!

[23:51] <Tim-Tom> Sure, glad I could help :)

[23:52] <Abcxyz> r: my @list = 5..10; 0, *+1 ...^ -> $a { @list[$a] > 8 }

[23:52] <p6eval> rakudo c8de2e:  ( no output )

[23:52] <Abcxyz> r: my @list = 5..10; say 0, *+1 ...^ -> $a { @list[$a] > 8 }

[23:52] <p6eval> rakudo c8de2e: OUTPUT¬´0 1 2 3‚ê§¬ª

[23:52] <Abcxyz> r: my @list = 5..10; say @list[  0, *+1 ...^ -> $a { @list[$a] > 8 }  ]

[23:52] <p6eval> rakudo c8de2e: OUTPUT¬´5 6 7 8‚ê§¬ª

[23:54] <Abcxyz> Thanks

