[00:00] *** shinobicl___ joined
[00:05] *** Leiting joined
[00:06] *** shinobicl___ left
[00:08] *** Leiting left
[00:09] <dalek> nqp: 2246b9d | jnthn++ | src/HLL/Grammar.pm:

[00:09] <dalek> nqp: Fix preclim handling in operator precedence parser to be consistent with STD's semantics.

[00:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2246b9dd83

[00:10] <jnthn> pmichaud: Don't worry, 2246b9d helped. :)

[00:10] <dalek> rakudo/stdinit: 4f23c1a | jnthn++ | src/Perl6/Actions.pm:

[00:10] <dalek> rakudo/stdinit: Fix assign_op calls.

[00:10] <dalek> rakudo/stdinit: review: https://github.com/rakudo/rakudo/commit/4f23c1af53

[00:11] *** pernatiy joined
[00:17] <dalek> nqp/bs: 19f1639 | moritz++ | / (2 files):

[00:17] <dalek> nqp/bs: [bigint] fix detection of negative numbers from binary ops

[00:17] <dalek> nqp/bs: 

[00:17] <dalek> nqp/bs: This should fix RT #109740

[00:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/19f1639689

[00:17] <dalek> nqp/bs: 2246b9d | jnthn++ | src/HLL/Grammar.pm:

[00:17] <dalek> nqp/bs: Fix preclim handling in operator precedence parser to be consistent with STD's semantics.

[00:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2246b9dd83

[00:17] <dalek> nqp/bs: 239b54f | jnthn++ | / (6 files):

[00:17] <dalek> nqp/bs: Merge branch 'master' into bs

[00:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/239b54ffb1

[00:31] <jnthn> sleep &

[00:33] *** lestrrat left
[00:33] *** lestrrat joined
[00:34] *** tty234_ joined
[00:37] *** lestrrat left
[00:38] *** lestrrat joined
[00:38] *** tty234_ left
[00:44] *** thou left
[00:48] *** whiteknight joined
[01:08] *** woosley joined
[01:18] *** scott__ joined
[01:23] <sorear> good * #perl6

[01:24] <sorear> eviltwin_b: AIUI, line buffering of stdin never(well ok there are corner cases) affects semantics

[01:24] <sorear> eviltwin_b: you may be thinking of stdout, which is line buffered if terminal, block buffered otherwise

[01:30] <TimToady> getc works for single character input as long as you call 'stty raw -echo min 1 time 1' first (on *nix)

[01:30] <TimToady> be sure to call 'stty sane' on the way back out though

[01:39] *** woosley left
[01:41] *** woosley joined
[01:48] *** tty234 left
[02:02] <flussence> .oO( tty internals are the scariest thing I think I've ever encountered in *nix )

[02:03] * eviltwin_b already pointed to "stty -g" which is a more accurate way to save and later restore tty settings

[02:05] *** replore joined
[02:12] *** sudokode left
[02:15] *** Chillance joined
[02:29] *** sudokode joined
[02:43] *** mls_ left
[02:43] *** mls joined
[02:43] *** kmwallio joined
[02:44] *** wolfman2000 joined
[02:49] *** whiteknight left
[03:19] *** shinobicl___ joined
[03:20] *** carlin left
[03:24] *** lestrrat left
[03:25] *** lestrrat joined
[03:27] *** DarthGandalf left
[03:33] *** DarthGandalf joined
[03:33] *** kmwallio left
[03:33] *** wooden left
[03:37] *** aloha left
[03:38] *** unobe left
[03:38] *** aloha joined
[03:41] *** orafu left
[03:42] *** orafu joined
[03:50] *** unobe joined
[04:18] *** [Coke] left
[04:23] *** Su-Shee_ joined
[04:25] *** wolfman2000 left
[04:26] *** Su-Shee left
[04:35] <skids> norole A [:$b] { has $.a = $b; }; my $a = 1; $a does A[:b(42)]; $a.a.say; my $b = 1; $b does A[:b(13)]; $b.a.say; $a.a.say;m: 

[04:35] <skids> erk.

[04:35] <skids> nom: role A [:$b] { has $.a = $b; }; my $a = 1; $a does A[:b(42)]; $a.a.say; my $b = 1; $b does A[:b(13)]; $b.a.say; $a.a.say;

[04:35] <p6eval> nom 2251cb: OUTPUT«42␤13␤13␤»

[04:35] * skids scratches head.

[04:36] <sorear> you used 'does' on a variable of type 'Int'

[04:36] <sorear> you've modified the literal constant 1

[04:36] <sorear> nom: my $a = 1; $a does role { method Str { "Suprise!" } };    say 1

[04:36] <p6eval> nom 2251cb: OUTPUT«Suprise!␤»

[04:37] <sorear> did you really mean to modify a constant?

[04:37] *** winnerdood joined
[04:37] <benabik> I'm constantly surprised that but and does modify the variable in place rather than returning a new object.

[04:38] <sorear> benabik: does modifies in place

[04:38] <benabik> But I've been doing a _lot_ of functional programming.

[04:38] <sorear> but returns a new object

[04:38] <sorear> that's why we have two operators!

[04:38] <skids> Ah, well that explains why $a.a changed then :-)

[04:39] <benabik> I thought it was because does took a role and but takes a value.

[04:39] <TimToady> maybe we should remove does

[04:40] <TimToady> except as a trait declartor

[04:40] *** ponbiki joined
[04:41] <moritz> o/

[04:42] <sorear> benabik: Both take both forms.

[04:42] *** shinobicl___ left
[04:42] <benabik> sorear: Oh!

[04:43] <benabik> I've never seen that, but neat.

[04:48] *** winnerdood left
[05:10] *** birdwindupbird joined
[05:40] *** replore left
[05:44] *** kaleem joined
[06:16] *** thou joined
[06:30] *** yertalert left
[06:42] *** cognominal___ joined
[06:44] *** cognominal_ left
[06:47] *** overrosy left
[06:47] *** Vlavv` left
[06:47] *** ashleydev left
[06:47] *** etneg left
[06:47] *** kshannon left
[06:47] *** Gothmog_ left
[06:47] *** TimToady left
[06:47] *** Yappoko___ left
[06:50] *** kaleem left
[06:51] *** overrosy joined
[06:51] *** Vlavv` joined
[06:51] *** ashleydev joined
[06:51] *** etneg joined
[06:51] *** kshannon joined
[06:51] *** Gothmog_ joined
[06:51] *** TimToady joined
[06:51] *** Yappoko___ joined
[06:54] *** kaleem joined
[06:54] *** wtw joined
[06:57] *** zby_home left
[07:59] *** ponbiki left
[08:04] *** mj41 joined
[08:11] *** tarch joined
[08:12] *** Khisanth left
[08:14] <dalek> niecza: 419e3bd | sorear++ | src/niecza:

[08:14] <dalek> niecza: Change |$ to | in src/niecza

[08:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/419e3bd929

[08:14] <dalek> niecza: 05e3637 | sorear++ | src/Niecza (2 files):

[08:14] <dalek> niecza: Allow defining extra operators in the setting, and implement an efficient way to load a bunch of operators into $~MAIN in one go

[08:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/05e363770e

[08:14] <dalek> niecza: de81026 | sorear++ | lib/CORE.setting:

[08:14] <dalek> niecza: First cut at enabling Set operators

[08:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/de8102626f

[08:20] *** aindilis left
[08:23] *** snearch joined
[08:27] *** Khisanth joined
[08:27] <dalek> niecza: 891be08 | sorear++ | lib/CORE.setting:

[08:27] <dalek> niecza: Switch Set and a few other things to at_key so that slicing works more sanely

[08:27] <dalek> niecza: review: https://github.com/sorear/niecza/commit/891be089b8

[08:29] <bbkr1> JSON::RPC is back on nom, including client and server 2.0 spec :)

[08:30] <sorear> Yayness.

[08:30] <bbkr1> moritz: your fallback hint worked perfectly - https://github.com/bbkr/jsonrpc/blob/master/lib/JSON/RPC/Client.pm#L10-35 - thanks! Now it's the easiest client to use ever.

[08:31] *** Su-Shee_ is now known as Su-Shee

[08:41] <sorear> std: constant Set term:<∅> = set();

[08:41] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing initializer on constant declaration at /tmp/BUnxDw3qZd line 1:␤------> [32mconstant Set [33m⏏[31mterm:<∅> = set();[0m␤Confused at /tmp/BUnxDw3qZd line 1:␤------> [32mconstant Set [33m⏏[31mterm:<∅> = set();[0m␤    expecti…

[08:49] *** birdwind1pbird joined
[08:53] <masak> g'morning, #perl6

[08:54] <dalek> niecza: df96012 | sorear++ | lib/CORE.setting:

[08:54] <dalek> niecza: Eliminate is equiv on multi candidates; niecza should carp on this but doesn't yet.  Also, forgot term:<∅>.

[08:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/df960121bd

[08:54] <sorear> g'masak morning.

[08:54] <sorear> niecza: 1

[08:54] <p6eval> niecza v14-23-g0699296:  ( no output )

[08:54] <sorear> evalbot rebuild niecza

[08:54] <p6eval> OK (started asynchronously)

[08:56] <dalek> Rebuild of niecza complete.

[08:56] <Timbus> oh god they're like telepathically linked twins that complete each others sentences

[08:57] <Timbus> and that is just creepy

[08:57] <sorear> niecza: say set(2,3,4) ∩ set(3,4,5)

[08:57] <p6eval> niecza v14-28-gdf96012: OUTPUT«set(3, 4)␤»

[08:58] <masak> but creepy-good, right? :)

[08:58] * sorear shows off the new functionality ^^^

[08:58] <masak> ooh, ∩!

[08:59] <sorear> niecza: say ∅

[08:59] <p6eval> niecza v14-28-gdf96012: OUTPUT«set()␤»

[08:59] <masak> niecza: say (2,3,4) ∩ (3,4,5)

[08:59] <p6eval> niecza v14-28-gdf96012: OUTPUT«set(3, 4)␤»

[09:00] <masak> \o/

[09:00] <masak> niecza: say (2,3,4) (&) (3,4,5)

[09:00] <p6eval> niecza v14-28-gdf96012: OUTPUT«set(3, 4)␤»

[09:00] <masak> (\o/)

[09:00] <sorear> niecza: say (2,3,4) [&] (3,4,5)

[09:00] <Timbus> oh good, i can type that

[09:00] <p6eval> niecza v14-28-gdf96012: OUTPUT«Potential difficulties:␤  Useless use of [] around infix op at /tmp/4AwqQzX3B_ line 1:␤------> [32msay (2,3,4) [33m⏏[31m[&] (3,4,5)[0m␤␤all((2, 3, 4), (3, 4, 5))␤»

[09:01] <Timbus> why not allow 'n' and 'u'

[09:02] <Timbus> i guess its not that common to use them

[09:02] * sorear thinks (&) should require more keypresses than ++

[09:03] * masak counts 4 for (&) and 3 for ++

[09:03] <masak> oh, but you meant as opposed to n which requires 1. I see.

[09:04] <masak> yeah, I feel 'n' and 'u' are "too cute", perhaps.

[09:04] <masak> if you want them, they're two lines of code.

[09:04] <sorear> 6 for ∩ ... I need a better input method

[09:04] *** daxim joined
[09:05] <sorear> ctrl shift 2 2 2 9, mnemonic is not

[09:05] <Timbus> true enough, i just cant see any harm in allowing them

[09:06] * sorear --> sleep

[09:08] *** mtths joined
[09:09] *** [particle] left
[09:14] *** snearch left
[09:16] <dalek> specs: 0c822b5 | masak++ | S32-setting-library/Exception.pod:

[09:16] <dalek> specs: [S32/Exception] corrected typo

[09:16] <dalek> specs: 

[09:16] <dalek> specs: Spotted by Util++.

[09:16] <dalek> specs: review: https://github.com/perl6/specs/commit/0c822b5989

[09:21] <masak> I should make a Perl 6 input method for irssi, and then share it with everybody else. :)

[09:25] <masak> [backlog] +1 on removing 'does' as an operator, especially since it's basically but=

[09:31] <tadzik> hrm, I quite like does

[09:35] *** flussence left
[09:35] *** flussence joined
[09:50] *** alvis joined
[09:51] *** woosley left
[09:51] *** dakkar joined
[09:53] <masak> this course intrigues me: http://courses.csail.mit.edu/6.851/spring12/ -- and both notes and videos upcoming. nice!

[09:53] <jnthn> morning, #perl6

[09:53] <masak> love the colored notes!

[09:53] <masak> jnthn! \o/

[09:53] <masak> jnthn: what *day* is it today? :D

[09:53] <jnthn> NS day!

[09:53] <jnthn> er

[09:53] <masak> :P

[09:53] <jnthn> Thursday?

[09:53] <jnthn> Perl 6 day! \o/

[09:53] <masak> Perl 6 day! \o/

[09:55] <jnthn> The memory hierarchy section of courses.csail.mit.edu/6.851/spring12/ is certainly relevant to anyone working in VM/language implementation space, I suspect.

[09:55] * jnthn will have to at least check that one out.

[09:55] <jnthn> er, does is *not* but=

[09:57] <masak> oh :/

[09:58] <jnthn> does modifies the *object* in place. Assignment is all about scalar containers.

[09:59] *** thou left
[10:03] <masak> hm, yes.

[10:04] <masak> but if I do 'my $obj = MyClass.new; $obj but= MyRole', there's never more than one instance, is there?

[10:05] <moritz> but clones first

[10:06] <jnthn> masak: Yes, but in this case you immediately throw it away

[10:06] <jnthn> my $obj = MyClass.new; my $orig = $obj; $obj but= MyRole; 

[10:07] <jnthn> In the above $orig doesn't have the role, but still exists

[10:07] <jnthn> my $obj = MyClass.new; my $orig = $obj; $obj does MyRole; 

[10:07] <jnthn> Now $orig and $obj (which of course point to the same object) have the role

[10:07] <jnthn> Well, one object has the role but two containers point to it

[10:07] <jnthn> Grr, not enough coffee to explain stuff

[10:07] <masak> right. I see it now.

[10:08] <masak> while I appreciate the distinction, it might be that it's too confusing to have both behaviors. people seem to get 'does' and 'but' mixed up.

[10:09] <Su-Shee> good morning everyone.

[10:09] <jnthn> masak: I'd rather fix the naming that lose functionality

[10:09] <jnthn> *tyhan

[10:09] <jnthn> oh, screw it, I'm going to make some coffee

[10:09] <jnthn> o/ Su-Shee 

[10:10] <masak> Su-Shee! \o/

[10:11] *** scott__ left
[10:11] <tadzik> hello :)

[10:12] *** overrosy left
[10:14] <masak> tadzik! \o/

[10:15] *** overrosy joined
[10:22] *** kaleem left
[10:30] <moritz> bbkr1: good to hear that the fallback worked.

[10:35] *** [particle] joined
[10:39] *** Trashlord left
[10:40] *** Trashlord joined
[10:42] <jnthn> ok, now I'm more caffienated :)

[10:42] <jnthn> moritz: stdinit may be worth a spectest run. As far as I know, only two test files are busted, and it's becuase somehow my $x = [=>] 1,2,3; style things are

[10:43] <jnthn> (combo of [=>] reduction and assignment)

[10:48] <jnthn> moritz: Also your $*HAS_SELF stuff should work on top of this branch :)

[10:55] <moritz> jnthn: does it require a newer nqp?

[10:55] *** kfo left
[10:56] <jnthn> moritz: Requires the preclim patch I did yesterday, yeah

[10:56] <jnthn> moritz: oh, but I forgot to bump NQP_REVISION

[10:58] <moritz> ok

[11:03] *** mtk left
[11:14] *** birdwind1pbird left
[11:14] *** lestrrat left
[11:15] *** lestrrat joined
[11:18] *** lestrrat left
[11:19] *** lestrrat joined
[11:25] *** jaldhar left
[11:25] *** ab5tract joined
[11:30] *** ab5tract left
[11:31] *** ab5tract joined
[11:34] *** au left
[11:58] *** fasad joined
[11:59] <fasad> std: sqrt( 3++ );

[11:59] <p6eval> std 48335fc: OUTPUT«ok 00:01 108m␤»

[11:59] <fasad> rakudo: sqrt( 3++);

[11:59] <p6eval> rakudo 2251cb: OUTPUT«Cannot assign to a non-container␤␤»

[11:59] <fasad> :(

[11:59] <fasad> niecza: sqrt ( 3++ );

[11:59] <p6eval> niecza v14-28-gdf96012: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/N1CYVd6L9q line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3746 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3747 (module-CORE @ 65) ␤  at /home/p6eval/niecza/lib…

[12:00] <fasad> :(

[12:00] <fasad> pugs: sqrt( 3++ );

[12:00] <p6eval> pugs b927740: OUTPUT«*** Can't modify constant item: VInt 3␤    at /tmp/CC0SR6oAV0 line 1, column 7-11␤»

[12:00] <jnthn> fasad: There's this other operator that will work on literal values, "+1" :)

[12:00] <jnthn> perl6: say sqrt(3+1)

[12:01] <p6eval> pugs b927740, rakudo 2251cb, niecza v14-28-gdf96012: OUTPUT«2␤»

[12:01] <jnthn> ;)

[12:01] <fasad> what does the rakudo error mean ?

[12:01] <jnthn> fasad: What you can't assign to something if it's not a container

[12:01] <jnthn> *That

[12:01] <jnthn> ++ expects to get a variable

[12:02] <fasad> jnthn: yeah, but ++ is supposed to work (?)

[12:02] <jnthn> nom: my $a = 3; $a++; say $a

[12:02] <p6eval> nom 2251cb: OUTPUT«4␤»

[12:02] <jnthn> Works fine.

[12:03] <jnthn> You can't do 3++ because you'd be trying to modify the number 3

[12:03] <jnthn> Which is a constant/literal.

[12:03] <fasad> std says the sqrt( 3++ ) is correct syntax

[12:03] <fasad> *that

[12:03] <jnthn> Sure

[12:03] <jnthn> It's fine *syntax*.

[12:03] <jnthn> It's not semantically correct, though.

[12:04] <fasad> oh ! duh.

[12:04] <jnthn> std: class A { }; A.does_not_exist

[12:04] <p6eval> std 48335fc: OUTPUT«ok 00:01 107m␤»

[12:04] <fasad> !

[12:04] <jnthn> That's another example of fine syntax. But won't work if you run it :)

[12:05] *** bluescreen10 joined
[12:08] <fasad> perl (v5) is an interpreter;  perl6 (rakudo)  is... ?

[12:10] <fasad> i mean there is a virtual machine in between rakudo and the machine, so what does it make rakudo?

[12:10] <jnthn> A compiler.

[12:10] <jnthn> It compiles your program into code for the virtual machine.

[12:11] <moritz> fasad: both p5 and Rakudo (and basically all modern implementations of dynamic languages) are a hybrid between compiler and interpreter

[12:11] <moritz> fasad: the distinction blurs

[12:11] <moritz> fasad: though rakudo is maybe a bit more compiler-y. Hard to tell.

[12:12] <jnthn> Yeah. It's not such a useful distinction once you start asking interesting questions about what's really going on :)

[12:12] <fasad> hmm. Is gcc a "pure" compiler?

[12:12] <moritz> in particular, both p5 and p6 need the facility to execute code at compile time (more than just constant folding)

[12:13] <jnthn> The virtual machine itself may be doing either interpretation or (JIT/AOT) compilation.

[12:13] <moritz> fasad: much more so than rakudo and parrot

[12:13] <moritz> fasad: but it also provides some runtime library stuff, so it's not 100% "pure" compiler

[12:13] <fasad> jnthn: AOT ?

[12:14] <moritz> ahead of time compilation

[12:14] <masak> perl6: say exp(pi * sqrt 163) - 640320 ** 3

[12:14] <p6eval> rakudo 2251cb: OUTPUT«-12032460128␤»

[12:14] <p6eval> ..pugs b927740, niecza v14-28-gdf96012: OUTPUT«256␤»

[12:14] <masak> neither of those results correspond to http://en.wikipedia.org/wiki/Complex_multiplication#Sample_consequence

[12:15] <moritz> nom: say exp(pi * sqrt 163)

[12:15] <p6eval> nom 2251cb: OUTPUT«2.62537400608308e+17␤»

[12:16] <masak> loss of precision, most likely.

[12:16] <moritz> perl6: 640320 ** 3

[12:16] <p6eval> pugs b927740, rakudo 2251cb, niecza v14-28-gdf96012:  ( no output )

[12:16] <moritz> perl6: say 640320 ** 3

[12:16] <p6eval> pugs b927740, rakudo 2251cb, niecza v14-28-gdf96012: OUTPUT«262537412640768000␤»

[12:16] <moritz> masak: but it's worrysome that the numbers diverge so much

[12:16] <moritz> nom: say 262537412640768000.Num

[12:16] <p6eval> nom 2251cb: OUTPUT«2.62537412640768e+17␤»

[12:16] <masak> niecza: say exp(pi * sqrt 163)

[12:16] <p6eval> niecza v14-28-gdf96012: OUTPUT«2.6253741264076826E+17␤»

[12:17] <masak> Niecza carries a few more significant digits, is all.

[12:17] <masak> so it fares better.

[12:17] <dalek> nqp/bs: ffeec9c | jnthn++ | src/6model/serialization.c:

[12:17] <dalek> nqp/bs: Set SC on objects as we deserialize them.

[12:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/ffeec9c21a

[12:17] <dalek> nqp/bs: 7275a66 | jnthn++ | src/6model/serialization.c:

[12:17] <dalek> nqp/bs: Serialize/deserialize v-table and method cache from STable.

[12:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7275a66b2b

[12:17] <dalek> nqp/bs: 2ea450f | jnthn++ | src/6model/serialization.c:

[12:17] <dalek> nqp/bs: Introduce concept of a cloned code reference; this will be used when implementing closure serialization.

[12:17] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2ea450f2ac

[12:18] <masak> still, 256 isn't so close to the expected 744, either...

[12:19] <moritz> jnthn: I can confirm your results from spectesting stdinit

[12:19] <jnthn> moritz: OK. So just the reduction operator thingy to fathom.

[12:21] <moritz> jnthn: right, and bumping NQP_REVISION

[12:21] <jnthn> moritz: Feel free to pull your $*HAS_SELF patch into that branch too, or some other way to try them in combination.

[12:21] <jnthn> moritz: I'm pretty sure the "has $!x = $!y" issues are now fixed.

[12:21] <moritz> jnthn: I'll try it

[12:21] <colomon> niecza: say "a" ∈ <a b c d e>

[12:22] <p6eval> niecza v14-28-gdf96012: OUTPUT«Unhandled exception: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.␤  at System.Collections.Generic.Dictionary`2[System.String,Niecza.P6any].get_Item (System.String key) [0x00000] in <filename unknown>:0 ␤…

[12:22] <colomon> !

[12:22] <jnthn> If Pm shows up today, maybe he'll have some hints on the reduction issue.

[12:22] <jnthn> (or feel free to poke if you've got any ideas)

[12:22] <jnthn> I can't quite figure out how STD gets it right.

[12:23] <colomon> p6eval: rebuild niecza

[12:24] <dalek> rakudo/nom: 828e4d6 | moritz++ | src/core/Exception.pm:

[12:24] <dalek> rakudo/nom: allow numification of X::AdHoc

[12:24] <dalek> rakudo/nom: 

[12:24] <dalek> rakudo/nom: This is a bit questionable, but a spectest requires it

[12:24] <dalek> rakudo/nom: In the end we might want to make X::Adhoc a wrapper

[12:24] <dalek> rakudo/nom: around a payload, and only use the stringification

[12:24] <dalek> rakudo/nom: for HLL interop.

[12:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/828e4d6c4d

[12:24] <moritz> evalbot rebuild niecza

[12:24] <p6eval> OK (started asynchronously)

[12:24] <dalek> Rebuild of niecza complete.

[12:24] <moritz> jnthn: it's a parse issue?

[12:25] <moritz> the error comes from REDUCE_METAOP_RIGHT where it tries to invoke infix:<=>> with one argument

[12:26] <jnthn> moritz: Yes, precednece issue in parsing

[12:26] <jnthn> my $x = [+] 1,2,3; say $x

[12:26] <jnthn> That also shows it much more simply.

[12:27] <jnthn> It stops parsing at the , for some, because of the precedence limit.

[12:27] <jnthn> s/for some,//

[12:30] <masak> because the = imposes scalar assignment?

[12:30] <moritz> the precedence limit from infix:<=> ?

[12:32] <masak> inneresting -- that's correct from the viewpoint of the infix:<=>, but the [+] creates a new parsing context "one level down", so to speak, which should lift that constraint.

[12:32] <jnthn> moritz: Correct

[12:32] <jnthn> masak: Yes, and I fail to see where STD does that.

[12:33] <masak> std: my $x = [+] 1, 2, 3;

[12:33] <p6eval> std 48335fc: OUTPUT«ok 00:01 112m␤»

[12:33] *** pernatiy left
[12:33] <masak> clearly it does that, though.

[12:33] <moritz> well no

[12:33] <moritz> it wouldn't syntax-error 

[12:33] <jnthn> right

[12:34] <moritz> (my $x = [+] 1), 2, 3 is also valid p6

[12:34] <jnthn> std: (my $x = [+] 1), 2, 3

[12:34] <p6eval> std 48335fc: OUTPUT«ok 00:01 113m␤»

[12:34] <jnthn> yeah, and the 2 and 3 ain't warned about

[12:34] <masak> huh.

[12:34] <masak> indeed.

[12:34] <jnthn> Well

[12:34] <jnthn> I'm only guessing STD gets it right because Niecza does

[12:35] <jnthn> It's possible Niecza has got something STD hasn't got here.

[12:35] <masak> check how Niecza does it :)

[12:35] * jnthn wonders if :sub<e=> in %list_prefix would fix it

[12:35] *** am0c joined
[12:35] <jnthn> or in reduce at least

[12:36] *** am0c left
[12:39] <jnthn> alas, no

[12:39] <moritz> do prefixes generally reset the prec limit?

[12:40] <jnthn> Don't believe so

[12:41] * masak just had an insight: unary prefixes are very loose on the term level, and list prefixes are very loose on the expression level

[12:53] *** tarch left
[12:58] *** au joined
[13:02] <cognominal___> I was discussing with rgs and elbeho on #perlfr about Mathematica. I note something which is interesting for people fearing typing weird symbol. Expressions have a fullform and a short form.  In the full form, everything is expressed like C functions except as bracket instead of parentheses.

[13:02] <cognominal___> The programmer types  code in a form that is a mix of full and short form.

[13:03] <cognominal___> Example of short from : a*b + c 

[13:04] <cognominal___> Coreesponding full form:  Plus[Times[a,b],c]

[13:06] <cognominal___> Operators  which are unicode can be typed in full form to avoid unicode but will eventually appear in short form

[13:06] <cognominal___> http://reference.wolfram.com/mathematica/tutorial/TheSyntaxOfTheMathematicaLanguage.html

[13:12] <flussence> I guess in vim you could write a bunch of ":imap <Leader>intersect ∩" lines too

[13:12] <masak> not a bad idea.

[13:13] <masak> and then have the same shortcuts in irssi... :)

[13:13] <flussence> though with that you have to type the entire thing in one go without a single typo or it aborts, so maybe not for everyone :)

[13:13] <masak> oh.

[13:14] <masak> maybe something more like \cap in TeX?

[13:14] <cognominal___> You don't have to type: a*b+c in longform though

[13:16] <cognominal___> Before knowing about compiler internals, I probably got from Mathematica the idea that program are really  not lines but trees. 

[13:17] <moritz> +1 to exposing all set operations as (ASCII-named) methods (or subs)

[13:18] <cognominal___> Chomsky would talk about surface syntax, but I am not sure TimToady likes Chomsky too much.

[13:18] <cognominal___> moritz: that could be a trait.

[13:19] <masak> I never fully bought into the concept of surface syntax. it seems to have contradictory meanings in the literature.

[13:19] <moritz> cognominal___: a trait? how so?

[13:21] <cognominal___> …specifying how to go form the long form to the short one. how so, not to sure yet.

[13:22] <flussence> macros :)

[13:22] <cognominal___> In mathematica that's a tree pattern matching transformation.

[13:23] <flussence> (and I think maybe it should be the other way around, latin-1 should be the canonical form and unicode should be the sugar on top)

[13:24] <cognominal___> With signatures, we do pattern matching already except they are expressed in a weird "short form".

[13:25] *** skids left
[13:25] <moritz> Mathematica is very Lisp-y under the hood

[13:25] <cognominal___> Well perl has always been about short forms except TimToady calls that huffman coding.

[13:26] <cognominal___> I think Mathematica as a cross of Lisp and Prolog.

[13:26] <moritz> ProLisp :-)

[13:27] <cognominal___> Should go Back in 2 or 3 hours

[13:27] <masak> there's two sides to Huffman coding. sometimes things get longer names because of it, too.

[13:29] *** ab5tract left
[13:31] <arnsholt> masak: As (more or less) a linguist, I don't really buy the Chomskian deep/surface distinction either =)

[13:31] <arnsholt> If it's any consolation

[13:32] <masak> it is. it mostly serves to confuse me.

[13:32] <masak> as a computer scientist, I don't see it having rigour enough.

[13:32] <dalek> rakudo/stdinit: 7b6cf5d | moritz++ | src/ (3 files):

[13:32] <dalek> rakudo/stdinit: Merge remote branch 'origin/has-self' into stdinit

[13:32] <dalek> rakudo/stdinit: review: https://github.com/rakudo/rakudo/commit/7b6cf5da5a

[13:32] <dalek> rakudo/stdinit: 48c50ff | moritz++ | tools/build/NQP_REVISION:

[13:32] <dalek> rakudo/stdinit: bump NQP revision to get preclim fix

[13:32] <dalek> rakudo/stdinit: review: https://github.com/rakudo/rakudo/commit/48c50ff5d3

[13:32] <arnsholt> Yeah, that's my main beef with Chomskian linguistics in general

[13:33] <jnthn> moritz: has $!y = $!x # works in stdinit?

[13:33] <arnsholt> They make a great issue of economy and some vague notion of "possible to compute", but Chomskian linguistics are pretty much completely absent from NLP/compling

[13:34] <arnsholt> Transformational syntax is just too hairy to implement as a computer program

[13:34] <arnsholt> (Only counter-example I can think of is something called tree-adjoining grammar, but that's pretty old)

[13:35] <moritz> jnthn: I haven't tested it specifically, but the merge only added passing TODOs to the spectest run, so I guess "yes"

[13:35] *** pernatiy joined
[13:36] <jnthn> moritz: yay

[13:36] <jnthn> So, just need to fathom this reduce thingy and then it can be merged.

[13:36] <jnthn> Am working on the serialization bits at the moment, though.

[13:36] <arnsholt> And speaking of unicode operators and vim, it should be possible to set up imaps so that the texas operators are magically transformed into unicode ops

[13:37] *** benabik left
[13:39] <moritz> jnthn: yes, works

[13:41] <jnthn> \o/

[13:49] <masak> arnsholt: that might go wrong, though. think of %h<bar>».foo -- I wouldn't want vim to turn that into %h<bar»>.foo

[13:49] <arnsholt> Oooh, good point

[13:50] <moritz> jnthn: yes, works

[13:51] <jnthn> moritz: The same thing you told me works 11 minutes ago? ;)

[13:51] <moritz> jnthn: now Ronja told you :-)

[13:51] <jnthn> :D

[13:52] <masak> she's getting much better at typing words.

[13:52] *** ajox joined
[13:56] <moritz> amazing, isn't it? she must have learned a lot from me :-)

[13:58] *** [Coke] joined
[14:00] *** mtk joined
[14:03] *** ab5tract joined
[14:23] <dalek> niecza: 6a63017 | (Solomon Foster)++ | lib/CORE.setting:

[14:23] <dalek> niecza: Restore the immutability of Set and Bag.

[14:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6a63017342

[14:23] *** chra left
[14:24] *** chra joined
[14:26] <masak> colomon: an interesting case of how easy it is to accidentally break encapsulation by handing out references through accessor methods.

[14:27] *** tarch joined
[14:27] *** birdwind1pbird joined
[14:27] <colomon> masak: yup

[14:30] *** etneg_ joined
[14:30] *** Vlavv` left
[14:30] *** Gothmog_ left
[14:30] *** etneg left
[14:30] *** Gothmog_ joined
[14:30] *** Vlavv` joined
[14:31] <dalek> roast: 8f304c2 | (Solomon Foster)++ | S02-types/key (2 files):

[14:31] <dalek> roast: Unfudge tests that work after sorear++'s changes last night.

[14:31] <dalek> roast: review: https://github.com/perl6/roast/commit/8f304c2b37

[14:36] *** birdwindupbird left
[14:44] *** skids joined
[14:49] <skids> which git branch to use for most functional REPR stuff, e.g. CStruct?

[14:50] <masak> nom, I think.

[14:50] <jnthn> Right.

[14:55] <jnthn> Note the implementation of CStruct actually lives in the NQP repo

[14:56] <skids> Will nom fetch the newest with --build-nqp?

[14:56] <skids> erm, --gen-nqp?

[14:57] *** PacoAir joined
[14:57] <jnthn> skids: It'll fetch recent enough (more)

[14:58] <jnthn> There hasn't been any additions to CStruct et al in the last couple of weeks

[14:58] *** unobe left
[14:59] <skids> Thanks, jnthn++

[14:59] *** birdwind1pbird left
[14:59] *** unobe joined
[15:10] *** tty234 joined
[15:23] *** kaleem joined
[15:26] *** GlitchMr joined
[15:29] <moritz> but if you want to patch stuff, you should 'git checkout master; git pull' in nqp before you start

[15:30] *** kaleem left
[15:30] <[Coke]> # 02/09/2012 - niecza at 99.64%

[15:30] <[Coke]> "niecza",     19553,   150,   732,  1582, 22017, 22863

[15:30] <[Coke]> "rakudo",     19623,    32,   616,  1977, 22248, 22873

[15:31] <[Coke]> sorear, colomon: note that niecza has 150 failures atm.

[15:31] <moritz> [Coke]++ # test statistics, feeding the friendly competition

[15:32] <masak> nom: sub postfix:<%>($n) { $n / 100 }; say "Rakudo at {(1/99.64% * 100).fmt("%6.2f")}%"

[15:32] <p6eval> nom 828e4d: OUTPUT«Rakudo at 100.36%␤»

[15:33] <moritz> masak: could I add you as possible mentor for the custom sprintf implementation in http://wiki.enlightenedperl.org/gsoc2012/ideas ?

[15:33] <masak> yes.

[15:35] <[Coke]> the detailed reports are at http://feather.perl6.nl/~coke/ *.out

[15:35] <jnthn> hmm, I need to review that multi dispatch one

[15:35] <jnthn> I did a bunch of the work there already

[15:37] <moritz> jnthn: btw rakudo commit 33fb020a12b6eccc2b1e0118d9c1a362ecd27d39 contains a commented-out multi method that causes circularity

[15:38] <moritz> I wonder if that's legit

[15:39] <jnthn> Unlikely

[15:39] <jnthn> (unlikely to be legi)

[15:39] <jnthn> *legit

[15:39] <PerlJam> There's only 3 gsoc ideas for Rakudo?

[15:40] <[Coke]> rakudo is haaaaaaard.

[15:42] <PerlJam> given the number of Perl projects under the TPF moniker, it seems unlikely that Perl 6 will get much love.

[15:42] *** kaleem joined
[15:43] <moritz> PerlJam: so far we've always got enough slots for Perl 6 projects, once we had interested and good students

[15:44] *** Psyche^ joined
[15:44] <PerlJam> well, that's really the trick anyway, isn't it?  Finding good students.

[15:45] <dalek> nqp/bs: b06857a | jnthn++ | src/6model/reprs/P6opaque.c:

[15:45] <dalek> nqp/bs: P6opaque should ensure its REPR data is calculated before any serialization of it takes place.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b06857a06c

[15:45] <dalek> nqp/bs: f6f2e8a | jnthn++ | t/serialization/03-closures.t:

[15:45] <dalek> nqp/bs: Add initial test for handling of cloned code refs (not testing outer handling yet, though - just very simple case of cloning).

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f6f2e8a09a

[15:45] <dalek> nqp/bs: f31afe1 | jnthn++ | src/6model/serialization. (2 files):

[15:45] <dalek> nqp/bs: Initial changes to add a closures table.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f31afe1b6a

[15:45] <dalek> nqp/bs: 317ff89 | jnthn++ | src/6model/serialization. (2 files):

[15:45] <dalek> nqp/bs: Start sketching out cloned code ref serializtion, in prep for really doing closure support.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/317ff89cfe

[15:45] <dalek> nqp/bs: b81e767 | jnthn++ | src/6model/serialization.c:

[15:45] <dalek> nqp/bs: Add initial code for deserializing a row from the closures table; this will eventually grow to be the full closure deserialization, but doing something much simpler for now.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b81e7671e0

[15:45] <dalek> nqp/bs: be303bd | jnthn++ | t/serialization/03-closures.t:

[15:45] <dalek> nqp/bs: Update test case to actually really use the static code object.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/be303bd653

[15:45] <dalek> nqp/bs: bf9b58e | jnthn++ | src/pmc/nqplexinfo.pmc:

[15:45] <dalek> nqp/bs: Get NQPLexInfo to remember the Sub it is attached to.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/bf9b58e23e

[15:45] <dalek> nqp/bs: 664e87c | jnthn++ | src/6model/serialization.c:

[15:45] <dalek> nqp/bs: Locate static code ref that a closure is based on, plus a few other fixes. First tests for cloned code objects now pass; this is the first pre-requisite for closure serialization done.

[15:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/664e87c369

[15:45] * PerlJam starts crafting an appropriate email to the local CS club about the GSoC

[15:46] * [Coke] should really do better outreach to the local schools. (RPI is one of the locals, I should really be able to find someone there. ;)

[15:47] *** Patterner left
[15:47] *** Psyche^ is now known as Patterner

[15:50] <[Coke]> what does the bs in nqp/bs stand for?

[15:50] <tadzik> Boom! Serialization!

[15:50] <PerlJam> "I can't be bothered to come up with a real name" :)

[15:51] <tadzik> Multiple Dispatch Optimization in Rakudo -- isn't this already done by jnthn++?

[15:51] *** kaare_ joined
[15:51] <flussence> I guess the b is binary

[15:51] <tadzik> bounded

[15:51] <flussence> .oO( as opposed to xml serialisation... ew. )

[15:57] *** kaleem left
[16:02] *** benabik joined
[16:04] <jnthn> bounded serialization :)

[16:04] *** yertalert joined
[16:07] <masak> tadzik: yes, but the project suggestions are from last year.

[16:07] <tadzik> yeah, I think so

[16:07] <tadzik> well, sprintf is new

[16:07] <masak> tadzik: it's likely that it can be updated to do even cooler optimizations.

[16:07] * tadzik sniffs for a nice task for this year

[16:08] <jnthn> Yeah, I'm pondering the best way to update that task :)

[16:14] <colomon> [Coke]: I already sent a list of failing test files to sorear++ via e-mail.  :)

[16:18] *** wtw left
[16:20] <TimToady> Ooh, set ops, shiny!  Used to be I couldn't spell mathmatishun, and now ir1.

[16:25] *** mj41 left
[16:32] *** Trashlord left
[16:36] <masak> niecza: say "a" ∈ <a b c d>

[16:36] <p6eval> niecza v14-29-g6a63017: OUTPUT«Unhandled exception: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.␤  at System.Collections.Generic.Dictionary`2[System.String,Niecza.P6any].get_Item (System.String key) [0x00000] in <filename unknown>:0 ␤…

[16:36] <masak> something the matter there, though.

[16:37] *** Trashlord joined
[16:37] *** benabik left
[16:43] *** fasad left
[16:46] *** kaleem joined
[16:47] <TimToady> maybe we need a sqrt(Rat, :precision) that returns a Rat

[16:48] <TimToady> .oO(square rats)

[16:49] <TimToady> or some variant of ** that returns a Rat

[16:52] <masak> could anon slurpy arrays *@ be made lazy?

[16:52] <sorear> good * #perl6

[16:52] <TimToady> o/

[16:53] <masak> sorear! \o/

[16:53] <sorear> TimToady: sqrt(2).Rat(1e-9) isn't enough?

[16:53] <TimToady> http://irclog.perlgeek.de/perl6/2012-02-09#i_5123826

[16:54] <TimToady> masak: maybe it's too early, or too late, but I can't picture what you're asking

[16:54] <jnthn> masak: Lazy as in, just throw away the rest of the values?

[16:54] <jnthn> masak: Rather than actually make an array?

[16:54] <jnthn> Though Rakudo may do that already...

[16:54] <masak> jnthn: right.

[16:55] <masak> so you can pass lazy, potentially infinite lists to the sub.

[16:55] <jnthn> masak: But you should already be able to do that for the named ones...

[16:55] <masak> I was looking at the first example of http://en.wikipedia.org/wiki/Corecursion#Discussion

[16:55] <masak> and thinking how to port it to Perl 6.

[16:55] <masak> nom: sub fibgen { $^x, fibgen $^y, $x + $y }; .say for fibgen 0, 1

[16:55] <p6eval> nom 828e4d: OUTPUT«maximum recursion depth exceeded␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibgen at /tmp/UI8CzVd3TC:1␤  in sub fibg…

[16:56] <sorear> masak: (backlog) I'd be +1 to dehuffmanizing does, perhaps to .APPLY_ROLE_IN_PLACE (lc?) or something like that

[16:56] <masak> sorear: sounds good.

[16:56] <sorear> making it a (meta?) method would hint at the fact that it mutates the object

[16:56] <masak> sorear: meta sounds about right for it.

[16:56] <jnthn> Doesn't need to be uppercase. It's not *that* scary.

[16:57] <masak> .^distort

[16:57] <TimToady> I was completely unsuccessful in getting hamming recursion to work last night on either niecza or nom

[16:57] <TimToady> .oO(use MONKEY_DOES)

[16:57] <jnthn> masak: huh

[16:57] <jnthn> .^mixin

[16:57] <jnthn> Call it what it does!

[16:57] <masak> ooh

[16:57] <jnthn> We don't need to make new words for everything :)

[16:57] <PerlJam> jnthn: +1

[16:57] <masak> I didn't think of that you can verb 'mixin'.

[16:58] <jnthn> Surely it's a nonification of "to mix in" ;)

[16:58] *** thou joined
[16:58] <jnthn> nom: class A { }; role R { method foo() { 42 } }; my $a = A.new(); $a.^mixin(R); say $a.foo

[16:58] <p6eval> nom 828e4d: OUTPUT«42␤»

[16:58] <jnthn> It even works already. :)

[16:59] <sorear> masak: "interesting case" - red herring.  Niecza still treats all methods as 'is rw', which is the problem here

[16:59] *** fsergot joined
[16:59] <fsergot> o/

[17:00] <masak> sorear: oh! I considered whether that might be part of it.

[17:00] <sorear> o/

[17:01] <TimToady> perl6: constant @foo = 1, @foo; say @foo[3]

[17:01] <p6eval> pugs b927740: OUTPUT«pugs: *** Undeclared variable: ("@foo",MkPad (padToList []),[PCompiling {pc_pad = MkMPad {mp_id = 140635094937585, mp_pad = <ref:0x7fe828ae7d99>}}])␤    at /tmp/HXoh5Rds_j line 1, column 20-24␤»

[17:01] <p6eval> ..rakudo 828e4d: OUTPUT«===SORRY!===␤Variable @foo is not declared␤at /tmp/RRmhwfflvi:1␤»

[17:01] <p6eval> ..niecza v14-29-g6a63017: OUTPUT«Any()␤»

[17:01] <masak> still, we've established that the *general* problem of DTRT with encapsulation of private data structures is unsolvable, or at least never solved satisfactorily in a language with assignment.

[17:01] <TimToady> perl6: my @foo; @foo.push: 1, @foo; say @foo[3]

[17:01] <p6eval> rakudo 828e4d, niecza v14-29-g6a63017: OUTPUT«Any()␤»

[17:01] <p6eval> ..pugs b927740: OUTPUT«␤»

[17:01] * masak decommutes

[17:03] <jnthn> TimToady: iirc, we'd discussed ".plan" instead of ".push" to make cases like that work.

[17:03] <jnthn> er, if I understand what you were after :)

[17:03] <TimToady> er, right

[17:03] <TimToady> perl6: my @foo; @foo.plan: 1, @foo; say @foo[3]

[17:03] <p6eval> rakudo 828e4d: OUTPUT«Method 'plan' not found for invocant of class 'Array'␤␤»

[17:03] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Array: "&plan"␤    at /tmp/8X_UxfXLnX line 1, column 10-28␤»

[17:03] <p6eval> ..niecza v14-29-g6a63017: OUTPUT«Any()␤»

[17:04] <jnthn> Hm. Seems we didn't implement .plan in Rakudo, though...

[17:04] <TimToady> still don't work though

[17:04] *** ajox left
[17:05] <PerlJam>  .plan ??

[17:05] <daxim> http://perlmonks.org/index.pl?node_id=952765

[17:09] *** kaleem left
[17:10] *** benabik joined
[17:12] *** MayDaniel joined
[17:12] * [Coke] hopes kikuchiyo filed a bug report!

[17:12] * jnthn sighs about Rakudo's list handling

[17:13] <flussence> nom: my $s; for 1..10 {$s+=1/$_**2}; say $s

[17:13] <p6eval> nom 828e4d: OUTPUT«1.54976773116654␤»

[17:15] <flussence> nom: my $s; for 1..10 {$s+=1/$_**2}; say $s.WHAT

[17:15] <p6eval> nom 828e4d: OUTPUT«Rat()␤»

[17:16] <flussence> nom: my $s; for 1..358 {$s+=1/$_**2}; say $s.denominator

[17:16] <p6eval> nom 828e4d: OUTPUT«1449787577947121375205308609556609711535433536157696434138530380517766506486305567414633608794650140470225443769804050741336943542145049679650936206123191521214587589518173757956538010055687965209269408060586721810178407168365269586498897970105441515066452356030319783…

[17:16] <flussence> nom: my $s; for 1..358 {$s+=1/$_**2}; say $s.denominator.chars

[17:16] <p6eval> nom 828e4d: OUTPUT«304␤»

[17:17] <flussence> 304 looks familiar... decimal exponent for the largest 32-bit float, I think

[17:17] <TimToady> it works find it Num arithmetic, if you cange the 1/ to 1e0/

[17:17] <TimToady> *change

[17:18] <flussence> nom: my $s; for 1..359 {$s+=1e0/$_**2}; say $s.denominator.chars

[17:18] <p6eval> nom 828e4d: OUTPUT«Method 'denominator' not found for invocant of class 'Num'␤␤»

[17:18] <flussence> wha

[17:18] <TimToady> Nums don't have denominators

[17:19] <TimToady> perl6: my $s; for 1..1000 {$s += 1e0/$_**2};say $s

[17:19] <p6eval> niecza v14-29-g6a63017: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1221 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 255 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/BEs41VM9GV line 0 (mainli…

[17:19] <p6eval> ..pugs b927740: OUTPUT«1.6439345666815598031390580238222155896521␤»

[17:19] <p6eval> ..rakudo 828e4d: OUTPUT«1.64393456668156␤»

[17:20] <TimToady> niecza gets the correct answer, but you can't see it for the noise

[17:20] <PerlJam> pugs++ too

[17:21] <TimToady> perl6: my $s = 0; for 1..10000 {$s += 1e0/$_**2};say $s

[17:21] *** jaldhar joined
[17:21] <p6eval> rakudo 828e4d: OUTPUT«1.64483407184807␤»

[17:21] <p6eval> ..pugs b927740: OUTPUT«1.644834071848059769806081833310310903538␤»

[17:21] <p6eval> ..niecza v14-29-g6a63017: OUTPUT«1.6448340718480652␤»

[17:21] <dalek> niecza: 7cb1d49 | sorear++ | lib/CORE.setting:

[17:21] <dalek> niecza: Fix (elem) private method issue

[17:21] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7cb1d49f90

[17:21] * sorear out

[17:26] <TimToady> nom: my $s; for 1..358 {$s+=1/$_**2}; say $s.WHAT

[17:26] <p6eval> nom 828e4d: OUTPUT«Rat()␤»

[17:26] <moritz> daxim: thanks for the link, I've written a reply

[17:26] <TimToady> is it really a FatRat in disguise?

[17:27] <moritz> yes

[17:27] <moritz> in rakudo, each Rat is a FatRat :/

[17:28] <jnthn> moritz: Is there a (huge amount) more to a first crack at fixing that beyond "has Int $.numerator; has int $.denominator;" ?

[17:29] <moritz> jnthn: well, handling overflow

[17:30] <jnthn> ah, yes.

[17:30] * jnthn just checked the relevant part of S02 and is happy to see we don't auto-promote to FatRat :)

[17:31] *** Tedd1 left
[17:31] <daxim> "rancorousness", hah

[17:32] <TimToady> and it's supposed to be Rat[Int,Uint64], actually

[17:33] *** snearch joined
[17:33] <TimToady> I don't know where moritz++ got 2**128 from...

[17:33] <TimToady> but I like the way he replied better than the way I didn't :)

[17:34] *** Tedd1 joined
[17:35] <jnthn> oh...the O(N**2) is not due to the iteration. *phew*

[17:36] <[Coke]> moritz++

[17:37] <moritz> TimToady: memory gone wrong

[17:41] <moritz> niecza: say ( 1 / 2**65).WHAT

[17:41] <p6eval> niecza v14-29-g6a63017: OUTPUT«Num()␤»

[17:41] <moritz> jnthn: maybe if we make infix:</> sufficiently magic...

[17:42] <moritz> and build the rest of the Rat arithmetic based on that instead of Rat.new

[17:53] <dalek> roast: 355851a | (Solomon Foster)++ | S02-types/keybag.t:

[17:53] <dalek> roast: Make the multiple-element access tests stronger.

[17:53] <dalek> roast: review: https://github.com/perl6/roast/commit/355851ade1

[17:56] *** MayDaniel left
[17:56] <moritz> niecza: my $f = FatRat.new(1, 1); my $r = 1.0; say ($f * $r).WHAT; say ($r * $f).WHAT

[17:56] <p6eval> niecza v14-29-g6a63017: OUTPUT«FatRat()␤FatRat()␤»

[17:56] <flussence> perl6: say (1..'potato')[^10]; # http://www.reddit.com/r/programming/comments/phync/ruby_cant_count_to_potato/

[17:57] <moritz> so FatRat is contagious?

[17:57] <p6eval> rakudo 828e4d: OUTPUT«(timeout)»

[17:57] <p6eval> ..niecza v14-29-g6a63017: OUTPUT«Unhandled exception: Cannot parse number: potato␤  at /home/p6eval/niecza/lib/CORE.setting line 1359 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3318 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3320 (NumSyntax.str2num @ 4) ␤  …

[17:57] <p6eval> ..pugs b927740: OUTPUT«␤»

[17:57] <TimToady> "The best approach to Perl 6 is to ignore it." --educated_foo

[17:57] <TimToady> .oO(if only he would...)

[17:58] <jnthn> No, no. "troll about" is a synonym of "ignore" these days :P

[17:58] *** pernatiy left
[17:59] <TimToady> yes, FatRat is contagious, which is why we try never to make one implicitly

[17:59] *** fasad joined
[18:02] *** retup-work joined
[18:03] *** Teratogen left
[18:09] *** dakkar left
[18:20] <moritz> jnthn: is there a way to write a sub or block in the setting which is inlined?

[18:22] <jnthn> moritz: What do you mean by "inlined"? In the optimization sense?

[18:22] <moritz> jnthn: yes

[18:23] <jnthn> moritz: The optimizer already takes care of some basic cases of that, but we're a bit limited in what we can do until we can serialize ASTs properly.

[18:23] <jnthn> moritz: It already will inline things it knows how to when compiling CORE.setting, though.

[18:24] <moritz> that's... vague

[18:26] <jnthn> moritz: For something more concrete, see add_inlining_info_if_possible in Actions.pm, and inline_call in Optimizer.pm.

[18:27] *** tarch_ joined
[18:28] <moritz> only single statements. That won't do for my purpose :(

[18:29] *** tarch left
[18:29] <jnthn> moritz: Yeah, it's very limited right now.

[18:30] <jnthn> moritz: I can extend it a bit, I suspect. But given it's mostly going to get a lot easier to do when we have serialization (which I'm working on now) and AST being 6model objects (which is up afterwards) I don't want to write too much to throw away.

[18:32] <moritz> jnthn: 's ok

[18:32] <jnthn> moritz: What's the use case, ooc?

[18:33] *** fasad left
[18:33] <moritz> jnthn: I thought about a sub that takes two Rational-ish types, a numerator and a denominator, and automagically makes a FatRat, Rat or Num

[18:34] <jnthn> moritz: Do you expect a serious performance regression if you do it that way and we don't have inlining of it just yet?

[18:34] <moritz> jnthn: well, one additional call per arithmetic operation

[18:35] *** preflex_ joined
[18:35] *** preflex left
[18:36] *** preflex_ is now known as preflex

[18:37] <jnthn> moritz: We can probably stomach that for the time being, in return for corrector semantics.

[18:40] *** tarch__ joined
[18:44] *** tarch_ left
[18:45] <dalek> nqp/bs: e4f5e80 | jnthn++ | t/serialization/03-closures.t:

[18:45] <dalek> nqp/bs: Add a failing test for closure serialization.

[18:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/e4f5e80c0e

[18:45] <dalek> nqp/bs: 40269bf | jnthn++ | src/6model/serialization.c:

[18:45] <dalek> nqp/bs: Add a column to the closures table for the outer context.

[18:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/40269bf764

[18:45] <dalek> nqp/bs: 9bdbaa1 | jnthn++ | src/6model/serialization. (2 files):

[18:45] <dalek> nqp/bs: Update serialize/deserialize code to set up for contexts table and data segment.

[18:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/9bdbaa175b

[18:45] <dalek> nqp/bs: 5ee3a41 | jnthn++ | t/serialization/03-closures.t:

[18:45] <dalek> nqp/bs: Correct test count.

[18:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5ee3a41791

[18:45] <jnthn> Time for dinner break.

[18:48] <colomon> moritz: what would be the purpose of such a sub?  shouldn't it just be Rat or Num?

[18:48] <colomon> or I guess my question is, what are the circumstances in which you'd want to choose between those three choices, given two Ints?

[18:49] <moritz> colomon: I consider how to write all the numeric ops

[18:49] <moritz> my idea ist

[18:50] <moritz> multi sub infix:<+>(Rational $a, Rational $b) {

[18:50] <moritz> my Int $nu = ...;

[18:50] <moritz> my Int $de = ... ;

[18:50] <moritz> MAKE_NUMBER($nu, $de, $a.WHAT, $b.WHAT)

[18:50] <moritz> }

[18:50] <colomon> ah

[18:50] <moritz> and depending on the actual types of $a and $b, that can return Rat, FatRat or Num

[18:53] <colomon> though if you're going as far as Rational, there are a lot more choices than Rat and Num, right?

[18:53] <moritz> yes

[18:53] <moritz> which means that we just need to make MAKE_NUMBER more general in the long run

[18:55] *** PZt left
[18:55] <colomon> bonus points if you make the conversion to Num smarter than just $nu.Num  / $de.Num....

[18:56] <moritz> assuming that $nu and $de are already shortened, is there a smarter way?

[18:56] *** PZt joined
[18:57] <moritz> (or how do you call that? cancled out? /me bad at math English)

[18:57] <moritz> ah, cancled down probably

[18:58] *** MayDaniel joined
[19:02] <eviltwin_b> mormalized?

[19:02] <eviltwin_b> er

[19:02] <eviltwin_b> normalized

[19:06] *** birdwindupbird joined
[19:13] *** cogno joined
[19:15] *** zby_home_ joined
[19:18] <colomon> moritz: sorry I got distracted.  The case I'm worrying about is that $nu.Num or $de.Num maybe be Inf, but the ratio of the two parts would make a perfectly good Num.

[19:20] <moritz> colomon: oh right. Then it might make sense to divide them both by an appropriately large integer first

[19:21] <colomon> really, this seems like the sort of thing the bigint library ought to already be smart enough to do.  :)

[19:21] <colomon> but yeah, dividing by an appropriately large integer would probably be an okay approach

[19:26] *** cogno left
[19:27] *** pernatiy joined
[19:32] <moritz> colomon: can you think of a different appraoch than dividing by a large int?

[19:36] <colomon> I was thinking more like $nu div $de, and only looking at ($nu % $de) / $de if needed

[19:37] <colomon> but you're likely to end up dividing the last expression by a large int if $de.Num == Inf, it's true...

[19:37] <moritz> that sounds a bit cleverer, actually :-)

[19:37] *** bluescreen10 left
[19:39] <PerlJam> I don't know what else the Swedes have contributed to the world, but right now I'm very thankful for swedish meatballs.

[19:39] <colomon> swedish meatballs++

[19:40] <tadzik> is that called 'shotbullars' or something like this?

[19:40] <moritz> tadzik: that's how it's pronounced, but it's spelled differently, iirc

[19:40] <moritz> with kj in the beginning, or so

[19:40] <tadzik> yeah, I don't recall seeing it written anywhere :)

[19:41] <moritz> erm, just k

[19:41] <moritz> "köttbullar" it seems

[19:42] <PerlJam> the only problem is that I don't have enough of them.

[19:43] <PerlJam> (But I guess that's really a blessing so I don't get fat from eating too much)

[19:43] <moritz> PerlJam, colomon, tadzik: can I motivate you to write some strategies for the prisoner's dilemma?

[19:43] <moritz> (see http://perlgeek.de/blog-en/perl-6/iterated-prisoners-dilemma.html for the details)

[19:43] <colomon> moritz: I've been meaning to, but my tuits are completely messed up at the moment

[19:43] <colomon> I'll make no promises, but I'll see what I can do.

[19:43] <tadzik> moritz: certainly, counting from tomorrow :)

[19:44] <tadzik> (I have one last exam tomorrow on 8AM

[19:44] <tadzik> )

[19:44] <moritz> \o/

[19:44] <tadzik> then I should be back to the usual slacking o^W^Whacking routine

[19:45] * colomon is the only healthy person in his immediate family, meaning he is on childcare duty, supposedly also working a full time job, and is superhumanly tired

[19:46] <tadzik> ouch

[19:46] <tadzik> colomon.energy++

[19:46] <moritz> colomon: it's similar here, though I can reduce the "full time job" part as needed

[19:46] <colomon> admittedly I'm messing around with Bags at the moment, because I don't have enough brainpower handy to do $work

[19:47] <PerlJam> moritz: maybe

[19:48] <PerlJam> Though to do anything but someple simple I'd need time to play with it and time always seems to be in short supply

[19:48] <PerlJam> s/someple/something/   # wow.

[19:49] *** daxim left
[19:49] *** bluescreen10 joined
[19:52] <PerlJam> moritz: here's one now though:  sub (:@theirs, *%) { +@theirs %% 2; }  #  :-)

[20:01] <pyrimidine> moritz: it's best not to feed the _foo, he never comes around

[20:02] <moritz> pyrimidine: I fear I can't resist at the moment :(

[20:08] *** tarch__ left
[20:09] <pyrimidine> moritz: I think he misses a major point.  Where would Perl 5 be if Perl 6 never existed?  Would perl 5.10 have happened?  Would there be a Moose?  

[20:10] <moritz> pyrimidine: there are a whole lot of points he is missing

[20:10] <pyrimidine> yup.  he likes strawmen

[20:11] * jnthn back from le dinner

[20:12] <moritz> jnthn: was it French? :-)

[20:13] <jnthn> No, I just wanted to sound classy and stuff.

[20:20] <dalek> niecza: b1a1194 | (Solomon Foster)++ | lib/CORE.setting:

[20:20] <dalek> niecza: Port KeyBag improvements back to Bag.

[20:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b1a1194d2d

[20:21] <dalek> roast: 8d18a30 | (Solomon Foster)++ | S02-types/bag.t:

[20:21] <dalek> roast: 70 more tests for Bag.

[20:21] <dalek> roast: review: https://github.com/perl6/roast/commit/8d18a308d4

[20:23] * tadzik wonders if *Bags are Rakudo-stealable

[20:24] <jnthn> Should be fairly possible :)

[20:24] * PerlJam wonders what it would take to silence the perl6-grouches of the world.

[20:25] <masak> I hereby dub the person in any post about Perl 6 who writes the inevitable comment saying "Perl 6 is failing/a farce/irrelevant/worthless", or something to that effect, causing deeply nested comments from insiders and outsiders alike that never lead anywhere, "the sponge".

[20:26] <masak> please consider carefully how much time you want to waste on the sponge. ;)

[20:26] <jnthn> Is that the sponge I wash up with, or sponge pudding?

[20:27] <PerlJam> jnthn: it's a dirty, nasty used sponge with bacteria oozing from it's insides.

[20:27] <jnthn> Eww. OK, 'cus wasting time on sponge pudding woulda been tempting. :)

[20:28] <PerlJam> masak: I wasted just enough time to read the thread(s), but that was time I was going to waste doing something frivolous and non-coding anyway

[20:28] <masak> nodnod

[20:28] <masak> well, the time that sponges mostly suck up is if you enter a conversation with them.

[20:30] * PerlJam starts down voting moritz's node because of the sponge he helped inflict upon us  ;)

[20:30] <PerlJam> s/node/nodes/

[20:32] <tadzik> colomon: why is %elems in https://github.com/sorear/niecza/blob/b1a1194d2d1b993942d9f1cfb5b611b854e66df2/lib/CORE.setting#L2128 Bool? 

[20:33] <Su-Shee> PerlJam: it would take a couple of cool projects out there for everybody to use. some must-haves. 

[20:33] <tadzik> without the constraint the implementation passes tests on Rakudo

[20:33] <colomon> tadzik: because I copied and pasted without noticing that, and apparently niecza doesn't check

[20:33] <colomon> tadzik++

[20:33] <tadzik> :)

[20:34] <tadzik> applies for a nieczabug I suppose

[20:34] <jnthn> tadzik++

[20:34] <masak> this is why I don't type my attributes. :)

[20:35] <tadzik> if anyone wants an LHF, https://gist.github.com/1782889 passes a similar set of tests that niecza does, on the first glance

[20:35] <tadzik> I should probably be learning for my exam instead :)

[20:35] <masak> nom: class A { has Int @.a }; my $a = A.new(:a(1, 2, "OH NOES")); say "alive"

[20:35] <p6eval> nom 828e4d: OUTPUT«alive␤»

[20:35] <tadzik> works for hashes

[20:35] <jnthn> Works for individual array alements

[20:35] <jnthn> But not assignment.

[20:35] <masak> I don't like to write code that could fail in the future when the implementation gets better.

[20:39] <masak> moritz: the technical comment about why Rat is slow is great. the personal comment about the 'educated_' prefix is not over-the-top in any way, and it's your pen, but... it's feeding the sponge, and nothing more.

[20:40] <dalek> niecza: 760a302 | (Solomon Foster)++ | lib/CORE.setting:

[20:40] <dalek> niecza: Fix embarrassing mistake noticed by tadzik++.

[20:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/760a30297d

[20:41] <tadzik> that may have been my first niecza contribution of some sort :)

[20:43] <masak> moritz: if nothing else, it's evident from the followups that those two comments led to. the one with the high blood pressure in it even attracted chromatic.

[20:43] <tadzik> are we talking about some perlmonks discussion?

[20:43] <masak> yeah.

[20:43] <colomon> geez, my head is so fuzzy I just completely botched a simple Thomas the Tank engine layout.

[20:44] <pyrimidine> tadzik: http://perlmonks.org/index.pl?node_id=952765

[20:44] * colomon is probably going to regret looking...

[20:47] <masak> nom: .say for "", { $_ ~ "potato".substr(.chars, 1) } ... "potato"

[20:47] <p6eval> nom 828e4d: OUTPUT«␤p␤po␤pot␤pota␤potat␤potato␤»

[20:47] <masak> Rakudo can count to potato :D

[20:48] <masak> nom: .say for "", { $_ ~ "potato".substr(.chars, 1) // last } ... *

[20:48] <p6eval> nom 828e4d: OUTPUT«(timeout)␤p␤po␤pot␤pota␤potat␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤…

[20:48] <masak> nom: .say for "", { $_ ~ ("potato".substr(.chars, 1) // last) } ... *

[20:48] <masak> hm.

[20:48] <p6eval> nom 828e4d: OUTPUT«(timeout)␤p␤po␤pot␤pota␤potat␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤potato␤…

[20:49] * masak .oO( "I know how to count to potato, but I don't know when to stop..." )

[20:49] <tadzik> banananananananana

[20:49] <masak> nom: say "ba" ~ "na" x (2..20).roll

[20:49] <p6eval> nom 828e4d: OUTPUT«banananananananananana␤»

[20:55] *** pernatiy left
[20:56] *** pernatiy joined
[20:57] *** bluescreen10 left
[20:58] *** birdwindupbird left
[21:04] *** lestrrat left
[21:05] *** lestrrat joined
[21:08] *** GlitchMr left
[21:09] <skids> specwise, if two roles/classes with a same-named attribute are composed, does the overridden one still exist enough to, well I guess, "take up space?"

[21:10] <jnthn> If you compose two roles with the same named attribute, it's a conflict. I'm not sure what you mean about composing two classes.

[21:14] <skids> OK good.

[21:15] *** bluescreen10 joined
[21:16] <masak> perl6: role A { has $!x }; role B { has $!x }; class C does A does B {}; say "alive"

[21:16] <p6eval> rakudo 828e4d: OUTPUT«===SORRY!===␤Attribute '$!x' conflicts in role composition␤»

[21:16] <p6eval> ..pugs b927740: OUTPUT«alive␤»

[21:16] <p6eval> ..niecza v14-32-g760a302: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Attribute '$!x' is provided by both 'A[curried][...]' and 'B[curried][...]' at /tmp/fnAJyZgvin line 1:␤------> [32m B { has $!x }; class C does A does B {}[33m⏏[31m; say "alive"[0m␤␤Unhandled exception: Check failed␤␤  a…

[21:16] <masak> Niecza likes curry.

[21:16] <jnthn> LTA that Rakudo doesn't tell you which roles.

[21:17] <jnthn> Could optimize the currying out in that case.

[21:27] *** fsergot left
[21:28] <skids> nom: class A { has $!a; }; class B is A { has $!a }; my B $a .= new(); $a.HOW.attributes($a).say

[21:28] <p6eval> nom 828e4d: OUTPUT«$!a $!a␤»

[21:32] <colomon> tadzik: I should warn you that I plan significant changes still for Set and KeySet.

[21:33] <tadzik> okay :)

[21:33] <tadzik> I'm not in a hurry

[21:33] <tadzik> the more situations like this appear the more I think about something along STD.pm6, but for CORE.setting

[21:35] <colomon> you mean a standard setting for more than one implementation?

[21:35] <tadzik> aye

[21:35] <tadzik> look at what we're doing now

[21:35] <tadzik> copying This and That from Rakudo to Niecza, then other This and That from Niecza to Rakudo

[21:35] <colomon> true

[21:35] <colomon> but usually there are at least minor changes when we do that

[21:37] <tadzik> now it was adding : before %elems in BUILDs, and changing the %e{$a}:delete expressions to the method call equivalents

[21:40] <dalek> nqp/bs: 44d674d | jnthn++ | src/6model/serialization. (2 files):

[21:40] <dalek> nqp/bs: First crack at one-level-deep closure serialization; survives, though not done deserialization yet.

[21:40] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/44d674d1f3

[21:48] *** kaare_ left
[21:51] <[Coke]> I think that's a very reasonable goal to have that shared, but I think we're going to get there organically, rather than by attempting to force it.

[21:53] *** MayDaniel left
[21:54] *** Chillance left
[21:54] <colomon> what [Coke] said.

[21:57] * [Coke] ponders graduate studies.

[21:57] <[Coke]> and perl6.

[22:07] *** skids left
[22:12] *** preflex_ joined
[22:12] *** preflex left
[22:12] <colomon> moritz: so, is that prisoner's dilemma harness *the* harness for the competition, or not?

[22:12] *** preflex_ is now known as preflex

[22:22] <cognominal___> jonathan: you meant "le dîner"? :)

[22:22] <[Coke]> that question makes me think you're trying to game the system, sirrah!

[22:22] *** benabik left
[22:24] <cognominal___> or may be "le diner". There has been a spelling reform that is ignored both by the litterate or the sms generation, that invents its own language.

[22:26] <masak> [Coke]: no, it makes sense to know how the competition will be judged.

[22:26] <cognominal___> it is funny to see that the spelling of words like jeanfoutre (jerker) is regulated by law :  http://www.academie-francaise.fr/langue/orthographe/graphies.html

[22:28] <cognominal___> someday, we will have legal trouble in France, if we try to verb names. :)

[22:31] <cognominal___> Apparently, with antidote, the software, one can chose the spelling, mordern, ancient or both

[22:32] <cognominal___> indeed, the new spelling drop the accent.

[22:32] <cognominal___> *modern *drops

[22:32] <cognominal___> antidote++

[22:32] <cognominal___> http://www.druide.com/antidote.html

[22:34] <cognominal___> *literate (but from litteratus)

[22:46] <masak> cognominal___: I would be sorry to see the accents go. I like most of them.

[22:48] * jnthn tries not to make a joke about ze French accent

[22:49] <cognominal___> the new rule specifies dropping or changing accents where French people are confused to start with so in practice it does not change anything.

[22:49] <masak> right. people who were confused prior to the reform will remain so :)

[22:49] *** yertalert left
[22:49] *** nimiezko joined
[22:49] <masak> rule of thumb: don't reform for the confused. :)

[22:50] <masak> bonne nuit, #perl6

[22:50] <cognominal___> but I remember there have been an outcry when some conporary book recent publication has been rectified.

[22:50] <jnthn> branoc, masak

[22:51] <nimiezko> rakudo: qx/ls/

[22:51] <p6eval> rakudo 828e4d: OUTPUT«qx, qqx is disallowed in safe mode␤  in sub restricted at src/SAFE.setting:2␤  in sub QX at src/SAFE.setting:9␤␤»

[22:51] <nimiezko> rakudo: q:x/ls/

[22:51] <p6eval> rakudo 828e4d: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 1, near ":x/ls/"␤»

[22:52] *** snearch left
[22:52] <cognominal___> that's very French to publish laws that are totally ignored. I think one third of them don't have a application decret signed by the president meaning that le legislative process is ignored by him even when it has been intiated by him at a time it was mediatically opportune to do so.

[22:52] <cognominal___> s/le/the/

[22:53] <nimiezko> nieczca: qx/ls/

[22:54] <nimiezko> What is the status on quoting forms (Q with adverbs) from S02 in rakudo ?

[22:55] <cognominal___> aren't they macros?

[22:55] *** cognominal___ is now known as cognominal

[22:55] <jnthn> nimiezko: The general Q with adverbs form isn't implemented in Rakudo yet, as far as I'm aware.

[22:56] *** REPLeffect joined
[22:56] <jnthn> Don't think we're missing anything especially major to implement it, just didn't happen yet.

[22:57] <nimiezko> so only abreviated forms works for now ?

[22:57] <jnthn> Correct.

[22:57] <nimiezko> thanks a lot

[23:09] *** Gothmog_ left
[23:09] *** chra left
[23:09] *** sudokode left
[23:09] *** awwaiid left
[23:09] *** y3llow left
[23:09] *** Gothmog_ joined
[23:09] *** awwaiid joined
[23:09] *** chra joined
[23:09] *** sudokode joined
[23:09] *** y3llow joined
[23:11] *** y3llow left
[23:12] *** y3llow joined
[23:13] *** y3llow left
[23:14] *** y3llow joined
[23:16] *** y3llow left
[23:16] *** y3llow joined
[23:16] <dalek> nqp/bs: 0505b08 | jnthn++ | src/6model/serialization.c:

[23:16] <dalek> nqp/bs: Don't attempt to serialize an outer that'll simply never work out.

[23:16] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/0505b08177

[23:16] <dalek> nqp/bs: cf55512 | jnthn++ | src/6model/serialization.c:

[23:16] <dalek> nqp/bs: Start to sketch out overall closure deserialization process.

[23:16] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/cf55512f22

[23:16] <dalek> nqp/bs: 3b9c867 | jnthn++ | src/6model/serialization.c:

[23:16] <dalek> nqp/bs: First crack at closure deserialization. Passes one of the tests, fails another...something still a bit off.

[23:16] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/3b9c86796c

[23:16] <dalek> nqp/bs: 84c2256 | jnthn++ | src/6model/serialization.c:

[23:16] <dalek> nqp/bs: Fix a couple of silly thinkos; basic closure serialization tests now pass.

[23:16] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/84c2256ba6

[23:17] *** leontopod joined
[23:17] <leontopod> If you guys can come out with Perl 6.0.0, I will start coding in it. =)

[23:18] <cognominal> we don't believe in numerology. :)

[23:19] <leontopod> you know, Perl 6, Version 1

[23:20] <tadzik> leontopod: what is that you don't like about the current version?

[23:22] <leontopod> I don't think it is ready to produce production code yet.

[23:23] <leontopod> Is anybody using Perl 6 to do anything Real?

[23:23] <tadzik> masak does

[23:23] <leontopod> Like, avionics, or controlling a nuclear power plant

[23:23] <leontopod> I know, I talked to masak.

[23:23] <leontopod> He nice guy! =)

[23:23] <leontopod> I promised him I wouldn't troll, so I better stop.

[23:26] <flussence> "$language doesn't do $completely-unrealistic-requirement, $language sucks!"

[23:26] <flussence> so what language is your nuclear reactor and/or air control tower currently using?

[23:27] <timotimo> cobol?

[23:27] <timotimo> hopefully ada or something similar

[23:32] <tadzik> cobol I guess

[23:37] *** whiteknight joined
[23:38] <timotimo> did you come here to protect poor perl6-in-distress, whiteknight? :)

[23:38] <whiteknight> timotimo: is perl6 in distress?

[23:38] <whiteknight> I came online to look up funny pictures of cats, but I'll help if help is needed

[23:39] <timotimo> a troll just came here who's all like "but i cannot use perl6 in a nuclear power plant yet! so clearly it's not ready to be used!"

[23:39] <timotimo> but i was mostly kidding, as was he

[23:39] <whiteknight> oh, then I won't say anything mean about him :)

[23:39] <tadzik> oh, I wouldn't exaggarate and call that trolling

[23:39] <tadzik> it's more like the usual "when will you hit 1.0"

[23:40] *** damsel_in_distre joined
[23:40] *** damsel_in_distre is now known as DamselInDistress

[23:40] *** nimiezko left
[23:44] <DamselInDistress> Help me, whiteknight, I need to learn perl6 to please a nice guy who could probably be more than just a friend, if you catch my drift ^^ but I need to learn perl6 to help him code a server for a supercool RPGgame that I need to write ;-) it has everyting a traditional RPG has and will also have awesome features and allow much better rpggeneration. Canyouhelpmeplz? ^^';

[23:44] <flussence> .oO( didn't we hit 1.0 some time around 1985? )

[23:44] <whiteknight> DamselInDistress: ha, that's the coolest request for help I've ever heard. Unfortunately, I'm probably not best for the job

[23:44] <whiteknight> my knowledge of P6 is not great

[23:45] <DamselInDistress> shucks

[23:45] *** DamselInDistress is now known as lisa_schwarzhaar

[23:45] <lisa_schwarzhaar> perl6 sounds cool though, I shall hang out in here for a while

[23:45] <leontopod> flussence, probably ADA

[23:46] <timotimo> is it ADA, not Ada?

[23:46] <leontopod> I know a lot of air traffic control systems and even some avionics use Jovial

[23:46] <tadzik> lisa_schwarzhaar: what do you need help with?

[23:46] <leontopod> which is a really really old multithreaded/tasking version of Algol

[23:46] <tadzik> lisa_schwarzhaar: do you have previous Perl/programming experience?

[23:46] <whiteknight> lisa_schwarzhaar: now, if you want to learn C, and have some extra hair that you don't mind ripping out, I can help :)

[23:47] <lisa_schwarzhaar> whiteknight, tadzik I can code c/c++ already and my hair is sacred

[23:47] <lisa_schwarzhaar> As for learning perl6, I guess I'll read a book / the internet and nag some of the local nerds

[23:47] <tadzik> and is schwarz

[23:47] <whiteknight> timotimo: Probably Ada. It's named in honor of Ada Lovelace

[23:47] <tadzik> lisa_schwarzhaar: try the Using Perl 6 Book

[23:47] <timotimo> yup, wikipedia claims so as well

[23:47] <whiteknight> lisa_schwarzhaar: excellent strategy

[23:47] <lisa_schwarzhaar> tadzik: sounds good

[23:48] <tadzik> lisa_schwarzhaar: http://perl6.org/documentation/ generally

[23:48] <lisa_schwarzhaar> I can still nag you with general questions, right?

[23:48] *** nimiezko joined
[23:48] <tadzik> sure thing

[23:48] <timotimo> "so, how do i computer?", lisa_schwarzhaar?

[23:48] <whiteknight> I can program some NQP, which is not quite what you want :)

[23:49] <timotimo> what exactly is nqp? it seems to have something to do with native calls and belongs to Parrot VM?

[23:49] <lisa_schwarzhaar> timotimo: Like I told you before, you gotta make sure your computer is feeling well. Treat it / him / her to some nice juicy electricity and generally treat it well...

[23:49] <tadzik> timotimo: it's a subset of Perl 6 in which the core compiler is written

[23:49] <flussence> it's perl6 without any syntactic sugar at all

[23:49] <timotimo> oh, interesting/terrible

[23:50] <whiteknight> timotimo: yeah, NQP is a subset of perl used for bootstrapping the compiler

[23:50] <whiteknight> so Rakudo perl6 is written in perl6

[23:50] <timotimo> cool, i totally didn't know that

[23:50] <jnthn> NQP is also self-hosting. :)

[23:51] <leontopod> Rakudo runs Parrot Assembly Language I thought

[23:51] <timotimo> so it's a little bit like pypy in that regard?

[23:51] <timotimo> wait. it's a subset of perl? or perl6?

[23:51] <jnthn> Subset of Perl 6.

[23:51] <whiteknight> jnthn: yes, it's turtles all the way down

[23:52] <whiteknight> Until you finally get down to a single exhausted bit, flipping on and off extremely fast

[23:52] <timotimo> until you reach elephants?

[23:53] <leontopod> you know what was cool about the Atari ST, is that video memory was just part of main memory, and you had the ability with a small C program to reset the video pointer to anywhere in memory you wanted

[23:53] <leontopod> so if you set it to low memory

[23:53] <leontopod> each pixel represents one bit

[23:54] <leontopod> so you can see counters counting up, bits flipping on and off, chunks of disk being read in

[23:54] <leontopod> it was pretty neat!

[23:54] <leontopod> oh right, and what made this all possible is the video chip ran asynchronously to the main cpu (68000) chip

[23:54] <leontopod> you can't do that easily with 80x86 architectures because video memory is separate from main memory

[23:55] * lisa_schwarzhaar smiles happily while daydreaming of better times

[23:55] <leontopod> really it hearkened back to the days when computers had lights on the console, and gleaming rows of toggle switches!

[23:56] <leontopod> Toggle switches so  you could toggle in bootstrap code.

[23:56] <timotimo> those were better times

[23:56] <timotimo> how did we get to this topic?

[23:56] <lisa_schwarzhaar> I heard they had hybrid computers too.. I even got to touch one..

[23:57] <leontopod> yes, the computing power in an android phone used to take up a large room in the 1960s

[23:57] <leontopod> I programmed on some of those beasts.

[23:57] <timotimo> uh

[23:57] <timotimo> an android phone would take more than just one large room

[23:57] <leontopod> well, ok!

[23:57] <leontopod> =)

[23:57] <leontopod> an entire fricking building!

[23:57] <timotimo> those phones usually host dual-core processors and sometimes dedicated graphics processors? not sure.

[23:58] <lisa_schwarzhaar> just clean out all the bloat and it would run on a decent old computer...

[23:58] <timotimo> and then there's the GSM chip that runs its own realtime-OS

[23:58] <leontopod> I am seriously looking into the android scripting environment

[23:58] <timotimo> i would suppose you couldn't even get to the performance due to bandwidth limitations in the whole thing and the problem of parallelizing things

[23:58] <leontopod> I'd like to write an android app in Perl

[23:59] <timotimo> you mean SL4A?

[23:59] <leontopod> I don't think it is QUITE there yet

