[00:02] *** drupek12 joined
[00:11] *** Loccccs joined
[00:25] *** explorer joined
[00:34] *** forsaken joined
[00:48] *** Debolaz joined
[01:05] <svnbot6> r15498 | lwall++ | Lookahead for P5ish 'for' code was wrong

[01:22] *** IllvilJa joined
[01:30] *** buetow joined
[01:31] *** Khisanth joined
[01:48] *** dolmans joined
[01:58] *** buetow joined
[02:18] *** forsaken joined
[02:19] *** dmq joined
[02:28] *** Minidin joined
[02:45] *** araujo joined
[02:47] *** araujo joined
[02:49] *** REPLeffect joined
[02:59] *** GabrielVieira joined
[03:00] *** pbuetow joined
[03:11] *** scw_ is now known as scw

[03:17] *** Schwern joined
[03:18] *** Khisanth joined
[03:30] *** nperez joined
[03:47] *** kanru joined
[03:51] *** weinig is now known as weinig__

[03:51] *** weinig__ is now known as weinig

[04:07] *** mako132_ joined
[04:19] *** nekokak joined
[04:23] *** geoffb joined
[04:26] *** dj_goku joined
[04:31] *** amnesiac joined
[04:57] *** anm joined
[04:59] *** justatheory joined
[05:12] <TimToady> TheDamian suggests one simplification would be to get rid of the &foo\(1,2,3,:mice<blind>) form and stick with the longer form &foo.assuming(1,2,3,:mice<blind>)

[05:12] <TimToady> anybody want to stick up for the short form?

[05:25] *** dolmans joined
[05:35] *** weinig is now known as weinig|zZzZ

[05:36] <TimToady> I'll take that as a no.  :)

[05:39] <specbot6> r14312 | larry++ | Some clarifications and oversights noted by TheDamian++.

[05:39] <specbot6> r14312 | larry++ | The &foo\($bar) shorthand for &foo.assuming($bar) is now gone.

[05:43] <svnbot6> r15499 | lwall++ | Deleted short form of .assuming

[05:43] *** GabrielVieira2 joined
[05:59] *** DHGE joined
[05:59] <specbot6> r14313 | larry++ | Q: Can February March?  A: No, but April May...

[06:00] <allbery_b> not the best time to ask such questions, perhaps, but (having not realized such a short form existed) my vote is "ewwwwwwww!"

[06:01] <allbery_b> I keep reading it as a typo in a long dot 

[06:02] *** GabrielVieira2 is now known as GabrielVieira

[06:02] *** revdiablo joined
[06:07] *** revdiablo joined
[06:09] *** ayrnieu joined
[06:14] *** BooK_ joined
[06:18] *** ]particle[ joined
[06:20] *** ]particle[ left
[06:23] *** jisom joined
[06:25] *** jisom left
[06:25] *** jisom joined
[06:52] *** iblechbot joined
[07:04] *** mauke_ joined
[07:15] *** devogon joined
[07:27] * yves is away: Occupé

[07:27] * yves is back (gone 00:00:19)

[07:54] *** mauke_ is now known as mauke

[08:02] *** the_dormant joined
[08:12] *** polettix joined
[08:13] *** marmic joined
[08:24] *** dduncan left
[08:33] <audreyt> TimToady: ping

[08:33] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:33] <audreyt> lambdabot: @messages

[08:33] <lambdabot> TimToady said 15h 16m 14s ago: actually, := is already specced to fail if the type is inconsistent, S03:1003

[08:34] <audreyt> @tell TimToady So is it okay to say "my $x; $x := [1,2,3]" works because "my $x is Any" is annotated, but "my Any $x; $x := [1,2,3]" fails because it means "my $x is Scalar of Any" and [1,2,3] is not a scalar?

[08:34] <lambdabot> Consider it noted.

[08:38] <gaal> hey audreyt 

[08:39] <audreyt> heya

[08:39] <gaal> still getting an error I don't understand; could be I'm missing some instances

[08:39] <audreyt> I managed to escape nascent Lost addiction

[08:40] <audreyt> <- going back to coding

[08:40] <audreyt> nopaste patch+error?

[08:40] <pasteling> "gaal" at 192.115.25.249 pasted "enough code quoted in error, I think" (41 lines, 1.7K) at http://sial.org/pbot/23324

[08:40] <audreyt> ok, see, ghc doesn't know what type pos should be

[08:41] <gaal> there's also instance Boxable PureInt and instance Boxable Int

[08:41] <audreyt> \ str sub (pos :: PureInt)

[08:41] *** iblechbot joined
[08:41] <audreyt> is one way

[08:41] <audreyt> (Str.drop pos str)

[08:41] <audreyt> is another way

[08:41] <gaal> oh, the incoming type?

[08:41] <audreyt> yeah

[08:41] <audreyt> it only knows that it's Boxable

[08:41] <audreyt> and it can be casted to Int

[08:41] <audreyt> but that's insufficient info

[08:42] <gaal> ok: changing (cast pos) to pos makes the error:

[08:42] <gaal> No instance for (Boxable (Int -> Val))

[08:42] <gaal> but that means I have an arity error somewhere doesn't it?

[08:43] <audreyt> well, yeah

[08:43] <gaal> I don't see it :(

[08:43] <audreyt> can you nopaste the patch

[08:43] <audreyt> or commit it?

[08:44] <gaal> nopaste coming up...

[08:44] <pasteling> "gaal" at 192.115.25.249 pasted "index" (71 lines, 2.3K) at http://sial.org/pbot/23325

[08:44] <audreyt> oh ok

[08:44] <audreyt> because it did not fit the instance

[08:44] <audreyt> see, you are working with

[08:45] <audreyt> PureStr -> PureStr -> Int -> Val

[08:45] <audreyt> but your instance is a->b->c->Eval z

[08:45] <audreyt> you need either a

[08:45] <audreyt> a->b->c->z

[08:45] <audreyt> or a 

[08:45] <audreyt> a->b->c->Val

[08:45] <gaal> oh, so add 'return'?

[08:45] <audreyt> no

[08:45] *** the_dormant joined
[08:45] <audreyt> add an autoderiv

[08:45] <audreyt> -- Auto-generate pure instances from Eval instances

[08:45] <audreyt> instance MethodPrimable (a -> b -> Eval z) a => MethodPrimable (a -> b -> z) a where asPrim f = asPrim ((\x args -> return (f x args)) :: (a -> b -> Eval z))

[08:45] <audreyt> similar to this

[08:46] <audreyt> but 3ary not 2

[08:46] <audreyt> adding return would do

[08:46] <audreyt> but that's not sufficiently pointless

[08:46] <gaal> wow that instance is very moose

[08:48] <audreyt> :D

[08:48] <gaal> okay; I added the instance and now I get: No instance for (Boxable (Invocant Eval))

[08:48] <audreyt> (customizable contexts)++

[08:49] <gaal> instance MethodPrimable (a -> b -> c -> Eval z) a => MethodPrimable (a -> b -> c -> z) a where asPrim f = asPrim ((\x y args -> return (f x y args)) :: (a -> b -> c -> Eval z))

[08:49] <audreyt> ok, that means Val is not boxable atm

[08:49] <gaal> isn't Val's box id?

[08:49] <audreyt> correct

[08:50] <gaal> should I add the instance or is it a mistake to have to use it?

[08:50] <gaal> and, how come it wasn't needed in the other methods?

[08:50] <audreyt> because they all just return something

[08:50] <gaal> oh, as opposed to a Val

[08:50] <audreyt> right.

[08:50] <gaal> because I'm already mkValing inside

[08:50] <gaal> okok

[08:51] <audreyt> dunno... I can argue either way

[08:51] <audreyt> another thought is to simply write another instance of MPrimable

[08:51] <audreyt> that has ->Eval Val

[08:51] <audreyt> instead of Eval z

[08:51] <audreyt> that feels slightly cleaner

[08:51] <audreyt> also avoids two unneccessary method calls

[08:51] <audreyt> (the fmap mkVal)

[08:52] <audreyt> so maybe do that instead?

[08:52] <gaal> you mean inside the two mkVals inside the index method?

[08:52] <audreyt> nono, I'm comparing writing another MPrimable instance

[08:52] <audreyt> with writing an instance of Boxable Val

[08:52] <audreyt> I think the former (writing an instance that has no fmap mkVal in it) makes more sense

[08:53] <audreyt> feels funny to double box into id

[08:53] *** Schwern joined
[08:53] <audreyt> so I mean

[08:53] <audreyt> instance (Boxable a, Boxable b, Boxable c) => MethodPrimable (a -> b -> c -> Eval Val) a where

[08:53] <audreyt> ...you know the rest...

[08:54] <audreyt> yet another thought (hey) is to leave sensible errors

[08:54] <gaal> oh; but then we'd need to write two insances for every new arity

[08:54] <gaal> potentially

[08:54] <audreyt> well, not really, because we can autoderiv too

[08:54] <audreyt> but well

[08:54] <gaal> one for MPrim and one for Boxable

[08:54] <gaal> er sorry

[08:54] <audreyt> one for Val and one for B

[08:54] <gaal> one for Eval z and one for Eval Val

[08:54] <audreyt> and one for z

[08:55] <audreyt> the z one covers Val too

[08:55] <audreyt> dunno, the arity is finite

[08:55] <audreyt> not really a loss

[08:55] <gaal> yeah this fever isn't helping my typechecker output layer

[08:55] <gaal> I don't see how autoderiv would work, but ok

[08:55] <gaal> that can happen later

[08:56] <audreyt> nod

[08:56] <gaal> where does the [::]ification of captures happen? in Prelude.pm ::internal methods?

[08:57] <gaal> that is, the rearrangement of args to a list

[08:57] <audreyt> hm, index now returns undef instead of -1?

[08:57] <audreyt> this is going to be fun!

[08:57] <gaal> according to Functions.pod, yeah

[08:57] * audreyt ponders "undef but -1"

[08:57] <gaal> yeah

[08:57] <audreyt> I mean, people would rely on -1

[08:58] <audreyt> how about -1 for now?

[08:58] <gaal> the is 0 .. undef empty?

[08:58] <gaal> s/the//

[08:58] <audreyt> feeling really bad about plain undef

[08:59] <audreyt> it's currently specified as a warning but (0..0)

[08:59] <audreyt> so just return -1 and we avoid the Eval-Val business altogether

[08:59] <gaal> I think that's where it'll hurt most

[08:59] <audreyt> I'll annotate the Functions.pod

[08:59] <gaal> okay

[08:59] <gaal> better life through spec change

[08:59] *** drrho joined
[09:00] <audreyt> ajs_: why does index('foo', 'bar') return undef? :/

[09:01] *** devogon joined
[09:01] * args notes that he highlights on 'args'

[09:01] <moritz> args: owned ;)

[09:02] <audreyt> wait... you were multiple "rg"

[09:02] <audreyt> but now you are just a single "rgs"?

[09:02] <moritz> my girlfried is called signe, so I hilighted on that name, and got matches with "unsigned int" ;-)

[09:02] <audreyt> was it "rg"s then and a"rgs" now, or "arg"s?

[09:03] <gaal>  /nick arghhhs

[09:03] <args> well, I prepended an 'a' because that makes me look so cool.

[09:03] <gaal> and lo, it compiles

[09:04] <audreyt> Ã¤rgs

[09:04] <audreyt> that's cool

[09:06] <gaal> audreyt: why are we using ByteString.Char8?

[09:06] <audreyt> gaal: we shouldn't. we should use UTF8

[09:06] <audreyt> which is a utf view of bytestring

[09:06] <audreyt> it's in src/UTF8.hs

[09:06] <audreyt> so just change the import line

[09:07] <gaal> k

[09:07] <gaal> why wasn't that a type error?

[09:07] <svnbot6> r15500 | audreyt++ | * In "foo".join(1,2,3), "foo" is the separator.

[09:07] <svnbot6> r15500 | audreyt++ | * index("foo", "bar") should really be -1, or something that

[09:07] <svnbot6> r15500 | audreyt++ |   numifies to -1, lest the universe collapses.

[09:07] <gaal> newtype--

[09:07] <audreyt> because both share the ByteString basetype

[09:07] <audreyt> it's just the operations (index length etc)

[09:07] <audreyt> are different

[09:07] <gaal> hmm

[09:07] <audreyt> it's really a view on Buf

[09:07] <gaal> ack

[09:07] <audreyt> and yes, we should switch to Rope once the new fps is out

[09:08] <audreyt> with concat strings and encoding views

[09:08] <audreyt> but The Day Is Not Today etc

[09:08] <audreyt> should be trivial, just another import change

[09:08] <audreyt> the API stays the same

[09:08] <gaal> haskell++

[09:08] <audreyt> indeed.

[09:09] <audreyt> with the right type infrastructure in place, feels almost like cheating :)

[09:09] <gaal> (not that I don't see the hypocricy in my -+)

[09:11] <audreyt> <sleepingsquirrel> Programming in Haskell is like having an interactive conversation with a teleportation machine.

[09:11] <audreyt> <sleepingsquirrel> You tell it you want to go to some place warm and sandy. The machine complains about ambiguous constraints.

[09:11] <audreyt> <sleepingsquirrel> So you tell it that there should be plenty of free tropical fruit drinks. It carps 'Inferred location less polymorphic than expected'.

[09:11] <audreyt> <sleepingsquirrel> After a few more iterations, there's a little puff of smoke, and at the sound of the chimes, you discover you're now on the beach in Tahiti.

[09:11] <audreyt> <sleepingsquirrel> And although you've used the machine many times before, you can't help but be impressed that it usually 'Just works' most of the time.

[09:11] <audreyt> </quote>

[09:12] *** MetaGod joined
[09:12] *** elmex joined
[09:14] <gaal> :-)

[09:14] <svnbot6> r15501 | gaal++ | * use UUndef instead of () for undefined Vals

[09:14] <svnbot6> r15502 | gaal++ | * chop and index

[09:14] <audreyt> gaal: Pad now carries Types... it's been a year but hey, we got there :)

[09:15] * audreyt is finishing up the type-annotation commit

[09:15] <audreyt> interesting tidbit: "my $x is Int; my $y = 3; $x := $y" fails

[09:16] <audreyt> I think people will take some time to learn that "my Int $x" and "my $x is Int" means totally different things.

[09:16] <gaal> find src -name \*\.hs\* | xargs grep Char8 | wc -l  =>  29

[09:16] <gaal> that can't be right

[09:16] <audreyt> most of the time it doesn't matter

[09:17] <audreyt> but yeah, changing them all to UTF8 would be Right

[09:17] <gaal> on the offchance somebody does some op somewhere

[09:17] <gaal> that would be a bummer to debug

[09:17] <audreyt> ayeaye

[09:19] <gaal> what's the vi equivalient to 'cw' that changes up to next whitespace?

[09:19] <args> cE ?

[09:20] <gaal> yeah, great thanks

[09:32] <gaal> huh. my equals key and my left ctrl key stopped working. this is interesting.

[09:33] <gaal> huh! but +, which is shiftequals, works

[09:33] <gaal> oi, minus doesn't work either

[09:33] <gaal> </3 computers

[09:33] <audreyt> ew

[09:34] <gaal> bbiab...

[09:44] <masak> audreyt: so, what is the difference between "my Int $x" and "my $x is Int"?

[09:45] <audreyt> masak: the former is shorthand for

[09:45] <audreyt> "my $x is Scalar of Int"

[09:45] <audreyt> in Haskell-speak:

[09:45] <audreyt> x :: TVar Integer

[09:45] <audreyt> x :: Integer

[09:45] <masak> oki

[09:45] <audreyt> the latter can only be let-rebound

[09:45] <audreyt> not assigned

[09:45] <audreyt> for I hope obvious reasons

[09:45] <masak> yes

[09:46] <gaal> time to get a new keyboard I gues...

[09:46] <audreyt> gaal: best luck

[09:46] <audreyt> you have on spare handy?

[09:46] <gaal> hm I can use the old laptop's

[09:47] <gaal> this makes little sense, but I found that if I hit equals really hard, it sometimes does emit a keypress; when shift is depressed it's more likely yo

[09:47] <gaal> *to

[09:49] <gaal> reminds me of the time I had a keyboard whose lowestbut one row was defunct

[09:49] <gaal> this was in the dos days; you could hit altnumkeypad to get a char

[09:49] <gaal> but 1,2,3 were also dead

[09:49] <gaal> luckily, the number you typed was taken modulo 2**8

[09:50] <gaal> great, five and six are dead too

[09:50] <gaal> life is ridiculous

[09:52] <audreyt> :/

[09:52] <gaal> rehi from laptop. screen++

[09:53] <gaal> oh and foo says hi

[09:53] <audreyt> hi foo!

[09:54] <gaal> "mrrrow"

[09:54] <audreyt> "the next day"?

[09:54] <audreyt> PadEntryMulti is dead, yay.

[09:55] <gaal> I think she means something more along the lines of "oh you are nice and warm"

[09:56] * gaal ponders adding a feature to ghci's :e to position the cursor at last error, or better integration with vim quickfix in general

[09:59] <svnbot6> r15503 | gaal++ | * Don't mention ByteString.Char8 in places where an accidental

[09:59] <svnbot6> r15503 | gaal++ |   string op would truncate the char. Use UTF8 view of ByteString

[09:59] <svnbot6> r15503 | gaal++ |   instead.

[09:59] <svnbot6> r15503 | gaal++ |   (You may need to rebuild after this commit if you're using ghci)

[10:03] <gaal> audreyt: how are mutating methods expressed? eg p5chop

[10:08] <audreyt> gaal: they are (Scalar of Str) methods

[10:08] <audreyt> not Str methods

[10:08] <audreyt> self can't be declared rw

[10:08] <audreyt> so we punt.

[10:08] <audreyt> maybe add a comment to that effect

[10:08] *** BooK joined
[10:08] <svnbot6> r15504 | gaal++ | * Pugs.Meta.Str: Prefer UTF8 functions to Prelude ones for golf value

[10:09] <gaal> thought so... the docs will be messy on this point :/

[10:09] <audreyt> nod.

[10:09] <gaal> unless they are tooled to bunch X of Foo together with Foo

[10:12] <audreyt> sorry, need to bbiab to focus on killing EntryMulti

[10:18] *** chris2 joined
[10:33] *** jisom_ joined
[10:42] *** rfordinal joined
[10:53] *** pbuetow joined
[10:55] <gaal> how is * expressed in newVal, eg.:

[10:55] <gaal>  our List multi method comb ( Str $input: Rule $matcher = /\S+/, Int $limit = * ) is export

[10:59] *** buetow joined
[10:59] *** penk joined
[11:11] *** kanru joined
[11:18] <svnbot6> r15505 | fglock++ | PCR - fixed <+[a]+digit>

[11:18] <svnbot6> r15505 | fglock++ | - t/regex/from_perl6_rules/stdrules.t - all tests pass

[11:18] *** fglock joined
[11:22] <gaal> ... dispatch fails ungracefully:

[11:22] <gaal> ?eval vv("asdf").index("s")

[11:22] *** evalbot_r15496 is now known as evalbot_r15497

[11:22] <evalbot_r15497> 1

[11:22] <gaal> huh? that's a segfault for me

[11:22] <moritz> what does vv() do?

[11:23] <gaal> because I didn't add a "pos" argument

[11:23] <gaal> moritz: it constructs the value as a newVal node instead of an oldVal one

[11:23] <gaal> we are in the ongoing process of replacing much of the way a parsed Perl 6 program is represented

[11:24] <gaal> moritz: to do it in a gradual manner rather than enter a cave and rip off everyhtgin and install the new representation, we added a vv() function that says, although you normally take this as an oldval, it isn't

[11:25] <gaal> ?eval vv("asdf").index("s",0)

[11:25] <evalbot_r15497> 1

[11:25] <gaal> ?eval vv("asdf").index("s",3)

[11:25] <evalbot_r15497> -1

[11:25] <moritz> gaal: so it's something that will not be part of final p6, right?

[11:25] <gaal> right

[11:25] <gaal> huh. it works correctly here...

[11:25] <gaal> ?eval vv("asdf").split(" ")

[11:26] <evalbot_r15497> (" ",)

[11:26] <gaal> ah. it's the old version of the function...

[11:26] <gaal> anyay, I'm getting:

[11:26] <gaal> pugs> vv("asdf").index("s",vv(0))

[11:26] <gaal> *** Cannot coerce from Pugs.Val.PureInt to Int

[11:27] <gaal> (without the vv on 0 too)

[11:29] <audreyt> rehi

[11:29] <gaal> heya

[11:29] <gaal> I may need to lie down for a bit soon...

[11:29] <audreyt> this means coerceVal for the Int instance isn't working yet

[11:30] <gaal> committing what I have so far

[11:30] <audreyt> k

[11:30] <audreyt> PadEntryMulti is gone

[11:30] <audreyt> all entries are now typed

[11:30] <audreyt> constants actually work

[11:30] <audreyt> and Multi code is now a proper Code object that just happens to contain other variants

[11:30] <audreyt> however it broke pretty much everything

[11:30] <audreyt> still fixing now ;)

[11:30] <gaal> :))

[11:31] <audreyt> gotta go through the red-inducing period before yellow-inducing

[11:32] <gaal> I had to touch Pugs.AST.Internals to get non-ghci build working, for some reason (PadEntry YAML instance missing)

[11:32] <svnbot6> r15506 | gaal++ | * a few more Str methods

[11:32] <audreyt> k

[11:32] <gaal> but I guess once it's removed that problem will go away :)

[11:32] <audreyt> that's my fault

[11:32] <audreyt> the comment there needs to be nixed

[11:32] <audreyt> betweeh the two PadEntry variants

[11:32] <gaal> yeah I moved it after the drift hint

[11:32] <audreyt> cool

[11:32] <gaal> yeah, committing then

[11:33] <audreyt>     Could not find module `Pugs.Prim.String':

[11:33] <audreyt>       Use -v to see a list of the files searched for.

[11:33] <svnbot6> r15507 | gaal++ | * unbreak the build

[11:33] <gaal> oi fixing

[11:33] <audreyt> util/add-text-fie

[11:33] <audreyt> :)

[11:33] <audreyt> gaal++

[11:34] <gaal> pull

[11:35] <gaal> nap, bbiab &

[11:35] <svnbot6> r15508 | gaal++ | * unbreak the build again

[11:35] <audreyt> @tell TimToady I'm going to assume that there's nothing as "anonymous multi sub"; i.e. only &name gets the multi-merging treatment and not $name.

[11:35] <lambdabot> Consider it noted.

[11:36] *** buetow__ joined
[11:38] *** buetow__ joined
[11:41] *** b00t joined
[11:48] <audreyt> @tell TimToady I'm going to assume that there's nothing as "anonymous multi sub"; i.e. only &name gets the multi-merging treatment and not $name.

[11:48] <lambdabot> Consider it noted.

[11:48] <audreyt> oops, retold

[11:51] <fglock> audreyt: in 6-on-5, I've been thinking about implementing p6 pads as p5 classes

[11:51] <fglock> vars are accessors, and inner pads are inherited classes

[11:52] *** iblechbot joined
[11:53] <fglock> pads are actually instances of these classes

[12:27] <gaal> that would be way cute!

[12:31] *** buetow joined
[12:31] <gaal> mhm editing P.M.Str still triggers massive rebuild. I wonder why...

[12:42] *** fglock joined
[12:44] *** REPLeffect joined
[12:53] *** buetow joined
[12:59] *** Psyche^ joined
[13:05] *** pbuetow joined
[13:07] *** Psyche^ is now known as Patterner

[13:13] *** weinig|zZzZ is now known as weinig|bbl

[13:15] *** dec_ joined
[13:18] *** Limbic_Region joined
[13:25] *** the_dormant joined
[13:30] *** elmex joined
[13:46] *** IllvilJa joined
[13:54] * gaal mooses

[13:55] *** buetow joined
[14:00] *** fglock joined
[14:03] <fglock> gaal: re cute - was it about pad-class in 6-on-5?

[14:04] *** Psyche^ joined
[14:06] <kolibrie> fglock: that is my impression

[14:07] <fglock> kolibrie: I'm back to debugging PCR infinite loops

[14:07] <kolibrie> ouch.  I thought that was fixed

[14:08] <fglock> I found new ones

[14:09] <kolibrie> ahh

[14:09] <fglock> there is a problem with backtracking and zero-width matches

[14:10] <kolibrie> if it backtracks, then matches a zero-width match?

[14:10] <fglock> I didn't fully understand the problem yet

[14:10] <kolibrie> <token> | <''>

[14:12] <fglock> it seems that even '^' can be a problem

[14:12] <kolibrie> so, something to do with backtracking and zero-width matches, but the exact problem is still to be determined?

[14:14] <gaal> fglock: yeah, the Perl 5 object system proves its flexibility once again :)

[14:15] *** rindolf joined
[14:16] <fglock> gaal: yes :) I had that idea when I unified 'vtable' and 'pad' in the mp6-on-C prototype

[14:17] *** Psyche^ is now known as Patterner

[14:18] <fglock> kolibrie: the problem is near lines 60-90 in Pugs::Runtime::Regex

[14:21] *** spinclad joined
[14:25] <kolibrie> fglock: looks like there are lots of (commented out) print statements there (area of previous debugging)

[14:26] <fglock> the current problem with kp6 is too many indirection - "$x" is compiled to $closure->pad->Scalar_x->FETCH 

[14:28] <fglock> kolibrie: yes, that's a troublesome point in the module

[14:33] <fglock> replacing Pugs::Runtime::Regex with putter's regex engine is a possible solution

[14:44] <fglock> I'd need p6-on-jvm for a $job project

[14:48] <svnbot6> r15509 | gaal++ | * split-on-a-string method. Can be made more efficient.

[14:48] *** iblechbot joined
[15:13] <audreyt> rehi!

[15:15] <kolibrie> audreyt: good morning/evening

[15:16] <audreyt> :)

[15:16] <audreyt> <- still taking pugs apart and seeing massive reds in smokes

[15:17] <audreyt> meaning, not yet ready to check in 

[15:17] *** Psyche^ joined
[15:17] <kolibrie> thank you

[15:18] <gaal> moose

[15:19] <kolibrie> it is very exciting seeing so much activity recently - audreyt feeling better, fglock back from vacation, etc.

[15:20] <audreyt> :)

[15:21] <kolibrie> audreyt: did plans for you to visit Boston in May ever materialize?

[15:22] <audreyt> I did not hear back, so the only plan now is July visit to Mountain View

[15:22] * kolibrie doubts he will be driving through Mountain View in July

[15:22] <kolibrie> driving through Boston in May is much more likely

[15:26] <gaal> audreyt: how newval-ready is VRule? should I transcribe methods that use res, such as $s.split(//)?

[15:28] <audreyt> gaal: sure. just add Boxable to VRule

[15:28] <audreyt> and add a cast in Pugs.AST line 61

[15:28] <audreyt> so fromVal can work

[15:28] <audreyt> that's all it takes

[15:28] * Debolaz is disappointed he couldn't get types.pm to work. :/

[15:30] <Debolaz> For a brief moment, I had hoped for typing in perl 5.

[15:31] <audreyt> typesafety.pm

[15:31] <audreyt> ?

[16:10] *** ilogger2 joined
[16:12] <Debolaz> Limbic_Region: sassign is an op.

[16:12] <audreyt> scalar-assign I bet

[16:14] <Limbic_Region> ahh

[16:14] <Limbic_Region> teach me to only half pay attention

[16:20] *** vel joined
[16:58] *** Aankhen`` joined
[16:58] *** CardinalNumber joined
[17:07] *** fglock joined
[17:12] *** SCalimlim joined
[17:17] *** CardinalNumber is now known as ProperNoun

[17:17] <specbot6> r14314 | audreyt++ | * S06: Instead of introducing the conjectural concept of

[17:17] <specbot6> r14314 | audreyt++ |   single-semicolon delimited multiple-longnames, delegate

[17:17] <specbot6> r14314 | audreyt++ |   the discussion to S12 and present the non-controversial

[17:17] <specbot6> r14314 | audreyt++ |   double-semicolon form as the example instead.

[17:19] <gaal> (I punted on Val<VRule> for now due to circularity issues)

[17:22] <audreyt> gaal: I have this algorithmic moose to solve

[17:22] <gaal> yes?

[17:23] <audreyt> I'll brainstorm it here and check for sanity

[17:23] <audreyt> ok. I've eliminated MkEntryMulti.

[17:23] * gaal summons anatoly

[17:23] <audreyt> now a multi is simply a Val that contains a set of Code

[17:23] <audreyt> just as we planned

[17:23] <audreyt> there are two issues here.

[17:23] <audreyt> one is that we need to write

[17:24] <audreyt> instance Monoid PureSig

[17:24] <audreyt> such that when we are faced with three multis

[17:24] <audreyt> we can find the common-subset-interface of it to advertise to the outside world

[17:25] <gaal> *nod*

[17:25] *** Kattana joined
[17:25] <audreyt> which means we need to Monoid on Cxt

[17:25] <audreyt> and LValueness

[17:25] <audreyt> for each param, as well

[17:25] *** anatolyv joined
[17:26] <audreyt> so let's see... rw `mappend` nonrw = rw

[17:26] <audreyt> CxtItem `mappend` CxtList = ???

[17:26] <gaal> hey anatolyv 

[17:26] <audreyt> anatolyv: greetings

[17:26] <anatolyv> hey audrey, gaal

[17:27] *** justatheory joined
[17:27] <audreyt> now anatolyv is here I'll move on to issue #2

[17:28] <audreyt> namely to implement S12:796

[17:29] <gaal> "The order in which candidates are considered is defined by a topological sort"...

[17:29] <audreyt> yes

[17:29] <audreyt> we have a Set of Signature here, and a single CaptVal

[17:29] <wolverian> is writing a Num instance the sanest way to get a negation operation for your datatype? :)

[17:29] <audreyt> wolverian: or define -: or something

[17:29] <wolverian> yeah. I was looking for Data.Abelian or so... ;)

[17:29] <audreyt> the CaptVal is already reduced according to the multi's proto-sig

[17:30] <audreyt> i.e. the `mconcat` of all its variants

[17:30] <gaal> nod

[17:30] <TimToady> audreyt: I suspect Scalar has to be smart enough to be able to wrap up an Any into a Scalar of Any when bound.

[17:30] <lambdabot> TimToady: You have 3 new messages. '/msg lambdabot @messages' to read them.

[17:31] <audreyt> so we have a partial ordering between the Sig, defined over the CaptVal

[17:31] <[particle]> i'd like to see a bot that can convert synopsis verses to text

[17:31] <[particle]> S12:796?

[17:31] <gaal> [particle]++ # great idea

[17:32] <wolverian> I want a bot that rewrites the synopses in pentameter

[17:32] <audreyt> what's a good way to write the topological sort itself?

[17:32] <ingy> morning

[17:32] <gaal> heya ingy

[17:32] <TimToady> and I think not worrying about multi on anons is fine, since the purpose of multies is to share a short name, and anons ain't got one.

[17:32] *** elmex joined
[17:32] <ingy> hi gaal

[17:33] <audreyt> we have: (candidates :: Set Sig), (compare :: Sig -> Sig -> Ordering), and we'd like to find a Sig that is GT every other

[17:34] <audreyt> I suspect there is something in Data.Graph.Inductive.Basic that simply solves this

[17:34] <gaal> yes, since your exposition already abstraced out the Perlish parts

[17:35] <gaal> lookign there.

[17:35] <audreyt> *nod*

[17:35] *** phiker joined
[17:36] <audreyt> I'd like to not code topological sort myself if possible; I'll get it wrong surely, esp 1:35am now :)

[17:36] <wolverian> Data.Graph has topSort certainly

[17:36] <wolverian> so does inductive, but not in .Basic, forgot where

[17:37] <audreyt> the function should be

[17:37] <audreyt> Set Sig -> Maybe Sig

[17:37] <wolverian> oh, .DFS

[17:37] <audreyt> it returns Just iff there's only one valid topsort

[17:37] <audreyt> in all other case it's Nothing

[17:37] <gaal> @index topSort

[17:37] <lambdabot> Data.Graph

[17:38] <wolverian> @index topsort

[17:38] <lambdabot> Data.Graph.Inductive.Query.DFS, Data.Graph.Inductive.Query, Data.Graph.Inductive

[17:38] <gaal> "A topological sort of the graph. The order is partially specified by the condition that a vertex i  precedes j whenever j is reachable from i but not vice versa.

[17:38] <gaal> "

[17:38] <gaal> not quite what we want though?

[17:38] <audreyt> the one in Inductive.Query is

[17:39] <audreyt> provided by dfs

[17:39] <gaal> ahhh

[17:39] <audreyt> topsort' :: Graph gr => gr a b -> [a]

[17:39] <gaal> so, listToMaybe . topSort'

[17:40] <audreyt> can you (or wolverian, or anatolyv) test that it does work? :)

[17:40] <gaal> you mean outside of Perl yes? :)

[17:40] <TimToady> but let me think about the binding think some more

[17:40] <audreyt> in Hs, yes.

[17:40] <anatolyv> ugh, probably not me, i'm disconnected from my stuff at the moment :)

[17:40] <gaal> sure :)

[17:41] <audreyt> woot :) that will get us True Multi Dispatch

[17:41] <audreyt> as currently proto already works

[17:41] <audreyt> and subs does shadow multis

[17:41] <gaal> woot

[17:42] <audreyt> TimToady: so is nameds part of the long name, or not?

[17:42] <anatolyv> is topsort enough, for practical purposes? maybe there's an incentive to put more fundamental types first, among uncomparables

[17:42] <wolverian> sorry, my coding laptop is offline at the moment, hopefully gaal can hack it :)

[17:42] <audreyt> S06 and S12 are a bit confusing here

[17:42] <anatolyv> foo(Int) and foo(Moose)

[17:43] <TimToady> not sure what you mean by "nameds"

[17:43] <TimToady> oh, named params

[17:43] <TimToady> it's still too early :(

[17:43] <gaal> have coffee, will be sentient

[17:44] <Aankhen``> LMAO.

[17:44] <audreyt> TimToady: multi foo (:$x!) {...}

[17:44] <audreyt> multi foo (Int :$x!) { ... }

[17:44] <TimToady> at the moment the official story is that only positionals (and nameds remapped as positional with proto) participate in 6.0.0, but it's erroneous to assume nameds won't be added later

[17:45] <audreyt> k

[17:45] <TimToady> however, if we decide we know how to add them before 6.0.0, that'd be nice

[17:45] <TimToady> 'course, I have a vague recollection that I used nameds in longnames somewhere in *STD

[17:45] <audreyt> slurpies are part of longname already...

[17:45] <audreyt> and they come after nameds in zoning

[17:46] <audreyt> so it's a bit contradictory, considering ;;'s placement

[17:46] <TimToady> I think I was only relying on failure if there is no such parameter name

[17:46] <fglock> what does a long name look like? (or is it just a data structure)

[17:46] <audreyt> fglock: currently in Pugs, a longname is simply a Signature

[17:47] <audreyt> I was trying to determine if it's a restricted form of Signature

[17:47] <audreyt> or if the full form is sane enough to use

[17:47] * gaal praises Data.Graph.Inductive.Example

[17:48] <TimToady> I suppose we should aim for what the user expects, and then see where it needs optimizing

[17:48] <audreyt> k

[17:48] <audreyt> TimToady: so the earlier issue #1 (instance Monoid Signature)

[17:48] <TimToady> and the user will likely expect nameds to participate as if bound already

[17:48] <wolverian> gaal, are you finding inductive sane to work with? 

[17:48] <audreyt> in p6speak, that issue can be phreased: should p6 generate protos from several multis of no proto is present?

[17:49] <gaal> wolverian: haven't really started yet!

[17:49] <wolverian> okay :)

[17:49] <audreyt> that is, it seems to me that we need to somehow find a "common subset" that subsumes all candidates

[17:49] <wolverian> I found it hard, but that was probably because I didn't read the paper until later

[17:50] <TimToady> seems like it could lead to a false generalization if the user is planning to add more multis later via eval, which is officially within the lexical scope

[17:50] <audreyt> because that is the only way we can propagate common type/context/lvalueness contexts into the expressions

[17:50] <audreyt> consider:

[17:50] <TimToady> or eval has to recalculate the proto

[17:50] <audreyt> I was leaning toward recalculating the proto

[17:50] <TimToady> recalc of proto is okay for eval, I expect

[17:51] <audreyt> multi f (Int $x, Str $y) {}; multi f (Int $x, Moose $y) {}

[17:51] <audreyt> f(want(), want())

[17:51] <audreyt> or rather

[17:51] <TimToady> i know what you mena

[17:51] <TimToady> *mean

[17:51] <audreyt> yeah.

[17:52] <audreyt> so is it safe to say (that is, to test) that the first expr gets Int as want?

[17:52] <TimToady> you think the want type is the intersection of the proto and the actual (if known) context?

[17:52] <phiker> mugwump, ping

[17:52] <audreyt> uhm, what actual?

[17:52] <TimToady> er, right

[17:53] <audreyt> the want type is the bound-as-proto, and proto is calculated by intersection if not present

[17:53] <audreyt> reason this is needed is that anything evaluated as ITEM can't go back and be reevaluated as LIST, and vice versa

[17:53] <TimToady> in other words, can it be the actual context

[17:54] <TimToady> @foo ||= @bar

[17:54] <lambdabot> Maybe you meant: faq ft todo yow

[17:54] <audreyt> that's solved at macro level

[17:54] <audreyt> same as =

[17:54] <audreyt> more like

[17:54] <audreyt> multi f (Int, *@x) {}; multi f (Str, *@x) {}

[17:55] <pasteling> "gaal" at 192.115.25.249 pasted "tiny D.G.I.Q.DFS.topsort example" (30 lines, 1K) at http://sial.org/pbot/23334

[17:55] <audreyt> f("foo", =<>)

[17:55] <audreyt> and =<> would like to know it can read all lines

[17:55] <pasteling> "gaal" at 192.115.25.249 pasted "here is the definition of kin248 from that example" (4 lines, 236B) at http://sial.org/pbot/23335

[17:55] <audreyt> before it enters multi dispatch

[17:55] <TimToady> basically, can we partially dispatch on generated proto

[17:55] <audreyt> or rather, we had a 

[17:55] <Debolaz> Does pugs support installing into a custom prefix now btw?

[17:55] <audreyt> Capt Exp

[17:56] <audreyt> which is a capture of expressions

[17:56] <audreyt> we'd like to reduce it to Capt Val

[17:56] <audreyt> which is a capture of reduced values

[17:56] <audreyt> but we can't use any information on the actual multis

[17:56] <audreyt> because multi dispatch acts on values

[17:56] <audreyt> but I'd like to have some hint

[17:56] <audreyt> if proto is present, it's specced to be the hint

[17:56] <audreyt> but if it's not, spec is silent

[17:57] <audreyt> and I'd like it to dwim, namely find the unifying proto that all multis agree

[17:57] <TimToady> type inferencey

[17:57] <audreyt> and unify to Any, that is to say VAR() context with no type hints

[17:57] <TimToady> Int|Str

[17:57] <audreyt> if things disagree on context

[17:58] <audreyt> Int|Str is fine, as types can unify like that

[17:58] <audreyt> but ITEM/LIST is nonunifiable...

[17:58] <audreyt> Int|Any is just Any, too

[17:58] <audreyt> it is type inferency, but otherwise in the face of

[17:58] <audreyt> f(g()) 

[17:58] <audreyt> without a proto f and with only multi f

[17:59] <TimToady> so basically, can we relax/tighten the rule that says if you don't know, it's list context, if all participating multis show item?

[17:59] <TimToady> then you know it's item.

[17:59] <TimToady> I think we can do that.

[17:59] <audreyt> yes. also, if any of multis want rw, we want rw.

[17:59] <TimToady> seems fine to me, as long as we recalc in eval.

[17:59] <audreyt> since we can always get ITEM/LIST out of a lvalue

[17:59] <audreyt> but not the other way around

[17:59] <TimToady> (if necessary)

[18:00] <audreyt> yup

[18:00] <audreyt> yay.

[18:00] <wolverian> is the enum spec still in flux?

[18:00] <audreyt> Debolaz: custom prefix?

[18:00] <TimToady> seems dwtwy enough.

[18:01] <TimToady> *dwtmy

[18:01] <audreyt> ?eval sub prefix:<~Y~> ($x) { "$x will dwim, or at least do something..." }; ~Y~ "Perl 6"

[18:02] <evalbot_r15509> "Perl 6 will dwim, or at least do something..."

[18:02] <audreyt> Debolaz: do you mean that?

[18:02] <TimToady> wolverian: it's been pretty solid for a while, unless we get pushback from the darn implementors.  :)

[18:02] <TimToady> wolverian: did you want to tweak something?

[18:04] <TimToady> hmm, with the proto generation, enum collisions could just be considered 0-ary functions that generate a proto that can't match anything.

[18:05] <TimToady> then you automatically get the Ada semantics of failing if two modules export conflicting names to the same namespace. 

[18:05] <audreyt> but enums ne multis...

[18:05] *** mr_ank joined
[18:05] <TimToady> just thinking mechanism

[18:05] <audreyt> k

[18:06] <TimToady> enums are types and constant values at the same time

[18:06] * audreyt goes back implementing the preceding steps toward bogo, er topo, sort

[18:06] <TimToady> and constants can be represented by 0-ary subs

[18:06] <TimToady> as in "use constant"

[18:07] <TimToady> if they were represented with 0-ary multies we might get collision detection for freebies

[18:07] <TimToady> is all I'm saying

[18:07] <audreyt> ah.

[18:07] <audreyt> they share long names, though

[18:08] <TimToady> longname and shortname is the same for ()

[18:08] <TimToady> isn't it?

[18:08] <audreyt> true. but the spec currently says on colliding longname, later one masks

[18:08] <audreyt> S12:775

[18:08] <audreyt> this is done before proto autogen

[18:09] <audreyt> maybe a redefinition warning?

[18:09] <TimToady> that would be fine for enums too, I suppose

[18:09] <audreyt> *nod* then already plan to do that

[18:09] <TimToady> as you were

[18:09] <TimToady> back to backlogging...

[18:12] <gaal> audreyt: was the tiny demo useful or do you need more?

[18:12] <gaal> (see 2 nopastes above)

[18:13] <audreyt> gaal: I think I'm deep-in-other-parts enough that I'd like a complete implementation :)

[18:13] *** anatolyv left
[18:13] <gaal> of what? :)

[18:13] <audreyt> dispatch :: (Set a) -> (a -> a -> Ordering) -> Maybe a

[18:13] <audreyt> this :)

[18:13] <gaal> k :)

[18:14] <audreyt> thanks! :)

[18:14] <Debolaz> audreyt: Last time I tried to install to /usr/local (perl is in /usr/pkg), it installed a lot of stuff in /usr/pkg

[18:14] <audreyt> @djinn [a] -> (a -> a -> Ordering) -> Maybe a

[18:14] <lambdabot> f _ _ = Nothing

[18:14] <audreyt> ok... _very_ useful, thanks djinn

[18:14] <gaal> pwned

[18:15] <audreyt> Debolaz: perl Makefile.PL PREFIX= doesn't dtrt?

[18:15] <TimToady> audreyt: now I'm wondering if Scalar/Any is really Any/any, and := just autoboxes the [...] any into an Any.

[18:15] <audreyt> ok... let's see

[18:16] <audreyt> Scalar is something that can accept infix:<=>

[18:16] <Debolaz> audreyt: I'll update to the most recent version, try again, and put up the full output of the installation if it fails.

[18:16] <audreyt> Debolaz: k

[18:16] <audreyt> Debolaz: also maketicket on dev.pugscode.org lest we forget

[18:16] <audreyt> (you do have a commit bit right?)

[18:17] <audreyt> TimToady: and [...] can't quite be assigned to.

[18:17] <allbery_b> the pugs INSTALL document does say that PREFIX= does not DTRT

[18:17] <Debolaz> audreyt: Yes.

[18:17] <audreyt> my $x := [1,2,3]; $x = 3; # will fail

[18:17] <audreyt> but the binding succeeds because $x is unannotated

[18:17] <audreyt> however, I'd expect

[18:17] <allbery_b> "XXXX NOTE!!!!!!!! PREFIX doesn't actually work right now."

[18:18] <audreyt> my $x is Scalar := [1,2,3] # to fail right there

[18:18] <wolverian> TimToady, not really, just thinking about data Foo = Bar | Baz in perl6, thinking "enum" is a weird name for that.

[18:18] <audreyt> otoh,

[18:18] <audreyt> my $x is Any := [1,2,3] # ought to work

[18:18] <audreyt> (sometimes I wonder if we should just allow * in type context so people won't look for a ::Any, because there isn't.)

[18:18] <audreyt> i.e. there is no concrete ^Any that does anything meaningful

[18:18] <audreyt> rather it's only meaningful as a type

[18:19] <audreyt> in any case.

[18:19] <wolverian> then again, "data" is a pretty horrid name too

[18:19] <audreyt> my $x is Int := 1; $x := 2; # should work

[18:19] <audreyt> my $x is Scalar := 1; # should fail

[18:19] <audreyt> the question was

[18:20] <audreyt> my Any $x; # should it be ignored and treated the same as "my $x"?

[18:20] <audreyt> my intuition is yes

[18:20] <audreyt> but

[18:20] <audreyt> my Object $x; # means "my $x is Scalar of Object"

[18:20] <audreyt> so

[18:20] <audreyt> my Object $x; $x := [1,2,3] # can fail

[18:20] <audreyt> </working-assumptions>

[18:21] <TimToady> maybe just silently turn "my Any $x" into "my $x"?

[18:21] <audreyt> *nod*

[18:21] <audreyt> my Int $x; $x := 3; # should this fail or box?

[18:21] <audreyt> I guess box

[18:22] <TimToady> that's probably what they want

[18:22] <audreyt> my $x is Int := 0; # works

[18:22] <TimToady> though = would get them there

[18:22] <audreyt> my $x is Int := 0; $x = 123 # fails

[18:22] <audreyt> that much is given

[18:22] <fglock> random idea... - make different versions of mp6 with backend-optimized capabilities

[18:22] <audreyt> yeah. the question is to when to fail

[18:23] <audreyt> I think fail later is fin

[18:23] <audreyt> fine

[18:23] <audreyt> because, that is what happens in

[18:24] <audreyt> sub f (Int $x is rw) { ... }; f(3)

[18:24] <TimToady> I'd say it's one of those things where it's guaranteed to fail at runtime but okay to prognosticate at compile time when you know it will fail at runtime

[18:24] <audreyt> sure. but what if the user only read it?

[18:24] <audreyt> my Int $x; $x := 3; say $x + 3;

[18:25] <audreyt> kosher the?

[18:25] <audreyt> kosher then?

[18:25] <TimToady> why not?

[18:25] <audreyt> cool

[18:25] <TimToady> is the = that will fail

[18:25] <audreyt> my Int $x; $x := [6,7,8]; # fails? Coerce-Array-to-3?

[18:26] <audreyt> coercing would be rather horrible, yet that's what currently happens with the uncommitted pugs

[18:26] <TimToady> but we can know that in the lexical scope, probably, assuming some sub doesn't rebind it

[18:26] <audreyt> (because Int([6,7,8]) == 3)

[18:27] <TimToady> sure, I think we can just blame the user there

[18:27] <audreyt> ok...

[18:27] <audreyt> I guess :)

[18:27] * audreyt goes back blaming the user

[18:27] <TimToady> attempted coercion is how we see if the types are compatible, I guess.

[18:28] <audreyt> *nod*

[18:28] <ajs_> If coercing and boxing can be told apart, I would expect that only the latter would ever be allowed with :=. Coercing implies the creation of a temporary that may have little or no relation to the given data to which the user thinks they're binding.

[18:28] <audreyt> currently the coercion is performed in this order

[18:28] <audreyt> Int([6,7,8]) calls first Array.Int

[18:29] <audreyt> if not found, then &Int(Array)

[18:29] <audreyt> i.e. the thing being coerced gets the first say

[18:29] <audreyt> this is good enough in the simplistic view of the world

[18:29] <audreyt> thong I wonder how can it plan nicely with perl6:Int-1.0.0

[18:30] * [particle] *coughs*

[18:30] <audreyt> ajs_: yes, hence "horrible" above

[18:32] <ajs_> Is := really coercing though? Should it even touch the coercing logic? Or is ^foo.box an identity for all high-level types that gets invoked anywhere that boxing might be required?

[18:32] <TimToady> what's the problem with that?  Int can only be aliased to a single module longname in a given lexical scope

[18:33] <audreyt> TimToady: sure. but what if MyArray wants to define two methods

[18:33] *** offby1 joined
[18:33] <audreyt> one for Int-1.0 and one for Int-2.0?

[18:34] <audreyt> do we have a 

[18:34] <audreyt> sub "\0\0\0" { ... }

[18:34] <audreyt> form?

[18:34] <TimToady> that's part of why I was thinking about going to a module name more of the form Int:(:ver(1.0), :auth<JRANDOM>)

[18:34] * ajs_ goes back to work

[18:35] <TimToady> or something like that

[18:35] <audreyt> Int:<1.0 JRandom>

[18:35] <audreyt> etc

[18:35] <audreyt> but got your point

[18:35] <TimToady> would prefer extensible :foo inside

[18:35] <audreyt> but that means we extend that to var space too

[18:35] <TimToady> but Int:ver():auth() would maybe work

[18:36] <audreyt> can live with that

[18:36] <audreyt> hopefully canonicalize the part nameds with simple sort

[18:36] <TimToady> was wondering if we keep the Int-1.0 form as sugar

[18:36] <audreyt> so it can end up storing as a simple string

[18:36] <audreyt> and not worry about normalization

[18:36] <audreyt> noncomparable IDs are really bad :)

[18:36] <TimToady> *nod*

[18:36] *** explorer joined
[18:37] <TimToady> but basicaly it's a name mangling discipline

[18:37] <TimToady> with real delims on what will be mangled

[18:37] <audreyt> yup

[18:37] <audreyt> Int:ver<3>:ver<4>

[18:37] <audreyt> same as Int:ver<4>?

[18:38] <TimToady> Int:ver(v3|v4)?

[18:38] <audreyt> ask because of validity of infix:<+><-><*></>

[18:38] <TimToady> hmm

[18:38] <audreyt> would prefer it to just mean infix:</>

[18:39] <audreyt> infix:<+>:<->:<*>:</> really

[18:39] <TimToady> that sounds to me rather like P5's last-value-of-the-list-itis

[18:39] <audreyt> but same thing

[18:39] <audreyt> *nod*

[18:39] <audreyt> ok, so maybe not, but

[18:39] <audreyt> infix:<x>:<y>

[18:39] <audreyt> infix:<y>:<x>

[18:39] <audreyt> wondering if they mean the same thing as

[18:39] <TimToady> maybe no dups allowed for a given adverb

[18:39] <audreyt> infix:<x y>

[18:39] <audreyt> actualy

[18:40] <audreyt> best if they don't

[18:40] <TimToady> with nameds, dups come in as [,,]

[18:40] <audreyt> then we have a very good syntax

[18:40] <audreyt> circumfix:<(>:<)>

[18:40] <TimToady> same as :<( )>

[18:40] <TimToady> seems good

[18:40] <audreyt> cool

[18:41] <PerlJam> greetings #perl6

[18:41] <audreyt> so any infix with the second part becomes ternary?

[18:41] <audreyt> infix:<foo>:<bar>

[18:41] <audreyt> 3 foo bar 4

[18:42] <audreyt> er

[18:42] <audreyt> 3 foo 4 bar 5

[18:42] <TimToady> maybe--I just hardwired it to look for a properly precedented EXPR for ??!!

[18:42] <TimToady> but could probably generalize

[18:43] <audreyt> k

[18:43] <TimToady> PerlJam: howdy doody

[18:43] <audreyt> so when Pugs.Parser sees infix:<=>

[18:43] *** Psyche^ joined
[18:43] <audreyt> it should install infix:sym<=>

[18:43] <audreyt> in order for STD-hook to work?

[18:44] <TimToady> infix:<=> is the name of the sub, infix:sym<=> is the name of the rule that parses the sub

[18:44] <audreyt> the symness is determined by \w-ness of first char?

[18:44] <audreyt> okay.

[18:44] <TimToady> have to keep the two names straight

[18:44] <PerlJam> Do either of you have a good email address for chromatic?

[18:44] <TimToady> or STD can't talk about its own infix:<=>

[18:45] <audreyt> PerlJam: @wgz.org

[18:45] <PerlJam> audreyt: thanks.

[18:45] <audreyt> np :)

[18:45] <audreyt> TimToady: that's all for it now :) thanks for the explanation

[18:45] <TimToady> hmm, well, I was think of the non-symness determined by the \W-ness, but yes

[18:46] <audreyt> btw, implementatation of STATUS still on hold, but it's not of priority now :)

[18:46] <TimToady> in backlog?

[18:46] <audreyt> quite a while ago

[18:46] <TimToady> k

[18:46] <audreyt> the comment was %hash.:exists{3,4,5}

[18:46] <audreyt> can't be passed as .STATUS(exists => {3,4,5})

[18:46] <audreyt> for obvious reasons

[18:47] <audreyt> so spec is bogus

[18:47] <TimToady> direct will probably be okay

[18:47] <audreyt> k then

[18:47] <audreyt> so .:foo just translates to ~~ foo

[18:47] <audreyt> so .:foo just translates to ~~ :foo

[18:47] <audreyt> that's easy enough

[18:48] <TimToady> still need to work the inversion in there somehow

[18:48] <TimToady> so that the pattern controls the meaning

[18:49] <TimToady> well, will think about that later

[18:49] <TimToady> back to the backlog &

[18:49] <audreyt> :)

[18:50] *** Psyche^ is now known as Patterner

[18:53] <fglock> I wonder if it makes sense for pugs to link to perl-5.9.x, and then use the new regex engine in PCR

[18:54] <PerlJam> fglock: why not?  If you need bleeding edge ghc, why not up the perl requirement too  :)

[18:55] <fglock> yes

[18:55] <audreyt> fglock: or you can check $^V...

[18:55] <audreyt> and load two different backends

[18:58] *** jisom joined
[18:59] <TimToady> Is there any important reason why prototypes like Int should be considered true rather than false

[19:00] <audreyt> eval ?Int

[19:00] <TimToady> I would like index to always return a StrPos, but it would be nice if the bare StrPos was false

[19:00] <audreyt> ?eval ?Int

[19:00] <TimToady> it's currently true

[19:00] <evalbot_r15509> Bool::False

[19:00] <TimToady> odd

[19:00] <audreyt> a bare anything is already false

[19:00] <TimToady> was true here

[19:00] <audreyt> as well as undefined

[19:01] <TimToady> ?eval say true Int

[19:01] <evalbot_r15509> OUTPUT[â¤] Bool::True

[19:01] <TimToady> okay, misread the return

[19:01] <audreyt> :D

[19:01] <fglock> how about to return a Match object

[19:01] <TimToady> good. changing to always return StrPos, which can be false

[19:01] <audreyt> so StrPos of 0 is true

[19:01] <audreyt> ?

[19:01] <TimToady> yes

[19:01] <TimToady> but you should not be thinking of them as integers, grr!!!

[19:02] <audreyt> ok, that makes a lot more sense than 0/undef.

[19:02] <audreyt> sure.

[19:02] <TimToady> Match seems like overkill

[19:02] <PerlJam> I'd thought that bare "types" were our typed-undef constructors and should be false anyway

[19:03] <TimToady> as long as we get a good message if you use an undefined StrPos, I'm happy

[19:03] <audreyt> that is correct.

[19:03] <audreyt> undefined StrPos numifies to Error, I'd expect

[19:03] <audreyt> or rather, Failure.

[19:04] <audreyt> I would rather undefined Int numify to Failure too...

[19:04] <audreyt> but undefined Str stringify to "Str" ;)

[19:04] <gaal> audreyt: okay, the library topsort (of course) doesn't deal with cycles. it uses reverse postorder of dfs, as far as i can see simply giving wrong output if the graph has cycles

[19:04] <audreyt> gaal: ok...

[19:05] <gaal> so we need to implement something ourselves

[19:05] <audreyt> sad :/

[19:05] <gaal> that unifies items into an, uh, isoset to invent a term, as they are discovered to be cyclical

[19:06] <fglock> dmq: ping?

[19:07] <gaal> is big-O important here at all? how many sigs do we have in the candidate set?

[19:07] <svnbot6> r15510 | lwall++ | Just the definition of index flapping in the breeze...

[19:07] <audreyt> well, we do that all the time :)

[19:07] <audreyt> but we can memoize the decisions

[19:08] <gaal> sure, but it may be one of those things where complexity is dwarfed by concrete implementation

[19:08] <audreyt> sure, so maybe just brute force something

[19:08] <audreyt> I can think of plenty of O(n^2) algorithms...

[19:08] <gaal> not that I'm 100% clear on how to do that yet

[19:10] <fglock> audreyt: re plan to use ropes - how does this affects pugs using p5strings/regexes

[19:13] <audreyt> fglock: not at all

[19:13] <TimToady> the problem with going to Tahiti by constraints is that most people just want to say "Take me to Tahiti" most of the time.  It's the brandname as a shortcut for thought problem, basically, but there are times when named equivalence is just a heck of a lot easier than structural.

[19:15] <gaal> TimToady: but task a C programmer with writing a doubling function, and he'll just assume it's on ints, most of the time

[19:16] <gaal> because int is a bogus brandname for number

[19:17] <gaal> or, and I know you like this one, sleep(42.5)

[19:17] <TimToady> you'll notice I was shifting the blame to the user again. :)

[19:18] <ajs_> Dunno if this was said, but with respect to the "no dups of a given adverb" discussion, above, what about overriding an expanded capture? eg:

[19:18] <ajs_> foo(|($c), :x<1>) # my capture-expanding syntax might be wrong

[19:19] <ajs_> Does that fail if :x is given in $c?

[19:19] <TimToady> good question, at the moment I think it's defined to turn the x arg into a list of values

[19:19] <TimToady> but that's maybe not what was intended 

[19:19] <audreyt> actually, a hypothetical list

[19:19] <gaal> audreyt: this really looks O(n^more than 2) to me; consider that a cycle may in fact play together with other nodes in another cycle

[19:20] <audreyt> if @x is at the receiving end it gets the list

[19:20] <TimToady> oh, right, that's how we handled it

[19:20] <TimToady> nevermind

[19:20] <audreyt> otherwise it gets last

[19:20] <audreyt> S06:454

[19:20] <audreyt> <- was just implementing that very part :)

[19:20] <ajs_> coolness

[19:20] <PerlJam> sounds sane to me.

[19:20] <TimToady> and here I thought you were just smart.

[19:21] <audreyt> :)

[19:21] <TimToady> shifting the blame to the implementor...

[19:21] <PerlJam> It probably helps to have an eidetic memory  :)

[19:21] <TimToady> my wife has one of those, but it's singularly unhelpful with geographical problems unless she's been looking at a map.

[19:22] <audreyt> gaal: true. to run the comparisons is n^2

[19:22] <gaal> there's only so many maps...

[19:22] <audreyt> what, you mean there are only finite worlds?

[19:23] <gaal> there are certainly unmapped worlds...

[19:23] <PerlJam> audreyt: no, we've only generated a finite number of 2d representations.

[19:23] <audreyt> but I thought each world is a map of itself...

[19:23] <audreyt> ...never mind :)

[19:24] <TimToady> gaal: you're confusing the map function with the data territory

[19:24] * gaal greps for his map of puns

[19:24] <ajs_> domain and codomain confusion? Quite common

[19:25] *** CardinalNumber joined
[19:25] <TimToady> map is the shortname, but map:of<Italy>:in<1492> is a longer name...

[19:26] <gaal> that would make for some interesting detours in a trip...

[19:27] <gaal> old enough, and you don't get the Himalayas

[19:28] <gaal> (I bet your maps of Italy don't have the Himalayas...)

[19:29] <TimToady> just returns a MapPos that is false

[19:29] <audreyt> ok, rerunning smokes to see if we stil fail 99% of it...

[19:30] <gaal> audreyt: are all Sigs comparable to each other, necessarily?

[19:31] <gaal> and doesn't the comparison have to take place under context of the present capture?

[19:31] <audreyt> gaal: sure, we assume that f already closes over the capture

[19:31] <audreyt> which is why it's not (Ord Sig) => 

[19:31] <gaal> oh ok...

[19:32] <wolverian> where do the cycles come from?

[19:32] <gaal> outer space?

[19:33] <gaal> I remember spinclad and putter discussing zombies when figuring out multi dispatch

[19:33] <gaal> it was kinda scary!

[19:33] <audreyt> well, strictly speaking, there are ties, but I'm not sure there are cycles

[19:33] <wolverian> hm, that'd make for fun error messages... "Error: Too many zombies from outer space" 

[19:34] <audreyt> pugs> moose()

[19:34] <audreyt> *** No such subroutine: "&moose"

[19:34] <audreyt> pugs> kill()

[19:34] <audreyt> *** No compatible multi variant found: "&kill"

[19:34] <audreyt> yay, finally got that to work

[19:34] <audreyt> the second message can use some English help

[19:34] <gaal> you call that working? /me rushes to add a global &moose...

[19:35] <audreyt> lol

[19:35] <obra> if gaal gets &moose, I demand &squirrel

[19:35] * moritz wants &beaver ;)

[19:36] <audreyt> obra: I didn't know that you're fond of squirrels...

[19:36] <mugwump> phiker: hello

[19:36] <[particle]> i reserve &parrot

[19:36] <phiker> mugwump, I saw that there has been a recent update of cpan6.org

[19:36] <phiker> and the "contribute"-link was removed

[19:37] * kolibrie claims &hummingbird

[19:37] <phiker> so thereÂ´s some work going on again?

[19:37] <phiker> (and the sponsors list was added)

[19:37] <moritz> it seems they are finished, no need for more contributors ;-)

[19:38] <Debolaz> Ah crap, if I try to install pugs multiple times it'll ignore the files already installed and there's no uninstall so I have to remove all files manually from all the various directories in order to produce a usefull install paste..

[19:38] <gaal> but really then: what scenario is the spec conceiving in which there are cycles?

[19:39] <Debolaz> Well, at least it seems that /lib/perl6 is the sinner anyway, it installs that in the perl 5 prefix rather than the PREFIX that I specified.

[19:39] * allbery_b thinks doing make install on pugs is something of a bad idea until it's released

[19:39] <allbery_b> especially given that INSTALL documents $PREFIX as being b0rked

[19:40] <Debolaz> allbery_b: Yes, but Audrey asked if PREFIX did the right thing above. :-)

[19:40] <moritz> yay, build .debs ;)

[19:40] <obra> audreyt: moose + squirrel.

[19:40] <gaal> and is the ordering assured associative? specifically, is it guaranteed that if x EQ y, and z LT x, that also z LT y?

[19:40] <Debolaz> So I figured I'd give it a spin.

[19:40] <audreyt> obra: ah, got it now.

[19:40] <gaal> allbery_b: I think releasing pugs is a bad idea until somebody fixes the installer :)

[19:41] <mugwump> phiker, markov got some sponsorship for his idea.  I don't know what his plan for managing contributions is now

[19:41] <audreyt> gaal: no, not that.

[19:41] <phiker> so heÂ´ll continue with the xml-schema-stuff?

[19:41] <audreyt> gaal: otherwise we'll just use mergesort

[19:41] <mugwump> I haven't seen any change in direction on that front

[19:42] *** CardinalNumber is now known as ProperNoun

[19:42] <phiker> :(

[19:43] *** Endymion joined
[19:43] <gaal> then how do we correctly infer tie groups? do we have to start with comparing everybody to everybody else? (not very topsort any more)

[19:44] <audreyt> gaal: that was the naive algorithm I mentioned

[19:45] <audreyt> then we get n*(n-1)/2 Ordering and work with them

[19:46] <mugwump> he has written XML::Compile, which apparently does XML Schema validation in pure perl and lets you transform to YAML tidily

[19:46] <gaal> I still don't really get it; in a usual dag of this kind, you have a partial ordering, but if you assume no cycles then relations are associative so long as it's a connected graph. right?

[19:46] <audreyt> if we are clever, and know that in [a,b,c] we have a<>b and a>c, we don't need to calculate b,c

[19:47] <gaal> audreyt: earlier you said we aren't guaranteed associativity?

[19:49] <gaal> which is what I'm not getting. where can cycles show up in the concrete problem?

[19:51] *** thepler joined
[19:53] <audreyt> A:(Str, Int)   B:(Str, Odd)    C:(Int, Str)     with \(Odd, Int)     we have A<>C B>A B<>C

[19:53] <audreyt> if <> is =, then B>A, A=C should gte B>C

[19:53] <audreyt> but it's not =

[19:55] <audreyt> er sorry, \(Int, Odd).

[19:56] <audreyt> assuming Int :>: Odd and both are compatible (can be casted to) Str

[19:56] <fglock> is this supposed to work? pugs -e ' use v5; printf "version is v%vd\n", $^V; '

[19:56] <audreyt> actually, change Str to Object would work too.

[19:56] <fglock> pugs: Printf.printf: bad formatting char v

[19:57] <audreyt> worksforme

[19:57] <audreyt> older version of pugs?

[19:57] <fglock> yes

[19:57] <audreyt> ?eval use v5; printf "version is v%vd\n", $^V;

[19:57] <evalbot_r15509> 1.0

[19:57] <audreyt> hm.

[19:57] <audreyt> ?eval use v5; sprintf "version is v%vd\n", $^V;

[19:57] <gaal> uh, we allow v5 in evalbot?

[19:58] <evalbot_r15509> "version is v5.8.8\n"

[19:58] <audreyt> better.

[19:58] *** riffraff joined
[19:58] <gaal> not very safe..

[19:58] <audreyt> why not?

[19:58] <audreyt> ?eval use v5; `cat /etc/passwd`

[19:58] <evalbot_r15509> Error eval perl5: "sub { use ops (':default', 'binmode', 'entereval');my ($__evalbot_print) = @_;; `cat /etc/passwd`â¤â¤}"â¤*** 'quoted execution (``, qx)' trapped by operation mask at (eval 2) line 1.â¤â¤Error: Undefined subroutine &main:: called.â¤

[19:58] <audreyt> you see, perl5 also has a sandbox.

[19:59] <gaal> where's it implemented? Safe?

[19:59] <audreyt> ops

[19:59] <audreyt> same thing

[19:59] <gaal> cool

[19:59] <riffraff> hello

[19:59] <gaal> this is pretty new, isn't it?

[20:00] <audreyt> 5.00307

[20:00] <audreyt> not exactly very new

[20:00] <moritz> hi riffraff ;)

[20:00] <gaal> I... never heard of it :(

[20:00] <mugwump> predates that I think

[20:01] <audreyt> :)

[20:01] <audreyt> mugwump: corelist ops says that

[20:01] <mugwump> added in perl5.002beta1.2b1g

[20:01] <audreyt> Safe is 5.002, though

[20:01] *** dduncan joined
[20:01] <audreyt> so you may be right

[20:01] <audreyt> er, ok :)

[20:01] <audreyt> mugwump++

[20:02] <dduncan> are any of you familiar with a language named Lua?

[20:02] <audreyt> mugwump: you mean 5.002b1g, right?

[20:03] <audreyt> I was wondering if perl had three-part versions before... :)

[20:03] <dduncan> perl sort of had 3 part versions since 5.6.0 at least, if not 5.0.0

[20:03] <mugwump> yes, that's right.  the announcement in the patch was "This is patch.2b1g to perl5.002beta1."

[20:03] <dduncan> or before

[20:03] <mugwump> sure, the SUBVERSION

[20:04] <ayrnieu> man perlhist

[20:04] <ayrnieu> dduncan - yes, why?

[20:05] <dduncan> yesterday I was talking with someone in RL about my DBMS project and they strongly recommended I looked at the Lua language ... apparently a lot of design principles of what I was doing was in that language

[20:06] <dduncan> eg, a metamodel

[20:06] <dduncan> everything being tables, or something

[20:06] <dduncan> so now people have given me comparisons to both Ada and Lua

[20:06] <ayrnieu> Yes.  It's not really an obscure language :-)

[20:07] <[particle]> there's a lua impl on parrot

[20:07] <dduncan> while I had heard the name before, I didn't know anything else about it until yesterday

[20:08] <dduncan> it also occurred to me that there may be considerable overlap between what one can do with Lua's metamodel and Perl 6's, so I almost wondered if Lua was one of the inspirations for Perl 6 design

[20:08] <dduncan> or if there was some common influence on those lines

[20:09] <ayrnieu> particle - http://rt.perl.org/rt3/Ticket/Display.html?id=41726 :-)

[20:09] <lambdabot> Title: #41726: [PATCH] make lua fail more gracefully with an exception handler

[20:09] <dduncan> yes, I saw the comment about it being on Parrot

[20:10] <ayrnieu> dduncan - which comment do you mean?

[20:10] <dduncan> [particle]: there's a lua impl on parrot

[20:10] <dduncan> 2 minutes ago

[20:11] <audreyt> hm, only 1000 new failures so far

[20:11] <ayrnieu> ah, you know, not everything said in the channel is directed at you.  You don't have to wierdly acknowledge it like that..

[20:11] <ayrnieu> also, weirdly.

[20:11] <audreyt> I guess I'll have to fix them later. till tomorrow... &

[20:12] <gaal> good night, audreyt

[20:12] * gaal sleeps also

[20:12] <TimToady> night

[20:12] <dduncan> ayrnieu, well it seemed like it was, given the strong coincidence

[20:13] <dduncan> I mention Lua out of the blue, something not usually brought up here, one person says its on Parrot, and someone else shows a ticket that proves the point

[20:13] <ayrnieu> I'm sure that more careful reading can clear things up for you.

[20:13] <dduncan> but no matter, its history now

[20:14] <riffraff> sorry for the dumb question: for foo() -> $a,$b {} (wehre foo returns an array of pairs) should assign both $a and $b, right?

[20:15] <moritz> it should assign a pair to each I guess

[20:16] <riffraff> oh

[20:16] <riffraff> still doesn't work, cause $b comes out undefined

[20:16] <moritz> riffraff: but you should not rely on my p6-"knowledge"

[20:16] <moritz> riffraff: even number of items?

[20:16] <riffraff> well, I still appreciate your help :)

[20:17] <moritz> ?eval for (1 .. 3) -> my $a, $b { print "a: $a; b: $b " }

[20:17] <evalbot_r15509> OUTPUT[a: 1; b: 2 a: 3; b:  ] undef

[20:18] <riffraff> argh

[20:18] <moritz> funny, at home I get "undeclared variable "$b" in the last iteration

[20:19] <[particle]> as a warning?

[20:19] <dduncan> aren't they spelled $^a and $^b or some such now?

[20:19] <riffraff> moritz: same here

[20:19] <dduncan> the special sort variables

[20:20] <riffraff> the special ones don't work with for loops, it seem

[20:20] <moritz> dduncan: not when you explitly declare them with -> 

[20:20] <riffraff> at least on my box

[20:20] <dduncan> oh never mind, I see you declared them explicitly

[20:20] *** rashakil joined
[20:20] *** amnesiac joined
[20:23] *** Southen joined
[20:23] <fglock> is there a recent build of pugs for darwin?

[20:24] <riffraff> I'm running it on my macbook, if that counts

[20:24] <riffraff> I mean: it compiles :)

[20:24] <svnbot6> r15511 | gabriele++ | solved 99problems 36 and 37

[20:29] <fglock> is there a way to specify the perl5 path when building pugs? 

[20:30] <fglock> I'll try it with 'path/to/perl Makefile.PL'

[20:33] <fglock> mm - "... Detected uninstalled Perl.  Trying to continue."

[20:33] <moritz> os $obj.clone implented?

[20:36] *** dec joined
[20:37] <moritz> apparently not really..

[20:39] <fglock> moritz: $obj1 = $obj2 should clone by default

[20:40] <moritz> fglock: $a = $b.clone doesn't clone arrays

[20:41] <fglock> ?eval $a=[1..3];$b=$a;$b[1]=42;$a

[20:41] <evalbot_r15509> [1, 42, 3]

[20:41] <fglock> :(

[20:42] <moritz> or with classes:

[20:42] <moritz> ?eval class A { has @.a is rw }; my $b=A.new; $b.a[0]=3; my $c = $b.clone; $c.a[0]=2; say $b.a[0]

[20:42] <evalbot_r15509> OUTPUT[2â¤] Bool::True

[20:43] <moritz> so how do you deep clone arrays?

[20:43] <moritz> 2d-arrays, that is

[20:43] *** stevan_ joined
[20:45] <moritz> and secondly, are assignnemnts to 'self' allowed?

[20:45] <fglock> got it: ./pugs -e ' use v5; printf "version is v%vd\n", $^V; '  # version is v5.9.4

[20:46] <kolibrie> fglock: yay!

[20:46] <fglock> ?eval $a=[1..3];$b=@($a);$b[1]=42;$a

[20:46] <evalbot_r15509> [1, 42, 3]

[20:47] <moritz> well, my Sudoku solver will have to wait until cloning is implemented (and easy accessible) ;)

[20:47] <fglock> ?eval $a=[1..3];$b=[@($a)];$b[1]=42;$a

[20:48] <evalbot_r15509> [1, 2, 3]

[20:48] <fglock> that's perl5ish

[20:48] <moritz> that's very... intuitiv ;)

[20:49] *** ashleyb joined
[20:49] <broquaint> ?eval [1,2,3].clone()

[20:49] <evalbot_r15509> Error: Pattern match failure in do expression at src/Pugs/Prim.hs:1309:4-14

[20:50] <tene> ?eval @a = 1..3; @b = @a; @b[1]=42; @a

[20:50] <evalbot_r15509> [1, 2, 3]

[20:50] <moritz> tene++

[20:50] <tene> fglock, moritz: $array is a reference to an array.  the reference was being cloned, not the array.

[20:50] <moritz> tene: and know the same for objects that contain nested arrays ;)

[20:51] <tene> moritz: eh?

[20:52] <moritz> tene: well, I have a class that 'has' an array of arrays...

[20:52] <moritz> tene: and I'd like to be able to clone instances of that class

[20:52] <moritz> tene: deeply clone, that is

[20:52] *** the_dormant joined
[20:53] *** BooK joined
[20:54] *** awwaiid_ joined
[20:54] <tene> does Perl 6 have arrays of arrays instead of just arrays of references to arrays?

[20:55] <moritz> the latter, I guess

[20:55] <kolibrie> there are no references in Perl 6

[20:55] <moritz> I just use @a = [1, 2], [3, 4]

[20:55] <moritz> and access it via @a[0][1]

[20:56] <tene> ?eval @a = [1..3],[1..3],[1..3]

[20:56] <evalbot_r15509> [[1, 2, 3], [1, 2, 3], [1, 2, 3]]

[20:57] <[particle]> ?eval @a= [1..2],[1..2]; @b = @a; @b[1][1] = 42; @a

[20:57] <evalbot_r15509> [[1, 2], [1, 42]]

[20:58] <tene> There are always multidimensional arrays, which I don't think have been implemented yet and have had changing syntax recently.

[20:59] <Juerd> tene: What was formerly called "a reference to an array", is now called "an array", and behaves the same way

[20:59] <[particle]> looks like either we can't figure out deep clone, or it's broken

[21:00] <Juerd> tene: Depending on the sigil, @ or $, the array flattens in list context, or not.

[21:01] <tene> Juerd: 

[21:02] <tene> ?eval $a = 1..3; $b = $a; $b[0]=42; $a

[21:02] <evalbot_r15509> [42, 2, 3]

[21:02] <tene> ?eval @a= [1..2],[1..2]; @b = @a; @b[1][1] = 42; @a

[21:03] <evalbot_r15509> [[1, 2], [1, 42]]

[21:03] <tene> what is that behavior if not references to arrays?

[21:04] <Juerd> tene: As said, they behave like before.

[21:04] *** bernhard joined
[21:04] <tene> I don't understand what you're saying, then.

[21:05] *** awwaiid joined
[21:18] <rhr> out of curiosity, why was @array.join("...") changed to "...".join(@array)?  I liked the way things like @array.pick(3).join("x") read

[21:19] <tene> (1..3).join('x')

[21:19] <tene> ?eval (1..3).join('x')

[21:19] <evalbot_r15509> "1x2x3"

[21:19] <tene> ?eval (1..100).pick(3).join('x')

[21:19] <evalbot_r15509> "67x77x24"

[21:20] <tene> rhr: what exactly is the problem?

[21:20] <[particle]> ?eval "x".join(1..3)

[21:20] <evalbot_r15509> "1x2x3"

[21:20] <[particle]> rhr: it works either way

[21:20] <moritz> that's... magic

[21:20] <[particle]> it's christmas!

[21:21] <moritz> not quite ;)

[21:21] <rhr> see http://dev.pugscode.org/changeset/15500, it was just changed afaics

[21:21] <lambdabot> Title: Changeset 15500 - Pugs - Trac

[21:21] <rhr> in the spec anyway

[21:22] <[particle]> ?eval 'x'.join('y')

[21:22] <evalbot_r15509> "y"

[21:22] <[particle]> ?eval 'x'.join('')

[21:22] <evalbot_r15509> ""

[21:32] <Aankhen``> stevan_: Ping?

[21:36] *** larsen_ joined
[21:40] *** justatheory_ joined
[21:51] *** iblechbot joined
[21:53] <Gothmog__> ?eval ('x').join('y')

[21:53] <evalbot_r15509> "y"

[21:53] <Gothmog__> ?eval ['x'].join('y')

[21:53] <evalbot_r15509> "x"

[21:56] <TimToady>  ?eval ('x',).join('y')

[21:56] <TimToady> ?eval ('x',).join('y')

[21:56] <evalbot_r15509> "x"

[21:57] <TimToady> parens by themselve cannot turn a scalar into a list

[21:59] <TimToady> &

[21:59] <svnbot6> r15512 | lwall++ | Whack on the cat() a bit.

[22:01] <stevan_> Aankhen``: pong

[22:02] <Aankhen``> stevan_: I was about to ask you about Moose, but peregrin answered my questions. Thanks anyway. ^_^

[22:04] *** devogon joined
[22:06] *** Psyche^ joined
[22:07] *** koye joined
[22:08] <Gothmog__> So, () just forces precedence, and , creates a list.

[22:09] <mj41> hi, is there any way how to get forgotten svn passwd? username rootmj, thanks

[22:10] <tene> mj41: that's why you should allow keyloggers on your system, so all your passwords get published on the internet for easy retrieval.

[22:10] <stevan_> Aankhen``: irc.perl.org#moose is the best place to ask :)

[22:10] <Aankhen``> Yup, joined there at his behest. ;-)

[22:22] *** Psyche^ is now known as Patterner

[22:29] *** [particle] joined
[22:32] *** dduncan left
[22:38] *** gnuvince joined
[23:25] *** Limbic_Region joined
[23:33] *** justatheory joined
[23:57] *** forsaken joined
[23:58] *** forsaken joined
