[00:11] <wolverian> rindolf, I think it thought helsinki is in estonia. augh. :)

[00:11] <wolverian> (I fixed it. nice that you can move the pins.)

[00:12] <rindolf> wolverian: OK.

[00:13] <wolverian> I added myself too :)

[00:13] <rindolf> wolverian: thanks. :-)

[00:17] *** diotalevi left
[00:19] *** mako132_ joined
[00:21] <svnbot6> r15739 | lwall++ | Carry over @ vs @@ contextualization to zip and Z and map.

[00:21] <svnbot6> r15739 | lwall++ | Delete old each function.

[00:21] <svnbot6> r15739 | lwall++ | Fix old Lazy declarations, they're just Lists.

[00:21] <svnbot6> r15739 | lwall++ | Remove hateful bogus package names on multis.

[00:21] <svnbot6> r15739 | lwall++ | (Please use standard declarations as they would appear in situ.)

[00:21] <svnbot6> r15739 | lwall++ | Multis should generally just come from the natural class of the invocant.

[00:21] <svnbot6> r15739 | lwall++ | If there is no natural class, the section's default module should be assumed.

[00:21] <svnbot6> r15739 | lwall++ | If the section doesn't have a default module, it needs one.  (todo)

[00:21] <svnbot6> r15739 | lwall++ | If a section has more than one default module, it needs to be split. (todo)

[00:21] <svnbot6> r15739 | lwall++ | Avoid non-OO classification.  I know what a Proc is, but what's a Conc?

[00:21] <svnbot6> r15739 | lwall++ | Control flow should generally be associated with Context object.

[00:21] <svnbot6> r15739 | lwall++ | Normalized normalization methods.

[00:21] <svnbot6> r15739 | lwall++ | Random C<> cleanup, still incomplete.

[00:21] <svnbot6> r15739 | lwall++ | More clarification of StrPos stuff.

[00:21] <svnbot6> r15739 | lwall++ | Various other things I forget now.

[00:22] <wolverian> removal of Lazy looks nice, yay.

[00:25] *** Psyche^ joined
[00:25] *** Psyche^ is now known as Patterner

[00:57] *** sunnavy joined
[01:04] *** Southen_ joined
[01:41] *** ozo_ joined
[01:42] *** ozo_ left
[01:45] *** ozo_ joined
[01:57] <Aankhen``> pugs++ # I know it took a while, and it's not perfect, but the Perl 5 integration seems to Just Work most of the time.

[02:01] *** mjk joined
[02:06] *** Limbic_Region joined
[02:12] *** jrockway joined
[02:48] *** yhsuan joined
[02:56] *** [particle] joined
[03:03] *** fletchnj joined
[03:06] *** fletchnj left
[03:52] *** justatheory joined
[04:08] *** mkirank joined
[04:14] <mkirank> ?eval say "hello"

[04:14] <evalbot_r15739> OUTPUT[hello␤] Bool::True

[04:15] <mkirank> ?eval my @a = (1,2,3);my @b=(10,11,12);say @a+@b;

[04:15] <evalbot_r15739> OUTPUT[6␤] Bool::True

[04:22] <Aankhen``> ?eval (1, 2, 3) »+« (10, 11, 12)

[04:22] <evalbot_r15739> (11, 13, 15)

[04:22] <Aankhen``> ?eval <1 2 3> »+« <10 11 12>

[04:22] <evalbot_r15739> (11.0, 13.0, 15.0)

[04:27] *** RHainsworth joined
[04:27] <mkirank> I'm getting the error 

[04:27] <mkirank> ghc.exe: unknown package: base-1.0 (dependency of pugs-fps-0.7)

[04:27] <mkirank> when I try to build pugs on  windows ... 

[04:27] *** RHainsworth left
[04:31] <diakopter> ?eval my @b = <z a b d e>; say @b.sort;

[04:31] <evalbot_r15739> OUTPUT[abdez␤] Bool::True

[04:34] <diakopter> ?eval say <q w e r t y>.sort\   .()

[04:34] <evalbot_r15739> Error: Cannot cast from VList [VStr "e",VStr "q",VStr "r",VStr "t",VStr "w",VStr "y"] to Pugs.AST.Internals.VCode (VCode)

[04:35] <diakopter> ?eval say <q w e r t y>.sort()

[04:35] <evalbot_r15739> OUTPUT[eqrtwy␤] Bool::True

[04:35] <diakopter> ?eval say <q w e r t y>.sort.()

[04:35] <evalbot_r15739> Error: Cannot cast from VList [VStr "e",VStr "q",VStr "r",VStr "t",VStr "w",VStr "y"] to Pugs.AST.Internals.VCode (VCode)

[04:37] <diakopter> ?eval say <q w e r t y>.sort.();

[04:37] <evalbot_r15739> Error: Cannot cast from VList [VStr "e",VStr "q",VStr "r",VStr "t",VStr "w",VStr "y"] to Pugs.AST.Internals.VCode (VCode)

[04:40] <offby1> bummer

[04:40] <offby1> ?eval say <<q w e r t y>>.sort.();

[04:40] <evalbot_r15739> Error: Cannot cast from VList [VStr "e",VStr "q",VStr "r",VStr "t",VStr "w",VStr "y"] to Pugs.AST.Internals.VCode (VCode)

[04:43] *** dmpk2k joined
[04:44] <diakopter> ?eval .perl

[04:44] <evalbot_r15739> "\\undef"

[04:45] <diakopter> ?eval perl

[04:45] *** justatheory joined
[04:45] <evalbot_r15739> Error: ␤Unexpected end of input

[04:45] <diakopter> heh

[04:46] <TimToady> sort.() should sort itself out once we switch to STD.pm for parsing.

[04:47] <offby1> ooh, STD brings back unpleasant memories of junior-high health class.

[04:49] <diakopter> syntactically transliterated deficiencies?

[04:51] <diakopter> ?eval say Object.new.DESTROYALL.perl;

[04:51] <evalbot_r15739> OUTPUT[undef␤] Bool::True

[04:52] <diakopter> ?eval say Object.new.DESTROYALL;

[04:52] <evalbot_r15739> OUTPUT[␤] Bool::True

[04:57] <TimToady> darn it, now you've gone and destroyed everything.  we'll have to start all over.

[04:58] <diakopter> ?eval .clone.say;

[04:58] <evalbot_r15739> Error: Pattern match failure in do expression at src/Pugs/Prim.hs:1313:4-14

[04:59] <diakopter> ?eval .DESTROYALL;

[04:59] <evalbot_r15739> undef

[04:59] <TimToady> see, it's all gone :(

[04:59] <diakopter> that's three variants of undef -  "\\undef", OUTPUT[undef␤] Bool::True, and undef

[05:00] <spinclad> ?eval Object.new.DESTROYALL.perl;

[05:00] <evalbot_r15739> "undef"

[05:00] <diakopter> there's another

[05:01] <spinclad> the OUTPUT form was from when you said() it

[05:01] <spinclad> so still three variants i think

[05:02] <spinclad> ?eval perl()

[05:02] <evalbot_r15739> Error: No compatible multi variant found: &perl

[05:02] <TimToady> well .perl is always going to return a string, not an undef

[05:02] <TimToady> undef.perl isn't undefined.  :)

[05:03] <spinclad> a different string than DESTROYALL.perl gave though, that's a bit odd

[05:03] *** mkirank left
[05:03] <spinclad> so down to two variants

[05:04] <TimToady> ?eval ().perl

[05:04] <evalbot_r15739> "()"

[05:05] <TimToady> ?eval undef.perl

[05:05] <evalbot_r15739> "undef"

[05:05] <spinclad> ?eval $_.perl

[05:05] <evalbot_r15739> "\\undef"

[05:05] <spinclad> :)

[05:05] <spinclad> what is that?

[05:05] <TimToady> a Scalar containing undef, perhaps

[05:06] <TimToady> my $x; $x.perl

[05:06] <spinclad> ?eval $_

[05:06] <evalbot_r15739> \undef

[05:06] <spinclad> yeah, that

[05:06] <spinclad> ?eval my $x; $x.perl

[05:06] <evalbot_r15739> "\\undef"

[05:06] <diakopter> ?eval 'say "foo";'.eval.perl.eval;

[05:07] <evalbot_r15739> OUTPUT[foo␤] Bool::True

[05:07] <diakopter> hrm

[05:07] <TimToady> val 'say "foo";'.eval.perl

[05:07] <TimToady> ?eval 'say "foo";'.eval.perl

[05:07] <evalbot_r15739> OUTPUT[foo␤] "Bool::True"

[05:08] <TimToady> say is returning True

[05:09] <diakopter> ?eval "'say \"foo\";'.eval.perl".eval;

[05:09] <evalbot_r15739> OUTPUT[foo␤] "Bool::True"

[05:12] <diakopter> ?eval $::({return 1;})

[05:12] <evalbot_r15739> pugs: Internal error:␤    Invalid sigil "$<"␤Please file a bug report.

[05:12] * diakopter tells evalbot to file a bug report herself.

[05:14] <TimToady> ?eval ~{return 1;}

[05:14] <evalbot_r15739> "<SubBlock(<anon>)>"

[05:14] <TimToady> there's your <

[05:16] <TimToady> ?eval $::('*PID')

[05:16] <evalbot_r15739> \undef

[05:16] <TimToady> ?eval $::('*OS')

[05:16] <evalbot_r15739> \undef

[05:17] <diakopter> ?eval <>.({1;})

[05:17] <evalbot_r15739> Error: Cannot cast from VList [] to Pugs.AST.Internals.VCode (VCode)

[05:17] <TimToady> translation: I haven't the foggiest idea how to "call" a list.

[05:17] *** Achilles14 joined
[05:18] *** Achilles14 left
[05:19] <diakopter> do/will the perl6 specs define anything about such error messages?

[05:19] <Aankhen``> I'm not familiar with Haskell, so… what would the API look like for the unified events & threads model in Perl 6?

[05:20] <TimToady> to the event handler it looks like sending information to a thread scheduler queue, kinda sort.  From the thread viewpoint it looks like unblocking.

[05:20] *** jisom joined
[05:21] <Aankhen``> Ah.

[05:21] <Aankhen``> I think I need to do some more reading. :-D

[05:21] <diakopter> ?eval ().<a b>.perl.say;

[05:21] <evalbot_r15739> OUTPUT[[undef, undef]␤] Bool::True

[05:22] <diakopter> I have no idea what happened there

[05:22] <TimToady> you more or less said "make me an empty list", subscript it by .{'a','b'} and tell me what you find.

[05:22] <TimToady> which is nothing, twice.

[05:23] <TimToady> nothing twice in Perl is [undef, undef]

[05:24] * offby1 sees TimToady's nothing twice, and raises him ... nothing.

[05:24] <TimToady> double or nothing...er, double *and* nothing.

[05:26] <diakopter> ?eval 'please ignore the gibberish'; |[{(|)}]|.say;

[05:26] <evalbot_r15739> Error: ␤Unexpected "[{(|)}]|."

[05:26] <diakopter> hmm; it worked on run.pugscode.org

[05:27] <TimToady> what did it say?

[05:28] <diakopter> (not that).  it just gave another prompt.  no output line.

[05:28] <TimToady> should parse as |([...]) | .say, I think

[05:28] <TimToady> though unary | without an arg is probably an error

[05:28] <TimToady> inside (|)

[05:29] <TimToady> ?eval 'please ignore the gibberish'; |[{(|[])}]|.say

[05:29] <evalbot_r15739> OUTPUT[␤] (Bool::True | {Syn "block" {Syn "|" {Syn "\\[]" {Syn "," {}}}}})

[05:29] <TimToady> yeah, the inner | needs an arg

[05:30] *** ludwig joined
[05:31] <TimToady> ?eval 'please ignore the gibberish'; |[{(<|>)}]|.say

[05:31] <evalbot_r15739> OUTPUT[␤] (Bool::True | {Syn "block" {"|"}})

[05:33] <diakopter> ?eval <>.clone; .say;

[05:33] <evalbot_r15739> Error: Pattern match failure in do expression at src/Pugs/Prim.hs:1313:4-14

[05:33] *** ludwig is now known as ludwig-

[05:33] <TimToady> I don't believe clone is implemented

[05:34] <audreyt> only for userdef objs

[05:34] <lambdabot> audreyt: You have 5 new messages. '/msg lambdabot @messages' to read them.

[05:34] <audreyt> just started to impl for builtins; once the pad branch is merged back it'll be there

[05:35] <audreyt> TimToady: btw, I hope this is sane

[05:35] <diakopter> audreyt: check your @messages :P

[05:35] <audreyt> sub f { my $x = 123 }; BEGIN{ f() }

[05:35] <audreyt> say f(); # 123

[05:36] <audreyt> or rather

[05:37] <audreyt> sub f ($compiling) { my $x; $x = 123 if $compiling; say $x }; BEGIN {f(1)}

[05:37] <audreyt> f(0); # still say 123

[05:37] <audreyt> f(0); # undef now

[05:37] <audreyt> basically the runtime sees the _last_ pad of compile time

[05:38] <audreyt> in perl5 currently compile-time calls to subs with half-formed compile-time pads will clear the freshness flag prematurely

[05:38] <audreyt> but there's no real reason to do that in p6, especially since we implicitly reclone inner functions upon entry

[05:39] <audreyt> sub f ($x) { sub g { $x } };

[05:39] <audreyt> g(); # undef

[05:39] <audreyt> my $g1 = f(1);

[05:39] <audreyt> g(); # 1

[05:39] <audreyt> $g1(); 3 1

[05:39] <audreyt> er, s/3/#/

[05:39] <audreyt> my $g2 = f(2);

[05:40] <audreyt> g(); # 2;

[05:40] <audreyt> $g2(); # 2

[05:40] <audreyt> $g1(); # 1

[05:40] <audreyt> etc. so the "will not stay shared" problem is gone.

[05:40] <audreyt> it's implemented that way now; again just sanity check :)

[05:41] <TimToady> it does seem a little odd not to get undef on first f(0), but it's mostly because you've conditionalized on $compiling

[05:41] <audreyt> diakopter: got it :)

[05:41] <audreyt> right.

[05:41] <TimToady> doesn't seem like a big problem to me.

[05:41] <audreyt> ok, thanks.

[05:50] <diakopter> ?eval .new .= ..;

[05:50] <evalbot_r15739> Error: the right-hand-side of .= must be a function application

[05:50] <geoffb> How do you say AUTOLOAD in P6, and is it implemented in Pugs?

[05:52] <TimToady> see S10:84

[05:52] <TimToady> and given there's no tests for it, I doubt it.

[05:53] <audreyt> so write some :)

[05:53] <geoffb> I still have to figure out why I can't commit my previous tests ... sigh.

[05:55] <audreyt> TimToady: any reason why CANDO uses

[05:55] <audreyt> Item, $name

[05:55] <audreyt> rather than just having the name containing '$' ?

[05:55] <audreyt> faster dispatch based on sigils?

[05:56] <diakopter> ?eval my $exec = 'methodName'; .new.$exec; .say;

[05:56] <evalbot_r15739> OUTPUT[␤] Bool::True

[05:57] <TimToady> I think more for extensibility.

[05:58] <TimToady> and showing off smartmatching of type parameters.  :)

[05:58] <TimToady> where the type is being treated as a value parameter match

[05:59] <TimToady> It's possible it's redundant in the usual case.

[05:59] <TimToady> but also you could ask for weird containers there.

[06:00] <audreyt> but then

[06:00] <audreyt> SomeCanDoPkg::<$foo>

[06:00] <audreyt> how does it know that it must ask for Item?

[06:00] <audreyt> hardcoded enum-type table?

[06:00] <audreyt> or is that sort of lookup not handled by CANDO?

[06:01] <TimToady> I think CANDO is assuming that someone has already figured out the desired container type

[06:01] <audreyt> what are the *%args for non-Code CANDO?

[06:01] <TimToady> and $name is just an arbitrary string to it

[06:02] <TimToady> I dunno, traits maybe...

[06:02] <audreyt> but Code also has traits...

[06:04] <audreyt> also the semi should be comma before *%args

[06:04] *** devogon joined
[06:04] <diakopter> ?eval perl.die;

[06:05] <evalbot_r15739> Error: Died

[06:05] <TimToady> I suspect *%args is mostly just a placeholder for things we haven't thought of yet.

[06:05] <audreyt> that's fine

[06:05] <audreyt> but we don't multi dispatch on slurpy-nameds anyway

[06:06] <audreyt> so the semi is really comma :)

[06:07] <diakopter> ?eval .DESTROYALL; .WHAT;

[06:07] <evalbot_r15739> ::Scalar

[06:08] <audreyt> still fuzzy on how to implement the return type dispatch other than hardcode a sigil-enum

[06:08] <audreyt> but otherwise CANDO seems implementable

[06:08] <TimToady> how do you dispatch to a value like 42?

[06:09] <TimToady> a proto-type is just another value that happens not to be defined. :)

[06:09] <audreyt> ~~ surely?

[06:09] <audreyt> multi f (0) { 1 }

[06:09] <audreyt> multi f ($x) { 123 }

[06:10] <audreyt> dunno. may not be entirely sane, that syntax

[06:10] <TimToady> multi f (Squirrel) { "Moose" }

[06:10] <audreyt> sure, but the question here is that

[06:10] <audreyt> my @x := SomeCanDoPkg::<$foo>

[06:10] <audreyt> does it dispatch with CANDO and Array then '$foo'?

[06:11] <audreyt> and with assignment we really don't know the expected type

[06:11] <audreyt> my $x = SomeCanDoPkg::<&bar>

[06:11] <audreyt> how do we know it must dispatch with Code, other than intuit from sigil-enum-map?

[06:11] <TimToady> I think in the usual case we just intuit from the sigil

[06:12] <audreyt> and is there a reason why in the unusual case the CANDO can't simply check &want?

[06:12] <audreyt> that way we save a parameter and avoid contravariance bug

[06:12] <audreyt> (where a return type is matched in reverse narrowness)

[06:12] <TimToady> I don't think it has anything to do with want, really.

[06:13] <audreyt> ok.

[06:13] <audreyt> so those type names really are hardcoded

[06:13] <audreyt> cando, then.

[06:13] *** BooK_ joined
[06:14] <audreyt> so unlike AUTOLOAD which does something immediately in p5

[06:14] <audreyt> CANDO must return another closure

[06:14] *** prly_ joined
[06:15] <TimToady> CANDO is asking "do you choose to declare this?"

[06:15] <audreyt> multi method CANDO (Code, $_) { when '&meth' { return method { ...meth body... } } }

[06:15] <audreyt> something like that?

[06:16] <TimToady> yeah, something like that.

[06:17] <audreyt> consequence is that

[06:17] <audreyt> class AnotherPkg is SomeCanDoPkg { ... }

[06:17] <audreyt> then not only AnotherPkg.meth is dyngenned

[06:18] <audreyt> but AnotherPkg::<&sym> is as well

[06:18] <audreyt> basically the p5 "inheriting autoload for non-method" thing

[06:19] <audreyt> not really saying there's anything terribly broken with that

[06:19] <TimToady> the non-method multi matches on package as first arg

[06:19] <audreyt> but it matches using mmd semantics

[06:19] <audreyt> with usual subtyping-fits rule

[06:19] <audreyt> so AnotherPkg does not define CANDO, it still matches the base class's multi cnaod

[06:20] <TimToady> just saying you could write it more generically than a single package

[06:20] <audreyt> yeah.

[06:20] <audreyt> and if you really want to not let derived class use it

[06:20] <audreyt> then declare it as submethod

[06:20] <audreyt> I guess. so that's fine

[06:21] <TimToady> and the intent is that CANDO gets to choose whether to create the actual object eagerly or lazily.

[06:22] <TimToady> in the latter case making use of AUTODEF, presumably.

[06:25] <audreyt> S06:1317

[06:25] <audreyt> the backslash there is... doing what again?

[06:26] <diakopter> ?eval hash moo=>boo=>loo=>'goo'

[06:26] <evalbot_r15739> {("moo" => ("boo" => ("loo" => "goo"))),}

[06:28] <audreyt> TimToady: also, an optimization bug.

[06:28] <geoffb> ?eval sub stub { undef } our &glBegin := &stub; glBegin();

[06:28] <audreyt> during codegen for subs with known param

[06:29] <audreyt> it's helpful to unroll the incoming Capture into params and throw the Capture structure away

[06:29] <audreyt> especially when there are slurpies

[06:29] <evalbot_r15739> undef

[06:29] <audreyt> however the possibility of .nextsame and .callsame

[06:29] <audreyt> means we need to save a snapshot of the incoming Capture somewhere

[06:29] <geoffb> ?eval sub stub { undef } sub stub_all {our &glBegin := &stub; } BEGIN {stub_all();} glBegin();

[06:29] <audreyt> just in case the "same" form is called

[06:29] <evalbot_r15739> undef

[06:30] <geoffb> ?eval sub stub { undef } sub stub_all {my $eval = "our \&glBegin := \&stub;\n"; eval $eval } BEGIN {stub_all();} glBegin();

[06:30] <evalbot_r15739> undef

[06:30] <audreyt> in JavaScript the same problem is there but

[06:30] <geoffb> ?eval sub stub { 'foo' } sub stub_all {my $eval = "our \&glBegin := \&stub;\n"; eval $eval } BEGIN {stub_all();} glBegin();

[06:30] <evalbot_r15739> "foo"

[06:30] <audreyt> an optimizing compiler can check for presence of the "arguments" call in the function body

[06:31] <audreyt> and if it's not there, don't save the original arguments

[06:31] <audreyt> but .nextsame is highly magical; it cannot be a normal method 

[06:31] *** jisom joined
[06:31] <audreyt> because that implies seeing caller's args contextually

[06:32] <geoffb> ?eval sub stub { 'foo' } sub stub_all {my @symbols = < glBegin>; my $eval = ''; for @symbols -> $symbol {$eval ~= "our \&$symbol := \&stub;\n"; } eval $eval } BEGIN {stub_all();} glBegin();

[06:32] <evalbot_r15739> "foo"

[06:32] <audreyt> so what is it really? a thought is that it's really a postfix-method-macro thing that expands to

[06:32] <audreyt> .nextwith(|$|)

[06:32] <geoffb> hmmm, must be just my old build ... 

[06:32] <audreyt> and we check visibility of $|

[06:32] * geoffb waits impatiently for GHC to finish compiling

[06:32] <audreyt> if it's in scope then we save away the incoming arg

[06:32] <audreyt> as if the use sayd

[06:33] <audreyt> sub f (|$|:( orig signature here )) { ... }

[06:33] <audreyt> but I wonder if it's a sane treatment, or if I mistook nextsame's semantics

[06:33] <geoffb> ?eval sub stub { 'foo' } sub stub_all {my @symbols = < glBegin>; my $eval = ''; for @symbols -> $symbol {$eval ~= "our \&$symbol := \&stub;\n"; } eval $eval } BEGIN {stub_all();} glBegin('blurtz', 'flaffle', 5);

[06:34] <audreyt> </question>

[06:34] <evalbot_r15739> "foo"

[06:35] <TimToady> hmm, well, any wrappable routine has to allow that the new wrapper is going to call it even if the old "core" didn't, so compile-time analysis doesn't help much there...

[06:35] <audreyt> but it's the wrapper saving its args

[06:35] <audreyt> not the inner wrappable

[06:36] <audreyt> so compile-time analysis of that wrapper is still viable

[06:36] <TimToady> but if the original call site threw away info that the wrapper wants...

[06:36] <audreyt> I think we can't touch callsite

[06:37] <audreyt> the only optimization we can do is to throw away the incoming Capture object after binding is done with it

[06:37] <audreyt> sub f ($x is copy) { ... }

[06:37] <audreyt> or even in the usual (sub f ($x) {...}) case

[06:37] <audreyt> we can throw away the info after binding to x

[06:37] <audreyt> about whether we were called as 

[06:38] <audreyt> (x => 1)

[06:38] <audreyt> or 

[06:38] <audreyt> (1)

[06:38] <audreyt> or

[06:38] <audreyt> (x => 1, x => 2)

[06:38] <TimToady> yes, and likewise for protos

[06:38] <audreyt> which is good for heap space with long call chains

[06:38] <TimToady> the main point of protos was to enable that rewrite.

[06:38] <audreyt> because all the callers will have thrown away their $|

[06:39] <audreyt> but the presence of .nextsame somehow assumes you can ask CALLER::<$|>

[06:39] <audreyt> which seems to me defeats all this

[06:39] <audreyt> hence the question about possible other interpretation of .nextsame

[06:40] <audreyt> .callsame is worth because it doesn't even erase the stack

[06:40] <audreyt> *worse

[06:40] <TimToady> if the data is in some format on some stack, all we need is for .nextsame to point the wrapped function at the same (presumably immutable) value lists

[06:40] <audreyt> true, but what about callsame?

[06:40] <TimToady> as long as they agree on the format, doesn't have to be a Capture

[06:41] <geoffb> ?eval sub stub { 'foo' } sub stub_all {my @symbols = < glBegin>; my $eval = ''; for @symbols -> $symbol {$eval ~= "our \&$symbol := \&stub;\n"; } eval $eval } BEGIN {stub_all();} glBegin('blurtz', 'flaffle', 5); "furball"

[06:41] <audreyt> but they don't have to agree on the format...

[06:41] <evalbot_r15739> "furball"

[06:41] <TimToady> and maybe if the wrapper tries to pull it out as a Capture, it's just

[06:41] <TimToady> "best effort"

[06:41] <TimToady> "here's a Capture that could have produced these arguments..."

[06:42] <audreyt> sub f ($x) { $x := 123; &g.callsame }

[06:42] <audreyt> does the "best effort" means &g gets 123?

[06:42] <audreyt> that sounds very fishy...

[06:42] <TimToady> I don't think so.

[06:43] <TimToady> if you want to monkey with the arguments you should use callwith instead.

[06:43] <audreyt> ok, so the incoming capture is still preserved somewhere other than the pad

[06:43] <audreyt> otherwise there's nowhere that callsame can get the original $x from

[06:44] <TimToady> we can just say that $x := 123 is erroneous.

[06:44] <audreyt> and that somewhere is contextual

[06:44] <audreyt> even though $x is not

[06:45] <audreyt> otherwise wouldn't allow definition of callsame in user-code

[06:45] <audreyt> class MyCode; method callsame { ... how? ... }

[06:46] <geoffb> ?eval sub stub { 'foo' } sub stub_all {my @symbols = < glBegin>; my $eval = ''; for @symbols -> $symbol {$eval ~= "our \&$symbol := \&stub;\n"; } eval $eval } BEGIN {stub_all();} method foo {glBegin('blurtz', 'flaffle', 5); } "furball"

[06:46] <evalbot_r15739> "furball"

[06:46] <TimToady> .HOW.callsame

[06:46] <audreyt> :)

[06:46] <audreyt> method callsame { .(|(caller.arguments)) }

[06:46] <audreyt> method callsame { .nextsame(|(caller.arguments)) }

[06:47] <TimToady> $.nextsame?

[06:47] <audreyt> er, yes.

[06:47] <audreyt> self.nextsame, actually

[06:48] <audreyt> since it could've been called in a slurpy list context

[06:48] <audreyt> ok, so I'll not worry about codegen or optimization yet and simply provides .arguments field

[06:49] <TimToady> It's quite possible that we want to reserve is as a HOWish not-quite-a-method thing

[06:49] <TimToady> and we can do that if it helps optimization later.  Not every primitive has to be user overridable.

[06:49] *** lisppaste3 joined
[06:49] <TimToady> not without we also give them a very sharp circularity saw...

[06:49] <audreyt> what, you mean we are not lisp?

[06:50] <audreyt> oh wait. you meant "not every primitive has to be user overridable _during runtime_."

[06:50] <TimToady> Perl Evaluator Runs Lisp

[06:50] <audreyt> sure :)

[06:51] <audreyt> overriding primitives is a compile-time BEGIN-block macro-writer business :)

[06:51] <TimToady> we have to give the optimizer some rope to shoot the user in the foot with.

[06:51] <audreyt> mm metaphor mixins

[06:51] <TimToady> Paradigm Exchange Research Laboratory

[06:51] <TimToady> People Experience Renewed Love

[06:52] <TimToady> Please Everyone, Right & Left

[06:52] * geoffb imagines one of those prison weapons, like the paper mache crossbow that fires slivers of lunch tray

[06:52] <TimToady> Persistent Energy Reinvents Life

[06:52] <TimToady> Perennially Emergent Reinvention Language

[06:52] <TimToady> Power Enterprise-Related Labor

[06:53] <TimToady> Perform Excellent Refactoring Liberation

[06:53] <TimToady> Pele Energy Releases Lava

[06:53] <geoffb> Portal Encouraging Reality Liberation

[06:53] <TimToady> Please Enhance Real Life

[06:53] <TimToady> that's enough for today. :)

[06:54] <diakopter> Pigeonholing Emitter Reaches Lower

[06:54] <geoffb> Pasta Enjoyment Requires Lactase

[06:54] <geoffb> (since I tend to use much cheese ...)

[06:55] <audreyt> curious that I've never noticed that REPL is an anagram before

[06:55] <diakopter> Primal Exasperation Remits Licenses

[06:55] <TimToady> so's ERPL :)

[06:56] <audreyt> well yeah, but REPL means something :)

[06:57] * Kattana agrees with geoffb, and is more confused by the rest of what is going on.

[06:57] <TimToady> People ERPL Really Late

[06:57] <audreyt> print eval read loop;

[06:57] <geoffb> farking clasticase!

[06:58] <geoffb> I'm trying to do a variant of my gl progam with all of the gl calls replaced with stubs, so I can investigate Pugs' performance profile without gl and Perl 5 embedding confusing things ...

[06:58] <geoffb> But my stubbing doesn't seem to work, and I can't manage to make a small case that breaks!

[06:59] * Debolaz2 reinvents the wheel at http://rafb.net/p/h3ufAB12.html

[06:59] <lambdabot> Title: Nopaste - Exception handling

[06:59] <geoffb> http://www.broadwell.org/dl/step075-stubbed.p6 produces:

[06:59] *** Debolaz2 is now known as Debolaz

[06:59] <geoffb> *** No compatible multi variant found: &glPixelStore

[06:59] <geoffb>     at step075-stubbed.p6 line 210, column 5-41

[06:59] <geoffb> And that's after an svk pull; make clean; configure; make

[06:59] <Kattana> not to cause a distraction but here is an interesting bit of linguistics some people here might appreciate http://www.everything2.com/index.pl?node_id=1866132

[06:59] <lambdabot> Title: wanna (idea)@Everything2.com

[07:00] <audreyt> geoffb: .p6 you mean.

[07:00] <diakopter> Please Eradicate Romance Languages

[07:01] <geoffb> audreyt: huh?

[07:01] * Kattana wonders if there is room for invisible words in perl6

[07:01] <audreyt> er nvm.

[07:01] <audreyt> I copy/pasted incorrectly :)

[07:01] <geoffb> oh, heh

[07:01] <audreyt> what does &glPixelStore.perl print?

[07:01] <geoffb> \{Prim ([Pugs.AST.Internals.Val] -> Pugs.AST.Eval.Eval Pugs.AST.Internals.Val)}

[07:02] <geoffb> (Two copies because I was printing it twice in different scopes to make sure it didn't disappear on me)

[07:03] <audreyt> if you call it immediately after the .perl

[07:03] <audreyt> what does it do?

[07:03] <geoffb> checking ....

[07:04] <geoffb> Just moves the same error earlier

[07:04] <geoffb> trying a hunch ...

[07:04] <audreyt> try changing the eval to

[07:04] <audreyt> "sub $routine \{ undef \}"

[07:04] <audreyt> and see if that works

[07:04] <geoffb> ok

[07:06] <geoffb> \sub {Syn "block" {undef}}

[07:06] <geoffb> Initializing ...

[07:06] <geoffb> *** Cannot use Undef as a Code object

[07:06] <geoffb>     at step075-stubbed.p6 line 211, column 18-37

[07:08] <geoffb> Oh now *that's* interesting ... if I change the call 'glPixelStore(GL_UNPACK_ALIGNMENT, 1)' to just 'glPixelStore()' the error goes away (and moves to the next gl call, but that's not surprising)

[07:08] <audreyt> ok I see why.

[07:09] <audreyt> it's fixed in pad branch

[07:09] <audreyt> but! you can use trunk if you say

[07:09] <audreyt>         $eval ~= "our \&$routine  ::= \&stub;\n";

[07:09] <audreyt> and

[07:09] <audreyt>         $eval ~= "our \&$constant ::= \&constant_stub;\n";

[07:09] <geoffb> Ah

[07:09] <audreyt> for very obscure reasons (trunk was confusing nested compiling scopes due to eval)

[07:09] <geoffb> OK, fair enough

[07:09] <audreyt> it's generally good form to use ::= anyway

[07:09] <geoffb> is ::= more correct anyway?

[07:09] <audreyt> yeah.

[07:09] <geoffb> OK, what's the difference again?

[07:10] <audreyt> ::= evaluates the rhs at compile time

[07:10] <audreyt> and only binds once

[07:10] <audreyt> instead of upon all reentry

[07:10] <geoffb> OK, got it

[07:10] <geoffb> Lemme try that

[07:10] <audreyt> sub f { our $x := say(123) } f(); f(); # prints twice

[07:10] <audreyt> sub f { our $x ::= say(123) } f(); f(); # prints once -- during compilation

[07:10] <geoffb> gotcha

[07:11] * geoffb is very glad to be getting up to speed *now*, because the learning curve is going to be LONG

[07:12] <diakopter> and non-converging.

[07:12] <audreyt> hm, a sec.

[07:12] <TimToady> I've been learning Perl 6 for 20 years now...

[07:13] <geoffb> nope, doesn't work in trunk -- it errors out at my first test call:

[07:13] <geoffb> pugs: *** Undeclared variable: &glPixelStore

[07:13] <geoffb>     at step075-stubbed.p6 line 65, column 9-27

[07:14] <geoffb> Er, I should say, my first "say &glPixelStore.perl"

[07:15] <geoffb> The relevant line in $eval was "our &glPixelStore  ::= &stub;", which looks correct to me

[07:15] <audreyt> I think you misspelled constant as contant

[07:15] <audreyt> so entire eval was failing

[07:15] <geoffb> nope, not I

[07:16] <geoffb> OH!

[07:16] <geoffb> DUH!

[07:16] <geoffb> The original sub!

[07:16] <geoffb> sigh

[07:16] *** Belaf joined
[07:16] <audreyt> everything works if I say

[07:16] <audreyt> sub stub         { undef }

[07:16] <audreyt> sub constant_stub () {   1   }

[07:16] <audreyt> then

[07:16] <audreyt>         $eval ~= "our \&$constant ::= \&constant_stub;\n";

[07:16] <audreyt>         $eval ~= "our \&$routine  ::= \&stub;\n";

[07:16] <audreyt> then

[07:16] <audreyt>     say $eval;

[07:16] <audreyt>     eval $eval;

[07:16] <audreyt>     die $! if $!;

[07:16] <geoffb> yep, definitely

[07:17] <geoffb> Should have guarded that eval in the first place ... 

[07:17] <audreyt> indeed

[07:17] <audreyt> so := vs ::= is not that

[07:17] <audreyt> := works too here

[07:18] <diakopter> perspicuity eschewed, readability lessened.

[07:18] <geoffb> I made the switch anyway, for correctness

[07:18] <audreyt> sure

[07:18] *** drbean_ joined
[07:19] <audreyt> the canonical way is not eval though.

[07:19] <audreyt> it's this:

[07:19] <audreyt> macro import_all {

[07:19] <audreyt>   ... the same body ...

[07:19] <audreyt>        for @routines  -> $routine {

[07:19] <audreyt>         $eval ~= "our \&$routine  ::= \&stub;\n";

[07:19] <audreyt>     }   

[07:19] <audreyt>     $eval;

[07:19] <audreyt> }

[07:19] <geoffb> will it work in current pugs?

[07:19] <audreyt> then instead of BEGIN

[07:19] <audreyt> just say

[07:19] <audreyt> import_all;

[07:19] <audreyt> it will expand inline into the $eval

[07:19] <audreyt> and if it fails compilation you'll know

[07:19] <audreyt> sure!

[07:19] <geoffb> ROCK ON

[07:19] * geoffb trying that

[07:20] <audreyt> a sane macro system is a killer feature :)

[07:20] <geoffb> EXCELLENT, working

[07:20] <TimToady> not that text macros are entirely sane, but then most killers aren't.

[07:20] <geoffb> too cool, audreyt!

[07:21] <audreyt> well I guess you could've used quasiquoters... that'd work too

[07:21] <audreyt> but in any case it's better than calling &eval

[07:21] <audreyt> since it's a single compiler scope

[07:21] <audreyt> with macros

[07:21] <audreyt> geoffb: yay! :)

[07:22] * audreyt anticipates geoffb producing some kind of writeup about it

[07:23] <geoffb> I hope to, but my time is pretty limited, so it may be a while ... sigh

[07:23] <tene> geoffb: just copy/paste IRC logs

[07:23] <tene> then trim

[07:23] <audreyt> but glad you're having some amount of fun :)

[07:23] <geoffb> Definitely

[07:24] * geoffb reminded by tene of Schwern's lightning talk a couple years ago at OSCON -- programming by deletion

[07:24] <tene> Heh.

[07:24] <tene> Sounds interesting.

[07:25] <geoffb> Essentially: start with a string containing everything, then delete the parts that aren't your program.  Very sculptural.

[07:25] <audreyt> kinda the dual to the old "programming is an art of debugging a blank screen" saying

[07:26] <TimToady> Patriarchal Entity Requires Lassitude

[07:27] <TimToady> Please Emit Remaining Language &

[07:27] <audreyt> TimToady++

[07:29] <audreyt> DebolazX: nice wheel reinvention :)

[07:29] <gaal> what's "~=" ?

[07:29] <tene> Pink Elephants Reviewed the Language

[07:29] <geoffb> gaal: .= in P5

[07:29] <tene> gaal: $x = $x ~ $y

[07:29] <gaal> oh right :)

[07:29] <gaal> yes thanks :)

[07:30] <audreyt> whenever you see ~=, it really want to be replaced by take :)

[07:31] <audreyt> geoffb: 

[07:31] <audreyt>     [~] gather {

[07:31] <audreyt>         for @constants -> $constant {

[07:31] <audreyt>             take "our \&$constant ::= \&constant_stub;\n";

[07:31] <audreyt>         }

[07:31] <audreyt>         for @routines  -> $routine {

[07:31] <audreyt>             take "our \&$routine  ::= \&stub;\n";

[07:31] <audreyt>         }

[07:31] <audreyt>     }

[07:31] <audreyt> }

[07:31] <audreyt> avoids a variable, makes the intention clear

[07:31] <audreyt> (the [~] intention is "join by concat")

[07:31] <geoffb> OK, so in http://www.broadwell.org/dl/ there are now three versions: the original step075.p6 (uses P5 embedding and GL code), a -stubbed version (no embedding needed, all SDL/GL calls stubbed out), and a -nogfx version (all SDL/GL calls deleted).

[07:31] <lambdabot> Title: Index of /dl

[07:31] <tene> perhaps map instead of for.

[07:32] <audreyt> maybe, but for feels more imperative :)

[07:32] <gaal> gather is for in nonvoid context :)

[07:32] <geoffb> On my machine, -stubbed reports 9.1 fps, -nogfx reports 13.3 fps.

[07:33] <geoffb> So either call overhead is very significant, or just having all those symbols in the current namespace is expensive.

[07:33] <audreyt> meaning, huge method call overhead.

[07:33] <audreyt> both, actually.

[07:33] <audreyt> the reason is that currently pugs does a recursive type inference

[07:33] <audreyt> whenever you do a call

[07:34] <audreyt> so it's O(m*n) where m is parameter count and n is stack depth

[07:34] <audreyt> it's _very_ expensive.

[07:34] <geoffb> OK ... does this go away with your Pad work, or is that sometime later?

[07:34] <geoffb> ouch!

[07:34] <audreyt> this go away with gaal's SigMonoid work

[07:34] <audreyt> where we never infer and thus runs in O(m)

[07:34] <geoffb> What O() will it become with that done?

[07:34] <audreyt> just parameter count

[07:35] <geoffb> so O(m).  Not bad.

[07:35] <tene> The depth of which stack?

[07:35] <geoffb> Especially since my stack depth is non-trivial, since I use a lot of little methods that call other little methods

[07:35] <audreyt> tene: term dependency stack

[07:36] <audreyt> f(g(a(), b(), c()))

[07:36] <audreyt> must infer the type of g()

[07:36] <audreyt> which depends on type of a() b() c()

[07:36] <audreyt> before it even performs the inner call to a()!

[07:36] <audreyt> and g() does that again since there's no cache

[07:37] <audreyt> so it's actually O(m*n!) or something like that.

[07:37] <geoffb> OWW

[07:37] <audreyt> it's a wonder that pugs runs at all.

[07:37] <audreyt> ;)

[07:37] <geoffb> Go gaal, go gaal!

[07:37] <audreyt> we needed to do that because:

[07:38] <audreyt> 1) there were no concept of proto()

[07:38] <audreyt> 2) multi were decided by type "distance" not "narrowness"

[07:38] <gaal> looks like I need copious amounts of caffeine to get this finished, so let me tell you what

[07:38] <geoffb> Well, now you have a sort-of real life benchmark to see how well method call changes do ...

[07:38] <gaal> I'm going to check in my unfinished p6 code version and get that coffee

[07:38] <audreyt> very good :)

[07:38] <geoffb> audreyt: both of which are now not so sucky?

[07:39] <audreyt> right.

[07:39] <geoffb> excellent.

[07:39] <audreyt> and also Pad is O(1) in my branch now 

[07:39] <audreyt> but that may not affect things so much

[07:39] <audreyt> but I better finish it :)

[07:39] * audreyt goes hacking

[07:39] <geoffb> When does your branch drop?

[07:39] <audreyt> tonight if lucky

[07:39] <audreyt> tomorrow if not

[07:39] <geoffb> schweet

[07:39] <audreyt> then you can say

[07:40] <audreyt> our &sub := &moose;

[07:40] <audreyt> sub moose { ... }

[07:40] <audreyt> # note the "reversed" order

[07:40] <geoffb> cool, I've been working around that for now.

[07:40] <audreyt> I think the academic word for that is "letrec" or something :)

[07:41] * geoffb has not been in academia for a long time ....

[07:41] <gaal> Y-combs, Y-combs everywhere

[07:42] <gaal> brb

[07:42] <svnbot6> r15740 | gaal++ | * add (start of) an imperative implementation of the Signature

[07:42] <svnbot6> r15740 | gaal++ |   unification algorithm

[07:46] <geoffb> maybe sleep, maybe not &

[07:48] *** nnunley joined
[08:33] *** iblechbot joined
[08:34] <geoffb> apparently ... not

[08:52] <Schwern> geoffb:  Oh, I can't take credit for that brilliant talk.  That was mjd.

[08:52] <geoffb> Ah, right, sorry

[08:53] <Schwern> http://perl.plover.com/yak/debruijn/

[08:53] <lambdabot> Title: Debugging the de Bruijn Sequence

[08:53] *** Belaf_ joined
[08:53] <Schwern> Done totally silent.

[08:55] <geoffb> And the best part was the suu.html

[08:59] *** Jedai joined
[09:07] <buu> This boss is officially ridiculous

[09:07] <tene> Did you try looking for a weak spot or using upgraded weapons?

[09:08] <buu> =[

[09:08] <buu> If only I could.

[09:08] <Aankhen``> Hit the weak spot for massive damage!

[09:29] <Aankhen``> Okay, so I actually read all of the Unifying events and threads paper.  A lot of it went over my head, especially since I don't understand Haskell, but whatever I comprehended seems pretty delectable. :-)

[09:33] <geoffb> OK, I did P5 backports of the P6 stubbed and nogfx versions.  Here's the totals:

[09:33] <audreyt> hm I think I accidentally sped up smoketime by 2x.

[09:33] <audreyt> rerunning to make sure it's not an illusion

[09:33] <tene> bad audreyt!  add some sleep()s!

[09:33] <geoffb> PUGS:  norm: 4.8 fps, stubbed: 9.0 fps, nogfx: 13.9 fps

[09:33] <audreyt> (that is, reduced pugs startup cost by 50%)

[09:34] <audreyt> or more. still benching

[09:34] <geoffb> PERL5: norm: 4160 fps, stubbed: 6616 fps, nogfx: 14632 fps

[09:34] <geoffb> So we have roughly 3 orders of magnitude difference

[09:35] <audreyt> okay

[09:35] <audreyt> that's very reasonable :)

[09:35] <geoffb> ok, now really going to try to sleep &

[09:35] <geoffb> g'night all

[09:35] <tene> g'night

[09:58] <svnbot6> r15741 | audreyt++ | * build_pugs.pl: Regen prelude if instance was new.

[10:07] <svnbot6> r15742 | audreyt++ | * DrIFT.YAML: New asYAMLanchor API to allow sharing of

[10:07] <svnbot6> r15742 | audreyt++ |   YAML nodes globally instead of just lexically within

[10:07] <svnbot6> r15742 | audreyt++ |   the YAML stream.  The instance on [a] and [:a:] alone

[10:07] <svnbot6> r15742 | audreyt++ |   shrinks the Prelude.pm.yml by 20%.

[10:07] <svnbot6> r15743 | audreyt++ | * Drift.RuleYAML: New DrIFT rule to make all derived types anchorable.

[10:10] <svnbot6> r15744 | audreyt++ | * Pugs.AST.Internals: Refactor TraitBlocks into its own

[10:10] <svnbot6> r15744 | audreyt++ |   data type to increase sharing; also marked various extra

[10:10] <svnbot6> r15744 | audreyt++ |   anchored YAML instances.

[10:10] <svnbot6> r15745 | audreyt++ | * Chase the TraitBlocks change.

[10:12] <gaal> yay audreyt! :)

[10:15] *** buetow joined
[10:17] <audreyt> still running smoke but seems like the gain is significant.

[10:17] <svnbot6> r15746 | audreyt++ | * Mark various instances YAML-anchored; this should reduce

[10:17] <svnbot6> r15746 | audreyt++ |   startup time back to the level it was before (or maybe faster.)

[10:17] <svnbot6> r15747 | audreyt++ | * Regen instances.

[10:18] <audreyt> after PadRefactor there wouldn't be a subEnv anymore

[10:18] <audreyt> so all modules can be precompiled safely 

[10:18] <audreyt> instead of hand-crafted ones that avoids forward refs with qualified

[10:18] <gaal> trying to understand r15741... how can you anchor to something that isn't in the stream?

[10:18] <audreyt> so might be time to revive .t.yml plan

[10:19] <audreyt> 15742?

[10:19] <gaal> er, yes

[10:19] <audreyt> well, you can't which is why you gen an anchor

[10:19] <audreyt> next time it gens a ref

[10:19] <audreyt> the diff is that we were using a ReaderT 

[10:19] <audreyt> and insert is local

[10:19] <audreyt> (children sees the anchor)

[10:19] <audreyt> but now it's ReaderT IORef

[10:20] <audreyt> so insert is global

[10:20] <audreyt> (siblings sees the anchor)

[10:20] <audreyt> things like [] can't be shared locally

[10:20] <audreyt> since it has no children

[10:20] <audreyt> sharing it globally results in huge win

[10:20] <audreyt> i.e. we were using YAML as a tree

[10:20] <audreyt> now we're using it as a graph

[10:21] <gaal> so eg TraitBlocks refactoring is there because empty TraitBlocks is very common?>

[10:21] <audreyt> s/using/emitting/

[10:21] <gaal> s/>//

[10:21] <audreyt> ypu

[10:21] <audreyt> yup

[10:21] <audreyt> so instead of a lot of [] [] [] []

[10:21] <audreyt> the emptyTraitBlock is now a single anchor

[10:21] <audreyt> without that refactoring you'll see

[10:21] <audreyt> *8 *8 *8 *8

[10:21] <audreyt> assumign ReaderT-IORef cache

[10:21] <audreyt> with the old cache it's [] [] [] []

[10:22] <gaal> nod

[10:22] <audreyt> (look at the new .yml to see the diff)

[10:23] <gaal> there's a strictness change in YAML (Set a) now (lost a $!)

[10:23] <gaal> (r15746)

[10:23] <gaal> on purpose?

[10:24] <audreyt> 746 actually took away three anchors

[10:24] <audreyt> the $! was introduced a couple commits earlier

[10:24] <audreyt> so never mind that

[10:25] *** chris2_ joined
[10:25] <audreyt> seems generating stableptr on map and set somehow makes HsSyck unhappy

[10:25] <audreyt> and fails with "moose"

[10:25] <audreyt> so those three anchor were taken away

[10:26] *** chris2_ is now known as chris2

[10:27] <tene> audreyt: more pending commits soon?

[10:27] <gaal> why is the pod split into an array? what's PEStatic?

[10:27] <pasteling> "evalbot_r15741" at 194.145.200.126 pasted "Pugs build failure" (628 lines, 25.7K) at http://sial.org/pbot/23556

[10:27] <audreyt> tene: no

[10:27] <audreyt> gaal: array because spec says @=foo is by line

[10:28] <tene> audreyt: thanks

[10:28] <audreyt> PEStatic is PadEntry for our and state

[10:28] <gaal> oh

[10:28] <audreyt> revision: 15737

[10:28] <audreyt>   test_count: 733

[10:28] <audreyt>   duration: 1266

[10:28] <audreyt> revision: 15746

[10:28] <audreyt>   test_count: 733

[10:29] <audreyt>   duration: 642

[10:29] <audreyt> yay!

[10:29] <gaal> woot!

[10:30] <masak> wow, whence the great speedup?

[10:30] <gaal> hmm, is hs/MkTraitBlocks = [ [], [], []... ] correct?

[10:30] <audreyt> masak: more sharing of .yml nodes

[10:30] <audreyt> startup time is dominated by YAML parsing

[10:31] <gaal> i see that with 15747

[10:31] <audreyt> so reduce .yml size by 50% means 2x faster speedup

[10:31] <gaal> I thought emptyTraitBlocks should have been shared?

[10:31] <audreyt> gaal: it should, I don't see that

[10:31] <gaal> regenning..

[10:31] <audreyt> I see one

[10:31] <masak> audreyt: I must not have been following development closely enough lately. what uses .yml nodes?

[10:31] <audreyt>                     - &66 !hs/MkTraitBlocks 

[10:31] <audreyt> and a lot of *66

[10:32] <audreyt> masak: blib6/lib/Prelude.pm.yml

[10:32] <audreyt> blib6/lib/Test.pm.yml

[10:32] <audreyt> precompilation

[10:32] <masak> audreyt: ah, of course

[10:32] <audreyt> .yml is our "bytecode" so to speak

[10:32] <masak> yes :)

[10:33] <audreyt> gaal: still not seeing it? I have

[10:33] <audreyt> [T|audreyt]~/work/pugs$ ll blib6/lib/*yml

[10:33] <audreyt> -rw-r--r-- 1 audreyt 874584 Mar 17 18:14 blib6/lib/Prelude.pm.yml

[10:33] <audreyt> -rw-r--r-- 1 audreyt 504983 Mar 17 18:16 blib6/lib/Test.pm.yml

[10:33] <gaal> still compiling

[10:33] <audreyt> that's down from 

[10:33] <audreyt> -rw-r--r-- 1 audreyt 2822451 Mar 17 11:08 blib6/lib/Prelude.pm.yml

[10:33] <audreyt> -rw-r--r-- 1 audreyt 1818599 Mar 14 18:34 blib6/lib/Test.pm.yml

[10:34] <gaal> huh no, mine are still large :(

[10:34] <audreyt> weird... ghc 6.7?

[10:34] <gaal> -rw-r--r-- 1 gaal gaal 2881774 2007-03-17 06:35 blib6/lib/Prelude.pm.yml

[10:34] <gaal> -rw-r--r-- 1 gaal gaal 1838800 2007-03-17 06:26 blib6/lib/Test.pm.yml

[10:35] <gaal> 6.7.20070301

[10:35] <gaal> 15747

[10:35] <gaal> I'll make clean.

[10:35] <audreyt> feb22 here but shouldn't matter

[10:35] <audreyt> make clean might not help

[10:35] <audreyt> *ponders

[10:35] <gaal> too late :)

[10:36] <audreyt> heh :)

[10:36] <gaal> svk st ?

[10:36] <audreyt> all clean

[10:36] <gaal> I need a hw upgrade :)

[10:36] <audreyt> maybe aggressive GC

[10:36] <audreyt> let me try something

[10:37] <gaal> oh, you're thinking sharing only becomes manifest with plenty of RAM?

[10:37] <audreyt> yes because stableptr was unreffed

[10:38] <audreyt> a sec I can fix that

[10:39] *** ludan joined
[10:41] * audreyt plays a bit with (void *)s

[10:41] <clkao> fnord

[10:41] <gaal> always fun, that

[10:41] <clkao> *(fnord **)f

[10:44] <svnbot6> r15748 | audreyt++ | * DriFT.YAML: Attempt to delay GC of stable pointers. 

[10:44] <svnbot6> r15749 | audreyt++ | * regen instances.

[10:45] <gaal> audreyt, do you regen instances in separate commits on purpose?

[10:45] <audreyt> yes to force -M

[10:45] <svnbot6> r15750 | audreyt++ | * err typo.

[10:45] <audreyt> since svn doesn't guarantee that

[10:46] <gaal> -M ?

[10:46] <gaal> oh

[10:46] <audreyt> ensure that Instances.hs has a later mtime than its orig

[10:46] <gaal> right

[10:46] <gaal> nodnod

[10:46] <audreyt> ok, new .yml generation still works here

[10:46] <svnbot6> r15751 | audreyt++ | * typo again...

[10:46] <gaal> clean didn't help, trying latest r

[10:46] <audreyt> no idea it'll work for you or not

[10:47] <audreyt> this is linux or win32?

[10:47] <gaal> (co)linux

[10:47] <audreyt> really no idea

[10:47] <gaal> medium memory (600mb)

[10:47] <audreyt> can someone build pugs and paste the size of blib6/lib/*yml?

[10:47] <audreyt> tene? :)

[10:47] <audreyt> (brb)

[10:47] <tene> audreyt: will do shortly

[10:47] * tene svn up

[10:48] <gaal> btw did you see that asm hackery to tell if you're running inside a VM? cute :)

[10:48] <tene> laptop still dead/gone, so on a relatively slow box ATM

[10:48] <audreyt> no... ?

[10:48] <gaal> runs unpriv, too. sec, finding url

[10:49] <gaal> http://invisiblethings.org/papers/redpill.html

[10:49] <lambdabot> Title: invisiblethings.org - Red Pill

[10:49] <audreyt> good name!

[10:49] *** xerox_ joined
[10:49] <gaal> also, some folks claim to have disproved the Riemann Hypothesis

[10:49] <gaal> not that I can follow the proof, but it looks non-constructive

[10:50] <gaal> http://arxiv.org/pdf/math.NT/0703367

[10:50] *** Jedai joined
[10:50] <gaal> # that's completely OT but if true, very moose

[10:52] <gaal> grrr why does src/Pugs/Run/Perl5.hs always issue a warning about pugs_getenv. it's declared!

[10:53] <gaal> ok, that didn't help :(

[10:53] <audreyt> ETOOBAD :/

[10:54] <audreyt> assumption then is that newStablePtr doesn't get you okay values for values

[10:54] <audreyt> upload your .yml?

[10:54] <audreyt> want to see which nodes are anchored and which are not

[10:55] <gaal> http://perlcabal.org/~gaal/tmp/Prelude.pm.yml.bz2

[10:56] *** xerox_ is now known as xerox

[11:00] <gaal> I wonder if we can allow more compact serialization of sepcialized types. so much of the prelude is position annotations...

[11:00] <audreyt> wow

[11:00] <audreyt> zero sharing!

[11:00] <audreyt> newStablePtr isn't working at all in your GHC

[11:00] <gaal> looks it

[11:01] <gaal> should I try with 6.6?

[11:02] <audreyt> prolly colinux more than anything

[11:02] <audreyt> feather will be done in 10min

[11:02] <audreyt> can check then

[11:02] <audreyt> we can workaround using addressOf

[11:02] <audreyt> instead of newStablePtr

[11:02] <audreyt> I think.

[11:03] <gaal> doesn't newStablePtr pin the addr?

[11:03] <gaal> ...I thought that's precisely what it does?

[11:05] *** ozo_ joined
[11:06] <audreyt> but repin

[11:09] <gaal> I have a 6.6 build running... if it fails I'll try a native win32

[11:09] <audreyt> repin can cache or it can choose not to

[11:10] <audreyt> need to run... bbiab

[11:10] *** rindolf joined
[11:18] <tene> tene@hussein:~/src/pugs/blib6/lib $ du *yml

[11:18] <tene> 2820    Prelude.pm.yml

[11:18] <tene> 1800    Test.pm.yml

[11:21] <gaal> audreyt: looks like you had -Oleg turned on again...

[11:21] <gaal> tene: which ghc are you using?

[11:21] <tene> 6.6

[11:21] *** RHainsworth joined
[11:21] *** as joined
[11:22] *** RHainsworth left
[11:32] <gaal> I should have timed this but I get the feeling that 6.7 is much faster to compile pugs than 6.6

[11:44] <gaal> big files with 6.6 too, trying win32...

[11:51] *** mjk joined
[11:51] *** Achilles14 joined
[11:59] <tene> I get 2827 and 1804 on a different box

[12:09] *** araujo joined
[12:18] <gaal> nah, should be much, much lower when audreyt's change kicks in

[12:18] <gaal> i'm having setup problems with 6.7 on win32

[12:43] <xerox> gaal -Oleg?

[12:44] <tene> xerox: she had to run

[12:44] <tene> it was a pun

[12:44] <xerox> tene: I thought it was a pun on Oleg and the -O option... nevermind.

[12:44] <tene> ahh

[12:48] <moritz> if anybody is interested in pugs builds for debian: http://moritz.faui2k3.org/debian/pugs/r15751/

[12:48] <lambdabot> Title: Index of /debian/pugs/r15751

[12:50] <xerox> palindrome release

[12:51] <moritz> s/release/revision/

[13:01] *** shlomif joined
[13:02] *** shlomi joined
[13:02] *** mj41_ joined
[13:02] *** shlomi is now known as rindolf

[13:08] *** iblechbot joined
[13:40] *** ruoso joined
[13:41] <pasteling> "rindolf" at 88.153.198.34 pasted "Parrot failures on Mandriva Cooker (Pentium 4)" (7 lines, 428B) at http://sial.org/pbot/23558

[13:46] *** vel joined
[13:58] *** explorer joined
[14:20] *** xinming joined
[14:31] *** Limbic_Region joined
[14:33] <masak> sigh... longest-token-first and the unsortedness of hashtables don't really go together well

[14:43] *** bonesss joined
[14:44] * Limbic_Region yawns

[14:45] <Limbic_Region> salutations all

[14:51] <Limbic_Region> @tell putter my audreyt donation has been made via proxy ( diakopter++ ).  Do you know who, if anyone, is leading the effort at getting a donation page online?  I saw docs/feather/donate.pugscode.org but am confused as to what still needs to be done

[14:51] <lambdabot> Consider it noted.

[15:23] *** weinig|bbl is now known as weinig

[15:25] *** Khisanth joined
[15:37] *** cookys joined
[15:54] *** ofer0 joined
[15:59] *** shlomif joined
[15:59] *** shlomif is now known as rindolf

[16:04] *** chris2 joined
[16:06] *** Khisanth joined
[16:22] *** lanny joined
[16:26] <lanny> Any way to get  NickServ to send you the password you registered with?

[16:42] *** prly joined
[17:06] *** xinming joined
[17:12] *** lichtkind joined
[17:21] *** idiotmax joined
[17:25] *** bonesss joined
[17:27] *** VanilleBert joined
[17:46] *** bonesss joined
[17:48] *** neonse joined
[17:57] *** larsen_ joined
[18:04] *** larsen__ joined
[18:28] *** t4 joined
[18:33] *** VanilleBert left
[18:37] <svnbot6> r15752 | audreyt++ | * build_pugs.pl: Also regen prelude if DrIFT.YAML changed.

[18:38] *** thepler joined
[18:38] <svnbot6> r15753 | audreyt++ | * Glorious YAML compressor.

[18:38] <svnbot6> r15753 | audreyt++ |   I delayed Pad refactoring for one night to write this

[18:38] <svnbot6> r15753 | audreyt++ |   generic common-graph-elimination algorithm for non-recursive

[18:38] <svnbot6> r15753 | audreyt++ |   YAML trees, because apparently newStablePtr isn't portable

[18:38] <svnbot6> r15753 | audreyt++ |   enough (gaal++ and tene++).

[18:38] <svnbot6> r15753 | audreyt++ |   Now we abandon newStablePtr altogether and instead inspect

[18:38] <svnbot6> r15753 | audreyt++ |   the YAML tree to find out the maximum possible degree of

[18:38] <svnbot6> r15753 | audreyt++ |   compression.  Test.pm.yml is now shorter than Prelude.pm.yml!

[18:38] <svnbot6> r15753 | audreyt++ |   So now everybody should see a >2x speed up. :-)

[18:39] <audreyt> actually, more than 2x; up to 5x for smaller programs.

[18:41] * Patterner updates

[18:41] <audreyt> would like reports on "make ; make blib6/lib/Test.pm.yml ; ls -l blib6/lib/*yml"

[18:41] <audreyt> as well as smoke time differences

[18:42] <geoffb> Is a make clean necessary?

[18:42] <audreyt> no

[18:42] <geoffb> pulling and making ...

[18:42] <geoffb> I know I asked this a few days ago, but I forgot -- is parallel compile working, and how do I tell it to do so?

[18:43] <geoffb> I'd love to actually use that second core I paid for ....

[18:43] <Patterner> wild guess would be "make -j3" :)

[18:43] <audreyt> you can do make -j3 :)

[18:43] <geoffb> Yeah, but time is dominated by GHC compile.

[18:44] * Patterner needs a faster computer...

[18:44] <geoffb> So the question becomes making GHC parallelize

[18:44] <audreyt> there's a patch.

[18:44] <audreyt> http://hackage.haskell.org/trac/ghc/ticket/910

[18:44] <lambdabot> Title: #910 (--make should have a -j flag for parallel building) - GHC - Trac

[18:44] <audreyt> slated to 6.8

[18:44] <audreyt> so "not yet but soon".

[18:44] * geoffb can't wait for Etch to release, so sid will start flowing downhill again ....

[18:44] <geoffb> k

[18:45] <audreyt> that patch scales linearly (as is all GHC-based SMP parallelism nowadays)

[18:45] <audreyt> so once it's in trunk it'll make a lot of difference I expect :)

[18:45] <geoffb> That rocks.  Because of STM?

[18:45] <geoffb> nodnod

[18:45] <audreyt> yeah.

[18:45] * geoffb is boggled that such a simple concept makes such a huge difference

[18:45] <audreyt> well, imagine database without transactions...

[18:46] <audreyt> oh wait, that wasn't too long ago...

[18:46] <audreyt> *cough* MySQL *cough*

[18:46] <geoffb> NODNODNOD

[18:46] <Patterner> STM?

[18:46] <geoffb> A few years ago, the company I was working at had to fly out the original MySQL coders to help us work around the lousy performance.

[18:46] <audreyt> Patterner: software transactional memory. transactions for variable updates, instead of locks.

[18:47] <Patterner> mysql is not a database, it's an electronic rolodex.

[18:47] * Patterner googles for it

[18:47] <audreyt> mysql>=5 is fine though...

[18:47] <geoffb> They helped with the R/O stuff, but we had to rewrite the heavy R/W stuff ourselves.

[18:47] <geoffb> For certain table types only, yes?

[18:47] <audreyt> sure

[18:47] <audreyt> Patterner: we implement stm (examples/concurrency/stm-contend.pl

[18:47] <audreyt> )

[18:48] <audreyt> which is based on the idea that you can declare transactions of updates that happens atomically wrt other threads.

[18:48] <geoffb> Happen to know if STM is in Parrot?

[18:48] <audreyt> the primitives are in

[18:48] <lichtkind> audreyt: im a bit behinf schedule i rewritten some parts but it was more work than i thought, maybe tomorrow you get mail what was your gmail again i will note int this time in my thunderbird

[18:48] <audreyt> not really exposed/exercised by anything

[18:48] <audreyt> lichtkind: audreyt.org at gmail

[18:49] <geoffb> Wow, the changes since last night are causing GHC to recompile quite a bit

[18:49] <audreyt> yeah, anything that touches Pugs.AST.Internals does that

[18:49] <audreyt> that module will be Gone in a week, fortunately

[18:49] <audreyt> or at least massively shrunk

[18:49] <geoffb> and there was much rejoicing

[18:49] <audreyt> oh wow.

[18:49] <Patterner> Hmm... is "Ruf" a good translation for "Call"...?

[18:49] <audreyt> timing: 

[18:49] <audreyt>   duration: 538

[18:49] <audreyt>   test_count: 733

[18:50] <gaal> !!!

[18:50] <devbot6> gaal: Error: "!!" is not a valid command.

[18:50] <audreyt> this is the first time since forever I have a <10min smoke.

[18:50] <geoffb> yay

[18:50] <geoffb> <9, even

[18:50] <audreyt> indeed

[18:50] * Patterner is still watching the compilation... 

[18:50] * geoffb on 101

[18:50] <audreyt> expected to drop 50% again with Pad+Multi refactoring next week

[18:50] <audreyt> if not more, I think

[18:50] <geoffb> good

[18:51] <geoffb> Tests don't get run enough if they're not fast enough.

[18:51] <gaal> hmmm.... big yml still.

[18:51] <audreyt> -rw-r--r-- 1 audreyt 804390 Mar 18 02:33 blib6/lib/Prelude.pm.yml

[18:51] <audreyt> -rw-r--r-- 1 audreyt 339244 Mar 18 02:30 blib6/lib/Test.pm.yml

[18:51] <gaal> remaking it.

[18:51] <gaal> -rw-r--r-- 1 gaal gaal 2881926 2007-03-17 14:52 blib6/lib/Prelude.pm.yml

[18:51] <gaal> -rw-r--r-- 1 gaal gaal 1838800 2007-03-17 06:47 blib6/lib/Test.pm.yml

[18:51] <audreyt> ...rm them and "make pugs" and "make blib6/lib/Test.pm.yml"...

[18:51] <gaal> (14:52 is now on this machine)

[18:51] <gaal> yeah...

[18:52] <audreyt> this time there's nothing machine-dependent, so if you still see large yaml we have a fun problem to debug )

[18:52] <audreyt> :)

[18:53] <gaal> btw: VStr "Compile error -- invalid Pugs.PIL1.PIL_Expr: Stmts etc.

[18:53] <gaal> -rw-r--r-- 1 gaal gaal 2881926 2007-03-17 14:54 blib6/lib/Prelude.pm.yml

[18:53] <gaal> -rw-r--r-- 1 gaal gaal 1838848 2007-03-17 14:54 blib6/lib/Test.pm.yml

[18:53] <gaal> we have a fun problem to debug, then...

[18:53] <audreyt> we do

[18:53] * audreyt ponders

[18:53] *** forsaken joined
[18:53] <audreyt> still zero sharing in the .yml?

[18:54] <gaal> by the size, yes. looking...

[18:54] <geoffb> compile done!

[18:54] <geoffb> checking

[18:54] <gaal> huh. inline pod's squashed

[18:54] <gaal> (one string)

[18:54] <geoffb> Mine's still big

[18:54] <audreyt> only one string shared?

[18:54] <geoffb> -rw-r--r-- 1 geoff geoff 2881926 2007-03-17 11:53 blib6/lib/Prelude.pm.yml

[18:54] <geoffb> -rw-r--r-- 1 geoff geoff 1818599 2007-03-16 23:55 blib6/lib/Test.pm.yml

[18:55] <gaal> no; one string w/ embnewlines vs. array

[18:55] <audreyt> thinking.

[18:55] <gaal> i don't spot any sharing....

[18:56] <gaal> there is _some_:

[18:56] <gaal> eg: - &7 !hs/MkType

[18:56] <gaal> hmm but not sure any deref

[18:56] <audreyt> ok, but nowhere near enough

[18:56] <audreyt> really? that's interesting

[18:56] <geoffb> Interesting: rm blib6/lib/*.yml ; make changed my filesizes to match gaal's

[18:56] <gaal> it'd look like *7 right?

[18:56] <audreyt> yes.

[18:57] <gaal> no deref.

[18:57] <audreyt> thinking.

[18:57] <gaal> 31 refs.

[18:57] <gaal> achors, that is. with nonconseq numbers.

[18:57] <audreyt> nonconseq

[18:57] <audreyt> that is again very interesting.

[18:58] <audreyt> that means the AReference nodes vaporized

[18:58] <gaal> all hs/Vars

[18:58] *** chris2 joined
[18:58] <audreyt> upload yml again?

[18:58] <gaal> nonconseq but at least monotonic

[18:58] <gaal> sec

[18:58] * geoffb working on make clean; ./configure; make in case that helps

[18:58] *** xerox joined
[18:59] <audreyt> geoffb: wouldn't help... :)

[18:59] <geoffb> well heck, worth a try ...

[18:59] <gaal> http://perlcabal.org/~gaal/tmp/Prelude.pm.yml.bz2

[18:59] <geoffb> I can debug perl.  I can't debug haskell, so I have to fall back to the simple things.

[18:59] <geoffb> :-)

[19:00] <Limbic_Region> audreyt - 2x speed up from when?  My smoke tie went from 88 min to like 147

[19:00] <xerox> bugs? where? (:

[19:01] <gaal> my asYAMLanchor is basically commented out to id. is that supposed to be that way?

[19:01] <audreyt> Limbic_Region: just a sec

[19:01] <audreyt> gaal: yes. the trick is in compress below

[19:01] <audreyt> Limbic_Region: give me 1hr or so before resmoking :)

[19:02] <gaal> yeah I see the compress...

[19:02] <gaal> your cpu isn't 64 bit is it?

[19:02] <Limbic_Region> audreyt - the times I reported btw are prior to your most recent checkins

[19:03] <audreyt> 32 here

[19:03] <Limbic_Region> any parallelization?

[19:04] <geoffb> 32 bit here as well

[19:04] <Limbic_Region> setting concurrent > 1 is intermittently broke here for me (Win32)

[19:04] <Limbic_Region> oh, sorry

[19:04] <Limbic_Region> misread

[19:04] <audreyt> gaal: try this

[19:05] <audreyt> put this into test.hs

[19:05] <audreyt> import DrIFT.YAML

[19:05] <audreyt> import Data.Yaml.Syck

[19:05] <audreyt> main = emitYamlFile "compressed.yml" =<< compressYamlNode =<< parseYamlFile "blib6/lib/Prelude.yml"

[19:05] <geoffb> Oh that's odd -- make after make clean crashed

[19:05] <audreyt> and then

[19:05] <audreyt> geoffb: make again?

[19:05] <audreyt> gaal: and then

[19:05] <audreyt> util/runcompiler --make  -isrc test.hs src/pcre/pcre.o

[19:05] <audreyt> ./test

[19:05] <audreyt> and see if size changes for compressed.yml

[19:05] <geoffb> audreyt: getting farther this time

[19:06] <gaal> compiling...

[19:06] <audreyt> still thinking where the bug is

[19:06] <audreyt> the hashing scheme maybe

[19:07] *** dmpk2k joined
[19:07] <gaal> ugh, size zero. I'll add error moosages

[19:07] <audreyt> sorry

[19:07] <audreyt> Prelude.pm.yml

[19:08] <audreyt> typo

[19:08] <audreyt> not Prelude.yml

[19:08] <gaal> fixed that already

[19:08] <audreyt> mmm

[19:08] <gaal> oh my bad

[19:08] <gaal> -rw-r--r-- 1 gaal gaal 2881927 2007-03-17 15:09 compressed.yml

[19:09] <gaal> -rw-r--r-- 1 gaal gaal 2881926 2007-03-17 14:54 blib6/lib/Prelude.pm.yml

[19:09] <gaal> byte difference is prolly a newline...

[19:09] <xerox> diff?

[19:10] <audreyt> ok, assume hash is at fault

[19:11] <gaal> diff's too messed up, it's a wonder there's only one byte difference

[19:11] <Limbic_Region> audreyt - presumably you have received my donation via proxy? # diakopter++

[19:11] <audreyt> Limbic_Region: I had. much much thanks!

[19:11] <gaal> diff -ub | wc -l => 62k lines!

[19:11] <gaal> map order primarily, i gues

[19:11] <gaal> s

[19:11] <audreyt> probably

[19:11] <Limbic_Region> good - and in a few days I can help contribute to getting the page up and the word out

[19:12] <rindolf> Hi audreyt, gaal 

[19:12] <audreyt> Limbic_Region++

[19:12] <gaal> xerox: can you spot the bug? :)

[19:12] <gaal> hi rindolf 

[19:12] <gaal> yes, Limbic_Region++

[19:13] <rindolf> gaal: what's up?

[19:13] <audreyt> gaal: assume hash is bad

[19:13] <audreyt> http://perlcabal.org/~audreyt/tmp/YAML.hs

[19:13] <gaal> rindolf: audreyt forgot to flip the MORE MAGIC switch

[19:13] <audreyt> put it in src/DrIFT, remake

[19:13] <audreyt> the test, that is

[19:13] <audreyt> it should run much slower

[19:13] <gaal> yeah sec...

[19:14] <audreyt> but result here is

[19:14] <audreyt> -rw-r--r-- 1 audreyt 812944 Mar 18 03:12 compressed.yml

[19:14] <audreyt> (it used checksum instead of hashing so lots of collisons)

[19:14] <Limbic_Region> is precompiling prelude and test now not a good idea?

[19:14] <gaal> nod

[19:14] <audreyt> Limbic_Region: a better idea than before

[19:14] <audreyt> as soon as I make this work outsie my machine :)

[19:15] <Limbic_Region> ah, ok - good then

[19:15] <audreyt> if hashing is not at fault, then comparison is... though I doubt it can come to that

[19:15] <gaal> -rw-r--r-- 1 gaal gaal 2881927 2007-03-17 15:17 compressed.yml

[19:15] <gaal> :(

[19:15] <audreyt> let's see...

[19:21] <pasteling> "audreyt" at 122.126.35.100 pasted "minimal test" (10 lines, 350B) at http://sial.org/pbot/23570

[19:21] <audreyt> gaal: try this? should print

[19:21] <audreyt> --- 

[19:21] <audreyt> - &1 bar

[19:21] <audreyt> - baz

[19:21] <audreyt> - *1

[19:22] <audreyt> (and feel free to revert the unhash patch now)

[19:22] <audreyt> (so it'd run faster)

[19:22] <gaal> ---

[19:22] <gaal> - bar

[19:22] <gaal> - baz

[19:22] <gaal> - bar

[19:22] <audreyt> oh excellent.

[19:22] <audreyt> easier to debug in any case.

[19:23] <audreyt> debugging

[19:23] <gaal> why no tags at all, though?

[19:25] <audreyt> not well formed I guess?

[19:26] *** devogon joined
[19:26] <audreyt> debugging on feather. give me 10min

[19:26] <gaal> sure

[19:26] <gaal> want shell here too?

[19:27] <audreyt> no. compression is flawless

[19:27] <audreyt> AReference is genned

[19:27] <audreyt> the problem is now at HsSyck side

[19:28] <audreyt> i.e. given this perfectly fine

[19:28] <audreyt> MkNode {n_id = 503388359, n_elem = ESeq [MkNode {n_id = 2964694693, n_elem = EStr "bar", n_tag = Just "foo", n_anchor = AAnchor 1},MkNode {n_id = 2725169137, n_elem = EStr "baz", n_tag = Just "moo", n_anchor = ASingleton},MkNode {n_id = 0, n_elem = ENil, n_tag = Nothing, n_anchor = AReference 1}], n_tag = Nothing, n_anchor = ASingleton}

[19:28] <audreyt> HsSyck refuses to gen anchors

[19:28] <gaal> why's your box special?

[19:28] <audreyt> very good question.

[19:30] <gaal> different syck?

[19:32] <audreyt> we link statically with syck/ no?

[19:32] <gaal> we sure oughta...

[19:33] <audreyt> trying that hypothesis...

[19:33] <audreyt> it could still be a newStablePtr problem though

[19:35] *** Limbic_Region joined
[19:36] <gaal> brb

[19:37] <Limbic_Region> audreyt - does that "wait an hour before smoking" still stand?

[19:39] <audreyt> Limbic_Region: no, probably another 30min

[19:42] <gaal> "you rush a miracle moose, you get rotten miracles"

[19:42] <audreyt> but this is higly strange :/

[19:42] <audreyt> so I've traced it down to C-level calls

[19:42] <audreyt> which is identical

[19:42] <gaal> ah!

[19:42] <gaal> different gccs

[19:42] <gaal> -O

[19:42] <audreyt> syck_emitter_mark_node does get the sptrs

[19:42] <audreyt> -O2 is in effect

[19:43] <audreyt> i686-apple-darwin8-gcc-4.0.1 (GCC) 4.0.1 (Apple Computer, Inc. build 5367)

[19:43] <gaal> gcc (GCC) 4.1.2 20061115 (prerelease) (Debian 4.1.1-20)

[19:43] <gaal> let me try -O0

[19:43] <audreyt> I thought blaming the compiler is the last resort..

[19:43] <gaal> how do I pass that to c?

[19:44] <audreyt> edit .cabal

[19:44] <audreyt> the hssyck one

[19:44] <gaal> yeah but -O there is ghc

[19:44] <audreyt> -optc-O0 

[19:44] <gaal> -f-

[19:44] <gaal> ah

[19:44] <gaal> ok

[19:47] <audreyt> a fresh checkout on my machine still outputs anchors

[19:47] <audreyt> so it's not a contaminated checkout

[19:47] <audreyt> also libsyck is not installed

[19:48] *** justatheory joined
[19:49] <gaal> still rebuilding deps...

[19:50] *** xinming joined
[19:50] *** avarab joined
[19:52] <gaal> okay, that didn't change anything. :-P

[19:55] *** Schwern joined
[19:57] <audreyt> hm

[19:57] <audreyt> I wonder if sizeof(int) == sizeof(long) 

[19:57] <audreyt> or rather

[19:57] <audreyt> sizeof((void*)) == sizeof(long)

[19:58] <gaal> the former's true, the latter not necessarily. iirc.

[19:59] <audreyt> happens to work on feather

[19:59] <audreyt> so that's not it either.

[19:59] <gaal> hmm

[20:00] *** avarab is now known as avar

[20:00] <audreyt> boils down to syck's internal hash st_lookup failure.

[20:00] <audreyt> tracing it

[20:01] <audreyt> emitter.c line 397

[20:01] <audreyt> and line 1252

[20:01] <audreyt> doesn't work together somehow.

[20:02] <audreyt> (I may have to crash before finished tracing though, so cycles welcome...)

[20:02] <gaal> "/* XXX - Added by Audrey Tang to handle self-recursive structures - XXX */"

[20:03] <audreyt> line 394, not 397.

[20:03] <audreyt>         st_lookup( e->markers, n, (st_data_t *)&oid ) &&

[20:03] <audreyt> this is false somehow

[20:05] <gaal> what's ST_DATA_T_DEFINED guard for?

[20:06] <gaal> it's never mentioned anywhere but syck.h once

[20:06] <gaal> do you enter line 100 there?

[20:06] <gaal> not that I see why it'd make any difference... any pointer's a word on most these archs

[20:06] <gaal> a word32 even

[20:07] <audreyt> yeah that's not it

[20:07] <gaal> although

[20:07] <gaal> (st_data_t)oid

[20:07] <gaal> on next line

[20:08] <audreyt> that line is entered here.

[20:08] <gaal> long != unsigned long

[20:08] <gaal> SYMID is the latter...

[20:09] <audreyt> it is stableptr bug.

[20:09] <audreyt> fixing.

[20:09] <gaal> huh

[20:10] <audreyt> two calls to freeze got two different ptrs

[20:10] <audreyt> markYamlNode freeze emitter node = do nodePtr <- freeze node

[20:10] <audreyt> that one, and

[20:11] <audreyt>     mapM_ (syck_emit_item e) =<< mapM freeze sq

[20:11] <audreyt> that one

[20:11] <audreyt> this is very annoying :)

[20:11] <audreyt> but, same bug as we ran into before.

[20:13] <gaal> I.... don't get it

[20:13] <audreyt> there's a 

[20:13] <audreyt>             ptr     <- newStablePtr node

[20:13] <audreyt> in freezeNode

[20:13] <audreyt> suppose each time you call it with same node

[20:13] <audreyt> it gens another ptr

[20:13] <audreyt> instead of the old one...

[20:13] <audreyt> so the mark-phase ptr will disagree with emit-phase

[20:14] <gaal> how would that happen?

[20:14] <gaal> bug inside newStablePtr?

[20:14] <audreyt> I have no idea...

[20:14] <audreyt> testing that hypothesis

[20:14] <gaal> wouldn't that like crash ghc all the time?

[20:14] <audreyt> no

[20:14] <gaal> is feather SMP?

[20:14] <audreyt> both will be safe

[20:14] <audreyt> and stable

[20:14] <audreyt> and dereffable

[20:15] <gaal> your cpu is SMP

[20:15] <audreyt> it's just they are not cached, so to speak

[20:15] <audreyt> mine is, yes.

[20:15] <audreyt> but ghc only uses one

[20:15] <audreyt> (no GHCRTS)

[20:16] <audreyt> fixed!

[20:16] <audreyt> the fix is trivial.

[20:16] <gaal> memoize newStablePtr? :-P

[20:16] <audreyt> yeah.

[20:16] <audreyt> in line 256

[20:16] <audreyt>     ptr     <- newStablePtr node

[20:16] <audreyt>     let ptr' = castPtr $ castStablePtrToPtr ptr

[20:16] <audreyt> instead of blindly do that

[20:16] <audreyt> we first do a hash lookup for aanchor nodes

[20:17] <audreyt> and if it's there, use the memoized value

[20:17] <audreyt> problem solved

[20:17] <audreyt> committing

[20:17] <gaal> audreyt++

[20:19] <audreyt> try it?

[20:20] <svnbot6> r15754 | audreyt++ | * Fix an incorrect assumption about newStablePtr always generating

[20:20] <svnbot6> r15754 | audreyt++ |   the same thing for the same value in Data.Yaml.Syck, which prevented

[20:20] <svnbot6> r15754 | audreyt++ |   proper anchoring on certain machines, by memoizing newStablePtr.

[20:21] <gaal> building...

[20:23] *** DHGE joined
[20:24] <pasteling> "evalbot_r15754" at 194.145.200.126 pasted "Pugs build failure" (253 lines, 13.3K) at http://sial.org/pbot/23571

[20:24] <gaal> I needed to do some cleaning after this stuff, if the build breaks for anybody, make clean or just rm -rf third-party/installed

[20:24] * audreyt waits for the build to build...

[20:25] <gaal> did but didn't regen ymls.....

[20:25] <gaal> sec

[20:25] <audreyt> *crossed fingers*

[20:26] <gaal> clearly I need a faster machine :)

[20:26] *** Aankhen`` joined
[20:26] <moritz> gaal: who doesn't? *g*

[20:26] <audreyt> did you remember to revert the src/DrIFT/YAML.hs? checksum patch ?:)

[20:26] <audreyt> that is very slow :)

[20:26] <gaal> it works!

[20:26] <audreyt> ship it!

[20:26] <gaal> -rw-r--r-- 1 gaal gaal 815374 2007-03-17 16:28 blib6/lib/Prelude.pm.yml

[20:26] <gaal> -rw-r--r-- 1 gaal gaal 339244 2007-03-17 16:28 blib6/lib/Test.pm.yml

[20:26] <audreyt> Limbic_Region: smoke should be fine to do now to measure time difference. :)

[20:26] <audreyt> gaal: measure 

[20:26] <gaal> audreyt++ audreyt++ audreyt++

[20:26] <audreyt> time ./pugs -e1

[20:26] <audreyt> ?

[20:26] <audreyt> gaal++ gaal++ gaal++

[20:27] <audreyt> it should be noticeably faster

[20:27] <gaal> indeed faster by half!

[20:27] <gaal> w00t

[20:27] <audreyt> and with -MTest

[20:27] <audreyt> it's 3x or so

[20:27] <audreyt> because compression worked even better there

[20:27] <audreyt> woot

[20:27] <audreyt> evalbot will return momentarily

[20:28] <gaal> this really rocks :)

[20:28] <audreyt> the resulting .pm.yml is of course unfit for human consumption :)

[20:28] <audreyt> :D

[20:28] <audreyt> would be nice if we thought about that back in the prehackathon :)

[20:28] <gaal> unlike, heh, the situation heretofore?

[20:28] <audreyt> lol true.

[20:28] <allbery_b> hm.  I think that bug bit here too, my current Prelude.pm.yml is the same size as gaal's

[20:29] <allbery_b> (OSX PPC)

[20:29] <gaal> allbery_b: rm it

[20:29] <allbery_b> gaal's old one that is

[20:29] <gaal> and Test.pm.yml

[20:29] <allbery_b> will do a full regen later

[20:29] <allbery_b> (I build both ghc and pugs from distclean/realclean)

[20:29] <gaal> starting a smoke; haven't done that in ages :)

[20:30] <allbery_b> I launch them and leave them overnight, since G4 minis aren't exactly speed demons :)

[20:30] <gaal> ?eval "audreyt++ saved about {0.60 * 733} seconds from smokes"

[20:30] <gaal> hee, no evalbot yet

[20:31] <audreyt> > 0.60*733

[20:31] <lambdabot>  439.8

[20:31] <gaal> anyway, the nice thing about that is that it's 7.33 minutes :)

[20:32] <audreyt> :D

[20:34] <svnbot6> r15755 | audreyt++ | * Force Test.pm.yml regen if Prelude.pm.yml is old.

[20:34] <svnbot6> r15756 | audreyt++ | * build_pugs.pl: also regen prelude if this build_pugs.pl has changed.

[20:35] <audreyt> allbery_b: can you try just "make pugs"

[20:35] <audreyt> and see if the yml shrinks now? (r15757)

[20:35] <svnbot6> r15757 | audreyt++ | * typo.

[20:36] <audreyt> should be incremental

[20:39] <gaal> 508 refs in Test, 861 in Prelude

[20:39] <gaal> I wonder how many hits

[20:39] <gaal> but, not important

[20:40] <Limbic_Region> testing now audreyt

[20:40] <Limbic_Region> headed out for a while - will report when I get back

[20:40] <geoffb> Pulling last four revs and building ...

[20:40] <audreyt> Limbic_Region: thanks!

[20:41] <audreyt> the speedup is consistently 2x+ here, so would like to hear about GHC 6.6 and nonunix setups

[20:41] <gaal> I wonder what's hs/MkPrag .. eol-block that I see in Test.pm?

[20:41] <geoffb> Yes!, make alone worked, and fast

[20:41] <geoffb> -rw-r--r-- 1 geoff geoff 815374 2007-03-17 13:40 blib6/lib/Prelude.pm.yml

[20:41] <geoffb> -rw-r--r-- 1 geoff geoff 339244 2007-03-17 13:41 blib6/lib/Test.pm.yml

[20:41] <audreyt> gaal: it's something that tells that a block is parsed at eof

[20:41] <audreyt> rather eol

[20:41] <gaal> those sizes look good, geoffb 

[20:42] *** evalbot_r15754 joined
[20:42] <gaal> audreyt: where did it come from?

[20:42] <Patterner> how many tests of "make test" do you expect to fail atm?

[20:42] *** the_dormant joined
[20:42] <gaal> the Prag node, that is

[20:42] <audreyt> gaal: parser

[20:43] <audreyt> a block that ends its line can't be a hash composer

[20:43] <audreyt> it's just there to mark that fact

[20:43] <gaal> got it, :69

[20:43] <audreyt> Patterner: http://smoke.pugscode.org/ has the fiured

[20:43] <lambdabot> Title: Pugs Smoke Reports

[20:43] <audreyt> figures

[20:43] <audreyt> ~500ish

[20:44] <audreyt> ?eval 1+1

[20:44] <evalbot_r15754> 2

[20:44] <audreyt> ?eval use java:java.lang.System;

[20:44] <evalbot_r15754> Error: *** Unsafe function 'require_java' called under safe mode␤    at -e line 16, column 7-74

[20:44] *** devogon_ joined
[20:44] <audreyt> 4:44am again...

[20:44] <audreyt> really need to sleep

[20:45] <geoffb> g'night, audreyt!

[20:45] <audreyt> thanks a lot for helping me to figure out I'm not hallucinating :)

[20:45] <gaal> night! very mooseful day

[20:45] *** explorer joined
[20:45] <audreyt> another 9 days of those accidental speedups and we'll be 1000 times faster...

[20:46] * geoffb smiles expectantly  :-)

[20:46] <gaal> like noodles

[20:46] * geoffb can't wait to convert all of his personal P5 code over

[20:47] <audreyt> :) *wave* &

[20:47] <svnbot6> r15758 | audreyt++ | * ext/Perl6-Grammar/t/basic.t: unTODO now that captures in PCR works.

[20:47] <moritz> is there still work going on on a p5 to p6 translator?

[20:50] *** devogon__ joined
[20:50] <moritz> or has it even started yet?

[20:51] <gaal> t/examples/all_parse.t still takes a while! (184 sec here...)

[20:52] <gaal> moritz: I think there hasn't been much work on it lately

[20:53] <moritz> gaal: then it's probably futile to ask how far it is progressed ;-)

[20:54] <gaal> not futile, but I don't know the answer :)

[20:57] *** devogon joined
[21:00] *** gnuvince joined
[21:01] *** devogon_1 joined
[21:03] *** DHGE left
[21:04] *** justatheory joined
[21:11] *** avarab joined
[21:11] <gaal> 561.640u 1695.350s 38:48.99 96.9%       0+0k 0+0io 1pf+0w

[21:12] <gaal> but I don't know how it compares to before :)

[21:24] *** avarab is now known as avar

[21:28] *** ferreira joined
[21:35] <svnbot6> r15759 | audreyt++ | * Merged various YAML::Syck tweaks, including proper base64 routines

[21:35] <svnbot6> r15759 | audreyt++ |   to separate Buf from Str later.  Also, double-quoted strings in YAML output

[21:35] <svnbot6> r15759 | audreyt++ |   no longer contains continuation lines, which confused YAML.pm terribly.

[21:37] *** ferreira left
[21:41] <svnbot6> r15760 | audreyt++ | * Data.Yaml.Syck: We now generate inline YAMLs by default, which uses

[21:41] <svnbot6> r15760 | audreyt++ |   1/6 of the original disk space, and loads about 15% faster.

[21:41] <svnbot6> r15761 | audreyt++ | * regen instances.

[21:45] *** devogon joined
[21:49] *** Psyche^ joined
[21:50] *** ferreira joined
[21:56] *** ferreira left
[21:56] *** devogon_ joined
[22:00] *** Psyche^ is now known as Patterner

[22:10] *** devogon joined
[22:30] *** avarab joined
[23:24] *** avar joined
[23:24] *** vel joined
[23:28] *** devogon joined
[23:50] *** jisom joined
[23:57] *** MikeJS joined
