[00:00] <stevan_> it wont let it happen

[00:00] <Limbic_Region> or how to ensure that the object initializer gets called for all your ancestors

[00:00] <Limbic_Region> or ...

[00:00] <stevan_> Moose handles that too :)

[00:00] <Limbic_Region> right - Moose has almost everything I want

[00:00] <stevan_> :)

[00:00] <Limbic_Region> though I have to say - my non-Moose solution works pretty slick

[00:00] <Limbic_Region> but that's because I know how it is all implemented

[00:01] <Limbic_Region> *shrug* - if they can't figure it out, I will recommend hiring a perl developer (to my knowledge, there isn't a single one on staff)

[00:01] <Limbic_Region> contractor or otherwise

[00:02] <Limbic_Region> stevan_ - AFAICT, those two things are all I can see missing from Moose

[00:02] <stevan_> param validation and?

[00:03] <Limbic_Region> abstract class/methods

[00:03] <stevan_> roles are those

[00:03] <stevan_> just different terminology and style

[00:03] <stevan_> cause roles cannot be instantiated

[00:03] <Limbic_Region> yeah, so perhaps a doc update rather than a real change

[00:04] *** offby1` is now known as offby1

[00:04] <stevan_> well roles are a different way of thinking too

[00:04] <stevan_> Java guys can think of them as interfaces

[00:04] <Limbic_Region> perhaps a "So you were a Java developer...."

[00:04] <stevan_> interfaces with code re-use :)

[00:05] <stevan_> Java guys will get it

[00:05] <stevan_> find the one Java guy in your shop who has played with Ruby

[00:05] <Limbic_Region> I like the idea of writing nice clean respectable perl 5 code and not having anyone else be able to maintain it

[00:06] <stevan_> :)

[00:06] <Limbic_Region> resulting in getting a full time perl developer on staff

[00:06] <stevan_> job security

[00:06] <Limbic_Region> no - as I said, I'm not a developer

[00:06] <stevan_> ah

[00:06] <Limbic_Region> this is one of the handful of projects I have been asked to write code for

[00:07] <stevan_> well, I think Moose + a subset of CPAN would probably work out fine for you

[00:07] <stevan_> Moose plays pretty well with most modules 

[00:07] <Limbic_Region> ok ok - to be honsest, I don't feel like re-writing it

[00:07] <stevan_> LOL

[00:07] <stevan_> transitioning to Moose is actually easy too

[00:07] <stevan_> I have done it with our old app

[00:07] <stevan_> its not an all or nothing framework

[00:08] <stevan_> in fact,.. in most cases... Mooseifying takes much less time then people tend to think

[00:08] <stevan_> at least this is the collective experience of the #moose folks

[00:09] <Limbic_Region> well, I have already comitted to using a better framework for any future projects

[00:09] <stevan_> but thats okay,.. dont wanna use my module.. *sniff* ... I wont get upset ... *sniff*

[00:09] <Limbic_Region> Moose is the current frontrunner

[00:11] <Limbic_Region> I have decided never to use plain p5 OO ever again - this project was the straw that broke the camel's back

[00:11] <stevan_> :D

[00:11] <stevan_> I know that feeling

[00:11] <stevan_> Perl 6 OO ruined me for Perl 5 OO

[00:11] <stevan_> hence Moose

[00:11] <Limbic_Region> yeah

[00:12] <stevan_> well, if you want to try a quick moosification of a few classes, I would be happy to help out and help smooth the transition

[00:12] <Limbic_Region> well, I am considering working on it this weekend

[00:13] <Limbic_Region> I have a circular dependency issue I kind of want to think of a better solution for

[00:14] <stevan_> Moose attributes support weak-refs out of the box ;)

[00:14] <Limbic_Region> oh, not a ref counting issue

[00:14] <Limbic_Region> I have a half a dozen or so Common::Base modules that can be used by any new class that provide extremely common functionality

[00:14] * stevan_ is starting to feel like a used car salesman :)

[00:15] <Limbic_Region> one of them is a Common::Base::Log class

[00:15] <stevan_> ohh,.. i smell Roles ;)

[00:15] <Limbic_Region> the other is Common::Base::FileSystem::Utils or some such

[00:15] <stevan_> remember,.. roles are not part of the class strucutre,.. so they eliminate entire classes of inheritence issues sometimes

[00:16] <Limbic_Region> ::Log is obvious - log4perl rip off

[00:16] <Limbic_Region> FS::Utils does things like chdir, pwd, open file, remove file, blah blah

[00:16] <Limbic_Region> so here is the issue

[00:17] <Limbic_Region> FS::Utils assumes a log method in case something fails

[00:17] <Limbic_Region> but ::Log uses FS::Utils to open the log to write to

[00:17] <Limbic_Region> the way I solved it isn't quite optimal

[00:17] <Limbic_Region> how would you do that with Moose

[00:22] <stevan_> ah,... 

[00:23] <stevan_> sorry for the delay,.. small child issues :)

[00:23] <Limbic_Region> I will tell you the two ways I solved it after

[00:23] <Limbic_Region> no worries - I understand

[00:23] <Limbic_Region> my family is out of the country ATM

[00:23] <stevan_> FS::Utils would require a log method

[00:24] <stevan_> and log would use FS::Utils

[00:24] <stevan_> then FS::Utils could accept any log method

[00:24] <Limbic_Region> so you would make FS::Utils a non-OO class?

[00:24] <stevan_> yes

[00:24] <stevan_> a role

[00:24] <Limbic_Region> ok

[00:24] <stevan_> although I am not 100% sure of that relationshop working

[00:24] <stevan_> I would have to test it out

[00:25] <Limbic_Region> well, that's sorta one of the two solutions I did

[00:25] <stevan_> but since FS::utils would require a log method,.. and Log would provide it

[00:25] <stevan_> it shoudl work

[00:25] <stevan_> although delegation would work in this case too

[00:26] <stevan_> I have to go deal with more child issues,... but I will backlog ...

[00:26] *** rdice joined
[00:26] <Limbic_Region> solution 1 - remove the log method from FS::Utils and have it return an obj/hash with things like success/failure, error message, etc and let logging happen in caller land

[00:27] <Limbic_Region> solution 2 - make logging in FS::Util optional - if you pass in a log object as an optional parameter it will log for you, if not it won't

[00:32] <Limbic_Region> both have pros and cons

[00:35] <Limbic_Region> the solution I went with is a hybrid

[00:36] <Limbic_Region> FS::Utils checks to see if you passed in a log obj - if you did, it uses that.  If not, it checks if $self->can(log) and if it can, it uses that.  If those two things fails, it returns back the info necessary for caller to log properly

[00:47] *** rhr joined
[00:48] * perlmonkey2 oogles Moose

[00:48] * perlmonkey2 decides to spend a few hours rewriting his project at work in Moose.

[00:52] *** bsb joined
[00:55] *** perlmonkey2 joined
[01:03] <offby1> don't get fresh.

[01:17] <Limbic_Region> stevan_ - I will be calling it a night in about 40 minutes.  If you have any input and I am not around, @tell me

[01:34] *** dolmans joined
[01:47] *** dmq joined
[02:10] *** rashakil joined
[02:25] *** Schwern joined
[02:40] *** esstone joined
[02:57] *** justatheory joined
[03:01] *** CardinalNumber joined
[03:24] <perlmonkey2> Is Perl6 OO going to look anything like Moose?

[03:38] <Aankhen``> A little. :-)

[03:48] <perlmonkey2> Reading the Synopsis on Objects right now :)

[03:58] *** alexe joined
[03:59] *** perlmonkey2 left
[04:00] *** ProperNoun joined
[04:09] *** nxu7 joined
[04:13] *** amnesiac joined
[04:27] *** mjk joined
[04:27] *** obra_work joined
[04:43] *** dduncan left
[04:58] *** dduncan joined
[06:06] *** mdiep joined
[06:14] *** BooK_ joined
[06:16] *** H0LE joined
[06:20] *** rfordinal joined
[06:23] *** geoffb joined
[06:29] *** mdiep joined
[06:37] *** bsb left
[06:41] *** iblechbot joined
[06:46] *** obra_work is now known as obra

[06:56] *** Alias__ joined
[06:58] *** mathlord joined
[07:29] *** jisom joined
[07:40] *** xinming_ joined
[08:14] <Juerd> Does [ <Foo> & <!:i bar> ] dwim?

[08:14] *** devogon joined
[08:14] <Juerd> i.e. match /:i bar/, limited to the substring that <Foo> matched, so that if <Foo> matched foobarbaz, the entire []-group fails?

[08:16] *** luqui joined
[08:50] *** Alias__ joined
[08:50] *** revdiablo joined
[08:52] *** elmex joined
[09:03] *** the_dormant joined
[09:13] *** kane-xs joined
[09:20] *** kane-xs is now known as kane_

[09:32] *** dduncan left
[09:41] *** lichtkind joined
[09:41] *** ruoso joined
[10:02] *** buetow joined
[10:02] *** buetow joined
[10:08] *** chris2 joined
[10:14] <lichtkind> audreyt: ping?

[10:26] *** mdiep joined
[10:33] * Leibsle pongs lichtkind 

[10:52] *** iblechbot joined
[10:58] *** andara joined
[11:23] *** TimToady joined
[11:27] *** IllvilJa joined
[11:33] *** fglock joined
[11:33] <svnbot6> r15778 | fglock++ | PCR - RegexPerl5.pm - fixed a precedence problem

[11:42] <clkao> fglock: you know this v6() thing in the compiled ast.pmc ?

[11:44] <pasteling> "evalbot_r15777" at 194.145.200.126 pasted "Pugs build failure" (340 lines, 18.9K) at http://sial.org/pbot/23709

[11:49] <fglock> clkao: looking

[11:51] <fglock> clkao: which directory is that?

[11:53] <clkao> Pugs/Runtime/Perl6AST.pm

[11:53] <clkao> the last line of use v6; somehow got translated to v6()

[11:53] <fglock> k

[11:54] <clkao> also pcp6's makefile.pl is requiring Pugs::Emitter::Perl6::Perl5 which is in this particular pacakge? 

[12:00] <clkao> fglock: v6 projects aren't proper packages

[12:03] <fglock> clkao: yes, Pugs::Emitter::Perl6::Perl5 was meant to be distributed separately, but it didn't

[12:03] <svnbot6> r15779 | fglock++ | v6.pm - fixed parsing of 'use v5' chunks - clkao++

[12:03] <fglock> proper packages?

[12:03] <clkao> i mean the v6 in perl6 ones

[12:06] <svnbot6> r15780 | fglock++ | v6.pm - Makefile.PL - Pugs::Emitter::Perl6::Perl5 is inside the distro - clkao++

[12:06] <clkao> so how uptodate are docs under v6/* ?

[12:07] <fglock>  v6/v6-KindaPerl6/docs/FAQ.pod is recent; everything else may be outdated

[12:08] <clkao> how about mp6 ?

[12:08] <fglock> it is underdocumented, but I think it is updated

[12:09] <clkao> bah, FAQ.pod isn't really a pod! :p

[12:09] * fglock hides

[12:12] <fglock> re package, you mean: 'grammar Xxx {...}' should be 'grammar Xxx; ... ' ?

[12:12] *** Limbic_Region joined
[12:14] <clkao> no, not buildable in normal process. but i see in the faq now

[12:15] <pasteling> "evalbot_r15779" at 194.145.200.126 pasted "Pugs build failure" (343 lines, 20.2K) at http://sial.org/pbot/23712

[12:16] <fglock> clkao: yes, I need to talk to audreyt and find out how what is needed to make mp6 compatible with pugs

[12:38] *** fglock joined
[12:52] *** fglock joined
[12:52] <fglock> Juerd: re [ <Foo> & <!:i bar> ] - I don't think it works; S05: if you don't want your two terms to end at the same point, then you really want to use a lookahead instead

[12:52] <fglock> the lookahead won't try to satisfy '&'

[13:46] *** stevan__ joined
[13:48] *** lanny joined
[13:49] <lanny> audreyt (or any commitbit admin): ping

[13:53] *** iblechbot joined
[14:03] *** forsaken joined
[14:04] *** forsaken joined
[14:14] <Limbic_Region> @tell lanny I missed your commitbit ping but if you @tell one of us what the problem is, we will be sure to try and correct it

[14:14] <lambdabot> Consider it noted.

[14:15] <kolibrie> Limbic_Region: I think lanny forgot his password is and is trying to get it reset

[14:15] <integral> registerfly--

[14:16] <kolibrie> obra mentioned that they are working on an interface in commitbit to do that, but it is not finished yet

[14:17] <Limbic_Region> kolibrie - looking now but I suspect obra is correct

[14:18] <Limbic_Region> hrm, I can't seem to login so perhaps I forgot my password

[14:19] <kolibrie> I'm in there, but see only 'Invite', and 'Delete' pending users

[14:20] <audreyt> sent again.

[14:20] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[14:20] <Limbic_Region> audreyt - sent to lanny?

[14:20] <audreyt> yeah.

[14:20] <audreyt> really need native support in commitbit

[14:21] *** vel joined
[14:21] <kolibrie> audreyt: so you do something on the commandline?

[14:21] <audreyt> kolibrie: yeah. previously delete-reinvite wouldn't work as well

[14:21] <Limbic_Region> audreyt - I briefly saw some commit about another 10% startup improvement - my smoke time actually went up about 5 minutes

[14:21] <audreyt> because the user account isn't erased really

[14:22] <audreyt> Limbic_Region: really? hm

[14:22] <Limbic_Region> I'm not in a place where I can verify that ATM but will be hacking all weekend

[14:22] * audreyt ponders if it's another of those GHC 6.7-specific optimizations, or if it's OSX-specific, or something

[14:22] <audreyt> cool, same here

[14:22] <Limbic_Region> which starts in circa 6 hours

[14:22] <audreyt> registerfly still havn't released domains to enom

[14:22] <audreyt> been dropping emails like crazy :/

[14:23] <Limbic_Region> :-(

[14:23] <audreyt> the pad branch's code is almost ready; the only showstopper is that .yml doesn't deal with circular refs yet

[14:23] <audreyt> (a pad's outer pad now contains symbols that points back to the inner pad)

[14:24] <[particle]> Limbic_Region: who is one of us? i couldn't help him, and neither could obra

[14:24] <Limbic_Region> ok, well putter seems to be MIA so I will be taking a look at the donate page this weekend

[14:24] <Limbic_Region> bbiab - work

[14:26] <audreyt> [particle]: I'll see what I can do about this... a sec

[14:27] <audreyt> ok. apparently.

[14:27] <audreyt> invite again using identical nickname and password means resending password...

[14:28] <[particle]> or resetting password and reinviting

[14:28] <[particle]> (to prevent sending it cleartext)

[14:28] <audreyt> er sorry

[14:28] <audreyt> resending the-url-to-reset-password.

[14:29] <[particle]> ah. yes.

[14:29] <kolibrie> and the commands to do that are?

[14:30] <audreyt> kolibrie: invite.pugscode.org

[14:30] <audreyt> use the same email and same nicknam

[14:30] <audreyt> click "invite again"

[14:30] <audreyt> will do

[14:30] * [particle] would like to see the huge 'delete' buttons become text links

[14:30] <audreyt> why, yes, and maybe a "resend invitation" too

[14:30] <[particle]> yep

[14:30] <audreyt> [particle]: I've jused tried reinviting you.

[14:31] <audreyt> can you confirm that it works?

[14:31] <[particle]> and appear next to the name, instead of below (or be offset somewhat from the following text)

[14:31] <[particle]> okie

[14:35] *** bonesss joined
[14:35] *** perlmonkey2 joined
[14:35] <[particle]> can't get to the page

[14:36] <[particle]> email worked fine, and link appeared in text. clicking on link sends me to nowhereland

[14:36] <kolibrie> :(

[14:36] <audreyt> msg me the link

[14:36] <audreyt> ?

[14:36] <audreyt> delete-link-next-to-name fixed

[14:40] <kolibrie> that's cute: widget inline button button_as_link

[14:40] <audreyt> yeah :)

[14:40] <audreyt> it's still a button

[14:41] <audreyt> just masquerading as a link

[14:41] <[particle]> looks much better with that hack

[14:41] <[particle]> it's a button while the page is still loading :)

[14:41] <audreyt> oh well :)

[14:42] <Juerd> fglock: I want them to begin and end at the same point, but not anchored there

[14:43] <Juerd> fglock: i.e. the RHS must be bound to the substring that the LHS matched, because <!before .* blah> would match farther than that.

[14:48] <lichtkind> audreyt: hello, you any mistake else?

[14:48] <audreyt> lichtkind: no, looks fine

[14:49] *** jiing joined
[14:50] *** Southen_ joined
[14:50] <audreyt> [particle]: check mail, try again (and see if the link contains the word /letme/ this time)?

[14:53] <[particle]> link worked. attempting password reset, but it's SLOW after hitting save

[14:53] <[particle]> in fact, didn't take me anywhere afterwards :(

[14:54] <audreyt> oh.

[14:54] <fglock> Juerd: one further complication is that '&' does not promise to execute the subexpressions left-to-right

[14:54] <audreyt> [particle]: but did your password get reset?

[14:54] <audreyt> apart from the not-taking-you-anywhere-afterwards part

[14:55] <[particle]> i suppose there's one way to find out. i'll update & commit

[14:56] <audreyt> the not-taking-you-anywhere bug shoudl be fixed now

[14:57] <Juerd> fglock: && then

[14:58] <[particle]> logout works :)

[14:58] <Juerd> fglock: Actually, does <! pattern> exist even? :)

[14:58] <[particle]> login takes me to nowhere. i'll try again

[14:58] <audreyt> ...now trying login...?

[14:58] <Juerd> Or should I use [ <Foo> && <!before pattern> .* ] instead?

[14:58] <[particle]> same link, with ?J:RETURN=S32821_441066

[14:58] <Juerd> Actually,

[14:59] <Juerd> [ <Foo> && <!before .* pattern> ] 

[14:59] <audreyt> [particle]: but it did accept your (newly reset) password?

[14:59] <[particle]> audreyt: i don't know. it didn't explicitly reject it.

[14:59] <[particle]> audreyt: it just took me to nowhere after hitting login

[15:00] <audreyt> ok, a sec.

[15:00] <[particle]> the link suggests that it's redirecting me to the pugs project 

[15:00] <fglock> Juerd: [ <Foo> && <!before .* pattern> .* ] might work, after some mad backtracking

[15:00] <Juerd> fglock: Why is the latter .* needed?

[15:00] <[particle]> audreyt: that's a hint that it's accepting it, but not confirmation (for me)

[15:01] <fglock> because <!...> doesn't move 'pos'

[15:01] <audreyt> that's correct

[15:01] <Juerd> No, but didn't the <Foo> do that for the surrounding []?

[15:01] <Juerd> I'd expect the RHS to restore the pos 

[15:01] <Juerd> i.e. [ foo && f ] does increase pos by 3, not 1

[15:01] <fglock> Juerd: yes, but '&&' checks that both sides finished at the same pos

[15:02] <Juerd> Darn. I hoped it would be a submatch, not a check.

[15:02] * Juerd needs a translation for EBNF's A - B syntax.

[15:02] <fglock> yes, [ foo && f ] fails

[15:02] <Juerd> I don't see why having that fail is useful yet

[15:02] <[particle]> juerd: i wrote an ebnf grammar for pge. *almost* complete, iirc

[15:03] <fglock> but it's perfectly fine to do <!before ...> foo

[15:03] <fglock> I think that's what you actually want

[15:03] <Juerd> [particle]: Parsing EBNF is one thing. Emitting Perl 6 grammars from it is harder, because of this A - B construct.

[15:03] <Juerd> Actually, it's impossible, because A - B means two distinct and incompatible things in ebnf :)

[15:03] <fglock>  [ <before f > foo ] works

[15:03] <[particle]> context-sensitive?

[15:04] <Juerd> fglock: No, because at the time you do the <before ...>, you don't know which substring to limit it to yet

[15:04] <Juerd> fglock: A - B means that B must NOT match on the substring that A did match

[15:04] <Juerd> [particle]: No, sensitive to the phase of the moon :)

[15:04] * [particle] wonders about junctions in p6 grammars

[15:05] <Juerd> [particle]: Consider Char* - '-'. That means that - is excluded from the "Char" class.

[15:05] <[particle]> Juerd: can you force it to match longest token?

[15:05] <Juerd> Yes, the quantifier is in between!

[15:05] <[particle]> yes, it's like <char-'-'>

[15:05] <Juerd> But Name - ( ('x'|'X') ('m'|'M') ('l'|'L') ) means that you have to do two matches

[15:06] <Juerd> First match name, and then assert that name !~ /xml/i

[15:06] *** stevan_ joined
[15:06] <Juerd> That's very different, semantically, but in EBNF the same thing syntactically.

[15:06] *** Limbic_Region joined
[15:06] <audreyt> [particle]: login link should be fine now

[15:07] <Juerd> So you could do something like <Name> <{ $Name !~ /xml/i }> perhaps

[15:07] <Juerd> But I'd like a non-code pure-regex syntax

[15:09] <[particle]> i think you'll need something like <name> { $name !~~ :i/xml/ or fail }

[15:10] <[particle]> i don't see another way

[15:10] <Juerd> :(

[15:11] *** fglock joined
[15:11] <fglock> hmm - you also have [ foo <!after pattern > ] - anything more complicated probably needs an <at> anchor

[15:12] <Juerd> fglock: No, because that alse matches "pattern" *before* "foo"

[15:12] <[particle]> audreyt: all works now!

[15:12] <Juerd> B must be bound to whatever A matched

[15:12] <Juerd> Or at least its positions

[15:12] <audreyt> cool :)

[15:12] * Juerd afk

[15:13] <audreyt> [particle]++ # $infrastructure.help

[15:14] <[particle]> can you get the length of <foo> after it's been matched?

[15:14] <[particle]> bbi10m

[15:14] <fglock> lunch &

[15:15] <Juerd> [particle]: Is that a hypothetical question?

[15:15] * audreyt purrs and goes offline for a bit &

[15:30] <[particle]> juerd: i'm wondering if you can do a negative lookbehind

[15:30] <[particle]> i assume it needs to be fixed length

[15:43] *** mr_ank joined
[15:44] *** justatheory joined
[16:05] *** kanru joined
[16:08] *** Aankhen`` joined
[16:42] *** ivas joined
[16:43] *** forsaken joined
[17:01] *** falseep joined
[17:22] <ivas> I know this is not the right place to ask, but as is seems that nobody is on the parrot channel. How would you serialize and deserialize the PMC object. Does anybody knows which PODs I need to read ?

[17:23] <TimToady> ./docs/dev/pmc_freeze.pod maybe, from a cursory grep

[17:23] <TimToady> or in this case, a recursory grep.  :)

[17:24] *** jisom joined
[17:24] <ivas> thanks

[17:26] *** ashleyb joined
[17:28] <[particle]> ivas: we're on #parrot (irc.perl.org)

[17:28] <[particle]> ...perhaps you've been looking on freenode.

[17:28] <ivas> sorry i have been looking on the freenode

[17:31] *** ivas left
[17:34] *** andara left
[17:43] *** nwc10 joined
[17:43] <nwc10> audreyt: did 6-on-5 come up with a clever way of getting lexically scoped pluggable regexps in 5.8.x?

[17:45] *** pmurias joined
[17:45] <pmurias> hi

[17:46] <pmurias> juerd: what would Name* - ( ('x'|'X') ('m'|'M') ('l'|'L') ) match?

[17:46] <pmurias> s/juerd/Juerd/

[17:48] <TimToady> I don't think Char* - '-' is notionally different--it'll still just match the longest seq of Char that doesn't contain -

[17:49] <[particle]> TimToady: i agree

[17:50] <[particle]> it's all easy if the named regex is a token

[17:51] <TimToady> however, I agree that we're probably missing a primitive of some sort to do negative matching

[17:51] <TimToady> possibly two primitives, one that does the -ish thing of &! and one that lets us retest a $0

[17:51] <TimToady> was wondering if a subrule knows what it is going to be bound against

[17:52] <TimToady> and if $0:=<not foo> could falsify $0 retroactively

[17:52] <[particle]> junctional matching?

[17:53] <TimToady> no, sequential, &! would be opposite of &&, not &

[17:53] <Juerd> pmurias: Such things (non-charset things quantified and then -'ed) aren't seen, but I'd expect it to mean $x := <Name><Name><Name>... <{ $x !~ /xml/i }>

[17:53] <Juerd> Though I keep mixing up <{}> and {}, so I don't know if this is the right syntax for an assertion :)

[17:53] <Juerd> TimToady: There's a difference there, though

[17:54] <[particle]> { $x !~~ :i/xml/ }

[17:54] <Juerd> TimToady: In Char* - '-', it's indeed the longest thing without a -

[17:54] <TimToady> <?{...}> is currently assertion

[17:54] <Juerd> TimToady: In the other example, though, a name containing /xml/i is *illegal*

[17:54] <Juerd> !~~??

[17:54] <TimToady> there is no !~

[17:55] <Juerd> !~~ negates ~~?

[17:55] <TimToady> ! is a metaop that negates any logical op

[17:55] <Juerd> Ah, so we have !== now too?

[17:55] <Juerd> Which is !(==), not !(===)

[17:55] <TimToady> we allow != as a shortcut

[17:55] <TimToady> but not !~

[17:55] <Juerd> Do we still have ===?

[17:55] <TimToady> yes

[17:56] <pmurias> !~ looks cute

[17:56] <Juerd> I'd then expect a shortcut !== for that one...

[17:56] <TimToady> and !eq is the same as ne

[17:56] *** lambdabot joined
[17:56] <TimToady> then you'd be wrong :)

[17:56] <Juerd> Allowing != as as shortcut sounds like a very bad idea.

[17:56] <lambdabot> TimToady: You have 2 new messages. '/msg lambdabot @messages' to read them.

[17:57] <Juerd> (Only because === exists.)

[17:57] *** marmic joined
[17:57] <TimToady> not in the context of P5 culture

[17:57] <Juerd> You seem to be using that argument rather arbitrarily.

[17:58] <TimToady> when did I ever claim not to be arbitrary?  :)

[17:58] <Juerd> Perl 6 breaks Perl 5 "culture" almost everywhere.

[17:58] <nwc10> rules 1 and 2 still seem to survive :-)

[17:58] <Juerd> In fact, the very simple inconsistency between != (allowed, because of Perl 5 culture) and !~ (disallowed, because...?) bother me.

[17:59] <Juerd> Perl 5 culture also had !~.

[17:59] <[particle]> so don't use !=

[17:59] <Juerd> (has)

[17:59] <Juerd> [particle]: I'm thinking about all the mistakes that /other/ people will make.

[17:59] <kolibrie> so != is the same as !== ?

[17:59] <TimToady> yes

[18:00] <[particle]> kolibrie: yes

[18:00] <Juerd> kolibrie: But !== isn't the same as !=== (!)

[18:00] <Juerd> And !~ isn't the same as !~~

[18:00] <kolibrie> it does seem a little inconsistent

[18:00] <Juerd> There's just this special case (red flag, alarm bells, orange strobe beacons!) for !=

[18:00] <TimToady> and ne

[18:01] <Juerd> ne is okay, for visual reasosn.

[18:01] *** forsaken joined
[18:01] <TimToady> so's !=

[18:01] *** polettix joined
[18:01] <Juerd> I'd totally accept != as a shortcut if === didn't exist, and !~ was added too.

[18:01] <TimToady> the negation of === is !===

[18:01] <Juerd> != is visually confusing with !===, especially if you factor in Perl 5.

[18:02] <TimToady> only if you're blind

[18:02] <Juerd> If != works as the negative version of ==, then people will expect !== to work as the negative version of ===

[18:02] <TimToady> no they won't

[18:02] <Juerd> Yes, they will. They really will.

[18:03] *** justatheory joined
[18:03] <kolibrie> I think people might get confused

[18:03] <Juerd> But you've made up your mind; Trying to convince you is kind of useless, I reckon, and flaming doesn't get anyone anywhere... :)

[18:03] * Juerd adds to the Perlego6 list: remove != alias

[18:04] <dmq> mental note: dont wash your free donor card.

[18:04] <ajs_> Juerd: I'm not sure that's true. It is, potentially a PR issue, but the real issue is that 90% of folks are never going to use ===. They'll use == and ~~ and that's about it.

[18:04] <Juerd> ajs_: Low usage frequency on a short operator is, to me, a reason to /be extra careful/ to avoid confusion.

[18:05] <pmurias> javascript uses !== as !===

[18:05] <Juerd> Again, I wouldn't mind if === were called something else and !~ was added too (for the same Perl 5 cultural reason)

[18:05] <[particle]> i think the spec is clear.

[18:05] <TimToady> metaops in Perl 6 are never replacement characters

[18:05] <Juerd> [particle]: Very few people read that, or all of the documentation. And those who do read what we want them to read, will forget.

[18:05] <TimToady> that's a simple fact to teach

[18:06] <[particle]> it's a contraction.

[18:06] <Juerd> TimToady: I agree that !== and !=== and !eq and !~~ and !<anything> are very easy to teach. I like them a lot, even though I just learned about them a few minutes ago.

[18:06] <Juerd> TimToady: But != isn't so easy to teach.

[18:06] <Juerd> Because it's a special case. And any single special case is simple, but is a dangerous precedent, and several special cases together make for a very hard to teach language.

[18:07] <Juerd> If !== : == :: !=== : ===, then it's reasonable to expect that != : =

[18:07] <[particle]> coming from p5 culture, there aren't nearly enough special cases in p6.

[18:07] <Juerd> And if != : ==, then people assuming !~ : ~~ are to be expected too.

[18:08] <Juerd> [particle]: I love that Perl 6 removes many special cases. I'm sorry that it adds a few dozen new ones.

[18:09] <[particle]> sure, like the unnecessary % and @ sigils.

[18:09] <[particle]> but i'll use them, even though they're special cases.

[18:09] <Juerd> Everything more than bare ASM is unnecessary. 

[18:09] <[particle]> that's totally untrue.

[18:09] <ajs_> Perl 6 regularizes where irregularity has caused pain. It does not regularize for its own sake.

[18:09] <Juerd> Some unnecessary things are worth it. I think != is not.

[18:10] <[particle]> programming languages are for the programmer, not for the hardware.

[18:10] <Juerd> [particle]: Yes, but that argument can be used for either side, apparently.

[18:10] <ajs_> There are sides, now?

[18:11] <TimToady> I'm frequently on both sides myself.  :)

[18:11] <Juerd> ajs_: Always.

[18:11] <Juerd> ajs_: for versus against, usually

[18:11] <[particle]> perls have an infinite number of sides

[18:12] <TimToady> I'm usually against against.

[18:12] <[particle]> ...or maybe they only have one side.

[18:12] * Juerd is just so happy with Perl 6's flexibility. I can create my own dialect, without forking the language. Lovely.

[18:12] <Juerd> And even nicer is that many, many people will do this. There'll be so many Perls to choose from...!

[18:12] <Juerd> (And that's a good thing, right? Is it?)

[18:12] <[particle]> a string of perls

[18:13] <TimToady> as long as they all predeclare their linguistic pedigree, it's fine.

[18:13] <[particle]> would make life easier of people did that, too.

[18:13] <TimToady> but you don't have to declare anything to not use !=

[18:13] <Juerd> My dialect will be called perlego :)

[18:14] <Juerd> TimToady: I want others who work for me to not use it, and code written by others to not use it.

[18:14] <TimToady> then tell them not to.  :)

[18:14] <Juerd> That doesn't work.

[18:15] <TimToady> oh well

[18:15] *** offby1 joined
[18:15] <Juerd> Can't tell every CPAN contributer to not use it.

[18:15] <ajs_> I want others to not use negative numbers, but I don't get very far with that....

[18:15] <Juerd> But I can host a copy of CPAN that doesn't use it.

[18:15] <TimToady> the phrase "out of proportion" comes to mind...

[18:16] <Juerd> It's like an enforced Best Practices set.

[18:16] <pmurias> you could write a plugin for your editor to display != as !==

[18:16] <Juerd> pmurias: Sure I could.

[18:16] <xinming_> the more interesting thing might be, many people will programming using his mother language in perl 6. 

[18:16] <Juerd> That's very besides the point, though.

[18:16] <Juerd> I'm thinking of the implications for teaching and using Perl in coding teams.

[18:17] <[particle]> coding standards and code reviews Work.

[18:17] <nwc10> forget perltidy. we'll have perl6[sanity|babel] that converts everyone else's code to your preferred dialect, before you go insane

[18:17] <pmurias> probably most programmers know what != means

[18:17] <Juerd> There's a reason that many people pick other languages over Perl, and Perl 6 is in many ways a good solution to this problem. And perhaps, if I'm in time, I can set a easier-to-learn standard.

[18:18] <TimToady> learnability is not the highest goal of Perl

[18:18] <Juerd> pmurias: Yes, but knowing that != has to do with ==, it's too easy to assume that !== will have to do with ===.

[18:19] <TimToady> there has to be something left over for the faq...

[18:19] *** fglock joined
[18:19] <Juerd> TimToady: Yes, but I'd like the FAQ to mostly discuss dwimmery and semantics, not syntax.

[18:19] <kolibrie> I did get confused about != after seeing several !~~, just seemed natural that != would have been replaced with !==

[18:19] <[particle]> != is dwimmery :)

[18:19] <Juerd> kolibrie: It is. It's the != alias that I'm afraid will hurt.

[18:19] <TimToady> kolibrie: it was

[18:20] * kolibrie will just use !== then

[18:20] <TimToady> I don't think removing != will prevent people from confusing !=== with !==

[18:20] <Juerd> I will too.

[18:20] <Juerd> TimToady: It won't prevent. It will limit the number.

[18:22] <ajs_> "use strict :noaliases :longvariables :bondagemeharder :dontletmesnackbetweenmeals :max80cols :musthavetrailingsemi :Juerd"

[18:22] <Juerd> #!/usr/bin/perlego

[18:22] * xinming_ agrees with Juerd, for what he ever said.

[18:23] <Juerd> ajs_: I will only limit things that I think are very wrong.

[18:23] <Juerd> ajs_: I believe in the flexibility of Perl.

[18:23] <ajs_> Juerd: And I think those two are mutually exclusive, but that's OK too ;)

[18:24] <fglock> nwc10: re pluggable regexps - do you mean pluggable regex engines? 

[18:24] <[particle]> well, there's always Inline::Perl6 to get around perlego

[18:24] <Juerd> [particle]: Of course.

[18:24] <nwc10> fglock: yes

[18:24] <Juerd> And maybe it'll be a lexical "use perlego". I dunno yet.

[18:25] <TimToady> I think it's bad to mix Greek with non-Greek roots...

[18:25] <Juerd> The primary reason that I want perlego is still <-> though :)

[18:26] <Juerd> All other issues are secondary.

[18:27] *** ozo_ joined
[18:27] <TimToady> speaking of special cases...

[18:27] <fglock> nwc10: at compile-time, it is not a problem (but currently not implemented); at runtime, it would depend on what the p5 libraries support

[18:27] <Juerd>  I think the implicit "$_ is rw" default is a worse special case.

[18:27] <nwc10> fglock: did anyone actually get anything working?

[18:27] <Juerd> Either rw should be the default, or the $_ default should be ro too.

[18:28] <nwc10> as best I can tell, the current interface that re.pm uses makes rather a lot of assumptions that your regexp bytecode is the same as the core's

[18:28] <Juerd> So Perlego makes -> always default to ro, with arrowless invocation defaulting to <->

[18:28] <Juerd> so for @array { ... } won't change, only for @array -> { ... } will.

[18:28] <Juerd> Or, hm, I'm not sure if an empty param list for -> actually defaults to $_. Probably not even.

[18:29] <Juerd> In that case, it'll even be fully compatible.

[18:30] <Juerd> afk  # pain in hands

[18:30] <fglock> nwc10: avar is working on it; there is already some published modules in CPAN (re::engine::*)

[18:30] <TimToady> fglock: does a subrule know what it's going to be bound to?

[18:31] <TimToady> well, it probably doesn't matter, since it's probably bad to overload := to something else...

[18:32] <fglock> TimToady: not sure what you mean, have an example?

[18:33] <TimToady> was wondering if $0:=<not foo> could fail if $0 doesn't contain foo, but it's a bad idea.

[18:34] <fglock> ok (but it would be possible)

[18:37] <[particle]> so, is it just syntax we need at that point? $0::=<...> ?

[18:37] <TimToady> we seem to be missing two syntaxes

[18:38] <TimToady> one that does <Foo> and not bar

[18:38] <TimToady> and one that says $0 not bar

[18:38] <fglock> nwc10: re::engine is actually independent on the p5 regexp bytecode; it only depends on the regex API

[18:38] <TimToady> where the latter also presumably wants "$0 true bar" as well.

[18:39] <TimToady> currently we relegate matches against a binding to a <?{...}>

[18:39] <[particle]> <foo!bar>

[18:39] <TimToady> and that's not something that generalizes to other languages

[18:39] <TimToady> we'd like to allow EBNF to translate directly

[18:39] <[particle]> indeed.

[18:40] <[particle]> i think i lost my ebnf parser :(

[18:40] <TimToady> we have &&, but that only handles positive on the right

[18:40] <[particle]> i used it to parse itself

[18:42] <TimToady> so thinking something like &&! for "match same length but can't contain..."

[18:43] *** tapple joined
[18:43] <pmurias> particle: it was writen in ebnf?

[18:43] <pmurias> s/writen/written/

[18:44] <TimToady> and maybe $0 ~~ [ bar ] and $0 !~~ [ bar ] for the match previous binding case.

[18:44] <[particle]> i should be more clear.

[18:45] <TimToady> would mean ~ and ! are new metachars after a variable

[18:45] *** tapple left
[18:45] <TimToady> clearly

[18:45] <[particle]> i used the ebnf grammar to create a p6 grammar to parse ebnf. to test it, i fed it the ebnf grammar.

[18:47] <[particle]> TimToady: it looks a bit funny with the spaces, if this is to be inside a regex

[18:47] <TimToady> we allow $0 := <rule>

[18:47] <[particle]> $0**{2}

[18:48] <pmurias> [particle]: you used the grammar in the ISO spec?

[18:48] <[particle]> pmurias: i believe so. i fear it was lost last november when my laptop died

[18:48] <TimToady> could also go with something like <match $0 bar> and <!match $0 bar>

[18:49] <[particle]> so, modulo the missing pieces we're talking about now, it's definitely possible to do.

[18:49] <TimToady> but then we're special casing the parsing of that

[18:49] <[particle]> <match $0~~bar>

[18:50] <TimToady> unfortunately <$0> is taken, unless we lookahead and make <$0~~bar> do something else

[18:50] <TimToady> <~~ $0 bar> is kinda weird

[18:50] <TimToady> [particle]: that's legal only if bare $0~~bar is legal

[18:51] <[particle]> pmurias: i'd like an ebnf front end to pge.

[18:51] <[particle]> TimToady: yeah, i know :( -- but it's good to see more options

[18:51] <TimToady> nod

[18:52] <TimToady> <$0? bar> and <$0! bar> maybe.

[18:53] <TimToady> getting a bit terse

[18:53] <TimToady> and not really like any other matching syntax

[18:54] <TimToady> or <=$0 bar> <!=$0 bar>

[18:55] <TimToady> (the latter just being ! applied to the former)

[18:56] <TimToady> <match($0,/bar/)> is unfortunately getting back towards assuming Perl

[18:58] <[particle]> with <$0? bar>, you want the space there to denote the following is a regex?

[18:58] *** nxu7-wrk joined
[18:58] <TimToady> space there doesn't matter, but space before ? would

[18:59] <[particle]> sure

[18:59] <[particle]> i'm thinking about current constructs

[18:59] <TimToady> and <$0?: string> is a bit out there

[18:59] <[particle]> looks too much like perl 5

[19:00] <[particle]> that is, terse and confusing

[19:00] <TimToady> <:match<$0> bar> <!:match<$0> bar>

[19:00] <fglock> TimToady: hmm - you are trying to enforce that Perl6-Regex and Perl6 are separate languages?

[19:01] <TimToady> I'm trying to make P6 regex language a little more borrowable by other languages

[19:01] <[particle]> <:$0 bar> <!:$0 bar>

[19:01] <fglock> yep

[19:01] <TimToady> would be nice if everyone's translation of EBNF to p6cre was the same

[19:02] <TimToady> rather than having p6cre invent new non-p6 syntax

[19:03] <TimToady> <:($0) bar> <!:($0) bar> would fit current adverbs better

[19:04] <TimToady> :$0 would be more like '0' => $0

[19:04] <TimToady> in p6-think

[19:04] <[particle]> true

[19:04] <[particle]> the parens are distracting, but not exactly overloaded

[19:05] <TimToady> we're kinda going with extended identifier using adverbs elsewhere

[19:05] <TimToady> "use foo:from<Python>"

[19:06] <TimToady> so maybe it's <match:($0) bar>, though we'd have to break current :

[19:06] <[particle]> might be trouble with a rule named <match>

[19:06] <[particle]> for the human, not the computer

[19:07] <TimToady> <if:($0) bar>

[19:07] <[particle]> <??:($0) bar> # now we're talking perl 5

[19:07] <TimToady> <also:($0) bar>, though <!also> is weird

[19:07] <TimToady> <true:($0) bar> <not:($0) bar> but then we waste ! prefix

[19:08] <TimToady> pity "submatch" is so long

[19:08] <TimToady> but maybe worth it huffmanly speaking

[19:08] <TimToady> <submatch($0) bar>

[19:09] <TimToady> <!submatch($0) bar>

[19:09] <[particle]> how about a cap somewhere?

[19:09] <[particle]> like TOP

[19:09] <TimToady> not magically called

[19:09] <[particle]> <SUBMATCH($0) bar> is ugly though

[19:10] <[particle]> so, just another builtin rule, like <ws>?

[19:11] <TimToady> <can:($0) bar>  :)

[19:11] <TimToady> <does:<$fido> bark>

[19:11] <fglock>  fail / assert ?

[19:12] <TimToady> I think fail's argument should be a message, if anything

[19:12] <TimToady> just to be the same as outside regex

[19:14] <TimToady> biab &

[19:19] *** prly_ joined
[19:20] <kolibrie> <submatch($0) bar> almost makes sense without too much thought, which is better than all the others, which left me puzzling for a while

[19:25] <TimToady> which makes me wonder if <foo bar> is just a <foo() bar>, and if so, how does /bar/ show up in the arguments to foo().

[19:25] <avar> fglock: heya:)

[19:27] <TimToady> is <foo($0) bar> equiv to <foo($0,/bar/)> or <foo($0,:regex(/bar/)> or <foo(/bar/,$0)> or something else...

[19:28] <TimToady> named would make it easier to have default args without confusion

[19:28] <[particle]> <foo:($0) bar>

[19:29] <TimToady> otherwise <foo() bar> would tend to put /bar/ where you weren't expecting it.

[19:29] <TimToady> except the foo:($0) is really intended for extending the name foo at compile time.

[19:29] *** prly__ joined
[19:29] <TimToady> infix:<+> for instance

[19:29] <[particle]> hrmm

[19:30] <TimToady> but I kinda like the <foo()> extending into <foo() more>

[19:30] *** Leibsle joined
[19:30] <TimToady> it's kind of arbitrary that <foo( always has to end )>

[19:31] <TimToady> might even get away with <Foo> && <!submatch bar> for the other syntax, if submatch can be taught to default to the left of the && somehow

[19:34] <Juerd> I'd almost suggest introducing an infix ~~ in regexes

[19:35] <TimToady> I already suggested it earlier.  :)

[19:35] <Juerd> Ah

[19:35] <lichtkind> TimToady: is in in the S?

[19:35] <TimToady> in?

[19:36] <[particle]> no, it's just in the channel

[19:36] <lichtkind> in the synopses i mean is it oficcial?

[19:37] <TimToady> is what official?

[19:37] <lichtkind> i asked if the infix ~~ is officially part of perl6

[19:37] <lichtkind> or juist a rant

[19:38] <TimToady> infix:<~~> is certainly official for normal Perl code.  we're talking about whether we could use it within a regex

[19:38] <Juerd> It'd be begging for a !~~ too

[19:38] <kolibrie> who's on first

[19:38] <TimToady> and then ~ and ! would have to be treated as metacharacters following $var

[19:39] <Juerd> And then you'd just have <Foo> && $?Foo !~~ <submatch :i xml>

[19:39] <Juerd> But ~~ wants // in my fingers... :S

[19:40] <Juerd> And while it's very doable to mechanically parse /<Foo> && $Foo !~~ /:i xml//, it looks weird

[19:40] <Juerd> $<Foo>

[19:41] <TimToady> and you still haven't satisfied && for ending at the same place.

[19:41] <Juerd> I'm still assuming it'll do that by default ;)

[19:41] <Juerd> (read: hoping)

[19:42] <Juerd> But now that I actually mentioned it, it'll never happen of course :)

[19:42] <TimToady> ~~ is an assertion

[19:42] <TimToady> so zero width

[19:42] *** the_dormant joined
[19:43] <lichtkind> ah thanks

[19:43] <Juerd> <ebnf_minus ...>  # desperate :)

[19:43] <TimToady> lol

[19:44] <Juerd> <but_not ...>

[19:45] <Juerd> no ebnf :because<IT SUCKS>;

[19:45] <TimToady> at the moment it's looking like <Foo> && <!submatch bar> .*  can be made to work, if submatch can access the left of && somehow

[19:45] <Juerd> Is there a list of current metachars?

[19:46] <Juerd> I'm thinking of an arrow of some kind

[19:46] <TimToady> yeah, but if it gets any longer we might as well make all punctuation metachars...

[19:46] <Juerd> <Foo> ==> <!submatch bar>

[19:46] <Juerd> Yes, that's why I'd want an arrow that begins with an existing metachar.

[19:46] <pmurias> TimToady: it would be consistent

[19:47] <Juerd> Very consistent, and forward-compatible.

[19:47] <Juerd> \w characters are literal unless escaped, \W characters are meta unless escaped

[19:47] <TimToady> presumably that gives you your '"' and "'" too

[19:47] <Juerd> :)

[19:48] <Juerd> Is it wise to bring up /$foo/ again? :)

[19:49] <TimToady> no, or you're break $0

[19:49] *** prly joined
[19:49] <Juerd> Break how?

[19:49] <TimToady> $0 should match literally, I think

[19:49] <Juerd> No, literal matches are "" ;)

[19:49] <Juerd> "$0"

[19:50] <Juerd> But I see your point. It's hard to please both my brain cells... :)

[19:51] <Juerd> Maybe $0 behaves differently in... REGEX CONTEXT! (oh my)

[19:51] <TimToady> but it'd free up <$0 bar> and <!$0 bar>

[19:51] <Juerd> Ah, another good point. 

[19:51] <Juerd> Though would that be used much?

[19:52] <TimToady> <Foo> && <!$<Foo> bar> .*

[19:52] <Juerd> Ah yes. Yea.

[19:52] <Juerd> I could get used to that. Easily :)

[19:53] <TimToady> I would need to think about this a lot.

[19:53] <pmurias> is there a way to negate a pattern

[19:53] <[particle]> <!$.Foo bar>

[19:53] <pmurias> what does $.Foo mean?

[19:54] *** prly_ joined
[19:54] <Juerd> has $.Foo = rx/.../;  #?

[19:54] <pmurias> and bar?

[19:54] <Juerd> Argument.

[19:56] <pmurias> would rule && <!exception> be enough for ebnf exceptions

[19:56] <pmurias> ?

[19:56] <pmurias> s/would/wouldn't/

[19:57] <Juerd> If there was an intelligent "exception" rule

[19:57] <TimToady> would have to recognize assertions and supply an implicit .*

[19:58] <TimToady> might be enough to simply recognize that the assertion would always fail and warn them that they need .*

[19:58] <pmurias> explain please

[19:58] <[particle]> heh, rerehash

[19:58] <TimToady> an && requires the same length on both sides, or it's just a lookahead

[19:59] <TimToady> foo && ^ can never match, for instance, even at the beginning of the string.

[19:59] <TimToady> foo && ^.* would match after 3 chars though

[20:02] <fglock> avar: hi

[20:06] <pmurias> i understand that part, \w+ && <not aaa> #{<not ...> is make up} , shouldn't match aaa but should match aaaa

[20:06] *** perlmonkey2 left
[20:08] <pmurias> a none-zero width <!...> would help here

[20:08] <TimToady> that would depend on how 'not' views the implicit anchors supplied by &&

[20:09] <Juerd> pmurias: What would the width be? :)

[20:10] <[particle]> maybe &&& provides anchors to the rhs ;)

[20:10] <Juerd> And maybe &&&& adds verbose debugging

[20:11] <[particle]> :)

[20:11] *** prly joined
[20:11] <[particle]> foo <dwim> bar

[20:12] <Juerd> (And all this time, I'm not even 100% sure that EBNF works this way...)

[20:13] <TimToady> as long as we can express either meaning, we're fine :)

[20:14] <Juerd> True

[20:14] <Juerd> And even if EBNF should not work this way, it'll still be a useful construct.

[20:15] <TimToady> we do need to try to pay attention to declarative vs procedural assumptions though.

[20:20] *** Belaf joined
[20:21] <pmurias> Juerd: got pretty confused, * most likly

[20:21] <pmurias> :)

[20:29] <ajs_> TimToady: So, in the above, you want to perform a match against a match that happened previously? e.g. "string contains some number of digits where the matched digits contain the sequence '123'"?

[20:30] <ajs_> And the concern is that / (\d+) <{$0 ~~ /123/}> / is not supportable in non-Perl Rule users?

[20:30] <TimToady> yes

[20:30] <Juerd> Pretty much

[20:34] <TimToady> but also that things with closures must be analyzed as procedural rather than declarational.

[20:35] <[particle]> declarative?

[20:35] <[particle]> same thing, right?

[20:35] <TimToady> nod

[20:36] <[particle]> hrmm this reminds me of how pge jumps between top-down, bottom-up, and custom parsers

[20:37] <[particle]> provide a rule that signals the transition

[20:37] <ajs_> You could get the same effect by issuing the two patterns together and never referncing $0 at all. e.g. / (\d+ <contains 123>) / The start-of-group gives a handy anchor for the <contains> to start from

[20:38] <Juerd> Is «» taken yet? 

[20:39] <TimToady> not at the moment

[20:40] <Juerd> *evil grin*

[20:45] <nwc10> oh, what is »|« ?

[20:45] <Juerd> nwc10: Do you know what »+« is?

[20:45] <ajs_> Juerd: What came between Is and taken? I think I may have font/character set issues here.

[20:45] <nwc10> [I hope I got the utf-8 right. I'm happily in luddite latin-1 land]

[20:45] <Juerd> ajs_: <<>>

[20:45] <nwc10> juerd it's hyper plus, of some sort

[20:46] <Juerd> nwc10: Yes. »|« is hypered pipe, the disjunction constructor

[20:46] <nwc10> so you'd get a list of disjunctions, from the lists on either side of the operator?

[20:47] <Juerd> Yep

[20:47] *** turrepurre joined
[20:54] <fglock> how about if '&&' didn't require the end position to be the same; just set the resulting pos to the longest pos

[20:54] <TimToady> then it's no different from a lookahead

[20:55] <TimToady> (assuming you know which is shorter)

[20:55] <TimToady> and doesn't really solve the "not" problem.

[20:56] <Juerd> :not

[20:56] <Juerd> m:not/foo/

[20:56] <Juerd> <Foo> && <$<Foo> :not bar>   # nah.

[20:59] <fglock> what if you say that '&&' operates on whatever is matched by the left side

[21:00] <[particle]> sounds like ~~ to me

[21:00] *** ajs joined
[21:01] <Juerd> fglock: That was my initial idea, but apparently there are uses for an && that works as currently specced

[21:01] <fglock> but I think these uses are now covered by '&'

[21:02] *** fglock left
[21:04] *** dduncan joined
[21:05] <TimToady> bbl &

[21:06] *** Psyche^ joined
[21:08] *** geoffb joined
[21:22] *** Psyche^ is now known as Patterner

[21:39] *** devogon joined
[21:44] *** buetow joined
[21:50] *** pelagic joined
[21:59] <pelagic> msg nickserv register <your-password>

[22:00] *** Alneyan joined
[22:31] *** Psyche^ joined
[22:42] *** nwc10 left
[22:42] *** forsaken joined
[22:47] *** Psyche^ is now known as Patterner

[22:57] *** ProperNoun joined
[23:09] *** drupek12 joined
[23:21] *** macli left
[23:23] *** Limbic_Region joined
[23:30] *** perlmonkey2 joined
[23:30] <Limbic_Region> ?seen stevan_

[23:30] <lambdabot> stevan_ is in #perl6. I don't know when stevan_ last spoke.

[23:30] <Limbic_Region> he spoke last night - to me in fact

[23:30] <lambdabot> Limbic_Region: You have 1 new message. '/msg lambdabot @messages' to read it.

[23:30] <Limbic_Region> @moosages

[23:30] <lambdabot> diakopter said 10d 10h 8m 22s ago: :P

[23:31] <Limbic_Region> lambdabot is b0rk

[23:31] <Limbic_Region> I already received that message and yet a different message that gaal left for me is no where to be found

[23:33] <Limbic_Region> @messages

[23:33] <lambdabot> You don't have any new messages.

[23:33] <Limbic_Region> liar

[23:34] *** [particle] left
[23:38] *** mjk joined
[23:55] <allbery_b> lambdabot did get restarted at some point

[23:55] <allbery_b> probably lost some state :(

[23:57] *** ruoso joined
[23:58] *** larsen_ joined
