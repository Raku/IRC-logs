[00:00] <nothingmuch> veritos: i speak hebrew too

[00:00] <nothingmuch> as does gaal

[00:00] <nothingmuch> roiem

[00:00] <nothingmuch> lightstep

[00:00] <nothingmuch> a few others, too

[00:01] <TimToady> still, there are probably a few more speakers of Chinese of one sort or another...

[00:01] <veritos> fine, hebrew (4+) beats hanyu (2 known)

[00:01] <TimToady> though maybe not here

[00:01] <nothingmuch> prolly true

[00:01] <nothingmuch> oh, globally def. true =)

[00:02] <TimToady> let's see, there's audreyt and clkao and xinming and...

[00:02] <nothingmuch> but us jews with our jew gold and our, uh... yamacas run the world, donchaknow ;-)

[00:03] <nothingmuch> *yawn*

[00:03] <nothingmuch> sleepy time

[00:06] <TimToady> but in AUTHORS there are an amazing number asian names from both ends of asia...

[00:09] <veritos> can miniperl6 be lexed by straight yacc?

[00:11] <TimToady> you mean parsed?  yacc generally needs an external lexer.  but I think miniperl6 is sufficiently regular to allow it.

[00:11] <veritos> sorry, what was that? i hit /clear too soon

[00:12] <TimToady> you mean parsed?  yacc generally needs an external lexer.  but I think miniperl6 is sufficiently regular to allow it.

[00:12] <veritos> i meant lex, sorry

[00:12] <veritos> i'm trying to write in straight regexes

[00:12] <TimToady> I'm not actually a lex expert--always rolled my own lexers.  but I suspect lex can do it

[00:12] <veritos> hmm.

[00:13] <TimToady> especially given that lex has the ability to have multiple modes.

[00:13] <veritos> go, little lexer. go!

[00:13] <TimToady> you might need to distinguish terms from operators though.

[00:14] <TimToady> you could just bypass all this, translate src/perl6/Perl-6.0.0-STD.pm to Python, and you'd be done.  :)

[00:14] <veritos> i go lower level, shouldn't be a problem. i'm even lexing $foo as [T_DOLLAR_SIGN, T_WORD_STUFF]

[00:15] <veritos> urgh, python is evil sometimes.

[00:15] <TimToady> well, sure, that's why you want to write Python in Perl 6, right?  :)

[00:15] <veritos> other way around

[00:16] <veritos> i don't go for that whole laziness thing ;)

[00:16] <geoffb> veritos: that may have been a hint.  ;-)

[00:16] <veritos> fglock asked me to do MiniPerl6 first anyway, so that's what i'm doing now

[00:16] *** BooK joined
[00:17] <TimToady> don't have any problem with that, which is why my "hint" has a smiley on it.

[00:18] <veritos> i like ruby; it just tries to be _too_ clean. my biggest problem with it though is that functions aren't first class...you need to use blocks, which have a different call syntax

[00:19] <jjore-w> Blocks aren't just another kind of function?

[00:19] <TimToady> In Perl 6 they're called the same but the return syntax has to differ

[00:19] <jjore-w> er, object?

[00:19] <TimToady> specifically "return" has to return from the "official" function, not the blocks embedded within it.

[00:20] <TimToady> so to return from a block requires "leave" instead.

[00:20] <veritos> oh, and ruby -current stole our new block syntax (->(){}) too! except they call it 'stabby'.

[00:21] <TimToady> I think they require parens too

[00:21] <geoffb> murderous lot ...

[00:21] <veritos> TimToady: no, you can get away without.

[00:21] <bsb> hi can someone do: svn propset svn:mime-type image/png pugs/project_planning/a_dependency_graph.png

[00:21] * geoffb half expecting the atheme and katana syntax to follow soon ...

[00:22] <veritos> http://www.dabeaz.com/ply/ - i'm saved!

[00:22] <lambdabot> Title: PLY

[00:23] <veritos> can i stick something that's LGPL straight in the pugs tree (in source form, but intended as a separate library) or would that 'pollute' everything else?

[00:25] <TimToady> as long as it's only ever dynamically linked, I don't see a problem with it

[00:26] *** veritos joined
[00:28] <TimToady> veritos: as long as it's only ever dynamically linked, I don't see a problem with it

[00:29] <veritos> TimToady: it's basically a .pm lib, but for python

[00:31] <TimToady> bsb: svn: 'pugs/project_planning' is not a working copy

[00:31] <TimToady> It's also okay to have it as an external dependency...

[00:32] <veritos> what would you do in this case?

[00:33] <TimToady> would depend on how stable I thought the original was, and how stable its source webpage.

[00:33] *** semifor joined
[00:34] <veritos> it was intended as a teaching tool originally it says. http://www.dabeaz.com/ply/ if you want more

[00:34] <veritos> that's the author's site

[00:35] <lambdabot> Title: PLY

[00:35] <TimToady> bsb: okay, figured out I should delete the pugs/  :)

[00:36] <TimToady> I will let you decide--that's why you have a commit bit.  :)

[00:36] <TimToady> but I don't think the license is a problem offhand.

[00:37] <veritos> sounds good...i'll put my email in the readme so he can whine to me if he has a problem with it. he's a teacher though, i think he'll be fairly reasonable. (one of the SWIG guys too!)

[00:38] <bsb> http://svn.pugscode.org/pugs/project_planning/a_dependency_graph.png works now

[00:39] <lambdabot> http://tinyurl.com/2z58bw

[00:40] <TimToady> so it would seem here too, thanks

[00:48] *** xdg joined
[00:51] *** amnesiac joined
[01:01] *** dolmans joined
[01:09] <TimToady> A cow. A trampoline.  Together they fight.  A crime.

[01:18] *** Lunchy joined
[01:36] *** lisppaste3 joined
[01:43] *** bonesss joined
[02:10] *** SubStack joined
[02:13] *** rissy joined
[02:22] *** geoffb joined
[02:40] *** veritos joined
[02:40] <veritos> hello again

[02:42] *** Limbic_Region joined
[02:48] *** toshinori joined
[02:54] *** mako132_ joined
[02:56] <veritos> what happened to the svn bot?

[02:57] <veritos> and is anyone else working today? my tree's been up to date all 5 times i've updated it.

[03:02] *** elmex_ joined
[03:19] <dduncan> I'm working today

[03:21] * offby1 is loafing today ... as most days

[03:30] *** agentzh joined
[03:32] *** Alias_ joined
[03:32] <TimToady> most of my work happens when I'm loafing

[03:32] <agentzh> iblech, malon: the synopses on the smoke server have run out of order (see the ones under "repository snapshot / linux"). thanks.

[03:33] <dduncan> I like bread

[03:33] <dduncan> which comes in loaves

[03:36] *** veritos joined
[03:37] <veritos> hey guys and gals...just got another v6-Python commit. it now (sort of) parses (a bit of) MiniPerl6 and outputs an ugly mass that somewhat resembles Ruby. have a looksee: pugsroot/v6/v6-Python

[03:39] <veritos> and if you looked, try svn up - ing your tree again.

[03:40] <veritos> and again.

[03:42] <veritos> anyone actually on?

[03:42] * offby1 wishes he could write off loafing as work

[03:44] <veritos> offby1: psst....svn up.

[03:44] <veritos> cd ~

[03:44] <pasteling> "evalbot_r16100" at 194.145.200.126 pasted "Pugs build failure" (3808 lines, 445K) at http://sial.org/pbot/24451

[03:44] <veritos> cd pugs

[03:44] <pasteling> "evalbot_r16100" at 194.145.200.126 pasted "Pugs build failure" (3803 lines, 445K) at http://sial.org/pbot/24452

[03:44] <veritos> cd v6

[03:44] <veritos> cd v6-Python

[03:46] *** ruoso joined
[03:46] <offby1> hmm

[03:46] <offby1> she

[03:47] * offby1 svk pulls

[03:48] <veritos> i think i'm the only one who's committed in the last ~6 hours

[03:48] <TimToady> no, dduncan has too

[03:49] <veritos> oh, people are here.

[03:49] <dduncan> yes, several times

[03:49] <dduncan> in fact, I hope to make a release today

[03:49] <veritos> what's your little pet, pun intended, project? or did you mean for pugs in general?

[03:49] <Patterner> yay for releases

[03:50] <dduncan> QDRDBMS is a module in synchronized Perl 5 and 6 versions ... the Perl 5 version will probably be released on CPAN today, but the announcement will mention both versions, so people who want the Perl 6 one can go to the Pugs repository, and the Perl 5 one is on CPAn as usual

[03:50] <veritos> oh

[03:51] <veritos> fun...

[03:51] <veritos> oh, alright...tree needed updating a couple sec ago

[03:52] <dduncan> I also see it as appropriate to post the announcement on Perl 5 and Perl 6 lists ... in the former case, it would be database related lists, in the latter case, I figured perl6-announce plus perl6-users would be the most appropriate ... I assume that perl6-language won't be an appropriate place to announce ... not for this release anyway

[03:53] <dduncan> a few releases later, p6l would be appropriate, because at that time QDRDBMS would include implementations of data types that I've been suggesting for mainline language support

[03:53] <dduncan> that is, the relation data type

[03:53] <dduncan> but the initial release won't have that, it is more of a skeleton

[03:54] <veritos> how do you type QDRDBMS so fast? kind of a mouthful.

[03:54] <dduncan> I'm used to it

[03:55] <dduncan> in any event, that name is temporary, to be replaced with somethng easier to type later

[03:57] <wolverian> what's it "short" for? :)

[03:57] <dduncan> oh, and I'm not the packager of Pugs ... basically just audreyt releases that

[03:57] <veritos> i see.

[03:58] <dduncan> I'll give you a hint ... the first 2 letters mean the same as in QDOS, the latter 5 are readily understood if you know the module is about databases

[03:58] <dduncan> and that may tell you why the name is temporary

[03:58] <wolverian> yeah, it's the first two I'm unfamiliar with

[03:59] <dduncan> Quick and Dirty Operating System ... which was later renamed to MS DOS

[03:59] <wolverian> ah :)

[03:59] <dduncan> the name denotes that this work is currently pre-alpha state

[03:59] <dduncan> or particularly that I've cut certain corners on purpose in order to get something working out sooner

[04:00] <dduncan> when those omissions are corrected and the project is more mature, it will be renamed

[04:00] <dduncan> and so people aren't surprised, I state this intention in the project's README file

[04:02] <dduncan> the other thing is that I haven't 100% decided what the longer term name will be, so I picked a bad short term name on purpose so people won't want to stick with it longer term

[04:02] <dduncan> that is all

[05:07] <gaal> veritos: actually (+) is not Num -> Num -> Num because Num is a typeclass, not a type.

[05:07] <gaal> @type (+)

[05:07] <lambdabot> forall a. (Num a) => a -> a -> a

[05:08] <gaal> you can ignore the forall a here; what this signature means is that for any type a that you pick, the signature is a -> a -> a so long as a happens to belong to Num.

[05:09] <gaal> where "belong to Num" means that you have "instance Num ThatDatatype where .. " and definitions of at least the minimum nexessary functions

[05:18] *** laye joined
[05:21] *** SubStack joined
[05:51] *** buubot joined
[05:54] *** Aankhen`` joined
[06:11] *** rfordinal_ joined
[06:13] *** BooK_ joined
[06:30] *** franck__ joined
[06:35] *** franck___ joined
[06:40] *** BooK__ joined
[06:44] *** benny joined
[06:46] *** devogon joined
[06:51] *** drupek12 joined
[07:05] *** drupek12 joined
[07:06] *** rfordinal_ is now known as rfordinal

[07:06] *** sapir joined
[07:09] *** rissy joined
[07:10] *** marmic joined
[07:19] *** buetow joined
[07:20] *** justatheory joined
[07:21] *** jisom joined
[07:35] *** iblechbot joined
[08:10] *** Daveman joined
[08:19] *** buetow joined
[08:23] *** awwaiid_ joined
[08:36] *** rfordinal_ joined
[08:53] *** zamolxes joined
[09:02] *** Salzh joined
[09:23] *** toshinori joined
[09:25] *** dduncan left
[09:56] *** demq joined
[10:13] *** ludan joined
[10:14] <ludan> hola

[10:14] <moritz> moin ;-)

[10:15] *** midellaq joined
[10:17] *** devogon joined
[10:23] *** mj41 joined
[10:27] *** polettix joined
[10:33] *** jisom_ joined
[10:48] *** ruoso joined
[10:50] *** BooK joined
[10:55] *** BooK_ joined
[11:05] *** ayrnieu joined
[11:15] *** chris2 joined
[11:27] *** iblechbot joined
[11:28] *** rfordinal_ is now known as rfordinal

[11:32] <pasteling> "evalbot_r16106" at 194.145.200.126 pasted "Pugs build failure" (278 lines, 15.8K) at http://sial.org/pbot/24459

[11:32] *** ruoso joined
[11:32] <moritz> I think we need a file in the pugs repository where different tasks are listed, and who usually takes care of them

[11:33] <moritz> for example evalbo, irclogs, smartlinks, autosmokes etc.

[11:34] <avar> /SLAVES

[11:34] <moritz> good name ;-)

[11:34] <moritz> bbiab&

[11:36] <OwlEye> autosmokes sounds interesting :)

[11:36] *** fglock joined
[11:43] *** mako132_ joined
[11:46] *** the_dormant joined
[11:48] <fglock> veritos: ping

[11:49] <fglock> veritos: in case you backlog:

[11:49] <fglock> mp6 can be bootstrapped by writing an emitter for the target language (Python)

[11:50] <fglock> and then recompile the mp6 source code to python

[11:50] <fglock> that is, you don't need to rewrite the whole compiler

[12:08] *** buetow joined
[12:11] *** fglock__ joined
[12:11] *** fglock__ left
[12:11] *** fglock__ joined
[12:13] *** fglock___ joined
[12:17] *** fglock__ left
[12:17] *** fglock joined
[12:27] *** vel joined
[12:28] <avar> (multiple emitters)++ fglock++

[12:59] *** semifor joined
[13:04] *** BooK joined
[13:16] *** jerrylee joined
[13:19] *** HiTech69 joined
[13:36] <fglock> the current version of kp6 can convert perl6 OO into pure procedural code - makes it easier to support 'simple' backends

[13:37] <avar> how does kp6 relate to mp6? Isn't the aim of kp6 to not require mp6?

[13:37] <moritz> I think kp6 is written in miniperl6, right?

[13:38] <fglock> kp6 is currently the language in which kp6 is written

[13:38] <fglock> mp6

[13:38] <fglock> moritz: yes :)

[13:38] <avar> don't trip over each other:)

[13:41] <fglock> kp6 has better semantics, but requires less backend support; OTOH, it does more emulation and can be slower

[13:42] <fglock> but the level of emulation is configurable

[13:42] <avar> how were you doing with the parrot backend? Past hello world?:)

[13:43] <fglock> avar: with the latest kp6 changes, it could now support full OO

[13:43] <moritz> PIR hello world? ;-)

[13:43] <fglock> the latest tested code is:

[13:44] <fglock> http://svn.pugscode.org/pugs/v6/v6-MiniPerl6/examples/p6parrot.pl

[13:50] <fglock> the current plan is: kp6 -> non-OO mp6 -> p6parrot

[13:55] <avar> fglock: does it emit pir that you can then run without [mp]p6?

[13:56] <fglock> I could not make p6parrot emit pir yet; not sure if it's my fault...

[13:57] <fglock> but mp6 emits simple-p6 that p6parrot can run

[13:57] <fglock> without mp6

[14:03] *** rlb3_work joined
[14:20] *** rlb3_work joined
[14:21] *** [particle] joined
[14:24] *** perlmonkey2 joined
[14:28] *** fglock_ joined
[14:29] *** DarkWolf84 joined
[14:30] *** rindolf joined
[14:30] <rindolf> Hi all.

[14:30] *** hcarty joined
[14:30] <moritz> hi rindolf

[14:30] <rindolf> Hi moritz 

[14:30] <rindolf> moritz: sup?

[14:31] <moritz> rindolf: nothingmuch ;-)

[14:31] <rindolf> moritz: OK.

[14:32] *** fglock__ joined
[14:32] <rindolf> I've started working on http://perl.net.au/wiki/Tactfulness_for_Geeks

[14:32] <lambdabot> Title: Tactfulness for Geeks - PerlNet

[14:34] <moritz> rindolf: that's like trying to preach to the devel ;-)

[14:34] <geoffb> moritz: oh, man, that one *hurt*

[14:35] <moritz> geoffb: no harm intended ;-)

[14:38] <nothingmuch> rindolf: tactfulness doesnt involve protocols and latency, it involves applying a filter to what you say

[14:39] <nothingmuch> 90% of the time you can avoid needless confrontation by just stfuing for another 10 seconds and thinking if that's really what you want to or should say, and if that's how you want to say it

[14:39] <nothingmuch> and that applies to real life also

[14:39] <nothingmuch> i don't think the concept of tact varies from one medium to another

[14:40] <nothingmuch> and also, i believe it's media, not mediums (i think mediums is plural for the synonym of the fortune teller)

[14:40] <nothingmuch> at least that's the only way i've seen it used that way withoutu being corrected by others quickly

[14:41] <rindolf> nothingmuch: often if you don't say anything it will be worse than saying something.

[14:41] <rindolf> nothingmuch: tact is not only about shutting up.

[14:42] <rindolf> nothingmuch: which you should know if you've read PG.

[14:42] <nothingmuch> PG?

[14:42] <moritz> rindolf: but in 90% of the cases shutting up helps ;-)

[14:43] <nothingmuch> for what it's worth I don't agree, it's very uncommon that saying something is better than saying nothing if there's a dillema between the two

[14:43] <moritz> ?eval my @a = 1..3; @a»++

[14:43] <evalbot_r16111> (*** Can't modify constant item: VInt 1␤    at <eval> line 1, column 15 - line 2, column 1, *** Can't modify constant item: VInt 2␤    at <eval> line 1, column 15 - line 2, column 1, *** Can't modify constant item: VInt 3␤    at <eval> line 1, column 15 - line 2, column 1)

[14:43] <nothingmuch> and I didn't say it was only, i said it was mostly

[14:43] <moritz> should that work?

[14:43] <nothingmuch> moritz: yes, it should

[14:43] <moritz> ?eval my @a = 1..3; @a=@a»+1

[14:43] <nothingmuch> oh wait

[14:43] <evalbot_r16111> Error: ␤Unexpected "\187+"␤expecting "::", term postfix, operator or ","

[14:44] <nothingmuch> ?eval my @a = (1..3); @a»++

[14:44] <evalbot_r16111> (*** Can't modify constant item: VInt 1␤    at <eval> line 1, column 17 - line 2, column 1, *** Can't modify constant item: VInt 2␤    at <eval> line 1, column 17 - line 2, column 1, *** Can't modify constant item: VInt 3␤    at <eval> line 1, column 17 - line 2, column 1)

[14:44] <nothingmuch> hmm, no

[14:44] <nothingmuch> i remember something vague about binding semantics in array assignment

[14:44] <rindolf> perlbot: ph

[14:44] <rindolf> perlbot: pg

[14:44] <nothingmuch> but i'm out of touch

[14:44] <rindolf> nothingmuch: PG == Paul Graham

[14:44] *** hcarty left
[14:44] <moritz> but the version with @a»+1 should work, right?

[14:45] <nothingmuch> rindolf: i doubt paul graham could teach me much about tact or life in general, my parents have first dibs

[14:45] <rindolf> nothingmuch: "A wise man can learn from a fool, much more than a fool can ever learn from a wise man".

[14:45] <rindolf> nothingmuch: and Paul Graham is very wise.

[14:45] <nothingmuch> also, most of what I read by him (and it wasn't much) may have been interresting, but I definitely didn't consider it to be The Word

[14:46] <nothingmuch> so, if i read his stuff he will learn from me? ;-)

[14:46] <rindolf> nothingmuch: http://www.paulgraham.com/nerds.html

[14:46] <lambdabot> Title: Why Nerds are Unpopular

[14:46] <rindolf> nothingmuch: I didn't say he was the absolute truth.

[14:46] <rindolf> nothingmuch: but I got many important insights from him.

[14:47] <rindolf> nothingmuch: no. Not unless you blog about it or whatever.

[14:47] <rindolf> nothingmuch: and he reads it.

[14:47] <rindolf> nothingmuch: I don't consider you a fool.

[14:47] <rindolf> What my quote means is that a wise man always learns more than a fool.

[14:47] <rindolf> A fool is stubborn, he's not open.

[14:48] <nothingmuch> i know what it means, i was kidding

[14:48] <rindolf> He may be very intelligent.

[14:48] <rindolf> nothingmuch: oh. Sorry.

[14:48] <rindolf> :-)

[14:48] <rindolf> /me can sometimes not detect when people are saying stuff tongue-in-cheek

[14:48] <nothingmuch> that's why i put the smiley in there

[14:49] <nothingmuch> internet lacks tone

[14:49] <nothingmuch> PG's problem is that he writes a lot of text to convey a simple idea

[14:52] <nothingmuch> ah, there we go

[14:52] <nothingmuch> i agree with that paragraph in spirit

[14:52] <nothingmuch> "In fact, it's derived from the same root as "tactile," and what it means is to have a deft touch. Tactful is the opposite of clumsy. I don't think I learned this until college."

[14:52] <nothingmuch> to me that means knowing when to shut up and when to speak up

[14:52] <nothingmuch> not to shut up most of the time

[14:52] *** toshinori joined
[14:53] <pasteling> "evalbot_r16111" at 194.145.200.126 pasted "Pugs build failure" (6 lines, 228B) at http://sial.org/pbot/24466

[14:57] <fglock_> nothingmuch: I wrote a very simple OO model for kp6, it would be nice if you could review it

[14:57] <nothingmuch> sure

[14:58] <fglock_> run tests in v6/v6-KindaPerl6, with 'sh run_tests.sh'

[14:59] <fglock_> the lib is: http://svn.pugscode.org/pugs/v6/v6-KindaPerl6/lib/KindaPerl6/Perl5/MOP.pm

[14:59] <lambdabot> http://tinyurl.com/2apyw6

[15:00] <rindolf> nothingmuch: it also means knowing what is the right thing to say.

[15:00] <rindolf> nothingmuch: and how to say it.

[15:00] <rindolf> nothingmuch: what's up, BTW?

[15:01] <nothingmuch> knowing what the right thing to say and when to say it is omiscience

[15:01] <nothingmuch> tacfulness, for me, is minimising damage when you're not 100% sure

[15:01] <rindolf> nothingmuch: pardon?

[15:01] <nothingmuch> when you know the right thing to say there's no need for tact

[15:01] <rindolf> nothingmuch: you can often say the same thing in two different ways, and one of them will be much better.

[15:02] <rindolf> nothingmuch: no, but you can often have a good judgement of what is better to say.

[15:02] <rindolf> How will people interpret it, etc.

[15:02] <nothingmuch> in practice I find that is often not such a big problem as the other half

[15:02] *** toshinori left
[15:03] <nothingmuch> fglock_: why go back to "traditional" OO

[15:03] <rindolf> nothingmuch: I agree with you that not saying anything is something you have to do.

[15:03] <nothingmuch> ?

[15:03] <rindolf> nothingmuch: as opposed to prototype-based OO?

[15:03] <rindolf> Or what?

[15:04] <nothingmuch> as opposed to the generalized metamodel thing that was the result of roughly 2 years of continual redesign by stevan and then by me

[15:04] <nothingmuch> which is capable of both classy OO and prototype OO

[15:05] <nothingmuch> and handling things like AUTOLOAD easily

[15:06] <fglock_> nothingmuch: I was after something that I could implement fast; I mean to upgrade the model later

[15:07] <nothingmuch> why not reuse MO? it's already implemented

[15:08] <fglock_> nothingmuch: I need to translate this to MiniPerl6; it's easier to translate my own code (not a good excuse)

[15:08] <nothingmuch> fairynuff

[15:09] <nothingmuch> it

[15:09] <[particle]> fglock: i think that's one reason other folks aren't helping you much (you keep translating your own stuff)

[15:09] <nothingmuch> s just a bit of a shame to see a regression in terms of the limitations we tried to take out

[15:10] <fglock_> [particle]: mp6 is the stable implementation

[15:11] <[particle]> nm: is MO the latest and greatest metamodel?

[15:11] <[particle]> or class::mop?

[15:11] <fglock_> nothingmuch: do you think I can keep the API and change the implementation later?

[15:11] <clkao> Win 47

[15:11] <rindolf> http://www.m-w.com/cgi-bin/dictionary?book=Dictionary&va=medium - Inflected Form(s): plural mediums or me·dia  /-dE-&/

[15:11] <lambdabot> Title: Definition of medium - Merriam-Webster Online Dictionary

[15:12] <nothingmuch> [particle]: MO is later

[15:12] <nothingmuch> Class::MOP is perl 5 specific

[15:12] <nothingmuch> MO is inspired by it (and as such by CLOS and smalltalk's metamodel)

[15:12] <nothingmuch> but attempts to make compile time and runtime separatable

[15:13] <[particle]> great. maybe i'll port MO to parrot

[15:13] <nothingmuch> the part that should be ported first is very very simple -- reusable responder interfaces

[15:13] <[particle]> now that we have a fancy new object model

[15:13] <nothingmuch> (not necessarily the ones I sketched in p5)

[15:13] <nothingmuch> responder interfaces are dumbed down versions of classes meant to be easy to dispatch on

[15:13] <nothingmuch> fglock_: MO's API requires a new layer

[15:14] <nothingmuch> what you sketched seems to be like the responder interface layer

[15:15] <[particle]> where is MO?

[15:15] <nothingmuch> http://nothingmuch.woobling.org/MO/

[15:15] <lambdabot> Title: Index of /MO

[15:15] <[particle]> cpan search is less than helpful

[15:15] <[particle]> great!

[15:15] <nothingmuch> it's not CPAN worthy yet

[15:15] <[particle]> ah, i see

[15:15] <nothingmuch> $work ;-)

[15:15] <nothingmuch> the problem is that the "stock" objects for Class, etc are more experiments

[15:15] <nothingmuch> to stretch the boundries isntead of provide a good base

[15:15] <nothingmuch> it's noncomittal

[15:16] * [particle] reads the ten thousand inch view

[15:16] <nothingmuch> http://nothingmuch.woobling.org/MO/lib/MO/Overview.pod

[15:16] <nothingmuch> ?

[15:16] <[particle]> yep

[15:16] <nothingmuch> lk

[15:16] <nothingmuch> oi, i see

[15:16] <[particle]> s/"/'/

[15:16] <nothingmuch> ;-)

[15:16] <nothingmuch> patches welcome

[15:16] <nothingmuch> ;-)

[15:16] <fglock_> nothingmuch: I'm mostly interested in working 'Code' objects right now; the model can be improved later

[15:17] <nothingmuch> fglock_: fairynuff, i agree that the perfect is the enemy of the good

[15:17] <nothingmuch> but I would make sure you are not using the meta model in a way that is too restricting for an MO style one to come by later

[15:18] <nothingmuch> theoretically in MO you can swap out your entire object system (new concept of method calls, new concept of objects, new concept of "concepts" (defining meta objects such as prototype objects or classes))

[15:18] <nothingmuch> without stepping over the language's native ones

[15:18] <nothingmuch> (part of the inspiration was parrot's intended multiple language thing, and the problems that might arise from that)

[15:18] <fglock_> is there something I should change right now?

[15:18] <nothingmuch> it's tricky to say

[15:19] <nothingmuch> i don't know kp6 or your mop very well

[15:19] <[particle]> nm: in parrot, Class and Object are coupled... if you override one, you need to override the other. is this common?

[15:19] <nothingmuch> [particle]: Class is the class of the meta class and Object is the class that is the base class of all instances?

[15:20] <nothingmuch> fglock_: the problem with MO is that it works in cycles

[15:21] <nothingmuch> the compiler or the runtime creates meta objects whose job is to retain the declarative data closely

[15:21] <nothingmuch> kinda like a high level AST

[15:21] <[particle]> nm: yes, iirc

[15:21] <nothingmuch> [particle]: in the current example metaclass (Class::MI and Class::SI) there is no concept of a base class of everything

[15:21] <nothingmuch> instead "core" methods are generated

[15:21] <nothingmuch> but this can be changed

[15:22] <nothingmuch> as for whether or not it's common - oi

[15:22] <nothingmuch> i've never seen that restriction before

[15:22] <nothingmuch> i don't think it matters much

[15:22] <nothingmuch> if you subclass Class into e.g. My::ORM::Metaclass

[15:22] <nothingmuch> then maybe $db_bound_object has a separate default meta class

[15:22] <nothingmuch> but maybe it doesn't and it's just the meta protocol (e.g. accessor generation) that's being changed

[15:23] <nothingmuch> i think they are orthogonal but that it's not a horrible restriction to enforce

[15:23] <nothingmuch> ... fglock_:

[15:23] <nothingmuch> these objects may refer to eachother (by value or by name, it doesn't matter)

[15:23] <nothingmuch> for things like subclassing, etc

[15:23] <nothingmuch> then you compute standalone structures from these

[15:24] <nothingmuch> either at compile time in advance or as necessary during boxing

[15:24] <nothingmuch> and you reference this structure from the object's type box

[15:24] <nothingmuch> instead of the original metaclass

[15:24] <nothingmuch> if you keep this runtime/compile time separation possible (even if it's all runtime for now) then you should be able to plug MO later by just generalizing the method call opcioode

[15:25] <nothingmuch> but there needs to be room for the multiple pass arch

[15:25] <nothingmuch> you should probably ask audreyt for advice, if she knows your stuff better

[15:25] <nothingmuch> because she also knows MO well

[15:25] <nothingmuch> btw, how is ingy? does anybody have an update?

[15:26] <fglock_> nothingmuch: thanks

[15:26] <nothingmuch> btw, don't take this the wrong way but WRT the perfect being the enemy of the good

[15:26] <nothingmuch> this is the Nth mini language, right?

[15:27] <nothingmuch> at some point i think you need to try to get at least the most difficult part closer to perfect

[15:27] <nothingmuch> even if it slows you down

[15:27] <nothingmuch> because in the long run it's going to have to happen sometime

[15:28] <fglock_> nothingmuch: most difficult part == MO ?

[15:28] <nothingmuch> the most difficult part is interlocking parts that need to get bootstrapped somehow

[15:28] <nothingmuch> the compiler is written in it's own language, right?

[15:28] <fglock_> yes

[15:28] <nothingmuch> to write a compiler you want good uspport for $nifty features

[15:28] <nothingmuch> but to support these features you need a good compiler

[15:28] <nothingmuch> (parser, meta model, interpreter, emitter, yadda yadda yadda)

[15:29] <nothingmuch> all these parts depend heavily on one another and if you kludge one of them you will at some point suffer in another part due to that

[15:29] *** toshinor_ joined
[15:29] <nothingmuch> i don't think you can really write everything up front 

[15:29] *** |OUF|HiTech69 joined
[15:29] <[particle]> can't you build a better metamodel from a simpler one?

[15:30] <nothingmuch> the point is that there have already been many simpler ones

[15:30] <nothingmuch> we've learned our lessons =)

[15:30] <nothingmuch> i'm not preaching for big design up front

[15:30] <nothingmuch> but it looks a bit like we're avoiding the next big step by looking for slightly more immediate results

[15:30] <nothingmuch> s/we're/you're

[15:30] <[particle]> i'm wondering if MO can sit on top of what fglock has

[15:30] <nothingmuch> i don't deserve to claim i'm doing anything ;-)

[15:30] <nothingmuch> [particle]: yes and no

[15:31] <nothingmuch> MO sits on Moose in perl 5 land

[15:31] <nothingmuch> i've experimented with MO in perl 5 bootstrapping itself

[15:31] <nothingmuch> and it works OK too

[15:31] <nothingmuch> but the thing is that the current stuff is in perl 5, with some integration it could be reused quite easily

[15:31] <nothingmuch> eventually MO will need to get ported to perl 6

[15:31] <nothingmuch> and then get compiled by it's perl 5 counterpart

[15:32] <nothingmuch> and then it can compile itself

[15:32] <[particle]> and if it's ported to kp6, then that can happen *soon*

[15:32] <nothingmuch> whereas in the current scenario it looks like the simpler model will get converted to perl 6, and then MO will be written in that, and then it will be integrated

[15:33] <fglock_> nothingmuch: I think the simpler model can be converted to MO by hand, with some help of the compiler

[15:34] <nothingmuch> i don't see how the compiler helps

[15:34] <nothingmuch> but suure, it can be converted later

[15:34] <nothingmuch> the question is at what cost

[15:34] <nothingmuch> and if it's really cheaper (time wise) to do that later instead of now

[15:35] <fglock_> the compiler just takes care of the syntax sugar

[15:35] <nothingmuch> superficially

[15:35] <fglock_> I'm ok to do it now,

[15:35] <nothingmuch> in practice it's also about the compilation structures' lifecycles

[15:35] <fglock_> kp6 milestones are all met,

[15:35] <nothingmuch> which are crucial for MO to be used correctly

[15:35] <fglock_> so there is no reason not to do it now

[15:35] <nothingmuch> i can't help right now ($work schedule is hard)

[15:36] <nothingmuch> but maybe come may 15th i'll have more time to hack again

[15:36] <nothingmuch> things to keep in mind -- a port of MO does not necessitate direct porting of the classes therein

[15:36] <nothingmuch> it's mostly about the most basic design decisions

[15:36] <nothingmuch> and about responder interfaces (which are the easiest part to port)

[15:36] <nothingmuch> so you can simplify MO to very few LOCs, i think

[15:37] <nothingmuch> and it remains extensible when the language requires richer meteaclasses

[15:37] <[particle]> nm: based on this conversation, and your work on MO, i'd appreciate your comments on PDD15. think you can give it a look when you have time?

[15:37] <nothingmuch> [particle]: i'll give it a shot

[15:37] <nothingmuch> link?

[15:37] <fglock_> what if I ported some MO tests to kp6, and worked on it

[15:38] <[particle]> http://www.parrotcode.org/docs/pdd/pdd15_objects.html

[15:38] <lambdabot> Title: Object and Class semantics for Parrot - parrotcode:

[15:38] <nothingmuch> fglock_: i think the smartest thing to do is to take your model

[15:38] <nothingmuch> and refactor it to use MO style cycles

[15:38] <nothingmuch> that way you don't need to make big changes later

[15:38] <nothingmuch> and you don't need to adopt a foreign code base alltogether

[15:39] <fglock_> are there docs on MO style cycles?

[15:39] <nothingmuch> and you can even fake it

[15:39] <nothingmuch> because the responder interface can just be the metaclass

[15:39] <nothingmuch> it's for when it's inconvenient for the metaclass to be a responder interface that MO brings benefits

[15:39] <nothingmuch> that overview that [particle] was reading

[15:39] <fglock_> ok

[15:40] <nothingmuch> i've gone further and implemented all the objects involved in MO in a purely functional style

[15:40] <nothingmuch> so that they're portable to haskell, too

[15:40] <nothingmuch> but that's not mandatory

[15:40] <nothingmuch> (though ideally it'll be refactored back into that once it's self hosting in perl 6)

[15:41] <[particle]> we're currently redesigning the PMC object

[15:41] <nothingmuch> [particle]: skimming it it looks like Class tries to be the one true responder interface in MO speak

[15:41] <[particle]> i've just started reading about responders now in MO

[15:41] <nothingmuch> (not necessarily good or bad)

[15:42] <nothingmuch> i'll read into it more

[15:42] <fglock_> brb

[15:42] <[particle]> for PMCs, the responder interface is a vtable

[15:42] <[particle]> hrmm, actually that's incomplete

[15:42] <[particle]> it's the vtable plus non-vtable methods

[15:43] <nothingmuch> from what I remember the pmc is practically it's own responder interface

[15:43] <[particle]> we've been talking about role-based pmc composition

[15:43] <nothingmuch> becaus eit's data coupled with a type

[15:43] <ingy> nothingmuch: kiss

[15:43] <nothingmuch> ingy: yay, you're concious!

[15:44] <[particle]> hey there ingy!

[15:44] <ingy> hi

[15:45] <cls_bsd> ingy: hi !!

[15:45] <cls_bsd> and night!!!

[15:45] <nothingmuch> [particle]: the original vision is that by extending the VM or implementing responder interfaces with the VMs language (both should be possible) the metaclass author can support an idealized runtime version of the object's behaviro

[15:46] <nothingmuch> == performance

[15:46] <nothingmuch> for example compiling a flattenned vtable

[15:46] <nothingmuch> indexing method names

[15:46] <nothingmuch> etc

[15:46] <[particle]> okay

[15:46] <nothingmuch> all lead to the construction of a simpler data type

[15:46] <nothingmuch> 90% of the itme this will be a dispatch table

[15:47] <[particle]> we definitely want vtable flattening, rather than storing pointers to the vtables of the composers

[15:47] <ingy> hi cls_bsd 

[15:48] * [particle] hopes ingy has found a friend in tab-completion

[15:48] <nothingmuch> when the process is separated then the metaclass's advanced features (e.g. roles, attribute grammars, complex attributes, various construction behaviors etc) can be implemented in the host source language

[15:48] <ingy> heh

[15:48] <ingy> alwayz

[15:49] <nothingmuch> as long as the output is a simplified structure that can then be transliterated into a natively supported responder interface

[15:49] <nothingmuch> example: for every possible target class, precompute the final table of all applicable methods and save them into a tabular structure

[15:49] <nothingmuch> if optimising for size, fragment the tables into shared ones with pointers

[15:49] <nothingmuch> if optimising for speed make only one vtable for every class

[15:49] <nothingmuch> the two optimisations can coexist as long as there is either a polymorphic dispatch

[15:50] <nothingmuch> (the responder interface has a type)

[15:50] <nothingmuch> or a different opcode is generated for the method call

[15:50] <ingy> i'm not much slower typing one handed then two

[15:50] <nothingmuch> inlining the lookup logic at the callsite

[15:50] <rindolf> Hi ingy 

[15:50] <rindolf> ingy: are you feeling any better?

[15:50] <ingy> hi rindolf 

[15:50] <ingy> still hate me?

[15:50] <rindolf> ingy: I never hated you.

[15:50] <rindolf> ingy: oh, you mean about speeding?

[15:51] <ingy> ;)

[15:51] <nothingmuch> speeding is fun

[15:51] <[particle]> everyone hates ingy!

[15:51] <rindolf> nothingmuch: not on the road.

[15:51] <nothingmuch> rindolf: speeding is fun on the road

[15:51] <ingy> Ricky Bobby is my hero

[15:51] <nothingmuch> skydiving is also fun

[15:51] <rindolf> "Everyone hates Ingy döt Net"

[15:51] <[particle]> skydiving *is* fun

[15:52] <nothingmuch> risk and consequences don't necessarily deduct from the fun of the activity before they are realized

[15:52] <nothingmuch> hence speeding is fun even if it's reckless

[15:52] <ingy> nothingmuch: well said

[15:53] <nothingmuch> ingy: i've been studying for this

[15:53] <nothingmuch> played wiuth snowboards and ice axes

[15:53] <nothingmuch> i can rationalize stupid hobbies very well now =)

[15:54] <nothingmuch> [particle]: are you seeing what I'm getting at? rich semantics in the language's compiler, and low level reusable components in the runtime

[15:54] <ingy> http://www.cafepress.com/buy/movie/-/pv_design_prod/pg_1/p_storeid.69508520/pNo_69508520/id_13881091/opt_/fpt_/c_360/

[15:54] <lambdabot> Title: CafePress.com : Error, http://tinyurl.com/29lbs5

[15:54] <nothingmuch> if required the runtime can use rich semantics too, but it doesn't have to all the time

[15:54] <nothingmuch> for example in perl 5 it's rich semantics all the way (the interperter walks the stash)

[15:55] <rindolf> I've uploaded to Flickr a photo of a Hyrax I took in the Carmel : http://www.flickr.com/photos/shlomif/471195681/

[15:55] <lambdabot> Title: Hyrax in Little Switzerland on Flickr - Photo Sharing!

[15:55] <[particle]> yes, i can see it, but i'm not exactly sure how to get there

[15:55] <nothingmuch> hosting perl 5 on a MO VM will mean that the metaclass (prolly an object wrapping the stash) is probably going to be it's own responder

[15:55] <nothingmuch> whereas in C++ for example, you have the one true metaclass

[15:55] <rindolf> Licence is PD.

[15:55] <nothingmuch> that compiles to the one true responder interface

[15:55] <nothingmuch> because everything is static it's easy:

[15:55] <nothingmuch> either it's virtual and you run it through a vtable or it's just a function call with OO syntax ;-)

[15:56] <nothingmuch> but C++ is not rich

[15:56] <nothingmuch> MO tries to make both worlds possible depending on the investment the VM and the language compiler are willing to make

[15:56] <[particle]> ultimately, we'd like PMC and PIR oo to look the same, so you can use interchangeably

[15:57] <nothingmuch> i'm not sure exactly what you mean

[15:57] <nothingmuch> from whose POV?

[15:57] <[particle]> it's a bit tangential

[15:58] <[particle]> from the user's perspective

[15:58] <nothingmuch> from the user's perspective it should be possible

[15:58] <nothingmuch> (you mean the metaprogramming, compiler writing user, right? not that user's user?)

[15:58] <[particle]> yes

[15:58] <nothingmuch> .. provide implementations of RIs and metaclasses for PMCs

[15:58] <[particle]> correct.

[15:59] *** ruoso joined
[15:59] <nothingmuch> it should be simple

[15:59] <nothingmuch> then the code gen emits abstract opcodes like "box"

[16:00] <nothingmuch> and the static analyzer can decorate these opcodes with more info

[16:00] <nothingmuch> like a set of types that this box might be

[16:00] <nothingmuch> and then this can be optimized into lowlevel opcodes

[16:00] <nothingmuch> which are different

[16:00] <nothingmuch> e.g. if you say $class.new(...); then it's always the abstract opcode in the runtime

[16:00] <nothingmuch> but if it's Str.new

[16:01] <nothingmuch> then the metaclass is known, hence the RI getting boxed in the .new is also known

[16:01] <nothingmuch> and since this is really a proxy for the PMC stuff in the low level it's not "native" OO but FFI OO

[16:01] <nothingmuch> (in the sense that Str is a class implemented by the VM or a library the VM uses or whatever)

[16:01] <nothingmuch> this applies to multiple languages at once too, btw

[16:02] <nothingmuch> Str might be implemented in python

[16:02] <nothingmuch> and $str.foo will be dispatched according to pytjon rules

[16:02] <nothingmuch> using python metaclasses

[16:02] <nothingmuch> it's not "brought over" to the perl side

[16:02] <nothingmuch> is this any clearer?

[16:04] <[particle]> yes, thanks

[16:04] <nothingmuch> i should probably read the PDD before advising more

[16:05] <nothingmuch> i only have a vague picture so i need to keep things too generalized ;-)

[16:05] <[particle]> sure.

[16:05] <[particle]> and i've only just begun writing tests for the implementation

[16:05] <[particle]> mostly i'm testing api's and other unit tests

[16:05] *** bernhard joined
[16:06] <[particle]> we need some solid functional and performance tests, though

[16:22] <fglock_> backlogging...

[16:23] *** veritos joined
[16:23] <veritos> morning

[16:24] <veritos> i already told fglock this, but apparently Python lets you compile to c code too.

[16:24] <veritos> it's only dependent on your system's libc

[16:24] <veritos> basically like B::C, but that works.

[16:31] *** amnesiac joined
[16:34] *** kanru joined
[16:34] *** midellaq left
[16:38] <fglock_> re http://nothingmuch.woobling.org/MO/lib/MO/Overview.pod - the compile-time metamodel look just right; now looking at the runtime...

[16:45] *** fglock_ left
[16:47] <nothingmuch>  /w 35

[16:48] *** franck__ joined
[16:53] *** buetow joined
[16:54] <gaal> looks like a great resource: http://www.diku.dk/hjemmesider/ansatte/torbenm/Basics/

[16:54] <lambdabot> Title: Basics of Compiler Design

[16:54] <gaal> # free book

[16:55] * moritz looks

[16:57] *** fglock joined
[17:05] <TimToady> nothingmuch: I'm wondering if P6's "undefined prototype" objects can be thought of as essentially just the pure, abstract responders without any particular attached object.

[17:06] *** penk joined
[17:06] <TimToady> the responder representative, if you will...

[17:08] <TimToady> I was always thinking of the RI as "something beyond .HOW", but those undefs are pretty close to the same notion, insofar as they respond to the same methods (to the extend possible without an object)

[17:09] <nothingmuch> TimToady: IMHo there's no need to burdon the language with RI details

[17:09] <nothingmuch> that's for language implementors

[17:09] <nothingmuch> granted prototype object based OO is very easy to translate to RIs

[17:09] <moritz> gaal++ # that books looks fine ;-)

[17:09] <nothingmuch> so the affinity is high between the metaclass and the RI of prototype OO stuff

[17:10] <nothingmuch> but I'm not sure p6 should care

[17:10] <nothingmuch> i mean, technically, yes, that's what they'll be (a box with just a type, i suppose)

[17:10] <TimToady> sure, just trying to figure out if it saves me mental energy to identify them more closely in my mind.

[17:11] <nothingmuch> but i don't think it's a fundamental change in the thought modeling

[17:11] <TimToady> if RI is fundamental to the MO view, and MO is fundamental to P6, then at some point RI shows up as fundamental in P6...

[17:11] <nothingmuch> RI is fundamental in the same sense that target opcodes are

[17:12] <nothingmuch> compile time metamodeling is fundamental in the same sense that prelude functions are

[17:12] <TimToady> except there's a profound difference between a singular interface and a bunch of opcodes.

[17:13] <nothingmuch> but it's not singular

[17:13] <nothingmuch> RIs are menat to duck type in the interpreter

[17:13] *** ozo joined
[17:13] <TimToady> well, sure, the whole OO mindset is that things that are singular on the outside are plural on the inside somehow...

[17:14] <nothingmuch> si

[17:14] *** justatheory joined
[17:14] <TimToady> and I'm not saying that RI's have to be real objects, only that to the extent they are, an undefined prototype is very like it.

[17:14] <nothingmuch> which is why i think it's invisible to the language

[17:14] <nothingmuch> oh

[17:14] <nothingmuch> sorry, i misunderstood

[17:14] <nothingmuch> hmm

[17:15] <nothingmuch> that's aesthetic

[17:15] <nothingmuch> but I don't know if it actually has any technical meaning ;-)

[17:16] <TimToady> probably not, unless they also happen to respond to ".WHATTHEHECKKINDOFRESPONDERINTERFACEAREYOU"

[17:16] <nothingmuch> hmm

[17:16] <rindolf> Hi TimToady 

[17:16] <TimToady> or .WTF maybe.  :)

[17:16] <nothingmuch> i always ssaw RI as the return value from blessed() in perl 5 terms

[17:17] <TimToady> but yeah, mostly just mental construct

[17:17] <nothingmuch> and likewise what you give to bless() to box some data with a type

[17:17] <rindolf> Heh. Today is Tuesday, when God said "And it is good" twice.

[17:17] <TimToady> gotta take my kid to the bus stop for ~20 min.

[17:17] <TimToady> afk &

[17:17] <rindolf> Or when God saw it was good twice.

[17:17] <rindolf> TimToady: bye.

[17:17] <rindolf> TimToady: have fun.

[17:17] <nothingmuch> rindolf: what a coincidence!

[17:18] <rindolf> nothingmuch: it's mystical I tell you!

[17:18] <nothingmuch> yep... this tueday just keeps popping up

[17:18] <rindolf> It only happens once every 7 days.

[17:19] <nothingmuch> TimToady: bless( $instance_data, Dog ); # consistent

[17:19] <nothingmuch> also querying the type of is consistent

[17:19] <nothingmuch> but i think it's more of a parallelism

[17:19] <rindolf> nothingmuch: you're using vim, right?

[17:19] <nothingmuch> because the proto is the type of the object to some extend (loose definition of type here)

[17:20] <nothingmuch> and the RI is the support object that the VM uses to figure out how the type behaves

[17:20] <nothingmuch> rindolf: yes

[17:20] <rindolf> nothingmuch: ah OK.

[17:20] <nothingmuch> what value will that object give, though?

[17:20] <nothingmuch> i mean, besides proto stuff

[17:21] <rindolf> nothingmuch: how long is your .vimrc file?

[17:21] <rindolf>  160  641 5679 .vimrc

[17:21] <rindolf> But I have some stuff in other files.

[17:21] <nothingmuch> Dog.handle_method( method => Method::Named.new( :name<foo> ), responder => $dog ); # possibly useful?

[17:22] <nothingmuch> especially if $dog is really something else

[17:22] <rindolf> Hmmm... http://www.flickr.com/services/api/upload.api.html

[17:22] <nothingmuch> rindolf: about the same

[17:22] <lambdabot> Title: Flickr Services

[17:23] <rindolf> nothingmuch: how do you upload photos to Flickr?

[17:23] <nothingmuch> i don't

[17:23] <rindolf> nothingmuch: ah.

[17:23] <rindolf> nothingmuch: then who does?

[17:25] <nothingmuch> flickr users

[17:25] <rindolf> Hmmm... http://search.cpan.org/~cpb/Flickr-Upload-1.25/

[17:25] <lambdabot> Title: Christophe Beauregard / Flickr-Upload-1.25 - search.cpan.org

[17:25] <rindolf> nothingmuch: I meant in regards to Perl 6.

[17:26] <nothingmuch> who uploads photos to flickr in regards to perl6?

[17:29] <rindolf> And Mandriva has it.

[17:29] <rindolf> nothingmuch: from conferences, etc?

[17:30] <nothingmuch> the intersection of the set of flickr users and the set of people who attend conferences and take pictures

[17:30] <nothingmuch> i really don't understand what type of information you're trying to get with these questions

[17:31] *** ozo_ joined
[17:35] <nothingmuch> food &

[17:38] *** Psyche^ joined
[17:39] *** [particle] joined
[17:54] *** Psyche^ is now known as Patterner

[18:06] *** jisom joined
[18:10] *** fglock left
[18:10] *** fglock joined
[18:14] *** the_dormant joined
[18:15] <fglock> nothingmuch: I think I got it now - my 'CALL' is the 'responder' implementation; I need to box it into a 'responder object', and make a 'responder interface'

[18:15] <fglock> hmm - simple like that?

[18:18] <nothingmuch> CALL($obj, "foo") should have a body of something like UNBOX_RI($obj)->dispatch( method => Invocation::Method::Named->new("foo"), responder => $obj );

[18:19] * rindolf is doing urpmi.update -a now.

[18:20] <fglock> you mean, the objects knows it's dispatcher

[18:20] <fglock> s/objects/object/

[18:23] <fglock> the reason for this is so that you can have several MOs in the same program?

[18:30] *** stevan__ joined
[18:31] <fglock> nothingmuch: MO/t/si.t has commands like MO::Run::Aux::method_call( $base_obj_box, "elk" )

[18:32] <nothingmuch> those are helper routines

[18:32] <nothingmuch> or opcodes, if you will

[18:32] <nothingmuch> method_call( $mo_obj, $string ) is equiv to $perl_obj->$string

[18:33] <nothingmuch> oops, missed the prev part

[18:33] <nothingmuch> yes, the reason is that you can have several responder interfaces

[18:33] <nothingmuch> from even more varied metaclasses

[18:33] <nothingmuch> multiple languages' systems

[18:34] <nothingmuch> multiple "concepts" in the same language

[18:34] <nothingmuch> hand coded optimisations

[18:34] <nothingmuch> whatever is fit

[18:34] <fglock> how about the bridge between the implementations? does it just fits together

[18:37] <fglock> I mean, what if the method arguments belong to a different MO - it's probably handled by a 'coerce' routine somewhere else

[18:37] <fglock> ah - no, it's just the API that matters

[18:38] *** calamare joined
[18:38] <nothingmuch> nope

[18:39] <nothingmuch> if the languages share a similar enough Invocation object

[18:39] <nothingmuch> then there's no need for coercion

[18:39] <nothingmuch> if they don't then that glue has to be done using a wrapper RI

[18:39] <nothingmuch> the boxed type presented to e.g. perl 6 from $lang_foo will have a wrapper RI that translates invocations before delegating to the original ones

[18:39] <nothingmuch> so basically what you said afterwords =)

[18:40] <fglock> wrapper = MO::Run::Aux::method_call for example

[18:40] <nothingmuch> nope

[18:41] <nothingmuch> more like class ShimRI { method dispatch ( :$obj, :$method ) { Invocation::DifferentKind.new( .... ); # based on $method; $.wrapped_ri.dispatch( $obj, $new_invocation ) } }

[18:41] <nothingmuch> and, of course, it wraps all return values as necessary, too

[18:42] <fglock> ok - I guess I'll do some implementation and come back with more questions :)

[18:42] <nothingmuch> cool

[18:46] <fglock> brb

[18:46] *** fglock left
[19:17] *** fglock joined
[19:34] <fglock> unbox($obj)->dispatch( $obj, $meth ) == now works in kp6 

[19:58] <fglock> any MO people still around?

[19:59] <fglock> one remaining problem in kp6 OO:

[20:00] <fglock> containers currently have 2 dispatchers, one for plain methods, and one for VAR() methods

[20:01] *** penk joined
[20:02] <fglock> having 2 dispatchers in the same object doesn't seem to be against MO, so I'll just keep it

[20:03] *** geoffb joined
[20:03] *** marmic joined
[20:04] <Juerd> Feather is going to change IP address soonish.

[20:07] <kolibrie> new network?

[20:11] *** Aankhen`` joined
[20:15] *** veritos joined
[20:17] <veritos> heya

[20:18] <pasteling> "fglock" at 201.54.129.80 pasted "kp6 - working "new-MO" output of t/kp6/20-bit.t" (51 lines, 1.5K) at http://sial.org/pbot/24472

[20:19] <fglock> veritos: hi

[20:20] *** _bernhard joined
[20:23] <avar> yay I sort of understand how mp6 works now:)

[20:23] <fglock> avar: cool

[20:24] <fglock> "sort of"? :)

[20:24] <fglock> avar: now you can start with kp6

[20:24] <avar> well how the p5 emitting backend differs from parrot

[20:25] <veritos> phew.

[20:25] <veritos> i'm working on the python code generator.

[20:26] <veritos> fglock: so what did you think of that Freeze thing i showed you? certainly one thing python did right...

[20:26] <avar> v6-Python?

[20:26] <veritos> avar...not now

[20:26] <fglock> the kp6 emitter is much simpler than mp6's

[20:26] <veritos> i'm working on a backend for miniperl6

[20:26] <avar> neat

[20:26] <[particle]> compiling perl 6 to python 3000?

[20:27] <veritos> [particle]: not 3000

[20:27] <avar> hah

[20:27] *** dduncan joined
[20:27] <fglock> veritos: it would be nice to see v6->python->C working

[20:27] <[particle]> vaporlang on vaporlang

[20:27] <veritos> fglock: once i get this python emmiter working

[20:27] <veritos> fglock: we could have almost skipped parrot.

[20:27] <fglock> [particle]: mp6 new-MO is out

[20:27] <[particle]> great

[20:28] <[particle]> that was fast!

[20:28] <fglock> veritos: heh

[20:28] <fglock> [particle]: see the last paste

[20:29] <avar> fglock: the kp6 emitting backends end up in mp6 though right?

[20:29] <demq> hey particle did you notice my message the other day?

[20:29] <fglock> [particle]: kp6->parrot is probably more doable now; it requires simpler semantics

[20:29] *** demq is now known as dmq

[20:29] <veritos> generating python is hard, you have to keep track of indent and everything.w

[20:30] <[particle]> dmq: no

[20:30] <fglock> avar: mp6 is just one backend; it does kp6->perl5 directly

[20:30] <avar> veritos: ya, that sucks:)

[20:30] <dmq> oh, just wanted to thank you for the pointer to the \v/\h esclists, and to say that ive added such support to p5.

[20:31] <dmq> so, thanks. :-)

[20:32] <dmq> was kinda curious actually what the rules were for generating the lists, just in case unicode X.0 adds new ones...

[20:32] <veritos> maybe i could implement it as a two-pass compiler. first would leave comments like # DEDENT or # INDENT, and the second pass would change those to actual indents.

[20:32] <avar> fglock: and it can do kp6->python|php|lisp|whatever easier than mp6->whatever?

[20:32] <fglock> veritos: I wonder if there is a "pythontidy" that would do it for you

[20:32] <dmq> just use { }

[20:32] <[particle]> dmq: fantastic news

[20:33] <avar> if 1+1: # {

[20:33] <avar>     print "ook":

[20:33] <avar> # }

[20:33] <kolibrie> fglock: should I start looking at kp6 as a replacement for v6.pm and PCR?

[20:33] <fglock> avar: yes, the ast transforms make it easier to desugar

[20:33] <veritos> fglock: no, because there's no way to tell. indentation works like {}, you can't work otherwise.

[20:33] <dmq> i also added support for \R as per uniocde tr18: http://unicode.org/unicode/reports/tr18/

[20:33] <lambdabot> Title: UTS #18: Unicode Regular Expressions

[20:33] <fglock> kolibrie: sorry, not enough runtime yet

[20:34] <avar> kolibrie: yeah it looks much nicer for what PCR does

[20:34] <avar> kolibrie: not that I know...:)

[20:34] <kolibrie> fglock: no problem (I'm not doing much to help)

[20:35] <kolibrie> I am getting ready to update my 'Practical Extraction with Perl6' talk

[20:35] <kolibrie> it's experienced some major bitrot I'm sure

[20:36] <avar> veritos: it would be awesome if you could document some of this stuff as you go along:)

[20:36] <fglock> kolibrie: but I guess it's time to start 6-on-6-on-kp6; the runtime will be written as-needed

[20:36] <avar> veritos: writing custom backends that is

[20:36] <avar> *nudge* *nudge*

[20:36] <veritos> avar: i'm mostly taking the perl5 one and changing the emitted code.

[20:36] <kolibrie> fglock: sounds great

[20:36] <[particle]> dmq: thanks for the \R reminder, >>@todo

[20:36] <avar> veritos: mm, and writing a match.pm in pythoon?

[20:37] <veritos> avar: http://www.dabeaz.com/ply/

[20:37] <lambdabot> Title: PLY

[20:37] <dmq> i dont think p6 is supposed to or needs \R in the sense of that article.

[20:37] <dmq> \R is supposed to be [^\r] in p6.

[20:37] <avar> p6 pretty much doesn't need any escapes since you can just add them:)

[20:38] <avar> <-[\r]> you mean:)

[20:38] <[particle]> hrmm... i guess pge is *mostly* perl 6-based

[20:38] <dmq> avar: er, right. :-)

[20:38] <[particle]> it will support negated \r, so maybe that'll do

[20:39] <avar> I don't think you can define custom \ escapen in p6 though

[20:39] <avar> then again I don't know p6:)

[20:39] <veritos> you could in p5...there was an example in ze camel.

[20:39] <fglock> [particle]: re translating my own stuff - hmm - do you think people get lost?

[20:40] <[particle]> fglock: yes, i do

[20:41] <dmq> so no idea how those lists were determined?

[20:41] <[particle]> it's a combination of things--not many understand compilers, nevermind bootstrapped compilers written in a subset of perl 6 :)

[20:41] <[particle]> dmq: the \v \h lists?

[20:41] <[particle]> i copied them from the spec

[20:42] <moritz> avar: you _can_ define \-sequences in p6 ;-)

[20:42] <avar> moritz: howz?

[20:42] <moritz> token rule_backslash:<w> { ... }     # define your own \w and \W

[20:43] <avar> neat

[20:43] <moritz> http://perlcabal.org/syn/S05.html#Syntactic_categories

[20:43] <lambdabot> Title: S05

[20:44] <veritos> python has some quirks though. there's no bare 'do this once block' like do{}, you have to say something like if True: yada

[20:45] <veritos> fglock: what's class Bind supposed to be?

[20:45] <veritos> a list of statements?

[20:46] <fglock> veritos:  $a := $b

[20:47] <veritos> hmm...it seems to look like ->(){} from the syntax here

[20:47] <fglock> or: [any-structure] := [other-structure]  - but you don't have to support this syntax

[20:47] *** vel joined
[20:47] <fglock> Bind is used in many places, like parameter-passing

[20:47] <veritos> go to like line 160 in the perl5 backend

[20:47] <fglock> one sec

[20:49] <fglock> veritos: that part of the program transforms [$a,$b] := [1,2] into $a:=1; $b:=2

[20:49] <veritos> fglock: oh, ok.

[20:49] <veritos> that works

[20:49] <veritos> right now i'm basically translating the bits of perl5 into python.

[20:51] <veritos> i haven't typed a := since i learned pascal.

[20:53] <fglock> later &

[20:55] <avar> perl6: the new pascal

[20:55] <geoffb> As a young kid, my parents sent me to a computer day camp.  It was tiered into basic and advanced students.  I was considered a "basic" student because I didn't know Pascal, despite knowing at least one assembly language at the time.  My, how times have changed.

[20:55] <[particle]> you go to advanced day camp now?

[20:55] <Tene> geoffb: that's odd.

[20:55] <geoffb> [particle]: heh.

[20:56] <geoffb> On the plus side, the basic students got to play with a programmable robot as their final project.  So I spent most of my time coding it to drive various patterns around the classroom.

[20:58] <geoffb> Early 80's robotics not so precise, btw.

[20:59] <geoffb> Some day when I'm rich and bored I ought to get back to playing with robotics again ...

[20:59] * geoffb hopes embedded Parrot will be a reality by then

[21:00] <[particle]> i sure haven't programmed in VAL-II in a while

[21:01] <[particle]> operating a robot that could position 44lbs at any angle was fun, but without force feedback, quite dangerous

[21:07] *** Caelum joined
[21:09] *** desiderato joined
[21:19] *** desiderato left
[21:39] *** sapir joined
[23:17] *** SubStack joined
[23:25] *** kunwon1 joined
[23:31] * TimToady wonders how well Perl 6 will run on a TRIPS processor...

[23:40] <mugwump> do they come from the frig?

[23:42] *** kunwon1 joined
[23:44] <jrockway> TRIPS = TimToady work project?

[23:44] <TimToady> http://hardware.slashdot.org/article.pl?sid=07/04/24/2021243

[23:44] <lambdabot> Title: Slashdot | Next-Gen Processor Unveiled

[23:45] <jrockway> ah, cool

[23:45] <TimToady> we already have the requisite references to Erlang and Haskell in the commentary...

[23:51] <specbot6> r14378 | larry++ | cut-n-paste typo noticed by TheDamian++

[23:58] *** forsaken joined
