[00:16] *** marmic joined
[00:18] *** Khisanth joined
[00:35] *** Khisanth joined
[00:56] *** neonse left
[01:07] *** riffraff joined
[01:07] <riffraff> hi

[01:08] <Tene> hi

[01:09] <Patterner> hi

[01:10] *** riffraff left
[01:10] *** riffraff joined
[01:19] *** lyokato joined
[01:40] *** buubot joined
[01:56] *** QwestDawG joined
[02:07] *** hexmode left
[02:39] *** riffraff joined
[02:39] <riffraff> hi

[02:44] *** bucky joined
[02:45] <riffraff> help please: what is the perl6ish way of putting unit tests in the same file of the code? I was going to use something like "if $?FILE eq $*PROGRAM { use Test; plan 4; ok...}" but it seems to much work

[02:49] *** drbean joined
[03:10] <avar> riffraff: Pod probably, nobody has implemented that so far afaik

[03:15] <riffraff> I see

[03:15] <riffraff> thak you

[03:40] *** audreyt_ joined
[03:46] *** diakopter joined
[03:46] <diakopter> wb audreyt

[03:48] <TimToady> oohie!

[03:51] <diakopter> spoke too soon, I guess.

[03:53] <TimToady> maybe we scared her away...

[03:53] <TimToady> more likely the last remaining fiber to Taiwan melted...

[03:54] <diakopter> irssi auto-reconnect perhaps

[03:54] <TimToady> historically she usually attaches from feather

[03:54] <TimToady> so I'm assuming she's trying to get out on a business-prioritized line

[03:55] <TimToady> or is that her new DSL line?

[03:56] <TimToady> hinet.net is definitely a chinese site...

[03:59] <diakopter> TimToady: sorry for brashly bantering with Titus and 1Co the other day.

[04:00] <TimToady> he's been dead for 1900 years, I don't think Paul is the least offended. :)

[04:00] <allbery_b> suppose that depends on your theology :)

[04:02] <TimToady> I don't think he's offended wherever he is... :)

[04:07] <TimToady> hinet.net is definitely audreyt's ISP, I think.

[04:08] *** LeeD joined
[04:10] <diakopter> in Titus he's referring to believers vs. unbelievers; in 1Co he's referring to confident believers among less... liberal ... believers.  A misconflation.  i'll be back in 13 hours.

[04:15] * allbery_b is not really the right person to be discussing Christian theology anyway :>

[04:17] *** audreyt joined
[04:20] *** b00t joined
[04:21] <bucky> what does pugscc do?  http://perlcabal.org/~audreyt/darcs/pugs/script/pugscc

[04:23] <TimToady> never tried it.  it has a pod section of docs embedded though.

[04:24] <bucky> hmm...

[04:25] <bucky> The 'pugscc' script allows you to create an exectuable image from a Perl6 script

[04:26] <bucky> ic

[04:28] <TimToady> not heavily used, so likely subject to bitrot

[04:30] <bucky> i just found it in Perl6-Pugs-6.2.13

[04:32] <TimToady> my dir shows it at Oct 18, so not much changed since then.

[04:32] <bucky> this is interesting: Perl6-Pugs-6.2.13/util/livecd/mklivecd.pl

[04:32] <TimToady> most of us here keep an up-to-date copy from svn/svk

[04:32] <bucky> i like this

[04:36] <TimToady> if you'd like to hack on it, I can give you a commit bit

[04:37] <bucky> thank you.. but i'm a beginner

[04:38] <bucky> perl6 looks like something i would want to use from now on though

[04:38] *** demy joined
[04:40] <bucky> i just didn't realize that pugscc came with the distribution

[05:01] *** luqui joined
[05:12] *** Eidolos joined
[05:31] *** drbean joined
[05:41] *** audreyt joined
[06:13] <Khisanth> luqui: you could use $ENV{'REMOTE_ADDR'} if you are using CGI, if using mod_perl then you can get it from the request object

[06:13] <luqui> Khisanth, thanks.

[06:15] *** BooK joined
[06:22] *** LeeD is now known as leed

[06:22] *** spacebat joined
[06:29] *** audreyt joined
[07:16] <beppu_> ?eval class President { }

[07:16] <evalbot_r14996> undef

[07:17] <beppu_> ?eval class President { }; my $president = President.new();

[07:17] <evalbot_r14996> \President.new()

[07:18] <beppu_> ?eval class President { }; my $president = President.new()

[07:18] <evalbot_r14996> \President.new()

[07:22] <QwestDawG> ?eval print "hello, world!\n";

[07:22] <QwestDawG> hahaha

[07:22] <evalbot_r14996> OUTPUT[hello, world!␤] Bool::True

[07:22] <QwestDawG> was worth a shot

[07:22] <QwestDawG> woah

[07:28] <beppu_> ?eval [ 0 .. 31 ] >>~<< [ "text" xx 32 ]

[07:28] <evalbot_r14996> ("0text", "1text", "2text", "3text", "4text", "5text", "6text", "7text", "8text", "9text", "10text", "11text", "12text", "13text", "14text", "15text", "16text", "17text", "18text", "19text", "20text", "21text", "22text", "23text", "24text", "25text", "26text", "27text", "28text", "29text", "30text", "31text")

[07:29] <Tene> [ 0 .. 31 ] >>~>> "text"

[07:29] <Tene> ?eval [ 0 .. 31 ] >>~>> "text"

[07:29] <evalbot_r14996> Error: ␤Unexpected ">>~>>"␤expecting operator

[07:30] <beppu_> There must be some way to not have to repeat "text" 32 times.

[07:30] <beppu_> ?eval [ 0 .. 31 ] >>~<< "text"

[07:30] <evalbot_r14996> ("0text", "1text", "2text", "3text", "4text", "5text", "6text", "7text", "8text", "9text", "10text", "11text", "12text", "13text", "14text", "15text", "16text", "17text", "18text", "19text", "20text", "21text", "22text", "23text", "24text", "25text", "26text", "27text", "28text", "29text", "30text", "31text")

[07:30] <luqui> beppu_, you are correct

[07:30] <luqui> it's just not implemented

[07:30] <luqui> (and that behavior is incorrect)

[07:30] <beppu_> really...  hmmm..

[07:31] <beppu_> what's the correct way gonna look like?

[07:31] <luqui> [0..31] >>~>> "text"

[07:33] <beppu_> I've heard that perl 6 would allow people to define operators in unicode.  Is anyone here familiar with how that is going to work?

[07:34] <luqui> beppu_, yeah

[07:34] <luqui> what do you want to know?

[07:34] <beppu_> the basic syntax for defining an operator.

[07:36] <Tene> sub prefix:<operator> { do some stuff }

[07:36] <beppu_> Oh, that's simple enough.

[07:37] <Tene> ?eval sub prefix:<double> -> $a { $a * 2}; double 2

[07:37] <evalbot_r14996> Error: ␤Unexpected "->"␤expecting "handles", "is", bare trait, subroutine parameters, trait or block

[07:37] <Tene> ?eval sub prefix:<double> { $_ * 2}; double 2

[07:37] <evalbot_r14996> 4

[07:37] <beppu_> cool

[07:38] <Tene> same for infix and postfix

[07:38] <beppu_> is a similar mechanism used for operator overloading?

[07:38] <beppu_> like if you had a date and timerange object and wanted to add them together...

[07:38] <luqui> ?eval multi *infix:<*> (Str $x, Str $y) { "$x--$y" }   [3*4, "x"*"y"]

[07:38] <evalbot_r14996> [12, "x--y"]

[07:39] <luqui> (short answer, yes)

[07:39] <beppu_> I see.  you declare types and rely on multimethod dispatch, right?

[07:39] <luqui> ya

[07:39] <beppu_> very interesting.  thanks for teaching me.  

[07:45] <beppu_> ?eval sub prefix:<☠> { kill(9, $_) }; ☠ 9999999;

[07:45] <evalbot_r14996> Error: Unsafe function 'kill' called under safe mode

[07:45] <beppu_> hehe

[07:45] <beppu_> Someone's going to have to come up with a good unicode input mechanism.

[07:47] <Tene> ?eval sub prefix:<☢> { say "$_ curies" }; ☢ 1234

[07:47] <evalbot_r14996> OUTPUT[1234 curies␤] Bool::True

[07:48] <beppu_> this will be an obfuscators wonderland ;-)

[07:51] *** DHGE joined
[07:59] *** ayrnieu joined
[08:02] <masak> beppu_: true, but I must confess that I'm even more looking forward to what one will be able to do with p6 when one's intents are to be as clear as possible :)

[08:03] <beppu_> of course.  :)

[08:03] <beppu_> we're gonna have to be creative

[08:03] <beppu_> there will be a perl renaissance

[08:05] *** frankg joined
[08:30] *** devogon joined
[08:36] <masak> beppu_: maybe. right now I'm not sure what the status is really of the pugs project

[08:37] <masak> it's so much easier when audreyt is present

[08:37] <masak> then the status is "steadily progressing" :)

[08:39] <beppu_> ?eval [+] (1 .. 8, 6)

[08:39] <evalbot_r14996> 42

[08:40] <beppu_> good night

[08:45] *** iblechbot joined
[09:04] <masak> ?eval multi *infix:<*> (Str $x, Str $y) { "$x--$y" } (3, "x") >>*<< (4, "y")

[09:04] <evalbot_r14996> ("3--4", "x--y")

[09:04] <masak> hm

[09:04] *** buetow joined
[09:13] *** kanru joined
[09:22] <QwestDawG> ?eval [-] (1..3)

[09:22] <evalbot_r14996> -4

[09:23] <QwestDawG> lisp influenced

[09:23] <QwestDawG> ?

[09:28] <TimToady> not really

[09:41] *** drrho joined
[09:43] *** elmex joined
[10:02] <svnbot6> r14997 | audreyt++ | * Pugs.Prim: Fix t/xx-uncategorized/say-crash.t by printing

[10:02] <svnbot6> r14997 | audreyt++ |   in 4096-byte chunks instead of running the strict encodeUTF8

[10:02] <svnbot6> r14997 | audreyt++ |   on the entire string.  This commit fixed the bug, but the

[10:02] <svnbot6> r14997 | audreyt++ |   next one should generalize this fix to make encode/decode

[10:02] <svnbot6> r14997 | audreyt++ |   sufficiently chunk-lazy...

[10:02] <svnbot6> r14997 | audreyt++ |   Reported by gaal++.

[10:04] <pasteling> "evalbot_r14996" at 194.145.200.126 pasted "Pugs build failure" (429 lines, 24.1K) at http://sial.org/pbot/22131

[10:07] <gaal> there seems to be some binary junk in your src/Pugs/Help.hs ?

[10:07] <gaal> oh, "your"==evalbot. hahah

[10:08] <audreyt> spj++ # fix ghc-trunk in time so it builds pugs _and_ so the watch/break/step debugger feature in ghci would work

[10:08] <gaal> audreyt: need 'make prof' for that, right?

[10:09] * gaal considers a 'make professor' alias

[10:10] <audreyt> no, "make ghci"

[10:10] <audreyt> it's builtin ghci

[10:10] <gaal> wow. that's... outstanding

[10:10] <gaal> spj++ indeed

[10:10] <audreyt> there's also :sprint

[10:10] <audreyt> which prints a value without forcing computation

[10:11] <gaal> but this is not in 6.6?

[10:11] <audreyt> no

[10:11] <audreyt> it just landed in usable form last week

[10:11] <audreyt>  Options for ':breakpoint':

[10:11] <audreyt>    list                                     list the current breakpoints

[10:11] <audreyt>    add Module line [col]                    add a new breakpoint

[10:11] <audreyt>    del (breakpoint# | Module line [col])    delete a breakpoint

[10:11] <audreyt>    stop                   Stop a computation and return to the top level

[10:11] <audreyt> it's somebody's SoC

[10:11] <audreyt> delayed delivery

[10:11] <audreyt> but damn useful

[10:11] * gaal d/ls bleadghc

[10:11] <audreyt> like, real debugger.

[10:11] *** fglock joined
[10:11] <gaal> somebody++

[10:12] <audreyt> ?eval $?PUGS_VERSION

[10:12] <evalbot_r14997> \"Perl6 User\'s Golfing System, version 6.2.13, October 17, 2006 (r14997)"

[10:13] <audreyt> generalized fix done (make encode/decode sufficiently semilazy)

[10:13] <audreyt> benchmarking to see if we lost any perf that way

[10:15] *** miyagawa joined
[10:15] <fglock> audreyt: happy new year!

[10:16] <fglock> I'm speccing post-mp6

[10:17] <fglock> please review if you have time

[10:19] <audreyt> happy new year

[10:19] <audreyt> cool

[10:19] <audreyt> pathname?

[10:20] <fglock> v6/KindaPerl6 :)

[10:21] <fglock> v6/v6-KindaPerl6

[10:21] <audreyt> heh ok :)

[10:21] <fglock> the idea is to have a compiler workflow framework first,

[10:21] <fglock> ad then start the module devel

[10:21] <fglock> reuse as much as possible from existing compilers

[10:21] <fglock> by writing adaptors

[10:22] <audreyt> nod

[10:22] <fglock> so that new impls can be done inide this workflow engine

[10:22] <audreyt> that sounds most sane

[10:22] <fglock> and start writing the optimiers

[10:22] <fglock> optimizers

[10:23] <audreyt> seems to help perf, amazingly

[10:24] <audreyt> resmoking to make sure it didn't help perf by silently doing something wrong ;)

[10:25] <audreyt> MP6 -> KP6

[10:25] <audreyt> asciibetically the next one in the sequence should be IPv6

[10:25] <fglock> re mp6, the spec is now frozen, with a bootstrapped p5 impl, and half-implemented parrot

[10:25] <fglock> ipv6 sounds good - what would it expand to?

[10:25] <audreyt> wow. nice!

[10:25] <audreyt> Internet Protocol Version 6

[10:25] <audreyt> I think

[10:26] <gaal> haha

[10:26] <fglock> the parrot impl compiles tokens already, and has a Match class

[10:26] <fglock> it has problems with blocks and class variables

[10:27] <fglock> blocks need to be compiled as subroutines, requires some work

[10:27] <fglock> and class vars does not seem to be supported natively

[10:27] <audreyt> yeah, /me am aware of those places :)

[10:28] <clkao> .kasjo6

[10:28] <audreyt> so in KP6 we'd have something that assumes all the subset of perl6 that's required for writing a reasonable fullp6 impl is there

[10:29] <audreyt> sure. excellent plan

[10:30] <fglock> thanks :)

[10:31] <fglock> btw, mp6-MO worked, but it's too slow to use as a compiler tool

[10:32] <fglock> but it's fine to make experiments wit

[10:32] <fglock> with

[10:32] <audreyt> cool!

[10:32] <audreyt> which part was slow?

[10:35] <fglock> the profiles show a lot of calls to Class::MOP::Class::compute_all_applicable_attributes, Class::MOP::Class::get_attribute - possibly fixable with memoization

[10:35] <audreyt> those two are prime memocands

[10:35] <audreyt> esp get_a

[10:36] <audreyt> or inlinecands even

[10:36] <audreyt> so it's still using oldland C::MOP

[10:36] <audreyt> not nothingmuch's new MO?

[10:36] <audreyt> or has it became C::MOP?

[10:36] * audreyt has lots of catching up to do

[10:36] <fglock> I guess MO uses C::MOP

[10:37] <audreyt> internally, I see

[10:37] <fglock> anyway, I was planning to write a wrapper to p5 native oo, in order to have a common pluggable API

[10:37] <audreyt> right

[10:38] <fglock> so we can have .HOW on native p5 objects (maybe reuse v6.pm)

[10:39] <fglock> does p6 allows to use different metamodels in the same program?

[10:39] <fglock> this could be a problem

[10:43] <audreyt> gaal: if you go about build trhunkghc yourself you need this in mk/build.mk

[10:43] <audreyt> GhciWithDebugger = YES

[10:43] <audreyt> fglock: it allows different HOW

[10:44] <audreyt> but the protocol is same

[10:44] <fglock> ok

[10:46] <gaal> audreyt: thanks, no, i used a binary

[10:46] <svnbot6> r14998 | audreyt++ | * Pugs.Internals.String: encodeUTF8 and decodeUTF8 is now

[10:46] <svnbot6> r14998 | audreyt++ |   lazy in 4k-chunk units, instead of completely strict.

[10:46] <svnbot6> r14998 | audreyt++ |   This allows reading/writing of huge files.

[10:46] <audreyt> gaal: ok, then you don't get debugger cmds

[10:46] <audreyt> I think. may be wrong

[10:47] <gaal> oh! that's... too bad

[10:47] <audreyt> try ":debugger" in ghci and see if it groks it

[10:47] <audreyt> but! ghc now compiles itself much faster

[10:47] <audreyt> :)

[10:47] <gaal> doesn't, but :? does show breakpoint options

[10:47] <svnbot6> r14999 | audreyt++ | * Pugs.Prim.List: Remove an unneccessary toInteger.

[10:47] <audreyt> yeah, but that's meaningless

[10:48] <gaal> why's it off by default? :-((

[10:48] <gaal> ghc will take up the rest of the weekend to build here...

[10:49] <audreyt> still being worked on I guess

[10:49] <audreyt> oy. sorry then :/

[10:49] <audreyt> is your ghc bincompat with feather perchance?

[10:49] <gaal> dunno, how do i check?

[10:50] <gaal> i just finished building '97 i think

[10:50] <gaal> (x86/32bit here)

[10:51] <gaal> (debian unstable)

[10:51] <audreyt> dunno either

[10:51] <audreyt> you can cp from feather and try... 

[10:51] <masak> welcome back, audreyt!

[10:51] <audreyt> thank you :)

[10:51] <gaal> yeah, will. but need to figure out lunch first

[10:51] <audreyt> still in backlog mode

[10:52] <masak> apparently a backlog mode that does commits along the way, however

[10:52] *** chris2 joined
[10:53] <audreyt> yeah, well, that's a bonus

[10:53] <svnbot6> r15000 | audreyt++ | * Pugs.Prim: Now encodeUTF8 autochunks, remove hardcoding in op2Print.

[10:54] <fglock> is 'class Dog {...}' the same as 'our class Dog {...}' ?

[10:54] <svnbot6> r15001 | audreyt++ | * Pugs.Types: Compare TMVar with their addresses, not bind Eqs.

[10:54] <svnbot6> r15001 | audreyt++ |   This is important for well-orderedness of Thread objects.

[10:55] <gaal> does bsl expose that 4069b constant somewhere?

[10:56] * gaal needs more ram, keeps getting evacuate errors

[10:57] <gaal> src/Pugs/AST/Internals.hs:637:16:

[10:57] <gaal> Not in scope: type constructor or class `VThread'

[10:57] <gaal> forgotten svk add?

[10:58] <audreyt> no, a sec

[10:58] *** ruoso joined
[11:00] <svnbot6> r15002 | audreyt++ | * Pugs.AST.Internals - Change "VThread Val" to "VThread"

[11:00] <svnbot6> r15002 | audreyt++ |   since Val is all one thread can conceivably return.

[11:00] <audreyt> try again?

[11:00] <audreyt> (r15003)

[11:00] <gaal> pulling

[11:01] <audreyt> gaal: no it's not bsl. it's P.Internals.String

[11:01] <audreyt> we're not using bsl yet

[11:01] <audreyt> bsl means all ops on it are 4klz

[11:01] <audreyt> not only en/de

[11:01] <svnbot6> r15003 | audreyt++ | * Regen instance.

[11:05] <gaal> ok looks better on the compilation moose, but ghci is hanging when i do "main", probably just a system problem on my machine

[11:05] <gaal> gotta go now though

[11:05] <gaal> see you later :)

[11:06] <gaal> (why does ghci not cache the results of compilation somewhere? eg every time i enter make ghci I need to recompile lots of code.)

[11:06] <nothingmuch> gaal: do you have trail map #1?

[11:06] <audreyt> bytecode is not yet saved

[11:06] <nothingmuch> (hermon)

[11:06] <gaal> (yes i realize it's not a compiler mode -- but it could have serialized asts or whatever)

[11:07] <gaal> nothingmuch: maybe one from ~10 years ago, but i won't be able to moose it till next weekend

[11:07] <gaal> anyway, i gotta go. <3s to y'all

[11:08] <gaal> *waves* &

[11:08] <gaal> y after linking all the libs it just sits there

[11:10] <fglock> I've been in hermon - it makes 20yrs  :)

[11:11] <fglock> they had 1m snow

[11:17] <audreyt> ?eval 42

[11:17] <evalbot_r14997> 42

[11:25] <gaal> ooh i got a pugs shell eventually, just took a while

[11:25] <gaal> fglock: you must have hit a cold year! :)

[11:27] <fglock> I still have the dubon :)

[11:27] *** ozo joined
[11:28] *** mj41 joined
[11:28] <fglock> is there a drawing somewhere showing when to execute BEGIN blocks, 'use' statements, etc

[11:28] <avar> where's the code that does perl5 embedding in pugs?

[11:29] <avar> fglock: aside from the synopsis, not a drawing though

[11:29] <avar> ?

[11:30] <audreyt> avar: src/perl5/ and src/Pugs/*/Perl5

[11:30] <fglock> I'm trying to sketch a detailed compilation workflow - I wonder if there is something done I could reuse

[11:32] <audreyt> fglock: the closest is docs/perl6_compilation

[11:44] <nothingmuch> @tell gaal thanks anymoose, i'm going to buy one now

[11:44] <lambdabot> Consider it noted.

[12:05] *** Grrrr joined
[12:21] *** marmic joined
[12:22] *** buetow joined
[12:22] <fglock> if I have separate parse, analyze and emit, when is it the right time to run BEGIN blocks?

[12:24] <fglock> is the answer "you can't split it like that"

[12:43] *** SCalimlim joined
[13:21] *** ruoso_ joined
[13:23] *** luqui joined
[13:27] *** marmic joined
[14:01] *** gnuvince joined
[14:08] *** fglock joined
[14:13] *** [particle] joined
[14:23] *** baest joined
[14:35] *** neonse joined
[14:45] *** nipra joined
[14:59] *** ozo left
[15:02] *** hexmode joined
[15:05] *** vel joined
[15:19] <fglock> is there some kind of OUTER relation between modules like ::A and ::A::B which are declared separately?

[15:20] <fglock> to what extent is ::A::B 'inside' ::A ?

[15:25] <nothingmuch> fglock: that slowness is due to MO objects being constructed

[15:25] <nothingmuch> Class::MOP::compute_all_applicable_attributes is used in Moose constructors

[15:25] <nothingmuch> and all the MO meta objects use Moose now

[15:25] <nothingmuch> my next step is to bootstrap MO using itself

[15:26] <nothingmuch> and then I can finish functionality

[15:35] *** spoop joined
[15:38] <fglock> nothingmuch: ok

[15:39] <luqui> fglock, was your question about perl 6?

[15:39] <fglock> luqui: yes

[15:40] <luqui> there is hardly any semantic relationship

[15:40] <fglock> just like p5

[15:40] <luqui> right

[15:41] <luqui> I'm not actually that well-versed in p5 territory here

[15:41] <fglock> what should I read to know more about 'BEGIN' and 'use' during compilation?

[15:41] <fglock> in p6

[15:42] <luqui> as far as I know, it's pretty much the same

[15:42] <luqui> modulo new stuff like "is export"

[15:43] <fglock> what should I read to know more about it in p5 :)

[15:43] <fglock> is 'use' executed at BEGIN time?

[15:43] *** turrepurre joined
[15:43] <luqui> yeah

[15:44] <fglock> so it needs to be compiled recursively

[15:44] <luqui> in p5, use X is equivalent to BEGIN { require X; X->import }

[15:44] <fglock> ok

[15:44] <luqui> you're asking about circular dependencies?

[15:44] <luqui> or... 

[15:45] <fglock> I'm wondering where to execute BEGIN

[15:45] <luqui> ?

[15:45] <fglock> probably inside the return-blocks in the parser

[15:45] <luqui> oh.  right after } is parsed...

[15:45] <fglock> like this:

[15:46] <luqui> (rather, statement ::= 'BEGIN' <block>  *here*)  I imagine...

[15:46] <fglock> token BEGIN { BEGIN <block> { execute_begin; return ... } }

[15:46] <luqui> that's what I'd guess, too

[15:48] <fglock> another point is, how much of the program is actually supposed to 'exist' when BEGIN is executed

[15:48] <fglock> my and our were not executed yet, right?

[15:48] *** thepler joined
[15:49] <luqui> I know we talked about this a lot some months ago

[15:49] <fglock> only 'sub' definitions

[15:49] <luqui> but I think it would be pretty hard to find the conversation

[15:49] <luqui> anyway, like perl 5

[15:49] <luqui> so my's *do* exist

[15:49] <luqui> and that's screwed up, and we understand that

[15:50] <luqui> let me see if I can find the p6l thread

[15:51] *** lumi_ joined
[15:54] <luqui> okay, 2006-08-14 is the timestamp of a thread asking about this sort of thing

[15:54] <gaal> it's X->import if UNIVERSALL::can('X', 'import'), which nobody seems to remember -- plus the parser hint for indirect object syntax, which nobody seems to forget :)

[15:54] <lambdabot> gaal: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:54] <luqui> looking at IRC logs nearby

[15:54] <gaal> @moosages

[15:54] <lambdabot> nothingmuch said 4h 9m 52s ago: thanks anymoose, i'm going to buy one now

[15:54] <gaal> s/ALL/AL/

[15:59] <gaal> the "readmore" on the latest entry in the pugs blog is broken

[16:00] <fglock> gaal: what's the 'parser hint for indirect object syntax'

[16:02] <gaal> fglock: man perlobj/"Indirect Object Syntax"/'For example, a call to a method "new" in indirect notation'

[16:03] <luqui> fglock, if you are ready for your head to explode thinking about scoping and compile phases together, look at http://colabti.de/irclogger/irclogger_log/perl6?date=2006-08-14,Mon&sel=771#l1375

[16:03] <lambdabot> Title: #perl6 2006-08-14,Mon, http://tinyurl.com/ubbbl

[16:03] <fglock> luqui: do I have a choice :)

[16:04] <fglock> thanks1

[16:04] <fglock> thanks!

[16:04] <luqui> oh

[16:04] <luqui> I pointed you to the end of that conversation

[16:04] <luqui> I guess it never got resolved

[16:04] <luqui> we just asked all the questions :-)

[16:04] <fglock> heh

[16:05] * luqui can't remember if TimToady was on IRC back then

[16:06] <fglock> gaal: I guess my misunderstanding is - do you mean a hint to the parser, or a hint to everybody

[16:07] <luqui> probably:  import { X } LIST

[16:08] <luqui> so that a definition of import in that package wouldn't interfere with parsing...

[16:08] <luqui> er, in the calling package

[16:09] <gaal> oh, there's not problem in import -- not THAT problem anyway -- because it really is invoked correctly

[16:10] <gaal> the problem is that C<meth $obj> might mean __PACKAGE__::meth($obj) or $obj->meth

[16:10] <gaal> this problem does not exist in Perl 6

[16:12] <avar> gaal: there's more to it than that, see the mess that is toke.c

[16:12] <avar> iirc at least, there were all sorts of nasty exceptions:)

[16:12] <avar> it's the part of the parser which perldoc calls "not strictly predictable":)

[16:15] *** jrockway_ joined
[16:18] <avar> well of course it means one or the other, but the parsing rules are explained in S_intuit_method(pTHX_ char *start, GV *gv, CV *cv)

[16:19] <luqui> ?eval sub foo (&infix:<+>) { 2 + 3 }     foo &infix:<*>

[16:19] <evalbot_r15003> 6

[16:20] <luqui> ?eval sub foo (&infix:<@@>) { 2 @@ 3 }     foo &infix:<*>

[16:20] <evalbot_r15003> Error: ␤Unexpected "@@ 3"␤expecting operator or "}"

[16:20] <luqui> aww

[16:21] <luqui> ?eval sub infix:<!!> ($x, $y) { $x + $y }   3 ?? 4 !! 5 !! 6;

[16:21] <evalbot_r15003> Error: ␤Unexpected ";"␤expecting "_", fraction, exponent, term postfix, operator or "!!"

[16:21] <luqui> ?eval sub infix:<!!> ($x, $y) { $x + $y }   5 !! 6;

[16:21] <evalbot_r15003> 11

[16:21] <luqui> ?eval sub infix:<!!> ($x, $y) { $x + $y }   3 ?? 5 !! 6;

[16:21] <evalbot_r15003> Error: ␤Unexpected ";"␤expecting "_", fraction, exponent, term postfix, operator or "!!"

[16:21] <luqui> ?eval 3 ?? 5 !! 6;

[16:21] <evalbot_r15003> 5

[16:22] <luqui> ?eval sub infix:<!!> ($x, $y) { $x + $y }   3 ?? (5 !! 6) !! 7;

[16:22] <evalbot_r15003> Error: ␤Unexpected ";"␤expecting "_", fraction, exponent, term postfix, operator or "!!"

[16:23] <luqui> ?eval my $x;  BEGIN { $x = '@@' };  sub infix:{$x} ($a,$b) { $a + $b };   3 @@ 4;

[16:23] <evalbot_r15003> 7

[16:24] <luqui> perl is going to be far too powerful at compile-time

[16:24] <luqui> :-)

[16:25] <luqui> ?eval my &infix:<@@> ::= &infix:<+>;  3 @@ 4

[16:25] <evalbot_r15003> Error: ␤Unexpected "@@ 4"␤expecting operator

[16:25] <luqui> ?eval &infix:<@@> := &infix:<+>;  3 @@ 4

[16:25] <evalbot_r15003> Error: ␤Unexpected "@@ 4"␤expecting operator

[16:25] <luqui> ?eval &infix:<@@> = &infix:<+>;  3 @@ 4

[16:25] <evalbot_r15003> Error: ␤Unexpected "@@ 4"␤expecting operator

[16:25] <luqui> ?eval &infix:<@@> = &infix:<+>;

[16:25] <evalbot_r15003> Error: Can't modify constant item: VStr "MkCode {isMulti = True, subName = \"&\", subType = SubPrim, subEnv = Nothing, subAssoc = ANil, subParams = [], subBindings = [], subSlurpLimit = [], subReturns = (mkType \"Any\"), subLValue = False, subBody = Prim ([Pugs.AST.Internals.Val] -> () Pugs.AST.Internals.Val), subCont = Nothing, subPreBlocks = [], subPostBlocks = [], subFirstBlocks = [], subLastBlocks = [], subNextBlocks = [], subKeepBlocks = [], 

[16:26] <luqui> ?eval &infix:<@@> := &infix:<+>;

[16:26] <evalbot_r15003> Error: Bind to undeclared variable: "&infix:@@"

[16:26] *** kanru joined
[16:26] <luqui> ?eval { my sub infix:<@@> ($x, $y) { 3 @@ 4 } }

[16:26] *** silug joined
[16:27] <evalbot_r15003> Error: ␤Unexpected "@@ 4"␤expecting operator or "}"

[16:27] <luqui> ?eval { my sub infix:<@@> ($x, $y) { $x + $y } 3 @@ 4 }

[16:27] <evalbot_r15003> 7

[16:27] <luqui> ?eval { my sub infix:<@@> ($x, $y) { $x + $y } } 3 @@ 

[16:27] <evalbot_r15003> Error: ␤Unexpected "3"␤expecting operator

[16:27] <luqui> ?eval { my sub infix:<@@> ($x, $y) { $x + $y } } 3 @@ 4

[16:27] <evalbot_r15003> Error: ␤Unexpected "3"␤expecting operator

[16:27] <luqui> okay, so remaining problems:

[16:28] <luqui> ?eval sub infix:<@@> ($x, $y) { $y @@ $x }   # no parse

[16:28] <evalbot_r15003> Error: ␤Unexpected "@@ $x"␤expecting operator or "}"

[16:28] <luqui> sub foo(&infix:<@@>) { 3 @@ 4 }  # no parse

[16:28] <luqui> ?eval sub foo(&infix:<@@>) { 3 @@ 4 }  # no parse

[16:28] <evalbot_r15003> Error: ␤Unexpected "@@ 4"␤expecting operator or "}"

[16:28] <fglock> try adding ; after eval

[16:28] <fglock> because it doesn't have a line break

[16:28] <luqui> wait, where?

[16:29] <fglock> oh sorry - I was misreading ?eval 

[16:31] <fglock> luqui: the reason I'm asking is because I'm adding 'BEGIN' to the mp6 implementation, and I'm trying to define the compiler workflow at a higher level

[16:32] <luqui> cool.

[16:33] <luqui> I think the strange interplay between compile-time and run-time variables is going to prevent the maximally elegant design

[16:33] <luqui> but do ask if you have any questions, and I'll *try* to answerthem

[16:34] <fglock> I'll need some clean way to have the compile-time env, too

[16:35] <luqui> you mean after a program compiles, you need to save the state

[16:35] <luqui> ?

[16:36] <luqui> so that it can be run (perhaps later, multiple times)

[16:37] <fglock> I mean, where does it store the pad structure

[16:38] <fglock> the state would be preserved as AST nodes, I presume

[16:38] <luqui> I recall coming up with a nice design for this at the hackathon

[16:38] <luqui> ask audreyt when she awakes

[16:39] <luqui> (hopefully she will remember better than I)

[16:40] <luqui> but can't it just store it alongside everything else

[16:40] <luqui> storing references to pads (so that more than one thing can refer to the same pad)

[16:40] *** jrockway_ is now known as jrockway

[16:40] <luqui> i.e., all lexical scopes exist at compile time

[16:40] <luqui> and they are cloned at runtime as needed

[16:40] <luqui> to create pads...

[16:41] <luqui> it seems a little asymmetrical, but it makes sense

[16:41] <luqui> I am just dumping words as they come into my head

[16:42] <fglock> let's see - mp6 pads are native, while compile-time pads are object or hash

[16:42] <luqui> oh, ouch

[16:43] <fglock> after parsing, the compile-time pads are not needed, because all info is stored in the AST

[16:43] <luqui> hm... food for thought:   my $x;   BEGIN { $x = 42; }  say $x;

[16:43] <luqui> where does 42 go?

[16:46] <fglock> dumping the env actually means this is compiled to: my $x; INIT { $x = 42; } say $x;

[16:46] <fglock> ?

[16:47] <luqui> that is conceivable

[16:48] * luqui tries to think of a case where that doesn't work...

[16:48] <fglock> it would work for 'use', I think

[16:49] <luqui> you mean to call import?

[16:49] <luqui> of course this:  BEGIN { say "Hello, World!" } doesn't turn into INIT { say "Hello, World!" }

[16:49] <luqui> but that's obvious

[16:50] <fglock> maybe it would turn into INIT { 1 } because that's what BEGIN returned

[16:50] <fglock> s/returned/dumped/

[16:51] <luqui> my $x; BEGIN { $x = { $x } }   # just brainstorming

[16:51] <fglock> is import compile-time only?

[16:51] <luqui> yeah

[16:52] <fglock> it could just be implemented as a run-time no-op

[16:53] <luqui> import is just a sub call

[16:54] <luqui> there is nothing special about it

[16:56] <fglock> you could tell 'use' to only call 'import' at compile-time

[16:58] <luqui> supposing that use X; is shorthand for BEGIN { require X;  X.import if X.can('import') }, wouldn't that happen anyway?

[16:58] <luqui> I think the contents of the {...} in the BEGIN case and in the INIT case being the same was only a coincidence

[16:58] <luqui> (above)

[16:59] <luqui> you have your compile-time pads

[16:59] <luqui> evaluate everything

[16:59] <luqui> then during code generation, output  INIT blocks to bring the runtime-pads to what they were at compile-time

[17:00] <luqui> it's very strange, because in the following:

[17:00] <luqui> my $x = { my $y;  BEGIN { $y = 42 } }

[17:01] <luqui> the pad containing $y exists *before* the closure does!

[17:03] <luqui> indeed, in the following, I'm not even sure what the behavior is:

[17:03] <fglock> I guess that from the env point of view, it's not a closure

[17:03] <luqui> ?eval for 1,2 { my $x = { my $y;  BEGIN { $y = 42 }; say $y };  $x() }

[17:03] <evalbot_r15003> OUTPUT[␤␤] undef

[17:03] <luqui> perhaps not

[17:04] <luqui> I would like to have a nice, pretty, consistent picture of all of this in my head

[17:04] <fglock> yes - I was reading about this case right now - http://aspn.activestate.com/ASPN/Mail/Message/perl5-porters/2132427

[17:04] <lambdabot> Title: Re: perl6 style BEGIN {} anyone? :: ASPN Mail Archive :: perl5-porters, http://tinyurl.com/yh2anv

[17:05] <luqui> except this is much more subtle than that problem

[17:05] <luqui> it's assigning to a variable which certainly doesn't exist until runtime at compile time

[17:06] <luqui> constant folding is just replacing an ast node

[17:06] <luqui> hmm

[17:06] <luqui> I think there is room for specification here

[17:06] <luqui> and I am inclined to outlaw the above case

[17:07] <luqui> so, how about this: it is illegal to assign to non-existant varaibles at compile-time

[17:07] <luqui> we just need to define 'exists' appropriately

[17:08] <luqui> a variable exists if... it is in a closure that cannot be cloned?

[17:08] <luqui> that is, if $x can only ever refer to one thing, then it exists at compile-time

[17:08] <luqui> I like that...

[17:09] <luqui> so crap like this:   for 1,2 { my $x;  BEGIN { $x = 10 };  say $x }

[17:09] <luqui> is illegal

[17:09] <luqui> but:  { my $x;  BEGIN { $x = 10 };  sub foo() { $x } }

[17:09] <luqui> is not

[17:09] <luqui> (assuming that closure was in void context...)

[17:10] <luqui> then, in the pad structure, you can store existent variables and reasonably initialize them at the beginning of runtime

[17:11] <luqui> inside their scope...

[17:11] *** nipra joined
[17:12] * luqui mulls over this a bit more before trying to write it up for p6l

[17:13] <fglock> I'm ok with that - it seems to avoid the problem

[17:20] <fglock> how is INIT {} different from {} in this context?

[17:21] <luqui> not terribly different...

[17:22] <luqui> I'm not actually sure in which context...

[17:22] <luqui> :-)

[17:25] <fglock> I mean, can BEGIN blocks be compiled to plain blocks

[17:25] <fglock> containing the local env dump

[17:26] <luqui> you mean INIT?

[17:26] <luqui> oh

[17:26] <luqui> no

[17:26] <luqui> you do mean BEGIN :-)

[17:27] <luqui> no, I think init is necessary

[17:27] <luqui> my $x;  say $x;  BEGIN { $x = 42 }

[17:27] <fglock> I think my confusion is, how do you run INIT blocks in a closure

[17:28] <luqui> that is what the proposal solves

[17:28] <luqui> this closure is unique, so you can create it at the beginning of the program if you have to

[17:28] <luqui> then just change the environment to it

[17:29] <fglock> that would be compiled to { $x=42; my $x; say $x }

[17:29] <luqui> (I am making many assumptions about your architecture)

[17:29] <luqui> ahh

[17:29] <luqui> I think that would work

[17:29] <fglock> or { my $x; { $x = 42; say $x } }

[17:29] <luqui> now I see what you're saying

[17:29] <luqui> given the new restrictions, I think that would work out

[17:29] <luqui> the new, hypothetical, restrictions

[17:30] <luqui> let's hope they make canon :-)

[17:31] <fglock> it could work like this - each 'my' decl creates a new pad, at compile-time

[17:31] <fglock> and BEGIN blocks are moved to the start of the pad code

[17:33] <luqui> where by "moved to " you mean "executed and then the pad's environment is dumped at" ?

[17:33] <fglock> yes

[17:34] <luqui> it is a little scary because it seems too simple

[17:35] <luqui> but I do think that it works...

[17:35] <luqui> I am in no position to prove it though

[17:37] <fglock> if you 'execute' the begin block repeatedly, it's not a big problem

[17:38] <luqui> ?

[17:38] *** _bernhard joined
[17:40] <fglock> a BEGIN block inside a for-statement is not a big problem

[17:40] <fglock> it will only execute once

[17:40] <luqui> true

[17:40] <luqui> but if it refers to variables whose scope is the for block, then you get into trouble

[17:42] <fglock> example?

[17:43] <luqui> for 1,2 { my $x;  BEGIN { $x = 3 } }

[17:43] <luqui> which $x is BEGIN referring to?

[17:43] <[particle]> for 1..3 -> $x { BEGIN { $x = 3; } say $x }

[17:43] <[particle]> heh, very similar examples :)

[17:43] *** kanru_ joined
[17:44] <[particle]> how many times does the loop run?

[17:44] <luqui> oh, careful with that

[17:44] <luqui> for isn't shorthand for while...

[17:45] <luqui> I'd say it runs three times no matter what

[17:45] <luqui> but that is not the point at the moment :-)

[17:45] <[particle]> good.

[17:45] <fglock> this would compile the same as if without BEGIN

[17:45] <luqui> so the $x = 3 is completely ignored

[17:45] <luqui> ?

[17:45] <fglock> because $x=3 dumps to $x=3

[17:45] <luqui> oh

[17:46] <luqui> I think that is special to this simplistic example

[17:46] <fglock> I guess it dumps an env diff

[17:46] <luqui> for 1..3 { my $x;  BEGIN { $x++ } }

[17:46] <fglock> at the end of BEGIN, $x=1

[17:47] <fglock> so it would compile to

[17:47] <fglock> for 1..3 { my $x=1 }

[17:47] * luqui tries to come up with an example that drives home that there are three different $x's

[17:48] *** justatheory joined
[17:48] <luqui> my $y; for 1..3 { my $x;  BEGIN { $y = { $x++ } } }  $y()

[17:49] *** justatheory joined
[17:49] <[particle]> better example

[17:49] <[particle]> but why {} around $x++ ?

[17:49] <[particle]> just for scoping?

[17:49] <luqui> it is a closure, closing over the $x inside the for

[17:50] <luqui> except there are three different $x's to close over... which one is it?

[17:50] <[particle]> ah, yes. very good example

[17:51] <luqui> I suppose the semantics are unambiguous there.  To make them ambiguous:

[17:52] <luqui> my $y; for 1..3 { my $x = $_;  BEGIN { $y = { $x } } }  $y()

[17:52] <fglock> let's see - that de-BEGINs to: my $y; for 1..3 { my $x; { $y = sub{ $x++ } } } $y()

[17:52] <luqui> there, that is sufficiently f'ed up

[17:52] <luqui> fglock, so you assign to $y three times?

[17:52] <luqui> what if $y is tied?

[17:53] <fglock> you can use a FIRST block, I guess

[17:56] <luqui> so I guess my point is that in at least this situation, it isn't meaningful to say { $x }

[17:56] <luqui> (as a closure creation)

[17:56] <luqui> oh, here we go:

[17:57] <luqui> my $y;  if rand() < 0.5 { my $x = 4;  BEGIN { $y = { $x } } } $y()

[17:57] <luqui> throw in a BEGIN { say $y } before $y() if you please

[17:58] <[particle]> or after

[18:01] *** weinig|bbl is now known as weinig

[18:02] *** buetow joined
[18:06] *** kanru joined
[18:15] <fglock> does placing a 'ran' flag in the block helps? such that it is only run once

[18:16] <[particle]> so, all closures get a loop counter?

[18:17] *** ofer0 joined
[18:17] <fglock> only for desugared BEGIN-blocks

[18:18] <fglock> BEGIN { $x=1+1 } desugars to { $x = 2 } unless $__global1234++

[18:19] <fglock> oops - something like that

[18:20] <luqui> see rand() example

[18:20] <[particle]> after BEGIN is executed, it returns a closure with a reset loop counter

[18:22] <[particle]> luqui: isn't $x undefined at BEGIN time in that example?

[18:22] <luqui> okay...

[18:23] <luqui> but what happens if the random number is less that 0.5?

[18:23] <luqui> does $y() return 4?

[18:23] <luqui> and if not, $y() returns undef?

[18:23] <luqui> then modify to this:

[18:24] <luqui> my $y;  for 1..rand(10) { my $x = $_;  BEGIN { $y = { $x } } }  $y()

[18:24] <luqui> now what?

[18:25] <luqui> I assume it will be 1 if the body ever gets executed

[18:25] <luqui> and undef otherwise

[18:25] <luqui> okay

[18:25] <luqui> hmm

[18:25] <luqui> so the question is, does such a transformation always work

[18:26] <luqui> oh...

[18:26] <luqui> so even if the block is never executed.. $y is not undef

[18:26] <luqui> so how do you handle that?

[18:26] <luqui> (this was the problem in the rand() case too)

[18:27] <luqui> I just distracted myself... :-)

[18:27] <fglock> how does p5 handles this?

[18:27] <luqui> so to clarify, $y() can return undef, but regardless $y is a code object, and has to refer to something

[18:28] <fglock> is the 'for' pad pre-allocated?

[18:28] <luqui> the first time you execute a block, you don't clone the pad

[18:28] <luqui> it's already there

[18:28] <luqui> it can get away from that because it doesn't separate compile time and runtime

[18:29] <luqui> s/from/with

[18:30] <[particle]> what about C< BEGIN { $x } say $x >: does this complain that $x is undeclared? (no C<my>)

[18:30] <[particle]> or is there a pad entry because it's used in begin

[18:31] <TimToady> no, the BEGIN would fail with "undeclared".

[18:31] <TimToady> in fact, the *compilation* of the BEGIN would fail.

[18:31] <luqui> TimToady, did you see my proposal above?

[18:32] <TimToady> it seems sane to the first approx

[18:32] <fglock> does this means that the rand example is forbidden?

[18:32] <TimToady> whether we can get the "first time through" uses compiler's pad thing to work is the real issue, I expect

[18:32] <[particle]> and C<my $x; BEGIN { $x = 3 }> compiles?

[18:32] <TimToady> not forbidden, just nonsensical

[18:33] <TimToady> GIGO

[18:33] <TimToady> I don't think we have to go to extraordinary lengths to make non-determinstic code deterministic

[18:33] <TimToady> at some point you say, we don't penalize the innocent with the guilty

[18:33] <luqui> well my proposal would like the rand example to be forbidden

[18:33] <TimToady> and it's just erroneous

[18:34] <fglock> do you think it's possible to desugar BEGIN blocks out after parsing?

[18:34] <TimToady> no

[18:34] <TimToady> er, yes

[18:35] <TimToady> not sure what you're asking exactly

[18:35] <TimToady> BEGIN blocks are executed and turned into a value, side effects have to have something at compile time to effect

[18:35] <TimToady> the question in my mind

[18:35] <TimToady> is whether a lexical that will be cloned

[18:36] <TimToady> has an initial value at compile time

[18:36] <TimToady> in the absence of an explicit =

[18:36] <TimToady> so you could make a lexical spring into existence with a value when cloned rather than undef.

[18:36] <TimToady> but generally,

[18:36] <TimToady> I think the approved way to do that is not with an assignment in a BEGIN

[18:36] <TimToady> but to say

[18:36] <TimToady> my $x = BEGIN {...}

[18:37] <TimToady> so I don't think we need to go to pains to try to make

[18:37] <TimToady> for 1..3 { my $x; BEGIN { $x = ... }}

[18:37] <TimToady> do anything special

[18:38] <TimToady> if a decent error message can be produced

[18:38] <TimToady> then that's better than merely declaring it erroneous

[18:38] <fglock> I'm asking if you can substitute BEGIN {} with some run-time code, possibly derived from the env difference before and after the BEGIN was executed...

[18:38] <TimToady> maybe something a little better than "variable will not stay shared"

[18:38] <luqui> like:   "error, example.pl line 6:  you must be out of your mind"

[18:39] <TimToady> :)

[18:39] <[particle]> error: BEGIN inside loop construct, RETARDO!!!

[18:39] <luqui> fglock, I've been trying to prove that you can't in general, for the last four examples

[18:40] <luqui> I may be mistaken, but I think the rand() example gets at the heart of it

[18:40] <fglock> luqui: I mean, considering that you have disallowed some constructs

[18:40] <TimToady> I agree with luqui on the general principle--a BEGIN can only influence structures that exist at compile time by side effect.  Other than that, all it can do is return a value.

[18:41] <luqui> fglock, oh, then I think you can

[18:41] <TimToady> the "extra" question is whether there are extraordinary structures we can have at compile time that do things at run time

[18:41] <TimToady> and I think the answer is, don't sweat it for now.

[18:41] *** weinig_ joined
[18:43] <TimToady> I suppose one could view the value returned by BEGIN as somehow lazy till run time, if the need arises, but I don't really see much need.

[18:43] <TimToady> the point of BEGIN is to make something happen Right Now as far as the compiler is concerned.

[18:44] <fglock> I'm wondering how to implement separate compile/run in p5, without executing BEGIN blocks at both

[18:44] <fglock> p6-on-p5

[18:44] <TimToady> in that sense the BEGIN blocks are gone by run time

[18:44] <TimToady> all you see is their results

[18:45] <fglock> hmm - that's what I was meaning with 'desugaring'

[18:45] <luqui> right.  I think you can generate code to initialize all "compile-time existing" variables at the beginning of their scopes, and the semantics will be correct

[18:46] <luqui> (though it is indeed a bit tricky if they refer to each other)

[18:46] <fglock> but in the case of the 'random' example, I need to do this with a BEGIN block, right?

[18:47] <fglock> in p5 land

[18:47] <luqui> you mean it is impossible to factor that out into a program with no BEGIN?

[18:47] <luqui> I think so.

[18:48] <fglock> think so == impossible ?

[18:49] <luqui> yeah

[18:49] <TimToady> are you asking if BEGIN is a primitive?

[18:49] <TimToady> BEGIN is purposeful installation of the halting problem within the compiler.  :)

[18:49] *** rindolf joined
[18:49] <rindolf> Hi all!

[18:49] <rindolf> I saved a perlbug bug report to a file. Now how do I submit it using perlbug?

[18:50] <TimToady> around here you just fix the bug yourself and check it into svn.  :)

[18:50] <rindolf> TimToady: heh.

[18:50] <fglock> man perlbug ..?

[18:51] <rindolf> fglock: I searched it for "save" and could not find a single occurence of the word.

[18:51] <integral> you email it to [email@hidden.address] (iirc)

[18:51] <rindolf> integral: OK.

[18:52] *** kanru joined
[18:53] <fglock> how about this: you execute the BEGIN block, and then generate code that has an INIT block in that place - the INIT block redoes the side-effects

[18:53] <fglock> at run time

[18:54] <[particle]> how does it interact with INIT blocks in the source?

[18:54] <svnbot6> r15004 | luqui++ | Parsing of a sub definition now goes into effect before seeing

[18:54] <svnbot6> r15004 | luqui++ | the definition block.  I.e. this parses:

[18:54] <svnbot6> r15004 | luqui++ |   sub infix:<@@> ($x, $y) { $y @@ $x }

[18:54] <svnbot6> r15004 | luqui++ | It doesn't work with postfix operators for some reason!

[18:55] <rindolf> integral: will /usr/sbin/sendmail [email@hidden.address] < perlbug-segfault-in-compilation.rep work?

[18:55] <luqui> fglock, sure

[18:56] <luqui> so long as the side-effects are just the env differences

[18:56] <luqui> but [particle]  has a good point

[18:57] <fglock> if you wanted other run-time side-effects, you were supposed to put then in an INIT block, right?

[18:57] <rindolf> Hmmm... I cannot compile perl5.

[18:57] <rindolf> rgs: ping.

[18:57] <luqui> my $x;   INIT { $x = 1 }  BEGIN { $x = 2 };   say $x;

[18:58] <luqui> or even:

[18:58] <fglock> that's a problem

[18:58] <luqui> n/m

[18:58] <luqui> oh dear

[18:59] <luqui> I was going to say that you have to move side-effects to the beginning of the scope where the affected variables were

[18:59] <luqui> however:

[18:59] *** koye joined
[18:59] <luqui> my $x;   ...stuff { my $y;  BEGIN { $x = { $y };  $y = { $x } } ...stuff }

[18:59] <luqui> ahh, pathological examples, my favorite

[19:00] <luqui> it is impossible to initialize $x at the beginning of its scope

[19:00] <luqui> ok... so, BEGIN blocks can only work on "compile-time existing variables"  (this assumption is getting more and more useful)

[19:01] <luqui> so you don't scope them

[19:01] <luqui> they are all global

[19:01] <luqui> then you can rig them to refer to each other

[19:01] <luqui> (are you compiling to perl 5?  I guess I don't fully understand what your target is)

[19:01] <luqui> but of course, that has GC problems...

[19:02] <fglock> I'm compiling to "desugared p6", which compiles either to p5 or parrot

[19:02] *** theorbtwo joined
[19:02] <[particle]> you'll need weak references

[19:02] <fglock> see mp6

[19:02] <luqui> okay, that was enough information

[19:05] <luqui> hmm, so we need something where the creation of an object can claim a reference instead of creating it

[19:06] <luqui> this is not a standard language feature :-(

[19:06] <luqui> let's see here (brainstorming commencing)

[19:07] <luqui> all compile-time existing variables (CEVs) are globals with an extra level of indirection

[19:08] <fglock> what's a non-CEV example?

[19:09] <luqui> so:  "my $x;  BEGIN { $x = 4 };"   turns into "my $__CEV_x1 = \do { my $x };  $$__CEV_x1 = 4;"

[19:09] <luqui> non-CEVs are things like $x in for 1..3 { my $x }

[19:09] <fglock> k

[19:10] <luqui> then you undef the reference at the end of its scope

[19:11] <luqui> so:  "{ my $x;   say $x }"  turns into "my $__CEV_x1 ... ...;  { say $$__CEV_x1;  LEAVE { undefine $__CEV_x1 } }

[19:12] <luqui> the initialization of all CEVs happens first thing in the the program

[19:12] <luqui> before any other INIT blocks

[19:12] <luqui> I think that actually does solve the circular-dependency pathology

[19:13] <luqui> and the GC problem

[19:13] <luqui> it's just... ugly

[19:13] *** awwaiid joined
[19:14] <luqui> detecting the circular references could be really tricky

[19:14] * luqui ponders...

[19:14] <luqui> another pathological example

[19:15] <luqui> my $x; { my $y;  BEGIN { $x = { $y } } };  { my $z;  BEGIN { $x = { $x() + $z } } }

[19:17] <luqui> I know how to convert that

[19:17] <luqui> but coming up with an algorithm to do it, which can stand turing-completeness....

[19:19] * luqui wonders if it is possible just to "trace your path" in some sense

[19:20] <luqui> it's easy for numbers and strings and things like that which have an easy lexical interchange

[19:20] <luqui> but maybe you thunk closures and references

[19:21] <luqui> and just remember what you did to them

[19:21] <luqui> then do that again at the beginning of the program

[19:21] <luqui> I wonder if it's possible to do that without re-implementing the entire core to handle it

[19:22] <fglock> you can save $obj.perl and eval it back

[19:22] <luqui> if you could do it, I have to say, it would be a freaking sweet architecture

[19:22] <luqui> fglock, you can't do that with closures tho, right?

[19:23] <fglock> not now, but you should be able to do it

[19:23] <luqui> it's not a feasible problem in general, because of the inter-referentiality closures can have

[19:23] <luqui> oh!

[19:23] <luqui> but all the variables we are working with here have to be CEVs

[19:24] <luqui> wait... no

[19:24] *** polettix joined
[19:24] <luqui> my $y;  my $z; BEGIN { my $x;  $y = { $x };   $z = { $x } }

[19:24] <luqui> $x is not CEV, but you have to express that the variable that $y and $z are referencing are the same one

[19:25] <luqui> which is the unsolvable problem of serializing closures

[19:25] <fglock> yes, but both belong to env, which is a single struct

[19:25] <fglock> you are doing a snapshot

[19:26] <luqui> okay... how are you going to convince .perl to do that?

[19:27] <fglock> let's see...

[19:28] <fglock> trying with Data::Dump::Streamer

[19:31] <fglock> this works: perl -MData::Dump::Streamer -e '  my $x = sub { 3 }; my $y = { a => $x, b => $x }; print Dump $y; '

[19:33] <luqui> the more pertinent example is: my $x;  my $y = sub { $x++ };  my $z = sub { $x++ };  my $a = { y => $y, z => $z }; print Dump($a)

[19:33] <luqui> which, incredibly, works

[19:33] <fglock> :)

[19:33] <luqui> okay, DDS kicks butt

[19:35] <diotalevi> dmq++

[19:35] * luqui ponders compile-time continuations invoked at runtime

[19:35] * luqui ponders committing suicide, but then stops

[19:35] <luqui> I think it would be okay if we didn't support that... ever

[19:36] <fglock> parrot might support that, with proper .perl

[19:36] <luqui> uh... I'm not sure that's possible

[19:37] <luqui> I mean, if so, that'd be cool

[19:37] <luqui> but how do you start running, and then go back to compile-time?

[19:37] <luqui> oh

[19:37] <luqui> I see

[19:37] <luqui> well you wouldn't be doing separate compilation anymore

[19:37] <[particle]> yep

[19:37] <[particle]> it's all deferred to runtime

[19:38] <TimToady> It's lazy turtles all the way down...

[19:38] <luqui> oh, btw however, that it *is* impossible to .perl a continuation

[19:39] <luqui> you can serialize

[19:39] <luqui> them

[19:39] <luqui> but you can't in pure perl

[19:40] <luqui> (btw however, that ...; what the hell does that grammatical construct mean? :-)

[19:40] <TimToady> It's a pessimistic Whatever.  :)

[19:42] <TimToady> hmm, then there's the optimistic sub stub:

[19:42] <TimToady> sub foo { * }

[19:43] <[particle]> it's good to see the optimistic case is properly huffmanized :)

[19:43] <TimToady> say 1..foo()

[19:43] <luqui> real question:  will that make foo behave exactly like * in all cases?

[19:43] <TimToady> should

[19:43] <luqui> so * is not syntactic...

[19:43] <TimToady> it's the Whatever object

[19:44] <luqui> okay.

[19:44] <TimToady> which we match in sigs with the Whatever type.

[19:44] <TimToady> we had to do way with prefix:<*> to get it.

[19:44] <Juerd> *.foo();

[19:44] <TimToady> though you can still say *.() if you can persuade * to respond

[19:45] *** rindolf joined
[19:45] <TimToady> "just call something, I don't care..."

[19:45] <Juerd> 5 + * + 5

[19:45] <rindolf> Hi all.

[19:45] <TimToady> "I feel lucky..."

[19:45] <luqui> randomly generate a program and execute it

[19:45] <Juerd> kill *, $$;

[19:45] <luqui> you could use it to check your solution to the halting problem

[19:45] <TimToady> kill -INT, *;

[19:45] <Juerd> luqui++

[19:46] <Juerd> TimToady: In typing, can Whatever be abbrev'ed to *?

[19:46] <TimToady> generally not

[19:46] <Juerd> sub foo (*|Int $bar) { ... }

[19:46] <TimToady> no, * is slurpy in that context

[19:46] <Juerd> Of course

[19:46] <TimToady> and Whatever needs dehuffmanization

[19:47] <TimToady> when you're writing multis

[19:47] <rindolf> rgs: I'm unable to compile bleadperl on Mandriva Linux 2007.

[19:47] <luqui> shouldn't | be slurpy?

[19:47] <Juerd> So $* variables are whatever-scoped, right? :)

[19:47] <TimToady> indeed

[19:47] <TimToady> wherever you go, there they are.

[19:48] <Juerd> TimToady: Can * in void context please say "Hello, World!"?

[19:48] <TimToady> you mean |@rest instead of *@rest?

[19:49] <TimToady> I think it wants to spit out 99 bottles of beer on the wall...

[19:49] *** weinig_ is now known as weinig

[19:49] <Juerd> TimToady: any(hello, bottles, quine) :P

[19:49] <luqui> Aleph-0 bottles of beer on the wall, aleph-0 bottles of beer.  Take one down, pass it around, aleph-0 bottles of beer on the wall!

[19:50] <TimToady> a bottle of quininety-nine...

[19:50] <rindolf> luqui: heh.

[19:50] <rgs> rindolf: I'm not, what's the problem?

[19:51] <rindolf> rgs: you mean, you *are* able to compile bleadperl?

[19:51] <rgs> yes

[19:51] <rindolf> rgs: ah OK.

[19:51] <rindolf> rgs: let me try again.

[19:52] <rgs> and tell me the error(s)

[19:52] <rindolf> rgs: OK.

[19:52] *** milan joined
[19:52] <[particle]> * in void context is an entire language implementation (hq9+)? wow!

[19:53] <[particle]> good april fool's idea

[19:53] <diotalevi> Is there a concept of "stashes" in Perl 6? I tried doing a thing in perl 5 where I took a sub ref, localized the stash it came from, gave it an AUTOLOAD, then called the function to have it trigger the AUTOLOAD except it didn't work because the function didn't notice the localized stash. I want to know if I can make such a thing work in Perl 6.

[19:54] <Juerd> [particle]: I don't see why not.

[19:54] <Juerd> And why it would be an april fool's thing :)

[19:54] <luqui> diotalevi, I'm not reaally sure what you're asking

[19:55] <Juerd> If anything should be huffmanized, it's Hello, World :)

[19:55] <TimToady> I think the compiler has to be able to optimize based on what it thinks is the symbol table.

[19:56] <luqui> oh that, yeah I tried that too

[19:56] <luqui> so, what if you said at compile time that "this isn't a regular symbol table, don't optimize!"

[19:56] <luqui> for some tree of the symbol table

[19:56] <luqui> s/tree/subtree/

[19:57] <TimToady> all things are possible, but I'd like to get Perl 6 out the door by Christmas...

[19:57] <diotalevi> luqui: I'm asking if I can substitute the symbol table for something else at runtime. You already know it can be modified at runtime but I wanted to do the moral equivalent of local %Foo::. Perl 5 has taken a pointer to it so it loses immediately.

[19:58] <luqui> ahh, I wanted to tie it

[19:58] <TimToady> you need a declarative tie, which P6 presumably gives you better

[19:58] <luqui> no, I meant in perl 7

[19:58] <allbery_b> isn't there some discussion of this in one of the synopses already?

[19:58] <diotalevi> Oh yeah, I think schwern said that stashes in p5 can't take tie magic. That'd solve my problem too if it worked.

[19:59] <TimToady> not if the tie happens too late for the compiler to notice.

[19:59] <TimToady> in p5 tie is run-time only.

[19:59] <TimToady> you need something compile time, like "is XXX"

[19:59] <fglock> decommute &

[19:59] <diotalevi> Hmm. ok.

[20:00] * diotalevi figures he can accomplish this in Perl 5 with B::Generate's as yet unwritten B::CV::STASH( cv, new stash ) mutator method.

[20:02] <TimToady> package Foo is Pessimized;

[20:07] *** rhizo joined
[20:24] *** lisppaste3 joined
[20:29] <rindolf> rgs: I got to the test stage now.

[20:29] <rindolf> rgs: I guess it was a one-time-bug.

[20:31] <rgs> arf

[20:34] <rindolf> rgs: what do you mean by "arf"?

[20:34] <rgs> the usual onomatopea emitted by programmers confronting an heisenbug

[20:39] <rindolf> rgs: I see.

[20:45] <rindolf> rgs: <<< All tests successful. >>>

[21:52] *** Aankhen`` joined
[21:54] *** frankg joined
[21:56] *** Schwern joined
[22:06] *** justatheory joined
[22:07] *** justatheory joined
[22:20] *** koye joined
[22:33] *** lisppaste3 joined
[22:45] *** ashleyb joined
[22:47] *** dduncan joined
[22:58] *** gene9 joined
[23:18] *** Psyche^ joined
[23:34] *** Psyche^ is now known as Patterner

[23:48] *** py1hon joined
