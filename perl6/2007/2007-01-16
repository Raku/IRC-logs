[00:02] *** buetow joined
[00:07] *** Psyche^ is now known as Patterner

[00:07] <putter> anyone around?

[00:08] <luqui> yeah

[00:09] <putter> I'm puzzling over release backends.  It looks like the current candidates are p5, parrot, hs(?), whatever vm someone writes and emitter for.  that sound about right?

[00:10] <putter> And of those, the only one which could conceivably not be mostly written in p6 is hs, yes?

[00:12] <luqui> I'm not really sure what you're talking about...

[00:12] <luqui> are you wondering what to call the backends for the release?

[00:15] <putter> It Xmas.  We have a releasable perl6.  There seem several possibilities.  Its vm could be p5, parrot, ...

[00:16] *** cognominal joined
[00:16] <putter> Though I think question is whether anything by a hs-based p6 might not be implemented in p6 itself.  At one time self hosting was said to be a post 6.0 concept.

[00:17] <putter> But it looks like the only current senario where that seems plausible is a hs-based release.

[00:18] <putter> I'm looking for a reality check, plus any comments like "selfhosting is now speced for 6.0", or "hs-based release has been removed from consideration".

[00:19] <putter> or even "vm is now required to be p5-based for compatibility/deployment reasons".

[00:19] <putter> any idea?

[00:19] <luqui> as far as spec goes

[00:19] <luqui> I think it's whichever one happens

[00:20] <luqui> we would like it to be parrot based

[00:20] <putter> k

[00:20] <putter> ok

[00:20] <putter> thanks

[00:27] *** nipra joined
[00:30] *** nipotaway is now known as nipotan

[00:37] *** mako132_ joined
[00:40] *** diakopte1 joined
[00:40] *** diakopte1 left
[01:02] *** lyokato joined
[01:04] *** b00t joined
[01:11] *** autark_ joined
[01:12] <putter> Anyone know if http://www.perlfoundation.org/gc/grants/2005-p6-proposal.html is still the parrot roadmap?

[01:12] <lambdabot> Title: The Perl Foundation

[01:18] *** lisppaste3 joined
[01:20] * luqui dunnos

[01:20] <putter> tnx

[01:23] <luqui> putter, i searched the meeting notes for "roadmap", and nothing consequential came up

[01:23] <luqui> so either it's still in effect, or it has been gradually phased out without anybody noticing :-)

[01:24] *** lisppaste3 joined
[01:34] *** diakopter joined
[01:41] *** shobadobs joined
[01:43] *** shobadobs left
[01:44] *** rashakil joined
[01:46] <putter> luqui: lol.  my thanks.

[01:56] <putter> sigh.  dsl's without a full language - just dandy until you hit the inevitable screw case. :/

[02:20] <putter> revised http://www.vendian.org/mncharity/TemporaryURL/deleteme.png and .dot

[02:22] <putter> &

[02:24] *** lisppaste3 joined
[02:25] <luqui> that's a nice graph.  it's motivating ;-)

[02:43] *** penk joined
[02:45] *** vel joined
[02:55] *** ProperNoun joined
[03:15] *** mdiep joined
[03:16] <luqui> @tell putter what can I do to help on mp6/kp6?

[03:16] <lambdabot> Consider it noted.

[03:17] *** b00t joined
[03:26] *** mdiep joined
[03:27] <luqui> @tell putter whoops, fglock is doing that stuff, not you, right?  hmm, I'll ask him

[03:27] <lambdabot> Consider it noted.

[03:27] <luqui> @tell fglock what can I do to help on mp6/kp6?

[03:27] <lambdabot> Consider it noted.

[03:43] *** leed joined
[03:51] *** mako132_ joined
[03:52] *** Aankh|Clone joined
[04:36] *** nipra joined
[04:47] *** nperez joined
[05:00] *** thestarslookdown joined
[06:15] *** BooK joined
[06:22] *** GabrielVieira2 joined
[06:33] *** avarab joined
[06:46] *** avarab_ joined
[06:48] *** avarab_ is now known as avar

[07:11] *** ilogger2 joined
[07:15] *** Aankh|Clone joined
[07:33] *** avarab joined
[07:39] *** iblechbot joined
[07:43] *** avarab_ joined
[07:46] *** xinming joined
[08:01] *** Aankhen`` joined
[08:30] *** spx2 joined
[08:37] *** Lunchy_ joined
[09:04] *** elmex joined
[09:29] *** ruoso joined
[10:03] *** takesako__ joined
[10:16] *** mj41 joined
[10:19] *** fglock joined
[10:22] <masak> http://c2.com/cgi-bin/wiki?MultiMethods

[10:23] <lambdabot> Title: Multi Methods

[10:32] <fglock> luqui: re kp6 - right now, it would be nice to have someone review the design decisions

[10:32] <lambdabot> fglock: You have 2 new messages. '/msg lambdabot @messages' to read them.

[10:33] <fglock> putter: re Data::Bind - it looked like a problem with perl itself, and there was a bug report to p5p

[10:55] *** yves joined
[10:56] <svnbot6> r15077 | fglock++ | kp6 - added 'Assign' to the grammar

[10:59] <svnbot6> r15078 | fglock++ | kp6 - fix last commit

[11:07] *** xinming joined
[11:15] *** xinming joined
[11:17] <svnbot6> r15079 | fglock++ | kp6 - added ChangeLog

[11:27] <fglock> re S06: how does an anonymous our-subroutine work? it can't be added to the namespace

[11:29] *** f0rth joined
[11:31] <fglock> also re S06: s/package GLOBAL/module GLOBAL/

[11:33] *** cmarcelo joined
[11:33] *** avarab_ is now known as avar

[12:01] <fglock> re S02: how about replacing 'package' with 'namespace', to avoid confusion with p5 'package'

[12:53] *** ofer0 joined
[12:53] *** Limbic_Region joined
[13:06] <svnbot6> r15080 | kudra++ | Corrected spelling of a word

[13:15] <svnbot6> r15081 | fglock++ | kp6 - added a Perl5-emitter plug-in

[13:19] <pasteling> "evalbot_r15080" at 194.145.200.126 pasted "Pugs build failure" (375 lines, 20.9K) at http://sial.org/pbot/22428

[13:22] <Juerd> Oh my... evalbot pastebots :)

[13:22] <Juerd> Incredibly clever :)

[13:23] <rgs> when will it begin to propose patches :)

[13:23] <Juerd> Or just commit them :P

[13:25] *** buetow joined
[13:30] <svnbot6> r15082 | fglock++ | kp6 - added kp6-perl5.pl script - compiles kp6 to perl5

[13:30] *** weinig joined
[13:32] *** iblechbot joined
[13:42] *** gnuvince joined
[13:45] *** thepler joined
[14:09] *** [particle] joined
[14:13] *** VanilleBert joined
[14:14] <masak> ?eval [ 'a' .. 'z', 0 .. 9 ].pick(10).join()

[14:14] <evalbot_r15082> "etk2pr1oxv"

[14:14] <masak> very well

[14:14] <Juerd> pick takes an argument. Heh.

[14:14] <masak> but pick(10) doesn't put them back, does it?

[14:14] <Juerd> What do you mean by "put back"?

[14:15] <Juerd> ?eval ~~['a'..'z',0..9].pick:10

[14:15] <masak> random selection with/without replacement

[14:15] <evalbot_r15082> Error: ␤Unexpected "~~['"␤expecting program

[14:15] <Juerd> ?eval ~~(['a'..'z',0..9].pick:10)

[14:15] <evalbot_r15082> Error: ␤Unexpected "~~(['"␤expecting program

[14:15] <Juerd> ?eval ~['a'..'z',0..9].pick:10

[14:15] <evalbot_r15082> Error: ␤Unexpected ":10"␤expecting term postfix or operator

[14:15] <masak> if I want replacement, I have to do this:

[14:15] <Juerd> ?eval ~['a'..'z',0..9].pick: 10

[14:15] <evalbot_r15082> "w k f h 8 j o y t u"

[14:15] <masak> ?eval ( { ['a' .. 'z', 0 .. 9 ].pick() } xx 10 ).map:{ .() }.join()

[14:15] <evalbot_r15082> "8g5w3muf20"

[14:15] * masak loves p6

[14:15] <Juerd> What's the difference?

[14:16] <masak> slight, but there

[14:16] <Juerd> Which is the difference?

[14:16] <Juerd> :)

[14:16] <masak> in the latter, I could get the same letter twice

[14:16] <masak> in the former, I never will

[14:16] <Juerd> Ahh

[14:16] <masak> hence "with replacement"

[14:16] <masak> like an urn, you know :)

[14:16] <Juerd> ?eval ~['a'..'z'].pick(26).join

[14:16] <evalbot_r15082> "shunzcmjtpofixqgldkvbaeryw"

[14:17] <Juerd> That ~ wasn't needed :)

[14:17] <masak> yep, all there

[14:17] <Juerd> ?eval ['a'..'z'].pick(52).join

[14:17] <evalbot_r15082> "fmwydzeuatonqrlcbjighkpxvs"

[14:17] <masak> heh

[14:17] <masak> can't fool pick

[14:17] <Juerd> Too bad

[14:17] <Juerd> ?eval { ['a'..'z',0..9].pick } xx 10

[14:17] <evalbot_r15082> ({Syn "block" {App &pick (Syn "\\[]" {Syn "," {App &infix:.. (: ␤                                                             "a", "z");␤                                              App &infix:.. (: 0, 9)}}: )}}, {Syn "block" {App &pick (Syn "\\[]" {Syn "," {App &infix:.. (: ␤                                                             "a", "z");␤                                              App &infix:.. (: 0, 9)}}: )}}, {Syn "block" {Ap

[14:18] <masak> yow

[14:18] <masak> you need to eval them

[14:18] <masak> with .()

[14:18] <masak> s/eval/apply/

[14:18] <Juerd> Then I'd still expect 10 subs.

[14:19] <Juerd> Or is this how pugs stringifies closures? :)

[14:19] *** vel joined
[14:19] <masak> guess so

[14:19] <Juerd> ?eval { ['a'..'z',0..9].pick } xx 10 >>.()

[14:19] <evalbot_r15082> Error: ␤Unexpected ">>.()"␤expecting operator

[14:20] <masak> I think the >>ops are broken

[14:21] <masak> been so a while now

[14:22] <masak> prove6 t/operators/hyper.t has a few :todos in it

[14:25] *** chris2 joined
[14:26] *** [particle] left
[14:30] *** weinig is now known as weinig|bbl

[14:37] *** theorb joined
[14:46] *** nipra joined
[14:47] *** elmex_ joined
[14:51] *** theorb is now known as theorbtwo

[14:52] *** jferrero joined
[14:53] *** [particle] joined
[14:56] *** bonesss joined
[14:59] *** fglock joined
[15:24] *** jferrero joined
[15:30] *** hexmode joined
[15:31] <hexmode> km;/

[15:35] *** fglock_ joined
[15:40] *** fglock joined
[15:44] *** xinming joined
[15:47] <TimToady> pick has an optional boolean parameter specifying :repl

[15:47] <TimToady> not implemented though

[15:48] *** CardinalNumber joined
[15:48] <TimToady> and "package" is the Perl word for "namespace"

[15:48] <TimToady> I don't see any reason to make another alias for that.

[15:52] <masak> TimToady: :repl, great

[15:52] <TimToady> I do kinda wish I could say ['a'..'z',0..9].[rand(*) xx 10] though

[15:53] <TimToady> ?eval ['a'..'z',0..9].[map {rand 32}, ^10]

[15:53] <evalbot_r15082> ["h", "e", "b", "e", "x", 4, "q", 5, 0, "h"]

[15:53] <TimToady> ?eval ['a'..'z',0..9].[map {rand 32}, ^10]

[15:53] <evalbot_r15082> ["b", "h", "a", "y", "e", "e", "q", 3, 0, "t"]

[15:53] <TimToady> that works

[15:54] <TimToady> er, except it should be 36... :/

[15:55] <[particle]> of course, that's base 36

[15:55] <[particle]> so, can you get the size of the list inside the selector?

[15:56] <TimToady> the list might not even be generated yet

[15:56] <[particle]> of course it would make it unlazy

[15:56] <TimToady> ?eval ['a'..'z',0..*].[map {rand 36}, ^10]

[15:56] *** xinming_ joined
[15:56] <evalbot_r15082> pugs: out of memory (requested 1048576 bytes)

[15:56] <TimToady> oops

[15:56] * [particle] notes, 'stop saying "of course"'

[15:59] <TimToady> if @a[*;1] has * meaning all of the current dimension, then maybe +* is the size of the current dimension.

[16:00] <TimToady> not quite sure if ['a'..'z',0..9].[map {rand 32}, ^10]

[16:00] <TimToady> er

[16:00] <TimToady> not quite sure if ['a'..'z',0..9].[map {rand +*}, ^10] would work though

[16:01] <[particle]> i think it needs something explicit to act upon

[16:04] <TimToady> well, I'm not gonna think about that much.  this morning I'm much more worried about how we carry the longest-token rule through a grammar consistently.

[16:04] <TimToady> I'm not sure the <%foo|%bar|%baz> notation is sufficient, quite.

[16:05] *** diakopter joined
[16:05] <[particle]> where does it fall down?

[16:06] <TimToady> several ways

[16:06] <TimToady> the inheritance problem could be worked around saying %.baz instead of %baz

[16:06] *** diakopter left
[16:06] <TimToady> and saying that if you have "rule baz", it can be used as a hash

[16:07] <TimToady> in which case it is required to be able to cough up a table of its initial tokens as a set of keys

[16:07] *** diakopter joined
[16:07] <TimToady> there's also problems in the followup to the initial token, however

[16:08] <TimToady> at the beginning of a statment, for example, you are in a superposition of wants

[16:08] <TimToady> statement_control

[16:08] <TimToady> declarator

[16:08] <TimToady> prefix

[16:08] <TimToady> term

[16:08] <TimToady> etc.

[16:08] <TimToady> some of those have to fire off additional rules

[16:08] <TimToady> the hash allows a rule for the value of the hash

[16:09] <TimToady> but offhand I don't see how to recognize a prefix or term and fire off the operator precedence rule

[16:09] <TimToady> there's a token lookahead problem in general

[16:10] <TimToady> most recursive descent parsers assume a tokener with one token lookahead

[16:10] <TimToady> but the definition of token depends on our current state.

[16:11] <TimToady> and the tokens that are legal in a particular parser state

[16:11] <TimToady> may be specified not just by a top set of %grammatical_categories but by various subrules

[16:12] <[particle]> to be clear, <%foo|%bar> is a true superposition (junction), and not logical-or

[16:12] <TimToady> you need the transitive closure of all the head tokens of all the rules.

[16:12] <TimToady> not a junction

[16:12] <TimToady> it could be any character there to indicate a sequence of hashes

[16:12] <TimToady> <%foo+%bar> would work as well

[16:12] <[particle]> you're right, not a junction

[16:13] <TimToady> the point is that the hashes as a whole follow longest token

[16:13] <[particle]> do the keys of %foo get precedence over %bar

[16:13] <TimToady> while ties are broken in favor of the earlier hash

[16:13] <[particle]> ok, i see

[16:13] <[particle]> longest token overall

[16:14] <[particle]> with stable sort

[16:14] <TimToady> so it's a bit like the MMD policy that a "my multi" can hide a particular long name, but other long names can be pulled in from outside

[16:14] <TimToady> but if we have to go as far as interrogating each head rule for its initial tokens, then the hash notation is superfluous

[16:15] <TimToady> all we need is something like [ :longest <a> | <b> | <c> ]

[16:15] <[particle]> sure, but it's much shorter

[16:15] <[particle]> it's almost as if the operator is spelled |%

[16:15] <TimToady> or a different |

[16:16] <TimToady> yes

[16:16] <TimToady> |+ maybe

[16:17] <TimToady> [ %statement_control |+ %declarator |+ <op_prec_parser> ]

[16:18] <[particle]> that stands out better visually

[16:19] <TimToady> though probably %.foo form instead for inheritance ease

[16:20] <TimToady> and then the derived grammar doesn't have to temporize the hash for a lexical scope

[16:20] <[particle]> oic. yes, that works.

[16:21] <[particle]> it makes the syntax a little clunky, but for good reason

[16:21] <[particle]> [ %.stmt_ctrl |+ %.decl |+ <opp> ]

[16:24] <TimToady> actually, declarator is just another term, so it belongs down in opp as well.

[16:25] <TimToady> we could finesse it for Standard Perl without the transitive property by making sure that statment_control is always an identifier

[16:25] <TimToady> but if someone were to add a punctuational statement_control, then we don't have the safety of whitespace anymore

[16:26] <TimToady> and it should really abide by the longest token rule, even if the longest token has to bubble up out of the <opp> rule.

[16:26] <TimToady> oh, which also has to be parameterized by its terminator, so another strike against using a hash for that.

[16:28] <TimToady> the other approach would be to use a set of hashes to peek ahead and figure out, the call <opp> with "pos" before the peeked token.

[16:28] *** kanru joined
[16:28] <TimToady> but that doesn't seem as clean

[16:28] <TimToady> s/the call/then call/

[16:30] <[particle]> what if jumping between parser types (rec-desc, opp, custom) is undefined behavior in hash combinators

[16:30] <TimToady> problem is we'd have to use different hashes for the same thing in different contexts

[16:31] <TimToady> so %prefix in the opp would have to just parse the operator, but at statement level would have to parse the whole expression

[16:32] <[particle]> that's no good :(

[16:32] <TimToady> and I think it's just a lot niftier if the rule engine can calculate the transitive differences from a DRY specification

[16:32] <TimToady> than if we have to copy stuff around

[16:32] <[particle]> agreed.

[16:32] * [particle] goes to get wet

[16:33] <TimToady> but it does seem to call for |+ or some such.

[16:33] <TimToady> yeah, ich auch. &

[16:49] *** CardinalNumber is now known as ProperNoun

[16:54] *** CardinalNumber joined
[17:01] <svnbot6> r15083 | fglock++ | kp6 - working 'hyper-to-map' transform

[17:13] *** ashleyb joined
[17:26] *** GabrielVieira joined
[17:46] *** fglock joined
[17:54] *** xinming joined
[18:09] *** ProperNoun joined
[18:13] <TimToady> I have majorly bitten the bullet.

[18:13] <TimToady> see p6l for change of | semantics to longest token.

[18:13] <TimToady> now we use || for old | semantics

[18:14] <[particle]> saw that

[18:14] <TimToady> for a while it was in the transitional form where only :ratchet reversed the meaning, but I decided consistency was more important with how | and || work outside

[18:15] <TimToady> and we get || for free because null patterns are illegal

[18:15] <[particle]> that paragraph is a bit dense. an example might help

[18:15] <gaal> say, $x in "for @list -> $x { ... }" is always my, right? is there a way to specify it otherwise?

[18:16] <TimToady> it's a formal parameter

[18:16] <gaal> not that having it available is necessarily a good thing, but the one use case i'm thinking of is if you want to look at the last iterator value if you break early from the loop.

[18:16] <TimToady> so you can do anything to it that you could do to the $x in "sub ($x)"

[18:17] <gaal> hmm, i don't see how that fact can be used to change the storage type

[18:17] <[particle]> $OUTER::x?

[18:17] <TimToady> while my $x = =@list {...}

[18:18] <gaal> yeah, okay. :)

[18:21] <TimToady> my $x = first {...}, @list

[18:22] <gaal> oh, that was a yeah of assent, not sarcasm :-)

[18:23] <TimToady> np

[18:23] <gaal> (hmm, typed affirmative calculus)

[18:24] <TimToady> my $x = @list.first: {...}

[18:24] <TimToady> I think I like this language.  :)

[18:24] <kolibrie> timtowtdi, obviously

[18:24] <gaal> hee

[18:26] <TimToady> anyone care to hack .first into Functions.pod as a variant of grep?

[18:28] *** avar joined
[18:39] <kolibrie> the Little Red Hen must be baking bread

[18:40] <nothingmuch> the giant will eat her any moment

[18:41] <TimToady> "Not I" said the Little Fluorescent Green Pig.

[18:42] * stevan looks in the fridge and sees that all the blue ice cubes are gon

[18:44] *** larsen_ joined
[18:44] *** [particle] joined
[18:45] *** bernhard joined
[19:02] <svnbot6> r15084 | lwall++ | Added first function.

[19:04] *** neonse joined
[19:08] * kolibrie notes that TimToady is not a Little Fluorescent Green Pig

[19:13] *** CardinalNumber joined
[19:13] <svnbot6> r15085 | fglock++ | kp6 - cleanup traverse/visitor

[19:17] <fglock> the sun here was just like this: http://www.geol.ucsb.edu/faculty/sylvester/118_fotos2005/Vistas/Vistas-Images/18.jpg

[19:17] <lambdabot> http://tinyurl.com/y8k8sj

[19:32] *** ashleyb joined
[19:38] *** CardinalNumber is now known as ProperNoun

[19:39] *** ziggy joined
[19:41] <ziggy> hello, just a quick complete noob question: is there any tutorial/book teaching perl6? and i don't mean bits and pieces, something coherent and complete

[19:42] <Juerd> No, not yet

[19:42] <[particle]> perl 6 design isn't coherent and complete yet

[19:42] <ziggy> hehe, guess i'll have to wait another 365 days :(

[19:43] <Juerd> No, christmas is before then.

[19:45] <ziggy> last christmas and the one before that i heard the same :D

[19:47] <[particle]> one day maybe you'll believe it ;)

[19:47] <ziggy> how did you guys learn perl6?

[19:48] <[particle]> by writing it. seriously. read the specs, and write some tests.

[19:48] <ziggy> wow

[19:48] <[particle]> the tests are all written in perl6

[19:48] <[particle]> wanna help?

[19:48] <ziggy> so there are specs?

[19:48] <Juerd> ziggy: I learned Perl 6 by reading Apocalypses, and trying to stay up to date after that

[19:48] <Juerd> ziggy: But if you start today, I would recommend that you read only the Synopses.

[19:49] <[particle]> http://spec.pugscode.org

[19:49] <lambdabot> Title: Official Perl 6 Documentation

[19:49] <Juerd> ziggy: See topic :)

[19:49] <[particle]> ziggy: want a commit bit, so you can help?

[19:50] <Juerd> ziggy: And/or access to feather, so you can try before you "buy"? :)

[19:50] <ziggy> wow, not so fast, let me chew a few synopses, try pugs, and then i'll ask if i consider myself usefull :)

[19:51] <ziggy> what's feather?

[19:51] <ziggy> 10x for the link

[19:51] <Juerd> ziggy: feather is a machine

[19:51] <[particle]> ziggy: anyone can get a commit bit, even you

[19:51] <Juerd> ziggy: People who want to try or work on Perl 6 (that includes Pugs) can get a shell account.

[19:52] <Juerd> ziggy: This was initially because many people found it hard to compile Pugs, as GHC is rather demanding during compilation.

[19:52] <ziggy> nice, too bad i can't use it, because i've got a lame isp that drops 20% packets and ssh is so sloooooow

[19:52] <ziggy> i have no alternative, i must compile it myself

[19:52] <Juerd> Good luck, then! :)

[19:52] <ziggy> what do you mean by "demanding"?

[19:52] <Juerd> It's not that hard, but it takes some time.

[19:52] <Juerd> ziggy: It uses lots of RAM and CPU.

[19:53] <Juerd> (The first time you compile it, that is. Subsequent compiles are much faster if not much was changed)

[19:53] <ziggy> aren't there any binaries available?

[19:54] <Juerd> There are some, but they're releases, and always out of date.

[19:54] <ziggy> ah, ok

[19:55] <Juerd> There is also http://feather.perl6.nl:8080/runpugs/ if you want to try simple stuff (not entire programs)

[19:55] <lambdabot> Title: Run Perl 6 Now -- in your browser!

[19:55] <Juerd> ?eval 1 + 5  # This works too, but please don't use it a lot :)

[19:55] <evalbot_r15085> 6

[19:55] <ziggy> wow, nice bot :P

[19:56] <ziggy> ?eval say "hello"

[19:56] <evalbot_r15085> OUTPUT[hello␤] Bool::True

[19:57] *** ofer0 joined
[19:57] <[particle]> ?eval "hello".say

[19:57] <evalbot_r15085> OUTPUT[hello␤] Bool::True

[19:58] <[particle]> perl6++

[19:58] <ziggy> say is a string class method? :D

[19:59] <[particle]> ?eval 4.say

[19:59] <evalbot_r15085> OUTPUT[4␤] Bool::True

[19:59] <[particle]> everything is an object

[19:59] <ziggy> can you add methods to builtin classes, like in Ruby?

[20:00] <[particle]> yes

[20:00] <[particle]> ruby's older sister just got an extreme makeover :)

[20:01] <ziggy> ok, you convinced me to read the specs :P

[20:02] <[particle]> you need a commit bit. msg me your email address

[20:02] <ziggy> ugh, i can't, i have to register a nick first

[20:03] <[particle]>  /msg nickserv identify <some_passwd_here>

[20:03] <[particle]> hrmm, maybe i can start a private chat...

[20:04] *** ziggy is now known as Ziggy6

[20:06] <TimToady> you can always use the "foo at whatever dot where" approach...

[20:06] <Juerd> TimToady: Which is utterly ineffective.

[20:06] <[particle]> Ziggy6 msg'd me successfully. bit sent.

[20:07] <Juerd> TimToady: Spammers also like Perl and its regexes :)

[20:07] <Ziggy6> thanks, i got the email

[20:08] *** polettix joined
[20:08] <kolibrie> Ziggy6: after you checkout pugs, add yourself to the AUTHORS file

[20:08] <Khisanth> [particle]: you can also set a mode so unregistered people can send you messages

[20:09] <[particle]> how can i cpan upload from feather?

[20:09] <Juerd> [particle]: I don't understand the question.

[20:09] <[particle]> i need to upload parrot-0.4.8.tar.gz to cpan

[20:09] <[particle]> it's on feather

[20:09] <[particle]> i'm on windows, using putty

[20:09] <Juerd> [particle]: There are several ways.

[20:10] <Juerd> [particle]: You can use a command line utility for it, there are several on cpan

[20:10] <Juerd> [particle]: You can create an SSH tunnel and use the web interface

[20:10] <Juerd> [particle]: You can use w3m for the web interface

[20:10] <Juerd> [particle]: Easiest is probably to put the file in your ~/public_html, and have PAUSE download it from there

[20:10] <[particle]> ah, yep, will do

[20:13] <[particle]> first, lemme make sure ithe tar is working

[20:13] <gaal> [particle]: also, on the putty d/l page you'll find many ssh-based command line tools, eg for scp and sftp etc.

[20:13] <[particle]> thx, gaal, i'll look at that, too

[20:14] <gaal> also there's the cpan-upload tool, which is great when you're like me and find the most bugs in your code immediately after releaseing it

[20:14] <[particle]> i figured i'd release 0.4.8_01 first for sanity check

[20:15] <gaal> I've done !cpa:p and then ^04^05 (or similar) more than once...

[20:15] <[particle]> besides, i'm not sure if i have proper rights to upload parrot yet

[20:17] *** cognominal joined
[20:25] *** trym joined
[20:32] *** fglock joined
[20:33] <TimToady> fglock: hello, I hope the new | semantics will not cause you much heartburn.  :)

[20:34] <TimToady> It means you don't have to implement <%foo|%bar|%baz> as a special case.  :)

[20:34] <TimToady> merely as a general case.

[20:35] <TimToady> since <%foo> | <%bar> | <%baz> is now guaranteed to behave the same.

[20:37] *** Ziggy6 left
[20:37] *** pmichaud joined
[20:38] <pmichaud> TimToady: ping

[20:40] <[particle]> pmichaud: he was just here, i think he's hiding behind something

[20:41] *** luqui joined
[20:41] <pmichaud> okay

[20:42] <pmichaud> I have a ton of questions on the latest S05 changes :-)

[20:42] * TimToady whistles

[20:42] <pmichaud> oh wait, do I hear him?

[20:43] <TimToady> It is pitch dark.  If you proceed you are likely to be eaten by a grue.

[20:43] <luqui> I, also, have a ton of questions on the latest S05 changes

[20:44] <luqui> Well, it's only one question, actually, but it weighs a ton

[20:44] <TimToady> cool, fire at will, just don't fire at me.

[20:44] <pmichaud> well, I'll start with the simple one first -- does @foo act like @foo[0] | @foo[1] | ...    or @foo[0] || @foo[1] || ...   ?

[20:45] * [particle] thinks TimToady must be very far away, because he's hiding behind a spec

[20:45] <TimToady> Seems like | would be nice

[20:45] <pmichaud> I agree :-)

[20:45] <pmichaud> it would then match %foo

[20:45] <TimToady> then you don't have to sort it

[20:45] <pmichaud> or at least they would tend to act more similarly

[20:45] <TimToady> on the other hand, how do you then write the ordered one?

[20:45] <luqui> that does have implications for infinite lists...

[20:46] <pmichaud> the other question I have is more about the implementation description in S05

[20:46] <TimToady> k

[20:47] <pmichaud> the "list of initial constant strings" has to be a runtime decision, yes?

[20:47] <TimToady> luqui: is that your 2000lb question?

[20:47] <luqui> no

[20:47] <luqui> I expect it is similar to pmichaud's coming question

[20:47] <luqui> so depending on what you were asking, yes

[20:47] <pmichaud> i.e., in order for a rule to report back on the initial constant strings of an initial subrule, we'd have to know what grammar we're in at the time the match is being performed

[20:48] <TimToady> yes, that's correct

[20:48] <TimToady> but I see it much like mmd optimization

[20:48] <pmichaud> why then we do we need to return the initial list?  Couldn't we just have the rule report back "here's the initial constant string that I can match"?

[20:49] <pmichaud> rephrasing

[20:49] <pmichaud> why then we do we need to return the initial constant strings as a list?  Couldn't we just have the rule report back "here's the longest initial constant string that I can match"?

[20:49] <TimToady> doesn't allow for much optimization

[20:50] <pmichaud> I'm not sure we're going to get much optimization anyway, since we have to determine it at runtime

[20:50] * luqui notes that that's how parsec does it

[20:50] <TimToady> people will change the string to search much more often than the grammar used to search it

[20:50] * luqui isn't sure how fast parsec is

[20:51] <pmichaud> so, we could compile the table of initial constant strings at runtime

[20:51] <pmichaud> i.e., each rule maintains a list based on the grammar of the match

[20:51] <TimToady> then you just merge those as you know the connections

[20:52] <TimToady> assuming lists are presorted longest to shortest

[20:52] <pmichaud> do we have to be able to invalidate them if new rules are added via out-of-band means?

[20:52] <TimToady> or build a trie

[20:52] <pmichaud> I guess each grammar could keep track of them

[20:52] <TimToady> I presume so, including adding entries to grammatical categories

[20:53] <pmichaud> i.e., we can ask a grammar "what are the initial constant strings for rule xyz?"

[20:53] <TimToady> but maybe the update can be done incrementally.

[20:53] <pmichaud> which it then computes if it doesn't know already

[20:53] <TimToady> or used to know and forgot...

[20:53] <pmichaud> and it saves information as it goes so that the next time it's asked it doesn't have to recompute the whole thing

[20:54] <TimToady> crudely, generation++ would work

[20:54] <TimToady> but most changes via declaration are incremental

[20:54] <TimToady> postfix:<!> and such

[20:54] <TimToady> so could probably propagate the fact that you need to do an insertion on your table or trie

[20:55] <TimToady> without rebuilding the whole thing

[20:55] <pmichaud> do we need to specify the optimization mechanism in S05, or can we leave it up to the implementations to decide the best way to determine "longest initial constant match"?

[20:55] <TimToady> I was wanting to leave that as open as possible

[20:55] *** cdpruden joined
[20:56] <TimToady> for some datasets it's probably fastest to falsify on character N rather than character 1

[20:56] <pmichaud> okay, I think I've got it for now

[20:56] <luqui> are the semantics of /<a> | <b>/ to match whichever of /<a>/ and /<b>/ is longer, or just to go to the one with the longest initial matching constant string?

[20:57] <TimToady> oh, let's see, I'll also need to mumble something about longest tokens requiring \b after identifiers by default...

[20:57] <luqui> and continue from there...

[20:57] <pmichaud> as I read S05, try the one with the longest initial matching constant string first

[20:57] <TimToady> that's correct

[20:57] <TimToady> longest token :: rest of rule

[20:57] <pmichaud> if it fails, backtrack to try another matching alternative according to the same criteria

[20:58] <TimToady> and :: in fact specifically terminates "token"

[20:58] <luqui> so it's concievable that /<a> | <b>/ could match <a> even if <b> ended up being longer...

[20:58] <TimToady> so does key/value boundary in hash match

[20:58] <pmichaud> does any quantifier terminate "token"?

[20:58] <TimToady> believe so

[20:58] <pmichaud> that's what I was working from

[20:58] <TimToady> (to both of you)

[20:59] <luqui> that seems incredibly brittle

[20:59] <pmichaud> luqui:  I think if it's brittle then use || instead

[20:59] <luqui> i.e. optimizations have the potential to change semantics

[20:59] <luqui> that's a cop-out answer...

[20:59] <pmichaud> agreed :-)

[20:59] <luqui> why should the semantically unstable one be the shorter one?

[21:00] <luqui> (or more accurately, why are we including a semantically unstable operator in the language?)

[21:00] <TimToady> I don't see how it's unstable.  It's no different than any other lexer/parser works...

[21:01] <TimToady> every lexer commits to the current token regardless of which production turns out longer

[21:01] <luqui> if you insert "predictive, top-down" in there, you might be right

[21:01] <luqui> oh, so you're looking at this from a tokenizer standpoint

[21:02] <luqui> but the definition of what a token is is ad-hoc

[21:02] <TimToady> it's defined by the rules you call.

[21:02] <luqui> whereas when you're using flex/bison, you have defined exactly what your tokens are

[21:02] <luqui> and flex always picks the longest one

[21:02] <TimToady> for your current lexer state

[21:03] <TimToady> and lexer state is usually a proxy for a parser state.

[21:03] <luqui> but where is the line between tokens and productions?

[21:03] <TimToady> we're just attaching it directly to your parser state 

[21:03] <luqui> (is it the "token" keyword?)

[21:04] <TimToady> no, token is whatever is constant on the front up to ::

[21:04] <pmichaud> I think the line between tokens/productions is the set of initial constant strings :-)

[21:04] <TimToady> or something non-constant like \b \s* etc

[21:04] <pmichaud> in something like / a+ / -- would the initial constant string be 'a'?

[21:05] <luqui> but that prohibits refactoring constants into data structures...

[21:05] *** Aankhen`` joined
[21:05] <TimToady> %hash keys are considered constants too

[21:05] <TimToady> pmichaud: can argue that both ways

[21:05] <pmichaud> TimToady: so can I , which is why I asked :-)

[21:06] <TimToady> I'm inclined to say not, but don't have a really good reason

[21:06] <luqui> TimToady, didn't you just lose your optimizations by saying that?

[21:06] <luqui> (%hash keys are considered constants

[21:06] <luqui> )

[21:06] <TimToady> not if you know whether the hash has changed or not.

[21:06] <TimToady> it's just another way for linkage to change

[21:07] <TimToady> p5 would just have done generation++

[21:07] <TimToady> and recalculated the world

[21:07] <luqui> so %hash keys don't count as constants if they are passed as parameters to a rule?

[21:07] <TimToady> and been fast usually

[21:07] <TimToady> we might need to be careful about terminators

[21:08] <pmichaud> I think I prefer that / a+ / have '' as an initial constant string, if only to be able to deal with things like / a**{$m..$n} /  later

[21:09] <TimToady> maybe hardwire ) ] } as terminators and don't revise hash if the parameter is one of those terminators

[21:10] * luqui doesn't follow

[21:10] * pmichaud neither

[21:10] <TimToady> most parameters turn out to be terminators, I suspect

[21:10] <TimToady> whichever way a+ goes, we have a way to write it the other way

[21:10] <TimToady> :: a+ / would force to ""

[21:11] <TimToady> s/^/\//

[21:11] <pmichaud> yes

[21:11] <TimToady> and / a a* / of course

[21:11] <TimToady> though that violates DRY

[21:11] <TimToady> which tends to argue for "a" by default

[21:11] <TimToady> just for optimizing purposes mainly

[21:11] <TimToady> less for tokenizing

[21:12] <pmichaud> well, if it changes semantics, is it really just optimization?

[21:12] <TimToady> see tailcall optimization...

[21:12] <luqui> pmichaud++   # my sentiment exactly

[21:12] <luqui> how does tailcall change semantics?

[21:13] <TimToady> guarantees you don't blow your stack with recursive solutoins

[21:13] <luqui> given enough ram, there is no change in semantics

[21:13] <luqui> i.e. on a turing machine, there is no difference

[21:13] <pmichaud> in this case, the chose of returning 'a' versus '' could be very different

[21:13] <pmichaud> s/chose/choice/

[21:15] <pmichaud> unfortunately, I have to run off and make it to the post office to meet a mailing deadline

[21:15] <TimToady> k

[21:15] <pmichaud> if I come up with any other questions, I'll ping or write to the ml

[21:15] <pmichaud> (or tomorrow's call)

[21:15] <TimToady> k

[21:16] <pmichaud> thanks a bunch for the quick answers -- this is fun stuff to think about :-)

[21:16] <luqui> so, TimToady, are you trying to emulate a predictive parser (like parsec) with these changes?

[21:17] <pmichaud> luqui:  this question came up on #parrot a few days ago -- someone was using an alternation of  / .pcc_sub | .pcc_sub_begin /  and was curious as to why .pcc_sub_begin never matched

[21:17] <pmichaud> it becomes odder when one writes   token sub { .pcc_sub | .pcc_sub_begin }

[21:18] <TimToady> um, we've been predictive ever since we introduced :ratchet

[21:18] <luqui> note that both of those have an initial constant string of ""

[21:18] <pmichaud> sorry, backwack the dots

[21:18] <luqui> but if the dots weren't backwhacked...

[21:18] <luqui> then the problem remains

[21:19] <pmichaud> it does also bring about the question of what to do with, say   { $foo }  :-)

[21:19] <pmichaud> s/say// # darn puns

[21:20] <pmichaud> I better get to the P.O. if I want to avoid a legal hassle -- bbiaw

[21:20] <luqui> I just don't see the win...  it seems like if I use | in a grammar I need to be maticulously knowledgeable about the exact details of how my rules are written to understand the behavior

[21:21] <luqui> and it's pretty easy to do a similar optimization on ||

[21:21] <luqui> just look at constant strings on the left, and if one matches, jump there and try it

[21:21] <pmichaud> luqui:  that was true before.  What's different now is that I need to know the details of my subrules to understand the behavior

[21:21] <luqui> if not, try the right

[21:21] * luqui meant subrules

[21:21] <TimToady> pmichaud: go away!!!  :)

[21:21] * luqui dittos

[21:22] <luqui> :-

[21:22] <luqui> :-)

[21:22] <pmichaud> I can't!  I'm having too much fun!  Taxes are not generally -Ofun!

[21:22] <pmichaud> (gone, for real this time)

[21:22] <ingy>  /kick pmichaud 

[21:25] <TimToady> I wonder if commutative should be specified with <=> in place of comma...

[21:25] <TimToady> then you can have your first 2 args commutative without the 3rd...

[21:26] <luqui> what if you want your 1st and 3rd commutative without the second?

[21:26] * luqui thinks "is commutative" is good enough

[21:27] <luqui> no more syntax for minor details please

[21:28] <luqui> use words for little things, so they're easy to look up, and presumably easy to read without having to look up

[21:28] <luqui> (<=> isn't obvious to me)

[21:28] <TimToady> how 'bout multiple signatures for a single body?

[21:28] * luqui woots

[21:29] <luqui> *that* is a pretty good idea I think

[21:29] <TimToady> every now and then...

[21:30] <luqui> could take a bit of pain out of multi disambiguation

[21:30] <luqui> you still have a combinatorical explosion to deal with now and then...

[21:31] <TimToady> but at least you don't have all these {...} scattered all over

[21:31] <TimToady> well, need to glare at that one for a while...

[21:32] <luqui> (Foo $a, Bar $b | Bar $b, Foo $a)  # match the longest initial object...

[21:32] *** jferrero joined
[21:33] <TimToady> hmm, current subsig syntax already allows it, almost, except it would bind both subsigs to the first arg only...

[21:34] <TimToady> ah, no, it would be anded not ored

[21:35] <TimToady> so subsigs wouldn't work in any case

[21:35] <TimToady> I think people would read | as binding tighter than ,

[21:35] <luqui> especially since it does a lot of the time  (Foo | Bar $x)

[21:36] <luqui> but || is available... (might be too much punning)

[21:36] <TimToady> I was just thinking (Foo $a, Bar $b) (Bar $b, Foo $a)

[21:36] <theorbtwo> (Foo $a, Bar $b) | (Bar $b, Foo $a) might be clearer.

[21:37] <TimToady> or (Foo $a, Bar $b)|(Bar $b, Foo $a) maybe

[21:37] * theorbtwo grins.

[21:37] <TimToady> and rightfully so.

[21:39] * TimToady wonders if all the alternatives must declare the same parameters or fail compilation...

[21:40] <TimToady> or if unbound ones just become undef

[21:40] <luqui> I like failing as long as it's easy to specify defaulting to undef

[21:40] <luqui> but it's not the same as $param

[21:40] <TimToady> former behavior is more conservative, and we could relax to latter later

[21:40] <luqui> er

[21:40] <luqui> $param? = undef

[21:40] <luqui> (i.e. $param? ;-)

[21:41] <TimToady> I like the double check, since it would be easy to mix up $a and $b

[21:41] <TimToady> though if you did get them backwards, it might have some spectacularly hard to diagnose failure modes

[21:42] <TimToady> assuming the type inferencer doesn't complain loudly

[21:45] <TimToady> which it can certainly do if it decides $a.WHAT === None

[21:46] <TimToady> but as soon as people start throwing Any in there we have to pretty much trust them to mean what they said.

[21:49] *** kanru_ joined
[21:50] <luqui> but this is mainly for mmd, right?

[21:50] <luqui> so Any will not be very likely

[21:50] <TimToady> ya

[21:50] <TimToady> gives you an asymmetric default case

[21:50] <luqui> because it has no information

[21:50] <TimToady> Num/Any

[21:50] <TimToady> vs Num/Num

[21:50] <luqui> elaborate

[21:51] <TimToady> it would dispatch a Num/NotQuiteaNum to Num/Any, presumably

[21:52] <TimToady> if your mmd coerced its right arg to Num, for instance.

[21:52] <luqui> oh, I see the problem.. if you had (Num $a, Any $b) | (Any $a, Num $b)

[21:52] <TimToady> /mmd/mm/

[21:52] <TimToady> and forget to swap $a and $b

[21:52] <luqui> Num|Any = Any, so both $a and $b would get typed as Any

[21:53] <TimToady> and how would you detect the error?

[21:53] <TimToady> well, you'd have the same problem if you cut-n-paste the body...

[21:54] <luqui> aye

[21:54] * TimToady reminds himself not to cut-n-paste any bodies in public)

[21:55] <TimToady> one thing the design of Ada taught me is that eventually you just give up and say "that's just erroneous, and we can't do diddly about it."

[21:55] <luqui> I mean, if you have strong type inference on (because weak inference isn't going to catch anything; it's just going to assume you're right), then Any will die on many things, because you can't do anything to it

[21:55] <TimToady> saved by the pragma.  :)

[21:55] <TimToady> no stupid;

[21:55] <luqui> haha

[21:56] * luqui considers making it so at least the types of the same parameter in different signatures have to match

[21:56] <luqui> but that seems to take away some power

[21:57] <TimToady> hmm leave out the params on 2nd and following, and have them autoassociate with the type?

[21:58] <luqui> uh no

[21:58] <luqui> a little too dwimmy for my taste

[21:58] <TimToady> prolly

[21:58] <luqui> (Any, Num) | (Num, Any) ($a, $b)

[21:59] <luqui> oh wait... that's the erroneous case!

[21:59] <luqui> (Any $a, Num $b) | ViceVersa.  (I guess that's spelled "is commutative")

[21:59] <TimToady> you'd probably want (Any, Num) | (Num, Any) -> Num $a, Any $b {...}

[22:00] <luqui> yikes

[22:00] <theorbtwo> Why not just spell that (Any $a, Num $b) | ($b, $a).

[22:00] <theorbtwo> Allos explicit types on the second, but do not require it.

[22:00] <luqui> that's interesting

[22:01] <TimToady> Don't see that it's much different than (Any $a, Num $b) | (Num, Any)

[22:02] <TimToady> though I guess that flips the order too

[22:03] <theorbtwo> For one thing, what does (Num $a, Num $b, Str $c) | (Num, Str, Num) mean?

[22:03] <TimToady> also ($b, $a) is a valid sig in it's own right

[22:03] <TimToady> which always means (Any $b, Any $a)

[22:04] <TimToady> so you can't also make it default, I think

[22:04] <luqui> ... true ...

[22:04] <TimToady> probably best to stay explicit for now

[22:05] <TimToady> and make the IDE flip entire paramlets for you...  :)

[22:05] <TimToady> presumably when you hit the "commute" button.

[22:06] <TimToady> sec &

[22:06] *** ruoso joined
[22:09] <TimToady> (Num $a, Any $b) || (Num $a, Num $b)  # desugared ;

[22:14] <luqui> Num, Num?

[22:16] <TimToady> desugared Num; Num

[22:16] <luqui> ?

[22:16] <luqui> oh

[22:16] <TimToady> note || instead of |

[22:16] <luqui> semicolon

[22:18] <TimToady> (Any $a, Num $b) || (Num $a, Num $b)  # backwards semicolon

[22:19] <TimToady> I'm probably all dingled in the head though

[22:21] <ingy>  /topic <TimToady> I'm probably all dingled in the head though

[22:25] *** dduncan joined
[22:32] *** gnuvince joined
[22:36] *** Limbic_Region joined
[22:36] *** weinig|bbl is now known as weinig

[22:40] *** ludan joined
[22:43] *** trym_ joined
[22:43] *** [particle] joined
[22:53] <TimToady> n

[22:53] <TimToady> not to mention y

[23:07] *** ludan joined
[23:12] * luqui is beginning to agree with TimToady's assessment about his head :-)

[23:15] <TimToady> I prefer it when you're disagreeable. :)

[23:15] *** Psyche^ joined
[23:24] *** xinming joined
[23:29] *** Psyche^ is now known as Patterner

[23:46] *** neonse left
[23:46] *** ludan joined
[23:50] *** Ziggy6 joined
