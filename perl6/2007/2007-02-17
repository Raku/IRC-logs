[00:25] *** REPLeffect left
[00:31] *** gaal joined
[00:32] *** nwc10 left
[00:34] <Coke_> (coke & pepsi) wot now?

[00:42] *** awwaiid joined
[00:46] *** zipf joined
[00:55] *** zipf left
[01:01] <specbot6> r13588 | larry++ | Clarification of coercion declarations and semantics.

[01:01] <rhr> Hi, I have a question about {} vs do{} in pugs/perl6

[01:01] <rhr> case 1: sub{ ... {warn "blah"; reutrn False; } unless something; ... }

[01:01] <rhr> case 2: sub{ ... something or do { warn "blah"; reutrn False; }; ... }

[01:01] <rhr> do blocks won't take modifiers so case1 can't take do

[01:01] <rhr> but a bare closure doesn't get run in case2 ({...}.() works also)

[01:02] <rhr> I find this confusing.  Also, S06 doesn't mention do in its discussion of return afaics

[01:05] *** polettix joined
[01:08] <svnbot6> r15277 | lwall++ | postcircumfix methods distinguished

[01:10] <TimToady> attempting to use a statment modifier on something that heavy almost certainly means you shouldn't be using a statement modifier there.

[01:11] <TimToady> and why would do need to be mentioned in the discussion of return?

[01:12] <TimToady> return is defined to go to the enclosing sub, skipping any non-sub blocks

[01:12] <TimToady> a do block is not a sub declaration

[01:13] <TimToady> is that what is bothering you?

[01:14] <rhr> yeah ok :)

[01:14] <rhr> S06 says "explicit keyword", and do kind of fits that description

[01:15] <TimToady> yes, I see how that can be misinterpreted.  I'll glare at it...

[01:16] <rhr> I still don't really understand why the closure is run with unless but not with or

[01:20] *** bones_ joined
[01:25] *** turrepurre joined
[01:31] <specbot6> r13589 | larry++ | Clarification on what may be returned from, requested by rhr++

[01:31] <TimToady> rhr: it could perhaps be construed as a bug.  I can argue that both ways.

[01:36] <rhr> what's the argument for not construing it as a bug, out of curiosity?

[01:36] <TimToady> a bare block where a statement expected automatically calls itself

[01:36] *** CardinalNumber joined
[01:36] <TimToady> the question is whether a bare block with something after it really qualifies as a bare block.

[01:37] * Limbic_Region wonders how many nudist perl hackers there are

[01:38] <rhr> hmm, but isn't the one that's not being run the one without anything after it?

[01:38] <rhr> or do I misunderstand?

[01:39] <TimToady> it depends on whether your ... is setting up the expectation of a statement.

[01:39] <rhr> it should have been ...;

[01:45] <rhr> in perl5 one-liners I often sneak a return in using a comma

[01:45] <rhr> I'm just trying to update this sordid idiom :)

[01:47] *** neonse left
[01:56] *** CardinalNumber is now known as ProperNoun

[01:57] <nanonyme> hey, can you define complex structures in perl6 and then call them again like you can in C?

[01:57] <TimToady> I have no idea what you mean

[01:58] <nanonyme> maybe i'm too drunk to think clearly, i'll ask again when i sober up

[01:59] <TimToady> k

[01:59] <Limbic_Region> TimToady - I believe nanonyme is referring to structs

[02:00] <Limbic_Region> IOW, defining your own datatype

[02:00] <TimToady> in that case, certainly

[02:00] <nanonyme> exactly, that was what a friend asked me to ask earlier, i'm just too drunk to word myself properly

[02:00] <nanonyme> thanks :)

[02:01] <rhr> TimToady: I guess I was expecting perl to expect a statement for both of those blocks

[02:02] <TimToady> the question is how picky we are on when to supply an implicit .() after the block.

[02:03] <TimToady> for instance, we certainly should not supply a .() if there's already one there.

[02:04] <TimToady> ?eval { say "hi $_" }.("there")

[02:04] *** evalbot_r15265 is now known as evalbot_r15277

[02:04] <evalbot_r15277> OUTPUT[hi there␤] Bool::True

[02:05] <TimToady> ?eval { say "hi" }

[02:05] <evalbot_r15277> OUTPUT[hi␤] Bool::True

[02:05] <rhr> in what way is the context different in {} if ... vs ... or {}?

[02:05] <rhr> I guess that's my main question

[02:05] <TimToady> or does not expect a statement after it

[02:06] <TimToady> so or {} will never supply an implicit .() for you.

[02:06] <TimToady> the implicit .() is only for a block used as a statement.

[02:06] <TimToady> and statement modifiers are kind of on the boundary.

[02:06] <rhr> oh, it just wnats to return the closure right?

[02:07] <TimToady> yes

[02:07] <TimToady> arguably a statement modifier is both a statement as a whole and contains a statement on its left.

[02:07] <Limbic_Region> TimToady - you are gainfully employed outside of working on Perl 6 right?  And you use pugs/perl 6 in that job correct?

[02:07] <rhr> I guess I expected differently because I don't usually use it to return a value

[02:08] <TimToady> I work for a company called Netlogic Microsystems

[02:08] <TimToady> whether that's "gainful" is of course subject to interpretation

[02:08] <Limbic_Region> ok

[02:08] * Limbic_Region is just having a friendly disagreement with merlyn on the matter

[02:08] <TimToady> I've been known to use pugs here

[02:08] <jdv79> :)

[02:08] <Limbic_Region> he said no one is using perl 6 for real

[02:09] <Limbic_Region> and so I jokingly said he was calling you no one

[02:09] <TimToady> it was for real at the time, though I ended up translating it back to Perl 5 so it'd run faster.

[02:10] *** Aankhen`` joined
[02:10] <TimToady> but it's certainly a good language for at least thinking in

[02:10] *** unop joined
[02:10] * allbery_b has the minor problem that he needs to support solaris boxen as well, and, well, ghc doesn't like solaris any more

[02:10] *** simcop2387 joined
[02:10] <TimToady> I guess it depends on what the definition of "is" is...

[02:10] *** westymatt joined
[02:11] <TimToady> speaking of cigars...

[02:12] * Limbic_Region has never enjoyed cigars or wine

[02:13] <TimToady> I've never tried a cigar.  Tried a cigaret once when I was in junior high...

[02:13] * allbery_b neither

[02:14] <TimToady> I don't mind a good wine, but I'm not allowed to imbibe at the moment because I'm taking some pills that are already hard on my liver, and we don't need two people here with bad livers... :(

[02:15] <Limbic_Region> any news on her hepatitis?

[02:15] <Limbic_Region> you seem to be in the know

[02:15] * allbery_b likes good single-malts

[02:16] <TimToady> only what I know from her popping in here occasionally.

[02:16] <Limbic_Region> oh

[02:16] * Limbic_Region searches the logs then

[02:17] *** dmq joined
[02:17] <TimToady> my guess is she's gonna still be very much out of it for at least a week and subpar for considerably thereafter.

[02:18] <Limbic_Region> oh, but "small chance I can leave the hospital tomorrow" is in itself good news

[02:19] * rhr wishes he could donate an extra liver to the cause

[02:19] *** weinig is now known as weinig|away

[02:20] <TimToady> well, I understand people can donate half livers these days.

[02:20] <TimToady> and it may yet come to that.

[02:20] <Limbic_Region> yeah, liver is one of the few organs that regrows

[02:22] <TimToady> I would certainly donate half my liver to audreyt in a flash, but that would certainly be suboptimal from an age standpoint, not to mention I'm probably disqualified anyway for various reasons such as having had a transplant and various transfusions myself...

[02:23] * Limbic_Region is such a dolt as he hasn't been keeping her in his prayers

[02:23] <TimToady> just pray once with a hyperoperator on it.  :)

[02:24] <Limbic_Region> well, I don't know how healthy my liver is but yeah

[02:24] <Limbic_Region> heh

[02:24] <Limbic_Region> presumably god transcends time so it shouldn't matter when the prayer happens - casuality is just something for us humans to maintain some semblance of sanity

[02:25] <TimToady> also, not sure what the culture of transplants is in Taiwan.  I know they're rather rare in Japan, though, because it's very hard to find donors.

[02:25] <rhr> fascinating.  Well, I'm young and have a perfectly good liver.  Can they ship 'em halfway around the world on ice? :)

[02:26] * allbery_b mi she-beirach avoteinu...

[02:27] <TimToady> well, from where you are, that's over the north pole, so that's pretty icy...

[02:27] <allbery_b> for the moment, at least

[02:27] <TimToady> maybe there will be a lot of spare polar bear livers available soon.  :(

[02:31] <TimToady> well, must decommute

[02:32] <TimToady> bbl &

[02:37] *** mjk joined
[02:38] *** araujo joined
[02:46] *** justatheory joined
[02:52] <westymatt> Hey I need to test for the existence of a command, but not execute it any advice?

[02:56] *** khisanth_ joined
[02:57] *** khisanth_ is now known as Khisanth

[03:08] <allbery_b> ?eval (any(%*ENV<PATH>.split(':')) ~ "/ping") ~~ :x

[03:08] <evalbot_r15277> Error: Can't modify constant item: VUndef

[03:08] <allbery_b> hm, safemode

[03:15] *** justatheory joined
[03:21] *** sunnavy joined
[03:44] <audreyt> short update: I'll be hospitalized for another 48 hours. my liver is gradually recovering, but still requires a lot of rest. TimToady is right; I'll still be easily tired for another month or so; but fortunately I've booked all $job away, so it's all pugstime for the month to come :)

[03:44] * audreyt faints some more &

[03:55] <allbery_b> yay!

[03:56] <allbery_b> audreyt++

[04:07] *** Khisanth joined
[04:08] <TimToady> fg

[04:12] *** MikeJS joined
[04:16] <rhr> is pipe expected to work like open e.g. my $xclip = pipe "xclip", :w; ?

[04:21] <[particle]> westymatt: readdir over $PATH?

[04:23] *** [particle] left
[04:24] *** [particle] joined
[04:24] <allbery_b> my ?eval tried to work here but my pugs is a bit old for :x

[04:38] <TimToady> rhr: might be more like Pipe.open(:w, "xclip")

[04:39] <TimToady> or Pipe.to("xclip") and Pipe.from("xclip") maybe

[04:40] <dduncan> TimToady, did you see my question yesterday about the StrPos etc types?

[04:41] <TimToady> yeah, just low on tuits

[04:41] <dduncan> does a value of said type have meaning in isolation, and can be used with any Str, or does it only have meaning when used with a specific Str value?

[04:41] <TimToady> only for a specific Str.

[04:41] <dduncan> so then, its sort of like a reference type, I gather?

[04:42] <allbery_b> IIRC different strings may have different interpretations (utf8, ascii, ...) and a StrPos needs to reflect that

[04:42] <TimToady> though a StrLen could know n bytes, m codepoints, o graphemes, etc.

[04:42] *** Khisanth joined
[04:42] <TimToady> StrPos doesn't care as long as it points between things at the abstraction level you're concerned about

[04:43] <TimToady> passing a byte StrPos into a routine thinking in graphemes may have to adjust the pointer or be unhappy

[04:43] <TimToady> I believe I speculated about all this in the original apocalypses

[04:44] <dduncan> so, does it conceptually make sense to compare two unequal Str as to whether they are of the same length or not, without specifying "in codepoints" or "in graphemes", because StrPos or StrLen is supposed to be abstracted above which is used?

[04:44] <dduncan> based on what I've heard, I would say no

[04:44] <TimToady> considering there's no .length method...

[04:45] <TimToady> how would you do it without specifying

[04:45] <TimToady> $a.chars == $b.chars specifies chars in the current unicode level

[04:46] <nothingmuch> Coke_ || [particle]: short update: the show was awesome. sleep now =)

[04:46] <TimToady> $a.bytes == $b.bytes requires the byte count to be the same, and fails if either string doesn't care to support byte ops

[04:46] <nothingmuch> (http://www.last.fm/event/143933)

[04:46] <lambdabot> Title: Sex Mob at Tonic (New York) on 16 Feb 2007 &ndash; Last.fm

[04:47] <dduncan> as I mentioned yesterday, if you have a value of a unit-inspecific  such as a "velocity" or a "temperature", you can do things with multiple values of said such as compare if one is faster or hotter than another, without caring whether we're using Kelvins or Farenheight units

[04:47] <dduncan> but I get the impression that StrPos etc can't be treated like those

[04:47] <TimToady> a StrPos is a position in a particular string, so no

[04:48] <dduncan> right, glad that's all cleared up for me

[04:48] <TimToady> a StrLen is not related to a particular string if you force it to tell you a number

[04:48] <dduncan> sure

[04:48] <TimToady> but it might be lazy about that and keep two StrPos till it knows

[04:49] <TimToady> in general we should be getting away from string lengths in the API as much as possible

[04:50] <dduncan> sure ... and the current definition of StrPos|StrLen smacks of memory address offsets and such, which Perl generally abstracts us away from having to think about

[04:50] <TimToady> there should be a substr variant that takes two StrPos, for instance.

[04:51] <TimToady> or the lazy StrLen can see if its lazy beginning happens to be the same as the substr pos.

[04:51] <TimToady> then it doesn't have to count anything.

[04:51] <allbery_b> dduncan: there's really n good way t reconcile graphemes, codepoints, byte4s, etc.

[04:52] <TimToady> you reconcile them by choosing a good abstraction level for the default and then providing clean ways to escape the default if you need to.

[04:53] <TimToady> and to the extent that the data types themselves allow you to escape

[04:53] <dduncan> presumably, then, if we use a rule to match something, the result of executing the rule could return something analagous to StrPos, in case we want to go back and say, get the string where that matched ... or maybe this is just something that rule executions to internally, and users of rules don't have to

[04:54] <TimToady> StrPos is precisely what it returns

[04:54] <TimToady> if you ask for the .beg or .end of any matched thing

[04:54] <TimToady> .pos is a StrPos

[04:55] <dduncan> so, I get the impression that for high level work, rules are the proper way to extract or work with substrings, and outside of rules, we generally treat strings as being atomic, that we just copy or compare for equality or before/after etc

[04:55] *** xwrn joined
[04:55] <TimToady> the age of fixed-width characters is largely past us, I think.

[04:56] <TimToady> and of fixed-width strings.

[04:56] <TimToady> you'll note that formats are now largely obsolete for the same reason

[04:56] <dduncan> now, maybe this is explained, but with terms like codepoints and graphemes going about, is there such a thing as a "character" with is clearly defined?

[04:57] <dduncan> or should we just say codepoints or graphemes instead of characters?

[04:57] <dduncan> or is "character" a convenient fuzzyness over the other terms

[04:58] <dduncan> when we want to fuzzy say what a string is composed of without going into detail

[04:58] <TimToady> they're defined at the beginning of Functions.pod, of all places.

[04:58] <TimToady> Char is defined as the maximum abstraction level supported in the current lexical scope.

[04:59] <TimToady> so with "use bytes" a Char is a byte

[04:59] <TimToady> with "use codepoints" it's a code point

[04:59] <dduncan> okay

[04:59] <TimToady> by default it's a grapheme

[04:59] <TimToady> if you say "use Arabic" it's an Arabic letter, whatever that is...

[05:00] <dduncan> I see the document now

[05:01] <TimToady> I believe audreyt was attempting to push this view into the Haskell community at one point, with mixed success.

[05:01] <TimToady> ah well, Perl has to be better at something than Haskell.  :)

[05:02] <allbery_b> haskell has to figure out its unicode support first :)

[05:02] <allbery_b> and then there's problems with languages like arabic and hebrew because of haskell's case significance

[05:03] *** BooK_ joined
[05:03] <allbery_b> (e.g. how do you write an uppercase letter to name a type in Arabic?)

[05:03] <TimToady> which is why these distinctions should only ever be conventions, not mandates

[05:05] <dduncan> As I work on designing my DBMS, I'm liking to be both modern while being able to map to older concepts ... I am trying to make my Text type as alike to Perl 6's Str type as possible, but part of what I have to support is users declaring a Text subtype that is constrained to being within a certain length, to help with data validation ... since the DBMS spec already says that Text has the latest Unicode repertoire as its character set ...

[05:06] <dduncan> I'm trying to make it as Perl 6 like as reasonable, given that a lot of Perl 6 features won't be in it as it is more domain specific.

[05:06] <dduncan> Mainly I'm focusing on features that can represent any data type, any constraint on a data type, and any common operation with such a data type ... assignment and equality comparison if nothing else.

[05:06] <TimToady> and what do they mean when they say "length"?

[05:07] <dduncan> I would say in practice that it is context specific

[05:07] <dduncan> eg, a SIN is of a certain format or length

[05:07] <dduncan> or maybe bad example ...

[05:08] <dduncan> I'm trying to think of things that are practically a certain length, and are not simply a number

[05:10] <dduncan> Since what I'm making is intended to be abstract, I will definitely not make it possible to generically ask for the length of a character string in bytes ... unless said function also specifies "when expressed as which encoding"

[05:10] <TimToady> well, maybe we can help drag database technology into the age of no arbitrary limitations.

[05:10] <dduncan> there is no "current encoding"

[05:10] <dduncan> I'm trying to do that

[05:10] <dduncan> help always appreciated

[05:11] <avar> TimToady: Regarding lexical scopes and such values, I've been implementing a plug-in for the regex engine in p5. When you have lexical pragmas they're defined as C<use bytes; #{ byte semantics } [ byte-using code ]; use characters; #{ character semantics } [ characters-using code]). I.e. you have to split your code/delclarations into sections but then each variable gets a "tag" saying it's in byte-mode, char-mode or in my case bound to the default regex engine o

[05:11] <avar> Does p6 offer a more comportable syntax to tell a value not the block/section it's delcared in that a pragma applies to it

[05:11] <avar> *comfortable

[05:12] <dduncan> in regards to constraints on a database, they exist because users want them to model a particular reality that they define, and refuse to accept input that doesn't fit ... the constraints are generally not there just to help the DBMS implement what users ask for ...

[05:12] <avar> I guess that's done with the type system...

[05:12] <allbery_b> sounds like a job for has()

[05:12] <allbery_b> er, no parens

[05:12] <avar> my ByteStr $foo; my CharStr $bar; #{ pseoudcode }

[05:13] <TimToady> every string has a minimum and maximum abstraction level it will deal with, so you can easily declare a codepoint string within a grapheme section, for instance.

[05:13] <TimToady> yes

[05:13] <avar> TimToady: Ah, that answers it;)

[05:15] <dduncan> until I reread what you said about users usually thinking about text in terms of graphemes, I was intending to have one level of representation, which is simply codepoints

[05:15] <dduncan> but I may be thinking differently now, or support both

[05:16] <TimToady> bearing in mind also that U+10ffff is a single codepoint represented with two surrogates.

[05:16] <TimToady> it's cheating to say that a Plane 1 character is two codepoints.

[05:17] <TimToady> ?eval "\x[10ffff]".chars

[05:17] <evalbot_r15277> 1

[05:18] <TimToady> ?eval "\x[10ffff]".codepoints

[05:18] <evalbot_r15277> Error: No compatible subroutine found: "&codepoints"

[05:18] <TimToady> ?eval "\x[10ffff]".codes

[05:18] <evalbot_r15277> 1

[05:18] <TimToady> :)

[05:18] <TimToady> ?eval "\x[10ffff]".bytes

[05:18] <evalbot_r15277> 4

[05:18] <dduncan> ?eval "a".bytes

[05:18] <evalbot_r15277> 1

[05:19] <dduncan> so, UTF-8 ?

[05:19] <TimToady> ?eval "\x[256]".bytes

[05:19] <evalbot_r15277> 2

[05:19] <TimToady> yes

[05:19] <TimToady> apparently

[05:20] <allbery_b> more complex than that, though.  בֻּ֓ :)

[05:20] <dduncan> in any event, the first releases of my DBMS will be pure Perl and won't have to map to anything else, so I can largely ignore internals issues, and map my operators to the Perl ones directly

[05:20] <dduncan> then come back to some of these worries later

[05:21] <allbery_b> (bet w/dagesh, qubutz, and shalshelet)

[05:21] <TimToady> ?eval "בבּבֻּ֓".chars

[05:21] <evalbot_r15277> 7

[05:21] <TimToady> ?eval "בבּבֻּ֓".codes

[05:21] <evalbot_r15277> 7

[05:21] <allbery_b> one grapheme (although most renderers don't handle trope markings)

[05:22] *** ashleyb joined
[05:22] <allbery_b> ?eval "בבּבֻּ֓".graphemes

[05:22] <lumi_> What's a shalshelet, then?

[05:22] <evalbot_r15277> Error: No compatible subroutine found: "&graphemes"

[05:22] <allbery_b> hm

[05:22] <dduncan> graphs

[05:22] <lumi_> "graphs" I think

[05:23] <allbery_b> ?eval "בבּבֻּ֓".graphs

[05:23] <evalbot_r15277> 7

[05:23] *** ashleyb joined
[05:23] <allbery_b> um, 3.

[05:23] <TimToady> I think pugs is at codepoint level currently

[05:23] <allbery_b> trope markings like shalshelet ("chains") indicate how to chant a passage

[05:24] <allbery_b> it's actually more of a syllabic than a character mark, but also indicates if and how a word associates with the next word

[05:24] <allbery_b> ...but some of them do attach to characters, not words or syllables

[05:25] <TimToady> does Unicode consider them combining characters?

[05:25] <tene> ?eval "unicode".syllables

[05:25] <evalbot_r15277> Error: No compatible subroutine found: "&syllables"

[05:25] <allbery_b> combining accents

[05:25] <TimToady> certainly that sort of thing can change when you throw in a "use Hebrew"

[05:26] <TimToady> which presumably changes the abstraction level from language-independent graphemes to hebrew characters

[05:26] <allbery_b> on the one hand, you're not going to have to deal with trope too often; on the other hand, I already have perl5 scripts which handle trope :)

[05:27] <TimToady> I only parse 日本語

[05:30] <rhr> so regex is a keyword now...  how do you pronounce it?  both hard and soft g sound wrong to me

[05:30] <TimToady> I use the j sound

[05:30] <TimToady> consider it encouragement to write a token or a rule instead.  :)

[05:30] <allbery_b> soft j sounds too close to "rejects" :)

[05:31] <rhr> yeah, I thought of "rejects" too.  But the alternative is a reggae expression :)

[05:32] <TimToady> the whole point of regex is to reject most things. :)

[05:32] <allbery_b> "pattern" :)

[05:33] *** BooK joined
[05:36] *** xwrn joined
[05:39] *** justatheory joined
[05:43] <dduncan> FYI, I just updated my DBMS documentation's terminology section to specify that the term "character" specifically means "grapheme" in general, and that I would generally work in those terms, though codepoints are possibly an alternative if doing that seems necessary.

[05:43] <dduncan> That said, is it possible for multiple sequences of codepoints to equal the same grapheme in Unicode?

[05:43] <dduncan> If so, that could give me some trouble.

[05:44] <dduncan> If not, then great!

[05:44] <TimToady> depends on which canonicalization you've used

[05:46] <dduncan> I'm just talking about within the same Unicode version ...

[05:46] <TimToady> in general as long as all your data uses the same canonicalization, you don't have to worry

[05:46] <dduncan> or are there multiple canonicalizations within the same version?

[05:46] <TimToady> yes

[05:47] <dduncan> in that case, I should make a point of learning about canonicalizations, then declaring 1 to be the one used everywhere ...

[05:47] <TimToady> see http://unicode.org/reports/tr15/

[05:47] <lambdabot> Title: UAX #15: Unicode Normalization Forms

[05:47] <dduncan> assuming you can still represent everything when using 1 canonicalization

[05:50] <TimToady> people argue about whether NFC or NFD is better.  the answer is that they're better for different things

[05:50] <TimToady> NFC is more compact, and NFD is more future proof.

[05:51] <dduncan> certainly, everything will use the same single encoding, or as far as users are concerned it is as if that were true ... in fact, for users, there is no such thing as an encoding, except when a Text value is explicitly mapped to/from a Blob value

[05:55] <TimToady> but NFD compresses down about as well as NFC does, since the information content is the same.

[05:56] <TimToady> NFC is likelier to give you something close to one codepoint per grapheme for most national character sets.

[05:57] <TimToady> NFD will split out accents and such to combining characters, so you're very much in the realm of a variable width encoding in terms of codepoints per grapheme

[05:59] <TimToady> the default Perl approach is to simply claim that the abstraction will be maintained, even if you have to do normalization on the fly internally.

[06:00] <TimToady> given that Perl may be pulling in both NFC and NFD data, there's something to be said for the lazy approach.

[06:01] *** gaal joined
[06:01] <TimToady> it does mean that $a eq $b may be doing more than just memcmp() though

[06:02] <TimToady> but yes, to the user there is no encoding, at least until they have to send it to an API that needs to know.

[06:11] <dduncan> indeed

[06:13] *** BooK_ joined
[06:22] <Aankhen``> I asked this last night, but I guess I had to head for bed before the answer came. :-( Are there any provisions to facilitate event-driven programming in Perl 6?

[06:31] <TimToady> probably.  we're looking at doing something like in http://www.seas.upenn.edu/~lipeng/homepage/unify.html

[06:31] <lambdabot> Title: Unifying events and threads

[06:32] *** REPLeffect joined
[06:38] <Aankhen``> TimToady: Ah, I think that was linked to in the discussion I saw. Thanks.

[06:39] <Aankhen``> It had me salivating, despite my limited understanding of Haskell.

[06:45] *** devogon joined
[06:54] *** ashleyb joined
[06:59] *** ashelyb_ joined
[07:22] *** leed joined
[07:31] *** REPLeffect left
[07:40] *** CardinalNumber joined
[07:46] *** sunnavy joined
[07:49] *** ch3o joined
[07:49] *** ch3o left
[07:59] *** CardinalNumber is now known as ProperNoun

[08:19] *** gaal joined
[08:34] *** jisom joined
[08:35] *** Belaf joined
[08:43] *** theorbtwo joined
[09:11] *** fandang0 joined
[09:13] *** turrepurre joined
[09:16] *** larsen_ joined
[10:02] *** elmex joined
[10:08] *** BooK joined
[10:17] *** dec joined
[10:18] <dec> greetings

[10:19] <audreyt> dec: greetings

[10:21] <dec> I kept reading "visit #perl6" in the topic of #perl and decided to take up the offer, finally.

[10:21] <Aankhen``> There goes the neighbourhood. :-(

[10:28] <dmq> morning

[10:37] *** VanilleBert joined
[10:39] *** larsen__ joined
[10:58] *** dduncan left
[10:58] *** chris2 joined
[11:04] *** foo\ joined
[11:14] *** CardinalNumber joined
[11:32] *** CardinalNumber is now known as ProperNoun

[11:45] *** BooK joined
[11:47] *** upd joined
[11:55] *** BooK_ joined
[11:56] *** neonse joined
[11:59] *** unop joined
[12:00] *** gaal joined
[12:03] *** larsen_ joined
[12:04] *** bernhard joined
[12:08] *** unop left
[12:13] *** Khisanth joined
[12:14] *** CardinalNumber joined
[12:21] *** BooK joined
[12:33] *** CardinalNumber is now known as ProperNoun

[12:34] *** BooK joined
[12:45] *** Coke joined
[12:52] *** gaal joined
[12:56] *** BooK_ joined
[13:14] *** Squern joined
[13:23] *** BooK joined
[13:39] *** larsen__ joined
[13:40] *** ruoso joined
[13:53] *** BooK_ joined
[13:54] *** mjk joined
[14:10] *** BooK joined
[14:15] *** BooK__ joined
[14:30] *** buetow joined
[14:35] *** elmex joined
[14:39] *** xwrn joined
[14:42] *** Psyche^ joined
[14:48] *** bonesss joined
[14:52] *** iblechbot joined
[14:53] *** Psyche^ is now known as Patterner

[14:55] *** nOp joined
[14:55] *** xwrn joined
[14:56] *** prism is now known as Administrator

[14:57] *** Administrator is now known as prism

[15:05] *** Psyche^ joined
[15:20] *** diakopter joined
[15:21] *** Psyche^ is now known as Patterner

[15:31] *** kanru joined
[15:32] *** BooK joined
[15:38] *** xdg_ joined
[15:45] *** Limbic_Region joined
[16:10] *** kisu joined
[16:20] *** BooK_ joined
[16:20] <svnbot6> r15278 | lwall++ | Rework categories to just be a category of their own.

[16:20] <svnbot6> r15278 | lwall++ | Swap #= and #+ just 'cuz I like 'em better that way. #+ "adds" a definition.

[16:37] *** VanilleBert joined
[16:37] *** turrepurre_ joined
[16:43] <smash> debian virtual server is up&running

[16:43] <smash> ups, wrong channnel

[16:44] <smash> sorry

[16:45] <smash> alas, wrong server even

[16:49] *** BooK joined
[16:56] *** Alchemy joined
[16:58] <diakopter> sorry to be off topic, but #perl wasn't much help - I'm looking for a module to manage application deployments and their database schema upgrades/downgrades/rollbacks/patches.  Any tips?

[16:59] <nothingmuch> DBIC has some schema management

[16:59] <nothingmuch> including versioned schemas (though I think that's still in development)

[16:59] <westymatt> Does perl6 have a release date?

[16:59] <nothingmuch> go to #dbix-cplass on irc.perl.org and find out more

[16:59] <nothingmuch> westymatt: chrstimas (year unspecified)

[17:00] <westymatt> lol thank you

[17:00] <allbery_b> "when it's ready" :)

[17:00] <westymatt> I heard its going to have strongly typed support

[17:00] <westymatt> does this mean its optional?

[17:00] <nothingmuch> yes, fully optional

[17:01] <westymatt> I take it no release date yet for parrot?

[17:01] <revdiablo> No no, the correct answer is to start a ferocious debate about what "strong typing" really means

[17:02] <moritz> revdiablo: right. Anything less strongly typed then Eiffel is "weakly typed" </rant> ;))

[17:02] <revdiablo> westymatt: Even if there was a release date, I wouldn't trust it

[17:02] <westymatt> yeah your probably right

[17:03] <westymatt> revdiablo-debate on what strongly typed means?

[17:03] <moritz> when is The Hurd's release date? duke nukem forever? Debian Etch?

[17:03] *** revence joined
[17:04] <revdiablo> westymatt: Yes, "strong typing" does not have a clear definition, but... I was just being silly. I hope I haven't started the debate unitentionally =)

[17:04] <westymatt> no

[17:05] <westymatt> I always looked at perl 5 as being a bit strongly typed, with having @ % $ as opposed to php where everything is $

[17:05] <revdiablo> westymatt: Yeah, I agree with that. But a lot of people think "strong typing" means C-style static typing. So it's probably best to avoid the term altogether when in mixed company

[17:05] <westymatt> personally the perl approach is much better, because type doesn't have to be a guessing game where running through others code

[17:06] <westymatt> yeah that makes sense

[17:06] <revdiablo> Perl 6's typing system looks nice, though

[17:06] <nothingmuch> part of the reason perl 6 will support type annotation is just to improve readability

[17:06] <westymatt> yeah that is a real advantage something you lose entirely with python

[17:07] <westymatt> is parrot functional yet?

[17:07] *** prism is now known as daemon

[17:08] *** gaal_ joined
[17:10] <Limbic_Region> westymatt - #parrot is on irc.perl.org - why don't you join over there

[17:10] <Limbic_Region> in addition to hanging out here of course

[17:10] <westymatt> well thank you

[17:14] *** jferrero joined
[17:14] *** westymatt joined
[17:16] <svnbot6> r15279 | lwall++ | subst and trans replacement parsing

[17:21] <TimToady> westymatt: would you like a commit bit?

[17:22] <nothingmuch> d'oh, why didn't I think of that ;-)

[17:22] *** buetow joined
[17:23] * nothingmuch is not used to people actually not having them yet ;-)

[17:25] * Limbic_Region forgets too

[17:25] *** BooK_ joined
[17:26] *** rindolf joined
[17:26] <specbot6> r13590 | larry++ | inconsistency spotted by Smylers++

[17:26] <rindolf> Hi all.

[17:26] <moritz> hi rindolf

[17:26] <moritz> rafl: ping

[17:36] *** simcop2387 joined
[17:38] *** pdcawley joined
[17:39] <rindolf> Hi moritz, what's up?

[17:41] *** VanilleBert left
[17:42] <moritz> rindolf: not much, (debian) build system still fucked up and I don't understand it ;)

[17:45] <rindolf> moritz: Debian Build system of what?

[17:45] <moritz> rindolf: of pugs

[17:45] <rindolf> moritz: I see.

[17:45] <rindolf> moritz: you mean the one that creates a .deb package?

[17:45] <moritz> rindolf: exactly

[17:45] <rindolf> moritz: ah.

[17:45] <rindolf> moritz: well, I don't know anything about .deb generation.

[17:46] <rindolf> Albeit I am familiar with hacking .rpm's.

[17:46] *** gaal joined
[17:46] <moritz> rindolf: the problem is, I don't know that much as well...

[17:46] <rindolf> moritz: I see.

[17:46] <rindolf> moritz: one can install from source on Debian, right?

[17:47] <moritz> rindolf: do you mean source packages?

[17:47] <moritz> rindolf: or plain make && make install?

[17:47] <rindolf> moritz: no I mean, using svn co ; perl Makefile.PL ; make ; etc.

[17:48] <moritz> rindolf: yes, but that's ugly...

[17:48] <moritz> rindolf: partly it's ugly becaues 'make install' as root still compiles stuff...

[17:48] <moritz> rindolf: which leads to a poisoned source tree

[17:49] <moritz> I'm currently trying to build .debs that don't include support for parrot...

[17:49] <moritz> since I use testing and libparrot-dev is not in testing due to RC-Bugs :(

[17:50] <rindolf> moritz: what RC-bugs?

[17:50] <rindolf> And what are RC-bugs?

[17:50] <moritz> rindolf: "Release Critical"

[17:50] <rindolf> moritz: I see.

[17:51] <moritz> rindolf: http://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=parrot;dist=unstable <-- especiall a >190 days old "can't build" bug ;)

[17:51] <lambdabot> Title: Debian Bug report logs: package parrot in unstable (versions 0.4.1-1, 0.4.4-1, 0 ..., http://tinyurl.com/yvg2uo

[17:57] *** BooK joined
[17:58] *** xinming_ joined
[18:11] *** ruoso joined
[18:37] *** [M]erk joined
[18:38] *** bonesss joined
[18:40] *** diakopter joined
[18:40] <svnbot6> r15280 | lwall++ | some notes on linkage

[18:59] *** nekokak_ joined
[19:05] *** BooK_ joined
[19:16] *** kisu joined
[19:18] *** awwaiid joined
[19:20] *** CardinalNumber joined
[19:26] *** nipra joined
[19:28] *** gaal joined
[19:38] *** dduncan joined
[19:38] *** Belaf_ joined
[19:39] *** CardinalNumber is now known as ProperNoun

[19:39] *** jisom joined
[19:41] *** BooK joined
[19:50] *** upd_ joined
[19:51] *** upd_ is now known as upd^

[19:53] *** BooK__ joined
[20:04] *** kisu left
[20:06] *** sunnavy joined
[20:06] *** ludan joined
[20:10] *** amnesiac joined
[20:26] *** BooK joined
[20:27] *** prism joined
[20:34] *** Aankhen`` joined
[20:34] *** elmex joined
[20:36] *** BooK_ joined
[20:52] *** weinig|away is now known as weinig

[20:53] *** czth__ joined
[20:56] *** BooK joined
[20:58] *** Victor_ joined
[20:58] <Victor_> hello

[20:58] <Victor_> http://www.fourmigration.com/link.php?pid=15&cont=5

[20:59] *** Victor_ left
[21:02] *** gaal joined
[21:05] *** BooK_ joined
[21:14] *** BooK__ joined
[21:22] *** Alchemy joined
[21:23] *** weinig is now known as weinig|bbl

[21:24] * moritz stares at CGI.pm's smoke results...

[21:25] <moritz> the failures in params.t all originate from the fact that CGI.pm does not preserve the order of the params...

[21:25] <moritz> but is that order really important? does it _have_ to be preserved?

[21:25] *** prism joined
[21:26] <dduncan> HTTP GET and POST parameter order is not significant

[21:27] <dduncan> since all fields are identified by their name

[21:27] <moritz> ok

[21:27] <moritz> so the tests basically produces false-positives?

[21:28] <dduncan> that said, there is a fuzzy area where sometimes groups of form elements are all given the same name, and some people consider the order of returned results to be significant

[21:28] <PerlJam> dduncan: foo=a&foo=b    What is the value of param('foo')?   I think order does matter.

[21:29] <dduncan> the value of foo is a junction of a and b

[21:29] <moritz> PerlJam: in that case CGI.pm stores a list associated with 'foo'

[21:29] <dduncan> or a set containing a and b

[21:29] <moritz> which is, IMHO, the correct way to do it

[21:29] <dduncan> as far as I'm concerned, if multiple fields have the same name, they denote a set

[21:30] <dduncan> where order is significant, the fields should have different names, or any significance can be attributed to sorting the values on the values, but then we don't need to preserve order info anyway

[21:31] <dduncan> personally, I think some aspects of the CGI.pm interface are flawed

[21:31] *** diakopter left
[21:31] <moritz> dduncan: which aspects?

[21:31] <dduncan> for example, it discards GET parameters in an HTTP POST request

[21:32] <moritz> shouldn't they be accessible via url_param?

[21:32] <dduncan> often in practice it is useful to transmit parameters using both places at the same time, but in order to do so with CGI.pm, I have to redo some of CGI.pm's work

[21:32] <dduncan> huh?

[21:32] <Khisanth> PerlJam: I don't think anyone is going to be foolish enough to rely on the order :)

[21:32] <dduncan> looking ...

[21:33] <moritz> dduncan: at least in P6 it did...

[21:33] <dduncan> I'm judging CGI.pm on its Perl 5 incarnation

[21:33] <PerlJam> Khisanth: clearly you must live on some other planet than the one I'm on.  Mine is *full* of foolish people.

[21:33] <dduncan> which AFAIK is being emulated as close as possible by the Perl 6 one, because its only reason to exist in Perl 6 is to help people migrate Perl 5 code

[21:34] <dduncan> of course, if the P6 one can be improved without losing significant backwards compatibility, I'm all for that

[21:35] <moritz> so should we implement url_param as well?

[21:35] <dduncan> in general, I prefer what many other tools do which is to treat GET and POST params as 2 distinct namespaces, which they are, and have separate functions to fetch either, rather than a combined function for both

[21:35] *** BooK joined
[21:35] <dduncan> GET and POST are no more ideally combinable than either is for COOKIE or PATH_INFO etc

[21:35] *** macroron joined
[21:36] <dduncan> s/for/with/

[21:36] <moritz> so offer get_param and post_param, and param() and url_param() for backwards compatiblity?

[21:36] <dduncan> in fact, one should be able to have a GET and POST var with the same key, and have them be distinct

[21:36] <dduncan> sure

[21:36] <PerlJam> dduncan: separating GET and POST is good, but so is having a sane combiner 

[21:37] <dduncan> as long as we fundamentally consider them distinct, and that the combiner is conceptually a convenience wrapper

[21:37] <PerlJam> precisely

[21:37] <moritz> PerlJam: the current approach in perl5's CGI is to look if POST-data is available, if yes, use that, if no, use GET

[21:38] <dduncan> CGI.pm in Perl 5 fundamentally considers them combined, or more specifically, ignore GET if we're a POST query

[21:38] <dduncan> you can see it clearly in he code

[21:39] <dduncan> personally, I'd like this to be fixed in the Perl 5 version

[21:39] <dduncan> ironically, I haven't yet talked to Lincoln Stein about this, so perhaps I should

[21:40] <moritz> well, do that before I try to fix P6's CGI

[21:40] <moritz> it would be a bad idea to fix it in an incompatible way ;)

[21:41] <dduncan> fyi, the internals can be fixed without changing the api

[21:41] <moritz> maybe, but it's easier to fix if you know what the API's going to be

[21:41] <dduncan> that's one big reason why we have encapsulation in the first place

[21:42] <moritz> or at least then you can do it all in one rush

[21:46] <PerlJam> I think it would be just fine to fix p6's CGI.pm in a way that's incompatible with p5's CGI.pm

[21:48] <moritz> why should we do that?

[21:48] <dduncan> so would I, actually

[21:48] <dduncan> as long as its mostly the same, so migration is easy

[21:48] <PerlJam> moritz: to fix the original CGI.pm's mistakes

[21:49] <dduncan> users can adapt to the fixes the same way they adapt to Perl 6's fixes of Perl 5

[21:49] <dduncan> if the design is similar enough, it would still be a thematic p5CGI descendent

[21:50] <moritz> allright

[21:50] <dduncan> eg, the API can be 90% the same while being 300% better

[21:51] <dduncan> also, despite what I said, I'm not sure it is practical to try and improve the Perl 5 version now ... what I suggested is just 1 of many P5CGI.pm issues that I have to work around ... almost to the point that I don't use CGI.pm at all

[21:51] <dduncan> or when I do use it, it is wrapped in a different class

[21:52] <dduncan> so I won't be writing LS today

[21:52] <PerlJam> dduncan: you sound like me (but for different reasons)

[21:52] <moritz> why don't you like it? 

[21:52] <moritz> I mean it's not pretty, but it's not that bad either...

[21:53] <dduncan> the API of CGI.pm is too different from the conceptual processes that it wraps, and I want to work more in the underlying terms

[21:54] <dduncan> it loses information, as I previously mentioned

[21:55] <dduncan> its API is rather kitchen-sink in design

[21:56] <dduncan> or should I say, inconsistent and hard to understand in places just looking at it

[21:56] <dduncan> but I understand a lot of that is due to legacy issues, so I can't fault it that badly

[21:56] <Juerd> If you haven't already, please read my Perl 6 CGI-related posts in perl6-users

[21:56] <dduncan> if you mean last year, I participated in that discussion

[21:56] <dmq> the funny thing with CGI is that everybody thinks it sucks, yet it hasnt really been replaced by anything so drammatically better that people stop recommending CGI.

[21:57] <dduncan> people recommend CGI because it is bundled with Perl

[21:57] <dduncan> and there is legacy code examples to look at

[21:57] <dmq> but if there was something that the community overwhelmingly thought was better it would end up being bundled as well.

[21:57] <Juerd> http://groups.google.com/group/perl.perl6.users/browse_frm/thread/00845b10b8ed7266/a209deddfadad19b?#a209deddfadad19b

[21:57] <lambdabot> Title: perl.perl6.users | Google Groups, http://tinyurl.com/2yefua

[21:57] <PerlJam> dmq: I don't use CGI.pm because it sucks.  I use my own home-grown thingy.  The problem is, I suspect, that all of the people who think CGI.pm sucks either do as I do or just suck it up and use CGI.pm.

[21:57] <Juerd> http://groups.google.com/group/perl.perl6.users/browse_frm/thread/2e67c41cf3bd5e35/5db1c4513fb847ff?#5db1c4513fb847ff

[21:57] <lambdabot> Title: perl.perl6.users | Google Groups, http://tinyurl.com/ypjn4x

[21:57] <dmq> my point exactly PerlJam. :-)

[21:58] <dmq> btw, it does suck. :-)

[21:58] <Juerd> Those posts outline my thoughts on the matter

[21:58] *** upd^ is now known as upd

[21:59] <dmq> those are long. ill have to read them when my brain has some power.

[21:59] <dduncan> CGI.pm's main advantage is that it is a low barrier for entry to people that want to do a quick form ... kind of like PHP's advantage actually ... but it falls down when scaling up in complexity ... or it falls down if you want expressivity

[21:59] *** rashakil joined
[21:59] <Juerd> dduncan: Yes, but there's no reason that such a low barrier could not be made without making the same mistakes.

[21:59] <dmq> or it falls down because when you read the code you want to puke. :-)

[21:59] <dduncan> indeed

[22:00] <Juerd> I think the interface should be made more perlish, and more modular. 

[22:00] <Juerd> Modular also involving tearing apart unrelated functionality.

[22:00] <PerlJam> Juerd: indeed!

[22:00] <Juerd> Perlish involving, among other things, using Perl data types instead of methods, where it can be made to make sense.

[22:01] <dduncan> so I'm all for making a better replacement for CGI.pm replacement in Perl 6 that is targeted at the same user base, which is low barrier of entry for doing simple things, but at the same time lacks all the bad stuff

[22:01] <Juerd> This requires, for example, ordered hashes, and Items that are both String and Array. But in Perl 6, all of this *can be done*!

[22:01] <Juerd> Though we don't know how yet :(

[22:01] <PerlJam> dduncan: people can still use perl5's CGI.pm in perl6 if they like the old way  

[22:01] <dduncan> yes

[22:02] <Juerd> This is what I miss in the current Perl 6 implementation (Pugs).

[22:02] <Juerd> PerlJam: Exactly

[22:02] <dduncan> fyi, my first significant CPAN modules, in 2001, were created partially as a replacement for CGI.pm

[22:02] <dduncan> but then, I recall, that was a popular thing to do

[22:02] * Juerd would love to write (parts of, or all of) the new CGI.pm replacement, but the infrastructure isn't ready.

[22:03] <PerlJam> Juerd: that hasn't stopped Larry from writing perl 6 in perl 6 :-)

[22:03] <Juerd> In fact, I'm afraid that once Perl 6 is implemented enough to do this stuff, it's already too late because someone will have implemented some more limited and less designed toolkit, which will already be the de facto standard.

[22:03] *** BooK_ joined
[22:03] <Juerd> PerlJam: I don't know how to write some of the things.

[22:03] <Juerd> PerlJam: Mostly the data types. Those are the basis of my thoughts.

[22:04] <dduncan> well, you say infrastructure isn't there, but you could still write the Perl 6 version the proper way even lacking the infrastructure, then let the infrastructure fill out behind it

[22:04] <Juerd> PerlJam: $GET<foo> should be both 'bar' and ['foo', 'bar'] given a QUERY_STRING of foo=foo&foo=bar

[22:04] <Juerd> dduncan: Infrastructure includes syntax.

[22:05] <Juerd> dduncan: How do you create an ordered hash? Your own array?

[22:05] <dduncan> why do you need an ordered hash?

[22:05] <Juerd> dduncan: Because in CGI parameters, order *does* matter.

[22:05] <dduncan> why?

[22:05] <Juerd> dduncan: Two form elements can have the same name.

[22:05] <Juerd> dduncan: They then commonly form an array in the implementation.

[22:06] <dduncan> and why does order matter, vs the 2 elements forming a 2 element set?

[22:06] <dduncan> so they form a set|junction in implementation

[22:06] <Juerd> dduncan: This is just one of the two reasons.

[22:06] <Juerd> dduncan: I was still typing, and will now start over. Please be patient :)

[22:06] <dduncan> ...

[22:07] <dduncan> more importantly is whether the HTTP standard says that order is significant, I think

[22:07] <Juerd> dduncan: Form elements must be submitted in the order they were in the HTML document, and that makes a lot of tasks very simple without resolving to code duplication. For example, a mail form. 

[22:07] <Juerd> The HTTP standard explicitly says that order is significant.

[22:07] <dduncan> well, okay then

[22:07] <Juerd> Furthermore, the order of *headers* is *also* significant.

[22:07] <Juerd> Consider the mail form example.

[22:08] <Juerd> For the Dutch Perl Workshop, we use a (too) simple CGI script that sends the form as a YAML document, by email.

[22:08] <Juerd> It is then handled by others for several purposes.

[22:08] <dduncan> but in my experience, a hash of arrays suffices to preserve and recreate an ordered query string

[22:08] <dduncan> one hash key per unique query key, and multiple values in the array in the order they were in the query

[22:08] <Juerd> But because hashes are unordered, these messages suck for human beings.

[22:08] <Juerd> And coding around this requires a lot more effort.

[22:09] <dduncan> doesn't anything which wants the data just extract the expected values by name anyway?

[22:09] <Juerd> dduncan: It's not about sufficiency!

[22:09] <Juerd> Heck, Perl 5 suffices.

[22:09] <Juerd> But if we're creating new tools, please let's work towards making *better* tools than we had before.

[22:09] <dduncan> well, replace sufficient with ideal in my comment

[22:10] <Juerd> I'm also not saying that all hashes should be ordered. I'm just saying that for a Perlish interface to HTTP and CGI stuff, you need them.

[22:10] <Juerd> Otherwise you're stuck with OO interfaces. Which are nice, but cumbersome.

[22:10] <Juerd> I don't *intuitively*, as a Perl programmer, know how to add a new param if the interface for getting one is $foo->param('bar')

[22:10] <Juerd> Could be anything.

[22:11] <dduncan> one generic tool by which to implement an ordered hash would be a ternary relation

[22:12] <dduncan> the 3 attributes being index, key, and value

[22:12] <Juerd> I want to be able to do "push $get<bar>, $string". This should work regardless of the number of "bar" elements in the query: 0, 1 or 2.

[22:12] <dduncan> if you read values ordered by index, you interpret it as ordered

[22:12] <dduncan> to add one to the end, you add a tuple with an index value 1 higher than the highest one in there

[22:13] <PerlJam> dduncan: who does the bookkeeping there?

[22:13] <Juerd> BTW, please refer to my post " Web development II: Code", which shows some (pseudo) code

[22:13] <dduncan> what do you mean?

[22:13] <Juerd> Ideally, all you need is:

[22:13] <Juerd>     class OrderedHash {

[22:13] <Juerd>         is Hash;

[22:13] <dduncan> I mean, PerlJam, what do you mean?

[22:13] <Juerd>         make that: does Hash;

[22:13] <Juerd>         does Array;

[22:14] <Juerd>         # override some methods here

[22:14] <Juerd> }

[22:14] <dduncan> sure

[22:14] *** ekelund joined
[22:14] <dduncan> that would be useful

[22:14] <Juerd> The actual implementation is less important to me. I'm sure all pieces will fall into place automatically.

[22:15] <Juerd> Also important is the Str/Array hybrid.

[22:15] <Juerd> In fact, I'd say it's more important even.

[22:15] <PerlJam> dduncan: you were talking implementation detail and I was thinking in terms of interface.  Ignore me.

[22:15] <dduncan> fyi, a relation is conceptually like a hash, but that n values are related rather than 2 values, and you can have multiple keys 

[22:15] <Juerd> And then, there's the combination of both. 

[22:15] <Juerd> Does a "push" on the Array/Hash hybrid, also push onto the array that is the value?

[22:16] *** weinig|bbl is now known as weinig

[22:16] <Juerd> i.e. can "push %orderedhash, bar => 'baz';"  push onto $orderedhash<bar>?

[22:16] <Juerd> (iff $orderedhash<bar> does Array)

[22:18] *** bonesss joined
[22:19] <dduncan> Juerd, I like your  " Web development II: Code"

[22:20] <Juerd> dduncan: Thanks

[22:20] <moritz> to me it sounds like a bit too much magic ;)

[22:21] <Juerd> moritz: No magic at all...

[22:21] <Juerd> To get this in Perl 5, you'd need lots of magic.

[22:21] <dduncan> I still think you can prototype it in Perl 6, just substituting some prerequisites for others until the ones you want are present, then switch back ... but either way, having something out there, will give you a better chance of being the defacto standard instead of someone else

[22:21] <Juerd> But in Perl 6, I think we can make it happen and intuitive, without relying on magic, or on awkward "looks like Perl, but doesn't behave as expected" interfaces.

[22:21] <dduncan> I'm making a push along those lines myself, but for DBMSs

[22:22] <Juerd> dduncan: I've tried, and threw it all away. It requires replication of all methods.

[22:22] <Juerd> dduncan: And once you're doing both array and hash, or both array and str, that's a lot of methods.

[22:22] <Juerd> I have little time.

[22:22] <PerlJam> Juerd: sounds just like a Capture to me  :-)

[22:22] <nothingmuch> moose

[22:22] <dduncan> fair enough

[22:23] <Juerd> I'm convinced that the entire toolkit can be written in a few days, once Perl 6 is ready.

[22:23] <Juerd> But I'm afraid that when Perl 6 is ready, it will already be too late, exactly *because* people will have been too impatient to wait.

[22:24] * Juerd rereads "will have been" and wonders if English even works like that :)

[22:24] <moritz> Juerd: I think it does, but I'm not a native speaker as well

[22:24] <dduncan> why don't you create an ext/ in Pugs now that is written the way you think it should be done, even if it doesn't compile yet

[22:25] <dduncan> Larry is writing the Perl 6 parser in Perl 6 now, though some prereqs don't work yet, afaik

[22:25] <Juerd> dduncan: Because I lack the creativity required to think of syntxa.

[22:25] <dduncan> then it would still only take the few days

[22:25] <Juerd> I've written this p6u post outlining a part of what I would want

[22:26] <Juerd> I'm sure that it can be improved a lot.

[22:26] <Juerd> And don't want to write everything now, and risk two horrible things:

[22:26] <Juerd> 1. that it will be used without the required improvement, because it's feature complete

[22:26] <Juerd> 1. that everything needs to be rewritten. As said, I have too little time.

[22:26] <Juerd> s/1/2/

[22:27] <Juerd> Some experimentation will be needed. For that, we need at least syntax.

[22:27] <dduncan> alternately, maybe you are worried too much that someone else will become a fefacto standard

[22:27] <Juerd> I am worried about that, yes. 

[22:27] <PerlJam> Hmm.

[22:27] <Juerd> Well, I am worried that someone will not think it through enough.

[22:27] <dduncan> considering your situation, maybe you should just wait until the syntax is in place, then write your thing in a few days

[22:28] <Juerd> So far, EVERY SINGLE discussion about getting rid of CGI.pm has resulted in many people coming up with ideas that IMO are suboptimal.

[22:28] <Juerd> dduncan: But then important namespace will be taken already.

[22:28] <Juerd> I don't believe in MyProject::HTTP::Message.

[22:28] <dduncan> then write a placeholder empty module in that namespace

[22:28] <PerlJam> Juerd: this is perl6 ... CGI-1.2-Juerd is just fine.

[22:28] *** larsen_ joined
[22:28] <Juerd> PerlJam: That's not the only issue. One issue is compatibility and de-facto objects.

[22:29] <Juerd> PerlJam: I write things that can take standard LWP objects.

[22:29] <Juerd> PerlJam: I can do this because LWP is the standard.

[22:29] *** Psyche^ joined
[22:29] <dmq> (afaik "will have been" is ok)

[22:29] <Juerd> PerlJam: But CGI.pm doesn't use the same objects, even though many would make a lot of sense.

[22:29] <dduncan> add an ext/ entry now which declares all the namespaces you want to use, but doesn't fill them out, and make its test suite empty

[22:29] <dduncan> if you change your mind later on the names, then update the ext/ accordingly

[22:29] <Juerd> dduncan: Oh, but the test suite could be filled.

[22:30] <dduncan> whatever works

[22:30] <Juerd> I have a really clear vision of the API. All I need is (lots and lots) of tuits.

[22:30] <dduncan> but simply declaring your namespace takes fairly little tuits

[22:30] <dduncan> I'm sure you could do it in just an hour

[22:30] <Juerd> dduncan: Sounds like domain squatting. I hate that.

[22:30] <PerlJam> actually, that's the way to do it.  Write the tests assuming things work the way you think they should.  Modules will grow around the interface implied (specced?) by the tests

[22:30] <PerlJam> (maybe)

[22:31] <dduncan> well, if you end up not using the name later, you can remove the ext/ entry

[22:31] <dduncan> see, in the early days of Perl 6 when all Perl 6 code is in Pugs, its easy to be dynamic as to what names are in use or not

[22:31] <moritz> dduncan: and charge 80$ for the next one to use it *duck*

[22:32] <dduncan> by the time Perl 6 code breaks out of the Pugs distro, things should be in place for your solution to be opeating

[22:32] <dduncan> operating

[22:32] <dduncan> this is not really the same as domain squatting at all

[22:32] <dduncan> and besides, I think you are well known enough, Juerd, that people would trust you if you reserve a name

[22:32] <Juerd> PerlJam: Iff I'll make it to the hackathon, I'll spend some time there.

[22:33] *** pdcawley joined
[22:33] <dduncan> so go and make your claim for the name!

[22:34] <dduncan> and fyi, you can consolidate your existing comments and example code to date as a documentation file which you place under that ext/ entry in Pugs

[22:34] <Juerd> $foo<bar> = 42; push $foo<bar>, 15; is($foo<bar>[0], 42); is($foo<bar>[1], 15); is($foo<bar>.join(":"), "42:15"); is($foo<bar>, 42);

[22:34] <dduncan> rather than referring people to emails

[22:34] <Juerd> dduncan: I know, I know. Tuits.

[22:35] <dduncan> if you want, I'll do what I just said on your behalf

[22:35] <dduncan> then you don't have to do anything now

[22:35] <Juerd> dduncan: The (imo) important parts of the messages were warnocked. I would have liked some more discussion.

[22:35] <moritz> from which directory are the tests called when `make smoke` is run?

[22:35] <Juerd> dduncan: Please, that would be nice.

[22:35] <dduncan> looking ...

[22:36] <Juerd> One of the things that I don't know yet, how to handle, is the numeric value of things.

[22:37] <Juerd> Here, it may *look* logical that $foo<bar> == 42, but why wouldn't it == 2, for containing two elements?

[22:37] <Juerd> That probably means there's something fundamentally wrong with my ideas, but I don't yet know how to fix it.

[22:38] <moritz> Juerd: shouldn't it be [42, 15]?

[22:38] <Juerd> So perhaps it's just an Array that returns its last element when used in scalar context.

[22:38] <Juerd> moritz: Both!

[22:39] *** JimmyZ joined
[22:39] <moritz> Juerd: why the heck should it return it's _last_ element?

[22:39] <dduncan> Juerd, mind this channel ... I may have a few questions for you to guide my progress, which is starting immediately ...

[22:39] <Juerd> dduncan: I'm sick and need to sleep soon.

[22:39] <Juerd> moritz: To be compatible with current scripts.

[22:40] <dduncan> oh

[22:40] <dduncan> I'll be quick then, maybe just one question

[22:40] <Juerd> moritz: Many existing sites depend on addition to the query string overriding previous values.

[22:40] <dduncan> your example code seemed to fall into 2 main namespaces, HTTP and Web

[22:40] <Juerd> moritz: When re-writing implementation, you don't also want to re-write all URLs, because there may be external links to them.

[22:40] <dduncan> would you say that HTTP is standalone, and Web is an optional extension?

[22:40] <Juerd> dduncan: Both stand alone, but Web depends on HTTP.

[22:41] <dduncan> I'm inclined to make 2 ext/ entries from what I saw, one for each, if so

[22:41] <Juerd> From my perspective, "HTTP" is just the "current protocol" that we use for the web.

[22:42] <Juerd> But maybe one day someone makes xhttp, an XML 2.0 compliant protocol, that is meant to replace HTTP.

[22:42] <moritz> Juerd: I don't get your point... why should a site use /?foo=bar;foo=baz instead of /?foo=baz ? in both cases external links would point to /?foo=bar...

[22:42] <moritz> Juerd: which is different from either...

[22:42] <Juerd> moritz: "$currenturl&foo=baz"

[22:42] <dduncan> well, I'll just do what I think will work, and people can change it later

[22:42] <moritz> Juerd: or did I get something wrong?

[22:42] <dduncan> and that is making HTTP/ and Web/

[22:42] <Juerd> dduncan: Yes, that's good.

[22:43] <dduncan> so get some sleep, then

[22:43] <dduncan> oh, in case it wasn't obvious, as I'm doing this as your proxy, I will specifically say you are the author of these ext/ distros

[22:44] <Juerd> Need to finish upgrading a server; I expect that to take 5 to 10 minutes

[22:44] <dduncan> in the associated metadata

[22:44] <Juerd> (Memo: never again do such stuff on production servers if you can't think clearly)

[22:44] <Juerd> Thanks for proxying me

[22:44] *** Psyche^ is now known as Patterner

[22:50] *** justatheory joined
[22:50] *** weinig is now known as weinig|bbl

[22:52] <Juerd> Good night, all

[22:52] <moritz> Juerd: good night

[22:53] <moritz> in which variable is the directory seperator ('/' for unix, '\' for win) stored?

[22:54] <dmq> in what?

[22:55] <dmq> perl (and actually the win32 internal routines) normally handles both.

[22:55] <moritz> perl6

[22:55] <moritz> so should I just use /?

[22:55] <dmq> thats the tendency in the perl5 world.

[22:57] <moritz> dmq: ok, thanks

[23:03] *** offby1 joined
[23:04] <offby1> is there something like FindBin for pugs?

[23:06] *** BooK joined
[23:06] <moritz> offby1: I'm essentially searching for the same thing...

[23:07] <offby1> I see http://svn.pugscode.org/pugs/ext/FindBin/lib/FindBin.pm but I don't know how to use it.

[23:07] <offby1> "use FindBin" just yields an error.

[23:07] <moritz> offby1: the testcases for Config::Tiny mostly fail because they are executed in the wrong directory

[23:07] * offby1 facepalsm

[23:07] * offby1 facepalms

[23:08] <moritz> offby1: probably @*INC is wrong (or not filled sufficiently)

[23:08] <offby1> sure

[23:15] *** devogon joined
[23:18] <moritz> but currently I'm lost as well

[23:19] <moritz> well, time for bed, good night * ;)

[23:22] <dduncan> Juerd, you have multiple email addresses listed for yourself, but I will be using [email@hidden.address] in your metadata, following the example of at least 1 of your existing CPAN modules, unless you want a different one used

[23:23] <dduncan> ... or you're gone ... so just take that as an fyi and change it later if you want

[23:45] *** BooK_ joined
[23:47] *** buetow joined
[23:53] *** BooK__ joined
