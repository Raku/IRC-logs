[00:00] <Arathorn> i guess i'm asking why { foo() } seems to mean sub { foo() } rather than do { foo() }

[00:00] <Arathorn> audreyt: open(...) or do { warn "failed to open"; return; }

[00:01] <Arathorn> i've never really understood why the do is necessary, or if it's even good style (given the history of 'do' as a perl4ish keyword)

[00:01] <jql> Arathorn: It's a design choice, to make passing code around in variables easier.

[00:02] <avar> why isn't code always an expression?

[00:02] <audreyt> open err { warn "failed!"; return }();

[00:02] <audreyt> the extra () seems a reasonable thing to type

[00:02] <Arathorn> mm, ok

[00:03] <avar> is my Code $c = do { foo() }; the same as my $c = \&foo; in p5?

[00:03] <jql> avar: err, no

[00:03] <Arathorn> performance wise is that nastier than worse than unless (open) { warn "failed!"; return } #?

[00:03] <jql> do { foo() } actually calls foo()

[00:04] <allbery_b> my Code $c = { foo() }; which I think is my $c = sub { foo(); };

[00:04] <Arathorn> given that it has to presumably do closure magic when instantiating the anonymous function

[00:05] <allbery_b> I think &foo is the new \&foo but don't quote me, I don'

[00:05] <allbery_b> t have the synopses memorized :)

[00:05] <Juerd> Arathorn: It's partly for nice syntax like: map { $_ ** 2 }, @numbers

[00:06] <Juerd> Arathorn: Which would otherwise either require a special case, or: map sub { $_ ** 2 }, @numbers

[00:06] <Arathorn> right, that makes sense

[00:06] <Juerd> Arathorn: Also, for @bar { ... } would be something like for @bar, sub { ... }

[00:06] <moritz_> which could be writetn as @number >>** 2 (just in this case)

[00:06] <Arathorn> i guess i'm too used to {} being merely a block delimiter in C-style languages, rather than yielding a coderef

[00:06] <Juerd> moritz_: I've never been really good at contriving code :)

[00:07] <allbery_b> think postscript? :)

[00:07] <Juerd> Arathorn: It's a block delimiter in Perl too.

[00:07] <Juerd> Arathorn: Only a keywordles block is treated differently when it's not in void context.

[00:07] <Juerd> Note that in void context, it still immediately executes.

[00:08] <Arathorn> right

[00:08] <Juerd> In fact, I think 0 || { die } may execute die.

[00:08] <Arathorn> it doesn't in (my very old) pugs

[00:08] <jql> $x = 0 || { die } ?

[00:08] <jql> is different from the void version?

[00:08] <Juerd> jql: Closure assignment.

[00:08] <Juerd> Yes.

[00:09] <Juerd> 5;  # 5 in void context

[00:09] <Juerd> my $x = 4;  # 5 in item context

[00:09] <Juerd> my @x = 5;  # 5 in list context

[00:09] <Juerd> s/4/5/

[00:09] <jql> so, it would have a different result depending on whether it's the last statement in the function? heh

[00:09] * jql gets out the spooky stick

[00:09] <Juerd> jql: I think so. But sane people don't write this in void context anyway :)

[00:09] <Arathorn> whilst i can see why there's convenience in {} returning a coderef in a non-void context, the different in behaviour for some reason seems unintuitive. but that's probably just me

[00:10] <jql> Arathorn: I always used comma in the case you cited above, in p5

[00:10] <Arathorn> jql: that's what i've been doing to - or || do { foo; bar; baz };

[00:10] <Arathorn> s/to/too/;

[00:10] <jql> foo(), bar() if 0 || (warn("foo"), return)

[00:11] <Arathorn> but i've always wondered whether do {}; had any unexpected overhead due to the block somehow having to be stored in such a way that it can be executed via 'do'

[00:12] <Juerd> do { } is syntax, not a function call.

[00:12] <Juerd> afaik

[00:14] <Arathorn> right

[00:14] <audreyt> do{} has overhead.

[00:14] <audreyt> braceless-do does not

[00:14] <audreyt> (the overhead is constructing a lexical scope)

[00:14] <Arathorn> does anyone know what overhead one would expect there to be between sub { warn; return }() and plain old { warn; return } #?

[00:15] <TimToady> the scope could be optimized away if it's unused

[00:15] <audreyt> well if you drop the "sub"

[00:15] <jql> depends on the level of -O

[00:15] <audreyt> then it's the same

[00:15] <audreyt> if you say "sub" then we have to construct a Routine instead of Block

[00:15] <Arathorn> oh, ok

[00:15] <audreyt> which is considerably harder to optimize away

[00:15] <jql> especiaally considering warn() probably calls context()

[00:15] <Arathorn> so {} in a non-void context yields a reference to Code which happens to be a Block?

[00:15] <audreyt> correct.

[00:16] <Arathorn> okay.

[00:16] <TimToady> it's not whether it's in a void context, but whether it's being used as a statement

[00:17] * Arathorn looks slightly more panicked and says "okay." again

[00:17] <TimToady> alternately, you can say that a block in statement position forces itself into void context and passes the real context to its inside.

[00:17] <rhr> Arathorn: &abort := -> Str $err { warn "$err\n"; return; } then you can say things like open ... err abort "some error"

[00:17] <TimToady> if you want to return a block rather than its value, use "return" explicitly.

[00:18] * allbery_b looks around furtively before starting the whole update-build-smoke cycle again...

[00:18] <audreyt> allbery_b: another massive commit coming...

[00:18] <allbery_b> heh

[00:18] <Arathorn> rhr: fair enough - although i'm searching for an idiom where my error block could contain arbitrary error handling.  more like a cheap one-off exception

[00:18] <avar> audreyt considered harmful to pugs smoking:)

[00:19] <TimToady> err try {...} maybe then?

[00:20] <moritz_> 18426 test cases: 7287 ok, 11139 failed, 3055 todo, 693 skipped and 2341 unexpectedly succeeded

[00:20] <Arathorn> i guess so

[00:20] <moritz_> fascinating ;-)

[00:20] <rhr> yeah, there's that.  I've found that idiom to be pretty useful though

[00:20] * Arathorn rereads S4

[00:20] <svnbot6> r15613 | audreyt++ | * Pugs.Parser: Allow exported "my" subs, whatever they may mean...

[00:22] <Arathorn> i guess i'm wondering if there

[00:22] <Arathorn> is any way to avoid setting up a new lexical scope, or anonymous code block

[00:22] <Arathorn> other than 0 || (warn(), return);

[00:22] <Arathorn> uh, s#||#err#

[00:23] *** lisppaste3 joined
[00:23] <audreyt> well yes

[00:23] <TimToady> then "err try expr" or "err do expr"

[00:23] <audreyt> what TimToady said.

[00:24] <Arathorn> ah, just by missing the braces - okay

[00:24] <TimToady> tosses the lexical scope but keeps the dynamic

[00:24] <Arathorn> presumably expr still ends up being comma delimited, though?

[00:24] <Arathorn> assuming you want multiple expressions

[00:25] <audreyt> I think TimToady recently added to S04 this form:

[00:25] <audreyt> 0 err (warn; return);;

[00:25] <audreyt> nvm the trailing semis

[00:26] <audreyt> oh, not really, the form is

[00:26] <audreyt> 0 err (return if warn "...");

[00:26] <Arathorn> ah, ok

[00:26] <moritz_> does ghc cleans up its temp files?

[00:26] <audreyt> semis within parens still isn't defined, iirc

[00:26] <audreyt> moritz_: usually yes

[00:27] <moritz_> ok, then i probably had an unusual case ;-)

[00:27] <moritz_> no, I'm wrong

[00:29] <audreyt> restarting evalbot

[00:29] <Arathorn> audreyt/TimToady/all: thanks for clarifying block behaviours - that all makes sense now

[00:30] *** Psyche^ joined
[00:30] *** eric_ joined
[00:31] * Arathorn stops agonising over the perceived ugliness of the open() or do { log_to_server(); log_to_client(); etc; return; } he just wrote in his p5 thing and relurks

[00:33] <svnbot6> r15614 | putter++ | yet_another_regex_engine/ - began :ratchet support.  It looks like simply concat(quant_or_alternation,commit_sequence).

[00:34] *** evalbot_r15613 joined
[00:34] <audreyt> ?eval 1

[00:35] <obra> "That didn't last long"

[00:35] <putter> Perl-6.0.0-STD.pm... 370 tokens, 70 rules, 14 other regex, and 4 methods.  Even in a small font that's big.

[00:35] <putter> ;)

[00:37] *** Psyche^_ joined
[00:39] <putter> oh, and 30 classes.

[00:41] <pasteling> "evalbot_r15613" at 122.126.32.85 pasted "Pugs build failure" (277 lines, 18.1K) at http://sial.org/pbot/23430

[00:41] *** evalbot_r15613 joined
[00:42] <svnbot6> r15615 | audreyt++ | * Pugs.Types: Make Array elements truly bindable:

[00:42] <svnbot6> r15615 | audreyt++ |     my @x;

[00:42] <svnbot6> r15615 | audreyt++ |     @x[10] := 123;

[00:42] <svnbot6> r15615 | audreyt++ |     @x[10] = 5;     # can't assign into Int

[00:42] <svnbot6> r15615 | audreyt++ |   also make cloning an STM action rather than an Eval action.

[00:42] <audreyt> (Hashes were already bindable this way.)

[00:43] <svnbot6> r15616 | audreyt++ | * Change all liftSTM into stm and all liftIO into io.

[00:44] *** Psyche^_ is now known as Patterner

[00:44] *** Schwern joined
[00:44] <audreyt> allbery_b: feel free to smoke now :)

[00:44] * audreyt goes to sleep and prays that evalbot can resurface in ~20mins

[00:46] *** stevan__ joined
[00:46] <svnbot6> r15617 | audreyt++ | * regen instances.

[00:48] <pasteling> "evalbot_r15617" at 122.126.32.85 pasted "Pugs build failure" (217 lines, 14.4K) at http://sial.org/pbot/23431

[00:50] *** evalbot_r15617 joined
[00:50] <audreyt> ?eval 1

[00:50] <audreyt> :/

[00:50] <moritz_> I guess evalbot needs a "make clean"

[00:50] <moritz_> anyway, bed++

[00:50] <audreyt> no, that was because INIT blocks are broken

[00:50] <allbery_b> hm

[00:51] *** eric_ is now known as forsaken

[00:51] <putter> evalbot being absent for a day will simply make us appreciate it all the more when it comes back.

[00:51] * allbery_b notes that he isn't exactly sitting around waiting

[00:51] *** evalbot_r15617 joined
[00:51] <audreyt> ?eval 1

[00:52] *** explorer joined
[00:56] <svnbot6> r15618 | audreyt++ | * evalbot.pl: rather than fix pugs's INIT block, let's use a

[00:56] <svnbot6> r15618 | audreyt++ |   state variable now to workaround it...

[00:58] <svnbot6> r15619 | audreyt++ | * Pugs.Parser: fix CHECK and INIT block anyway.

[00:58] * allbery_b hits the button and goes back to Pesach cleaning...

[01:01] *** ozo_ left
[01:01] *** ozo_ joined
[01:05] *** nipotaway is now known as nipotan

[01:07] <audreyt> zzz for real &

[01:18] <pasteling> "evalbot_r15619" at 194.145.200.126 pasted "Pugs build failure" (425 lines, 25K) at http://sial.org/pbot/23432

[01:19] *** evalbot_r15619 joined
[01:19] <allbery_b> needs make clean, I believe

[01:26] <rhr> Arathorn: it still seems to me that a named pointy block does just what you want.  my &abort_and_log := -> Str $svmsg, Str $clmsg { log_to_server($svmsg); log_to_client($clmsg); etc; return; } open ... err abort_and_log "blah", "blah";

[01:30] <Arathorn> is there any advantage to that over a plain old subroutine, though?

[01:30] <rhr> pointy is transparent to return

[01:31] <Arathorn> ah, ok

[01:31] <rhr> so it return from the caller

[01:31] * Arathorn nods.

[01:32] <Arathorn> still, it isn't very concise.  I guess i just expected 0 err { foo; bar; baz } to work, without having to () the block

[01:33] <rhr> I had the same question here a week or two ago :)

[01:48] *** kanru joined
[02:02] *** jisom joined
[02:06] <allbery_b> yay new pugs!  smoking...

[02:07] <allbery_b> (btw creating JS prelude throws an error...)

[02:21] *** dmq joined
[02:32] *** mjk joined
[02:45] *** b00t joined
[02:51] *** mako132_ joined
[02:54] *** dolmans joined
[03:19] *** dvorak_ joined
[03:38] *** mako132_ joined
[03:55] *** SCalimlim joined
[04:06] *** Aankhen`` joined
[04:11] *** forsaken joined
[04:39] * avar ponders re::engine::PCR v.s. re::engine::Pugs::Compiler::Rule; 

[04:52] *** Schwern joined
[04:53] <obra> RE::Engine::PugsRule?

[04:54] <avar> perhaps....:)

[04:54] *** amnesiac joined
[04:54] <avar> I'm leaning towards PCR, easy to swap it out for PGE, typing wise:)

[04:55] <obra> nod

[04:57] <avar> I got captures working in re::engine::Plugin, well, numbered captures

[04:57] <avar> $re->captures( [ qw(a o e u) ] ); :)

[04:58] <avar> going to do $re->captures( sub { my ($re, $num) } ); too I guess, 

[04:58] <avar> $5000 would call sub { my ($re, $num }->($re, 5000) :)

[04:58] *** Schwern joined
[05:35] *** Psyche^ joined
[05:41] *** Psyche^_ joined
[05:48] *** nipotan is now known as nipotaway

[05:48] *** Psyche^_ is now known as Patterner

[06:14] *** BooK_ joined
[06:43] *** iblechbot joined
[06:54] *** Psyche^ joined
[06:57] *** RHainsworth joined
[06:57] *** RHainsworth left
[06:57] *** elmex joined
[06:59] *** Psyche^_ joined
[07:00] *** Psyche^_ is now known as Patterner

[07:06] *** rfordinal joined
[07:14] *** euleron joined
[07:22] <meppl> guten morgen

[07:26] *** marmic joined
[07:43] *** DrSlump_2 joined
[07:47] *** Caleb1 joined
[07:47] <Caleb1> sup d00ds?

[07:47] <Caleb1> just here to tell you that perl is teh suck, and no l33t hax0rs use it

[07:50] *** Caleb1 left
[07:57] *** aukjan|gone is now known as aukjan

[08:02] <Schwern> I think we've made the big time.

[08:05] <audreyt> ?eval 1

[08:06] <evalbot_r15619> 1

[08:07] <shay> shit

[08:08] <shay> I'm going to delete perl now, I thought that it was l33t

[08:11] *** the_dormant joined
[08:11] <Schwern> It is merely elite.

[08:15] *** dec_ joined
[08:22] <svnbot6> r15620 | audreyt++ | * capture.t: unTODO.

[08:28] <svnbot6> r15621 | audreyt++ | * splat_rw.t: "sub f (*@x is rw)" is now specced to work, not to fail.

[08:28] <svnbot6> r15621 | audreyt++ |   Add smartlink and reverse the tests.

[08:31] <svnbot6> r15622 | audreyt++ | * multi_named_vs_pos.t: unTODO.

[08:46] <svnbot6> r15623 | audreyt++ | more unTODO.

[08:48] *** dec_ is now known as dec

[08:55] *** jisom joined
[08:56] *** jisom left
[08:57] *** jisom joined
[09:05] <svnbot6> r15624 | audreyt++ | * namespaces.t: unTODO; all passes.

[09:12] *** devogon joined
[09:21] <avar> audreyt: re::engine::Plugin has $re->captures( [ bless {} => "PCR" ] ); $1->( "hello world" ); working now # dmq++ :)

[09:21] <avar> audreyt: /w 19

[09:21] <avar> eek

[09:27] *** RHainsworth joined
[09:31] *** Jedai joined
[09:32] *** RHainsworth left
[09:38] *** beppu joined
[09:39] <audreyt> oooh

[09:41] *** Psyche^ joined
[09:42] *** IllvilJa joined
[09:43] <avar> use re::engine::Pugs::Compiler::Rule; if ("abc" =~ /((.).)./) { $&; $&->from; $&->to; $1; $1->[0]; }

[09:43] <avar> audreyt: or re::engine::PCR; what do you think?:)

[09:44] <svnbot6> r15625 | moritz++ | unTODOed several test files

[09:55] *** Psyche^ is now known as Patterner

[09:59] <ayrnieu> audreyt++ # your VB rocks! slideshow was a hit in ##C :-)

[10:00] <avar> mm, url?

[10:00] <ayrnieu> avar - http://feather.perl6.nl/~audreyt/osdc/vb.xul

[10:00] <avar> shorten that

[10:00] <avar> eek

[10:01] <ayrnieu> http://www.pugscode.org / see the link on the left-hand-side

[10:01] <lambdabot> Title: Pugs - pugscode

[10:02] *** polettix joined
[10:02] <avar> I just typed it:)

[10:03] <avar> wow, a html slideshow that doesn't suck:)

[10:03] <avar> made with some tool or handcoded?

[10:05] <ayrnieu> The other slideshows there are also quite good, but they are not HTML.

[10:30] *** ruoso joined
[10:54] <audreyt> avar: "view source" :)

[10:54] <audreyt> ayrnieu: ##C?

[10:55] <audreyt> avar: ::PCR sounds good. going to upload it on cpan? :D

[10:56] <avar> I'm going to keep it all for myself:)

[10:56] <avar> well, afte I get stuff working in ::Plugin well enough:)

[10:57] <audreyt> :D

[10:57] <audreyt> avar++ # most exciting

[10:58] <avar> it's just synatx sugar dear:)

[10:58] <avar> sugar++

[10:58] <avar> *syntax

[11:03] <specbot6> r14338 | audreyt++ | * formatting code consistency suggested by Daniel Hulme.

[11:07] <ayrnieu> audreyt - the C IRC channel, yes.

[11:07] <ayrnieu> audreyt - double-# for obscure Freenode reasons.

[11:08] <audreyt> ok...

[11:10] <avar> ayrnieu: the people on that channel suck:)

[11:11] <ayrnieu> well, a troll wanted to let us know that he really likes VB.  It's always better to take such people mostly as genuine, and to share good links like that.

[11:11] <avar> pedantic bastards:)

[11:11] <ayrnieu> avar - *nod*, I can only barely stand people who habit that channel.

[11:12] <avar> #hurd was worse though back in the day:)

[11:45] *** devogon joined
[11:45] <svnbot6> r15626 | fglock++ | PCR - more Unicode fixes; named_chars.t passes 411/419

[11:45] <svnbot6> r15626 | fglock++ | - added external/internal 'ignorecase' flag

[11:46] *** fglock joined
[11:51] *** Psyche^ joined
[11:53] *** Psyche^ is now known as Patterner

[12:10] *** weinig|bbl is now known as weinig

[12:18] *** diakopter joined
[12:43] *** rindolf joined
[12:46] *** araujo joined
[12:55] *** [particle] joined
[12:56] *** dec_ joined
[12:57] *** agentzh joined
[13:04] *** agentzh left
[13:13] *** the_dormant joined
[13:19] <svnbot6> r15627 | fglock++ | PCR - CPAN version 0.21

[13:39] *** Limbic_Region joined
[13:51] <avar> fglock: what's new?

[13:51] <avar> ah, ^^ commit;

[13:51] <audreyt> fglock: blog about it? :

[13:51] <audreyt> :)

[13:52] *** vel joined
[13:52] <clkao> mmmmm

[14:03] *** BooK joined
[14:11] <fglock> hi!

[14:11] <fglock> re new - better unicode support

[14:12] <svnbot6> r15628 | fglock++ | - added t/regex/capture_rollback.t (2 TODO tests)

[14:12] <avar> audreyt: pugs.blogs.com should be in svn:)

[14:13] <audreyt> avar: want to go about make that happen?

[14:13] <audreyt> atom<->svn bridge or something

[14:14] <avar> how about just storing the posts as POD?:)

[14:14] <audreyt> sure... :)

[14:15] <fglock> also, some internal fixes, such as operator precedence

[14:16] <fglock> audreyt: it there a way to access pugs variables from PCR?

[14:17] <fglock> also, to handle back closures for pugs to parse/compile

[14:17] <audreyt> fglock: give me an API and I'll make it happen

[14:18] <audreyt> fglock: currently all lexicals are passed in again for eval_perl5 bridge

[14:18] <fglock> I'd really like to have some way of making pads look like objects

[14:18] <audreyt> but globals are inaccessible

[14:18] <audreyt> is that good enough?

[14:18] <audreyt> ?eval my $x = 5; eval('$x', :lang<perl5>)

[14:19] *** evalbot_r15619 is now known as evalbot_r15628

[14:19] <evalbot_r15628> 5

[14:19] <audreyt> like that

[14:19] <moritz_> cool ;-)

[14:19] <fglock> ok! I'll make some tests

[14:19] *** buetow joined
[14:19] <audreyt> fglock++

[14:20] <audreyt> fglock: btw have you seen my new PadEntry layout?

[14:20] <audreyt> I intend to blog about it

[14:20] <audreyt> data PadEntry

[14:20] <audreyt>     = EntryLexical  { pe_type :: !Type, pe_proto :: !VRef, pe_store :: !(TVar VRef), pe_fresh :: !(TVar Bool) }

[14:20] <audreyt>     | EntryStatic   { pe_type :: !Type, pe_proto :: !VRef, pe_store :: !(TVar VRef) }

[14:20] <audreyt>     | EntryConstant { pe_type :: !Type, pe_proto :: !VRef }

[14:20] <audreyt> basicaly there are three kinds of entries: refreshable, nonrefreshable, and nonbindable (and thus nonrefreshable)

[14:21] <audreyt> all of them carries a type constraint, and a compile-time-object that is the "proto" object

[14:21] <audreyt> for example, "my $x is Scalar" carries the proto of Scalar.new

[14:21] <audreyt> but the proto is determined when compilatino of that scope ends, so if you have

[14:21] <audreyt> "{ my $x is Scalar; BEGIN { $x = 3 } }"

[14:22] <audreyt> then each time that scope is entered, a fresh Scalar.new(Int(3)) is cloned

[14:22] <audreyt> (except for the first time; the "fresh" slot in Lexical pad tracks that)

[14:23] <audreyt> I find this layout much saner than the old Cell layout

[14:23] <audreyt> and maybe helpful to kp6 (which does not yet have Static/Constant layouts)

[14:23] <audreyt> </rant>

[14:24] <fglock> re API: currently it works like this: the p6 compiler overrides the definition of the 'Pugs::Grammar::Rule.parsed_code' rule; and the backends call a hardcoded 'Perl6.emit' sub if '$Pugs::Compiler::Perl6::VERSION' is defined

[14:26] <fglock> re kp6: the current problem in p5-land is that ':=' just calls perl5 '=', without type-checking

[14:26] *** breakeven joined
[14:27] <fglock> I'd like to discuss kp6 when you have some time - I'm not happy with the architecture yet

[14:27] <fglock> kp6 is almost building a VM on top of p5

[14:29] <fglock> mm - no Cell?

[14:30] <fglock> is tieing supported?

[14:31] <fglock> probably by defining new role methods for FETCH, etc?

[14:32] <audreyt> well, tieing is simply binding 

[14:33] <fglock> to a proxy var

[14:33] <audreyt> the tieable role simply lifts the type constraint in pe_type

[14:33] <audreyt> yes.

[14:38] <fglock> mm - I'd like to port lazy arrays to Haskell if I could

[14:38] * smash greetings

[14:45] <smash> so, what's new in haskell land ?

[14:49] *** DrSlump joined
[14:50] <DrSlump> hi

[14:52] <audreyt> smash: perl5 bridge converted to MO (with .HOW etc); "constant" and "state" declarators for vars and subs; much more accurate multi dispatch coming up next

[15:02] *** cognominal joined
[15:03] <smash> audreyt: writing in haskell ?

[15:07] <ajs_> fglock, I dunno if you were around to see http://sial.org/pbot/23398 but it looks like it was a problem with escapes in rule-embedded code with quoting

[15:07] <lambdabot> Title: Paste #23398 from "ajs" at 63.107.91.99

[15:10] <audreyt> smash: yeah

[15:11] *** iblechbot joined
[15:11] <smash> audreyt: nice, anything specific i can help with ? i miss writing code in haskell

[15:14] <audreyt> smash: ooh. let's see...

[15:14] *** aukjan is now known as aukjan|gone

[15:16] <audreyt> smash: write me a function that checks if a Capture can bind to a Signature?

[15:16] <audreyt> or checks two Signatures against a Capture to determine which one is closer to it

[15:16] *** ProperNoun joined
[15:17] <audreyt> smash: the Sig data type is in src/Pugs/Val/Code.hs line 73

[15:17] <audreyt> the CaptVal data type is in Pugs.Val.Capture

[15:17] <audreyt> see if they make sense to you?

[15:18] <audreyt> the algorithm is S06:338

[15:19] <smash> let me update first

[15:20] <audreyt> alternately... write a unifier for two Signature to find the common Signature that can bind to both

[15:20] <audreyt> for example

[15:21] <audreyt> ($x, $y) and ($x, $y, $z) should unify to ($x, $y, $z?)

[15:21] <ajs_> Another thing I've run into is "our" scoped variables don't appear to be available to <$foo> inside regexen

[15:21] <pasteling> "ajs_" at 63.107.91.99 pasted ""our" scope not available to regex" (4 lines, 65B) at http://sial.org/pbot/23441

[15:21] <ajs_> in v6 that is

[15:22] <ajs_> change the "our" to "my" and it works fine

[15:22] <audreyt> the idea is that if a Capture is incompatible with the unified sig, then it has no chance of binding to any of the original sigs

[15:33] <smash> audreyt: where's the algorithm gain ?

[15:34] <smash> s/gain/again/

[15:36] <audreyt> smash: an older version of the binding/compatible algorithm is src/Pugs/Bind.hs

[15:36] <audreyt> smash: the spec is in S06

[15:36] <audreyt> line 338

[15:59] *** diakopter joined
[16:07] *** lichtkind joined
[16:08] <lichtkind> are there any attempts to rewrite MAD for Partidge ?

[16:18] *** wilx` joined
[16:22] *** fglock joined
[16:23] <fglock> ajs_: checking...

[16:29] *** drupek12 joined
[16:34] *** forsaken joined
[16:35] <fglock> _ajs: re backslash: interpolating quotes in v6.pm are unfinished; single quotes parse: '\\'

[16:35] *** rashakil_ joined
[16:36] <fglock> _ajs: but after it parses, there are more problems...

[16:36] *** mj41 joined
[16:39] <fglock> _ajs: re 2nd paste, that's an error in v6.pm emitter; compiled rules should be inlined

[16:39] *** chris2_ joined
[16:40] *** chris2_ is now known as chris2

[16:41] <fglock> mm - last v6.pm release was on my birthday

[16:41] <clkao> whoot

[16:50] <avar> audreyt: I forget, did you have co-maint or maint on re::engine::PCRE?

[16:51] <fglock> does it make sense to write $somelang emitters for pugs yaml dumps?

[16:53] <avar> yaml dumps of what? the parse tree?

[16:55] <fglock> avar: pugs can dump compiled code to yaml; I don't know if it's the parse tree

[16:56] *** Southen_ joined
[16:56] *** justatheory joined
[16:56] <avar> like what $somelang?

[16:56] <fglock> avar: C, C++, Perl5

[16:57] <fglock> current kp6 possible targets

[16:57] <avar> ooh:)

[16:58] <avar> how do you run kp6?

[16:58] <PerlJam> fglock: sounds interesting.

[16:59] <svnbot6> r15629 | fglock++ | PCR - added TODO tests;

[17:00] <svnbot6> r15629 | fglock++ | - defined Base::Grammar::DESTROY to avoid autoloading it

[17:00] <fglock> avar: there is some code in v6/v6-KindaPerl6, but it's not really runnable yet - needs runtime libs and such

[17:01] *** forsaken joined
[17:02] <fglock> emitters are lightweight enough to be run from pugs

[17:10] <fglock> otoh, a native compiler is still needed to execute eval blocks

[17:15] <fglock> I wonder if pugs 6.283 will compile rules to haskell

[17:26] <pasteling> "fglock" at 201.54.129.80 pasted "pugs parsefail, trying to parse the PCR rule grammar" (9 lines, 230B) at http://sial.org/pbot/23442

[17:31] <audreyt> fglock: are you using latin1?

[17:31] <audreyt> yes you are. bad idea

[17:32] <audreyt> fixed

[17:34] <svnbot6> r15630 | audreyt++ | * Rule2.pm: use utf8;

[17:37] <fglock> audreyt: thanks!

[17:38] <audreyt> :)

[17:40] <fglock> pugs: *** Can't locate utf8.pm in @*INC ...

[17:40] <audreyt> well, that's hardly exciting...

[17:41] <gaal> rehi

[17:41] <TimToady> hi gaal

[17:41] <audreyt> fglock: create a stub utf8.pm for now?

[17:41] <fglock> audreyt: ok

[17:42] <gaal> hey :) audreyt, any moose I can moose?

[17:42] <fglock> audreyt: isn't utf8 the default?

[17:42] <TimToady> fglock, do you have any automated way to unTODO the passing regex tests?

[17:43] <audreyt> gaal: yes, I need a Signature unifier

[17:43] <fglock> TimToady: no, sorry

[17:43] <audreyt> and a Signature/Capture compat checker

[17:43] <gaal> what's Sig unification?

[17:43] <audreyt> then VCode can switch to use newsig instead of [Param]

[17:43] <gaal> :(Int $x) <=> :(Num $x) ?

[17:44] <audreyt> property: give two Sig, produce a Sig that, if a Capt can't be bound to it, then it can't be bound to the orig two

[17:44] <audreyt> given that property, of course a legit implementation is simply return :(|$)

[17:44] <audreyt> but try to do better than that :)

[17:45] <gaal> unify :: Sig -> Sig -> Capt -> Sig ?

[17:45] <audreyt> no

[17:45] <audreyt> instance Monoid Signature where

[17:45] <audreyt>     mappend :: Sig -> Sig -> Sig

[17:45] <gaal> give me a frinstance with sigs?

[17:45] <audreyt> it's not Capt related

[17:45] <audreyt> :($x) `mappend` :($x, $y) = :($x, $y?)

[17:45] <audreyt> :(Int $x) `mappend` :(Str $y) = :(Int|Str $y)

[17:46] <audreyt> :($x is rw) `mappend` :($x) = :($x is rw)

[17:46] <gaal> :($x) `mappend` :($x) => :($x) yes?

[17:46] <audreyt> sure

[17:46] <gaal> what about code constraints?

[17:46] <gaal> simple addition?

[17:46] <gaal> where $c1 where $c2 ?

[17:46] <audreyt> use | semantics

[17:46] <audreyt> no

[17:47] <obra>   B/win 75

[17:47] <audreyt> where $c1|$c2

[17:47] <audreyt> or just drop the where

[17:47] <audreyt> probably wise to drop

[17:47] <audreyt> we are not required to be gcd

[17:47] <audreyt> just some cd

[17:47] <TimToady> fglock: don't apologize, just keep an eye out for a minion/cagecleaner to do it.  :)

[17:47] <gaal> I'm not even sure ValSig expresses junctions now?

[17:47] <audreyt> so just drop it :)

[17:48] <TimToady> any minions/cagecleaners listening in, feel free to volunteer...

[17:48] <gaal> k :) I'll write some algebraic rules first and nopaste them for review

[17:48] <audreyt> moose!

[17:48] <gaal> I've always been of that opinion, yes

[17:48] <TimToady> there's >2000 todos that can be unTODO'd with a bit of automation

[17:49] <[particle]> you keep pugs in a cage? HOW CRUEL!

[17:49] <fglock> pugs -Iext/Test/lib  t/regex/p6regex/p6regex.t | grep '^ok' | grep TODO | perl -ne ' print ", $1" if /(\d+)/ '

[17:49] <TimToady> if there are no minions/cagecleaners, a fawning sycophant would do...

[17:50] <gaal> audreyt: are there any cases where mappend is not commutative here?

[17:51] <audreyt> TimToady: do onlies install shortnames?

[17:51] <audreyt> er, longnames

[17:51] <audreyt> gaal: shouldn't be 

[17:51] <gaal> cool

[17:51] <TimToady> onlies hide all outer longnames

[17:51] <audreyt> sub f () { 3 }

[17:51] <audreyt> &f:()();

[17:51] <audreyt> kosher?

[17:52] <TimToady> why not, just a set that happens to contain one member?

[17:52] <audreyt> k.

[17:53] <audreyt> but it's the same pad entry?

[17:53] <TimToady> sort of proto f is override

[17:53] <audreyt> i.e. if I rebind one, the other gets rebound?

[17:53] <audreyt> &f vs &f:()

[17:53] <TimToady> hmm

[17:54] <TimToady> question is whether :() does PDLish slice or a "copy"

[17:55] <audreyt> well, currently it goes like this

[17:55] <audreyt> multi f () { 3 }

[17:55] <audreyt> we already said that &f and &f:() are distinct entities

[17:55] <audreyt> you can &f.wrap which does not touch &f:()

[17:55] <audreyt>  if &f:() gets rebound, &f chases it

[17:55] <audreyt> but not the other way around

[17:56] <audreyt> question is if onlies work like that. I think I prefer that its shortname/longname is actually the same entry

[17:56] <TimToady> If that makes it simpler, I guess I'm okay with it

[17:56] <TimToady> probably dwimmier that way

[17:57] <TimToady> and maybe -Oier

[17:57] <audreyt> yeah. also saves pad storage a lot

[17:57] <audreyt> k.

[17:58] <audreyt> does

[17:58] <audreyt> $f:(Int, Int)

[17:58] <audreyt> mean anything at all?

[17:58] <audreyt> (the previous line might have been "$f := &f")

[17:59] <audreyt> as in, could it be a legit syntax?

[17:59] <audreyt> and also if I import a $f that is bound to a multi, and I have a local $f that is bound to a multi, do they unify?

[17:59] <audreyt> (current pugs say "yes" to all above)

[17:59] <audreyt> i.e. it's sigil-invariant

[18:03] <TimToady> hmm, it tends to violate the adverb-applied to infix contract

[18:03] <TimToady> $a op $b :() should apply to op

[18:04] *** ayrnieu joined
[18:04] <TimToady> and I'm thinking of &foo:() as a single token

[18:04] <TimToady> but maybe our ident:() forms trump that

[18:04] <TimToady> on the other hand, if we generalize ident:() forms that far, then

[18:05] <TimToady> 1..$x:by(2) is in trouble

[18:05] <TimToady> and would have to be written 1..$x :by(2)

[18:05] <audreyt> but then

[18:05] <audreyt> 1..&x:by(2)

[18:05] <audreyt> 1..$x:by(2)

[18:06] <audreyt> parses differently is weird, too

[18:06] <moritz_> is the name "pugs" officially lower case?

[18:06] <audreyt> or does it?

[18:06] * diakopter notes that Tim*Toady* used the word sycophant.

[18:06] <audreyt> moritz_: it's officially whatever case, up and including PUGS

[18:06] <moritz_> pUGs ;-)

[18:06] <audreyt> or that, yes.

[18:07] <ayrnieu> I always evangelize this project as pUgS

[18:07] <moritz_> that looks UgLy

[18:08] <audreyt> or Ｐｕｇｓ

[18:11] <obra> I'm so glad I finally shaved the unicode in irc yak.

[18:11] <svnbot6> r15631 | gaal++ | * Signature Monoid instance algebra for review

[18:11] <obra> It makes #perl6 so much more worthwhile

[18:11] <audreyt> wow that was quick

[18:11] *** ajs_ joined
[18:11] <audreyt> obra++

[18:11] <fglock> many tests in p6regex.t give error messages, but succeed - is it ok to unTODO for now?

[18:11] <obra> TimToady++ # most of the useful bits

[18:12] <obra> TimToady++ # for utf8 IRC, but also, for Just about everything else.

[18:12] <gaal> TimToady, audreyt, please review misc/pX/gaal/SigMonoid.lhs

[18:13] <lichtkind> is it true that MAD is written in haskell too?

[18:13] <ajs_> fglock, thanks for looking at those regex issues

[18:13] <gaal> (lhs in vain, I probably won't be able to rip out data Sig from Pugs.Val)

[18:16] <audreyt> k. let me finish checking in longnames...

[18:18] *** dec joined
[18:19] <fglock> ajs_: I'm rethinking v6.pm (and kp6); trying to find out which projects should be maintaned or closed

[18:20] <audreyt> TimToady: infix:<..> is nonassoc?

[18:20] <audreyt> nvm it is

[18:22] <gaal> does unpacking work with structural typing? ie, is this legal? :($t (Left $l, Right $r))

[18:22] <svnbot6> r15632 | gaal++ | * add unpacking case

[18:22] <svnbot6> r15633 | fglock++ | p6regex.t - unTODO all 'ok', even if there were error messages

[18:23] <gaal> or does it require a BinTree static constraint?

[18:23] <audreyt> I think they are orthogonal

[18:23] <gaal> cool. :-)

[18:26] <ajs_> fglock, as long as the future holds a Perl5-based Perl 6 to use for transition, I don't think it matters what it's called. v6 has certainly taught everyone a lot.

[18:26] <fglock> ajs_: :)

[18:27] *** jisom joined
[18:28] *** jisom left
[18:28] *** jisom joined
[18:33] <gaal> audreyt, do you have a commit pending? I've a Makefile.PL fix but it can wait.

[18:33] <audreyt> please commit

[18:36] <svnbot6> r15634 | gaal++ | * Never attempt debugging builds when compiling with GHC 6.6.

[18:40] <audreyt> ok, longnames done.

[18:40] <gaal> whee

[18:42] *** Aankhen`` joined
[18:43] <svnbot6> r15635 | audreyt++ | * Pugs.Types: Introduce "v_longname" field to Var;

[18:43] <svnbot6> r15635 | audreyt++ |   its parsing rule is looking for ":(" in the string.

[18:44] <svnbot6> r15635 | audreyt++ |     &::('skip()')

[18:44] <svnbot6> r15635 | audreyt++ |   Currently, no canonization attempt is made.

[18:44] <Aankhen``> Why is it looking for sad faces? :-(

[18:44] <audreyt> (that means &::('skip(    )') will lookup sail)

[18:44] <audreyt> lol

[18:44] <audreyt> er, skip:() and skip:(   ) respectively above

[18:46] <fglock> TimToady: re automatic: grep + Set::Infinite works :)

[18:46] <gaal> audreyt: missing SCodeMulti export in Pugs.AST.Utils

[18:46] <gaal> er, import

[18:46] <svnbot6> r15636 | audreyt++ | * Pugs.Val.Code: Restore Show instance for Sig.

[18:47] <audreyt> SCodeMluti is no more.

[18:47] <svnbot6> r15637 | fglock++ | t/regex/from_perl6_rules/properties.t - unTODO a thousand tests

[18:47] <TimToady> fglock: :)

[18:48] <svnbot6> r15638 | audreyt++ | * Pugs.AST.Internals: VMultiCode now holds a map from longname

[18:48] <svnbot6> r15638 | audreyt++ |   to variants, instead of an array of variants, to guarantee

[18:48] <svnbot6> r15638 | audreyt++ |   that longnames are unique.

[18:48] <svnbot6> r15639 | audreyt++ | * Pugs.AST.Utils: SCodeMulti is no more.

[18:49] <gaal> audreyt: chase into Pugs.AST.Pad too

[18:50] <audreyt> gaal: wait 3min

[18:50] <gaal> lol you're too fast as usual :)

[18:50] <audreyt> commit is slow :)

[18:50] <svnbot6> r15640 | audreyt++ | regen instances.

[18:50] <svnbot6> r15641 | audreyt++ | * Pugs.AST.Pad: Since SCodeMulti is no more, merge

[18:50] <svnbot6> r15641 | audreyt++ |   multi entries by content, not by type.  That means

[18:50] <svnbot6> r15641 | audreyt++ |   if two "my $f" in nested scopes happens to be bound

[18:50] <gaal> it's in already; svnbot6 polleth slow

[18:50] <svnbot6> r15641 | audreyt++ |   to multi selector protosubs, they gets unified.

[18:50] <pasteling> "evalbot_r15634" at 194.145.200.126 pasted "Pugs build failure" (394 lines, 21.3K) at http://sial.org/pbot/23446

[18:51] <svnbot6> r15642 | audreyt++ | * Pugs.AST: All longnames now implicitly create shortname

[18:51] <svnbot6> r15642 | audreyt++ |   protodispatchers if one is not already in scope.

[18:53] <audreyt> r15643 should build.

[18:53] <svnbot6> r15643 | audreyt++ | * Pugs.Parser: Parse for longname forms:

[18:53] <svnbot6> r15643 | audreyt++ |     &f:($x, $y)

[18:53] <svnbot6> r15643 | audreyt++ |   The signature part is canonicalized correctly here.

[18:53] <svnbot6> r15643 | audreyt++ |   Also make exporting selective multi variants work.

[18:53] <svnbot6> r15644 | audreyt++ | * Pugs.Parser.Operator: multi longnames should not affect

[18:53] <svnbot6> r15644 | audreyt++ |   the operator precedence table; we let the proto do that.

[18:53] <audreyt> er, r15645.

[18:54] <svnbot6> r15645 | audreyt++ | * Eliminate SCodeMulti in all other places.

[18:54] <svnbot6> r15645 | audreyt++ |   This concludes the longname batch.

[18:54] <audreyt> looking at monoid now...

[19:02] *** jisom_ joined
[19:03] <audreyt> checked in some fix

[19:03] <gaal> looking

[19:04] <gaal> okay, thanks

[19:05] <svnbot6> r15646 | audreyt++ | * SigMonoid: some clarifications

[19:05] <gaal> oh, :($x?) :+: :($x = 42) is ($x?), right?

[19:05] <gaal> (and thus, :($x) :+: :($x = 42) is, too?)

[19:07] <gaal> :($)         :+:  :($)                 = :($x)

[19:08] <gaal> the "x" isn't invented there, is it?

[19:08] <gaal> and: is this really correct?

[19:08] <gaal> :($x)        :+:  :($y?)               = :($x, $y?)

[19:08] <gaal> because if it is, why is this correct?

[19:08] <gaal> :(:$elk)     :+:  :(:$caribou)         = fail "incompat"

[19:09] <svnbot6> r15647 | gabriele++ | 99problems lispish solution for #56

[19:09] <svnbot6> r15648 | fglock++ | t/regex/from_perl6_rules/propcharset.t - unTODO

[19:09] <audreyt> er

[19:09] <audreyt> sorry that was typo

[19:09] <audreyt> :($) + :($x) = :($x)

[19:10] <gaal> fixed

[19:10] <audreyt> :($x) :+: :($y?) is surely incompat. sorry

[19:10] <gaal> okay

[19:11] <gaal> is the slurpy ne mandatory presumption good?

[19:12] <audreyt> aye

[19:12] <audreyt> although

[19:13] <audreyt> :(*$x) vs :($x)   # should probably unify to :($x is rw)

[19:13] <audreyt> but not sure about that.

[19:13] <audreyt> :(*$y) vs :($x) # too

[19:13] <gaal> hmmm

[19:13] <gaal> ok I don't understand why :)

[19:13] <audreyt> the idea is that once you have the lvalue

[19:14] <audreyt> you can call .ITEM or .LIST to get either context

[19:14] <audreyt> but that may be too weird.

[19:14] <svnbot6> r15649 | gaal++ | * SigMonoid: some fixes

[19:14] <audreyt> maybe just unify to incompat...

[19:14] <gaal> ok, this'll give us a first approx.

[19:14] <gaal> brb

[19:17] <devbot6> dev: WikiStart edited by audreyt <http://dev.pugscode.org/wiki/WikiStart>

[19:18] <gaal> you know, I'm not sure splittin SigMethSingle and SigSubSingle was such a win

[19:20] <audreyt> it surely is not

[19:21] <gaal> undoing then.

[19:23] *** IllvilJa joined
[19:30] <svnbot6> r15650 | gaal++ | * the compiler says it doesn't need {-# SOURCE #-} here, so remove it

[19:37] <fglock> hmm - Perl6::Rules fails many more tests in 5.9.4 than in 5.8.8

[19:37] *** forsaken joined
[19:38] <moritz_> shoudn't the 5.* releases be backwards compatible?

[19:38] <ayrnieu> yes, they should.

[19:39] <fglock> moritz_: Perl6::Rules is experimental; but I wonder if it should fails less tests

[19:40] <ayrnieu> Perl6::Bible on CPAN comes from Feb2006 -- were can I find the working copy?

[19:40] <svnbot6> r15651 | gaal++ | * unify the two Sig constructors to one with a Maybe invocant.

[19:43] <audreyt> ayrnieu: http://spec.pugscode.org/

[19:43] <lambdabot> Title: Official Perl 6 Documentation

[19:43] <audreyt> ayrnieu: also http://svn.perl.org/perl6/doc/trunk/design/syn

[19:43] <lambdabot> Title: Revision 14338: /doc/trunk/design/syn

[19:44] <ayrnieu> cool, thanks

[19:46] <gaal> audreyt: did you encounter a ghci random borkage where :r throws the following error:

[19:46] <gaal> Overlapping instances for (:>:) Pugs.Types.VStr String

[19:46] <devbot6> dev: SummerOfCodeIdeas edited by audreyt <http://dev.pugscode.org/wiki/SummerOfCodeIdeas>

[19:47] <audreyt> gaal: I did not... hm

[19:47] <gaal> somewhere in Pugs.AST.Eval

[19:47] <gaal> it's totally bogus, it sees Pugs.Internals.Cast's instance twice

[19:47] <audreyt> I did encouter something like that

[19:47] <audreyt> but only with a lot of :r

[19:47] <audreyt> so it's rare

[19:48] <gaal> :rare

[19:48] <gaal> k, moving along...

[19:48] <gaal> s_invocant sigZero = Nothing, yes?

[19:49] <audreyt> sure

[19:49] *** Loro joined
[19:51] *** Loro joined
[19:51] <gaal> @index Monoid

[19:51] <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS

[19:52] <gaal> ahh heh, I meant s/Zero/Empty/. say "I will read the entire error message" xx $blackboard

[19:54] <gaal> .oO( now all those ADTs that have a constructor called "empty" allude to instantiating Monoid....)

[19:56] *** euleron is now known as AZTEK

[19:57] *** AZTEK is now known as rononovski

[20:00] <gaal> how to express mappend failure?

[20:00] <gaal> 'error' would be very bad.

[20:00] <gaal> is this really a monoid if it's not closed on append?

[20:00] <meppl> good night

[20:00] <audreyt> gaal: maybe we blindly uinfy to (|$).

[20:00] <audreyt> *unify

[20:01] <gaal> "sigBogus"

[20:01] <audreyt> "sigWhatever"

[20:01] <gaal> what's the MkSig for that?

[20:02] <gaal> Is Sig currently experssive enough for it?

[20:02] <gaal> oh, s_slurpyCapture?

[20:02] <audreyt> yeah.

[20:02] <audreyt> and mempty for all other slots

[20:04] <gaal> ok. |$'s p_variable, is it simply '$'? does it need a p_types?

[20:04] <audreyt> nay

[20:04] <audreyt> [] is another word for Any

[20:05] <gaal> cool.

[20:06] <ayrnieu> eval: say "I will read" xx 2

[20:06] <buubot> ayrnieu: String found where operator expected at eval line 1, near "#line 1 eval       say "I will read""  (Missing operator before "I will read"?) Bareword found where operator expected at eval line 

[20:06] <ayrnieu> ?eval say "I will read" xx 2

[20:07] *** evalbot_r15628 is now known as evalbot_r15645

[20:07] <evalbot_r15645> user error (Incompatible version number for compilation unit␤Consider removing blib6/lib/Prelude.pm.yml and make it again␤)␤pugs: user error (*** *** Can't modify constant item: VUndef␤        at <prelude> line 781, column 9-46␤           <prelude> line 781, column 9-46␤    at)␤

[20:07] <moritz_>  ?eval say "I will read" x 2

[20:08] <moritz_> ?eval say "I will read" x 2

[20:08] <ayrnieu> er, well, in the 'Use Pugs Now -- in your browser', say "s" xx 2 # gave me output of just "ss\n"; should it be "s\ns\n" ?

[20:09] <moritz_> ayrnieu: no, it should not

[20:09] <moritz_> ayrnieu: because the arguments of a functions are processed, and then the function is called

[20:09] <evalbot_r15645> pugs: user error (*** *** Can't modify constant item: VUndef␤        at <prelude> line 781, column 9-46␤           <prelude> line 781, column 9-46␤    at)␤

[20:10] <audreyt> repairing evalbot.

[20:10] <ayrnieu> moritz - uh, sure, then: shouldn't this give me "s\ns\n"?  say ["s", "s"] 

[20:11] <ayrnieu> rather: say ("s", "s")

[20:11] <moritz_> no

[20:11] <moritz_> "say" only adds a newline once

[20:11] <moritz_> you might want print "s\n" x 2

[20:12] <ayrnieu> Yes, I realize that I can do this in other ways.

[20:12] <moritz_> but timtowtdi ;-)

[20:13] <ayrnieu> not in this case.

[20:13] <moritz_> ?eval for (1 xx 2) {say "s"}

[20:14] <evalbot_r15645> pugs: user error (*** *** Can't modify constant item: VUndef␤        at <prelude> line 781, column 9-46␤           <prelude> line 781, column 9-46␤    at)␤

[20:14] <moritz_> ?eval for (1 .. 2) {say "s"}

[20:14] <evalbot_r15645> pugs: user error (*** *** Can't modify constant item: VUndef␤        at <prelude> line 781, column 9-46␤           <prelude> line 781, column 9-46␤    at)␤

[20:15] <ayrnieu> Sorry, what I mean is that 'say' seems oddly limited in usefulness.

[20:15] <ayrnieu> but, if this is defined, fine.  I just thought it weird in the browser.

[20:16] <audreyt> ("ss" xx 2).>>say # that works

[20:17] <moritz_> ayrnieu: I'm pretty sure that this behaviour is intended

[20:17] <svnbot6> r15652 | audreyt++ | * Pugs.Types: Qualified names are never lexical.

[20:17] <moritz_> ayrnieu: and I like it that way

[20:17] <ayrnieu> moritz - why do you like it this way?

[20:17] <Limbic_Region> .seen diakopter

[20:17] <lambdabot> Limbic_Region: You have 1 new message. '/msg lambdabot @messages' to read it.

[20:17] <Limbic_Region> @moosages

[20:17] <lambdabot> putter said 1d 1h 18m 18s ago: draft donate language: http://colabti.de/irclogger/irclogger_log/perl6?date=2007-03-11,Sun&sel=409#l666

[20:18] <moritz_> ayrnieu: because in p5 I often wrote print $foo, $bar, $baz, "\n";

[20:18] <moritz_> ayrnieu: or print ..., $/;

[20:18] <audreyt> .say for 'ss' xx 2; # works too

[20:19] <Limbic_Region> isn't there a seen bot here?

[20:19] <audreyt> @seen Limbic_Region

[20:19] <lambdabot> Limbic_Region is in #perl6. I last heard Limbic_Region speak 6s ago.

[20:19] <Limbic_Region> @seen diakopter

[20:19] <lambdabot> I saw diakopter leaving #perl6 12m 47s ago, and .

[20:19] <ayrnieu> audreyt - do you need the . in that?

[20:19] <audreyt> ayrnieu: yes. otherwise it's just (say "")

[20:20] <audreyt> defaulting to $CALLER::_ made parsing much more unpredictable than what it's worth

[20:20] <audreyt> (plus you'd need to guess whether the API writer thought about adding $CALLER::_)

[20:20] <audreyt> so we eliminated them

[20:22] <gaal> audreyt: :($x?) :+: :(:$x?) -- do we perform this check?

[20:22] <Limbic_Region> @tell putter I like it.  I have some ideas and will be on later tonight.

[20:22] <lambdabot> Consider it noted.

[20:22] <audreyt> gaal: well, $x? is a legit unificiation

[20:22] <gaal> # clashing named and positional names

[20:22] <ayrnieu> moritz - thanks for that example -- I forgot that I also do that in Perl, ad kept comparing say to Ruby's puts

[20:22] <svnbot6> r15653 | audreyt++ | * Cipher: work around shortcomings in multi dispatch

[20:23] <gaal> so the named is fixed to a positional in this case?

[20:23] * ayrnieu waaits for machine to stop thrashing.  If it isn't the machine at the keyboard, it's the machine running the IRC client :-/

[20:23] <Limbic_Region> @tell diakopter my paypal connection didn't pan out so I would love to be able to send you a check for you to forward audreyt.  I will be around tonight if you are for details.

[20:23] <lambdabot> Consider it noted.

[20:24] <audreyt> gaal: sure, because \(x=>1) will always cause a tie

[20:24] *** ludan joined
[20:24] <audreyt> \(1) causes positional to win

[20:24] <audreyt> \() is another tie

[20:24] <audreyt> but it's legit, as parsing is consistent

[20:25] <gaal> yeah. okay :)

[20:25] <ludan> hi

[20:26] <audreyt> ludan: greetings

[20:26] *** BooK joined
[20:27] <svnbot6> r15654 | moritz++ | first very early version of donate.pugscode.org 

[20:27] <gaal> uh, p_variable    :: Var, which Var type is this now?

[20:28] <audreyt> smoketime should be much better now.

[20:28] <gaal> .. and what's its zero?

[20:28] <gaal> ooh

[20:28] <audreyt> gaal: it's the Var in Pugs.Types

[20:28] <audreyt> we unified that from CapInternals long ago

[20:29] <audreyt> its zero is varNullScalar

[20:29] <gaal> cool. does sigWhatever use varNullScalar?

[20:29] <gaal> }:)

[20:29] <audreyt> :D

[20:31] <gaal> huh? there's no xor in Prelude?

[20:31] <gaal> (hs)

[20:32] <specbot6> r14339 | larry++ | Various clarifications suggested by TheDamian++

[20:32] <svnbot6> r15655 | audreyt++ | * overloading.pl: Put explicit $_ in signature as it's required now.

[20:32] <specbot6> r14339 | larry++ | Explicit pipe target is now @(*) or @@(*).

[20:32] <specbot6> r14339 | larry++ | Separated clobbering <== ==> from pushy <<== and ==>>

[20:32] <specbot6> r14339 | larry++ | Pushy pipes can now be stacked on filters as well as sinks.

[20:32] <specbot6> r14339 | larry++ | $?BLOCK and other contexts now consistently return a list of labels.

[20:34] <[particle]> was single semi-colon replaced by double semi-colon in sigs?

[20:34] <[particle]> if so, cleanup on aisle 03!

[20:34] <audreyt> the trailing one, yes.

[20:34] <[particle]> +    for zip(@names; @codes) -> $name, $zip {

[20:35] <audreyt> no, not in calls

[20:35] <audreyt> calls wtill use single

[20:35] <audreyt> *still

[20:35] <[particle]> ah

[20:35] *** wilx joined
[20:35] <audreyt> double semis has nothing to do with callside singles

[20:36] <[particle]> haven't reread the spec recently, just skimming the commit logs

[20:36] <[particle]> so i'm a bit behind on syntax

[20:36] <audreyt> k

[20:39] <audreyt> I'll bbl...

[20:40] <svnbot6> r15656 | audreyt++ | * Pugs.Parser: Routines with no formal parameters but $_

[20:40] <svnbot6> r15656 | audreyt++ |   in scope should still default to (*@_):

[20:40] <svnbot6> r15656 | audreyt++ |     sub f { $_ };   # Signature is :(*@_), not :($_)

[20:41] *** larsen_ joined
[20:42] <audreyt> oh yay

[20:42] <audreyt> TheDamian++ # he remembered to kill the %hash:<a> form

[20:44] <svnbot6> r15657 | lwall++ | Clarify when say and print should complain about empty arglists.

[20:48] *** bernhard joined
[20:48] <ayrnieu> ow, the docss at that svn were a trap.

[20:48] <svnbot6> r15658 | audreyt++ | * donate: MIME type fixes.

[20:48] <audreyt> someone write some tests for r15657?

[20:50] <moritz_> audreyt: thanks (MIME)

[20:50] <audreyt> np :) 

[20:55] <svnbot6> r15659 | audreyt++ | * Pugs.Prim: unbreak &sort

[20:55] <audreyt> http://donate.pugscode.org/ now points to live svn data.

[20:56] <moritz_> audreyt: I don't think it's ready for a broad public right now ;-)

[20:56] <audreyt> neither do I :)

[20:57] <moritz_> as long as nothing links to it... ;-)

[20:57] <moritz_> .seen Limbic_Region

[20:57] <svnbot6> r15660 | audreyt++ | * arity.t: arity is a method, not a sub.

[20:57] <moritz_> @seen Limbic_Region

[20:57] <lambdabot> I saw Limbic_Region leaving #perl6 32m 33s ago, and .

[20:57] *** fglock left
[20:58] *** yts joined
[20:59] <moritz_> @tell Limbic_Region please add yourself to docs/feather/donate.pugscode.org/index.html as first donor as soon as you transfer the money (including name or nick (+link if you want), date, amount)

[20:59] <lambdabot> Consider it noted.

[20:59] <gaal> audreyt: sorry, I ran out of wakies..

[20:59] <svnbot6> r15661 | gaal++ | * SigMonoid: a few more rules, please review

[20:59] <svnbot6> r15661 | gaal++ | * Pugs.Val.Code: start of implementation

[21:00] <gaal> opt-floating, or -infecting, or whatever, is tricky. I added a few cases but I may have been wrong about them

[21:00] <gaal> I gotta sleep, can resume tomorrow.

[21:00] <audreyt> yay

[21:00] <gaal> moose

[21:01] *** offby1` joined
[21:01] <gaal> z&

[21:01] <rhr> typo in r14339: &ROUTINE.name should be &?ROUTINE.name

[21:02] <audreyt> fixed

[21:02] <rhr> am I crazy to want this to work? @x = gather while @x < $len { take foo if bar }

[21:03] <TimToady> already specced to work

[21:03] <rhr> :)

[21:03] <audreyt> don't we need := ?

[21:03] <TimToady> why?

[21:04] <audreyt> my @lines = =<>; # I thought it's eager here

[21:04] <audreyt> as opposed to := which maintains laziness

[21:04] <TimToady> he didn't ask for lazy...

[21:04] <audreyt> that example looks like laziness

[21:04] <rhr> out of curiosity, where does the spec mention this?

[21:05] <TimToady> S04:461

[21:05] <specbot6> r14340 | audreyt++ | * S02: typo spotted by rhr++

[21:05] <specbot6> r14341 | larry++ | Typos

[21:06] <audreyt> rhr: is the identical occurence of @x in both lhs and rhs intentional, so as to exercise laziness?

[21:07] <rhr> yes, it should be @x both places

[21:07] <svnbot6> r15662 | moritz++ | added inheritance test to pre_post.t

[21:07] <moritz_> can somebody please take a look at the last two tests in pre_post.t?

[21:07] *** marmic joined
[21:07] <moritz_> I'm not sure if I understood the Synopsis correctly

[21:08] <svnbot6> r15663 | audreyt++ | * Pugs.Parser: Repair "my @x = 1,2,3".

[21:08] <TimToady> okay, then yes, you need := for that gather to not be eager.

[21:09] <rhr> where can I get the raw Synopsis pod to find line numbers?

[21:09] <TimToady> the reuse of @x is rather subtle there...

[21:09] <rhr> TimToady: ok

[21:09] <TimToady> https://svn.perl.org/perl6/doc/trunk/design/syn

[21:09] *** Limbic_Region joined
[21:09] <TimToady> or for the ones under pugs

[21:09] <TimToady> http://svn.pugscode.org/pugs/docs/Perl6/Spec

[21:09] <lambdabot> Title: Revision 15663: /docs/Perl6/Spec

[21:10] <rhr> thanks.  I guess that just falls out of laziness then?

[21:11] <audreyt> yes.

[21:11] <rhr> cool

[21:11] <TimToady> and 9 developers out of 10 will shoot you if you use that construct. :)

[21:12] <rhr> heh

[21:12] <TimToady> at least, if you use it uncommented...

[21:12] *** explorer joined
[21:13] <Patterner> Do we want to know what the 10th does?

[21:14] <TimToady> no, but I believe it involves broomsticks

[21:14] <Patterner> Sounds more painful that a simple shot.

[21:21] <Limbic_Region> @seen audreyt

[21:21] <lambdabot> audreyt is in #haskell and #perl6. I last heard audreyt speak 10m 31s ago.

[21:21] <Limbic_Region> she go to sleep?

[21:21] <lambdabot> Limbic_Region: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:21] <Limbic_Region> @moosages

[21:21] <lambdabot> moritz_ said 22m 36s ago: please add yourself to docs/feather/donate.pugscode.org/index.html as first donor as soon as you transfer the money (including name or nick (+link if you want), date,

[21:21] <lambdabot> amount)

[21:22] <audreyt> Limbic_Region: hi.

[21:22] <audreyt> (about to sleep)

[21:22] <Limbic_Region> @tell moritz_ it is going to take some time, I need to send a check to diakopter who will then forward the money for me but will do

[21:22] <lambdabot> Consider it noted.

[21:22] <moritz_> re

[21:22] <lambdabot> moritz_: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:22] <moritz_> @moosages

[21:22] <lambdabot> Limbic_Region said 13s ago: it is going to take some time, I need to send a check to diakopter who will then forward the money for me but will do

[21:22] <Limbic_Region> audreyt - was just wondering if you are doing Win32 builds

[21:23] * Limbic_Region has had a hanging test for some time now

[21:23] <moritz_> Limbic_Region: no problem, just remember doing it

[21:23] <Limbic_Region> but as you were "away", I didn't bother with it

[21:23] <specbot6> r14342 | audreyt++ | * S06: Clarify that simple parenless form of declarators must

[21:23] <specbot6> r14342 | audreyt++ |   support list-context assignment.

[21:24] <audreyt> Limbic_Region: which one?

[21:24] <svnbot6> r15664 | audreyt++ | * defaults.t: unTODO; fix broken semi

[21:25] <svnbot6> r15665 | audreyt++ | * multi_named_vs_pos.t: unTODO

[21:25] <Limbic_Region> audreyt - I am running smoke now

[21:25] <Limbic_Region> audreyt - don't know how long it will take - so I will just @tell you

[21:25] <Limbic_Region> audreyt - so go to bed ;-)

[21:25] <audreyt> k

[21:25] <audreyt> moritz_: where is it said that PRE checks are inherited?

[21:25] <audreyt> moritz_: I thought it's associated with the block

[21:26] <audreyt> and if the parent does not get entered, the PRE should not fire

[21:26] <moritz_> audreyt: I thought I'd read it in the specs some time ago

[21:26] <moritz_> audreyt: but I may well be wrong

[21:26] <audreyt> you are right.

[21:27] <audreyt> but

[21:27] <audreyt> The precondition is satisfied if either the method's own C<PRE> block

[21:27] <audreyt> returns true, or I<all> of its parents' C<PRE> blocks return true.

[21:28] <moritz_> isn't that... very weird?

[21:28] <audreyt> it is

[21:28] <moritz_> because it means that if I inherit from a class I change its behaviour

[21:28] <audreyt> also that if it has no parents with PRE blocks, that the second clause worked voidly?

[21:28] <moritz_> the right thing would be to OR-ify all PRE blocks

[21:29] <moritz_> and to AND-ify als POST blocks

[21:29] <audreyt> I have no idea why they should be treated differently.

[21:29] <moritz_> read "Object Oriented Software COnstruction" by Betrand Meyer ;-)

[21:30] <audreyt> ok :)

[21:30] <moritz_> I can try to summarize it, but it will take a few minutes

[21:30] <audreyt> but then your test is still wrong

[21:30] <moritz_> yes

[21:30] <audreyt> so fix it :) and add a smartlink

[21:31] <moritz_> ok, soon

[21:31] <audreyt> with single inheritance chain, the spec algorithm is the same as OR all PRE blocks

[21:31] <moritz_> and who fixes the spec?

[21:31] <moritz_> ok

[21:31] <audreyt> the spec is written this way to accomodate for MI

[21:31] <audreyt> and it looks fine

[21:31] <moritz_> allright

[21:31] <moritz_> but I think it's not very clear

[21:32] <audreyt> it's terribly unclear :)

[21:32] <moritz_> that it refers to MI

[21:32] <audreyt> also does not deal with the case where parent has PRE but child does not

[21:33] <audreyt> so yeah, clarification would be cool, but I need to sleep :) 

[21:33] <audreyt> till tomorrow... &

[21:33] <TimToady> night

[21:33] <moritz_> then just the PRE of the parent should count

[21:33] <moritz_> night

[21:34] <TimToady> commuting &

[21:39] *** marmic joined
[21:44] *** diakopter joined
[21:46] <Limbic_Region> diakopoter ping

[21:46] <Limbic_Region> er

[21:46] <Limbic_Region> diakopter ping

[21:47] <diakopter> Limbic_Region: here.

[21:47] <lambdabot> diakopter: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:47] <Limbic_Region> well, I just send you a /msg

[21:47] <Limbic_Region> my paypal connection fell through so ....

[22:07] *** evalbot_r15652 joined
[22:14] *** offby1` is now known as offby1

[22:14] *** Psyche^ joined
[22:22] *** Psyche^ is now known as Patterner

[22:22] <svnbot6> r15666 | moritz++ | fixed broken pre_post.t test of inherited PREs

[22:36] <Limbic_Region> are the recent changes known to make pugs horribly slow or is there something else I should be concerned about?

[22:44] *** LimbicRegion joined
[22:45] *** LimbicRegion is now known as Limbic_Region

[23:11] *** meppl joined
[23:13] *** gnuvince` joined
[23:13] <specbot6> r14343 | larry++ | Added the KitchenSink role.

[23:13] <specbot6> r14343 | larry++ | Fiddle the feed operators to work better with files and such.

[23:14] *** gnuvince` joined
[23:15] *** polettix joined
[23:20] <svnbot6> r15667 | audreyt++ | * chained.t: update declarator list.

[23:21] *** miyagawa joined
[23:21] <Limbic_Region> @tell audreyt Win32 is no longer hanging on smoke - this means the changes have either fixed the problem or resulted in the hanging test failing prior to the hang

[23:21] <lambdabot> Consider it noted.

[23:26] *** bsb joined
[23:41] *** weinig is now known as weinig|bbl

[23:41] <svnbot6> r15668 | audreyt++ | * Automata::Cellular: Switch to the preferred form to export

[23:41] <svnbot6> r15668 | audreyt++ |   operators defined for a class:

[23:41] <svnbot6> r15668 | audreyt++ |     method postfix:<++> () is export { ... }

[23:43] <svnbot6> r15669 | audreyt++ | * Pugs.Parser: Correctly handle "is export" methods by

[23:43] <svnbot6> r15669 | audreyt++ |   exporting with its longname rather than shortname.

[23:46] *** fatman2 joined
[23:46] <fatman2>  hello i am fatman and i weigh 400 pounds.  you can see videos of my supreme fatness at www.fatman.tk

[23:47] *** fatman2 left
[23:49] *** dolmen joined
[23:50] <svnbot6> r15670 | audreyt++ | * Pugs.Prim: atomicEval now ensures that errors and control

[23:50] <svnbot6> r15670 | audreyt++ |   exceptions within the STM transaction gets propagates out

[23:50] <svnbot6> r15670 | audreyt++ |   correctly.  This makes "--1" fail as desired.

[23:53] <svnbot6> r15671 | audreyt++ | * Export Object::HOW and Object::new, because the spec

[23:53] <svnbot6> r15671 | audreyt++ |   contains lots of "new Foo" calls and we wouldn't want

[23:53] <svnbot6> r15671 | audreyt++ |   them to fail miserably.

