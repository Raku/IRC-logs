[00:00] *** lichtkind left
[00:04] *** japhb left
[00:05] *** theorb joined
[00:08] <pugs_svnbot> r18327 | avar++ | [kp6-lisp] Implemented length, again..

[00:08] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18327

[00:08] <lambdabot> Title: Changeset 18327 - Pugs - Trac

[00:17] *** theorbtwo left
[00:18] <TimToady> please call it "chars", not "length"

[00:20] *** jferrero left
[00:20] <avar> it's length in kp6, I suppose it can be changed later:)

[00:21] *** vbattsAtWork left
[00:22] *** devogon left
[00:22] <TimToady> meh, who's the dufus who called it length in the first place?  oh wait, nevermind...

[00:22] *** cognominal__ left
[00:23] <amnesiac> heh

[00:38] *** justatheory left
[00:39] *** kanru joined
[00:52] *** polettix left
[00:59] *** lyokato joined
[01:16] *** nipotaway is now known as nipotan

[01:44] *** weinig left
[01:54] *** kanru left
[02:16] *** daxim_ joined
[02:19] *** mr_ank joined
[02:22] *** zamolxes left
[02:22] *** kanru joined
[02:29] *** drbean_ left
[02:35] *** Schwern left
[02:44] *** weinig joined
[02:48] *** vbattsAtWork joined
[03:09] *** drupek12 joined
[03:17] *** REPLeffect_ joined
[03:51] *** jjore-w left
[04:03] *** justatheory joined
[04:13] *** diotalevi joined
[04:15] *** REPLeffect_ left
[04:38] <meppl> good morning

[04:40] <spinclad> good morrow, meppl

[04:41] <meppl> good morning spinclad

[05:01] * allbery_b had to switch back to this tab after doing a quick flash-through and reading "good moring moose"/"good morning squirrel"

[05:01] * allbery_b thinks it's tme for bed...

[05:03] <meppl> good night allbery

[05:03] <spinclad> no, #moose is over there ->

[05:03] <spinclad> sweet dreams, allbery_b 

[05:04] * spinclad changes channel name to #greetings

[05:04] *** dlocaus joined
[05:08] *** Ashizawa joined
[05:15] *** vbattsAtWork left
[05:17] *** devogon joined
[05:41] *** jisom joined
[06:19] *** thoughtpolice left
[06:37] *** elmex joined
[06:49] *** Aankhen`` joined
[06:57] *** justatheory left
[07:02] *** iblechbot joined
[07:02] *** dlocaus left
[07:10] *** shachaf left
[07:19] *** penk joined
[07:22] <pugs_svnbot> r18328 | Aankhen++ | * [kp6-lisp] call PERL->DISPLAY from &prefix:<~>.

[07:22] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18328

[07:22] <lambdabot> Title: Changeset 18328 - Pugs - Trac

[07:38] *** penk left
[07:38] *** penk joined
[07:55] *** franck___ joined
[07:59] *** amnesiac left
[08:24] *** masak joined
[08:25] *** xinming_ joined
[08:36] *** polettix joined
[08:37] *** xinming left
[08:50] *** jisom left
[08:50] *** devogon left
[08:52] *** devogon joined
[08:54] *** Kattana left
[08:55] *** iblechbot left
[09:03] *** Kattana joined
[09:06] *** polettix left
[09:20] <pugs_svnbot> r18329 | ruoso++ | [yap6] autotools ready to use... just do a make -f Makefile.cvs; configure; make

[09:20] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18329

[09:20] <lambdabot> Title: Changeset 18329 - Pugs - Trac

[09:41] <pugs_svnbot> r18330 | ruoso++ | [yap6] a roadmap is documented in the README file

[09:41] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18330

[09:41] <lambdabot> Title: Changeset 18330 - Pugs - Trac

[09:47] <pugs_svnbot> r18331 | ruoso++ | [yap6] clarification of the roadmap in README

[09:47] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18331

[09:47] <lambdabot> Title: Changeset 18331 - Pugs - Trac

[10:03] *** Ashizawa left
[10:08] *** fglock joined
[10:14] *** chris2 joined
[10:27] *** snearch joined
[10:28] *** dduncan left
[10:44] *** snearch left
[11:03] <pugs_svnbot> r18332 | ruoso++ | [yap6] Namespace seems to be the first step for a MOP (at least this is what MO:: makes me think)...

[11:03] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18332

[11:03] <lambdabot> Title: Changeset 18332 - Pugs - Trac

[11:06] *** lyokato left
[11:12] <pugs_svnbot> r18333 | fglock++ | [kp6] initial impl of gather/take

[11:12] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18333

[11:12] <lambdabot> Title: Changeset 18333 - Pugs - Trac

[11:13] *** drupek12 left
[11:20] *** drupek12 joined
[11:27] <pugs_svnbot> r18334 | ruoso++ | [yap6] specifies use of rwlock instead of mutex. define the functions to manage that...

[11:27] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18334

[11:27] <lambdabot> Title: Changeset 18334 - Pugs - Trac

[11:28] *** lichtkind joined
[11:28] <pugs_svnbot> r18335 | fglock++ | [kp6] added t/kp6/internals/02-gather.t

[11:28] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18335

[11:28] <lambdabot> Title: Changeset 18335 - Pugs - Trac

[11:30] *** nipotan is now known as nipotaway

[11:37] *** pina joined
[11:37] <pina> ok not trying to troll but where all does python lack in comparison to ruby or perl

[11:38] <pina> besides syntaxes

[11:38] <masak> pina: what do you mean?

[11:38] <pina> i mean where is it inefficient

[11:38] <masak> hard to say, I think

[11:38] <pina> like python sometimes is inefficient for something perl handles easily

[11:39] <masak> regexes are maximally easy in Perl

[11:39] <masak> in Python you have to use slightly more cumbersome syntax

[11:39] <masak> also, Python is more type strict

[11:39] <masak> Perl is explicitly context-sensitive

[11:40] *** ilogger2 joined
[11:42] <pina> ok

[11:42] <pina> those are pretty basic

[11:42] <pina> just syntaxes

[11:42] <masak> well, yes

[11:43] <masak> sufficiently deep down all languages are the same

[11:43] <masak> though I would say that Python and Perl have different feels to them even mid-way down

[11:44] <masak> many aspects of Python were created with Perl in mind

[11:44] <masak> Python has "There should be only one obvious way to do it" as one of its slogans

[11:44] <masak> the Python 3000 design process was made to be dissimilar to the Perl 6 design process

[11:45] <masak> I'm not saying one is better than the other, or that people cannot be friends across cultures, or anything like that

[11:45] <pugs_svnbot> r18336 | fglock++ | [kp6] tested gather/take on an infinite loop

[11:45] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18336

[11:45] <lambdabot> Title: Changeset 18336 - Pugs - Trac

[11:46] <masak> it's just that Python in many ways seems to be a reaction to Perl

[11:46] <masak> it's not only that, of course

[11:46] <masak> it's also a quite clean and easy to read programming languages, with its basis in education

[11:50] <fglock> moritz_: would you install the Coro module from CPAN in the evalbot environment?

[11:51] *** CindyLinz joined
[11:53] *** ilogger2 joined
[11:59] <fglock> is the block in 'gather' always supposed to terminate? 

[11:59] <fglock> I guess not, since it is evaluated lazily

[12:03] <fglock> I suppose the block is killed when the gather return value is no longer needed (gets out of scope)?

[12:03] <masak> fglock: sounds reasonable

[12:04] <masak> in the end, it's just iterators anyway, I suppose

[12:08] <masak> fglock: is there any case where programs would behave differently depending on whether 'gather' blocks have to terminate or not?

[12:09] <moritz_> fglock: of course, wait a second...

[12:10] *** Shillo joined
[12:12] <fglock> masak: in the case when you have an infinite loop inside gather; kp6 currently just terminates the main program

[12:13] <moritz_> kp6: say "hello"

[12:13] <exp_evalbot> r18336: OUTPUT[hello‚ê§]

[12:13] <masak> fglock: that's correct according to me iff the gathered array is not used

[12:13] <moritz_> fglock: does that mean everything is working again with evalbot?

[12:13] *** polettix joined
[12:14] <platypus> fglock: How does it detect an infinate loop?

[12:14] <fglock> http://dev.pugscode.org/browser/v6/v6-KindaPerl6/t/kp6/internals/02-gather.t

[12:14] <fglock> it is used, but just as needed

[12:14] <lambdabot> Title: /v6/v6-KindaPerl6/t/kp6/internals/02-gather.t - Pugs - Trac, http://tinyurl.com/yodmcp

[12:14] <masak> fglock: what do you mean?

[12:14] <fglock> platypus: it doesn't detect the loop; it runs until it gets enough data, then pause

[12:15] * platypus nods.

[12:15] <masak> fglock: if I understand you correctly, it sounds excellent

[12:15] <masak> the gather gets stuck in an infinite loop, but the program itself doesn't

[12:15] <fglock> masak: see the test

[12:15] <masak> oki

[12:15] <fglock> yep

[12:16] *** gorax joined
[12:16] <masak> re the test: yes, we agree

[12:16] <masak> excellent use of laziness, by me

[12:18] <masak> why is `gather` spelled `Gather.new`, btw?

[12:18] <masak> is that a kp6ism?

[12:19] <fglock> because it's not in the grammar yet

[12:19] <fglock> this is the internal representation

[12:19] <masak> wohoo, sounds like a fun thing to hack into the grammar! :)

[12:19] <fglock> masak: because it was just implemented a few minutes ago :P

[12:19] <masak> ah

[12:20] <masak> fglock++

[12:27] <Shillo> fglock: Do you plan to make it truly lazy, eventually?

[12:28] <Shillo> I mean, generate nothing when called, and only generate -precisely- as much as needed?

[12:28] <fglock> Shillo: it does already

[12:28] <Shillo> Goodie. :)

[12:29] <Shillo> For a moment I thought you were describing something like unix buffered pipes, so I commented. Sowwy.

[12:30] *** iblechbot joined
[12:30] <Shillo> Come to think of it, making the lazy lists buffered could be very useful. Because then you could autoparalelize to a different thread.

[12:31] <moritz_> but then you can't guarantee "true" lazyness

[12:31] <moritz_> we need a new trait, "is half-lazy" ;)

[12:31] <Shillo> Yeah, I know. :)

[12:31] <Shillo> Well, umm, train creep = evil. ;) Maybe just a proxy-list in standard library

[12:32] <Shillo> Er, trait creep :)

[12:35] <fglock> Shillo: I don't get it - can you give an example?

[12:36] * Shillo thinks...

[12:36] <moritz_> fglock: you can define lazy lists recursively

[12:37] <moritz_> @a = (0, 1, @[*-1] + @[*-2])

[12:37] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . v

[12:37] <moritz_> that should generate the fibonaccy numbers lazyly

[12:37] <Shillo> moritz_: You can do that with normal laziness, too

[12:37] <moritz_> now if have a sub that read from that list, you have to switch between the list calculation and the callling sub

[12:37] <pugs_svnbot> r18337 | fglock++ | [kp6] added 'gather' to the grammar; needs some AST work

[12:37] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18337

[12:37] <lambdabot> Title: Changeset 18337 - Pugs - Trac

[12:38] <Shillo> Normal gather would create an object that contains list_so_far and a continuation that makes more

[12:38] <moritz_> but if you did some buffering, you could move the liist calculation into its own thread

[12:38] <Shillo> Threaded gather would have list_so_far, a semaphore and a thread

[12:38] <moritz_> and run them in parallel

[12:38] <Shillo> list_so_far would now contain more than needed, and the thread would block until more is required

[12:39] <Shillo> I suspect this is the primitive you need to implement hyperops and pipes with gather

[12:39] <Shillo> Not sure if semaphore is the right locking primitive, of course. Possibly not.

[12:39] <moritz_> reboot &

[12:40] <Shillo> Could be just a pair of mutexes instead. ACtually, probably is, becuase this is producer-consumer pattern

[12:40] <Shillo> But honestly, I don't think this belongs to the core language. Maybe into the runtime library

[12:41] <Shillo> You actually need it (or something like it) for autothreaded primitives.

[12:42] <Shillo> Actually, this is another good problem: Pester @Larry into thinking about interactions about autothreading and laziness

[12:42] *** pmurias joined
[12:42] <pmurias> hi

[12:43] <Shillo> As in, is @a >>+<< @b lazy list? Or does it autothread? Or, if it does both, how?

[12:43] <Shillo> Hiya!

[12:43] <masak> Shillo: good question

[12:44] <pmurias> list context is lazy by default

[12:44] <pmurias> (is what i heard)

[12:44] <Shillo> That doesn't completely answer my question, though.

[12:44] <Shillo> Or rather, it doesn't answer 3rd part of it.

[12:45] <Shillo> Basically, if it splits @a and @b into sublists and assigns them to threads, the question becomes, when do you do the summing?

[12:45] <Shillo> ... of the middle chunks?

[12:46] <fglock> Shillo: you do the sum just when you need the result

[12:46] <Shillo> fglock: This isn't what autothreading implies, though

[12:46] <masak> @ask TimToady about the interactions between autothreading and laziness. what happens in the following case? my @a = gather { ... }; my @c = @a >>+<< @b; does the calculation of @c happen lazily, or does it autothread only after the calculation of @a is complete?

[12:46] <lambdabot> Consider it noted.

[12:47] <Shillo> Because lazy = as needed, as late as possible. Autothreading = random order, hardware/os-dependent time. The two don't seem compatible by default.

[12:48] <Shillo> I'm not saying that they can't be made compatible, but it's worthy thinking about.

[12:48] <masak> nod

[12:50] *** cmarcelo joined
[12:51] *** iblechbot left
[12:56] <fglock> kp6: "test"

[12:56] <pugs_svnbot> r18338 | fglock++ | [kp6] gather syntax works

[12:56] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18338

[12:56] <exp_evalbot> r18337: OUTPUT['test'‚ê§]

[12:56] <lambdabot> Title: Changeset 18338 - Pugs - Trac

[12:57] *** audreyt_ joined
[12:58] <pmurias> fglock: why is gather in t/internals?

[12:58] <fglock> kp6: my $a = gather { take 123; take 456; }; say $a[1]

[12:58] <exp_evalbot> r18338: OUTPUT[456‚ê§]

[12:59] <fglock> pmurias: because the Gather class is not part of the spec

[12:59] <fglock> kp6: my $a = gather { while 1 { take 123; take 456; } }; say $a[1]

[12:59] <exp_evalbot> r18338: OUTPUT[456‚ê§]

[12:59] <fglock> yay!

[13:00] <pmurias> is Junction.new(...) speced?

[13:00] <masak> fglock++ # cool

[13:00] <fglock> kp6: my $a = gather { while 1 { take 123; take 456; } }; say $a[3]

[13:00] <exp_evalbot> r18338: OUTPUT[456‚ê§]

[13:00] <masak> it's almost surreal that that works

[13:00] <masak> how does pugs do in comparison?

[13:00] <fglock> pmurias: no - it was created before t/internals :P

[13:00] <pmurias> history explain everythin

[13:01] <pmurias> g

[13:01] <moritz_> fglock++

[13:01] * moritz_ is truely impressed

[13:01] <Shillo> fglock: Nice!

[13:01] <masak> apparently pugs hangs on the gather

[13:02] <masak> too eager...

[13:02] <Shillo> masak: Yeah, I tested laziness in pugs a while ago, and that's what happened.

[13:02] <Shillo> audreyt: Hiya!

[13:02] * masak ownders if there's a test for gather laziness in the pugs test suite

[13:03] <Shillo> kp6: my $a = gather { for 1..5 { say $_; take $_ } }; say $a[3];

[13:03] <exp_evalbot> r18338: OUTPUT[error in Block at lib-kp6-mp6-p5/KindaPerl6/Grammar/Sub.pm line 14, <> line 1.‚ê§Illegal declaration of anonymous subroutine at - line 1.‚ê§]

[13:03] <Shillo> kp6: my $a = gather { for 1..5 -> $x { say $x; take $x; } }; say $a[3];

[13:03] <moritz_> masak: you could add one, just in case

[13:03] <exp_evalbot> r18338: OUTPUT[error in Block at lib-kp6-mp6-p5/KindaPerl6/Grammar/Sub.pm line 14, <> line 1.‚ê§Illegal declaration of anonymous subroutine at - line 1.‚ê§]

[13:03] <masak> moritz_: I'll do that

[13:04] <fglock> Shillo: Range is unfinished

[13:04] * pmurias had to dispable valgring support in Coro

[13:04] <masak> how best to test against infinite looping? wait a reasonable amount of time for a thread and then kill it?

[13:04] <Shillo> kp6: my $a = gather { say 1; take 1; say 2; take 2; say 3; take 3; say 4; take 4; }; say $a[1];

[13:04] <exp_evalbot> r18338: OUTPUT[1‚ê§2‚ê§2‚ê§]

[13:04] <Shillo> Hmm, how to try this same thing in pugs?

[13:04] <Shillo> kp6 passed with flying colors :)

[13:05] <Shillo> pugs: my $a = gather { say 1; take 1; say 2; take 2; say 3; take 3; say 4; take 4; }; say $a[1];

[13:05] <masak> Shillo: good idea

[13:05] <exp_evalbot> OUTPUT[1‚ê§2‚ê§3‚ê§4‚ê§2‚ê§]

[13:05] <pmurias> my $a = gather { while(1) {take 2} };say $a[5];

[13:05] <Shillo> Ooooh!

[13:05] <Shillo> There's your test. Fails without hanging. :)

[13:05] <pmurias> kp6: my $a = gather { while(1) {take 2} };say $a[5];

[13:05] <exp_evalbot> r18338: OUTPUT[error in Block at lib-kp6-mp6-p5/KindaPerl6/Grammar/Sub.pm line 14, <> line 1.‚ê§Illegal declaration of anonymous subroutine at - line 1.‚ê§]

[13:06] <moritz_> my $count = 0; my @list = gather { for 1 .. 10 -> $a { take $a; $count++ } }; say @list[2]; say $count

[13:06] <moritz_> pugs: my $count = 0; my @list = gather { for 1 .. 10 -> $a { take $a; $count++ } }; say @list[2]; say $count

[13:06] <exp_evalbot> OUTPUT[3‚ê§10‚ê§]

[13:06] <moritz_> you see it's not lazy

[13:06] <Shillo> Nice, too :)

[13:06] <masak> moritz_: I'll use your method as a test

[13:06] <moritz_> kp6: my $count = 0; my @list = gather { for 1 .. 10 -> $a { take $a; $count++ } }; say @list[2]; say $count

[13:06] <exp_evalbot> r18338: OUTPUT[error in Block at lib-kp6-mp6-p5/KindaPerl6/Grammar/Sub.pm line 14, <> line 1.‚ê§Illegal declaration of anonymous subroutine at - line 1.‚ê§]

[13:06] <pmurias> kp6: my $count;while(--$count > 0) {say 2}

[13:06] <exp_evalbot> r18338: OUTPUT[syntax error at position 30, line 1 column 30:‚ê§my $count;while(--$count > 0) {say 2‚ê§                              ^ HERE‚ê§DISPATCH: calling APPLY KindaPerl6::Runtime::Perl5::DispatchSugar::Dispatch=HASH(0x8583850) on invalid object:$VAR1 = {};‚ê§‚ê§ at

[13:06] <exp_evalbot> ..lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 33‚ê§    main::DISPATCH('undef', 'APPLY', 'KindaPerl...]

[13:06] <pmurias> kp6: my $count=4;while(--$count > 0) {say 2}

[13:06] <exp_evalbot> r18338: OUTPUT[syntax error at position 32, line 1 column 32:‚ê§my $count=4;while(--$count > 0) {say 2‚ê§                                ^ HERE‚ê§DISPATCH: calling APPLY KindaPerl6::Runtime::Perl5::DispatchSugar::Dispatch=HASH(0x814f504) on invalid object:$VAR1 = {};‚ê§‚ê§ at

[13:06] <exp_evalbot> ..lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 33‚ê§        main::DISPATCH('undef', 'APPLY', 'Kinda...]

[13:06] <moritz_> it doesn't use I/O, and it doesn't loop forever if it's not lazy

[13:07] <pmurias> moritz_: it does IO

[13:07] <pmurias> I/)

[13:07] <pmurias> I/O

[13:08] <moritz_> pmurias: yes, but not as a side effect in the gather/take

[13:09] *** gorax left
[13:09] <fglock> kp6:  my $a = gather { while (1) {say "take"; take 2} };say $a[5];

[13:09] <exp_evalbot> r18338: OUTPUT[take‚ê§take‚ê§take‚ê§take‚ê§take‚ê§take‚ê§2‚ê§]

[13:09] <pmurias> kp6: use IO::File:from<perl5>;my $fh = IO::File.new();$fh.open(">file");

[13:09] <exp_evalbot> r18338: OUTPUT[DISPATCH: calling perl on invalid object:$VAR1 = '';‚ê§‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 33‚ê§    main::DISPATCH('', 'perl') called at - line 16‚ê§]

[13:09] <pmurias> kp6: use IO::File:from<perl5>;my $fh = IO::File.new();

[13:09] <exp_evalbot> r18338: OUTPUT[Can't locate object method "perl" via package "IO::File" at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/Wrap.pm line 22.‚ê§]

[13:10] <masak> there actually is a small laziness test in t/statements/gather.t, but I'll add an explicit one in the end anyway

[13:10] <masak> the small test is markes :todo<unspecced>

[13:11] <masak> s/markes/maked/

[13:11] <pmurias> kp6: say "hi"

[13:11] <exp_evalbot> r18338: OUTPUT[hi‚ê§]

[13:11] <pmurias> kp6: gather {say "hi";}

[13:11] <exp_evalbot> r18338: OUTPUT[no method 'code' in Class 'Gather'‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 130‚ê§    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x85a2494)', 'code') called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 36‚ê§    main::DISPATCH('HASH(0x85a2494)', 'code')

[13:11] <exp_evalbot> ..called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl6/Gather.pm line 51‚ê§    Gathe...]

[13:11] <pmurias> kp6: gather {1+2;}

[13:11] <exp_evalbot> r18338: OUTPUT[no method 'code' in Class 'Gather'‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 130‚ê§    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x85a84d4)', 'code') called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 36‚ê§    main::DISPATCH('HASH(0x85a84d4)', 'code')

[13:11] <exp_evalbot> ..called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl6/Gather.pm line 51‚ê§    Gathe...]

[13:11] <pmurias> kp6: gather {take 1+2;}

[13:11] <exp_evalbot> r18338: OUTPUT[no method 'code' in Class 'Gather'‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 130‚ê§    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x85a84f4)', 'code') called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 36‚ê§    main::DISPATCH('HASH(0x85a84f4)', 'code')

[13:11] <exp_evalbot> ..called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl6/Gather.pm line 51‚ê§    Gathe...]

[13:11] <fglock> pmurias: one sec, I'll fix it

[13:11] <Shillo> Funny.

[13:12] <pmurias> moritz_: why dosn't gather use IO?

[13:12] <moritz_> pmurias: why should it?

[13:12] <moritz_> pmurias: I think we're not talking about the same thing

[13:12] <pugs_svnbot> r18339 | masak++ | [t/statements/gather.t]

[13:12] <pugs_svnbot> r18339 | masak++ | * test for lazy gather

[13:12] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18339

[13:12] <lambdabot> Title: Changeset 18339 - Pugs - Trac

[13:13] <moritz_> pmurias: I suggested a method to check if gather works lazily, and that didn't use additional I/O

[13:18] <pmurias> moritz_: i see

[13:19] <pmurias> had too much school/starcraft 

[13:20] <fglock> kp6: gather {take 1+2;}

[13:20] <pugs_svnbot> r18340 | fglock++ | [kp6] fixed Gather.perl (but still have errors)

[13:20] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18340

[13:20] <exp_evalbot> r18339: OUTPUT[no method 'code' in Class 'Gather'‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 130‚ê§    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x85a84f4)', 'code') called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 36‚ê§    main::DISPATCH('HASH(0x85a84f4)', 'code')

[13:20] <exp_evalbot> ..called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl6/Gather.pm line 51‚ê§    Gathe...]

[13:20] <lambdabot> Title: Changeset 18340 - Pugs - Trac

[13:20] <fglock> kp6: gather {take 1+2;}

[13:20] <exp_evalbot> r18339: OUTPUT[no method 'code' in Class 'Gather'‚ê§ at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 130‚ê§    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x85a84f4)', 'code') called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 36‚ê§    main::DISPATCH('HASH(0x85a84f4)', 'code')

[13:20] <exp_evalbot> ..called at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl6/Gather.pm line 51‚ê§    Gathe...]

[13:23] <Shillo> Didn't update yet. old r number

[13:23] <Shillo> kp6: gather {take 1+2; }

[13:23] <exp_evalbot> r18340: OUTPUT[gather( Str )‚ê§]

[13:23] <Shillo> Heh! :)

[13:25] *** mino joined
[13:25] *** mino left
[13:26] <pugs_svnbot> r18341 | fglock++ | [kp6] fix Gather.perl a bit more

[13:26] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18341

[13:26] <lambdabot> Title: Changeset 18341 - Pugs - Trac

[13:27] <fglock> note that gather {take 1+2; } never executes the block

[13:27] <fglock> kp6: gather {take 1+2;}

[13:27] <exp_evalbot> r18341: OUTPUT[( gather { ... } )‚ê§]

[13:31] *** vbattsAtWork joined
[13:36] <moritz_> kp6: my @a = gather { take 1; take 2 };

[13:36] <exp_evalbot> r18341: OUTPUT[Can't use an undefined value as an ARRAY reference at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/Array.pm line 24.‚ê§]

[13:36] <moritz_> kp6: my @a; @a = gather { take 1; take 2 };

[13:36] <exp_evalbot> r18341: OUTPUT[Can't use an undefined value as an ARRAY reference at lib-kp6-mp6-p5/KindaPerl6/Runtime/Perl5/Array.pm line 24.‚ê§]

[13:36] <moritz_> kp6: gather { take 1; take 2 };

[13:36] <exp_evalbot> r18341: OUTPUT[( gather { ... } )‚ê§]

[13:38] *** cognominal_ joined
[13:40] *** cognominal_ left
[13:41] *** cognominal_ joined
[13:41] *** TJCRI joined
[13:44] <avar> is the kp6-kp6 backend completely scewed up atm?

[13:44] <pmurias> fglock: is there much benefit in also testing desugared forms like Gather.new() instead of gather?

[13:44] *** alecc joined
[13:44] <fglock> moritz_: Array is not lazy yet, so @a = gather ... doesn't work

[13:44] <fglock> pmurias: not really

[13:44] <fglock> just for debugging

[13:44] <pmurias> avar: kp6-kp6 never work, it's not realy a backend

[13:46] <avar> it doesn't even compile now

[13:47] <avar> /usr/bin/perl script/kp6 -r kp6 < lib/KindaPerl6/Visitor/EmitLisp.pm | perltidy -pro=util/perltidyrc > lib-kp6-kp6-p5/KindaP\

[13:47] <avar> erl6/Visitor/EmitLisp.pm

[13:47] <avar> KindaPerl6/Runtime/Perl6/Pair.pm did not return a true value at lib-kp6-kp6-p5/KindaPerl6/Runtime/Perl5/MOP.pm line 823.

[13:47] <avar> Compilation failed in require at lib-kp6-kp6-p5/KindaPerl6/Runtime/Perl5/Runtime.pm line 5.

[13:48] <pmurias> * worked

[13:55] *** cmarcelo_ joined
[13:59] *** cmarcelo left
[13:59] *** cmarcelo_ is now known as cmarcelo

[14:05] *** elmex joined
[14:06] <pmurias> ruoso: it might interesting to see home much of the runtime can be implemented using native types

[14:06] *** iblechbot joined
[14:07] <pmurias> some parts of perl6 eq. sub add(int $a,int $b --> int) {$a+$b} can be compiled to c directly

[14:17] *** ntgrl joined
[14:17] <pugs_svnbot> r18342 | fglock++ | [kp6] moved much of the gather impl to Perl 6 land

[14:17] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18342

[14:17] <lambdabot> Title: Changeset 18342 - Pugs - Trac

[14:17] <avar> pmurias: http://sial.org/pbot/27962

[14:17] <lambdabot> Title: Paste #27962 from Someone at 208.78.101.240

[14:18] <avar> pmurias: When kp6-CL supports such type decls we can emit optimized assembly for those cases as that paste shows

[14:18] <avar> parrot^Hkp6-cl aims to be the fastest perl 6 implementation:)

[14:19] *** polettix left
[14:19] <avar> Well, it is at the moment even though the CL we're emitting is completely unoptimized

[14:23] <pugs_svnbot> r18343 | fglock++ | [kp6] implemented .eager on Gather objs

[14:23] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18343

[14:26] <pugs_svnbot> r18344 | fglock++ | [kp6] gather stringification works

[14:26] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18344

[14:27] *** amnesiac joined
[14:34] <pmurias> avar: cool

[14:35] <moritz_> avar: do you have some figures on the speed?

[14:36] <avar> only stuff I posted on pugs.blogs.com

[14:37] <avar> but the stand-alone exes I've been making feel much faster than pugs, and it's even faster than that inside the lisp image

[14:37] <avar> (the exes are 30MB)

[14:37] <moritz_> avar: I only saw your "kp6 is now on CPAN" post there

[14:38] <avar> http://pugs.blogs.com/pugs/2007/08/playing-with-th.html#comments

[14:38] <lambdabot> Title: Pugs: Playing with the new "Not Quite Perl"

[14:38] *** ajelenak joined
[14:39] <avar> sbcl also has built-in support for what parrot was going to do (is doing?), run one parrot image per system and load programs into it

[14:39] <avar> That's how you're supposed to run it in fact

[14:39] *** ajelenak left
[14:39] <moritz_> avar: ok

[14:44] *** blindfish joined
[14:52] <[particle]> avar: with 30MB exes, let's hope so :/

[14:54] *** mncharity joined
[15:02] <pugs_svnbot> r18345 | fglock++ | [kp6] Gather.map (doesn't work yet)

[15:02] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18345

[15:04] <Aankhen``> I'm confused.  Do packages, modules, classes and roles share the same namespace or do they not?

[15:05] <Aankhen``> Also types and subtypes, I suppose.

[15:06] <[particle]> one part of this that i think i understand clearly is Class has-many Namespace

[15:06] <[particle]> in other words, you can alias classnames

[15:07] <Aankhen``> How so?

[15:08] <[particle]> i'm looking for something to support that in the synopses

[15:08] <[particle]> however, i know parrot's namespace/class design is that way to allow perl 6 aliasing

[15:09] <pmurias> Aankhen``: classes,modules and roles surly share the same namespace

[15:09] <[particle]> and grammars

[15:09] <Aankhen``> Whew.

[15:09] <pmurias> grammars are classes

[15:09] <Aankhen``> I was worried for a moment.

[15:10] <Aankhen``> Types and subtypes as well?

[15:10] <pmurias> they must

[15:10] <Aankhen``> Right.

[15:10] <Aankhen``> Thanks, I feel much better now. :-)

[15:10] <moritz_> can't you just use ::= to alias namespaces etc.?

[15:12] <pugs_svnbot> r18346 | fglock++ | [kp6] Gather.map runs; possible fencepost error?

[15:12] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18346

[15:13] <fglock> kp6: my $a = gather { my $k = 0; while 1 { take $k; $k = $k + 1; } };say ( $a.map: -> $x { $x + 100 }  )[10];

[15:13] <exp_evalbot> r18346: OUTPUT[121‚ê§]

[15:14] *** [particle] joined
[15:14] <Aankhen``> Is misc/Perl-Metamodel/ outdated?

[15:14] <Aankhen``> That is, would it be silly to use ideas from there?

[15:14] <fglock> Aankhen``: it's a bit outdated

[15:15] <fglock> Aankhen``: see Moose and MO instead

[15:15] <Aankhen``> fglock: What's more up-to-date?

[15:15] <Aankhen``> Okay.

[15:15] <fglock> looking for link

[15:15] <Aankhen``> Don't worry, I'm familiar with Moose and I came across MO recently. :-)

[15:15] <fglock> Aankhen``: http://nothingmuch.woobling.org/MO/

[15:15] <lambdabot> Title: Index of /MO

[15:15] <fglock> ok :)

[15:16] <Aankhen``> Oh, perhaps this was the wrong MO I came across.

[15:16] <Aankhen``> Thanks for the link.

[15:17] *** Shillo left
[15:25] <avar> [particle]: the 30mb exes are really memory dumps of sbcl

[15:30] *** IllvilJa joined
[15:32] *** barney joined
[15:32] <pugs_svnbot> r18347 | fglock++ | [kp6] moved Gather.INDEX to Perl 6

[15:32] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18347

[15:32] <lambdabot> Title: Changeset 18347 - Pugs - Trac

[15:43] *** melissa joined
[15:44] <pmurias> 53-attr-bind should use $!member

[15:44] <pmurias> i don't know what binding to a method call would/should do

[15:47] <pmurias> right?

[15:50] <pugs_svnbot> r18348 | pmurias++ | [kp6] private attribute, only binding to private attribiutes is allowed

[15:50] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18348

[15:50] <lambdabot> Title: Changeset 18348 - Pugs - Trac

[16:00] <pmurias> 2 tests fail on the p5 backend ;)

[16:08] <pugs_svnbot> r18349 | fglock++ | [kp6] gather - more fixes

[16:08] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18349

[16:08] <lambdabot> Title: Changeset 18349 - Pugs - Trac

[16:10] *** lisppaste3 joined
[16:10] <TimToady> @messages

[16:10] <lambdabot> masak asked 3h 24m 14s ago: about the interactions between autothreading and laziness. what happens in the following case? my @a = gather { ... }; my @c = @a >>+<< @b; does the calculation of @c

[16:10] <lambdabot> happen lazily, or does it autothread only after the calculation of @a is complete?

[16:12] <TimToady> the hyperops wants to run to completion, and pretends the array is all there for scheduling threaded execution

[16:12] <TimToady> if it isn't all there, then the thread in question will have to wait until its values start arriving from the gather

[16:13] <TimToady> on the earlier question, I have always felt that laziness should be allowed to happen in batches by default

[16:13] <TimToady> you shouldn't be relying on laziness happening in a particular order

[16:13] <TimToady> that should be considered harmful

[16:14] <TimToady> so if a thread wants to work ahead a little, I don't see why it shouldn't.

[16:15] <TimToady> most of these parallel operators in Perl 6 explicitly promise that you don't care about order of evaluation

[16:15] <TimToady> and even laziness doesn't really care about order of evaluation, just order of the resulting values

[16:17] <TimToady> but we basically give the list optimizer three settings on the dial: lazy, eager, and hyper 

[16:17] <[particle]> s/list optimizer/teenager/

[16:17] <TimToady> rofl

[16:22] <TimToady> the basic assumption is that a lazy list may not be interested in all its values; an eager list is interested in all its values and cares about order of evaluation; hyper wants all values but doesn't care about order of evaluation.

[16:22] <TimToady> (and junctions don't care about order of evaluation and don't necessarily want all their values)

[16:23] <TimToady> biab &

[16:23] *** ruoso joined
[16:27] <Tene> Are there currently any implementations of 'lazy' for Perl 5?

[16:28] <[particle]> Moose has lazy

[16:32] <Tene> Oh, Scalar::Defer

[16:32] <[particle]> ah, right!

[16:35] *** jeremyb joined
[16:36] *** alecc left
[16:38] *** arrowax joined
[16:39] *** jjore-w joined
[16:48] *** Daveman joined
[16:53] <TimToady> I should say, lazy cares about the order of evaluation, but only with respect to its own list.

[16:53] <TimToady> it necessarily follows that it can work ahead if it likes

[16:57] *** justatheory joined
[16:58] <avar> Aankhen``: echo 'my $res = do { "1" // 0 }; if $res {}' | perl script/kp6 -lisp | sbcl

[16:58] <avar> same with 1 (Int)

[16:58] <avar> * Error: #<KP6-STR {AF3AFC9}> fell through ETYPECASE expression.

[16:58] <avar>        Wanted one of (KP6-NAMED-PARAMETER KP6-POSITIONAL-PARAMETER).

[17:01] *** theorbtwo joined
[17:01] <pugs_svnbot> r18350 | ruoso++ | [yap6] Basic memory management, values are alloced and basic refcount garbage collection is implemented

[17:01] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18350

[17:01] <lambdabot> Title: Changeset 18350 - Pugs - Trac

[17:03] *** weinig joined
[17:03] <pugs_svnbot> r18351 | avar++ | [kp6-lisp]

[17:03] <pugs_svnbot> r18351 | avar++ | * Added method support back to class Call, isn't supported by the

[17:03] <pugs_svnbot> r18351 | avar++ |   runtime yet but fails more nicely now

[17:03] <pugs_svnbot> r18351 | avar++ | * //, || and && were returning CL (t/nil) object not kp6 objects so they failed on e.g. if (do { 1 || 0 }) {}

[17:03] <pugs_svnbot> r18351 | avar++ | * Re-indented, fix yer settings aankhen:)

[17:03] <pugs_svnbot> r18352 | avar++ | Regened from the last few commits

[17:03] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18352

[17:03] <lambdabot> Title: Changeset 18352 - Pugs - Trac

[17:04] *** weinig_ joined
[17:06] *** kanru joined
[17:07] *** weinig__ joined
[17:07] *** weinig_ left
[17:07] <pugs_svnbot> r18353 | fglock++ | [kp6] gather + map works now

[17:07] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18353

[17:07] <lambdabot> Title: Changeset 18353 - Pugs - Trac

[17:10] <fglock> nested gather has problems

[17:12] <fglock> kp6: my $a = gather { my $k = 0; while 1 { take $k; $k = $k + 1; } };say ($a.map: -> $x { $x + 100 })[10];

[17:12] <exp_evalbot> r18353: OUTPUT[110‚ê§]

[17:12] *** jisom joined
[17:13] <avar> oh noes, Aankhen`` broke my precious // :)

[17:15] <fglock> kp6-perl5 feels real slow when working on lists

[17:17] <avar> lie what program for example?

[17:20] <fglock> kp6: my $a = gather { my $k = 0; while 1 { take $k; $k = $k + 1; } };say (($a.map: -> $x { $x + 100 }).map: -> $y { $y - 1 } )[99]; 

[17:20] <exp_evalbot> r18353: OUTPUT[198‚ê§]

[17:20] <fglock> hmm - not that bad

[17:21] *** weinig left
[17:24] *** Psyche^ joined
[17:29] *** pina joined
[17:29] <fglock> TimToady: re lazy cares about the order of evaluation,

[17:30] <fglock>  @a = gather {...}; @b = @a.map:{ $_+1 }; say @b[10];   # does it need to add 1 to all of @a[0..9] ?

[17:32] <fglock> or maybe you mean "order of results"

[17:33] *** GeJ joined
[17:33] <pugs_svnbot> r18354 | ruoso++ | [yap6] basic dispatch, first tests

[17:33] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18354

[17:33] <lambdabot> Title: Changeset 18354 - Pugs - Trac

[17:33] <ruoso> fglock, I would say it needs to do all of 0..9 when you try to mess with @b[10]

[17:33] <pmurias> me too

[17:34] <pmurias> it could cheat if there are no side effects, but that's an implementation detail

[17:36] <ruoso> pmurias, it can't, because there's no way to tell "there are no side effects"

[17:37] *** weinig__ left
[17:37] *** weinig joined
[17:40] *** Psyche^ is now known as Patterner

[17:42] <pugs_svnbot> r18355 | ruoso++ | [yap6] consts increment the refcount when assigning the dispatcher...

[17:42] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18355

[17:42] <lambdabot> Title: Changeset 18355 - Pugs - Trac

[17:43] <avar> Aankhen``: echo 'my $x = 5; say $x;' | perl script/kp6 -do Scope,EmitLisp

[17:43] *** ntgrl is now known as integral

[17:44] <pmurias> ruoso: i agree that analysing side effect is difficult but it could be possible if the compiler was smart enough

[17:44] <pmurias> although the existence of eval could screw everything up

[17:46] <avar> Scope.pm isn't used by the perl emitting stuff..

[17:46] <avar> pmurias: yes, eval sucks

[17:47] <avar> It's one of those things along with caller() and other stuff that means you have to carry around stacks, scope info and whatnot

[17:48] <avar> (eval) in CL for instance does not allow you to access variables in the scope that happens to have the eval call, it just allows you to make a new compilation unit

[17:52] *** diakopter joined
[17:52] <pugs_svnbot> r18356 | fglock++ | [yap6] minor fixes in Makefile, mem alloc, by ruoso++

[17:52] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18356

[17:52] <lambdabot> Title: Changeset 18356 - Pugs - Trac

[17:53] <pmurias> avar: it's a conflict between wanting perl6 to be a compiled language a keeping the dynamism

[17:54] *** ChanServ sets mode: +o diakopter

[17:54] *** diakopter sets mode: +o TimToady

[17:54] *** diakopter sets mode: -o diakopter

[17:54] <avar> pmurias: sure

[17:55] <avar> pmurias: But as CL shows you can have lots of carefully crafted dymanism without slowing everything else down, if you're ready to drop som features

[17:56] <pmurias> swimming&

[17:58] <fglock> Scope.pm is mostly meant for implementing lexical scopes and closures in backends that don't support it natively

[18:00] <avar> People studying how to design an optimizable dynamic language would do well to study CL, it was basically designed by a bunch of compiler implementors who knew what they were doing and what they needed to fix:)

[18:00] <avar> *hint* *hint* :)

[18:03] <avar> But it's clear that Perl 6 won't be as fast as CL in the general case since there's a lot of stuff that prevents you from compiling it to optimized assembly, and some of this stuff is hard to figure out statically by a compiler

[18:03] * integral notes that plenty of people can tell you what makes perl 5 hard to run fast, but little of it has changed for perl 6

[18:03] *** scent joined
[18:05] <avar> integral: That's not right, the biggest thing holding perl 5 back I'd say is magic. It's not copied in perl6 unless you bind the variable

[18:06] <avar> with that and the type system you can optimize stuff like sub add(int $a, int $b --> int) { $a + $b }

[18:06] <avar> (see sial.org paste earlier)

[18:06] *** kanru left
[18:07] <pugs_svnbot> r18357 | fglock++ | [kp6] gather - fixed several workarounds

[18:07] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18357

[18:07] <lambdabot> Title: Changeset 18357 - Pugs - Trac

[18:07] <integral> avar: But how many people are going to put enough annotations on their code?

[18:08] <integral> but you're right, magic is mostly gone which is nice :-)

[18:09] <avar> integral: few, but you can do it for parts which need optimizing

[18:13] <pugs_svnbot> r18358 | ruoso++ | [yap6] created a doc directory, included some notes about the ideas...

[18:13] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18358

[18:13] <lambdabot> Title: Changeset 18358 - Pugs - Trac

[18:15] <avar> integral: But I think a lot of people are going to use Num/Int/Str etc.

[18:16] *** kanru joined
[18:18] *** polettix joined
[18:25] *** snearch joined
[18:27] *** penk joined
[18:29] *** Jedai joined
[18:37] *** ruoso left
[18:55] *** REPLeffect_ joined
[19:06] *** justatheory left
[19:06] *** justatheory joined
[19:16] *** _go_ joined
[19:18] *** rindolf joined
[19:25] *** amnesiac left
[19:28] *** blindfish_ joined
[19:44] *** blindfish left
[19:48] *** pina left
[19:56] *** snearch left
[19:56] <pmurias> the compiler can create specialize multi variants based on profiling information

[19:57] *** dduncan joined
[19:58] <pmurias> psyco does something similar for python

[20:06] *** blindfish_ left
[20:14] <pugs_svnbot> r18359 | pmurias++ | [yap6] doc fix - I think Rouso meant firstly instead of at first, revert if wrong

[20:14] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18359

[20:14] <lambdabot> Title: Changeset 18359 - Pugs - Trac

[20:15] *** vbattsAtWork left
[20:28] *** ofer joined
[20:36] *** shachaf joined
[20:37] *** cognominal_ left
[20:43] *** cognominal_ joined
[20:47] *** drupek12 joined
[20:47] *** thoughtpolice joined
[20:49] *** _go_ left
[20:54] *** drupek12 left
[20:54] *** rindolf left
[21:02] *** barney left
[21:08] *** jeffreykegler joined
[21:14] *** arrowax left
[21:21] *** TJCRI left
[21:22] <pmurias> g'night

[21:22] *** pmurias left
[21:24] *** iblechbot left
[21:30] *** Daveman left
[21:33] *** Daveman joined
[21:56] *** polettix left
[22:20] *** Limbic_Region joined
[22:23] *** pjcj_ joined
[22:27] <pugs_svnbot> r18360 | fglock++ | [kp6] s/length/chars/

[22:27] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18360

[22:27] <lambdabot> Title: Changeset 18360 - Pugs - Trac

[22:32] *** cmarcelo left
[22:54] *** fax joined
[22:58] <avar> fax: interested in more hackery?:)

[22:58] <fax> yeah :)

[22:59] <fax> Looks like @source[0] = 2; has broken

[22:59] <fax> in kp6

[22:59] <fax> hows progress?

[23:00] <avar> we're passing a few more tests, but now we need the object model:)

[23:01] <avar> look at lib/KindaPerl6/Runtime/Perl5/MOP.pm

[23:02] <avar> The core so to speak being ::DISPATCH

[23:02] <avar> basically that's the Perl 6 object model in Perl 5. You define an object in a non-std way in Perl 5 that has a name, parents, some functions etc.

[23:03] <avar> Everything works in that model so you can tell a Str instance to tell you its length in chars for instance and it knows to look up its method, its parents method and so on

[23:04] <avar> I haven't done anything in it but I've been wondering to what amount that can be layered on top of CLOS and some standard slots/methods. So far I haven't seen any reason not to do that

[23:04] <fax> mhm

[23:04] <fax> CLOS is possible you can use the metaobject protocol in CLOS to change most all behavior 

[23:04] <avar> ...and using CLOS would mean not implementing your own method resolution mechanism from a class higherarchy 

[23:05] <fax> [if that was needed]

[23:05] <avar> yup

[23:08] <avar> echo 'my %hash = (key => "value"); say %hash.elems' | perl script/kp6 | perltidy

[23:08] <avar> that's a good example

[23:08] <avar>         ::DISPATCH( $GLOBAL::Code_say, 'APPLY',

[23:08] <avar>             ::DISPATCH( $Hash_hash, 'elems', ) )

[23:14] <fax> ah ok I get it

[23:16] <avar> basically we've been doing a lot of this stuff wrong:)

[23:17] <avar> assignment for example in kp6-perl is just:

[23:17] <avar> '::DISPATCH_VAR( ' ~ $node.emit_perl5 ~ ', \'STORE\', ' ~ $.arguments.emit_perl5 ~ ' )' ~ Main::newline();

[23:19] *** devogon joined
[23:20] <fax> hm so are you thinking about implementing the object model and then changing most of the lisp emitter stuff to use it like that?

[23:20] <avar> Yeah

[23:21] *** devogon left
[23:23] *** devogon joined
[23:24] <pugs_svnbot> r18361 | avar++ | Docs for Runtime::Perl6::Scope based on small discussion with fglock++

[23:24] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18361

[23:24] <lambdabot> Title: Changeset 18361 - Pugs - Trac

[23:24] <avar> I got distracted looking at assignments:)

[23:27] *** melissa left
[23:29] *** amnesiac joined
[23:33] *** FurnaceBoy joined
[23:35] *** jjore-1 joined
[23:39] <pugs_svnbot> r18362 | avar++ | nuke some whitespace

[23:39] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/18362

[23:39] <lambdabot> Title: Changeset 18362 - Pugs - Trac

[23:43] *** drupek12 joined
[23:47] *** SCalimlim joined
[23:51] *** FurnaceBoy left
[23:51] *** jjore-w left
