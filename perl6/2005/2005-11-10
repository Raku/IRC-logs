[00:00] <buu> Heh, that's silly.

[00:00] <buu> ?eval my @x = (0...); 

[00:00] <evalbot_7917> pugs: out of memory (requested 1048576 bytes) 

[00:00] <buu> =[

[00:00] <buu> Stupid nonlazy pugz0r

[00:00] <mugwump> ?eval my $x = [0...];

[00:00] <evalbot_7917> pugs: out of memory (requested 1048576 bytes) 

[00:00] <mugwump> ?eval my $x = (0...);

[00:00] <evalbot_7917> pugs: out of memory (requested 1048576 bytes) 

[00:00] <mugwump> :/

[00:03] <geoffb> Lazy is implemented in the P5 backend, not in the Haskell backend (yet)

[00:03] <geoffb> (Probably JS works too, knowing iblech)

[00:36] <buu> P5 back end?

[00:37] <wolverian> pugs -h, see the -C argument

[06:33] <SoHaN> anyone alive to help me run perl scripts in windows xp? 

[06:33] <obra> SoHaN: you want #perlhelp or maybe #perl

[06:37] <SoHaN> ok thanks :)

[06:37] <obra> zkaia

[06:37] <obra> mischan

[06:58] <svnbot6> r7918 | Darren_Duncan++ |  r771@Darren-Duncans-Computer:  darrenduncan | 2005-11-09 22:55:47 -0800

[06:58] <svnbot6> r7918 | Darren_Duncan++ |  /ext/Rosetta-Incubator : updated Rosetta-Incubator collection version to 6.0.0 from 0.0.1, following Pugs' example; fixed bugs in Locale::KeyedText SYNOPSIS; removed 'use 5.008001' and 'use utf8' pragmas from Makefile.PL

[07:34] <svnbot6> r7919 | Ovid++ | Added "Managing instance data" to cookbook.  Needs much

[07:34] <svnbot6> r7919 | Ovid++ | more work (as does all of the cookbook)

[08:50] <gaal> has anyone been working on "leave"?

[10:35] <svnbot6> r7920 | Darren_Duncan++ |  r773@Darren-Duncans-Computer:  darrenduncan | 2005-11-10 02:31:48 -0800

[10:35] <svnbot6> r7920 | Darren_Duncan++ |  /ext/Rosetta-Incubator : added new file /docs/Copying which outlines my copyright related intentions for Rosetta

[11:59] <cognominal_> ?eval rx |a|

[11:59] <evalbot_7920> {rule} 

[12:00] <cognominal_> ?eval rx|a|

[12:00] <evalbot_7920> {rule} 

[12:00] <cognominal_> ?eval ref rx|a|

[12:00] <evalbot_7920> ::Pugs::Internals::VRule 

[12:00] <cognominal_> ?eval my $a. ref \$a

[12:00] <evalbot_7920> Error:  unexpected "." expecting word character, "::", trait, "=", ".=", ":=", "::=", ";" or end of input 

[12:00] <cognominal_> ?eval my $a; say  ref \$a

[12:00] <evalbot_7920> Scalar bool::true 

[12:22] <gaal> ?eval given <a b> { when {.join eq "ab"} { say "closure smartmatch" } }

[12:22] <evalbot_7920> Error: No compatible subroutine found: "&when" 

[12:22] <gaal> ?eval given <a b> { when -> {.join eq "ab"} { say "closure smartmatch" } }

[12:22] <evalbot_7920> Error: No compatible subroutine found: "&when" 

[12:54] <svnbot6> r7921 | iblech++ | * Usual svn props.

[12:54] <svnbot6> r7921 | iblech++ | * examples/cookbook/13classes-objects-and-ties/13-03managing-instance-data.p6:

[12:54] <svnbot6> r7921 | iblech++ |   Fixed the declaration of &length --

[12:54] <svnbot6> r7921 | iblech++ |     multi method length ($self: $new_length) {...}

[12:54] <svnbot6> r7921 | iblech++ |     multi method length ($self:)             {...return length...}

[12:54] <svnbot6> r7921 | iblech++ |     # These declaration do *not* allow lvalue access, i.e.

[12:54] <svnbot6> r7921 | iblech++ |     $foo.length = 42;  # is invalid.

[12:54] <svnbot6> r7921 | iblech++ |   Instead, you've to use Proxy.

[12:59] <wolverian> what's wrong with 'has'? :)

[13:24] <Limbic_Region> anyone know what's up with use.perl journals ???

[13:34] <kolibrie> I get connection refused

[13:40] <xinming> maybe sys-admin happened to type reboot. :-)

[13:48] <Limbic_Region> oh, I can connect - but the link to journals returns the main page and if you attempt to go to a specific users journal it is completely blank

[13:48] <Limbic_Region> oh wait, now I can't connect at all

[13:50] <xinming> It seems that the system is down, for maintance?

[13:54] <Limbic_Region> dunno

[13:54] * Limbic_Region doesn't know where pudge hangs out online

[14:00] <broquaint> #perl on irc.perl.org, but he's not about atm.

[14:08] <Limbic_Region> oh, well it looks like the site is undergoing changes

[14:08] <Limbic_Region> I have just now been able to get to the journals but not by normal paths

[15:55] <gaal> could someone explain the deal with the Proxy, eg. in the last commit? Why isn't `has $.length` sufficient?

[15:56] * eric256 backlogs

[15:56] <eric256> it just says that the way they defined it you can't use it as an lvalue

[15:57] <eric256> i dunno why they defined it like that though. ;)

[15:58] <eric256> looks like the example has just been slowly mutated. probably adding some checks to it would make it make more sense.

[15:59] <eric256> do those cook book examples make directly to the original book?

[15:59] <gaal> when is Proxy actually to be used at all?

[15:59] <eric256> when you want an lvalue that you can verify the value you are setting

[15:59] <eric256> int this case you might not want to allow negative lengths ;)  or require length to be an Int and not a Float

[16:00] <wolverian> eh

[16:00] <wolverian> I thought: has $.foo where { ... }; worked

[16:00] <wolverian> maybe I remember wrong

[16:01] <gaal> Int $.length; can help with the int requirement, although last i heard that'd do a coercion and not raise an error.

[16:01] <eric256> where can impose restrictions i think. but what if the object held a string and changing the length should affect the string? the you would need a proxy

[16:01] <gaal> but: okay, i think i get it. :-)

[16:01] <eric256> the whole lvalue vrs getter/setter holy war aside

[16:02] <gaal> I in general like to leave holy wars aside.

[16:02] <wolverian> there is no holy war. only a bad perl5 implementation.

[16:02] <eric256> TIMTOWTDI

[16:02] <eric256> wolverian  there is definitly a war over lvalues, getters setters, and a single getter/setter of the same name. ;)

[16:03] <wolverian> meh. not in perl6 and C#.

[16:03] * eric256 has heard it argued that objects should never have properties...though i never understood that.

[16:03] <wolverian> both use lvalue properties.

[16:04] <eric256> using and having them doesn't mean there isn't a raging debate about weather they should have them or should use them.  me though, the more options the better

[16:05] <wolverian> anyone who uses .getFoo .setFoo in perl6 will be ridiculed. I hope.

[16:05] <wolverian> it just doesn't make any sense when the language so strongly recommends .foo

[16:05] <svnbot6> r7922 | iblech++ | examples/cookbook/13classes-objects-and-ties/13-03managing-instance-data.p6:

[16:05] <svnbot6> r7922 | iblech++ | Clarified my XXX comment.

[16:06] <eric256> see wolverian you have the makings of a relegious warrior on the topic yet!

[16:06] <wolverian> I've just been coding java lately (university course)

[16:06] <wolverian> it might not make me religious, but it sure as hell makes me disgruntled.

[16:07] <gaal> hey, what does Code<> and Code<$> mean?

[16:07] <gaal> Context: L<S04/"Smart matching">

[16:07] <gaal> code with arity zero and one respectively?

[16:08] <wolverian> the <>s are probably signatures, although they should be Code\() or Code:() nowadays

[16:08] <wolverian> I think.

[16:08] <gaal> okay, asking the list.

[16:09] <wolverian> gaal++

[16:21] <svnbot6> r7923 | kane++ |  r132@coke:  kane | 2005-11-10 17:19:19 +0100

[16:21] <svnbot6> r7923 | kane++ |  * document what .jib files are

[16:21] <svnbot6> r7924 | gaal++ | t/statements/given.t: add tests CODE matcherands

[16:22] <gaal> (I'm looking into when CODE in .hs now)

[16:23] <eric256> sweet ;)

[16:25] <eric256> hmmm does that mean that $obj ~~ { .test; .whatever} automaticaly topicalizes the lhs for that block? an obfu given $obj { .test; .whatever } ;)

[16:30] <gaal> :)

[16:31] <gaal> no, just calls code($_) automatically if the code wants it.

[16:31] <gaal> hey liz6 

[16:31] <liz6> hey gaal

[16:31] <liz6> seen autrijus

[16:31] <jabbot> liz6: autrijus was seen 22 hours 31 minutes 13 seconds ago

[16:31] <liz6> hmm...

[16:31] <eric256> that might be a record for autrijus

[16:33] <liz6> this could have been when autri was still in helsinki...

[16:33] <gaal> he popped by to say hello from .tw

[16:33] <liz6> ah, ok

[16:33] <liz6> good to know autri is back...

[16:34] <liz6> back to $work I'm afraid... ;-)

[16:34] <eric256> $work ~~ 'evil' ;)

[16:34] <gaal> App !Exp !(Maybe Exp) ![Exp] keeps confusing me

[16:34] <gaal> the maybe is the invocant, yes?

[16:35] * eric256 wonders if we could have > and  5 and << 10)

[16:35] <eric256> but i guess if  (5 < $x < 10)  is pretty cool

[16:35] <gaal> is it ok to to call a regular sub with a NOthing invocant and one arg?

[16:41] <gaal> ok to import Pugs.Prim.Code into Pugs.Prim.Match or is that a layering violation?

[16:44] * eric256 stares at gaal for moment. lol

[16:45] <gaal> eric256: it is perfectly natural behavior, i assure you, to procastinate about writing English by writing Haskell.

[16:59] <gaal> hey, is ghci still useful?

[16:59] <gaal> or rather: hey, hasn't ghci become useless?

[17:04] <wolverian> why was autrijus in helsinki, btw?

[17:04] <wolverian> and why didn't I meet him? :)

[17:07] <gaal> connection.

[17:07] <gaal> i think

[17:10] <wolverian> ah, okay.

[17:11] <eric256> and  he doesn't like you!!! ;) j/k

[17:20] <gaal> anyone know a quick way to find the topic?

[17:20] <gaal> $_ in .hs, not the channel topic :)

[17:20] <gaal> oh, silly me, readVar "$_"

[17:27] <gaal> sweet, sweet words: Looks like 2 tests of 49 passed unexpectedly

[17:33] <svnbot6> r7925 | gaal++ | * when CODE:

[17:33] <svnbot6> r7925 | gaal++ |   * given { when &sub { ... } } works for 0- and 1-arity subs.

[17:33] <svnbot6> r7925 | gaal++ |   * still TODO: when { bare closure }, as this requires parser tweaking.

[17:33] <svnbot6> r7925 | gaal++ |   * tests.

[17:37] <eric256> did you just fix the smart match operator?

[17:38] <gaal> partly.

[17:38] <gaal> working on another part.

[17:39] <gaal> $moose ~~ &somesub now works. this does *not* topicalize $moose at all, in fact it's ignored completely.

[17:40] <gaal> if somesub wants an arg, $_ will be it.

[17:40] <theorbtwo> Blink... I thought topicalizing and setting $_ were the same thing.

[17:41] <theorbtwo> ?eval $_='foo'; 'bar' ~~ sub {say $_}

[17:41] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[17:41] <theorbtwo> Huh?

[17:42] <gaal> it doesn't set $_. it calls somesub with the current $_, which in a given block, happens to be the other matcherand.

[17:43] <gaal> hmm!

[17:44] <geoffb> oh, theorbtwo, dia turned out to work Just Fine for me . . . autrijus' suggestion of SQL::Translator looked cool, but output quite a mess.

[17:44] <geoffb> Um, so, thanks theorbtwo .  :-)

[17:46] <theorbtwo> Welcome.

[17:47] <gaal> ?eval sub x { say $^val } "moose" ~~ $x

[17:47] <evalbot_7925> Error: Undeclared variable: "$x" 

[17:47] <gaal> ?eval sub x { say $^val } "moose" ~~ &x

[17:47] <evalbot_7925> Error: Undeclared variable: "$^val" 

[17:47] <gaal> ?eval sub x ($val) { say $val } "moose" ~~ &x

[17:47] <evalbot_7925> perl6 bool::true 

[17:48] <gaal> ?eval $_ = 42; sub x ($val) { say $val } "moose" ~~ &x

[17:48] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[17:48] <gaal> where's THAT coming from?

[17:48] <gaal> sub x ($val) { say $val } given 42 { when &x { say "again" } }

[17:49] <gaal> ?eval sub x ($val) { say $val } given 42 { when &x { say "again" } }

[17:49] <evalbot_7925> 42 again bool::true 

[17:49] <gaal> obviously readVar wasn't enough :/

[17:59] <eric256> why not? that last test was perfect

[17:59] <gaal> yes, but the straight smartmatch, which ought also work, by right, does not

[18:00] <gaal> ?eval $_ = 42; sub x ($val) { say $val } "moose" ~~ &x

[18:00] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[18:00] <eric256> ?eval $_ = 42; sub x ($val) { say $val }; "moose" ~~ &x

[18:00] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[18:00] <gaal> and I'm puzzled about that VStr "perl6". Where'd it come from?

[18:00] * eric256 scratches his head. lol. that is interesting

[18:01] <wolverian> ?eval say $_

[18:01] <evalbot_7925> perl6 bool::true 

[18:01] <wolverian> there you go :)

[18:01] <eric256> lol. 

[18:01] <dada> ?eval say

[18:01] <evalbot_7925>  bool::true 

[18:01] <wolverian> ?eval $_

[18:01] <evalbot_7925> \"perl6" 

[18:01] <eric256> ?eval $_ = 42; sub x ($val) { say $val }; given 42 { "moose" ~~ &x; } 

[18:01] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[18:02] <wolverian> ?eval my $_ = 42; sub x ($val) { say $val }; given 42 { "moose" ~~ &x; }

[18:02] <evalbot_7925> 42 bool::true 

[18:02] <eric256> ?eval sub x ($val) { say $val }; given 42 { say $_; "moose" ~~ &x; } 

[18:02] <evalbot_7925> 42 42 bool::true 

[18:02] * eric256 can't find assignment of perl6 to $_ anywhere in source...odd

[18:03] <dada> isn't it @ARGV[0] or some such?

[18:03] <dada> err, $0 maybe

[18:03] <gaal> ?eval $?PROGRAM_NAME

[18:03] <evalbot_7925> Error: Undeclared variable: "$?PROGRAM_NAME" 

[18:03] <gaal> ?eval $*PROGRAM_NAME

[18:03] <evalbot_7925> \undef 

[18:03] <eric256> grep perl6 -r * turns up nothing looking like an assignment of perl6.

[18:04] <gaal> yeah

[18:04] <eric256> its magic!

[18:04] <dada> perl6 has a strong ego :-)

[18:05] <gaal> anymoose, i'll ignore that for now and work on the bare closure thing :)

[18:06] <eric256> oddly say $_ on feather doesn't print perl6

[18:06] <eric256> could it actauly be evalbot's doing?

[18:06] <gaal> not impossible! :)

[18:07] <gaal> but it's also the unmodifiability of this that's weird

[18:07] <gaal> ?eval $_

[18:07] <evalbot_7925> \"perl6" 

[18:07] <gaal> aaaahhh it isn't the smart match that's failing at all is it? it's the $_ being read only

[18:07] <gaal> and me being thick.

[18:07] * xinming wonders if there is a way to list all attributes for an instance

[18:08] <eric256> yea. lol

[18:08] <gaal> yes, $obj.perl

[18:08] <eric256> sorry thought you were on that track already

[18:08] <xinming> oops. forgot the .perl method. :-)

[18:08] <gaal> ?eval class Foo; has $.paws; Foo.new(paws=>4).perl

[18:08] <evalbot_7925> "Foo.new((\"paws\" => 4),);" 

[18:09] * xinming loves perl more and more... :-P

[18:09] <cognominal_> ?eval my ($perl6, $needed, $possible); given $perl6 {   when $needed { 'dynamic' } when  $possible { 'static' } }

[18:09] <evalbot_7925> "dynamic" 

[18:09] <cognominal_> :)

[18:09] <gaal> ?eval { $_ = 42; sub x ($val) { say $val } "moose" ~~ &x}

[18:09] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[18:10] <eric256> ?eval { my $_ = 42; sub x ($val) { say $val } "moose" ~~ &x}

[18:10] <evalbot_7925> 42 bool::true 

[18:10] <xinming> Perl 6 rules the world.

[18:10] <eric256> no my so your still attatcking that weird $_ ;)

[18:10] <dada> ?eval { $_ = 42; }

[18:10] <evalbot_7925> Error: Can't modify constant item: VStr "perl6" 

[18:11] <gaal> well, whatever, i'll just ignore this for now :)

[18:11] <xinming> ?eval $_ is rw { $_ = 42 };

[18:11] <evalbot_7925> undef 

[18:11] <gaal> ruleCondPart can use some teasing apart

[18:11] <xinming> ?eval { $_ is rw = 42 };

[18:11] <evalbot_7925> undef 

[18:11] <eric256> anyone else try this localy?  i can't reproduce except on eval bot

[18:12] <eric256> ?eval eval { $_ }

[18:12] <evalbot_7925> "SubBlock(<anon>)" 

[18:12] <cognominal_> hum, I wonder why it returned "dynamic"

[18:12] <gaal> eric256: maybe look at the source for evalbot, i bet it does some sub {  } wrapping a la mod_perl

[18:12] <xinming> eric256: in interactive shell, It seems that $_ is rw by default.

[18:12] <dada> ?eval my $x; $x;

[18:12] <evalbot_7925> \undef 

[18:12] <dada> ?eval my $x; ?$x;

[18:12] <evalbot_7925> bool::false 

[18:13] <dada> ?eval my $x, $y; $x ~~ $y;

[18:13] <evalbot_7925> Error:  unexpected "," expecting word character, "::", trait, "=", ".=", ":=", "::=", ";" or end of input 

[18:13] <dada> ?eval my $x; my $y; $x ~~ $y;

[18:13] <evalbot_7925> bool::true 

[18:13] <dada> cognominal_: that's why, I suppose

[18:16] <eric256> gaal... i have been looking at evalbot but i can't find where it could be doing that, unless eval bot is running different source code than whats in the repository

[18:17] <eric256> cognominal it reutrned dynamic because all your vars are undef, so the first one matches  ($perl = undef) ~~ ($dynamic = undef) == true

[18:18] <gaal> hey, anyone know if there's a good reason why ruleGivenConstruct has

[18:18] <gaal> topic <- ruleCondPart

[18:18] <gaal> ? that looks like just some sneaky convenience

[18:18] <gaal> because, well, the topic part in a given declaration is just an expression

[18:20] <cognominal_> dada: indeed

[18:20] <eric256> are you wondering why its not ruleExp (or whatever that is without looking at the source)

[18:21] <gaal> or something like that, yes. i'm now adding blocks as an alternative to ruleCondPart, and am a little wary if it's used hackily by other thigns

[18:22] <eric256> are blocks acceptable in conditions?

[18:22] <eric256> if { } {} else {} seems wierd

[18:22] <gaal> well, "moose" ~~ { .is_blue } uses ruleCondPart...

[18:22] <eric256> plus don't you want to add blocks to the when construct not given?  maybe /me should look at source before speaking more though

[18:23] <eric256> ahh

[18:23] <gaal> i do, i do

[18:23] <gaal> but i see ruleCondPart is used in all sorts of place.

[18:23] <gaal> places

[18:23] <gaal> maybe i'll add a rule just for when.

[18:23] <gaal> i think this oughta be made to work too though:

[18:24] <gaal> when -> ($x) { $x } {...}

[18:24] <gaal> confusing, yes :/

[18:24] <eric256> yes... trying to make $x =:= $_ ?

[18:25] <gaal> oh, never mind the content of the block :)

[18:25] <gaal> i meant putting in a pointy for a closure for a when clause.

[18:47] * eric256 got confused and thought you did

[18:47] <eric256> given -> ($x) {$x}  { ... }

[18:47] <eric256> which makes nooo sense. lol

[18:48] <eric256> yes pointy closurs on when blocks would be cool

[18:56] <gaal> unfortunately just sticking either ruleBlock or ruleBlockLiteral to the alternatives in ruleCondPart doesn't make it work :-)

[19:08] <gaal> oh, the things that amuse me

[19:08] <gaal> the recent commit message showed up in the rss feed

[19:08] <gaal> but &sub changed to ⊂ 

[19:09] <gaal> hm, which my current font doesn't display.

[19:09] <gaal> that's a subset symbol.

[19:10] <gaal> something that amuses me less is that i'd forgoten some bread in the oven for 20 minutes at high heat :(

[19:11] <eric256> lol

[19:11] <gaal> of course remembering the bread also reminded me i was hungry!

[19:23] <cognominal_> ?eval  my (Num $i, Int  $j);

[19:23] <evalbot_7925> Error:  unexpected "N" expecting variable name, "undef" or ")" 

[19:23] <cognominal_> ?eval my Num $i

[19:23] <evalbot_7925> undef 

[19:23] <cognominal_> ?eval my Int $j

[19:23] <evalbot_7925> undef 

[19:24] <cognominal_> ?eval  my  Num ( $i,  $j);

[19:24] <evalbot_7925> undef 

[19:24] <cognominal_> ?eval  my  int  ( $i,  $j);

[19:24] <evalbot_7925> undef 

[19:27] <cognominal_> ?eval  my @a = [ 33, 44, 55]; my @b = @a[1,2]; say @b

[19:27] <evalbot_7925>  bool::true 

[19:27] <cognominal_> ?eval say @a

[19:28] <evalbot_7925> Error: Undeclared variable: "@a" 

[19:28] <cognominal_> hum, I guest I got splicing wrong

[19:30] <cognominal_> ?eval  my @a = [ 33, 44, 55]; my @b = $a[1,2]; say @b

[19:30] <evalbot_7925> Error: Undeclared variable: "$a" 

[19:31] <cognominal_> ?eval  my @a = [ 33, 44, 55]; my @b = @a[[1,2]]; say @b

[19:31] <evalbot_7925> Error:  unexpected "[" expecting word character, "::", term postfix, operator, ";" or end of input 

[19:47] <dada> ?eval  my @a = [ 33, 44, 55]; my @b = @a[1,2]; @b

[19:47] <evalbot_7925> [undef, undef] 

[19:47] <dada> ?eval  my @a = (33, 44, 55); my @b = @a[1,2]; @b

[19:47] <evalbot_7925> [44, 55] 

[19:48] <dada> yup

[19:48] <dada> ?eval  my @a = [33, 44, 55]; my @b = @a[0]; @b

[19:48] <evalbot_7925> [33, 44, 55] 

[20:42] <cognominal_> ?eval my @a = [ 33. 444. 66]; say length @a

[20:42] <evalbot_7925> Error:  unexpected "[" expecting expression 

[20:42] <cognominal_> ?eval my @a = [ 33, 444,  66]; say length @a

[20:42] <evalbot_7925> Error: No compatible subroutine found: "&length" 

[20:43] <cognominal_> ?eval my @a = [ 33, 444,  66]; my $a = @a; say $a

[20:43] <evalbot_7925> 33 444 66 bool::true 

[20:43] <obra> seen autrijus 

[20:43] <jabbot> obra: autrijus was seen 1 days 2 hours 42 minutes 52 seconds ago

[20:43] <cognominal_> ?eval my @a = [ 33, 444,  66]; my $a = @a; say ref $a

[20:43] <evalbot_7925> Array bool::true 

[20:44] <cognominal_> ?eval  my @a = [ 33, 44, 55]; my @b = @a.[1,2]; say @b

[20:44] <evalbot_7925>  bool::true 

[20:44] <cognominal_> ?eval  my @a = [ 33, 44, 55];  say @a[0]

[20:44] <evalbot_7925> 334455 bool::true 

[20:45] <cognominal_> ?eval  my @a = [ 33, 44, 55];  say @a.[0]

[20:45] <evalbot_7925> 334455 bool::true 

[20:46] <cognominal_> ?eval  my @a = [ 33, 44, 55];   @a.[0]

[20:46] <evalbot_7925> [33, 44, 55] 

[20:47] <cognominal_> ?eval  my @a = ( 33, 44, 55);   @a.[0]

[20:47] <evalbot_7925> \33 

[20:47] <cognominal_> ?eval  my @a = ( 33, 44, 55);   @a[0]

[20:47] <evalbot_7925> \33 

[21:00] <Juerd> Please use a real pugs :)

[21:11] <dada> ?eval my @a = [33, 444, 66]; elems @a

[21:11] <evalbot_7925> 1 

[21:12] <dada> cognominal_: elems, not length

[21:13] <cognominal_> yea, I badly need to reread the synopses...

[21:15] <azuroth> or "+@a" I think

[21:31] <gaal> @a in scalar context, in general.

[21:31] <wolverian> gaal, numeric context.

[21:32] <gaal> ?eval my @a = <a b c>; my $x = @a; $x

[21:32] <evalbot_7925> ["a", "b", "c"] 

[21:32] <gaal> ahem.

[21:33] <gaal> ?eval my @a = <a b c>; my $x = scalar @a; $x # i wonder what this button does

[21:33] <evalbot_7925> Error: No compatible subroutine found: "&scalar" 

[21:33] <azuroth> in string context it's like .join(" ") I think

[21:33] <gaal> heh. i suppose a string context would concatenate?

[21:34] <gaal> heh again.

[21:35] <gaal> well, i'm off to read some more TaPL then zzzZZs. see ya &

[21:35] <azuroth> night

[21:55] <r0nny_> re

[21:57] <fglock> hi all

[22:09] <Juerd> ? my @a = <a b c>; my $x = item @a; $x

[22:09] <Juerd> eh

[22:09] <Juerd> ?eval my @a = <a b c>; my $x = item @a; $x

[22:09] <evalbot_7925> ["a", "b", "c"] 

[22:10] <sili> what's item

[22:10] <Juerd> scalar context was renamed to item context, mostly to avoid confusion between scalar context and Scalar context.

[22:10] <eric256> ?eval my @a = <a b c>; @a;

[22:10] <evalbot_7925> ["a", "b", "c"] 

[22:11] <eric256> why would there be confusion between scalar and Scalar ?? :)

[22:11] <eric256> and what does item context do to an array?   not .pick which was my first guess

[22:11] <theorbtwo> Refify, I assume.

[22:12] <eric256> ?eval my @a = <a b c>; scalar @a'

[22:12] <evalbot_7925> Error:  unexpected "'" expecting word character, "::", term postfix, operator, ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[22:12] <eric256> ?eval my @a = <a b c>; scalar @a;

[22:12] <evalbot_7925> Error: No compatible subroutine found: "&scalar" 

[22:12] <eric256> ?eval my @a = <a b c>; ~@a;

[22:12] <evalbot_7925> "a b c" 

[22:12] <Juerd> eric256: Arrays and hashes return, in item context, a reference to themselves.

[22:13] <Juerd> eric256: This is sometimes called "autoreferencing", which isn't actually very true.

[22:13] <eric256> are there words for ~, +, ?   ...juerd yes that makes sense i think.  just not dwim the first tiem, but from then on 

[22:13] <Juerd> There is a word for ?, not for ~ or +.

[22:13] <Juerd> The word is "true". It's a bad, bad word, but english lacks a negation of "not".

[22:14] <eric256> true? instead of bool?

[22:14] <Juerd> bool is already the name of a type.

[22:14] <theorbtwo> In conversation, boolify, stringify, and nummify.

[22:14] <eric256> not is the negation of not.;) its not not cold outside

[22:14] <Juerd> eric256: Dutch has the word "wel", which negates "niet" (not)

[22:14] <theorbtwo> indeed.

[22:15] <eric256> hmmm.  true "1" == true "0"

[22:15] <theorbtwo> if (indeed $obj) {...}

[22:15] <Juerd> theorbtwo: Has been suggested, iirc.

[22:15] <theorbtwo> I'm not at all surprised.

[22:15] * eric256 lacks the brain power to even figure out what a negation of not would be

[22:15] <Juerd> theorbtwo: I like it a lot better than "true", which I find misleading and looking like a sign of desperation.

[22:15] <theorbtwo> BTW, somebody was looking for you on slashnet/#perlmonks earlier.

[22:15] <liz6> how abou "aye"

[22:15] <eric256> i am not suprised, i am indeed suprised, i am true surprised.  hmmm

[22:16] <Juerd> liz6: "aye" works well as a term, but not as a prefix thing, I think. Just like "true".

[22:16] <theorbtwo> I don't see why it needs a stringy name at all.

[22:16] <theorbtwo> ...and I'd /much/ rather see true and false be names for the cannonical true and false values.

[22:16] <Juerd> theorbtwo: Because it's a logical operator as well as a type caster.

[22:16] <Juerd> theorbtwo: And we have high precedence and low precedence forms for those things.

[22:17] <eric256> yes if (?$test) {} reads easier than if (true $test)....maybe not easier. but harder to misunderstand

[22:17] <Juerd> theorbtwo: The low precedence ones are words.

[22:17] <theorbtwo> Sorry, they were looking for Juke, not Juerd -- I have a bad memory for names.

[22:17] <theorbtwo> Hmm.

[22:17] <Juerd> eric256: In boolean context, it is completely redundant and I would advise against using it.

[22:17] <eric256> Juerd can you provide an example of the difference between + and ? in this thinking.  i'm finding all this hard to wrap my head around

[22:18] <liz6> how about "ack" ?

[22:18] <Juerd> liz6: Tricky.

[22:18] <eric256> when is ? if not in bool context? 

[22:18] <Juerd> liz6: But my liking "indeed" much clouds judgement.

[22:18] <theorbtwo> Thanks.

[22:18] <liz6> 3 letters more!  ;-)

[22:18] <cognominal_> what is the syntax of the arithmetic if?

[22:18] <eric256> indeed it is

[22:19] <Juerd> You'll only be using this in the RHS of assignment anyway! :)

[22:19] <eric256> cognomials...you mean trinary? my $x = $test ?? 1 !! 2;

[22:19] <cognominal_> I thought it was  $a ?? $b :: $c

[22:19] <theorbtwo> eric256: my $knowntime = ?$time;

[22:19] <cognominal_> ok

[22:19] <eric256> :: became !!... which makes a certian kind of sense

[22:19] <cognominal_> thx eric256 

[22:19] <Juerd> cognominal_: No, :: is now !!, to better correspond to ? and !, which are "true" and "not"

[22:20] <Juerd> cognominal_: And to make parsing stuff with classes much easier.

[22:20] <Juerd> cognominal_: The RHS of ?? is what is done when the expression is true, the RHS of !! is what is done when it is not.

[22:20] <Juerd> (Oh god, that actually argues for "true")

[22:20] <theorbtwo> So it does...

[22:21] * liz6 wonders whether intelligent design is at work here...

[22:21] <Juerd> Hahaha

[22:22] <Juerd> Do note the lcfirst :)

[22:22] <liz6> ;-)

[22:23] * theorbtwo would never have thought he'd "yey" Dover, PA of all places.

[22:23] <Juerd> "Om de rest van de updates te installeren, moet u LiveUpdate nogmaals uitvoeren."

[22:23] <Juerd> WTF?

[22:24] <Juerd> Prutsers.

[22:24] * theorbtwo wonders if babelfish does Dutch.

[22:24] <Juerd> Het zij ze vergeven omdat ik vandaag bij Symantec heerlijke jus d'orange heb gekregen, maar anders was ik nu toch wel zo vreselijk verontwaardigd!

[22:24] <theorbtwo> (Yes.)

[22:26] * Juerd wonders if Babelfish makes sense of this :)

[22:26] <theorbtwo> More or less, except for "Prusters".

[22:26] <theorbtwo> And jus d'orange, which I assume is actually french.

[22:26] <Juerd> Perhaps because it's prutsers, not prusters.

[22:27] <theorbtwo> They them forgive because I have today got d'orange at Symantec delicious gravy, but I had been differently incensed now nevertheless this way terribly!

[22:27] <Juerd> It's French, yes. It means: orange juice.

[22:27] <liz6> jus d'orange => OJ

[22:27] <Juerd> That translation's funny.

[22:28] <theorbtwo> Doesn't get either, Juerd.

[22:28] * Juerd can't even come up with a correct translation of prutser :)

[22:28] <Juerd> liz6? :)

[22:28] <liz6> yes?

[22:29] <Juerd> Do you happen to know a translation for prutser?

[22:29] <liz6> ah, 

[22:30] <liz6> tinkerer according to the dictionary

[22:30] <Juerd> Oh, that's a good one.

[22:30] <liz6> but that doesn't convey the negative connotations, I think...

[22:30] <Juerd> Oh, then I've always read it wrong :)

[22:30] <Juerd>        3: an unskilled person who tries to fix or mend [syn: {tinkerer}]

[22:30] <Juerd> That does sound negative

[22:31] <Juerd> Though it doesn't necessarily have to do with fixing or mending. Here, it's about creating.

[22:31] <liz6> tinkering charlatans?

[22:31] <Juerd> Hehe

[22:31] <Juerd> In this case, yea :)

[22:32] <Juerd> Esp. considering the bar with free drinks :)

[22:33] <eric256> why does Symantec have delicious gravy?

[22:33] <Juerd> No, orange juice

[22:34] <Juerd> But the Dutch word "jus" (which is actually the French word "jus") doesn't quite mean the same as the French word "jus".

[22:34] <Juerd> If that makes any sense at all.

[22:34] <Juerd> "jus" in Dutch means gravy, except in French or drink context, then it means juice :)

[22:34] <eric256> sure. lol. jus translated to gravy then? but was meant in the frenche joice way?

[22:35] <eric256> lol

[22:35] * eric256 still has no idea what the translation meant

[22:35] <eric256> you were mad at them, but then you got free orange juice so now you aren't as mad?

[22:36] <Juerd> Sort of :)

[22:36] <liz6> except he got the OJ before he got mad, right?

[22:37] <Juerd> Yes

[22:37] <Juerd> So I actually didn't get mad :)

[22:37] * Juerd so feels sorry for eric256's brain right now :)

[22:38] <Juerd> Eh, s/so feels/{ $/.split.reverse.cat }/

[22:38] <Juerd> Make that s/cat/join/

[22:38] <theorbtwo> Does join with no non-invocant parameter join with ' '?

[22:39] <Juerd> Yes.

[22:39] <Juerd> Or, well, it should.

[22:39] * theorbtwo nods.

[22:39] <Juerd> I'm not entirely sure it's blessed.

[22:39] <Juerd> If split defaults to ' ', then join should too.

[22:39] * theorbtwo nods.

[22:40] <theorbtwo> Though split doesn't exactly default to ' ', more like rx:p5/\s+/.

[22:40] <Juerd> That is irrelevant.

[22:41] <Juerd> We can't join on a regex meaningfully :)

[22:41] <Juerd> See also the p6l thread "lists in string context"

[22:41] * theorbtwo nodsnods.

[22:42] <eric256> split defaults to \s+ magic,   join defailts to '' not ' '

[22:42] <eric256> ?eval "hello".split.join

[22:42] <evalbot_7925> "hello" 

[22:42] <eric256> ?eval "hello world".split.join

[22:42] <evalbot_7925> "helloworld" 

[22:43] <Juerd> Then join is wrong.

[22:43] <eric256> hehehe. i had that exact conversation with someone else the other day. ;) /me agrees

[22:43] <eric256> ~@a and @a.join should come out the same.  relativly

[22:43] <Juerd> Indeed.

[22:44] <Juerd> And cat should be &join.assuming(sep => '')

[22:44] * eric256 considers making a bot to track eachs days most popular word. ;)

[22:44] * theorbtwo suspects "the" and "and" will be front-runners.

[22:44] <eric256> theorbtwo what a buz killer ;)

[22:45] <Juerd> There was a bot in one of Dutch channels I was in that would keep such statistics per user.

[22:45] <Juerd> It turned out that the arrogant people indeed did use "ik" (I) much more often than others :)

[22:45] <cognominal_> ?eval  my @a = <a b>;  my $rx = rx| @a|;  say "a" ~~ $rx

[22:45] <evalbot_7925> *** Cannot parse PGE: :w:: @a *** Error: end of file  bool::true 

[22:45] * Juerd was one of them, unfortunately.

[22:46] * theorbtwo lols at Juerd.

[22:46] <Juerd> Oh, 8 minutes until food supply closes

[22:46] <Juerd> brb

[22:47] <cognominal_> pugs>  my @a = <a b>;  my $rx = rx| @a|;  say "a" ~~ $rx

[22:47] <cognominal_> PackFile_unpack: Bytecode not valid for this interpreter: fingerprint mismatch

[22:47] <cognominal_> Parrot VM: Can't unpack packfile /usr/lib/parrot/runtime/library/PGE.pbc.

[22:48] <cognominal_> problem on feather apparently

[22:48] <eric256> yea

[22:48] <cognominal_> pugs>  my @a = <a b>;  my $rx = rx| @a|;  

[22:48] <cognominal_> oops

[22:48] <eric256> rafl broke it and i havn't seen him lately

[22:48] <cognominal_> ?eval  my @a = <a b>;  my $rx = rx| @a|;  

[22:48] <evalbot_7925> \{rule} 

[22:49] <cognominal_> how come the bot behaves differently?

[22:49] <rafl> eric256: Here I am.

[22:49] <eric256> differently than what? than feather? because whoever runs the bot runs there own build of pugs for some reason. 

[22:49] <cognominal_> ok

[22:50] <eric256> rafl....PGE linkage/whatever borked

[22:50] <rafl> eric256: Yes. I don't know why, though. Will investigate tomorrow.

[22:50] <eric256> evil debian packages!! ;)

[22:51] <rafl> Eval broken parrot portability!

[22:52] <theorbtwo> rafl: When parrot breaks compatability, under normal debianish rules, you should make a parrot(++$n) package.

[22:52] <theorbtwo> I think...

[22:52] <theorbtwo> And make them conflict if they cannot be done asside each-other.

[22:53] <theorbtwo> OTOH, I think Parrot is sufficently betaish to ignore that and go with the "you get to keep both pieces" policy.

[22:53] <rafl> theorbtwo: Err. I'll simply fix parrot and update the package.

[22:53] <rafl> theorbtwo: Who to conflicting parrot packages?

[22:56] <theorbtwo> Umm?

[22:56] <Juerd> re

[22:56] <eric256> that made as much sense as juerds rumbling about orange juice

[22:57] <eric256> $last.subst("rumbling", "rambling");

[22:57] <Juerd> There and back in 10 minutes.

[22:57] <Juerd> Wow.

[22:58] <Juerd> Hm, does English lack positive words altogether?

[22:58] <Juerd> "back", the direction, does it have an opposite?

[22:58] <Juerd> I hope you like RPN or yodaspeak.

[22:58] <rafl> forward?

[22:58] <eric256> forward? ;)

[22:59] <Juerd> Hm, I guess :)

[22:59] <Juerd> Though you wouldn't use that to describe a route?

[22:59] <eric256> or front if you mean a side.  indeed, some positive words have we.

[22:59] <eric256> if you are on a route you would be assumed to be going forward

[23:00] <eric256> you might say "continue down that street"

[23:00] <Juerd> "forward" feels like the translation of "vooruit", not exactly that of "heen"

[23:01] * eric256 considers says "bless you" to juerd

[23:01] <Juerd> It's Dutch, not a scandinavian language.

[23:01] <liz6> "there and back"

[23:02] <Juerd> liz6: I started with that, but "there" doesn't quite cover uses of "heen" in Dutch. "heenreis"...

[23:02] <liz6> I think it does.

[23:02] <Juerd> "terugreis" can be translated using "back"

[23:02] <liz6> hmmm... wonder what the Dutch translation of "The Hobbit" was...

[23:02] <Juerd> Hehe :)

[23:03] <Juerd> Some things should be left untranslated :)

[23:03] <Juerd> And can be.

[23:03] <eric256> hmmm i wonder if you could teach a language by reading a book, then slowly translating portions of sentences and reread...repeat until entire book is in new language..... ;)

[23:03] <Odin-LAP> Juerd: "Should"?

[23:04] <Juerd> Odin-LAP: Your sentence incomplete.

[23:04] <Odin-LAP> Juerd: Dunno. Tolkien said he liked the Icelandic translation better than the original texts. ;)

[23:04] <Odin-LAP> (Of the Lord of the Rings, though, not the Hobbit...)

[23:04] <Odin-LAP> eric256: There is a method based on that...

[23:05] <Juerd> Original authors shouldn't be taken too seriously.

[23:05] <Odin-LAP> eric256: Should be based on relatively easier texts, though.

[23:05] <Juerd> (\lwall, perhaps)

[23:05] <Odin-LAP> Says who?

[23:05] <Juerd> Does your IRC client not show that?

[23:06] <Odin-LAP> Take nothing seriously. Turn everything into a joke.

[23:06] <Juerd> I guess that makes judging what is said rather than who says it easier, but it completely destroys the social aspect.

[23:07] <Odin-LAP> I'd suggest that the context is more important than the person.

[23:07] <Juerd> If you'd suggest that, I'd agree.

[23:07] <theorbtwo> English lacks the concept of a fully positive answer to a negitive question.

[23:07] <theorbtwo> Or, rather, a short way of saying "I reject the premise of this question".

[23:08] <theorbtwo> "Did you stop having sex with little children?"

[23:08] <Odin-LAP> theorbtwo: What language has that?

[23:08] <Juerd> Well, it has "Yes, it does!"

[23:08] <Odin-LAP> theorbtwo: "I never did."

[23:08] <theorbtwo> Odin: Say that in one word.

[23:08] <Juerd> But that doesn't quite count, because the "it does" part holds the actual boolean value, not the "yes".

[23:08] <Odin-LAP> theorbtwo: Why should I have to? Because you're obsessed with byte counts? :>

[23:08] <Juerd> Odin-LAP: Think of a positive for "not" where "not" is the negative form.

[23:09] <Juerd> That can be used in the same way: "I will not do that"

[23:09] <Juerd> "I will <...> do that"

[23:09] <Odin-LAP> Juerd: I *know* what you're talking about. I just don't think it's actually needed.

[23:09] <Juerd> Odin-LAP: It's not needed. Otherwise English would have died already.

[23:09] <Juerd> But it does kind of suck when in a programming language based on English, you need a negation of "not".

[23:09] <Odin-LAP> That's like arguing chinese is useless, because they often have to combine words to transmit even simple ideas.

[23:10] <Odin-LAP> That, however, is an entirely different matter. :p

[23:10] <Juerd> No, stating that a language lacks a certain feature is not at all like arguing that a language is useless.

[23:10] <liz6> how about "way"

[23:10] <theorbtwo> "way"?

[23:10] <liz6> (as opposed to "no way"

[23:11] <Juerd> my $is_cool = way $cool;

[23:11] <Juerd> Could work.

[23:11] <theorbtwo> my $has_time = way $time?

[23:11] <Juerd> waaaay time!

[23:11] <liz6> I was thinking Wayne's World here...

[23:11] <Odin-LAP> Juerd: Stating that a language's prominent feature is "unworkable", which was my implication, *is*. :)

[23:11] <liz6> they always had "way" as the negation of "no way"

[23:12] <theorbtwo> "no way" isn't really the right concept that we're trying to negate, though.

[23:12] <theorbtwo> Anyway, they often used "yes way", IIRC.

[23:12] <Odin-LAP> That explanation might be digging a bit to deep into pop culture?

[23:12] <liz6> perhaps...

[23:12] <Juerd> liz6: Again lack of negative for "no", so they just leave it out :)

[23:12] <Odin-LAP> s/to/too/; # AGH!

[23:13] <Juerd> liz6: We also do not have a good negative for "geen", but we can at least use an article (een) or number (een, comfortably) to make up for that :)

[23:13] <theorbtwo> geen == kein?

[23:13] <Juerd> theorbtwo: German for "geen" is "kein", indeed.

[23:14] <theorbtwo> English is doing the same thing there, but many words don't need an article in many positions.

[23:14] <Juerd> "no way", "a way" doesn't feel like a negation pair

[23:15] <Juerd> While "geen weg", "een weg" does. But this is probably only because English isn't my native language.

[23:15] <Juerd> (Translating "no way" literally makes little sense, though :))

[23:15] <theorbtwo> Is there a way to get what we want from here?  No, there is no way.

[23:15] <Odin-LAP> That 'no' isn't the same as the word 'no' you use to answer a question.

[23:15] <Odin-LAP> :p

[23:16] <Juerd> Odin-LAP: Exactly^WIndeed.

[23:16] <theorbtwo> German has actual different words for it -- kein and nein.  (I suspect Dutch does too.)

[23:16] <Juerd> theorbtwo: Yes: geen and nee ("neen" too)

[23:16] <Odin-LAP> Icelandic, too.

[23:16] <Odin-LAP> :)

[23:16] <rafl> theorbtwo: Oh, you're german? Will you be at the next german perl workshop? :-)

[23:17] <theorbtwo> No, I'm American.  I took German in high school.  (And didn't do very well.)

[23:17] <theorbtwo> I also lived in Germany for two years.

[23:17] <Juerd> Icelandic has all the neat features that Dutch and German have, because it hasn't devolved into shit, like English has.

[23:17] * theorbtwo likes English.

[23:17] <Odin-LAP> English is a nice language.

[23:17] <theorbtwo> I also note that we're talking English here, and not German, Dutch, Icelandic, or Chinese.

[23:18] <Juerd> theorbtwo: You just explained why. You're American :)

[23:18] <Odin-LAP> Sollen wir Deutsch sprechen, dann?

[23:18] <theorbtwo> English is an /amazingly/ successful language.

[23:18] <theorbtwo> Bissen.

[23:18] <Juerd> theorbtwo: Maybe you're not talking about those other languages (though I'd swear you were), but we certainly are!

[23:18] <SamB> Juerd: maybe you are confused with the related tongue known as "gibberish"

[23:18] <Odin-LAP> theorbtwo: Ja, aber warum?

[23:19] <theorbtwo> Odin: Wait... I think I answered that incorrectly, based on a bad guess of "Sollen".

[23:19] <Juerd> Deutsch saugt!  # und woerdliche uebersetzungen auch!

[23:19] <theorbtwo> We may be talking /about/ Germanic languages, but we're doing it /in/ English.

[23:19] <Odin-LAP> Anyhow. English is a nice language. It has next to no grammar, a smattering of basic words, and a vocabulary that no single species can master. *grin*

[23:20] <Odin-LAP> Actually, English *is* a germanic language.

[23:20] <Juerd> theorbtwo: My brane inserted "is" there.

[23:20] <buu> Juerd: You have a 'brane' ?

[23:20] <Juerd> buu: In Perl channels, yes.

[23:20] <buu> This is fascinating. Please tell more.

[23:20] <Juerd> It's slang.

[23:21] <Juerd> For an almost equally pronounced word.

[23:21] * liz6 wonders whether eliza is pretending to be buu

[23:21] <Juerd> Hehe.

[23:21] <Juerd> What makes you say this is fascinating, Please tell more?

[23:21] <Juerd> ... :)

[23:21] <theorbtwo> I hear often that English is a horrible languge, and I can believe it.  Clearly, however, it got something right, as it's hugely popular.

[23:22] <Juerd> theorbtwo: Oh, it does.

[23:22] <Juerd> theorbtwo: In the Microsoft way.

[23:22] <theorbtwo> When Russians send packages to the Arab-speaking world, what do they label the boxes in?

[23:22] <Juerd> theorbtwo: English or French, usually.

[23:23] <Juerd> Though I've received packages labelled in only Russian. They take at least a week longer.

[23:23] <Odin-LAP> theorbtwo: It's nothing to do with the language as such.

[23:23] <Odin-LAP> theorbtwo: It's pure politics.

[23:23] <Odin-LAP> Same reason as French dominated in Europe a while back.

[23:23] <Juerd> Odin-LAP: That's the long version of "In the Microsoft way." :)

[23:23] <Odin-LAP> (Why do you think it's "lingua france" and not "english language"? ;)

[23:23] <Odin-LAP> BAH!

[23:23] <Odin-LAP> s/france/franca/

[23:24] <Juerd> Which in turn is latin...

[23:24] <Juerd> Which used to be the lingua franca.

[23:24] <Juerd> I

[23:24] <Odin-LAP> Juerd: Indeed. Which is a further, humourous twist.

[23:24] <Juerd> I guess it's hard to start a trend and name it yourself.

[23:25] <theorbtwo> Odin: I think linguistics has /something/ to do with it.  /Largely/ politics, sure.

[23:25] <Juerd> theorbtwo: It's not excedingly hard and computers were first produced by americans, using ASCII. That too has helped English spread much.

[23:26] <theorbtwo> Another reason is that alphebetically, it's least-common-denominator of modern latin-derived langauges, of which there are a lot.

[23:28] <Juerd> I think that largely has to do with ASCII.

[23:28] <Odin-LAP> The only reason for that is that they actually dropped letters out when printing arrived.

[23:28] <Odin-LAP> Moreover, several loanwords are *properly* typeset with accents, which has receded lately, in substantial part due to ASCII.

[23:29] <Odin-LAP> ('th' used to have a seperate letter in English, just like in Icelandic.)

[23:29] <Odin-LAP> And if you want to get started on orthography ... :>

[23:30] <theorbtwo> I'm quite glad of the phenominom, whatever the causes.

[23:31] <theorbtwo> ...and I don't see it changing any time soon, either.

[23:31] <theorbtwo> English, for example, isn't beginning to take on lots of loan-words from any purticular source.

[23:32] <Juerd> I consider it likely than in a few hundred years, Chinese, or some simplified derivative, will be the lingua franca.

[23:32] <Juerd> theorbtwo: No, it takes them from any language that has roughly the same alphabet. I'm not sure if this is a good thing.

[23:33] <theorbtwo> I think it probably is.

[23:33] <theorbtwo> If English were taking on a lot of Chinese loan-words, I'd say that'd be a pretty clear sign that Chinese was winning.

[23:33] <Odin-LAP> *blink*

[23:34] <Juerd> theorbtwo: Eh.

[23:34] <Odin-LAP> You *do* realise that approximately half the modern english vocabulary is derived from latin, directly or indirectly?

[23:34] <Juerd> Odin-LAP: And that in turn from Greek.

[23:34] <Juerd> Which is all to often ignored.

[23:34] <theorbtwo> Yes, Odin.  If it were taking them on /now/, it'd be a different matter.

[23:34] <Odin-LAP> Juerd: In some cases, yes. Not as many as most assume.

[23:35] <theorbtwo> But I see lots of English in Chinese, and other languages.  In non-latin languages, it's even more noticable, because they stick out like sore thumbs.

[23:35] <Juerd> Odin-LAP: I was taught there was a greek language that existed before what we know as Ancient Greek, that was mostly the basis for Latin.

[23:36] <Odin-LAP> Juerd: Huh. I see.

[23:36] <theorbtwo> When English took on a load of outside words, it was certianly /not/ the lingua-franca.

[23:37] <Juerd> theorbtwo: Which is this clearly defined period in which English took on a load of outside words?

[23:37] <Juerd> theorbtwo: The language has always done that (if a language can actively do anything, that is)

[23:38] <Juerd> theorbtwo: It takes from whatever is current at the moment of taking. Which is no surprise, of course.

[23:38] <theorbtwo> If Chinese were to become the linga franca, it'd take those external words and make them Chinese, as English does.

[23:38] <Juerd> I wouldn't

[23:39] <Juerd> I'm one of the people who think the English influence for non-English languages is already too broad.

[23:39] <Juerd> The French are very extreme in this idea, and tend to reject any use of English.

[23:39] <theorbtwo> Yes, they do.

[23:39] <Juerd> I'm more flexible, but I do think existing Dutch words should be used when there are any.

[23:39] <theorbtwo> As a concequence, you don't see many non-french people speaking french.

[23:39] <Odin-LAP> theorbtwo: O_o

[23:39] <Juerd> theorbtwo: Huh?

[23:40] <Odin-LAP> theorbtwo: Are you really that ignorant, or..?

[23:40] <theorbtwo> Possibly I am.

[23:40] <Juerd> theorbtwo: Can I have a copy of that encyclopaedia? :)

[23:40] <theorbtwo> Ahh, but Encyclopedia now has the status of a full English word.

[23:40] <Odin-LAP> French is believed to be the second most widespread second language after English.

[23:41] <Odin-LAP> It's a loanword.

[23:41] <theorbtwo> No it's not.

[23:41] <Odin-LAP> Yes, it is.

[23:41] <theorbtwo> It /was/ a loanword.

[23:41] <Odin-LAP> Doesn't matter how long it's been used.

[23:41] <theorbtwo> No, it doesn't.

[23:41] <Odin-LAP> A loanword is still a loanword a thousand years later.

[23:41] <Juerd> theorbtwo: Is that American culture, to loan something and never return it, and then call it yours? :)

[23:41] <Juerd> And call it yours *because* you never stopped using it? :)

[23:42] <Odin-LAP> (Although English doesn't *have* those, since it's not that old, I speak languages that do. :)

[23:42] <Juerd> Odin-LAP: Like Icelandic? :)

[23:42] <Odin-LAP> Yes.

[23:42] <Odin-LAP> Like Icelandic.

[23:42] <Juerd> Why doesn't this surprise me... :)

[23:42] <theorbtwo> It's an English word.  Schoolchildren aren't taught that it's a Latin word that they can use in conversation anyway.

[23:43] <Juerd> theorbtwo: That's to prevent brane overload.

[23:43] <Juerd> theorbtwo: Not because it's true.

[23:43] <Odin-LAP> (Really. They can pretty much time the appearance of certain christianity-related words; that's maybe 900 years back, maybe more.)

[23:43] <theorbtwo> Ah, but it is true.

[23:43] <Juerd> Teaching is an art of lying in a way that people will not kill you for.

[23:43] <theorbtwo> What is it about the word that makes it anything but English?

[23:43] <Odin-LAP> Oh, but if you're hung on "encyclopedia", let me get at an even better example.

[23:44] <Odin-LAP> "Knife" is not an english word.

[23:44] <Odin-LAP> It's a loanword.

[23:44] <Odin-LAP> *manic-grin*

[23:44] <theorbtwo> Similarly, Beef is a perfectly valid English word, even though it's based on the French, and appeared around the time of the Norman invasion.

[23:44] <Odin-LAP> (So are "husband", "wife", "window", and several other common words.)

[23:45] <theorbtwo> No, those are English words.

[23:45] <theorbtwo> We stole them, made them our own.

[23:45] <Odin-LAP> In the sense that english uses them, yes.

[23:45] <Juerd> Does this make regexes Perl?

[23:46] <theorbtwo> Yes.

[23:46] <Juerd> Does it make animals cows?

[23:46] <theorbtwo> No.

[23:46] <eric256> did any language realy just randomly make up its own words? i've always been of the understanding that every langauge known today evolved from some other language

[23:46] <Juerd> Okay. Keep feeding this new neural net.

[23:46] <theorbtwo> I am me, and not the food I have been eating for the past 25 years.

[23:47] <Juerd> theorbtwo: The food is digested and no longer in your body.

[23:47] * eric256 wonders if now is the time to shout out "sure you are pig!"

[23:47] <Odin-LAP> eric256: Yes, but there's a difference between that and nicking words from other languages. Not to say that it's wrong, in any sense, but linguistically quite distinct.

[23:47] <Juerd> Otherwise you'd be a hell of a lot heavier.

[23:47] <Juerd> Now, English actually did get a lot heavier.

[23:47] <Khisanth> some of it might be though

[23:47] <Juerd> The words are still there. Usually in their original forms too.

[23:47] <theorbtwo> More or less.

[23:48] <theorbtwo> Resumé kept it's terminal accent, but the plural is Resumés, not Résumés as it would be in French.

[23:48] <theorbtwo> (Please, correct me if my French is wrong.)

[23:49] <Juerd> I haven't seen it spelled with any accent in English yet.

[23:50] <Juerd> But the accent on the first e is there in French in both the singular and the plural

[23:50] <Juerd> What is your point?

[23:50] <Juerd> And even if you destroy someone else's property, it doesn't become yours.

[23:50] <theorbtwo> My point is that I think most English-speakers don't think they have inserted a French word into the middle of their sentance, but instead have used a slightly abnormal English word.

[23:51] <Juerd> Even if you mutate another language's word, it doesn't become English.

[23:51] <eric256> Odin-LAP...realy?  whats the difference between evolving the use of existing words, and evolving the user of existing words? ;)

[23:51] <theorbtwo> It's not like the French can't have it too.

[23:51] <Juerd> theorbtwo: That failure of "most English-speakers" doesn't change facts.

[23:51] <theorbtwo> We made a copy.  This is our copy, they still have theirs.

[23:52] <theorbtwo> I fail to see where facts enter this discussion.

[23:52] <Juerd> .oO( copy, break, spread, sell, profit! )

[23:52] <Juerd> s/sell/support/ ;)

[23:53] <theorbtwo> BTW, where do you get the "knife" example from?

[23:53] <Juerd> TBH, "knife" was in Old English

[23:53] <theorbtwo> http://www.m-w.com/dictionary/Knife

[23:53] <Juerd> Which is derived from the same branch of Germanic languages that Icelandic stems from.

[23:54] <eric256> hey. americans are muts, why shouldn't our language be too!

[23:54] <Juerd> eric256: Oh, it can be nuts.

[23:54] <Juerd> I don't mind.

[23:54] <theorbtwo> The word may be in other languages as well as English, but it is beyond doubt an English word.

[23:54] <Odin-LAP> eric256: The distinction is quite simple. The predecessor language usually has earlier, older versions of words. If it does not - the word is a loanword - then that's nice to know, since it means you don't have to go hunting for the word's prior version. That's all. It's just a linguistic convenience.

[23:55] * eric256 thinks linguist are crazy...but then he thinks most people are crazy,

[23:55] <Odin-LAP> theorbtwo: Merriam-Webster actually supports my point. :>

[23:56] <theorbtwo> How do you figure?

[23:56] <Juerd> "Etymology" followed by ancient languages is a clear sign...

[23:57] <theorbtwo> Yes.  That a long time ago, somebody took a copy from it out of some other language, and since it's become a perfectly normal English word.

[23:57] <Juerd> No offense, but English itself is a loanword ;)

[23:57] <theorbtwo> I think I understand now.

[23:57] <Odin-LAP> theorbtwo: You're misunderstanding what the whole question is about.

[23:57] <eric256> every ones always picking on us poor english folk. 

[23:58] <Juerd> theorbtwo: There is no negative connotation with "loanword".

[23:58] <Juerd> theorbtwo: There's nothing to be offended about.

[23:58] <Juerd> (over?)

[23:58] <Odin-LAP> A word's being a loanword doesn't mean it's less valid.

[23:58] <eric256> Juerd easy for you to say, its not your language they are picking on!!

[23:58] <eric256> lol

[23:58] <Odin-LAP> (Unless you're a crazed purist, which in the case of English would be sheer insanity.)

[23:58] <theorbtwo> In America we have a saying, or at least I do -- "Everybody's got to be from somewhere".

[23:58] <SamB> Juerd: maybe you don't know what etymology means

[23:58] <Juerd> eric256: In a way, it is too.

[23:59] <Juerd> SamB: I find that highly unlikely.

[23:59] <Juerd> Maybe you don't know me very well :)

[23:59] <eric256> i like when people ask me where i'm from. i tell them i'm a mutt.  little oh this little oh that. probably not more than 20% of any one thing ;)

[23:59] <theorbtwo> I'm an American.  This is far more important then where my ancestors were from before they were American -- Russian, German, Scotch, Irish, Sweedish, a little of this, a little of that.

[23:59] <SamB> Juerd: it does not mean "what language a word is from"

[23:59] <Juerd> theorbtwo: That's because of some unfortunate history with "native" americans.

