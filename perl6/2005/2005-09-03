[00:03] <putter> Anyone here know why   my %h=(a=>11,b=>12); class C{has $.a; has $.b;} C.new(*(%h.pairs))   doesn't work?  thanks

[00:03] <svnbot6> r6666 | putter++ | PIL-Run - class C{method f(){13}} C.new.f #=> 13.  But that's about all that works.

[01:27] <putter> new PIL-Run smoke... 12.67% !   fglock++

[01:52] <svnbot6> r6667 | putter++ | PIL/Node_pm_gen.pl: introduction of a parallel set of "self type-checking" nodes.  some cleanup.

[01:58] <svnbot6> r6668 | dudley++ | Perl6::MetaModel 2.0 docs - Minor speeling/grammer fixes.

[02:05] <Pete_I> why is it called 'Pugs'?

[02:05] <Pete_I> perl user groups?

[02:10] <dudley> Perl6 User's Golfing System

[02:11] <dudley> It's a play on Hugs, the Haskell User's Golfing System, an interactive haskell interpreter

[02:12] <Pete_I> ah

[02:23] <putter> ?eval class C{has $.x; method new($x){say $x; BUILD(x => $x);}}  C.new(3)

[02:23] <evalbot_6652> 3 Error: No compatible subroutine found: "&BUILD" 

[02:23] <putter> Am I missing something obvious?

[03:02] <putter> A request:  could someone write

[03:02] <putter> class C{}; class C::D{method new($d){...}}; sub f($d,$cls){ ::C::($cls).new($d) } say f(3,"D");

[03:02] <putter> with the ... filled in.

[03:03] <putter> I'll backlog to pick it up.  Right now PIL/Node_pm_gen.pl is stuck until it's figured out.

[03:03] <putter> thank you for your help.

[03:04] <putter> end of day.  good night all &

[03:26] *** sleepster is now known as typester

[06:51] <luqui> ?eval my %h = (a => 1, b => 2);  say +%h

[06:51] <evalbot_6652> 2 bool::true 

[07:01] <luqui> ?eval class C { has $.x;  method new ($x) { say $x;  ./BUILDALL(x => $x)}}  C.new(3)

[07:01] <evalbot_6652> 3 Error: No compatible subroutine found: "&BUILDALL" 

[07:01] <luqui> ?eval class C { has $.x;  method new ($x) { say $x;  ./BUILD(x => $x)}}  C.new(3)

[07:01] <evalbot_6652> 3 Error: No compatible subroutine found: "&BUILD" 

[07:02] <luqui> ?eval class C { has $.x;  submethod BUILD ($x) { $.x = $x } method new ($x) { say $x;  ./BUILD(x => $x)}}  C.new(3)

[07:02] <evalbot_6652> 3 \3 

[07:03] <luqui> ?eval class C { has $.x;  submethod BUILD ($x) { $.x = $x } method new ($x) { say $x;  my $s = ./BUILD(x => $x); $s}}  C.new(3)

[07:03] <evalbot_6652> 3 \3 

[07:03] <luqui> huh...

[07:03] <luqui> probably have to bless manually, which is probably unsupported

[07:06] <ods15> ./ ?

[07:08] <luqui> ods15, that's "call on self" which may or may not exist

[07:08] <luqui> but does exist according to pugs at least

[07:08] <ods15> heh

[07:08] <luqui> hmmm, and that makes sense why that doesn't make any sense now

[08:34] <luqui> ?eval say('smiley :')

[08:34] <evalbot_6668> smiley : bool::true 

[08:46] <nothingmuch> autrijus: deep magic on p6l

[08:46] <nothingmuch> please have a crack at it

[08:46] * luqui reads

[08:46] <nothingmuch> it's in response to the lexically and temply overriding &prefix:<+>

[08:47] <nothingmuch> in short: i think there's a place for the everything-inferencing in p6l at the language definition level

[08:50] <luqui> nothingmuch, before value inference, we should probably get type inference working at all

[08:50] <nothingmuch> luqui: this can be overlooked temporarily

[08:50] <luqui> also, keep in mind that value inference should be a halting problem

[08:50] <nothingmuch> but i think that for sane semantics of overriding &pprefix:<+> we need full inferencing, even if it's weak

[08:51] <nothingmuch> or to disallow rebinding the prelude at all

[08:51] <luqui> you mean sane optimization?

[08:51] <nothingmuch> s/at all/completely/

[08:51] <nothingmuch> no, i mean the ability to decide via inferencing whether code can be executed at all

[08:51] <nothingmuch> or whether it's a circular definition

[08:51] <nothingmuch> since &prefix:<+> or something like that was rebound to a sub that makes use of global &prefix:<+>

[08:52] <luqui> that sounds like the screaming definition of the halting problem

[08:52] <nothingmuch> not quite

[08:52] <nothingmuch> look at the implementation strategy

[08:52] <luqui> you must allow recursion

[08:52] <nothingmuch> you can't guarantee that your code won't get stuck or anything

[08:52] <luqui> but I haven't finished reading

[08:52] <nothingmuch> it's a more basic question - where is the line between the runtime's primtive's and your language's definition drawn

[08:53] <nothingmuch> and this being perl 6, the answer is determined by excessive handwaving

[08:53] <nothingmuch> and i think that inferrencing is necessary to draw the line where it's safe to draw it

[08:53] <nothingmuch> to make sure that code can be run at all

[08:53] <luqui> ooh, handwaving?  now i'm listening :-)

[08:55] <nothingmuch> anyway, the prelude is completely recursive, and portable across ruuntimes

[08:55] <luqui> another thing that we could say is that in the standard dialect you're only allowed to lexically rebind builtins

[08:55] <nothingmuch> the runtime prelude is an annotation to the portable prelude

[08:56] <nothingmuch> providing native alternatives for "pure" functions

[08:56] <nothingmuch> some things are '...' in the prelude since they rely on the runtime

[08:56] <nothingmuch> and absolutely must have the native alternative to work

[08:56] <luqui> you also note that your proposal is completely contrary to separate compilation

[08:56] <nothingmuch> no it isn't... this is link time ;-)

[08:57] <luqui> we have to keep so much information around, and we do so much at link time

[08:57] <luqui> that basically link time == compile time, as it did in perl 5

[08:57] <nothingmuch> inferrencing then takes the native loop holes, and tries to use them wherever they can safely be used

[08:57] <nothingmuch> uh, we can't both be dynamic and static

[08:58] <nothingmuch> as I see i this is as separate as we can get without ruling out some language features

[08:59] <luqui> okay, the root of my uneasiness with this (not having thought about it much), is that everybody seems to think that global inferrence is bad

[08:59] <luqui> in every single paper I've read that addressed the issue

[08:59] <luqui> so I figure smart people have their reasons

[08:59] <luqui> but I haven't stuck it in my own brain yet

[09:00] <nothingmuch> well, i think it's a choice that the user should have:

[09:00] <nothingmuch> no overly dynamic rebinding of "builtins", and an actual notion of builtins

[09:00] <nothingmuch> or a langauge which pretends to be completely defined within itself

[09:01] <nothingmuch> except where inferrencing let's it cheeat

[09:01] * luqui is intrigued by your implementation strategy, though

[09:02] <nothingmuch> i think that leaving the metacircular option TODO for a long while is a viable option

[09:02] <nothingmuch> i think that 99% of the time i'd like to run that way

[09:02] * luqui wonders how many implicit parameters a call into a complex module would have

[09:02] <nothingmuch> luqui: initially thousands

[09:02] <nothingmuch> but constant folding and parameter inlining should solve that

[09:02] <nothingmuch> and furthermore this work is already being done

[09:02] <luqui> yeah... kindof

[09:02] <nothingmuch> compile time resolving of "globalish" functions is something that perl 5 does

[09:03] <luqui> it'd be nice to be able to compile perl without 2G of memory...

[09:03] <luqui> but we have moore on our side

[09:03] <nothingmuch> 'time(); use SomeModule qw/time/; time()' # not the same time() being called

[09:03] <luqui> right

[09:03] <nothingmuch> well, i think that it's a good feature, left optional

[09:03] <luqui> that's essentially a lexical rebinding... but only kinda

[09:04] <luqui> when you're compiling, it looks to see if time is overridden...

[09:04] <luqui> and only puts in one of two alternatives

[09:04] <nothingmuch> well the problem is that in perl 5 CORE::GLOBAL:: and CORE:: are special cases

[09:04] <luqui> you can never get three different behaviors of time() in the same module

[09:04] <nothingmuch> which perl 6 is pretending to do away with

[09:04] <nothingmuch> right

[09:05] * luqui likes static binding, mostly because he has had to use opengl

[09:05] <luqui> so I'm with you there

[09:05] <luqui> you just want it to be really smart, and I think it will be fine if it's relatively dumb

[09:06] <nothingmuch> well, i'll reiterate:

[09:06] <nothingmuch> it's dumb by default, because it's Good Enough

[09:06] <nothingmuch> but since the language pretends to be meta meta

[09:06] <nothingmuch> then there is the option to use the slow smart way

[09:06] <nothingmuch> (slow compilation)

[09:07] <nothingmuch> this may be useful for several things:

[09:07] <nothingmuch> safe compartments

[09:07] <nothingmuch> domains pecific languages

[09:07] <nothingmuch> environment emulation

[09:07] <nothingmuch> very very evil workarounds

[09:08] <nothingmuch> it's dangerous though

[09:08] <nothingmuch> and in this sense i'd rather have 'no you can't do that' by default

[09:08] <nothingmuch> with 'use meta circular mega inferrencing' as a lexical pragma to get around that

[09:08] <luqui> re: safe compartments

[09:09] <luqui> you're talking about putting code that was compiled before you knew that it had to be safe

[09:09] <nothingmuch> yes

[09:09] <nothingmuch> uh, no

[09:09] * luqui thinks that's pretty rare

[09:09] <nothingmuch> code that wasn't compiled with the megainferrencor can't be mega inferred

[09:09] <luqui> safe compartments can be done with lexical rebindings, no?

[09:09] <luqui> ...

[09:09] <luqui> n

[09:09] <luqui> no

[09:09] <luqui> nevermind

[09:10] <nothingmuch> anyway, more than that

[09:10] <nothingmuch> safe compartments not only in the permission sense

[09:10] <nothingmuch> but also in the auditing sense

[09:10] <luqui> ?

[09:10] <nothingmuch> oh, and obfuscated code

[09:10] <nothingmuch> well, sometimes you just want to rule out certain opcodes

[09:10] <luqui> hmm?

[09:10] <luqui> obfuscated?

[09:11] <nothingmuch> i was kidding ;-)

[09:11] <luqui> oh

[09:11] <luqui> I thought you were referencing something like the java obfuscator

[09:11] <luqui> to hide source from reenignes

[09:11] <nothingmuch> but 'temp &*prefix:<+> := &say.assuming("Just Another Perl Hacker")' could be nice

[09:11] <nothingmuch> oh, no, that stuff sucks

[09:12] <nothingmuch> anyway, sometimes you don't want to just rule out opcodes, but you want to meter, augment, or otherwise change or wrap builtin opcodes

[09:12] <nothingmuch> for just a part of the system

[09:12] <luqui> nothingmuch, yeah, I understand that

[09:12] <luqui> and that part of the system is often dynamically scoped

[09:12] <luqui> not lexically

[09:13] <nothingmuch> and the domain of the solution should move away from the runtime, towards the language definition, when it becomes that complicated

[09:13] <luqui> let the users use modules, but don't let the modules do Funny Stuff either

[09:13] <nothingmuch> right

[09:13] <luqui> the other way to do Safe, of course, is to use something akin to Parrot's slow core

[09:13] <nothingmuch> right

[09:13] <luqui> just assume that everything has gone to hell and execute with negative one optimizations

[09:14] <nothingmuch> anyway, house work is calling

[09:14] <luqui> call him back

[09:14] <nothingmuch> i think that @Larry will need to:

[09:14] <luqui> :-p

[09:14] <nothingmuch> a. decide when the line is drawn

[09:14] <nothingmuch> b. decide whether several lines can be drawn

[09:14] <nothingmuch> c. decide where the line will be drawn when it is drawn

[09:15] <nothingmuch> d.

[09:15] <nothingmuch>  whether the user gets to make a choice

[09:15] <nothingmuch> ciao

[09:15] * luqui expects a lot of that just depends on how much the faithful implementors of perl 6 (i.e. us) get done

[09:15] <nothingmuch> autrijus: backlog please, you know much about this

[09:15] <nothingmuch> luqui: i think this issue is more all encompassing than we think

[09:16] <nothingmuch> and that it's a language designer's decision to mark it as 'todo' or 'won't fix'

[09:16] <luqui> nothingmuch, yeah, but you're essentially talking about a strategy that has never been done

[09:16] <luqui> and there have been many sucessful self-implementing languages

[09:16] <luqui> anyway, ciao

[09:17] <nothingmuch> luqui: self implementing compilers for languages

[09:17] * luqui points to scheme

[09:17] <nothingmuch> but at some point the chip on your has to do some boolean logic

[09:17] <nothingmuch> even if you've implemented church integers

[09:18] * luqui understands the problem

[09:18] * luqui will think about it some, but he thinks that it's less all-encompassing than you think :-)

[09:18] <nothingmuch> and the prelude, as well as overriding things like &infix:<&&>, &prefix:<+>, &infix:<+>, and so forth is not changing the compilation down to the chip doing some boolean logic

[09:19] <nothingmuch> it's overriding it

[09:19] <nothingmuch> and the mega inferrencer is, IMHO, the only way to determine when it's safe to still use the chip, to bootstrap the part that no longer uses the chip

[09:19] <nothingmuch> (except that it does, behind the scenes

[09:21] <nothingmuch> anyway, *poof*

[11:48] * nothingmuch is now high on paint, paint thinner and sawdust

[11:48] <nothingmuch> posts to p6l may become more interesting

[13:38] <nothingmuch> la la la

[13:43] <svnbot6> r6669 | Stevan++ | Perl6::MetaModel 2.0

[13:43] <svnbot6> r6669 | Stevan++ | * adding in the _('$.x') instance attribute 

[13:43] <svnbot6> r6669 | Stevan++ |   accessor/mutator macro

[13:49] <luqui> nothingmuch, thanks for the summary

[13:49] <luqui> I understand what you're getting at better here

[13:49] <luqui> I was looking at it as more of an optimization problem gone wrong

[13:49] <nothingmuch> yeah, i hoped that'd be the acheived effect

[13:49] <nothingmuch> oh, no, i don't care only about optimization ;-)

[13:49] <luqui> You want overriding operators to be correct *everywhere*, even inside builtins

[13:50] <luqui> or rather, your proposal wants that

[13:50] <nothingmuch> yes

[13:51] <luqui> you understand that if you throw optimization out the window, that this inferrence becomes possible and easy at runtime

[13:51] <luqui> and you get the same effect

[13:51] <luqui> but it would be slower than Class::Multimethods::Pure :-)

[13:51] <nothingmuch> right

[13:51] <nothingmuch> optimization for such a complicated language is a requirement, IMHO

[13:52] <nothingmuch> and furthermore, dynamic, continuous, incremental and reversable optimization is also necessary

[13:52] <luqui> well, I keep figg'ring that (like you said at the end of your summary) global overriding of builtins should not be possible

[13:52] <luqui> only lexical...

[13:52] <nothingmuch> otherwise there is just too little balance between runtime and compile time

[13:52] <luqui> nothingmuch, "reversible" optimization is impossible

[13:53] <luqui> talk to Dan sugalski about that one, he understands it well

[13:53] <nothingmuch> yes it is, you just keep snapshots of previous states, or a log

[13:53] <luqui> you can't

[13:53] <nothingmuch> and throw away what you did here when it becomes:

[13:53] <nothingmuch> worthless

[13:53] <nothingmuch> problematic

[13:53] <nothingmuch> uh, wtf?

[13:54] <luqui> hang on while I concoct an example

[13:54] <nothingmuch> let's say we have executable byte code called 'a'

[13:54] <nothingmuch> it's slow

[13:54] <luqui> sub foo { bar();  baz();  }   sub bar() { *baz = sub { "but it doesn't work" } }   sub baz() { "I like this optimization" }

[13:54] <nothingmuch> the runtime says "this is unoptimized code, but and we have only spent 1% of the last minute optimizing"

[13:55] <luqui> you can't inline baz()... ever

[13:55] <nothingmuch> so it stops for a second, and derives an optimized tree, 'b' out of 'a'

[13:55] <nothingmuch> i'm not saying you can

[13:55] <nothingmuch> wait

[13:55] <nothingmuch> you can

[13:55] <nothingmuch> you just have to make the *baz container know about all inlined instances

[13:56] <luqui> so that it can...

[13:56] <nothingmuch> and zap them, reverting to "normal" calls, whenver it changes

[13:56] <nothingmuch> think of inlining as a cache

[13:56] <luqui> but you see, you're *already* inside an optimized function

[13:56] <luqui> when you decide that the function shouldn't have been optimized

[13:56] <nothingmuch> hmm

[13:57] <nothingmuch> at the call level i think there is enough abstraction that it is okay

[13:57] <nothingmuch> but at the opcode level you are right

[13:57] <luqui> how so?

[13:57] <nothingmuch> putter: ping

[13:57] <luqui> I'm not sure what you mean by the call level

[13:58] <nothingmuch> okay, foo is optimizeed

[13:58] <luqui> are you saying that we already have enough indirection there to manage it

[13:58] <nothingmuch> and the calls to bar and baz are already resolved to be a pointer to some code

[13:58] <luqui> (even though we're not discussing any implementation in particular... which has me.. confused)

[13:58] <nothingmuch> in the most extreme solution the opcode and the string are actually inlined into 'baz'

[13:58] <nothingmuch> the call to thereof, that is

[13:59] <nothingmuch> anyway, bar is executed, and it replaced 'baz'

[13:59] <nothingmuch> the baz container was magicified by the runtime

[13:59] <nothingmuch> it overwrote the inlined call to baz with code to lookup baz and apply that

[13:59] <nothingmuch> worst case scenario - it makes a closure that will do that, an inlines a call to that

[13:59] <nothingmuch> and then remembers to reoptimize foo when we're done using it

[14:00] <luqui> buying you nothing over not inlining

[14:00] <nothingmuch> no, because the level of indirection is in the baz container

[14:00] <nothingmuch> not in the code where baz was inlined

[14:00] <nothingmuch> so there is no overhead in executing that code

[14:01] <luqui> oh, you're saying that the assignment to *baz would actually modify the currently executing optree of foo?

[14:01] <nothingmuch> yes

[14:01] <luqui> why don't you design a runtime that can do that, because I'm not aware of one :-)

[14:01] <nothingmuch> you make it sound like a bad thing, but let me remind you that inlining in a dynamic system is a bad thing ;-)

[14:01] <luqui> well, I didn't really mean to focus on this particular problem

[14:02] <luqui> it was just the case for nonreversible optimizations

[14:02] <nothingmuch> okay

[14:02] <luqui> in most runtimes, you can't undo that one

[14:02] <nothingmuch> then such a runtime is not suitable for a system that needs to be both fast and eval friendly

[14:03] <luqui> taking the standpoint that code in evals need to do basically what they would if they had been evaluated at compile time

[14:04] <luqui> if you know what I mean

[14:04] <nothingmuch> not that it's that important, if the mega inferrencer detects that *baz is assigned at runtime in code which is not eliminated by the dead code eliminator, then baz should never be inlined

[14:04] <luqui> As far as Larry is concerned, it's okay to allow optimizations that forbid certain kinds of things going on in evals later

[14:04] <luqui> as long as you can turn them off

[14:04] <nothingmuch> i agree

[14:04] <nothingmuch> or rather, as long as they're off by default

[14:04] <luqui> nope

[14:05] <luqui> that's what I thought too

[14:05] <nothingmuch> okay, convince me =)

[14:05] <luqui> I don't have an argument

[14:05] <luqui> I think Larry's main argument is a social one, if I picked up on it right

[14:05] <nothingmuch> isn't it dangerous for newbies to be bitten by the "oh, you can't do that unless you 'no optimize eval_wizardry'?

[14:05] <luqui> "I want Perl to be fast out of the box, so it doesn't get a reputation of being slow"

[14:05] <nothingmuch> hmm

[14:05] <nothingmuch> okay, that's pretty much the same as my argument

[14:06] <nothingmuch> except with different parameters ;-)

[14:06] <luqui> yep

[14:06] <nothingmuch> yeah, i guess speed is more important than corner case flexibility, as long as it doesn't go too far

[14:06] <luqui> the people who are going to be corner-casing are the people who already know a lot of the language

[14:07] <nothingmuch> but anyway, in this specific example, baz() should never be inlined on a runtime that doesn't allow unoptimizing

[14:07] <luqui> and know about how perl does optimizations

[14:07] <luqui> probably so

[14:07] <nothingmuch> yes, i see, and I think you converted me

[14:07] <luqui> runtime-overriding a function is common enough

[14:07] <luqui> that it should be pragmatic to inline rather than pragmatic not to

[14:08] <nothingmuch> hmm

[14:09] <nothingmuch> you could also make things that are probably not going to be overridden into things that are semi inlined:

[14:09] <nothingmuch> an inlined structure that has a cache

[14:09] <nothingmuch> or use a cache table indexed by caller position instead of name

[14:09] <luqui> or some kind of lightweight flag

[14:09] <nothingmuch> and have &*baz invalidate that instead

[14:09] <nothingmuch> right

[14:10] <nothingmuch> that is almost inlining, but not as "hard"

[14:10] <luqui> basically turn bar() into $bar_overridden ?? bar() :: inlined_bar

[14:10] <nothingmuch> i was thinking more along the lines of bar() into $bar.() instead of bsr $bar_addr

[14:11] <nothingmuch> where $bar is &bar until the cache is invalidated

[14:11] <luqui> same diff...

[14:11] <nothingmuch> when it is overwritten to be sub { bar() }

[14:11] <nothingmuch> no, mine is cooler ;-)

[14:11] <luqui> yours has more abstraction

[14:11] <luqui> and less cache locality

[14:11] * luqui points out that he really doesn't know anything about cache locality

[14:12] <luqui> unfortunately, one of the nice things you can do with inlining is fold the inlined versions up

[14:12] <luqui> and if it's conditional inlining, then you don't get that

[14:12] <luqui> you just halve the function call overhead or so...

[14:13] <nothingmuch> right

[14:13] <nothingmuch> but it's still safe

[14:13] <luqui> (which would have been good enough for Glop, believe me)

[14:13] <nothingmuch> and for where we know that it absolutely is safe to inline, we can still do that

[14:13] <nothingmuch> after all &*baz is probably not in the compiled code for every function

[14:13] <luqui> under "use early" ;-)

[14:13] <nothingmuch> 99% chance that none of the prelude is overridden

[14:13] <nothingmuch> 'use early'?

[14:14] <luqui> hypothetical "use early binding"

[14:14] <nothingmuch> uh, why?

[14:14] <luqui> because I like perl for a lot of reasons

[14:14] <luqui> and when I don't care to like it for its dynamicity, I can still use it for all those other reasons

[14:14] <nothingmuch> nonono

[14:15] <nothingmuch> why only under 'use early'?

[14:15] <luqui> no, we know that it is safe to inline under "use early"

[14:15] <luqui> I'm not sure where, but it might be possible other times too

[14:16] <nothingmuch> oh

[14:16] <luqui> &::('*baz') = ...

[14:16] <nothingmuch> one time: no instance of 'eval' or 'require' opcodes in runtime code

[14:16] <luqui> breakfast, brb

[14:16] <nothingmuch> this means that any code that is never assigned to, or marked read only, can be inlined

[14:16] <putter> nothingmuch: pong

[14:16] <nothingmuch> which is very good for incremental optimization of one liner scripts that may have to eat huge wads of data

[14:17] <nothingmuch> by the time they do 1mb or so, they should be optimized more aggressively

[14:17] <nothingmuch> putter: putting parrot dir in $PATH did not solve smoke issues

[14:18] <putter> :(

[14:20] * putter wonders if I have ever tried smoke on a non-embedded-parrot pugs

[14:22] <putter> nothingmuch: it's less critical now with the smoke repositiory - I can point folks who need a public smoke of rules to that.

[14:22] <nothingmuch> putter: i'm trying to submit to it =(

[14:22] <nothingmuch> but yes, I agree

[14:22] <nothingmuch> bbiab

[14:23] <nothingmuch> (watching slides of presentation)

[14:23] <putter> hmm... it was you who deleted your automated smoke from the pugs wiki, wasnt it?

[14:23] <nothingmuch> yes, it was

[14:23] <putter> ok

[14:23] <nothingmuch> haddock should still be there

[14:23] <nothingmuch> but i think that using iblech's service is better for the community

[14:23] <nothingmuch> since my smoke loop is flakey

[14:23] <nothingmuch> the problem is that it's the play machine in the house

[14:23] <autrijus> hi from blazingly fast 33.6k modem (for the next 40 hours)

[14:23] <nothingmuch> it gets rebooted every once in a while

[14:23] <nothingmuch> and I don't work on it at all

[14:23] <nothingmuch> hi autrijus!

[14:24] * putter goes to check wiki... some hacking for high schoolers site apparently announced "unsecured site! you can hack into it by clicking on Edit".  apparently never heard of wikis.  sigh.

[14:26] <bmonty> can anyone help me with how to determine if there is a file on STDIN with perl?

[14:26] <putter> biggest impact of the repository for me is it allows things like pilrun to be smoked, which is still "run make smoke-perl5... check on it later, kill the non-terminating test..." ;)

[14:26] <autrijus> bmonty: not (-t STDIN)

[14:29] <nothingmuch> -t

[14:29] <nothingmuch> uh, םםפד

[14:29] <nothingmuch> damnit

[14:29] <nothingmuch> that was supposed to be "oopS"

[14:29] <putter> what was that?

[14:29] <nothingmuch> changed lang in the middle to hebrew

[14:29] <putter> lol

[14:29] <scook0_> oh, the irony!

[14:30] *** scook0_ is now known as scook0

[14:30] <nothingmuch> anyway, physical labour is calling... the sun is down, the air is no longer hot and sizzly

[14:30] <luqui> 33.6... that's the fast kind right (as opposed to 28.8)

[14:30] <nothingmuch> 56k was the fastest

[14:30] <autrijus> it's the supposed-to-be-56k-but-noise-gets-in-the-way kind

[14:30] * luqui remembers

[14:31] <luqui> darn that noice

[14:31] <scook0> not that anybody EVER got 56k

[14:31] <luqui> noise

[14:31] <luqui> well, assuming a noiseless line it's 56k

[14:31] <luqui> and noise is something that's not supposed to happen

[14:31] <luqui> because physics doesn't exist

[14:31] <putter> bbl &

[14:35] <bmonty> autrijus: can I use your suggestion with if?  I want to do if (file on STDIN) { run this code} else {run other code}

[14:36] <autrijus> if (-t STDIN) { ...interactive... } else { ...batch... }

[14:36] <autrijus> but this is a #perl question not a #perl6 one :)

[14:37] <autrijus> (although curiously that should also work with perl6, with STDIN replaced by $*IN)

[14:37] <bmonty> autrijus: ok, thanks....sorry about being in the wrong channel

[14:37] <autrijus> no prob

[14:41] <luqui> ?eval sub foo() { "outer" }   sub bar() { my sub foo() { "inner" }  foo() }  bar()

[14:41] <evalbot_6668> 'inner' 

[14:42] <luqui> hmmm...

[14:42] <luqui> I could have sworn that was broken

[14:43] <luqui> oh, it's only wrt operators

[14:44] <luqui> sub infix:<@@> ($x,$y) { "$x outer $y" }  sub bar() { my sub infix:<@@> ($x,$y) { "$x inner $y" }  3 @@ 4 }  say bar()

[14:44] <luqui> ?eval sub infix:<@@> ($x,$y) { "$x outer $y" }  sub bar() { my sub infix:<@@> ($x,$y) { "$x inner $y" }  3 @@ 4 }  say bar()

[14:44] <evalbot_6668> 3 inner 4 bool::true 

[14:44] <luqui> uh...

[14:44] <luqui> wait

[14:44] <luqui> uh

[14:44] <luqui> IIRC, I am running evalbot, so it is the same pugs

[14:44] <luqui> and it's doing two different things based on whether it's on the command line

[14:46] * luqui is completely perplexed

[14:48] <luqui> holy crap

[14:48] <luqui> it says "outer" in normal code, and it says "inner" if it's within an eval

[14:48] <luqui> wtf

[15:00] <luqui> autrijus, do operators not fit in lexical pads?

[15:02] <autrijus> I think it does

[15:04] <luqui> well operators cannot be lexically scoped

[15:04] <luqui> I'm looking into it

[15:04] <luqui> and I think I've found the problem (but I'm not too sure)

[15:05] * luqui loves hoogle

[15:05] <autrijus> cool! :)

[15:05] <autrijus> I'll bbiab. _still_ had not downloaded pugs

[15:05] <luqui> ouch

[15:05] <autrijus> I'm resorting to remotely sync and copying tbz2 over

[15:05] <luqui> oh, btw

[15:05] <autrijus> but even that is ridiculously slow

[15:05] <luqui> is there a "substr" function in haskell

[15:05] <autrijus> sure

[15:06] <luqui> called...

[15:06] <autrijus> take 3 drop 4

[15:06] <autrijus> or rather, (take 3 . drop 4)

[15:06] <luqui> Oops

[15:06] <luqui> I'm an idiot

[15:06] <luqui> sorry, is there a "issubstring" function

[15:07] <luqui> String -> String -> Bool came up blank

[15:07] <autrijus> [a] -> [a ] -> Bool

[15:07] <luqui> isPrefixOf and isSuffixOf

[15:07] <luqui> that's all

[15:07] <luqui> well, I'll go ask in #haskell

[15:09] <nothingmuch> luqui: you can recursively apply isPrefixof

[15:09] <svnbot6> r6670 | rafl++ | * Fixes for the PIL2JS README.

[15:09] <svnbot6> r6671 | rafl++ | * Explained the anatomy of the debian/ dir in pugs::hack.

[15:14] <nothingmuch> putter: make clean in parrot tree seems to have fixed it.

[15:43] <luqui> ?eval sub <+> ($x) { $x }

[15:43] <evalbot_6668> undef 

[15:43] <luqui> that, um, doesn't look like a valid sub name to me

[16:07] <putter> nothingmuch: :)

[16:07] <nothingmuch> putter: i thought I had that in the script =/

[16:12] <putter> ah yes.  up there with "I was sure I had that filesystem on the backup list..."

[16:13] * putter plays with http://search.cpan.org/~salva/Language-Prolog-Yaswi-0.08/

[16:17] <putter> and http://www.cs.sfu.ca/people/Faculty/cameron/Teaching/384/99-3/regexp-plg.html  Perl Style Regular Expressions in Prolog

[16:53] <geoffb> nothingmuch, ping

[16:54] <luqui> autrijus!

[16:54] <luqui> Eval isn't a monad?

[16:55] <luqui> I can't use transforms on it: Type synonym `Eval' should have 1 argument, but has been given 0

[16:59] *** _SamB_ is now known as SamB

[17:00] <autrijus> luqui: Eval is a type synonym

[17:00] <autrijus> luqui: if you want to transform on it, transform on EvalMonad 

[17:00] <autrijus> which is another type synonym with the correct kind

[17:00] <luqui> okay

[17:01] <luqui> otherwise it looks exactly the same?

[17:01] <autrijus> yeah

[17:01] <autrijus> type synonyms are not types

[17:01] <luqui> okay, thanks

[17:01] <autrijus> they are like C macros

[17:01] <autrijus> so you can't curry them as you can with type constructors

[17:01] <autrijus> they are of fixed fixity

[17:01] <luqui> :-(

[17:01] <autrijus> er I mean arity

[17:01] <luqui> arity you mean

[17:03] <luqui> EvalMonad is not exported from Pugs.AST.Internals

[17:03] <luqui> okay to add it to the exports?

[17:03] <luqui> hooo-ly crap, I just wrote 30 lines of haskell using monad transforms and stuff and it compiled on the first try!

[17:04] <luqui> I fear I'm learning this language...

[17:04] <SamB> whats to fear?

[17:04] <luqui> nothing :-)

[17:04] <luqui> Just Fear | Nothing

[17:05] * SamB usually gets loads of type errors, but things that aren't insanely complicated often work on the first succesfull compile

[17:05] <SamB> usually, even

[17:06] <SamB> even the insanely complicated things work fairly often...

[17:06] <SamB> I figured out how to use Data.Generics today...

[17:06] <geoffb> luqui, that looks like a T-shirt, or hat, or something

[17:07] <luqui> geoffb, ?

[17:07] <geoffb> "Just Fear | Nothing"  -- that's just screaming to be put on swag

[17:08] <luqui> ahh

[17:08] <geoffb> Something for autrijus to put in the cafepress store

[17:08] <geoffb> :-)

[17:38] <nothingmuch> geoffb: pong

[17:38] <stevan> @PugsLand = (Fear & Loathing);

[17:41] <nothingmuch> =)

[17:42] <nothingmuch> loathing is provided by python, fear by weird extensions to haskell

[17:45] <SamB> so who is doing the loathing, and who is fearing?

[17:46] <stevan> SamB: it's a junction... and so autothreaded 

[17:47] <stevan> loathing and fearing at the same time

[17:50] * SamB personally experiences more incomprehension the fear about weird extensions to haskell

[17:50] <stevan> luqui: you forgot to update your changelog for C::MM::Pure 0.08 

[17:50] <SamB> s/the/then/

[17:51] <luqui> oh, was that one of the modules I had a changelog for?

[17:51] <luqui> okay, I'll have to do that

[18:04] * geoffb back

[18:05] <geoffb> dangit, I knew as soon as I went and did something, nothingmuch would pong

[18:05] <geoffb> nothingmuch, what's the darcs address for your harrorth repo?

[18:13] <luqui> geez, it's hard to make nontrivial changes to pugs

[18:13] <luqui> because running the test suite takes so long!

[18:15] <wilx> I bet that GCC testsuite runs much longer :)

[18:15] <wilx> And still they are able to do stuff with it.

[18:16] <geoffb> luqui, How long does it take for you, and what are your build options?

[18:17] <luqui> let's see, it's been about ten minutes, and I'm up through t/builtins/want

[18:17] <coral> given a makefile with each test file as a target whose build command was the pugs test command line, then make -j8 could multithread 8 tests at a time

[18:17] <luqui> though half of the source files are optimized and half aren't

[18:17] <luqui> think it's worth putting in the -O time?

[18:20] <autrijus> probably yes

[18:20] <coral> regarding an earlier discussion about caching precompiled files on a per-platform basis, a shell script precursor to ccache is here: http://www.erikyyy.de/compilercache/compilercache-1.0.10.tar.gz

[18:23] <luqui> pugs has a smoke right?

[18:23] <luqui> yes

[18:26] <nothingmuch> geoffb: http://feather.perl6.nl/~nothingmuch/harrorth

[18:37] <geoffb> ah, cool

[18:37] <geoffb> thank you

[18:39] <geoffb> I hadn't realized that (like subversion) darcs used the same url for web browsing as for pulling . . . guess I should have tried that, duh.

[18:39] <geoffb> I blame sleep deprivation.

[18:44] <svnbot6> r6672 | luqui++ |  r548@feather:  fibonaci | 2005-09-03 20:40:28 +0200

[18:44] <svnbot6> r6672 | luqui++ |  Rewrote findSyms to do real shadowing instead of returning all possible symbols.  That is, if

[18:44] <svnbot6> r6672 | luqui++ |  there is a matching name in the lexical, it returns no global names.  This solves the lexical

[18:44] <svnbot6> r6672 | luqui++ |  operator bug.

[18:50] <autrijus> ooh. luqui++ indeed

[18:51] <nothingmuch> geoffb: care to help with forth a bit?

[18:51] <nothingmuch> or actually, anyone?

[18:51] <luqui> what sort of help?

[18:51] <nothingmuch> tests for the return stack

[18:51] <luqui> I suppose it would help if I knew forth

[18:54] <pasteling> "geoffb" at 69.110.115.185 pasted "Earliest beginnings of a Forth interpreter -- starting in Perl 5, will translate to Perl 6 when I have the structure figured out" (286 lines, 8.4K) at http://sial.org/pbot/12906

[18:54] <geoffb> I wish pasteling's output was in a decent font

[18:55] <geoffb> anyway, nothingmuch, I figured the best way I could understand enough forth, was to write my own forth interpreter -- and use yours and pforth as sanity checks

[18:55] <geoffb> It's just at really early stages now (simple interpretation, that's all), but it's a blast

[18:55] <nothingmuch> it's lots of fun

[18:55] <geoffb> NODNOD

[18:56] <nothingmuch> yours is perl 5 cemntered

[18:56] * nothingmuch is trying to emulate a real machine, with a heap and stuff

[18:56] <geoffb> As the paste comment says, I'm hoping to convert it to Perl 6 once I have the structure worked out

[18:56] <nothingmuch> i like your way =)

[18:56] <geoffb> :-)

[18:56] <nothingmuch> well, perl cenetered

[18:56] <nothingmuch> unfortunately my plans are to compile down to assembley eventually

[18:56] <nothingmuch> so I gave up the luxuary of abstract anything ;-)

[18:56] <geoffb> yeah . . . I figured that was the easiest way to start, but as I read in the ANS Forth spec,

[18:57] * nothingmuch 's heap is an array of integers

[18:57] <geoffb> many Forths have two dictionaries, one of clean implementations for interpretation, and one of machine code for optimized compiles

[18:57] <nothingmuch> btw - the input buffer is line oriented

[18:58] <geoffb> nothingmuch, yeah, I know that -- last night I left off in the midst of refactoring the parser to be real.  :-)

[18:58] <nothingmuch> well, if you like, submit that to the harrorth repo, and share my test cases

[18:58] <geoffb> Let me get it a bit farther, and then I definitely submit it.

[18:58] <nothingmuch> yummy

[18:58] <nothingmuch> call it geoforth

[18:58] <geoffb> If I get it to be Perl 6, I may just submit it to the pugs repo.  :-)

[18:59] <geoffb> It's currently "gjbforth"  :-)

[18:59] <nothingmuch> fairynuff

[18:59] <nothingmuch> =)

[18:59] <geoffb> Although geoforth or geofforth has a nice ring . . . .

[19:00] <nothingmuch> i pronounce it as 'jefforth', but 'geoforth' has a sort of globality to it ;-)

[19:00] <geoffb> yeah, that's why I can't decide which spelling I like better.

[19:00] <nothingmuch> have you dealt with VARIABLE and DOES yet?

[19:00] <geoffb> Maybe geoforth as you did it, because of the multiplicity

[19:00] <nothingmuch> those are what made me break down and make a real heap

[19:00] <geoffb> No.  As of last night I had:

[19:00] <nothingmuch> (that is, array of integers)

[19:00] <geoffb> 1) a crude repl,

[19:01] <nothingmuch> oh, no IF/ELSE either ;-)

[19:01] <nothingmuch> naughty naughty

[19:01] <geoffb> 2) a small library of primitives and another libary of preludes

[19:01] <geoffb> 3) a data area,

[19:01] <geoffb> 4) a data stack

[19:01] <geoffb> The rest is all lies.

[19:02] <nothingmuch> data area?

[19:02] <geoffb> There can't easily be if/else without a compile mode, which isn't there yet.

[19:02] <geoffb> @DATA is an array of ints

[19:02] <nothingmuch> for ! and @?

[19:02] <geoffb> nod

[19:02] <nothingmuch> ah

[19:02] <nothingmuch> do you know how ELSE is implemented?

[19:02] <geoffb> Yeah, from the blurb about control structures in appendix A

[19:03] <geoffb> (Trying to understand it from just the normative stuff in section 6 is not so easy)

[19:03] * nothingmuch didn't read the ANS stuff

[19:04] <nothingmuch> wasn't patient enough

[19:04] <nothingmuch> it drove me mad with boredom

[19:04] <geoffb> You notice I created the number picture words, basically so that I would have a structure to wrap my mind around when I went to implement control structures and compilation.

[19:04] <geoffb> yeah, it's very long, but there is a LOT of good info in there.

[19:04] <geoffb> Especially the rationales and appendices

[19:05] <geoffb> One of my goals is to have a near-minimal primitive set, so almost everything is defined in the prelude, for obvious reasons.

[19:05] <pasteling> "nothingmuch" at 82.81.247.180 pasted "nuffinforth if/then" (10 lines, 91B) at http://sial.org/pbot/12907

[19:05] <nothingmuch> geoffb: mine too

[19:06] <nothingmuch> my rationale is user ne optimizer

[19:06] <nothingmuch> and since it's open, it might as well be accessible too

[19:06] <geoffb> CM might disagree.  ;-)

[19:06] <nothingmuch> CM?

[19:06] <geoffb> nodnod

[19:06] <nothingmuch> oh, right

[19:06] <nothingmuch> well, I have very evil plans for optimizer with haskell later

[19:07] <geoffb> yeah, I'm all for open to user base

[19:07] <geoffb> nodnod

[19:07] <geoffb> :-)

[19:07] <nothingmuch> all i have to do is get that far

[19:07] <geoffb> heh

[19:07] <geoffb> "nuffinforth"?

[19:07] <geoffb> Real or a joke name

[19:07] <geoffb> ?

[19:07] <nothingmuch> joke name

[19:08] <geoffb> ok, cool

[19:08] <nothingmuch> want to define do/loop for me? i don't feel like it

[19:08] <geoffb> all right, we can chat more about forth later, if you don't mind -- I've got some stuff to do while $toddler is asleep

[19:08] <geoffb> :-)

[19:09] <nothingmuch> ah, okay

[19:09] <nothingmuch> have fun

[19:09] <geoffb> Anything you don't define, I will eventually -- I plan to have at least all of CORE and CORE EXT words defined.

[19:09] <geoffb> thanks!

[19:10] <nothingmuch> oh, biggest hint:

[19:10] <nothingmuch> implement the diff between immediate and regular as early as possible

[19:10] <nothingmuch> it makes you think in terms of IMMEDIATE

[19:12] <luqui> nothingmuch, did you end up writing forth in haskell?

[19:12] <nothingmuch> yes, some bits

[19:13] <luqui> cool

[19:53] <svnbot6> r6673 | luqui++ |  r552@feather:  fibonaci | 2005-09-03 21:49:38 +0200

[19:53] <svnbot6> r6673 | luqui++ |  The erroneous "sub <foo>" no longer parses.  Sub parameters may now be operators,

[19:53] <svnbot6> r6673 | luqui++ |  eg. "sub foo(&infix:<+>) {...}".

[20:08] <nothingmuch> geoffb: i'm 80% done writing my forth's runloop in forth

[20:10] <luqui> so you're 40% done eh?

[20:22] <autrijus> or 64%?

[20:26] <luqui> hmm, did I accidentally break smart match?

[20:27] <luqui> no..

[20:28] <luqui> what the heck...

[20:29] <luqui> has anyone seen this error before:

[20:29] <luqui> pugs: *** Language "perl6" unknown. at tmp-Prelude.pm

[20:30] <autrijus> hm looks like you've been mixing prelude and nonprelude compilation.

[20:30] <luqui> well I don't think my change touched anything of the sort

[20:30] <luqui> so... what could be happening

[20:30] <luqui> this is after a make clean; perl Makefile.PL; make

[20:37] <autrijus> hm weird.

[20:38] <luqui> do you have the most recent pugs, or are you too slow

[20:42] <autrijus> just synced, making unoptimised

[20:50] <autrijus> luqui: it worksforme

[20:50] <autrijus> try removing the PreludePC files?

[20:51] <luqui> well, it worksforme too

[20:51] <luqui> try pugs -MNet::IRC

[20:53] <autrijus> got that error

[20:53] <autrijus> strange, it's almost as if the 'lc' didn't work or something

[20:53] <autrijus> or the 'when' does not

[20:53] <autrijus> in src/perl6/Prelude.pm

[20:54] <luqui> it's the 'when'

[20:54] <luqui> I tried lowercasing it elsewhere (literal "perl6" instead of "Perl6"); still didn't work

[20:54] <autrijus> what if you replace when with a series of if?

[20:54] <luqui> strange thing is:  ./pugs -e 'eval "<hi>"' works

[20:54] <autrijus> maybe given/when is borken

[20:54] <luqui> well, the tests pass

[20:54] <autrijus> very weird then

[20:56] <luqui> trying if

[20:59] <luqui> using an if cascade worked

[21:01] <autrijus> I wonder if somehow given/when did not survive -CPugs.

[21:01] <autrijus> unlikely as it seems

[21:03] <luqui> how do I compile a test module with -CPugs in a manner similar to prelude

[21:03] <luqui> is it fairly easy?

[21:04] <autrijus> -BPugs should do that for you

[21:04] <autrijus> oh

[21:04] <autrijus> # precompile_modules: [ ext/Test/lib/Test.pm ]

[21:04] <autrijus> in config.yml

[21:05] <autrijus> rafl: pugs::hack entries are directories not files

[21:05] <autrijus> rafl: so I'm not sure your debian/ descriptions belong

[21:06] <autrijus> rafl: if you feel that they should stay, though, that's fine with me. I fixed your 4-width tabs though

[21:09] <luqui> it seems as though my recent change broke it

[21:11] <svnbot6> r6674 | autrijus++ | * expandtab on rafl's pugs::hack additions.

[21:16] <autrijus> mm it's past 5am again

[21:17] <autrijus> probably needs to sleep

[21:17] * autrijus waits for the slow connection to use.perl.org to get through

[21:19] <putter> good night autrijus :)

[21:20] <luqui> good night aut

[21:28] * autrijus waves &

[21:34] * luqui nap &

[21:35] <masak> i have read the new perl5/Perl6-MetaModel2.0/docs/10_000_ft-view.pod

[21:35] <masak> what happened to metaclass?

[21:42] <svnbot6> r6675 | fglock++ | * perl5/Code - added comments, TODO

[21:48] <putter> weary woot - p5 embedded prolog regex engine returning (somewhat bogus but sometimes correct) Match objects.

[21:50] * putter evening &

[21:50] <geoffb> OK, lemme get this straight, you've got prolog embedded in P5, and are using that to handle regular expressions in PIL-RUN?

[21:50] <putter> oh,

[21:51] <putter> yes, up until the PIL-Run part.  and a very weak value of "handle".

[21:53] <putter> objective is not so much to add regexs to pilrun, but to have some engine, any engine, which actually does non-trivial p6 regex.  this would get the grammar-for-perl6 folks unstuck.

[21:56] <putter> p5 is stable.  prolog is stable and tolerably fast (even doing interpreted, not compiled, regexes).  the interface so far seems moderately stable.  unless there are gotchas, it looks like a straight development path.  the result isnt something most folks will want to use (linking swi-prolog), but it will get us our first working p6 rules engine.

[21:57] <putter> though... if we're thinking about runtimes using it, pil2js, running under Perl6::Run::JS, could use it equally well... ;)

[21:57] <Juerd> How is PGE coming along then?

[21:58] <dduncan> so, as promised on thursday or friday, I'm going to start expanding any tabs in pugs files today

[21:59] <putter> pm had non-PGE work until(?) recently.  someone stopped by a couple of days ago wondering if we had heard from him, as he was apparently somewhat out of touch.  last I heard, he had a block of time coming up.   there was a concept of doing an alternate engine design (as the PGE approach was proving slow).  other than, PGE development has not been visibly progressing.

[22:00] <Juerd> That's too bad, really

[22:00] <Juerd> Lots of things depend on a rules engine

[22:01] <Juerd> And I depend on going to bed

[22:01] <putter> A native p6 engine is not difficult to write... but pugs just isnt up to handling it yet.

[22:01] <Juerd> Good night

[22:01] <Juerd> Be careful with "not difficult"s ;)

[22:01] <putter> g'night

[22:01] <Juerd> afk

[22:01] <putter> :)

[22:01] <putter> also can do partial p6 on PCRE...

[22:03] <putter> "not difficult" compared to the pain so far experienced attempting workarounds...

[22:03] <putter> ;)

[22:03] <putter> good night all &

[22:15] *** enilb is now known as bline

[22:28] <rafl> autrijus: Hm. Any idea how to tell vim to use tabs or spaces for identing per directory?

[22:30] <wolverian> rafl, autocmd BufRead /foo/bar set ...

[22:31] <wolverian> (:h autocmd-patterns)

[22:32] <rafl> wolverian++; #Thank you.

[22:32] <wolverian> you're welcome :)

[22:34] <rafl> wolverian: Does it know about regular expressions?

[22:36] <wolverian> rafl, :h file-pattern

[22:37] <rafl> Yay!

[22:39] <rafl> autrijus: I think important files should also be described, don't you?

[23:29] <geoffb> rafl, sure, but you have to be willing to keep it up to date (or make sure someone else does), otherwise it becomes worse than useless.  Second-level directories was about the best I thought we could manage.

[23:30] <geoffb> The other thing is figuring out not to have it devolve into an unhelpful mess.

[23:30] <geoffb> Perhaps the best thing is just to put a very good README in the directory in question.

[23:31] <geoffb> "how not to have it devolve into a cluttered, unhelpful mess" even.  Missing a couple words there.

