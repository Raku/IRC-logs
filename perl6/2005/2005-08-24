[01:44] <luqui> xinming, well mostly because it's just good compiler design

[01:45] <luqui> like you said, it helps us bootstrap

[01:45] <xinming> luqui: then, What will pugs be in the future?

[01:45] <luqui> and it means we have somewhere to go if parrot ends up not being so hot

[01:45] <luqui> I think pugs will always be a bootstrap

[01:45] <luqui> since Perl 6 really ought to run in Perl 6

[01:45] <xinming> luqui: So, Pugs might take place of "Parrot" :-)

[01:45] <luqui> I mean, be compiled by a perl 6 program

[01:45] <luqui> I doubt it

[01:46] <luqui> Pugs just keeps our options open, so mono, jvm, *vm, etc. can take Parrot's place if they need to

[01:46] <luqui> (javascript included in that list :-)

[01:46] <luqui> it also gives us nice portability and interoperability options if parrot does succeed, too

[01:47] <luqui> I guess the real answer is "because it's silly not to"

[01:48] <xinming> luqui: hmm, I'd like pugs can be keep pugs. :-) with too much options, might confuse some people. Just like me. :-P

[01:50] * xinming is going to read tutorials. 

[01:51] <luqui> which tutorials?

[01:52] <ingy> hola

[01:53] <xinming> luqui: maybe haskell, maybe Synopsis. :-)

[01:53] <luqui> hi ingy 

[01:53] <xinming> ingy: hi

[01:53] <luqui> ahh, indirect object syntax :-)

[01:55] <ingy> hi luqui 

[01:55] <ingy> I have become famous overnight

[01:55] <luqui> you weren't famous before?

[01:55] <obra> Maybe pugs will run on the new ruby vm

[01:55] <ingy> Wikiwyg

[01:55] <luqui> what you kill is what you get?

[01:55] <luqui> :-p

[01:56] <luqui> *what I kill

[01:56] <ingy> it del.icio.us/popular/ and all over google after 3 days

[01:56] <ingy> it's creepy

[01:57] <luqui> well...cool

[01:58] <xinming> seen autrijus 

[01:58] <jabbot> xinming: autrijus was seen 1 days 22 hours 24 minutes 39 seconds ago

[01:59] * xinming wish autrijus will take care of himself.

[01:59] <xinming> s/wish/wishes/

[02:38] <xinming> luqui: you still there please?

[02:39] <xinming> luqui: I think I found a bug in Synopsis, But I am not so sure, I just have to confirm first. ;-)

[02:40] <xinming> luqui: hmm, I was wrong, Sorry for the confusion... 

[02:41] * xinming is blind...  @_2

[02:53] <xinming> A leading [ or + indicates an enumerated character class:

[02:53] <xinming> A leading - indicates a complemented character class:

[02:53] <xinming> can anyone here give me an example for this?

[02:55] <luqui> <+[a-z]>   # alpha

[02:55] <luqui> <-[a-z]>   # any character that is not a-z

[02:56] <xinming> luqui: thanks

[03:24] <Khisanth> so no more <[^a-z]>?

[03:24] <Khisanth> hmm <[^_^]>

[03:28] <xinming> <[$_$]>

[03:29] <xinming> <[@_@]>

[03:29] <xinming> :-)

[03:30] <xinming> <[/\/| $]>

[03:32] <Khisanth> <[@_@]> for some reason I am associating that one with autrijus :)

[03:52] * jql waits for <[a-z] (-) [aeiou]>

[03:52] <svnbot6> r6441 | putter++ | PIL-Run - t/01-sanity/04-if.t passes.  iblech++

[03:52] <svnbot6> r6442 | fglock++ | * perl5/ Array - implemented boxed lazy Array

[03:52] <luqui> jql, you wait for that to be implemented?

[03:52] <luqui> or specced?

[03:52] <jql> suggested

[03:53] <luqui> it was suggested long ago

[03:53] <luqui> and it was part of perl 6 for a long while

[03:53] <jql> umm...

[03:53] <jql> no, not with the new set ops

[03:53] <jql> which are new afaik

[03:53] <luqui> (right, the semantic equivalent_)

[03:53] <jql> well, that's what I meant

[03:53] <jql> operator unification

[03:53] <luqui> still, we killed char class set ops altogether

[03:53] <luqui> other than union

[03:54] <luqui> hmmm..

[03:54] <jql> unicode bleh

[03:54] <luqui> actually, the only thing we killed was intersection, I suppose

[03:59] <svnbot6> r6443 | putter++ | EvalX.pm: unbreak t/01-sanity/03-equal.t

[04:10] <allent17> anyone in here familiar with bioperl?

[04:10] <luqui> why?

[04:10] <luqui> you going to do a perl6 port?

[04:10] <allent17> ha, nah, just need a little help

[04:10] <luqui> you should probably go ask at #perl

[04:15] <QtPlatypus> Though porting bioperl to perl6 would interesting.

[04:19] <luqui> sure... if only I knew the first thing about it

[04:19] <luqui> and if only it were useful without being really really fast

[04:19] <luqui> (I guess that's the first thing about it)

[04:20] * QtPlatypus only knows the first thing about it.

[04:21] * luqui knows that it's his bedtime

[04:27] * Khisanth has only heard complaints about bioperl

[04:34] <QtPlatypus> What sort of complaints?

[04:37] <Khisanth> they were mostly non constructive and shallow though :)

[04:37] <QtPlatypus> Damn.

[04:39] <QtPlatypus> Its just that bioperl is one of the application areas where it would be nice to get imput from.

[05:21] <tewk> ll

[05:21] <tewk> ll

[05:22] <tewk> Boy I'm good at that

[05:24] <QtPlatypus> Good at what?

[05:55] <QtPlatypus> Apprently generating random non-sequturs.

[05:56] <putter> ok, p5.  $n = '$P::x';  $$n = 3;   Question - what variable is now 3?

[05:57] <putter> bah.  $n = 'P::x';  thanks.

[05:58] <jql> $n = '$P::x' would work, too

[05:58] <jql> :)

[05:58] <jql> perl ain't picky

[06:01] <putter> ;)  though sometimes, as now, not-picky == dont notice bug until loooong after its created. :/

[06:20] *** jp-autar1 is now known as jp-autark

[06:43] <putter> ah well.  PIL-Run subs will have to wait for tomorrow (aka later today).

[06:43] <putter> &

[11:20] <xinming> @objectÂ».=meth(@args)  # calls mutator method on each

[11:21] <xinming> does this mean, @object[0] .= meth(@args), @object[1] .= meth(@args), @object[2] .= meth(@args)... ? ?

[11:45] <masak> xinming: i think so

[11:46] <masak> dang, perl6 operators can really blow one's mind

[11:48] <xinming> masak: maybe because I am not clever. T_T

[11:48] <xinming> ?eval [*](1..100)

[11:48] <evalbotzy> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 

[11:49] <xinming> ?eval [+](1..100)

[11:49] <evalbotzy> 5050 

[11:49] <xinming> I like this :-)

[11:53] <elmex> <gnaa>perl6 is too complicated and parrot will never be finished.</gnaa>

[11:55] * QtPlatypus wonders perl6 will optimize [+](1..100) -> ((1+100)*100)/2

[11:55] <QtPlatypus> I guess not would be hard to match.

[12:05] <nothingmuch> antishithemins are making me droooooowwwwzzzyyy

[12:06] <nothingmuch> QtPlatypus: with peephole optimizations and *value* inferrence it should be easy

[12:06] <nothingmuch> if I had more time i would start writing a PIL optimizer plugins

[12:06] <nothingmuch> and the optimization framework

[12:07] * QtPlatypus nods

[12:08] <masak> xinming: oh, i think you're clever. it's just that perl6 operators require that and more

[12:09] <nothingmuch> QtPlatypus: if you're tempted i posted a mail about the optimization pipeline sometime in early july, on p6l

[12:10] * QtPlatypus will take a look.

[12:11] <GeJ> Talking about optimizations, do you know if there will be a way to code a lib/module/whatever in PIR and use() it in a perl6 script?

[12:11] <GeJ> maybe there's an API already specced?

[12:12] <nothingmuch> GeJ: there will be, 100% surely

[12:12] <nothingmuch> and right now pugs has eval_pir

[12:12] <scook0> I would be very surprised if it were not possible

[12:12] <nothingmuch> but i don't think a module interface is implemented yet

[12:12] <nothingmuch> the interface should look like 'use pir:SomeModule'

[12:12] <nothingmuch> and the 'pir' foreign interface plugin defines:

[12:12] <nothingmuch> where to look

[12:12] <nothingmuch> how to load

[12:12] <nothingmuch> how the interface is exposed

[12:13] <QtPlatypus> The macro interface can almost do it.

[12:13] <scook0> nothingmuch: `use pir:SomeModule`?

[12:13] <scook0> wouldn't you just compile to PBC (or whatever), put it in your path, and say `use SomeModule`?

[12:14] <scook0> (I suppose I'm just nitpicking...)

[12:20] <nothingmuch> sorry, back

[12:20] <nothingmuch> i don't know

[12:20] <GeJ> nothingmuch: hum, yummy... :) Unfortunately, it may generate more flame from those who blame perl for being cryptic when they take a perl golf entry as "regular" perl code. :)

[12:20] <nothingmuch> i guess 'use SomeModule' should work if it was perl

[12:21] <nothingmuch> but if it's handwritten pir it's a different "domain" of code

[12:21] <nothingmuch> whether in effect it's cached bytecode from the perl somemodule, or compiled bytecode from the pir somemodule is an implementation detail

[12:21] <nothingmuch> and in fact what I'm writing to p6l at the moment

[12:51] <xinming> Any one here can give me an example of sub.wrap?

[12:55] <scook0> xinming: hmm, let me think

[12:56] <scook0> ok, let's say we have `sub eat_meal { ... }`

[12:56] <scook0> and that's all working fine

[12:57] <scook0> then at some stage we discover that we need to wash our hands before eating a meal

[12:57] <scook0> so we say:

[12:58] <scook0>   my $h = &eat_meal.wrap( { wash_hands; call } )

[12:58] <scook0> and from now on, any time we call eat_meal()

[12:58] <scook0> it will call wash_hands(), then call the original code

[12:59] <scook0> then when we don't need to do this any more

[12:59] <scook0> we say:

[12:59] <scook0>   &eat_meal.unwrap($h)

[12:59] <scook0> and it goes back to normal

[12:59] <kvakke> wow

[13:00] <kvakke> scook0: what is $h?

[13:01] <scook0> kvakke: a unique value

[13:01] <scook0> that lets you identify this particular `wrap`

[13:01] <scook0> so that you can undo it later

[13:01] <scook0> without affecting other wrappers

[13:01] <kvakke> ok, that's really cool

[13:01] <xinming> scook0: It seems like sub func will do { ... } { ... };

[13:02] <nothingmuch> scook0: we're thinking of a wrap mutiny

[13:02] <xinming> s/seems/seems to be/

[13:02] <nothingmuch> .wrap should not be mutating

[13:02] <nothingmuch> &sub.=wrap is the mutating variant

[13:02] <kvakke> I installed pugs yesterday, now I don't know what to do with all the power...

[13:02] <nothingmuch> furthermore you can edit the stack

[13:02] <scook0> nothingmuch: ooh, .= goodness

[13:02] <scook0> (functional programming)++

[13:02] <nothingmuch> and have access to the wrapper stack from within each wrapped thingy

[13:02] <nothingmuch> s/wrapped/wrapping

[13:03] <nothingmuch> s06's .wrap is too much like Hook::LexWrap which, with all due respec, is a pretty lousy interface

[13:03] <nothingmuch> &sub_with_wrapper should have the .nested_sub method to retreive the original wrapped sub

[13:03] <scook0> nothingmuch: the only issue is whether it affects everybody's view of &sub

[13:04] <nothingmuch> and also have things like '&further_augmented = &sub_with_wrapper.remove_deep_wrapper(name)'

[13:04] <nothingmuch> scook0: you can replace the symbol, or use .-

[13:04] <scook0> (which I suppose depends on the exact semantics of .= )

[13:04] <nothingmuch> (which are the same)

[13:04] <xinming> hmm, What about sub func will (first|...) `forgot the automatic hooks` ?

[13:04] <nothingmuch> &some_sub.=wrap(sub { "i'm a wrapper"; call });

[13:04] <nothingmuch> and then later

[13:04] <scook0> xinming: it was just a simple example

[13:04] <nothingmuch> &some_sub.=nested_sub; # or a better name

[13:05] <scook0> you can actually do more complicated stuff

[13:05] <nothingmuch> the subs should also give you access to the whole stack, so that if you wrap a with b to get b', and wrap b' with c to get c', you can ask c' to remove the b wrapping, and get c'', which is c wrapped around a

[13:05] <scook0> xinming: the example in S06 converts Fahrenheit to Celsius

[13:07] <scook0> actually, the `mutator mutiny` thing reminds me of one of my pet peeves:

[13:07] <scook0> the fact that s/// does mutation

[13:07] <svnbot6> r6444 | fglock++ | * PIL-RUN - (1,2,3) stringifies correctly; 'Array' implemented.

[13:08] <scook0> and it's actually /harder/ to substitute on a copy

[13:08] <nothingmuch> scook0: i agree, but It

[13:08] <nothingmuch> 's very useful none the less

[13:08] <nothingmuch> do you have an idea you could raise to p6l?

[13:09] <scook0> nothingmuch: bah, too tired for that now

[13:09] <wolverian> scook0, I suspect it's mostly to make map { s/// } ... trivial

[13:09] <wolverian> (and fast)

[13:09] <nothingmuch> wolverian: s/trivial/dangerous/; ?

[13:10] <nothingmuch> as for fast - static analysis is your friend!

[13:10] <wolverian> if you can fix it, please do!

[13:10] <scook0> (well, if we can't even change `==` for historical reasons, I don't see what chance `s///` has)

[13:11] <wolverian> I like how == behaves currently.

[13:11] <scook0> perhaps I'll just `no substitutions 'mutation'` or something :)

[13:12] <xinming> scook0: thanks, I will think more on your words.

[13:12] <scook0> wolverian: I prefer == for generic-equals, but then again I don't really have a Perl background

[13:12] <wolverian> nothingmuch, I meant s/// for @foo; above

[13:13] <wolverian> scook0, right, I do.

[13:13] <nothingmuch> wolverian: ah, that's something completely different =)

[13:13] <wolverian> and I'm sure neither of us is right. :)

[13:13] <nothingmuch> phew, long post

[13:13] <wolverian> nothingmuch, yes. I haven't slept too well. :)

[13:13] * nothingmuch is also drowsy

[13:13] <nothingmuch> anti-histhemines

[13:13] <nothingmuch> i hope my p6l post is Good Enough

[13:14] <wolverian> histamines

[13:14] <wolverian> I slept about six hours and had a lactose intolerance test in the morning, so I couldn't eat after 8pm last evening

[13:14] * nothingmuch can't spell

[13:14] <nothingmuch> oi

[13:15] <scook0> nothingmuch: better than `antishithemins` -- took me a few seconds to figure that one out :)

[13:15] <wolverian> basically, they gave me a large jug of lactose :)

[13:16] <nothingmuch> ouch

[13:16] <nothingmuch> that's horrible if you do have lactose intolerance

[13:16] <nothingmuch> do you know what lactose intolerance actually works like? I was shocked

[13:16] <wolverian> I know the mechanism, yes

[13:17] * nothingmuch imagines bacteria making a joyous feast in wolverian's tummy

[13:17] <wolverian> little bacteria farting in your stomach :)

[13:17] <wolverian> right. :)

[13:17] <nothingmuch> stomache or intestines?

[13:18] <nothingmuch> iblech, fglock, putter, stevan, autrijus, parrot people - the p6l post concerns you

[13:18] <wolverian> right, intestines.

[13:20] <scook0> bye chaps -- bedtime for me

[13:21] <nothingmuch> ciao scw 

[13:21] <nothingmuch> uh, oops

[13:21] <nothingmuch> tab completion makes it into an even bigger mess

[14:28] <nothingmuch> ciao!

[14:52] <svnbot6> r6445 | fglock++ | * PIL-Run - fixed some problems with internal recursive lists

[14:52] <svnbot6> r6446 | fglock++ | * PIL-Run - 1..1000000000000000 works

[15:44] <kvakke> ?eval [+] (1..10)

[15:44] <evalbotzy> 55 

[16:02] <Juerd> The parens are unnecessary. [op] is a listop, like print.

[16:02] <Juerd> ?eval [+] 1..10

[16:02] <evalbotzy> 55 

[16:03] <Juerd> ?eval [**] 1..10

[16:03] <evalbotzy> 1.0 

[16:03] <Juerd> :)

[16:03] <Juerd> ?eval [**] reverse 1..10

[16:03] <evalbotzy> Inf 

[16:03] <Juerd> Woo!

[16:03] <Juerd> ?eval Inf + 1

[16:03] <evalbotzy> Inf 

[16:03] <Juerd> ?eval ~Inf + 1

[16:03] <evalbotzy> Inf 

[16:03] <QtPlatypus> I thought they did bigint support

[16:03] <QtPlatypus> ?eval 2**32

[16:03] <Juerd> QtPlatypus: *this* big?

[16:03] <evalbotzy> 4294967296 

[16:03] <QtPlatypus> ?eval 2**64

[16:03] <evalbotzy> 18446744073709551616 

[16:04] <Juerd> ?eval "Inf" + 1

[16:04] <evalbotzy> Inf 

[16:04] <QtPlatypus> ?eval 2**128

[16:04] <evalbotzy> 340282366920938463463374607431768211456 

[16:04] <QtPlatypus> ?eval 2**2**2

[16:04] <evalbotzy> 16 

[16:04] <Juerd> ?eval 10**9

[16:04] <evalbotzy> 1000000000 

[16:04] <QtPlatypus> ?eval 2**2**2**2

[16:04] <Juerd> ?eval 10**9**8

[16:04] <evalbotzy> 65536 

[16:04] <evalbotzy> Inf 

[16:04] <QtPlatypus> ?eval 2**2**2**2**2

[16:04] <evalbotzy> 20035299304068464649790723515602557504478254755697514192650169737108940595563114530895061308809333481010382343429072631818229493821188126688695063647615470291650418719163515879663472194429309279820843091048559905701593189596395248633723672030029169695921561087649488892540908059114570376752085002066715637023661263597471448071117748158809141357427209671901518362825606180914588526998261414250301233911082736038437678764490432059603791244909057075603

[16:04] <QtPlatypus> ?eval 2**2**2**2**2**2

[16:04] <evalbotzy> Inf 

[16:04] <Juerd> ?eval 10**9**3

[16:04] <evalbotzy> 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

[16:04] <Juerd> ?eval 10**9**4

[16:04] <evalbotzy> 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

[16:04] <Juerd> ?eval 10**9**5

[16:04] <Juerd> (irc message limit. hehe)

[16:04] <evalbotzy> (no output)

[16:05] <Juerd> ?eval 10**9**6

[16:05] <evalbotzy> (no output)

[16:05] <Juerd> ?eval 10**9**7

[16:05] <evalbotzy> pugs: out of memory (requested 1048576 bytes) 

[16:05] <Juerd> ?eval 10**9**8

[16:05] <evalbotzy> Inf 

[16:05] <QtPlatypus> ?eval 10**10**100

[16:05] <evalbotzy> Inf 

[16:05] <Juerd> weird!

[16:05] <Juerd> 10**9**8 is inf, but 10**9**7 uses too much memory.

[16:11] <pdcawley_> Boggle

[16:18] <coral> ?eval 10**9**8**0.1

[16:18] <evalbotzy> 9.032825325192743e14 

[16:18] <svnbot6> r6447 | fglock++ | * PIL-Run tabs cleanup

[16:19] <coral> ?eval (10**9**8|10**9**8)**0.1

[16:19] <evalbotzy> Inf 

[16:40] <svnbot6> r6448 | fglock++ | * PIL-Run - registered type 'Bit'; bool::true/bool:false works

[16:44] <elmex> ?eval print "i'm stupid"

[16:44] <evalbotzy> i'm stupidbool::true 

[16:46] <elmex> ?eval print "\001ACTION pukes on the floor\001\n"

[16:46] <evalbotzy> ACTION pukes on the floor bool::true 

[16:46] <elmex> ?eval print "\001ACTION dances around\001"

[16:46] <evalbotzy> ACTION dances aroundbool::true 

[16:46] <elmex> *G*

[16:50] <wolverian> I like flaming threads that burn down to intelligent discussion.

[16:51] <elmex> ?eval print "\001ACTION dances around\001"; ""

[16:51] <evalbotzy> ACTION dances around'' 

[16:51] <elmex> ?eval print "\001ACTION dances around"; ""

[16:51] <evalbotzy> ACTION dances around'' 

[16:51] <elmex> hmm

[16:51] <elmex> ?eval print "\001ACTION dances around"; undef

[16:51] <evalbotzy> ACTION dances aroundundef 

[16:51] <svnbot6> r6449 | fglock++ | * PIL-Run - 'a' x 10000000000 works

[16:51] <elmex> wolverian: what discussion?

[16:52] <wolverian> elmex, the thread that started with Kevin Tew's "Python PMC's [sic]" on perl6-internals

[16:52] <elmex> ah :)

[16:53] <Khisanth> ?eval "\001ACTION dances around\001"

[16:53] <evalbotzy> 'ACTION dances around' 

[16:53] <elmex> weird

[16:54] <elmex> python will be the first finished (serious) language that runs on parrot ;)

[16:54] <Khisanth> ?eval print "\001ACTION dances around"; sub foo {return ""} foo

[16:54] <evalbotzy> ACTION dances around'' 

[16:55] <Khisanth> ?eval print "\001ACTION dances around"; sub foo {return "\001"} foo

[16:55] <evalbotzy> ACTION dances around'' 

[16:55] * Khisanth shakes his fist at the bot

[16:56] <elmex> *g*

[16:57] <Khisanth> hrm those would have work on some clients

[16:59] <Khisanth> elmex: how far along is python on parrot?

[17:05] <svnbot6> r6450 | fglock++ | * tabs cleanup

[17:05] <svnbot6> r6451 | putter++ | PIL-Run - namespace now hierarchical.  01-sanity/05-sub.t passes.

[17:06] <fglock> putter: ping

[17:07] <putter> fglock: pong

[17:08] <fglock> can you help to find out why 1..10.reverse doesn't work? I think the pil is not being read properly

[17:08] <putter> sure, looking...

[17:10] <putter> hmm, before I get to that, it looks like the hierarchical namespace patch broke even basic lists (3,4) ...

[17:11] <fglock> it still works here. did you update Value and Container ?

[17:12] <putter> sigh.  usual putter problem.  usual putter comment.  usual fglock suggestion.  usual fix.  usual putter post-fix comment.

[17:13] <fglock> I usually use 'svn up ../..'

[17:14] <putter> ;)  thanks.  good idea.  or just svn up .. , so pugs doesnt get updated.

[17:14] <fglock> there are 3 list constructors working: (1,2,3) (1..10) (1 x 10)

[17:15] <putter> err, where is reverse defined?  it doesnt seem to be in Prim...

[17:15] <fglock> I don't know how to specify 1..10:by(2) syntax

[17:16] <fglock> PrimP5.pm - MULTI SUB reverse (@xx) { @xx->reverse };

[17:16] <putter>  1..10:by(2) wont parse anyway.  adverbs on operators dont work yet (I only did them for f calls).

[17:23] <putter> ok, so 3 problems.  reverse(@xx) { @xx->reverse } should have been reverse(@xx) { $xx->reverse }  since @xx is now in p6 land, which becomes a $xx scalar ref in p5 land.  yeah, it sucks/confusing.  perhaps it should change.  2nd, its the other version, reverse($xx){...}, which is called currently.  that gave the ... "unimplemented" message.  3rd, method calls arent implemented in EvalX.  so (3..4).reverse reduces to reverse() which give

[17:23] <putter> s "cant call reverse on undef!".  shall I add method calls? ;)

[17:23] <svnbot6> r6452 | putter++ | PrimP5.pm: minor reverse() fixes

[17:25] <xinming> ?eval my @ary = (3, 4, 5, 6); @ary >>-<< 1 ; @ary;

[17:25] <evalbotzy> [3, 4, 5, 6] 

[17:25] <xinming> ?eval my @ary = (3, 4, 5, 6); @ary = >>-<< 1 ; @ary;

[17:25] <evalbotzy> Error:  unexpected ">" expecting term 

[17:25] <fglock> cool - reverse(1..10000000) works

[17:26] <fglock> method calls? sure!

[17:26] <xinming> hmm, How to decrease 1 for each element of an @ary?

[17:26] <wolverian> @ary>>--

[17:26] <xinming> ?eval reverse(1..10)

[17:27] <evalbotzy> '01 9 8 7 6 5 4 3 2 1' 

[17:27] <xinming> :-) It seeems it do reversing too much...

[17:27] <wolverian> @ary >>-= 1 # I assume 

[17:27] <xinming> wolverian: hmm, I know this, But...

[17:28] <xinming> ?eval my @ary = (3, 4, 5, 6); @ary >>-= 1;

[17:28] <evalbotzy> Error:  unexpected ">" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[17:28] <xinming> ?eval my @ary = (3, 4, 5, 6); @ary>>--;

[17:28] <evalbotzy> Error: Can't modify constant item: VInt 3 

[17:28] <wolverian> xinming, seems to be pugsbugs. check if there are tests for those and add them if not, please :)

[17:29] <xinming> wolverian: Certainly I will, I just ask here for confirmation.

[17:29] <wolverian> xinming++

[17:29] <wolverian> I will now go buy some food before the store closes. bye!

[17:30] <xinming> hmm, Some times, you normally use $::('nick')++, what does this mean exactly?

[17:30] <xinming> what does ++ mean.

[17:31] <fglock> xinming: I think there is a 'vote' counter

[17:31] <fglock> karma fglock

[17:31] <jabbot> fglock: fglock has neutral karma

[17:31] <fglock> mm maybe not

[17:32] <xinming> thanks anyway

[17:32] <nothingmuch> hmm, no replies =(

[17:33] <fglock> nothingmuch: people need time to think about it

[17:33] <putter> fglock: :) one line change.  (3,4).reverse now works.

[17:33] <nothingmuch> they've had a whole day, i only thought about it for 20 mins or so before I wrote it all down

[17:33] <xinming> the test has been there.

[17:33] <nothingmuch> (which took another half hour or so, but whatever)

[17:34] <xinming> someone had it written. :-P

[17:34] <svnbot6> r6453 | putter++ | EvalX.pm: add invocant to args.

[17:34] <putter> ok, that wasnt the clearest commit message I've ever done.

[17:36] <fglock> what's next? is it possible to add simple signature check, such that 'a'..'z' is called different than 0..100?

[17:37] <putter> I'd like to get the last two sanity tests running, so one can  make test-perl5 ...

[17:38] <fglock> I'll take a look at the tests

[17:39] <putter> if you get a chance and could take a look at 06-use, I'll skip ahead to plowing through getting Test.pm to compile...

[17:40] <xinming> submethod and method can be the same name in a class, so, Which one has higher priority?

[17:42] <xinming> submethod. :-)

[17:45] <nothingmuch> xinming: i think a submethod and a method cannot co-exist in the same namespace

[17:45] <nothingmuch> it just doesn't make sense

[17:48] <xinming> nothingmuch: they can. :-)

[17:48] <nothingmuch> xinming: that's horrible

[17:48] <nothingmuch> i'm guessing submethod takes over

[17:48] <nothingmuch> but only from within the class

[17:48] <xinming> You may mix methods and submethods of the same name within the class hierarchy,

[17:48] <xinming> that's from S12

[17:49] <xinming> nothingmuch: Yes, I tried, submethod has a higher priority.

[17:49] <nothingmuch> xinming: please post on p6l and ask why the hell that is allowed

[17:50] <nothingmuch> "You may mix methods and submethods of the same name within the class hierarchy"

[17:50] <xinming> nothingmuch: well, I won't. :-) I wish submethod and method can be the same name in a class. :-)

[17:50] <nothingmuch> not the same namespace, though, right?

[17:50] <xinming> nothingmuch: hmm, right...

[17:50] <nothingmuch> it means that classs a { method foo { } }; class b is a { submethod foo { } }; class c is b { method foo { } }

[17:51] <nothingmuch> in this case if you say 'a.new.foo' you get the first foo

[17:51] <xinming> But I think the default answer is "yes" to this question,

[17:51] <nothingmuch> if you say b.new.foo you also get the first foo

[17:51] <nothingmuch> if you say c.new.foo you get the third foo

[17:51] <nothingmuch> if c::foo says '$?SELF.SUPER::foo' it gets a::foo

[17:51] <xinming> ?eval class C { method a { 'a'.say }; submethod a { 'b'.say } }; C.new.a;

[17:51] <evalbotzy> b bool::true 

[17:51] <nothingmuch> the only case where b::foo is every called is if something in class b said '$?SELF.foo'

[17:52] <nothingmuch> xinming: that's just wrong

[17:52] <xinming> nothingmuch: hmm, Ok, I will post the question.

[17:53] <nothingmuch> xinming: submethods should never be accessible from outside the class

[17:53] <nothingmuch> so even if you can have 'method a' and 'submethod a' in the same class, you still can't say C.new.a and get a submethods

[17:53] <nothingmuch> s/s$//;

[17:54] <putter> fglock: hey, use Test; already works.  because of the "problem" iblech mentioned earlier - you ask pugs to compile "use Test;", and it provides a compilation of Test.pm. !:)

[17:55] <putter> ("works" in the sense that PIL for Test.pm arrives at PIL-Run, not in the sense that EvalX has a clue what to do with it.)

[17:55] <xinming> nothingmuch: In my understanding, method and submethod, their only difference is, method can be inherited, But submethod can't..

[17:55] <nothingmuch> well, yes

[17:55] <nothingmuch> submethods are like private methods

[17:55] <nothingmuch> they are utility methods that should not be shared

[17:57] <xinming> by the way, How to write "new" in perl 6? don't use bless {},$class syntax.

[17:58] <xinming> because in perl 6, a class a no longer a anonymous hash, (though we can make it)

[17:59] <PerlJam> xinming: $class.bless(...)

[17:59] <PerlJam> where ... is the bit that initializes the attributes.

[17:59] <xinming> s:nth(2)/a/is/

[17:59] <fglock> bbiab

[18:00] <xinming> PerlJam: thanks.

[18:00] <PerlJam> $class.bless(key => value,  :otherkey(othervalue))  # etc

[18:00] <xinming> PerlJam: it seems that this will create a anonymous hash "class" It's the same in perl 5

[18:01] <PerlJam> xinming: I think that people who want to write their own "new" in perl6 will really want to write a BUILD method

[18:01] <putter> fglock: bah.  Test.pm is breathtakingly non-trivial.  sanity seems to be "missing" a series of 06.01 ... 06.82  tests.  hmm, perhaps the right thing to do is to create them?  other backends will be down this path after us...

[18:02] <nothingmuch> house work... ciao!

[18:02] <PerlJam> xinming: If you still think of class Foo { has $.a, $.b; ...} as a hash with keys $.a and $.b, then sure.

[18:03] <xinming> PerlJam: But, In perl 6, Attribute can't be access via $obj.{'att_name'};

[18:03] <xinming> $class.bless( { } ); will create a perl 5 style instance. though, not so sure about $class.bless(), 

[18:03] <xinming> I would check it. bbl

[18:04] <nothingmuch> I'm guessing that Object::bless is a runtime thing

[18:05] <nothingmuch> it returns an Opaque

[18:05] <nothingmuch> and no one but the runtime knows how it's implemented

[18:05] * nothingmuch fades back out

[18:05] <ods15> hi

[18:06] * PerlJam adjusts the tuner but nothingmuch's signal is too weak  ;)

[18:07] <xinming> PerlJam: your right. :-)

[18:08] * PerlJam lunch &

[18:08] <xinming> $class.bless( 0, *%_ ) will do make a perl 6 "style" object, and $class.bless( { } ) will make a perl 5 "style" object.

[18:08] * ods15 untangle's PerlJam's & into a |

[18:08] * ods15 then proceeds to beat PerlJam over the head with it

[18:08] <putter> oh, what do y'all think?  create a series of t/01-sanity/07-XX-foo.t tests, which test each language feature as used in Test.pm.  that way, new backends work their way through 07-XX, rather than confronting a monolithiic 07-test "next, implement _all the many language features Test.pm uses".

[18:09] <xinming> hmm, I am still wrong

[18:09] <xinming> { }.bless $class might be perl 5 "style" object.

[18:10] <fglock> putter: there are many tests that could be reused - how about writing a script to run existing tests in a specified order

[18:11] <fglock> in increasing complexity

[18:13] <putter> or just making a list, and leave the scripting for later.  my one reservation is that test files will, intentionally, try to test things thoughroughly.  where here our objective is to just barely get things working well enough for Test to run, and subsequently run those same test files.

[18:16] <putter> oh, that's the gotcha.  you cant use the existing test files... they use Test! ;).  well, one could create a simple-Test.pm perhaps, and start backend's make test using -MSimplerTest until they are ready to take on Test.pm itself.

[18:20] <putter> ooo, how about that.  mumblebootstrap/Test.pm, which defines a package Test;, doing very basic Test.pm functionality, with the simplest possible code.  so given new backend, you work your way through sanity, but punt 07-test.  run with pugs -Imumblebootstrap  for a while, which swaps in the minimal Test, until you have some hope of running the real Test.pm.  thoughts?

[18:22] <putter> One could even have backend-specific mumblebootstrap/Test.pm's, tuned to whatever is simplest/first-running on backend foo.

[18:22] <fglock> how about Test::Bootstrap ? Test::MiniPerl ?

[18:24] <putter> perl5/PIL-Run/lib6/Test.pm  ?   and in EvalX  pugs -Ilib6  (which it should say anyway)

[18:24] <fglock> what's wrong with MULTI SUB postcircumfix:<[ ]> ($a,$i) {...} - it's a syntax error

[18:25] <putter> trailing semicolon?

[18:25] <fglock> no, it is there

[18:25] <putter> looking...

[18:29] <fglock> actually, nevermind - this can be specified in Prelude

[18:29] <putter> ah, so.  when you get syntax errors in Prim, there is a # print; line in the filter.  uncomment it, and perl -w crude_repl.pl > deleteme.pl.  in this case, it still says MULTI SUB.  hasnt been expanded.  apparently because of the quicky parsing in the filter \S+.  lets see, what should it be instead...

[18:30] <xinming>  hmm,

[18:30] <xinming> sub init_dbh (Str $dsn --> DBI $dbh) {

[18:30] <xinming>     $dbh .= connect($dsn);

[18:30] <xinming>     $dbh.do('some init code');

[18:30] <xinming>     say 'I return $dbh anyway!';

[18:30] <xinming> }

[18:30] <xinming> I saw this in autrijus' journal, What will --> operator be if this grammar is accepted?

[18:31] <xinming> It doesn't make sense to me... T_T

[18:31] <xinming> Or, what will --> operator do here?

[18:36] <xinming> will it just be an ',' ?

[18:37] <Juerd> It'll promise that init_dbh will return that particular DBI $dbh

[18:37] <Juerd> So my Blah::Xyzzy $dbh = init_dbh($dsn) works only if Blah::Xyzzy can handle DBI

[18:38] <Juerd> At compile time.

[18:39] <fglock> bbiab

[18:39] <xinming> Juerd: so, You think this will be a "return-type" operator?

[18:40] <putter> fglock: it's in...

[18:42] <Juerd> xinming: I'm actually quite sure.

[18:42] <svnbot6> r6454 | putter++ | PrimP5.pm: postcircumfix:<[ ]> stub.

[18:44] <xinming> Juerd: So, This is funny, Perl 6 will have a more syntax to confuse people...

[18:54] <Juerd> xinming: You're very tiring

[18:56] <wolverian> xinming, that's very obvious syntax, I think.

[19:09] <xinming> Juerd: I ever said, I am NOT clever, or talent. So please tolerate some stupid questions... :-)

[19:13] <PerlJam> Juerd:  Just imagine the thousands and millions of people who come after xinming 

[19:15] <xinming> PerlJam: Then, there should be thousands and millions one come after me... Will you commit the suicide. :-P

[19:16] <integral> billions too...

[19:18] <putter> give pugs -CPerl5 -e 'multi sub postcircumfix:<[ ]>(*@a){1} 5[6]', a postcircumfix:[ ] (with space) is defined, but a postcircumfix:[] (without) is called.  this seems not quite the right thing.

[19:22] <PerlJam> putter: that's weird.

[19:27] <buu> ?eval sub test { say $^y; say $^x } test(10,20,30);

[19:27] <evalbotzy> Error: Undeclared variable: "$^y" 

[19:27] <wolverian> I expect that's a pugsbug, buu.

[19:27] <buu> Really?

[19:27] <wolverian> s,expect,think,

[19:28] <wolverian> haven't you read the apocalypses and synopses? :)

[19:28] <buu> So what *should* it do?

[19:28] <buu> wolverian: Not for a while.

[19:28] <wolverian> it shoud say 10, 20

[19:28] <wolverian> er

[19:28] <wolverian> actually

[19:28] <wolverian> it is an error

[19:28] <wolverian> test expects two arguments, gets three

[19:28] <buu> That errors now?

[19:28] <buu> And how come $^y gets 10, doesn't $^x come before it?

[19:28] <wolverian> I think so, yes. &test.arity is 2

[19:29] <PerlJam> buu:  sub test { ... $^y ... $^x }  is the same as if you'd said  sub test ($x,$y) { .. $y .. $x }

[19:29] <wolverian> buu, oh, yes.

[19:29] <buu> Holy fucking shit.

[19:29] <wolverian> sorry. I suck at the alphabet :)

[19:29] <buu> How is that possibly a good idea?!

[19:29] <wolverian> buu, it's nice with map.

[19:29] <buu> The mind boggles.

[19:29] <PerlJam> buu: it allows you to have more than one implicit arg for those times where it's needed.

[19:30] <PerlJam> buu: in perl5 $_ got all of the implicitness, in perl6 you can spread that out a bit

[19:30] <buu> PerlJam: Until you change the name and screw the ordering.

[19:30] <PerlJam> buu: that's why it's a *shortcut*

[19:30] <wolverian> buu, that's intentional. it is to be used in very small blocks. :)

[19:30] <buu> Oh. Dear. Lord.

[19:30] <wolverian> if you don't think it is a good idea, I'm sure p6l is receptive.

[19:31] <buu> It just seems.. pointless.

[19:31] <PerlJam> buu:   sort { $^b <=> $^a } @array 

[19:31] <iblech> putter: re &postcircumfix:<[ ]> -- that's correct, but internally, we use &postcircumfix:[] so we don't have to deal with the spaces and the <>s

[19:32] <buu> PerlJam: Eh, I suppose.

[19:32] <PerlJam> buu:  map { [ $^b, $^a ] }  @stuff;  # map 2 -> 1

[19:32] <buu> PerlJam: I'd rather see $^a..z get the arguments in that order.

[19:32] <iblech> buu: sub test { say $^y; say $^x } -- that is illegal, placeholder variables only work with blocks, not subs

[19:32] <wolverian> oh, right. sorry, forgot that.

[19:32] <iblech> buu: I.e. sub foo { $^a } is illegal, but { $^a } works

[19:32] <buu> iblech: I thought blocks were subs?! What's the difference?

[19:32] <svnbot6> r6455 | putter++ | PIL-Run - Primitives can now be written in p6 (lib6/PrimP6.pm).  postcircumfix:<[ ]> moved from PIL/Run/PrimP5 to PrimP6.

[19:33] <wolverian> buu, subs have names. :)

[19:33] <buu> PerlJam: Wouldn't just saying $^a = $_[0], $^b = $_[1] make a tad more sense?

[19:33] <wolverian> (and are semantically larger collections, so $^ vars don't work well there.)

[19:33] <buu> You still get the short cuttyness, but they always mean the same thing

[19:33] <iblech> buu: Both Sub and Block isa Code, but a Block isa not a Sub

[19:33] <PerlJam> buu: why say it when it's implied.

[19:33] <PerlJam> iblech: buu really isn't ready to hear all of this  :)

[19:33] <iblech> buu: I.e. {...}.isa(Sub) is false

[19:33] <buu> PerlJam: Code clarity.

[19:34] <iblech> PerlJam: oh :)

[19:34] <buu> iblech: Ok, but that doesn't explain why $^x don't work in subs?

[19:34] <PerlJam> buu: for the times where you want more clarity, use an explicit parameter list

[19:34] <iblech> buu: Larry explicitly forbid it

[19:34] <buu> iblech: Ok.

[19:34] <buu> PerlJam: There is that.

[19:35] <putter> iblech: but I'd think PIL should use one or the other, rather than both.  for the moment I'm just crushing spaces when walking PVars.

[19:35] <PerlJam> buu: you know the perl motto, of course.  Perl6 just exponentiates the WTDI a little bit :)

[19:35] <buu> PerlJam: I just think it's wacky to see say, $^f and then five lines later see $^e and have to go back and realize the first variable was the second argument

[19:36] <putter> iblech: thanks for the info! ;)

[19:36] <iblech> putter: Right. Let me see whether I can fix that

[19:36] <PerlJam> buu: right.  But that's why the rule is so simple.  when you use implicit parameters, they are unicodically ordered.

[19:36] <buu> I suppose that's more of a programmer issue, but I'm afraid I don't see the benefits of deciding based on their order.

[19:37] <buu> PerlJam: I guess my point is more, with my way, for example, if I come across say, $^c, I always know exactly which argument it is. I don't have to read anything else, I know what it is. With this way, I still have to read the rest of the code and try to figure out their order in my head.

[19:37] <PerlJam> buu: how else would you decide their order?  You'd have to declare that right?  As soon as you're declaring them, you lose the benefit of implicitness (which maybe you shouldn't have done in the  first place)

[19:37] <buu> PerlJam: Er, no.

[19:38] <buu> PerlJam: My idea was that order was always tied to a specific variable.

[19:38] <buu> $^a is [0], $^b is [1], and so forth

[19:38] <PerlJam> oh, right.

[19:38] <PerlJam> well, ping p6l about that.

[19:39] <buu> But they're scary!

[19:39] <buu> They might eat me.

[19:39] <iblech> buu: But then you can't use more descriptive names, e.g. think of %hash.key.map:{ uc $^key }

[19:40] <buu> iblech: Don't you think that more descriptive implicit names raise the confusion level significantly?

[19:40] <buu> At least with more than one.

[19:40] <PerlJam> yeah, lwall's method allows for mnemonicity

[19:40] <iblech> buu: Actually I think more descriptive names *lower* the confusion level :)

[19:41] <PerlJam> buu: it's still another "enough rope" situtation.   Perl is all about giving you rope.  What you do with it is up to you.  :)

[19:41] <buu> iblech: They help describe what's in the variable, but then you have more letters to guess which variable comes first =/

[19:41] <PerlJam> "With great power comes great responsibility" or something.

[19:41] * buu shrugs.

[19:41] <PerlJam> ;-)

[19:42] <buu> $^foobar, $^foo_bar, etc. 

[19:42] <iblech> buu: What PerlJam said, and if you use $^aaaaa and $^aaaab then it's your fault anyway, I think :)

[19:42] <buu> heh

[19:42] <buu> Well there's certainly an argument for that.

[19:43] <putter> hmm, how do we get pugs -CPerl5 if the input use()es a module which generates output?  eg, Foo.pm is "say 'Im not perl code';"  perl -CPerl5 -e 'use Foo;' outputs bogusity.

[19:44] <putter> bogosity even

[19:44] <iblech> putter: Right. I've s/use Test/use lib/ 06-use.t because of that problem :)

[19:44] <Juerd> PerlJam: Well, Perl 6 should have some non-perl name and lots of whining will end itself.

[19:44] <iblech> putter: (I.e., I don't know a solution)

[19:45] <buu> Juerd: I doubt it.

[19:45] <putter> perhaps puts needs a -o argument?

[19:45] <iblech> putter: I like that. And we could add more hooks later, i.e. pugs -o foo.pil foo.pl; pugs -o foo.js foo.pl, etc.

[19:46] <putter> oh, do task inference based on the path name too?

[19:46] <iblech> I'd like that, yes :)

[19:46] <putter> :)

[19:48] <putter> though it feels a little like "save one argument and 4 letters at the complexity cost of becoming magical"... or does it shortcut other things too?

[19:50] <putter> I guess the other place it might bite is if .foo underspecifies, so one ends up with a mix (".foo means -ZfooA, unless a -ZfooB is also specified)

[19:50] <iblech> Hm? What argument do you have in mind?

[19:52] <putter> oh, err, -CJS ?

[19:52] <iblech> ah, but it still would have to inference the type of the input file

[19:52] <putter> pugs -BJS -e '...'   pugs -CJS -e '....'

[19:52] <putter> err, huh?  p5 vs p6?

[19:53] <putter> pugs -CJS -o foo.js  foo.pl

[19:54] <iblech> pugs -CJS -o foo.js foo.pil

[19:54] <putter> ahhhhhhh

[19:54] <iblech> but now that you say it, we could just as well forbid .pil as input

[19:55] <iblech> I.e. I would be completely fine with -CJS|Perl5|... -o output input.p6

[19:56] <putter> eh, .pil seems plausible.  I wonder still though about underspecification...  is -o foo.pl the p5 backend, the other p5 backend, the SWI prolog backend, or the YAP prolog backend?

[19:56] <putter> ;)

[19:57] <putter> but the first step atleast is just   pugs -Cperl5 -o deleteme ... to replace pugs -Cperl5 ... > deleteme

[19:58] <iblech> ok, then we definitely need -C for disambiguation

[19:58] <iblech> Right.

[19:58] *** Maddingue__ is now known as Maddingue

[20:04] <putter> mugwump: so... any plans to give Scriptalicious a persistent history cache?  so when crude_repl starts up again(and again) one still has one's command history?

[20:04] <putter> :)

[20:04] <buu> PerlJam: What is scriptalicious?

[20:05] <buu> ER, putter, sorry.

[20:05] <iblech> buu: http://search.cpan.org/author/SAMV/Scriptalicious-1.10/lib/Scriptalicious.pm

[20:06] <buu> iblech: Er, yeah, I managed to find it.. but what the heck does it do? Or rather, why is it useful?

[20:07] <iblech> buu: PIL-Run uses it, IIRC, mainly for it's easier interface to Term::Readline

[20:08] <buu> Oh.

[20:25] <nothingmuch> putter: wrt to refactoring sanity tests - ++

[20:25] <nothingmuch> xinming: --> is not a perl 6 operator... The syntax for declaring subroutine parameters is a minilanguage of it's own

[20:26] <nothingmuch> which can have embedded perl 6 in where { } clauses

[20:30] <putter> nothingmuch: thanks! :)

[20:30] <svnbot6> r6456 | putter++ | PIL-Run - ? optional arguments, p6_eval_file() added, crude_repl.pl accepts optional filenames.

[20:31] <putter> ;)  bash... that was ?$arg optional arguments ;-)

[20:32] <nothingmuch> heh

[20:32] <nothingmuch> sv* -m '$arg' not "$arg"

[20:33] * nothingmuch has been hard coded to turn on a red flag in his head whenever he scans ".*?\$.*?"

[20:34] <putter> Hmm... so I started down the PIL/Run/lib6/Test.pm minimal Test path... but since unrecognized things tend to cause death, its not clear its at all useful.  sure, you can run ok() is() etc.  but its not clear any of the .t files dont die anyway...

[20:35] <putter> nothingmuch:  yes.  but I found myself using apostrophies, so that's (sic) why I got into the habit ;)

[20:37] <putter> (I suppose I should just remind myself how to escape ' in bash...)

[20:37] <putter> prolog land - echo 'foo''bar'

[20:37] <putter> ok.  thanks nothingmuch. ;)

[20:41] <putter> dinner &   If noone has started on smashing Test.pm into a bunch of bitesized .t files, I start on that later.  fglock, iblech, everyone - tnx, was fun! ;)

[20:46] <nothingmuch> still no replies for linkage post =(

[20:50] <stevan> nothingmuch: your submethod understanding is incorrect

[20:50] <stevan> I thought the same way you did

[20:50] <stevan> but I asked Larry

[20:51] <stevan> they are not private to the class

[20:51] <stevan> you can call them from outside

[20:51] <nothingmuch> odd

[20:51] <nothingmuch> why aren't they inheritable then?

[20:51] <stevan> and the whole "method and submethod of the same name can exists in a class" is wrong

[20:51] <stevan> they are not inheritable so that you can really specialize it to a particular class

[20:51] <nothingmuch> or rather, why does something like that have it's own keyword, and such a confusing one at tht

[20:51] <stevan> yeah it does seem a bit much

[20:52] <nothingmuch> is this just for BUILD and DESTROY?

[20:52] <stevan> they basically are regular methods with the following like inserted 

[20:52] <stevan> next METHOD unless $?SELF.class =:= $?CLASS;

[20:52] <stevan> so basically if you are not local, it skips to the next applicable method

[20:52] <nothingmuch> hmm

[20:53] <stevan> BUILD and DESTROY are the only good uses I can think of myself

[20:53] <stevan> and it's a good use actually

[20:53] <stevan> becuase inherited BUILD and DESTORY can be messy

[20:53] * nothingmuch always preferred 'method BUILD is disowned { }' or something like that

[20:53] <stevan> and BUILDALL and DESTROYALL seem to the right way to go

[20:53] <nothingmuch> yeah, C++ is surprisingly sane in that respect, but only because it *REAALLLLLYUYYYYYYY* has to be

[20:56] <xinming> http://www.axis-of-aevil.net/archives/img/2003_08/p6_cover.jpg

[20:56] <xinming> lol

[20:57] <xinming> mutant

[20:57] * nothingmuch has that posted in his cube

[20:58] <xinming> well, I just saw it, And feel funny, So posted here. :-)

[21:06] <nothingmuch> xinming: yeah, it's a wonderful photo =)

[21:06] <nothingmuch> well, not really a photo, eh?

[21:12] <Khisanth> what happened to the backticks in p6?

[21:15] <xinming> hmm, May I suggest 2 method for an @ary?

[21:17] <xinming> one is "pull" which will "pull out" a slice of an array, another one might be "insert"

[21:17] <svnbot6> r6457 | fglock++ | * PIL-Run - implemented (1,2,3)[1] array subscript

[21:19] <xinming> hmm, It seems splice does this. :-S

[21:32] * nothingmuch loved splice

[21:32] <svnbot6> r6458 | fglock++ | * PIL-Run - implemented (1,2).elems; (1,2).end

[21:32] <svnbot6> r6458 | fglock++ |   - updated Container::Array

[21:32] <nothingmuch> i knew *exactly* what it was going to do, when I just saw it's name in the docs

[21:32] <nothingmuch> i haven't used it much over the years though

[21:33] <xinming> ?eval [+][1, 2, 3]

[21:33] <evalbotzy> (1, 2, 3) 

[21:33] <xinming> will [op] deference the array?

[21:33] <nothingmuch> i think it should

[21:33] <nothingmuch> [1, 2, 3] >>+<< [1, 1, 1]

[21:33] <nothingmuch> ?eval [1, 2, 3] >>+<< [1, 1, 1]

[21:33] <evalbotzy> (2, 3, 4) 

[21:33] <nothingmuch> yes, it's more consistent

[21:34] <xinming> So another bug. :-)

[21:35] <nothingmuch> xinming++; # how do you find all of these?

[21:37] <landover> hello all

[21:37] <nothingmuch> well, finally finished shower, etc... off to bed!

[21:37] <nothingmuch> landover: hi!

[21:39] <landover> how is perl6 coming along

[21:39] <nothingmuch> landover: quote well

[21:39] <landover> i have almost considered switching to python...

[21:39] <landover> joking

[21:39] <landover> heh

[21:39] <nothingmuch> if you have subversion, 'svn co http://svn.openfoundry.org/pugs/'

[21:39] <nothingmuch> landover: whatever floats yer boat

[21:40] <landover> good good must play with it

[21:40] * nothingmuch personally doesn't mind pythonites

[21:40] <nothingmuch> landover: give me an email address, i'll give you commit privs

[21:40] <landover> ya i have become friends with the pythonites

[21:40] <nothingmuch> okay, sending invite

[21:40] <nothingmuch> play nice and commit beautiful tests

[21:41] <nothingmuch> do you know where the synopses are?

[21:41] <landover> no ive been in the trenches...literally...if you know what i mean

[21:41] <landover> or should i say been doing a lot of gov work etc....

[21:42] <landover> how is parrot coming along?

[21:42] <nothingmuch> these are the most important: [email@hidden.address]
[21:42] <landover> gracias

[21:42] <nothingmuch> parrot is coming along nicely but differently

[21:42] <nothingmuch> i actually don't know that much about it

[21:42] <nothingmuch> irc://irc.perl.org/parrot is the place to discuss, i guess

[21:43] <nothingmuch> but there are some knowlegiable people here too

[21:44] <nothingmuch> ugh... i can't find the login box on openfoundry.

[21:44] <nothingmuch> i wonder what's wrong

[21:44] <landover> my only concern is that i would rather not move towards any type of a strictly typed language or should i say one that is compiled....im lazy....

[21:44] <landover> cough cough...or java....

[21:45] <nothingmuch> landover: perl 6 is strictly typed and compiled, but some of it's strict types are, for example the "Any" type, and it pretends to interpret =)

[21:45] <nothingmuch> well, at least in the future

[21:45] <nothingmuch> the type system is completely optional

[21:45] <nothingmuch> and compilation is transparent when you don't want it, but still lets you make object files

[21:45] <nothingmuch> so in short - best of both worlds

[21:46] <nothingmuch> xinming: can you understand the openfoundry interface?

[21:47] <nothingmuch> oh wait, I think I got it

[21:47] <nothingmuch> phew! english!

[21:47] <nothingmuch> okay, landover, your invitation is sent

[21:47] <landover> i suppose im the only smalltalk fan left....poor poor allan kayes

[21:47] <landover> gracias

[21:48] <nothingmuch> look around the source code, there's a bunch of READMEs

[21:48] <nothingmuch> they aren't too long

[21:48] <nothingmuch> get ghc from www.haskell.org/ghc to compile pugs

[21:48] <nothingmuch> you can also get parrot for rules

[21:49] <landover> haha ok i must be an idiot.....please dont answer that.....but what are all of the ?'s for?

[21:49] <elmex> i love smalltalk

[21:49] <nothingmuch> what ?s?

[21:49] <nothingmuch> in AUTHORS?

[21:49] <landover> the link

[21:49] <nothingmuch> oh

[21:49] <landover> on openfoundry

[21:49] <landover> ???????????????????,??????????(???)????????????????????????????????????

[21:49] <landover> ????????????????????????????????????????????????????????????????,???????????????????????????????

[21:49] <nothingmuch> that's chinese

[21:49] <nothingmuch> i'm not sure which chinese though

[21:49] <landover> ah sorry my chinese is a little bad

[21:49] <nothingmuch> once you manage to login it can become enlglish I think

[21:50] <nothingmuch> landover: that's why it took me so long to login ;-)

[21:50] <landover> hah

[21:50] <sabren> does anyone here know about pugs /Emit/PIR.hs ?

[21:51] <nothingmuch> sabren: i know a bit about it, but only meta data

[21:51] <Supaplex> sabren, I bet the fellow that wrote it does.

[21:51] <Supaplex> :P

[21:51] <Supaplex> but ask us instead :)

[21:51] <sabren> haha.. yeah.. I was hoping for a quick answer here..

[21:51] <sabren> I haven't used pugs at all.. I'm working on pirate (the python compiler)

[21:52] <nothingmuch> sabren: IIRC it is basically an PIL<->PIR

[21:52] <nothingmuch> s/an/a/;

[21:52] <nothingmuch> i think translator is the right word

[21:52] <sabren> right

[21:52] <nothingmuch> i don't think it does much - evaluating PIL is a tricky job

[21:52] <sabren> what is PIL?

[21:52] <nothingmuch> but it pretty prints PIR

[21:52] <nothingmuch> PIL is the pugs intermediate language

[21:52] <sabren> ah

[21:53] <sabren> so basically you take perl code and do a bunch of tree transformations and get PIL?

[21:53] *** autark is now known as jp-autark

[21:53] <landover> sabren can i ask you a tech question...my programming skills are obviously far less than yours if you are writing compiles

[21:53] <nothingmuch> sabren: yes, that's the bulk of pugs' job

[21:53] <landover> err compilers

[21:53] <landover> can i msg you a geek question?

[21:53] <nothingmuch> right now we have an evaluator that doesn't do PIL (from before the PIL revolution) and a PIL emitter

[21:54] <nothingmuch> PIL runtimes on javascript and perl5

[21:54] <nothingmuch> and the beginings of a new pugs runtime running PIL2

[21:54] <elmex> wtf is PIL btw. ? i know PIR and PASM ..

[21:54] <sabren> landover: I'll try to help if i can :)

[21:54] <nothingmuch> sabren: http://pugscode.org/images/simple-compilation.png

[21:54] <nothingmuch> elmex: PIL is pugs intermediate language, and it's a functional like subset of perl 6.

[21:55] <nothingmuch> very very tiny

[21:55] * xinming is going to sleep now,

[21:55] <geoffb> sabren: see also docs/notes/plan in the pugs source tree

[21:55] <xinming> bye all.

[21:55] <elmex> nothingmuch: ah

[21:55] * geoffb has finally caught up with backlog since yesterday (sheesh)

[21:55] <nothingmuch> backlogging.. *sigh*. I wish I could read that fast

[21:56] <geoffb> and damn, two of the people I need to talk to went offline, bah

[21:56] <Supaplex> the compiler looks like a zip disk :)

[21:56] <geoffb> anyone know whether leo-ctx5 has merged on the parrot side?

[21:56] <nothingmuch> Supaplex: autrijus was having fun

[21:56] <sabren> he said it's coming soon but I think they're still debating about python 

[21:56] <nothingmuch> anyway, i really want to go to sleep. Bye!

[21:56] <sabren> thanks nothingmuch :)

[21:56] <geoffb> sabren, was that comment to me?

[21:57] <sabren> geoofb: yes, sorry :)

[21:57] <sabren> er geoffb 

[21:57] <geoffb> What about python is holding up leo-ctx5?

[21:58] <sabren> geoffb: supposedly it breaks all the python pmcs... I don't know if it's holding him up or not but they've been going back and forth on the perl6 and pirate lists

[21:58] <geoffb> iblech, putter: if you backlog, I have questions for both of you, and answers for one of you.  :-)

[21:58] <geoffb> sabren, *sigh*, OK

[22:04] <sabren> so here's the thing: with pirate, we're working to turn our single-pass compiler into a series of tree transformations

[22:05] <sabren> and the end result should look a lot like PIR

[22:05] <sabren> so that's why I'm looking at Emit/PIR.hs ... to see if we've got some overlap here

[22:06] <geoffb> sabren: did you check out docs/notes/plan?

[22:06] <sabren> geoffb: reading it now

[22:06] <geoffb> (y)

[22:07] <geoffb> There are probably a few bits that are somewhat out of date (that file is probably a month old now), but the basic concepts should be clear

[22:07] <geoffb> also STATUS in the top level (which I just updated) has some more up-to-date info about progress

[22:08] <landover> hah its funny around 2/3 years ago i left irc world....and within ten minutes i've realized what the hell i've been missing

[22:08] <landover> people that know what the hell they are actually doing heh

[22:08] <geoffb> landover, it helps to be on a channel with a fairly high SNR . . . 

[22:10] <geoffb> Speaking of IRC, anyone happen to know if IRC has a delayed-message function, to send a message to someone who is not currently on?

[22:11] <svnbot6> r6459 | geoffb++ | Update, extend, and clean up STATUS

[22:12] <landover> geoffb not that i can recall

[22:12] <landover> u can prob write a python/perl script that will check when that ip is logged on

[22:12] <geoffb> bah, that would make some things a lot easier

[22:12] <buu> geoffb: Most networks tend to provide such services.

[22:12] <landover> buu oh?

[22:12] <buu> I don't believe it's a part of any spec.

[22:12] <landover> i didnt know that

[22:13] <landover> right

[22:13] <geoffb> buu: how do you do it on freenode?

[22:13] <buu> memoserv

[22:13] <sabren> geoffb : so... PIL is basically scheme... does it have first class objects?

[22:14] <geoffb> iblech, putter, or autrijus (none of whom are not around at the moment, sigh) would be better to ask, but:

[22:14] <geoffb> iblech said yesterday that PIL1 does not have proper OO support, but PIL2 does.

[22:14] <geoffb> Sadly, PIL2 is not yet ready, because autrijus is buried in his day job

[22:16] <geoffb> Hmmm, fglock and stevan might know as well, but I believe they are idle

[22:17] <geoffb> and nothingmuch is gone as well.

[22:17] <geoffb> Damn this timezone!

[22:17] <sabren> :)

[22:17] <sabren> it's okay, I'm just trying to get a feel for where you guys are at

[22:17] <landover> well if everyone in this room chipped in oh 10 bucks a day...we could prob pay his ass to do it

[22:18] <geoffb> $970 a day?  Dude, I'd work for that!

[22:18] <landover> now you see what i mean

[22:18] <landover> literally we could hire people to support our own cause heh

[22:18] <landover> i dont mind chipping in 50 a week to someone....

[22:18] <landover> if i know that i'll have a job...1-2-5 years from now

[22:19] <landover> its like an investment thats better than education heh

[22:19] <geoffb> Sadly, and I've never understood quite why, many of the people in here are permanent lurkers -- I'm not quite sure why they don't just use the HTML irc logs.

[22:19] <landover> ah geo mainly to steal good ideas....

[22:20] <landover> you know im only here to see if im going to be out of a job...6 months or a year....to program in j2ee....blah

[22:20] <landover> heh

[22:20] <landover> actually they say all good things come to those who wait

[22:21] <buu> geoffb: I'm sucking your brains out.

[22:22] <sabren> so... is PIL2 something thats months down the line? weeks? days?

[22:23] <geoffb> buu: aaaaaaahhhhhh

[22:23] <geoffb> What a nice pressure release

[22:23] <buu> Exactly. It's like trepanation.. with tentacles!

[22:23] <geoffb> sabren, PIL2 was supposed to be this month-ish, but autrijus has been delayed

[22:23] <landover> geoff we need a bot that says autrijus is working is not working is busy ..or is delayed

[22:24] <geoffb> sabren, I do remember that someone from the Python side had talked with him at the leo hackathon about making PIL useful to both Perl 6 and Python compilers

[22:24] <landover> speaking of autrijus i really hope the us doesnt go to war with china over taiwan...then i'd be enemies with autrijus that would be really pretty

[22:24] <sabren> geoffb : that was me :)

[22:24] <landover> err wouldnt be really pretty

[22:25] <sabren> oh wait

[22:25] <geoffb> landover, just because nations go to war, doesn't mean people do

[22:25] <sabren> i wasn't at leo's.. i only talked to him on the list

[22:25] <geoffb> sabren, it's possible that's what I recall, sorry, it's been a while

[22:30] <buu> geoffb: It is unlikely.

[22:30] <buu> s/geoffb/landover/

[22:31] <landover> buu oh absolutely..i was trying to make a poor excuse of a joke

[22:32] <buu> Kim Il Jong scored 5 hole in ones the first time he played golf!

[22:32] <buu> Or kim jong il, whatever his name is

[22:32] <landover> hahahahaha

[22:34] <leo__> the PIL2 scheme emerged here on a flipchart, well, in Autrijus' own speed. But I've to admit that it is beyond my understanding. To work against my troubles of groking FP, I've implemented unlambda and major parts of Lazy-k in Parrot ;-)

[22:36] <sabren> hey leo!

[22:36] <leo__> (I'm not aware of a specific discussion PIL/Python, but as PIL2 can represent Perl6 code, there are for sure no problems to represent different languages in PIL)

[22:37] <leo__> hi all - just delurking a bit

[22:37] <sabren> the thing is, right now pirate already compiles a whole slew of stuff

[22:38] <geoffb> leo__, ah!  So can you explain the status of leo-ctx5?  The last update I have is that the PIR backend is blocked waiting on that merge . . . .

[22:38] <geoffb> (PIR backend for pugs, I mean)

[22:38] <sabren> but we're refactoring it... i'm just trying to keep where pugs is headed in mind so that we might possibly be able to integrate the two later on

[22:39] <geoffb> nodnod

[22:39] <landover> got it

[22:39] <leo__> geoffb: yes, first merge, then continue with impoved (workable) lexical handling and variable sized register frames

[22:40] <leo__> sabren: dynclasses/py* did implement already too much of CPython - IMHO

[22:40] <leo__> some refactoring is really needed

[22:40] <geoffb> leo__, is merge near, or still far?

[22:41] <sabren> leo: I'm just the AST guy... one of these days I'll learn C :)

[22:41] <leo__> chip is looking at the code currently, I hope the merge is in the next release, which is due soon

[22:41] <geoffb> ah, fantastic

[22:42] <sabren> Leo: btw, python_group still doesn't show up correctly in the current parrot tree

[22:42] <sabren> it broke right after the last release

[22:42] <landover> hey isnt this a perl6 room note python? heh

[22:42] <landover> just kidding

[22:42] <sabren> perl6 is so cool it does python too :)

[22:42] <landover> ROFL

[22:42] <landover> try explaining that to an illogical technical manager

[22:43] <sabren> leo: any idea why it might break?

[22:44] <leo__> sabren: I dunno what 'show up' mean and that should reall better be explored on p6i or #parrot

[22:44] <sabren> leo: haha... yeah but you're not in parrot, and when I mentioned it before on p6i you said it should be working... so i'm stumped

[22:45] <sabren> leo: Couldn't load 'python_group': python_group.so: cannot open shared object file: No such file or directory

[22:45] <landover> is the path correct?

[22:46] <leo__> sabren: I'm of course in the #parrot channel and listening there too

[22:47] <leo__> - but you aren't ;-)

[22:47] <sabren> it's not on irc.freenode.net?

[22:47] <leo__> no

[22:48] <leo__> pobox

[22:48] <geoffb> painful that the two are on different nets, it's a FAQ at this point

[22:48] <leo__> pobox: irc.pobox.com:6667

[22:49] <buu> geoffb: Heh, so where is the answer?

[22:50] <sabren> well that would certainly explain why there's never anyone in #parrot.. thanks

[22:50] <geoffb> buu, here and there.  Constantly.

[22:50] <geoffb> :-)

[22:50] <buu> geoffb: Er, what?

[22:50] <leo__> sabren: it's probably too easy to create 'talk with yourself private channels'

[22:51] <geoffb> buu, I meant, it gets answered over and over in each channel, because people are often in one and want to get to the other

[22:51] <geoffb> leo__, definitely

[22:51] <buu> geoffb: ER, so what is the answer?

[22:52] <geoffb> buu, if you're asking *why*, I have no idea, if you're asking where #parrot is, leo__ just said where to look

[22:52] <leo__> $ grep -w irc docs/*.pod

[22:52] <leo__> (inside parrot )

[22:52] <buu> geoffb: No no, I wanted a why =/

[22:54] <leo__> dunno yest what even the problem is - wait a minute

[22:54] <leo__> s,,s,

[22:56] <landover> geoffb we could probably bridge the two channels using a python script that would just forward all messages from one to the other

[22:57] <leo__> that'll need a really good filtering language then ;-)

[22:57] <landover> why?

[22:59] <geoffb> landover, do you mean #parrot on pobox to #parrot on freenode?  Or #parrot on pobox to #perl6 on freenode?

[22:59] <geoffb> The former might be reasonable.  The latter would be PAINFUL

[22:59] <landover> former of course

[22:59] <landover> well it works the same way as a port forward program does

[23:00] <landover> hell the guys over at twisted could probably whip it up in an hour or so

[23:02] <leo__> landover: just in case if forwarding starts spitting out evalbotzy at #parrot ;-)

[23:05] *** skylan_ is now known as skylan

[23:07] <leo__> pytuple.pmc:163 is 

[23:07] <leo__>         if (!SELF.elements())

[23:07] <leo__> oops

[23:08] <leo__> # there must be some working shortcut key to switch windows in irssi OS/X ;-)

[23:12] <leo__> # ah must have hit ^N

[23:16] * leo__ thinks that now all have started the irc forwarder hack ;-)

