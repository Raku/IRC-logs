[01:50] <stevan> geoffb: ping

[01:56] <geoffb> stevan, pong

[02:17] <geoffb> well gee, I was a little slow in replying, but not THAT bad . . . 

[02:17] <stevan> LOL

[02:17] <stevan> sorry geoffb was doing $work

[02:17] <stevan> revdiablo: PIL and no class support

[02:17] <stevan> I head iblech say that too

[02:18] <geoffb> nodnod

[02:18] <stevan> but I know little more than that

[02:19] <stevan> it did not have multimethod support until very recently either

[02:19] <geoffb> oh, do tell!  :-)

[02:19] <stevan> iblech asked me about a multimethod for the JS metamodel

[02:19] <stevan> i hacked one which dispatched based on arity

[02:19] <stevan> it was total crap, but just to get things started

[02:20] <stevan> then autrijus came in and added it to PIL

[02:20] <stevan> but all it really did was just allow 2 things with the same name IIRC

[02:21] <geoffb> So MMD is broken in PIL1 . . . what about PIL2?  Or is PIL2 not even ready to ask that question?

[02:21] <stevan> I think it is not broken so much as not directly addressed by PIL1

[02:22] <geoffb> fair enough

[02:22] <geoffb> and PIL2?

[02:23] <stevan> I am not sure

[02:23] <stevan> I think only autrijus knows that :)

[02:23] <geoffb> fair enough.  :-)

[02:23] <stevan> I think MMD will likely not be addressed in PIL2 though

[02:23] <stevan> other than to allow 2 things with the same short name

[02:23] <stevan> because how it is done is really somewhat of an implementation detail for the runtime

[02:24] <geoffb> The backend is expected to call into the OOMM for that, yes?

[02:24] <stevan> geoffb: no descision is made as to if the MM will handle that or not

[02:24] <geoffb> wheee

[02:24] <stevan> I tend to think that given the existence of multi subs there is little need to implement specific multimethods

[02:25] <geoffb> nod

[02:25] <stevan> all methods are in the MM are closures around the sub body

[02:25] <geoffb> k

[02:26] <stevan> the MM2 shows this fairly well (IMHO that is :)

[02:26] <stevan> chaos.pl, there are some ::make_method() functions

[02:26] <stevan> it basically just binds $?SELF and $?CLASS in the methods scope

[02:27] <stevan> then private methods and submethods just add checks before the actual method code

[02:27] <stevan> they are checks wrapped around methods which are wrappers around the subs

[02:28] <stevan> now eventually I think this part will get replaced by some kind of Sub object which is part of the runtime

[02:28] <stevan> so I assume that a mutlimethod will just be a wrapper around the multisub from the runtime 

[02:28] <geoffb> fair enough

[02:29] <geoffb> (getting to be my favorite response tonight -- maybe need to abbreviate to FE)

[02:29] <stevan> :)

[02:30] <stevan> of course,.. all these details will be ironed out as more metamodel integration of runtimes and such are done

[02:30] <stevan> nothing like other people using your code to find all the ugly corners in it :)

[02:30] <geoffb> .oO( Man, I have *got* to arrange for more time for this stuff, it's just too fun)

[02:30] <geoffb> heh

[02:30] <stevan> :)

[02:30] <stevan> me too,.. I should be $working

[02:30] <dudley> stevan: do you see the MM being implemented in perl6 any time soon?

[02:31] <stevan> dudley: I think the plan is as follows

[02:31] <stevan> 1) get PIL2 working

[02:31] <stevan> 2) get MM2 working

[02:31] <geoffb> I like Conway's idea of having people send you their sample scripts, after giving them only the module's name and purpose -- but I wonder who he knows that has the tuits for that

[02:31] <stevan> 3) port MM2 to Haskell (actually they may be developed simultaniously)

[02:31] <stevan> 4) port MM to Perl 6 using the Haskell MM to bootstrap

[02:33] <putter> hi all.

[02:34] <geoffb> putter!

[02:34] <putter> geoffb: any remaining questions?

[02:34] <geoffb> Well, actually, I had some info for you, re: t/01-sanity

[02:34] <putter> ooo, info always appreciated.

[02:34] <stevan> hullo putter

[02:34] <geoffb> I was the original author of the whole dir.

[02:35] <putter> hi stevan.

[02:35] <geoffb> The reasons for the huge functional jump from 06-use to 07-test are:

[02:36] <putter> (ah, the suspense...;)

[02:36] <geoffb> 1) I was running low on tuits after 6, so knew it was important to get what I had committed (and it looks like it has been valuable, yay!)

[02:36] <geoffb> 2) I knew Test.pm was needed by virtually everything else,

[02:36] <putter> indeed. definite yay.

[02:37] <geoffb> 3) Test.pm is such a completely crazy piece of code (using advanced features in the module that is used to test basic features is WRONG to me)

[02:37] <geoffb> 4) I planned to rewrite Test.pm in much simpler version, then build a replacement 07 -> 99 or whatever that included each needed feature one by one,

[02:37] <geoffb> in the same fashion as 01-06

[02:38] <geoffb> So basically: 07 was a stopgap, just until I got more tuits,

[02:38] <geoffb> which of course, I didn't.

[02:38] <putter> :)

[02:38] <geoffb> So:

[02:38] <putter> ahh.

[02:38] <putter> hmm....

[02:38] <geoffb> I'd like to see 07 change number to 99 or so,

[02:38] <geoffb> and fill in 07-98 with granular tests.

[02:39] <geoffb> The key in my mind, was that Test.pm should also get MUCH SIMPLER.

[02:39] <putter> I started on a simple Test.  It quickly revealed that if you want to use a simple test, then you need a notably tolerant compiler.

[02:39] <geoffb> It's using inappropriate features for a self-test

[02:39] <geoffb> by which I assume you mean "pugs is not sufficiently tolerant"?

[02:40] <putter> with pugs, there was this eval_ok, etc, game.  each new backend doesnt get to play.  so it either very quickly catches up with pugs, or it need to tolerate "all sorts of stuff is going on which I dont understand... continuing"

[02:40] <geoffb> ls

[02:40] <geoffb> oops, wrong window :-)

[02:41] <geoffb> nodnod

[02:41] <geoffb> Hmmmm.

[02:42] * putter remembers a gnu window manager writen by a mob of paranoid people.  a _real_ warning message said  segfault... bus error... continuing... ;)

[02:42] <geoffb> ouch

[02:43] <geoffb> OK, one thing I did long ago was run a script through the test trees determining which subs in Test.pm were used at what percentage.

[02:43] <putter> neat.

[02:44] <geoffb> As I recall, something like half the tests were just using ok() and plan(), and there was a pretty nice inverse drop off as you went to rarer calls

[02:45] <geoffb> So perhaps we can just do a Test::Mini that contains only like 4-5 extremely basic functions (plan, ok, is, ...)

[02:46] <geoffb> and do 07-test-mini, before 99-test.

[02:46] <geoffb> Do you think that would help the backend people?

[02:46] <putter> I've just uploaded my simple-Test experiment.  6460.

[02:47] <geoffb> pulling

[02:47] <putter> I'm not sure,

[02:47] <putter> a question is what the right way to go about building a backend is.

[02:48] <geoffb> It seems like people comment about going through 01-sanity's 01-06, and then there's this big delay while they work on 07.

[02:48] <geoffb> That seems like too high a cliff, and I think you've said that very thing within the last day.  :-)

[02:50] <geoffb> at least autrijus and iblech have worked through 01-sanity, and I thought at least one person on the P5 team was doing so as well.

[02:50] <svnbot6> r6460 | putter++ | PIL-Run/lib6/Test.pm: created.  A _simple_ Test replacement for PIL-Run.  use Test;  Its usefulness is not clear.

[02:52] <putter> Ok, bottom up.  My puzzle is that even with this simple Test, likely none of the .t files will do anything but compilefail.  Perhaps that's a compiler issue.  Pehaps each bit of file should be wrapped in an eval, so performance always degrades gracefully.  But if not,

[02:54] <putter> then Test, and its complexity, isnt really the problem.  Rather that the big-test-file approach is fine when program and tests grow together, but not when "second class - dont mess with the test files" programs are trying to bootstrap.

[02:55] <geoffb> I think I failed to mention a step in my thinking:

[02:56] <putter> s/each bit of file/each bit of compiled code/

[02:56] <geoffb> bah, I'm confusing myself

[02:57] <geoffb> dammit

[02:57] <putter> ! ;)

[03:00] <putter> having small sanity tests, like the current ones, allows one to do a hill-climbing design-a-bit, code-a-bit, test-a-bit, recurse.  But I'm not sure that's actually useful...  If PIL2 was done, I'd say you document and annotate it, sketch implementation approaches, and then do a broad push implementation.  The design-a-bit part is just asking for pain, if you have access to the big picture.  And if you have a broad implementation front, 

[03:00] <putter> bitesize test files are less important.

[03:00] <putter> s/actually useful/actually useful long-term/

[03:01] <geoffb> sorry, was AFK to deal with kid

[03:02] <putter> Eg, JS has a nice spec.  I can with some confidence mechanically transform it into an implementation, and expect to hit it at the end with a test suite, and have things go well.

[03:02] <putter> np.  I understand completely.

[03:03] <geoffb> well, here's my thought, which I think has finally coagulated:

[03:03] <putter> There, microtests just wouldn't be of interest.  So there is something about the state of spec-ness which determines the ideal shape of testing.

[03:04] <geoffb> Your plan would be generally correct, *if* PIL2 was finished, but:

[03:04] <geoffb> 1) PIL2 isn't finished, so we've got people like iblech still working with finding the corner cases in PIL1 (which will have to be handled by PIL2 anyway)

[03:05] <geoffb> 2) It's almost guaranteed that even if there was a spec, there would be bugs in either the spec or the new backend implementation, so

[03:05] <geoffb> 3) It's best to be able to test the whole big all-at-once PIL2 backend in little bite sized pieces anyway,

[03:05] <geoffb> because I guarantee that the first test run after getting all the code written will explode in a thousand points of light,

[03:06] <geoffb> and then you have to work from the bottom to figure out what you did wrong.

[03:06] <geoffb> And the jump from 06-use to 07-test is so high that you have no idea why 06-use is working but 07-test is not.

[03:06] <geoffb> EOL

[03:07] <geoffb> Did that all make sense?

[03:07] <putter> yes, but ;)

[03:08] <geoffb> :-)

[03:10] <putter> one question is what does PIL2 look like vis PIL1.  the fuzzy impression I've gotten from autrijus is the PIL1-ish aspects of PIL2 are very similar to PIL1.  (I should go back and reread the log (of a couple of days ago?) where autrijus argues PIL-Run development doesnt have to wait on PIL2).

[03:10] <geoffb> ah, didn't backlog that far

[03:12] <putter> if PIL1 isnt "going away real soon", then rather than tweaking PIL-Run, I should probably be documenting PIL and _designing_ PIL-Run.  the key is

[03:14] <putter> sigh.  if the test files were all maximally aggressive oo p6, then there would be a step function. you have no hope of running the tests at all until it's likely your about to pass most of them.

[03:15] <putter> so a question is, how do we characterize the _current_ state of the tests.  the "language subset" required to reasonably run them.  if

[03:16] <geoffb> (that very need, to express a working language subset at a time, is about half of why I created 01-sanity in the first place)

[03:16] <putter> it is something that isnt very deep, that one can approach with a combination of coding from spec, and little hand-written debugging cases, then having little test-file cases buy you... what?

[03:18] <putter> right.  with sanity, PIL-Run wouldnt exist.  (err, there's an obvious variant on that which I wont mention)

[03:18] <geoffb> heh

[03:19] <geoffb> so what exactly is different between 01-sanity and "little hand-written debugging cases", except that 01-sanity is part of the test suite?

[03:19] <geoffb> Yes,

[03:19] <geoffb> I know that hand-written cases will uncover stuff that tests just can't.

[03:20] <geoffb> I guess I'm saying, as much as possible of those hand-written cases should become part of 01-sanity, so that all backends will just have it.

[03:20] <geoffb> Part of all of this is I don't want to see each backend have to reinvent all the tests they'll need to get to having a large enough language subset working to run the main test suite

[03:20] <putter> err, at least in its current form.  micro-history of PIL-Run... whatever happend before I saw it... nothing much say it will be a long time before there are backends... thus challenged (and because a said backends were to be important rsn), putter creates p5 backend in a day or so... iblech explodes with JS backend... putter punts p5 backend... autrijus says, no, do it now... putter goes back to hacking on it a bit... present day. ;)

[03:21] <geoffb> heh

[03:25] <putter> re difference, similar in size, but hand-written is throwaway to debuggingly lubricate the convergence of backend and suite.  hmm, if suite were 10k test files of one test each, rather than 500 of 20, would we be having this conversation?

[03:27] <geoffb> yes, we would, because the test suite as it is now generally has every test file assume that all other features are working, if they were working in base pugs (haskell runloop) when the test file was written

[03:27] <geoffb> I would LOVE to be able to refactor the test suite not to have that behavior,

[03:27] <geoffb> but that's MASSIVELY more tuits than I have

[03:27] <dudley> (debuggingly lubricate)++

[03:27] <geoffb> So I'm advocating starting bit by bit in 01-sanity

[03:28] <putter> really?  I thought most tests were like ok(<testexpr>) or is(<testexpr>,<very simplee xpected result>)

[03:28] <geoffb> and maybe doing 02- and so on directories later, which might be largely movement of existing test files

[03:28] <geoffb> lemme find example

[03:29] <geoffb> wow, the very first one I checked.

[03:29] <geoffb> t/builtins/undef.t

[03:29] <geoffb> just keep scrolling.

[03:29] <geoffb> MANY language features get tested in there.

[03:30] <putter> while you're looking, I'll do the correlary.  if the tests would be fine if done independently, then the problem is the file-compile coupling of tests in the same file.  the file-compile succeeding or failing as a whole.

[03:30] <putter> looking...

[03:31] <geoffb> yes, I do think that's a problem,

[03:31] <putter> though my fuzzy recollection is undef.t ended up a slush of tests for any aspect of any feature which returns undef.

[03:32] <geoffb> but also there's this case: I want to test whether feature bar works with feature foo.  So I test foo + bar.  Even though foo and bar may not have been tested yet.  So I could get foo + bar fails before finding out that the real problem is that bar is broken.

[03:32] <geoffb> In math terms, there's a partial ordering that we could apply to the test suite, but right now, that's not done, except in 01-sanity

[03:33] <putter> ok, so undef.t points out at least two issues.  the setup for a test may depend on a breadth of language feature incidental to the test.  and tests may be coupled together by a common setup.

[03:33] <geoffb> NODNOD

[03:36] <geoffb> .oO( I wish IRC supported seeing whether someone else was typing )

[03:38] <geoffb> putter, if you're still typing, hit enter -- otherwise, I should amble off and visit $spouse

[03:38] <putter> if you can get your implementation within a short distance (few debugging steps) of working, then even the undef tests are small enough to hand-generate tests to close the gap.  agreed?  then the question is, is the space of such tests small enough that one can write some useful subset of them before hand, as part of the test suite.  one point here is that a failing tests doesnt just test and flag what it is officially there to test, bu

[03:38] <putter> t other stuff too.  if everything *should* be working, this is a feature, not a bug.  its only a bug if the entire test suite gives you lots of "well, yes, I know *that* isnt working. I just wanted to test *foo* in isolation".

[03:38] <geoffb> holy crap

[03:38] <putter> lol

[03:39] <geoffb> And I contend that we are currently in that latter case of conflated test hell.

[03:39] <putter> the state-of-spec ties in by making "everything *should* work" more likely, so test isolation is less important.

[03:41] <geoffb> iblech has been slowly moving up in % test success, but that % has had little correlation with actual work done, because stuff like eval() working suddenly makes a whole bunch of tests work that have nothing to do with the features supposedly tested.

[03:41] <putter> agreed.  but is the way out to change the tests, or to document PIL1?

[03:41] <geoffb> Would you buy "Do both, this is Pugs we're talking about?"

[03:41] <putter> right.  but is % anything but a spectator metric?

[03:41] <jql> don't undervalue the spectators

[03:42] * jql sits back down on the bleachers

[03:42] <putter> ;)

[03:42] <putter> hmm, one question is whether the test noise hides useful information which would help PIL2JS development.

[03:42] <geoffb> I think it is, actually, though only by proxy -- because when iblech sees a bunch of red in his smoke, he has to mentally filter out which are real problems, and which are just because something implicitely expected by a block of tests isn't there

[03:42] <geoffb> and jql is absolutely right, I might add

[03:43] <geoffb> putter, yes, I think so

[03:43] <putter> if iblech isnt really using the tests to figure out what needs to be done next, what is or isnt or regressingly isnt working...

[03:43] <geoffb> that parsefailed.

[03:44] <geoffb> I'm saying, the original idea that autrijus had was to do pugs as test-driven development.  Except now, major portions of the project aren't depending on the test suite, because it doesn't help them.

[03:44] <geoffb> And I think that's BAD

[03:45] <geoffb> s/aren't/can't/

[03:45] <geoffb> OK, so:

[03:45] <luqui> geoffb, what portions are those?

[03:45] <putter> i think you answered it... iblech is looking at the test failures to guide development... though the next question is, what is the cost of the noise, are his mental filters working...

[03:45] <putter> ah.

[03:46] <geoffb> I think in iblech's case, his mental filters work fine.

[03:46] <geoffb> The problem is, that only works because iblech is uncommonly smart.

[03:46] <putter> but for "test driven development', you want something more accessible...

[03:46] <geoffb> That's not reasonable to expect from everyone

[03:46] <geoffb> yes

[03:46] <geoffb> that's my point exactly

[03:47] * putter is tempted to do some bulk analysis of the test suite to see how much coupling happens and where...

[03:48] <jql> it's one of the perils of mixing the standardization committee's code repository with the reference implementation test suite

[03:48] <geoffb> It reminds me in a way of Linux kernel dev before Linus got version control religion.  People were trying to explain that he was only holding things together by the fact that he's a genius, but not having version control just doesn't scale . . . .

[03:48] <putter> but... say I did that, and every test became minimal and independent...  PIL-Run would still be unable to run any test file.

[03:49] <geoffb> But as iblech pointed out, PIL-Run *does* run several test files -- in 01-sanity, where there is little implied requirements.

[03:49] <geoffb> which kindof makes my point.  :-)

[03:49] <geoffb> jql: I think I understand and agree.

[03:50] <putter> its "tests have minimal bagage" and "tests can be confronted independently"

[03:50] <geoffb> nodnod

[03:51] <putter> the second could be test-infrastructural, or tolerant compilation.

[03:51] <jql> I might add "test for capability" and "test for regression"

[03:51] <geoffb> Now, there is *absolutely* need for tests that mix features, because many pugsbugs have involved two features that work independently, but not together, I'm just saying that the test suite *also* needs independent tests

[03:51] <putter> jql: ?

[03:52] <jql> I'm nattering on about my standardization-committee tests

[03:52] <geoffb> nattering++

[03:52] <jql> tests which define perl6 vs. tests which detect broken implementation/features

[03:52] <geoffb> right

[03:54] <geoffb> <voice character="obi-wan">Use the [enter] key, putter . . .</voice>

[03:54] <geoffb> :-)

[03:54] <putter> hmm.  two ideas come to mind.  reaching into PIL-Run's EvalX and wrapping the generated code for every PStmt in an eval.  and _then_ see what happens with the test suite.

[03:54] <putter> ;)

[03:55] <geoffb> interesting idea

[03:56] <geoffb> OK, I really must get AFK, so as to remain friendly with better half.

[03:56] <geoffb> I'll backlog later/tomorrow.

[03:56] <putter> and bulk massaging the test files, ripping out chucks (test lines, ^^{...^^} blocks, etc) and seeing if pugs/JS/PILRun can deal with each chunk..

[03:56] <putter> ok.

[03:57] <putter> thanks geoffb

[03:57] <putter> that was most interesting and useful.

[03:57] <geoffb> sure, np, good discussion.  :-)

[03:57] <putter> notice my many enters. ;)

[03:57] <geoffb> heh

[03:57] <geoffb> THANK YOU

[03:57] <putter> good night.

[03:57] <geoffb> ditto

[04:19] <putter> for completeness, I note one aspect of testing we didnt discuss... automated test generation.  spew regex and strings to test rules.  spew code to test the parser.  spew PIL to test the backends.

[04:46] <svnbot6> r6461 | putter++ | Added missing "use v6;" to 3 test files.

[04:47] <putter> fyi, ~410 t/ .t files with ~7600 tests.

[04:58] <putter> 2/5 outliers account for 20/30% of tests.  the rest average a bit more than 10 tests / file.

[05:11] <landover> hi all

[05:12] <dudley> hello

[05:17] <luqui> hello

[08:21] <nothingmuch> hi ho

[08:22] <QtPlatypus> Hi nothingmuch 

[08:22] <nothingmuch> what a long morning

[08:22] * nothingmuch sorted out something like 25 expense receipts

[08:22] <nothingmuch> anyway, someone is in need of help... ciao!

[08:27] <svnbot6> r6462 | Stevan++ | Perl6::MetaModel 2.0 -

[08:27] <svnbot6> r6462 | Stevan++ | * added the META:: pseudo package so things will

[08:27] <svnbot6> r6462 | Stevan++ |   get disapatched from META to non-META properly

[08:27] <svnbot6> r6462 | Stevan++ |   - however this is currently somewhat broken.

[08:27] <svnbot6> r6462 | Stevan++ |     basically it all works fine until I make

[08:27] <svnbot6> r6462 | Stevan++ |     $::Object the superclass of $::Class and then

[08:27] <svnbot6> r6462 | Stevan++ |     things start to spin out of control. I will

[08:27] <svnbot6> r6462 | Stevan++ |     have to investigate this more after sleeping :)

[08:46] <nothingmuch> *sigh*... 4.18% (7454.14 MB) @ 3.24MB/s ETA: 52733s

[08:51] <scook0> nothingmuch: that's a lot of megs...

[08:51] <nothingmuch> scook0: 200gb

[08:52] <nothingmuch> one file being split into 8 files

[08:52] <nothingmuch> i wonder if I can optimize the script

[08:52] <scook0> yeowch

[08:53] <nothingmuch> currently it does <$in>, matches a field, hashes the field into an index, and finds the output handle in an array

[08:53] <scook0> what on earth are you doing?

[08:53] <nothingmuch> (hashing is a modolu and an addition)

[08:53] <nothingmuch> splitting an unsorted data file that has dated fields into 6 month periods

[08:53] <nothingmuch> actually I don't know what I'm doing - this is for someone else

[08:54] <nothingmuch> he had a script that used egrep

[08:54] <nothingmuch> with huge |||| patterns, to match each of the 6 months in a year

[08:54] <nothingmuch> the script would run through the file 8 times, filtering the needed data

[08:54] <nothingmuch> my script is about 15x faster, and it will take it 15 more hours

[08:55] <nothingmuch> i wonder if there's something I don't know about the data

[08:55] <nothingmuch> if it's fixed width, it could be faster

[08:56] <nothingmuch> shit, tab separated

[08:56] <nothingmuch> what's more this is on windows via cygwin. I hope i was pedantic enough with 'use bytes' and 'binmode' everywhere

[08:56] <scook0> sounds like something I had to help out with recently

[08:57] <scook0> helping with my brother's follow-up to an honours thesis involving log analysis

[08:57] <scook0> the program the previous guy had was a scary C++ thing

[08:58] <nothingmuch> thesis and log analysis sounds scary

[08:58] <nothingmuch> when the two are combined there is *ALWAYS* something wicked going on

[08:58] <scook0> which took over a week, at 50% CPU time on the uni server

[08:58] <nothingmuch> oh my

[08:58] <scook0> we rewrote it in perl, because the original was too cryptic

[08:59] <scook0> and it finished in minutes on my wussy machine

[09:00] <nothingmuch> heh

[09:00] <nothingmuch> oh man, it's slowed down to 2.9MB/s

[09:02] <nothingmuch> it's not leaking any memory though, that's odd

[09:02] <nothingmuch> constant 1.5MB

[09:02] <nothingmuch> oh, someone else is using the box

[09:02] <nothingmuch> heh, someone was an understatement... there are like 9 sessions, and this is a windows box

[09:42] <kungfuftr> seen theorbtwo

[09:42] <jabbot> kungfuftr: theorbtwo was seen 3 days 9 hours 54 minutes ago

[09:42] <kungfuftr> seen castaway

[09:42] <jabbot> kungfuftr: castaway was seen 4 days 18 hours 18 minutes 2 seconds ago

[09:43] <kungfuftr> is there a public irc log available somewhere?

[09:55] *** kungfuftr is now known as kgftr|konobi

[09:55] * kgftr|konobi bounces

[09:55] <scook0> kgftr|konobi: http://colabti.de/irclogger//irclogger_logs/perl6

[09:55] <kgftr|konobi> ta

[09:57] <nothingmuch> kgftr|konobi: you can find them on perlmonks.org

[09:58] <nothingmuch> or maybe not... 2 days ago too

[09:59] <aw1> Hi! Is that a channel to ask (tricky) questions about perl?

[09:59] <kgftr|konobi> nothingmuch: they're mid-transit iirc

[09:59] <nothingmuch> aw1: #perl is for that

[09:59] <integral> aw1: about perl6, yes.

[09:59] <nothingmuch> this is for discussing perl 6

[09:59] <aw1> Ah, ok, so I rather head over to #perl then! Thanks and bye.

[10:20] * QtPlatypus wonders how people get confused.

[10:21] <nothingmuch> QtPlatypus: many people don't know they're running on perl 65

[10:21] <nothingmuch> *cough*. perl 5

[10:22] <nothingmuch> because they didn't even know that perl 4 existed

[10:22] <nothingmuch> what I really don't know is how they find #perl6 the channel

[10:22] * QtPlatypus learned using perl 4 "And I still see perl 4 code written for perl 5"

[10:23] * QtPlatypus tests something

[10:23] <nothingmuch> Real programmers can write fortran in any language

[10:23] <nothingmuch> -- Larry

[10:23] <QtPlatypus> Perhaps they use list?

[10:23] * nothingmuch started with perl around the time 5.8 came out

[10:23] <nothingmuch> maybe a bit earlier

[10:24] <nothingmuch> i first use MacPerl 5.004 or so, but only for a very short time

[10:24] * QtPlatypus nods.

[10:25] <scook0> wow, luqui just posted a scarily similar p6l reply at exactly the same time as me...

[10:26] <scook0> (or maybe I didn't refresh my inbox for an hour...)

[10:27] <nothingmuch> and still no one replied to my post =(

[10:27] <scook0> nothingmuch: I feared as much

[10:27] <scook0> sadly, it's tooooooooooooooooooooooo long -- everybody is probably scared

[10:28] <nothingmuch> it's a big subject... the linker is not a simple piece

[10:28] <scook0> perhaps you need pretty visio diagrams :)

[10:28] <nothingmuch> and everybody wants it to be fast, and to work with eval, and what not

[10:28] <nothingmuch> there's too much transformation and polymorphism to graph it

[10:28] <nothingmuch> or i don't know how to graph transformation and polymorphism

[10:29] <scook0> well, I shall read it again, and see if I have anything useful to say to de-warnock you

[10:29] <nothingmuch> =)

[10:29] <nothingmuch> what's your post subject?

[10:30] <nothingmuch> under demagicalizing?

[10:30] <scook0> nothingmuch: aye

[10:30] <nothingmuch> i liked that proposal =)

[10:31] <nothingmuch> i think we need to find a better disambiguation though

[10:31] <scook0> nothingmuch: which one?

[10:31] <scook0> the parens?

[10:31] <nothingmuch> well, more than that

[10:31] <nothingmuch> do { } for the pairs is not nice

[10:32] <nothingmuch> and parens should be used for precedence in argument lists

[10:32] <nothingmuch> and to clarify stylistically

[10:32] <scook0> I'm not really a fan of the parens

[10:33] <nothingmuch> i think maybe a marker is in order

[10:33] <scook0> do{} is nice because it doesn't involve any new syntax

[10:33] <nothingmuch> or a marco for do { }

[10:33] <nothingmuch> right

[10:33] <scook0> I suppose you could just say `pair(a=>'b')`

[10:33] <nothingmuch> sub pairs (*%pairs){ return %pairs.pairs }

[10:33] <scook0> where &pair checks its slurpy hash

[10:33] <scook0> checks there's only one arg

[10:33] <nothingmuch> heh  =)

[10:34] <scook0> and returns it as a value

[10:34] * nothingmuch tries to speak in code when possible

[10:34] <nothingmuch> perl 6 is very powerful in that it lets you describe most of perl 6's behavior with other parts of perl 6

[10:34] <scook0> what do you think of `my $pair = :a<b>; foo( *%$pair )`?

[10:35] <scook0> (I was rather proud of it, though I'm not sure it fits exactly with the semantics of %{})

[10:35] <nothingmuch> that was kind of sick ;-)

[10:36] <nothingmuch> i think that we should have the pairs() and named() functions though

[10:36] <nothingmuch> named($pair);

[10:36] <scook0> but you shouldn't be using it much

[10:36] <nothingmuch> and pairs(:foo("bar"));

[10:36] <scook0> and it isn't new syntax or anything

[10:36] <nothingmuch> as symmetric operations

[10:37] <nothingmuch> sub named (*@pairs) { map { *%$_ } @pairs }; # even more line noise... Who said perl 6 was readable, eh?

[10:37] <scook0> `named` would have to be a syntactic form, of course

[10:37] <nothingmuch> sub pairs (*%names) { map %names.pairs }

[10:37] <nothingmuch> it could be just a macro

[10:38] <nothingmuch> that evaulates it's parameters with a *%

[10:38] <scook0> true

[10:38] <scook0> (syntactic form) ~~ macro

[10:38] <nothingmuch> what if we just subclass pair

[10:39] <nothingmuch> NamedArg isa Pair

[10:39] <scook0> and named-syntax in arg-list denotes NamedArg, and Pair elsewhere

[10:39] <nothingmuch> yup

[10:39] <nothingmuch> it's just a different constructor

[10:40] <scook0> that re-introduces the concept of magical values, but at least they're under the hood

[10:40] <nothingmuch> and then pairs() and named() just rebless

[10:40] <nothingmuch> as I see it it's just an implementation strategy for your demagicalized semantics =)

[10:42] <scook0> a problem with magical-values (vs. syntactic-forms) is that they might make it harder to tell statically which args are named, and which aren't

[10:42] <scook0> (from the compiler's point of view)

[10:43] <nothingmuch> what about this: foo(my $x = :foo<bah>); bar($x); # named or pair?

[10:43] <scook0> ooh

[10:44] <scook0> I reckon pair, for both of them

[10:44] <nothingmuch> hmm

[10:44] <scook0> because they're both expressions

[10:44] <nothingmuch> i think a named for the first, a pair for the second... writing up in my email

[10:44] <scook0> (rather than just pair literals)

[10:44] <scook0> possibly with a warning for the first, since it kinda breaks the mnemonic

[10:45] <nothingmuch> yeah

[10:45] <nothingmuch> "possibly unintended pair instead of named argument in function call"

[10:45] <nothingmuch> you're right

[10:46] <scook0> I imagine that the parser tries to parse a pair-literal or splat

[10:47] <scook0> and if it doesn't find one, it parses an expression instead

[10:47] <scook0> and assumes it's not a named-arg

[10:47] <scook0> (or something along those lines)

[10:48] <scook0> after macro-expansion, probably

[10:49] <nothingmuch> replied

[10:52] <nothingmuch> shit, I think I didn't group reply

[10:52] <nothingmuch> did you get it? because I think p6l did not

[10:53] <scook0> I see no reply here

[11:22] <nothingmuch> odd, I see it as sent

[11:22] <nothingmuch> (sorry, meeting)

[11:22] <scook0> ooh, it's arrived!

[11:22] <scook0> and it seems to have been sent to the list

[11:22] <nothingmuch> multi bene

[12:22] <xinming> seen autrijus 

[12:22] <jabbot> xinming: autrijus was seen 3 days 8 hours 48 minutes 9 seconds ago

[12:23] * xinming is thinking if the 6.2.8.0 version will be out when autrijus comes.

[12:51] <masak> xinming: :)

[13:26] <nothingmuch> ingy:

[13:26] <nothingmuch> you are drunk

[13:27] <nothingmuch> kwiki can't build without Kwiki::Test, but Kwiki is a prereq for Kwiki::Test

[13:27] <nothingmuch> wait, no, i think this is an env problem

[13:29] <nothingmuch> ingy++ nothingmuch--; # sorry, false accusations

[13:43] *** Maddingue__ is now known as Maddingue

[13:45] <fglock> nothingmuch: how about PIL2Forth for an interesting project

[13:45] <nothingmuch> fglock: uh, you go ahead

[13:46] <fglock> putter: ping

[13:46] <nothingmuch> my forth fu is not that good

[13:48] <fglock> next would come PIL2Postscript. Then we would be able to compile P6 to pdf :)

[13:49] <iblech> Hm, does PS have closures?

[13:49] <nothingmuch> fglock: i don't think PDF is turing complete

[13:50] <integral> PDF can embed JS luckily :)

[13:51] <Odin-> PDF is "just" a page description format.

[13:51] <Odin-> Unlike PostScript, which doubles as a programming language.

[13:52] <kgftr|konobi> PDF can embed PS though

[13:54] <iblech> Wow, my provider just borked their router configuration -- all IPv4 traffic gets TTL exceeded errors, but IPv6 works fine :)

[14:00] <fglock> iblech: forth uses the stack for everrything, I think closures can be faked

[14:00] <fglock> everything

[14:00] <fglock> nothingmuch: pdf is compressed postscript, which is a forth dialect (AFAIK)

[14:00] <nothingmuch> i thought pdf is a subset of postscript functionality

[14:01] <putter> fglock: pong

[14:02] <fglock> putter: I'm trying to find a way to make things like 'Array::fetch' automatic in PrimP5

[14:02] <fglock> because it is already a Array method

[14:03] <putter> automatic?

[14:03] <fglock> so that you don't need to declare it in PrimP5

[14:04] * putter ponders...

[14:06] <putter> Is Array's fetch already a Sub?  A Scalar?

[14:07] <fglock> Array fetch is a method in the MetaModel. I think it is not an object in the current version of MM

[14:10] <putter> hmm... so the idea is basically to expose p5 methods...

[14:11] <fglock> yes!

[14:11] <xinming> hmm, I ever heard that autrijus said that there is a bit hard to make pugs support perl 6 rules,

[14:11] <xinming> So, I wonder, Is it possible to use pugs to write most perl 6 codes to pharse perl 6 rules?

[14:13] <xinming> I mean, If pugs suports full perl 6 oo mechanism ( except the pharsing rules ), will it possible to use pugs to write some class to pharse perl 6 rules?

[14:13] <putter> so like... p6_apply taking the invocant, if any, and UNIVERSAL::can()ing it, against the function variable name...

[14:13] <fglock> xinming: yes - you can write a library

[14:13] <xinming> hmm, well, This is just my humble opinion,

[14:14] <xinming> fglock: then, which is harder? Using haskell or using pugs?

[14:14] <putter> xinming: posible, once oo works better.

[14:15] <xinming> putter: do you mean, My Humble Opinion is right? :-)

[14:15] <xinming> Or it is the way you all plain to go?

[14:16] <fglock> xinming: you can write libraries in pugs, but you can't integrate them in the language yet. There are a few bits missing.

[14:17] <putter> has anyone written a p5 module which takes a list of keys and walks array structures, stopping and _not_ autovivifying if one is missing?

[14:17] <putter> s/array/array&hash/

[14:18] <xinming> fglock: hmm, then, which part is missing? :-S

[14:18] <fglock> putter: you can test with 'exists'

[14:18] <putter> k

[14:19] <xinming> putter: hmm, maybe can make something like "convert" rules into "class" :-P

[14:19] <xinming> oops. worng

[14:20] <fglock> xinming: you can create classes, but you can't redefine what a 'rule' is

[14:20] <fglock> but you certainly can write your own class with rule functionality, and integrate it in a future version of pugs

[14:21] <xinming> hmm, well, It's just a piece of inspiration which just came out of my head just now.

[14:23] <svnbot6> r6463 | iblech++ | * Usual svn props.

[14:23] <svnbot6> r6463 | iblech++ | * t/statements/loop.t: Oops, I accidentally removed the "use Test" line in

[14:23] <svnbot6> r6463 | iblech++ |   r8382, fixed.

[14:23] <svnbot6> r6463 | iblech++ | * PIL2JS: ~~33% speedup! putter++!

[14:23] <svnbot6> r6463 | iblech++ |   * You can now write primitives as macros written in Perl 5 -- they take a

[14:23] <svnbot6> r6463 | iblech++ |     list of (already compiled to JS) parameters (and the cc, of course), and

[14:23] <svnbot6> r6463 | iblech++ |     return the resulting JS code. See new lib/Prelude/JS.pm.

[14:23] <svnbot6> r6463 | iblech++ |   * Implementing &statement_control:<if> and &statement_control:<unless> as a

[14:23] <svnbot6> r6463 | iblech++ |     P5Macro already gives ~~13%, implementing most two-ary standard ops gives

[14:23] <svnbot6> r6463 | iblech++ |     another speedup.

[14:24] <putter> fglock: err, doesnt the mm use lots of AUTOLOAD?  does it implement a matching can()?

[14:25] <fglock> putter: I'm not sure if can() will work. You may have to use an eval

[14:25] <fglock> Scalar and Ref are particularly tricky

[14:25] <fglock> because they do auto-deref

[14:26] * putter wonders if the waters are getting too deep...

[14:26] <fglock> sorry

[14:26] <putter> oh, np...

[14:26] <putter> exploring...

[14:32] <putter> is there an official way to ask a Scalar if it contains an undef?  or just defined($s->fetch) ?

[14:33] <fglock> $x->defined

[14:33] <putter> tnx

[14:47] <putter> fglock: p6 test expression to see if fetch is now working?

[14:47] <svnbot6> r6464 | fglock++ | * PIL-Run - implemented ^.. ..^ ^..^ infix:<->

[14:49] <fglock> (1,2).fetch(1)

[14:49] <putter> trying...

[14:49] <fglock> it thinks it is a Scalar fetch

[14:50] <putter> iblech:  hmm... in PILRun one can do macros in p5 because one has access to the runtime environment, to see if the variables are indeed bound to macros... but how can one do that in p5 when one's runtime is js...?  or are the "non-overrideable, compiled away at compile-time" primitives?

[14:53] <iblech> putter: The latter. But I'm currently hacking in a guard so the macro versions are only called if the subs weren't rebound

[14:53] <iblech> putter: Ala &infix:<+>.is_pil2js_compiletime_macro ? ($a + $b) : &infix:<+>($a, $b)

[15:12] <putter> iblech++ :)

[15:12] <svnbot6> r6465 | fglock++ | * PIL-Run - implemented coerce:as($x, $type)

[15:15] <iblech> Hm, looks like I run into a perl5 memory leak

[15:15] <putter> $a = Array->new(); $a->push(3,4); $a->fetch(1); $s = Scalar->new(); $s->store($a); $s->fetch(1)

[15:15] <putter> Array=HASH(0x113f800)

[15:15] <putter> fglock: is that right?!?

[15:15] <putter> (I thought the Scalar was supposed to proxy the call...)

[15:16] <fglock> I have to check this - I'm going for lunch now - bbiab

[15:17] <putter> k

[15:17] <iblech> putter: I'd say what you're doing can't work -- you store an Array container into a Scalar container. But if Scalar should autoref in this case, it should, of course, work

[15:19] <kgftr|konobi> anyone got any contact (phone) details for theorbtwo or castaway?

[15:27] <svnbot6> r6466 | putter++ | PIL-Run - Began a bypass to treat some PApps as p5 method calls, since the current mm methods Array::fetch etc are not yet(?) objects, nor in the namespace.  Also tweaked name lookup().

[15:31] <putter> iblech: currently PVar yields a bound, possibly new, Scalar.  $x=3 becomes (find('$x')||$x=newScalar).store(3).  sortof.  not the right thing?

[15:33] <iblech> putter: That's correct for scalars. But if the LHS is a scalar, and the RHS is an aggregate, you've to autoref ($s = @a is really $s = \@a). If Scalar->new does this autoreffing, then everything's fine

[15:35] <putter> ok. thanks.

[15:35] <iblech> And, while we're at it, @array = $scalar is really @array = ($scalar,) (= &infix:<,>($scalar))

[15:36] <putter> ;)   putter didnt even know Array's were in there.  fglock++

[15:38] <PerlJam> iblech: is  @array = list $scalar;  the same thing? 

[15:38] <iblech> PerlJam: I think so.

[15:39] <PerlJam> if so, I prefer that form over the dangling comma.  (That's one bit of python's syntax that continues to bother me)

[15:49] <putter> hah!  sprinkle in a few eval()s, and crude_repl happily bumbles drunkenly through t/*/*.t...

[15:50] <putter> time for a smoke...

[15:50] <putter> (though I suspect most of the success with be "and check x _didnt_ occurr" flavor tests. ;)

[15:53] <svnbot6> r6467 | iblech++ | PIL2JS:

[15:53] <svnbot6> r6467 | iblech++ | * PIL2JS.js: Fixed numification of junctions.

[15:53] <svnbot6> r6467 | iblech++ | * PIL::P5Macro: Optionally check if (say) &statement_control:<if> is still

[15:53] <svnbot6> r6467 | iblech++ |   bound to our macro. But, as perl5 seems to leak memory (2 GiB in 2min), this

[15:53] <svnbot6> r6467 | iblech++ |   currently needs %*ENV<PIL2JS_MACROS_CORRECT_BEHAVIOUR> to contain a true value.

[15:55] <putter> eeep!

[15:55] <putter> # ~ 1 machine-memory/min ;)

[15:57] <wilx> Circular references?

[15:58] <iblech> wilx: Thought so too, but didn't find any (and the code in question is only 10 lines or so long (with a 5 line here-doc))

[15:58] <iblech> putter: (5 GiB swap)++ :)

[15:58] <wilx> Heh.

[15:58] <putter> ;)

[15:59] <wilx> Nice achievement with 5 lines of code :)

[15:59] <iblech> :D

[16:07] <fglock> putter: ping

[16:11] <putter> pong

[16:11] <svnbot6> r6468 | fglock++ | * PIL-Run - ?x ~x works

[16:12] <putter> crude_repl is smoking...!  (hmm... have to find a way to skip the ext/ tests...)

[16:12] <putter> err,

[16:13] <putter> fglock: pong

[16:13] <fglock> do you still have that problem with Array?

[16:13] <putter> checking...

[16:15] <putter> yes.  behavior unchanged.

[16:16] <fglock> the problem is - "how to store an array item when the array is inside a scalar" ?

[16:16] <fglock> I haven't written tests for that - it might not work yet

[16:19] <putter> right.  perhaps incorrectly, the current implementation uses Scalar as the named in namespace <name,named> tuples.  it thus relies on Scalar's proxing behavior.  I've no idea if this is all spec, fudged-spec, or bizarrely incorrect.

[16:19] <svnbot6> r6469 | fglock++ | * PIL-Run - +x

[16:20] <fglock> what does "Scalar's proxing behavior" is? 

[16:22] <putter> all namespace lookups currently return a Scalar.  so "do something to a variable" means "do something to a Scalar".

[16:23] <putter> though it may be the only thing we were consistently using variables for was to hold subs.  so atleast ->do() works. ;)

[16:24] <putter> Some of the sanity tests must of exercised them a bit more.

[16:24] <svnbot6> r6470 | fglock++ | * PIL-Run - pop, push, unshift, Array::values

[16:25] <fglock> does it mean that @a[1] should return a Scalar that holds the second cell in the Array?

[16:25] * putter wonders if he should svn up and restart the smoke... ;)

[16:25] <xinming> putter: go ahead. :-P

[16:26] * fglock was lunching while putter was smoking

[16:26] <putter> no.  it means given $a = (3,4); $a[1]   if fetch is just a p5 method, this gets converted to a ->fetch(1) on the Scalar returned by name lookup of '$a'.

[16:27] <fglock> ok - I'll test that

[16:27] <putter> which currently returns the Array, rather than the 4.

[16:27] <putter> xinming: :)

[16:32] <fglock> is there a way to reduce the 'tab' size in Data::Dumper?

[16:32] <iblech> fglock: $Data::Dumper::Indent = 1

[16:32] <fglock> thanks

[16:37] <fglock> if you have a Scalar that holds an Array: does $s->fetch returns Array, and $s->fetch(1) returns Array element?

[16:39] <putter> ?

[16:39] <putter> I'm afraid I haven't been following the mm closely... sorry.

[16:39] <putter> stevan: ping? ;)

[16:40] <fglock> I mean in Perl 6  - $s=@a; how to you get the array back from $s? (I think you don't)

[16:40] <putter> stevan: btw, will mm2.0 have macros?

[16:41] <iblech> fglock: @$s

[16:41] <putter> ah.

[16:41] <iblech> fglock: But $s[index] will work, too, because $s autoderefs

[16:41] <fglock> ah too

[16:42] <fglock> ok - I'm verifying the implementation

[16:48] <svnbot6> r6471 | putter++ | PIL-Run - make smoke-perl5 runs.

[16:53] <fglock> I fixed this bug, but now I've got to fix the other tests

[16:56] <fglock> putter: can you test fetch() now? I'm going to fix store()

[16:57] <putter> testing...

[16:58] <putter> woot!  :)

[16:58] <putter> works.  fglock++

[16:58] <svnbot6> r6472 | fglock++ | * perl5/ Scalar - autodereference array->fetch(1)

[17:00] <putter> so (3,4)[1]  and $a[1] and $a.fetch(1) all work.  but (3,4).fetch(1) doesnt.  exploring...

[17:01] <putter> hmm... perl5.t takes a long time... even when you dont have regexs implemented... ;)

[17:10] <svnbot6> r6473 | fglock++ | * perl5/ Scalar - Arrays stored in a Scalar can be accessed using indexed store/fetch

[17:13] <fglock> putter: 'Inf - 2' dies looking for "Math::BigInt"

[17:13] <svnbot6> r6474 | fglock++ | * PIL-Run - several new primitives

[17:13] <svnbot6> r6475 | iblech++ | * t/pugsrun/*.t: skip if $*OS eq "browser"

[17:13] <svnbot6> r6475 | iblech++ | * PIL2JS:

[17:13] <svnbot6> r6475 | iblech++ |   * PIL: $vars with associated PPos information was incorrectly

[17:13] <svnbot6> r6475 | iblech++ |     compiled, fixed.

[17:13] <svnbot6> r6475 | iblech++ |   * P5 Prelude::JS: All ops working on Strs *booleanified* their arguments

[17:13] <putter> p6_new('Array',p6_new('Int',3)).fetch(p6_new('Int',0))   gives an error You cannot call $AUTOLOAD from outside of a MetaModel defined method

[17:13] <svnbot6> r6475 | iblech++ |     instead of stringifying them, fixed (2-char-patch).

[17:13] <svnbot6> r6475 | iblech++ |   * PIL::PVar: Variables in void context don't discard the cc now.

[17:13] <iblech> fglock: That's probably because -CPerl5 serializes Inf as Math::BigInt->binf

[17:14] <putter> fglock: add Math::BigInt to MainX?

[17:15] <putter> hmmm...

[17:18] <fglock> about Array - Array->() new takes no arguments, you have to push elements into it

[17:18] <fglock> I mean Array->new()

[17:19] <putter> yes.

[17:19] <putter> I saw that in p6_new.

[17:20] <fglock> The problem might be that fetch needs un unboxed value

[17:20] <fglock> an

[17:20] <putter> re Inf, I think Int doesnt know what to make of 'inf'.

[17:21] <fglock> I'm defining an 'Inf' sub

[17:22] <putter> ah, no.  its just that VNum isnt expand()ed yet.

[17:22] <putter> what should a num be?  (in the mm)  Num?

[17:23] <fglock> yes

[17:23] <putter> k

[17:24] <putter> hmm. :5 p6_to_s(p6_new('Num','inf'))  is... "0". :/

[17:25] <fglock> try 100**100**100

[17:25] <putter> while I'm here, Int, Num, Str, any other easy literals?

[17:25] <putter> Inf :)

[17:25] <fglock> that's all - the other values are Ref, Pair, List

[17:26] <putter> k

[17:26] <putter> cleaning up and checking in...

[17:28] <putter> what ever happened to Rat?

[17:28] <putter> in, 6476.

[17:28] <fglock> Rat is 2 Num together

[17:28] <putter> k

[17:28] <fglock> it can be defined at a higher level

[17:28] <putter> is there a Decimal?

[17:29] <fglock> I don't think so - I've seen a discussion years ago, I think it was agreed not to have it

[17:30] <fglock> many errors in Math::BigInt while executing Inf+2

[17:30] <svnbot6> r6476 | putter++ | PIL-Run - Num support added.

[17:31] <putter> Err, ok, not _quite_ what I expected.   408 files  26 test cases: 24 ok, 2 failed, 2 todo, 2 skipped and 0 unexpectedly succeeded  92.31%

[17:31] <putter> k # re Decimal

[17:32] <fglock> 92% of all tests?

[17:32] <putter> all 26 of them.

[17:32] * putter goes to try and figure out what's up with smoke...

[17:34] <putter> re Inf+2 and BigInt errors, that's so 20th Century.  Here in the future, Inf**Inf == ... what is it, Aleph_0?

[17:37] <fglock> TODO: Value::Transfinite

[17:38] <putter> lol :)

[17:38] <putter> have you seen Magma?  (looks for url...)

[17:39] <putter> http://magma.maths.usyd.edu.au/magma/htmlhelp/MAGMA.htm

[17:39] <fglock> @a[1]=3 try to store to an Int

[17:41] <putter> http://magma.maths.usyd.edu.au/magma/Features/Features.html  but that's still not it... where's the manual...

[17:43] <nothingmuch> evening

[17:44] <putter> ah, no, it was the first link.  http://magma.maths.usyd.edu.au/magma/htmlhelp/MAGMA.htm

[17:44] <putter> 'evening nothingmuch.

[17:46] <putter> nothingmuch: so, while you were gone, you were volunteered ("the person who misses the meeting is _always_ ""volunteered""") to implement finite groups ( http://magma.maths.usyd.edu.au/magma/htmlhelp/part4.htm ).

[17:46] <nothingmuch> what are finite groups?

[17:47] <fglock> putter: (undef,1,undef,2) returns (1,2) - I defined undef as multi sub undef () { my $x };

[17:47] <nothingmuch> are they like sets?

[17:48] <putter> ah, wikipedia is really getting nifty.  http://en.wikipedia.org/wiki/Group_(mathematics)  http://mathworld.wolfram.com/FiniteGroup.html

[17:48] <putter> fglock: is this a good thing?

[17:49] <putter> nothingmuch: sorry, tongue firmly in cheek.  though... it would be really neat if p6 could become a decent algebra system...

[17:49] <fglock> in pugs it returns (undef,1,undef,2) 

[17:49] <putter> who was it that was doing Set?

[17:49] <fglock> me

[17:49] <putter> ah! ;)

[17:49] <fglock> oops - not Set

[17:50] <putter> oh. :/

[17:50] <fglock> I did Infinite Sets (Set::Infinite)

[17:50] <putter> ah! :)

[17:50] <fglock> and Recurrence, Span and related thingies

[17:50] <fglock> Recurrence is nice if you like math

[17:52] <fglock> ext/Recurrence/lib/Recurrence.pm

[17:52] <putter> http://www.math.uiuc.edu/Software/magma/text129.html  hmm... do we have predicate subsets of infinite sets?  intersection, etc?

[17:53] <fglock> sure

[17:53] * putter too many distractions.  bbiam

[18:01] <putter> weee. back.

[18:02] <putter> is there a mm Undef?  I dont think the runtime is doing anything unusual with undef.  does Array->push?

[18:03] <fglock> I'll test - maybe

[18:04] <putter> nothingmuch: re groups, they are <set,operator> tuples, where operator is  set set -> set, and it behaves like multiplication.

[18:04] * putter wonders if anyone has does a haskell algrebra system

[18:05] <fglock> putter: see ext/Recurrence/lib/Recurrence.pm

[18:09] <svnbot6> r6477 | iblech++ | * PIL2JS:

[18:09] <svnbot6> r6477 | iblech++ |   * PIL2JS.js: +undef is 0 now, not undef.

[18:09] <svnbot6> r6477 | iblech++ |   * P5 Prelude::JS: Added comment about that.

[18:09] <svnbot6> r6478 | fglock++ | * PIR-Run - !x (negation)

[18:12] * nothingmuch returns dramatically

[18:12] <svnbot6> r6479 | iblech++ | PIL2JS: PIL2JS.js: &prefix:<+>: Unbroke numification of bools.

[18:12] * putter holds his breath, anticipating drama

[18:13] * nothingmuch dramatically unveils cap, cane and tap dancing shoes

[18:14] * nothingmuch sings a corny song and expects to be recognized as talented

[18:16] <ods15> poke poke, nudge nudge

[18:18] *** saorge_ is now known as saorge

[18:22] <fglock> putter: is it already possible to define classes in PIL-Run?

[18:23] <fglock> in order to implement Pair

[18:23] <svnbot6> r6480 | putter++ | PIL-Run - Can now be run outside of PIL-Run/.

[18:23] <putter> re Recurrence.pm, neat!  I wonder if there is a nice way to support things that dont know if they are infitite or not?  There are some predicates like is_infinite that I sometimes which had cost meta information associated with them.  is_inf_cheap()   sometimes writing them I want the method to gossip "you DO reallize I'm a possibly infitite set?"  "do you really want me to spend the day calculating that?" "how about I give you odds ins

[18:23] <putter> teald?"  (all said in a wise-ass voice). ;)

[18:24] <putter> s/which/wish/

[18:25] <fglock> see Span - if you intersect a Recurrence with a Span, it knows what to do

[18:25] <fglock> (see Set::Infinite, actually)

[18:27] <iblech> fglock: WRT defining classes, no, that can't be possible, as -CPerl5 can't compile class declarations

[18:29] <fglock> putter: re infinite computations - List emits a warning if you try to instantiate an infinite list

[18:35] <fglock> bbiab

[18:43] <geoffb> putter: funny, you commented a few minutes after I left that we didn't discuss autogenerated tests.  And of course I fell asleep thinking about autogenerated tests . . . .

[18:46] <putter> The hall is gone now, but you can still see the outline of the foundation on the ground.  And they still tell the story of putter's ghost. "He was just about to applaud nothingmuch when he lost it. Trashing, memory exhausted by his smoking.  He was disconnected."  And sometimes, on a quiet night, you can still hear the clapping.

[18:46] <geoffb> *chuckle*

[18:48] * geoffb idly wonders which of his umpteen projects he should apply some tuits to right now

[18:48] <putter> geoffb: :)  now if only we could all code in our sleep consistently...

[18:49] <geoffb> I can't even tell you how many times in the last week I wish I had a brain implant that could take notes . . . .

[18:49] <geoffb> I hate getting a pile of ideas while falling asleep, then having to spend an hour trying to remember them all after waking up the next morning

[18:50] <geoffb> And ideas while stuck in slowly moving traffic are pretty painful too -- though I'm considering getting a digital voice recorder for that issue

[18:51] * putter really looks forward to... whatever its called... digital personal assistant... watches/listens, records, and indexes your day.  provides framework for moving behaviors off the wetware.  "I dont *what* talk it is.  My planner just told me to come here." (real;)

[18:51] <geoffb> heh

[18:51] <putter> bah. s/dont/dont know/

[18:51] <geoffb> funny, I read it correctly, even though there was a word missing.

[18:52] <putter> ;)

[18:52] <geoffb> (human pattern-matching engine)++

[18:52] <geoffb> And tuits of the moment go to:  eating cookie dough.  brb

[18:53] <putter> When I'm in that kind of mode, I keep a paper, pen, and a very dim light by my bed.  Roll over, brain dump, back to sleep.  Otherwise sometimes I just cant let go.

[18:53] <putter> Sometimes though, and hour later and the dump is still in progress.

[18:53] <putter> Good choice.  Even better with icecream.

[18:55] <geoffb> bak

[18:55] <geoffb> mmmm, cookie dough . . . .

[18:56] <geoffb> yeah, sometimes I just give up, wander down the hall to the home office, and brain dump into the computer

[18:56] <geoffb> I have huge directories of "notes"

[18:57] <putter> fglock: re classes, due to PIL limitations, not in p6.  can in p5... but you knew that.  I was tempted to do Rul and Match classes in p5, just to get rules (and the 20% coverage boost;).  But it seemed a waste to write soon(hopefully)-to-be-disposed of code.

[18:58] <geoffb> Speaking of which, I think next tuits will go towards updating parts of http://www.broadwell.org/graphics/pigge/docs/trends.html

[18:58] <putter> I'm acutally faster to dump on paper.  Spacial is dominant brain mode, and paper does that better.

[18:59] <geoffb> I'm more language-oriented, even when talking about graphics.  I think the linguistic influences on Perl are why I like Perl so much.

[19:00] <geoffb> Often when I need a small amount of spacial notes, I just do ascii art.  Occasionally I'll fall back to paper, but then I instantly think "dammit, now I have to transcribe this someday"

[19:01] <geoffb> spatial, sheesh, no wonder that word looked wrong

[19:03] <putter> lol :)

[19:08] <putter>  408 files  	6062 test cases: 219 ok, 5843 failed, 2 todo, 2 skipped and 0 unexpectedly succeeded  	3.61%

[19:08] <svnbot6> r6481 | putter++ | PIL/Run/Container moved to Container_old_not_used.

[19:08] <putter> !

[19:08] <putter> hey, almost 4%!!!

[19:09] <geoffb> putter: w00t!

[19:11] <putter> ah well, not really.  about 3%.  1/7 of tests are still awol.

[19:13] <putter> feature request: tests.yaml with individual file times.

[19:14] <nothingmuch> putter: that's easy to do wioth Test::TAP::Model

[19:14] <nothingmuch> if you save the timing info, load the YAML (takes 40 seconds... =(

[19:14] <nothingmuch> walk the files

[19:14] <nothingmuch> and iterate the timing info

[19:15] <putter> nothingmuch: re tap dance, just in case you dont backlock, I mention campfire tale.

[19:15] <nothingmuch> aha

[19:15] <nothingmuch> i don't backlog, except when I'm really curious

[19:15] <nothingmuch> ++ on the tests

[19:16] <putter> now-29min

[19:17] * fglock is back

[19:17] <putter> welcome back.

[19:18] <fglock> re classes - it means I can't define classes in PrimP6 either :(

[19:19] <putter> nope... :(   we need to find autrijus some $$

[19:24] <fglock> I'm getting "Method (defined) not found for instance (Sub=..." in several operations that were already working

[19:25] <fglock> such as '2.perl'

[19:25] <svnbot6> r6482 | fglock++ | * PIL-Run - 1=>2 - Pair constructor

[19:28] * nothingmuch goes to see a movie

[19:30] <putter> geoffb: very neat doc.  re http://www.broadwell.org/graphics/pigge/docs/trends.html

[19:30] <svnbot6> r6483 | fglock++ | * PIL-Run - pair value, key

[19:30] <svnbot6> r6484 | fglock++ | * PIL-Run - rand()

[19:31] <geoffb> putter, thanks!

[19:31] <putter> fglock: ah, Scalar is passing on its ->defined() call to Sub, which doesnt understand it?

[19:32] <fglock> maybe - I'll fix it

[19:32] <putter> k

[19:36] <svnbot6> r6485 | putter++ | PIL/Run/EvalX.pm: better warnings from PStmt.

[19:47] <svnbot6> r6486 | putter++ | PIL/Run/ApiX.pm: Squash warning "Scalar value @_param{$xx} better written as...".

[19:48] <fglock> putter: it's not calling Scalar::defined

[19:49] <fglock> I'll try creating Sub::defined and see what happens

[19:50] <putter> is there a // nearby?

[19:51] <fglock> it works now

[19:51] <putter> ah, ok.

[19:53] <fglock> what's the superclass for Str,Int,Num? (what elese goes into this superclass?)

[19:53] <svnbot6> r6487 | fglock++ | * perl5/ Code - defined() method

[19:53] <fglock> else

[19:53] <putter> Object?

[19:54] <fglock> I think there is something between Int and Object. Int is a subclass of Num?

[19:58] <putter> That sounds familiar... I'm looking for docs...

[20:02] <putter> I havent found anything definitive.  My impression is Num and Int both does() Number (and Int does Integer), but that Int is not isa() Num.

[20:03] <putter> p6 type hierarchy is very flat and roley.

[20:10] <fglock> $a=(1,2) works, but $a=@a doesn't

[20:13] <ods15> heh that remins me mirc scripting

[20:13] <putter> does the mm have a concept of inspect() or "intended for debugging" stringification?  eg, more like what p5 objects strigify to be default (though some languages nicely include field values too).

[20:13] <ods15> when i used to name functions 'c='...

[20:13] <fglock> most objects have the '.perl' method

[20:14] <fglock> can't run crude_repl.pl in windows - PxPerl pugs is tool old

[20:15] <ods15> ?eval say say.perl

[20:15] <evalbotzy> Error:  unexpected "p" expecting block construct, ":", term, term postfix, operator, ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:15] <ods15> ?eval say.perl

[20:15] <evalbotzy> Error:  unexpected "p" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:15] <ods15> oh, heh, functions don't methods

[20:15] <fglock> pugs's 'say' is not an object

[20:16] <ods15> si i figured

[20:16] <ods15> so*

[20:16] <ods15> ?eval say "hello"

[20:16] <evalbotzy> hello bool::true 

[20:16] <fglock> p6's 'say.perl' should return 'sub { ... }'

[20:16] <ods15> ?eval say("hello").perl

[20:16] <evalbotzy> hello 'bool::true' 

[20:16] <ods15> ?eval say say("").perl

[20:16] <evalbotzy>  bool::true bool::true 

[20:17] <ods15> ?eval say().perl

[20:17] <evalbotzy>  'bool::true' 

[20:17] <ods15> hmm

[20:17] <ods15> ohh

[20:17] <ods15> ?eval (say().perl).perl

[20:17] <evalbotzy>  '\'bool::true\'' 

[20:17] <ods15> right

[20:17] <iblech> ?eval &say.perl

[20:17] <evalbotzy> '\\sub {...}' 

[20:18] <fglock> :)

[20:18] <ods15> ?eval &say

[20:18] <buu> What the hell?

[20:18] <evalbotzy> \sub {...} 

[20:18] <ods15> buu: what

[20:18] <iblech> ?eval say.perl   # same as say().perl, i.e. bool::true.perl

[20:18] <evalbotzy> Error:  unexpected "p" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:18] <iblech> oh, parse error

[20:18] <ods15> ?eval (say).perl

[20:18] <evalbotzy>  'bool::true' 

[20:18] <buu> ods15: Is .perl?

[20:18] <ods15> ?eval (&say).perl

[20:18] <evalbotzy> '\\sub {...}' 

[20:18] <ods15> buu: ??

[20:19] <buu> ods15: What does it do?!

[20:19] <ods15> ?eval &say "hello"

[20:19] <evalbotzy> Error:  unexpected "\"" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:19] <fglock> .perl is more or less like Dump

[20:19] <buu> ?eval "test"

[20:19] <evalbotzy> 'test' 

[20:19] <buu> ?eval "test".perl

[20:19] <evalbotzy> '\'test\'' 

[20:19] <ods15> buu: turns anything into a string

[20:19] <ods15> even a string

[20:19] <buu> ods15: Consisting of the code?

[20:20] <iblech> ods15: WRT &say "hello" -- you either need ()s, or you have to drop the &

[20:20] <buu> ?eval my $x = sub { say "zomg" }; $x

[20:20] <evalbotzy> \sub {...} 

[20:20] <ods15> ?eval &say("hello")

[20:20] <evalbotzy> hello bool::true 

[20:20] <buu> ?eval my $x = sub { say "zomg" }; $x.perl

[20:20] <evalbotzy> '\\sub {...}' 

[20:20] <buu> Is that an error in my approach or an error in evalbot, or am I missunderstanding things?

[20:20] <fglock> ?eval (2,\"test",1, sub{},[3]).perl

[20:20] <evalbotzy> '(2, \\\'test\', 1, sub {...}, [3])' 

[20:20] <ods15> fglock: dump the 

[20:20] <ods15> err

[20:21] <ods15> fglock: dump the 'perl' in the end

[20:21] <buu> Why aren't we seeing sub code?

[20:21] <iblech> buu: It hasn't been decided yet whether $subref.perl should return a stub string (i.e. "sub {...}") or the real contents

[20:21] <ods15> buu: cause thats "unknown"

[20:21] <ods15> iblech: heh, shouldn't

[20:21] <fglock> buu: that's implementation dependent

[20:21] <buu> fglock: Er, what the heck?

[20:21] <buu> How can that be implementation dependent? OR rather, why would it be?

[20:22] <fglock> pugs doesn't dump the code inside sub{...}

[20:22] <iblech> buu: Also consider &NativeCModule.some_sub.perl

[20:22] <iblech> buu: How could perl print something meaningfun in this case?

[20:23] <buu> iblech: I have no idea, but it would be really cool.

[20:23] <iblech> buu: ..and it's be impossible ;)

[20:23] <fglock> iblech: 'sub { nci_call( "NativeCModule" ) } ' ?

[20:23] <buu> iblech: Don't bother me with your picky technicalities!

[20:24] <iblech> fglock: Right, but more meaningful would be something along the lines of sub { use Grammar::C; int x = 3; ...

[20:24] <iblech> buu: :D

[20:25] <ods15> lol

[20:25] <buu> I also want a dwim operator

[20:25] <buu> So when my code has syntax errors, I just randomly insert it until it works.

[20:26] <buu> Hrm. Is undef still a function now?

[20:26] <fglock> from PIL you can return 'sub { ** line 1322 ** } '

[20:26] <iblech> buu: No, use &undefine to make a var contain undef

[20:27] <buu> Yay!

[20:27] <buu> I just had some code that looked like: foo( "bar", undef

[20:27] <buu> baz );

[20:27] <buu> And I could not figure out why foo wasn't getting the proper arguments

[20:28] <fglock> undef() returns undef in pugs

[20:32] <fglock> stevan: ping

[20:32] <svnbot6> r6488 | putter++ | PIL-Run - p6_eval() again defaults to Root::main.  crude_repl.pl :5 <p5exprs> also defaults to there, simplifying debugging.

[20:32] <putter> fglock: patch in.  now you can  p5ugs> @a=(3,4)    :5 $array_a   and play with it.

[20:33] <putter> this looks odd...

[20:33] <putter> :5 $array_a->fetch()

[20:33] <putter> Use of uninitialized value in numeric eq (==) at /home/net1/perl6/pugsxpl1/perl5/PIL-Run/../Perl6-Container/lib/Perl6/Container/Array.pm line 361.

[20:33] <putter> Int=HASH(0x12cce70)

[20:33] <putter> where p5ugs> :5 $array_a

[20:33] <putter> Scalar=HASH(0x12cccb0)

[20:34] <fglock> :5 $array_a->fetch(1)

[20:34] <putter> and you get that same error message during $s=@a.

[20:34] <fglock> fetch without parameters is fetch(0) - and a warning

[20:35] <putter> re fetch(1), yes, but Scalar's talk to each other with fetch(), I suspect.

[20:35] <putter> Scalar $s2->store($s1) may include a $s1->fetch()  

[20:36] <fglock> but $s=@a is $scalar_s->store( $array_a )

[20:36] <putter> and  $array_a is a Scalar.

[20:36] <putter> the scalar_ and array_  are the sigils.

[20:36] <fglock> so $array_a->fetch() should return the array?

[20:38] <fglock> I mean, scalar->fetch() always returns the cell contents; scalar->fetch(0) try to dereference to array

[20:39] <putter> _if_, Scalar store(), when given another Scalar $s1, asks that $s1 to ->fetch(), then either Scalars cant delegate the no-argument form of ->fetch(), or...  (I cant immediately think of another possibiility)

[20:40] <fglock> I'll implement this and see if it works

[20:41] <iblech> FYI, in PIL2JS, @array.FETCH returns a JS array, $arrayref.FETCH returns a Ref (which has .autoderef set to true), and Scalar::STORE calls autorefs the RHS of an assignment if the RHS is an aggregate

[20:41] <putter> Maybe Array containers shouldnt implement zero-ary fetch()?

[20:42] <iblech> Maybe s/fetch/fetch_elem/?

[20:42] <fglock> bbiab ...

[20:42] <putter> bottom line - I am too unfamilliar with the MM to say how the container classes should interact.

[20:44] <putter> iblech: what is your... bound object?  the second half of a <name,thing> namespace entry?

[20:46] <iblech> putter: Binding is *not* only a change in the symbol name -> container table (i.e., the pad) (consider @a[$idx] := $val, which is really &postcircumfix:<[ ]>(@a, $idx) := $val)

[20:46] <iblech> putter: Binding set the LHS's .FETCH and .STORE to RHS's .FETCH and .STORE in PIL2JS

[20:46] <iblech> putter: Which is basically the same as setting the LHS's .cell to RHS's .cell

[20:47] <putter> Do you have a cell object distinct from Scalar?

[20:48] <iblech> Not technically, but:

[20:49] <iblech> Instead of varname -> container -> cell -> value, I do varname -> container -> .FETCH .STORE -> value, and then I do appropriate magic so users could *think* there's a cell involved, where there is no one actually

[20:49] <iblech> (This is only an optimization, I'm saving one (otherwise needed) indirection)

[20:50] <putter> where Scalar is a container?

[20:50] <iblech> Right.

[20:51] <iblech> (But, another implementation detail, I don't have separate Scalar,Array,Hash classes, but only a generic Box class, but again I fake things appropriately so you can't see the difference)

[20:51] <fglock> back. Array doesn't implement fetch() - Scalar does - the problem is that Scalar sends the fetch to Array, which doesn't know what to do

[20:51] <putter> ok, so as I understand it, in the p5 mm, .FETCH and .STORE are spelled ->fetch and ->store, and the same cell-less magic scheme is used.

[20:52] <fglock> so Scalar must know that Array doesn't do fetch()

[20:53] <putter> iblech: would a Scalar container ever contain an Array container?

[20:53] <iblech> putter: No, never. $scalar = @array (and even $scalar := @array) always autorefs the RHS

[20:54] <putter> so that's the problem.  the full stack looks like   varname -> varcell -> container -> cell(s) -> value(s)

[20:54] <fglock> works :)

[20:55] <putter> I used Scalar as my varcell, so fetch was being overloaded to mean varcell.get.

[20:55] <putter> ;)

[20:55] <svnbot6> r6489 | fglock++ | * perl5/ Scalar - scalar fetch/store without index returns/store the whole Array/Hash

[20:55] <putter> sounds right?

[20:55] <iblech> What's varcell?

[20:56] <iblech> The P5 variable holding the container object?

[20:56] <putter> sure.

[20:56] <iblech> Then it's correct, I think :)

[20:56] <putter> ok.  fixing...

[20:56] <leo__> iblech: wrt  @a[$idx] := $val - what should the implementation do if: the array changes, gets, spliced, the item isn't there, gets deleted, ... the array is undefed, rebound, ...

[20:57] <iblech> leo__: 1) if $val changes, @a[$idx] gets changed as well, and vice versa

[20:57] <iblech> leo__: 2) spliced -- see 3)

[20:58] <iblech> leo__: 3) item isn't there -- fatal error, can't (re)bind non-existing container. if splice deletes an element, $val will still exist (think Unix hardlinks with refcounting)

[20:59] <iblech> leo__: 5) @a = () causes the binding to cease to exist, but accessing $val will still work. But chaning $val won't change @a

[20:59] <putter> fglock: I think the key is,  $s = @a, should read $scalar_s = $array_a, with $array_a an Array rather than a Scalar containing an Array, rather than $scalar_s->store($array_a).

[20:59] <iblech> leo__: 6) @a is rebound -- same as 5)

[21:00] <putter> no ->fetch message, no problem.

[21:01] <leo__> 4) item is there but changed due to splice -- see 1)

[21:01] <putter> fglock: sounds plausible?

[21:01] <putter> (and faster;)

[21:03] <iblech> leo__: Hm, haven't thought of that. This depends on the implementation of splice -- if it simply does @a[some_index] = ..., then 1), but if it @a.delete(some_index); @a[some_index] = ..., then 5)

[21:03] <fglock> putter: I thought it was doing exactly that

[21:04] <leo__> not good - depends on implementation ...

[21:05] <putter> fglock: nope.  sorry.  the :v toggle to crude_repl will show the compiled p5 code for subsequent entries...

[21:05] <fglock> iblech: each array element must have a cell?

[21:05] <iblech> leo__: Right, @Larry has to spec it

[21:06] <leo__> iblech: can you please forward the relevant snippets to p6l - thx

[21:06] <svnbot6> r6490 | iblech++ | * Makefile.PL: Unbreak make smoke-js (4-char-patch).

[21:06] <svnbot6> r6490 | iblech++ | * t/data_types/array_ref.t: Added another test.

[21:06] <svnbot6> r6490 | iblech++ | * t/general/atoms.t, t/operators/filetest.t: Skip IO tests if $*OS eq "browser".

[21:06] <svnbot6> r6490 | iblech++ | * PIL2JS:

[21:06] <svnbot6> r6490 | iblech++ |   * PIL2JS.js: More unbreaking to &prefix:<+>.

[21:06] <svnbot6> r6490 | iblech++ |   * P5 Prelude::JS: Fix all the standard ops implemented by P5Macros WRT

[21:06] <svnbot6> r6490 | iblech++ |     junction autothreading.

[21:06] <svnbot6> r6490 | iblech++ |   * Prelude::JS::Array: Add "is rw" to &shift, &pop, etc. This was not

[21:06] <svnbot6> r6490 | iblech++ |     previously necessary because PIL2JS assumed "is rw" on all subs (because

[21:06] <svnbot6> r6490 | iblech++ |     -CPerl5 didn't give us that information, but this is fixed now).

[21:06] <svnbot6> r6490 | iblech++ |   * Prelude::JS::Hash: Add "is rw" to &postcircumfix:<{ }> (same reason).

[21:06] <svnbot6> r6490 | iblech++ |   * README: Update WRT P5Macros and TODO

[21:06] <iblech> fglock: An Array contains pointers to other *containers* (the elements). These containers are regular Scalar containers containing a cell

[21:07] <iblech> leo__: Will do

[21:07] <leo__> iblech: then are of course more cases - what happens if the array becomes tied (or was already), passed to a function, slurped, and what not ...

[21:08] <leo__> thanks &

[21:08] <iblech> leo__: Dunno about tied, you've to ask autrijus for that :)

[21:08] <iblech> leo__: Passed to a function -- no problem, the bindings are preserved

[21:08] <iblech> leo__: Slurped -- bindings are lost, as with 5)

[21:10] <fglock> putter: $a=@a works now: my @a=(1,2); my $a=@a; - $a[1] shows '2'

[21:12] <fglock> I'll add '$a[1] is Scalar' to TODO

[21:12] <svnbot6> r6491 | fglock++ | * perl5/ Scalar - fixed $a=@a (again)

[21:13] <putter> fglock: yes, but

[21:14] <putter> I still have to fix the excessive/incorrect use of scalars as part of the variablespace system.

[21:17] <putter> does p6 still have lhs expression lvalues?  (0 ?? $a :: $b) = 3; ?

[21:18] <fglock> @a[1] == Scalar should make @a[1] assignable

[21:18] <fglock> re lvalues - don't know

[21:19] <revdiablo> putter: that works in pugs. I don't remember seeing anything saying they are going away.

[21:19] <putter> it does.  sigh.  looking at the PIL, I dont see an obvious pattern of nodes wherein $a safely goes from being a potentially written varcell to being just a container.

[21:20] <iblech> fglock: Right. PIL2JS's &infix:<,> creates fresh containers for the array it's about to build

[21:22] <iblech> fglock: I.e. instead of @new_array[$idx] := @input_array[$idx], it calles @new_array[$idx] = new_scalar_container; @new_array[$idx] = @input_array[$idx]

[21:22] * putter promises himself to go study all existant documentation on PIL before the next round of flailing.

[21:23] <fglock> is there documentation on PIL?

[21:23] <putter> code, mailinglist discussions, and such.

[21:24] <fglock> iblech: does PIL creates the scalar container or Array has to implement this?

[21:24] <iblech> fglock: Either &infix:<,> or Array have to implement this. Definitely not PIL.

[21:25] <fglock> ok

[21:29] <putter> Does the metamodel include any cell objects?  either container -> cell(s)  or varname -> varcell -> container?

[21:29] <putter> which, if the namespace is a hash, are the same thing

[21:29] <iblech> leo__: mail sent

[21:29] <fglock> no - the cell is a standard p5 object

[21:30] <fglock> defined in Container/Scalar.pm

[21:35] <putter> hmm... what else proxies besides Scalar?  Ref?  anything else?

[21:35] <fglock> I've got @a[1]=3 almost working (some weird behaviour left to fix)

[21:35] <iblech> putter: Proxy

[21:36] <iblech> putter: (sub foo is rw { return new Proxy: FETCH => {...}, STORE => {...} })

[21:36] <putter> hmm...

[21:37] <fglock> iblech: a Proxy is more or less like a tied Scalar? what's the difference?

[21:37] <fglock> just syntax?

[21:37] <iblech> Yes, I think so.

[21:39] <putter> in sub f($x is rw) { }  f(3), Int 3 gets wrapped in a Scalar?

[21:39] <putter> or no, a Ref?

[21:40] <putter> err.

[21:42] <fglock> putter: try this - @a=(1,2); @a[1]=3 -- @a is now (1,3) !!! (update Container first :)

[21:42] <iblech> The 3 has to be promoted to a constant container (if it isn't one already). It's still unspecced whether f(3) should fail at invocation-time (as the constant container holding a cell pointing to 3 isn't rw) or only when $x is actually assigned to

[21:42] <svnbot6> r6492 | fglock++ | * perl5/ Array - elements fetched from the array are aliases

[21:43] <putter> ^_^   fglock++

[21:44] <putter> "constant container"?  containers Scalar, Array, and "constant"?

[21:45] <fglock> iblech: I'm creating cells lazily - because I can't create cell in a lazy Array - but it works the same

[21:45] <putter> ooo, fglock, what mechansm did you use for your array element aliases?

[21:45] <fglock> putter: black magic :)

[21:46] <putter> can I have some for the namespace?

[21:46] <iblech> putter: I expressed myself badly. Not the containers are constant, but the cells of the containers are marked immutable. It's like new Proxy: FETCH => { 3 }, STORE => { die "Can't modify constant...

[21:46] <fglock> I'm doing a check during fetch/pop/shift - if the element isn't a Scalar, then I create a new Scalar and put the element inside

[21:47] * putter imagines a varname -> index -> big-magical-array[index] -> magical-varcell

[21:47] <fglock> if the operation was a fetch, then I store the Scalar back into the Array

[21:47] <putter> is there a p5 Proxy anywhere?

[21:47] <svnbot6> r6493 | fglock++ | * removed debugging info

[21:48] <fglock> putter: what do you need for the namespace?

[21:48] <iblech> putter: tie? But I personally would refrain from implementing P6 Proxy with P5 tie

[21:49] <fglock> putter: you can implement p6 proxy with p6 Scalar tie

[21:49] <fglock> very easily

[21:49] <putter> ah, wright.  you get to use the arrays fetch/store.  sigh.

[21:50] <fglock> but what are you looking for?

[21:52] <fglock> does p6 have @a[1..2]=(1,2) ?

[21:53] <putter> ok, bottom up.  p5 runtime's $scalar_foo, representing p6 $foo.  p6_lookup, variable lookup, represented in PIL by PVar, returns something.  A "varcell".  Something which is read-writable.  There is no clear place where the wriable-ness can be dropped, so you cant really plan on stripping varcell down to the contained value.  varcell will be doing a *lot* of proxying for that value.

[21:53] <iblech> fglock: It has.

[21:53] <iblech> fglock: &postcircumfix:<[ ]> has to be "is rw"

[21:53] <iblech> fglock: And, while we're at it, &infix:<,> has to be is rw, too (think ($a, undef, $b) = (1,2,3))

[21:54] <putter> Previously, Scalar was playing this role.  But it should have been.  So we need something else.

[21:54] <putter> s/value/"value"/.   not a value in the sense if varname->varcell->container->cell(s)->value(s).

[21:56] <putter> varcell will spend it's life proxying for containers.  Scalar, Array, and Hash.  If I could tuck away a \$scalar_foo reference in the container meta-information, for PAssign to use later, I'd be all set.

[21:56] <fglock> it really looks like a Scalar

[21:57] <putter> almost.

[21:57] <fglock> or a Ref - both would work. but a Scalar is lighter

[21:59] <putter> you could have $scalar_foo is a Scalar, but then when you do $s = @a, you want to do $r = $scalar_s->gimme_reference; $$r = $array_a->hold_this_reference($r)

[22:00] <putter> $array_a->copy()->hold_this_reference($r)

[22:00] <fglock> $array_a->clone would work

[22:01] <fglock> objects are already references in p5

[22:01] <putter> $s := @a would be without the copy()

[22:01] <fglock> $s = @a doesn't copy - it just stores the array in the scalar

[22:02] <iblech> putter: Larry ruled that $s := @a is the same as $s = \@a

[22:02] <putter> fglock: right, but for assignment, I need a reference to the symbol table entry.  since I'd be using the containers to fake an enclosing symbol-table-entry-object.

[22:02] <iblech> fglock: err, it just stores a *Ref* to the array in the scalar

[22:03] <fglock> sure, but the Ref autoderefs

[22:03] <putter> so the PIL is wrong?

[22:03] <fglock> (I don't like autoderefs - you never know what's really happening)

[22:04] <iblech> fglock: but only when accessing, not when storing

[22:05] <putter> anyway, that is, I think, secondary.  err, but wait.  so if varname starts out being bound to a Scalar container, is there any way it can be rebound to an Array container?

[22:06] <putter> no, because we have typed varnames here in perl.

[22:06] <fglock> iblech: I just checked - it is implemented right (I must have misunderstood what we were talking about)

[22:07] <iblech> putter: Right, a $-var *always* points to a Scalar container, and a @ always to an Array, etc. (and a & always to a Scalar which only accepts cells of type Code)

[22:07] <putter> $s and @a are always resolve to Scalar and Array containers respectively?

[22:07] <iblech> putter: Right.

[22:07] <putter> ok.

[22:07] <iblech> fglock: Ah, ok

[22:08] * putter slowly collects twigs, and dust bunnies, and patient guidance, and begins to assemble a clue.

[22:09] <fglock> putter: I also find it difficult to understand. 

[22:10] <fglock> most of the bugs I've fixed were because I didn't know what I was doing :)

[22:10] <landover> que es tu problema?

[22:10] <fglock> mi problema es que perl6 no esta totalmente especificado

[22:11] <putter> iblech++ fglock++ revdiablo++ etal++  # helping putter assemble a clue

[22:12] <iblech> We should probably document this somewhere

[22:12] <landover> si si esta grande problema es la documentacin eso mala

[22:12] <putter> one last lose end.  the PIL currently generated for $s = @a is incorrect, yes?  (no Ref anything)

[22:12] <fglock> putter: almost everything is in Container/Scalar.pm, if you dare to read it

[22:13] <landover> so do you guys have an actual project plan / course of action etc?

[22:13] <Supaplex> the secret to life, the universe, and oh yea, perl itself is housed there

[22:13] <landover> just curious

[22:14] <iblech> putter: Asked autrijus about this once. The answer was: No, PIL is correct, consider $s = some_sub() -- PIL can't know whether some_sub will return an array or a scalar

[22:14] <landover> ah life = h/v4

[22:14] <iblech> putter: Therefore I put the appropriate magic in .STORE

[22:14] <putter> ah.  ok.  more magic comming up.  fglock!  :)

[22:14] <iblech> putter: See PIL2JS/libjs/PIL2JS.js, lines 104-174

[22:14] <putter> is there a mm Ref?

[22:15] * fglock must go now :(

[22:15] <fglock> putter: Ref is defined in Value.pm

[22:15] <putter> ohhhhh.

[22:15] <putter> ok.

[22:15] <svnbot6> r6494 | fglock++ | * perl5/ Array - more TODO

[22:16] <putter> I'll patch and polish.

[22:16] <putter> You've done a nifty job today.

[22:18] <putter> Now we know why it was "almost" working... it was "almost" correct... ;)  (just the bit about array variables having Array containers)

[22:18] <fglock> bye!

[22:18] <putter> good night!

[22:19] <svnbot6> r6495 | iblech++ | STATUS:

[22:19] <svnbot6> r6495 | iblech++ | * PIL2JS passes about 2/3 -> more than 2/3 (73.46% currently :))

[22:19] <svnbot6> r6495 | iblech++ | * putter is merging make targets -> putter merged make targets, and added

[22:19] <svnbot6> r6495 | iblech++ |   examples (test-perl5, test-js, etc.)

[22:20] * iblech needs to sleep too. Night all :)

[22:20] <putter> I hereby note for the record that PIL-Run would just sooooooo not be happening at all without fglock and putter.

[22:20] <putter> good night iblech!

[22:20] <iblech> oh and putter++ fglock++ # progressing *rapidly*

[22:20] <iblech> :)

[22:20] <putter> err, that's fglock and iblech.

[22:20] <putter> eeps.  *face red*

[22:21] <putter> iblech quits.  now *face very red*

[22:22] <putter> oy

[22:24] <putter> iblech: please note above. ;)

[22:25] <putter> to repeat,

[22:25] <putter> I hereby note for the record that PIL-Run would just sooooooo not be happening at all without fglock and iblech.

[22:25] <putter> ah.  done.

[22:54] <svnbot6> r6496 | putter++ | PIL-Run - array variables now get Array containers.  p6_set treats $s = @a; as $s = \@a;  fglock++ iblech++  Some problems: @a = @b doesnt seem to work, and p5ugs> $s = @a;  dies, perhaps because Ref doesnt stringify.

[23:07] <brentdax> Does splat-in-subcall not work yet?

[23:08] <putter> ?eval my @a=(3,4); sub f(@b){join ",",@b} f(*@a)

[23:08] <evalbotzy> '3,4' 

[23:08] <brentdax> I'm trying to do something like $subref($foo, *@bar) and it's not working--the sub gets an array with the contents of @bar, rather than the contents separated out into parameters.

[23:09] <putter> hmm...

[23:09] <brentdax> ?eval my @a=(3,4); sub f($x,$y) { return $x * $y } f(*@a)

[23:09] <evalbotzy> Error: No compatible subroutine found: "&f" 

[23:10] <brentdax> Guess I'll work around it...probably tomorrow, though, rather than tonight.

[23:11] <putter> guess not...

[23:12] <putter> the PIL looks ok, so maybe on the JS backend?

[23:12] <brentdax> I'm using the default backend.

[23:13] <putter> yes

[23:13] <brentdax> I think I ran into this earlier in the project too, but I didn't realize what was going on.

[23:15] <putter> hmm, could you zip @a with qw(x y) and call it with the tuples?

[23:16] <brentdax> I don't believe so--that was one of the things I tried the first time I hit this.

[23:16] <brentdax> ?eval my @a=(x=>3,y=>4); sub f($x,$y) { return $x * $y } f(*@a)

[23:17] <putter> ?eval my @xya=(x =>3,y=>4);  sub f($x,$y) { return $x * $y } f(@xya)

[23:17] <evalbotzy> Error: No compatible subroutine found: "&f" 

[23:17] <evalbotzy> Error: No compatible subroutine found: "&f" 

[23:17] <putter> ?eval my @xya=(x =>3,y=>4);  sub f($x,$y) { return $x * $y } f(x=>3,y=>4)

[23:17] <evalbotzy> 12 

[23:18] <putter> ?eval my @xya=(x =>3,y=>4);  my $f = sub ($x,$y) { return $x * $y } $f(@xya)

[23:18] <evalbotzy> Error:  unexpected "$" expecting term postfix, operator, ";" or end of input 

[23:19] <putter> ?eval my @xya=(x =>3,y=>4);  my $f = sub ($x,$y) { return $x * $y }; $f(@xya)

[23:19] <evalbotzy> 0.0 

[23:19] <putter> ?eval my @a=(3,4);  my $f = sub ($x,$y) { return $x * $y }; $f(@a)

[23:19] <evalbotzy> 0.0 

[23:19] <putter> ?eval my @a=(3,4);  my $f = sub ($x,$y) { return $x * $y }; $f(*@a)

[23:19] <evalbotzy> 0.0 

[23:20] <brentdax> ?eval my @a=(3,4); my $f = sub ($x,$y) { return $x.ref ~ $y.ref }; $f(@a)

[23:20] <evalbotzy> 'ArrayScalar' 

[23:20] <putter> bah.  so both function resolution and argument binding seem to be troubled.

[23:20] <brentdax> er,

[23:20] <brentdax> ?eval my @a=(3,4); my $f = sub ($x,$y) { return $x.ref ~ $y.ref }; $f(*@a)

[23:20] <evalbotzy> 'ArrayScalar' 

[23:21] <putter> or, maybe just prefix:<*>....

[23:22] <putter> ?eval my @a=(3,4); map{.ref} *@a

[23:22] <evalbotzy> (::Int, ::Int) 

[23:22] <brentdax> There's a problem with the ref-to-sub stuff too, I think--calling through a subref should defer signature checking, not disable it.

[23:22] <putter> ?eval my @a=(3,4);  my $f = sub ($x,$y) { return $x * $y }; $f(map{$_} *@a)

[23:22] <evalbotzy> 0.0 

[23:22] <putter> ??

[23:23] <brentdax> ?eval my @a=(3,4); my $f = sub ($x,$y) { return $x ~ $y }; $f(map{$_} *@a)

[23:23] <evalbotzy> '3 4' 

[23:23] <brentdax> ?eval my @a=(3,4); my $f = sub ($x,$y) { return "$x,$y" }; $f(map{$_} *@a)

[23:23] <evalbotzy> '3 4,' 

[23:24] <putter> ?eval my @a=(3,4); map{.ref} 'a',*@a,'b'

[23:24] <evalbotzy> (::Str, ::Int, ::Int, ::Str) 

[23:24] <putter> ?eval my @a=(3,4); map{.ref} *@a,'b'

[23:24] <evalbotzy> (::Int, ::Int, ::Str) 

[23:25] <putter> ?eval my @a=(3,4); my $f = sub ($x,$y,$z) { return "$x,$y,$z" }; $f(77,*@a)

[23:25] <evalbotzy> '77,3 4,' 

[23:26] <putter> ?eval my @a=(3,4); @a.ref

[23:26] <evalbotzy> ::Array 

[23:26] <putter> ?eval my @a=(3,4); my $f = sub ($x,$y,$z) { return "$x,$y,$z" }; $f(map{$_} 77,*@a)

[23:26] <evalbotzy> '77 3 4,,' 

[23:28] <putter> sorry brentdax, no quick fixes come to mind.

[23:29] <brentdax> I expected as much.  Nasty workaround time, I suppose, which means I'll wait until tomorrow.

[23:30] <putter> ok.  (we need to find autrijus some funding...)

[23:30] <putter> end of day for me too I think.

[23:31] <geoffb> g'night, putter

[23:31] <brentdax> G'night.

[23:31] <putter> good night &

