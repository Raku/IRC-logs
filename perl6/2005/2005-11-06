[00:07] <leo> rafl: maybe folks should run nice 'the work'

[00:08] <autrijus> sync.pl (and darcs) is now running in +20

[00:09] <autrijus> hope that helps

[00:11] <leo> I don't really care how long my 'nice make all test' is running, when I'm doing that, but I don't like latency in my screen/irssi session ;-) 

[00:12] <leo> anyway feather is really great - Juerd++ 

[00:12] <rafl> Indeed!

[00:12] <Juerd> :)

[00:12] <Juerd> leo: Do you usually have latency?

[00:13] <Juerd> 'cause if people nice their stuff correctly, there shouldn't be

[00:13] <leo> no - no problem

[00:13] <Juerd> ok

[00:14] <leo> I'm compiling on another machine in hawaii regularly - I know what latency is ;-)

[00:14] <Juerd> Hehe

[00:15] <leo> but with that machine I have svn up;make realclean;perl Configure.pl;make test in ~4 mins

[00:15] <Juerd> That's fast

[00:15] <leo> it is

[00:15] <Juerd> Can't you set up distcc on it? ;)

[00:16] <rafl> We shoud setup a global ccache on feather, btw.

[00:16] <leo> it has ccache alreay

[00:16] <Juerd> rafl: There is

[00:16] <leo> but distcc  could work too

[00:16] <Juerd> Something ccache like for ghc would be sweet.

[00:16] <eric256> juerd...any ideas why the feather build seems to be failing? the .err file is empty. ;(

[00:17] <leo> it's a dual opteron 250 machine

[00:17] <eric256> trying a manual build now

[00:17] <rafl> Juerd: a global one?

[00:17] <SamB> Juerd: ccache?

[00:17] <leo> nope

[00:17] <leo> compiler cache

[00:17] <rafl> Juerd: Could be possible. At least for the work ghc does using cc.

[00:17] <Juerd> rafl: Oh, no, it had that, but things broke randomly and I lacked fixing fu

[00:17] <Juerd> eric256: No idea.

[00:18] <rafl> Juerd: I also tried it and it didn't work out. Thought I was to dumb for it.

[00:18] <Juerd> eric256: That's why I wanted someone else to do this :)

[00:18] <Juerd> rafl: Anyway, ccache per user is a big save already

[00:19] <rafl> Juerd: Yes. A global one would be even better because most people are compiling the same stuff there, afaik.

[00:19] <Juerd> Yes, but as said, that fails misteriously

[00:19] <Juerd> mysteriously.

[00:20] <eric256> juerd. no prob, looking into it ;)

[00:22] <svnbot6> r7865 | autrijus++ | * repo cp Pugs.Compile to Pugs.Compile.PIL2 to begin the new compilation saga.

[00:23] <leo> Juerd: a global ccache is imho not the best idea

[00:23] <rafl> leo: Why?

[00:23] <leo> tell folks how to use it locally

[00:23] <leo> I don't think it scales and in trouble case you can't clean it

[00:24] <Juerd> leo: IIRC, it's used by default

[00:25] <leo> indeed

[00:25] <Juerd> Then telling people isn't necessary :)

[00:25] <leo> ok - as long as it works

[00:25] <Juerd> Haven't had complaints

[00:25] <Juerd> Well, since the global cache was removed, anyway

[00:26] <leo> I had some nasty compile errors that went away after clearing the cache, not often, but ...

[00:26] <Juerd> You just bumped the counter to 1

[00:26] <Juerd> I'll take action when it's at 5 :)

[00:26] <leo> ah - I see - the .ccache is local - fine then

[00:33] <autrijus> hm, I'd like to change -CPerl5 to -CPIL-Perl5.

[00:33] <svnbot6> r7866 | autrijus++ | * New compiler backend targets around PIL2:

[00:33] <svnbot6> r7866 | autrijus++ |     ./pugs -C PIL2-Perl5

[00:33] <svnbot6> r7866 | autrijus++ |     ./pugs -C PIL2-JSON

[00:33] <svnbot6> r7866 | autrijus++ |     ./pugs -C PIL2-Binary

[00:33] <svnbot6> r7866 | autrijus++ |   The dash is optional (all nonalphanum is dropped), and

[00:33] <svnbot6> r7866 | autrijus++ |   it's case insensitive.  Eventually these will replace

[00:33] <svnbot6> r7866 | autrijus++ |   the PIL1 variants when our p5/js codegens finishes the

[00:33] <svnbot6> r7866 | autrijus++ |   migration.

[00:33] <autrijus> reserving -CPerl5 for the true "compile to perl5", not "compile to pil, dump as perl5"

[00:34] <Juerd> autrijus: Do you know if there's anything that lets ghc cache things?

[00:34] <Juerd> autrijus: So compilation doesn't happen again for unchanged files?

[00:35] <autrijus> Juerd: GHC should automatically do that.

[00:35] <autrijus> it's the linking that is mandatory

[00:35] <Juerd> Oh

[00:35] <Juerd> But this doesn't work across make cleans, right?

[00:36] <Juerd> Ah well, it's no big deal anyway

[00:36] <Juerd> feather's fine as it is

[00:37] <Juerd> eric256: One piece of advice: when running autobuild.sh manually, disable the cron thingy. Two concurrent instances will mess things up.

[00:39] <eric256> how do i disable the cron?  comment it out?

[00:40] <autrijus> Juerd: well, we can spec so that clean doesn't clean dist/build

[00:40] <autrijus> in Makefile.PL

[00:40] <autrijus> in which case it will survive clean

[00:40] <Juerd> eric256: Yes

[00:40] <rafl> Pugs.cabal contains /usr/lib/blib/lib for me now which seems to be wrong. Does anyone know which changes introduced that?

[00:41] <Juerd> autrijus: Then what does it clean? I think this would be counterintuitive

[00:41] <autrijus> doesn't say that here

[00:41] <autrijus> Juerd: k

[00:41] <Juerd> My dillemma is that for an automated building thing, you'd want make clean, but not to recompile.

[00:41] <Juerd> But cleaning up does improve the success ratio a lot :)

[00:41] <Juerd> ccache fixes this for C

[00:42] <rafl> autrijus: On feather?

[00:42] <eric256> could make clean on the hour, but between hours just regular make ?

[00:42] <Juerd> eric256: Oh, if a build fails, then from then on, it will not build at all (and thus keep err empty) until there's a new svk revision.

[00:42] <Juerd> eric256: When testing, comment out the condition

[00:42] <rafl> eric256: Could you please stop your autobuild job? I'd like to try how it works for the debian packages.

[00:43] <eric256> yea i'm not testing the script right now, just trying to get it to build at all

[00:43] <rafl> Thank you.

[00:43] <eric256> um ralf the build isn't working at all yet so you might want to make

[00:44] <eric256> make clean; perl Makefile.PL; make unoptimized;  doesn't seem to work. trying a build right now

[00:44] * theorbtwo is back.

[00:45] <rafl> eric256: I'm rafl, btw. Not ralf. :-)

[00:46] <eric256> hehe sorry. daughter started chocking...on nothing apparently. fun how they do that. ;)

[00:51] <svnbot6> r7867 | autrijus++ | * ./pugs -C Perl5 (and -C JSON, -C Binary) are deprecated.

[00:51] <svnbot6> r7867 | autrijus++ |   Use "-C PIL1-Perl5" instead; it doesn't have to be a dash;

[00:51] <svnbot6> r7867 | autrijus++ |   any nonalphanumerical character would do:

[00:51] <svnbot6> r7867 | autrijus++ |     ./pugs -CPIL1.Perl5 -e 'say 123'

[00:51] <svnbot6> r7867 | autrijus++ |   This is because "-C Perl5" will be reserved to mean the

[00:51] <svnbot6> r7867 | autrijus++ |   backend that actually compiles to Perl 5.

[00:54] <rafl> Is there a way to do a "lexically scoped" chdir?

[00:55] * eric256 wonders why pugs is taking SOOO long to build on feather now... hmmm

[00:59] <autrijus> rafl: why, yes, 

[00:59] <autrijus> temp $*CWD = '/path'

[01:00] <autrijus> if you mean p5, File::chdir on cpan does the same.

[01:00] <autrijus> I think I'll sleep now -- tomorrow should see the beginning of -CPerl6.

[01:00] * autrijus waves &

[01:02] <Juerd> afk

[01:02] <Juerd> z

[01:13] <eric256> rafl: you around?

[01:13] <eric256> wanna try your debian package stuff?  build passed finaly ;)

[01:15] <rafl> eric256: Yes.

[01:16] <rafl> eric256: First tell me how to do anon closures in p6. :-)

[01:17] <Khisanth> $foo = { ...; } ?

[01:19] <rafl> sub { ... } seems to work.

[01:19] <Khisanth> both work :)

[01:20] <Khisanth> unless your sub looks like a hash to pugs

[01:22] <rafl> Look at http://perlcabal.org/~rafl/autobuild.p6 -- in recompilation_is_needed @list.elems says 2 so it should return bool::false. It returns something true nevertheness.

[01:24] <rafl> Using an explicit return $ret in work_in fixes that. Why doesn't --> $ret work?

[01:25] <dduncan> so, for those of you using svk to commit pugs offline, do you set svk up to first mirror only the latest pugs rev, or the whole pugs history, or do something else

[01:25] <Khisanth> rafl: perhaps not implemented yet? :)

[01:26] <rafl> THought is was..

[01:26] <eric256> rafl i would guess it doesn't work yet.

[01:26] <eric256> ?eval sub test (--> $ret) { $ret = "hello";"nope" }; print test();

[01:26] <evalbot_7867> Error:  unexpected "-" expecting formal parameter, ":" or ")" 

[01:27] <eric256> ?eval sub test ($str --> $ret) { $ret = "hello";"nope" }; print test("a");

[01:27] <evalbot_7867> Error: Undeclared variable: "$ret" 

[01:27] * eric256 thinks he doesn't understand --> ;)

[01:27] <rafl> ?eval sub foo ($a, $b --> $c) { $c = $a + $b; "I'll return $c anyway!".say } foo(1, 2);

[01:27] <evalbot_7867> Error: Undeclared variable: "$c" 

[01:27] <rafl> ?eval sub foo ($a, $b --> $c) { my $c = $a + $b; "I'll return $c anyway!".say } foo(1, 2);

[01:27] <evalbot_7867> I'll return 3 anyway! bool::true 

[01:28] <rafl> :-(

[01:28] <rafl> OK.. please do some commits on parrot and pugs so I can verify it works ;-)

[01:28] <rafl> Or do we already have a getopt lib?

[01:29] * theorbtwo wonders if it's strange that Jet Lee films now always remind him of Autrijus.

[01:30] <Khisanth> rafl: why do you expect $ret to be returned?

[01:31] <rafl> Khisanth: Because perl 6 can do named returns

[01:33] <eric256> will be able too...doesn't yet ;)  /me goes to give daughter bath...back in 30

[01:34] <rafl> What's wrong with this version: http://perlcabal.org/~rafl/autobuild.p6

[01:34] <rafl> It doesn't get parsed right.

[01:36] <Khisanth> hrm but according to S6 that --> is only to indicate the return type

[01:38] <theorbtwo> ?eval sub test(--> Int) {3.14}; test();

[01:38] <evalbot_7867> Error:  unexpected "-" expecting formal parameter, ":" or ")" 

[01:38] <theorbtwo> ?eval sub test($a --> Int) {3.14}; test();

[01:38] <evalbot_7867> Error: No compatible subroutine found: "&test" 

[01:39] <theorbtwo> ?eval sub test($a --> Int) {3.14}; test(1);

[01:39] <evalbot_7867> 157/50 

[01:40] <theorbtwo> I don't think it does anything.

[01:43] <rafl> How about the parse error in http://perlcabal.org/~rafl/autobuild.p6

[01:43] <rafl> I don't see what's wrong.

[01:45] <Khisanth> rafl: but what is the error?

[01:45] <Khisanth> message

[01:46] <rafl> unexpected "@"

[01:46] <rafl> expecting block construct, ":", word character, "::", term postfix, operator, ",", "!!", postfix conditional, postfix loop, postfix iteration, ";" or "}"

[01:46] <rafl> at autobuild.p6 line 20, column 16

[01:47] <Khisanth> perhaps you want @ARGS[0] or @*ARGS[0]? 

[01:50] <rafl> That doesn't change anything.

[02:06] <rafl> eric256: OK, auto building/installing is done via dpkg now.

[02:06] <rafl> eric256: Only the haskell interface to pugs isn't installed.

[02:20] <azuroth> afternoon, all

[02:22] <rafl> Hi azuroth 

[02:22] <azuroth> how's it all going?

[02:24] <rafl> Quite well. I'm happy that feather now uses the Debian packages of pugs and parrot and that I can upload parrot officially to the Debian archive tomorrow. :-)

[02:25] <azuroth> oh, excellent!

[02:27] <azuroth> how about ubuntu..?

[02:28] <rafl> I'm not an ubuntu developer.

[02:32] <azuroth> ahh

[02:34] <eric256> rafl: do you have a script for me to use? or is it running on your account?

[02:37] <rafl> It runs on my machine currently. You have the right's to install debian packages using sudo withoug a password as well. You can steal ~rafl/autobuild if you want.

[02:37] <eric256> actualy i can't cause i can't get into that directory ;)

[02:38] <eric256> if you have it setup to cron thats fine with me

[02:38] <eric256> your building pugs and parrot?

[02:38] <rafl> I set up cron and I build parrot and pugs (with p5 and parrot embedding)

[02:39] <eric256> sounds fine to me.  i'll still build and smoke every 6 hours.

[02:40] <rafl> OK

[02:40] * eric256 passes an only recently acquired torch on to rafl ;)

[02:41] <eric256> ?eval ('a*' ~~ /<p6rule>/)

[02:41] <evalbot_7867> Error: cannot cast from VUndef to Pugs.AST.Internals.VCode (VCode) 

[02:42] * eric256 wishes eval bot used the same version of pugs as the general feather one

[02:43] <azuroth> haha. that's crazy

[02:44] <eric256> azuroth??

[02:45] <azuroth> rule called p6rule

[02:46] <eric256> yea. its pretty cool. gives you a hash representation of the match object...kinda hard to explain but if you try it on feather you'll see the output. ;)

[02:48] <eric256> i can't wait tlil we have the p6code rule ;) or a p5code rule. be able to parse code on the fly ;)

[02:49] <azuroth> :D

[02:49] <azuroth> what will the benefits of that over eval be, though? ;-p

[02:50] <eric256> source filters that work on an actual syntax tree? or how about building your own grammar for a script language?  its the hard part of making your own programming language already done! ;)

[02:51] <rafl> eric256: Why doesn't it do that?

[02:51] <rafl> eric256: wrt evalbot and the pugs executable

[02:51] <azuroth> ohh

[02:51] <eric256> easy safe.. just scan the parsed tree for unsafe calls. etc. color coding a perl6 source file, super smart search and replace, editors tahn can refactor

[02:51] <eric256> and more. ;)

[02:52] <eric256> rafl: no idea, been looking for ages for the owner of that bot, it should also stop logging on and off every time someone commits, eventualys its going to hit some rate limit on IRC ;) 

[02:53] <rafl> eric256: Yes!

[02:53] <eric256> in case azuroth didn't notice eric256 can think of 101 uses for parsing perl and thats just the start ;)

[02:53] <rafl> eric256: It runs on feather. fibonaci (Luke) runs it.

[02:54] <eric256> luke!!! i saw fibonaci but never put 2 and 2 together. ;)

[02:54] <rafl> finger fibonaci.. whois fibonaci

[02:54] <azuroth> syntax highlighting would be awesome

[02:55] * rafl goes to bed. 4am already.. bye!

[02:55] <azuroth> night, rafl

[02:56] <eric256> oddly that bit with the rule doesn't work on the command line at all. but it does in interactive..

[02:56] <eric256> is there some difference between those two i'm not aware of?

[03:00] <azuroth> you make me strong, you're my vitamin

[03:24] <eric256> gaal: ping

[03:25] <eric256> nm. i had a question about your article. but it makes sense after all ;)

[03:45] <Khisanth> ?eval my $h = hash( a=>1, b=>2, c=>3 );

[03:45] <evalbot_7867> Error: cannot cast from VUndef to Handle (VHandle) 

[03:45] <Khisanth> ?eval my $h = {a=>1, b=>2, c=>3}; $h.perl

[03:45] <evalbot_7867> "\{(\"a\" => 1), (\"b\" => 2), (\"c\" => 3)}" 

[03:45] <eric256> ?eval my $h = hash(( a=>1, b=>2, c=>3 ));

[03:45] <evalbot_7867> Error: cannot cast from VUndef to Handle (VHandle) 

[03:45] <Khisanth> ?eval my $h = {a=>1, b=>2, c=>3}; $h<a b c>;

[03:45] <evalbot_7867> [1, 2, 3] 

[03:45] <Khisanth> hrm

[03:46] <Khisanth> ?eval my $h = [{a=>1, b=>2, c=>3}]; $h[0]<a b c>;

[03:46] <evalbot_7867> [1, undef, undef] 

[03:46] <Khisanth> ?eval my $h = [{a=>1, b=>2, c=>3}]; $h[0].<a b c>;

[03:46] <evalbot_7867> [1, undef, undef] 

[03:46] <azuroth> ?eval (2,4) == (5,7)

[03:46] <evalbot_7867> bool::true 

[03:47] <azuroth> ?eval (2,4) ~~ (5,7)

[03:47] <evalbot_7867> bool::false 

[03:48] <azuroth> ?eval my @a = (2,4), @b = (5,7); @a == @b

[03:48] <evalbot_7867> Error: Undeclared variable: "@b" 

[03:48] <azuroth> ?eval my @a = (2,4); my @b = (5,7); @a == @b

[03:48] <evalbot_7867> bool::true 

[03:48] <Khisanth> an overloaded ==?

[03:49] <azuroth> ?eval my @a = (2,4); my @b = (5,7); *@a == *@b

[03:49] <evalbot_7867> bool::true 

[03:49] <azuroth> ?eval my @a = (2,4); my @b = (5,7); ~@a == ~@b

[03:49] <evalbot_7867> bool::false 

[03:49] <Khisanth> ?eval my @a = (2,4); my @b = (5,7); my $a = @a; my $b = @b; $a == $b

[03:49] <evalbot_7867> bool::true 

[03:49] <azuroth> it was happening on feather too, so I wanted to check evalbot

[03:49] <Khisanth> ?eval my @a = (2,4); my @b = (5,7); my $a = @a; say $a.perl, $b.perl

[03:49] <evalbot_7867> Error: Undeclared variable: "$b" 

[03:50] <Khisanth> ?eval my @a = (2,4); my @b = (5,7); my $a = @a; my $b=@b; say $a.perl, $b.perl

[03:50] <evalbot_7867> [2, 4][5, 7] bool::true 

[03:50] <Khisanth> why are they equal?

[03:51] <azuroth> ?eval my %a = {:a(5), :b(2)}; my %b = {:a(3), :b(0)}; %a == %b

[03:51] <evalbot_7867> bool::true 

[03:51] <azuroth> ?eval my %a = {:a(5), :b(2)}; my %b = {:a(3), :c(0)}; %a == %b

[03:51] <evalbot_7867> bool::true 

[03:51] <azuroth> ?eval my %a = {:a(5), :b(2)}; my %b = {:a(3), :b(0)}; %a ~~ %b

[03:51] <evalbot_7867> bool::false 

[03:51] <azuroth> ?eval my %a = {:a(5), :b(2)}; my %b = {:a(3), :d(0)}; %a ~~ %b

[03:51] <evalbot_7867> bool::false 

[03:51] <Khisanth> ?eval my @a = (2,4); my @b = (5,7,8); @a == @b

[03:51] <evalbot_7867> bool::false 

[03:52] <Khisanth> ?eval my @a = (2,4); my @b = (5,7,8); @a > @b

[03:52] <evalbot_7867> bool::false 

[03:52] <azuroth> hmm, ok. I thought smart match was supposed to check the keys, not vals. must be mistaken

[03:52] <Khisanth> oops

[03:52] <Khisanth> ?eval my @a = (2,4); my @b = (5,7,8); @a < @b

[03:52] <evalbot_7867> bool::true 

[03:53] <azuroth> so it's acting as if it's using numeric context?

[03:53] <Khisanth> I guess

[05:20] <jdv79> seen stevan

[05:20] <jabbot> jdv79: stevan was seen 1 days 8 hours 7 minutes 56 seconds ago

[05:42] <gaal> eric256: pong + pong**-1 :)

[05:43] <eric256> ;)

[05:43] <eric256> map being lazy is...confusing. ;) at least after p5

[05:44] <eric256> btw i think the class sigil is now ^ , i've seen larry use it a couple times now ;)  sub test (^class $test) {};

[05:48] <Khisanth> that was also used in the Synopsis

[05:48] <gaal> map being lazy is *wonderful*

[05:49] <gaal> hmm, thanks for the class tip! this really shortens the unicode list

[05:49] <eric256> i dunno about wonderfull.... map being able to be lazy ++...defaulting to lazy...i dunno. ;)

[05:50] <eric256> btw on your split().join() example why not split on space, join with - or something.  just so it seems less pointless. ;)

[05:50] <eric256> ?eval "Hello, world!".split(" ").join("-").say;

[05:50] <evalbot_7867> Hello,-world! bool::true 

[05:50] <eric256> ?eval "Hello, world!".split(" ").join("\t").say;

[05:50] <evalbot_7867> Hello,	world! bool::true 

[05:51] <gaal> hee, well the point was that a list was an invocant. you can't do that in p5. that block should probably go elsewhere where i have space to elaborate

[05:51] <eric256> and the equvilant p5 might be more like...print join("-", split(" ", "hello world")),"\n";  just so you are comparing apples to apples

[05:51] <gaal> you have the usual p5 chain:

[05:52] <gaal> $out = join split $in # pseudocode

[05:52] <gaal> but these are builtins

[05:52] <gaal> .join and .split are methods

[05:53] <gaal> ?eval <3 1 4 1 5>.join("")

[05:53] <evalbot_7867> "31415" 

[05:53] <gaal> can't do that in p6

[05:53] <gaal> errr

[05:53] <gaal> in p5

[05:53] <eric256> 10 01?eval <3 1 4 1 5>.join()

[05:53] <eric256> 10 01?eval <3 1 4 1 5>.join;

[05:53] <eric256> ?eval <3 1 4 1 5>.join;

[05:53] <evalbot_7867> "31415" 

[05:53] <eric256> stupid space before ? lol.

[05:54] <eric256> point just is that in p6 you don't need to pass empty string, so either don't make it empty or don't pass it, because it looks like you are writing p5.5 ;)

[05:54] <eric256> any i should sleep. article look great BTW!

[05:55] <gaal> anyone got a link to the ruling on the cent sigil?

[05:55] <gaal> thanks!

[05:55] <gaal> aaah, thanks, good point

[05:55] <gaal> eric256++

[05:58] <gaal> we need a mailing list interface where, like in the spirit of anonpan, people can flag emails with the 'ruling' bit.

[06:01] <gaal> .oO( hmmmm, i think i may leave join("") for symmetry with split(""). )

[06:01] <eric256> ?eval "hello".split;

[06:01] <evalbot_7867> ("hello",) 

[06:02] <eric256> hmmm interesting

[06:02] <gaal> not special: whitespace based split, like p5.

[06:03] <eric256> S02/Names and Variables

[06:03] <gaal> ahh, thanks.

[06:03] <eric256> ?eval "hello world".split.join;

[06:03] <evalbot_7867> "helloworld" 

[06:03] <eric256> ?eval "hello world".split.join("-");

[06:03] <evalbot_7867> "hello-world" 

[06:03] <eric256> ?eval "hello world".split("").join("-");

[06:03] <evalbot_7867> "h-e-l-l-o- -w-o-r-l-d" 

[06:04] <eric256> [~] "hello".split("");

[06:04] <gaal> makes perfect sense when you think of it. just like p5

[06:04] <eric256> ?eval [~] "hello".split("");

[06:04] <evalbot_7867> "hello" 

[06:05] <eric256> i'm not sure p5 ever realy makes perfect sense. ;) and i'm not sure spliting on ' ' implicity is DWIM. guess its splitting on \s+ not ' '..anyway realy must sleep. later

[06:06] <gaal> it's a little more DWIMmier than that, it throws away trailing records that are empty :) but i have to say that often that was *exactly* what I wanted.

[06:06] <gaal> night :)

[06:11] <azuroth> why is it called golfing system, anyway?

[06:14] <svnbot6> r7868 | gaal++ | tpr.pod: remove obsolete class sigil from unicode list, add eric256++

[06:24] <gaal> azuroth: it helps you get to your goal with fewer kestrokes

[06:27] <gaal> work &

[06:27] <azuroth> ahh

[06:38] <dduncan> well, I seem to have gotten svk installed, so tomorrow I can start using it

[06:38] <svnbot6> r7869 | stevan++ | Perl6::ObjectSpace - nil now has &is_not_nil; so does type; more converting of Boostrap.pm to s-expressions about 80% done now (see docs/sexp_meta_model.pod)

[06:40] <dduncan> unfortunately, it spews a bunch of warnings from Class/Autouse.pm under the system perl, though the latest perl doesn't have those problems ... but I can't easily get it to work with that newer perl in a nonstandard location, so I'm stuck with two-dozen warnings every time I invoke svk

[06:44] <azuroth> ?eval sub a($a,$b){say $a ~ $b; }; a 1 2;

[06:44] <evalbot_7869> Error:  unexpected "2" expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[06:44] <azuroth> ?eval sub a($a,$b){say $a ~ $b; }; a 1, 2;

[06:44] <evalbot_7869> 12 bool::true 

[06:45] <azuroth> hm, ok. I didn't see optionality of ()s for subs in perl 6 essentials - just methods

[06:47] <dbrock> I thought it was the other way around

[06:48] <azuroth> ?eval "hello world".split "o"

[06:48] <evalbot_7869> Error:  unexpected "\"" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[06:48] <azuroth> ?eval "hello world".split("o")

[06:48] <evalbot_7869> ("hell", " w", "rld") 

[06:48] <dbrock> :-)

[06:48] <azuroth> hah. that's interesting...

[06:49] <azuroth> ?eval split "hello world": "o"

[06:49] <evalbot_7869> ("hell", " w", "rld") 

[06:49] <azuroth> hmm, okay, maybe it was only talking about that

[06:49] <dbrock> I don't remember or understand why allowing <"hello world".split "o"> is problematic

[06:50] <dbrock> but I'm sure there is a very good reason :-)

[06:50] <azuroth> hmm. yeah

[06:50] <dbrock> and I'm sure it's done that way so that we can enjoy other cool and convenient niceties

[06:52] <dbrock> ?eval split "hello world", "o"

[06:52] <evalbot_7869> ("o",) 

[06:53] <dbrock> ?eval split "o"

[06:53] <evalbot_7869> ("o",) 

[06:54] <dbrock> what does that list syntax mean?

[06:54] <dbrock> ?eval ("o",)

[06:54] <evalbot_7869> ("o",) 

[06:54] <dbrock> ?eval ("o", undef)

[06:54] <evalbot_7869> ("o", undef) 

[06:54] <dbrock> ?eval ("o",,,)

[06:54] <evalbot_7869> ("o",) 

[06:55] <azuroth> ?eval split

[06:55] <gaal> method calls require parens if they have params

[06:55] <evalbot_7869> Error: No compatible subroutine found: "&split" 

[06:55] <gaal> ?eval "hello world".split("o")

[06:55] <evalbot_7869> ("hell", " w", "rld") 

[06:55] <gaal> but i'm not here :)

[06:56] <azuroth> you're having fun working, right?

[06:56] <gaal> no, i'm having fun being late for work :)

[06:56] <azuroth> haha

[06:56] <gaal> &

[08:25] * azuroth wonders about porting rails to perl 6

[08:27] <r0nny> yo

[08:27] <azuroth> hey r0nny

[08:50] <azuroth> is there any ported database stuff yet?

[08:53] <r0nny> i dont think there is such stuff atm

[08:53] <azuroth> ;-)

[09:19] <wolverian> azuroth, use perl5:DBI;

[09:20] <azuroth> or maybe I could port DBI, or something with a similar goal at least?

[09:23] <wolverian> right. whatever is fun :)

[09:24] <azuroth> :D

[11:03] <webmind> morning

[11:03] <webmind> hm is there anything like sysread for perl6 ?

[11:04] <r0nny_> yo 

[11:05] <r0nny_> i dont know if sys_read is implemented

[11:05] <rafl> webmind: There's a sysread in the S29 draft.

[11:07] <rafl> Why must I use Pipe::open instead of Pipe.open which seems more natural to me?

[11:09] <webmind> S29 ?

[11:10] <gaal> rafl: Pipe.open "should" work to the best of my knowledge.

[11:11] <gaal> that is, i think that's what the spec says, but haven't seen it actually working that way recently. It did use to.

[11:12] <rafl> gaal: It doesn't as it seems. No compatible subroutine found: "&Pipe"

[11:12] <r0nny_> hmm - i think i found a bug - i did try{eval "use foo"} and pugs exited from cmdline mode with a error instead of catching the try stuff

[11:15] <r0nny_> btw - is there a way, i can do eval<foo> "bar" intead of eval "bar", :lang<foo>

[11:17] <rafl> pugs compile error: src/Pugs/PIL2.hs: file name does not match module name `Main'

[11:17] <rafl> Can someone confirm this?

[11:17] <r0nny_> moment

[11:18] <rafl> It's a newly checked out tree.

[11:18] <rafl> From feathers svk mirror.

[11:20] <webmind> hmm, sysread is pending in  S29 ?

[11:21] <gaal> rafl: looks like a bug to me. but i'm $working so i can't look into this now. sorry :/

[11:23] <rafl> gaal: The Pipe or PIL2 storry?

[11:23] <rafl> btw: working on sunday? Poor gaal..

[11:51] <r0nny_> re

[11:51] <r0nny_> rafl: for me it works fine

[12:00] <gaal> rafl: Pipe.open ought to work IMO (I may be wrong, check with the L people...)

[12:01] <gaal> rafl: aw, not to bad: I bet you do work on Fridays :)

[12:04] <rafl> gaal: I do work once a week if I'm in mood for it. ;-)

[12:18] <autrijus> rafl: I'll look into the PIL2.hs borkage

[12:18] <autrijus> bbiab

[12:58] <svnbot6> r7870 | autrijus++ | * drift.pl - don't corrupt the PIL1.hs and PIL2.hs 

[12:58] <svnbot6> r7870 | autrijus++ |   when DrIFT is not installed.

[13:06] <rafl> autrijus: That is what made me wonder if pugs depends on drift yesterday. With drift installed it worked.

[13:10] <svnbot6> r7871 | iblech++ | * Usual svn props,

[13:10] <svnbot6> r7871 | iblech++ | * pugs::run: Documented the new names for the backends.

[13:16] <geoffb> rafl:  it seems it *did* depend on drift -- it just wasn't supposed to.  :-)

[13:18] <rafl> syntax error at util/drift.pl line 14, near "$in;"

[13:21] <svnbot6> r7872 | iblech++ | Pugs.Pretty: Correctly prettyprint one-elem-arrays (e.g. (3,) should be

[13:21] <svnbot6> r7872 | iblech++ | prettyprinted as (3,), not as (3)).

[13:56] <svnbot6> r7873 | iblech++ | * t/subroutines/loopscope.t: Added some more tests and s/"a".."c"/1..3/ (as

[13:56] <svnbot6> r7873 | iblech++ |   this test tests $_ in loops and not .. on chars (which PIL2JS doesn't support

[13:56] <svnbot6> r7873 | iblech++ |   yet)).

[13:56] <svnbot6> r7873 | iblech++ | * t/operators/reduce-metaop.t:

[13:56] <svnbot6> r7873 | iblech++ |   * Added try {...} blocks around in-PIL2JS-inflooping tests.

[13:56] <svnbot6> r7873 | iblech++ |   * Fixed the [=] test (eval_is can't find lexicals) and added some

[13:56] <svnbot6> r7873 | iblech++ |     more [=] tests.

[13:56] <svnbot6> r7873 | iblech++ | * PIL2JS: Prelude::JS::Operators:

[13:56] <svnbot6> r7873 | iblech++ |   * Unbroke [=>] -- PIL2JS's => currently captures containers, i.e.

[13:56] <svnbot6> r7873 | iblech++ |       my $pair = ($key => $val);

[13:56] <svnbot6> r7873 | iblech++ |       $pair.val = 42;

[13:57] <svnbot6> r7873 | iblech++ |       say $val;  # 42;  correct?

[13:57] <svnbot6> r7873 | iblech++ |   * Implemented [=] and [,] (with all tests passing).

[13:57] <svnbot6> r7873 | iblech++ | * New t/pugsbugs/arity-of-blocks-with-placeholders.t:

[13:57] <svnbot6> r7873 | iblech++ |   While fixing [=>], I noticed that .arity calculation with blocks with

[13:57] <svnbot6> r7873 | iblech++ |   placeholders doesn't work in all circumstances:

[13:57] <svnbot6> r7873 | iblech++ |       {          $^a,$^b          }.arity   # 2

[13:57] <svnbot6> r7873 | iblech++ |       { my $foo; $^a,$^b          }.arity   # 1!

[13:57] <svnbot6> r7873 | iblech++ |       {          $^a,$^b; my $foo }.arity   # 2

[13:57] <xerox> haha, .arity is the best.

[14:02] <Juerd> iblech: When would you want to use [,]?

[14:02] <iblech> Juerd: obfu? :)

[14:02] <Juerd> Good enoug.h

[14:02] <Juerd> s/.h/h./

[14:02] <iblech> (&prefix:«[,]» ::= &list)

[14:03] <Juerd> The list operator makes no sense. Why do we still have it?

[14:03] <xerox> What is [,] ? .-)

[14:03] <xerox> Rebuilds the list?

[14:03] <Juerd> xerox: Do you know what [+] does?

[14:03] <xerox> Yes.

[14:03] <Juerd> xerox: Then you know what [,] does.

[14:03] <xerox> Nothing, more or less.

[14:04] <iblech> TIMTOWTDI probably -- if you don't want to type ($a,$b,$c), you can type list $a,$b,$c (but yes, it's redundant)

[14:05] <iblech> xerox: Yep. Even the containers are kept -- ([,] $a,$b)[0] =:= $a is true

[14:05] <Juerd> iblech: The thing is, that in all cases where "list" actually returns a list, the entire keyword could be left out.

[14:06] <Juerd> What remains is a "list" operator that practically doesn't have anything to do with lists.

[14:06] * Juerd already knows his first Perl 6 best practice: Never use the "list" operator :)

[14:07] <iblech> Yep, but consider: my $arrayref = list $a  <=>  my $copy_of_a = $a

[14:07] <Juerd> I think the former is very bad style.

[14:07] <iblech> It's probably mostly useful in situations where you don't want to write ($single_element,)

[14:07] <Juerd> It should be: my @arrayref; @arrayref[0] := $a

[14:08] <Juerd> Which happens to be *@arrayref := $a

[14:08] <Juerd> Iff you really need this, which I think you will not, ever.

[14:10] <iblech> I used this a few times in PIL2JS's Prelude. It's important to know the differences between my $arrayref = ($a,) and $arrayref = [$a], of course (the former does not create new containers, while the latter does)

[14:12] <Juerd> Then still, "list" is obfuscation

[14:13] <Juerd> And why do you use $arrayref = ($a,) instead of *@array := $a?

[14:15] <iblech> Well, some people (wolverian?) prefer to type list $a instead of ($a,) because they don't like ($a,)'s appearance

[14:15] <iblech> Because using subroutine signatures as LHS of := is not yet implemented and because I may want to have an arrayref, not an array.

[14:16] <Juerd> Wanting a ref instead of an array is weird, in Perl 6.

[14:16] <Juerd> Because the moment you use the real array as a ref, it will behave like one.

[14:18] * Juerd thinks the documentational value of the @ is very valuable

[14:18] <svnbot6> r7874 | iblech++ | util/drift.pl: drift.pl should no longer print to STDOUT, but to @ARGV[1].

[14:19] <Juerd> And even a good reason to write "my @foo := %bar<baz>;" instead of "my $foo_ref = %bar<baz>;"

[14:20] * Juerd thinks := will be very popular

[14:29] <svnbot6> r7875 | iblech++ | t/operators/binding/{arrays.t,hashes.t}:

[14:29] <svnbot6> r7875 | iblech++ | @array := $arrayref should *not* mean @array := ($arrayref,) (as it would with

[14:29] <svnbot6> r7875 | iblech++ | normal assignment) (consider

[14:29] <svnbot6> r7875 | iblech++ |   sub foo (@array) {...}

[14:29] <svnbot6> r7875 | iblech++ |   foo $arrayref;  # internally, @array := $arrayref is called).

[14:29] <svnbot6> r7875 | iblech++ | Juerd++ for raising this topic.

[14:30] <iblech> Juerd: Obviously, I agree :)  (on := going to be very popular)

[14:33] <Juerd> And references with $ sigils not :)

[14:37] <iblech> Yep :) I think there are situations where not dereferencing refs is any(useful,more clear)

[14:37] <Juerd> Yes, but I do doubt that those are situations where you'd copy the ref.

[14:38] <Juerd> When binding, you're not really dereferencing.

[14:38] <Juerd> Or referencing.

[14:38] <Juerd> You may be changing the method of accessing the array

[14:39] <Juerd> @a := $aref doesn't really deref $aref. It's actually more like @a := @$aref

[14:39] <Juerd> It binds directly

[14:39] <Juerd> (Okay, this can be called dereferencing, of course. I should find a wider vocabulary.)

[14:40] <Juerd> I might even not be making any sense right now

[14:40] <Juerd> Forget this :)

[14:40] <wolverian> damn, Messenger sucks. it can't connect, gives a problem ID that MS's help pages don't know about. nice support there. this is what most people tolerate? sigh.

[14:41] <Juerd> It's not just what they tolerate

[14:41] <Juerd> It's what they love.

[14:41] <wolverian> I can understand that. it's purty. but tolerate as well?

[14:41] <Juerd> People love weakness.

[14:41] <Juerd> Isn't $cute := $weak, in a way?

[14:42] <Juerd> Eh, :=:

[14:42] <Juerd> Or was that =:=?

[14:42] <wolverian> right. .needs_protection ;)

[14:42] <Juerd> I keep forgetting.

[14:42] <Juerd> Right

[14:42] <iblech> Juerd: [@a := @$aref] Yep, right.

[14:42] <Juerd> Don't we all love the English language?

[14:42] <Juerd> It's fragile, makes no sense, but that's a reason in itself to keep it around.

[14:43] <Juerd> Heck, Perl 5 is as fragile as cute.

[14:43] <Juerd> We protect it and love it

[14:43] <wolverian> gaim++ # spellchecks many many languages

[14:43] <wolverian> gaim-- # the languages aren't in alphabetical order when selecting which dictionaries to install

[14:43] <Juerd> I don't get why people love Google so much

[14:44] <Juerd> Perhaps the near empty default page makes it look much more fragile than it is.

[14:44] <Juerd> "We're too poor to hire designers, so we let the techies do that kind of stuff"

[14:44] <Juerd> Sure, *we* know the techies are right, and this is a good interface.

[14:45] <Juerd> Non-geek people just find it looks silly. Yet they love it.

[14:45] <Juerd> Okay, I do get why people love Google now.

[14:48] <webmind> heh

[15:03] <theorbtwo> Eurooscon article on BBC news: http://news.bbc.co.uk/1/hi/programmes/click_online/4407742.stm.

[15:14] <Juerd> theorbtwo: Small, nitpicky advice: if you want to end your sentence properly, while the last atom is a URL, enclose it in <>

[15:20] <geoffb> theorbtwo, or just put a space before the sentence-ending punctuation . . . .

[15:30] <Juerd> autrijus: Is there any audio or a/v record of your Pugs talk?

[15:59] <r0nny_> any changes for thread primitives ?

[16:02] <Simonff> Hi - I have a Pugs install problem. Anyone online?

[16:02] <rafl> Just ask.

[16:03] <Simonff> After the Pugs compilation is done:

[16:03] <Simonff> Pugs build should not get here at ../../inc/Module/Install.pm line 29.

[16:03] <Simonff> After: cd perl5/Perl6-Container && perl Makefile.PL && /usr/bin/make

[16:03] <Simonff> This is on Fedora Core 3.

[16:04] <rafl> What revision are you using?

[16:04] <Simonff> Pugs 6.2.10

[16:05] <rafl> The release? Please try using svn HEAD.

[16:05] <Juerd> Releases are nice for changelogs

[16:05] <Juerd> They're not things you should actually use ;)

[16:06] <r0nny_> hehe

[16:06] <Simonff> I downloaded a CPAN release. Should I be using SVN?

[16:06] <Juerd> They're points in time when stuff is cleaned up, and synchronized.

[16:06] <Juerd> Simonff: Yes.

[16:06] <rafl> Juerd: If they were complete. Try to summarize some thousand commits in a few changelog lines. :-)

[16:06] <Juerd> rafl: I prefer incomplete to complete, re this.

[16:07] <Juerd> rafl: See linux kernels. Nowadays, they just dump a bunch of logs on you and call that changelog.

[16:07] <Juerd> In the 2.4 series, you'd get summaries. Comprehensible stuff, albeit incomplete.

[16:08] <rafl> Juerd: I see your point.

[16:08] <Juerd> No raise?

[16:09] <rafl> Well.. if you like it?

[16:24] <svnbot6> r7876 | liz++ | grammatical nit

[16:30] <svnbot6> r7877 | liz++ | some remarks in the article marked with (EM)

[16:36] <svnbot6> r7878 | liz++ | Added Kane and myself to AUTHORS

[16:39] <Simonff> Okay, I just tried to compile the current SVN version of Pugs. Same problem:

[16:39] <Simonff> Pugs build should not get here at ../../inc/Module/Install.pm line 29.

[16:46] <webmind> rafl, could you help me out with this debian packaging stuff I said I would do?

[16:46] <rafl> webmind: What's the problem?

[16:47] <webmind> wondering what I'd need to do 

[16:47] <webmind> don't have much experience with packaging

[16:56] <webmind> rafl, uhm -hilight- ?

[16:57] <rafl> webmind: Let me explain this tomorrow, OK? I'm kind of busy currently.

[16:58] <webmind> rafl, alright

[17:12] <svnbot6> r7879 | autrijus++ | * Empty p6 rules now raises exceptions.

[17:12] <svnbot6> r7879 | autrijus++ |   Reported by Patrick Michaud.

[17:13] <rafl> autrijus: Is there a mechanism to glue arbitrary haskell interfaces into pugs?

[17:22] <clkao> lol on the ja pugs presentation :D

[17:22] <clkao> even funnier now i can read some more japanese

[17:26] <gaal> rafl: you know about eval :lang<haskell> yes?

[17:26] <rafl> Btw: fresh debian packages for parrot and pugs every 15 mins: http://perlcabal.org/~rafl/debian/

[17:26] <rafl> gaal: Yes, but that would require to write the glue myself.

[17:27] <gaal> it's a start. :)

[17:31] <theorbtwo> Nifty, rafl!

[17:38] <rafl> gaal: I'm lame, you know? :-)

[17:48] <svnbot6> r7880 | liz++ | Braindump of coro meeting

[17:50] <wolverian> filepaths would be nice in the commit messages..

[17:52] <rafl> Yeah, like svk log -v does

[17:53] <gaal> wolverian: svn log -v. I think it's too long for pasting in the channel.

[17:55] <wolverian> hm. I mostly meant manually typing them when relevant.

[17:55] <wolverian> but that works too. thanks :)

[17:56] <gaal> ah, you mean a developer convention where people give context about what they're doing? I'm never sure if I should do that or not

[17:57] <gaal> we have trouble enough remembering the convention of prefixing things we think should go into the changelog with "* ".

[17:58] <theorbtwo> If the svnbot was smart enough, it could summerize the files that got hit, possibly.

[17:59] <gaal> how?

[17:59] <theorbtwo> Hold on a sec, let me see what a normal spread is like.

[17:59] <gaal> like logjam factors out common prefixes in journals?

[18:00] <gaal> this idea, only with paths? http://logjam.danga.com/tour/usejournal.png

[18:01] <gaal> because i don't think that'll be useful here :)

[18:01] <theorbtwo> Yes, lots like that.

[18:02] <theorbtwo> Hmm, looking at the log, it looks pretty useful ot me.

[18:03] <gaal> it must be smart enough to protect against Great Renamings where millions of files change

[18:04] <theorbtwo> Yeah.

[18:05] <theorbtwo> For that matter, to looks like many commits only hit a single *file*.

[18:05] <theorbtwo> (And a directory, for some strange reason.)

[18:06] <gaal> svn propchanges probably.

[18:12] <svnbot6> r7881 | autrijus++ | * add Allison to AUTHORS

[18:13] <svnbot6> r7882 | liz++ | Junctive Autothreading and Hyper Operations fart

[18:17] <iblech> liz6: Your last change to AUTHORS removed many people -- intentional or $EDITOR having problems with Unicode?

[18:17] <svnbot6> r7883 | iblech++ | S17draft.pod: My thoughts -- coroutine parameters should never be rebound.

[18:17] <svnbot6> r7883 | iblech++ | Instead, yield(...)s return value is an Arglist object containing the new

[18:17] <svnbot6> r7883 | iblech++ | arguments.

[18:17] <theorbtwo> Interesting idea, iblech.

[18:18] <liz6> iblech: it did?   argh

[18:19] <iblech> theorbtwo: Old discussions about coroutines on p6l wanted this too -- but at this time, Arglist didn't exist

[18:19] <theorbtwo> This is actually the first I've heard about it, but I'm quite glad it exists.

[18:19] <iblech> liz6: See http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/diff/AUTHORS?rev1=7850&rev2=7878

[18:20] <iblech> Yep, it's really great :) See t/data_types/arglist.t for examples

[18:20] <autrijus> iblech: so if you are to rebind

[18:20] <autrijus> you'll go like

[18:21] <autrijus> coro ($x) { $x := yield($x*2); $x := yield($x*3) }

[18:21] <autrijus> right?

[18:21] <autrijus> except you don't want to do that when it's not called with something

[18:21] * xerox should have done more for pugs.. :(

[18:22] <iblech> Hm, probably you'll need to splat -- $x := *yield($x*2), as otherwise $x would be bound to the Arglist object. But yes, that's the idea

[18:22] <liz6> iblech: looks more like a borked installation somehow to me...

[18:22] <autrijus> hm, I think liz6's svk copy of pugs is broken

[18:22] <svnbot6> r7884 | autrijus++ | * return() now resets the coroutine pointer, as S17 will

[18:22] <svnbot6> r7884 | autrijus++ |   very soon spec.  This makes all of t/unspecced/coro.t pass.

[18:22] <svnbot6> r7884 | autrijus++ |   (the test doesn't yet cover rebinding of arguments -- which

[18:22] <svnbot6> r7884 | autrijus++ |    will happen when you call the coro again with arguments, but

[18:22] <svnbot6> r7884 | autrijus++ |    not if you call it as a nullary -- gnomes welcome)

[18:22] <autrijus> it has old revisions of AUTHORS

[18:22] <autrijus> I'll help her fix it after dinner

[18:22] <liz6> autri: tx

[18:26] <autrijus> iblech: my idea is that a continuing coro becomes multi

[18:26] <autrijus> the argless form means continue

[18:26] <autrijus> and arful form means rebind.

[18:27] <autrijus> I think have the user manually rebind yield() will be asking a bit much

[18:27] <autrijus> but I'm being called to dinner

[18:27] <autrijus> bbiab

[18:27] <wolverian> wow, coldfusion is really bad. really really really bad.

[18:28] <iblech> Yep, but then you, as an coroutine author, can't be sure that your variables stay unchanged around yield() calls (but you know that, of course). Not sure...

[18:28] <svnbot6> r7885 | autrijus++ | * repair the AUTHORS borkedness due to corrupt svk repo

[18:30] <theorbtwo> That was a quick dinner...

[18:30] <xerox> Anybody has ACM access?

[18:47] <clkao> autrijus: what happened to her svk repo?

[18:55] <r0nny_> re

[19:18] <autrijus> iblech: actually you can easily do that

[19:18] <autrijus> coro foo ($x is copy) { ... }

[19:18] <autrijus> rebinding can't touch it then (at least we can spec it so)

[19:19] <iblech> autrijus: Ah! I'd be fine with this :)

[19:19] <autrijus> because it's like -- coro foo ($x) { my $xx = $x; ... }

[19:19] <autrijus> except implicit in the trait

[19:19] <autrijus> oh cool!

[19:19] <autrijus> liz6: add that do S17? :)

[19:20] <autrijus> s/do/to/

[19:20] <Khisanth> 3hours 20minutes to build pugs >_<

[19:20] <Khisanth> no wonder it feels like it takes a long time :P

[19:21] <autrijus> the way for "is copy" to prevent that would mean that rebinding still happens, but the rebinding takes place in an outer scope, and the "is copy" is doing a ($x = $OUTER::x)

[19:21] <autrijus> conceptually

[19:21] <iblech> yep

[19:21] <autrijus> except it's not really OUTER -- user doesn't see it

[19:21] <autrijus> so it is a bit murky

[19:22] <autrijus> you can of course do it by hand:

[19:22] <autrijus> coro foo ($x) { { $x := $OUTER::x; ... } }

[19:22] <autrijus> which would do away with an assignment

[19:25] <iblech> right.

[19:25] <autrijus> I'm not sure -- I like yield() being symmetrical but the extra shuffling care is a bit too much. I think we keep the multi idea, and let the rebinding be implemented by the postcircumfix:<()> handler

[19:25] <autrijus> and you can reasonably subclass Coro or use a trait to get different rebinding behaviour.

[19:26] <autrijus> because the same handler also controls what yield() will get back

[19:29] *** Lopo_ is now known as Lopo

[19:30] <autrijus> iblech: otherwise, how do you like the idea of explicit .start form?

[19:32] <iblech> autrijus: [subclass Coro or trait] fine with me (and note that I don't have a strong opinion on the coro stuff)

[19:33] <iblech> I like .start very much. That way you can even pass coros around to other modules in a safe way

[19:33] <autrijus> yup

[19:34] <liz6> clkao: the initial svk sync was interrupted

[19:34] <liz6> clkao: a restart after that seemed to have borked my repo

[19:35] <liz6> clkao: autri is giving me her copy

[19:37] <Juerd> liz6: What was this with Wendy calling him Audrey all of a sudden? Or did I misunderstand that?

[19:38] * Juerd hadn't asked before. Kind of forgot. "Autri" ringed a bell.

[19:38] <liz6> juerd: wasn't that "autri" ?

[19:39] <Juerd> Then I didn't hear it correctly :)

[19:39] <Juerd> I thought maybe it was referring to something that happened while I wasn't paying attention, or something like that.

[19:39] <liz6> I don't think you missed anything...

[19:40] <Juerd> Okay, then I misheard Autri as Audrey :)

[19:40] <liz6> I guess so...  ;-)

[20:05] <autrijus> iblech: oh, can you think a bit about two bad ideas of mine?

[20:05] <iblech> autrijus: sure :)

[20:06] <autrijus> class Hash { &postcircumfix:<( )> { derefing a hash } }

[20:06] <autrijus> er

[20:06] <autrijus> class Hash { &postcircumfix:<( )> { ... } }; %ENV()

[20:06] <autrijus> that's one

[20:06] <autrijus> bad idea two

[20:06] <autrijus> $x = 3;  # Scalar.new.infix:<=>(3)

[20:06] <azuroth> go go go speed racer

[20:07] <autrijus> basically, make the Assign form a meth call on container obj, and make the Apply form a meth call on code obj

[20:07] <iblech> Thought about these, too

[20:07] <iblech> Yep

[20:07] <iblech> Implementation-wise it'd be relatively easy

[20:08] <iblech> What about :=?

[20:08] <autrijus> this is so that everything is an object, for real; it also strenghtens the container/value difference

[20:08] <autrijus> you think we can pull off Arglist.infix:<:=> ?

[20:09] <iblech> I think there's a problem with making := really $lhs.infix:<:=>($rhs), as subroutines can't rebind the vars of their caller

[20:09] <iblech> i.e.:

[20:09] <autrijus> $OUTER::x := 3;

[20:09] <autrijus> why not?

[20:10] <autrijus> $CALLER::x := 3; # even

[20:10] <iblech> my $foo; sub bar ($var) { $var := $some_other_var }; bar($foo);  # $foo not rebound

[20:10] <iblech> hm

[20:10] <autrijus> er but it is not Container.infix:<:=>

[20:10] <autrijus> it's Arglist.infix:<:=>

[20:10] <autrijus> we are promoting $var into :($var)

[20:10] <autrijus> coercion, even

[20:10] <autrijus> when using :=

[20:11] <autrijus> (am I making sense?)

[20:11] <iblech> You are making sense :)

[20:11] <autrijus> good. so Arglist is like chip's PadInfo

[20:11] <autrijus> it dispatches the binding forms

[20:12] <iblech> I'd have guessed that rebinding $CALLER::x causes the binding of $CALLER::x -> caller's $x to get destroyed (similar like rebinding %hash<key>)

[20:12] <autrijus> (I thought larry called Arglist as "Signature")

[20:12] <autrijus> sure, but that's also what happens with regular $MY::x

[20:13] <autrijus> I don't know... I'm still thinking

[20:13] <autrijus> 3 := 3; # this would actually be noop

[20:13] <autrijus> right?

[20:13] <autrijus> if we are to go with arglist-coercion road

[20:13] <autrijus> because it's like saying

[20:13] <Juerd> Can an rvalue be on :='s LHS then?

[20:13] <autrijus> (sub (3) {}).(3)

[20:14] <autrijus> (sub ($ where { $_ ~~ 3 }) {}).(3)

[20:14] <autrijus> which would be noop

[20:14] <iblech> Juerd: It always could (consider @array[$idx]<key>.blarb() := $foo)

[20:14] <autrijus> I think that is too surprising :)

[20:14] <autrijus> so maybe binding is still a special form.

[20:14] <Juerd> iblech: I fail to understand this

[20:15] <autrijus> turning it into something overridable, while very "io"ish, doesn't seem to do much good

[20:15] <iblech> Juerd: := was never restricted to only take variables as LHS. You were always able to use expressions (and subroutine signatures) as LHS.

[20:15] <Juerd> Oh.

[20:15] <Juerd> Signatures I knew.

[20:15] <Juerd> But I fail to see how 5 := $foo can ever make sense.

[20:16] <autrijus> Juerd: (5) is a Signature.

[20:16] <autrijus> that means ($ where { $_ ~~ 5 })

[20:16] <Juerd> Yes, but what would the semantics of this be?

[20:16] <autrijus> multi fac (5) { 6 }

[20:16] <autrijus> multi fact ($_) { $_ * ($_-1) }

[20:16] <autrijus> er, s/fact/fac/

[20:16] <Juerd> I understand that it makes sense for pattern matching

[20:16] <Juerd> But what would it do with :=?

[20:17] <integral> throw an exception then $foo isn't 5 presumably...

[20:17] <autrijus> because supposedly, the first thing subroutine does is to run := on their Signature with their input

[20:17] <autrijus> exactly what integral said.

[20:17] <autrijus> but I also agree it doesn't seem to make much sense.

[20:17] <integral> it's the same as: sub fac (5) { 6 }

[20:17] <autrijus> which calls for the treatment that makes := a special form still, not a method on Signature.

[20:18] <integral> autrijus: "with their input" is there a function that returns this input, so one can say: (... signature here ...) := functionArgs; ?  sort of @_, but not an array

[20:18] <iblech> I agree... 3 := foo should be a compile-time error

[20:18] <Juerd> autrijus: Well, := is like argument binding for non-multi subs.

[20:18] <iblech> integral: sub foo (\$arglist) { $arglist }?

[20:19] <Juerd> autrijus: Of course, there are differences between multis and nonmultis

[20:19] <integral> o_O wow

[20:19] <iblech> autrijus: It's "Arglist" according to r6522 of S03.pod

[20:19] <autrijus> integral: it's the shiny new s03

[20:19] <autrijus> iblech: yeah, I noticed

[20:20] <autrijus> liz6: http://svn.perl.org/perl6/doc/trunk/design/syn/

[20:20] <integral> cool

[20:21] <iblech> Juerd: See docs/quickref/namespace and t/operators/binding/* for examples (of using complex things as :='s LHS)

[20:21] <autrijus> $x := 3;  # sugar for \($x) := 3 then?

[20:21] <iblech> I think so.

[20:21] <Juerd> This is what I've been waiting for. A reference to a quickref document :)

[20:21] <autrijus> and we can spec so value-based where{} forms is only recognized for subroutines

[20:21] <Juerd> Thanks :)

[20:22] <Juerd> I will have a look at the current revisions

[20:22] <autrijus> so \(3) will be utterly rejected

[20:22] <autrijus> if so, we can move back so that := becomes merely Arglist.infix:<:=>

[20:22] <autrijus> except it's not really arglist is it... it's now on the rhs

[20:23] <autrijus> er I mean lhs

[20:23] <autrijus> arglist in S03 is something that you feed to subs

[20:23] <ingy> hi autrijus 

[20:23] <autrijus> not something you read into subs

[20:23] <autrijus> Siglist?

[20:23] <iblech> Oh, right, of course.

[20:24] <autrijus> ingy: hey

[20:24] * ingy has many new and exciting projects :)

[20:24] <autrijus> ingy: eggcellent

[20:24] <autrijus> iblech: and if I remember correctly you construct them with :()

[20:25] <autrijus> so :() is sigs, and \() is args

[20:25] <iblech> autrijus: Yep, although :() was never official, was it?

[20:25] <ingy> autrijus: maybe you can teach me some new and exciting languages to program them in

[20:25] <autrijus> iblech: yeah, but I think it's starting to make more sense

[20:25] <iblech> autrijus: yep

[20:25] <autrijus> ingy: try io, maybe

[20:26] <autrijus> so \(3) makes no sense, and the only thing that makes sub (3) working is a macro

[20:26] <autrijus> that turns it into \($ where {$_~~3})

[20:27] <autrijus> and it is just for binding

[20:27] <autrijus> as assignment is handled by something else altogether

[20:28] <autrijus> ($x?, $y?) = 9; # doesn't look right anyway

[20:28] <iblech> *nod*

[20:29] <autrijus> but consider this form

[20:29] <autrijus> ($x, $y) = (1,2);

[20:30] <autrijus> is this List.infix:<=> ?

[20:30] <autrijus> (which then redistributes the args)

[20:30] <autrijus> into two Scalar.infix:<=> calls

[20:30] <autrijus> it's how it is implemented in hs runcore anyway

[20:30] <autrijus> but I think it's worth exposing to userland so user can *gasp* override them.

[20:31] <iblech> I'd think so. In current PIL2JS, it's &infix:<,> returning a magical rw proxy object

[20:31] <iblech> yep.

[20:31] * liz6 smells string obfu possibilities

[20:31] <r0nny_> hello ?

[20:32] <iblech> Should specifying Siglist objects as LHS of := be allowed? $siglist := ... would surely rebind $siglist (per the "$foo := desugaring into :($foo) :="-rule)

[20:32] <r0nny_> are conditional variables aviable ?

[20:32] <autrijus> sub List infix:<,> is assoc<list> (\$arglist) {}

[20:32] <iblech> Probably directly using a siglist as LHS is too evil

[20:32] <autrijus> :() := ...

[20:33] <autrijus> is completely fine as it does something utterly equivalent

[20:33] <autrijus> and if you want to do on $siglist you do

[20:33] <autrijus> $siglist.infix:<:=>(...)

[20:33] <autrijus> which would surely call into the siglist obj living in the $siglist Scalar.

[20:33] <iblech> Yep. But this is not specially syntax-support

[20:33] <iblech> Right.

[20:34] <autrijus> so yay, we deformed^Wreformed everything into a method call.

[20:34] <autrijus> ;)

[20:34] <iblech> :)

[20:34] <autrijus> would you have some tuits to t/unspecced/ them?

[20:34] <autrijus> that way I can focus on PIL2 and not being able to lie to myself :)

[20:34] <autrijus> and once it's reasonably working we can S03 them.

[20:35] <autrijus> (after running them thru p6l of course)

[20:35] <iblech> Not today unfortunately (school starts again tomorrow); but from Wed on, I'll probably have some free time

[20:35] <autrijus> okay, that's cool

[20:36] <iblech> yep :)

[20:37] <r0nny_> autrijus: where is a good place too look for thread-controlling stuff

[20:37] <Juerd> r0nny_: An operating system's kernel.

[20:37] <autrijus> r0nny_: you mean in current pugs? I don't know ... examples/network/http-server.p6

[20:37] <autrijus> otherwise see S17 for what will come

[20:37] <r0nny_> hmm

[20:38] <iblech> Need to go off now, bye all!

[20:39] <autrijus> iblech++ # general sanity

[20:49] <autrijus> mm svk did it to mugwump again

[20:49] <autrijus> and to svnbot6.

[20:51] <autrijus> (huge commit log generated by push)

[20:51] <mugwump> Oh, dear

[20:51] <mugwump> I'm on svk 1.05

[20:51] <autrijus> it's automatically clkao's fault, not youre

[20:52] <mugwump> can anyone svn ps --revprop it away?

[20:53] <autrijus> I can do that

[20:53] <r0nny_> DARN

[20:54] <r0nny_> S17 is basically a list of headlines

[20:57] <autrijus> mugwump: I edited revprops with vi

[20:57] <autrijus> ;)

[20:57] <autrijus> should be fine now

[20:58] <mugwump> cool

[20:59] <obra> 'afternoon

[20:59] <autrijus> yo obra.

[20:59] <mugwump> morning obra 

[20:59] <obra> how's things, guys?

[21:00] <obra> mugwump: are you in auckland, wellington or other?

[21:00] <mugwump> Wellington

[21:00] * obra nods

[21:00] <obra> sadly, not much chance of getting there when I'm in auckland in december

[21:00] <mugwump> How long are you there for?  and which dates?

[21:00] <autrijus> obra: I just consulted with iblech and we are going to make p6 very much rubyish ;)

[21:00] <obra> likely about a week over newyear

[21:00] <obra> autrijus: oh? how?

[21:01] <autrijus> (with = and := overridable by user)

[21:01] <autrijus> actually that goes beyond ruby.

[21:01] <autrijus> oh, and .() as well.

[21:01] <r0nny_> autrijus: is there any way to get more information about a thread ?

[21:02] <autrijus> r0nny_: beyong S17, not much -- detach/kill/join is all you can do at this moment with pugs

[21:02] <autrijus> you can read up on "perldoc perlthrtut"

[21:03] <obra> autrijus: have you implemented your S17 proposal?

[21:04] <mugwump> New Years is a great time to be in NZ ... lots of parties going on

[21:04] <mugwump> I'll be at rhythmandvines.co.nz ...

[21:08] <r0nny_> autrijus: what exactly does async return ?

[21:08] <liz6> r0nny: good question:

[21:08] <liz6> I think autri and I disagree on that...

[21:08] <liz6> I think it shouldn't return anything

[21:08] <liz6> if you need threads, use threads

[21:09] <liz6> in P5 ithreads, async { } is just syntactic sugar for threads->new( )

[21:09] <liz6> which I think is bad

[21:10] <r0nny_> hmm

[21:10] <r0nny_> u did "use threads;" now it complains about missing modules

[21:12] <r0nny_> works with perl5:threads

[21:12] <r0nny_> should i use it, or is it a killer ?

[21:14] <liz6> I would not recommend using P5 ithreads in any way, shape of form, really

[21:14] <liz6> well, not in production anyway

[21:15] <liz6> because it's the worst of both worlds: forking and threading

[21:17] <r0nny_> then how do i create a thread in perl6 ?

[21:18] <r0nny_> liz6: ?

[21:18] <liz6> obra: I think autri is preparing for travel early tomorrow morning (about 7 hour from now)

[21:18] <obra> no worries

[21:19] <r0nny_> and waht the hell does async return ?

[21:19] <liz6> r0nny: hmmm...  not sure at this stage of the game (I only got drafted by autri into pugs this week ;-)

[21:20] <liz6> r0nny: in P5 an instantiated threads object

[21:20] <liz6> which you can later use to do a join() on

[21:20] <r0nny_> any propper thread stuff ?

[21:21] <liz6> r0nny: no idea, as I said, please try

[21:22] <r0nny_> odd

[21:23] <r0nny_> async returns a thread

[21:24] <r0nny_> hmm

[21:24] <SamB> r0nny_: that doesn't sound particularly odd to me...

[21:25] <r0nny_> but there is no meta method

[21:27] <autrijus> liz6: ping

[21:27] <autrijus> liz6: turns out I've written something to explain the coro too, so if it makes sense, maybe work it in

[21:27] <liz6> autri: pong

[21:27] <r0nny_> coro ?

[21:27] <liz6> coroutine

[21:28] <obra> how close is S17 to "ready for review"?

[21:28] <autrijus> obra: another 10hr or so

[21:28] <obra> :)

[21:28] <autrijus> (of raw work, not of wallclock)

[21:28] <r0nny_> cool :)

[21:28] <autrijus> liz6: http://use.perl.org/~autrijus/journal/27490

[21:29] <autrijus> I'm still writing it, but thought the coro part may be of use

[21:29] <r0nny_> autrijus: why does the meta method fail on Thread ?

[21:30] * obra wonders how hard the parrot threading spec will be after this

[21:32] <autrijus> r0nny_: I'm quite sure .meta is waiting on MM/PIL2 :)

[21:33] <r0nny_> so .meta isnt implemented ?

[21:33] <autrijus> no it is not.

[21:33] <r0nny_> hmm

[21:34] <r0nny_> guess now all my reasons to stay awake are gone

[21:35] <autrijus> good night :)

[21:35] <obra> autrijus: where to next?

[21:35] <autrijus> obra: helsinki, to visit aevil+jhi

[21:35] <autrijus> then after a day, taipei

[21:37] <obra> nice.

[21:37] <obra> .oO {Are you talking to jhi about 6pan or unicode?}

[21:40] <liz6> obra: I think autri mentioned 6pan

[21:40] <autrijus> 6pan mostly, I think, as I think unicode is pretty well understood

[21:42] <obra> *nod*

[21:42] <obra> though I bet he has nice cautionary tales ;)

[21:46] <autrijus> very dense braindump journal finished -- hopefully still making some sort of sense

[21:46] <autrijus> shower &

[21:55] <dduncan> ... dainbramaged

[21:57] <liz6> dduncan: after a while you don't feel it anymore... ;-)

[21:58] <dduncan> I wasn't talking about anyone in particular ... seeing the word 'brain' reminded me of that word ...

[21:59] <liz6> I guess we should refer to it as "drainbump" then?

[22:00] <autrijus> paindumbr

[22:00] <dduncan> more fitting in this situation

[22:01] <dduncan> rong

[22:01] <dduncan> anyway, I'm starting to read the latest journals now

[22:03] <dduncan> on a separate note, my first relational database on pugs will be 'Native', a pure perl reference implementation of the Rosetta API that supports all of its features, but with the conscious decision to save on complexity by allowing it to be slow ...

[22:04] <dduncan> correct but slow ...

[22:05] <dduncan> this exists mainly to help guide the re-plan of the API and help test it, as well as have *something* working on Pugs, but isn't intended for heavy duty use

[22:06] <obra> using your DBI port?

[22:06] <dduncan> it will be slow mainly because it will maintain the whole database in memory and write it all to disk on a commit, rather than just the changed parts, so it will only perform reasonably on small data sets

[22:07] <dduncan> fyi, I am doing both at once

[22:07] <obra> but could be fast if you made flushing optional?

[22:07] <r0nny_> dduncan: what exactly is the Rosetta api ?

[22:07] <dduncan> saving it to disk will be optional

[22:07] <dduncan> it is essentially an in-memory database that can optionally be saved to disk as well

[22:08] <dduncan> the saving is necessary to be ACID compliant ... when a commit returns without error, you know the data is saved

[22:08] <dduncan> the in memory only version would be more as scratch space for an app, not persistant storage

[22:09] <dduncan> using this will loosely resemble using SQLite, but it will implement features that SQLite doesn't, and SQLite is fast

[22:09] <dduncan> the whole db is in a single on disk file that can be stored anywhere

[22:09] <obra> why not just implement an SQLite binding?

[22:09] <dduncan> I will do that later ...

[22:10] <dduncan> I'm doing my own first because I want to have a solid testing example for Rosetta, and SQLite doesn't support a number of its important features

[22:10] <obra> Rather: Implementing your own database seems like a possibly painful operation that could be short-circuited.

[22:10] <obra> what's SQLite missing that rosetta needs?

[22:10] <dduncan> it would only be painful if I tried to make it fast

[22:10] <obra> (Or DBD::mysqlPP)

[22:10] <obra> is there already an SQL parser in perl6?

[22:11] <dduncan> one key difference is that no SQL strings have to be involved in the backend

[22:11] <dduncan> Rosetta natively takes an AST, and my db would natively use that

[22:11] <dduncan> no work in generating SQL to be parsed again

[22:11] <obra> ah

[22:11] <r0nny_> so Rosetta is basically like CDBI, just __more__ sweet ?

[22:12] <dduncan> also, the same SQL::Routine that is used to store the AST when an app builds SQL statements can be used to natively store my db's schema

[22:13] <dduncan> my db will support multiple schemas in a db, tables, foreign keys, views, stored routines ... SQLite doesn't support native updateable views or most stored routines

[22:14] <dduncan> despite appearances, I think that this will actually be quite easy

[22:14] <obra>  That would be really cool

[22:15] <dduncan> I will follow the SQLite model of having only one writer to the db at once, which has exclusive access, but there can be multiple readers

[22:15] <dduncan> all transactions have serialized concurrency

[22:15] <dduncan> also for simplicity

[22:15] <obra> will the writer's locking be opportunistic or will it have to explicitly relinquish control?

[22:15] <dduncan> the bottom line is ...

[22:15] * liz6 wonders how Rosetta could fit in with "is atomic" functionality

[22:16] <dduncan> the bottom line is that, it is easier for me to conceptualize an API if the database testing it works in exactly the same way, rather than my having to mess around with my mind about how various dbs act differently and how to compensate

[22:16] <dduncan> remember that my db is just a reference implementation, so I only care about correctness, not speed

[22:17] <dduncan> though it will still be designed efficiently within certain bounds

[22:17] <dduncan> liz6, in answer to your question ...

[22:18] <dduncan> assuming the normal case of a database stored on disk, so it is persistant ...

[22:18] <dduncan> it will all be stored in a single file, and the operating system's ordinary file locking mechanism will govern access ...

[22:18] <liz6> dduncan: ah, ok...

[22:19] <dduncan> when a process starts a transaction that wants to write, it will block until it can get an exclusive lock

[22:19] <liz6> it's just that "is atomic" functionality has a lot in common with commit/rollback functionality

[22:19] <dduncan> it will then perform, in memory, the steps of the transaction

[22:20] <dduncan> on a rollback, the file is reread into memory, overwriting any changes

[22:20] <dduncan> or, on a commit, the changes are written into the file

[22:20] <dduncan> to deal with interruuptions ...

[22:21] <dduncan> before writing any changes to the file, a copy of the pristine file will be made on disk first under a known file name, and synced

[22:21] <dduncan> then the changes will be written to the original file, and synced

[22:21] <dduncan> then the copy will be deleted

[22:21] <liz6> well, for a reference implementation of "is atomic" that might make sense...  

[22:22] <liz6> but maybe just serialization would also do the trick...

[22:22] <r0nny_> so its basically not thread-save, and emulates this by big locks ?

[22:22] <dduncan> what I mentioned is meant to guard against power outages or OS failures or program crash

[22:23] <dduncan> to save on complexity, the whole db is locked at once, not just the smaller parts ... that's also what SQLite does

[22:23] <obra> you really want your reference implementation of a DB API to be clogged with this stuff?

[22:23] <dduncan> threading is a separate issue

[22:23] <obra> I can see that as a great 2.0 feature

[22:24] <dduncan> I consider ACID to be a fundamental feature

[22:24] <dduncan> of a database

[22:24] <dduncan> if its supposed to be reliable

[22:24] <r0nny_> as ling as it cant deal with threads correct, it wont be used for heavy load parralel stuff

[22:24] <r0nny_> ACID ?

[22:24] <dduncan> well, this reference is for the API, its not actually meant to be used in production

[22:25] <dduncan> ACID is an acronym that essentially means 'reliable' ...

[22:25] <dduncan> if a database is ACID compliant, it guarantees certain features ...

[22:25] <r0nny_> hmm

[22:26] <dduncan> 1. either all parts of a transaction succeed or none of it has any effect

[22:26] <liz6> http://en.wikipedia.org/wiki/ACID

[22:26] <r0nny_> well - i hope your api wont break if real multithreading is introduced

[22:26] <obra> it sounds like you have conflicting goals, darren.

[22:26] <dduncan> I'll consider threads to be the thing I put off for version 2

[22:26] <obra> 1) clean API to implement against 

[22:26] <obra> 2) full ACID compliance

[22:27] <obra> 3) quick to implement and easy to understand

[22:27] <dduncan> this is accomplished partly by sacrificing speed and non-serialized concurrency

[22:27] <dduncan> and multi-threading

[22:28] <dduncan> I consider this database to be a test for Rosetta, to help hash it out, as Pugs is a test for Perl 6

[22:28] <r0nny_> btw - u could save the entire db by using the perl method, and reload it by using eval

[22:28] <dduncan> I was going to

[22:29] <obra> oh. I thought it was a test for DBI6

[22:29] <dduncan> part of the simplicity is that the file will simply be a text file containing perl code, that when evaluated produced the original data structure

[22:29] <r0nny_> hmm

[22:29] <liz6> dduncan: so how different is that from Storable?

[22:29] <dduncan> simpler

[22:30] <liz6> like Data::Dumper?

[22:30] <r0nny_> well - not so sweet formated

[22:30] <dduncan> said perl code will just be a single hash declaration, whose elements are whatever

[22:30] <dduncan> no mention of objects or anything complex

[22:30] <dduncan> just a hash of arrays of ...

[22:30] <liz6> ah, ok

[22:30] <r0nny_> hmm

[22:30] <r0nny_> btw - how does the perl method deal with cyclic stuff

[22:30] <dduncan> fyi, the older SQL::Routine can already serialize itself in that manner, in only about 10 lines of code

[22:31] <theorbtwo> ?eval $a = []; $a[0] = $a; $a

[22:31] <evalbot_7889> Error: Undeclared variable: "$a" 

[22:31] <mugwump> pixie is very similar to that, dduncan 

[22:31] <theorbtwo> ?eval my $a = []; $a[0] = $a; $a

[22:31] <evalbot_7889> [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[

[22:31] <dduncan> the perl objects will first "serialize" themselves into plain perl structures, hashes of arrays etc, and from that the perl code is generated

[22:31] <theorbtwo> r0: Not very well.

[22:31] <dduncan> SQL::Routine already does this too

[22:31] <dduncan> see ...

[22:32] <mugwump> also, if you extend the concept to have "mementos", and lazy loading, then you have pixie

[22:32] <mugwump> which is a bit like MLDBM, but allowing nodes to store other nodes

[22:32] <r0nny_> i think i found a bug

[22:33] <r0nny_> the perl method cant deal with cyclic data

[22:33] <dduncan> see the get_all_properties_as_perl_str() function on CPAN, and the 2-3 utility functions it uses

[22:33] <dduncan> in SQL::Routine

[22:33] <dduncan> it breaks all the cycles

[22:34] <dduncan> get_all_properties() is the core, spitting out a cycle-broken hash-of-arrays

[22:34] <dduncan> the other func wraps that and is like perl()

[22:34] <dduncan> the output of the first can be fed right back into build_container() to recreate everything

[22:35] <r0nny_> well - i wish someone could write a data-serialisation/deserialisation framework wich deals with all this stuff

[22:35] <dduncan> that already works in my pre-rewrite version ... the new one will be similar

[22:35] <dduncan> the cycle breaking is built into the object because it knows best about how to do it for its own circumstances

[22:36] <dduncan> the actual serializing could be farmed out, but I didn't at the time

[22:37] * r0nny_ requests a Data::Dumper and Data::Reader can do perl code, yaml, xml, and some other stuff

[22:37] <dduncan> question ... when people say they want DBI in Perl 6, what do they *actually* want?

[22:37] <r0nny_> who knows

[22:38] <r0nny_> guess they want enought, to keep theis scripts working, and easy ported

[22:38] <dduncan> as far as I'm concerned, if I get Rosetta working and people can access databases with it (besides my test impl) then their needs have been met

[22:38] <dduncan> and a DBI-emulating wrapper over Rosetta is already part of its roadmap

[22:38] <r0nny_> darn

[22:38] <dduncan> for those older scripts

[22:38] <liz6> dduncan: to an extent, that's true

[22:39] <dduncan> and Rosetta is sort of a DBI-v2 in design

[22:39] <r0nny_> the.perl method is allready lost on simple cycles, but in complex ones

[22:39] <dduncan> it may not look it, but you should be able to use it much the same way as DBI

[22:39] <liz6> but I think a lot of people would just want to be able to access their data in existing tables, e.g. in MySQL or PostgreSQL

[22:39] <dduncan> its overall design is the same ... common front end with connection handles and statement handles, and multiple specialized backends

[22:40] <dduncan> the basics like, "just get that data" will be among the first things implemented

[22:40] <dduncan> the only main prerequisite is the ability to connect to the database, over which connection other stuff happens

[22:41] <dduncan> to talk to SQLite in Pugs, we need to be able to invoke its C library API

[22:41] <dduncan> to talk to MySQL or Postgres, we either need to talk to their client C library API, or code a network client in Perl

[22:42] <dduncan> to do either will take a bit of time

[22:42] <liz6> isn't there a pure perl implementation of DBD::mysql ?

[22:43] <dduncan> that's written in perl 5, and has several other perl 5 modules as dependencies

[22:43] <dduncan> all would need to be ported or rewritten

[22:43] <dduncan> if you just want a "get the data", all that really needs porting is "Net::MySQL"

[22:43] <dduncan> but that is more like the MySQL native API and not the DBI API

[22:44] <mugwump> The first thing I want to see is pictures of the data model used for schemas, tables, expressions, etc.

[22:44] <dduncan> that will be forthcoming

[22:45] <dduncan> SQL::Routine::Language and friends define version 1, and the rewritten version I'm doing now will be loosely similar

[22:46] <dduncan> essentially, a catalog has zero or more schemas, has zero or more of any of: tables, views, procedures ...

[22:46] * liz6 is calling it a day...

[22:46] <dduncan> domains, sequences ...

[22:47] <dduncan> the API of a table and a view are both defined by a row, which is an associative array of names and data types

[22:47] <dduncan> a table has one column for each row field

[22:47] <dduncan> a table also has constraints on it, such as not null, unique value, foreign key

[22:48] <mugwump> great.  draw it up in Umbrello

[22:48] <mugwump> It should be very close to the first thing people see when they look at the framework ... it will explain so much, so quickly.

[22:49] <obra> Umbrello?

[22:49] <dduncan> yes indeed

[22:49] <dduncan> I assume its like what Autrijus uses for his pictures

[22:49] <mugwump> well, umbrello is specifically a UML modeller

[22:49] <mugwump> it's not the best CASE tool on the planet, but it is better than dia when it comes to drawing UML diagrams

[22:49] <dduncan> I can make something similar in ASCII or a drawing program as a first draft

[22:50] <mugwump> start with dia or umbrello, you'll save yourself a lot of pain.

[22:50] <dduncan> I don't have any specific uml programs

[22:50] <dduncan> but if they're free for mac os x, I can look ...

[22:51] <mugwump> should be.  dia runs standalone, umbrello is kde

[22:51] <dduncan> I don't have kde installed

[22:51] <dduncan> in any event, it will take a few days before I come back with this

[22:56] <dduncan> on a side note, an official DBIv2 is being hashed out among the usual people ... I'm focusing on Rosetta first partly because it implements a number of features I'd like to see in the actual DBIv2 ... and my implementation will let people actually see the suggestions in action before they commit to them ... also, who knows how long they will take, and meanwhile my doing this will put some functionality on Pugs "now"

[23:30] <eric256> rafl: around?

