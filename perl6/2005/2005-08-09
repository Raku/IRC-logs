[00:05] <dduncan> fyi, Darren_Duncan is now dduncan by default, to be nicer to those on 80 character IRC clients

[00:06] <hobbs> nicks over 9 chars long are heretical! ;)

[00:06] <dduncan> well then, consider me saved!

[00:07] <dduncan> seen the light, etc ...

[00:08] <dduncan> autrijus, is it practical or possible to change my Pugs committer name likewise?

[00:08] <dduncan> or don't worry about it

[00:33] <stevan> dduncan: the pugs commiter name is the same name as the openfoundry user. You could try to change that in the user admin, however, the solution might be to get a new user account on openfoundry. However the problem with that is that open foundry keys user accounts by email address, so you would also need to change that. In other words, it may not be a trivial task.

[00:34] <dduncan> okay then, no need to change anything

[00:45] <stevan> dudley: if you want to work on the Java version go right ahead

[00:45] * stevan is backlogging sorry :)

[00:45] <stevan> dudley: I would use the Javascript version as a guide, I tried to mirror them both

[00:45] <stevan> dudley: there is also an ANT build.xml file which runs the JUnit test suite and can do coverage with EMMA

[00:46] <stevan> however, you need to have both the Junit and EMMA jars in your path (obvviously)

[00:46] <stevan> if you want I can email the jars to you, just email me at stevan at iinteractive.com and I will send them on over

[00:56] <dudley> stevan: What's EMMA

[00:56] <dudley> ?

[00:57] <dudley> dduncan: autrijus had me sign up as a new user, then just gave that new user the committer bit. So I guess I have two openfoundry names now.

[00:58] <dduncan> I C

[00:58] <dudley> Three, if you count my daughter, who got the committer bit for her 0th birthday ;-)

[00:58] <dduncan> how'd you swing that?

[00:59] <dudley> I announced here that my wife was going into labor, then when we got back, someone asked if the new baby was a committer yet...

[01:01] <dudley> ahh, code coverage. I'll check that out.

[01:02] <dudley> stevan: I'm going to port the javascript straight across at first. It makes for some ugly Java code, but I'll straighten that out eventually.

[01:03] <dudley> biab

[01:14] <iblech> stevan: Hm, will Perl6.MetaModel support multisubs eventually?

[01:14] <iblech> Or are multisubs considered not to be part of the metamodel?

[01:46] <stevan> dudley: Java is always a little ugly :) you cannot avoid it 

[01:46] <stevan> iblech: re: multisubs and the metamodel

[01:47] <stevan> 1) I dont really have enough knowledge of the inner workings of subroutines and MMD in particular to really do justice to the idea

[01:47] <stevan> 2) I assumed that multi-methods would be built upon multi-subs, which I don't see as the responsibilty of the metamodel

[01:48] <stevan> and since p5 and JS did not have multi-subs, or formal parameters for that matter I punted 

[01:48] <iblech> 1) Neither do I, that's the problem :)

[01:48] <stevan> LOL

[01:49] <iblech> Idea...:

[01:49] <stevan> iblech: Punt and let autijust do it

[01:49] <iblech> Someone writes the MMD dispatching code in Perl 6

[01:49] <iblech> And we can compile it to JS and P5 then :)

[01:49] <iblech> Right :)

[01:49] <stevan> nice

[01:49] <stevan> iblech: have you seen luqui's Class::MultiMethods::Pure?

[01:49] <iblech> I've read the docs, but not more

[01:50] <stevan> 3) they havent settled on the dispatch semantics of MMD anyway

[01:50] <stevan> iblech: personally I like the CLOS generic function idea

[01:50] <stevan> it is very clean

[01:50] <stevan> but unfortunately it is not appropriate to Perl 6 OO

[01:51] <stevan> iblech: have you implemented multi-subs?

[01:51] <stevan> in PIL2JS?

[01:52] <iblech> No. Additionally, -CPIL doesn't give my any sub definitions for multi subs

[01:52] <stevan> ah,.. then it's autrijus's fault anyway :)

[01:53] <iblech> Good :)

[01:53] <stevan> iblech: how has the integration of methods gone?

[01:53] <stevan> how are you handling that?

[01:54] <iblech> method foo (Foo $self: ...) is compiled to sub foo (Foo $self, ...); PIL2JS.addmethod(::Foo, &foo)

[01:55] <iblech> Then the metamodel knows about the "foo" method of Foo

[01:55] <iblech> And calls are dispatched accordingly then

[01:55] <stevan> nice

[01:55] <stevan> so are you using the Perl6.Method class still?

[01:56] <iblech> Yep.

[01:56] <stevan> hmm

[01:56] <iblech> But I could do without it

[01:56] <stevan> then we could possible hack together multi-methods if you want

[01:56] <iblech> oooh

[01:56] <stevan> here is my thought

[01:57] * iblech listens

[01:57] <stevan> 1) we alter the metamodel such that if it gets a method of the same name, it checks to see if that method is a multi-method

[01:57] <stevan> because currently it just allows it to overwrite

[01:57] <stevan> 2) we create a multi-method class

[01:57] <stevan> and put all the glue in

[01:58] <stevan> then as far as the dispatch is concerned

[01:58] <stevan> we punt on the details

[01:58] <stevan> and just hack together something simple for now

[01:59] <stevan> as long as the dispatch code is in it's own method, it should be able to be replaced easily

[01:59] <stevan> I can try to hack this into the JS metamodel if you want to try?

[01:59] <iblech> Excellent.

[02:00] <iblech> :)

[02:00] <stevan> it wont be pretty :)

[02:00] <iblech> But we won't be able to test it from PIL2JS, because of the -CPIL problem

[02:00] <iblech> Sure :)

[02:00] <stevan> iblech: so -CPIL does not handle it at all?

[02:01] <iblech> Reusing the code for multisubs would be simple, too

[02:01] <iblech> Right, try pugs -CPIL -we 'multi foo (Str $a) {}; multi foo (Num $a) {}'

[02:02] <iblech> (No "foo" in the output)

[02:02] <iblech> But that's probably easy to fix in Pugs.Compile

[02:03] <stevan> iblech: all I got was 

[02:03] <stevan> PIL_Environment

[02:03] <stevan>     { pilMain = ((PStmts PNoop PNil))

[02:03] <stevan>     , pilGlob = ([(PSub "&*END" SubPrim [] PNil )])

[02:03] <stevan>     }

[02:03] <iblech> Right.

[02:03] <iblech> No &foo.

[02:03] <stevan> yeah, what happened?

[02:03] <iblech> dunno, ask autrijus :)

[02:04] <stevan> did it croak on the duplicate name?

[02:04] <stevan> ah

[02:04] <stevan> I see, multi is not understood maybe?

[02:05] <iblech> It seems so. Probably (but I haven't looked at the source), &foo is internally a list of subs, and -CPIL doesn't know how to compile a list of subs

[02:06] <stevan> iblech: yes,... hmmm

[02:06] <stevan> where is that autrijus when you need him :P

[02:06] <iblech> :)

[02:07] <stevan> iblech: well I will hack together a skeleton for mutlimethods anyway

[02:07] <stevan> however, I will caveat it with the fact I have no real idea what I am doing :)

[02:08] <iblech> Thanks :)

[02:08] <iblech> We'll just ask Damian or Luke to give us appropriate JS code :D

[02:08] <stevan> :)

[02:09] <stevan> whoever gives us the code first, wins

[02:09] <iblech> Right :)

[02:09] <stevan> if you look at t/80_Code.t in the p5 mm there is some basic multi-sub code

[02:10] <stevan> but it only dispatches on the number of params

[02:11] <iblech> Hm, this is enough to get Test::skip working :)

[02:12] <stevan> ok

[02:12] <stevan> I should have a rough sketch of the code in a few minutes

[02:13] <iblech> :)

[02:13] <iblech> stevan++ # fast :)

[02:13] <stevan> not really fast, just porting the perl 5 code :)

[02:13] <iblech> :) cheater :D

[02:14] <stevan> uh oh

[02:15] <stevan> I need to be able to check the num of params in the function signature

[02:15] <stevan> can I do that with PILJS?

[02:15] <stevan> where should I look for that

[02:15] <iblech> You can (&foo.arity), but the problem is:

[02:16] <iblech> The metamodel doesn't really get the actual boxed Function object, but only methods which, when invoked, return that object

[02:16] <iblech> But I could simply give you the arity as a parameter

[02:18] <iblech> (That's because you're able to rebind &subs, and it'll be even more important when I've finished my full-continuations-in-JS patch...)

[02:18] <stevan> so something like:

[02:18] <stevan> Perl6.MultiMethod.prototype.call = function (arity, inv, args)

[02:18] <iblech> Will work

[02:19] <stevan> wait, that wont work with the code I am writing though

[02:19] <stevan> I have a list of method objects

[02:19] <stevan> and I need to check the arity on them

[02:19] <iblech> Oh, right.

[02:19] <stevan> and match it against the length of args

[02:20] <iblech> Then I'll pass the arity to new Perl6.Method(...)?

[02:20] <stevan> ok

[02:21] <brentdax> Continuations in Javascript?

[02:22] <iblech> Right. Instead of emitting say(foo(), bar()), I emit foo(-> $a { bar(-> $b { say $a, $b }) }), basically

[02:22] <iblech> call/cc is then trivial

[02:22] <stevan> so iblech will you pass the arity to the Perl6.Method constructor?

[02:22] <iblech> And it'll allow me to add support for coroutines, gather/take, and &sleep

[02:23] <brentdax> Awesome.  Scary, but awesome.

[02:23] <iblech> stevan: new Perl6.Method(associated_cls, function (...) {...}, arity)?

[02:23] <stevan> iblech: nice, that way I can test it too :)

[02:24] <stevan> ok, give me a little more than 5 minutes on this one then :P

[02:24] <iblech> stevan: Great :)

[02:24] <iblech> :D

[02:24] <stevan> I have to write new code

[02:27] <stevan> iblech: is the inv included in the arity?

[02:27] <iblech> It is. Should I -1?

[02:27] <stevan> no

[02:27] <iblech> ok

[02:28] <stevan> I will include it in the calculations :)

[02:28] <stevan> ok, questions.

[02:28] <stevan> should methods be declared multi?

[02:29] <stevan> or should trying to add a method of the same name automagically make it multi

[02:29] <iblech> It's probably to cleaner to demand a multi declaration

[02:29] <stevan> I am leaning towards the first one right now

[02:30] <stevan> ok

[02:30] <stevan> well actually the metaclass wont care

[02:30] <stevan> polymorphism++

[02:31] <stevan> Perl6.Class is the only place I have to address it

[02:36] <iblech> Hmm... Seems "use YAML; warn Dump($self->[PIL::CC])" modifies $self

[02:37] <iblech> (WTF?)

[02:38] <iblech> Seems a bare "$self;" does too

[02:38] <iblech> Apparently a bug in perl5

[02:47] <stevan> iblech: hmmm, it seems arity is already a property of function objects, so i am renaming for now

[02:47] <stevan> oh wait

[02:47] <stevan> sorry my bad,.. no need

[02:48] <iblech> FWIW, all PIL2JS subs have a JS-arity of 1 (always "args", like Perl 5's @_)

[02:49] <stevan> ok, well we are future proofing it :)

[02:49] <stevan> for when PIL handles them correctly too

[02:58] <autrijus> greetings.

[03:00] * autrijus backlogeth

[03:00] <mugwump> hi there ... wow, my work queue is empty at new jobs already

[03:00] <stevan> hola autrijus 

[03:00] <iblech> Hi :)

[03:00] <mugwump> s/new jobs/new job/

[03:00] <autrijus> hey stevan, iblech.

[03:00] <autrijus> I dreamed of TSa last night.

[03:01] <autrijus> more precisely, at his seemingly completely insane reply to my container thread.

[03:01] <autrijus> and truth emerges: he is actually making sense.

[03:01] <autrijus> I wonder if it means I can read deeper than the surface, _or_ I'm insane.

[03:02] <autrijus> so I'd like to check with you a bit :)

[03:02] <stevan> I am not sure if iblech and myself are the high watermarks of sanity

[03:02] <stevan> mugwump either :)

[03:03] <stevan> but go ahead and try 

[03:03] <autrijus> consider %h.kv and $s.method

[03:03] <autrijus> intuitively there's a difference

[03:03] <autrijus> .kv is acting on the container, and .method is acting on the object obtained by .FETCH on the container.

[03:03] <autrijus> so far so good?

[03:03] <stevan> yes

[03:03] <iblech> In PIL2JS, .kv is actually acting on the .FETCH of the container, too (a PIL2JS.Hash object)

[03:03] <wolverian> oh, why can't everything just be objects! or lists! :)

[03:03] * mugwump nods hesitantly

[03:04] <autrijus> iblech: aha. how about @ary.end ?

[03:04] <autrijus> is that acting on a FETCH'ed list also?

[03:04] <iblech> Yep.

[03:05] <autrijus> can %h contain anything else than the same Hash object?

[03:06] <iblech> what same Hash object?

[03:06] <autrijus> also, what's stopping $s from storing a Hash object, then?

[03:06] <autrijus> er, I mean

[03:06] <iblech> PIL2JS.Box.prototype.STORE is auto-reffing such cases

[03:06] <autrijus> my %h = (1=>2); %h = ();

[03:07] <autrijus> is %h storing the same Hash object, only with different content?

[03:07] <iblech> Ah. No, in current PIL2JS, %h stores a new PIL2JS.Hash object then

[03:08] <autrijus> you know... I like your treatment better :)

[03:08] <autrijus> iblech++ # sanity

[03:08] <iblech> :)

[03:08] <autrijus> the model I was about to say

[03:08] <autrijus> is that "Scalar of Any" has an AUTHMETH that redispatches all unhandled methods to its FETCH.

[03:09] <autrijus> whilst Array and Hash does not do such thing.

[03:09] <autrijus> so for $s, it handles .tie, .tied, := etc

[03:09] <autrijus> but .method gets redispatched.

[03:09] <mugwump> I'm really confused here.  I know I've been out of the loop for a bit, but I don't understand why tie can't be implemented in terms of Proxy objects...

[03:10] <autrijus> mugwump: tie %h, 'DB_File';

[03:10] <autrijus> mugwump: try rewrite it using proxy object?

[03:10] <autrijus> iblech: also, how do you handle (%h := %g) then

[03:11] <autrijus> iblech: does that mean they share a Box?

[03:11] <iblech> %h := %g is exactly like $a := $b

[03:11] <mugwump> can %h not get reblessed into the DB_File class?

[03:11] <iblech> I.e. .STORE, .FETCH, and .BINDTO are copied

[03:12] * mugwump hmms

[03:12] <iblech> autrijus: Why should Array and Hash not also redispatch?

[03:12] <autrijus> iblech: @ary.foomethod

[03:12] <autrijus> iblech: if Array does not handle foomethod

[03:13] <autrijus> what should it redispatch to?

[03:13] <iblech> Ah, of course. Was mixing up Perl 6/PIL2JS

[03:13] <autrijus> mugwump: also note that when you tie(%h), then untie(%h) , original content of %h needs to prevail.

[03:14] <mugwump> but wasn't "tie" always a hack, anyway?  I thought that the only required goal of tie-like functions was to be able to make objects that behave like instrinsic types

[03:14] <autrijus> mugwump: yeah, you're talking about killing tie, and I'm okay with that proposal

[03:15] <autrijus> mugwump: but the spec says tie stays, so I need to find a way to implement it.

[03:15] <autrijus> mugwump: the "tie should die" proposal belongs elsewhere :)

[03:16] <autrijus> iblech: so, look at http://pugscode.org/images/container.png for a second

[03:16] * mugwump sends his comment "We're supposed to be leaving legacy behind in Perl 6" elsewhere

[03:16] <wolverian> mugwump, that would be perl6-language

[03:16] <wolverian> I'll post my "rename 'grep' to something even vaguely resembling English" post too, then :)

[03:16] <autrijus> iblech: my initial thought is that $s.foo is dispatched first to the Cell

[03:17] <autrijus> iblech: which is exposed as surface class Scalar and Scalar::Const

[03:17] <autrijus> iblech: then if it does not handle .foo, its AUTOMETH redispatch it to the "Scalar Value" slot.

[03:18] <autrijus> iblech: and in array's case, exactly the same thing applies, except there is no "array value" to dispatch to -- they are separate containers.

[03:18] <autrijus> "they" == "the items"

[03:18] <autrijus> iblech: your PIL2JS Box 's fetch looks like the Container-Cell fetch

[03:18] <iblech> Sounds sane.

[03:18] <mugwump> "Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time tie statement unless the variable is explicitly declared with an implementation type that does the Tieable role.

[03:18] <autrijus> not the Cell-Value fetch I was talking aboutl

[03:18] <mugwump> - S06

[03:18] <iblech> Yep.

[03:19] <autrijus> mugwump: right, that.

[03:19] <autrijus> iblech: good. so if we hav

[03:20] <autrijus> Array does Cell; Scalar does Cell; Hash does Cell;

[03:20] <autrijus> (the "cell" name is throwaway temporary hypothetical device)

[03:20] <autrijus> iblech: then we can rule that Ref always hold a Cell

[03:21] <autrijus> and enreference will promost anything not a cell into an appropriate cell -- that is, plural value into Array and other values into Scalar.

[03:22] <iblech> What about \%hash?

[03:22] <autrijus> iblech: so if you reopen the Scalar class to add new methods, it effectively intercepts its content's method. also "implementation class" are merely new Scalar Cell types beyond the default mutable and immutable cells.

[03:22] <autrijus> iblech: \%hash takes a Hash, Hash does Cell, it holds a Cell, no autoenreference happens

[03:22] <iblech> Ok.

[03:23] <autrijus> as a direct result, what we used to call "lvalue" now actually means "Cell"

[03:23] <autrijus> and the reason that

[03:23] <iblech> Right, makes sense.

[03:23] <autrijus> 4 = 5

[03:23] <autrijus> does not work, is because 4 does not typecheck.

[03:24] <autrijus> and I think that's what TSa was getting at.

[03:25] <stevan> iblech: your JS multi-methods are in r6125

[03:25] <svnbot6> r6125 | Stevan++ | Perl6.MetaModel - (JS)

[03:25] <svnbot6> r6125 | Stevan++ | * adding very very primative MultiMethods

[03:25] <svnbot6> r6125 | Stevan++ |    - added tests file for them

[03:25] <svnbot6> r6125 | Stevan++ | * added multi-method support to Perl6.Class

[03:25] <svnbot6> r6125 | Stevan++ |    - added a test for this as well

[03:25] <stevan> as promised they are not pretty :)

[03:25] <iblech> oooh :)

[03:25] <iblech> stevan++

[03:25] <iblech> stevan++

[03:25] <iblech> stevan++

[03:25] <autrijus> oh, what about PIL not dumping multimethods?

[03:25] <stevan> iblech: it basically takes an array of Perl6.Method objects

[03:25] <hobbs> so you guys are responsible for the massively inflated karma on perlbot

[03:25] <stevan> and based on their arity, it dispatches

[03:26] <stevan> hobbs++ # yes :)

[03:26] <spinclad> well, svnbot does most of the dirty work, but yeah

[03:26] <autrijus> iblech: Compile.hs line 152, extend it to handle non-singular list contents, that's all

[03:27] <autrijus> iblech: should be straightforward as it already allows multiple returns

[03:27] <stevan> oh autrijus, I was talking to matts about doing a port of DBIx::Class to perl 6

[03:27] <stevan> and generating the classes with the metamodel

[03:27] <iblech> autrijus: Simple :) Will do that tomorrow then

[03:27] <autrijus> ooh. bridging it on perl5:DBI ?

[03:28] <autrijus> iblech++ # cool

[03:28] <stevan> autrijus: probably yes

[03:28] <stevan> I wont be able to start on it until mid-sept

[03:28] <iblech> But I *really* need to sleep now. (05:28 AM here)

[03:28] <autrijus> stevan: cool

[03:28] <iblech> Night all :)

[03:28] <autrijus> iblech: go sleep you crazy diamond

[03:28] <iblech> :D

[03:28] <stevan> nite iblech, I hope you dream of container types too

[03:28] <autrijus> *wave*

[03:29] <stevan> autrijus: I figure too that you will have the metamodel in by then

[03:29] <autrijus> stevan: yeah, that sounds likely

[03:29] <autrijus> I'll go out and grab some food. be back in a bit

[03:29] <stevan> I am also working on documenting the meta object protocol (not sure if you saw the backlog)

[03:29] <autrijus> no, will backlog further

[03:29] <autrijus> I look forward to more Visio time :)

[03:30] <stevan> see docs/S12.5.pod in the metamodel

[03:30] <stevan> it is just a start

[03:30] <stevan> however, I need to sleep soon as well, nite &

[03:31] <spinclad> it sounds like you're extending the MM to meta-calling (MMD and such)

[03:32] <spinclad> which i think is excellent and needed.

[03:34] * dudley tries to resist the urge to give up on java and learn scala....

[03:35] <autrijus> dudley: that will do you good :)

[03:35] <autrijus> Scala and Nice are both very nice.

[03:35] <SamB> it would be a shame if nice was not nice

[03:35] <dudley> yeah, but I'm working on the java port of the metamodel. Changing horses in midstream and all that.

[03:35] <spinclad> stevan++;  iblech++ # CPS in JS

[03:38] * spinclad puts down pompoms for the night

[03:40] <SamB> riding horses through rivers sounds odd enough to start with!

[03:42] <Khisanth> eh?

[03:42] <Khisanth> oh dudley's statement :)

[03:45] <dudley> Ok, that's enough for one day. Goodnight all.

[03:45] <dudley> sleep &

[05:49] <dduncan> for those of you interested in Perl 5 stuff that will shortly be translated ... I would like to announce that http://svn.utsl.gen.nz/trunk/Rosetta/ is now fully up to date with Rosetta's current state of being as of r724; however, that is a snapshot and fails a test; r724 is good to study, but r723 passes all tests ... and so, any future commits have brand new stuff

[05:49] <svnbot6> r6126 | Stevan++ | Perl6::MetaModel - (p5)

[05:49] <svnbot6> r6126 | Stevan++ | * added ::get_P6opaque_instance_data to centralize p6opaque information

[05:49] <svnbot6> r6126 | Stevan++ |    - changed all files which accessed data directly to use this function

[05:49] <svnbot6> r6126 | Stevan++ | * moved some things around in Perl6::Class to facilitate the name lookup 

[05:49] <svnbot6> r6126 | Stevan++ |   refactoring. It is getting there, but not quite done yet. 

[10:12] <geoffb> Wheeee

[10:12] * geoffb feels like he got run over by a conference or something

[10:12] <geoffb> . . . but I just finished the last of my OSCON blogs, so I'm happy.

[10:13] <geoffb> And maybe tomorrow I can come back to the fun here in Pugsland.

[10:16] <geoffb> Mighty quiet around these parts.

[10:16] <geoffb> Ah well, I'll come back and visit sometime when the sun is on my side of the planet again.   :-)

[10:16] <geoffb> g'night, all.

[10:17] <castaway_> night geoff :)

[10:44] * autrijus purrs

[10:44] <autrijus> I did a lot of PIL2 design on paper today

[10:44] * autrijus finally got network back

[10:44] <autrijus> will start hacking :)

[10:53] <castaway_> grats autrijus !

[10:54] *** castaway_ is now known as castaway

[10:54] <kgftr|konobi> castaway: lo... how's it going?

[10:54] <jdv79> is the "paper" available?

[11:03] <castaway> hey

[11:03] <castaway> not bad, coming together, I think :)

[11:04] <autrijus> jdv79: available as dead trees

[11:04] <autrijus> I'm coding them down

[11:05] <jdv79> oh, you meant _real_ paper:)  my mistake.

[11:05] <autrijus> :)

[11:06] <autrijus> I'm targetting a reduced set of perl6 currently

[11:06] <autrijus> just for experimenting with the new type-directed compilation and PIL2

[11:08] <castaway> .oO( people still write on paper? what a concept .)

[11:08] <autrijus> I went out of battery ;)

[11:09] <autrijus> ok, I'll go offline now... can't code with IRC window on

[11:09] * autrijus waves &

[11:10] <castaway> later a*

[11:39] <svnbot6> r6127 | autrijus++ | * beginning of a separate PIL2 repl loop, in PIL.hs.

[11:39] <svnbot6> r6128 | autrijus++ | * oops, it now compiles. next up: "print 1" in the grand

[11:39] <svnbot6> r6128 | autrijus++ |   Punie tradition!

[11:39] <coral> Punie?

[11:40] <coral> or dvorak

[11:40] * coral &

[11:45] <integral> coral: punie == perl1 on parrot

[11:45] <QtPlatypus> Punie is Perl1 on Parrot.  The first test was "print 1"

[11:50] <autrijus> right, and the only running test.

[11:51] <autrijus> "print 10" would fail, for example :)

[11:51] <Whitesocks> I want to send the command "ls -l" to the perl open command from a apache web server... but when i type "ls+-l" in the browser, the "+" doesnt get exchanged for a space..... why?

[11:51] <integral> Whitesocks: the perl6 open command?

[11:51] <autrijus> Whitesocks: I suggest #perl

[11:52] <Whitesocks> Ok thanks. :)

[11:52] <autrijus> :)

[11:52] * autrijus mumbles something about rm+-rf.

[11:53] <nothingmuch> rm -rf is the roxor

[11:54] <QtPlatypus> Perhaps we should put something in the topic about it not being a channel for perl5 questions.

[11:54] <nothingmuch> it fixes all those stupid alias rm="rm -i" entries

[11:54] * integral thought the 6 in the name was a giveaway

[11:54] <nothingmuch> QtPlatypus: i don't think it's worth that much... we don't get them too often

[11:55] <QtPlatypus> I've seen about one question per week.

[11:55] <QtPlatypus> Your right that isn't two much.

[11:55] <svnbot6> r6129 | autrijus++ | * the runM monad for generic monad translation

[11:58] *** xinming_xchat is now known as xinming

[12:01] <autrijus> hm.

[12:01] <autrijus> class Foo { method f (Str $x --> Int) {} )

[12:01] <autrijus> class Bar is Foo { method f (Int $x, Int $y --> Str) {} }

[12:01] <autrijus> should such things be tolerated?

[12:01] <autrijus> also: 

[12:02] <autrijus> my &f := sub (Str $x --> Int) {}; &f := sub (Int $x, Int $y --> Str) {};

[12:02] <autrijus> also:

[12:02] <autrijus> my Int $f; $f := "string!";

[12:02] <autrijus> they are similar but not exactly the same. thinking about how far we should go on those.

[12:04] <QtPlatypus> First shouldn't be permitted unless multimethods 

[12:04] <QtPlatypus> THe frist shouldn be permitted unless there muliti methods?

[12:05] <QtPlatypus> On the other hand you might wish to overwrite methods, which should also be permitted.

[12:05] <autrijus> the thing is that each of those disables a form of early binding.

[12:06] <autrijus> I'm pretty sure you can't say you "does" a role but does not have a compatible interface.

[12:06] <autrijus> that's the thing that makes

[12:06] <autrijus> role Coercable { method coerce:<as> (::t --> t) { ... } }

[12:06] <autrijus> work.

[12:07] <QtPlatypus> Isn't that why we have "is final"?

[12:07] <autrijus> there is no "is final".

[12:07] <autrijus> check again?

[12:07] <autrijus> (we have "use optimize :classes<final>")

[12:07] <autrijus> but that's not the same.

[12:08] * autrijus ponders some more.

[12:22] <masak> are tests marked "todo" given as much attention as failing tests?

[12:22] <autrijus> no.

[12:23] <autrijus> I look at :todo<bug> from time to time

[12:23] <autrijus> but most :todo<feature> will probably only be fulfilled in the new runcore.

[12:23] <masak> it was mostly the :todo<bug> ones i meant

[12:24] <autrijus> oh. then, still not

[12:24] <masak> that's too bad

[12:24] <autrijus> :todo<bug> means they are confirmed bugs

[12:24] <autrijus> failing tests are untriaged

[12:24] <autrijus> and triaging needs to happen before bugfix

[12:24] <autrijus> so it makes sense to pay more attention to them :)

[12:25] <masak> i suddenly realised that i expect bugs to be fixed by themselves

[12:25] <masak> that's an unreasonable expectation

[12:25] <autrijus> indeed :)

[12:26] <autrijus> I mean, eventually, sure

[12:26] <masak> i just wish there was more i could do to fix *my* bugs :)

[12:26] <autrijus> but if you put any time frame on it, then it's less certain.

[12:26] <autrijus> soon, soon. :)

[12:26] <autrijus> (assuming you feel more proficient hacking perl6 than haskell)

[12:26] <masak> i think i do

[12:26] <autrijus> good then.

[12:27] <masak> neither very much, but still, perl6 i sorta understand

[12:29] <autrijus> *nod*

[12:31] <scook0> bah, in one day everything I think I know about the metamodel gets turned upside-down :(

[12:32] <autrijus> scook0: hmm?

[12:32] <scook0> stevan's comments on p6l

[12:33] <nothingmuch> g/qui

[12:33] <scook0> I thought I understood it

[12:34] <scook0> then he says something like "the Class object will be invocant of all the class methods", and I realise I must be totally off

[12:34] <scook0> perhaps someone needs to convince stevan to draw some pretty diagrams :)

[12:34] <autrijus> or I should draw one for you

[12:34] <autrijus> I have half-finished ones.

[12:35] <autrijus> but I'm compelled to make "print 1" work now :)

[12:35] <scook0> yeah, I heard--I shall gleefully examine your latest PIL work...

[12:36] <autrijus> scook0: it's based on type-directed translation

[12:36] <autrijus> for once

[12:36] <autrijus> for example, when it sees

[12:36] <autrijus> print 1

[12:36] <autrijus> then it compiles to

[12:36] <autrijus> &print(&coerce:<as>(1 as Int, Str as Type) as Str) as Bool

[12:36] <jdv79> i thought what is now called Object was going to be called MetaMetaClass

[12:37] <autrijus> scook0: and

[12:37] <autrijus> print $_

[12:37] <autrijus> &print(&coerce:<as>(&Scalar::FETCH($_ as Scalar of Any) as Any) as Str) as Bool

[12:37] <autrijus> the FETCH is inserted by coercing (Scalar of Any) to (Any) via a compile time binding

[12:38] <autrijus> but maybeit should be overridable as a  coerce:<as> form as well.

[12:38] <autrijus> dependent types are so much fun.

[12:39] <masak> that's something you don't here every day

[12:39] <scook0> autrijus: I'm not sure I understood any of what you said, so I'll just peer at the code for now

[12:39] <masak> s"here"hear"

[12:39] <autrijus> scook0: ok :)

[12:40] <scook0> hmm, is there any way to tell GHC to use /less/ memory?

[12:40] <scook0> even 'make unoptimised' locks up my system with thrashing :(

[12:40] <autrijus> allocate less heap?

[12:40] <autrijus> scook0: oh, you can do the easy thing

[12:40] <autrijus> edit config.yml

[12:41] <autrijus> turn off precompile prelude

[12:41] <scook0> done (thanks)

[12:41] <scook0> not that I really run pugs much

[12:42] <scook0> I mostly just recompile to make sure Haddock doesn't screw up

[12:42] <Daniel_Nee> Hi, Autrijus: Could you come in tomorrow afternoon around 1:00 PM and we'll go to nanshan to continue the UAT ?

[12:42] <autrijus> Daniel_Nee: hey, I already replied your mail

[12:43] <autrijus> Daniel_Nee: also if you look at the bottom of your chatzilla screen there should be a red "autrijus" button -- pressing it and you'll see a private message from me, and we can talk in that window in private, too :)

[12:44] * autrijus praises the amazing protocol that is irc.

[12:47] <autrijus> Aankhen``: hey

[12:50] <Aankhen``> Hiya.

[12:50] <Aankhen``> And bye-a.  I can't stay. :-\

[12:50] <Aankhen``> Will be back later.

[12:50] <autrijus> ciao :)

[12:50] <autrijus> bbiab too &

[14:11] <fglock> ping

[14:11] <autrijus> pong.

[14:13] <fglock> ping

[14:13] <autrijus> pong.

[14:13] <fglock> hi! I'm reading the metamodel - I can't find 'List' there

[14:14] <fglock> maybe i'm in the wrong directory

[14:14] <autrijus> hm?

[14:14] <autrijus> List?

[14:15] <fglock> There is an Array.pm - is there a List.pm?

[14:15] <fglock> under "Container"

[14:15] <autrijus> I don't think so, currently

[14:15] <autrijus> list is a value type

[14:15] <autrijus> not a container type

[14:15] <autrijus> and I don't think the p5 metamodel deals with value types yet

[14:17] <fglock> i've got Lazy lists ready, i think

[14:17] <svnbot6> r6130 | autrijus++ | * layout for the new stuff -- "make pil" launches into ghci

[14:17] <svnbot6> r6130 | autrijus++ |   for PIL.hs.  This is strictly temporary.

[14:17] <svnbot6> r6131 | fglock++ | * Array::Lazy - code cleanup

[14:17] <svnbot6> r6132 | autrijus++ | * split into "make pil" and "pili"

[14:17] <svnbot6> r6133 | autrijus++ | * preliminary checkin for literal parsing.

[14:17] <svnbot6> r6134 | autrijus++ | * "print 1" is parsed... how very exciting :)

[14:19] <autrijus> fglock: yay. porting it to p5 if you have the tuits? :D

[14:19] <autrijus> I'll integrate it to the runtime when I get around to the Plural handling.

[14:20] <fglock> do you mean - using coroutines?

[14:23] <autrijus> fglock: yes.

[14:23] <autrijus> you can fake coros with an extra callback sub param

[14:23] <autrijus> the same way as ruby does

[14:23] <autrijus> or you can ues the more expensive Coro.pm

[14:25] <fglock> I started implementing using callbacks - then I changed to coro. but I think it can work both ways.

[14:25] <fglock> even a Sub with a state variable would do

[14:26] <fglock> how about "Perl6::List"

[14:28] <autrijus> I'd prefer Perl6::Runtime::List or Perl6::Val::List

[14:28] <autrijus> just so we don't conflict massively with other cpan things

[14:28] <autrijus> or Perl6::Pugs::List

[14:28] <autrijus> ;)

[14:29] <autrijus> I think Perl6::Value::List can work.

[14:30] * Arathorn crawls in from the cold

[14:31] <fglock> ok - Perl6::Value::List. should it use 'shift' or 'SHIFT'?

[14:32] <autrijus> you mean the method? call it shift, I don't think it'd hurt

[14:33] <fglock> I'll work on it in the afternoon. Going for lunch now :)

[14:35] <autrijus> fglock++

[14:40] <stevan> fglock: anything in the metamodel under ::Container should be probably ignored 

[14:40] <svnbot6> r6135 | autrijus++ | * beginning of compilation

[14:40] <svnbot6> r6136 | autrijus++ | * rename PIL.Syn to PIL.Exp

[14:40] <svnbot6> r6137 | autrijus++ | * finishing up the rename.

[14:40] <stevan> morning all :)

[14:41] <dudley> Morning

[14:41] <stevan> I am responding to TSa on p6l, I have a feeling the cyclical nature of the metamodel will not sit well in his clean Type DAG world

[14:41] <QtPlatypus> Good evening

[14:41] <stevan> morning dudley, evening QtPlatypus  :)

[14:42] <stevan> s/Type/Type model/

[14:43] <pasteling> "Stevan" at 67.186.136.119 pasted "MetaModel cycles" (16 lines, 328B) at http://sial.org/pbot/12335

[14:44] <stevan> I made him a pretty picture though :)

[14:46] <castaway> pretty pictures++

[14:54] <Arathorn> hrm, my pine mutilates the pretty pictures :(

[14:58] <stevan> Arathorn: see the nopaste above

[14:58] * Arathorn has found the H button to get pine to display rawtext sensibly :)

[14:58] <Arathorn> but thanks

[15:03] *** autark is now known as jp-autark

[15:07] <QtPlatypus> autrijus: Will PIL2 contain PPos infomation.  And if so what do you expect it to look like?

[15:13] <autrijus> QtPlatypus: question 1 is yes

[15:14] <autrijus> I think the current line/col range is good enough

[15:14] <autrijus> I'll probably put file into another form

[15:14] <autrijus> and you can deduce your file and line/colrange by looking outward and find first one of each kind

[15:14] <autrijus> does that sound ok?

[15:14] <autrijus> yay, the skeleton is done

[15:15] <svnbot6> r6138 | autrijus++ | * rather improbably, "print 1" works, so does "say 123", as well

[15:15] <svnbot6> r6138 | autrijus++ |   as "say say say 123".

[15:15] <autrijus> I can focus on type directed translation now.

[15:15] * QtPlatypus nods

[15:15] * autrijus continues to sail on this Heart of Gold thing

[15:16] <QtPlatypus> So I'm guessing its a psydo funtion wrapped around the code?

[15:17] <autrijus> it's not pseudo function...

[15:18] <autrijus> but rather each node can be annotated with one or more positions

[15:18] <autrijus> something like

[15:18] <autrijus> data PIL = Pos PIL | ...

[15:18] <autrijus> or rather

[15:18] <autrijus> data PIL = Pos Pos PIL | ...

[15:18] <QtPlatypus> How are thouse annotations serilized?

[15:18] <autrijus> and it has type a :: a

[15:18] <autrijus> for example, say you have

[15:18] <autrijus> Lit (Single (Int 3))

[15:19] <autrijus> then the annotated form is

[15:19] <autrijus> Pos somePos (Lit (Single (Int 3)))

[15:19] <autrijus> where somePos is some position information.

[15:19] <autrijus> I think I'll move the main part on the left

[15:19] <autrijus> so it's

[15:19] <autrijus> Pos (Lit (Single (Int 3))) somePos

[15:20] <autrijus> i.e. exactly the same way current Exp and PIL handle things.

[15:20] * QtPlatypus nods

[15:20] <autrijus> an alternative is have each node carry a position optionally

[15:20] <autrijus> but then I can't easily "peel them" away

[15:20] <autrijus> so probably not.

[15:20] <autrijus> peek (Pos x _) = x

[15:20] <autrijus> er

[15:20] <autrijus> peel (Pos x _) = x

[15:21] <autrijus> peel x = x

[15:21] <autrijus> done

[15:21] <QtPlatypus> thanks

[15:21] <autrijus> and it fusions as well, so if all is in haskell, then those position slots are not filled in the first place

[15:21] <autrijus> since their evaluation never triggers

[15:21] <autrijus> so we don't get much speed penalty

[15:23] * QtPlatypus thought that PIL2 was going to look like flattened p6?

[15:23] <autrijus> the prettified form, surely.

[15:24] <autrijus> maybe it'll be littered with #line -- I mean #file -- directives if you want them.

[15:24] * QtPlatypus nods and can work with that

[15:26] * QtPlatypus beds &

[15:27] * autrijus purrs

[15:37] <fglock> ping

[15:37] <autrijus> pong

[15:38] <fglock> hi autrijus - I need to define 'Inf' in perl5. Is Perl6::Value::Scalar a good place?

[15:39] <autrijus> Perl6::Value::Num actually.

[15:39] <autrijus> Scalar is container, Num is contained

[15:39] <autrijus> but you can get inf in perl5 using 9**9**9

[15:39] <autrijus> but otoh, you can't call .. on it.

[15:39] <autrijus> so it's up to you :)

[15:39] <autrijus> for the value type names, please follow the new PIL runcore

[15:40] <autrijus> http://svn.openfoundry.org/pugs/src/PIL/Val.hs

[15:40] <autrijus> Int Int | Num Num | Str Str | Ref Ref | Bit Bit

[15:41] <autrijus> (they should inherit from the common abstract "Single" class.)

[15:42] <autrijus> and List should inherif from "Plural", but you don't need to worry about that yet.

[15:42] <autrijus> it'll all become Visiolized :)

[15:42] <autrijus> visiolization++

[15:43] <fglock> where can i get the operator names (the "List API")

[15:43] <fglock> like "..", comma, etc

[15:45] <fglock> i've got a solution for detecting "end of list", when the list contains "undef"

[15:46] <fglock> "List" can have the "elems" operator. It returns Inf until the list finishes, and then return "0"

[15:46] <autrijus> cool.

[15:47] <autrijus> that sounds nice

[15:47] <autrijus> I don't think there is a canonical API.

[15:47] <autrijus> you can grep List in src/Pugs/Prim.hs

[15:47] <autrijus> to get some idea of that

[15:48] <autrijus> if you come up with one and it works well

[15:48] <autrijus> it will likely become the canonical api.

[15:52] <fglock> when I cast a List to a Num - is it a $list.to_num() operation or a Num.from_list( $list ) ? I hope the question makes sense

[15:52] <autrijus> perl6 uses coerce:<as>

[15:53] <autrijus> so it is to, not from

[15:53] <autrijus> otoh, you can define MMD forms from it

[15:53] <autrijus> so it can potentially be both

[15:53] <autrijus> but never only from.

[15:54] <autrijus> also, you're doing the one-level-below runtime class

[15:54] <autrijus> so you can use any API you like

[15:54] <autrijus> it's the job of the inferencer to pick the correct coercion form, and the code generator to call your runtime class.

[15:54] <Aankhen``> Hi.

[15:54] <fglock> Hi Aankhen

[15:55] <autrijus> but to make things tidier, to_num sounds fine certainly, although you may or may not want use overload.

[15:55] <Aankhen``> Heya fglock. :-)

[15:55] <autrijus> i.e. overload 0+ => \&to_num

[15:55] <autrijus> (hopefully I'm still making sense)

[15:55] * Aankhen`` wonders how to create a class that functions as an array, with the right sigil, et al.

[15:56] <fglock> sure - I'm trying to find out what is the minimum API.

[15:56] <fglock> Aankhen - me too :)

[15:56] <autrijus> Aankhen``: class MyArray does Array { ... }; my @x is MyArray;

[15:56] <autrijus> Aankhen``: will work, does not yet :)

[15:56] <Aankhen``> autrijus: What about if I want to be able to say: my @foo = MyArray.new();

[15:56] <Aankhen``> Will that work too?

[16:00] <fglock> Aankhen: I think it should work, but you are copying the data from your new array into @foo, and throwing it away, I think

[16:00] <autrijus> Aankhen``: I don't think that works. := works.

[16:00] <Aankhen``> OK.

[16:01] <Aankhen``> And if I just say `class MyArray does Array { ... }`, MyArray automatically knows to return an array?

[16:03] <autrijus> er, that's what does means.

[16:03] <autrijus> if you think about it a bit :)

[16:03] <autrijus> liskov and all that.

[16:04] <Aankhen``> I try not to think about it; it hurts my head.

[16:04] <Aankhen``> My understanding of `does` was always that it's simply a way to manage code reuse.  Didn't think it would alter the `new` method.

[16:05] <autrijus> er, "does" means

[16:05] <autrijus> whatever you retur

[16:05] <autrijus> n

[16:05] <autrijus> you agree to conform to the Array API in full.

[16:05] <autrijus> so it's "as good as" Array.

[16:05] <fglock> can "does" be tested with "isa"? (I think I tried it before and it didn't work)

[16:05] <autrijus> no. "isa" manages implementation reuse

[16:05] <autrijus> "does" manages interface reuse.

[16:06] <autrijus> (broadly speaking, that is.)

[16:06] <Aankhen``> Ah, I see.

[16:06] <Aankhen``> "Does" that extend to other roles as well?

[16:07] <autrijus> sure.

[16:08] <xinming> is the the only difference between "say" and "print" is say will add a "\n" to the result. but not print?

[16:10] <autrijus> xinming: yes.

[16:10] <autrijus> in other languages it's be the different betweehn putStr and putStrLn, or print and println, or write and writeln.

[16:11] <autrijus> but @Larry reasoned that the "ln" form is actually more common

[16:11] <autrijus> and hence should be shorter.

[16:11] <autrijus> it's called the principle of huffman encoding

[16:11] <autrijus> er, Huffman coding.

[16:12] <Aankhen``> So are roles only supposed to be interfaces?

[16:12] <osfameron> given how much we talk about Huffman coding, should we Huffman code it to somethign shorter?

[16:13] <autrijus> osfameron: I don't think that comes often enough nowadays, and "huffman" would suffice :)

[16:14] <autrijus> Aankhen``: they may contain implementation code as a "default case". but it's not reuse -- it's copied straight into the "does" consumer.

[16:14] <autrijus> well, it's reuse, but not inheritance, sorry.

[16:14] <autrijus> so you don't get to call SUPER.

[16:14] <Aankhen``> Ah.

[16:14] <autrijus> there's no SUPER for roles.

[16:14] <Aankhen``> Well, thanks for the explanation(s). :-)

[16:14] <autrijus> so you can't post/pre process the super methods.

[16:14] <autrijus> if you'd like to do that, roles isn't for you.

[16:14] <autrijus> np :)

[16:15] <Aankhen``> class MyClass does Hash does Array { ... }; MyClass.new() # what type of object?

[16:15] <autrijus> MyClass of course.

[16:15] <Aankhen``> Er, right.

[16:15] <autrijus> :)

[16:15] <Aankhen``> What sigil?

[16:15] <autrijus> both.

[16:15] <autrijus> my @x is MyClass; (fine)

[16:15] <autrijus> my %x is MyClass; (fine too)

[16:16] <autrijus> this is not entirely unlike in perl5 you can tie hash and array to the same class.

[16:16] <Aankhen``> And `my $x is MyClass` becomes a regular opaque object?

[16:16] <autrijus> er, no, it will complain that MyClass doesn't do Scalar, or something like that.

[16:16] <autrijus> my MyClass $x

[16:16] <autrijus> is what you want.

[16:16] <Aankhen``> Ah, right.

[16:16] <autrijus> shorthand of "my $x returns MyClass" or "my $x of MyClass".

[16:17] <Aankhen``> That's equivalent to `my $x of MyClass`, right?

[16:17] <Aankhen``> OK.

[16:17] <autrijus> :)

[16:17] * Aankhen`` boggles at the thought of an instant HashArray class.

[16:17] * autrijus notes you can do that in perl5 with three ways already.

[16:17] <Aankhen``> In one line

[16:17] <Aankhen``> ?

[16:17] <autrijus> sure!

[16:18] <Aankhen``> That is to say, one semi-colon terminated statement?

[16:18] <autrijus> sure!

[16:18] <Aankhen``> Wow.

[16:18] <Aankhen``> I've never come across anything of the sort.

[16:18] <Aankhen``> My life has been wasted.

[16:18] <Aankhen``> :-\

[16:19] <autrijus> use overload ('@{}' => sub { [] }, '%{}' => sub { {} }); 

[16:19] <autrijus> that's one way

[16:19] <autrijus> *TIEARRAY = *TIEHASH = *FETCH = *STORE = ... = sub { ... };

[16:19] <autrijus> that's another

[16:19] <autrijus> [{}]

[16:20] <autrijus> is the third (deprecated) way.

[16:20] <autrijus> perl6 doesn't really add many runtime features

[16:20] <autrijus> but it made it much more reasonable and cleaner.

[16:20] <Aankhen``> Looks like it.

[16:20] <autrijus> (it does add a _lot_ of compile time features though.)

[16:22] <Aankhen``> my HashArray %hasharray = (a => 'b', c => 'd'); %hasharray[0] # == 'b'?

[16:23] <Aankhen``> # given a `class HashArray does Hash does Array`, that is.

[16:23] <autrijus> my %hasharray is HashArray

[16:23] <Aankhen``> Ah, right, my bad.

[16:23] <autrijus> your form has it containing HashArray elements.

[16:23] <Aankhen``> That's going to come back to bite me.

[16:23] <Aankhen``> Again and again and again.

[16:23] <autrijus> :)

[16:23] <autrijus> I blame it to @Larry.

[16:23] <autrijus> different things made similar.

[16:24] <Aankhen``> Ah, I personally blame it on my sudden bursts of thick-skull-itis.

[16:24] <autrijus> I contend that %hasharray[0] still won't work. :)

[16:24] <autrijus> as the sigil rules over the interface

[16:24] <autrijus> so your Array side of methods did not get recognized

[16:24] <autrijus> by the inferencer.

[16:24] <autrijus> but, if you get a p6l ruling

[16:24] <autrijus> I can think of ways to implement that :)

[16:24] <Aankhen``> So if I want to provide both interfaces, do I use `my $x of HashArray`?

[16:25] <SamB> you silly person! never blame thick-skull-itis! software should be designed to relieve it!

[16:25] <autrijus> yes, that would work.

[16:25] <Aankhen``> Cool.

[16:25] * autrijus looks SamB strangely

[16:25] <Aankhen``> SamB: Oh yeah. Sorry. Must have been the thick-sk-- er, nevermind.

[16:26] <Aankhen``> Anyway, time for din-din.

[16:26] <Aankhen``> BBIAB.

[16:26] <Aankhen``> &

[16:26] <autrijus> :)

[16:26] * autrijus starts journaling

[16:26] <fglock> I'm writing the file Perl6/Value/List.pm - is it ok to say 'package List' instead of 'package Perl6::Value::List' ?

[16:26] <autrijus> fglock: well, I definitely prefer the later

[16:26] <fglock> ok

[16:26] <autrijus> you can set up local aliases like

[16:27] <autrijus> my $List = __PACKAGE__;

[16:27] <autrijus> or something like that :)

[16:27] <xinming> Perl 6 is going to confuse more people then ever. :-)

[16:27] <autrijus> xinming: that is just following the grand tradition of perl5.

[16:30] <PerlJam> As long as perl6 doesn't cause too much confusion about basic things (or what programmers think of as basic (like the type system))

[16:32] <autrijus> indeed.

[16:32] <autrijus> the type system is perhaps the most significant new semantics over perl5.

[16:34] <PerlJam> new semantics == good

[16:34] <autrijus> just like haskell is pronounced "world's finest imperative language" after it got monads, maybe perl6 can evolve to be the world's finest static language.

[16:34] <PerlJam> new confusing semantics == bad

[16:34] <autrijus> verily.

[16:35] <PerlJam> I would be shocked if perl6 became the world's finest static language.

[16:35] <PerlJam> (but in a good way)

[16:36] <xinming> I agree with autrijus, Perl 6 will be. :-)

[16:36] <autrijus> it's pretty tough with grand prior arts like O'Caml, but one can certainly try :)

[16:40] * fglock is finding it hard to write Perl5 after a month doing only Perl6

[16:41] <PerlJam> fglock: I've stopped writing perl6 for a while actually.  It was affecting my ability to write perl5 for work.

[16:41] <fglock> i'm too slow :)

[16:43] <PerlJam> when I went to explain something to a co-worker and wrote a perl6 solution without thinking, I realized a few things:  1) perl6 will be great once it's ready for prime time  2) a perl6 solution in a house of perl5 isn't too productive and 3) more perl6 would only make me wish for it  hard enough to hurt myself  :)

[16:44] <Aankhen``> Heh.

[16:44] <Aankhen``> I wub Perl 6.

[16:45] <Aankhen``> Or rather, I wub that subset of it which I can understand.

[16:46] <Aankhen``> Oh dear... the Empire Earth II demo is mad at me for not playing it since I installed it.  I better go.

[16:46] <xinming>  while =$*IN -> $line {...} ,What does the equal sign mean here please?

[16:46] <brentdax> Unary equals is the iteration operator.

[16:46] <brentdax> (Like the old <blah>, but more general.)

[16:47] <fglock> it is just like 'shift'

[16:47] <autrijus> PerlJam: your experience is a prime example of why compiling perl6 to perl5 is The Way Forward :)

[16:47] <autrijus> fglock: actually it's like "a lot of shift"

[16:48] <autrijus> xinming: and that should read

[16:48] <autrijus> for =$*IN -> $line { ... }

[16:48] <PerlJam> autrijus: "a lot of lazy shift"

[16:48] <autrijus> PerlJam: right.

[16:48] <autrijus> "a lot of shift, lazily"

[16:48] <fglock> "lazy list constructor"

[16:48] <autrijus> decomposer, actually

[16:49] <autrijus> the $*IN is the constructor

[16:49] <autrijus> or is it called "generator / consumer"

[16:49] <xinming> :-S

[16:49] <xinming> hard to understand for me. :'(

[16:50] <PerlJam> xinming: why? What's confusing?

[16:50] <autrijus> xinming: ok. $IN is this object that was called STDIN

[16:50] <autrijus> xinming: and prefix = replaces <>

[16:50] <autrijus> and for replaces while :)

[16:51] <autrijus> xinming: in perl5 you could also say

[16:51] <autrijus> for my $line (<STDIN>) {...}

[16:51] <autrijus> except it will wait until EOF

[16:51] <autrijus> but in perl6, it will eventually read one line at a time.

[16:52] <fglock> is there a place under pugs/ for Perl6::* modules? or do they go straight to CPAN?

[16:52] <autrijus> "eventually" = as soon as I port fglock's implentatino over.

[16:52] <autrijus> fglock: yes, put them under perl5/

[16:52] <autrijus> fglock: once they work coherently, they will go straight to CPAN as Perl6::Runtime or something like that.

[16:52] <autrijus> before that, put it under its own perl5/ subproject.

[16:53] * autrijus can't wait to use Perl6::Runtime at $work.

[16:54] <xinming> autrijus: go on please. 

[16:54] <autrijus> xinming: ok... the idea is that =$IN is like <$IN>

[16:54] <autrijus> except that the list is not evaluated all at once

[16:55] <autrijus> but rather only at the time it is bound to something, like $line

[16:55] <autrijus> so the net effect is that it reads one extra line when the loop runs next

[16:56] <autrijus> note that this does not describe the current pugs

[16:56] <autrijus> which has no support for lazy arrays

[16:56] <autrijus> but we're -- actually fglock is -- working on that :)

[16:57] <xinming> Ok, Then, for Every Array, eval qq{ my $t = (1..8); for =$*t -> $_ { $_.say }; } means the value(not values) in the anonymous list is calculated every time reached for, right?

[16:58] <autrijus> assuming that array does iterator

[16:58] <xinming> Sorry for my poor English. :-)

[16:58] <autrijus> and assuming you wrote q{} instead of qq{}

[16:59] <autrijus> that's fine :)

[16:59] <autrijus> and assuming you wrote $t instead of $*t

[16:59] <autrijus> then yes, 2 is evaluated after 1 is printed.

[16:59] <autrijus> so you could have written 1..Inf

[16:59] <autrijus> and get a lot of strings on your screen

[16:59] <autrijus> instead of like in perl5 where it plain dies.

[17:00] <autrijus> but you do have to hit Ctrl-C eventually, before you run out of bits.

[17:00] <autrijus> (but even 32 bits takes a lot of time to run out.)

[17:01] <xinming> my $t = (1..Inf); for $t { $_.say };

[17:01] <xinming> This will print nothing, right?

[17:01] <SamB> what do you mean, run out of bits?

[17:01] <autrijus> SamB: never mind... I forgot Int is bigint.

[17:01] <xinming> If so, I think I understand what = exactly means here.

[17:02] <SamB> I thought Int wrapped around?

[17:02] * autrijus ponders how array references should stringify.

[17:02] <autrijus> SamB: nope. int may, but Int is big.

[17:02] <autrijus> SamB: (note I don't like this.)

[17:03] <Khisanth> autrijus: why not stringify to same thing as perl5?

[17:03] <autrijus> Khisanth: ARRAY(0x1234) ?

[17:03] <Khisanth> :)

[17:03] <autrijus> Khisanth: I somehow doubt its usefulness.

[17:03] <autrijus> xinming: assuming $t stringifies the array it points to, then yes, it will likely die of a out of memory.

[17:04] <Khisanth> one of those things that should be a fatal error?

[17:05] <autrijus> maybe, if we can detect it somehow.

[17:05] <autrijus> but sometimes it's kind of hard.

[17:06] <PerlJam> xinming: given $t = 1..Inf;  for *$t { .say } will never output anything as it will halt executing trying to expand $t.

[17:06] <PerlJam> xinming: for **$t { .say } will do the same but halt compilation as it tries to expand $t

[17:06] <autrijus> Khisanth: unless stringification is lazy also

[17:07] <autrijus> Khisanth: but in p6, string ne list of char

[17:07] <autrijus> so I doubt that can happen.

[17:07] <PerlJam> xinming: for =$t { .say } will output a bunch of numbers.

[17:07] <fglock> Perl6::Value::List is done - it's 30 lines

[17:07] <autrijus> Khisanth: it's like 

[17:07] <autrijus> Data.PackedString.packString (show [1..])

[17:07] <autrijus> which is also out of memory.

[17:07] <Khisanth> autrijus: isn't stringification lazy in p5?

[17:08] <autrijus> Khisanth: I mean the process itself

[17:08] <Khisanth> oh

[17:08] <autrijus> in haskell, show :: [Int] -> [Char]

[17:08] <autrijus> and each cons cell is processed separately

[17:08] <autrijus> so fusion happens and all's fine

[17:08] <autrijus> but in perl6 String is not [Char]

[17:09] <autrijus> so I doubt we can lazily print a stringified infinite array.

[17:09] <autrijus> (I like that Str is not [Char], fwiw.)

[17:15] <svnbot6> r6139 | fglock++ | * Perl6::Value::List - implements "List" semantics in Perl5

[17:15] <fglock> autrijus: you can print "start..end", but not the whole array

[17:15] <autrijus> fglock: right

[17:17] <Limbic_Region> IIRC, @larry - or perhaps even $larry has ruled that if you type the parameters of a sub and you don't pass args of that type - p6 will squawk.  In what ways and conditions will p6 squawk for improper type use elsewhere?

[17:19] <autrijus> actually, it will only squawk when it can't find the coerce:<as> form.

[17:19] <autrijus> it will warn and insert coercion silently otherwise.

[17:20] <autrijus> Limbic_Region: typechecks is only done on bindings. function application and return involves two implicit bindings.

[17:20] <svnbot6> r6140 | fglock++ | * List.pm - added reverse() method

[17:20] <Limbic_Region> so is there going to be a pragma or something to really squawk?

[17:21] <autrijus> Limbic_Region: sure, I think that'd be cool.

[17:21] <autrijus> we're talking about

[17:21] <autrijus> '1' - '2'

[17:21] <Limbic_Region> right

[17:21] <Limbic_Region> and 1 - '2'

[17:21] <autrijus> yup

[17:22] <autrijus> but

[17:22] <Limbic_Region> and '21asdf' - 4

[17:22] <autrijus> 1 - ('2' as Int)

[17:22] <autrijus> will always be fine.

[17:22] <autrijus> (because coercion typechecks by definition)

[17:22] <Limbic_Region> right - explicit type casts required if you say you don't want implicit

[17:23] <xinming> PerlJam: So, for **$t {...}; will be a failure at compile time. And for *$t {...}; won't be a failure, But generating the list all the time.

[17:23] <autrijus> Limbic_Region: use strict 'types';

[17:23] <autrijus> Limbic_Region: I think that'd work.

[17:23] <autrijus> in fact I'll implement it in pil2 :)

[17:24] <Limbic_Region> autrijus - b4 you do

[17:24] <Limbic_Region> I found the thread I was talking about

[17:24] <autrijus> although there is a very pedantic form of coercion

[17:24] <autrijus> 1 - $x

[17:24] <autrijus> which I don't think I'll ever warn.

[17:24] <Limbic_Region> it was luke - not larry - but he agreed there would be yelling, screaming, and gnashing of teeth

[17:25] <Limbic_Region> perhaps only in the case of no coercion though

[17:25] <autrijus> my Int $x; # suppose that

[17:25] <Limbic_Region> let me link

[17:25] <autrijus> then I won't force user to write "1 - ($x as Int)"

[17:25] <autrijus> (because you see, $x is of type "Scalar of Int")_

[17:26] <xinming> thanks all for your patient explaination. :-)

[17:26] <autrijus> to cast it into Int is to call FETCH to it.

[17:26] <autrijus> ok, I need to run for food. bbl

[17:32] <Limbic_Region> grrr - google groups is not playing nice

[17:33] <Limbic_Region> subject line was "Argument Type Checking" and the thread was started by me

[17:47] <svnbot6> r6141 | fglock++ | * List.pm - to_num(), to_str()

[17:56] <geoffb> *yawn*

[17:56] <geoffb> Hey, everyone . . . .

[17:56] <fglock> hi geoffb

[17:57] <geoffb> Two weeks without #perl6 -- I think I'm in withdrawal, despite the sleep deprivation

[17:58] * Limbic_Region is rather enjoying his respite from all things geek

[17:58] * geoffb starts the `svk pull` rounds . . . this is going to take a while

[17:58] <geoffb> You take pretty a pretty soft break, Limbic_Region.  :-)

[17:59] <geoffb> Hey, iblech!

[17:59] <iblech> Hi :)

[17:59] <geoffb> How have you been, lo these many days?

[17:59] <iblech> :) Implementing CPS in PIL2JS currently

[17:59] <geoffb> ooh, very cool.

[18:00] <iblech> Allowing me to implement coro, gather/take, &sleep, callcc, &?CALLER_CONTINUATION and many more things :)

[18:00] <geoffb> How is PIL2JS doing otherwise?  Is the OOMM integrated?

[18:00] <geoffb> nice

[18:00] <iblech> It is, but we've to wait for -CPIL2 to fully use it

[18:01] <geoffb> (`svk pull` isn't finished, so I couldn't check for myself :-)

[18:01] <geoffb> nodnod.

[18:01] <geoffb> And how is -CPIL2 coming?

[18:01] <integral> if PIL2JS can pass t/unspecced/cont.t that'll be one up on Eval.hs

[18:01] <iblech> geoffb: It doesn't exist yet :)

[18:02] <geoffb> wow, I thought for sure autrijus would be mostly there by now.  $work must be really interfering.  Damnable need to eat.

[18:02] <iblech> But as the new PIL runcore (src/PIL*) will use PIL2, we'll have -CPIL2 soon, I think

[18:03] <geoffb> fair enough

[18:06] <geoffb> Oh, for those who didn't make it to OSCON in Portland: http://www.oreillynet.com/pub/au/2333

[18:06] <geoffb> ^ My two dozen or so OSCON posts

[18:10] <iblech> ooh geoffb++

[18:11] <geoffb> Thanks.  Ended up being a lot more work than I expected!

[18:11] <svnbot6> r6142 | fglock++ | * List.pm - added clone(), is_infinite(), to_bit(), to_ref(),

[18:11] <svnbot6> r6142 | fglock++ |     from_single(), to_ref()

[18:26] <svnbot6> r6143 | fglock++ | * Lazy.pm - added concat_list(), from_range()

[18:37] <svnbot6> r6144 | fglock++ | (forgot to save last changes)

[18:48] <Arathorn> big badda boom

[18:48] <Limbic_Region> 5th element

[18:49] <Limbic_Region> great movie btw

[18:50] <wolverian> agreed.

[18:57] <autrijus> woot

[18:58] <autrijus> role Coerceable[::to] { method coerce:<to> (--> ::to) { ... } }

[18:58] <autrijus> multi *coerce:<as> ((Coerceable[T] $from: Type ::T) --> T) { $from.coerce:<to> }

[18:58] <Aankhen``> o_O

[18:59] <autrijus> class Array does Coerceable[Int] { method coerce:<to> () { ./elems } }

[18:59] <autrijus> very clean.

[18:59] <Aankhen``> Yup.

[18:59] <autrijus> then, (@array as Int) follows directly from that

[19:00] <Aankhen``> Yay.

[19:00] <autrijus> and hence ('foo' x @array) too.

[19:00] <autrijus> now, the tricky part is to implement the dependent types ;)

[19:00] <autrijus> (note how the ::T in coerce:<as> unifies with a _value_)

[19:00] <Aankhen``> What dependent types?

[19:00] <autrijus> the (Type ::T) part.

[19:00] <Aankhen``> Ah, OK.

[19:01] * autrijus summons the power of F-omega-sub.

[19:01] <autrijus> dependent types means you can write weird things like

[19:01] <autrijus> ($x as ref($y))

[19:02] <autrijus> or even

[19:02] <autrijus> ($a as (rand(2)>1 ?? Int :: Str))

[19:02] <autrijus> and expect it to work.

[19:02] <wolverian> autrijus, wow, ::T can come after it's used in the signature?

[19:02] <Aankhen``> Coolness!

[19:02] <Aankhen``> Right, I'm taking a break.

[19:02] <Aankhen``> BBL, maybe. &

[19:02] <autrijus> wolverian: yes, all :: bindings unify first into common supertype

[19:02] <autrijus> regardless of position

[19:02] <brentdax> Is ./ back again?

[19:02] <autrijus> then is applied to restrict the non-:: form.

[19:02] <wolverian> autrijus, right. greatness. autrijus++

[19:03] <autrijus> wolverian: thank you, I do think that's kind of an innovation :)

[19:03] <svnbot6> r6145 | Aankhen++ |  r6175@tef-base:  Aankhen | 2005-08-10 00:25:07 +051800

[19:03] <svnbot6> r6145 | Aankhen++ |  HTTP::Message:

[19:03] <svnbot6> r6145 | Aankhen++ |  * added explicit invocant wherever appropriate.

[19:03] <svnbot6> r6145 | Aankhen++ |  * changed `coerce:<as>` from method to sub.

[19:03] <svnbot6> r6146 | Aankhen++ |  r6176@tef-base:  Aankhen | 2005-08-10 00:26:43 +051800

[19:03] <svnbot6> r6146 | Aankhen++ |  * changed `require` to `use` wherever classes were being imported in HTTP::Message, HTTP::Request, HTTP::Request::CGI and HTTP::Response.

[19:03] <autrijus> brentdax: ./ is never left.

[19:04] <brentdax> Ugh...never been a fan of it.

[19:04] <autrijus> right.

[19:04] <wolverian> hm, how do you declare coercion into multiple things in one class?

[19:05] <autrijus> but it's still staying for now, as larry said it's okay to have implicit "use self './'" before we can implement self.pm

[19:05] <autrijus> (which is kind of hard)

[19:05] <autrijus> once that happens then you need that to use ./

[19:05] <autrijus> good enough?

[19:05] <autrijus> wolverian: 

[19:05] <autrijus> class MyClass does Coerce[Int] does Coerce[Str] {

[19:06] <autrijus>     multi method coerce:<to> (--> Int) { ./as_int }

[19:06] <autrijus>     multi method coerce:<to> (--> Str) { ./as_str }

[19:06] <autrijus> }

[19:06] <wolverian> hm, right. that's clean.

[19:06] <autrijus> very.

[19:06] <autrijus> and because of -->'s contravariance

[19:06] <autrijus> if you can coerce to Int without defining coerce to Num

[19:06] <wolverian> somehow the coerce:<to> looks like I should be writing coerce:<Int> etc

[19:06] <autrijus> then pugs picks up Int anyway.

[19:06] <brentdax> Yeah, that's certainly alright.

[19:07] <autrijus> wolverian: yeah, but that'd be name, sadly

[19:07] <autrijus> (picks up Int anyway when you demand Num that is)

[19:07] <integral> will perl6 produce chains of coercions?  $a as B =====> ($a as C) as B ?

[19:08] <brentdax> Can you say `has Int multi method coerce:<to>() { ./as_int }`?  Or is there no counterpart to my/our for methods?

[19:08] <wolverian> autrijus, so why not just call it 'coerce'? what does the :<to> give us?

[19:08] <autrijus> integral: I think that's generally a halting problem

[19:08] <integral> autrijus: thank goodness :)  that's one icky corner of c++

[19:08] <wolverian> (I'm obviously a bit confused, sorry.)

[19:08] <autrijus> integral: right. I don't think that's worth it.

[19:08] <autrijus> wolverian: the coerce: is a grammatical category

[19:08] <autrijus> (not my invention; see A12)

[19:09] <wolverian> right, I'll reread it now. thanks. :)

[19:09] <autrijus> things in that category may appear freely in infix position to add annotations.

[19:09] <autrijus> so hm

[19:09] <wolverian> oh, so you'd write '$foo to Int'?

[19:09] <autrijus> no,

[19:09] <autrijus> $foo as Int

[19:09] <autrijus> so coerce:<to> is bogus

[19:10] <autrijus> maybe just coerce_to then

[19:10] <wolverian> now I'm even more confused. I'll just read A12 now. :)

[19:10] <autrijus> wolverian: A12 just talk about that syntax.

[19:10] <autrijus> I can explain :)

[19:10] <autrijus> the &coerce:<as> function takes a thing and a type

[19:11] <autrijus> and cast the thing to that type

[19:11] <autrijus> provided that the thing does the Coerce role with that type as role parameter.

[19:11] <wolverian> right. 

[19:11] <wolverian> I'm just confused about the <as> thing.

[19:11] <autrijus> to implement that role, we need an actual method

[19:11] <autrijus> oh, the <as>

[19:11] <wolverian> i.e. why it's necessary.

[19:11] <autrijus> it's just like

[19:11] <autrijus> &infix:<and>

[19:11] <wolverian> so we can write our own coerce operators? 

[19:11] <wolverian> what is the use in that? :) 

[19:12] <autrijus> actually a lot of.

[19:12] <autrijus> I can think of "super" for one.

[19:12] <wolverian> oh. well, that's why I'm confused, I can't think of any

[19:12] <autrijus> return (f() super Int);

[19:12] <wolverian> what does that do? :)

[19:12] <autrijus> it ensures that f() returns something that can be used as Int or one of its super types

[19:13] <autrijus> not terribly useful in that position, now I think about it.

[19:13] <wolverian> whoa. method int () { .. } # what happens in integer context

[19:14] <autrijus> yeah, we could have

[19:14] <autrijus> subtype IntDuck can int(-->Int);

[19:15] <autrijus> IntDuck does Coerce[Int] { method coerce () { ./int } }

[19:15] <wolverian> A12 seems to say the int() thing is builtin

[19:15] <autrijus> this is all hypothetical and noncanonical btw.

[19:16] <autrijus> wolverian: sure, *int is builtin, but it better croak on things that can't be intted.

[19:16] <autrijus> $ perl -e 'print int(qr//)'

[19:16] <autrijus> 134574816

[19:16] <autrijus> very useful, that.

[19:16] <Limbic_Region> autrijus - so in the example I tried to link to but google gropus can't seem to find - sub foo (Int $bar) { say $bar } foo('hello');

[19:16] <Limbic_Region> error or no error?

[19:17] <wolverian> right, but A12 says $foo.int is called when $foo is used in any integer context, including implicit

[19:17] <autrijus> Limbic_Region: depends on whether there is coerce defined bothways

[19:17] <wolverian> unless I'm totally misreading what 'integer  context' means

[19:17] <autrijus> Limbic_Region: and whether coercion are implemented to raise warnings.

[19:17] <Limbic_Region> and if error, would the answer change if it was foo('42answer');

[19:17] <Limbic_Region> ok - well, according to Luke in that thread - it is supposed to squawk

[19:17] <autrijus> Limbic_Region: in hackathon lwall ruled that coercion will happen regardless, but '42' and 'Inf' won't raise warnings

[19:17] <autrijus> while '42answer' will

[19:17] <Limbic_Region> ahhh

[19:18] <wolverian> yay. that's sane.

[19:18] <autrijus> and those warnings can be made fatal.

[19:18] <autrijus> and you can additionally make all such coercion fatal.

[19:18] <Limbic_Region> hackathon trumps that thread 

[19:18] <autrijus> so '42' will also croak

[19:18] <autrijus> but that's not by default.

[19:18] <autrijus> yes.

[19:18] <autrijus> wolverian: yeah, very sane and easy to implement also.

[19:18] <wolverian> so, uh. if we have method int to define coercion into int, why do we have coerce:<as> at all?

[19:18] <autrijus> (I should know because I pushed for the most implementable solution)

[19:18] <wolverian> or is A12 just behind the times?

[19:18] <autrijus> wolverian: because you still say

[19:18] <autrijus> ('asd' as Int)

[19:18] <Limbic_Region> I still want to be able to have coercion be fatal or raise warnings if I have 1 or more pragmas enabled

[19:19] <autrijus> that form must be legal

[19:19] <autrijus> now it may call int() behind the scene

[19:19] <autrijus> or other way around

[19:19] <autrijus> the important thing is just the user needs to have access to both.

[19:19] <wolverian> hm. right. so A12 is just unclear here, not strictly wrong

[19:19] <autrijus> wolverian: the "IntDuck" above gives out coerce:<as> to anything that definds .int

[19:19] <autrijus> Limbic_Region: right, you _will_ get those.

[19:19] <autrijus> I want those for the perl6 compiler written in perl6.

[19:20] <wolverian> has there been discussion about renaming grep and/or map? I seem to remember something like that on p6l

[19:20] <wolverian> just wondering if I should bring it up (again)

[19:21] <autrijus> I don't think I see those confirmed

[19:21] <autrijus> I think map is fine

[19:21] <Limbic_Region> I (incorrectly) thought originally, there would be 3 form of declarations for each type - int = looks like an int but will gladly autoconvert, Int = int and will autoconvert but will forget it ever happened (no caching of conversion), INT - int and if you try and use it as any other type I will die

[19:21] <wolverian> right. I don't like grep.

[19:21] <autrijus> Limbic_Region: the INT form is archaic.

[19:21] <autrijus> and obsolete

[19:21] <autrijus> int is unboxed (i.e. not an object, but will autobox)

[19:21] <autrijus> Int is boxed (an object, can have other traits)

[19:21] <wolverian> although even .map could be renamed to .filter or so.

[19:21] <autrijus> that's all

[19:22] <wolverian> I don't know if it'd be clearer though.

[19:22] <autrijus> wolverian: .map is not .filter.

[19:22] <autrijus> .grep is maybe .filter

[19:22] <autrijus> but not .map.

[19:22] <wolverian> .grep is more like .collect

[19:22] <wolverian> I think.

[19:22] <autrijus> but in haskell, filter means grep

[19:22] <autrijus> I think python too

[19:22] <wolverian> right. okay, map isn't filter then. :)

[19:22] <autrijus> to have filter mean map will be weird.

[19:22] <autrijus> now .for_each is fine ;)

[19:22] <autrijus> or even .each

[19:23] <wolverian> isn't that taken already?

[19:23] <autrijus> eh?

[19:23] <wolverian> oh, I was thinking of hashes

[19:23] <autrijus> by ruby maybe

[19:23] <wolverian> which makes me wonder if we have grep/map for hashes?

[19:23] <wolverian> %foo.map(-> $k, $v { ... })

[19:24] <wolverian> I guess it'd be %foo.=kv.map(...)?

[19:24] <wolverian> does that chaining work? :)

[19:24] <autrijus> yeah.

[19:24] <autrijus> sure does.

[19:24] <wolverian> yay!

[19:24] <wolverian> btw - I don't like 'filter' because it's a noun as well as a verb

[19:25] <wolverian> 'collect' is a verb

[19:25] <wolverian> but I don't know if that's much of a design rule in perl6. hm.

[19:34] <eric256> lol. i take a couple days off from pugscode.org to go buy a house and once agian there are like 8 posts to read. lol. the whole week before that only saw like 2 posts...guess i just have good timeing ;)

[19:37] <wolverian> 8 isn't much at all. there have been 40 new messages in a few hours on p6l at times.

[19:37] <eric256> very true.

[19:37] <eric256> but this are pretty big ones ;)

[19:54] <renormalist> Hi all!   Does anybody know whether there is already a (maybe preliminary) perl6-mode for (X)Emacs?

[19:55] <Limbic_Region> I know there is for vim

[19:55] <gaal_> there's a vim mode in util/perl6.vim

[19:55] <gaal_> but i don't know of one for emacs

[19:55] <svnbot6> r6147 | iblech++ | * Usual svn props.

[19:55] <svnbot6> r6147 | iblech++ | * PIL2JS: Continuation Passing Style landed.

[19:55] <svnbot6> r6147 | iblech++ |   * General idea: foo(3); bar(baz()) is rewritten as

[19:55] <svnbot6> r6147 | iblech++ |     foo(3, -> () { baz(-> $arg0 { bar($arg0, {}) }) }).

[19:55] <svnbot6> r6147 | iblech++ |   * Note: Most things (even &say) do not work yet again, will need work on the

[19:55] <svnbot6> r6147 | iblech++ |     JS parts of Prelude::JS. PIL2JS.js is already converted to CPS.

[19:55] <svnbot6> r6147 | iblech++ |   * return(...) respects scope now.

[19:55] <svnbot6> r6147 | iblech++ |   * But &next, &last, etc. do not work yet again.

[19:55] <Limbic_Region> autrijus - sorry, had to step afk

[19:55] <ingy___> hola

[19:56] <Limbic_Region> the incorrect memory is just that - incorrect

[19:56] <Limbic_Region> OTOH, it would be nice to say int, Int, and INT each with different behaviors

[19:57] <renormalist> k

[20:02] <svnbot6> r6148 | iblech++ | PIL2JS:

[20:02] <svnbot6> r6148 | iblech++ | * PIL: Removed dead code (&PIL::generic_catch).

[20:02] <svnbot6> r6148 | iblech++ | * Prelude::JS: Fixed some "calls" to &JS::inline so the resulting JS parses again.

[20:04] <autrijus> Limbic_Region: then I can't name my class C3

[20:04] <autrijus> stevan will be unhappy

[20:05] <autrijus> and think about those chinese class names with no upper case forms!

[20:05] <autrijus> :)

[20:06] <Limbic_Region> err - I am not overly particular about the naming convention

[20:06] <autrijus> iblech: whoa, CPS landed.

[20:06] <autrijus> iblech: did you see my extra-sane coerce?

[20:06] <autrijus> role Coerce[::to] {

[20:06] <autrijus>     method coerce (--> ::to) { ... }

[20:06] <autrijus> }

[20:06] <autrijus> multi *coerce:<as> ((

[20:06] <autrijus>     Coerceable[T] $from

[20:06] <Limbic_Region> I just mean the ability to tell the compiler I mean int and if I ever use it as something other than that - hit me hard

[20:06] <autrijus>     : Type ::T

[20:06] <autrijus> ) --> T) { $from.coerce }

[20:06] <iblech> autrijus: Yep, but absolutely nothing works, fixing :)

[20:07] <iblech> Indeed, very sane

[20:07] <Limbic_Region> or, I mostly intend to use this as an int, but please forgive me if I don't - I understand I will pay a performance penalty when you have to bail me out - and that is ok

[20:07] <autrijus> Limbic_Region: right, in both cases you use int

[20:07] <autrijus> and choose the strictness level of coercion.

[20:07] <Limbic_Region> and finally a mode to say - I don't know what I want or how I will use it so please bail me out and remember what you did so you can be faster about it next time

[20:07] <autrijus> since int->Int is considered coercion.

[20:08] <autrijus> or maybe we call it boxing

[20:08] <autrijus> use strict 'boxing'

[20:08] <Limbic_Region> autrijus - is the strictness level of coercion done on a per-variable declaration basis?

[20:08] <autrijus> Limbic_Region: no, it's based on scope

[20:08] <Limbic_Region> cause if not - I don't llike it

[20:08] <autrijus> nod.

[20:08] <Limbic_Region> so it is still all or none, but only for a given scope

[20:09] <Limbic_Region> *shrug*

[20:09] <autrijus> you are certainly free to declare

[20:09] * Limbic_Region doesn't really have to like it

[20:09] <autrijus> my int_rigid $x;

[20:09] <autrijus> and implement int_ridig.pm by augmenting the int class

[20:09] <autrijus> but disable its coercion bits.

[20:10] <autrijus> which is not unlike Tie::VariousRestrictedThings in perl5.

[20:10] <autrijus> except much faster.

[20:10] <Limbic_Region> well - the only point in doing that is if it made things go faster - which is yet to be seen in p6

[20:10] <Limbic_Region> right

[20:10] <autrijus> right, and if you use int then things will be faster whenever it can.

[20:10] <autrijus> and even if you use Int

[20:10] <autrijus> but without extra traits

[20:10] <Limbic_Region> in p5 changing behavior outside of core meant performance penalties

[20:11] <autrijus> it is possible to automagically unbox it too.

[20:11] <autrijus> right, and in p6 the penalty is only paid in compile time.

[20:11] <Limbic_Region> in p6 - time will tell

[20:11] <autrijus> which hopefully isn't much.

[20:11] <autrijus> yeah, time will tell :)

[20:11] <Limbic_Region> you are more confident then I am on that

[20:11] <autrijus> sure, because I'm the one writing the type directed compiler :)

[20:12] <Limbic_Region> well - it isn't just types though

[20:12] <Limbic_Region> in this case it is

[20:12] <Limbic_Region> but in general, people who want to modify the behavior of how p5 works pay a penalty in performance

[20:12] <Limbic_Region> in general, p6 aims to allow morphing behavior AND still be fast

[20:13] <Limbic_Region> that's the part, IMO, that remains to be seen

[20:14] <autrijus> sure, but currently

[20:14] <autrijus> user-def operators, macros, itypes etc

[20:14] <autrijus> are all compile time features

[20:14] <autrijus> the runtime knows nothing about it

[20:14] <autrijus> so it's hard to imagine it will make runtime slow.

[20:19] <autrijus> journal finally up.

[20:19] <autrijus> g'nite!

[20:19] <Limbic_Region> autrijus - well, I am not trying to be a pessimist here

[20:19] * autrijus waves &

[20:19] <Limbic_Region> TTFN

[20:19] <Limbic_Region> but

[20:19] <autrijus> hm?

[20:20] <Limbic_Region> history has shown that things shoehorned in after the fact lead to original designs being comprimised

[20:20] <autrijus> right.

[20:20] <autrijus> so, Better is Better, this time.

[20:20] <autrijus> &

[20:20] * Limbic_Region stands behind his "time will tell" philosophy

[20:57] * stevan is actually enjoying responding to TSa, the man asks good questions :)

[20:59] <kolibrie> stevan: you've been giving good answers

[21:00] <stevan> kolibrie: thanks :)

[21:00] <stevan> this is my sanity break for the day, I have been on conf calls all day long for $work

[21:00] <stevan> metamodel stuff is a breath of fresh air :)

[21:00] <kolibrie> I'm still trying to understand the whole thing

[21:01] <kolibrie> I've got a paper with lots of notes that I want to digitize somehow

[21:01] <kolibrie> and then ask you questions

[21:01] <stevan> kolibrie: it took me about 2 months and about 5-10 prototypes (all false starts) to get it 

[21:01] <kolibrie> :0

[21:01] <kolibrie> I don't feel too bad, I've only been looking at it for a week or two

[21:02] <stevan> but I didn't have "The Art of MOP" book either, which has been a big help

[21:02] <kolibrie> don't have time for another book right now :(

[21:06] <kolibrie> later all

[21:06] <stevan> later

[21:10] <fglock> hi

[21:10] <eric256> hola

[21:11] <fglock> hola eric256

[21:12] * eric256 tries to figure out the best way to see any new featuers in pugs that he will notice

[21:12] <ingy___> hola

[21:12] <eric256> seems like allot of thoeritcal work has been done.  gonna have to check the svn log to see if any concrete everyday, things i'm going to notice, things have been done ;)

[21:12] <ingy___> has anyone here installed spidermonkey on osx?

[21:13] <obra> hey ingy

[21:13] <ingy___> hi obramatic

[21:13] <obra> how's stl?

[21:13] <ingy___> just fine :)

[21:13] <fglock> eric256: i've worked on Array-Lazy, but it is not integrated into pugs - it's just a module now

[21:14] <eric256> hmmm lazy arrays...anything with objects been happing on the codeing level? i know alot has been brewing

[21:14] <fglock> I think i've got to rename a few modules, like Array::Lazy to Perl6::Container::Array

[21:15] <fglock> eric256: it's already implemented, but integrating into the core is hard

[21:16] <eric256> implemented in pugs?

[21:17] <fglock> yes, but it is just an object - you can't use "@lazy[2]" yet - only $lazy.FETCH(2) 

[21:18] <eric256> i think we are talking about different things.  i mean the object model stuff not the Lazy stuff

[21:18] <eric256> though i want to look into the lazy stuff too

[21:19] <fglock> the object model is the priority right now - but i'm interested in the lazy stuff

[21:20] <fglock> so I started working on it

[21:20] <eric256> i noticed ;)

[21:20] <fglock> :)

[21:22] <fglock> anyone knows how the file hierarchy in pugs works? i'm trying to find out where to place a file

[21:36] <fglock> how do I call a sub in the main namespace, like CORE:: in Perl5?

[21:37] <integral> &*global? if by "main" you mean globals

[21:37] <obra> fglock: is the current DateTime::Span on CPAN expected to pass all its tests?

[21:38] <fglock> no - it depends on DateTime, which is not finished yet :(

[21:39] <fglock> oops - I thought you asked about perl6 version - yes, the CPAN version should pass

[21:39] <obra> I ran into a circular dependency issue where installing DateTime tried to pull in DateTime::Span. which failed tests :/

[21:39] <obra> ahh. ok.

[21:39] <obra> I'm seeing failures in 0.22

[21:39] <obra> t/15time_zone.t    5  1280    14    5  35.71%  7 10 12-14

[21:39] <fglock> DateTime should not depend on DateTime::Span - strange

[21:40] <obra> I bet it was some other module in a dependency chain.

[21:40] <obra> What can I do to help debug those failures?

[21:40] <fglock> i'm looking into it, just a moment

[21:40] <obra> cool.

[21:41] <obra> I don't mean to derail you from what you're working on, but I saw your nick right as I saw the failures ;)

[21:41] <fglock> which t/time_zone.t? does it have a number on the name?

[21:43] <obra> t/15time_zone.t    5  1280    14    5  35.71%  7 10 12-14

[21:43] <obra> 15

[21:45] <fglock> testing...

[21:49] <fglock> obra - it passed all tests with my old DateTime.pm installation. It broke when I updated it. I'll check what's happening.

[21:49] <obra> Ok. cool. I'm glad to hear that it's replicatable

[21:53] <svnbot6> r6149 | iblech++ | PIL2JS:

[21:53] <svnbot6> r6149 | iblech++ | * pil2js.pl: Load stevan++'s new Perl6.MultiMethod.

[21:53] <svnbot6> r6149 | iblech++ | * More steps towards a working PIL2JS.

[21:55] <fglock> obra - It looks like the error is in the test itself - i think it depends on a timezone that has changed

[21:56] <obra> *laugh* oy.

[21:57] <fglock> and I can't login to sourceforge to fix it - it can't connect

[21:58] <fglock> it's in my list for tomorrow

[21:58] *** wilx` is now known as wilx

[21:59] <obra> thanks much.

[21:59] <obra> If we're ever in the same place, I owe you a beer or equivalent. As much for the craziness that was reefknot as this 

[22:00] <fglock> you were in reefknot?

[22:01] <fglock> i guess i find craziness atractive

[22:02] <obra> fglock: I came in relatively late. I spent time with srl working to untangle a lot of the code so mortals could hack on it.

[22:02] <fglock> i tried to call global::push, but it didn't work - is there another syntax?

[22:03] <fglock> obra: it would be nice to have the calendar server working - a lot of people have asked for one

[22:03] <obra> fglock: it sure would.

[22:03] <obra> Right now, there are a lot of opensource efforts to create calendar servers.

[22:03] <obra> Sadly, there are also like six new calendar protocols out there

[22:04] <fglock> (people complain a lot about Set::Infinite code - the perl6 version is much more readable)

[22:04] <obra> fglock: yeah. autrijus was showing me today.

[22:04] <obra> Set::Infinite is deep magic for perl 5

[22:05] <obra> and part of the problem I ran into at the time was trying to do infinite recurrences stored in the database and fast

[22:05] <fglock> i was able to store recurrences in the database - but it was very slow

[22:05] <obra> *nod*

[22:06] <fglock> it can't optimize the queries - they get exponentially slow

[22:06] <obra> yep.

[22:06] <obra> doing infinite set algebra in perl/sql is...well, I haven't seen it done.

[22:07] <fglock> take a look at ext/Recurrence - it is pretty short for what it does

[22:08] <fglock> i think it is doable in perl/sql - i was trying to do it in pure sql :)

[22:09] <obra> heh

[22:09] <obra> doing it fast in perl/sql?

[22:10] <fglock> the problem i got with sql is that it can't do binary searches inside a select, and this means that if i had hour,minutes,seconds it would take 24*60*60 operations

[22:11] <obra> I keep finding that I'm happier storing epoch time in the database

[22:12] <fglock> the problem with perl/sql is that it would take cpu time on the database server - people don't want that

[22:12] <fglock> (i think)

[22:12] <mugwump> I use the native date format, but never rely on server-side date calc

[22:14] <fglock> i'm still trying to find out what's the namespace for 'push()' 

[22:16] <brentdax> I'm actually storing Perl 6's time() format in Kontent store databases--it's fairly handy.

[22:16] <buu> brentdax: What is a 'kontent store database' ?

[22:16] <brentdax> (But then, I'm also avoiding complicated queries.)

[22:16] <obra> perl6 time is still seconds since y2k?

[22:17] <brentdax> Floating-point seconds since Y2K, yes.

[22:17] <brentdax> buu: Kontent is the Perl 6-based CMS I'm writing for Summer of Code.  A store database is where it keeps its pages.

[22:17] <buu> brentdax: Oh. Is it any good?

[22:18] <brentdax> Too slow to be usable, but it just needs a faster interpreter.  Once it's fast enough, I think it'll be pretty nice.

[22:19] <buu> What are the advantages?

[22:21] <eric256>  your getting paid to play with Perl6?  man i missed that boat

[22:21] <eric256> hay perl6 time and perl5 time arn't going to play togther?

[22:21] <obra> eric256: I'm sure there will be magic to make them deal well. and enough rope to hurt yourself too

[22:22] <brentdax> It intrinsically supports multiple page types, so you can keep (say) a wiki and a message board on the same system.  It can render the same page into multiple formats.  Supports multiple stores (I'm writing a DBI one) and multiple web server APIs (writing a CGI one).  And it's cleaner than comparable systems, like Everything and MediaWiki.

[22:22] <Khisanth> obra: well Perl wouldn't be Perl if it didn't give you just enough rope to hang yourself :)

[22:23] <obra> brentdax: how does it compare to bric?

[22:28] <brentdax> Somewhat different emphasis--Kontent is largely intended for open-contribution sites (wikis, message boards, Slash/Scoop news sites, PerlMonks-ish sites), where it looks like Bricolage is mainly for a restricted group of admins.  I think either could do anything the other can with some work, though.

[22:29] <svnbot6> r6150 | fglock++ | * Renamed Lazy::List to Perl6::Value::List

[22:29] <svnbot6> r6150 | fglock++ | * Renamed Array::Lazy to Perl6::Container::Array

[22:30] <brentdax> I'm not sure if Bric creates static pages, but Kontent doesn't--it's all dynamic.  (And no doubt I'll need to add in lots of caching.)

[22:31] <brentdax> (Yeah, Bric creates static HTML.)

[22:32] <svnbot6> r6151 | iblech++ | PIL2JS:

[22:32] <svnbot6> r6151 | iblech++ | * PIL2JS.js, Prelude::JS{,::*}: Fixed hopefully all subs to call the cc.

[22:32] <svnbot6> r6151 | iblech++ | * Good news: "say "hi"" runs again!

[22:32] <svnbot6> r6151 | iblech++ | * Bad news: It produces garbled output. Fixing.

[22:33] <buu> brentdax: So will you have to create your site in side your framework, or will it be just a couple of site types?

[22:34] <brentdax> It pretty much assumes you're keeping your entire site in it.

[22:35] <buu> brentdax: For example, how would you set up an Everything type system?

[22:41] <brentdax> After installing the system (for the CGI supervisor, this involves saying "Alias / /path/to/supervisor/cgi.p6"), you would arrange for new pages to have the Kompose (owned page) class, probably by creating a /pages page with that class and having all of your pages under that.  You would then grant the create permission on /users and /pages to everybody, customize a few settings like the...

[22:41] <brentdax> ...template and site name, and let 'em rip.

[22:41] <svnbot6> r6152 | fglock++ | * Array::Lazy TODO update

[22:44] <renormalist> stupid question (my first experiments with p6regex):   Is =~  still the matching operator?

[22:44] <brentdax> Nope, ~~ now.

[22:44] <renormalist> k, moment

[22:45] <renormalist> ah, ok. ~~ works

[22:46] <renormalist> (of course )

[22:46] <eric256> is there a site for Kontent /

[22:46] <eric256> ?

[22:47] <brentdax> Not yet--just the 0.01 distribution on CPAN and the Subversion repository on my server.

[22:47] <iblech> [PIL2JS] Yay, say "hi" works again :))

[22:48] <eric256> is it still mostly production? because i've been looking for something like that for our work portal, and i'll either have to get to work rewriting mine (written when i was too green to even salvage now) or find a goood one to use ;)

[22:49] <brentdax> It's nowhere near production quality--the current SVN version even has a known remote-code-execution bug (which won't be closed until I implement users and security.)

[22:49] <brentdax> And it's horribly slow because Pugs is unoptimized.

[22:49] <eric256> hehe.../me heads off to start his own design then. ;)

[22:50] <eric256> mine would need less bells and whistles anyway.

[22:50] <brentdax> Probably.  This thing has quite a few, including its own wikiish markup language.

[23:03] <svnbot6> r6153 | iblech++ | PIL2JS: Made say "hi" work again (and probably most other things, too).

[23:03] <svnbot6> r6153 | iblech++ | *Problem*: PIL2JS runs into "too much recursion" errors *really fast*, as

[23:03] <svnbot6> r6153 | iblech++ | PIL2JS never JS-return()s from a function, but instead simply calls the escape

[23:03] <svnbot6> r6153 | iblech++ | continuation. I.e. JS thinks we're still in 1000 functions and dies...

[23:10] <chip> Has Larry posted about sets yet?

[23:16] <iblech> No

[23:24] <renormalist> Question about p6regexes/rules: Should "subpatterns" in Pugs already work? I don't get stuff like <$subrule> to work but I'm not sure whether they already should.

[23:25] <renormalist> I try sth. like this:

[23:25] <renormalist> # - Variant 1 --------------------------------------------------

[23:25] <renormalist> my $PROGRAM = rx{^ \s* START \s* (affe|loewe|giraffe) \s* \. $};

[23:25] <renormalist> # - Variant 2 --------------------------------------------------

[23:25] <renormalist> #my $KEYWORD = rx{(affe|loewe|giraffe)};

[23:25] <renormalist> #my $PROGRAM = rx{^ \s* START \s* <$keyword> \s* \. $};

[23:25] <renormalist> # --------------------------------------------------------------

[23:25] <renormalist> # - match ------------------------------------------------------

[23:25] <renormalist> my $str = 'START loewe .';

[23:25] <renormalist> say "ok" if $str ~~ $PROGRAM;

[23:26] <renormalist> variant1 works, variant 2 not.

[23:28] <brentdax> I don't think they do, but even if they did, they'd be case-sensitive.

[23:28] <renormalist> ah, damn

[23:28] <renormalist> hm, ok, but wasn't the bug

[23:51] <Khisanth> hmm

