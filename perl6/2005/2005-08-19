[00:34] <mikfire> Stupid beginner question.  Is there somewhere I can get a list of the features pugs has implemented?

[00:35] <revdiablo> maybe the test suite? that's getting kind of big these days, though...

[00:35] <mikfire> And I have found some things done that the test code doesn't test yet.

[00:37] <mikfire> Speaking of which.  Where is the best place to submit patches for test code?

[00:38] <revdiablo> ask for commit access

[00:55] <theorbtwo> mik: Want a committer bit?

[00:56] <revdiablo> mikfire: of course, I failed to mention, one of us can commit it for you if you don't want to do it yourself

[00:56] <mikfire> Thinking about it.

[00:56] <mikfire> I need to understand more of what is expected to work.

[00:57] <revdiablo> paste your patch to: http://sial.org/pbot/perl6

[00:57] <theorbtwo> What do you think isn't covered in the test suite?

[00:57] <theorbtwo> ?eval '42' ~~ "forty-two"

[00:57] <evalbot6> bool::false 

[00:58] <theorbtwo> (Useful for discussing such things.)

[00:58] <mikfire> I have have toying with the type system today.

[00:58] <mikfire> excuse me -- the wife calls

[00:58] <revdiablo> oh lord, my working copy is 600 revisions out of date

[01:02] <theorbtwo> G'night, all.

[01:03] <revdiablo> ciao theorbtwo 

[01:28] <sili_> which doc covers references?

[01:43] <buu> ?eval my $x = 32; my $y = \$x; say $x

[01:43] <evalbot6> 32 bool::true 

[01:43] <buu> Weirdness.

[01:44] <sili_> sigh.

[01:44] <sili_> someone needs to start writing spiffy docs.

[01:45] <buu> ?eval my $x = 32; my $y = \$x; say ref $x

[01:45] <evalbot6> Int bool::true 

[01:46] <buu> ?eval my $x = 32; my $y = \$x; say $y

[01:46] <evalbot6> 32 bool::true 

[01:46] <buu> ?eval my $x = 32; my $y = \$x; say ref $y

[01:46] <evalbot6> Int bool::true 

[01:57] <gantrixx> in pugs, does the object stuff work?

[02:03] <gantrixx> is anyone here?

[02:06] <mugwump> hello.  there has been some level of OO support since about 6.2.5 IIRC

[02:07] <gantrixx> I guess I'm just using the wrong syntax or something

[02:07] <gantrixx> I'm following the examples in the Oreily book

[02:07] <mugwump> Which book?

[02:07] <mugwump> Perl 6 Essentials?

[02:08] <gantrixx> perl6 and parrot

[02:08] <gantrixx> let me ask do I still need "return 1;" at the end of packages?

[02:08] <mugwump> no

[02:10] <gantrixx> well it's a very simple object

[02:10] <mugwump> jabbot: nopaste?

[02:10] <jabbot> mugwump: nopaste is http://irc.csie.org:8888/

[02:11] * mugwump compiles ghc-6.4 for amd64

[02:11] <gantrixx> ok, I pasted it

[02:12] <gantrixx> http://irc.csie.org:8888/130

[02:12] <mugwump> oh, blast, the bot isn't in this channel ... you'll have to paste the URL in here

[02:12] <mugwump> ok, Class is not capitalised

[02:12] <sili_> anyone feel like explaining pir?

[02:12] <gantrixx> oh my god

[02:12] <gantrixx> thanks

[02:12] <mugwump> I'm not sure if the unboxed type "int" works yet - better to use the boxed type "Int"

[02:16] <sili_> so pir is just a higher level representation of pasm?

[02:16] <sili_> as in, we could do without it, but would rather not?

[02:17] <mugwump> sili_: trawl through autrijus' journal, it explains the PIL / PIR / IMC / pasm stream

[02:17] <sili_> okies.

[02:18] <mugwump> use.perl.org/~autrijus/journal/

[02:18] <gantrixx> mugwump, did I define the object correctly?

[02:18] <mugwump> sing out if you can't find the relevant entry

[02:18] <mugwump> gantrixx: yup, looked fine otherwise.  does it work?  I've not been up with the current state of pugs for a while

[02:19] <gantrixx> no, it doesn't seem to work

[02:19] <gantrixx> and I thought I could take out the "return 1" at the end

[02:20] <mugwump> ok, perhaps try running the test cases in t/oo in the pugs dist, see how many work.  Perhaps it is in a transitional state.  You might be better off with a release version...

[02:21] <sili_> mugwump: does he do this in a single post or over several?

[02:25] <mugwump> http://use.perl.org/~autrijus/journal/23928, http://use.perl.org/~autrijus/journal/25203, possibly others

[02:26] <mugwump> http://pugscode.org/images/simple-compilation.png # that's what I was looking for!

[02:27] <sili_> thanks.

[02:27] <mugwump> Hmm, then PIR gets compiled to IMC, which gets compiled to PASM... but I'm very sketchy on the details myself

[02:27] <sili_> so much learning

[02:27] <sili_> i almost wish i had gone to school and taken a class or something.

[02:30] <mugwump> just try to remember the eagerness you had to learn at that age ...

[02:30] <mugwump> "Everyone is born a genius, but the process of living de-geniuses them." -- Richard Buckminster Fuller

[02:31] <sili_> any idea what this imc stuff does?

[02:32] <meppl> gute nacht - good night

[02:32] <mugwump> it is a "high level" parrot language

[02:32] <sili_> i thought that's what pir was for?

[02:32] <dudley> sili_: imc == pir

[02:32] <mugwump> oh, silly me

[02:32] <sili_> tricky hobitses.

[02:32] <sili_> dudley: what's it stand for?

[02:33] <dudley> Parrot Intermediate Representation, IIRC

[02:33] <sili_> imc*

[02:33] <mugwump> like I said, I'm sketchy on the details ;)

[02:33] <sili_> what does imc stand for?

[02:33] <dudley> InterMediate Code?

[02:33] <sili_> i guess the world may never know.

[02:36] <mugwump> I forgot that IMC was renamed to PIR

[02:47] <mugwump> http://search.cpan.org/~ltoetsch/parrot-0.2.3/imcc/docs/imcfaq.pod#What_is_IMC,_PIR_and_IMCC?

[02:51] <gantrixx> what does "plan 9" mean?

[02:52] <gantrixx> what does the keyword "plan" do?

[02:52] <gantrixx> why do tall the examples end with .t?

[02:55] <dudley> plan 9 tells the test harness to expect to run 9 tests, that way if a different number of tests are run, the harness knows something went wrong.

[02:56] <dudley> oh, and .t is the canonical suffix for perl test files.

[02:56] <gantrixx> oh, thanks

[02:56] <dudley> np ;)

[02:56] <gantrixx> and perl test files are real perl code?

[02:56] <svnbot6> r6349 | fglock++ | * perl5/ Hash - new Perl5 class

[02:56] <svnbot6> r6349 | fglock++ |   "Perl6::Container::Hash::Object"

[02:56] <svnbot6> r6349 | fglock++ |   implements a hash in which the keys can be objects

[02:57] <dudley> gantrixx: yes, they are.

[02:58] <gantrixx> sorry to ask stupid questions

[02:58] <gantrixx> it seems hard to find examples that I can understand

[02:58] <dudley> there are no stupid questions :)

[02:58] <gantrixx> is the package keyword still used?

[02:58] <gantrixx> or is it "module" that we us now?

[02:59] <gantrixx> basically, I just want a good example of how to declare a object in module and how to call it

[03:00] <dudley> package is still around, but if the interpreter sees package at the top of a file, it assumes that it's perl 5 code, whereas "module" or "class" means perl 6

[03:00] <gantrixx> hmmmmm....that isn't in my book

[03:02] <dudley> I would assume your book is pretty far out of date, but I haven't read any.

[03:03] <dudley> Read the Apocalypses, then the Synopses to get a better idea. But even those are out of date in a lot of places...

[03:05] <sili_> the docs could be a bit better.

[03:06] <gantrixx> what does "use v6" mean?

[03:06] <dudley> sili_: Agreed. Most of the people who have the knowledge to update the docs are busy designing the language and putting food on the table though.

[03:07] <dudley> gantrixx: That's the way (currently) to disambiguate between perl5 and perl6 code.

[03:07] <sili_> ugh.

[03:07] <dudley> the module/class thing isn't implemented as far as I know.

[03:07] <gantrixx> what do you mean by that?

[03:08] <gantrixx> I'm trying to define a simple object in a module than use it in my main code

[03:08] <gantrixx> will I be able to do that?

[03:08] <sili_> not yet.

[03:08] <gantrixx> ok, so if I define the object in the main, I can do that right?

[03:08] <dudley> I meant the interpreter deciding between perl5 and 6 by the "module" and "class" keywords

[03:09] <dudley> gantrixx: sure.

[03:09] <QtPlatypus> gantrixx: Yes 

[03:09] <gantrixx> could I paste an error to you?

[03:09] <gantrixx> the error message is confusing

[03:09] <QtPlatypus> How big is the error?

[03:10] <gantrixx> 5 lines

[03:10] <QtPlatypus> Use the pastling, its in the topic

[03:11] <gantrixx> http://irc.csie.org:8888/131

[03:13] <gantrixx> I'm setting the attribute incorrectly?

[03:13] <gantrixx> or the object didn't get instantiated?

[03:13] <sili_> dudley: wouldn't the documentation be better served with a wiki of some sort?

[03:13] <gantrixx> Is the new() method inherint in the object?

[03:19] <gantrixx> QtPlatypus, did you see what I pasted?

[03:20] <dudley> sili_: Possibly, but in pugs, committer bits are handed out liberally enough that the whole project is wikiish

[03:20] <sili_> hmmmmm

[03:20] <dudley> so if you want to write some docs, ask for a committer bit and check them in :)

[03:21] <sili_> i'd like to, but i'm retarded

[03:21] <sili_> i haven't figured anything out yet.

[03:21] <dudley> gantrixx: I don't think you need to declare $card.name as "my"

[03:21] <buu> Pain

[03:21] <buu> And agony

[03:22] <sili_> yes.

[03:22] <sili_> @array.postcircumfix:<[ ]>( <== @x, @y ); #omgwtf

[03:22] <gantrixx> dudley, I still get the same error regardless

[03:25] <dudley> oh, wait. attributes are read-only by default. try "has $.name is rw;"

[03:25] <mugwump> sili_: you don't like that syntax?!  :)

[03:25] <sili_> mugwump: it's not the syntax, it's that i have no idea what it's doing

[03:25] <dudley> perl6's line noise is much prettier than perl5's :)

[03:26] <mugwump> ok, well the .postcircumfix:<[ ]> refers to a method

[03:26] <mugwump> you normally call it with @array[]

[03:26] <gantrixx> dudley, still get the same error

[03:26] <mugwump> it's a _post-circumfix_ operator, ie it appears after (post), and is circumfix (surrounds its operands)

[03:27] <gantrixx> mugwump, are you talking to me?

[03:27] <sili_> me

[03:30] <sili_> what is dims

[03:30] <sili_> mm dimensions.

[03:30] <mugwump> I don't understand the arrows part, I'll admit :)

[03:31] <dudley> gantrixx: I don't have a built Pugs right now, or I'd be slightly more helpful.

[03:31] <dudley> try it without the package qualifier

[03:31] <gantrixx> no problem, I'll be back in a bit, I'm going to switch to my other computer

[03:32] <dudley> i.e. "class Card" instead of "Card::Card"

[03:33] <mugwump> ah, I love being on a network fast enough to run wget -O - url | cdrecord -

[03:46] <dudley> aren't attributes supposed to default to read-only?

[03:48] <dudley> :todo<feature>

[03:48] <dudley> I understand, now.

[03:51] <dudley> gantrixx: if you happen to backlog, here's how to do what you were trying to do.

[03:51] <pasteling> "dudley" at 70.179.213.96 pasted "gantrixx's problem" (16 lines, 198B) at http://sial.org/pbot/12582

[03:52] <sili_> i need to upgrade pugs

[03:55] <dudley> Goodnight , everyone.

[03:55] <dudley> sleep &

[03:58] <putter> sili_: there is a wiki http://pugs.kwiki.org/ .  One useful page to create might be a BeginnersQuestions page.  Fill it up with questions as you encounter them, and then you and others can fill in answers.  That way, beginner number n+1 can benefit from the n people who have been there before her.

[04:00] <gantrixx> for some reason, it takes a really long time to build Pugs on my main machine

[04:00] <gantrixx> my laptop has a slower processor, but is faster

[04:00] <putter> my $card = Card.new(:name("J") :suit("c"))  also works.

[04:01] <gantrixx> thanks putter, I'll try that as soon as I update my pugs

[04:02] <sili_> ah.

[04:06] <gantrixx> pugs uses parrot?

[04:09] <gantrixx> I'm just really surprised how long, make and make test takes on my desktop machine vs my laptop

[04:19] <luqui> autrijus, poke

[04:24] <putter> gantrixx: pugs uses parrot's PGE for perl6 style rules (p5 style, eg, rx:perl5/foo/ is done internally using PCRE).  It can also use parrot/PIR as a backend, but that's not working at the moment until the parrot leo-ctx5 branch is merged with the parrot trunk.

[04:25] <putter> parrot/PGE can be used either externally (pugs just calls parrot), or embedded.  with the choice made at config/compile time.

[04:26] <gantrixx> uh, ok

[04:28] <putter> the STATUS file might be of interest.

[04:40] <putter> good night all. &

[04:40] <svnbot6> r6350 | putter++ | PIL-Run - added kludged macro support.  Thus && and || seem to work.  t/01-sanity/03-equal.t passes.  But not with the current Perl6/Container/Scalar.pm r6349 (r6331 worked with minimal syntax error fixes).

[05:45] <autrijus> luqui: peek

[06:18] <xinming> ?eval given "1" { when 1 { 'number'.say }; when "1" { 'string'.say } };

[06:18] <evalbot6> number bool::true 

[06:18] <xinming> hm, so anyone here would tell me how can I get the "right" result?

[06:23] <QtPlatypus> I don't think pugs at the moment diffrentates between Str's and Ints

[06:23] <QtPlatypus> ?eval ref(1)

[06:23] <evalbot6> ::Int 

[06:23] <QtPlatypus> ?eval ref("1")

[06:23] <evalbot6> ::Str 

[06:24] <QtPlatypus> ?eval given ref("1") { when "::Int" { 'number'.say }; when "::Str" {'string'.say}};

[06:24] <evalbot6> undef 

[06:24] <xinming> "will do" trait will be used as a subroutine call hook, hmm, when, will it be called?

[06:24] <xinming> before the function call?

[06:24] <QtPlatypus> ?eval given ref("1") { when ::Int { 'number'.say }; when ::Str {'string'.say}};

[06:24] <evalbot6> undef 

[06:25] <luqui> xinming: it is the function call

[06:25] * QtPlatypus wonders why that doesn't work.

[06:25] <luqui> sub foo () { blah } is short for sub foo() will do {blah}

[06:25] <luqui> (except that you have to have some block on the sub, so maybe it's sub foo() will do {blah} {...})

[06:25] <luqui> anyway, nobody will ever write that, so that's just how we refer to the codeblock that is the body of the subroutine

[06:26] <xinming>  given {ref("1")} { when ::Int { 'number'.say }; when ::Str {'string'.say}};

[06:26] <xinming> ?eval given {ref("1")} { when ::Int { 'number'.say }; when ::Str {'string'.say}};

[06:26] <evalbot6> undef 

[06:26] <luqui> ?eval given "1" { when ::Int { 'number'.say };  when ::Str { 'string'.say } }

[06:26] <evalbot6> string bool::true 

[06:27] <luqui> types in smart match check whether the left side is an instance

[06:27] <luqui> (technically it checks "does", so maybe it ought to work)

[06:27] <luqui> ?eval ::Int.does(::Object)

[06:27] <evalbot6> bool::true 

[06:28] <luqui> ?eval ::Object.does(::Int)

[06:28] <evalbot6> bool::false 

[06:28] <luqui> okay, so that ought to work

[06:28] <luqui> unless ref returns a string, not a type

[06:29] <luqui> ref(ref("1"))

[06:29] <luqui> ?eval ref(ref("1"))

[06:29] <evalbot6> ::Type 

[06:29] <luqui> hmm

[06:29] <xinming> ?eval sub foo will do { 'will do part'.say } { 'function main part'.say };

[06:29] <evalbot6> Error:  unexpected "w" expecting bare trait, subroutine parameters, trait or block 

[06:29] <luqui> I'm not sure "will" is supported

[06:29] <xinming> ?eval sub foo will do { 'will do part'.say } { 'function main part'.say }; &foo();

[06:29] <evalbot6> Error:  unexpected "w" expecting bare trait, subroutine parameters, trait or block 

[06:30] <luqui> ?eval my $x will begin(4)

[06:30] <evalbot6> Error:  unexpected "w" expecting trait, "=", ".=", ":=", "::=", ";" or end of input 

[06:30] <luqui> er, 

[06:30] <xinming> luqui: So, Which message will printed first?

[06:30] <xinming> will do part. or function main part?

[06:30] <luqui> xinming, one of those will override the other

[06:30] <luqui> hopefully with a warning

[06:30] <luqui> the default block *is* the "will do" block

[06:31] <luqui> ?eval my $x will begin { 4 }

[06:31] <evalbot6> Error:  unexpected "w" expecting trait, "=", ".=", ":=", "::=", ";" or end of input 

[06:31] <xinming> Oh,Ok, So, the will do block will override the "main part" and "main part" won't be executed. right?

[06:31] <luqui> it looks like traits are hard-coded in the parser

[06:31] <luqui> something like that

[06:31] <luqui> or the other way around

[06:31] <luqui> or die and carp that it was defined twice

[06:31] <luqui> probably that one

[06:32] <luqui> ?eval "1".does(::Int)

[06:32] <evalbot6> bool::false 

[06:33] <luqui> ?eval "1".does(::Str)

[06:33] <evalbot6> bool::true 

[06:33] <xinming> 1.does(::Int)

[06:33] <xinming> ?eval 1.does(::Int)

[06:33] <evalbot6> bool::true 

[06:33] <luqui> ?eval "1" ~~ ::Str

[06:33] <evalbot6> bool::true 

[06:33] <luqui> ?eval ::Int ~~ ::Object

[06:33] <evalbot6> bool::true 

[06:33] <luqui> okay, so "when" is broken, it seems

[06:39] <xinming> ?eval my $a; $a//0??true(1)::not(1);

[06:39] <evalbot6> bool::false 

[06:39] <xinming> hmm, It seems, evalbot can do the things better than our parser. :-)

[06:39] <luqui> uh, what?

[06:40] * luqui is still compiling the latest pugs

[06:40] <xinming> ?eval my $a; $a//1??true(1)::not(1);

[06:40] <evalbot6> bool::true 

[06:40] <xinming> my example. the "latest pugs doesn't give the right answer.

[06:41] <luqui> what does it give?

[06:42] <xinming> pugs> my $a; $a//0??true(1)::not(1);

[06:42] <xinming> undef

[06:42] <xinming> pugs> my $a; $a//1??true(1)::not(1);

[06:42] <xinming> undef

[06:42] <luqui> hmm

[06:44] * luqui experiments with this (upon completion of pugs compile :-(  )

[06:45] <xinming>     $x ~~ .does(Storeable)      # okay

[06:45] <xinming>     .does(Storeable) ~~ $x      # not okay--gets wrong $_ on left

[06:45] <xinming>     { .does(Storeable) } ~~ $x  # okay--closure binds its $_ to $x

[06:45] <xinming> luqui: Could you please explain the example above for me?

[06:45] <luqui> hmm...

[06:45] <luqui> it seems that ~~ is no longer symmetric

[06:45] <luqui> (I think I remember Larry saying that)

[06:46] * ods15 looks around for nothingmuch

[06:46] <luqui> okay, so in general, A ~~ B makes A the topic for the evaluation of B

[06:46] <luqui> wait

[06:46] <luqui> no

[06:46] <luqui> okay I can't explain it

[06:46] <ods15> wtf is ~~

[06:46] <xinming> :-)

[06:46] <luqui> what I can do is complain to p6l about it

[06:46] <ods15> not not?

[06:46] <luqui> ods15: smart match

[06:47] <luqui> it's the new =~, but it does a lot more

[06:47] <ods15> heh

[06:47] <luqui> "give me two things, and I'll tell you whether they like each other"

[06:47] <ods15> by what

[06:47] <luqui> xinming, where did you see that example

[06:47] <ods15> soundex, one is in each other, what

[06:47] <luqui> according to their type

[06:48] <luqui> just "do the right thing"

[06:48] <xinming> luqui: I will leave the question to eval bot. :-)

[06:48] <xinming> luqui: in S04

[06:48] <luqui> we're trying to cram all the dwimmyness into that operator

[06:48] <luqui> so $x ~~ /foo/   tests whether $x matches the pattern

[06:48] <luqui> $x ~~ Int   tests whether $x is an Int

[06:48] <luqui> etc.

[06:49] <ods15> ay

[06:49] <luqui> the table of all the dwimmyness is in S04 I think

[06:49] <luqui> geez, pugs is still compiling!

[06:50] <luqui> ohhh... do not compile pugs on a machine with 128M of memory, duh!

[06:51] <xinming> luqui: no, In fact, 256M mem machine should avoid this too. ;-)

[06:51] <xinming> I got 512M mem, And Still swapping heavily.

[06:51] <luqui> yikes

[06:51] <luqui> optimized?

[06:52] * luqui switches to feather

[06:53] <xinming> luqui: do you mean, I have to remeber the table in S04 which is relating the ~~?

[06:54] <luqui> hopefully not.  we've tried to define it so that it just does what you want

[06:54] <luqui> but that's why there are alternatives to everything in smart match

[06:54] <luqui> so that if you want to be precise (or you can't remember the table), you can use those

[06:57] <xinming> luqui: Hmm, In fact, I wonder why... .does(Storeable) ~~ $x

[06:57] <xinming>  .does(Storeable) ~~ $x      # not okay--gets wrong $_ on left

[06:58] <luqui> that's what I'm going to complain about

[06:58] <luqui> not that, but the other one

[06:58] <luqui>  $x ~~ .does(Storeable)   # gets the right $_

[06:58] <luqui> where "the right" means "$x"

[06:58] <luqui> which I think is wrong

[06:59] <ods15> ?eval 5 ~~ Int

[06:59] <evalbot6> bool::true 

[06:59] <ods15> ?eval "bla" ~~ Int

[06:59] <evalbot6> bool::false 

[06:59] <ods15> ?eval 5 ~~ String

[06:59] <luqui> .does(Storeable) ought to mean $_.does(Storeable) for the block-lexical $_

[06:59] <evalbot6> Error: No compatible subroutine found: "&String" 

[06:59] <jql> anyways, isn't $x ~~ Storable a .does test these days?

[06:59] <luqui> and that oughtn't change

[06:59] <luqui> (you have to write ::String, it seems)

[06:59] <ods15> what should i be using

[06:59] <ods15> ?eval 5 ~~ ::String

[06:59] <evalbot6> bool::false 

[06:59] <luqui> (but that is a bug in pugs)

[06:59] <ods15> ?eval "5" ~~ ::String

[06:59] <evalbot6> bool::false 

[06:59] <luqui> uh

[06:59] <ods15> ?eval "5a" ~~ ::String

[06:59] <luqui> woah

[06:59] <evalbot6> bool::false 

[06:59] <luqui> oh

[06:59] <luqui> ::Str

[06:59] <luqui> right

[06:59] <ods15> ?eval "hello?" ~~ ::Str

[06:59] <evalbot6> bool::true 

[07:00] <ods15> ?eval "5" ~~ ::Str

[07:00] <evalbot6> bool::true 

[07:00] <luqui> you can probably leave off the :: then

[07:00] <ods15> ?eval 5 ~~ Str

[07:00] <evalbot6> bool::false 

[07:00] <ods15> ?eval "5" ~~ Str

[07:00] <evalbot6> bool::true 

[07:00] <ods15> whatever

[07:00] <jql> ?eval 5 ~~ Num

[07:00] <evalbot6> bool::true 

[07:01] <xinming> ?eval Num ~~ 5;

[07:01] <evalbot6> bool::false 

[07:01] <luqui> yeah, unfortunately, for a symmetric operator, the semantics are not symmetrical

[07:01] <xinming> ?eval ::Str ~~ "ha" ;

[07:01] <ods15> ?eval Num ~~ Type

[07:01] <evalbot6> bool::false 

[07:01] <jql> ?eval Num !~ 5

[07:01] <xinming> ...

[07:01] <evalbot6> bool::true 

[07:02] <jql> ?eval 5 ~~ Str|Num

[07:02] <evalbot6> bool::false 

[07:02] * jql was curious... didn't think so

[07:02] <luqui> ?eval 5 ~~ (Str (+) Num)

[07:02] <evalbot6> Error:  unexpected "(" expecting letter or digit, ":", term postfix, operator or ")" 

[07:03] <luqui> okay, not implemented

[07:03] <ods15> ?eval 5 ~~ (Str|Num)

[07:03] <evalbot6> bool::false 

[07:03] <ods15> yawn

[07:03] <luqui> that really ought to work

[07:03] * xinming is still in confusion. T_T

[07:03] <ods15> i'm hating perl6 more and more :)

[07:03] <luqui> don't mind the current ~~

[07:03] <luqui> I've seen several cases here that are wrong

[07:04] <luqui> ods15: are you from perl or haskell?

[07:04] <jql> my font is missing (+). I have ≈ tho

[07:05] * jql sighs

[07:05] <luqui> how can your font be missing (+)

[07:05] <luqui> it's three ascii characters

[07:05] <jql> the unicodian version

[07:05] <ods15> luqui: C

[07:05] <luqui> oh, well it's not latin-1

[07:05] <luqui> so (+) ought to be the culturally standard version

[07:05] <luqui> or something

[07:06] <jql> I have some of unicode installed, but that's ≠ all

[07:06] <luqui> I don't hack culture, that's larry's job

[07:06] <luqui> ods15: you didn't use perl 5 before perl 6?

[07:06] <ods15> i have

[07:06] <Supaplex> self.sleep(lots)

[07:07] <Supaplex> nite. :-D

[07:07] <xinming> Supaplex: nite

[07:08] <luqui> xinming, about your bug: "my $a; $a//0??true(1)::not(1);"

[07:08] <luqui> leave off the semicolon at the end

[07:08] <luqui> pugs seems to think that that means you want undef to be retured

[07:08] <luqui> returned

[07:10] <xinming> my $a; $a//0??true(1)::not(1)

[07:10] <xinming> my $a; $a//1??true(1)::not(1)

[07:11] <luqui> right, in the pugs interactive environment, those should do the right thing

[07:11] <xinming> yeap, I got it

[07:12] <luqui> ?eval ref("1")

[07:12] <evalbot6> ::Str 

[07:12] <luqui> ?eval Str

[07:12] <evalbot6> \Class.new(('name' => 'Str'), ('traits' => ('Scalar'))); 

[07:12] <luqui> those two really ought to be the same thing

[07:12] <jql> interesting

[07:12] <luqui> ?eval ::Str

[07:12] <evalbot6> \Class.new(('name' => 'Str'), ('traits' => ('Scalar'))); 

[07:13] <jql> eval "1".class

[07:13] <jql> ?eval "1".class

[07:13] <evalbot6> Error: No compatible subroutine found: "&class" 

[07:13] * jql shrugs impotently

[07:22] <xinming> is there any difference between .pair and .kv ? or they are the same with the different name

[07:22] <luqui> .pair?

[07:23] <luqui> ?eval {a => 1, b => 2}.pair

[07:23] <evalbot6> (('a 1' => ('b', 2))) 

[07:23] <luqui> uh, what the heck?

[07:23] <luqui> ?eval {a => 1, b => 2}.kv

[07:23] <evalbot6> ('a', 1, 'b', 2) 

[07:23] <luqui> well there is clearly a difference

[07:23] <luqui> ?eval pair 1, 2

[07:23] <evalbot6> (('1' => 2)) 

[07:24] <luqui> ?eval pair 1, 2, 3, 4

[07:24] <evalbot6> (('1' => 2), ('3' => 4)) 

[07:24] <xinming> It seems that pugs is doing wrong thing here.

[07:24] <xinming> ?eval {a => 1, b => 2}.pair

[07:24] <luqui> it looks like pair is almost the opposite of kv

[07:24] <evalbot6> (('a 1' => ('b', 2))) 

[07:24] <luqui> pair {a => 1}

[07:24] <luqui> ?eval pair {a => 1}

[07:24] <evalbot6> (('a 1' => undef)) 

[07:24] <xinming> hmm...

[07:24] <xinming> :-)

[07:24] <luqui> yeah, it shouldn't listify the hash

[07:25] <luqui> other than that it looks right

[07:25] <xinming>  ?eval {a => 1, b => 2}.kv

[07:25] <xinming> ?eval {a => 1, b => 2}.kv

[07:25] <evalbot6> ('a', 1, 'b', 2) 

[07:25] <xinming> ?eval each {a => 1, b => 2}

[07:25] <evalbot6> Error: No compatible subroutine found: "&each" 

[07:25] <Khisanth> ?eval { a => 1, b => 2, c => 3 }.pair

[07:25] <evalbot6> (('a 1' => ('b', 2)), ('c 3' => undef)) 

[07:25] <luqui> yeah, I know what it's doing

[07:26] <xinming> how to return "a" pair instead of all kv?

[07:26] <luqui> what do you mean?

[07:26] <luqui> which one?

[07:26] <luqui> you mean like each in perl 5?

[07:26] <Khisanth> why is it concatenating the key with the value?

[07:27] <luqui> because that's how you stringify pairs

[07:27] <luqui> but it's a bug

[07:28] <xinming> luqui: yeap, each,

[07:28] <luqui> doesn't exist in perl 6

[07:28] <Khisanth> ?eval { a => 1, b => 2, c => 3 }.perl

[07:28] <evalbot6> '{(\'a\' => 1), (\'b\' => 2), (\'c\' => 3)}' 

[07:28] <xinming> hmm, In fact, I know in for statement. you can use for ( %hash.kv ) -> $key, $value { }

[07:28] <luqui> right

[07:29] <luqui> that's why each is going away: because we have a new, better idiom for that

[07:29] <xinming> but How to use this in "normal" state?

[07:29] <luqui> example please

[07:30] <xinming> ?eval { a => 1, b => 2, c => 3 }.kv[0];

[07:30] <evalbot6> \'a' 

[07:30] <xinming> ?eval { a => 1, b => 2, c => 3 }.kv[0]

[07:30] <evalbot6> \'a' 

[07:30] <luqui> uh.. huh?

[07:31] <luqui> and?

[07:31] <xinming> ?eval { a => 1, b => 2, c => 3 }.kv[0,1];

[07:31] <evalbot6> ['a', 1] 

[07:31] <xinming> ?eval { a => 1, b => 2, c => 3 }.kv[0,1].perl;

[07:31] <evalbot6> '[\'a\', 1]' 

[07:31] <xinming> It returns a anonymous hash, I with it to be return as a "pair".

[07:32] <xinming> just like we created using { 'a' => 1 }

[07:32] <luqui> you want the first pair in the hash?

[07:32] <luqui> ?eval { a => 1, b => 2, c => 3 }.pairs

[07:32] <evalbot6> (\('a', 1), \('b', 2), \('c', 3)) 

[07:32] <luqui> hmm

[07:33] <xinming> ?eval { a => 1, b => 2, c => 3 }.pairs[1]

[07:33] <evalbot6> ['b', 2] 

[07:33] <luqui> ?eval a => 1

[07:33] <evalbot6> ('a' => 1) 

[07:33] <luqui> weird

[07:33] <xinming> ?eval { a => 1, b => 2, c => 3 }.pairs[0]

[07:33] <evalbot6> ['a', 1] 

[07:33] <xinming> still anonymous hask.

[07:33] <xinming> s/hask/hash.

[07:33] <luqui> anonymous array, rather

[07:33] <xinming> oops.

[07:33] <luqui> and I believe that is a bug

[07:33] <xinming> sorry.

[07:33] <luqui> looking into it

[07:36] <luqui> ?eval <a b c>.pairs

[07:36] <evalbot6> ((0 => 'a'), (1 => 'b'), (2 => 'c')) 

[07:37] <luqui> it appears that it's only broken in the hash form

[07:38] <xinming> ?eval {a b c}.pairs

[07:38] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[07:38] <luqui> syntax error

[07:38] <xinming> ...

[07:38] <xinming> pugs: out of memory (requested 1048576 bytes) 

[07:39] <xinming> luqui: It's a bug,

[07:39] <luqui> no kidding

[07:40] <luqui> ?eval {a b c}

[07:40] <evalbot6> Error: No compatible subroutine found: "&a" 

[07:40] <luqui> weird

[07:42] <xinming> luqui: open a new terminal, And run pugs. try this line. {a b c}.pairs  :-)

[07:42] <xinming> luqui: You will know why I say It's a bug.

[07:42] <luqui> I did

[07:42] <luqui> and I see that

[07:43] <luqui> and I said "weird"

[07:43] <xinming> If you don't get much mem, please close it as soon as possible.

[07:43] <luqui> I'll leave that to the gurus: that one seems over my head

[07:44] <xinming> may be not to write a test for this bug. :-)

[07:46] <luqui> write p6c about it

[07:46] <xinming> luqui: hmm, Ok, I will do.

[07:52] <xinming> ?eval { a b }

[07:52] <evalbot6> Error: No compatible subroutine found: "&a" 

[07:53] <xinming> ?eval { a }

[07:53] <evalbot6> Error: No compatible subroutine found: "&a" 

[07:55] <scook0> ?eval (hash {a b c}).pairs

[07:55] <evalbot6> (\('<SubBlock(<anon>)>', undef)) 

[07:56] <scook0> ?eval (sub {a b c}).pairs

[07:56] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[07:58] <luqui> ?eval hash(a b c).pairs

[07:58] <evalbot6> Error: No compatible subroutine found: "&a" 

[07:58] <luqui> welp, I can't seem to find the .pairs bug

[07:59] <luqui> no, wait, I can find it

[07:59] <luqui> I just can't fix it

[07:59] <luqui> now that I know haskell pretty well, I guess I should start trying to learn pugs

[07:59] <luqui> which is about as much like haskell as the perl 5 implementation is like C

[07:59] <castaway_> ;)

[08:00] *** castaway_ is now known as castaway

[08:00] <xinming> luqui: hmm, I know I am good at neither haskell pugs nor perl 5. :-)

[08:01] <xinming> ?eval { "a" => 1 };

[08:01] <evalbot6> {('a' => 1)} 

[08:01] <xinming> ?eval { a => 1 };

[08:01] <evalbot6> {('a' => 1)} 

[08:01] <xinming> ?eval { a => 1 b };

[08:01] <evalbot6> Error:  unexpected "b" expecting operator, term postfix, postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[08:01] <xinming> ?eval { a => 1, b };

[08:01] <evalbot6> Error: No compatible subroutine found: "&b" 

[08:02] <xinming> ?eval { a b c };

[08:02] <evalbot6> Error: No compatible subroutine found: "&a" 

[08:02] <xinming> ?eval { a b c }.pair;

[08:02] <evalbot6> (('<SubBlock(<anon>)>' => undef)) 

[08:02] <luqui> ?eval { x }.pairs

[08:02] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[08:02] <luqui> aha

[08:02] <luqui> ?eval sub { 1 }.pairs

[08:02] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[08:03] <luqui> Code.pairs breaks

[08:03] <xinming> hmm, so, need to check before call method pairs, right?

[08:04] <luqui> well, pairs ought to check for you

[08:05] <xinming> luqui: I think What I mean is change the source in pugs. before it call pairs.

[08:10] <luqui> pairsFromVal and pairsFromRef are calling each other recursively

[08:11] <xinming> Use variable to get at the container of a scalar variable.

[08:11] <xinming>     if variable($scalar).constant {...}

[08:11] <xinming> hmm, what does this mean please?

[08:11] <luqui> a scalar variable automatically returns its value

[08:12] <luqui> whereas with an array, you have to fetch:  @a[2]

[08:12] <luqui> so you use variable($foo) if you want to get at the scalar, not its value

[08:12] <luqui> that is, you can never change a value

[08:12] <luqui> but you can change a variable

[08:12] <xinming> luqui: hmm, do you mean type?

[08:12] <luqui> no

[08:12] <xinming>  get at the scalar

[08:13] <xinming> I don't understand this sentence. :-S

[08:13] <luqui> when you say $scalar.constant, you're asking whether the value that the scalar holds is constant

[08:13] <luqui> which is meaningless

[08:13] <luqui> you want to know whether the scalar container is constant

[08:13] <luqui> so you say variable($scalar).constant

[08:13] <luqui> uh...

[08:13] <luqui> it is related to type

[08:14] <luqui> when you say "my Num $x"

[08:14] <luqui> you're saying that $x can only hold Nums

[08:14] <luqui> so when you say $x = 4

[08:14] <luqui> the type of the value that $x is holding is Int

[08:14] <luqui> but the type the container can accept is still Num

[08:14] <luqui> (you could say $x = 4.5 later)

[08:14] <xinming> hmm, scalar container is also a scalar...

[08:14] <xinming> luqui: Ok, I think I know.

[08:14] <luqui> it is a reference

[08:14] <luqui> the vocabulary is a bit jumbled and ambiguous

[08:15] <luqui> we're calling things like 1, "Foo", and [1,2,3] "Items"

[08:15] <luqui> whereas we say "Scalar" when we mean a scalar container

[08:15] <luqui> so a Scalar holds an Item

[08:16] <xinming> perl 6 might be the harder language to learn than perl 5 does. ;-)

[08:16] <luqui> it will definitely be harder to learn as a whole

[08:16] <luqui> we're trying to make it easy to learn the part you need though

[08:16] <xinming> hmm, I will still considering this. thanks for your explaination.

[08:16] <luqui> sure.  wish I could say it more clearly

[08:19] <xinming> will perl 6 running in "strict" and "strict" mode by default?

[08:19] <luqui> yeah

[08:20] <luqui> xinming, your { a b c }.pairs bug is fixed

[08:20] <luqui> r6351

[08:21] <svnbot6> r6351 | luqui++ |  r200@feather:  fibonaci | 2005-08-19 10:18:41 +0200

[08:21] <svnbot6> r6351 | luqui++ |  Fixed the infinite loop on sub { 1 }.pairs.  I did it by removing the IScalar

[08:21] <svnbot6> r6351 | luqui++ |  case on pairsFromRef, so that might have broken something.  But that case seemed

[08:21] <svnbot6> r6351 | luqui++ |  to violate the new zer deref semantics.

[08:23] <xinming> luqui: So, The variable function is a bit like, get_container( $variable ), right?

[08:23] <luqui> yeah

[08:23] <luqui> in fact, it's a lot like tied() in perl 5

[08:24] <luqui> except it doesn't return undef if the variable isn't tied

[08:24] <luqui> do you use svk xinming?

[08:25] <xinming> hmm, then, will the tied function moved to variable()?

[08:25] <luqui> I think so

[08:25] <luqui> tied() is not a very descriptive name these days

[08:26] <xinming> I use svn. :-) I am stilll a new bie with computing. ;-)

[08:27] <xinming> I see the uniformness in perl 6,

[08:28] <luqui> thanks... we're still working on that

[08:29] <xinming> It seems that larry is the person who wish to "rule" the world.

[08:30] <luqui> he said he was a megalomaniac

[08:30] <luqui> heh

[08:30] <xinming> I ever used perl 5, and found amazing. Now, after read most of the synopsis, I found there is still many improvements in perl 5

[08:31] <xinming> though there is a bit pain to switch perl 6 from perl 5. :-)

[08:31] <luqui> it's pretty much a different language

[08:32] <xinming> hyper operator those things might never be seen in the other language.

[08:32] <luqui> no, hyper operators are common practice in APL :-)

[08:32] <xinming> luqui: I know that, most aspect of perl 5 has gone.

[08:32] <xinming> what APL mean please?

[08:32] <luqui> it's an obscure language from the 70s

[08:33] <svnbot6> r6352 | luqui++ |  r202@feather:  fibonaci | 2005-08-19 10:27:28 +0200

[08:33] <svnbot6> r6352 | luqui++ |  Removed Debug.Trace that I used temporarily.

[08:33] <luqui> it didn't think ASCII was good enough, so it invented its own keyboard for programming in it

[08:33] <xinming> ...

[08:35] <xinming> luqui: I don't think ASCII is good either. And even the keyboard layout... I don't like it either.

[08:36] <luqui> oh darn, my { a b c }.pairs fix broke some stuff :-(

[08:39] <xinming> ?eval :a:b:c(1);

[08:39] <evalbot6> Error:  unexpected ":" expecting word character, "(", "[", "<<", "<", "\171", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:39] <xinming> ?eval :a:b:c(1)

[08:39] <evalbot6> Error:  unexpected ":" expecting word character, "(", "[", "<<", "<", "\171", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:39] <xinming> will this be valid in perl 6?

[08:39] <xinming> :a:b:c(1)

[08:40] <scook0> xinming: what are you expecting it to do?

[08:40] <xinming> hold on.

[08:40] <luqui> ?eval :a :b :c

[08:40] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:40] <luqui> ?eval say :a :b :c

[08:40] <xinming> scook0: hmm, for generate 3 pairs with the value 1;

[08:40] <evalbot6>  bool::true 

[08:41] <luqui> ?eval my @pairs = :a :b :c; say @pairs

[08:41] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, ";" or end of input 

[08:41] <luqui> ?eval my @pairs = :a(1) :b(1) :c(1); say @pairs

[08:41] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, ";" or end of input 

[08:41] <luqui> you're allowed to omit the comma between those sorts of pairs

[08:41] <luqui> ?eval my @pairs = :a(1), :b(1), :c(1); say @pairs

[08:41] <evalbot6> a1b1c1 bool::true 

[08:41] <luqui> but it appears to be unimplemented

[08:41] <scook0> ?eval sub report(*%_) { say %_}; report :a:b:c(1)

[08:41] <evalbot6> a1b1c1 bool::true 

[08:41] <xinming> The innermost block matching the selection criteria will be exited. The return value, if any, must be passed as a list. To return pairs as part of the value, you can use a pipe:

[08:41] <xinming>     leave <== :foo:bar:baz(1) if $leaving;

[08:42] <luqui> ?eval id 1

[08:42] <evalbot6> undef 

[08:42] <xinming> scook0: see the example

[08:42] <xinming> scook0: written in S04

[08:42] <luqui> ahh

[08:43] <luqui> don't think that :foo:bar:baz(2) gives :foo(2) :bar(2) :baz(2)

[08:43] <luqui> it gives :foo(1):bar(1):baz(2)

[08:43] <xinming> luqui: what it will give?

[08:43] <xinming> hmm...

[08:43] <luqui> since :foo is equivalent to :foo(1)

[08:44] <luqui> though maybe that's bool::true these days

[08:44] <xinming> ?eval :b:c:d

[08:44] <evalbot6> Error:  unexpected ":" expecting word character, "(", "[", "<<", "<", "\171", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:44] <luqui> we're pretty inconsistent on that one

[08:44] <luqui> ?eval :b

[08:44] <evalbot6> ('b' => 1) 

[08:44] <xinming> luqui: thanks. :-)

[08:45] <scook0> I suppose the true/false '1'/'' thing is tricky because of all the history and culture

[08:46] <luqui> yeah

[08:47] <xinming> luqui: could you pleaes give me a example of "Delegation"

[08:47] <luqui> from eg. S12?

[08:47] <xinming> luqui: yeap

[08:47] <luqui> hmmm... I'm not used to programming with it

[08:48] <luqui> let's see, where would you want to send some methods to one object, and other methods to another

[08:48] <scook0> the concept is simple though

[08:48] <luqui> scook0, why don't you explain

[08:48] <scook0> :)

[08:49] <scook0> oh, explaining is harder... :) let me think

[08:49] <xinming> scook0: too simple so that you don't with to explain. T_T

[08:49] <scook0> it mostly just saves you from having to type

[08:49] <xinming> scook0: you can say that why this concept comes out first. ;-)

[08:50] <scook0> method foo (*@_, *%_) { $.member.foo(*@_, *%_) }

[08:50] <scook0> all over the place

[08:50] <scook0> if I want my class to have some method

[08:51] <scook0> but all I would be doing is forwarding that method to one of my members

[08:51] <scook0> then I can just delegate it

[08:51] <scook0> rather than writing a wrapper method explicitly

[08:52] <scook0> (for my next trick, I will also claim that monads are simple ^_^)

[08:54] <xinming> scook0: Is there any code example. :-)

[08:54] <luqui> you could scrape CPAN for Class::Delegation

[08:55] <xinming> luqui: thanks

[09:01] <luqui> ?eval my $x = { 1 };  $x.pairs

[09:01] <evalbot6> Error: Not a keyed reference: <Scalar> 

[09:01] <luqui> oh boy, it recompiled

[09:03] <luqui> ?eval my $x = { a => 1 };  $x.pairs

[09:03] <evalbot6> Error: Not a keyed reference: <Scalar> 

[09:04] <luqui> ?eval my $x = hash( a => 1 );  $x.pairs

[09:04] <evalbot6> Error: Not a keyed reference: <Scalar> 

[09:08] <xinming> luqui: recompiled with wrong code. :-)

[09:08] <luqui> working on fixing that

[09:26] <luqui> okay, it's actually fixed now :-)

[09:26] <xinming> hmm... I am actually confused by delegation now. :-S

[09:27] <luqui> it's okay.  it's one of those things that you don't really have to learn

[09:27] <luqui> like everything else in perl 6 :-)

[09:28] <xinming> luqui: Hmm, In fact, Perl 6 will be make delegation as a "feature", I think This is useful... and has it's advance. So I wish to learn it.

[09:28] <xinming> hm, I just wish to know, why It's needed, rather than how to use it.

[09:28] <xinming> read the example in Class::Delegation But not help much

[09:29] * luqui has never used it, so he wouldn't know

[09:35] <svnbot6> r6353 | luqui++ |  r204@feather:  fibonaci | 2005-08-19 11:24:40 +0200

[09:35] <svnbot6> r6353 | luqui++ |  Okay, actually fixed the sub {1}.pairs bug this time... I hope.

[09:35] <svnbot6> r6354 | qtplatypus++ | Documentation for Draft GC API, usial svn props.

[09:37] <QtPlatypus> ?eval sub test(*@_) {say @_};test(a => "a",b => "b")

[09:37] <evalbot6>  bool::true 

[09:37] <QtPlatypus> ?eval sub test(*@_) {[~] @_};test(a => "a",b => "b")

[09:37] <evalbot6> undef 

[09:39] * QtPlatypus will have to write a test for that.

[09:44] * luqui doesn't understand that one

[09:44] <luqui> ?eval sub test(*@_) { say +@_ }; test(a => "a", b => "b")

[09:44] <evalbot6> 0 bool::true 

[09:44] <luqui> ahh

[09:44] <QtPlatypus> It should be 4

[09:44] <luqui> it should be 2

[09:45] <QtPlatypus> One of each pair?

[09:45] <luqui> yeah

[09:45] <QtPlatypus> ?eval (a => "a",b => "b")

[09:45] <evalbot6> (('a' => 'a'), ('b' => 'b')) 

[09:45] <QtPlatypus> ?eval +(a => "a",b => "b")

[09:45] <evalbot6> 2 

[09:45] <QtPlatypus> Ok.

[09:45] <QtPlatypus> That makes sence.

[09:46] <scook0> currently the binding code assumes all pairs are named arguments

[09:46] <scook0> and any leftover ones get put in the slurpy hash

[09:46] <luqui> which they should... if it is declared

[09:46] <scook0> (they never get anywhere near the slurpy array)

[09:46] <QtPlatypus> But the slurpy array should slurp them up if its there.

[09:46] <luqui> on the other hand, there have been complaints that pairs are too special, which makes them awkward to work with

[09:47] <luqui> so maybe we should make them more special, so that people understand that they're not supposed to "work with" them

[09:47] <luqui> that is, separate the distinction between a hash pair and a named argument pair

[09:47] <scook0> also, if there isn't a slurpy hash, then currently (in Pugs) they just get dropped

[09:48] <luqui> Hmm, would it irritate anyone here to separate those?

[09:49] <scook0> hmm

[09:49] <luqui> foo(a => "b", :c("d"))  # gets a Pair (a => b)  and puts "d" into the argument $c

[09:49] <QtPlatypus> Yes.

[09:49] <luqui> how come?

[09:50] <QtPlatypus> because 

[09:50] <luqui> (maybe that's not the right separation, I'm just idea fishing right now)

[09:50] <QtPlatypus> there the same thing.

[09:50] <scook0> you'd still need some way to splat normal-pairs in as named args, of course

[09:50] <luqui> do you follow p6l?

[09:50] <luqui> yeah, like, oh, say, a named() function

[09:50] <QtPlatypus> And if I ever wish to send in a pair into a function I'll not be able to to day.

[09:51] <QtPlatypus> do that.

[09:51] <luqui> hmm?

[09:51] <luqui> that sentence didn't parse at the end

[09:51] <QtPlatypus> Sorry.  I'll rewrite.

[09:52] <QtPlatypus> If I understand your stament, it will be impossable to write a function that takes pairs as an argument without them being a named argument pair.

[09:52] <scook0> actually, the normal-pairs/special-pairs distinction is reminding me of the sets/junctions thing

[09:53] <luqui> you can, but the distinction is made on the caller side

[09:53] <luqui> a => b  # passes a pair in a positional

[09:53] <luqui> :a(b)  # passes a pair as named

[09:53] <luqui> so :a(b) would be short for named(a => b) or something like that

[09:54] <QtPlatypus> What would %hash=(:a(b),:b(c)) # Mean?

[09:55] <luqui> I was thinking about that, and we could go either way

[09:55] <luqui> we face a cognitive problem if we make it DTRT

[09:55] <scook0> it depends whether you want to blur the distinction outside of calls

[09:55] <scook0> or force people to write it the 'correct' way

[09:55] <luqui> (so :a(b) is just a pair unless I'm using it in a sub call?  wtf?)

[09:56] <luqui> yeah, or we can make that form strictly for named arguments

[09:56] <luqui> and I think it's an important decision, but I don't know the right answer

[09:56] <scook0> I wonder whether we should generalise the concept of 'magically-behaving-values'

[09:56] <luqui> TIMTOWTDI says we should DTRT (IMHO :-)

[09:56] <scook0> i.e. junctions...adverbial-pairs...(what else?)

[09:57] <luqui> those are the two at the top of my list :-)

[09:57] * QtPlatypus thinks that the :a(a) form is too usefull to not have it as a pair creator.

[09:57] <luqui> okay, that's a fair stance

[09:58] <luqui> it seems more perlish to do it that way, too

[09:58] <scook0> QtPlatypus: what sort of things did you have in mind?

[09:58] <scook0> maybe we need to introduce a /new/ magical-pair syntax (shudder)

[09:58] <luqui> somehow I doubt that

[09:59] <scook0> :)

[09:59] <luqui> I'm just wondering about this one:

[09:59] <luqui> my $x = named(a => 1)

[09:59] <luqui> is named the magical thing, that demagicalizes itself once it's not in a call?

[10:00] <QtPlatypus> Could it be a trait?  my $x = (a => 1) but named

[10:00] <luqui> that'd be a role, but maybe that's doable

[10:00] <scook0> that's an interesting idea

[10:00] <luqui> what I'd really like, though, is to make named-argument passing visible exactly where the call is

[10:01] <luqui> that is:  foo($x, $y, $z)   # no named arguments, for sure!

[10:01] <luqui> no matter what is in $x, $y, and $z

[10:02] <QtPlatypus> Sure, but what if you wish to create a set of possisional arguments.

[10:02] <luqui> for example?

[10:03] <xinming> hmm, for better understanding of delegation, So could anyone rewrite the example in Class::Delegation ?

[10:03] <scook0> luqui: I shudder to think of what might happen if $z contained a junction of (pair|non-pair)

[10:03] <scook0> (that is, if named-args could be invisible)

[10:04] <xinming> the example after "The problem(s) with attribute-based hierarchies"

[10:04] <luqui> well, first of all, it would thread into two calls

[10:04] <luqui> yeah, here's a pathological example:

[10:04] <luqui> sub (?$x, ?$y) { say "$x $y" }

[10:04] <QtPlatypus> For example trans is defined as taking pairs/possisionals, if you wish to preroll the translation table.

[10:05] <luqui> my $z = (x => 1) | 2

[10:05] <scook0> xinming: you mean rewrite in Perl6?

[10:05] <xinming> using perl 6 syntax.

[10:05] <xinming> scook0: yes,

[10:05] <luqui> foo(3, $z)     # "1 " | "3 2"

[10:05] <luqui> yikes

[10:06] <scook0> I suppose:

[10:06] <scook0> has $:left_front_wheel handles <steer drive brake>

[10:06] <luqui> QtPlatypus: why couldn't you use *%_ for that?

[10:07] <scook0> has $:left_rear_wheel handles 'brake'

[10:07] <scook0> etc

[10:08] <QtPlatypus> I suppose in thaqt case *%_ is the best.

[10:08] <scook0> then when somebody does $mycar.brake

[10:08] <scook0> it should automatically call $:left_front_wheel.brake and $left_rear_wheel.brake

[10:08] <scook0> without you having to write a brake method for Car

[10:09] <xinming> :-) Now~~~, I know~~~

[10:09] <QtPlatypus> And the car makes a hard left turn.

[10:10] <xinming> ..

[10:10] <scook0> QtPlatypus: :)

[10:10] <xinming> so, the exactly should be...

[10:11] <xinming>  has $:left_front_wheel handles <steer drive brake> = Wheel.new;

[10:11] <xinming> right?

[10:11] <xinming> the grammar for delegation is hard to understand first.

[10:11] <xinming> thanks

[10:12] <GeJ> Will the Class::Delegation ``concepts'' be included in Perl6' syntax one way or another, or will a module be needed?

[10:13] <xinming> GeJ: I don't think the module is needed, In fact, It's a feature in perl 6

[10:13] <scook0> GeJ: what do you mean by 'concepts'?

[10:16] <GeJ> Well, if I get it correctly, Class::Delegation is syntactic sugar to proxify method call from the called object to delegated objects or other methods.

[10:17] <scook0> well, S12 isn't clear about delegating to other methods

[10:18] <scook0> but afaict, delegating methods to members should be built-in (no modules needed)

[10:18] <scook0> unless somebody decides to take it out

[10:19] <scook0> but even then, a module-based solution look much more integrated than in p5

[10:19] <GeJ> While, it saves a few lines of code, I'm not sure to see the practical point. Dispatching a method call to another method is probably a bad interface design and/or a violation of the Liskov Substitution principle

[10:21] <scook0> GeJ: I'm not sure how it would violate LSP

[10:21] <scook0> unless the delegated method fails to uphold the contract that you're supposed to be implementing

[10:22] <wolverian> S12 has a bit about delegation to methods

[10:23] <scook0> wolverian: aye, but I'm not sure whether it talks about one method name to another, or delegating to the /result/ of a method call

[10:24] <wolverian> the latter.

[10:24] <wolverian> but I think you can do it with an anonymous role:

[10:24] <scook0> that was my suspicion

[10:24] <GeJ> scook0: Let's assume that (sorry, I'll use Perl5 syntax as I'm not familiar with Perl6' one yet), $obj->my_first_method() is 'redirected' to $obj->my_other_method(). In this case $obj must be a child class of something else otherwise I don't see the point in doing the same thing twice (DRY principle)

[10:25] <wolverian> oh, well, maybe not.

[10:25] <GeJ> If so, I assume that $obj's parent class has two distinct methods (my_first_method and my_other_method) that do two different things

[10:26] <GeJ> having $obj merging the two methods into one is a LSP violation, isn't it?

[10:26] <xinming> GeJ: The problem is caused by inheritance... hmm, Just read the doc in Class::Delegation

[10:26] <scook0> GeJ: I agree that that situation would be an unwise use of delegation

[10:27] <scook0> but there are other situations where it is useful

[10:27] <wolverian> hmm. do we have anonymous methods?

[10:27] <scook0> wolverian: pretty sure we do

[10:28] <wolverian> very well, then: method foo handles<bar> { method { ...actual code... } } 

[10:28] <GeJ> scook0: do you have an example in mind, because right now, all I'm thinking about is the one I gave.

[10:28] <wolverian> of course, you can also just wrap &bar and not call() it 

[10:29] <scook0> GeJ: not off the top of my head, but try looking at the docs for (cpan) Class::Delegation

[10:29] <wolverian> &bar.wrap:{ &foo.goto } # or so

[10:29] <GeJ> scook0: oki, I will. :)

[10:29] <xinming> scook0: by the way, how do we get the attribute name in delegation class? $?CALLER?

[10:29] <xinming> has $:tail handles 'wag'; method wag (*@args is context(Lazy)) { $:tail.wag(*@args) }

[10:30] <scook0> xinming: you mean the method name that was originally used?

[10:30] <xinming> hmm, This is example from S12, But how about other attributes handles 'was' ?

[10:30] <scook0> not sure if $?CALLER would work

[10:31] <xinming> s/was/wag/

[10:31] <scook0> it depends whether the wrapper method makes itself invisible to $?CALLER

[10:31] <luqui> my named arguments proposal is in p6l

[10:32] <xinming> seen autrijus 

[10:32] <jabbot> xinming: autrijus was seen 4 hours 47 minutes 8 seconds ago

[10:33] <scook0> luqui: using special-forms rather than magical-values is interesting

[10:33] <scook0> less possibility for accidental weirdness

[10:33] <luqui> exactly

[10:34] <luqui> that's the point behind default semantics for junctions, too

[10:34] <scook0> it might make propeller-headed things slightly harder

[10:34] <scook0> but it's ok as long as they're possible

[10:34] <luqui> that is, instead of "if $x == 1 | 2 | 3 {...}" creating a magical value and threading it over an operator

[10:34] <luqui> it is just taken as a special form for "if $x == 1 || $x == 2 || $x == 3"

[10:35] <luqui> and $x = 1 | 2 | 3 is illegal

[10:35] <luqui> unless "use junctions" is on or $x is declared as a Junction

[10:35] <scook0> so people can get the basic benefits of junctions

[10:36] <luqui> without having to think about them before they understand

[10:36] <scook0> without suddenly having no idea what their code means in the presence of unexpected junctions

[10:36] <QtPlatypus> luqui: By special form you mean "short cut for"?

[10:37] <luqui> yeah

[10:37] * QtPlatypus normally thinks of special forms as things you can't evaluate by subsitution.

[10:37] <luqui> for exampe?

[10:37] * luqui likes examples, clearly :-)

[10:39] <xinming> subtype EvenNum   of Num where { $^n % 2 == 0 }; my EvenNum $n; $n = 3; Will this be an warning or an error?

[10:39] <luqui> error

[10:39] <scook0> otherwise what's the point?

[10:39] <QtPlatypus> With a normal (non special form), you can evaluate by replacing the function with its return values untill the return values.

[10:40] <xinming> luqui: is your answer for me please?

[10:40] <luqui> xinming, yes

[10:40] <luqui> can you show me an example of a special form?

[10:40] <QtPlatypus> For example if

[10:41] <luqui> "if"?

[10:41] <luqui> if boolean_expression(), &code;  # ?

[10:41] <luqui> that's just a regular function

[10:42] <scook0> 'if' might be a bad example

[10:42] <QtPlatypus> Depends on your langague.

[10:42] <broquaint> ?evalbot6 our $foo; sub f { temp

[10:42] <QtPlatypus> Ok, conditional and.

[10:43] <luqui> ?eval 42

[10:43] <evalbot6> 42 

[10:43] <luqui> QtPlatypus, ahh

[10:43] <luqui> gotcha

[10:43] <broquaint> ?eval our $foo; sub f { temp $foo = 'new value'; say $foo } $foo = 'old value'; say $foo; f; say $foo

[10:43] <evalbot6> old value new value new value bool::true 

[10:43] <luqui> well, we're just calling those "thunk expressions", and there's no reason why you can't write your own these days

[10:43] <luqui> but I see your point

[10:44] <broquaint> Why isn't $foo being dynamically scoped with that temp()?

[10:44] <QtPlatypus> With something normal like "+" it doesn't mattor if you evaluate both of the sides untill you get a solution.  But it you do the same thing with and you may end up triggering side effects.

[10:44] <luqui> broquaint, bug

[10:44] <broquaint> Ah, thought it might be :/

[10:44] <broquaint> Thanks, luqui.

[10:44] <luqui> let's see if it's tested yet

[10:44] <broquaint> I don't believe it is.

[10:45] <QtPlatypus> luqui: As long as you have lambda (in perl6 terms sub) you can define most of your specal forms in terms of that.

[10:45] <broquaint> It looks like it's tested for lexicals but not package vars.

[10:46] <luqui> mind writing a test?

[10:46] <broquaint> Will do :)

[10:46] <pdcawley_> Is &?CALLER_CONTINUATION working yet?

[10:47] * luqui dunnos

[10:48] * pdcawley_ grins, sorry, it's just an intermittent question I ask.

[10:49] <QtPlatypus> pdcawley_: You wish to compleat your puzzel solver?

[10:49] <pdcawley_> Yeah.

[10:49] <pdcawley_> And make it a little less pessimal.

[10:49] <QtPlatypus> Do we have raw bitstrings yet?

[10:49] * pdcawley_ reboots, laptop playing up.

[10:50] <broquaint> What is it to commit? svk submit t/var/temp.t # ?

[10:51] <integral> pdcawley_: if t/unspecced/cont.t works, then yes

[10:51] <theorbtw1> ?eval &?CALLER_CONTINUATION

[10:51] <evalbot6> Error: Undeclared variable: "&?CALLER_CONTINUATION" 

[10:51] <QtPlatypus> snv add t/var/temp.t

[10:51] <QtPlatypus> svn i mean

[10:51] <QtPlatypus> and then svn ci

[10:51] <theorbtw1> I think that's a "no", pdcawley.

[10:51] <integral> ?eval sub f() { &?CALLER_CONTINUATION } f()

[10:51] <evalbot6> \sub {...} 

[10:51] <theorbtw1> Oh, right.

[10:51] <broquaint> Thanks, QtPlatypus :)

[10:51] *** theorbtw1 is now known as theorbtwo

[10:51] <pdcawley_> ?eval sub f() { &?CALLER_CONTINUATION } f().("Bibble!")

[10:51] <evalbot6> 'Bibble!' 

[10:51] <integral> the bug is deep in the old evaluator

[10:52] <pdcawley_> Yeah, so I gathered.

[10:52] <integral> hmm, maybe it works with JS since that uses CPS

[10:52] <pdcawley_> Possibly -- the old evaluator could only do escape continuation couldn't it?

[10:53] <pdcawley_> Fecking laptop, won't even reboot cleanly...

[10:53] * theorbtwo wonders... how usable is the output of the JS backend?

[10:53] * pdcawley_ hits the power switch and has done with it.

[10:53] <theorbtwo> Could I start programming my google maps hacks in p6?

[10:54] <broquaint> Yes, theorbtwo, do it!

[10:54] * luqui is excited about using Flash as a perl 6 graphics environment

[10:55] <broquaint> How's that, luqui? My mind is boggling over here.

[10:55] <integral> ?eval sub h($c) { $c.(5) } sub g($c) { h($c) } sub f() { h(&?CALLER_CONTINUATION) } f()

[10:55] <evalbot6> 5 

[10:56] <xinming> my $ref; $ref = { $ref };

[10:56] <luqui> broquaint, JS == ActionScript

[10:56] <xinming> what's this example should do?

[10:57] <broquaint> I thought ActionScript was a horribly limited version of JS, or was that back in the bad old days?

[10:57] <luqui> rather, JS (<=) ActionScript

[10:57] <xinming> hmm, also call the sub ref

[10:57] <xinming> $ref();

[10:57] <luqui> yeah, that used to be the case, but in Flash MX it's fully compatible

[10:57] <scook0> xinming: infinite recursion, I imagine

[10:57] <broquaint> Most nifty.

[10:57] <theorbtwo> ?eval my $ref; $ref = { $ref };

[10:57] <evalbot6> \sub {...} 

[10:57] <svnbot6> r6355 | broquaint++ | * Added temp() test for package vars (which isn't work atm due to a bug).

[10:57] <svnbot6> r6356 | broquaint++ | * Forgot to update the test number from previous commit :/

[10:57] <theorbtwo> ?eval my $ref; $ref = { $ref }; $ref.();

[10:57] <evalbot6> \sub {...} 

[10:57] <theorbtwo> Right, though so.  Creates a sub that, when called, returns itself.

[10:58] <scook0> oh, sorry

[10:58] <theorbtwo> Try my $ref; $ref = { $ref.() }; $ref.(); on a local copy, though.

[10:59] <theorbtwo> I think evalbot is supposed to have inf-loop protection, but I'd rather not test it.

[10:59] <luqui> you don't have to declare separately anymore

[10:59] <autrijus> luqui: I like your proposal.

[10:59] <luqui> thanks

[10:59] <autrijus> the pair treatment is the single one I was unhappy from the hackathon

[10:59] <luqui> you mean the named arguments one, or the insane one?

[10:59] <autrijus> but I can't find a counterproposalthat would do what larry wanted.

[10:59] <scook0> theorbtwo: I think it just aborts if you take too much time/memory

[10:59] <autrijus> the named arg one.

[10:59] <luqui> ahh

[11:00] <autrijus> I ignored the insane one.

[11:00] <autrijus> it's clearly insane.

[11:00] <luqui> everybody did

[11:00] <luqui> good for them

[11:00] <clkao> ?

[11:00] <clkao> autrijus: don't ignore yourself!

[11:00] <broquaint> Anyone want to take a stab at making the parser from HOP work? I've already converted it to p6 but am coming up against invisible and probably scary bugs :/

[11:00] <autrijus> clkao: why, I did much good despite myself

[11:01] <autrijus> broquaint: ooh, check it in somewhere?

[11:01] <clkao> 18:57 < autrijus> I ignored the insane one.

[11:01] <luqui> HOP?

[11:01] <autrijus> clkao: yeah, I mean I did much good while ignoring myself

[11:01] * autrijus finally finished /sbin/dump and dd sessions

[11:01] <autrijus> everything backed up

[11:01] <clkao> oh well

[11:01] <broquaint> Higher Order Perl.

[11:02] <luqui> ahh

[11:02] <obra> yay, autrijus 

[11:02] * luqui wants that book

[11:02] <autrijus> I wonder if I should take this chance to set up dual booting OSX :)

[11:02] <luqui> wait--

[11:02] <broquaint> Anywhere in particular, autrijus? It's only the Stream/Parser/Lexer modules and expr-parser.pl at the moment.

[11:02] <luqui> --n/m

[11:03] <theorbtwo> autrijus: AFAIK, the state of the art with OSX/x86 requires that it take up a whole HDD, so you probably can't do that with a laptop.

[11:03] <luqui> autrijus, have you figured out/found a way to solve those type equations?

[11:03] * QtPlatypus whants that as well.

[11:04] * luqui is completely stumped

[11:04] <autrijus> theorbtwo: if so, a certain friend of mine noted something that is apparently beyond the state of art :)

[11:05] <theorbtwo> Oh.

[11:05] <autrijus> broquaint: examples/algorithms/ ? a new examples/ dir?

[11:05] <theorbtwo> Nevermind, then.

[11:06] <xinming> in perl 5, $x = \$x might cause memory leak, how about perl 6?

[11:06] <QtPlatypus> xinming: Nope

[11:06] <luqui> xinming, depends on the backend

[11:07] <broquaint> I'll check it into examples/hop6/ for now, autrijus.

[11:07] <autrijus> luqui: what type equations?

[11:07] <QtPlatypus> The standard backend will do proper GCing though.

[11:08] <luqui> Int.does(::T);   ::T.does(Str);  

[11:08] <luqui> that make type inferencing work

[11:08] <autrijus> luqui: why not have Int unify with ::T

[11:09] <autrijus> namely, Int.does(Str)

[11:09] <luqui> It's more complicated than that

[11:09] <autrijus> ok..?

[11:09] <luqui> Int.does(::T);  Str.does(::T);   ::T.does(Num);   # failure

[11:09] <autrijus> why does it need to fail?

[11:09] <luqui> after the second "step" (if that's the approach), ::T is Int (+) Str

[11:10] <luqui> because Str doesn't do Num

[11:10] <luqui> and ::T says it can accept Strs

[11:11] <autrijus> and what do you want ::T to be?

[11:11] <luqui> in the failure case?

[11:11] <autrijus> yeah

[11:11] <luqui> failure :-)

[11:11] <luqui> impossible to solve, that's why it failed

[11:12] <luqui> at first it seems like a logic programming problem, but it's really not

[11:12] <autrijus> it's not. have you read the H-W algorithms?

[11:12] <autrijus> er, H-M

[11:12] <luqui> nope

[11:12] <autrijus> please do.

[11:12] <luqui> give me more letters

[11:12] <autrijus> can't really talk about type inferencing without that :)

[11:12] <autrijus> Hindley Milner

[11:13] <luqui> okay, that's what I was looking for

[11:13] <luqui> mmm... literature

[11:13] <autrijus> after that, Pierce and Turner's Local Type Inference.

[11:13] <autrijus> after that, the Colored variant.

[11:13] <autrijus> then it'll be much clearer :)

[11:13] * luqui gets out his text editor

[11:13] <autrijus> (GHC uses all those techniques)

[11:14] <luqui> Perl 6's inference is a bit different from haskell's, but I'm sure the algorithms will only need slight modifications

[11:14] <autrijus> the colored variant is specifically designed to handle subtypes

[11:14] <autrijus> as well as generics

[11:14] <luqui> schweet

[11:15] <autrijus> Scala uses it too, and Scala's type system is remarkably similiar to p6.

[11:15] * luqui begins reading

[11:15] <autrijus> push for Devel::TypeCheck's release -- it implements H-M

[11:15] <autrijus> for p5

[11:16] <autrijus> so that may give you something to play with

[11:21] <scook0> autrijus: roughly speaking, how much of the current code is PIL2 intended to make obsolete?

[11:21] <svnbot6> r6357 | broquaint++ | * Initial commit of the p6-ified parser from MJD's seminal Higher Order Perl.

[11:21] <svnbot6> r6357 | broquaint++ | * NB - It doesn't work at the moment due to invisible grue-like bugs.

[11:21] <svnbot6> r6358 | broquaint++ | * This is needed if the HOP code is to be used (I think).

[11:21] <autrijus> scook0: roughly speaking, all the Compile.hs code and Codegen.hs code.

[11:21] <autrijus> scook0: AST.Internals needs to be retrofitted

[11:21] <autrijus> everything else will probably stay, maybe refactored a bit.

[11:21] <scook0> autrijus: I see, thanks

[11:24] <autrijus> dinner &

[11:26] *** ods15_ is now known as ods15

[11:38] <svnbot6> r6359 | scook0++ | * Some docs for Lexer.hs and Parser/Types.hs

[11:38] <svnbot6> r6359 | scook0++ | * Tweak DrIFT/Binary.hs so it doesn't confuse poor Haddock

[11:53] <tewk>   var key = pair.key.toNative();

[11:53] <tewk>   if(!this.entries[key]) this.num_of_entries++;

[11:53] <tewk>   this.entries[key] = pair;

[11:53] <tewk> sorry bad paste

[12:05] <[1]equinox> hi

[12:05] <Limbic_Region> salutations

[12:05] <[1]equinox> has anybody tried to make an exe from a perl6 scripts?

[12:05] <Limbic_Region> yes

[12:06] <Limbic_Region> though not recently

[12:06] <[1]equinox> and how does its speed compare with perl?

[12:06] <Limbic_Region> that's a loaded question

[12:06] <[1]equinox> what do you mean by loaded?

[12:07] <Limbic_Region> I mean that the resulting .exe isn't the same thing as what will be native executables

[12:07] <Limbic_Region> it is more like proof of concept

[12:07] <Limbic_Region> so one shouldn't be looking at speed at that point

[12:08] <Limbic_Region> p6 is still very much in development

[12:08] <[1]equinox> don't worry

[12:08] <Limbic_Region> if you want to do speed comparisons - you should be comparing parrot and p5

[12:08] <[1]equinox> I am still interested

[12:08] <[1]equinox> I know it is not finished

[12:09] <[1]equinox> and what about that speed comparison?

[12:09] <Limbic_Region> not even sure if it works currently

[12:09] <[1]equinox> I won't make a touch and eternal and diminishing judgement

[12:12] <Limbic_Region> I am actually busy with $work

[12:12] *** ods15_ is now known as ods15

[12:13] <QtPlatypus> pugs running on its standard runtime is slower the p5 but catching up.

[12:13] <QtPlatypus> pugs running using the parrot back end is faster the the standard backend.

[12:14] <QtPlatypus> parrot in some sitatations is faster then p5 and in other situations slower.

[12:14] <QtPlatypus> At the moment pugs isn't realy optimized for speed rather then actually solving the problems.

[12:15] <QtPlatypus> In time I expect the mature end point of p6 to run the pants of p5.

[12:16] <QtPlatypus> Everything I have said may be inaccurate.

[12:16] <QtPlatypus> [1]equinox: Does that answer your question?

[12:17] <[1]equinox> yes, partly

[12:18] <[1]equinox> Do you know any quantitative data?

[12:18] <acme__> try it for yourself ;-)

[12:18] <[1]equinox> There is some difficulties

[12:18] * acme__ notes that premature optimisation is the root of all evil

[12:18] <[1]equinox> I don't have the most recent binaries

[12:19] <[1]equinox> let us be careful with religion.

[12:19] * QtPlatypus nods to acme__

[12:19] <[1]equinox> does anyone know a source where I can download it?

[12:19] <QtPlatypus> http://dev.perl.org/perl6/

[12:20] <[1]equinox> not source

[12:20] <[1]equinox> binary

[12:20] <[1]equinox> typo

[12:20] <QtPlatypus> It gives you insructios on where you can download both parrot and pugs.

[12:20] <[1]equinox> the binary I found not recent enough.

[12:20] <[1]equinox> It was compiled on Aug 10.

[12:22] <[1]equinox> do you know how to set the location of libs in PUGS?

[12:23] <QtPlatypus> use libs "blah";

[12:23] <QtPlatypus> Like in perl5

[12:29] <[1]equinox> ok

[12:29] <broquaint> q

[12:29] <[1]equinox> PERL6LIB should work, should not it?

[12:29] <castaway> broquaint!

[12:30] <QtPlatypus> broquaint: Yes broquaint ?

[12:30] <QtPlatypus> [1]equinox: I don't know eather way.

[12:30] <broquaint> Nothing, QtPlatypus, am getting lost in irssi :/

[12:30] <QtPlatypus> Test it and see.

[12:30] <broquaint> Hey, castaway, how goes it?

[12:30] <QtPlatypus> N/P

[12:30] <[1]equinox> it does not

[12:31] <castaway> we moving next week!

[12:31] <castaway> s/we/we're/

[12:31] <[1]equinox> sorry, it does work

[12:31] <broquaint> Wow! Congrats! :)

[12:32] * castaway bounces.

[12:32] <broquaint> We are you moving to?

[12:33] <castaway> Abingdon 

[12:33] <castaway> (Oxon)

[12:33] <[1]equinox> I could be moving to Mars

[12:33] <[1]equinox> you could be moving to Mars

[12:33] <broquaint> Nice one, c :)

[12:34] <[1]equinox> where is that?

[12:34] <broquaint> Oxfordshire, England, dear chap.

[12:35] <[1]equinox> ok, tell me where is Szalkszentmrton

[12:36] <castaway> not a clue

[12:36] * castaway puts the group Camel back on the shelf ..,)

[12:37] <[1]equinox> ok

[12:37] <[1]equinox> it is not a sine

[12:37] <broquaint> I'm guessing somewherein Hungary, [1]equinox.

[12:38] <[1]equinox> what help did you make use of?

[12:38] <[1]equinox> correct, broquaint

[12:39] <broquaint> Teh Google of course :)

[12:40] <[1]equinox> well, you can use the web efficiently

[12:40] * QtPlatypus asks if Oxford is in Oxfordshire 

[12:42] <castaway> usually, yes

[12:42] <broquaint> It is indeed, QtPlatypus. As Cambridge is in Cambridgeshire. The naming of some English counties isn't terribly imaginitive.

[12:42] <castaway> *g*

[12:42] <castaway> Theres no Wilts in Wiltshire tho!

[12:43] <QtPlatypus> Are there pigs in Devonshire?

[12:43] <castaway> quite likely

[12:46] <pjcj> the hogs are in Hampshire

[12:47] <[1]equinox> is there File::Copy in perl6?

[12:48] <castaway> theres a perl6?

[12:48] <QtPlatypus> There is a Perl6 but there isn't a perl6.

[12:48] <broquaint> Nope, [1]equinox. Although you could possibly just: use perl5:File::Copy; # Assuming that's the correct syntax.

[12:49] <[1]equinox> or is copy part of Perl6?

[12:50] <broquaint> Probably not, [1]equinox. It could possibly be in a File:: type module though.

[12:51] * QtPlatypus mmms to himself sub cp ($sce,$des) { open "<$sce" ==> open ">$des" }

[12:51] <QtPlatypus> Would that work?

[12:51] <QtPlatypus> Actually

[12:53] <QtPlatypus> I can't see why it wouldn't.

[12:53] * QtPlatypus mmms to himself sub cp (Str $sce,Str $des) { open("<$sce") <== open(">$des") }

[12:53] <QtPlatypus> Or are we using :r and :w now?

[12:54] <QtPlatypus> sub cp (Str $sce,Str $des) { open($sce,:r) ==> open($des,:w) }

[12:58] <[1]equinox> have you ever got this?

[12:58] <[1]equinox> pugs: user error (Cannot evaluate in Ghc)

[12:58] <QtPlatypus> Nope.

[12:59] <QtPlatypus> Pugs doesn't seem to know about ==>

[13:00] <[1]equinox> D:\extracted\pugs>pugs -BGhc D:\extracted\pugs\examples\functional\member.p6

[13:00] <[1]equinox> pugs: Internal error:

[13:00] <[1]equinox>     Unrecognized construct: App (Var "&member") Nothing [Pos (MkPos "D:\\extract

[13:00] <[1]equinox> ed\\pugs\\examples\\functional\\member.p6" 5 12 5 17) (Val (VStr "foo")),Pos (Mk

[13:00] <[1]equinox> Pos "D:\\extracted\\pugs\\examples\\functional\\member.p6" 5 19 5 20) (Val (VInt

[13:00] <[1]equinox>  1)),Pos (MkPos "D:\\extracted\\pugs\\examples\\functional\\member.p6" 5 22 5 27

[13:00] <[1]equinox> ) (Val (VStr "foo")),Pos (MkPos "D:\\extracted\\pugs\\examples\\functional\\memb

[13:00] <[1]equinox> er.p6" 5 29 5 30) (Val (VInt 3)),Pos (MkPos "D:\\extracted\\pugs\\examples\\func

[13:00] <[1]equinox> tional\\member.p6" 5 32 5 33) (Val (VInt 4)),Pos (MkPos "D:\\extracted\\pugs\\ex

[13:00] <[1]equinox> amples\\functional\\member.p6" 5 35 5 40) (Val (VStr "bar"))]

[13:00] <[1]equinox> pugs has a lot to develop

[13:01] <QtPlatypus> Looks like the GHC backend doesn't understand that code.  Use another backemd

[13:01] <QtPlatypus> end

[13:03] <[1]equinox> are pir and parrot the same?

[13:07] <broquaint> Parrot is the virtual machine and PIR is its language (or at least, the language which compilers for Parrot should target).

[13:12] <[1]equinox> ok

[13:18] <tewk> So I'm trying to understand the directory structure of pugs/perl5 org.perl6.metamodel looks to be an old java implementation, is it used for reference.

[14:22] <Limbic_Region> [1]equinox ping

[14:22] <Limbic_Region> You are interested in a windows binary?

[14:23] <Limbic_Region> I believe there are links to binary builds from the pugs homepage at http://pugscode.org

[14:23] <Limbic_Region> but if not, Jonathan does *mostly* daily binary builds of pugs and parrot on windows at http://www.jwcs.net/~jonathan/perl6/

[14:24] <Limbic_Region> emailing him that it is out of date usually gets it updated though, hence the *mostly*

[14:27] <fglock> autrijus: ping

[14:28] * Limbic_Region seconds that

[14:28] <Limbic_Region> autrijus ping

[14:29] * Limbic_Region hesitates to point out a problem as it will likely involve being volunteered to provide the solution

[14:29] <fglock> Are traits applied to a Container's cell?

[14:29] <fglock> Limbic_Region: most likely :)

[14:30] <dudley> tewk: the org.perl6.metamodel as it is now is not used for anything

[14:31] <Limbic_Region> fglock - well, the fix is easy provided that there is a p6 version of File::Find

[14:31] <Limbic_Region> but I am still keeping my mouth shut about the problem for now ;-)

[14:36] <Limbic_Region> geoffb ping

[14:42] * fglock googles for instance traits

[14:57] <stef_> I have not followed recent events, is pge supported in the main trunk?

[14:59] <broquaint> If you have parrot, yes.

[15:00] <stef_> the current parrot trunk, I meant....

[15:01] <stef_> I think it was separate

[15:05] <Limbic_Region> Ok - I am going to problem report and run so as to avoid getting volunteered to fix

[15:05] <Limbic_Region> with the ever changing specifications - there is a fair amount of code in the examples directory that no longer works

[15:06] <Limbic_Region> if we care that the code is broken we don't have to do anything but ...

[15:06] * Limbic_Region ducks

[15:06] * Limbic_Region runs

[15:06] * Limbic_Region finds cover

[15:06] <broquaint> BOOOOOOOOOOOOOM!!!!!!!!!!

[15:08] <xinming> ?eval 3+5

[15:08] <evalbot6> 8 

[15:09] <xinming> hmm... whose bot is this by the way?

[15:09] <Limbic_Region> evalbot is in the examples directory

[15:10] <theorbtwo> ?eval $ref = {$ref.()}; $ref()

[15:10] <evalbot6> Error: Undeclared variable: "$ref" 

[15:10] <theorbtwo> ?eval my $ref = {$ref.()}; $ref()

[15:10] <evalbot6> (no output)

[15:10] <theorbtwo> Not bad.

[15:19] <tewk> dudley: Thanks, I figured that, what was it in it's prior life, a pugs backend in java?  Who wrote it?

[15:20] <xinming> ?hi

[15:24] <fglock> xinming: hi

[15:25] <tewk> Ooh: I just found http://search.cpan.org/dist/Perl6-Pugs/lib/pugs/hack.pod

[15:26] <integral> http://svn.openfoundry.org/pugs/lib/pugs/hack.pod # the master copy

[15:26] <kolibrie> stevan: I'm setting up WWW::Kontent, and get this error: 

[15:26] <kolibrie> pugs: *** No compatible subroutine found: "&File::Spec::path"

[15:26] <kolibrie>     at /usr/local/share/perl6/FindBin.pm line 36, column 17-36

[15:26] <kolibrie>        /usr/local/share/perl6/FindBin.pm line 68, column 9-16

[15:27] <kolibrie> do I need to switch it to File::Spec::Unix?

[15:27] * kolibrie wonders why the magic at the top of File::Spec isn't working for him

[15:27] <dudley> tewk: stevan wrote the hard parts (MetaClass.java) a long time ago and I picked it up a while back and ported the rest from the javascript metamodel

[15:28] <dudley> it was never really meant to be anything other than an exercise in learning the metamodel, at least for me.

[15:29] <tewk> Nice

[15:29] <dudley> occasionally I get the perverse urge to code in java, but usually I just lay down for a while and it goes away :)

[15:31] <xinming> is eval bot here the same as the bot in example/network/evalbot/

[15:31] <xinming> fglock: hi

[15:32] <integral> should be xinming 

[15:33] <xinming> *** Warning: Unknown modifier :Perl5 will probably be ignored.

[15:33] <xinming> integral: And then, the bot exited.

[15:34] <fglock> xinming: maybe you don't have Pugs compiled with Perl5 support

[15:35] <xinming> fglock: How to do that please?

[15:35] <integral> export PUGS_EMBED=perl5

[15:36] <xinming> integral: thanks

[15:37] <kolibrie> xinming: you may or may not want to embed parrot, too

[15:38] <xinming> pugs and emacs 22 are all on the way to destination... feeling really fine these days. :-)

[15:38] <nothingmuch> do you have to say 'new Dog:;' for indirect syntax?

[15:38] <integral> examples/inf_lazy_list.p6 is one of the broken scripts — anyone grok the problem with `list .= map:{ by_n $_ };`

[15:42] <Limbic_Region> examples/nested_loops/coroutine.p6 is another of the broken examples fwiw

[15:43] * integral is going through and making a list - already fixed pipe_open.p6 (err, but that was trivial)

[15:47] <ods15> nothingmuch: you asked me about avi-fix a few days ago...

[15:47] <nothingmuch> ods15: i deleted that already, so too late... but i still want to know =)

[15:47] <ods15> in case you still need it for something, use the CVS version, cause it's like 100000 times faster

[15:47] <nothingmuch> (that == movie, not avi-fix)

[15:47] <nothingmuch> i'll keep that in mind

[15:47] <ods15> turns out the bottleneck wasn't hd or cpu, it was an insane amount of printfs

[15:48] <ods15> a printf for EVERY invalid byte

[15:48] <ods15> i fixed it cvs..

[15:48] <nothingmuch> oi

[15:48] <xinming> nothingmuch: If there is no arguments, you don't need to use ':'

[15:48] <nothingmuch> ods15++

[15:48] <nothingmuch> xinming: isn't that ambiguous?

[15:48] <ods15> ods16 is not me

[15:49] <ods15> use ods++.'15'

[15:49] <nothingmuch> ods15: you C head don't have magical ++

[15:49] <ods15> the 15 is constant

[15:49] <xinming> nothingmuch: why will you think so? I don't think It is ambiguous. :-)

[15:49] <coral> inconstant ods

[15:50] <nothingmuch> if it were "ods15"++ in perl, then it would be problem, but since 'ods15' is a symbol, that represents you, and your karma, it can be used in the expression <symbol><postfix operator working on value stored in container represented in symbol>

[15:50] <nothingmuch> fairy nuff?

[15:51] <ods15> oh, ok

[15:51] <ods15> btw do you actually have a karma bot here?

[15:52] <nothingmuch> i think perlbot's karma was reset when, due to this channel, it reached the 1000s

[15:52] <nothingmuch> and since it has been ignoring #perl6

[15:52] <nothingmuch> but jabbot should keep track

[15:52] <nothingmuch> jabbot: karma ods16

[15:52] <jabbot> nothingmuch: ods16 has neutral karma

[15:52] <nothingmuch> jabbot: karma ods15

[15:52] <jabbot> nothingmuch: ods15 has neutral karma

[15:52] <nothingmuch> uh, guess not

[15:52] <nothingmuch> jabbot: karma autrijus

[15:52] <jabbot> nothingmuch: autrijus has karma of 574

[15:52] <QtPlatypus> jabbot: karam qtplatypus

[15:52] <jabbot> QtPlatypus: Tell me more about that.

[15:52] <QtPlatypus> jabbot: karma qtplatypus

[15:52] <jabbot> QtPlatypus: qtplatypus has neutral karma

[15:53] <dudley> jabbot: karma dudley

[15:53] <jabbot> dudley: dudley has neutral karma

[15:53] <svnbot6> r6360 | fglock++ | * perl5/ Scalar - added a test for 'traits'

[15:53] <svnbot6> r6361 | bsmith++ | * Fixed old syntax in examples/nested_loops/coroutine.p6 and examples/nested_loops/recursive.p6.

[15:53] <svnbot6> r6361 | bsmith++ | * Changed pipeopen to Pipe::open in examples/pipe_open.p6.

[15:53] <ods15> jabbot: hello

[15:53] <jabbot> ods15: Hi. What seems to be your problem?

[15:53] <ods15> jabbot: dumb bot is <reply>stupid human

[15:53] <jabbot> ods15: 喔

[15:53] <ods15> wtf?

[15:53] <ods15> jabbot: dumb bot

[15:53] <jabbot> ods15: I'm not sure I understand you fully.

[15:53] <ods15> damn

[15:53] <nothingmuch> jabbot: it's not a purl

[15:53] <jabbot> nothingmuch: Please go on.

[15:54] <ods15> ok it's obiously not a (good ole) infobot

[15:54] <nothingmuch> ugh... damnit. Now *I'm* getting confused

[15:54] <theorbtwo> jabbot: karma theorbtwo

[15:54] <jabbot> theorbtwo: theorbtwo has karma of 43

[15:55] <xinming> jabbot: version

[15:55] <jabbot> xinming: Tell me more about that.

[15:55] <xinming> jabbot: about version

[15:55] <jabbot> xinming: Please go on.

[15:55] <xinming> jabbot: about your version

[15:55] <jabbot> xinming: Why are you concerned over my version?

[15:55] <xinming> hmmm..

[15:56] <xinming> bbl,

[15:56] <nothingmuch> xinming: jabbot is run by gugod, it's author, and I suspect that it's the head revision or his working copy because fixes take around 3 minutes to get merged... See also: http://jabbot.blogspot.com/

[15:56] <nothingmuch> oops

[15:57] <stevan> kolibrie: ping

[15:57] <stevan> kolibrie: the File::Spec voodoo is evil, I am not suprised it is causing issues

[15:57] <stevan> however I thought autrijus had fixed it

[15:58] * stevan would try to fix it, but has too much $work at the moment

[15:58] <fglock> stevan: can I create anonymous classes using MetaModel-1? (see perl5/Perl6-Container/t/trait.t)

[15:58] <stevan> fglock: no, not with 1.0

[15:58] <stevan> you will be able to with 2.0

[15:59] <fglock> Is it correct to use anon classes to implement traits?

[15:59] <stevan> fglock: 1.0 is too tied to the perl5 package system 

[16:00] <stevan> fglock: I never really "got" traits fully

[16:00] <stevan> they seemed like roles to be applied at compile time which could cause everything to explode if you looked at them wrong 

[16:00] <fglock> exactly

[16:00] <stevan> ah, so my understanding was correct :)

[16:01] <kolibrie> stevan: I tried the same syntax in a test script, and it worked

[16:01] <fglock> I'm using anon classes to apply roles to instances

[16:01] <kolibrie> stevan: so I don't know what's up

[16:01] <stevan> kolibrie: it is evil voodoo,... all results are undefined :)

[16:02] <stevan> fglock: ah, I see what you are doing

[16:03] <stevan> the equivalent perl 6 would be something like my $x does MyRole;

[16:03] <stevan> correct?

[16:04] <fglock> 'my $x is TieableScalar' for example

[16:04] <stevan> yes, the anon class approach is what I remember from the hackathon

[16:05] <stevan> as opposed to some type of reblessing

[16:05] <stevan> revdiablo: reblessing - I was actually suprised to find that CLOS supports something similar, I thought that was purely a Perl 5 OO "feature" 

[16:06] <stevan> darn autocompletion, that was not meant for revdiablo :)

[16:07] <kolibrie> stevan: ah ha! my installed version of FindBin.pm is out-of-date

[16:07] <fglock> the problem I see is, 'my $x is TiedThing; my $y; $y ;= $x; $y.untie ' would fail, because $y doesn't do 'untie' - it is a normal scalar. But it is not a big problem.

[16:07] <stevan> kolibrie: see, the voodoo will even revert versions :)

[16:07] <fglock> oops - ;= should be :=

[16:08] <stevan> fglock: why is $y a normal scalar? shouldn't $y := $x alias $x to $y?

[16:08] <stevan> ?eval my $x; my $y; $y := $x; $x =:= $y;

[16:08] <evalbot6> bool::true 

[16:08] <fglock> no, it alias only the 'cells' that hold the value.

[16:09] <stevan> ah

[16:09] <stevan> that seems counterintuitive to me

[16:09] <fglock> unless traits apply to the cell. 

[16:09] <fglock> ?

[16:10] * stevan does not fully grok the whole container model yet

[16:10] * stevan really wishes he didnt have to $work, and could just code Pugs :)

[16:12] <fglock> 'tieable' is a cell thing. But methods are a 'Container' thing. So a non-tieable container may have a tieable cell, which is strange.

[16:12] <stevan> yes, very

[16:17] <fglock> stevan: is it possible that 'does' clobbers 'is' methods? It looks like a method disappeared...

[16:22] <fglock> (doing more tests)

[16:28] <fglock> stevan: I found the problem - private methods disappear when you create the anonymous class (which is corect)

[16:46] <svnbot6> r6362 | fglock++ | * perl5/ Scalar - scalars bound to tieable scalars are tieable too

[16:56] <svnbot6> r6363 | fglock++ | * perl5/ Scalar traits.

[16:56] <svnbot6> r6363 | fglock++ |   - Removed methods: .set_tieable(), .access()

[16:56] <svnbot6> r6363 | fglock++ |     These functions will be provided by traits. See t/trait.t.

[16:56] <svnbot6> r6363 | fglock++ |   - Methods .tieable, .tie, .untie were kept, in order to keep 

[16:56] <svnbot6> r6363 | fglock++ |     bound scalars tieable.

[16:56] <svnbot6> r6363 | fglock++ |   - ._cell was promoted to public method, in order to keep .bind

[16:56] <svnbot6> r6363 | fglock++ |     working after a trait is applied.

[17:02] <dudley> fglock: re tieable containers, if tieable is a property of a cell, then the definition of a tieable container would be "a container which has a tieable cell", right? So you can't have a nontieable container with a tieable cell.

[17:02] <dudley> or am I missing something (likely)?

[17:04] <fglock> dudley: I already fixed that - I made all Scalars have the methods, but they will only work if the cell is tieable.

[17:07] <fglock> now I'm trying to make 'is readonly' work

[17:07] <dudley> I wasn't really talking about the implementation, just the container model. I'm still trying to wrap my head around it. :)

[17:08] <fglock> ok - the problem is (was) that you can't tie a container if you don't have the 'tie' method. Whatever the cell is.

[17:22] <svnbot6> r6364 | fglock++ | * perl5/ Scalar - Added roles (traits) - tieable, readonly

[17:23] <Limbic_Region> integral ping

[17:24] <Limbic_Region> anyone know why http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/log/ stops at rev 6317?

[17:26] <integral> Limbic_Region: pong

[17:27] <Limbic_Region> did you attempt to fix examples/nested_loops/coroutine.p6 or was that someone else?

[17:27] <Limbic_Region> I can't tell because the recent commits page is b0rk

[17:27] <integral> Limbic_Region: yes, I think I was

[17:28] <Limbic_Region> ok - well while the stderr error is fixed, it still doesn't produce the correct results

[17:28] <integral> but I just fixed it for syntax,  I have no idea what it should do :-/

[17:28] <Limbic_Region> IIRC, every single piece of code in that directory should yield the same output

[17:29] <Limbic_Region> though formatting/spacing/etc may have subtle differences

[17:29] <integral> hmm

[17:29] <Limbic_Region> yep

[17:29] <integral> ah, I see what iterative.p6 is doing now

[17:29] <Limbic_Region> more or less it should produce the same output as iteratative.p6

[17:30] <Limbic_Region> which is the one I wrote

[17:32] <integral> ok, got it fixed,  basically changed yield undef to yield, and @next to $next.

[17:35] <Limbic_Region> great

[17:38] <svnbot6> r6365 | bsmith++ | At Limbic_Region's suggestion fixed examples/nested_loops/coroutine.p6.

[17:48] <nothingmuch> has the kevin tew guy gotten a commit bit yet?

[17:50] <nothingmuch> ah yes

[17:50] <Limbic_Region> nothinmuch - you can't check yourself?

[17:50] <Limbic_Region> I see you as a meta commiter too

[17:50] <nothingmuch> yes, i can

[17:51] <nothingmuch> i was beying lazy

[17:51] <Limbic_Region> oh

[17:51] <Limbic_Region> well, I was having trouble with the new interface

[17:52] <Limbic_Region> I liked the members listed vertically - was easier finding someone

[17:59] <autrijus> whew. finally dd'ed all my data from the broken hard disk to the new 80gb one

[17:59] * autrijus sleeps &

[17:59] <nothingmuch> ciao

[18:05] <svnbot6> r6366 | fglock++ | * perl5/ Scalar - updated 'readonly' trait

[18:06] <Limbic_Region> grats and sleep well autrijus

[18:45] <nothingmuch> is there any work towards a PIL optimizer?

[19:02] <kolibrie> my $work has some old G3s (1996, beige boxes). Is it worth my time to salvage one, or should I treat them as obsolete and utterly worthless?

[19:08] <nothingmuch> kolibrie: i would keep one as a linuxppc mailserver type thing

[19:08] <nothingmuch> debian works reasonably well on old hardware (not too old though)

[19:08] <nothingmuch> disks are cheap (These are post scsi)

[19:08] <fglock> kolibrie: I use old computers as terminals. I even have some Sparc5.

[19:08] <fglock> I use debian too

[19:19] <PerlJam> kolibrie: I have an old G3 at home running OSX 10.1 (I think).  It wasn't difficult or a problem at all and it makes a nice (albeit slow) computer to use sometimes (like when testing whether or how things compile on a Mac)

[19:23] <kolibrie> so an old G3 might be useful, and can probably run OSX ok

[19:23] <kolibrie> thank you all for insights: nothingmuch, fglock, PerlJam 

[19:26] <kolibrie> fglock, nothingmuch: I use debian for all my computers so far, but they are all x86 right now

[19:26] * kolibrie wants a cell processor desktop

[19:35] <fglock> is $x := %hash valid? What happens if 'undefine $x' ?

[19:37] <nothingmuch> kolibrie: http://opendarwin.org/projects/XPostFacto/

[19:39] <kolibrie> nothingmuch: so, that is an OSX replacement, or something to help OSX get installed?

[19:39] <nothingmuch> it helps get osx installed

[19:39] <kolibrie> ok

[19:39] <kolibrie> of course, debian is less expensive

[19:57] <theorbtwo> I haven't managed to get my old G3 to run OSX (or anything else).

[19:57] <theorbtwo> Of course, I got it as just a mobo, which may have been a mistake.

[20:14] <svnbot6> r6367 | fglock++ | * perl5/ boxed 'Hash' works

[20:43] <ods15> CapoeiraA: do i know you

[20:45] <kolibrie> can anyone think of a better name for Class::Inflate? (still perl5)

[20:47] <fglock> what's Class::Inflate?

[20:48] <kolibrie> well, that's the question, does the name describe what it does

[20:48] <kolibrie> so what do you think it does?

[20:48] <fglock> creates a text version of the class?

[20:49] <kolibrie> bummer, you didn't getit

[20:50] <kolibrie> it allows an object to describe how it relates to a database, so that the object can then be "inflated" from values in the database

[20:51] <fglock> try the module-authors list - always have discussions on module names an APIs

[20:51] <kolibrie> ok

[20:54] <svnbot6> r6368 | fglock++ | * perl5/ TODO update

[21:00] <putter> xinming: fglock, integral: "Warning: Unknown modifier :Perl5 will probably be ignored." was a bug, an incorrect warning.  :perl5 :Perl5 and :P5 work to trigger the use of PCRE (compiled into pugs), rather than PGE (compiled into parrot, and thereby optionally into pugs).  perl, the perl5 executable, which can be embedded with PUGS_EMBED, is not involved at all.  Bug patch in progress.

[21:04] <putter> &

[21:08] <svnbot6> r6369 | putter++ | Prelude.pm: Removed incorrect warning about :Perl5 being an unknown regex modifier.  Added warning about :p5.  xinming++

[21:16] <gantrixx> I have a syntax problem, could someone help me?

[21:16] <gantrixx> I'd like to paste some code and the error I get

[21:29] <integral> ah, I was thinking of use'ing perl5 modules, not regexps

[21:30] <[1]equinox> do you know a tool for patching?

[21:40] *** Maddingue__ is now known as Maddingue

[21:47] <xinming> ?eval my $a; my $a;

[21:47] <evalbot6> undef 

[21:51] <xinming> hmm, In S04, It says:" (It's illegal to declare $x twice in the same scope.) "

[21:51] <xinming> Is this a "bug" in pugs?

[22:01] <gantrixx> is it possible to assign to use something other than $_ in a for loop for the current value of the iterator?

[22:02] <xinming> gantrixx: do you mean for @ary -> $item { bla; bla; }; ?

[22:02] <xinming> ?eval for (1, 2, 3) -> $item { $item.say }

[22:02] <evalbot6> 1 2 3 undef 

[22:04] <gantrixx> I think I might mean that

[22:04] <svnbot6> r6370 | yiyihu++ | add test for declaring my() variable twice in the same scope.

[22:04] <gantrixx> is that the same as foreach $item in @array { bla; bla; }

[22:05] <xinming> ?eval foreach (1, 2, 3) -> $item { $item.say }

[22:05] <evalbot6> Error:  unexpected ">" or "-" expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[22:05] <xinming> hmm, Maybe foreach is obselete in perl 6

[22:05] <xinming> no need to use that. Because the list is lazy by default.

[22:05] <gantrixx> I sort of liked the foreach statement

[22:06] <gantrixx> sort of like natural english

[22:06] <xinming> read S04

[22:07] <xinming> foreach doesn't exist in perl 6

[22:18] <gantrixx> I can't find anything in the Auodad book on pushing and popping onto arrays

[22:19] <gantrixx> is it as simple as  @array.push("red");    ?

[22:19] <theorbtwo> xinming, it's "for", not "foreach".

[22:19] <theorbtwo> And that's only listy for -- C-like for is now spelt "loop".

[22:21] * theorbtwo declares it time for bed.

[22:25] <xinming> theorbtwo: *** No compatible subroutine found: "&splitpath"

[22:25] <xinming> theorbtwo: I am trying to run evalbot, what caused this please?

[22:30] <xinming> hmm, I think I should ask, where to find the function splitpath?

[23:00] *** xinming is now known as help

[23:00] <gulugulu> hi yall

[23:00] *** help is now known as xinming

[23:00] <xinming> gulugulu: hi.

[23:07] <xinming> try_evalbot< ?eval 3+5

[23:07] <xinming> ?eval 3+5

[23:31] <gantrixx> ok, so if I have an object that has @.array is rw  as an attributed, if I want to push an object onto that attribute, I would just do a    push @.array, $obj    ?

[23:40] <buu> gantrixx: God I hope not.

[23:41] <nothingmuch> buu: sucks for you

[23:42] <nothingmuch> ciao people

[23:59] <putter> nothingmuch: still no p6 rules testing on the smoke...

