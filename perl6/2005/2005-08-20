[00:10] <gantrixx> buu, what don't you hope?

[00:12] <gantrixx> It would have been nice to have @array.push($arg) and @array.pop() methods

[00:15] <Khisanth> those exists too ...

[00:15] <gantrixx> they do?  Well then I'll try to use them once I get this working

[00:15] <gantrixx> can you have two classes defined in one module?

[00:15] <Khisanth> ?eval my @a; @a.push("gantrixx"); @a

[00:15] <Khisanth> hmm where did the bot go?

[00:16] <Khisanth> gantrixx: that will depend on which syntax you use for declaring the class, should be able to if you are using the one with the block

[00:16] <gantrixx> I'm getting an "Undeclared variable: "$?SELF" error

[00:17] <gantrixx> I used the block style

[00:18] <Khisanth> class Foo { method foo { say $?SELF; } } my $foo = Foo.new; $foo.foo; seems to work ok

[00:19] <gantrixx> what is "say"

[00:19] <gantrixx> and what is $?SELF

[00:19] <gantrixx> ?

[00:22] <Khisanth> the same $?SELF you are using :)

[00:22] <Khisanth> say is print but with the newline automatically added

[00:23] <gantrixx> it's like $self in perl5?

[00:23] <gantrixx> it's the reference to the object that you are?

[00:24] <Khisanth> hmm seems so

[00:25] <gantrixx> interesting, if I put say $?SELF; in there it complains and says "Undeclared variable: $?SELF"

[00:27] <putter> &

[00:28] <Khisanth> hrm

[00:28] <gantrixx> is it different if I'm using Pugs?

[00:29] <Khisanth> SELF seems undocumented

[00:29] <Khisanth> < using pugs

[00:29] <gantrixx> it says "Undeclared $?SELF"

[00:29] <Khisanth> use the paste site and paste your code?

[00:30] <Khisanth> ahh

[00:30] <Khisanth> $?SELF    # The current instance as scalar variable

[00:31] <Khisanth> need a perl6doc perlvar :)

[00:31] <pasteling> "gantrixx" at 24.251.41.77 pasted "Undeclared variable $?SELF" (24 lines, 455B) at http://sial.org/pbot/12605

[00:31] <gantrixx> http://sial.org/pbot/12605

[00:33] <gantrixx> The funny thing is that I was getting this error before I ever had the     say $?SELF;   statement in there.

[00:33] <gantrixx> As you can see, I've commented everything else out just to test the    say $?SELF

[00:33] <Khisanth> actually I wouldn't expect that to work

[00:34] <gantrixx> you wouldn't expect    say $?SELF to work in pugs?

[00:35] * geoffb appears hazily for a moment . . . 

[00:35] <Khisanth> gantrixx: not where you have it

[00:35] <geoffb> Limbic was looking for me earlier, but he's not here now -- anybody happen to know what he needed?

[00:36] <Khisanth> gantrixx: the $?SELF should only work inside a method

[00:40] * geoffb fades away again . . .

[00:40] <gantrixx> Can I define the new method?

[00:43] <Khisanth> the constructor? yup :)

[00:52] <luqui> does anybody know how to trigger a perl6 warning from haskell

[00:54] <gantrixx> under what circumstances would I get the "No compatible subroutine found: "&subname" " error?

[00:54] <gantrixx> I've got 3 methods defined in a class and I get this error

[00:54] <gantrixx> but it's clearly defined

[00:55] <luqui> you have to call methods as method

[00:55] <luqui> methods

[00:55] <luqui> can you snip me the relevant code?

[00:55] <gantrixx> I can paste it into the bot

[00:55] <luqui> yep

[00:57] <pasteling> "gantrixx" at 24.251.41.77 pasted "Undeclared variable $?SELF" (49 lines, 806B) at http://sial.org/pbot/12606

[00:57] <gantrixx> sorry if I pasted more then relevant

[00:58] <gantrixx> *** No compatible subroutine found: "&display"

[00:58] <luqui> where is the error happening?

[00:58] <luqui> oh

[00:58] <gantrixx> is the error from $deck.display()

[00:59] <luqui> hmm

[00:59] <Khisanth> your new does not seem to return anything

[00:59] <luqui> that would be a problem

[00:59] <gantrixx> what am I supposed to return $?SELF?

[00:59] <luqui> I think you mean "submethod BUILD"

[01:00] <luqui> not "method new()"

[01:00] <Khisanth> and if return values work like they do in p5 then your new is returning the value of the last push

[01:00] <gantrixx> let me read about submethod then

[01:00] <luqui> his "new" is an initializer, not a constructor, so it should be BUILD

[01:00] <luqui> and BUILD need not return anything

[01:01] <luqui> a submethod is a method that only gets called when the invocant is *exactly* the class in which it was defined

[01:01] <luqui> it's mostly used for initializers and destructors

[01:04] <gantrixx> OK, I think I understand this one

[01:04] <gantrixx> but is BUILD an inherent method to all objects like DESTROY?

[01:05] <luqui> yeah

[01:05] <gantrixx> is it something that the constructor (new) calls?

[01:05] <luqui> by default, yes

[01:05] <luqui> in perl 6, it should be unnecessary most of the time to write your own new

[01:05] <gantrixx> so basically, I just want to change the new method to submethod BUILD right?

[01:05] <luqui> righto

[01:06] <gantrixx> OK, cool, then I can define a class called Card::Shoe and it won't inherit the submethods?

[01:06] <luqui> yeah

[01:06] <luqui> why would you want that?

[01:06] <gantrixx> because a show is built differnt than a deck

[01:07] <Khisanth> Shoe!

[01:07] <gantrixx> It's a blackjack term

[01:07] <luqui> OOishly, though, you should probably make a common base class for the two of them

[01:07] <luqui> BUILD is called like constructors from C++

[01:08] <luqui> all the BUILDs in the heirarchy are called

[01:08] <luqui> it still makes me wonder how those are actually submethods, then...

[01:08] <gantrixx> Well a shoe is just multiple decks

[01:08] <luqui> so it's probably best to do it by delegation

[01:08] <gantrixx> so they still have all the same methods of a deck such as shuffle, cut, and deal, they are just built differently

[01:09] <luqui> yeah, you basically just thread the methods over multiple decks, right?

[01:09] <luqui> method Shoe::shuffle() { @.decks>>.shuffle }

[01:10] <gantrixx> Well the idea was to have a group of Card classes  Card::Card, Card::Deck, Card::Shoe

[01:10] <luqui> that makes sense.  I'm just saying that Card::Shoe should probably aggregate a couple Card::Decks

[01:10] <luqui> but design how you will

[01:10] <luqui> there are many WTDI

[01:11] <gantrixx> WTDI?

[01:11] <luqui> way(s) to do it

[01:11] <luqui> from TIMTOWTDI

[01:12] <gantrixx> oh, sorry not up on all the geekronisms

[01:12] <luqui> you don't come from a perl 5 background do you?

[01:12] <gantrixx> yes, I do

[01:12] <luqui> huh...

[01:13] <luqui> let me take this foot out of my mouth here, and, ahhh, that's better

[01:13] <gantrixx> you've lost me.  what foot in your mouth?

[01:14] <gantrixx> ...I guess it doesn't matter, but I appreciate your help.  And my appologies for the "geek" comment.  I meant it as a term of admiration

[01:14] <luqui> I know

[01:14] <luqui> geek isn't a negative word for miles outside of this town

[01:15] <gantrixx> it's a hood thing, only a geek can call another a geek without ending up in a gangland brawl

[01:15] <gantrixx> wazup my geek

[01:16] <gantrixx> keepin' it real?

[01:16] <luqui> hehe

[01:19] <dudley> heh, my daughter drew a picture of me at school and she drew me wearing a shirt that said "geek" across the front

[01:19] <dudley> her teacher got all serious and showed my wife, thinking my daughter was being mean

[01:19] <dudley> then my wife had to explain that I really did have a shirt like that...

[01:20] <gantrixx> how old is the daughter?

[01:21] <dudley> she's 8 now, this was at least a year ago

[01:23] <gantrixx> where can I find all these methods that come with arrays?

[01:23] <gantrixx> this Auodads book is lacking a lot

[01:28] <gantrixx> is there an @array.length() function?

[01:28] <luqui> it's called "elems"

[01:29] <luqui> because of the confusion between length of string and length of array

[01:29] <gantrixx> where is it that you learn all this?

[01:29] <luqui> the string version is called "chars"

[01:29] <luqui> Apocalypses, Exegeses, and (especially) Synopses

[01:29] <luqui> and being aroung perl6-language long enough to know what parts of those are outdated

[01:29] <luqui> in other words, it's hard to learn from docs at the moment

[01:30] <gantrixx> Well, I'm mostly relying on the Auodads book (which should eventually become a Camel with a Parrot on it's back).

[01:30] <gantrixx> Someone should aggregate all the Apocolypses and Exegeses into one reference document

[01:31] <gantrixx> (no, I'm not volunteering)

[01:31] <luqui> we'll do that once we feel like it's stopped changing

[01:31] <luqui> or at least reasonably slowed down

[01:31] <luqui> I'm trying to get my hand in to write a chapter of the camel 6

[01:31] <luqui> (which I guess would be the camel 4)

[01:32] <luqui> what's the auodads book?

[01:32] <gantrixx> I call it Auodads, it's the Perl6 and Parrot Essentials

[01:32] <gantrixx> It has a pic of an Auodad on the front

[01:32] <luqui> ahh, that one

[01:32] <luqui> 2nd ed?

[01:33] <gantrixx> so like they call it "the Camel Book", I call it "the Auodads Book"

[01:33] <gantrixx> yes, 2nd edition

[01:33] <luqui> well, we're trying to keep the Synopses no more than six months out-of-date :-)

[01:33] <luqui> so you can kinda rely on those

[01:34] <gantrixx> I wish they were searchable

[01:35] <luqui> you can check them out with svn and then grep

[01:36] <luqui> https://svn.perl.org/perl6/doc

[01:36] <gantrixx> what comes between 13 and 29?

[01:36] <gantrixx> are they missing?

[01:37] <luqui> for now

[01:37] <luqui> they correspond to chapters of the camel

[01:37] <luqui> and 14-28 really aren't that important to the primary design of the language

[01:38] <luqui> we'll be filling in a couple of those, but not many

[01:42] <gantrixx> I think the learning curve on Perl6 is pretty significant

[01:42] <gantrixx> It's pretty much like learning a new language

[01:42] <luqui> do you have any ideas on how to make it softer

[01:42] <luqui> oh yeah, that

[01:43] <luqui> you can't expect it to be like Perl 5

[01:43] <gantrixx> not really

[01:43] <luqui> except when you can...

[01:43] <QtPlatypus> gantrixx: Its more like perl5 then it isn't IMHO.

[01:43] <putter> Drats.  r6371 went out without a descriptive log entry (a click-o).

[01:44] <gantrixx> well I've programmed in Perl5 and I'm finding it very painful to get a simple script done

[01:44] <luqui> well you're using the OO features

[01:44] <putter> r6371: pugsbugs/attribute_of_return_value.t: Created.  Calling accessors on the return value of a sub doesn't work.  Eg, class C { has $.a; }  sub f() { C.new() }  f().a

[01:44] <luqui> which, admittedly, weren't there physically in perl 5

[01:44] <gantrixx> for the amount of effort I'm putting in, I could probably learn Python or Ruby....this is what I'm worried about with the Perl5 to Perl6 transition

[01:44] <luqui> just culturally

[01:44] <luqui> gantrixx, how so?  what have you struggled with?

[01:45] <luqui> plus, yeah, you probably could learn Python or Ruby.  But Perl 6 is better than those :-p

[01:45] <gantrixx> right now I'm looking for the random number function,

[01:45] <luqui> oh, it's "rand"

[01:45] <luqui> but it's probably unimplemented :-(

[01:45] <gantrixx> a second ago I was looking for the $#array function

[01:45] <luqui> oh, you use that?

[01:46] <luqui> we're trying to phase that out.  just use @array in numeric context

[01:46] <gantrixx> makes sense

[01:48] <gantrixx> It's just that I would hate to see Perl slip off it's dominance

[01:48] <dudley> gantrixx: Perl 6 is really a moving target right now. You're not only trying to learn the language, but also how much is actually implemented, how much of what is implemented works the way it's supposed to, etc. And the language spec itself is mutating every day.

[01:48] <svnbot6> r6371 | putter++ | pugsbugs/attribute_of_return_value.t

[01:49] <gantrixx> ther is a lot of Python advocacy these days (i.e www.linuxradio.org)

[01:49] <gantrixx> I understand dudley

[01:49] <gantrixx> I hope I don't sound like chicken little

[01:50] <putter> gantrixx: re combining AES into a single searchable document... agreed.  I tried to get one into Perl6::Bible when I was getting started with p6, but it "didn't take".  I just use one of my own.  Though I find as I get to know the assorted AES, which individually have different characteristics, grepping them separately has become more useful.

[01:50] <dudley> gantrixx: I hear a lot of that around here ;)

[01:51] <gantrixx> do most of the developers on Perl6 have full time jobs and do Perl6 on the side?  or are they students or what?

[01:51] <putter> On the IRC a while back I consed up (with help) a google search which hit the bible and mailing lists.  Perhaps that's a concept worth dusting off and linking from the wiki.

[01:52] * luqui is a student

[01:53] * dudley is a student, works full time, and is a new father.

[01:53] <dudley> so Pugs gets considerably less time than I would like :)

[01:54] <putter> ruby and python are both nice languages.  in some respects nicer than perl.  I look forward to having compilers and runtimes for both written in p6, so we can "use ruby;".

[01:55] <putter> I started on the ruby runtime, but decided to wait for the metamodel merge and oo cleanup, so it could actually be tested during development.

[01:55] <tewk>  /tewk just became a student again reciently, ruby seems like a good mix of perl and smalltalk.

[01:57] <putter> all three have significant limitations.  but only p6, technically and socially, has the potential to do a superset.  and blends.

[01:59] <tewk> so what is the word on th oo cleanup, is leo done? I heard it was waiting for chip's approval.

[01:59] <gantrixx> gantrixx is a 40+ hr/week contract engineer and aspiring retiree

[02:00] <putter> but yes, it's rather hard to get started.  I keep hoping folks trying to get started will start using the wiki as a collective resource to ease the process.  But hasnt happened yet.   Maybe folks get two free beginners questions on #perl6, and then they are strongly encouraged to add the questions and answers to a GettingStartedFAQ on the wiki.

[02:01] <gantrixx> where is the wiki?

[02:02] <putter> tewk: pugs side oo.  metamodel merge, and pil2 runtime.  parrot... I'm not sure what the status of the leo-ctx5 branch merge is.  But that only holds up the pugs PIR backend.

[02:02] <putter> pugs.kwiki.org

[02:05] <tewk> putter: I'd like to help so all start with my two free questions and put your answers on the wiki

[02:06] <putter> tewk: unfortunately one thing ruby didn't pick up from smalltalk is the culture of self-hosting code.  for a language which is exceptional for metaprogramming, there has been strikingly little community interest or effort at supporting it.  Eg, it took years to create the equivalent of Tie::Array::Simple (or whatever its called) base classes for creating Array/Hash/etc-like objects.  And it was still a mess the last time I looked.

[02:06] <putter> tewk++ ! :)

[02:07] <luqui> hey putter, you know haskell?

[02:07] <luqui> more importantly, do you know pugs internals very well?

[02:08] <luqui> for a very loose definition of "very"

[02:08] <putter> not really.  some corners more than others.

[02:09] <luqui> where should I put a utility function like warn :: String -> Eval ()

[02:10] <luqui> Pugs.Internals?

[02:10] <putter> tewk: feel free to mash FrequentlyAskedQuestions.  its quite crufty.  please let me know if you have any questions or if I can be of assistance.

[02:12] <luqui> I'm going with that one

[02:12] <putter> luqui: yes, that sounds plausible.

[02:13] <putter> hmm... or not... putter tries to remember the files scope of Eval...

[02:14] <luqui> I'm going to stick it in Eval, since that's where I'm using it, and I'll let autrijus move it if he wants :-)

[02:15] <putter> sounds good.

[02:19] <putter> gantrixx: rand() actually is implemented.  the quick way to find out if primitive foo is implemented is to grep for foo in src/Pugs/Prim.hs and src/perl6/Prelude.pm (and perhaps src/perl6/Parser.hs if its something which seems likely to benifit from special parser treatment).

[02:20] <putter> Oh, though the first thing to do is just try whatever p5 does.

[02:20] * jql sniffs at :x($horizontal)

[02:22] <luqui> huh, there's already a Pugs.Compile.warn

[02:22] <luqui> weird, my grep didn't see it

[02:25] <gantrixx> sorry, I'm back putter and thanks

[02:25] <gantrixx> yes, I just wrote a small program to see if it was implemented

[02:29] <putter> tewk: I've added a link to http://www.kwiki.org/?KwikiFormattingRules on the top page of the wiki.

[02:29] <putter> gantrixx: np :)

[02:29] <tewk> putter: What does the pil2 runtime consist of, What does new improvements are there in version 2

[02:29] <putter> gantrixx: you know you can just say  ./pugs  and get an interactive read-eval-print-loop?

[02:30] <tewk> putter: I'm familiar with wiki

[02:30] <putter> addid from the usual -e   ./pugs -e 'say rand'

[02:34] <tewk> pil is Perl itermediate Language ?

[02:34] <luqui> something like that

[02:35] <luqui> though there is dispute about the word "language"

[02:35] <putter> tewk: my understanding is the current PIL was basically a "roughing it out", bootstrap, first draft.  so this second draft is expected to be cleaner.  and will be/is being used by several backends.  the new haskell backend will emphasize correctness.  becoming a running spec for p6.  the current state of affairs is a bit flakey.

[02:35] <luqui> PIL is just PIL :-)

[02:37] <gantrixx> is there a @array.splice($start, $stop) function?

[02:38] <luqui> ?eval my @a = (1,2,3,4);  say @a.splice(0,1); say @a

[02:38] <luqui> where is evalbot?

[02:39] <luqui> well, try that in a -e

[02:39] <luqui> the short answer is "yes"

[02:39] <luqui> but it's @array.splice($start, $length)

[02:40] <gantrixx> the wiki didn't return anything from the search on it

[02:40] <svnbot6> r6372 | luqui++ |  r225@feather:  fibonaci | 2005-08-20 04:36:27 +0200

[02:40] <svnbot6> r6372 | luqui++ |  Added a runWarn function for runtime warnings, and added "Odd number

[02:40] <svnbot6> r6372 | luqui++ |  of elements in hash constructor" to the hash() builtin (only -- not {}).

[02:40] <luqui> then ot'

[02:40] <luqui> then it's probably not there

[02:40] <luqui> you don't seem to understand our poor state of documentation

[02:40] <gantrixx> I do understand

[02:41] <luqui> do you want to  add it to the wiki?

[02:41] <luqui> that'd be great

[02:41] <gantrixx> It just makes me feel like an idiot to be bothing you all with these silly questions

[02:41] <luqui> it's okay, I clearly have nothing better to do

[02:41] <luqui> still, don't be afraid to use pugs -e

[02:41] <gantrixx> autrijus asked me to help by writing some examples, so I am, but it's a real learning curve

[02:42] <luqui> try learning haskell some time :-)

[02:42] <gantrixx> hassel?

[02:42] <luqui> haskell, the language pugs is implemented in

[02:42] <gantrixx> df -f /dev/brain shows 99% full

[02:42] <putter> PIL is basically a "kernel language" for p6.  Hmm... I dont see a good reference webpage describing what a kernel language is.  Anyone...?

[02:43] <luqui> I figured.  It was just an expression; I don't want you to learn haskell

[02:43] <luqui> I just wanted to contrast the learning curves :-)

[02:43] <gantrixx> ...and highly fragmented

[02:46] <putter> ?eval 42

[02:47] <tewk> putter: I'm writting a page about general architecture right now.

[02:47] <tewk> Where is PIL2 in svn?

[02:47] <luqui> evalbot6 isn't even present

[02:47] <tewk> where does it, live did it die?

[02:48] <tewk> So what does autrijus think of the wiki does he prefer it over docs in svn? or the other way around?

[02:50] <putter> tewk: neat!  src/PIL/  I think (anyone: yes?)   there is a good article in autrijus's journal at...

[02:50] <putter> http://use.perl.org/~autrijus/journal/25964

[02:51] <luqui> autrijus likes svn

[02:51] <luqui> so I expect svn docs are the way to go

[02:51] <tewk> Yeah that what I thought.

[02:51] <tewk> so wher is a kwid format document

[02:52] <luqui> docs/01Overview.kwid ?

[02:52] <putter> tewk: do you have a committer bit yet?

[02:53] <tewk> Hmm, I'm not sure?

[02:53] <putter> is there anyone on now who has committer invitation ability?

[02:54] <tewk> I talked to autrijus along time ago, and he might have given me one?  I'll try to commit some docs in a little while and see what happens.

[02:54] <putter> (this is rather the quiet time each day of 24hr world-wide pugs development;)

[02:54] <putter> ok

[02:55] <tewk> So what is YAML used for in pugs.

[02:55] <jql> can't burn the candle from both ends forever

[02:58] <tewk> I'm in MDT. But I often stay up till midnight(my wife works in an E.R. till midnight).  I often get up early, 3-4am so I catch the other half of the world:)

[02:59] <putter> autrijus, iblech, etal: it looks like f().foo , where f() is a sub returning a non-native object, currently doesnt work.  for both accessors and methods.  Eg, class C {method me(){42}} sub f(){C.new}  f().me

[03:00] <putter> YAML is used for the build config file, a dump format for (Json actually) PIL, and ...?

[03:01] <tewk> Ok so pugs uses it to dump PIL cool.

[03:01] <tewk> Json?

[03:04] <putter> http::/www.json.org/  http://redhanded.hobix.com/inspect/yamlIsJson.html

[03:04] <tewk> So is src/PIL the old PIL or the new PIL2? I heard PIL2 will resemble scheme.

[03:05] <putter> semantically (well, a superset of), rather than syntactically.  though an s-expression dumper for PIL is on the collective todo list.

[03:08] <tewk> putter: so is pugs.kwiki.org your baby, would you mind if I stole some of the content and moved it to svn.  A glossary in svn would be helpfull.

[03:09] <putter> tewk: who me?  looks over sholder.  not my baby.  ;)  go for it.

[03:10] <dudley> tewk: src/PIL is PIL2

[03:11] <tewk> dudley: so is the old PIL somewhere else or has it been gutted.

[03:12] <scook0> tewk: the old PIL is sitting around in various parts of src/Pugs

[03:13] <putter> tewk: might want to leave a (svn) link behind so folks surfing but not yet using pugs can easily find it.

[03:13] <dudley> src/Pugs/Compile.hs is a lot of it, I think.

[03:13] <dudley> look for the data types starting with P

[03:13] <putter> ;)

[03:13] <dudley> PStmt, PPos, PNoop, etc..

[03:16] <tewk> scook0: Thats what I thought, thanks for all the confirmations, maybe my attempt to document will be close to the truth.

[03:17] <tewk> I figure if I document I'll know my way around enought to start hacking.

[03:20] <scook0> tewk: that's more or less what I've been doing with my Haddock stuff

[03:20] <scook0> (not that I've made any actual code changes yet)

[03:20] <putter> End of day.  I believe the f().foo bug is the last obsticle to getting Rul and rules development unstuck.  fingers crossed.

[03:21] <dudley> scook0: I've been meaning to ask you about the #ifdef HADDOCK stuff

[03:21] <putter> Good night all. &

[03:21] <scook0> dudley: what did you want to know?

[03:21] <scook0> do you know what Haddock is?

[03:21] <dudley> does that just change some of the types as they appear to haddock?

[03:21] <scook0> it depends

[03:22] <scook0> Haddock isn't as sophisticated as GHC

[03:22] <dudley> Only vaguely. It's documentation annotation in the source, right?

[03:22] <scook0> dudley: right

[03:22] <scook0> so some Haskell extensions that GHC accepts will trip up Haddock

[03:22] <scook0> the easiest way around that is just to #ifndef them out

[03:23] <scook0> but this means that the affected types and functions don't show up in the documentation

[03:23] <dudley> That's pretty much what I was thinking. Thanks.

[03:23] <scook0> so in some places we've put in replacements that have a similar meaning, but don't confuse haddock

[03:24] <scook0> the Haddock docs are quite useful when you're browsing around the Pugs source

[03:24] <dudley> That's what it looked like to me, but I know better than to think that I understand what's going on with Haskell. :)

[03:25] <scook0> dudley: :)

[03:25] <dudley> Are the Haddock docs online somewhere?

[03:25] <scook0> dudley: there's a link off pugscode.org somewhere

[03:25] <dudley> Haddock doesn't build out of the box on my machine, and I lack the tuits to make it work.

[03:26] <dudley> http://nothingmuch.woobling.org/pugs_test_status/haddock/

[03:27] <dudley> for anyone reading the logs, wondering where the Haddock is :)

[03:27] <scook0> dudley: out of curiosity, what are you running?

[03:28] <dudley> Mac OS 10.4

[03:28] <dudley> using darwinports

[03:30] <scook0> actually, speaking of OSX, does anyone know a way to get Haskell syntax-highlighting in XCode?

[03:31] <scook0> (or something else I can use in the mac-labs at uni)

[03:31] <dudley> SubEthaEdit has a Haskell mode

[03:32] <dudley> or, of course, Emacs :)

[03:33] <gantrixx> ok, another stupid question

[03:33] <gantrixx> is there a min function?

[03:34] <gantrixx> there is, sorry I figured it out

[03:36] <scook0> dudley: oh, I didn't realise until now that SubEtha was free for non-commercial use

[03:36] <scook0> I shall give it a try next week

[03:36] <dudley> Yeah, but it's got this annoying watermark that shows up after a few minutes of inactivity.

[03:37] <dudley> Otherwise a nice editor, though.

[03:39] <dudley> OSX needs a good open-source cocoa editor. Maybe I'll write one when Pugs gets an ObjC backend :)

[03:54] * luqui starts the wthi project

[03:57] <scook0> luqui: wthi?

[03:57] <luqui> what the heck is

[03:57] <luqui> it's a sort of perldoc search

[03:57] <scook0> ooh, tasty

[03:58] <luqui> wthi '[>>+<<]'  # brings up the entries for [] reduce, binary hyper, and infix +

[03:59] <scook0> didn't somebody already start writing p6explain?

[03:59] <luqui> oh, let me look

[03:59] <luqui> that's what it was called

[04:00] <luqui> ahh, a different approach from mine

[04:00] <luqui> hmmm...

[04:00] <luqui> maybe that's a good approach

[04:00] <luqui> p6explain maps syntax into vocabulary, and then you can go look up the vocabulary

[04:09] <luqui> hmmm

[04:09] <luqui> I wonder if it is worth starting a feature-oriented documentation project

[04:09] <luqui> a one-page document about hyper operators, separate from a page about metareduction, separate from a page about multimethods, etc.

[04:44] <gantrixx> If I want to pass in an initialization arguement to the &.new method, does that automatically get passed to the &.BUILD method?

[04:48] <gantrixx> can someone answer a question for me about the BUILD method in objects

[04:48] <gantrixx> ?

[04:50] <gantrixx> For example if I have class Card::Shoe is Card::Decke{ yada yada } it appears as if the BUILD submethod of Card::Deck gets called and then the BUILD submethod of Card::Deck

[05:06] <scook0> gantrixx: S12 says that bless calls BUILDALL, which calls all the BUILDs in least-to-most-derived order

[05:08] <scook0> also, I believe it says that the default &new passes all its named arguments to &bless, which passes them to both &CREATE and &BUILD

[05:08] <scook0> (unless something has changed to make that out-of-date)

[05:10] <QtPlatypus> luqui: Sounds good.

[05:10] <gantrixx> wow, I'm confused

[05:11] <gantrixx> YOu can have more than one BUILD in a class?

[05:11] <gantrixx> I just wanted Card::Shoe to inherit everything except the BUILD method from Card::Deck

[05:12] <gantrixx> I thought using submethod BUILD in Card::Shoe overwrites the BUILD in the object from which it inherits

[05:14] <luqui> nope

[05:14] <luqui> BUILD is just a constructor, and it's probably best not to think of it any differently

[05:15] <luqui> what I would do is to make an init() function that BUILD calls

[05:15] <luqui> *init() method

[05:15] <luqui> and then override that

[05:16] <luqui> class Card::Deck { submethod BUILD() { ./init }  method init { initialize deck } }

[05:16] <luqui> class Card::Shoe { is Card::Deck;  method init { initialize shoe } }

[05:17] <gantrixx> I'm confused then, I thought submethod was teh thing that did the overwriting

[05:17] <luqui> gantrixx, have you used C++?

[05:17] <arcady> submethod just means that it's part of a class, but not inheritable like a method is

[05:17] <gantrixx> no

[05:18] <luqui> Java?

[05:18] <arcady> at least as far as I understand it

[05:18] <gantrixx> the example in the Auodad book is contrary to your explaination

[05:18] <gantrixx> or perhaps I'm not reading it correctly

[05:18] * luqui thinks he has the 2nd ed.

[05:19] * luqui goes to look

[05:19] <gantrixx> When you say    class Frogstar::B is Frogstar::A { stuff}  it means that Frogstar::B inherits from Frogstar::B  right?

[05:19] <scook0> (B inherits from A)

[05:20] <gantrixx> and in that example the smash method is overwrittin in B with submethod smash

[05:20] * luqui only has 1st ed

[05:21] <luqui> can you paste?

[05:21] <gantrixx> oh, wait, no, I think you are right

[05:22] <gantrixx> but this doesn't seem to be what is happening with my classes

[05:23] <luqui> paste?

[05:23] <luqui> OO stuff is hard to talk about

[05:24] <gantrixx> umm OK, but let me get it back into shape for pasting

[05:28] <pasteling> "gantrixx" at 24.251.41.77 pasted "Calls both BUILD methods" (52 lines, 1.2K) at http://sial.org/pbot/12609

[05:29] <luqui> so when you call Card::Shoe.new, which BUILD do you think will be called?

[05:29] <gantrixx> I was hoping it would call only the BUILD from Card::Shoe

[05:29] <gantrixx> but perhaps the BUILD methods can't be overwritten

[05:30] <luqui> well, that's not really what's going on

[05:30] <gantrixx> so the new calls the BUILDALL which calls the BUILD from the parent as well as the child

[05:30] <luqui> BUILDALL from the call to new() is calling *both* BUILDs explicitly

[05:30] <luqui> yeah

[05:30] <gantrixx> why?

[05:31] <luqui> because objects often need local initialization

[05:31] <gantrixx> you can't overwrite the BUILD methods?

[05:31] <luqui> if you derive from a class that initializes a file handle

[05:31] <luqui> you don't want your BUILD to override its BUILD

[05:31] <luqui> because then you would keep it from opening its handle

[05:31] <luqui> same with DESTROY

[05:32] <gantrixx> ok, well I think I can hack this to work the way I wanted to

[05:32] <arcady> where does a parent class's BUILD get its arguments from, by the way?

[05:32] <gantrixx> that's a good question

[05:32] <luqui> the same place as all other BUILDs

[05:32] <luqui> the argument list

[05:33] <luqui> (which I think is a little bit... wrong)

[05:33] <arcady> yeah, especially for multiple inheritance

[05:33] <gantrixx> what if the BUILD in the parent does have arguements but the BUILD in the child does?

[05:33] <luqui> arcady, the situation isn't as bad as you'd think, since all parameters to constructors must be named

[05:33] <arcady> oh

[05:33] <arcady> didn't know that

[05:33] <luqui> but it's still pretty limited compared to what you'd like to do

[05:34] <arcady> but it makes sense and does sort of solve the problem

[05:34] <arcady> still, not necessarily what I'd want

[05:34] <luqui> gantrixx, all arguments are named, so the ones that aren't in the argument list are simply ignored

[05:35] <luqui> gantrixx, there's some OO design stuff in your program going on that is making your job harder than it should be

[05:36] <gantrixx> please enlighten me

[05:36] <luqui> well, you're accessing member variables from the child class, which is a no-no

[05:36] <luqui> (I'm not even sure if it works in pugs)

[05:36] <luqui> you probably want a common abstract base class for these two things

[05:37] <luqui> and make them both siblings

[05:37] <luqui> like Card::Dealer (or something)

[05:37] <luqui> put all common implementation in there

[05:37] <gantrixx> OK, guys, I'm an EE I'm not formally trained on all this computer stuff

[05:37] <gantrixx> Well Card::Shoe is just a specialized Card::Deck

[05:37] <luqui> then class Card::Deck { is Card::Dealer; ... }   class Card::Shoe { is Card::Dealer; ... }

[05:38] <gantrixx> I understand what you are saying

[05:38] <luqui> gantrixx, how is it specialized?

[05:38] <luqui> as in, how is it different?

[05:38] <gantrixx> A shoe is just multiple decks

[05:38] <gantrixx> they do that to make it harder for card counters

[05:38] <luqui> right

[05:39] <luqui> so how does this make you think that multiple decks is a kind of single deck?

[05:39] <gantrixx> so only the initialization is different

[05:39] <arcady> why do you even need two separate classes?

[05:39] <luqui> (I was thinking that too)

[05:39] <gantrixx> well, I could do it with on class

[05:40] <arcady> make number of decks an optional parameter with 1 being the default

[05:40] <gantrixx> I suppose a Card::Deck is a Card::Shoe of just 52 cards

[05:40] <gantrixx> yes, that is what I'm thinking

[05:40] <luqui> Card::Deck is a subtype of Card::Shoe

[05:40] <luqui> but don't use subtypes, because they're inappropriate here

[05:41] <gantrixx> I was also trying to keep it so that it was easily readable

[05:41] <gantrixx> but it's still easily readable this way too

[05:42] <luqui> bbiab

[05:44] <gantrixx> bbiab?

[05:44] <luqui> .e .ack .n . .it

[05:52] <gantrixx> what does this error mean?

[05:52] <gantrixx> *** Can't use positionals in default new constructor

[05:54] <QtPlatypus> gantrixx: It means that the defalut consturctors must take named arguments.

[05:55] <gantrixx> oh, I get it, and I understand why

[05:57] <QtPlatypus> You can rewrite your constructor to take named arguments, or you can just make a nondefault constructure using positionals.

[05:58] <gantrixx> where can I read more about this?

[05:59] <gantrixx> just do it like....

[05:59] <gantrixx> class Card::Shoe ($numdecks) { has @.sequence; yada yada }

[05:59] <gantrixx> ?

[06:00] <gantrixx> like a subroutine?

[06:00] <luqui> huh?

[06:00] <luqui> oh

[06:00] <luqui> (didn't see that ($numdecks) there)

[06:00] <luqui> no, you have to write

[06:01] <luqui> class Card::Shoe { sub new ($arg1, $arg2) { various stuff that the default new does that I don't know } }

[06:01] <luqui> in other words, right now, you should use positionals

[06:01] <luqui> I mean nameds

[06:01] <QtPlatypus> method mynew (::Class $class: {# Your arguements go here #}) { ... }

[06:02] <luqui> QtPlatypus, more important, though, is what goes where you wrote ...

[06:02] <QtPlatypus> luqui: sub new will not work.

[06:02] <luqui> QtPlatypus, hmmm, right, because it's a class method, not a sub

[06:03] * luqui goes to change the error message that gantrixx cites

[06:04] <luqui> how about *** Must use named parameters to new()

[06:04] <gantrixx> ok, I'll give it a go

[06:21] <gantrixx> is the loop syntax still

[06:21] <svnbot6> r6373 | luqui++ |  r232@feather:  fibonaci | 2005-08-20 08:09:57 +0200

[06:21] <svnbot6> r6373 | luqui++ |  Changed error message to be more descriptive. gantrixx++

[06:21] <gantrixx> loop ( $i = 1; $i >= $max; $i++ ) { stuff } 

[06:21] <gantrixx> ?

[06:22] <QtPlatypus> gantrixx: Thats a c style for loop.

[06:22] <gantrixx> OK, so what is the new Perl6 style

[06:22] <luqui> that is correct, it's just not idiomatic

[06:22] <luqui> for 1..$max -> $i { stuff }

[06:22] <gantrixx> what did you call me?

[06:23] <gantrixx> :)

[06:23] <luqui> hehe

[06:23] <gantrixx> just kidding

[06:23] <luqui> ?say "eval is back!"

[06:23] <gantrixx> is there a better way?

[06:23] <luqui> ?eval say "eval is back!"

[06:23] <evalbotzy> eval is back! bool::true 

[06:23] <gantrixx> because this way doesn't seem to work

[06:23] <luqui> gantrixx, what do you mean?

[06:24] <luqui> ?eval for 1..10 -> $i { say $i }

[06:24] <evalbotzy> 1 2 3 4 5 6 7 8 9 10 undef 

[06:24] <gantrixx> it keeps saying that $i is undeclared

[06:24] <luqui> oh, you mean in the loop () form?

[06:24] <gantrixx> yes

[06:25] <luqui> loop (my $i = 1; $i <= $max; $i++ ) { stuff }

[06:25] <gantrixx> I tried that too

[06:25] <luqui> ?eval loop (my $i = 1; $i <= 10; $i++) { say $i }

[06:25] <evalbotzy> Error: No compatible subroutine found: "&my" 

[06:25] <luqui> ohhh, that's right

[06:25] <luqui> my is still broken

[06:25] <luqui> ?eval my $i; loop ($i = 1; $i <= 10; $i++) { say $i }

[06:25] <evalbotzy> 1 2 3 4 5 6 7 8 9 10 undef 

[06:26] <gantrixx> well I'm trying it the    loop 1..$.max -> $i { stuff }      way

[06:26] <gantrixx> now it's complaining about unexpected {

[06:26] <gantrixx> I just can't win

[06:27] <luqui> s/loop/for/

[06:27] <gantrixx> but sometimes I've see this when it is missing a ;

[06:27] <gantrixx> ok, it works now

[06:28] <luqui> which one did you do?

[06:28] <gantrixx> this is a good speed test for the interpreter.....shuffling a 6 deck shoe

[06:28] <gantrixx> for 1..$.max { stuff }

[06:28] <luqui> prepare to be disappointed :-)

[06:28] <luqui> cool, that's the way the perl gods intended it

[06:28] <gantrixx> wow, this is slow

[06:31] <QtPlatypus> gantrixx: Its not speed optimized yet.

[06:31] <luqui> PIL2 should help with that

[06:32] * QtPlatypus nods "And hopefully make alot of stuff easy to write"

[06:34] <gantrixx> Well, it's not that slow

[06:34] <gantrixx> It's reasonable

[07:05] <xinming> anyone here knows chinese? I wish to know the translation of the word delegation.

[07:06] <xinming> hmm, I looked up the word in the directionary. But I want to know if that's what it means.

[07:16] <Khisanth> autrijus probably knows :)

[07:19] <xinming> Khisanth: He might be busy working with pugs. :-)

[07:20] <Khisanth> or sleeping!

[07:22] <xinming> seen autrijus 

[07:22] <jabbot> xinming: autrijus was seen 13 hours 23 minutes 9 seconds ago

[07:23] <xinming> BTW which editor are you using to handle the perl 6 code?

[07:31] * Khisanth uses vim in gnome terminal

[07:34] <luqui> in the pugs repository there is a vim syntax file for perl 6

[07:34] <luqui> which makes editing it so much nicer

[07:49] <xinming> ?eval my @ary; my $aryref := @ary;

[07:49] <evalbotzy> [] 

[07:50] <xinming> hmm, by the way, is := the same as = here?

[09:32] <nothingmuch> good morning

[09:35] <castaway> mornin

[09:48] <nothingmuch> for some reason I have all sorts of crap music on my comp all of a sudden

[09:48] <arcady> it's a virus!

[09:48] <arcady> a crap-music-downloading virus

[09:48] <arcady> spread by the RIAA

[09:49] <nothingmuch> oh, I get it

[09:49] <nothingmuch> this is some friend's music dir

[09:49] <nothingmuch> I went through it, after copying it

[09:49] <nothingmuch> and I didn't really think it was something

[09:49] <nothingmuch> appearantly itunes gobbled it up when I installed the new comp

[09:51] <nothingmuch> there's christmas songs, and some of the soundtrack to Top Gun

[09:51] <nothingmuch> and, uh, all sorts of really weird stuff

[10:09] <ods15> nothingmuch: umm, what's your ip...

[10:09] <ods15> i mean, why is it pasta.woobling.org

[10:09] <nothingmuch> pasta.woobling.org... why?

[10:09] <nothingmuch> because that's my domain

[10:09] <ods15> i just noticed, you aren't grey

[10:09] <nothingmuch> and that's what my reverse pointer is

[10:09] <ods15> what isp do you use?

[10:09] <nothingmuch> bezeq

[10:09] <nothingmuch> but i have a business account

[10:09] <ods15> you asked them to reverse dns to that?

[10:09] <nothingmuch> yes

[10:09] <ods15> oh.. doesn't that cost much more money?

[10:10] <ods15> how much upload do you have

[10:10] <nothingmuch> 278kbit

[10:10] <nothingmuch> 1.5m down

[10:10] <ods15> wow neat.. how...

[10:10] <nothingmuch> again: business account

[10:10] <nothingmuch> it's more $, but it's worth it

[10:10] <ods15> i mean, isn't the buissness account for buisnesses only?

[10:10] <ods15> whats the price

[10:10] <nothingmuch> social engineering =)

[10:11] <ods15> oh bah, that

[10:11] <nothingmuch> around 300 nis altogether a month

[10:11] <nothingmuch> maybe slightly less

[10:11] <ods15> heh that's quite a bit

[10:11] <ods15> including bezeq adsl?

[10:11] <nothingmuch> yes it is, but the difference is astounding

[10:11] <nothingmuch> yes, and no... it's cable

[10:11] <nothingmuch> that's the combination of carrier+ISP

[10:11] <ods15> ok, so including cable? heh

[10:12] <ods15> well, it almost 2 times as much.. iirc i pay 120 altogether...

[10:12] <nothingmuch> yup

[10:12] <ods15> almost 3 times*

[10:12] <nothingmuch> the advantages:

[10:12] <nothingmuch> dhcp instead of those fucking dialers (that's for bezeq regardless of business or not)

[10:12] <ods15> so, damn, an extra 200 shekels for more upload and a reverse dns? yes, more upload is ERY good, but not THAT good..

[10:12] <nothingmuch> bit torrent *FLIES*

[10:13] <nothingmuch> i don't feel load of webserver or mailserver

[10:13] <ods15> i usually get BT at 50-70k...

[10:13] <nothingmuch> my server isn't likely to be spammy

[10:13] <nothingmuch> ods15: do you give back a good ratio?

[10:13] <nothingmuch> i tended to get around 20-30 when I was on 96k

[10:13] <ods15> my ratio is usually 0.001

[10:13] <nothingmuch> that's evil

[10:13] <ods15> heh i love it

[10:14] <nothingmuch> seriously man, that's evil

[10:14] <nothingmuch> upload more

[10:14] <nothingmuch> my ratio is between .8 and 3

[10:14] <nothingmuch> for big files too

[10:14] <ods15> if my isp didn't suck so bad i would

[10:14] <nothingmuch> use a traffic shaper and leave it in the background

[10:14] <ods15> but generally i'm evil with my upload

[10:14] <nothingmuch> what kind of files do you download, btw? 70k is amazing if you don't upload

[10:14] <ods15> you mean, the kind where you can still download 100% while uploading?

[10:15] <ods15> movies mostly, in rare occassions programs

[10:15] <ods15> but i mostly dl at 120kb/sec from xdcc, tv shows

[10:15] <ods15> that's my real specialty..

[10:16] <ods15> anyway, the cables in my house suck SO bad, that believe me, no matter wtf traffic shaper i use, there's no way on earth i'll get fast download when uploading

[10:16] <ods15> seriously, i've tried all kinds of traffic shapers

[10:16] <ods15> and they helped, a little, but seriously marginally

[10:17] <ods15> basically it goes, if don't upload, i can dl at 120k (when my max should be 190!! i _NEVER_ get that from those xdcc's! only from sites, and even THATS rare), if i upload at 5k, i can dl at 60k, if i upload at 9k, and i'm lucky, i can dl at 5k...

[10:17] <ods15> which is why i ALWAYS limit my bt to 2k

[10:17] <ods15> sometimes i'm like 'wtf, why is bt barely dling at 2k

[10:18] <ods15> then i realize i forgot to limit it and its uploading at 7k

[10:18] <ods15> thats how much my connection sucks

[10:18] <ods15> adsl in general in israel sucks, mine just sucks more, cause of wiring in the building

[10:19] <ods15> (my sister worked at tech support adsl, they can actually check if the connection from them to my adsl is ok, she checked, it's suck ass)

[10:22] <ods15> nothingmuch: i know that reverse dns is new, cause i have seen you grey before...

[10:22] <ods15> when did you get it, only like a week ago or something

[10:22] <nothingmuch> yes it is

[10:22] <nothingmuch> sorry, i was away

[10:23] <ods15> i color all israelis grey, and i noticed all of a sudden you weren't anymore...

[10:23] <ods15> i thought you just weren't resolving for a bit and then it stayed, so i whoised :)

[10:24] <nothingmuch> i switched from nv to bezeq intl about 2 weeks ago

[10:24] <nothingmuch> nv sucked real bad (connection was always dropping)

[10:24] <ods15> nv?

[10:24] <nothingmuch> netvision

[10:24] <ods15> oh

[10:24] <nothingmuch> then a few days after I got connected i setup the rev ptr

[10:24] <ods15> well, i'm not sure whats the status on isps is anymore

[10:25] <ods15> about 2 years ago, the status was 012 > 013 > internet zahav > netvision> bezeqint

[10:25] <ods15> i use 012, and i think i'm worse off than when i was with bezeqint back then, which was REALLY bad, so i dunno

[10:26] <ods15> 012 was very good when i just switched to them, a huge improovement from bezeqint...

[10:32] <nothingmuch> right now I have decent pings, good throughput, and a reliable connection

[10:32] <nothingmuch> so I'm happ[y

[10:32] <nothingmuch> i hear that 012 ~~ bezeqing > nv > internet zahav > 013

[10:36] <ods15> wow 013 sinked then i guess.. it was just about same as 012 then, i.e., best

[10:36] <ods15> and bezeqint took its place :P

[10:37] <ods15> but anyway, all of it doesnt matter in my case cause my wiring simply sucks :( i should switch to cable or something, but it took me a YEAR to convince my dad to switch to 012 instead of ebzeqint (he works at bezeq), i doubt it'll be possible at all for me to convince him to switch to cable...

[10:40] * castaway slaps ods15 for misusing BT..

[10:40] <ods15> i told you, i wouldnt be evil if my upload didnt suck

[10:40] <castaway> then dont download ?

[10:40] <ods15> i used to be non-evil, but evantually i realized it just wasnt practical

[10:41] <castaway> ours sucks too, we just leave it running a week

[10:41] <theorbtwo> Ours sucks differently, though.

[10:41] <castaway> shhh thats not the point!

[10:41] <theorbtwo> We can't drop much below 1 no matter what we do, because our downstream is often slower then our upstream on BT.

[10:42] <theorbtwo> On non-BT it sucks much less.

[10:42] <castaway> you're not helping ,)

[10:42] <theorbtwo> If it doesn't improve drasticly at the new place, I'll try shaping, QOS, and the like.

[10:43] <theorbtwo> I suspect our provider sucks on BT on purpose, and our router is old and slow and not helping matters.

[10:43] <theorbtwo> ...but we'll likely change routers at the new place anyway.

[10:43] * castaway doesnt think the router is the/a problem

[10:43] * nothingmuch is very happy with meta-box as router

[10:43] <nothingmuch> it does mail, web, etc

[10:44] <nothingmuch> and also wonderful traffic shaping

[10:44] * castaway sighs

[10:44] <nothingmuch> btw - for all of you music downloaders - musicbrainz's clients were updated

[10:44] <nothingmuch> please use them, they are good for you and good for other people who use them too

[10:45] <theorbtwo> Our router does web and routing only.

[10:45] <castaway> wtf is that?

[10:45] <nothingmuch> castaway: you calculate an accoustic checksum for the song

[10:45] <nothingmuch> from then on it's like freedb

[10:45] <nothingmuch> only higher quality entries

[10:45] <theorbtwo> Eh?

[10:45] <castaway> umm, oh

[10:45] <castaway> I dont think I care ;)

[10:46] <theorbtwo> I thought it was a P2P music sharing ap.

[10:46] <nothingmuch> and it doesn't need the original CD, which you, uh, obviously lost, and that's why you were downloading off the internet to begin with ;-)

[10:46] <castaway> it should ,)

[10:46] <nothingmuch> it should what?

[10:46] <castaway> require the CD ,)

[10:46] <nothingmuch> ah

[10:47] <nothingmuch> but it doesn't

[10:49] <theorbtwo> "SendQ exceeded"?  First time I've seen that one...

[10:52] <ods15> 13:43:43  * nothingmuch is very happy with meta-box as router - btw, i use ipcop

[10:57] <nothingmuch> hmm... i guess NAT was enough for me

[10:57] <svnbot6> r6374 | scook0++ | * Misc. Haddock for Parser.hs

[10:57] <nothingmuch> what other advantages does ipcop have?

[11:14] <ods15> nothingmuch: well, i dunno, it's just overall nice, there's no special advantage

[11:14] <ods15> has all the regular services, you can set it to update dyndns, traffic graphs, etc.

[11:14] <nothingmuch> ods15: is it just a wrapper for iptables? because "if it ain't broke, don't fix it" is my system administration motto

[11:15] <nothingmuch> hmm... graphs might be nice, but unnecessary

[11:15] <ods15> ?

[11:15] <nothingmuch> dyndns is useless - i've got a static IP

[11:15] <ods15> on occassion i use traffic graphs for connection "debugging"

[11:15] <TheMaaaa> does anybody know when iblech will be back from holiday again?

[11:15] <ods15> well its obviously useful for me

[11:16] <ods15> what do you mean by wrapper to iptables?

[11:16] <nothingmuch> iptables is the linux fw, right?

[11:17] <ods15> fw?

[11:17] <nothingmuch> firewall

[11:17] <nothingmuch> if ipcop is a userland firewall, it may be different

[11:17] <nothingmuch> but I doubt it

[11:17] <ods15> i know nothing of internet management on linux :/

[11:17] <nothingmuch> and my iptables is also configured to a working state, so I'd rather not touch

[11:17] <ods15> i use ifconfig a tiny bit, route a little, and mostly dhclient...

[11:18] <nothingmuch> this is at another level

[11:18] <ods15> anyway, i dunno, it's possibly a userland firewall, it has logs and everything

[11:18] <nothingmuch> route is somewhat related

[11:18] <nothingmuch> but basically it's the set of tables that every packet goes through

[11:18] <ods15> anyway, its obviously much more than a firewall, its an entire router...

[11:19] <ods15> tbh i dont get whats the point of having a firewall in your router to begin with

[11:19] * nothingmuch thinks he'll pass.. things have been working and I don't have the time to break them and fix them again

[11:19] <nothingmuch> a firewall and a router is the same thing

[11:19] <ods15> heh i didnt suggest you use ipcop...

[11:20] <nothingmuch> it's just that "firewall" is usually used to describe a router with one route and complicated rules

[11:20] <ods15> im saying that what i use and kind of asking if its any good

[11:20] <nothingmuch> and a "router" is usually used to describe a firewall with no complicated rules, but elaborate transformations and dispatches

[11:20] <nothingmuch> let me answer the question "if it's any good" by asking you a question: "does it make your life easier?"

[11:20] <ods15> i thought a router is a internet <-> nat thing, where as a firewall is just prtoection from malicious asshats

[11:21] <nothingmuch> both control what happens to packets coming in on an interface, and have multiple interfaces to move packets in and out of

[11:21] <nothingmuch> functionally any capable firewall OR router can get the job done well

[11:21] <ods15> nothingmuch: umm, i cant not have a router, thats like asking if having arms makes my life easier...

[11:22] <ods15> the only thing that annoys me about my router is that the web interface is FUCK SLOW

[11:22] <nothingmuch> high end hardware might be suited for a specific purpose for performance reasons, but anything "serious" should be able to do both tasks moderately well

[11:22] <ods15> well over 4 seconds to open each page, even 20 seconds on occassion

[11:23] <ods15> but i;ve been told thats only cause slow hardware

[11:23] <ods15> i run it on 75mhz

[11:23] <ods15> and guy with 200mhz says it runs totally smooth for him

[11:23] <nothingmuch> that should be enough

[11:23] <nothingmuch> my box is ~1.8ghz =)

[11:24] <ods15> the ROUTER?

[11:24] <nothingmuch> yes

[11:24] <nothingmuch> but it does other jobs too:

[11:24] <nothingmuch> mail (imap, pop, smtp, spam filtering, all that)

[11:24] <ods15> well, actually, you own a macintosh laptop, you might as well be a millionare :P

[11:24] <nothingmuch> (including running mutt on my 32,000 message inbox)

[11:24] <castaway> (hmm, P90, but no web interface needed for iptables ;)

[11:25] <nothingmuch> mail for ~10 other users

[11:25] <ods15> i run exim on this box, not on the router

[11:25] <ods15> 10 other users? you admin for other ppl?

[11:25] <nothingmuch> webserver, with dynamic apps (gallery, squirrelmail, occasional experimentation)

[11:25] <ods15> just random ppl from net using your box as inbox?

[11:25] <nothingmuch> 10 other users - friends with mail accounts on my box

[11:25] <ods15> ah, what i said

[11:25] <nothingmuch> it's also DNS, DHCP, and all that mess

[11:25] <ods15> dont be so proud of 32,000 msgs :P

[11:26] <nothingmuch> i'm not proud... my story is: at 1000 i was like "if I don't clean this up quick it's going to be too late"

[11:26] <ods15> 385M    .kde/MyDocs/Mail

[11:26] <nothingmuch> tsk tsk

[11:26] <nothingmuch> du is still working

[11:26] <ods15> dns/dhcp etc. my router does too

[11:26] <ods15> you probably use maildirs

[11:27] <ods15> i use mboxes, that whole dir is ~15 files

[11:27] <nothingmuch> the reason I don't delete is that then threads become orphanned in mutt

[11:27] <nothingmuch> yes i do

[11:27] <nothingmuch> now i'm looking into a solution that knows how to remember that a certain thread is boring, and then I should be able to zap about 25,000 messages

[11:27] <ods15> anyway, hmm

[11:27] <ods15> what was i saying

[11:28] <ods15> oh, i run all services on this box

[11:28] <nothingmuch> the router box also runs mldonkey, which is heavy

[11:28] <ods15> Hostname: linux15 - OS: Linux 2.6.6/i686 - CPU: AMD Athlon(tm) XP 2500+ (1837.634 MHz) - Processes: 121 - Uptime: 12d 19h 24m - Load Average: 0.17 - Memory Usage: 330.12MB/503.42MB (65.58%) - Disk Usage: 47.28GB/327.13GB (14.45%) - External Traffic (eth0): 520.06MB In/2616.78MB Out

[11:28] <ods15> its not totally awesom,but its good enough

[11:28] <ods15> hehe, yeah i run mldonkey here too

[11:29] <ods15> anyway whats annoying me now is that i lost my webspace :(

[11:30] <ods15> i had some uber good webspace for quite a long while, and a whileago it disappeared and still hasn't returned :(

[11:30] <nothingmuch> the reason I have my own box and business acct and all that - i got tired of the longevity (or lack thereof) of webspace, mail addresses, etc

[11:31] <ods15> longevity?

[11:31] <ods15> my webspace was pretty damn reliable

[11:31] * castaway has her email address 10 yrs now

[11:31] <nothingmuch> mail addresses tend to live for about 2-3 years tops

[11:31] <nothingmuch> webspace tends to live about 1 year

[11:31] <castaway> they do?

[11:31] <nothingmuch> unless you have an account somewhere serious

[11:31] <ods15> but of the man users on it, i was one of the few that wasnt paying for it

[11:32] <nothingmuch> which either costs money

[11:32] <ods15> mine was VERY serious, i knew the admin personally

[11:32] <nothingmuch> or is there because you work there

[11:32] <nothingmuch> or if you have a friend who admins one of those

[11:32] <castaway> ah, well cheap/free ones dont count

[11:32] <castaway> you get what you pay for ;)

[11:32] <nothingmuch> castaway: true... and if i'm going to pay i might as well have it my way

[11:32] <castaway> yup

[11:32] <ods15> the problem is that now he's disappeared, and wont answer mails (he's busy, he answered a few old mails to other ppl that mailed him), and my account is still missing

[11:33] <nothingmuch> ods15: maybe he hates you

[11:33] <ods15> they did a switch from one pc to another or something, and since then my account hasnt returned

[11:33] <ods15> possible

[11:33] <ods15> anyway, i'm not begging mplayer fokes to gimme mplayerhq.hu/~ods15/ :)

[11:34] <ods15> nothingmuch: so, umm, you run your own webspace?

[11:34] <nothingmuch> yep

[11:34] <ods15> even with 300kbps up, that aint enough, atleast not for my needs

[11:34] <castaway> (the email account is actually a dialin, but I never do.. so email is costing me 12 euro/month ,)

[11:34] <nothingmuch> my needs are modest

[11:34] <ods15> i put up pics, movies, programs, etc.

[11:35] <nothingmuch> i put up text

[11:35] <castaway> text++

[11:35] <ods15> yeah that would be the difference...

[11:35] <nothingmuch> and s3cr3t-linkz-fuh-friendz

[11:35] <nothingmuch> and a modest webgallery

[11:35] <ods15> i guess i can use http://kmenc15.sf.net/ , but i hate sf.net

[11:35] <nothingmuch> sf.net for your personal needs?

[11:35] <nothingmuch> isn't that a violation of the agreement?

[11:35] <ods15> yeah, not a good idea

[11:36] <castaway> collaborative websites ;)

[11:36] <ods15> heh i dont remember it

[11:36] <ods15> besides who cares :P

[11:36] <nothingmuch> well, it's not very nice to take the bw and space they give you for a project and misuse it

[11:36] <nothingmuch> this being opensource most people are poor

[11:36] <nothingmuch> and sf.net is doing a service for the poor people

[11:36] <nothingmuch> so don't make them poor

[11:36] <ods15> i dont use that much bw anyway, i think my project is near dead :P

[11:37] <nothingmuch> yes, but other projects need the disk and bandwidth

[11:37] <ods15> and yes, its painfully obvious that sf.net are broke. the m$ ads are a good hint...

[11:37] * castaway thinks they should charge a mini amount per project/yr

[11:37] <nothingmuch> castaway: the problem is the added beurocracy

[11:38] <ods15> castaway: that would prevent A LOT of projects going there

[11:38] <castaway> other projects that do such cope ,)

[11:38] <ods15> even if i wanted to, i couldnt pay, i have no credit card

[11:38] <castaway> ods15 if you cant afford, say, $1 a month or year...

[11:38] <nothingmuch> castaway: part of the mission statement is to preserve as much data as possible

[11:38] <castaway> ods15: also, a lot of them are not worth it anyway ;)

[11:38] <ods15> someone tried to give me a donation a fe months ago, and i coulldnt accept it!!

[11:38] <nothingmuch> castaway: in israel it's hard to get an int'l credit card before your 22 years old or so

[11:39] <castaway> why would you need a credit card to accept it?

[11:39] <nothingmuch> again, i have one due to social engineering

[11:39] <nothingmuch> what would you do, send a cheque?

[11:39] <ods15> because no other transactions are allowed with israels

[11:39] <ods15> nothingmuch: i think thats my biggest problem

[11:39] <ods15> i have zero social engineering

[11:39] <nothingmuch> ods15: practice... it costs you nothing to lose

[11:40] * castaway shrugs .. it would obviously have to be worked out per country/possibility etc

[11:40] <nothingmuch> castaway: you'd be surprised how hard it is to shop on ebay when you're in israel

[11:40] <castaway> I dont think I would..

[11:42] <xinming> multi sub is_even (Int $value:) {

[11:42] <xinming>     $value % 2 == 1;

[11:42] <xinming> }

[11:42] <xinming> 5.is_even 

[11:42] <xinming> how can this work please?

[11:42] <xinming> multi sub isn't a keyword to define a "method" :-S

[11:42] <nothingmuch> again with the multis... WHY DON"T THEY CONSOLIDATED IT ALREADY?!

[11:42] <nothingmuch> sorry

[11:43] <nothingmuch> i'd say 'class Int is extended { method is_even ($value:){ $value % 2 } }'

[11:43] <nothingmuch> oh wait, is Int a role or a class this week?

[11:44] <scook0> the way things are going, I don't think Perl 6 will come out with /any/ classes :)

[11:44] <scook0> just a bazillion roles

[11:44] <castaway> (or come out at all :)

[11:44] <scook0> castaway: ooh, that was low :)

[11:44] <ods15> nothingmuch: ugh, '$value & 1' !!

[11:44] <castaway> just realistic

[11:44] <ods15> not % 2 ...

[11:44] <nothingmuch> ods15: no... that's only for 'int'

[11:45] <ods15> ah bah

[11:45] <nothingmuch> for something pretending to be an Int & 1 is not necessarily consistent

[11:45] <nothingmuch> it might not be repreented as bits at all

[11:45] <ods15> well his original was only int :)

[11:45] <nothingmuch> no, it wasn't

[11:45] <nothingmuch> Int is a boxed type, that is a class

[11:45] <nothingmuch> 'int' is N bits representing a number

[11:45] <ods15> oh, right, perl6 ugliness, nm :)

[11:45] <nothingmuch> ods15: please don't judge

[11:46] <ods15> ok ok

[11:46] <nothingmuch> ods15: if you have nothing to contribute don't call it uglyness

[11:46] <nothingmuch> boxed vs unboxed types have their merits

[11:46] <nothingmuch> and just because C doesn't have boxed types doesn't mean that's the best way to go

[11:46] <ods15> btw nothingmuch, you probably know better than i do, are there any fun/interesting event in israel like that august penguin?

[11:46] <ods15> that was the first time i've ever been in such a thing

[11:46] <nothingmuch> august penguin was boring =(

[11:47] <nothingmuch> YAPC::Israel is more fun

[11:47] <ods15> where when

[11:47] <nothingmuch> google google

[11:47] <nothingmuch> probably mid feb

[11:47] <ods15> doing so, shush

[11:47] <nothingmuch> probably in hertzelia interdisciplinary center

[11:47] <ods15> any other event though?

[11:48] <nothingmuch> not that I know of

[11:48] <ods15> oh, umm, perl only?

[11:48] <nothingmuch> yes, YAPC is Yet Another Perl Conference

[11:49] <ods15> hmm, 17th feb 2005

[11:49] <ods15> thats past

[11:49] <nothingmuch> 2006

[11:49] <ods15> 2006 is 404

[11:50] <nothingmuch> wait for szabgab to update it

[11:50] <ods15> sigh

[11:50] <nothingmuch> you can come to the Israel.pm meetings, they're either boring or very very fun

[11:50] <ods15> oh well, seems expensive too

[11:50] <ods15> when are they

[11:50] <nothingmuch> early bird is cheap

[11:50] <ods15> i could use ANY kind of meeting

[11:50] <ods15> 90 nis i saw?

[11:50] <nothingmuch> they are monthly

[11:50] <nothingmuch> yes, that's cheap

[11:51] <nothingmuch> YAPC::NA is $85

[11:51] <nothingmuch> OSCON is $700+

[11:51] <nothingmuch> 90 NIS is dirt cheap

[11:51] <ods15> i preffer august penguin's price

[11:51] <ods15> which was 30 nis, or actually free for me

[11:51] <nothingmuch> august penguin is appearantly better subsidized... it's in direct ratio to the number/size of sponsorships

[11:51] <nothingmuch> inverse ratio, that is

[11:51] <ods15> hehe

[11:52] <nothingmuch> except for OSCON which isn't nonprofit

[11:53] <ods15> whAT oscon

[11:53] <ods15> whats

[11:53] <nothingmuch> oreilly's open source conference

[11:53] <nothingmuch> a spinoff from TPC (the perl conference)

[11:53] <ods15> oh that

[12:22] <svnbot6> r6375 | scook0++ | * Haddocks for use/no/require in Parser.hs

[12:38] <dudley> Is a Pad in PIL2 analogous to a typeglob in Perl 5?

[12:40] <dudley> Or does a Pad store multiple names?

[12:40] <nothingmuch> dudley: uh, sort of

[12:40] <nothingmuch> it says "this new lexical symbol pops into existence"

[12:41] <scook0> and be careful not to confuse the Pad data-constructor with the Pad type

[12:41] <dudley> oh, crap.

[12:41] <scook0> there's lots of that sort of punnery in Pugs

[12:42] <dudley> Well, does every symbol in a Pad have the same Name, with different Sigils?

[12:43] <dudley> or is there one symbol per Pad?

[12:43] <nothingmuch> dudley: that's an implimentation detail

[12:43] <nothingmuch> the sigil is part of the name

[12:43] <scook0> dudley: hold up

[12:43] <nothingmuch> as I see it the simplest implementation is: keep a stack of symbols

[12:43] <nothingmuch> and keep a stack of scope frames

[12:43] <scook0> tell me what file you're looking at right now

[12:44] <nothingmuch> scopes refer to the last element in the linked list stack

[12:44] <dudley> scook0: The one in my brain.

[12:44] <nothingmuch> as you create new symbols you push new pad items to the stack

[12:44] <nothingmuch> as you enter a scope you record the symbol stack head in the scope stack

[12:44] <nothingmuch> lookup traverses the symbol stack, starting from scope stack element #x where x is the number of OUTER::'s encountered in the name

[12:45] <nothingmuch> when you leave a scope you pop the symbol stack until you find the the head of the scope stack, and then you pop one element from the scope stack

[12:45] <nothingmuch> but that is inefficient

[12:45] <nothingmuch> the scope stack may be a stack of hashes

[12:45] <nothingmuch> where each pad is a hash

[12:46] <nothingmuch> and each Pad node creates a new key in the hash

[12:46] <nothingmuch> that's also a simple mapping, but not as "functional" ;-)

[12:46] <dudley> :)

[12:46] <nothingmuch> that's probably what the perl5 runtime should do

[12:47] <nothingmuch> btw - scope enter does not necessarily mean dynamic scope

[12:48] <nothingmuch> the scope stack maintained by that is the dynamic scope one (CALLER::)

[12:48] <nothingmuch> but for lexical, each scope has a ref to it's parent scope

[12:48] <iblech> Hi :)

[12:48] <iblech> oooh PIL2 discussion :)

[12:48] <nothingmuch> hola iblech, you were sought after earlier

[12:48] <dudley> Not so much discussion as instruction :)

[12:48] <iblech> nothingmuch: pads as stack of hashes -- this is exactly what PIL2JS does

[12:49] * iblech backlogs

[12:49] <dudley> nothingmuch is learnin' me some stuff

[12:49] <nothingmuch> iblech: pads are stack frames

[12:49] <nothingmuch> whether they are stack elements or regions of the stack, it doesn't matter =)

[12:50] <iblech> yep

[12:51] <nothingmuch> anyone who has a song named "Bitch Niggaz" is obviously an idiot... *sigh*

[12:52] <nothingmuch> what does that even mean?

[12:52] <dudley> scook0: I'm mostly looking at src/PIL/Container.hs and src/PIL/Pad.hs

[12:52] <dudley> nothingmuch: I kind of like that song :)

[12:52] <nothingmuch> dudley: it could be a good song, but the title is stupid

[12:53] <nothingmuch> and I infer the person who came up with a title is also stupid

[12:53] <dudley> I didn't say it was a _good_ song :)

[12:53] <nothingmuch> dudley: i don't know the song, and 'good' is subjective

[12:53] <nothingmuch> OTOH i do know the title, and stupid is objective because I am the center of the universe

[12:53] <dudley> but yes, the title is quite stupid

[12:53] <nothingmuch> so there

[12:54] <scook0> nothingmuch: you're the centre of the universe?

[12:54] <scook0> crap

[12:54] <nothingmuch> it came up as a possible tag for a Grateful Dead song... no clue how =)

[12:54] <scook0> I thought that was me...

[12:54] <nothingmuch> scook0: you too

[12:54] <dudley> heh

[12:54] <nothingmuch> it just depends on your POV

[12:54] <nothingmuch> from my POV things are organized in a radial fashion, around me

[12:54] <nothingmuch> hence I am the center of the universe

[12:55] <scook0> nothingmuch: deep...

[12:55] <nothingmuch> because I have no grasp of the end of the universe, it might aswell be round, with me at the center

[12:56] <nothingmuch> regardless, that song title is stupid because I said so =)

[12:58] <scook0> iblech: I was looking at ruleUseJSANModule in Parser.hs earlier

[12:58] <scook0> trying to refactor it into ruleUsePackage and friends

[12:59] <scook0> I've stopped for now because it was getting complicated

[12:59] <iblech> The problem is that ruleUseJSANModule doesn't do anything at compile-time

[12:59] <iblech> in contrast to the regular uses

[13:00] <iblech> Therefore I created an own rule for it

[13:01] <scook0> I see

[13:01] <nothingmuch> anybody want to shove me in the right direcction WRT fixing my smoke report?

[13:01] <nothingmuch> it's failing the parrot rule stuff

[13:03] <scook0> iblech: but I see no real reason for them to be separate

[13:03] <nothingmuch> eep, wtf is Test::Code all about

[13:03] <scook0> (other than the fact that merging them would require work and refactoring)

[13:04] <nothingmuch> might as well copy your .pm file to the t/ dir and make sure the files are identical

[13:04] <iblech> scook0: Well, you'd need lots of if and cases

[13:04] <scook0> iblech: yeah, that was the 'getting complicated' part

[13:04] <iblech> :)

[13:05] <scook0> well, I'll try changing both of them in small steps until they resemble each other more closely

[13:05] <scook0> then merging should be easier

[13:05] <iblech> scook0++

[13:06] <iblech> pdcawley_: t/unspecced/cont.t passes 11/13 on PIL2JS :) Working on the two remaining tests

[13:11] <scook0> iblech: it wouldn't make sense to 'no' a JSAN package, would it?

[13:11] <iblech> Right, IIRC JSAN doesn't support that

[13:14] <scook0> I shall make it an error then

[13:17] <iblech> Yep

[13:22] <scook0> (bah, compiling takes WAY too long...I need more RAM)

[13:22] <integral> iblech++ # cont.t

[13:24] <xinming> hmm, I've read the example in example/vmmethods/ .

[13:28] <iblech> pdcawley_: Now 12/13 :)

[13:30] <xinming> In my understanding. In keyword multi will define a function which will dynamic append to a specified class?

[13:30] <xinming> anyone here would tell me if I am right or wrong?

[13:34] <scook0> xinming: I don't think that's right

[13:34] <scook0> 'multi' means you can have more than one sub/method/whatever with the same name

[13:35] <QtPlatypus> As long as they have diffrent signatures.

[13:35] <scook0> then, when you call it at run-time, it will pick the most appropriate version, based on the types of the arguments

[13:37] <xinming> seen autrijus 

[13:37] <jabbot> xinming: autrijus was seen 19 hours 37 minutes 51 seconds ago

[13:39] <iblech> integral: 14/14 :)

[13:48] <svnbot6> r6376 | iblech++ | * Usual svn props.

[13:48] <svnbot6> r6376 | iblech++ | * PIL2JS: &?CALLER_CONTINUATION.

[13:48] <svnbot6> r6376 | iblech++ |   * t/unspecced/cont.t: Added some type annotations and a new test.

[13:48] <svnbot6> r6376 | iblech++ |     PIL2JS passes 14/14 with 6 unexpected succeedings. :)

[13:48] <svnbot6> r6376 | iblech++ |   * PIL, PIL2JS.js: PIL2JS.cps2normal now works correctly with functions

[13:48] <svnbot6> r6376 | iblech++ |     which reach the end of the program (this can happen, for example, with

[13:48] <svnbot6> r6376 | iblech++ |     continuations :)). Previously, the program flow was restarted after the

[13:48] <svnbot6> r6376 | iblech++ |     call to PIL2JS.cps2normal, resulting in certain regions running twice.

[13:48] <svnbot6> r6376 | iblech++ |   * PIL, PIL::PVar, PIL::Subs: sub foo { {return}() } didn't compile, because

[13:48] <svnbot6> r6376 | iblech++ |     PIL2JS only kept track of the current subtype, not of all subs it's

[13:48] <svnbot6> r6376 | iblech++ |     currently in. Fixed.

[13:48] <svnbot6> r6376 | iblech++ | * PIL2JS: PIL, PIL2JS.js, README: Context objects are now unboxed -- boxing was

[13:48] <svnbot6> r6376 | iblech++ |   never needed. Should give a small speedup.

[13:51] <ods15> why does svnbot6 keep flooding the channel?

[13:53] <nothingmuch> ods15: because it's useful info

[13:53] <ods15> i cant make head or tails of it

[13:53] <ods15> iblech must have huge karma by now

[13:53] <nothingmuch> ods15: than read more carefully

[13:53] <iblech> ods15: svnbot6 relays new commits to the repository

[13:54] <jhorwitz> karma iblech

[13:54] <ods15> whats the r6376 mean

[13:54] <jabbot> jhorwitz: iblech has karma of 337

[13:54] <iblech> revision 6376

[13:54] <jhorwitz> karma autrijus

[13:54] <jabbot> jhorwitz: autrijus has karma of 574

[13:54] <iblech> rREVISIONNUMBER | committername++ | description as given by the committer

[13:55] <ods15> hmm, what has higher precedence in perl5, space or operators?

[13:55] <ods15> func $bla > 10

[13:55] <ods15> is it

[13:55] <ods15> func($bla > 10)

[13:55] <ods15> or

[13:55] <ods15> func($bla)> 10

[13:55] <ods15> ?

[13:55] <nothingmuch> ods15: that depends on when and how func was defined

[13:56] <ods15> in this case, func is 'scalar'

[13:57] <nothingmuch> it still depends

[13:57] <nothingmuch> ;-)

[13:57] <wolverian> I don't think a space has much precedence in perl5 at all

[14:00] <svnbot6> r6377 | scook0++ | Phase 1 of my 'use'-parser refactoring:

[14:00] <svnbot6> r6377 | scook0++ | * Unified the 'lang' parser for JSAN & Perl packages

[14:00] <svnbot6> r6377 | scook0++ | * JSAN & Perl paths now use similar code to parse the package name

[14:00] <scook0> well, I'm off to get some sleep--later all

[14:05] <integral> it depends on the type of operator,  unary named ops have different prec to list named ops

[14:05] <integral> ods15: so in the case of `scalar $a < 5` according to perlop, named unary ops are one prec level above <

[14:08] <ods15> hmm

[14:11] <nothingmuch> ods15: do you know perl?

[14:11] <ods15> i've done a few scripts..

[14:11] <nothingmuch> ods15: then why not learn it seriously?

[14:11] <nothingmuch> it's a pretty nice language... perhaps not as nice as <xyz>, but CPAN makes up for that

[14:11] <ods15> i like perl for it's intended usage, string manipulation

[14:12] <ods15> xyz? (was that a generic word?..)

[14:12] <nothingmuch> that is it's superficially intended usage

[14:12] <nothingmuch> but the language has progressed from 1987, you know

[14:12] <nothingmuch> replace xyz with whatever you think is better than perl

[14:12] <ods15> yeah so i figured

[14:13] <ods15> i do like perl, but i dont like what perl6 is trying to do with it

[14:13] <nothingmuch> why not?

[14:13] <ods15> i heard something about unicode operators?

[14:13] <nothingmuch> heh

[14:13] <nothingmuch> there's always ascii equivelents

[14:13] <nothingmuch> the unicode ones just look pretty

[14:13] <theorbtwo> We allow users to define whatever unicode operators they like.

[14:14] <theorbtwo> As for operators that are defined by the language, we limit ourselves to latin-1, and there's always a way to write it using pure ASCII if you prefer.

[14:14] <ods15> '\233' is not pretty :/

[14:14] <theorbtwo> Who said anything about \233?

[14:14] <nothingmuch> ods15: you don't need it to be \233

[14:14] <nothingmuch> ods15: i think you are really trying hard to ignore the big points of perl 6

[14:14] <theorbtwo> You can write @array  @array2, if you want.

[14:14] <nothingmuch> and instead you're nitpicking about small details that don't really make a difference

[14:15] <ods15> anyway, you took a complicated language, and made it more complicated

[14:15] <theorbtwo> You can also write @array Y @array2, or zip(@array;@array2).

[14:15] <nothingmuch> no, perl 6 is more simple

[14:15] <nothingmuch> because it's more consistent

[14:15] * castaway looks at nothingmuch  ,)

[14:15] <nothingmuch> and perl is also simple, it's just wide

[14:15] <theorbtwo> Perl 6 is more complicated to define, and more simple to use, we hope.

[14:15] <ods15> nothingmuch: so far i see added features, not reduced

[14:15] <iblech> nothingmuch: I'm about to un-warnock "Serializing code" -- I still don't get what you mean by "kind of value", could you elaborate please? :)

[14:15] <theorbtwo> Yep, ods15.  If you want a sparse language that has a simple defintion, you know where to find brainfuck.

[14:16] <ods15> i see perl6 falling down same trap as C++

[14:16] <nothingmuch> ods15: if you really knew perl 5 for more than just scripts, and really studied the synopsis you would see a kind of all-encompassing consistency

[14:16] <theorbtwo> iblech, for one, look forward to being able to write if (-1 < $x < 1) {...}.

[14:16] <nothingmuch> C++ is ugly because it has symptomatic solutions for problems

[14:16] <nothingmuch> iblech: one sec

[14:16] <theorbtwo> Anyway, I was planning to implement Hail and Ride, not do this...

[14:17] <nothingmuch> ods15: please study the synopses carefully before passing judgement

[14:18] <ods15> nothingmuch: yeah i'm generally trying not to pass judgement because i know very little/nothing about it

[14:18] <QtPlatypus> ods15: What trap is that?

[14:18] <theorbtwo> s/iblech/I/

[14:18] <nothingmuch> with all due respect it's appearant that you don't really know what you're talking about, since most of your criticism has too little facts, too much prejudice

[14:18] <iblech> nothingmuch: Sorry, just got informed I have to go to $work now, will be back in ~~6h (but I'll backlog, of course)

[14:18] <iblech> Later all :)

[14:18] <wolverian> theorbtwo, the set operators are not latin1 (although it's not exactly a core feature)

[14:18] <nothingmuch> iblech: ciao!

[14:18] * QtPlatypus fully expects that I will be able to write with a subset of Perl 6, without having to learn the entire langauge.

[14:19] <ods15> QtPlatypus: over complicated

[14:19] * castaway hopes so too

[14:19] <theorbtwo> wolverian, last I heard, the set operators were just an example... has that changed?

[14:19] <castaway> -p You can skip most of Perl6's new features if you like (iirc)

[14:19] <wolverian> theorbtwo, they're being used for types not as well. Int (+) Str

[14:19] <wolverian> s,not,now,

[14:19] <theorbtwo> QtPlatypus, I certianly expect you can, and I plan to avoid Junctions for the most part.

[14:19] <ods15> 17:18:10 <nothingmuch> with all due respect it's appearant that you don't really know what you're talking about, since most of your criticism has too little facts, too much prejudice - that's pretty true

[14:20] <ods15> i'm generally an asshat

[14:20] <nothingmuch> iblechbot: what I meant by "types of data" is not the value type (Int, Str, etc), but the nature of the data (global variables, closure owned pad snapshots, etc)

[14:20] <nothingmuch> ods15: is that a good thing?

[14:20] <ods15> anyway, i believe in "small is beautiful"...

[14:20] <theorbtwo> Oh... but that still has an ASCII alternative, right -- like you just wrote it?

[14:20] <ods15> nope

[14:20] <wolverian> theorbtwo, yes.

[14:20] <theorbtwo> Good.

[14:20] <wolverian> ods15, do you like Ruby?

[14:20] <ods15> wolverian: never tried it

[14:20] <castaway> (non-ascii operators - too futuristic.. )

[14:20] <wolverian> ods15, you might like it. it's pretty simplistic.

[14:20] <nothingmuch> iblech: the issue is - what happens to data in the environment that compiled code relies on? is it serialized too? is it symbolically stored, to be looked up on the other side?

[14:20] <ods15> tbh not sure what it is, guessing a programming language...

[14:21] <wolverian> ods15, http://www.ruby-lang.org

[14:21] <nothingmuch> ods15: small is beautiful applies to lots of perl 6 *code*

[14:21] <nothingmuch> there are some really amazing patterns captured in perl 6 (the language), which allow you to write code so elegant you want to nopaste it immediately

[14:21] <wolverian> ods15, while perl's syntax is not beautiful, its nature is. :)

[14:22] <wolverian> (what nothingmuch said.)

[14:22] <ods15> hehe i don't care about "beautiful" syntax :)

[14:22] <wolverian> that's good.

[14:22] <nothingmuch> hyperoperators, reductions, gather/take, lazy lists, functional aspects, post-object-oriented - these are all tools that let you simplify the way your intention is written in code

[14:23] <ods15> hehe

[14:23] <nothingmuch> ods15: take gather/take as an example

[14:23] <ods15> hmm

[14:23] <ods15> nothingmuch: ok, it's just not my style, it's not necessarily bad

[14:24] <ods15> i like control

[14:24] <nothingmuch> my @filenames = gather { for =$input_handle { take $_ if looks_like_a_file($_) } };

[14:24] <castaway> sound like you're stuck in the mud ods15 .. 

[14:24] <castaway> how many languages do you program in?

[14:24] <ods15> while writing a perl6 program, i'll most likely have absoloutely no idea whats going on 'under the hood', which i hate

[14:24] <castaway> its almost basic like again nm ,) (ie sounds like english)

[14:24] <nothingmuch> in perl 5 this looks like: my @filenames; while (<$input_handle>){ push @filenames, $_ if looks_like_a_file($_) }

[14:24] <ods15> castaway: define 'program in'

[14:24] <nothingmuch> except that gather/take is lazy

[14:24] <QtPlatypus> ods15: And you think you have that with perl 5?

[14:25] <castaway> regularly use, as opposed to 'did one script in 5 yrs ago'

[14:25] <castaway> Qt he doesnt know either much

[14:25] <nothingmuch> in C, i don't want to know what you have to allocate in there

[14:25] <ods15> i've hacked in C, perl, python, bash, VB, BASIC, PASCAL and probably quite a few other hideous langs

[14:25] <ods15> QtPlatypus: nope, not with perl5 either

[14:25] <castaway> a few scripts in perl hardly counts

[14:25] <nothingmuch> ods15: why not try a beautiful one for change? Scheme, perhaps?

[14:25] <castaway> LISP!

[14:26] <ods15> nothingmuch: heh lisp you mean?

[14:26] <ods15> i've tried that too, yes

[14:26] <nothingmuch> ods15: scheme is a beautiful dialect for a beautiful languagre

[14:26] * QtPlatypus loves scheme "I just hate the implemations"

[14:26] <ods15> QtPlatypus: but perl5 was ok, its intent was string manipulation (and more), and it did it beautifully

[14:26] <nothingmuch> then why didn't you grok the goodness of map/filter and so forth a while ago? Are you sure you "got" lisp?

[14:26] <castaway> perl*1*s intent was string manip.. perl5s wasnt

[14:27] <wolverian> ods15, if you hate not knowing what's going on under the hood, you're stuck with assembly

[14:27] <ods15> nothingmuch: no i didn't get into much.. hardly at all actually

[14:27] <ods15> i just saw the hideous () :)

[14:27] <ods15> wolverian: and C

[14:27] <nothingmuch> ods15: see, that is superficial judgement

[14:27] <castaway> hideous what?

[14:27] <nothingmuch> the parens mean nothing

[14:27] <nothingmuch> lisp can be written with just indentation

[14:27] <ods15> nothingmuch: yes i know

[14:27] <nothingmuch> or using a graphical tree

[14:27] <wolverian> ods15, right. why is it so important to you, though, to know what's going on under the hood?

[14:27] <ods15> i never got into it much

[14:28] <castaway> oh, parens in LISP :)

[14:28] <ods15> wolverian: control... when you dont know what youre doing, you start making hacks

[14:28] <nothingmuch> ods15: so why did you let the parens stop you? it's a shame that you're missing out on so much due to such a small barrier

[14:28] <ods15> "hey, this just happenned to work. i have no idea why, but it works. oh well, i'll just use it"

[14:28] <wolverian> ods15, you know what *you're* doing. you don't need to know what exactly the compiler is doing for you to get it done.

[14:28] <ods15> nothingmuch: i dunno, just never bothered, i guess i could look into it..

[14:28] <wolverian> ods15, as long as the program makes algorithmic sense the implementation doesn't matter.

[14:28] <nothingmuch> ods15: bullshit. cargo cult programming has nothing to do with highlevel programming

[14:28] <QtPlatypus> I've often heard that as an argument by hard core Cers against Garbage collectiors.

[14:29] <wolverian> ods15, right. you can do that in ASM and C as well. high level does not mean you can't learn algorithms.

[14:30] <ods15> wolverian: when things get more complicated you're not sure how the "language" will cooperate with your things

[14:30] <nothingmuch> ods15: look, this discussion is fruitless. I do not appreciate being called a cargo cult programmer just because I do perl

[14:30] <ods15> nothingmuch: whats a cargo cult programmer?

[14:30] <nothingmuch> i appreciate minimalism and essence in programming

[14:30] <wolverian> ods15, but things aren't more complicated. it's often simpler to state an algorithm in a high-level language than to write its implementation in C.

[14:30] <ods15> (i didnt call you that...)

[14:30] <nothingmuch> and I believe, with my experience, that C is just as prone to that (even more, perhaps) than a high level language

[14:30] <castaway> if you read up on the docs and such you'd know what the language was doing

[14:30] <nothingmuch> because understanding just how much control someone has is not something a newbie gets instantly

[14:31] <ods15> i care not about newbies

[14:31] <nothingmuch> oldbies do not copy-paste blindly, and i'm offended that you implied we do

[14:31] <dudley> a cargo cult programmer is someone who codes using idioms she doesn't understand because she's seen someone else do it.

[14:31] <ods15> nothingmuch: i implied?i must be misunderstanding me :(

[14:32] <QtPlatypus> ods15: What do you like programing in?

[14:32] <ods15> QtPlatypus: C is my favorite, then perl, then C++, and then VB. seriously.

[14:32] <nothingmuch> you said: "hey, this just happenned to work. i have no idea why, but it works. oh well, i'll just use it"

[14:32] <ods15> nothingmuch: yeah, i'm quoting random j. hacker

[14:33] <QtPlatypus> ods15: What is the problem space of most of your programing?

[14:33] <ods15> not you or anyone here...

[14:33] <nothingmuch> a language is good in the hands of an experienced programmer

[14:33] <ods15> QtPlatypus: ? what do you mean

[14:33] <nothingmuch> a language designed for idiots could come with an IDE with no copy-paste function

[14:33] <castaway> those sort of things are not language specific.. 

[14:33] <nothingmuch> if you are looking for a language that makes sure the programmer behaves you've got python and java, and they're good for what they do

[14:33] <QtPlatypus> ods15: What type of problems do you write programs to solve?

[14:33] <theorbtwo> Someone who codes like an idiot will do it in whatever language.

[14:33] <nothingmuch> but they also suffer from cargo cult madness

[14:34] <nothingmuch> my dad's colleague has some students help him with his protein-folding code... they copy paste all the time

[14:34] <ods15> QtPlatypus: ah.. well, multimedia sometimes, mathematical stuff sometimes, stuff just for my convinience (ie some task i do often..)

[14:34] <nothingmuch> and then he can't make folding deadlines, because the code is too bugyg

[14:34] <theorbtwo> It seems like your primary problem with perl is that you code perl like you don't know what perl's really doing.

[14:34] <theorbtwo> That's not perl's fault, it's yours.

[14:34] <nothingmuch> they use java, which was supposed to keep the stupid error factor down

[14:35] <nothingmuch> but it doesn't

[14:35] <theorbtwo> Nobody will deny that there exist bad perl programmers.  Perl's philosiphy has always been to give you plenty of rope.

[14:35] <nothingmuch> they get buggy code, but no buffer overruns, at the cost of 30% the performance it could have been

[14:35] <theorbtwo> It's up to you if you perfer to hang yourself, or make a net.

[14:35] <ods15> lol i like that :P

[14:35] <nothingmuch> ods15: C also gives you plenty of rope

[14:35] <QtPlatypus> I mean Matts Script archive vs CPAN and all that.

[14:36] <theorbtwo> Good then.  Get an account at perlmonks, and start programming well.  Then come back, and we'll tell you how perl6 can let you program better.

[14:37] <Khisanth> heh there is a page on shooting one's own foot in various languages :)

[14:37] <theorbtwo> What do you like least about programming, in whatever langauge?

[14:37] <ods15> i think perl6 is a different language for a different purpose.. you guys said it's built to work with big projects and such?

[14:37] <nothingmuch> ods15: let's refine the argument: a good language is one that lets the programmer get the best output from their intention, right?

[14:37] <Khisanth> ods15: only superficially

[14:38] <theorbtwo> ods: Perl6 should work for you, no matter what size your project is.

[14:38] <castaway> perl5 is already

[14:38] <theorbtwo> That has very little to do with what you program in, and more with how you program.

[14:38] <ods15> nothingmuch: no, a good language for me, is one that's fun to program in and in the end result makes my life better :)

[14:38] <nothingmuch> in that sense C is good, when "best" is constrained to performance or memory use

[14:38] <nothingmuch> fun to program in is a value of "best"

[14:38] <theorbtwo> I think perl6 will be fun to program in.

[14:38] <QtPlatypus> ods15: I've found perl 6 hell of alot more fun.

[14:38] <nothingmuch> life better is a part of 'intention"

[14:38] <ods15> 17:37:31 <theorbtwo> What do you like least about programming, in whatever langauge? - i'm not sure...

[14:39] <nothingmuch> in this sense, perl is good when you want it done in a short time, and you would like lots of code reuse, and performance isn't that much of an issue

[14:39] * QtPlatypus loves that he can say [~] @array.  Rather then join '',@array for example.  "I practally creamed my pants the first few times I did that"

[14:39] <ods15> ni i like preformance too

[14:40] <nothingmuch> ods15: you can get performance in perl for the parts that matter by using Inline::C, for example

[14:40] <ods15> this is in perl6 or 5?

[14:40] <nothingmuch> ods15: perl 6

[14:40] <nothingmuch> let me explain what it does:

[14:40] <ods15> figured, no compiler in perl5 :)

[14:40] <nothingmuch> compiler?

[14:40] <castaway> perl5 has Inline::C too

[14:40] <nothingmuch> oh.

[14:40] <nothingmuch> not inline::c, reduce

[14:40] <castaway> so eh?

[14:40] <nothingmuch> inline::C is perl 5 only, so far

[14:41] <nothingmuch> and perl 5 does have a compiler

[14:41] <theorbtwo> (With the stress on /so far/, I expect.)

[14:41] <nothingmuch> anyway, let me explain QtPlatypus's example

[14:41] <ods15> this is extremely funny, we've evolved from the days of c with inline asm into perl with inline c :P

[14:41] <castaway> Perl has inline more-or-less everything

[14:41] <nothingmuch> ods15: C is good for certain things, that's what Inline::C gives you!

[14:41] <theorbtwo> ods: You can also use Inline::ASM if you like, but I wouldn't recommend it.

[14:41] <nothingmuch> you're really not listening

[14:41] <castaway> (or Inline::Java, if you're crazy ,)

[14:42] <ods15> umm, i'm trying to... go on, i'll be quiet and listen..?

[14:42] <QtPlatypus> (Don't we have an Inline::Perl6 now as well?)

[14:42] <Khisanth> there is even Inline::Java

[14:42] <ods15> Khisanth: pay attention :P

[14:42] <nothingmuch> ods15: look, C is good for certain things: performance, memory restriction, etc

[14:42] <castaway> (restriction.... ;)

[14:42] <nothingmuch> perl is good when you want to worry less, and get more done in less time

[14:43] <ods15> nothingmuch: i mentioned that part of is fun

[14:43] <nothingmuch> if you can't afford to use perl for 2% of your project, since it's too (big|slow), then you can use Inline::C for just that bit

[14:43] <nothingmuch> ods15: fun is subjective

[14:43] <Khisanth> ods15: erm perhaps you are just bad at expressing yourself but after reading the scrollback you off being quite trollish...

[14:43] <ods15> for me that is

[14:43] <ods15> nothingmuch: that i admit would be really really good

[14:44] <nothingmuch> ods15: s/would/is/;

[14:44] <castaway> well do it then ,)

[14:44] <ods15> i'm being serious - mplayer written in perl, with serious bits being in C/asm would be very very good

[14:44] <castaway> so what are you waiting for? ;)

[14:44] <nothingmuch> ods15: look at the bunch of C extensions on CPAN

[14:44] <QtPlatypus> And if worse comes to worse.  Perl is great for prototyleing your algorthems in and then when you have got your algrythms down pat back porting into C.

[14:45] <nothingmuch> Digest::MD5 and Crypt::Blowfish will be too slow in perl

[14:45] <nothingmuch> but much more convenient in perl

[14:45] <castaway> baeh ;)

[14:45] <nothingmuch> so they are C/Perl - convenient and fast

[14:45] <nothingmuch> there are countless examples

[14:45] <ods15> anyway, regarding the fun thing, for me, comftable, is NOT fun.. if it's too easy, it's not fun. if i write in perl, i can get my goal done usually pretty damn fast, but if i write in c, i can spend some effort in it, and if bored, i can sit back and really thing about whats going on in my program behind the scenes.. i find this fun..

[14:46] <ods15> but again, subjective :)

[14:46] <nothingmuch> ods15: do you code for a living? or just as a hobby?

[14:46] <ods15> nothingmuch: i'm in army, i have no living

[14:46] <nothingmuch> ods15: that's the fine line then

[14:46] <Khisanth> ... bugs = fun eh? guess I am not the only one that enjoys debugging :)

[14:46] <nothingmuch> when you code for $$$ time is an important factor

[14:47] <castaway> most people think the coding should be fairly easy, and the fun/tough bit is figuring out the division into modules, subs, classes, and the algorithms etc

[14:47] <nothingmuch> and you want to get it out the door as fast as possible, in the best shape it could be

[14:47] <ods15> Khisanth: not bugs at all

[14:47] <ods15> effort is fun

[14:47] <castaway> he means do you get paid to code?

[14:47] <nothingmuch> and you want to make sure that when you have to fix it, it would be painful

[14:47] <nothingmuch> and time is always at war with the other priorities

[14:47] <ods15> nothingmuch: painless you mean?

[14:48] <nothingmuch> and the better the language, the less tradeoffs you have to make

[14:48] <nothingmuch> yes, painless

[14:48] <ods15> hehe

[14:48] <ods15> yeah you lost me there :P

[14:48] <ods15> funny thing, in army, i DID program in perl! hehe

[14:48] <nothingmuch> the army is not like the market

[14:48] <ods15> i've only made one program there and its all perl...

[14:49] <ods15> but i used perl cause it was more suited... it had to do with http and string manipulation... so, c, no good

[14:49] <nothingmuch> i'll reiterate - the value of the language is the quality of the output, measured by programmer burnout, performance, code size, maintainability, clarity, and so forth, divided by the time it takes to get the output

[14:50] <QtPlatypus> ods15: Do you think that the shift to Perl 6 will harm this ability?

[14:50] <nothingmuch> ods15: apache is written in C, and perl iis written in C

[14:50] <nothingmuch> those are perhaps the best tools out there to deal with http and strings

[14:50] <nothingmuch> please tell me why they aren't written in perl?

[14:50] <ods15> nothingmuch: to this day i dont understand the http spec.. :)

[14:51] <ods15> so i used ready made stuff

[14:51] <nothingmuch> ods15: that's why library authors grok spes for you

[14:51] <nothingmuch> see also LWP

[14:51] <ods15> and c is horrible for strings, i think we all agree

[14:51] <wolverian> perldoc LWP :)

[14:51] <ods15> wolverian: thats what i used there..

[14:51] <wolverian> that's good. 

[14:51] <nothingmuch> ods15: do you agree with my function to compute the value of a language?

[14:52] <wolverian> reinventing the wheel might be fun, but it's not productive.

[14:52] <ods15> nothingmuch: almost, yes

[14:52] <castaway> but, ods15, you were using stuff that you dont know how it works!

[14:52] <nothingmuch> and do you understand why in your circumstances time is not a factor, and do you see why this is perhaps the reason you value C more than high level things?

[14:52] <Khisanth> nothingmuch: the military(at least the US one) tends to waste a lot of money ...

[14:52] <nothingmuch> Khisanth: IDF does that too

[14:52] <nothingmuch> ods15: now, do you also see why Perl 6 helps increase that value?

[14:53] <nothingmuch> maintainability is high due to good solutions for normal problems

[14:53] <nothingmuch> programmer burnout is low, because lots of things are easy and quick

[14:53] <nothingmuch> code size is low, because the language is dense

[14:53] <ods15> nothingmuch: one thing i wish to add about your equation, it is correct when your goal is JUST, to get something DONE

[14:53] <Khisanth> either that or they are really using some of the money or some secret stuff but I am not paranoid enough for that :)

[14:53] <nothingmuch> ods15: no!!! THAT IS SOOO NOT MY POINT!!!

[14:53] <castaway> one generally needs to get it done, and working well without bugs

[14:53] <ods15> ?

[14:54] <nothingmuch> it applies when you need to have a sustained rate of productivity over time

[14:54] <nothingmuch> maintainability has nothing to do with "just getting it done"

[14:54] <nothingmuch> because it's a factor that is calculated in lieu of the understanding that it's never done

[14:54] <ods15> nothingmuch: i was reffering to the equation about the quality of a language

[14:54] <nothingmuch> yes

[14:55] <nothingmuch> that is the quality of the language

[14:55] <Khisanth> hrm .. nothingmuch, C IS high level :)

[14:55] <Khisanth> high level asm!

[14:55] <nothingmuch> productivity is the the cost of the programmer * the value of the language

[14:55] <castaway> not relative to Perl.. ,)

[14:56] <nothingmuch> and over time it's cheaper to use perl for most things like web applications, short lived data munging scripts, general do-hicky programs, support tools, rapidly changing code than it is to use C

[14:56] <ods15> that's true...

[14:56] <nothingmuch> however, it's cheaper to use C to develop a database application, because if you write it in perl it'll be too slow, and no one will buy it, hence it's very expensive (investment - income)

[14:56] <nothingmuch> that is my point

[14:56] <nothingmuch> and it was my point when I stated that perl 6 is a good language

[14:57] <nothingmuch> since perl 6 is better than perl 5 in almost all the measurable or seemingly measurable aspects of what is the value of a language

[14:57] <nothingmuch> and off the top of my head I can't think of why it's worse

[14:57] <nothingmuch> the only thing about it is that:

[14:57] <nothingmuch> a. it's not ready yet

[14:57] <nothingmuch> b. people seem to think it's ugly

[14:57] <nothingmuch> c. there's more to learn

[14:58] <nothingmuch> but to counter c, once you know 40% of perl 6, the curve flattens

[14:58] <castaway> I think c doesnt really count..

[14:58] <nothingmuch> in perl 5 this only happens around 80%

[14:58] <ods15> hmm

[14:58] <castaway> theres a lot to learn in perl5, but lots of people dont know/need to know all of it

[14:58] <QtPlatypus> b, is purely subjective.

[14:58] <nothingmuch> perl has many more special cases

[14:58] <nothingmuch> QtPlatypus: that's why it's also moot

[14:59] <ods15> heh

[14:59] <nothingmuch> ods15: are we at an understanding?

[14:59] <nothingmuch> because if so, i'd like to drop this

[14:59] <ods15> yes..

[14:59] <ods15> do you mind showing me some kind example perl6 code?

[15:00] <nothingmuch> with the conclusion that every language is good at whatever it is that it's good at

[15:00] <ods15> something complete, non trivial, but not too big

[15:00] <nothingmuch> http://svn.openfoundry.org/pugs/examples/

[15:00] <nothingmuch> http://svn.openfoundry.org/pugs/t/

[15:00] <nothingmuch> http://svn.openfoundry.org/pugs/ext

[15:01] <ods15> hmm

[15:02] <ods15> print "5x5 matrix in one line: " unless @*ARGS;

[15:02] <ods15> my $matrix = @*ARGS[0] || =<>;

[15:02] <nothingmuch> where is that from?

[15:02] <ods15> matrix.p6

[15:03] <nothingmuch> okay, what about it?

[15:03] <nothingmuch> do you know what that line does?

[15:03] <nothingmuch> it means that $matrix is the string value that is either the first argument if it's there, or a line of STDIN

[15:03] <nothingmuch> so little code, saying so much

[15:04] <nothingmuch> helping the program be more usable

[15:04] <ods15> but i couldnt understand it

[15:04] <nothingmuch> i could

[15:04] <ods15> whats the = before =<> for?

[15:04] <nothingmuch> that means lazy

[15:04] <ods15> (whats @* ?)

[15:04] <nothingmuch> @ is array

[15:04] <nothingmuch> * is global

[15:04] <nothingmuch> the global array named ARGS

[15:04] <ods15> ah

[15:04] <nothingmuch> indexed to offset 0

[15:05] <nothingmuch> || is short circuiting on value

[15:05] <nothingmuch> if @*ARGS[0] is undefined or false, then evaluate the right side

[15:06] <ods15> yeah i got that part.. heh

[15:07] <ods15> heh i didnt get why the print is only when there's args...

[15:07] <ods15> and i see an obvious change from perl5, no more $arr[0] ...

[15:07] <ods15> which i really did kinda hate about perl5

[15:08] <nothingmuch> ods15: the reasons for that are quite beautiful actually

[15:08] <nothingmuch> but the usage is bad

[15:08] <nothingmuch> that's why it's going away

[15:08] <ods15> $matrix .= chomp;

[15:08] <nothingmuch> see? isn't perl 6 better already?

[15:08] <nothingmuch> .= means mutating method call

[15:08] <ods15> this obviously behaves differently than perl5... could you explain?

[15:08] <nothingmuch> chomp is a method called on strings

[15:08] <nothingmuch> that removes end of line if there is one tacked on the end of the string

[15:08] <nothingmuch> $matrix = chomp($matrix);

[15:09] <nothingmuch> that's the equivelenet perl 5 snippet

[15:09] <ods15> heh, thats a pretty damn big change for '.='.. couldnt they pick a different operator?

[15:09] <nothingmuch> ods15: see? superficial differences again

[15:09] <nothingmuch> no, they couldn't, because the rest of the world uses '.' for method calls

[15:09] <nothingmuch> and everyone hated perl for using '->'

[15:09] <nothingmuch> so we switched to '.'

[15:09] <ods15> ok, but it's certainely confusing regarding perl5...

[15:09] <nothingmuch> it's nicer, shorter, and more readable

[15:09] <nothingmuch> ods15: it takes 3 minutes to learn

[15:09] <ods15> hmm

[15:10] <ods15> .= means..

[15:10] <nothingmuch> ~ is now the string concatenator

[15:10] <ods15> $bla = $bla.chomp

[15:10] <ods15> ?

[15:10] <nothingmuch> $obj .= method

[15:10] <nothingmuch> $obj = $obj.method

[15:10] <nothingmuch> yes

[15:10] <nothingmuch> but it's possibly more efficient

[15:10] <ods15> ah, ok, thats sense making

[15:10] <nothingmuch> for example @array.=sort could be in place, since it's not returning anything

[15:10] <ods15> neat

[15:11] <ods15> btw, regarding compiled binaries... libpugs.so ?..

[15:11] <nothingmuch> not yet

[15:11] <ods15> i mean, is that how it all works?

[15:11] <nothingmuch> let me find you a link

[15:11] <nothingmuch> http://pugscode.org/images/simple-compilation.png

[15:11] <autrijus> ods15: we can have libpugs.a

[15:11] <nothingmuch> hola autrijus 

[15:12] <autrijus> but GHC's .so support is not really there

[15:12] <autrijus> so until that improves, no .so for now

[15:12] <autrijus> yo nothingmuch

[15:12] <autrijus> ods15: but it doesn't matter that much; the reference runtime is just that, a reference

[15:12] <autrijus> ods15: the real action is likely to happen at the Perl5, Javascript and Parrot runtimes.

[15:12] <ods15> btw, if perl is supposed to be an "industrial" language, you really should've disallowed 'method params' altogether :/

[15:12] <autrijus> which all has their own .so

[15:12] <nothingmuch> method params?

[15:13] <autrijus> what are method params again?

[15:13] <ods15> not method(params)

[15:13] <ods15> space as a function call

[15:13] <autrijus> juxtaposition as function call?

[15:13] <nothingmuch> how do you say MMD?

[15:13] <ods15> mmd?

[15:13] <nothingmuch> why should it be $fh.close or close($fh) and not both

[15:13] <nothingmuch> multimethod dispatch

[15:13] <autrijus> nothingmuch: er, no, ods15 means

[15:13] <autrijus> close $fh;

[15:14] <autrijus> ods15: what should juxtaposition mean then?

[15:14] <ods15> ?

[15:14] <ods15> as far as i can tell i'm talking about a purely cosmetic thing

[15:14] <nothingmuch> ods15: perl 6 lets you optimize for readability

[15:14] <autrijus> ("juxtaposition" means you put a verb and an argument together separated by only space)

[15:14] <nothingmuch> if it makes more sense to you to close a file handle, you write 'close $fh'

[15:14] <nothingmuch> if you think 'filehandle, be closed', you say $fh.close

[15:15] <nothingmuch> it really depends on what color your train of thought is at the moment

[15:15] <ods15> nothingmuch: i was actually talking about, the ()

[15:15] <ods15> sort @arr       sort(@arr)

[15:15] <ods15> that cosmetic thing

[15:15] <nothingmuch> ah

[15:15] <nothingmuch> i forget the new rules in perl 6

[15:15] <autrijus> I don't know... OCaml, Fortran, Visual Basic etc

[15:15] <autrijus> even Haskell

[15:16] <theorbtwo> The question, I think, is why can you say $fh.print("Your mother"), but not $fh.print "Your mother"

[15:16] <ods15> but re-thinking, i guess i can see some actually nice "uses" for thiss

[15:16] <ods15> especially in heavily nested calls

[15:16] <theorbtwo> There is a reason, but I don't remember what it is.

[15:16] <autrijus> theorbtwo: $obj.print + 3;

[15:16] <nothingmuch> ods15: that really doesn't matter

[15:16] <nothingmuch> that's just syntax

[15:17] <nothingmuch> you can replace the grammer for perl 6 within a perl 6 program

[15:17] <autrijus> theorbtwo: method calls doesn't have the arity/listop kinding

[15:17] <autrijus> theorbtwo: so they need parens to parse

[15:17] <nothingmuch> ods15: not that I'd bother reading your code if you do

[15:17] <ods15> nothingmuch: well the whole idea was to sanitize the perl5 syntax

[15:18] <nothingmuch> ods15: but also to introduce new levels of flexibility

[15:18] <theorbtwo> Ah, right.

[15:18] <nothingmuch> you can ammend to the syntax

[15:18] * autrijus ponders doing a "The Least Insane" web comic strip

[15:18] <nothingmuch> you can create macros

[15:18] <nothingmuch> if they help, then they help

[15:18] <nothingmuch> and that's good

[15:18] * nothingmuch quotes spiderman: "With great power comes great responsibility"

[15:18] <nothingmuch> since I like to think that I'm not an irresponsible idiot, i tend to prefer power

[15:18] <ods15> nothingmuch: that was spiderman's uncle!

[15:19] <nothingmuch> yeah, that was ambiguous

[15:19] <autrijus> with great power comes electric shock

[15:19] <Khisanth> autrijus: where will you find time to do a comic strip? :p

[15:19] <ods15> hehe

[15:19] <nothingmuch> i meant i was quoting spiderman the comic, not the character

[15:19] <ods15> ah

[15:19] <autrijus> Khisanth: I don't

[15:19] <Khisanth> :)

[15:19] <ods15> btw is there ANY kind of ambiguity in perl6/undefined behavior?

[15:19] <theorbtwo> (Uncle Owen)++

[15:19] <castaway> autrijus++

[15:20] <nothingmuch> ods15: far less than perl 5

[15:20] <autrijus> I'm still working on this $job thing and trying to get Catalyst+SQLite3 happy with each other

[15:20] <Khisanth> ods15: of course :)

[15:20] <theorbtwo> ods: There's plenty, but when we find it we try to define it.

[15:20] <nothingmuch> autrijus: what do you need? i do it all the time

[15:20] <ods15> nothingmuch: heh i wasn't aware perl5 had any

[15:20] <Khisanth> since it's not fully specced yet :p

[15:20] <castaway> darn jobs..

[15:20] <ods15> Khisanth: heh. i consider it C's greatest weakness

[15:20] <autrijus> nothingmuch: which scaffolding do you use nowadays?

[15:20] <nothingmuch> autrijus: i also had crap with it

[15:20] <Khisanth> perl5 has at least a couple as well

[15:20] <autrijus> nothingmuch: the main problem is the schema changes every day

[15:20] <nothingmuch> autrijus: i started with the helper, and then grew my own

[15:20] <nothingmuch> autrijus: /msg ?

[15:20] <ods15> if (0) if (1) a = 1; else a = 2;

[15:20] <autrijus> nothingmuch: #catalyst

[15:20] <castaway> thats hardly the softwares fault, autrijus ;)

[15:21] <theorbtwo> ods: That's not legal in perl (5 or 6), so it's not ambigious.

[15:21] <ods15> but atleast it gives a compiler warning :P

[15:21] <autrijus> castaway: no, but it contributes to my lack of time on pugs :)

[15:21] <nothingmuch> ods15: compiler error

[15:21] <ods15> theorbtwo: i said, i consider it C's ngreatest weakness

[15:21] <castaway> I can imagine ;(

[15:21] <ods15> C's!

[15:21] <theorbtwo> Oh, right.

[15:21] <castaway> (changing specs)--

[15:21] <theorbtwo> Sorry.

[15:21] <ods15> hehe

[15:22] <nothingmuch> afk &

[15:22] <ods15> oh, nothingmuch, i just remembered what was the other thing i "hated" about perl6... no official implementation :(

[15:22] <Khisanth> I consider C's greatest weakness to be the number of yaks you end up shaving in the course of writing a program :)

[15:22] <nothingmuch> (not really, just other channel)

[15:22] <ods15> bye

[15:22] <nothingmuch> ods15: we're working on it

[15:22] <nothingmuch> what i mean is: mention my name to get my attention

[15:22] <ods15> nothingmuch: umm, you're working on the opposite?

[15:22] <castaway> ods15: thats just a matter of time, in theory

[15:23] <ods15> castaway: i find portability problems only get worse with time, not better :(

[15:23] <ods15> the second you have 2 implementations, you might as well have a million

[15:23] <castaway> eh?

[15:23] <castaway> one will be plenty

[15:23] <ods15> castaway: there was never a perl standard, and it was the most consistent language on earth

[15:23] <nothingmuch> ods15: we're working on an implementation

[15:24] <ods15> because it had only one implementation

[15:24] <nothingmuch> that will bootstrap *the* implementation

[15:24] <nothingmuch> in the future there will be one perl 6

[15:24] <ods15> nothingmuch: no, thats not what i mean..

[15:24] <nothingmuch> compiling to NPIL

[15:24] <ods15> heh

[15:24] <nothingmuch> PIL will the run on different runtimes

[15:24] <castaway> theres a P6 standard?

[15:24] <Khisanth> there are also good reasons for multiple implementations ...

[15:24] <nothingmuch> i doubt there will be several perl 6's because it's designed to fulfill the deployment needs project forks usually get around to

[15:24] <ods15> Khisanth: they are rare

[15:24] <Khisanth> though it would probably fail for the same reason Communism fails :)

[15:25] <Khisanth> good but only if you take away human behavior/emotions/desires :)

[15:29] <ods15> oh, i still didnt understand, whats =<> ?

[15:33] <Khisanth> you know what <> does in perl5?

[15:35] <Khisanth> ods15: http://svn.openfoundry.org/pugs/docs/quickref/

[15:35] <Khisanth> that should be useful for getting started

[15:58] *** Maddingue__ is now known as Maddingue

[16:26] <putter> nothingmuch: ping?

[16:43] <xinming> hmm, by the way, Is there any problem with irc.freenode.net?

[16:43] <xinming> why will I have to connect over times to get in here?

[16:44] <QtPlatypus> You keep getting an "SendQ exceeded" error.

[16:48] <xinming> ???

[16:48] <QtPlatypus> Thats what it says in your quit

[16:48] <Khisanth> * xinming has quit (SendQ exceeded)

[16:49] <Khisanth> which client are you using?

[16:49] <xinming> xchat

[16:49] <Khisanth> in any large channels?

[16:49] <xinming> I might considering erc instead. :-)

[16:50] <Khisanth> anyway /set away_track off

[16:50] <xinming> Do you mean I opened too many channel a time?

[16:51] <Khisanth> no

[16:51] <nothingmuch> putpong

[16:51] <nothingmuch> ugh

[16:51] <nothingmuch> putter: pong

[16:52] <nothingmuch> ods15: how's your perl 6 learning coming along?

[16:53] <Khisanth> xinming: but the away tracking can cause the problem with SendQ

[16:54] <ods15> umm, i just read one script :P

[16:54] <ods15> i moved on to the next bored thing

[16:55] <ods15> i'm not interested in becoming perl6 programmer, atleast not in forseeable future, you can count on it :)

[16:56] <xinming> Khisanth: hmm, do you mean I need to check the "enable away tracking" or not ?

[16:56] <xinming> Khisanth: default It is unchecked.

[16:57] <Khisanth> then there shouldn't be anything else that would cause that by default

[16:57] <Khisanth> if you have any scripts loaded then it's anybody's guess what is causing it

[16:58] <xinming> ods15: hmm, Larry says, you will use perl 6 as perl 5. :-)

[16:59] <ods15> heh in the forseeable future, there is no perl6...

[16:59] <xinming> Khisanth: hmm, I really don't know, This happened today. really trouble some, And I can open google here today.

[17:00] <xinming> can't open google

[17:01] <autrijus> xinming: might be that great firewall of yours :-/

[17:04] <xinming> ods15: don't you believe that after pugs covers most of the perl 6 "specification", Perl 6 will be out in at most a year.

[17:05] <ods15> no i don't

[17:05] <ods15> it'll be used by few

[17:05] <ods15> cause of the name

[17:05] <xinming> autrijus: hmm, Don't know, M$ Home seems not to be able to reach either.

[17:06] <ods15> it's like the corel draw fokes working on a linux version, and then m$ bought corel draw (or something like that?) and kicked the linux team off, and now they are still working on it, but nobody knows who they are cause they dont carry the name

[17:06] <xinming> ods15: you mean some people don't like pugs, because pugs isn't developed by Larry ? T_T

[17:07] <ods15> xinming: i thought pugs was the perl6 bug tracking system :/

[17:08] <xinming> ods15: hmm, well, You might suggest autrijus to rename pugs to perl pugs. :-)

[17:08] <nothingmuch> wrestling is soo stupid, even when it'

[17:08] <ods15> who

[17:08] <nothingmuch> s stupid by definition

[17:08] <ods15> nothingmuch: that reminds me linus's quote about sco :P

[17:09] <ods15> "There are literally several levels of SCO being wrong. And even if we were to live in that alternate universe where SCO would be right, they'd still be wrong."

[17:09] <theorbtwo> nothingmuch, I know a /very/ intelegent wrestling coatch.

[17:09] <autrijus> ods15: anointment comes if and when it's time. before that, it might be a good thing if people doesn't mistake pugs as the production version of perl6.

[17:09] <nothingmuch> theorbtwo: not real wrestling, sorry

[17:09] <nothingmuch> tv wrestling, as enterntainment, not as a sport

[17:10] <theorbtwo> Right.

[17:10] <autrijus> lest they have unrealistic expectations.

[17:10] <theorbtwo> That WWE junk.

[17:10] <nothingmuch> yup

[17:10] <nothingmuch> there's this one show, which I'm waiting to be over at the moment

[17:10] <nothingmuch> every time they fall I have to wait for the announcers to tell me who i shurt

[17:10] <nothingmuch> because it looks so symmetrical

[17:11] <ods15> hey, maybe all you can help... what would be a good name for a library that does all sorts of audio/video.. umm, that's the word i'm looking for...

[17:11] <ods15> it does scaling, cropping, etc. etc.

[17:12] <autrijus> videomagick ;)

[17:12] <nothingmuch> ods15: are you wrapping the mplayer filters in a lib?

[17:12] <ods15> has to start with 'libav'.. we thought of libavfilter, but 'lavf' is already taken by libavformat

[17:12] <autrijus> libavmagick

[17:12] <ods15> nothingmuch: we're thinking of making a new one from scratch cause mplayer's filter layer sucks so much

[17:13] <xinming> It seems that the Great Firewall is doing something really stupid... or the main routers are down currently.

[17:13] <ods15> lead developer likes 'libavmunge' :P

[17:13] <autrijus> libavmunge

[17:13] <autrijus> ooh.

[17:13] <ods15> ....

[17:13] <autrijus> sick minds, etc.

[17:13] <ods15> lol

[17:14] <ods15> how the hell did you come up with that word :P

[17:14] <xinming> http://caibird.3322.org/Screenshot.png

[17:14] <nothingmuch> what word?

[17:14] <ods15> munge

[17:14] <ods15> btw how's perl6's gui

[17:14] <xinming> autrijus: open that pic. and see the time on the left column...

[17:14] <ods15> (if at all?)

[17:14] <nothingmuch> ods15: which GUI?

[17:15] <autrijus> ods15: parrot has sdl and javascript has dhtml

[17:15] <ods15> nothingmuch: can i make a gui with it

[17:15] <autrijus> so we're doing fine, thank you :)

[17:15] <nothingmuch> in theory wxhaskell might be gluable

[17:15] <xinming> really a pain to wait for your talks.

[17:15] <autrijus> bbiab.

[17:15] <nothingmuch> perl 5 has tcl/tk, gtk, qt, wx, win32::gui, cocoa, x11 libs

[17:15] <nothingmuch> uh, can't remember what else

[17:15] <ods15> and they all suck :P

[17:16] <ods15> actually, not sure if they suck

[17:16] <nothingmuch> yes, cocoa stinks

[17:16] <nothingmuch> qt is worthless

[17:16] <nothingmuch> gtk2 is shyte

[17:16] <wolverian> gtk2 is lovely.

[17:16] <wolverian> (although the documentation sucks.)

[17:16] <wolverian> (I mean the perl bindings.)

[17:16] <ods15> hehe

[17:16] <nothingmuch> wolverian: shutup, we're listening to ods15 

[17:16] <wolverian> oh, sorry. ;)

[17:16] <ods15> i use Qt btw

[17:16] <ods15> (and KDE..)

[17:16] <wolverian> ods15, since you can directly use perl5 modules from perl6, your question is pretty much answered.

[17:17] <ods15> wolverian: i was wondering if there's anything builtin

[17:17] <nothingmuch> ods15: there's nothing builtin for perl 5 either

[17:17] <nothingmuch> why should there be anything builtin?

[17:17] <wolverian> ods15, no. perl is a language, not a gui toolkit.

[17:18] <wolverian> (although it can work as one when you install the appropriate modules. that's the brilliance of CPAN!)

[17:18] <xinming> autrijus: I might be wrong, I haven't noticed the time is "hours:minute" :-)

[17:20] <xinming> ok, anyone here can answer my question I asked this afternooon?

[17:21] <xinming> Is the keyword multi used for append the sub routine to the spcified "class" dynamicly?

[17:22] <arcady> xinming probably not

[17:22] <xinming> I read the example in examples/vmmethods/, I can understand the example, But I don't know the "internal" for correctly.

[17:22] <arcady> since with multi there is not necessarily a "the class"

[17:22] <arcady> there might be multiple classes

[17:24] <xinming> arcady: So, with multi, you can make the subroutine as "method" to any class, right?

[17:25] <arcady> yes, you can

[17:25] <Khisanth> wolverian: the C documentation for gtk2 isn't much better

[17:25] <arcady> but you can also make a method of two classes at the same time

[17:25] <arcady> like multi infix:<+>

[17:26] <xinming> just like, `class C { }; multi sub haha{ "haha".say }; "a".haha; 3.haha; C.new.haha;`

[17:26] <xinming> amazing feature.

[17:26] <arcady> no, not like that

[17:27] <arcady> multi haha(C $foo)

[17:27] <wolverian> Khisanth, right. wx has pretty nice docs, I think.

[17:27] <Khisanth> wolverian: not by much ...

[17:27] <Khisanth> well it has More :)

[17:28] <wolverian> xinming, multi just means that there can be multiple versions of that method or sub, and the dispatcher chooses the right one at runtime based on the parameter types

[17:30] <xinming> wolverian: so, you can declare the multi sub without parameter?

[17:31] <wolverian> xinming, you mean: 'multi foo () { ... }'? yes. then it will only be called when you do foo(), without arguments.

[17:31] <xinming> s/can/can't/

[17:32] <wolverian> xinming, yes, you can. as above. :)

[17:34] <xinming> wolverian: Ok, So, multi can do something "cross" the class. just like multi sub ( MyClass $self: ) { };, This function will dynamic append to MyClass as a method.

[17:34] <xinming> wolverian: This is my understanding of keyword of multi after reading the examples. :-)

[17:34] <xinming> wolverian: But now, It's more clearly to me.

[17:35] <xinming> wolverian: thanks. ;-)

[17:35] <wolverian> xinming, right.

[17:35] <wolverian> I don't think 'multi' has anything to do with the 'add as method' bit. that's the ':' in the signature.

[17:36] <xinming> wolverian xinming, multi just means that there can be multiple versions of that method or sub, and the dispatcher chooses the right one at runtime based on the parameter types

[17:37] <xinming> wolverian: This one gives me the answer. :-)

[17:37] <wolverian> good. :)

[17:38] <wolverian> some people think that this behaviour should be the default.

[17:38] <xinming> Lvalue subroutines, what does lvalue mean here? "long"?

[17:39] <nothingmuch> xinming: left

[17:39] <nothingmuch> from this: (left = right)

[17:39] <nothingmuch> an lvalue is something you can assign to

[17:40] <nothingmuch> and an rvalue is something you can put in an assignable lvalue

[17:40] <xinming> wolverian: I think multi is just used for some people who is work "harder" whom will handle all the function himself. and signature or the compiler.

[17:41] <wolverian> xinming, I didn't quite get what you mean there.

[17:44] <xinming> wolverian: hmm, Just like, in C++, there is "multi sub"-like feature, which is much like float add( float, float); and int add( int, int); In Synopsis, Larry wrote that perl 6 program can be compiled into byte codes. So, the "signature" is need for optimize.

[17:46] <Khisanth> overloaded method names ...

[17:46] <xinming> Khisanth: ...

[17:46] <xinming> Sorry for my poor English... :-)

[17:51] <wolverian> xinming, right, but it's useful for more things besides that.

[17:55] <xinming> wolverian: In perl 6, it is.

[17:58] <xinming> ?eval my $lval; sub get { return $lval }; sub set ( $v ) { $lval = $v }; set 100; my $t = get; $t.say;

[17:58] <evalbotzy> 100 bool::true 

[17:58] <xinming> hmm, what's the differences between with is rw, and without 'is rw' ?

[18:00] <xinming> ?eval my $lval; sub get() is rw { return $lval }; sub set ( $v ) is rw { $lval = $v }; set 100; my $t = get; $t.say;

[18:00] <evalbotzy> 100 bool::true 

[18:03] <Khisanth> a rw sub?

[18:07] <xinming> Khisanth: yeap, don't know their differences, rw is specified that this is a lvalue sub, But In fact, without rw, It is also a lvalue sub.

[18:09] <Khisanth> eval my $lval; sub get() is rw { return $lval }; sub set ( $v ) { $lval = $v }; set 100; set() = 100;

[18:09] <Khisanth> oops

[18:09] <Khisanth> ?eval my $lval; sub get() is rw { return $lval }; sub set ( $v ) { $lval = $v }; set 100; set() = 100;

[18:09] <evalbotzy> Error: No compatible subroutine found: "&set" 

[18:09] <Khisanth> ?eval my $lval; sub get() is rw { return $lval }; sub set ( $v ) is rw { $lval = $v }; set 100; set() = 100;

[18:09] <evalbotzy> Error: No compatible subroutine found: "&set" 

[18:09] <Khisanth> grr

[18:09] <Khisanth> ?eval my $lval; sub get() is rw { return $lval }; sub set ( $v ) is rw { $lval = $v }; set() = 100;

[18:09] <evalbotzy> Error: No compatible subroutine found: "&set" 

[18:15] <xinming> ?eval my $lval; sub get() is rw { return $lval }; sub set () is rw { $lval }; set = 300; my $t = get; $t.say;

[18:15] <evalbotzy> 300 bool::true 

[18:15] <xinming> Khisanth: :-)

[18:23] <xinming> ?eval my $var = "key_value"; (key => $var) = "value"

[18:23] <evalbotzy> ('key' => \'value') 

[18:24] <xinming> ?eval my $var = "key_value"; (a => $var, b => $var ) = "value"

[18:24] <evalbotzy> (('a' => \'value'), ('b' => \'value')) 

[18:30] <xinming> ?eval my $var = "key_value"; ( => $var, => $var ) = "value"

[18:30] <evalbotzy> Error:  unexpected ">" expecting term 

[18:32] <xinming> ?eval my $var = "key_value"; ( => $var ) = "value"

[18:32] <evalbotzy> Error:  unexpected ">" expecting term 

[18:42] <xinming> ?eval my @ary = ( 1, 2, 3 ); my $b ::= @ary[1]; $b = 100; "{@ary}".say;

[18:43] <evalbotzy> 1 2 3 bool::true 

[18:48] <xinming> hmm, anyone here would explain this for me?

[18:54] <autrijus>  my @ary = ( 1, 2, 3 ); my $b := @ary[1]; $b = 100; @ary

[18:54] <autrijus> ?eval my @ary = ( 1, 2, 3 ); my $b := @ary[1]; $b = 100; @ary

[18:54] <evalbotzy> [1, 100, 3] 

[18:54] <autrijus> xinming: the ::= happens at compile time

[18:55] <autrijus> xinming: then the assignment overwrite whatever that was in @ary

[18:55] <autrijus> so the previous @ary[1] was gone

[18:55] <autrijus> that's all

[18:56] <xinming> autrijus: that's why I feel confusing to me.

[18:57] <xinming> $b here in fact, It get the "location" of the @ary[1], 

[18:57] <autrijus> yes.

[18:57] <xinming> hmm, not in fact, in my opinion. :-)

[18:57] <autrijus> but that location is no longer associated with @ary after the assignment

[18:57] <fglock_> hi

[18:57] <autrijus> when you assign into @ary, you discard all cells associated with it

[18:57] <autrijus> hi fglock_

[18:58] <autrijus> xinming: then you replace it with a new set of scalar container: (1,2,3)

[18:58] <xinming> autrijus: Oh, Ok, thanks. hmm, It seems that compile time binding is useless. :-S

[18:58] <autrijus> not really.

[18:58] <autrijus> watch:

[18:58] <fglock_> a friend of mine is going to china in ten days - how is the weather (Shanghai)

[18:58] <xinming> except for some "constant" values.

[18:58] <autrijus> ?eval my @ary; @ary[1] = 10; my $b ::= @ary[1]; $b = 100; @ary

[18:58] <evalbotzy> [undef, 100] 

[19:00] <xinming> fglock_: Sorry, I am living in a place a bit far from ShangHai. :-S

[19:00] <autrijus> same here

[19:00] <autrijus> you'd be better checking the various weather service sites

[19:00] <autrijus> sorry :-/

[19:01] <xinming> fglock_: I will check it for you. for me I might be better to understand Chinese than you do.

[19:02] <xinming> 8 21  	8 22  	8 23

[19:02] <jabbot> xinming: 8 21  	8 22  	8 23

[19:03] <xinming> 22C  	24C  	23C

[19:03] <xinming> This is the lowest temperature.

[19:03] <xinming> 28C  	28C  	28C

[19:03] <xinming> highest

[19:03] <fglock_> xinming - thanks

[19:03] * nothingmuch wants to see china... It looks so pretty in pictures. Mongolia too

[19:04] <nothingmuch> i had a friend whose brother went there, and ever since I saw his photographs I've had it in the back of my mind

[19:05] <xinming> http://weather.yahoo.com/forecast/chxx0116.html

[19:05] <xinming> fglock_: http://weather.yahoo.com/forecast/chxx0116.html

[19:06] <xinming> fglock_: The weather report I ever pasted is from a Chinese "site" serves doing the weather report.

[19:07] <xinming> fglock_: I don't know which is more correct. ;-)

[19:07] <wolverian> heh, why is feather's MOTD in hebrew or something like that? :)

[19:07] <xinming> autrijus: could you please give me an example for using compile time binding? It seems that compile time binding is useless except doing a constant variable binding.

[19:08] <integral> wolverian: it's upside down :)

[19:08] <nothingmuch> wolverian: that's not unicode

[19:08] <nothingmuch> or hebrew

[19:08] <wolverian> oh, haha.

[19:08] <wolverian> where does it come from?

[19:12] <autrijus> xinming: sure.

[19:12] <autrijus> xinming: this:

[19:12] <autrijus> sub f ($x) { $x + 1 }

[19:12] <autrijus> is a compile time binding :)

[19:12] <autrijus> our &f ::= sub ($x) { $x + 1 }

[19:12] <autrijus> is what it is

[19:13] <autrijus> to the compiler

[19:13] <wolverian> oh, ::= is not aliasing at all?

[19:13] <autrijus> wolverian: it's compile time :=

[19:13] <autrijus> it's roughly equivalent to BEGIN { := }

[19:14] <wolverian> right - but I don't understand why the $b ::= @a[1]; $b = 100; doesn't carry over to @a when with := it does

[19:14] <autrijus> wolverian: BEGIN happens before the my() assignment.

[19:14] <autrijus> my @a = (1,2,3);  -- desugared to

[19:14] <wolverian> ohh.

[19:14] <autrijus> my @a; @a = (1,2,3);

[19:14] <autrijus> wolverian: you can witness the same situation with perl5.

[19:14] <autrijus> try it sometimes :)

[19:15] <wolverian> right, but perl5 doesn't have ::= :)

[19:15] <autrijus> it does have use :)

[19:15] <autrijus> my $a = 1; use constant A => $a;

[19:15] <autrijus> this, for example, won't work.

[19:15] <fglock_> if I have a multisub with Int argument, can I call 10.mysub() ?

[19:15] <autrijus> fglock_: yes, that's what multisub is.

[19:15] <wolverian> autrijus, good point.

[19:16] <wolverian> autrijus, does that have to be a multi?

[19:16] <autrijus> wolverian: no, any sub would do, last I heard.

[19:16] <wolverian> ?eval sub square (Int $x:) { $x**2 } $x.square

[19:16] <evalbotzy> Error: Undeclared variable: "$x" 

[19:16] <wolverian> er, duh.

[19:16] <wolverian> ?eval sub square (Int $x:) { $x**2 } 3.square

[19:16] <evalbotzy> 9 

[19:17] <wolverian> right. then I understand 'multi' correctly and didn't lie to xinming. hooray.

[19:18] <xinming> autrijus: then... ::= this is the beauty for the compiler. :-)

[19:18] <xinming> wolverian: :-)

[19:19] <autrijus> xinming: think about it this way; using ::= the code will only be run once

[19:19] <autrijus> during compilation

[19:19] <xinming> Now, I think I understand what pugs really do in rough... :-)

[19:19] <autrijus> using := means the code will need to be run every time on the vm

[19:19] <autrijus> sometimes there's a large difference.

[19:19] <autrijus> esp. when you are in a inner loop

[19:23] <xinming> ?eval sub x2 ( Str $x: ) { $x**2 }; sub x2 ( Int $x: ) { $x**2 }; "3".x2; 3.x2;

[19:23] <evalbotzy> 9 

[19:23] <xinming> ?eval sub x2 ( Str $x: ) { $x**2 }; sub x2 ( Int $x: ) { $x**2 }; "3".x2;

[19:23] <evalbotzy> 9 

[19:23] <xinming> ?eval sub x2 ( Str $x: ) { $x**2 }; sub x2 ( Int $x: ) { $x**2 }; 3.x2;

[19:23] <evalbotzy> 9 

[19:24] <xinming> hmm... I still wonder... What will multi do... :-S

[19:24] <autrijus> easy

[19:24] <ods15> whats that ':'

[19:24] <xinming> this example, multi isn't needed...

[19:24] <Khisanth> ?eval sub x2 ( Str $x: ) { $x**2 }; sub x2 ( Int $x: ) { $x**2 }; "foo".x2;

[19:24] <evalbotzy> 0 

[19:24] <xinming> ods15: just like, in perl 5, you have to write. sub { my $obj = shift; ... };

[19:25] <ods15> ?

[19:25] <xinming> ods15: in perl 6, you just need to write sub ( $obj: ) { ... }

[19:25] <Khisanth> of course raising a string to a power doesn't make sense

[19:25] <ods15> whats tha got to do with the ':' then

[19:25] <ods15> ah

[19:25] <ods15> ?eval sub square (Int $x:) { $x**2 } "3".square

[19:25] <evalbotzy> 9 

[19:25] <ods15> ?eval sub square (Int $x:) { $x**2 } "3".square()

[19:25] <autrijus> actually you can drop the : here, as that's implicit

[19:25] <evalbotzy> 9 

[19:26] <ods15> autrijus: only needed if you have multiple params?

[19:26] <autrijus> ?eval sub x2 (Int $x) { 'int called' }; sub x2 (Str $x) { 'str called' }; 3.x2

[19:26] <evalbotzy> 'int called' 

[19:26] <autrijus> ?eval sub x2 (Str $x) { 'str called' }; sub x2 (Int $x) { 'int called' }; 3.x2

[19:26] <evalbotzy> 'int called' 

[19:26] <xinming> ?eval sub x2 (Int $x) { 'int called' }; sub x2 (Str $x) { 'str called' }; "3".x2

[19:26] <evalbotzy> 'str called' 

[19:26] <ods15> ?eval sub x2 (Str $x) { 'str called' }; sub x2 (Int $x) { 'int called' }; "3".x2

[19:26] <evalbotzy> 'str called' 

[19:26] <ods15> bleh beat me to it

[19:26] <autrijus> mm, pugs is being too smart.

[19:27] <ods15> best match?

[19:27] <ods15> kinda like overloading..

[19:27] <autrijus> yeah. that shouldn't happen.

[19:27] <autrijus> it's a bug ;)

[19:27] <ods15> damn

[19:27] <autrijus> if you had written

[19:27] <autrijus> multi x2 ...

[19:27] <autrijus> instead of

[19:27] <autrijus> sub x2 ...

[19:27] <coral> ?eval sub x2 (Int $x) { 'int called' }; sub x2 (Str $x) { 'str called' }; "3".x2

[19:27] <evalbotzy> 'str called' 

[19:27] <autrijus> then that behaviour is exactly what should happen

[19:27] <nothingmuch> *cough*

[19:27] <autrijus> but not 'sub' -- sub is supposed to be single.

[19:28] <autrijus> nothingmuch: ;)

[19:28] <xinming> autrijus: so, what does multi really do, It seems that "sub" handles all...

[19:28] <xinming> autrijus: ... :-)

[19:28] <ods15> ambiguous

[19:28] <autrijus> xinming: the fact that 'sub' handles all is a pugs bug ;)

[19:28] <nothingmuch> ods15: did you find the 'sub'/'multi sub' distinction confusing?

[19:28] <autrijus> and a new one at that.

[19:28] <ods15> nothingmuch: dunno, i haven't even seen it yet

[19:28] <coral> ?eval multi x2 (Int $x) { ... }, (Str $x) { ... };

[19:28] <evalbotzy> Error:  unexpected "," expecting ";", statements or end of input 

[19:28] <coral> just curious

[19:29] <ods15> ok night

[19:29] <xinming> ods15: learning perl 6 is a kind of fun... ;-)

[19:29] <xinming> ods15: night.

[19:29] <xinming> autrijus: hmm, I will write these test in the "near" future. at least, I have to understand perl 6 "well". :-)

[19:29] <coral> if i follow what just went by multi allows what sub is demonstrating that it supports right now -- argument-based multple path support

[19:29] <nothingmuch> coral: multi xs ((Int (+) Str) $x) { }

[19:30] <coral> that combines the two into a single { }?

[19:30] <coral> multi seems like a switch statement only with sub instead of case

[19:31] <coral> neat to see that it works!  pugs++

[19:31] <nothingmuch> coral: no, that's just saying the type that is Int and Str

[19:31] <fglock_> autrijus: what kind of object a "Type" is? is it a function that takes an object and returns true or false?

[19:31] <xinming> coral: in my humble opinion, I agree with you...

[19:31] <nothingmuch> coral: i hope not

[19:32] <nothingmuch> MMD dispatch order is, IMHO, orthogonal to definition order

[19:32] <nothingmuch> that way you have an aspect of usefulness - you can amend to other people's code

[19:32] <nothingmuch> you just define the special cases very carefulyy

[19:32] <coral> i hadn't considered the ordering implied by switch

[19:32] <nothingmuch> and you can work around, optimize, extend, fix and otherwise resolve bad code

[19:32] <nothingmuch> but the way it looks i am going to be wrong

[19:32] <coral> just noting that it's a very clean syntax for defining lots of "this argument" means "this code block"

[19:32] <nothingmuch> and i'm sad

[19:32] <nothingmuch> boohoo

[19:33] <coral> the order is decided by the arguments, afaict

[19:33] <autrijus> fglock_: it provides that method.

[19:33] <nothingmuch> coral: you know haskell, right?

[19:33] <coral> nope. i'll stop then.

[19:33] <wolverian> hmm, can we make multi a listop like ods15 showed? :)

[19:33] <nothingmuch> coral: you should

[19:33] <ods15> ?

[19:33] <ods15> leave alone, lemme go sleep

[19:33] * ods15 crashes into keyboard

[19:33] <ods15> dkj fzg

[19:33] <xinming> hmm, after autrijus said the "smart bug" of pugs. I wonder, how will larry think of this...

[19:34] <xinming> I mean, If multi is really needed...

[19:34] <nothingmuch> ods15: it's called /quit, and people type it when they really mean "i went to bed"

[19:34] <nothingmuch> if they don't, then they're lying

[19:34] <nothingmuch> and it's OK to keep them around

[19:34] <wolverian> (or /away)

[19:34] <nothingmuch> uh, oops

[19:35] <nothingmuch>  /away is when you're faking it, and you really stick around a few minutes longer, closing windows

[19:35] <wolverian> I don't close my IRC client.

[19:36] <wolverian> even when I sleep.

[19:36] <xinming> nothingmuch: well, some people don't want his(her) computer go sleep... so will keep all night long. :-)

[19:36] <nothingmuch> wolverian: that means you're always there

[19:36] <nothingmuch> unless you coincidentially went a away

[19:36] <nothingmuch> but we can never trust you fully

[19:36] <nothingmuch> it's like autrijus

[19:36] <autrijus> xinming: ok, I fixed the multi/sub bug

[19:37] <wolverian> hehe. :)

[19:37] <autrijus> tests very much welcome :)

[19:37] <nothingmuch> 03:05 - <autrijus> Journal up, bed &

[19:37] <nothingmuch> 05:42 - <autrijus> r8715

[19:37] <autrijus> xinming: certain people want all 'sub' to be 'multi'

[19:37] <autrijus> xinming: a prominient certain people made that case very well, but currently @Larry and me are still not convinced 

[19:37] <nothingmuch> 05:42 - <autrijus> PIL compiles to JVM now

[19:38] <autrijus> (that certain people is nothingmuch here)

[19:38] <wolverian> autrijus, why are you not convinced?

[19:38] <wolverian> (I haven't read contrary opinions, or don't remember them. a URL is fine too)

[19:38] <wolverian> (or title to a p6l thread :)

[19:39] <nothingmuch> wolverian: every time i brought it up it was eitehr warnocked or taken in another direction

[19:39] <nothingmuch> but "MML Dispatch" [sic] (yes, with the typo)

[19:39] <nothingmuch> that'

[19:39] <nothingmuch> s a good read

[19:39] <wolverian> right. thanks.

[19:39] <nothingmuch> and docs/notes/blh has some stuff

[19:39] <xinming> autrijus: hmm, I also wonders why, :-)

[19:39] <autrijus> wolverian: oh, mostly because I rarely redefine subs purposefully, but mostly accidentally

[19:39] <wolverian> autrijus, ah, okay.

[19:39] <autrijus> and I'd like compiler to catch that by default.

[19:39] <nothingmuch> and modules/Class-Events has code which I think should be the way MMD should look like

[19:40] <wolverian> does 'multi' in a class mean 'multi method' or 'multi sub'?

[19:40] <wolverian> (is there a difference?

[19:40] <wolverian> )

[19:40] <autrijus> there is a difference, multisub doesn't get inherited

[19:40] <autrijus> and I think the answer is multisub currently

[19:40] <autrijus> it makes sense

[19:40] <autrijus> since multi are designed to exist transparent to class boundaries

[19:40] <autrijus> so copy/pasting them around should ignore the class context around them

[19:41] <wolverian> good point.

[19:41] <nothingmuch> or alternatively - since all methods are just multisubs too, whose implicit first MMD argument is an object whose type is the current class... yadda yadda yadda

[19:42] * nothingmuch tries to enumerate all the kinds of subs in his head

[19:42] <nothingmuch> and the ways they are dispatched

[19:42] * nothingmuch feels slightly nautious

[19:42] <nothingmuch> naucious ?

[19:42] <autrijus> nauseous

[19:42] * autrijus applies an unicorn horn on nothingmuch

[19:43] <nothingmuch> what does a unicorn horn do?

[19:43] <nothingmuch> and isn't application of sharp things to heads a fatal error?

[19:43] <wolverian> nauseated.

[19:44] <nothingmuch> neo-seating

[19:44] <autrijus> nothingmuch: it's from the game that you dare not start playing :)

[19:44] <wolverian> (nauseous would mean you make others around you ill.)

[19:44] <nothingmuch> http://www.cenqua.com/pairon/

[19:44] <nothingmuch> ah

[19:44] <fglock_> is there a public interface to Types - like 1.isa('Int') but for types? $list.isa('Lazy') ?

[19:45] <nothingmuch> fglock_: every class is a type

[19:45] <nothingmuch> so, uh, yes

[19:45] <wolverian> fglock_, and you don't need to quote defined types

[19:45] <autrijus> fglock_: also the string form is not specced to be supported

[19:45] <autrijus> 1.isa(Int) is the only specced form

[19:45] * nothingmuch is afraid of being shot by TSa

[19:45] <wolverian> autrijus, does 1.isa('foo') check 1.isa(Str)?

[19:46] <autrijus> wolverian: no, it's either an error or it does a runtime lookup on ::foo.

[19:46] <autrijus> pugs implements the latter; it's apocryphal.

[19:47] <xinming> autrijus: the default multi key word is equal to "multi sub" right?

[19:47] <nothingmuch> xinming: yes

[19:47] <xinming> nothingmuch: so multi method override the default "multi" behavior... (In my humble ... )

[19:48] <nothingmuch> uh, i have no clue, what the semantics of those are

[19:48] <nothingmuch> there are just too many clashing metaphors, IMHO

[19:48] <nothingmuch> sub foo { }; # in the current package

[19:48] <nothingmuch> multi sub foo { }; # regardless of package, based on argument types only

[19:49] <nothingmuch> multi method foo { }; # in the current class, allows functional programming like pattern matching on types, values, etc

[19:49] <nothingmuch> submethod {}; # an uninherited method, should be a trait or attribute of methods, IMHO

[19:49] <wolverian> autrijus, does Larry want it to be ::('foo')?

[19:49] <nothingmuch> multi submethod {}; # is it a multi method that is uninheritable?

[19:50] <fglock_> but Lazy is a subtype - not a Class - so it's not seen by 'isa' (or is it?)

[19:50] <nothingmuch> did I forget anything?

[19:50] <nothingmuch> fglock_: Lazy is either a class or a role... i suspect it's a role

[19:51] <fglock_> roles aren't seen by isa

[19:51] <nothingmuch> how is multi sub found, btw?

[19:51] <autrijus> wolverian: no.

[19:51] <fglock_> but 'does' is

[19:51] <nothingmuch> really accross anything?

[19:51] <nothingmuch> who beats who? package Moose { multi sub foo ... }; package Dog { sub foo ...;  foo($thing) };

[19:52] <nothingmuch> what's the point of multi subs when you have mutlimethods? or rather, what's the difference?

[19:52] <nothingmuch> except the calling style?

[19:52] <fglock_> in this case Lazy would be a trait - but i think i've read it was a subtype

[19:52] <autrijus> nothingmuch: er wow, one thing at a time

[19:52] <autrijus> nothingmuch: in your example $thing won't ever see the moose foo

[19:52] <autrijus> it's not even in scope!

[19:52] <nothingmuch> autrijus: so i must import all multi subs I care about?

[19:53] <nothingmuch> in that sense, why aren't they just subs with pattern matching?

[19:53] <nothingmuch> why aren't the multimethods in the classes of the values involved?

[19:53] <nothingmuch> (which is something completely different)

[19:53] <autrijus> nothingmuch: multi subs are just subs with pattern matching.

[19:53] <autrijus> it's specced like that.

[19:53] <nothingmuch> so non multi subs are multi subs with the restriction of a unique short name?

[19:54] <nothingmuch> or can they not contain any pattern matching at all

[19:54] <nothingmuch> ?

[19:54] <autrijus> nonmulti subs can only be defined at one place.

[19:54] <autrijus> that's that.

[19:54] <autrijus> sure they can pattern match

[19:54] <autrijus> but if it fails it fails.

[19:54] <autrijus> doesn't retry.

[19:54] <autrijus> hence, much better compile time errors.

[19:54] <nothingmuch> so in a sense it's the same thing

[19:55] <nothingmuch> just that the compiler approaches definitions in a different way

[19:55] <autrijus> yes.

[19:55] <nothingmuch> have i said the "why isn't it a pragma" line today?

[19:55] <autrijus> also runtime override of multi is easier.

[19:55] <autrijus> s/override/augmentation/

[19:56] <autrijus> no, you havn't, but you can say that, and I'll answer that you can make s/sub/multi/ a pragma as you well please.

[19:56] <nothingmuch> no

[19:56] <nothingmuch> module Moose; sub foo {} ;

[19:56] <nothingmuch> that is uploaded to cpan

[19:56] <nothingmuch> module Dog; use Moose qw/foo/;

[19:56] <nothingmuch> use multi qw/i_know_what_i'm_doing/;

[19:56] <nothingmuch> sub foo () { };

[19:57] <autrijus> surely it can do a runtime rebind.

[19:57] <autrijus> or even compile time ones at that.

[19:57] <nothingmuch> but what is the difference?

[19:57] <nothingmuch> i still fail to understand why there is any technical distinction

[19:57] <nothingmuch> it's a pedantic one at best

[19:58] <autrijus> it is.

[19:58] <autrijus> which is good.

[19:58] <autrijus> think back to "use overload".

[19:58] <xinming> ...

[19:59] <nothingmuch> what about it?

[19:59] * xinming never saw any good point except to remember new keyword

[20:00] <autrijus> xinming: oh ok. you know the concept of overload?

[20:00] <autrijus> nothingmuch: multi is designed to replace overload

[20:00] <xinming> autrijus: hmm, I think I know...

[20:00] <nothingmuch> autrijus: and just that?

[20:00] <nothingmuch> 30% of a feature to replace a hack?

[20:00] <autrijus> nothingmuch: also replace the visitor pattern.

[20:00] <xinming> float add( float, float ); int add( int, int )...

[20:00] <autrijus> xinming: right, exactly

[20:01] <autrijus> xinming: in perl5, you can use "use overload" to overload some operators

[20:01] <autrijus> but only those

[20:01] <autrijus> and you can't extend the list

[20:01] <nothingmuch> autrijus: explain that please

[20:01] <autrijus> multi is designed so you can overload any operator or function that is marked to be overloadable.

[20:01] <autrijus> and to mark a function to be overloadable, you define it with "multi" first.

[20:01] <autrijus> end of explanation :)

[20:01] <nothingmuch> no, the visitor pattern thing

[20:02] * fglock_ thinks a subtype can be created using a role that overrides .isa - but it looks like a hack

[20:02] <nothingmuch> autrijus: but saying 'multi sub' just adds a flag to the definition of said sub

[20:02] <nothingmuch> right?

[20:03] <nothingmuch> and that flag is just a hint to the compiler saying "don't reject more definitions"

[20:03] <xinming> well, Maybe larry found that in perl 5, many aspects are too simple... so that try to make a more complex one... :-)

[20:03] <nothingmuch> and the compiler can then infer from the lack of this flag that the user is errorneously redefining something (which is an error i got once or twice in my life =()

[20:03] <svnbot6> r6378 | autrijus++ | * xinming pointed out that "sub foo" was silently treated

[20:03] <svnbot6> r6378 | autrijus++ |   as "multi foo" -- i.e. later "sub" did not override the

[20:03] <svnbot6> r6378 | autrijus++ |   earlier scope's "multi" or "sub".  Fixed.

[20:04] <autrijus> nothingmuch: you know what visitor pattern is?

[20:04] <nothingmuch> autrijus: nope

[20:04] <autrijus> ok. 

[20:04] <autrijus> http://www.ccs.neu.edu/research/demeter/papers/context-journal/node9.html

[20:04] <nothingmuch> do you remember these links by heart?

[20:04] <autrijus> no I googled it

[20:04] <autrijus> nothingmuch: the visitor pattern is designed to solve the OO problem where foolish people wrote

[20:05] <autrijus> if ($o->isa("Foo") {

[20:05] <autrijus> er

[20:06] <autrijus> sub visit_tree_sum (Tree $o) { given $o { when Leaf { .val } when Branch { visit_tree_sum(.left) + visit_tree_sum(.right } } }

[20:06] <autrijus> very ugly

[20:06] <nothingmuch> aha

[20:06] <nothingmuch> the visitor takes &infix:<+> and applies it?

[20:07] <autrijus> exactly.

[20:07] <nothingmuch> how does MMD get rid of that?

[20:07] <nothingmuch> by pattern matching Leaf and Branch?

[20:07] <autrijus> multi sum (Branch $_) { sum(.left) + sum(.right) }

[20:07] <autrijus> multi sub (Leaf $_) { .val }

[20:07] <nothingmuch> yes, I see

[20:08] <autrijus> s/sub/sum/

[20:08] <nothingmuch> okay, but that's not really replacing visitors, that's a different approach

[20:08] <nothingmuch> the way it's compiled is sort of like the visitor approach

[20:08] <nothingmuch> but it's more scalable

[20:08] <nothingmuch> since it's defined outwardly, and not inwardly

[20:08] <nothingmuch> this is inheritable

[20:08] <autrijus> now think when you want to visit two objects.

[20:08] <nothingmuch> uh, s/inheritable/extendable/;

[20:08] <autrijus> mmd becomes clearly superior.

[20:09] <nothingmuch> right

[20:09] <autrijus> and perl5's overload.pm totally fails.

[20:09] <autrijus> since it's biased inherently to the left.

[20:10] <nothingmuch> and why do we want this not to be the default again?

[20:10] <xinming> autrijus: multi sub () { ... }; will this just define a anonymous multi sub?

[20:10] <autrijus> xinming: I'm not sure you can have an anonymous multi

[20:10] <autrijus> I don't quite know what it means even

[20:10] <theorbtwo> Because it means you can't give messages about illegal use of subs at compile-time, because somebody might make it legal between then and when it's run.

[20:11] <autrijus> not only 'might', it's more like you expect people to.

[20:11] <autrijus> so you can warn, but not die fatally

[20:11] <fglock_> $x = multi sub () {...} | multi sub () {...}

[20:11] <fglock_> :)

[20:11] <nothingmuch> autrijus: multi foo (...) { }; multi foo (...) {}; my $anon = \&foo;

[20:11] <autrijus> nothingmuch: er sure

[20:11] <autrijus> nothingmuch: it's not anonymous though.

[20:11] <autrijus> it's a reference to a named thing.

[20:12] <nothingmuch> if the symbols go out of the scope it's anonymized, right?

[20:12] <nothingmuch> ooh

[20:12] <autrijus> sure but it's beside the point :)

[20:12] <nothingmuch> my &foo = multi sub (...) { }

[20:12] <nothingmuch> my &foo = multi sub (...) {};

[20:12] <nothingmuch> wtf happenned therE?

[20:12] <autrijus> syntax error.

[20:13] <nothingmuch> how do you do it then?

[20:13] <autrijus> like I said, I'm not sure multi can be used to anonymous sub syntax.

[20:13] <nothingmuch> my multi sub foo (...) { }?

[20:13] <autrijus> that works.

[20:13] <nothingmuch> so how do you generate mutli subs

[20:13] <nothingmuch> and assign them to globs?

[20:13] <nothingmuch> you *need* to do that

[20:13] <autrijus> why, easily

[20:14] <autrijus> the first multi clause creates a MultiSub object

[20:14] <autrijus> the next ones call its add_variant method or something.

[20:14] <nothingmuch> ah

[20:14] <nothingmuch> su my &foo = sub ( ) { };

[20:14] <nothingmuch> &foo.is_multi = 1;

[20:14] <nothingmuch> &foo.add_variant(sub () { });

[20:14] <nothingmuch> ?

[20:14] <autrijus> er you need a promotion

[20:14] <autrijus> or a rebless

[20:15] <nothingmuch> phooey that, they are the same =)D

[20:15] <autrijus> since it's different class underneath

[20:15] <autrijus> but generally yes ;)

[20:15] <nothingmuch> okay, so i win

[20:15] <nothingmuch> you only think you win

[20:15] <fglock_> (maybe a trait?)

[20:15] <nothingmuch> fglock_: i'd argue yes

[20:15] <nothingmuch> there's no real functional diff

[20:15] <nothingmuch> they both do parameter pattern matching

[20:16] <xinming> just watching your conversation, I learnt a lot. :-)

[20:16] <nothingmuch> xinming: me too =)

[20:16] <autrijus> anyway, yes you can do all that at runtime

[20:16] * nothingmuch really wants to do it to broken code at compile time

[20:17] <autrijus> but then the compiler won't catch your errors :)

[20:17] <autrijus> timtowtdi.

[20:17] <nothingmuch> what errors?

[20:17] <autrijus> accidental redefinition; static typechecks; inlining

[20:17] <nothingmuch> the latter two - please explain

[20:18] <nothingmuch> the first one i don't care about

[20:18] <nothingmuch> it has never happenned to me in perl 5 land

[20:18] <nothingmuch> unless i really ment it

[20:18] <nothingmuch> meant

[20:18] <nothingmuch> then you just say 'no warnings'

[20:18] <fglock_> static typechecks means the compiler already knows which sub to call

[20:18] <nothingmuch> fglock_: i know

[20:19] <nothingmuch> i don't know what compile time appending of multi flag has to do with it

[20:19] <nothingmuch> it should simply change the compiler's mind regarding what's going on

[20:19] <nothingmuch> and static binding is a link time optimization anyway

[20:20] <fglock_> the problem would be runtime binding, I think - that can be slow

[20:20] <nothingmuch> runtime binding is slow

[20:20] <autrijus> ok. when you import two subs from diff. pkg the the same user space

[20:20] <autrijus> with the same name

[20:20] <autrijus> if both are sub, the compiler can stop you right there

[20:20] <nothingmuch> autrijus: that's not the same as 'use Moose qw/foo/; multi foo () { }'

[20:21] <nothingmuch> that indeed looks like an error

[20:21] <nothingmuch> unless you resolve the conflict by saying 'multiize these two in this lexical scope'

[20:22] <autrijus> I'm not sure of that. hm

[20:23] <nothingmuch> or you say 'both are multi of the same sub'

[20:23] <autrijus> oh also. you said both does pattern match

[20:23] <nothingmuch> that's the choices i'd like to have

[20:23] <nothingmuch> either: conflict

[20:23] <autrijus> that is partially true

[20:23] <nothingmuch> multi just for here

[20:23] <nothingmuch> multi everywhere

[20:23] <nothingmuch> which will require recompilation of other code

[20:23] <autrijus> multis need to sort

[20:23] <autrijus> their dispatcher need to do multistep narrowing

[20:23] <autrijus> with layers of invocants

[20:24] <autrijus> nonmultis doesn't have the layers

[20:24] <nothingmuch> and again, IMHO it's only sane if dispatch order is orthogonal to definition order

[20:24] <nothingmuch> the fact that they don't have them is an optimization, is it not?

[20:24] <autrijus> it's just one layer, always flattened, and just checked for false/true, not constraints

[20:24] <autrijus> er, as opposed to what?

[20:24] <nothingmuch> well, as I see it SMD is functionally a subset of MMD

[20:25] <autrijus> I understand your position very well :)

[20:25] <nothingmuch> by simply not making use of the multiness of MMD you get the same behavior

[20:25] <nothingmuch> hence there is no distinction

[20:25] <nothingmuch> you can also tell the compiler that 'if i added more multis, that was a mistake'

[20:25] <nothingmuch> and it can compile more efficiently or make up better errors with that knowlege'

[20:26] <autrijus> well you just outlined the distinction yourself.

[20:26] <nothingmuch> that's not a distinction, that as optimization and a compiler hint =)

[20:26] <autrijus> it's all lambda calculus -- I mean turing machine underneath

[20:27] <autrijus> _everything_ is either a compiler flag or a runtime hack.

[20:27] <nothingmuch> no

[20:27] <nothingmuch> there's a conceptual difference

[20:27] <nothingmuch> let me demonstrate:

[20:27] <nothingmuch> multi sub foo (); # no other definitions

[20:27] <nothingmuch> use optimize :closed(Everything);

[20:27] <nothingmuch> is 'multi' a no-op in this specific case?

[20:28] <nothingmuch> i argue that it is

[20:28] <autrijus> I argue not.

[20:28] <nothingmuch> then please enlighten me

[20:28] <autrijus> unless of course you put them both in the single toplevel program.

[20:28] <autrijus> then sure.

[20:28] <autrijus> if you however put the two lines in two files.

[20:28] <nothingmuch> okay

[20:28] <autrijus> separate compilation kicks in

[20:28] <nothingmuch> then again we agree

[20:28] <nothingmuch> it's a matter of *when* resolving happens

[20:28] <nothingmuch> but it's still the same resolution

[20:28] <nothingmuch> for both single and multi

[20:28] <autrijus> er no.

[20:29] <autrijus> if you write

[20:29] <autrijus> multi sub foo () {}

[20:29] <autrijus> in a file

[20:29] <autrijus> and let compiler generate code for it

[20:29] <autrijus> it needs to be different from

[20:29] <autrijus> sub foo () {}

[20:29] <autrijus> for obvious reasons.

[20:29] <nothingmuch> but the compiled 'sub foo {}' can be transformed at link time WRT to it's consumer

[20:29] <nothingmuch> into something that is exactly the same as 'multi sub foo () {}', right/

[20:30] <autrijus> really. how?

[20:30] <autrijus> whole-program analysis?

[20:30] <autrijus> solving the eval halting problem?

[20:30] <nothingmuch> by saying 'use Moose :asMulti<foo>' or something like that

[20:30] <nothingmuch> no

[20:30] <autrijus> drop all special case hints please ;)

[20:30] <nothingmuch> these are more than special case hints

[20:30] <autrijus> you can of course emulate any behaviour with anything else.

[20:31] <autrijus> but in absense of hints, they are different things and generates different object code.

[20:31] <nothingmuch> i really don't see *why*, not *that* subs are not just a subset of multis

[20:31] <nothingmuch> post object code too

[20:31] <nothingmuch> why it isn't that their user can determine what they are

[20:31] <nothingmuch> and they simply provide a default

[20:32] <autrijus> you can force sub to become multisub by a slow non-compiler-protected rebinding.

[20:32] <nothingmuch> that's not what I want

[20:32] <nothingmuch> because I see no reason that the compiler can't be told to rebind

[20:32] <nothingmuch> in a fast compiler protected way

[20:32] <nothingmuch> and in a lexically scoped or global way

[20:33] <autrijus> you mean the linker

[20:33] <nothingmuch> they are the same to me

[20:33] <nothingmuch> since the compiler compiles based on what the linker linked

[20:33] <nothingmuch> after the compiler compiled the code that caused the link

[20:33] <autrijus> alright. technically I think you are right; it is feasible. practically though, I have not seen anyone do that.

[20:34] <nothingmuch> i would see me do it

[20:34] <autrijus> probably because smd-turned-mmd is not considered a popular use case.

[20:34] <nothingmuch> i'd see me fix Class::DBI::AsForm that way

[20:34] <nothingmuch> i'd implement Class::Events that way

[20:34] <autrijus> so, because of this practical (in)consideration, there is a conceptual difference.

[20:34] <autrijus> but yes, if you take that away, then transmeta CPU is as good as intel CPU, or something like that.

[20:35] <nothingmuch> beh

[20:35] <autrijus> (no, seriously; it's similar) 

[20:35] <nothingmuch> i still don't understand this:

[20:35] <nothingmuch> a feature intended to protect newbies limits the technical capabilities of the language

[20:35] <nothingmuch> in a language that isn't java

[20:35] <xinming> nothingmuch: me either... :-)

[20:36] <autrijus> er look

[20:36] <autrijus> 04:32 < autrijus> you can force sub to become multisub by a slow non-compiler-protected rebinding.

[20:36] <autrijus> 04:32 < nothingmuch> that's not what I want

[20:36] <autrijus> I'd argue no technical capabilities per se is being violated :)

[20:36] <nothingmuch> i argue the compiler should be implemented that way

[20:36] <nothingmuch> and then on top of that the newbie guard can be added

[20:36] <autrijus> and it will be even efficient, if you do help implementing the compiler that way.

[20:37] <autrijus> but in either case the capability is there.

[20:37] <xinming> But, IMHO, multi is a thing a bit like syntax highlighting... It is not needed to a computer... But really useful to a human... :-)

[20:37] <nothingmuch> xinming: it's necessary to fix broken 3rd party code which you get as encapsulated byte code

[20:37] <autrijus> xinming: yes... but consider if you said

[20:37] <autrijus> sub close ($x) { say "I'm closed! $x" }

[20:38] <autrijus> and discovered that you can't call close($IN)

[20:38] <autrijus> because it's an IO and there is a (sub close (IO $x) {...}) by default

[20:38] <autrijus> that will likely become inconvenient very quickly.

[20:38] <autrijus> so @Larry ruled that you can override a multi with a same-named sub

[20:38] <nothingmuch> autrijus: but you didn't import IO qw/close/;

[20:39] <autrijus> and the default builtin functions are all multis

[20:39] <nothingmuch> so it's always $IN.close;D

[20:39] <autrijus> and you can safely override any of them with your subs.

[20:39] <nothingmuch> close: $in;

[20:39] <nothingmuch> or if it is imported, you get a compilation error that you can turn off

[20:39] <nothingmuch> or you can say 'my sub close ($x) { say "I'm closed! $x" };

[20:39] <nothingmuch> and close($IN) will go that anyway

[20:39] <nothingmuch> since lexical wins

[20:40] <autrijus> nothingmuch: right, but that violates principle of least surprise

[20:40] <nothingmuch> 23:39 < nothingmuch> or if it is imported, you get a compilation error that you can turn off <-- not surprising

[20:41] <nothingmuch> btw, what is 'close'?

[20:41] <autrijus> by turning it off, you mean the compiler do the mutilate thing

[20:41] <nothingmuch> class IO { method close () { } } ?

[20:41] <autrijus> nothingmuch: er it's a multisub defined in IO and Socket?

[20:41] <autrijus> global multisub at that

[20:41] <nothingmuch> so you have to import it, right?

[20:41] <nothingmuch> or it's in Prelude?

[20:41] <nothingmuch> imported for you?

[20:41] <autrijus> it's prelude.

[20:41] <autrijus> yeah

[20:41] <nothingmuch> wtf?

[20:41] <nothingmuch> global multisub? as opposed to?

[20:42] <autrijus> package-scoped

[20:42] <autrijus> it's &*close

[20:42] <nothingmuch> uh, i'm confused again

[20:42] <nothingmuch> but now it's cleared

[20:42] <nothingmuch> r

[20:42] <autrijus> cool. and as much as I'd like to chat, I've been neglecting $work, and it's 4:43am

[20:43] <autrijus> so I'm afraid I need to go off irc :)

[20:43] <nothingmuch> how do you say $IO.close?

[20:43] <nothingmuch> is there also a method close?

[20:43] <nothingmuch> ciao

[20:43] <nothingmuch> class IO { method close () { close $?SELF } }; # stupid

[20:44] <autrijus> surely $IO.close dispatches to &*close.variants(IO)

[20:44] <autrijus> it doesn't need a method there.

[20:44] <nothingmuch> class IO { method close () }; package Prelude; multi sub *close (IO $obj) { $obj.close }; multi sub *close (Socket $obj) { $obj.close }

[20:44] <nothingmuch> why? it's a sub, not a method

[20:44] <nothingmuch> why is that distinction going away?

[20:44] <autrijus> multisubs in scope gets the dispatch when no method is found.

[20:44] <xinming> autrijus: hmm, If this consumes you so much time, I'd really suggest you to finish "pugs" first. As These "feature" can be discussed in the future. :-)

[20:45] <nothingmuch> ick!

[20:45] <autrijus> nothingmuch: that's what the visitor pattern is for!

[20:45] <nothingmuch> i'd much rather have methods being treated as global multisubs when they're unambiguously resolved at compile time

[20:46] <autrijus> I sympathize.

[20:46] <autrijus> but perl6 is not that sort of language 

[20:46] <autrijus> please send S06 diffs to p6l :)

[20:46] <nothingmuch> phooeey

[20:46] <nothingmuch> this is such a huge mess

[20:46] <autrijus> (as in, I'd really like to do static method binding)

[20:46] <nothingmuch> i want to try that absynthe thing the examiner chick is into

[20:47] <autrijus> xinming: right, I'll try that ;)

[20:47] <autrijus> but before that I need to go back to $work before I fall unconscious.

[20:47] * autrijus waves &

[20:47] <nothingmuch> ciao

[20:48] <nothingmuch> wtf is eigen btw?

[20:52] <nothingmuch> btw, are rules normal methods that are just compiled to a different target language (usually PGE?)

[20:52] <xinming> ?eval sub x2 (Str $x) { 'str called'.say }; sub x2 (Int $x) { 'int called'.say }; 3.x2

[20:52] <evalbotzy> int called bool::true 

[20:53] <xinming> hmm, it seems that the bug still exist.

[20:53] <nothingmuch> ?eval sub x2 (Str $x) { 'str called' }; sub x2 (Int $x) { 'int called' }; 3.x2

[20:53] <evalbotzy> 'int called' 

[20:53] <nothingmuch> ?eval sub x2 (Str $x) { 'str called' }; sub x2 (Int $x) { 'int called' }; "3".x2

[20:53] <evalbotzy> 'int called' 

[20:53] <nothingmuch> ?eval say "moose"

[20:53] <evalbotzy> moose bool::true 

[20:54] <xinming> ?eval say "evalbotzy is stupid."

[20:54] <evalbotzy> evalbotzy is stupid. bool::true 

[20:54] <xinming> :-)

[20:54] <nothingmuch> ?eval say "is evalbotzy stupid?"

[20:54] <evalbotzy> is evalbotzy stupid? bool::true 

[20:54] <nothingmuch> that's more like it =)

[20:54] <nothingmuch> you know what's also nice?

[20:55] <nothingmuch> ?eval "xinming++ " x 3

[20:55] <evalbotzy> 'xinming++ xinming++ xinming++ ' 

[20:55] <nothingmuch> jabbot: karma xinming 

[20:55] <jabbot> nothingmuch: xinming  has neutral karma

[20:55] <nothingmuch> uh, yeah, sure

[20:55] <xinming> jabbot: karma evalbotzy

[20:56] <jabbot> xinming: evalbotzy has neutral karma

[20:58] <nothingmuch> macro  "->"

[20:58] <xinming> I'd think if perl 6 "rule" syntax could be written as a normal "sub" which will use print or say such kind of things to a string to compose a "rule"

[20:59] <nothingmuch> xinming: i'd think of it like parsec treats it's monadic actions

[20:59] <xinming> hmm, Maybe just the humble opinion of mine. :-)

[20:59] <nothingmuch> sub moose is rule (@input_tokens is delayed) { ... } 

[21:00] <nothingmuch> sub <a-z> is rule (@input_tokens is delayed){ atomic { die unless shift @input_tokens eq any("a" .. "z")  } }

[21:01] <nothingmuch> or somesuch

[21:01] <xinming> I skiped the grammar and rule section while I reading the synopsis. :-) everytime.

[21:01] <lamer0> will perl 6's threads be cpu scalable?

[21:02] <xinming> lamer0: I think This should be a function of parrot.

[21:02] <nothingmuch> lamer0: define that

[21:02] <nothingmuch> and generally "if it's a good thing, we hope so"

[21:03] <lamer0> such as, you create two threads, they get split evenly between two cpus

[21:03] <lamer0> or between two cores, or evenly on a hyperthreaded cpu

[21:03] <nothingmuch> lamer0: that's for the OS to decide, and for parrot to make portable

[21:03] <lamer0> right now for example python, it uses internal threads, it does not get split evenly and just ends up bouncing back and forth

[21:03] <nothingmuch> ouch, that sucks

[21:04] <lamer0> well, I wrote this quick floating point benchmark program in C and python, with C posix threads the two threads get split evenly between two cpus.. python on the other hand just bounces around

[21:04] <xinming> nothingmuch: $a + $b, <+> here is infix, <!-- comments here --> <\<!-- --\>> is circumfix, so what are the prefix and postfix?

[21:04] <nothingmuch> lamer0: are you sure that it isn't just how python is compiled for your platform?

[21:05] <nothingmuch> xinming: prefix is like multi sub &prefix:<~> ($thing --> Str) { }

[21:05] <nothingmuch> postfix is like sub &postfix:<++>, as in '$a++'

[21:05] <nothingmuch> unary postfix and unary prefix that is

[21:05] <nothingmuch> the first is ~ as in ~50 yields "50"

[21:06] <xinming> nothingmuch: so, the postfix is at the ass part... the infix in at the front, right?

[21:06] <nothingmuch> yes

[21:06] <nothingmuch> pre is before, post is after

[21:06] <nothingmuch> post mortum - the thing after death

[21:07] <nothingmuch> pre-calculated - calculated in advance

[21:07] <nothingmuch> latin

[21:07] <nothingmuch> but borrowed into english

[21:08] <xinming> nothingmuch: hmm, and prefix will takes 2 arguments always, others only one, right?

[21:08] <nothingmuch> prefix takes one argument

[21:08] <nothingmuch> listfix takes N arguments

[21:08] <lamer0> how far a long is parrot anyway?

[21:08] <xinming> oops,

[21:08] <xinming> s/prefix/infix/

[21:08] <nothingmuch> and a unicode named sub like 'sub x ($obj, $obj)' takes two

[21:08] <nothingmuch> yes, infix takes two, and is between them

[21:09] <nothingmuch> lamer0: uh, it depends

[21:09] <lamer0> is it useable at all? for personal use?

[21:09] <nothingmuch> i would say 30% of completeness, 80% of functionality

[21:09] <nothingmuch> yes it is, but it's not stable enough (the API)

[21:09] <nothingmuch> Dan uses it at work

[21:10] <xinming> nothingmuch: 30% of completeness, 80% of functionality is also the progress of perl 6. :-)

[21:11] <nothingmuch> xinming: i'd say 15% completeness, no more

[21:11] <nothingmuch> xinming: there's still lots of stuff to do WRT to compilation semantics

[21:11] <nothingmuch> which we are only exploring in our heads right now

[21:11] <xinming> what does WRT mean please?

[21:12] <xinming> Ok, I know, WRT = write.

[21:12] <nothingmuch> "With Respect To"

[21:12] <nothingmuch> sorry =)

[21:14] <xinming> nothingmuch: hmm, I really don't understand... I've read the synopsis, and found, It seems cover most of the normal syntax of perl 6.

[21:14] <nothingmuch> xinming: yes, that part is pretty far along

[21:14] <nothingmuch> but the actual semantics are very complicated

[21:14] <xinming> nothingmuch: maybe I am too eye-narrow...

[21:14] <nothingmuch> in that there are many details

[21:14] <nothingmuch> this isn't specced but:

[21:14] <nothingmuch> compilation of code is chunked into units

[21:15] <nothingmuch> each unit pretends it's compiled in another process

[21:15] <nothingmuch> they have no knowlege of each other

[21:15] <nothingmuch> a piece of code that consumes other code gets access to the compiled version

[21:15] <nothingmuch> and it's compiled structure is linked against that

[21:16] <nothingmuch> this process covers a hell of a lot of decisions that need to be made

[21:16] <nothingmuch> which no one has really thought about yet

[21:16] <nothingmuch> uh, correction

[21:16] <nothingmuch> which no one has really thought about until the hackathon

[21:16] <nothingmuch> at least to my knowlege

[21:16] <xinming> nothingmuch: hm, do you mean, the specification is almost "finished", But the problem is the parser or "compiler". It's far more complex than we can think?

[21:17] <nothingmuch> no

[21:17] <nothingmuch> the specificationc overs just one side of the language:

[21:17] <nothingmuch> definition

[21:17] <nothingmuch> it is very lacking in another, IMHO broader side: behavior

[21:17] <xinming> ...

[21:18] <xinming> hmm, You mean, It doesn't covers all the situation that other programmers might hold. or try.

[21:18] <xinming> ?eval "sorry for my poor English... nothingmuch.".say

[21:18] <evalbotzy> sorry for my poor English... nothingmuch. bool::true 

[21:18] <nothingmuch> xinming: english is not a prerequisite =)

[21:19] <nothingmuch> xinming: not only that... the synopses are indeed ambiguous in some places

[21:19] <nothingmuch> but more than that - the way the perl 6 system 

[21:19] <nothingmuch> that is:

[21:19] <nothingmuch> the compiler

[21:19] <nothingmuch> the runtime

[21:19] <nothingmuch> the language

[21:19] <nothingmuch> the libraries

[21:19] <nothingmuch> how they behave

[21:19] <nothingmuch> how they integrate

[21:19] <nothingmuch> those aspects are not tightly woven enough

[21:19] <nothingmuch> they are easy to gues

[21:19] <nothingmuch> s

[21:20] <nothingmuch> but not yet completely designed

[21:20] <nothingmuch> and some parts are completely unimplemented

[21:21] <xinming> nothingmuch: Hmm, Now I know, I think I can understand.

[21:22] <xinming> hmm, what part the pugs plays?

[21:22] <xinming> runtime?

[21:23] <nothingmuch> xinming: currently it's about 15% of a compiler

[21:23] <nothingmuch> and a runtime

[21:23] <nothingmuch> and libraries

[21:23] <nothingmuch> the libraries are written in perl 6 and haskell

[21:23] <nothingmuch> soon it should be 25% of  compiler

[21:23] <xinming> nothingmuch: Ok, If we just need a parser like perl 5 does, no need compile it into binary or such, just need to learn the "language" itself...

[21:24] <nothingmuch> perl5 is more than a parser:

[21:24] <nothingmuch> it's a parser

[21:24] <nothingmuch> with a weighted tokenizer

[21:24] <nothingmuch> that compiles to in memory op tree

[21:24] <nothingmuch> and a peephole optimizer which fixes that op tree into something more efficient

[21:24] <nothingmuch> and a VM which walks the op tree and executes it

[21:27] <xinming> hmm, In fact, What I want, is just wishing pugs finished all the perl 6 language definition, and libraries will be out soon... IMHO It won't be long as @Larry wrote the language spcification. ;-)

[21:27] <Khisanth> but the language specification is not yet written :)

[21:27] <nothingmuch> xinming: but the language isn't 100% finished

[21:27] <nothingmuch> look at the argument we just had today:

[21:27] <nothingmuch> we still don't know exactly how MMD works

[21:28] <xinming> Khisanth: hmm, well, I believe that Synopsis is reaching the truth...

[21:28] <nothingmuch> xinming: i'd say no more than 50% there

[21:28] <nothingmuch> though it seems more

[21:28] <xinming> ...

[21:29] <autrijus> 99% of statistics is useless anyway.

[21:29] <xinming> I'd say @Larry is mutable...

[21:29] <autrijus> the remaining 1% is rounding error

[21:29] <nothingmuch> @Larry has a mute button?

[21:30] <xinming> autrijus 99% of statistics is useless anyway. what does this mean please?

[21:30] <autrijus> xinming: it means that the 50%, 20% etc figure is not useful without a measurement

[21:31] <autrijus> and really it's very hard to quantify things.

[21:32] <autrijus> for example, I can say we have six milestones and we only reached one.

[21:32] <autrijus> does that makes pugs 13% there?

[21:32] <autrijus> surely not; it's arbitary, and the other milestones have been progressing simultaneously

[21:33] <xinming> autrijus: Nope... the bigger one and the smaller one.

[21:33] <autrijus> so the numbers are more like confidence ratings

[21:33] * autrijus goes back to $work :)

[21:33] <xinming> autrijus: good job. ;-)

[21:34] <autrijus> thank-you :)

[21:34] <autrijus> &

[21:34] <nothingmuch> http://dev.perl.org/perl6/status.html <-- eep. 2001?

[21:35] <obra> nothingmuch: patches welcome. to [email@hidden.address]
[21:35] <nothingmuch> obra: no thanks

[21:54] <svnbot6> r6379 | autrijus++ | * PIL1's poem: "Tin?\195?\186viel, Tin?\195?\186viel!"

[21:55] <xinming> autrijus: the "sub/multi" bug still not fixed.

[21:55] <xinming> ?eval sub x2 (Str $x) { 'str called'.say }; sub x2 (Int $x) { 'int called'.say }; 3.x2

[21:55] <evalbotzy> int called bool::true 

[21:56] <Khisanth> that looks correct ...

[21:57] <xinming> Khisanth: No, In fact, this example should raise a error.

[21:58] * xinming is not so sure about this.

[21:58] <autrijus> ?eval sub x2 (Int $x) { 'int called' } sub x2 (Str $x) { 'str called' } 3.x2

[21:58] <evalbotzy> 'str called' 

[21:58] <autrijus> *shrug* I think it's fixed.

[21:58] <xinming> :-)

[21:58] <autrijus> it should have raised an error, yes, but we don't have a compiler yet, so it can't easily do that :)

[21:59] <autrijus> meanwhile, having the latter x2 override the earlier x2 is implemented.

[21:59] <autrijus> compare:

[21:59] <autrijus> ?eval multi x2 (Int $x) { 'int called' } multi x2 (Str $x) { 'str called' } 3.x2

[21:59] <evalbotzy> 'int called' 

[21:59] <autrijus> see the difference?

[21:59] <Khisanth> ah you mean it's acting as a multi sub even when not declared as one?

[21:59] <autrijus> Khisanth: it was. not anymore

[22:00] <autrijus> hey iblech!

[22:00] <xinming> autrijus: hmm, I see the difference.

[22:00] <xinming> hi iblech 

[22:01] <iblech> Hi :)

[22:02] <iblech> nothingmuch: re serializing code -- can I find your answer in the backlog?

[22:02] <nothingmuch> iblech: yes. 3 minutes or so after you left

[22:02] <autrijus> iblech: does pil2js solve sudoku?

[22:02] <iblech> nothingmuch: Thanks, /me looks

[22:03] <autrijus> (examples/continuation/nondet_sudoku.p6)

[22:03] * iblech tets

[22:03] * iblech tests

[22:03] <autrijus> pdcawley: cross yer fingers :)

[22:03] <iblech> Compile error -- invalid Pugs.PIL1.PIL_Expr

[22:04] <autrijus> take away the do block

[22:05] <autrijus> I actually

[22:05] <autrijus> just removed the 'do'

[22:05] <autrijus> on line 55

[22:05] <xinming> hmm, In my understanding of perl 6, It seems that perl 6 is doing something which describe the language it self. Just spcifying the rule sets of the language... So, You might even write a "perl 6" language which can parse "basic" source, am I right?

[22:06] <autrijus> and it compiles. committing

[22:06] <iblech> autrijus: &choose accesses &give_up -- but this doesn't work as &choose is in pilGlob, far away from pilMain

[22:06] <iblech> Converting to subrefs now

[22:06] <theorbtwo> xinming: There's syntax, and there's semantics.

[22:06] <autrijus> ah, the old lifting problem

[22:06] <autrijus> yeah

[22:07] <theorbtwo> Changing the syntax of perl6 is /very/ easy.

[22:07] <theorbtwo> The hard(er) bit is where there is semantic differences between the languages.

[22:07] <autrijus> and you can always solve them by emulation

[22:07] <xinming> theorbtwo: hmm, In fact, I mean, you can override the operators...

[22:07] <autrijus> but sometimes emulation is so slow it isn't practical anymore

[22:07] <theorbtwo> Exactly... in one direction.

[22:08] <iblech> autrijus: &uniq is not yet implemented in PIL2JS

[22:08] <theorbtwo> The hard bit is passing things from perl6-world that don't have any real equivelent in basic-world.

[22:08] <theorbtwo> What does a continuation look like from a language that doesn't have funtion pointers?

[22:08] <autrijus> it would look like a toplevel function.

[22:09] <autrijus> or a label that you can jump to.

[22:09] <theorbtwo> Perhaps not the best of examples.

[22:09] <autrijus> :)

[22:09] <autrijus> you can ask "what does a compiler look like from the game of life?"

[22:09] <autrijus> "how do you write &eval with gliders?"

[22:10] <svnbot6> r6380 | chromatic++ | Untabified source code.

[22:10] <svnbot6> r6380 | chromatic++ | Don't add empty descriptions in Test::Builder::Test report() methods.

[22:10] <svnbot6> r6380 | chromatic++ | Don't use non-existent $.really_passed in Test::Builder::Test::TODO.

[22:10] <svnbot6> r6380 | chromatic++ | Added test_pass() and test_fail() to Test::Builder::Tester.

[22:10] <svnbot6> r6380 | chromatic++ | Added get_test_number() to Test::Builder (but may change name later).

[22:10] <svnbot6> r6381 | autrijus++ | * remove spurious 'do' from sudoku solver.

[22:10] <svnbot6> r6382 | iblech++ | * t/statements/loop.t: Minor fix.

[22:10] <svnbot6> r6382 | iblech++ | * PIL2JS:

[22:10] <svnbot6> r6382 | iblech++ |   * PIL::Subs, PIL::Params:

[22:10] <svnbot6> r6382 | iblech++ |     Refactored PIL::PSub to be a subclass of PIL::PCode.

[22:10] <svnbot6> r6382 | iblech++ |     This will makes adding support for coroutines much simpler.

[22:10] <svnbot6> r6382 | iblech++ |   * Prelude::JS::ControlFlow:

[22:10] <svnbot6> r6382 | iblech++ |     * Fixed &next, &last, &redo (was a two-char fix...).

[22:10] <svnbot6> r6382 | iblech++ |     * Added &statement_control:<postwhile> and postuntil.

[22:10] <autrijus> and the answer would be http://rendell.server.org.uk/gol/tm.htm

[22:12] <theorbtwo> At some point all turing-machine equivelent langauges are equivelent, yes... but if everything looks like a turing machine, then you might as well be programming in brainfuck.

[22:13] <autrijus> right. and nowadays, most self-respecting languages can communicate with the vanilla C semantics of function calls and primitive types

[22:14] <autrijus> but as all Inline::* users (and authors!) know, that's simply too painful.

[22:15] <putter> hi all.

[22:15] <autrijus> thus, the interest in virtual machines. ;)

[22:15] <autrijus> hi putter.

[22:15] <theorbtwo> I'm not sure I follow that leap, autrijus?

[22:15] <putter> nothingmuch: re smoking rules, when I ran it on my own machine it just worked, so I dont have any "what might be wrong" suggestions.  Sorry.

[22:16] <nothingmuch> crapxor

[22:16] <autrijus> theorbtwo: oh ok. the C semantics maps into an ideal machine, but that ideal machine doesn't do enough interesting things

[22:16] <autrijus> now that the "interesting" level is rised

[22:16] <autrijus> but just how interesting is interesting enough, is an interesting question.

[22:17] <theorbtwo> Wouldn't an interesting ABI spec on a real machine be able to do the same sorts of interesting things?

[22:17] <autrijus> why, sure, except for the reprogrammable bit

[22:17] <putter> ?eval class C { has $.v } my $c = C.new;  sub f(){ $c }  f().v

[22:17] <evalbotzy> Error: No compatible subroutine found: "&v" 

[22:18] <autrijus> ?eval  class C { has $.v } my $c = C.new;  sub f() returns C { $c } f().v

[22:18] <evalbotzy> \undef 

[22:18] <autrijus> putter: bad inferencing at work. known problem

[22:18] <autrijus> and tested for, iirc.

[22:18] <putter> ooooohh.  but a workaround!  happy, happy, joy, joy, joy.  autrijus++

[22:18] <putter> autrijus++

[22:18] <autrijus> :)

[22:21] <autrijus> theorbtwo: if Java Chips can microassemble themselves when a new Java spec is out

[22:21] <svnbot6> r6383 | autrijus++ | * make crude_repl run on platform that doesn't have `cat`.

[22:21] <autrijus> I think they will fare much better :)

[22:22] <autrijus> in that regard, our Parrot Chip is much more adaptable

[22:22] <autrijus> but the technical difficulty at mass production is a problem.

[22:23] * autrijus is reminded of the "clone dconway to run perl6 for you" sayings way back

[22:23] <obra> autrijus: cloning?

[22:23] <autrijus> obra: and mind transfer, yeah

[22:24] <theorbtwo> Obra: It'd be easier to get a Damien Conway whenever you want to execute perl then to make a perl6 evaluator on a computer.

[22:34] <iblech> BTW, http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/log/ is still at r6317. Known?

[22:39] <autrijus> iblech: nope. thanks, fixed.

[22:39] <svnbot6> r6384 | putter++ | Beginning of a JavaScript front-end.

[22:39] <svnbot6> r6384 | putter++ | modules/JavaScript-FrontEnd/Grammar.pm: a grammar derived from the ECMA-262 spec.  It is untested.  And is unrunnable on current PGE.

[22:39] <iblech> autrijus: Thanks much :)

[22:39] <iblech> putter: JavaScript front-end? /me looks

[22:40] <autrijus> mm compiling javascript to javascript.

[22:40] <autrijus> but narcissus project did that

[22:42] <putter> js to p5?  js to haskell?  ;)

[22:42] <autrijus> that'd be too useful ;)

[22:43] <putter> iblech: the only thing there now is an unrunnable and untested grammar.   next step would be a runtime.

[22:45] <putter> hmm, pugs head just now failed to build with an error of

[22:45] <putter> /usr/bin/perl -Iinc util/drift.pl src/Pugs/PIL1.hs-drift > src/Pugs/PIL1.hs

[22:45] <putter> runhugs: Error occurred

[22:45] <putter> ERROR - Unable to open file "/home/net1/perl6/pugsxpl2/util/../../DrIFT/src/DrIFT.hs"

[22:45] <autrijus> mea culpa

[22:46] <nothingmuch> ciao!

[22:46] <putter> bye.

[22:46] <autrijus> fixed.

[22:46] <autrijus> see ya

[22:46] <putter> danke

[22:46] <autrijus> bitte schn

[22:48] <svnbot6> r6385 | autrijus++ | * unbreak the build. remember to check in PIL1.hs after modifying

[22:48] <svnbot6> r6385 | autrijus++ |   PIL1.hs-drift -- even just adding a poem

[22:48] <putter> nothingmuch: actually, one note on smoke.  you are failing, rather than skipping, the t/rules/from_perl6/rules/*.t.  Johnathan's smoke is skipping them, but failing t/rules/rules.t.  curious.  dont know what it means.

[22:48] <nothingmuch> *shrug*

[22:48] <nothingmuch> i'll look at it when i have some spare time, and my brain is functional

[22:49] * putter pines for a working public smoke of p6 rules... :-(

[22:49] <putter> thanks. L)

[22:49] <putter> err, :) even

[22:50] <nothingmuch> perhaps if parrot were also pining towards a good goal (like fjords) it would just work

[22:51] <putter> lol

[22:53] <fglock___> iblech: what kind of structure a "type" is in PIL2JS runtime? I'm studying how to implement types in Perl5 runtime

[22:54] <pasteling> "putter" at 66.30.119.55 pasted "pugs head compile warning" (13 lines, 933B) at http://sial.org/pbot/12623

[22:54] <fglock___> (I mean, a subtype)

[22:54] <iblech> fglock___: Ah. There is none :)

[22:55] <putter> Compiling Pugs.Embed.Perl5 is currently unhappy.

[22:55] <iblech> fglock___: Much of the OO stuff needs -CPIL2

[22:56] <iblech> fglock___: And, as there is no -CPIL2 yet, very little OO things work -- in fact, only method declarations work

[22:57] <autrijus> putter: that warning was always like that.

[22:59] <nothingmuch> iblech: read mail

[22:59] <fglock___> If I define 'multi sub grep(List x:,...){...}' globally, will $list.can(grep) work?

[23:00] <nothingmuch> fglock___ =~ s/_*$//;

[23:00] <fglock___> :)

[23:00] <fglock___> that's my beard

[23:01] <iblech> fglock___: I don't think so -- the class isn't modified in any way, I think.

[23:02] <fglock___> so 'can' will be mostly useless, with most routines being defined in Prelude?

[23:02] <putter> autrijus: really?  oh, ok, thanks.

[23:02] <fglock___> (unless they are defined in a class, and then exported)

[23:03] <iblech> Why do they need to be exported?

[23:04] <fglock___> ok, right

[23:04] <iblech> method grep (@array: ...) {...} -- then both @foo.grep and grep @foo will work

[23:04] * autrijus waves again... &

[23:04] <iblech> bye autrijus :)

[23:06] <fglock___> If it is defined in Prelude, does it have to be: method Array::grep (... in order to be a method? (and be can()'ed)

[23:07] <iblech> I think method grep (Array $self: ...) (or method grep (@self: ...)) is sufficient

[23:07] <iblech> But probably explicitly writing Array::grep doesn't hurt

[23:10] <fglock___> method grep ( Array|List @a: ...

[23:10] <iblech> Right.

[23:11] <iblech> (BTW, this is how PIL2JS handles methods like .pairs currently: method pairs (Hash|Array|Pair $self:) {...})

[23:21] <putter> ?eval do{my $r = 13; $r }

[23:21] <evalbotzy> Error: Undeclared variable: "$r" 

[23:22] <putter> huh?!?

[23:24] <iblech> ?eval do { 1; my $r = 13; $r }

[23:24] <evalbotzy> \13 

[23:24] <iblech> Ah, maybe because of the special treatment of do STMT

[23:24] <putter> thanks! :)

[23:25] <putter> ?eval (sub() returns Int {12}())  # so dont need this

[23:25] <evalbotzy> Error:  unexpected "r" expecting block 

[23:25] <netstar_> Does anyone have any idea when Perl 6 will be ready?

[23:25] <xinming> netstar_: What do you mean for "perl 6" exactly? :-)

[23:26] <netstar_> perl6 even

[23:26] <iblech> and what do you mean by "ready" exactly? :)

[23:26] <xinming> netstar_: If you mean the whole perl 6... As nothingmuch ever told me. It is now only 15% completed.

[23:27] <iblech> There exist many working Perl 6 modules today

[23:27] <xinming> netstar_: If you mean only the language "grammar" and you wish to try to program in perl 6, Then pugs is for you.

[23:27] <xinming> netstar_: It covers many aspects of perl 6 "specification".

[23:27] <netstar_> cool

[23:28] <xinming> BTW, if something I said wrong. Please told me.

[23:29] <putter> iblech: shall I create a t/pugsbug?

[23:29] <putter> (re do{})

[23:29] <iblech> please do :)

[23:29] <putter> ok

[23:30] <iblech> BTW, I got coro almost working in PIL2JS :)

[23:30] <iblech> But need to sleep soon

[23:30] <putter> soo... the combination of macros and Prelude and broken type inference still has me stuck (vis trying to get Rul working and rules unstuck)

[23:31] <iblech> :(

[23:32] <putter> what are all the ways to say something has a type?  cant do return value on an anon sub.  macro expanding "do{1; my Rul $r = ...; $r}" doesnt help.  "foo(...)" where foo is returns Rul, even if foo is defined in- or post-Prelude, doesnt help.  other ideas?

[23:33] <iblech> a Rul $r

[23:33] <iblech> but "a" is not yet implemented yet

[23:33] <putter> ;)

[23:34] <xinming> how do slurp in perl 6? hmm, I mean if there is already a interal function handle this.

[23:34] <iblech> slurp "filename"

[23:35] * putter wonders if it would have been easier to implement macro quote:foo, that this attempted hook to Prelude.  weary sigh.

[23:35] <iblech> slurp $filehandle works too, IIRC

[23:35] <putter> s/that/than/

[23:35] <xinming> what it will return? a file handle?

[23:35] <xinming> or a Str

[23:37] <iblech> Str

[23:37] <xinming> iblech: thanks.

[23:37] <iblech> (slurp works in Pugs, BTW)

[23:39] <putter> iblech: any last give-type-type-inferencer-a-hand thoughts?

[23:39] <iblech> putter: No, sorry :(

[23:39] <putter> ok.  my thanks. :/

[23:41] <svnbot6> r6386 | iblech++ | PIL2JS: coro almost working.

[23:41] <iblech> Need to sleep now, night all :)

[23:44] <putter> 'night iblech.  thanks again.

[23:48] <putter> night all &

