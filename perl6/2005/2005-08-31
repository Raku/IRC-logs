[00:00] <putter> new Perl/Compiler/PIL.hs

[00:00] <putter> should just be even simpler than the data section of src/Pugs/PIL1.hs.

[00:01] <putter> but with only macros, you have to pack and unpack everything (fields, their types, any comments).

[00:01] <putter> it becomes easier just to emit raw code, and force hand global editing of the file every time someone makes a change.  blech.

[00:02] <putter> what would be utterly trivial for a source filter, and result in clean, very readable code, is just too painful with only macros. :/

[00:04] <putter> err/emit raw/write raw/

[00:06] * putter 's #1 reason for using source filters - so the spec is the program.

[00:08] <geoffb> That's one of my reasons for doing so . . . another is that I can cut all of the boilerplate out and write only "interesting" bytes, and let the source filter fill in all the crap

[00:09] <geoffb> And then of course there's so I can do s/method\s+(\w+)\s*{/sub $1 { my \$self = shift;/g . . . .

[00:09] <geoffb> (in my poor Perl 5 code)

[00:10] <putter> hmm... macros vs filters, macros require the arguments to parsable, whereas filters can use free regexs to snarf them.  for templates, what do filters get you that macros dont?   <putter frowns in thought>

[00:10] <NightShadow> hey

[00:10] <Khisanth> mmm action at a distance?

[00:10] <NightShadow> anyone here ever use the Number::Phone mod?

[00:10] <Khisanth> why are you taking surveys all over the place?

[00:11] <putter> NightShadow: I dont think perl6 has one yet.  Perhaps you're looking for #perl ? ;)

[00:11] <NightShadow> ah

[00:11] <NightShadow> sry

[00:11] <putter> np

[00:11] <NightShadow> so hard to find a example of it

[00:11] <putter> oh, I should have suggested the cpan rating system be checked.  oh well.

[00:13] <geoffb> putter, Khisanth: for example, I have a source filter that allows me to write a pretty-printed call graph, and have that turned into a deeply nested stack of method definitions.  Filters are necessary to allow the call graph pretty printing and indentation to define things.  The call graph spec also has macros layered on top, so I get macros implemented by the filter.  :-)

[00:13] <putter> the other approach to all this being "make everything an s-expression, and define macros/functions" to make it executable.  hmm...

[00:14] <putter> yeah, indentation-based semantics implies source filter.

[00:14] <putter> or a new macro whitespace:< > ;)

[00:14] <geoffb> When I'm looking for visual clarity, the mere overhead of parens is more than I want, even if I was making something that is semantically s-expressions

[00:15] <geoffb> putter, but outdenting means as much as indenting.  :-)

[00:15] <putter> macro foo()  foo( use YAML; .... ) 

[00:17] <geoffb> Actually, I think this is something the LISP bigots just don't get:  Yes, being able to wrangle the AST is great.  What if I don't actually want to write an AST as input?  (Sure, this is doable -- I meant, why isn't this *easy*?)

[00:17] <putter> so, there are string macros, pil macros, and source filters.  it could also be nice to have a lispy get tree-but-not-pil macro.  with s-exp and yaml being candidate trees.

[00:18] <geoffb> putter, nodnod

[00:20] <putter> which I guess is just a string macro foo  called as foo(q:yaml/..../) ... no then you need to run yaml twice, once to parse out the argument, and once in the macro to get a tree from it.

[00:21] <putter> so a normal data macro foo(), with q:yaml/.../ returning the data tree form.

[00:21] <Khisanth> hmm so when has been said and done nobody will be able to read perl6 in a reasonable amount of time? :)

[00:22] <putter> I think perl coding standards are going to be a really big thing.

[00:23] <putter> In the extreme, some companies may say, "yes, you can use p6, and all your files must begin with  use Python; ". :)

[00:23] <geoffb> Personally, I think cool technology just sets a high bar for the user of said tech -- if you want to use something really cool and unusual, you better do something cool with it

[00:23] <geoffb> heh

[00:26] <putter> There are costs to features and design flexibility.  I'd be quite happy if some of the cpan code I've seen were written in a use Python.  Just to shrink potential design space to something the author can wield more skillfully.

[00:26] <Khisanth> I am all for being able to do those things :)

[00:26] <geoffb> ?eval my $foo = '+bar'; $foo ~~ rx:perl5/^\+/ ?? "plus" :: "other"

[00:26] <evalbot6> 'plus' 

[00:26] <geoffb> ?eval $?VERSION

[00:26] <evalbot6> Error: Undeclared variable: "$?VERSION" 

[00:26] *** skylan_ is now known as skylan

[00:26] <Khisanth> I am just against people casually using that particular feature :)

[00:26] <putter> which feature...?

[00:27] <geoffb> ?eval $?PUGS_VERSION

[00:27] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6378)' 

[00:27] <geoffb> Who is hosting evalbot6 these days?

[00:27] <putter> ?eval $?PUGS_HACK_BACKEND

[00:27] <evalbot6> Error: Undeclared variable: "$?PUGS_HACK_BACKEND" 

[00:28] <putter> dont know

[00:28] <geoffb> Do either of you have a recent pugs build?  Can you test the rx eval I did above?

[00:29] <Khisanth> well judging from the earlier statements, probably luqui

[00:29] <geoffb> luqui, ping

[00:29] <putter> testing...

[00:30] <Khisanth> my version is older than the bot

[00:30] <putter> 'plus' ... were you expecting something else?

[00:30] <geoffb> I get: *** No compatible subroutine found: "&rx_"

[00:30] <geoffb>     at <interactive> line 1, column 19-61

[00:30] <putter> that sounds like you're missing Prelude.pm.

[00:30] <geoffb> I've got P5 embedding on, and all other build opts off

[00:30] <geoffb> interesting!  So lack of PCP is killing me?

[00:31] <putter> yes.

[00:31] <geoffb> BAH

[00:31] <geoffb> BAH BAH BAH BAH BAH

[00:31] <putter> :(

[00:31] <geoffb> OK, time to actually start specing components for a replacement dev box

[00:31] <geoffb> One that I can add RAM to . . . 

[00:32] <geoffb> .oO( Should I spec 2 GB or 4 GB ? )

[00:32] <putter> hmm...  putter can think of workarounds, but....

[00:33] <geoffb> Can't wait to explain to $spouse that we will have yet *another* month with a major cash outlay.  :-/

[00:33] <putter> geoffb: if you take src/perl6/Prelude.pm, copy out &rx_ and friends, change &rx_ &m_ and &barerx_ to from macros to subs, then you should be able to load the resulting file at runtime and get rx support that way.

[00:34] * geoffb goes to look at above file

[00:35] <putter> hey, how about a  macro macro_or_sub () { ...err... $am_at_compiletime ?? "macro" :: "sub" }

[00:35] <geoffb> Sounds vaguely Forthish

[00:36] <putter> ;)

[00:36] <putter> macro_or_sub rx_ ...

[00:37] <putter> I'm pretty sure a  $am_at_compiletime predicate exists, or at least is specced, but I cant think of it at the moment.

[00:38] <geoffb> What are 'is safe' and 'is unsafe'?  Tainting?  Or something about having side effects?  Or ... ?

[00:38] <putter> evalbot

[00:38] <geoffb> oh, gotcha

[00:38] <geoffb> Should say that in the header./

[00:38] <geoffb> Right, I have the commiter bit.

[00:38] <putter> lol :)

[00:38] * geoffb going to edit Prelude while in there.

[00:39] <putter> my fuzzy recollection is unsafe things dont make it into the symbol table when... mumble safe.

[00:40] <putter> comments in the evalbot source maybe.

[00:41] *** jiing_2 is now known as jiing_

[01:04] <geoffb> putter, OK, I've read through Prelude.pm (interesting stuff there) . . . which begs the question, where is /.../ turned into rx_, m_, and rxbare_?

[01:05] <geoffb> And is there any reason other than efficiency that you declared them as macros instead of subs?

[01:07] <putter> ahh...

[01:10] <putter> re why, because p6 cant yet parse  foo:bar/hee/   so the parser has to do it.  it parses, runs possiblyApplyMacro (or somesuch) of &rx_ etal, which then reach back in with pugs_internals_rx (or somesuch).  It would be native p6 is you could do it.

[01:10] <putter> re macros, ...

[01:11] <putter> oh, variables and such.

[01:12] <geoffb> Speaking of parsers, I didn't grok much of that -- and I think it's because I parsefailed.

[01:12] <putter> its not going to work quite correctly as a sub.  actually, in addidtion to any macro_or_sub hack, inside you'd have to eval() the code string.

[01:12] <putter> which would obviously be in your env, rather than your callers.

[01:13] <geoffb> (Sounds like a second (100th?) call for eval_in_caller_context)

[01:13] <putter> ;)

[01:14] <geoffb> OK, so let me try to understand you:

[01:14] <putter> I've always liked tcl's ability to reach up the stack and inject things. well, almost always.

[01:14] <svnbot6> r6599 | geoffb++ | Clarify and clean up comments at top of Prelude.pm

[01:15] <geoffb> Since we have no Parser written in Perl 6, pugs is parsing foo:bar/hee/ in Haskell code and turning it into things that look like function calls.

[01:15] <putter>  pugs_internals_rx is the "real" rx.  parser, when it sees rx//, calls rx in an odd mode - if it's a macro, run it now, else treat it as a normal sub call.

[01:15] <putter> err, calls &rx_

[01:15] <geoffb> But really they are macro calls, because we want lexical caller context to be correct.

[01:16] <putter> yes

[01:16] <geoffb> right, OK, I think I'm with you.

[01:17] <geoffb> Is this magic happening in src/Pugs/Parser.hs?

[01:18] <putter> geoffb: "Since we have no Parser"... almost, but not quite.  foo:bar /hee/  currently can be written in p6.  just foo:bar/hee/ , no space, cant. :(  if not for that space, the parser hook out to &rx_ would go away, and macro &rx_ would be renamed macro rx.

[01:18] * geoffb blinks

[01:19] <geoffb> More detail, please

[01:19] <putter> (though it would still be a bit of a kludge.  the parser would still parse the / / as a regex, and macro rx would ask it for its pattern, and then throw it away and just use the pattern as currently)

[01:20] <putter> there currently being no way to write quoting constructs.  macro quote:<z>  or whatever it is.

[01:20] <geoffb> gotcha

[01:20] <geoffb> OK, must AFK, toddler awakes

[01:21] <putter> foo:bar /hee/  gets parsed as a call to (macro or sub) foo, with adverb :bar, and one positional argument, a regex /hee/.  foo could then ask /hee/.pattern, getting "hee", throw away the object, and proceed.

[01:21] <putter> ok.  &

[01:23] <putter> some issues with syntax errors on //.  eg, foo:perl5 /hee/  where hee is something legal in p5 regexs, but not in p6.  sigh.  thus the current hack.

[01:24] <putter> but the error problem could be dealt with.  next step down this path would be getting foo:bar/hee/ to work.

[01:24] <putter> but as you say, it would still need to be a macro.

[01:32] <brentdax> ?eval hash {}

[01:32] <evalbot6> Error: cannot cast from VUndef to Handle (VHandle) 

[01:33] <autrijus> ?eval hash ()

[01:33] <evalbot6> Error: cannot cast from VUndef to Handle (VHandle) 

[01:33] <autrijus> ?eval (hash ())

[01:33] <evalbot6> Error: cannot cast from VUndef to Handle (VHandle) 

[01:33] <autrijus> ?eval hash 1,2

[01:33] <evalbot6> {('1' => 2)} 

[01:33] <autrijus> ?eval hash()

[01:33] <evalbot6> {} 

[01:40] <putter> sigh.  this parsefails:

[01:40] <putter> sub f () { my $s = "class { "; my @a=(); for @a -> $n { say $n; }

[01:40] <putter> #    $code ~= "}\n";

[01:40] <putter> } f;

[01:41] <autrijus> { inside double quote is interpolated

[01:41] <putter> but remove the comment, and it's fine.  sigh.

[01:41] <putter> oy.  bitten by that one again.  :/  thanks autrijus.

[01:41] <autrijus> np. :)

[01:42] * putter tries to think of some way a warning could be generated...

[01:48] <revdiablo> putter: almost makes you want a  use warnings 'p5transition';

[01:54] <putter> ;)

[01:55] <putter> I'm being repeatedly caught by it.  Though I guest the average user is less likely to be using strings with {.

[01:55] <putter> s/guest/guess/   irc reveals so many things about how ones mind works.

[01:57] <putter> Is there anyway to have barewords without predeclaring them or using pairs?

[01:58] <autrijus> don't think so

[01:58] <buu> ?eval "{{1}}"

[01:58] <evalbot6> '{1}' 

[01:59] <putter> ah well.  thanks!  Tufte would not be happy with me.  (lots of wasted ink)

[01:59] <buu> So is that a literal string containing {1} ?

[02:00] <autrijus> ?eval "{ {1} }"

[02:00] <evalbot6> '1' 

[02:00] <autrijus> I think it's two bugs :)

[02:00] <autrijus> ?eval "{ {want} }"

[02:00] <evalbot6> 'Scalar (Any), LValue' 

[02:00] <autrijus> ?eval "{ {say want} }"

[02:00] <evalbot6> Scalar (Any), LValue '1' 

[02:06] <buu> Fascinating.

[02:15] <buu> Anyone know what happens with, {say $^bbb; say eval '$^'.chr(rand(255)) } ?

[02:16] <putter> ?eval macro f($x) { "class $x \{};" }  f("C");  C.new

[02:16] <evalbot6> Error: No compatible subroutine found: "&C" 

[02:16] <putter> :(

[02:22] <putter> ?eval say ({say $^bbb; say eval '$^'.chr(rand(255)) })("hi")

[02:22] <evalbot6> hi Error: No compatible subroutine found: "&chr" 

[02:22] <putter> chr is being called with two arguments.

[02:26] <geoffb> buu, did you mean to do '$^' ~ chr(rand(255)) ?

[02:41] <buu> geoffb: Yes.

[02:42] <buu> ?eval say ({say $^bbb; say eval '$^'~chr(rand(255)) })("hi")

[02:42] <evalbot6> hi  1 bool::true 

[02:42] <buu> ?eval say ({say $^bbb; say eval '$^'~chr(rand(255)) })("foo","bar")

[02:42] <evalbot6> foo  1 bool::true 

[02:42] <buu> Color me confused.

[02:43] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); $x.ref

[02:43] <evalbot6> ::Str 

[02:43] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); $x.perl

[02:43] <evalbot6> '\\\'foobar\'' 

[02:44] <brentdax> Hmm.

[02:44] <brentdax> Does substr() return a string or a reference to a string?

[02:45] <brentdax> Because somehow I think I'm getting a reference to a string, and it's not working out very well.

[02:47] <buu> Why are you calling $x.ref ?

[02:47] <brentdax> Because I don't know what else to call.

[02:48] <brentdax> ...wait, good point.

[02:48] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); $s.ref

[02:48] <evalbot6> ::Str 

[02:48] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); $s.perl

[02:48] <evalbot6> '\\\\\'foo\'' 

[02:48] <brentdax> Ah, there.

[02:48] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); $$s.perl

[02:48] <evalbot6> '\\\\\'foo\'' 

[02:49] <buu> I think it needs a few more slashes

[02:49] <buu> \\\\\\\\\\\\\\\\\\\\\'foo'

[02:49] <brentdax> ?eval my $x = 'foobar'; my $s = $x.substr(0,3); ${$s}.perl

[02:49] <evalbot6> '\\\\\'foo\'' 

[02:49] <brentdax> Heh.

[02:49] <brentdax> ?eval my $x = 'foobar'; my $s = ~$x.substr(0,3); $s.perl

[02:49] <evalbot6> '\\\'foo\'' 

[02:50] <brentdax> Not gonna ask...

[03:26] <svnbot6> r6600 | putter++ | Perl/Compiler/PIL/Node_pm_gen.pl:  Beginning of a full set of PIL notes for p6.  Hopefully it will eventually obsolete the current Perl/Compiler/PIL.pm.

[03:30] <putter> sigh.  s/notes/nodes/

[03:34] <putter> Node_pm_gen.pl is still rough.  I didnt get to the point of eating -CPerl5.   I'll likely be offline Wed and Thurs, but hope to get back to it on Friday.

[03:49] <putter> Actually, reality check.  Bad time of day to ask, but...

[03:52] <putter> Is pushing on a p6-based PIL infrastructure the wrong thing at this point?  Ie, would p5-based be better?  p5 would run faster, and development would be much faster.  a p6-based emitter would be a nontrivial oo p6 program.  thus something it might be best to wait on.  any comments, thoughts?

[03:54] <putter> Using one of the Class::MultiMethod packages, one could probably even write the p5 version in the architectural style of a p6 one.  thus serving as a prototype.

[03:54] <putter> then again, we already have PIL2JS as a prototype.

[07:09] * luqui thinks he has the perl 6 way of solving the expression problem

[07:09] <autrijus> MMD?

[07:09] <autrijus> that's well worth a docs/notes/ writeup :)

[07:09] <luqui> eh, it relates to something like that

[07:10] <autrijus> do tell more

[07:10] <luqui> it's basically Scala's way, but it gives names to the concepts (taken from model theory)

[07:10] <luqui> those concepts turn out to be widely applicable

[07:10] <luqui> basically "multi roles" (not in their parameterizations, but in their methods)

[07:11] <luqui> a model is data+implementation (like a multi class)

[07:11] <luqui> a theory (which needs a better name) is interface (like a multi role)

[07:12] <luqui> theories can be composed; models can be extended

[07:12] <luqui> but I'd like to write it up first to get my terminology and thinking clear and consistent

[07:17] <autrijus> cool

[07:17] <autrijus> that may lead to more visiolization and t-shirts :)

[07:36] <luqui> er, how do you write comments in Scala?

[07:37] <luqui> ahh, looks like C++

[07:47] * nothingmuch had mango for breakfast

[07:47] <nothingmuch> i like having good fruits and veggies at work

[07:50] <Aankhen``> Build is still broken on Windows?

[07:52] <autrijus> I wasn't aware that it is

[07:52] <autrijus> how is it broken?

[07:52] <autrijus> hm, that one-line change of yesterday caused 200+ subtests to unexpectedly pass

[07:53] <pasteling> "Aankhen``" at 61.246.21.131 pasted "Build fails on Win32" (16 lines, 689B) at http://sial.org/pbot/12838

[07:55] <autrijus> weird. it's a recent failure?

[07:55] <autrijus> I'll boot to win32 to take a look in a bit

[07:55] <Aankhen``> I dunno; I was out of town for 9 days, came back and found that.

[07:55] <Aankhen``> (i.e. I discovered it on the 28th)

[07:56] <autrijus> ok.

[07:58] <svnbot6> r6604 | autrijus++ | * lots of unTODOs thanks to nested structures finally working fully

[07:59] <brentdax> "nested structures finally working fully" means what?  Arrays of hashes of arrays (and such) will have sane behavior?

[08:02] <autrijus> yeah.

[08:02] <autrijus> it used to be that [[0]] will cause the inner [0] to have const sclar container

[08:02] <autrijus> so

[08:02] <autrijus> [[0]][0] = 1

[08:02] <autrijus> will fail

[08:03] <brentdax> That sounds like very familiar behavior...

[08:06] <nothingmuch> % perl -e '[[0]]->[0] = 1'; echo $?

[08:06] <nothingmuch> 0

[08:06] <nothingmuch> i wouldn't expect it, actually

[08:06] <nothingmuch> [] creates an array reference

[08:07] <nothingmuch> an anonymous array

[08:07] <autrijus> it is nevertheless the case.

[08:07] <nothingmuch> it's like saying '${ do { my $x; \$x} } = 10' 

[08:07] <autrijus> ?eval [[0]][0][0] = 10

[08:07] <evalbot_6589> Error: Can't modify constant item: VInt 0 

[08:07] <nothingmuch> it's an anonymous scalar since it ceases to exist by the time it's used

[08:07] <nothingmuch> i don't see why that should happen

[08:07] <autrijus> that's before the bugfix.

[08:08] <nothingmuch> oh

[08:08] <autrijus> ?eval [[0]][0][0] = 10

[08:08] <evalbot_6589> Error: Can't modify constant item: VInt 0 

[08:08] <evalbot6> Error: Can't modify constant item: VInt 0 

[08:08] <autrijus> hrm

[08:08] <autrijus> feather's autobuild isn't up to date?

[08:08] <nothingmuch> maybe it's lagging

[08:08] <autrijus> as of r6604:

[08:08] <autrijus> pugs> [[0]][0][0] = 10

[08:08] <autrijus> 10

[08:10] <nothingmuch> =)

[08:10] <nothingmuch> woo! our company wiki is picking up

[08:14] * luqui updated evalbot_xxxx

[08:14] <svnbot6> r6605 | autrijus++ | * more nested data structure unTODOing.

[08:14] <luqui> s/updated/updates/

[08:20] <svnbot6> r6606 | autrijus++ | * num.t fixes.  I'm not sure `0101` is to be parsed as `101` --

[08:20] <svnbot6> r6606 | autrijus++ |   $Larry ruled that it should raise exception saying that `0o101`

[08:20] <svnbot6> r6606 | autrijus++ |   is the correct way now.

[08:26] <svnbot6> r6607 | autrijus++ | * stub implementation of builtin infix:eqv

[08:41] <landover> hello all

[08:45] <autrijus> landover: greetings.

[08:46] <landover> ah

[08:46] <autrijus> Aankhen``: I'm building on win32... so far so good

[08:46] <landover> good good

[08:46] <landover> i saw your video

[08:46] <landover> that was very entertaining

[08:46] <autrijus> the oscon05 one? I'm glad you like it :)

[08:46] <landover> yes i was extremely amused

[08:46] <landover> so how are things over there?

[08:47] <landover> im in washington DC

[08:47] <autrijus> a large typhoon is approaching right now; crazy sound FX effects

[08:47] <landover> hah

[08:47] <landover> so how did you manage to get into writing compilers i believe your a year younger than me

[08:47] <broquaint> Where might the OSCON '05 video be found?

[08:52] <autrijus> broquaint: http://pugscode.org/

[08:52] <autrijus> "oscon movies" to the left

[08:52] <autrijus> ?eval [[0]][0][0] = 1

[08:52] <evalbot_6600> \1 

[08:52] <evalbot6> Error: Can't modify constant item: VInt 0 

[08:52] <broquaint> Aha, thanks, autrijus :)

[08:53] <luqui> oops

[08:53] <luqui> are evalbot and svnbot the same thing?

[08:53] <luqui> hmm.. I doubt it

[08:53] <autrijus> nope

[08:53] <luqui> is it just a coincidince that I told evalbot6 to quit and then svnbot6 did too

[08:54] <landover> duh

[08:54] <autrijus> I think I ^C'ed the wrong thing

[08:54] <landover> obviously at 4:53 am i am worthless

[08:54] <autrijus> landover: a certain book called TaPL will make a compiler write out of anyone :)

[08:54] <luqui> landover: I do not like green eggs and am

[08:54] <autrijus> http://www.cis.upenn.edu/~bcpierce/tapl/ 

[08:55] <autrijus> s/write/writer/

[08:55] <landover> reading...thinking of buying etc

[08:57] <GeJ> landover: autrijus' age has nothing to do with anything. The guy sleeps 12seconds per day, and even then, his brain is talking Haskell... that makes him around... hum... 63 years old (on a normal earthling scale)

[08:57] <autrijus> landover: additional list of books may be found at http://svn.openfoundry.org/pugs/READTHEM

[08:57] * nothingmuch agrees with GeJ 

[08:57] <autrijus> oh, and an upcoming oreillynet interview -- the second half may be more interesting:

[08:57] <autrijus> http://autrijus.org/tmp/edd_interview.html

[08:57] <autrijus> the first half is done when edd and I still thought I'm going to talk about PerlI18N

[08:58] <autrijus> Aankhen``: sadly win32 builds just fine here.

[08:59] <autrijus> Aankhen``: is it possible that your PATH has strange things like cygwin stuff in it?

[08:59] <landover> is there anything you need autrijus outside of the computer?

[08:59] <autrijus> landover: network

[08:59] <autrijus> electricity

[08:59] <autrijus> that's about it

[08:59] <landover> well im in here often if you need anything or even donations for money let me know

[09:00] <landover> out of my pocket of course

[09:00] <autrijus> if you feel like donating, the T-shirts in http://www.cafepress.com/pugscode may be of interest :)

[09:00] <landover> one quick question

[09:00] <landover> i wont waste any more of your time

[09:00] <landover> and i know i am going to get reamed by everyone here

[09:00] <landover> but

[09:00] <landover> have you ever played with smalltalk?

[09:01] <autrijus> yes, I played with Squeak for Seaside

[09:01] <autrijus> by no means proficient though

[09:02] <landover> when you have a minute some day book mark this http://www.opencroquet.org

[09:03] <landover> ok i need to go read pugs... let me know if you need anything

[09:03] <autrijus> I think I've seen the demo of it in LinuxTag

[09:03] <landover> well when 2 people can code in realtime....and literally build a house

[09:04] <landover> anyways

[09:04] <autrijus> like Kay's other works it looks amazingly cool and approchable

[09:04] <landover> well he wont be able to do it though...its smalltalk....

[09:04] <autrijus> mm?

[09:04] <landover> but the concept is what i wanted to embed deep in the back of your brain

[09:04] <autrijus> oh. sure. it's already there :)

[09:04] <autrijus> but thanks for the link.

[09:04] <landover> np

[09:05] <obra> scratch looks very pretty.

[09:05] <obra> it's derived from opencroquet, no?

[09:05] <autrijus> er, scratch the weblog system?

[09:06] * autrijus is having context mismatch

[09:06] <autrijus> oh, obra, sorry I misremembered the time and didn't attend parrotsketch on Tuesday. how did it go?

[09:07] <obra> autrijus: I was packing for braga. chromatic reported that it was productive

[09:07] <obra> no, scratch the programming environment for kids

[09:07] <obra> part of the $100 media lab pc

[09:07] <obra> s/pc/laptop/

[09:07] <obra> looks like logo, with more drag and drop lego-programming.

[09:07] <obra> turns out it's smalltalk, not scheme

[09:07] <luqui> my model theory model is working out so well!

[09:08] <luqui> better than Scala :-)

[09:08] <autrijus> obra: oh. 3d?

[09:08] <autrijus> luqui: good! time to submit paper to OOPSLA! :)

[09:08] <autrijus> luqui: better how, though?

[09:09] <luqui> do you have that paper you showed me about scala's technique for solving the exp problem?

[09:09] <autrijus> sure

[09:09] <luqui> look on the right column of page 5

[09:10] <autrijus> trait DblePlusNeg ?

[09:10] <luqui> you have to respecify all constructors in the tree

[09:10] <luqui> because they might not return something that is the new exp anymore

[09:11] <luqui> since the new exp is a subtype of the exp they used to refer to

[09:11] <autrijus> yes.

[09:11] <luqui> well, trees like this belong in data construtors

[09:11] <autrijus> it's a variant of the variance problem

[09:11] <luqui> so when you extend a model, you "Extend" the union type

[09:11] <luqui> that is, you make the set *bigger*, not smaller

[09:12] <luqui> so you have to specify more variants on your processing methods (as we expect)

[09:12] <luqui> but it follows that whatever your old processors returned will be okay in the new model

[09:12] <autrijus> hm, it reminds me of ocaml variant types

[09:12] <autrijus> please go on

[09:13] <luqui> well, that's about it.  you don't retype anything existent

[09:13] <autrijus> variant types: http://caml.inria.fr/pub/docs/u3-ocaml/ocaml051.html

[09:13] <luqui> I'm filling in all the details in my writeup

[09:13] <luqui> okay, I'll look at those

[09:13] <autrijus> cool. looking forward to it

[09:23] *** nBakedBeas is now known as BakedB

[09:41] <nothingmuch> ... "power adapter is a beautifully designed product featuring the latest technologies in charging"

[09:41] <nothingmuch> $49.99

[09:41] <nothingmuch> i wonder if people are really that guillible

[09:41] <broquaint> $49.99 for a power adapter? What a bargain!

[09:41] <nothingmuch> at least it's got a plug adapter set

[09:42] <nothingmuch> no wait! buy now and get $5 off!

[09:42] <nothingmuch> and it's got an "Inbuilt cable with USB connector"

[09:42] <broquaint> I'm saving money buy spending money!

[09:43] <nothingmuch> i bought my friend an ipod shuffle for his birthday, and his computer had low power ports

[09:43] <nothingmuch> then we bought an el-cheapo USB card

[09:43] <nothingmuch> it didn't work either...

[09:46] <broquaint> The harroth docs are interesting, nothingmuch.

[09:46] <landover> where can i ask some pugs questions?

[09:47] <nothingmuch> broquaint: it's slowed down a lot

[09:47] <nothingmuch> now i'm working on harrorth about 2 hours a month

[09:47] <nothingmuch> i'm rewriting most of the forth stuff in forth at the moment

[09:47] <nothingmuch> the dictionary handling code

[09:47] <nothingmuch> the word definition words

[09:47] <nothingmuch> then the runtime will simply by an intmap

[09:48] <nothingmuch> and two stacks of integers

[09:48] <broquaint> Sweet. It'll be cool to have a forth implementation for parrot.

[09:48] <nothingmuch> there is one, actually

[09:48] <broquaint> This is the best place to ask about pugs, landover.

[09:48] <nothingmuch> harrorth is nowhere near parrot yet

[09:49] <broquaint> Isn't that one a bit broken?

[09:49] <nothingmuch> but the parrot forth project does exist

[09:49] <nothingmuch> i think it is, but at least it's something =)

[09:49] <nothingmuch> do you know parrot?

[09:49] <nothingmuch> because leo was looking for a maintainer

[09:49] <broquaint> Well he's ok I guess, but we've never really spoken to one another.

[09:49] <broquaint> So, no, I don't really know parrot all that well.

[09:50] <landover> always good time to learn

[09:50] <nothingmuch> well, if you do, and you're still interested in forth, don't forget to ping leo =)

[09:50] <landover> pugs types ? optional

[09:50] <broquaint> Will do :) And I should probably remember how to program forth too ...

[09:50] <nothingmuch> landover: huh?

[09:51] <nothingmuch> broquaint: http://feather.perl6.nl/~nothingmuch/harrorth/misc/Forth/lib/Forth/Interp.pm

[09:51] <nothingmuch> there is a 3 stage bootstrap

[09:51] <landover> sub add (Str $a, Str $b) { } are the type declarations optional?

[09:51] <nothingmuch> first the primitives are defined... these are implemented in perl

[09:51] <nothingmuch> then the bootstrap forth code is parsed by perl

[09:51] <nothingmuch> and dependencies are resolved

[09:51] <nothingmuch> this is compiled using perl code

[09:52] <nothingmuch> and then the buffer is set to the "soft" prelude, which is just executed

[09:52] <nothingmuch> the test suite is lots of fun: http://feather.perl6.nl/~nothingmuch/harrorth/misc/Forth/t/

[09:52] <nothingmuch> since I run it against gforth when I'm writing tests, and then I run the passing tests on my forth when I'm writing my forth impl: http://feather.perl6.nl/~nothingmuch/harrorth/misc/Forth/cmp_forths.sh

[09:53] <nothingmuch> http://feather.perl6.nl/~nothingmuch/harrorth/misc/Forth/t/lib/Forth/Interp/Test.pm

[09:53] <nothingmuch> (based off ingy's Test::Base)

[09:55] <clkao> gah!

[09:56] <clkao> is currying for classes implmemented?

[09:56] <nothingmuch> currying for classes?

[09:56] <clkao> larry aws talking about it just now

[09:56] <nothingmuch> $obj.can("method").assuming($obj) ?

[09:56] * nothingmuch reads mail

[09:56] * nothingmuch sees no new mail

[09:56] <clkao> in yapceurope

[09:56] <clkao> he is giving keynotes

[09:57] <broquaint> That's some nice work there, nothingmuch :)

[09:57] <nothingmuch> oh

[09:58] <nothingmuch> broquaint: what I really hope will be interesting is writing a generic stack->register optimizer in haskell

[09:58] <nothingmuch> by mapping TOS into the register window, you can eliminate most simple stack operations

[09:58] <nothingmuch> if you simply inline your called code so that it's compiled such that the stack positions it expects are mapped to the registers the data is already in

[09:59] <nothingmuch> for example, you see ': , here swap ! ;'

[09:59] <nothingmuch> '10 ,'

[10:00] <nothingmuch> this should be load 10 into register, load here pointer into other register, and then compile a version of ! that writes the data from one register into the address in another register

[10:02] <nothingmuch> this is instead of: push 10, bsr ',', bsr here, push here addr, bsr read, pop address, push value, return, return, bsr swap, pop into reg a, pop into reg b, push reg a, push reg b, return, bsr '!', pop reg a, pop reg b, write value from reg into address in other reg

[10:02] <nothingmuch> return return

[10:03] <broquaint> Sounds interesting and mind-warping.

[10:04] <nothingmuch> all i need is to get a round tuit

[10:05] <nothingmuch> http://www.myrtlewoodgallery.com/get_a_round_tuit.htm (not as nice as the perl foundation's ones)

[10:06] <broquaint> Delegate to an eager PhD student or something.

[10:06] <nothingmuch> nono, this is mine!

[10:06] * nothingmuch *wants* to be an eager phd student ;-)

[10:07] <broquaint> What's stopping you?

[10:07] <landover> is it possible to save the state of all objects in the haskell runtime?

[10:07] <nothingmuch> broquaint: job, rennovation, social life, fatigue, hobbies

[10:08] <nothingmuch> WRT to fatigue i'm improving my sleep cycle

[10:08] <broquaint> Which will no longer be problems if you become a PhD student!

[10:08] <broquaint> Except the fatigue, that'll get worse.

[10:08] <nothingmuch> job won't be ;-)

[10:08] <broquaint> 'xactly!

[10:08] <nothingmuch> rennovation is temporary, but demanding

[10:08] <nothingmuch> both psychologically, and time wise

[10:29] <vkon> Juerd: regarding your question about what people are doing at feather; I use it mostly to get current snapshot, and for IRC from work, because our IP at work is filtered; this makes obtaining shapshot much easier; also, sometimes I do tests with pugs via ssh. Hope my isage is okay...

[10:30] <vkon> Juerd: ... so it is helping me very much. I almost do not use it from home, btw...

[10:30] <vkon> ?eval $?PUGS_VERSION

[10:30] <evalbot_6600> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005' 

[10:31] <vkon> ?eval 'a' ~~ /a/

[10:31] <evalbot_6600> Error: cannot cast from VUndef to Pugs.AST.Internals.VCode (VCode) 

[10:39] <Juerd> vkon: Sure, it's okay

[10:39] <Juerd> vkon: I'm just asking around to get a better view

[10:39] <Juerd> vkon: In fact, I wish it were used a little more, as it's mostly idling

[10:44] * nothingmuch forgot to read mail for 2 days

[10:44] <nothingmuch> work mail, that is 

[10:44] <nothingmuch> =/

[10:58] <luqui> Juerd: thanks a lot for feather

[10:59] <luqui> at home I don't have a stable ghc, and the server I normally use is down too much

[10:59] <luqui> I use it for all pugs development these days

[11:30] <autrijus> iblechbot: I submitted http://m19s28.vlinux.de/iblech/stuff/pugs-smokes/pugs-smoke-6.2.9-r0-freebsd-normal--1125487758-1657--9672-9458-214-1042-1385-6--6e7bdd9c4f4482ca7bd572b8f14d8aa0.html but it's marked as "r0"

[11:31] <autrijus> Aankhen``: rehi. I can't duplicate the build problem here on win32. :-/

[11:33] <Aankhen``> Hi.

[11:33] <Aankhen``> What's your build systeml?L

[11:33] <Aankhen``> s/L$//

[11:34] <Aankhen``> s/l\?/?/ too, come to think of it.

[11:34] <Juerd> luqui: You're welcome

[11:34] <autrijus> Aankhen``: WinXP, nmake

[11:34] <Aankhen``> autrijus: What compiler? MSVC? MinGW?

[11:34] <Aankhen``> Er.

[11:35] <Aankhen``> MSVC6 or 7?

[11:35] <autrijus> activeperl

[11:35] <autrijus> no MSVC involved -- nmake.exe straight off free download

[11:35] <Aankhen``> Ah, okay.

[11:35] <Aankhen``> What version of nmake, then?

[11:35] <autrijus> nmake15.exe

[11:35] <Aankhen``> That might be it...

[11:35] <Aankhen``> That's version 1.5, IIRC, and my version is 7.

[11:36] <autrijus> try nmake15 then? move nmake.exe off our path

[11:36] <autrijus> and run makefile.pl again

[11:42] <Aankhen``> I don't think I have 1.5...

[11:44] <autrijus> MAkefile.PL will download it for you

[11:44] <Aankhen``> Ah.

[11:44] <Aankhen``> One sec.

[11:44] <autrijus> http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/Nmake15.exe

[11:44] <Juerd> What is it with Windows people wanting to be elite enough to compile their own shit, but just not elite enough to actually run a good OS? :)

[11:44] <Aankhen``> Juerd: Practicality. :-)

[11:44] <Juerd> Aankhen``: You've been struggling for how long now? How practical is that?

[11:44] <Aankhen``> Very practical, since my life is not solely about Pugs.

[11:45] <Juerd> Heretic

[11:45] <Aankhen``> MWAHAHAHAHAHAHA

[11:45] * Aankhen`` chokes.

[11:45] <Aankhen``> When was the last time you played Splinter Cell: Chaos Theory on Linux? :-P

[11:46] <Juerd> Ever heard about dual booting? The possibility of running Linux under Windows? 

[11:46] <Aankhen``> Yes.

[11:46] <Juerd> Or an extra box? Or an account on feather?

[11:47] <Aankhen``> Extra box requires money.  Feather requires giving out my real name, last time I checked.

[11:47] <Juerd> That is true

[11:47] <Aankhen``> Dual booting is a pain in the neck.

[11:47] <Aankhen``> .

[11:47] <Juerd> Then there is still the running Linux under Windows thing

[11:47] <Juerd> Which can be free

[11:47] <Aankhen``> It sorta misses the whole point.

[11:47] <Aankhen``> But yeah, I guess it would solve the current problem.

[11:48] <Juerd> Aankhen``: www.colinux.org

[11:49] <Aankhen``> This is extremely ironic.

[11:49] <Aankhen``> That page has those little text ads which appear when you hover over the link.

[11:50] <Aankhen``> "operating system" in "why should another..." was linked.

[11:50] <Aankhen``> The ad is from Microsoft, about how Windows outperforms Linux.

[11:51] <Aankhen``> Hmmm... this coLinux thing looks neat.

[11:51] <Juerd> It's your key to leetness.

[11:51] <Aankhen``> AHH!  THE HORROR!  NOT LEETNESS!

[11:52] * Aankhen`` wonders how many $#@!ing copies of nmake.exe are installed by VS.

[11:52] <nothingmuch> Aankhen``: we use colinux at work, it's been pretty good

[11:53] <nothingmuch> it compiles and runs our binaries pretty fast, and pretty stably

[11:53] <Aankhen``> Ah, two are installed by VS.NET and one by the SDK.

[11:53] <Aankhen``> nothingmuch: So the performance hit isn't too bad?

[11:53] <nothingmuch> not at all... I'd estimate no more than %15-20

[11:53] <Aankhen``> Kewl.

[11:53] <nothingmuch> for the overall "feel"

[11:54] <nothingmuch> we also run the cygwin X server to access it

[11:54] <Aankhen``> autrijus: 1.5 bombs too.

[11:55] <autrijus> weird. :-/

[11:55] <autrijus> got a telnet or rdesktop login?

[11:55] <Aankhen``> No...

[11:55] <autrijus> grab CPAN's release version?

[11:56] <autrijus> I need to run + dinner in a bit. bbiab

[11:56] <Aankhen``> I have to go too.

[11:56] <Aankhen``> Gonna watch Sky High.

[11:56] <Aankhen``> Will try later.

[11:57] <autrijus> k.

[11:58] <Aankhen``> Gah... where is nmake downloaded to?

[11:59] <autrijus> perl/bin/

[11:59] <autrijus> same path as perl.exe

[11:59] <Aankhen``> Ah, okay.  Thanks.

[11:59] <Juerd> 13:56 < nothingmuch> not at all... I'd estimate no more than %15-20

[11:59] <Juerd> 20% performace?

[11:59] <Juerd> 20% performance?

[11:59] <Aankhen``> Performance hit.

[11:59] <Juerd> Oh :)

[12:00] <Juerd> Then it's pretty good

[12:00] <Aankhen``> Yep.

[12:00] <Aankhen``> Gotta try it out later.

[12:00] <Aankhen``> Anyway.

[12:00] <Aankhen``> See y'all.

[12:00] <Aankhen``> &

[12:00] <Juerd> Bye

[12:00] <Juerd> Have fun &ing

[12:11] <ycheng> why ((11, 12), 2, 3) is designed to be (11, 12, 2, 3) in perl ?

[12:12] <QtPlatypus> ycheng: Because perl flattens lists.

[12:12] <QtPlatypus> Are you asking about perl6 or perl5?

[12:12] <ycheng> so it's on purpose not to fallten array ? why we chose to design this way ?

[12:12] <ycheng> I test this in both perl6 and perl5

[12:13] <ycheng> the same result

[12:13] <QtPlatypus> ?eval ((11,13), 2, 3)

[12:13] <evalbot_6600> (11, 13, 2, 3) 

[12:13] <broquaint> Because lists are ethereal things in perl, ycheng.

[12:13] <QtPlatypus> It tends to be handy

[12:13] <broquaint> Parentheses in a list context merely delimit precedence.

[12:14] <ycheng> QtPlatypus: got it, thanks.

[12:14] <ycheng> ?eval ([1, 2], 33, 44)

[12:14] <evalbot_6600> ([1, 2], 33, 44) 

[12:14] <ycheng> ^^

[12:15] <broquaint> That's a list with an array in it ...

[12:15] <broquaint> Maybe someone should write pdecl ...

[12:15] <ycheng> ya, I know.

[12:15] <QtPlatypus> pdecl?

[12:15] <ycheng> what that ?

[12:15] <broquaint> Like cdecl but for perl.

[12:15] <ycheng> s/what/what's/

[12:16] <broquaint> http://linuxcommand.org/man_pages/cdecl1.html

[12:16] * broquaint & # Lunch.

[12:17] <nothingmuch> is anybody here a (gulp) tcsh user?

[12:21] <ycheng> broquaint: I think perl6 should give warning if someone write "@a = ((1,2),3 ,4)", but no warning as "@a = (1, 2); @b = (@a, 3, 4)"

[12:38] <ycheng> my @a, @b; / my $a, $b; / my %a, %b; all fail (Internal error while running expression: unexpected ",") (an known bug ?)

[12:47] <Juerd> ycheng: my (@a, @b)

[12:47] <Juerd> ycheng: In Perl 5 terms, my has ($) like precedence

[12:47] <Juerd> ycheng: So that you can do: foo(my $bar, $quux), where $quux is already in scope

[12:48] <Juerd> (Mostly handy for: bless \my $dummy, $class)

[12:51] <ycheng> you mean; in "my (@a, @b)", my like a function which got "@a" and "

[12:51] <ycheng> @b"

[12:52] <ycheng> good point that this make foo(my $a, $b) work.

[13:04] <iblech> autrijus: re smokeserv: Fixed.

[13:04] <iblech> putter: pong

[13:45] <putter> iblech: ping?

[13:45] <iblech> putter: pong

[13:45] <putter> hey.

[13:46] <putter> I was wondering how smoke when (putter hasnt upgraded perl yet)...

[13:46] <putter> s/when/went/

[13:46] <clkao> autrijus: your svk diagram is gone again?

[13:48] <iblech> putter: Haven't upgraded perl either, yet, and I had to ^C the smoke yesterday (I increased the max time a test may take ==> it ate my RAM and swap...)

[13:48] <putter> :(

[13:49] <putter> perl5.t is by far the largest test file...  while having it as a stress test is nice, one could rationalize breaking it in half or so...

[13:49] <iblech> Yes...

[13:50] <putter> so the perl alligator thing isnt something which can be worked around?  (I'm unclear on exactly what it is)

[13:52] <putter> hmmm... perhaps pugs needs a bundle... grep all the use XXX; from pugs... rather than an incremental "oops, that didnt work" process...

[13:53] <iblech> Currently, we do work around it ("$self;" does the trick), but I wasn't able to work around it in my attempt of substituting $possibly_ccify_many and $step by real subs and using pass-by-ref instead of copying

[13:54] <fglock> hi all

[13:55] <fglock> will it be possible to clone closures in Perl 6?

[13:55] <iblech> hi fglock :)

[13:55] <iblech> Yes, definitely

[13:55] <iblech> And serializing closures and continuations should work, too

[13:55] <fglock> cool - this makes much easier to clone lazy lists

[13:56] <iblech> putter: BTW, I implemented autovivication and fixed another small bug, should cause additional ~~150 tests to pass :)

[13:58] <putter> :) !

[13:59] <putter> Is there enough class stuff in pil to start hacking classes?

[14:01] <iblech> Looked into it, found at least one problem:

[14:02] <iblech> class Pair is reopened { method postcirumfix:<{}> {...} }  # does not emit the decl of &Pair::postcirumfix:<{}>

[14:05] <svnbot6> r6608 | fglock++ | * perl5/List - clone

[14:05] <svnbot6> r6609 | iblech++ | * util/smokeserv/smokeserv-server.pl: Increase maximum upload size, autrijus++

[14:05] <svnbot6> r6609 | iblech++ |   for noticing the bug.

[14:05] <svnbot6> r6609 | iblech++ | * t/data_types/num.t, t/syntax/parsing_numbers.t: Fixed a test, added more

[14:05] <svnbot6> r6609 | iblech++ |   tests to t/syntax/parsing_numbers.t.

[14:05] <svnbot6> r6609 | iblech++ | * t/data_types/mixed_multi_dimensional.t: Fixed a test (and pinged p6l).

[14:05] <svnbot6> r6609 | iblech++ | * PIL2JS:

[14:05] <svnbot6> r6609 | iblech++ |   * PIL2JS.js: (Hack) $^thing.isa(Code) ==> $^thing.isa(Sub), $^thing.isa(Block)

[14:05] <svnbot6> r6609 | iblech++ |   * Prelude::JS::Array: Stubbed &pair, needed to make { pair 1,2,3,4 } work.

[14:05] <svnbot6> r6609 | iblech++ |   * Prelude::JS::Hash: Hash autovification!

[14:05] <svnbot6> r6609 | iblech++ |   * Prelude::JS::Pair: $pair.value = ... works again, added $pair<key>.

[14:05] <iblech> restarting smoke...

[14:06] <iblech> errands &

[14:06] <putter> oh, &    I likely wont be around later.

[14:06] <fglock> re p5 runtime: does it make sense for p6 to have it's own namespace system (pads)

[14:07] <putter> fglock: And perhaps some  use() hack could suck them in to simpler names on a package by package basis...

[14:08] <putter> oh, that was a question...

[14:11] <fglock> Lazy lists need clonable closures - is there some hack to make this in p5?

[14:22] <broquaint> Sorta.

[14:22] <broquaint> Data::Dump::Streamer can do closures.

[14:22] <svnbot6> r6610 | Stevan++ | Perl6::MetaModel 2.0 -

[14:22] <svnbot6> r6610 | Stevan++ | * changed SELF() and CLASS() to be $::SELF and $::CLASS

[14:22] <svnbot6> r6610 | Stevan++ |    - $::CLASS is now bound within the closure form of 'class'

[14:22] <svnbot6> r6610 | Stevan++ | * added lots of error checking to chaos.pl

[14:26] <putter> fglock:  sorry, 4GB perl swapping.

[14:26] <fglock> putter: ?

[14:27] <putter> delay in response

[14:27] <putter> do you mean "p5 and p6 have distinct namespaces, where the same names can be used for different things", or

[14:28] <putter> "would a metamodel of the namespace be useful", or

[14:29] <putter> should "p6 package names not have a trivial map to p5 package names implementing them", or

[14:29] <putter> ...?

[14:29] <putter> ;)

[14:31] <putter> currently there is a 1-1 map between p6 packages and p5 packages, with lookup done in a package-local sub "p6_lookup", and all under PIL::Run::Root  or somesuch.

[14:31] <fglock> I mean, when you instantiate a 'Code', it would be nice if the closure variables were somehow part of the object

[14:31] <putter> ahh...

[14:31] <putter> yes.

[14:32] <putter> create mm Pad?

[14:38] <fglock> a Pad structure would make things much slower? we already have a lot of indirection

[14:40] * putter brain slowly grinds into motion...

[14:40] <putter> what's the objective again in having a Pad to capture lexically scoped variables?

[14:40] <fglock> we will end up needing a garbage collector

[14:41] <fglock> the objective is to allow closures to be cloned

[14:43] *** lhooq is now known as ARRAY

[14:43] *** ARRAY is now known as lhooq

[14:43] <putter> if sub{}s are used to do the capture, could one use a magic argument to call the sub and get back another with the same capture?

[14:44] <putter> at worst, one should be able to do  sub { if ($magic_eval_in_context_request) { return eval($request) } ...}

[14:46] <putter> or just  sub { if <mumble> { return sub { eval(@_) } ... }

[14:46] <putter> which you could actually wrap in a Pad object ;)

[14:47] <putter> does this make sense?

[14:48] <fglock> how about $sub->eval( \@args, \@context ) and later $sub->clone()

[14:49] <putter> get_eval_in_closure($old_sub)->('sub { new code in same closure }')

[14:49] <putter> hmm...

[14:49] <putter> what does eval() do?

[14:49] <putter> and what is @context?

[14:50] <fglock> actually: $sub->new( $code, \@arglist, \@context ) and later $sub->clone()

[14:50] <fglock> @context would be the lexical variables the sub can see

[14:50] <fglock> @context would be cloned when you clone the sub

[14:51] <putter> $sub is Sub yes?

[14:51] <fglock> yes

[14:51] <fglock> $sub = Sub->new( ...

[14:52] <putter> Can Sub->new capture caller lexical variables?

[14:52] <putter> eg, using a sub{} trick, perhaps wrapped in a source filter?

[14:53] <fglock> it could use p5 PadWalker.pm

[14:53] * putter goes to look at PadWalker...

[14:54] <fglock> but it would be nicer if we captured only the variables we actually use

[14:55] <putter> PadWalker has a number of fails on cpan testers.  but neat.  the SEE ALSO section has some perhaps alternatives.

[14:56] <putter> re, capture only what used,   SHARING($x,$y)   ->   ['$x','$y'], sub { return \$x,\$y; }     Sub->new(... SHARING...)

[14:57] <putter> sub { return '$x' => \$x, '$y' => \$y }

[14:58] <putter> sub { '$x' => \$x, '$y' => \$y }

[14:58] <fglock> PIL can tell you what lexical variables are being used, I think

[14:59] <putter> yes

[15:01] <putter> CURRENT_ENV  ->  sub { eval(@_) }   ;)

[15:03] <fglock> $sub->fetch( $var_name ) would tell you the variable contents from the closure standpoint

[15:03] <putter> one worry is that p5 seems to have some landmines around this neighborhood.  vague recollection of having to use non-named subs to get proper closure behavior(?)(fuzzy recollection)

[15:03] <fglock> no problem - we don't use named subs

[15:03] <putter> sounds good

[15:04] <coke> seen pmichaud?

[15:04] <jabbot> coke: pmichaud was seen 62 days 19 hours 46 minutes 13 seconds ago

[15:04] <putter> !

[15:04] <coke> woof. anyone talked to patrick lately? I was expecting an email from him a few days ago, and just sent another email to him & p6i that I'm surprised he hasn't pounced on.

[15:05] <putter> not I

[15:07] <obra> He's been working             

[15:07] <obra> Earning a living and all that ;)

[15:07] <broquaint> Slacker.

[15:09] <putter> fglock: the eval stuff may not work.

[15:09] <putter> perl -e '$s = (sub{my $x =4; sub{eval('$x')} })->(); print $s->('$x'),"\n";'  #=> undef

[15:09] <putter> oops, shell quoting bits again.

[15:10] <iblech> fglock: Problem: You can't trust PIL what vars are used, think sub { my $varname = get_random_varname(); $::($varname) } or even sub { eval '$stuff' }

[15:10] <putter> perl -e '$s = (sub{my $x =4; sub{eval(q/$x/)} })->(); print $s->(q/$x/),"\n";'  still not...

[15:10] <coke> thanks, folks.

[15:11] <broquaint> That won't close over $x, putter.

[15:12] <iblech> There was a thread about that on p6l once, with the general concensus being (IIRC), that we have to close over all variables unless we can prove that some variables can't be used.

[15:12] <broquaint> That shouldn't work either. It'd be icky.

[15:12] <fglock> iblech: these are not a problem, because the var will take a execution time value, instead of sub-creation time

[15:13] <putter> broquaint: are there workarounds, or is it a lost cause (to attept to close over things I dont know the name of)

[15:13] <iblech> fglock: Ah, that would indeed be a very simple solution :) 

[15:13] <broquaint> There are work arounds, putter, but they ain't pretty e.g perl -e '$s = (sub{my $x =4; sub{$x;eval(q[$x])} })->(); print $s->(),"\n";'

[15:14] <broquaint> The problem being that the eval in the inner sub doesn't know about $x at compile-time so won't close over it.

[15:15] <putter> right.  but there the environment capturing code, CURRENT_ENV, is sub{$x;eval(q[$x])}.  which knows all the lexically scoped variables of interest.

[15:15] <putter> so the only way to close over something is to name it?

[15:15] <putter> s/name/mention/

[15:15] <fglock> perl -e '$s = (sub{my $x =4; eval"sub{$x}" })->(); print $s->(q/$x/),"\n";'

[15:17] <putter> (sub{my $x =4;  CURRENT_ENV })->()      is there any definition of CURRENT_ENV which will continue working when I rename $x to $y?

[15:18] <broquaint> How would you rename $x to $y within a closure?

[15:20] <putter> err, everything but CURRENT_ENV is client code.  they can call it anything they like. ;)  my $a,$b;  ... my $x;... $env = CURRENT_ENV;  ...  print $env->($ARGV[0]);

[15:21] <broquaint> Aha. Yes, in perl5, that magic isn't available.

[15:21] <putter> the recent suggestions have all been of a   SHARING($x)   --filter expand to-->   sub { \$x }    variety.

[15:21] <putter> sniff.  oh well.

[15:26] <putter> broquaint: is it just a matter of preventing the variable from being inlined?  ie, if its capture is forced _somewhere_ on the lexical stack, then will eval work?

[15:26] <broquaint> That's about the size of it, putter.

[15:27] <broquaint> If perl doesn't see that variable then it's not captured.

[15:27] <fglock> putter: this is the call/fetch idea in a nutshell:

[15:27] <fglock> perl -e '%s=sub{my $x=4;(call=>sub{++$x},fetch=>sub{$x})}->(); print $s{fetch}(),$s{call}(),"\n";'

[15:30] <fglock> in other words, sub-execute and sub-clone should share a context. I think it is possible to implement this in a simple way

[15:31] <putter> broquaint: ah, but that means, at least with subs created by the system, that one can force the variables to exist by including a throwaway sub which mentions everything.  and have it work for sublevels too.  though I havent tested that.  one could imagine the child closures being pruned.

[15:31] <putter> fglock:

[15:32] <fglock> although I almost sure this will leak memory

[15:32] <fglock> because closures are being created inside closures

[15:32] <putter> so the motivation for having call and fetch, rather than just returning \$x is...?

[15:34] <fglock> fetch() is just an example - I actually need sub_clone() - but it was more difficult to write

[15:35] <fglock> I'll try

[15:36] <putter> sounds good.

[15:36] <broquaint> Are you generating the code, putter?

[15:37] <putter> I tried $s = (sub{my $w=3; $s1=sub{\$w}; sub{my $x =4; sub{eval('$w')}};})->()(); print $s->(q/$w/),"\n";  but no joy.  mixing eval() and lexical variables may have only limited utility.

[15:38] <putter> broquaint: err, an interesting question in a code generation context.  but I think the answer is "no, fglock"

[15:39] <putter> ;)

[15:43] <broquaint> It'd be dead easy if you're generating the code. But it'd still be a filthy hack ;)

[15:43] <putter> fglock: let's not worry at all about efficiency now.  working and correct.  sorry for the distraction.

[15:44] * putter breaks out in "but it would be faster if" hives...

[15:44] <fglock> :) btw - my 'clone' idea didn't work

[15:45] <putter> on to plan B?

[15:46] <fglock> create a pad structure?

[15:47] <fglock> what does PIL2JS do?

[15:48] <iblech> PIL2JS can't clone anything currently, and uses JS's variables. There is a "pad" structure and a global PIL2JS.subpads array containing the current subpads in scope, but these are only used for $CALLER::

[15:51] <svnbot6> r6611 | iblech++ | * t/var/var.t: unHACKify

[15:51] <svnbot6> r6611 | iblech++ | * PIL2JS: PIL::PPad, PIL::PVar: Unbroke $OUTER::.

[15:55] <putter> I'm off.  back day after tomorrow.   bye &

[15:55] <chumphries> pugs looks interesting, have to try to remember haskell

[15:57] <svnbot6> r6612 | fglock++ | * perl5/Code - added 'Pad' to TODO list

[16:37] <kolibrie> stevan_: I'm looking at ::bind_SELF_and_CLASS, and am wondering how $::SELF is available outside of chaos.pl

[16:44] <svnbot6> r6613 | iblech++ | * t/statements/return_from_inner_block.t: Added a guard against inflooping.

[16:44] <svnbot6> r6613 | iblech++ | * PIL2JS: PIL::PVar: Unbreak &infix:<**>, &sin, &cos, etc.

[16:46] <iblech> stevan_: Hm, to call a class method in MM2.0 you have to $Foo->class::bar, right? But what if you can't know in advance if you're calling a class method or a instance method (sub foo ($obj) { $obj.some_method() }; foo(FooClass); foo(FooClass.new))?

[16:51] <stevan_> kolibrie: $::SELF means it is bound to $main::SELF

[16:51] <stevan_> $:: is an alias for $main::

[16:51] <stevan_> in p5

[16:51] <stevan_> that is "fixed" in p6 ;)

[16:51] <kolibrie> ahh

[16:51] <stevan_> iblech: re: class methods

[16:52] <stevan_> good point

[16:53] <stevan_> iblech: I will have to review A12 again

[16:53] <stevan_> but I think class methods are methods which have an explicit Class invocant

[16:56] <Juerd> [bondage freaks]--

[16:56] <svnbot6> r6614 | fglock++ | * perl5/Array - more tests (2 fail)

[16:56] <Juerd> [heuristics maniacs]--

[16:59] <iblech> stevan_: That's true, I think -- FooClass.new.class_method should, of course, not work

[16:59] <iblech> But $x.class_method should, assuming that $x =:= FooClass, work

[17:00] <stevan_> iblech: yes

[17:00] *** stevan_ is now known as stevan

[17:01] <stevan> iblech: wait,.. does =:= mean "is exactly"?

[17:01] <svnbot6> r6615 | dakkar++ | corrected a bug: C<< for @a -> {...} >> is different from C<< for @a {...} >>

[17:01] <svnbot6> r6615 | dakkar++ | of course, now the t-shirts are wrong. Will say as much at the YAPC::Europe 2005 auction ;-)

[17:01] <iblech> =:= means the container on the LHS is the same as the container on the RHS

[17:01] <iblech> Thus I should have better written $x eqv FooClass

[17:03] <stevan> iblech: I almost feel as if class methods should be explicitly MM

[17:03] <svnbot6> r6616 | iblech++ | PIL2JS: PIL2JS.js: Fixed the booleanification of one() junctions.

[17:03] <stevan> rather implicitly

[17:04] <fglock> stevan: we were discussing about using a Pad structure in the p5 runtime (vs hacking the p5 pads) - do you have an opinion on this?

[17:06] <stevan> fglock: not really, I am not that familiar with the internals of p5 pads, and I would expect that p6 pads would need more functionality then p5 pads can supply, but I dont know for sure

[17:12] <stevan> iblech: from a12 -> "Class methods are called on the class as a whole rather than on any particular instance object of the class. They are distinguished from ordinary methods only by the declared type of the invocant. Since an implicit invocant would be typed as an object of the class and not as the class itself, the invocant declaration is not optional in a class method declaration if you wish to specify the type of the invocant. (Un

[17:12] <stevan> typed explicit invocants are allowed to "squint", however.)"

[17:13] <fglock> how about moving Perl6-Value/lib/Perl6/Code.pm to the MetaModel2.0 directory, in order to have Subs and Methods being developed in the same place?

[17:13] <stevan> fglock: I am worried about circularity issues with Code.pm

[17:13] <stevan> since it uses the metamodel

[17:14] <stevan> the metamodel need some kind of primative sub

[17:16] <fglock> "moving" can be: delete the current one, create another one that works right

[17:18] <stevan> fglock: I dont think we should delete the current one

[17:20] <Aankhen``> G'night.

[17:22] * fglock have a meeting in 10min

[17:23] <stevan> fglock: I was going to try and hook up Class::Multimethods::Pure to the MM2.0 today, and see if that will work

[17:24] <stevan> if it does, I think we might want to approach Code.pm the same way

[17:24] <stevan> as an outside module

[17:24] <stevan> basically sub's and multi-subs should be outside of the metamodel

[17:25] <fglock> how about the parameter type-checking in multi methods?

[17:25] <stevan> at least in the primative level

[17:25] <stevan> fglock: C::MM::Pure handles that

[17:26] * stevan still think's nothingmuch's idea of "everything is MMD" is not a bad one

[17:26] <stevan> then we get parameter checking for free (sort of)

[17:26] <fglock> so it would be easy to use C::MM::Pure everywhere?

[17:26] <stevan> I think

[17:26] <stevan> I have to do some source diving into C::MM::Pure first 

[17:27] <fglock> I need to go now

[17:27] <stevan> luqui wrote it as a proof of concept IIRC, so it may need some work to be useful to us

[17:27] <stevan> fglock: enjoy the meeting :)

[17:27] <fglock> bye

[17:31] <kolibrie> stevan: thanks for that $:: tutorial (saved my neck, actually)

[17:44] <svnbot6> r6617 | iblech++ | * t/operators/precedence.t: unEVAL

[17:44] <svnbot6> r6617 | iblech++ | * PIL2JS: PIL2JS.js:

[17:44] <svnbot6> r6617 | iblech++ |   * Classes stringify to their name now.

[17:44] <svnbot6> r6617 | iblech++ |   * $obj.isa(SomeClass) works now. (Previously, only $obj.isa("SomeClass")

[17:44] <svnbot6> r6617 | iblech++ |     worked.)

[17:48] <stevan> luqui: ping

[18:13] *** typester is now known as sleepster

[18:17] <svnbot6> r6618 | iblech++ | PIL2JS: Prelude::JS: Implemented

[18:17] <svnbot6> r6618 | iblech++ |   my $x = $foo but {

[18:17] <svnbot6> r6618 | iblech++ |     $foo.bar = $baz;

[18:17] <svnbot6> r6618 | iblech++ |     ...;

[18:17] <svnbot6> r6618 | iblech++ |   };

[18:21] <dduncan> it appears that Haskell is choking on something

[18:23] <dduncan> 'make' on r6618 dies at the start with 'ghc-6.4: internal error: evacuate: strange closure type 16408

[18:23] <dduncan>     Please report this as a bug to [email@hidden.address] ...'

[18:23] <dduncan> I'll try a realclean now just to be safe

[18:23] <iblech> dduncan: Right, realclean will probably solve the problem

[18:24] <dduncan> I did that, and then the subsequent 'perl Makefile.PL' spat the same error but otherwise completed; still ...

[18:25] <dduncan> ... and make dies as before

[18:25] <iblech> :(

[18:26] <iblech> I can't check whether it works here, as I've got a smoke running...

[18:26] <dduncan> I don't know if the problem is transient and specific to my system or not ... will see what smoke etc says

[18:29] <dduncan> hmm ... I seem to have other issues at present which aren't specific to Pugs ... back in a bit

[18:41] <svnbot6> r6619 | Stevan++ | Perl6::MetaModel 2.0 -

[18:41] <svnbot6> r6619 | Stevan++ | * experimental support for multi-methods using

[18:41] <svnbot6> r6619 | Stevan++ |   Class::Multimethods::Pure to provide the needed

[18:41] <svnbot6> r6619 | Stevan++ |   functionality

[18:41] <svnbot6> r6619 | Stevan++ |     - added tests for this

[18:44] <dduncan> in *this* case, the problem in question was resolved by restarting the computer ... make realclean etc did not do it

[18:45] <dduncan> sometimes my machine has OS-level instability following a wake from sleep ... a program crashed prior to this Pugs discussion ... and one during ... for the same cited reason in the console (a certain low level toolbox routine)

[18:45] <dduncan> anyway, following this, 'make' et al now work normally

[18:48] <svnbot6> r6620 | fglock++ | * perl5/Array - more tests

[19:24] <svnbot6> r6621 | fglock++ | * perl5/Array - more tests; now all tests pass

[19:27] <iblech> http://m19s28.vlinux.de/iblech/stuff/pugs-smokes/pugs-smoke-6.2.9-r6607-linux-pil2js--1125516426-3527--5262-4168-1094-454-801-62--7095335d782e45c4d0c362a246a4b52b.html # new PIL2JS smoke, 79.21% passes :)

[19:28] <fglock> does @a[undef] =:= @a[0] ?

[19:28] <fglock> or is it an error?

[19:30] <iblech> former, probably with a warning "uninitialized warning used in numeric contect"

[19:31] <fglock> ok thanks :)

[19:31] <iblech> (Same for hashes: %h{undef} =:= %h{""})

[19:31] <iblech> np :)

[19:52] <fglock> what happens if @a is tied, and you do @a=@b - is the tie undone?

[19:53] <fglock> btw - what if @b is tied?

[19:56] <PerlJam> I wouldn't think the tie would be undone 

[19:56] <PerlJam> and if @b were tied, it wouldn't matter.  @a would become a copy of @b at that time.

[19:57] <fglock> so with tied arrays, you have to copy elements one by one (non lazily)

[19:58] <PerlJam> well, I wouldn't think you'd have to copy them all at once.  Each element of @a would be sort of a lazy proxy for each element in the tied array @b

[20:00] <fglock> ok, added to TODO list - thanks

[20:11] <autrijus> journal up

[20:11] <fglock> :)

[20:11] <autrijus> took 4+ hours and still just went thru about 40% of changes.

[20:12] <autrijus> i.e. only the changes from <fglock iblech putter> that are marked with "PIL-Run" and "PIL2JS"

[20:13] <autrijus> but finally I no longer feel so overwhelmed :)

[20:13] <autrijus> still, that was amazingly productive.

[20:13] <autrijus> I need to crash now... will catch up the rest of backlogging tomorrow

[20:14] <autrijus> happy hacking :)

[20:14] <autrijus> &

[20:14] <autrijus> (also corrections etc welcome as comments)

[20:15] <S833> hello all

[20:15] <S833> i am trying to rename some ms excel files in a directory

[20:16] <S833> here's paste of my code

[20:16] <S833> http://sial.org/pbot/12853

[20:16] <S833> original file 100-abc-filename.xls i want it to be renamed to filename 100.xls

[20:16] <S833> can some one help

[20:18] <Khisanth> wrong channel

[20:23] <S833> what's wrong tell me

[20:23] <S833> i am just asking for help man

[20:25] <Khisanth> WHAT do you need help with? what do you need the script to do that it isn't currently doing?

[20:26] <S833> yes

[20:26] <S833> the line my ($first, undef, $third) = split (/-/, $old);

[20:26] <S833> and my $new = $third . " " . $first;

[20:26] <S833> need help

[20:27] <S833> besides that everything is fine

[20:28] * Khisanth twitches

[20:29] <Khisanth> I already know that, but what the heck do you want it to do?

[20:30] <S833> read ms excel files from currenct directory

[20:30] <S833> that has the original filename as 100-abc-filename.xls and change it to

[20:30] <S833> filename 100.xls if 

[20:31] <S833> that's it

[20:33] <buu> THIS IS TEAM SIMPLE.

[20:34] <buu> S833: Break it in to steps. Code the steps. Profit!

[20:34] <Khisanth> give me the name of your English teacher so I may murder him/her

[20:35] <Supaplex> my xboss *chough*

[20:35] <Supaplex> noo that'd be to kind. keep him alive. :-)

[20:36] <S833> Khisnath: was that comment about me for buu:

[20:36] <Khisanth> for you

[20:38] <buu> YES

[20:44] <fglock> is (undef=>undef) a valid Pair?

[20:45] <buu> ?eval (undef=>undef)

[20:45] <evalbot_6600> ('undef' => undef) 

[20:45] <buu> Who knows!

[20:45] <fglock> I mean, in the Perl 6 spec :)

[20:45] <S833> Khisnath: you know what

[20:46] <S833> python guys are much better than you guys are!

[20:46] <S833> atleast they help newbies

[20:46] <S833> and people you are having problems

[20:46] <Supaplex> that's just too bad now isn't it?

[20:46] <fglock> S833: try #perl instead

[20:47] <buu> fglock: He's *in* perl

[20:47] <buu> We keep trying to help him.

[20:47] <buu> He ignores all replies and then reasks the question an hour later.

[20:48] <Khisanth> if you think writing the script for you is help

[20:48] <buu> Picky.

[20:49] <S833> i am not asking you to write for me

[20:49] <S833> all i am asking is guide me

[20:49] <S833> give suggestion or example

[20:51] <buu> Why are you asking *here* ?

[20:55] <iblech> fglock: It is.

[20:56] <iblech> fglock: and the key should probably not be coerced into a string

[20:57] <iblech> ?eval (undef => undef).key

[20:57] <evalbot_6600> 'undef' 

[20:57] <iblech> ?eval (undef => undef).value

[20:57] <evalbot_6600> \undef 

[20:58] <fglock> this means { undef=>undef } is not an error? In the current implementation, a hash can have 'undef' as key

[21:00] <buu> fglock: Er, shouldn't that be "undef" the string?

[21:00] <buu> ?eval {undef,undef}

[21:00] <evalbot_6600> (undef, undef) 

[21:00] <buu> ?eval {undef,undef}.key

[21:00] <evalbot_6600> Error: cannot cast from VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subEnv = Just (MkEnv {envContext = CxtItem (mkType "Any"), envLValue = True, envLexical = MkPad (padToList [("$?1",[(<ref>,<ref>)]),("$_",[(<ref>,<ref>)]),("$code",[(<ref>,<ref>)]),("$lang",[(<ref>,<ref>)]),("&?BLOCK_EXIT",[(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>)]),("&break",[(<ref>,<ref>),(<ref>,<ref>)])

[21:00] <buu> hahhahaha

[21:00] <buu> I broke you!

[21:00] <fglock> PIL-Run currently prints {('undef', undef)}

[21:01] <buu> fglock: For which?

[21:01] <iblech> fglock: Right, I'd think so (and this is how I've implemented it in PIL2JS). But: By default, hash can autoconvert their keys to Strs, so {undef()=>undef} would have the same effect as {""=>undef}. But if a hash is declared with shape(Any), {undef()=>undef} should create a hash with .pairs[0].key being undef

[21:01] <fglock> for { undef=>undef }

[21:01] <buu> fglock: Are you differentiating between undef=>undef and undef,undef ?

[21:01] <buu> fglock: Dude, that's a string!

[21:01] <buu> At least, I think it is.

[21:02] <iblech> => autoquotes its LHS...

[21:02] * buu beats fglock with a bat.

[21:02] <buu> iblech: So what happened to evalbot just now?

[21:02] <iblech> buu: It printed an error message, which was truncated after 500 (or so) chars

[21:02] <iblech> ?eval "but evalbot still works"

[21:02] <evalbot_6600> 'but evalbot still works' 

[21:03] <buu> iblech: Er, let me rephrase. Why did it print an error message?

[21:03] <iblech> buu: Because {undef,undef} is not a hash, but a Code, and Pugs tried to coerce the Code into a Hash, but failed

[21:04] <buu> Er, so how do you create a hash ref?

[21:04] <iblech> buu: \hash(undef,undef), {undef() => undef}, {pair undef, undef}, etc.

[21:05] <buu> You wacky perl6ers

[21:12] <svnbot6> r6622 | fglock++ | * perl5/Container - { 1=>2 }.buckets and .elems work in PIL-Run

[21:12] <svnbot6> r6622 | fglock++ |   - TODO update

[21:17] <svnbot6> r6623 | iblech++ | * New t/var/autovivification.t: Tests for autovivification (passes 20/20 in

[21:17] <svnbot6> r6623 | iblech++ |   Pugs, 7/20 in PIL2JS)

[21:17] <svnbot6> r6623 | iblech++ | * PIL2JS:

[21:17] <svnbot6> r6623 | iblech++ |   * PIL: Fixed overwriting of unexported subs, this should unbreak some tests.

[21:17] <svnbot6> r6623 | iblech++ |   * Prelude::JS::Array: Array autovivification, but doesn't work yet because of

[21:17] <svnbot6> r6623 | iblech++ |     mysterious bug (probably a typo), will investigate tomorrow.

[21:18] <fglock> what is 1..Inf.pick supposed to do - int(rand( what? ))

[21:19] <Khisanth> ?eval 1..10:by(3)

[21:19] <evalbot_6600> Error:  unexpected ":" expecting digit, "_", fraction, exponent, term postfix, operator, "does", "but", "is", "^..^", "cmp", "<=>", "^..", "..^", "..", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[21:21] <iblech> fglock: There was a thread on p6l about this, but unfortunately I neither remember subject nor concensus...

[21:23] <iblech> Need to sleep now, night all! :)

[21:24] <fglock> good night iblech

[21:40] <stevan> luqui: ping

[22:01] <luqui> stevan, pong

[22:06] <buu> TEH PONGITY

[22:07] <luqui> jeez, it's only been 20 minutes

[22:07] <luqui> donde fue stevan?

[23:41] *** skylan_ is now known as skylan

