[02:21] <audreyt> tcliou: openfoundry is performing hardware upgrade right now?

[02:22] <audreyt> tcliou: will it be back this afternoon? :)

[02:22] <rafl> Isn't there a mirror somewhere? I'm interested in what kane has done on JIB.. :-(

[02:23] <audreyt> http://svn.perl.org/perl6/pugs

[02:24] <rafl> Is it really a 1:1 mirror? It has a trunk/branches/tags layout.

[02:25] <audreyt> the trunk is 1:1

[02:25] <audreyt> the tag is manually maintained but I tend to forget

[02:26] <rafl> OK. Why doesn't pugs use a standard svn layout as well?

[02:26] <rafl> I, as the Debian maintainer, who cares a lot about releases, would like to have release tags.

[02:26] <rafl> kane-xs: ping

[02:27] <xinming> rafl: that might be because of audreyt use freebsd

[02:28] <audreyt> rafl: if you care about release tags, andis willing to maintain them, talk to Robrt to get a pugs commit bit over at svn.perl.org and maintain the tags/ there for me? :)

[02:28] <rafl> audreyt: That's fine with me, but I don't see why we shouldn't have that at svn.openfoundry.org?

[02:28] <rafl> xinming: I don't see the connection here.

[02:29] <xinming> well, Just kidding. :-P

[02:29] <audreyt> rafl: mostly because I don't like areas in the main playground to be restricted tocommit

[02:29] <audreyt> as tags/ definitely is and branches/ too

[02:30] <audreyt> culturally, I'd like to encourage a single trunk with no roomfor accidental breaking-the-rules

[02:30] <audreyt> my brain is strange. please bear with it :)

[02:30] <rafl> audreyt: Why should it be restricted? :-)

[02:30] <audreyt> rafl: free commits into tags/ doesn't quite make sense :)

[02:31] <rafl> I actually know the situation of thinking that my brain is strange as I'm pretty trunk, err.. drunk.

[02:32] <rafl> audreyt: Why? Anybody could make a release tag. Maybe the guy who's currently doing the releases gets hit by a bus, which we all don't hope.. ;-)

[02:32] <audreyt> I'd like to meet this guy you are referring to ;)

[02:33] <audreyt> in any case. I'll talk with robrt into handing you a svn.perl.org commit bit

[02:33] <audreyt> do you have a perl.org account?

[02:33] <rafl> Already pinged him.

[02:33] <audreyt> excellent

[02:33] <rafl> Yes, I'm a parrot commiter as well.

[02:34] <audreyt> maybe you can commit into pugs/ there already then

[02:34] <audreyt> not sure... robrt may have separate ACL

[02:34] <rafl> I won't try that now. :-)

[02:35] <rafl> But that reminds me to finally finish my svn server setup at perldition.org :-(

[02:37] <rafl> And perldition.org reminds me that I still need a funny, somehow perl-related, domain name as my provider grants me one for free..

[02:37] <rafl> Any hints? :-)

[02:39] <audreyt> purl.cc :)

[02:40] <xinming> audreyt: which window manager you use please? xfce4 I use mostly died today. :-/

[02:41] <audreyt> I used to use ion

[02:41] <rafl> audreyt: .cc is expensive.

[02:41] <audreyt> but afterI upgraded the laptop I'm a happy metacity user

[02:41] <rafl> audreyt: I'd prefer .org or .de or .net or something like that.

[02:41] <rafl> I can recommend wmii.

[02:41] <audreyt> perl-r.us

[02:41] <rafl> ion, but much cooler.

[02:42] <rafl> I don't get what's funny about perl-r somehow.. :-)

[02:42] <audreyt> "perl R us"

[02:42] <audreyt> as in "toys R us"

[02:44] <rafl> *pling*

[02:45] <audreyt> or how about something vanilla: perl5.org

[02:45] <audreyt> perl5.net

[02:45] <audreyt> both are free

[02:45] <audreyt> as is lambdacamel.org

[02:46] <rafl> perl5.* will be outdated pretty soon ;-)

[02:46] <xinming> audreyt: metacity can do nothing without gnome in my opinion. :-/

[02:46] <audreyt> xinming: er sure, gnome 2.12 user here

[02:46] <audreyt> rafl: perl7.net then

[02:47] <rafl> :-)

[02:47] <audreyt> or p6doc.org to host documentations

[02:47] <rafl> Is there a fixed name for sixpan yet? sixpan.org?

[02:48] <rafl> Or will it be on cpan.org?

[02:51] <audreyt> cpan.org/perl6/  or cpan.org/jib/ is possible

[02:51] <audreyt> talk to aevil if you'd like to populate it now

[02:51] <audreyt> (and have it mirrored usually)

[02:52] <audreyt> but sixpan.org would work happily too

[02:52] <audreyt> brb

[02:52] <rafl> I think it's impossible to merge the perl6 stuff to current cpan. What do you think? And I'd personally prefer a short url to the new cpan. Like sixpan.org.

[02:53] <rafl> But I fear I don't have the bandwith. 100mbit/s and 250GB free/month.

[02:55] <obra> fwiw, I already have 6pan.com,net,org

[03:01] <rafl> obra: I would prefer something without a number at its beginning. I'd register sixpan.org if you're fine with that.

[03:01] <obra> Actually, jarkko and larry strongly preferred we stick with cpan.org

[03:02] <obra> which is why I'm just sitting on them

[03:02] <obra> Really a path under cpan.org that a site could mirror without mirroring all of cpan would be a huge win

[03:02] <rafl> How to migrate cpan from perl5 to 6?

[03:02] <obra> and not forking the cpan is an even bigger win

[03:02] <obra> different hierarchy inside cpan.org

[03:03] <obra> and really, it's not a migration. because both should stay live

[03:03] <rafl> Well, perl6.cpan.org sounds good to me as well.

[03:03] <obra> ftp://ftp.funet.fi/pub/CPAN/perl6/{modules,authors,etc}

[03:03] <obra> a domain name doesn't really help

[03:03] <obra> it's all about file hierarchy

[03:04] <rafl> Of course. But I want something that's short to type and a long path name isn't what I want. :-)

[03:04] <obra> ...why do you want this path?

[03:05] <obra> what are you actually trying to do?

[03:05] <obra> since, well, the tools should be the only thing getting to the site most of the time

[03:05] <obra> I'm happy to make s.ly/6 redirect to wherever you want it to ;)

[03:05] <rafl> I just want a short url to get to perl6's cpan. What I'm currently trying to do is to fine a nice domain name as I still get one for free from my isp.

[03:06] <obra> ah. I'd not use your free domain for a perl thingy.

[03:06] <obra> but I'm happy to make sure a very short url resolves to cpan for perl6 when the repo exists

[03:06] <rafl> Well. Free for one year. 12/a afterwards.

[03:07] <rafl> But 12 EUR per year is nearly for free, imho. :-)

[03:07] <obra> you can get com/net/org for that pretty easily :)

[03:07] <obra> hey. there's no rafl.net

[03:07] <rafl> I don't like .net domains to be honest.

[03:09] <rafl> I would have taken rafl.org though.

[03:10] <rafl> OK, so you think I should not register a domain for sixpan?

[03:11] <rafl> I would have everything I we need for it. Including 3rd level delegation and stuff..

[03:12] <audreyt> I suggest jib.bz

[03:12] <rafl> jib uses gzip, bit bz2 currently ;-)

[03:13] <audreyt> that can change ;)

[03:13] <rafl> Also .bz is not for free as far as I see. Only .com/org/net/de is covered.

[03:16] <obra> I think that we don't want a sixpan that's not the CPAN.

[03:16] <obra> I say this in my "official capacity" as the Perl 6 Project Manager.

[03:16] <obra> But! I'd love to see more of cpan for perl6 actually built.

[03:17] <obra> which likely starts with getting a directory structure jhi likes and helping ANDK update pause

[03:18] <rafl> obra: OK. I won't register sixpan.org then.

[04:36] <stevan_> audreyt: ping

[04:36] <audreyt> stevan_: pong

[04:37] <stevan_> so I have read the Roles section of S12 and I have a thought

[04:37] <audreyt> stevan_: they are replacing the switch -- turned out openfoundry was under DDOS since yesterday -- expected to be back within a few hours

[04:37] <stevan_> audreyt: okay, I have not gotten a lot of code written anyway,.. was chasing issue for $work

[04:37] <audreyt> k

[04:38] <stevan_> but I was thinking,.. that maybe for Roles at this level

[04:38] <stevan_> it might make sense to have an interface more similar to the original Traits (not p6 traits, but the Traits papers)

[04:38] <stevan_> we would allow for explicit exclusion, and other things like that

[04:39] <stevan_> I would rather make this part of the meta-role's responsibility than to force any compiler to have to do tricks to accomplish it

[04:41] <audreyt> makes sense.

[04:41] <audreyt> I'd like to see some tests that defines this behaviour

[04:41] <stevan_> ok

[04:42] <stevan_> I am going to finish the roles as they are now designed, but give this more thought

[04:43] <stevan_> having things like an explicit list of method/attribute requirements that a consuming class must fufill makes things much easier I think

[04:43] <stevan_> these things never need to be seen by anyone but meta-model hackers

[04:47] <audreyt> yup

[04:50] <stevan_> ok, back to roles then ... :)

[04:52] <stevan_> oh audreyt, almost forgot,.. we will need to define $?ROLE as well

[04:52] <stevan_> similar to $?CLASS

[04:52] <stevan_> but this can wait

[04:56] <audreyt> $?ROLE only makes sense in the role body?

[04:56] <stevan_> yes

[04:56] <audreyt> but $?CLASS is runtime dispatched

[04:56] <audreyt> not lexicallly determined

[04:56] <audreyt> oh wait, $?ROLE is also that

[04:57] <audreyt> never mind, I had levels confused

[04:58] <stevan_> :)

[04:59] <stevan_> like I said,.. not critical I don't even use it in the bootstrap

[05:09] <audreyt> k

[05:09] <audreyt> I'll run to $job now... bbiab

[05:09] <stevan_> have fun

[08:13] <GeJ> greetings all

[08:13] <gaal> yo GeJ 

[08:14] <GeJ> morning gaal

[08:15] <gaal> how do you find TaPL?

[08:16] <GeJ> offending. I mean I never thought a book could give me such headaches. And to answer your following question, no, I didn't use it to hit my forehead :)

[08:16] <gaal> :)

[08:17] <GeJ> I really regret all those hours where I slept during the math classes... 

[08:18] <gaal> somehow sleep is something one only regets in hindsight.

[08:18] <GeJ> Why don't teachers and professors simply advertise their class like this: "Please, don't sleep, you'll find this class useful in 10 years."

[08:18] <gaal> i think they actually do, but at the time students hear that it's hardly convincing.

[08:18] <gaal> tea, brb.

[08:19] <GeJ> coffee, brb too.

[08:26] <GeJ> hi again

[08:27] <gaal> xx 2

[08:27] <gaal> audreyt: ping

[08:35] <GeJ> all the planets collapsed?

[08:42] <gaal> ?

[09:00] <GeJ> I get timeouts for planet.perl.org, planetsix and parrot

[09:03] * luqui doesn't

[09:04] <GeJ> hi luqui 

[09:04] <luqui> hello

[09:05] <GeJ> must be a routing issue then. Two big telcos must be playing "Mine's bigger than yours, show me the money" again

[09:06] <luqui> :-)

[09:10] <GeJ> hum, traceroute blocks on 7th hop. definitely routing. 

[09:11] <GeJ> How can somebody expect me to be productive if I don't get my morning dose of perl news.

[09:11] <luqui> well, there's nothing new on planetsix

[09:22] <svnbot6> r8390 | luqui++ | Got quantification working, and fixed a bug in alternation.

[09:48] <GeJ> New year's resolution : sync Luthor and pugs 6.28.0 with the FreeBSD ports

[09:50] <GeJ> CPAN-centric question: is it bad practice to copy-paste-minorchange-rename a module if the maintainer timeouts?

[09:51] <luqui> especially not if you rename and point to the original

[09:51] <luqui> if you didn't rename I could see that as being controversial

[09:54] <GeJ> well, the problem is that one of svk's dependancies conflicts with a module I was using while reading chromatic's book.

[09:54] <svnbot6> r8391 | luqui++ | A few tests.

[09:55] <luqui> so what's your plan?

[10:00] <GeJ> well, svk depends on Audrey's VCP which in turns depends on podToHTML wich in turns depends on a very old version of Pod::Parser.

[10:01] <luqui> and what is the conflict?

[10:03] <GeJ> back in the days where podToHTML used an old version of Pod::Parser, the former had a Pod::Find on its own. Now, Pod::Parser has its own Pod::Find. both of them have different interfaces.

[10:04] <luqui> I'd say that you should patch and re-upload under the same name... as long as you still pass all tests.

[10:04] <luqui> update version so people get yours instead of his

[10:04] <GeJ> isn't that like stealing the guy's port?

[10:04] <luqui> yeah, but you're not being malicious

[10:04] <luqui> and he still gets the "registered" version if he registered

[10:06] <luqui> If you really wanted to have "good style" then I'd email [email@hidden.address] and ask to be the maintainer of that module

[10:06] <luqui> since the real maintainer is no longer active

[10:06] <GeJ> Oki, will do then. I will refactor the module, run the tests, propose the patch to the original author and in case of timeout, I'll follow your advice.

[10:07] <luqui> I figure that kind of thing is fine as long as you're helping people and hurting nobody

[10:12] <GeJ> thanks, I'll do it then

[11:04] <luqui> ?eval "foo" ~~ /foo/

[11:04] *** evalbot_8389 is now known as evalbot_8391

[11:04] <evalbot_8391> *** Cannot parse PGE: foo *** Error: end of file Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} ) 

[11:04] <luqui> ?eval "foot" ~~ /foo/

[11:04] <evalbot_8391> *** Cannot parse PGE: foo *** Error: end of file Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} ) 

[11:05] <luqui> ?eval "foot" ~~ /^foo$/

[11:05] <evalbot_8391> *** Cannot parse PGE: ^foo$ *** Error: end of file Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} ) 

[11:47] <Juerd> PGE in Perl 6?

[11:47] <Juerd> Sweet :)

[11:49] <luqui> it's been there for a while

[11:49] <luqui> doesn't seem to be working presently

[11:52] <audreyt> weird, it worksforme (parrot 0.4.0)

[11:52] <audreyt> external parrot

[11:54] <luqui> I think that evalbot embeds

[11:54] <luqui> or, wait

[11:54] * luqui checks

[11:55] <audreyt> do you have parrot in path (if not embedded)?

[11:55] <luqui> parrot 0.3.1

[11:56] <luqui> but I set PARROT_PATH...

[11:56] <luqui> shouldn't that override

[11:56] <luqui> looks like it's external

[11:56] <luqui> PUGS_EMBED='perl5'  # not parrot

[11:58] <audreyt> mm, not sure we support 031 anymore

[11:58] <audreyt> try up to 040?

[12:01] <luqui> it was feather's parrot

[12:01] <luqui> hmm, Juerd is here

[12:01] <luqui> Juerd, update parrot!

[12:01] <luqui> :-)

[12:01] * luqui builds it himself, too

[12:02] <Juerd> Hm?

[12:02] <Juerd> Location: eric256

[12:02] <luqui> you run feather, right?

[12:02] <Juerd> I'm only doing system administration of feather now, no additional things like providing pugs and parrot

[12:03] <audreyt> Status: 301

[12:03] <Juerd> It was too ambituous to do bouth

[12:03] <Juerd> s/outh/oth/

[12:03] <luqui> fair enough

[12:06] <audreyt> luqui: I'll make the runtime executable path look at PARROT_PATH

[12:13] <svnbot6> r8392 | audreyt++ | * %ENV{PARROT_PATH} is now consulted in runtime for

[12:13] <svnbot6> r8392 | audreyt++ |   external parrot invocations (eg. PGE).

[12:13] <svnbot6> r8392 | audreyt++ |   (Set it to a directory containing the "parrot" executable.)

[12:13] <svnbot6> r8392 | audreyt++ |   Requested by luqui++

[12:14] <luqui> hm.  I was going to try pge to see what kind of match object "x" ~~ /[[x]*]*/ should return

[12:14] <luqui> it infinite loops ;-)

[12:22] <audreyt> not very surprised ;)

[12:23] <luqui> how come?

[12:24] <audreyt> I recall running into the same problem months before

[12:26] <luqui> what's that p5 regex that causes exponential behavior?

[12:30] <luqui> hmm... there seem to be exportation problems

[12:30] <audreyt> oh wow

[12:30] <audreyt> what fun

[12:30] <audreyt> $ perl -e '("a"x 9000) =~ /(a|a*)*/';

[12:30] <audreyt> Bus error

[12:30] <luqui> 9000?!

[12:31] <audreyt> yeah, huge, no?

[12:31] <luqui> interesting.  works fine here.

[12:31] <audreyt> on feather it takes 30000 to blow up

[12:31] <audreyt> but still quite amazing

[12:31] <luqui> there we go

[12:32] <theorbtwo> Here perl -e '("a"x 10_000) =~ /(a|a*)*/'; finishes in a moment, but 100_000 segfaults.

[12:32] <theorbtwo> (Again, very quickly.)

[12:33] <audreyt> I'd rather an infinite loop than a segfault

[12:33] <theorbtwo> perl -e '("a"x 24938) =~ /(a|a*)*/'; is the line, which is an interesting number.

[12:34] <theorbtwo> So would I.

[12:34] <audreyt> unpredictable segfault, even

[12:35] <luqui> wait... does pugs use both parsec and happy?

[12:40] <audreyt> just parsec

[12:40] <luqui> configure seemed to probe for happy

[12:40] <audreyt> cabal does that automagically

[12:40] <audreyt> it's okay if it can't find it, no?

[12:40] <luqui> I guess.  I wouldn't know.

[12:41] * luqui doesn't think he appreciates cabal as much as he should

[12:48] <ingy> hey audreyt 

[13:00] <ingy> hi nothingmuch 

[13:02] <luqui> gaal, ping

[13:02] <luqui> hey audreyt, you helped gaal with his export patch, right?

[13:14] <audreyt> luqui: a bit

[13:16] <luqui> n/m, I found what I needed

[13:16] <luqui> it appears that the package part of the environment is not swapped out correctly when calling an exported sub

[13:18] <audreyt> aye, quite possible

[13:18] <audreyt> you fixed it?

[13:18] <luqui> no, but I found the place I should be trying to fix it

[13:19] <luqui> it's a little tough to track down, because if I say my &foo = &Bar::foo, then everything works correctly

[13:19] <luqui> ahh, there we go

[13:19] <luqui> superfluous Syn "sub"

[13:22] <svnbot6> r8393 | luqui++ | The lexical environment of exported subs was not being swapped out correctly.

[13:27] <luqui> ?eval "Hooray, evalbot is back, finally"

[13:27] <evalbot_8393> "Hooray, evalbot is back, finally" 

[13:28] <luqui> ?eval "does pge work" ~~ /pge/

[13:28] <evalbot_8393> *** Cannot parse PGE: pge *** Error: end of file Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} ) 

[13:28] <svnbot6> r8394 | luqui++ | We don't know how to delegate exports yet, so let's just use File::Spec::Unix explicitly for now.

[13:28] <luqui> damn

[13:29] <luqui> huh... it works with the exact same pugs on the console

[13:29] <luqui> maybe it's the safe mode thing

[13:33] <luqui> uh, how do I set safemode?

[13:33] <luqui> oh stupid me

[13:33] <luqui> learn how to use your shell luqui

[13:34] <ingy> hmm googling the swastika character works, but not the snowman character

[13:40] <luqui> ?eval "does pge work" ~~ /pge/;  1

[13:40] *** evalbot_8393 is now known as evalbot_8394

[13:40] <evalbot_8394> *** Cannot parse PGE: pge *** Error: end of file 1 

[13:40] <luqui> that's so weird

[13:41] <audreyt> some sort of ulimit?

[13:42] * luqui is investigating

[13:45] <Juerd> ingy: Then probably they classified the swastika as a letter :)

[13:47] <luqui> ?eval "does pge work" ~~ /pge/

[13:47] <evalbot_8394> Match.new(   ok => bool::true,    from => 5,    to => 8,    str => "pge",    sub_pos => (),    sub_named => {} ) 

[13:48] <svnbot6> r8395 | luqui++ | Liberalize the memory limit in evalbot a little bit.

[13:48] <ingy> Juerd: but not the snowman!!!

[13:48] <luqui> there, now PGE works in evalbot

[13:48] <Juerd> ingy: Everyone knows a snowman is not a letter :P

[13:49] <luqui> 8

[13:49] <luqui> hmm, all it needs now is some arms:  /8\

[13:49] <luqui> no, that looks more like a tent

[13:49] <webmind> Juerd, it's not?

[13:49] <luqui> hmm, all it needs now is some arms:  -8-

[13:49] <luqui> there we go

[13:50] <luqui> see, the snowman is too a glyph

[13:50] * webmind rewrites his last letter :)

[13:50] <Juerd>  ^

[13:50] <Juerd> -8-

[13:50] <Juerd> Blah, too much spacing :)

[13:50] <luqui> not in my font

[13:50] <luqui> oh, for the caret

[13:50] <luqui> yes, in my font

[13:50] <theorbtwo> ･

[13:50] <theorbtwo> o

[13:50] <theorbtwo> O

[13:50] <luqui> stop using unicode that confuses my computer!

[13:51] <theorbtwo> .

[13:51] <theorbtwo> o

[13:51] <theorbtwo> O

[13:51] <ingy> luqui: upgrade!

[13:51] <theorbtwo> Plain ole ascii.

[13:51] * luqui would, but he isn't sure what to upgrade

[13:51] <theorbtwo> OS?

[13:52] <luqui> gentoo

[13:52] * ingy just wrote a program called the Dominator

[13:52] <theorbtwo> Install more fonts, assuming it shows a "I don't have this char" box.

[13:53] <luqui> ingy, I think you need to write a Tick module that uses Spoon

[13:53] <ingy> yeah yeah yeah

[13:53] <theorbtwo> Makes things comply with the document object model, using whips and chains?

[13:53] <ingy> theorbtwo: :)

[13:59] <luqui> cool!  a prof is going to let me sit in on his "topics in programming languages" grad seminar

[14:11] <Juerd> luqui: A whole seminar about topics?

[14:20] <luqui> :-)

[14:20] <luqui> the topic of the topics is "performance on modern machines"

[14:23] <Juerd> Ah

[14:31] <svnbot6> r8396 | kane++ | * Repository.pm has a packages() accessor now

[14:31] <svnbot6> r8396 | kane++ | * repo.pl gets packages from pkg.pl, not from a `find`

[14:31] <svnbot6> r8396 | kane++ | * add JIB::P::Installable to represent repository packages

[14:31] <svnbot6> r8396 | kane++ |     * fix jib::package to delegate to j::p::installable

[14:31] <svnbot6> r8396 | kane++ | * add some more constants

[14:31] <svnbot6> r8396 | kane++ | * jib::repository uses J::P::Installables now

[14:31] <svnbot6> r8396 | kane++ | * add basic tests for J::P::Installable

[14:34] <luqui> audreyt, ping

[14:37] <luqui> I'll ping, and then I'll leave.  How considerate. &

[15:33] * luqui thinks xern should get a handle on his irc client :-)

[15:33] <luqui> er, a client on his irc handle ?

[15:35] <GeJ> Well, syncing his RTC modem to the lights on his Xmas tree was a bad idea if you ask me

[15:37] <audreyt> rehi

[15:43] <araujo> hi audreyt 

[15:45] <audreyt> :)

[15:48] <luqui> hmmm...

[15:48] <luqui> should monkey but clone?

[15:49] <luqui> ?eval my $a = [1,2,3];  my $b = $a but { $_.[2] = 4 };  say $a;  say $b

[15:49] *** evalbot_8394 is now known as evalbot_8396

[15:49] <evalbot_8396> OUTPUT[124 124 ] bool::true 

[15:49] <luqui> is that correct?

[15:49] <audreyt> I don't think monkey but does a deep cloning

[15:49] <audreyt> it is likely to be expensive

[15:50] <luqui> then how much cloning is done?

[15:50] <luqui> because certainly a little bit is

[15:50] <audreyt> assignment

[15:50] <audreyt> I think

[15:50] <luqui> that makes sense

[15:50] <luqui> is .clone deep?

[15:51] <luqui> ?eval my $a = [[1,2],[3,4]];  my $b = $a.clone;  $a[0][0] = 42;  say $b

[15:51] <evalbot_8396> Error: Pattern match failure in do expression at src/Pugs/Prim.hs:1077:4-14 

[15:51] <luqui> uh oh

[15:52] <luqui> heh.  nobody knows the answer to that question :-)

[15:52] * luqui thinks .clone should be shallow

[15:52] <luqui> actually... it's probably specified

[15:53] <audreyt> clone is shallow?

[15:54] <luqui> I would think that to be a more common want

[15:54] <luqui> shallow copy of an object

[15:54] <luqui> deep copy gets tricky to specify in some cases, shallow doesn't.

[15:54] <luqui> I expect a .deepcopy or .clone(:deep) also to exist...

[15:56] <luqui> hmm.  I guess not.  I seem to recall this sort of thing being specced.

[16:08] <luqui> wait.  What does assignment buy us for monkey but?

[16:10] <luqui> Hmm.  but is a referential rebless.  Does that mean that reblesses don't work like they do in perl 5?

[16:10] <audreyt> I don't think you can rebless anything.

[16:10] <audreyt> you can bless things, but not rebless them.

[16:11] <audreyt> in the minilang calculus, the o_class field is read only.

[16:11] <luqui> okay, then what is it that "but" does?

[16:11] <audreyt> it's a convenient syntax for "given" and then return the same topic

[16:12] <luqui> not monkey but, regular (human) but

[16:12] <luqui> 0 but True, etc.

[16:14] <audreyt> it's just an assignment.

[16:14] <audreyt> s12.

[16:14] <audreyt>            (($anonymous = 0) does answer).answer = 42;

[16:14] <audreyt>            $a = $anonymous;

[16:14] <audreyt> $a = 0 but answer(42); # desugared into above

[16:16] <luqui> okay.  what does "does" do?

[16:19] <audreyt> it derives a new anonclass

[16:19] <luqui> and....

[16:19] <audreyt> blesses the old opaque

[16:19] <audreyt> into a new object

[16:19] <audreyt> with a different .id

[16:19] <audreyt> and return it

[16:20] <luqui> so that's not a rebless?

[16:20] <audreyt> I don't think .id survives a "does", no

[16:20] <audreyt> they may share the same underlying opaque.

[16:20] <luqui> hmmm...

[16:20] * gaal meows

[16:20] <luqui> I'm just thinking that "does" is probably going to be done in void context most of the time

[16:20] <theorbtwo> Rebless:  my $x = bless {}, "foo"; $y=$x; bless $x, "bar"; $y->isa("bar")

[16:21] <gaal> hi everybody

[16:21] <luqui> hiya gaal

[16:21] <theorbtwo> Well, you could possibly do $foo does=answer(42), but that's ugly.

[16:24] <GeJ> I wish you all a Merry Christmas (or whatever your $LOCAL calls it). Go easy on the food, the chocolate and the alcohol

[16:25] <luqui> anyway... the test is:  my $x = Foo.new;  $y = $x;  $y does Bar;  say $x.does(Bar);

[16:25] <gaal> does anybody rely stronly on assignment chaining now? I'm inclined to break it knowingly, fix the import stuff, and have it added back afterwards.

[16:25] <luqui> oh, a less controversial question: how are hashes stored in pugs?

[16:25] <luqui> there's no VHash constructor

[16:26] <gaal> also, are we going to allow things like my $a := my $b ::= my $c = 8?

[16:26] <luqui> ack... that ::= in there scares me...

[16:26] <gaal> uh huh

[16:26] <luqui> let's see, that means... $b and $c are set at compile time

[16:26] <luqui> but $a is not

[16:26] <luqui> I'm guessing

[16:27] <gaal> i have no idea what it means :)

[16:27] <gaal> in this context, what difference does it even make if it's compiletime or not?

[16:27] <luqui> my $a := my $b ::= my $c = 8;   say $a;  # is this "" or "8"?

[16:28] <luqui> er

[16:28] <luqui> wrap a BEGIN around that say

[16:28] <luqui> then it matters

[16:28] <gaal> heh.

[16:29] <gaal> maybe we can simply disallow chained assignments of different kinds

[16:30] <luqui> that's not a "chained assignment"

[16:30] <luqui> that's just my $a := (my $b ::= (my $c = 8))

[16:31] <luqui> and it should have a well-defined semantic

[16:31] <audreyt> gaal: just kill chained assignment for now.

[16:31] <luqui> oh, gaal, you're working on that

[16:31] <audreyt> they need a redo anyway based on inline declarators

[16:31] <luqui> which is why you're interested

[16:31] * luqui agrees with audreyt 

[16:31] * luqui agrees with audreyt again (inline declarators)

[16:32] <gaal> "inline declarators"?

[16:33] <gaal> also: audreyt, can you explain again how lexical aliases of "our" vars are supposed to be used,

[16:33] <gaal> and if they *are* used, what's supposed to happen here? --

[16:33] <gaal> my $x; our $x

[16:33] <audreyt> inline declaration

[16:33] <audreyt> $y = 6 + my $x;

[16:33] <gaal> ahh, literally, "in a line" :-)

[16:34] <audreyt> what happens there is the compiler should raise an error.

[16:34] <gaal> why? in p5 it's totally cool to do that; the my var masks the our var until the scope ends.

[16:34] <gaal> as I am sure you know :)

[16:34] <luqui> yeah, and we killed that

[16:34] <luqui> for various reasons

[16:35] <gaal> luqui: all these new scoping rules are quite.. a mouthful. are they bunched together in any one document?

[16:35] <gaal> (if not I'll start one)

[16:37] <luqui> gaal, "all" which?

[16:37] <luqui> name two.

[16:37] <gaal> namespaces can be lexical

[16:37] <luqui> ah, that.

[16:38] <gaal> exports can change the kind of visibility a variable has.

[16:38] <luqui> you mean define.

[16:38] <luqui> they can't "change"

[16:38] <gaal> I'm talking about my $x is export(:our)

[16:39] <luqui> yeah.  they define the scope of $x in the calling package.

[16:39] <luqui> er, calling... scope?

[16:39] <gaal> use Xs::Module :state<$x>

[16:39] <luqui> calling whatever

[16:40] <luqui> gaal, look at S11

[16:40] <gaal> "unit"?

[16:40] <luqui> I'm going to go with "caller"

[16:40] <gaal> S11 doesn't have enough detail for me

[16:40] <gaal> unless there've been recent commits?

[16:40] <luqui> then you need to bug Larry and p6l

[16:41] <gaal> btw, does "temp" work on both my and our variables?

[16:42] <gaal> the lexical alias stuff seems to suggest that it does

[16:43] <audreyt> yes, it does

[16:43] <audreyt> it also works on arbitrary methods.

[16:43] <audreyt> if they are "is rw"

[16:44] <gaal> I wish there were a p6 version of "coping with scoping" (HOP also had an interesting digression on lifetime scope vs. visibility scope, no?)

[16:44] <gaal> hmmm remind me, method foo is rw means an lvalue sub?

[16:45] <audreyt> aye

[16:45] * audreyt gives up trying to import comments from use.perl tonight

[16:45] <gaal> soooo, temping that means locally overriding the lvalue sub? why can't you do that with a my method?

[16:46] <gaal> ah, dynamic scopt

[16:46] <gaal> scope.

[16:46] <gaal> of course.

[16:46] <gaal> this cartesian product has a lot of dimensions :)

[16:46] <audreyt> no, it means overriding the container returned by the lvalue sub

[16:46] <gaal> eep!?

[16:47] <audreyt> temp foo();

[16:47] <audreyt> vs

[16:47] <audreyt> temp &foo;

[16:47] <audreyt> different things.

[16:47] <audreyt> I was talking about foo().

[16:47] <gaal> i understand temp &foo;

[16:47] <gaal> what does temp foo() mean?

[16:48] <audreyt> my $foo; sub foo is rw { $foo }; temp foo();

[16:48] <audreyt> does the same thing as temp $foo

[16:48] <luqui> that's the reason that we require you to return a proxy object for $foo.bar = 42;

[16:49] <luqui> instead of transforming it into an argument passed to .bar()

[16:49] <gaal> what S is this?

[16:49] <gaal> 6?

[16:49] <luqui> 12?

[16:49] <audreyt> 12

[16:49] <luqui> one of those two

[16:50] <stevan_> hello all :)

[16:50] *** stevan_ is now known as stevan

[16:50] <audreyt> stevan: hey!

[16:50] <audreyt> you again showed up when I'm about to sleep :)

[16:50] <gaal> yo stevan 

[16:50] <stevan> audreyt: yeah,.. something to do with the earths rotation I think :P

[16:51] <stevan> audreyt: I am about to commit the roles work,.. all that is missing is the "apply this to a class" part

[16:51] <stevan> which shouldnt take me too long actually

[16:51] <stevan> although it will be broken per-S12

[16:51] <audreyt> er, uhm, I need more context (or look at the commit) to understand that

[16:52] <stevan> well, it will handle method conflicts,.. but it cannot die

[16:52] <stevan> same for attrs

[16:53] <stevan> and it will not correctly handle stub methods either

[16:53] <stevan> but none of the prototypes ever did

[16:53] <stevan> like I said,.. I am going to move the role model closer to the original trait model 

[16:53] <stevan> it just works better at this meta-level

[16:54] <stevan> audreyt: we also need to think about Prim methods vs. user-defined methods

[16:54] <stevan> I ran into an issue with them and using anon-opauqes 

[16:56] <stevan> because the anon-opaques (ala - the counter) use self.new_opaque()

[16:56] <stevan> which puts self in the  o_class slot.,... which can be problematic because when I try to call get_attr on that opaque

[16:56] <luqui> so audreyt, how are hashes stored in pugs?

[16:57] <stevan> it looks for hte MRO,.. which is not always going to be there (depending upon the context in which the opaque was created)

[16:57] <gaal> luqui: Pugs.Types.Hash

[16:57] <gaal> included into AST.Internals IIRC

[16:57] <luqui> I mean, there's no VHash

[16:58] <luqui> there's only VList

[16:58] <luqui> oh... probably a ref

[16:58] <gaal> type VHash = Map VStr Val

[16:58] <svnbot6> r8397 | stevan++ | PIL/Native/Bootstrap.pil

[16:58] <svnbot6> r8397 | stevan++ | - more Roles work, we have collect_all_roles() and does() now :)

[16:58] <svnbot6> r8397 | stevan++ | t/pil/metamodel/*

[16:58] <svnbot6> r8397 | stevan++ | - added test for does() and collect_all_roles()

[16:58] <integral> hmm, isn't Data.Map actually a btree rather than a hash?

[16:58] <luqui> yeah

[16:59] <gaal> hmmm actually type VHash = Map VStr Val is wrong, isn't it? keys can be arbitrary objects

[16:59] <luqui> yeah

[16:59] <audreyt> yup, the minilang container type will fix that

[16:59] <integral> I thought it was speced that they have a .hash method to turn themselves into the actual key to be used?

[16:59] <stevan> audreyt: ok

[17:00] <stevan> audreyt: workarounds are fine for now,.. and I commented them heavily

[17:00] <stevan> I am going to implement the broken Role resolver for now,.. and then over the holiday work out exactly how the more trait-ish model shoudl work

[17:00] <gaal> I was really amused when I learned that C# has a .hashval method in class Object, just like Java, so they obviosuly realized how important this was, but they didn't think it reason enough to add hashes to the language itself.

[17:01] <luqui> I'm sure it's in a library

[17:02] <gaal> sure, there's a HashTable type

[17:02] <gaal> with an oo interface

[17:02] <gaal> but no syntax for lookups etc.

[17:02] <gaal> (mm slices..)

[17:02] <gaal> brb

[17:02] <luqui> why do you need syntax for lookups?

[17:03] <luqui> That was always an annoyance of perl to me, that hashes and arrays used different syntax

[17:03] <gaal> huh? say %ENV<USER>

[17:03] <luqui> Sure, perl has syntax for lookups, but why do you need it

[17:03] <gaal> because you use it a lot? :)

[17:04] <luqui> yeah, in a dynamic language you do

[17:04] <integral> why have syntax for addition?

[17:04] <luqui> static languages use hashes a lot less

[17:04] <integral> luqui: how do you know that's not just because there's a lack of syntax for them?

[17:05] <luqui> it's because a lot of what perl programmers use hashes for, static language programmers have to use records

[17:05] <gaal> I don't see a reason off hand why staticness should have anything to do with it.

[17:05] <luqui> because the values are of different type

[17:05] <gaal> brb for real though.

[17:05] <integral> oh, you mean for building objects?   I usually use them to be able to look up records by some key

[17:05] <luqui> "look up records by some key"?

[17:05] <luqui> I don't understand

[17:06] <integral> luqui: I was processing a logfile the other day, and I used a hash to keep track of all the machine names I'd seen

[17:06] <integral> so I was using a hash to lookup the record containing counters for that machine

[17:07] <luqui> yeah, that's a place where a static language would use a hash too

[17:07] <luqui> my other point is, what's wrong with %ENV['USER']

[17:07] <luqui> in a static language, that is especially viable

[17:07] <integral> I'd be surprised if you thought my use of hashes was uncommon.

[17:08] <luqui> it needs to be more than 'common' to warrant its own brackets.

[17:08] <luqui> brackets are sparse and valuable

[17:08] <integral> you haven't seen all the uses of two character brackets?  eg. [: ... :], [| ... |] etc

[17:09] <luqui> sure I have

[17:09] <luqui> but do you think hash lookups deserve one-character brackets?

[17:09] <luqui> okay, I want to get off syntax for a moment

[17:09] <luqui> er, not really.  I want to get of the exact syntax for a moment

[17:10] <luqui> what's wrong with %ENV['USER']?

[17:10] <integral> actually, I'm surprised nothing uses the function call syntax for it

[17:10] <luqui> er, yeah, that too

[17:10] <gaal> rehi. I just realized that Perl 6 can in fact unify lookup syntax; P5 couldn't.

[17:10] <audreyt> %ENV('USER');

[17:10] <luqui> gaal, how come?

[17:10] <integral> luqui: I'd say nothing since we have different sigils for arrays and hashes, so they tell us about the different behaviour

[17:10] <luqui> oh, I know

[17:10] <gaal> varying sigils.

[17:10] <luqui> yeah

[17:10] <luqui> integral, and even when we don't...

[17:11] <luqui> $var<key>

[17:11] <integral> ugh. %{$var}<key> would solve that one

[17:11] <luqui> well, I think the type of $var would tell you that

[17:11] <gaal> what's that supposed to be, subscript on a symbolic lookup?

[17:12] <luqui> but then you don't get autovivi

[17:12] <gaal> isn't that $::($var)<key> ?

[17:12] <audreyt> http://pugs.blogs.com/pugs/2005/02/day_1_pugs.html

[17:12] <luqui> which I guess is the most important argument

[17:12] <luqui> gaal, he was just doing a hash lookup

[17:12] <integral> gaal: I was taking it to be the same as ${$var}{key} in perl5

[17:12] <gaal> riht.

[17:12] <gaal> but with a g.

[17:12] <gaal> audreyt: cute

[17:13] <gaal> is that the new home for your journal?

[17:13] <audreyt> aye

[17:13] <integral> feels a long time ago :)

[17:13] <audreyt> probably still going to crosspost back to use.perl

[17:13] <wolv> audreyt, 404 link in the newest post

[17:13] <gaal> 302 actually

[17:14] <audreyt> wolv: fixed

[17:14] <wolv> hey, why can't I change my nick? argh, I hate services

[17:14] <luqui> does somebody know how to clone a ref?

[17:14] <luqui> I mean, from Haskell level?

[17:14] <luqui> that is, I want to take a ref and put its contents into a new ref

[17:14] <gaal> op3 "Object::clone"

[17:15] <luqui> gaal, you're right!  Except... that's what I'm currently writing

[17:15] <gaal> heh

[17:15] <audreyt> I thought we had that

[17:15] <luqui> clone dies if you try to clone an array

[17:15] <audreyt> ah. true

[17:15] <gaal> but not a hash?

[17:15] *** wolv is now known as wolverian

[17:16] <luqui> and a hash

[17:16] <luqui> and an anything that's not a VObject

[17:16] <gaal> I was wondering what the "p" arg was for...

[17:16] <luqui> $obj.clone(attr => newval)

[17:16] <audreyt> luqui: there's no way to clone a ref in the default runcore yet

[17:17] <luqui> so I have to do it by hand?

[17:17] <luqui> Switch on IType?

[17:17] <audreyt> er, that's the easy part

[17:17] <luqui> hmmm?

[17:17] <audreyt> the hard part is that you don't know which underlying storage is used

[17:17] <audreyt> since each one is cloned differently

[17:18] <luqui> Isn't that what I mean by "IType"?

[17:18] <audreyt> yeah, but you can't switch on it, since it's existentially quantified

[17:18] <luqui> oh

[17:18] <audreyt> the only general way to do it is to add a clone method

[17:18] <luqui> so I need to add a vtable method

[17:18] <audreyt> to ArrayClass etc

[17:18] <audreyt> yes

[17:18] <luqui> I can do that

[17:19] <audreyt> and lift it to Types.Object level as a general object_clone

[17:19] <audreyt> excellent

[17:19] <audreyt> do that then :)

[17:20] <stevan> audreyt: nice to see the journal back :)

[17:21] <luqui> hmm.. is it possible to create array_create, etc?

[17:21] <luqui> array_empty :: (ArrayClass a) => a

[17:21] <luqui> or will I run into a wall

[17:21] <audreyt> luqui: and follow it by an array_store?

[17:21] <audreyt> I think just _clone will be better

[17:22] <audreyt> as readonly things can be cloned

[17:22] <audreyt> which is just id

[17:22] <audreyt> but if you do empty+store

[17:22] <audreyt> then that's not gonna work

[17:22] <luqui> hmm, yeah

[17:22] <luqui> I was just trying to factor out some code

[17:22] <audreyt> nodnod

[17:23] <luqui> If you clone a slice, does it lose it's association to the source array?

[17:23] <luqui> yes.

[17:23] <audreyt> yes.

[17:23] <luqui> ooh, that's a problem

[17:24] <luqui> array_clone :: a -> Eval a

[17:24] <Qiang> stevan, where is the journal ?

[17:24] <luqui> but that one would mean it's: array_clone :: IArraySlice -> Eval IArray

[17:24] <stevan> http://pugs.blogs.com/

[17:25] <audreyt> obra: please update the planets feed to point to http://pugs.blogs.com/

[17:25] <stevan> audreyt: would you mind if I added that to the title?

[17:25] <audreyt> sure

[17:25] <luqui> maybe clone is just (Array a) => a -> Eval IArray

[17:25] <audreyt> I'm abandoning the "Day #xyz" format as well

[17:25] <luqui> which would mean it wouldn't have to be a method

[17:25] <Qiang> stevan, thanks. 

[17:26] *** stevan changes topic to: The Return of the Journal : http://pugs.blogs.com/ | pugscode.org | pugs.kwiki.org | paste: http://paste.lisp.org/new/perl6 or http://sial.org/pbot/perl6

[17:26] * luqui thinks that makes more sense

[17:26] <stevan> Qiang: no problem 

[17:26] <Qiang> i would like to see a journal entry or short writeup on "where is pug now and where it is heading next" :-)

[17:26] <audreyt> luqui: I agree.

[17:26] <audreyt> Qiang: good, I'll do that :)

[17:26] <gaal> audreyt: http://use.perl.org/~autrijus/journal/23918 is ported incorrectly to http://pugs.blogs.com/pugs/2005/03/index.html

[17:27] <gaal> possibly other long entries are truncated as well.

[17:27] * luqui thinks the hardest part about hacking on pugs is figuring out in which file to put stuff

[17:27] <Qiang> audreyt, :)  

[17:29] <audreyt> gaal: </div> handling is broken

[17:30] <gaal> audreyt: LJ gets that kind of thing right, but I guess you already made a new home :)

[17:30] <audreyt> gaal: no, the scraping part of WWW::UsePerl::Journal

[17:31] <audreyt> already fixed, reimporting

[17:32] <luqui> hmm.. I can't figure this out

[17:32] <luqui> how do you create a new reference?

[17:32] <gaal> LJ also has efficient backups.. but I'll shut up now :)

[17:32] <audreyt> luqui: MkRef

[17:32] <luqui> I doubt it

[17:32] <audreyt> create anything that's an instance of ArrayClass

[17:32] <gaal> luqui: eval "\my $x", :lang<perl5>

[17:32] <audreyt> then MkRef (IArray that))

[17:32] <luqui> That would mean my clone function would be the identity

[17:33] <audreyt> huuh.

[17:33] <luqui> I want to readRef, and then make a reference from what I read

[17:33] <luqui> oh.

[17:33] <audreyt> you probably don't want readRef.

[17:33] <audreyt> you want to use the native storage and clone from it.

[17:34] <luqui> Why would I want to do that?

[17:34] <audreyt> also see how eg. newArray is implementeed

[17:34] <stevan> Horray, ... we have (slightly broken) roles!!!

[17:34] <audreyt> stevan: !!

[17:34] <stevan> resolve was really easy :)

[17:34] <audreyt> luqui: because 3.clone should be 3?

[17:34] <audreyt> or rather, \3.clone should be identity?

[17:35] <luqui> should it?

[17:35] <luqui> it seems like cloning would get rid of constness

[17:36] <audreyt> if so, then don't bother adding vtable... you can indeed switch on reftype and call newArray etc manually

[17:36] <luqui> that's what I said a long time ago

[17:36] <audreyt> readRef --> newArray

[17:36] <luqui> newArray... that's what I was looking for

[17:36] <audreyt> newHash too

[17:37] <luqui> once it was a -> Eval IArray, there was no need for a vtable

[17:37] <audreyt> aye

[17:37] <audreyt> since you can case into a

[17:38] <luqui> I wonder if .clone on stuff like Code should be identity

[17:38] <luqui> I guess there's no way to change Code, so it doesn't matter

[17:40] <audreyt> er.

[17:40] <audreyt> destructive .wrap does change Code.

[17:40] <Juerd> 18:43 < luqui> I guess there's no way to change Code, so it doesn't matter

[17:40] <Juerd> Never liked that :)

[17:40] <Juerd> I've always seen subroutines as variables

[17:40] <Juerd> And anonymous subs as values.

[17:40] <luqui> that's not what I meant by change

[17:41] <audreyt> in fact, you can destructively assign into Code using clever .wrap

[17:41] <Juerd> And it'd be fun to be able to do &foo.unshift( { die if foo } )

[17:41] <Juerd> Though we do get wrap.

[17:41] <audreyt> so it only takes a simple reopened implementation of infix assignment

[17:41] <audreyt> and the rest of array interfaces

[17:42] <audreyt> all built on this .wrap thing.

[17:42] <luqui> uh, except .shift

[17:42] <audreyt> including .shift

[17:42] <audreyt> which is unwrapping a preprocessor

[17:42] <luqui> oh.

[17:42] <audreyt> s/preprocessor/prehook wrapper/

[17:43] <luqui> then you could definite all sub primitives

[17:43] <luqui> and build everything out of wrappers of the identity

[17:43] <luqui> and have mutable code

[17:43] <luqui> gee... I think they call that LISP

[17:44] <luqui> no wait

[17:44] <luqui> I think they call that functional programming

[17:44] <luqui> yeah, that's the ticket

[17:44] <luqui> very new research area

[17:44] <luqui> nobody knows whether it'll work yet

[17:44] <luqui> okay I'll stop

[17:45] <audreyt> ;)

[17:45] <audreyt> .wrap does assume something on the runtime

[17:45] <audreyt> and you can't change the signature, just the body, I think

[17:46] <audreyt> so it's somewhat constrained

[17:49] <luqui> wait... why the heck am I writing this function?

[17:49] <luqui> how does \$x work!?

[17:50] <luqui> and why can't I find it in Parser.hs?

[17:50] <audreyt> it's just a spre

[17:50] <audreyt> symbolic prefix

[17:50] <audreyt> in op1 "\\" on Prim

[17:50] <audreyt> nothing special about it

[17:51] <luqui> oh.  I guess I was looking at the wrong optable

[17:51] <audreyt> stevan: I grokked your code. I think we want new infixes.

[17:51] <luqui> ahh, you took the "referential context" approach

[17:51] <audreyt> $foo.bar; # userdefined dispatch

[17:51] <luqui> which explains why \$x is so damn broken

[17:51] <audreyt> $foo!bar; # userdefined priv dispatch

[17:52] <audreyt> $foo->bar; # prim dispatch

[17:52] <audreyt> stevan: the -> part can change... 

[17:53] <audreyt> luqui: er, right, I explained that in toronto, and I'm fixing it using fglock/iblech's container class now in the new runtime

[17:53] <luqui> yeah, I seem to recall something like that

[17:53] * luqui looks forward to the new runtime

[17:53] <audreyt> but at that time _nobody_ knows how container classes work

[17:54] <audreyt> many weeks after larry ruled that $foo.method never goes to container

[17:54] <luqui> except for the fact that I'll have to throw away all my pugs internals knowledge

[17:54] <luqui> man, that'll feel good :-)

[17:54] <audreyt> but @foo.method always go to container

[17:54] <luqui> s/after/before/?

[17:54] <audreyt> and so invalidated the entire old runtime assumption

[17:54] <audreyt> s/after/after toronto/

[17:55] <luqui> oh, "many weeks after, larry ruled..."

[17:55] <audreyt> yeah

[17:55] <audreyt> and he introduced the special form variable($foo)

[17:55] <audreyt> which can't be expressed in old runtime

[17:55] <luqui> ahh

[17:55] <audreyt> and I don't even know how to bind &variable except as a macro

[17:56] <audreyt> etc etc :)

[17:56] <luqui> macros are okay

[17:56] <audreyt> they are, and I think it even desugars into something okay

[17:56] * luqui gives up on clone

[17:57] <luqui> but inexpressible?

[17:57] <audreyt> variable($foo).method

[17:57] <audreyt> what Exp does this turn to?

[17:58] <audreyt> you need a new form of Var that does not look into value, or some such

[17:58] <luqui> maybe it's the other way around

[17:58] <audreyt> oh, you mean 

[17:58] <audreyt> say $x;

[17:58] <audreyt> desugars into

[17:58] <audreyt> say $x.value;

[17:58] <audreyt> ?

[17:58] <luqui> uh huh

[17:59] <audreyt> and it's entirely sigil-driven?

[17:59] <luqui> yeah...

[17:59] <audreyt> I think that can work, yes

[17:59] <luqui> kinda goes along with the whole context-sigil thing

[17:59] <audreyt> so $obj.method always becomes $obj.value.method

[17:59] <luqui> and the cool thing:

[17:59] <luqui> say @foo;   # where @foo is in list context

[17:59] <luqui> desugars to

[18:00] <luqui> say @foo.elems;

[18:00] <luqui> which is the defining property of the @ sigil

[18:00] <luqui> assuming context can always be known at compile time

[18:00] <luqui> can it?

[18:00] <audreyt> mm, you assume compile time context knowledge

[18:00] <audreyt> sub blah { @foo }

[18:00] <audreyt> my $x = blah;

[18:00] <audreyt> my @y = blah;

[18:00] <luqui> right...

[18:00] <luqui> returns.

[18:00] <luqui> stupid things

[18:01] <luqui> It's a form of parametric polymorphism, come to think of it

[18:01] <audreyt> it's crude return type polymorphism.

[18:02] <luqui> this will be important to the coersion and context proposal I'm thinking about maybe starting to work on

[18:02] <luqui> :-)

[18:02] <audreyt> cool... I look forward to it. for now I assume context is always passed in at runtime as an extra argument.

[18:02] <audreyt> for function calls, that is

[18:02] <luqui> that's probably a good bet; assuming the most dynamic of things

[18:03] <audreyt> and if I can statically determine context later, that's just dead code elimination.

[18:03] <audreyt> same applies to type based multiple dispatch.

[18:03] <luqui> you just pass the types of the arguments?

[18:03] <audreyt> (where types are passed in as arguments)

[18:03] <audreyt> yeah

[18:03] <luqui> sounds like Haskell's typeclass polymorphism :-)

[18:04] <audreyt> oh, sure, that technique is entirely lifted from Jhc.

[18:04] * audreyt has been studying compilers :)

[18:04] <luqui> good thing to study when you're writing one

[18:04] <luqui> (al: hint, hint)

[18:05] <luqui> man I'm mean

[18:05] <luqui> stop it luqui!

[18:05] * audreyt chuckles

[18:05] <audreyt> stevan: thoughts about using differnt infix for priv/pub/prim methcalls?

[18:06] <audreyt> stevan: of course, the pub methcall is just desugared to the "send" prim

[18:06] <audreyt> not sure if we want a desugar prim for private meth calls

[18:06] <audreyt> if we want one, maybe call it "smuggle"

[18:06] <audreyt> oh, btw: http://pugs.blogs.com/audrey/

[18:22] <audreyt> gaal: the </div> bug should be fixed now

[18:31] * luqui thinks that perl 6 should have an &id, er, &ident, er, &identity

[18:32] <luqui> there are too many good words that start with id

[18:32] <luqui> well, identifier and identify, and that's about it.  But those are both good.

[18:33] <audreyt> I like idle ideas myself.

[18:34] <luqui> those aren't very good words in programming :-)

[18:34] <luqui> which was the implicit context

[18:34] <luqui> but I guess I forgot to pass it in

[18:36] <stevan> audreyt: ping

[18:37] <stevan> audreyt: I think the different infixs are a good idea

[18:38] <stevan> I like . for user-public and ! for user-private  

[18:38] <stevan> I am not sure about ->

[18:38] <stevan> we could go ole school Ada and use `

[18:38] <luqui> what's -> ?

[18:38] <stevan> for prim methods

[18:39] <stevan> get_attr, set_attr, etc.

[18:39] <audreyt> stevan: I changed my mind already

[18:39] <luqui> ahh

[18:39] <stevan> LOL

[18:39] <stevan> audreyt: ok,... whats the new plan

[18:39] <audreyt>   $x.foo(1, 2);   # native method call

[18:39] <audreyt>   $x:foo(1, 2);   # desugars into $x.send('foo', 1, 2)

[18:39] <audreyt>   $x!foo(1, 2);   # desugars into $x.send_private('foo', 1, 2)

[18:39] <stevan> ok

[18:39] <luqui> audreyt, it's fun being the language designer for a change huh?

[18:40] <audreyt> luqui: the difference is I write implementation first :)

[18:40] <audreyt> (already got the three implemented)

[18:40] <stevan> audreyt: that works for me, when can I expect a commit?

[18:41] <stevan> audreyt: also, what about making o_class rw?

[18:42] <stevan> I would like to make all the anon-opaques inherit from a Null class, and Null should then be it's own class (like ::Class is)

[18:42] <stevan> ideally it would not have add_method either 

[18:42] <stevan> or will this all be taken care of with the containers anyway so I shouldnt worry

[18:45] <audreyt> just a bit... ::C desugars into :.send('C') now

[18:45] <audreyt> probably not the best idea

[18:45] <audreyt> everything wants the colon

[18:45] <stevan> what is that for?

[18:45] <audreyt> that's a bug.

[18:45] <audreyt> a misfeature, even

[18:45] <audreyt> I think we go back to Ada.

[18:45] <stevan> ok

[18:47] * stevan starts to write his air traffic control system with the mini-language ;)

[18:47] <audreyt> rofl

[18:47] <audreyt> you want to make anonopaques inherit from Null

[18:47] <audreyt> that's fine

[18:48] <stevan> cool

[18:48] <svnbot6> r8398 | audreyt++ | * two sugar forms in PIL.Native: public method call as $x`foo

[18:48] <svnbot6> r8398 | audreyt++ |   and private method call as $x!foo.

[18:48] <audreyt> why again does that have to be rw?

[18:48] <stevan> I suppose it doesnt if I have a ::Null class

[18:49] <audreyt> can we call that class ::

[18:49] <audreyt> ?

[18:49] <audreyt> literally null

[18:49] <audreyt> or is it too cute :)

[18:49] <stevan> ::.new_opaque()

[18:49] <audreyt> yeah

[18:49] <stevan> no I kinda like it,.. it wont clash with anything

[18:50] <audreyt> committed.

[18:51] <svnbot6> r8399 | audreyt++ | * PIL.Native.Eval: class "null" is now bound to the

[18:51] <svnbot6> r8399 | audreyt++ |   never-clash-with-anything name "::".

[18:52] <audreyt> ::.new_opaque now works as of r8400

[18:52] <svnbot6> r8400 | audreyt++ | * er, typo.

[18:52] <audreyt> anything you need before I finally go to sleep? :)

[18:52] <stevan> nope,.. this will hold me till tomorrow :)

[18:52] <audreyt> excellent :)

[18:52] <stevan> muchas gracias 

[18:52] <audreyt> ditto

[18:52] * audreyt waves &

[18:53] <stevan> adios

[18:53] <obra> hi

[18:54] <stevan> hey obra 

[18:54] <obra> hey stevan

[18:54] <obra> audreyt: I'll update it. Why did you move your blog?

[18:55] <audreyt> obra: much easier organization for one; meaningful categories for another; multimedia stuff; multiple updates per day;

[18:56] <audreyt> separation of OT entries into another subblog (not to be syndicated by planetsix)

[18:56] <obra> *nod*

[18:56] <obra> all makes sense

[18:56] <audreyt> eventual need of guess blogging or coblogging

[18:56] <audreyt> _much_ better layout

[18:56] <audreyt> et cetera :)

[18:57] * obra laughs

[18:57] <audreyt> but the bottom line is that it makes me more motivated to journal

[18:57] <audreyt> which is what counts :)

[18:57] <obra> That matters.

[18:57] <audreyt> s/guess/guest/

[18:57] * obra had guested

[18:57] <svnbot6> r8401 | luqui++ | Small redesign, half tests.

[19:16] <gaal> lj users: http://www.livejournal.com/userinfo.bml?user=pugs_rss

[19:27] <svnbot6> r8402 | stevan++ | PIL/Native/Bootstrap.pil

[19:28] <svnbot6> r8402 | stevan++ | - full (but partially broken) Roles support 

[19:28] <svnbot6> r8402 | stevan++ |     - I really need to rethink some things about the role model

[19:28] <svnbot6> r8402 | stevan++ | t/pil/metamode/*

[19:28] <svnbot6> r8402 | stevan++ | - added roles.t to test basic role composition

[19:57] <audreyt> stevan: ping

[19:59] <audreyt> stevan: I'm thinking about reversing the roles of ` and .

[19:59] <audreyt> stevan: both to agree with the surface syntax

[20:00] <audreyt> and also because later on in Bootstrap most calls are to userdefined

[20:00] <audreyt> also we can make `send() fallback to native method if not defined

[20:06] <audreyt> because this does not (yet) break any of your code, I've committed it :)

[20:08] *** knewt_ is now known as knewt

[20:09] <audreyt> &

[20:10] <svnbot6> r8403 | audreyt++ | * PIL.Native: switch meanings of `method and .method:

[20:10] <svnbot6> r8403 | audreyt++ |     $obj`method;        # native call

[20:10] <svnbot6> r8403 | audreyt++ |     $obj.method;        # $obj`send("method")

[20:10] <svnbot6> r8403 | audreyt++ |   This allows dynamic interpolation of methods:

[20:10] <svnbot6> r8403 | audreyt++ |     $obj.$method;       # legal

[20:10] <svnbot6> r8403 | audreyt++ |     $obj!$method;       # also legal

[20:10] <svnbot6> r8403 | audreyt++ |     $obj`$method;       # illegal

[20:10] <svnbot6> r8403 | audreyt++ |   Adjust the pretty printer to recognize all three forms.

[20:10] <svnbot6> r8403 | audreyt++ |   I wonder if we should introduce two extra node types

[20:10] <svnbot6> r8403 | audreyt++ |   instead of depending on `send -- that of course depends

[20:10] <svnbot6> r8403 | audreyt++ |   on whether we actually use dynamically interpolated 

[20:10] <svnbot6> r8403 | audreyt++ |   methods.  Need more discussion with stevan++.

[20:22] <stevan> audreyt: ping

[20:36] <Khisanth> interpolated method calls or is that something else?

[20:38] <stevan> Khisanth: it is for the mini-lang (aka PIL2)

[20:45] <stevan> audreyt: when you wake up we should talk about all this

[20:45] <stevan> I think you forgot to add "send" too, or at least I cannot see where is it implemented

[20:46] <stevan> also the last commit does not seem to do anything, everything only works with . still

[20:46] <stevan> but we can talk about this more when you awake 

[20:47] <stevan> I think actually we could take this opportunity to rework the dispatcher, maybe even to move the user-defined method dispatcher into the mini-language 

[20:48] <stevan> this would allow more flexibility maybe

[20:48] <stevan> or it might be insane,.. not sure which 

[21:07] * luqui just heard himself say "It doesn't seem like multiplication would be a Syn"

[21:07] <luqui> but it is in some religions!

[21:16] <svnbot6> r8404 | stevan++ | PIL/Native/Bootstrap.pil

[21:16] <svnbot6> r8404 | stevan++ | - mostly just comments re: why Roles are incorrectly implemented

[21:16] <svnbot6> r8404 | stevan++ |   and how. More on this later, I need to think some.

[22:16] <r0nny> re

[22:20] <leo> hi folks: what is the current P6 syntax for testing address equality?

[22:24] <luqui> well, if things had "addresses", it would probably be better

[22:24] <luqui> do you mean spec or pugs?

[22:26] <luqui> leo, sorry, didn't say your name

[22:26] <leo> spec or pugs (yes ;)

[22:27] <leo> $a =:= $b   # or some such?

[22:27] <leo> but at Parrot level

[22:27] <leo> both PMCs are at the same address 

[22:29] <luqui> well, =:= tests bindings

[22:29] <luqui> but you probably want ===

[22:30] <luqui> which tests referential equality (except for value types)

[22:30] <leo> hmm

[22:30] <luqui> that is: my $x = 1;  my $y = 1;  $x === $y;  # true

[22:30] * Khisanth wonders if it is really better to have 4 different operators to test if something is equal

[22:30] <luqui> we're trying to make value types referentially transparent

[22:30] <leo> that's different and implementation dependant

[22:31] <luqui> leo, how?

[22:31] <luqui> how is it implementation dependent?

[22:31] <leo> you know python?

[22:31] <luqui> a little

[22:31] <luqui> no details

[22:31] <luqui> but you mean "language dependent"?

[22:31] <leo> id(2) = id(1+1) 

[22:32] <luqui> that's true?

[22:32] <leo> id(200) != id(100+100)

[22:32] <luqui> ack!

[22:32] <leo> ==

[22:32] <svk_frank> Python ! Rules

[22:32] <leo> so how to test for the same value, if some are cached

[22:32] <leo> i.e reuses

[22:33] <luqui> well, anyway, in perl 6, === tests for value equality for value types

[22:33] <leo> === looks to me just like ==

[22:33] <luqui> visually?

[22:33] <luqui> or semantically?

[22:33] <leo> no above

[22:33] <leo> semantically

[22:34] <luqui> it pretty much is.  except it works on strings too

[22:34] <luqui> and Foo.new === 91875985  will *always* be false, even if that's where Foo lives

[22:34] <luqui> but that's perl 5 semantics anyway

[22:35] <luqui> uh... so, not sure if I answered your question

[22:35] <leo> either it is assuming that the rhs constant is always the same, or it just is a compliated wqy to spell == or eq

[22:35] <luqui> but in summary, there is no way to tell the difference between 1 and 1 in perl 6.

[22:36] <luqui> okay, um:  Foo.new == Foo.new

[22:36] <luqui> coerces Foo.new to a number before comparing

[22:36] <luqui> === does not, it just tests the reference

[22:36] <leo> which ought to be different as these are generating 2 different objects?

[22:37] <luqui> yes

[22:37] <leo> ok

[22:37] <luqui> (unless Foo is declared to be a value type, which it usually isn't ;-)

[22:37] <leo> but still  1 === 1 is a can of worms

[22:37] <luqui> leo, how so?

[22:37] <luqui> we do it not by testing address or id, but by overloading ===

[22:37] <leo> a native int doesn't have and address

[22:38] <avar> ?eval [*] 1..10

[22:38] *** evalbot_8396 is now known as evalbot_8404

[22:38] <evalbot_8404> 3628800 

[22:38] <luqui> right, and === doesn't tests "address equality", it tests "sameness"

[22:38] <luqui> for our definition of "sameness"

[22:38] <luqui> we want 1 to be the "same" as 1

[22:38] <leo> ah ok

[22:38] <leo> is there an address eq op?

[22:38] <luqui> nope

[22:38] <luqui> value types are referentially transparent.  you can't ever tell one from the other

[22:39] <luqui> (well, not without hackery)

[22:39] <leo> okie then - that answered it - thanks

[22:39] <luqui> sure

[23:30] <luqui> ?eval sub foo (@a) { say @a.perl }  foo([1,2,3])

[23:30] <evalbot_8404> OUTPUT[[[1, 2, 3],] ] bool::true 

[23:31] <luqui> ?eval sub foo (@a) { say @a.perl }  foo(1,2,3)

[23:31] <evalbot_8404> Error: No such sub: "&foo" 

[23:46] <avar> ?eval (1,2,3)

[23:46] <evalbot_8404> (1, 2, 3) 

[23:46] <avar> ?eval sub x(*@x) { say @a.perl }; x(1,2,3);

[23:46] <evalbot_8404> Error: Undeclared variable: "@a" 

[23:46] <avar> ?eval sub x(*@x) { say @x.perl }; x(1,2,3);

[23:46] <evalbot_8404> OUTPUT[[1, 2, 3] ] bool::true 

[23:46] <avar> there

[23:46] <avar> you have to use *

[23:48] <luqui> that's not what I was testing

[23:48] <luqui> but thanks anyway

[23:50] <avar> mm

