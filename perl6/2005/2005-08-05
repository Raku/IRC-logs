[00:09] <brentdax> ...that just might be the weirdest thing I've ever seen a Pugs program do.

[00:11] <brentdax> Basically, I use an s/// in a while loop to extract two fields from a string.  Stringify $0 and mess with the result, and somehow things that depend on...oh, hmm...

[00:13] <brentdax> Are the $N variables lexical yet?

[00:39] <stevan> iblech: re: [18:13] 	<iblech>	stevan: class Foo {...}; say Foo.ref; say ::Foo.ref; say Foo.meta.ref  # what should these print?

[00:40] <stevan> I am not sure about .ref

[00:41] <stevan> .ref on a class has more relevance in p5 since that is the crux of that object model

[00:41] <stevan> (or lack of an object model)

[00:41] <stevan> so I think Foo, ::Foo and Foo.meta should act like all other types

[00:41] <stevan> basically whatever Array.ref, ::Array.ref would od

[00:42] <stevan> then Foo.meta.ref is just asking Foo's metaclass instance what it's ref is

[00:42] <stevan> so it is not all that different from MetaClass.ref

[00:42] <mugwump> So, ::Foo.ref would be some subclass of "Package", presumably?

[00:42] <stevan> but to be totally honst, I am making this all up, and you should ask p6l

[00:43] <stevan> mugwump: I dont know, I dont think of ::Foo as a reference

[00:43] <stevan> it is an instance of Class

[00:43] <stevan> ::Foo.isa(Class)

[00:44] <stevan> is .ref() really as useful with P6Opaque objects? as it was with Perl5 blessed refs

[00:44] <stevan> I think that is the basic question

[00:44] <stevan> my $foo = \::Foo;

[00:44] <stevan> maybe then $foo.ref is Class

[00:44] <mugwump> well, to me it's asking what the type of something is.  Perhaps it would be better called .type

[00:44] <stevan> mugwump: ok

[00:44] <stevan> then Foo.ref would be Foo?

[00:45] <stevan> ::Foo.ref would be Class?

[00:45] <stevan> and Foo.meta.ref would be MetaClass?

[00:45] <stevan> I think that make some sense

[00:45] <stevan> however, Class.isa(Object)

[00:45] <stevan> and MetaClass.isa(Object)

[00:46] <stevan> so maybe like ::Foo.ref returns a type junction (Object|Class)

[00:46] <stevan> etc

[00:46] <stevan> but I am not sure that makes a lot of sense either

[00:47] <stevan> iblech: I would run it up the p6l flagpole

[00:47] <stevan> and see what @Larry has to say

[00:48] <stevan> ok, movie time, ... later all &

[00:49] * mugwump waves

[06:15] <brentdax> Is m:c (continue from previous position) implemented?

[06:58] <autrijus> brentdax: no

[06:58] <autrijus> write up some tests?

[06:58] <brentdax> Hmm, okay.  Maybe I can find another way...

[06:58] <autrijus> are you using it with pcre?

[06:59] <brentdax> No, PGE preferably.  I did some checking, and it looks like they changed what I want to :p since A5 was put out--there are some tests in t_disabled, but they crash for seemingly unrelated reasons (pos isn't implemented).

[07:01] <autrijus> okie.

[07:01] <svnbot6> r6080 | scook0++ | * Unbreak Haddock, using #ifndef and whitespace

[07:01] <svnbot6> r6080 | scook0++ | * Misc. Haddocks and fixes

[07:01] <autrijus> funny, we do have pos

[07:01] <Aankhen``> Morning.

[07:01] <autrijus> but for match objects

[07:01] <autrijus> not the string itself

[07:02] <autrijus> I forgot whether string itself carries pos information anymore

[07:02] <autrijus> hey Aankhen``

[07:02] *** ods15_ is now known as ods15

[07:03] <Aankhen``> What's new in Pugs?

[07:04] <autrijus> theology :)

[07:04] <Aankhen``> Kewl.

[07:05] <autrijus> I'm beginning to see the huge gap between static object systems and dynamic ones.

[07:05] <Aankhen``> Neat!

[07:06] <autrijus> ...and, ignoring the impossibility, thinking of ways to unify them.

[07:06] <autrijus> (which means more paper reading and prototyping)

[07:06] <Aankhen``> Heh.

[07:07] <autrijus> a rich typesystem and a rich metaobject protocol rarely exist together, after all

[07:08] <autrijus> you usually have one or the other

[07:09] <coral> hmm

[07:11] <coral> "There are no languages that have both counters and gender-- if you classify your nouns one way, you don't classify them the other way."

[07:11] <coral> "English is one of the rare languages that has neither counters nor gendered nouns."

[07:11] <coral> ttp://www.mindspring.com/~kimall/Japanese/numbers.html

[07:11] <autrijus> ;)

[07:11] * coral &

[07:12] <autrijus> at one end we can restrict all the theology -- I mean MOP -- as read-only

[07:12] <autrijus> that is ways to reflect into the runtime, but never changing it

[07:13] <autrijus> and focus on the typefulness (MMD, Generics, Roles, inferencing) to provide flexibility

[07:14] <autrijus> on another end we can do what CLOS does and embrace Apotheosis -- making _everything_ tweakable at runtime, and the compile time typing are merely hints, or assertions.

[07:15] <coral> is there a third route, do neither?

[07:15] <autrijus> I have no idea. I suspect yes.

[07:15] <coral> the lack of such strictures serves english well in usage

[07:16] <autrijus> but makes it a pain to reason with.

[07:18] <coral> i've begun to discard certain englishisms as impractical

[07:18] <coral> one thing, two things

[07:18] <coral> zero things

[07:18] <coral> fools' errand

[07:18] <coral> eh, too tired

[07:18] * coral &

[07:37] <stevan> morning autrijus, coral 

[07:37] <stevan> autrijus: I see you have MOP on the mind :)

[07:37] <stevan> it is very addictive

[07:39] <stevan> autrijus: not sure if you saw this (http://use.perl.org/~Stevan/journal/) 

[07:40] <stevan> I figured I should try this blog thing a bit

[07:40] <stevan> anyway, time for me to sleep &

[07:41] <autrijus> stevan: I had. :)

[07:41] <autrijus> journaling++

[07:41] <autrijus> g'nite stevan!

[07:41] <brentdax> If match objects have a pos(), how do I use it?  Just do $/.pos?

[07:42] <autrijus> $/.from and $/.to

[07:42] <autrijus> also all the subobjects too

[07:42] <brentdax> Ah, alright...

[07:42] <autrijus> $0<foo>[3].from

[07:42] <autrijus> etc

[07:44] <brentdax> Okay, thanks.

[07:45] <brentdax> Hmm, looks like :pos is broken anyway.  Maybe I can fake it with something along the lines of /^.**{$lastlen}/, though.

[07:46] <autrijus> nod.

[07:46] <autrijus> but please write tests :)

[07:46] <autrijus> for the pcre subset

[07:46] <autrijus> not rules (the implementation should carry over)

[07:47] <autrijus> I mean for the m:c and/or m:pos

[07:47] <autrijus> and I'm not sure that having the string remembering the pos() is a hot idea after all

[07:47] <autrijus> but that's the spec, I'll do it

[07:47] <brentdax> I wouldn't be surprised if PCRE handles this stuff--I'm just trying to use rules whenever I can, because that's what the final system will use everywhere, so it means less rewriting.

[07:48] <autrijus> ah ok.

[07:48] <autrijus> rx:P5 will also be supported universally :)

[07:48] <autrijus> but yeah, future proofing == good

[07:48] <brentdax> Heh.

[07:48] <autrijus> brentdax++ # pushing the envelope

[07:48] * brentdax bows.

[07:49] <brentdax> (Says the guy who's implementing one of the most complex procedural/OO languages ever designed in a functional language...)

[07:50] <autrijus> ah, I'm just this coding monkey, you know? :)

[07:50] <brentdax> There's modest, and there's too modest.  :^P

[07:51] * autrijus purrs

[07:52] <brentdax> ...it's a sad day in the life of a Perl hacker when he runs out of characters to use as regex delimiters.

[07:53] <scook0> unicode to the rescue? :-)

[07:53] <autrijus> you can use unicode :)

[07:54] <autrijus> I recomment U+236A APL FUNCTIONAL SYMBOL COMMA BAR

[07:54] <autrijus> s/recomment/recommend/

[07:54] <brentdax> Heh.

[07:55] <brentdax> Sadly, I'm not sure I have a font that'll support it.  Guess I'll stick to French quotes or something.

[08:08] <autrijus> bbiab... &

[08:53] <kgftr|konobi> castaway: moo

[08:54] <castaway> woof

[08:56] <castaway> what up?

[08:59] <kgftr|konobi> castaway: not much... when you going to be getting into the UK?

[09:00] <castaway> This is a good question.. according to current plans, the 23rd or so

[09:00] <castaway> (of august natcherly)

[09:00] <brentdax> & #sleep, and the mental regrouping that goes with it.

[09:00] <castaway> Which reminds me, I wanted to ask if theres any useful bus services around there

[09:02] <castaway> We may or may not have a flat by then, depending on how fast things get processed.. 

[09:04] <kgftr|konobi> castaway: there's buses every 10 mins or so between central oxford and abingdon during peak times

[09:04] <castaway> right, but they dont actually come past the pentagon?

[09:05] <kgftr|konobi> castaway: nope... pentagon is about 5-10 min walk from centre of abingdon

[09:05] <castaway> ah, ok then :)

[09:05] * castaway ponders a bike

[09:06] <kgftr|konobi> castaway: you looking to more to oxford rather than abingdon then?

[09:06] <castaway> Nope, abingdon

[09:06] <kgftr|konobi> ah... k

[09:06] <castaway> but we'll probably be carless for a while

[09:06] <castaway> looking at the south corner, hobbs close, etc

[09:07] <kgftr|konobi> castaway: 2 secs

[09:07] * castaway nods

[09:07] <kgftr|konobi> castaway: ah yeah... very close

[09:08] <kgftr|konobi> castaway: yer other half got any work sorted yet?

[09:08] <castaway> http://desert-island.dynodns.net/perl/abingdonrental.html (googlemaps++)

[09:08] <castaway> Nope, but he did get his Visa issued! So we can start looking now :)

[09:09] <castaway> allo nm

[09:09] <ods15> hello nothingmuch, if you are there. hi

[09:11] <nothingmuch> hola

[09:11] <ods15> hehe

[09:11] <nothingmuch> castaway: theorbtwo get a visa? w00t!

[09:11] <castaway> yup :)

[09:12] <ods15> lol i just noticed, nothingmuch, you just joined the channel :P

[09:12] <kgftr|konobi> castaway: what sort of work he looking for?

[09:13] <nothingmuch> ods15: well, i did say I lived here, didn't I?

[09:13] <ods15> i joined the channel last night, and saw you were in it, at this point i was active and just figured you were here... didn't notice you JUST joined..

[09:13] <ods15> hehe.

[09:14] <castaway> kgftr|konobi: Similarly to me, but lower entry level probably, since he has little work experience.. 

[09:14] <nothingmuch> ah... I didn't pay attention to the channel last night

[09:14] <castaway> Need any junior programmers? :)

[09:14] <nothingmuch> and now i'm done doing morning stuff

[09:14] <kgftr|konobi> castaway: heh, not in the web dept i'm afraid

[09:15] <castaway> darn :)

[09:15] <castaway> morning? I though it was later over there, nm? (11:14 here)

[09:16] <castaway> And preferably in the area, of course

[09:16] <nothingmuch> i woke up ~10:00

[09:16] <kgftr|konobi> castaway: perl stuff specifically or what?

[09:17] <castaway> Yup, perl stuff

[09:17] <kgftr|konobi> hhhmmm... ox.ac.uk may have something... 2 secs

[09:17] <castaway> nifty

[09:17] <ods15> so, umm, does perl6 actually work

[09:18] <castaway> pugs does, for some definition of work (which changes daily)

[09:18] <QtPlatypus> pugs works.

[09:18] <QtPlatypus> like castaway said

[09:18] <ods15> pugs are like fleas?

[09:19] <castaway> pugs is what this channel is about, see title

[09:19] <castaway> (s/title/topic/

[09:20] <ods15> heh, just noticed, topic says 'Pugs 6.2.9', i thought it said Perl...

[09:20] <QtPlatypus> pugs is an implementation of perl6

[09:20] <ods15> hmm, is this the official implementation of perl6?

[09:21] <kgftr|konobi> it's "an" implementation of perl6

[09:21] <castaway> official, no

[09:23] <ods15> didn't know there was several implementations...

[09:23] * nothingmuch goes to do a favour

[09:23] <kgftr|konobi> castaway: http://www.ox.ac.uk/jobs/

[09:23] <ods15> i always considered much of perl's advantage is that there's a single implementation

[09:24] <nothingmuch> ods15: that's both an advantage and a limiting factor

[09:25] <nothingmuch> right now there's a problem: the "official" perl 6 is getting nowhere

[09:25] <castaway> Thanks, will have a look!

[09:25] <nothingmuch> pugs, on the other hand, is pretty far along

[09:25] <osfameron> is anyone working on a backend targetting mono or jvm?

[09:25] <ods15> sounds like perl6 is analogous to mplayer G2 :)

[09:26] <kgftr|konobi> castaway: http://www.admin.ox.ac.uk/ps/gp/current/http038.shtml - that's in headington (part of oxford)

[09:26] <ods15> i still don't like the idea of several perl implementations.. it's one of the reasons C is in such poor state...

[09:27] <ods15> ("The great thing about standards is that there's so many to choose from!")

[09:27] <nothingmuch> ods15: perl 6 is right now being slightly redesigned with this in mind

[09:27] <nothingmuch> the garbage collection api is just being discussed on the perl6-language mailing list

[09:27] <castaway> Mmm, debian.. 

[09:28] <kgftr|konobi> TIMTOWDI

[09:28] <nothingmuch> there is a relative concensus that the api should be requirement oriented

[09:28] <nothingmuch> so that if you clearly state your requirements for where they matter, it doesn't matter what garbage collector you use

[09:28] <ods15> heh. i think... i don't like where this is going...

[09:29] <nothingmuch> lots of perl 5 code was written "unportably" in this sense: circular references were weakened, timely destruction was relied upon, and so forth

[09:29] <nothingmuch> in perl 6 you may be running under an embedded environment, where it's more efficient to do some kind of garbage collection

[09:29] <ods15> i like perl as a string parser.. it's very good at that.. however i don't like the idea of people writing big OO projects in it...

[09:30] <nothingmuch> and the same code might run on a multiprocessor machine, where you would prefer a multithreaded GC

[09:30] <nothingmuch> ods15: that's what perl 6 is fixing

[09:30] <nothingmuch> it's OO model is divine

[09:30] <ods15> GC?

[09:30] <nothingmuch> garbage collection

[09:30] <ods15> ah

[09:30] <nothingmuch> perl 6 is not just another scripting language

[09:30] <ods15> nothingmuch: then it should not be called perl...

[09:30] <nothingmuch> perl is not just a scripting language either

[09:30] <osfameron> ods15: perl 5 is not just another scripting language either

[09:30] <nothingmuch> but it's harder to see that

[09:31] <jdv79> p5 isn't all that performant by the way when you try to put regexes under pressure

[09:31] <ods15> i hope perl6 doesn't make the same mistake C++ did

[09:32] <castaway> perl isnt either (wait, people already said that )

[09:32] <nothingmuch> ods15: what is that mistake?

[09:32] <ods15> an infinitely complex language

[09:32] <ods15> is not as good as a simple one

[09:32] <nothingmuch> whttp://dev.perl.org/perl6/doc/synopsis.html

[09:32] <nothingmuch> that's where perl 6 is specced

[09:32] <jdv79> since when was perl ever simple?

[09:32] <nothingmuch> it's pretty big and complex

[09:32] <castaway> (otoh I agree that perl6 doesnt seem to be very perl-like)

[09:33] <nothingmuch> but once you start knowing them, you see that it's very consistent

[09:33] <ods15> jdv79: hence not being a good pick for OO projects

[09:33] <castaway> OO projects? (danger will robinson :)

[09:33] <integral> is C++ "big and complex" and hence not a good pick for OO projects too? 8-)

[09:33] <jql> perl5 is latin. perl6 is the set of romance languages we have today

[09:33] <QtPlatypus> nothingmuch: I still would like to be able to send non portable tuning infomation into the GC.

[09:34] <castaway> kgftr|konobi: I like how all their jobs have the same salaray (range :)

[09:34] <nothingmuch> QtPlatypus: in that case you have to introspect the environment, and see what kind of GC you're running under

[09:34] <ods15> integral: yes, exactly

[09:34] <QtPlatypus> For example I would like to say, "If I have a geneational GC, I would like it to have 5 generations"

[09:34] <castaway> (speaking of C++ anyone care to give me a hand with some?)

[09:34] <ods15> castaway: i know (quite) a bit

[09:35] <nothingmuch> but the requirement oriented GC api needs to be 100% portable, since it will probably be used in library code

[09:35] <ods15> integral: C++ is a horrible language

[09:35] <integral> ods15: the original stuff wasn't so bad since there wasn't so much then,  but the way it's grown hasn't made it simpler

[09:36] <ods15> i'd hate to say it, but Java and C# are much better. I've never actually used python, but i think it's good as a "project" language too

[09:36] <nothingmuch> java doesn't have closures!

[09:36] <ods15> integral: exactly. they increased complexity instead of reducing it

[09:37] <ods15> nothingmuch: bah, i dunno what that means :)

[09:37] <jql> whatcha wanna know about C++?

[09:37] <jql> :)

[09:37] <GeJ> regarding the GC API, while I agree that the idea is really interesting, I'm afraid of the problems it could generate. Lets say two modules used in one application that both override the GC settings in an incompatible way.

[09:37] <integral> OTOH I'm not sure I completely agree about perl5,  the thing I think it's lacking (and p6) fixes is nice easy things like class{} to implement a metamodel

[09:37] <ods15> i have a project in it

[09:37] <nothingmuch> ods15: do you know the 'map' function in typical functioanl languages?

[09:37] <ods15> nothingmuch: not really

[09:37] * jql admits a shameful preference for VB.NET over C#.NET

[09:39] <ods15> jql: same shit different flavor :)

[09:39] <QtPlatypus> GeJ: It would depend on how the settings could be scoped.

[09:39] <ods15> i think computing has reached a solid point where.. all programming languages suck. some just suck less.

[09:39] <jql> prettier

[09:39] <jql> :)

[09:39] <nothingmuch> http://www.rodadams.net/Perl/S29.html

[09:39] <nothingmuch> search for rthe definition of map under there

[09:39] <GeJ> QtPlatypus: GC settings would be module-related? That would be nice indeed :)

[09:39] <ods15> maybe we should all just switch to brainfuck

[09:40] <nothingmuch> the first argument of map is a function.

[09:40] <nothingmuch> ther rest is a list

[09:40] <nothingmuch> the result is a list of elements, with the function applied to every element

[09:40] <ods15> hmm

[09:40] <ods15> ah, so, it's umm, nothing

[09:40] <nothingmuch> if lisp is nothing it's nothing

[09:41] <ods15> why not just make a silly for :)

[09:41] <nothingmuch> because the function is a parameter

[09:41] <ods15> ... so?

[09:41] <castaway> LISP++

[09:41] <nothingmuch> with a for loop you can't supply the body of the loop as a parameter

[09:41] <ods15> yes you can

[09:42] <nothingmuch> well, not in the languages I know

[09:42] <ods15> for(i = 0; i < 50; i++) func(arr, i);

[09:42] <ods15> where func can be a function pointer...

[09:42] <nothingmuch> ook

[09:42] <nothingmuch> that's not really what I meant

[09:42] <nothingmuch> ofcourse you can make a body that applies a function in a var

[09:43] <nothingmuch> but nevermind, i have to go, i'll give you some more fp-fu later

[09:43] <ods15> ok

[09:43] <integral> but you're having to type out the body each time?

[09:43] <ods15> just whats fp-fu?

[09:43] <ods15> integral: umm, how is this different from map? i don't understand

[09:43] <QtPlatypus> GeJ: Some settings can be lexically scoped.  I know some can be applied just to values or collections of values (Such as Timely and Tardyness).  Others I think will just be last setting wins.

[09:44] <integral> ods15: well with map you've hidden how the iteration works

[09:44] <ods15> ok, change:

[09:44] <integral> ods15: and map can apply to different datastructures too (things that are Functors in haskell)

[09:44] <ods15> for(i = 0; i < 50; i++) arr[i] = func(arr[i]);

[09:45] <integral> ok, that's another thing which has a similar type to map

[09:45] <ods15> integral: explain to me what exactly is the difference between this and map?

[09:46] <integral> that does an in place update,  map (in perl) returns the concatenation of the list results of the functions

[09:46] <ods15> it returns.. what?

[09:46] <ods15> "@arr" ?

[09:47] <integral> in perl map calls the given function once for each element in the input list, and returns a list which consists of all the results of the functions concatenated together

[09:47] <castaway> fp-fu is probably function pointer fu

[09:47] <ods15> this is obviously not valid C, but you get the idea:  for(i = 0; i < 50; i++) str += arr[i] = func(arr[i]);

[09:47] <integral> castaway: I'd guessed "functional programming"...

[09:48] <ods15> integral: so, umm, it returns arr?

[09:48] <integral> ods15: in perl map is like: my @result; for my $e (@input) { push @result, f($e) }

[09:48] <castaway> well I'm not sure where the -fu comes from.. it means 'knowledge' kind of

[09:48] <integral> it returns a new list

[09:48] <ods15> integral: ah

[09:48] <ods15> i forgot what was the point of this conversation

[09:49] <jql> perl6's map is cooler

[09:50] <ods15> i think i'm just not cut out for this. i like lower level programming more.. (not asm, but not high OO either)

[09:50] <jql> to each his own, as long as it's Perl

[09:51] <ods15> .. C!

[09:51] <QtPlatypus> castaway: It comes from kungfu

[09:51] <castaway> Perl!

[09:51] <castaway> (wrong channel for that, ods15  :)

[09:51] <ods15> castaway: :D

[09:52] <ods15> I like MPlayer BTW, that's my kind of programming...

[09:52] * jql can picture someone making a C eval grammar for perl6

[09:52] <ods15> bleh

[09:52] <castaway> Inline::C you mean?

[09:52] <ods15> lol

[09:52] <ods15> what's it based on, libtcc? :)

[09:52] <jql> not Inline::C. I mean eval

[09:53] <castaway> norra clue

[09:53] * castaway avoids C like the plague

[09:53] <castaway> except when work insists..

[09:53] <jql> actually parse a C function into a Perl script, type and all

[09:53] * ods15 avoids the plague

[09:53] <integral> C->LLVM->PIL2->LLVM->C :-)

[09:54] <castaway> ah..

[09:54] <jql> make sure to add a ->PMC->Parrot at the end

[09:54] <castaway> mebbe theres a Parse::RecDescent for it..

[09:54] <integral> heh

[09:54] <castaway> but honstly, that'd be a bit daft

[09:54] <integral> jql: good thought that :-)

[09:54] <integral> iirc there's some C lib for o'caml

[09:54] <ods15> only in C can you do crap like  int c[10]; (!!c)[c] = 1["bla"]; 

[09:54] <nothingmuch> ods15: now in haskell map is nice

[09:54] <nothingmuch> it's part of a type class

[09:54] <nothingmuch> you can map a tree

[09:54] <nothingmuch> and you can map a list

[09:55] <nothingmuch> and you can map a moose

[09:55] <nothingmuch> as long as the type class has an instance on said type

[09:55] <ods15> nothingmuch: you got me confused

[09:55] <ods15> what are you babbling about

[09:55] <nothingmuch> map is a combinator

[09:55] <integral> and with generic haskell map and other can be automatically derived from the type definition

[09:55] <ods15> hmm

[09:55] <nothingmuch> it takes a function that applies to an element

[09:56] <nothingmuch> the function is not concerned with the structure

[09:56] <nothingmuch> nor is the call to map

[09:56] <nothingmuch> it's only the definition of the structure that must worry about it

[09:56] <ods15> hmm

[09:56] * castaway maps moose (or meese?)

[09:56] <nothingmuch> castaway: the plural of moose is moose

[09:56] <castaway> jojo

[09:56] <ods15> deer

[09:56] <castaway> sounds like walk_mapping

[09:56] <ods15> so, umm, the struct has to define a "map return and set" value?

[09:57] <ods15> could you just tpype this out in your favorite pseudo language? i hate understanding words

[09:57] <nothingmuch> uh, yep

[09:57] <castaway> (even if its perl?)

[09:57] <ods15> castaway: yes, even vb if you preffer

[09:57] <ods15> just not brainfuck

[09:57] <castaway> or Ook!

[09:58] <ods15> MOO

[09:58] * castaway cant do MOO, only LPC

[09:58] <ods15> there's ofcourse also whitespace...

[09:58] <nothingmuch> integral: i forgot what the TC of mappable is... Functor?

[09:59] <ods15> which i still think is better than python...

[09:59] <castaway> whitespace?

[09:59] <castaway> (Acme::Bleach?)

[09:59] <ods15> castaway: never seen it?

[09:59] <castaway> nope

[09:59] <ods15> a language completely based on space tab and return

[10:00] <integral> nothingmuch: yep, Functor

[10:00] <castaway> sounds like Ook! oder bf

[10:00] <castaway> s/oder/or/

[10:00] <ods15> ook is identical to brainfuck

[10:00] <ods15> whitespace is a completely different dialect

[10:00] <jql> space & tab represent the bits, IIRC

[10:01] <jql> space 0, tab 1, or perhaps the other way round

[10:01] <ods15> have a look at www.99-bottles-of-beer.net

[10:01] <ods15> i like that perl won first place in that site...

[10:01] <ods15> jql: nah, iirc they do some kind of stack manipulation..

[10:02] <jql> I meant for Acme::Bleach

[10:02] <ods15> oh

[10:02] <jql> BF is a turing-type monstrosity

[10:02] <ods15> i dunno what that is

[10:02] <ods15> so is whitespace, i think

[10:02] <castaway> you use that module in your perl code, and your source code ends up looking like just whitespace

[10:03] <nothingmuch> integral: uuh, you take over

[10:03] <ods15> "bleach" as in, the cleaning product?

[10:03] <nothingmuch> fglasgow-exts is not letting me derive Functor

[10:03] <integral> nothingmuch: oh, you can't in standard haskell afaik

[10:03] <nothingmuch> oh

[10:04] <ods15> what languages is pugs?

[10:04] <ods15> haskell? never heard of it...

[10:04] <castaway> yes that product

[10:04] <integral> data Maybe a = Nothing | Just a; instance Functor Maybe where { fmap f Nothing = Nothing; fmap f (Just x) = f x }

[10:04] <castaway> Its written in Haskell

[10:05] <ods15> integral: was what you typed just now a sentence or code...

[10:05] <integral> ods15: code! :-)

[10:05] <ods15> horrible

[10:05] <QtPlatypus> Loose like hascall

[10:05] * castaway runs away at the sight of Haskell

[10:05] <ods15> next thing you'll start using ThisIsAnIterator instead of 'i'...

[10:05] <nothingmuch> ods15: huh?

[10:06] * integral underlines the use of "a", "f" and "x" ;-)

[10:06] <ods15> integral: ok :)

[10:06] <nothingmuch> ods15: Maybe x means that the value is either Just x or Nothing

[10:06] <ods15> using more than 2 chars for an 'i' is braindead.. i've seen some people actually do counter and kounter

[10:06] <castaway> picky picky

[10:07] <integral> data Stream a = MkStream a (Stream a); instance Functor Stream where { fmap f (MkStream x s) = MkStream (f x) (fmap f s) }

[10:07] <ods15> nothingmuch: i don't get it

[10:07] <nothingmuch> so Maybe Int allows you to add an out-of-bounds state to data types

[10:07] <nothingmuch> anyway, never mind

[10:07] <ods15> :)

[10:07] <nothingmuch> the point is that lets say you have a function that returns a tree

[10:08] <nothingmuch> you can map that tree into another

[10:08] <ods15> thats pretty non specific

[10:08] <nothingmuch> where the structure is the same

[10:08] <nothingmuch> but the elements are changed by the function that applies to elements

[10:08] <ods15> ok...

[10:08] <nothingmuch> the function that applies to elements doesn't know whether what it's being applied to is an element of a tree or a list, or anything

[10:08] <nothingmuch> th

[10:09] <nothingmuch> the code mapping a structure into another using a function also doesn't need to know about the structure

[10:09] <nothingmuch> or the function

[10:09] <nothingmuch> or the elements

[10:09] <nothingmuch> (it should probably know of one of these in order to be useful)

[10:11] <integral> data Foobar a b = Foo a | Bar b; newtype Bar b a = MkBar a b; instance Functor (Foo a) where { fmap f (Foo x) = Foo x; fmap f (Bar y) = Bar (f y) }; instance Functor (Bar b) where { fmap f (MkBar (Foo x)) = MkBar (Foo $ f x); fmap f (MkBar (Bar y)) = MkBar (Bar y) } # argh

[10:12] * ods15 screams

[10:12] <integral> hmm, s/MkBar a b/MkBar (Foobar a b)/

[10:12] <ods15> nothingmuch: ok, is a "tree" something the user has defined or is there such a data structure built into the language?

[10:12] <nothingmuch> ods15: either or

[10:12] <jql> hmm... that code could use some $'s to break up the mind-numbing textyness

[10:12] <nothingmuch> i'm not sure if Data.Graph and friends have Functor instances, bu tthey should

[10:12] <nothingmuch> at least DAG graphs

[10:13] <ods15> how on earth would 'map' know how to iterate over the tree

[10:13] <nothingmuch> ods15: it's just simple polymorphism

[10:13] <ods15> it transforms into a cat?

[10:13] <nothingmuch> nope

[10:14] <nothingmuch> an appropriate implementation of 'map' is chosen, WRT the data structures involved

[10:14] <integral> data Tree a = Branch (Tree a) (Tree a) | Leaf a; instance Functor Tree where { fmap f (Leaf x) = Leaf (f x); fmap f (Tree x y) = Tree (fmap f x) (fmap f y) }

[10:14] <ods15> integral: binary tree!

[10:14] <ods15> hey, i get it

[10:15] <nothingmuch> okay then, now go beyond map

[10:15] <nothingmuch> foldl, foldr

[10:15] <ods15> when you define a thingy, you make a function for mapping, that either returms (or sets) the value, OR iterates over the rest of the .. strcture

[10:15] <ods15> yes?

[10:15] <ods15> (did i understand right?)

[10:15] <nothingmuch> no, it just itertates the structure

[10:15] <integral> yes

[10:15] <nothingmuch> applying the function to each element

[10:16] <nothingmuch> and returning the same 'shape' but with different elements

[10:16] <ods15> ok, anyway, umm, i've forgotten the point?

[10:16] <nothingmuch> the point is that these relate to closures:

[10:16] <nothingmuch> higher order functions

[10:16] <nothingmuch> and java doesn't have them

[10:16] <nothingmuch> so it sucks

[10:16] <ods15> whats closures

[10:17] <nothingmuch> okay, now, given map, we can either give it a qualified function

[10:17] <integral> nothingmuch: I'm not entirely convinced by that personally, since everything you can do with closures you can do with objects

[10:17] <nothingmuch> or something we just made up

[10:17] <nothingmuch> integral: the issue is choices

[10:17] <ods15> also, if i understood correctly, you've introduced the recursion from hell

[10:17] <nothingmuch> i interleave functional/object oriented programming in perl, and that's why i like perl

[10:17] <nothingmuch> ods15: haskell has tail recursion optimization.

[10:17] <integral> ods15: recursion only exists for data structures that are recursive :-)

[10:18] <nothingmuch> all control structures are moot

[10:18] <integral> So for a Maybe (which can be Nothing, or a box with a value in it) there is no recursion

[10:18] <nothingmuch> there is no 'for', 'while', or anything like that

[10:18] <ods15> integral: will this all work correctly for lists?

[10:18] <nothingmuch> since all loops are recursive

[10:18] <QtPlatypus> And most of the funtional lanaguages optimize tail recursion.

[10:18] <integral> ods15: yes, but those are recursive, so you do get recursion

[10:18] <ods15> ..lists are not recursive (?!)

[10:18] <nothingmuch> ods15: lists are recursive

[10:18] <nothingmuch> linked lists

[10:19] <integral> yes they are: data List a = Tail | Link a (List a)

[10:19] <ods15> by definition they are not.. trees by definition are, lists are not...

[10:19] <nothingmuch> by definition a linked list is recursive

[10:19] <ods15> integral: ugh, please stop typing in haskell, it's worse than brainfuck

[10:19] <integral> it's just that the recursion for a list can be done in constant space, but for a tree you can't

[10:19] <nothingmuch> ods15: it's actually very readable

[10:19] <castaway> thats what you say :)

[10:19] <nothingmuch> http://en.wikipedia.org/wiki/Linked_list

[10:20] <ods15> for(it = l->first; it; it = it->next) whatever(it);   // i don't see recursion here

[10:20] <nothingmuch> that's recursion

[10:20] <integral> ods15: struct Link { struct Link *next } /* recursion! */

[10:20] <nothingmuch> it might not be recursion of the for block

[10:20] <nothingmuch> but the structure is recursive

[10:20] <integral> it mentions itself which is quite definately recursion :-)

[10:20] <ods15> then i need to redefine recursion...

[10:20] <nothingmuch> also, in haskell that'll be:

[10:20] <nothingmuch> whatever [] = []

[10:21] <nothingmuch> where the empty list returns the empty list

[10:21] <nothingmuch> oh, wait

[10:21] <nothingmuch> we are throwing that away

[10:21] <ods15> ??

[10:21] <nothingmuch> whatever (x:xs) = (do something to x, and then ) ... whatever(xs);

[10:22] <ods15> integral: ok, but, umm, does map() recurse when iterating over a list or is it smart enough to not do that?

[10:22] <nothingmuch> whatever [] = .... ; # whatever on the empty list

[10:22] <integral> whatever a [] = return (); whatever a (x : xs) = do { a; whatever a xs }

[10:22] <nothingmuch> ods15: it recurses

[10:22] <nothingmuch> it can't not recurse

[10:22] <integral> ods15: it does recurse

[10:22] <nothingmuch> but it's smart enough not to do it

[10:22] <nothingmuch> since there is tail recursion optimization in haskell

[10:22] <ods15> tail recursion?

[10:22] <integral> but because you don't need the previous stack frame it can get thrown away (because it's not a stack ;-)

[10:22] <integral> ods15: void f(struct List *l) { ...; f(l->next) } /* here the call to f in f is tail-recursive */

[10:23] <ods15> yeah, i'd hate to see the backtrace of a 6 million element map()   :)

[10:23] <integral> none of the local variables or arguments stored in the first f's stack frame are needed during the nested call to f, so it just gets binned

[10:23] <integral> So it's got the same performance as a loop (memory-wise)

[10:23] <ods15> integral: lemme understand map correctly, in more or less pseudo code:

[10:23] <nothingmuch> map [] = []

[10:23] <nothingmuch> uh, map f [] = []

[10:23] <ods15> nothingmuch: hold on a second...

[10:24] <nothingmuch> map f (x:xs) = (f x):map f xs

[10:24] <integral> void map (func_ptr_t f, list_ptr l) { f(l); map(f, l->next) } /* map in C, modulo typedefs */

[10:24] <nothingmuch> integral: no, map constructs a result list

[10:24] <integral> nothingmuch: erk, true :-)

[10:25] <ods15> hmm

[10:25] <ods15> integral: how does that work in trees though

[10:25] <nothingmuch> ods15: it doesn't

[10:25] <integral> ods15: it doesn't :-)

[10:25] <nothingmuch> there's also a map that works on trees

[10:25] <ods15> ... didn't you just say it does :)

[10:25] <integral> To traverse a tree iteratively typically you keep your own stack, right, ods15 ?

[10:25] <nothingmuch> well, not 'the' map, 'a' map works on trees

[10:25] <ods15> integral: ok, so i've lost the point again

[10:26] <ods15> if map() doesn't work on trees, whats the point!

[10:26] <integral> it does work,  it's just a different definition

[10:26] <ods15> just do  for(it = l->first; it; it = it->next) whatever(it);

[10:26] <nothingmuch> ods15: for some really novel example of higher order functions look in SICP

[10:26] <integral> there is one map defined for lists, one for maybes, one for trees

[10:26] <nothingmuch> they discuss a wonderful way of calcualting the square root

[10:26] <integral> but they can all be called as: fmap f d for any datastructure d supporting fmap

[10:27] <ods15> bah, binary search is good enough for that :P

[10:27] <integral> iirc that's what the SICP implementation uses :-)

[10:27] <nothingmuch> binary search does not return the same shape with different elements

[10:27] <nothingmuch> oh wait

[10:28] <nothingmuch> yes, the square root solution is a binary search... *blush*

[10:28] <integral> maybe a good example is sum, product, etc?

[10:28] <nothingmuch> around here: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%25_sec_1.1.7

[10:29] <integral> sum and product are both very similar as loops: my $accumulator = 0; for my $e (@l) { $accumulator  = $accumulator + $e }

[10:29] <nothingmuch> yep

[10:29] <integral> sub foobar { my ($list, $start, $func) = @_; my $acc = $start; for my $e (@$l) { $acc = $func->($acc, $e) } } # sub sum { my $list = shift; return foobar($list, 0, sub { $_[0] + $_[1] }) }

[10:30] <nothingmuch> product l = reduce (+) 1 l

[10:30] <nothingmuch> uh, that's sum

[10:30] <nothingmuch> no, that's product

[10:30] <nothingmuch> since sum starts with 0

[10:30] <nothingmuch> but you get the picture

[10:30] * integral has a small dislike of reduce ;-)

[10:31] <nothingmuch> reduce f init (x:xs) = reduce (f init x) xs

[10:31] <ods15> ..

[10:31] <nothingmuch> reduce f init (x:xs) = reduce f (f init x) xs

[10:31] <nothingmuch> reduce _ i [] = i

[10:31] <nothingmuch> integral: why?

[10:31] <integral> nothingmuch: foldl + foldr just make more sense to be as a pair

[10:32] <nothingmuch> integral: explainb "to be as a pair"

[10:32] <nothingmuch> do you mean "you just reimplemented folding" ?

[10:32] <nothingmuch> because I know i did =)

[10:32] <integral> (reduce f (f init x) xs) vs. f x (reduce init xs)

[10:33] <integral> nothingmuch: I mean there's a choice between the two, and reduce's name doesn't say which one like the l/r after fold :-/

[10:33] <nothingmuch> right

[10:33] <integral> hmm, do I mean: f init (reduce x xs)

[10:33] <nothingmuch> i agree, but I think that this is side tracking too much from the point that product and sum differ only in the reduction of two values into one value, and the initial value

[10:34] <integral> true :-)

[10:34] <nothingmuch> and that the pattern for doing both can be found in a very concise function

[10:35] <nothingmuch> ods15: anyway, if you're still slightly interested, SICP has video lectures

[10:35] <nothingmuch> they are a very nice intro to functional programming

[10:36] <nothingmuch> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/

[10:39] <ods15> oh lectures, cool. i like lectures. they help me sleep.

[10:39] <nothingmuch> these are not lectures you sleep through =)

[10:39] <ods15> just today i (re)watched some lectures by mike melanson and alex

[10:40] <ods15> it's the ONLY time i ever find MPlayer's -speed option useful

[10:40] <ods15> cause alex talks REALLY slow

[10:41] <GeJ> Hum, what is Perl6-MetaModel? I'm not sure to get it... If I understand, autrijus is 'porting' it to Haskell so we can play with the S12. But what is the implementation in perl5? A blueprint for Mr. A. ? Is it use-able on a p5 application/script?

[10:42] <nothingmuch> GeJ: it might be usable, but likely inconvenient

[10:42] <integral> GeJ: both, and it can be used by the PIL->P5 runtime

[10:42] <nothingmuch> it was a draft, mostly

[10:44] <GeJ> oh, ok. thanks

[10:50] <castaway> If I'm doing: strncpy ( strBeg, (char *) strtmp.c_str(), strLen ); .. how should strBeg be declared?

[10:50] <castaway> (C++ junk)

[10:53] <castaway> hmm.. char strBeg[strLen] seems to work, but I have no earthly clue why.. ,)

[10:54] <nothingmuch> that declares strBeg as a pointer to a char

[10:54] <nothingmuch> and 'alloca's strLen*(sizeOf char) every time that scope is entered

[10:56] <castaway> fine by me as long as it works :)

[10:56] <castaway> if i just "char * strBeg" it seg faults

[10:58] <castaway> (theres that elmex again.. he ever talk?)

[11:09] <nothingmuch> castaway: because you haven't allocated anything

[11:09] <nothingmuch> char * strBeg

[11:09] <nothingmuch> upon entering the function strBeg contains an undefined value or 0, depending on your compiler

[11:10] <nothingmuch> if you then say strBeg = (char *)malloc(n * (sizeOf char));

[11:10] <nothingmuch> then strBeg points to some area in memory

[11:10] <nothingmuch> on the heap

[11:10] <nothingmuch> if you say:

[11:10] <nothingmuch> char strBeg[strLen]; then strBeg also points to some area in memory

[11:10] <nothingmuch> but this time it's on the stack

[11:11] <nothingmuch> so when you leave this scope, and enter another, the data may be overwritten

[11:11] <castaway> hmm, so theres anot a way to have it take any length content?

[11:12] <castaway> I hate C :)

[11:12] <nothingmuch> uh, to malloc enough

[11:12] <nothingmuch> one sec

[11:12] <castaway> my confusion is because I have other code which does:

[11:12] <nothingmuch> you are trying to strn.... something into strBeg?

[11:12] <castaway>   ostringstream ostr01 ( timeout );

[11:12] <castaway>   ostr01 << MisTimeStamp ( sec, 0 );

[11:12] <castaway>   strncpy ( timeout, (char *) ostr01.str().c_str(), cDb2TimeStampStrLen );

[11:12] <castaway> yes

[11:12] <nothingmuch> what do you want to do with strBeg later?

[11:12] <castaway> there, timeout springs into existance as if by magic :)

[11:12] <nothingmuch> okay

[11:13] <nothingmuch> do you want to keep 'timeout' and give it to someone else?

[11:13] <nothingmuch> and also - how big can it grow?

[11:13] <nothingmuch> if the answers are 'yes' or 'big' then you want to say:

[11:13] <castaway> oops, I lied.. timeout is passed in, there..

[11:13] <nothingmuch> timeout = (char *)malloc(cDb2TimeStampStrLen * (sizeOf char));

[11:13] <nothingmuch> eep

[11:14] <ods15> nothingmuch: i don't get your nick

[11:14] <nothingmuch> ods15: my nickname?

[11:14] *** Yaakov_ is now known as Yaakov

[11:14] <ods15> yeah

[11:15] <nothingmuch> it's just a nick =)

[11:15] <ods15> Yaakov? are you the Yaakov i know?

[11:15] * ods15 checks

[11:15] <ods15> not sure, hostmask is different

[11:17] <castaway> anyway, forget the timeout stuff.. the code iterates over the contents of strBeg later, passing it to other thigns and so on

[11:18] <castaway> I guess its fine to size it, if I know the size anyway

[11:18] <castaway> previoud code just did: const char * strBeg = mDataStm.str ();

[11:19] <nothingmuch> okay

[11:19] <Yaakov> ods15: Yes.

[11:19] <nothingmuch> i think that means that mDataStm.str() had a pointer to space it was supposed to write into

[11:19] <ods15> Yaakov: hi!

[11:19] <Yaakov> Hello

[11:21] <castaway> I guess.. it used to be an ostrstream, now its an ostringstream, which is causing headaches

[11:22] <ods15> so, what's haskel implemented in

[11:23] <nothingmuch> ods15: depends

[11:23] <nothingmuch> GHC - the glorious glasgow haskell compiler is implemented in haskell

[11:23] <nothingmuch> there's also nhc and hugs, but i don't know what their implemented in

[11:23] <nothingmuch> hugs is focused on the interactive environment

[11:23] <ods15> i think a good rule of thumb is not to implement a programming language in a language that can't compile itself...

[11:24] <nothingmuch> ods15: ghc can compile haskell to C

[11:24] <nothingmuch> which can be ported to another platform

[11:24] <nothingmuch> compiled with a C compiler

[11:24] <nothingmuch> resulting in a GHC on that platform

[11:24] <nothingmuch> so getting a binary is not that hard

[11:24] <ods15> nothingmuch: but, umm, does that ghc produce valid output?

[11:24] <nothingmuch> for a porter

[11:24] <nothingmuch> ods15: no, never

[11:24] <ods15> lol

[11:24] <nothingmuch> in fact, when you compile haskell code, it's usually just ascii art

[11:25] <ods15> lol?

[11:25] <nothingmuch> seriously though, what kind of question is that?

[11:25] <ods15> nothingmuch: compile a compiler on a platform does not mean it will produce correct output for that platform!

[11:26] <nothingmuch> i just said the C output probably needs to be ported to get a binary

[11:26] <nothingmuch> but it's not junk code

[11:26] <ods15> i'm confused..

[11:26] <nothingmuch> You won't be, after the next episode of Soap

[11:27] <ods15> soap?

[11:28] <nothingmuch> http://en.wikipedia.org/wiki/Soap_%28TV_series%29

[11:28] <GeJ> haha...

[11:28] <GeJ> I almost forgot about that line

[11:28] <GeJ> thanks nothingmuch 

[11:48] <ods15> nothingmuch: so anyway, what i wanted to show you yesterday

[11:48] <ods15> 14:48) ods15@linux15:~ $ grep Oded sources/mplayer/main/AUTHORS

[11:48] <ods15> Shimon, Oded (ods15) [email@hidden.address]
[11:55] <nothingmuch> huh?

[11:55] <nothingmuch> oh

[11:55] <nothingmuch> so what does 15 stand for?

[11:56] <castaway> theres certainly a lot of 15s in there.. mebbe age? :)

[12:00] <ods15> no. it's a random number

[12:00] <ods15> after i've used it for some years i found out my dad actually picked it out, if i would've known that i wouldn't have used it

[12:01] <castaway> ,)

[12:01] * ods15 pokes out castaway's other eye

[12:02] <ods15> you're supposed to say ' )' now

[12:03] <castaway>  )

[12:03] <castaway> or rather (

[12:03] <castaway> or even () ?

[12:03] * ods15 wipes that smile off castaway's face

[12:05] <castaway> nice try :)

[12:05] <ods15> you're supposed to say

[12:05] <ods15>  

[12:05] <ods15> :/

[12:29] * ods15 looks at the tumbleweed roll by

[13:13] *** wilx` is now known as wilx

[13:32] <rafl> Fresh pugs packages for Debian: https://www-user.tu-chemnitz.de/~rafl/Code/Debian/Pugs/

[14:18] <stevan> ok, normally I wouldnt post links to IRC, but this one is just hilarious

[14:18] <stevan> http://bink.nu/Article4655.bink

[14:19] <ods15> bink! binky!

[14:19] <ods15> that was an awesom seinfeld episode. even though it wasn't a seinfeld episode.

[14:22] <osfameron> stevan: ?

[14:27] <gaal> two things worth mentioning:

[14:27] <gaal> 1. it's codenamed "Monad" :)

[14:28] <gaal> 2. it has $_

[14:28] <gaal> eg., http://channel9.msdn.com/wiki/default.aspx/Channel9.MSHSampleScript

[14:31] <ods15> gaal: shalom

[14:31] <gaal> hi.

[14:37] <Aankhen``> I've changed my mind.  I don't want Need For Speed: Most Wanted AND Project Gotham Racing 3.  I want NFS:MW AND Project Gotham Racing 3 AND Test Drive Unlimited.

[14:38] * QtPlatypus guesses that Aankhen`` is a fan of car games.

[14:38] <Aankhen``> Hrm.

[14:38] <Aankhen``> Not quite...

[14:39] <Aankhen``> I like the NFS series.  NFS: Hot Pursuit 2 in particular.  NFS: Underground, the sequel (in name) was disappointing.  NFS: Underground 2 was much better, but still not quite HP2.  Most Wanted combines the Underground and Hot Pursuit styles, and it's got great graphics.

[14:39] <Aankhen``> Project Gotham Racing 3 has mind-blowing graphics.

[14:40] <Aankhen``> Test Drive Unlimited has amazing graphics as well as promising gameplay.

[14:41] <Khisanth> isn't everything suppose to look like a blurr anyway? :)

[14:42] <Aankhen``> No, durr. :-P

[14:43] <Aankhen``> http://www.gamespot.com/xbox360/driving/testdriveunlimited/screens.html?page=27

[14:44] <Aankhen``> Going out, BBL.

[15:30] <iblech> autrijus: Hi, PIL2 questions :)

[15:31] <iblech> my $a; BEGIN { $a = 3 }; say $a   # PIL2?

[15:31] <iblech> sub foo { my $a; BEGIN { $a = 3 }; say $a }  # PIL2?

[15:32] <iblech> And WRT your answer to my class Foo {...} question: That'll work :)

[15:36] <svnbot6> r6081 | iblech++ | PIL2JS: Use real JS "lexicals" for lexicals inside subs.

[15:36] <svnbot6> r6081 | iblech++ |   * sub foo { my $a = 3; return { $a } }; say foo()()  works now.

[15:36] <svnbot6> r6081 | iblech++ |   * sub foo ($a) {       return { $a } }; say foo(3)() works now.

[15:36] <svnbot6> r6081 | iblech++ |   * Probably more speed.

[15:48] * integral hopes the last one get a rude error message :)

[15:48] <iblech> It would certainly simplify PIL2JS :)

[15:49] <iblech> But in Perl 5, or better perl5, &foo will output 3 on the first invocation and undef later on.

[15:49] <putter> brentdax: my $pos = 0;  while 1 { my $m = substr($str,$pos) ~~ /mumble/; $pos = $m.to if $m; ... }  # re :continue

[15:50] <integral> I suppose the former should give an error too,  I'm thinking of what ModPerl::Registry does by wrapping sub{} around code which may contain BEGIN blocks,  and to go from working (because it's at file-level) to broken because it's insane would be bad

[15:50] <putter> hmm, or $m.to + 1.

[15:56] <putter> coral: re nouns/gender - that reminded me some written languages use whitespace to break words, in which case you dont need to write the vowels, some use vowels but no whitespace (you incrementally parse it), and some use both.  the same language may drift among the three with time.  the vowels-no-whitespace need for a preperatory wordbreaking pass was why once the highest praise was "he's so smart, he can read _silently_".

[15:56] <coral> ooh, interesting

[15:57] <putter> (everything tweakable at runtime)++

[15:58] <putter> :)

[15:58] <coral> agreed

[16:02] <QtPlatypus> putter: Curiosuly when we read, we actally read out loud and the suppress our throught movements.  With the correct sensors you can actally detect this.

[16:02] <coral> subvocalization

[16:05] <putter> pos and the target string should really be accessible during the regexp (perhaps via $/) after (pos...) and perhaps before.  during the regexp, the logical place is in the, err, whatever the regexp run state object was called, and could be accessed via $/.  pos on string could be used elsewhen as an api, but blech.  backwards compatibility. :(  last time I looked, seemed need for more speccedness here.

[16:06] <putter> QtPlatypus: neat.  I wonder if it's universal?  if one includes outliers, there seems to be a great variety of human cognitive strategies.

[16:09] <putter> hmm, if /foo/ is "future search", $/ is "present or past search", perhaps  Bar.new($str,$extra_cruft) ~~ /foo/ to add data to initialization of new search?

[16:16] <putter> re C grammar... and with backtracking, you can even parse _un_preprocessed C source (because preprocessor use is so stereotyped). :)  but note "C isnt all that simple" caveats like CIL's (written in ML) http://manju.cs.berkeley.edu/cil/cil017.html  http://manju.cs.berkeley.edu/cil/

[16:18] <sili> which doc covers p6 references/pointers?

[16:25] <putter> looks somewhat nonlocalized.  suggest dumping AES in a directory and grepping.  maybe look at the 02's and then the 06's.  "reference" is the keyword.

[16:25] <putter> does the debian distribution of ghc include ghci?  I've long been puzzled that the binary ghc builds dont.

[16:26] <putter> (the ones distributed by/in association with  ghc)

[16:30] <putter> oh, and re rules, there is also the (as yet unimplemented) rules-as-multi-subs, to which one could pass arbitrary cruft.

[16:30] <putter> wee, caught up.  modulo some missed days last(?) week.

[16:35] <kolibrie> seen stevan

[16:35] <jabbot> kolibrie: stevan was seen 2 hours 16 minutes 26 seconds ago

[16:35] <kolibrie> stevan: getting ready to read through the irc logs from yesterday

[16:36] <kolibrie> do you have a diagram/visualization of the whole metamodel?

[16:36] <velcro> \quit

[16:39] <putter> brentdax: do you have a wish list for rules support?  (I need a "client" to motivate work on rules, lacking stevan++'s capability of working alone for months with all the payoff at the end)

[16:41] <kolibrie> putter: I want to be able to easily extract and/or tag things in documents

[16:41] <kolibrie> such as dates, names, etc

[16:42] <putter> kolibrie: perhaps collect notes as you go?  the beginnings of a "metamodel intro/summary" could be useful.  both for writing backends, general understanding, and frontends (how do I map my language X's model onto p6).

[16:42] <kolibrie> I've got my paper in front of me.

[16:42] <kolibrie> four red squares so far, labeled: role, class, instance, metamodel

[16:43] <putter> kolbrie, so named aliases?  / @foo := <mumble> /  or are names enough / <mumble> <frotz> /;  say $/<mumble>;

[16:43] <putter> :)

[16:43] <kolibrie> I think that names will be enough, but don't know for sure yet

[16:43] <dudley> kolibrie: Make sure you're up on your Gnostic metaphysics...

[16:44] <iblech> putter: (Weird idea I have had for quite some time now) $some_str.substr(3, 5).tags<some_tag> = "hi"; say $some_str.substr(4, 1).tags<some_tag> # should print hi

[16:44] <kolibrie> dudley: I'm sure I'm behind in that field

[16:44] <dudley> I spent way too much time on wikipedia and ended up missing most of the discussion

[16:44] <kolibrie> I was $working

[16:45] * putter goes to check CPAN.... very fuzzy recollection of a tagged/attributed text module...

[17:00] <stevan> kolibrie: howdy :)

[17:01] <putter> bah.  kolibrie: yes, good idea.  definitely need one if doesnt already exist.

[17:02] <putter> hi stevan.

[17:02] <stevan> hey putter :)

[17:02] <stevan> hows rules treating you?

[17:03] <putter> bah.  ;)  I need a "client", someone with real pressing needs to motivate dealing with the cruft involved.

[17:04] <stevan> putter: funny I need to get rid of my $client, but $work would not like that :)

[17:04] <putter> lol

[17:06] <kolibrie> stevan: hi!

[17:06] <stevan> hey kolibrie

[17:06] <stevan> I am whipping up a 10,000 ft veiw of the metamodel for you

[17:07] <kolibrie> awesome!

[17:07] <kolibrie> it is slow reading

[17:07] <putter> ah, $work.  I should really write back to a head hunter today.  but hunters->interviews->contract negotiations and lawyers... the thought of which... maybe I'll get back to them monday.  yeah.  monday of some week or other.

[17:07] <stevan> kolibrie: to be honest, the JS is the easiest one to read (if you know JS that is)

[17:07] <stevan> it is not bootstrapped, so does not deal with the circularity issue

[17:08] <stevan> putter: by Christmas ;)

[17:08] <putter> :)  better be sooner than that. :(

[17:08] <kolibrie> stevan: JS is not my forte

[17:11] <svnbot6> r6082 | iblech++ | * PIL2JS: Support for $CALLER::.

[17:11] <svnbot6> r6082 | iblech++ |   * On subentry, a new pad ({}) is created and pushed on PIL2JS.subpads.

[17:11] <svnbot6> r6082 | iblech++ |   * Each var declaration updated the pad.

[17:11] <svnbot6> r6082 | iblech++ |   * $CALLER::CALLER::CALLER::foo is "PIL2JS.subpads[-3]["$foo"]" then

[17:11] <svnbot6> r6082 | iblech++ |     (with error handling etc. of course).

[17:11] <svnbot6> r6082 | iblech++ | * New test: t/var/caller.t (passes 7/7 on PIL2JS, had to skip

[17:11] <svnbot6> r6082 | iblech++ |   two tests on regular Pugs).

[17:12] <kolibrie> stevan: so, does the MetaModel work in perl5?  I mean, it is useable, or just a reference?

[17:12] <stevan> it is useable

[17:12] <stevan> run the tests

[17:12] <kolibrie> neato

[17:12] <stevan> it needs nothing outside the core

[17:12] <kolibrie> ubercool

[17:13] <kolibrie> so I could write all my objects the Perl 6 way?

[17:13] <stevan> kolibrie: you could

[17:13] <stevan> but I would not recommend it right now

[17:13] <stevan> it still lacks error checking

[17:13] * kolibrie studies the metamodel furiously

[17:13] <stevan> in critical parts

[17:14] <stevan> however I am planning on making a p5 class generator out of this once current $work project is done

[17:14] <kolibrie> I wrote a class generator

[17:14] <stevan> class generators are fun

[17:15] <kolibrie> I needed one with a simple interface, and the ones on CPAN just didn't cut it

[17:19] <stevan> perlbot nopaste

[17:20] <putter> autrijus: I assume you are on ll1-discuss?

[17:21] <pasteling> "stevan" at 67.186.136.119 pasted "10,000 ft view of the metamodel v1" (46 lines, 1.5K) at http://sial.org/pbot/12248

[17:21] <kolibrie> stevan: all in 46 lines!

[17:21] <stevan> ASCII art even

[17:21] <kolibrie> :)

[17:22] <stevan> I am a visual thinker, and it is worth at least 1000 words :P

[17:23] <kolibrie> I'm a visual thinker too

[17:23] <iblech> stevan: You get to Foo from i(Foo) by calling .ref on an instance of Foo, right?

[17:24] <stevan> iblech: I see Foo as being really just a proxy to the Metalevel class(Foo)

[17:24] <stevan> the interpreter handles it, but it has no actual concrete form

[17:24] <stevan> in the p5 MM it is just a package

[17:25] <stevan> and I let the p5 bless magic deal with it

[17:25] <iblech> Ok.

[17:25] <putter> so in ruby say, when one adds a method at runtime to an individual object, it creates an anonymous mumbleclass which inherits from the objects current class, and re-classes the object.  how would something like that fit in...?

[17:25] <iblech> And you get to meta(Foo) by calling i(Foo).meta?

[17:25] <stevan> iblech: yes

[17:25] <stevan> in the JS metamodel, I actually dealt with Class objects, but that was just because it made the most sense to do so

[17:26] <iblech> Ok.

[17:26] <stevan> no packages/bless in JS :)

[17:26] <stevan> that is really where the sugar/magic is

[17:26] <stevan> in CLOS you do a name lookup

[17:27] <stevan> so (find-class 'Foo') or something like that

[17:27] <stevan> to get the class(Foo)

[17:27] <stevan> at the hackathon $Larry said he wanted the class to be really a thin layer

[17:28] <stevan> which connected the meta and user worlds

[17:28] <putter> 2nd question, class(Foo) is meta-level?  not Class instanceof Class, Class instanceof Object, Class(Foo) instanceof Class?

[17:29] <stevan> Class isa (Object) yes

[17:29] <stevan> however not in the p5 version

[17:29] <stevan> because bootstrapping that is problematic

[17:29] <stevan> really Perl6::Class is not even needed

[17:29] <stevan> it could be tossed out, except it handles much of the magic

[17:30] <putter> how does one then do anonymous classes?

[17:30] <iblech> Next question :) i(Foo) is an instance of Foo. What is meta(Foo) an instance of?

[17:30] <ods15> i(Foo).meta

[17:30] <stevan> putter: it is the same as a named class, just you dont know the name

[17:30] <ods15> i dunno

[17:31] <stevan> iblech: MetaClass

[17:31] <stevan> putter: at least I think that is how it would work

[17:31] <iblech> stevan: And meta(MetaClass) is again an instance of MetaClass, right?

[17:31] <stevan> my $foo = class { method bar { "$foo.bar" }}

[17:31] <stevan> iblech: yes, that is the cycle

[17:32] <autrijus> putter: no, as a matter of fact I'm not. should I?

[17:32] <stevan> MetaClass.isa(Object) as well

[17:32] <autrijus> rehi \camels, btw. I learned a lot of ocaml today :)

[17:32] <stevan> howdy autrijus 

[17:32] <iblech> Hi :)

[17:32] <stevan> iblech: that is the boostrap which brings the meta-level into the user-level

[17:34] <iblech> stevan: Ok. Definitely commit that nopaste :)

[17:34] <putter> autrijus: I failed to find an archive that is still working... and while bursty high traffic, and not always the highest quality, there some current threads on package systems and closures that might be worth at least scanning...

[17:34] <autrijus> putter: https://lists.csail.mit.edu/pipermail/ll-discuss/2005-August/thread.html

[17:35] <autrijus> I recognized Felleisen

[17:35] <stevan> iblech: I will

[17:35] <autrijus> looks mildly interesting

[17:37] <putter> ah, good.  mildly sounds about right.  I accumulate them for a few months, and then skim.  I've found the highest payoff is when someone good says something you find surprising, and you can go back to them directly and explore.

[17:39] <putter> ocaml++   With active community and good backend support, is definitely on my short-list of interesting potential backends for pugs.

[17:39] <svnbot6> r6083 | Stevan++ | Perl6::MetaModel - 10,000 ft. view of MetaModel

[17:40] <autrijus> putter: right. ocaml feels, amazingly, very perlish.

[17:41] <autrijus> I mean the grab-bag-of-too-powerful-tools mentality

[17:41] <autrijus> but it's also strangely fast.

[17:41] <stevan> ok, back to $work &

[17:41] <putter> &

[17:42] <autrijus> conversely, one has to spend lots of time in baby talks and acquire idioms of how to mix those sublanguages together

[17:42] <autrijus> but that is also true for perl anyway :)

[17:42] * autrijus backlogs

[17:43] <putter> yes.  (thanks, I was just now trying to identify what makes me think of something as perl-ish.  "grab-bag-of-too-powerful-tools mentality" is really good characterization)

[17:43] <autrijus> iblech: the same thing as for "sub foo { 1 }"

[17:43] <autrijus> iblech: i.e. values that is part of variable declaration

[17:44] <autrijus> so you don't allocate undef for them; you directly allocate with value

[17:44] <iblech> Ah, ok, will work. :)

[17:45] <integral> has there been an answer to iblech's questions (1530Z) about my $a; BEGIN { $a = 5 } ?

[17:45] <iblech> Yep, scroll 4 lines up :)

[17:46] <brentdax> putter: I don't think I'd make a good "client"--I'll be done doing anything really interesting wth the regex engine in a couple days.

[17:46] <putter> re idioms, I would give bodily appendage for "the big book of language idioms".  most languages dont even document their own idioms well.  so that ends up being the longest and hardest part of learning a language (or spinning it back up after not having used it in a while).

[17:47] * integral blinks

[17:47] <putter> :(  snif.  ah well.   sooo... what'cha building?

[17:47] <autrijus> putter: The Big Book == CPAN :)

[17:48] <QtPlatypus> putter: I wonder if thats what the whole 'design pattens' movement is trying to do but not realizing it.

[17:48] <putter> :)

[17:48] <brentdax> At the moment, a parser fora simpleish markup language.

[17:53] <putter> QtPlatypus: yes.  and just "lets document our language better / make it easier to learn" making progress from the other, more concrete end.  The c2wiki can be fun  http://c2.com/cgi/wiki?PerlLanguage

[17:53] <autrijus> hm, as I'm on Win32, I might as well start drawing some Pugs architecure flowchart.

[17:53] * autrijus conjures up Visio

[17:53] <obra> 'afternoon, autrijus

[17:53] <autrijus> greetings obra. how is the con?

[17:53] <putter> brentdax: ah, neat.

[17:53] <obra> the con is quite excellent

[17:54] <obra> The past couple years seem to have focused on "How the hell are we going to make money on open source"

[17:54] <svnbot6> r6084 | iblech++ | * EOL at EOF.

[17:54] <svnbot6> r6084 | iblech++ | * Perl6-MetaModel: docs/10_000_ft_view.pod: Added putter++'s and my questions

[17:54] <svnbot6> r6084 | iblech++ |   and Stevan++'s answers.

[17:55] <putter> autrijus: re CPAN, it seems I'm always using non-mainstream modules, and, well, the authors are really happy to hear from someone when I email them bug reports... ;)

[17:55] <obra> This year, people have realized that they're earning money on opensource and the feeling seems to be "Let's talk about some fucking technology for a change"

[17:55] <autrijus> ahhh. that is good

[17:55] <autrijus> I was afraid it will get downhill.

[17:55] <autrijus> that sounds exciting indeed

[17:56] <putter> obra: any tech highlights?

[17:56] <obra> Ruby is the new black.

[17:57] <autrijus> and stiff is indeed very lucky.

[17:57] <putter> "the new black"?

[17:57] <autrijus> obra: for the longest time I've been saying that Ruby is Perl6 without advertisement :)

[17:58] <obra> autrijus: and rails is the obvious killer app

[17:58] <obra> autrijus: I remember

[17:58] <autrijus> yup. so imagine how nice Perl6 would be _with_ the advertisement!

[17:58] <obra> putter: an american expression meaning "Is cooler than cool"

[17:59] <obra> also, nobody dislikes the ruby people.

[17:59] <putter> and the ruby C implementation is nicely clean... posible to do mostly automated bulk code transformations to play games with it...

[17:59] <putter> obra, re "cool", ahhhhh, thanks. :)

[18:01] <putter> very friendly community.  (having just asked a question on #perl, and one response being an "that's a silly thing to want (because I dont immediately see the need)" (albeit followed by a "perhaps that's not the most helpful resonse to give people...")

[18:02] <putter> s/one response/the one and only response/

[18:04] <putter> nice wiki http://www.rubygarden.org/ruby  blog http://redhanded.hobix.com/

[18:04] <autrijus> yeah, the good-vibe thing is certainly an advantage.

[18:06] <autrijus> yeah, redhanded is amazing.

[18:07] <autrijus> it makes me want to start doing web comics.

[18:07] <putter> ruby on p6 should be straightforward.  I have bits of grammar and runtime.  currently on hold for rules and oo.  if anyone else is interested, would be much more fun to do as a group...

[18:07] <putter> ;) # re web commics

[18:07] <autrijus> putter: OO is the priority and will be resolved in due time

[18:08] <autrijus> are you going to bootstrap rules in a nonparrot fashion?

[18:08] <putter> ooo, have to catch up on bunny  http://www.frozenreality.co.uk/comic/bunny/

[18:08] <autrijus> or by hacking PGE into a better shape?

[18:08] <autrijus> it's unfortunately that pmichaud was again massively distracted elsewhere.

[18:10] <putter> non-parrot.  definitely not hacking PGE, except now and then a bit around the edges.  though PGE is now working well enough that it can run a grammar for regexp.  so one can chuck the whole fake-match-trees-to-bootstrap pain.

[18:11] <autrijus> nod.

[18:13] <jdv79> geoffb, around?

[18:13] <putter> and with pugs working so much better than it was a few months ago, there's really no reason for it to be other than straightforward.  I'm afraid I just a bit burned out on it.  

[18:13] <autrijus> putter: that's fine... you can write the plan down first

[18:14] <autrijus> (or find someone to interview you. that always works)

[18:14] <Maddingue> autrijus: not wanting to bother you, but did you see this Module::Install bug : http://rt.cpan.org/NoAuth/Bug.html?id=13711  ?

[18:15] <putter> hmmm, be interviewed... that's a nifty idea... volunteers? ;)

[18:16] <autrijus> Maddingue: no... is that you?

[18:16] <Maddingue> yes

[18:16] <Maddingue> I filled it about 3 weeks ago, but was wondering if you received the mail from RT

[18:17] <autrijus> the /Library thing, don't worry

[18:17] <autrijus> it's just a #file directive.

[18:17] <autrijus> I mean #line

[18:17] <Maddingue> ok

[18:17] <Maddingue> it looked weird :)

[18:18] <autrijus> so, can you try with EUMM 6.17?

[18:18] <putter> re pmichaud, if you give him test cases, fixes can at least sometimes happen quickly...

[18:18] <autrijus> or indeed any version prior to 6.30

[18:18] <Maddingue> let me try

[18:18] <autrijus> please tar the entire dir and mail to me

[18:19] <putter> and his fixes have been backported to parrot trunk/, so you can use them even if leo-ctx5 isnt working for you.

[18:19] <Maddingue> ok

[18:19] <jdv79> PGE isn't going to be used now?

[18:19] <autrijus> jdv79: er, no, just trying to render it optional.

[18:19] <jdv79> ah

[18:20] <jdv79> seems to be a popular theme

[18:20] <putter> and also wrap it in p6 helpers for things it doesnt support yet

[18:21] <autrijus> jdv79: right... nondependence is indeed one of pugs's themes :)

[18:21] <autrijus> Maddingue: also, just in case -- you got a committer invitation mail to http://svn.openfoundry.org/modinstall/ .

[18:23] <putter> a pcre backend provides a stable alternative when pge is having difficulties, and a prototype for backends to other languages (eg p5) which have a regexp library with something like named-subexpressions.  second, an entirely p6 regexp engine helps languages (eg javascript) which lack even that, and also allows doing the full regexp spect in which

[18:24] <Maddingue> autrijus: er, thanks :)

[18:24] <putter> regexps interact with code in interesting ways.

[18:26] * putter is just waiting for a :inline adverb to regexps, which allows subsequent code to backtrack back into the regexp.  eg, rx:inline/foo/; bar;  is  rx/foo { bar }/  or something (I always have to recheck which code embedding is which;)

[18:27] <putter> in a different universe, perl6's design could really be a couple of theses.

[18:28] <Khisanth> in a different universe perl5's core is less hairy :)

[18:29] <putter> :)

[18:29] <autrijus> in a different universe, this sentence yes verb

[18:30] * putter wonders what it would have taken for that to be true...

[18:30] <putter> ;)

[18:31] <putter> years of effort by a refactoring obsessed person with larry's ear and the development of a massive test suite...

[18:31] <autrijus> stevan: hm.

[18:31] <autrijus> =head2 What about anonymous classes?

[18:31] <autrijus> They're basically the same as named classes.

[18:32] <autrijus> stevan: your approach calls for a gensym-like scheme

[18:32] <integral> anonymous stashes?

[18:32] <autrijus> where anon classes are named like ANON001 or something

[18:32] <autrijus> this is popular in languages where you cannot rebind class names

[18:33] <Khisanth> is Perl 6 such a language?

[18:33] <autrijus> that is my question.

[18:33] <autrijus> I have no idea :)

[18:34] <putter> though since you can already gut and restuff packages/classes, I'm not sure anything is bought by prohibiting it.

[18:35] <autrijus> whoa, not so fast...

[18:35] <putter> ;)

[18:35] <autrijus> class Foo is reopened { ... }

[18:35] <autrijus> is extending-only

[18:35] <autrijus> you can't, for example, remove methods that way.

[18:36] <autrijus> perl5 remains a nominal type system, where all bless() has is a tag that describes the package name.

[18:36] <autrijus> I wonder if perl6 is like that too.

[18:37] <putter> so you can do things to a package/module (undefine subs) which you can't to role/class?

[18:37] <integral> maybe it's blessed with a reference to the package,  not a name of the package?

[18:37] <autrijus> integral: that's what my current theology have

[18:38] <integral> (autrijus' theology)++ ;-)

[18:38] <autrijus> but then it's not purely nominal anymore

[18:38] <putter> ?

[18:39] <autrijus> putter: it concerns that, when you do Foo.bless(), does the resulting object contain a symbolic, or hard, refrence to ::Foo.

[18:40] <putter> where the concequence of that indirection is... you could simultaneously reclass all the instances of a class?

[18:41] <stevan> autrijus: I think you cannot rename a class

[18:41] <autrijus> it looks like in the Js world it's not by name, it's by ref

[18:41] <stevan> i think that would break tooooo much

[18:42] <autrijus> stevan: but... it won't really break if existing objects contains hardlinks to their class

[18:42] <putter> stevan: but then, so much of static oo is just crying out to be broken...

[18:42] <autrijus> instead of symbolic links

[18:42] <autrijus> stevan: am I correct in thinking that Perl6.MetaClass does that?

[18:42] <autrijus> that is, it does not make use of an extra named-only lookup

[18:43] <stevan> one sec $client called

[18:43] <autrijus> whilst in perl5, you use the package stash for that lookup.

[18:44] <autrijus> sure

[18:45] <putter> one nice thing about the indirection is that, as classes/roles name both sets of behaviors and implementations, one could swap among different sets of behaviors over common implementations.

[18:45] <putter> whether to allows swaps over implementation, with rep coersion, is a second question.

[18:46] * putter would reaaally like objects to change rep while remaining =:=

[18:47] <autrijus> putter: well, you can swap them anyway by rebinding ::Foo.

[18:47] <autrijus> consider.

[18:47] <svnbot6> r6085 | iblech++ | PIL2JS: PIL2JS.js: Made it work with Opera again.

[18:47] <autrijus> my $obj = do { my class Foo { ... }; Foo.new };

[18:48] <autrijus> $obj is of course of class Foo.

[18:48] <autrijus> but it can't just contain a name -- unless it also carries a closure scope.

[18:48] <autrijus> at which time it's too expensive anyway.

[18:51] <putter> (aside, for clarity, the object rep change with unchanged =:= was wrt individual objects, unlike the rest of the discussion)  re Foo, err, so if a Foo symbol isnt sufficient (need closure too), what's the question again?  wether to point directly to the class object or indirect through a rebindable reference ???

[18:51] * putter probably didnt want to say "rebindable" there...

[18:53] <coral> oo, reclass all instances of a class

[18:53] <coral> i could use that to make classes read/write

[18:53] <coral> :)

[18:54] <putter> re theology, etal, putter notes the existence of http://pugs.kwiki.org/?Perl6Nomenclature  which could be extended... volunteers? ;)

[18:54] <autrijus> putter: whether to point to a class object by name, or by reference.

[18:54] <iblech> putter: IIUC, whether to point directly to the class object or indirect through its name

[18:54] <autrijus> I was arguing that by-name doesn't work unless all classes can by fully qualified.

[18:54] <integral> hmm, there's the option of pointing to the symtab slot, rather than naming it

[18:55] <autrijus> I further wonder if it makes sense to talk about anonymous packages, but that's another topic.

[18:58] <autrijus> iblech: if I'm not mistaken, the JS version of metamodel is already nameless

[18:58] <stevan> autrijus: I see what you are saying

[18:58] <stevan> autrijus: yes, it is, it uses the class(Foo) objects directly

[18:58] <autrijus> the 'Foo-0.0.1-jsan:STEVAN' carries no meaning, and the class is not depending on it addressable via 'Foo'

[18:58] <autrijus> oh.

[18:59] <autrijus> hm.

[18:59] <autrijus> foo.isa('Foo')

[18:59] <stevan> autrijus: the ideal would be for instance to hardlink to the Perl6::Class instance

[18:59] <stevan> then naming is a non-issue

[18:59] <autrijus> yay. good. thanks.

[18:59] <autrijus> I started out that way, then found that the high-altitude overview doesn't say that :)

[19:00] <stevan> autrijus: yes, sorry, that overview was more for the p5 prototype, I should clarify that

[19:00] <autrijus> I can see that only having fully qualified class can simplify stuff

[19:00] <putter> use Mumble as Frotz;  my $o = ...; $o.isa('Frotz::Zog')   ...

[19:00] <autrijus> but then you'd need to hoist up every lexical-scoped class by naming each lexical scope with a fully qualified name

[19:00] <integral> putter: why the single quotes?  Isn't Frotz::Zog an object itself?

[19:00] <autrijus> such as Packagename::ANONBLOCK003

[19:01] <autrijus> which I'm not sure is worth it.

[19:01] <stevan> autrijus: agreed

[19:01] <autrijus> yay, thanks for agreement :)

[19:01] <stevan> autrijus: I will rework the p5 metamodel to use Class instances

[19:01] <stevan> like you said, the JS model already does this

[19:01] <autrijus> stevan: oh good. in that case the META hack can go away too

[19:01] <stevan> it was just a happy accident that it happened

[19:01] <putter> integral: because autrijus's preceeding example had single quotes (I just copied it;)

[19:01] <stevan> autrijus: yes

[19:01] <integral> oh :-)

[19:01] <autrijus> then all three versions will be in perfect alignment :)

[19:02] <autrijus> integral: the preceding example is js code :)

[19:02] <integral> ah!

[19:02] <autrijus> this is truly a multilingual channel :)

[19:02] <stevan> autrijus: I recall having some issue with trying to do this in an earlier version

[19:02] <stevan> problems with the GC 

[19:02] <stevan> but I will overcome :)

[19:02] <autrijus> mm weakrefs?

[19:02] <autrijus> inside-outs?

[19:02] <autrijus> I think inside-outs is designed to solve things like that

[19:03] <stevan> autrijus: I think if I anchor something to the symbol table, the rest should not get GC-ed

[19:03] <stevan> what that something is, I am not sure

[19:03] * autrijus looks at Class::Std

[19:03] <autrijus> "Std is the new Acme!"

[19:04] <putter> stevan: (as a complete aside (which I include now solely so I dont forget again)) if at some point in the distant-is-fine future, you could convert one of the perl5/PIL-Run/lib/PIL/Run/Type/*'s to use the mm (and dont even worry about getting it running), I could then do the others...

[19:05] <stevan> putter: does any of this help (http://svn.openfoundry.org/pugs/perl5/Perl6-MetaModel/lib/Perl6/Container/)

[19:07] <fglock> how do I get the "identity" of an object? ".id" is returning undef

[19:07] <autrijus> ?eval class Foo {} Foo.new.id

[19:07] <evalbot6> 51 

[19:08] <autrijus> stevan: hm, object has this Id thing.

[19:08] <autrijus> stevan: which the metamodel does not address yet, right?

[19:08] <stevan> right

[19:08] <autrijus> is it one of its implicit private attribute?

[19:08] <fglock> ?eval my $a; $a.id

[19:08] <evalbot6> undef 

[19:08] <putter> ooo, that's it?  psyche.

[19:09] <autrijus> fglock: $a does not contain an object

[19:09] <putter> psych, even.  not the goddess? princess?

[19:09] <autrijus> fglock: you are perhaps looking at container ID.

[19:09] <autrijus> fglock: I don't think there is an official way to get it right now

[19:09] * nothingmuch feels like such a burnout

[19:09] <autrijus> you can compare them with =:=

[19:09] <autrijus> but that's it

[19:10] <autrijus> fglock: please p6l if you'd like to get the container id.

[19:10] <ods15> hi nothingmuch 

[19:10] <autrijus> (with a use case, preferably)

[19:10] <ods15> nothingmuch: you're not a lot, are you :P

[19:10] <nothingmuch> hi ho

[19:10] <nothingmuch> nope

[19:10] <nothingmuch> i'm nothing much

[19:10] <nothingmuch> bwahaha

[19:10] <nothingmuch> haha.

[19:10] <ods15> hehe

[19:10] <nothingmuch> *cough*

[19:10] <autrijus> I'm told that joke is more funny in chinese

[19:10] <Aankhen``> putter: Support for recursive rules is definitely on my wishlist. :-)

[19:11] <stevan> autrijus: P6::O could have a private class attribute, and P6::O.CREATE could stash the .next_value into the instance somehow

[19:11] * nothingmuch goes to fulfill basic human needs such as food and/or higene

[19:11] <autrijus> stevan: either that, or in addition to objMeta and objData, we add objId

[19:11] <nothingmuch> uh, spelling.

[19:12] <ods15> heh

[19:12] <stevan> autrijus: yes, that would be ideal, so that it won't override any user defined id

[19:13] <autrijus> yup.

[19:14] <stevan> ok, on the TODO list: 1) $obj.id 2) remove lookup-class-by-name functionality in favor of hardlinks

[19:15] <autrijus> and 3) move META into an attrib

[19:15] <autrijus> stevan: if you hit the GC wall, I highly recommend Class::Std

[19:15] <autrijus> I've been doing that for my projects for some time now

[19:15] <stevan> autrijus: #2 implies #3, so I consider it a subtask :)

[19:15] <fglock> I'm longing for "Lazy", so that I can test the Recurrence modules

[19:15] <stevan> autrijus: I will look into it

[19:15] <stevan> Class::STD that is

[19:15] <autrijus> fglock: the new runcore will take care of that

[19:16] <autrijus> fglock: but OO has priority currently... so another couple weeks

[19:16] <autrijus> wow, past 3am. better start journaling

[19:17] <putter> Aankhen``: how recursive?  Fully left -- rule foo { <foo> <bar> } ? (Is slow ok?)  rule foo { x <foo> } should work now.  Mutually -- rule foo { x <bar> } rule bar { y <foo> }  I'm not sure whether PGE can do this now or not.  rules on PCRE wont be able to :( (hmm, or... atleast not my current simple approach -- PCRE needs a total ordering to exist over its named subpatterns), only rules on p6.

[19:17] <fglock> autrijus: I wish I could help, 

[19:18] <stevan> oooh,... I can do this to fake name based lookup : my $Foo = Perl6::Class->new('Foo', ...);  sub ::Foo { $Foo }

[19:19] <autrijus> fglock: oh. but you could... look in S04 (I think, maybe someplace else) for .spec and generators

[19:19] <autrijus> fglock: and write tests for them

[19:19] <svnbot6> r6086 | autrijus++ | * add objId as recommended by Stevan to support .id

[19:19] <stevan> hey, dont go blaming that on me now :)

[19:19] <autrijus> er, but you did say that is the ideal approach :)

[19:20] <autrijus> fglock: or even better, prototype it in perl5 or perl6 or javascript or pir :)

[19:20] <stevan> you cant prove it, I'll deny it,.. I was never here,.. :P

[19:20] <putter> autrijus: how's your clock speed these days.  with work and late nights and all.  never used to see you online at this local time...

[19:20] <autrijus> roflmao

[19:20] <autrijus> putter: yeah... $work is usually to around dinner localtime

[19:20] <autrijus> so I resume pugs working pretty late

[19:20] <autrijus> and well into midnight

[19:21] <fglock> Span::* is kind of a prototype for things like 1..Int

[19:21] <putter> aahhhh.

[19:21] <stevan> autrijus: funny, I am on the opposite schedule

[19:21] <autrijus> fglock: right. but the thing gets interesting when an array has multiples of them.

[19:21] <stevan> $work during the day is too difficult (to many $client calls), so I hack pugs

[19:22] <autrijus> fglock: suppost @a is 1..Inf

[19:22] <stevan> and work on $work work last at night :)

[19:22] <autrijus> then I splice it a 2..10 into position 5

[19:22] <autrijus> can Span handle that?

[19:22] <autrijus> 1,2,3,4,2,3,4,5,6,7,8,9,10,5,6,7,...

[19:24] <fglock> autrijus: no, but you can use a list of Spans: [1..4],[2..10],[5..Inf] - that's how Set::Infinite works

[19:25] <autrijus> fglock: aye, the key is that the "splice" container method

[19:25] <autrijus> must be smart enough to handle that.

[19:25] <Aankhen``> putter: Fully left ought to be enough for now.  You say it works?

[19:25] <autrijus> I'll look at the Span code for guidance.

[19:25] <fglock> I could implement it - all I need is a namespace

[19:25] <autrijus> sure. Tie::Array::Span?

[19:26] <autrijus> basically just implement all the methods in the standard perltie

[19:26] <putter> mugwump: re crude_repl.pl and Scriptalicious, I tried installing Scriptalicious from CPAN and got

[19:26] <putter> /usr/bin/perl "-Iblib/arch" "-Iblib/lib" Build.PL Build

[19:26] <putter> Too early to specify a build action 'Build'.  Do 'Build Build' instead.

[19:26] <putter> make: *** [Build] Error 9

[19:26] <autrijus> actually if you can do that, it may make sense to p5ize it

[19:26] <Aankhen``> Neat!

[19:26] <autrijus> because _that_ will become our container for Lazy when we compile p6 to p5.

[19:26] <autrijus> as an advantage, you can also test it with regular perl5 t/* and perltie.

[19:27] <fglock> autrijus: look at Set::Infinite::Functional. However, what you are talking about is an "unordered" set, which is a different thing

[19:27] <Aankhen``> Hmm.

[19:27] <autrijus> hm? I though I was talking about a List.

[19:27] <Aankhen``> Now I need <before> and <after>.

[19:28] <putter> fglock: fyi, there is a p6 splice in... src/perl6/Prelude/PIR.pm

[19:28] <fglock> Sure, but Spans are ordered sets - what you need is a bit different - now I got it

[19:28] <putter> oh, and if your working in p5, I have one of those too.

[19:29] <autrijus> fglock: cool. I want generator lists, methods on them that respects list fusion

[19:29] <fglock> does it have to support things that are not "Int"?

[19:30] <Aankhen``> rule escaped ($char) { <after [<!after <escaped>> \\]> $char } # this ought to match any singly escaped character, right?

[19:30] <Aankhen``> (e.g. "\n" in "foo\n")

[19:30] <fglock> I was thinking about something like date(2000-05-10)..date(2005-05-20)

[19:30] <putter> Aankhen``: fully left doesnt I believe.  you can rewrite it though... sub foo { <foo> bar... } as sub foo { [<bar>...]+ }

[19:30] <putter> err, s/sub/rule/

[19:31] <autrijus> fglock: surely it needs to

[19:31] <autrijus> fglock: a stream of strings, a stream of objects, etc

[19:31] <putter> though of course that can get hairy if foo has additional alternation clauses...

[19:32] <autrijus> fglock: it is like spans but also a bit different.

[19:33] <fglock> autrijus: mmm ok. So if it supports splice, I could do (emulate) a splice in a stream, right?

[19:34] <autrijus> riight.

[19:35] <putter> Aankhen``: rules with additional arguments definitely arent implemented.  shouldnt that be  <after [<!after <escaped '\\'>> \\]> $char

[19:36] <Aankhen``> Er, right.

[19:36] <Aankhen``> It should.

[19:36] <Aankhen``> Left recursion appears to work... but maybe I'm missing something?

[19:36] <Aankhen``> I'll nopaste.

[19:38] <putter> hmm...  \\ <!after <escaped '\\'>> $char

[19:38] <pasteling> "Aankhen``" at 203.101.5.81 pasted "Left recursion?" (2 lines, 62B) at http://sial.org/pbot/12254

[19:38] <Aankhen``> Wait... dangit.

[19:38] <Aankhen``> Ignore that, please.

[19:39] <autrijus> ?eval my $p; $p< connection username password >

[19:39] <evalbot6> [undef, undef, undef] 

[19:39] <Aankhen``> putter: Ah, it doesn't appear to work.

[19:39] <Aankhen``> Have you heard of Markdown?

[19:41] <putter> Aankhen``: paste looks fine.  not really left recursive (what I probably incorrectly called "fully left recursive") because of the x.  should work.  does.  (tried r6060 with a fairly recent parrot trunk/ (may or may not be r8730))

[19:42] <putter> Markdown?

[19:42] <Aankhen``> Yeh, that works, but I figured "left recursive" means something like /<foo> x/, rather than /x <foo>/.

[19:43] <Aankhen``> http://daringfireball.net/projects/markdown/

[19:43] <putter> yes.  PGE happily recurses to boom on that.

[19:43] <Aankhen``> Indeed.

[19:43] <Aankhen``> Anyway.

[19:43] <putter> well, not to boom.  gives nice max recursion exceeded error message.

[19:43] <Aankhen``> In the words of the author, Markdown is a text-to-HTML conversion tool.

[19:44] <putter> ah.

[19:44] <wolverian> Aankhen``, is there a CPAN module for it? there is one for Textile, which is why I'm using that instead of Markdown.

[19:44] <Aankhen``> wolverian: Not that I know of. :-\

[19:44] <wolverian> (Textile seems to be more supported in general, too, maybe because of the module.)

[19:44] <wolverian> Aankhen``, right. well, the differences aren't that great. 

[19:44] <wolverian> see Textile if you want a module to do that sort of a thing :)

[19:44] <putter> best bet, if it's not too difficult, is to rewrite the recursion as a repetition.  all other approaches are still vaporware.

[19:45] <Aankhen``> putter: What is of relevance to you and me is that Markdown supports escape sequences.  These escape sequences are handled by, in the first parse, replacing all such sequences with MD5'd versions of themselves, and replacing them in the last pass with the escaped characters.

[19:45] <Aankhen``> I want to rewrite Markdown in Perl 6 using recursive patterns rather than the MD5 approach.

[19:45] <Aankhen``> It is my dream to someday do that. ;-)

[19:50] <Aankhen``> Dang, I think I scared him away.

[19:51] <putter> I see, so there are other backslashes about, but one only wants to apply this processing to things in particular places defined by a larger grammar...?

[19:51] <putter> :)

[19:51] <Aankhen``> Er, yeah.

[19:51] <Aankhen``> I guess.

[19:52] <fglock> if I had 'say for 1,2,3,-Inf..0;' it would iterate to 1,2,3,-Inf,-Inf,-Inf,... right?

[19:53] <autrijus> fglock: exactly.

[19:53] <autrijus> however!

[19:53] <autrijus> if you pass it to reverse()

[19:53] <autrijus> it will magically then iterate 0,1,2,3,...

[19:53] <fglock> sure - reverse would use 'pop()'

[19:53] <putter> My fuzzy understanding is PGE will have a p5-like restriction that lookbehinds have to be fixed length.  So I vaguely expect recursive lookbehinds will be a nono.  PCRE has the same limitation.  so it looks like that particular approach (nested afters) would have to wait for a p6 engine.

[19:54] <autrijus> fglock: yeah

[19:54] <Aankhen``> Wha?

[19:54] <fglock> cool - I'm starting Tie::Array::Span

[19:54] <Aankhen``> I thought patterns are meant to support variable length lookbehinds?

[19:56] <putter> Could be.  I don't know.  Would somewhat restrict implementation options.

[19:56] <Aankhen``> It would totally suck to not have variable length lookbehinds.

[19:56] <putter> PCRE definitely shares p5's fixed length limitation.

[19:56] <Aankhen``> Yup, I know about PCRE.

[19:57] <putter> I actually expect there will be multiple engines with different properties.  I could be wrong though.

[19:57] <mauke> that's because variable-length look-behind's matching semantics are unclear, at least to me 

[19:57] <putter> But for any property foo which someone wants, I expect there will be an engine which supports foo.

[19:58] <putter> mauke: hmm, interesting.  for example?

[19:58] <Aankhen``> I suppose.

[19:58] <mauke> perl5: "1234x" =~ /(?<=(\d+)(\d+))x/;

[19:59] <mauke> what are $1 and $2?

[19:59] <putter> Aankhen``: I expect the standard way to do what you described is  ... (pattern-matching-thing-to-munge) { $/[index or name of thing] = munge($/[same]) } ...

[20:00] <mauke> possible values: "123","4"; "1","234"; "3","4"

[20:00] <putter> ie, you can modify the strings matched within the regexp.

[20:03] <putter> if one defines lookbehind as lookahead on a reverse, then "1","234" is clearly the right thing.   or for ui consistence, one could define a region by the same, and then run the pattern forward, in which case it would be the first.  seems more a matter of definition than ambiguity, no?  (but I'm not sure if reversability restriction introduces issues)

[20:04] <putter> s/consistency/

[20:04] <putter> things do get odd if :exhaustive has been specified :)

[20:05] <putter> or not really.  no different than the issues with lookahead.

[20:05] <putter> mauke: am I missing something obvious...?

[20:06] <mauke> no, I just need a sane definition of how lookbehind is supposed to work

[20:06] <putter> the spec already has a lot of "and subpattern foo is varied first, then subpattern bar" flavor proceedural definition.

[20:07] <putter> ah.  yes.

[20:10] <putter> Aankhen``: while code in regexp remains unsupported, another option is a rule munge_this { ... }  rule foo { ... <munge_this> }  and then just crawl over the match tree reassembling the string, but for nodes reached via $m<munge_this>, munging it.

[20:12] <putter> Poorman's :parsetree (which is also currently unimplemented).  Just make sure nodes of type x are always refered to via <x>, no aliasing (which doesnt yet work anyway(?)), and crawl the tree top-down.

[20:12] <putter> That you can do today.

[20:15] <svnbot6> r6087 | iblech++ | PIL2JS: Very minor fixes: .isa and .ref work on Any and added Int and Rat.

[20:16] <putter> The grammar looks just about as it would ideally.  One just does the stringification as a separate step.  If one wants a match tree with the munged nodes, you can crawl and assemble a new tree of  MatchX, a Match alternative, in modules/Grammars (though it still has issues.  hmm, and I have a more recent version that hasnt been checked in yet).  but I've used this approach, so you could do it now...

[20:16] * putter notices Aankhen`` has been silent for the last 20 min...

[20:21] <autrijus> well, pcre has known-length lookbehind

[20:21] <autrijus> which is quite a bit better than fixed-length lookbehind of perl5's.

[20:22] <autrijus> (?<=a|bc|defg) is allowed in pcre but not perl5.

[20:22] <mauke> (?:(?<=a)|(?<=bc)|(?<=defg))

[20:23] <autrijus> hm, true.

[20:23] <autrijus> I wonder why p5 doesn't compile this to that though.

[20:24] <autrijus> maybe because the regex engine is not easily hackable.

[20:24] <Aankhen``> putter: I was off shooting terrorists. :-)

[20:34] <autrijus> journal up. g'nite!

[20:34] * autrijus waves &

[20:34] *** Maddingue__ is now known as Maddingue

[20:53] <putter> goodnight autrijus.  interesting.  curious mauke.  eeep Aankhen``.  

[20:53] <putter> ;)

[20:55] <putter> around 9/11, the official us state dept definition of terrorism was, hmm, approximately, "war-like acts by NGO's".  ;)  probably been changed since.

[21:04] <putter> Hey, day 180.  We're approaching the 1/2 year mark.

[21:05] <putter> Party? ;)

[21:21] * Aankhen`` goes to sleep.

[21:22] <Aankhen``> G'night.

[22:01] <putter> &

[22:25] <fglock> how can I call the global 'pop'? I have a method with the same name, and it is calling the method instead

[22:25] <Khisanth> is CORE still around?

[22:26] <fglock> no, I get No compatible sub found: &CORE::pop

[22:27] <wolverian> *pop, I assume 

[22:27] <wolverian> might have to do &*pop

[22:29] <fglock> I just renamed my method to _pop for now :(

[23:21] * brentdax waits for his test document to render yet again...

[23:29] <svnbot6> r6088 | fglock++ | * new class 'Array::Lazy' - implements "Array" using iterators, so that

[23:29] <svnbot6> r6088 | fglock++ |   you can store a list like "1,50,$obj,1..Inf,10,4" and do splice, pop,

[23:29] <svnbot6> r6088 | fglock++ |   shift, etc on it.

[23:29] <wolverian> o.O

[23:39] <brentdax> (I grabbed a few paragraphs from [[Wikipedia:Hermione Granger]] and translated them into my markup language.  Yes, I'm a hopeless geek.)

[23:48] <Khisanth> hmm Hairy Plotter

[23:53] <ayrnieu> mmm slash

