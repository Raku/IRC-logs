[02:30] <svnbot6> r6279 | putter++ | talks/README: Added entry for Wellington.pm p6 intro.

[02:30] <svnbot6> r6279 | putter++ | docs/SEEALSO: now points out that talks/README contains links to online versions of talks.

[04:58] <autrijus> wow.

[04:58] <autrijus> gvanrossum is on our committer list.

[04:59] <autrijus> maybe I should ask him to add himself to AUTHORS.

[05:37] <autrijus> mugwump: your design is on http://www.cafepress.com/pugscode now :)

[05:37] <autrijus> &

[05:39] <mugwump> heh, not offensive anymore huh?  :)

[05:40] <dduncan> autrijus, didn't you add gvanrossum to the committer list yourself, during ingy's talk in OSCON, when he asked you to live on stage?

[05:42] <coral> heh

[05:42] <coral> autrijus++

[06:17] <coral> in the words of a former friend, omg

[06:17] <coral> cafepress has a mousepad. do they have plastic mousepads?

[06:32] <xinming> ?eval class TMP { has $.tmp;method tmp { "perl 6".say}; }; my TMP $t .= new; tmp $t;

[06:32] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected in "&TMP::tmp" 

[06:32] <xinming>     $handle.close

[06:32] <xinming>     close($handle)

[06:32] <xinming>     close $handle:

[06:32] <xinming>     close $handle

[06:33] <xinming> But the from Synoposis, It is legal for my example. So Is Pugs wrong?

[06:33] <xinming> while {tmp $t:;} works

[06:35] <xinming> anyone here "alive" ? :-S

[06:41] <Khisanth> isn't that an indirect invocation? I am quite sure that invovles a colon somewhere :)

[06:43] <jql> ?eval class TMP { has $.tmp;method tmp { "perl 6".say}; }; my TMP $t .= new; tmp $t:

[06:43] <evalbot6> perl 6 bool::true 

[06:43] <jql> there ya go

[06:43] <jql> you were right; it was the colon

[06:44] <xinming> from Synoposis, It is legal for { tmp $t; }

[06:44] <jql> ?eval class TMP { has $.tmp;method tmp { "I declared, I instantiated, I invoked"}; }; my TMP $t .= new; tmp $t:

[06:44] <evalbot6> 'I declared, I instantiated, I invoked' 

[06:45] <xinming> ?eval class TMP { has $.tmp;method tmp { "perl 6".say}; }; my TMP $t .= new; tmp $t

[06:45] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected in "&TMP::tmp" 

[06:46] <xinming> see the $handle.close example. :-)

[06:46] <xinming> the last one is also in Synoposis

[06:46] <jql> the @Larry have flip-flopped on the explicit invocation syntax

[06:46] <masak> jql: in what way?

[06:47] <xinming> jql: you mean, The last one is not valid while Larry changed his mind, right?

[06:47] <jql> well, you can make arguments for the mandatory colon for tmp $foo: arg1, arg2, arg3; vs. MMD on the whole function

[06:47] <xinming> by the way, I sometimes wonder, Why the init Method will be named BUILD{ }, I think the init method use the class name might be better. :-)

[06:48] <jql> xinming: how would you name the constructor of an anonymous class? >:)

[06:48] <xinming> jql: Yes, I know, what here we talk is without arguments

[06:49] <xinming> jql: .... Ok, I understand. ;-)

[06:50] <xinming> Indirect object notation now requires a colon after the invocant if there are any arguments. If there are no arguments and you omit the colon, the notation is parsed either as a named unary operator or a list operator with one argument. In any case, all of these come out to the same thing:

[06:51] <jql> xinming: an indirect method call without a colon would actually be a multimethod call

[06:51] <jql> ?eval class TMP { has $.tmp;multi method tmp { "perl 6".say}; }; my TMP $t .= new; tmp $t   # don't think this works yet

[06:51] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected in "&TMP::tmp" 

[06:51] <jql> yeah, don't think that can work. heh

[06:52] <xinming> hmm,, How about Larry think about this.

[06:53] <xinming> does larry agree with the example above. ?

[06:53] <jql> might as well ask the mailing-list. it might divert them from the latest MMD thread

[06:53] * jql falls asleep

[06:53] <xinming> jql: night

[07:04] <putter> autrijus: re journal, you saw my earlier irc notes?  "putter suggests we rotate the items every three months" is, well, not what I had in mind at all...  ah well.

[07:08] <putter> iblech: I notice the rules Parser/Prelude hook is getting in the way of PIL2JS.  As rules are again stalled on "everything takes two orders of magnitude longer because pugs isn't quite working yet", and PIL2JS is part of the critical path on getting things working, please feel free to rip it out.  Hmm, here's a patch...

[07:09] <pasteling> "putter" at 66.30.119.55 pasted "a patch to pull the Parser/Prelude macro rules hook fyi." (344 lines, 13.1K) at http://sial.org/pbot/12492

[07:10] <putter> fyi

[07:10] <putter> good middle-of-the night all.

[07:27] <autrijus> hm, I keep misinsg putter

[07:28] * autrijus updates journal to reflect putter's feedback

[07:29] <autrijus> done

[07:30] <autrijus> mm lwall gives justification for the y2k epoch

[07:30] <autrijus> <larry> But mostly because I'm a megalomaniac, and think I can change the world.

[07:41] * autrijus ponders generating a -CPython for guido to play with

[07:42] * jql offers autrijus a choice of pie... banana cream? key lime?

[07:44] <jql> hell, if larry can embarass the programming world into adding universal pcre integration, I think he can make his own epoch

[07:45] <autrijus> well yeah, I hope so :)

[07:45] <autrijus> hm, I wonder if I should blog about the guido incident today

[07:45] <autrijus> (openfoundry.org sent a newsletter to all users to announce the new, much improved site look implemented by gugod)

[07:46] <autrijus> and guido wrote back saying "but I'm not a user, why am I getting this"

[07:46] <autrijus> then we found out he is a pugs committer after all :)

[07:49] * castaway1 grins

[07:49] <castaway1> mm, is it readable now?

[07:50] <autrijus> the beta version will be up in 2 days 

[07:50] *** castaway1 is now known as castaway

[07:50] <castaway> well thats an improvement, I can actually use it now ,)

[07:51] <autrijus> :D

[07:53] * castaway thinks public descs should be english tho (with an extra field for local names ,)

[07:53] <autrijus> nodnod :)

[07:53] * autrijus needs to run... still at $job

[07:53] <castaway> have fun ,)

[07:55] <castaway> Oh.. http://www.openfoundry != http://openfoundry.org (the first is still unusable)

[07:58] * jql files the ICANN petition

[07:59] <castaway> ?

[08:00] <nothingmuch> darn, someone kicked my box

[08:00] * nothingmuch thinks the builders may have actually bumped the power button

[08:02] <castaway> wuzn't me

[08:02] <nothingmuch> do you have an alliby?

[08:03] <castaway> depends, for when? :)

[08:03] <nothingmuch> today, in the morning I got a message saying "this box is going down, due to halt"

[08:04] <nothingmuch> which is what you get when you press the power button

[08:04] <castaway> umm.. I was in bed?

[08:56] <xinming> hmm, anyone here can tell me what the differences between {has $var;} and { my $var; } for a class

[08:57] <Aankhen``> `has $var;` declares an instance variable.

[08:57] <Aankhen``> `has $.var;`, rather.

[08:57] <Aankhen``> `my $var;` declares a class variable.

[08:58] <Aankhen``> ?eval class Foo { my $bar = "bar (class)"; has $.bar = "bar (instance)"; }; (Foo.bar, Foo.new.bar)

[08:58] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[08:58] <Aankhen``> ?eval class Foo { my $bar = "bar (class)"; has $.bar = "bar (instance)"; }; (Foo.bar, Foo.new().bar)

[08:58] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[08:58] <Aankhen``> Bah.

[08:59] <Aankhen``> D'oh.

[08:59] <Aankhen``> My mistake.

[08:59] <Aankhen``> ?eval class Foo { our $bar = "bar (class)"; has $.bar = "bar (instance)"; }; ($Foo::bar, Foo.new().bar)

[08:59] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[08:59] <Aankhen``> What the heck?

[08:59] <Aankhen``> ?eval class Foo { our $bar = "bar (class)"; has $.bar = "bar (instance)"; }; $Foo::bar

[08:59] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[08:59] <xinming> :-)

[09:00] <Aankhen``> ?eval class Foo { has $.bar = "abcd" }

[09:00] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:00] <Aankhen``> Ah, that'd be the problem.

[09:00] <Aankhen``> Anyway.

[09:00] <Aankhen``> I made a mistake earlier.

[09:00] <xinming> ?eval class TMP { has $.bar = "abc"; };

[09:00] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:00] <Aankhen``> `my $var;` acts like a regular lexical variable, i.e. one that is limited in scope to the class in which it is declared.

[09:00] <xinming> ?eval class TMP { has $.bar; };

[09:00] <evalbot6> undef 

[09:00] <Aankhen``> Or... wait...

[09:00] <Aankhen``> One sec.

[09:01] * Aankhen`` tries to sort things out in his head.

[09:01] <xinming> ?eval class TMP { has $.bar; my $.bar };

[09:01] <evalbot6> undef 

[09:01] <xinming> ?eval class TMP { has $.bar =1; my $.bar; my $bar; };

[09:01] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:01] <xinming> ?eval class TMP { has $.bar; my $.bar; my $bar; };

[09:01] <Aankhen``> `my $.foo` declares a private class variable, i.e. one that can only be accessed by it or its subclasses, or any classes it "trusts".

[09:01] <evalbot6> undef 

[09:01] <Aankhen``> That sounds about right.

[09:01] <Aankhen``> xinming: `my $.foo` declares a private class variable, i.e. one that can only be accessed by it or its subclasses, or any classes it "trusts".

[09:02] <xinming> hmm... how about the keyword has?

[09:02] <Aankhen``> On the other hand, `has $.foo` declares a public instance variable.

[09:02] <Aankhen``> So if you have this: class Foo { has $.bar = "bar" }

[09:03] <Aankhen``> Then you can access $.bar as a property of a Foo object, rather than the class: my $foo = Foo.new(); $foo.bar

[09:03] <xinming> ?eval class Foo { has $.bar = "bar" }; my Foo $v .= new; $v.bar.say;

[09:03] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:03] <Aankhen``> Initial values for attributes don't seem to be supported yet.

[09:04] <xinming> for priviate variable, the has $:var form is used I think. :-S

[09:04] <xinming> hard to understand. T_T

[09:04] <Aankhen``> For instance variables, yes...

[09:04] <Aankhen``> I'm not really sure about the class variables thing.

[09:04] <Aankhen``> `has $:foo` declares a private instance variables.

[09:05] <Aankhen``> s/s\.$/./

[09:05] <xinming> ?eval class T { has $.new; }; my T $o .= new;

[09:06] <evalbot6> \undef 

[09:06] <xinming> ?eval class T { has $.new; method tmp { 'pugs'.say }}; my T $o .= new; $o.tmp;

[09:06] <evalbot6> Error: No compatible subroutine found: "&tmp" 

[09:07] <Aankhen``> I believe you need a better signature on that method.

[09:07] <Aankhen``> ?eval class T { has $.new; method tmp () { "pugs" } }; my T $o .= new; $o.tmp;

[09:07] <evalbot6> Error: No compatible subroutine found: "&tmp" 

[09:07] <Aankhen``> ?eval class T { has $.new; method tmp () { "pugs" } }; my T $o .= new; $o.tmp

[09:07] <evalbot6> Error: No compatible subroutine found: "&tmp" 

[09:07] <xinming> Aankhen``: no, In fact, I think that's the problem for the member variable $t. :-)

[09:07] <xinming> oops.

[09:07] <xinming> $.new

[09:07] <Aankhen``> Yes...

[09:08] <Aankhen``> ?eval class T { method tmp () { "pugs" } }; my T $o .= new; $o.tmp;

[09:08] <evalbot6> 'pugs' 

[09:09] * Aankhen`` wanders off.

[09:13] <xinming> ?eval class T { has $.new; method tmp { 'pugs'.say }}; my T $o .= bless( {} );

[09:13] <evalbot6> Error: No compatible subroutine found: "&bless" 

[09:13] <xinming> ?eval class T { has $.new; method tmp { 'pugs'.say }}; my $o = T.bless( {} );

[09:13] <evalbot6> Error: No compatible subroutine found: "&bless" 

[09:13] <xinming> oops.

[10:15] <nothingmuch> god damnit!

[10:15] * nothingmuch just spent a day learning enough CSS to do what he wants

[10:15] * castaway comforts nothingmuch 

[10:15] <nothingmuch> and when it finally works.... it doesn't under IE

[10:15] <nothingmuch> FUCK FUCK FUCK FUCK FUCK FUCK FUCK!

[10:15] <castaway> IE--

[10:16] <nothingmuch> Microsoft probably owes the world 50% of it's lost man hours

[10:16] <nothingmuch> the rest can be attributed to family emergencies, real hardware problems, drug abuse, and so forth

[10:17] <ods15> nothingmuch: if you're having that much trouble, you're probably doing something broken anyway

[10:17] <nothingmuch> ods15: "display: table-cell"

[10:17] <nothingmuch> it works perfect everywhere, very stable, very non quirky

[10:17] *** Aankh|Clone is now known as Aankhen``

[10:17] <ods15> css is kinda nice, but your page should look nice in links as well as other browsers

[10:17] <nothingmuch> except that it's completely unsupported on IE

[10:17] <ods15> what is that

[10:18] <nothingmuch> well, it means that the items (divs, spans, etc) can be layed out like a table

[10:18] <nothingmuch> even when they're not

[10:18] <ods15> then use tables...

[10:18] <nothingmuch> ods15: please, don't just preach

[10:18] <ods15> ok, could you explain to me it then?

[10:18] <nothingmuch> i don't do this because I think it's fun

[10:19] <nothingmuch> i did this because tables didn't give me enough control

[10:19] <nothingmuch> and the layout was completely unreadable

[10:19] <ods15> hmm

[10:19] <nothingmuch> nevermind, i'll find a way to deal with it

[10:19] <nothingmuch> I could create images with GD

[10:19] <nothingmuch> and just display them inline

[10:19] <nothingmuch> =)

[10:19] <ods15> what are you trying to do? can you give me a screenshot of the page as it works in FF?

[10:19] <Aankhen``> odsl: The whole point of CSS is to seperate style (presentation) from structure (markup).  This makes it /easier/ for text browsers to display the page.

[10:20] <nothingmuch> ods15: i'll find something, i haven't exhausted my options yet

[10:20] <Aankhen``> ods15, even.

[10:20] * Aankhen`` curses Courier New.

[10:20] <ods15> Aankhen``: yeah, css IS good

[10:20] <castaway> (except CSS is too complex for what it does, and has sucky support :)

[10:20] <ods15> but it shouldn't be your problem when designing a page...

[10:21] <ods15> btw, my idea of a pretty page... http://kmenc15.sf.net/

[10:21] <castaway> thats not pretty, just plain ,)

[10:21] <Aankhen``> Indeed.

[10:21] <ods15> plain is pretty :)

[10:21] <Aankhen``> Nope.

[10:22] <Aankhen``> Plain is plain.

[10:22] <Aankhen``> Plain != pretty.

[10:22] <Aankhen``> Simple != pretty.

[10:22] <ods15> bs

[10:22] <Aankhen``> Truth.

[10:22] <ods15> bah

[10:22] <Aankhen``> That page looks like something out of 1996.

[10:22] <ods15> oh, what am i talking about, you're perl programmers, ofcourse you think big is beautiful...

[10:23] <Aankhen``> I never said big is beautiful.

[10:23] <nothingmuch> ods15: wtf?

[10:23] <Aankhen``> "Simple" and "pretty" are not mutually exclusive.

[10:23] <Aankhen``> However, they are not equivalent.

[10:23] <ods15> Aankhen``: ah, i misunderstood your "equations"

[10:23] <nothingmuch> ods15: is C pretty?

[10:23] <Aankhen``> S'okay, I think they weren't very clear.

[10:23] <ods15> i thought you meant "simple can't possibly be pretty"

[10:23] <nothingmuch> is it small?

[10:24] <Aankhen``> Nah.

[10:24] <Aankhen``> I've seen plenty of simple sites that manage to look really good.

[10:24] <ods15> nothingmuch: C is slightly too big, but it's simpler and smaller than most. i think it's generally beautiful.

[10:24] <nothingmuch> ods15: not the language, the programs written in it

[10:25] <ods15> what do you mean

[10:25] <nothingmuch> C as it's defined is elegant

[10:25] <castaway> simple can be pretty, lack of colour whatsoever isnt (IMnsHO :)

[10:25] <nothingmuch> it's very little that gives you very much

[10:25] <ods15> Aankhen``: i like sites which gives content...

[10:26] <ods15> nothingmuch: yeah...

[10:26] <nothingmuch> but C code usually isn't pretty or elegant

[10:26] <Aankhen``> ods15: I do too, but I don't call a site with minimum style and colour but lots of content pretty.

[10:26] <nothingmuch> it's serious, but that's all i can think of

[10:26] <wolverian> I think http://beaglewiki.org/ is rather pretty.

[10:26] <Aankhen``> nothingmuch: Could I see the page on which you're using `display: table-cell;`?

[10:26] * ods15 checks

[10:26] <nothingmuch> Aankhen``: no, sadly, it's internal company data

[10:27] <Aankhen``> wolverian: Yeah, that looks nice.

[10:27] <nothingmuch> and creating a mockup would take me quite a while, since the structure is pretty big

[10:27] <Aankhen``> wolverian: Also check out http://blog.codefront.net/.

[10:27] <Aankhen``> nothingmuch: OK, then I'll simply ask: are you sure you shouldn't just be using tables?

[10:27] <ods15> looks nice. wiki don't usually look very good in elinks/links :/ even wikipedia is kinda bad there..

[10:27] <nothingmuch> Aankhen``: if I use tables I have colspan on 80% of the cells, and rowspan on 20% of the cells

[10:28] <wolverian> Aankhen``, that's nice, too. the a:hover colour is a bit bright, but then again, this LCD destroys colour pretty well.

[10:28] <Aankhen``> nothingmuch: What sort of content are you marking up?

[10:28] <nothingmuch> Aankhen``: an item in a database, and all it's complex relationship to 3 other tables

[10:28] <nothingmuch> as well as edit/delete buttons

[10:28] <ods15> nothingmuch: i haven't seen THAT many C programs, but i can say i've seen quite a few which were wonderfully designed (e.g. ffmpeg), and quite a few which have a wonderfully broken design... (mplayer) but it has more to do with planning ahead than the language...

[10:28] <Aankhen``> tables++

[10:29] <Aankhen``> wolverian: Yeah, the hover colour is a bit bright, but what I like is the overall look.

[10:29] <nothingmuch> ods15: i don'

[10:29] <nothingmuch> t mean in the big picture

[10:29] <nothingmuch> i mean the actual code

[10:29] <nothingmuch> there is too much micromanagement

[10:29] <nothingmuch> not enough intention

[10:29] <ods15> ah, that

[10:30] <ods15> depends on your purposes..

[10:30] <nothingmuch> the code doesn't say what it wants to do, it says how to do it, and also what is needed to do it, and how to do that too

[10:30] <Aankhen``> wolverian: http://phoenity.com/firefox.html # seems fairly simple now, but it totally blew me away the first time I saw it.

[10:30] <ods15> and, it too depends on a good design

[10:30] <wolverian> Aankhen``, heh, the backgrounds are neat.

[10:31] <wolverian> Aankhen``, but the title image doesn't have an alpha channel :/

[10:31] <ods15> if you make good general purpose functions which do the tiny things, the big stuff can use them and not worry about small stuff

[10:31] <nothingmuch> ods15: except when it needs to

[10:31] <Aankhen``> wolverian: http://mathibus.com/ # opinion? :-)

[10:31] <nothingmuch> and then you get 10 variation s on a short name

[10:31] <ods15> ?

[10:32] <nothingmuch> one for each different way on how memory is managed

[10:32] <nothingmuch> on the return value

[10:32] <nothingmuch> or pass-a-pointer

[10:32] <nothingmuch> or what not

[10:32] <nothingmuch> and if you have the returns-a-mallocced-thing, you need to define a macro that allocates for that function

[10:32] <nothingmuch> or link it to something proper

[10:32] <nothingmuch> and if you pass a pointer, then you need to worry about memory anyway

[10:32] <ods15> well C's is most known for it's greatest advantage and disadvantage - it leaves memory management to the programmer

[10:33] <nothingmuch> ods15: memory management is not the only thing

[10:33] <nothingmuch> objective C is a superset of C, that gives OO

[10:33] <nothingmuch> it's memory management is also manual

[10:33] <ods15> OO is design, not language

[10:34] <nothingmuch> but it's tucked away very nicelyu

[10:34] <Aankhen``> ods15: Ever done Perl 5 OO? :-P

[10:34] <nothingmuch> ods15: OO is the luggage that comes with the language

[10:34] <nothingmuch> you can't do OO proper in C

[10:34] <ods15> Aankhen``: nope.. but i've seen quite a bit of OO in C

[10:34] <nothingmuch> you can pretend that you're doing it

[10:34] <nothingmuch> but it's not really it

[10:34] <ods15> no, you can REALLY do it

[10:34] <nothingmuch> you can implement OO in C

[10:34] <Aankhen``> ods15: Try it sometime.

[10:34] <ods15> with structs and functions pointers

[10:35] <nothingmuch> ods15: that's not OO, that's structs and function pointers

[10:35] <nothingmuch> that, btw, is what objective C is

[10:35] <nothingmuch> structs and function pointers

[10:35] <nothingmuch> but with syntax and culture

[10:35] <nothingmuch> objective C used to be just preprocessed down to C

[10:35] <nothingmuch> and then compiled

[10:35] <ods15> no, it's OO. if you believe me, look at mplayer's vf layer...

[10:36] <Aankhen``> If you're happy and you know it, clap your hands!

[10:36] <ods15> the entire vf stuff is very beautiful "OO" style

[10:36] <nothingmuch> ods15: this argument is pointless

[10:36] <nothingmuch> my original premise is:

[10:36] <nothingmuch> C leaves you worrying about too much details all the time, when you should only really care about them when you care about them

[10:37] <castaway> (so does assembler ,)

[10:37] <Aankhen``> nothingmuch: BTW, I hate to digress, but as regards your earlier problem... :-P http://www.usability.com.au/resources/tables.cfm

[10:37] <ods15> which is ofcourse why it's only best suited in places where it's best suited...

[10:37] <castaway> its best suited to writing compilers in ,)

[10:37] <ods15> there is no "perfect" language :)

[10:38] <ods15> castaway: or any kind of intensive operations

[10:38] <wolverian> Aankhen``, nice, although nothing special. I think the horizontal navigation menu should have a different background colour than the main text body. the 'recent comments' author links are too light.

[10:38] <wolverian> Aankhen``, otherwise I like it.

[10:38] <wolverian> simple and easy to read.

[10:38] <wolverian> and not ugly.

[10:38] <castaway> ods15: throw more hardware at it ,)

[10:38] <nothingmuch> ods15: uh, that's not what I mean

[10:38] <ods15> nothingmuch: ?

[10:38] <Aankhen``> wolverian++

[10:39] <nothingmuch> my claim wasn't that C is bad for everything

[10:39] <nothingmuch> it was that most code is inelegant

[10:39] <ods15> ah

[10:39] <nothingmuch> and this inelegance is the price you pay for control

[10:39] <nothingmuch> and sometimes, you pay for control in safety, and even performance

[10:39] <ods15> nothingmuch: ?

[10:40] <ods15> you lost me on performance.. usually that is the reson you take control..

[10:40] <nothingmuch> ods15: what about copy on write? who the hell wants to really optimize every copying or non copying operation by hand?

[10:41] <nothingmuch> also, some languages are more optimizable than C, because the functions deal more with intention than with details, so the compiler can replace details with better ones

[10:41] * ods15 scratches head

[10:41] <ods15> what copy on write?

[10:42] <ods15> i mean, what did you mean by what you said there

[10:42] <nothingmuch> ods15: my $str = "Foo"; my $other = $str; # should this make a copy?

[10:42] <ods15> i know what cp[y on write is

[10:42] <nothingmuch> in a higher level languaage the compiler can see what your usage pattern for a given string is

[10:42] <nothingmuch> if it determines that a given variable takes a substring

[10:42] <ods15> nothingmuch: hmm, what do you mean

[10:43] <nothingmuch> and immutably manipulates it, until the substring is destroyed

[10:43] <nothingmuch> even if the lexical scope of the code doesn't know if it's mutably or immutably manipulated

[10:43] <ods15> in perl, that code only copies on write?

[10:43] <nothingmuch> ods15: no, perl doesn't have COW

[10:43] <nothingmuch> ods15: look at haskell's arrays

[10:44] <nothingmuch> in haskell most data structures are immutable

[10:44] <nothingmuch> but sometimes it makes sense for the immutable structures to really be implemented as mutable structures, because it's more efficient

[10:44] <nothingmuch> this is comparing apples and oranges, WRT to C

[10:44] <ods15> 13:40:26 <nothingmuch> ods15: what about copy on write? who the hell wants to really optimize every copying or non copying operation by hand? - you mean, a lazy C programmer would ALWAYS duplicate his stuff even when he doesn't need to, and in other languages this wouldn't happn?

[10:45] <nothingmuch> ods15: the programmer, lazy or not lazy, should not need to worry about that

[10:45] <nothingmuch> for example:

[10:45] <ods15> i don't think i've ever heard of something like that.. whenever making any kind of copy, you know beforehand if you need to modify it or not, and duplicate or point accordingly...

[10:45] <nothingmuch> sub foo ($str) { my $sub = substr($str, <offset>, <length>); return $sub };

[10:45] <nothingmuch> my $string = "moose";

[10:46] <nothingmuch> my $other = foo($string);

[10:46] <nothingmuch> length($other);

[10:46] <nothingmuch> my $another = foo($string);

[10:46] <castaway> but what if you dont know? :)

[10:46] <nothingmuch> $other =~ tr/A-Z/a-z/;

[10:46] <nothingmuch> oops, the $other in the last one should be $another

[10:47] <ods15> nothingmuch: is this actually broken perl code you're giving me? should i run this code in perl?

[10:47] <nothingmuch> ods15: it's pseudo code

[10:47] <ods15> ah

[10:47] <nothingmuch> foo() accepts a string

[10:47] <nothingmuch> and returns a part of it

[10:47] <nothingmuch> it doesn't know what happens to the part of it

[10:47] <nothingmuch> if the return value is modified, the original string should not be altered

[10:48] <nothingmuch> in C, how would you keep 'my $other = $string; length($other); # other is no longer used now' efficient?

[10:49] <ods15> in C i would have to copy no matter what due to null terminator

[10:49] <nothingmuch> ods15: that's besides the point

[10:49] <ods15> lol

[10:49] <nothingmuch> assume the string is really a struct that has a pointer and some length

[10:49] <ods15> ok

[10:50] <nothingmuch> anyway, in a language that doesn't specify it, you have several different solutions:

[10:50] <nothingmuch> copy on write can make the substring share bytes with the original

[10:50] <nothingmuch> $other doesn't cause a copy

[10:50] <nothingmuch> but $another does

[10:50] <nothingmuch> furthermore, static code analysis can even avoid COW

[10:50] <ods15> heh

[10:50] <nothingmuch> because a compiler could see that foo is used in a variable that gets changed, and that doesn't get changed

[10:51] <nothingmuch> and the compiler can augment the version in use

[10:51] <ods15> in places where efficiency REALLY matters, this kind of situation should never happen

[10:51] <nothingmuch> ods15: why should it never happen

[10:51] <ods15> i agree, in this case C would be "slower" as you would have to always make a copy

[10:51] <nothingmuch> ods15: no, C will probably be faster

[10:52] <nothingmuch> if you make two versions of 'foo'

[10:52] <nothingmuch> but then the programmer is slower

[10:52] <nothingmuch> so most people will just make a copy to stop worrying about it

[10:52] <nothingmuch> which is the correct way for most code

[10:52] <nothingmuch> but look at projects like psyco, which take high level code

[10:52] <ods15> actually, in C i wouldn't do this at all because there's no such thing as a "substr" function

[10:52] <ods15> ...due to the memory management....

[10:52] <nothingmuch> ods15: that's sooooo besides the point

[10:52] <ods15> no, it's not

[10:53] <nothingmuch> ods15: it seems like you're trying to avoid dealing with the main issue

[10:53] <nothingmuch> i'm giving you general examples

[10:53] <nothingmuch> that are supposed to convey a concept

[10:53] <ods15> nothingmuch: which don't apply when you take not of the "little" details

[10:53] <nothingmuch> and C does have substr in the sense that perl's substr is implemented in C

[10:53] * castaway sighs

[10:53] <ods15> 13:52:17 <nothingmuch> so most people will just make a copy to stop worrying about it - stop worrying about it? they still need to free() it!!

[10:53] <nothingmuch> ods15: nevermind

[10:53] <nothingmuch> oids

[10:53] <nothingmuch> ods15: see? that's why C sucks for stuff that shouldn't care about it

[10:54] <ods15> lazy.. programmers..

[10:54] <nothingmuch> ods15: yes, programmers should be lazy

[10:54] <nothingmuch> my time is more expensive than my compiler/processor

[10:54] <ods15> and use high level language :)

[10:54] <nothingmuch> much more expensive

[10:54] <nothingmuch> ods15: for 90% of the code yes

[10:54] <ods15> i forgot your point

[10:55] <ods15> something about C programs

[10:55] <nothingmuch> my point was that C is about micromanagement

[10:55] <ods15> yes, it is

[10:55] <ods15> i agree

[10:55] <nothingmuch> and that's why programs written in it are inelegant in my opinion - they don't concern themselves with what result the program is trying to achieve

[10:56] <nothingmuch> they are concerned with tiny issues that come up on the way to that result

[10:56] <ods15> ah. well. depending on the purpose, this could be unavoidable... (you're obviously not suggesting that mplayer and linux should be re-written in perl)

[10:57] <nothingmuch> ods15: no, i'm not, but mplayer's command line argument processing code doesn't really need to perform well, does it?

[10:57] <castaway> (the right language for the job)

[10:57] <ods15> nothingmuch: ah, yes, you could say for example, the entire high level management SHOULD be written in something else

[10:58] <ods15> but unfortunately, once you pick a language, you should STICK to that language.. any other solution is almost always less elegant, not more

[11:00] <ods15> all of mplayer's high level management is totally awful, and it being C is not the only cause, but defenetaly a cause.. sadly, there is no better solution. oh well

[11:01] <ods15> oh, 2pm... bbl, patrol

[11:02] <castaway> patrol?

[11:11] <ods15> nothingmuch: what;s the word in english?

[11:11] <castaway> patrol sonuds english :9

[11:12] <theorbtwo> Patrol: An orginized, regular, search, in order to catch things that shouldn't be there, but are.

[11:17] <ods15> yeah that's about it

[11:17] <ods15> army thing

[11:17] <ods15> i need to go around the base

[12:02] * nothingmuch returns 

[12:02] * nothingmuch leaves once more

[12:02] <castaway> ah, around the base.. and what do you do the rest of the time? :)

[12:06] <ods15> chat with you guys

[12:06] <castaway> nice job

[12:06] <ods15> yeah. army. sure is hard :(

[12:09] <theorbtwo> US army?

[12:10] <castaway> he's in .il

[12:10] <theorbtwo> Ah.

[12:18] <Odin-> So, a former terrorist group.

[12:18] <castaway> ?

[12:18] <Odin-> The IDF was formed from hebrew terrorist groups.

[12:19] <Odin-> ... not an unusual way for a national army to form, I might note.

[12:19] * castaway nods

[12:19] <ods15> nod

[12:19] <ods15> well, it wasn

[12:19] <ods15> err

[12:19] <ods15> well, it wasn't really terrorists..

[12:19] <Odin-> You can argue that their cause was just, but that's irrelevant. ;)

[12:19] <ods15> afaik they didn't do any kind of innocent people killing, atleast not intentionally

[12:20] <ods15> Odin-: actually i consider terrorism by killing innocent irrelavent people

[12:20] <ods15> killing non-innocent people is still just as bad imo, but it's not "terrorism"

[12:21] <Odin-> By that definition, the U.S. Army is the single largest terrorist organisation today.

[12:21] <Odin-> *shrug*

[12:21] <ods15> (e.g., all the armies in the world as far as i am concered are totally as bad as terrorism...)

[12:21] <ods15> hmm.. u.s. army kills innocent people?...

[12:21] * Odin- notes that 'terrorist' is what people-in-power call others doing the same thing as themselves.

[12:22] <Odin-> ods15: Sure. It's called "collateral damage".

[12:22] <ods15> heh

[12:22] <ods15> i actually consider all people innocent...

[12:23] * Odin- may sound rabidly anti-military, but that's not really it.

[12:23] <castaway> even the ones that are trying to kill you?

[12:23] <Odin-> I just don't believe there's any nobility attached. ;)

[12:23] <ods15> there are very few people which really want to kill, they are call psychopaths... the rest do it in self defense or forced to by circumstances..

[12:24] <ods15> as for the psycopaths, they are innocent too, because it's not their fault their mind is broken

[12:24] <ods15> stupidity is not controllable...

[12:24] <Odin-> An interesting viewpoint.

[12:24] <theorbtwo> Don't confuse psychopathy with stupidity.

[12:24] <castaway> breed it out ,)

[12:24] <ods15> theorbtwo: hmm, good point

[12:24] <Odin-> And one that really easily makes status quo justifiable. ;)

[12:25] <ods15> but both are mental diseases though?

[12:25] <ods15> as in, uncontrollable?

[12:25] <theorbtwo> Sure.

[12:25] <Odin-> castaway: Psychopathy isn't an inheritable disease.

[12:25] <castaway> I mean the stupidity

[12:25] <Odin-> Well, that isn't, either.

[12:25] <castaway> and as for the other, Im not so sure thats true

[12:25] <theorbtwo> But a stupid person probably won't be very good at killing you.  The psychpaths, however, will likely be /very/ good, at least at some things.

[12:25] <Odin-> I've never come across a person that's "incurably stupid".

[12:26] <Odin-> castaway: There are genetic factors which influence it, sure.

[12:26] <ods15> Odin-: go work at some tech support company, you'll see what it means :)

[12:26] <Odin-> castaway: Just like, say, depression.

[12:26] <Odin-> ods15: Heh. :>

[12:26] <theorbtwo> 'Ignorant' ne 'stupid'.

[12:26] <Odin-> ods15: Dunno. I think that's arrogance speaking. ;)

[12:27] <ods15> theorbtwo: religious leaders are not psychopaths, they are stupid

[12:27] <ods15> and they kill thousands

[12:27] <theorbtwo> nothingmuch, I'd tend to think that they are more likely psycopaths then stupid.  Or neither.

[12:27] <ods15> ods15?

[12:27] <theorbtwo> I don't think stupid people are very good at becomming religious leaders.

[12:28] <ods15> W bush :P though he's not a religious leader...

[12:28] <ods15> and tbh i'm not sure if he's stupid, never really checked

[12:28] <theorbtwo> GW Bush isn't stupid (though he tries to appear so).  OTOH, he quite possibly is a psychopath.

[12:28] <Odin-> I wouldn't say 'stupid'.

[12:28] <Odin-> I'd say "narrowly focused".

[12:29] <ods15> childish?

[12:29] <Odin-> Which is pretty much what psychopathy is...

[12:30] <theorbtwo> Psychopathy, as I understand it, is not having a normal motoviational structure, or an intuitive understanding of psychology.

[12:30] <theorbtwo> They can /learn/ psychology quite effectively, but to them it's xenospsychology -- they don't learn about themselves as they learn about other people, or vice-versa.

[12:31] <ods15> theorbtwo: hmm, ok, what about the nazis?.. hitler was NOT stupid, but his "fan club" i believe mostly were

[12:31] <ods15> he rised to power by stupidity

[12:31] <Odin-> I dunno.

[12:31] <Odin-> I think it was the other way around.

[12:31] <theorbtwo> Stupid people are very easy to manipulate by those who learn phychology, yes.

[12:31] <Odin-> Hitler was nuts, his "inner ring" was relatively sane, although utterly unreal.

[12:31] <ods15> Odin-: nah, hitler was not stupid, at all

[12:32] <castaway> he was a psycho .. (meglomaniac?)

[12:32] <ods15> (stupid is not capable of mathematical/logic thinking...)

[12:32] <Odin-> ods15: I didn't say 'stupid'. But people like GÃ¶ring, Himmler most certainly weren't, either.

[12:32] <ods15> theorbtwo: btw, you said, ignorance != stupidity... elaborate?

[12:32] <ods15> himmler?

[12:33] <Odin-> ods15: Ignorance is a lack of knowledge.

[12:33] <castaway> not knowing something yet is not the same as not being able to comprehend it

[12:33] <Odin-> Stupidity is inability to know.

[12:33] <Odin-> (Roughly speaking.)

[12:33] <ods15> Odin-: ah, well, the people who call tech support are not JUST ignorant, they really are TRUELY stupid

[12:33] <ods15> (i don't mean all..)

[12:33] <castaway> no, I think mostly they're ignorant

[12:33] <Odin-> ods15: Not at all. You just try to start at the wrong point. ;)

[12:34] <ods15> Odin-: no, they refuse to do anything, using wizards scares them, they do not understand that cutting the power in the room causes the pc to shut down

[12:34] <ods15> that is not ignorance

[12:34] <ods15> most are ignorant, yes. but some are truely stupid

[12:35] <Odin-> Maybe some. But they're rare. ;>

[12:35] <ods15> not according to the stories my sister has told me.. (adsl tech)

[12:35] <Odin-> Most of the "horror stories" I've heard are not stupidity.

[12:36] <Odin-> And, yeah, re: the power ... no, that's not "stupidity". It's a failure of understanding; i.e., ignorance.

[12:37] <ods15> Odin-: umm, isn't FAILURE of understanding stupidity?

[12:37] <castaway> no, inability is stupidity

[12:37] <Odin-> ods15: No. Inability to understand.

[12:37] <ods15> ignorance i thought was that you simply have never learned

[12:37] <ods15> but failure of learning would then be stupidity?

[12:38] <Odin-> ods15: Not at all. That could be the result of a myriad different things.

[12:38] <ods15> (not understanding that 2+2+2 is 2*3, after you've been explained, is stupidity.. not knowing it BEFORE you've been explained, is ignorance.. right?)

[12:38] <theorbtwo> Correct, ods15.

[12:39] <Odin-> ods15: Hm. Yes.

[12:39] <ods15> then.. failure of understandg is stupidity?...

[12:39] <Odin-> But do keep in mind that not understanding it after one round of explaining it doesn't mean someone is stupid.

[12:39] <ods15> Odin-: well, stupid is not black and white

[12:39] <ods15> it grows "gradually"

[12:39] <Odin-> ods15: Neither is arrogance. ;)

[12:40] <Odin-> Which, frankly, is an all too common taint on intelligence.

[12:40] <ods15> if you're reffering to me you'll have to explain to me where i've been arrogant.. i (think i) generally try not be...

[12:41] <dbrock> tech support customers' failure of understanding is the same as tech support's failure of explaining

[12:42] <ods15> that's a good point.. heh

[12:42] <nothingmuch> theorbtwo: huh?

[12:42] <ods15> but i think fortunately most of tech support is just as stupid as teir customers, which makes the communication easier :)

[12:42] <Odin-> ods15: Well, I think you have a skewed viewpoint. I know I do. The fact that someone takes much longer to realise something than you, or even an average person, doesn't mean the person is stupid. Especially when there are unstated assumptions of knowledge, which often happens...

[12:42] <dbrock> the failure might be due to the customer's stupidity and ignorance, or it might be due to tech support's incompetence, or any combination thereof :-)

[12:43] <Odin-> ods15: And you wondered where arrogance was to be found? ;>

[12:43] <Odin-> dbrock: Indeed. :)

[12:43] <ods15> Odin-: well, i never mentioned myself..

[12:43] <theorbtwo> orafu, in many cases, the falure of documentation -- often including the complete absence of any documentation.

[12:43] <theorbtwo> nm: What are you "huh"ing, in purticular?

[12:43] <dbrock> ods15: good point :-)

[12:44] * theorbtwo wonders who he meant when he said "orafu".

[12:44] <ods15> but, even though it doesn't mean the person is stupid, it does SOMEWHAT (in most cases) mean the person is stupidER (which could still be very intelligent, just not AS)

[12:44] <Odin-> ods15: Which brings the latter point to focus. Often, when knowledgeable people are trying to explain something, they make unstated assumptions of a person's knowledge, which is by no means certain.

[12:44] <Odin-> AS?

[12:44] <ods15> the other person

[12:45] <Odin-> Ah.

[12:45] <Odin-> Yeah, sure.

[12:45] <Odin-> But in those cases I think "stupid" is a bad word to use. ;)

[12:45] <ods15> and that's what i meant by "gradually"

[12:45] <ods15> yes, lack of a better word :)

[12:45] <theorbtwo> For example: "Of course your computer is off, if your power failed!"

[12:45] <ods15> i'll say the cliche - everything is relative, nobody is stupid or smart :)

[12:46] <theorbtwo> 1) They realize their power has failed, and not that the computer and light bulb both happened to die at the same time.

[12:46] <theorbtwo> 2) They know that the computer is an electrical device, and not mechanical.

[12:46] <ods15> they already know that electricty runs many appliances in the house

[12:46] <theorbtwo> 3) They know that it doesn't work on batteries (many electronic devices do).

[12:46] <ods15> and they are unable to draw conclusions, that is stupidity

[12:46] <theorbtwo> They do?

[12:47] <ods15> tv, refrigirator...

[12:47] <theorbtwo> That's another assumption.

[12:47] <theorbtwo> Perhaps they haven't tried to use the TV or refrigerator during a power failure.

[12:47] <ods15> wait, so the statement you said just now are assumptions?

[12:47] <theorbtwo> Power failures of more then a few seconds aren't that common in much of the US anymore, for example.

[12:47] <ods15> i see

[12:48] <ods15> yes, i guess they are assumptions... but in this example, these assumptions are safe?...

[12:48] * castaway looks back in after answering the phone and is completely lost

[12:48] <Aankhen``> I always thought stupidity is the frequent (or perhaps regular?) inability to arrive at the correct conclusion despite having, and being aware of, all the necessary information.

[12:48] <theorbtwo> If you've never used a 3.5in floppy, then it's perfectly reasonable to assume that it's a card reader.

[12:49] <ods15> Aankhen``: yeah, that's a pretty good definition.. stupidity comes in many forms

[12:49] <theorbtwo> Yep, Aankhen, and one tech support call isn't enough to know if they do it frequently, and have all the neccessary information.

[12:49] * theorbtwo thinks it's a very good definition.

[12:49] <ods15> mostly all forms of stupidity involve inability to reach/understand a conclusion

[12:51] <ods15> theorbtwo: the assumptions you mentioned are practically safe assumptions

[12:51] <theorbtwo> The other day I saw a series of photos of stupid things people do to their computers and send them in for repair.

[12:51] <Aankhen``> [18:17:54] <theorbtwo> Power failures of more then a few seconds aren't that common in much of the US anymore, for example. # lucky dawgs.

[12:52] <ods15> also, even if they are assumptions, all of those assumptions are actually conclusions themselves, which should've been reached, if the person isn't stupid

[12:52] <Aankhen``> Yup.

[12:53] <theorbtwo> One was of credit cards stuck in a 3.5" floppy drive, with the caption "no, it's not a card reader".

[12:53] <Aankhen``> Hrm.

[12:53] <Aankhen``> ods15: Actually, I'm not so sure...

[12:53] <ods15> theorbtwo: hehe

[12:53] <theorbtwo> If you've never seen a 3.5" floppy, and nobody told you otherwise, thinking it's a card reader isn't that crazy.

[12:53] <Aankhen``> Everyone exhibits the inability to reach the conclusion once in a while.

[12:53] <Aankhen``> It might be that you reached all the necessary conclusions except one.

[12:54] <ods15> Aankhen``: i agree...

[12:54] <theorbtwo> Computers these days don't come with manuals.  At best, they have an icon on the desktop, which hopefully you figure out to double-click on, and how to use.

[12:54] <Aankhen``> theorbtwo: They do if they're assembled. :-D

[12:54] <ods15> hehe

[12:54] <castaway> with real "user" manuals? I dont believe you

[12:54] <theorbtwo> Aankhen: I haven't seen a computer that came with a manual that laid everything you need to know out in a long time.

[12:54] <Aankhen``> castaway: 'Twas said in jest. :-P You do get the manuals for the individual parts, though. ;-)

[12:55] <Aankhen``> theorbtwo: Have they stopped bundling manuals with branded computers?

[12:55] <Aankhen``> I know my mother's laptop came with one.

[12:55] <theorbtwo> I think so, Aankhen.

[12:55] <theorbtwo> A useful one?

[12:55] <ods15> Aankhen``: one on how to browse the web?

[12:55] <Aankhen``> I dunno, never read it.

[12:55] <castaway> one that explained double click, and F1 and .. ?

[12:55] <castaway> (and start to shutdown :)

[12:56] <Aankhen``> It had online (as in, "on computer", not "on Web") help, so I browsed that a bit.

[12:56] <Aankhen``> Come to think of it, though, it wasn't really a good idea for newbies.

[12:56] <theorbtwo> Most likely, it doesn't tell you how to use a computer, only how to use the bits of that computer that vary from a bog-standard computer.

[12:56] <Aankhen``> (i.e. the answer to castaway's question is yes)

[12:56] <Aankhen``> s/yes/no/ even. -_-

[12:56] <Aankhen``> theorbtwo: Spot on.

[12:57] <castaway> Which is no help whatsoever to people who have never used one

[12:57] <Aankhen``> Yeah.

[12:57] <castaway> Its like giving someone a car without them haven taken lessons .. what do all the knobs and buttons and levers do?

[12:57] <theorbtwo> Thank god it's so hard to get a computer to run over people.

[12:58] <castaway> indeed.. easy to get it to spam people tho

[12:58] <Aankhen``> castaway: Yeah, with a manual that shows you how the CD player is different from others.

[12:58] * castaway thinks the "computer driving licence" idea is still a good one

[12:58] <Aankhen``> Or how the six-speed manual transmission can be switched to a four-speed automatic transmission.

[12:58] *** autark is now known as jp-autark

[12:58] <Aankhen``> Mmm, I don't really care about a computer driving license...

[12:59] <Aankhen``> I do care about a "computer instruction license" though.

[12:59] <castaway> whichever you call it

[12:59] <Aankhen``> Almost all instructors I have ever met have been completely clueless.

[12:59] <castaway> but just better manuals would help a lot... they'd just have to be huge

[12:59] <theorbtwo> I've never met a computer instructor other then myself and the guy I worked with (who did most of the instruction).

[13:00] <Aankhen``> My pet peeve is Web development.

[13:00] <castaway> whats that got to do with users? :)

[13:01] <Aankhen``> "Every Tom, Dick and Harry can build a Website these days..." Heck no, they can't.  They can mash together a bunch of angle brackets and letters.  They can't build Websites.

[13:01] <Aankhen``> Oh, nothing, I just wanted to hijack the converstion. :-D

[13:01] <theorbtwo> Lots of users try to do web development these days.

[13:01] <nothingmuch> colspan--

[13:01] <theorbtwo> However, thank the many gods, they don't really mess up other people.

[13:01] <Aankhen``> theorbtwo: Could you elaborate on "users"?

[13:02] <theorbtwo> People without the ability to read and understand w3 specs, or even realize that such specs exist.

[13:02] <Aankhen``> Ah, those people.

[13:02] <theorbtwo> s/w3/w3c/

[13:02] <Aankhen``> Actually, every one of them does mess up other people, since pretty much everyone starts out by copying other people's code.

[13:03] <castaway> what annoys me (more) is that some then think they know something, and write "HowTos" for others, which spreads the crap

[13:03] <theorbtwo> They don't mess up other people in the same way that not being firewalled does, or driving like you have no idea that there are such things as road laws.

[13:03] <castaway> (I little bit of knowledge can be a dangerous thing)

[13:03] <Aankhen``> theorbtwo: Ah, that's true.

[13:03] <castaway> s/I/A/

[13:03] <Aankhen``> castaway: Aye aye!

[13:04] * castaway ponders 'net "pollution" laws ,9

[13:04] <Aankhen``> LMAO.

[13:04] <Aankhen``> castaway++

[13:04] <theorbtwo> I'm very glad that new installs of winxp now come with the firewall enabled by default.

[13:04] <castaway> lets spin off a separate network for professionals and leave these people to their junk.. (wait, wasnt that how the internet started.. ?)

[13:04] <Aankhen``> Heh.

[13:04] <theorbtwo> The thing is that I'm /very/ reticent to get the law any more involved in the internet then it already is.

[13:05] * castaway didnt really mean a governmental law

[13:05] <theorbtwo> What did you mean, then?

[13:06] * theorbtwo ponders ISPs giving "good netizen" discounts.

[13:06] <Aankhen``> Another spec, like WCAG. ;-)

[13:06] <castaway> some sort of self preservation / higher echelon / test .. 

[13:07] <Aankhen``> OK, I'm off.

[13:07] <Aankhen``> Gonna go watch Madagascar.

[13:07] <Aankhen``> Later.

[13:07] <castaway> have fun

[13:07] <Aankhen``> Thanks. :-)

[13:07] <theorbtwo> Later, Aankhen -- nice chattering with you.

[13:07] <Aankhen``> BBL. &

[13:28] <autrijus> rehi!

[13:32] <nothingmuch> hola

[13:33] <autrijus> heya nothingmuch. what's up?

[13:36] <QtPlatypus> autrijus: Would it be approprate to place the GC API documentation I've been discussing on p6l in the Pugs documentation tree?  And if so where whould be most approprate?

[13:36] <autrijus> docs/notes/ is the default stash area.

[13:36] <QtPlatypus> Thanks.

[13:37] <autrijus> np :)

[13:37] * autrijus is, sadly, deep in $job $deadline foo

[13:37] <castaway> ick, deadlines

[13:37] <autrijus> right. I love the sound of them whooshing by

[13:37] <autrijus> no such luxury this time though, it seems :)

[13:41] <kolibrie> I work better without deadlines

[13:42] <autrijus> me too :)

[13:43] <stevan> $deadlines--

[13:43] * stevan has several $deadlines all one after the other

[13:43] <castaway> don't we all? just these pesky customers that need them 

[13:43] <Limbic_Region> um - are underscores supposed to work as comma like breaks in numbers as in p5?

[13:43] <autrijus> Limbic_Region: I have no idea. so I presume "default yes"

[13:44] <Limbic_Region> if so - then there is a parse bug

[13:44] <autrijus> nod

[13:44] <Limbic_Region> ?eval for 1 .. 1000 { } 'foo'

[13:44] <evalbot6> 'foo' 

[13:44] <Limbic_Region> ?eval for 1 .. 1_000 { } 'foo'

[13:44] <evalbot6> Error: No compatible subroutine found: "&_000" 

[13:44] <autrijus> tests welcome

[13:45] <Limbic_Region> yeah yeah yeah

[13:45] * Limbic_Region was actually looking into an apparent rand() bug

[13:45] <autrijus> :)

[13:46] <Limbic_Region> I will see what I can do - time permitting

[13:46] <autrijus> the fix belong on src/Pugs/Parser/Number.hs line 89

[13:46] <autrijus> somewhat tricky though, as 1__2 is legal but 1__2_ is not

[13:48] <autrijus> hrm, wait, it is legal

[13:48] <castaway> (careful with "as comma", thats a dot over here :)

[13:48] <autrijus> even 1_______._______ is legal

[13:48] <autrijus> craziness.

[13:49] <castaway> fugly ,)

[13:49] <autrijus> indeed

[13:49] <PerlJam> What's crazy is that 1_____._____3  == 1.3

[13:50] <castaway> which evaluates to 1 ?

[13:50] <castaway> that too

[13:51] <autrijus> ok, fixed.

[13:51] <autrijus> committing

[13:56] <theorbtwo> Eh, it's just s/_//g, AFAIK.  What's so complicated | crazy about that?

[13:57] <QtPlatypus> theorbtwo: Its not the stripping, its the parsing of numbers.

[13:57] <autrijus> also, _1 does not work

[13:57] <autrijus> but 0x_1 does

[13:58] <autrijus> (which I got wrong, so still fixing)

[13:59] <autrijus> hm

[13:59] <autrijus> 0x

[13:59] <autrijus> works

[13:59] <autrijus> as "0"

[13:59] <autrijus> even more craziness.

[14:00] * castaway boggles :)

[14:01] <autrijus> I give up full emulation for now :)

[14:01] * autrijus checks in the common case

[14:03] <Limbic_Region> sorry - had $work

[14:03] <Limbic_Region> so now that it is fixed, I will write a test if/when I get a chance

[14:03] <Limbic_Region> but now I have a question about rand()

[14:04] <Limbic_Region> how large a sample, statistically speaking, should I need to see if there is a flaw when choosing 1 .. 10 randomly

[14:04] <theorbtwo> Hm?  Are you implementing your own RNG, or just using Haskell's?

[14:04] <autrijus> theorbtwo: I'm using System.Random

[14:04] <autrijus> ?eval rand(2)

[14:05] <evalbot6> 1.7793987013351635 

[14:05] <autrijus> ?eval rand(2)

[14:05] <evalbot6> 0.9534177356291138 

[14:08] <theorbtwo> In that case 1) You shouldn't need to do /too/ much testing of that.  2) Doing good testing of it is hard.

[14:08] <theorbtwo> Start with a chi-squared test.

[14:09] <Limbic_Region> ok - it looks like the anomoly is going away with a large enough sample size

[14:09] <svnbot6> r6280 | autrijus++ | * Allow underlines inbetween digits: 0xFF_FF etc.

[14:09] <svnbot6> r6280 | autrijus++ | * Trailing underline works too.

[14:09] <svnbot6> r6280 | autrijus++ | * Leading underline currently unsupported; Perl5's "0x__"

[14:09] <svnbot6> r6280 | autrijus++ |   and "0x" are not yet available.

[14:10] <Limbic_Region> what I was seeing with a smaller sample size was the equivalent of flipping a coin and getting heads 8 times in a row

[14:12] <QtPlatypus> Limbic_Region: That is possable.  Even a ballence coin will do that.

[14:12] <Limbic_Region> out of curiosity - does p5 have tests specifically designed for parse errors?  Such as the 1_000 vs 1000 thing?

[14:13] <Limbic_Region> QtPlatypus - I know, which is why I was asking how large a sample was needed to even out the distribution before you could say statistically the coin was fixed

[14:13] * Limbic_Region left his statistics books at home (or in Maine come to think of it)

[14:14] <theorbtwo> There's no such thing as "statistically certian" -- the sample size depends on how sure you want to be.

[14:14] <theorbtwo> ...and my web browser is being obnixious again.

[14:16] <Limbic_Region> theorbtwo - you are mixing theory and practicality - when you start applying the results of the statistical analysis to the real world you can be certain that there is a flaw

[14:16] <Limbic_Region> because you don't get an infinite number of flips 

[14:16] <PerlJam> Limbic_Region: um ... where's the parse error in 1_000 vs 1000  ?

[14:16] <QtPlatypus> Limbic_Region: Hold on I have a copy of the art of computer programing, it has a chaper on this.

[14:16] <Limbic_Region> PerlJam - it was just fixed

[14:16] <Limbic_Region> see 6280

[14:16] * autrijus stops checking pugs store report every half hour ;)

[14:17] <PerlJam> oh, I see what you're saying  (just looked at this window and took your query out of context)

[14:17] <Limbic_Region> autrijus - you haven't written a WWW::Mechanize script to do that for you

[14:17] <autrijus> ...it's always $0.00, not particuarly exciting

[14:17] <autrijus> Limbic_Region: that's a good idea.

[14:18] * Limbic_Region hates coding anything web related but thanks petdance and others for nifty tools like WWW::Mechanize

[14:19] * theorbtwo does some googling, finds that he's forgotten an awful lot of stats.

[14:19] * QtPlatypus find the bit that he was looking for

[14:20] <theorbtwo> L~R: Re mixing theory and practicality, I don't think I am.

[14:21] <QtPlatypus> Knuth suggest 1000 as a minim for a computer chi-square test 

[14:21] <Limbic_Region> *shrug*

[14:21] <theorbtwo> If you tell me you want to be 99% certian that your coin is fair, I can tell you that you should flip it N times.

[14:22] <theorbtwo> If you tell me you want to be 100% certian, I can tell you that you should go home.

[14:23] <Limbic_Region> I guess I am not being clear

[14:23] <Limbic_Region> there either is or isn't a flaw

[14:24] <Limbic_Region> the statistics can't prove that there is or isn't with 100% certainty

[14:24] <Limbic_Region> but in the real world, you can find out for sure

[14:24] <Limbic_Region> the statistics just give you an idea of weather or not to bother looking

[14:24] <QtPlatypus> Limbic_Region: Its a algorthimic RPG.  By some definitions its inherently flawed.

[14:25] <theorbtwo> In the real world you can't find out anything for sure -- you can just be reasonably certian.

[14:25] <theorbtwo> You can even be unreasonably certian.

[14:25] <Limbic_Region> a set of crap die is either loaded or not

[14:25] <theorbtwo> I'm not even certian there's a real world at all.

[14:26] <Limbic_Region> well, neither am I

[14:26] <theorbtwo> Intentionally loaded is easy to find out.

[14:26] <Limbic_Region> exactly

[14:26] <Limbic_Region> anyway - I have to wander off for $work

[14:26] <theorbtwo> A flaw in the dice that makes them not quite fair is a lot harder.

[14:27] <theorbtwo> I once had a dice that wasn't fair from a manufacturing error.

[14:27] * QtPlatypus nods "How much do these dice differ from a set of perfect dice"

[14:27] <QtPlatypus> theorbtwo: How did you discover that?

[14:28] <theorbtwo> Qt: Rolled it a fair number of times, noted occourances.

[14:28] <theorbtwo> Also, examined the dice, noticed one of the sides wasn't flat.

[14:28] * QtPlatypus nods.

[14:29] <QtPlatypus> Then started using it to cheat at RPGs?

[14:29] <QtPlatypus> :D

[14:32] <theorbtwo> Thought about it, Qt.

[14:32] <theorbtwo> I don't remember if it was a d6 or a d10.

[14:32] <theorbtwo> In any case, I find roll-every-3-seconds RPGs annoying.

[14:33] <fglock_> stevan: ping

[14:35] <fglock_> autrijus: ping

[14:37] <autrijus> fglock_: pong

[14:38] <fglock_> the Scalar object is a kind of proxy to it's Value? Such as $x++ calls increment on it's value

[14:38] <autrijus> hm, a value never has state, so that's not quite that

[14:39] <autrijus> $x++ calls increment on the scalar, which FETCH its value, remember that value, do something magically incrementing, store it back, returns the rememberd value.

[14:40] <fglock_> but I can't implement every possible method on Scalar, so I was thinking of something like an autoload

[14:41] <fglock_> I implemented $value.increment as a function that returns a new value

[14:42] <autrijus> that is fine

[14:43] <Limbic_Region> pardon my ignorance and my intrusion and interest in premature optimizations but ...

[14:43] <Limbic_Region> will prefix increments be more efficient than postfix as in C and p5 ?

[14:44] <Limbic_Region> and if so, will the optimizer silently convert postfix to prefix when/where possible?

[14:45] <fglock_> Limbic_Region: I don't think it is possible to see any difference at this point

[14:45] <fglock_> because of the object overhead

[14:47] <fglock_> autrijus: so a Scalar has to respond to map, grep, join, increment, decrement ... - it depends on what is stored inside it

[14:47] <autrijus> fglock_: aye

[14:51] <fglock_> is there a 'default' method in the metamodel, that could be used to dispatch unimplemented methods?

[14:52] <autrijus> yes, see AUTO*

[14:53] <autrijus> AUTOMETH is probably what you're looking for.

[14:56] * Limbic_Region is finishing up a test for _ in numbers but I have this vague recollection that _ wasn't the only separator that could be used?

[14:57] <autrijus> it probably is

[14:57] <fglock_> is a Scalar more or less like a "rw" Reference?

[14:58] <autrijus> fglock_: a scalar is exactly a rw reference. a tieable scalar is something more.

[14:58] <autrijus> (a tieable scalar is a rw reference that can optionally hold an associated object)

[15:03] <fglock_> but references should not auto-deref, otherwise they would be just like the value they point to

[15:04] <autrijus> fglock_: right, but scalar automagically deref when a value is demanded

[15:04] <autrijus> i.e. it delegates FETCH and method calls transparently.

[15:04] <autrijus> it's also very confusing.

[15:05] <autrijus> (but it seems all languages derived from C shares this confusion)

[15:05] <fglock_> and a Reference doesn't do that, right?

[15:05] <autrijus> a refernce does that if it's pointing to a non-scalar container.

[15:05] <autrijus> but does not do that if it's pointing to a scalar container.

[15:05] <autrijus> a scalar container points to values; reference points to containers.

[15:06] <autrijus> so they are also differently typed.

[15:07] <fglock_> so "\1" is the same as "1", because a reference to a value is flattened?

[15:08] <autrijus> no.

[15:08] <autrijus> \1 first creates a constant scalar container

[15:08] <autrijus> holding the value 1

[15:08] <autrijus> and then create a reference

[15:08] <autrijus> pointing to that container

[15:08] <autrijus> it's now pinting to a scalar container

[15:08] <autrijus> so is _not_ flattened.

[15:09] <fglock_> ok

[15:10] <fglock_> thanks autrijus - I'm going for lunch now &

[15:10] <autrijus> np :)

[15:14] <Khisanth> hmm

[15:14] <Khisanth> autrijus: if you have $foo = \1; and $bar = \1; will they both be refering to the same scalar?

[15:15] <autrijus> Khisanth: the answer is "we make no guarantee" :)

[15:16] <autrijus> consequently, "1 =:= 1" is either ill-timed, or undefined.

[15:17] <PerlJam> "ill-timed"?  I like that  :)

[15:17] <autrijus> er. ill-typed.

[15:17] <autrijus> thinko.

[15:20] <theorbtwo> I think implementation-dependent is the best way to handle it.

[15:20] <theorbtwo> That, or false.

[15:20] <autrijus> *nod*

[15:20] <theorbtwo> 0 but true =:= 0 must be false.

[15:20] <autrijus> sure, that's w/o doubt.

[15:20] <autrijus> "0 but true" is not a intrinsic anyway.

[15:20] <autrijus> it's a fully boxed Int object

[15:21] <Limbic_Region> autrijus - underbars are allowed in any kind of number (hex, binary, floating point, etc) - does your fix work in all those cases?

[15:21] <theorbtwo> Hm, I assumed 0 was an Int, not an int, but come to think of it there's no reason for it to be.

[15:23] <autrijus> Limbic_Region: yes, but not 0x_

[15:23] <autrijus> Limbic_Region: pugs consider 0x to be prefix

[15:23] <autrijus> but perl5 considers it part of number

[15:25] <Limbic_Region> ok - waiting for Pugs to finish compiling so I can verify all the tests I have currently pass

[15:26] <Limbic_Region> 3.14_15_926 will parse just fine where as 3._1415 will fail correct?

[15:27] <Limbic_Region> ?eval for 1 .. 1_0 { } 'foo'

[15:27] <evalbot6> 'foo' 

[15:28] <Limbic_Region> ?eval for 1 .. 3.14_15 { } 'foo'

[15:28] <evalbot6> Error: No compatible subroutine found: "&_15" 

[15:28] <Limbic_Region> autrijus - looks like it needs some work

[15:29] <Limbic_Region> ?eval my $foo = 3.14 + 3.1_4; $foo

[15:29] <evalbot6> Error:  unexpected "_" expecting digit, exponent, term postfix, operator, ">>+|<<", ">>+^<<", ">>~|<<", ">>~^<<", ">>?|<<", ">>+<<", ">>-<<", ">>~<<", "\187+|\171", "\187+^\171", "\187~|\171", "\187~^\171", "\187?|\171", "\187+\171", "\187-\171", "\187~\171", "+|", "+^", "~|", "~^", "?|", "+", "-", "~", ";" or end of input 

[15:29] <ods15> ugh

[15:30] <theorbtwo> Is evalbot running an up-to-date version?

[15:30] <Limbic_Region> well - it croaked before on 1 .. 1_0 so I think so

[15:31] <Limbic_Region> ?eval my $foo = 10 + 1_000; $foo

[15:31] <evalbot6> \1010 

[15:31] <theorbtwo> OK then.

[15:31] <ods15> hmm, didn't know there's an eval bot here

[15:31] <ods15> what happens if i do '?eval exit()' ?

[15:32] <Limbic_Region> TIAS

[15:32] <Limbic_Region> ?eval exit()

[15:32] <evalbot6> Error: No compatible subroutine found: "&exit" 

[15:32] <ods15> i'm guessing that means "try it and see"

[15:32] <Limbic_Region> yep

[15:32] <ods15> ?eval exec "nil"

[15:32] <evalbot6> Error: No compatible subroutine found: "&exec" 

[15:32] <ods15> ?eval system "ls"

[15:32] <evalbot6> Error: No compatible subroutine found: "&system" 

[15:32] <ods15> ?eval $$

[15:32] <evalbot6> Error:  unexpected "$" expecting "::" 

[15:32] <Limbic_Region> ods15 - it isn't a "safe" bot

[15:33] <Limbic_Region> err - it is a "safe" bot

[15:33] <ods15> hehe

[15:33] <ods15> ?eval 3+5

[15:33] <evalbot6> 8 

[15:33] <ods15> ?eval fork

[15:33] <evalbot6> Error: No compatible subroutine found: "&fork" 

[15:33] <ods15> cool

[15:34] <Limbic_Region> ods15 - the source code is available in the distribution 

[15:34] <Limbic_Region> if you would like to find some flaws in it - please look there

[15:34] <ods15> nah, maybe later. and what distrobution?

[15:35] <autrijus> ods15: http://svn.openfoundry.org/pugs  is the svn repo

[15:36] <ods15> hmm, what's pugs..

[15:36] <ods15> sounds like "perl bugs"

[15:36] * PerlJam boogles that anyone would be here and not know what pugs is

[15:36] <Limbic_Region> autrijus - I am going to check in the test for the numbers and underscores with pugs breaking - hope that is ok

[15:36] <QtPlatypus> pugs -> perl6 users golfing systems.

[15:37] <QtPlatypus> (Please remove the extra s's)

[15:37] <ods15> PerlJam: for a while, i thought pugs was a perl6 bug tracking system

[15:37] <Limbic_Region> well - that is as soon as pugs is finished compiling

[15:37] <theorbtwo> ods15: Pugs is an implementation of perl6.

[15:37] <autrijus> Limbic_Region: fixed, committing

[15:37] <ods15> i know that now :P

[15:37] <ods15> i'm just goofing

[15:38] <ods15> bug for quite a while i was here i didn't know that

[15:38] <ods15> anyway bbl

[15:38] * QtPlatypus thinks its a pun on hugs, a hascal implimentation.

[15:38] <autrijus> s/hascal/haskell/ but yes.

[15:39] <autrijus> I didn't know what pugs are when I came up with the name.

[15:39] <Limbic_Region> autrijus - alright - test will be comitted sometime later today then as I need to do $work now and another rebuild will take forever

[15:39] <autrijus> I had to google it ;)

[15:39] <autrijus> Limbic_Region: "make unoptimised"

[15:39] <autrijus> Limbic_Region: but thanks!

[16:16] <svnbot6> r6281 | autrijus++ | * recognize underscores in fractional part, too.

[16:16] <svnbot6> r6281 | autrijus++ |   Limbic_Region++ for reporting this.

[16:16] <svnbot6> r6282 | autrijus++ | * cosmetic cleanup to STATUS

[16:33] <kgftr|konobi> http://thegestalt.org/simon/perl/wholecpan.html - Autrijus is 1 module off 100!!!

[16:34] <Aankhen``> Just a note: I'm going out of town on Friday, will be back around the beginning of next month.

[16:34] <autrijus> kgftr|konobi: it depends on how you count :)

[16:35] <fglock> re metamodel1: is there a simple way to obtain the class and class name of an object?

[16:35] <svnbot6> r6283 | fglock++ | * perl5/ runtime: updated TODO; tests

[16:35] <svnbot6> r6284 | fglock++ | * perl5/ runtime: renamed directories

[16:36] <autrijus> fglock: .ref perhaps? stevan had not implemented it iirc

[16:36] <Aankhen``> Is AUTOMETH like AUTOLOAD?

[16:36] <autrijus> .ref is the class, and .ref.name would be name (iirc, not 100% sure)

[16:36] <fglock> I'm implementing .ref :)

[16:36] <autrijus> Aankhen``: yes, but only for methods

[16:36] <Aankhen``> I figured that part out all by myself. ;-)

[16:37] <Aankhen``> What I didn't figure out, though, was whether it should be declared as a sub or a method.

[16:37] <PerlJam> Isn't AUTOMETH mostly for introducing method names and AUTOMETHDEF for actually introducing the method

[16:37] <PerlJam> ?

[16:37] * PerlJam has hazy memory

[16:43] <autrijus> PerlJam is correct.

[16:43] <Aankhen``> So how does it work?

[16:43] <Aankhen``> (in other words: example? :-D)

[16:43] <autrijus> Aankhen``: S10 :)

[16:44] <autrijus> and A12 iirc.

[16:44] <autrijus> A12 is like Finnegan's Wake -- _everything_ is in it

[16:45] <Aankhen``> Heh.

[16:45] <Aankhen``> I hope A12 gives actual examples.

[16:46] <Aankhen``> Apparently not. :-(

[16:47] <PerlJam> A12 is like a dream of what could be.  Only the dream needs to be specced.

[16:49] <autrijus> guido mailed back saying that he appreciates the pugs project, but alas, he does not have time to participate.

[16:49] <autrijus> oh well, one less entry in AUTHORS :)

[16:49] <PerlJam> er, what exactly would he have done?

[16:50] <autrijus> PerlJam: I don't know, perl6->python backend perhaps?

[16:50] <autrijus> ...or the other way around

[16:50] <PerlJam> yeah, that sounds slightly better.

[16:50] <PerlJam> I can't really imagine the first one.

[16:52] <autrijus> mm? python bytecode is not unlike parrot bytecode.

[16:52] <autrijus> so it's actually the easier one

[17:02] <Aankhen``> QtPlatypus++ # GC API

[17:02] <svnbot6> r6285 | fglock++ | * perl5/ object .id() works

[17:06] <fglock> I found out how to get the Class from the object, now I need to get the MetaClass from the Class...

[17:10] <fglock> found it: ::dispatch( ::meta( $p->ref ), 'name' )

[17:18] <autrijus> ooh there are helicopters from helsinki to talinn

[17:18] <autrijus> regular commuting 'copters

[17:18] <wolverian> one just went down a week ago or so.

[17:19] <autrijus> er.

[17:19] <autrijus> not very encouraging

[17:19] <wolverian> passengers and two pilots died.

[17:19] <wolverian> no, not very. :)

[17:19] * autrijus reconsiders

[17:19] <wolverian> but then again, they haven't had problems before, and they've flown for quite a while now.

[17:20] <wolverian> the fast ships are nice, too, as long as the wind doesn't make the sea too choppy.

[17:20] <fglock> can I get a Class from a MetaClass?

[17:32] <autrijus> fglock: well, they should be the same thing when you are working on the backend

[17:33] <svnbot6> r6286 | autrijus++ | * Single-argument calls with object as the argument should

[17:33] <svnbot6> r6286 | autrijus++ |   dispatch to method:

[17:33] <svnbot6> r6286 | autrijus++ |     close $fh   # same as $fh.close

[17:33] <svnbot6> r6286 | autrijus++ |   Reported by Yiyi Hu.

[17:33] <svnbot6> r6287 | fglock++ | * perl5/ - added 'Ref' class skeleton. 

[17:33] <svnbot6> r6287 | fglock++ |   will need more info on the MetaModel to make this work

[17:33] <autrijus> fglock: consult stevan for more information :)

[17:33] <autrijus> (as I need to sleep now, sadly)

[17:33] <fglock> autrijus: I tried calling metaclass->new, but it doesn't return an instance

[17:35] <autrijus> $ALL_CLASSES{$name} ?

[17:35] <autrijus> you can get name from metaclass surely?

[17:35] <autrijus> or identifier

[17:35] <fglock> yes, name works

[17:36] <autrijus> cool

[17:39] <fglock> $Perl6::Class::ALL_CLASSES{$name} seems to work

[17:40] <fglock> yes it does :)

[17:40] <autrijus> :))

[17:40] <autrijus> fglock++ # rock on!

[17:40] <autrijus> no journal today, too tired... /me waves &

[17:40] <fglock> good night

[17:40] <Aankhen``> Nite autrijus.

[18:13] <Supaplex> speaking of which, $fh.close, fh.close and fh.close() are identical, are they not?  I know .js handles foo and foo() differently. foo() calls the method, and foo returns the source for that method.

[18:13] <svnbot6> r6288 | fglock++ | * perl5/ Value - code cleanup

[18:19] <wolverian> fh.close? what's fh?

[18:22] <Qiang> file handler

[18:22] <wolverian> fh.close in perl6 is the same as fh().close()

[18:22] <wolverian> I'm not sure if that was what Supaplex asked, though :)

[18:26] <kolibrie> I'm looking at WWW-Kontent, but get a pugs parse error when trying to make_root

[18:26] <kolibrie>     unexpected "{"

[18:26] <kolibrie>     expecting trait, ";" or end of input

[18:26] <kolibrie>     at ./WWW/Kontent/Store.pm line 188, column 30

[18:26] <kolibrie> which is this line:

[18:26] <kolibrie> class WWW::Kontent::Revision {

[18:26] <kolibrie> any ideas?

[18:27] <fglock> I've seen this many times - it means there is an error _anywhere_ in the class

[18:27] <kolibrie> oh joy!

[18:28] <fglock> the best way to find out is to diff with a working version

[18:28] <kolibrie> well, it parsed with an older pugs, but had a runtime error, so I updated my pugs

[19:06] <svnbot6> r6289 | Limbic_Region++ | Added tests for parsing numbers with underscore

[19:06] <autrijus> fglock:, kolibrie 

[19:06] <autrijus> try taking off the "try"

[19:06] <autrijus> in Parser.hsline 301

[19:06] <autrijus> that may give much more accurate error messages.

[19:06] <autrijus> (it makes the class pasing rule non-backtrack)

[19:07] <autrijus> I don't know whether that will cause more problems elsewhere though. try different tries :)

[19:07] * autrijus goes back to sleep &

[19:07] <kolibrie> ok

[19:07] <kolibrie> thanks for the hint autrijus 

[19:07] <autrijus> np :)

[19:19] *** spinclad is now known as spinclad__

[19:20] *** spinclad__ is now known as spinclad___

[19:21] <kolibrie> ah, error is now:

[19:21] <kolibrie>     unexpected "f"

[19:21] <kolibrie>     expecting digit, "_", exponent, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or "}"

[19:21] <kolibrie>     at ./WWW/Kontent/Store.pm line 205, column 71

[19:22] <kolibrie> which is this line:

[19:22] <kolibrie> method driver(Request $r)  returns Void                   { ._fill_revclass(); $._revclass.driver_($r)     }

[19:22] *** spinclad___ is now known as spinclad

[19:22] <kolibrie> so the ._fill_revclass() is not understood

[19:23] <kolibrie> any ideas?

[19:25] <theorbtwo> Hm, get rid of that leading _, and see if it still parses?

[19:25] <theorbtwo> It's possible that it's thinking that should be a number, like ._3, meaning .3 -- autrijus was just working on that earlier today.

[19:26] * kolibrie tries

[19:26] <autrijus> right, exactly.

[19:26] <autrijus> sigh.

[19:27] <autrijus> fixing.

[19:28] <kolibrie> yep, seems to be true, parses fine without the _

[19:28] <autrijus> fixed. committing

[19:29] <kolibrie> autrijus++ # fixing bugs while sleeping

[19:29] <autrijus> that seems to be my specialty

[19:34] * theorbtwo should remember not to use aut's name while he is (theoretically) sleeping.

[19:37] * kolibrie waits for aut's commit to be available

[19:39] <autrijus> it's ambiguous.

[19:39] <autrijus> say 1.__e4

[19:39] <autrijus> in p5 it's clearly 10000

[19:39] <autrijus> I have _no_ idea about p6.

[19:39] <autrijus> thoughts?

[19:40] * kolibrie also has _no_ idea

[19:40] <autrijus> maybe disallowing underscores in fractional parts?

[19:40] <autrijus> I think that's sanest.

[19:41] <theorbtwo> Or disallowing underscores just before or after the . in floating-point numbers.

[19:41] <autrijus> before is fine.

[19:41] <autrijus> 1.e__4

[19:42] <autrijus> is 10000 in perl5.

[19:42] <autrijus> I'm pretty sure we want it to be a method call in p6.

[19:42] <autrijus> 0x1.fe_ff_ff_f9

[19:42] <autrijus> ;)

[19:42] <theorbtwo> I think so too... and that wouldn't be under my rule.

[19:42] <autrijus> so I think disallow is safer now.

[19:42] <theorbtwo> That looks like a number to me.

[19:42] <theorbtwo> 0x1.fe_ff... that is.

[19:43] <autrijus> but isn't it a method called fe_ff_ff_f9?

[19:43] <theorbtwo> That'd be a really silly name for a method.

[19:43] <autrijus> 0xFF.dead;

[19:43] <autrijus> 0xFF.add;

[19:43] <theorbtwo> Point.

[19:43] <kolibrie> yep, must be a method

[19:44] <theorbtwo> It doesn't come up for anything but hex, so it's not that important to me.

[19:44] <autrijus> 1.44_44_12

[19:44] <theorbtwo> Hex fractions don't seem that useful.

[19:44] <autrijus> is a number clearly

[19:44] <theorbtwo> Can't be a method -- method names can't begin with digits.

[19:44] <autrijus> 1.e10

[19:44] <autrijus> is again ambiguous.

[19:44] <autrijus> and it doesn't even involve underscore.

[19:44] <theorbtwo> Method.  If you want number, write 1e10 with the same meaning.

[19:45] <autrijus> ok. so if it can be a method

[19:45] <autrijus> it is a method

[19:45] <integral> almost need a numeric quote operator with delimiters, q:number"1.e10"

[19:45] <autrijus> does that sound okay?

[19:45] <theorbtwo> I think so, yeah.

[19:46] <kolibrie> if ambiguous, choose method over number, sounds good

[19:50] <autrijus> r6290. enjoy

[19:51] <autrijus> it passes parsing_numbers.t

[19:51] <autrijus> more tests welcome there.

[19:51] <autrijus> &

[19:53] <kolibrie> thank you

[19:53] <svnbot6> r6290 | autrijus++ | * Disallow underscore and 'e' after dots, as that conflicts with method

[19:53] <svnbot6> r6290 | autrijus++ |   name resolution.  Reported by kolibrie.

[19:53] <svnbot6> r6290 | autrijus++ |     1.e10   # method call

[19:53] <svnbot6> r6290 | autrijus++ |     1._10   # ditto

[19:59] <spinclad> the longest-possible-token rule, common among languages, would want those to be numbers.

[20:00] <spinclad> don't know if perl*, and perl6 in particular, has that rule, though.

[20:02] <Limbic_Region> autrijus - according to perldata underscores are only allowed between digits

[20:02] <Limbic_Region> for p5 anyway

[20:02] <Limbic_Region> sorry it took so long to commit - $work has been busy

[20:02] <spinclad> 0x1.e10 is ambiguous three ways -- is that e a digit, exponent mark, or alpha?

[20:02] <Limbic_Region> and besides - I am officially not working on Pugs anymore

[20:02] <Limbic_Region> ;-)

[20:05] *** Aankh|Clone is now known as Aankhen``

[20:05] <xinming> hmm... $obj.update; without any arguments, Can it be written in this form, `update $obj;`

[20:06] <Limbic_Region> yucky poo poo

[20:07] <Aankhen``> ?eval any<a b c d> eq "a"

[20:07] <evalbot6> bool::false 

[20:07] <Aankhen``> ?eval "a" eq any(<a b c d>)

[20:07] <evalbot6> bool::false 

[20:07] <Aankhen``> Hmm.

[20:07] <xinming> hmm... In Synoposis said it's valid. But in Pugs, It won't allow you to use this.

[20:07] <xinming> which one should I follow please?

[20:08] <xinming> I've send this question to mailing list. But it doesn't seem that anyone who cared about my question.

[20:08] <iblech> Hi :)

[20:08] <Aankhen``> Hi iblech. :-)

[20:08] <xinming> iblech: hi

[20:08] <iblech> ?eval ?(any<a b c d> eq "a")

[20:08] <evalbot6> bool::false 

[20:08] <iblech> Hrm

[20:08] <Aankhen``> iblech: Should that work?

[20:08] <Aankhen``> (I would have thought it should)

[20:08] <iblech> It should

[20:08] <Aankhen``> OK.

[20:08] <Limbic_Region> it has in the past IIRC

[20:08] <iblech> ?eval ?(any("a", "b", "c", "d") eq "a")

[20:08] <evalbot6> bool::true 

[20:09] <iblech> ?eval ("a", "b", "c", "d")

[20:09] <evalbot6> ('a', 'b', 'c', 'd') 

[20:09] <iblech> ?eval <a b c d>

[20:09] <evalbot6> ('a', 'b', 'c', 'd') 

[20:09] <iblech> ?eval <a b c d>[0] eq "a"

[20:09] <Limbic_Region> ?eval any('a', 'b', 'c') eq 'a'

[20:09] <evalbot6> bool::true 

[20:09] <evalbot6> bool::false 

[20:09] <Aankhen``> It's not urgent... I'm converting some of my "hobby" modules to Perl 6, and a lot of other stuff doesn't work yet anyway.

[20:10] <Aankhen``> ?eval sub foo (*&cb, *@params) { &cb.(*@params) }

[20:10] <evalbot6> undef 

[20:10] <Aankhen``> ?eval sub foo (*&cb, *@params) { &cb.(*@params) }; foo({ @_ }, "a", "b")

[20:10] <evalbot6> Error: Undeclared variable: "@_" 

[20:10] <Aankhen``> ?eval sub foo (*&cb, *@params) { &cb.(*@params) }; foo(sub { @_ }, "a", "b")

[20:10] <evalbot6> ['a', 'b'] 

[20:10] <Aankhen``> Kewl.

[20:10] <Aankhen``> ?eval sub foo (*&cb, *@params --> List) { &cb.(*@params) }; foo(sub { @_ }, "a", "b")

[20:10] <evalbot6> ['a', 'b'] 

[20:11] <Aankhen``> ?eval sub foo (*&cb, *@params --> List) { &cb.(*@params) }; foo("a", "b"):sub { @_ }

[20:11] <evalbot6> Error: Undeclared variable: "@_" 

[20:11] <Aankhen``> ?eval sub foo (*&cb, *@params --> List) { &cb.(*@params) }; foo("a", "b"):(sub { @_ })

[20:11] <xinming> ?eval ('a'|'b'|'c') eq 'a'

[20:11] <xinming> ?eval 'a'|'b'|'c' eq 'a'

[20:11] <evalbot6> Error:  unexpected ":" expecting word character, block construct, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:11] <evalbot6> bool::false 

[20:11] <iblech> Hm, I think a slurpy code parameter makes the sub accept a adverbial block

[20:11] <Aankhen``> Um, sorry for the spam.  I'll go back to the interactive shell.

[20:11] <Aankhen``> iblech: Not a sub, then?

[20:12] <iblech> xinming: Because of a bug in evalbot/.perl/whatever, you probably need to ?(...) your expressions

[20:12] <Aankhen``> OK.

[20:12] <iblech> I mean, foo(@params):{...} would then work, probably

[20:13] <iblech> But I'm not the adverbial modifiers expert, we should better ask putter :)

[20:13] <Aankhen``> Heh, check this out: pugs> sub foo (*&cb, *@params) { "abcd" }; foo():{ @_ } <== <a b c d>

[20:13] <Aankhen``> (undef, undef, undef, undef, undef)

[20:14] <spinclad> (re: number formats) perldata doesn't make clear whether hex numbers can have a fractional part or exponent; i would guess yes based on orthogonality, no based on ambiguity.

[20:14] <xinming> ?eval ?('a'|'b'|'c' eq 'a')

[20:14] <xinming> neither worked. T_T

[20:14] <evalbot6> bool::true 

[20:14] <xinming> iblech: can `$obj.update;` be written in this form: `update $obj;` ?

[20:14] <Aankhen``> xinming: update $obj:;

[20:14] <Aankhen``> # perhaps that might work?

[20:15] <iblech> xinming: Yep, I think. It's a special case. If you've got more than one argument, you need the colon, though

[20:15] <iblech> i.e. update $obj will work, but update $obj, $foo won't. To make it work, you'd have to write update $obj: $foo

[20:15] <svnbot6> r6291 | iblech++ | * t/syntax/parsing_numbers.t: Added tests for 1.e23 etc.

[20:15] <svnbot6> r6291 | iblech++ | * Usual svn props.

[20:16] <xinming> Aankhen``: I know that works. But I wonder if the example I give is also valid.

[20:16] <xinming> with `:`, It will work, how about without `:`?

[20:16] <Aankhen``> xinming: iblech just gave you the answer, didn't he? :-)

[20:17] <xinming> iblech: hmm, So, This might be a really "small" bug in pugs.

[20:17] <xinming> :-)

[20:17] <xinming> ?eval 3+5

[20:17] <evalbot6> 8 

[20:17] <xinming> oops, It seems that the bot ignored me. :-S

[20:17] <xinming> or autrijus is tuning his bog.

[20:18] <xinming> bot.

[20:18] <xinming> s/bog/bot/

[20:18] <iblech> I've thought autrijus fixed the bug?

[20:19] <iblech> ?eval class A { method b () { "c" } }; b A.new

[20:19] <evalbot6> 'c' 

[20:19] <iblech> :)

[20:19] <iblech> ?eval class A { method b () { "c" } }; b A.new:

[20:19] <evalbot6> 'c' 

[20:20] <xinming> ?eval class T { method update { 'updated'.say; } }; my T $o .= new; update $o;

[20:20] <evalbot6> updated bool::true 

[20:20] <xinming> Yes,It's fixed. :-)

[20:27] <xinming> after reading more Synoposis, I found now, the keyword package has 3 usages. one is for acting as a 'signature' for perl 5, another is for using tie, and last is used for user defined libs, Is my opinion right?

[20:27] <svnbot6> r6292 | iblech++ | * t/syntax/parsing_numbers.t: Added link to p6l post.

[20:27] <svnbot6> r6292 | iblech++ | * PIL2JS: PIL::PExp wasn't calling the ->as_js of the expr it contains,

[20:27] <svnbot6> r6292 | iblech++ |   resulting in nothing working. Fixed.

[20:27] <iblech> xinming: For tie, you need classes, not packages.

[20:27] <iblech> But the rest is ok, I think.

[20:28] <iblech> (And note that the difference between package and module is very blurred.)

[20:28] <xinming> ?eval given '3' { when 1 { 1 }; when 3 { 3 };}

[20:28] <evalbot6> 3 

[20:33] * xinming is still wondering if the keyword package will be obsolete after perl 6 rules the world.

[20:35] <xinming> ?eval class C { has $.a = 1; };

[20:35] <xinming> I think autrijus is compiling the new version of pugs. :-)

[20:35] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[20:37] <iblech> has with assignment doesn't parse, known bug.

[20:38] <iblech> Already tested for in t/oo/attributes/class.t, I think

[20:41] <xinming> ?eval class C { has $.a; has $.b; }; my C $o .= new; $o{'a'} = 1; $o.keys;

[20:42] <evalbot6> Error: Not a keyed reference: VObject (MkObject {objType = (mkType "C"), objAttrs = <ref>, objOpaque = Nothing, objId = 52}) 

[20:42] <iblech> spinclad: Luke replied to my post on p6l WRT the ambiguity of parsing numbers -- want to reply with your "but it against the longest-token rule"?

[20:42] <iblech> $o.keys should definitely not work, unless C isa Hash.

[20:43] <iblech> But I did read something in one of the apocalypses that $o<a> should work

[20:43] <iblech> Not sure, though

[20:43] <iblech> Want to ask p6l? :)

[20:43] <spinclad> sure

[20:44] <iblech> Great :)

[20:46] <xinming> iblech: in fact, I wonder if that the object is still a blessed reference :-)

[20:46] <xinming> blessed anonymous reference.

[20:47] <iblech> It is blessed, but (by default) it's not a hashref, but a P6Opaque

[20:47] <iblech> P6Opaque is like a hashref, only that it has got compile-time typo checks and a much more compact storage and much more :)

[20:52] <xinming> hmm. wish the class is a blessed hashref, then, some perl 5 codes might be easier to migerate to perl 6

[20:52] <xinming> ?eval class C { has $.a; has $.b; }; my $t = C.bless({'a' => 1 }); $t.keys;

[20:52] <evalbot6> Error: No compatible subroutine found: "&bless" 

[20:54] <xinming> ?eval class C { has $.a; has $.b; }; my $class = "C"; my $t = $class.bless({'a' => 1 }); $t.keys;

[20:54] <evalbot6> Error: No compatible subroutine found: "&bless" 

[20:54] <iblech> This will probably work eventually.

[20:56] <xinming> iblech: will the $object be a hashref always by default in perl 6?

[20:57] <iblech> No. But you can use .bless to override that default

[20:57] <iblech> Because with hashrefs, it's not possibly to do compile-type typo checks and have a much more compact storage etc. :)

[20:59] <xinming> so my $c = $class.bless; will do what I want, without specify the bless({}); ?

[20:59] <iblech> No, you do need the {}

[20:59] <iblech> Sorry if I was unclear

[21:03] <xinming> iblech: well, It's Ok if your unclear, I must thank you for your patient. :-)

[21:03] <svnbot6> r6293 | iblech++ | * t/syntax/parsing_numbers.t: Added Luke's response.

[21:03] <svnbot6> r6293 | iblech++ | * PIL2JS: Probably restored to fully working :)

[21:03] <svnbot6> r6293 | iblech++ |   * PIL::PStmt, PIL::PPos, and PIL::PExp all bubble up the ->{CC} to their

[21:03] <svnbot6> r6293 | iblech++ |     inner objects -- i.e. PIL::PApp will get the ->{CC} even if it's packed in

[21:03] <svnbot6> r6293 | iblech++ |     a PIL::PExp.

[21:03] <svnbot6> r6293 | iblech++ |   * PIL::PVal, PIL::Params, PIL::Subs: Misc. smaller fixes.

[21:03] <iblech> np :)

[21:04] * Aankhen`` goes to sleep.

[21:04] <iblech> Night Aankhen`` :)

[21:04] <Aankhen``> ?eval sub foo (*%_) { %_ }; my $bar = "_"; foo($bar => "bar")

[21:05] <evalbot6> {('bar' => undef)} 

[21:05] <iblech> Oh and we'll miss you :(

[21:05] <Aankhen``> I'll miss you guys too!

[21:05] <Aankhen``> Anyway.

[21:05] <Aankhen``> Must sleep.

[21:05] <Aankhen``> G'night.

[21:07] <xinming> ?eval class C { has $.a; my $.a; };

[21:07] <evalbot6> undef 

[21:07] <xinming> ?eval class C { my $.a; has $.a; };

[21:07] <evalbot6> undef 

[21:08] <iblech> my $.foo and our $.foo are not yet implemented (IIRC), you'll have to wait for the new PIL runcore which uses the metamodel

[21:08] <fglock> I'm trying to understand what's the point of having References, is everything is auto-dereferenced

[21:09] <iblech> Not all things auto-dereference anymore, only refs to aggregates

[21:09] <iblech> I.e. (\3).isa(Ref) is true, but (\@array).isa(Ref) and ([1,2,3]).isa(Ref) are false

[21:09] <xinming> hmm, which will be used for accessor method?

[21:10] <iblech> fglock: See http://www.nntp.perl.org/group/perl.perl6.language/22532

[21:10] <iblech> xinming: Dunno. Probably it's an error to declare two "$.a"s

[21:11] <xinming> iblech: hmm. In fact, I wonder something what from larry thought. :-)

[21:13] <fglock> in order to "deref one level" the dereference will have to be done by the compiler - the object doesn't know which level it is, right?

[21:14] <xinming> iblech: hmm, One is public attribute, another  is the class attribute, I think they can have the same name in the class. though, don't know how larry thinks of this.

[21:15] <iblech> fglock: I'm not sure I've understood you right, but yes, the object does not never which level it is

[21:15] <iblech> And BTW, if you want to turn an autodereffing ref into a non-autodereffing ref, you've to use tied: $arrayref.isa(Ref) is false, but tied($arrayref).isa(Ref) is true

[21:16] <iblech> (But "tied" is the wrong name for this operation, as tied operates on containers, not values. I've asked Larry about this, but the topic got warnocked.)

[21:16] <iblech> xinming: Ask p6l :)

[21:17] <fglock> I mean, \\3 dereferences to \3, which doesn't dereference 

[21:17] <iblech> No \\3 does not autoderef

[21:17] <iblech> Only refs to aggregates autoderef

[21:18] <iblech> And \3 is not an aggregate, so \\3 won't autoderef

[21:18] <iblech> But I may be wrong of course -- you might want to ask p6l to be certain :)

[21:18] <fglock> [[ 1,2,3 ]] dereferences to [ 1,2,3 ], which doesn't dereference to Array

[21:19] <iblech> No, [[ 1,2,3 ]] derefs to ([1,2,3])

[21:19] <iblech> And this is simply an Array containing one elem

[21:24] <fglock> I need to write tests for Ref and Scalar - this will help

[21:25] <xinming> iblech: what does p6l mean pleaes?

[21:25] <iblech> xinming: Oh, p6l is short for perl6-language, the mailinglist on which Perl 6's design is discussed

[21:25] <iblech> xinming: See http://dev.perl.org/perl6/lists/

[21:26] <iblech> (Similarily, p6c is perl6-compiler and p6i is perl6-internals.)

[21:26] <iblech> fglock: Yep -- before implementing autoderef in PIL2JS, I wrote t/var/autoderef.t

[21:27] <iblech> fglock: You might be able to port some of autoderef.t to Perl 5

[21:28] <xinming> iblech: thanks

[21:29] <iblech> xinming: Sure, np

[21:30] <xinming> ?eval my $var = 1; ('a' => $var) = "value";

[21:30] <xinming> what does this mean really.

[21:30] <evalbot6> ('a' => \'value') 

[21:32] <iblech> This is a special case -- if you assign something to a pair value (not a container holding a pair!), then the pair's .value will be modified

[21:32] <iblech> I.e. $var is "value" after the assignment

[21:33] <xinming> ?eval my $var = 1; ( $var => 'a' ) = "value" ;

[21:33] <evalbot6> Error: Can't modify constant item: VStr "a" 

[21:33] <iblech> Oh and while we're at it, if you use :=, you're allowed to put the usual subroutine signature syntax in the left hand side

[21:33] <iblech> I.e.

[21:33] <iblech> (*$first_thing, *@remaining_things) := foo()

[21:35] <xinming> ?eval my $var = 1; ( $var => 'a' ) := "value" ;

[21:35] <evalbot6> Error: Cannot bind this as lhs: Pos (MkPos "<eval>" 1 16 1 28) (App (Var "&infix:=>") Nothing [Var "$var",Cxt (CxtItem (mkType "Str")) (Val (VStr "a"))]) 

[21:36] <iblech> This is another special case, allowing things like

[21:36] <iblech> (foo => $foo, bar => $bar) := (bar => calc_bar(), foo => calc_foo())

[21:36] <iblech> but it isn't implemented yet

[21:38] <iblech> (BTW, allowed things like (+$foo, ?$bar) := baz() aren't even parsed currently.)

[21:39] <iblech> IIRC S06 has got more details

[21:40] <fglock> I'm reading autoderef.t - yes it helps :)

[21:42] <iblech> Great :)

[21:45] <svnbot6> r6294 | iblech++ | * STATUS: Noted that I'm currently converting PIL2JS to use -CPerl5.

[21:45] <svnbot6> r6294 | iblech++ | * PIL2JS: More fixes in PIL::Subs, PIL::PApp, and Prelude::JS::Operators;

[21:45] <svnbot6> r6294 | iblech++ |   thanks to -CPerl5 for allowing a *much* faster edit/compile/test cycle. :)

[21:46] <iblech> Ok, need to sleep now.

[21:46] <iblech> Night all :)

[21:46] <spinclad> i've sent the p6l thread my longest-token-rule note, but it hasn't shown up yet; i suppose it's waiting to be vetted as non-spam?

[21:47] <fglock> spinclad: maybe - my mails take a day to show

[22:34] <svnbot6> r6295 | fglock++ | * perl5/ 'Ref' works (but hacky)

