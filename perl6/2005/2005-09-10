[01:06] <svnbot> r6915 | putter++ | PIL-Run - basic my() and temp()

[01:09] <putter> stevan_: ping?

[01:10] <stevan_> putter: pong

[01:10] <putter> what would be involved in upgrading PIL-Run to mm v2?

[01:10] <putter> is that a reasonable thing to be thinking about at this point?

[01:11] <stevan_> putter: sorry.,.. trying to get the new client working

[01:11] <stevan_> putter; mm2.0 is not yet finished

[01:12] <putter> np

[01:12] <putter> ok, so the right thing is to defer the upgrade for later

[01:12] <stevan_> putter: yes

[01:12] <stevan_> I am trying to keep the interfaces/APIs the same

[01:12] <putter> great.  tnx.  looking forward to it :)

[01:13] <stevan_> however, some fundemental parts of the design have changed

[01:13] <stevan_> so there might be some bits that need tweaking

[01:13] <stevan_> and to be totally honest, I am not 100% how the MM and the runtimes will fit together

[01:14] <putter> hmm... I suggest you feel free to make api changes on whim.  we have a very very small code base at the moment.  better to get things right early,

[01:14] <stevan_> you, fglock and iblech are blazing new trails :)

[01:14] <stevan_> I was going to look at PyPy to see how they did it actually

[01:15] <putter> I'm just sweeping up behind the parade.

[01:15] <stevan_> but, I have to run right now,.. be back in later tonight

[01:15] <putter> ok.  main question answered.  thanks. &

[01:15] <stevan_> putter++

[01:44] <new-b> hello

[01:44] <dudley> hello

[01:45] <new-b> hi dudley 

[02:37] <stevan_> luqui: ping

[03:11] <luqui> stevan_, pong

[03:12] <stevan_> luqui: hey

[03:12] <luqui> grass

[03:12] <svnbot> r6916 | stevan++ | Perl6::MetaModel 2.0 - 

[03:12] <svnbot> r6916 | stevan++ | * fixing GC issue again, since I upgraded my perl

[03:12] <svnbot> r6916 | stevan++ | * testing the ability to disambiguate method calls by using the $::Package

[03:12] <svnbot> r6916 | stevan++ |   interface to fetch the method first, then call it

[03:13] <stevan_> luqui: Call::Immediate very interesting

[03:13] <luqui> thanks

[03:13] * luqui is going to use it for Class::Theory

[03:14] <stevan_> what is Class::Theory

[03:14] <luqui> it's my type-class-like object model that I described to you a little while ag

[03:14] <luqui> ago

[03:14] <stevan_> ah yes

[03:15] <stevan_> hey,.. do you have a link on that?

[03:15] <stevan_> you deleted it from the pugs repo

[03:15] <luqui> on which?

[03:15] <luqui> oh, yes, I did

[03:15] <stevan_> just information on it

[03:15] <stevan_> it was a Scala thing right?

[03:15] <luqui> I'll bounce you the message I sent to sixperl

[03:15] <luqui> yeah

[03:15] <stevan_> yes, please

[03:15] <stevan_> I would like to read more on it

[03:16] <stevan_> you got my interest, then you deleted it :P

[03:16] <luqui> sorry

[03:16] <luqui> had to rethink my ideas

[03:16] <stevan_> not a problem :)

[03:16] <luqui> still rethinking them :-)

[03:16] <luqui> sent

[03:16] <stevan_> mucho gracias

[03:18] <stevan_> luqui: have you read TAPL yet?

[03:18] <luqui> no, it was just suggested to my by autrijus yesterday

[03:18] <luqui> trying to get my hands on it

[03:18] <stevan_> ah

[03:19] <luqui> (my university has it as an online paper, but they have it set up so I can't download it, so I have to read it on campus )-:

[03:19] * stevan_ just started reading it,.. but it is making my eyes cross 

[03:19] <luqui> hmm, chances are it'll make my eyes cross for a little while until I "get it"

[03:20] <stevan_> chances are you will "get" more of it than I am 

[03:20] <luqui> that's how these things usually work.  It's not incremental learning, it's all-at-once :-)

[03:20] <luqui> we'll see

[03:21] <stevan_> I "get" the gist of it,.. its the real heavy math stuff which gets to me

[03:21] <stevan_> and the terminology

[03:21] <stevan_> but I have already learned a bunch and I am only on chapter 4

[03:21] <stevan_> so it is worth the effort

[03:22] <luqui> Yeah.  It'd probably be good for me to start proposing things out of books rather than my ass

[03:22] <stevan_> :D

[03:23] <stevan_> hey, dudly and I were talking about trying to do some pugs-related Scala stuff

[03:23] <stevan_> you should join in

[03:24] <luqui> hmm?

[03:24] <luqui> like what?

[03:24] <stevan_> I was thinking the metamodel

[03:24] <stevan_> I was thinking the metamodel

[03:24] <stevan_> bah,.. damn keys

[03:24] <stevan_> I am obsessed though,.. so it doesnt have to be that

[03:24] <luqui> ahh

[03:25] * luqui might want to learn scala...maybe

[03:25] <dudley> I started playing with it today, but I got hung up on Scala's unit testing and didn't get further than P6Opaque

[03:25] <stevan_> hey dudley :)

[03:25] <dudley> biab

[03:25] <dudley> hello!

[03:26] * luqui goes into windows where he can get on the university vpn

[03:26] <stevan_> luqui: so a theory really has nothing to do with a class 

[03:26] <stevan_> bah

[03:36] <dudley> hmm, so where should the scala mm live?

[03:36] <dudley> I think perl5/ is getting a little overloaded...

[03:37] <stevan_> dudley: I agree,.. although I am not sure we have a better place at the moment

[03:37] <dudley> Not that I have anything to commit yet :-)

[03:37] <stevan_> I think perl5 is fine for now,.. there is talk of relenging this weekend,.. so we can move it then

[03:38] <stevan_> dudley: so what about Scala Unit testing got you hung up

[03:38] * stevan_ has only downloaded and ran hello world with Scala

[03:38] <dudley> It's not quite complete.

[03:38] <stevan_> ah

[03:38] <dudley> there's not a TestRunner

[03:38] <stevan_> thats an issue maybe

[03:38] <dudley> it only reports failures

[03:40] <stevan_> luqui: your theory Base looks straight outta TAPL 

[03:41] <stevan_> dudley: how good is the Java interface? can we use JUnit?

[03:41] <dudley> It shouldn't be too much of a problem, I don't think. I'll give it a whirl tomorrow.

[03:42] <luqui> the example?

[03:43] <stevan_> luqui: yes

[03:43] <luqui> well, that's probably because I got the example from autrijus

[03:43] <stevan_> :)

[03:43] <luqui> who probably got it from the book

[03:43] <luqui> it's the one he used to show me GADT in haskell

[03:43] <stevan_> yes the whole first part is all about succ, pred, is_zero, if t1 then t2 else t3...

[03:43] <luqui> and completely sold me on haskell, causing me to really try to learn it (instead of just kinda sorta wanting to)

[03:44] * luqui is reading it now

[03:48] <dudley> Goodnight, everybody.

[03:48] <stevan_> nite dudley 

[03:48] <dudley> sleep &

[03:48] <stevan_> I should sleep too

[03:48] <stevan_> night all

[03:48] <stevan_> luqui: enjoy TAPL :)

[03:48] <stevan_> &

[03:52] <putter> good night stevan

[03:53] <putter> so, pilrun now does return/last/next/redo, for some value of "does".

[03:53] <svnbot> r6917 | putter++ | PIL-Run - first cut at return(), last(), next(), redo().

[03:54] <putter> next step is to hoist code objects out of loops, so they dont get created repeatedly.  the delay is actually visible.

[03:55] <putter> luqui is reading.  anyone else left on the night shift?

[03:55] <spinclad> just caught up with backlog.  (whew!)

[03:56] <putter> :)

[04:00] <spinclad> re. perl5/ (after the release), i'd suggest hoisting metamodel and pil stuff upward, but don't know under what name or whether they belong together.  Subdirs for @backends, which determines some of the hierarchy, but not all...

[04:02] <putter> we certainly need to do something

[04:03] * Supaplex eats a cashew

[04:04] <putter> i'm not sure it needs to be after the release either, current usage is so narrow (a couple of people repeatedly doing a few things) that I'm not sure we gain much from "it's been working as-is".

[04:04] <Supaplex> guess what my new plates have on them :)

[04:04] <putter> elephants?

[04:05] <spinclad> nuts.

[04:05] <Supaplex> perl6

[04:05] <Supaplex> :)

[04:05] <putter> one follows the other

[04:05] <putter> cafepress?

[04:06] <putter> My guess is this release will need a lot of testing and repair.

[04:07] <putter> If we can put together a good vision of where the pieces should go, testing and repairing that might be worth the extra pain.

[04:09] <spinclad> Code-Perl, Perl6-{Container,Value} go into @backend<perl5> (oops, should be %), leaving T2-Perl6 stranded (first MetaModel customer?) maybe

[04:10] <putter> is anything actually using Code-Perl?

[04:10] <spinclad> sort of turning perl5/ inside out

[04:11] <spinclad> sorry, i haven't kept close enough track to know

[04:11] <putter> my fuzzy impression is it is inactive

[04:11] <putter> the rest seems plausible though

[04:13] <luqui> putter: I believe Code-Perl is not being used

[04:13] <spinclad> i think you're right, that Code-Perl has already been cannibalized into MM.

[04:13] <luqui> we were going to use it for Perl::Compiler

[04:13] <luqui> But then PIL-Run took over that job

[04:14] * putter has never really come to delight in the name PIL-Run...

[04:15] <putter> ok, so

[04:15] <putter> pugs/backends/perl5/ Perl6-MetaModel PIL-Run ...

[04:15] <putter> unified lib/ or still separate?

[04:16] <putter> does PIL2JS with its heavy use of perl for compilation go in backends/js/ or perl5/?

[04:16] <putter> actually, suggest non-unified lib.

[04:17] <putter> one puzzle is that the various backends which use perl5 to fiddle with PIL, may share common libraries to do so.  they go in... ext/ ?

[04:18] <putter> is everyone happy with PIL-Run as a name?  its currently fairly easy to change, but that window is closing.

[04:20] <putter> is "backend/" a general enough concept?  if I write a PIL optimizer using a combination of p5 and something declaritive, say a tabling prolog, where does it go?  what if it emits p5 code?

[04:21] <putter> projects/ would cover all that, but perhaps looses too much meaning

[04:21] * putter realizes he has been talking to himself for 6 minutes ;)

[04:22] <spinclad> i think one backend per language won't suffice; we'll have reimplementations, competing experiments, etc

[04:22] <putter> agreed

[04:24] <putter> and worth emphasizing somehow - PIL-Run performance will in some respects be _glacial_ for a while.  there seems a real risk of folks going "oh, perl6 is slooow" (silly, but folks did it to lisp)

[04:25] <putter> PIL::Run::Proto0 ;)

[04:25] <putter> permitting PIL::Run::SomethingElse

[04:26] <spinclad> :)

[04:28] <putter> PIL seems unlikely to remain a singular unvariagated thing for long

[04:28] <putter> already isnt (PIL2)

[04:28] <spinclad> right

[04:28] <luqui> is PIL2 going anywhere?

[04:30] <putter> my impression is $work is eating rather more of a's cycles than he originally envisioned.  or the plan may have changed to limited pugs for a while, to make $ for big time block (something went by which left that impression)

[04:31] <putter> there is some stuff in src/PIL/

[04:31] <spinclad> yes, he's banking up for erdosing

[04:36] <spinclad> i just searched the tree for anything named PIL2* and only found PIL2JS.  where'd it go?  i thought i remembered it somewhere...

[04:37] <spinclad> ah, right, src/PIL.hs.  d'oh!

[04:38] <putter> back when ARPA was under less incompetent management, there was the concept floating around of allowing project managers do micro grants.  $40k for a year of autrijus is small change in that context.  no one ever had the tuits to pursue it.  and with current administration, its a lost cause.

[04:40] <spinclad> heh.  they don't believe in government doing that sort of patronage, they think that job belongs to industry (along with everything)

[04:41] <putter> Perl6::PIL::ProtoRun

[04:41] <putter> err, no

[04:42] <putter> spinclad: yes.  plus a micromanaging director in an organization which really needs to push down responsibility.

[04:43] <spinclad> bitter, me?

[04:43] <putter> ;)

[04:46] <putter> The concept was for a "wheel greaser".  Eg, someone has the state of subfield X in their brain, but it's never been written down.  Go in and help.  Perhaps that means paying for a scribe.  Or arranging a sabatical.  Or whatever.  Person to help get things unstuck.

[04:48] <putter> I wonder if there is a portable way to constrain how much memory a perl process uses.

[04:48] <spinclad> a sounds to be a prime candidate.  or maybe subsidize a small team, with some such person at its core

[04:49] <spinclad> ulimit?

[04:49] <putter> its amazing how much is held up for really pointless reasons

[04:50] <putter> ulimit on windows?

[04:51] <putter> but ulimit will save me from having to watch smokes so they dont melt down my machine.  thanks! :)

[04:51] <spinclad> windows, dunno.  ulimit -d on bash (on unix, linux, ?POSIX?)

[04:52] <spinclad> and ulimit -s

[04:54] <putter> ulimit -d 1000000  ;)    not an interface which will make it unchanged to terabyte memories

[04:55] <spinclad> ulimit -d 1000000000

[04:55] <spinclad> ;)

[04:57] <spinclad> (you mean the system call?  new version for 64-bit space)

[04:58] <spinclad> s/version/$0 neeeded/

[05:01] <putter> right

[05:01] * putter waits expectantly for a smoke to finish... eventually...

[05:02] <putter> incremental smokes?

[05:03] <putter> each test file gets a smoke data file, so one can be in continuous resmoking.  and as test set grows, it doesnt come to take a day to do a smoke.

[05:04] <spinclad> btw, what state is the parrot target in?  dead for now?  (passing 2/3)  last i heard it was waiting on the new calling convention

[05:04] <spinclad> and none of the metamodel work has targeted it, afaics

[05:06] <putter> yes, unmoving.  we're waiting on cc, and last I heard, leo considered it done and waiting on chip for a go/no-go.

[05:06] <spinclad> right

[05:07] <putter> ho, that will be interesting.  pilrun regex is too dumb to know it doesnt do p6 regexes, so its about to try with p5...

[05:08] <spinclad> continuous testing:  just as long as the runs converge, vs divergence by overlap

[05:09] <spinclad> good luck to it

[05:09] <putter> it would also be nice to be able to do per-test, an individual ok(), tracking.  so one can ask "what rev did this stop working".

[05:11] <spinclad> dump them in your database!  datamining for the software practicioner!

[05:13] <putter> :)

[05:17] <putter> hmm...  you know, with PIL and a declarative constraint system, I bet it wouldn't be too difficult to do whole-program analysis of p6.  Nothing which could fiddle with the Num classes, mash it down to machine types.  etc

[05:19] <putter> might have to try that...

[05:19] <spinclad> sure.  might begin to resemble some larger haskell compiles...

[05:19] <putter> :)

[05:20] <putter> I was think more, when you want to do a release, you compile it down.

[05:22] <putter> pilrun is currently structured so it could do  -c foo.p6 -o foo.p5

[05:23] <spinclad> anyway, getting tired.  i feel i'm just a kibitzer so far.  i want to dig in someplace specific.  maybe an unlambda target? *<8o)  or i'll look for something that will help with the metamodel work.

[05:24] <putter> digging in good

[05:24] * putter admits it's pretty silly to stay up too late waiting on a smoke...

[05:25] * spinclad tools up with spade and shovel and a promise for tomorrow

[05:25] <putter> :)

[05:25] <putter> I'm off.

[05:25] <putter> good night &

[05:26] <spinclad> me too.  night putter &

[08:55] <new-b> hiho

[10:49] <xerox> Today is http://softwarefreedomday.org/ !

[11:01] <castaway> hey.. is there a doc on Kwid somewheres?

[11:10] <dudley> castaway: http://pugs.kwiki.org/?KwidSynopsis

[11:11] <dudley> there used to be a perlkwid.kwid that was the spec in the Pugs tree, but it seems to have disappeared...

[11:18] <castaway> hmm, odd that.. thanks

[12:01] <dudley> stevan_: ping

[12:51] <svnbot> r6918 | iblech++ | * Usual svn props.

[12:51] <svnbot> r6918 | iblech++ | * Changed "scalar(...)" to "item(...)" and "scalar context" to "item context"

[12:51] <svnbot> r6918 | iblech++ |   and "Scalar" to "Item" where applicable in examples/, t/, ext/, docs/, src/,

[12:51] <svnbot> r6918 | iblech++ |   and perl5/, based on

[12:51] <svnbot> r6918 | iblech++ |   http://www.nntp.perl.org/group/perl.perl6.language/23078.

[12:51] <svnbot> r6918 | iblech++ | * t/builtins/hashes/slice.t: Added link to relevant p6l post and =for

[12:51] <svnbot> r6918 | iblech++ |   unspecced'ed another test.

[12:52] <gaal> hey folks, are you getting the prelude compiled in on your regular builds now?

[12:54] * dudley hasn't built pugs in a long, long time

[13:05] <gaal> hmm. issuing the build_pugs.pl command manually seems to work, but from a bare 'make' it doesn't.  weird.

[13:05] <gaal> (now just to hope ghc doesn't blow up again)-:

[13:05] <dudley> it looks like the default 'make' is giving me the precompiled prelude here

[13:12] <gaal> thanks for the input. i've managed to build a pugs and am running a smoke test now; after it finishes i'll pull a fresh tree and try again. maybe having many aborted builds confuses build_pugs.

[13:16] <dudley> Yeah, this is on a clean tree

[13:34] <stevan_> dudley: pong

[13:37] <gaal> brentdax, ping

[13:43] <dudley> stevan_: I think the java/scala stuff really only works calling java code from scala

[13:43] <dudley> not the other way around

[13:44] <dudley> It seems that scala classes appear to java as abstract

[13:44] <svnbot> r6919 | putter++ | PIL-Run - hopefully reduce testing fragility

[13:56] <svnbot> r6920 | gaal++ | Log::Selective: skip looping tests

[14:46] <putter> hi all

[14:46] <putter> fglock: ping?

[14:52] <rafl_> All requirements for pugs to go into Debian are satisfied now (exept those modules needed for smoking, but that doesn't hurt). What do you think which version should go in? 6.2.9 or a current svn snapshot?

[14:55] <putter> a release version.  6.2.9 if that's the most recent.  things are a bit crufty.  pugs itself is down to 96%.

[14:56] <rafl_> OK, /me is working on 6.2.9 then.

[14:57] <putter> there is a big cleanup and testing push before each release, which gets all the tests passing, etc.

[14:59] <rafl_> The last time I saw that it looked to me that this is mostly done by TODOifying failing tests.

[15:00] <stevan_> dudley: re: scala, well maybe it is not ready yet

[15:00] <stevan_> hey putter :_

[15:01] <putter> there's definitely some of that.  more when autrijus is pressed for time, or a "bugfixing session" dynamic doesnt happen.

[15:01] <putter> hi stevan

[15:05] <dudley> stevan_: Or maybe some sucker will fill in the missing parts of SUnit...

[15:05] <stevan_> dudley: always a possibility :)

[15:05] <dudley> :)

[15:11] <putter> fglock: it looks like r6896 broke  @a=(3,4)

[15:23] <putter> and p6_to_a is broken - Array ->unboxed is now returning a...

[15:23] <putter> p5ugs> :5 $y = Array->new('$.unboxed' => [34])

[15:23] <putter> Array=HASH(0x10722a0)

[15:23] <putter> p5ugs> :5 $y->unboxed

[15:23] <putter> Perl6::Container::Array=HASH(0x14aeab0)

[15:28] <putter> Hmm... looks like Array ->unboxed may never have been working.

[16:29] * putter wonders why make test is saying "hate software so much".  not that he disagrees at the moment, but one doesn't often see the sentiment expressed by one's software.

[16:40] <svnbot> r6921 | putter++ | PIL-Run - \@INC now exists, but doesn't work (problem in Array?).  The real Test.pm now compiles, and works on tests individually, but not under make test.

[16:49] <rafl_> pugs is in the Debian NEW queue (http://ftp-master.debian.org/new.html) again. This time it should also be accepted.

[16:49] <putter> rafl_++ :)

[16:50] <rafl_> btw, the only difference from the packaging in SVN is that it doesn't send the smoke results to smokeserv (libtest-tap-*-perl aren't in, yet).

[16:51] <putter> Does that mean debian folk will simply be able to aptget pugs, without struggling with a ghc install?!?

[16:51] <rafl_> putter: Of course. But is apt-get install ghc6 really that hard? :-)

[16:52] <putter> :)

[16:53] * putter thinks of all the work it was to get a version of ghc which worked on x86_64... the contrast of "apt-get pugs" is a bit boggling.

[16:54] <putter> "civilization advances by increasing the number of things you don't have to worry about"

[16:55] <rafl_> putter: Why doesn't ghc6 6.4-4.1 work for you?

[16:55] <rafl_> putter: I can't find a bug for this in the bts. Maybe you should report one.

[16:57] <putter> Is 6.4.1 finally out?  For a while I had to follow cvs head, playing the "does it even compile today?  if yes, does it seem more or less broken than the snapshot I'm currently using" game.

[16:57] <putter> Eventually I wasnt noticing problems, so I stopped playing.

[16:58] <rafl_> No, 6.4-4.1 is NMU (non maintainer upload) 1 for Debian version 4 of ghc6 6.4.

[16:58] <rafl_> That's the first version that uses the new C++ API.

[16:59] <putter> ah.  yes, 6.4 has difficulties on x86_64.  6.4.1 is ironing them out.

[17:00] <rafl_> Well, making other Debian users as well as the maintainer aware of that would be a good thing, though.

[17:01] <putter> (I note that's ghc's official 6.4 release.  not using debian, can't comment on 6.4-4.1.)

[17:02] <putter> Everything I've found is in the bug tracker, or communicated directly to the pursuing developer.  What happens from there...

[17:05] <spinclad> excellent!  rafl_++++

[17:06] <spinclad> (pugs, not ghc6, of course)

[17:06] <putter> :)

[17:06] *** rafl_ is now known as rafl

[17:06] <spinclad> wait, does karma carry over?

[17:07] <spinclad> karma rafl_

[17:07] <spinclad> whobot knows karma?

[17:07] <rafl> Doesn't matter. There seems to be no karma at all ATM. :-)

[17:07] <rafl> perlbot, AFAIK.

[17:07] <perlbot> As Far As I Know

[17:08] <spinclad> perlbot, why won't you talk to Me?

[17:10] <rafl> But I think shouldn't be carried over when changing nicks. . o O ( /nick autrijus; /nick iblech; /nick putter; /nick fglock; /nick gaal; ... $karma = Inf)

[17:11] <spinclad> either that or not merge.

[17:12] <spinclad> but then .oO ( /nick autrijus; $karma = 0 ) so better no carryover

[17:12] <putter> stevan

[17:13] <rafl> ACK.

[17:13] <putter> luqui

[17:13] * putter gives up on that game

[17:15] <DiGiT79_> hi

[17:16] <spinclad> hi. which DiGiT is 79?

[17:16] <DiGiT79_> i have a problem wirh the NET::SSH::PERL module .... for days now! maybe someone in here is familiar with that module ?!

[17:16] <DiGiT79_> :p

[17:16] <rafl> Grr. 7 Minutes after I uploaded pugs without smoking support libtest-tap-model-perl was accepted. :-/

[17:17] <spinclad> :(

[17:17] <rafl> DiGiT79_: This channel is about Perl6 and pugs development. Maybe you want to join #perl.

[17:18] <DiGiT79_> rafl, sorry for that! thnx :)

[17:19] <rafl> spinclad: That's not that bad actually. Only the smoke results of the Debian buildds wont be sent to smokeserv.

[17:20] <rafl> Yay, pizza for me :-)

[17:20] <spinclad> i'd guess 6.2.10-1 should have it anyway

[17:20] <rafl> spinclad: Yes, it will.

[17:24] <rafl> libtest-tap-htmlmatrix-perl_0.04-1_i386.changes is also accepted now.

[17:32] * rafl prepares a new upload.

[17:34] <putter> err, note that make smoke currently non-terminates.

[17:34] <putter> fyi

[17:35] <putter> the MIME-Base64 is apparently unresolved.  at least on my machine.

[17:35] <putter> s/is/issue is/

[17:35] <rafl> For 6.2.9 it works fine for me.

[17:36] <putter> we may have disabled that test for the release?  regardless, yes, the actual release should be fine.

[17:53] * putter plays with svn log...

[17:53] <putter> some obvious things.  "May was fun"

[17:58] <putter> some less so - even though autrijus is less than half the commits, starting surprisingly early in the project, the shape of total and autrijus commits is quite similar, until the summer tapering off, where total commits leveled off even though autrijus went away (commit count wise).

[17:59] <integral> that sounds like the point when the other backends (JS, P5) started to appear; they seem to have lots of developers compared to the haskell

[17:59] <putter> which, in retrospect, is consistent with my impression that autrijus is a key pacing factor.

[18:00] <putter> hmm... looking...

[18:06] <putter> basically, with 15 active commiters and 200 commits per week as a baseline, the "golden time";) was most of May, with twice that.  there is a spike in commiters and commits around the time the backends showed up a month later (to ~30 something and ~300), but it was only a week or two.

[18:07] * putter tries to think of an easy way to post the curves...

[18:19] <svnbot> r6922 | stevan++ | Perl6::MetaModel 2.0 - 

[18:19] <svnbot> r6922 | stevan++ | * first steps towards supporting unbound methods, which are needed for Roles

[18:19] <svnbot> r6922 | stevan++ |   - commiting this before I make too much of a mess :)

[18:20] <putter> :)

[18:40] <roo> I think I know why I've been having all those GHC errors.

[18:41] <roo> My computer crashed and won't start now. Looks like the CPU or RAM died :-(

[18:41] *** roo is now known as gaal

[18:42] <gaal> Oh well, at least this is an opportunity to pick up irssi.

[18:42] <putter> :(

[18:43] <gaal> Remarkably, the computer is still under warranty! I thought they timed those things to happen a month after it expires!

[18:43] <svnbot> r6923 | stevan++ | Perl6::MetaModel 2.0 - 

[18:43] <svnbot> r6923 | stevan++ | * methods are not bound to the class until they are 

[18:43] <svnbot> r6923 | stevan++ |   added to that class

[18:43] <svnbot> r6923 | stevan++ |     - fixed some tests to account for this, still some cleanup to do

[18:50] <putter> :)

[18:52] <putter> good luck gaal

[18:52] <putter> later &

[18:52] <gaal> thanks - bye!

[18:53] <gaal> seen autrijus

[19:01] <svnbot> r6924 | stevan++ | Perl6::MetaModel 2.0 -

[19:01] <svnbot> r6924 | stevan++ | * cleaned all code and sub prototypes so now unbound methods are the

[19:01] <svnbot> r6924 | stevan++ |   "way things are done", all tests pass, and we are now ready to add

[19:01] <svnbot> r6924 | stevan++ |   Roles into the metamodel

[19:18] <spinclad> ooo Roles :)

[19:26] <luqui> lwall to sixperl: Good tree matching syntax ... [is] really better done with an extension to signatures

[19:26] <luqui> hooray!

[19:27] <luqui> he proposes:  sub foo (Plus $plus (Lit ($left), Lit ($right))) {...}

[19:28] <wolverian> luqui, sixperl?

[19:28] <luqui> The um... lack of a secret cabal communication channel

[19:29] <wolverian> just as long as it's not perlsex..

[19:29] <luqui> :-)

[19:30] <Aankhen``> Ohh, ^W is the new ^H?

[19:30] <luqui> ?

[19:31] <Aankhen``> goa^W^W^Wsomething as opposed to goa^H^H^Hsomething.

[19:31] <svnbot> r6925 | iblech++ | * Added Makefile, blib, etc. to ext/Log-Selective's svn:ignore.

[19:31] <svnbot> r6925 | iblech++ | * PIL2JS: lazy {...}!

[19:31] <svnbot> r6925 | iblech++ |   * Prelude::JS::Code: Added &lazy. Note that in PIL2JS, all lazy "values" are

[19:31] <svnbot> r6925 | iblech++ |     actually autodereffing references. Can't say whether this is against the

[19:31] <svnbot> r6925 | iblech++ |     spec as no spec exists ;)

[19:31] <svnbot> r6925 | iblech++ |   * libjs/PIL2JS.js: Fixed autodereffing handling in some places --

[19:31] <svnbot> r6925 | iblech++ |     &ref autodereffed more than one time and &prefix:<~> and &prefix:<+>

[19:31] <svnbot> r6925 | iblech++ |     did not autoderef in some cases.

[19:31] <svnbot> r6925 | iblech++ | * t/var/lazy.t: Added some more tests. PIL2JS passes 15/15 :)

[19:31] <luqui> ^W generally means "kill a word"

[19:31] <Aankhen``> Ah, I see.

[19:31] <luqui> whereas ^H means "kill a letter"

[19:31] <Aankhen``> Thanks for the explanation. :-)

[19:33] <luqui> ?eval my $x = lazy { "hi" };  say "hi"

[19:33] <evalbot_6925> hi bool::true 

[19:33] <luqui> ?eval my $x = lazy { "hi" };  say $x

[19:33] <evalbot_6925> hi bool::true 

[19:33] <luqui> ?eval my $x = lazy { say "evaluating!"; "hi" };  say "boo!"; say $x

[19:33] <evalbot_6925> boo! evaluating! evaluating! evaluating! hi bool::true 

[19:33] <luqui> uh..

[19:33] <luqui> three times?

[19:33] <Aankhen``> ?eval my $x = lazy { say "evaluating!"; "hi" };  say "boo!";

[19:33] <evalbot_6925> boo! bool::true 

[19:33] <Aankhen``> ?eval my $x = lazy { say "evaluating!"; "hi" };  say $x;

[19:33] <evalbot_6925> evaluating! evaluating! evaluating! hi bool::true 

[19:34] <Aankhen``> ?eval my $i = 0; my $x = lazy { $i++; "hi" }; say $i; say $x; say $i;

[19:34] <evalbot_6925> 0 hi 3 bool::true 

[19:35] <Aankhen``> Freaky.

[19:35] <luqui> well, you're not supposed to put side-effects inside lazy { }

[19:35] <luqui> but still...

[19:35] <Aankhen``> Indeed.

[19:35] <wolverian> luqui, hm, what does that tree matching syntax mean exactly? 

[19:36] <luqui> It's a Plus node with two Lit subnodes

[19:36] <luqui> and you put the Plus node as a whole into $plus, and the contents of the Lit nodes in $left and $right

[19:36] <Aankhen``> ?eval $?PUGS_VERSION

[19:36] <evalbot_6925> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6925)' 

[19:36] <wolverian> ohh.

[19:37] <wolverian> luqui, are the parens in 'Lit ($left)' necessary?

[19:37] <luqui> yeah, otherwise $left gets the Lit node, as opposed to its contents

[19:38] * luqui still isn't sure how you specify something like "Plus"

[19:38] <luqui> but we know how to match it at least :-/

[19:50] <wolverian> luqui, well, get to work on the specification side then!

[19:50] * wolverian cracks the whip

[19:50] * luqui ows

[19:54] <svnbot> r6926 | iblech++ | * t/var/autoderef.t: Refs to subrefs should not autoderef.

[19:54] <svnbot> r6926 | iblech++ | * pugs::run: Added short paragraph about the features of our backends.

[19:54] <svnbot> r6926 | iblech++ | * PIL2JS: README: Added section about the implementation of laziness.

[20:01] <spinclad> ?eval my $x = lazy { say "howdy!"; "hi" }; say $x

[20:01] <evalbot_6926> howdy! howdy! howdy! hi bool::true 

[20:01] <spinclad> it's certainly enthusiastic.

[20:02] <spinclad> ?eval my $x = lazy { say "howdy!"; "hi" }; $x

[20:02] <evalbot_6926> howdy! \\'hi' 

[20:02] <spinclad> interesting difference

[20:03] <spinclad> ?eval my $x = lazy { say "howdy!"; "hi" }; say $x; say $x

[20:03] <evalbot_6926> howdy! howdy! howdy! hi howdy! howdy! howdy! hi bool::true 

[20:04] <spinclad> so it's not converting to cache on autoderef...

[20:09] <spinclad> this way is simple and computationally equivalent to anything better (and lazier!)

[20:09] <spinclad> s/anything better \(and lazier!\)/(and lazier than!) anything smarter

[20:09] * Aankhen`` goes to sleep.

[20:10] <Aankhen``> G'night.

[20:11] <spinclad> g'night aankhen``

[20:13] <spinclad> .oO ( so what three times does say $x evaluate $x? )

[20:13] <spinclad> ?eval my $x = lazy { say "howdy!"; "hi" }; $x.perl

[20:13] <evalbot_6926> howdy! howdy! howdy! '\\\\\'hi\'' 

[20:16] <spinclad> sorry, this way is lazy _about_ caching, but caching should be lazier computationally.  (eval at most once)

[20:26] <spinclad> s/should/would/

[20:27] <spinclad> i think that's as close as i'll get to saying this right today.

[20:39] <svnbot> r6927 | iblech++ | * t/syntax/symbol_table.t: =begin obsolete'd the whole test because things

[20:39] <svnbot> r6927 | iblech++ |   were changed recently (see thread "Packages, Modules and Classes" on p6l

[20:39] <svnbot> r6927 | iblech++ |   started by Stevan: http://www.nntp.perl.org/group/perl.perl6.language/23019).

[20:39] <svnbot> r6927 | iblech++ | * t/unspecced/eval_yaml.t: skip under PIL2JS.

[20:39] <svnbot> r6927 | iblech++ | * t/operators/reduce-metaop.t: Some more tests and minor reorganization.

[20:39] <svnbot> r6927 | iblech++ | * PIL2JS: Prelude::JS::Operators: Basic [...] reduce metaoperator! But:

[20:39] <svnbot> r6927 | iblech++ |   * No autogenerated metaops for user-defined operators yet.

[20:39] <svnbot> r6927 | iblech++ |   * No attention paid to the associativity of the operators yet.

[20:39] <svnbot> r6927 | iblech++ | * PIL2JS: libjs/PIL2JS.js: $*PUGS_HAS_JSPLUGINS := 0;

[20:48] *** theorbtw1 is now known as theorbtwo

[21:04] <cybercobra> could anyone recommend a book on perl6 for the non-perl programer?

[21:05] <luqui> learning perl?

[21:05] <luqui> er

[21:05] <luqui> perl6

[21:05] <luqui> uh

[21:05] <luqui> no... not really

[21:06] <luqui> I expect the camel 4 when it comes out will probably not be a diff but more of a complete spec

[21:06] <luqui> or a complete learning spec at least

[21:06] <cybercobra> well so far I've found http://www.oreilly.com/catalog/perl6es/ and http://search.barnesandnoble.com/bookSearch/isbnInquiry.asp?r=1&isbn=1590593952

[21:08] <luqui> yeah, those both look like they require a perl 5 knowledge

[21:08] <luqui> what other languages are you familiar with?

[21:09] <cybercobra> C, python, Java

[21:09] <cybercobra> just read a book on C#

[21:09] <luqui> learning perl shouldn't be that hard for you then

[21:09] <luqui> but learning perl 6 is always a challenge

[21:10] <luqui> since it's always changing, and the docs are about specific sublanguages and idioms rather than the language as a whole

[21:10] <luqui> so the best way to do it, I think, is to familarize yourself with some amount of perl 5 and then play with pugs

[21:10] <luqui> spending time on this channel will also help

[21:10] <luqui> since a lot of us have perl 6 in our head

[21:10] <luqui> s

[21:13] <cybercobra> all right then, I think I'll go with 'Perl 6 Now' then. thanks

[21:14] <luqui> yeah, I was a major help, wasn't I :-/

[21:15] <cybercobra> you tried and were honest. that's all I can ask for until perl6 is finalized

[21:29] <spinclad> cybercobra: not a book, but i wouldn't forget our design docs: Apocalypses, Exegeses, and Synopses (AES)

[21:30] <cybercobra> spinclad: yeah, I looked over the regex an operator apocalypses a few weeks ago

[21:30] <cybercobra> *and

[21:31] <fglock_> putter: pong

[21:31] <spinclad> not complete (even for what's been specified to date -- for that you'd best follow the perl6.language mailing list

[21:33] <spinclad> but not bad introductions to go along with whatever books

[21:34] <spinclad> they do presume perl5 though, in describe the differences therefrom.

[21:35] <spinclad> /describing/

[22:19] <svnbot> r6928 | fglock++ | * perl5/Match.pm - fixed tabs

[22:30] <autrijus> greetings

[22:33] <fglock_> hi

[22:33] <autrijus> hi. there'll be no journal today I'm afraid -- I just low-level formatted autrijus.org's -- including all raid disks -- by accident

[22:33] <autrijus> coupled with the recent laptop hd crash, that means, well, all the data I'm going to have will be public data.

[22:34] <fglock_> I just had a blackout here - but no problems with the computer :)

[22:35] <autrijus> congrats :)

[22:35] <fglock_> open source is a great backup medium

[22:37] <autrijus> it is, although I'm going to miss my mail archive and private works.

[22:37] <svnbot> r6929 | iblech++ | * EOL at EOF.

[22:37] <svnbot> r6929 | iblech++ | * t/data_types/lazy_lists.t: skip_rest instead of die when not running under PIL-Run.

[22:37] <svnbot> r6929 | iblech++ | * t/junction/misc_junctions.t: Fixed test and...

[22:37] <svnbot> r6929 | iblech++ | * New t/syntax/parsing_postfix_if_and_is.t: ...added new test testing that the

[22:37] <svnbot> r6929 | iblech++ |   syntax error misc_junctions.t contained actually causes Pugs to parsefail ("3

[22:37] <svnbot> r6929 | iblech++ |   if 4\nis 50" (note: no ";" before the "\n") does *not* parsefail currently!).

[22:38] <fglock_> ouch - no cdroms?

[22:39] <autrijus> ope.

[22:39] <autrijus> I have laptop and server back up each other, each one with redundant disks

[22:39] <autrijus> but somehow this week I nuked every single one of them

[22:41] <dudley> It's a great week for hardware failures.

[22:42] <autrijus> verily.

[22:42] <dudley> I lost my hard drive on my laptop and gaal blew up a cpu or something like that

[22:42] <fglock_> autrijus: are lazy array slices actually specified? they are pretty difficult to implement right

[22:42] <autrijus> fglock_: no, they are not specified in detail

[22:42] <autrijus> but I'm sure @Larry on p6l will be happy to work out the rough ends when brought up

[22:44] <fglock_> things like: (@a[1..100],@b[1..50])=(@a[1..50],@b[1..100]) - weird intersections of lazy lists

[22:44] <luqui> woah

[22:45] <luqui> you want that to happen without evaluating @a[25], I imagine

[22:46] <fglock_> yes

[22:46] <luqui> are you using the generator approach?

[22:46] <fglock_> you can put a lot of extra zeroes there :)

[22:47] <fglock_> I'm using List.pm - it supports a set of "queries" on the list

[22:48] <fglock_> List->new() takes a bunch of closures, which are the actual "generator"

[22:48] <luqui> it seems like to do your example, lazy lists need to be able to split themselves

[22:49] <luqui> it would probably be helpful to specify the ListGenerator role

[22:49] <luqui> i.e. all the things an object needs to do in order to be part of a lazy list

[22:51] <fglock_> no problem, I think. Right now it is using a class, but it can be a Role

[22:51] <luqui> yeah, it feels more interfacey than derivey to me

[22:52] <luqui> among the things I can think of

[22:52] <luqui> $gen.index($idx)    # get $idx elements from the beginning, generating as much as necessary

[22:53] <luqui> ($left, $right) = $gen.split($idx)     # get two generators, one for 0..^$idx, and one for $idx...

[22:54] <luqui> maybe this is a p6l issue, so we can really determine the best minimal interface

[22:54] <fglock_> yep. I call this shift_n($n), and there is a pop_n($n) too

[22:54] <luqui> okay

[22:54] <luqui> or maybe a p6c issue :-)

[22:54] <fglock_> Array.splice is defined in terms of shift_n and pop_n calls

[22:54] <luqui> are generators values or references?

[22:55] <fglock_> where $n can be Inf

[22:55] <fglock_> generator is an instance of List

[22:55] <luqui> so it's a reference.

[22:55] <luqui> that is, you can change it

[22:56] <fglock_> yes, you can "take" from it

[22:56] <luqui> okay

[22:56] * luqui wonders what the interface would look like as a value type

[22:56] <luqui> it may end up making things a lot easier, or it may end up making things a lot harder

[22:57] <luqui> but my experience with laziness says that things get easier when you make them constant

[22:57] <luqui> not that I have all that much experience

[22:57] <fglock_> PIL-Run arrays are using this

[22:58] <luqui> uh huh...

[22:58] <luqui> and?

[22:58] <luqui> well, let me think about it

[22:58] <luqui> at the moment, my hunch is that generators should not be lists

[22:58] <luqui> but lists should be aggregated generators

[22:58] <luqui> and generators should just be a nice interface for extracting and splitting lazy sequences

[22:59] <fglock_> Array is a cached list aggregate, more or less

[22:59] <luqui> nice for the implementor of List, that is

[22:59] * luqui will look over List.pm

[23:00] <luqui> it's really hard pretending you know the right design when you haven't even seen how the current one works yet :-p

[23:01] <fglock_> the remaining problem is how you clone a list - because you need to clone the closures

[23:02] <luqui> "clone the closures"

[23:02] <luqui> the closures are not pure?

[23:02] <fglock_> pure?

[23:02] <luqui> you allow the generating closures to mutate stuff?

[23:05] <fglock_> like: @a=@b; say @a.shift; say @b.shift; - if there is a generator involved, you need to be able to get to the same element twice

[23:05] <luqui> of course

[23:05] <luqui> hmm...

[23:06] <fglock_> I've written a module that solves the problem, but it was not elegant - involved buffering, too much extra work

[23:07] * luqui is just thinking about @b = =<> earlier on

[23:07] <fglock_> cloning the generator could fix that, if it was possible. 

[23:07] <fglock_> yup - working with files would involve buffering

[23:07] <luqui> it's like the generator needs to know what it's already generated

[23:08] <luqui> so a pure head/tail scheme won't work here

[23:08] <luqui> I think

[23:08] <luqui> well, gtg

[23:08] <luqui> &

[23:17] <fglock_> electricity is gone again - it's nice that the computer has batteries :)

[23:26] * fglock_ learns to write without seeing the keyboard

[23:44] <vkon> after I looked into :ignorecase in t/rules/tules.t, it appears that parrot has incomplete abilities on case-insensitive comparision operators, as described in appropriate files.

[23:46] <vkon> moreover, matching a character to a character class is done "index char,string"; I think it will be better to have it searched within a hash...

[23:48] <vkon> those two mentioned items, and yet a way to call parrot from within pugs, make it clear why rules are that slow, and why :ignorecase isn't done yet...

[23:50] <vkon> all in all, implementing rules (temporarily) in Haskell could be much more effective... or even with matching using PCRE?

[23:51] <svnbot> r6930 | fglock++ | * PIL-Run - @INC is tied to P5 @INC

[23:51] <luqui> vkon, pcre?

[23:52] <luqui> you can't do that with perl 6 rules

[23:52] <luqui> I think pcre is in fact called when you do :p5

[23:55] <vkon> luqui: yes, indeed... but parrot's engine is so incomplete (and it is documented as temporary and incomplete) so if matching itself will be done elsewhere, it could be easier. But I probably misunderstand the point.

[23:55] <luqui> well, the idea is to eventually run everything on parrot

[23:56] <luqui> in which case it won't be inconvenient

[23:56] <luqui> however, I have planned to port PGE to perl 6 one of these days

[23:56] <luqui> so at least we'll have a working if not fast rules engine everywhere we run

[23:58] <vkon> luqui: I respect parrot embedding, and compiling to PIR is good... but why parrot still lacks :ignorecase?

