[00:07] <putter> is there a favored nopaste for #perl6 haskell code?  i've a three line untodo which I'd like stylistic feedback on...

[00:08] <stevan> perlbot nopaste

[00:08] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[00:10] <pasteling> "putter" at 66.30.119.55 pasted "new code for Prim.hs" (4 lines, 180B) at http://sial.org/pbot/8942

[00:10] *** stevan changes topic to: pugscode.org <<Overview Journal Logs>> | You have safely opened the door to many Perl 6 hackers. | pugs.kwiki.org | smoke: http://xrl.us/fmw2 | Mac OS X r1537 (212/3783) | Win2k r1534 (210/3779)

[00:11] <putter> Caveats: it handles ["a"].join("x") but not ("a").join("x"), so its not a complete join.t untodo.  my attempts at () were excessively slurpy.

[00:13] <putter> feedback of any flavor welcome.

[00:16] <putter> any flavor at all...

[00:18] <Schwern> Pork ripple

[00:19] <Schwern> Holy crap, that's all the code?

[00:19] <Schwern> <--- non Haskell programmer

[01:07] <putter> is there any interest in having tests consolidated.  eg, there are eq tests in operators/cond.t and in operators/eq.t.  with the former also doing halfhearted string<->number conversion.  any thoughts?

[01:08] <putter> er, thats test _files_ consolidated.

[01:19] <Khisanth> S10 is rather brief! O_o

[01:25] <metaperl> wow Juerd actually agreed with me for once!

[01:31] <Khisanth> must be a ruse

[01:32] <stevan> metaperl: is it a Full Moon tonight in Holland?

[01:32] * metaperl crosses himself with garlic

[01:33] <metaperl> it must be a full moon for Juerd to agree with me

[01:33] * stevan loads his gun with silver bullets

[02:06] <putter> would it be plausible to drop the implementation of additional operators in Prim.hs?  they probably need a better home, but I dont immediately see one...

[02:06] <putter> err, additional _filetest_ operators.

[02:09] <shapr> will vCast work for every type?

[02:09] <shapr> Is the precision of log part of the specification?

[02:11] <shapr> I have this from log.t, should I just change the expected and check it in? #   Expected: 1.6094379124341  \n #        Got: 1.6094379124341003

[02:13] <shapr> I search, for a clue.

[02:13] * putter thinks things are quiet... tooo quiet...

[02:13] <shapr> putter: is your nickname from perl golf?

[02:17] <putter> ah, that's the question.  just _which_ pun is being made. ;)

[02:18] <shapr> All of them?

[02:18] <putter> not telling.

[02:18] <shapr> I like mystery.

[02:18] <shapr> Anyway, do you know if the precision of log is specified?

[02:19] <putter> hmm, exploring...

[02:24] <shapr> It's getting light outside, I should go to sleep.

[02:25] <shapr> btw, what's the more polite approach? should I knock over more builtins or leave them for camelfolk who are learning Haskell?

[02:28] <putter> ah, I'm losing.  why not commit.  possible outcomes are need to back out, or that it demonstrates need to truncate as comment in file hypothesizes.

[02:29] <shapr> works for me.

[02:30] <putter> re knocking off builtins... given the range of tasks available, perhaps addressing things that novices can't will have a higher collective payoff.

[02:31] <shapr> Yeah, true.

[02:34] <putter> oh, and perhaps leave a comment in log.t about the change, just in case thought did go into the precision.

[02:36] <shapr> How do you create complex numbers in perl?

[02:37] <Alias_> I'm sure there's a module

[02:37] <putter> Math::Complex?  in p6, checking...

[02:37] <Alias_> Math::Complex perhaps?

[02:37] <shapr> I just want to know for the unit test. log should work on complex numbers just the same, I think.

[02:40] <putter> s09: my complex $n;

[02:41] <putter> oh, but that doesnt help you with a constructor... checking...

[02:45] <shapr> I'll just check in what I have and go to sleep.

[02:45] <putter> i dont see it in the assorted docs.  Math::Complex does 4 - 3*i.  perhaps do that, and add a question to... wherever we are accumulating questions for p6l.

[02:45] <putter> sleep is good.

[02:47] <shapr> I think someone new to Haskell should be able to implement exp.t and sign.t without too much trouble.

[02:48] * shapr falls over asleep

[02:48] <putter> sounds good.  i think i'll leave some of the filetest operators, after correcting the return type of the current ones.

[02:49] <putter> good night shapr

[03:21] <putter> does anyone know what the pugs "bootstrap philosophy" is?  just enough coverage of p6 to bootstrap a rules engine? full coverage? something in between?  if full, how is "i'm an object pretending to be a string" handled?  (probably not the right time of day to ask...)

[03:24] <Alias_> Isn't the Rules engine Haskell?

[03:24] <Alias_> 1) Load Haskell 2) Parse Perl

[03:24] <Alias_> :)

[03:28] <putter> my understanding is p6 will eventually be parsed by p6 rules.

[03:28] * putter putters off for the night.

[03:28] <Alias_> sure. But not pugs

[03:28] <Alias_> AFAIK

[03:28] <putter> Alias_: tnx

[03:29] <Alias_> Pugs is P6 in Haskell... P6 is P6 in P6

[03:29] <Alias_> There will be a limited bootstrapping parser of some sort though

[03:31] <autrijus> pugs will eventually be translated from haskell to p6.

[03:31] <autrijus> that's our strategy. see roadmap

[03:31] <Alias_> So Haskell will be the bootstrapping parser, with P6 as the real parser?

[03:32] <autrijus> yes.

[03:33] <autrijus> putter: the philosophy is that we do full coverage until the day that p6 macros is supported.

[03:33] <autrijus> because without them there's little chance to translate pugs to p6

[03:35] <putter> the "bootstrap philosophy" question came to mind as i went to fix a filetest operator, and it struck me that strings are being used in situations where an object-vs-its-stringification distinction may need to be drawn.  so i was wondering how much dynamic pain pugs is signing up for...

[03:35] <autrijus> oh. those will be rewritten using our OO core.

[03:35] <autrijus> the OO core needs to be attached soon.

[03:36] <autrijus> once we fix the remaining significant bugs and deem the next release (I think) 6.2.0.

[03:36] <autrijus> again, please see the roadmap.

[03:37] <sdtr443w> I've been seeing a lot of examples have something like *@xs in a subroutine prototype.  Is that a reference to an array?

[03:39] * putter for the record, quoteth "6.2: Basic IO and control flow elements; mutable variables; assignment."

[03:39] <autrijus> right. that means we /completed/ them.

[03:39] <autrijus> then we start hacking in OO

[03:39] <autrijus> once OO support is considered complete, we call that 6.28.0.

[03:40] <autrijus> sdtr443w: http://search.cpan.org/dist/Perl6-Bible/lib/Perl6/Bible/A06.pod#The_slurpy_array

[03:40] <Alias_> This versioning thing is gunna bite you in the ass everntually :)

[03:40] <sdtr443w> I guess referencing and dereferencing has changed

[03:40] <autrijus> Alias_: nope. there is a finite number of milestones :)

[03:40] <autrijus> Alias_: after the last one, we'll be called "Perl 6.0.0."

[03:41] <sdtr443w> Oh wait I guess I picked up somebody else's dialog first and got confused

[03:41] <Alias_> autrijus: For all you know pugs could end up becoming the Haskell -> Parrot doohicky permanently

[03:41] <sdtr443w> I see it in a scalar context too: *$x

[03:42] <autrijus> Alias_: I will not let that happen :)

[03:42] <autrijus> of course if I get hit by a bus, oh well.

[03:42] <sdtr443w> I have a short bus.  Where you at?

[03:42] <autrijus> ;)

[03:43] <ninereasons> autrijus, I wrote a test that assumes that 'my (@a) = 1 .. 3' is the same as in perl5.  was I correct?  

[03:44] <autrijus> sdtr443w: http://search.cpan.org/dist/Perl6-Bible/lib/Perl6/Bible/S06.pod#List_parameters

[03:44] *** knome is now known as rblackwe

[03:44] <autrijus> ninereasons: correct.

[03:44] <autrijus> lunch. bbiab! & :)

[03:44] <sdtr443w> autrijus: I scrolled to the top of the first link you sent me and I'm just reading it sequentially

[03:45] * putter still puzzled, but too tired to think.

[03:46] <ingy> autrijus: ping

[03:52] <sdtr443w> Hrm I see things in the grammar about explicitly declaring the return value of a sub, but is there a way to explicitly declare the parameters?

[03:54] <sdtr443w> Oh finally... somewhere past a third down it gets into it

[04:00] <sdtr443w> Is there a problem with this subroutine declaration in pugs: sub void_run_strarray(str @test_array is r) { }

[04:00] <sdtr443w> I put a print in there and get nothing; it's giving me the silent treatment

[04:01] <ninereasons> I don't think that "is" works yet, sdtr443w

[04:02] <ninereasons> and I think that 'str' will work if written as 'Str';

[04:37] <sdtr443w> Yeah it works with caps

[04:37] <sdtr443w> I mean, capitalized 'S'

[04:38] <sdtr443w> That's odd -- doesn't that mean I'm casting it as an object?  I thought those don't work yet

[06:37] <gaal> morning all

[06:39] *** castaway_ is now known as castaway

[06:42] <gaal> are builtins meant to really be built in? after all in S29 they have Perl signatures

[06:42] <gaal> so theoretically they can be implemented in a core library?

[06:48] <gaal> is the ordering in the list at the bottom of Prim.hs important?

[06:58] <Juerd> gaal: Perl 6 will eventually be written in Perl 6

[06:59] <Juerd> gaal: Fortunately, Perl 6 is fast and thus so will Perl 6

[07:08] <gaal> yay! i added sign! :)

[08:46] <ingy> hola

[08:46] <gaal> aloh

[08:47] <ingy> hi gaal

[08:47] <gaal> hello. do you know where we stand in terms of embedding c?

[08:48] <gaal> inlining from perl, that is.

[08:48] <ingy> well we can almost inline haskell

[08:48] <ingy> but there are outstanding dynaloaderish issues

[08:49] <ingy> I assume that once we resolve those issues, inlining C will be rather trivial

[08:49] <gaal> neat!

[08:51] <gaal> in Prim's initSyms, what does ~ mean as a prefix to a type? eg.. \\n   Scalar    left    &&      (Bool, ~Bool)\

[08:51] <gaal> eval lazily?

[08:53] <Khisanth> coerce into a bool?

[08:53] <gaal> so why doesn't the first arg have it too?

[08:54] <gaal> it looks like it's there only in the short-circuits

[09:23] <gaal> any lambdafolk around?

[09:25] <theorbtwo> Looking at Prim.hs line 859, gaal?

[09:25] <gaal> more or less :) i'm doing exp now, which has an optional arg

[09:25] <theorbtwo> I think you're right -- it looks to me like it's building a thunk, but I'm certianly not a lambdaite.

[09:26] <theorbtwo> Just list it as defaulting to... whatever?

[09:26] <theorbtwo> (Presumably e.)

[09:26] <gaal> those aren't very common - so i was peeking at the implementation of rindex, which is simple enough

[09:26] <theorbtwo> (Num, ?Num=2.7...)

[09:26] <gaal> but i don't understand the syntax of 'let' there, which doesn't have an 'in' clause

[09:26] <gaal> no, i don't want to hardcode e

[09:26] <theorbtwo> Or, IIRC, just ?Num, and check if it's undef.

[09:27] <gaal> i want to use the best haskell function --

[09:27] <gaal> either exp or ** (or maybe even ^ and ^^)

[09:29] <gaal> the p5 code i am thinking of is something like return defined $base ? $base ** $exponent : builtin_exp($exponent);

[09:29] <gaal> because haskell provides me with a presumably efficient and exact exp builtin.

[09:29] <gaal> so back to rindex:

[09:30] <gaal> about line 630 - it has this code to do a let based on the results of a vCast

[09:30] <gaal> which looks like what i want, but mimicing the syntax doesn't work

[09:33] <gaal> ah, i think i see what my problem was, i forgot the -> do

[09:41] <autrijus> greetings

[09:41] <gaal> heya!

[09:41] <autrijus> the "in" is omitted in monads

[09:41] <theorbtwo> Allo, autrijus.

[09:41] <gaal> i changed it to an if, makes more sense anyway :)

[09:42] <gaal> but now i get errors saying Couldn't match `Eval Val' against `Exp'. is there an explanation about pugs types somewhere i can stare at?

[09:43] <autrijus> yeah

[09:44] <pasteling> "gaal" at 192.115.25.249 pasted "my naive attempt" (14 lines, 401B) at http://sial.org/pbot/8951

[09:45] <gaal> doesn't work when i vCast, either.

[09:46] <autrijus> a sec

[09:47] <theorbtwo> I think you just need a "do" after that =, but could well be wrong.

[09:48] <gaal> no, it's a,er, the find of function that doesn't do .. return

[09:48] <theorbtwo> pure function.

[09:48] <theorbtwo> But it's getting called impurely.

[09:48] * gaal is in the "programming in the dark" state

[09:49] <rgs> beware of the dark side

[09:49] <gaal> or, more like, programming in the twilight state.

[09:52] <jabbot> pugs - 1544 - build fix for Eclipse

[09:52] <jabbot> pugs - 1543 - sign builtin

[09:52] <jabbot> pugs - 1542 - implemented log and log10.

[09:52] <jabbot> pugs - 1541 - more hangman.p6 work; improved gameplay/

[09:52] <jabbot> pugs - 1540 - some tests for return statement

[09:52] <jabbot> pugs - 1539 - array .join added

[09:52] <jabbot> pugs - 1538 - my(@a)=1..3 with parens should return th

[09:52] <theorbtwo> Hm, I think I know what's going on, but not how to explain it.

[09:52] <jabbot> pugs - 1537 - Correct the test count

[09:52] <jabbot> pugs - 1536 - Add tests for list assignment bug, not d

[09:52] <jabbot> pugs - 1535 - add code to demonstrate arg list flatten

[09:53] <gaal> theorb2, i think my problem is one of types, not purity.

[09:54] <theorbtwo> Except that Eval is a monad.

[09:54] <theorbtwo> It's also a type, of course.

[09:59] <nothingmuch> http://ginger.ucdavis.edu/paloverde/paloverde.html

[10:03] <autrijus> back

[10:03] <autrijus> <- just installed Mac Mini

[10:03] <autrijus> using usb keypad no less

[10:04] <nothingmuch> yay!

[10:04] <nothingmuch> start a smoke server

[10:04] <nothingmuch> i'll check in my "alternative" script

[10:04] <autrijus> that sounds like an idea

[10:04] <autrijus> please do

[10:04] <gaal> haha. reminds me of the time i had to use a keyboard where the middle row didn't work

[10:04] <gaal> it was in DOS

[10:04] <nothingmuch> no wait, i have an OSX one

[10:04] <gaal> so ALT-numkeypad gave out chars by their ascii values

[10:04] <nothingmuch> damnit, i need to get that real smoke server stuff done

[10:05] <gaal> and thankfully, although many numbers were inaccessible -- anything with 4,5, or 6 in it --

[10:05] <gaal> ALT accepted modulos!

[10:05] * castaway wonders if pasta is working again

[10:05] <gaal> so if i needed eg 65, i could try 65+256

[10:06] <nothingmuch> castaway: err, yes

[10:06] <nothingmuch> what port do you want SEE on?

[10:06] <gaal> which is 321

[10:06] <nothingmuch> gaal++ # great heroism

[10:06] <gaal> and that was how i typed "A" :)

[10:07] <theorbtwo> Wow, gaal... I wouldn't have thought of that.

[10:07] <castaway> pick one :)

[10:07] <gaal> you get to think of all sorts of things when you're desperate :)

[10:08] <theorbtwo> I would have thought of replacing the keyboard first...

[10:08] <castaway> but then we have about 3 extra keyboards lying around

[10:08] <theorbtwo> More, I think.

[10:08] * theorbtwo loves his IBM type M.

[10:12] <jabbot> pugs - 1545 - * `\_ ->` is now spelled `const`

[10:12] * castaway does actual work, having spend all morning see hacking (ahem ,)

[10:14] <nothingmuch> castaway: one minute, i need to carry up a monitor

[10:15] <castaway> no hurry :)

[10:16] <nothingmuch> see://woobling.org:6944 should work eventually,

[10:16] <theorbtwo> WOOHOO!

[10:16] <theorbtwo> It doesn't work yet, but I've gotten past the first hurdle.

[10:16] <gaal> what does see:// mean?

[10:16] <castaway> hurdle?

[10:17] <theorbtwo> Thing that one has to jump over to continue the race.

[10:17] <castaway> SubEthaEdit

[10:17] * castaway grins

[10:17] <theorbtwo> emacswiki.org/wiki/SubEthaEdit

[10:17] <wolverian> are there SEE-compatible, free software linux editors?

[10:17] * castaway adds a 'cw' in that url somewhere

[10:17] * gaal doesn't own a mac

[10:17] <theorbtwo> Not yet, wolverian; castaway and I are working on one.

[10:17] <nothingmuch> wolverian: they're working on it

[10:17] <castaway> not yet, wolverian, but we're working on it

[10:17] <castaway> heh :)

[10:18] <wolverian> I love you guys. :)

[10:18] * castaway blushes

[10:18] <wolverian> what are you coding it in, and what are you using as components?

[10:18] <theorbtwo> Thanks, wolverian.

[10:18] <theorbtwo> We're writing in emacs lisp, and creating many of our own components.

[10:18] * castaway lets theorbtwo answer and does some work instead

[10:18] <wolverian> oh, I hate you guys. emacs. :(

[10:19] <castaway> well you can use our protocol deciphering to make your own

[10:19] <nothingmuch> castaway: are there howl bindings for emacs?

[10:19] <castaway> who/what?

[10:19] <wolverian> mmhm. I wonder if simlpy using vim's perl bindings would be adequate.

[10:19] <autrijus> gaal: what does exp do again?

[10:19] <wolverian> simply, rather.

[10:20] <autrijus> is it not the perl5 exp?

[10:20] <autrijus> it should be a op1, no?

[10:20] <nothingmuch> rendezvous

[10:20] <nothingmuch> i think it should have two variants

[10:20] <nothingmuch> one being op1, using haskell's exp

[10:20] <nothingmuch> and vcasting it appropriately

[10:20] <nothingmuch> and the other being an op2 alias to **

[10:21] <autrijus> exp(2, 3) ?

[10:21] <nothingmuch> uhuh

[10:21] <theorbtwo> rendezvous forms only a very minor part of SEE's protocol stack; we're ignoring that bit.

[10:21] <theorbtwo> Where is that specified, BTW?

[10:21] <autrijus> is it defined in the bible?

[10:22] <theorbtwo> wolverian: If you want to write your own SEE-compatable client, you'll need to start with bencode/bdecode and BEEP (RFC 3080)>

[10:23] <autrijus> and isn't it serialized ObjC objects?

[10:23] <autrijus> i.e. you have little chance to munge them without ObjC

[10:23] <theorbtwo> No, autrijus, it isn't.

[10:23] <nothingmuch> theorbtwo: it should be a nobrainer with some rendezvous browser

[10:23] <wolverian> theorbtwo: thanks.

[10:23] <castaway> nm, I doubt there is.. but one doesnt need that bit anyway, much

[10:24] <nothingmuch> autrijus: in that case, won't GNUStep be able to provide good enough remote objects?

[10:24] <autrijus> nothingmuch: no idea. I'm just respewing rumours

[10:24] <wolverian> theorbtwo: what is bencode?

[10:25] <theorbtwo> The encoding scheme used in torrent files; the spec is in http://www.bittorrent.com/protocol.html (search for "bencoding").

[10:25] <wolverian> right. there's a module for that.

[10:25] <wolverian> thanks again.

[10:25] <theorbtwo> Note that it uses a small extension to that specification: Strings can start with : or '.'.

[10:25] <theorbtwo> Right; Convert::Bencode.

[10:25] <wolverian> there's also BT::Bencode; I don't know how good that is or if it's even on CPAN.

[10:26] <theorbtwo> I'm also working with a server in perl, but it's meant largely as a development tool.

[10:26] <wolverian> (just googling around while reading the RFC.)

[10:26] <wolverian> theorbtwo: are you going to implement BEEP in it, though?

[10:26] <nothingmuch> theorbtwo: do you have some wikipage where these notes are scribbled?

[10:26] <nothingmuch> wolverian: there's already BEEPCORE for perl

[10:26] <castaway> emacswiki.org search for subetha

[10:27] <gaal> sorry, was making coffee

[10:27] <wolverian> nothingmuch: oh. so I wouldn't have to write any protocol cruft myself, just the application layer?

[10:27] <theorbtwo> I know, nothingmuch, but it doesn't do what I want.

[10:27] <theorbtwo> Quite possibly.

[10:27] <wolverian> hmm. there is no POE BEEP component. :)

[10:27] <gaal> 2arg exp is not **, it's ** with the order of args switched :)

[10:27] <castaway> iek, POE :)

[10:27] <wolverian> Net::BEEP::Lite looks nice.

[10:28] <gaal> it's defined in S29

[10:28] <theorbtwo> There isn't a callback for the creation of a channel in Net::BEEP::Lite, though.

[10:28] <wolverian> yeah, the POD indicates it's _very_ lite

[10:28] <wolverian> that is, no asynchronous channels

[10:28] * castaway wonders what its point is then

[10:30] <wolverian> I don't see perl on beepcore.org :/

[10:30] <autrijus> gaal: got it.

[10:30] <wolverian> (besides Net::BEEP::Lite, and it's probably not enough of an implementation.)

[10:31] <castaway> DIY all the way, baby

[10:31] <castaway> (neither of them existed for elisp ,)

[10:31] <wolverian> argh. :)

[10:32] <castaway> which is why we're only just getting to the actual SEE stuff

[10:32] <nothingmuch> autrijus.explain($_) for «vCast castV»

[10:32] <castaway> iek

[10:33] <wolverian> the python library seems to be more complete. augh. 

[10:33] * castaway must remember to set utf-8 permanently

[10:33] <autrijus> castV casts anything into a Val

[10:33] <autrijus> vCast casts a Val into anything.

[10:33] <autrijus> however vCast can't be used for a mutable variable

[10:33] <nothingmuch> autrijus.elaborate

[10:34] <autrijus> ok. the args for op are Val types

[10:34] <autrijus> you can't directly perform operation on them

[10:35] <autrijus> so you need to use vCast to read them

[10:35] <nothingmuch> so in gaal's question

[10:35] <gaal> autrijus, okay, so please look at the following:

[10:35] <nothingmuch> op1 "exp" = \x -> exp(vCast x) appearantly doesn't work

[10:35] <pasteling> "gaal" at 192.115.25.249 pasted "vCast?" (22 lines, 1K) at http://sial.org/pbot/8952

[10:35] <wolverian> do you have any basic implementation notes somewhere on BEEP? if I decide to do this myself, I'm going to need some guidance. :)

[10:36] <nothingmuch> :t exp says it wants to eat a Float

[10:36] <nothingmuch> i assume you can make a VRat into a Floating

[10:36] <castaway> BEEP has RFCs, and is fairly easy

[10:36] <castaway> rfc3080

[10:36] <theorbtwo> Hm, now I segfault.

[10:36] <theorbtwo> I'm not sure if I should define that as progress or not.

[10:36] <theorbtwo> Also, 3081.

[10:36] * castaway has ignored 3081 so far

[10:36] <wolverian> castaway: yeah, I'm reading that. I was just wondering if there are any specific issues not addressed in that, or anything else you'd like to share. :)

[10:37] <castaway> I cant think of any offhand, its fairly simple

[10:37] <nothingmuch> libetha should be C IMHO, if there are volunteers

[10:37] <castaway> I did it from there, plus a tcpdump of a SEE session

[10:37] <nothingmuch> that way everyone can eat it

[10:37] <castaway> which you're welcome to have

[10:37] <castaway> C--

[10:37] <wolverian> I'd very much like to have the dump.

[10:37] <nothingmuch> C++ for being portable, is all

[10:37] <wolverian> (that sounded wrong..)

[10:38] <nothingmuch> ofcourse, when all our editors will be compiled for parrot... ;-)

[10:38] * castaway wishes other things also produced useful shared libs

[10:38] * theorbtwo wonders if we should start an SVN repo, and dump everything we've got in it.

[10:38] <castaway> that is, if theorbtwo is in agreement

[10:39] <theorbtwo> Hm?

[10:39] <theorbtwo> In agreement on what?

[10:39] <castaway> giving wolverian the ethereal dumps

[10:39] <theorbtwo> Of course.

[10:39] <castaway> is SVN safe?

[10:39] <theorbtwo> Link to them from the wiki.

[10:39] <theorbtwo> Safe?

[10:39] <wolverian> you have a wiki? :)

[10:39] <autrijus> gaal: you are missing a return.

[10:39] <autrijus> gaal: you can't return things w/o a return.

[10:39] <theorbtwo> We're abusing the emacswiki.

[10:40] <gaal> when do i need to return things as opposed to just have a function evaluate to them?

[10:40] * theorbtwo wonders if we should start decorating the source code with L<...> markers.

[10:40] <castaway> http://desert-island.dynodns.net/misc/dump.etherealdump (for now)

[10:40] <theorbtwo> gzip that, love.

[10:41] <castaway> safe, as in secure, if we run it locally

[10:41] <wolverian> thanks! 

[10:41] <autrijus> gaal: when you are in a monad.

[10:41] <castaway> done, add a .gz

[10:41] <autrijus> > :t return

[10:41] <autrijus> return :: (Monad m) => a -> m a

[10:41] <gaal> theorbtwo was right :)

[10:41] <wolverian> it's gzipped by the server automatically.

[10:41] <autrijus> return takes a value and put it into a monad.

[10:41] <wolverian> (if the client supports that, anyway. or so wget seems to claim.)

[10:42] <autrijus> so I fixed your code and checked it in.

[10:42] <gaal> so i need that in a do block as well, right?

[10:42] <autrijus> thanks :)

[10:42] <theorbtwo> ...and when I'll get the hubris to yell at ingy again, to tell him that Perl6::Bible should have a function that gives me the contents of the document I ask for (as raw POD).

[10:42] <autrijus> well sure, because a do block is just a way to write monadic code.

[10:42] <gaal> autrijus, my code? hah

[10:42] <autrijus> gugod_: can we have jabbot announce freepan commits?

[10:42] <wolverian> hmm, BEEP can run out of reply codes. :)

[10:42] <castaway> hmm, if we want to get/chat about multiple implementations, we should probably add a section on the kwiki on perlmonk.org

[10:43] <wolverian> I so suck at reading RFCs.

[10:43] <theorbtwo> wolverian, it's supposed to wrap at that point, which is why the spec is written to say that you can reuse msgnos that have had both a MSG and a RPY on them.

[10:43] <gaal> thanks, autrijus :)

[10:43] <wolverian> theorbtwo: ah, thanks.

[10:44] <castaway> right, but it has quite a few before it gets that far :)

[10:44] <gaal> map (++) [ autrijus, nothingmuch, theorbtwo ]

[10:45] <theorbtwo> Hm, any purticular reason that SHA1__0_0_1.hs gives extern__ = [['s', 'h', 'a', '1']], rather then extern__ = ["sha1"] ?

[10:45] <autrijus> theorbtwo: because that's how TH prints out code.

[10:45] <autrijus> "sha1" is a Data.PackedString converted 

[10:45] <theorbtwo> Ah, OK.

[10:45] <autrijus> 's' etc is primitive to haskell

[10:46] <castaway> wolverian: anyway, any questions, just ask.. I may even know the answers

[10:47] * theorbtwo reminds castaway that she's supposed to be working while she's at work.

[10:48] <wolverian> castaway: thanks. I'll do that. :)

[10:48] <castaway> oops :)

[10:49] * castaway fetches more tea instead

[10:52] <jabbot> pugs - 1546 - * exp

[10:52] <theorbtwo> Hm, how do I do a <- and explicitly give the type of the var I'm putting into?

[10:52] <theorbtwo> extern :: [String] <- loadFunction mod "extern__" doesn't quite do it.

[10:52] <autrijus> extern <- loadFunction mod "extern__" :: [String]

[10:53] <autrijus> extern <- (loadFunction mod "extern__" :: [String])

[10:53] <autrijus> extern <- (loadFunction mod "extern__" :: Eval [String])

[10:53] <autrijus> something like that

[10:53] <theorbtwo> Thanks.

[10:53] <autrijus> np :)

[10:54] * castaway sighs.. elisp/see hacking is so much more interesting than SQL project updating..

[10:55] <castaway> somebody motivate me ,)

[10:55] * Alias_ pulls out the whip

[10:56] <Alias_> Do some work and if you're good I'll use it!

[10:56] <theorbtwo> You just told your boss that you don't have time; if he thinks that you don't have time because you're playing at work, he probably won't look kindly upon it.

[10:56] <theorbtwo> Hey, watch it, there.

[10:56] <castaway> hacking isnt playing!

[11:02] <wolverian> wow, reading an RFC really makes you tired.

[11:03] <castaway> and thats actually quite a sane one, IMO

[11:03] <autrijus> the UTF9 one?

[11:03] <wolverian> BEEP. 3080.

[11:03] <autrijus> ah.

[11:04] <wolverian> where is the wiki on perlmonk.org?

[11:05] <castaway> theorbtwo.perlmonk.org/kwiki

[11:05] <wolverian> thanks.

[11:05] <castaway> as yet no SEE pages

[11:05] <autrijus> hrm, sign() should prolly return undef for undef

[11:05] <castaway> I could stuff my local "notes" ones in there

[11:05] <Alias_> So any news on a truly common SEE'like application?

[11:06] <wolverian> castaway: I'd be grateful.

[11:06] <castaway> Alias_: been asleep the last hour ? :)

[11:06] <Alias_> yes

[11:06] <castaway> anything to keep me from working :)

[11:07] <Alias_> castaway: Give me the 20c update

[11:08] <wolverian> I wonder how hard it would be to wrap beepcore-c

[11:08] <wolverian> it doesn't sound like fun.

[11:08] <castaway> Alias_: we're writing an elisp implementation .. 2/3s done maybe.

[11:08] <Alias_> elisp...

[11:09] <Alias_> So in other words a SEE client for emacs?

[11:09] <castaway> correct

[11:09] <wolverian> Alias_: I'm currently planning my own implementation of the protocol stack. I'm not sure yet about the application layer; I'd like to tie it into vim somehow.

[11:09] <Alias_> This is why I hate it when editors have their own language

[11:09] <castaway> wolverian: in no particular order (and not linked anywhere): BEEPDecode, BencodeBdecode, SubEthaEditProtocol, SubEthaEmacs (wiki pages=

[11:10] <wolverian> castaway: thanks! castaway++

[11:10] <castaway> the orginal (local) wiki is actually reachable, but seems to be terribly slow for most people

[11:10] <wolverian> damn, I need to get home to read these. 

[11:10] <castaway> hmm?

[11:11] <theorbtwo> He's trying to actually work at work.

[11:11] <wolverian> I don't have a comfortable hacking environment currently.

[11:11] <castaway> Alias_: well, it was that or perl.. I dont touch C/C++ in my free time

[11:11] <Alias_> So with vim and emacs caught up, and a mere mortal Win32 Ultraedit user like me find a program that the plugin will work with?

[11:11] <Alias_> s/and/what is/

[11:11] <castaway> hmm, you'd need a DLL

[11:11] <castaway> presumably

[11:12] <jabbot> pugs - 1547 - * according to s29 draft from rod, sign 

[11:12] <Alias_> Is there a Win32 emacs or vim spawn that works "normally" and isn't 90% obscure key-combination driven? :)

[11:12] <theorbtwo> emacs has menus.

[11:12] <castaway> win32 emacs should run it

[11:12] <Alias_> ok

[11:12] <Alias_> Then all is good good good :)

[11:12] * castaway will test at some point

[11:12] <castaway> what was I.. ? oh yeah, work..

[11:12] <theorbtwo> But not while she's at work.

[11:14] <wolverian> the rendezvous part of SEE isn't connected to BEEP in any way, is it?

[11:14] <castaway> no, just replaces the typing of URIs

[11:14] <wolverian> right.

[11:15] <castaway> bah..

[11:15] * castaway wonders if SQL can bitshift

[11:16] <wolverian> that sounds nasty.

[11:16] <shapr> I usually call that filesystem corruption.

[11:17] <castaway> hmm?

[11:17] <shapr> Sorry, standard smartass comment from me. When all my SQL is bitshifted, I call that filesystem corruption.

[11:19] * shapr boings cheerfully

[11:19] <shapr> I think I'm going to give up on Rob Nagler.

[11:19] <theorbtwo> Rob Nagler?

[11:19] <shapr> extremeperl

[11:20] <theorbtwo> Doesn't ring any bells.

[11:20] <theorbtwo> Oh, a book?

[11:20] <shapr> http://groups.yahoo.com/group/extremeperl/messages

[11:22] <jabbot> pugs - 1548 - * according to S29 atan2 is now spelled 

[11:23] <Alias_> Will be interesting to see the combination of SEE and Test::Inline

[11:23] <Alias_> Multiple people on one file writing the docs, tests and code simultaneously

[11:26] <castaway> ick :)

[11:26] <castaway> umm, iek :)

[11:28] <wolverian> shapr: how are you giving up on him?

[11:29] <theorbtwo> nopaste?

[11:29] <theorbtwo> jabbot, nopaste?

[11:29] <jabbot> theorbtwo: nopaste is Use http://sial.org/pbot

[11:29] <theorbtwo> jabbot, thank you.

[11:29] <jabbot> theorbtwo: You're not really talking about me -- are you?

[11:30] <shapr> wolverian: I'm tired of talking to him. It seems to me he's not looking for a better way, he's looking to stay inside the way he's got at all costs.

[11:30] <autrijus> stevan: I'm hacking your hangman

[11:30] <autrijus> sub cls returns Void {

[11:30] <autrijus>     system( ($?OS eq any(<MSWin32 mingw cygwin>)) ?? 'cls' :: 'clear');

[11:30] <autrijus> }

[11:30] <autrijus> that should work for now

[11:31] <autrijus> mm any<MSWin32 mingw cygwin>

[11:31] <wolverian> shapr: oh. :/

[11:32] * autrijus discovers a nice idiom for p6 :)

[11:32] <shapr> As much as I enjoy using Haskell, Epigram, Joy, or whatever, I'm sure there will be better solutions available in fifty years. I'd like to steal parts of that better future and use them today.

[11:33] <theorbtwo> Shapr: We hope to take less then 50 years to get perl6 usable.

[11:33] <shapr> haha

[11:34] <shapr> I'm just saying that everything we use and know has beauty and quality, but is necessarily imperfect. So it's best to look for lots of grains of goodness and keep them all in mind.

[11:34] <pjcj> perl6 is for the next 20 years, no?  But five of them have already gone ;-)

[11:35] <theorbtwo> shapr++

[11:35] <theorbtwo> You are indeed quite eloquent for what I am assuming is not your native language.

[11:36] <shapr> Heh, I'm from Alabama. Redneck is my native language!

[11:36] <theorbtwo> Oh, damn.

[11:36] <theorbtwo> That makes that reference somewhat less funny.

[11:37] <shapr> My swedish isn't nearly as eloquent.

[11:37] <theorbtwo> sial.org's pastebot seems to be down; what's a good alternative?

[11:40] * theorbtwo sighs... I'm getting closer, I think.

[11:41] <autrijus> theorbtwo++

[11:41] <autrijus> theorbtwo: nopaste.snit.ch ?

[11:42] <jabbot> pugs - 1549 - * more p6ification for hangman

[11:47] <stevan> autrijus++ # nice hangman/clear screen fix :)

[11:47] <theorbtwo> http://nopaste.snit.ch:8001/2256

[11:48] <autrijus> any<foo bar baz>

[11:48] <autrijus> is such a nice idiom.

[11:48] <stevan> I like that too

[11:48] <theorbtwo> Tis indeed.

[11:48] <theorbtwo> I think it'd like it better with a ~~, though.

[11:48] * stevan is very much in love with junctions :)

[11:49] <theorbtwo> $?OS ~~ any<MSWin32 mingw cygwin>

[11:49] <stevan> theorbtwo: with the mutiple operators you have greater control

[11:49] <autrijus> theorbtwo: you have this committer right thing

[11:49] <autrijus> :)

[11:49] <stevan> $?OS ne any<MSWin32 mingw cygwin>; $?OS eq any<MSWin32 mingw cygwin>; etc...

[11:50] * stevan has to unplug and drive to his weekly work meeting

[11:50] <stevan> bye all

[11:51] <theorbtwo> True, but I'm not so sure if the code I have is actually better then the code that is already there.

[11:51] <autrijus> oh, that works?

[11:51] <autrijus> the bit you posted

[11:52] <theorbtwo> Well, it works up to the (`mapM`) bit.  That segfaults.

[11:52] <Alias_> autrijus: You're involved in various Module::(Build|Install) stuff right?

[11:52] <autrijus> can you print out extern?

[11:52] <autrijus> Alias_: not M::B

[11:52] <theorbtwo> How?

[11:52] <autrijus> M::I is my work yes.

[11:52] <autrijus> theorbtwo: print extern

[11:52] <Alias_> autrijus: Is there any "standard" way to install a data file?

[11:52] <autrijus> Alias_: no. I think we've had this discussion before :)

[11:52] <autrijus> many moons ago

[11:52] <Alias_> I _am_ having a bit of deja-vu... 

[11:53] <Alias_> But them I'm working on Data::Package again, so that might be why

[11:53] <theorbtwo> I don't see any output.

[11:54] <autrijus> theorbtwo: hrm, try using trace

[11:55] <autrijus> trace (show extern) return ()

[11:55] <autrijus> but, maybe you can commit that bit

[11:55] <autrijus> so I can svk pull and go to dinner where there's no network :)

[11:55] <Alias_> autrijus: OK, so in that case, I'd like to _propose_ a standard way :)

[11:55] <Alias_> autrijus: If you think it will integrate with M:I

[11:56] <autrijus> I'd be happy to integ it w/ M::I.

[11:57] <theorbtwo> Still no output, but ci'd anyway.

[11:57] <autrijus> k.

[11:57] <autrijus> bbiab. :) &

[11:57] <theorbtwo> You'll have to change the hardcoded path, of course.

[11:57] <autrijus> sure.

[12:02] <jabbot> pugs - 1552 -  r6230@speights:  samv | 2005-04-05 19:5

[12:02] <jabbot> pugs - 1551 -  r6229@speights:  samv | 2005-04-05 19:2

[12:02] <jabbot> pugs - 1550 - inline haskell support -- I think this i

[12:13] * shapr hops cheerfully

[12:13] <theorbtwo> You seem very cheerful, shapr.

[12:14] <shapr> I am! I had food! I have sugary drinks! w00!

[12:14] <shapr> and I committed code to an open source project in the last 24 hours! w00h00!

[12:15] * theorbtwo grins.

[12:26] <Alias_> Question: Is a "lambda" basically the technical term for an anonymous subroutine?

[12:27] <shapr> How much detail do you want?

[12:27] <wolverian> I'd say the technical name is 'anonymous subroutine'. :)

[12:27] <Alias_> shapr: The level 2 version

[12:29] <shapr> \x -> x + 1 is a nameless Haskell function that adds 1 to a number.

[12:30] <shapr> Technically it's the lambda from lambda calculus.

[12:30] <theorbtwo> http://en.wikipedia.org/wiki/Lambda_calculus

[12:31] <shapr> In short, the turing machine and the lambda calculus are two approaches to computational theory. They can both do anything a general purpose computer can do, but one or the other is easier to reason about for varying purposes.

[12:32] <Alias_> damn the informal description on wikipedia is dense

[12:32] <Alias_> "In lambda calculus, every expression stands for a function with a single argument; the argument of the function is in turn a function with a single argument, and the value of the function is another function with a single argument. A function is anonymously defined by a lambda expression which expresses the function's action on its argument."

[12:33] <shapr> The first example I saw of that dense description was these crazy things called 'Church numerals' (Church numbers?).

[12:33] <elmex> shapr: it just popped into my mind, aren't u a regular #haskell idler?

[12:33] <shapr> elmex: yeah, I show up there sometimes.

[12:34] * shapr grins

[12:34] <Alias_> so yes, a "lambda" is a function, just without a name

[12:34] <Alias_> ... and apparently only one argument

[12:34] <shapr> Technically, Haskell functions only take one argument, even when they take several.

[12:34] <theorbtwo> All functions in haskell only have one argument.

[12:34] <theorbtwo> They just fake it really well.

[12:35] <elmex> shapr: i only remember you, back from the days when i idled there and tried to learn haskell ;) now i barely remember how to code in haskell ;/

[12:35] <Alias_> hmm... and it explains a lot about why they teach Haskell at university

[12:35] <shapr> Alias_: it does?

[12:35] <gaal> Gordon Freeman was a lisp hacker.

[12:35] <theorbtwo> OTOH, all functions in perl5 only take one argument, and that argument is always named @_.

[12:35] <Alias_> Because is Haskell is a lambda-focused language, mathematicians probably love it

[12:36] <shapr> I dunno. I've never had any CS classes, or any math classes.

[12:36] <theorbtwo> Mathematicians proveably love it, you mean.  ;)

[12:36] <Alias_> and thus in the "early" days of computer when it was mathematician heavy, haskell got used a lot

[12:36] <shapr> theorbtwo: haha!

[12:36] <theorbtwo> Alias, Haskell isn't that old.

[12:36] <shapr> Alias_: actually, lambda calculus is older than computers, and Haskell is only fifteen years old.

[12:36] * castaway returns, out of breath

[12:36] <Alias_> And when those people got old and wanted to teach and introductory language they already knew, Haskell got pushed onto another generation of uni students

[12:36] <Alias_> Anyways...

[12:36] <Alias_> It spans comp and math

[12:37] <Alias_> So I see why the unis like it

[12:37] <pjcj> but there was a plethora of other functional languages

[12:37] * castaway falls on theorbtwo. 

[12:37] <shapr> I'm just looking for better ways of doing things, that's how I found Haskell.

[12:37] <Alias_> But Haskell was the coolest one of the most recent generation?

[12:37] <shapr> Depends on what you mean by cool.

[12:38] <Alias_> The one all the cool kids were using

[12:38] <Alias_> being the people that dictate the courses :)

[12:38] <pjcj> haskell was designed to replace all the others, IIRC.

[12:38] <shapr> Haskell was designed because the most popular lazy functional language was a commercial closed source product.

[12:38] <pjcj> or at least the others in its class

[12:39] <shapr> And a bunch of guys wanted something they could hack on.

[12:39] <castaway> hmm, where'd he go?

[12:39] <shapr> castaway: I'm sorry, you squished him.

[12:39] <shapr> Remember, don't jump on people from six stories up!

[12:39] <pjcj> My college used Hope, but no one else did.

[12:40] <shapr> I always feel like a total geek when I want to say "Oh, Hope had some really cool features!"

[12:40] <castaway> hmpf, and I just climbed 4 floors, how did you know?

[12:40] * shapr laughs

[12:40] <shapr> castaway: are you really German?

[12:40] <castaway> No

[12:40] <shapr> whew.

[12:40] * castaway is a brit!

[12:41] <Odin-> Poor thing.

[12:42] * theorbtwo kisses castaway.

[12:43] <theorbtwo> (I was reading CNN.)

[12:43] <castaway> Aha!

[12:43] <shapr> I'm amazed that Haskell is so close to lambda calculus. The more I find powerful patterns in software, the more I think they depend on being powerful patterns from mathematics.

[12:43] <Odin-> theorbtwo shares a host with castaway, so I feel I must ask: In real life, or?

[12:44] <Odin-> :p

[12:44] <castaway> correct

[12:44] * Odin- curious.

[12:44] * castaway snuggles theorbtwo. (mines!)

[12:44] * theorbtwo snuggles back.

[12:44] <shapr> I'm tryin to code here! geez!

[12:45] <castaway> sowwy shapr 

[12:45] <castaway> ,)

[12:45] * shapr grins

[12:45] * castaway attempts more SQL, while waiting for the next interruption

[12:46] <shapr> select * from irc where username >= 5;

[12:46] <theorbtwo> shapr, any idea about the segfault autrijus and I were discussing a bit ago?

[12:47] <Limbic_Region> autrijus - http://www.perlmonks.org/index.pl?node_id=444853 # Perl6 and Ruby on Rails

[12:47] <shapr> I used to work on this 65,000 line visual basic trust management application. It had SQL queries that were several pages long, with no line breaks. Debugging those was fun.

[12:47] <castaway> ick

[12:47] <theorbtwo> Limbic, autrijus is at dinner.

[12:47] <castaway> BEEP! username is not numeric

[12:47] <shapr> doh

[12:50] <Limbic_Region> theorbtwo - he usually catches back up on the log, but I /msg'd him anyway

[12:52] <wolverian> Limbic_Region: I like how he hasn't apparently read any apos or even synopses. (re: perlmonks)

[12:52] <wolverian> I guess perlmonks isn't the right place to say RTFM. 

[12:53] <theorbtwo> We generally prefer that you say something else in addition to RTFM.

[12:53] <theorbtwo> ...like how to find the FM, and what FM to R.

[12:54] <wolverian> I try to do that on #perlhelp and such, yes.

[12:55] <Limbic_Region> wolverian - I haven't read the article yet.  I make a daily scan of use.perl journal entries and posts at the Monastery and mention anything parrot related to chip and anything p6/pugs related to autrijus

[12:56] <shapr> theorbtwo: have you considered the hightech option of throwing putStrLn in there?

[12:56] <castaway> ooh, hightec

[12:56] <theorbtwo> Hm, no, good idea, shapr.

[12:57] <wolverian> Limbic_Region: oh, right. thanks, too, it's always good to read such things, even if they're by IGNORAMUSES.

[12:57] <wolverian> I think I need to sleep. :/

[12:57] <shapr> I get tired of reading stuff written by Ignoramuses. I'd rather read stuff by Oleg Kiselyov. Then I feel like an Ignoramuses who can improve!

[12:59] <shapr> I feel that way when reading of autrijus' code too. Like "wow, I can really learn something here."

[12:59] <castaway> you can learn a fair bit attempting to fix other peoples crap code, too :)

[13:00] * Limbic_Region agrees with castaway

[13:00] <castaway> But I agree that one gets tired of it ,)

[13:01] <shapr> Alias_: btw, church numerals and all that lambda calculus stuff is tremendously fun.

[13:01] <Alias_> shapr: So you say :)

[13:01] <shapr> http://c2.com/cgi/wiki?ChurchNumeral

[13:01] <Alias_> shapr: I don't program for fun. Just to be ! bored

[13:01] <Alias_> shapr: Fortunately for CPAN, I get bored a lot

[13:02] <shapr> I can intellectually realize that some people do not program for fun. But I do not think I'll ever really get it.

[13:03] <Alias_> shapr: I've done practically everything fun I can think of with programming

[13:03] <shapr> My current email signature is "Programming is the Magic Executable Fridge Poetry, It is machines made of thought, fueled by ideas."

[13:03] <Alias_> shapr: And now I'm just out to make it not suck

[13:03] <shapr> Alias_: if you don't know about lambda calculus, there's a whole new world to be found.

[13:04] <Alias_> meh... but what's the point, really

[13:04] <shapr> What's the point of programming at all?

[13:04] <Alias_> I've probably discovered it myself independantly

[13:04] * mugwump laughs

[13:04] <Alias_> mugwump: It's a bad habit :)

[13:04] <shapr> Alias_: c'est votre choix

[13:04] <castaway> he speaks french too!

[13:05] <shapr> Peut etre. Parlez vous français Mademoiselle?

[13:05] <Alias_> yes, but unfortunately my spelling issues are far worse in French, so I don't dare type it

[13:05] <castaway> Non ,)

[13:05] <shapr> quelle dommage.

[13:05] <castaway> wot? :)

[13:05] <rgs> "quel"

[13:05] <shapr> rgs: man, I did that again! ouch!

[13:05] <shapr> rgs: thanks!

[13:05] * castaway got a B about 15 years ago (GCSE)

[13:06] <rgs> :)

[13:06] <Alias_> I wonder...

[13:06] <Alias_> Take a machine learning algorithm for recognising languages, add babelfish, and mix with an IRC client

[13:06] <shapr> Last time I took french classes was 1992.

[13:06] <Alias_> The mis-tranlations would be hilarious... but it might actually be functional

[13:07] <Alias_> Implementation is left as an exercise for the reader

[13:07] <castaway> those things are bad enough when you give them a specific language

[13:07] <shapr> But I spent a few hours in some bars in Lille last christmas speaking only French. That was fun. No one really understood me, but I sure felt cool.

[13:07] <Alias_> Masque: About the only knife I had I really like is my swiss army knife

[13:08] <shapr> Alias_: oh, try a leatherman!

[13:08] <Alias_> Masque: milspec... from Switzerland

[13:08] <shapr> Alias_: EMISCHAN

[13:08] * castaway looks confused.

[13:08] <Alias_> shapr: Nah... I have a "real" swiss army knife, and that is enough for me

[13:08] <Alias_> ack, channel

[13:09] <shapr> I have a stick. It is enough for me. It is turing complete.

[13:10] * shapr beats himself with his stick.

[13:10] <xerox> You need brainpower for fullify the turing completeness of your stick :-)

[13:10] * castaway stopped carrying a knife when people started complaining about them on various transport mediums

[13:10] <xerox> ^__^

[13:10] <castaway> (that was abt 15 years ago too)

[13:11] <Alias_> castaway: Now you just pack a sword in your carry-on?

[13:11] <castaway> heh, no, theorbtwo has the sword ,)

[13:11] <Alias_> I like the idea of getting a sword

[13:12] <Alias_> Even one of the knock off dodgy cheap ones

[13:12] <Alias_> But instead of mounting it or some shit, just leave it lying around in the loungeroom

[13:12] <castaway> heh

[13:12] <Alias_> "Oh, that's for roach killing"

[13:12] <theorbtwo> Mine is indeed lying around the living-room somewhere.

[13:12] <theorbtwo> Well, the small one; the big one is still in the US.

[13:13] <theorbtwo> BTW, check them, not carry-on.

[13:13] <shapr> Yeah, I have to check my leatherman too :-(

[13:13] <Alias_> "Crap a spider, $guest can you grab the sword? I think it fell down the back of the lounge"

[13:13] * castaway assumes Alias_ isnt quite that daft

[13:13] <elmex> ?

[13:13] * castaway lost a pair of pliers that way.. (coming back that is, going they didnt notice/complain... sigh)

[13:14] <Alias_> castaway: Well, if I were to do it, it would be the biggest craziest looking over the top sword I can find

[13:14] <castaway> yup, but putting it in the carry-on is asking for trouble

[13:14] <Alias_> 5-6 feet long, spikey bits, dragon's head on the pommel

[13:14] <Alias_> The whole 9 yards

[13:14] <castaway> :)

[13:14] <shapr> that's not 5-6 feet

[13:14] <castaway> 9 yards is 27 feet

[13:14] * castaway high-5s shapr

[13:14] <shapr> Isn't that like the whole two yards?

[13:14] <Alias_> heh

[13:15] * shapr snickers

[13:15] <castaway> dammit folks, this isnt SQL

[13:15] <shapr> and this isn't $work

[13:15] * theorbtwo threatens castaway with the shortsword.

[13:16] <castaway> iek!

[13:22] <jabbot> pugs - 1553 - * fix parsefail bug on false unaries

[13:23] <Alias_> ok, I've read the description of lambda calculus on wikipedia and it makes practically no sense

[13:23] <Alias_> Which probably means Haskell is not for me :)

[13:23] <autrijus> the old parsebug fixed

[13:23] <Alias_> sorry lambas :(

[13:23] <autrijus> next; last; return;

[13:23] <autrijus> now all just work.

[13:24] <theorbtwo> Alias, the description there seems very dense for programmers.

[13:24] <shapr> autrijus: can you suggest a task that is one step up from implementing builtins? do you think the want.{Scalar,...} fits in there?

[13:24] <theorbtwo> autrijus, any dice on my problem?

[13:25] <Alias_> I'm liking "lamba calculus as birds" a bit better though

[13:25] <autrijus> theorbtwo: I had not looked; sorry

[13:25] <Alias_> http://uq.net.au/~zzdkeena/Lambda/index.htm

[13:25] <autrijus> shapr: want.Scalar requires OO subsystem

[13:25] <Alias_> of course, I'm still not seeing the point

[13:25] <shapr> oh

[13:25] <autrijus> and we currently don't have one

[13:25] <autrijus> maybe implement kill()? :D

[13:25] <shapr> Alias_: whoa, that rocks.

[13:25] <autrijus> that's still a builtin, though

[13:26] <shapr> maybe a builtin that requires more than just filling in initSyms?

[13:26] <autrijus> not sure... you grok GADTs?

[13:26] <shapr> vaguely

[13:26] <autrijus> kill() requires a bit more thought

[13:26] <shapr> not grok :-)

[13:26] <shapr> ok, I'll check that out.

[13:26] <autrijus> or maybe help theorbtwo with DynamicLoader :)

[13:26] <shapr> ok

[13:27] <shapr> theorbtwo: is that paste all that you need to get the segfault?

[13:28] <Alias_> I don't like the use of . in lamba calc, because it makes it really bloody hard to read

[13:28] <castaway> ieks, COBOL

[13:28] <autrijus> shapr: you need just to check out the trunk of pugs

[13:28] <Alias_> I'm too used to . as method or concat

[13:28] <autrijus> install that, then checkout http://tpe.freepan.org/repos/ingy/SHA1/ then install that (perl Makefile.PL ; make install)

[13:28] <autrijus> then you can witness the segfault with

[13:29] <autrijus> make ghci ; loadHaskell

[13:29] <theorbtwo> Alias_: That's probably why Haskell spells it ->

[13:29] <theorbtwo> (And \ instead of lambda.)

[13:33] <shapr> I get an error building with the latest svn, anyone else?

[13:33] * shapr tries make clean && make

[13:34] <autrijus> is it an impossible error?

[13:34] <shapr> yup

[13:34] <shapr> fromJust: Nothing

[13:34] <autrijus> I get that too

[13:34] <autrijus> GHC bug. a clean fixes it

[13:34] <shapr> ok

[13:36] <shapr> Alias_: this lambda calculus is birds is a great find, thanks!

[13:36] <Alias_> shapr: I'm still confused as hell, but I think I at least have an idea of the point of it, from the math side of things

[13:37] <Alias_> in that sense the bird thing is handy

[13:37] <castaway> bird thing?

[13:37] <Alias_> http://uq.net.au/~zzdkeena/Lambda/index.htm

[13:37] <Alias_> "To shred a Mockingbird"

[13:37] <Alias_> Lambda calculus animated and described in bird names

[13:38] * shapr snickers wildly, "In the case of the Idiot song being heard by an Idiot bird we can perform another beta reduction and obtain a result which is just the Idiot bird/song."

[13:39] <xerox> "In the case of the Idiot song being heard by an Idiot bird we can perform another beta reduction and obtain a result which

[13:39] <xerox> Whoops.

[13:39] <castaway> cute

[13:41] <mj> t/pugsbugs/die_and_end.t             1   256     1    2 200.00%  1 :-)

[13:42] <jabbot> pugs - 1554 - * there is no nullary eval form.

[13:42] <Alias_> castaway: Of course, reading any haskell file in pugs still makes no sense... :)

[13:42] <castaway> It doesnt to me either, Alias_ 

[13:42] <shapr> I can help!

[13:42] <Alias_> heh

[13:43] <castaway> you can translate to perl?

[13:43] <shapr> oh, probably not.

[13:43] <castaway> elis?

[13:43] <castaway> elisp?

[13:43] <Alias_> I'm guess it's going to be easier to put a lamba on a camel than to put a camel on a lambda

[13:43] <shapr> maybe to elisp.

[13:44] <castaway> hmm

[13:44] <Alias_> shapr: Or maybe, "where the fuck do you start"

[13:44] <xerox> I do like the effort going on in putting a camel on a lambda, as in pugs :-)

[13:44] <shapr> I wrote a Baskin-Robbins introduction to Haskell for those who value methylphenidate - http://www.haskell.org/hawiki/HaskellDemo

[13:44] <Alias_> Haskell seems like the sort of language that really needs a video introduction

[13:45] <shapr> Hey, that's a good idea!

[13:45] <theorbtwo> vnc2swf ?

[13:45] <Alias_> Hi I'm Troy McClure.

[13:45] <shapr> And I'm Shae Erisson

[13:45] <shapr> And today we'll introduce you to the new LambdaCamel TV series!

[13:46] <Alias_> You may have seem me in such educational videos as "Sex. Know you know how, DON'T DO IT!" and "Forks and Toaster. A bad thing?"

[13:46] <Alias_> vnc2swf?

[13:46] <Alias_> So THAT's how he did it

[13:46] * Alias_ saw a swf video demo some some program the other day

[13:46] <theorbtwo> You may remember me from such educational films as Lambda does Latin Dancing and Beta Reduction -- the SEXY Way.

[13:47] <shapr> And you may have seen me in such educational films as "Ivory Towers, more fun than tilting at windmills?" and "Will the university of Lyon lie down with the lambda?"

[13:47] <Alias_> So tell me, do you have to define "add" in every single program?

[13:47] <shapr> no

[13:47] <Alias_> I also worry about anything where "true" is defined as a set of functions :)

[13:48] <shapr> Oh, you mean the temperature equality typeclass?

[13:48] <Alias_> shapr: Are you taking suggestions for that demo page?

[13:48] <shapr> I am.

[13:48] <shapr> I encourage them even.

[13:49] <shapr> Maybe there's no outright begging, but it is implied.

[13:49] <Alias_> somenumber = 1    (good)

[13:49] <Alias_> somestring = "somestring"    (good)

[13:49] <shapr> you think monads shouldn't go right after that?

[13:49] <Alias_> add1 :: Integer -> Integer      and       add1 x = x + 1

[13:49] <Alias_> slowing down a bit... but ok

[13:50] <theorbtwo> The first line tells you the signature of add1, the second tells you the defintion.

[13:50] <Alias_> yeah, I managed to get the idea after 10 seconds

[13:50] <castaway> just wait til you get to multiple arguments :)

[13:50] <Alias_> My next question, before you got any more complex, was "and how do you use it"

[13:50] <Alias_> How does one "do" anything

[13:51] <theorbtwo> Well, the sort answer is "just like perl, except for the parens".

[13:51] <Alias_> I need a 1 + 1 = 2 example, using your add1 function

[13:51] <castaway> good idea, Alias_ 

[13:51] <Alias_> immediately after you defined ad1

[13:51] <xerox> Missing function application?

[13:51] <shapr> Alias_: excellent point.

[13:51] <Alias_> here is how to define the most basic function, and how you use it

[13:51] * shapr edits

[13:51] <Alias_> here is how you define a lambda, and how you use it

[13:51] <Alias_> etc etc

[13:52] <Alias_> slowly slowly... with lots of parallels to normal functional programming

[13:52] <castaway> "a lambda"

[13:52] <castaway> ?

[13:52] <jabbot> pugs - 1557 -  r6235@speights:  samv | 2005-04-05 21:4

[13:52] <jabbot> pugs - 1556 - Implemented sum.

[13:52] <jabbot> pugs - 1555 - Add nick for shapr

[13:52] <Alias_> anonymous function ?

[13:52] <castaway> ah

[13:52] <Alias_> Am I misusing the term?

[13:52] <Alias_> -- anonymous function (we give this one a name anyway)

[13:52] <Alias_> add2 = (\x -> x + 2)

[13:52] <castaway> I dont know.. I know it from somewhere else :)

[13:53] <autrijus> anonymous function is correct.

[13:53] <castaway> the word "lambda" seems to get thrown about a lot and used for various things

[13:53] <shapr> nick?

[13:53] <castaway> nickname?

[13:54] * autrijus notes that

[13:54] <autrijus> data People = Person Name Age

[13:54] * castaway digs out the LPC lambda stuff

[13:54] <autrijus> reads worse than

[13:54] <autrijus> data People where Person :: Name -> Age -> People

[13:54] <shapr> truly

[13:55] * theorbtwo isn't sure what either of them are supposed to mean.

[13:55] <autrijus> so I guess I'll convert more pugs code to use that form :D

[13:55] <shapr> That's an interesting point. GADTs are more readable than boring datatypes?

[13:55] <autrijus> theorbtwo: it defaults a new type "People"

[13:55] <autrijus> to construct them, use "Person" function

[13:55] *** Aankh|Clone is now known as Aankhen``

[13:55] <autrijus> which takes two arguments of "Name" and "Age" type

[13:55] <autrijus> and returns something that belongs to "People" type

[13:55] <autrijus> s/defaults/defines/

[13:56] <mj> WinXP ... 209/3795 subtests failed, 94.49% okay. After s/todo_//g ... 1087/3795 subtests failed, 71.36% okay ... $Pugs ~~ '71% percent Perl 6' ?

[13:56] <theorbtwo> Something like that, mj.

[13:57] <shapr> I really like that idea.

[13:57] <shapr> Alias_: what do you think about the add1 example I used?

[13:57] <castaway> wait, the 2nd reads easier than the first, autrijus ? 

[13:58] <Alias_> shapr: /me looks

[13:59] * castaway notes parallels between LPC closures and LISP (hmm, what fun)

[14:00] <theorbtwo> Unsurprising -- doesn't the L in LPC stand for LISP?

[14:00] <shapr> autrijus: GADTs for readability is a great idea, thanks!

[14:00] <castaway> No

[14:00] <castaway> "Lars"

[14:00] <castaway> Lars Penji C (sp?)

[14:01] <shapr> yay LPMuds!

[14:01] <castaway> confusingly, its docs call "anonymous functions written in a weird mini language" - "closures" :)

[14:01] <castaway> precisely

[14:01] <shapr> Closures have some other picky details that make them interesting. The word comes from the fact that you 'close over' the values.

[14:01] <Alias_> shapr: aaaah... so fortytwo = add1 41 is basically like a normaly function call but without the braces that add so much annoying readability

[14:01] <Alias_> shapr: That is a Big Deal(TM)

[14:02] <theorbtwo> Alias: Yep.

[14:02] <castaway> yeah, but I'm not actually sure that LPCs do

[14:02] <Alias_> makes understanding at least somewhat possible, maybe

[14:02] <shapr> Alias_: well, braces add readability for some folk, I assume.

[14:02] <castaway> Alias_++

[14:02] <theorbtwo> I think Haskell would be much more readability if they added some parens and commas.

[14:02] * castaway too

[14:02] <theorbtwo> You can use parens, but they go around expressions, not argument lists.

[14:02] <Alias_> shapr: Well, for camels, the fact that add1 41 is add1(41) is gunna matter a LOT

[14:02] <theorbtwo> (And around tupples.)

[14:03] <Alias_> shapr: Since we are used to full parens on things

[14:03] <castaway>                 closure max;

[14:03] <castaway>                 max = lambda( ({ 'x, 'y }),

[14:03] <castaway>                               ({ #'? ,({ #'>, 'x, 'y }), 'x, 'y }) );

[14:03] <castaway>                 return funcall(max,7,3);

[14:03] <castaway> (even more silly parentheses :)

[14:03] <shapr> That is clearly closing over the values.

[14:03] * shapr eats a value for lunch.

[14:03] <theorbtwo> Alias, recall that parens are optional in perl.  However, they are /disallowed/ in haskell.

[14:04] <castaway> which vals? I seem to be blind

[14:04] <shapr> the 'x and 'y values.

[14:04] <shapr> well, I think so.

[14:04] <castaway> umm, they're passed in, not external?

[14:04] <shapr> ok, they are..

[14:04] <shapr> but it could be closing over values!

[14:04] <Alias_> theorbtwo: True, but most people don't use implicit braces any more, since most coding now is OO, and OO MUST have braces

[14:04] * shapr pouts

[14:04] <castaway> I've never seen any that do

[14:04] <Alias_> There is remarkebly little use of function signatures to allow implicit braces

[14:04] * castaway tickles shapr.

[14:05] * shapr unpouts

[14:05] <shapr> castaway: can you get partial application by filling in one part of a lambda?

[14:05] <castaway> Alias_: who are these "most people" ? :)

[14:05] <theorbtwo> That's because p5 prototypes aren't very good at that.

[14:05] <Alias_> castaway: Most camels

[14:05] <castaway> Alias_: I wouldnt agree..

[14:05] <castaway> shapr umm, I dont think so

[14:06] <Alias_> castaway: As a percentage of the code you've written in the last year, how much uses implicit braces

[14:06] <Alias_> castaway: Hell... how much is non-OO

[14:06] <theorbtwo> I take advantage of implicit braces and non-OO quite a bit, Alias.

[14:06] <theorbtwo> I think OO is rather overrused by many.

[14:06] <Alias_> I've got maybe 2000 lines of functional stuff, and 150,000 lines of OO stuff

[14:07] <castaway> umm, you can do it with unbound closures tho

[14:07] <shapr> hm, neat.

[14:07] <castaway> Alias_: ALL of minie does.. I just know/have seen a fair few people who dont, per default

[14:07] <theorbtwo> Alias: You almost certainly mean imperative, not OO.

[14:07] <theorbtwo> Er, imperative, not functional.

[14:07] <Alias_> sorry, procedural?

[14:07] <castaway> And lots of it is non OO

[14:07] <Alias_> imperative...

[14:07] <theorbtwo> shapr, you can always use closures to create currying.

[14:08] <shapr> yay

[14:08] <shapr> Is a functor the opposite of an imperator?

[14:08] <theorbtwo> I don't know what either of those are.

[14:08] <Alias_> (\x = x + 2) is equivalent to sub { return $_[0] + 2 }   ?

[14:09] <theorbtwo> Yes.

[14:09] <theorbtwo> The return is optional, BTW.

[14:09] <pjcj> perl -wle 'sub add1 { $_[0] + 1 } $forty_two = add1 41; print $forty_two'  # I like missing parens

[14:09] <Alias_> right

[14:09] <Alias_> just trying to be clearer

[14:10] <theorbtwo> Oh, right... /me forgot which language was your native, and which you were uncertian about.

[14:10] <Alias_> shapr: And you use pooled idenfitiers?

[14:10] <theorbtwo> (\x = x + 2) is exactly equvlent to sub { $_[0] + 2 }, down to the closing.

[14:11] <shapr> Sorry, my identifiers can't swim. No really, what does that mean?

[14:11] * castaway grins

[14:11] <Alias_> is C<   add1 x = x + 1  > equivalent to C<   add1 = (\x -> x + 1)   >

[14:11] <castaway> lambda (x) (+ x 2) :)

[14:12] <castaway> (lambda (x) (+ x 2)) (of course)

[14:12] <shapr> Alias_: yes it is.

[14:12] <Alias_> so (\x = x + 2) differs in that while Perl would create a ref to the func, Haskell's IS the func?

[14:12] <wilx> Hmm, OT question.

[14:13] <wilx> Does SVK allow background syncing of reps while checking out something on foreground?

[14:13] <shapr> I don't quite understand the difference between a ref and the function itself.

[14:13] <Alias_> well... for example...

[14:13] <autrijus> shapr: easy

[14:13] <Alias_> $reference = sub { $_[0] + 1 };

[14:13] <autrijus> in perl, everything is IORef.

[14:13] <shapr> oh!

[14:13] <Alias_> You have to escape the ref to use it

[14:14] <shapr> that's wild!

[14:14] <autrijus> and all programs are in the IO monad.

[14:14] <autrijus> (with builtin ContT and ReaderT)

[14:14] <autrijus> that's all :)

[14:14] <Alias_> autrijus: I think you two need to create a pair of primers

[14:14] * shapr appoints autrijus dual-citizenship lambdacamel

[14:14] <shapr> Or at least fluent translator

[14:14] <Alias_> autrijus: Lamba for Camels, and Camel for Lambdas

[14:15] <autrijus> Alias_: I have some URLs in PA01...

[14:15] <Alias_> If the two communities are going to be mixing for a while, it may well be needed a lot

[14:15] <autrijus> more suggestions welcome

[14:15] <theorbtwo> shapr: Autrijus already is a fluent translator.

[14:15] <shapr> It's sort of braintwisty for me to figure out how you would do stuff with everything wrapped in an IORef.

[14:15] <Alias_> theordtwo: Beware the English-only speaker who also knows only PHP

[14:15] <autrijus> easy; you "deref" it.

[14:15] <shapr> theorbtwo: yes, but he has now added Haskell <-> Perl to his lists.

[14:16] <Alias_> &$ref

[14:16] <Alias_> The & derefs

[14:16] <shapr> yeah, I dig it.

[14:16] <shapr> &IORef

[14:16] <autrijus> and by deref, it actually means "cast the thing in IORef to one of <Code Scalar Hash Array>."

[14:16] <autrijus> because you see, perl5 is a strongly typed language.

[14:16] <autrijus> with no subtypes.

[14:16] <theorbtwo> It's sort of braintwisty for me to figure out how you do stuff when you keep having to enter and escape monads.

[14:16] <shapr> Dare I ask what those types signify?

[14:16] <theorbtwo> It just only has a very short list of types, and not the ones you'd think.

[14:16] <Alias_> Code is an anonymous function

[14:17] <shapr> I'll gues that, Code is a sub, Array is an array, and...

[14:17] <theorbtwo> shapr, latin plural class, believe it or not.

[14:17] <autrijus> Hash is a Data.Map

[14:17] <Alias_> Scalar is a string/number/reference

[14:17] <shapr> oh wow

[14:17] <Limbic_Region> autrijus - you get the link I /msg'd you?

[14:17] <theorbtwo> Scalar is string/number/reference/undef (a bit catch-all).

[14:17] <shapr> Geez, Larry Wall should hook up with Aarne Ranat.

[14:17] <shapr> um "Aarne Ranta"

[14:17] <autrijus> Scalar is Either Ref Value

[14:17] <shapr> huh

[14:18] <autrijus> and Value would be the union of String, Num, Int

[14:18] <pjcj> Also Regexp, IO

[14:18] <autrijus> s/Num/Float/

[14:18] <Alias_> autrijus: We'll ignore Ref and Glob for now? :)

[14:18] <shapr> Why nested refs?

[14:18] <autrijus> shapr: because somebody like it.

[14:18] <shapr> fair enough

[14:18] <autrijus> shapr: because that's how perl does multidim arrays.

[14:18] <Alias_> shapr: It's partly the C heritage

[14:18] <autrijus> perl arrays can't contain arrays

[14:18] <autrijus> only scalars

[14:18] <theorbtwo> Shapr: Arrays and hashes only hold scalars.

[14:18] <autrijus> so those are references to arrays

[14:18] <Alias_> @inner = ( 1, 2, 3 );

[14:19] <Alias_> @outer = ( \@inner )

[14:19] <shapr> Hm, interesting.

[14:19] <Alias_> bad example

[14:19] <autrijus> shapr: e.g. perl allows for

[14:19] <autrijus> [ [1,2], 3 ]

[14:19] <Alias_> autrijus: Or specifically, how perl DOESN'T to multidim arrays

[14:19] <autrijus> which is ill typed in haskell.

[14:19] <autrijus> the trick is to make it

[14:20] <Alias_> Perl has no proper multidimentional array, just arrays containing pointers to other arrays

[14:20] <autrijus> [ (Ref Array [1,2]) (Int 3) ]

[14:20] <Alias_> So the length of each dimention is not enforced

[14:20] <theorbtwo> s/pointers/references/

[14:20] <autrijus> (Int) and (Ref a) being both constructors to Scalar.

[14:20] * castaway looks slightly lost.

[14:20] <autrijus> so that has type [Scalar]

[14:20] <theorbtwo> Indeed, the number of dimensions is not enforced.

[14:20] <autrijus> and hence well typed.

[14:21] <theorbtwo> castaway: A haskell array is limited to containing any number of elements, all of which have the same type.

[14:21] <shapr> That kind of makes sense, an array of pointers.

[14:21] <castaway> hmm, so are LISP ones, thats why it also has lists :)

[14:21] <autrijus> the weirdo thing is that Scalar is a union of pointer or pure values.

[14:21] <castaway> No pointers!

[14:21] <Alias_> shapr: Thus, to be camel-friendly, you may need to point out that add2 = (\x -> x + 2) is exactly equivalent to add2 x = x + 2

[14:22] <shapr> Right, I'm beginning to see that.

[14:22] <Alias_> Big difference between "reference to" and "is" for us

[14:22] <Alias_> The sigil is what defines the IS

[14:22] <castaway> does haskell have anything that does allow a dynamic number of elements?

[14:22] <autrijus> castaway: a list? :)

[14:22] <theorbtwo> Sadly, perl 6 is trying to hide the difference, without getting rid of it.

[14:23] <castaway> oh sorry, misread.. any number of els, same type

[14:23] <castaway> what about multi types then?

[14:23] <shapr> You can do multi-types with HList, but it's not for the faint of heart.

[14:23] <Alias_> shapr: In fact, I'd do naked (\x -> x + 2) first, then show assigning it, THEN show it's the same

[14:23] <autrijus> castaway: that's called a HList.

[14:23] <shapr> Alias_: show me?

[14:23] <autrijus> but usually in haskell, you either fix the number of els

[14:23] <autrijus> or the type.

[14:23] <Alias_> -- anonymous function

[14:23] <autrijus> if you fix the els, it's called a n-tuple

[14:24] <Alias_> (\x -> x + 2)

[14:24] <autrijus> written as (a,b,c)

[14:24] <theorbtwo> Tupples allow elements of any type, but you have to declare how many elements, and of what types, the purticular tupple will have.

[14:24] <autrijus> right.

[14:24] <Alias_> -- but you can assign these anyway

[14:24] <autrijus> if you want to keep both variadic

[14:24] <autrijus> you want HLists.

[14:24] <castaway> yeah, I gave up reading the tutorial somewhere there

[14:24] <Alias_> add2 = ...

[14:24] <Alias_> -- assigning in this way is exactly the same as the basic function def

[14:25] <Alias_> add2 x = x + 2

[14:25] <autrijus> oh also, Alias_, "=" in haskell reads "binds to" 

[14:25] * castaway hands around tea and biscuits.

[14:25] <autrijus> it's roughly the same as :=

[14:25] <autrijus> in perl6

[14:25] <chip> autrijus: If you'll indulge me, what in your Rule modules should I look for as the key difference from stock Parsec?  Interface?  New concept(s)?

[14:25] <Alias_> autrijus: I'm sort of getting that

[14:25] <Alias_> It's a type-less pooled identifier space

[14:26] <autrijus> chip: uhm, from the outside, there's no difference really

[14:26] <theorbtwo> Oooh, tea and biscuts!

[14:26] <autrijus> chip: I added the "List" and "Chain" assocs

[14:26] <chip> Alias_: but with packages!  foo is Main.foo

[14:26] <autrijus> chip: and there's some code cleanups 

[14:26] <shapr> Alias_: cool, I'll add that. thanks for the contribution!

[14:26] <autrijus> uh it's not type-less

[14:26] <chip> autrijus: I haven't read the code yet, thus the "obvious" question; I'm asking for what to look _for_

[14:26] <autrijus> each identifier has one type

[14:26] <Alias_> sorry, non-type-split?

[14:26] <autrijus> chip: ok. assume they are identical.

[14:27] <autrijus> "sigilless" is the term.

[14:27] <Alias_> in the sense that perl has $foo and @foo and etc

[14:27] <theorbtwo> D'oh!

[14:27] <autrijus> Alias_: do you know that in perl6 you can say

[14:27] <theorbtwo> is foo <- bar in a monad lazy?

[14:27] <theorbtwo> That is, will bar never be executed if I never use foo?

[14:27] <autrijus> my %foo is Array; %foo[0] = 1;

[14:27] <autrijus> theorbtwo: that is mostly the case.

[14:27] <autrijus> there are exceptions.

[14:27] <theorbtwo> Blast.

[14:28] <Alias_> autrijus: Yeah, I've been getting some funny smells from certain p6l posts, so it doesn't surprise me too much

[14:28] <autrijus> hence my suggestion in using trace()

[14:28] <theorbtwo> That explains it; I'm segfaulting earlier then I thought.

[14:28] <autrijus> which forces strictness.

[14:28] <chip> autrijus: Maybe you could pass it as an argument to a function that declares its parameter with "!" for forced evaluation.  I forget what that's called.

[14:28] <autrijus> strictness annotation.

[14:28] <chip> ah

[14:28] <autrijus> the most usual form is $!

[14:28] <Alias_> autrijus: I'm presuming some form of use strict will stop that from being legal?

[14:28] <autrijus> which evals the rhs and hands it to lhs for apply, just like $

[14:29] <autrijus> Alias_: I have no idea. I think that may be intentional.

[14:29] <autrijus> intentionally legal anyway.

[14:29] <shapr> Alias_: better?

[14:29] * Alias_ looks

[14:29] <shapr> It's exactly what you wrote, so...

[14:29] <Alias_> whoa... hang on

[14:29] <Alias_> you added something

[14:29] <shapr> I did?

[14:29] <Alias_> add2'     <--? WTF you didn't mention that before

[14:29] <shapr> huh?

[14:29] <shapr> oh

[14:29] <Alias_> the quote

[14:30] <theorbtwo> ' is a perfectly valid character in identifiers in haskell.

[14:30] <theorbtwo> (I also find this confusing.)

[14:30] <xerox> autrijus: I didn't understand, is it $! different from $ ?

[14:30] <shapr> right, and it's a commonly used math thingy, a and a' means a and a prime

[14:30] <theorbtwo> xerox: A bare $ is meaningless in perl.

[14:30] <Alias_> theorbtwo: kinda

[14:30] <xerox> theorbtwo: whoops, perl's $! equals Haskell's $ ?

[14:31] <Alias_> theorbtwo: The sigil doesn't strictly have to touch the idenfier

[14:31] <Alias_> $ foo      is the same as $foo

[14:31] <xerox> I tought you were talking about Haskell's $!.

[14:31] <autrijus> I'm talking about haskell's $!

[14:31] <autrijus> Prelude> :t ($)

[14:31] <autrijus> ($) :: (a -> b) -> a -> b

[14:31] <autrijus> Prelude> :t ($!)

[14:31] <autrijus> ($!) :: (a -> b) -> a -> b

[14:31] <autrijus> see, same type

[14:31] <shapr> Alias_: if you have any other suggestions, I'd like to hear 'em.

[14:32] <xerox> autrijus: yep, different semantics?

[14:32] <Alias_> shapr: So you added ' to make it a different name, but using ' was a convention of familiarity to math'heads?

[14:32] <autrijus> the only difference being that ($!) evaluates the right hand side strictly.

[14:32] <castaway> shapr: Is there an infinite arg function? eg: (defun addall (&rest args) .. ?

[14:32] <autrijus> while ($) does not evaluate right hand side until needed.

[14:32] <Alias_> shapr: In that case, you could put the add2 x = x + 2 in the comment

[14:32] <shapr> Alias_: I changed to add3 x = x + 3

[14:32] <Alias_> better to make it truly identical

[14:32] <autrijus> castaway: yes there is :)

[14:32] <Alias_> just put it in the comment

[14:32] <shapr> ok

[14:32] <castaway> care to add that, while you're there?

[14:32] <xerox> autrijus: I see, thank you.

[14:32] <autrijus> castaway: see Text.Printf

[14:33] <autrijus> it needs tricks.

[14:33] <autrijus> i.e. not "elementary" haskell.

[14:33] * castaway is trying to improve the demo too :)

[14:33] <Alias_> oh!

[14:33] <shapr> castaway: you can also do sum [1,2,3,4,5]

[14:33] * Alias_ just noticed this page is a wiki

[14:33] <castaway> Alias_: heh, didnt notice?

[14:33] <shapr> Yeah, I'm maintainer of the HaskellWiki too.

[14:34] <shapr> It's funny how admin/maintainer so often means "hi-tek janitor"

[14:34] <Alias_> Can I make minor changes?

[14:34] <shapr> sure

[14:34] <Alias_> just to presentation really

[14:34] <shapr> it's a wiki

[14:34] * PerlJam hands shapr a broom

[14:34] <PerlJam> Get to work! 

[14:34] <PerlJam> ;-)

[14:34] * shapr upgrades to broom 2.0

[14:34] * castaway as yet doesnt even remember what [..] means in haskell

[14:35] <PerlJam> castaway: just like perl IIRC

[14:35] <shapr> castaway: in what context?

[14:35] <theorbtwo> Creates a list.

[14:35] <theorbtwo> More or less like [] in perl.

[14:35] <castaway> your sum example

[14:35] <shapr> ok, now we have the big guns.

[14:35] * castaway hugs lambdabot 

[14:36] <shapr> @plugs [1..5]

[14:36] <shapr> The plugs command runs a full Haskell subprocess (with IO limitations, of course) and gives the results.

[14:36] <theorbtwo> Odd, shapr, lambdabot just gave the answer to that to me in a /msg.

[14:36] <castaway> PerlJam: that would mean it creates a reference to an anon-array :)

[14:36] <Alias_> shapr: Damn, it's getting denser :)

[14:36] <shapr> theorbtwo: it's actually, a notice

[14:37] <theorbtwo> Oh.  GAIM doesn't handle those well, then.

[14:37] * castaway gets it in the channel, in purple

[14:37] <shapr> theorbtwo: The IRC RFC specifies that automated processes should only send via NOTICE because otherwise those same processes might get into a loop.

[14:37] <shapr> list via PRIVMSG, send via NOTICE

[14:37] <theorbtwo> Makes some degree of sense.

[14:37] <castaway> so it wont read its own output?

[14:38] <castaway> @plus sum [1,2,3,4,5]

[14:38] <shapr> Right, it might get into a loop.

[14:38] <theorbtwo> Most bots I've seen ignore that, though.

[14:38] <castaway> @plugs sum [1,2,3,4,5]

[14:38] <castaway> ooh, I can do haskell, me :)

[14:38] <shapr> yay!

[14:38] <castaway> @plugs sum [1..2]

[14:39] <theorbtwo> Is there a way to use lambdabot to do the equiv of :t from ghci?

[14:39] * castaway pats lambdabot on the head.

[14:39] <xerox> @type foldr

[14:39] <Alias_> shapr: You've got a bit of a circular description there, re partial application

[14:39] <theorbtwo> Ah, nifty.

[14:39] <shapr> Alias_: how so?

[14:39] <ninereasons> @plugs product [1,2,3,4]

[14:39] <ninereasons> cool

[14:40] <xerox> @plugs intersperse 'Z' "zzzz"

[14:40] <Alias_> You describe the multi-arg is invoking partials, which I haven't seen, then shows partial using the multi :)

[14:40] * xerox loves intersperse.

[14:40] <Alias_> s/is/by/

[14:40] * autrijus notes that lambdabot is much safer than Safe.pm :)

[14:40] <shapr> Alias_: It's difficult to explain one without the other. Can you think of something better?

[14:40] <castaway> what a useful function, xerox  ,)

[14:41] <xerox> castaway: it is! :-)

[14:41] <Alias_> shapr: I'll see what I can do

[14:41] <chip> autrijus: sorry to bother you again, but I can't find any definition for ($).  Where to look?

[14:41] <shapr> I guess I can just start with multi-arg functions.

[14:41] <autrijus> Alias_: do you have pugs installed? :)

[14:41] <Alias_> shapr: But I find this idea of partial evaluation built into the language to be quite amazing

[14:41] <Alias_> autrijus: I have a checkout... but no

[14:41] <shapr> Alias_: yeah, I agree. It r0xx0rs.

[14:41] <shapr> Alias_: And it's totally based on lambda calculus.

[14:42] <Alias_> shapr: Since I've been debating how to do partial evaluation in Perl

[14:42] <autrijus> chip: sure. http://haskell.org/onlinereport/standard-prelude.html

[14:42] <shapr> lambda calculus has a bunch of cool tricks like that.

[14:42] <chip> ah, of course

[14:42] <autrijus> f $  x    =  f x

[14:42] <Alias_> shapr: Mainly be using PPI to "read" perl and manipulate the source manually, then eval it :)

[14:42] <Alias_> shapr: Which would be absolutely insanely evil

[14:42] <Alias_> s/be/by/

[14:42] <autrijus> Alias_: there is http://search.cpan.org/~dconway/Perl6-Currying-0.05/lib/Perl6/Currying.pm

[14:43] <Alias_> You'll have to escuse my little spelling/grammarisms. I type quickly and have got a little mild ADD/dyslexia

[14:43] <autrijus> Alias_: also if you have pugs installed, you can try it out easily :)

[14:43] <autrijus> pugs> my $add = sub ($x, $y) { $x + $y }

[14:43] <theorbtwo> From the top of my head: sub partial {my ($coderef, @args)=@_; return sub {$coderef->(@args, @_) }}

[14:43] <autrijus> pugs> my $add1 = $add.assuming(1)

[14:43] <autrijus> pugs> $add1(2)

[14:43] <autrijus> 3

[14:44] <autrijus> that's partial application for you.

[14:44] <theorbtwo> This is what I said earlier about building currying off of closures.

[14:44] <shapr> Alias_: It's okay, I have heavy ADHD. I can dig it.

[14:44] <shapr> Speaking of which, it's time for more DRUGS!

[14:44] <autrijus> and the perl6 ways is better because you can partially apply $z first for a function that takes $x $y $z

[14:44] <Alias_> Well it's no wonder Haskell makes for such nice optimising compilers then

[14:45] <wolverian> autrijus: does &add.assuming(1) work? (I don't have a recent pugs due to the new GHC requirement.)

[14:45] <autrijus> to do that in haskell using point free style is... an exercise in madness.

[14:45] <shapr> Alias_: just wait till you see monads. They make compilers soooo much easier.

[14:45] <autrijus> wolverian: uhm, what's your platform that prevents you having GHC 6.4?

[14:45] <autrijus> wolverian: yes it works

[14:45] <Alias_> You can take things like if ( $os eq 'Win32' ) { and remove it from the functions for the current platform

[14:45] <wolverian> autrijus: it doesn't prevent, I'm just lazy and haven't compiled it myself yet

[14:45] <autrijus> Gruber: welcome aboard!

[14:45] * theorbtwo wonders who Gruber is.

[14:46] <castaway> .. and where

[14:46] * Gruber bows

[14:46] <shapr> Anton Berezin?

[14:46] * shapr knots

[14:46] <theorbtwo> Ah, hello, Gruber.

[14:46] * castaway wonders how it knows which param is being assumed

[14:46] * autrijus is proud to have tobez, the BSDPAN czar, on board :)

[14:46] <autrijus> castaway: always the first. but you can also do

[14:46] <autrijus> $add.assuming( :y(3) )

[14:46] * shapr waits for flip

[14:47] <castaway> ah, sneaky

[14:47] <Alias_> shapr: I think the problem with invoking partials in the multi-variable comment is that you insert $difficult topic in the middle of a description of another $difficult concept

[14:47] <autrijus> castaway: it's absolutely crazily nice.

[14:47] <Alias_> shapr: My head was fully occupied with Integer -> Integer -> Integer and you threw in a wrench

[14:47] <autrijus> nothingmuch++ # implemented it in 3 days with _no_ prior haskell knowledge

[14:47] <castaway> Yeah, that'll get rid of most of the stuff I'd keep global :9

[14:47] <castaway> wow

[14:48] <castaway> assuming($dbh) - yay

[14:48] <autrijus> and largely without my help

[14:48] <Alias_> Haskell will rock for doing platform-adaptive coding

[14:48] <theorbtwo> Note that it just replaces global variables with global functions.

[14:48] <shapr> Alias_: what about moving the partial application explanation down under the multi-arg function, to just before the first demonstration of partial application?

[14:48] <autrijus> theorbtwo: strangely, we find global functions easier to reason about :)

[14:48] <Alias_> shapr: Yeah, split it in half or something

[14:48] <castaway> you cant have everything.. (anyway whats wrong with global funcs, are we going java-like now?)

[14:48] <autrijus> theorbtwo: partly because you can't assign into a function.

[14:49] <wolverian> hmm. aren't statement modifiers (postfix 'if' and such) macros in perl6? but can they affect the parsing of the RHS? hmm.

[14:49] <Alias_> shapr: If I read the first three lines of the comment 2 or 3 times I "get" it

[14:49] <castaway> assuming("sql is already written") -> false, damn

[14:49] <Alias_> shapr: It was the last two that screwed me up mid-trying-to-understand

[14:50] <shapr> Alias_: better?

[14:50] <autrijus> wolverian: yes. now, try to get macros specced :-(

[14:50] <autrijus> wolverian: I can fake/improvise lots of missing synopses

[14:50] <autrijus> but macro I cannot

[14:50] <wolverian> autrijus: eugh. they need the whole parse tree interface.

[14:50] <autrijus> because there's nothing equiv in perl5.

[14:50] <autrijus> wolverian: we have that.

[14:50] <shapr> y0 metaperl

[14:50] <wolverian> in perl6?

[14:51] <autrijus> oh, you mean we bind Exp as a perl6 structure?

[14:51] <Alias_> shapr: No... I'll show you

[14:51] <autrijus> sure, I can do that if you want

[14:51] <wolverian> that's what I assume larry wants to do

[14:51] <wolverian> it's also the only way I can see this will work

[14:51] <shapr> Alias_: you want the type sig part up with add, and the two lines of partial app down with partial app itself?

[14:51] <wolverian> but I don't know anything really. 

[14:51] <autrijus> sure, but that's the semantics

[14:51] <autrijus> I also need the syntax.

[14:51] <Alias_> shapr: Editing it now...

[14:51] <wolverian> yes. that's what I can't provide. :)

[14:52] <autrijus> yeah :)

[14:52] <jabbot> pugs - 1558 - This test reads its own source;  this be

[14:52] <theorbtwo> Hm, what syntax do you need that's not in the subs Apoc?

[14:52] <ninereasons> autrijus, I still get a seg fault in pugs-i, when I say '?'  or ':r'  -- well known?

[14:52] <wolverian> hmm, isn't the parse tree just a match object as returned by rules?

[14:53] <autrijus> theorbtwo: how "is parsed" works; also I need a definition for if/elsif/else.

[14:53] <wolverian> I would implement if/elsif/else as macros as well

[14:53] <wolverian> but that needs the former.

[14:54] <autrijus> wolverian: sure. try implementing it, assuming that the Pugs AST in AST.hs (Exp) is the object :)

[14:54] <Alias_> shapr: Done

[14:54] <wolverian> autrijus: hmm. :)

[14:54] <autrijus> I tried and failed to come up with anythiing

[14:54] <autrijus> but I didn't give it much effort

[14:55] <autrijus> note to test/example writers: if you want to read from the source file itself, do not use hardcoded pathname

[14:55] <autrijus> my $fh = open $*PROGRAM_NAME;

[14:55] <autrijus> # that's the way to go

[14:55] <autrijus> thanks to Gruber for catching it

[14:55] <wolverian> I really don't have a clue how to do this

[14:55] <autrijus> yeah. but it's the thing that prevents pugs from fully bootstrapping.

[14:56] <autrijus> fortunately we still has lots of things to do before that.

[14:56] <wolverian> we just need the design team to call in with the macro stuff 

[14:56] * autrijus checks for design team presence here

[14:56] <autrijus> chip? obra? :D

[14:56] <theorbtwo> Hm, L<A06/" is parsed( <rule> )"> looks to have enough information to get started, I think...

[14:57] <Gruber> autrijus: ah, even better!

[14:57] * theorbtwo pokes chip on #parrot.

[14:57] <autrijus> theorbtwo: you want to help? :)

[14:57] <autrijus> the [Update:] that begins with

[14:57] <autrijus> "The default parse rule probably turns out to be dependent "

[14:58] <theorbtwo> OTOH, the bit spec'd there isn't enough to create non-prefix macros.

[14:58] <autrijus> is vague enough that I can't get nontrivial macros to work, let alone the entire Syn category.

[14:58] <autrijus> Syn here being "special forms" that Pugs currently use for macros.

[14:58] <theorbtwo> spre, you mean?

[14:59] <autrijus> no, Syn

[14:59] <autrijus> see Eval.hs

[14:59] <autrijus> Syn "if"

[14:59] <autrijus> Syn "given"

[14:59] <autrijus> etc.

[14:59] <Alias_> ew... type stuff bogs me down a bit

[14:59] <autrijus> Alias_: quick, when you see type, think class :)

[14:59] <autrijus> and when you see class, think roles

[15:00] <wolverian> we need the match object interface, I guess

[15:00] <Alias_> What amazes me the most is that you can make ANYTHING defined in these sorts of terms run on a processor, let alone run fast

[15:00] <wolverian> if we want to be able to modify what has been already parsed 

[15:00] <autrijus> wolverian: write tests :)

[15:00] <wolverian> (postfix macros need this, I think)

[15:00] <wolverian> autrijus: I don't know what the interface should look like.

[15:01] <theorbtwo> We need that anyway, as the sub half of the macro needs to get passed the results of the is parsed half of the macro.

[15:01] <autrijus> read up and improvise? post to p6l?

[15:01] <Alias_> shapr: I think the concept "type" needs to be introduced earlier

[15:01] <wolverian> good point, theorbtwo 

[15:01] <Alias_> shapr: Give me a sec...

[15:01] <Alias_> I'll edit 

[15:01] <wolverian> autrijus: very well.

[15:01] <wolverian> (post to p6l)

[15:02] <jabbot> pugs - 1559 - * do not hard code filename

[15:03] <wolverian> do we need anything else besides the match object?

[15:04] <wolverian> reading S05.

[15:04] <theorbtwo> Perhaps the is parsed half should start where the keywork was seen, as specced outside of the square brackets, and $_ should be the match object of the thus-far bit?

[15:04] * theorbtwo checks the S06.

[15:04] * castaway attempts to persuade gentoo to emerge ghc 6.4, and fails - any ideas?

[15:05] <theorbtwo> Fails how?

[15:06] <castaway> it insists on giving me 6.2.2 even tho I set the ~x86 keyword

[15:06] <gaal> by the way:

[15:06] <gaal> find t -name \*.t | xargs wc -l  -> 14174 total

[15:06] <gaal> find src -name \*.hs | xargs wc -l -> 10321 total

[15:06] <autrijus> nice.

[15:09] <shapr> Poo, $work calls. Nay, it screams.

[15:09] <castaway> Oh.. it has a ghc 6.4 but not a ghc-bin 6.4 ebuild (whatever the difference may be, the first depends upon the second for something)

[15:09] * castaway syncs and crosses her fingers

[15:09] * shapr takes the fun out of work with a defun

[15:10] <PerlJam> shapr: that's always been a problem with LISP-like languages ;)

[15:10] <wolverian> I just can't figure out what the parse tree would look like

[15:11] <Alias_> autrijus: type Name = String 

[15:11] <Alias_> just equivalent, or more like transparent subclass?

[15:11] <shapr> equivalent

[15:11] <Alias_> shapr: Check out the page now

[15:12] <Alias_> You needed to introduce types a bit earlier, when I was more receptive

[15:12] <castaway> no gentoo users in here?

[15:12] <jabbot> pugs - 1561 - Added tests for pi(), sin(), cos(), tan(

[15:12] <jabbot> pugs - 1560 - Implemented tan. (Well, I had to add two

[15:12] <Alias_> I completely skipped over that initial comment about types, because I saw the shiny C<   something = 1   >

[15:12] <shapr> Alias_: oh, I like that.

[15:13] <shapr> I'd say what we *could* have written.

[15:13] <Alias_> Very important to introduce ideas one at a time and fully explore each :)

[15:13] <shapr> yeah, I agree.

[15:14] <shapr> For the most part, you don't need type signatures.

[15:14] <Alias_> which was the bit of what you wrote I kept

[15:14] * castaway blinks cos the partial stuff on shapr's page now makes sense :)

[15:14] <Alias_> But it read as "don't need type signature... huh? don't need them for what?"

[15:14] <Alias_> Since I hadn't even seen something = 1 yet

[15:15] <shapr> oh I see

[15:15] <wolverian> hmm, what primitives can a 'if' macro use? :)

[15:15] <metaperl> hi shapr... on my way to the store and then work... cya in 45mins

[15:15] <shapr> ok

[15:15] <shapr> I'll be working in a few minutes, cya tomorra

[15:16] <castaway> later shapr 

[15:16] <shapr> I really like the way autrijus unified all the other type and function understanding with GADTs in the Person type

[15:16] <shapr> I'll add that in a moment of work frustration.

[15:16] <autrijus> :)

[15:16] <Alias_> shapr: You skip from C< data Temp = Cold | Hot > to Show too quickly

[15:16] <autrijus> GADTs is da way of da future

[15:16] <shapr> Alias_: I appreciate your help on HaskellDemo, and hope you find more to clarify :-)

[15:16] <shapr> autrijus: truly, but I had not yet noticed.

[15:17] <Alias_> shapr: Happy to help as I go

[15:17] <shapr> right, I'll be back later

[15:17] <theorbtwo> Hm, from L<A6/Macros>, we've got more then I thought...

[15:17] <iblech> castaway: ghc 6.4 is masked in /usr/portage/profiles/package.mask

[15:18] <castaway> hmm, I cant unmask it in /etc/portage/package.keywords?

[15:18] <castaway> (cant check now, emerge sync is running)

[15:19] <Alias_> autrijus: Damn this is amazing dense stuff... cool, but oh so nastily dense

[15:20] <Alias_> even the basic demo

[15:21] <iblech> castaway: Dunno about portage.keywords.  ghc-bin is mostly precompiled (took 25min to install), ghc is not (took 2h40min)

[15:21] <castaway> package.keywords

[15:21] <ninereasons> ghc-bin must surely be the bootstrap binary?

[15:21] <iblech> right, typo

[15:21] <castaway> presumably

[15:22] <ninereasons> I wonder why the package would require ghc-bin if ghc is already installed?

[15:22] <castaway> It isnt

[15:22] <ninereasons> ah - 

[15:22] <chip> yo!

[15:23] <autrijus> Alias_: it just require you to newfs your brain a bit

[15:23] <theorbtwo> Yo, chip.

[15:23] <autrijus> try find some more unused partition in it -- I hear the fs is 90% unallocated

[15:23] <iblech> ninereasons: ghc requires virtual/ghc, and both ghc and ghc-bin provide virtual/ghc. Now you first need ghc-bin, and then ghc can get compiled. Afterwards, you can unmerge ghc-bin

[15:23] <castaway> ah, sneaky :)

[15:23] <Alias_> autrijus: I've yet to see anything particularly new... it's just packed into with a high degree of Huffman optimisation

[15:23] <theorbtwo> You guys need to design macros.

[15:24] <autrijus> Alias_: wait till you see monads :)

[15:24] <chip> I wish to understand why PIR should have macros.  That's what HLLs are for.

[15:24] * castaway drums fingers..

[15:24] <theorbtwo> I was using "you guys" in a rather large sense.

[15:24] <Alias_> autirjus: As I said earlier, I have a bad habit of independantly discovering things, only to find out later they have names :)

[15:24] <autrijus> Alias_: MJD said to me that in his Higher Order Perl, the more advanced things are, the more penalty perl5 gives

[15:24] <theorbtwo> IE the p6 cabal.

[15:24] <castaway> Alias_: yeah, sucks dont it :)

[15:24] <autrijus> Alias_: and he could not do monads in p5 reasonably anymore

[15:24] <autrijus> so monads are not in HOP.

[15:25] <autrijus> (not to mention arrows or functors)

[15:25] <Alias_> autrijus: Hell, partial evaluation itself is a bitch in Perl

[15:25] <autrijus> Alias_: true, but it's just verbose

[15:25] <theorbtwo> autrijus: Doesn't that mean that the hufmanization is right?  More advanced things should be harder.

[15:25] <castaway> not really, you just wrap a subref around

[15:25] <autrijus> and linearly verbose at that

[15:25] <autrijus> theorbtwo: sadly, the advanced things are also common things.

[15:25] <Alias_> autrijus: I wanted to use PPI to find things like $0 eq 'Win32' and convert them into a constant so that the perl tree-pruner would optimise it

[15:25] <theorbtwo> What?  I just implemented partial application in less then 128 characters...

[15:26] <autrijus> theorbtwo: huffmanization uses that "uncommon" things needs to be long.

[15:26] * Alias_ probably uses the wrong magic var

[15:26] <autrijus> theorbtwo: however, programmers uses recursion etc all the time.

[15:26] <Alias_> There's way too much OS-specific testing code that isn't compiled away

[15:26] <autrijus> or reduce, or schwartzian transform

[15:26] <chip> I was being paged?

[15:26] <theorbtwo> Alias, $^O.

[15:26] <chip> Was the macro question the reason?

[15:26] <Alias_> theorbtwo, right

[15:27] <theorbtwo> Aye, chip.

[15:27] <autrijus> Alias_: use constant IsWin32 => ($^O eq 'MSWin32')

[15:27] <autrijus> like that?

[15:27] <Alias_> autrijus: exactly, but you'd be amazed how much core module don't do that

[15:27] <autrijus> $^O lookup is cheap anyway

[15:27] <autrijus> unless you are inside a real tight loop

[15:27] <Alias_> And there any many cases of such

[15:27] <chip> Hm.  My part of macros will probably be the AST, but I'm weeks away from being able to work on that.

[15:28] <Alias_> $^O reduntantly checking OZ millions of times

[15:28] <autrijus> chip: let me know when you're able :)

[15:28] <Alias_> OS

[15:28] <chip> autrijus: you'll be the 2nd to know :)

[15:28] <autrijus> that is, of course, that you actually need that millions of times :)

[15:28] * autrijus raises the benchmark flag

[15:28] <Alias_> yeah

[15:29] <Alias_> in any case, I've been thinking about some form of Const module

[15:29] <Alias_> which just defines the 100 most common useful-as-constant things

[15:29] * castaway looks at the clock

[15:29] <theorbtwo> Hm, I wouldn't think it'd be a horribly difficult thing to make the p5 constant folder aware that $^O is a constant.

[15:30] <Alias_> theorbtwo: I'm not sure it can fold the equality though

[15:30] <cognominal> what is the meaning of "use v6"  in pugs programs? Does pug intend to support perl5 with "use v5"?

[15:30] <theorbtwo> Yeah, folding equality is easy.

[15:30] <Alias_> autrijus: Does it only fold plain booleans?

[15:30] <autrijus> Alias_: it can.

[15:30] <autrijus> [not|autrijus]~$ perl -MO=Deparse -e '1 eq 1'

[15:30] <autrijus> '???';

[15:30] <autrijus> there you go.

[15:30] <Alias_> hmm..

[15:30] <Alias_> let me check something

[15:30] <theorbtwo> perl -MO=Deparse,-p -e '"x" eq "x" and print "Yep!"'

[15:31] <theorbtwo>  perl -MO=Deparse,-p -e '"x" eq "y" and print "Yep!"'

[15:31] <theorbtwo> autrijus, you can't actually tell in that context; it could have been optimizing that away as don't-care.

[15:31] <cognominal> and why "use v6" and "require Test"; why not "use Test" as well?

[15:32] <theorbtwo> Because 'use' is only implemented for use-version.

[15:32] <autrijus> right.

[15:32] <cognominal> can you elaborate?

[15:32] <cognominal> ok, I got it

[15:32] <theorbtwo> use Test isn't implemented, only use v6.

[15:33] <Alias_> in any case... there's quite a bit of code that would benefit from $^O being read-only and constant

[15:33] * theorbtwo wonders if he should get in the habit of writing "use 5;" at the top of his p5 scripts.

[15:34] <Alias_> Perl would most certainly get faster for many things

[15:34] <Alias_> and have a lower overhead

[15:34] <rgs> theorbtwo: no, but maybe "no 6" if I get this implemented :)

[15:34] * theorbtwo finds with some amazement that $^O isn't already read-only.

[15:34] <cognominal> ho boy,  this is good to read Perl6 code. /me reading Test.pm

[15:35] <Alias_> theorgtwo: Which is what worries me a little... if it's writable, there may well be a reason

[15:35] <theorbtwo> The concept scares me.

[15:35] <Alias_> theorbtwo: Giving you enough rope, and all that

[15:35] * castaway wanders off home

[15:35] <theorbtwo> Since setting $^O to 'MSWin32' does not cause my machine to reboot, I'd say it's a bug.

[15:35] <rgs> $^O being writable is a feature, iirc

[15:36] <Alias_> theorbtwo: Use File::Find::PPI and see if anything in CPAN actually modifies it

[15:36] <theorbtwo> Sounds like work.  I'll let the pumpking handle that.

[15:36] <theorbtwo> I just suggest ideas.

[15:37] <iblech> cognominal: You might also want to read some ports of Perl 5 modules to Perl 6 on http://freepan.org/

[15:37] <pjcj> Windows builds from way back used to claim they were Irix, so setting $^O was very useful then.  It's also handy for testing purposes.

[15:37] <Alias_> Anyways, I'm stuck at data Temp = Cold | Hot

[15:37] <Alias_> I'll leave it till next time

[15:37] <theorbtwo> Alias, that says that there is a data type named Temp, and that there are two functions that construct it, Cold and Hot.

[15:37] <chip> And you can tell which function constructed it.

[15:38] <Alias_> So what does type Foo = Bar say?

[15:38] <autrijus> type Foo = Bar says that Foo is a synonym to Bar.

[15:38] <autrijus> "data" vs "type"

[15:38] <Alias_> wait a sec, Cold and Hot are functions?

[15:38] <autrijus> they are constructor functions.

[15:38] <Alias_> Why use an uppercase name?

[15:38] <autrijus> because they are not user-defined functions.

[15:38] <autrijus> and also, because they can be pattern-matched.

[15:39] <Alias_> I really need to see what how you actually USE data Temp = Hot | Cold, before continuing

[15:39] <autrijus> sure.

[15:39] <autrijus> data Temp = Cold | Hot

[15:39] <autrijus> mix Cold Hot = "nice and warm"

[15:39] <autrijus> mix Hot Hot = "boiling, man"

[15:39] <Alias_> aaaah!

[15:39] <autrijus> mix _ _ = "they do not mix"

[15:39] * Alias_ screams

[15:39] <Alias_> my head!

[15:40] <autrijus> mix :: Temp -> Temp -> String

[15:40] <cognominal> autrijus, I will write in a French mag about pugs in a few month. Can you tell me why you crated #perl6 on freenode? Is the idea similar to Larry infecting shell related newgroup with perl posts?

[15:40] <Alias_> still explodey

[15:40] <autrijus> cognominal: uh, yes, I think.

[15:41] <Alias_> More examples needed for basic data Temp in use

[15:41] <autrijus> ok... try this

[15:41] <cognominal> autrijus: thx

[15:41] <Alias_> Tell, See, Do

[15:41] <autrijus> fromCelsius :: Int -> Temp

[15:41] <autrijus> fromCelsius n | n > 30 = Hot

[15:41] <autrijus> fromCelsius _ = Cold

[15:41] <Alias_> Medicine has taught using "Hear it, See it, Do it" forever

[15:42] <autrijus> or, written less fancily

[15:42] <Alias_> So Hot is something like a constructor/constant?

[15:42] <autrijus> fromCelsius n = if n > 30 then Hot else Cold

[15:42] <autrijus> yes. it is a constructor, and a constant.

[15:42] <Alias_> That's the bit missing from the examples

[15:42] <autrijus> it has the type

[15:42] <autrijus> Hot :: Temp

[15:43] <Alias_> Need it to communicate that "Temp is one of two values"

[15:43] <autrijus> actually in GHC 6.4 and above you can say exactly that.

[15:43] <autrijus> data Temp where

[15:43] <autrijus>     Hot :: Temp

[15:43] <autrijus>     Cold :: Temp

[15:43] <autrijus> which is crystal clear.

[15:43] <chip> why would you want to?

[15:43] <autrijus> want to say that?

[15:43] <autrijus> or want to use that notation?

[15:44] <autrijus> it reads more clear :)

[15:44] <chip> why be able to say "::Foo" when it's redundant?

[15:44] <chip> why add the grammar for it?

[15:44] <autrijus> but more importantly, because that notation lets you say things like:

[15:44] <theorbtwo> Oooh, that syntax is far more clear then the other ways you said it earlier.

[15:44] <autrijus> data Term a where

[15:44] <autrijus>     TrueT :: Term Bool

[15:44] <autrijus>     ZeroT :: Term Int

[15:45] <autrijus> which Cannot Be Done using the old notation.

[15:45] <Alias_> autrijus: Time for me to head home. I'll take up this whole demo thing another time

[15:45] <autrijus> Alias_: sure :)

[15:45] <autrijus> http://autrijus.org/tmp/old.hs # old, error-prone, impossible to reason about notation

[15:45] <Alias_> But it's no wonder nobody codes commercially in Haskell :)

[15:46] <autrijus> http://autrijus.org/tmp/gadt.hs # new, guaranteed correct notation

[15:46] <Alias_> Only technical wizards in places nobody else gets to look

[15:46] <Alias_> :)

[15:46] <autrijus> Alias_: eh, I do :)

[15:46] <Alias_> I could never tech this crap to my LUG'mates

[15:46] <Alias_> It's the sort of language that has a minimum IQ of 120

[15:46] <ninereasons> I have a friend who programs ATMs and Mil crypto in Haskell

[15:46] <Alias_> Or you spend a year learning

[15:46] * autrijus notes that Java people say that that about Perl too.

[15:47] <Alias_> autrijus: Perl is just twisty.. there's nothing there that's particularly twisty

[15:47] <Alias_> errr

[15:47] <Alias_> hard

[15:47] <autrijus> ah that's because you have learned it :)

[15:47] <Alias_> regex maybe

[15:47] <Alias_> regular expressions were the only true "hard" thing, from memory

[15:47] <chip> autrijus: you could do that with named fields in records, I think, but it would be uglier

[15:48] <autrijus> chip: you can't typecheck the named fields.

[15:48] <autrijus> chip: which is the whole point :)

[15:48] <Alias_> And the initial translation from functions to OO

[15:48] <Odin-> autrijus: Nah. There's different types of people. There's java people, there's perl people, there's haskell people, there's lisp people... ;)

[15:48] <Alias_> Which just required "Collections of data that know where their functions are without you having to tell them"

[15:49] <autrijus> chip: using the old notation you can write nonsensical things like "Succ TrueT"

[15:49] <Alias_> But regex and pattern'stuff was a very different concept

[15:49] * Alias_ &

[15:49] <autrijus> i.e. "bool::true++"

[15:49] <Alias_> night

[15:49] <chip> autrijus: named fields have types, though.

[15:49] <chip> <- confused

[15:49] <autrijus> chip: and they are all of the same type.

[15:49] <autrijus> chip: the point of GADTs is allow each term to carry different type.

[15:50] <chip> I think I see

[15:50] <autrijus> the example:

[15:50] <autrijus> data Term a where

[15:50] <autrijus>     TrueT :: Term Bool

[15:50] <autrijus>     ZeroT :: Term Int

[15:50] <autrijus> cannot be rewritten using records

[15:50] <autrijus> data Term

[15:50] <autrijus>     = TrueT { typeOfTerm :: Bool }

[15:50] <autrijus>     | ZeroT { typeOfTerm :: Int }

[15:50] <autrijus> is invalid.

[15:51] <autrijus> because all field selectors of the same name needs to have same type.

[15:51] <autrijus> and that did not let you write

[15:51] <chip> I see

[15:51] <autrijus> eval :: Term a -> a

[15:51] <chip> Is this new syntax standard or just ghc-author-fu?

[15:51] <autrijus> this new syntax is shiny new and specific to ghc.

[15:52] <ninereasons> it won't work in hugs?

[15:52] <autrijus> pugs's symbol table type "Pad" and "Symbol" has just been converted to GADT.

[15:52] <autrijus> ninereasons: not today. eventually in the future

[15:53] <autrijus> converting them to GADT has raised some subtle bugs :)

[15:53] <autrijus> I expect more bugs to be uncovered after we go all the way to GADTs.

[15:55] <autrijus> mm 46 revs today.

[15:55] * autrijus journaling

[15:56] <autrijus> chip: oh. the point of GADTs is that there is no need to write a "context propagator".

[15:56] <autrijus> remember how hard it was in perl5? or in languages/perl6/ (P6C in parrot)?

[15:57] <autrijus> GADTs makes them all _obsolete_ :)

[15:57] <chip> neat

[15:57] * chip fixed a bug in Devel::Profile WRT contexts

[15:58] <autrijus> cool

[15:58] * autrijus tries out the new ebug

[15:58] <ninereasons>  ebug is very slow, but what a concept!

[15:58] <theorbtwo> ebug?

[15:59] <ninereasons> a new cpan debugger maker

[15:59] <autrijus> theorbtwo: http://search.cpan.org/dist/Devel-ebug/

[15:59] <autrijus> one of the fruits generated from YAPC::Taipei hackathon

[16:00] <autrijus> fueled by bad ideas from lots of people, including yours truly :)

[16:00] <Alias_> still impressed with it being a web front end

[16:00] * Alias_ leaves really this time

[16:00] <Alias_> :)

[16:03] <chip> autrijus: now I know I must use ghc 6.4 despite Debian slowness to upgrade, thank you

[16:03] <theorbtwo> chip: it's in experimental.

[16:04] <chip> theorbtwo: but trying to install it uninstalls some of the ghc-dependent libraries, whcih means I have to rebuild them myself

[16:04] <theorbtwo> Ah.

[16:04] <chip> theorbtwo: but now I know that's worth the trouble

[16:06] <chip> ebug++ # autrijus is a hub of innovation

[16:06] <chip> oh wait, Leon wrote it.  leon++

[16:07] <autrijus> acme++

[16:08] <PerlJam> chip: still acme had to rub up against autrijus for it to happen  ;)

[16:08] <autrijus> and obra. and beer. :)

[16:08] <autrijus> beer being perhaps the most imporatnt.

[16:08] <PerlJam> chip: go hang out with those guys.  The productivity seems infectous!

[16:09] <ninereasons> I don't really understand String-Koremutake

[16:11] <ninereasons> what does ebug use it for?

[16:11] <ninereasons> use it to do? that is

[16:12] <jabbot> pugs - 1562 - Added todo tests for the delete builtin.

[16:12] <chip> PerlJam: I'm here, aren't I?  :-P

[16:12] <theorbtwo> Hmm, what's the syntax at the top of Eval.hs's reduce: reduce env@Env{ envContext = cxt } exp@(Syn name exps) = case name of...

[16:12] <theorbtwo> What's with the @s?

[16:13] <PerlJam> chip: you might need physical contact to catch the disease

[16:14] <ninereasons>  perl -MString::Koremutake -le 'my $k = String::Koremutake->new(); my $s = $k->integer_to_koremutake(123456789); print $s;' # nugrohigo

[16:14] <PerlJam> theorbtwo: I forget what it's called but that's a syntax to make a name that is the whole of the parts.

[16:14] <autrijus> theorbtwo: what PerlJam said

[16:14] <autrijus> fun arg@(x:xs) = ...

[16:15] <autrijus> here x is head arg

[16:15] <autrijus> and xs is tail arg

[16:16] <cognominal> autrijus: what is the GADT ,entionned in your journal?

[16:18] <autrijus> cognominal: see the log above :D

[16:18] <autrijus> also compare http://autrijus.org/tmp/old.hs with http://autrijus.org/tmp/gadt.hs

[16:19] <ninereasons> i see ... a way to keep secrets

[16:20] <PerlJam> secrets?

[16:20] <PerlJam> It looks more like a way to eliminate "useless" code :-)

[16:20] <cognominal> stands, for Glasgow Abstract Data Tree?

[16:21] <ninereasons> sorry PerlJam, I'm OT

[16:21] <ninereasons> talking to myself

[16:21] <chip> I wonder when autrijus will be visiting $Continent::NA

[16:21] <autrijus> chip: YAPC::NA

[16:21] <autrijus> cognominal: Generalised Algebraic Data Types

[16:22] <jabbot> pugs - 1563 - removed 2 globals (kind of) and further 

[16:25] <chip> autrijus: Marvelous!

[16:25] * chip will be there too

[16:25] <autrijus> arrive 4 days earlier for our hackathon?

[16:26] <autrijus> http://www.nntp.perl.org/group/perl.perl6.compiler/487

[16:27] <crysflame> "and of course, a lake to put them in"

[16:28] <chip> autrijus: I think I cannot resist.  The pull is too strong!

[16:28] <autrijus> yay!

[16:28] <autrijus> chip++

[16:31] <stevan> oooh hackathon for YAPC::NA

[16:32] <stevan> but wait,.. wont we be finished by then ;)

[16:32] <jabbot> pugs - 1564 - Added tests for pairs and exists on arra

[16:33] <autrijus> stevan: no way ;)

[16:37] <stevan> autrijus: should I consider AoH and AoP(airs) as todo or not todo?

[16:41] <autrijus> I don't know. I think not todo

[16:41] <stevan> ok

[16:42] <jabbot> pugs - 1565 - Added tests for kv, keys, and values (mo

[16:43] <Limbic_Region> autrijus - out of curiosity, how long before Apocryphon 2?

[16:44] <autrijus> Limbic_Region: 1 week I think

[16:44] <autrijus> now that the conf is over :D

[16:45] * autrijus kept getting drawn into coding

[16:45] <autrijus> but, sleep first :) journal up.

[16:45] <autrijus> &

[16:45] <theorbtwo> G'night.

[16:45] <Limbic_Region> Sleep well

[16:46] <stevan> iblech: are you around?

[16:46] * Limbic_Region is also wondering about huge jumps in versioning considering things in future versions (by roadmap) are already being implemented

[16:46] <iblech> stevan: Yep

[16:46] <stevan> hey

[16:47] <stevan> can we move all those delete, kv, pairs test into like a hashs_and_arrays/ folder?

[16:48] <stevan> or maybe I am being over-organized

[16:48] <iblech> Of course

[16:48] <iblech> If we don't stay organized, we'll have 100 tests in one directory soon :)

[16:48] <stevan> iblech: cool

[16:49] * stevan likes to use #perl6 as a sanity tester :)

[16:51] <iblech> done as r1568

[16:52] <stevan> iblech: thank you

[16:52] <jabbot> pugs - 1568 - Moved some builtin tests concerning both

[16:52] <jabbot> pugs - 1567 - (whoops forgot to save file before commi

[16:52] <jabbot> pugs - 1566 - some tests for mixed type multi-dimensio

[16:52] <stevan> iblech++ # for writing soooo many tests and soooo many modules in sooo short a time :)

[16:52] <Limbic_Region> perlbot karma for iblech

[16:52] <perlbot> Karma for iblech: 14

[16:52] <Limbic_Region> perlbot karma for autrijus

[16:52] <perlbot> Karma for autrijus: 60

[16:53] <iblech> thanks :)

[16:53] <stevan> perlbot highest karma

[16:53] <perlbot> The top 5 karma entries: C: 65, autrijus: 60, nothingmuch: 46, stevan: 38, ~brad2901: 29

[16:54] <stevan> I think iblech needs to knock brad2901 off the list :)

[16:54] <Limbic_Region> and C plus plus too

[16:54] <rgs> C cheats

[16:54] * iblech is writing some more tests then :)

[16:55] <nothingmuch> how the heck do i have that much karma?

[16:55] <stevan> C-- is great

[16:55] <stevan> nothingmuch++ # for humility

[16:55] <nothingmuch> nono, seriusly

[16:55] <stevan> C-- is my favorite language now

[16:55] <nothingmuch> i was lurking for 2 weeks now

[16:55] <nothingmuch> and i get ~10+, i think

[16:56] <stevan> nothingmuch: it's still left over 

[16:56] <Limbic_Region> nothingmuch, I don't believe perlbot distinguishes between channels

[16:56] <Limbic_Region> so any karma from #perl applies here

[16:56] <nothingmuch> Limbic_Region: i'm only occasionally on gentoo

[16:56] <nothingmuch> and that's it

[16:56] <stevan> perlbot karma for Limbic_Region 

[16:56] <perlbot> Karma for Limbic_Region: 1

[16:57] <stevan> Limbic_Region++ # for slogging through perlmonks, use.perl etc

[16:57] <nothingmuch> anyway, this motivates me to try and clear more time for pugs

[16:57] <nothingmuch> otherwise i'll feel like a sellout ;-)

[16:57] <Limbic_Region> stevan - I purposely keep my karma neutral, but thanks

[16:57] <Limbic_Region> Limbic_Region--

[16:58] <Limbic_Region> Limbic_Region--

[16:58] <nothingmuch> you can get the same effect by ++ yourself... much more fun

[16:58] <nothingmuch> nothingmuch++

[16:58] <perlbot> What kind of idiot karmas himself?  Your kind of idiot!

[16:58] <Limbic_Region> hmmm - those should have been in /msg's to perlbot - sorry

[16:59] * nothingmuch goes to dinner

[16:59] * castaway wonders if she can crash SEE

[17:11] <putter> filetest operators -d -f currently return bool, rather than the filename, so they dont chain.  shall i fix?

[17:11] *** stevan changes topic to: pugscode.org <<Overview Journal Logs>> | You have safely opened the door to many Perl 6 hackers. | pugs.kwiki.org | smoke: http://xrl.us/fmw2 | Mac OS X r1567 (267/3922) | Win2k r1534 (210/3779)

[17:11] <stevan> putter: yes please :)

[17:12] <rgs> do -f etc accept filehandles ?

[17:12] <rgs> or only filenames ?

[17:12] <stevan> rgs: good question

[17:12] <Limbic_Region> out of curiosity - does the chaining of -f -d -r etc re-stat the file or use the equivalent of p5's _ ?

[17:12] <putter> :)

[17:12] <stevan> Limbic_Region: good question too

[17:13] <rgs> Limbic_Region: in perl 5.9.2 this doesn't re-stat

[17:13] <stevan> hmm, who wants to post to p6l? ( I don't this is addressed in the Synopsis )

[17:13] <rgs> stevan, about the re-stating ?

[17:13] <stevan> actually rgs's question is probably for p6l and Limbic_Region's is for p6c

[17:14] <rgs> stevan, no, I remember having read that -f $filehandle is legal perl 6 in p6l

[17:14] <stevan> rgs: even better (we already know the answer)

[17:15] <Limbic_Region> the cached stat is supposed to be available per file (IIRC), my question was more a matter of does Pugs support that with chained file tests now

[17:15] <rgs> and I think that -f -r $foo shouldn't re-stat, since I remember having already asked this question while implementing it in perl 5

[17:16] <ninereasons> for <1 2 3 4> -> $_ {say $_ } # 1 3 :  odd behavior ? (unintended pun)

[17:17] <ninereasons> for <1 2 3 4> -> $a {say $a } # 1 2 3  4 : compare

[17:18] <stevan> pugs -e 'for (1, 2, 3, 4) -> $_ {say $_ }' # prints 1 3 as well

[17:18] <stevan> ninereasons: post a bug to perl6-compiler please 

[17:18] <ninereasons> yea.  it's the explicit designation of $_ as a topic that does it, I think

[17:19] <Limbic_Region> rgs - http://dev.perl.org/perl6/doc/design/apo/A03.html

[17:20] <Limbic_Region> it appears that the operators are supposed to be smart enough to return the right thing to avoid the re-stat.  If I am reading it correctly

[17:20] <rgs> niiice

[17:20] <Limbic_Region> search for "RFC 290"

[17:20] <rgs> I've seen

[17:20] <rgs> larry++

[17:21] <stevan> putter: feeling adveturous I hope :)

[17:21] <putter> Limbic_Region: currently pugs doesnt support chainging at all.  or any filetest operators other than -d and -f.  my intent is it will shortly support chaining, reflecting whatever the underlying haskell stat-ing is.  excess stat avoidance i'll leave until the filetests are more fleshed out.  i believe we will also need a filetest builtin.

[17:21] <rgs> there's chaining (-d -r -w) and grouping (-drw)

[17:22] <rgs>     $handle = open -r -w -x $file or die;

[17:22] <putter> anyone like to create a bunch of tests for t/operators/filetest.t ?

[17:23] <Limbic_Region> putter - thanks - I am an innocent bystander just watching the flow of progress (to be read as I am not involved with pugs development)

[17:23] <stevan> iblech: wanna take on putter's request?

[17:23] * stevan has to go set up servers soon 

[17:24] <putter> it's _very_ easy to create tests...  ok(-r -w 't/operators/file_test_ops.t','-r -w file works');

[17:25] <iblech> hm... such a test is a bit tricky, me thinks, because you've to create files with "unnormal" permissions, and sockets, and that

[17:25] <iblech> but as putter says, -r and -w should be simple -- will do

[17:26] <stevan> iblech++ 

[17:26] <stevan> putter++

[17:26] * stevan heads down to the server room

[17:29] <putter> iblech: i check in a revised file_test_ops.t in a moment. (hmm, that should be renamed)

[17:30] <putter> iblech: re -r -w, the p5 test file makes interesting reading.  suggest using the recent mumble OS = any<mumble> idiom as a guard.

[17:31] <gaal> shapr still around?

[17:31] <rgs> iblech: be sure to take the t/op/filetest.t from perl 5.9.2. It tests stacked operators.

[17:31] <gaal> shapr++; # http://www.haskell.org/hawiki/HaskellDemo

[17:31] <gaal> (and anyone else writing there)

[17:32] <jabbot> pugs - 1569 - * Added tests for splice.

[17:32] <iblech> rgs: Is there a online svn/cvs repo somewhere?

[17:32] <rgs> iblech: search.cpan.org ?

[17:33] <iblech> rgs: of course, thanks :)

[17:35] <iblech> brb

[17:35] <putter> anyone object to my renaming t/operators/file_test_ops.t to t/operators/file_test.t?  (it uses its own name in the file, so I might as well deal now if this seems worthwhile...)

[17:39] <gaal> putter: go for it

[17:45] <putter> its now operators/filetest.t.  ill check in a revised version in a few minutes.

[17:45] <gaal> cool

[17:50] <nothingmuch> castaway|theorbtwo: is see on woobling at port+2 working?

[17:50] * theorbtwo will check.

[17:51] <nothingmuch> anyway, i'm off to a friends to fix his TV

[17:52] <gaal> pugs should talk like this, perhaps: http://www.effect.net.au/lukastan/humour/Computing-Software/Error-Messages-Mac.txt

[17:52] <theorbtwo> G'luck.

[17:52] <jabbot> pugs - 1570 - renamed file

[17:58] <gaal> is there a technical name for the kind of structure that can contain an XML node? ie something whose content can be thought of as text; or as an array of elements; or sometimes as an ordered hash of elements

[18:00] <putter> iblech: this might help...  http://web.mit.edu/ghc/www/libraries/base/System.Directory.html

[18:00] <castaway> nope, not working nm

[18:12] <jabbot> pugs - 1571 - Added more filetest tests.

[18:19] <putter> iblech: beat me to it.  looks like you did a superset of  my changes (hmm, and nicer style too), so i'm done with filetest.t.

[18:19] <iblech> will do some cleanup and, finally, a is_rw.t now

[18:25] *** Aankh|Clone is now known as Aankhen``

[18:26] * iblech ~~ off, school tomorrow

[18:32] <jabbot> pugs - 1575 - Some organizational cleanups.

[18:32] <jabbot> pugs - 1574 - Added test for "is rw".

[18:32] <jabbot> pugs - 1573 - build fix for Eclipse, again

[18:32] <jabbot> pugs - 1572 - Added tests for stacking/cascading of fi

[19:01] <gaal> anyone with Makefile-fu up? FileSpec isn't being make'd into blib

[19:12] <jabbot> pugs - 1576 - restored some forgotten semicolons (on m

[19:35] <putter> in haskell, is there a short variable name implying it contains a bool?  eg, in scheme, "p".

[19:40] <wilx> isSomething?

[19:40] <wilx> Maybe.

[19:56] <stevan> nothingmuch: ping!

[19:59] *** crysflame is now known as krysflame

[20:01] <putter> tnx

[20:22] <Odin-LAP> )

[20:22] <Odin-LAP> Bah.

[20:27] <Corion> Oooo. Segfaults have now reached Pugs/Win2k :))

[20:27] <Corion> (segfault in operators/arith.t)

[20:27] <Corion> ... backloggin

[20:30] *** Corion changes topic to: pugscode.org <<Overview Journal Logs>> | You have safely opened the door to many Perl 6 hackers. | pugs.kwiki.org | smoke: http://xrl.us/fmw2 | Mac OS X r1567 (267/3922) | Win2k r1576 (281/4129)+1Unex

[20:40] <Corion> I've patched lots of tests to "if($?OS eq any<MSWin32 mingw cygwin>) {" where they previously used "if $?OS eq 'MSWin32'" - it might be that I broke some tests that way. Gaal - please test the msys stuff (I don't know how unixish it is)

[20:40] <Corion> ... well, I haven't committed yet, and I'm running a local MSWin32 test to verify that the number remains constant before committing :)))

[20:40] <metaperl_> what is the colon after the parenthesis doing here:

[20:40] <metaperl_> multi sub abs (: Num ?$x = $CALLER::_ ) returns Num

[20:49] <nothingmuch> theorbtwo|castaway: retry see://woobling.org:6944

[20:50] <Corion> Ooo - you got the SEE decoding going ? I need to hook Zaphod up with that :))

[20:50] <gaal> Whoops, Corion, wasn't really here (and going to bed soon)

[20:51] <Corion> gaal: np - I'm going to bed as well - I just wanted to tell everybody that I changed stuff so there is no frantic search in the code when just the tests broke :)

[20:51] <gaal> go ahead and commit whenever you want, i'll test it in the morning (or, well, whoever uses msys other than myself)

[20:51] <gaal> :)

[20:51] <Corion> Pugs porn was updated at http://datenzoo.de/pugs/win2k.html

[20:51] <Corion> gaal: Ah well - Perl6 should aim for as many platforms as Perl5 already sits on!

[20:52] <jabbot> pugs - 1577 - $?OS eq 'MSWin32' => if($?OS eq any<MSWi

[20:52] <gaal> if it works, it'd be a good idea to scan the whole tree for MSWin32 and judiciously apply that idiom

[20:52] <gaal> corion, sure.

[20:52] <Corion> gaal: I did just that :)

[20:53] <Corion> re :)

[20:53] <Corion> I did just that, grep for MSWin32 and then after a quick code scan replaced the code with the junction

[20:54] <Corion> ... so I might have broken some tests for the platforms that are more unixish

[20:54] <gaal> including outisde t/ that is - though of course, not everywhere.

[20:55] <Corion> gaal: Oh, yes!

[20:55] <Corion> Aaah - the one unexpected TODO is autrijus fixing "last()" to become "last" - I'll promote that test from TODO to real

[20:55] <Corion> HTML test viewer++

[20:57] <gaal> Corion, consider doing the catalog thingie too so they become cross-referenced

[20:57] <Corion> Hmmm. autrijus promised that I was writing a real HTTP proxy, instead of the fakey proxy I've been using to simulate my testing environment. Maybe I should port HTTP::Proxy :)

[20:57] <Corion> gaal: "catalog thingie" ?

[20:58] <gaal> http://nothingmuch.woobling.org/pugs_test_status/ and click on a test

[21:00] <gaal> created with catalog_tests.jmm.pl

[21:00] <gaal> i'm off to sleep now -- see you later!

[21:00] <Corion> Ah, cute! Yeah, I should find out how to do that, and do it as well :) Ah, like that. I'll put that into my smoking batch too.

[21:00] <Corion> good night

[21:01] * gaal zzzz

[21:02] <jabbot> pugs - 1578 - Promoted TODO test for 'last;' to real t

[21:25] <Corion> Gah. The second I decide to look at a port of HTTP::Proxy, BooK releases a new version with more features :))

[21:25] <Corion> (But HTTP::Proxy might actually work without fudging under Win32 if ported to Pugs)

[21:32] <Corion> & # zZzzzzZzzz

[21:42] *** krysflame is now known as crysflame

[21:54] <crysflame> oo, neat

[21:54] <crysflame> Corion: nice :)

[22:07] <putter> ok, -r -w -x -e are in.  sort of.  and they chain.  but they do multiple stat()s.  we have to figure out how we are going to portablably do stat().  wonder what p5 does...?

[22:12] <jabbot> pugs - 1579 - added more filetest operators, and they 

[22:17] <rgs> putter: it's awful

[22:17] <rgs> putter: see the filetest pragma for example

[22:17] <rgs> need to handle acls etc...

[22:17] <rgs> in my opinion this will be deferred to parrot at some point

[22:17] <rgs> ask chip about that

[22:20] <putter> blech.  what a zoo.

[22:21] <putter> my fuzzy impression is darcs uses a fake posix to get windows support.  perhaps we might snarf it...

[22:39] <putter> rgs: some of the filetests (eg, -s ) probably cant be deferred to parrot, unfortunately.

[22:41] <putter> darcs approach: http://abridgegame.org/cgi-bin/darcs.cgi/darcs/win32/System/Posix.hs?c=annotate

[22:49] <Limbic_Region> not sure if autrijus still plays catch up with the log, but http://www.perlmonks.org/?node_id=445097 is a nice reply in the thread I pointed out earlier showing the impressiveness of Pugs

[22:54] <putter> Limbic_Region: :)

[22:58] <putter> it looks like pugs on non-posix systems already sheds functionality (eg, sleep)...

[23:02] <jabbot> pugs - 1580 - fixed golf.t typo

