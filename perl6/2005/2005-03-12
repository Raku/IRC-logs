[00:16] <theorbtwo> &

[00:30] <dan2> where can I get a copy of the perl6 distribution

[00:31] <safrican> well its not yet fully completed

[00:31] <safrican> but i think Perl6::Bundle

[00:31] <dan2> and pugs?

[00:31] <safrican> or Bundle::Perl6 should be good enough

[00:34] <Steve_p> There is no Perl 6 yet

[00:34] <Steve_p> pugs is an initial implementation of Perl 6 

[00:36] <Limbic_Region> dan2 - to explain a bit further Perl6::Bundle is Perl5 that looks/feels like Perl6

[00:36] <Limbic_Region> Pugs is an implementation of Perl6 in Haskell, but is as of yet uncomplete

[00:37] <Limbic_Region> but given that Perl6 is still not fully spec'd, it is simply amazing

[00:38] <safrican> Perl6::Bundle is what I use

[02:46] <safrican> :P

[02:46] <safrican> sorry

[02:47] <safrican> my irssi got messed up

[03:40] <ingy> hola all

[03:57] <Steve_p> Hey ingy

[03:58] <ingy> hi Steve_p 

[05:25] *** mandarin is now known as Qiang

[06:55] <gugod> hi perl6, I let my bot report the rss headlines of pugs

[06:57] *** wilx` is now known as wilx

[07:29] <autrijus> \camels -> greetings

[07:30] <autrijus> http://www.perlmonks.org/index.pl?node_id=438876 made my day :)

[07:30] * autrijus ponders golf-driven development

[07:41] <autrijus> lunch &

[07:45] <rgs> heh

[07:45] <rgs> when perl 6 attracts golfers, you know the advocacy case is being won.

[07:56] <b6s> http://web.media.mit.edu/~hugo/publications/papers/IUI2005-metafor.pdf #visualizing stories as code

[08:00] <Khisanth> hrm something odd seems to be going on with Perl6::Pugs metadata

[08:55] <autrijus> back

[08:55] <autrijus> Khisanth: mm?

[08:58] <autrijus> lwall++ # detailed response

[08:58] <autrijus> I wish I had access to that info when I started writing Parser.hs ;)

[08:58] <autrijus> (p6c)

[09:40] <autrijus> down to 1 test file failing.

[09:40] * autrijus fixing that

[09:40] * Aankhen`` cheers for autrijus.

[09:41] <autrijus> =)

[09:41] <autrijus> 6.0.11 looks in pretty good shape!

[09:47] <autrijus> the mad Andrew Savige is now a committer!

[09:48] * autrijus praises golf-driven development

[10:13] <autrijus> ||= etc works.

[10:14] <theorbtwo> Yey!

[10:14] <autrijus> now I wonder if all infix symbol op automatically has a "=" form.

[10:14] <theorbtwo> I was looking into that last night.

[10:14] <autrijus> or if they are hard coded.

[10:14] <theorbtwo> Well, they only make sense for a -> a -> a ops.

[10:14] <autrijus> sure.

[10:14] <autrijus> theorbtwo: the trick in the lexer, add | into the ahead

[10:15] <autrijus> (line 90)

[10:15] <autrijus> and in Eval's Syn category add:

[10:15] <autrijus>     syn | last syn == '=' -> do

[10:15] <autrijus>         let [lhs, exp] = exps

[10:15] <autrijus>             op = "&infix:" ++ init syn

[10:15] <autrijus>         evalExp (Syn "=" [lhs, App op [lhs, exp] []])

[10:15] <autrijus> that's all.

[10:15] <theorbtwo> Aaah!

[10:15] <autrijus> it says basically: "when you see X xx= Y, translate it into X = X xx Y"

[10:15] <theorbtwo> I didn't really think of cheating like that.

[10:15] <autrijus> cheating is of course the best.

[10:18] <theorbtwo> Anyway, not all binary ops make sense with an assignment form.

[10:18] <theorbtwo> ==, the assignment form of =, for example.

[10:19] <autrijus> right. but it's already in the table

[10:19] <autrijus> so that's okay

[10:19] <theorbtwo> And $x =:== $y, which sets $x to true if $x and $y are bound to the same thing.

[10:19] <autrijus> i.e. we can set it up so it won't shadow existing stuff.

[10:19] <theorbtwo> Of course, something being nonsensical has never stopped perl from doing it before.

[10:19] <autrijus> true.

[10:20] <theorbtwo> Oh, along the same lines: Is @foo.=sort; parsed?

[10:20] <theorbtwo> (Equiv @foo = @foo.sort.)

[10:20] <autrijus> don't think so.

[10:20] <autrijus> let me try

[10:20] <autrijus> $foo .= 1..10;

[10:21] <autrijus> what does this mean?

[10:21] <theorbtwo> Well, that'd mean the same as $foo.(1..10) -- which AFAIK is meaningless.

[10:21] <theorbtwo> Or possibly it stringifies the list, and tries to find that as a method of $foo.

[10:21] <autrijus> "meaningless" ne good enough :)

[10:21] <autrijus> write a test for .= for me?

[10:22] <theorbtwo> Hmm, that means I need to find a reference on it.

[10:22] <theorbtwo> Do you know an easy way to download all the Apoc, Syn, and Exg?

[10:22] <theorbtwo> Why is Synopsis under t and not doc or docs?

[10:22] <theorbtwo> And for that matter, why do we have both doc and docs?

[10:23] <autrijus> $foo .= bar(3); # what does this mean, hmm?

[10:23] <autrijus> theorbtwo: I don't know, ask ingy. I think it should all be docs.

[10:23] <autrijus> but he apparently disagrees for some reason, can't remember.

[10:23] <theorbtwo> $foo = $foo.bar(3);

[10:24] <theorbtwo> Hmm, making the <op>= parser not allow shadowing would allow for us to implement ||= directly for better performance.

[10:25] <autrijus> performance not a top concern for me

[10:26] <autrijus> and how will it help again?

[10:26] <theorbtwo> Hmm, you know, I'm not sure.

[10:26] <autrijus> .= implemented.

[10:26] <theorbtwo> Cool.

[10:26] <autrijus> committing

[10:27] <autrijus> r597.

[10:27] <autrijus> i'd appreciate a .= test

[10:28] <autrijus> rarely nowadays did I commit something and found that there's no UNEXPECTEDLY SUCCEEDED :)

[10:29] <theorbtwo> t/op/inplace.t?

[10:32] <autrijus> ok.

[10:32] <autrijus> bbiab &

[10:40] <theorbtwo> r598 -- tested; list LHS works but not scalar?

[10:48] <theorbtwo> r599 -- You forgot yourself in AUTHORS, autrijus.

[10:59] <theorbtwo> Allo, almost-symmetric.

[11:00] <theorbtwo> Hello, fayland.

[11:02] <fayland> hello.

[11:02] <larsen> Hello.

[11:02] <fayland> theorbtwo: anything to say?

[11:03] <theorbtwo> Just saying a friendly hello.

[11:04] <fayland> ya.:)

[11:12] <theorbtwo> Hmm, Mr. Muskrat on PM is having problems installing with GHC 6.4

[11:15] <theorbtwo> Yep, and downgrading to 6.2.2 made it work for him.

[11:34] <jabbot> pugs - 599 - Um, Autrijus, you forgot yourself...

[11:34] <jabbot> pugs - 598 - Test .= inplace modification operator

[11:34] <jabbot> pugs - 597 - .= implemented

[11:34] <jabbot> pugs - 596 - * ||= and //= etc now works; list as LHS

[11:38] <metaperl> sub foo { return "$?CALLER::POSITION" }

[11:38] <metaperl> what does $? indicate

[11:38] <metaperl> the question mark confuses me

[11:47] <theorbtwo> The bit between the $ and the name proper is called a secondary sigil.

[11:47] <theorbtwo> I'm afraid I don't know what each of them is off the top of my head.

[12:01] <metaperl> theorbtwo, thanks. It is discussed here: http://dev.perl.org/perl6/synopsis/S02.html

[12:05] <Juerd_> "Is it nanoseconds this week?

[12:05] <Juerd_> That's the sort of arbitrary complexity that doesn't belong in Perl 6.

[12:05] <Juerd_> Solving the real problems is hard enough.

[12:05] <Juerd_> ""

[12:05] <Juerd_> argh, stupid pasting system in irssi

[12:05] <Juerd_> Anyway, we have to wonder what the $op operator is this week, but the units for time are set in stone :)

[12:19] <theorbtwo> Issues with GHC 6.4: http://use.perl.org/~Mr.%20Muskrat/journal/23622

[12:21] <malaire> last revision is working with GHC 6.4, at least for me - but it does give quite many warnings while compiling

[12:21] <theorbtwo> Oh, OK.

[12:22] <malaire> Mostly about deprecated things like Data.FiniteMap

[12:23] <theorbtwo> Ah, OK.  He's using release, not SVN.

[12:25] <wilx> Huh, why is Data.FiniteMap deprecated?

[12:26] <malaire> warning says to use Data.Map instead

[12:27] <malaire> but for some reason online-documentation for Data.Map is missing

[12:27] <malaire> (at http://www.haskell.org/ghc/docs/6.4/html/libraries/index.html)

[12:27] <malaire> so I'm not sure where to check about differences between Data.FiniteMap and Data.Map

[12:42] <nothingmuch>  List = Nothing

[12:42] <nothingmuch> 	     | Cons a (List a)

[12:42] <nothingmuch> List.hs:5: parse error on input `|'

[12:42] <nothingmuch> que?

[12:43] <nothingmuch> <tab>Lis...\n<tab><space>+\|

[12:43] <metaperl> is that not data List = Nothing | Cons a (List a)

[12:43] <metaperl> data in frnt

[12:44] <metaperl> nothingmuch, they can help you on #haskell

[12:44] <nothingmuch> oh crap

[12:44] <nothingmuch> #haskell is usually less helpful

[12:44] <nothingmuch> the tend to get on about funky stuff

[12:44] <nothingmuch> and ignore me

[12:44] <nothingmuch> except if i'm lucky

[12:49] <metaperl> I've found them to be most helpful and friendly

[12:49] <theorbtwo> Well, that's not very nice of them.

[12:50] <metaperl> theorbtwo, form your own opinions

[12:50] <theorbtwo> What's the difference between "chain" and "list" in the initSyms table in Prim.hs?

[12:50] <theorbtwo> (Is that properly Prim.initSyms?)

[12:51] <theorbtwo> s/that's not/that doesn't sound/

[13:06] <malaire> it seems to me that "list" is used in things that creates lists, or junctions (junction-ops, dot, ;)

[13:06] <malaire> chain is used for ops like '<' which can be chained together like a < b < c - and results a boolean

[13:06] <theorbtwo> Hm, I don't see the difference there.

[13:06] <theorbtwo> Oh, context, of course.

[14:07] <Juerd_> xerox: I need a new fuser for my xerox phaser 6100 :)

[14:07] <Juerd_> xerox: Get me one :P

[14:07] * xerox grumbles

[14:16] <autrijus> greetings.

[14:16] <autrijus> theorbtwo: not only context, and also different evaluation rules

[14:16] <autrijus> "list" means list-associative

[14:16] <autrijus> "chain" means chain-associative

[14:17] * autrijus likes this "wireless taipei" thing

[14:17] <autrijus> free wireless almost everywhere :)

[14:17] <autrijus> <- in a random small foodplace

[14:22] * clkao giggles at autrijus

[14:26] <nothingmuch> autrijus++ # haskell instructor extraordinaire

[14:27] <autrijus> :)

[14:27] <nothingmuch> perlbot karma autrijus

[14:27] <perlbot> Karma for autrijus: 8

[14:27] <nothingmuch> ah, it's up!

[14:28] <nothingmuch> l~r was complaining for nothing

[14:36] <autrijus> bbiab. :)

[15:17] * autrijus back

[15:17] <autrijus> fixing 

[15:17] <autrijus> my ($a, $b, @c, @d) = (1,2,3,4);

[15:17] <autrijus> this should make $a == 1, $b == 2, @c == (3,4) and @d == ()

[15:17] <autrijus> right?

[15:18] <hcchien> yes

[15:18] <hcchien> I think so. :)

[15:23] * autrijus ponders about porting CPANPLUS to Pugs.

[15:24] <jabbot> pugs - 600 - Autrijus made some todo_is test work so 

[16:52] <ingy> hola

[16:53] <autrijus> greetings!

[16:54] <ingy> I'm am heading off to do a bike race

[16:54] <ingy> nothing to report

[16:55] <metaperl> wow another one

[16:56] <metaperl> where do you live ingy?

[16:56] <ingy> autrijus: docs is for adhoc documents about pugs. doc is where the installable perlxxx.{kwid|pod} files go

[16:56] <ingy> Seattle

[16:56] <ingy> I have at least one race per week until September

[16:56] <autrijus> ingy: I find that very confusing.

[16:57] <metaperl> for a team with nothing but outside shooters, the Sonics are kicking some A this year

[16:57] <autrijus> I'd much rather unify them as kwids and all in doc/, or all docs/, etc.

[16:57] <ingy> autrijus: well 01Overview.html is not an installable doc per se

[16:57] <autrijus> why not?

[16:57] <autrijus> provided that we kwidify it

[16:57] <ingy> so I just made a place for the installable kwids

[16:57] <ingy> sure...

[16:58] <autrijus> and even in html form, what's stopping us from installing html? :)

[16:58] <ingy> but for now it is nice to have a place where we put stuff that is not really intended to be part of the final dist, like yaht.kwid

[16:59] <ingy> ie helpful stuff that is not in MANIFEST

[16:59] <ingy> but it's your call

[16:59] <ingy> I'll kwidify 01Overview.html and move it to doc

[16:59] <autrijus> ok. I think that works.

[17:00] <autrijus> and maybe the uninstalled stuff is notes/.

[17:00] <ingy> I need to add doc install support to make install

[17:00] <autrijus> s/uninstalled/not-installed/

[17:00] <ingy> coming soon

[17:00] <autrijus> just to avoid confusion.

[17:00] <ingy> ok. gotta race! &

[17:01] <metaperl> have fun ingy

[17:04] <Limbic_Region> autrijus - any guestimate as to which release of pugs will have classes?

[17:04] <autrijus> 6.28.0 of course!

[17:04] * autrijus points people to PA01

[17:05] * Limbic_Region read PA01

[17:05] <Limbic_Region> hmmm - don't remember that bit

[17:06] <Limbic_Region> is there a link to PA01 from http://pugscode.org/

[17:06] <autrijus> "Overview"

[17:06] <Limbic_Region> nevermind - found it

[17:06] <nothingmuch> anybody got a spare YAHT 4.11 solution?

[17:06] <nothingmuch> filter/map in CPS

[17:07] <Limbic_Region> found the roadmap - thanks

[17:08] <autrijus> np

[17:08] <xerox> nothingmuch, yep.

[17:08] <xerox> nothingmuch, are you having problems?

[17:08] <nothingmuch> well, i got it

[17:08] <nothingmuch> sort of

[17:08] <nothingmuch> but i don't like my solution

[17:08] <nothingmuch> because consing is done in the compatible wrapper

[17:09] <nothingmuch> instead of the cont one

[17:09] <autrijus> that is not unlike mapM

[17:09] <Limbic_Region> autrijus - did you see Larry's replies to the Replaying Santa Claus Golf Apocalypse with Pugs/Perl6 thread at the Monastery?

[17:09] <autrijus> no. reading

[17:11] <autrijus> heh.

[17:11] <autrijus> I think that means we have to implement reverse() now.

[17:11] <autrijus> any takers?

[17:12] <nothingmuch> hah

[17:12] <nothingmuch> you know what?

[17:12] <nothingmuch> with some hand holding, why not

[17:12] <Limbic_Region> well - I am no longer employed with 2 jobs, I might very well become more than just a lurker soon

[17:12] <nothingmuch> xerox: can you post your 4.11 somewhere?

[17:13] <xerox> cfold?

[17:14] <nothingmuch> map in CPS

[17:14] <xerox> map. Okay.

[17:14] <autrijus> nothingmuch: yay!

[17:14] <nothingmuch> 	my_reverse [] = []

[17:14] <nothingmuch> 	my_reverse (x:xs) = (reverse xs) ++ [x]

[17:14] <nothingmuch> will it look similar?

[17:14] <autrijus> nothingmuch: you can start by write a reverse test :)

[17:15] <nothingmuch> or can i use the reverse builtin?

[17:15] <nothingmuch> good point ;-)

[17:15] <autrijus> sure you could!

[17:15] <autrijus> so let's write a reverse for string 

[17:15] <autrijus> ready? :)

[17:15] <autrijus> 1. you need to figure out its signature.

[17:15] <nothingmuch> one sec

[17:15] <nothingmuch> committing reverse.t

[17:16] <autrijus> ok.

[17:16] <autrijus> I'll type away.

[17:16] <xerox> http://haskell.org/hawiki/HaskellIrcPastePage

[17:16] <nothingmuch> autrijus - see?

[17:16] <autrijus> I'd rather do it on irc

[17:17] <autrijus> it's very simple

[17:17] <autrijus> and I want it logged here :)

[17:17] <nothingmuch> ok, one minute then

[17:17] <autrijus> when you're ready, open Prim.hs.

[17:17] <xerox> nothingmuch, was for you.

[17:17] <nothingmuch> xerox: you seem to have done it the same as I have

[17:17] <nothingmuch> i was wondering if the consing could have been done inside mapC' someway

[17:18] <xerox> Why?

[17:18] <nothingmuch> err, i dunno

[17:19] <nothingmuch> just wondering

[17:19] <nothingmuch> ok, reverse.t comitted

[17:19] <nothingmuch> ...

[17:19] <autrijus> cool.

[17:19] <nothingmuch> done

[17:19] <nothingmuch> and prim.hs gvimmed

[17:19] <autrijus> ok. let's do the string part first.

[17:20] <nothingmuch> pugs strings eq haskell strings?

[17:20] <autrijus> sort of. you can say that.

[17:20] <autrijus> type VStr = String

[17:20] <autrijus> same thing, but we consistently use a "V" prefix

[17:20] <autrijus> on line 583 you see

[17:20] <autrijus> \\n   Scalar    pre     scalar  (Scalar)\

[17:20] <nothingmuch> ok

[17:20] <nothingmuch> exactly what i was going to guess

[17:21] <autrijus> that is prototype for "scalar"

[17:21] <autrijus> so you copy that line

[17:21] <autrijus> and add another line after it

[17:21] <nothingmuch> one minute, svn up time

[17:21] <autrijus> and change "Scalar" to "Str" and "scalar" to "reverse"

[17:21] <autrijus> and voila we have a function.

[17:21] <nothingmuch> my 583 doesn't look like that

[17:21] <larsen> nothingmuch: I think there's a typo in the test

[17:21] <autrijus> what does your 583 look like?

[17:21] <autrijus> oh. svn up.

[17:22] <nothingmuch> larsen - it ran and todoed fine, but that does not mean it's correct

[17:22] <nothingmuch> what's wrong?

[17:22] <larsen> line 9

[17:22] <nothingmuch> autrijus: ...

[17:22] <larsen> it should be my @a ...

[17:22] <nothingmuch> no

[17:22] <nothingmuch> @e is expected

[17:22] <nothingmuch> @a is got

[17:23] <nothingmuch> my @a; eval '@a is reversed 1..4'

[17:23] <nothingmuch> my @e = what we want

[17:23] <larsen> ah sure

[17:23] <nothingmuch> todo_is(~@a, ~@e)

[17:23] <larsen> ok

[17:23] <nothingmuch> someday we'd like to implement todo_is and is with ~~, i hope =)

[17:23] <autrijus> nothingmuch: so, your line 583 synced? :)

[17:23] <nothingmuch> yup yup

[17:23] <autrijus> sure.

[17:23] <nothingmuch> and i changed it

[17:23] <autrijus> ok. add that line of prototype

[17:23] <autrijus> and now implement it

[17:24] <jabbot> pugs - 601 - Test string and list reverse op

[17:24] <xerox> autrijus, sorry, did you say GHC 6.4 doesn't write "forall a." anymore?

[17:24] <nothingmuch> jabbot announces svn up?

[17:24] <nothingmuch> or is it not a bot at all?

[17:24] <autrijus> it is a bot.

[17:24] <autrijus> xerox: I mean it's :t function.

[17:24] <nothingmuch> line 89

[17:24] <nothingmuch> op1 "reverse" = reverse

[17:24] <autrijus> right.

[17:24] <nothingmuch> right?

[17:25] <autrijus> not quite :)

[17:25] <autrijus> op1 :: Ident -> Val -> Eval Val

[17:25] <autrijus> type Ident = String

[17:25] <xerox> autrijus, can you give me an example? It seems to show "forall" here :(

[17:25] <autrijus> so "reverse" fills the Ident slot

[17:25] <autrijus> xerox: if shows forall if you launch it with -fglasgow-exts

[17:25] <autrijus> or if it loads a file that has OPTIONS -fglasgow-exts

[17:25] <autrijus> like all pugs files

[17:25] <xerox> Ah, okay, thank you.

[17:25] * nothingmuch thinks a little

[17:25] <nothingmuch> no help!

[17:26] <autrijus> nothingmuch: so the function on the right of "=" needs to be of type

[17:26] <autrijus> Val -> Eval Val

[17:26] <nothingmuch> nono! don't help!

[17:26] <autrijus> vCast

[17:26] <autrijus> oh ok

[17:26] * nothingmuch covers ears and sings

[17:26] * autrijus stops helping

[17:26] <autrijus> you'll figure it out :)

[17:26] <xerox> Ah ah. :)

[17:27] <autrijus> nothingmuch: and when you're done implementing string op, look at op1 "=" for how to do the list part.

[17:27] <autrijus> that'd be all :)

[17:27] <autrijus> oh, and "Eval" is just a monad. think of it like "IO".

[17:28] <nothingmuch> beh beh beh, phone distracting

[17:28] <xerox> ``just a monad''

[17:29] <autrijus> yeah. be glad it is not an arrow parameterized on polymorphic existential endofunctors inside a ST thread under STM.

[17:30] * xerox panics

[17:30] * autrijus reboots xerox 

[17:31] * xerox happily beeps

[17:32] <autrijus> hm. I can't quite believe it only took two lines.

[17:34] * nothingmuch doesn't get it

[17:34] <nothingmuch> i create a function

[17:34] <nothingmuch> which happens to reverse val

[17:34] <autrijus> nothingmuch: ok... may I help? :)

[17:34] <autrijus> cool.

[17:34] <nothingmuch> which accepts a Val

[17:34] <autrijus> and gives out Val.

[17:34] <nothingmuch> and returns something which is an evaluation

[17:35] <nothingmuch> which i have no idea how to construct yet

[17:35] <autrijus> now, the type of "return" is

[17:35] <autrijus> a -> Eval a

[17:35] <autrijus> :)

[17:35] <autrijus> actually it is

[17:35] <nothingmuch> what is the . operator in haskell?

[17:35] <autrijus> (Monad m) => a -> m a

[17:35] <autrijus> and Eval is indeed Monad

[17:35] <autrijus> nothingmuch: it means function composition.

[17:35] <autrijus> f . g

[17:35] <autrijus> is like, in perl

[17:36] <autrijus> sub f_dot_g { f(g($_[0])) }

[17:36] <nothingmuch> it returns an anoynmous function which accepts the type that g accepts

[17:36] <nothingmuch> and calls g on it's param

[17:36] <nothingmuch> and calls f on that?

[17:36] <autrijus> exactly!

[17:37] <autrijus> (b -> c) -> (a -> b) -> a -> c

[17:37] <autrijus> is the type of (.)

[17:37] <autrijus> you can clearly see how "a" flows to g

[17:37] <autrijus> and becomes "b" which flows to f

[17:37] <autrijus> and gives out c.

[17:37] <autrijus> so whenever you find yourself writing

[17:37] <nothingmuch> what is an Ident?

[17:37] <autrijus> foo (bar baz)

[17:37] <autrijus> then you can write

[17:37] <autrijus> (foo . bar) baz

[17:38] <autrijus> Ident is String.

[17:38] <nothingmuch> oh, the "reverse"

[17:38] <nothingmuch> the operators name

[17:38] <autrijus> yup.

[17:38] <autrijus> yup. "Identifier name"

[17:38] <nothingmuch> ok, not the variable it's acting on or something like that

[17:38] <nothingmuch> ok, dealt with

[17:38] <autrijus> nope.

[17:38] <nothingmuch> and Val is a class VStr belongs to?

[17:38] <autrijus> Value is a class VStr belongs to.

[17:39] <nothingmuch> err

[17:39] <autrijus> AST.hs line 149 is the instance declaration (that you probably don't need to read)

[17:39] <nothingmuch> so why isn't return . reverse doing what I meant?

[17:39] <nothingmuch>     Couldn't match `Val' against `[a]'

[17:39] <nothingmuch>         Expected type: Val -> Eval Val

[17:39] <nothingmuch>         Inferred type: Val -> ContT Val (ReaderT Env IO) [a]

[17:39] <autrijus> because reverse expects VStr

[17:39] <autrijus> but you give it a Val

[17:39] <nothingmuch> isn't [a], err, in this case [Char] basically a member of Val?

[17:40] <autrijus> you can get a VStr from a Val

[17:40] <autrijus> by using vCast.

[17:40] <nothingmuch> ah, ok

[17:40] <autrijus> vCast :: (Value n) => Val -> n

[17:40] <autrijus> note that "Value" is the class

[17:40] <autrijus> and "Val" is a type.

[17:40] <autrijus> now you'll run into another problem :)

[17:40] <autrijus> i.e. reverse can work on lots of things, not only VStr.

[17:40] <autrijus> so you need to instrument it:

[17:40] <autrijus> (reverse :: VStr -> VStr)

[17:41] <autrijus> but that is not neccessary.

[17:41] <autrijus> because you needs to return a Val, not a VStr

[17:41] <autrijus> to make a Val from a VStr

[17:41] <autrijus> you use... "VStr"

[17:41] <autrijus> this time in constructor form.

[17:41] <autrijus> VStr :: VStr -> Val

[17:42] <autrijus> the convention of pugs is that the constructor takes, as the only parameter, the type with the same name, and promote it to the "more abstracted" type.

[17:42] <autrijus> so constructor "VStr" promotes a VStr into Val

[17:42] <autrijus> constructor "Val" promotes a Val into Exp

[17:42] <autrijus> (but you don't need to know that yet) :)

[17:42] <autrijus> All tests successful.

[17:42] <autrijus> Files=84, Tests=1419, 53 wallclock secs ( 0.00 cusr +  0.00 csys =  0.00 CPU)

[17:43] <autrijus> assign.t bug squashed.

[17:43] <nothingmuch> yay!

[17:43] <autrijus> it works!?

[17:43] <nothingmuch> bah, it's dinner time

[17:43] <nothingmuch> no, that assign.t is good

[17:43] <autrijus> oh :)

[17:44] <jabbot> pugs - 603 - * unify my()=() with ()=(); that makes a

[17:44] <nothingmuch> i tried both return .VStr . reverse .vCast thinking it would cause it to infer stuff into reverse

[17:44] <jabbot> pugs - 602 - * unary op following .= is unimplemented

[17:44] <nothingmuch> but this confuses the next line

[17:44] <nothingmuch> and before i tried vStr . vCast

[17:44] <nothingmuch> but that caused a different problem

[17:44] <nothingmuch> err, compile cycle too long to check

[17:44] <autrijus> !.

[17:44] <nothingmuch> anyway, i have to go, i will be back soon to finish

[17:44] <autrijus> you should be able to just use ghci

[17:44] <autrijus> and keep using :r

[17:45] <autrijus> ghci -isrc src/Main.hs

[17:45] <autrijus> that's all you need to do :)

[17:45] <autrijus> uh

[17:45] <autrijus> op1 "reverse" =  return . VStr . reverse . vCast

[17:45] <autrijus> is actually The Correct Solution.

[17:46] <autrijus> not sure what confuses the next line.

[17:46] <autrijus> indent maybe

[17:46] <autrijus> anyway, I await your commit after dinner.

[17:46] <autrijus> journal time :)

[17:54] <jabbot> pugs - 604 - * my $a == $b should not mean my $a = = 

[18:02] <autrijus> rg0now++

[18:02] <autrijus> say*(split"",int(7e10+ +*(=open@ARGS[0])))[1..11]

[18:02] <autrijus> aw, aw.

[18:02] <autrijus> pugs gold!

[18:02] <autrijus> err. pugs golf!

[18:03] <autrijus> (that implements 'wc')

[18:06] <nothingmuch> ok

[18:10] <nothingmuch> ick

[18:10] <autrijus> all larry's golfs now works.

[18:10] <nothingmuch> why is it not working

[18:11] <autrijus> ??:: inside parens

[18:11] <autrijus> and posfix ...

[18:11] <nothingmuch> woo! ??:: inside parens!

[18:11] <autrijus> was parsed wrong.

[18:11] <autrijus> yeah. thanks to golf-driven development

[18:11] <autrijus> nested ??:: now works too.

[18:11] <nothingmuch> ya ya ya

[18:12] <nothingmuch> now for reverse

[18:12] <Juerd_> autrijus: I thought that was known for a while

[18:12] <autrijus> what was known?

[18:12] * xerox wonders what's the good thing about incompresible syntax..

[18:13] <nothingmuch> Juerd_: the problem was known, and even tested, just not fixed =)

[18:13] <Juerd_> autrijus: In fact, I thought that that was why tests mostly had if (cond) { say ... } else { say ... } instead of say(cond ?? ... :: ...)

[18:13] <Juerd_> nothingmuch: Ah, okay

[18:13] <autrijus> true. tests needs to use try{} and ??:: more.

[18:13] <nothingmuch> and yes, that is why the tests did that

[18:13] <autrijus> oh and postfix conditionals is now part of expression.

[18:13] * nothingmuch will try to clean some stuff up when he returns from alcohol place tonight

[18:13] <Juerd_> Yay for sanity

[18:14] <jabbot> pugs - 606 - * ??:: in parens works now; thanks to rg

[18:14] <jabbot> pugs - 605 - * postfix ... works again.

[18:14] <autrijus>  1 ?? 3 if 2 :: 4 if 0

[18:14] <Juerd_> autrijus: Good. That means you get stacked statement modifiers :)

[18:14] <Juerd_> FOR FREE

[18:14] <autrijus> that too.

[18:14] <autrijus> FOR FREE.

[18:14] <Juerd_> larry-- autrijus++  # ;)

[18:14] <autrijus> and it's all very clean.

[18:14] <autrijus> I'll keep it that way until larry shouts at me to cripple it :)

[18:14] <xerox> What is "1 ?? 3 if 2 :: 4 if 0" supposed to mean?

[18:14] <nothingmuch> 1 ?? -> yes

[18:15] <nothingmuch> so evaluate '3 if 2'

[18:15] <nothingmuch> 2 -> yes

[18:15] <nothingmuch> so 3

[18:15] <nothingmuch> if 1 was false, then :: 4 if 0 is evaled

[18:15] <nothingmuch> if 0? -> no

[18:15] <nothingmuch> so no on the 4

[18:15] <Juerd_> Not that it's readable, though, when written like that

[18:15] <autrijus> pugs> . 1 ?? 3 if 2 :: 4 if 2

[18:15] <autrijus> {{  Syn "if" {

[18:15] <autrijus>      1;

[18:15] <autrijus>      Syn "if" {2; 3; undef};

[18:15] <autrijus>      Syn "if" {2; 4; undef}}

[18:15] <Juerd_> 1

[18:15] <autrijus> }}

[18:15] <Juerd_> ?? 3 if 2

[18:15] <Juerd_> :: 4 if 0

[18:15] <autrijus> thanks to nnunley we have a pretty AST.

[18:16] <nothingmuch> i have no idea what that returns, though

[18:16] <nothingmuch> undef?

[18:16] <autrijus> which should makes everything clear

[18:16] <Juerd_> nothingmuch: undef makes sense

[18:16] <nothingmuch> autrijus: so what do we do about reverse?

[18:16] <autrijus> no, it returns 3. :)

[18:16] <nothingmuch> see it and see why it's broken?

[18:16] <autrijus> nothingmuch: I thought you've implemented it

[18:16] <nothingmuch> i can't tell

[18:16] <autrijus> sure. just commit.

[18:16] <Juerd_> 3?!

[18:16] <nothingmuch> i have

[18:16] <nothingmuch> and even in a way which you said is ok

[18:16] <nothingmuch> but it doesn't compile

[18:16] <autrijus> Juerd_: "3 if 2" is 3

[18:16] <nothingmuch> is ?! an operator?

[18:16] <Juerd_> OH DUH

[18:16] <autrijus> just commit it.

[18:16] <Juerd_> HAHA

[18:16] * Juerd_ for some reason assumed ~~ semantics for if

[18:16] <Juerd_> But that's spelled "when" 

[18:17] <autrijus> riiight.

[18:17] <nothingmuch> autrijus: *cough* /what/?!

[18:17] <autrijus> nothingmuch: just commit whatever code you have and I'll see the compile error

[18:17] <Juerd_> This is what happens if you don't touch any code for a few weeks :(

[18:17] <nothingmuch> fine

[18:17] <nothingmuch> beh beh beh!

[18:17] <autrijus> brb.

[18:17] <Juerd_> nothingmuch: ?! should be ?(!(...)

[18:17] <Juerd_> Prefix that is

[18:18] <Juerd_> ! implies ? though

[18:18] <nothingmuch> so boolean prefix of !?

[18:18] <nothingmuch> err, 

[18:18] <Juerd_> Yes.

[18:18] <nothingmuch> !? is not an expression ;-)

[18:18] <nothingmuch> boolean context, not prefix

[18:18] <nothingmuch> well, it's like saying 'scalar 0

[18:18] <nothingmuch> '

[18:18] <Juerd_> scalar is a prefix operator too

[18:18] <nothingmuch> like in perl5

[18:19] <Juerd_> ! and ? are the same thing

[18:19] <Juerd_> But ! negates the outcome

[18:19] <nothingmuch> aye

[18:20] <Juerd_> The low precedence versions are called "not" and "true"

[18:20] <nothingmuch> and scalar is still a prefix operator

[18:20] <Juerd_> NOte: not "false" and "true", not "not" and "too"

[18:20] <Juerd_> :)

[18:20] <nothingmuch> so zeronary ? is basically '1 == 1'?

[18:20] <Juerd_> I think "true" is special

[18:21] <Juerd_> Hm, it is not

[18:21] <Juerd_> nullary true and ? don't exist

[18:21] <Juerd_> The true value is Bool::true, not true

[18:21] <nothingmuch> ah

[18:21] <nothingmuch> that's what nullary means

[18:21] <Juerd_> To avoid that people actually use it.

[18:21] <Juerd_> nullary = having 0 arguments

[18:21] <nothingmuch> i always read it as 'null array', not 'nulery'

[18:21] <Juerd_> unary = having 1 argument

[18:21] <Juerd_> binary = having 2 arguments

[18:21] <Juerd_> ternary = having 3 arguments

[18:22] <Juerd_> listary = having any number of arguments :)

[18:22] <nothingmuch> heh

[18:22] <nothingmuch> that's cute

[18:22] <Juerd_> unary can be prefix or postfix

[18:22] <nothingmuch> for irc log completeness: infix postfix prefix etc say where the arguments are nibbed from

[18:22] <Juerd_> binary is infix

[18:22] <Juerd_> unary can also be circumfix

[18:22] <Juerd_> listary is always prefix

[18:22] <nothingmuch> circumfix? que?

[18:22] <Juerd_> but could in theory be postfix

[18:22] <Juerd_> nothingmuch: circum == around

[18:22] <Juerd_> nothingmuch: () is circumfix

[18:23] <nothingmuch> is hyper a circumfix op taking an op

[18:23] <Juerd_> nothingmuch: "" is circumfix

[18:23] <Juerd_> It is *around* the argument

[18:23] <Juerd_> nothingmuch: hyper is a meta-op

[18:23] <nothingmuch> and converting it to a binary infix listrefferry op?

[18:23] <nothingmuch> ;-)

[18:23] <Juerd_> Either prefix, postfix or both (sort-of circumfix), but to an op, not a term

[18:24] <jabbot> pugs - 607 - Implemented reverse for strings, and thr

[18:24] <Juerd_> jabbot: Neato. Let me see the tests for that

[18:24] <jabbot> Juerd_: I'm not sure I understand you fully.

[18:24] <nothingmuch> do we get to declare meta ops, btw?

[18:24] <Juerd_> As list reverse "foo" should still be "foo"

[18:24] <nothingmuch> jabbot->isa bot

[18:24] <Limbic_Region> heh

[18:24] <nothingmuch> t/op/reverse.t was very hackishly thrown together

[18:24] <Juerd_> nothingmuch: Good question; ask p5l

[18:24] <nothingmuch> i'll add more stuff

[18:25] <Juerd_> nothingmuch: I don't see why we shouldn't talk to bots.

[18:25] <Juerd_> I have long nocternal conversations with purl.

[18:25] <Limbic_Region> jabbot: tobbaj?

[18:25] <jabbot> Limbic_Region: That is interesting. Please continue.

[18:25] <nothingmuch> hah

[18:25] <nothingmuch> great

[18:26] <nothingmuch> now i can't check that the new test is actually sane

[18:26] <nothingmuch> because i can't compile pugs

[18:26] <Juerd_> I like how perl is very persistent in trying to parse input

[18:26] <Juerd_> perl Makefile

[18:26] <nothingmuch> yes, that always amuses me =)

[18:26] <Juerd_> Eventually giving up past line 757.

[18:27] <nothingmuch> Can't find string terminator '"' anywhere before EOF at Makefile line 765.

[18:27] <nothingmuch> *MY* perl is trigger happier than *YOUR* perl

[18:28] <nothingmuch> Juerd_: 

[18:28] <nothingmuch> 	my $a = "foo";

[18:28] <nothingmuch> 	my @a; eval '@a = reverse $a';

[18:28] <autrijus> rehi.

[18:28] <nothingmuch> 	my @e = ("foo");

[18:28] <nothingmuch> 	todo_is(@a, @e, "reversed string in array context is actually a no-op");

[18:28] <nothingmuch> hola autrijus

[18:29] <Juerd_> A no op that, when the argument is a simple scalar, should very probably emit a warning

[18:29] <Juerd_> This requires introspection of the argument list

[18:29] <nothingmuch> and what about reverse($a)?

[18:29] <nothingmuch> or reverse *$a?

[18:30] <Juerd_> list reverse $a returns $a and should emit a warning

[18:30] <nothingmuch> testing my @a = ("foo"); and reversing that seems silly

[18:30] <Juerd_> scalar reverse $a should reverse $a and return that

[18:30] <autrijus> hey

[18:30] <autrijus> nothingmuch: you accidentally touched "list"

[18:30] <autrijus> that's all.

[18:30] <autrijus> "reverse" is fine.

[18:30] <autrijus> fixed.

[18:30] <autrijus> "svn di" is your friend

[18:30] <nothingmuch> how did i touch it?

[18:30] <nothingmuch> svn st next time

[18:31] <nothingmuch> grazie

[18:31] <autrijus> right.

[18:31] <nothingmuch> now on to list reverse

[18:31] <autrijus> op1 "reverse" = return . VList . reverse . vCast

[18:31] <autrijus> is actually all there is.

[18:31] <autrijus> the trick lies in how to trigger the correct one depending on context.

[18:31] <Juerd_> Does the list list operator exist?

[18:31] <autrijus> yes.

[18:32] <nothingmuch> is it tested?

[18:32] <nothingmuch> hard to say based on grep -r

[18:32] <autrijus> not sure.

[18:32] * autrijus writing journal

[18:33] <nothingmuch> i'll look into that

[18:33] <autrijus> nothingmuch: so should I implement the context dispatch code

[18:33] <autrijus> or are you doing it?

[18:33] <nothingmuch> how will it look?

[18:33] <nothingmuch> like you said?

[18:33] <nothingmuch> or more scary?

[18:33] <autrijus> line 198.

[18:34] <autrijus> I'll do that.

[18:34] <autrijus> gives me chance to unify the context dispatcher.

[18:34] * nothingmuch looks at op1 "="

[18:34] <nothingmuch> oh, which is 198

[18:34] <xerox> brb

[18:34] <nothingmuch> ok

[18:34] <nothingmuch> i'll svn ci list reverse

[18:34] <jabbot> pugs - 608 - * fix breakage

[18:35] <nothingmuch> oi vey, what have i done to op1 "list"

[18:36] <nothingmuch> sorry, autrijus

[18:36] <Juerd_> I've commited some more reverse tests

[18:36] <Juerd_> Can't run them, though, as I still have broken pugs

[18:36] <nothingmuch> svn up should fix it

[18:36] <Juerd_> nothingmuch: I'm in fact already compiling

[18:39] <Juerd_> autrijus: Can you implement -I?

[18:39] <nothingmuch> -l, i.e. the is file a link -X function?

[18:40] <Juerd_> no, -I

[18:40] <Juerd_> Not -l

[18:40] * Juerd_ can't count, by the way

[18:40] <Juerd_> It's official now.

[18:40] * Juerd_ changes the plan.

[18:40] <autrijus> what? what?

[18:40] <Juerd_> -Iblib6/lib

[18:40] <autrijus> I need context!

[18:40] <Juerd_> Include.

[18:40] <autrijus> ah.

[18:40] <nothingmuch> ah

[18:40] * Juerd_ doesn't like environment variables :)

[18:41] <Juerd_> KDE Technologies: Get Hot New Stuff

[18:41] <nothingmuch> Juerd_: i've untodoed the first str test

[18:41] <Juerd_> The KDE people really know their target audience too well :(

[18:42] <Juerd_> Is this the first test where a method behaves different from a list op?

[18:42] <autrijus> nothingmuch: bah.

[18:42] <autrijus> no context dispatch needed

[18:42] <autrijus> op0 "reverse" = return . VList . reverse

[18:42] <autrijus> op1 "reverse" = return . VStr . reverse . vCast

[18:42] <Juerd_> (i.e. @foo.reverse in scalar context should return an arrayref, and not do stringy reverse)

[18:42] <autrijus> \\n   Str       pre     reverse (Str)\

[18:42] <autrijus> \\n   List      pre     reverse (List)\

[18:42] <autrijus> that's all!

[18:43] <nothingmuch> what about reverse @list?

[18:43] <autrijus> MMD.

[18:43] <nothingmuch> it's op0?

[18:43] <autrijus> but that depends on the fact that pugs does retval MMD.

[18:43] *** khisanth__ is now known as Khisanth

[18:43] <autrijus> op0 means listOp

[18:43] <nothingmuch> ah

[18:43] <nothingmuch> i assumed nullary

[18:43] <autrijus> no, that won't be an op

[18:43] <autrijus> for obvious reasons.

[18:43] <Juerd_> New word, already using it! :)

[18:44] <jabbot> pugs - 610 - untodo str reverse

[18:44] <jabbot> pugs - 609 - more reverse tests

[18:44] <Juerd_> jabbot too can't count

[18:44] <autrijus> C:\work\pugs>pugs t\op\reverse.t

[18:44] <autrijus> 1..2

[18:44] <autrijus> ok 1 - list was reversed # TODO

[18:44] <autrijus> ok 2 - string was reversed # TODO

[18:44] <Juerd_> It has the reverse commits in reverse. The irony.

[18:44] <nothingmuch> Juerd++

[18:44] <Khisanth> autrijus: a bit delayed but is Perl6::Pugs not meant to be upgradable from the cpan/cpanp shells?

[18:45] <autrijus> Khisanth: what do you mean?

[18:45] <Khisanth> well according to both of them the most recent version is 6.0

[18:46] <autrijus> ah. you have version.pm installed?

[18:46] * Khisanth checks

[18:46] <Khisanth> nope

[18:47] <nothingmuch> is there a gcov for haskell?

[18:47] <nothingmuch> i think for fp gcov really makes sense, with it being pure and all

[18:47] <autrijus> I agree.

[18:47] <Juerd_> autrijus: Can we have .=?

[18:47] <autrijus> Juerd_: we already have .=.

[18:48] <Juerd_> Hmm

[18:48] <Khisanth> autrijus: having it installed gives the same result ...

[18:48] <nothingmuch> i think i saw a ci log for .=,  no?

[18:48] <Juerd_> Then why isn't my test script compiling anymore, after I added that?

[18:48] <autrijus> Khisanth: aw. it's a cpanplus/cpan.pm bug.

[18:48] <nothingmuch> oh, is 'unimplemented'

[18:48] <autrijus> Juerd_: if you added an "unary op" after .=

[18:48] <autrijus> then it's unimplemented.

[18:48] <Juerd_> No, list op

[18:48] <autrijus> iiinteresting.

[18:48] <Juerd_> @a.reverse

[18:48] <autrijus> what is it?

[18:48] <Juerd_> eh

[18:48] <Juerd_> @a.=reverse

[18:48] <autrijus> ah. I see why.

[18:49] <autrijus> hmm, .= is very special.

[18:49] <nothingmuch> special--

[18:49] <Juerd_> .= is just .

[18:49] <nothingmuch> simple++

[18:49] <Juerd_> Or, well, can very well be implemented like that for now

[18:49] <Juerd_> Assigning the result back to its LHS

[18:49] <autrijus> ok. doing it.

[18:50] <Juerd_> That also automatically gives you the right context

[18:50] <nothingmuch> Juerd_: 'for now'.... what do you mean?

[18:50] <autrijus> ok, doing so.

[18:50] <nothingmuch> it has more complicated semantics?

[18:50] <nothingmuch> (with objs, i see, but lists?)

[18:50] <Juerd_> nothingmuch: Later on, it should be able to call a specific, more optimized version of the method that avoids copying

[18:50] <Juerd_> nothingmuch: The classic example being @foo.=sort

[18:50] <nothingmuch> will @foo.sort in void context automatically upgrade to @foo.=sort?

[18:50] <Juerd_> That shouldn't have to be @foo = @foo.sort with weird recognition of self-assignment

[18:50] <nothingmuch> (although i don't know what it will really do to ops)

[18:51] <nothingmuch> ah

[18:51] <Juerd_> Being special in void context is perl 4

[18:51] <Juerd_> See split.

[18:51] <Juerd_> Only optimizations may be made

[18:51] <Juerd_> (See map)

[18:51] <Aankhen``> Hi Juerd_.

[18:51] <Juerd_> Hello

[18:51] <autrijus> ok, implemented according what Juerd_ said.

[18:52] <nothingmuch> btw, if object $foo has a method, blah

[18:52] <autrijus> testing.

[18:52] <nothingmuch> which retturns an object

[18:52] <nothingmuch> of $foo's class

[18:52] <nothingmuch> does $foo.=blah replace all instances of $foo with the returned object?

[18:52] <nothingmuch> only the one in the container?

[18:53] <nothingmuch> i'm curios, because i'd like a nicer way to do Object::Realize::Later type wackiness

[18:53] <Juerd_> nothingmuch: The return type is irrelevant. If $foo.isa(Foo) and $foo.Bar returns a Bar, then $foo.=Bar should still turn $foo into Bar, discarding the previous Foo $foo

[18:53] <nothingmuch> ok, so $foo.=clone probably makes sense in the way most people mean?

[18:53] <Juerd_> Eh

[18:53] <nothingmuch> what about objects changing their thingy instead of their references?

[18:53] <Juerd_> I don't know why you'd clone and then dump the original...

[18:54] <jabbot> pugs - 612 - * fix plans

[18:54] <jabbot> pugs - 611 - * reverse implemented in full. thanks no

[18:54] <Juerd_> Unless you want $dbh.=clone to really mean $dbh.reconnect

[18:54] <nothingmuch> well, given my $foo = get_fooo_from_some_place

[18:54] <nothingmuch> where if you modify $foo you change some_place's copy

[18:54] <nothingmuch> so you $foo.=clone, and it's yours

[18:54] <autrijus> ok 4 - inplace int # TODO

[18:54] <Juerd_> I can't parse it

[18:54] <Juerd_> Rereading.

[18:55] <nothingmuch> my $foo = @array_of_objects[1];

[18:55] <nothingmuch> $foo->blah;

[18:55] <b6s> "#perl6 is already talking about improving GHC's tool chain by writing a code coverage tool, based on pjcj's excellent Devel::Cover module, so we can identify untested conders in Pugs. 'Tsall good. :-) " #http://use.perl.org/~autrijus/journal/23389 ?

[18:55] <Juerd_> nothingmuch: No, that can't work, because = copies.

[18:55] <Juerd_> It'd work only if $foo is a reference.

[18:55] <nothingmuch> wait wait wait

[18:55] <autrijus> b6s: right. gcov is one such possibility.

[18:56] <nothingmuch> $foo refers to a thingy

[18:56] <nothingmuch> be it a blessed strucure or an opaque

[18:56] <nothingmuch> an object in that sense

[18:56] <nothingmuch> it is a copy of the reference @array_of_objects[4]

[18:56] <autrijus> Juerd_: svn up and check your .reverse again?

[18:56] <nothingmuch> but if i call a destructive method on $foo

[18:57] <nothingmuch> like $foo->increment_your_mojo

[18:57] <nothingmuch> then @array_of_objects[4] also changes

[18:57] <Juerd_> autrijus: I've commited it already

[18:57] <nothingmuch> because otherwise it just doesn't make sense

[18:57] <nothingmuch> now, if i don't want @array_of_objects[4] to change

[18:57] <nothingmuch> then i say $foo.=clone

[18:57] <autrijus> aw. you and your fast fingers

[18:57] <Juerd_> nothingmuch: Ah, yes.

[18:57] <nothingmuch> or $foo = @array_of_objects[4].clone

[18:57] <nothingmuch> which is the same thing

[18:57] <Juerd_> nothingmuch: Like that

[18:57] <nothingmuch> ok, good

[18:57] * Juerd_ is compiling

[18:57] <nothingmuch> so how do i not clone, but destroy the original copy in silly ways?

[18:57] <nothingmuch> i want a proper Object::Realize::Later

[18:57] <Juerd_> It takes thrice as long as it did when I last wrote tests

[18:59] <autrijus> mmm fat dog

[18:59] <Juerd_> nothingmuch: I don't know O::R::L (and dislike its name)

[18:59] <nothingmuch> i'll mail p6l about it

[19:00] <Khisanth> autrijus: I'm just cursious but any idea where the shells are getting the 6.0 from?

[19:00] <Juerd_> autrijus: test script compiles and runs now

[19:00] <autrijus> Khisanth: sure, it only accept x.yy not x.y.z

[19:00] <nothingmuch> basically it's an generic object that delays heavyweight construction to a later time

[19:00] <autrijus> Juerd_: woot.

[19:00] <autrijus> Khisanth: they need fixing. not me

[19:00] <nothingmuch> by compositing with delegation you get incremental on demand vivication of needed data

[19:00] <autrijus> maybe I should try the vstring form.

[19:00] <nothingmuch> and thus you can optimise for lazy loading

[19:01] <nothingmuch> without losing a simple, naive implementation that uses the object on the outside

[19:02] <Khisanth> ah didn't know that

[19:02] <autrijus> Khisanth: ok, switched to vstrings.

[19:02] <autrijus> let's see how much havoc it will wreck.

[19:02] <nothingmuch> no! vstring bad!

[19:02] <autrijus> nothingmuch: "6.0.11" is arguably badder.

[19:02] <autrijus> and we need perl 5.6 anyway.

[19:02] <nothingmuch> autrijus--; # why not just inline the int? perl will parse that, no?

[19:02] <autrijus> 6.0.11?

[19:02] <nothingmuch> oi, nevermind

[19:03] <Juerd_> vstrings aren't bad

[19:03] <Juerd_> The perl 5 implementation of them is.

[19:03] <autrijus> sure that'd work, but I like v6.0.11.

[19:03] <Juerd_> However - we still get version *objects* for Perl 6

[19:03] <Juerd_> Not just strings.

[19:03] <autrijus> what Juerd_ said.

[19:03] <nothingmuch> no, i meant '\000\006\000\014'

[19:03] <autrijus> nothingmuch: ...

[19:03] <autrijus> ... NO.

[19:03] <nothingmuch> but really inline

[19:03] <nothingmuch> exactly

[19:03] <Juerd_> nothingmuch: That's not a bad representation, as long as it's internal :)

[19:03] <autrijus> v6.0.11 in perl 5.9 will produce a version object.

[19:03] <autrijus> I'm counting on that.

[19:03] <nothingmuch> Juerd_: that's what vStrings are =)

[19:03] <Juerd_> Counting on a version object; heh

[19:04] <jabbot> pugs - 616 - $plan += $N; s/todo// for @tests[-1];

[19:04] <jabbot> pugs - 615 - * use vStrings!

[19:04] <jabbot> pugs - 614 - resolved conflict

[19:04] <jabbot> pugs - 613 - * .= implemented cleanly thanks to Juerd

[19:04] <autrijus> hi our glorious golfer!

[19:04] <nothingmuch> autrijus: but with an icky icky warning

[19:04] <rg0now> hi!

[19:04] <Juerd_> nothingmuch: 65.66.67 eq "ABC" is where vstrings are bad

[19:04] <rg0now> I am happy to be here at last...

[19:04] <autrijus> nothingmuch: not sure what you mean. I don't get warnings.

[19:04] <Juerd_> autrijus: I notice you prefix * to commit messages. What does it mean?

[19:04] <rg0now> Just came here to tell you that 'reverse' seems to be broken in current svn tree

[19:05] <Juerd_> rg0now: Really? ;)

[19:05] <rg0now> it reverses everything on eart

[19:05] <autrijus> say reverse=<>

[19:05] <autrijus> works.

[19:05] <Juerd_> rg0now: We were just working on this the past hour :)

[19:05] <rg0now> sorry, i am completely new to irc

[19:05] <autrijus> it reverses what on earth?

[19:05] <rg0now> yes, sure

[19:05] <autrijus> damn, my journal keeps getting obsoleted by #perl6.

[19:06] <autrijus> and I had not even written half of it!

[19:06] *** Juerd_ changes topic to: Run Perl6 Now! | pugscode.org ('Overview', 'Journal') | pugs.kwiki.org | channel log: http://xrl.us/e98m | < autrijus> damn, my journal keeps getting obsoleted by #perl6.

[19:06] <Juerd_> Hm

[19:06] <Juerd_> In fact

[19:06] <rg0now> I tried: print reverse =open@ARGS[0]

[19:06] *** Juerd_ changes topic to: Run Perl6 Now! & pugscode.org ('Overview', 'Journal') & pugs.kwiki.org & channel log: http://xrl.us/e98m & < autrijus> damn, my journal keeps getting obsoleted by #perl6.

[19:06] <nothingmuch> rg0now: when did you last svn up?

[19:06] <Juerd_> :)

[19:06] <rg0now> about 3 minutes

[19:06] <nothingmuch> Juerd++

[19:06] <Juerd_> Why choose if you can have them all()? :)

[19:07] <autrijus> rg0now: oh I see. it didn't reverse lines

[19:07] <autrijus> right?

[19:07] <Khisanth> autrijus: be lazy, write some to extract a summary from #perl6.log :)

[19:07] <nothingmuch> print scalar contextifies?

[19:07] <autrijus> eww eww.

[19:07] <rg0now> I mean, you reverse not just the order in the list, but the list elements themselves too

[19:07] <autrijus> nothingmuch: right, that seems to be what it did

[19:07] <Juerd_> rg0now: That's what the list op reverse does in scalar context

[19:07] <rg0now> really?

[19:07] <Juerd_> rg0now: Not in list context, though

[19:07] <autrijus> but it should be in list context!

[19:08] <rg0now> sorry, go back to Synopses

[19:08] <autrijus> \\n   Bool      pre     print   (List)\

[19:08] <nothingmuch> rg0now: that was the equiv of 'print scalar reverse scalar =open@ARGS[0]'

[19:08] <nothingmuch> sort of

[19:08] <autrijus> rg0now: no, we're saying pugs is wrong

[19:08] <nothingmuch> except that scalar was implied

[19:08] <autrijus> and trying to find the problem

[19:08] <Juerd_> rg0now: reverse isn't discussed in synopses, so I'm assuming Perl 5 behaviour for the non-method semantics.

[19:08] <autrijus> ok, I see why.

[19:08] <rg0now> shoul this work: print *reverse =open@ARGS[0]

[19:08] <autrijus> it's parser precedence thing.

[19:08] <nothingmuch> it first stringified the =open@ARGS[0] into a big concat, and then reversed the chars of that

[19:08] <autrijus> I shouldn't rely on the MMD.

[19:08] <autrijus> a sec.

[19:09] <nothingmuch> Juerd_: is 'list' == '*'?

[19:09] <Juerd_> nothingmuch: No

[19:09] <nothingmuch> but both enforce list context?

[19:09] <Juerd_> list in scalar context returns an arrayref, afaict

[19:09] <Juerd_> Yes

[19:09] <nothingmuch> list @array remains an array?

[19:09] <Juerd_> list is for lists what scalar is for scalars

[19:09] <nothingmuch> but splat array is forced flattenned?

[19:09] <Juerd_> It merely provides context

[19:09] <Juerd_> TO THE ARGUMENT

[19:10] <Juerd_> The context the op itself is in it cannot determine

[19:10] * nothingmuch always saw scalar as the smushtogether or count operator in perl5

[19:10] <Juerd_> nothingmuch: Splat is for distributing a list to multiple non-slurpy parameters

[19:11] <Juerd_> While list just provides list context where otherwise you'd have scalar conetxt

[19:11] <nothingmuch> do we have a 'splat' keyword?

[19:11] <Juerd_> I don't believe so

[19:11] <Juerd_> low precedence splat doesn't make sense either, I think

[19:11] <nothingmuch> right

[19:11] <Juerd_> The very rare occasion you want to splat two things, double * makes much more sense

[19:12] <Juerd_> That is: foo(*@foo, *@bar) makes more sense than foo(splat @foo, @bar)

[19:12] <Juerd_> Making low precedence splat is easy though

[19:12] <Juerd_> macro splat { "*" . @_.perl }

[19:12] <Juerd_> eh

[19:12] <Juerd_> macro splat { "*" ~ @_.perl }

[19:13] <Juerd_> I'm not sure if that'd work for rw args

[19:13] <Juerd_> Holy $bovine, 74 nicks in this channel already!

[19:13] <rg0now> Sorry folks, I can not really follow you. Though, I will be lurking around here and report, if I can get reverse to work, eventually

[19:14] <Juerd_> rg0now: See t/op/reverse.t

[19:14] <Juerd_> rg0now: That's how we want it to work, eventually

[19:15] <rg0now> oh, the test, I always forget to use...

[19:15] <autrijus> ok, I think I fixed it.

[19:15] <Juerd_> The way reverse currently works isn't complete

[19:15] <autrijus> testing.

[19:15] <Juerd_> Hmmm

[19:15] <rg0now> ok, currently this reverses everything, even list elements: my @l = =open@ARGS[0]; @l = reverse @l; print @l;

[19:15] <Juerd_> Don't you all agree that ~@array should return join('', @array) instead of join(' ', @array)?

[19:16] <Juerd_> OR that reverse LIST in scalar context should also join on ' ', not ''?

[19:16] <Juerd_> And that current design is inconsistent?

[19:17] <Juerd_> rg0now: Can you please not use open in simple examples? @l = <foo bar> is much easier to understand

[19:18] <Juerd_> Are you saying that that prints raboof instead of barfoo?

[19:18] <rg0now> ok, now I see that it is in todo, sorry folks...

[19:19] <Juerd_> Answer, please

[19:19] <autrijus> rg0now: try again.

[19:19] <autrijus> I think you'll be happy.

[19:19] <rg0now> ok, here is the test code: my @l = <foo bar>; @l = reverse @l; say @l;

[19:19] <autrijus> 18 out of 23 works now.

[19:19] <rg0now> prints: rab oof

[19:19] <Juerd_> autrijus: Exciting

[19:19] <autrijus> please update to r617 and resume your discussion.

[19:20] <autrijus> also, help me in finding out why the 5 are failing.

[19:20] <autrijus> i.e. passing in the wrong context.

[19:20] * autrijus goes back to journaling

[19:21] * nothingmuch mailed p6l about O::R::L style behavior

[19:21] <rg0now> it seems to work with r617, the result is: barfoo

[19:21] * autrijus reminds folks that Pugs stands for "Perl6 User's Golfing System"

[19:22] * Juerd_ never really understood the name

[19:22] <autrijus> so only golf-driven development can do it justice :)

[19:22] <rg0now> ok, I am going back to PerlMonks for golfing on...

[19:22] <nothingmuch> and who the hell uses OOP in golf?

[19:22] <autrijus> :))

[19:22] <nothingmuch> all my tests were for nothing?!

[19:23] <autrijus> uh. perl6 will make using oop in golf much more competitive.

[19:23] <autrijus> as will fp

[19:23] <autrijus> it won't be always regex now!

[19:23] <autrijus> the other schools will have a chance!

[19:23] <nothingmuch> well, maybe for complex golfs

[19:23] <autrijus> and especially us unicoders!

[19:23] * autrijus grins

[19:23] <nothingmuch> but oop syntax is anything but concise

[19:23] <nothingmuch> ah

[19:23] <nothingmuch> that is something

[19:23] <nothingmuch> hyper and junctions are probably the most golfy features ever

[19:24] <jabbot> pugs - 617 - * a different set of reverse.t tests fai

[19:24] <autrijus> riight

[19:24] <Juerd_> nothingmuch: I use Data::Swap in Perl 5 to change an object's state

[19:24] <autrijus> so nondet school will have its day

[19:24] <autrijus> in fact I expect p6 golf to be much much more fun than p5.

[19:24] <Juerd_> nothingmuch: For example, in DBIx::Simple, I swap existing objects for DBIx::Simple::Dead for objects that no longer serve any purpose, but do have references to them

[19:24] <nothingmuch> ah

[19:24] <nothingmuch> puurdy

[19:25] * nothingmuch makes note, especially for recent dabblings with stevan and lazy subclasses of Tree::Simple

[19:25] <nothingmuch> thanks, Juerd!

[19:25] <Juerd_> Welcome as always

[19:27] <nothingmuch> i wonder why no one mentioned Data::Alias when i needed it

[19:27] <nothingmuch> but with a much more vague name

[19:28] <nothingmuch> Array::RefElem got the job done

[19:32] <Juerd_> p6l consulted re lists in scalar context

[19:33] <autrijus> Juerd_: good. I was about to.

[19:33] <Juerd_> Eh, no

[19:33] <Juerd_> p6l consulted re lists in STRING context

[19:33] <Juerd_> Sorry

[19:33] <autrijus> ah. I'll followup as needed anyway.

[19:33] <Juerd_> Hm

[19:33] <Juerd_> That's weird tohugh

[19:33] <Juerd_> though

[19:33] <Juerd_> I've requested something strange

[19:34] <Juerd_> scalar reverse LIST should of course be an arrayref

[19:34] <Juerd_> 4~reverse "LI", "ST" should be TSIL

[19:36] <lucs> Er, can you prefix that with some non-Unicode please?

[19:36] <Juerd_> It's non unicode

[19:36] <Juerd_> It's IRC colouring

[19:36] <lucs> Oh :)

[19:36] <Juerd_> <red>~</red>reverse

[19:36] <Juerd_> I suggest you seek a more capable IRC client

[19:36] <lucs> You want me to have color, eh.

[19:36] <Juerd_> Yes, it has very practical use

[19:36] * Juerd_ hates colour abuse as much as everyone else

[19:37] <lucs> You're probably right :)

[19:37] <lucs> Anyway, you were saying  ~reverse ...

[19:38] <Juerd_> See p6l

[19:38] <lucs> Okay, thanks.

[19:38] <nothingmuch> autrijus: are there any docs explaining how pugs is implemented?

[19:38] <Juerd_> Just after typing the first message, autrijus' comment made me realise I had been careless when composing it.

[19:38] <lucs> (I'm not spending enough time following all this.)

[19:38] <Juerd_> Neither am I

[19:39] <Juerd_> I'm thinking of the details of how things work in Perl 5 and 6

[19:39] <Juerd_> While most people are discussing only the new features

[19:39] <autrijus> nothingmuch: PA02.

[19:39] <Juerd_> Which don't intruige me as much

[19:39] <Juerd_> I'm still looking for a better Perl 5

[19:40] <nothingmuch> which is being written as we speak?

[19:40] <autrijus> yes.

[19:40] <Juerd_> Instead of a new language. Autothreading, MMD, ML, etc., will all come and I'll start learning them as soon as Perl 6 is in useful state.

[19:40] <autrijus> will be published at end of March.

[19:40] <autrijus> probably debutted at YAPC::Taipei.

[19:40] <autrijus> March 27

[19:40] * Juerd_ doesn't join these big discussions about that

[19:41] <Juerd_> And is still thinking on a syntactic level of strings and numbers.

[19:41] <autrijus> pugs is already dangerously close to an useful state :)

[19:41] <Juerd_> #1/usr/bin/pugs

[19:41] <Juerd_> How - who wrote that :)

[19:42] <autrijus> you!

[19:42] <Juerd_> No

[19:42] <autrijus> or nothingmuch?

[19:42] <Juerd_> I didn't write the initial reverse.t

[19:42] <Juerd_> I only added some tests to ti

[19:42] <autrijus> fixed.

[19:42] <Juerd_> it

[19:42] <Juerd_> Hm

[19:42] <autrijus> er.

[19:42] <Juerd_> Yes, but have we now both fixed the same thing?

[19:42] <autrijus> you beat me to it.

[19:42] <Juerd_> Heh.

[19:42] <autrijus> journal up.

[19:42] <autrijus> I'll sleep now. :)

[19:42] <nothingmuch> which file is that?

[19:43] <Juerd_> Neat, /me goes to read

[19:43] <autrijus> or at least, try to

[19:43] <nothingmuch>  [syeeda:/usr/local/src/pugs] nothingmuch % svn blame t/op/reverse.t

[19:43] <nothingmuch>    601 nothingmuch #1/usr/bin/pugs

[19:43] <Juerd_> Rest well, autrijus 

[19:43] * autrijus waves &

[19:43] * nothingmuch always does crap like that

[19:43] <nothingmuch> sorry

[19:43] <nothingmuch> good night, autrijus!

[19:43] <nothingmuch> thanks for all the haskell help today!

[19:43] <rg0now> Folks! I have just uploaded the final Golf scripts to PerlMonks. It seems to work pretty nice, feel free to add them to the tests...

[19:43] <rg0now> have a nice Perl 6 hacking...

[19:43] <nothingmuch> rg0now: do you have commit access?

[19:43] <rg0now> no I don't

[19:44] <nothingmuch> well, why don't you get some, and do it yourself?

[19:44] <nothingmuch> it's easy

[19:44] <autrijus> right.

[19:44] <rg0now> might I write a series of tests out of it?

[19:44] <nothingmuch> err, one minute

[19:44] <autrijus> give me your email.

[19:44] <nothingmuch> yes you may

[19:44] <nothingmuch> and i will be glad to help

[19:44] <rg0now> [email@hidden.address]
[19:44] <rg0now> where should I put the tests?

[19:44] <autrijus> Schwern! you're in golfer's realm now! :)

[19:44] <rg0now> I men, inot which dir?

[19:44] <Schwern> Great

[19:45] <rg0now> :-)))

[19:45] <nothingmuch> well, uh

[19:45] <autrijus> t/golf/santa/

[19:45] <autrijus> ;)

[19:45] <rg0now> ok

[19:45] <autrijus> if not in test form, examples/golf/

[19:45] <autrijus> (I don't really know.)

[19:45] <nothingmuch> what about t/ext/golf/santa?

[19:45] <autrijus> ext?

[19:45] <nothingmuch> i think that's a better place to put 'generic' tests

[19:45] <nothingmuch> extra, external, whatever you want

[19:45] <nothingmuch> t/bonus/golf

[19:45] <nothingmuch> maybe that is nicer ;-)

[19:46] <nothingmuch> like perl5's japhs

[19:46] <nothingmuch> they are sort of stress tests

[19:46] <Juerd_> We need the examples to be tests

[19:46] <nothingmuch> golfs and japhs usually annoy the parser

[19:46] <Juerd_> I'll see if I can think of a way

[19:46] <nothingmuch> Juerd_: i'm thinking we should keep them as they are mostlyh

[19:46] <nothingmuch> perhaps refactor

[19:46] <nothingmuch> and unit test the examples

[19:46] <Juerd_> nothingmuch: As they are, yes

[19:46] <nothingmuch> thus testing both the examples and pugs

[19:46] <Juerd_> But included in the test suite.

[19:46] <Juerd_> Still in the examples directory and all

[19:46] <Juerd_> But where output is static, it can be tested

[19:47] <Juerd_> And their compilation should always succeed

[19:47] <nothingmuch> hmm

[19:47] <autrijus> yup

[19:47] <autrijus> at least test compilation.

[19:47] <nothingmuch> well, what about t/bonus/examples/progname.t containing unit tests for examples?

[19:47] <Juerd_> Nothing is as shameful as having examples that don't work :)

[19:47] <autrijus> I'll leave the layout for you. but no "bonus" please :)

[19:47] <Juerd_> nothingmuch: I was thinking of examples/output/scriptname

[19:47] <Juerd_> And t/examples.t which tests them all

[19:47] * autrijus really sleep &

[19:47] <nothingmuch> i tried doing that with exegesis 02's program

[19:48] <nothingmuch> but had too many features that were not yet ready

[19:48] <nothingmuch> ciao autrijus!

[19:48] <nothingmuch> Juerd_: but then that file may bloat

[19:48] <autrijus> rg0now: invitation sent. welcome aboard

[19:48] <nothingmuch> if it really does unit test

[19:48] <Juerd_> nothingmuch: Not really

[19:48] <Juerd_> nothingmuch: It tests compilation for each, and output for those of which static output is known

[19:48] <Juerd_> Nicely generating a plan of @examples + @outputs

[19:48] <nothingmuch> why not take it one step further?

[19:48] <nothingmuch> put it in t/examples/sanity.t

[19:49] <Juerd_> What'd that do?

[19:49] <nothingmuch> exactly what your t/examples.t

[19:49] <Juerd_> I'm not suggesting duplicating ANY of the example code

[19:49] <nothingmuch> but with t/examples/send_more_money.t checking that it actually works

[19:49] <nothingmuch> no, not duplicating

[19:49] <Juerd_> Why one test script per example?

[19:49] <Juerd_> Why not write one very simple harness for it?

[19:49] <nothingmuch> unit tests for the actual functions therein

[19:49] <Juerd_> And store output with pugs $example > output/$example

[19:50] <Juerd_> Hm

[19:50] <Juerd_> Okay, you do that, I do this :)

[19:50] <nothingmuch> ok

[19:50] <Juerd_> Why argue if we can have both :)

[19:50] <nothingmuch> maybe you should todo t/examples.t with backticks and todo_ok?

[19:50] <nothingmuch> we could argue this is golf driven development and autrijus will implement backticks by the time we wake up tomorrow

[19:51] <Juerd_> Hm

[19:51] <Juerd_> Does pugs support pipes yet even? :)

[19:51] <nothingmuch> hmm

[19:51] <nothingmuch> maybe we should port IPC::Run

[19:51] <Juerd_> And spawning processes etc

[19:51] <stevan> pugs does read files and can eval strings :)

[19:51] <nothingmuch> we do have system()

[19:51] <Juerd_> stevan: Ah! good point!

[19:51] <stevan> but that might blow up

[19:51] <nothingmuch> i think

[19:51] <Juerd_> Now, does it have glob or readdir?

[19:51] <stevan> yeah I think we have system 

[19:51] <Juerd_> We can hard code this for now

[19:51] <nothingmuch> stevan: Tree::Simple lazification made sane:

[19:52] <nothingmuch> no Object::Realize::Later crap

[19:52] <stevan> nothingmuch: ok

[19:52] <stevan> I assume you have been thinking about it more

[19:52] <nothingmuch> enter Data::Swap (really Data::Alias) (Juerd_++, xmath++)

[19:52] <stevan> nothingmuch: I am not familiar with it

[19:52] *** Juerd_ is now known as Juerd

[19:52] <Juerd> Good point

[19:52] * stevan goes to CPAN and looks

[19:53] <nothingmuch> not really, i have been thinking about personal issues mostly

[19:53] <nothingmuch> and work

[19:53] <nothingmuch> and hiking

[19:53] <nothingmuch> neither was I

[19:53] <stevan> nothingmuch: yeah, my parents are down visiting, so my time has been limited

[19:53] <stevan> that and I was trying to hack a kwid2pod converter 

[19:54] <jabbot> pugs - 618 - s/#1/#!/

[19:54] <stevan> so I can at least see my kwid :P

[19:55] <nothingmuch> demerphq's new japh is way cute:

[19:55] <nothingmuch> perl -Mre=debug -e "/just|another|perl|hacker/"

[19:57] <nothingmuch> Juerd: for unit testing I propose each example script should have a sort of marker

[19:57] <nothingmuch> err, maybe

[19:57] <Juerd> No

[19:57] <Juerd> Example scripts should be pure and have no indication they're anything more than examples.

[19:57] <nothingmuch> and we could eval everything but the thing that runs the actual demo

[19:57] <Juerd> We're practically testing documentation

[19:57] <nothingmuch> so how test we they?

[19:58] <nothingmuch> both Test::Output?

[19:58] <nothingmuch> and unit tests, in one?

[19:58] <Juerd> I've no idea what you mean even.

[19:58] <nothingmuch> err, nevermind then

[19:58] <nothingmuch> i'll find something clever to do

[19:59] <nothingmuch> how do i capture stdout in pugs given current devel?

[19:59] <nothingmuch> is there any test doing that?

[20:00] <Juerd> nothingmuch: http://tnx.nl/3650AZSG

[20:01] <nothingmuch> pretty

[20:02] <Juerd> It doesn't at al work though

[20:02] <Juerd> at all

[20:03] <Juerd> autrijus: I don't think $_.foo should interpolate, or should it?

[20:04] <Schwern> It should, IMHO.  Dunno what p6l decided.

[20:04] <Schwern> Else you're once again stuck writing "Your name is "_$_.name_"\n"

[20:04] <Schwern> Instead of the more natural "Your name is $_.name\n"

[20:05] <Schwern> ie. make accessors as easy to use as hash keys

[20:06] <Juerd> "Your name is {.name}"

[20:06] <Juerd> "Your name is {$_.name}"

[20:06] <Schwern> Ahh

[20:06] <Schwern> Eh.

[20:06] <nothingmuch> $*OUT = open(">examples/output/quicksort");

[20:06] <nothingmuch> require "examples/quicksort.p6";

[20:06] <Juerd> Scary, but you will get used to it.

[20:06] <nothingmuch> isn't that supposed to get me what I want?

[20:07] <Juerd> WEIRD

[20:07] <Juerd> I have REALLY WEIRD behaviour here

[20:07] <Juerd> I'll commit so you can have a look

[20:08] <Juerd> done; r619

[20:08] <Juerd> Run t/examples.t

[20:08] <Juerd> Why is it iterating over only fp and quicksort?

[20:08] <Juerd> Hm

[20:09] <Juerd> <> isn't <.*> with greedy .*, right? :)

[20:09] <Juerd> Uh oh. Let's see.

[20:09] <Juerd> No, can't be.

[20:09] <Juerd> @outputs is properly declared.

[20:11] <nothingmuch> i get 1 .. 10

[20:11] <Juerd> That is correct

[20:11] <Juerd> After that, I get:

[20:11] <Juerd> 1 ok # skip: Try to compile fp.p6

[20:11] <Juerd> 2 ok # skip: Try to run fp.p6 and compare to output/fp

[20:11] <Juerd> 3 ok # skip: Try to compile quicksort.p6

[20:11] <Juerd> 4 ok # skip: Try to run quicksort.p6 and compare to output/quicksort

[20:12] <Juerd> Which makes absolutely no sense

[20:12] <nothingmuch> only 4

[20:12] <Juerd> What happens to hanoi?

[20:12] <Juerd> And the others?

[20:12] <lightstep> i thought hanoi never worked

[20:12] <nothingmuch> oddly, 'for (@examples){ say $_ }' works

[20:13] <Juerd> lightstep: That's irrelevant right now, as I'm not even executing

[20:13] <Juerd> Or even compiling

[20:13] <Juerd> I'm just iterating over hard coded arrays...

[20:14] <jabbot> pugs - 620 - fixed stupid hardcoding

[20:14] <jabbot> pugs - 619 - Adding stub for testing examples. Weird 

[20:14] <nothingmuch> could it have something to do with 'expr if blah?'

[20:14] <nothingmuch> when i comment if ($_ eq any(@outputs)) { }; it works

[20:14] <Juerd> No, hanoi is in outputs

[20:14] <nothingmuch> but with 'if ($_ eq any(@outputs)) { };', nothing in the block, it doesn't

[20:14] <nothingmuch> good point

[20:15] <nothingmuch> and shuffle/life aren't

[20:26] <nothingmuch> how would you implement listary zip?

[20:26] <nothingmuch> in haskell

[20:26] <nothingmuch> i can get binary going

[20:26] <nothingmuch> map head lists?

[20:26] <lightstep> transpose?

[20:26] <nothingmuch> what does that mean?

[20:27] * nothingmuch is a haskell noob

[20:27] <lightstep> transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]

[20:27] <nothingmuch> hmm

[20:28] <nothingmuch> i don't have a transpose

[20:28] <nothingmuch> where does it come from?

[20:29] <lightstep> it's in List

[20:30] <nothingmuch> thanks

[20:40] * nothingmuch tries zip.t op

[20:45] <nothingmuch> how do i specify a list of lists?

[20:45] <nothingmuch> in pugs internals?

[20:45] <Juerd> They don't exist.

[20:45] <Juerd> Oh.

[20:46] <Juerd> I don't know.

[20:46] <nothingmuch> i.e., greater list comma?

[20:46] <nothingmuch> op1 "zip" = return . VList . foldr (++) [] . transpose . VListOfList . vCast

[20:46] <nothingmuch> err, sort of

[20:49] * nothingmuch gives autrijus nightmares, so he wakes up and comes to IRC

[20:49] <Juerd> That's un-nice.

[20:50] <nothingmuch> it's for a good cause ;-)

[21:01] <lightstep> foldr (++) [] = concat

[21:02] <nothingmuch> ah

[21:02] <nothingmuch> maybe there is a 'zip_like_pugs_would_like_to' builtin too

[21:03] <nothingmuch> lightstep: are you familiar with how pugs represents it's data types?

[21:03] <lightstep> i looked at the source twice

[21:04] <lightstep> what is VListOfList ?

[21:05] <nothingmuch> imaginary

[21:05] <nothingmuch> the zip operator takes arrays like this: zip(@a;@b;$c)

[21:06] <nothingmuch> tr/$/@/

[21:06] <lightstep> if VList is always guarenteed to be a synonym to [Val], you can use id

[21:06] <nothingmuch> i'd like to feed that list, [[@a], [@b], [@c]] to transpose

[21:06] <nothingmuch> what is id?

[21:06] <nothingmuch> brb phone

[21:06] <lightstep> the identity function

[21:07] <Khisanth> hrm that was a couple of pages ago :)

[21:07] <nothingmuch> id :: forall a. a -> a

[21:08] <nothingmuch> what does that mean?

[21:08] <lightstep> that it works for any type of argument

[21:08] <lightstep> you can feed it value of whatever type, and it returns something of the same type

[21:09] <nothingmuch> so is it a no-op?

[21:09] <lightstep> no, it's useful in a situation with combinators, for example

[21:09] <nothingmuch> got a reference i could slurp?

[21:10] <lightstep> haskell.org/onlinereport

[21:10] <nothingmuch> thanks

[21:12] <lucs> Juerd: Try this:  http://tnx.nl/3651DNDH

[21:13] <Juerd> "Learn at least a half dozen programming languages. Include one language that supports class abstractions (like Java or C++), one that supports functional abstraction (like Lisp or ML), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), one that supports coroutines (like Icon or Scheme), and one that supports parallelism (like Sisal)."

[21:13] <Juerd> I believe that's the old fashioned version of: Learn Perl 6

[21:13] <Juerd> http://www.norvig.com/21-days.html

[21:14] <integral> Haskell also fits quite a few of those

[21:14] <Juerd> lucs: EEEEEEEEEk.

[21:14] <lucs> :-)

[21:14] <Juerd> for is descructive!?!

[21:14] <Juerd> !!?!!!

[21:14] <Juerd> (Enough drama.)

[21:14] <lucs> There's your examples.t bug in a nutshell.

[21:15] <Juerd> Great detective work

[21:16] <nothingmuch> !!?!!! is an op i've not yet heard of

[21:16] <Juerd> nothingmuch: !!?!!!expr is just !(!(?(!(!(!(expr))))))

[21:17] <nothingmuch> i wasn't serious, Juerd... =)

[21:17] <Juerd> ?!!?$foo is just a very elaborate way of saying ?$foo, but documenting that you're surprised about it being true ;)

[21:17] <Juerd> die if ?!!?$foo

[21:17] <qmole> lol

[21:17] <Juerd> It's the symbolic equivalent of WTF?!

[21:17] * theorbtwo waits for somebody to create a $foo!? suffix operator...

[21:18] <Juerd> Hm

[21:18] <Juerd> !? ::

[21:18] <Juerd> Or, better

[21:18] <Juerd> ?! ::

[21:18] <Juerd> $foo ?! die :: "pfew"

[21:18] <theorbtwo> ...which dies unless it's argument is true.

[21:18] <Juerd> hee hee

[21:19] <nothingmuch> i think ?! should be ternary ?? ::

[21:19] <nothingmuch> but with ?? die implied

[21:19] <Juerd> p6l

[21:20] <Juerd> hm

[21:20] <Juerd> In fact, POSTFIX ?! is probably more useful

[21:20] <Juerd> For assertions

[21:20] <Juerd> With postfix ? for the other way around

[21:20] <Juerd> open "/etc/shadow" ?;

[21:20] <Juerd> Nahh

[21:21] <Juerd> We need :(, which implies ;

[21:21] <nothingmuch> open "/etc/shadow" ?; asserts that it must work or we die?

[21:21] <theorbtwo> Er, when I said "suffix", I meant postfix.

[21:21] <Juerd> open "/etc/shadow" :(

[21:21] <theorbtwo> print "foo" ?!;

[21:21] <theorbtwo> Means print "foo" or die.

[21:21] <Juerd> postfix and suffix are the same word :)

[21:21] <lucs> Where's the best place to report the "$_ $_" in 'for' bug?

[21:21] <nothingmuch> except that sufix can't send email

[21:21] <theorbtwo> Nah, suffix = prefix | postfix

[21:21] <theorbtwo> Wait, no, that's afix.

[21:22] <Juerd> lucs: an autrijus's alarm clock

[21:22] <theorbtwo> You're right.

[21:22] <lucs> Oh, he reads scrollback, eh.

[21:22] <Juerd> dunno

[21:22] <nothingmuch> unless we create  suffix op

[21:22] <theorbtwo> Oh, apparently Gaim isn't the only client that thinks this is utf8.

[21:22] <lucs> autrijus: Please check out: http://tnx.nl/3651DNDH

[21:22] <nothingmuch> it is utf8

[21:23] <theorbtwo> say "foo" ;

[21:24] <Khisanth> nothingmuch: that op looks like an envelope :)

[21:24] <nothingmuch> it is an envelope

[21:25] <nothingmuch> it's the suffix complimentary to postfix

[21:25] <nothingmuch> =D

[21:25] <nothingmuch> . o O ( the only language whose operators have configuration files )

[21:25] <nothingmuch> morning, castaway!

[21:25] <Juerd> Hm

[21:26] <nothingmuch> joining the herd?

[21:26] <Khisanth> nothingmuch: PHP didn't do that yet? :)

[21:26] * castaway just wanted totell nothingmuch that the suffix/postfix joke was very funny

[21:26] <Juerd> We have spies!

[21:26] <nothingmuch> Juerd: uhuh, theorbtwo is it

[21:27] <nothingmuch> Khisanth++

[21:27] <Juerd> That much was guessable

[21:27] <nothingmuch> castaway: thankyou *bow*

[21:27] * castaway has eyes everywhere!

[21:27] <Juerd> afk  # sudden terrible pain

[21:29] <castaway> .. and all was quiet ..

[21:30] * nothingmuch whines

[21:30] <nothingmuch> my posts to p6l never generate replies

[21:30] <castaway> p6l?

[21:30] <nothingmuch> [email@hidden.address]
[21:31] * theorbtwo hopes Juerd is OK.

[21:32] <theorbtwo> learn p6l as [email@hidden.address]
[21:33] <theorbtwo> perlbot, learn p6l as [email@hidden.address]
[21:33] <perlbot> added p6l to the database

[21:33] <lightstep> perlbot: p6l

[21:33] <perlbot> [email@hidden.address]
[21:33] * castaway musters the perlbot

[21:33] <lightstep> perlbot, help

[21:33] <perlbot> Syntax: (fact) :: tell (who) about (what) :: (who) > (what) :: learn (what) as (info) :: relearn (fact) as (info) :: facts (search term) :: shorten (url) :: shorten it :: search (module) :: docs (module) :: perldoc -f (function) :: math :: fortune :: flip :: host (type) (record) :: rot13 :: roll (die) :: tempconv (temp) :: scramble (text) :: 8ball :: slap :: diss :: what time is it :: highest karma  :: lowest karma

[21:34] * theorbtwo notes that you can /msg perlbot.

[21:36] <nothingmuch> Juerd: is the destructive for bug tested for?

[21:38] <nothingmuch> lucs: maybe you?

[21:39] <lucs> Not that I know of. Where would such a test go? It's just not supposed to do that :)

[21:39] <nothingmuch> r621

[21:40] <lucs> My example doesn't show where exactly things are going wrong either. Is it in the stringification?

[21:40] <nothingmuch> i don't think so

[21:40] <nothingmuch> the test case I wrote uses push

[21:44] <jabbot> pugs - 621 - Test for a weird bug that Juerd found an

[21:45] <theorbtwo> Who does jabbot belong to?

[21:46] <theorbtwo> ...and can they fix it to give full changelog entries?

[21:46] <Khisanth> theorbtwo: gugod probably :)

[21:46] <theorbtwo> ...or at least postpend a '...'?

[21:46] <castaway> append.

[21:46] <nothingmuch> suffix ;-)

[21:46] <theorbtwo> Er, right.

[21:47] <nothingmuch> what is an appix?

[21:47] <nothingmuch> sounds like some kind of energy bar

[21:47] <castaway> or suffend?

[21:47] <theorbtwo> Thats affix.

[21:47] <Khisanth> nothingmuch: sounds like an insect

[21:47] <theorbtwo> affix = prefix | postfix

[21:47] <castaway> das ende vom suff ,)

[21:47] <nothingmuch> appix = append -> fix

[21:48] <nothingmuch> it is suffix ~~ $_ ~~ postfix

[21:48] <nothingmuch> i think

[21:48] <theorbtwo> Not to be confused with applix.

[21:48] <nothingmuch> (does ~~ chain?)

[21:48] <castaway> hmm Applix

[21:48] <theorbtwo> Yes.

[21:48] <Khisanth> Applix - yet another linux distro!

[21:49] <theorbtwo> \\n   Bool      chain   ~~      (Any, Any)\

[21:49] <castaway> An office variant

[21:51] <steveq> Hi there, quick pugs question: Does it support sorting of lists yet? If so what's the syntax, i couldn't spot it in the t/ directory

[21:57] <nothingmuch> err, maybe @list.sort { $^a cmp $^b }

[21:57] <nothingmuch> but i don't think it's there yet

[21:58] <nothingmuch> you can use examples/quicksort.t for now ;-)

[21:58] <wolverian> that'd need to be .sort:{...}

[21:58] <steveq> nothingmuch: yeah, i spotted that one

[21:58] <nothingmuch> cmp is there

[21:59] <nothingmuch> wolverian: want to test, or should I?

[21:59] <steveq> nothingmuch: and also <=>?

[21:59] <nothingmuch> uhuh

[21:59] <nothingmuch> t/op/relational.t

[21:59] <theorbtwo> Hmm, so we have enough to implement sort!  Very cool.

[21:59] <wolverian> nothingmuch: I can't now. I'm stuck on a windows computer that isn't mine. :/

[21:59] <nothingmuch> i'll try to get to it

[21:59] <steveq> When I saw you'd done reverse it seemed the next step ;-)

[22:00] <rg0now> might I ask something now, or do I disturb anything?

[22:00] <theorbtwo> Ask away.

[22:00] <nothingmuch> rg0now: always

[22:00] <steveq> We need the schwartzian transform in perl6 :-)

[22:00] <rg0now> I seemed to find a bug with =<> operator

[22:00] <rg0now> as TimToady pointed out at perlmonks

[22:00] <rg0now> this might work as the meagical <> in Perl5

[22:01] <theorbtwo> .sort should ST if it wants to by itself.

[22:01] <rg0now> so it might read from the file named in the first command line argument in some cases

[22:01] <Khisanth> oooh a fish operator! :)

[22:01] <rg0now> :)

[22:01] * Juerd can barely type

[22:01] <steveq> theorbtwo: that would be nice

[22:01] <nothingmuch> >==x>

[22:01] <Juerd> nothingmuch: No, but examples.t shows it

[22:01] <rg0now> I maen this: my@l= =<>; should read from ARGG[0]

[22:01] <rg0now> isn't it?

[22:02] <Juerd> steveq: No, sort automatically caches 

[22:02] <Juerd> So no need for an ST

[22:02] <nothingmuch> Juerd: committed as r621 to t/base/for.t

[22:02] <Juerd> afk

[22:02] <nothingmuch> ciao!

[22:08] <theorbtwo> Ugh.  I just asked ghci to show me Prim.initSyms.

[22:08] <theorbtwo> Now my head hurts.

[22:09] <nothingmuch> does @foo = sort { } @array

[22:09] <nothingmuch> remain the same?

[22:09] <nothingmuch> and should @array.sort dwim for num vs. str values?

[22:10] * nothingmuch thinks sort will not be too difficult to do

[22:10] <nothingmuch> given op2Grep and op2Map

[22:10] <nothingmuch> and the fact that List has sortBy

[22:10] <nothingmuch> which is basically the same

[22:11] <lightstep> how do i tell svk to get files from openfoundry.org instead of perl.org?

[22:11] <steveq> If the list has a numerical type will it automatically do a numeric comparison instead of a string cmp?

[22:11] <nothingmuch> lightstep: i think you do funny stuff to your depotmap

[22:11] <nothingmuch> but that's where my knowlege ends

[22:12] <nothingmuch> i use darcs normally

[22:12] <nothingmuch> and svn temporarily for pugs

[22:12] <nothingmuch> steveq: more than that

[22:12] <nothingmuch> if the list is basically all nums or all strings

[22:12] <nothingmuch> without explicit declaration

[22:12] <steveq> nothingmuch: excellent, where can I read about this?

[22:12] <nothingmuch> will the right thing be done?

[22:13] <steveq> I looked in the synopses but i couldn't find it clearly explained

[22:13] <nothingmuch> steveq: read about what?

[22:13] <nothingmuch> ah,

[22:13] <nothingmuch> i'm asking myself

[22:13] <nothingmuch> (luqui | Juerd)->answer

[22:14] <castaway> does yourseld know?

[22:14] <jabbot> pugs - 622 - small update to AUTHORS and MANIFEST - n

[22:21] <theorbtwo> You know, I could have sworn that one of the [AES]es had lots of data on sort.

[22:23] <steveq> I have to go now, I'll take a look at the irc logs tomorrow, thanks

[22:23] <nothingmuch> ciao, steveq!

[22:26] * nothingmuch sees that it's not that trivial to create op2Sort

[22:26] <Darren_Duncan> While I can't name anyone in particular, I suspect that a number of people who committed to Pugs aren't in the AUTHORS file -- they should probably be added prior to 6.0.11 going out

[22:27] <Darren_Duncan> since svn handles are often different from real names, I can't easily figure out who's missing and add them

[22:27] <Darren_Duncan> or do you know an easy way?

[22:27] <nothingmuch> err

[22:27] <nothingmuch> google the handles?

[22:28] <Darren_Duncan> I suppose, but that could take awhile

[22:28] *** lightstep_ is now known as lightstep

[22:28] <Khisanth> add a test that will always fail telling people to add their name :)

[22:28] <Darren_Duncan> I considered posting to p6c a reminder message to do that -- what do you think?

[22:30] <integral> do you have a list of nicks that are missing?

[22:30] <Darren_Duncan> no because I haven't found an easy way to determine them

[22:30] <integral> ah

[22:30] <Darren_Duncan> I'll post to p6c a reminder

[22:34] <nothingmuch> anybody with subetha edit and haskell skills want to help?

[22:35] <theorbtwo> Well, I have two halves of those.

[22:36] <nothingmuch> theorbtwo: har

[22:37] <theorbtwo> I've got SEE on a PearPC, and some haskell knowladge.

[22:38] <nothingmuch> well, see woobling.org

[22:38] <Darren_Duncan> How is PearPC -- the performance acceptable?

[22:38] <crysflame> .

[22:38] <theorbtwo> Workable for me.

[22:38] <Darren_Duncan> ok, the reminder notice is posted to p6l -- simplest solution

[22:39] <theorbtwo> P4/3GHz/HT.  YMMV.

[22:39] <Darren_Duncan> I see

[22:39] <Juerd> stevan: Probably. And in general, $foo.cmp($bar)

[22:39] <Darren_Duncan> oops, I meant p6c, not p6l

[22:39] <castaway> tis a tad slower on the 2ghz machine

[22:39] <Juerd> stevan: All speculation, though.

[22:39] <Juerd> stevan: This is a good question for p6l

[22:40] <Darren_Duncan> I posted to p6c since that was the most Pugs-specific

[22:41] <nothingmuch> Juerd or someone- please sanify t/op/sort in 1 minute

[22:42] <Juerd> sanify?

[22:42] <nothingmuch> make sure it tests correct things

[22:43] <Juerd> Comma between closure argument and slurpy list is not optional afaik

[22:43] <nothingmuch> S06 seems to imply that sorting an array filled with numbers will dwim correctly

[22:43] <nothingmuch> sort {}, @foo?

[22:43] <Juerd> You're not testing multi-condition sorts

[22:43] <Juerd> Yes

[22:44] <Juerd> And sort [ {}, {}, {}, ... ] <== @foo

[22:44] <nothingmuch> ah

[22:44] <jabbot> pugs - 623 - Sort of guesswork test

[22:44] <Juerd> I'll forward you a message I got from Damian if you want.

[22:44] <nothingmuch> which is instead of { $^a[0] <=> $b^[0] or $a^[1] <=> $^b[1] }?

[22:44] <nothingmuch> sure

[22:44] <Darren_Duncan> which test file is array *comparison* done in?

[22:45] <nothingmuch> Darren_Duncan: theoretically smartmatch.t

[22:45] <nothingmuch> Test's is routines will stringify

[22:45] <nothingmuch> and since the values are simple stringification is a good enugh test

[22:45] <nothingmuch> enough

[22:46] <Juerd> nothingmuch: You have 2 messages.

[22:46] <Darren_Duncan> okay then

[22:46] <nothingmuch> maybe it should really be ok(@a eq @e)

[22:46] <nothingmuch> grazie, Juerd

[22:46] <nothingmuch> why is multi criteria split up, btw?

[22:46] <Juerd> prego

[22:47] <Juerd> split?

[22:47] <nothingmuch> well, err

[22:47] <nothingmuch> made possible

[22:47] <nothingmuch> i mean, isn't sort with one comparison block good enough?

[22:47] <Juerd> No

[22:48] <Juerd> Because of the dwimmery

[22:48] <Juerd> { .<foo> }

[22:48] <Darren_Duncan> a single block should certainly be tested

[22:48] <Darren_Duncan> it's the least that's needed

[22:48] <Juerd> That is actually { $^a<foo>.cmp($^b<foo>) }

[22:50] <nothingmuch> err

[22:51] <nothingmuch> i'm thinking maybe i'll fix the sort {}, @a

[22:51] <nothingmuch> and leave the more complicated stuff to others

[22:51] <theorbtwo> With no block, you mean?

[22:51] <nothingmuch> because i just noticed i'm dropping dead

[22:51] <theorbtwo> Is that even defined?

[22:51] <nothingmuch> t/Synopsis/S06.pod:    @nums ==> grep { $_ % 2 } ==> sort ==> map { $_**2 } ==> @oddsquares;

[22:51] <theorbtwo> Larsen, is your proper name Stefano Rodighiero for the AUTHORS file?

[22:52] <nothingmuch> theorbtwo: uhuh

[22:52] <larsen> theorbtwo: yes.

[22:52] <larsen> AUTHORS of what ? :)

[22:52] <nothingmuch> pugs

[22:52] <theorbtwo> Pugs, of course.

[22:53] <larsen> largely exagerate, but thanks

[22:53] <theorbtwo> You have a checkin, so you go in AUTHORS.

[22:57] <crysflame> oooo

[22:57] <crysflame> nothingmuch: that's very nice to see. :)

[22:57] <nothingmuch> crysflame: eh?

[22:57] * Juerd feels so smart after his latest post to p6l :)

[22:58] <crysflame> 14:52 @nums

[22:58] <Juerd> Now all that's left is watch the idea get smashed and bashed... :)

[22:59] <nothingmuch> Juerd: rhs quoting will probably be confusing

[22:59] <nothingmuch> what if it's a listop?

[22:59] <Juerd> nothingmuch: Why will it be?

[22:59] <nothingmuch> f // @list?

[22:59] <Juerd> That's WEIRD syntax

[22:59] <Juerd> Then just make it &f

[22:59] <nothingmuch> because things that look quoted are bound to be treated as such by the user

[23:00] <nothingmuch> i meant sort of like s//

[23:00] <Juerd> nothingmuch: As I said, think of s///

[23:00] <nothingmuch> but with a replacement list

[23:00] <nothingmuch> not a replacement string

[23:00] <Juerd> AND, they'll very quickly understand it.

[23:00] <Juerd> One problem I have with sprintf now is that you need 2 sets of delimiters, nested.

[23:01] <Juerd> sprintf4(10"%03d %15s10", @foo4)

[23:01] <Juerd> hm

[23:01] <Juerd> sprintf4(10"%03d %15s10", @foo4)

[23:01] <Juerd> Stupid colour parsing of ^C,

[23:01] <crysflame> where'd you copy that from?

[23:02] * Juerd doesn't understand the question

[23:02] <theorbtwo> Hmm, now missing 5 people for AUTHORS.

[23:02] * nothingmuch would like to see format extensions to sprintf

[23:02] <crysflame> how did you syntax colorize perl on irc?

[23:02] <Juerd> crysflame: With IRC colours.

[23:02] <nothingmuch> that allow duplicating stuff

[23:02] <crysflame> manually?

[23:02] <theorbtwo> (00:01:20) Juerd: Stupid colour parsing of ^C,

[23:02] <Juerd> Yes

[23:02] <nothingmuch> a bit like unpack

[23:02] <crysflame> o

[23:02] <crysflame> nevermind

[23:02] <nothingmuch> anywho

[23:03] <nothingmuch> i'm falling asleep

[23:03] <nothingmuch> good night

[23:03] <Juerd> Bye nothingmuch 

[23:03] <theorbtwo> G'night.

[23:03] * crysflame bows

[23:03] <larsen> ciao nothingmuch 

[23:03] <nothingmuch> i don't know how to make zip(@a;@b;@c) be a list of VLists

[23:03] <castaway> -

[23:03] <nothingmuch> if anyone wants to try, here is prelim fscking of op1 "zip":

[23:03] <castaway> night asleep

[23:03] <nothingmuch> op1 "zip" = return . VList . concat . transpose . vCast

[23:04] <nothingmuch> autrijus must help us tomorrow

[23:04] <jabbot> pugs - 624 - test: sort {} @a -> sort {}, @a

[23:04] <Juerd> nothingmuch: ;?!

[23:04] <nothingmuch> ?

[23:04] <nothingmuch> oh

[23:04] <nothingmuch> luqui said so, Juerd

[23:04] <nothingmuch> i much prefer @a  @b  @c myself

[23:04] <Juerd> rationale?

[23:04] <nothingmuch> err

[23:04] <nothingmuch> i don't know

[23:04] <Juerd> I prefer @a Y @b Y @c

[23:04] * theorbtwo wonders if alinbsp == Alin Iacob == ALIN.

[23:05] <Juerd> It took months before I got what I wanted with Y

[23:05] <nothingmuch> you basically mush a multidimentional array into a one dimentional zipped one

[23:05] <nothingmuch> sort of

[23:05] <Juerd> After even proposing z to just get \w ascii into people's minds

[23:05] <theorbtwo> Y is an alias for  now?

[23:05] <Juerd> Yes! :)

[23:05] <Juerd> (I proposed z when unicode broken bar was zip)

[23:05] <nothingmuch> but Y doesn't have the funky zipper like graphical qualities ;-)

[23:06] <Juerd> does too

[23:06] <Juerd> It's just not as detailed

[23:06] <nothingmuch> hah

[23:06] <theorbtwo> Doesn't nearly as much, but it is rather easier to type.

[23:06] <nothingmuch> anywho

[23:06] <nothingmuch> on macs it's just alt instead of shift

[23:06] <nothingmuch> anywho, Juerd - duke on p6l on zip(@a;@b)

[23:06] <nothingmuch> i'm off

[23:06] <theorbtwo> 

[23:06] <theorbtwo> D'oh.

[23:06] <Juerd> "duke"?

[23:07] <Juerd> It's compose + Y + - here

[23:07] <Juerd> Or compose + Y + =

[23:07] <theorbtwo> Um... perhaps sounds like "look" if you're used to Hebrew?

[23:07] <Juerd> eh, not +

[23:07] <Juerd> compose, Y, -

[23:07] <Juerd> Not all at the same time :)

[23:07] <Juerd> 2776 messages

[23:08] <theorbtwo> You know, I really ought to mess with my keyboard map to make the key next to left shift into compose.

[23:08] <Juerd> Not going to search if I have no idea what to look for

[23:08] <Juerd> "zip" is too broad

[23:08] <theorbtwo> ...since I'm using an en-us keymap.

[23:08] <Juerd> I use right alt

[23:08] <theorbtwo> "zip(@a;@b)"

[23:08] <Juerd> Labeled Alt Gr

[23:08] <theorbtwo> I don't; I like keeping both my alt keys alt keys.

[23:08] <Juerd> Right alt doesn't do anything left alt does anyway.

[23:08] <theorbtwo> It does on an en-us layout.

[23:08] <Juerd> Weirdness!

[23:09] <theorbtwo> Not really.  en-us is the best keyboard layout; all others are just bad copies.

[23:09] <theorbtwo> ;)

[23:09] <Juerd> No, en-us implies qwerty

[23:09] <Juerd> And that S U C K S

[23:09] <theorbtwo> You have a certian point.

[23:09] <Juerd> www.dvorak.nl!

[23:09] <Juerd> (my site)

[23:10] <theorbtwo> Hmmpf, Gaim tries to consider the ! part of the domain name.

[23:11] <theorbtwo> Hm, your shifted digits are straight en-us.

[23:11] <theorbtwo> []/{} are moved up a row, though.

[23:11] <Juerd> Oh, that's because I'm using *US* Dvorak

[23:11] <Juerd> Localized versions exist

[23:12] <theorbtwo> Ah.  I also wondered why it was missing umlouted vowels.

[23:12] <Juerd> Because Dutch doesn't have umlauts

[23:12] <Juerd> We have tremas, which are essentially the same thing, but with a very different purpose

[23:13] <Juerd> The glyph is called diaeresis

[23:13] <Juerd> It's an umlaut when it's german-like in changing the sound of a vowel, only.

[23:13] <Juerd> Webster's has a VERY weird definition though :)

[23:13] <Juerd>      2. A mark consisting of two dots [[umlaut]], placed over the

[23:13] <Juerd>         second of two adjacent vowels, to denote that they are to

[23:13] <Juerd>         be pronounced as distinct letters; as, co["o]perate,

[23:13] <Juerd>         a["e]rial.

[23:14] <Juerd> "umlaut" has nothing to do with that particular function of diaeresis

[23:14] <castaway> interesting

[23:14] <theorbtwo> They're using "umlaut" to be a generic term for the mark, it would seem.

[23:14] <theorbtwo> I agree with you that they are wrong.

[23:15] <Juerd> Anyway, diaereses for vowel separatation are mostly unneeded

[23:15] <Juerd> I've been Dutch all my life, but only in more formal writings I use them.

[23:15] <theorbtwo> I quite agree, and they are very rarely used.

[23:15] <theorbtwo> Er, in English, I meant.

[23:15] <Juerd> They're not official English.

[23:16] <Juerd> They are officially mandatory in Dutch.

[23:16] <theorbtwo> People use a dash when they assume the audience can't tell.

[23:16] <Juerd> For example, Belgium is Belgi

[23:16] <Juerd> But 99% just type Belgie

[23:16] <theorbtwo> There is no official English.

[23:16] <Juerd> Which would literally be pronounced as Belgee

[23:16] <castaway> Queens English, of course!

[23:16] <Juerd> theorbtwo: In fact, there are several :)

[23:17] <theorbtwo> They used to be common in English, a few hundred years ago.

[23:17] <Juerd> That's when Dutch and English were still dialects of the same language

[23:18] <theorbtwo> Juerd, nothingmuch said he meant duke as in duke it out.

[23:18] <Juerd> I don't know what that means though

[23:18] <castaway> fight

[23:18] <theorbtwo> Right.

[23:19] <Juerd> I've spammed p6l too much for one day already.

[23:19] <Juerd> Someone else do it.

[23:19] <theorbtwo> That's OK, it looks like what is now in is great:

[23:19] <castaway> put your dukes up - boxing, because it was originally for (umm.. die adel ;)

[23:19] <theorbtwo> zip(), infix , or infix Y.

[23:20] <Juerd> I don't know the English word for adel

[23:20] <theorbtwo> Annoyingly, BTW, on a xfree86 german keymap, yen in altgr-shift-<key where Y is on an en-us>.

[23:20] <castaway> its not occuring to me either ,)

[23:20] <theorbtwo> Even though that key produces a Z without the altgr.

[23:20] <castaway> gentry, nobility

[23:21] <theorbtwo> Thus, the Marquis of Queensbury rules.

[23:21] <castaway> right

[23:21] <castaway> (ok, explained that oen to death ;)

[23:21] <Juerd> 00:25 <@Juerd> !travlang dutch english adel

[23:21] <Juerd> 00:25 <+cu2q> Juerd: [adel] 1. nobility

[23:22] <Juerd> Travlang agrees.

[23:22] <castaway> nice

[23:22] <castaway> leo weiss alles

[23:22] <Juerd> Nah, too german :)

[23:22] <Juerd> Adel's dutch too

[23:22] <castaway> I figured

[23:22] <Juerd> weisst btw

[23:22] <theorbtwo> What was that you were saying about dialects of the same languge?

[23:22] <castaway> leo weisst? nah

[23:22] <Juerd> Not?

[23:23] <castaway> no

[23:23] <Juerd> Hm.

[23:23] <castaway> Ich weiss, Du weisst, Er weiss

[23:23] * castaway scratches head.

[23:23] <Juerd> Stupid irregular verbs

[23:25] <Juerd> http://tnx.nl/3652HDKB  # travlang script

[23:25] <Juerd> For those who like it.

[23:25] <obra>  hi

[23:25] <Juerd> hi

[23:25] <castaway> low

[23:26] * obra debates between trying to do tests for vstrings in pugs and trying to refactor the perl5 debugger a bit

[23:27] <obra> instead of all my work

[23:27] <pjcj> Isn't mjd rewriting the debugger?

[23:28] <theorbtwo> Meh, I should figure out that whole "where to stop" thing.

[23:29] <theorbtwo> I added all the committers to AUTHORS.

[23:29] <theorbtwo> Now I'm considering going back and adding the proper (non-romanized) spellings of their names.

[23:29] <castaway> bah enough already ;)

[23:29] <Juerd> theorbtwo: Do so in the -1st column

[23:30] <Juerd> theorbtwo: As to not mess up formatting for non-utf8 terminals

[23:30] <Juerd> It's a good idea anyway.

[23:33] <Juerd> 

[23:33] <Juerd> That's my name :P

[23:33] <castaway> umm, thank you

[23:33] <castaway> in ?

[23:34] <Juerd> utf8, I hope?

[23:34] <jabbot> pugs - 625 - Lots of updates.  Now lists all committe

[23:34] * castaway no have utf8

[23:35] <theorbtwo> Eeep, I really did give that stupid of a commit message.

[23:35] <crysflame> i see a UTF bom character

[23:35] <crysflame> that's utf8 without terminal support for it

[23:35] * crysflame argues with his terminal

[23:36] <Khisanth> Waa|boer?

[23:37] <Khisanth> Juerd: are the J and W suppose to be differently colored?

[23:37] <Juerd> Waalboer

[23:37] <Juerd> No, but I don't mind :)

[23:50] <theorbtwo> Hmmpf.

[23:50] <theorbtwo> CPAN::Shell kills wide characters for me.

[23:50] <castaway> borken

[23:50] <theorbtwo> It thinks AUTRIJUS's ->fullname is 'Autrijus Tang'.

[23:51] <Juerd> search.cpan.org, copy, paste

[23:52] <theorbtwo> That sounds like work.

[23:52] <theorbtwo> And not the fun kind.

[23:52] <castaway> WWW::Mechanize it

[23:52] <Juerd> Outsource it to India

[23:52] <theorbtwo> Was planning on it.  More or less.

[23:52] <theorbtwo> Juerd++

[23:52] <theorbtwo> And they probably even know how to deal with utf8 there.

