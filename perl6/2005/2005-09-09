[06:24] <autrijus> migrating from p4, that's the first command we found missing

[06:24] <autrijus> so clkao implemented it right away :)

[06:24] <autrijus> it'd be "svk desc YYYY" 

[06:24] <svnbot> r6886 | autrijus++ | * fix kind error for ghc 6.5

[06:25] <luqui> ghc 6.5 you say?

[06:25] <autrijus> -devel

[06:25] <GeJ> hello gentlemen, good morning

[06:25] <autrijus> greetings GeJ.

[06:25] <gaal> i heard good things about p4. might try to use it in a setting where no "scary OSS" is allowed one day.

[06:25] <luqui> autrijus, making pugs depend on 6.5 is not allowed :-)

[06:25] <autrijus> luqui: sure.

[06:25] <luqui> come to think of it

[06:25] * gaal giggles

[06:25] <luqui> what are the 6.4 features that pugs uses?

[06:26] <autrijus> luqui: but breaking it for 6.5 would be unfortunate

[06:26] <luqui> of course

[06:26] <autrijus> luqui: GADT, STM, TH

[06:26] <luqui> oh wow, those are all new to 6.4?

[06:26] <autrijus> yeah.

[06:26] <autrijus> well, TH was seriously revamped

[06:27] <autrijus> the other two were new

[06:27] * luqui likes GADT

[06:27] <gaal> have to go for a while. see you later!

[06:27] <luqui> the proposal I sent to sixperl had a vague proposal of GADT embedded in the middle of it

[06:27] <autrijus> cool. dependent types is indeed handy

[06:28] <luqui> so, when you say "dependent types"...

[06:28] <luqui> what exactly are you referring to

[06:28] <luqui> (making sure I didn't miss an important feature or something)

[06:29] <autrijus> ok. in untyped lambda calculus, or in "dynamic languages"

[06:29] <autrijus> we have anonymous functions

[06:30] <autrijus> and function application

[06:30] <autrijus> which is terms depending on other terms

[06:30] <autrijus> (1+2) is a term that the value depends on the value of terms 1, + and 2

[06:30] <luqui> gotcha

[06:30] * spinclad (recognizes the other two, forgets what TH is)

[06:30] <autrijus> spinclad: Template HAskell

[06:31] <spinclad> ah, thx

[06:31] <autrijus> luqui: and in polymorphism, we have term depending on types

[06:31] <autrijus> that is, the type of arguments dictates at runtime which function variant gets fired

[06:31] <autrijus> including MMD etc 

[06:31] <autrijus> then we also have type operators

[06:31] <autrijus> --> (+) (-)

[06:31] <autrijus> which is types depending on types

[06:31] <autrijus> the value of (Int --> Str) depends on the value of Int and Str

[06:32] <luqui> comprendo

[06:32] <autrijus> finally, completing the cube

[06:32] <autrijus> we have types depending on terms!

[06:32] <autrijus> which is called dependent types

[06:32] <luqui> eg

[06:32] <autrijus> consider a "case" expression over a GADT

[06:33] <autrijus> data Term a where

[06:33] <autrijus> data Term a where

[06:33] <autrijus>     Cond    :: Term Bool -> Term a -> Term a -> Term a

[06:33] <autrijus>     Succ    :: Term Int -> Term Int

[06:33] <autrijus>     IsZero  :: Term Int -> Term Bool

[06:33] <autrijus> the term -- or rather the constructor of the term -- at runtime

[06:33] <autrijus> dictates the types of the type in "a" position

[06:33] <autrijus> which is why we can write typesafe

[06:33] <autrijus> eval :: Term a -> a

[06:34] <luqui> okay good

[06:34] <autrijus> here's a helpful link: http://en.wikipedia.org/wiki/Lambda_cube

[06:34] <luqui> I grokked all that, but I didn't see that nice symmetry or have any vocabulary for it

[06:35] <luqui> hmm, would you like me to bounce you the proposal so you can sanity check it, amend important stuff before @Larry butcher it, etc?

[06:35] <autrijus> sure thing

[06:35] <luqui> it's mostly an incomplete brain dump of the stuff i'm thinking about "theories" and whatnot

[06:35] <luqui> but it outlines the ideas

[06:35] <autrijus> nod

[06:36] <autrijus> do get a copy of TaPL and ATTaPL if you have the chance :)

[06:36] <luqui> uh, @acronyms>>.expand please

[06:37] <autrijus> Types and Programming Languages

[06:37] <luqui> n/m

[06:37] <luqui> oh, just out of time

[06:37] <autrijus> Advanced Topics on $&

[06:37] <autrijus> I mean $/

[06:37] <GeJ> !$

[06:38] <luqui> ?

[06:38] <luqui> ??!!

[06:38] <GeJ> oops, sorry, that was shell... wrong channel. My mistake

[06:39] <luqui> autrijus, will do

[06:40] <luqui> it's not too heavily academic is it?

[06:40] * luqui loses interest in dry academic prose quickly

[06:40] <autrijus> nope, it's extremely hands on

[06:40] <autrijus> with concrete implementations interleaved with discussion

[06:40] <gaal> it's been known to get people to implement interpreters that turned into compilers, though.

[06:40] <autrijus> indeed.

[06:41] <luqui> well, we want a little of both right?

[06:41] <autrijus> luqui: 

[06:41] * gaal goes off for real   &

[06:41] <autrijus>     sub min(::T *@values --> ::T | Ord[::T]) {

[06:41] <autrijus> mm junctive types ;)

[06:41] <luqui> that's not a junction

[06:41] <luqui> it's like => in Haskell

[06:41] <autrijus> oh wow

[06:41] <luqui> but on the other side where it belongs

[06:41] <autrijus> more overloading

[06:41] <autrijus> of symbols

[06:41] <luqui> | doesn't exist anymore

[06:42] <autrijus> sub min(::T *@values --> ::T where Ord[::T]) {

[06:42] * autrijus ponders

[06:42] <spinclad> gaal: well, that's natural enough, do enough partial evaluation and you may end up with a compiler without noticing

[06:42] <luqui> oh, I mean as a junctive type constructor

[06:42] <autrijus> nvm -- I just thought | is packed with 'or' in perl6

[06:42] <luqui> gotcha

[06:42] <luqui> that "where" seems to go with the ::T, not with the whole signature

[06:43] <luqui> anyway, it's not a syntax proposal

[06:43] <autrijus> indeed

[06:47] <autrijus> &

[07:02] <dduncan> hello campers!

[07:02] <dduncan> s/hello/good morning/

[08:16] <svnbot> r6887 | Darren_Duncan++ | /ext/Locale-KeyedText : resynced with the final Perl 5 version 1.6.0, just released on CPAN

[08:23] <dduncan> fyi, I have now just uploaded the first complete set of my Perl 5 modules on CPAN that have 3-part version numbers, indent with spaces rather than tabs, and have various other non-functionality-changing (they are fully backwards compatible) improvements ... this is the first batch of changes that is exclusively/mainly for applying Perl Best Practices (tm)(r)(etc) to my Perl 5 work, for the community's benefit ... also, any of these comp

[08:42] <dduncan> for those who care, but don't know what I'm referring to, it is these new distros, soon to reach your favorite CPAN mirror: Locale-KeyedText-1.6.0, SQL-Routine-0.70.0, Rosetta-0.48.0, SQL-Routine-SQLBuilder-0.21.0, SQL-Routine-SQLParser-0.2.0, Rosetta-Engine-Generic-0.21.0

[08:49] <gaal> autrijus, ping

[08:49] <integral> why do they need three part version number?

[08:50] <dduncan> those are a lot more expressive

[08:50] <acme__> sure all version numbers are evil?

[08:51] <integral> dduncan: Have you changed the way you do releases of bugfixes to use the new level of numbering?

[08:51] <dduncan> its easier to tell major from intermediate from minor releases

[08:51] <dduncan> under the new system, I will release bug fixes as changes to the minor-most digit, and large feature adding changes as changes to the middle digit

[08:52] <dduncan> before now, nearly every release was a change to a single digit, whether major or minor

[08:52] * luqui uses a revision-like version number scheme

[08:52] <luqui> just because it's easier for me that way

[08:52] <luqui> and nobody really cares

[08:52] <dduncan> there's an additional advantage

[08:52] <luqui> three-part is better though... if I did care

[08:53] <dduncan> and that is if I want to release more than 29 more versions of SQL::Routine before I tick over to version 1-point-oh

[08:53] <dduncan> under the new system, it is perfectly valid to have 0.114.0, for example

[08:53] <dduncan> and they'll sequence correctly with 0.98.0 etc

[08:54] <spinclad> re: ping: ssh! he's sleeping!

[08:54] <gaal> oh, is he?

[08:54] <dduncan> fyi, my very next planned set of releases are mainly just for running these through Perltidy (didn't do that yet), and the version nums for those will be an increment of the minor-most digit

[08:54] <gaal> i didn't think he was because i didn't see any commits from him.

[08:55] <dduncan> I may perhaps rewrap my POD at 78 chars rather than the current 80 chars as well, for the same reasons that is suggested for code

[08:56] <dduncan> one reason is, you get a level of quoting in email without wrapping

[08:56] <dduncan> and another is, apparently, some terminals are effectively just under 80 chars wide, not fully 80 chars

[08:56] <spinclad> or, well, maybe not.  thinking home-centrically, but US East != .tw.  but i think you've thoroughly refuted me.

[08:57] <gaal> dduncan, may as well make it 75 and have quoted patches not wrap. :-)

[08:59] <dduncan> thanks for bringing that up now ... I prefer to get the new width right/best on the first attempt ... and 75 is a rounder number anyway ... thanks!

[09:01] <dduncan> my next update round will involve this re-wrapping, and my first run ever of Perltidy 

[09:02] <luqui> ?eval sub infix:<@@> ($x, $y) { $x + $y }   3 @@ 4

[09:02] <evalbot_6887> 7 

[09:03] <gaal> 75 is a rounder number than 78? 64, that's a round number.

[09:04] <luqui> I say 78 is rounder than 75, but 88 is rounder than both

[09:04] <dduncan> yes, but 88 is also wider than 80

[09:05] <dduncan> I'm going to go with 75, unless someone convinces me that is too *wide*

[09:05] <gaal> i say it's a pity code can't be made to wrap beautifully automatically, and then there would be no need for a limit anyway.

[09:06] <luqui> ?eval sub infix:<!@^%> ($x, $y) { $x + $y }  3 !@^% 4

[09:06] <evalbot_6887> 7 

[09:06] <dduncan> maybe this can be accomplished, with Perl programs anyway, if Perltidy is tied into the email program, so it can auto-wrap *correctly*

[09:06] <gaal> in our age of wide terminals 75 cols for code is *usually* too little, *but* wrapped code is so horrible that it's reasonable to make a limit, and 75 is as good a limit as they come.

[09:07] * Khisanth hates horizontal scrolling

[09:07] <gaal> i'm pretty sure it can be made correctly, but also pretty sure it can't be made beautifully.

[09:07] * integral tries to remember what the line length is for handwriting

[09:07] <dduncan> there's also the advantage in regards to *printing* ... if one wants to print, they know the code won't wrap on paper, regardless of how wide your screen is

[09:07] <gaal> sure, same problem.

[09:07] <gaal> only with a higher price on horizontal scrolling.

[09:08] <gaal> :)

[09:08] <dduncan> anyway, its 2am here, so I'm going to bed in 10 mins or so, good night

[09:08] <kakos> ?eval sub infix:<a> ($x, $y) { $x + $y }  3 a 4

[09:08] <evalbot_6887> 7 

[09:09] <gaal> night.

[09:10] <luqui> ?eval 3 eqv 3

[09:10] <evalbot_6887> bool::true 

[09:10] <luqui> ?eval 3.0 eqv 3

[09:10] <evalbot_6887> bool::false 

[09:10] <luqui> darn

[09:12] <luqui> ?eval sub infix:<@@> is tighter(&infix:<*>) ($x, $y) { $x + $y }    3 * 4 @@ 5

[09:12] <evalbot_6887> Error:  unexpected "(" expecting trait or block 

[09:12] <luqui> hmm... darn

[09:13] * luqui jots that down on his dog todo

[09:13] <gaal> are you making a dog?

[10:42] *** Aankh|Clone is now known as Aankhen``

[11:39] <rindolf> Hi all!

[11:39] <rindolf> autrijus: here?

[12:06] <autrijus> rindolf: yes?

[12:07] <gaal> ugh, three ghc versions, none of them build pugs on my box any more :-(

[12:07] <gaal> autrijus, hi. have time to talk about lexical pragmas?

[12:08] <autrijus> gaal: I don't think I have brain for that yet, sorry. maybe after a nap or three -- say, 5hrs from now

[12:08] <autrijus> <- totally consumed by errands today

[12:09] <autrijus> but feel free to type ahead

[12:09] <gaal> okay, i'll be arond in ~7-8hrs myself, i hope my own brain holds.

[12:09] <autrijus> okay, deal

[12:09] <autrijus> nap &

[12:12] <rafl> gaal: The debian package with perl5 embedding works quite well, btw.

[12:12] <rafl> gaal: The only problem I have is that the pugs::run and pugs::hack manpages are simply empty. I can't reproduce that outside the chroot, though. Any ideas?

[12:13] <gaal> typing ahead: i read mjd's proposal, patch, and followup discussions on p5p, and i think i more or less understand this. i first need help mapping this to pugs concepts (eg: an op/COP is what in pugs, an Exp?), possibly modify the design if there's any need, and eventually no doubt with some practical haskell.

[12:13] <gaal> rafl++ # great news!

[12:14] <gaal> re the empty manpages, absolutely no idea. can you strace and see what files are being accessed?

[12:15] <rafl> Yes. I think I'll try that today. I'm currently not at my development box.

[12:17] <gaal> a fully-featured pugs binary in debian would be awesome. It's much easier for people to 'apt-get install pugs' than 'apt-get install ghc-cvs ; cpan Perl6::Pugs' and start tweaking. this will surely bring new hackers, or even just curious p5 users to look at p6.

[12:32] <rindolf> autrijus: hi!

[12:32] <rindolf> autrijus: we discussed Perl 6 and pugs in #perl.

[12:34] <rindolf> autrijus: why does $a,$b,$c=1,2,3 assigns only to $c while my @array=4,10,20

[12:34] <rindolf>  assigns to @array? How do the precedences of "=" and "," relate to each other?

[12:35] <gaal> rindolf, he's taking a nap

[12:35] <rindolf> gaal: I see.

[12:35] <gaal> (hi)

[12:35] <rindolf> gaal: hi, what's up?

[12:36] <gaal> all's well :)

[12:36] <rindolf> gaal: that's good.

[12:42] * Juerd keeps wondering why rindolf continually misses basic things like, in this case, precedence

[12:42] <integral> I thought at one point p6's , was going to have difference precedence to p5's?

[12:45] <Juerd> It was considered for a short while

[13:03] <autrijus> agreat! the home server that serves autrijus.org was just up in smokes

[13:03] <autrijus> apparently the power supply burned itself up for fun :-/

[13:04] <Juerd> Why does so much of your hardware fail?

[13:04] <Juerd> Bad power lines?

[13:04] <autrijus> I wish I know why

[13:04] <autrijus> :-(

[13:07] <rafl> autrijus: Hello, I'd like to know which sources and object files are needed to be installed for pugs to be working. I think the object files are needed to be linked to the generated haskell code to form the pugs haskell runtime (integral told me that). Are the source files also used in some way?

[13:08] <svnbot> r6888 | fglock++ | * lazy_lists.t - more tests, TODO list

[13:09] <autrijus> rafl: theoretically only interfaces (.hi) and object files (.o) are needed, but since pugscc currently uses -make instead of -lpugs

[13:09] <autrijus> that means the .hs files needs to be around as ewll.

[13:09] <autrijus> if we manage to build a libpugs.a

[13:09] <autrijus> then all the .hi .o and .hs would be unneccesary

[13:11] <rafl> That would be much nicer. Is someone working on that already?

[13:11] <autrijus> no.

[13:12] <autrijus> not as far as I'm aware, that is

[13:13] <rafl> Thanks for clarification!

[13:57] <svnbot> r6889 | fglock++ | * PIL-Run - Test.pm is more verbose

[13:57] <svnbot> r6890 | fglock++ | * lazy_lists.t - svn properties, plan()

[14:05] <vkon> was recent change ??:: to ??!! intentional? not only much test fail, but that is harder to remember IMHO...

[14:05] <vkon> ... I mean ternary operator that was '?' in P5 

[14:06] <QtPlatypus> vkon: Yes it was.

[14:06] <QtPlatypus> The idea is so that :; can be used unambiously for other things.

[14:09] *** mml_ is now known as mml

[14:15] <vkon> QtPlatypus: that's fine...  you mean there were difficulties with '::' when dealing with package names separator?

[14:16] <QtPlatypus> Nore when people where going ::<$varname> 

[14:17] <integral> vkon: much test fail?  I tried to change as many as possible, but if you've found ones that I've missed, feel free to fix them

[14:20] <PerlJam> integral: What's blib6 for exactly?  None of the files in there appear to have changed ??:: to ??!!

[14:20] <PerlJam> (perhaps that's what vkon is talking about)

[14:20] <integral> PerlJam: o_O  I thought it was a perl6 version of blib

[14:21] <vkon> integral: sorry for I didn't analyzed that matter deeply, because I run tests and go sleep, and only checked results briefly, and I can look deeper later.

[14:21] <integral> I very possibly missed lots of ??::s

[14:21] * integral sets up to run the test suite

[14:22] * PerlJam decides to look at a clean pugs checkout for the first time in a loooong time.

[14:22] <integral> ugh, tests are slow :-(

[14:23] <vkon> t/rules/rules.t alone takes many minutes to run...  I think may be it's reasonable groups within that file that are anyway fail, into one single expandable group, and this way try to reduce compiling time for t/rules/rules.t

[14:25] <vkon> t/rules/rules.t  compiles slowly because it is 100+Kb in size...  I think no-one will be against if I will reorganize that file so it will at least be faster in compiling time, with probably using groups of evals, or somesuch...

[14:29] <integral> only failure is in t/subroutines/lvalue_subroutines so far

[14:30] <xerox> Hey!

[14:30] <xerox> Do you know where is the "Powered by Ph.D" image? :)

[14:30] <vkon> integral: my pugs,ghc are at home, so I can't share my information, and, of course, my speculations on ??!! could perfectly be false alarms...

[14:31] <integral> vkon: Well, it's really my fault.  I should have run the tests myself last night

[14:33] <vkon> ok, I'll go now and will return with faster t/rules/rules.t file...

[15:26] <svnbot> r6891 | Stevan++ | Perl6::MetaModel 2.0 - just commiting because I am going to upgrade my OS

[15:39] <svnbot> r6892 | putter++ | PIL-Run - improved timeout.  But smoke-perl5 still requires 3 manual interventions.

[15:45] <gc_mnc> yo

[15:46] <gc_mnc> is there way to do something like `` with pugs 6.2.9 without doing it all by hand?

[15:48] <fglock> putter: ping

[16:09] <svnbot> r6893 | fglock++ | * PIL-Run - reverse() works for Str and Array

[16:11] <putter> fglock: pong

[16:11] <fglock> I had a bit of trouble finding out the problem in reverse() - but not it's ok, thanks

[16:12] <putter> ok

[16:13] <putter> are you going to be around this weekend?  i'm doing a no-jobsearch weekend, so I thought if we, steven, iblech, et al, were around, we might push PIL-Run to plausibility.

[16:13] <fglock> sure - it's raining here :)

[16:14] <putter> its 30% now, without lexicals.  +10% for rx:perl5, which should only require mm'izing Match, and $0...$9 aliases.

[16:14] <putter> :)

[16:15] <putter> if mm support for packages and modules exists (does it?), it would be nice to get that nailed down.

[16:15] <fglock> how about start migrating to mm2?

[16:15] <putter> if a simple "use p5 lexicals work" (more in a moment), doing lexicals should be straightforward.  if not, more work.

[16:15] <putter> is mm2 ready for it?

[16:17] <fglock> mm2 has packages and modules, afaik.

[16:17] <fglock> using p5 lexicals would be nice

[16:17] <putter> re lexicals, autrijus, anyone, - does anyone know what exactly the changes in lexical scoping are between p5 and p6?  It would be nice to use p5-with-hacks.  but if there are gotchas, we might need to do something more indirect.

[16:19] <putter> stevan: any cries of "no! dont use mm2 yet!"?

[16:20] <putter> fglock: sure, let's try mm2.  do you want to look into it?

[16:21] <fglock> I wrote some tests in t/data_types/lazy_lists.t - I'm trying to make some more to pass - I'll take a look in mm2 in a moment

[16:21] <putter> autrijus, anyone: similarly, are there any known gotchas in how p6 does control flow (next, last, return, exceptions) which make it non-straightforward to use p5 equivalents with hacks.

[16:21] <putter> k

[16:22] <fglock> re: control flow - there are coroutines and continuations

[16:22] <putter> my weekend is still 5-ish hours away from beginning, so I wont be intense until then.

[16:24] <putter> full-(non-escape-)continuations I believe are optional.  but regardless, doing them would require either CPS transform, with really bad speed implications, good compilation which wont exist for a while, or maybe we can get lucky with a hack.  The last would need a working non-full system anyway, so I thought we'd focus on that first.

[16:26] <putter> re coro... any of the p5 Coro modules do something plausible?

[16:27] <fglock> autrijus said it would be slow to use p5 Coro - he didn't say it doesn't work :)

[16:27] <putter> :)

[16:27] <integral> Coro has the issue that you can't clone a continuation

[16:28] <wolverian> Coro also has the issue that it has never worked for me!!!

[16:28] <integral> it's only worked for me on MacOSX

[16:28] <wolverian> I've only tested Linux 2.[46].

[16:29] <fglock> btw, it would be nice to be able to clone closures (for lazy lists)

[16:29] <putter> fglock: do we have closures yet? ;)

[16:30] <putter> we sort of create one hanging off of Sub and Code

[16:30] <svnbot> r6894 | iblech++ | * Usual svn props.

[16:30] <svnbot> r6894 | iblech++ | * Perl6-MetaModel2.0: docs/misc_drawings.txt: s/\s*$//

[16:30] <svnbot> r6894 | iblech++ | * Test improvements:

[16:30] <svnbot> r6894 | iblech++ |   * t/01-sanity/07-try.t: Added the most basic try{} test.

[16:30] <svnbot> r6894 | iblech++ |   * t/operators/binding/{arrays,hashes}.t: @foo := @bar does not create new

[16:30] <svnbot> r6894 | iblech++ |     containers (and same for hashes).

[16:30] <svnbot> r6894 | iblech++ |   * t/builtins/numify.t: +"Inf ", +"3 ", +"NaN\t", etc.

[16:30] <putter> iblech: btw, thanks for your 07-mumble tests.  they were very useful.

[16:31] <putter> ok, clone-able closures for lazy lists.

[16:31] <fglock> well, map() works if you don't look too closely

[16:32] <putter> ;)

[16:33] <wolverian> ?eval do if 1 { "a" } else { "b" }

[16:33] <evalbot_6894> 'a' 

[16:33] <wolverian> ?eval my $foo = do if 1 { "a" } else { "b" }

[16:33] <evalbot_6894> \'a' 

[16:34] * putter notes  make smoke  still requires a manual intervention to get by MIME.

[16:36] <svnbot> r6895 | iblech++ | PIL2JS:

[16:36] <svnbot> r6895 | iblech++ | * &prefix:<~> stringifies Inf and -Inf to "Inf" and "-Inf" now (instead of JS's

[16:36] <svnbot> r6895 | iblech++ |   "Infinity" and "-Infinity").

[16:36] <svnbot> r6895 | iblech++ | * &prefix:<+> numifies "Inf", "-Inf", "Inf " etc. correctly and returns 0

[16:36] <svnbot> r6895 | iblech++ |   (instead of NaN) on bogus numbers (+"abc").

[16:37] * putter pauses to appeciate svnbot

[16:37] * putter pauses to appeciate iblech :)

[16:41] <putter> fglock: any thoughts on what order things should be approached in?  mm2 transition, naming (mm2 packages and lexicals), control flow (return, next/last, ...?).

[16:42] <putter> ?

[16:43] <putter> anyone who isnt usually part of the PIL-Run insanity want to help out for the weekend?  "PIL-Run hackathon"?

[16:43] <putter> :)

[16:44] <fglock> do you have an idea how much each one of these impacts the smoke result? 

[16:44] <putter> no

[16:46] * putter tries to massage smoke log into something informative...

[16:46] <fglock> making multi subs work properly is important for Prelude; it would be nice to have lexicals and file access too; flow control is trivial if we are in p5 space

[16:47] <fglock> we can add p5-regexes to the list too

[16:49] <fglock> yesterday's Hash slice hacks have broken a few Array tests :(

[16:52] <putter> I'm afraid even a distilled snoke log is 300k.  I dont think pastbot would appreciate that. ;)

[16:52] <putter> does the mm have multi subs?

[16:53] * putter is very unclear on what the mm has working and what not...

[16:53] <fglock> Value/Code.pm has; I think mm2 has too

[16:53] <putter> k

[16:56] <pasteling> "putter" at 66.30.119.55 pasted "smoke-perl5 error log - trimmed a great deal" (2955 lines, 197K) at http://sial.org/pbot/13012

[17:00] <fglock> it looks like anything we do will improve it :)

[17:01] <putter> :)

[17:04] <pasteling> "putter" at 66.30.119.55 pasted "smoke-perl5 error log - trimmed slightly less (more informative, but huge)" (26046 lines, 467K) at http://sial.org/pbot/13013

[17:04] <svnbot> r6896 | fglock++ | * perl5/Array - fixed @a[10] := $b

[17:05] <putter> ok, on this last paste, the # lines show all the symbols occuring in the code.  An application of undef means one of them, a sub, was not defined.

[17:05] * putter should really add an "autovivifying &foo" warning.  that would greatly clarify things.  todo list.

[17:06] <putter> and I'm off.  I expect to be back in ~5 hrs, but that may slip.

[17:06] <fglock> bye

[17:06] <putter> bye &

[17:09] <svnbot> r6897 | iblech++ | PIL2JS: Prelude::JS::Operators: int(Inf), int(-Inf), int(NaN) return Inf, -Inf

[17:09] <svnbot> r6897 | iblech++ | or NaN now (instead of NaN). t/builtins/math/infinite.t passes 8/8 now.

[17:21] <svnbot> r6898 | iblech++ | * t/builtins/lists/map.t: Minor cosmetical fixes.

[17:21] <svnbot> r6898 | iblech++ | * PIL2JS: Prelude::JS::Str: &substr can be used as an method now.

[17:33] <svnbot> r6899 | fglock++ | * perl5/Scalar - auto-dereferencing in  Scalar.store(Scalar)

[17:57] <svnbot> r6900 | iblech++ | * Splitted t/builtins/lists/reduce.t into reduce.t and new

[17:57] <svnbot> r6900 | iblech++ |   t/operators/reduce-metaop.t.

[17:57] <svnbot> r6900 | iblech++ | * t/builtins/io/time.t: skip the times() test on PIL2JS.

[17:57] <svnbot> r6900 | iblech++ | * t/builtins/hashes/slice.t: =for discussion'ed test testing whether

[17:57] <svnbot> r6900 | iblech++ |   (a => 1, b => 2)<a b> works. Will ping p6l in a minute.

[17:57] <svnbot> r6900 | iblech++ | * t/builtins/arrays_and_hashes/exists.t: Cleanup and made the test not

[17:57] <svnbot> r6900 | iblech++ |   use the (mostly unspecced) stringification of pairs.

[17:57] <svnbot> r6900 | iblech++ | * t/builtins/perl.t: According to S02, a standard Perl should be able to

[17:57] <svnbot> r6900 | iblech++ |   reparse .perl's return value, added tests for this. Also added tests for

[17:57] <svnbot> r6900 | iblech++ |   recursive data structures (but had to skip the actual tests because they

[17:58] <svnbot> r6900 | iblech++ |   infloop).

[18:06] *** typester is now known as typeout

[18:32] *** typeout is now known as typester

[20:08] <gaal> hey there!

[20:09] <gaal> how is everyone?

[20:12] <dudley> Quite well. How about you?

[20:12] <gaal> not bad, not bad.

[20:13] <Aankhen``> I'm happy... it rained here and it's cooled down for the first time in a long while, and I finally found a place to download Condition Zero 1.2.

[20:13] <Aankhen``> s/\.$/ from./

[20:14] <gaal> i finished GTA SA recently. games are fun when you have more important things to do :)

[20:14] <Aankhen``> Heh.

[20:23] <gaal> A isn't around, is he?

[20:24] * Aankhen`` goes to sleep.

[20:24] <Aankhen``> G'night.

[20:25] <gaal> .sleep for %::.keys:grep{ /^A/ }

[21:08] <putter> hellllooo pugs night shift ;)

[21:09] <gaal> hey putter :)

[21:09] <fglock_> welcome back

[21:09] <putter> hi gaal, fglock

[21:10] <putter> unless anyone has better ideas, I'm going to give things a chance to be simple and add return, last, next.  then clean up thunks and try a simply my().

[21:11] <fglock_> ok

[21:12] <putter> great

[21:12] <putter> more for fun, how difficult would it be to make the Match at the bottom of PrimP5.pm into something the mm can live with?

[21:14] <fglock_> looking...

[21:15] * putter putter can't quite remember the rationale for the $xxFoo variable names in PrimP5, but keeps writing them out of inertia.  perhaps that should change.  especially if they meant "an autogenerated name which will get changed when a human touches it". ;)

[21:15] <^conner_> how is the perl6 grammar being specified in pugs?

[21:15] <svnbot> r6901 | fglock++ | * lazy_lists.t - more tests

[21:18] <putter> ^conner_: Parser.hs, haskell... err, I forget the name of the approach.

[21:20] <fglock_> putter: re Match - I'll try to move it to mm (I'm saving it to a new file)

[21:21] <stevan_> ^conner_: it uses a Haskell parser combinator library called parsec IIRC 

[21:21] <dudley> Parsec?

[21:23] <putter> fglock_: :-) !

[21:23] <^conner_> is it ebnf with attributes or something more exotic?

[21:24] <putter> http://www.cs.uu.nl/~daan/parsec.html

[21:24] <stevan_> ^conner_: much more exotic

[21:24] <stevan_> ^conner_: have a look here too  http://www.cs.uu.nl/~daan/download/parsec/parsec.html

[21:28] <^conner_> it's a bit more theory then I understand... so this is a top down parser

[21:28] <^conner_> the 'semantics' look just like attribute grammars thou

[21:30] <^conner_> the token associativity stuff looks neat

[21:33] <putter> fglock_: was there a vision of how return() in Code's... return?  a last LABEL hack?  something else?

[21:33] <svnbot> r6902 | putter++ | PIL-Run - added non-working return, next, last

[21:33] <putter> stevan_: back! :)

[21:33] <stevan_> putter: yes!!

[21:33] <putter> lol

[21:33] * stevan_ just finally upgraded to Tiger today

[21:34] <putter> ahh

[21:34] <stevan_> and I keep realizing how many things i forgot to install :)

[21:35] <stevan_> important stuff,.. like "make"

[21:35] * putter again mentions the idea of someone putting together a Bundle of pugs-required CPAN modules.  (apropos forget and install:)

[21:37] <fglock_> putter: a simple return should work - the block is called by the 'do' method in Code.pm

[21:38] <stevan_> putter: IIRC, iblech implemented all those using exceptions

[21:38] <putter> err, does return() in a Code return from the code or from the enclosing mumble?

[21:39] * stevan_ has to run and do some real world things &

[21:39] <fglock_> it returns to the do() method, which will take care of checking the returned type

[21:39] <putter> ah.  oh well.  &

[21:41] <putter> sub f() { for (3,4) -> { return 5 }; return 6; } f()

[21:41] <putter> 5

[21:41] <putter> the {} is a code, yes?  (putter goes to check)

[21:42] <putter> stevan_: will there be any pattern to your presence over

[21:42] <putter> the next two days or so?

[21:42] <fglock_> 'sub xx(){}' is a Sub

[21:43] <fglock_> '{return 5}' is a Block

[21:44] <putter>  { return 5 } is showing up as a PCode of type SubPointy

[21:44] <stevan_> putter: I will likely be doing the changelog work on sunday morning,.. but other than that,.. maybe some late night hacking (U.S. EST)

[21:44] <fglock_> we don't have SubPointy yet, but Sub should work

[21:45] * stevan_ really goes &

[21:45] <putter> ok, bye &

[21:45] <fglock_> by stevan

[21:45] <stevan_> :)

[21:46] <putter> fglock_: but Sub will (correctly) absorb the return(), yes?

[21:46] <putter> ok, backing up....

[21:47] <fglock_> yes, it should

[21:48] <putter> plain return() is insufficient (final, etc, and we're using subs internally).  two posibilities come to mind: Exceptions (stevan++), and hand threading through labels (goto et al).

[21:49] <fglock_> putter - I created a Match.pm skeleton

[21:49] <svnbot> r6903 | fglock++ | * PIL-Run - added preliminary mm version of Match class

[21:49] <fglock_> still needs moving methods to the right places

[21:49] <putter> awesome! putter goes to look...

[21:50] <fglock_> I think the overload can be kept where it is

[21:52] <putter> feel free to gut the overload, this being solely to support the mm'ed pilrun.

[21:54] <putter> neat.  though I afraid I'm not entirely clear on the next step either.   among the mm docs, is there a quickref "bootstrap is something you dont have to worry about.  for class C{} say foo, for a rw field, say bar to created it, and hee to access it.  for methods ... etc".

[21:55] <putter> let's see, where was the other thread...

[21:55] <fglock_> there are the t/ files

[21:56] <putter> oh yes.  Exceptions are simpler.  Labels are perhaps faster.  Simple wins. ;)  Exceptions, unless someone can think of a third option, or disagrees...

[21:56] <putter> t/ files?

[21:56] <putter> oh yes, to show use.

[21:56] <putter> righ

[21:56] <putter> right even

[21:57] <putter> Is Error.pm still the best place to get exceptions from?

[21:58] <fglock_> sorry - I don't know enough about Error.pm

[21:59] <putter> fglock_: is there a way to "just in time" make an object into an mm object?  with Match it didnt matter.  But if exceptions are going to be used... never mind.  control flow exceptions and die exceptions can just be different decendants of a common ancesstor.

[22:00] <putter> there is a hack currently in PrimP5 to give Exception::Simple a ->bit method, so  unless $! {...} will work.

[22:00] * putter contemplates asking #perl

[22:00] <fglock_> do you mean to make objects of an existing class? just call new()

[22:02] <putter> the original thought was to deal with (more efficiently created) native exceptions, and then coerce them if/when they needed to be touched as p6 objects.  but with return()-implementing exceptions not needing exposure to p6, die() exceptions and return() exceptions can simply be (very) different classes, one mm and one not.

[22:03] <fglock_> ok

[22:04] <putter> re Error.pm, I'll see if it cleanly wraps in ApiX, so we can easily change it later if needed.

[22:04] * putter goes to check Error.pm's cpan test, but my fuzzy recollection is it's now part of the standard distribution.

[22:09] <fglock_> finished with Match.pm - but it is not tested at all

[22:12] <brentdax> Okay, I've finished my Log::Selective module, including 21 passing tests.  Should I put it in the Pugs repo?  On FreePAN?  CPAN?

[22:12] <svnbot> r6904 | fglock++ | * PIL-Run - Match.pm - added remaining methods

[22:15] <fglock_> brentdax: how about pugs ext/ ?

[22:15] <brentdax> I can do that, certainly.

[22:15] <putter> ahh.  thank you fglock_.  fglock_++

[22:16] <putter> ext/ has the advantage that if ?? !! changes to something else...

[22:17] <putter> (it will get handled by bulk fixing)

[22:17] <brentdax> Heh.  I actually wasn't using the ternary operator anywhere, but I can certainly see the benefit.

[22:18] <putter> p6 is still in flux enough that archiving code elsewhere seems an invitation to obsolescence

[22:18] <svnbot> r6905 | brentdax++ | Add Log::Selective module.

[22:18] <Juerd> Are "item context" and "slurpy context" official yet?

[22:18] <putter> no idea

[22:20] <putter> "foo" ~~ /(.)(.)/    $/[1]  #=> Fyi: Can't locate object method "fetch" via package "Match" at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-Container/lib/Perl6/Container/Scalar.pm line 105

[22:20] <putter> ?

[22:20] <fglock_> mmm

[22:21] <putter> sorry fglock_, i didnt mean to suck you into regex land from wherever you were working on...

[22:21] <fglock_> np

[22:21] <fglock_> I know what is happenning, but I don't know how to fix it 

[22:21] <Juerd> What was the reason for calling list context slurpy?

[22:22] <Juerd> What confusion is avoided?

[22:22] <Juerd> (item context is because the difference between "scalar" and "Scalar" is annoyingly small)

[22:24] <svnbot> r6906 | putter++ | PIL-Run - from() and to() implemented as methods on Match.  Dont work yet.

[22:24] <fglock_> putter: it is fetching the match from a scalar, which is ok, but it may be using extra parameters - in this case the fetch() is recursive

[22:25] <putter> I've yanked from() and to() from PrimP5.  They return undef, but perhaps they are not being set...

[22:26] <putter> hmm, shouldn't package Match be disappeared from PrimP5?

[22:26] <luqui> Juerd, to distinguish from the context that expects a real array (or ref)

[22:26] <fglock_> oh yes, it should

[22:26] <Juerd> Why is "list context" not good enough, given that we still have difference between lists and arrays?

[22:27] <luqui> well, it was good enough to confuse p6l folks

[22:27] <putter> re fetching match... so what next?

[22:27] <Juerd> luqui: Do you know if these names are official yet?

[22:27] * luqui isn't sure, but thinks so

[22:27] <luqui> but it's still perl 6

[22:27] <luqui> so nothing is official until 6.0

[22:28] <fglock_> putter: there is a commented message in line 104, Code.pm - you can uncomment it and see what is happening

[22:28] <Juerd> If they are, I wonder why the keywords for context forcing. are scalar and list

[22:28] <Juerd> s/\.//

[22:28] <luqui> Juerd, good question

[22:28] <Juerd> Please, don't give me that crap. I know very well that everything can change at any point. However, it is important to have some sense of what is official. Even if you don't like that name.

[22:29] <putter> fglock_: err, with Match gone,  "foo" ~~ /(.)(.)/ stops working...

[22:29] * luqui thought that you were asking if it was okay to propose a change

[22:29] <luqui> please calm down

[22:29] <Juerd> Oh, no.

[22:29] <Juerd> I'm writing a PM article

[22:29] <svnbot> r6907 | putter++ | PrimP5: removed obsoleted package Match definition.

[22:29] <luqui> anyway, that keyword inconsistency is a little irritating now that I think about it

[22:29] <Juerd> I'm explaining the most basic Perl 6 things in a series of articles (though nobody knows that it is a series yet)

[22:29] <luqui> maybe you ought to bring it up

[22:29] <Juerd> Sorry, I was rude.

[22:30] <Juerd> http://perlmonks.org/index.pl?node_id=490468 is the first

[22:30] <Juerd> I try to pick one subject at a time, which is very hard.

[22:30] <Juerd> And: Perl 5 is past tense, Perl 6 is present

[22:30] <luqui> sure

[22:30] * putter just saw a talk where the email(?) tool had a little face on the side of the window, and some emotional content estimation heuristics, to give people feedback on the emotive content of their messages while they were written.  since in email, one lacks the feedback loops one has in face to face conversation.

[22:31] * luqui reads

[22:31] * putter goes to look at message in Code

[22:32] <fglock_> sorry - it is Scalar.pm

[22:33] <putter> ah

[22:34] <luqui> Juerd, cool, keep it up

[22:34] * luqui considers getting a perlmonks account

[22:34] <Juerd> Why not - they're free :)

[22:34] <Juerd> It's the perfect way to keep in touch with the average user

[22:35] <luqui> by "considers", I meant "begins"

[22:36] <fglock_> putter: Match->new() should be expecting named arguments

[22:36] <fglock_> in PrimP5, line 636

[22:36] <buu> Perlmonks is awesome. All hail.

[22:37] * fglock_ haven't written a line in Perlmonks for a month now

[22:38] <buu> I haven't written much either

[22:38] <fglock_> I've been spending all my free time here :)

[22:39] <buu> I find the questions generally fall in to three or four categories. The first one is a RTFM question that I don't care enough to repeat again. The second types are really complicated ones that would take a fair amount of effort to answer, which I'm too lazy for. The third are the ones that are already answered =/

[22:39] <luqui> is perlmonks based on e2?

[22:39] <luqui> or vice versa?

[22:39] <Juerd> No, a heavily patched everything <2

[22:39] <Juerd> AFAIK, perlmonks was first

[22:39] <Juerd> Sure I am not

[22:40] <luqui> you sure aren't

[22:40] <luqui> :-)

[22:40] <Juerd> (Wow, that is a weird (though correct) sentence in English.)

[22:47] <putter>  fglock: like  Match->new('$.val_bool' => $b, ...     ?

[22:48] <fglock_> yes

[22:48] <putter> still doesnt work.  will check in

[22:49] <fglock_> new() never complains, but it should

[22:49] <buu> ?eval sub y { (1,2,3) } y()[-1]

[22:49] <evalbot_6907> \3 

[22:49] <buu> YAY!

[22:49] <buu> ?eval sub y { (1,2,3) } y[-1]

[22:49] <evalbot_6907> (1, 2, 3) 

[22:49] <buu> Oh that's co.. weird?

[22:50] <buu> What happened there?

[22:50] <putter> same behavior in pilrun

[22:53] <luqui> ?eval sub y { (1,2,3) };  my @y = y;  @y[-]

[22:53] <evalbot_6907> Error:  unexpected "[" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[22:53] <luqui> ?eval sub y { (1,2,3) };  my @y = y;  @y[-1]

[22:53] <svnbot> r6908 | putter++ | PrimP5.pm: attempting to get Match to work

[22:53] <evalbot_6907> \3 

[22:53] <luqui> ?eval sub y { (1,2,3) }; (y)[-1]

[22:53] <evalbot_6907> \3 

[22:53] <wolverian> y[-1] looks fine to me.

[22:53] <fglock_> putter: try adding some debugging code like 'warn Match->val_bool' to see what's going on

[22:53] <luqui> hmm, it's a good question

[22:54] <luqui> does subscripting impose a scalar context?

[22:54] <putter> Match.pm wasnt being loaded in MainX

[22:54] <luqui> I guess that would make the sub return a list

[22:54] <fglock_> :)

[22:54] <luqui> which would then be indexed

[22:54] <luqui> er, an array

[22:54] <luqui> so it ought to work either way

[22:55] <wolverian> Juerd, that's a nice perlmonks article on ~. congrats!

[22:56] <Juerd> wolverian: Thank you.

[22:58] <svnbot> r6909 | putter++ | PIL-Run - add Match.pm to MainX

[22:58] <svnbot> r6910 | putter++ | Match.pm: return real values

[23:00] <fglock_> putter: did it work?

[23:02] <putter> ok, have str and bit and int working, and set_as_failed()

[23:02] <putter> now for array

[23:02] <putter> best guess is still the line in Scalar?

[23:03] <fglock_> I'll try to replicate the problem - what expression you are using to test?

[23:03] <putter> so postcirumfix[] is being called with $/ and 0...

[23:04] <putter> let me sync up

[23:04] <putter> ok r6911.

[23:05] <putter> "foo" ~~ /(.)(.)/; say $/; $/[0]

[23:05] <putter> the mangled variable name is $scalar__47x

[23:06] <putter> p5ugs> :5 $scalar__47x->fetch()

[23:06] <putter> Match=HASH(0x10ab9c0)

[23:06] <putter> p5ugs> :5 $scalar__47x->fetch(0)

[23:06] <putter> Method (fetch) not found for instance (Match=HASH(0x10ab9c0)) at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-MetaModel/lib/Perl6/MetaModel.pm line 248

[23:07] <putter> :5 ref $scalar__47x

[23:07] <putter> Scalar

[23:07] <fglock_> it looks like $/ is a string - and you are using [0] on it

[23:08] <putter> p5ugs> :5 ref $scalar__47x->fetch

[23:08] <putter> Match

[23:08] <fglock_> in order to say $/[0], you have to define fetch()

[23:09] <putter> ok

[23:09] <svnbot> r6911 | putter++ | PrimP5.pm: some Match related fixes

[23:09] <putter> (looking ahead, how does one distinguish fetch() for $/[0]  and for $/{foo} ?  (low priority question))

[23:10] <fglock_> we could redefine [] to call array_fetch and {} to call hash_fetch - currently, both call fetch()

[23:11] <putter> ah.  that will likely need to be separated.

[23:11] <putter> re fetch, how does one fetch the entire array?  eg,  @$/

[23:12] <fglock_> you call fetch on the array, without parameters - this should be a separate method too

[23:14] <putter> wooot! $/[0] #=> f

[23:15] <putter> .from and .to work... going to try perl5.t ! :-)

[23:16] <fglock_> :) great!

[23:20] <svnbot> r6912 | putter++ | Match.pm: added fetch()

[23:21] <Juerd> http://perlmonks.org/index.pl?node_id=358255  # draft of 2nd article

[23:22] <fglock_> leaving ...

[23:25] <svnbot> r6913 | putter++ | PrimP6.pm: added not().  not 0 gives an odd warning out of Perl6/Value.pm

[23:25] <putter> oh

[23:25] <putter> wait...

[23:26] <putter> first 50 tests now all passing.  now running it on the whole 900.

[23:26] <putter> moment of "wooot!" :)

[23:26] <putter> just thought you'd like to know before heading off...

[23:27] <putter> thanks very much for your help.

[23:28] <fglock_> cool - I'll read the irc log later &

[23:29] <Juerd> wolverian: Please proofread the 2nd :)

[23:30] <wolverian> Juerd, sure! where?

[23:30] <svnbot> r6914 | putter++ | PrimP5.pm: Match fix from()/to()

[23:30] <wolverian> Juerd, oh, sorry, I'm blind.

[23:33] <wolverian> Juerd, maybe you could extrapolate on what Ref being subtype of Scalar means.

[23:33] <wolverian> (s,extrapolate,write,)

[23:36] <Juerd> Like what?

[23:37] <Juerd> Oh, I get it, I think

[23:39] <Juerd> Done

[23:39] <Juerd> I wish I knew what exactly the difference between item context and Scalar context would be

[23:53] <putter> woot!  PIL-Run passes 98% of perl5.t  :)  fglock++

