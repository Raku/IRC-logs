[00:04] <halobA> can parrot questions be asked here?

[00:06] <obra> yes, but #parrot on irc.perl.org is better

[00:26] <audreyt> Juerd: no, I will resume my journal today or tomorrow.

[00:27] <halobA> so will parrot have support for ruby?

[00:27] <audreyt> halobA: if people work on it, then sure

[00:28] <audreyt> halobA: ruby's multiple-backend compiler support is not quite there yet though, so it may be easier to take YARV instructions and translate to Parrot directly

[00:29] <audreyt> but I'm not involved in racc or other ruby compilation technologies, so I'm not the most qualified person to answer this

[00:29] <halobA> has anyone gotten parrot running on mac os x?

[00:30] <leo> halobA: sure

[00:30] <leo> since ages ;-)

[00:30] <audreyt> leo: hey, thanks for the reply on p6i :)

[00:31] <stevan> audreyt: good morning/afternoon/whenever 

[00:31] <leo> audreyt: welcome and thanks for the reminder

[00:31] <audreyt> stevan: morning it is. saw your checkins :)

[00:31] <audreyt> was about to go out to pickup my laptop and return ~2.5hr later

[00:31] <stevan> ok

[00:32] <audreyt> so you no longer crave for sugars in minilang? :)

[00:32] <stevan> be thinking about dispatcher while you wait :)

[00:32] <audreyt> okay, will do.

[00:32] <stevan> not at all

[00:32] <leo> halobA: parrot will support ruby, when someone writes a Ruby -> PIR translator

[00:32] <stevan> I am getting the hang of it I think

[00:33] <stevan> audreyt: I tried, really tried (ask gaal) to do some Haskell today

[00:33] <stevan> I grok a little more now, ... but not enough to get it to compile & work

[00:34] <audreyt> stevan: ooh, post a patch somewhere (or as comment) ?

[00:34] <clkao> audreyt!

[00:34] <clkao> did you see the weird parse thungy

[00:35] <stevan> audreyt: it was bad,.. i was chasing type signatures,.. 

[00:35] <clkao> thingy

[00:35] <stevan> I was trying to hack in a has_attr() method for instances

[00:36] <stevan> it kept telling me the expected type was STM and the inferred type was Maybe,.. that was as close as I could get

[00:36] <stevan> I svk reverted in anger though,.. so it is no more

[00:36] <clkao> not svk's fault that you are in anger?

[00:36] <stevan> clkao: no it is not,.. but you have created a wonder stress reliever :)

[00:37] <clkao> :P

[00:37] <audreyt> clkao: yes I did

[00:37] <clkao> sorted?

[00:37] <audreyt> no, not until I got a working laptop back ;)

[00:37] <audreyt> which I'm going to now

[00:37] <clkao> did you mention asomething about 'first thing in the morning'

[00:38] <audreyt> yes, they open at 10am

[00:38] <clkao> oh well, it's quite a morning for you :)

[00:38] <audreyt> so I will indeed arrive first thing in the morning

[00:38] <clkao> alright. audreyt, i will see you in a few days or at most a week

[00:38] <audreyt> stevan: I'll think about dispatcher... also has_attr

[00:38] <audreyt> stevan: meanwhile:

[00:38] <clkao> are we nearly there yet

[00:38] <audreyt> <darix> the problem with haskell is

[00:38] <audreyt> <darix> the learning curve is like a mountain in the himalaya ...

[00:38] <audreyt> <darix> nearly 90degree and close to 8000 m

[00:38] <audreyt> <darix> but standing up the hill just rocks ;)

[00:38] <audreyt> bbiab... &

[00:38] <clkao> you just need some climbing training

[00:39] <stevan> audreyt: yes, I agree :)

[00:39] <luqui> seconded

[00:39] <clkao> it's not all that hard, slackerse!

[00:39] <stevan> my problem is having the mind-share available for Haskell in my brain

[00:39] <stevan> too many other things already occupying space, and much accumulated damage :)

[00:40] <luqui> clkao, I thought it was pretty hard, having never been exposed to ML, and never programmed anything real in scheme or lisp

[00:41] <stevan> monads and types, those are the two things I curse at most often when programming haskell :)

[00:41] <luqui> Haskell is like wasabe.  It is hard to eat at first, but it will clear out all the garbled nonsense in your sinuses accumulated from other languages.

[00:41] <clkao> i did some hardcore stuff in scheme

[00:41] <clkao> oh man, i love wasabe

[00:41] <luqui> stevan, you... curse... monads?

[00:41] <clkao> particularly when you can cut fish properly after some practice :) it tastes even better!

[00:41] <luqui> By the time I had any idea what they were, I loved them.

[00:42] <stevan> luqui: it's a love/hate thing,.. 

[00:42] * luqui 's knife was too dull.  It just squished.

[00:42] <luqui> the fish, that is.

[00:43] <luqui> stevan, have you used interesting monads yet?

[00:43] <luqui> i.e. things besides IO?

[00:43] <stevan> I love the idea,.. but when you throw in static types and unfamilar syntax & control flow, ... I curse them

[00:43] <stevan> luqui: no, I probably should experiment on a small side project

[00:43] <stevan> luqui: I was fighting with STM today

[00:43] <luqui> I actually rather dislike the IO monad

[00:43] <luqui> but Maybe is cool, [] is awesome, RWS is pretty useful

[00:44] * stevan will probably stick to meta-models for the time being :)

[00:45] <luqui> mmkay

[00:45] * luqui just realized that he listed off all the monads in the standard library, with the exception of Cont :-)

[00:46] <drbean> What can I look at in pugs to get some practice with monads?

[00:46] <luqui> don't use pugs

[00:46] <stevan> luqui: can you explain Monads in 20 words or less? 

[00:47] <luqui> it's very complicated, and it is not a very good learning tool (IMO)

[00:47] <stevan> in p5-ish terms

[00:47] <luqui> drbean, google "all about monads"

[00:47] <luqui> that's an exellent tutorial

[00:47] <luqui> stevan, hmmm

[00:47] <luqui> (there's one)

[00:47] <drbean> I have read most of the monad tutorials. I want to try writing or using them.

[00:48] <drbean> I was pointed toward Parsec.

[00:48] <luqui> stevan, monads are way to perform sequenced computations

[00:49] <luqui> drbean, parsec is a good one

[00:49] <luqui> stevan, that's the best I can come up with

[00:49] <drbean> But I was thinking something perl-related would be good.

[00:49] <luqui> stevan, do you know how State works?  (it's quite simple)

[00:49] <luqui> drbean, you can look at Parser.hs

[00:49] <stevan> luqui: no, esplain please :)

[00:49] <clkao> zzzz

[00:50] <luqui> stevan, you can do normal stuff, you can "get" the current state, and you can "put" the current state

[00:50] <luqui> if you "get" the state after you "put" it earlier, it just gives you back what you put there

[00:50] <stevan> how is the state stored?

[00:50] <luqui> that's not important

[00:50] <luqui> (to be honest, it's stored as a function that takes the current state, and returns a value with a new state)

[00:51] <stevan> ok

[00:51] <luqui> (but the monad hides that complexity from you)

[00:51] <stevan> yes

[00:51] <stevan> how does the function maintain state? more magic?

[00:51] <luqui> okay, I'll explain with code

[00:51] <stevan> :)

[00:52] <luqui> State Foo Int  (int is the return type, Foo is the state type)  is the same as the type   Foo -> (Int,Foo)

[00:52] <luqui> It takes a current state and returns a value with a new state

[00:52] <stevan> can you show an example of usage?

[00:53] <stevan> would you use this for say,.. a counter?

[00:53] <luqui> perhaps

[00:53] <luqui> let's write a gcd that counts how many steps it took

[00:53] <stevan> simpler than that please

[00:53] <stevan> in other words,.. no math ;) 

[00:53] <luqui> that's about the simplest nontrivial thing I can come up with

[00:53] <stevan> what about a counter

[00:53] <luqui> stevan, what should we count?

[00:54] <stevan> State Int Int

[00:54] <stevan> web page hits,.. I dont care,.. 

[00:54] <stevan> I want to be sure I grok this on the simplest leverl

[00:54] <luqui> hmm.  okay.

[00:55] <luqui> do { ctr <- get;  {- do stuff -}  put (ctr + 1) }

[00:55] <luqui> er, not quite

[00:55] <stevan> Monads have been someting I have only been able to understand in the very abstract,.. and I have trouble bringing them to the level of usefulness

[00:55] <stevan> <- is the way to get things out of the monad right?

[00:56] <luqui> "the monad"...

[00:56] <luqui> more like "a monad"

[00:56] <stevan> yes

[00:56] <stevan> sorry,.. :P

[00:56] <luqui> get returns a monad.

[00:56] <stevan> binding it to ctr?

[00:56] <luqui> yep

[00:57] <stevan> so get and put are functions related to the State monad

[00:57] <luqui> yes

[00:57] * stevan is making sure he gets all the syntax right in his head

[00:57] <luqui> it's tough at first to know when you should use <- and when you should use let

[00:57] <stevan> let?

[00:57] <stevan> oh,.. nevermind

[00:58] <stevan> let x = ...

[00:58] <luqui> yeah

[00:58] <stevan> when should you use let vs. <-

[00:58] <luqui> you use let on things that don't return monads

[00:58] <luqui> let x = 3 + 4

[00:58] <luqui> y <- get

[00:59] <luqui> (you can also use let on things that do return monads, but then you have a monad in that variable, and you still to bind it to something to use it)

[00:59] <luqui> let's see, I like the list monad

[00:59] <luqui> let's use that

[00:59] <stevan> ok

[01:00] <luqui> here's a function that increments every element in a list using the list monad

[01:00] <luqui> incList list = do { cur <- list;  return (cur + 1) }

[01:00] <luqui> try that in ghci

[01:00] <stevan> so ctr in (your last example) is a monad? or is it the value returned from the monad?

[01:01] <luqui> ctr would be an Int, not a monad

[01:01] <stevan> so where is the monad then?

[01:01] <luqui> it is returned by get

[01:01] <stevan> ok

[01:01] <luqui> you can think of <- as a way to get from "m a"  to  "a"

[01:01] <stevan> but not assigned to anything?

[01:02] <luqui> that is:  foo <- bar

[01:02] <luqui> if bar is "IO Int", then foo will be "Int"

[01:02] <stevan> and bar is the monad?

[01:02] <luqui> yeah

[01:03] <stevan> but in your first example you just did get;,.. where is the monad in that example?

[01:03] <luqui> get :: State s s

[01:03] <luqui> get is a monad itself

[01:03] <stevan> ok

[01:04] <luqui> did you do the list example?

[01:04] <luqui> because we're going to build on it

[01:04] <stevan> parse error :)

[01:04] <luqui> oh, slam a "let" at the front of that statement

[01:04] <stevan> Prelude> incList list = do { cur <- list;  return (cur + 1) }

[01:04] <stevan> <interactive>:1:13: parse error on input `='

[01:05] <stevan> ok,.. its in ghci

[01:05] <luqui> Prelude> incList [1,2,3]

[01:05] <luqui> [2,3,4]

[01:05] <luqui> as expected

[01:05] <stevan> cool

[01:06] <luqui> so what the list monad does is it takes one value from the list it's binding to

[01:06] <luqui> and then performs the rest of that computation on the value

[01:06] <luqui> the computation must return a list

[01:06] <luqui> and then all the results are concatenated together

[01:06] <luqui> in the list monad, return x  is the same as [x]

[01:06] <luqui> that's how it's defined

[01:06] <luqui> so, for a more fun example

[01:07] <luqui> let incList list = do { cur <- list;  [cur + 1, cur + 2] }

[01:07] <luqui> I suppose "incList" is no longer a good name

[01:07] <stevan> no,.. it works

[01:07] <stevan> now,.. why is this better than just using a function

[01:07] <luqui> yeah it does.  but incList doesn't describe what it does anymore

[01:08] <luqui> because the things you can express would be very complicated in a function

[01:08] <luqui> for example

[01:08] <luqui> let addLists as bs = do { a <- as; b <- bs; return (a + b) }

[01:09] <luqui> gives you every combination of sums of things from as and things from bs

[01:09] <luqui> it may not be surprising, but list comprehensions are just a little bit of syntactic sugar around the list monad

[01:10] <luqui> [ a + b | a <- [1,2,3], b <- [4,5,6] ]  is the same as  do { a <- [1,2,3]; b <- [4,5,6];  return (a+b) }

[01:11] <luqui> you could think of the Maybe monad as a way to fail a computation and have that failure propagate until the function returns (like the undef thread on p6l ;-)

[01:12] <stevan> :D

[01:12] <luqui> do { a <- Just 4;  b <- Just 5;  c <- Just 6;  return (a + b + c) }

[01:12] <luqui> returns Just 15

[01:12] <luqui> but:

[01:12] <luqui> do { a <- Just 4;  b <- Nothing;  c <- Just 6;  return (a + b + c) }

[01:12] <luqui> returns Nothing

[01:12] <luqui> because one of the inputs was Nothing (i.e. undef)

[01:14] <luqui> Maybe is a nice monad to define.

[01:15] <luqui> Just x >>= f  = Just (f x);   Nothing >>= f  = Nothing;  return x = Just x

[01:15] <luqui> that's it :-)

[01:15] <luqui> when you bind a Just to a function, you just apply that function.  When you bind Nothing to a function, you return Nothing.

[01:15] <luqui> and that gives you failure propagatin

[01:15] <stevan> nice

[01:17] <luqui> any questions?

[01:18] <stevan> not really,.. I am messing around with ghci :)

[01:18] * luqui loves ghci

[01:18] * luqui wishes perl had a competent interactive shell

[01:18] <stevan> I dont really see where these would be that useful outside of Haskell though

[01:19] <luqui> right.  they are a good fit for Haskell.

[01:19] <luqui> other than the list monad, which kicks amazing ass

[01:19] <stevan> I guess I was trying to transpose them to Perl, etc. to grok their usefulness

[01:20] <luqui> yeah, I can't really see how that would be done for most of these

[01:20] <luqui> I kind of like the "implicit state object" of the State monad.  It would have to be explicit in perl.

[01:21] <luqui> but the idea that a binding is a function application is quite powerful

[01:22] <stevan> yes, I like that

[01:22] <luqui> some of my insane junction proposals on p6l used that idea

[01:22] <luqui> but they were insane...

[01:22] * stevan wonders where luqui has been keeping his sane proposals ;)

[01:23] <stevan> so now,.. STM

[01:23] <stevan> what do you know about it?

[01:23] <luqui> very little

[01:23] <stevan> is it just a transation State monad?

[01:23] <stevan> transactional

[01:23] * luqui looks at the docs to see if he can figure it out

[01:24] <stevan> that is what audreyt is using for the instance type in the Object Space

[01:24] <luqui> STM looks like a way to computations over TVars

[01:25] <stevan> TVars are?

[01:25] <luqui> shared variables

[01:25] <luqui> atomically :: STM a -> IO a

[01:25] <luqui> so it's quite similar to IO it seems

[01:26] <stevan> I thought IO was for reading and writing files/sockets/etc

[01:26] <luqui> IO is pretty much for "unrevokable actions"

[01:26] <luqui> anything you can't undo

[01:26] <luqui> such as writing to a shared variable

[01:27] <luqui> STM gives you a way to locally undo that...

[01:27] <stevan> hmm

[01:28] <luqui> where is audreyt's code 

[01:28] <stevan> PIL/Native/*

[01:28] * luqui has trouble understanding what you mean by "instance type"

[01:28] <stevan> PIL/Native/Object.hs in particular

[01:29] <stevan> is it the core "object instance" in the Object Space and mini-language

[01:30] <stevan> with that we build the class system with

[01:30] <luqui> it looks like STM is just the computational framework in which the object space is executed

[01:31] <stevan> what does the => mean in those signatures?

[01:31] <luqui> "then"... kindof

[01:31] <luqui> that's the typeclass syntax

[01:31] <stevan> ok

[01:32] <luqui> do you think you grok that?

[01:32] <luqui> for example:  sort :: (Ord a) => [a] -> [a]

[01:32] <stevan> I grok more of it now than I did before 

[01:32] <luqui> "if a can be Ordered, then this function takes a list of as to a list of as"

[01:33] <stevan> a being the polymorphic type,.. 

[01:33] <luqui> yeah

[01:33] <luqui> setAttr :: MonadSTM m => NativeObj -> NativeStr -> Native -> m ()

[01:33] <stevan> but in this case,.. it is not totally "free",.. it must be Ord too

[01:33] <luqui> right

[01:34] <luqui> it must be an "instance" of Ord

[01:34] <luqui> as they say

[01:34] <stevan> ok

[01:34] <stevan> why is that not something like [ Ord a ] -> [ Ord a ]?

[01:34] <stevan> is it just sugar?

[01:34] <luqui> setAttr will work for any monad m, as long as MonadSTM m is true; i.e. as long as m can do STM stuff

[01:34] <luqui> certainly not just sugar

[01:34] <luqui> Ord a represents a "predicate" on tyeps

[01:34] <luqui> types

[01:34] <luqui> that is, it is either true or false

[01:35] <luqui> it is not a type itself

[01:35] <luqui> so for any type a, if Ord a is true, then I can use this function

[01:35] <stevan> interesting

[01:35] <luqui> reminiscent of theories? ;-)

[01:36] <stevan> yes, somewhat,.. I was always looking at theories from the metamodel POV

[01:36] <stevan> but now they actually make more sense,.. from this POV

[01:39] <luqui> looks like PIL.Native.Objects uses a lot of fancy machinery, but it's really quite straightforward

[01:39] <stevan> this is what I was fighting with today

[01:40] <stevan> I was trying to add a hasAttr function

[01:40] <luqui> what was your plan?

[01:40] <luqui> it doesn't look to me like there's any way to do that without changing the NativeObj table

[01:41] <stevan> yup, I added o_exists to that

[01:42] <stevan> then tried to create hasAttr

[01:42] <luqui> it's possible that it should actually just be o_fetch :: NativeStr -> STM (Maybe Native)

[01:42] <stevan> thats what gaal suggested :)

[01:42] <luqui> but whatever, we'll go with o_exists for the sake of discussion

[01:42] <stevan> but I wasnt sure if that would step on something audreyt was trying to do

[01:43] <stevan> I also added has_attr to PIL.Native.Eval.hs too

[01:44] <luqui> okay, so what was your trouble with hasAttr?

[01:44] <stevan> I could not get the types to all match up,..

[01:44] <luqui> how is o_exists typed?

[01:45] <stevan> I copied o_fetch's sig

[01:45] * stevan svk reverted this stuff,.. so he is recalling from memory

[01:45] <luqui> NativeStr -> STM Native

[01:45] <luqui> or NativeStr -> STM Bool

[01:46] <stevan> the first one

[01:46] <luqui> that's most likely the problem

[01:46] <clkao> dude, fix the blank-line parse problem please

[01:46] <stevan> it was telling me expected: STM, inferred: Maybe

[01:46] <luqui> clkao, which?

[01:46] <luqui> interestng

[01:47] <luqui> too bad you reverted

[01:47] <stevan> luqui: I will try and reconstruct it,.. and commit my mess  :)

[01:47] <luqui> heh okay

[01:48] <luqui> clkao, which is that?

[01:48] <luqui> oh, I already asked that...

[01:49] <clkao> i posted earlier..

[01:50] <clkao> http://home.clkao.org/~clkao/tmp/test.pl

[01:50] <luqui> works for me

[01:50] <clkao> with and without hte first blank line, pugs -CPIL or -CPugs are subtly different

[01:51] <clkao> ya, it works. but with the first blank line, everything happens in Test:: namespace

[01:51] <clkao> without it, it's in main::, as expected

[01:52] * luqui investigates

[01:56] <stevan> luqui: I just commited ,.. I think I have re-created the last version I had

[01:56] <svnbot6> r8310 | stevan++ | PIL.Native.* -> Haskell hurts my brain

[01:57] <stevan> ... what svnbot6 said :)

[02:00] <luqui> does that compile by default?

[02:00] <luqui> I mean, PIL.Native.stuff

[02:00] <stevan> yes

[02:00] <stevan> but with my stuff in it,.. it breaks

[02:01] <luqui> by "by default", I mean, should it be compiling when I type "make"?

[02:01] <luqui> because I got a successful compile here

[02:01] <stevan> oh

[02:01] <stevan> no,.. make pili

[02:01] <luqui> mmkay

[02:02] <stevan> I think the exists definition is wrong,.. 

[02:02] <stevan> it should be member,.. not lookup

[02:02] <luqui> almost

[02:02] <stevan> but I get "src/PIL/Native/Objects.hs:53:12: Not in scope: `member'"

[02:03] <luqui> Map.member?

[02:03] <stevan> checking

[02:03] <stevan> same error,.. just Map.member is not in scope

[02:04] <stevan> audreyt imports Data.Map as NMap in another module

[02:04] <luqui> ahh

[02:04] <luqui> NMap.member?

[02:04] <stevan> same error

[02:04] <stevan> not in scope

[02:04] <luqui> weird

[02:04] <stevan> yeah

[02:04] * luqui wonders how lookup is in scope but not member

[02:04] <stevan> weirdness is bad for newbies :)

[02:05] <stevan> me too :)

[02:06] <luqui> where does he import NMap

[02:06] <stevan> Types.hs

[02:06] <stevan> import qualified Data.Map as NMap

[02:07] <luqui> Oh!

[02:07] <luqui> Prelude.lookup exists

[02:07] <stevan> ah,.. this is a good sign

[02:08] <luqui> anyway, try "elem"

[02:08] <luqui> elem key attrs

[02:08] <luqui> er, no

[02:08] <luqui> isJust (lookup attrs key)

[02:09] <luqui> it converts a maybe into a bool

[02:09] <stevan> isJust is not in scope

[02:09] <luqui> wait... this is very confusing

[02:09] <luqui> oh, sorry, Maybe.isJust (or Data.Maybe.isJust)

[02:09] <luqui> it looks like lookup is returning a monad

[02:10] <luqui> did you put in the lookup call?

[02:10] <luqui> this might explain it.  I was assuming that lookup was there before and therefore correct

[02:10] <stevan> no I put in lookup

[02:11] <stevan> cause member didnt work

[02:11] <luqui> how do I find the current file in vim?

[02:12] * stevan doesn't use vim,.. I have no idea

[02:12] <qwr> current?

[02:12] <luqui> okay.  PIL.Native.Coerce

[02:12] <luqui> qwr, the one I'm currently looking at

[02:12] <stevan> HAH!

[02:12] <luqui> I just want it to show me the status line that I get when I first edit a file

[02:12] <stevan> import qualified Data.Map as NMap.. then NMap.member works

[02:13] <luqui> you want "exists"

[02:13] <stevan> still getting a type error though

[02:13] <luqui> to keep with his design

[02:13] <stevan> where is exists defined?

[02:13] <luqui> PIL.Native.Coerce line 73

[02:13] <qwr> luqui: ^G seems to do this

[02:13] <luqui> qwr, yep.  thanks.

[02:14] <luqui> stevan, you will still get a type error though

[02:14] <stevan> luqui: how do I get that exists 

[02:14] <luqui> what, is it not in scope?

[02:15] <stevan> `exists' is applied to too many arguments in the call

[02:15] <luqui> swap the arguments

[02:15] <luqui> exists key attrs

[02:15] <luqui> n/m

[02:15] <luqui> I'm wrong

[02:16] <stevan> yeah,.. same error

[02:16] <luqui> but maybe it's wrong about what kind of error it is

[02:17] <luqui> oh

[02:17] <luqui> that's a recursive exists call :-)

[02:17] <stevan> ok

[02:17] <luqui> you probably need PIL.Native.Coerce.exists

[02:17] <luqui> either that or change the exists key = do line

[02:17] <luqui> to exists' key = do

[02:18] <luqui> and change the surrounding reference to exists accordingly

[02:18] <stevan> ok

[02:18] <stevan> I will just use PIL.Native.Coerce.exists

[02:18] <stevan> expected type: STM t inferred type: Bool

[02:18] <luqui> right

[02:18] <luqui> you have to change the sig for o_exists

[02:19] <stevan> ok,.. so are we closer now?

[02:19] <luqui> yes

[02:19] <luqui> it should be o_exists :: STM Bool

[02:19] <stevan> compiling .......

[02:19] <luqui> you don't return a Native object when you're asking whether something exists

[02:19] <luqui> there will still be an error :-)

[02:20] <stevan> change line 35 to hasAttr :: MonadSTM m => NativeObj -> NativeStr -> m Bool??

[02:20] <luqui> that is one thing

[02:20] <luqui> but the thing I'm staring at has to do with returning a Bool when you should be returning an STM Bool

[02:20] <luqui> in the newObject function

[02:21] <stevan> yeah

[02:21] <luqui> know how to fix that?

[02:21] <stevan> no idea

[02:21] <luqui> well, STM is a monad

[02:21] <luqui> how do you put a value in a monad?

[02:21] <stevan> I am gonna guess that tvar has something to do with it?

[02:22] <luqui> nah.  you just need a function that takes a -> m a

[02:22] <stevan> ok

[02:22] <luqui> what's that function?

[02:22] * stevan wonders if he should check hoogle

[02:23] <luqui> that might be overkill

[02:23] <luqui> okay fine, I give up on the socratic method

[02:23] <luqui> it's "return" :-)

[02:23] <stevan> please

[02:23] <stevan> thanks

[02:23] <luqui> I thought "it's one of the two monad primitives" would be giving away too much

[02:23] <stevan> return PIL.Native.Coerce.exists attrs key ?

[02:23] <stevan> this breaks

[02:24] <luqui> return (lookup attrs key)

[02:24] <luqui> if you do a monadic bind in a function, you have to return a monad

[02:24] <luqui> lookup just returns a bool

[02:24] <luqui> er, exists

[02:24] <luqui> s/lookup/exists/g

[02:28] <stevan> horray!!!!!!!

[02:28] <stevan> it compiles

[02:28] <luqui> cool

[02:29] <stevan> and it works too

[02:29] <luqui> coolness

[02:29] <stevan> Haskell is not that hard if you have a luqui handy :)

[02:31] <luqui> :-p

[02:31] <luqui> that'll be $3.50

[02:31] <stevan> I will take it off your room charge from Toronto

[02:31] <stevan> :P

[02:32] <luqui> hehe

[02:32] <svnbot6> r8311 | stevan++ | PIL.Native.*

[02:32] <svnbot6> r8311 | stevan++ | - adding has_attr method to the instance type, thanks to 

[02:32] <svnbot6> r8311 | stevan++ |   luqui++ for all the Haskell/Monad 

[02:32] <svnbot6> r8311 | stevan++ | coaching

[02:33] * luqui is off to pay his bills, and then back to work on p6ge

[02:33] * luqui &

[02:37] * stevan is off to get some celebratory ice cream &

[02:37] <svnbot6> r8312 | stevan++ | PIL.Native.Bootstrap.pil

[02:37] <svnbot6> r8312 | stevan++ | - added has_attr back into ::Class.BUILD, and added test for it

[04:24] <audreyt> stevan++ luqui++

[04:25] <obra> hey audreyt 

[04:25] <audreyt> obra: yo! I'm told my laptop will be ready for me in 5 minutes

[04:25] <audreyt> hopefully this time they really mean it

[04:26] <audreyt> sorry I missed sketch

[04:26] <obra> ooh. has it been dead all this time?

[04:26] <audreyt> where all this time = 3 days

[04:26] <audreyt> yeah, been using the backup ibook

[04:26] <obra> heh

[04:26] <audreyt> which is not ideal for things

[04:27] <obra> understood

[04:27] <obra> "but good for see"

[04:27] <audreyt> that might be the case :)

[04:27] <obra> I extracted the currentuser stuff for Jifty

[04:28] <obra> Login is just now working in the second app

[04:28] <audreyt> gobby hits darwinports btw

[04:28] <audreyt> oh cool

[04:28] <audreyt> "the second app"?

[04:28] <obra> Wifty

[04:28] <obra> "not the hiveminder codebase"

[04:28] <audreyt> k

[04:28] <obra> also, the support for single-use urls for feeds and email auth 

[04:29] <obra> probably not necessary for what you're doing, but useful for confirmation mail

[04:29] <audreyt> that sounds useful indeed

[04:29] <audreyt> 5 days to go until 0.00_00_00_01 release?

[04:29] <obra> 0.01 ;)

[04:29] <audreyt> oh, much more conventional :)

[04:30] <obra> and alex got our AHAH support working

[04:30] <obra> so a form submit can update multiple page regions

[04:30] <audreyt> nod

[04:30] <obra> just in time for the "AHAH" acronym to come up on microformats

[04:30] <audreyt> Asynchronous 

[04:30] <audreyt> ..?

[04:30] <audreyt> HTML and HTTP?

[04:31] <obra> yeah

[04:31] <obra> "AJAX, microformats edition"

[04:31] <audreyt> "A-HAH support"

[04:32] <audreyt> it's not yet too late to rename the toolkit to "use Ahah;"

[04:32] <audreyt> use Ahah::Bwahaha;

[04:32] <obra> I like jifty :)

[04:32] <audreyt> me too :)

[04:34] <audreyt> ooh, the laptop is ready. I'll bbiab :)

[04:34] <audreyt> &

[04:35] <obra> later

[04:42] <luqui> ?eval say < < 3 > >

[04:42] *** evalbot_8307 is now known as evalbot_8312

[04:42] <evalbot_8312> OUTPUT[<3> ] bool::true 

[04:42] <luqui> ?eval say < < < 3 > >

[04:42] <evalbot_8312> OUTPUT[<<3> ] bool::true 

[04:42] <luqui> I find it disturbing that that works

[04:42] <luqui> ?eval say < < < 3 > >; say "hello";

[04:42] <evalbot_8312> OUTPUT[<<3> hello ] bool::true 

[04:42] <luqui> how?

[05:09] <audreyt> what how?

[05:10] <luqui> the fact that < > balance, but only when you want them to

[05:10] <audreyt> because it's a backtracking parsert?

[05:10] <svnbot6> r8313 | autrijus++ | * minor cleanup to "exists" usage in PIL.Native.Objects

[05:11] <luqui> that was my guess...

[05:12] <audreyt> clkao: I don't see a difference between test.pl with and without blank line.

[05:12] <audreyt> what did I miss?

[05:12] <audreyt> they both output "1\n1..0\n"

[05:12] <audreyt> or was it fixed somehow already?

[05:12] <luqui> he says that it compiles in a different namespace

[05:13] <luqui> without the blank line it compiles in Main, but with the blank line it compiles in Tes

[05:13] <luqui> t

[05:13] <audreyt> oh, "compiles"

[05:13] <audreyt> that makes more sense. fixing

[05:14] <audreyt> luqui: so, how's it going for P6GE?

[05:15] <luqui> I just scrapped and restarted

[05:15] <luqui> no more AST

[05:15] <luqui> more like Parsec now

[05:15] <audreyt> *nod*

[05:15] <audreyt> ooh, excellent

[05:16] <luqui> also I'm building in the possibility of matching against non-text

[05:16] <luqui> I figured I fought hard enough on p6l for that that I should at least support it ;-)

[05:17] <audreyt> cool... that's always one of the wins I perceive about parser combinator type stuff

[05:18] <audreyt> although there is apparently another approach, more akin to the PGE/TGE plan, in the form of ASF+SDF2

[05:19] <luqui> ?

[05:19] <audreyt> http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/SDF2

[05:19] * luqui reads it twice

[05:19] <audreyt> er.

[05:19] <audreyt> http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ASF

[05:20] <audreyt> it's declarative,  not function based (i.e. not parser combinator) but is interesting neverthelss

[05:20] <luqui> the thing that made me choose parser combinators was the match object stuff

[05:21] <luqui> the fact that you can't compile x* into a recursive (x|)

[05:21] <luqui> because the match objects would look different

[05:21] <luqui> I'd like to research the SDF some other time

[05:23] <audreyt> *nod* and p6rule allows arbitrary callbacks to p6 code

[05:23] <audreyt> so you can't be purely declarative anyway

[05:23] <audreyt> so parser combinators is still the obvious choice

[05:24] <luqui> mm hmm

[05:24] <audreyt> also the fact that you can declare a rule without mentioning "rule" -- i.e. define it as a method -- pretty much means that rules are just desugared into parser combinator calls underneath

[05:25] <luqui> well... sortof

[05:25] <luqui> that may actually be a suboptimal choice

[05:25] <audreyt> (not neccessarily in the atom level)

[05:25] <audreyt> I don't quite mean that rule {abc} is desugared into

[05:25] <audreyt> char 'a'; char 'b'; char 'c'

[05:26] <audreyt> but rather that you can treat it as a method and compose it in your methods

[05:26] <luqui> well, I just don't want to wire it down to a particular implementation strategy

[05:26] <audreyt> pretty much the same way that parsec's buildExpressionParser works

[05:26] <audreyt> cool... anything that works works :)

[05:26] <luqui> Pm's uses coroutines, mine uses CPS.  So there has to be a compatibility layer.

[05:26] <audreyt> *nod*

[05:27] <audreyt> any reason not to use coros?

[05:27] <audreyt> pugs's coro support should be pretty stable at this point

[05:27] <luqui> because it's easier for me to think in CPS for some reason

[05:27] <luqui> pretty much a choice made by -Ofun

[05:28] <luqui> it probably has something to do with the side-effect-free impression that Haskell has made on me

[05:29] <audreyt> cool :)

[05:30] <audreyt> also... is pm still going to work on the pge-based minilang parse tree evaluator?

[05:30] <luqui> it sounds like it

[05:30] <audreyt> might be interesting to port PIL2 OO minilang to that evaluator

[05:30] <audreyt> to get some sort of instant portability of metamodel

[05:31] <luqui> whoever does that would have to touch PIR, no

[05:31] <luqui> ?

[05:31] <audreyt> probably not...

[05:31] * luqui doesn't know much about pm's plans

[05:32] <audreyt> assuming pm gets an evaluator working, we can just output whatever it's evaluating

[05:32] <audreyt> I think the Ann nodes are making pugs slower than needed...

[05:32] * audreyt benchmarks

[05:33] <luqui> can you speed things up by strictifying?

[05:33] <audreyt> it's already all strict

[05:33] <audreyt> and unboxed

[05:33] <luqui> hmm

[05:33] <audreyt> need benching to be sure

[05:45] * luqui loves the always "use strict"ness of perl 6.  I always forget to put that in my perl5 modules

[05:45] <audreyt> clkao: fixing the newline bug now

[05:45] <audreyt> luqui: export PERL5OPT=-Mstrict

[05:45] <audreyt> or even better

[05:46] <audreyt> export PERL5OPT=-MAcme::use::strict::with::pride

[05:46] <luqui> that will only help me forget it

[05:46] <luqui> (these are modules that I would CPAN)

[05:48] <audreyt> though if your module passes strict always without declaring it

[05:48] <audreyt> it doesn't quite hurt that much (still hurts patch makers)

[05:48] <luqui> I suppose

[05:48] <gaal> morning!

[05:49] <audreyt> gaal: hey

[05:50] <gaal> audreyt: hey :) brb # coffee etc.

[05:56] <gaal> sooo, got sillicone? /me backloggeth

[06:00] <audreyt> yup.

[06:00] <audreyt> clkao: fixed

[06:00] <audreyt> fees rather good to finally be able to hack :)

[06:01] <gaal> audreyt: I had some monadicity trouble myself, let me nopaste....

[06:02] <pasteling> "gaal" at 192.115.25.249 pasted "making the exporter more general" (15 lines, 885B) at http://sial.org/pbot/15055

[06:03] <gaal> this is the last bit of ruleUsePerlPackage

[06:03] <gaal> the idea is that it's all well and good to use unsafeEvalExp to export globals, but other things need to return a Pad

[06:04] <gaal> so I want to take each of the exportables by type, and fold their rebinding together into one Stmts list.

[06:05] <gaal> something like... %requested = { SMy => <$a &b @c>, SGlobal => <$d> };

[06:06] <audreyt> nodnod

[06:06] <gaal> for %requested -> $key, $sym { accumulate map export $key $_ for @$sym }

[06:07] <svnbot6> r8314 | autrijus++ | * trivial patch in Parser.hs - Pos should close over lexical scope on

[06:07] <svnbot6> r8314 | autrijus++ |   beginning of block body, not after the whitespacess

[06:07] <gaal> return [mergeStmts] accumlator]

[06:07] <gaal> s/]$//

[06:08] <gaal> "accumulate" is handwavy; and the present nopaste doesn't compile because of monad level errors.

[06:08] <gaal> any suggestions?

[06:10] <audreyt> looking

[06:12] <audreyt> so, what monad level problems?

[06:13] <svnbot6> r8315 | autrijus++ | * fix the "newline causes use '' to belong in different namespaces"

[06:13] <svnbot6> r8315 | autrijus++ |   bug mentioned by clkao; in -C and -B modes pugs inlines all use

[06:13] <svnbot6> r8315 | autrijus++ |   statements in the beginning of lines _except_ when it occurs on

[06:13] <svnbot6> r8315 | autrijus++ |   the first line, and it forgets to close over the scope in {...}

[06:13] <svnbot6> r8315 | autrijus++ |   brackets.  Fix both.

[06:13] <gaal> 8315 !!!

[06:13] <gaal> what a weird bug

[06:13] <audreyt> I forgot whose idea it was to do that

[06:14] <audreyt> it might have been me... or you

[06:14] <gaal> the problem with the nopasted code:

[06:15] <gaal> Couldn't match `Exp' against `GenParser Char RuleState Exp'

[06:15] <gaal> in mergeStmts

[06:15] <audreyt> that part is easy

[06:15] <audreyt> return . foldl mergeStmts Noop =<< smapM (rebind hardcodedScopeFixme) name

[06:15] <audreyt> s/smapM/mapM/

[06:16] <gaal> I tried lifting in all sorts of places :)

[06:16] <audreyt> or, more readably

[06:16] <audreyt> foo <- mapM (rebind hardcodedScopeFixme) names

[06:16] <audreyt> return $ foldl mergeStmts Noop foo

[06:16] <gaal> yeah, that won't work either, sec

[06:17] <gaal> darn. it DOES work.

[06:17] <gaal> arrrrghgh! :)

[06:17] * audreyt purrs

[06:17] <audreyt> do you want me to walk you thru? :)

[06:18] <gaal> I think I just forgot to "return" the fold

[06:18] <audreyt> I think so too :)

[06:18] <gaal> and was confused by the next error message

[06:18] <audreyt> and yes I think the plan is sane

[06:18] <gaal> so I started trying other things :(

[06:18] <audreyt> the main drawback of monadic code is that error message is hard to read 

[06:18] <gaal> ok there is one thing I'm not sure about there:

[06:18] <audreyt> although I've been told that Helium does it excellently

[06:18] <gaal> if i want to export say 3 SMys

[06:19] <gaal> is it totally cool to do Stmts (Pad ... A) Stmts (Pad ... B) Stmts (Pad .. C)

[06:19] <gaal> instead of the more succinct

[06:19] <gaal> uh,

[06:19] <gaal> something else? :)

[06:19] <gaal> (Pad A (Pad B (Pad C)))

[06:20] <gaal> or something similar

[06:20] <audreyt> Pad (A,B,C) etc

[06:20] <gaal> maybe this can be solved simply by having two remind functions

[06:20] <audreyt> I think it's totally cool to make it work using whatever

[06:20] <gaal> :-)

[06:20] <audreyt> and refactor later

[06:20] <audreyt> (seriously.)

[06:21] <gaal> audreyt++ # the pragmatic programmer

[06:21] <gaal> ohhh, good that you mentioned Heluim because I remembered I wanted to ask you about something

[06:22] <gaal> tools like buddha or other debuggers, none of them will work with wacky code like pugs'.

[06:23] <audreyt> with hs' in sight, I think that is going to change

[06:23] <audreyt> i.e. the main reason the tools doesn't work is that the last std is 98

[06:23] <gaal> how to debug pugs? i mean okay, it's great to keep things simple so you never have to single step (huh? in a fp language what does that even mean?)

[06:23] <audreyt> if there's a std in 06 that pugs can target against (which is what hs' is), there'd be better tool support

[06:23] <gaal> "hs'"? an anti-google name :/

[06:23] <Juerd> audreyt: (re journal) Ah, okay, neat :)

[06:24] <audreyt> gaal: http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/

[06:25] <gaal> very interesting

[06:25] <audreyt> but to answer your question, I just use ghci really

[06:25] <audreyt> and call single functions

[06:26] <gaal> audreyt: but when checking things in the parser, what can you pass as arguments?

[06:26] <audreyt> gaal: hmm? string for it to parse against?

[06:27] <audreyt> using runParser

[06:27] <gaal> but what if you want funky things like use, that rely on some Env?

[06:28] <gaal> basically: monads help reduce the explicitness of state being carried about

[06:28] <gaal> but that means it's harder to debug because you have to get the state from somewhere...

[06:28] <audreyt> nod... and you can conjure up the Env and pass it to runParser

[06:28] <audreyt> but our Env carries to much mutables and hardrefs, making it hard

[06:29] <gaal> re hs' -- interesting that http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/wiki/HaskellExtensions shows things that GHC doesn't have, I thought it was very innovative

[06:29] <audreyt> which is why the minilang evaluator is much simplified

[06:29] <audreyt> it is very innovative, but other implementations are also very innovative.

[06:29] * audreyt praises languages that has multiple implementations.

[06:29] <audreyt> "the official implementation" is overrated

[06:30] * gaal praises innovation (but is scared to consider what *other* new things lambdaheads have invented :)

[06:30] <audreyt> oh, there's one I really really like

[06:31] <audreyt> http://repetae.net/john/computer/jhc/jhc-reify-typeclass.html

[06:32] <audreyt> using "types are values" to reach "dynamic when needed static when possible"

[06:32] <luqui> ?eval {}.perl

[06:32] *** evalbot_8312 is now known as evalbot_8315

[06:32] <evalbot_8315> "sub \{...}" 

[06:32] <luqui> isn't that supposed to be a hash?

[06:32] <gaal> I almost but not completely have no idea what that means :-)

[06:33] <gaal> ...but I think I will defer trying to understand it till after I get some code working here

[06:33] <audreyt> luqui: s06

[06:33] <audreyt>        "{...}" is always a block.  However, if it consists of a single list,

[06:33] <audreyt>        the first element of which is either a hash or a pair, it is executed

[06:33] <audreyt>        immediately to compose a hash reference.

[06:34] <audreyt> so I guess we coded to the spec

[06:34] <luqui> I think we made a special case for {}

[06:34] <gaal> btw, in Perl 5, is there any difference between 'use 5.6' and 'require 5.6' ?

[06:34] <luqui> gaal, the latter is run at runtime

[06:34] <gaal> and apart from that?

[06:34] * luqui doesn't think so

[06:34] <audreyt> luqui: if it's not in S06... it's not made :)

[06:34] <luqui> :-)

[06:35] * luqui will look for the decision and add it if there is one

[06:35] <audreyt> please do. I think {} is hash makes sense

[06:35] <audreyt> we can always disambig with {;}

[06:36] <gaal> luqui: require perl5:DBI oughta work too, right?

[06:37] <luqui> .... probably

[06:37] <luqui> the difference between require and use is touchy

[06:37] <audreyt> bbiab

[06:38] <luqui> because of the distinction between "modules" (which hold exports) and "packages" that we've been talking about

[06:39] <gaal> well, I want at least to unify the first part of these statements: both use and require should work on the same atoms

[06:39] <gaal> and up to importation+configuration, should have the same syntax

[06:39] <luqui> require doesn't, er, didn't import

[06:39] <gaal> yes, I know

[06:39] <luqui> but if perl5: is just telling it where to look, I think that makes sense

[06:40] <gaal> so: version requests, languagespace requests -- these are common to use and require

[06:40] <audreyt> yes... as is authority, version

[06:40] <audreyt> as well as package name (if kane gets his way, which I reason he might)

[06:41] * luqui thinks that s06 is wrong in its clever wording

[06:41] <luqui> if it were true, then:  my @a = {1,2,3,4}  should be the same as  my @a = {return (1,2,3,4)}.() which is the same as my @a = (1,2,3,4)

[06:41] <luqui> when in fact it should be the same as my @a = hash(1,2,3,4)

[06:41] <luqui> i.e. a single element

[06:42] <audreyt> why would {} autorun?

[06:42] <audreyt> {} only autorun on void

[06:42] <audreyt> @a= is not void

[06:42] <audreyt> so it will become 

[06:42] <luqui> see your quote above

[06:42] <gaal> "executed immediately"

[06:42] <audreyt> so?

[06:42] <audreyt> it doesn't begin with a hash

[06:42] <audreyt> neither does it with a pair

[06:42] <audreyt> so autoexec doesn't happen

[06:42] <luqui> sorry

[06:43] <luqui> pretend that the first and third of those commas were =>

[06:43] <luqui> same issue

[06:43] <audreyt> then it becomes

[06:43] <audreyt> @a = {1=>2, 3=>4}

[06:43] <luqui> right

[06:43] <luqui> and it is "executed immediately", which is the same as @a = {(1 => 2, 3 => 4)}.()

[06:43] <audreyt> then @a contains a single elem

[06:44] <audreyt> which is a hashref

[06:44] <audreyt> no

[06:44] <audreyt> it is

[06:44] <audreyt> "executed immediately to compose a hash reference"

[06:44] <audreyt> which means it's run in Item(Ref<Hash>) context

[06:44] <audreyt> not the surrounding context

[06:44] <luqui> okay, fair enough

[06:44] <luqui> I guess the only difference between that and "just" constructing a hash is:

[06:45] <luqui> { a => my $b }

[06:45] <luqui> $b will not leak

[06:50] <luqui> ?eval {{a => 1}}

[06:50] <evalbot_8315> Error:  unexpected "{" expecting program 

[06:50] <luqui> ?eval { {a => 1} }

[06:50] <evalbot_8315> {("a" => 1),} 

[06:50] <luqui> see, that's wrong

[06:50] <luqui> ?eval { {a => 1} }.perl

[06:50] <evalbot_8315> "sub \{...}" 

[06:51] <luqui> hmmm.. or.. not

[06:51] <luqui> ?eval { say 42 }

[06:51] <evalbot_8315> OUTPUT[42 ] bool::true 

[06:51] <luqui> ?eval { { say 42 } }

[06:51] <evalbot_8315> OUTPUT[42 ] bool::true 

[06:51] <luqui> ??

[06:51] <audreyt> void context propagates

[06:51] <audreyt> that's correct.

[06:52] <luqui> I didn't know that evalbot ran its expression in void context

[06:52] <audreyt> need explicit "return" iirc.

[06:52] <luqui> and then somehow printed the void that's returned...

[06:53] <audreyt> mm

[06:54] <audreyt> eval("...").perl

[06:54] <audreyt> indeed it should be in item context

[06:54] <audreyt> so that's a bug

[06:57] <svnbot6> r8316 | luqui++ | Scratch.

[06:57] <svnbot6> r8317 | luqui++ | A bare {} is a hash, not a code.

[06:57] <svnbot6> r8318 | luqui++ | Add half-complete new rule parser.

[06:57] <luqui> heh, I guess I meant "half-compiling"

[06:57] <luqui> or half-working

[06:58] <luqui> certainly not half-complete :-p

[06:58] <luqui> ?eval {}.perl

[06:58] <evalbot_8315> "sub \{...}" 

[06:59] <audreyt> luqui: can we please get a S06 commit on that too :)

[06:59] * luqui already did

[06:59] <audreyt> oh, cool!

[06:59] <audreyt> luqui++

[07:00] <audreyt> need another bot to track synopses changes

[07:00] <audreyt> or hack multi repo support to svnbot

[07:01] <audreyt> bbiab

[07:20] <gaal> oh, funny problem:

[07:20] <gaal> ./pugs -e '{ use smth; } say "alive"'

[07:20] <gaal> this doesn't parse

[07:21] <gaal> but if there's a newline after the scope, it does.

[07:21] <gaal> ?eval { "significant newlines?" } say "hmm"

[07:21] *** evalbot_8315 is now known as evalbot_8318

[07:21] <evalbot_8318> Error:  unexpected "s" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:22] <luqui> gaal, I actually think that's specified

[07:22] <gaal> makes oneliners weird

[07:23] <luqui> put a semicolon after the brace

[07:23] <gaal> though the "fix" from the programmer's pov is to add a semicolon after the scope

[07:23] <gaal> heh

[07:23] <luqui> the problem we're facing is the fact that you can say { 42 }.do_something

[07:23] <gaal> anyway... we have lexical imports now! :-)

[07:23] <luqui> gaal++

[07:23] <luqui> sweet

[07:26] <gaal> i don't handle exported multisubs now though

[07:26] <gaal> can someone explain the '&' hack?

[07:27] <svnbot6> r8319 | gaal++ | imports are lexical now.

[07:27] <luqui> you mean the fact that &&foo represents multi foo?

[07:27] <gaal> yeah

[07:27] <luqui> no idea

[07:27] <luqui> I read that comment and ran away

[07:28] <gaal> shouldn't the VCode store that info?

[07:28] <gaal> *doesn't* it? :)

[07:28] <gaal> it does

[07:29] <gaal> anymoose... now to make imports lexical by default only :-)

[07:32] <audreyt> gaal++ # single-handedly made lexical imports work

[07:32] <audreyt> if nothing else, that alone should motivate me to resume journaling

[07:35] <gaal> adding variable exports now

[07:36] <gaal> (was surprised to find they weren't there!)

[07:38] <audreyt> meanwhile I'm trying to make sure that pugs compiles on win32 with latest ghc

[07:38] <audreyt> and  get some profile info out of it

[07:38] <audreyt> the recent slowdown makes a release a bit difficult

[07:39] <luqui> there was a recent slowdown?

[07:39] <gaal> since I started coLinux, I haven't built pugs on win32 fer real :-)

[07:39] <audreyt> luqui: yes... I suspect Ann [Prags] but may be caused by something else

[07:39] <luqui> the Ann thing

[07:40] <gaal> oh, which reminds me, if someone wants a small buildsystem project, turn off Prelude precompilation when building unoptimized

[07:41] <gaal> audreyt: I think introducing Ann is a more likely culprit than Ann [Prags] specifically

[07:41] <gaal> we never insert prag annotations yet

[07:41] <gaal> but yeah, expect a slowdown when we do! :-)

[07:43] * gaal eyes chained var declaraions testily

[07:45] <gaal> hey, another monadic Q: look at Parser.hs:673

[07:45] <gaal> there's a let exp' = ...

[07:46] <gaal> a bit later there's a exp'' <- exp'

[07:46] <gaal> why go up a monadic level just to go down?

[07:46] <gaal> just so you can use "fail" there?

[07:46] <luqui> that seems likely

[07:47] <gaal> okay, thanks.

[07:47] <audreyt> nod

[07:49] <gaal> what's the type of exp', btw? what monad has it entered, Eval?

[07:49] <webmind> hmm

[07:49] <webmind> feather had a high load again ?

[07:50] <luqui> gaal: it had better be RuleParser

[07:50] <luqui> because you're binding it to exp''

[07:51] <gaal> which is of type... Exp?

[07:52] <luqui> uh huh

[07:52] <luqui> but that's not why it has to be RuleParser

[07:52] <gaal> yes...

[07:53] <gaal> one of its possible values is "return exp"

[07:54] <gaal> um, no that's not a reason to be RuleParser either.

[07:54] <gaal> what is? :)

[07:54] <luqui> the fact that exp'' <- exp' is occurring within a RuleParser

[07:55] <gaal> "within" as in, the whole function has the signature ......... -> RuleParser foo?

[07:55] <gaal> well, just "RuleParser Exp" in this case

[07:55] <luqui> the "whole function" being the one that starts on line 655 in this case

[07:55] <luqui> yes

[07:56] <gaal> and we can infer that, because that uses "option", yes?

[07:56] <luqui> yep

[07:56] <gaal> option :: a -> GenParser tok st a -> GenParser tok st a

[07:56] <luqui> type inference++  # nonlocal dwimmery

[07:56] <gaal> what's the relation between "GenParser tok st a" and "RuleParser"?

[07:56] <gaal> ah

[07:56] <gaal> they're synonyms

[07:56] <luqui> the latter is probably a synonym for something like the former

[07:57] <gaal> src/Pugs/Parser/Types.hs:43, yes

[07:57] <gaal> ctags++

[07:57] * luqui adores ctags 

[07:57] <luqui> I've used it much in this project

[07:58] <gaal> luqui++ # helping me chip away at my ignorance

[07:58] * luqui taco bell (eww.. but it's the only thing that's open at this time of night) &

[08:03] <gaal> um, shouldn't the FIRST hack use a boolean and not an integer, which might in theory wrap around eventually? (vcode2firstBlock)

[08:03] <audreyt> integer is big and won't wraparound

[08:03] <audreyt> but a boolean should be preferred anyway.

[08:04] <gaal> okay, an integer is big and cause needless slowdown on looong running programs :-p

[08:04] <audreyt> right. :)

[08:05] <audreyt> I think Run.hs always ants to be compiled with optimization

[08:05] <gaal> once native int64s become common this is very unlikely to be a problem :)

[08:05] <audreyt> s/ants/wants/

[08:05] <gaal> audreyt: because of the prelude?

[08:05] <audreyt> yeah

[08:05] <audreyt> either that, or turn off it during unoptimize... wait, you just said that

[08:05] <gaal> tricky

[08:06] <gaal> the problem is that folks with "only" 300mb available really need not to precomp

[08:06] <audreyt> the problem is that -CPugs wants to become -CPIL2.Haskell ;)

[08:06] <audreyt> (which I'm working on)

[08:07] <audreyt> but yeah... I think have unoptimize to disable precomp with it is the correct workaround for now

[08:08] <gaal> hmmmm Parser:696 - isn't it a bug that the SState case doesn't handle unnestPad ?

[08:08] <gaal> (sorry for all the context switches...)

[08:10] <audreyt> a bug

[08:10] <audreyt> but I didn't hack in unnestPad in myself... it's a complex kludge :)

[08:11] <audreyt> infix:<=> shouldn't be a special form

[08:11] <gaal> I wasn't pointing any fingers :)

[08:12] <audreyt> I was :)

[08:12] <gaal> lol

[08:12] <audreyt> in any case, slapping a unnestpad to it should do

[08:13] <audreyt> cool, bleadghc compiles pugs fine.

[08:13] <dduncan> quick terminology question

[08:14] <audreyt> mm?

[08:14] <dduncan> what's a synonym for 'pure' like in a pure function such as sum(x,y), that's about 10 letters long

[08:14] <dduncan> what haskell functions have to be when not a monad

[08:14] <audreyt> side-effect-free?

[08:14] <gaal> unfilthy?

[08:14] <dduncan> or tighter

[08:14] <gaal> immaculate?

[08:14] <dduncan> a function whose results looks only at the arguments, not any globals

[08:14] <dduncan> gaal, good guess but no

[08:15] <audreyt> mathlike? ;)

[08:15] <gaal> dduncan: where is this haskell crossword you're looking at? :)

[08:15] <dduncan> or maybe I just mean a function with no side effects

[08:15] <gaal> innocent?

[08:15] <azuroth> purely functional...?

[08:15] <gaal> innocuous-only-spelled-right?

[08:15] <dduncan> actually, I'm writing documentation

[08:15] <audreyt> dduncan: evaluation-order-independent

[08:15] <gaal> tame?

[08:15] <audreyt> s/independent/agnostic/

[08:16] <dduncan> audreyt, the meaning is right

[08:16] <audreyt> dduncan: I think "free of side effects"

[08:16] <dduncan> independent

[08:16] <gaal> idempotent?

[08:16] <dduncan> sorry

[08:16] <dduncan> it may start with an 's'

[08:16] <gaal> idempotent is even exactly 10 letters.

[08:16] <dduncan> okay, I'll look in a book...

[08:16] <audreyt> so is "effectfree"

[08:17] <gaal> s/s(idempotent)/$1/ ?

[08:17] <dduncan> not a compound word

[08:17] <dduncan> reading ...

[08:17] <Khisanth> you remember the length of the word but not the word itself?!

[08:17] <audreyt> I do that all the time...

[08:17] <dduncan> that's how my memory works

[08:17] <dduncan> I'm much better with numbers

[08:18] <audreyt> "referentially transparent"? 

[08:18] <gaal> I often remember what part of the page (which side too) something was

[08:18] <Khisanth> I guess I am more suprised that someone would bother to count the length of words as they read :)

[08:18] <audreyt> Khisanth: different brain patterns :)

[08:19] <gaal> My only problem is that I often remember wrong :/

[08:19] <audreyt> i.e. not bothersome at all to me, sometimes

[08:19] <audreyt> bleadghc on win32 is much faster than I remembered

[08:19] <audreyt> hopefully it can complete without running out of heap

[08:20] <gaal> I set 500m heap nowadays :(

[08:20] <gaal> and that's w/o precompiling Test

[08:21] <audreyt> actually I suspect huge numbers of space problem will go away

[08:21] <audreyt> if we just replace String with FastPackedString and [] with Seq

[08:22] <audreyt> the list type is notorious for antisocial heap behaviour

[08:22] <dduncan> I found my answer

[08:22] <dduncan> "deterministic"

[08:22] <audreyt> dduncan: cool!

[08:23] <dduncan> that's a function whose answer is dependent only on the arguments, a pure math function

[08:23] <dduncan> thanks for trying, anyway

[08:24] <audreyt> np... I was reminded briefly of the time when we made hangman.p6 a bot

[08:24] <audreyt> it was fun

[08:25] <gaal> whee!

[08:26] <gaal> our Test doesn't do unscalar comparison, right? is smth_returning_a_list(), <val1 val2>

[08:27] <audreyt> no it does not

[08:27] <audreyt> the usual workaround is to compare .perl

[08:27] <gaal> oh right!

[08:27] <gaal> cool, thanks

[08:28] <audreyt> np:)

[08:38] <gaal> drats, sticking an unnestPad isn't enough because of vcode2firstBlock

[08:39] <gaal> but i think at least i did fix my $foo = our $bar

[08:39] <gaal> at least

[08:46] <svnbot6> r8322 | autrijus++ | * more fixes to get bleadghc to compile pugs

[08:47] <araujo> Hello.

[08:47] <araujo> Anyone knows if there exist a parrot channel?

[08:48] <audreyt> yes, irc.perl.org #parrot

[08:48] <araujo> thanks

[08:51] <audreyt> np :)

[08:53] * audreyt watches two insane #haskell people inventing co-evaluation

[08:54] <spinclad> [from 07:39Z]  .oO ( oh sure, blame Ann [Prags]!  .oO ( who the heck is Ann [Prags]?  can somebody introduce me to her?  has she been hacking here long? ) )

[08:56] <audreyt> spinclad: she lives in line 867 Pugs.AST.Internals

[08:58] <gaal> but she's been depressed and hasn't been doing much lately

[08:58] * audreyt discovers Control.Concurrent.STM.TArray in bleadghc

[08:58] <gaal> eeeeep! i think state variables leak

[08:58] <gaal> in baaaad ways

[08:58] <audreyt> excellent... now we just need a TMap and all container types can be implemented in 0 lines

[08:59] <gaal> let me post a demo

[08:59] <Khisanth> 0?

[09:00] <audreyt> Khisanth: 0, as in, it's already there

[09:00] <pasteling> "gaal" at 192.115.25.249 pasted "try omitting the nonces on variable names, get different results" (15 lines, 683B) at http://sial.org/pbot/15058

[09:01] <gaal> ...as posted test4 "chained my, state" fails with undef

[09:01] <gaal> if all $a and $bs are renamed to $a and $b...

[09:01] <gaal> $b is 44

[09:02] <gaal> which means the state isn't lexical

[09:03] <audreyt> mm, can you get it without chained = ?

[09:04] <gaal> let me try{}

[09:05] <gaal> ...no.

[09:07] <gaal> this btw is after making this change:

[09:07] <gaal> -unnestPad (Pad SMy lex (Syn "=" [v,Pad SMy lex' (Syn "=" [v',x])])) = Pad SMy lex (Stmts Noop (Pad SMy lex' (Syn "=" [v,(Syn "=" [v',unnestPad x])])))

[09:07] <gaal> +unnestPad (Pad scope1 lex (Syn "=" [v,Pad scope2 lex' (Syn "=" [v',x])])) = Pad scope1 lex (Stmts Noop (Pad scope2 lex' (Syn "=" [v,(Syn "=" [v',unnestPad x])])))

[09:08] <gaal> (just paramatize over scopes)

[09:09] <gaal> and, well

[09:09] <gaal> return $ unnestPad $ Pad scope lexDiff implicit_first_block

[09:09] <gaal> but i don't see how state leaks across scopes at all

[09:10] <gaal> bbiab &

[09:14] <audreyt> stevan: closure-based iterator with its own state is the way to go

[09:16] <audreyt> I think we can make one trivially (KISS and all that) by introducing a .iterate form

[09:16] <audreyt> for seqs

[09:16] <audreyt> I'll work on it after dinner

[09:17] * araujo thinking if emergin' pugs or not

[09:18] <audreyt> araujo: why not? :)

[09:18] <audreyt> but for now, dinner &

[09:19] <Khisanth> consumes  too much memory!

[09:21] <araujo> audreyt, I do't programm in perl :-/

[09:21] <araujo> Though i do in Haskel, and that's why i am kind of curious :-)

[09:24] <araujo> hah, i also see you have a poem in my native language in Main.hs , pugs++ :-)

[09:34] <gaal> rehi

[10:04] <wolverian> http://use.perl.org/~luqui/journal/28064 nice post :)

[10:27] <svnbot6> r8323 | gaal++ | * Pugs.Parser: improve handling of chained declarations with differring scopes

[10:27] <svnbot6> r8323 | gaal++ | * t/var/chained.t: some tests

[10:27] <svnbot6> r8323 | gaal++ | * t/var/state.t: demonstration that this still isn't perfect

[10:45] <svnbot6> r8324 | Darren_Duncan++ |  r1439@Darren-Duncans-Computer:  darrenduncan | 2005-12-20 02:43:42 -0800

[10:45] <svnbot6> r8324 | Darren_Duncan++ |  /ext/Rosetta-Incubator : updated SQL/Routine/Language.pod to add start of new DATA TYPES OVERVIEW pod section

[11:20] <clkao> err

[11:20] <clkao> runghc: cannot find ghcrunghc: cannot find ghcBuild failed: 256 at util/build_pugs.pl line 86.

[11:26] <gaal> clkao: worksfor me, but probably 8321 is the culprit?

[11:28] <clkao> setting proper PATH works.

[11:28] <clkao> was only setting it when running makefile.pl before

[11:29] <clkao> gr!

[11:29] <clkao> Setup.lhs: internal error: stg_ap_v_ret Please report this as a bug to [email@hidden.address]
[11:30] <clkao> do i need 6.4.1

[11:30] <gaal> last i heard 6.4 was still ok

[11:30] <gaal> but 6.4.1 recommended

[12:00] <araujo> clkao, where did oyu get that error?

[12:05] <clkao> 641 works fine

[12:05] <clkao> osmewhere running setup.lhs iirc

[12:13] <araujo> clkao, I knew that , i was asking about what step of setup.lhs :-)

[12:15] <clkao> configure: Dependency readline-any: using readline-1.0

[12:15] <clkao> Preprocessing library Pugs-6.2.10...

[12:15] <clkao> Building Pugs-6.2.10...

[12:15] <clkao> Setup.lhs: internal error: stg_ap_v_ret

[12:15] <clkao> luckily i have them in my scrollback. hth

[12:18] <araujo> clkao, are you using the ghc's cabal?

[12:18] <araujo> 6.4?

[12:18] <clkao> i have no idea

[12:19] <clkao> i upgraded already

[12:19] <araujo> ghc's cabal is kind of buggy.

[12:20] <araujo> I recommend you to use the stand-alone cabal version 

[12:40] <gaal> audreyt: ping

[12:52] <clkao> audreyt: you sure it's fixed?  still seems to be in Test namespace for me

[12:56] <clkao> nvm, it didn't actually compile. syck stuff. but it should tell me compile failed!

[13:10] <clkao> hmm,, did a proper compile, it still thinks i am declaring Test::foo

[13:17] <gaal> whee! this is like learning Haskell! http://www.matessa.org/~mike/dutil/p1.html

[13:17] <gaal> # message sent to the stars by Encounter 2001

[13:19] <svnbot6> r8325 | kane++ |  r576@coke:  kane | 2005-12-20 14:17:07 +0100

[13:19] <svnbot6> r8325 | kane++ |  * use constant to check existing files 

[13:19] <svnbot6> r8325 | kane++ |  * fix a bug in package::installed that returned the list of files as a string

[13:19] <svnbot6> r8325 | kane++ |  * add a small JIB::HOWTO

[13:19] <svnbot6> r8325 | kane++ |  * add file tests for uninstall

[13:19] <svnbot6> r8325 | kane++ |  * add tests for jib::installation::set

[13:19] <svnbot6> r8326 | kane++ |  r577@coke:  kane | 2005-12-20 14:17:29 +0100

[13:19] <svnbot6> r8326 | kane++ |  * add J::I::Set to represent your @INC for installatoins

[13:43] *** hlen_ is now known as hlen

[14:01] <gaal> yo stevan_

[14:18] <audreyt> yo

[14:19] <audreyt> clkao: okay, roger, will revert the runghc hack

[14:20] <audreyt> stevan_: I think .new_opaque to create a increment state var is the way to go

[14:23] <nothingmuch> obra: ping

[14:25] <svnbot6> r8327 | autrijus++ | * revert the runghc hack (was there to get bleadghc to compile)

[14:25] <svnbot6> r8327 | autrijus++ |   as it breaks Cabal 1.0 in vanilla GHC.  So much for backward

[14:25] <svnbot6> r8327 | autrijus++ |   compatibility... here's hope that GHC 6.6 gets released soonish.

[14:33] <obra> hi nothingmuch 

[14:45] <audreyt> stevan_: dispatcher lands... surprisingly extremely easy -- please sanity check _make_dispatcher_iterator

[14:49] <stevan_> audreyt: will do

[14:49] <svnbot6> r8328 | autrijus++ | * PIL.Native.Parser: parsing for negative numbers.

[14:49] <svnbot6> r8329 | autrijus++ | * PIL.Native: [].fetch(4) should return nil not exception

[14:49] <stevan_> gaal: did you see I finally commited some haskell

[14:49] <stevan_> and it works too :)

[14:50] * audreyt goes reading the /. interview with lwall

[14:50] <svnbot6> r8330 | autrijus++ | * dispatcher iterator lands -- this makes the object count

[14:50] <svnbot6> r8330 | autrijus++ |   after bootstrappign 10 instead of the original 4 -- but hey,

[14:50] <svnbot6> r8330 | autrijus++ |   it's a small price to pay to get "next METHOD" support.

[14:50] <svnbot6> r8330 | autrijus++ |   Stevan, please sanity check the implementation. :)

[14:50] <stevan_> ooohhh

[14:51] * stevan_ puts all $work aside for the morning ... 

[14:51] *** stevan_ is now known as stevan

[14:52] <audreyt> I started with coroutines and state vars and whatnot

[14:52] <audreyt> but then switched to the simplest way possible:)

[14:52] <stevan> simple is good

[14:53] <audreyt> now, why is metamodel.t still failing...

[14:53] <stevan> still?

[14:53] <audreyt> it wasn't?

[14:53] <stevan> i was working when I last commited (about 13 hours ago)

[14:53] <stevan> but I have not checked since

[14:54] <audreyt> mmmmm

[14:54] <stevan> I will investigate though

[14:54] <stevan> rebuilding pil now

[14:54] <audreyt> it's failing with 

[14:54] <audreyt> pil: Map.find: element not in the map

[14:54] <audreyt> I'll revert to older boot code

[14:54] <stevan> eak

[14:54] <stevan> I hate that error :P

[14:54] * audreyt has a distinct feeling of hacking BIOS

[14:54] <stevan> let me look first

[14:55] <audreyt> I'll improve the errmsg then

[14:55] <stevan> that error usually comes up when you ask for a non-existent attribute with get_attr

[14:55] <stevan> it was a large part of why I did has_attr :)

[14:56] <audreyt> I improved the error

[14:58] <audreyt> pil: Cannot find "%!methods" in map: ["$!name","@!MRO","@!superclasses"]

[14:58] <audreyt> appears that ::Foo did not copy over %!methods?

[14:59] <stevan> it is likely a bug in CREATE

[14:59] <svnbot6> r8331 | autrijus++ | * improve messages for NativeMap fetch error

[14:59] <stevan> I did not test it last night since I didnt have the dispatcher 

[15:00] <audreyt> the boot was okay before my dispatcher fix.

[15:00] <stevan> yeah

[15:00] <audreyt> or rather, s/fix/break/

[15:00] <clkao> audreyt: so the blank line issue?

[15:00] <stevan> I will look into it

[15:00] <audreyt> clkao: give me a minimal test case?

[15:00] <clkao> the test.pl is the minimum one

[15:00] <audreyt> I got the the test.pl

[15:00] <audreyt> how do I look at the namespace?

[15:01] <audreyt> -CJS?

[15:01] <clkao> no

[15:01] <clkao> -CPugs

[15:01] <clkao> |grep Test::foo

[15:01] <clkao> which should never exist

[15:01] <clkao> or -CPIL

[15:02] <audreyt> it now breaks regardless of whether there's a blank line or not

[15:02] <audreyt> which is a definite improvement

[15:02] <audreyt> ...not

[15:02] <clkao> oh well

[15:02] <clkao> it made my jsperl5 smoke this morning skip most of the tests

[15:02] <audreyt> fixing

[15:02] <clkao> because it simply doesn't work :P

[15:02] <audreyt> fixed

[15:03] <clkao> whoot

[15:05] <audreyt> committed

[15:06] <audreyt> clkao++

[15:06] <clkao> how did it all work before? 

[15:07] <gaal> rehi

[15:07] <svnbot6> r8332 | autrijus++ | * Pugs.Parser: when leaving a lexical block, restore not only

[15:07] <svnbot6> r8332 | autrijus++ |   the lexical pad, but the current package namespace as well,

[15:07] <svnbot6> r8332 | autrijus++ |   otherwise we leak over namespaces outside block, as clkao++

[15:07] <svnbot6> r8332 | autrijus++ |   had painfully observed...

[15:07] <audreyt> I don't know, sheer luck maybe

[15:07] <audreyt> (inlining of "use" modules only happens for -C and -B)

[15:07] <audreyt> gaal: hi

[15:08] <gaal> i unearthed (or caused :) an error when i tried exporting vars

[15:08] <svnbot6> r8333 | autrijus++ | * er, uhm, typo.

[15:09] <gaal> i think it only trips when you see a "$var is export" so i think i'll commit

[15:09] <gaal> is there a way to track "Prelude.head: empty list" errors?

[15:09] <audreyt> yes... redefine head ;)

[15:09] <audreyt> import Prelude hiding (head)

[15:09] <audreyt> import MyHead (head)

[15:10] <audreyt> but that doesn't help the general case

[15:10] <audreyt> which is to replace head calls with an assertionor trace

[15:10] <gaal> it never ceases to surprise me how far haskell has gone with so little in the way of standard debugging tools :)

[15:11] <audreyt> I think you can search and replace all calsl of

[15:11] <audreyt> head x

[15:11] <audreyt> into

[15:11] <audreyt> assert (not $ null x) head x

[15:11] <audreyt> which will give you the error location

[15:11] <audreyt> you can even do a #define for it.

[15:11] <audreyt> and put -cpp on the pragma line

[15:12] * gaal nods

[15:12] <audreyt> gaal: indeed... but then, haskell lacks most of enbugging features as well

[15:12] <audreyt> so it all balances out

[15:12] <gaal> that's why it's amazing

[15:12] <gaal> in this case though i'da wanted something replacing error with error-with-position

[15:13] <gaal> "assert" shows a stacktrace?

[15:13] <clkao> can we steal the non-enbugging feature ?

[15:14] <audreyt> gaal: no, only the erorr site

[15:14] <audreyt> gaal: depth-1-stack trace

[15:14] <obra> 'morning

[15:14] <audreyt> if you will

[15:14] <audreyt> gaal: I've talked with JaffaCake on a potential stack tracing assertion using repeated catch/throw (which will be even easier with GHC RTS support for delimited continuations) but I lack the tuits to code it up

[15:16] <gaal> eep, one of the recent commits tripped a rebuild. wish those were faster :(

[15:17] <gaal> stevan: re:hacking - yay :)

[15:17] <clkao> audreyt: still the same :/

[15:17] <clkao> no wait, compile failed

[15:18] <audreyt> clkao: I united jsperl5

[15:18] <audreyt> with perl5

[15:18] <clkao> whoot!

[15:19] <audreyt> how do I test it?

[15:19] <clkao> can you make try { use perl5:foo } non fatal?

[15:19] <audreyt> no, you need a require

[15:19] <clkao> audreyt: t/unspecced/p5/return.t

[15:20] <audreyt> clkao: how do I run it?

[15:20] <clkao> get my javascripit.pm from home.clkao.org/~clkao/jspm

[15:20] <audreyt> gah, why not commit it

[15:20] <clkao> ./runjs --run=jspm --perl5 ../../t/unspeccted/p5/return.t

[15:21] <clkao> hopefully it will be on cpan soon

[15:21] <audreyt> JavaScript.xs:8:22: jsdbgapi.h: No such file or directory

[15:21] <audreyt> I do have spidermonkey

[15:21] <audreyt> what gives?

[15:21] <clkao> locate jsdbgapi

[15:21] <clkao> you should have that from mozilla

[15:22] <audreyt> yup

[15:22] <clkao> set JS_INC to that directory

[15:22] <audreyt> I think you should ship it with you

[15:22] <audreyt> makes no sense to require moz install

[15:22] <clkao> *nod*

[15:22] <clkao> that's why it's not released yet. still some crap

[15:23] <audreyt> oh well.

[15:24] <clkao> *** Wasn't able to find 'Syck_stub.o', aborting...

[15:24] <clkao> gr!

[15:25] <obra> That's syck.

[15:25] <audreyt> clkao: did you clean up your dist/ ?

[15:25] <audreyt> hmm, the BACKEND fix doesn't really work.

[15:25] <clkao> no, i just killed that file.. make should be able to create it

[15:26] <audreyt> aha, that's because runjs pretends it's compiliing to PIL not to JS

[15:26] <audreyt> as far as the parser is concerned

[15:26] <audreyt> it's messy... I'll figure it out tomorrow

[15:26] <audreyt> need to sleep

[15:27] <clkao> it's early!

[15:27] <audreyt> no it's not... I'm still in australia time

[15:27] <clkao> alright. catch you tomorrow then.

[15:27] <clkao> hotspring countdown

[15:27] <clkao> i am going to hotspring directly from airport

[15:28] <kane-xs> clkao+- # good choice, but i'm jealous ;(

[15:30] <stevan> audreyt: I forgot the &redo.() in CREATE :)

[15:31] <stevan> however, I found a very nice debugging technique... "---------------------".trace()  adds nice seperators between other trace output :)

[15:31] <audreyt> excellent :)

[15:34] <stevan> once pugs finishes recompiling I will test metamodel.t

[15:34] <audreyt> I wonder why you'd need pugs instead of (say) pil :)

[15:34] <audreyt> i.e. "make pil" should be enough for metamodel.t

[15:35] <stevan> Test::PIL uses pugs

[15:35] * stevan ponders re-writing it in p5

[15:35] <audreyt> nah... it will be compiled to much faster minilang soon :)

[15:35] <stevan> :)

[15:35] <audreyt> I do plan to optimize the hell out of minilang :)

[15:35] <stevan> purity++

[15:36] <stevan> hey,.. didnt chromatic say he wanted to write a PIL optimizer while we were in toronto?

[15:36] <audreyt> :))

[15:36] <audreyt> he probably did

[15:36] <stevan> delegation++ ;)

[15:36] <audreyt> cool ;)

[15:36] <stevan> I will ask him if he is still interested

[15:37] <audreyt> yay. shower, brb &

[15:48] <nothingmuch> audreyt: isn't au time == tw time?

[15:49] <clkao> 2 hour differences iirc

[15:49] <nothingmuch> i thought they were ~~ same longitude

[15:50] <nothingmuch> http://reverie.aaeol.ca/about/timezone.jpg

[15:50] <nothingmuch> oh, i guess it depends which australia

[15:50] <nothingmuch> which part

[15:52] <audreyt> 3hr tzdiff

[15:54] <audreyt> stevan: so, aside from autoboxing, what else is there to do? container types? types as values? SigList and ArgList objects?

[15:55] <stevan> audreyt: I will finish the metamodel (minus Roles) and test the hell out of it today

[15:55] <audreyt> woot

[15:55] <stevan> then add roles

[15:55] <audreyt> Roles will rock too after that

[15:55] <audreyt> okay, I'll handle the compilation and boxing part

[15:55] <gaal> audreyt, stevan, didn't you want to change the fetch/store interface to do Maybe?

[15:55] <gaal> to fix the nil semipredicate problem

[15:56] * stevan defers to audreyt on this one

[15:56] <nothingmuch> i want pugs =(

[15:56] <nothingmuch> ENOTUITS

[15:56] <audreyt> gaal: which semipredicate problem again? :)

[15:56] <gaal> nothingmuch: just make sure you're available on Feb :)

[15:56] <nothingmuch> yeah, that's no problem

[15:56] <nothingmuch> i already cleared up time

[15:56] <gaal> audreyt: o_fetch can return "nil"

[15:57] <gaal> but then you can't tell if an attrib exists or is set to "nil"

[15:57] <gaal> you have to call has_attrib first

[15:57] <stevan> gaal: right now get_attr will die

[15:57] <audreyt> and the alternative is..?

[15:58] <audreyt> I think in minilang, exception handling is not needed

[15:58] <gaal> to return a Maybe Native (I think it was) and have the getter throw a detailed error

[15:58] <gaal> OK

[15:58] <audreyt> we already raise a sorta detailed error now

[15:58] <gaal> darn, I did the head-replacement operation

[15:58] <gaal> and the problem is not in Parser.hs

[15:58] <gaal> :-((

[15:58] <audreyt> :( try headhunting elsewhere then

[15:58] <audreyt> I need to doze off now... good night

[15:59] <gaal> bye

[15:59] <audreyt> good luck!

[15:59] <gaal> thanks :)

[16:00] <stevan> audreyt: once we have roles, I think the next step is the container types

[16:25] * audreyt loves the mdo notation

[16:26] <stevan> mdo?

[16:28] <PerlJam> method destruction order?  ;)

[16:29] <stevan> I was thinking maybe Microsoft Data Objects 

[16:29] <PerlJam> The thing about context is that you need to have enough of it for stuff to make sense.

[16:30] <audreyt> stevan: you are going to like this

[16:30] <audreyt> *PIL> eval "::Bit.add_method('foo', ->{3}); true.foo"

[16:30] <audreyt> 3

[16:30] <stevan> boxing!

[16:30] <stevan> auto-boxing?

[16:31] <theorbtwo> audrey: does it add the method lexically?  dynamically?  globally?

[16:31] * stevan thought audreyt  was going to sleep?

[16:31] <theorbtwo> Congrats on the great renaming, BTW.

[16:32] <audreyt> theorbtwo: globally. you can temporize it too

[16:32] <audreyt> also you can dynamically rebind ::Bit

[16:32] <audreyt> and the autobox will use the lexical ::Bit as class

[16:32] <_metaperl> stevan: ping?

[16:32] <audreyt> thanks re congrats :)

[16:32] <stevan> _metaperl: pong

[16:32] <integral> mdo with or without side effects? :)

[16:32] <audreyt> stevan: yes, full autoboxing with no strings attached

[16:32] <stevan> audreyt++ # horray

[16:33] <audreyt> integral: with sideeffects

[16:33] <audreyt> bootstrapClass x = mdo

[16:33] <audreyt>     cls <- newObject cls $ mkClassMethods [("add_method", addMethod)]

[16:33] <svnbot6> r8334 | autrijus++ | * autoboxing arrives to PIL.Native.*:

[16:33] <svnbot6> r8334 | autrijus++ |     ::Bit.add_method('foo', ->{3});

[16:33] <svnbot6> r8334 | autrijus++ |     true.foo; # 3

[16:33] <svnbot6> r8334 | autrijus++ |   Currently only Bit (also it doesn't reuse autoboxed objects),

[16:33] <svnbot6> r8334 | autrijus++ |   but the rest is just filling out the details in PIL.Native.Eval's

[16:33] <svnbot6> r8334 | autrijus++ |   bootstrapClass and PIL.Native.Objects's Boxable types -- helps welcome!

[16:33] <svnbot6> r8335 | autrijus++ | * redundant char

[16:33] * stevan is still trying to figure out what mdo is

[16:33] <audreyt> namely, using the lhs of a <- in the rhs of that <-

[16:33] <integral> wow.  that's very, very, very cool

[16:33] <audreyt> stevan: it's like the "do" notation but gets you value recusion

[16:33] <stevan> ah

[16:34] <audreyt> so you can use something to define itself

[16:34] <audreyt> which is why it's just one line to complete metamorphisis

[16:34] <gaal> what does "Native" refer to btw?

[16:34] * PerlJam finally switches to a haskell context so that things make sense

[16:34] <audreyt> no intermediate class-without-a-class

[16:35] <audreyt> gaal: it refers to "something that is not civilized^Wmetamodelled"

[16:35] <gaal> well, nativity also means pertinent to birth :-)

[16:36] <audreyt> which fits the gnosis theme :)

[16:36] <audreyt> integral: if you got tuits, maybe tidy up the Boxable code and create default ::Bit ::Num etc using the boilderplace in PIL.Native.Eval?

[16:36] <audreyt> once we get that we can autobox everything :)

[16:37] <audreyt> in any case... have fun, I'll conclude this committing-in-my-sleep session :)

[16:38] * audreyt waves &

[16:38] <gaal> hmm how do i express a pattern match in a "when" condition?

[16:38] <gaal> when (isExport && lhs ~~ (VStr x))

[16:38] <gaal> I know I can case, but don't wanna

[16:38] <audreyt> easiest is to derive isVStr

[16:38] <audreyt> DrIFT can do that for you

[16:38] <audreyt> but you can define it yourself

[16:39] <audreyt> isVStr (VStr _) = True -- etc

[16:39] <gaal> cool, thanks

[16:39] <audreyt> np. :)

[16:39] <audreyt> really &

[18:06] *** evalbot_8318 is now known as evalbot_8335

[18:11] <nothingmuch> stevan: ping

[18:13] <nothingmuch> ?eval say "redhat-- " for 1 ...;

[18:13] <evalbot_8335> pugs: out of memory (requested 1048576 bytes) 

[18:13] <nothingmuch> =(

[18:35] *** kakos|away is now known as kakos

[20:44] <svnbot6> r8336 | stevan++ | PIL/Native/Bootstrap.pil

[20:44] <svnbot6> r8336 | stevan++ | - simplified bootstrapping (much less meta-circularity issues

[20:44] <svnbot6> r8336 | stevan++ |   in the mini-language)

[20:44] <svnbot6> r8336 | stevan++ | - added ::Object.isa and .can 

[20:44] <svnbot6> r8336 | stevan++ | - this file is 99% complete, we still need ::Package.FETCH &

[20:44] <svnbot6> r8336 | stevan++ |   .STORE (and the overriden versions for ::Class), but those

[20:44] <svnbot6> r8336 | stevan++ |   can come later on

[20:44] <svnbot6> r8336 | stevan++ | - added many new tests as well (see t/pil/*)

[21:16] <gaal> hmm. variable exportation will be harder than I thought, because the actual object is only created in Eval (reducePad).

[21:17] <gaal> audreyt: I'll have to pick your brains about this, unfortunately tomorrow's a longish $work day

[21:18] <gaal> one ugly way would be to unsafeEvalExp in the parser immedeately and then look up the fresh object. yuck!

[21:18] <gaal> I'm not even sure what that requires to get to work though.

[21:19] <gaal> on that happy note I will bid you good night. &

[22:31] <svnbot6> r8337 | stevan++ | PIL/Native/Bootstrap.pil

[22:31] <svnbot6> r8337 | stevan++ | - added ::Class.isa() because it is different than ::Object.isa()

[22:31] <svnbot6> r8337 | stevan++ | t/pil/*

[22:31] <svnbot6> r8337 | stevan++ | - renamed metamodel.t to basic_object.t

[22:31] <svnbot6> r8337 | stevan++ | - added inheritence.t to test basic inheritance 

[22:47] <stevan> audreyt: I am feeling pretty confident in the metamodel now. I still want to write some more tests before I introduce roles.

[22:48] <stevan> audreyt: but once that is done, roles shouldn't take too long to add and test

[22:48] <stevan> audreyt: we do however need to discuss how to handle next METHOD

[22:49] <stevan> audreyt: we can can go the CLOS route and just create a lexically scoped function for each method invocation

[22:50] <stevan> similar to how $?CLASS and $?SELF are handled

[22:58] <stevan> audreyt: I think that next METHOD will likely need to be written in Haskell

[22:58] <stevan> but we should be able to just add it to the lex like $?SELF and $?CLASS

[23:00] * stevan dinner & (be back in ~2 hours)

[23:59] <rafl> nothingmuch: ping

