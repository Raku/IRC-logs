[00:01] <geoffb> rafl, by "pin to the etch release" do you mean setting APT::Default-Release in apt.conf or something else?

[00:02] <rafl> That's what I mean. Then sid packages will only be installed if you explicitly ask for it.

[00:02] <geoffb> rafl, even for dependencies?  That would be much easier.

[00:02] <geoffb> I guess a versioned dependency would override . . . .

[00:03] <rafl> No. If the dependencies can't be satisfied from etch they will be pulled from sid without asking you.

[00:03] <rafl> Otherwise it'll install etch packages.

[00:03] <geoffb> cool.

[00:04] <geoffb> When you do it manually using dpkg, I assume you just wget out of the package pool?

[00:04] <geoffb> Yay . . . pinning the release passed the "update and dist-upgrade installs nothing" test

[00:06] <geoffb> (apt-cache policy)++

[00:10] <geoffb> Oooh, working as advertised, rafl.  Thanks.  Sometimes one just needs to hear "No really, it will work the way you want it to."  :-)

[00:10] <rafl> :-)

[00:11] <rafl> geoffb: Well, I use a small script that gets the package from the pool. It doesn't handle dependencies, though.

[00:21] * nothingmuch doesn

[00:21] <nothingmuch> 't understand why it breaks this way

[00:21] <nothingmuch> Some::Object->new(..., orig => $obj, ...); # after a while orig is gone

[00:25] <geoffb> nothingmuch, this is old, I'm sure -- but I like your idea for a circularly defined functionally complete prelude -- did that come from your Forth interpreter hacking?

[00:25] <nothingmuch> that's what  I'm working on these days

[00:26] <nothingmuch> http://svn.openfoundry.org/pugs/perl5/Blondie/

[00:26] <geoffb> I'll take a look as soon as the pugs build completes

[00:27] <nothingmuch> it's perl 5 =)

[00:30] <nothingmuch> i'm off to bed

[00:31] <geoffb> OK

[00:31] <geoffb> cool.

[00:31] <geoffb> Is everything that I need to know in the README or whatever?

[00:31] * geoffb is multitasking

[00:32] <nothingmuch> in the example, I guess

[00:32] <nothingmuch> The parts are:

[00:32] <nothingmuch> AST (Blondie::Nodes) constructs programs

[00:32] <nothingmuch> Blondie::Compiler compiles them using Blondie::Prelude

[00:33] <nothingmuch> it creates a single AST from an AST and an env

[00:33] <nothingmuch> Blondie::Backend::* takes this AST and does something else with it

[00:33] <nothingmuch> the Perl runtime can just interpret it

[00:33] <nothingmuch> the C runtime uses Blondie::TypeSafe to type infer the AST and install explicit conversions on type mismatch

[00:34] <nothingmuch> Then the C runtime emits the code, binds it using Inline::C, and runs it

[00:34] <geoffb> How complex are the "programs" taht it understands?  Just little snippets?

[00:34] <nothingmuch> we have calls with fixed param numbers

[00:34] <nothingmuch> and perl values

[00:35] <nothingmuch> theretically it's good enough

[00:35] <geoffb> good enough to do PIL -> Blondie AST, you mean?

[00:35] <nothingmuch> i doubt it... not yet

[00:35] <nothingmuch> good enough == turing complete ;-)

[00:35] <nothingmuch> i don't think there is any reason to do PIL -> Blondie, too

[00:36] <nothingmuch> Blondie is strictly optimized to make the compilation simpler

[00:36] <geoffb> heh

[00:36] <nothingmuch> it's got no lexical scop

[00:36] <nothingmuch> e

[00:36] <nothingmuch> it's got no objects

[00:36] <nothingmuch> it's got no assignment

[00:36] <geoffb> wheee

[00:36] <nothingmuch> these things can be added on later if we like

[00:37] <geoffb> right

[00:37] <nothingmuch> but right now i'd like to concentrate on the compilation, which is the part i'm interested in =)

[00:37] <geoffb> So what are your plans from here?

[00:37] <geoffb> oh jinx

[00:37] <nothingmuch> finish the C backend

[00:37] <nothingmuch> start expanding the prelude

[00:37] <geoffb> nodnod

[00:37] <nothingmuch> type safety for higher order functions

[00:37] <geoffb> Is harrorth on the back burner or pretty much dead?

[00:38] <nothingmuch> i'd say it's on hold

[00:38] * nothingmuch tends to give few time slices to projects like that after he's not learning as much ffrom them as he was in the begining

[00:38] <nothingmuch> anyway i really must be off

[00:39] <geoffb> g'night!

[00:39] <geoffb> and I know what you mean

[02:55] <rafl> Wow, Catalyst really rocks. I wrote a little CMS+Blog including an RSS feed that uses POD files as its database within a few hours. The original version of that (without rss feed) was more than three times bigger and I needed about a week to write it. :-)

[02:56] <rafl> Hopefully someone ports it to Perl6 :-)

[03:08] <stevan> rafl: IIRC sri has already begun the porting of catalyst

[03:08] <stevan> not sure what stage it is in, he never checked it in

[03:17] <rafl> Cool!

[03:58] <Supaplex> Catalyst?

[04:00] <rafl> stevan: catalyst.perl.org

[04:00] <rafl> Err, Supaplex: catalyst.perl.org

[04:03] <Supaplex> thanks

[04:04] * Supaplex waits for it to ... load...

[04:04] <Supaplex> ding

[05:28] <gaal> morning!

[05:38] <masak> morning

[05:40] <gaal> heya masak

[05:44] <geoffb> morning, gaal 

[05:44] <geoffb> and morning, masak :-)

[05:55] <rafl> Yay, suspend to disk on a swap partition on LVM2! :-)

[05:58] <masak> hooray, examples/games/wizard.p6 is working again! :)

[05:58] <rafl> It seems to become a good morning. :-)

[05:59] <masak> indeed

[05:59] <geoffb> hooray, I finally have all my non-darcs checkouts converted to svk! :-)

[05:59] <geoffb> nodnod

[05:59] <masak> everybody's happy, it seems

[05:59] <geoffb> I'd be even happier if SVK spoke darcs . . .

[06:00] <rafl> I'd be even happier if SVK would be darcs. :-)

[06:00] <masak> it seems to me they have some things in common, though

[06:02] <wolverian> Catalyst needs to get higher in the google results for 'catalyst' :)

[06:02] <geoffb> definitely.  I just happen to like SVK for a number of reasons, and would prefer not to ever care about what the backend is for any checkout.

[06:03] <masak> geoffb: lately we have a lot of cvs-esque alternatives. it's time to become picky and choosey :)

[06:05] <masak> svk is the best i've used so far

[06:05] <masak> but i still haven't tried darcs

[06:05] <geoffb> I'm all in favor of abstracting out the back end.  I'm picky about my client, but less so about the protocol & server -- with the exception that they had bloody well better support atomic change/patch sets, or some such isomorphic concept

[06:05] <geoffb> nodnod

[06:10] <gaal> hey geoffb, long time no moose.

[06:10] <geoffb> MOOOOOSE

[06:10] <geoffb> no kidding

[06:10] <geoffb> new system hell

[06:10] <geoffb> I think I'm on the other side now, though.

[06:11] <geoffb> Basic utilities I can't believe aren't installed on every *nix system by default, #105: tree

[06:12] <geoffb> What have you been up to, gaal?

[06:12] <wolverian> IRC-- # no default encoding for channel names 

[06:12] <geoffb> wolverian, ???

[06:12] <wolverian> (or if there is, it's ASCII or something similarly pathetic)

[06:12] <gaal> they had encodings when irc was invented? :)

[06:12] <gaal> geoffb, oh, bits and pieces

[06:13] <wolverian> standards are called "standards" because they're meant to be modified

[06:13] <geoffb> gaal, yep: EBCDIC or ASCII-7, your choice

[06:13] <gaal> that's why they shoulda've been called walkards. or creepards

[06:14] <geoffb> shuffleards?

[06:14] <wolverian> oh, for the love of god, there is a tree(1)? I have coded this myself in perl many many times :/

[06:14] <geoffb> oh dear

[06:16] <wolverian> well, it was fun, anyway

[06:16] <geoffb> And you probably learned something . . . um, well at least the first time

[06:18] <azuroth> hmm. I'm trying pugs, but I'm getting weirdness with shebangs. it's running with bash or something, even though the shebang says to use /usr/bin/pugs

[06:24] <gaal> azuroth, does invoking the script with an explicit interpreter work?

[06:24] <gaal> /usr/bin/pugs yourscript.p6

[06:25] <azuroth> yeah, it does

[06:26] <gaal> can you nopaste the output of what goes wrong?

[06:26] <gaal> perlbot nopaste

[06:26] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[06:28] <pasteling> "azuroth" at 220.245.178.140 pasted "shebang" (26 lines, 1.1K) at http://sial.org/pbot/13237

[06:29] <azuroth> if I go "/usr/bin/pugs test.p6", works fine... if I put stuff like "echo $SHELL" in there, it tells me /bin/bash or somesuch

[06:33] <nothingmuch> morning

[06:33] <geoffb> morning, nothingmuch 

[06:34] <dduncan> morning ... and good night

[06:42] <gaal> azuroth, this is weird. but i don't have a unix pugs around so i can't reproduce it.

[06:42] <gaal> putter, ping

[06:42] <azuroth> ahh

[06:43] <azuroth> well I'm going to try setting up apache to explicitly call `pugs blah` on all .p6 files... if I can?

[06:43] <gaal> i'm no expert on apache, but i think you can, like people used to associate '.cgi' with perl(5).

[06:44] <gaal> actually while you're at it, make the association with pugs_bin, because recently that's what 'pugs' has been made to frontend.

[06:44] <gaal> save yourself a fork :)

[06:44] <azuroth> ahh, okay

[06:44] <gaal> (and a p5 load hit!)

[06:44] <azuroth> er...

[06:44] <geoffb> The latter being by far the bigger pain

[06:45] <gaal> okay we really really need a getopt library ported

[06:45] <gaal> and preluded.

[06:45] <azuroth> I changed the shebang to pugs_bin ... it works now...

[06:45] <gaal> interesting, i thought interpreter hopping was supposed to work

[06:45] <gaal> what os are you on?

[06:46] <azuroth> debian

[06:47] <azuroth> hmm... yay, I suppose

[06:47] <gaal> wow, we'll need to back off that frontending it seems. it also causes problems on win32.

[06:47] <gaal> thanks for the report!

[06:48] <azuroth> that's alright ;-p

[06:49] <azuroth> now I need to figure out how to do CGI

[06:50] <gaal> hint the first: replace `print ".....\n"` with `say "....."` :-)

[06:54] <azuroth> hurrah

[06:55] <wolverian> do we have filehandle objects yet?

[06:55] <gaal> open returns an IO

[06:56] <wolverian> does it have methods? :)

[06:56] <wolverian> I mean, $STDOUT.record_separator = "\r\n"; etc 

[06:58] <gaal> not very interesting ones yet :) see Prelude.pm - and please hack :)

[06:58] <gaal> but =, btw, is a method.

[06:58] <wolverian> right. :) 

[06:58] <wolverian> I thought larry said it isn't?

[06:59] <gaal> he did?

[06:59] <wolverian> I had the impression he said in some p6l post that = and . are not methods

[06:59] <wolverian> which TSa argued against (never mind, never mind..)

[06:59] <gaal> in the prelude it's a "next" method on iterables

[06:59] <wolverian> oh

[06:59] <wolverian> you mean =$foo

[06:59] <wolverian> I meant &infix:<=>

[06:59] <gaal> aah

[06:59] <gaal> yes

[06:59] <wolverian> anyway, I have a maths lecture now, from which I'm late already. have to go :) 

[07:00] <gaal> bye :)

[07:02] <azuroth> while (=<STDIN>) { say $_; } ??

[07:02] <gaal> say for =$*IN

[07:02] <gaal> you don't need <>

[07:03] <azuroth> hmm, okay

[07:03] <geoffb> What's the preferred way to interpolate an array into a string?

[07:03] <gaal> actually, you want print in this case, not say, since we don't autochomp (yet)

[07:03] <geoffb> "@foo" no workie

[07:03] <azuroth> ahh

[07:03] <gaal> {[~] @foo} ? :-)

[07:03] <geoffb> bleh!

[07:04] <geoffb> hmm . . .

[07:04] <gaal> {@foo} works.

[07:04] <geoffb> yeah, just tried that

[07:05] <geoffb> ?eval my $foo = 5 == 5; $foo.perl

[07:05] <evalbot_7057> '\\bool::true' 

[07:06] <geoffb> ?eval my $foo = 5 == 5; "$foo"

[07:06] <evalbot_7057> '1' 

[07:06] <geoffb> ?eval my $foo = 5 == 4; "$foo"

[07:06] <evalbot_7057> '' 

[07:06] <geoffb> ?eval my $foo = 5 == 4; $foo.perl

[07:06] <evalbot_7057> '\\bool::false' 

[07:06] <gaal> you want 0? try numeric context.

[07:06] <geoffb> That's just the problem, I was interpolating it into a string.  :-)

[07:07] <geoffb> And anyway, why bother to have a different case for strings?  0 is still false, right?

[07:07] <geoffb> All hail iblechbot 

[07:08] <geoffb> er, "0", I meant

[07:11] <dduncan> hail

[07:11] <geoffb> I thought you were going to sleep, dduncan?

[07:11] <geoffb> Or was that good night just a timezone reference?

[07:12] <dduncan> I am going to sleep

[07:12] <dduncan> really

[07:12] <gaal> i don't know, maybe so ([~] @tests).chars counts successes? j/k :-)

[07:12] <dduncan> and its 12:12am here

[07:13] <dduncan> I should be back online in 10 hours ...

[07:13] <dduncan> starting NOW

[07:14] <geoffb> gaal, that is so disturbing a rationale, but you know, I would believe it.

[07:14] <geoffb> well, almost.

[07:15] <geoffb> Man, my tendency to use fat comma all over the place in Perl 5 is going to bite me in the ass over and over as I do Perl 6 conversions

[07:16] <azuroth> fat comma?

[07:16] <geoffb> =>

[07:17] <azuroth> ahh

[07:17] <azuroth> half a space ship

[07:17] <geoffb> :-)

[07:17] <geoffb> ?eval 1 => 2 => 3

[07:17] <evalbot_7057> (1 => (2 => 3)) 

[07:17] <geoffb> good

[07:18] <azuroth> eek

[07:20] <geoffb> ?eval ?(1 => 2)

[07:20] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:20] <geoffb> ur?

[07:21] <geoffb> ?eval my $foo = 1 => 2; $foo

[07:21] <evalbot_7057> (1 => 2) 

[07:21] <azuroth> ?eval say (1)??('a'):('b');

[07:21] <evalbot_7057> Error:  unexpected ":" expecting term postfix, operator or "!!" 

[07:21] <geoffb> ?eval my $foo = 1 => 2; ?$foo

[07:21] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:21] <azuroth> ?eval say (1)??('a')!!('b');

[07:21] <evalbot_7057> a bool::true 

[07:22] <geoffb> OK, something is just broken with booleanization of Pairs

[07:22] <geoffb> Anyone know what the rule is supposed to be?  Is it always bool::true, or does it depend on the key or value or both?

[07:23] <geoffb> ?eval ?1

[07:23] <evalbot_7057> bool::true 

[07:23] <geoffb> ?eval ?0

[07:23] <evalbot_7057> bool::false 

[07:23] <geoffb> ?eval ?"0"

[07:23] <evalbot_7057> bool::false 

[07:23] <geoffb> good.  :-)

[07:23] <geoffb> ?eval ?""

[07:23] <evalbot_7057> bool::false 

[07:23] <geoffb> ?eval ?"0.0"

[07:23] <evalbot_7057> bool::true 

[07:23] <geoffb> ?eval ?0.0

[07:23] <evalbot_7057> bool::false 

[07:24] <azuroth> ?eval 1?

[07:24] <evalbot_7057> Error:  unexpected "?" expecting digit, "_", fraction, exponent, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:24] <azuroth> ?eval 1?;

[07:24] <evalbot_7057> Error:  unexpected "?" expecting digit, "_", fraction, exponent, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:24] <azuroth> oh, right

[07:24] <nothingmuch> wow, that was fun

[07:24] <azuroth> what was?

[07:24] <geoffb> ?

[07:25] <nothingmuch> replied to the gather : async { } thread

[07:25] <nothingmuch> implemented scook's function

[07:25] <nothingmuch> and gathedr

[07:25] <nothingmuch> conclusion: perl 6 needs continuations

[07:25] <nothingmuch> conclusion 2: perl 6 is fucking cool

[07:25] <geoffb> :-)

[07:25] <geoffb> nothingmuch, do you happen to remember what the boolean context rule for Pairs is?

[07:26] <nothingmuch> nope

[07:26] <geoffb> damn

[07:26] <nothingmuch> i'm guessing ?$pair.snd

[07:26] <geoffb> huh?

[07:26] <nothingmuch> boolean context of the values

[07:26] <nothingmuch> value

[07:26] <nothingmuch> http://www.nntp.perl.org/group/perl.perl6.language/23139

[07:27] <geoffb> ?eval my $foo = 1 => 2; $foo.snd

[07:27] <evalbot_7057> Error: No compatible subroutine found: "&snd" 

[07:27] <geoffb> ?eval my $foo = 1 => 2; $foo.2nd

[07:27] <evalbot_7057> Error:  unexpected "." expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:27] <geoffb> ?eval my $foo = 1 => 2; $foo.value

[07:27] <evalbot_7057> \2 

[07:27] <nothingmuch> aye

[07:27] <nothingmuch> ?eval my $foo = 1 => 2; ?$foo

[07:27] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:27] <nothingmuch> ?eval my $foo = 1 => 2; ? $foo

[07:27] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:27] <nothingmuch> ?eval my $foo = 1 => 2; $foo ?? 1 :: @

[07:27] <geoffb> and therein lies my problem

[07:27] <nothingmuch> ?eval my $foo = 1 => 2; $foo ?? 1 :: 2

[07:27] <evalbot_7057> Error:  unexpected ":" expecting operator or "!!" 

[07:27] <nothingmuch> ?eval my $foo = 1 => 2; $foo ?? 1 !! 2

[07:27] <evalbot_7057> 1 

[07:28] <nothingmuch> ?eval my $foo = 1 => undef; $foo ?? 1 !! 2

[07:28] <evalbot_7057> 1 

[07:28] <nothingmuch> bah

[07:28] * nothingmuch is really amazed at how easy 'sub buffer_lazy' was

[07:29] <geoffb> Man, perl6-language needs a better archive interface than nntp.perl.org

[07:30] <nothingmuch> google hasn't gotten the msg yet

[07:31] <geoffb> ?eval my $foo = undef => undef; $foo ?? 1 !! 2

[07:31] <evalbot_7057> 1 

[07:31] <geoffb> ?eval my $foo = undef; $foo ?? 1 !! 2

[07:31] <evalbot_7057> 2 

[07:32] <geoffb> So it seems a Pair is true, but prefix:<?> doesn't know how to handle it

[07:32] <geoffb> At least, that's the way pugs sees it

[07:33] <QtPlatypus> ?eval my $foo = undef=>undef; ?$foo;

[07:33] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:33] <QtPlatypus> ?eval my $foo = undef=>undef; ? $foo;

[07:33] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:33] <QtPlatypus> ?eval my $foo = undef=>undef; say ?$foo;

[07:33] <evalbot_7057> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[07:35] <nothingmuch> submit a bug report?

[07:35] <nothingmuch> i.e. test?

[07:37] <geoffb> I was planning to.  I was hoping someone knew (for relative sure) the correct booleanization.

[07:37] <geoffb> So I could make a test better than "this shouldn't error"

[07:37] <nothingmuch> geoffb: i think you get to decide ;-)

[07:37] <geoffb> heh

[07:37] <nothingmuch> the most sensical thing is, IMHO, value, but that's just an opinion

[07:38] <ods15> hya nothingmuch 

[07:38] <azuroth> does that mean the ternary for it is buggy too, then?

[07:38] <azuroth> or is that entirely different :x

[07:39] <nothingmuch> hi ho

[07:39] <geoffb> fair nuf.  The only other halfway rational thing I can think of is the way ternary is interpreting it: It's a complex thing, so therefore true.

[07:39] <ods15> ?eval 5

[07:39] <evalbot_7057> 5 

[07:39] <ods15> ?eval 5;

[07:39] <evalbot_7057> 5 

[07:39] <ods15> hmm, that's slightly interesting

[07:39] <nothingmuch> azuroth: i think it's a syntactic issue

[07:39] <nothingmuch> ods15: how come?

[07:39] <nothingmuch> last statement of any block has optional ;

[07:39] <ods15> what does ; do?

[07:40] <nothingmuch> it's a separator more than a statement closer

[07:40] <nothingmuch> and it allows empty statements

[07:40] <nothingmuch> my $foo = do { ...; $x };

[07:40] <nothingmuch> my $foo = do { ...; $x; };

[07:40] <ods15> well, i thought ; turns an expression into a statement

[07:40] <nothingmuch> not really

[07:41] <nothingmuch> it's more mundane than it seems

[07:41] <ods15> mundane?

[07:41] <nothingmuch> every statement is possibly an expression and vice versa

[07:41] <geoffb> Evil bug workaround:    # my $update = %move_update{$command} or return;

[07:41] <geoffb>     my $update = %move_update{$command} ?? %move_update{$command} !! return;

[07:41] <ods15> 'if' ?

[07:41] <nothingmuch> if is a construct, not a statement

[07:41] <ods15> ?eval if(0) { 1 }

[07:41] <evalbot_7057> undef 

[07:41] <ods15> ?eval if(0) { 1 } else { 2 }

[07:41] <evalbot_7057> 2 

[07:42] <nothingmuch> although in pugs it's hacked to be an expression too ;-)

[07:42] <ods15> ...

[07:42] <nothingmuch> that's not what you think it is

[07:42] <nothingmuch> this is for

[07:42] <ods15> if is a statement :)

[07:42] <ods15> ?eval $a = if(0) { 1 } else { 2 };

[07:42] <evalbot_7057> Error:  unexpected "i" expecting term reserved word 

[07:42] <nothingmuch> sub factorial ($n) { if ($n == 0) { 1 } else { $n * factorial($n - 1) } }; factorial(5);

[07:43] <nothingmuch> ods15: no, it isn't

[07:43] <ods15> ?eval $a = (if(0) { 1 } else { 2 });

[07:43] <evalbot_7057> Error:  unexpected "i" expecting expression reserved word 

[07:43] <nothingmuch> ?eval sub factorial ($n) { if ($n == 0) { 1 } else { $n * factorial($n - 1) } }; factorial(5);

[07:43] <evalbot_7057> 120 

[07:43] <ods15> hmm

[07:43] <ods15> ?eval $a = do{ if(0) { 1 } else { 2 } }; $a

[07:43] <evalbot_7057> Error: Undeclared variable: "$a" 

[07:43] <ods15> ?eval my $a = do{ if(0) { 1 } else { 2 }; }; $a

[07:43] <evalbot_7057> \2 

[07:43] <geoffb> boo-yah!

[07:43] <nothingmuch> ods15: "every block is a closure"

[07:44] <ods15> geoffb: damn where is that from

[07:44] <nothingmuch> so oevery block can return

[07:44] <nothingmuch> hence every block can do an implicit return

[07:44] * geoffb managed to get to step 40 in his conversion of Perl 5 OpenGL code from his perl.com articles to Perl 6

[07:44] <geoffb> ods15, it has been a long damn road.

[07:45] <geoffb> Only 35 more steps to go, so far.

[07:45] <geoffb> Of course, I'm hoping to make the Perl 6 conversion be article 6.  I've only published 4 so far, so the goal will get farther away before I'm done.

[07:45] <ods15> geoffb: hmm, oh, i know, from GG

[07:46] * geoffb blinks

[07:46] <geoffb> GG?

[07:46] <ods15> gilmore girls

[07:46] <ods15> in the ep where she interviewed some geek he kept saying booyah

[07:46] <geoffb> oh, you mean the exclamation "boo-yah!"?

[07:47] <geoffb> ah, well, not from there, but I have no idea where

[07:47] <QtPlatypus> boo-yah is a canadiean thing I think.

[07:47] <geoffb> OK, now that I have the workaround in place, time to go file a pugsbug

[07:48] <geoffb> o/~ Blame Canada! o/~

[07:48] <nothingmuch> boo-yah much older than gilmore girls, ods15 

[07:48] <ods15> nothingmuch: yes i know, but tried to remember where _I_ know it from :)

[07:49] <nothingmuch> ah

[07:51] <azuroth> ~ is concat? what about . ?

[07:51] <geoffb> Wheee, wikipedia rules: http://en.wikipedia.org/wiki/List_of_catch_phrases

[07:51] <azuroth> for some reason, wikipedia is firewalled off at my college-ish-thing

[07:52] <geoffb> that's just wrong.  Wikipedia *is* college

[07:52] <geoffb> azuroth, where do you go?

[07:52] <geoffb> (to college, I mean)

[07:52] <azuroth> a TAFE in Australia

[07:53] <geoffb> TAFE?

[07:53] <QtPlatypus> Techincal and Further Education

[07:53] <azuroth> yeeah

[07:53] <azuroth> it's like university for dropouts?

[07:53] <geoffb> Like DeVry in the US?

[07:54] <QtPlatypus> Its a Technical Collage.

[07:54] <nothingmuch> azuroth: . is method call

[07:54] <azuroth> ah, okay

[07:55] <azuroth> ?eval $a = "second"; $b = 1=>2; say $b . $a;

[07:55] <evalbot_7057> Error:  unexpected "." expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:56] <azuroth> ?eval $a = "second"; $b = 1=>2; say $b.second();

[07:56] <evalbot_7057> Error: Undeclared variable: "$a" 

[07:56] <nothingmuch> geoffb: google groups got the message: http://groups.google.com/group/perl.perl6.language/browse_frm/thread/81dde1c00715df07/5d8110655531e6c3?tvc=1#5d8110655531e6c3

[07:56] <azuroth> err, whoops

[07:56] <azuroth> ?eval my $a = "second"; my $b = 1=>2; say $b.second();

[07:56] <evalbot_7057> Error: No compatible subroutine found: "&second" 

[07:56] <azuroth> ?eval my $a = "second"; my $b = 1=>2; say $b.$a();

[07:56] <evalbot_7057> Error:  unexpected "." expecting word character, "::", term postfix, operator, ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:56] <azuroth> d'oh

[07:56] <geoffb> nothingmuch, nod.  I guess now we know how long the GG backlog is.  :-)

[07:56] <nothingmuch> ?eval my $a = "value"; my $b = 1 => 2; $b.$a;

[07:56] <evalbot_7057> Error:  unexpected "." expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:57] <nothingmuch> darn

[07:57] <nothingmuch> ?eval my $a = "value"; my $b = 1 => 2; $b.value;

[07:57] <evalbot_7057> \2 

[07:57] <ods15> ?eval my $a = "value"; my $b = 1 => 2; $b.$a();

[07:57] <evalbot_7057> Error:  unexpected "." expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:57] <nothingmuch> ?eval my $a = "value"; my $b = 1 => 2; $b ~ $a;

[07:57] <evalbot_7057> pugs: src/Pugs/Prim.hs:1286:13-36: Non-exhaustive patterns in lambda   

[07:57] <ods15> that's a shame

[07:57] <nothingmuch> hah

[07:57] <ods15> bbl

[07:57] <nothingmuch> ods15: we'll have that, worry not

[07:57] <nothingmuch> we have it in prel 5

[07:57] <nothingmuch> perl 5

[07:57] <ods15> we do?

[07:57] <nothingmuch> i use it all the time

[07:57] <nothingmuch> yep

[07:57] <nothingmuch> you can use a var containing a string or a code ref as a method

[07:57] <geoffb> ?eval my $a = "value"; my $b = 1 => 2; $b.::($a)

[07:57] <evalbot_7057> Error:  unexpected "." expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:58] <nothingmuch> very handy for dispatch table behavior

[07:58] <nothingmuch> sub dispatch {

[07:58] <nothingmuch>     my $self = shift;

[07:58] <nothingmuch>     my $thing = shift;

[07:58] <ods15> heh. speaking of which, someone asked me to take a list and make a "count" of each elemen in the list and was amazed how fast i did it in perl..

[07:58] <geoffb> ?eval my $a = "value"; my $b = 1 => 2; &::($a).($b)

[07:58] <evalbot_7057> \2 

[07:58] <nothingmuch>     if (my $method = $self->can("do_" . $thing->moniker)){ $self->$method($thing) };

[07:58] <geoffb> got it

[07:58] <nothingmuch> }

[07:59] <ods15> moniker?

[07:59] <azuroth> name?

[07:59] <ods15> bbl

[07:59] <nothingmuch> ods15: err, yes, that's what perl is about. make things easy =)

[07:59] <nothingmuch> define: moniker

[07:59] <geoffb> No definebot, I take it

[07:59] <nothingmuch> or in our example http://search.cpan.org/~kasei/UNIVERSAL-moniker-0.08/moniker.pm

[07:59] <nothingmuch> oops, that was a google query

[07:59] <nothingmuch> http://www.google.com/search?client=safari&rls=en&q=define:+moniker&ie=UTF-8&oe=UTF-8

[08:00] <nothingmuch> it has the onload focus crap

[08:00] * nothingmuch really hates that, especially about amazon

[08:00] <nothingmuch> whenever you do tabbed browsing in amazon it makes the browser jump around

[08:00] <azuroth> ack

[08:01] <geoffb> You know, this is cool and all:

[08:01] <geoffb> ?eval my $a = "value"; my $b = 1 => 2; &::($a).($b)

[08:01] <evalbot_7057> \2 

[08:01] <geoffb> But I really want this:

[08:02] <geoffb> ./::($action).($command, @args);

[08:02] <nothingmuch> "it's stuck in while(true) waiting for sub-processes stopping, but stopProcess() fails because of wrong credentials got from hrcmdrc."

[08:02] <nothingmuch> that's the bug report for the setup program

[08:02] <geoffb> I wonder . . . .

[08:02] <nothingmuch> i hate that code =(

[08:02] <geoffb> mine?  Or the setup program?

[08:02] <nothingmuch> the installer for our product at work

[08:02] <geoffb> ah

[08:02] <nothingmuch> it's a classic example of bad management

[08:03] <nothingmuch> someone from the QA team with only bash experience changed departments

[08:03] <nothingmuch> so this was her learning project

[08:03] <nothingmuch> she didn't know OOP, didn't know C++ and didn't know Qt

[08:03] <nothingmuch> the code is a total mess

[08:03] <nothingmuch> replacing it is out of the question

[08:03] <nothingmuch> fixing it when it goes wrong is hard

[08:04] <nothingmuch> for example, this bit of code could be fixed by using exceptios

[08:04] <nothingmuch> but i don't think she knew of exceptions and how to use them

[08:04] <nothingmuch> there should be a polling wait loop to make sure the prooduct goes down cleanly when upgrading

[08:04] <nothingmuch> if it takes too long a timeout is raised

[08:05] <nothingmuch> if it doesn't work at all an error is raise

[08:05] <nothingmuch> d

[08:05] <nothingmuch> but in the current code it just loops

[08:07] <azuroth> ack

[08:08] <geoffb> bleah

[08:18] <geoffb> pugsbug committed

[08:19] <svnbot6> r7058 | geoffb++ | New t/pugsbugs/pair_boolean.t for broken pair booleanization

[08:21] <geoffb> Hmmm, I'm decently passed 2**5 commits, but it will be a while before I get to 2**6, I think.

[08:22] <geoffb> s/passed/past/

[08:22] <geoffb> Clearly, I need sleep

[08:22] <geoffb> "But mommy, I don' wanna go to bed!"

[08:24] <ods15> nothingmuch: do you have a job or anything?...

[08:24] <nothingmuch> yes

[08:25] <nothingmuch> that's what I'm complaining about

[08:25] <azuroth> buy me a job

[08:25] <ods15> geoffb: hehe, that's funny, the act of growin up is becoming your own mommy :)

[08:25] <geoffb> :-)

[08:25] <nothingmuch> not the job itself, but one of the things i maintain

[08:25] <ods15> nothingmuch: ah, cause you're just connected and active atm, soo...

[08:26] <nothingmuch> ods15: yep... 

[08:26] <nothingmuch> two screens =)

[08:26] * nothingmuch hears ods15 in his minds ear: "isn't that laptop screen enough?"

[08:26] <nothingmuch> well, no. I have another 19" flatscreen just to the left of it ;-)

[08:27] <azuroth> I have a 21" crt. :D

[08:29] <geoffb> Mmm, 21" CRT . . .

[08:29] * geoffb loves everything about his, except for the total loss of desk real estate

[08:29] <ods15> whatever

[08:29] <ods15> brb

[08:30] <geoffb> oh, and the unhappy lights on the UPS every time it degausses

[08:31] <geoffb> g'night all

[08:31] * geoffb is finally heading to bed

[08:31] <azuroth> night

[08:40] <azuroth> is there a bug tracker for pugs?

[08:40] <gaal> "Champion needed: command-line processing in Perl 6": http://www.livejournal.com/users/gaal/171558.html

[08:45] * nothingmuch hopes it isn't damian conway

[08:45] <gaal> azuroth: t/pugsbugs

[08:45] <gaal> or more genrally: grep -r todo t

[08:46] <gaal> generally

[08:50] <azuroth> ahh, cool

[08:51] <gaal> bugs that are fixed don't (usually) get their tests removed

[08:51] <gaal> so that if they resurface we (1) catch them early and (2) already have some context about them

[08:52] <gaal> and of course have a test to know when they're refixed.

[08:54] <azuroth> makes sense

[08:54] <masak> gaal++ # for the getopt post

[08:57] <gaal> why, thanks. it's been on my mind for months now but i never got around to writing it

[08:58] <gaal> for the same reasons i guess that i never actually did the getopt thing myself

[09:29] <masak> gaal: how difficult is it?

[09:30] <svnbot6> r7059 | putter++ | pugs: a somewhat more portable #! incantation

[09:31] * azuroth svn ups

[09:41] *** davidra is now known as jp-autark

[09:43] <nothingmuch> masak: IMHO the next generation of Getopt libraries should be multilayered

[09:44] <gaal> masak: it shouldn't be crazily difficult. it depends on how ambitious you are.

[09:44] <nothingmuch> the first level should provide an abstract interface for storage of named parameters in an array

[09:44] <nothingmuch> this includes two elements which form a pair

[09:44] <nothingmuch> one element which is 'foo=val'

[09:44] <gaal> i think a cleaned-up version of getopt::long is fine for a start

[09:44] <nothingmuch> a filter callback to decide what is an option and what isn't

[09:44] <gaal> though anything nothingmuch tells you now is probably smart too

[09:45] <nothingmuch> a way to get certain things to be synonymous

[09:45] <nothingmuch> (short options, etc)

[09:45] <gaal> and yet, like i said, we want something before everything.

[09:45] <nothingmuch> then on top of that we can leverage subtyping and D::FV style interfacing for parameter validation

[09:45] <nothingmuch> subclasses of the basic array<->named mapper can add features such as clustering

[09:46] <nothingmuch> or non standard prefixes

[09:46] <nothingmuch> the most crucial thing is to resist adding functionality that is not bare essentials

[09:46] <gaal> nm: don't forget though that not every cli is option based.

[09:46] <nothingmuch> and to refactor every composite decision into smaller methods

[09:46] <nothingmuch> you mean like 'svn --universal_option  up --sub_option'

[09:46] <nothingmuch> ?

[09:47] <gaal> yup. i sure want a library for that!

[09:47] <nothingmuch> okay, here's a thought:

[09:47] <nothingmuch> the basic array to named mapper is an event parser

[09:47] <gaal> that dispatches to another parser?

[09:47] <gaal> that works.

[09:47] <nothingmuch> right

[09:48] <gaal> that's how we did it in logjam

[09:48] <nothingmuch> the events should be as informative as possible

[09:48] <gaal> except not prettily or generically.

[09:48] <gaal> but:

[09:48] <gaal> you want to make interfacing to the data convenient

[09:48] <nothingmuch> then a XML::SAX filter like approach can help unwind certain things:

[09:48] <gaal> there's the api side of this to think of too

[09:48] <nothingmuch> clustered options become single entities, etc

[09:48] <nothingmuch> what do you mean?

[09:48] <gaal> i mean how does the programmer access the parsed results?

[09:49] <nothingmuch> ah

[09:49] <gaal> what you said gives the power to do anything

[09:49] <nothingmuch> the layered approach works:

[09:49] <gaal> i also want a conventional and convenient practice

[09:49] <nothingmuch> an "easy" library leverages the event parser, and collects key<->value mappings in the handler

[09:50] <nothingmuch> my $opts = Getopt::Easy.new;

[09:50] <nothingmuch> $opts.optname; # just parsed out

[09:50] <nothingmuch> this is the simplest case where you don't even specify what you want

[09:50] <nothingmuch> the constructor for Getopt::Easy uses a factory methodo to create an event parser

[09:51] <nothingmuch> listens to events from an array (defaults to ARGV)

[09:51] <gaal> oh, new was wired to @*ARGS because i didn't specified anything else? that sounds like IO::All :-)

[09:51] <nothingmuch> and then collects the results

[09:51] <nothingmuch> sensible defaults are a good thing

[09:51] <gaal> sure

[09:51] <nothingmuch> implcit behavior isn't

[09:51] <nothingmuch> there's a line between them ;-)

[09:51] <nothingmuch> IO::All let's you construct an HTTP server in one line. I don

[09:51] <gaal> especially in this case where 98% of the cases you'll indeed want @*ARGS

[09:52] <nothingmuch> 't think that's a good thing for anyone who doesn't know IO::All inside out

[09:52] <nothingmuch> right

[09:52] <gaal> ok ok no time for wars now :)

[09:52] <nothingmuch> anyway, my #1 problem with Damian code is:

[09:52] <nothingmuch> it's usually very brilliant, except for a small bit that bothers me

[09:52] <nothingmuch> but i can never reuse it

[09:52] <nothingmuch> because everything is in one huge sub

[09:52] <gaal> forget the code

[09:52] <nothingmuch> or makes weird assumptions about state

[09:53] <nothingmuch> i'd like a Getopt library that is not like that at all

[09:53] <gaal> reuse design, reuse ideas, reuse specs.

[09:53] <nothingmuch> right

[09:53] <gaal> reuse tests if you can :-)

[09:53] <nothingmuch> and since there are so many approaches and requirements for getopting, the only way to create a standard library is to create a standard set of libraries that get along and encourage extensibility

[09:54] <nothingmuch> anyway, enough of this, i've got to get back to debugging this installer thing

[09:54] <gaal> let's identify a few "styles" then.

[09:54] <gaal> aw, we only just started :)

[09:54] <nothingmuch> long options with short synonyms

[09:54] <nothingmuch> when boolean, with clustering

[09:55] <gaal> that's essentially getopt::long

[09:55] <nothingmuch> that's "the" approach most small things use

[09:55] <nothingmuch> yes, but Getopt::long is not a convenient

[09:55] <nothingmuch> and it's not reusable either

[09:55] <nothingmuch> i can identify 2 processes to getting there

[09:55] <nothingmuch> maybe if i think more i can get a 3rd one out

[09:56] <nothingmuch> the event parser notifies of tokens to the Getopt::Long thingy

[09:56] <nothingmuch> there are two types of tokens, aside from "regular"

[09:56] <nothingmuch> --foo and -f

[09:56] <nothingmuch> in the base class for a handler these simply delegate to the regular token handler

[09:56] <nothingmuch> the base class also stops processing at '--' and puts the rest in a special normal args array

[09:57] <nothingmuch> anyway... when the ::long variant gets a single slash event it tries to figure out char by char what they are

[09:57] <nothingmuch> it translates each one of these to a call to the single dash event recursively, for the single options

[09:58] <nothingmuch> when a single option is a single char it looks for a boolean option and enables it

[09:58] <nothingmuch> the moment the clustered parser finds an option that isn't boolean, the rest of the string is gobbled as a parameter to that option

[09:58] <nothingmuch> recouple that, it's too separate

[09:59] <nothingmuch> the long option thingy behaves a bit differently - it puts the option on the stack

[09:59] <nothingmuch> and gobbles up the next thing as an argument

[09:59] <nothingmuch> all setting of options is first filtered through a synonym normalizer

[10:01] <nothingmuch> i take it back

[10:01] <nothingmuch> clustered options do reraise events

[10:01] <gaal> (you're describing g:l's algorithm, with what you thing is wrong about it? or the design you're proposing?)

[10:01] <gaal> (ah, what you're proposing. okay)

[10:13] <buu> Hrm. Does perl6 have a 'Safe' type module that actually works yet?

[10:13] <integral> pugs has a safe-mode which works

[10:14] <buu> Yeah, but I don't want to fork pugs

[10:14] <integral> ?eval say "I'm safe!"

[10:14] <evalbot_7059> I'm safe! bool::true 

[10:14] <buu> I was thinking about a mush using perl6 as a scripting language

[10:14] <buu> But it needs to be safe, and fast

[10:14] <integral> pugs is the former, but not necessarily the latter.

[10:14] <integral> embedded haskell can be safe (see hs-plugins)

[10:14] <buu> But I don't like haskell!

[10:15] <buu> Dunno. I guess the only real way is to provide a super limited set of commands

[10:16] <buu> Including no loops

[10:16] <buu> I mean, how do you safely handle'while(1)' no matter what language you're using?

[10:16] <azuroth> mush?

[10:17] <nothingmuch> gaal: i waas trying to describe the G::L process

[10:17] <buu> azuroth: Yeah!

[10:17] <nothingmuch> and how it oculd be implemented as a second layer on top of an event parser

[10:17] <azuroth> ...woo, yeah!

[10:18] <buu> I guess if you strip out say, functions, loops, and gotos it would be safeish

[10:19] <azuroth> but...

[10:19] <nothingmuch> uh?

[10:19] <buu> Seems kind of pointless.

[10:19] <nothingmuch> you can place time limits

[10:19] <buu> nothingmuch: sure, but that starts getting ugly

[10:19] <nothingmuch> Time::HiRes can set an alarm to be delivered after N cpu seconds

[10:19] <nothingmuch> as can the limit interface (sends a deadly signal)

[10:19] <buu> look Object;

[10:20] <buu> 10 seconds later

[10:20] <buu> It responds

[10:20] <nothingmuch> as for IO - that can be filtered out in a well shaped language

[10:20] <nothingmuch> pugs knows to do this

[10:20] <nothingmuch> and what do you mean by that?

[10:20] <nothingmuch> that X is too slow?

[10:21] <buu> nothingmuch: Yeah

[10:21] <nothingmuch> what about perl 5?

[10:21] <buu> Er, no. Not the speed of the language

[10:21] <nothingmuch> Safe.pm is Good Enough, i think

[10:21] <nothingmuch> then?

[10:21] <buu> Imagine walking in to the room. It executes code to display the contents of the room

[10:21] <buu> The code includes a while(1)

[10:22] <buu> It would take X seconds to display the room

[10:22] <nothingmuch> oh

[10:22] <buu> Any X seems too long to me =/

[10:22] <nothingmuch> in that case: rooms with while (1) should be moderated out of the system

[10:22] <nothingmuch> if it's a wiki style mush, then the user base should know how to do that

[10:22] <nothingmuch> and a time limit for room rendition can be made

[10:23] <nothingmuch> and rooms can be pre-rendered whenever the manhatten distance to the current room is 1

[10:23] <buu> Yeah, I suppose

[10:23] <buu> Dunno about "wiki style"

[10:23] <buu> That's a Bad Idea

[10:23] <nothingmuch> what is the mush user base going to be?

[10:25] <buu> Sorry, I don't understand. People?

[10:25] <buu> I would assume fairly educated perl programmers.

[10:25] <nothingmuch> PING 1127298315 362945

[10:25] * buu waves

[11:01] <azuroth> ?eval 2 err 1

[11:01] <evalbot_7059> 2 

[11:01] <azuroth> ?eval 0 err 1

[11:01] <evalbot_7059> 0 

[11:01] <azuroth> ?eval false err 5

[11:01] <evalbot_7059> Error: No compatible subroutine found: "&false" 

[11:01] <azuroth> ?eval 0 or 2

[11:01] <evalbot_7059> 2 

[11:04] <azuroth> how is PGE and rules stuff going?

[11:11] <dada> ?eval bool::false err 5

[11:11] <evalbot_7059> Error: No compatible subroutine found: "&bool::false" 

[11:11] <dada> ?eval ?0

[11:11] <evalbot_7059> bool::false 

[11:11] <dada> mmm

[11:12] <dada> ?eval bool::false

[11:12] <evalbot_7059> bool::false 

[11:12] <dada> ?eval (bool::false) err 5

[11:12] <evalbot_7059> bool::false 

[11:12] <dada> isn't this a bug?

[11:13] <dada> ?eval bool::false or 42

[11:13] <evalbot_7059> Error: No compatible subroutine found: "&bool::false" 

[11:13] <dada> ?eval 42 or bool::false

[11:13] <evalbot_7059> 42 

[11:14] <dada> please, tell me it is a bug :-)

[11:16] <azuroth> I'll tell you so

[11:16] <azuroth> and we can pretend we combined have the power to enforce it...

[11:17] <azuroth> is err equivalent to or?

[11:17] <dada> not really equivalent

[11:17] <dada> but they're both infix operators

[11:18] <dada> ?eval bool::false and 42

[11:18] <evalbot_7059> Error: No compatible subroutine found: "&bool::false" 

[11:18] <ods15> ?eval !0

[11:18] <evalbot_7059> bool::true 

[11:18] <dada> the problem is bool::false, not err

[11:18] <dada> or, more to the point, the problem is the parser

[11:20] <dada> ?eval 42 or false

[11:20] <evalbot_7059> 42 

[11:20] <gaal> wha--! dada, please pugsbugs.

[11:21] <dada> gaal: any pointer?

[11:21] <dada> how to pugsbug, that is

[11:21] <gaal> sure, add a test in t/pugsbugs

[11:21] <dada> ok, I'll try

[11:21] <gaal> thanks!

[11:22] <ods15> gaal: yeah, i used to think pugs was perl6 bug tracking system :0

[11:22] <ods15> :)

[11:23] <gaal> yes, it's also a spec bug filter

[11:24] <gaal> btw:

[11:24] <gaal> ?eval bool::false() err 42

[11:24] <evalbot_7059> bool::false 

[11:24] <gaal> which also isn't right :)

[11:25] <gaal> i think this may actually be two bugs

[11:25] <dada> mmm

[11:25] <gaal> in err and in bool::false's arity or some such.

[11:26] <dada> I think is something more deep

[11:26] <dada> bool::false should be a constant, but in fact it is implemented as an accessor

[11:27] <dada> eg. like perl5's "use constant" stuff

[11:27] <gaal> an accessor? no, here's the implementation:

[11:27] <azuroth> ?eval ?0

[11:27] <evalbot_7059> bool::false 

[11:27] <gaal> op0 "bool::false" = const $ return (VBool False)

[11:27] <gaal> Pugs.Prim:62

[11:28] <dada> mmm

[11:28] <dada> ok, so maybe constants are implemented as accessors :-)

[11:28] <dada> ?eval Inf or 0

[11:28] <gaal> not sure what you mean by that?

[11:28] <evalbot_7059> Inf 

[11:29] <dada> I mean something like sub bool::false { return 0 }

[11:29] <dada> no, maybe not

[11:29] <dada> I'm just plain wrong

[11:29] <dada> I can't svn up!

[11:30] <gaal> what's the error?

[11:30] <dada> svn: Failed to add file 'pugs': object of the same name already exists

[11:30] <gaal> ah, yes. it's a script now. simply move away the file.

[11:30] <gaal> (you can delete it)

[11:30] <dada> but it isn't there...

[11:30] <dada> there was a pugs.exe

[11:31] <dada> (I'm on Win32)

[11:31] <dada> oh well, deleted pugs.exe, now everything works

[11:32] <dada> what is, gramatically speaking, Inf?

[11:33] <gaal> a Num, I think.

[11:34] <gaal> that is, a literal number

[11:34] <dada> mmm

[11:35] <gaal> yes, it's a named literal. Pugs.Parser:1872

[11:35] <dada> seen

[11:35] <dada> while bool::false, in fact, is a primitive

[11:35] <masak> gaal: so, if i started porting getopt::long to perl6, would that further things?

[11:35] <dada> Bool      pre     bool::false safe   ()

[11:36] <masak> i think i know perl6 sufficiently well

[11:36] <gaal> masak: yes!

[11:36] <dada> so, it looks in fact something like sub bool::false() { return 0 }

[11:36] <masak> but would probably need some hand-holding here at #perl6 in places

[11:36] <masak> gaal: ok, i'll get on it

[11:36] <gaal> masak: my recommendation, feel free to change things you want to change

[11:36] <gaal> and start with porting the tests :)

[11:37] <gaal> re: perl6, nobody knows it perfectly. that's what we're here for ;-)

[11:37] <masak> gaal: good idea w/ tests

[11:37] <masak> i can even commit them as i go

[11:39] <gaal> yes, commit muchly.

[11:39] <masak> first question: is there a good, working example p6 module in the pugs tree somewhere?

[11:39] <gaal> dada: why is that a problem?

[11:39] <gaal> masak: yes, look in ext/ for a few

[11:40] <masak> oki

[11:40] <gaal> masak: also see http://tpe.freepan.org/modules.html though many of those have never actually run

[11:40] <dada> gaal: because bool::false is declared (for the parser) as a function with prototype (), so bool::false() of course works

[11:41] <gaal> dada, that doesn't mean what perl 5's prototype () means

[11:41] <dada> mmm

[11:41] <gaal> it means there's a prim with arity 0

[11:41] <dada> have to go now

[11:41] <dada> later

[11:41] <gaal> bye!

[11:43] <gaal> masak, also see docs/porting_howto if you haven't yet.

[11:43] <masak> gaal: i have, but i will, again

[11:44] <gaal> also also, avoid rules for now, and prefer p5 regexps, because not everyone has parrot.

[11:46] <masak> right

[11:47] <masak> can always refactor them later

[11:47] <GeJ> gaal: do you have an idea about when a new pugs release may occur?

[11:52] <gaal> masak, sure, they're clearly labeled all over pugs.

[11:53] <masak> gaal: in what sense?

[11:53] <gaal> GeJ, no. Autrijus is traveling now (I hope! :) and has to recover from multiple hardware failures

[11:54] <gaal> masak: in that it's no problem to grep ':Perl5' all over the code tree :-)

[11:54] <gaal> when we do want to move upwards that is.

[11:54] <masak> ah

[11:56] <masak> let's see... qw(...) is spelled <...> nowadays, yes?

[11:57] <gaal> yup

[11:57] <gaal> << ... >> if you want interpolation

[11:58] <masak> yes, found it in A02

[11:58] <azuroth> ?eval <a b>.length

[11:58] <evalbot_7059> Error: No compatible subroutine found: "&length" 

[11:58] <azuroth> ?eval $a = <a b>

[11:58] <evalbot_7059> Error: Undeclared variable: "$a" 

[11:58] <azuroth> ?eval my $a = <a b>

[11:58] <evalbot_7059> ['a', 'b'] 

[11:58] <azuroth> buhh

[12:00] <gaal> elems

[12:00] <gaal> there is no length.

[12:00] <azuroth> ahh

[12:01] <gaal> masak: better work with the synopses, not the apos

[12:02] <azuroth> $eval <a b>.elems

[12:02] <azuroth> ?eval <a b>.elems

[12:02] <evalbot_7059> 2 

[12:02] <azuroth> ?eval my $a="a b"; <<$a>>.elems

[12:02] <evalbot_7059> Error: No compatible subroutine found: "&elems" 

[12:02] <azuroth> ?eval my $a="a b"; @a = <<$a>>; say @a.elems;

[12:02] <evalbot_7059> Error: Undeclared variable: "@a" 

[12:03] <azuroth> ?eval my $a="a b"; my @a = <<$a>>; say @a.elems;

[12:03] <evalbot_7059> 2 bool::true 

[12:03] <azuroth> I could've probably gotten a quicker answer by asking...

[12:04] <masak> gaal: right. maybe a good time to get familiar with the synopses, i've mostly read the apocs

[12:05] <masak> question: what sort of comparison does is() do, numeric or stringy?

[12:07] <masak> or some smart, dwimmy stuff?

[12:08] <gaal> sorry, i'm also $working so i'm here a little sporadically

[12:09] <masak> no problem

[12:09] <gaal> is() is defined in ext/Test/lib/Test.pm

[12:09] <masak> yes

[12:09] <masak> it calls proclaim()

[12:09] <gaal> "eq"

[12:10] <masak> oki, thx

[12:10] <masak> does that mean i should rewrite numerical comparisons as ok() calls?

[12:11] <gaal> you can force numeric context if you need to

[12:11] <gaal> is(+$x, +$y)

[12:11] <gaal> or if you fear something that should be returning a number might not be, insert an explicit test for that

[12:13] <masak> ah, ok

[12:17] <masak> right. here goes

[12:17] * masak commits

[12:19] <svnbot6> r7060 | masak++ | Getopt::Long test file gol-basic.t

[12:24] <masak> is 'undef' still in perl6?

[12:24] <gaal> "undefine" now

[12:24] <masak> ok

[12:24] <masak> i like that better

[12:25] <gaal> also, maybe we can ditch g:l's automatic symbol generation? those two undefines there are really weird: they're not even use strict clean

[12:26] <gaal> also: @ARGV is spelled `@*ARGS` now

[12:26] <gaal> and, where you can, try adding a test description

[12:26] <masak> yes

[12:26] <masak> i can fix @*ARGS

[12:27] * gaal giggles at 'plan 9'

[12:27] <masak> but what about the automatic symbol generation?

[12:27] <masak> i thought i would get away with an automatic translation :)

[12:28] <gaal> it's okay to change the api a little.

[12:29] <masak> yesyes, but to what? i have no good ideas right now

[12:29] <masak> my head is full of translationg p5->p6

[12:29] <gaal> but a core module ought not assume you're running without strictures, because those will be turned on by default in p6

[12:29] <gaal> oh, you know how you can say

[12:29] <masak> i agree

[12:29] <gaal> (in p5)

[12:30] <gaal> GetOptions \our %Config, qw(help user|u=s password|p=s);

[12:30] <svnbot6> r7061 | masak++ | corrected gol-basic.t: undef is now undefine

[12:30] <svnbot6> r7062 | masak++ | corrected gol-basic.t: @ARGV is now @*ARGS

[12:30] <masak> that is, store stuff in a hash

[12:30] <gaal> that is, don't ask the library to do any symbol magic at all

[12:30] <gaal> in fact:

[12:31] <gaal> you can probably do away with the OUT variable and do:

[12:31] <gaal> my $conf = GetOptions <spec>

[12:31] <gaal> and have the library raise an exception when it fails

[12:31] <gaal> well, fail when it fails. :})

[12:31] <masak> so GetOptions returns a hash

[12:32] <gaal> hashref, yes

[12:32] <masak> yes

[12:32] <gaal> seems reasonable to me.

[12:32] <masak> sounds neat

[12:32] <gaal> that's how i always use it anyway

[12:32] <masak> i'll rewrite the tests to that end

[12:32] <gaal> i don't like the ad-hoc switch args

[12:32] <gaal> *but*, some people do like things like:

[12:33] <gaal> GetOptions "user|u=s" => \my $user, "password|p=s" => \my $pass, "help" => \&help

[12:33] <gaal> so don't prevent that :)

[12:34] <masak> not sure i grok that syntax right away, but ok :)

[12:34] <gaal> the good news is that you can easily detect how you were called

[12:34] <gaal> oh, that was perl 5 syntax -- it's one of the ways you can use G::L today

[12:34] <gaal> and it's reasonable to allow it in the ported version too

[12:35] <gaal> you pass a hash (list of pairs in p6) of each option and "where you want to put it"

[12:36] <masak> oh ok

[12:36] <gaal> in the case of the first two you <declared and passed a reference in one go> to scalars

[12:36] <gaal> and in the third, the "help" option, you gave a coderef to dispatch if the option was activated.

[12:38] <masak> yes

[12:38] <masak> this is exciting!

[12:40] <gaal> :)

[12:41] * masak commits again

[12:41] <masak> feel free to have a look, i might have missed things

[12:43] <gaal> sure

[12:45] <gaal> looks good. just: ok($options = GetOptions ("foo", "Foo=s"));

[12:45] <svnbot6> r7063 | masak++ | made gol-basic.t more perl6ish: GetOptions now returns hashref

[12:45] <gaal> you can say GetOptions <foo Foo=s>

[12:45] <gaal> though you don't have to :-)

[12:48] <masak> oh yes, that's nicer

[12:48] * masak changes

[12:51] <svnbot6> r7064 | masak++ | made gol-basic.t more perl6ish: replaced list of strings with <...>

[12:51] <masak> what do you think gaal, should i still support the call syntax w/ OUT variable?

[12:51] <masak> eg GetOptions (\%lnk, "foo", "Foo=s") in perl5

[12:54] <gaal> your call... i can't think of a reason to include it right from the start :)

[12:55] <gaal> though

[12:55] <gaal> i have my own pattern of using this module

[12:55] <gaal> i don't know, how useful do you think the current return value of getoptions is?

[12:57] <svnbot6> r7065 | masak++ | added test descriptions in gol-basic.t

[12:57] <masak> the only reason i can see for including it is the principle of least surprise

[12:58] <masak> a port should deprecate as little as possible

[12:59] <gaal> true, but it should also be in the style of the target language. so for example we want to encourage fail

[12:59] <gaal> to signal failures

[12:59] <gaal> in libraries.

[13:00] <masak> yes

[13:00] <masak> but here it's more a question of providing extra behaviour for free

[13:01] <gaal> you always have that question when working on an interface

[13:01] <masak> of course

[13:01] <gaal> imho "fail" is the way to go. and make the thing that's returned better than a hashref, make it an object

[13:02] <gaal> so you can also query it later for the info that would have been in the return value (what is it, number of options?)

[13:02] <gaal> number of matches?

[13:02] <masak> a Getopt::Result object or something

[13:02] <masak> i don't know

[13:02] <masak> i can check

[13:05] <masak> seems to return true iff all went well

[13:08] <gaal> yes, but what true? it's a count of something.

[13:09] <gaal> oh, you're right, it's just a boolean

[13:09] <gaal> so by all means we can get rid of the out variable with no loss of any information

[13:10] <gaal> you'll have to spell your invocation a little differently, but code that handles errors can stay essentially the same

[13:10] <gaal> that is, if you want not to use exceptions

[13:10] <gaal> no fatal; my $opts = getoptions err die "can't parse: $!....";

[13:11] <masak> how will that look in the test files?

[13:13] <gaal> no fatal; ok(! getoptions("bad spec"), "parser detects bad spec"); ok($!, "some error", "yields useful error")

[13:14] <gaal> or without mucking with use fatal:

[13:14] <gaal> dies_ok { getoptions "bad spec" } "parser detects bad spec"; ok($! ....

[13:15] <gaal> (hmm, i *think* dies_ok preserves $!. don't trust me on that one :-)

[13:16] <masak> :)

[13:19] <svnbot6> r7066 | masak++ | fixed capitalisation in gol-basic.t

[13:21] <masak> i get a new evalbot for every commit i do

[13:22] <masak> how wastefully cool isn't that? :)

[13:25] <svnbot6> r7067 | masak++ | Getopt::Long test file gol-linked.t

[13:45] <masak> oh my, Test.pm is broken since the interrobang decision :(

[13:46] <masak> dare i change it on my own?

[13:46] <masak> i mean, it's just a s/::/!!/ change of syntax

[13:46] * masak changes it

[13:46] <masak> what the heck

[13:46] <QtPlatypus> Worce comes to worse we revert the files.

[13:49] <masak> hmm

[13:49] <masak> looks fixed already

[13:49] <masak> maybe i just need recompile... strange

[13:49] * masak compiles pugs

[13:49] <nothingmuch> ah! finally, some internet

[13:50] <nothingmuch> Blondie now compiles to C much better

[13:50] <nothingmuch> now i'll be refactoring Thunk, and adding branch support at the tree level

[13:50] <nothingmuch> then I'll try harder math with C and Perl together

[13:50] <nothingmuch> and then i'll work on lists, the type inferrencer, and runtime deferred types

[13:51] <nothingmuch> e.g., the type of X is either IV or PV because X is an element of an array which has interacted with IVs and PVs

[13:51] <nothingmuch> so all of the elements in the array are boxed with type info

[13:55] <svnbot6> r7068 | nothingmuch++ | Symbolic representations of reused nodes in C output

[13:55] <svnbot6> r7069 | nothingmuch++ | Folding of constants

[13:57] <masak> seems i have an old version of Test.pm in /usr/lib/perl6/

[13:57] <masak> what do i need to do?

[13:59] <kolibrie> delete it?

[14:00] <masak> then i will have no version of Test.pm in /usr/lib/perl6/ :)

[14:00] <QtPlatypus> delete it and then check out the new version

[14:00] <masak> but this is /usr/lib/perl6/, not part of the pugs source tree

[14:00] <kolibrie> the install path for perl6 modules changed a while back

[14:01] <masak> ok...

[14:31] <svnbot6> r7070 | iblech++ | Usual svn props.

[15:28] <deego> (curious newbie..)  Is perl6 being developed in haskell altogether? Or, is pugs just an alternative implementation? 

[15:29] <deego> And, if the latter, what is the purpose?

[15:29] <QtPlatypus> deego: Bootstrapping

[15:30] <integral> It's mostly the latter (except being the only implementation, it looks a bit like the first...)

[15:31] <svnbot6> r7071 | iblech++ | * t/data_types/lists.t: =begin more-discussion-needed'ed, as there is no

[15:31] <svnbot6> r7071 | iblech++ |   final ruling on the \(...) thread yet (link included in the test).

[15:31] <svnbot6> r7071 | iblech++ | * t/pugsbugs/pair_boolean.t: begin more-discussion-needed'ed, for the same

[15:31] <svnbot6> r7071 | iblech++ |   reason (link included as well).

[15:32] <dudley_> deego: The main purpose of Pugs is "fun"

[15:33] <integral> and to demonstrate that it really is possible to require a cluster to just compile a program!

[15:34] <Limbic_Region> anyone interested in the "run once" thread may be interested in following a related thread at PerlMonks I just posted http://perlmonks.org/index.pl?node_id=493826

[15:42] <deego> thanks dudley_, QtPlatypus

[15:43] <deego>  and integral :)

[15:44] <deego> evalbot_7071: help

[15:44] <Odin-> deego: Perl6, although it will have an "official" implementation isn't intended to be bound to a single implementation. Although, to be fair, that's the likeliest outcome... :p

[15:44] <deego> :)

[15:44] <deego> does evalbot_7071 eval perl expressions? 

[15:45] <deego> Odin-: I see

[15:45] <Khisanth> Odin-: and I would say the preferable one ...

[15:45] <nothingmuch> bah

[15:46] * nothingmuch is having trouble with Y combinator in Blondie

[15:46] <Khisanth> sure there are advantages to multiple implementations but there also some very annoying disadvantages

[15:46] <pasteling> "nothingmuch" at 82.81.247.180 pasted "*sigh*" (83 lines, 1.2K) at http://sial.org/pbot/13240

[15:47] <nothingmuch> deego: watch

[15:47] <nothingmuch> ?eval 1 + 1

[15:47] <evalbot_7071> 2 

[15:47] <deego> nothingmuch: thanks

[15:47] <nothingmuch> ?eval class Foo { has $.x; submethod BUILD { $.x = 5 } }; my $f = new Foo; $f.x;

[15:47] <evalbot_7071> \5 

[15:47] <nothingmuch> the only thing it can't do is IO related stuff

[15:48] <nothingmuch> and infinite loops:

[15:48] <nothingmuch> ?eval [+] 1 ...

[15:48] <evalbot_7071> pugs: out of memory (requested 1048576 bytes) 

[15:48] <Khisanth> nothingmuch: hey! that is actually valid perl5?

[15:48] <nothingmuch> ?eval [+] 1 .. 10

[15:48] <evalbot_7071> 55 

[15:48] <nothingmuch> no, that's perl 6

[15:48] <deego> neat

[15:48] <nothingmuch> [] is the meta reduction operator

[15:48] <nothingmuch> it applies to infix operators, and is a bit like foldl/foldr

[15:49] <nothingmuch> only i don't know if it has a defined "lean"

[15:49] <nothingmuch> 1 ... is the infinite list constructor for 1 to Inf

[15:50] <nothingmuch> sub &*postfix:<...> ($n) { $n .. Inf }

[15:50] <stevan> hey there nothingmuch 

[15:50] <nothingmuch> hi ho stevan 

[15:51] <stevan> I am about to commit generic classes in the metamodel :)

[15:51] <nothingmuch> generic classes?

[15:51] <stevan> you should like this one

[15:51] <stevan> yes

[15:51] <dudley_> Whoa

[15:51] <nothingmuch> like C++ templates?

[15:51] <stevan> yeah but not

[15:51] <Odin-> Khisanth: I said nothing about that. ;)

[15:51] <nothingmuch> delta(C++ templates, generic classes);

[15:51] <nothingmuch> i mean

[15:51] <nothingmuch> ?eval delta(C++ templates, generic classes);

[15:51] <evalbot_7071> Error: No compatible subroutine found: "&delta" 

[15:51] <dudley_> You mean classes that take type parameters

[15:52] <dudley_> right?

[15:52] <nothingmuch> dudley_: afaik that's the definition of a C++ template

[15:52] <stevan> dudley_: yes, parameterized classes

[15:52] * dudley_ knows no C++

[15:52] <nothingmuch> e.g. vector<Dog> is the template class 'vector' parametrized over Dog so in a sense it's a vector of dogs

[15:53] <stevan> yup

[15:53] <stevan> I was reading a paper recently on how they do this

[15:53] <nothingmuch> it's a bit like instantiating an anonymous class, which is how I bet you implemented it, right?

[15:53] <stevan> Array[Int]

[15:53] <stevan> etc

[15:53] <svnbot6> r7072 | stevan++ | Perl6::MetaModel 2.0 -

[15:53] <svnbot6> r7072 | stevan++ | * we now have generics (kind of) see t/32_parameterized_classes.t for an example

[15:53] <svnbot6> r7072 | stevan++ | * fixed isa() in class

[15:53] <nothingmuch> aye

[15:53] <stevan> nope

[15:53] <stevan> and yes

[15:53] <nothingmuch> nope and yes?

[15:54] <stevan> the class macro can take either a hash ref of method/attr definitions or it can take a subroutine

[15:54] <stevan> the subroutine is expected to build the class manually

[15:54] <stevan> so ,..for parameterized classes all I did was to add another possible set of parameters

[15:54] <nothingmuch> y combinator smashed my swap =(

[15:54] <stevan> so if you pass an array ref, followed by a sub

[15:55] <stevan> you get back a parameterized class constructor

[15:55] <stevan> which is basically just an anon-sub, which will spit out a class when given the right parameters

[15:56] <stevan> its kind of a cheap fix

[15:56] <nothingmuch>     $::CLASS->add_method('STORE' => ::make_method(sub {

[15:56] <nothingmuch>         my ($self, $value) = @_;

[15:56] <nothingmuch>         ($value->isa($T->name)) # || $value->does($T)) 

[15:56] <nothingmuch>             || confess "Incorrect Type";

[15:56] <nothingmuch>         ::opaque_instance_attr($self => '$:value') = $value;

[15:56] <stevan> but it works

[15:56] <nothingmuch>     }));

[15:56] <nothingmuch> that's what I suspected

[15:56] <nothingmuch> stevan++

[15:56] <nothingmuch> very nice =)

[15:56] <stevan> nothingmuch: :)

[15:56] <nothingmuch> is this implemented in $Object?

[15:56] <stevan> nope

[15:56] <nothingmuch> or $Class?

[15:56] <stevan> it is all in the macro layer

[15:56] <nothingmuch> oh

[15:56] <stevan> the paper i was reading was talking about how you do not create the class until you have the paremeters

[15:57] <nothingmuch> that's exactly like C++ templates

[15:57] <stevan> yes I guess

[15:57] <nothingmuch> they are instantiated only when the parameters are given

[15:57] <nothingmuch> that causes mui headaches

[15:57] * stevan knows less C++ than dudley :)

[15:57] <stevan> mui?

[15:57] * dudley_ doubts that :)

[15:57] <nothingmuch> lots, plenty, many, and much rolled in one

[15:57] <stevan> oh

[15:57] <nothingmuch> it's spanish

[15:57] * stevan thought it was some weird acronym

[15:57] <nothingmuch> and since i don't know spanish it becomes polymorphic

[15:58] <nothingmuch> =D

[15:58] <stevan> nothingmuch: why does it cause issues ?

[15:58] <nothingmuch> because some compilers are too dumb

[15:58] <stevan> ah

[15:58] <stevan> no compilers here,.. its all runtime baby :P

[15:58] <nothingmuch> and they instantiate template classes before the templates are fully defined

[15:58] <nothingmuch> you wanna see what I was up to?

[15:58] <stevan> I saw a big AST

[15:59] <stevan> and I have been wathing Blondie :)

[15:59] <nothingmuch> that's a test that's causaing an infinite loop

[15:59] <stevan> ah

[15:59] <stevan> Y combinator?

[15:59] <nothingmuch> but the C compilation stuff is the Big Thing

[15:59] <stevan> yes I saw that

[15:59] <stevan> that is very cool

[15:59] <nothingmuch> Y combinator takes a function f and returns a function that takes a value x, and applies f to x and f itself

[16:00] <Odin-> C compilation? :/

[16:00] <nothingmuch> Odin-: errm, yes

[16:00] <nothingmuch> Blondie compiles down to C/

[16:00] * Odin- has clearly lost track.

[16:00] <Odin-> Blondie? :p

[16:00] <stevan> so it would look like : sub { my $f = shift; return sub { $f->(@_) }}

[16:00] <stevan> Odin-: Blondie is our Perl 6 fork ;)

[16:00] <nothingmuch> Blondie is my toy language for trying to implement the compiler strategies i've been bringing up on p6l

[16:01] <nothingmuch> stevan: aye

[16:01] <stevan> hey fglock 

[16:01] <Odin-> Hm. I see.

[16:01] <fglock> hi stevan

[16:01] <nothingmuch> y(sub { my ($n, $f) = @_; if ($n == 0) { return 1 } else { return $n * $f->($n - 1) } })

[16:02] <stevan> fglock: FYI - I just added (very rough) parameterized classes to MM 2.0

[16:02] <stevan> so, what is the issue with this nothingmuch ?

[16:03] <fglock> parameterized classes?

[16:03] <nothingmuch> ?eval sub y (&f) { -> $x { f($x, &f) } }; sub facty ($x, &f) { $n ?? $n * f($n - 1) !! 1 }; my &fact := y(&facty); fact(5)

[16:03] <evalbot_7072> Error: Undeclared variable: "$n" 

[16:03] <nothingmuch> ?eval sub y (&f) { -> $x { f($x, &f) } }; sub facty ($n, &f) { $n ?? $n * f($n - 1) !! 1 }; my &fact := y(&facty); fact(5)

[16:03] <evalbot_7072> Error: No compatible subroutine found: "&f" 

[16:03] <nothingmuch> ?eval sub y (&f) { -> $x { f($x, &f) } }; sub facty ($n, $f) { $n ?? $n * $f.($n - 1) !! 1 }; my &fact := y(&facty); fact(5)

[16:03] <evalbot_7072> Error: Undeclared variable: "$f" 

[16:03] <stevan> fglock: like Array[Int]

[16:04] <stevan> where Array can only hold Int objects

[16:04] <nothingmuch> ?eval sub y ($f) { -> $x { f($x, $f) } }; sub facty ($n, $f) { $n ?? $n * $f.($n - 1) !! 1 }; my &fact := y(&facty); fact(5)

[16:04] <evalbot_7072> Error: No compatible subroutine found: "&f" 

[16:04] <nothingmuch> ?eval sub y ($f) { -> $x { $f.($x, $f) } }; sub facty ($n, $f) { $n ?? $n * $f.($n - 1) !! 1 }; my &fact := y(&facty); fact(5)

[16:04] <evalbot_7072> Error: Undeclared variable: "$f" 

[16:04] <nothingmuch> damnit

[16:05] <fglock> cool - so Array doesn't need to check - how does this interact with Type (old question - what a Type really is?)

[16:06] * nothingmuch gives up on the y comb test

[16:06] <stevan> fglock: well, the parameterized Array class would implement the checking 

[16:06] <stevan> but you could get Array[Int] Array[Str], etc really easily

[16:07] <stevan> as for how it interacts with Type,.. I have no idea

[16:07] <stevan> nothingmuch: so is it choking Blondie?

[16:07] <nothingmuch> stevan: you pervert

[16:07] <stevan> nothingmuch: your sick,.. sick sick sick

[16:08] * stevan forgot he has to walk to the dog, bbiab &

[16:17] <gaal> rehi

[16:17] <nothingmuch> hi ho

[16:24] <gaal> fe

[16:35] <svnbot6> r7073 | nothingmuch++ | Some smoke tests for the Blondie backends

[16:36] <gaal> putter, ping

[17:15] <gaal> on win32, sometimes make doesn't precompile a prelude for me. has anyone seen this happen on other systems?

[17:17] <dudley_> gaal: It's never happened to me on osx, but I don't compile pugs as often as I used to.

[17:19] <gaal> this is pretty recent, say two weeks.

[17:24] <svnbot6> r7074 | stevan++ | docs/journal - update of current meta-model activity

[17:36] <darkelectron> so whats the deal with perl6?

[17:37] <gaal> how do you mean?

[17:37] <darkelectron> is it done yet?

[17:37] <darkelectron> its been years since I spent anytime with it

[17:37] <darkelectron> I haven't coded perl5 for like a year

[17:37] <gaal> it's not done, but it's progressing nicely.

[17:37] <darkelectron> ok

[17:38] <darkelectron> I was just wondering

[17:38] <darkelectron> be back in a year

[17:38] <gaal> heh.

[17:46] <acme> ;-)

[17:46] <autrijus> ;)

[17:47] <stevan> hola autrijus 

[17:47] <stevan> how is @life?

[17:47] <autrijus> see journal

[17:48] <gaal> autrijus!

[17:48] <gaal> hello! :)

[17:48] <autrijus> :)

[17:48] <autrijus> <- epitome of badluck this week

[17:49] <autrijus> but I survived, so it should me stronger, or something ;)

[17:49] <gaal> at least your passport eventually surfaced...?

[17:50] <autrijus> yeah. turns out .tw dhl and .us dhl knows nothing of .jp dhl shipment

[17:50] <autrijus> still shows "no info available" even when I got it

[17:50] <stevan> autrijus: so where are you now?

[17:50] <autrijus> stevan: .tw, about to get some much deserved sleep - was death marching for three days

[17:51] <autrijus> but I got a bundle of fine pugs t-shirts that surpassed my expectation

[17:51] <stevan> very nice

[17:51] <autrijus> I'm wearing it every day and that somehow kept me sane :)

[17:52] <stevan> :)

[17:52] <svnbot6> r7075 | stevan++ | Perl6::MetaModel 2.0 - 

[17:52] <svnbot6> r7075 | stevan++ | * fixed weirdness with Perl 5 subs to make the parameterized classes

[17:52] <svnbot6> r7075 | stevan++ |   work correctly

[17:53] <autrijus> I think I'm going to try Takahashi slides for ICFP for a change

[17:53] <autrijus> er CUFP

[17:53] <autrijus> seems a nice improvement over the Lessig style, or the MJD/Ingy style that I'm used to

[17:54] <stevan> I have never seen them, but I trust your opinion on the matter :) 

[17:55] <gaal> so you're using Acme::Takahashi::Method?

[17:55] <autrijus> stevan: http://www.rubycolor.org/takahashi/thinkinrails/img0.html

[17:55] <autrijus> gaal: the spirit of it :)

[17:56] <gaal> :)

[17:56] <autrijus> so, what's fun and exciting that I should mention in my talk?

[17:57] <autrijus> blondie?

[17:57] <stevan> Blondie is very cool yes

[17:58] <stevan> autrijus: what do you think of the parameterized classes hack?

[17:58] <stevan> I am not sure it is the right way to do it 

[17:58] <autrijus> stevan: the factory thing makes sense on runtime

[17:59] <autrijus> though it's not really positional

[17:59] <stevan> positional?

[17:59] <autrijus> ah, nvm, the spec wasn't positional anyway

[18:00] <autrijus> it's the compiler's job to translate Foo[Int, Str] into Foo('::T1' => ::Int, ''::T2' => ::Str)

[18:00] <stevan> it's all sugar to me  :)

[18:01] <szabgab> hi autrijus  

[18:01] <gaal> that's why we call you sweet tooth stevan

[18:01] <autrijus> greetings szabgab 

[18:01] <szabgab> you might know I am involved in the Hungarian Perl workshop[

[18:01] <szabgab> on 22nd October

[18:02] <szabgab> is there any chance seeing you there ?

[18:02] <autrijus> on 22nd I'll be in Nordic

[18:02] <szabgab> :-(

[18:02] <autrijus> which is also 22nd

[18:02] <autrijus> maybe the organizers can do another of those teleconference things

[18:03] <szabgab> we might setup videoconference like you had in Austria

[18:03] <szabgab> nearly the same people after all

[18:03] <autrijus> right, that would work.

[18:03] <szabgab> yeah I talk to Andras, 

[18:03] <szabgab> then it seems we'll meet in Israel

[18:04] <autrijus> indeed

[18:05] <clkao> szabgab!

[18:05] <clkao> szabgab: btw, hugary visa is insanely expensive

[18:06] <obra> autrijus: you'll be at nordic perl workshop?

[18:06] <szabgab> do you need a visa there ?

[18:06] <beppu> autrijus, (my response is a little late, but....) takahashi's slides are simple but very cool.  the big, bold lettering has a nice impact.  I like.

[18:06] <szabgab> it is EU

[18:06] <clkao> but tokaj++

[18:06] <clkao> no, it's not schengen state

[18:06] <clkao> so need different visa

[18:06] <clkao> obra: yes he will and i will too

[18:06] <obra> ooo

[18:06] * obra hopes the customer in .lt bites

[18:07] <autrijus> obra: aye. sorry I missed the conf call but I was still deathmarching anywa

[18:07] <szabgab> I see, I have Hungarian passport

[18:07] <autrijus> y

[18:07] <obra> autrijus: nod. it's ok

[18:07] <autrijus> beppu: yeah. I've only seen it in black on white

[18:07] <szabgab> clkao, btw can you also come to Israel ?

[18:08] <clkao> when is that?

[18:08] <autrijus> whilst I preferred white on black before. I wonder if there's something about takahashi that wants black-on-white

[18:08] <autrijus> clkao: feb 06

[18:08] <szabgab> sometime in February, no fixed date yet

[18:08] <svnbot6> r7076 | gaal++ | simplify lexical pragma stuff by dropping the cons list

[18:08] <clkao> ok... we'll see.. when is lunar new year?

[18:08] <autrijus> before that

[18:09] <autrijus> I depart immediately after lunar 5th

[18:09] <szabgab> really autrijus, do you have some preferred dates ?

[18:09] <autrijus> er, fwiw, 06 stood for '06, not 6th

[18:09] <autrijus> szabgab: well, midfeb sounds good, somewhere around 10th, just so I have more time to adjust for jetlag

[18:10] <szabgab> yeah, Larry said basically the only date that is not good for him is the 11th :-)

[18:10] <autrijus> cool, I'll be happy with 12th then

[18:10] <autrijus> a repeated hackathon with Larry would be most welcome

[18:10] <szabgab> I think we'll have to give him some time to come over from the US

[18:10] <autrijus> k

[18:11] <szabgab> I'll try to put the conf on 14-16

[18:11] <gaal> autrijus, you'll be coming from .tw?

[18:11] <szabgab> and hackathon afterwards

[18:11] <autrijus> gaal: likely. why?

[18:12] <gaal> no special reason. jetlag isn't too bad that way though, i think

[18:12] <gaal> 5 hours difference, going westwards

[18:12] <gaal> might actually be in your favor, because confs usually start early in the morning :)

[18:12] <autrijus> I certainly hope so :)

[18:13] <autrijus> also I think the pre-conf hackathon format worked well for yapcna

[18:13] <szabgab> but the drinking lasts late in the evening

[18:13] <autrijus> just so there's more exciting things to report at the con

[18:13] <szabgab> do you think it is better to hack before the conf ?

[18:13] <szabgab> ah

[18:13] <geoffb> (backlogging) What is the difference between Lessig and Takahashi?  Lessig has less on each slide?

[18:13] <gaal> szabgab, what drinking, autrijus will beat us all unconscious in the CPAN game :)

[18:13] <autrijus> geoffb: no, lessig's font size are fixed

[18:13] <geoffb> And hi, autrijus, nice to see you.

[18:14] <autrijus> geoffb: takahashi always scale to 100%

[18:14] <geoffb> ah, gotcha

[18:14] <autrijus> nice to see you too :)

[18:14] <geoffb> :-)

[18:14] <szabgab> gaal even with jetlag ?

[18:15] <geoffb> Well, new computer is (mostly) working, so coming back to where the flavor^Wfun is

[18:15] <autrijus> cool, and just in time for ghc 6.4.1 which should also improve in the zippiness front

[18:15] <geoffb> How so?  Better optimizer?

[18:16] <autrijus> yeah, less leak

[18:16] <geoffb> thank HEAVENS

[18:16] <autrijus> <cough>precompiled prelude</cough>

[18:16] <gaal> szabgab, i wouldn't count on that to save us :)

[18:16] <gaal> heh heh

[18:17] <geoffb> nodnod, maybe we can make the prelude longer without giving ghc dispepsia now

[18:17] <nothingmuch> autrijus: how's life?

[18:17] <nothingmuch> did the passport make it?

[18:17] <nothingmuch> oh wait, i see

[18:17] <nothingmuch> hurrah

[18:17] <gaal> autrijus, is there a way for me to debug-print all the existing envs at a given point? i'm trying to debug a mislaid write to an env. i'm not sure this question even makes sense...

[18:18] <nothingmuch> seen iblech

[18:18] <gaal> fe

[18:18] <gaal> grrr, i'm trigger happy

[18:18] <autrijus> gaal: all the existing envs?

[18:19] <gaal> well, it's like this: i'm writing something with putRuleEnv

[18:19] <gaal> but it doens't turn out where i want it

[18:19] <nothingmuch> autrijus: did you hear the blondie news?

[18:19] <gaal> so either i'm writing it to some sort of a temporary env, or, well, i don't know :)

[18:20] <gaal> but i don't really grok the lifetime of an env, in a pure world, which is why my question may not be sensible

[18:20] <gaal> it's not even supposed to have a lifetime, is it

[18:21] <autrijus> nothingmuch: yes I did, most amazing work

[18:21] <autrijus> I got it running and I saw the C output.

[18:21] <autrijus> nothingmuch: no README? ;)

[18:22] <nothingmuch> phooey

[18:22] <nothingmuch> it raises kwalitee

[18:22] * nothingmuch will henceforth stop pod tests, stop READMEs, changelogs, licence files, and whatnot.

[18:22] <nothingmuch> i will explicitly insert one padly formatted pod file into every dist

[18:22] <nothingmuch> and.... uh...that's it

[18:23] <nothingmuch> well, no, i'm kidding

[18:23] <geoffb> <troll>But POD already *is* badly formatted!</troll

[18:23] <nothingmuch> geoffb++

[18:24] <gaal> if it were the end of March nothingmuch would be releasing Devel::Uncover

[18:24] <nothingmuch> huh? what's March got to do with it?

[18:24] <geoffb> Perhaps the Ides of March?

[18:24] <gaal> April :-)

[18:24] <gaal> (first)

[18:24] <nothingmuch> ah

[18:24] <geoffb> :-)

[18:25] <nothingmuch> i don't know what it'll do ;-)

[18:25] * nothingmuch fills a few more songs into the ipod, and goes biking

[18:25] * geoffb has been rolling the Getopt stuff around in his head . . . (ow, ow, stop that!)

[18:26] <gaal> nothingmuch, it'll probably search for tests and delete them?

[18:26] <nothingmuch> autrijus: i am going to break the AST tonight, so when you return from CUFP things should be better

[18:26] <geoffb> You know, maybe the solution is to just stop the hackish designs and go straight to defining the command line as a language, using rules . . . .

[18:26] <nothingmuch> gaal: hmm... interesting

[18:26] <geoffb> (yes, I understand P6 rules don't work now, I'm thinking about the Happy Place(tm))

[18:26] <nothingmuch> geoffb: the problem is that there are too many dialects

[18:26] <nothingmuch> and the worse problem is that they are all equally valid

[18:27] <gaal> geoffb, have you seen my post about that?

[18:27] <geoffb> No, that's what I'm saying . . . have an engine that parses an array of arguments according to a grammar.  The only thing special is that the shell has already done a tokenize pass for you.

[18:27] <geoffb> gaal, yes.

[18:27] <geoffb> er, at least at LJ

[18:28] <gaal> yeah, that one.

[18:28] <geoffb> So specify all standard dialects as grammars,

[18:28] <nothingmuch> geoffb: err, that's what I was sort of thinking of earlier

[18:28] <geoffb> rather than regex monstrosities

[18:28] <nothingmuch> except with an event parser approach

[18:28] <nothingmuch> and stacking layers of high levelism

[18:28] <geoffb> Yeah, I was offering grammars as an alternative to event parser approach

[18:29] <nothingmuch> can the rule engine handle tokens which aren't chars? (please pretty please?)

[18:29] <geoffb> Grammars already have obgect orientation

[18:29] <geoffb> so use it

[18:29] <geoffb> hmmm?  What do you mean?

[18:29] <nothingmuch> Parsec, for example, can parse any list

[18:30] <nothingmuch> it only happens to provide builtin parsers (rules in p6esque) that parse arrays of chars

[18:30] <nothingmuch> (strings)

[18:30] <geoffb> nod

[18:30] <nothingmuch> i'd like to be able to do two things:

[18:30] <geoffb> So PGE seems to be an early optimization that wasn't backed up with huge amounts of time to overcome the early opt hell.

[18:30] <nothingmuch> lazy parsin

[18:31] <nothingmuch> made practical using the cutoff operation

[18:31] <nothingmuch> that's one

[18:31] <geoffb> So we should go the opposite direction, and be as simple as possibly necessary to get something that complies with the Rules design

[18:31] <nothingmuch> (for infinite streams)

[18:31] <nothingmuch> and second is support for parsing anything

[18:31] <geoffb> nodnod

[18:31] <nothingmuch> define rules which eat tokens that aren't chars at all

[18:31] <nothingmuch> including branching

[18:31] <nothingmuch> (parsing a tree)

[18:32] <geoffb> right

[18:33] <geoffb> OK, who has worked on Rules engines so far?

[18:33] <nothingmuch> pmichaud

[18:33] <geoffb> I know pmichaud for PgE

[18:33] <geoffb> nod

[18:33] <nothingmuch> the parsec guy

[18:33] <nothingmuch> the arrows guy

[18:33] <nothingmuch> let's get the arrows guy to do it for us

[18:33] <geoffb> heh

[18:34] <nothingmuch> parrow is faster than parsec ;-)

[18:34] <autrijus> I for the longest time thought prettyprinting combinators should be able to serve also as parser combinators

[18:34] <nothingmuch> Template::Extract and Template::Generate?

[18:34] <autrijus> and those combinators shoudl be inferable too

[18:34] <autrijus> yeah.

[18:34] <svnbot6> r7077 | autrijus++ | * 6.2.10's Main.hs poem is in Espa?\195?\177ol: "Un nuevo barco para ?\195?\169l construyeron..."

[18:34] <nothingmuch> autrijus++

[18:34] <nothingmuch> you do it then ;-)

[18:35] <gaal> ah it's by *version*!

[18:35] <geoffb> autrijus, how many languages do you speak, anyway?

[18:35] <nothingmuch> TSa never listens =(

[18:35] <integral> the parsing idea described in the idiom notes sound interesting too, they interleave the function with constructs the tree with the parsing

[18:35] <nothingmuch> "No, the role installs homogenious targets into the generic                                           

[18:35] <autrijus> geoffb: surprisingly few; chinese, holok, english, a bit german, and that's it

[18:35] <nothingmuch> binary-MMD comparator which I think is called eqv."

[18:35] <nothingmuch> this was a reply to me, on a thread where i criticized eqv

[18:35] <nothingmuch> autrijus: that's not few

[18:35] <nothingmuch> that's average plus

[18:35] <geoffb> autrijus, clearly you haven't spent enough time with Americans if you think that's small.

[18:35] <nothingmuch> most people I know speak one language well

[18:36] <nothingmuch> and if it's not english than they also speak OK english

[18:36] * geoffb just thanks his lucky stars that he natively speaks the language of computing

[18:36] <autrijus> geoffb: the americans I spent time with, they generally speak 2+ langs, or are at least okay with me speaking nonenglish in front of them

[18:37] <autrijus> (the latter trait, I was much surprised to learn, is of minority)

[18:37] * stevan never understood why people got offended by that

[18:37] <autrijus> ditto

[18:37] <stevan> most of the same people who are offended by that, would probably speak english in front of you :)

[18:37] <autrijus> you'd think they'll also oppose OpenPGP or something

[18:38] <geoffb> Not that I'm one of those, but I'm guessing perhaps it's like having your parents taking about you in the third person in front of you?  Kindof a "Hello, I'm HERE!" kindof issue

[18:38] <stevan> regardless of if you knew it or not

[18:38] * geoffb generally doesn't have much of a problem with that, because he figures anyone speaking another language in front of him doesn't want to communicate with him

[18:38] <stevan> geoffb: some people might see it as that

[18:38] <autrijus> geoffb: yeah, but I learned english on IRC, which it is pretty much a given that people will 1)talk past each other and 2)not comprehending much of the sentences not directed to them

[18:39] <geoffb> LOL

[18:39] <stevan> however, it is not always easy to express yourself in a second language (be it english or another), and when conversing with another native speaker, why cripple the converstation to my (non-speaking) level

[18:39] <geoffb> no doubt

[18:40] <geoffb> Actually, some dialects I like to hear people speak in, because the sounds of the language are beautiful and calming.

[18:40] <stevan> yes, that is true

[18:41] * stevan always wanted to learn another language, but has enough trouble with english as it is

[18:41] <geoffb> I wish I could take the DoD tests that can figure out what language you'd be good at.

[18:41] <stevan> geoffb: are tehy not public?

[18:41] <geoffb> My Dad did that many years ago, and the answer was Chinese.

[18:42] * nothingmuch studied french for a while

[18:42] <stevan> geoffb: was your dad in the DoD?

[18:42] <nothingmuch> i like it a lot, but:

[18:42] <nothingmuch> teacher was kind of lousy

[18:42] <nothingmuch> not enough practice

[18:42] <nothingmuch> some day i'll go to a french speaking country for a few months to make sure I lock it in

[18:42] <geoffb> stevan, Vietnam-era Air Force.

[18:42] <geoffb> I took 5 years of French.  I remember a few phrases.

[18:43] * stevan took  spanish and german classes, but would mix up the two, which made for very confused teachers

[18:44] <nothingmuch> wow, Gong can be annoying when you're not in the mood

[18:44] <geoffb> stevan, I thought you pretty much only got them if you went to sign up for military service.  Which in the current political climate in the US is . . . possibly tantamount to suicide.

[18:44] <stevan> geoffb: doesnt have to be the armed forces, I think the CIA is hiring ;)

[18:44] <geoffb> Nothing like children to make you say "I'll pick my battles, thanks."

[18:44] <svnbot6> r7078 | autrijus++ | * Minor comment cleanup in Main.hs

[18:45] <geoffb> Oh man, I'd be such a horrid spook

[18:45] <geoffb> Way too honest

[18:45] <stevan> yeah, me too, I am a very bad opium farmer too

[18:45] <nothingmuch> geoffb: stevan knows

[18:45] <geoffb> ???

[18:45] <stevan> nothingmuch: shhhhhhhhhhh

[18:45] *** stevan is now known as nothingmuch_

[18:46] <nothingmuch> whenever I would threaten to take the money and run when he made me write Verby he would be like "i know where to find you"

[18:46] <nothingmuch_> oh geoffb, nothing ...

[18:46] *** nothingmuch_ is now known as stevan

[18:46] <gaal> lol

[18:46] <geoffb> heh

[18:46] <nothingmuch> geoffb: forgive stevan, he's in a kinky mood today

[18:46] <nothingmuch> how did nickserv let you be nothingmuch_ ?

[18:46] <geoffb> Kinkiness is always forgiven

[18:46] * autrijus waves goodnight to you spirited folks :)

[18:46] <nothingmuch> ciao autrijus!

[18:46] <gaal> autrijus, re: pre-YAPC::Il hackathon - sure, my place will be open to hackers from when you arrive

[18:46] <geoffb> Have a good night autrijus!

[18:47] <gaal> well, after you'd done the post-flight sleep that is

[18:47] <autrijus> gaal: much kudos

[18:47] <nothingmuch> apropos spirited, did you see the backlog from the Juerd talk about life?

[18:47] <gaal> only problem it isn't very big

[18:47] <nothingmuch> that was a funny moment =)

[18:47] * stevan dials his Mossad contact .....

[18:47] <geoffb> nothingmuch, link?

[18:47] <nothingmuch> gaal: can I stay too?

[18:47] <gaal> nm, sure

[18:47] <nothingmuch> mui bien

[18:47] <gaal> what Juerd talk?

[18:47] <autrijus> nothingmuch: no. url?

[18:48] <nothingmuch> one sec

[18:48] <nothingmuch> starts here: http://colabti.de/irclogger/irclogger_log/perl6?date=2005-09-16,Fri&sel=78#l123

[18:48] <nothingmuch> it's really very funny

[18:48] <gaal> async { say "night, autrijus" }

[18:48] <nothingmuch> we discover that QtPlatypus and I are twins with a telepathic link

[18:49] <nothingmuch> and then Juerd's electricity goes out to make the point extra clear

[18:49] <nothingmuch> async... mmm.

[18:49] * nothingmuch had fun with async today

[18:49] <nothingmuch> scook should be happy =)

[18:51] * geoffb 's mind wanders back to an actual on topic subject, strangely

[18:51] <geoffb> So lessee, we need:

[18:52] <geoffb> 1) A generic grammar engine that understands things other than arrays of characters

[18:52] <autrijus> 4005 pass for pilrun?

[18:52] * autrijus is positively shocked

[18:52] * nothingmuch checks if hs pugs stopped hanging in ext/

[18:52] <autrijus> I was still remembering it as <400

[18:52] <geoffb> 2) One or more modules that convert friendly CLI descriptions to grammars and run them

[18:53] * autrijus finally asynchronously goes back to sleep

[18:53] <nothingmuch> ciao

[18:53] <geoffb> The nice thing is that 2) shouldn't be brutally hard, and 1) gets us past the PGE blockade

[18:53] <geoffb> to tuit or not to tuit, that is the question

[18:54] <geoffb> I have too strong a tendency to take on projects, I think

[18:55] <geoffb> I just hate saying "Gee, someone should do this, just not me."

[18:55] <geoffb> bah

[18:55] * nothingmuch does it all the time

[18:55] * geoffb 's stream of consciousness begins to dribble out his ears

[18:55] * nothingmuch only gets to the fun stuff

[18:56] <nothingmuch> geoffb: how's your forth

[18:56] <geoffb> It's been on the back burner since the machine arrived, but I'm considering restarting it

[18:57] <geoffb> It actually can compile words at this point, rather than faking it.

[18:57] <nothingmuch> ooh

[18:57] <nothingmuch> with the : word and immediate/nonimmediate, and STATE?

[18:58] <geoffb> Yep

[18:58] <nothingmuch> cool!

[18:58] <nothingmuch> where is it?

[18:58] <geoffb> mmmf, hold on, I'll look

[18:59] <nothingmuch> bah, it's getting late.

[18:59] <geoffb> perlbot, nopaste

[18:59] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[18:59] * nothingmuch is going to go biking

[18:59] <szabgab> aurijus we are looking for sponsors for both the conference, the hackathon and your stay in Israel

[18:59] <nothingmuch> so paste it and i'll read it later

[19:00] <nothingmuch> szabgab: he went to bed

[19:00] <szabgab> :-(

[19:00] <szabgab> then I talk to him later I guess

[19:00] <nothingmuch> szabgab: email is probably best

[19:00] <szabgab> which is?

[19:00] <nothingmuch> [email@hidden.address]
[19:00] <szabgab> ok, I can find it

[19:00] <szabgab> found it :-)

[19:01] <nothingmuch> geoffb: i'll ttyl

[19:01] <nothingmuch> *poof*

[19:01] <pasteling> "geoffb" at 69.110.115.185 pasted "gjbforth part 1: Perl" (333 lines, 10K) at http://sial.org/pbot/13243

[19:02] <pasteling> "geoffb" at 69.110.115.185 pasted "gjbforth part 2: prelude" (98 lines, 2.4K) at http://sial.org/pbot/13244

[19:02] <geoffb> It's buggy, but it's all mine.  :-)

[19:03] <szabgab> I am not really following, what's going on with the separation of stages that will make it "easy" to write other front-ends to Pugs ?

[19:55] <kolibrie> geoffb: I've been playing around with MJD tokens function from Higher-Order Perl 8.1.3

[19:55] <kolibrie> I've gotten it to work with Perl 6, mostly

[19:56] <kolibrie> I don't know if that kind of approach would be useful for command-line argument parsing

[19:56] <kolibrie> tokenize what you know, leave everything else intact

[21:19] <geoffb> kolibrie, if you backlog: That is probably a good option for nothingmuch's approach, actually.

[21:19] <svnbot6> r7079 | stevan++ | Perl6::MetaModel 2.0 - 

[21:19] <svnbot6> r7079 | stevan++ | * Roles are now (mostly, sorta) complete. 

[21:19] <svnbot6> r7079 | stevan++ |    - Role does Role

[21:19] <svnbot6> r7079 | stevan++ |    - Class does Role

[21:19] <svnbot6> r7079 | stevan++ | * some tests added to check this stuff, but many more still 

[21:19] <svnbot6> r7079 | stevan++ |   needed. 

[21:20] <geoffb> My true calling -- kicking svnbot

[21:48] <putter> gaal: pong

[21:49] <putter> fglock: have you seen the latest PIL-Run smoke?  4k passes.  :)  fglock++

[21:49] <putter> slurpy array parameters are busted again unfortunately.  if you get a chance to look at it... ;)

[21:50] <putter> stevan: sooo... MM2.0 ready to be swapped into PIL-Run yet?  :)   /me wonders hopefully

[21:53] <rafl> Good evening everybody

[21:53] <fglock> putter: ping

[21:53] <putter> re pugs, if there are more portability issues on pugs-is-now-a-script, someone should look more closely at make (MakeMaker?)... this has to be a solved problem.

[21:53] <putter> fglock: pong.  hi!

[21:54] <putter> evening rafl

[21:54] <fglock> hi! I've been away for a few days - back to normal now :)

[21:54] <putter> i'm about to disappear for a few days.  ;)  such is life.

[21:55] <fglock> I saw you have problems with :todo - did you set the parameter to optional?

[21:57] <putter> yeah, I did a workaround ... ?$msg, ?$todo)    it works now on pilrun, but is incorrect (ie, doesnt work on pugs).  when slurpy hashes work (even just plain hashes dont really work at present), we can change it to ?$msg, *%adverbs).

[21:57] <fglock> Perl6::Param->new( ..., required => 0 )

[21:57] <putter> ?

[21:57] <putter> explain ?

[21:58] <fglock> maybe I didn't understand what the problem is

[21:59] <fglock> I thought ?$todo wasn't working

[21:59] <putter> sub f(*%h){}  f()   errors in Code

[21:59] <fglock> ok

[21:59] <putter> hmm, or did.  before I short-circuited check_mumble.  but since I gave up on *%h, the short-circuit can come out now.

[22:00] <fglock> is slurpy array ok?

[22:01] <putter> sub f(?$todo){}  f(:todo<bug>)  should not work.  but in pilrun, it isnt, it currently works, so.... I use it.

[22:01] <putter> slurpy array is dead dead not working dead.

[22:01] <putter> ;)

[22:02] <fglock> the implementation is pretty simple (Code.pm 281) it should work. Adding slurpy hash should be easy

[22:02] <fglock> but if slurpy array doesn't work we have a problem

[22:05] <putter> ok, 7080 has the short-circult removed.

[22:06] <fglock> slurpy array creates a native array - maybe that's the problem?

[22:06] <putter> yes, slurpy array is needed by many things.

[22:07] <putter> it may not be related, but I had to modify p6_to_a() (another layer of ->fetch()?) as it was not working.

[22:08] <putter> $ary->fetch($i)->fetch

[22:08] <fglock> that's right - array fetch returns a Scalar - so you have to fetch again

[22:09] <fglock> that's because you may want to $ary->fetch($i)->store($thing)

[22:09] <fglock> for example $a[$i] = 3

[22:09] <putter> k

[22:10] <putter> ./pugs -B perl5

[22:10] <svnbot6> r7080 | putter++ | Perl6/Code.pm: removed check_params() short-circuit.  Giving up on sub f(*%h){} for now.

[22:10] <putter> sub f(*@a){} f(3,4)

[22:10] <putter> sub f(*@a){@a} f(3,4)ARRAY(0x1289400)

[22:10] <fglock> I'll make *@a create a boxed array - wait a second

[22:10] <putter> that probably shouldn't be an ARRAY, but an Array

[22:10] <putter> :)

[22:10] <fglock> yes

[22:11] <putter> I'd say it was almost time for a pilrun evalbot... but safety would be a nightmare.

[22:11] <putter> bbiam

[22:15] <fglock> done - slurpy array works now

[22:15] <putter> back

[22:15] <svnbot6> r7081 | fglock++ | * perl5/Code - slurpy array now creates a boxed Array internally

[22:15] <putter> awesome! :)

[22:15] <fglock> now let's see slurpy hash

[22:16] <fglock> I think slurpy hash is actually creating an array of pairs - I'll test

[22:17] <putter> hmm... ./pugs -B perl5 -Iperl5/PIL-Run/lib6 t/subroutines/slurpy_param.t  went boom, but I'm not sure it ever worked...

[22:19] <fglock> the signature check for slurpy hash must be fixed first

[22:20] <putter> ok

[22:21] <fglock> only Array and Hash can be slurpy?

[22:23] <fglock> ok, I've got it generating an Array of pairs - now let's make it into a hash

[22:24] <putter> I think there is slurpy code, but it's not a pressing issue.

[22:25] <putter> Note that hash has issues:  %h=(3,4)  errors, %h=(3=>4)  yields {((3, 4), undef)}, etc.

[22:27] <fglock> ok - so we should expect these errors

[22:28] <fglock> btw - %h=(3=>4) error may be bacause it is calling $hash->store($pair) instead of $hash->store($key,$value)

[22:29] <fglock> so the key is "3=>4"

[22:31] <putter> So what has changed about slurpy array params since they were list working?  Line 224 in ApiX is giving an Not an ARRAY reference error, breaking all the PrimP5.pm primitives with slurpy array parameters.

[22:31] <putter> s/list working/last working/

[22:32] <fglock> I don't get this error here

[22:32] <putter> p5ugs> join("a","b")

[22:32] <putter> Fyi: Not an ARRAY reference at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/lib/PIL/Run/ApiX.pm line 224.

[22:32] <fglock> ok, I got it

[22:32] <rafl> Any news from autrijus, btw?

[22:33] <putter> he stopped by earlier today.  and there is a new journal entry.

[22:35] <fglock> slurpy hash is ok

[22:35] <fglock> now checking the join() error

[22:36] <fglock> sub f(*%a){%a} f(3=>4, 5=>6)

[22:37] <geoffb> rafl, and he actually sounded decent, if tired

[22:39] <rafl> Ah, OK

[22:39] <svnbot6> r7082 | fglock++ | * perl5/Code - slurpy hash works

[22:40] <putter> (versioned evalbot)++

[22:41] <geoffb> Yeah, I like it too.  Some people find it wasteful, but I think the old scheme was just hiding the work, rather than not doing it

[22:42] <putter> ah.  transparency++ :)

[22:42] <fglock> putter: line 224 is expecting a native ARRAY - it is getting an Array now

[22:43] <putter> ok, I'll change that

[22:43] <fglock> thanks

[22:43] <putter> sub f($foo){13} f()  currently works, but likely shouldnt

[22:43] <fglock> checking

[22:45] <fglock> it is ignoring extra parameters - Code.pm 225 - I'll try to fix that

[22:48] <geoffb> Heh: on the path to finding out a problem with the $contract code I was debugging was actually just a PEBCAK, I found (and fixed) a real bug in the project's debug logging facility . . .

[22:51] <putter> :)

[22:52] <putter> pebcak?

[22:52] <mugwump> problem exists between chair and keyboard

[22:52] <geoffb> what mugwump said

[22:53] <geoffb> My other favorite for consulting, slightly more pointed, is PICNIC: Problem In Client, Not In Computer

[22:55] <geoffb> Though honestly, PICNIC situations often mean the UI sucks . . . 

[22:55] <putter> :)

[22:57] <fglock> putter: it looks like the required/optional flag is not being set (all parameters are required)

[23:00] <fglock> "sub f($foo,?$x){13}" has the internal signature "(Any $foo, Any $x)"

[23:03] <svnbot6> r7083 | putter++ | PIL-Run - progress with slurpy array parameters.  fglock++  join() improved, but still failing many tests.

[23:03] <putter> ./pugs -B perl5 -Iperl5/PIL-Run/lib6 t/builtins/lists/join.t  now has some passes. :) !  and many failures.

[23:04] <putter>  required/optional flag?   a Param->new thing?

[23:05] <fglock> yes - either you send it a variable with the '?', or you set "required=>0"

[23:06] <putter> so '?$x' means optional, but apparently '$x' does not mean required?

[23:06] <putter> '$x',required=>1  neededd?

[23:07] <fglock> required is the default - you need it when required=>0

[23:07] <fglock> required=>0 means optional

[23:08] <fglock> I think the '?' is being stripped before Param->new

[23:10] <putter> err, the problem is sub f($x){13} f()  _works_.... no ? to strip...

[23:12] <fglock> I was counting parameters in Code->check_params(), in order to fix the f() bug, and then I noticed that the optionals are not marked as optionals

[23:12] <fglock> it's an urelated bug - but it explains the :todo problem

[23:18] <fglock> fixed 'f($x){13} f()' - but Code.pm still needs much work

[23:18] <putter> ok.  sorry, I got distracted working through join.t    looks like my "strawman" join() primitive was quite incomplete...

[23:18] <putter> !:)

[23:20] <putter> very odd join.t test:

[23:20] <putter> my $joined4d = join("", [ "a", "b", "c" ]);

[23:20] <putter> is($joined4d, "a b c", 'join("", []) works');

[23:20] <svnbot6> r7084 | fglock++ | * perl5/Code - fixed Code->check_params() strictness about required parameters

[23:22] <fglock> is it supposed to be  'join("",  "a", "b", "c" )'

[23:22] <fglock> ?

[23:22] <putter> fglock: r7084 broke lib6/Test.pm.   Signature does not match - (Any $v, Any $v2, Any $msg, Any $todo).

[23:23] <fglock> isn't it "?$todo" - the optional parameter bug?

[23:25] <putter> hmm, ? is getting stripped... let's see where...

[23:25] <fglock> found it - ApiX 299

[23:26] <fglock> needs a required=>xxx flag

[23:28] <fglock> somehow the parameter in line 266 should get to line 299 :)

[23:28] <putter> err, I thought required=>1 was the default...

[23:28] <putter> however, the $is_optional test was wrong.  no ref() needed/wanted.

[23:29] <fglock> it is - that's why it is requiring a :todo

[23:34] <putter> ok, isOptional works.  yay.

[23:34] <putter> 7085.

[23:34] <fglock> :)

[23:35] <putter> looking at the other flags, is there anything which should be done with is invocant/lvalue/lazy/named/writable?

[23:36] <putter> any Param->new() flags for them?

[23:37] <fglock> some parameters are not implemented yet - checking

[23:38] <svnbot6> r7085 | putter++ | PIL/Run/ApiX.pm: optional args fixed.

[23:38] <svnbot6> r7085 | putter++ | PIL/Run/PrimP5.pm: join() improved.

[23:39] <fglock> new() takes: type - a Perl6::Type, name - the name, default - the default value, required, slurpy - it is missing all of invocant/lvalue/lazy/named/writable

[23:40] <putter> ok

[23:40] <putter> I've been meaning to do default value, but just haven't gotten to it.

[23:40] <fglock> you can add those - they will be ignored by now, but they can be implemented later

[23:40] <putter> k

[23:40] <fglock> default is easy - just say default=>$thing

[23:41] <fglock> btw - congratulations for the 4k mark!

[23:42] <putter> I'm going to leave Test.pm using ?$msg,?$todo)  as ?$msg,*%adv) eats :todo<bug> with $msg when there's no msg.

[23:43] <putter> hey, it's your and stevan's (and anyone I'm leaving out's) work on mm and objects.  I've just added a bit of pil-ish glue.

[23:43] <putter> fglock++ ;)

[23:43] <fglock> that's one of the 'need more work' errors I was talking about - named parameters are not handled properly yet

[23:44] <putter> Junctions are going to be a real pain.  But there's lots of stuff to do first.

[23:44] <fglock> I must leave now - I'll try to come back later

[23:44] <putter> thanks for your work.

[23:44] <fglock> thank you

[23:45] <putter> I'll clean up a bit, and leave a new smoke running... :)

[23:48] <buu> ?eval my $a="b"; $a--;

[23:48] <evalbot_7085> 'b' 

[23:48] <buu> ?eval my $a="b"; $a--; $a

[23:48] <evalbot_7085> \-1.0 

[23:48] <buu> =[

