[00:06] <putter> nothingmuch: not quickly, but I note svn.openfoundry.org still doesnt ping.  www.openfoundry.org is up, but I dont immediately see status info.

[00:07] <putter> It also wasnt pinging 8+ hours ago.

[00:30] <Darren_Duncan> to whom it concerns, openfoundry.org seems to be down right now

[00:55] <putter> Darren_Duncan, yes, thanks.  Its been down for many hours.

[00:55] <putter> :(

[00:56] <autrijus> yeah.

[00:57] <autrijus> it being the weekend, I think there's still exactly 24 hours to go before it will be back up.

[00:58] * autrijus sighs and waves and falls back to sleep again, having jumped out the window of the closet^Wroom and almost had to jump back in... &

[01:53] * Khisanth wonders why autrijus is jumping out of windows

[01:53] <kelan> the door to his room only has a knob on the outside

[01:54] <QtPlatypus> Sounds like my office.

[02:24] <_meppl_> gute nacht

[03:59] <Aankhen``> Server's down?

[04:00] <gaal> was, last night at least...

[04:00] <QtPlatypus> Yes

[04:00] <Aankhen``> ?eval class Foo { };

[04:00] <evalbot6> undef 

[04:00] <Aankhen``> Ah.

[04:00] <Aankhen``> That bites.

[04:00] <Aankhen``> ?eval class Foo { }; module Foo { };

[04:00] <evalbot6> undef 

[04:02] <Aankhen``> ?eval class Foo { method bar (Class $self: ) { "I'm a class, you " ~ ::?CLASS } }; module Foo { sub bar () is export { "I'm a module, you $?PACKAGE!" } }; use Foo; bar();

[04:02] <evalbot6> pugs: *** No compatible subroutine found: "&use"     at -e line 4, column 5-253 

[04:02] <QtPlatypus> Safe mode?

[04:02] <gaal> nah, you can't do that. it's 1. safe mode, no "use" and 2. use wouldlook for a file.

[04:03] <Aankhen``> Yeh, I see.

[04:12] <Darren_Duncan> it may be useful to give different error messages if something isn't working because it is explicitly disabled by safe mode, rather than never supported

[04:33] * Aankhen`` goeth out.

[04:33] <Aankhen``> Later.

[06:02] <Alias_> This channel is logged?

[06:02] <Khisanth> It was not sure it if it still is

[06:03] <revdiablo> http://colabti.de/irclogger/irclogger_logs/perl6

[06:03] * Alias_ is not entirely happy to find out that everything he has ever said in here is public, online and searchable

[06:03] <Pete_I> one of the several bots probly keeps logs.

[06:03] <Pete_I> haha

[06:04] <Alias_> I don't mind people logging and doing it for themselves

[06:04] <Pete_I> well, this is a public channel.

[06:04] <Alias_> CRAP, and in real time

[06:04] <Darren_Duncan> I think the public logging is a great idea

[06:04] <Pete_I> (there's a bot in here that's updating it)

[06:05] <Darren_Duncan> lots of important things are discussed here, and its good to have a backup copy to refer to later

[06:05] <revdiablo> Pete_I: are you sure? I thought someone was busily copying and pasting.

[06:05] <Pete_I> haha

[06:05] <Pete_I> yeah....

[06:05] <Darren_Duncan> the irclogger is akin to what nntp.perl.org does for the mailing lists

[06:05] <Alias_> Darren_Duncan, as I said I'm totally ok with private logging and searching

[06:05] <revdiablo> now I have a strange desire to search the logs for everything Alias_ has said in here

[06:05] <Alias_> But irc is not generally a considered a "will hang around to haunt you for the rest of your life" medium

[06:05] * nothingmuch wonders how he'll get to work this morning

[06:06] <Alias_> unlike mailing lists

[06:07] <Pete_I> revdiablo, i think i'll use google to do it :)

[06:08] <Alias_> I wonder if google does index it...

[06:08] <Alias_> http://ali.as/  # onling logging google link spam!

[06:08] <Alias_> online

[06:26] <Alias_> Speaking of public logs...

[06:26] <nothingmuch> autrijus: ping

[06:27] <Alias_> Darren_Duncan: Re: your interest in PPI...

[06:27] <Alias_> The one larry is doing is a totally different approach

[06:27] <Alias_> Larry is doing a code porter

[06:27] <Darren_Duncan> I'm here

[06:27] <Alias_> Imagine a B::Deparse that spat out Perl 6

[06:27] <Alias_> instead of Perl 5

[06:27] <Alias_> So it only works if you can get the module compiling and loaded

[06:28] <Darren_Duncan> Alias_, what do you mean "my interest in PPI"?

[06:28] <Darren_Duncan> I've never used PPI

[06:28] <Alias_> maybe it was gaals

[06:28] <Alias_> http://colabti.de/irclogger/irclogger_log/perl6?date=2005-03-15,Tue#l391

[06:28] <Darren_Duncan> true, I am doing a project to parse and rebuild SQL

[06:29] <Darren_Duncan> there is some conceptual overlap, but SQL is a lot simpler

[06:29] <Darren_Duncan> ... than Perl

[06:29] <Darren_Duncan> checking log ...

[06:30] <Darren_Duncan> anyway, I'm aware that Larry is hacking Perl 5 itself to remember all the whitespace etc so it spits out identical perl 5 first, and then equivalent perl 6 next, rather than using PPI

[06:30] <nothingmuch> Alias_: your ppi demo says: Can't locate object method "_commit" via package "PPI::Token::Word" ... at /usr/local/share/perl/5.6.1/PPI/Token/Whitespace.pm line 75

[06:31] <Alias_> erk.. it's probably not ported up to the current version. There's been some API changes

[06:31] <Alias_> The demo is very ad-hoc...

[06:31] <Alias_> I keep meaning to do an Ajax one

[06:31] <Alias_> Type into some field, parsed version appears in other panel

[06:31] <nothingmuch> spunky

[06:32] <nothingmuch> oh my, harrorth is 12,000 words

[06:32] <Darren_Duncan> Alias_ - yes, I mentioned PPI on March 15th because I heard about it being used to help with porting, and read an item on Perl Foundation towards funding that, but I had no further involvement besides the cursory knowledge

[06:32] <Alias_> yeah, never mind

[06:32] <Alias_> :)

[06:33] <Darren_Duncan> anyway, I'm doing a large re-implement of Rosetta, fixing some design flaws in my previous version, so it should actually be useable to do reall work in a week or so

[06:33] <Darren_Duncan> this all in Perl 5 right now

[06:33] <Alias_> really?

[06:33] <Alias_> wow

[06:33] <QtPlatypus> What is Rosetta?

[06:33] <Alias_> A sort of SQL generation/abstraction thingy

[06:33] <Darren_Duncan> Rosetta is a framework to let applications run seamlessly on multiple database products

[06:33] <Alias_> A little wordy at times, but very "correct"

[06:34] <Alias_> I've been_too_scared_because_of_the_giant_method_names :)

[06:34] <Darren_Duncan> bringing to databases what Java etc does with apps, "write once, run anywhere"

[06:34] <Darren_Duncan> DBI doesn't do this by itself

[06:34] <Darren_Duncan> it goes part way

[06:34] <Alias_> DBI is a connector...

[06:34] <Darren_Duncan> yes

[06:35] <Alias_> Has the XML beurocracy invented XSQL yet?

[06:35] <Darren_Duncan> DBI makes the pipes to the databases look the same ... Rosetta makes the databases themselves look the same

[06:35] <Alias_> How does it handle sequences?

[06:35] <Alias_> (meaning to ask for a while now)

[06:35] <Darren_Duncan> I've heard of XSQL but think it never went anywhere

[06:35] <jql> XQuery

[06:35] <jql> also, WebDAV has a SQL syntax in XML as well

[06:35] <Alias_> My abstraction layer currently does emulated sequences for MySQL

[06:35] <Alias_> But for other database, it gets painful

[06:36] <Darren_Duncan> Rosetta will use the database's built-in sequences if they have them, and in some cases emulate them when not

[06:37] <Darren_Duncan> Rosetta generally uses a database's built-in features where all possible, and emulates only when they lack native support

[06:37] <Darren_Duncan> unlike many other wrappers that just emulate for all dbs, treating all like least common denominator

[06:37] <Alias_> I agree

[06:37] <Alias_> I do the same, it's definitely better

[06:37] <Darren_Duncan> sometimes I even get the db itself to emulate a missing feature

[06:38] <Alias_> I'd love to write a Rosetta backend some time

[06:38] <Darren_Duncan> eg, a database without native UNION support can still do all the work with a specially crafted JOIN using a temporary table

[06:38] <Alias_> Just to see how comparably fast/bloaty it would be

[06:38] <Darren_Duncan> you should get your chance by the end of June

[06:38] <Alias_> And I'll find the time   by the end of the year... maybe

[06:38] <Alias_> :)

[06:39] <Darren_Duncan> Rosetta will generate actual UNION sql for a conceptual union when supported, and generate JOIN sql in other cases

[06:39] <Alias_> What databases ATM?

[06:39] <Darren_Duncan> define 'ATM'

[06:39] * Alias_ only needs Postgres/MySQL/ORacle

[06:39] <Alias_> At the moment

[06:39] <Darren_Duncan> MySQL 4.0+ has unions, 3.x doesn't, but support joins

[06:39] <Alias_> What databases does Rosetta support

[06:40] <Darren_Duncan> all of them

[06:40] <Alias_> what do you mean, "all"

[06:40] <Darren_Duncan> more specifically, Rosetta is extensible ala DBI

[06:40] <Darren_Duncan> you can add support for more with plugins

[06:40] <Alias_> For example, does it support SQLite, and emulate sequences properly

[06:40] <Darren_Duncan> SQLite is the very first db it will support, MySQL second

[06:40] <Alias_> Because as far as I was aware, that can't be done

[06:41] <Darren_Duncan> SQLite has built-in sequences of a sort

[06:41] <Alias_> no it does

[06:41] <Alias_> doesn't

[06:41] <Alias_> It has post-insert ids

[06:41] <Alias_> Which are the ugliest hack MySQL ever did

[06:42] <Darren_Duncan> if you define an integer primary key and don't give it an explicit value, it will be set from a sequence automatically

[06:42] <Darren_Duncan> in SQLite

[06:42] <Alias_> No it doesn't

[06:42] <Alias_> It uses default max(id) + 1

[06:42] <Alias_> A sequence is something you can pull a number from, so that you can set the id BEFORE you INSERT

[06:43] <Darren_Duncan> I'll have to look that up ...

[06:43] <Alias_> auto_increment is merely one use for sequences

[06:43] <Alias_> For example...

[06:43] <Darren_Duncan> I think the behaviour changed between 2.x and 3.x

[06:43] <Alias_> Say I have three records that point to each other in a circular relation

[06:43] <Alias_> a -> b, b -> c, c -> d

[06:43] <Alias_> er...

[06:43] <Alias_> c -> a

[06:44] <Alias_> With sequences, you can pull three ids, set the values appropriate, disable constraints, insert the three, then enable constratints again

[06:44] <Alias_> assuming "not null" and "references"

[06:44] <Darren_Duncan> does a standard relational database model let you have circular references?

[06:44] <Alias_> of course it does

[06:45] <Alias_> update table set value = id;

[06:45] <Alias_> self-referential, the lot

[06:45] <Darren_Duncan> in any event, I'm focusing early on in using features a database supports natively, and being light on the emulation ... I can do heavier emulation work later

[06:45] <Alias_> DBIx::MySQLSequence

[06:46] <Darren_Duncan> corresponding to this, early on I recommend using the newest versions of various products

[06:46] <Alias_> So Rosetta doesn't support "select sequence.nextval"

[06:46] <Darren_Duncan> the main goal of Rosetta is that everything looks the same to the user regardless of how it's implemented

[06:46] <Alias_> ?

[06:46] <Alias_> right

[06:47] <Alias_> And are you saying that Rosetta doesn't support sequences

[06:47] <Darren_Duncan> Alias_ ; Rosetta does support what you mention

[06:47] <Alias_> how does it work in SQLite?

[06:47] <Darren_Duncan> to clarify, I mainly focus on being able to define what I want, and worry on implementation as a separate problem

[06:48] <Darren_Duncan> Rosetta lets you define the sequence.nextval right now

[06:48] <Alias_> But you have a SQLite backend working right now?

[06:48] <Darren_Duncan> note that the syntax you give is Oracle specific ...

[06:48] <Alias_> Darren_Duncan, sure it's oracle specific... if you have an equivalent I mean that too :)

[06:48] <Darren_Duncan> no back ends are wroking now, I'm still building the thing

[06:48] <Alias_> oh ok

[06:49] <Alias_> Sorry if I sound narcy. It's just that sequences are both one of my pet peeves, and extroidinarily valuable and important to me database implementation

[06:49] <Darren_Duncan> the ANSI standard says "select next value from mysequence" or something like that

[06:49] <Alias_> s/me/my/

[06:49] <Darren_Duncan> looking ...

[06:49] <Alias_> As long as Rosetta can support "can retrieve a value from a sequence without it being a part of some other insert statement"

[06:50] <Alias_> In my terms, it's AppSpace::DB::Sequence->new('sequence_name')->next_val

[06:50] <Darren_Duncan> fyi, look at http://search.cpan.org/src/DUNCAND/SQL-Routine-SQLBuilder-0.18/lib/SQL/Routine/SQLBuilder.pm ...

[06:50] <Darren_Duncan> under the function build_expr_seq_next()

[06:51] <Darren_Duncan> that function generates both ANSI syntax and Oracle syntax

[06:52] <Darren_Duncan> ANSI is 'NEXT VALUE FOR my_sequence'

[06:53] <Darren_Duncan> see also build_schema_sequence_create() that generates a CREATE SEQUENCE statement with all/most the options in the SQL:2003 spec

[06:55] <Darren_Duncan> Rosetta lets you read from a sequence nearly anywhere; eg, in a SELECT, I/U/D, and in a CREATE TABLE ... DEFAULT NEXT VALUE FOR my_sequence

[06:56] <Alias_> right. That's fine

[06:56] <Alias_> It's just that there are two underlying methods of generating row ids

[06:56] <Alias_> One is a sequence for which you can fetch the id early if you need to, before the insert

[06:56] <Darren_Duncan> now, the SQL generator only helps here when the database natively supports sequences

[06:56] <Alias_> The other is to blind-insert the rows, and ask the server what id it used after the event

[06:57] <Darren_Duncan> when it doesn't, that'll be trickier

[06:57] <Alias_> And the latter is very very nasty, because there's a number of situation in which it screws up things.

[06:57] <Alias_> And there's a number of algorithms you simply can't do at all without the ability to get the ids first

[06:57] <Darren_Duncan> don't transactions and locking help with that?

[06:58] <Alias_> That previous case of the circular relationship is an example

[06:58] <Alias_> a trivial one

[06:58] <Alias_> if you have ids before the insert, you just pull a bunch and insert as normal

[06:58] <Darren_Duncan> I'd probably do it that way

[06:58] <Alias_> Without them, you have to actually know the structure of the data and insert everything in a very specific order

[06:59] <Alias_> So that you don't break anything

[06:59] <Alias_> Now imagine an "arbitrarily complex schema"

[06:59] <Alias_> Where you don't know the schema structure in advance

[06:59] <Alias_> For example.

[06:59] <Darren_Duncan> can one not just scan the database?

[07:00] <Alias_> Can you imagine how complex the algorithm for doing the link traversal and ordering would be

[07:00] <Darren_Duncan> doing it within a transaction should keep it reliable

[07:00] <Alias_> It's both NP-complete, and nasty

[07:00] <Alias_> And you have to violate not-null constraints

[07:00] <Alias_> I have an algorithm that lets you take the contents of one database, and dump it into another database with the same schema

[07:00] <Darren_Duncan> yes

[07:01] <Alias_> And the ids of the data will NEVER clash

[07:01] <Alias_> No matter how complex the data is

[07:01] <Darren_Duncan> why should they if they didn't clash in the original db?

[07:01] <Alias_> Because the existing data in the other database is using the same ids

[07:01] <Darren_Duncan> ah, so the target db wasn't empty first

[07:01] <Alias_> right

[07:02] <Darren_Duncan> that's not a pure copy then

[07:02] <Alias_> sure it is

[07:02] <Darren_Duncan> because you potentially changed the data

[07:02] <Alias_> no I didn't

[07:02] <Darren_Duncan> an id is part of the data, isn't it?

[07:02] <Alias_> nope

[07:02] <Alias_> It's metadata

[07:02] <Darren_Duncan> fine

[07:02] <Darren_Duncan> I was speaking broadly

[07:02] <Alias_> unless you use it outside of the system

[07:02] <Alias_> in the general sense yes

[07:02] <Alias_> But this you can also do things like cloning data

[07:03] <Alias_> this means

[07:03] <Darren_Duncan> but I do agree that primary keys should never be descriptive or meaningful, simply distinct

[07:03] <Alias_> Take a "user" in a database, with all it's setting and preferences and data, and make another one the same

[07:03] <Alias_> No matter how complex the schema

[07:04] <Alias_> In a post-insert id scenario, the code to do this is case-specific

[07:04] <Alias_> schema-specific rather

[07:04] <Darren_Duncan> how expensive is it to always read the ids pre-insert?

[07:04] <Alias_> Well, under Oracle it caches

[07:04] <Alias_> The client actually fetches 20 at a time

[07:05] <Alias_> which is one statement on the server

[07:05] <Darren_Duncan> then your app can keep a map of old-to-new and just translate as it copies data over with a plain lookup

[07:05] <Alias_> update sequences set currval = currval + 20;

[07:05] <Alias_> right

[07:05] <Alias_> You build the id mapping in advance, and then just do a plain copy in any order you like

[07:05] <Darren_Duncan> sure

[07:05] <Alias_> You turn off reference constraints in the transaction

[07:06] <Alias_> But you can't do that if you only get the ids AFTER you insert :)

[07:06] <Darren_Duncan> probably better actually, when dealing with circular data

[07:06] <QtPlatypus> BTW is there any diffrence between the enviroment that :e runs in and the pugs command line?

[07:06] <Alias_> And _that_ is the big problem with MySQL

[07:06] <Alias_> MySQL has no way to get ids before you insert

[07:06] <Darren_Duncan> FYI, Rosetta is actually geared towards use with more powerful databases ...

[07:06] <Alias_> I noticed :)

[07:06] <Alias_> And I'm glad

[07:07] <Darren_Duncan> its main help is when each db does things in different ways

[07:07] <Alias_> SQLite is a bitch though

[07:07] <Alias_> which is a pitty

[07:07] <Darren_Duncan> since many powerful features start off as proprietary extensions

[07:07] <Alias_> The big problem with sequences for SQLite, is that sequence operations MUST happen outside of transactions

[07:07] <Darren_Duncan> I really like SQLite

[07:07] <Alias_> They are ALWAYS global

[07:07] <Alias_> and immediate

[07:08] <Alias_> With SQLite, transactions are simple file locks

[07:08] <Darren_Duncan> that said, in my own apps I never really use sequences anywhere except to generate primary keys

[07:08] <Darren_Duncan> so it doesn't bother me

[07:08] <Alias_> So if you tried to pull a sequence (even emulated) from inside a transaction, you get a dependency lock

[07:08] <Darren_Duncan> how do you get a dependency lock?

[07:09] <Alias_> You can't update the sequence number because you are in a transaction, and you need to update the sequence number to get data for inside the transaction

[07:09] <Darren_Duncan> FYI, I'm on the sqlite ml and have been looking at it closely

[07:09] <Alias_> Because (I _think_) SQLite does transaction locks based on locking the file?

[07:09] <Darren_Duncan> I don't know why doing anything with sequences would require it to be done outside a transaction

[07:10] <Alias_> Imagine you have two transactions

[07:10] <Darren_Duncan> a sequence is conceptually like a one-row, one-col table

[07:10] <Alias_> And they both want a sequence number

[07:10] <Darren_Duncan> and you keep updating its value

[07:10] <Alias_> The sequence must ALWAYS hand out a number that is unique

[07:10] <Darren_Duncan> yes

[07:11] <Alias_> Let me put it this way

[07:11] <Darren_Duncan> so, at worst one transaction would block until the other completes ... thats not a deadlock

[07:11] <Alias_> Having issued number 123, it should never ever rollback

[07:11] <Alias_> What if I need that id in the transaction

[07:12] <Alias_> the one we have to wait to complete until the sequence alteration can proceed

[07:12] <Alias_> transaction waits to get a sequence number, sequence waits for the transaction

[07:12] <Alias_> deadlock

[07:12] <wilx> Huh?

[07:12] <Darren_Duncan> FYI, assuming I can get to OSCON this year, one of my tutorials is the inner workings of SQLite by its creator

[07:12] <Alias_> really?

[07:13] <Alias_> Anyways

[07:13] <Darren_Duncan> since a sequence read would alter the sequence, I would expect it to block there before returning a sequence value

[07:13] <Alias_> right

[07:13] <wilx> Hmm, imho nobody says that you have to be able to rollback the sequence with the transaction that you use...

[07:13] <Alias_> and the thing you are blocking to wait for is what needs the sequence

[07:14] <Alias_> hmm?

[07:14] <Alias_> sequences don't rollback

[07:14] <crysflame> Alias: does threatnet run under pugs?

[07:14] <Alias_> it's their fundamental properly

[07:14] <Alias_> In fact, strictly speaking sequences don't have to issue ids in order either

[07:14] <wilx> Yup, so why should the sequence get wait for anything?

[07:14] <Alias_> They simply MUST be globally unique

[07:14] <Darren_Duncan> as I recall, sequences simply have to dish out unique values

[07:15] <Darren_Duncan> Alias_, part of a sequence definition will say whether being in order is mandatory or not

[07:15] <Alias_> wilx: Because under SQLite, a transactions are done using file locking

[07:15] <Alias_> It's a SQLite-specific issue

[07:15] <wilx> Oh.

[07:15] <wilx> I see.

[07:15] <Alias_> DBIx::MySQLSequence works really really well

[07:15] <Darren_Duncan> or actually, I think the 'ORDER' / 'NO ORDER' attribute isn't in SQL:2003, but Oracle

[07:15] <Alias_> It's only under SQLite that it becomes a problem

[07:15] <Alias_> crysflame: I have no idea :)

[07:16] <Alias_> Does POE work under pugs?

[07:16] <Darren_Duncan> anyway, love to chat but I have to get to bed now

[07:16] <crysflame> does the actual value of the id matter outside of a specific time window?

[07:16] <crysflame> if not, then you can guarantee that the id won't conflict for the duration

[07:16] <Alias_> crysflame: Because I might be using that id somewhere else for a while, and then want to insert it later

[07:16] <crysflame> and then change it when done if it's a duplicate

[07:16] <Darren_Duncan> lets talk more later when I have something implemented and we want to get it working for whatever your needs are

[07:16] <crysflame> so promise to remember the search for the record instead

[07:16] <Alias_> the what?

[07:16] <Alias_> what record

[07:17] <crysflame> hmmm

[07:17] <crysflame> you're linking to a specific row number by the autonumber row

[07:17] <Darren_Duncan> remind me though, because I may not remember it was you specifically that was interested in sequences

[07:18] <Alias_> crysflame: What row...

[07:18] <Alias_> it might not exist yet

[07:18] <Darren_Duncan> good night

[07:18] <Alias_> the database gave my an id to use at any time in the future I wish

[07:18] <Alias_> me

[07:18] <crysflame> are you storing it outside of perl?

[07:18] <Alias_> quite possibly

[07:18] <Alias_> I might give it to some other process/company to remember me by later

[07:19] <crysflame> so i think that when you write to the database if the id you got is already taken and you're saying 'new record' then it should say "ok but here's the id i used instead, update your side and we're good"

[07:19] <Alias_> update my side?

[07:19] <Alias_> I had that id sent to a printer to permanently log something

[07:19] <crysflame> when you're creating the object, you can adjust it before you return the new object.

[07:19] <Alias_> and it was sent by email to my grandmother so she could type in a URL to get my e-card

[07:20] <crysflame> you should have adjusted it based on the autonumber returned from mysql

[07:20] <crysflame> by that point

[07:20] <Alias_> I should alter the paper printout and the email that was sent to my grandma

[07:20] <Alias_> I haven't inserted the record yet

[07:21] <Alias_> I don't know it's not usable yet. The sequence told me it was

[07:21] <crysflame> oh. you're depending on ids to be unique without cross-referencing against a central source

[07:21] <Alias_> the sequence is the central source

[07:21] <Alias_> That's what sequences do. That's all they do

[07:21] <Alias_> They issue unique numbers

[08:09] <QtPlatypus> perlbot: nopost

[08:10] <QtPlatypus> ?perlbot nopost

[08:13] <gaal> perlbot nopaste

[08:13] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[08:13] <QtPlatypus> Thanks Gaal

[08:16] <nothingmuch> it's also in the chat topic, btew

[08:24] <pasteling> "qtplatypus" at 202.7.69.25 pasted "Possable :e bug" (7 lines, 228B) at http://sial.org/pbot/10968

[08:25] <QtPlatypus> Could someone look at that and check that I'm not doing something obvicely wrong?

[08:26] <autrijus> QtPlatypus: nope, genuine bug

[08:26] <gaal> morning autrijus :)

[08:27] <autrijus> heya.

[08:27] <autrijus> ooh server's back

[08:27] <gaal> i've gotten all confused again with local, after i thought i'd tamed it :(

[08:27] * QtPlatypus nods ":e doesn't play well with postfix functions?"

[08:28] <QtPlatypus> Also I've noticed that Use module; Only works for the line that its on.

[08:28] <gaal> i want to simply build a finite callchain list, [ (Env, VCode) ]

[08:28] <gaal> but this expression gives a type error:

[08:28] <gaal> val <- local (const caller) (readVar "&?SUB")

[08:29] <gaal> it "expects []

[08:29] <gaal> for some reason.

[08:30] <gaal> i got this to work at some point  but i lost it:(

[08:31] <gaal> spelling that .... (return $ readVar "&?SUB") doesn't work either.

[08:38] <autrijus> yo

[08:38] <autrijus> [] is a monad

[08:38] <autrijus> if you used one <- too many then it's possible it will put [] around the expected type

[08:39] <gaal> so.... val = local ... ?

[08:40] <gaal> no that's a parse error. :(

[08:40] <autrijus> er.

[08:40] <autrijus> what do you expect val to be?

[08:41] <autrijus> val <- readVar "&?SUB"

[08:41] <gaal> the vcode sub.

[08:41] <autrijus> does it work?

[08:41] <autrijus> local() doesn't modify the type

[08:41] <gaal> well, i want it from the caller context.

[08:42] <autrijus> right, but still, first test the typechecker

[08:43] <gaal> !? it gives the same error!

[08:43] <autrijus> so there you go

[08:43] <autrijus> first fix that :)

[08:43] <pasteling> "gaal" at 192.115.25.249 pasted "callChain attempt" (9 lines, 405B) at http://sial.org/pbot/10969

[08:43] <gaal> :))

[08:45] <wilx> Huh.

[08:45] <wilx> Missing let?

[08:45] <gaal> but! the code that already is in svn does do val <- ...

[08:45] <gaal> wilx, nope, it's supposed to be <-

[08:45] <gaal> my paste error

[08:45] <gaal> and the code that's in svn works :)

[08:47] <nothingmuch> autrijus: nopasting 50% of chapter 8

[08:47] <nothingmuch> + new AST + new Eval (untested)

[08:48] <nothingmuch> Parsec will go

[08:48] <nothingmuch> List.words will stay

[08:48] <nothingmuch> (what a swell name, eh?)

[08:48] <pasteling> "nothingmuch" at 212.143.91.217 pasted "chapter 8" (67 lines, 2.5K) at http://sial.org/pbot/10970

[08:49] <pasteling> "nothingmuch" at 212.143.91.217 pasted "new eval" (104 lines, 2.7K) at http://sial.org/pbot/10971

[08:49] <nothingmuch> I'm really proud of the new evaluator code

[08:50] <gaal> (var :: Val) <- readVar "&?SUB" doesn't work either. this makes no sense

[08:51] <gaal> <- readVar is used all over the place

[09:01] <autrijus> oh wow!

[09:01] <autrijus> callChain :: Env -> [(Env, VCode)]

[09:01] <autrijus> you're in the wrong monad, sir

[09:01] <autrijus> callChain :: Env -> Eval [(Env, VCode)]

[09:01] <autrijus> is the way to go

[09:01] <autrijus> Env  -> [a]

[09:01] <autrijus> is in the list monad

[09:01] <autrijus> that yields a

[09:01] <autrijus> Env -> Eval [a]

[09:02] <autrijus> is in the Eval monad

[09:02] <autrijus> that yields [a]

[09:02] <autrijus> very different

[09:02] <gaal> aha!

[09:02] <gaal> okay: but then, how to i use the result of this computation like a pipe with filters?

[09:03] <gaal> is Eval [a] also a list?

[09:03] <gaal> so can i.... filter f callChain

[09:03] <gaal> or maybe i need something like

[09:03] <gaal> liftM filter f callChain

[09:03] <gaal> ?

[09:03] <autrijus> filterM.

[09:04] <autrijus> filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

[09:04] * gaal murk murk murks

[09:04] <autrijus> so something like

[09:04] <autrijus> filteredFoo <- filterM condM =<< callChain

[09:04] <autrijus> condM being something that is

[09:04] <autrijus> (Env, VCode) -> Eval Bool

[09:04] <autrijus> if you don't need Eval in the cond

[09:05] <autrijus> then

[09:05] <autrijus> filteredFoo <- fmap (filter cond) callChain

[09:05] <autrijus> will do.

[09:09] <chip> autrijus!  are you locked in again?

[09:17] <gaal> taking a break...

[09:20] <nothingmuch> seen ingy

[09:20] <jabbot> nothingmuch: ingy was seen 3 days 1 hours 42 minutes 35 seconds ago

[09:21] <nothingmuch> damn

[09:21] <nothingmuch> anybody know how to convert kwid to x without resorting to spork?

[09:21] <autrijus> nothingmuch: wonderful work

[09:22] <autrijus> nothingmuch: why not just make doExp of Prim "id" ?

[09:22] <nothingmuch> any suggestions for the evaluator code?

[09:22] <autrijus> why duplicate two interpret?

[09:22] <nothingmuch> Prim "id"?

[09:22] <autrijus> doExp (Prim prim) = prim

[09:23] <nothingmuch> oh

[09:24] <nothingmuch> puuurdy

[09:24] <nothingmuch> because I did interpret on Prims before i remembered . and .s were Eval monadic

[09:24] <nothingmuch> so they were initially pure

[09:24] <nothingmuch> and it looked like this:

[09:24] <nothingmuch> interpret ((Prim f):exps) = funInterpret f exps

[09:24] <nothingmuch> which I thought was really cool

[09:26] <nothingmuch> hola lightstep

[09:26] <nothingmuch> backlog to nopaste, i think you might like it

[09:28] <autrijus> nothingmuch: so.

[09:28] <autrijus> nothingmuch: I'll work on AST for PIR

[09:28] <autrijus> today

[09:29] <autrijus> and then use harrorth to do the metacomputational monad thing

[09:29] <autrijus> targetting PAST

[09:29] <autrijus> or rather PugsAST

[09:29] <autrijus> which is a way to say we compile forth to perl6

[09:29] <autrijus> then compile perl6 to pir

[09:30] <integral> this "metacomputational monad" is for generating bytecode, or is it for generating bits of bytecode for an embedded interpreter?

[09:30] <autrijus> that's my plan at least

[09:30] <nothingmuch> not yet!

[09:30] <nothingmuch> i think i'm not up to it

[09:30] <autrijus> integral: it's about separating compile time computation

[09:30] <autrijus> integral: with runtime computation

[09:30] <integral> hmm

[09:30] <autrijus> integral: by having the Compiler monad yield something else that can be run in the Runtime monad

[09:30] <lightstep> nitpick: you have bad syntax on the `data Exp' declaration (it should be Prim Prim instead of Prim)

[09:31] <autrijus> integral: the yielding itself is polymorphic over the underlying Runtime

[09:31] <nothingmuch> lightstep: right

[09:31] <integral> autrijus: hmm, so Compiler is a monad transformer applied to Runtime?

[09:31] <autrijus> compile :: ParseTree -> Compile (Runtime Val)

[09:31] <autrijus> interpret :: Runtime Val -> Eval Val

[09:32] <integral> hmm, but Runtime is a monad?

[09:32] <autrijus> yes.

[09:32] <lightstep> this type means that `compile' compiles to a runnable thing

[09:32] <autrijus> yes.

[09:33] <lightstep> (a -> Compile b) means "compiles a to b"

[09:33] <autrijus> yes.

[09:33] <autrijus> that's the basic idea.

[09:33] <lightstep> that's why arrows are better

[09:33] <integral> hmm, but being a monad you have these bits of haskell code inbetween each bit of bytecode?

[09:33] * integral can see how you can do bytecode with arrows, but not monads

[09:33] <autrijus> integral: !. how do I do it with arrows?

[09:34] <autrijus> integral: btw, "Metacomputation-based Compiler Architecture".

[09:34] <autrijus> www.cse.ogi.edu/PacSoft/publications/2000/mpcfinal.pdf

[09:34] <integral> is that a paper?

[09:34] <autrijus> aye

[09:34] * integral goes to read

[09:35] <Nattfodd> hi

[09:35] <autrijus> hi nothingmuch 

[09:35] <autrijus> er.

[09:35] <Nattfodd> autrijus: I was in fpw and there was a question we forgot to ask you

[09:35] <autrijus> hi Nattfodd

[09:35] <lightstep> nothingmuch, i really really do think that using Reader complicates your code

[09:35] <nothingmuch> hi autrijus ;-)

[09:36] <lightstep> but that's just me, it might be wrong

[09:36] <nothingmuch> lightstep: i'll deal with it soon

[09:36] <Nattfodd> autrijus: you said that you had a working interpreter in 6 days

[09:36] <Nattfodd> did you rest on the seventh ?

[09:36] <nothingmuch> i like it's elegance now, and the fact i'm grokking it

[09:36] <lightstep> since being a Reader adds capabilities, but i don't see why they're needed. and you seem to treat it like State anyway

[09:37] <autrijus> Nattfodd: " As a mere mortal, on Day 7 I did not rest. Instead I worked out the Scalar/List context propagation rule"

[09:37] <nothingmuch> what I'm afraid of is that I will get lost in the details of state vs. reader, etc etc etc

[09:37] <nothingmuch> i would rather work on getting actual forth working

[09:37] <autrijus> # http://use.perl.org/~autrijus/journal/23074

[09:37] <nothingmuch> and then go back and refactor

[09:37] <autrijus> lightstep: I thought Reader is a restricted State!

[09:37] <nothingmuch> instead of the opposite order

[09:38] <Nattfodd> hum

[09:38] <lightstep> autrijus, it is. that's why the guarentees are stronger

[09:38] <autrijus> lightstep: anyway, I found Reader much less error prone

[09:38] <lightstep> aka more capabilities (like not allowing side effects allows you to invent STM(

[09:39] <autrijus> for my own code (which is why I suggested it to nothingmuch)

[09:39] <autrijus> since you had to use IORef for mutable storage

[09:39] <autrijus> instead of being deluded into thinking that the State is somehow IORef

[09:39] <autrijus> but maybe it's just me :)

[09:40] <autrijus> (I agree that State is far easier to understand and use.)

[09:40] <lightstep> when using `local' only on the last action in a monadic block, and using it on all the last actions in monadic blocks, you're emulating state

[09:41] <autrijus> lightstep: right, but I did not know that forth has no lexicalness

[09:41] <autrijus> (and I'm still not sure it does not)

[09:41] <lightstep> reader is for dynamic scope

[09:42] <lumi> I think it does

[09:42] <autrijus> lightstep: oh?

[09:42] <autrijus> lightstep: local (\e -> { envLexical = newLex }) ...

[09:42] <nothingmuch> type Prim = \x -> x does not parse

[09:42] <autrijus> is how pugs does lexical scope

[09:42] <nothingmuch> what did I mean?

[09:42] <lightstep> which is incidentally the way you pass an environment reference in a lexically scoped language

[09:42] <autrijus> nothingmuch: type Prim = (a -> a)

[09:42] <autrijus> type Prim = (a -> Eval a)

[09:42] <lightstep> nothingmuch, throw the \

[09:42] <autrijus> one of the two

[09:42] <nothingmuch> oh

[09:42] <nothingmuch> right

[09:42] <Aankhen``> Argh.

[09:42] <autrijus> lightstep: ah. right. understood.

[09:43] <Aankhen``> Remind me to use `svn commit -N`.

[09:43] <autrijus> Aankhen``: use `svn commit -N`!

[09:43] <Aankhen``> Oh right!  That's what I needed to do!

[09:43] <Aankhen``> Thanks. :-D

[09:44] <nothingmuch> bah

[09:44] <lightstep> nothingmuch, i also suspect a primitive isn't a general polymorphic transformation, but an interpreter action

[09:45] <lightstep> for example, prim "." = <some monadic block>

[09:45] <nothingmuch> you are correct

[09:45] <nothingmuch> right

[09:48] <Aankhen``> Strange...

[09:48] <Aankhen``> Makefile.PL appears to be capable of removing src\gen_prelude.exe, but it doesn't.

[09:51] <ingy> hola

[09:52] <Aankhen``> It's even in the generated Makefile...

[09:53] <integral> hmm, the paper seems to talk about "Code is generate via type-directed partial evaluation"

[09:54] <integral> I think that's the thing that's worrying me about the Dynam monad

[09:54] <Aankhen``> Hi iblech.

[09:54] <iblech> Hi

[09:55] <nothingmuch> can functions be in class Show?

[09:56] <integral> there's a bit of code that looks like this: (inAddr 0 C[[e]]) >>= \phi_c -> return (phi_c >>= \i -> updateSto([Acc => i]))

[09:57] <svnbot6> r4544, iblech++ | Macros.

[09:57] <svnbot6> r4544, iblech++ | * t/macros/          -- unSKIP and more tests

[09:57] <svnbot6> r4544, iblech++ | * Pugs.Eval.Var      -- New module containing findVar & co.

[09:57] <svnbot6> r4544, iblech++ | * Pugs.Prim.Param    -- New module containing foldParam

[09:57] <svnbot6> r4544, iblech++ | * Pugs.Prim, Pugs.AST.Internals, Pugs.Eval, Pugs.Prim.List --

[09:57] <svnbot6> r4544, iblech++ |   Moved several functions to new Pugs.Eval.Var, Pugs.Prim.Param, and

[09:57] <svnbot6> r4544, iblech++ |   Pugs.Prim.List.

[09:57] <svnbot6> r4544, iblech++ | * Pugs.Parser        -- Various calls to new fun possiblyApplyMacro.

[09:57] <svnbot6> r4544, iblech++ | * Pugs.Parser.Unsafe -- New fun possiblyApplyMacro.

[09:57] <svnbot6> r4545, Aankhen++ | * added pugs.exe to svn:ignore for /.

[09:57] <svnbot6> r4546, iblech++ | t/ -- open "foo", :w -> open("foo", :w) to work around "&:w not found" errors.

[09:57] <svnbot6> r4546, iblech++ | t/builtins/io/evalfile.t -- Fix test.

[09:57] <Aankhen``> :-o

[09:57] <xerox> O_O

[09:58] <Aankhen``> Bleh.

[09:58] <Aankhen``> Right when I'm at the end of my `nmake test`.

[09:59] <iblech> :D

[09:59] <Aankhen``> Ah well, I'll just recompile and not run the tests.

[10:01] <integral> inAddr 0 C[[e]] >>= \phi_c -> return (phi_c >>> updateSto Acc) -- removes that pesky i

[10:02] <integral> (that's the same when that arrow is the Kleisli arrow of Dynam,  but it doesn't have to be a Kleisli arrow, it can be something you can introspect (which you can't do with (->) in haskell))

[10:02] <svnbot6> r4547, iblech++ | svnbot.p6 -- Hack to keep svnbot from passing a negative number to svn log,

[10:02] <svnbot6> r4547, iblech++ | resulting in svn log not giving us the new log messages (this happened last

[10:02] <svnbot6> r4547, iblech++ | night).

[10:04] <integral> (that's not convincing)

[10:04] <svnbot6> r4548, iblech++ | * t/examples/examples.t -- Fix paths to examples.p6 after my move some days ago.

[10:04] <svnbot6> r4548, iblech++ | * examples/output/      -- Move expected outputs, too.

[10:07] <Aankhen``> Whoa.

[10:08] <Aankhen``> Quad-core processors from AMD in 2007...

[10:08] <autrijus> nothingmuch: yes

[10:09] <autrijus> nothingmuch: instance Show (a -> b) where show _ = "(->)"

[10:09] <autrijus> nothingmuch: or easier just import Text.Show.Function or something

[10:09] <nothingmuch> my god

[10:09] <nothingmuch> there's a library for everything

[10:15] * chip mumbles (* -> *) -> *

[10:16] <autrijus> chip: er. that's still a->b.

[10:16] <autrijus> b itself is a function 

[10:16] <autrijus> but that's fine

[10:16] <autrijus> everything is unary.

[10:16] <autrijus> (except for things that are nullary)

[10:17] <chip> isn't (*->*)->* the kind(right word?) of that Show?

[10:17] <chip> er, that show

[10:17] <autrijus> no

[10:17] <chip> darn

[10:17] <chip> OK

[10:17] <autrijus> instance Show (a -> (b -> c)) where ...

[10:17] <autrijus> is more like it

[10:17] <autrijus> the * -> * is used only for kinds

[10:18] <autrijus> not for types

[10:18] <autrijus> kinds are types of types.

[10:18] <chip> the only way out of Haskell is through it.

[10:19] * integral is now convinced that monads are ok for Compile/Dynam

[10:19] <svnbot6> r4549, iblech++ | * t/builtins/undef.t -- undef() -> undef (there's no undef() function any more).

[10:19] <svnbot6> r4549, iblech++ | * t/ -- open(">...") -> open("...", :w)

[10:19] <autrijus> integral: good :)

[10:19] <autrijus> paper++ # saves me much much typing

[10:19] <integral> I'm just not convinced that that paper is brilliant :-)  (Because it uses partial evaluation)

[10:19] <autrijus> right. but the idea itself is sound

[10:20] <autrijus> i.e. composable (meta)reduction rules as monad transformer blocks

[10:20] <integral> yep.   You just need to have things of type Dynam Reg rather than Dynam Int like the paper suggests I think

[10:20] <autrijus> yup.

[10:20] <autrijus> exactly.

[10:21] * integral was thrown by thinking w/ arrows you could get away with Int,  but you still have that pesky arr function

[10:21] <lightstep> it can be hidden with ^>> and >>^

[10:22] <integral> >>^?

[10:22] <lightstep> a >>^ b = a >>> arr b

[10:22] <autrijus> ew.

[10:22] * autrijus is strongly reminded of nethack

[10:23] <integral> lightstep: but that's still got the problem arr has:

[10:23] <xerox> lightstep, is arr really needed?

[10:23] <integral> if you have a b Int, and that Int is produced by the dynamic code, you're still embedding a haskell function in the bytecode

[10:24] * integral thinks yes: (x &&& y) >>> arr (\(a,b) -> (b,a))

[10:25] <lightstep> you're interpreting. one way to do it is to replace bytecode by haskell code and run

[10:25] <lightstep> xerox, it is

[10:26] <lightstep> xerox, arrows are like dataflow. there is a thread of data that passes every time you use (>>>). (***) and (+++) split it and remerge. all the other manipulation is doen with arr

[10:27] <integral> (/me needs to make himself remember that arrows are for capturing data flow, not hiding the values flowing through them)

[10:36] <svnbot6> r4550, iblech++ | strings/ord.t -- Refactored all the is(...) calls into a @maps array and added

[10:36] <svnbot6> r4550, iblech++ | some more tests.

[10:36] <svnbot6> r4551, iblech++ | coro.t -- Fix test, 100% ok now.

[10:51] <svnbot6> r4552, autrijus++ | * add UnicodeC.h in Pugs.Eval.Var to avoid warnings.

[10:52] <nothingmuch> wow! my eval code actually works

[10:53] <QtPlatypus> nothingmuch: Congrats.

[10:54] <nothingmuch> it's very brain zonking

[11:04] <nothingmuch> autrijus: help - i have type Reduction = Eval (Interp -> Interp)

[11:04] <nothingmuch> and Prim Reduction is the type of a Prim

[11:04] <nothingmuch> except I want it to be polymorphic

[11:05] <nothingmuch> Eval (a -> a)

[11:10] <jrieks> nothingmuch: autrijus is gone to take some more sleep

[11:10] <svnbot6> r4553, iblech++ | io_redirect_to_scalar.t -- skip_all -> skip_rest

[11:11] <nothingmuch> jrieks: thanks

[11:11] <gaal> there's a bug (i think) in autogenerated accessors via "has"

[11:11] <gaal> it's a little involved though, i'll nopaste.

[11:13] <pasteling> "gaal" at 192.115.25.249 pasted ""has" / intermediate obj problem" (23 lines, 291B) at http://sial.org/pbot/10972

[11:14] <gaal> also: when you don't use a factory, this doesn'

[11:14] <gaal> t happen.

[11:14] <spinclad> autrijus: hw2005, s.7.1: "conditionals and other a statement constructs that does not act":

[11:14] <spinclad> autrijus:  s/ a / /, s/does/do/

[11:15] <gaal> also also, putting an intermediate var inside the factory doesn't help either. is this a context problem?

[11:16] <nothingmuch> spinclad: you can edit the file

[11:16] <spinclad> (nits from latest sections)

[11:17] <spinclad> nothingmuch, thanks, I'll try that

[11:23] <gaal> how do i find the label of a block? (i'm not in the parser)

[11:30] <chip> autrijus just yesterday told me that the full name of multi sub add(Foo a, Foo b) is &add<Foo,Foo>, but in the p6l summary I see it's &add:(Foo,Foo)

[11:30] <chip> welcome to Perl 6, I guess

[11:45] <gaal> beh, the 'has' thing looks like a real bug

[11:46] <gaal> and is blocking caller.

[11:51] <lightstep> nothingmuch, a reduction is a computation that returns a meta-function? and a primitive is an infinite descent of types?

[11:52] <nothingmuch> a primitive is an expression that is just a lambda whose type is Reduction

[11:52] <nothingmuch> but i can't think about that anymore

[11:52] <nothingmuch> i need a bit of a break

[12:03] <svnbot6> r4554, gaal++ | spelling fixes

[12:17] <pasteling> "iblech" at 80.81.23.181 pasted "gaal: Patch for gen().x" (24 lines, 835B) at http://sial.org/pbot/10973

[12:18] <gaal> thanks :) i was just working around the problem in my test code

[12:20] <gaal> Arbeitskopie sounds like an unpleasant surgical procedure. (i know what it really means)

[12:56] * gaal whews.

[13:05] <svnbot6> r4555, gaal++ | bring caller up to spec; tests. still missing: "label", misc details

[13:35] <gaal> juerd about?

[13:50] <QtPlatypus> How much work would it be to implement strictness and warnings?

[13:52] <gaal> strictness is on by default

[13:52] <gaal> don't know about warnings.

[13:53] <gaal> in fact, there's no way to turn off strictures atm :)

[13:53] <integral> perl6 *is* strict, something which perl5 IMHO should be

[13:55] <chip> integral: you miss the psychological lift we get from typing C<use strict>

[13:55] * QtPlatypus nods "I'll try and replicate some of the situations where I think should have warned or died of strictness."

[13:56] <gaal> why, one liners of course.

[13:57] <QtPlatypus> The type system seems to be mostly a place holder.

[13:57] * gaal is sure to keep a copy of perl5 around for one-liners if p6 doesn't have a convenient 'use loose'.

[13:57] <QtPlatypus> Excluding MMD.

[13:57] <integral> the type system is *weird* imho :-)   Particulary the type variables

[13:57] <nothingmuch> wow, what an amazing creature: http://en.wikipedia.org/wiki/Antarctic_krill

[13:57] <gaal> hah! i read that article a few weeks ago too

[13:58] <gaal> got to it by random wikilinkage. how'd you get there?

[13:58] <gaal> it's a very nice article, too. :)

[13:58] <QtPlatypus> integral: How do you find the type system weird

[13:58] <nothingmuch> uh, let me think one second

[13:58] <nothingmuch> ah,

[13:59] <nothingmuch> i looked up WRT to make sure I knew what it meant

[13:59] <nothingmuch> so i got to the acronyms starting with W page

[13:59] <nothingmuch> there I found out that wtf is a... one sec

[13:59] <nothingmuch> http://en.wikipedia.org/wiki/Euphemism

[14:00] <nothingmuch> discussion on euphemisms regarding death ensued, at which point I wound up on the Dead Parrot Sketch entry

[14:00] <integral> QtPlatypus: well I can understand specifying the IType of things, and specifying primitive types,  and specifying that values in a variable must do certain roles

[14:00] <gaal> i think i followed the wikisource logo, which is an iceberg image, and from there to floe, etc.

[14:00] <integral> But then I don't really get how types are used for coercion and matching in signatures

[14:00] <nothingmuch> now, how did I get from there.... one sec

[14:01] <nothingmuch> oh!, i clicked on the Cockatoo link on the bottomm

[14:01] <nothingmuch> from there to the parrot list -> blue & yellow mackaw -> pets -> glofish -> glow genes

[14:02] <nothingmuch> eventually http://en.wikipedia.org/wiki/Bioluminescence

[14:02] <nothingmuch> where the krill is depicted

[14:02] <nothingmuch> only 15 more browser tabs to read through

[14:02] <gaal> you know, nothinmuch, i'm glad i implemented caller. :-p

[14:02] <QtPlatypus> integral: I get the way the signature matching works.  Though I'm not sure how it works with co-ersion.  I ran into an error from that today.

[14:02] <nothingmuch> =D

[14:03] <nothingmuch> the problem is that browsing in general is like one big tail call optimization

[14:03] <nothingmuch> and tabbed browsing is like continuations

[14:03] <nothingmuch> i would like a browsing metaphor with call stacks and autothreading

[14:03] <integral> that's a very good description nothingmuch :-)

[14:03] * QtPlatypus laughs.

[14:04] <gaal> all firefox users: be sure to install the Session Saver extension. (as i periodically urge)

[14:05] <wilx> Hmm.

[14:06] <gaal> wilx, integral, other haskellheads - i'd appreciate it if you reviewed my caller patch, which i'm not sure is the prettiest of haskell code (r4555)

[14:07] <wilx> Hehe, you think to high of me :)

[14:07] <wilx> I am nowhere near the level of people like autrijus or other Pugs developers. I just hang around here :)

[14:08] <gaal> well, if you do have some input, i'd appreciate it even if yo do just hand around here ;-)

[14:08] <integral> the same of me :)

[14:08] <nothingmuch> gaal: i'll take a look soon, if i my head clears up

[14:09] * integral only plays a haskellhead on irc :-P

[14:09] <gaal> i am currently basking in unhaskelled clearheadedness. so take your time. :-)

[14:10] <integral> well you appear to have deleted lots of Haskell,  that's a good sign :-)

[14:13] <gaal> Carter's Compass, isn

[14:13] <gaal> 't that?

[14:15] <chip> that's the one that always points at Plains, GA

[14:15] <q[pdcawley]> chip: I just replied to your message about the register allocator and continuations. 

[14:16] <q[pdcawley]> I think you're confusing continuations with gotos.

[14:16] <chip> q[pdcawley]: I agree with you, except I'm not confused.

[14:17] <q[pdcawley]> Okay. So the problem becomes how to make continuations do the right thing?

[14:17] <q[pdcawley]> Or am I confused?

[14:17] <chip> If you can keep your head when all those about you are losing theirs, you obviously do not understand the situation.

[14:18] <q[pdcawley]> Heh.

[14:36] <svnbot6> r4556, iblech++ | strings/ord.t -- Test chr() too (we shouldn't duplicate @maps to two tests).

[14:36] <svnbot6> r4557, iblech++ | Remove chr.t and rename ord.t to ord_and_chr.t.

[14:47] <QtPlatypus> Is the object returned by caller documented somewhere?

[14:47] <svnbot6> r4558, iblech++ | Fixed t/subroutines/sub_named_params.t.

[14:48] <gaal> QTPlatypus, see src/perl6/Prelude.pm

[14:48] <gaal> for now

[14:48] <gaal> it's not finalized, unfortunately.

[14:48] * QtPlatypus nods

[15:00] <q[pdcawley]> chip: while I don't wish this descend into 'no, YOU are confused' madness, I'm I afraid I must take this moment to say "No, YOU are confused".

[15:02] <chip> q[pdcawley]: Look.  If you have to take this on faith, so be it.  But the basic issue is quite simple: Register allocation depends on understanding when you leave an area and will Never Go Back.  Continuations mean that every function call is a point to which you can potentially Go Back.  This b0rks register allocation.  And caller-saves has NOTHING to do with it.  Just imagine you're analyzing a machine where NO REGISTERS ARE CALLER-SAVES and the problem is sti

[15:04] <QtPlatypus> You get cut off at "thr problem is sti..."

[15:04] <chip> Just imagine you're analyzing a machine where NO REGISTERS ARE CALLER-SAVES and the problem is still there.

[15:04] <integral> The thing I don't get about parrot is how lexicals map to registers

[15:04] <chip> *sigh*

[15:04] <q[pdcawley]> integral. As you want them to.

[15:04] <integral> It seems in your example that you're mapping lexicals to registers without a pad?

[15:05] <chip> THE MAIL MESSAGE.  READ THE MAIL MESSAGE.

[15:05] <q[pdcawley]> You can write a lexical from/to any register. The $whatever things in the message ARE NOT LEXICALS>

[15:05] <chip> The message clearly says that I'm calling them $a and $b for pedagogical purposes, and that those variable names are NOT LEXICALS.

[15:05] <integral> right, I get that they're not lexicals

[15:05] <chip> Well, then, WTF?

[15:05] <integral> err, why is chip shouting at me?

[15:05] <q[pdcawley]> chip: So, you're arguing that register allocation should be at a more global level than per function?

[15:06] <chip> "<integral> It seems in your example that you're mapping lexicals to registers without a pad?"

[15:06] <q[pdcawley]> If so then, dammit, you're trying to do too much.

[15:06] * chip throws up his hands

[15:06] <integral> chip: right, and this is something I've seen quite often in parrot code

[15:06] <q[pdcawley]> If register allocation is restricted to being per function with caller saves then I really fail to see where there's a problem.

[15:06] <integral> What are the conditions where a HLL compiler can not have a entry in the lexical pad for a lexical and only use a register for it?

[15:07] <chip> integral: Please ask about this another time.  q[pdcawley] will think my answers apply to his question and nobody will be happy.

[15:07] <q[pdcawley]> And if you're trying to make it more global than that then something will *always* fuck it up.

[15:07] <chip> q[pdcawley]: "Bob" dammit, at which point did you think I was doing register allocation outside a single function?

[15:07] <chip> q[pdcawley]: Parrot is not.  It won't.  It literally can't.

[15:07] <q[pdcawley]> Because I'm buggered if I can see how continuations would break it in any other case.

[15:08] <chip> q[pdcawley]: Well, then, I suggest you invest in KY jelly, because I can't seem to rescue you.

[15:08] <q[pdcawley]> a continuation returns from a function. The fact that can return from function a to function b doesn't make a damned bit of difference from the point of view of the calling function.

[15:10] <chip> the return from the call to &foo does not restore the entire machine state.  continuations do not capture the entire register set.  perhaps you would like it if they did, and that's an interesting idea, but they don't.

[15:10] <q[pdcawley]> Yes, they restore the registers you care about.

[15:11] <chip> Actually, they don't.

[15:11] <chip> This is the key misunderstanding, apparently.

[15:11] <q[pdcawley]> They bloody well should do. Because they're just a return from a function. Which restores the registers you care about.

[15:11] <q[pdcawley]> Not the continuation, the code that runs *after* you take it. Because it's the same as the cleanup from the function return.

[15:11] <chip> Well, the register set being as large as it is, that could very well make continuations unacceptably expensive.

[15:12] <q[pdcawley]> Which is why you don't save the entire fucking register set in the first place. You only save the ones you care about.

[15:12] <chip> Remember, to understand the situation, you have to remember that we're talking about a hypothetical machine where there are no caller-saves registers.  It's P16 we're talking about, not P10.

[15:12] * integral notes that saving a register in the cont. and saving it in the pad have different semantics with multiple invocations

[15:12] <q[pdcawley]> You don't save the register, you save its value.

[15:13] <q[pdcawley]> And forget about the bloody pad.

[15:13] * chip didn't bring it up

[15:13] <q[pdcawley]> Sorry, aimed at integral.

[15:13] <integral> Why?

[15:13] <integral> Isn't the pad important because all the HLLs use it?

[15:14] <q[pdcawley]> Because it's got sod all to do with register allocation in this context.

[15:14] <chip> integral: please stay off my side

[15:15] <q[pdcawley]> Chip: I understand that you're arguing for this hypothetical thing, but continuations don't work without caller saves.

[15:15] <q[pdcawley]> Or they become monstrously more painful.

[15:16] <chip> I see.

[15:16] <q[pdcawley]> Sorry, monologuing.

[15:16] <chip> q[pdcawley]: Let me be clear on the terminology.

[15:17] <chip> q[pdcawley]: Parrot 0.2 has volatile and non-volatile registers, with regard to function calls.

[15:17] <q[pdcawley]> Even at the pasm level?

[15:17] <chip> q[pdcawley]: this is the architecture.  in my message, $a and $b are simply symbolic names for non-volatile registers.  Taking a continuation does not save them.

[15:18] <chip> q[pdcawley]: especially at the pasm level.  P0-15 are volatile - subroutine can trash them.  P16-31 are non-volatile - subroutine cannot trash them.

[15:18] <q[pdcawley]> Because if that's the architecture now, it's  abig change from the design.

[15:18] <q[pdcawley]> WTF?

[15:18] <chip> I'm describing the ACTUAL arch, not a change.

[15:18] <q[pdcawley]> When did that change

[15:18] <chip> This is the way things already are.

[15:18] <q[pdcawley]> Because as designed, everythings volatile but 16-31 are safe by convention.

[15:19] <q[pdcawley]> At the PS

[15:20] <q[pdcawley]> At the pasm level, to make a function call you should save everything you care about in P16-31, make the call, and restore everything after the return.

[15:20] <q[pdcawley]> If Parrot is doing that for you at the PASM level, then it's not working as Dan specced it, and no wonder there's a bloody problem.

[15:21] <q[pdcawley]> They should not be privileged at the machine level.

[15:21] <chip> I am experiencing a phenomenon in which I say I like sandwiches and I'm told that it's a bad idea to eat rocks.

[15:21] * chip wonders if he is silently being filtered through a double babelfish

[15:23] <q[pdcawley]> chip: Which is all very well to say, but doesn't exactly clarify anything.

[15:23] <chip> On the other hand, I appreciate that you've caused me to reevaluate the design decision on how continuations work.  It's possible that saving the non-volatile registers in the continuation data structure (P16-P31), and restoring them when the continuation is taken, will solve the problem.

[15:23] <svnbot6> r4559, iblech++ | while.t -- Add tests for "while ... -> $x {...}".

[15:23] <chip> The only question is whether this is the Right thing, or only Apparently Right But Actually Evil.

[15:24] <q[pdcawley]> chip: Talk to Dan. But from conversations I've had with him, I think that's how he intended things to work.

[15:24] <q[pdcawley]> My understanding is that continuations have never actually been implemented completely correctly in Parrot.

[15:25] <q[pdcawley]> If you have continuations, you have no stack. Anything you need to get back after you return from a function should be accessible from the continuations.

[15:27] *** wolv is now known as wolverian

[15:34] *** chip____ is now known as chip

[15:35] <chip> q[pdcawley]: I've pondered it, and there seems to be an unsolvable problem with the plan to save and restore registers: It is impossible to save and restore S and P registers.

[15:36] <chip> Leaving S aside, because the S problem is tractable if it were all we had to worry about, P is deadly.

[15:36] <q[pdcawley]> You save a pointer to the PMC, and then when you restore, you reset the register to point back to the same PMC. How is this impossible?

[15:36] <chip> Restoring a P register per se is just setting a pointer.  If the thing you're pointing at has changed state, you have failed to go back in time.

[15:36] <chip> The PMC has state and the state has changed.  You're not back to status quo ante.

[15:36] <q[pdcawley]> But you don't want to go back in time. If you can't cahnge the state of the PMCs then you end up in loops.

[15:37] <q[pdcawley]> That's the entire bloody point.

[15:37] <q[pdcawley]> Sorry. 

[15:37] <chip> No problem.

[15:38] <q[pdcawley]> Of course PMCs have state and that state changes. But that's fine. So long as you get the same PMC back, the fact that its state has changed is actually a good thing.

[15:38] *** gaal_ is now known as gaal

[15:38] <q[pdcawley]> Smae goes for the pad. You get back the same pad frame, but the things it points to may have changed, and again, that's fine.

[15:39] <q[pdcawley]> I'm not sure wehre it is in the parrot tree, but have you had a look at the implementation of 'choose' I posted a year or so back?

[15:39] <chip> Are you sure you're not going to overload me?  I'm stretching a bit now.

[15:40] <q[pdcawley]> Sorry. Continuations really mess with your head. Then you'll 'get' them and I'll be making sense.

[15:40] <integral> q[pdcawley]: can I ask a question?

[15:41] <q[pdcawley]> If you've got the time, the chapter on the explicit control machine in SICP, for all it barely mentions continuations, is excellent.

[15:41] <q[pdcawley]> integral: Sorry, didn't mean to monopolise, go ahead.

[15:42] <integral> In some highlevel code I've got { my int $a; },  so I've got a lexical $a, and for speed it can be manipulated in a I register, is that right so far?

[15:42] *** clkao_ is now known as clkao

[15:42] <q[pdcawley]> Yes.

[15:42] <integral> now over a function call, if I leave it in the I var in such a way it gets saved and restored,  it will always get the same value back when the continuation is invoked

[15:43] <q[pdcawley]> Yes. But how do you know the called function won't monkey with CALLER::MY?

[15:43] <integral> That's what I was going to ask :-)

[15:43] <chip> q[pdcawley]: playing with %MY:: voids your warranty.

[15:43] <q[pdcawley]> For safety you're going to have to write it back into the lexical before the function call.

[15:43] <integral> The different semantics between I-var saving over a cont, and lexical saving, means I always need to put values from variables back into the pad

[15:44] <integral> ok, so if I always need to put things back in the pad,  when is saving the registers useful?

[15:44] <q[pdcawley]> When the things in the register aren't HLL things.

[15:44] <chip> expand "HLL things"?

[15:44] <integral> hmm, I can't think of when that is?

[15:44] <q[pdcawley]> Or when they're pointer things.

[15:45] <q[pdcawley]> Well, if you've taken something out of a pad, created a new PMC that *isn't* in the pad, you need to save and restore it over the function call.

[15:45] <integral> hmm, but a pad entry for a PMC thingie could change which PMC is used, couldn't it?

[15:45] <chip> S and P registers are all pointer things.

[15:45] <chip> so I'm even more confused now.

[15:45] <svnbot6> r4560, sri++ | Fixed File::Find debug output

[15:45] <integral> oh, like intermediate values in $a = foo($b) + bar($c) + baz($d) ?

[15:45] <q[pdcawley]> Yeah.

[15:46] <integral> ok, that makes sense now :-)

[15:46] <q[pdcawley]> Also, there may not be a strong mapping between HLL functions and PASM functions.,

[15:46] <q[pdcawley]> You only need to worry about stashing lexicals when your PASM function is equivalent to an HLL function. I think.

[15:46] <integral> err, pasm doesn't have "functions" since it's all CPS...

[15:46] <autrijus> hm, like one HLL function may actually be 1,024 PASM functions?

[15:47] <chip> q[pdcawley]: What you're describing is a situation where no P register is usable across any HLL function call boundary.

[15:47] <q[pdcawley]> integral: Yeah, but we tend to think of them as functions.

[15:47] * integral personally goes "ewww" at that ;-)

[15:47] <q[pdcawley]> chip: Nope, only the value registers (I)

[15:48] <q[pdcawley]> I think.

[15:48] <q[pdcawley]> Caller::MY is really scary.

[15:48] <chip> q[pdcawley]: Like I said, voids the warranty.  Don't worry about it, ever.

[15:48] <integral> why is it scary?

[15:48] <q[pdcawley]> Then I don't think you need to worry about rewriting to the Pad before and after function calls.

[15:48] <integral> It can only be used in situations where everything's been written back to the pad from tempories surely?

[15:49] <q[pdcawley]> integral: Because you need to keep the state of the pad up to date at all times.

[15:49] <q[pdcawley]> integral: With pointer types, you tend not to have to worry.

[15:50] <chip> q[pdcawley]: you seem to be assuming that the only thing worth restoring in the P registers is shadowed copies of what's in %MY:: and other user-visible storage, or else you wouldn't be fixating on %MY:: so much.

[15:50] <chip> q[pdcawley]: it could be something as user-invisible as the result of a hoisted common subexpressin.

[15:51] <q[pdcawley]> chip: No. I'm assuming that if the P register shadows what's in %MY you might be find that the thing got *replaced* during a function call, so you can't assume that what you *thought* was a shadowed copy of %MY is still one after any function return.

[15:51] <q[pdcawley]> chip: The user invisible stuff still needs to get saved on the continuation.

[15:52] <q[pdcawley]> So if you have some register P1 that was initialised with the contents of a variable from the pad, then you probably need to write it back to and from the pad around any function call.

[15:52] <q[pdcawley]> Ignore that. Typing without enough thinking.

[15:52] <q[pdcawley]> Dunno the answer.

[15:54] <integral> so $a = foo($b) + bar($c) should translate to something like: P1 = lex_get("b"); P2 = make_cont(L1); call P2, foo(P1); L1: P1 = arg(0); P2 = lex_get("c"); P3 = make_cont(L2, saving => P1); call P3 bar(P2); L2: P2 = arg(0); P3 = add P1, P2; lex_save "a", P3 ?

[15:54] <q[pdcawley]> integral: I don't know. Need to think.

[15:55] <q[pdcawley]> Or chip does :)

[16:00] * autrijus is with leo and chip in the same room now

[16:00] <clkao> happy?

[16:00] <autrijus> sort of

[16:00] <autrijus> finally slept enough

[16:00] <clkao> blue-sugar-ed ?

[16:00] <nothingmuch> huraah

[16:00] <autrijus> to recover the clock speed

[16:00] <autrijus> so my agenda for tonight

[16:00] <autrijus> :

[16:01] <autrijus> fix chained comparison

[16:01] <autrijus> fix other showstoppers to Pugs release

[16:01] <autrijus> enter preflight

[16:01] <autrijus> may or may not have time to finish release tonight

[16:01] <autrijus> but that's okay

[16:01] <autrijus> so feel free to let me know which tests are important to you and must not be :todo<bug>'ed 

[16:01] <clkao> autrijus: there's something very weird when using GD--Perl5

[16:02] <clkao> i wrote something to combine map images

[16:02] *** AtnNn_ is now known as AtnNn

[16:03] <autrijus> ok?

[16:04] <clkao> somehow i have to do my $final = eval_perl5("GD::Image->new({ $want.w }/10, { $want.h }/10, 1)");

[16:08] <nothingmuch> seen gaal

[16:08] <jabbot> nothingmuch: gaal was seen 1 hours 19 minutes 57 seconds ago

[16:08] <svnbot6> r4561, iblech++ | * Pugs.Prim -- Made lvalue substr work.

[16:08] <svnbot6> r4561, iblech++ | * substr.t  -- unTODOed and unEVALed some tests and added new ones.

[16:13] <gaal> autrijus, there's the 'has'-accessor bug which would be nice if it were fixed, as without it caller is clunky to use.

[16:15] <QtPlatypus> How does the bug present itself (I'm trying to fiddel around with caller and I'm wondering if I'm getting effected by it)

[16:15] <gaal> Qt: you have to assign caller's return value to a temp var before using it.

[16:16] <gaal> ie caller.subname -> gives error

[16:16] <gaal> my $c = caller; $c.subname -> ok

[16:16] * QtPlatypus nods "Thats exactly the problem I'm having"

[16:16] <gaal> hmm, sorry i didn't spell it out earlier :-(

[16:17] <QtPlatypus> No problem gaal++ for explaining it to me.

[16:18] <gaal> btw, caller in list context should eventually work rather similarly to p5's caller -- but it's not there yet.

[16:18] <gaal> look at t/builtins/caller.t for things that do work

[16:19] <gaal> i hope the Sub / Method chain isn't too confusing - took me a while to figure out what Larry meant

[16:19] <q[pdcawley]> seen Juerd

[16:19] <jabbot> q[pdcawley]: Juerd was seen 2 days 19 hours 18 minutes 33 seconds ago

[16:20] <QtPlatypus> BTW what does "is safe" and "is primitive" do?

[16:20] <gaal> Qt: 'is safe' means you can call it in safe mode (see: lib/pugs/run.pod)

[16:21] * QtPlatypus nods.

[16:21] <gaal> 'is primitive' means (a) it runs from the perspective of the caller; (b) you can't use "return" in it and (c) some parrot magic which i don't know :)

[16:21] <gaal> both are not for general use.

[16:21] * QtPlatypus nods.

[16:30] <Aankhen``> ?eval class Foo { sub bar () { } }

[16:30] <evalbot6> undef 

[16:30] <Aankhen``> ?eval class Foo { sub bar () { 1 } }

[16:30] <evalbot6> undef 

[16:31] <Aankhen``> ?eval class Foo { sub bar () { 1 } }; Foo::bar();

[16:31] <evalbot6> 1 

[16:31] <Aankhen``> ?eval class Foo { sub bar () { 42 } }; Foo::bar();

[16:31] <evalbot6> 42 

[16:31] <Aankhen``> ?eval class Foo { sub bar () is export { 42 } }; Foo::bar();

[16:31] <evalbot6> 42 

[16:31] <Aankhen``> ?eval class Foo { sub bar () is export { 42 } }; use Foo; bar();

[16:31] <evalbot6> pugs: *** No compatible subroutine found: "&use"     at -e line 4, column 5-101 

[16:31] <Aankhen``> $#@!

[16:32] <gaal> eval class Foo { sub bar () is export { 42 } }; bar()

[16:32] <gaal> ?eval class Foo { sub bar () is export { 42 } }; bar()

[16:32] <evalbot6> 42 

[16:33] <gaal> A: you don't need to use.

[16:33] <Aankhen``> I see that now, heh.

[16:33] <Aankhen``> ?eval module Foo { sub foo () is export { 42 } }; foo();

[16:33] <evalbot6> 42 

[16:33] <Aankhen``> ?eval class Foo { method bar () is export { 42 } }; bar();

[16:33] <evalbot6> Error: No compatible subroutine found: "&bar" 

[16:34] <Aankhen``> ?eval class Foo { method bar () is export { 42 } }; bar(Foo);

[16:34] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected 

[16:34] <Aankhen``> ?eval class Foo { method bar () is export { 42 } }; bar(Foo: );

[16:34] <evalbot6> Error:  unexpected ":" or "b" expecting ";", statements or end of input Only one invocant allowed 

[16:34] <Aankhen``> ?eval class Foo { method bar () is export { 42 } }; Foo.bar();

[16:34] <evalbot6> 42 

[16:34] <Aankhen``> Aaand I'm back to square one.

[16:34] <Aankhen``> Ah well.

[16:34] <Aankhen``> It happens.

[16:35] <Aankhen``> pugs: *** Can't locate Foo.pm in @INC (@INC contains:

[16:35] <Aankhen``> Shouldn't that be @*INC now?

[16:35] <gaal> i agree that this looks like a bug, but do you *need* exported methods?

[16:36] <Aankhen``> gaal >> I was just messing around and wondering about how class methods interact with C<is export>. :-)

[16:36] <gaal> yes, it should. though @INC oughta work as well unless someone was being cute.

[16:36] <gaal> well, in p5 that's one way you can do mixins

[16:36] <iblech> Aankhen``: Right, it was just the error message which was wrong (fixed)

[16:36] <gaal> it's not useless, just... weird

[16:37] <Aankhen``> iblech >> Regarding methods with C<is export>?

[16:37] <iblech> Aankhen``: Regarding @*INC

[16:37] <Aankhen``> iblech >> Ah, okay.

[16:37] <gaal> iblech++; # speed demon

[16:37] <Aankhen``> iblech++

[16:38] <Aankhen``> gaal >> I figure exported methods might come in handy if they can act as either static or virtual methods -- you could offer both a functional and an object-oriented style of programming.

[16:38] <iblech> 7away

[16:38] <svnbot6> r4562, iblech++ | Pugs.Prim.Eval -- @INC -> @*INC, thanks to Aankhen``++ for noticing.

[16:38] <nothingmuch> Error: Error occured during annotate: error  

[16:38] <iblech> Err

[16:38] <Aankhen``> Programming?  What am I saying?

[16:38] <nothingmuch> very informative

[16:38] <Aankhen``> s/programming/using the module/

[16:38] <Aankhen``> ROTFLMAO nothingmuch.

[16:38] <nothingmuch> do the bots sum karma? i wonder what the collective karma of #perl6 is

[16:39] <Aankhen``> Although I think maybe you could achieve the same thing as I said above using C<.assuming>.

[16:39] <gaal> problem is you get very dirty namespaces if everybody exports.

[16:39] <Aankhen``> How so?

[16:39] <gaal> use A; use B; use C; use D;

[16:40] <gaal> they all defined methods

[16:40] <gaal> now you have lots of methods in your namespace.

[16:40] <Aankhen``> Yeah, but it's the same with regular modules in Pugs, atleast until C<is export> is fully implemented. :-)

[16:40] <gaal> ?

[16:41] <Aankhen``> If you have modules A, B, C and D with lots of exported subs, and use them all together, you can expect a cluttered namespace...

[16:41] <gaal> er, yes, that's why you don't usually export/import stuff with OOP

[16:42] <Aankhen``> Yes, but you could have something like CGI's C<use CGI qw/:standard/>, and thereby provide the optional functional interface.

[16:43] <gaal> ahh, so you're asking for a generic way to give a procedural facade to an OOP module's set of static methods?

[16:44] <Aankhen``> Not quite asking for, just bouncing the idea around. :-)

[16:46] <gaal> for @export -> $meth { %{caller.package ~ "::$meth"} := $meth.assuming($self => $SINGLETON_INSTANCE) } or so

[16:47] <gaal> modulo typos and bugs and unimplemented features

[16:47] <Aankhen``> Is @export a special variable?  Or are you simply referring to a list of the exported methods?

[16:48] <gaal> and lazy construction of the singleton instance which you only want to activate with the functional facade

[16:48] <gaal> no, i'm picturing an init fucntion that can do this, nothing standard.

[16:48] <Aankhen``> OK.

[16:48] <gaal> though, heh, it can be made a standard role

[16:49] <Aankhen``> I had an epiphany regarding classes vs. roles yesterday. :-

[16:49] <Aankhen``> D

[16:49] <gaal> class CGI does FunctionalFacade { }

[16:50] <gaal> though functional means something else to many pugs hackers :)

[16:50] <Aankhen``> Heh, indeed.

[16:50] <gaal> and "procedural" reminds me of that wacky Spore game

[16:50] <Aankhen``> ?eval my $foo = "bar"; my $bar = "baz"; $::($foo)

[16:50] <evalbot6> \'baz' 

[16:51] <gaal> woot! when was that made to work?

[16:51] * Aankhen`` shrugs.

[16:51] <gaal> $::($somebody)++

[16:52] <Aankhen``> Heh.

[16:52] <iblech> That was me, some weeks ago :)

[16:52] <gaal> :)

[16:52] <Aankhen``> iblech++

[16:52] <Aankhen``> perlbot karma $somebody

[16:52] <perlbot> $somebody doesn't have any karma

[16:52] <Aankhen``> perlbot karma $::($somebody)

[16:52] <perlbot> Karma for $::($somebody): 1

[16:52] <gaal> $somebody = "iblech"; redo

[16:53] <Aankhen``> gaal++ # things like that :-)

[16:54] <gaal> iblech: did you make it work with hierarchical namespaces? last i checked the spec wasn't clear on whether they were in or not

[16:54] <iblech> You mean sth. like $::(...)::Foo::Bar::(...)::Baz? Works

[16:55] <gaal> no, i mean it searches in This::Current::Package, then in This::Current, then in This

[16:55] <gaal> funky, huh?

[16:56] <gaal> "Note that unlike in Perl 5, initial "::" doesnx92t imply global.  Package names are searched for from inner lexical scopes to outer, then from inner packages to outer.

[16:56] <gaal> The global namespace is the last place it looks.

[16:56] <gaal> must use the "*" package to force the search to start in the global namespace."

[16:56] <gaal> --  s02

[16:56] <iblech> Ah, dunno. The $::(...) notation simply reduces to the result of the expressions (i.e. $::("foo") -> $foo), and then gives the result to the standard variable finder

[16:59] <chip> back

[17:00] <knewt> hi chip

[17:03] <chip> hey, I've gone back to #parrot for the continuation issue

[17:03] <chip> er, the continuation of the issue.  whatever

[17:09] <Aankhen``> How do I pass modifiers to a Perl 5 regex?

[17:09] <gaal> rx:P5:i/moose/

[17:09] <Aankhen``> What about if I need /x?

[17:09] <Aankhen``> :x?

[17:10] <gaal> dunno :)

[17:10] <chip> :x is the default

[17:10] <Aankhen``> chip >> For P5 regexes too?

[17:10] <chip> beats me

[17:10] <Aankhen``> I doubt it...

[17:11] <gaal> ?eval "mooseelffish" ~~ rx:P5/moose elk fish/

[17:11] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:11] <Aankhen``> O_O

[17:11] <Aankhen``> Pattern matching worked?

[17:11] <gaal> ?eval "mooseelffish" ~~ rx:P5:x/moose elk fish/

[17:11] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:11] <gaal> it didn't in either case.

[17:11] <iblech> Aankhen``: :P5 apparently doesn't allocate 30MiB or so of RAM, so it works

[17:11] <Aankhen``> ?eval my $foo = "true"; bool::($foo)

[17:11] <evalbot6> Error:  unexpected "b" expecting ";", statements or end of input 

[17:11] <Aankhen``> iblech >> OK.

[17:11] <sproingie> especially since elf doesn't match elk

[17:12] <Aankhen``> ?eval "mooseelffish" ~~ rx:P5:x/moose elf fish/

[17:12] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:12] <Aankhen``> ?eval "mooseelffish" ~~ rx:P5/moose elf fish/

[17:12] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:12] <gaal> sproingie, you're right! elves don't have antlers.

[17:13] <sproingie> how about that, it's still not matching

[17:13] <sproingie> ?eval "foo" ~~ rx:P5:/foo/

[17:13] <evalbot6> Error: No compatible subroutine found: "&rx" 

[17:13] <gaal> no way to say /x? sounds like a bug to me!

[17:13] <sproingie> what'd I do wrong?

[17:13] <gaal> ?eval "foo" ~~ rx/P5/foo/

[17:13] <evalbot6> Error:  unexpected "f" expecting term postfix, operator, ">>=:=<<", ">>!=<<", ">>==<<", ">><=<<", ">>>=<<", ">>~~<<", ">>!~<<", ">>eq<<", ">>ne<<", ">>lt<<", ">>le<<", ">>gt<<", ">>ge<<", ">><<<", ">>><<", "\187=:=\171", "\187!=\171", "\187==\171", "\187<=\171", "\187>=\171", "\187~~\171", "\187!~\171", "\187eq\171", "\187ne\171", "\187lt\171", "\187le\171", "\187gt\171", "\187ge\171", "\187<\171", "\187>\171", "=:=", "!=", "==", "<=", ">=", "~~", "!~", 

[17:13] <gaal> ahem

[17:14] <gaal> sprongie: extra :

[17:14] <sproingie> ?eval "foo" ~~ rx:P5'/foo/

[17:14] <evalbot6> Error:  unexpected "'" expecting word character, "(", "[", "<<", "<", "\171", term postfix, operator, ",", ":", ">>=:=<<", ">>!=<<", ">>==<<", ">><=<<", ">>>=<<", ">>~~<<", ">>!~<<", ">>eq<<", ">>ne<<", ">>lt<<", ">>le<<", ">>gt<<", ">>ge<<", ">><<<", ">>><<", "\187=:=\171", "\187!=\171", "\187==\171", "\187<=\171", "\187>=\171", "\187~~\171", "\187!~\171", "\187eq\171", "\187ne\171", "\187lt\171", "\187le\171", "\187gt\171", "\187ge\171", "\187<\171", "

[17:14] <sproingie> argh

[17:14] <sproingie> ?eval "foo" ~~ rx:P5/foo/

[17:14] <evalbot6> MkMatch {matchOk = True, matchFrom = 0, matchTo = 3, matchStr = "foo", matchSubPos = [], matchSubNamed = {}} 

[17:14] <gaal> ah

[17:14] <sproingie> ?eval "foobar" ~~ rx:P5/foo bar/

[17:14] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:14] <gaal> at last someone who can type!

[17:14] <sproingie> ?eval "foobar" ~~ rx:P5:x/foo bar/

[17:14] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:15] <sproingie> hmm

[17:15] <sproingie> ?eval "foobar" ~~ rx:P5/foo bar/x

[17:15] <evalbot6> Error:  unexpected end of input expecting end of input or term 

[17:15] <Aankhen``> BBIAB.

[17:20] <gaal> weird, Pugs.Eval does mention x as a p5flag.

[17:22] <sproingie> ?eval "FooBar" ~~ rx:P5:i/foobar/

[17:22] <evalbot6> MkMatch {matchOk = True, matchFrom = 0, matchTo = 6, matchStr = "FooBar", matchSubPos = [], matchSubNamed = {}} 

[17:22] <sproingie> does parse flags.  doesn't seem to grok x

[17:22] <sproingie> or it does, and ignores it

[17:22] <sproingie> ?eval "FooBar" ~~ rx:P5:y/foobar/

[17:22] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:22] <sproingie> seems to ignore all flags it doesnt understand

[17:23] <gaal> hmmm, it doesn't handle :s either:

[17:23] <gaal> ?eval "foo\nbar" ~~ rx:P5:s/foo.bar/

[17:23] <evalbot6> MkMatch {matchOk = False, matchFrom = 0, matchTo = 0, matchStr = "", matchSubPos = [], matchSubNamed = {}} 

[17:25] <gaal> Pugs.Eval line 622, if anyone's feeling fixy

[17:25] * gaal has depleted his daily haskell-fu

[17:26] <autrijus> er.

[17:26] <autrijus> it's

[17:26] <autrijus> rx:P5<x>

[17:26] <autrijus> rx:P5<xism>

[17:26] <gaal> oh!

[17:26] <Aankhen``> ?eval "mooseelffish" ~~ rx:P5<x>/moose elf fish/

[17:26] <evalbot6> MkMatch {matchOk = True, matchFrom = 0, matchTo = 12, matchStr = "mooseelffish", matchSubPos = [], matchSubNamed = {}} 

[17:26] <Aankhen``> autrijus++

[17:26] <clkao> ?eval 5 < 10 < 8

[17:26] <evalbot6> bool::true 

[17:26] <gaal> woot!

[17:26] <clkao> autrijus: slacker!

[17:26] <autrijus> clkao: yeah. I just woke up

[17:27] <clkao> no, you woke up a few hours ago :p

[17:27] <autrijus> clkao: stop calling me that... I barely get any quality sleep in the past week

[17:27] <autrijus> clkao: I went back ;)

[17:27] * gaal unwoots after noticing that 10 !<< 8

[17:28] <Aankhen``> ?eval -> $foo { $foo ~ ' was called $foo in this pointy block' }.("bar")

[17:28] <evalbot6> 'bar was called $foo in this pointy block' 

[17:28] <gaal> maybe it's time for me to sleep :)

[17:28] <Aankhen``> ?eval -> $foo { $foo ~ ' was called $foo in this pointy block' }.()

[17:28] <evalbot6> ' was called $foo in this pointy block' 

[17:28] <Aankhen``> Parameters aren't required by default for pointy blocks?

[17:28] <Aankhen``> ?eval -> $foo = "default" { $foo ~ ' was called $foo in this pointy block' }.()

[17:28] <evalbot6> Error:  unexpected "=" expecting trait, ",", ":" or block 

[17:29] <Aankhen``> ?eval -> Str $foo { $foo ~ ' was called $foo in this pointy block' }.("bar")

[17:29] <evalbot6> 'bar was called $foo in this pointy block' 

[17:31] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; our &bar ::= &foo; } Foo.bar();

[17:31] <evalbot6> pugs: *** Undeclared variable: "&foo"     at <eval> line 1, column 62-66 

[17:32] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; our &bar := &foo; } Foo.bar();

[17:32] <evalbot6> Error: Undeclared variable: "&foo" 

[17:32] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; our &bar := \&foo; } Foo.bar();

[17:32] <evalbot6> Error: Undeclared variable: "&foo" 

[17:32] <Aankhen``> Wha?

[17:33] <iblech> You can't take methods references, last time I checked

[17:33] <Aankhen``> In Perl 6, or in Pugs?

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my &bar = &Foo::foo; bar()

[17:34] <evalbot6> Error: No compatible subroutine found: "&bar" 

[17:34] <iblech> Aankhen``: In Pugs

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my &bar = &Foo::foo; &bar()

[17:34] <Aankhen``> Ah.

[17:34] <evalbot6> Error: No compatible subroutine found: "&bar" 

[17:34] <Aankhen``> OK.

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my $bar = &Foo::foo; &bar()

[17:34] <evalbot6> Error: No compatible subroutine found: "&bar" 

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my $bar = &Foo::foo; $bar()

[17:34] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected 

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my $bar = &Foo::foo; $bar(Foo.new)

[17:34] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected 

[17:34] <iblech> ?eval class Foo { method foo () { 42 } }; my $bar = &Foo::foo; $bar(Foo.new:)  # last try

[17:34] <evalbot6> 42 

[17:34] <iblech> :)

[17:35] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; } my &bar = &Foo::foo; bar(Foo.new());

[17:35] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected 

[17:35] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; } my &bar = &Foo::foo; bar(Foo.new);

[17:35] <evalbot6> Error: Wrong number of invocant parameters: 0 actual, 1 expected 

[17:35] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; } my &bar = &Foo::foo; bar(Foo.new:);

[17:35] <evalbot6> 'foo was called' 

[17:36] <Aankhen``> ?eval sub foo (Str $bar, Bool ?$lc) { ($lc) ?? $bar.lc :: $bar.uc }; foo("bar");

[17:36] <evalbot6> 'BAR' 

[17:37] <putter> Is there an "official" p6 rules grammar{} for regexps?

[17:37] <Aankhen``> ?eval sub foo (Str $bar, Bool ?$lc) { ($lc) ?? $bar.lc :: $bar.uc }; my &bar := &foo.assuming(lc => 1); bar("BAR");

[17:37] <evalbot6> 'bar' 

[17:37] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; } my &bar = &Foo::foo.assuming(self => Foo.new); bar();

[17:37] <evalbot6> Error: No compatible subroutine found: "&bar" 

[17:38] <Aankhen``> ?eval class Foo { method foo () { "foo was called" }; } my &bar = &Foo::foo.assuming(self => Foo.new()); bar();

[17:38] <evalbot6> Error: No compatible subroutine found: "&bar" 

[17:39] <iblech> ?eval class Foo { method foo () { "foo was called" }; } my $bar = Foo.new.can("foo"); $bar()

[17:39] <evalbot6> Error: No compatible subroutine found: "&can" 

[17:39] <iblech> ?eval class Foo { method foo () { "foo was called" }; } my $z = Foo.new; my $bar = $z.can("foo"); $bar()

[17:39] <evalbot6> Error: No compatible subroutine found: "&can" 

[17:39] <Aankhen``> ?eval Str.can("lc");

[17:39] <evalbot6> Error: No compatible subroutine found: "&can" 

[17:40] <Aankhen``> ?eval "lc".can("lc")

[17:40] <evalbot6> Error: No compatible subroutine found: "&can" 

[17:42] <putter> autrijus, chip: has anyone started work on a grammar{} for p6 regexp?  Ie, the "regexp" rule of grammar Perl {}?

[17:45] <iblech> putter: See the end of http://svn.perl.org/perl6/grammar/trunk/Grammar.perl6

[17:48] <gaal> ?eval Carp::longmess

[17:48] <evalbot6> Error: No compatible subroutine found: "&Carp::longmess" 

[17:49] <gaal> iblech, doe evalbot bypass prelude?

[17:49] <iblech> Yep, look at Pugs.Run:152

[17:49] <iblech> unless safeMode $ do ... initPrelude ...

[17:50] <iblech> If the "is safe"/"is unsafe" traits work, we could unconditionally load the Prelude

[17:50] <gaal> ah - so we can omit the 'is safe' / 'is unsafe' directives

[17:50] <gaal> heh heh heh

[17:50] <putter> iblech: thanks...

[17:52] <iblech> food &

[17:53] <putter> yipes... I was expecting... more.

[17:54] <gaal> iblech: they do not, now at least.

[17:55] <putter> I wonder if anyone would object to doing grammar development in the pugs tree...

[17:55] <Aankhen``> How come C<< multi sub *coerce:<as> >> does

[17:55] <Aankhen``> How come C<< multi sub *coerce:<as> >> doesn't parse?

[18:03] <svnbot6> r4563, iblech++ | Pugs.Parser -- Make "is unsafe" work.

[18:08] <svnbot6> r4564, iblech++ | Pugs.Run -- Load the Prelude unconditionally, now that "is unsafe" works.

[18:12] <nothingmuch> *cough*

[18:12] <nothingmuch> oh....

[18:12] <nothingmuch> oh my... http://gumby.misplacedmac.com/Images/billgates01.jpg

[18:12] <nothingmuch> that's horrible

[18:15] <autrijus> Aankhen``: because pugs doesn't yet understand the "coerce" categ

[18:15] <autrijus> Aankhen``: it's in Parser.hs line 3621

[18:15] <autrijus> er

[18:15] <autrijus> line 361

[18:15] <autrijus> feel free to fix!

[18:18] <gaal> ?eval Carp.longmess

[18:19] <evalbot6> Error: No compatible subroutine found: "&Carp" 

[18:19] <gaal> ?eval Carp::longmess

[18:19] <iblech> ?eval $?PUGS_VERSION

[18:19] <evalbot6> Error: cannot access CALLER:: in top level: "$?CALLER::POSITION" 

[18:19] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.6, June 2, 2005 (r4564)' 

[19:04] <svnbot6> r4565, iblech++ | * t/pugsrun/11-safemode.t -- More tests.

[19:04] <svnbot6> r4565, iblech++ | * Prelude.pm -- Put a reminder to update 11-safemode.t if there's a name change

[19:04] <svnbot6> r4565, iblech++ |   of certain functions.

[19:14] <Aankhen``> autrijus >> I did it! :-D

[19:14] <Aankhen``> Should I also add the categories from A12?

[19:14] <autrijus> Aankhen``: sure!

[19:15] <Aankhen``> Okey dokey!

[19:15] <svnbot6> r4566, Aankhen++ | * C<coerce:> is now parsed in sub names.

[19:15] <autrijus> Aankhen++

[19:17] <Aankhen``> Wow, I actually changed something in the parser. :-o

[19:17] <Aankhen``> (even if it was a small thing :-)

[19:34] <svnbot6> r4567, Aankhen++ | * added remaining categories from A12 to list of valid sub name prefixes.

[19:35] <Aankhen``> 17 minutes? O_O

[19:46] <stevan> hey autrijus :) hows Vienna?

[19:51] <autrijus> stevan: very nice

[19:51] <svnbot6> r4568, putter++ | Cleaned up two disabled grammar test files - now runnable and :todo.

[19:51] <svnbot6> r4569, putter++ | Undisabled two rules/from_perl6_rules grammar test files.

[19:51] <svnbot6> r4570, putter++ | Undisabled two rules/from_perl6_rules grammar test files. (part 2 - svn ci scoping oops)

[19:51] <stevan> autrijus: any releases planned?

[19:56] <stevan> autrijus: I have been reading a lot about the CLOS MetaObject system

[19:56] <stevan> it seems like a combination of CLOS and Smalltalk will make for a nice system

[20:05] <nothingmuch> http://www.pbs.org/wnet/savageplanet/01volcano/01/indexmid.html

[20:05] <nothingmuch> stevan: see also forth

[20:06] <nothingmuch> my def for forth is meta imperative

[20:06] <stevan> nothingmuch: meta-forth?

[20:06] <nothingmuch> no, forth is meta without needing a meta prefix ;-)

[20:06] <stevan> yes

[20:07] <stevan> all "meta" really means is reflective

[20:07] <stevan> (yes that is over simplifying things)

[20:07] <nothingmuch> meta is data about data

[20:07] <nothingmuch> that is, an object interface about the objects

[20:07] <stevan> yes

[20:07] <nothingmuch> e.g. an object for a class

[20:08] <nothingmuch> forth takes this to a lower level

[20:08] <stevan> and an object for that class's class

[20:09] <nothingmuch> it constructs itself during runtime that is compile time that is runtime

[20:09] <nothingmuch> very very simple

[20:09] <nothingmuch> read chapter 7 of harrorth =)

[20:09] <stevan> meta-times :P

[20:09] <autrijus> "I never meta language I don't like"

[20:10] <stevan> :)

[20:11] <stevan> autrijus: are you familiar with CLOS at all?

[20:12] <Aankhen``> ?eval $?PUGS_VERSION

[20:12] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.6, June 2, 2005 (r4570)' 

[20:12] <autrijus> stevan: not at all

[20:13] <stevan> autrijus: neither was I :)

[20:13] <stevan> but I have been reading about it's meta-object stuff

[20:13] <stevan> very cool 

[20:13] <stevan> generic-functions++

[20:51] <svnbot6> r4571, putter++ | Parse non-capturing subrules <?foo>, and subrule names with ":" and ".".  Updated tests.

[20:54] <nothingmuch> http://www.pbs.org/wnet/savageplanet/01volcano/01/indexmid.html

[20:54] <Aankhen``> G'night.

[20:58] <mugwump> morning all!

[20:59] <mugwump> hey david

[21:12] <putter> autrijus: ping?

[21:12] <svnbot6> r4572, putter++ | capture.t: Un-todos, un-evals, un-comment tests, one new (good) todo.

[21:17] <autrijus> putter: pong

[21:25] <putter> autrijus: Could you give me the big picture on rules development?  How do you see things going forward?

[21:26] <putter> (should I be writing in pir, p6, p6, or hs... ;)

[21:32] *** stef is now known as cognominal

[21:33] <nothingmuch> http://members.safe-t.net/jwalker/programming/interview.html

[21:48] <autrijus> putter: yo

[21:48] <svnbot6> r4573, autrijus++ | * chained comparisons now work again (was broken in 6.2.6).

[21:48] <svnbot6> r4573, autrijus++ |     clkao++ for noticing it.

[21:49] <autrijus> clkao: thx. it turns out to be a typo.

[21:49] <putter> hi

[21:49] <autrijus> clkao: fortunately it's only been broken for one version

[21:51] <autrijus> putter: the big picture is that

[21:51] <autrijus> 1. PGE will go forward with default builtins and other semantics etc all written in PIR.

[21:52] <autrijus> 2. at some point, it may make sense to port PGE's parser part into Rules itself.

[21:52] <autrijus> 3. it may also make sense to compile rules into Parsec primitives.

[21:52] <autrijus> I'm pretty sure both 1. and 2. will happen eventually

[21:53] <autrijus> 3. I'm less sure, that depends on whether we see it important to keep pugs independent from parrot.

[21:53] <autrijus> if the PGE-PIR based implementation takes off and does not share the same AST as pugs

[21:53] <svnbot6> r4574, putter++ | Parse array and hash captures in regexp.  Just because they are not implemented doesnt mean we have to parsefail.  Untodoed tests.

[21:53] <autrijus> then I can see Pugs evolving another Rules system.

[21:54] <autrijus> so that we can run the PGE-PIR grammar independent of parrot.

[21:54] <autrijus> on the other hand, if Pugs became embedding parrot by default

[21:54] <autrijus> then it makes little sense to keep two rules implementations.

[21:54] <autrijus> that's the big picture. I think.

[21:55] <putter> ok... ,

[21:56] <cognominal> autrijus: that was great to get your talk from Vienna live in Marseille...

[21:57] <cognominal> too  bad I could not get you and Pierre Weis to talk together

[21:58] <putter> the pieces I've banged on are: a regexp grammar{} (or rather a bunch of them;); p6 rx in p6 on pcre; p6 rx in p5 on p5 qr; and assorted tree and bootstrap cruft. 

[22:00] <putter> hmm.  there was a transition there I blurred.  pause.  Thank you for that big picture overview! :)  I will now commence to think out loud. ;)

[22:01] <autrijus> Pierre?

[22:02] <autrijus> putter: grammar{} is just classes for methods that are aliases to rules.

[22:02] <autrijus> putter: It may or may not be feasible to compiler p6rules to p5rx.

[22:03] <autrijus> Damian demonstrated that it would be hard to get right.

[22:03] <putter> It isnt actually very hard to bootstrap a regexp parser.  You just use a match tree (:parsetree  or normal) as the parse tree, write the tree to whatever emitter, fake up an initial match tree, and your done.

[22:04] <cognominal> autrijus: http://pauillac.inria.fr/~weis/index-eng.html

[22:04] <cognominal> the designer of ocaml...

[22:04] <autrijus> putter: aye. but then p6rules isn't really a regexp.

[22:05] <autrijus> putter: it's got closures in it and it's got hypotheticals.

[22:05] <cognominal> he was attending our french Perl workshop

[22:05] <autrijus> oh, the Caml guy

[22:05] <putter> Re p6rules to p5rx - the underlying engine limits the space of usable rules.  left-recursion is a nogo.  pcre has difficulties with some right-recursive rules,

[22:05] <autrijus> he did ask about laziness

[22:05] <cognominal> yes

[22:05] <autrijus> and I gave a verbose answer of why I think default lazy list context is not a great thing

[22:05] <autrijus> and how pugs is forced to label all IOs are strict.

[22:05] <autrijus> hopefully he finds the answer sane.

[22:05] <cognominal> but I acted as go-between so a lot of information was lost

[22:06] <autrijus> putter: right. so that's kind of hard.

[22:06] <autrijus> putter: also p5rx is nonreentrant

[22:06] <cognominal> anyway, I think it is a good thing to get caml people to get interested in perl in general and perl6 in particular

[22:06] <autrijus> which kills much things

[22:07] <autrijus> because you can't define helper functions that performs some more matching for you anymore

[22:07] <autrijus> cognominal: I agree

[22:08] <putter> a pcre or p5 based backend will never do full p6 rules.  period, full stop.  there are two targets of interest,

[22:09] <putter> one, not tremendously relevent to pugs, is that a p5 emulator, despite its limitations, might be appreciated by folks using p5.

[22:12] <putter> two, a p6/pcre, or p5/qr, or p5/Parse::Regex, or PGE bootstrap, are posible ways to get to a boostrapped regexp grammar{} and parser.

[22:13] <putter> It sounds like parrot independence is not a near term objective, which reduces the attractiveness of p6/pcre and p5/qr based emulators.

[22:14] <autrijus> a sec

[22:15] <autrijus> there's p6/parsec.

[22:15] <autrijus> or hs/parsec.

[22:16] <putter> Which leaves me tempted to simply roll a regexp grammar{}, using the limited vocabulary PGE currently understands, fake up a match tree, and do a p6-based tree-to-pir emitter.  Then the existing pir parser can be tossed.

[22:16] <autrijus> which is attractive and what I'm saying about 3.

[22:17] <putter> I didn't quite follow the last few comments...

[22:18] <autrijus> oh ok.

[22:18] <autrijus> pugs currently parses perl 6 source code

[22:18] <autrijus> using Parsec.

[22:18] <putter> y

[22:19] <autrijus> feature-wise parsec is equivalent, or more powerful, than rules

[22:19] <putter> indeed

[22:19] <autrijus> so it is possible that we can parse rules syntax

[22:19] <autrijus> and compile it to parsec functions

[22:19] <autrijus> while preserving the entire rules semantics

[22:20] <autrijus> essentially reinventing PGE inside the Pugs interpreter space.

[22:20] <autrijus> I'm not working on that until we get OO done

[22:20] <autrijus> which is why 6.283 is after 6.28

[22:20] <autrijus> but I think it will be fruitful

[22:20] <autrijus> OTOH, because PGE is here

[22:20] <autrijus> there's no particular rush to do that.

[22:23] <putter> I guess the core question might be this:  PGE/pugs currently implements only a small subset of p6 rules.  Better rules support might be nice (hmm, why exactly?).  So there seem three options:

[22:24] <autrijus> 1. improve PGE XD

[22:24] <putter> allocate effort to PGE; allocate effort to parsec; punt until after objects.

[22:26] <putter> XD?

[22:26] <autrijus> XD is this smiley thing

[22:26] <putter> ah

[22:26] <autrijus> that is ignorable :)

[22:26] <putter> :)

[22:27] <autrijus> so I'm punting

[22:27] <autrijus> but I will gladly help people who want to work on either PGE or Parsec.

[22:29] <putter> Oh yes.  Your task is clearly objects.  I'm just wondering what to do next.

[22:30] <autrijus> *nod*

[22:30] * SamB thought 6.283 was after 6.28 because of the definition of decimal notation

[22:30] <autrijus> SamB: ;)

[22:31] <autrijus> putter: it would be instructive to do what nothing much did for Forth and try a basic parser for rules in Parsec, I think. 

[22:31] <putter> Hmm... a haskell learning exercise... tempting.

[22:32] <SamB> Parsec is fun.

[22:32] <putter> As for the assorted things I have "almost done" at this point, I'm tempted to simply punt until post-object.

[22:34] <putter> But for reference purposes, it really does turn out to be quite easy to bootstrap a regexp parser.  The match-tree-as-parser-ast is quite nice.  And regeps arent really that complex, from a parser point of view.

[22:34] <putter> s/purposes,/purposes, I note that/

[22:35] <putter> ok, my thanks for your help autrijus.

[22:37] <crysflame> (?<=a.*)b seems to be hard in regex as it stands

[22:37] <autrijus> putter: np :)

[22:38] <autrijus> anyway. I plan to up the req to parrot 0.2.1

[22:38] <autrijus> for this release

[22:38] <autrijus> just so we have character classes

[22:38] <autrijus> (among other things.)

[22:42] <putter> k.  I note the parrot HEAD (no J.Buffet pun intended) PGE/P6Rule.pir is unchanged, so it doesnt need merging.

[22:44] * mugwump is talking tonight at http://wellington.pm.org/ about Perl 6

[22:46] *** Odin_ is now known as Odin-LAP

[22:47] <putter> Ok, you know IRC is warping your mind when your reaction to the talk announcement is "Sam Vilain?  Who is this Sam Vilain?  mugwump is giving the talk?!? <puzzled frown>".

[22:47] <autrijus> putter: have you updated your change to parrot PGE?

[22:48] <autrijus> the <?foo> one

[22:48] <putter> "updated my change"?  err,

[22:48] <autrijus> "reflected"

[22:48] <autrijus> seems not.

[22:49] <putter> I did a second independent patch to parse array and hash... oh, that.

[22:49] <autrijus> right. because I think keeping a separate PGE tree inside pugs is troublesome

[22:49] <autrijus> I was thinking about just commit to parrot tree instead

[22:49] <autrijus> now parrot is doing monthly releases

[22:49] <autrijus> shouldn't take too long to pick things up

[22:50] <putter> It was snv'ed in as r4571 and r4572.

[22:50] <autrijus> I mean in the parrot tree.

[22:50] <autrijus> parrot/compilers/pge/

[22:51] <autrijus> I think if you're hacking PGE, it may make sense to apply for committership in parrot and commit to parrot instead

[22:51] <autrijus> just so we don't keep two PGE trees

[22:51] <autrijus> or, at least, post them as patches to p6i for patrick to re-merge

[22:51] <autrijus> into parrot

[22:51] <putter> Ah.  Good point.   Makes sense.  No, I haven't.   No bits, but I can send off a patch.

[22:52] <putter> seen pdcrawley

[22:52] <jabbot> putter: I havn't seen pdcrawley , putter

[22:52] <autrijus> ok. please send patch and ask for a bit.

[22:52] <autrijus> happily, I'm with leo and chip

[22:52] <autrijus> so handing you a committer bit should not take long.

[22:52] <autrijus> (but please send the patch for pmichaud's review first)

[22:53] <putter> seen pdcawley

[22:53] <jabbot> putter: pdcawley was seen 3 days 2 hours 31 minutes 3 seconds ago

[22:53] <putter> seen q[pdcawley]

[22:53] <jabbot> putter: q[pdcawley] was seen 6 hours 33 minutes 47 seconds ago

[22:54] <putter> Oh, wrong p.* name.  sigh.

[22:54] <putter> seen pmichaud

[22:54] <jabbot> putter: pmichaud was seen 30 days 5 hours 39 minutes 50 seconds ago

[22:54] <putter> autrijus: will do.

[22:58] <q[pdcawley]> putter?

[22:58] <q[pdcawley]> quick one.

[23:04] <geoffb> Can someone point me to any .t files that are data-driven, rather than just a long list of ok() statements (mixed with little bits of test setup)

[23:04] <autrijus> ?eval 6>5>4

[23:04] <evalbot6> bool::true 

[23:04] <autrijus> :)

[23:05] * geoffb is feeling lazy about doing `find . -name '*.t' |xargs less`

[23:05] <autrijus> geoffb: golf.t or something

[23:05] <autrijus> oh no

[23:05] <autrijus> t/examples

[23:05] <autrijus> examples.t

[23:05] <autrijus> hangs off examples/output

[23:09] <geoffb> OK, so examples/output/ has to get generated at some point I guess . . . 

[23:12] <geoffb> But actually, that wasn't what I was referring to:  I meant, takes a set of constructs, and some set of operations on them, and then runs tests for all combinations.

[23:12] <geoffb> If such does not exist, I will want to create it

[23:12] * geoffb looks at output from `svk pull` -- ah, and there is examples/output/

[23:12] <geoffb> sonofagun

[23:12] <putter> q[pdcawley]: hi, sorry, I'm apparently indexing people on the first letter and visual profile of their nicks.  Went to remember pmichaud and got pdcawley.  Sigh.;)

[23:13] *** Limbic_Region_ is now known as Limbic_Region

[23:13] <autrijus> geoffb: we don't have spec-based testing

[23:13] <autrijus> yet

[23:13] <autrijus> welcome to add it

[23:13] <geoffb> Fair enough.

[23:13] * geoffb has inspired Laziness.  Read "RSI"

[23:13] <Limbic_Region> autrijus - how goes the hackathon?

[23:14] <geoffb> Seemingly one of the favorite questions around here . . . .

[23:14] <autrijus> Limbic_Region: very well

[23:14] * geoffb guesses that autrijus willl say "very well"

[23:14] <geoffb> And there you go

[23:14] <autrijus> Limbic_Region: parrot is now much more p6 friendly :)

[23:14] <Limbic_Region> so Parrot is going to end up with STM and new calling conventions

[23:14] <geoffb> Go Parrot

[23:15] <autrijus> yes, and inexpensive continuations

[23:15] <revdiablo> STM? wow! I didn't hear about that

[23:15] <autrijus> that can be saved

[23:15] <Limbic_Region> fwiw - changing calling conventions was 1 of many sore spots between Dan and Leo

[23:15] <revdiablo> that is hot

[23:15] <autrijus> and variable sized register frames

[23:15] <Limbic_Region> revdiablo - read chip's journal

[23:15] <autrijus> Limbic_Region: right. and since the "Dan" side has disappeared...

[23:15] <Limbic_Region> http://use.perl.org/~chip/journal/25158

[23:15] <geoffb> Limbic_Region, where is chip's journal?

[23:15] <autrijus> ...we end up figuring out how to piece together "Leo" sides.

[23:15] <geoffb> man, asked to fast

[23:15] <autrijus> and so far I like what I see :)

[23:15] <autrijus> oh and a generational GC to boot.

[23:16] <Limbic_Region> autrijus - I wasn't sure how much you followed Parrot previously

[23:16] <Limbic_Region> I am not advocating one side or the other

[23:16] <autrijus> Limbic_Region: previously I read the summaries that's all

[23:16] <Limbic_Region> just trying to explain some of why a lot of changes 5 years into the project are happening relatively quickly

[23:16] <revdiablo> oh, I haven't been following chip's journal at all lately

[23:16] <Limbic_Region> from an outsiders perspective anyway

[23:16] <revdiablo> I think I need to catch up

[23:17] <Limbic_Region> the generational gc has been going in slowly for some time now

[23:18] <Limbic_Region> I wonder if matt is still working with Parrot

[23:18] <Limbic_Region> I should mention that the benchmark graphs should likely have a new scaling

[23:18] <Limbic_Region> http://www.sidhe.org/~timeparrot/graphs/

[23:19] <Limbic_Region> there's about a year's worth of graphs there showing the benchmark times of Parrot in case you are interested autrijus

[23:21] <Limbic_Region> so there are a lot of obvious changes/impacts to parrot - what's on the pipeline for Pugs?

[23:21] <autrijus> Limbic_Region: I fixed the chained comparison just so clkao won't call me slacker again

[23:21] <autrijus> :)

[23:21] <autrijus> in other news I sent off an updated version of hw2005

[23:22] <autrijus> it's now "complete" and will be judged tomorrow by the reviewers

[23:22] <autrijus> that is the conference committee

[23:22] <Limbic_Region> which means what?

[23:22] <autrijus> which means I get to code from tomorrow on :)

[23:22] <autrijus> instead of just reading and writing papers.

[23:22] <Limbic_Region> err - not what I meant

[23:22] <Limbic_Region> what are the possible outcomes of the "judging"

[23:24] <autrijus> oh.

[23:24] <autrijus> I suspect they'll tell me to improve some sections

[23:24] <autrijus> etc

[23:24] <autrijus> if I'm lucky and accepted to present in the conference

[23:24] <autrijus> if not then I suspect I'll be told 2 weeks later that they're not interested in Pugs

[23:24] <autrijus> :)

[23:25] <Limbic_Region> right - and monkey's will fly out of my butt

[23:25] <Limbic_Region> s/'//

[23:25] <autrijus> yeah, I admit I think it's rather unlikely.

[23:25] <autrijus> but hey, I'm just guessing :)

[23:25] <autrijus> in yet other news, I worked out the AST for PIR

[23:25] <Limbic_Region> ok - so are you guys taking turns sleeping or are you trying to keep them on your internal clock?

[23:26] <Limbic_Region> and it is going to stay relatively stable right?

[23:26] <autrijus> and continued to design the intermediate level PugsAST to compile from Exp to PIR

[23:26] <autrijus> right.

[23:26] <autrijus> the idea is that it's good for very long.

[23:26] <autrijus> and PASM level will change drastically.

[23:26] <autrijus> so no PBC compat for forseeable future

[23:26] <autrijus> between even point releases.

[23:26] <Limbic_Region> well - OO assembly is sick and twisted (to be read really cool)

[23:26] <Limbic_Region> but I agree - it isn't for humans to be writing anyway

[23:27] <autrijus> yup

[23:27] <autrijus> we can abuse silicon life forms

[23:27] <autrijus> until they gain sentience

[23:27] <Limbic_Region> so in the past there were very few branches in Parrot (actually I can only ever think of 1 maybe 2)

[23:27] <Limbic_Region> does this mean there should be a fair amount

[23:27] <Limbic_Region> ?

[23:28] <Limbic_Region> oh - and perhaps you can fix the whole unicode problem too - that would be really nice

[23:28] <clkao> ?eval 6 < 10 < 8

[23:28] <evalbot6> bool::false 

[23:28] <clkao> autrijus++

[23:28] <Limbic_Region> ?eval 10 > 6 < 8

[23:28] <evalbot6> bool::true 

[23:28] <Limbic_Region> yep

[23:30] <autrijus> Limbic_Region: I already fixed the latin1 bias a while ago

[23:31] <clkao> autrijus: youre still up!

[23:31] <clkao> how far have you got for parrot backend

[23:31] <autrijus> clkao: pretty far along in design

[23:31] <autrijus> clkao: coding starts tomorrow

[23:32] <autrijus> clkao: I'll start with svnbot.p6

[23:32] <putter> good night folks

[23:33] <clkao> coolio

[23:33] <Limbic_Region> autrijus - I was referring to Parrot's dependency on ICU cause no one has been brave enough to hack up an alternative

[23:33] <clkao> in other news, i've got plan for the git import/export for svn::mirror

[23:34] <autrijus> Limbic_Region: there's no ICU dep anymore

[23:34] <clkao> and then we'll see if it's feasible to make backend with it

[23:34] <autrijus> cool

[23:34] <autrijus> seems git is hot :)

[23:34] <autrijus> Limbic_Region: not mandatory anyway

[23:36] <geoffb> Is there already a file or files that provide a human-friendly map to the pugs tree?

[23:36] <clkao> it's actually quite rough *shrug*

[23:36] <Limbic_Region> autrijus - that should have been written "dependency on ICU for unicode"

[23:36] * geoffb 's @pugs_todo is getting rather long

[23:36] <autrijus> geoffb: no. lib/pugs/hack.pod

[23:37] <Limbic_Region> the design was supposed to be a well published API so that any unicode library would work

[23:37] <Limbic_Region> 2.  Parrot would ship with capability of unicode period - user could choose to not use it

[23:37] <Limbic_Region> 3.  ICU would be default library until something better came along

[23:37] <Limbic_Region> it sounds like 1 and 2 are finished

[23:38] * geoffb assumes that autrijus's last comment should be decompressed to "No it doesn't exist; but it should go in lib/pugs/hack.pod"

[23:38] <autrijus> yes.

[23:38] <geoffb> thought so.

[23:39] <autrijus> Limbic_Region: I think it's okay to have a minimal builtin impl for unicode charclesses and case conversions

[23:39] <autrijus> but other than that I further think ICU is decent.

[23:39] <Limbic_Region> ICU is a boheamoth that breaks in lots of ways on lots of platforms

[23:39] <geoffb> I swear I will be able to start popping soon.  (Of course, I'm swearing that with one side of my brain so that the other side doesn't go "Right. Time to go jump out a window and stop recursing.")

[23:39] <Limbic_Region> it ups the dependencies for Parrot too (requiring c++)

[23:40] * Limbic_Region shuts up now

[23:40] <autrijus> geoffb: I did the window jumping thing this morning. lots of fun

[23:40] <Limbic_Region> this is #perl6 and not #parrot

[23:40] <geoffb> heh

[23:44] <autrijus> ok. I need to sleep now :)

[23:44] <autrijus> g'nite folks, see you tomorrow!

[23:44] <Limbic_Region> TTFN autrijus

[23:44] <Limbic_Region> sleep well

[23:45] <geoffb> cya, sleep well!

[23:59] <Odin-LAP> revdiablo: Sorry.

