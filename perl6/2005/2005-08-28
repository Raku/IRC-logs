[01:17] <rjbs> Does Perl 6 have a hashy hash slice notation?  That is, return a list of pairs for the given keys?

[02:33] <svnbot6> r6528 | fglock++ | * perl5/ Array

[02:33] <svnbot6> r6528 | fglock++ |   - Fixed fetch/store single elements from a lazy slice

[02:33] <svnbot6> r6528 | fglock++ |   - Fixed fetch/store of whole lazy slice -

[02:33] <svnbot6> r6528 | fglock++ |     supports syntax: 

[02:33] <svnbot6> r6528 | fglock++ |     @a = (0..Inf); @a[1,10,100..10000] = @a[500..30000]

[02:33] <svnbot6> r6528 | fglock++ |     (needs optimization)

[02:33] <svnbot6> r6528 | fglock++ |   - New method tied()

[02:33] <svnbot6> r6528 | fglock++ |   - Fixed binding of fetched result

[02:33] <svnbot6> r6528 | fglock++ |   - Fixed stringification of unboxed values

[02:33] <svnbot6> r6528 | fglock++ |   - New parameter 'max' in perl() and str() methods -

[02:33] <svnbot6> r6528 | fglock++ |     controls how many elements of the lazy array are

[02:33] <svnbot6> r6528 | fglock++ |     stringified.

[02:33] <svnbot6> r6528 | fglock++ |   - Array is stringified using parenthesis.

[02:33] <svnbot6> r6528 | fglock++ | * perl5/ List

[02:33] <svnbot6> r6528 | fglock++ |   - new methods start() end()

[05:30] <luqui> ?eval (a => 1).keys

[05:30] <evalbot_6528> ('a') 

[05:30] <luqui> ?eval (a => 1)<a>

[05:30] <evalbot_6528> \1 

[05:30] <luqui> ?eval (a => 1)<a> = 2

[05:30] <evalbot_6528> Error: Can't modify constant item: VUndef 

[05:30] <luqui> ?eval my $x = 1; (a => $x)<a>

[05:30] <evalbot_6528> \\1 

[05:30] <luqui> ?eval my $x = 1; (a => $x)<a> = 4

[05:30] <evalbot_6528> Error: Can't modify constant item: VUndef 

[05:48] <ods15> odd

[05:49] <ods15> whats with the <>, why the change

[05:51] <revdiablo> {} subscripts don't auto-quote

[05:52] <revdiablo> ? eval (a => 1){'a'}

[05:52] <revdiablo> ?eval (a => 1){'a'}

[05:52] <evalbot_6528> \1 

[05:52] <revdiablo> without those quotes, it would take it as code.

[05:52] <revdiablo> ?eval (a => 1){a}

[05:52] <evalbot_6528> Error: No compatible subroutine found: "&a" 

[05:53] <revdiablo> so there's <> that does quoting

[05:53] <ods15> yeah that was a bit inconsistent in perl5

[05:53] <ods15> like, if '{a}' work, and '{$bla}', what does '{func()}' do...

[05:54] <ods15> or '{$a b}'

[05:54] <revdiablo> so yeah, perl6 disambiguates the situation

[05:55] <luqui> Ods, {$bla} does not autoquote

[05:55] <luqui> the only thing that autoquotes in p5 is /[\w-]+/

[05:55] <luqui> but perl6 autoquotes nothing, which is nice in a way

[05:55] <luqui> (though it's a situation that I resisted for a while)

[05:56] <ods15> heh

[05:56] <luqui> does anybody here know anything about PIL2

[05:56] <luqui> ?

[05:57] <revdiablo> ?eval (a => 1)«a»

[05:57] <evalbot_6528> Error:  unexpected "\a" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[05:58] <revdiablo> hmm, I dunno if the utf8 went through right

[06:07] <luqui> ?eval (a => 1)<<a>>

[06:07] <evalbot_6528> \1 

[06:07] <luqui> I'm guessing it's a utf8 problem

[06:10] <svnbot6> r6529 | putter++ | lib6/Prelude/JS/Rules.pm: unfinished sketch of :perl5 regex support for PIL2JS.

[06:25] <luqui> nothingmuch, do you know anything about PIL2?

[06:26] <nothingmuch> no

[06:26] <luqui> darn

[06:26] <nothingmuch> sorry

[06:26] <luqui> what are you working on these days?

[06:26] <nothingmuch> work and rennovating the house

[06:26] <luqui> ahh, so not perl 6

[06:26] <luqui> :-)

[06:27] <nothingmuch> no =(

[06:27] <luqui> too bad.  well, I hope you're having fun betraying us...

[06:27] * luqui should talk, having the longest absences of anyone :-)

[06:27] <luqui> anyway, I do hope you're having fun

[06:28] <luqui> you're working with stevan right?

[06:33] <nothingmuch> huh?

[06:33] <nothingmuch> on what?

[06:33] <nothingmuch> and no, i'm not having fun... Dust and insanity mostly

[06:33] <nothingmuch> then it's also summer vacation, so the car is tied up

[06:33] <nothingmuch> and I have to rely on rides to work

[06:34] <luqui> eep

[06:34] <nothingmuch> which sometimes don't get there

[06:34] <luqui> why is the car tied up during summer?

[06:34] <nothingmuch> sister needs enterntainment (summer camps all over)

[06:34] <luqui> oh.  I'm glad I have no siblings...

[06:35] <nothingmuch> since parents don't have to teach in the summer, they can work from home

[06:35] <luqui> that sucks though

[06:35] <nothingmuch> so one works, while the other entertains sister

[06:35] <nothingmuch> in normal times parents and I share the car to work

[06:36] <nothingmuch> work needs to lease me a small car

[06:36] <luqui> who are you working for then?

[06:36] * luqui guesses it's not stevan

[06:36] <nothingmuch> http://www.hyperroll.com/

[06:36] <luqui> for some reason I thought thtat it was

[06:36] <nothingmuch> well i did do one project for stevan, that's what got me to YAPC (monetarily)

[06:37] <luqui> ahh, that was it.  it was a one-shot thing.  that's what confused me

[06:37] <luqui> hyperroll.com looks like a nice weasel-wordy site

[06:37] <nothingmuch> yup

[06:38] <nothingmuch> weasel-wordy?

[06:38] <nothingmuch> it's the "new website", since ca last year or so

[06:38] <nothingmuch> some company does it for us, I think

[06:38] <luqui> "HyperRoll delivers previously unattainable levels of speed, data volume, and *business dimensions*"

[06:38] <nothingmuch> ah yes

[06:39] <luqui> wtf does that mean? :-)

[06:39] <nothingmuch> but then againa all of OLAP is weasel wordy

[06:39] <luqui> OLAP?

[06:39] <nothingmuch> speed means we're faster than the competition

[06:39] <nothingmuch> data volume means we handle more data and take less space than the competition

[06:39] <nothingmuch> and business dimensions are OLAP nonsense made possible by efficient speed and data volume

[06:40] <luqui> heh

[06:40] <luqui> what is OLAP?

[06:40] <nothingmuch> dimentionality in OLAP determines a certain slice by which you query your tables

[06:40] * luqui learns to google

[06:41] <nothingmuch> i must admit i don't really know

[06:41] <nothingmuch> anyway, ride issue fixed, must get ready for it

[06:41] <luqui> good

[06:41] <luqui> adionara

[07:52] <nothingmuch> morning

[07:57] <luqui> quiet in here

[07:57] <nothingmuch> indeed

[08:06] <ods15> hya nothingmuch 

[08:07] <nothingmuch> hi hop

[08:07] <nothingmuch> s/p$/;

[08:07] <nothingmuch> grr

[08:07] <ods15> yawn

[08:08] <nothingmuch> ods15: just getting up, or got up too early?

[08:12] <nothingmuch> heh, someone at work just told me that his computer now says:

[08:12] <nothingmuch> "CPU not workable, press F1 to continue" during boot

[08:12] <nothingmuch> when he presses F1 the machine resumes normally

[08:13] * nothingmuch kind of knew intel was scamming us with the gigahertz myth and all that, but I never thought you don't actually need a CPU to run windows

[08:20] <ods15> nothingmuch: hmm, niether really..

[08:20] <ods15> i woke up at about 6pm yesterday after about 3 hours of sleep

[08:23] <nothingmuch> odd

[08:23] * nothingmuch has a new idea

[08:23] <nothingmuch> ($by_name{$action->name} ||= Set::Object->new)->insert($action);

[08:23] <nothingmuch> user defined autovivification would be nice here

[08:24] <nothingmuch> my %by_name is autovivifying(sub { Set::Object->new });

[08:24] <nothingmuch> uh, perl6ify that

[08:24] <luqui> class Foo will autovivify { Foo.new } {...}

[08:25] <nothingmuch> uh, what does that mean? that I can say my %hash is shape (... contains a Foo ...) "?

[08:25] <luqui> probably

[08:25] <nothingmuch> which syn is that?

[08:25] <luqui> how do you know what to vivify otherwise?

[08:25] <nothingmuch> the hash has a subroutine

[08:26] <nothingmuch> like in my example

[08:26] <nothingmuch> or a trait saying which class to use

[08:26] <nothingmuch> my %by_name will autovify(Foo);

[08:27] <luqui> Yeah, I think my Foo %hash is the way to go there

[08:27] <nothingmuch> i agree

[08:27] <nothingmuch> what syn is that?

[08:27] <luqui> uh

[08:27] <luqui> S06?

[08:27] <nothingmuch> that's subs, doesn't make sense

[08:28] <luqui> or S09

[08:28] <nothingmuch> nope

[08:28] <luqui> what are you looking for?

[08:28] <nothingmuch> /autov/

[08:28] <luqui> oh, autovivi

[08:28] <luqui> do the syns mention that even?

[08:29] <nothingmuch> i don't find 'autov' so autovivi woon't turn up either

[08:29] <nothingmuch> s 06 mentions it WRT to parameters and 'is ref'

[08:30] <luqui> A06 is the only place that autovivi is mentioned too

[08:30] <luqui> maybe it hasn't been covered

[08:30] <ods15> nothingmuch: whats odd? my sleeping pattern?

[08:30] <nothingmuch> ods15: yes

[08:30] <ods15> army guarding isn't very permissive regarding sleeping :/

[08:30] <nothingmuch> i thought the army makes your sleeping pattern more rigid

[08:31] <nothingmuch> oh, i see... =)

[08:31] <ods15> usualy yes, except when you guard

[08:31] <nothingmuch> right

[08:31] <nothingmuch> what is the effect of : sub foo (*@args) { ... }; foo(gather { ... });

[08:31] <nothingmuch> does it delazify?

[08:32] <luqui> certainly not

[08:32] <nothingmuch> good

[08:32] <luqui> *@ is allowed to be lazy

[08:32] <nothingmuch> **@ flattens?

[08:32] <luqui> er, eagerifies, yes

[08:32] <nothingmuch> what about foo($scalar, @array)? do you get [ $scalar, [ @array ] ] or [ $scalar, @array ]

[08:33] <luqui> I expect you get the latter, but a lazy proxy so @array can stay lazy

[08:33] <nothingmuch> yeahg

[08:35] * luqui loves monads much now, and is entertaining the idea of making the hyper operators into monadic binding

[08:35] <luqui> -<< @foo   # @foo.bind(&prefix:<->)

[08:35] <ods15> nothingmuch: wtf is lazy

[08:36] <nothingmuch> ods15: you have 30 seconds to make a guess

[08:36] <ods15> not a clue

[08:36] <ods15> don't read/do anything until actually called?

[08:36] <luqui> s/called/used/   yep

[08:36] <ods15> as opposed to non lazy?!?!?

[08:37] <nothingmuch> "strict" or "eager"

[08:37] <ods15> wtf kind of thing does something without being used

[08:37] <luqui> for instance:  @foo = <>;  print @foo;   # input is read on "print", not the assignment

[08:37] <ods15> the whole beauty of doing 'if (NULL && *(int*)NULL) {}' is that it can be done and it's safe...

[08:38] <ods15> luqui: that's lazy?

[08:38] <luqui> not in perl 5... I don't think it is in perl 6 either

[08:38] <luqui> but:  @foo = lazy { <> };   print @foo;   # is

[08:38] <nothingmuch> ods15: explain why that is beautiful

[08:38] <luqui> and what it has to do with laziness...

[08:39] <ods15> nothingmuch: if (ptr && ptr->value) { do something }

[08:39] <ods15> luqui: i mis understood laziness

[08:39] <nothingmuch> uh, not all of the language is lazy

[08:39] <nothingmuch> just certain things

[08:39] <nothingmuch> my @array = 1 .. 1000000000000000; # doesn't explode your computer;

[08:39] <ods15> i thought you meant, since 'ptr->value' is not used, it's not evaluated..

[08:39] <nothingmuch> more interestingly: 'my @array = 1 ...'; # to infinity

[08:39] <ods15> "not lazy" in that definition would be insane

[08:39] <coral> (x|y) appears to be lazy

[08:39] <nothingmuch> ods15: go learn haskell

[08:39] <coral> but i think i'm just misunderstanding

[08:39] <nothingmuch> ods15: you'll hate it.

[08:39] <coral> also, must learn haskell :)

[08:40] <luqui> coral, how is x|y lazy?

[08:40] <luqui> I'm just asking, not making a point

[08:40] <nothingmuch> coral: 'x || y' maybe? WRT the y?

[08:40] <coral> well, in my experiments with evalbot and (x|y) i've noticed that it tends to avoid picking one of the choices until the very last moment possible, if at all

[08:40] <ods15> anyway... that's pretty insane then? you can't keep track of when things are actually DONE, you can end up with crazy race conditions and deadlocks and not understand where/why

[08:40] <coral> which seems to fit the definitionish of lazy

[08:40] <luqui> coral, evalbot and junctions don't mix

[08:41] <coral> ok

[08:41] <luqui> ?eval 1|2|3|4

[08:41] <evalbot_6528> 1 

[08:41] <luqui> ?eval 1|2|3|4

[08:41] <evalbot_6528> 1 

[08:41] <luqui> ?eval 1|2|3|4

[08:41] <evalbot_6528> 1 

[08:41] <luqui> ?eval (1|2|3|4).perl

[08:41] <evalbot_6528> '(1 | 2 | 3 | 4)' 

[08:41] <luqui> that's more like it :-)

[08:41] <ods15> whats |, not or i'm guessing

[08:41] <luqui> it's a special kind of "value or"

[08:42] <luqui> ?eval my $x = 3;  if $x == 1|2|3|4 { "yes" } else { "no" }

[08:42] <evalbot_6528> 'yes' 

[08:42] <nothingmuch> ods15: junctive or

[08:42] <nothingmuch> ?eval my $x = 2|5; ($x * 2).perl

[08:42] <evalbot_6528> '(4 | 10)' 

[08:42] <ods15> then, it's not a value of any kind

[08:42] <nothingmuch> it is

[08:42] <ods15> as in, 1|2|3|4 doesn't really have a value

[08:42] <ods15> it's more a list

[08:42] <nothingmuch> it does

[08:43] <nothingmuch> no it isn't

[08:43] <revdiablo> 1|2|3|4 creates a junction

[08:43] <nothingmuch> it's a junction =)

[08:43] <revdiablo> which is decidedly a value

[08:43] <ods15> what it's value?

[08:43] <luqui> ods15, it multiple values masquerading as a single one

[08:43] <nothingmuch> ods15: (1|2|3|4)

[08:43] <coral> ods15: have you seen the perl6 module Quantum::Superposition?

[08:43] <ods15> nothingmuch: that's "kind of" a list

[08:43] <nothingmuch> ods15: you can passs that around, apply arithmetic to it, and so forth

[08:43] <coral> or thereabouts.. it's a dconway thing, in any case.

[08:43] <nothingmuch> coral: that is perl 5

[08:43] <coral> er perl6

[08:43] <nothingmuch> ods15: no it isn't, it's a scalar

[08:43] <coral> ARGH

[08:43] <ods15> coral: a better question would be, "have you seen perl6?"

[08:43] * luqui wants to make junctions simply syntactic shorthand though

[08:43] <nothingmuch> a list is a list of values with order

[08:43] * coral tries for the 5 twice and misses.

[08:43] <luqui> because they so horribly defy the laws of logic

[08:44] <ods15> nothingmuch: ok, i get it

[08:44] <nothingmuch> a junction is a nested collection of values with logical combinators

[08:44] <nothingmuch> luqui--; # NONONONO

[08:44] <luqui> nothingmuch, why

[08:44] <nothingmuch> i've used junctions as values several times, I haven't gotten burned, and it was very nice

[08:44] <ods15> ?eval my $x = 5|2; ($x * 2).perl

[08:44] <evalbot_6528> '(4 | 10)' 

[08:44] <nothingmuch> this is the "i'm not an idiot" issue all over again

[08:44] <ods15> ?eval my $x = 5|2|2; ($x * 2).perl

[08:44] <evalbot_6528> '(4 | 10)' 

[08:45] <ods15> ?eval my $x = 5|2|2.5; ($x * 2).perl

[08:45] <evalbot_6528> '(4 | 10 | 5)' 

[08:45] <coral> is there a way to turn a list into a junction?

[08:45] <luqui> nothingmuch, okay, I understand that angle

[08:45] <ods15> ?eval my $x = 5|2|2.53; ($x * 2).perl

[08:45] <evalbot_6528> '(4 | 10 | 5.06)' 

[08:45] <nothingmuch> coral: any(@list)

[08:45] <nothingmuch> luqui: another thing I don't like about perl 6 is the "this is not for the children... let's make it a pragma" approach

[08:45] <coral> ?eval my $x = 1...; any($x).perl

[08:45] <evalbot_6528> pugs: out of memory (requested 1048576 bytes) 

[08:45] <revdiablo> ?eval any(1,2,3).perl

[08:45] <evalbot_6528> '(1 | 2 | 3)' 

[08:45] <nothingmuch> there are already enough daqngerous features to make the children scream and have nightmares

[08:45] <nothingmuch> autothreading, off the top of my head, is one that is on by defau.t

[08:46] <ods15> ?eval my $x = 5; $x|=2; ($x * 2).perl

[08:46] <evalbot_6528> '(4 | 10)' 

[08:46] <ods15> ?eval my $x = 5; $x|=2; $x&=3; ($x * 2).perl

[08:46] <evalbot_6528> '(6 & (4 | 10))' 

[08:46] <nothingmuch> and the way to make it safe is not to make it harder to give it a proper value

[08:46] <ods15> wtf is that

[08:46] <nothingmuch> s/proper/; improper

[08:46] <ods15> ?eval my $x = 5; $x|=2; $x^=3; ($x * 2).perl

[08:46] <evalbot_6528> '(6 ^ (4 | 10))' 

[08:46] <revdiablo> ods15: & means all, | means any

[08:46] <nothingmuch> ods15: that means it's 6 and (4 or 10)

[08:46] <coral> hmmm. is there a way to take an infinite iterator like 1... and turn it into a junction without evaluating it for 1..inf first?

[08:46] <ods15> nothingmuch: what do you compare it with, another junction?

[08:46] <nothingmuch> so if you say (6 & (4 | 10)) < 8

[08:47] <nothingmuch> it's ture

[08:47] <luqui> nothingmuch, autothreading is one of those features that enforces "this is not for children"

[08:47] <ods15> ay

[08:47] <ods15> thats scary

[08:47] <nothingmuch> luqui: but it's on by default

[08:47] <luqui> it enforces that you don't give junctions to functions that aren't expecting them

[08:47] <ods15> bbl hungry

[08:47] <nothingmuch> ods15: i find it bleasant

[08:47] <nothingmuch> pleasant

[08:47] <luqui> yeah, and if it were off, then all subs would have to worry about junctions

[08:47] <nothingmuch> luqui: if junctions were treated normally unless autothreading, things would not be so clumsy wrt to this safety issue

[08:47] <nothingmuch> 'sub foo is autothreading' # enough

[08:48] <nothingmuch> or 'use autothreading'; # global for this scope

[08:48] <luqui> so you want to be able to say foo(1|2) and let foo assume that its argument behaves normally when it doesn't?

[08:48] <nothingmuch> or 'sub foo is pure' # maybe autothreading, maybe not - depends on runtime, #cpus, available memory, and so forth

[08:48] <nothingmuch> luqui: i want (1|2) to propagate downwards

[08:48] <luqui> oh, autothreading btw has no tie to cpu threads

[08:48] <nothingmuch> and let the junction be resolved at the lowest level, by the builtin operators

[08:49] <nothingmuch> pure operators will take junctions and return junctions

[08:49] <luqui> that's a bad approach.  it's the same reason that we had to kill junctive types and replace them with union/intersection types

[08:49] <nothingmuch> things like $fh.seek(1|2); # death

[08:49] <luqui> junctions do not obey the laws of logic

[08:49] <luqui> so you can't metaprogram if they're around

[08:49] <nothingmuch> i argue that you can:

[08:49] <nothingmuch> junctions are dealt with at the lowest level in the call stack

[08:49] <nothingmuch> and created at the highest level

[08:50] <nothingmuch> and anything in the middle doesn't have to care

[08:50] <luqui> but it does

[08:50] <nothingmuch> why does it?

[08:50] <luqui> if $x == 1 { say "foo" }  if $x != 1 { say "bar" }

[08:50] <luqui> if $x is a junction, both clauses may be executed

[08:50] <nothingmuch> okay

[08:50] <luqui> which is contrary to an assumption that the programmer may have made

[08:50] <nothingmuch> so what about:

[08:51] <nothingmuch> sub foo ($place) { $fh.seek($place) };

[08:51] <luqui> the writer of this module may not even know that junctions exist (this is that thing -- you don't have to know the whole language to write good code)

[08:51] <nothingmuch> foo(1|2); # silently seeks to either 1 or 2?

[08:51] <nothingmuch> luqui: yeah, i agree it's dangerous, but IMHO autothreading is still more dangerous

[08:51] <luqui> depending on evaluation order :-)

[08:51] <luqui> nothingmuch, they're both dangerous

[08:52] <luqui> that's why I want to demote junctions

[08:52] <nothingmuch> what I want junctions for is things like:

[08:52] <coral> having unlink() or an equivalent in the core function set of any language by default is incredibly dangerous

[08:52] <coral> and yet

[08:52] <nothingmuch> is($got, 1|2, "foo");

[08:52] <luqui> the same way I want to demote pairs: to make it very visible exactly where you are using them

[08:52] <luqui> nothingmuch, hmmm

[08:52] <luqui> hmmmmmmmmmmmm

[08:52] <nothingmuch> this is where junctions shine

[08:52] <nothingmuch> they are sooooo good when you know what the thing you call is doing

[08:53] <nothingmuch> they are not useful for big nested calls

[08:53] <nothingmuch> but lots of time control flow is encapsulated behind polymorphism

[08:53] <luqui> and that wouldn't work if is were autothreaded

[08:53] <nothingmuch> ?eval use Test; is(1, 1|2);

[08:53] <evalbot_6528> pugs: *** No compatible subroutine found: "&use"     at tmp-Prelude.pm line 38, column 30-59 

[08:53] <nothingmuch> uh, crap

[08:53] <nothingmuch> anyway it says "ok 1\nnot ok 2\n"

[08:53] <nothingmuch> unless we made Test explicitly accept junctions

[08:53] <luqui> right

[08:54] <nothingmuch> but since it didn't work to start with, no one touched it with a ten foot pole ever since

[08:54] <nothingmuch> i really really really like encapsulating logic

[08:54] <nothingmuch> especially when the input is similar, the output is the same, but the path is different

[08:55] <nothingmuch> i like to ask my objects 'are you happy? can you do this?' and not deal with it myself at the top level

[08:55] <nothingmuch> this sometimes leads me to overly abusing multiple inheritence in perl 5

[08:55] <nothingmuch> but roles and delegation should help me solve that in perl 6

[08:55] <nothingmuch> so i don't want to retrain myself just yet

[08:56] <luqui> oh, example:

[08:57] <luqui> sub is ($test, $output, $name) { if $test == $output { say "ok 1 # $name" }   say "Debug 1";   if $test != $output { say "not ok 1 # $name" } }

[08:57] <luqui> unfolded from if {} else {}

[08:57] <luqui> for debugging, and suddenly you're debugging a problem that wasn't there to begin with

[08:58] <nothingmuch> luqui: is there any middle grounds?

[08:58] <luqui> So I think junctions are wrong, however I think locally encapsulated junctions (because of your examples) are also probably wrong

[08:58] <luqui> how can we fix that

[08:58] <nothingmuch> i think that i'd rather just poke and see if something works

[08:58] <nothingmuch> and then use it

[08:59] <nothingmuch> instead of not being able to use it at all, just because the author didn't think of it at the time

[08:59] <luqui> I'm not sure what you mean by that

[08:59] <nothingmuch> well, if i'm not allowed or can't use junctions, then i'm screwed either way

[09:00] <nothingmuch> if i can use them, but sometimes i'll cry because of it, i can use them in one liners

[09:00] <nothingmuch> or with code that I wrote

[09:00] <nothingmuch> and I won't have to say in advance that I did

[09:00] <nothingmuch> or more significantly, i won't have to patch other code to make sure it does

[09:00] <nothingmuch> as I see it both autothreading and passed junctions are useful

[09:01] <nothingmuch> perhaps this makes sense:

[09:01] <nothingmuch> if there is a branch in control flow due to an external junction, it's a fatal error unless explicitly asked for by the caller

[09:01] <luqui> well I'm trying to push autothreading into the list monad for my new proposal

[09:02] <nothingmuch> aside from that the user can choose to pass the junction, or to autothread on a lexical pragma basis, with the now safer option (passing) being the default

[09:02] <nothingmuch> luqui: please explain

[09:02] <luqui> I'm going to try to steal << >> from qww and turn it into an argument hyper

[09:02] <luqui> (the arrows are pointing to the parentheses)

[09:03] <luqui> so you can do foo(1, 2, <<3,4>>,5)

[09:03] <luqui> and it will return (foo(1,2,3,5),foo(1,2,4,5))

[09:03] <nothingmuch> yeah, i liked that

[09:03] * nothingmuch thinks he brought that up with >><<

[09:03] <nothingmuch> but I don't remember now

[09:03] <luqui> I think you did

[09:04] <luqui> I'm just generalizing it more

[09:04] <nothingmuch> why can't it use foo(1, 2, >>3, 4<<, 5), btw?

[09:04] <luqui> well, it *could*

[09:04] <luqui> but I think << and >> make more sense, because the arrows always point to the *operator* that is being hypered

[09:04] <luqui> and I think qww is not common enough to deserve these very useful brackets

[09:05] <nothingmuch> oh, i see

[09:05] <luqui> so that covers autothreading when you want it (plus predictable unpacking, which junctions don't give you)

[09:05] <nothingmuch> qww is something I write all the time in perl 5

[09:06] <nothingmuch> or wait, qww vs qw?

[09:06] <luqui> qww interpolates and shell splits

[09:06] <nothingmuch> ah

[09:06] <nothingmuch> right, I agree

[09:06] <nothingmuch> i like that a lot

[09:07] <nothingmuch> it also has the property, much like hyper, to be so obvious and so noticable, that once a newbie knows what it's doing, they never forget

[09:07] <luqui> hooray

[09:07] <luqui> so back to junctions

[09:07] <nothingmuch> luqui++; # good proposal

[09:09] <luqui> I would like junctions in their current state if we could massage them to obeying logic

[09:09] <luqui> for instance, flipping their junctitude on negation operators and whatnot

[09:10] <luqui> or maybe they are just a smartmatch pattern?

[09:10] <nothingmuch> lunch time

[09:10] <luqui> happy lunching

[09:10] * luqui gets some food too

[09:10] <nothingmuch> how do you make them obey logic?

[09:11] <luqui> actually, I don't think you can

[09:11] <luqui> not without implementing Quantum::Entanglement

[09:11] <luqui> but we can formalize the notion of "pattern"

[09:11] <luqui> against which smartmatch works

[09:12] <luqui> and then junctions are just patterns, and there's nothing mathematically evil with them

[09:13] <nothingmuch> hmm

[09:13] <nothingmuch> what's bad about Q::E?

[09:13] <luqui> nothing, it's just, um...

[09:14] <luqui> not for children :-)

[09:14] <nothingmuch> okay

[09:14] <nothingmuch> so again to my "safe" junctions proposal:

[09:14] <nothingmuch> boolean logic that involves non uniform control flow is a fatal error

[09:14] <luqui> example?

[09:14] <nothingmuch> your example for is()

[09:15] <nothingmuch> it wouls say 'junctive parameter caused inconsistent program flow at line xxx file x, from line zzz file z'

[09:15] <nothingmuch> with zzz being the first place where the junction was passed

[09:15] <luqui> so once you tested it against one thing

[09:16] <luqui> er, that sentince won't finish

[09:16] <nothingmuch> heh

[09:16] <luqui> so:  my $j = 1|2;   if $j == 1 { say "foo" }  if $j == 2 { say "bar" }   # dies

[09:16] <nothingmuch> luqui: user def autovivification on p6l

[09:16] <nothingmuch> yes

[09:16] <nothingmuch> at $j == 1

[09:16] <luqui> my $j = 1|2;  if $j == 1 { say "foo" }  if $j == 1 { say "bar" }    # doesn't die

[09:16] <nothingmuch> because it's both true, and false, one flow does execute { say "foo" } and the other doesn't

[09:17] <nothingmuch> wait, no

[09:17] <nothingmuch> hmm

[09:17] <nothingmuch> doesn't make sense

[09:17] <luqui> you just make sure that the value the junction represents is always the same

[09:17] <nothingmuch> this isn't good enough because sometimes you would like the code you call to "foo\nbar\n" and sometimes you don't

[09:17] <nothingmuch> i think you don'

[09:17] <nothingmuch> t is the default

[09:17] <nothingmuch> so it dies if there is any altered control flow whatsoever

[09:17] <nothingmuch> if ($x == 1) { } ...

[09:17] <luqui> hmmm

[09:18] <nothingmuch> that is death

[09:18] <nothingmuch> unless the code takes that explicitly

[09:18] <luqui> then the usual implementation of is() breaks with junctions

[09:18] <nothingmuch> right, unless the caller says "that's OK"

[09:18] <nothingmuch> but anyway, nevermind, i'm hungry

[09:18] <luqui> ahh, the call*er*?

[09:18] <luqui> yeah, me too

[09:18] <luqui> bbiab

[09:18] <nothingmuch> errrr yes, the person who apssed the junction decides under these semantics

[09:19] <nothingmuch> unless the calleeeeeeeeee (no Rs) says explicitly that it allows, doesn't allow, and/or autothreads

[09:19] <nothingmuch> *poof*

[10:20] <nothingmuch> oh boy!

[10:20] * nothingmuch is writing a query planner

[10:20] <nothingmuch> with Class::Multimethods.

[10:20] <nothingmuch> this should be really fun

[10:21] <nothingmuch> ofcourse, I don't need it to be efficient yet, but how can I pass on something this fun

[10:21] <luqui> you could use Class::Multimethods::Pure, which is even slower!

[10:22] <nothingmuch> yarr

[10:22] * nothingmuch isn't going to use MMs just yet... 

[10:22] <nothingmuch> in several minutes

[10:35] * luqui has been using MMs all over the place.  They really make programming wonderful

[10:35] <luqui> And they make my programs slow... but I'm not the kinda guy that cares about that

[10:36] * luqui sleep &

[10:36] <nothingmuch> i like the potential of MMD to actually make things fast

[10:36] <wilx> MM?

[10:36] <nothingmuch> lots of the logic becomes declarative

[10:36] <wilx> Is that something like C++ function overloading?

[10:36] <nothingmuch> and this can be resolved by a type inferrencing compiler

[10:36] <nothingmuch> wilx: yes, multimethods

[10:36] <nothingmuch> they're more than overloading though

[10:37] <scook0> and it's based on runtime-type rather than static-type

[10:37] <nothingmuch> scook0: not necessarily

[10:37] <scook0> well, no

[10:37] <nothingmuch> it's based also on runtime type

[10:38] <scook0> bah, pedant :)

[10:38] <nothingmuch> =)

[10:38] <nothingmuch> static typing is very important to make MMD practical

[10:38] <nothingmuch> look at my thread on the runtime linker

[10:39] <scook0> the scary long antihistamine-induced one?

[10:39] <nothingmuch> i don't think antihistamine caused that

[10:39] <nothingmuch> it may have degraded it =)

[10:39] <nothingmuch> but yes, the long one

[10:39] <nothingmuch> it briefly touches on how I see MMDs, the linker, static typing and the optimization pipeline getting along

[10:41] <scook0> but logically speaking, most MMD takes place on dynamic-type, right?

[10:41] <scook0> (even if in practice it might get optimised away)

[10:41] <nothingmuch> yes

[10:42] * scook0 claims victory! :)

[10:42] <nothingmuch> but it doesn't seem so close to the truth with this:

[10:42] <nothingmuch> my Dog $foo;

[10:42] <nothingmuch> my Cat $bar;

[10:42] <nothingmuch> fight($foo, $bar);

[10:43] <scook0> huh? (I don't see your point...)

[10:43] <nothingmuch> scook0: the "feeling" of dynamicity is lost here

[10:44] <nothingmuch> luqui: how stable is C::M::P?

[10:44] <wilx> What if you have multiple inheritance and more than one instance of one class in the inheritance graph? How does the multimethod pick one? Does that signal compile time/run time error?

[10:45] <nothingmuch> wilx: in my opinion yes

[10:45] <nothingmuch> in Damien's opinion manhatten distance wins

[10:45] <nothingmuch> we don't3 know yet

[10:46] <scook0> nothingmuch: but if you were to say `$foo = new Poodle`, then it would "feel" dynamic?

[10:46] <nothingmuch> scook0: yes =)

[10:46] <nothingmuch> or my $foo = shift;

[10:46] <nothingmuch> or my $foo = get_poodle;

[10:46] <nothingmuch> then type inferrence can make it really be my Poodle $foo = get_poodle;

[10:46] <scook0> I think we may be violently agreeing -- just a mismatch of personal terminology

[10:47] <nothingmuch> oh, i knew we were all along =)

[10:47] <nothingmuch> Can't locate Class/ultimethods/Pure.pm

[10:47] <nothingmuch> wow... ultimethods

[10:47] <nothingmuch> those must rock

[10:47] * scook0 wants an ultimethod

[10:47] <nothingmuch> i wonder what they do

[10:48] <scook0> (or what about penultimethods?)

[10:48] <nothingmuch> i don't even have a guess as to what that would mean

[10:48] <scook0> don't mention them on p6l, or somebody will try to figure it out!

[10:48] <nothingmuch> heh

[11:30] <wolverian> can we call methods by regex? $obj.*/foo/() # call all methods matching /foo/? 

[11:30] <wolverian> maybe that's a bad idea...

[11:38] <scook0> wolverian: probably a bad idea to make it that easy

[11:38] <scook0> but with the metamodel, it should at least be /possible/

[11:38] <wolverian> ObjectSpace>>.*/.*/; # hm...

[11:39] <scook0> wolverian: the question is, how long until it finds the permutation `0.exit()`? :)

[11:40] <wolverian> heh. that looks totally weird, by the way. 1.kill

[11:41] <scook0> $?SYSTEM.halt_and_catch_fire

[11:42] <scook0> "~/important_document.txt".unlink

[11:43] <scook0> lots of potential for catastrophe

[11:45] <scook0> ?eval 42

[11:45] <evalbot_6528> 42 

[11:45] <wolverian> I think the integers are more confusing

[11:45] <wolverian> 0.exit, 1.kill, etc.

[11:45] <scook0> ?eval use Test

[11:45] <evalbot_6528> pugs: *** No compatible subroutine found: "&use"     at tmp-Prelude.pm line 38, column 30-59 

[11:46] <scook0> hmm, does someone test something on a recent build for me?

[11:46] <scook0> (I'm getting weirdness on my local copy, and I want to know if it's my patch)

[11:46] <scook0> sorry, thinko -- can someone test something for me?

[12:00] <svnbot6> r6530 | scook0++ | * Merge some more code in Parser.hs

[13:08] <ycheng> I found it's interesting that in perl, access non-exist elements of an array will not stop the program.

[13:15] <nothingmuch> ycheng: search for autovivification

[13:16] * nothingmuch wants to burn something

[13:16] <nothingmuch> i've had it with character encodings!

[13:17] <wolverian> ?eval "foo " ~ ("a" & "c") ~ " bar"

[13:17] <evalbot_6528> 'foo a bar' 

[13:17] <nothingmuch> i'm so fucking sick and tired of endlessly dealing with this pointless nonsense!

[13:17] <wolverian> hm. that doesn't look right, but I don't know what it should be.

[13:17] <nothingmuch> ?eval "foo " ~ ("a" & "c")

[13:17] <evalbot_6528> 'foo a' 

[13:17] <nothingmuch> ?eval ("a" & "c") ~ " bar"

[13:18] <evalbot_6528> 'a bar' 

[13:18] <nothingmuch> hmm

[13:18] <nothingmuch> ?eval ("a" | "c") ~ " bar"

[13:18] <evalbot_6528> 'a bar' 

[13:18] <nothingmuch> odd

[13:18] <wolverian> I was just wondering whether '"<element>" ~ all(open("foo.txt").lines) ~ "</element>" would autothread the concatenation and create <element>..</element> for each line

[13:18] <nothingmuch> ?eval ("a" | "c")

[13:18] <evalbot_6528> 'a' 

[13:18] <nothingmuch> wolverian: it should

[13:18] <wolverian> that is brilliant.

[13:18] <nothingmuch> ?eval ("a" | "c").perl

[13:18] <evalbot_6528> '(\'a\' | \'c\')' 

[13:18] <nothingmuch> ?eval (("a" | "c") ~ " bar").perl

[13:18] <evalbot_6528> '(\'a bar\' | \'c bar\')' 

[13:18] <nothingmuch> okay, eval bot is just drunk

[13:18] <nothingmuch> it actually works

[13:19] <nothingmuch> ?eval 1|2

[13:19] <wolverian> yeah, I think he doesn't like outputting junctions

[13:19] <evalbot_6528> 1 

[13:19] <nothingmuch> does anybody know of any cache profiling tools?

[13:19] <nothingmuch> (l2 cache, that is)

[13:20] <ycheng> nothingmuch: thanks very much for that keyword !

[13:20] <nothingmuch> you're welcome

[13:21] <stevan> hola nothingmuch 

[13:21] <stevan> how is live in the construction zone

[13:23] <nothingmuch> hi ho

[13:24] <nothingmuch> stevan: yucky

[13:24] <nothingmuch> FUCKING CGI! FUCK YOU FUCK YUOU FUCK YOU!!!!!

[13:24] <elmex> nothingmuch: please

[13:24] <nothingmuch> sorry

[13:24] <stevan> your not using CGI.pm are you?

[13:24] <nothingmuch> Kwiki is

[13:24] <nothingmuch> =(

[13:24] <elmex> nothingmuch: i love fsck-speak :)

[13:25] <nothingmuch> kwiki uses a CGI function called query_string

[13:25] <stevan> ah,.. my sympathies

[13:25] <nothingmuch> which rejoines the parsed query string

[13:25] <stevan> yes

[13:25] <nothingmuch> somewhere in the way UTF8 is smashed to bits

[13:25] * stevan has had many text-encoding nightmares lately

[13:26] <nothingmuch> it needs to be unicode all the time

[13:26] <stevan> nothingmuch: look... you so offended elmex,.. he quit

[13:26] <nothingmuch> that's the only way to deal with it

[13:26] <stevan> nothingmuch: I tend to agree

[13:26] <nothingmuch> i'm truely sorry, but i'm on the verge of kicking my table

[13:26] <stevan> we had to deal with french text,.. which is fine in Latin-1,.. but all the data files were set to us as utf-8

[13:26] <stevan> and they were to big to convert

[13:27] <stevan> so we ended up with all this mixed up encodings

[13:27] <nothingmuch> why not stick to utf-8?

[13:27] <stevan> because the people who were doing the HTML were using Latin-1

[13:27] <nothingmuch> then those people should be spanked

[13:27] <stevan> and when I said utf-8,.. they said "what is that?"

[13:28] * stevan considered that

[13:28] <nothingmuch> isn't Latin-1 isa utf-8?

[13:28] <stevan> I have no idea,.. they did not seem to get along well

[13:28] <nothingmuch> =(

[13:28] <wolverian> no

[13:28] <nothingmuch> ascii isa utf-8?

[13:28] <stevan> it is almost over though,.. just one more week

[13:28] <stevan> then I can get back to the metamodel :)

[13:29] <wolverian> nothingmuch, 0-127 ascii corresponds to utf8, yes

[13:29] * stevan has been reading papers on sub-typing and generics to help ease the pain

[13:29] <wolverian> but latin-1, also called iso 8859-1 has 128-255, which do not correspond to utf-8

[13:29] <nothingmuch> to top it off i'm wroking through SSH and vim on the other end is so drunk i can't work

[13:29] <stevan> wolverian: I suspect the 128-255 is where all the funny french characters are then

[13:29] <wolverian> stevan, yes.

[13:29] <wolverian> same with finnish.

[13:30] <wolverian> it is annoying on IRC, since most people use mirc and it doesn't do utf8.

[13:30] <stevan> those were the ones which never seemed to mix properly

[13:30] <wolverian> stevan, they don't. you have to recode.

[13:30] <wolverian> (irssi supports it natively with /recode in 0.8.10 release candidates)

[13:30] <stevan> wolverian: yes,.. Encode was my friend :)

[13:30] <wolverian> right. :)

[13:30] <nothingmuch> why is CGI.pm so big?

[13:31] <stevan> that and gaal's DBD::Mysql patch

[13:31] <wolverian> nothingmuch, because it is horrible.

[13:31] <nothingmuch> why is it both OO and imperative?

[13:31] <stevan> nothingmuch: you should write your own version

[13:31] <stevan> then patch Kwiki :)

[13:31] <wolverian> if you're on apache, use the apache libs. if not, use CGI::Lite

[13:31] <nothingmuch> stevan: there are a ton of CGI things

[13:31] <nothingmuch> i don't want to do that

[13:32] <nothingmuch> i don't want to patch kwiki too, it takes too long to read ingy code

[13:32] * stevan was very much kidding :)

[13:32] <wolverian> or if you can't help it, use CGI::Simple as a drop-in replacement for CGI.pom

[13:32] <wolverian> er, s/pom/pm/

[13:32] <nothingmuch> too much inheritence

[13:32] <nothingmuch> wolverian: does it pollute the CGI namespace?

[13:32] <nothingmuch> because kwiki calls to CGI::query_string directly

[13:32] <stevan> nothingmuch: I think SocialText is hiring (Ingy's kwiki company)

[13:32] <wolverian> nothingmuch, augh.

[13:32] <wolverian> nothingmuch, no, it doesn't.

[13:32] <wolverian> it's also strictly OO only, I think.

[13:32] <nothingmuch> stevan: i don't want to hack kwiki for a living

[13:33] <stevan> nothingmuch: that is easily hacked around

[13:33] <nothingmuch> wolverian: then i'm screwed... I need to rewrite Kwiki:CGI

[13:33] <stevan> *CGI::query_string = sub { CGI::Special->querystring(@_) {

[13:33] <stevan> nothingmuch: but you would work with ingy ;)

[13:34] <nothingmuch> stevan: ugh....

[13:34] <stevan> :D

[13:34] <nothingmuch> (wrt to the hack with the sub)

[13:36] <Juerd> CGI as a namespace doesn't make sense for things concerning URIs.

[13:36] <Juerd> Query strings are not a CGI thing, they're a URI thing.

[13:37] <wolverian> can you reimplement junctions in perl6 trivially yourself?

[13:37] <Juerd> wolverian: Depends mostly on your definition of "trivial".

[13:37] <wolverian> Juerd, right. I'm wondering how to easily redispatch everything to the elements

[13:37] <wolverian> in the object

[13:38] <Juerd> I don't understand that sentence

[13:38] <Juerd> Or sentance. I never know.

[13:38] <wolverian> sentence. :)

[13:39] <wolverian> I mean: how does the junction object I construct easily run any operation performed on it on each of the elements it has instead?

[13:39] <wolverian> method override_all { ... } # :)

[13:40] <Juerd> I don't think that'll be easy

[13:41] <wolverian> hmm. new Proxy: FETCH => { for @element { ... } } ?

[13:43] <nothingmuch> oh god.... CGI::init could be fixed

[13:43] <nothingmuch> but it's soooo big and ugly

[13:43] <nothingmuch> someone please put a bullet in my head

[13:45] * nothingmuch gives up

[13:47] <wolverian> I just don't know how to do foo(1 & 2) => foo(1), foo(2)

[13:50] <nothingmuch> ?

[13:51] <wolverian> isn't that what the junction does? 

[13:52] <Juerd> nothingmuch: What are you doing with CGI stuff?

[13:52] <nothingmuch> Juerd: Kwiki is not supported hebrew usernames

[13:52] <Juerd> nothingmuch: So it's not Perl 6 related?

[13:52] <nothingmuch> the encodings get screwed

[13:52] <nothingmuch> no

[13:52] <Juerd> Okay

[13:53] <Juerd> I was very afraid you were porting CGI.pm literally.

[13:53] <Juerd> (Which is okay, but not using that name...)

[13:53] <nothingmuch> hell no, aankhen was doing a good job with all the good modules

[13:53] <nothingmuch> i think CGI.pm should be left to rot in perl 5 land

[13:54] * nothingmuch should have installed mediawiki instead

[13:54] <nothingmuch> but i was like "hmm... if I have to change something I prefer working with perl"

[13:54] <nothingmuch> which sucks, because all of the features I needed so far are supported by mediawiki

[14:10] * nothingmuch goes back to writing fun code3

[14:23] <nothingmuch> sest driven development saved whatever sanity i had left today...

[14:23] <nothingmuch> ciao, i'm going home!

[14:28] <svnbot6> r6531 | iblech++ | * Usual svn props.

[14:28] <svnbot6> r6531 | iblech++ | * New util/smokeserv/: Pugs Smoke Reports Server

[14:28] <svnbot6> r6531 | iblech++ |   * smokeserv-client.pl: Submits smokes to a smokeserv

[14:28] <svnbot6> r6531 | iblech++ |   * smokeserv-server.pl: The smokeserv (HTML template included)

[14:28] <svnbot6> r6531 | iblech++ |   * README

[14:28] <svnbot6> r6531 | iblech++ | * util/yaml_harness.pl: Include the path to pugs used in the smoke so the

[14:28] <svnbot6> r6531 | iblech++ |   smokeserv can easily differentiate between normal runcore/PIL-Run/PIL2JS.

[14:28] <svnbot6> r6531 | iblech++ | * pugs::hack: Add info how to submit a smoke to a smokeserv.

[14:29] <iblech> putter: smokeserver is up! :)

[14:29] <iblech> http://m19s28.vlinux.de/cgi-bin/pugs-smokeserv.pl

[14:29] <iblech>  Submitting your own smoke is easy, a "$ ./util/smokeserv/smokeserv-client.pl ./smoke.html"  should suffice.

[14:34] <iblech> (Help on the design is very much appreciated, BTW :))

[14:48] <stevan> iblech++

[14:48] <iblech> putter++ # his idea

[15:31] <svnbot6> r6532 | iblech++ | util/smokeserv/smokeserv-server.pl:

[15:31] <svnbot6> r6532 | iblech++ | * Very minor typo and XHTML validity fixes.

[15:31] <svnbot6> r6532 | iblech++ | * Obsolete smokes are now removed. The algorithm differentiates between

[15:31] <svnbot6> r6532 | iblech++ |   pugs_version, osname, and runcore, so it won't blindly delete smokes older

[15:31] <svnbot6> r6532 | iblech++ |   than n days.

[15:49] <svnbot6> r6533 | iblech++ | PIL2JS: PIL::Params: Fix invocant parameters wrongly being moved to the end of

[15:49] <svnbot6> r6533 | iblech++ | the fixed parameter list. reverse.t has a chance of passing now again.

[16:04] <putter> hey folks.

[16:04] <putter> iblech++

[16:04] * putter running smokes

[16:05] <iblech> Hi putter :)

[16:05] <xinming> iblech: you there please?

[16:06] <xinming> oops.

[16:06] <xinming> iblech: hmm, Did @Larry confirmed about the 'named parameters' passing?

[16:06] <xinming> iblech: for my test

[16:06] <xinming> wish I can do something before I go to BeiJing. :-P

[16:06] <iblech> xinming: Yes: You are not allowed to pass slurpies by name. I.e. sub foo (*@args) {}; foo(args => [...]) is bogus

[16:07] <putter> I wonder if it's time to give ext/ an explicit test/smoke inclusion flag.  MIME-Base64/t/Base64.t has been running for 15+ minutes, and actually am only interested in the core test suite at the moment.  (sometimes I just find ext/|grep '\.t$'|xargs rm ;)

[16:07] <xinming> iblech: and slurpy hash won't slurp the named params, right?

[16:08] <iblech> xinming: Right.

[16:08] <iblech> putter: You can use the PUGS_RUNTIME hack

[16:09] <xinming> sub foo ( $a, *%h ) { }; foo( a=> 'v', a=> 'u' ); will cause an error; and foo( a=>'v' ); works, but %h get nothing,

[16:09] <iblech> putter: See util/yaml_harness.pl:41

[16:09] <iblech> xinming: Right.

[16:09] * xinming bbl

[16:09] <QtPlatypus> putter: It shouldn't be taking that long.

[16:10] <putter> iblech: which reminds me, it might also be worth distinguishing (avoiding gc) on the summary line.  So if someone does an ext/-free smoke, like I am now, it doesnt smash one with.  or parrot-working vs not.

[16:10] * QtPlatypus will have to look at it tommrow morning to see if there is some bug in the code that is screwing it up, and I'll see if I can oplimise it.

[16:11] <putter> QtPlatypus: k.  it did seem odd.  thanks :)

[16:11] <putter> iblech: looking...

[16:12] <TheOddity> Hi, is this the right place to talk about perl threads?

[16:12] <TheOddity> 5.8.x

[16:12] <xinming> TheOddity: try #perl instead. :-)

[16:13] <xinming> TheOddity: that might be better for you.

[16:13] <iblech> putter: Yep. Will only need an addition to yaml_harness, testgraph.pl or run-smoke -- one of these scripts have to record the setting.

[16:17] <TheOddity> sorry to be such a pain, but I could not find #perl ?  #perl-es #perl.ch #perl.de #perl6 #perlcafe #perlchina #perlfr but not #perl. do i need to connect to a separate server for that?

[16:17] <svnbot6> r6534 | iblech++ | * t/rules/: Some more guards to skip the test if rules support is missing and

[16:17] <svnbot6> r6534 | iblech++ |   unCOMMENTED a previously hardfailing test.

[16:17] <svnbot6> r6534 | iblech++ | * PIL2JS:

[16:17] <svnbot6> r6534 | iblech++ |   * PIL::Params: Invocant parameters shouldn't be allowed to be passed by name.

[16:17] <svnbot6> r6534 | iblech++ |   * Prelude::JS::*: Extremenly minor misc. fixes.

[16:17] <iblech> TheOddity: Huh? on irc.freenode.net/#perl are 323 people currently

[16:19] <TheOddity> i'm using gaim, probably something wrong with the list-rooms function, will try to join room by specifying the room manually.

[16:19] <TheOddity> it works!!

[16:19] <TheOddity> thanks ..

[16:30] <iblech> food &

[16:31] <xinming> hmm, anyone here can tell me if there is way to ban the private message on advertisement?

[16:38] <putter> strawman proposal: create a "runpugs" wrapper script, in p5, which handles command line analysis, and knows where the various backends and repls are.  We could add it to pugs (which currently only knows about PIR, which it actually compiles), but perl seems preferable to haskell for this kind of hackery.  Thoughts?

[16:40] <Aankhen``> Hola!

[16:43] <xinming> iblech: hmm, sub func ( $n, *%h ) { }; func( 100, n => 100 )

[16:43] <xinming> iblech: what the result will be in this example?

[16:43] <xinming> iblech: hmm, sub func ( $n, *%h ) { }; func( 100, n => 200 )

[16:44] <xinming> an error or 200?

[16:47] <iblech> Aankhen``: Welcome back! :)

[16:48] <iblech> putter: re. Yep, I think Perl is more suited for that job, too

[16:48] <iblech> xinming: Your subbodies were both empty

[16:48] <Aankhen``> Thanks!

[16:48] <Aankhen``> How's things?

[16:49] <iblech> xinming: But anyway, $n will 200, and the dangling 100 will throw an error ("too any arguments passed to...")

[16:49] <xinming> :-)

[16:50] <iblech> Aankhen``: PIL2JS passes 74%, and PIL-Run is actively developed again

[16:50] <Aankhen``> Nice!

[16:50] <Aankhen``> Any progress on the Haskell backend? :-D

[16:51] <autrijus> no, because I was away with $work and moving to another house

[16:52] <Aankhen``> Ah, okay.

[16:52] <Aankhen``> And hi. :-D

[16:52] <autrijus> plus a bruising finger jammed by a random door, today

[16:52] <Aankhen``> Ow.

[16:52] <Aankhen``> Sounds painful.

[16:52] <autrijus> feels rather weird typing with nine fingers

[16:52] <autrijus> yeah. will heal tomorrow likely

[16:52] <putter> iblech: btw, re 74%, nothingmuch's smoke _is_ passing the :perl5 tests (just not the p6 rules tests).  so there is perhaps an extra ~10% when you want it.  basically just requires ~~ recognize whatever Prelude/JS/Rules.pm creates.

[16:52] <Aankhen``> My condolences. :-(

[16:53] <autrijus> thanks. :)

[16:53] <iblech> putter: ooh +10% :) I'll look into your Rules.pm today or tomorrow

[16:54] <autrijus> rehi all, btw. I'm delighted to have plenty of things to catch up every couple hours :)

[16:54] <autrijus> oh, and good news: my Perl-I18N talk in Euro OSCON is cancelled

[16:54] <autrijus> replaced by "Introduction to Pugs":)

[16:55] * Aankhen`` applauds!

[16:56] <putter> iblech: one ./util/smokeserv/smokeserv-client.pl ./smoke.html coming up...

[16:56] <iblech> putter, autrijus: ooh :)

[16:58] <autrijus> hm, I probably need a small project to acquaint myself with the p5 works

[16:59] <autrijus> say, what would take it to plug Inline::Pugs into the pilrun framework?

[16:59] <autrijus> or has it already been thought of?

[17:00] <pasteling> "Aankhen``" at 203.101.5.144 pasted "Build fails on Win32" (17 lines, 750B) at http://sial.org/pbot/12780

[17:01] <putter> iblech: is there a delay before an upload smoke shows up?

[17:02] <iblech> putter: No, shouldn't be. Did smokeserv-client.pl say something other than "success"? And was your util/yaml_harness.pl synced up?

[17:03] <putter> I synced up util (though I've been editing yaml_harness).  the client dumped html text at me.  looks vaguely like the text of your page.

[17:03] <iblech> putter: Checking

[17:03] <iblech> putter: I had this problem during debugging, but it magically disappeared

[17:05] <putter> autrijus: all the progress on pilrun has been fglock's.  I've just tried to keep the rest of it out of his way.  smoke coming up (in a while).

[17:05] <autrijus> understood

[17:05] <putter> re Inline::Pugs, do you mean p5 user code  use Inline::Pugs;  and get the metamodel, etc?

[17:05] <autrijus> yes.

[17:06] <iblech> putter: Problem (hopefully) fixed, try again please? :) (It was discarding your POST because the smoke was too big)

[17:10] <putter> Only two issues come to mind.  err, 3.  We kind of stomp on the p5 namespace (defining Int, Str, etc).  I don't think we have quite gotten to the bottom of what's a p5 method, is it a Method, etc.  So users should expect instability, and I'd hate to put any kind of crimp on stevan/flgock/etal making major changes.  And there is a GB-eating (deep recursion?) in pilrun or the mm which shows up on some test files.

[17:10] <putter> iblech: trying...

[17:12] <autrijus> okay. I'll do the wrapper thing first

[17:12] <iblech> putter: worked :)

[17:12] <autrijus> Fyi: require(P5Runtime/PrimP6.pm) - file not found at lib/Inline/../../perl5/PIL-Run/lib/PIL/Run/PrimP5.pm line 187.

[17:12] <autrijus> hm, what does this signify? something akin to :precomp needs to be done?

[17:13] <putter> hmm, you may be the windows sacrificial guinne pig.

[17:14] * putter will be intermittantly non-responsive over the coming minutes as memory hungry tests run...

[17:18] <putter> perl5.t giving PIL2JS indigestion...

[17:23] <svnbot6> r6535 | autrijus++ | * port Inline::Pugs to use the PIL-Run runtime.  So far this works:

[17:23] <svnbot6> r6535 | autrijus++ |     use Inline Pugs => q{

[17:23] <svnbot6> r6535 | autrijus++ |         sub intone { say "Hello, $_!" }

[17:23] <svnbot6> r6535 | autrijus++ |     };

[17:23] <svnbot6> r6535 | autrijus++ |     intone('World');

[17:39] <autrijus> seen fglock

[17:39] <autrijus> hm. I'll check back when I wake up.

[17:39] * autrijus sleeps &

[17:40] <putter> good night autrijus...

[17:40] <putter> ibech++!  :)  looks great.  more smokes coming...

[17:40] <putter> err, iblech++ ;)

[17:42] <iblech> Night autrijus :)

[17:42] <iblech> Thanks, putter++, for the idea :) 

[17:53] <putter> iblech: does a single js get used for multiple tests?  I have a js, now running for 12+ minutes, which has been slowly growing, now almost up to 1/2 GB.

[17:53] <svnbot6> r6536 | yiyihu++ | Change the test according to http://www.nntp.perl.org/group/perl.perl6.language/22883

[17:54] <iblech> putter: No

[17:54] <iblech> putter: 12+ min -- if you set PIL2JS_RESOURCE_GUARD=1, then all js's taking longer than 35s are killed by the kernel

[17:55] <putter> I may have broke something by ^Z'ing the test to get some swapping-free breathing room.

[17:55] <iblech> no, that shouldn't have changed anything

[17:55] <putter> do many tests exceed 35s?

[17:57] <xinming> ?eval [+][1,3,5]

[17:57] <evalbot_6528> (1, 3, 5) 

[17:58] <iblech> putter: At least on my machine (1.667 GHz, 512 MiB RAM) probably only the rules/ tests

[17:59] <putter> ok.  tnx.

[17:59] <iblech> xinming: "dies_ok { position_with_slurpy_hash1 n => 100, test => 40, 1, 3, 5, 7 }," -- why?

[18:01] <xinming> iblech: hold on please

[18:02] <iblech> xinming: Finished reading the rest -- looks correct :)

[18:02] <xinming> iblech: :-P forget to add 100 before (n => 100) pair. T_T

[18:03] <xinming> iblech: help me fix it please. :-)

[18:03] <iblech> xinming: Ah, ok, then it's correct :)

[18:04] <iblech> xinming: err, you mean forgot to add (n => 100) before the pair (n => 100), right?

[18:04] <xinming> dies_ok { position_with_slurpy_hash1 100, n => 100, test => 40, 1, 3, 5, 7 }

[18:05] <xinming> iblech: the comment above the test shows what I wisht o do. :-)

[18:06] <iblech> xinming: You've to add another n => "does not matter" to the arglist, or you've to s/dies_ok/lives_ok/

[18:07] <xinming> iblech: ...

[18:07] <xinming> bbl

[18:09] <xinming> ## `sub func ( $a, *%h ) { }; func 100, a => 200` should be an error

[18:09] <xinming> dies_ok { position_with_slurpy_hash1 n => 100, test => 40, 1, 3, 5, 7 },

[18:09] <xinming>   'Testing: passing positional parameter with pair which has the same key name.';

[18:10] <xinming> I mean, change this dies_ok { .. }...

[18:10] <xinming> to dies_ok { position_with_slurpy_hash1 100, n => 100, test => 40, 1, 3, 5, 7 }, ' ... ';

[18:10] <xinming> because you ever said that might raise an error.

[18:11] <ods15> evalbot_6528: say "a" for (1...);

[18:11] <ods15> err

[18:11] <ods15> ?eval say "a" for (1...);

[18:11] <evalbot_6528> pugs: out of memory (requested 1048576 bytes) 

[18:11] <ods15> ?eval $a = 1+2 for (1...);

[18:11] <evalbot_6528> pugs: out of memory (requested 1048576 bytes) 

[18:11] <ods15> ?eval $a = 1+2 while (1);

[18:11] <evalbot_6528> Error: Undeclared variable: "$a" 

[18:11] <ods15> ?eval my $a; $a = 1+2 while (1);

[18:12] <evalbot_6528> (no output)

[18:12] <ods15> did i break it?

[18:12] <ods15> ah, damn, smart :P

[18:12] <iblech> xinming: Right, "sub func ( $a, *%h ) { }; func 100, a => 200" should be an error, but &position_with_slurpy_hash1 has got an additional *@slurpy_array which accepts the additional "100"

[18:12] <iblech> ods15: evalbot is unbreakable :D

[18:12] <ods15> i've gotta find something :P

[18:12] <xinming> iblech: hmm,

[18:13] <ods15> ?eval say "hello\nworld"

[18:13] <evalbot_6528> hello world bool::true 

[18:13] <ods15> ?eval say "hello\nworld";

[18:13] <evalbot_6528> hello world bool::true 

[18:13] <iblech> ods15: It s:g/\n/ / :)

[18:14] <iblech> ?eval "\n" x 100  # would be many lines

[18:14] <evalbot_6528> '                                                                                                    ' 

[18:14] <xinming> iblech: Oh, Ok, thanks for reminding me this.

[18:14] <ods15> iblech: ya otherwise i could send irc commands

[18:14] <iblech> xinming: Sure. Thanks for fixing the rest of the test :)

[18:14] <ods15> say "bla\nquit"

[18:14] <iblech> ods15: And you could flood the channel

[18:15] <ods15> only if i did 'privmsg #perl6 :' after each \n ....

[18:15] <iblech> ods15: But no, that wouldn't be possibly, because Net::IRC is smarty enough and appends PRIVMSG #perl6 to each line

[18:15] <ods15> ay

[18:19] <xinming> iblech: by the way.

[18:20] <putter> ok, while that runs...

[18:20] <svnbot6> r6537 | putter++ | Consolidated ENV{PUGS_RUNTIME} hackery in run-smoke.  yaml_harness is now backend-clean.

[18:20] <svnbot6> r6537 | putter++ | yaml_harness.pl: --exclude now takes a regex pattern rather than a string, and it is applied to the path, not just the bare filename.

[18:20] <putter> iblech: is there a ~~ in piljs?

[18:20] <xinming> sub func ( $a, *%h ) { }; func( 100, x => 1, y => 2, 11, 12, 13 ); will this be an error?

[18:21] <xinming> I think so. :-)

[18:21] <iblech> xinming: Right, as there's no place where the 11,12,13 could go. It would work if you added a *@slurpy_array, though.

[18:26] <putter> ah well.  I tried smokeserv-client'ing a copy of Johnathan's smoke, so we would have something windows up, but got a error: The submitted smoke has an invalid format!

[18:27] <iblech> Right, as it doesn't contain a pugs-path-info

[18:28] <iblech> Only new copies of yaml_harness.pl include that field

[18:28] <iblech> (It is needed to associate a smoke with normal/PIL2JS/PIL-Run)

[18:28] <putter> Ok.  So in future we'll be able to use them.   good.

[18:28] <iblech> Right.

[18:29] <xinming> ?eval { sub foo { $_.say } }; foo( "haha" );

[18:29] <evalbot_6528> haha bool::true 

[18:29] <xinming> Is this a bug?

[18:29] <xinming>  sub is defined in a closure, how can it be "package" scoped?

[18:30] <putter> perhaps you meant  my sub ...

[18:30] <iblech> xinming: Pugs' behaviour is correct: sub foo {...} is really BEGIN { our &foo ::= sub {...} }

[18:30] <iblech> xinming: Thus all sub declarations are automatically package-scoped, unless you prefix them with "my"

[18:31] <iblech> ?eval { my sub foo { $_.say } }; foo( "haha" );

[18:31] <evalbot_6528> Error: No compatible subroutine found: "&foo" 

[18:38] <svnbot6> r6538 | putter++ | crude_repl.pl: added -w command line argument (ignored).  make smoke-perl5  again works.

[18:42] <putter> iblech: can spidermonkey do a system() call?  (google is proving unhelpful...)

[18:42] <iblech> putter: Not that I know of...

[18:43] <iblech> putter: At least the standard bin/js does not. I tried embedding spidermonkey in a P5 script (to provide printWithoutNewLine, sleep, etc.), but I got many segfaults

[18:44] * Aankh|Clone goes to sleep.

[18:44] <Aankh|Clone> See y'all in the morning.

[18:44] <Aankh|Clone> G'night.

[18:45] <iblech> Night Aankhen`` :)

[18:46] <putter> yeah, I dont see it in the source.  ah well, no parrot pge for p6 rules.

[18:47] <putter> g'night Aankhen``.  welcome back.

[18:47] <putter> iblech: you've seen the p5 cpan module to use spidermonkey?

[18:47] <iblech> putter: Right, I've used that

[18:49] <putter> wow.  dont think I've ever seen a 3GB perl process before.

[18:52] <iblech> I have seen some of them since PIL2JS was able to make smoke :)

[18:52] <putter> hmm, there seem to be two of them  http://search.cpan.org/~claesjac/JavaScript-0.55/  http://search.cpan.org/~mschilli/JavaScript-SpiderMonkey-0.11/

[18:53] <putter> the first seems under active development.

[18:53] <iblech> I took the first

[18:54] <putter> mmm... Inline::Pugs::JS  ... ;)

[18:54] <iblech> :)

[19:02] <putter> autrijus: btw, re one of your soft typing posts, one option I didnt see mention is the compiler emitting both simple and optimized code, and using observer hooks to invalidate the optimized version.

[19:07] <putter> JavaScript::SpiderMonkey make test works at least.

[19:09] <iblech> JavaScript.pm worked fine for small scripts -- but with the embedded Prelude (at that time ~~5000 lines), it segfaulted all the time...

[19:11] <putter> ;)  pugs, its not just perl6, it's a stress test.

[19:17] <fglock> hi all

[19:19] <iblech> Hi fglock

[19:27] <putter> woot.  JavaScript::SpiderMonkey handles a "commented out a couple of problematic lines" version of PIL2JS.js ! :)

[19:31] <pasteling> "puttern" at 66.30.119.55 pasted "non-functional diff to PIL2JS.js to run under JavaScript::SpiderMonkey" (76 lines, 2.1K) at http://sial.org/pbot/12782

[19:32] <putter> hi fglock.

[19:32] <fglock> hi putter

[19:36] <putter> "handles" as in "survives well enough to run trivial p5 callback at end".  none/little of the code was actually run.

[19:38] <svnbot6> r6539 | fglock++ | * PIL-Run - fixed lazy slices - @a[1..1000]=@a[1001..2000]

[19:39] <putter> fglock: have you seen iblech's new smoke server?  http://m19s28.vlinux.de/cgi-bin/pugs-smokeserv.pl

[19:40] <putter> iblech: I added a link from http://pugs.kwiki.org/?SmokedPugs

[19:41] <fglock> nice - are you placing PIL-Run there too?

[19:41] <putter> ha.  couldn't ask for a better straight-line.  smoke done.  uploading...

[19:42] <iblech> putter: Thanks :)

[19:42] <iblech> :D

[19:42] <putter> :( error: The submitted smoke has an invalid format!

[19:43] <putter> Hmm, no pugs-path-info field...

[19:43] <iblech> old yaml_harness.pl?

[19:44] <putter> nope, brand new recently edited and commited yaml_harness.  maybe I broke something?

[19:45] <iblech> checking...

[19:47] <iblech> hm, your commit seems sane

[19:48] <iblech> manually add "pugs-path: something/PIL-Run/something" so you can upload it?

[19:49] <iblech> but yaml_harness should add pugs-path, hm

[19:49] <putter> I see a $Config{"pugs-path"}, is that what should be doing it?

[19:49] <iblech> Right.

[19:49] <putter> $Config{"pugs-path"} = $ENV{HARNESS_PERL};

[19:49] <putter> hmm, no other action required...?

[19:50] <iblech> I think so. At least, it worked when you and I tested it

[19:50] <putter> I see pugs-path in the config: in the smoke file.  where does the -info come in?

[19:51] <iblech> ERR! I misread your "Hmm, no pugs-path-info field..." as no pugs-path (without -info)

[19:51] <iblech> -info is not necessary

[19:52] <iblech> Could you nopaste the header section from the smoke.html please?

[19:52] <putter> pasting...

[19:52] <xinming> ?eval { my foo { 'a'.say } foo;} { my foo { 'b'.say } foo;}]

[19:52] <evalbot_6528> Error:  unexpected "{" expecting variable name or "(" 

[19:52] <xinming> ?eval { my foo { 'a'.say } foo;} { my foo { 'b'.say } foo;}

[19:52] <evalbot_6528> Error:  unexpected "{" expecting variable name or "(" 

[19:52] <xinming> ?eval { my foo { 'a'.say } foo;}; { my foo { 'b'.say } foo;}

[19:52] <evalbot_6528> Error:  unexpected "{" expecting variable name or "(" 

[19:52] <iblech> xinming: You need the "sub" keyword -- my *sub* foo {...

[19:53] <xinming> ?eval { my sub foo { 'a'.say } foo;}; { my sub foo { 'b'.say } foo;}

[19:53] <evalbot_6528> a b bool::true 

[19:53] <wolverian> er, should that output anything actually? I thought bare { }s are closures now

[19:53] <pasteling> "putter" at 66.30.119.55 pasted "requested smoke-perl5 header section" (27 lines, 697B) at http://sial.org/pbot/12783

[19:53] <wolverian> or are they called automatically in void context?

[19:54] <iblech> wolverian: Right, they're called automatically

[19:54] <wolverian> I don't know if I like that.

[19:54] <wolverian> sub foo { { ... } } foo; # calls the inner closure?

[19:54] <iblech> wolverian: Right, you need "return {...}" if you want to return the closure

[19:55] <wolverian> ew.

[19:55] <wolverian> that feels exceedingly ugly.

[19:55] <iblech> putter: I changed smokeserv-server.pl to be a bit more verbose -- could you try uploading it again?

[19:56] <putter> uploading...

[19:56] <xinming> ?eval sub foo(+$n, *%h, *@a){ @a.sum }; foo 1, x => 20, y => 300, 4000;

[19:56] <evalbot_6528> 4000 

[19:56] <xinming> is it a bug?

[19:56] <iblech> wolverian: If you want blocks, there's no way around it -- or do you want to type "{ my $a... }()" (with the ()) all the time?

[19:56] <xinming> named param act the same as positional

[19:56] <putter> error: The submitted smoke has an invalid format![[summary!runcore!duration!pugs_revision!]]

[19:56] <iblech> xinming: It is

[19:56] <wolverian> iblech, do { }

[19:57] <iblech> putter: Aha! It lacks the osname!

[19:57] <xinming> iblech: oh, I ever thought there might be something wrong with my test.

[19:57] <iblech> putter: Should I $osname ||= "(unknown)"?

[19:57] <xinming> and even think that the bug is about function scope

[19:58] <wolverian> iblech, I don't like that I have to remember that closures are a special case when you return them from a function

[19:58] <wolverian> iblech, it feels like perl5

[19:58] <putter> hmm.  smoke complains each time I run it that I should do something with a configure file, or give it an --anonymous option.  neither of which are easy enough to have been pursued.  could that be part of the problem?

[19:59] <iblech> putter: That should only be relevant if you want your name to be included in the smoke.html

[19:59] <fglock> PIL-Run thinks (1..2,5) is ((1,2),5)

[19:59] <svnbot6> r6540 | fglock++ | * perl5/Array - fixed "@a[4..5]=6"

[19:59] <iblech> putter: I've fixed smokeserv, try again please? :)

[20:00] <iblech> fglock: Probably because * in subroutine signatures isn't implement correctly (as &infix:<,> has a signature of (*@things))

[20:00] <putter> iblech: "unknown" isnt a fix... something about smoke is broken...

[20:00] <iblech> fglock: * has to flatten arrays

[20:00] <putter> its a workaround...

[20:00] <iblech> putter: right...

[20:00] <putter> uploading anyway...

[20:01] <putter> error: The submitted smoke has an invalid format![[summary!runcore!duration!pugs_revision!]]

[20:01] <putter> why dont I paste the entire beginning of the file, so you can easily test?

[20:02] <iblech> You're definitely right, it's something weird with the smoke system

[20:02] <iblech> pugs_version wasn't set

[20:02] <iblech> oooh!

[20:02] <iblech> I know why!

[20:03] <iblech> build_info: &quot;--version unimplemented\n&quot;

[20:03] <iblech> It's crude_repl

[20:03] <putter> ?

[20:03] <iblech> the run-smoke calls $pugs --version to get the build info

[20:03] <iblech> osname, version number, etc.

[20:03] <putter> ahhhhhh.

[20:03] <putter> fixing...

[20:03] <iblech> :)

[20:03] <iblech> putter++

[20:04] <putter> err, but pugs --version doesnt have osname...??

[20:05] <putter> does say  Version: 6.2.9 (r6531)  

[20:05] <iblech> hrm

[20:05] <iblech> right.

[20:05] <iblech> looking...

[20:06] <iblech> ah, it calls -V

[20:06] <iblech> see yaml_harness.pl:121

[20:06] <iblech>     $self->{_build_info} = join '', qx{$executable -V};

[20:06] <putter> ahh, not --version, but -V

[20:07] <putter> ok, I'll fudge that.  use pugs's -V.  what does js smoke do?

[20:08] <iblech> pugs-smokejs.pl proxies most calls to the real pugs

[20:08] <putter> ok

[20:08] <iblech> only pugs-smokejs.pl pugs -w t/foo/bla.t is handed over to PIL2JS

[20:11] <svnbot6> r6541 | fglock++ | * PIL-Run - p6_from_a has a signature of *@a

[20:11] <svnbot6> r6541 | fglock++ |   - this fixes <,> - @a[1..2,5]=@b works now

[20:12] <fglock> bbiab

[20:16] <putter> I fixed crude_repl, and hand patched smoke-perl5.html with the output.  uploaded....

[20:16] <putter> works! :)

[20:17] <putter> Duration a bit arbitrary.  Took me a while to notice one of the tests is currently non-terminating.

[20:17] <svnbot6> r6542 | putter++ | crude_repl.pm: -V passed on to pugs.  The version information is used by smoke.

[20:17] <iblech> :)

[20:18] <iblech> Great!

[20:18] <putter> smoke-pir in progress... ;)

[20:20] <putter> iblech: spiffy site.

[20:20] <iblech> Hm, problem: pugs-path is "./pugs" with make smoke-pir

[20:21] <iblech> Fixed, testing

[20:23] <svnbot6> r6543 | yiyihu++ | Correct some mistake I made. Rewrite Part of test, which makes it clear... (to me at least)

[20:25] <iblech> fix doesn't work...

[20:25] <putter> the smoke is running far too well... I suspect its not -BPIR.

[20:26] <putter> looks like Makefile passes -BPIR to run_smoke.pl.  exploring...

[20:26] <iblech> Hm, it seems $optional_args doesn't get used

[20:27] <iblech> Probably changing line 17 of run-smoke.pl to include $optional_args suffices

[20:27] <xinming> iblech: which line please? :-)

[20:27] <iblech> xinming: Hm? I meant line 17 of run-smoke.pl (not your test)

[20:27] <xinming> I am watching for your feedback. ;-)

[20:28] <xinming> iblech: oh,Ok, hmm, Need to take a shower. bbl.

[20:28] <putter> yes, fix in.

[20:28] <svnbot6> r6544 | putter++ | run_smoke.pl: was ignoring optional command line arguments.  so make smoke-pir wasnt -BPIR.  Fixed.

[20:28] <iblech> xinming: Ah :)

[20:29] <putter> or not fixed...

[20:30] <putter> ah, Null PMC access.  fixed! :)

[20:32] <iblech> :)

[20:32] <putter> So, iblech.  (putter briefly dons "interviewer" hat), what are your plans for PIL2JS?

[20:33] <putter> ;)

[20:33] <iblech> My goal for the very near feature is to make .pairs work again.

[20:33] <putter> lol

[20:34] <iblech> Really, PIL2JS is still a fun-only project, I don't have any real plans :)

[20:36] <putter> Quite a remarkable fun-only project.  Did you think it would get as far as it has when you started?

[20:37] * putter notes that if not for rules support, with its unusual number of tests, PIL2JS would be neck and neck with the pugs backend...

[20:38] <iblech> Thanks :) No, absolutely not. The prototype was a 400 line long script, and it worked, then I wanted to pass 01-sanity, then mandel.p6, then Test.pm, and suddely PIL2JS passed 74% :)

[20:38] <putter> And that's doing things well enough to make up for not receiving any oo data from pugs via pil.

[20:39] <putter> :)

[20:40] <obra> how fast is PIL2JS running these days?

[20:40] <putter> So perl6 may someday be a JSAN module? ;)

[20:41] <iblech> obra: A complete smoke (without ext/), with a guard so no test may take longer than 35s, takes ~~44min.

[20:41] <iblech> obra: I.e., it's probably half as fast as normal Pugs

[20:42] <obra> nod

[20:43] <iblech> obra: It used to be much faster (before the CPS change), but without CPS, PIL2JS couldn't have continuations (and thus proper &return, coroutines, gather/take, &sleep, etc.)

[20:43] <obra> *nod*

[20:43] <iblech> obra: If JavaScript had goto, PIL2JS would be at least twice as fast as it is now.

[20:44] <obra> does the next rev of js?

[20:44] <iblech> Not that I know of.

[20:44] <obra> 16:41 <iblech> obra: I.e., it's probably half as fast as normal Pugs

[20:44] <obra> 16:43 <iblech> obra: If JavaScript had goto, PIL2JS would be at least twice as fast as it is now.

[20:44] <obra> Those statements taken together scare me ;)

[20:44] <iblech> ;)

[20:47] <clkao> mad iblech

[20:50] <iblech> putter: I wonder if PIL-Run passes more tests than PIR :D

[20:52] <xinming> back

[20:53] <xinming> iblech: do you think test is much bettter? :-P

[20:53] <iblech> xinming: Sorry, haven't looked

[20:53] <iblech> xinming: (Making .pairs in PIL2JS work again :))

[20:54] <xinming> iblech: hmm, well, It's Ok, Just wish to make my test better.

[20:55] <xinming> I need to sleep now, If you think there is any place which can be improved, please let me know.

[20:55] <xinming> :-)

[20:55] <xinming> bye all

[20:55] <putter> iblech: almost certainly.  smoke in progress... ;)

[20:56] <putter> bye xinming

[20:56] <iblech> Night xinming :)

[20:56] <iblech> putter: :)

[21:03] <iblech> Yay! .pairs fixed! :) (PIL2JS have had this bug for three weeks)

[21:04] <putter> oh my.  like wow.  hey iblech.  working pairs++.  how would you like to run them linked with perl5?

[21:06] <putter> say "Hello, world" just ran in a test-jig...

[21:06] <putter> !!!

[21:07] <putter> Sorry.  Got distracted.  Yay!  .pairs fixed!  :-)

[21:09] <putter> ./runjs.pl -e 'say "hi from linked monkey"'

[21:09] <putter> # Number of lexical scopes: 1

[21:09] <putter> Skipping &*END.

[21:09] <putter> hi from linked monkey

[21:09] <putter> #IGNORE NEXT LINEFEED#

[21:09] <putter> 1..0

[21:09] <putter> #IGNORE NEXT LINEFEED#

[21:09] <iblech> ooooh! :)

[21:09] <iblech> No segfaults! :)

[21:11] <pasteling> "putter" at 66.30.119.55 pasted "run_js_on_jssm" (13 lines, 368B) at http://sial.org/pbot/12784

[21:11] <putter> oops, left the "write to file" debugging line in.

[21:12] <leo_> [ot]  PyPy runs on its own! Hurray!. - PyPy release 0.7.0

[21:12] <putter> JavaScript::SpiderMonkey rather than JavaScript.pm.   There are two reasons for a module...

[21:12] <leo_> - but a bit related ;-)

[21:12] <putter> leo_: !! huzzah! :)

[21:14] <iblech> putter: Can you try running a bigger script (say, t/builtins/lists/elems.t)? If it doesn't segfault, check it in please :)

[21:15] <putter> iblech: testing...

[21:17] <putter> a moment of paranoia... are Test runs now independent?  (I'd hate to stomp on the takes-a-long-time PIR smoke...)

[21:18] <iblech> I think they are. And I think that all tests which do IO (= which could interfer) won't run under -BPIR

[21:18] <putter> ah, what the hell...  array/elems.t  12 for 12! :)

[21:20] <putter> what's a harder one...?

[21:20] <putter> ;)

[21:21] <iblech> Wow!

[21:21] <iblech> arith.t

[21:21] <putter> testing...

[21:21] <iblech> this one should take relatively much memory

[21:22] <iblech> I.e. it's a good stress test

[21:24] <putter> ReferenceError: _26main_3a_3atryeq is not defined ?

[21:28] <iblech> Works fine here...

[21:28] <svnbot6> r6545 | iblech++ | Pairs should stringify to "$key\t$value", per the

[21:28] <svnbot6> r6545 | iblech++ | pairs-behave-like-one-elem-hashes. Modified

[21:28] <svnbot6> r6545 | iblech++ | t/builtins/arrays_and_hashes/pairs.t and t/data_types/pair.t accordingly.

[21:28] <svnbot6> r6546 | iblech++ | PIL2JS: Fix the long-standing bug of .pairs not working.

[21:28] <svnbot6> r6546 | iblech++ | * PIL2JS.js: Repair %hash = @array

[21:28] <svnbot6> r6546 | iblech++ | * PIL2JS.js: Croak on unknown container combinations

[21:28] <svnbot6> r6546 | iblech++ | * PIL2JS.js: Make $foo := $bar call $foo's .STORE **with an invocant**.

[21:28] <putter> I get the same error, modulo the extra #IGNORE NEXT LINEFEED#s, with normal run_js().

[21:29] <putter> js gets over 1GB big doing arith.t!

[21:29] * putter svn up's

[21:30] <iblech> Hm, weird. Do you get the error at the very beginning or later on?

[21:30] <putter> very later on.

[21:31] <putter> has actually printed the 1..183.  error is the next line show.

[21:32] <iblech> Very weird. &tryeq is used at the very beginning, so it should not die later on

[21:33] <iblech> ("_26main_3a_3atryeq is not defined" == "&tryeq not declared")

[21:34] <iblech> d'oh, misread you.

[21:34] <pasteling> "putter" at 66.30.119.55 pasted "runjs arith.t error message" (15 lines, 1.2K) at http://sial.org/pbot/12786

[21:35] <iblech> It has to have do to something with your modifications, as arith.t runs fine here (I ^Ced after ok 117)

[21:36] <iblech> Hm, I don't have any local modifications ATM either...

[21:39] <iblech> BTW, the huge memory usage of pil2js.pl may be because of a bug in perl5 -- I've found at least one bug (lib/PIL/PApp.pm:146 -- a lone "$self;" changes things), so it's possibly that some internal state is b0rked

[21:40] <svnbot6> r6547 | putter++ | PIL2JS - JavaScript::SpiderMonkey support

[21:40] <iblech> oooh /me goes to look

[21:42] <putter> I svn up -r6546 .  Same error.  Could it be a PATH problem?  Ie, a file not loaded?  Do you normally invoke runjs elsewhere?  Puzzled...

[21:44] <putter> well, smoke-pir is quite boring. :/

[21:46] <wilx> How do you run the JS tests? 

[21:46] <wilx> Just with Firefox?

[21:46] <iblech> putter: I normally run runjs.pl from perl5/PIL2JS/, but that shouldn't be a problem.

[21:46] <iblech> putter: Want to send me the .js runjs would execute?

[21:46] <putter> uploaded.  those %ok are very misleading.  PIR choked on almost every test.  but of those few it didnt, it got some oks.  just not the right thing...

[21:46] <iblech> wilx: make smoke-js

[21:47] <putter> does make test-js work now?

[21:48] <putter> iblech: all 1.6MB of it?

[21:49] <putter> ok, make test-js isnt working yet.  t/01-sanity/01-tap.................................pugs: user error (Cannot generate code for Js).  so just make smoke-js.  or running the tests individually.

[21:51] <putter> iblech: there is a 

[21:52] <putter> var _26Test_3a_3atryeq  but no var _26main_3a_3atryeq.

[21:52] <iblech> 23:48 < iblech> putter: WRT PIR -- the two tests which work are both run at compile-time, 

[21:52] <iblech>                 the runtime doesn't have anything to do...

[21:52] <iblech> 23:48 < iblech> putter: Haven't tested

[21:53] <iblech> 23:48 < iblech> putter: No, it doesn't know about -BJS

[21:54] * putter tries to decode iblech's post...

[21:54] <iblech> I mean, the only test PIR passes are exit_in_check.t and exit_in_begin.t

[21:54] <putter> got it.

[21:55] <putter> ;)

[21:55] <putter> so,  _26Test_3a_3atryeq is defined, and used once or twice.  _26main_3a_3atryeq isnt defined, but is used a lot.

[21:56] <iblech> That's weird. But I do have an assumption:

[21:56] <iblech> Try ./pugs-smokejs.pl pugs -w ../../t/operators/arith.t

[21:56] <iblech> This is the same as runjs, but uses the precompiled Test.pm

[21:57] <iblech> (And I tested arith.t using pugs-smokejs.pl)

[21:58] <iblech> It's possible that somehow, PIL gives PIL2JS wrong sub names -- it prefixes the "tryeq" with "Test::", probably because it doesn't get that it has left Test.pm's namespace

[21:59] <iblech> I.e. it thinks the declaration of tryeq is still in the "Test" namespace

[21:59] <putter> ok, ./pugs-smokejs.pl pugs -w ../../t/operators/arith.t  worked.

[21:59] <putter> ??

[22:00] <iblech> ok, assumption confirmed :)

[22:00] <putter> :)

[22:00] <iblech> To summarize: Pugs thinks "module Test {...}; sub tryeq {...}" really means "module Test { ...; sub tryeq {...} }"

[22:00] <iblech> (but Pugs is wrong.)

[22:02] <putter> And in answer to your long-ago question... JS::SM  does arith.t! :)

[22:02] <iblech> :))

[22:02] <iblech> putter++

[22:02] <iblech> putter++

[22:03] <putter> use Inline::Pugs is definitely going to need some options now... ;)

[22:04] <iblech> :D

[22:05] <putter> I suppose the right thing is runjs or something taking a --compile-to-js -o -  and then doing the rest in some p5 module?

[22:06] <putter> oh, no. there isnt any reason to have a separate process.  a PIL2JS module?

[22:07] <iblech> There's jsbin_hack(compile_perl6_to_standalone_js("-e", $code))

[22:07] <putter> use PIL2JS;  PIL2JS::compile_p6_to_js() ?

[22:07] <putter> ah.

[22:14] <putter> perl -Ilib -we 'use PIL2JS; PIL2JS::eval_p6(q/say "hi"/);'

[22:16] <iblech> Hm, but I don't see a possibility of "PIL2JS::eval_p6(q/sub foo {...}/); foo(...)" working

[22:16] <iblech> Unless we use IPC, similar to how Pugs communicates with an external Parrot

[22:20] <putter> is there a mechanism for js to wait on/watch an object?  the JSSM api lets one modify objects in the (I assume) running runtime.

[22:21] <iblech> Err. Ignore what I said. I forgot JS can run in the same process as the main P5 program now.

[22:21] <iblech> In this case, I see the possibililty of it working :)

[22:21] <putter> ;)

[22:22] <iblech> ok, clearly I need to sleep now ;)

[22:22] <iblech> Night all! :)

[22:22] <putter> though perhaps PIL2JS should just provide code, rather than eval and such.  else you have to worry about multiple $js instances, throwaway vs persistant, etc.

[22:22] <putter> ok,

[22:22] <putter> good night iblech!

[22:23] <putter> Fun day.  Thanks!

[23:04] <fglock> putter: ping

[23:08] <putter> pong

[23:08] <putter> fglock: pong

[23:09] <fglock> hi putter

[23:09] <fglock> how are the tests going?

[23:09] <putter> hi

[23:09] <putter> tests? 

[23:10] <putter> There is now a smoke-all on iblech's server...?

[23:10] <fglock> you were trying to make Test work on PIR-Run?

[23:12] <putter> briefly.  ;)  PIL-Run currently uses its own Test.pm in its lib6.

[23:13] <putter> basically,

[23:13] <fglock> maybe I'll write some tests with lazy arrays - but I'll need some way to time-out the failing tests

[23:15] <putter> ok, that should be easy to add... working..

[23:19] <fglock> I'll take a look on making hashes work 

[23:28] <putter> fglock: 6548 has a --timeout argument.  it may even work.  hmm, perhaps an ENV variable would be easier to use with make smoke, etc?

[23:29] <fglock> thanks - I'll check it

[23:30] <putter> 6549 has a PUGS_HACK_TIMEOUT env var.

[23:30] <svnbot6> r6548 | putter++ | crude_repl.pl: new --timeout Nsec argument.

[23:30] <svnbot6> r6549 | putter++ | crude_repl.pl: can also set timeout with an environment variable.

[23:30] <svnbot6> r6550 | fglock++ | * perl5/Value - Pair stringifies

[23:35] <fglock> should I use the t/ directory?

[23:35] <fglock> PIL-Run/t

[23:40] <putter> err...

[23:41] <putter> whatever is easiest.  the perl5/ slushpile needs to go away, but for now, I guess, whereever.

[23:42] <fglock> maybe pugs/t ? the problem is that pugs doesn't implement lazy lists, and will loop forever

[23:42] <putter> ahh.

[23:42] <putter> hmm, maybe crude_repl should define a "you are running on X backend" variable?

[23:43] <putter> then the test can be if X'ed.

[23:44] <fglock> $?BACKEND ?

[23:44] <putter> eh, howabout pilrun t/ for now, and then we'll deal with the integration as part of perl5/ going away...?

[23:44] <putter> (the "eh" was for the concept - you subsequent suggestion, $?BACKEND, is plausible)

[23:45] <putter> does JS do lazy, or only P5?

[23:47] <fglock> don't know

[23:49] <fglock> I'm trying to implement postfix:<...> - Inf works, but 1..Inf gives an empty list

[23:49] <putter> err, whats the name of some $?FOO variable?  (putter has to leave rsn and is drawing a blank)

[23:50] <fglock> ?

[23:50] <putter> got it.  Run.hs.  tnx

[23:57] <fglock> bbiab &

[23:58] <putter> fglock: 6552.

[23:59] <putter> good night &

