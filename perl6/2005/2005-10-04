[00:02] <kolbsoft> hello

[00:04] <kolbsoft> is this channel active?

[00:08] <QtPlatypus> Mostly not

[05:45] <stevan> autrijus: ping

[05:50] <obra> stevan: you're on planetsix.perlfoundation.org now

[05:52] <stevan> obra: I am?

[05:52] <stevan> what part of me?

[05:53] <obra> autrijus said you had a journal relevant to perl6 ;)

[05:53] <stevan> ah,.. 

[05:53] <stevan> hmmm, this means I need to do some more journalling then :)

[05:53] <obra> :)

[05:53] <stevan> thanks :)

[05:55] <obra> If you know of any other willing victims, tell me :)

[05:56] <stevan> geoffb wrote some stuff on Perl 6 in his OReilly blog,.. but I am not sure how willing he is,.. and how relevant it will always be

[05:57] <stevan> other than that, most of the "journaling" takes place in the commit logs  

[05:57] <obra> *nod* and part of the problem is that commits are too noisy to get aggregated directly

[08:14] <wolverian> Juerd++ # irssi on feather 

[08:16] <svnbot6> r7251 | autrijus++ | * Be a bit more win32-friendly and suggest "perl smokeserv-client.pl"

[08:16] <svnbot6> r7251 | autrijus++ |   instead of "./util/smokeserv/smokeserv-client.pl"

[08:16] <svnbot6> r7252 | autrijus++ | * Heffalump pointed out that type synonyms can be overapplied,

[08:16] <svnbot6> r7252 | autrijus++ |   so we don't need the "Eval" vs "EvalMonad" split.

[08:33] <wolverian> argh, why does solaris have to be so WEIRD

[08:44] <Alias_> hi hi

[08:45] <Alias_> A question: What does $foo mean in Perl 6. That is, is the twigil implicit?

[08:45] <autrijus> greetings

[08:45] <autrijus> $foo carries no twigil; twigil is not mandatory.

[08:45] <Alias_> So all this talk of twigils is only really "when you care"?

[08:45] <Alias_> So mostly 1% stuff?

[08:46] <autrijus> in OO code, was was written as

[08:46] <autrijus> $self->{foo}

[08:46] <autrijus> will now be written as $.foo

[08:46] <autrijus> which is a common case

[08:46] <Alias_> I meant more the other stuff... globals vs lexical vs compile-time etc etc... all the weird ones

[08:46] <Alias_> for a simple scalar

[08:47] <Alias_> (or whatever it was)

[08:47] <Alias_> $?FOO etc?

[08:47] <gaal> ?eval $?PUGS_VERSION

[08:47] <evalbot_7252> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r7252)' 

[08:47] <gaal> those are magicals, mostly.

[08:47] <gaal> ? means compile time

[08:48] <Alias_> OK, so answer my question again :)

[08:48] <gaal> * means (global) runtime, for example %*ENV

[08:48] <Alias_> You CAN create and use your own right?

[08:48] <gaal> ?eval $*always = "yes"; class Other; $*always

[08:48] <evalbot_7252> \'yes' 

[08:49] <Alias_> I'm presuming you can create and use a compile-time variable of you own and then it errors at run-time if you try to modify it...

[08:49] <autrijus> see quickref :)

[08:49] <Alias_> And that will be happening in a haskelly lots of magically optimising way?

[08:49] <Alias_> currying etc

[08:50] <Alias_> So you can do platform detection and alternative path handling or what have you at compile time, and it will be nice and fast at run-time?

[08:50] <autrijus> thing though is that compile time and runtime may on different machines

[08:50] <Alias_> define vary

[08:50] <Alias_> I would assume if you "compile" the program, it will no longer work on other types of platforms?

[08:51] <Alias_> in the same was as you compile C?

[08:51] <Alias_> Or does compile mean to compile to intermediate language

[08:51] <gaal> we have a virtual machine :)

[08:51] <Alias_> gaal: Oh really? Does it implement Path::Spec->updir?

[08:51] <Alias_> (or the functional equivalent)

[08:52] <Alias_> or catdir etc?

[08:52] <Alias_> or File::HomeDir?

[08:52] <kgftr|konobi> Class::Path++

[08:52] <gaal> we have a virtual machine that doesn't have all the functionality the underlying OS might have

[08:52] <gaal> so if you need those things, indeed you'll have a dependency.

[08:52] <Alias_> Right, so having a virtual machine is not relevant to platform-level compilation issues

[08:52] <Alias_> except at the most basic level

[08:53] <gaal> if you want them resolved at compile time, which you might in fact not want exactly because of these issues?

[08:54] <Alias_> gaal: Well, it's all going to depend what compile means

[08:54] <gaal> i doubt optimization matters much if you're doing IO

[08:54] <gaal> (i mean that level of optimization)

[08:54] <Alias_> A lot of the code in platform-specific places is a lot slower that it could be because it's got EBCIC and mac and whatever special cases all though it

[08:54] <Alias_> I'm wondering if the explicit compile-ness and haskelisation of things is going to mean that stuff finally gets compiled out at compile-time

[08:55] <Alias_> It's also memory...

[08:56] <Alias_> all that code that hangs around because of a condition that will never be true

[08:57] <gaal> autrijus: feature suggestion for the openfoundry web interface: when viewing a revision, a link to the diff with the previous revision. who do i suggest this to? :)

[08:57] <gaal> Alias_: you can put what you like in BEGIN and it'll be resolved then.. but of course that's a payoff against compatibility.

[08:58] <Alias_> True, but so far we don't actually DEFINE BEGIN

[08:58] <gaal> we don't?

[08:58] <Alias_> I had hoped with all this extra focus, Perl 6 would somehow we defining it better

[08:58] <autrijus> gaal: it's SVK::Web

[08:58] <autrijus> so, patch to clkao on cpan

[08:58] <gaal> autrijus: thanks

[08:58] <Alias_> In Perl 5, it means for this machine

[08:59] <Alias_> gaal: When is it defined as happening for Perl 6

[08:59] <Alias_> What types of optimisations should I or should I not have in it?

[08:59] <gaal> Alias_: on p5 it's "for this machine" because there's no separate compilation

[08:59] <Alias_> EXACTLY!

[08:59] <Alias_> And for Perl ^?

[09:00] <Alias_> perl 6? How does it deal with that

[09:00] <wolverian> don't the AES specify this?

[09:00] <Alias_> Does it mean I have to make BEGIN have no platform stuff any more?

[09:00] <gaal> "this machine and others sufficiently like it that you won't have platform issues, and we hope you know what you're doing", i think.

[09:00] <Alias_> Is Perl 6 going to thus be less optimised

[09:00] <Alias_> define "sufficiently like it"

[09:01] <Alias_> is it specifiable? is it testable?

[09:01] <gaal> i don't think it's sufficiently defined, because parrot hasn't been fully specced yet. practicallty speaking, compatibility might look like it does in p5

[09:02] <Alias_> I doubt that very very much

[09:02] <gaal> with the bonus of being able to stipulate parrot.

[09:02] <Alias_> I already can't assume which other modules are loaded it would appear

[09:03] <Alias_> So C< if ( loaded(goodmodule) ) { goodmodule->doitright } else { cludgyway() }  > is out in Perl 6

[09:03] <Alias_> s/good/optional/

[09:03] <gaal> i don't understand

[09:03] <Alias_> You can't do anything about %INC or @INC or %ENV

[09:04] <broquaint> Sure you can.

[09:04] <Alias_> Because on different machines, that might not be true

[09:04] <broquaint> It'll be fine.

[09:04] <Alias_> Using $ENV{HOME} in a BEGIN will be fine?

[09:04] <broquaint> Sure, why not?

[09:04] <Alias_> because $ENV{HOME} will be different on a different machine

[09:05] <Alias_> hell, it will be different on the same machine

[09:05] <broquaint> Assuming you've compiled the compile-time section.

[09:05] <broquaint> Which you shouldn't do if you're doing things like that.

[09:05] <Alias_> Well, if it's not true, then you can't ever compile

[09:05] <broquaint> Kinda kills the purpose of optimization, huh?

[09:05] <Alias_> Because you can't trust everyone elses code

[09:06] <Alias_> yes

[09:06] <broquaint> How do magical languages like C++ and so forth do it?

[09:06] <Alias_> Once you compile them, you don't move them from the same environment

[09:06] <Alias_> IFDEF etc

[09:06] <broquaint> Some kind of spooky maaaggiiiiic!

[09:06] <Alias_> It's well defined what you can optimise at IFDEF time and what you can't

[09:06] <gaal> what did you mean by "can't assume which other modules are loaded"?

[09:07] <broquaint> So the distribution of programs over the internet is entirely in my head?

[09:07] <Alias_> broquaint: It's well defined what you CAN optimize at IFDEF time and what you CAN'T

[09:07] <Alias_> And what "compile-time" means

[09:08] <broquaint> Sure, so you don't do things in BEGIN that you shouldn't, just like C/C++/etc developers don't do things in #ifdefs they shouldn't.

[09:08] <broquaint> It's no big deal.

[09:08] <Alias_> sure. Now define "shouldn't"

[09:08] <Alias_> or define what those $things are

[09:08] <Alias_> "You'll know when they break" being NOT an answer I want

[09:08] <broquaint> I don't need to. They're entirely arbitrary. But we can't worry about what silly things people *might* do.

[09:08] <gaal> Alias_: is the kind of answer to that question that Java provides a good one for you?

[09:09] <Alias_> broquaint: define silly

[09:09] <qwr> #ifdef is purely preprocessing the code before compiling

[09:09] <Alias_> I have ZERO guidelines as to what I can do and can't do

[09:09] <broquaint> Yes.

[09:09] <Alias_> (so far as I can tell)

[09:09] <broquaint> Correct.

[09:10] <Alias_> So lacking anything I CAN do, the answer is do nothing

[09:10] <Alias_> wiping out the usefulness to me of compile-time optimisation

[09:10] <broquaint> You can do anything, whether you should or not is up to you.

[09:10] <Alias_> So we should remove BEGIN

[09:10] <broquaint> It doesn't wipe it out, does it? Because it works in other compiled languages.

[09:10] <gaal> .oO(Skeptics have been known to breath.)

[09:10] <autrijus> Alias_: this is really not at all different from perl5 with perlcc -- although granted, nobody uses perlcc for real

[09:11] <Alias_> broquaint: They get to assume seperated compile-run, and so they tell you what you can and can't do

[09:11] <Alias_> Name anything I can reliably do in BEGIN now...

[09:11] <broquaint> Anything that won't fit inside a monad.

[09:11] <autrijus> Alias_: sure, like, defining constants.

[09:11] <autrijus> including subroutines and classes :)

[09:11] <Alias_> use constant ON_WIN32 => ...;

[09:11] <Alias_> well, except those

[09:12] <Alias_> you mean dumb constants of course, but anyways

[09:12] <autrijus> if you mean INIT, write INIT :)

[09:12] <autrijus> it's that simple.

[09:12] <broquaint> I would've thought compile-time could be compile-once (for optimizing) and compile-everywhere-once (for dynamical-type optimization).

[09:12] <Alias_> So can I do haskellisation at INIT-time?

[09:12] <Alias_> currying etc...

[09:13] <Alias_> get rid of code for other platforms?

[09:13] <autrijus> sure!

[09:13] <Alias_> And module existance only matters at INIT time?

[09:13] * broquaint writes some perl6 to get rid of kernel32.dll

[09:14] <autrijus> Alias_: at INIT time, the interfaces are linked and symbol table populated, but as this is a dynamic language, you can still tweak all bindings to your heart's content.

[09:14] <Alias_> err... symbol table populate?

[09:14] <Alias_> as in modules loaded?

[09:14] <broquaint> What's the default mainspace? Is it still main::?

[09:14] <autrijus> broquaint: "default"? the main program is Main, yes.

[09:15] <autrijus> Alias_: "use" modules are loaded, yes.

[09:15] <broquaint> Thanks, autrijus :)

[09:15] <Alias_> how on earth does that work...

[09:15] <Alias_> That would mean you can't compile a module once and use it with other programs?

[09:16] <Alias_> let me put it better...

[09:16] <Alias_> if ( on_win32 ) { sub foo { use Win32::Module; ... } } else { sub foo { ... } }

[09:16] <Alias_> How does that happen

[09:17] <broquaint> That looks just like ... like ... like ... perl5!

[09:17] <Alias_> that's only pseudocode

[09:17] <joao> hello

[09:17] <broquaint> I'm still not seeing the problem here.

[09:17] <Alias_> now on unix, Win32:: won't be installed

[09:17] <broquaint> Hello, joao.

[09:18] <Alias_> So are there init-time variables?

[09:18] <autrijus> Alias_: you want dynamic, not static, loading for that.

[09:18] <Alias_> but all the modules are loaded already you said

[09:18] <autrijus> all the "use" modules.

[09:18] <autrijus> static ones.

[09:18] * Alias_ points to the use module

[09:19] <Alias_> granted, at the moment to implement this I use evals

[09:19] <autrijus> I don't think it works in perl5

[09:19] <autrijus> so I'm not sure why it should work in perl6.

[09:19] <Alias_> sure it does

[09:19] <broquaint> Or hopefully require/use will get smarter.

[09:19] <Alias_> It works just fine in perl 5

[09:19] <autrijus> perl -e "if (0) { use ADS }"

[09:19] <autrijus> Can't locate ADS.pm in @INC...

[09:20] <broquaint> It oughtn't work just fine in perl5.

[09:20] <autrijus> please define the 'just fine' here.

[09:20] <Alias_> You can turn that pseudo-code into Perl 5

[09:20] * joao is definitely sleeping: "rm -rf abc *" IS NOT "rm -rf abc*" 

[09:20] <gaal> ow ow ow

[09:20] <autrijus> how?

[09:20] <Alias_> if (0) { eval "use Win32::Module; ..." }

[09:21] <autrijus> er that is valid perl6, for sure.

[09:21] <autrijus> it even works in pugs.

[09:21] <Alias_> I was hoping for something less cludgy

[09:21] <autrijus> you can also use INIT { if (on_win32) { require Win32::Module } else { require Unix::Module } }

[09:22] <Alias_> well, what I wanted more was something like INIT { if (on_unix) { sub path($) { $_[0] } } else { sub path($) { File::Spec->cat( File::Spec::Unix->split($_[0]) ) } }

[09:22] <autrijus> you can indeed write that.

[09:22] <Alias_> err...

[09:23] <Alias_> In Perl 5 the prototypes are missing at compile time, and thus things die badly

[09:23] <Alias_> In Perl 6...

[09:23] <broquaint> Welcome to the wonderful new world of Perl 6!

[09:23] <autrijus> Alias_: okay. so in sum

[09:24] <autrijus> you'd like the interface to persist

[09:24] <autrijus> and checked at compile time

[09:24] <autrijus> but the implementation code needs to be swapped out at INIT time.

[09:24] <autrijus> we can do that.

[09:24] <Alias_> but have platform optimisation happen at INIT time

[09:24] <Alias_> yes

[09:24] <Alias_> It's a big problem now, and nobody realises it

[09:24] <autrijus> basically you can write forward decl

[09:25] <Alias_> Chewing up a non-trivial amount of CPU and memory

[09:25] <autrijus> sub path (Str $path) { ... }

[09:25] <autrijus> the "..." is literal

[09:25] <Alias_> right

[09:25] <autrijus> and then at INIT

[09:25] <autrijus> load one of the many backends and swap &path 

[09:25] <autrijus> into something concrete.

[09:25] <autrijus> so the compiler will check interface for $path just fine

[09:25] <autrijus> I mean &path

[09:26] <autrijus> and at runtime, if &path is not swapped in

[09:26] <autrijus> then it will die 

[09:26] <autrijus> ?eval sub path { ... }; path()

[09:26] <evalbot_7252> *** ... - not yet implemented     at <eval> line 1, column 12-16 

[09:26] <Alias_> at call-time or end-of-init time

[09:26] <autrijus> at call time, as currently specified.

[09:26] <autrijus> as you can swap in implementation at runtime

[09:26] <autrijus> not endofinit time

[09:27] <nothingmuch> morning

[09:27] <Alias_> ok

[09:27] <Alias_> but you'd have to do it at module level though

[09:28] <Alias_> every platform factor is going to mean different modules?

[09:28] <Alias_> say I just want a single line in a loop somewhere...

[09:28] <autrijus> if you want to compile into platform independence, yes.

[09:28] <Alias_> next if on_mac;

[09:29] <Alias_> there's lots of that stuff around and about

[09:29] <nothingmuch> hmm?

[09:29] <nothingmuch> why should that die?

[09:29] <Alias_> So the answer then if "only to the degree that Perl 5 can"

[09:29] <Alias_> is

[09:29] <nothingmuch> Windows can implement that as { false }

[09:30] <Alias_> nothingmuch: That line should be just optimized out at init-time

[09:30] <nothingmuch> err, what does it matter?

[09:30] <nothingmuch> the moment we have a constant it can be constant folded

[09:30] <nothingmuch> it doesn't matter when

[09:31] <nothingmuch> the linker ought to invoke optimizers once there is enough info

[09:31] <Alias_> You can define a constant at INIT-time that is refered to in code at compile-time?

[09:31] <nothingmuch> yes... the moment it's defined it can be used

[09:31] <Alias_> define used

[09:31] <nothingmuch> but if your runtime is linker oriented - the INIT block will emit a compiled linkable unit

[09:32] <nothingmuch> that exports a symbol

[09:32] <nothingmuch> which binds to the unresolved symbol in the "main" code

[09:32] <Alias_> you just went into language-implementor language... which I don't know

[09:32] <nothingmuch> and after this link operation the call chain will be reoptimized

[09:32] <nothingmuch> well, these are language implementor issues =)

[09:32] <nothingmuch> think of the output of every .pm file as a library

[09:33] <nothingmuch> BEGIN, INIT, etc also emit tiny libraries

[09:33] <nothingmuch> that are just compiled elsewhere

[09:33] <nothingmuch> as does eval

[09:33] <Alias_> Not really. I'm asking if I can optimise platform-specific things out in a more sophisticated way than at the module level

[09:33] <Alias_> I just want to know if it can be done, and what Perl 6 code I'd have to write

[09:33] <nothingmuch> you would just have to use constants

[09:34] <nothingmuch> and constant folding will get around to it

[09:34] <Alias_> constants that are defined at INIT time?

[09:34] <Alias_> but used in code normally

[09:34] <nothingmuch> or you would have to swap in complete functions for every runtime

[09:34] <Alias_> ?

[09:34] <nothingmuch> yes, that too

[09:34] <nothingmuch> since INIT time will introduce new symbols those symbols will be used to resolve unresolved symbols in the main code. the moment they are resolved they can be optimized

[09:35] <Alias_> so... INIT { constant UNIX = (test for unix) ? 1 : 0 } sub path { if ( UNIX ) { simple } else { complex } }; will work?

[09:35] <nothingmuch> yes, but it's silly

[09:35] <nothingmuch> just say sub path { }

[09:35] <Alias_> no it isn't

[09:35] <nothingmuch> and define a path for UNIX

[09:35] <nothingmuch> and a path for Windows

[09:35] <nothingmuch> and a path for ...

[09:35] <nothingmuch> there will be hooks for this kind of behavior

[09:36] <nothingmuch> because (AFAICT) that's how we are going to implement any level of portability (e.g. parrot vs javascript)

[09:36] <Alias_> now imagine I have a do_this { 17 statements here; if ( Unix ) { 1 extra }; 3 statements; unless ( Max ) { ... } ; etc }

[09:36] <nothingmuch> for that it isn't silly

[09:36] <Alias_> this sort of stuff exists all over the place today

[09:36] <Alias_> It's very normal

[09:36] <Alias_> It means not having to do 38 different versions with nearly identical code

[09:37] <nothingmuch> right, all i'm saying is that we may have better tools in the future

[09:37] <nothingmuch> right

[09:37] <nothingmuch> the issue is how identical is the code

[09:37] <nothingmuch> if it's not, don't use if

[09:37] <Alias_> So will Perl 6 allow that level of thing to be optimised out

[09:37] <nothingmuch> if it is, use if

[09:37] <nothingmuch> yes

[09:37] <Alias_> and that if can be compiled out at INIT time

[09:37] <Alias_> ?

[09:37] <nothingmuch> but keep in mind that sometimes someone on unix needs to use File::Spec::Win32

[09:37] <nothingmuch> yes

[09:37] <Alias_> for code that already exists

[09:37] <nothingmuch> yes

[09:38] <nothingmuch> not now

[09:38] <nothingmuch> probably not even soon

[09:38] <Alias_> Before 1.0?

[09:38] <nothingmuch> but that's what i'm trying to learn how to do in Blondie

[09:38] <nothingmuch> i don't know when 1.0 will arrive

[09:38] <Alias_> So it's vapourware?

[09:38] <Alias_> (that optimisation)

[09:38] <nothingmuch> you can think of it as vaporware

[09:39] <nothingmuch> i'm working on the beginings of enabling these kinds of things by prototyping a simler compiler framework

[09:39] <Alias_> Well, "yes it will do it, eventually, when we work out how, because we don't know how yet" is vapourware

[09:39] <nothingmuch> once we have learned from that thing, we can implement it

[09:39] <nothingmuch> so yes, it's vaporware

[09:39] <nothingmuch> but it's under early development

[09:39] <nothingmuch> and we do know how

[09:39] <Alias_> So when I say "Will Perl 6 allow this" the answer is "we'd like it to"

[09:40] <nothingmuch> or at least i think we do

[09:40] <nothingmuch> no

[09:40] <nothingmuch> because the answer might be "it damn well do it, or it will suck"

[09:40] <nothingmuch> in which case that is just optimized into "yes"

[09:40] <broquaint> There will have to be some level of approximation if Perl5->Perl6 is going to work.

[09:40] <Alias_> so "maybe"?

[09:40] <Alias_> Because as of now it doesn't seem to be a simple "yes"

[09:41] <nothingmuch> Alias_: err. whatever

[09:41] <Alias_> sigh

[09:41] <nothingmuch> if you're not going to help out at least don't judge

[09:41] <nothingmuch> sigh yourself

[09:41] <nothingmuch> i gave you all the information i can

[09:41] <nothingmuch> you can interpret it without trying to humiliate me

[09:41] <Alias_> "Will you pay me back this money if I lend it to you". "yes. well, it's a more complicated thing that will possibly optimise out to 'yes'"

[09:42] <Alias_> I just want an unqualified straight answer

[09:42] <nothingmuch> broquaint: as for the perl 5 runtime - constant folding can be a benefit, but most optimizations probably won't be relevant, unless it's compiled to C/XS

[09:42] <nothingmuch> Alias_: you never lent me any money

[09:42] <nothingmuch> i owe you nothing

[09:42] <nothingmuch> i'm being friendly

[09:42] <nothingmuch> and i get antagonism

[09:42] <nothingmuch> what do you expect?

[09:42] <Alias_> nothingmuch: Because you could never say if you'd pay it back :)

[09:42] <Alias_> "yes", "no" or "maybe" or "we'd like to" or "probably not"

[09:43] <nothingmuch> you asked "will"

[09:43] <nothingmuch> not "does"

[09:43] <autrijus> Alias_: I think dead code elimination during INIT time is viable, but likely to be runtime dependent. parrot does have facility for it

[09:43] <nothingmuch> "does" is no

[09:43] <nothingmuch> will is yes

[09:43] <nothingmuch> because we won't let it not work, and it's a simple thing to do as long as things are organized enough

[09:43] <Alias_> probably not even soon

[09:43] <Alias_> i don't know when 1.0 will arrive

[09:43] <nothingmuch> will predicates no time frame

[09:43] <Alias_> I probably implied "possibly not before release" out of that

[09:43] <nothingmuch> 1.0 will probably come after simp[le optimizations

[09:44] <nothingmuch> and this is a simple optimization

[09:44] <nothingmuch> dead code elmineation at link time is a basic idea

[09:44] <nothingmuch> it applies to code almost everywhere

[09:44] <nothingmuch> the reason perl 5 doesn't have it is that all it's linkage is adhoc (*{ $sym } = ... )

[09:44] <Alias_> So the answer is a clear "yes"

[09:44] <nothingmuch> yes

[09:45] <Alias_> or rather, "yes, before 1.0"

[09:45] <Alias_> ok

[09:45] <nothingmuch> i don't get to decide when 1.0 comes, but it better be fast enough or everyone will think perl 6 sucks

[09:45] <nothingmuch> in fact, by 1.0 i hope even the optimizer is optimized.

[09:46] <Alias_> That was unnecesary enginerr ass-covering :)

[09:46] <nothingmuch> what was?

[09:46] <nothingmuch> the whole conversation?

[09:46] <Alias_> your two additional lines of conditions

[09:47] <nothingmuch> the 'yes' was also ass covering

[09:47] <Alias_> So give a confirmed 'yes' and then turn it into a 'maybe'

[09:47] <nothingmuch> i might get hit by a truck, and then the linker won't turn out the way I want to

[09:47] <Alias_> no you won't

[09:47] <nothingmuch> and then it might not work

[09:47] <nothingmuch> i said 'yes'

[09:47] <Alias_> The odds you will be are statistically nonexistant

[09:47] <nothingmuch> not 'yes, before 1.0'

[09:47] <nothingmuch> when you ammended that i said i have no clue what 1.0 even is

[09:48] <Alias_> You don't?

[09:48] <nothingmuch> but it sounds important, and for it to be good it should have those

[09:48] <Alias_> It's the first production release of an application

[09:48] <Alias_> As in, when Perl 6.000

[09:48] <Alias_> final, done

[09:48] <nothingmuch> so by that we disallow perl 6.5?

[09:48] <nothingmuch> no otpimizations can ever make it to 6.5 because they must be done by 6.0?

[09:49] <Alias_> Are you telling me you've never shipped a module?

[09:49] <nothingmuch> no

[09:49] <Alias_> wow... sorry

[09:49] <nothingmuch> no as in i'm not telling you that

[09:49] <Alias_> I thought I'd seen things you'd made before

[09:49] <nothingmuch> i have

[09:49] <Alias_> Then you understand 1.0

[09:49] <Alias_> this conversation is one big ball of misunderstandings

[09:49] <nothingmuch> the issue is that a community driven language that is so wide will have 1.0ish spread around around a year

[09:49] <nothingmuch> heh

[09:50] <nothingmuch> good riddece

[09:50] <nothingmuch> riddance

[09:50] * autrijus purrs.

[09:50] * nothingmuch will make sure that all his optimizations are conditional

[09:51] <nothingmuch> if ($*ENV{LOGNAME} ne "adamk") { optimize real well }

[09:51] <autrijus> oh btw.

[09:51] <autrijus> the demagicalizing thread on p6l fizzled, right?

[09:52] <nothingmuch> i haven't noticed it

[09:52] <autrijus> magical pairs is responsible for lotsa test failures :-/

[09:52] <nothingmuch> hmm

[09:52] <nothingmuch> fry them?

[09:52] <nothingmuch> i think luqui's proposal was pretty well accepted

[09:53] <autrijus> url to his proposal?

[09:53] <nothingmuch> let me dig

[09:53] <nothingmuch> also see tuple types in theory.pod

[09:53] <nothingmuch> since he brought it up i've wanted slurpy scalar about 50 times

[09:53] <autrijus> yuppers.

[09:53] <nothingmuch> it would be very nice to have

[09:53] <nothingmuch> *searching*

[09:54] <nothingmuch> okay, in theory.pod:

[09:54] <nothingmuch> foo($x, (foo => "bar")); # positionals

[09:55] <nothingmuch> foo($x, foo => "bar"); # positional and named

[09:55] <nothingmuch> my $x = foo => $bar;

[09:55] <autrijus> ooh meaningful parens.

[09:55] <nothingmuch> foo($x); # positional

[09:55] <nothingmuch> (they're very intuitive, aren't they?

[09:55] <nothingmuch> to make $x a named you have to ....

[09:56] <nothingmuch> i think you should flatten it:

[09:56] <nothingmuch> foo(*$x);

[09:56] <nothingmuch> where a pair is really a tuple with only one named

[09:56] <nothingmuch> makes sense?

[09:57] <autrijus> er, yes, because we went thru that during yapcna hackathon.

[09:57] <autrijus> larry kept saying he want a way to mark named zones.

[09:57] <nothingmuch> hmm?

[09:57] <autrijus> instead of that proposal

[09:57] <nothingmuch> tuples existed since then?

[09:57] <autrijus> but that never materializes, so I think what we have is second best.

[09:58] <nothingmuch> hmm

[09:58] <nothingmuch> i see a post that discusses only  "I suspect a lot of people would still prefer to write named args with =>"

[09:59] <nothingmuch> this is from aug 19, though

[09:59] <autrijus> aye.

[09:59] <autrijus> oh btw. you have some cycles?

[09:59] <nothingmuch> cycles? brain or CPUD?

[09:59] <autrijus> I'd like to ditch t/rules/rules.t

[10:00] <nothingmuch> split it? or throw it away?

[10:00] <autrijus> by ditch Imean to turn it into somethign spec based

[10:00] <nothingmuch> ah

[10:00] <autrijus> and then transfer /en masse/ to parrot folks.

[10:00] <autrijus> spec based means some delimited format

[10:00] <nothingmuch> yes

[10:00] <nothingmuch> hmm

[10:00] <nothingmuch> to what extent does PGE know about the names of perl 6 special vars?

[10:01] <autrijus> nothingmuch: it knows a data structure of each named and positional matches

[10:02] <autrijus> nothingmuch: the original stuff is spec based

[10:02] <autrijus> see the comment lines

[10:02] <nothingmuch> yes, I know

[10:02] <svnbot6> r7253 | autrijus++ | * Massive TODOization.

[10:02] <autrijus> so probably just translate it back into that format

[10:02] <autrijus> and let parrot harness it 

[10:02] <nothingmuch> i'm thinking it's slightly more difficult

[10:02] <nothingmuch> since it was hand edited by then

[10:02] <autrijus> indeed? I don't know... throw a regex at it and see what slips

[10:03] * autrijus is still relenging the tests

[10:04] <nothingmuch> i think i will svk log a bit

[10:04] <nothingmuch> then figure out if we're better off translating from othe original or from this one

[10:04] <nothingmuch> it's seems very well formed though

[10:04] <autrijus> nod.

[10:07] <broquaint> Quick q. - are the Pugs internals documented and if so, how do I get at those docs?

[10:07] <nothingmuch> broquaint: haddock

[10:07] <nothingmuch> and not really, sadly =(

[10:08] <broquaint> Dang. I was looking to make Object.new(*%args) JFW, but wasn't sure where to start, and much of Haskell makes my brain want to be somewhere else.

[10:09] <nothingmuch> broquaint: i guess i can help a little, and autrijus is always willing too

[10:10] <nothingmuch> and he can actually help a lot ;-)

[10:14] <broquaint> Nah, it's ok, I did to hack in bits and bobs. Maybe I'll just write my own perl6 interpreter to get up to speed ;)

[10:15] <broquaint> s/did/tend/

[10:15] <nothingmuch> =)

[10:15] <nothingmuch> you can try what i did

[10:15] <nothingmuch> it helped me a lot

[10:15] <nothingmuch> i learned forth and haskell together

[10:16] <nothingmuch> it's documented too: http://feather.perl6.nl/~nothingmuch/harrorth

[10:16] <nothingmuch> (the learning process)

[10:17] <broquaint> Hack a new language, eh? Sounds good to me.

[10:18] <broquaint> Maybe it's time Haskell was implemented in Perl6 ...

[10:19] <nothingmuch> hmm

[10:19] <nothingmuch> http://svn.openfoundry.org/pugs/perl5/Blondie/milner.pl

[10:27] <nothingmuch> hola joao 

[10:27] <joao> nothingmuch, hi, my laptop ran out of battery :P

[10:27] <nothingmuch> eep

[10:28] <joao> and yesterday he kissed the floor... fortunately, everything seems to work just fine ;)

[10:29] <nothingmuch> eep!

[10:30] <joao> nothingmuch, anyway, I'll try to do something like you did with harrorth :-)

[10:30] <nothingmuch> mui bien

[10:30] <joao> "muito bem" is better :)

[10:30] <nothingmuch> pt?

[10:31] * joao nods

[10:31] <nothingmuch> muito bem

[10:31] * nothingmuch will try to remember

[10:31] <joao> ;)

[10:31] <nothingmuch> joao++

[10:31] <joao> pt and sp are similar languages

[10:31] <nothingmuch> pt sounds cooler though

[10:31] <nothingmuch> less rigid and throatal

[10:32] <joao> I don't know about the rigid part :)

[10:33] <nothingmuch> rigid not in any grammatical sense

[10:33] <nothingmuch> that much i don't know

[10:33] <nothingmuch> pt vs sp on tv always sounded more round, soft and pleasant

[10:34] <joao> Probably because they speak louder, faster and sometimes almost singing :-)

[10:35] <nothingmuch> autrijus: i think i'll try to convert the current rules.t

[10:35] <nothingmuch> it seems like there is some rules

[10:35] <nothingmuch> err... some change

[10:36] <joao> Oh well, work is calling again

[10:36] <joao> bbl

[10:36] <nothingmuch> ciao

[10:40] <autrijus> nothingmuch++

[10:41] <autrijus> oh btw, is $/ deprecated?

[10:41] <autrijus> for the whole match, I mean, in favour of $<>

[10:43] <nothingmuch> i dunno

[10:43] <nothingmuch> isn't it the match object

[10:44] <nothingmuch> ~$/ eq $<>

[10:44] <nothingmuch> ?

[10:44] <nothingmuch> breakfast time

[10:44] <nothingmuch> see you soon

[10:48] <autrijus> cool

[11:05] <svnbot6> r7254 | autrijus++ | * remove warning from using rx:i//.

[11:05] <svnbot6> r7254 | autrijus++ | * do not report rx warnings with a line number inside Prelude.pm

[11:05] <svnbot6> r7254 | autrijus++ |   as it is not helpful.

[11:47] <svnbot6> r7255 | autrijus++ | * For Parrot 0.3.0, we need to inline PGE::Hs into run_pge.pir

[11:47] <svnbot6> r7255 | autrijus++ |   for rules to work again.

[11:52] <svnbot6> r7256 | autrijus++ | * disable the arcfour test as it seems not yet implemented.

[12:10] <betaplus> hi! is this the right place to ask -- http://cia.navi.cx/stats/project/perl6 didn't update for quite some time, but the real svn repository shows progres...?

[12:11] <autrijus> hm, sec

[12:12] <QtPlatypus> That is way out of date.  We are up to 7256

[12:13] <autrijus> fixing.

[12:14] <betaplus> ooh cool! ++

[12:17] <svnbot6> r7257 | autrijus++ | * do not export operators from fp.pm; instead multify them.

[12:17] <svnbot6> r7258 | autrijus++ | * repair times.t to use proper french quoting.

[12:17] <Limbic_Region> autrijus - I know you are incredibly busy with an incredible amount of stuff - but do you have a 1 or 2 line summary of your progress of porting the MM to Haskell?

[12:18] <QtPlatypus> Multify?

[12:18] <autrijus> "turned into multi sub"

[12:19] <autrijus> Limbic_Region: sure - it's "didn't do anything that works in any shape yet; pending releng and some time to Q&A with stevan"

[12:19] <Limbic_Region> ok

[12:20] <Limbic_Region> What I am most interested in as casual observer is how natural the port is versus how much hmmm - this doesn't feel right comes up

[12:20] <Limbic_Region> I am a firm believer that the more something is fully grok'd the simpler it becomes

[12:20] <autrijus> aye

[12:21] <autrijus> that's also related to container model

[12:21] <autrijus> which also needs porting over

[12:21] <Limbic_Region> right

[12:21] <autrijus> and I've been thinking about how to do this transplant without affecting too much of Eval.hs

[12:22] <autrijus> easiest is perhaps to treat the current PIL interface as a black box

[12:22] <svnbot6> r7259 | nothingmuch++ |  r8827@syeeda:  nothingmuch | 2005-10-04 14:19:56 +0200

[12:22] <svnbot6> r7259 | nothingmuch++ |  milner.pl:

[12:22] <svnbot6> r7259 | nothingmuch++ |  * fix type checking of higher order functions wrt variable instantiation

[12:22] <svnbot6> r7259 | nothingmuch++ |  * close STDERR

[12:22] <svnbot6> r7259 | nothingmuch++ |  * more tests

[12:22] <autrijus> i.e. do another backend runcore that does not participate in parsing yet

[12:22] <Limbic_Region> well, as long as that doesn't ultimately end up painting you into a corner

[12:22] <autrijus> I've been in many corners the past couple days :)

[12:22] <Limbic_Region> or to use a p5 analogy - end up making Pugs development a game of Jenga

[12:22] <autrijus> right.

[12:23] <autrijus> modularity is of utmost importance.

[12:23] <autrijus> but with parrot 0.3.0 and ghc 6.4.1 out

[12:23] <autrijus> releasing a pugs that works with them

[12:23] <autrijus> is perhaps a greater priority

[12:23] <autrijus> so I'm trying to get that done first today

[12:23] <Limbic_Region> well, yes - but more important is a sound API design that has forethought for growth

[12:24] <Limbic_Region> I guess those are two sides of the same coin

[12:24] <autrijus> er, well, I'm more of the refactor-what-works-into-api school

[12:24] <autrijus> bduf didn't work very well for me :)

[12:24] <Limbic_Region> ok - we are saying the same thing pretty much

[12:25] <autrijus> *nod*

[12:25] <autrijus> venehement agreement good.

[12:25] <Limbic_Region> the design should allow for change without terribly impacting everyone else

[12:25] <Limbic_Region> but the design should indeed change whenever appropriate

[12:25] <autrijus> nod.

[12:25] <Limbic_Region> sometimes terribly impacts are unavoidable so you want to get that done and over with before releasing to the world

[12:26] <Limbic_Region> s/releasing to the world/declaring stability/

[12:26] <autrijus> nothingmuch: please delete t/rules/rules.t when you are done converting -- I'm marking it as not-to-be-run now

[12:27] <nothingmuch> autrijus: sorry, was on phone for a long while

[12:27] <svnbot6> r7260 | autrijus++ | * skip rules test as it's moving to parrotland soon, per consensus

[12:27] <svnbot6> r7260 | autrijus++ |   at parrotsketch..

[12:27] <svnbot6> r7259 | nothingmuch++ |  r8827@syeeda:  nothingmuch | 2005-10-04 14:19:56 +0200

[12:27] <svnbot6> r7259 | nothingmuch++ |  milner.pl:

[12:27] <svnbot6> r7259 | nothingmuch++ |  * fix type checking of higher order functions wrt variable instantiation

[12:27] <nothingmuch> then i found a bug in the inferrencer

[12:27] <svnbot6> r7259 | nothingmuch++ |  * close STDERR

[12:27] <svnbot6> r7259 | nothingmuch++ |  * more tests

[12:27] <nothingmuch> so i'm finishing now, and i'll be on it 2 mins

[12:27] <autrijus> k

[12:30] <nothingmuch> wow, AGs rock

[12:30] <nothingmuch> i'm adding DWIMness to the pretty printer and it's working out very well

[12:34] <betaplus> ok bye and thank you autrijus for fixing CIA :)

[12:36] <autrijus> np :)

[12:38] <nothingmuch> moose!

[12:38] <svnbot6> r7261 | autrijus++ | * marking lexical_pragmas as TODO, that is, not for this release by default.

[12:39] <nothingmuch> okay, back to rules.t

[12:44] <stevan> autrijus: ping

[12:44] <svnbot6> r7262 | nothingmuch++ | better pretty printing, and a fix for the wide char in print warning

[12:44] <nothingmuch> hey stevan 

[12:44] <stevan> hey nothingmuch 

[12:45] <autrijus> stevan: pong!

[12:45] <stevan> autrijus: if you would like to do a quick MM q&a right now we can,..

[12:45] <autrijus> stevan: okay, how quick? :)

[12:46] <stevan> I got about 20-30 min tops

[12:48] <autrijus> okay

[12:49] <autrijus> why is the class part of opaque instance a scalar ref?

[12:49] <svnbot6> r7263 | autrijus++ | * In Set::Symbols, do not override normal operators, but only

[12:49] <svnbot6> r7263 | autrijus++ |   apply the operators to Set objects.

[12:49] <autrijus> instead of a simple ref

[12:49] <stevan> IIRC to make the initial Class is a Class easier

[12:50] <stevan> however, that is probably not needed if it is a problem

[12:50] <autrijus> you mentioned that singleton methods may make the for=>instance and for=>class easier and/or different.

[12:50] <autrijus> what do you mean?

[12:50] <stevan> in Ruby class methods are just singleton methods on the Class instance

[12:51] <stevan> if we follow that path

[12:51] <stevan> then we can eliminate the class/instance method code

[12:51] <autrijus> then the "the DBI class is an undef for a DBI object" foo can go away

[12:51] <stevan> which never felt right anyway

[12:52] <stevan> yes, that is likely

[12:52] <stevan> it looks to me as if it will unify some things

[12:52] <stevan> simplify too

[12:52] <stevan> which is always a good thing

[12:52] <autrijus> yes, I think that's the way to go.

[12:53] <autrijus> so the way in p5 is to invent anonclass to bless into?

[12:53] <stevan> I am not sure whether to force all objects to be like that

[12:53] <stevan> or to do it "on demand"

[12:53] <stevan> this is what I was thinking about yesterday

[12:53] <stevan> yes, look at t/36_... er,.. singleton_method or something

[12:53] <stevan> it subclasses class

[12:54] <autrijus> we can surely reclass an obj's .meta at runtime?

[12:54] <stevan> I think it is not a recommended thing

[12:54] <stevan> but it should be possible

[12:55] <nothingmuch> seen luqui

[12:55] <jabbot> nothingmuch: luqui was seen 1 days 16 minutes 56 seconds ago

[12:55] <autrijus> and if so, we can then conjure up anonclass when there is a need for it.

[12:55] <stevan> if you do it, we cannot guarantee the results

[12:55] <stevan> however if we do it,. we can :)

[12:55] <autrijus> lol

[12:55] <stevan> yes, that is basically how it works

[12:56] <autrijus> okay. is for=>instance and for=>class going away then?

[12:56] <stevan> its gets a little messy deciding where to install new methods (using add_method) vs. singleton methods (using add_singleton_method)

[12:56] <stevan> but thats just details

[12:56] <stevan> autrijus: yes, they will go away 

[12:56] <autrijus> good.

[12:56] <stevan> yeah they smelled bad :)

[12:56] <autrijus> I stopped there :)

[12:57] <autrijus> and thought something along the lines of, it can't be right :)

[12:57] <stevan> if you want,.. you can ignore the class method thing all together and just build it with instance methods

[12:57] <autrijus> yup

[12:57] <stevan> there are not class methods in the core MM

[12:57] <autrijus> I'm going to do just that.

[12:57] <stevan> cool

[12:57] <autrijus> hi Qiang 

[12:57] <stevan> I should have the singleton methods integrated by the end of the week at the latest

[12:58] <stevan> $work is a little busy, so my tuits are limited

[13:00] <autrijus> sure, no worries

[13:00] <stevan> how is it going otherwise?

[13:00] <stevan> did you have issues with other parts of chaos?

[13:00] <nothingmuch> autrijus: ping me when you're done with stevan, i have a refactoring plan for you

[13:00] <autrijus> nothingmuch: I can multiplex

[13:01] <autrijus> stevan: as you know, there's no globals in haskell :)

[13:01] <nothingmuch> i don't want to take out of stevan's limited time

[13:01] <autrijus> stevan: so I'm trying to see which environments are absolutely needed for me to keep around

[13:01] <nothingmuch> and I can do some dirty work before it

[13:01] <stevan> autrijus: well you need $?SELF, $?CLASS, $?ROLE and $?PACKAGE

[13:02] <stevan> but other than that,.. you should be okay

[13:02] <autrijus> stevan: and naturally it goes back to mutability.  the $::*

[13:02] <autrijus> er, jinx

[13:02] <autrijus> right.

[13:02] <autrijus> $::SELF etc I mean.

[13:02] <stevan> the $::DISPATCHER is actually optional

[13:02] <stevan> you can implement next_METHOD CLOS-style and redefine it for each method call

[13:03] <stevan> it tended to be more expensive since you get if whether you use it or not,.. but it always felt the cleanest

[13:03] <autrijus> okay, I'd need to think about it

[13:03] <nothingmuch> stevan: remember static analysis

[13:03] <nothingmuch> i think we should go to predictable cleanliness

[13:03] <nothingmuch> it's easier to optimize that  then to make an optimized impl and keep that clean

[13:04] <stevan> autrijus: keep in mind that chaos.pl and gnosis.pl are not concrete, they can be modified to fit the runtime

[13:04] <autrijus> stevan: so, in chaos, all bless() is just tagging

[13:04] <stevan> everything after that is the MM

[13:04] <stevan> autrijus: yes, just tagging really

[13:04] <autrijus> the only method that is used is ->isa

[13:04] <stevan> and IIRC I only use that in gnosis.pl

[13:05] <autrijus> chaos too

[13:05] <stevan> which actually can go away once the singleton methods are in place

[13:05] <stevan> yes, chaos too

[13:05] <autrijus> cool.

[13:05] <autrijus> so the idea is I forget about class meths

[13:05] <stevan> but once singlton methods are in place,.. class methods are installed that way

[13:05] <autrijus> and support metamorph.pl API

[13:05] <autrijus> and everything else should fall from there

[13:05] <stevan> and private methods can be detected by the : or _ at the begining

[13:05] <autrijus> s/API/usage/

[13:06] <stevan> yes

[13:06] <autrijus> eggcellent. I think that's it for now :)

[13:06] <stevan> up to metamorph (chaos, and gnosis) is the implementation specific stuff

[13:06] <stevan> metamorph and beyond should be followed fairly strictly

[13:07] <stevan> very nice :)

[13:07] <stevan> I can't wait

[13:07] <stevan> BTW - I started hacking a p6 version of metamorph

[13:07] <stevan> mostly to sort of test out the p6 part of the MOP

[13:08] <stevan> actually nothingmuch, that is something you might be interested in messing with

[13:08] <nothingmuch> huh hmm?

[13:09] <stevan> nothingmuch: see lib6 in the MM2.0 directory

[13:09] <nothingmuch> ermm.... soon

[13:09] <stevan> and hack some P6 MOP for me

[13:10] <stevan> ok

[13:10] <nothingmuch> i have something i need to do, and if i keep getting distracted with fun stuff it will never be done

[13:10] <nothingmuch> compiling rules is slow...

[13:10] <nothingmuch> is parrot invoked once for each rule?

[13:10] <autrijus> no, we keep persistnt connection

[13:10] <stevan> ok,.. I have to run now,.. off to $work

[13:10] <stevan> adios all

[13:10] <autrijus> stevan: thank and good luck!

[13:10] <stevan> &

[13:11] <stevan> :)

[13:11] <stevan> no death march,.. just driving in traffic,.. so its not too bad,.,. lots of time to think

[13:11] <nothingmuch> ciao Steve_p 

[13:11] <nothingmuch> eep

[13:12] <nothingmuch> autrijus: okay, here's the plan

[13:12] <nothingmuch> use Test::Base

[13:12] <nothingmuch> i hope parrot land won't mind

[13:12] <nothingmuch> we have:

[13:12] <autrijus> prolly won't if you bundle it

[13:12] <nothingmuch> ---input: foo

[13:12] <nothingmuch> ---pattern: bar

[13:12] <nothingmuch> those are always string constants

[13:12] <nothingmuch> then we have other fields

[13:12] <nothingmuch> like

[13:12] <nothingmuch> ---whole_match: string constant # will translate to $<>

[13:13] <nothingmuch> --- match_var: 1

[13:13] <nothingmuch> --- match: "constant

[13:13] <nothingmuch> this is $1

[13:13] <nothingmuch> that way it's very portable

[13:13] <nothingmuch> and not too hard to hack on the T::B side (just a few simple filters)

[13:13] <nothingmuch> then to run these against perl 6 we need to port Test::Base (prolly not too hard)

[13:13] <nothingmuch> and port the filters (not hard at all)

[13:14] <nothingmuch> and in parrot land we will write the filters to use the perl 5 glue they use

[13:14] <nothingmuch> makes sense?

[13:15] <nothingmuch> splitting rules.t into batches of 150

[13:15] <autrijus> makes sense.

[13:15] <autrijus> nothingmuch++ # sound plan.

[13:16] <nothingmuch> i hope it's not too much trouble

[13:16] <nothingmuch> i'll make a human assisted translation script

[13:16] <nothingmuch> if it can parse something and knows exactly what it is it generates simple rules

[13:16] <autrijus> nothingmuch++ nothingmuch++

[13:16] <nothingmuch> otherwise it asks for help

[13:16] <autrijus> k

[13:16] <nothingmuch> then we can split the work effort across the 150-test chunks, so that I fatigue doesn't cause bad translation

[13:17] <nothingmuch> hiya ingy

[13:17] <nothingmuch> autrijus: are some tests in rules.t known to segfault?

[13:17] <ingy> nothingmuch: hi there

[13:17] <autrijus> nothingmuch: none of them, if you up to the latest pugs

[13:18] <nothingmuch> oh right, i haven't compiled pugs yet... only parrot

[13:18] *** theorbtw1 is now known as theorbtwo

[13:18] <nothingmuch> hola theorbtwo 

[13:18] <autrijus> nothingmuch: r7288 fixes the segfault against 0.3.0 afaict

[13:18] <autrijus> but you don't really need to run it for real :)

[13:18] <autrijus> for translation, I mean.

[13:18] <nothingmuch> i'm still chunking

[13:19] <Limbic_Region> theorbtwo - how did you do in the contest?

[13:22] <svnbot6> r7264 | autrijus++ | * protect signature_matching with try{} throughout

[13:30] <theorbtwo> Nothing mailed about results yet.

[13:31] <theorbtwo> OTOH, my access log shows that they did look at least a bit -- though they didn't create an account.

[13:31] <Limbic_Region> so did you end up modifying the vector engine at all?

[13:32] <theorbtwo> No major modifications thus far.

[13:32] <theorbtwo> I think I'd like to modify it, but I'm not sure how to do so without using N*M time.

[13:32] <Limbic_Region> I am not sure how rating TV shows compares to finding search strings in documents but ...

[13:32] <Limbic_Region> that engine was severly lacking in features that I would want

[13:32] <nothingmuch> pugs: internal error: scavenge_stack: weird activation record found on stack: 469

[13:32] <nothingmuch>     Please report this as a bug to [email@hidden.address]
[13:32] <nothingmuch>     or http://www.sourceforge.net/projects/ghc/

[13:33] <nothingmuch> should i upgrade ghc?

[13:33] <Limbic_Region> word ordering, proximity matching, weighting, etc

[13:33] <theorbtwo> The idea is that we figure out what your ideal show is, and compare each show to that one to rate it.

[13:34] <nothingmuch> autrijus: punting for a few mins

[13:35] <nothingmuch> gotta fix a flat tire in our car

[13:36] <autrijus> k

[13:36] <nothingmuch> dad said: wait

[13:36] <pasteling> "nothingmuch" at 82.81.247.180 pasted "can't compile pugs" (6 lines, 269B) at http://sial.org/pbot/13451

[13:39] <autrijus> nothingmuch: you sure you don't have local changes?

[13:39] <autrijus> because that line is line 281 here.

[13:42] <Qiang> hi, autrijus

[13:48] * nothingmuch patiently waits for compilation to finish

[13:51] <nothingmuch> what is $0 in perl 6 again?

[13:53] <kolibrie> $0 is the first match

[13:54] <Limbic_Region> kolibrie right

[13:54] <nothingmuch> so $1 in perl 5?

[13:54] <kolibrie> yes

[13:54] <Limbic_Region> and nothingmuch wants to know what p5's $0 is in p6

[13:54] <nothingmuch> not whole match or any special case like that?

[13:54] <nothingmuch> no

[13:54] <Limbic_Region> err - nevermind me

[13:54] <nothingmuch> $0 in p6 is $?PROGRAM_NAME, i guess =)

[13:55] <kolibrie> I guess

[13:58] <svnbot6> r7265 | autrijus++ | * First step toward named argument rationalization -- 

[13:58] <svnbot6> r7265 | autrijus++ |   Primitive won't accept any nameds, so pairs are passed in verbatim.

[13:58] <svnbot6> r7266 | autrijus++ | * fix adverbial_modifiers.t to use lexical subs to avoid name clash.

[14:00] <kolibrie> autrijus: I'd like a pugs shirt, but with names on the back, or something

[14:00] <kolibrie> anyway, meeting &

[14:01] <nothingmuch> is there an array of $1 $2 $3 ... in perl 5?

[14:01] <autrijus> with names on the back?

[14:01] <autrijus> kolibrie: and are you coming to euro oscon?

[14:01] <autrijus> or npw

[14:02] <autrijus> nothingmuch: no, you need to use substr($var, $-[1], $+[1] - $-[1]

[14:02] <nothingmuch> phooey

[14:02] <nothingmuch> do i know how many matches there were

[14:02] <nothingmuch> heck, i could just ahrd code $1 .. $max

[14:02] <nothingmuch> they can be undef

[14:03] <autrijus> $#-

[14:03] <autrijus> or $#+, same thing

[14:03] <nothingmuch> how do i make an any(@patterns) without losing qr ness (join("|", @patterns) makes a string)

[14:03] <nothingmuch> yeah, you're right

[14:03] <nothingmuch> but it's too much headache, not enough benefit

[14:03] <autrijus> er, why you worry about losing qrness.

[14:03] <autrijus> join '|' is perfectly fine.

[14:04] <nothingmuch> can i safely qr a stringified qr?

[14:04] <nothingmuch> because the old qrs contain many meta chars

[14:04] <autrijus> I think so, yes

[14:08] <Limbic_Region> TIAS

[14:14] <nothingmuch> regexes are too hard to debug

[14:15] <pasteling> "nothingmuch" at 82.81.247.180 pasted "sad" (9 lines, 854B) at http://sial.org/pbot/13453

[14:15] <nothingmuch> ofcourse, this was a pretty combination of $RE{quoted}{-keep} and what not before

[14:22] <kolibrie> autrijus: not coming to euro oscon :(

[14:22] <skew> autrijus: Do you have slides or notes from your oscon talk online somewhere?

[14:33] <skew> I'm going to be teaching Haskell at work, and I'm wondering how you fit so much stuff into 45 minutes without expecting any previous experience

[14:37] <PerlJam> skew: What will you be doing at work with Haskell (besides teaching :)

[14:37] <PerlJam> ?

[14:37] <skew> writing code generators at least

[14:37] <skew> maybe some network + concurrency stuff

[14:38] <PerlJam> cool

[14:44] * nothingmuch flexes his brain

[14:58] <svnbot6> r7267 | iblech++ | ChangeLog: Changelogged r6963:r7266. The list is still unsorted, though.

[15:00] <autrijus> skew: I'll hack both slides and notes together over the next 2 weeks

[15:00] <autrijus> ooh iblech++

[15:01] <nothingmuch> moose

[15:01] <nothingmuch> the converter is coming along nicely

[15:02] <autrijus> nice moose

[15:02] <nothingmuch> it's the scariest code i've written in a while

[15:02] * autrijus is about to have dinner

[15:02] <kolibrie> nothingmuch: what exactly are you converting?

[15:02] <nothingmuch> rules.t

[15:03] <kolibrie> into?

[15:03] <nothingmuch> to $any_color_you_like

[15:03] <nothingmuch> right now - parrot & Test::Base

[15:03] <nothingmuch> basically, i'm parsing it

[15:03] <nothingmuch> so far

[15:04] <skew> do you think you can cover all the stuff from the abstract?

[15:05] <autrijus> skew: why, yes, given takahashi.

[15:05] <autrijus> I'm not giving a tutorial; I'm merely showing what is possible.

[15:05] <kolibrie> I am slowly beginning to understand lexing, parsing, interpretting, as I work through HOP chapter 8

[15:05] <autrijus> so: code fragments, not real programs; ideas, not implementations

[15:06] <skew> ah, that's a bit different

[15:06] <autrijus> I only got 45min :)

[15:06] <gaal> autrijus: re:arcfour, it actually is implemented but there seems to be a bug in 'is'.

[15:07] <autrijus> gaal: oh.

[15:07] <autrijus> nothingmuch: oh, btw, ANF.

[15:07] <nothingmuch> ?

[15:07] <autrijus> http://perlcabal.org/~autrijus/lab.tar.gz

[15:07] <autrijus> ANF SSA converter.

[15:07] <autrijus> including parser and runcore for both ANF and SSA

[15:07] <autrijus> pretty printer too iirc.

[15:07] <autrijus> have fun :)

[15:07] <nothingmuch> i'll try ;-)

[15:08] <gaal> autrijus: class Cipher::Arcfour is Cipher::Stream, which defines the "missing" method; the method is "..." only in the base class.

[15:08] <gaal> pointing this out since it may be the kind of OO bug you want to know of before a release ;-)

[15:08] <autrijus> gaal: ah okay... I wonder why is is broken

[15:08] <autrijus> yes I do, and I do, thanks!

[15:08] * autrijus ponders what is the bug

[15:16] <nothingmuch> moose

[15:16] <nothingmuch> about 60% of tests are parsed

[15:16] <gaal> wapiti

[15:16] <nothingmuch> spooky

[15:16] <pasteling> "nothingmuch" at 82.81.247.180 pasted "the script so far" (97 lines, 2.4K) at http://sial.org/pbot/13454

[15:18] <geoffb> <rez>

[15:18] <geoffb> I'm gone a day and a half, and everybody gets bloody talkative

[15:18] <geoffb> sheesh

[15:19] <geoffb> Well, before I backlog, from the highlighted message:

[15:20] <geoffb> stevan, obra: I'll be blogging weekly on O'Reilly.  The topic will vary, but will often relate to Perl and especially Perl 6, because, well, that's what I like.

[15:20] <nothingmuch> someone please explain is(("ab" ~~ /(a+|b)*/ && $0[-1]), "b", 're_tests 218/1 (#262)');

[15:20] <geoffb> Which reminds me, I need to turn my notes for this week into an actual post.  Tomorrow, I think.

[15:20] <nothingmuch> geoffb++; # /me wants to see what's next

[15:21] <geoffb> "-Ofun: The Most Important Optimization"

[15:22] <autrijus> geoffb++

[15:22] <geoffb> I'm thinking of doing "After -Ofun: Thoughts on Optimization" next, and then . . . well, topics welcome

[15:23] <autrijus> nothingmuch: it's testing that the captured stuff is 'b' instead of 'a'

[15:23] <autrijus> nothingmuch: the &&$0[-1] part is saying that the match shall succeed and we are testing the last captured block

[15:23] <nothingmuch> i thought $0 is just a string?

[15:23] <nothingmuch> is it really meaning $/ ?

[15:24] <nothingmuch> or is $/ really $0 ?

[15:24] <nothingmuch> and wtf is $<> if $0 and $/ are both whole match?

[15:24] <nothingmuch> I WANT MY MOMMY!

[15:24] <autrijus> $0 is the first capture group

[15:24] <autrijus> $0[-1] means the last subgroup in it

[15:24] <pasteling> "nothingmuch" at 82.81.247.180 pasted "ungrokked lines" (23 lines, 748B) at http://sial.org/pbot/13455

[15:24] <autrijus> I contend $0[-1] really means $/[-1]

[15:24] <pasteling> "nothingmuch" at 82.81.247.180 pasted "full output" (2048 lines, 169K) at http://sial.org/pbot/13456

[15:25] <nothingmuch> hmm

[15:25] <nothingmuch> right, it's subgroup

[15:25] <nothingmuch> hmmm

[15:25] <nothingmuch>  is(("abbbcd" ~~ /(<[abc]>)*d/ && $0[-1]), "c", 're_tests 240/1 (#296)');

[15:25] <nothingmuch> oh wait, that's a brain parse error

[15:26] <nothingmuch> we can use $/[-1] for now

[15:26] <geoffb> & breakfast, then massive backlogging

[15:26] <autrijus> gaal: enjoy :)

[15:26] <autrijus> er

[15:26] <autrijus> geoffb: enjoy :)

[15:26] <geoffb> :-)

[15:26] <gaal> ah, the wily <Tab> :)

[15:28] <nothingmuch> okay, we grok it all

[15:28] <nothingmuch> let me CI the script

[15:28] <nothingmuch> where to?

[15:28] <nothingmuch> hmm... i need to go now

[15:28] <gaal> util/?

[15:28] <nothingmuch> if anyone wants to pick up where i stopped - they're more then welcome, but i'll have to finish later

[15:28] <nothingmuch> gaal: it's a one time script

[15:29] <nothingmuch> we are converting rules.t and then then quitting

[15:29] <gaal> bar/?

[15:29] <nothingmuch> fair enough

[15:29] * gaal was joking, but util/bar/ might be good

[15:30] <autrijus> please just util ;)

[15:30] <nothingmuch> too late

[15:30] <nothingmuch> ../throw_away

[15:30] <nothingmuch> hola leo__ 

[15:30] <nothingmuch> your new PGE tests are %25 ready

[15:31] <leo__> hiho all

[15:32] <autrijus> hi leo :)

[15:32] <leo__> hi here too :-)

[15:33] * nothingmuch wonders if you can speed up svk push

[15:34] <autrijus> push -l ?

[15:34] <autrijus> put it into background? ;)

[15:34] <nothingmuch> ah

[15:34] <nothingmuch> won't -l make the commit log fuzzy?

[15:35] <nothingmuch> it's not blocking my work

[15:35] <autrijus> it would.

[15:35] <nothingmuch> http://svn.openfoundry.org/pugs/throw_away/

[15:35] <nothingmuch> a good commit log is worth a few seconds

[15:35] <nothingmuch> the script is pretty crazy... sorry ;-)

[15:35] <nothingmuch> anyway, it emits line per line

[15:36] <nothingmuch> with lines that it grokked printed as '$human_readable; # $orig' and lines it didn't as "###FIXME### $orig'

[15:36] <nothingmuch> i'm guessing that $human_readable should dump to a Test::Base format

[15:36] <nothingmuch> but I don't have time right now

[15:36] <svnbot6> r7268 | nothingmuch++ | minor refactoring of type pretty printer's AG

[15:36] <svnbot6> r7269 | nothingmuch++ | conversion tool for rules, and split up rules.t

[15:36] <svnbot6> r7270 | autrijus++ | * add throw_away to MANIFEST.SKIP so we don't acceidetally

[15:36] <svnbot6> r7270 | autrijus++ |   release it -- preferably nuke it before release.

[15:37] <nothingmuch> i'll finish this later if no one picks up

[15:37] <autrijus> cool, nothingmuch++

[15:38] <nothingmuch> anyway, ciao

[15:38] <kolibrie> see you, nothingmuch 

[15:38] <nothingmuch> hmmm

[15:38] <nothingmuch> someone please remind me to do the laundry when I get back

[15:38] <autrijus> nothingmuch: remember to do the lunadry when you get back

[15:39] <autrijus> er, laundry. creative dyslexia

[15:39] <nothingmuch> echo "$autrijus.repeat" | at now + several_hours 

[15:39] <autrijus> at: you do not have permission to use this program

[15:40] <nothingmuch> ciao

[15:45] <kolibrie> hmm, just updated my parrot svn, and now parrot won't compile

[15:46] <leo__> make realclean

[15:46] <kolibrie> did that

[15:46] <kolibrie> twice, actually

[15:46] <leo__> then I need more info

[15:47] <kolibrie> svn updated to r9331

[15:47] <kolibrie> imcc/main.c: In function ‘do_pre_process’:

[15:47] <kolibrie> imcc/main.c:400: error: ‘END’ undeclared (first use in this function)

[15:47] <kolibrie> imcc/main.c:400: error: (Each undeclared identifier is reported only once

[15:47] <kolibrie> imcc/main.c:400: error: for each function it appears in.)

[15:47] <kolibrie> imcc/main.c:414: error: ‘SAVEALL’ undeclared (first use in this function)

[15:47] <kolibrie> imcc/main.c:415: error: ‘RESTOREALL’ undeclared (first use in this function)

[15:48] <PerlJam> same here. (fwiw)

[15:48] <leo__> ah I see 1 minute

[15:49] <PerlJam> looks like imcc.y is missing a few tokens

[15:49] <leo__> no, main.c has(d) too much :)

[15:49] <leo__> r9332

[15:50] <leo__> sorry

[15:50] <kolibrie> leo__: thanks :)

[15:50] <PerlJam> ah, muy bueno

[16:14] <gaal> is the smoke server down for submitting smokes for you folks too?

[16:25] <svnbot6> r7271 | gaal++ | suggest smoke upload with system directory separator

[16:28] <gaal> is anyone using %*ENV<PUGS_SMOKE_UPLOAD> in practice? I want to break it and go through config.yml

[16:28] *** brentdax_ is now known as brentdax

[16:28] <gaal> and while i'm at it add an option to automatically upload successful smokes to the public smokeserver

[16:44] <nothingmuch> autrijus: ping

[16:48] <autrijus> nothingmuch: pong

[16:48] <autrijus> gaal: not me

[16:48] <nothingmuch> taken to /msg

[16:49] <autrijus> nothingmuch: I think you want to identify yourself.

[16:49] <autrijus> thank you freenode.

[16:49] <nothingmuch> odd, i have the script

[16:51] <nothingmuch> did you get it now?

[16:54] <autrijus> aye

[16:55] <autrijus> down to <4000 failures

[16:55] <autrijus> er

[16:55] <autrijus> I mean <400.

[16:55] <autrijus> still a long way to go

[17:07] <svnbot6> r7272 | iblech++ | * New t/builtins/io/say_and_print.t: Tests for &say and &print (triggered

[17:07] <svnbot6> r7272 | iblech++ |   by PIL2JS dieing on "str".say).

[17:07] <svnbot6> r7272 | iblech++ | * PIL2JS:

[17:07] <svnbot6> r7272 | iblech++ |   * Prelude::JS::IO: Support the method form of &say and &print.

[17:07] <svnbot6> r7272 | iblech++ |   * PIL::Subs: method foo (Bar @array:) {...} should not add a method

[17:07] <svnbot6> r7272 | iblech++ |     to Bar, but to Array. Fixed.

[17:43] <svnbot6> r7273 | iblech++ | * t/statements/io_leaking_into_runtime.t:

[17:43] <svnbot6> r7273 | iblech++ |   my $fh = BEGIN { my $f = open(...); ({$f}) } should not work, as a

[17:43] <svnbot6> r7273 | iblech++ |   compile-time filehandle would leak into runtime. force_todo'ed.

[17:43] <svnbot6> r7273 | iblech++ |   (Also noted that open("...", :w) does not work currently (FYI, &open did work

[17:43] <svnbot6> r7273 | iblech++ |   in r7105).

[17:43] <svnbot6> r7273 | iblech++ | * t/data_types/anon_block.t:

[17:43] <svnbot6> r7273 | iblech++ |   {...};    # should auto-execute

[17:43] <svnbot6> r7273 | iblech++ |   ({...});  # should not auto-execute (:todo<bug>'ed)

[17:45] <Limbic_Region> code that had previously been working for months is currently b0rk

[17:46] <Limbic_Region> unfortunately I have not tested it in a week or two

[17:46] <Limbic_Region> so I don't know when the problem was introduced

[17:46] * Limbic_Region tries to see if he can create a smaller test case

[17:49] <Limbic_Region> grrrrr

[17:50] <Limbic_Region> I hate when making a smaller test case makes the problem disapear

[17:50] <Limbic_Region> heisenbugs--

[17:56] <Limbic_Region> weird

[17:56] <Limbic_Region> found the bug

[17:57] <Limbic_Region> ?? :: vs ?? !!

[17:58] * Limbic_Region can't believe it has been that long since I tested this code though - perhaps I had the wrong version of pugs and the wrong version of the code

[17:58] <gaal> are you sure you have PERL6LIB set correctly?

[17:58] <Limbic_Region> gaal - yes

[18:02] <geoffb> Hah!  Finally caught up with backlog.  Only took 2 hours . . . .

[18:03] <autrijus> :D

[18:03] <autrijus> gaal: I found the cipher bug. fixing

[18:03] <autrijus> thanks for bringing it to my attention :)

[18:04] <gaal> autrijus: oo!

[18:07] <autrijus> minimal test case

[18:07] <autrijus> ?eval class A is B { method f {1} }; class B { method f {...} method g { ./f } }; say A.g

[18:07] <evalbot_7273> Error: *** ... - not yet implemented     at <eval> line 1, column 52-55  

[18:10] <autrijus> curiously

[18:11] <autrijus> ?eval class A is B { method f {1} }; class B { method f {...} method g { ./f } }; say A.new.g

[18:11] <evalbot_7273> 1 bool::true 

[18:11] <autrijus> that means class objects did not survive redispatch.

[18:11] <autrijus> even more reason for singleton-based metmaodels.

[18:14] <svnbot6> r7274 | gaal++ | use canonpath instead of catpath

[18:14] <gaal> I don't understand that last comment, (what are singleton-based metmaodels and) why isn't this "simply" a bug in the current implementation?

[18:15] <autrijus> gaal: okay. current MM1, MM2 and MM0(pugs runcore) distinguish between class meths and instance meths

[18:15] <autrijus> which means the dispatcher has to special-case in quite a few places

[18:16] <autrijus> and also leads to strange musings like "class Int is the undefined instance of itself"

[18:17] <gaal> I'm not familiar with the metamodel (am ordering the Art book today in fact, to fix that!)... Just wondering how a singleton might help

[18:17] <autrijus> gaal: I'm leaning toward having class objects like ::A simply be instance of type Class that happen to have various singleton methods installed into them

[18:17] <autrijus> so _all_ method calls are instance methods

[18:18] <autrijus> and the dispatcher won't need a duplicate copy of logic (which is what went wrong here)

[18:18] <gaal> okay, I think I see :)

[18:20] <PerlJam> autrijus: And don't you have to do something like that anyway to support the creation of anonymous classes that are created by tacking on "but" or "does" things?

[18:20] <svnbot6> r7275 | iblech++ | * t/subroutines/lvalue_subroutines.t: unEVAL

[18:20] <svnbot6> r7275 | iblech++ | * PIL2JS:

[18:20] <svnbot6> r7275 | iblech++ |   * README: Misc. fixes.

[18:20] <svnbot6> r7275 | iblech++ |   * New Prelude::JS::Proxy: Proxy class! (But not yet user-visible as the

[18:20] <svnbot6> r7275 | iblech++ |     MetaModel lacks class methods)

[18:20] <svnbot6> r7275 | iblech++ |       my $x := PIL2JS::Internals::new_proxy(

[18:20] <svnbot6> r7275 | iblech++ |         FETCH => {...},

[18:20] <svnbot6> r7275 | iblech++ |         STORE => -> $new {...},

[18:20] <svnbot6> r7275 | iblech++ |       );

[18:20] <svnbot6> r7275 | iblech++ |       say $x; $x = ...;  # works

[18:20] <svnbot6> r7275 | iblech++ | * ChangeLog: Minor update to PIL2JS section; also note that I forgot to mention

[18:20] <svnbot6> r7275 | iblech++ |   that my r7267 (log message "Changelogged r6963:r7266") only refers to PIL2JS,

[18:20] <svnbot6> r7275 | iblech++ |   sorry...

[18:20] <autrijus> PerlJam: aye, yes. unification good.

[18:23] <autrijus> gaal: anyway. the bug here is that the dispatcher for ./f sees the invoker is of type "Class", so it neglected to dispatch things for it

[18:23] <gaal> ack

[18:24] <autrijus> eg:

[18:24] <autrijus> ?eval class A is B { method f {1} }; class B { method g { ./f } }; say A.g

[18:24] <evalbot_7275> Error: No compatible subroutine found: "&f" 

[18:24] <leo__> autrijus: parrot always dispatches on obj.class - works fine

[18:25] <autrijus> leo__: so a class's .class is itself?

[18:25] <leo__> you can consider it as .get_class

[18:25] <autrijus> nod.

[18:28] <leo__> the class is itself a singleton, yes

[18:29] <leo__> so that klas.get_klass == klas

[18:29] <leo__> so that klas.get_class == klas

[18:30] * gaal is reminded of GObject...

[18:30] <svnbot6> r7276 | autrijus++ | * add the (currently failing) test for Cipher::Arcfour's bug.

[18:31] <gaal> they have the style of using "klass" as a varible referring to the class too.

[18:31] <autrijus> leo__: right, I think singleton is the way to go

[18:31] <leo__> I saw that a lot in python code

[18:31] <autrijus> ruby too iirc.

[18:48] * Aankhen`` goes to sleep.

[18:48] <Aankhen``> G'night.

[18:51] <Limbic_Region> autrijus - do you have an ETA for 6.2.10 ?

[18:53] <autrijus> Limbic_Region: yes, asap ;)

[18:54] <autrijus> depends how much help I get for changelogging etc

[18:54] <Limbic_Region> and that entails targeting the latest merged parrot (with new calling conventions) correct?

[18:54] <autrijus> yes.

[18:55] <Limbic_Region> so after that, porting the MM to the Haskell and Parrot backends?

[18:55] <autrijus> leo__: btw, "invoke" is gone?

[18:56] <leo__> autrijus: no, just that invoke with implict arguments

[18:56] <autrijus> Limbic_Region: no, port MM and containers to haskell, get 6.28.0 released, _then_ parrot

[18:56] <leo__> invoke foo # works fine

[18:56] <autrijus> Limbic_Region: I think it's better for parrot if we can figure out exactly what we demand from it :)

[18:56] <autrijus> leo__: what about invoke $P0 ?

[18:57] <autrijus> leo__: see http://perlcabal.org/~autrijus/foo.pir

[18:57] <autrijus> line 77

[18:57] <leo__> that's now invokecc $P0

[18:58] <leo__> or invoke $P0, $P1

[18:58] <autrijus> but I don't want to return :)

[18:58] <leo__> the latter takes the continuation too as arg

[18:58] <Limbic_Region> autrijus - has @larry looked at the MM?  I ask only because it seems to me that AES12 leaves a bit to be desired and I assumed stevan made educated guesses

[18:59] <autrijus> Limbic_Region: yes, he conversed extensively with $Larry

[18:59] <autrijus> see S12.5

[18:59] <autrijus> ./perl5/Perl6-MetaModel2.0/docs/S12.5.pod

[18:59] <autrijus> which is not yet very polished

[18:59] <autrijus> but I think the idea is that the MOP will be documented there.

[18:59] <gaal> autrijus, i'd :todo tests but i don't know what's fixable (or even a showstopper :)

[18:59] <Limbic_Region> ok - so 6.28.0 is realistic - wow

[18:59] <autrijus> gaal: you do actually :)

[18:59] <Limbic_Region> woooooooohooooooo

[19:00] <autrijus> gaal: please blindly :todo ahead and tell me anything that you don't feel comfortable

[19:00] <gaal> hee :)

[19:00] <gaal> ok

[19:00] <autrijus> gaal++

[19:00] <gaal> starting from the end.

[19:00] <gaal> (lexically)

[19:01] <autrijus> that's my usual order too :)

[19:01] <leo__> autrijus: see also http://groups.google.com/group/perl.perl6.internals/browse_thread/thread/84a72c2aaf83c847/d2efb9430a077b30?q=invoke+yield&rnum=2&hl=en#d2efb9430a077b30

[19:01] <autrijus> leo__: all very sensible, already fixed, thanks!

[19:02] <leo__> thx for the sensible

[19:02] <leo__> anyway, you can now just use PIR short syntax:

[19:03] <leo__> (a,b) = foo(c,d,e)

[19:03] <leo__> or

[19:03] <leo__> (a,b) = obj.foo(c,d,e)

[19:03] <autrijus> 'kay

[19:03] <leo__> this emits the argument passing opcodes already used in pugs

[19:04] <Limbic_Region> leo__ have you figured out how to provide for chip's named arguments sensibly or is that still a wish-list item?

[19:04] <svnbot6> r7277 | autrijus++ | * adjust "invoke" into "invokecc" as per Parrot's new callconv.

[19:04] <svnbot6> r7277 | autrijus++ |   (more parrotBrokenXXX fixes later) 

[19:04] <leo__> when it's python compatible, we will implement it

[19:05] <leo__> the big problem wa the magic Pair

[19:05] <leo__> chip has the design almost finished AFAIK

[19:05] <autrijus> named, lexpad, and kill-the-alligator-please varref

[19:06] <autrijus> is the three immediate things we'd need; everything else can be emulated :)

[19:06] <autrijus> s/varref/varreg/

[19:06] <leo__> the varreg is what exactly?

[19:06] <Limbic_Region> flexible parameters are a PITA - named, positional, optional, default values, slurpy or not, etc

[19:06] <autrijus> variable sized register frames.

[19:07] <autrijus> Limbic_Region: "easy things are easy; hard things should be slow" :D

[19:07] <leo__> ah ok, working on that

[19:07] <leo__> but first and needed is cleanup

[19:07] <autrijus> but in all seriousness, not slower than it should be.

[19:07] <leo__> e.g. pushtopp or such

[19:07] <autrijus> k

[19:08] <leo__> Limbic_Region: all but names works

[19:08] <leo__> default is optional + compiler code to provide the value

[19:09] <leo__> you might grep for :slurpy, :optional, and :opt_flag in t/op/calling.t

[19:09] <svnbot6> r7278 | autrijus++ | * INSTALL: We now really want Parrot 0.3.0.

[19:09] <svnbot6> r7278 | autrijus++ | * Also mention the good folks at PxPerl.

[19:09] <svnbot6> r7279 | autrijus++ | * Restore Cipher::Arcfour to its former tested glory as it's

[19:09] <svnbot6> r7279 | autrijus++ |   not its fault.

[19:11] <geoffb> Autrijus, before 6.2.10, would you mind giving STATUS a buffing?  I would do it myself, but I'm buried in $work today . . . and it seems good to have that file up to date with each release.

[19:12] <autrijus> geoffb: k

[19:12] * autrijus eagerly looks forward to the -Ofun article

[19:12] <geoffb> :-)  Tomorrow.

[19:12] <autrijus> woot.

[19:12] <geoffb> Or at least, that's the plan.

[19:13] * geoffb finds it very hard to convince himself to prioritize $work over Perl 6 . . . but sadly, must be done to pay bills

[19:14] <dduncan> is there an ETA for the next Pugs release?

[19:15] <Juerd> pugs was broken on feather

[19:15] <svnbot6> r7280 | autrijus++ | * $?SELF.method inside class methods are now redispatched with the

[19:15] <svnbot6> r7280 | autrijus++ |   correct invoker type, so inheritance works (see t/oo/class/inheritance.t)

[19:15] <svnbot6> r7280 | autrijus++ |   -- this has the potential of breaking existing tests...

[19:15] <Juerd> This has been for months

[19:15] <Juerd> I'm a bit disappointed that I hadn't heard about that yet

[19:15] <Juerd> (It was old because svk wanted user input)

[19:15] <Limbic_Region> Juerd - just replied to your zip question with my opinion

[19:17] <gaal> for $arrayref -> { ... }        # iterate or only enter block once?

[19:17] <gaal> in pugs it iterates.

[19:17] <gaal> what should it do?

[19:17] <dduncan> each array elem goes into $_, I think

[19:17] <dduncan> since no explicit arg specified

[19:17] <fglock__> gaal: Array does auto-dereferencing

[19:17] <gaal> okay, so t/statemets/for_with_only_one_item.t is wrong. fixing.

[19:18] <fglock__> for \$arrayref -> { ... } enters once

[19:19] <gaal> waitno, the p6-l thread stipulates it shoudl only enter once.

[19:20] <Juerd> gaal: It should NOT deref

[19:20] <autrijus> it should not deref.

[19:20] <Juerd> An object|reference should never derefence in list context

[19:20] <autrijus> what Juerd said.

[19:20] <autrijus> it wasn't clear, but it's clear now :)

[19:20] <autrijus> that also means

[19:20] <autrijus> $arrayref.map{}

[19:20] <autrijus> and

[19:20] <autrijus> map{}$arrayref

[19:20] <autrijus> do rather different things.

[19:21] <autrijus> (I meant .map:{} of course)

[19:21] <fglock__> ok

[19:25] <gaal> (thanks)

[19:25] <svnbot6> r7281 | autrijus++ | * another invoke -> invokecc fix; that puts sanity tests

[19:25] <svnbot6> r7281 | autrijus++ |   passing again for Parrot 0.3.0. leo++

[19:25] <svnbot6> r7282 | gaal++ | remove debug print

[19:25] <Limbic_Region> autrijus - how far after 6.28 will 6.283 be?  pmichaud got PGE whipped into shape or is there still a lot of work to do?

[19:26] <autrijus> er, uhm, compilers/pge/ has got no commits since July

[19:27] <autrijus> neither has the punie compiler

[19:27] <autrijus> so I don't really know about them...

[19:28] <Limbic_Region> ok

[19:28] <autrijus> we'll worry about it when we get to it :)

[19:29] <meppl> speaking "perl6" in german sounds like "perlsex" (perlsechs)

[19:29] <Ikarus> LOL

[19:29] <Ikarus> meppl: and that isn't accurate ?

[19:32] <meppl> germans put up that the number "6"(sechs) sounds like "sex"...

[19:32] <meppl> nobody laughs about that

[19:32] <Limbic_Region> only sex in germany doesn't sound like sex in english

[19:32] * eric256 is entertained by the mailing list...hehe for options, and for people liking mostly different options

[19:33] <eric256> did i get the right room? L~R's talking about sex in different countries | languages . lol

[19:35] <eric256> s/for/four/

[19:35] <Limbic_Region> eric256 - perhaps you weren't aware of one of Pugs mottos

[19:35] <Limbic_Region> . o O ( optimized for FUN )

[19:35] <eric256> lol. yea

[19:35] <autrijus> sex in german sounds like bad in german.

[19:37] <Limbic_Region> autrijus - which certainly begs the question "is sex like pizza when you are in germany"?

[19:37] <Limbic_Region> because even when it is bad - it is still good

[19:38] <Limbic_Region> ok, back to OT

[19:38] <Limbic_Region> err On Topic even

[19:38] <joao> good night

[19:38] <joao> or should I say, good evening

[19:38] <joao> :-)

[19:38] <autrijus> Limbic_Region++ # back to OT

[19:39] <autrijus> good localtime, joao.

[19:39] * joao smiles

[19:39] <joao> (GMT+0, 20:39)

[19:40] <autrijus> +2 here.

[19:41] <gaal> autrijus, oh, DST is finished where you are? we aren't in the same TZ after all :)

[19:41] <autrijus> :)

[19:41] <geoffb> Auuuggghh, timezones!

[19:42] * geoffb gets flashbacks from writing calendaring software

[19:42] <geoffb> DateTime.pm++ # Saving me

[19:42] * fglock__ gave up keeping DateTime::Set pass the timezones tests

[19:42] <svnbot6> r7283 | gaal++ | test TODOifications (still more left)

[19:44] <geoffb> It is amazingly hard to explain to people, BTW, that A) timezones are not trivial to deal with, especially in the face of cross-TZ date math, and B) No, we don't have a big database with every GPS location to correct TZ.

[19:45] <gaal> t/operators/binding/hashes.t is very Skippy

[19:45] <PerlJam> geoffb: screw timezones and do everything in UTC.  :)

[19:45] <geoffb> And C) even if we did, converting everyone's hand-typed local-formatted snail mail address to GPS coords would not be trivial

[19:45] <gaal> but the first test, the only one which isn't skipped, still fails

[19:45] <gaal> is that reasonable?

[19:45] <geoffb> PerlJam, internally I did.  Now if I could get users to think in UTC, it would have been much easier!

[19:46] <PerlJam> geoffb: and forget cross-TZ math, what about timezones where the offset from UTC varies with time?

[19:46] <eric256> geoffb actualy its not too bad..at least not in pure US addresses.. government releases the TIGER data which lets you do address to long/lat in a fairly reasonable manner...still agree with you though

[19:46] <PerlJam> (i mean more than the usual DST variability)

[19:47] <gaal> in .il the TZ situation probably wins the ludicrousity challenge

[19:47] <geoffb> PerlJam, hence my reason for converting in and out of UTC.  And I assume you mean "historical changes to timezones"

[19:47] <eric256> just make your customers adopt swatch beats, then they wont know when to expect it and wont know its comeing for the wrong time ;-)

[19:47] <gaal> it's set by politics and typically only scheduled a couple of years in advanced

[19:47] <geoffb> eric256, yeah, except at least half the userbase was spread across like 30 countries

[19:48] <geoffb> eric256, heh

[19:48] <gaal> a few years ago there *almost* was a non-continuous DST.

[19:48] <geoffb> gaal, ouch!

[19:48] <eric256> hehe mon-fri we are going to observer DST, on the weekends just set your clock to whatever you feel like ;)

[19:49] <PerlJam> geoffb: Well, if it's not now and not in the future, it's all historical :-)  but yeah, timezones where there's a 15 minute offset for a little while, then a 30 minute offset, but only for years before X and then a 1 hour offset (but only for years between Y and Z)  etc.

[19:49] <gaal> so, can someone look at t/operators/binding/hashes.t ?

[19:49] <geoffb> nodnod

[19:49] <gaal> and ..../arrays.t while yer at it

[19:50] * gaal <3 vim's :E

[19:50] * eric256 just got an email "You are prequalified to reciev a deploma"....hmmmm lol

[19:52] <autrijus> gaal: the current runcore only allows binding for simple vars

[19:52] <autrijus> gaal: I think I can kluge in support for element binding, but the fact is the current container model is not at all what we decided upon

[19:53] <gaal> autrijus: which is why the *rest* of the tests are skipped, no?

[19:53] <autrijus> so I think element binding shall wait till a proper port container model which will go with MM2-hs

[19:53] <autrijus> gaal: er right, but shouldn't the first one be todo feature as well?

[19:53] <gaal> ahhhh, they're skipped because they crash? ack ack ack

[19:53] <gaal> fixing.

[19:54] <gaal> well, todoing :)

[19:54] <autrijus> cool :)

[19:54] <autrijus>         names <- forM vars $ \var -> case unwrap var of

[19:54] <autrijus>             Var name -> return name

[19:54] <autrijus>             _        -> retError "Cannot bind this as lhs" var

[19:54] <autrijus> is the relevant part in Eval.

[19:54] <autrijus> so as you can see, only Var forms are bound.

[19:55] <eric256> is there a "haskel for poeple who can't  even look at haskel without getting a headache" page?

[19:55] <gaal> how does a subscripted element look there? 

[19:55] <gaal> s/does/would/

[19:56] <gaal> eric256: i think the hawiki has a few short practical examples, sec

[19:57] <gaal> http://haskell.org/hawiki/HaskellNewbie and the area

[19:57] <PerlJam> eric256: what about haskell gives you a headache?  

[19:58] <integral> some bits of pugs aren't exactly the prettiest haskell,  like the big multi-page functions :)

[19:58] <autrijus> integral: they are going away :)

[19:58] <autrijus> some of them, at least.

[19:58] <integral> yay! ;)

[19:58] <wolverian> wow, I can almost read haskell now. having a friend to learn with rocks :)

[19:58] <PerlJam> pugs is hardly typical of your average haskell program I think :)

[19:59] <gaal> i wonder what subset of perl we'll end up having available for Prelude.pm

[19:59] <autrijus> but there are good pieces too... the PIR codegen is quite concise

[20:00] <eric256> PerlJam, the spacing, the arrows pointing bothe ways the random $  things like 'forM vars $ \var' .... just things i don't understand because i don't understand haskel....and it would be fun to be able to actualy hack on some pugs internals... or at least read them. ;)

[20:01] <PerlJam> eric256: man, perl6 is going to give you *such* a headache then  ;-)

[20:01] <integral> $ is the same idea as || vs. or in perl5

[20:01] <autrijus> @names := for @vars -> $var { given unwrap($var) { when Var($name) { $name }; default { fail "Cannot bind this as lhs: $var" } }

[20:01] <autrijus> eric256: that's a rough translation

[20:02] <autrijus> except it's write wrong...

[20:02] <autrijus> @names := @vars.map(-> $var { given unwrap($var) { when Var($name) { $name }; default { fail "Cannot bind this as lhs: $var" } })

[20:02] <autrijus> is maybe better.

[20:03] <integral> pointies have to be the best invention in perl6

[20:03] <eric256> actualy PerlJam i'm quite comfortable with perl 6...guess the unknown just makes my head spin ;)

[20:03] <autrijus> it may be blasphemy, but I think VB9/C#3 has a better lambda syntax :)

[20:03] <eric256> thanks Atrijus that helps alot. 

[20:03] <autrijus> var => var.foo

[20:03] * eric256 gasps

[20:04] <Limbic_Region> PerlJam - *some* perl6 is likely to give eric256 a headache

[20:04] <integral> hmm, that makes me think of epigram's case matching

[20:04] <eric256> some perl5 gives me headaches though so thats no surprise...

[20:04] <gaal> we should definitely fix open :w for this release :)

[20:05] <gaal> (taking a look)

[20:13] <gaal> undef.say("this shouldn't print"); # does

[20:13] <gaal> (to stdout)

[20:14] <autrijus> easy to explain

[20:14] <autrijus> ?eval 12.say(34)

[20:14] <evalbot_7283> 1234 bool::true 

[20:14] <autrijus> but, of course, wrong.

[20:15] <gaal> Prim ops can't tell they're being invoked OOPishly?

[20:15] <svnbot6> r7284 | autrijus++ | * surprisingly, the last class-method fix cured a rule_used_in_Str bug.

[20:15] <gaal> hee!

[20:16] <autrijus> gaal: it could, it's a List thing bug.

[20:16] <autrijus> gaal: 1.foo(2), failing to find things, looks &foo(1:2) instead

[20:16] <autrijus> and if &foo is *@_, it silently passes.

[20:17] <wolverian> where should it stop looking?

[20:17] <gaal> they perhaps oughta: there's some chicanery eg in the implementation of split where it figures out which is the delimiter and which is the string. it shouldn't have to

[20:18] <autrijus> nod. I'm not 100% clear on this.

[20:24] <gaal> how to raise a catchable exception in a Prim?

[20:25] <autrijus> fail

[20:25] <autrijus> incidentally identical to the perl6 idiom :)

[20:25] <gaal> um, how to convert a ghc library fail to a catchable excption? :)

[20:25] <gaal> ...liftIO $ somethingThatFails

[20:25] <autrijus> tryIO ?

[20:25] <gaal> but i don't want to return undef

[20:26] <gaal> and i'd like to propagate the actual error

[20:26] <gaal> error message at leat.

[20:26] <gaal> least

[20:27] <autrijus> tryIO err = liftIO . (`catch` (const $ return err))

[20:27] <gaal> catch \e -> fail e ?

[20:27] <autrijus> so maybe

[20:27] <autrijus> import try from System.IO.Error

[20:27] <autrijus> v <- liftIO $ try action

[20:28] <autrijus> case v of

[20:28] <autrijus>     Left err -> fail (show err)

[20:28] <autrijus>     Right ....

[20:28] <autrijus> that looks most portable.

[20:28] <autrijus> improvise :)

[20:28] <gaal> okie, thanks.

[20:28] <autrijus> np :)

[20:29] <autrijus> actually.

[20:29] <autrijus> I wonder if our liftIO should get that automagically.

[20:29] <autrijus> a bit extreme maybe. have a new "doIO" form?

[20:30] <autrijus> doIO :: (MonadIO m) -> IO a -> m a

[20:30] <autrijus> anyway, do as you see fit :)

[20:33] <gaal> I was thinking of something like that, yes, because eventually we'd want these things to turn into a p6 fail

[20:35] <autrijus> and it's good practice anyway

[20:36] <autrijus> gaal: so, let me check in this fix and see if it kills our performance?

[20:37] <gaal> you're too fast for me autrijus :)

[20:38] <gaal> how come this has anything to do with performance though?

[20:40] <autrijus> gaal: let me think about it a bit

[20:41] <autrijus> we'd like liftIO to automagically propagate "fail" upward

[20:42] <autrijus> yet we'd like tryIO to not use that version of liftIO.

[20:46] <autrijus> okay, committing

[20:51] <svnbot6> r7285 | autrijus++ | * Guard all IO errors and promote them into Eval errors.

[20:52] <gaal> whee :)

[20:52] <autrijus> gaal++ # good idea

[20:52] <autrijus> hadn't finished compilation though so not sure ifit even works

[20:53] <Shillo> Hullo, folks. :)

[20:56] <autrijus> ugh I broke the build with that.

[20:56] <autrijus> fixing

[20:56] <autrijus> fixed.

[20:57] <autrijus> but it made things hang indefinitely.

[20:58] <autrijus> clearly, bad idea

[20:58] <eric256> is there a way to use GHC interativly?

[20:58] <geoffb> :-/

[20:59] <eric256> i don't see an option for that

[20:59] <autrijus> eric256: ghci

[20:59] <gaal> maybe not make it mandatory, use another funciton?

[20:59] <gaal> ghci

[20:59] <autrijus> ghc --interactive

[20:59] <eric256> thanks

[20:59] <gaal> doIO as you proposed originally?

[20:59] <joao> is there a good idea to "make test" , and try to fix failed tests? (i mean, is it a good idea to start helping? :P )

[20:59] <gaal> is it hanging because something is recursively lifting? (can that make sense?)

[21:00] <dduncan> seen mugwump

[21:00] <jabbot> dduncan: mugwump was seen 35 days 16 hours 43 minutes 20 seconds ago

[21:00] <gaal> joao: of course! :)

[21:00] <joao> t/builtins/arrays/shift............................FAILED test 27

[21:00] <joao>         Failed 1/27 tests, 96.30% okay

[21:00] <autrijus> gaal: I'm going with "guardIO"

[21:01] <autrijus> compiling, will checkin shortly

[21:01] <joao> How do I know which is test 27? :P

[21:01] <autrijus> joao: oh, definitely

[21:01] <autrijus> joao: 1/27 so it's the last test.

[21:01] <gaal> joao: you can use `prove` with pugs, and then in verbose mode it prints a line number.

[21:01] <autrijus> joao: if you made "make smoke" instead you'll see the line number.

[21:01] <gaal> you'll need:

[21:01] <gaal> export HARNESS_PERL=./pugs

[21:02] <joao> hmmm

[21:02] <gaal> export PERL6LIB=blib6/lib

[21:02] <svnbot6> r7286 | autrijus++ | * tryIO is also used in Main.hs.  My bad.

[21:02] <gaal> and then

[21:02] <gaal> prove -v t/builtins/arrays/shift

[21:02] <gaal> .t

[21:02] <joao> oh, thank you gaal :)

[21:02] <joao> do you recommend any test for me to start?

[21:03] <gaal> as autrijus said, you can run everything automatially with `make smoke`, this even creates one of those pretty matrices you can send off to the smoke server so that everybody sees your results.

[21:03] <Shillo> autrijus: Hey, a friend (and a coworker) of mine were in ICFP. He said he saw you in the hall and was too intimidated to even say hi. That after all my raving about Perl6/Pugs at work. ;)

[21:04] <joao> (i don't know much about testing, but it seems a good place to start: I learn how to test and I have defined things to try to do in pugs :) )

[21:05] <gaal> joao: well, we're mostly in release engineering mode now, so we're doing housecleaning, looking over all failing tests and marking them either as bugs or as pending features

[21:05] <autrijus> Shillo: aw. :)

[21:05] <autrijus> joao: you can just start with the shift one

[21:06] <gaal> this isn't quite getting into pugs internals, but think of it as getting up to date :)

[21:06] <autrijus> joao: we are ni release-engineering phase

[21:06] <autrijus> so that last test is likely not a regression

[21:06] <autrijus> but something pugs does not yet support

[21:06] <joao> I'll start practicing at least, so that I can be more useful in the future :)

[21:06] <autrijus> joao: in fact, make sure you have a recent enough version.

[21:07] <autrijus> as I distinctly remember I've TODO'ed it.

[21:07] <autrijus> one of the thing about pugs development is that builds have a half life of about 10 minutes ;)

[21:07] <Shillo> autrijus: From his description, my first association was 'Leader of the bad guys in a kung-fu movie' :)

[21:08] <gaal> autrijus: build still failsforme

[21:08] <joao> autrijus: it's recent

[21:08] <joao> r7283

[21:09] * Shillo tries to svn up and build...

[21:09] <autrijus> joao: okay

[21:10] * Shillo thinks it through and first updates parrot.

[21:10] <Shillo> I'll see about building with embedded parrot-0.3.0

[21:11] <leo__> wait a bit w parrot

[21:11] <Shillo> leo__: Okie.

[21:11] <autrijus> Shillo: I wonder why "bad guy" :)

[21:11] <leo__> 2 mins or so - just fixing compile bugs

[21:12] <Shillo> autrijus: His description was: tall, imposing Asian guy with a long hair.

[21:12] <svnbot6> r7287 | gaal++ | some more TODOs

[21:13] <Shillo> autrijus: Think the guy at the end of Azumi. Or Sephiroth. :)

[21:13] <autrijus> joao: okay, my :todo of that test is troublesome

[21:13] <autrijus> joao: look at the test at line 76

[21:13] <joao> I thought all asian bad guys had mustache

[21:13] <autrijus> you'll see that the :todo should be in the parens

[21:13] <Shillo> leo__: Ick. Been fixing the compile bugs at work the whole day. Just the phrase 'compile bugs' makes me jittery. :)

[21:14] <gaal> that's a lot of mustaches

[21:14] <autrijus> same applies to other tests in that directory: try "should not work on scalars"

[21:14] <joao> hmm

[21:14] <autrijus> grep it there and fix it for me please :)

[21:14] <autrijus> joao: got a committe rbit?

[21:14] <autrijus> if not, your email?

[21:14] <joao> autrijus, i do i do

[21:14] * joao grins

[21:15] <autrijus> ok :)

[21:15] <autrijus> joao++

[21:15] <autrijus> then, also fix AUTHORS so it has your name

[21:15] <joao> if I actually do something cool, in the future, yes

[21:15] <eric256> HEHEHEH.../me just compiled his ver first hskel program. and feels like a kid at christmas

[21:16] <Shillo> leo__: 9340 built without problems. :)

[21:16] <joao> autrijus, there are three ":todo<bug>" related with  "should not work on scalars" , is that it?

[21:17] <joao> "you'll see that the :todo should be in the parens" <- what do u mean?

[21:18] <kolibrie> eric256++ # learning haskell

[21:18] <svnbot6> r7288 | autrijus++ | * guarded liftIO is now guardIO.

[21:18] <autrijus> joao: it should be

[21:18] <autrijus> is(foo, bar, "desc", :todo<bug>)

[21:18] <autrijus> but I made it

[21:18] <autrijus> is(foo, bar, "desc"), :todo<bug>

[21:19] <autrijus> eric256++

[21:19] <autrijus> joao: nah, you belong in AUTHORS the second you pointed out the test error :)

[21:20] <leo__> Shillo: parrot builds, yes, but generating libs fails as well as tests (the former after realclean) 

[21:20] * leo__ comitting

[21:21] <Shillo> Oh. Right, I didn't do make clean.

[21:22] <Shillo> Hmm, in one thing, Haskell and C++ have exactly the same problem. Build times.

[21:22] <gaal> Shillo: when in a rush, `make unoptimized`

[21:23] <autrijus> Shillo: hugs has no such problem :)

[21:23] <gaal> in a rush to build anyway. it doesn't pay off if you need to run the thing you builtt ;-)

[21:23] <autrijus> but it's good for "it compiles, let's ship it" mode.

[21:23] <Shillo> autrijus: True. :)

[21:23] <autrijus> gaal: it's annoying that build-without-prelude doesn't work for rx_ macros

[21:24] <autrijus> putter is responsible for that, I think

[21:24] <autrijus> but it means preludeless cannot participate in testing

[21:24] <autrijus> as it's too late for macro time

[21:24] <autrijus> probably a post-release issue.

[21:24] <gaal> who was it that wanted to hack on pugs to return inlined source prelude?

[21:24] <Shillo> I guess I got really jaded at work today.

[21:24] <gaal> eric256! that was you! :)

[21:24] <eric256> and anyone on windows without like a gig of memory can't compile prelude ;( (/me speeks of his own issues)

[21:24] <Shillo> 5M lines of code. 10 platforms. 3 active branches. 1 build master.

[21:24] <eric256> gall, that was me.  hince the learning of haskel

[21:25] <gaal> eric256++ # metooing

[21:25] <gaal> what has 5MLOC?

[21:25] <autrijus> gaal: Shillo's $job

[21:26] <gaal> oh. that's a lot. largest project i saw up close was just under half that.

[21:26] <Shillo> gaal: I won't go on about the FORTRAN bits. :p

[21:26] * gaal grins

[21:26] <gaal> so i won't go into the XML parts :)

[21:27] <Shillo> C, C++, FORTRAN, Python, Scheme, XML, XSL.

[21:27] <leo__> Shillo: parrot r9341 is in

[21:27] <Shillo> Mind you, developing it is a lot more fun than building it. :)

[21:27] <Shillo> Problem, some developers have too much fun. :p

[21:28] * Shillo tries make realclean this time...

[21:29] <Shillo> leo__: When I set cxx, it doesn't assume that I want linker to be the same. Took me a couple tries.

[21:30] <autrijus> gaal: is the build building for you?

[21:30] <autrijus> I havn't really put guardIO to use

[21:30] <autrijus> so if it hangs I wouldn't know

[21:31] <leo__> Shillo: you have to set --link too, and --ld (iirc)

[21:31] <Shillo> Yeah. Set --link, but it didn't gripe about --ld.

[21:31] <leo__> put that will be resolved soon

[21:31] <Shillo> Well, errr...

[21:32] <Shillo> I'm running in pre-beta Ubuntu Breezy. c++ isn't symlinked. Neither is g++. :)

[21:32] <leo__> --cxx=  # the 4th one ;-)

[21:32] <Shillo> parrot built successfully. :)

[21:33] <svnbot6> r7289 | autrijus++ | * chases Parrot-side changes of s/isnull/if_null/g

[21:33] <Shillo> 'consider using make unoptimized instead' Funny. :) you didn't just commit it, did you? :)

[21:33] <Shillo> (or did I just fail to notice it?)

[21:33] <autrijus> Shillo: I shall notice that no-one really read Makefile.PL messages :)

[21:34] <eric256> . operator is interesting in haskel.

[21:34] <gaal> autrijus: yes, i'm converting some prims to guardIO

[21:34] <autrijus> "make unoptimised" and "make unoptimized" both works for some time now.

[21:34] <autrijus> eric256: indeed, it's interesting in math too

[21:34] * Shillo tries, with timing...

[21:35] <joao> eric256, function composition?

[21:35] <gaal> Shillo: if you *always* or almost always need one over the other then vi config.yml

[21:37] <gaal> autrijus: should i avoid %s,liftIO,guardIO,g in Prim? You mentioned a possible perf hit?

[21:37] <nothingmuch> Richard Gere just taught me that old people can also have fun

[21:37] <joao> what is the nationality of fglock? (did my xchat translated the quit message?)

[21:37] <autrijus> broquaint: you are quite crazy. er, "inspired".

[21:37] <nothingmuch> i'm shocked

[21:38] <joao> nothingmuch, heh :)

[21:38] <autrijus> gaal: I don't know, need measurement, I wouldn't oppose to that.

[21:38] * nothingmuch crashed on his mom & sister watching this new movie where he is miserable, but then learns dancing

[21:38] <nothingmuch> anyway, time to bike

[21:38] <nothingmuch> err, the verb is actually cycle, right?

[21:39] <autrijus> broquaint: I think Params::Named would work nicely

[21:39] <gaal> "sweat" i think

[21:39] <nothingmuch> seen stevan

[21:39] <jabbot> nothingmuch: stevan was seen 8 hours 28 minutes 26 seconds ago

[21:39] <nothingmuch> phooey

[21:40] <Shillo> 4 minutes. Not too bad. :)

[21:40] <eric256> hehe the factorial function in haskel makes perl seem brutish... ;)

[21:41] <autrijus> ?eval { $_ ?? $_ * &?SUB($_-1) !! 1 }.(10)

[21:41] <evalbot_7288> Error: No compatible subroutine found: "&?SUB" 

[21:41] <autrijus> ?eval { $_ ?? $_ * &?BLOCK($_-1) !! 1 }.(10)

[21:41] <evalbot_7288> 3628800 

[21:41] <Shillo> ?eval [*] 1..10

[21:41] <evalbot_7288> 3628800 

[21:41] <autrijus> ?eval 3628800

[21:41] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:42] <autrijus> er wha?

[21:42] <Shillo> :)

[21:42] <autrijus> is that a cruel joke?

[21:42] <eric256> its a funny joke thats for sure

[21:42] <joao> lol!

[21:42] <autrijus> ?eval 10

[21:42] <evalbot_7288> 10 

[21:42] <autrijus> ?eval 1000

[21:42] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:42] <joao> ?!?

[21:42] <eric256> LOL

[21:42] <joao> ;)

[21:42] <joao> ?eval 666

[21:42] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:42] <joao> ?eval 665

[21:42] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:42] <Shillo> Number in numeric context is /not/ its string length? :)

[21:43] <joao> ?eval my $x = 1000

[21:43] <evalbot_7288> \1000 

[21:43] <Shillo> ?eval "1000"

[21:43] <evalbot_7288> '1000' 

[21:43] <Shillo> ?eval _+"1000"

[21:43] <evalbot_7288> Error: No compatible subroutine found: "&_" 

[21:43] <autrijus> ?eval 01000

[21:43] <Shillo> ?eval +"1000"

[21:43] <evalbot_7288> Error:  unexpected end of input expecting octal digit 0100 is not octal in perl6 any more, use 0o100 instead. 

[21:43] <evalbot_7288> 1000.0 

[21:43] <autrijus> ?eval 0o1000

[21:43] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:43] <Shillo> ?eval +1000

[21:43] <evalbot_7288> Code to eval exceeds maximum length limit.

[21:44] <Shillo> ?eval 1000

[21:44] <evalbot_7289> Code to eval exceeds maximum length limit.

[21:45] <eric256> can the argument list of a haskel function have a comparison?  factorial <1 = 0l; -- ?

[21:45] <joao> no

[21:45] <autrijus> sorry, but I had to:

[21:45] <autrijus> ?eval 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

[21:45] <evalbot_7289> Error:  unexpected "x" expecting "\\", "$!", "$/", "$" or "'" 

[21:46] <autrijus> something's very wrong with this bot.

[21:46] <autrijus> eric256: sure, easily

[21:46] <autrijus> factorial x | x < 1 = 0

[21:46] <joao> autrijus, not in the argument list

[21:46] <joao> :)

[21:46] <autrijus> joao: I wouldn't argue whether the guard is part of the arglist :)

[21:47] <joao> I don't consider it :)

[21:47] <joao> f x y z | x > 1 = 0

[21:47] <joao> x y z is the arg list

[21:47] <joao> ;)

[21:47] <joao> imo

[21:47] <eric256> since /me doesn't know what a gard is ...but assumes is the part after the | and before the =

[21:47] <autrijus> eric256: yup.

[21:47] <joao> eric256, yes

[21:48] <gaal> eric256: http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html

[21:48] <justatheory> seen autrijus

[21:48] <jabbot> justatheory: autrijus was seen 1 minutes 29 seconds ago

[21:48] <svnbot6> r7290 | autrijus++ | * bytes($code) > 500, not bytes($code > 500), I'd say.

[21:49] * eric256 fears that link for now...too much information this early could be bad for my head ;)  page 41 of a 198 page tutorial hehe

[21:49] <gaal> hee

[21:50] <gaal> eric256: it's a great reference to have handy; it's a tool not a tutorial.

[21:51] <Shillo> ?eval { {$_.(5)}.(&?CALLER_CONTINUATION) }.()

[21:51] <evalbot_7290> Error: Undeclared variable: "&?CALLER_CONTINUATION" 

[21:51] <Shillo> ?eval say { {$_.(5)}.(&?CALLER_CONTINUATION) }.()

[21:51] <evalbot_7290> <SubBlock(<anon>)> Error: cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode) 

[21:51] <Shillo> Ah. Got a bug. :

[21:51] <eric256> i bookmarked it for reference. thanks gall

[21:51] <eric256> sorry. gaal. i keep doing that

[21:52] <Shillo> (aside from the fact that I should've said say do {...}

[21:53] <gaal> no worries, eric :)

[21:54] <eric256> i shoulda learned haskel while still in high school. this would have made math class ridiculously easy. lol. mathematical functions seem to map seemlessly into haskell

[21:55] <autrijus> eric256: it's said to be the interface between academics and computers.

[21:55] <joao> here we learn haskell in the first year

[21:55] * gaal wonders when Casio'd start making calcs with ghc on them...

[21:55] <Shillo> autrijus: I always thought that was whiteboard and a graduate student. ;)

[21:55] <eric256> i'd never even heard of haskell before pugs came aroung

[21:55] <gaal> RAM would need to egt cheaper first.

[21:56] <autrijus> Shillo: Haskell is a conspiracy organized by a make-graduate-student-obsolete committee 

[21:56] <Shillo> gaal: What do you mean, my phone has 20 megs, expandable to 300 megs. :)

[21:57] <gaal> Shillo: if you expand it to its maximum you might be able to make unoptimized with no precompilation :)

[21:57] <joao> after a code change, is "make" recommended ?

[21:58] <autrijus> joao: code, as in "src/", then yes

[21:58] <autrijus> if just in "t/", no need to bother.

[21:58] <joao> i'm playing around with src/

[21:58] <joao> and "make" is too slow :(

[21:59] <Shillo> ?eval say sub{1}.()

[21:59] <evalbot_7290> <SubRoutine(<anon>)> Error: cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode) 

[21:59] <autrijus> "make unoptimized"

[21:59] <Shillo> ?eval say (sub{1}).()

[21:59] <evalbot_7290> 1 bool::true 

[21:59] <joao> that's why I've asked ;)

[21:59] <Shillo> Is this supposed to work like this?

[21:59] <joao> jsut to be sure

[22:00] <gaal> ?eval {1}.()

[22:00] <evalbot_7290> 1 

[22:00] <autrijus> Shillo: not sure... I think sub forms should bind tighter, but it's not docced iirc

[22:01] <Shillo> ?eval say {1}.()

[22:01] <evalbot_7290> <SubBlock(<anon>)> Error: cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode) 

[22:01] <Shillo> ?eval say {1}

[22:01] <evalbot_7290> <SubBlock(<anon>)> bool::true 

[22:02] <Shillo> ?eval true.()

[22:02] <evalbot_7290> Error:  unexpected "." expecting term 

[22:02] <Shillo> ?eval 1.()

[22:02] <evalbot_7290> Error: cannot cast from VRat (1%1) to Pugs.AST.Internals.VCode (VCode) 

[22:04] <Shillo> Actually say {...} seems to bind too tight.

[22:04] <autrijus> aye

[22:04] <autrijus> p6l it?

[22:07] <Shillo> ?eval sub f($x) { say $x; } f {1}.()

[22:07] <evalbot_7290> 1 bool::true 

[22:07] <Shillo> See? Only broken for say.

[22:08] <autrijus> ?eval sub f(*@_) { say @_ } f {1}.()

[22:08] <evalbot_7290> <SubBlock(<anon>)> Error: cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode) 

[22:08] <eric256> is p6 going to let you do "multi sub f (1) { 1 };  multi sub f (n) { n * f(n-1)}" ? i thought i heard something along those lines

[22:08] <autrijus> no, it's broken for all listops.

[22:08] <autrijus> eric256: yes, that is specced and will be supported. not this moment though

[22:09] <autrijus> it arguably belongs to 6.2831.

[22:09] <autrijus> constraint-based typing and desugaring

[22:10] <Shillo> autrijus: Hmm. :)

[22:10] <autrijus> Shillo: it's due to the eager scanning of arg-like constructs

[22:10] * autrijus ponders.

[22:10] <autrijus> please p6l it :)

[22:11] <Shillo> Hmm, not sure how to pose the question...

[22:11] <Shillo> If anything, slurpy scan should bind looser than normal scan, no?

[22:13] <autrijus> hm, but the problem is that block is parsed before normal ops

[22:13] <autrijus> consider

[22:13] <autrijus> foo:{...}.();

[22:14] <autrijus> would you think the :{} belong to foo first?

[22:14] <autrijus> if so, our parsing need to ignore block form for the first parts (before colon)

[22:14] <autrijus> anyway, it's tricky

[22:14] <Shillo> Well... I tend to think of '.' as VERY sticky glue between its two sides.

[22:15] <autrijus> I think I agree with you

[22:15] <autrijus> but I'd like it reviewed and codified as a test :)

[22:15] <Shillo> I'd think f{...}.() should push {} towards f. f {...}.() shouldn't?

[22:15] <autrijus> I don't really know :-/

[22:15] <autrijus> I don't think whitespace matters here

[22:15] <autrijus> but that just be me.

[22:15] <autrijus> s/just/may just/

[22:24] <joao> autrijus, what desc do I put for dies_ok(foo,'desc',:todo<bug>); ? 

[22:25] <gaal> "foo raises an exception"?

[22:25] <Shillo> Sent to p6l. :)

[22:25] <joao> gaal, I've just put the ')' in its place O:)

[22:25] <joao> "embarrassing commit" ?

[22:25] * joao smiles

[22:25] <gaal> "fix test" is fine

[22:26] <gaal> and no commit is too small ;)

[22:26] <joao> :)

[22:26] <autrijus> Shillo++

[22:27] <gaal> I've got a guardIO patch pending but I want to see it pass a few tests before I commit.

[22:27] <autrijus> joao: "fix bad autrijus's bad bad typo in TODOing array tests"

[22:27] <autrijus> or something like that.

[22:28] <autrijus> gaal: sure

[22:29] <joao> autrijus, heh :) better not :) fix typo in array tests sounds cool.. i am just looking for my passwd O:)

[22:34] <joao> autrijus, have you ever cleaned users from the rt?

[22:34] * joao smiles

[22:35] <joao> I can't find my username in the rt..

[22:36] <joao> I guess you'll have to send the email again

[22:37] <gaal> joao: what was your username there?

[22:40] <joao> gaal, joao and I think I forgot to activate it back in July.. so I activated it now

[22:40] <joao> gaal, I can't see me in the list, though

[22:40] <autrijus> that's fine. your uid is joao?

[22:40] <joao> yes

[22:41] <Shillo> G'night, all.

[22:41] <autrijus> joao: log in once?

[22:42] <joao> Unverified account. Please verify your account first.

[22:42] <joao> After my verification...

[22:42] <joao> weird

[22:42] <autrijus> weird. 

[22:42] <autrijus> a sec.

[22:43] <eric256> hmmm. either the person who wrote this example never ran it....or i'm missing something....(probably the later)

[22:43] <joao> You are now a registered user on OSSF, the online development environment for Open Source projects.

[22:43] <joao> You are now a registered user on OSSF, the online development environment for Open Source projects."

[22:43] <joao> ooops

[22:43] <joao> sorry

[22:43] <joao> :(

[22:44] <autrijus> np... fixing

[22:44] <joao> thank you :)

[22:44] <joao> sorry to bother

[22:46] <svnbot6> r7291 | gaal++ | Use guardIO where applicable. Some Prims are using boolIO still, need

[22:46] <svnbot6> r7291 | gaal++ | to spec their return values?

[22:46] <eric256> "test.hs:19:8: parse error on input `doGuess'" any idea what i should be looking for?

[22:47] <gaal> eric256: nopaste?

[22:49] <eric256> whats that url again?

[22:49] <gaal> [ot] anyone know how to make the tab bar in FireFox use two rows? I've got lots of open tabs and the rightmost ones are getting hidden

[22:49] <gaal> perlbot nopaste

[22:49] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[22:49] <pasteling> "eric256" at 66.102.136.70 pasted "Haskell tutorial code" (23 lines, 526B) at http://sial.org/pbot/13459

[22:50] <eric256> if i comment out lines 19 and 22 then all works well

[22:50] <eric256> never mind...turns out haskell cares about whitespace

[22:51] <eric256> that probably should have been mentioned somewhere

[22:51] <eric256> ;)

[22:51] * eric256 scans up the tutorial and finds the important wording in a paragraph he skipped. lol

[22:51] <gaal> it does indeed. it's called layout. very annoying at first :) but it's great for golf.

[22:53] <eric256> i wondered how it knew where my do was ending...but i figured it must be smart. lol

[22:56] <svnbot6> r7292 | joao++ | Fix typo in array tests

[22:57] <autrijus> also, layout is optional.

[22:57] <autrijus> GHC internals, for example, uses braces and semicolons.

[22:58] <gaal> not when reading existing code :)

[22:58] <autrijus> do { x <- blah; foo; y <- bleh; return baz }

[22:58] <autrijus> replace <- with = and it looks clearly procedural :)

[23:00] <joao> replace do by >>= and i call you insane ;)

[23:01] <autrijus> GHC uses `thenM`

[23:01] <autrijus> which is far more insane :)

[23:01] <gaal> it should use `ohAnd`

[23:01] <joao> :)

[23:02] * gaal is still tracking down the problem with open

[23:02] <svnbot6> r7293 | autrijus++ | * add JOAO to AUTHORS as he is too modest to do it himself. :D

[23:02] <autrijus> I think `byTheWay` works too

[23:03] <joao> r7294 | joao++ I * remove JOAO from AUTHORS and kick autrijus :)

[23:03] <perlbot> What kind of idiot karmas himself?  Your kind of idiot!

[23:03] <autrijus> rofl

[23:03] <autrijus> I need to sleep, though

[23:04] <autrijus> journal up. see ya tomorrow :)

[23:04] <joao> you don't sleep, remember?

[23:04] <joao> :)

[23:04] <autrijus> beg your pardon, I may code in my sleep, but I still sleep

[23:04] * autrijus waves &

[23:04] <joao> :)

[23:04] <autrijus> :))

[23:04] * joao waves

[23:05] <gaal> night A

[23:27] <dduncan> night B

[23:37] <joao>              +

[23:37] <joao> -----------------

[23:39] <gaal> hmm, out of wakies myself. see you later!

[23:39] <gaal> zzZZZ &

