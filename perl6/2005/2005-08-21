[00:01] <svnbot6> r6387 | putter++ | pugsbugs/parsing_do_my.t: do{my $a = 3; $a} yields Undeclared variable: "$a"

[00:47] <fglock_> hi

[00:51] <fglock_> Pugs has few people in my timezone span :(

[00:53] <dudley> what timezone? I often feel the same way. (GMT -6)

[00:53] <fglock_> GMT-3

[00:54] <fglock_> I have some 'List' code that I think belongs to Prelude

[00:55] <fglock_> but I'm not sure I can place it there without breaking something

[00:55] <dudley> Throw it in, there's always "svn revert" :)

[00:56] <dudley> bbiab

[00:56] <fglock_> How can I load Pugs without the precompiled Prelude (I mean, recompiling Prelude)

[01:06] <dudley> fglock_: if you turn it off in config.yml, does it recompile?

[01:06] <dudley> I thought I heard someone mention that a while back, but I've never tried it.

[01:07] <fglock_> (trying)

[01:15] <fglock_> dudley: it should work, but it requires that Pugs be recompiled

[01:16] <fglock_> ?eval (1,2,3).ref

[01:16] <evalbotzy> ::Array 

[01:16] <fglock_> is there a way to create a 'List'

[01:22] <dudley> ?eval ::Array.isa(List)

[01:22] <evalbotzy> bool::true 

[01:24] <fglock_> (!)

[01:24] <fglock_> ?eval my $x=List.new; $x.ref

[01:25] <evalbotzy> ::List 

[01:25] <fglock_> he

[01:25] <dudley> whoa, pugs just segfaulted

[01:32] <gantrixx> so if an child object inherits all methods from the parent, can the methods be overwritten in the child or must they be defined in the parent as submethods?

[01:34] <fglock_> gantrixx: the child class can override methods

[01:44] <dudley> I thought submethods weren't inherited...

[01:46] <fglock_> submethods aren't inherited

[01:46] <dudley> Oh, you were saying define them as submethods so they won't be inherited. Nevermind.

[01:47] <fglock_> (or maybe I didn't understand the question, sorry)

[01:48] <fglock_> I found that I can redefine 'Lazy' in Prelude. I don't know if this will break 'Array' yet

[01:49] <dudley> Why do that in the Prelude?

[01:49] <dudley> I mean, why do you need to redefine 'Lazy' ?

[01:50] <fglock_> Lazy is not defined yet - it is actually a non-lazy list

[01:50] <fglock_> I've written it as a module, but I'm trying to integrate it back in Pugs

[01:51] <dudley> Ah. Right.

[01:53] <fglock_> I can't have Haskell to call Lazy.new without messing with Pugs source, but I can redefine '..' to create a lazy list.

[01:57] <dudley> Why not mess with Pugs source? It just sounds like it would be more at home in the Pugs core than the prelude.

[01:58] <dudley> But then again, I have no idea what I'm talking about ;-)

[02:02] <fglock_> Prelude is portable - it gets compiled to PIR/PIR2, so it's one less thing to port to JS, P5, etc.

[02:04] <dudley> Good enough for me

[02:06] <fglock_> native implementations would be more optimized

[02:12] <fglock_> cool - (1..Inf).shift works!!

[02:13] <fglock_> I'll try to make it in one line for the evalbot

[02:28] <fglock_> ?eval class Lazy{has Code $.cstart}multi infix:<..> (Int $a,Int|Num $b){my $i=$a;Lazy.new(cstart=>sub{my $tmp=$i;undefine $tmp if $tmp>$b;$i++;$tmp});}multi method shift (Lazy $x:) returns Any {return &{$x.cstart}();}say (1..Inf).shift;

[02:28] <evalbotzy> 1 bool::true 

[02:44] <scook0> ?eval my $Foo::3; $Foo::3 = 'hello'; say $Foo::3

[02:44] <evalbotzy> hello bool::true 

[02:48] <scook0> ?eval my $Foo::::::bar = 'goodbye'; say $Foo::::::bar

[02:48] <evalbotzy> goodbye bool::true 

[02:52] <fglock_> I can't make '@a= **(1..10)' work (flatten lazy list) - I get 'Unknown syntactic construct: Syn "**"'

[02:54] <fglock_> it was declared with 'multi prefix:<**> ( Lazy $x ) { $x.flatten }'

[02:54] <scook0> fglock_: it's parsing as a Syn, rather than as an App...

[02:55] <fglock_> what is a Syn?

[02:56] <scook0> fglock_: (difficult to explain)

[02:56] <scook0> something that can't be represented by a sub call

[02:56] <scook0> the point being that your multi doesn't even get considered

[02:57] <scook0> (weird that there's no implementation for it though)

[02:57] <fglock_> I'll try another name - I can fix it later

[02:57] <scook0> fglock_: try going into Parser.hs, line 1121

[02:58] <scook0> , preSyn "* **"

[02:58] <fglock_> I can't recompile pugs here - too little ram :(

[02:58] <scook0> oh, ok

[02:59] <fglock_> I did it once - took 2 hours

[02:59] <scook0> I wonder if there's a test for it? (probably not)

[02:59] <scook0> fglock_: make unoptimised is faster

[03:00] <scook0> I have 256MB, and unoptimised is at least tolerable (though still not fun)

[03:06] <svnbot6> r6388 | putter++ | JavaScript-FrontEnd/ARuntime.pm: the (very) humble beginnings of a JavaScript-on-p6 runtime.

[03:08] <scook0> ?eval my $::x = 3; say $::x

[03:08] <evalbotzy> Error:  unexpected ":" expecting word character or "::" Empty variable name 

[03:12] <dudley> what is Syn short for?

[03:13] <scook0> "Syntactic Construct"

[03:13] <dudley> thanks

[03:21] *** autark is now known as jp-autark

[03:21] <arcady> wow, soon we'll be able to run javascript on perl6 on javascript

[03:22] <fglock_> redefining Lazy breaks Array, because @a=1..10 is the same as @a = $lazy, which creates an array with one element

[03:23] <scook0> arcady: let me know when Perl 6 runs on an infinite stack of turtles :)

[03:30] <fglock_> good night - time zone overflow :)

[04:00] <scook0> ?eval $?PUGS_VERSION

[04:00] <evalbotzy> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6378)' 

[04:00] <svnbot6> r6389 | scook0++ | More Parser refactoring:

[04:00] <svnbot6> r6389 | scook0++ | * Introduced ruleDelimitedIdentifier to factor out common code

[04:00] <svnbot6> r6389 | scook0++ | Also removed prefix-** from the list of Syn parsers, since it

[04:00] <svnbot6> r6389 | scook0++ | was giving fglock trouble, and doesn't seem to be implemented

[04:00] <svnbot6> r6389 | scook0++ | anyway

[04:16] <gantrixx> If one object in one file inherits from another object in another file, do I have to do a "use ParentClass" ?

[04:18] <scook0> gantrixx: I think so

[04:18] <scook0> (otherwise how else would it find it?)

[04:18] <gantrixx> yes, it does

[04:23] <gantrixx> ok, I think I know the problem.  In order to use attributes from the parent class I have to use the $self.parentattrib correct?

[04:23] <svnbot6> r6390 | scook0++ | * Updated Parser docs to reflect refactoring

[04:23] <svnbot6> r6390 | scook0++ | * Removed some dead code (killed by refactoring)

[04:23] <gantrixx> or is that out of date now?

[04:23] <gantrixx> because it says *** Undeclared variable: "$self"

[04:23] <scook0> well, $self isn't a special variable name

[04:24] <scook0> try $?SELF

[04:24] <gantrixx> what really is $?SELF?

[04:24] <scook0> (or explicitly naming your invocant)

[04:24] <scook0> inside a method, $?SELF is the object that the method was invoked on

[04:24] <scook0> like C++/Java's 'this'

[04:25] <gantrixx> so do I also use @?SELF.attrib for an attribute that is an array?

[04:28] <scook0> no, because that would imply that SELF is an array

[04:28] <svnbot6> r6391 | putter++ | JavaScript-FrontEnd/ARuntime.pm: a few more bits.

[04:28] <scook0> you would just use $?SELF.attrib

[04:29] <gantrixx> so $?SELF is a reference?  Just like we would us $self in Perl5?

[04:29] <gantrixx> except this is built in

[04:30] <scook0> gantrixx: I think so

[04:30] <scook0> you can also use $self, provided you mention it in your method parameter list (like in P5)

[04:30] <scook0> method foo($self: $x, $y, $z)

[04:31] <gantrixx> ok, why does $SELF have a ? in it     (i.e $?SELF )

[04:31] <scook0> I don't think people are actually supposed to use $?SELF directly (though they can if they want to)

[04:31] <scook0> gantrixx: short answer: because it's special

[04:31] <gantrixx> so is $_

[04:31] <scook0> to avoid polluting the normal identifier namespace

[04:31] <gantrixx> but it isn't $?_

[04:32] <scook0> hmm

[04:33] <scook0> (maybe $_ is very special)

[04:33] <scook0> either way, having to type $?_ would kind of defeat the point of having $_

[04:34] <gantrixx> I think that is one feature of Perl5 that I've heard complaints about.  Perl5 is such that the code can become very cryptic.

[04:35] <scook0> S02 mentions $? variables

[04:36] <scook0> (but curiously, S12 never mentions $?SELF)

[04:36] <scook0> I don't think P6 will make it harder to write cryptic code

[04:36] <scook0> but it should make it easier to write non-cryptic code

[04:37] <scook0> (provided the person reading the code has actually bothered to learn the language)

[04:37] <scook0> that's probably the main reason people say P5 is "hard to read"

[04:38] <gantrixx> P5 can be hard to read, depends on the programmer

[04:39] <scook0> yeah

[04:39] <scook0> some of that is because of the language, some of it is because of the programmer

[04:39] <scook0> P6 is trying to remove the language-induced difficulty

[04:39] <gantrixx> two things that can make P5 hard to read: 1) you can use cryptic symbols like $_ and 2) there is more than one way to write the same statement

[04:40] <gantrixx> I had to maintain some code from a guy that wrote things in a very funny way.  It always had me refering to the Camel book to figure out exactly what he was doing.  It would have been soo much easier if he followed conventions.

[04:40] <scook0> reading retarded code is never fun

[04:41] <scook0> I recently had to help someone try to read some nasty C++

[04:41] <gantrixx> One collegue was saying that is one of the strengths of Python, you don't have the flexibility to be retarded

[04:42] <scook0> gantrixx: you'd be surprised at what people are capable of

[04:42] <gantrixx> I'm not a Python programmer

[04:42] <gantrixx> doesn't seem to be a big calling for it in the consulting biz, but there are a lot of open source guys using it these days

[04:42] <scook0> but it is true that Python, in general, makes it harder to write unreadable code

[04:42] <scook0> (but not impossible)

[04:43] <scook0> I mean, if you took the C++ program I was talking about

[04:43] <scook0> and transliterated it into Python

[04:43] <scook0> you'd still have no idea

[04:43] <scook0> eventually I gave up on even trying to understand the code

[04:43] <scook0> and just re-wrote it myself in P5

[04:44] <scook0> (my second-ever P5 program!)

[04:44] <gantrixx> In my experience it is more important to be "wordy" and explicit in your code (making it easier to maintain for the sucker who inherits it) than to try to be tricky and compact with everything

[04:44] <gantrixx> I've rewritten code that I couldn't understand before also

[04:45] <scook0> well I didn't so much re-write it as re-implement it from scratch

[04:45] <putter> autrijus: re compiling javascript to javascript... for completeness I'll note that while js on p5, and js on haskell, might actually be useful, the real motivation for starting the js frontend was really to get the first p6 language "pass-thru"? started.  ie, js on p6 on PIL2JS.  ;)

[04:46] <scook0> the problem with being 'wordy'

[04:47] <scook0> is that sometimes you end up with a lot of code that is easy to read line-by-line

[04:47] <scook0> but just as incomprehensible as a whole

[04:47] <gantrixx> well yes, there is such a thing as over-kill

[04:48] <scook0> that's the problem I run into with Python and Java

[04:48] <scook0> the languages prevent you from doing complex things

[04:48] <scook0> but the complexity has to go somewhere

[04:48] <scook0> so your program ends up much more difficult to follow

[04:48] <putter> Java has nifty code policy checkers and transformers.  P6 will probably need them too.

[04:50] <gantrixx> So far P6 syntax seems pretty nice.  I start a new P5 contract on 8/29.  It will be a shame to go backwords.

[04:50] <scook0> the main reason I became interested in P6 was that I was always interested in Perl as a concept

[04:50] <putter> Picture the most horrible p5 code you've seen, then add macros, unicode, junctions, etc.  It will be quite easy for the tasteless to create something _truely_  unreadable.

[04:50] <scook0> but I had heard some nasty things about it in reality

[04:51] <gantrixx> I'm interested in P6 because I'm interested in a long life for Perl.  I'd like to see Perl as much of a staple as C/C++

[04:52] <scook0> putter: but these features also make it possible to write more readable code, /if/ you're trying in that direction

[04:53] <gantrixx> long life is a big selling point for many clients

[04:53] <scook0> gantrixx: I think P6 will have a long life -- look how long it's been going for already :)

[04:56] <putter> scook0: yes.  but p6 does provide better tools for writing incomprehensible code.  so a question is, what are the concequences?  will CPAN need a stylecheck barrier?  will corporations need to see a readable cannonical form to avoid them discarding p6 as unmaintainable?  what other issues does it raise...?

[05:00] <scook0> putter: interesting points...

[05:00] <scook0> I think there was some mention of 'policy modules'

[05:01] <putter> that would be neat.

[05:01] <scook0> so you could ensure your code contains no macros, no junctions and no unicode operators

[05:01] <gantrixx> OK, here is a funny one.  If I want to set attributes in a child class that it inherited from teh parent class, how do I do that?

[05:01] <scook0> just by saying "use FooCorp::CodingStandard"

[05:01] <putter> and rules + PIL will allow some powerful games.

[05:02] <scook0> gantrixx: in a method in the child class?

[05:02] <scook0> I think you just do $?SELF.inherited_attr = val

[05:03] <scook0> (I think a lot of the fine details of OO are still up in the air, so some of this is me guessing)

[05:03] <gantrixx> No I mean  BlackJack::Card.new( name=>$name, suit=>$suit)  but $.name and $.suit come from PlayingCard::Card with BlackJack::Card inherits

[05:04] <scook0> gantrixx: are you trying to set them explicitly or implicitly?

[05:05] <putter> scook0: googling for perl6 policy.module didnt turn up much.  any other phrases that come to mind?

[05:06] <gantrixx> I'm trying to set them as you see above

[05:07] <scook0> putter: there's a mention of "policy" modules at http://www.perl.com/pub/a/2005/04/p6pdigest/20050403.html

[05:07] <scook0> but that may not be what I'm thinking of

[05:08] <scook0> (It could be that I misinterpreted the term, and invented the concept myself)

[05:08] <scook0> but either way it's useful functionality

[05:09] <dudley> scook0: I definitely remember hearing talk of it before, so it's not entirely in your head :)

[05:12] <putter> scook0: thanks. :)

[05:12] * putter is reassured that our fearless leaders are sufficiently insane to make p6 very nifty...

[05:14] * dudley doesn't think the insanity of our fearless leaders was ever in doubt...

[05:15] <putter> ;)

[05:15] <dudley> Anybody here know Scala?

[05:16] <putter> I skimmed it, but nothing more.

[05:17] <dudley> I'm wondering if there's a way to work around Scala not allowing type synonyms at top level

[05:19] <putter> arg, (non-html language specs)--  sorry, no idea.

[05:20] <putter> end of day.  good night all.  &

[05:20] <dudley> good night

[05:21] <gantrixx> Is there a way to list all the attributes of an object?

[05:24] <scook0> gantrixx: you'd need introspection for that

[05:24] <scook0> it probably will be possible

[05:24] <scook0> but I doubt it's implemented

[05:25] <gantrixx> I'm just thinking for debugging purposes it might be nice

[05:26] <gantrixx> you know to make sure it inherits what it was supposed to inherit

[05:26] <dudley> For debugging and for IDE/automated refactoring stuff, too

[05:26] <gantrixx> vi is my IDE

[05:27] <gantrixx> I'm a hammer and chissle guy

[05:27] <dudley> emacs is mine

[05:27] <scook0> I like IDEs in theory, but in practice they tend to bug me

[05:27] <dudley> I'm a thermonuclear jackhammer guy

[05:28] <dudley> scook0: Me too. Eclipse is incredibly annoying.

[05:28] <scook0> I'm content with any editor with a decent GUI and syntax highlighting

[05:28] <scook0> emacs is another thing I like in theory, but can't stand in practice

[05:29] <dudley> It has so much potential and does so many things well, but the whole package just doesn't quite do it.

[05:29] <gantrixx> gvim does syntax highlighting

[05:29] <scook0> If there was a version of emacs that followed modern GUI conventions, I'd be all over it

[05:29] <gantrixx> it would be cool if gvim would implement tabbed editing

[05:29] <dudley> emacs is pretty much the least of a near-infinity of evils

[05:29] <scook0> I'm using GEdit at the moment

[05:30] <gantrixx> if vi = hammer + chissel, notepad = chopsticks

[05:30] <dudley> I can't use emacs in a GUI. It drives me absolutely nuts.

[05:30] <scook0> gantrixx: notepad = one chopstick

[05:31] <scook0> it's 2005, people should at least be using editors that indent new lines for you

[05:31] <gantrixx> I just don't see how notepad is even useful for anything

[05:32] <scook0> well, notepad is literally just a textbox with load/save dialogs

[05:32] <scook0> can't even handle unix newlines :(

[05:33] <gantrixx> If you get an "error line 32", try using notepad to find the error, it's difficult

[05:33] <gantrixx> it doesn't wrap lines

[05:33] <gantrixx> it's a real hinderance

[05:34] <scook0> but it's the only plain-text-editor you get out-of-the-box on windows

[05:35] <dudley> isn't there an 'edit' or something in dos?

[05:35] <mugwump> edlin++

[05:36] <gantrixx> when I'm forced to use a windows box, I usually spend a day loading the win32-gnu tools, gvim, virtual desktop manager, firefox, etc

[05:36] <mugwump> I think they dropped it in about DOS 4.0 though ;)

[05:36] <gantrixx> oh, and activestate perl5

[05:36] <scook0> 'edit' still works on my XP box

[05:37] <scook0> in fact, unlike notepad it will automatically keep your indentation level when you go to a new line

[05:37] <mugwump> mmm.... "edlin" was very similar to UNIX "ed", a fine editor when your /usr is offline

[05:37] <scook0> I had to use 'ed' the other day

[05:38] <scook0> in a shell script for a uni assignment

[05:38] <scook0> but I certainly wouldn't want to try regular editing with it

[05:39] <gantrixx> it is a bit surprising that MS doesn't include some of the free stuff

[05:40] <gantrixx> what would it hurt if they offered BASH as a command line interpreter?

[05:40] <gantrixx> I really don't see how that would hurt there business strategy

[05:40] <scook0> speaking of which, I wonder what the 'Monad' shell thingy is like...

[05:41] <scook0> gantrixx: probably more of an ideological/cultural thing

[06:19] <nothingmuch> morning

[06:21] <dudley> morning

[06:21] <nothingmuch> Devel::TypeCheck is out

[06:22] <nothingmuch> or at least should be out soon

[06:22] <nothingmuch> http://search.cpan.org/~bargle/

[06:59] <xinming> Is there a method for Array which will help Join the array into string?

[06:59] <xinming> oops. just now, I asked this In #perl, And someone is sticking on my question with perl 5 grammer. :-)

[07:00] <xinming> I know as, .as('%03d', ', ') which will mean if you get the element of from a array "slot", it will be formated as `$(%03d),`   But Do I have to join them myself?

[07:00] <xinming> * DeathWo1f has quit (Remote closed the connection)

[07:00] <arcady> there is "join", isn't there?

[07:01] <xinming> arcady: yes, What I want to know is, if there a "built-in" join for Array.

[07:01] <arcady> what do you mean?

[07:02] <arcady> @a.map { .as("%03d") }.join(", ") or something like that

[07:02] <xinming> arcady: ...

[07:03] <xinming> arcady: I mean, It will hold a string "internally"... 

[07:04] <arcady> okay, I'm not getting what you mean by that

[07:05] <xinming> arcady: I can't turning the way of thinking sometimes. :-(

[07:06] <xinming> s/turning/turn/ 

[07:07] <arcady> so wait, what exactly needs to be holding a string internally?

[07:08] <scook0> what about [~] ?

[07:09] <arcady> oh yes, that works

[07:09] <arcady> is there a >>.<< ?

[07:10] <scook0> arcady: huh?

[07:10] <xinming> arcady: some time, If you don't wish to declare a scalar to hold the "slurped" array yourself.

[07:11] <xinming> This is the problem I ever encountered... hmm, But, From my poor Programming experience. This might not be necessary really... :-)

[07:14] <arcady> scook0: apply a method to each element of an array

[07:14] <scook0> arcady: there's @foo ».bar

[07:14] <scook0> (don't think its implemented yet)

[07:14] <scook0> which will call .bar on each elem of @foo

[07:15] <xinming> my @ary; @ary.as("abc: %s"); my $slurped := @ary.scalar;  And then, Every time you push a element into the array, you won't need to join yourself... and also, Every time you modify the one of the elemts in the array, The $slurped varaible will get the new result.

[07:15] <arcady> that's... way too much magic that is happening there, I think

[07:17] <scook0> I would recommend something like:

[07:17] <arcady> scook0 I think they've decided on not having >>(op) or (op)<< and just having >>(op)<<

[07:17] <arcady> otherwise it's just unparseable

[07:17] <scook0> arcady: really? when was this?

[07:18] <scook0> xinming: instead of having a scalar, you could have a sub

[07:19] <scook0> my &slurped = { @ary.scalar }

[07:19] <scook0> (or whatever)

[07:19] <scook0> then when you call slurped()

[07:19] <scook0> it has the most up-to-date value

[07:19] <arcady> ?eval (1,2,3)>>+<<2

[07:19] <evalbotzy> (3, 4, 5) 

[07:19] <arcady> ?eval (1,2,3)>>+2

[07:19] <evalbotzy> Error:  unexpected ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:19] <xinming> ?eval (1, 2, 3) >>+ 2

[07:19] <evalbotzy> Error:  unexpected ">" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:20] <arcady> it may not have been decided but it is the current state of things

[07:20] <scook0> ?eval -« [1, 2, 3]

[07:20] <xinming> ?eval (1, 2, 3) <<+ 2

[07:20] <evalbotzy> -3 

[07:20] <evalbotzy> Error:  unexpected "<" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:20] <arcady> ?eval -<< (1,2,3)

[07:20] <evalbotzy> (-1, -2, -3) 

[07:20] <scook0> ?eval (-« [1, 2, 3]).say

[07:20] <evalbotzy> -3 bool::true 

[07:20] <arcady> whoa

[07:20] <scook0> oh, oops

[07:20] <arcady> ?eval 2 +<< (1,2,3)

[07:20] <evalbotzy> Error:  unexpected "<" or "+" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[07:21] <arcady> oh

[07:21] <nothingmuch> morning

[07:21] <arcady> that makes sense

[07:21] <scook0> op« is for prefix ops

[07:21] <arcady> morning

[07:21] <arcady> yes

[07:21] <scook0> »op is for postfix

[07:21] <scook0> »op« is for infix

[07:21] <arcady> so which one is .?

[07:22] <scook0> arcady: . is postfix

[07:22] <scook0> or postcircumfix

[07:22] <scook0> (can't remember)

[07:22] <arcady> no, definitely not postcircumfix

[07:22] <arcady> that's like []

[07:22] <xinming> ?eval my $lval; sub get { return $lval }; sub set () is rw { $lval }; set = 100; my $t = get; $t.say;

[07:22] <evalbotzy> 100 bool::true 

[07:22] <xinming> ?eval my $lval; sub get { return $lval }; sub set () is rw { $lval }; set = 300; my $t = get; $t.say;

[07:22] <evalbotzy> 300 bool::true 

[07:23] <scook0> I don't think the . itself is considered an operator

[07:23] <scook0> I believe the whole .meth(args) is considered postfix

[07:23] <nothingmuch> it isn't

[07:23] <arcady> oh

[07:23] <nothingmuch> scook0: you're right

[07:24] * nothingmuch forgot the dvi-vga converter at home =(

[07:24] <nothingmuch> no second monitor today

[07:24] <scook0> nothingmuch: awww

[07:24] <nothingmuch> yeah

[07:24] <scook0> dual-monitors is great fun

[07:24] * nothingmuch is very very spoiled with his montiro

[07:24] <nothingmuch> monitors

[07:24] <xinming> so, anyone here can give ma example to compose these two functions into one?

[07:25] <nothingmuch> a 17" powerbook + 17" samsung LCD

[07:25] <xinming> and, also, without declaring a my $lval outside.

[07:25] <nothingmuch> the samsung is not the best monitor in the world, but it's pretty good

[07:25] <scook0> xinming: you mean 'as' and 'join'?

[07:25] <nothingmuch> xinming: 'state $lval;'

[07:25] <xinming> scook0: No...

[07:25] <nothingmuch> but that'll only work for one sub

[07:25] <xinming> ?eval my $lval; sub get { return $lval }; sub set () is rw { $lval }; set = 300; my $t = get; $t.say;

[07:25] <evalbotzy> 300 bool::true 

[07:25] <scook0> oh, sorry, I didn't see your evalbot stuff

[07:26] <nothingmuch> ?eval sub value is rw { state $lvalue; $lvalue }; value = 100; my $v = value; $v.say;

[07:26] <evalbotzy> Error: Can't use readline() or getc() in safemode. 

[07:26] <nothingmuch> ?eval sub value is rw { state $lvalue; $lvalue }; value = 100; my $v = value; $v

[07:26] <evalbotzy> Error: Can't use readline() or getc() in safemode. 

[07:26] <nothingmuch> huh?

[07:26] <nothingmuch> ?eval my $lvalue; sub value is rw {$lvalue }; value = 100; my $v = value; $v

[07:26] <evalbotzy> Error: Can't use readline() or getc() in safemode. 

[07:26] <nothingmuch> wtf am I doing wrong?

[07:26] <xinming> what does the keyword state do? It seems it doesn't appear in synopsis.

[07:26] <nothingmuch> xinming: state is like static in C

[07:27] <scook0> it keeps its value between sub calls

[07:27] <nothingmuch> where in perl 5 you said 'my $var; sub routine { $var ||= $initial_value; ... }' you can now say 'sub routine { state $var = $initial_value }

[07:27] <xinming> nothingmuch: If so, The space of the var for state will never be freed, right?

[07:29] <nothingmuch> hmm

[07:29] <nothingmuch> maybe in a closure, once the closure is freed so is the value

[07:29] <xinming> In this case, I think the sub should be declared with my or our...

[07:30] <xinming> or my

[07:30] <nothingmuch> yeah, if you say 'my sub routine { state $x = some_func() }' then $x should be reset at scope exit, i would guess

[07:32] <xinming> nothingmuch: But this hasn't been supported in pugs. :-)

[07:32] <nothingmuch> i don't think pugs has reached this level of detail yet

[07:34] <xinming> nothingmuch: What's null key really in perl 6?

[07:34] <nothingmuch> null key?

[07:34] <xinming> nothingmuch: ( => 'value' )

[07:35] <nothingmuch> that's a syntax error, i think

[07:35] <xinming> And how to I access it? or in perl 6, I won't be parsed.

[07:35] <nothingmuch> you can say undef => 'value'

[07:35] <nothingmuch> then it's a pair with the left side being undef

[07:35] <nothingmuch> if your hash's shape is told to store more than just strings, than you can say my %hash = (undef => 'value');

[07:35] <nothingmuch> and then just %hash{undef};

[07:35] <xinming> ?eval ( undef => 'value' );

[07:35] <evalbotzy> ('undef' => 'value') 

[07:36] <nothingmuch> oh wait, that autoquotes

[07:36] <xinming> ?eval ( => 'value' );

[07:36] <evalbotzy> Error:  unexpected ">" expecting term 

[07:36] <xinming> ?eval { undef => 'value' );

[07:36] <evalbotzy> Error:  unexpected ")" expecting operator, term postfix, postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[07:36] <xinming> ?eval { undef => 'value' };

[07:36] <evalbotzy> {('undef' => 'value')} 

[07:36] <nothingmuch> ?eval Pair.new(undef, 'value')

[07:36] <evalbotzy> Error: Must only use named arguments to new() constructor 

[07:36] <nothingmuch> damnit, now to find Pair.new

[07:36] <scook0> ?eval (undef) => 'value'

[07:36] <evalbotzy> (undef => 'value') 

[07:36] <scook0> woo!

[07:37] <nothingmuch> scook0++

[07:37] <scook0> you just have to circumvent the parser's cleverness

[07:38] <scook0> in fact, you'd have to do that for any bareword-function-call

[07:38] <xinming> ?eval my %h = { (undef) => 'value' }; my $b := %h{undef}; $b = "test"; %h.kv;

[07:38] <evalbotzy> ('', 'test') 

[07:38] <scook0> ?eval sub bob {3}; bob => 'value'

[07:38] <evalbotzy> ('bob' => 'value') 

[07:39] <xinming> Is an empty string undef?

[07:39] <scook0> ?eval sub bob {3}; (bob) => 'value'

[07:39] <evalbotzy> (3 => 'value') 

[07:39] <scook0> ?eval ~(undef)

[07:39] <evalbotzy> '' 

[07:39] <xinming> or, is (undef) an empty string

[07:39] <scook0> when you stringify (undef), it turns into ''.

[07:40] <scook0> ?eval defined('')

[07:40] <evalbotzy> bool::true 

[07:40] <scook0> ?eval defined(undef)

[07:40] <evalbotzy> bool::false 

[07:40] <xinming> scook0: How to I preserve the undef ?

[07:40] <xinming> scook0: the example I used above

[07:41] <scook0> xinming: you would need a hash that can accept keys that are not strings

[07:41] <scook0> at the moment, it automatically turns all key values into strings (I think)

[07:41] <scook0> no easy way to preserve the undef at the moment

[07:42] <xinming> scook0: So, the hash in perl, will hash key not accept the non-string object by default?

[07:42] <scook0> xinming: I think that is the default

[07:42] <scook0> you will be able to specify hashes that can have other values

[07:42] <scook0> but it's not implemented

[07:43] <xinming> scook0: hmm, I know, we can use my %hash is MyHash syntax.

[07:43] <scook0> xinming: you can also use my %hash is shape(Any) -- see S09

[07:44] <scook0> now that I think about it, I'm not sure whether or not hashes should accept undef...

[07:45] <scook0> but that would be getting into not-specced-yet territory anyway (re: typed undefs)

[07:54] <xinming> ?eval "my $a; $a = 5; $a.say".eval;

[07:54] <evalbotzy> Error: Undeclared variable: "$a" 

[07:54] <xinming> will this be valid in perl 6?

[07:55] <nothingmuch> xinming: use ''

[07:55] <nothingmuch> ?eval 'my $a; $a = 5; $a.say'.eval

[07:55] <evalbotzy> 5 bool::true 

[07:55] <xinming> ...

[07:55] <xinming> forgot the qq and the q. ;-)

[07:56] <nothingmuch> what you wrote is like ("my " ~ $a ~ "; " ~ $a ~ " = 5; " ~ $a.say).eval

[07:56] <xinming> nothingmuch: yes, I know, I just forgot to use '' instead of ""

[07:57] * nothingmuch wants lunch to arrive

[08:01] * xinming wants money to fall from the sky.

[08:02] <webmind> that'll be bad for inflation

[08:02] <webmind> :)

[08:04] * xinming knows the it's bad for inflation, so xinming might want beauty instead...

[08:05] <xinming> s/the//

[08:13] <xinming> hmm, May I ask a non-perl6-related question here?

[08:15] <autrijus> you just asked one

[08:15] <autrijus> and the answer is yes

[08:16] <xinming> http://blogs.msdn.com/danlehen/archive/2004/06/01/146259.aspx

[08:16] <xinming> and search for the string

[08:16] <xinming>  That is truly one of the most amazing things

[08:16] <xinming> in the comment.

[08:17] <xinming> search "That is truly one of the most", I wonder if there are really funny comments written in English there. :-)

[08:17] <autrijus> it's mildly funny yes :)

[08:18] <xinming> autrijus: You can understand Chinese. and There are many such comments written in Chinese. So, I wonder If there is such comment which written in English. Except this one.

[08:20] <xinming> 大师的话真如“大音希声扫阴翳”，犹如”拨开云雾见青天”，使我等网民看到了希望，看到了未来！晴天霹雳，醍醐灌顶或许不足以形容大师文章的万一；巫山行云，长江流水更难以比拟大师的文才！黄钟大吕，振聋发聩！你烛照天下，明见万里；雨露苍生，泽被万方！透过你深邃的文字，我仿佛看到了你鹰视狼顾，龙行虎步的伟岸英姿；仿佛

[08:20] <xinming> 看到了你手执如椽大笔，写天下文章的智慧神态；仿佛看见了你按剑四顾，江山无数的英武气概！

[08:22] <autrijus> xinming: yow.

[08:22] * autrijus rushes to /clear

[08:22] <xinming> That's just copy and past...

[08:22] <xinming> ...

[08:23] <autrijus> xinming: I've read enough text that praises Chiang Kai Shek and Mao... please spare me further things like this :)

[08:24] <xinming> autrijus: hmm, I think I would prefer seeing the finish of pugs rather than read these articles. :-)

[08:25] <autrijus> riiight.

[08:25] * autrijus goes back to hack

[08:48] * Supaplex feeds xinming /dev/urandom until his $TERM goes *poof*

[08:49] <xinming> Supaplex: Hmmm. Sorry...

[08:49] <Supaplex> heh, tiz ok.

[08:50] <Supaplex> I use to enjoy meannacing peeps IRC sessions with chunks of /dev/urandom or beeps (^G aka ) hehe.

[08:50] <revdiablo> heh, actually xinming's paste showed up fine in my client+terminal. looks kinda neat.

[08:51] <revdiablo> I even have a font with all the glyphs

[08:51] <xinming> Supaplex: Do you wish to hear the sound of the kernel? :-)

[08:51] <xinming> Supaplex: cat /proc/kcore > /dev/dsp

[08:51] <Supaplex> haha

[08:52] <xinming> ?eval class C { has $.a = 1; };

[08:52] <evalbotzy> Error:  unexpected "=" expecting trait, "handles", ";" or "}" 

[08:52] <Supaplex> I'm enjoying knobtweakers.net tracks too much to listen to the kernel atm.

[08:53] <xinming> Can pugs use the all the perl 5 libs for now?

[08:53] <xinming> maybe most... Infact.

[08:56] <autrijus> xinming: only if you link against perl5 when building pugs, and there are known problems with certain XS modules like DBD::Pg.

[08:58] <Supaplex> what a shame

[09:00] <autrijus> indeed; which is why we are working toward compiling to perl5 code.

[09:00] <autrijus> then you can work with any perl5 code.

[09:06] <xinming> running perl 5 code is "a bit" too slow...

[09:06] <autrijus> xinming: for what purposes?

[09:07] <xinming> autrijus: hmm, I just now try to use "use CGI", And It seems it will slowly finsihed... :-)

[09:08] <xinming> autrijus: well, I know it's not perl 6 really, I just do some practising. :-)

[09:08] <autrijus> xinming: oh... but it's perl6's CGI

[09:08] <autrijus> if you want to use perl5 CGI, you need to say

[09:08] <autrijus> use perl5:CGI;

[09:09] <xinming> In fact, use CGI works also. at least, run at the same speed.

[09:09] <xinming> autrijus: by the way, Is there any difference between fun_call.say and fun_call().say ?

[09:10] <xinming> ?eval f { 'test' }; f().say;

[09:10] <autrijus> xinming: if &fun_call is in scope

[09:10] <evalbotzy> Error: No compatible subroutine found: "&f" 

[09:10] <autrijus> then no, no difference.

[09:10] <xinming> ?eval sub f { 'test' }; f.say;

[09:10] <evalbotzy>  'test' 

[09:10] <xinming> ?eval sub f { 'test' }; f().say;

[09:10] <evalbotzy> test bool::true 

[09:11] <xinming> autrijus: But in fact, here we got the different result.

[09:11] <autrijus> wow... a bug.

[09:11] <autrijus> write tests :)

[09:11] <autrijus> f.say is somehow parsed as f(say()).

[09:13] <xinming> autrijus: :-) Well, I will record all the bugs I now encountered. And will write the test after I "finished" learning perl 6.

[09:18] <scook0> (wow, the parser is just chock full of redundancy...)

[09:19] <xinming> In perl 5, If you say "use Data::Dumper", But In perl 6, it doesn't works, so what the differences between "use Data::Dumper" and "use Data:Dumper" are?

[09:19] <xinming> scook0: well, that's better than nothing. :-)

[09:19] <xinming> scook0: for me, At least I can learn how to use perl 6 programming in "real" world.

[09:20] <scook0> xinming: ooh, that's a good one :)

[09:20] <scook0> and I'm working on getting rid of some of it

[09:21] <xinming> hmm, Ok, Just go ahead, I will try to figure out the difference between Data::Dumper and Data:Dumper myself. :-)

[09:23] <masak> how come practically all of my tests fail?

[09:28] <xinming> ?eval my $var =3; $var *= (5, 9); $var.say;

[09:28] <evalbotzy> 6 bool::true 

[09:28] <xinming> hmm, Why It is 6 please?

[09:29] <revdiablo> ?eval +(5,9)

[09:29] <evalbotzy> 2 

[09:30] <integral> is it the , or the () that is the list constructor?

[09:30] <scook0> integral: , is the list constructor

[09:30] <integral> ok

[09:30] <scook0> but because of precedence, most of the time you need () also

[09:30] <scook0> hence the confusion

[09:30] <xinming> ?eval my $var =5; $var *= (5, 9); $var.say;

[09:30] <evalbotzy> 10 bool::true 

[09:30] <integral> I thought the precedence had been "fixed" in perl6?

[09:30] <integral> ie , is now above = ?

[09:31] <scook0> integral: some people want that

[09:31] <scook0> but last I heard it was still the same

[09:31] <integral> oh, ok.  I thought it was a done deal ages ago

[09:31] <scook0> it really should be changed though

[09:32] <scook0> iirc, the only reason to stay the same was so you can do parallel processing in C-style loops

[09:32] <scook0> (which is a pretty bogus reason, if you ask me)

[09:32] <integral> which are now decidedly not C-style now ;)

[09:34] <xinming> ?eval my $var; say $var;

[09:34] <evalbotzy>  bool::true 

[09:35] <integral> xinming: what did you mean when you said "use Data::Dumper" didn't work in perl6?

[09:40] <xinming> integral: Sorry, I was wrong. :-)

[09:40] <integral> oh

[09:40] <xinming> integral: But Is there any difference between using : and ::?

[09:41] <integral> :: separates namespaces, but : separates attributes

[09:55] <xinming> hmm, who update the CGI.pm in blib6/lib/ by the way?

[09:55] <xinming> Just try 'use CGI;'

[10:13] <svnbot6> r6392 | scook0++ | * Merge some more parser redundancy

[10:13] <svnbot6> r6392 | scook0++ | * Oops, ruleDelimitedIdentifier shouldn't use lexeme identifiers

[10:13] <svnbot6> r6392 | scook0++ | * ruleDelimitedIdentifier now matches leading delimiters

[10:39] *** autark is now known as jp-autark

[10:41] <xinming> ?eval NaN

[10:41] <evalbotzy> NaN 

[10:41] <xinming> ?eval +NaN

[10:41] <evalbotzy> NaN 

[10:41] <xinming> ?eval "test'~NaN

[10:41] <evalbotzy> Error:  unexpected "t" expecting block, "\\", "$!", "$/", "$" or "\"" 

[10:41] <xinming> ?eval ~NaN

[10:42] <evalbotzy> 'NaN' 

[10:42] <xinming> ?eval 'test' ~NaN

[10:42] <evalbotzy> 'testNaN' 

[10:47] <coral> ?eval int(NaN)

[10:47] <evalbotzy> -269653970229347386159395778618353710042696546841345985910145121736599013708251444699062715983611304031680170819807090036488184653221624933739271145959211186566651840137298227914453329401869141179179624428127508653257226023513694322210869665811240855745025766026879447359920868907719574457253034494436336205824 

[10:47] <coral> it's negative now?

[10:47] <coral> oh, that was Inf. n/m

[10:53] <arcady> ?eval int(Inf)

[10:53] <evalbotzy> 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 

[11:01] <xinming> I think, Perl will be a language which will stop people from going deeper... :-S

[11:03] <xinming> anyone here would explain this for me? `'test' ~NaN`    `"test'~NaN`

[11:08] <scook0> ?eval "test" ~ NaN

[11:08] <evalbotzy> 'testNaN' 

[11:09] <scook0> ?eval 1/0

[11:09] <evalbotzy> Error: Illegal division by zero 

[11:10] <xinming> in fact, ~ should be a infix:<~> But, with default "infix" operator, there should be no space before or after the operator.

[11:10] <xinming> user defined infix:<~> must have space...

[11:13] <xinming> don't know if I am right.

[11:13] <scook0> ?eval "test"~NaN

[11:13] <evalbotzy> 'testNaN' 

[11:14] <scook0> (in your example, you mismatched " and ')

[11:16] <xinming> ...

[11:16] <xinming> @_@

[11:16] <xinming> carelessness is a bad thing really. :-)

[11:18] <xinming> ?eval my $a = 1 but false; $a.bit;

[11:18] <evalbotzy> Error: No compatible subroutine found: "&false" 

[11:19] <xinming> ?eval my $a = 1 but not true; $a.bit;

[11:19] <evalbotzy> Error:  unexpected "t" expecting block construct, ":", term, term postfix, operator, "does", "but", "is", "^..^", "cmp", "<=>", "^..", "..^", "..", ";" or end of input 

[11:19] <scook0> actually, if there's confusion between infix and postfix operators, the infix must have a space, and the postfix must not

[11:19] <scook0> (but I don't think any built-in operators will be ambiguous that way)

[11:20] <xinming> ?eval my $a = 0 but true; $a.bit;

[11:20] <evalbotzy> Error:  unexpected ";" expecting term 

[11:20] <xinming> ?eval my $a = 0 but true ; $a.bit;

[11:20] <evalbotzy> Error:  unexpected ";" expecting term 

[11:22] <xinming> scook0: 1+5 here, IMHO this should be clear with "user defined" operator. just like, 1 + 5 will use the user defined operator.

[11:22] <xinming> and 1+5 will call the "perl 6" operator

[11:22] <scook0> no, I don't think so

[11:23] <scook0> what I was talking about is if you have:

[11:23] <scook0> infix:<++> and postfix:<++>

[11:23] <scook0> then you might have to write

[11:23] <scook0> $a++

[11:23] <scook0> or

[11:24] <scook0> $b ++ $c

[11:24] <scook0> but not '$a ++' or '$b++$c'

[11:24] <scook0> (I think that's right...)

[11:24] <xinming> hmm, then, How to call the "default" postfix:<++>

[11:25] <scook0> xinming: not sure what you mean by "default"

[11:26] <scook0> are you talking about user-defined vs. built-in operators?

[11:26] <xinming> scook0: yes, built-in operator.

[11:26] <scook0> hmm

[11:27] <scook0> normally I don't think you would replace the built-in ones

[11:28] <scook0> you would just add new versions for your own classes/types

[11:28] <scook0> (though you probably could change the built-in ones if you REALLY wanted to)

[11:29] <xinming> scook0: hmm, by the way, Do you mean the operator can be... infix:<MINE_+> ?

[11:29] <xinming> or infix:<mine->

[11:30] <scook0> xinming: you want to be able to write `3 MINE_+ 4`?

[11:31] <scook0> or are you talking about `MyClass.new + MyClass.new`

[11:31] <xinming> scook0: the first example.

[11:31] <xinming> if It's able to apend some letters to define a operator.

[11:33] <scook0> you can define new operators using whatever symbols you want

[11:33] <scook0> even unicode

[11:33] <xinming> ?eval true;

[11:33] <evalbotzy> Error:  unexpected ";" expecting term 

[11:33] <xinming> scook0: thanks.

[11:33] <xinming> ?eval true();

[11:33] <evalbotzy> Error: No compatible subroutine found: "&true" 

[11:33] <xinming> ?eval true(1);

[11:33] <evalbotzy> bool::true 

[11:34] <scook0> ?eval sub infix<◎>($a, $b) { $a + $b + 1 }; 1 ◎ 1

[11:34] <evalbotzy> Error:  unexpected "<" expecting word character, "::", bare trait, subroutine parameters, trait or block 

[11:34] <scook0> ?eval sub infix:<◎>($a, $b) { $a + $b + 1 }; 1 ◎ 1

[11:34] <evalbotzy> 3 

[11:35] <xinming> :-)

[11:35] <xinming> ?eval sub infix:<puls>($a, $b) { $a + $b + 1 }; 1 puls 1

[11:35] <evalbotzy> 3 

[11:36] <xinming> ?eval sub infix:<puls>($a, $b) { $a + $b + 1 }; 1 puls 5

[11:36] <evalbotzy> 7 

[11:36] <xinming> amazing. :-)

[11:44] <xinming> ?eval sub func;

[11:44] <evalbotzy> Error:  unexpected ";" expecting word character, "::", bare trait, subroutine parameters, trait or block 

[11:44] <xinming> ?eval sub func{ };

[11:44] <evalbotzy> undef 

[11:44] <xinming> ?eval sub func{ ... };

[11:44] <evalbotzy> undef 

[11:54] <xinming> ?eval sub duplicate($n, *%flag, *@data) {...}

[11:54] <evalbotzy> undef 

[11:54] <xinming> evalbotzy: sub duplicate($n, *%flag, *@data) {...}

[11:55] <xinming> evalbotzy: ?eval sub duplicate($n, *%flag, *@data) {...}

[11:57] <xinming> ?eval -> $a { ... };

[11:57] <evalbotzy> sub {...} 

[12:04] <xinming> If I want to use role and grammar things, Do I have to use PUGS_EMBED="perl5 parrot"

[12:05] <mugwump> you don't need either; parrot can be in your PATH

[12:05] <mugwump> it starts a parrot subprocess and talks to it via pipes...

[12:05] <xinming> mugwump: hmm, I mean, Do I have to compile parrot?

[12:06] <mugwump> If you want to use Perl 6 rules, and not just PCRE, yes.

[12:06] <xinming> mugwump: thanks

[12:07] <xinming> ?eval sub fun will do { 'will'.say } { 'main'.say }; fun();

[12:07] <evalbotzy> Error:  unexpected "w" expecting bare trait, subroutine parameters, trait or block 

[12:10] <xinming> ?eval sub function { caller; }; function();

[12:10] <evalbotzy> Control::Caller.new(('file' => '<eval>'), ('line' => 1), ('package' => 'main'), ('sub' => undef), ('subname' => undef), ('subtype' => undef)); 

[12:11] <xinming> ?eval sub function { caller Sub; }; function();

[12:11] <evalbotzy> undef 

[12:12] <iblech> nothingmuch: You have mail :)

[12:12] <xinming> hmm...

[12:12] <nothingmuch> iblech: checking

[12:12] <iblech> ?eval sub sub1 { caller Sub }; sub sub2 { sub1() }; sub2()

[12:12] <evalbotzy> Control::Caller.new(('file' => '<eval>'), ('line' => 1), ('package' => 'main'), ('sub' => sub {...}), ('subname' => '&main::sub2'), ('subtype' => 'SubRoutine')); 

[12:12] <xinming> why it doesn't return function?

[12:12] <iblech> Because it returns the *calling* functions

[12:12] <iblech> s/s$//

[12:12] <iblech> But there is no calling function, only the calling toplevel

[12:13] <xinming> oh,ok

[12:22] <xinming> ?eval my @x=[1,2,3;4,5,6;7,8,9]; @x[0..10; 1,0; 1...:by(2)]

[12:22] <evalbotzy> Error:  unexpected "[" expecting expression 

[12:22] <xinming> ?eval my @x=[1,2,3;4,5,6;7,8,9]; @x[:by(2)]

[12:22] <evalbotzy> Error:  unexpected "[" expecting expression 

[12:23] <xinming> hmm, what does :by(2) mean ?

[12:23] <QtPlatypus> ?eval 1..10:by(2)

[12:23] <evalbotzy> Error:  unexpected ":" expecting digit, "_", fraction, exponent, term postfix, operator, "does", "but", "is", "^..^", "cmp", "<=>", "^..", "..^", "..", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[12:23] <QtPlatypus> Its supposed to mean that the range goes up by steps of 2

[12:24] <xinming> QtPlatypus: So, ( 1..10 ) will become ( 1..20 )?

[12:25] <scook0> xinming: no, I think it's (1, 3, 5, 7, 9)

[12:25] <mugwump> ?eval &infix:<..>(1, 10, :by(2))

[12:25] <evalbotzy> Error: No compatible subroutine found: "&infix:.." 

[12:25] <mugwump> ?eval &Num.infix:<..>(1, 10, :by(2))

[12:25] <evalbotzy> Error: Undeclared variable: "&Num" 

[12:26] <mugwump> ?eval &Num::infix:<..>(1, 10, :by(2))

[12:26] <evalbotzy> Error:  unexpected ":" expecting "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[12:26] <xinming> is it equal @ary >>+<< 2 ?

[12:26] <mugwump> alright, I give up on that approach :)

[12:27] <scook0> xinming: no, it means "count up in steps of 2"

[12:27] <scook0> (not that it's implemented)

[12:28] <mugwump> ?eval (1..10).grep:{ $_ ^& 1 }

[12:28] <evalbotzy> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[12:30] <xinming> Oh, Ok, so, (1, 2, 3, 4, 5, 6, 7):by(2) will get a new @ary = (1, 3, 5, 7)

[12:30] <scook0> hmm

[12:30] <mugwump> ?eval (1..7.5)

[12:30] <evalbotzy> (1, 2, 3, 4, 5, 6, 7, 8) 

[12:31] <scook0> I don't now how clearly :by() has been specced at this point

[12:31] <mugwump> ?eval (1,3..10)

[12:31] <evalbotzy> (1, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:31] <mugwump> ?eval ( (1,3)..10)

[12:31] <evalbotzy> (2, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:31] <xinming> ?eval (1,3..10):by(2)

[12:31] <evalbotzy> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[12:31] <scook0> it might even have been ditched...can't remember

[12:32] <xinming> ?eval ( (1,5)..10)

[12:32] <evalbotzy> (2, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:33] <iblech> (1,5) is numified first, and, as it contains two elems, it numifies to 2

[12:33] <iblech> Compare this to:

[12:33] <iblech> ?eval (1|5)..10

[12:33] <evalbotzy> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:33] <iblech> ?eval ((1|5)..10).perl

[12:33] <evalbotzy> '((1, 2, 3, 4, 5, 6, 7, 8, 9, 10) | (5, 6, 7, 8, 9, 10))' 

[12:34] <xinming> iblech: I know what junctions do. :-)

[12:34] <xinming> ?eval ( all(1, 5).. 10 )

[12:34] <evalbotzy> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:34] <iblech> xinming: Cool :)

[12:34] <xinming> ?eval ( any(1, 5)..10 )

[12:34] <evalbotzy> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 

[12:34] <iblech> You need the (...).perl in evalbot

[12:34] <xinming> ?eval ( any(1, 5)..10 ).perl

[12:34] <evalbotzy> '((1, 2, 3, 4, 5, 6, 7, 8, 9, 10) | (5, 6, 7, 8, 9, 10))' 

[12:34] <xinming> ?eval ( all(1, 5)..10 ).perl

[12:35] <evalbotzy> '((1, 2, 3, 4, 5, 6, 7, 8, 9, 10) & (5, 6, 7, 8, 9, 10))' 

[12:35] <mugwump> ?eval sub foo { }; &foo.perl

[12:35] <evalbotzy> '\\sub {...}' 

[12:35] <mugwump> ?eval sub foo { }; &infix:<..>.perl

[12:35] <evalbotzy> '\\sub {...}' 

[12:35] <mugwump> ?eval sub foo { }; &infix:<..x>.perl

[12:35] <evalbotzy> Error: Undeclared variable: "&infix:..x" 

[12:35] <mugwump> ?eval sub foo { }; &infix:<..>(1,5)

[12:35] <evalbotzy> (1, 2, 3, 4, 5) 

[12:35] <mugwump> ?eval sub foo { }; &infix:<..>(1,5,:by(2))

[12:35] <xinming> by the way, Is there any difference between sub f { } and sub f { ... }

[12:35] <evalbotzy> Error: No compatible subroutine found: "&infix:.." 

[12:36] <xinming> hmm, maybe the yada operator.

[12:36] <scook0> xinming: sub f {} is just a normal sub that will do nothing

[12:36] <scook0> whereas sub f {...} will fail when you try to call it

[12:37] <xinming> scook0: It's kind of "viusal" thing to user. :-)

[12:37] <scook0> ?eval sub f {}; f

[12:37] <evalbotzy> undef 

[12:37] <scook0> ?eval sub f {...}; f

[12:37] <evalbotzy> *** ... - not yet implemented     at <eval> line 1, column 8-11 

[12:38] <iblech> [PIL2JS] coro works now :)

[12:38] <scook0> iblech++

[12:39] <xinming> ?eval sub f { }; sub f { };

[12:39] <evalbotzy> undef 

[12:39] <xinming> ?eval my $a; my $a;

[12:39] <evalbotzy> undef 

[12:39] <scook0> xinming: that shouldn't be allowed

[12:39] <xinming> these 2 examples should all generate a error.

[12:39] <xinming> scook0: I know. ;-)

[12:40] <scook0> that's how you know pugs is incomplete

[12:40] <scook0> it doesn't have all of Perl 6's errors :)

[12:40] <xinming> scook0: hmm, well, In fact, from these, We might write a more strict test to test perl 6 parser.

[12:40] <nothingmuch> iblech++; # good ideas

[12:40] <nothingmuch> sorry it took me so long

[12:41] <iblech> scook0, nothingmuch: Thanks :)

[12:41] <iblech> nothingmuch: Sure, np

[12:41] <scook0> iblech: wrt. `use jsan:`

[12:41] <scook0> do you think it makes more sense to say:

[12:41] <scook0> `use jsan:Foo::Bar`

[12:41] <scook0> or

[12:41] <scook0> `use jsan:Foo.Bar`

[12:42] <iblech> Foo.Bar

[12:42] <iblech> Because that's the official name of the modules

[12:42] <scook0> I guess

[12:42] <scook0> It just makes things more difficult :)

[12:43] <scook0> (only a little though)

[12:43] <iblech> ah, yes

[12:44] <scook0> though it also makes sense to have the module-name-format dictated by the `lang:` prefix

[12:44] <scook0> I'll leave it as it is for now

[12:46] <scook0> it's hard to tell which parts of the pugs/perl5/jsan paths to merge together

[12:46] <scook0> and which to keep separate

[12:46] <iblech> right...

[12:48] <scook0> (ooh, just realised that my code does some odd things)

[12:55] <nothingmuch> i disagree

[12:55] <nothingmuch> after you 'use jsan:Foo.Bar'

[12:55] <nothingmuch> what do you get?

[12:55] <nothingmuch> Foo.Bar.new?

[12:56] <nothingmuch> or Foo::Bar.new?

[12:56] <scook0> nothingmuch: that was the other reason I thought of

[12:56] <iblech> Hm

[12:56] <nothingmuch> we can't support 'Foo.Bar.new' because some day a language which hassyntax errors for namespace separators will come along

[12:56] <nothingmuch> IMHO we need to map the foreign namespace into the local one

[12:56] <iblech> Currently, exported namespaces aren't autoboxed, so neither will work

[12:56] <nothingmuch> prefixed by the domain

[12:57] <nothingmuch> unless unambigouous

[12:57] <nothingmuch> so Foo::Bar is OK

[12:57] <nothingmuch> and jsan:Foo::Bar is also ok, if there is more than one Foo::Bar involved in the process

[12:57] <scook0> btw, can you say `use ::Foo`?

[12:57] <scook0> (I imagine you can)

[12:57] <nothingmuch> scook0: for a relative name?

[12:57] <iblech> And therefore, currently, you've to write $*JS.Foo.Bar.new

[12:58] <iblech> scook0: That should work, I think, and mean the same as you'd have dropped the ::s

[12:58] <scook0> nothingmuch: I'm not really fussed why

[12:58] <scook0> my only issue is `use pugs:::Foo`

[12:59] <scook0> maybe we say that you get leading :: only if you /don't/ use a namespace prefix

[13:00] <scook0> in any case, `use jsan:.Foo` is clearly bogus

[13:00] <scook0> which is what I'm about to fix

[13:05] <svnbot6> r6393 | scook0++ | * Disallow leading delimiters in ruleDelimitedIdentifier

[13:06] <scook0> eek, it's late -- bye folks

[13:10] <svnbot6> r6394 | iblech++ | PIL2JS: Coroutines work :)

[13:10] <svnbot6> r6394 | iblech++ | Unfortunately, Pugs and I have different opinions on how coroutines should

[13:10] <svnbot6> r6394 | iblech++ | work ;) I think a return() should reset the entrypoint, i.e.

[13:10] <svnbot6> r6394 | iblech++ |     my $foo = coro { yield 42; return 23; die };

[13:10] <svnbot6> r6394 | iblech++ |     say $foo(), $foo(), $foo(), $foo();  # 42 23 42 23

[13:10] <svnbot6> r6394 | iblech++ | Pugs' return does not reset the entrypoint. And another related problem:

[13:10] <svnbot6> r6394 | iblech++ |     my $foo = coro { yield 42 };         # is really (in PIL2JS)

[13:10] <svnbot6> r6394 | iblech++ |     my $foo = coro { return(yield 42) };

[13:10] <svnbot6> r6394 | iblech++ |     say $foo(), $foo(), $foo(), $foo();  # 42 undef 42 undef

[13:20] <autrijus> iblech: your semantics is correct. however, fall-off yield should not be put into return()

[13:20] <autrijus> just as

[13:20] <autrijus> sub { return 3 }

[13:20] <autrijus> is not

[13:20] <autrijus> sub { return (return 3) }

[13:21] <iblech> Ah, ok

[13:21] <autrijus> but I do agree explicit return should reset entry. does Coro.pm do that same?

[13:22] <iblech> dunno

[13:23] <iblech> I look through the old p6l posts WRT coroutines currently

[13:23] <autrijus> let me test

[13:24] <autrijus> in p5's Coro it prints 

[13:24] <autrijus> 42 42 42 42

[13:24] <iblech> So it does not reset the entrypoint

[13:24] <autrijus> because return() is considered rewind there

[13:25] <autrijus> pugs currently is 

[13:25] <autrijus> 42 23 23 23

[13:25] <autrijus> I don't know... maybe p6l?

[13:26] <autrijus> I havn't really been used yield() so I can't quite speak there

[13:26] <autrijus> maybe ask some python or ruby folks :)

[13:27] * iblech starts irb

[13:27] <pdcawley> Ruby yield isn't relaly the same as a coro yield. It doesn't return anything, it passes an argument to the implicit block and gets the return value.

[13:27] <autrijus> yes, I understand that much.

[13:28] <autrijus> pdcawley: btw, do you hear the pil2js passes all continuation.t tests?

[13:28] <pdcawley> I did now. Whee!

[13:28] <iblech> pdcawley: Right, just noticed...

[13:28] <autrijus> t/unspecced/cont.t that is

[13:29] <autrijus> which means it can probably work with sudo ku soon

[13:29] <pdcawley> Whee! I shall have a play.

[13:30] <autrijus> iblech said.uniq is not yet implemented, so it doesn't quite work yet

[13:30] <autrijus> but junctions do iirc, so if that's the only blocking thing, we're close

[13:30] <pdcawley> After I've finished watching _Dr No_

[13:31] <pdcawley> Easy enough to rewrite without uniq I think.

[13:32] <pdcawley> And as it stands is *desperately* inefficient.

[14:15] <svnbot6> r6395 | iblech++ | * t/unspecced/coro.t: return() should reset the entrypoint.

[14:15] <svnbot6> r6395 | iblech++ | * PIL2JS: PIL::PStmt, PIL::PVar, PIL::PStmts:

[14:15] <svnbot6> r6395 | iblech++ |   sub foo { return 3 } is no longer sub foo { return(return 3) }.

[14:15] <svnbot6> r6395 | iblech++ |   Similarily, coro foo { yield 3 } is no longer coro foo { return(yield 3) }.

[14:17] <xinming> .doit(1,2,3) :{ $^a <=> $^b }

[14:17] <xinming> what does this do exactly please

[14:19] <iblech> It calls doit with the argument 1,2,3 and the slurpy block { $^a <=> $^b }

[14:19] <iblech> You can declare such a method with:

[14:19] <iblech> method doit($a,$b,$c, *&slurpy_block) {...}

[14:19] <iblech> method doit(*@normal_args, *&slurpy_block) {...} will work, too, I think

[14:21] <QtPlatypus> What does *&block mean?

[14:21] <QtPlatypus> I know what *@array means.

[14:22] <xinming> QtPlatypus: It might be something link, grep {}, @ary...

[14:23] <xinming> iblech: So, Why this grammar exists is only because of we can write it in another way,right?

[14:23] <xinming> grep @ary : { ... };

[14:23] <iblech> QtPlatypus: It allows you to specify a adverbial block, (map:{...}, grep:{...}, etc.)

[14:24] <QtPlatypus> Arh

[14:24] <iblech> xinming: I'm not sure I understood you correctly, but yes, it's because of TIMTOWTDI

[14:24] <iblech> xinming: That's disallowed, I think. There may not be whitespace between :{

[14:25] <xinming> iblech: Oops. I forgot it.

[14:27] <xinming> iblech: can the :{ } syntax be written into ->{ } ?

[14:27] <iblech> xinming: You mean something like @array.map:-> $a {...}?

[14:27] <iblech> That's disallowed

[14:27] <iblech> But

[14:28] <xinming> hmm, without :

[14:28] <xinming> .doit(1,2,3) ->{ $^a <=> $^b }

[14:28] <iblech> you can use placeholder argument if you want to name the params: @array.map:{ $^a + $^b }

[14:28] <iblech> Ah, that's disallowed, too

[14:28] <iblech> But .doit(1,2,3, -> $a, $b {$a <=> $b}) should work

[14:30] <xinming> so, .doit( *@ary ) `@ary = ( 1, 2, 3, 10, 11 )`  will pharsed like .doit( 1,2,3, -> 10, 11 { ... } ); right/

[14:32] <iblech> IIUC, no, * doesn't convert the argument types, so it would mean .doit(1,2,3,10,11).

[14:32] <iblech> You'd have to use

[14:32] <iblech> @ary = (1,2,3, -> ... {...}); .doit(*@ary)

[14:34] * xinming wonders if in emacs, that syntax highlighting for perl will pharsed by human instead of computer...

[14:35] <QtPlatypus> xinming: What do you mean?

[14:37] <iblech> xinming: $EDITOR could use Pugs to parse Perl

[14:37] <iblech> Meaning that it would also work with user-defined operators, macros, and grammar redefinitions

[14:38] <iblech> IIRC theorbtw1 was thinking of a Perl 6 syntax colorizer which used Pugs to parse the Perl

[14:42] <xinming> iblech: yes, I mean that.

[14:42] <xinming> If you use pugs to do that, the "process" might all be slown down.

[14:43] <iblech> Right, $EDITOR would have to optimize things a lot

[14:43] <xinming> iblech: At least, I don't want elisp to call "pugs-parser" to handle the syntax highlighting. :-)

[14:43] <iblech> So it only gives Pugs small regions to reparse

[14:44] <xinming> pugs might be the "father" of perl 6. :-)

[14:44] <iblech> Well, it's inevitable if you want user-defined ops, macros, and grammar redefinitions to be colored correctly

[14:47] <xinming> iblech: do you use Emacs?

[14:51] <iblech> xinming: No, vim

[14:54] <xinming> iblech: I prefer Emacs to Vim... But For editing the config file, I prefer vim.

[14:54] <xinming> oops

[14:55] <xinming> $omeone prefer $var_1 to $var_2, In this grammar, is $var_1 better than $var_2 to someone please?

[15:01] <xinming> sub tmp (*$a, *%hask, *@ary ) { ... }

[15:01] <xinming> ?eval sub tmp (*$a, *%hask, *@ary ) { ... }

[15:01] <evalbotzy> undef 

[15:05] <xinming> ?eval sub tmp ( $a, *%hash, *@ary ) { $a.say; }; tmp( 101, a => 100 );

[15:05] <evalbotzy> 100 bool::true 

[15:06] <xinming> ?eval sub tmp ( $a, *%hash, *@ary ) { $a.say; }; tmp( 101, { a => 100} );

[15:06] <evalbotzy> 101 bool::true 

[15:06] <xinming> ?eval sub tmp ( ?$a, *%hash, *@ary ) { $a.say; }; tmp({ a => 100} );

[15:06] <evalbotzy> a100 bool::true 

[15:06] <xinming> ?eval sub tmp ( ?$a, *%hash, *@ary ) { $a.say; }; tmp({ a => 100} ).perl;

[15:06] <evalbotzy> a100 'bool::true' 

[15:07] <xinming> ?eval sub tmp ( ?$a, *%hash, *@ary ) { $a.say; }; tmp({ a => " 100"} ).perl;

[15:07] <evalbotzy> a 100 'bool::true' 

[15:07] <xinming> { a => 100 }.say

[15:07] <xinming> ?eval { a => 100 }.say

[15:07] <evalbotzy> a 100 bool::true 

[15:11] <xinming> ?eval sub tmp (*%hash, *@ary ) { return undef }; tmp({ a => 100} );

[15:11] <evalbotzy> undef 

[15:12] <xinming> ?eval sub tmp (?$a, *%hash, *@ary ) { if $a { $a.say }; else return undef }; tmp({ a => 100} );

[15:12] <evalbotzy> a100 Error: No compatible subroutine found: "&else" 

[15:13] <xinming> ?eval sub tmp (?$a, *%hash, *@ary ) { if $a { $a.say } else return undef }; tmp({ a => 100} );

[15:13] <evalbotzy> Error:  unexpected "i" expecting ";", statements or "}" reserved word 

[15:13] <xinming> ?eval sub tmp (?$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp({ a => 100} );

[15:13] <evalbotzy> a100 bool::true 

[15:13] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp({ a => 100} );

[15:13] <evalbotzy> a100 bool::true 

[15:14] <xinming> hmm,

[15:14] <xinming> how can we distinguish named parameter and slurp hash parameter?

[15:58] <iblech> autrijus: my $num = 3; my $a = \$num; $num := 4; say $$a;  # 4, right?

[15:59] <autrijus> iblech: verily

[16:00] <autrijus> ?eval my $num = 3; my $a = \$num; $num := 4; $$a

[16:00] <evalbotzy> \3 

[16:00] <autrijus> oh wow.

[16:00] <autrijus> that is broken 'course :)

[16:01] <iblech> (Writing tests for =:= and eqv currently)

[16:02] <autrijus> excellent.

[16:09] <iblech> .id operates on the container or the cell?

[16:09] <autrijus> neither.

[16:10] <autrijus> on scalar it operates on the value; on array/hash it operates on the array/hash object.

[16:10] <iblech> ok

[16:10] <autrijus> =:= is orthogonal to id

[16:23] <svnbot6> r6396 | iblech++ | * Pugs.Parser: Parse the new eqv operator.

[16:23] <svnbot6> r6396 | iblech++ | * t/operators/identity.t: Fixes and improvements -- =:= operates on containers.

[16:23] <svnbot6> r6396 | iblech++ | * t/operators/eqv.t: 38 tests for the eqv operator.

[16:23] <svnbot6> r6396 | iblech++ | * PIL2JS: Prelude::JS:

[16:23] <svnbot6> r6396 | iblech++ |   * Minor fixes to &infix:<=:=> -- PIL2JS passes 35/39 of identity.t.

[16:23] <svnbot6> r6396 | iblech++ |   * Implemented &infix:<eqv>    -- PIL2JS passes 37/38 of eqv.t.

[16:24] <rmr> hello everyone ! :-)

[16:24] <rmr> so what's going on here?

[16:35] <svnbot6> r6397 | iblech++ | New t/var/refs_point_to_containers.t: References should point to containers,

[16:35] <svnbot6> r6397 | iblech++ | not cells or even values (passes 12/12 on PIL2JS).

[16:52] <xinming> hmm, maybe You all didn't see what I confused about,

[16:52] <xinming> how can we distinguish named parameter and slurp hash parameter?

[16:52] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp({ a => 100});

[16:52] <evalbotzy> a100 bool::true 

[16:57] <fglock_> how can I declare a method for 1..10:by(2)

[16:57] <fglock_> I tried multi infix:<..> ( Int|Num $a, Int|Num $b, Int|Num ?$by = 1 ) ... 

[16:58] <iblech> xinming: named paramaters and pairs are currently discussed on p6l, thread "Demagicalizing pairs" started by Luke

[16:59] <iblech> fglock_: I'd think so, but I doubt that that has been implemented yet. But better ask putter, he fixed :adverbial modifies recently

[16:59] <iblech> bbl &

[17:20] * autrijus discovers Symbol::Opaque

[17:21] <xinming> many people will refer the IIRC Thing, what this is really.

[17:21] <autrijus> luqui is quite insane.

[17:21] <autrijus> xinming: "if I recalled correctly"

[17:21] <autrijus> xinming: http://en.wikipedia.org/wiki/IIRC

[17:22] <xinming> autrijus: thanks

[17:31] <putter> How do we do goto LABEL in p6?  

[17:33] * integral hopes it's faster than perl5

[17:34] <iblech> putter: By using continuations? :)

[17:34] <iblech> putter: dunno. It might as well stay "goto LABEL"

[17:35] <autrijus> yeah, that's probably that.

[17:36] <autrijus> and surely it'd be invoking continuations?

[17:36] <autrijus> http://autrijus.org/tmp/Devel-TypeCheck-0.01-patched.tar.gz

[17:36] <autrijus> alias typecheck 'perl -MO=TypeCheck,-main'

[17:36] <autrijus> bargle++ # nice work

[17:38] <putter> ah well.  I'll add an abstraction layer then.  The JS spec uses "goto step 4" constructs.  Given the size of the spec, the rate at which I was progressing with hand rewrites... it would take *days*.  So it's time for some global text massage.

[17:40] <putter> Devel::TypeCheck looked interesting.  I only briefly skimmed the paper, but was left wondering why only three programs(?) were used for Experimental results.  Oh, duh.  Paper deadline of course. ;-)

[17:41] <autrijus> yes :)

[17:41] <autrijus> due in a week.

[17:46] <xinming> hmm, Perl now reached a place which is the hell for "English", Just now, I watched my qwert keyboard. and try to find if there is any punctuation which isn't been used in perl...

[17:47] <xinming> Maybe not for English, Even In Chinese. I think It will get there also...

[17:47] <Khisanth> already has!

[17:48] <xinming> what does ` do in perl 6?

[17:48] <xinming> Maybe we can consider this one.

[17:49] <autrijus> larry wants it to mean unit.

[17:49] <fglock_> what is the next milestone for Pugs?

[17:49] <autrijus> fglock_: 6.28.0, full OO support.

[17:50] <fglock_> it means having the Perl6 version of the MetaModel? or in Haskell?

[17:50] <autrijus> yes, or something like that.

[17:50] <putter> I don't suppose anyone has gotten around to writing a Filter::Simple like thing for pugs yet?

[17:50] <autrijus> putter: iblech checked in macro support a while ago.

[17:50] <autrijus> filter-simple style macros.

[17:51] <putter> yeah, but macros require arguments to parse.  you cant say "and take the rest of the line".

[17:53] <fglock_> is there a todo list?

[17:53] * putter tries to avoid having thousands of little one-line blocks because he cant grab lines of code.

[17:54] <fglock_> or something I can do to help

[17:55] <fglock_> there is not much I can do in the 'Lazy' front at the moment

[17:55] <putter> or me.  I'm only off play silly JS frontend games because I dont see a way to affect the critical path.

[17:59] <autrijus> uh, the critical path is probably make "make p5smoke" work.

[17:59] <autrijus> in the same fashion as "make jssmoke".

[17:59] <autrijus> maybe some metaprogramming to fill in PrimP5

[17:59] <autrijus> in a saner fashion

[18:00] <autrijus> that is perhaps the #1 important thing atm.

[18:01] <xinming> sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( a => 1, q:h{ a => 100} );

[18:01] <autrijus> i.e. perl5/PIL-Run/lib/PIL/Run/PrimP5.pm

[18:01] <autrijus> also, a shared inferface with jspugs.pl etc, or at least something similar, would also help a lot

[18:01] <xinming> hmm, anyone here would tell me if this might be ok... hmm, IMHO, I think It is ok for me...

[18:01] <autrijus> since I intend to hook in -BPerl5 and -BJS off them.

[18:02] <autrijus> xinming: q:h means that "%x" is interpolated

[18:02] <autrijus> xinming: it does not mean that you can write a=>100 and have it mean a hash

[18:02] <autrijus> to do that, use

[18:02] <autrijus> hash(a => 100)

[18:03] <autrijus> er sorry

[18:03] <autrijus> { a => 100 } would do

[18:04] <xinming> autrijus: I just wish to figure this problem. :-) because, if the you specified the named argument, You might not be able to have a hash key as the argument name,

[18:04] <fglock_> is there a way to define the primitives using the metamodel? (maybe by inserting methods in Int,Num...?)

[18:04] <autrijus> xinming: if you said { a => 100 } that'd work surely?

[18:04] <putter> one could clone jsbe.  but sane requires objects.  could be main difference between p5be and jsbe - good use of objects.  doesnt seem much point otherwise.  but pil2 doesnt do objects yet.  full stop.(?)  common interface can be done though.

[18:05] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( { a => 100} );

[18:05] <evalbotzy> a100 bool::true 

[18:05] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( );

[18:05] <evalbotzy> undef 

[18:05] <xinming> autrijus: *%hash should slurp all "Pairs" .

[18:05] <autrijus> xinming: yes and you are looking at a bug :)

[18:06] <xinming> But with the same syntax, the named argument can't be pharsed, 

[18:06] <autrijus> no the bug is simpler thant hat.

[18:07] <autrijus> ?eval sub tmp (+$a) { $a }; tmp(3);

[18:07] <evalbotzy> \3 

[18:07] <autrijus> ;)

[18:07] <autrijus> named participate in positional bindings. that's wrong.

[18:07] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp(3, 'a' => 3 );

[18:07] <evalbotzy> 3 bool::true 

[18:07] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp(3, 'a' => 5 );

[18:07] <evalbotzy> 5 bool::true 

[18:07] <xinming> You see what I means? :-)

[18:08] <autrijus> I see, but +$a means it can't take positionals

[18:08] <autrijus> so that's currently a bug that it could.

[18:08] <xinming> autrijus: hmm, But there will be confliction, with named parameters and the "slurp hash keys"

[18:09] <xinming> maybe slurped hash. :-)

[18:10] <putter> autrijus: did you mean common interface with runjs.pl?  jspugs is the repl.  crude-repl.pl already looks a lot like it (though jspugs doesnt actually eval expressions yet).   could be made more similar, and to the pugs repl.

[18:11] <putter> a runp5.pl would give you -B.

[18:14] <autrijus> putter: yes, that.

[18:14] <putter> ok.  in progress.

[18:14] <xinming> ?eval sub tmp ( $a, $b ) { "$a $b".say }; tmp( a => 3, b => 5 );

[18:14] <evalbotzy> 3 5 bool::true 

[18:14] <xinming> autrijus: so, this works, a => 3 is a pair.

[18:15] <putter> autrijus: still need something fglock_ can do to help.

[18:15] <autrijus> putter: also, the extent of OO in PIL1 -- i.e. classless OO -- would be useful to support that in runp5.

[18:15] <xinming> autrijus: What about the "slurped hash"? How to pass the a pair to that hash?

[18:15] <autrijus> xinming: *%h takes whatever +$x not bound; similar to how *@a takes whatever ?$x not bound

[18:16] <autrijus> xinming: any named things not explicitly bound to other args will go there.

[18:17] <dudley> autrijus: Do you know if you can compile a Scala program to a .jar that will run standalone on a jvm?

[18:17] <autrijus> putter: mm, maybe make mandel.p6 work on p5 :)

[18:17] <autrijus> dudley: yes, you can.

[18:17] <xinming> autrijus: Yes, So, If we have a key which name is the same as the "var" name, Then, It might pass wrong...

[18:17] <autrijus> xinming: that is so.

[18:17] <xinming> autrijus: hmm, So, I think We should make some point to avoid this.

[18:17] <dudley> I've got a punielicious PIL2 repl in Scala, but if it can't run without a Scala runtime, I may go the Nice route...

[18:18] <putter> ooooo.

[18:18] <autrijus> oh wow.

[18:19] <xinming> just like, the ( a => 'value' ) are bound to variable. and some_func( a => 'value' ) to explicitly pass it to the hash...

[18:19] <autrijus> xinming: (h => { a => value })

[18:19] <autrijus> will pass to %h. I think.

[18:20] <xinming> autrijus: ok, fall back to my example above.

[18:20] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( a => 3, a => { a => 3 } );

[18:20] <evalbotzy> 3 bool::true 

[18:20] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( a => 3, a => { a => 5 } );

[18:20] <evalbotzy> 3 bool::true 

[18:20] <autrijus> ?eval sub tmp (+$a, *%hash, *@ary ) { %hash }; tmp(hash => { a => 3 })

[18:20] <xinming> :-(

[18:20] <evalbotzy> {('a' => 3)} 

[18:20] <autrijus> :-)

[18:20] <xinming> autrijus: your right.

[18:20] <xinming> :'(

[18:21] <putter> autrijus: if you really want PIL1 p5be, I can transliterate PIL2JS.  But there doesnt seem to be much point.  I believe one would take a very different approach if one had PIL2 objects.  It would be a throwaway.

[18:21] <autrijus> putter: from my primitive runcore work, that is not so -- PIL2 is essentially typed and normalized PIL1

[18:23] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( a => 100 );

[18:23] <evalbotzy> 100 bool::true 

[18:23] <autrijus> putter: but it's not much transliteration as building the abstractions in p5 that unifies metamodel, intrinsics and ffi

[18:23] <iblech> putter: At least in PIL2JS, the code to support methods is ~~15 lines

[18:24] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( {a => 100} );

[18:24] <evalbotzy> a100 bool::true 

[18:24] <autrijus> putter: especially FFI, which is orthogonal to the IL

[18:24] <xinming> autrijus: is this example should return undef?

[18:24] <autrijus> and I think p5 FFI is one of, if not the, most important thing for pugs 6.28.0

[18:25] <autrijus> ?eval sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp({b => 123})

[18:25] <evalbotzy> b123 bool::true 

[18:25] <autrijus> xinming: yes, undef.

[18:25] <autrijus> xinming: both should be bound to @ary.

[18:25] <autrijus> xinming: so tests welcome

[18:25] <xinming> autrijus: I've said I will write tests. ;-)

[18:25] <autrijus> cool

[18:25] <fglock_> what is FFI?

[18:26] <autrijus> fglock_: foreign function interface

[18:26] <autrijus> use perl5:DBI;

[18:26] <autrijus> use jsan:Number.Roman;

[18:26] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if %hash<a> { %hash<a>.say } else{ return undef }}; tmp( {a => 100} );

[18:26] <evalbotzy> undef 

[18:27] <autrijus> xinming: that is correct, since it should go to @ary

[18:27] <fglock_> you mean to translate parameters and return values back and forth between P6 and native?

[18:27] <xinming> autrijus: You said `{ a => 100 }` should go to array, so ` a => { a => 100 }` should go into %hash, right?

[18:28] <autrijus> fglock_: yes... basically, how P6 should work with its host runtime

[18:28] <autrijus> fglock_: that part is of course runtime specific

[18:28] <autrijus> xinming: no, it should go to $a

[18:28] <autrijus> xinming: b => {a => 100} goes to hash.

[18:28] <autrijus> fglock_: it's similar to iblech's existing work on use jsan:Module

[18:29] <xinming> autrijus: then, b here is something like pseudo... It will do nothing...

[18:29] <autrijus> xinming: er no, b becomes the key in %hash

[18:29] <autrijus> %hash<b><a> would be 100

[18:30] <xinming> autrijus: How to generate a hash key named a? just like the result of %hash<a> would be 100?

[18:30] <autrijus> fglock_: more concretely, get t/unspecced/p5/*.t to pass on runp5

[18:30] <autrijus> xinming: sorry, I can't parse your question

[18:31] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if %hash<a> { %hash<a>.say } else{ return undef }}; tmp( a => {a => 100} );

[18:31] <evalbotzy> undef 

[18:31] <xinming> ?eval sub tmp (+$a, *%hash, *@ary ) { if %hash<a> { %hash<a><a>.say } else{ return undef }}; tmp( a => {a => 100} );

[18:31] <evalbotzy> undef 

[18:32] <autrijus> ?eval sub tmp (*%h) { %h<a><b> }; tmp(a => { b => 3 });

[18:32] <evalbotzy> \3 

[18:32] <autrijus> that's what I mean.

[18:32] <xinming> ?eval sub tmp (*%h) { %h<a> }; tmp(a => 3);

[18:32] <evalbotzy> \3 

[18:32] <xinming> This is what I mean,

[18:32] <xinming> ?eval sub tmp (+$a, *%h) { %h<a> }; tmp(a => 3);

[18:32] <evalbotzy> \undef 

[18:32] <autrijus> yes, that is correct behaviour.

[18:33] <autrijus> ?eval sub tmp (+$a, *%h) { %h<b> }; tmp(b => 3);

[18:33] <evalbotzy> \3 

[18:33] <autrijus> and this is also correct.

[18:33] <xinming> how to pass the pair `a => 3` into %hash rather than the argument.

[18:33] <autrijus> ?eval sub tmp (+$a, *%h) { %h<a> }; tmp(h => { a => 3 });

[18:33] <evalbotzy> \3 

[18:33] <autrijus> like that.

[18:33] <xinming> yes,

[18:33] <xinming> ?eval sub tmp (+$a, *%h) { %h<a> }; tmp(y => { a => 3 });

[18:33] <evalbotzy> \undef 

[18:35] <xinming> ?eval sub tmp (+$a, *%h) { %h.keys }; tmp(a => 10, h => { a => 3 }, b => 3, c => 4);

[18:35] <evalbotzy> ('a') 

[18:42] <svnbot6> r6398 | iblech++ | Net::IRC: Updated the documentation of Net::IRC-OO and minor fixes to

[18:42] <svnbot6> r6398 | iblech++ | Net::IRC's documentation.

[18:42] <xinming> ?eval sub tmp ($a, *%h, *%ary) { }; tmp( a => 1, h => { }, ary => [], x => 5, y => 6 );

[18:42] <evalbotzy> undef 

[18:43] <xinming> autrijus: so, Is this example mean that the pair ` x => 5, y => 6 ` are all ignored?

[18:43] <xinming> s/Is/does/

[18:44] <autrijus> xinming: I think so, and I further think it's correct

[18:44] <iblech> Hm, I'd say that's an error

[18:45] <iblech> As all params should have a var which they can be bound to

[18:45] <autrijus> iblech: and if there's (*%h, *%h2), it binds to h2?

[18:45] <xinming> autrijus: In fact, That's why I wish to clarify... :-)

[18:45] <iblech> That's my intuition, yep

[18:45] <xinming> autrijus: I now caught up with you, But... :-)

[18:45] <autrijus> okay, I think that's probably best.

[18:46] <autrijus> note that in methods you get *%_ for free

[18:46] <autrijus> so practically that error won't happen

[18:46] <autrijus> unless of course you do (_ => ...)

[18:46] <iblech> Why is this, BTW?

[18:46] <autrijus> xinming: so test that it shoudl raise an error

[18:46] <rmr> hi everyone

[18:46] <autrijus> iblech: subclasses can then redispatch to super/next without fear of incompatibility.

[18:47] <autrijus> greetings rmr

[18:47] <iblech> autrijus: Ah, makes sense

[18:47] <rmr> i'm a begineer of perl scripting language

[18:47] <rmr> :-)

[18:47] <xinming> rmr: hi

[18:47] <autrijus> nice. hopefully one day you will be a master of perl programming language :)

[18:48] <xinming> autrijus: Which example you think will raise an error?

[18:48] <rmr> autrijus: Thanks :-)

[18:48] <xinming> mine?

[18:48] <xinming> rmr: In fact, I am on the way... 

[18:48] <autrijus> xinming: ary=>[] should cause an error because %ary can't take []

[18:49] <autrijus> xinming: furthermore, the unbound b=> and c=> should cause error, as are the unbound x=> and y=>

[18:49] <rmr> ok master programmers!!!

[18:49] <rmr> IGTG

[18:50] <rmr> c ya...

[18:50] <xinming> autrijus: Ok, thanks. Now, I recorded it.

[18:53] <rmr> hi everyone!

[18:54] <clkao> 6/win28

[18:54] <rmr> can anyone tell me which is the best book to get started in perl?

[18:54] <autrijus> rmr: Learning Perl, 4th edition, also known as the Llama book.

[18:54] <rmr> right now i'm using o'reilly learning perl 3ed

[18:54] <autrijus> 3ed works too, but 4ed is cooler because it talks about Pugs

[18:54] <autrijus> ;)

[18:55] <rmr> Pugs?!:-/

[18:55] <autrijus> rmr: pugscode.org

[18:56] <rmr> thanks 4 the info!

[18:56] <rmr> :-)

[18:56] <xinming> autrijus: who is the operator of #perlchina?

[18:58] <autrijus> xinming: no idea...

[18:58] <xinming> autrijus: hmm, Ok, I will ask myself. :-)

[18:59] <fglock_> is there a description of PIL that I can read?

[19:01] <iblech> fglock_: Pugs.Compile :) And there was a thread about PIL on p6c some weeks ago

[19:01] <rmr> can u tell me about some commonly used programs in linux, written in perl?

[19:03] <iblech> rmr: Parts of Debian's dpkg/apt-get are written in Perl 5, IIRC

[19:03] <rmr> thanks iblech

[19:05] <kgftr|konobi> iblech: http://kungfuftr.com/code/dibs-0.01.tar.gz

[19:05] <kgftr|konobi> if you're intrested

[19:05] <autrijus> fglock_: also -CPerl5 output

[19:06] <autrijus> fglock_: and perl5/PIL2JS/lib/PIL/*

[19:07] <iblech> fglock_: And -CPerl5 | perl -MYAML -we 'print Dump(<>)'

[19:07] <xinming> rmr: I think, You shouldn't ask which programs are written in perl, as most program needs perl, :-)

[19:08] <iblech> kgftr|konobi: This is not "dibs -- Distributed Internet Backup System", is it?

[19:09] <rmr> xinming: can u give me some eg: ? 

[19:09] <kgftr|konobi> nope... debian (improved/improvised) installer

[19:09] <iblech> kgftr|konobi: ah

[19:09] <xinming> rmr: I don't think we need much eg. as most Linux distribution "have" to install perl. even in freebsd.

[19:10] <kgftr|konobi> came up with it ages ago to provide a better mechanism for debootstrap for one-touch installations

[19:11] <rmr> well, even the cygwin i'm currently using under windows has got perl... so i guess its an important part of every distro, right?

[19:12] <kgftr|konobi> xinming: freebsd 5.0 doesn't have perl

[19:12] <autrijus> ...in its minimal installation

[19:12] <xinming> kgftr|konobi: hmm, Well, Sorry for my misleading. :-)

[19:12] <autrijus> in practice, though, its default install contains perl.

[19:12] <kgftr|konobi> autrijus: true enough

[19:12] <rmr> ok

[19:13] <autrijus> so it's more like "freebsd5's core doesn't depend on a particular version of perl5".

[19:13] <rmr> so all of u guys r using freebsd? i've never had the opportunity to use freebsd...

[19:13] <autrijus> I'd imagine not. :)

[19:13] * integral keeps misreading rmr as rms 8)

[19:14] <autrijus> debian-based distros is perhaps more popular here iirc

[19:14] <kgftr|konobi> down with linux! as they say

[19:16] <rmr> can i run all the GNU sw i'm using in linux in freebsd as well?

[19:16] <integral> that's what meta^Wautoconf is for

[19:17] <rmr> i mean without any modifications to the source code?

[19:17] <autrijus> rmr: freebsd can run linux binaries.

[19:17] <rmr> is that because both linux & freebsd r POSIX compliant?

[19:17] <autrijus> rmr: also you can install a debian, rh9, suse9, or gentoo userland.

[19:17] <xinming> rmr: But only 90%...

[19:18] <autrijus> rmr: so unless it's a kernel driver or something, chances are it runs on freebsd.

[19:18] <autrijus> rmr: no, it's because freebsd is linux compliant :)

[19:18] <xinming> rmr: No, that's because BSD has a "emulator" for Linux binary.

[19:18] <xinming> autrijus: hmm, so, why are you choosing bsd?

[19:18] <xinming> autrijus: :-)

[19:19] <rmr> ok. thanx guys..:-)

[19:19] <autrijus> xinming: clkao forced me to

[19:19] <autrijus> I had not choice

[19:19] <autrijus> (translation: freebsd community in .tw more active than linux community.)

[19:19] <autrijus> that was many years ago though. nowadays it's both got great community.

[19:19] <xinming> what does clkao mean ?

[19:20] <rmr> i'd like 2 try bsd... do they've a live cd?

[19:20] <autrijus> xinming: clkao is clkao at clkao.org, author of svk.elixus.org, the person introduced me to freebsd, all around crazy guy.

[19:20] <xinming> rmr: I suggest you Linux rather than bsd if you have much new hardware.

[19:20] <autrijus> rmr: yes, http://www.freesbie.org/

[19:20] <kgftr|konobi> freebsd emulates linux system calls, iirc

[19:21] <xinming> rmr: I ever wish to try Freebsd, But I got a Sil 3114 sata card and something more which doesn't well supported in Freebsd,

[19:22] <rmr> what about hacking the device drivers 4 say, linux and using it?

[19:23] <autrijus> sadly that's the one thing that does not carry over :-/

[19:23] <kgftr|konobi> better than it was though

[19:24] <autrijus> yup. thanks to eg unified codebase for wifi with linux

[19:25] <rmr> ok. i've an old PIII system with 64 MB RAM & a 40GB IDE HDD. can i do a minimal install in this system

[19:25] <autrijus> you can do a full install.

[19:25] <autrijus> but I need to sleep. cioa!

[19:26] <autrijus> *wave* 

[19:26] * autrijus &

[19:26] <rmr> ok ciao

[19:26] <rmr> autrijus: Thanks 4 the info...

[19:27] <iblech> Night :)

[19:28] <rmr> IGTG now. Good Night Everybody...:)

[19:31] <xinming> hmm, what does mmd mean?

[19:32] <xinming> and also ciao...

[19:35] <dudley> Multi Method Dispatch

[19:35] <dudley> and ciao is goodbye

[19:35] <dudley> in italian

[19:37] * dudley slinks back off to Real Life for a while...

[19:39] * nothingmuch wonders why no one has mentioned the is_gay function... http://perlmonks.org/?node_id=485453

[19:40] <Juerd> It has an underscore in its name and thus does not at all look like a Perl builtin

[19:41] <nothingmuch> that's because it's part of PDF::Sexuality

[19:44] <jql> does this mean there's a use strict qw(hetero)?

[19:53] * theorbtw1 looks up the node in question, and says "OY!" loudly.

[19:53] <xinming> by the way, anyone here can tell me why in Synopsis, it will have a big jump. which skip S14 and reached S29?

[19:53] <putter> fglock_: ping?

[19:54] <iblech> xinming: Only because some topics are more important than others

[19:54] <iblech> xinming: Think of builtin subs vs. threads or so

[19:55] <xinming> iblech: So, there are still many syntax of the perl language there? T_T

[19:56] <xinming> iblech: or They just the default functions built-in with perl 6

[19:56] <kgftr|konobi> theorbtw1: NOT LONG NOW SUCKA!

[19:57] <iblech> xinming: Sorry, couldn't parse these two sentences, but yes, you can, of course, override all "builtins"

[19:57] <iblech> xinming: There could even be a "no builtins;"

[19:58] <xinming> iblech: I mean, If there are still many grammars for perl 6 language there.

[19:58] <putter> Can anyone think of a reason p6-on-p5 could not have a blended type system?  eg, p5 str isa P5::Str does String.  p6 classes can inherit from p5 cls via AUTOMETH.  p5 classes can inherit from p6 cls normally, as long a p6 classes @ISA a UNIVERSAL_Blocker class which throws isa() etc back at the metamodel's AUTOLOAD.  use overload helps use p6 objects in p5 code.  thoughts?

[19:58] <xinming> iblech xinming: There could even be a "no builtins;", hmm, So what does perl 6 do exactly? Just a kind of mind... maybe the spirit of perl 6? :-)

[19:59] <iblech> putter: ooh inheriting from native classes

[20:00] <iblech> xinming: I've probably misunderstood you, but yes, there can be as many grammars as wanted/needed

[20:03] <wolverian> Juerd, hello. haven't seen you much lately. (on IRC, that is.)

[20:03] <Juerd> Hello

[20:03] <Juerd> I've been away for a month, and have been inactive for at least a month before that

[20:03] <Juerd> I've been on IRC now and then, but it's highly irregular

[20:03] <wolverian> ah. I hope it's nothing serious? 

[20:04] <Juerd> And because my hands, wrists and arms have still not yet recovered, it'll stay like this for a while, I fear.

[20:04] <Juerd> It's serious alright

[20:04] <stevan> putter: slight digression, but where is AUTOMETH and co. documented? which Syn?

[20:04] <wolverian> Juerd, damn. I'm sorry. I didn't cause it but hate the world for it.

[20:05] <wolverian> (really.)

[20:05] <Juerd> I hate the world for it even though I did in part cause it

[20:05] <Juerd> It would perhaps be easier to live with if it weren't partly my own fault

[20:06] <wolverian> it's probably easier to hate the world then.

[20:06] <wolverian> I don't consider it a fault, though.

[20:06] <Juerd> Stubbornness is a big mistake

[20:07] <Juerd> I didn't admit it at the time, but I have to ask myself why the hell my largest number of PM posts were done at times I let other things for what they were because of the same very pain.

[20:07] <Juerd> I didn't make that mistake this time.

[20:08] <putter> stevan!  hi.  was just thinking of you.  checking...

[20:09] <putter> A12 S1[023]

[20:09] <wolverian> Juerd, at least you've learned. and I'm happy that you're not totally disabled.

[20:09] <Juerd> If I were totally disabled, I'd get help from others

[20:09] <Juerd> Now I am on my own

[20:09] <stevan> putter: thanks :)

[20:09] <Juerd> Even my parents no longer believe I have to avoid some activities anymore

[20:09] <putter> np :)

[20:10] <wolverian> Juerd, that sucks. :/

[20:10] <Juerd> I can still move everything, and I can still carry large boxes

[20:10] <Juerd> It's hard for the outside world to realise that this all causes great discomfort

[20:10] <putter> iblech: on reflection (no pun intended), p6 classes would almost certainly have to do delegation, but with AUTOMETH it could look to clients like inheritance.

[20:13] <xinming> @object».*meth(@args)  # calls all methods (0 or more) on each

[20:13] <xinming> what does each mean here?

[20:14] <xinming> in parrel dispatch

[20:14] <putter> Juerd: yeah, that's a tough one.  It helps to get it named, eg "I have CTS, so I can't do that".

[20:14] <xinming> parallel

[20:15] <Juerd> putter: Yep. But I don't have CTS --nobody knows what exactly I do have-- and I *can* do it.

[20:15] <Juerd> I can just ignore the pain and do things. It'll get worse, but it doesn't disable me.

[20:15] <Juerd> Hm, I said I didn't make the same mistake this time. That isn't even true.

[20:16] <Juerd> http://juerd.nl/vt.txt  # I shouldn't have typed all this in, even though I believe in the cause.

[20:17] <putter> sure, but there is a large class of things (lifting vis back or abdom.), typing vis wrists, etc, where yes you can do it, you might even do it without pain, but you know the concequences in pain and incapacity for thus pushing your envelope, and so wisely decline the task.

[20:18] <Juerd> Yes

[20:18] <Juerd> I know you people understand it. I just wish the general public understood what it is about.

[20:19] <putter> the real hard case is when there isnt even near term feedback, eg truckdrivers and spinal/join wear from lifting, where its "slow job vs abstraction of being crippled for life a decade out".

[20:19] <Juerd> It's so depressing to continually have to answer questions to people who don't understand the answer, and will never do so.

[20:20] <putter> at least the universe promptly reminds you you are making a mistake.  even if its thus far difficult to explain to others. ;)

[20:21] <wolverian> xinming, it calls @object[0].meth, @object[1].meth, and each .meth that it finds in the inheritance trees of all the @object[n]s

[20:22] <Juerd> By the way - I am looking for people who CAN type (without discomfort) to help me transcribing some videos

[20:22] <Juerd> But I reckon that asking this in #perl6 is unsmart. Ignore what I said and get coding :)

[20:22] <putter> General advice for this kind of thing - try additional doctors.  Often one will eventually say, "oh, of course.  I dont know what those other folks were thinking.  its obviously foo".  They you can say "its foo" and people will be happy.  Sometimes even when the cause is still unknown, there are names for bags of symptoms, which doest help you cure wise, but does provide a name.

[20:22] <xinming> wolverian: Ok,thanks.

[20:23] <xinming> wolverian: I didn't see the @ T_T

[20:23] <Juerd> putter: I've seen too many already, imo

[20:24] <Juerd> putter: I can say "it's RSI", which at least in .nl is known by everyone.

[20:24] <putter> rms (not rmr;) has had folks providing typing assistance full time.  "Ctrl-A Meta-W thank you for your"...

[20:24] <Juerd> putter: But because of some very weird media attention, people think that 1/3 of all office workers have RSI, and that it is mostly a psychological and whiney disorder.

[20:24] <putter> ah.  so "i have rsi.  i have to / have been told to  avoid x y z"

[20:25] <putter> ooooh.  curious.

[20:25] <Juerd> There was a move to rename the spectrum of RSI to CANS, but of course publicizing this decision undid the effect it should have had.

[20:26] <putter> well, could always add a modifier.  "severe rsi".  "tramatic rsi".  "impact rsi"

[20:26] <Juerd> oh, severe rsi is the official term for what I have

[20:26] <Juerd> And that is what I use.

[20:27] <Juerd> It helps not. :(

[20:27] <putter> :)  another hypothesis bites the dust.

[20:27] <putter> err, s/:)/:(/

[20:29] <putter> hmm, well, could use it a chance to do public education.  the process of which also helps pursuade.

[20:31] <Juerd> I'm too tired of all this nonsense that surrounds it, that I can't even explain anymore in a friendly tone what is wrong.

[20:31] <Juerd> It gets to you after a few years

[20:31] <luqui> ?- topic(X).

[20:31] <Juerd> luqui: RSI and people not recognising its impact and importance

[20:31] <luqui> ahh

[20:32] <Juerd> The annoying and awkward situation in which you have a named disorder, but you still have to do everything just because people don't believe the things they ask from you will hurt so much.

[20:33] <fglock_> putter: is there an overview of how PIL-RUN works?

[20:33] <putter> fglock_: no.  let's see...

[20:34] * fglock_ is lost in the void between MetaModel and PIL

[20:35] <xinming>     multi sub unimpl (MyFoo $x) { upchuck(); }

[20:35] <xinming>     &infix:<+> ::= &unimpl;

[20:35] <xinming> hmm, infix needs two arguments, so, the example only gives one, where is the other one please?

[20:36] <fglock_> xinming: that should be an error

[20:36] <putter> crude-repl is the top, MainX loads, EvalX processes PIL to p5, ApiX provides an abstraction on the runtime, PrimP5 has primitives.  Type/ contains some object types not yet migrated to Per6-Value etal.  That's about it.

[20:37] <luqui> xinming, where did you see that?

[20:37] <putter> fglock_: ah, ApiX is most of the interface between mm and pil-run.  EvalX handles all PIL processing.

[20:37] <nothingmuch> hola luqui

[20:37] <luqui> hi nothingmuch 

[20:37] <fglock_> putter: I guess it will need Type abstraction? How does it handle multisubs?

[20:37] <xinming> luqui: S13

[20:38] <xinming> fglock_: S13 show this example.

[20:38] <putter> actually, I was going to talk with you and stevan to see if we cound discard ApiX and have a blended p6-p5 type system.

[20:39] <putter> fglock_: the mm isnt yet being used for subs.  Type/Sub.pm is.

[20:40] <xinming> reading Synopsis is really kind of fun.

[20:40] <putter> that was a next step before something in the mm changed, and crude-repl stopped working.

[20:40] <luqui> xinming: fixed

[20:40] <luqui> thanks

[20:41] <fglock_> I've been planning to work on the type system - I hoped that being able to undertand PIL would help the implementation

[20:41] <putter> I dont suppose anyone has seen any perl5 magic which makes ->foo method access work on nonreference things?

[20:41] * luqui has been wanting that for a while

[20:41] <fglock_> do you mean on unboxed types?

[20:41] <luqui> you could overload all constants :-)

[20:42] <luqui> putter, why?

[20:42] <xinming> luqui: What do you mean by "fixed"? do you mean the document is fixed, or just a wrong completion ? :-)

[20:43] <luqui> xinming, document has been fixed in https://svn.perl.org/perl6/doc

[20:43] <putter> perl -we '$x = 3;  $x->foo'  currently an error, someone out there may well have a hack to make it work...

[20:43] <luqui> It would require some C code or a source filter

[20:43] <putter> re why, just trying to understand the design space,

[20:43] <luqui> or overload::constants

[20:44] <luqui> (which doesn't exist, I now remember)

[20:44] <luqui> (it's just part of overload)

[20:44] <putter> autrijus's emphasis on FFI has me thinking about the p5backend from the bottom up.  "if p6 integration is to appear seamless from the p5 side, then ...".

[20:45] <xinming> luqui: I ever thought I was reading the newest doc. But now I know...

[20:45] <fglock_> putter: if you were using Value.pm, it would be $x=Int->new( '$.unboxed'=>3 ); $x->foo; 

[20:45] <luqui> xinming, well, you were, until I fixed it five minutes ago

[20:46] <luqui> that reminds me.. I have to write my value type manifesto

[20:47] <putter> right.  but one could make p5 ints look like say P5::Int (does Integer) on p6 side.  I was just looking for a way to close the circle.  avoid p5 code having to say make_sure_its_an_object($x)->foo

[20:48] <fglock_> you mean delay the autoboxing - but that's the optimizer's job (?)

[20:48] <luqui> I think he's talking about user-generated code

[20:49] <luqui> (that is, hand written)

[20:49] <xinming> luqui: So, I wish to clarify an example...

[20:50] <xinming> sub tmp (+$a, *%hash, *@ary ) { if $a { $a.say } else{ return undef }}; tmp( { a => 100} ); should return undef;

[20:50] <xinming> which ($a %hash @ary ) will get `{ a => 100 }`

[20:50] <luqui> @ary

[20:51] <xinming> luqui: Ok, then, how about `tmp( a => 100 )` ?

[20:51] <luqui> +$foo and *%foo are both for named arguments

[20:51] <luqui> $a would get that

[20:51] <luqui> and tmp( b => 100 );  # %hash<b> == 100

[20:51] <putter> yes.  the ideal FFI is one that doesnt exist.  user p5 code says $x = Int->new(3)  or just $x = 3 and can use p6 bar($x).  and with $x = a_p6_bar(),  overloading gets us $x + 1, but $x->foo is still a problem for native p5 non-reference types.

[20:51] <xinming> luqui: Ok, the problem now comes out,

[20:52] <fglock_> how about _call_method( $x, 'foo' )

[20:52] <xinming> tmp( a => 100, 3, 4, 5, 6, );

[20:52] <xinming> luqui: If I need to pass a pair which is ( a => 200 ), how can I do that?

[20:52] <xinming> pass it to %

[20:52] <luqui> what do you mean?

[20:53] <luqui> you want $a to be 100, but you want %hash<a> to be 200?

[20:53] <putter> right.  I was just wondering whether in the large bag of little used esoteric perl5 hacks, someone had worked out something to permit 3->foo.

[20:53] <xinming> luqui: yes.

[20:53] <luqui> can't

[20:53] <luqui> *% is for overflow named arguments

[20:53] <fglock_> that's the same thing when you do UNIVERSAL::isa() 

[20:53] <xinming> luqui: So, % will never get a key named 'a' in this example, right?

[20:53] <luqui> fglock_, except that _call_method could be smart about it

[20:54] <luqui> xinming, I believe so

[20:54] <fglock_> sure

[20:54] <xinming> luqui: In fact, autrijus gave me an example tmp( a => 100, hash => { a => 200 } );

[20:54] <putter> isa($x,'C') you mean?

[20:54] <xinming> luqui: But from This example, The other problem comes out, which is, other pairs which "should" be in hash will all be ignored.

[20:55] <luqui> oh my

[20:55] <luqui> yeah, that's an interesting case

[20:55] <fglock_> sub call_method{ unless(ref($_[0])){ upgrade_to_object(\$_[0]) } $_[0]->$_[1] } or something like that

[20:56] <xinming> luqui: So, I think You might need to write more details on this. :-)

[20:56] <putter> right.  or the more general but less efficient  p6ify($x)  which gives you a full p6 proxy object.

[20:56] <putter> (if necessary)

[20:57] <luqui> xinming, using hash => { } might be construed as evil, according to some

[20:57] <xinming> luqui: some people who is busy won't care about this, except me... as I am "twindle my thumbs" :-)

[20:58] * luqui thinks he will p6l this issue

[20:58] <xinming> luqui: by the way, In the above example, I didn't mean *%, I mean *%hash, hope you can understand. :-)

[20:58] <luqui> yeah

[20:59] <xinming> %_ will slurp all the other pairs for methods, But not for sub... odd...

[21:00] <luqui> xinming, the only difference is that in methods %_ is automatically declared

[21:00] <putter> ha! you _can_ create p5 infix operators.  just define a receiver class with say + overloaded.  so Filter::Simple say  --> (that's - - > ) to say + mumble, where mumble's overload + returns the right thing.  hmm, have to check precedence... hopefully something higher than +

[21:01] <putter> err, those "say"'s are "perhaps", not say(). ;)

[21:02] <xinming> luqui: I knew. :-)

[21:02] <luqui> putter, that's an interesting idea

[21:03] <luqui> the tightest infix you can get is **

[21:03] <luqui> but it's right associative

[21:03] <putter> 3-->ref eq 'P5::Int'  ;)

[21:03] <luqui> the next one up is *

[21:03] <putter> ooo, good.

[21:04] <luqui> putter, you will break Damian's code if you do that :-)

[21:04] <putter> which code?

[21:05] <luqui> he uses this idiom:

[21:05] <luqui> while ($count --> 0) {...}

[21:06] <luqui> oh, there's another issue

[21:06] <putter> ?

[21:07] <luqui> 1-->ref eq 'P5::Int'  # would be equivalent to 1**ref($_) eq 'P5::Int'

[21:07] <luqui> that is, -> is special in that it quotes its right side

[21:07] <luqui> but that's not a huge issue

[21:08] <luqui> just turn 3-->ref into 3**_method('ref')

[21:08] <luqui> source filters can do such things :-)

[21:09] <luqui> hmmmmmm, I wonder if you could use that technique to use ->

[21:09] <luqui> convert $x->y into $x**_method('y')

[21:09] <luqui> and then make _method smart

[21:10] <fglock_> how about p6(1)->foo instead of 1-->foo (no source filter needed)

[21:10] <luqui> fglock_, because that's a lot harder with a source filter

[21:10] <luqui> oh

[21:10] <luqui> without a source filter

[21:10] <luqui> that's awkward though

[21:10] <putter> oh drats.  I see.  you cant overload anything higher than, so has to deal not just with the object, but with any method call.  blech.  oh well.

[21:10] <luqui> you want to minimize pain on the user's part

[21:11] <putter> than -> 

[21:12] <putter> fglock_: yes, definitely.  also call(3,'foo').  I'm just looking for a third, less efficient but perhaps less invasive, idiom.

[21:12] <luqui> Hmm, is PPI smart enough to be able to transform 1->foo

[21:12] <luqui> generally

[21:12] <fglock_> you are using the source filter as a mini-perl6?

[21:13] <fglock_> in this case, why not use 3.foo ?

[21:13] <luqui> because that's a much more common operator in perl 5

[21:13] <xinming> luqui: Why does perl still use pod, why not change it to xml by the way?

[21:14] <luqui> xinming, because xml sucks

[21:14] <luqui> I should clarify

[21:14] <luqui> humans hate writing xml

[21:14] <luqui> and you can't read it easily

[21:14] <luqui> but its good for generated markup

[21:14] <putter> fglock_: in a very limited sense.  the idea being -> would work as expected on p6 objects.  but if p6 objects arent forced to do outgoing border checks, a p6 sub could return a p5 native int.  and it would be nice not to have to saturate your p5 code with "an make sure it's not a native int before I call a method" code.

[21:14] <luqui> but pod is written and read by humans

[21:14] <putter> luqui: PPI?

[21:15] <wolverian> luqui, I assume PPI is good enough, as it (AFAIK) parses 99% of CPAN correctly.

[21:15] <luqui> wolverian, it *tokenizes* 99% of CPAN correctly

[21:15] <xinming> luqui: well, In fact, For perl, There isn't much markup, So, with autocomplete feature. I didn't find xml is hard to written really. :-)

[21:15] <luqui> I was wondering if it was smart enough such that you could put a precedence hack around it

[21:15] <wolverian> luqui, ah, right.

[21:16] <putter> hmm... an alternative would be P5::Int  does _not_ does Integer, but does coerce, so everything which hits p6 ceases to be native.  but then one has to deal with proxy objects and such.  which it would be nice to avoid.

[21:17] <luqui> putter, but is not as nice to avoid as source filters are

[21:17] <luqui> xinming, well, you could write your documentation in xml

[21:17] <luqui> because we're already supporting both pod and kwid

[21:17] <luqui> so an =xml plugin shouldn't be so hard

[21:18] <putter> luqui: --> would be an optional import.  trades filterness for being able to "think objects" even in p5.

[21:19] <luqui> fair enough

[21:19] <luqui> however, as long as you're adding syntax

[21:19] <luqui> we could do as fglock_ says and treat /\.\w+/ as a method call

[21:19] <luqui> instead of the heaviweight /-->\w+/

[21:20] <putter> hmmmmmmmmm

[21:20] <luqui> oh shit

[21:21] <putter> lol :)

[21:21] <putter> loudly

[21:21] <luqui> how would you transform this:  3.foo(24)

[21:21] <putter> "what HE said!" 

[21:21] <putter> 3**mumble->foo(24)

[21:21] <luqui> which means 3**(mumble->foo(24))

[21:22] <luqui> however...

[21:22] <luqui> as long as you have control over mumble

[21:22] <luqui> you could make that work

[21:22] <putter> mumble still has to play "capture the chain of ->" game.

[21:23] <fglock_> 3**unboxed**->foo(24)   :)

[21:23] <fglock_> self-documenting

[21:23] <putter> **->  syntax error?

[21:24] <luqui> s:2nd/\*\*//

[21:24] <xinming> luqui: Ok, by the way, hmm, will be perl 6 default assume the codes are perl 6 in the future? I know now, It is assume the codes are perl 5 codes.

[21:25] <putter> oh, so using "unboxed" as the name of mumble?  i still havent thought to hard about what mumble needs to be.

[21:25] <luqui> xinming, you mean when you run perl script.pl

[21:25] <luqui> it is assumed to be perl 5?

[21:25] <putter> users will never see it anyway.

[21:25] <luqui> putter, I think he was suggesting that you make the users write that

[21:25] <putter> eeep.

[21:26] <fglock_> unboxed{3}->foo(24)  -- using a tied hash

[21:26] <luqui> fglock_, how is that better than p6(3)->foo(24)

[21:26] <luqui> xinming, well, the question is, when do we switch?

[21:26] <luqui> because as soon as we do, we break things

[21:26] <xinming> luqui: hmm. :-) 

[21:27] <luqui> so it will probably stay perl 5 forever, until we give you the option not to build perl 5 at all

[21:27] <luqui> and then it's the administrator's choice

[21:27] <luqui> the other way around it is to use a different extension for perl 6 scripts

[21:27] <xinming> luqui: why not ask people to change all the perl extension into .p5 or .pl5 ? :-)

[21:27] <luqui> how about the other way

[21:28] <xinming> luqui: and the default .pl will always stand for the newest version of perl.

[21:28] <luqui> ask people to change from .pl to .p6 when it's perl 6

[21:28] <putter> $x**ip6->foo()  does give you infixness wo filters, which p6($x)->foo  doesnt.  so I guess it could make sense to expose mumble so you can do that.

[21:28] <luqui> xinming, because then you're still breaking everything

[21:28] <luqui> it doesn't matter what you ask people to do

[21:28] <luqui> they won't read your request

[21:28] <fglock_> luqui: it allows more explicit declarations, such as unboxed{3:int}->foo(24)  

[21:28] <luqui> fglock_, that's a syntax error

[21:28] <luqui> p6(3, 'int')->foo(24)

[21:29] <xinming> luqui: hmm, Do something rude... :-)

[21:29] <putter> $x**as6->foo()**as6->bar()  vs  p6(p6($x)->foo())->bar()  vs  $x.foo().bar()

[21:29] <xinming> luqui: just do something like M$. :-)

[21:29] <luqui> ?

[21:29] <luqui> oh

[21:30] <putter> ok, can anyone think of any showstoppers for the blended type scheme?

[21:30] <xinming> luqui: Ok, so, how about extension .pl6? will it be used for perl ?

[21:30] <luqui> you mean "HI THERE, I SAW YOU HAVE A FILE THAT HAS A .PL EXTENSION.  YOU PROBABLY MEANT PERL 5, BUT WE WANT YOU TO MEAN PERL 6.  SO CHANGE IT, OR ELSE I'LL CRASH"

[21:30] <putter> everyone believe we can create a HIDEUNIVERSAL class which bounces UNIVERSAL methods back to the p6 object's mm AUTOLOAD?

[21:31] <luqui> just rebind UNIVERSAL?

[21:31] <xinming> luqui: Well, No... You should rather say, "Perl 5 is outdated... We need a wonderful technoledgy, which will make your life easier... your program wrong faster... and safer... "

[21:31] <luqui> *{'UNIVERSAL::'} = \%HIDEUNIVERSAL::'

[21:31] <xinming> s/wrong/run/

[21:32] <luqui> xinming, though the original wasn't too far off :-)

[21:32] <putter> p5 calling $p6o->isa() on a p6 object should get p6's version of is, rather than UNIVERSAL's.  I think.

[21:32] <luqui> so why don't you just define "sub isa" for the perl 6 Object class

[21:33] <putter> $p5o->isa() on non-p6 objects should get the usual UNIVERSAL isa.

[21:33] <fglock_> putter: I think it already works like this in the MetaModel

[21:33] <luqui> putter, right.  isa() is nothing special, you can override it just like any method

[21:33] <xinming> luqui: because perl is a really different language, It will keep changing... and in the future... I believe perl 7 will be even harder to "pharse", So, why not make these scheme default? .p6 or pl6,

[21:33] <putter> oh, duh.  by simply defining an isa method.

[21:33] <xinming> luqui: And also, It's really ugly to write use v6; as the first statement.

[21:34] <luqui> xinming, agreed

[21:34] <putter> so that just leaves the puntable issue of folks adding methods to UNIVERSAL and p6 having to avoid them.  something for version 2.

[21:34] <luqui> I believe if you give perl a file that ends with .pl6 or .p6, it should do the right thing

[21:34] <xinming> luqui: or even more, you can have symbolic link, which links to /usr/bin/perl and the link names are /usr/bin/perl5 /usr/bin/perl6

[21:35] <luqui> and we can just bind .pl (and .plx, and .pm) to mean perl 5 by default

[21:35] <luqui> xinming, yeah, that was planned already

[21:35] <xinming> luqui: will the perl 6 have a different extension for "module"?

[21:35] <putter> Ok, so which version of the metamodel should we be using.  stevan?  mm2.0?  doesnt matter?

[21:35] <luqui> no, but perl 6 modules start with "module", not "package"

[21:35] <luqui> so we can tell

[21:36] <xinming> I rather prefer going with the newest perl.

[21:36] <luqui> again, that breaks stuff.  we don't want to break stuff

[21:36] <luqui> one of the reasons perl has been so successful is because it never breaks backwards compatibility

[21:36] <putter> If -Bperl5 is to be integrated with pugs, we should probably move a metamodel, along with its tests, out of pugs/perl5/ and into the main distribution.

[21:36] <luqui> we're gutting the language, so we have to have safety features to assume backwards compatibility

[21:37] <luqui> putter, maybe so

[21:37] <fglock_> luqui: does isa() test for subtypes? like $list->isa(Lazy)

[21:37] <xinming> luqui: hmm, I think, by the time goes by, we can make .p5 .pl5 as perl 5, and px plx for the specified version. and .pl for the newest version of perl.

[21:38] <xinming> luqui: backwards compatibility will confuse many "newbie"

[21:39] <xinming> They might not be able to do so much comparision with perl. That's what I think, might be wrong anyway.

[21:39] <xinming> luqui: just do a suggestion. ;-) and most people will change by the time goes by. :-)

[21:39] <luqui> fglock_, in perl 6, no

[21:40] <luqui> xinming, you know how perl tutorials say "always write #!/usr/bin/perl at the top of every script"

[21:40] <xinming> this is a bit like w3c recommendation.

[21:40] <luqui> I don't see how perl six is any different: "always write #!/usr/bin/perl6 at the top of every script"

[21:40] <luqui> fglock_, in fact, it would really be nice to abolish isa() in perl 6

[21:40] <luqui> or at least hide it in is_subclass_of or inherits_from

[21:41] <xinming> luqui: hmm, So, Some people will use #!/usr/bin/perl6 at the top line, and use perl 5 syntax. That's what I can image. :-)

[21:41] <luqui> because most of the time, what people are asking is whether it does()

[21:41] <fglock_> or move it to .meta?

[21:41] <luqui> xinming, they have more to learn :-)

[21:41] <putter> iblech, etal: reality check: with this kind of FFI-free scheme, one could still cps transform p6 code, passing the continuation in a local() var.  is anything (aside from p5-compiled-from-p6 code size) lost?

[21:41] <luqui> fglock_, yeah, perhaps

[21:42] <fglock_> how to test for subtypes? .does(Lazy) ?

[21:42] <luqui> fglock_, yeah

[21:42] <luqui> though I think you're misusing "subtype"

[21:43] <fglock_> I've read that Lazy is a subtype ?

[21:43] <luqui> fglock_, of what, with what constraint?

[21:44] <xinming> luqui: hmm, So, If a script extension name is .p5 or .pl5, will this be pharsed as perl 5?

[21:44] <luqui> xinming, sure

[21:44] <luqui> xinming, just like everything else that isn't .p6 or .pl6

[21:44] <luqui> if it ends with .p5 and starts with "v6" or "use v6", then it's perl 6

[21:44] <luqui> perhaps with a warning on that case

[21:46] * putter mutters "pity there isnt a UNIVERSAL_UNBLESSED"... ints and strings could be validly copied into p6 objects, and arrays and hashes could have methods out of U_UB.

[21:46] <xinming> luqui: Ok, then, I'd suggest to write a simple line with, "we suggest use .px .plx (x = perl version ) name extension instead of .pl(Note: It's not necessary but recommend)."

[21:47] <luqui> xinming, agreed

[21:47] <luqui> .p5 is clearer than .pl

[21:47] <xinming> luqui: then, you can watch how long will this come to reality. :-)

[21:48] <xinming> and also, for .pl the autodetection way is needed, but It will assume it's the newest perl version.

[21:49] <luqui> uh, no.  .pl assumes perl 5

[21:49] <luqui> because that's when .pl was in use

[21:49] <xinming> luqui: hmm, what's extension for perl 4?

[21:49] <xinming> cgi? :-)

[21:49] <luqui> perl 5 is backwards compatible with perl 4, so it doesn't matter

[21:49] <putter> looks like having arrays use methods in ARRAY has been talked about for a decade, but never done.  :(

[21:49] <luqui> haha

[21:49] <xinming> or no extension, but use `cat filename | perl`

[21:50] <xinming> luqui: perl is amazing, But I think, the extension scheme flexibilty is really needed. as perl isn't like any other language in the world.

[21:51] <xinming> luqui: That's just my Humble Opinion.

[21:51] <wolverian> extensions are a hack anyway.

[21:51] <leo__> what I'm doing wrong: lt@feather:~$ pugs -e'use Set;say "hallo"'

[21:52] <leo__> (the plain say "hello" works fine)

[21:53] <luqui> hmm

[21:53] <luqui> well, this ought to work, but doesn't:

[21:53] <fglock_> luqui: so Lazy and Eager are roles - I was trying to find out this for days :)

[21:53] <nothingmuch> wow... /me just implemented the forth looping constructs in 10 lines of forth

[21:53] <putter> ARRAY autoload could even give the same "unblessed reference" error.  ah well.

[21:53] <luqui> pugs -Mblib6/lib -euse Set'

[21:53] <luqui> er, s/-e/-e'

[21:53] <nothingmuch> well, 2/3rds of them

[21:53] * putter is craving ruby just about now... none of this idiocy.

[21:53] <luqui> nothingmuch, cool

[21:53] <xinming> luqui: So, In fact, we can say, How many people there are still using perl 4? In fact, most people will use perl 5, hmm, except for older working scripts.

[21:54] <luqui> putter, what idiocy?

[21:54] <nothingmuch> i love the way forth is like that over and over again

[21:54] <nothingmuch> i should give it more than an hour a month =(

[21:54] <luqui> oh, the ARRAY stuff and whatnot

[21:54] * fglock_ programmed forth for years

[21:54] <fglock_> before perl

[21:55] <nothingmuch> fglock_: http://feather.perl6.org/~nothingmuch/harrorth

[21:55] <nothingmuch> uh, s/org/nl

[21:55] <nothingmuch> specifically http://feather.perl6.nl/~nothingmuch/harrorth/misc/Forth/lib/Forth/Interp.pm

[21:55] <nothingmuch> look for ': BEGIN'

[21:55] <putter> if native p5 arrays behaved as if they were blessed as ARRAY, its not clear anything would be lost (the arguments against I've seen so far have all be flawed), and we wouldnt now have to be designing hoops and struggling to jump through them.  the right idea was had by the mid 90's, and yet here we are. :(  sigh.

[21:56] <nothingmuch> fglock_: i'm learning forth by implementing it with perl, so that I can implement it better in haskell and learn haskell that way

[21:57] <nothingmuch> the only problem is that I haven't done enough of this over the past 2 months

[21:57] <luqui> nothingmuch, do you grok monad transforms?

[21:57] <nothingmuch> luqui: nope

[21:57] <luqui> oh

[21:57] <nothingmuch> i know how to use ReaderT

[21:57] <luqui> well, that's a start

[21:58] <nothingmuch> i understand what it's purpose is, and what it does conceptually

[21:58] <luqui> I'm writing Monad.pm (for both perl 5 and perl 6)

[21:58] <nothingmuch> but I have no idea how the implementation actually works

[21:58] <nothingmuch> cutesy

[21:58] <luqui> autrijus suggested that I have Monad::Transform

[21:59] <leo__> luqui: nope doesn't (-I neither)

[21:59] <luqui> leo__, I know.  I just said that it *should*

[21:59] <luqui> you could try installing pugs

[21:59] <luqui> so it will look in the right place

[21:59] <leo__> oh, well compiling it

[22:00] <luqui> aha!

[22:00] <luqui> leo__, I've got it

[22:01] <luqui> export PERL6LIB=/home/whatever/pugs/blib6/lib

[22:01] <putter> oh, drat.  cant use dot ofcourse.  not with &-free subs.  sub bar{"bar"}  "foo".bar()    Back to -->.  and wishing p5 had been properly patched.

[22:02] <luqui> putter, I was suggesting that you treat /\.\w+/ as a method

[22:02] <luqui> and if they don't put space around the ., that's their fault

[22:03] <putter> sigh.  I suppose.  I hadnt appreciated the incompatibility before.  But I guess   use Dot;  would be ok.

[22:04] <nothingmuch> sleepy time

[22:04] <putter> use Dot; could also, instead of being p6-specific, fix the unblessed- and non- reference problem, treating them as ARRAY, etc, and then the p6 side of things could twiddle ARRAY.

[22:04] <nothingmuch> all employee meeting at 8 am

[22:04] <xinming> nothingmuch: good night.

[22:04] * nothingmuch hates time zones

[22:04] <putter> good nigh.

[22:04] <luqui> aginite

[22:04] <luqui> sleep wellish

[22:04] <putter> surely someone has already done a  use Dot  before... ??

[22:05] <luqui> (or welsh, whichever you prefer)

[22:05] <xinming> luqui: how the way, How long did @Larry write the "Apocalypse" for perl 6?

[22:05] <nothingmuch> if i sleep in welsh i won't understand anything

[22:05] <xinming> how long had @larry*

[22:05] <luqui> xinming, "the" apocalypse?

[22:06] <xinming> luqui: yes, I mean, the language design should be slowly gathered.

[22:06] <luqui> there are eight of them

[22:06] <xinming> luqui: only for perl 6?

[22:06] <xinming> ...

[22:07] <luqui> let's see, Apocalypse 1 was written 2 Apr 2001

[22:07] <luqui> And Apocalypse 12 was written 13 Apr 2004

[22:07] <luqui> so it seems about 3 years

[22:07] <nothingmuch> written or updated?

[22:07] <luqui> written

[22:08] <nothingmuch> oh right, we didn't start till feb of *this* year

[22:08] <xinming> luqui: I mean start writing the Apocalypse.

[22:08] <nothingmuch> anyway, mail done... *poof*!

[22:08] <luqui> probably around March 2001

[22:08] <luqui> where'd nothingmuch go?

[22:08] <luqui> I wish I could disappear

[22:08] <xinming> no wonder perl 6 succeed in the future. :-)

[22:09] <xinming> someone who learnt perl 5 for only 2 weeks, he said, Hi, You see, It's really convient to do something I like computer do. ;-)

[22:10] <xinming> luqui: hmm, I believe perl 6 will be easier to program, But harder to grasp the internal.

[22:10] <luqui> xinming, I hope the internals are easier to grasp, being written in perl 6 and all

[22:10] <luqui> xinming, but I think the underlying concepts will be a lot harder than perl 5

[22:10] <luqui> but we're trying to make it so that you don't have to learn those

[22:11] <putter> simon wrote an Acme::Dot, but it is "a class can provide ." rather a client can use it on everything.

[22:11] <xinming> luqui: hmm, I like to learn the internal rather than use it. :-)

[22:12] <xinming> luqui: If I don't wish to know the internal, I think Windows is really good except the blue screen.

[22:12] <xinming> luqui: But I don't know when I will know that. :'(

[22:12] <luqui> putter, interesting, and it seems he did it without source filters

[22:13] <putter> sure, just overload '""'...

[22:13] <putter> (at least that would be my guess... checking...)

[22:15] <putter> oooo, there is a use overload '.' !

[22:15] <xinming> luqui: by the way, theoretically, will perl 6 ( not compiled to byte code ) run faster than or equeal with perl 5?

[22:15] <gantrixx> OK, I have a question on a print statement.  Here is the print statement

[22:15] <gantrixx> print "3rd card is " ~ $deck.sequence[2].display() ~ " \n";

[22:15] <gantrixx> why does this result in the following output

[22:15] <gantrixx> 4c3rd card is 1

[22:16] <luqui> xinming, you can't really help but compile it to byte code

[22:16] <luqui> we're of course trying to make it run faster than perl 5

[22:16] <luqui> but if we can't, then we're giving you mechanisms (like the unboxed types) that you can use to write locally fast code

[22:16] <luqui> which is really all you need most of the time

[22:17] <luqui> gantrixx, woah, wtf

[22:17] <xinming> luqui: just like perl 6 a rule engine, pharse rules.

[22:17] <pdcawley_> gantrixx: Probably because display does it's own printing and returns true.

[22:17] <xinming> and compile the rule into byte code. :-)

[22:18] <luqui> pdcawley, ahh yes, that makes sense

[22:18] <gantrixx> why would it display the results of the display method before the "3rd card is" string?

[22:18] <luqui> because your statement is equvalent to:

[22:18] <Khisanth> because display executes first

[22:18] <pdcawley_> Because, obviously, it's evaluated before the print .

[22:18] <luqui> my $str = $deck.sequence[2].display;  print "3rd card is $str\n"

[22:19] <gantrixx> Oh, that makes sense

[22:19] <gantrixx> and where does the 1 come from?

[22:19] <luqui> the return value of print

[22:19] <gantrixx> display returns nothing

[22:19] <pdcawley_> Wrong.

[22:19] <Khisanth> subs always return something :)

[22:19] <pdcawley_> It returns whatever the last executed statement returns.

[22:19] <luqui> the return value of the print in display()

[22:19] <gantrixx> ok, well I don't have a return in the method

[22:20] <luqui> that doesn't mean it doesn't return anything :-)

[22:20] <luqui> sub foo() { "hello" }   say foo;   # hello

[22:20] * pdcawley_ should stop doing this. I'm in a foul mood, which is never a good mood to be in when doing tech support.

[22:20] <gantrixx> well it is annoying that it returns it to stdout

[22:20] <Khisanth> it doesn't

[22:20] <luqui> gantrixx, you should have display() return a string

[22:20] <luqui> not print it

[22:20] <Khisanth> you printed out the return value

[22:20] <gantrixx> Oh OK, I know then, I should have it return the string

[22:20] <putter> pdcawley_: do you have a feel for why calling methods on unblessed- and non- references continues to be prohibited?

[22:21] <xinming> my @ary; my @ary2 = ( 1, 2, 3, 4, 5, ); @ary = @ary2; 

[22:21] <pdcawley_> It is? So I can't write 10.as_roman?

[22:21] <putter> not in p5.

[22:21] <pdcawley_> Who cares?

[22:21] <xinming> in this example, will the values pass to @ary is a copy?

[22:22] <gantrixx> hmmm, maybe I can just say "return" and have it return nothing

[22:22] <luqui> xinming, if you change @ary, @ary2 will not be affected

[22:22] <xinming> luqui: So It's a copy. :-)

[22:22] <luqui> yeah

[22:22] <luqui> (just being clear)

[22:23] <QtPlatypus> But only to one leval.

[22:23] <pdcawley_> Yeah, shallow copy.

[22:23] <putter> if the p6-on-p5 backend emphasizes lightweight FFI, the lack causes pain and suffering yet again...

[22:23] <xinming> pdcawley: Do you mean "Copy on write" ? :-)

[22:23] <putter> for people using p5 that is.  perhaps that's correctly a "who cares?".

[22:24] <putter> ah well.

[22:24] <pdcawley_> @ary := @ary2 works if you want to alias 'em.

[22:24] <pdcawley_> FFI?

[22:24] <luqui> foreign function interface

[22:24] <luqui> as in libffi, but not for C

[22:26] <pdcawley_> ISTR writing something that would pretty much ensure that all unblessed reference types would autobless into ARRAY/HASH/WHATEVERs, but I can't, for the life of me, remember how I did it.

[22:26] <pdcawley_> I think evil was involved.

[22:28] <pdcawley_> with assitance from some of the hairier parts of overload.pm

[22:28] <putter> a p5 implemtation?!?  there have been patches floating around for years, but I dont recall seeing a pure p5 one...

[22:29] <pdcawley_>  I may be going mad. Or it may simply be that I worked out something that I thought should work, but didn't do it.

[22:29] <putter> ah, yes.  as long as you can source filter, you can use overload and a helper class to fake it.

[22:29] <theorbtw1> Doesn't autobox do that?

[22:29] <dduncan> quite by accident, my last commit was a nice round number, by computer or comp history terms

[22:29] <pdcawley_> I don't think it used a source filter.

[22:29] <putter> autobox?

[22:30] * putter goes to search for autobox...

[22:31] <leo__> ?eval use Set; "ok".say

[22:31] <evalbotzy> pugs: *** No compatible subroutine found: "&use"     at tmp-Prelude.pm line 38, column 30-59 

[22:31] <theorbtw1> http://search.cpan.org/~chocolate/autobox-1.03/

[22:31] <pdcawley_>  leo: That's not going to work on evalbot -- IO's generally frowned on.

[22:31] <svnbot6> r6399 | fglock++ | * perl5/ Value - added 'Lazy' and 'Eager' List roles

[22:31] <svnbot6> r6400 | Darren_Duncan++ | updated /LICENSE/GPL-2 so that it reflects the current address of the Free Software Foundation, as seen at http://www.fsf.org/ ; its whitespace was also cleaned up

[22:32] <putter> oooooo, autobox...  http://search.cpan.org/~chocolate/autobox-1.03/autobox.pm

[22:32] <luqui> theorbtw1++

[22:32] *** theorbtw1 is now known as theorbtwo

[22:32] *** theorbtwo is now known as theorbtw1

[22:32] <theorbtw1> theorbtwo++

[22:32] <pdcawley_> Bah. It still resorts to XS.

[22:32] <leo__> pdcawley_: the evalbotzy can't use any modules?

[22:32] <theorbtw1> theorbtw1--

[22:33] *** theorbtw1 is now known as theorbtwo

[22:33] <pdcawley_> leo: That does tend to follow. However, I'm not entirely sure of this. Ask whoever wrote it.

[22:34] <putter> theorbtw1++ theorbtw1++ theorbtw1++ Yay!

[22:34] <putter> pdcawley_: yes, but its all PASS on CPAN testers...

[22:35] <pdcawley_> That's gloriously evil...  a chap could rather like that...

[22:39] <putter> ok. so that takes care of that.  "when writing p5 code, remember p6 code may return an unblessed- or non- reference value.  and you dont have the p6 compiler hiding this from you.  so if you want to safely use -> everywhere, you need to use autobox."

[22:40] <putter> hows that?

[22:40] <svnbot6> r6401 | iblech++ | PIL2JS:

[22:40] <svnbot6> r6401 | iblech++ | * PIL::Subs: Slurpy hashes, thanks to xinming++ for reminding me that

[22:40] <svnbot6> r6401 | iblech++ |   *%slurpy_hashes exist :)

[22:40] <svnbot6> r6401 | iblech++ |   It uses the semantics of

[22:40] <svnbot6> r6401 | iblech++ |   http://www.nntp.perl.org/group/perl.perl6.language/22860, i.e.

[22:40] <svnbot6> r6401 | iblech++ |     sub foo (*%hash) {...}, foo(hash => {...});              # works

[22:40] <svnbot6> r6401 | iblech++ |     sub foo (*%hash) {...}, foo(hash => {...}, foo => bar);  # dies

[22:40] <svnbot6> r6401 | iblech++ | * PIL::Types, PIL::Params: Restored junction autothreading (was broken

[22:40] <svnbot6> r6401 | iblech++ |   in certain cases).

[22:41] <theorbtwo> Putter: Why would people expect the perl5 bit of perl5/6 code to act like perl6 code instead of perl5 code?

[22:44] <theorbtwo> Now, if perl5 code can pass an unblessed reference to perl6, and you can't call methods on it in perl6, that'd be a problem.

[22:44] <pdcawley_> Because being able to do $arbitrary_thing->isa(...) is just gleefully useful, whatever language you think you're in.

[22:45] <pdcawley_> Used to seriously piss me off, having check the blessedness of a reference before doing that.

[22:45] <theorbtwo> Eh, UNIVERSAL::isa($thing, 'class').

[22:45] <theorbtwo> The thing that always annoys me is that it's UNIVERSAL::isa, and not UNIVERSAL::ISA.

[22:45] <pdcawley_> Which is *so* bloody clunky in mostly OO code.

[22:46] <pdcawley_> And sucks satans balls if you need to override isa somewhere.

[22:46] <theorbtwo> I don't use isa much; I generally prefer to just die on errors.

[22:46] <theorbtwo> You're 100% right about needing to override isa, though.

[22:47] <pdcawley_> I had to use it in Pixie, at least until I worked out how to force objects to inherit behaviour from classes associated with their base types.

[22:47] <pdcawley_> Which is a whole other level of evil involving redefining bless and...

[22:47] <theorbtwo> Wow.

[22:48] <theorbtwo> That's some pretty hardcore evil.

[22:48] <pdcawley_> Well, you just look at the type of the object you're blessing, and, if the class you're blessing it into doesn't inherit from the implementation type, you stick the implementation type on said class's @ISA.

[22:48] <theorbtwo> ...and I've had occasion to want to JMP $scalar.

[22:48] <pdcawley_> Easy.

[22:49] <pdcawley_> The really cunning bit was when we added magic to allow you to store out of band information on an arbitrary  scalar.

[22:49] <theorbtwo> OK, really, to want to $functionpointer->(@arguments), where $functionpointer is a /C/ function pointer.

[22:49] <pdcawley_> Most importantly, any package needed to be able to do it to any scalar.

[22:49] <theorbtwo> Isn't that what attributes are for?

[22:50] <svnbot6> r6402 | Darren_Duncan++ | /ext/Locale-KeyedText : converted all of my indenting from tab characters to space characters, at 4 spaces per indent level; updated version to 1.6.0

[22:50] <svnbot6> r6403 | iblech++ | * PIL2JS: libjs/PIL2JS.js, pil2js.jspl: Fixed exit() not terminating the

[22:50] <svnbot6> r6403 | iblech++ |   program flow if it was used in a sub using PIL2JS.cps2normal.

[22:50] <svnbot6> r6403 | iblech++ | * New t/builtins/io/exit-in-if.t: wrote a test for that.

[22:50] <svnbot6> r6403 | iblech++ | * PIL2JS: PIL::PNil: Very minor cosmetic fix.

[22:50] <pdcawley_> Theorbtwo: At the time we wrote pixie, we didn't *have* attributes. Not that you could hang off *values* anyway.

[22:51] <pdcawley_> And you couldn't use hash keys, because it's not safe. And we wanted to be able to hang data off objects implemented using arbitrary references.

[22:51] <xinming> It's just plain cool, that's why.  Oh, and Perl 6 then magically

[22:51] <xinming> runs inside every vaguely recent web browser.

[22:51] <xinming> so, What does this exactly mean?

[22:51] <pdcawley_> Pixie does some evil, evil, evil stuff in order to look lovely to its users.

[22:51] <xinming> It's from docs/note/plan

[22:51] <pdcawley_> Catch is, the locking is broken as designed.

[22:51] <pdcawley_> And a complete bastard to fix.

[22:56] <dduncan> pdcawley_, a quick question ...

[22:56] <pdcawley_> Fire away.

[22:56] <dduncan> is pixie and SQL::Translator the same thing or different things?

[22:56] <pdcawley_> I don't know what SQL::Translator is.

[22:57] <dduncan> just a minute ...

[22:57] <pdcawley_> Definitely not the same thing.

[22:58] <dduncan> oops, pardon me, confused 'pixie' with 'sqlfairy'

[22:58] <pdcawley_> Pixie does object persistence in a single database table. There were plans afoot to allow for dedicated class tables with indexy things, but we never got that far.

[22:58] <dduncan> bad memory, bad@

[22:58] <dduncan> !

[22:58] <putter> theorbtwo: (long pause) I'm not sure.   The background is considering creating a very-low-overhead FFI version of a p5backend.  Which suggests allowing native types, rather than mutating or proxying them at border crossings.  Which lead to "what is the cost?".  And on the p5 site, one cost was losing the ability to do -> on everything.  Unfortunately, within the runtime implementation

[22:58] <pdcawley_> I hate writing schemas. We wanted a thing you could chuck pretty much any object at and it would Just Store It.

[22:58] <theorbtwo> Well, that seems like a benifit, not a cost: In perl5, stuff acts like perl5.

[22:58] <putter> autobox doesnt really help, because being XS, we will likely need to avoid it for portability.

[22:59] <pdcawley_> It didn't have queries, it didn't have all sorts of stuff, but it pretty much worked with everything, and the things it didn't work with you could write hooks for.

[22:59] <theorbtwo> Sounds lovely, pdc.

[22:59] <putter> yeah.  point taken.  though it would be nice in the p5 code which implements the runtime, if we could forget that unboxed types are a posibility.

[23:00] <pdcawley_> But it really, really sucks at concurrency.

[23:00] <theorbtwo> Databases annoy me -- my perl code ends being warped to be nice to the database.  I'd much rather have the database be warped to be nice to me.

[23:01] <theorbtwo> Hm, you could always box upon calling into the p6, but that'd be inefficent.

[23:01] <pdcawley_> Take a look at pixie. I should really take the time to write a design doc for a concurrency handling system that might actually *work*.

[23:01] <putter> pdcawley_: have you seen http://www.rubygarden.org/index.cgi/Libraries/og_tutorial.rdoc

[23:02] <pdcawley_> Not yet.

[23:02] <fglock_> putter: does PIL makes the unboxed/boxed conversion explicitly, or is it left to the runtime to do?

[23:03] <pdcawley_> Ruby really wins over perl if you're trying to write an object persistence thing because there's only one way of implementing an object, and there's all sorts of notification features built in.

[23:03] <putter> it would have to be a runtime thing.  so p5 code could use a module compiled by pugs and call methods without knowing/caring that they were p6-based.

[23:03] <theorbtwo> Well, there's already the argument unpacking code that you generate, no?

[23:04] <pdcawley_> And having Object be extensible really doesn't hurt in the slightest :)

[23:04] <putter> pdcawley_: true.  sometimes lots of ways to do something just means "I have to handle _how_ many cases?!"

[23:04] <pdcawley_> Indeed.

[23:05] <putter> Hopefully PIL as kernel language will help mitigate that.

[23:07] <pdcawley_> I just wrote a rather neat thing in Ruby for generating a composite from an XML tree. Most of the time, you're happy with a basic node type, but some things want to have custom behaviour. Initially I was writing an explicit thing for mapping from XML tags to classes, but they just looked like: 'TagName' => 'Node::TagName', which was tedious. But Ruby lets you notify a class when you subclass it, so I arranged things so that simply making 

[23:07] <fglock_> putter: sorry to insist on this, but how about: Int::add( 3, 4 ) - p5 code for saying 3.add(4)

[23:07] <leo__> pdcawley_: what is the $cookie from $pixie->insert

[23:08] <pdcawley_> leo__ it's the object id you use to get the object back.

[23:08] <pdcawley_> Opaque, so it's usually a good idea to insert named 'root' objects. It's been a while, so I can't remember all the methods.

[23:08] <leo__> valid in that very program only?

[23:08] <putter> fglock_, theorbtwo: I guess the argument goes, if you want to accept natives, then you either tolerate them internally or proxy them as they come in.  the main downside being proxies are notably slow.  but perhaps that's acceptable.

[23:08] <pdcawley_> leo: No, persistent.

[23:09] <pdcawley_> But generally based to use the 'name_object' (if memory serves) method for that sort of thing.

[23:09] <leo__> kind of a hash?

[23:09] <leo__> value

[23:09] <pdcawley_> In a web app, you'd save your session data say, and stick the OID in your session cookie.

[23:09] <leo__> ah ok

[23:10] <putter> fglock_: no sorry needed.  i'm thinking fuzzily.  it's almost like having a conversation in front of a whiteboard!  (wistful sigh)

[23:10] <pdcawley_> I think we just used UUIDs, guaranteed unique, opaque(ish) strings.

[23:12] <putter> fglock_: err, where?  I guess it doesnt matter.  yes, that should work.  Oh, you mean internally... and yes, that should work...

[23:12] * putter tries to figure out WHAT he has been thinking...

[23:13] <leo__> parrot's builtin '$S0 = freeze foo' should simplify these apps vastly

[23:14] <theorbtwo> Donno.  Will be helpful, but not much more then Storable.

[23:14] <theorbtwo> The problem is getting things into the database in a mildly sane manner.

[23:14] <putter> Oh, that call is fine if you know you have an Int.  But dispatching if there are natives is a pain.  (blessed($o) ?? $o->add(4) :: is_scalar_and_number($o) ?? Number::add($o,4) :: ...)

[23:15] <putter> err, s/::/:/  s/??/?/ 

[23:15] <leo__> theorbtwo: true

[23:17] <fglock_> but that would be a special case, and then you would use the slower dispatch( 'add', 3, 4 )

[23:17] <theorbtwo> fglock: But who is the "you"?

[23:17] <theorbtwo> The compiler can't know, and you don't want to force the user to write code like that.

[23:17] <gantrixx> wouldn't as a rule "best practices" practices sort of thing, be better to always reference your attributes, even if not inherited, as $self.attribute?

[23:18] <leo__> putter: parrot MMD handles that ;-)

[23:18] <putter> But regardless.  The next steps are the same regardless.  Get a metamodel out of pugs/perl5/ and its tests into t/ .  Probably Int->new(3) rather than Int->(unboxed=>3) to reduce FFI cost.  Then we can add overloads to the mm again reduce FFI cost.  And while

[23:19] <putter> this is going on, attempt to write the PIL compiler/evaluator/whatever which uses these objects.

[23:19] <putter> Oh, and using the mm, write the assorted runtime library primitives.

[23:20] * putter just which he didnt have a sneaking suspicion that the flexibility sacrificed by going minimal-FFI wasnt going to bite us later... ?)

[23:20] <putter> leo__: :)

[23:21] <putter> fglock_: all sounds plausible.  let's code. :)

[23:21] <leo__> this means that all optimizations at he 'upper' level are contraproductive

[23:21] <putter> steven: ping?

[23:22] <putter> fglock_: does the minimal-FFI thing of p5:  my $i = Int->new(3);  print $i+2; # 5  sound plausible?

[23:24] <fglock_> It might break in MM2, I think it will not export classes to p5 by default. But it can be fixed.

[23:24] <fglock_> I'd make the optimizations later.

[23:25] <putter> fglock_: ok.

[23:25] <fglock_> about $i+2, yes, we can overload Int to do that

[23:26] <fglock_> but overloading objects is even slower than accessing object methods, I think

[23:27] <putter> leo__: yes.  but the current puzzling was over the perl backend, rather than the parrot backend...  so were stuck with what perl can/cant do.

[23:27] <leo__> ah ok - sorry for the interruption

[23:28] <putter> fglock_: yes, it is.  oh well.  it hopefully wont harm the p6 side, and it will allow folks to easily use p6 in their p5 programs, so...

[23:30] <putter> leo__: oh, no problem.  just took me a while to think "hmm, maybe it _wasnt_ humor..." ;-)

[23:31] <fglock_> putter: actually people would use $i = Scalar->new(3) - that's a p6 scalar holding an unboxed value

[23:33] <putter> what's $i->ref ?

[23:33] <fglock_> that's the class $i belongs to

[23:33] <fglock_> like ref($i), but in p6 you get the Class object

[23:34] <putter> so in perl5,  print Scalar->new(3)->ref();  will say... 'Int'?

[23:35] <putter> 'int'?

[23:35] <fglock_> no, it says 'Scalar' when the content is untyped (but I'm not sure if this is correct)

[23:36] <putter> can one still say Int->new(3) when one really wants an Int?

[23:36] <fglock_> sure

[23:36] <putter> k

[23:37] <fglock_> $i = Scalar->new( Int->new(3) ) - a Scalar holding an Int

[23:37] <putter> Scalar->new(Int->new(3))->ref() # 'Int'   yes?

[23:37] <fglock_> yes

[23:37] <putter> k

[23:38] <putter> sounds like a plan

[23:40] <putter> I wonder how we handle the p5 and p6 namespaces.  Here it feels like they want to be unified, but that causes collisions.

[23:40] <putter> Maybe P6:: on the p5 side and P5:: on the p6 side?

[23:40] <fglock_> I should be using Perl6::Value::Int, but that's a lot to type

[23:41] <putter> (to get to the other one)  so  class P5::Foo {}  declares a p5 package Foo.

[23:42] <putter> Oh, yeah.  Can p5 use Frotz qw(Int Str); ?

[23:43] <putter> use Perl6::Easily qw(Int Str);

[23:43] <theorbtwo> If you're going to do that, make it Int(3) instead of Int->new(3).

[23:43] <fglock_> Perl6::Value::Int could export $Int so that you call $Int->new(3)

[23:43] <theorbtwo> (Though I suppose there's some int/Int confusion for some people.)

[23:44] <theorbtwo> Or it could just export &Int.

[23:44] <theorbtwo> Function call overhead is a lot lower then method call overhead.

[23:44] <fglock_> theorbtwo: looks like a good idea

[23:45] <theorbtwo> I'd still much rather the argument unpacker did it itself, though.

[23:46] <fglock_> theorbtwo: I think the idea is to not need an unpacker 

[23:47] <theorbtwo> Um, how can you not need an unpacker?

[23:48] <theorbtwo> What else lets you call sub foo(Int $a, Int $b) as foo({b=>12, a=>3}) ?

[23:50] * theorbtwo shrugs... it's bedtime.

[23:50] <fglock_> (just thinking aloud) the actual foo is a p6 Sub object. when you call p5 foo() you are calling a wrapper

[23:52] <fglock_> putter: do you think this make sense?

[23:56] * leo__ thinks that with current p6 design most of HLL interop doesn't work out of the box

[23:58] * fglock_ dinner time

