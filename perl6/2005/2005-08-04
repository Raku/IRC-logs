[00:00] <obra> brentdax: you're putting perl6 on cpan?

[00:00] <svnbot6> r6060 | iblech++ | docs/talks/Anatomie_eines_Compilers_am_Beispiel_von_Pugs.latex: Fix date.

[00:01] <brentdax> obra: Yes.

[00:01] <obra> That's an interesting predecent :)

[00:02] <brentdax> It needs to happen sooner or later.

[00:03] <obra> Yes, once pause knows how to understand perl6 dists.

[00:08] <brentdax> As far as PAUSE is concerned, this is basically a random tarball of files which includes a README, META.yml, a few other files, and a lot of *.pm files that don't seem to be Perl 5 modules.  I don't mind that situation.

[00:16] <stevan> iblechbot: re: Perl6.MetaModel

[00:16] <stevan> it is somewhat behind the Perl6-MetaModel

[00:17] <stevan> iblechbot: I am currently trying to factor out all circularity and Perl 5 magic from the P5 version

[00:17] <stevan> which is partially inspired by how the JS version did things 

[00:17] <stevan> so they will eventually converge

[00:31] <putter> sigh.  1hr+ cleaning up spam on the oz wiki.

[00:31] <putter> everyone knows about the perl6 curse, right?

[00:31] <QtPlatypus> putter: No

[00:32] <putter> "If you use perl6 to generate spam, great misforture will befall you in your life."

[00:32] <putter> It seems too late to pursuade folks of such a curse on p5, but with p6 we can start fresh.

[00:32] <putter> ;)

[00:33] <QtPlatypus> Apprently that Russian spammer who was beaten to death was thinking of using perl6.

[00:34] <putter> That's it!  Incontravertable proof! :)

[00:34] <QtPlatypus> If just thinking about it is that deadly, immaginin what fate will befell you if you accully spam.

[00:35] <putter> Oh, the horrors.  They hardly bare thinking on.

[00:37] <putter> There is a story pattern, from some part of the planet which escapes me at the moment, that basically goes <minor topical thing goes wrong> <rapidly escalating chain of concequences> <"Everybody dies">.

[00:37] <Di42lo> pugs eq perl6 eq parrot or what ?

[00:38] <scrottie> Pugs is a Perl 6; Parrot is a Perl 6 (approximately...)

[00:38] <putter> (pugs -lim-> perl6) > parrot

[00:39] <Di42lo> whats -lim ?

[00:39] <QtPlatypus> Limit

[00:40] <Di42lo> anyways...is anyone gonna use thie language ?

[00:40] <Di42lo> i dont see people use it

[00:40] * QtPlatypus uses it, expermenally.

[00:40] <putter> p6 is the language spec; pugs is a rapidly developing but still partial implementation of it; parrot is a vm, one backend of pugs, and perhaps to be the reference implementation of p6.

[00:41] <wolverian> Di42lo, as putter said, there is no complete implementation of it, yet. 

[00:41] <Di42lo> say there is complete implementation of it...will people use it ?

[00:41] <Di42lo> in your opinion

[00:41] <wolverian> in my opinion? yes.

[00:41] <putter> Di42lo: it didn't exist at all at the beginning of February.  now much exists, but no-one things its currently ready for production use.

[00:41] <Di42lo> it should be the next generation of perl ?

[00:41] <putter> s/things/thinks/

[00:42] <wolverian> I wouldn't mind if it was called something else than perl - but yes, it is certainly the next generation of perl.

[00:42] <wolverian> (grok that!)

[00:43] <Di42lo> the gonna change everything in this perl6 ?

[00:43] <Di42lo> s/the/they/

[00:43] <Di42lo> i mean ...the syntax

[00:43] <Di42lo> and the modules

[00:43] <Di42lo> etc..

[00:43] <wolverian> it is not backwards compatible. it is not completely different. perl5 will run on parrot, as well. perl6 code will be able to use perl5 libraries, and vice versa.

[00:45] <putter> most p5 is still valid p6, with minor changes.  p6 is largely a superset, but some p5 things have been altered, usually superficially, to keep it all manageable.

[00:45] <Di42lo> and when it gonna be out ?

[00:45] <dudley> Christmas.

[00:45] <scrottie> Di42lo: do you program in Perl 5?

[00:46] <QtPlatypus> Before christmas

[00:46] <wolverian> when it is done. :)

[00:46] <putter> to which the cannonical question is "Which Christmass?"  and the answer is "Dont know yet!".

[00:46] <scrottie> long before it's done >=)

[00:46] <Di42lo> scrottie: yes i do

[00:47] <Di42lo> okay...i guess then cya in christnas :D

[00:49] <putter> Currently, I get frustrated at about ~1k lines of code.  On that scale, I hit problematic bugs.  I expect before the end of the year, I personally will be using p6 for real but non-mission-critical projects.

[00:49] <scrottie> I can't just start using Perl 6. I have to go cold turkey and stop using Perl 5 first.

[00:50] <putter> Why?

[00:50] <scrottie> Ever watch a PHP programmer try to learn Perl? About every five minutes they get frustrated, shout "but I know how to do it in PHP!" and march off.

[00:51] <scrottie> Problem is, I know "how to do it" in Perl 5.

[00:51] <putter> Ah.  Well, that's what we need  "use PHP; ... no PHP;" for... :)

[00:51] <scrottie> heh

[00:51] <scrottie> Too old to learn new languages. Trying to force myself to learn Haskell. Distraction sure is easy to find sometimes.

[00:53] * putter twiddles thumbs, whistles, and looks at something reeeaally interesting in the corner.  "pugs a distraction?  from a job search?  who me?"

[00:54] <scrottie> If I'm ever forced to get a real job, I'm starting a commune so that no other free software programmer must befall the same fate.

[00:54] * QtPlatypus llooks equilly guilty

[00:54] * wolverian follows suiit

[00:54] <wolverian> er, one i less.

[00:55] <putter> Aside from full bore  use OtherLanguage;, I hope we'll be able to also do  use OtherishArrays;, which lexically makes, in this case, Array objects look like they have methods which behave consistently with what one expects in Other.

[00:56] <scrottie> I mentioned that to The Conway once, and he gave me this disguested, contemptious scowl.

[00:56] <putter> That's the other half of having domain specific languages... the objects participate.

[00:56] <scrottie> er, The Damian.

[00:57] * scrottie coughs

[00:58] <putter> Tough.  You just can't scale nicely without it.  And with p6, I can't be stopped...  uuahhhhhahahaha.

[00:59] * putter wonders what depths of linguistic and engineering insanity are going to be plumbed on p6...

[01:01] <putter> That reminds me, I was going to write a ClassNameFromPath() macro, because I'm tired of having to both move a file and edit it every time I change a package/class name.  Moving should be enough.

[01:01] <putter> package ClassNameFromPath(); ...  or  class ClassNameFromPath()::Foo { ... }

[01:02] <putter> Pity pods dont(?) have an interpolation mechanism.

[01:04] <putter> Perhaps pods need a { <perlcode> } interpolation phrase, so you can Filter::Simple your pod text.

[01:04] <scrottie> have Makefile.PL template out the POD into its own file.

[01:06] <putter> or define pod as a simple language operating on a simple dom, with the option of embedded p5/6 direct manipulation of the dom.

[01:07] * scrottie scowels

[01:08] <putter> Tcl has the nice capability to create a single executable file, with a read-writable filesystem overlay and databases inside.  I tend to think of doing things with fewer files, rarther than more.

[01:09] <putter> Note that that's a stand-alone executable - no site installation required.

[01:10] <putter> plpyrb just can't do stuff like that yet.

[01:10] <scrottie> That *is* nice. The Damian has a Inline::Files, but I'm not sure how that would work on databases, or anything complex

[01:10] <scrottie> And doubtful it works if you generate a binary

[01:11] <putter> It's interesting how each language community picks a different set of things to focus on, and then with self-selection, wanders off in its own direction.

[01:12] <shapr> There's a nice meta-community though.

[01:13] <mugwump> Isn't PAR like that, putter ?

[01:13] <putter> Sometimes.  The prolog folks for instance, still, after wha, 20+ years, still cant agree on such challenging questions as, what shall we call chdir()?

[01:13] <scrottie> PARs extract themselves.

[01:14] <scrottie> heh

[01:14] <putter> PAR?  putter goes off to google...

[01:14] <scrottie> Perl ARchive

[01:16] <putter> Ah, neat!  Yes, though it's not clear pars are easily self modifiable.

[01:17] <putter> tnx mugwump

[01:31] <putter> Hmm... env PUGS_BUILD_OPTS=precompile_prelude=false make  gives me a pugs, but without the Prelude.  But perhaps my first interrupting the Prelude/Run compilation broke something.

[01:36] *** jiing_ is now known as jiing

[01:59] <putter> Hmm, and ./pugs -Isrc/perl6 -MPrelude doesnt do it...

[02:08] <autrijus> putter: .par being .zip files can't modify themselves.

[02:08] <autrijus> but .exe built using pp can easily self modify.

[02:09] <autrijus> lathos shipped a standalone httpd, firefox, database and a maybole app as a single .exe a while ago.

[02:14] <putter> :)  are there details somewhere (you can trivially find)?

[02:14] <svnbot6> r6061 | putter++ | Pugs::Internals::rule_pattern and rule_adverbs now work on all VRules (thay hadn't on PCRE VRules).

[02:15] <autrijus> yes, the par documentation, also "perldoc par.pl"

[02:16] <autrijus> also the PAR tutorial.

[02:16] <putter> thank you.

[02:16] <autrijus> no problem. :)

[02:22] <autrijus> $work &

[02:23] <autrijus> iblech: if you are backlogging, PIL2 will gen code for class Foo exactly the same way as for sub Bar; namely anonymous class construction at BEGIN time, then bind to symbol table.

[02:24] <putter> hmm... did :g ever work on PGE or PCRE?  (doesnt seem to currently)

[02:24] <putter> autrijus &

[02:25] <QtPlatypus> putter: I've never seen it working.

[02:27] <autrijus> ?eval "aaa" ~~ m:P5<g>/(.)/

[02:27] <evalbot6> 3 

[02:28] <autrijus> ?eval "aaa" ~~ m:P5:g/(.)/

[02:28] <evalbot6> 3 

[02:28] <autrijus> ?eval join ',',  "aaa" ~~ m:P5:g/(.)/

[02:28] <evalbot6> 'a,a,a' 

[02:28] <autrijus> looks not exactly wrong

[02:30] <putter> ?eval my @a = ("aa" ~~ m:perl5:g/a/); @a

[02:30] <evalbot6> [] 

[02:31] <putter> Ok, so PCRE side should work, though something I don't understand is happening with my tests.  PGE-side clearly drops the flag, but that doesnt matter yet because PGE is still ignoring :i.

[02:32] <putter> ?eval my @a = ("aa" ~~ m:perl5:g/(a)/); @a

[02:32] <evalbot6> [MkMatch {matchOk = True, matchFrom = 0, matchTo = 1, matchStr = "a", matchSubPos = [], matchSubNamed = {}}, MkMatch {matchOk = True, matchFrom = 0, matchTo = 1, matchStr = "a", matchSubPos = [], matchSubNamed = {}}] 

[02:33] <beckheng> POE你们在cygwin下安装过吗?

[02:33] <putter> ?eval my @a = ("abab" ~~ m:perl5:g/(a(b))/); @a

[02:33] <evalbot6> [MkMatch {matchOk = True, matchFrom = 0, matchTo = 2, matchStr = "ab", matchSubPos = [], matchSubNamed = {}}, MkMatch {matchOk = True, matchFrom = 1, matchTo = 2, matchStr = "b", matchSubPos = [], matchSubNamed = {}}, MkMatch {matchOk = True, matchFrom = 0, matchTo = 2, matchStr = "ab", matchSubPos = [], matchSubNamed = {}}, MkMatch {matchOk = True, matchFrom = 1, matchTo = 2, matchStr = "b", matchSubPos = [], matchSubNamed = {}}] 

[02:33] <beckheng> sorry.

[02:34] <autrijus> beckheng: hey, #perlchina is the zh-cn language channel :)

[02:34] <autrijus> (and no, I havn't installed POE under cygwin.)

[02:35] <beckheng> autrijus: irc newbie. :(

[02:36] * f0rth is new, too

[02:37] <putter> sigh.  so in p5, /aa/ behaves like rx:p5/(aa)/ but /a(a)/ behaves like rx:p5/a(a)/ and not /(a(a))/  :(

[02:38] *** beckheng_ is now known as beckheng

[02:38] <putter> err, all with g's.

[02:38] <autrijus> putter: I think that's a simple bug in pcre handling code in Prim -- fixes welcome, I really gotta run.

[02:39] <putter> go go go! :) &

[02:39] <autrijus> Prim.Match line 234.

[02:40] <putter> got it.  go! :)

[02:57] *** beckheng_ is now known as beckheng

[03:12] <dudley> gaal: ping

[03:38] *** beckheng_ is now known as beckheng

[03:40] *** beckheng_ is now known as beckheng

[03:43] <autrijus> rehi

[03:44] * scrottie waves hi

[03:47] <autrijus> :)

[03:58] <brentdax> Would it be appropriate to send the WWW::Kontent announcement message to perl6-announce?

[04:00] <brentdax> (Or one of the other perl6-* lists, for that matter.)

[04:01] <dudley> I would think so. perl6-announce could use a little more traffic :-)

[04:02] <autrijus> yes :)

[04:02] <autrijus> brentdax: go for it

[04:02] <brentdax> Is it even possible to send to p6-a?  lists.perl.org says it's a read-only list.

[04:04] <autrijus> I assume that it means that ask gets to moderate it.

[04:04] <autrijus> feel free to cc p6[cl] on your first announcement as well :)

[04:04] <brentdax> Alright.

[04:06] <svnbot6> r6062 | Stevan++ | Perl6::MetaModel - 

[04:06] <svnbot6> r6062 | Stevan++ | * converting method object to single closure factory to create

[04:06] <svnbot6> r6062 | Stevan++ |   the different kind of method types

[04:06] <svnbot6> r6062 | Stevan++ |    - everything done except SubMethods need to work out the force_call() issues

[04:06] <svnbot6> r6062 | Stevan++ | * removed all deprecated ::Method files

[04:11] <putter> Hint request:  How can I get a Val from a VMatch?

[04:13] <brentdax> Okay, sent.

[04:26] <pasteling> "putter" at 66.30.119.55 pasted "VList [match] isnt quite right" (21 lines, 712B) at http://sial.org/pbot/12216

[04:27] <putter> any thoughts before I call it a night would be appreciated...

[04:32] <scrottie> here's a thought: stay awake a little bit longer ;)

[04:40] <putter> ;)

[04:41] <putter> good night all. &

[04:47] <autrijus> hi Darren_D1ncan.

[04:48] <Darren_D1ncan> hi Autrijus

[04:48] <Darren_D1ncan> my lightning talk is tomorrow

[04:48] <autrijus> good luck :)

[05:01] <xinming> where to download the whole Synopsis in a package please?

[05:04] <xinming>  class MyStruct is rw {...}. so anyone here can tell me what "is rw" mean here? for a variable, I know. What about for the class definition?

[05:05] <autrijus> xinming: it means that `is rw` is applied to all member variables.

[05:05] <autrijus> it's just a shorthand

[05:07] <Darren_D1ncan> will do ... fyi, the building may close shortly ... if I go offline, don't worry, I should be back 10-15 mins later

[05:07] <Darren_D1ncan> if I'm not, then worry

[05:08] <Darren_D1ncan> er sorry, I wrote this in the wrong IRC window

[05:09] <ayrnieu> We'll still worry about you.

[05:09] <xinming> autrijus: thanks

[05:10] <autrijus> np :)

[05:11] <xinming> hmm. I think if the after synopsis is finished. the perl 6 is "actually" out. 

[05:11] <dudley> aren't member variables rw by default?

[05:11] <brentdax> No, they're ro by default.

[05:11] * dudley needs to reread some synopses...

[05:11] <brentdax> (The ro/rw distinction only applies to the accessors.)

[05:12] <brentdax> xinming: Take a look at Perl6::Bible.

[05:14] <xinming> brentdax: thanks.

[06:00] <gaal> dudley, pong

[06:17] <dudley> gaal: Just wanted to let you know that install_dir in config.yml installs the perl5 stuff in the right place, but the perl6 stuff goes wherever your perl5 install is.

[06:17] <gaal> eek

[06:18] <gaal> Aankhen``, ping

[06:18] <dudley> I think passing PREFIX=whatever to Makefile.PL does the same thing

[06:18] <gaal> that was his patch

[06:18] <gaal> IIRC

[06:27] *** beckheng___ is now known as beckheng

[07:06] * nothingmuch will demo pugs in August Penguin 4 soon.

[07:06] <nothingmuch> any special requests?

[07:10] <castaway_> a song?

[07:10] *** castaway_ is now known as castaway

[07:16] <nothingmuch> uh, sure, why not

[09:43] <gaal> Aankhen``, ping

[09:44] <Aankhen``> Hi.

[09:44] <gaal> hey :)

[09:45] <Aankhen``> What's up?

[09:45] <gaal> dudley reports some borkage with install_prefix

[09:45] <Aankhen``> install_dir, you mean?

[09:45] <gaal> er, yes, sorry

[09:45] <Aankhen``> OK.  What's the borkage?

[09:45] <gaal> can you look into that? he says the perl6 stuff gets installed to the same place as p5 stuff

[09:46] <Aankhen``> No way!

[09:46] <Aankhen``> What OS is he on?

[09:46] <gaal> dudley, about?

[09:46] <Aankhen``> Oh $#@!.

[09:46] <Aankhen``> It worked fine for me when I tried it. -_-

[09:46] <Aankhen``> And I don't understand why /anything/ would be installed under anything except the PREFIX dir.

[09:47] <gaal> it is under prefix

[09:47] <Aankhen``> So he set the install_dir to the same thing as his Perl installation? :-S

[09:47] <gaal> but w/o differentiation between p5 and p6 parts (i think)

[09:50] <gaal> my fever is getting worse, i kinda can't debug anything right now :/

[09:50] <Aankhen``> Awww. :-(

[09:50] <Aankhen``> Better rest.

[09:51] <gaal> yeah, started taking antibiotics today. this is, as they say, teh suck.

[09:52] <Aankhen``> Hmmm.

[09:52] <Aankhen``> Could you add a line to INSTALL warning that if install_dir is specified in config.yml, /everything/ will be installed under that directory?

[09:53] <gaal> sure

[09:53] <Aankhen``> (and so, if you specify your Perl directory, files in there may be overwritten)

[09:53] <Aankhen``> Thanks.

[09:53] <Aankhen``> My SVK is still b0rked.

[09:53] <gaal> ok

[09:54] * castaway mumbles something about openfoundry and opera

[09:54] <gaal> is the NOTE about PREFIX in INSTALL yours?

[09:54] <Aankhen``> No.

[09:54] <Aankhen``> Hrm, I think that was dudley.

[09:55] <gaal> svn praise confirms.

[09:55] <gaal> okay, i'll add the warning. please be on the lookout for him and investigate this together?

[09:56] <Aankhen``> A'right.

[09:56] <gaal> thanks!

[10:00] <Aankh|Clone> In the Makefile, I can't find anything that installs anywhere except under my Perl directory (this is without using PREFIX).

[10:02] <gaal> added; bbl &

[10:06] <svnbot6> r6063 | gaal++ | warnings about PREFIX and install_dir until issues are fully understood.

[10:07] <Aankh|Clone> I have to go shower, BBIAB.

[10:08] <clkao> Aankhen``: what went wrong with your svk?

[10:55] <Aankhen``> clkao: The Perl bindings for Subversion on my computer appear to be b0rked, so SVK is b0rked as a result.

[10:55] <Aankhen``> I keep getting a message about `set_path` not being a method of SVN::Ra.

[10:55] <Aankhen``> # whenever I run `svk sync`

[11:03] <clkao> Aankhen``: win32? i got the same report. bad package builder

[11:03] <Aankhen``> Yes.

[11:03] <Aankhen``> Package builder?

[11:08] <Aankhen``> clkao: Is there any way to fix it?

[11:17] <clkao> Aankhen``: er, rollback to older version of svn ?

[11:17] <Aankhen``> SVN, not SVK?

[11:17] <clkao> yes, it's svn/perl problem. provided by the svn package

[11:17] <Aankhen``> Alright.

[11:31] <Aankhen``> Doesn't seem to help. :-\

[11:32] <clkao> (!)

[11:33] <clkao> if you kill the svn and back to the svk1.0 win32 binary ?

[11:34] <Aankhen``> That'd probably work... I was hoping to be use 1.02, though.  I had the 1.00 binary earlier, which was working fine.

[11:37] <Aankhen``> s/be use/use/

[11:38] <clkao> find matthewd on #svk and see if he can make a new win32 binary?

[11:38] <Aankhen``> OK.

[11:38] <Aankhen``> Thanks for the help. :-)

[11:43] <meppl> @blubb.end  and  @blubb[-1]   dont seems to work.     is there still anything prefab to find out the last peace of an array?

[11:44] <Aankhen``> Last peace? :-S

[11:47] <Aankhen``> Oboy, nearly a hundred revisions to sync.

[11:47] <Aankhen``> clkao++

[11:49] <meppl> last array-index

[11:49] <Aankhen``> Ah.

[11:50] <Aankhen``> Dunno of anything prefab; what about `@blubb[@blubb - 1]`?

[11:51] <notThis> Hi. Can anyone give me the url of the subversion repository that includes the official perl6 docs (synopses etc)?

[11:56] <svnbot6> r6064 | Aankhen++ |  r6092@tef-base:  Aankhen | 2005-08-04 17:24:18 +051800

[11:56] <svnbot6> r6064 | Aankhen++ |  * Prelude: added explicit invocants for IO, Iter methods.

[11:56] <notThis> Nevermind, I found it: http://svn.perl.org/perl6/doc/trunk

[12:00] <meppl> aankhen, it returns always nothing

[12:00] <meppl> not like perl5

[12:06] <Aankhen``> How so?

[12:06] <Aankhen``> pugs> my @foo = (1, 2, 3, 4); @foo[@foo - 1]

[12:06] <Aankhen``> 4

[12:22] <autrijus> rehi!

[12:23] *** autrijus changes topic to: Pugs 6.2.9 released | pugscode.org | pugs.kwiki.org | paste: http://sial.org/pbot/perl6 | www.geeksunite.net

[12:24] <Aankhen``> Hi autrijus. :-)

[12:24] <autrijus> hey. how's life?

[12:24] * autrijus is back from $work and into another typhoon

[12:24] <Aankhen``> Pleasant.

[12:24] <Aankhen``> It's raining outside, so it's cool.

[12:24] <autrijus> yup

[12:25] <Aankhen``> And clkao suggested I rollback SVK to 1.00 for now, so I did, and now it's working.

[12:26] <autrijus> cool.

[12:26] <Aankhen``> And I just finished listening to Reanimation.

[12:27] <autrijus> looks interesting.

[12:28] <Aankhen``> Oh, cool, I just understood what svn:keywords is for.

[12:53] <svnbot6> r6065 | iblech++ | * Perl6::Pugs: Grammar fix.

[12:53] <svnbot6> r6065 | iblech++ | * util/livecd/mklivecd.pl: Adjust default initrd size again.

[12:53] <svnbot6> r6065 | iblech++ | * PIL2JS: PIL::Parser: Unbreak parsing of escaped strings (e.g. \n, \\, etc.).

[13:29] <meppl> aankhen, sorry, i had some problems with my router.   did you say something to me apart from @blubb[@blubb -1]?

[13:29] <Aankhen``> [17:30:33] <meppl> not like perl5

[13:29] <Aankhen``> [17:30:40] * kolibrie (~kolibrie@cworth.org) has joined #perl6

[13:29] <Aankhen``> [17:36:18] <Aankhen``> How so?

[13:29] <Aankhen``> [17:36:18] <Aankhen``> pugs> my @foo = (1, 2, 3, 4); @foo[@foo - 1]

[13:29] <Aankhen``> [17:36:18] <Aankhen``> 4

[13:29] <meppl> +1

[13:30] <autrijus> ?eval my @foo = (1..4); @foo[@foo.end]

[13:30] <evalbot6> \4 

[13:30] <Aankhen``> meppl: You sure you don't have an outdated Pugs?

[13:34] <wolverian> ?eval ("a".."c").end

[13:34] <evalbot6> 2 

[13:34] <svnbot6> r6066 | iblech++ | PIL2JS: Infrastructural support for Perl6.MetaModel.

[13:34] <svnbot6> r6066 | iblech++ |   * PIL2JS.pm: The --pugs option wasn't properly honoured, fixed.

[13:34] <svnbot6> r6066 | iblech++ |   * PIL2JS.js: Die if the MetaModel wasn't loaded.

[13:34] <svnbot6> r6066 | iblech++ |   * pil2js.pl: Support linking the MetaModel in.

[13:34] <svnbot6> r6066 | iblech++ |   * jspugs.pl, README: Add option to set the path to the MetaModel.

[13:34] <svnbot6> r6066 | iblech++ |   * PIL: Very minor cosmetic fix.

[13:34] <wolverian> hmm. is there a .last, or so, to get the element directly? :) because [-1] is so hard to type...

[13:35] <autrijus> whoa, the metamodel is in for js?

[13:35] <autrijus> wolverian: sadly &last is taken to mean loop control

[13:36] <autrijus> ?eval multi last (@x) { @x[-1] }; (1..4).last

[13:36] <evalbot6> \4 

[13:36] <wolverian> hmm, good point. wouldn't be good to overload the meaning.

[13:36] <autrijus> there you go

[13:36] <wolverian> s,meaning,word,

[13:36] <wolverian> thanks :)

[13:36] <autrijus> :)

[13:37] <Limbic_Region> s/last/end/

[13:38] <Limbic_Region> @array.end in p6 == $#array in p5

[13:38] <Limbic_Region> which with autoderefing makes $aref.end so much nicer than $#$aref

[13:40] <Limbic_Region> ?eval (1..4).end

[13:40] <evalbot6> 3 

[13:40] <Limbic_Region> which is obviously not the last element - duh

[13:40] <autrijus> right :)

[13:41] * Limbic_Region crawls back under a rock

[13:46] <svnbot6> r6067 | scook0++ | * Initial stab at some Haddock docs for Parser.hs

[13:46] <svnbot6> r6067 | scook0++ | * Formatted CodeGen.hs' poem for Haddock :-)

[13:46] <svnbot6> r6068 | fglock++ | * documentation updates

[13:46] <meppl> so

[13:47] <meppl> it does not work with attributes which i gave no value

[13:47] <meppl> but thats correct?

[13:47] <meppl> (class-attributes)

[13:51] <meppl> # pugs -e 'class La {has int @.s;  method la() {say @.s.end;}}; La.la'

[13:51] <meppl> *** No compatible subroutine found: "&end"

[13:51] <meppl>     at -e line 1, column 42-49

[13:51] <meppl>        -e line 1, column 54-59

[13:52] <cognominal_> ?eval  $_ = "toto"  s/.*/if (1) { 2 } else { 3}/e; print

[13:52] <evalbot6> Error:  unexpected "s" expecting operator, ">>=><<", "\187=>\171", "=>", "::=", "**=", "xx=", "||=", "&&=", "//=", "^^=", "+&=", "+|=", "+^=", "~&=", "~|=", "~^=", "?|=", "?^=", ":=", "~=", "+=", "-=", "*=", "/=", "%=", "x=", "Y=", "\165=", "|=", "^=", "&=", "=", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[13:53] <cognominal_> oops

[13:53] <cognominal_> ?eval  $_ = "toto";  s/.*/if (1) { 2 } else { 3}/e; print

[13:53] <evalbot6> Error:  unexpected "e" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[13:54] <cognominal_> hum, I am not sure how to specify a perl5 s///

[13:54] <wolverian> s:Perl5///

[13:57] <cognominal_> I was wondering if "if() {} else {}" would still act as an expression (ie returning a value unlike a C statement)

[13:58] <wolverian> the perl6 way to do that is: s/foo/{ if 1 { 2 } else { 3 } }/

[13:58] <wolverian> { }s interpolate as code in regexes and strings automatically

[13:58] <wolverian> (the s there is a plural marker, not a perl flag :)

[13:59] <wolverian> as a block returns the last expression evaluted in it, foo is replaced by either 2 or 3

[14:02] <meppl> # pugs -e 'class La {has int @.s;  method la() {@.s = (); say @.s.end;}}; La.la'

[14:02] <meppl> -1

[14:02] <wolverian> ?eval @foo.end

[14:03] <evalbot6> Error: Undeclared variable: "@foo" 

[14:03] <wolverian> ?eval my @foo; @foo.end

[14:03] <evalbot6> -1 

[14:03] <wolverian> right. should work with 'has' too

[14:03] <wolverian> (I think. :)

[14:05] <meppl> ?class La {has int @.s;  method la() {say @.s.end;}}; La.la

[14:05] <meppl> aeh

[14:05] <meppl> whatever

[14:05] <meppl> meppl # pugs -e 'class La {has int @.s;  method la() {say @.s.end;}}; La.la'

[14:05] <meppl> meppl *** No compatible subroutine found: "&end"

[14:05] <meppl> eval

[14:06] <autrijus> ok, ok, I'll import the metamodel :)

[14:08] * autrijus proceeds to do so

[14:08] <svnbot6> r6069 | iblech++ | * PIL2JS: pil2js.pl: Fix Perl6.* module loading.

[14:08] <svnbot6> r6069 | iblech++ | * Perl6.MetaModel: Perl6.Class, Perl6.Object, Perl6.MetaModel, Perl6.MetaClass:

[14:08] <svnbot6> r6069 | iblech++ |   Added if(Perl6.ModuleToBeLoaded == undefined) guards around require()s.

[14:08] <svnbot6> r6069 | iblech++ |   This is because require() uses document.write("<SCRIPT..."), which of course

[14:08] <svnbot6> r6069 | iblech++ |   doesn't work when running under Spidermonkey's bin/js.

[14:08] <svnbot6> r6069 | iblech++ |   All Perl6.MetaModel tests still pass; additionally ./runjs.pl -e 'say "Hi"'

[14:08] <svnbot6> r6069 | iblech++ |   loads the MetaModel now (but doesn't use it yet).

[14:08] <meppl> :-P

[14:09] <stevan> iblechbot: feel free to remove the "require()" stuff in the metamodel

[14:09] <stevan> it was mostly for my testing convience

[14:10] <autrijus> stevan: so, anything I should watch out before importing?

[14:10] <autrijus> or are you not_quite_done yet? :)

[14:10] <stevan> autrijus: I will never be "done" :)

[14:10] <autrijus> okay then :)

[14:10] <stevan> and to be honest, it would be helpful to have other people looking/working on it

[14:11] <autrijus> noted

[14:11] <stevan> it helps me be sure I am on the right path

[14:11] <autrijus> the mmd is only hinted at 80_code, right?

[14:11] <stevan> autrijus: yes, and Lukes Class::MultiMethods::Pure actually finished that thought too

[14:12] <autrijus> very well :)

[14:12] <autrijus> you think luqui's approach is sound? if yes I'll look into importing it too

[14:12] <stevan> I have to do some source diving on it, I only skimmed the docs 

[14:13] <stevan> I think luqui's approach is an attempt to prove to Damian that luquis approach works :)

[14:16] <LordNlkon> http://sial.org/pbot/12233

[14:16] <LordNlkon> Can somebody help me ?

[14:28] <stevan> LordNlkon: you might have better luck on #perl

[14:28] <stevan> this is for Perl 6

[14:29] * castaway notes the sneaky use of "might" there

[14:31] <LordNlkon> i know

[14:31] <LordNlkon> i just found a way to resolve it

[14:31] <LordNlkon> :P

[14:31] <LordNlkon> needed an module for LWP

[14:32] <LordNlkon> thx anyway

[14:48] <stevan> autrijus: Class::MultiMethods::Pure seems logical, but to be honest, some of this stuff goes over my head

[14:49] <autrijus> nodnod.

[14:49] <autrijus> I'll deal

[14:49] <stevan> ok, I will be around for the next 8 hours or so if you have any questions :)

[15:02] <stevan> autrijus: it might make it easier to port things if you do not try to bootstrap it initially

[15:02] <svnbot6> r6070 | autrijus++ | * symbol formalism.

[15:02] <stevan> see: JS and Java versions

[15:03] <stevan> both are based on the perl versions 

[15:03] <stevan> and so theoretically can end up being bootstrapped

[15:07] <stevan> iblech: we can remove the namespace hacks in the JS metamodel too

[15:13] <svnbot6> r6071 | autrijus++ | * snapshot checkin of PIL.hs before importing metamodel.

[15:18] <autrijus> stevan: ok. some very meta questions

[15:19] <stevan> autrijus: fire away

[15:19] <stevan> I will try to give very meta-answers

[15:20] <autrijus> I'm coming from the haskell side, so lots of purity related issues first

[15:20] * stevan really wishes he had starting documenting this stuff earlier

[15:20] <autrijus> I understand that the attributes themselves are mutable cells.

[15:20] <stevan> how do you mean attributes?

[15:20] <stevan> instnace attributes?

[15:20] <autrijus> yes.

[15:21] <stevan> yes

[15:21] <stevan> the metaclass holds attribute definitions

[15:21] <autrijus> also, there is an "environment"

[15:21] <stevan> hola iblech :) you are just in time for the meta-discussion 

[15:21] <autrijus> that is also mutable

[15:21] <autrijus> for example by _apply_class_to_environment

[15:21] <autrijus> are there other mutable cells in this game?

[15:21] <stevan> yes, but this is to allow for perl5 sugar

[15:22] <stevan> it could likely be removed

[15:23] <stevan> however an "object environment" which supports class lookup by name is not a bad idea

[15:23] * stevan is pondering the "other mutable cells" question

[15:24] <stevan> autrijus: I dont think there are any other mutable cells

[15:24] <stevan> however this is conditional on the bootstrapping

[15:24] <autrijus> ok. so persumably all the pop/shift/etc can be gather/take'ized

[15:24] <autrijus> since they are lexical in nature

[15:24] <stevan> because the metaclass is just an instance like what is created by Perl6::Object->bless

[15:24] <autrijus> yes I understand :)

[15:24] <autrijus> what do you think about bootstrapping the environment?

[15:25] <autrijus> that is, the package space.

[15:25] <stevan> I am not sure how one would go about that?

[15:25] <stevan> you mean create a Package Class?

[15:25] <stevan> that is possible

[15:25] <stevan> mugwump was going along those lines in the early metamodel

[15:25] <stevan> autrijus: much of the push/pop stuff is in 2 contexts

[15:26] <stevan> 1) manipulation of container types

[15:26] <stevan> 2) support for things like $?CLASS and $?SELF and next METHOD

[15:26] <stevan> which were hacked in there

[15:26] <stevan> and probably should not work in the same way in the Haskell version

[15:26] <stevan> although that is your choice

[15:27] <autrijus> ok.

[15:27] <autrijus> (I'm talking also about perl6 version)

[15:27] <stevan> I see ?$CLASS and $?SELF as lexicals which are rebound for each method execution

[15:27] <autrijus> nod.

[15:27] <stevan> they are not globals since they are not accessible outside of their context

[15:27] <stevan> but they change for each execution

[15:28] <stevan> so however you can accomplish this in Haskell is likely better than my cheap Perl5 hack ;)

[15:29] <stevan> next METHOD, as described in A12, is just a next to a label

[15:29] <stevan> but this requires the label search to go outside the method itself, and back up to the dispatcher, then to the resume a loop

[15:30] <stevan> this was just not possible in p5 (at least AFAIK)

[15:30] <autrijus> that is easy to accomplish with coro

[15:30] <stevan> so my choice was to use a stateful dispatcher

[15:31] <stevan> if you can do it with a coro, then you can likely simplfy the dispatcher to be just a simple dispenser

[15:31] * mugwump hovers in hyperspace

[15:32] * stevan looks up nervously at mugwump, and hopes nothing falls 

[15:32] <autrijus> another meta q

[15:33] <autrijus> the immutable fixed layout in P6::MetaClass

[15:33] <stevan> ok

[15:33] <autrijus> that is the lifting point of bootstrapping right?

[15:33] <stevan> that is the basic instance layout

[15:33] <stevan> yes, it needs to be created first

[15:33] <stevan> once it is bootstrapped (which occurs at the bottom of Perl6::MetaModel)

[15:34] <stevan> then all other metaclasses are built in the normal way

[15:34] <stevan> only Perl6::MetaClass and Perl6::Object's Metaclass are built using that new()

[15:34] <autrijus> bottom of metamodel?

[15:34] <stevan> metamodel file

[15:34] <autrijus>     ::dispatch(::meta('Perl6::MetaClass'), 'superclasses', [ ::meta('Perl6::Object') ]);

[15:34] <stevan> yes

[15:34] <autrijus> this?

[15:34] <autrijus> okay, makes +Inf of sense.

[15:34] <stevan> that make Metaclass->isa(Object)

[15:34] <autrijus> yup

[15:34] <stevan> :)

[15:35] <stevan> I was thinking of create a construct_instance() function last night

[15:35] <autrijus> ok. let's go thru the prim layout one by one

[15:35] <stevan> to centralize the layout of the instance sturcutre

[15:35] <stevan> prim?

[15:36] <autrijus> primitive metaclass layout

[15:36] <stevan> ok

[15:36] <autrijus>         class => 'Perl6::MetaClass',

[15:37] <stevan> yes, an instance must hold the class it is created from

[15:37] <autrijus> what about reblessing?

[15:37] <stevan> this is partially why having an object env with string->class mapping is good

[15:37] <stevan> reblessing?

[15:37] <autrijus> in p6 bless is a class method

[15:37] <autrijus> that takes a candidate

[15:38] <autrijus> and returns a blessed object

[15:38] <autrijus> it looks like it is not mutable now

[15:38] <autrijus> i.e. it doesn't modify the candidate in place

[15:38] <autrijus> in p5, you can do

[15:38] <autrijus> bless(bless({}, 'Class1'), 'Class2')

[15:38] <stevan> yes, but that is silliness :P

[15:38] <stevan> which should go away

[15:38] <autrijus> that is, overwrite the "class" field

[15:38] <stevan> yes

[15:38] <autrijus> okay. so I hold the class field to be immutable.

[15:39] <stevan> hoestly I think it should be

[15:39] <autrijus> you have it using a name here.

[15:39] <autrijus> but as we know, class objects may be rebound.

[15:40] <Khisanth> well hopefully things like inheriting constructor are a bit easier now so you don't need that kind of thing? :)

[15:40] <autrijus> (::Int, ::Str) := (::Str, ::Int); # hat trick

[15:40] <stevan> ok

[15:40] <autrijus> are the former Int instances still bound to whatever class they were bound?

[15:40] <autrijus> I'd think yes

[15:40] <stevan> yes, I think messing with class objects like that should produce undefined results

[15:40] <autrijus> they don't suddenly assume Str behaviour

[15:41] <stevan> the CLOS spec defines things like this as having "undefined results" 

[15:41] <autrijus> okay.

[15:41] <stevan> meaning you can do it, but we are not responsible for what it might make happen

[15:41] <autrijus> okay.

[15:42] <stevan> I think manipulating the metamodel in such a way is very hard to predicte the outcome of

[15:42] <autrijus> sure, paint token

[15:42] <autrijus> I mean, point taken

[15:42] <stevan> :)

[15:42] <stevan> I prefer paint token 

[15:43] <autrijus> mm dylsexic

[15:43] <stevan> so back to the class => "Perl6::metaClass" thing

[15:43] <stevan> I use a name, because I can in perl5

[15:43] <autrijus> the name/version/authority section is apparently immutable as well

[15:43] <stevan> ideally that would be a class object

[15:44] <autrijus> I've written that already :)

[15:44] <stevan> but then again, str -> class object lookup is a good thing IMO

[15:44] <stevan> ok

[15:44] <stevan> name, version authority could be mutable

[15:44] <autrijus> back up a bit

[15:44] <stevan> name should likely not be

[15:44] <stevan> ok.. sorry

[15:44] <autrijus> instance_data

[15:44] <stevan> yes

[15:45] <autrijus> it's a map from member names to values

[15:45] <stevan> yes

[15:45] <stevan> it is constructed from the attribute objects in the metaclass (and all the superclasses)

[15:45] <autrijus> when you reopen a class

[15:45] <stevan> Perl6::Object->CREATE shows an example

[15:45] <autrijus> to add new member names

[15:45] <stevan> yes

[15:46] <stevan> you either need to do 2 things

[15:46] <stevan> 1) have the instance value accessing function (_() in the MetaModel) check the metaclass first

[15:46] <stevan> and create the new slot in the instance_data structure

[15:46] <stevan> or 2) use some kind of autovivification

[15:47] <stevan> sorry that didnt make much sense

[15:47] <stevan> ok

[15:47] <stevan> you need to proxy access to the instance variables

[15:48] <stevan> that proxy should check the metaclass for each access

[15:48] <stevan> for various reasons

[15:48] <autrijus> wait wait.

[15:48] <stevan> ok

[15:48] <autrijus> say my class is P6::MC

[15:48] <stevan> yes

[15:48] <autrijus> and my instance_data is $.name and $.version.

[15:48] <stevan> yes

[15:48] <autrijus> ideally, my instance data is just a IntMap

[15:49] <autrijus> that is a perl5 array

[15:49] <autrijus> and my class should give me the mapping from $.name to 0

[15:49] <autrijus> and $.version to 1

[15:49] <stevan> ok

[15:49] <autrijus> and the bound that that it's at that

[15:49] <stevan> sure, that is how CLOS does it

[15:49] <autrijus> when I reopen it, I magically get 2 as a valid key

[15:49] <autrijus> but otherwise it's an out of bounds.

[15:49] <autrijus> that sounds cleaner

[15:49] <stevan> but hashes are more expensive in LISP then perl :)

[15:49] <stevan> ok

[15:50] <autrijus> well no, it's about sharing a keymap.

[15:50] <autrijus> that way when I reopen a class and throw new methods in

[15:50] <autrijus> I mean, members in

[15:50] <autrijus> existing instances automagically gets them

[15:50] <autrijus> without me walking thru their instance_data

[15:50] <stevan> ok

[15:50] <autrijus> in perl5 this style is known as... pseudohashes

[15:51] <autrijus> (which sadly is going away for dubious reasons)

[15:51] <stevan> yes

[15:53] <autrijus> ok.

[15:53] <autrijus> at this moment I have

[15:53] <autrijus> data Class = MkClass { clsMembers :: Name -> Id }

[15:53] <coral> pseudohashes!

[15:53] <autrijus> data MetaClass = MkMetaClass { objClass  :: Class , objData   :: Id -> Container }

[15:53] <stevan> BTW - I locked keys in the P5 version only for myself, not as a design descision

[15:53] <autrijus> nod

[15:53] <stevan> to keep my sanity when I was debugging :)

[15:53] <stevan> and bootstrapping

[15:53] <stevan> ok, that looks good

[15:54] <stevan> but MetaClass is basically an object

[15:54] <autrijus> yes

[15:54] <stevan> so you could inherit from Object maybe?

[15:54] <autrijus> so it's really

[15:54] <autrijus> data Object = MkObject { objClass  :: Class , objData   :: Id -> Container }

[15:54] * stevan still doesnt know enough Haskell

[15:54] <autrijus> haskell has no monomorphic subtyping :)

[15:54] <stevan> data MetaClass = MkObject()

[15:54] <autrijus> it's like erlang.

[15:55] <autrijus> (there is only roles, not classes, so to speak)

[15:55] <autrijus> but anyway

[15:55] <stevan> yes, I remember that part :)

[15:55] <stevan> grokking it is another story, but I remember it :)

[15:55] <autrijus> so a class is a mapping from Name to Id, that is the member fields

[15:56] <stevan> yes

[15:56] <autrijus> what else does a primitive class do?

[15:56] <stevan> nothing really

[15:57] <stevan> well actually there is one thing missing here

[15:57] <autrijus> okay. in that case, do we ever need to reopen a primitive class?

[15:57] <stevan> an instance points to it's class

[15:57] <stevan> a class needs to point to it's metaclass

[15:57] <stevan> I use the symbol table to store it currently

[15:57] <autrijus> okay.

[15:57] <stevan> see ::meta() in the MetaModel.pm file

[15:57] <autrijus> its metaclass is an object?

[15:57] <stevan> the BUILD submethod of MetaClass handles that

[15:58] <stevan> every class has a metaclass instance

[15:58] <stevan> the metaclass instance actually defines all the stuff the class does

[15:58] <stevan> the class object is just a bridge

[15:58] <autrijus> data Class = MkClass { clsMeta    :: Object , clsMembers :: Name -> Int }

[15:59] <stevan> between the meta space and the user space

[15:59] <autrijus> data Object = MkObject { objClass  :: Class , objData   :: Int -> Container }

[15:59] <stevan> yes those look sane 

[15:59] <stevan> if you make each class an instance of a Class object, that would work as well

[15:59] <stevan> if that makes things easier

[16:00] <stevan> so each instnace has-a instance of a Class

[16:00] <autrijus> prolly not

[16:00] <stevan> ok

[16:00] <stevan> yeah it worked in the JS version, but no in the P5 version

[16:01] <stevan> if we want to be really cyclical you could define Class as an Object too

[16:01] <stevan> but that is just insane

[16:01] <stevan> and only Smalltalk does that kind of insanity

[16:02] <stevan> actually CLOS does it too, sort of

[16:02] <stevan> either way, that is something which can be dealt with later I think

[16:02] <autrijus> ok.

[16:02] <autrijus> what's the metaclass of Perl6::MetaClass

[16:02] <autrijus> ?

[16:03] <stevan> an instance of Perl6::MetaClas

[16:03] <autrijus> is this the same instance that is the bootstrap?

[16:03] <autrijus> i.e. it forms a cycle

[16:03] <stevan> yes

[16:03] <stevan> only the new() and add_method() need be defined

[16:03] <stevan> in the normal class way

[16:03] <autrijus> normal class way?

[16:04] <coral> stevan: Class::Method in perl5 lets me do my $class = new Class::Method; bless $obj, $class; $obj->extend(add => sub { $_[0] + $_[1] }); # all objects in the $class support adding now

[16:04] <stevan> in p5 terms: in the package symbol table

[16:04] <coral> which i found quite handy for my putterings about with AI

[16:04] <stevan> coral: the metamodel will allow that

[16:04] <stevan> simply do this:

[16:04] <coral> three disclaimers - (a) i wrote it (b) it uses Devel::Pointer and (c) scalarified overloading of $class under bless doesn't work yet

[16:05] <stevan> Perl6::Object->meta->add_method('add' => sub { ... })

[16:05] <coral> neat, perfect

[16:05] <stevan> :)

[16:05] <coral> :)

[16:05] <stevan> autrijus: new is needed to create the first few instances of MetaClass 

[16:06] <stevan> until we have the Perl6::Object boostrapped in

[16:06] <autrijus> right.

[16:06] <autrijus> let me think about it a bit

[16:06] <stevan> and _add_method must be created, so that we can add methods into the metaclass structure

[16:06] <stevan> but once _add_method adds itself (line 95 of MetaClass) we can add all other methods

[16:06] <stevan> and the dispatcher then can find them

[16:07] <stevan> or rather ::dispatch() can find them

[16:07] <coral> i am very cheered to see this being implemented in p6 somehow

[16:07] * coral bows to stevan

[16:07] <stevan> the early metaclasses need to have a special dispatcher which avoid all method calls

[16:07] <stevan> otherwise you get infinite loops

[16:07] <autrijus> yes.

[16:07] <autrijus> still thinking

[16:07] <stevan> coral: thank you, but I am only an implementation monkey :)

[16:08] <coral> i am only a cheerleader

[16:08] <stevan> autrijus: it might help to not bootstrap the first time around

[16:08] <coral> check out my enormous pom-poms

[16:08] * coral does a cheer

[16:08] <autrijus> stevan: nah, I think I need to grok it in one sitting :)

[16:08] <stevan> to define MetaClass by hand, and not as a MetaClass instance

[16:08] <autrijus> let me try it once at least :)

[16:08] <stevan> sure

[16:08] <stevan> coral: :)

[16:08] <autrijus> ok. so at the very very beginning

[16:08] <stevan> yes

[16:08] <autrijus> we have a map of meta info

[16:09] <autrijus> that is the three metadata, MRO, superclasses, etc

[16:09] <stevan> yes

[16:09] <autrijus> so it has undef for both name and authority?

[16:10] <stevan> yes

[16:10] <autrijus> funky

[16:10] <stevan> I added the default version, that may not be the best

[16:11] <stevan> it is a blank slate when you begin

[16:11] <autrijus> nod.

[16:11] <autrijus> gnosis :: Map Int Container

[16:12] <autrijus> gnosis = Map.fromList . constify $ [ ("$.name", constScalar Undef) , ("$.version", constScalar Undef) , ("$.authority", constScalar Undef) ]

[16:12] <stevan> nice name :)

[16:12] <autrijus> the object is called demiurge :)

[16:12] <stevan> LOL

[16:13] <autrijus> ok. what's this @:MRO doing?

[16:13] <stevan> it stores the calculated C3 MRO

[16:13] <autrijus> it's a cache?

[16:13] <stevan> you can safely remove it if you like,.. 

[16:13] <stevan> yes

[16:13] <autrijus> ok. I'll replace it with hash consing

[16:13] <stevan> Demiurge A deity in Gnosticism, Manichaeism, and other religions who creates the material world and is often viewed as the originator of evil.

[16:13] <stevan> originator of evil :)

[16:14] <autrijus> that's right.

[16:14] <autrijus> actually, it's not evil

[16:14] <stevan> meta-evil actually :P

[16:14] <autrijus> more like defect, imperfection

[16:14] <autrijus> but it's not time for metaphysical mishmash right now :)

[16:14] <stevan> LOL

[16:14] <autrijus> now, @:superclasses.

[16:14] <stevan> ok, so @:superclasses is the superclasses of the class

[16:15] <autrijus> this is likely mutable

[16:15] <stevan> a list of meta-class instances

[16:15] <stevan> yes

[16:15] <autrijus> but add-only

[16:15] <autrijus> I persume

[16:15] <stevan> well

[16:15] <coral> um

[16:15] <stevan> hard to say

[16:15] <stevan>  i think it should be 

[16:15] <autrijus> at least in S12 I see no way to remove a "is" relationship.

[16:15] <stevan> but again, manipulating the superclasses list at runtime should have undefined behavior

[16:15] <coral> oooh

[16:16] <autrijus> undefined behaviour is the bane of QuickCheck :)

[16:16] <autrijus> (which is built out from invariant specifications)

[16:16] <coral> rats :(

[16:16] <stevan> removing from superclasses is just insane

[16:16] <stevan> IMO we should not support it

[16:16] <stevan> it breaks too much

[16:16] <autrijus> k.

[16:17] <stevan> adding to it is insane as well

[16:17] <autrijus> class Foo is reopened is Bar {...}

[16:17] <stevan> since it can both change the MRO and instance mapping

[16:17] <autrijus> but that's okay

[16:17] <autrijus> I think

[16:17] <autrijus> it invalidates caches

[16:17] <autrijus> but that's about it

[16:18] <autrijus> it doesn't invalidate compile time assertions

[16:18] <autrijus> (I think)

[16:18] <stevan> ok

[16:18] <stevan> again, in CLOS, this is undefined behavior

[16:18] <stevan> aka - virgin territory

[16:19] <stevan> if we can define it, great, but that may not be possible to deal with 100%

[16:19] <autrijus> ok.

[16:19] <coral> o/` classed for the very first time o/`

[16:19] <autrijus>     , ("@:superclasses", constArray []) -- appendArray in the future?

[16:20] <stevan> ok

[16:20] <autrijus> %:private is immutable for gnosis I gather

[16:21] <autrijus>     , ("%:private", constHash [ "methods", mutableHash [] ])

[16:21] <stevan> I think all the method and attribute slots are mutable

[16:21] <stevan> oh yes, that is immutable

[16:21] <autrijus> the "methods" hash is mutable

[16:21] <stevan> it is the sub-slot of methods which is mutable

[16:21] <stevan> yes

[16:21] <autrijus> but not the "%:private"

[16:21] <stevan> yes

[16:21] <autrijus> good :)

[16:22] * stevan is dangerously low on caffinee

[16:22] <stevan> autrijus: it might make sense to have attribute in the %:private slot 

[16:22] <stevan> but I am not sure

[16:22] <stevan> I think private attribute are local to the class, like methods are

[16:23] <autrijus> but it's not currently implemented that way?

[16:23] <stevan> no, because private methods are a very new addition

[16:23] <autrijus> ok.

[16:24] <stevan> as was the %:private slot

[16:24] <autrijus> ok

[16:24] <autrijus> I'll add both in then

[16:25] <stevan> however, the behavior is still the same

[16:25] <stevan> within the instance structure

[16:25] <autrijus>     , ("%:private", methodAttrHash)

[16:25] <autrijus>     , ("%:class_definition", methodAttrHash)

[16:25] <autrijus>     , ("%:class_data", methodAttrHash)

[16:25] <autrijus>     where

[16:25] <autrijus>     methodAttrHash = constHash

[16:25] <autrijus>         [ "methods", mutableHash []

[16:25] <autrijus>         , "attributes", mutableHash []

[16:25] <autrijus>         ]

[16:25] <stevan> accessing a private attribute should only take place in a method defined in the class which the private attribute is defined in

[16:25] <stevan> yes, that looks sane :)

[16:26] <autrijus> okay, we have gnosis.

[16:26] <autrijus> demiurge :: Object

[16:26] <autrijus> demiurge = MkObject

[16:26] <autrijus>     { objClass = MkClass

[16:26] <autrijus>         { clsMeta    = demiurge

[16:26] <autrijus>         , clsMembers = fromKeys (Map.keys gnosis)

[16:26] <autrijus>         }

[16:26] <autrijus>     , objData = gnosis

[16:26] <autrijus>     }

[16:26] <autrijus> sane?

[16:27] <stevan> give me a moment to grok the haskell

[16:27] <autrijus> sure

[16:27] * autrijus praises infinite data structures without references

[16:27] <stevan> yes that looks sane I think

[16:28] <autrijus> ok

[16:28] <autrijus> what's this?

[16:28] <autrijus>     _build_meta() unless $params{'$.name'} eq 'Perl6::MetaClass';

[16:28] <autrijus> ah, it's so that :meta('Perl6::MetaClass') doesn't recurse?

[16:29] <stevan> yes

[16:29] <autrijus> clever

[16:29] <stevan> remember Perl6::metaClass::new() is used exactly twice

[16:29] <stevan> first to create the structure for MetaClass

[16:29] <stevan> then to create the structure for Obejct

[16:29] <autrijus> right.

[16:29] <stevan> s/structure/instance structure/

[16:30] <autrijus> so the second time it's

[16:30] <autrijus> class 'Perl6::Object' => {

[16:30] <stevan> creating Object is actually what creates the MetaClass instance for MetaClass 

[16:30] <stevan> lazy loaded 

[16:30] <autrijus>     'class' => {

[16:30] <autrijus>         methods => {

[16:30] <autrijus>             'new' => sub {

[16:30] <autrijus> etc.

[16:30] <autrijus> which inits the MC

[16:30] <stevan> yes

[16:30] <stevan> look in Class->_apply_class_to_env

[16:31] <stevan> there is a special case conditional for Perl6::Object

[16:31] <autrijus> ok. I'll not call the first object as yhwh.

[16:31] <stevan> LOL

[16:32] <autrijus> okay, I think I'll call it pneuma

[16:32] <stevan> nice

[16:33] * stevan is really working Google's defintion feature today :)

[16:33] <autrijus> explain this

[16:33] <autrijus>             # XXX - this might move up the MetaClass at some point - per $Larry

[16:33] <autrijus> I grok the rest

[16:33] <mugwump> autrijus, you are writing a tangram schema!  :)

[16:33] <mugwump> 04:19 < autrijus>     'class' => {

[16:33] <mugwump> 04:19 < autrijus>         methods => {

[16:33] <mugwump> 04:19 < autrijus>             'new' => sub {

[16:33] <autrijus> mugwump: that's stevan's code

[16:34] <stevan> autrijus: where is that comment from?

[16:34] <autrijus> I'm far more lazy than that :)

[16:34] <autrijus> stevan: it's in             'bless' => sub {

[16:34] <stevan> ok, looking

[16:35] <stevan> yes, $Larry spoke once of having the metaclass handle blessing on some level

[16:35] <stevan> but I dont think that is sane IMO

[16:35] <autrijus> "Jesus says to the Samaritan woman: 'Pneuma o theos' -- God is Spirit. Notice that !Theos.isa(Pneuma), Theos =:= Pneuma"

[16:35] <autrijus> I don't see how that could work.

[16:35] <stevan> however, I only implemented p6opaque here

[16:35] <mugwump> Did anyone ever write tests for $Larry's approval of $.foo =:= ./foo() ?

[16:36] <stevan> autrijus: it Object::new would just dispatch to Object->meta->new

[16:36] <stevan> s/new/bless/

[16:36] <autrijus> reexplain?

[16:36] <stevan> autrijus: I suggest we punt, I think it is a non-issue in the end

[16:37] <autrijus> ok.

[16:37] <stevan> I think bless() in the sense of tagging a reference is best in the interpreter core

[16:37] <stevan> but bless() in the object sense is best in Object

[16:37] <stevan> maybe with some help from MetaClass later on, but I see no immediate need for that now

[16:38] * stevan *must* get some more coffee, bb in two shakes of the lamb of gods tail (to keep the religous theme going)

[16:38] <autrijus> ok.

[16:38] <autrijus> :D

[16:40] <autrijus> ok, so we have gnosis, that is logos, which was with demiurge, in the beginning. the pneuma, that is the first object, the light that shines

[16:40] * autrijus is translating Perl6::Object

[16:41] <autrijus> hm, Perl6::Class is never defined.

[16:41] <autrijus> I wonder why.

[16:41] <autrijus> is it not yet lifted?

[16:42] <stevan> autrijus: no, it is nothing but a shell

[16:42] <stevan> a means to connect between the user world and the meta world

[16:42] <autrijus> okay. so in a sense, Perl6::MetaClass is the shape of Perl6::Class

[16:42] <stevan> uhm, yes

[16:42] <autrijus> in the perl6 space

[16:42] <autrijus> i.e. user world

[16:43] <autrijus> it's the metaverse's means to shapw how the Class is perceived by the mortals

[16:43] <stevan> any questions asked of Perl6::Class instances are passed up to their metaclass instance

[16:43] <autrijus> right.

[16:43] <stevan> yes

[16:43] * autrijus suppresses the obvious "channeling" jokes

[16:44] * stevan thinks maybe there should be a "meta" song, so we can have something to sing when things make sense :)

[16:44] <autrijus> ok. so to evaluate pneuma, we need to turn to the channel

[16:44] <autrijus> that is perl5/Perl6-MetaModel/lib/Perl6/Class.pm

[16:45] <autrijus> it's called with

[16:45] <autrijus> Perl6::Class->new('Perl6::Object', {...});

[16:45] <stevan> yes, that is what class => 'Perl6::Object' does

[16:45] <stevan> see Perl6::MetaModel::class()

[16:46] <autrijus> yes

[16:46] <autrijus> ignoring _validate_params for now

[16:46] <stevan> yes

[16:46] <stevan> good idea

[16:46] <autrijus> so it's essentially

[16:47] <autrijus> bless({name => 'Perl6::Object', params => \%theos}, 'Perl6::Class')

[16:47] <autrijus> or rather

[16:47] <autrijus> bless({name => 'Perl6::Object', params => \%theos}, __PACKAGE__)

[16:47] <autrijus> since we don't make use of inheritance

[16:47] <autrijus> in the underlying runtime

[16:47] <stevan> yes

[16:47] <stevan> http://svn.openfoundry.org/pugs/perl5/Perl6.MetaModel/lib/Perl6/Object.js  might help

[16:48] <autrijus> looks rather identical

[16:48] <stevan> yes

[16:48] <autrijus> just with less @_ shipping around

[16:48] <stevan> but not seeing it in perl, sometimes helps

[16:49] <autrijus> ok. let's tease the methods apart

[16:49] <autrijus> we ignore _validate_params already

[16:49] <stevan> yes

[16:49] <stevan> _apply_class_to_environment?

[16:49] <autrijus> that leaves us _apply_class_to_environment _get_class_meta_information _build_class 

[16:49] <stevan> _get_class_meta_information is simple, just breaks up the name

[16:50] <autrijus> that's easily a helper sub

[16:50] <autrijus> not warranting a method

[16:50] <stevan> yes

[16:50] <autrijus> what's _build_class ?

[16:50] <autrijus> (I know all the magic is in _apply)

[16:50] <stevan> it converts the $params hash to a metaclass

[16:50] <autrijus> aha

[16:50] <autrijus> it's the channel from static data into live mixes

[16:50] <stevan> mostly it just populates the metaclass created in _apply

[16:51] <autrijus> right.

[16:51] <autrijus> okay. which brings us back to _apply

[16:51] <stevan> yes

[16:51] <stevan> ok the eval part

[16:51] <stevan> just sets up the p5 magic

[16:52] <stevan> look at Perl6::Instance for a second

[16:52] <autrijus> already there

[16:52] <stevan> it defines all the UNIVERSAL:: methods

[16:52] <stevan> isa, can and AUTOLOAD

[16:52] <autrijus> it's the sugar

[16:52] <stevan> yup

[16:52] <autrijus> ok, safely ignored

[16:52] <stevan> and it makes the $MyClass::META entry in the symbol table

[16:52] <stevan> which we can ignore since we strore it in the Class

[16:52] <autrijus> yes.

[16:53] <stevan> next, it aliases the full name to the short name

[16:53] <stevan> more p5 sugah

[16:53] <autrijus> so the entire chunk vanishes in a puff of logic

[16:53] <stevan> yes

[16:53] <stevan> then creating the metaclss

[16:53] <autrijus> that's the real magic

[16:53] <stevan> Perl6::Object is a special case

[16:53] <stevan> it must be created by hand

[16:53] <autrijus> right.

[16:53] <stevan> using the Perl6::MetaClass::new() function 

[16:53] <autrijus> ahh. so _that_'s what it's for

[16:54] <stevan> and then installing the resulting meta into the $META

[16:54] <autrijus> but wait

[16:54] <autrijus> we don't use $META anymore no?

[16:54] <stevan> yes

[16:54] <stevan> you need to store it in the class

[16:54] <stevan> just change ${"${name}::META"} = $meta;   to $class->{meta} = $meta

[16:54] <stevan> and you ahve the same thing

[16:55] <stevan> of course Class::new should create the "meta" slot then

[16:55] <autrijus> yup

[16:55] <autrijus> ok. so the $meta there

[16:55] <stevan> yes

[16:55] <autrijus> is not the demiurge metaobject

[16:55] <stevan> in the non-special case

[16:55] <autrijus> nono

[16:55] <stevan> ok

[16:55] <autrijus> I'm talking about the special one

[16:55] <stevan> :)

[16:55] <autrijus> the special one is like demiurge

[16:55] <autrijus> but with an additional clause

[16:56] <autrijus> that is _build_meta

[16:56] <autrijus> because its name is now P6::Obj

[16:56] <autrijus> not P6::MC

[16:56] <stevan> yes

[16:56] <stevan> which basically then inits the P6::MC's metaclass instance

[16:56] <autrijus> which throws in a whole bunch of dispatcher

[16:56] <autrijus> yup

[16:57] * autrijus sees the entire metacircular light!

[16:57] <stevan> :)

[16:57] <autrijus> beautiful :)

[16:57] * stevan does the meta-dance

[16:57] <Odin-> Yo, MC Perl in da house!

[16:57] <Aankhen``> meppl: `has Int @.s;` declares an instance variable, not a class variable.

[16:58] <Aankhen``> ?eval class La { has int @.s; method la () { say @.s.end; } }; La.new().la()

[16:58] <evalbot6> Error: No compatible subroutine found: "&end" 

[16:58] * autrijus drinks a potion of gain level

[16:58] <Aankhen``> ?eval class La { has @.s; method la () { say @.s.end; } }; La.new().la()

[16:58] <evalbot6> Error: No compatible subroutine found: "&end" 

[16:58] * autrijus bootstraps and floats up, through the ceiling!

[16:58] <Aankhen``> ?eval class La { has @.s; method la () { @.s = <a b c d>; @.s.end; } }; La.new().la()

[16:58] <evalbot6> 3 

[16:58] <stevan> autrijus: it is not unlike a rube goldberg machine, in that each little thing trips of the next thing until suddely, you catch the mouse

[16:59] <Aankhen``> Ah, that would be why it wasn't working.

[16:59] <Aankhen``> No elements in @.s.

[16:59] <autrijus> stevan: indeed

[16:59] <stevan> meta-circularity++

[16:59] <Aankhen``> Dinner. &

[16:59] <stevan> Aankhen``: ooh, anything good?

[16:59] <autrijus> stevan: why can't _build_meta be called the 1st time around?

[16:59] <stevan> because there is _build_meta calls new()

[17:00] <stevan> to create the Metaclass's metaclass instance 

[17:00] <autrijus> ah right

[17:00] <stevan> careful, cycles abound

[17:00] <autrijus> ok

[17:00] <autrijus> so it _is_ called the 1st time around

[17:00] <stevan> the first it can be called 

[17:00] <stevan> and no sooner

[17:00] <autrijus> yes.

[17:00] <stevan> or later for that matter

[17:00] <autrijus> and not again

[17:00] <meppl> aankhen, yes, i said that i though.     but why does normal variables work without

[17:00] <stevan> yes

[17:01] <stevan> one time use :)

[17:01] <autrijus> ok. so in our model

[17:01] <meppl> ?eval my $a; $a.end

[17:01] <evalbot6> Error: No compatible subroutine found: "&end" 

[17:01] <autrijus> we'll use a lexical $META

[17:01] <meppl> oh

[17:01] * stevan is very excited to see the metamodel moving to Haskell

[17:01] <autrijus> and then stuff it into Perl6::Object's clsMeta.

[17:02] <stevan> sure

[17:02] <meppl> ?eval my $a; say $a.end

[17:02] <evalbot6> Error: No compatible subroutine found: "&end" 

[17:03] <autrijus> does the MetaClass for the Perl6::Object class has a name?

[17:03] <meppl> asdhg

[17:03] <meppl> ?eval my @a; @a.end

[17:03] <evalbot6> -1 

[17:03] <stevan> how do you mean "name"?

[17:04] <stevan> $.name?

[17:04] <autrijus> I know its $.name is Perl6::Object

[17:04] <stevan> I am not understanding then

[17:04] <autrijus> the metaclass object for P6::Obj

[17:04] <autrijus> let's call it theos, for the lack of a better name

[17:05] <stevan> in the p5 it is stored in $Perl6::Object::META

[17:05] <autrijus> I have

[17:05] <autrijus> -- The Original Perl6::Object

[17:05] <autrijus> pneuma :: Object

[17:05] <autrijus> pneuma = MkObject

[17:05] <autrijus>     { objClass = MkClass

[17:05] <autrijus>         { clsMeta   = theos

[17:05] <autrijus>         , clsMembers = fromKeys (Map.keys logos)

[17:05] <autrijus>         }

[17:05] <autrijus>     }

[17:05] <autrijus> (objData not there yet)

[17:05] <autrijus> i.e. it's objData = logos too, but I hadn't transcribed logos

[17:05] <stevan> ok

[17:06] <stevan> why would it need a name?

[17:06] <integral> autrijus++ # fantastic names :)

[17:07] <autrijus> mm, it's only used by pneuma

[17:07] <autrijus> never reused as anybody else's metaclass object

[17:07] <autrijus> so it can stay anonymous

[17:07] <autrijus> i.e. not referenced elsewhere

[17:07] <stevan> yes, all classes have a metaclass instance

[17:07] <autrijus> it's available as Perl6::Object.meta

[17:07] <stevan> 1 to 1

[17:07] <stevan> yes

[17:08] <autrijus> hm, except for demiurge

[17:08] <autrijus> clsMeta (objClass demiurge) == demiurge

[17:08] <stevan> which one is that agina?

[17:08] <autrijus> the original Perl6::Object metaclass

[17:08] <stevan> you mean the Perl6::MetaClass's metaclass?

[17:08] <autrijus> yes.

[17:09] <stevan> it is an instnace of itself

[17:09] <stevan> Perl6::MetaClass is defined as an instance of itself

[17:09] <autrijus> right

[17:09] <stevan> the cycle at the top of our object model

[17:10] <stevan> otherwise we keep meta.meta.meta.meta-ing

[17:10] <autrijus> mmm parthenogenesis

[17:10] <autrijus> but yeah, I think I grok that now

[17:10] * stevan googles that one

[17:11] <stevan> yes, metaclass is essentially the virgin birth

[17:11] <coral> hee

[17:11] <autrijus> ok. back to Class.pm lin 57

[17:11] <stevan> yes

[17:12] <autrijus> we create an instance of the primitive Perl6::MetaClass

[17:12] <stevan> yes

[17:13] <autrijus> its instance data is like the blank state

[17:13] <autrijus> except its $.name which is set to P6::Object

[17:13] <stevan> at that point (line 57) yes

[17:13] <autrijus> but otherwise it's the same

[17:13] <stevan> the same as?

[17:14] <autrijus> as the gnosis... i.e. the thing you call P6::MetaClass::new() with no states

[17:14] <stevan> yes

[17:14] <autrijus> the layout for the parthenogenesis

[17:14] <autrijus> ok

[17:14] <stevan> _build_class then populates it

[17:14] <stevan> _build_meta is like _build_class

[17:14] <autrijus> right.

[17:14] <stevan> but for the MetaClass

[17:14] <autrijus> but _b_class is reusable

[17:14] <stevan> yes

[17:15] <autrijus> every time you call class{} you _b_class

[17:15] <autrijus> but _b_meta is one shot

[17:15] <stevan> yes

[17:15] <stevan> yes

[17:15] <stevan> bootstrap

[17:15] <stevan> basically you throw away most of the bootstrap once it is in place :)

[17:15] <autrijus> right.

[17:15] <stevan> but I dont need to tell you that :P

[17:15] <autrijus> ;)

[17:15] <stevan> careful, cycles abound

[17:16] <autrijus> let me finish logos and pneuma. just a sec

[17:16] <stevan> it is very easy to think about one thing, and follow it further and realize you are back where you started

[17:16] <stevan> many things depend upon them being there before they exist

[17:16] <stevan> chicken and eggs and all that

[17:16] <autrijus> right, but you see... in haskell that's just fine :)

[17:17] <autrijus> note how I referred to demiurge before it completes itself

[17:17] <stevan> CLOS (or at least in Clossett in The Art of MOP)  bootstraps in 10 steps

[17:17] <stevan> I have not counted how many steps I take

[17:17] <stevan> yes, laziness++ :)

[17:18] <stevan> as always the LOC of the Haskell version will be something less than 10% of the total LOC of the perl version

[17:18] <autrijus> :)

[17:20] <Aankhen``> stevan: Kadai chicken, rice, beans, roti, daal, and raita. Any of that familiar to you?

[17:20] <sili> i think it's time to learn haskell

[17:20] <stevan> Aankhen``: yes :)

[17:20] <stevan> Aankhen``: I was once a waiter at an indian resturant

[17:20] <Aankhen``> Ah, cool.

[17:20] <stevan> I was the token white boy :)

[17:20] <Aankhen``> In that case, you can form your own opinion. ;-)

[17:20] <stevan> home cooked indian food++

[17:21] <stevan> after we closed the resturant, they staff would always make a big "home-style" dish

[17:21] <stevan> yummmmm

[17:21] <Aankhen``> Yeah, I wish I could get some home cooked Indian food.  Instead, I have to put up everyday with... uh... oh.

[17:22] <stevan> my favorite was the corn roti and spinach, i think it was a punjabi winter dish

[17:22] <Aankhen``> I haven't had corn roti.

[17:22] <Aankhen``> I don't like spinach much, though.

[17:22] <stevan> it is very good

[17:22] <Aankhen``> (I am an extremely finicky eater)

[17:22] <stevan> saag++

[17:22] <Aankhen``> Back in February, I would not even have eaten beans.

[17:23] <stevan> I think my overall favorite is Chicken Bhuna

[17:23] <Aankhen``> (Tandoori chicken)++

[17:23] <Aankhen``> (Kathi Kebabs)++

[17:23] <stevan> I used to go out drinking with the Tandoori chef all the time

[17:24] <Aankhen``> Lucky you. :-)

[17:24] <Aankhen``> dudley, you around?

[17:25] * stevan ponders the "good old days" before he knew about meta-models and life was much simpler

[17:26] <Aankhen``> LOL.

[17:27] <Aankhen``> stevan++ # work on Meta-Model is amazing

[17:27] <stevan> Aankhen``: thanks :)

[17:28] <stevan> Aankhen``++ # for braving the depths of CGI and libwww

[17:29] * cognominal_ fears Meta-Stase

[17:29] <Aankhen``> Heh.

[17:29] <Aankhen``> CGI is scary.

[17:29] <Aankhen``> LWP isn't so much so.

[17:29] <cognominal_> on the other hand a Meta-Stas would be usefule for mod_perl

[17:31] <autrijus> yay it works!

[17:31] <autrijus> just for the 0th stage

[17:31] <stevan> nice

[17:31] <Aankhen``> What does?

[17:31] <autrijus> I'll leave the rest to tomorrow... need to write notes :)

[17:31] <autrijus> Aankhen``: this

[17:31] <stevan> auuuh

[17:31] <autrijus> -- The Original Perl6::MetaClass class (and metaclass!)

[17:31] <autrijus> demiurge :: Object

[17:31] <autrijus> demiurge = MkObject{ objClass = cls, objData = dat } where (fld, dat) = splitMap (gnosis Undef) -- no $.name cls = MkClass{ clsMeta = demiurge, clsFields = fld }

[17:31] <autrijus> er

[17:31] <autrijus> with better layout:

[17:31] <autrijus> demiurge = MkObject{ objClass = cls, objData = dat }

[17:31] <stevan> this means I have to do $work now

[17:31] <autrijus>     where

[17:31] <autrijus>     (fld, dat) = splitMap (gnosis Undef) -- no $.name

[17:31] <autrijus>     cls = MkClass{ clsMeta = demiurge, clsFields = fld }

[17:31] <Aankhen``> Very cool.

[17:32] <autrijus> stevan: thanks so much for hand holding :)

[17:32] <stevan> autrijus: a pleasure as always :)

[17:33] * autrijus praises lazy evaluation again

[17:33] <autrijus> in p6, we'd need to use later-populated refs or thunks to tie the knot

[17:34] <autrijus> but that's fine, just more verbose

[17:34] <stevan> yes

[17:35] * autrijus is suitably excited at the sheer madness

[17:36] <autrijus> a MOP fully exposed at language level is so very sick :)

[17:36] * stevan is just happy to have the company over here in the meta-land

[17:36] <autrijus> I think I really need to learn SBCL well :)

[17:37] <stevan> SBCL?

[17:37] <autrijus> steel bank common lisp

[17:37] <autrijus> the soft typing thing that can do compile time inferencing and assertion

[17:37] <autrijus> descendent of cmucl

[17:37] <stevan> ah

[17:39] <autrijus> stevan: 

[17:39] <stevan> autrijus: 

[17:39] <autrijus> S12: Every class is an instance of its metaclass.  You can get at the metaclass of any object via the ".meta" method.

[17:39] <autrijus> this looks like the reverse of the world picture

[17:39] <autrijus> which we just put together

[17:39] <stevan> S12 is wrong

[17:39] <autrijus> thank you!

[17:39] <stevan> every class has an instnace of a metaclass

[17:39] <autrijus> yup

[17:41] <stevan> why would a class be an instance of its metaclass

[17:41] <stevan> both are singletons anyway

[17:41] <stevan> you never have 2 instance of class(Foo)

[17:41] <stevan> and you never have 2 instance of meta(class(Foo))

[17:42] <stevan> a has-a chain just makes more sense

[17:42] <autrijus> nod.

[17:42] <autrijus> in scala, one can write a singleton definition just by writing 

[17:43] <autrijus> (paraphrased)

[17:43] <autrijus> object Foo { has $.foo = "x"; has $:bar = "y" };

[17:43] <autrijus> i.e. just by switching "class" to "object"

[17:43] <stevan> interesting

[17:43] <autrijus> they also have case classes, which looks like (paraphrases)

[17:44] <autrijus> class Tree {...}

[17:44] <autrijus> case class Branch { has Tree $.l; has Tree $.r }

[17:44] <autrijus> case class Leaf { has Int $.v }

[17:44] <autrijus> then you can write

[17:44] <autrijus> my $tree = Branch( Branch( Leaf(3), Leaf(4) ), Leaf(5) );

[17:45] <autrijus> and then

[17:45] <stevan> hmmm, how very SML-ish

[17:46] <dudley> Aankhen``: ping

[17:46] <Aankhen``> Pong.

[17:46] <autrijus> sub count (Tree $t) { given $t { when Branch { count(.l) + count(.r) } when Leaf { count(.v) } } }

[17:46] <autrijus> etc.

[17:47] <autrijus> the difference with perl6 is that the .l/.r binding is compile time, that is if you've written .v there it won't typecheck.

[17:47] <autrijus> er, count(.v) should be .v, obviously

[17:47] <autrijus> I find that to be quite attractive :)

[17:47] <Aankhen``> dudley: Hi. You reported some problems with install_dir?

[17:47] <autrijus> (for data-centric problem domains)

[17:48] <dudley> The problem with the install is: lib/perl5 respects PREFIX (or install_dir) but lib/perl6 gets installed to wherever my original perl5 installation is

[17:49] <Aankhen``> Wha?

[17:49] <Aankhen``> What OS are you on?

[17:49] <dudley> mac os 10.4

[17:49] <Aankhen``> That's weird.

[17:49] <Aankhen``> Hmm.

[17:49] <Aankhen``> Where is lib/perl5?

[17:49] <Aankhen``> Or are you talking blib and blib6?

[17:50] <Aankhen``> Talking about, even.

[17:52] <dudley> I mean the stuff that gets installed to PREFIX/lib/perl5 or lib/perl6

[17:53] <Aankhen``> Ah.

[17:54] <dudley> I set install_dir to /Users/dudley/something and end up with /Users/dudley/something/lib/perl5/, but /opt/loca/lib/perl6

[17:55] <Aankhen``> Can you open up the Makefile for a sec?

[17:55] <dudley> yep

[17:56] <Aankhen``> What is the value of INST6_ARCHLIB (it's towards the end)?

[17:56] <dudley> blib6/arch

[17:57] <Aankhen``> OK.

[17:57] <Aankhen``> Now a few others: INSTALLDIRS, PREFIX, PERLPREFIX, SITEPREFIX, VENDORPREFIX

[17:59] <dudley> INSTALLDIRS=site, PREFIX=/Users/dudley/pit, rest = $(PREFIX)

[17:59] <Aankhen``> Hum hum hum.

[18:00] <dudley> ah, here it is.

[18:00] <Aankhen``> Could you nopaste the `pure_site_install` and `pure_vendor_install` targets?

[18:00] <dudley> in Makefile.PL, pure_site_install gets its info from $config

[18:01] <dudley> sure, from Makefile or .PL?

[18:01] <Aankhen``> Makefile.

[18:02] <wolverian> what does TSa use to make those ASCII diagrams? heh.

[18:03] <gaal> TheDraw? :)

[18:03] <gaal> hello

[18:04] <Aankhen``> util/PugsConfig.pm appears to be the culprit.

[18:04] <pasteling> "dudley" at 70.179.213.96 pasted "Makefile snippets" (23 lines, 1.2K) at http://sial.org/pbot/12236

[18:04] <Aankhen``> What the heck is util/generate_config?

[18:05] <Aankhen``> dudley: Thanks.

[18:05] <dudley> np

[18:06] <gaal> Aankhen``, do you see the problem?

[18:06] <svnbot6> r6072 | iblech++ | * Usual svn props.

[18:06] <svnbot6> r6072 | iblech++ | * PIL2JS: Step 1/2 in integrating Perl6.MetaModel.

[18:06] <svnbot6> r6072 | iblech++ |   * PIL2JS.js: Removed Object.prototype.toPIL2JSBox, as it breaks

[18:06] <svnbot6> r6072 | iblech++ |     Perl6.MetaModel.

[18:06] <svnbot6> r6072 | iblech++ |   * PIL2JS.js: Modified PIL2JS.call to be able to call methods on Perl6.*

[18:06] <svnbot6> r6072 | iblech++ |     objects.

[18:07] <Aankhen``> gaal: Not really... am I supposed to?

[18:07] <Aankhen``> Hrm, those snippets don't appear to mention INST6_* anywhere.

[18:07] <gaal> you said PugsConfig is the culprit...

[18:08] <Aankhen``> One sec.

[18:08] <wolverian> gaal, hmm. thedraw looks nice :)

[18:08] <Aankhen``> I'm examining it.

[18:08] <gaal> wolverian: ol' BBS days :)

[18:08] <dudley> doh, wrong targets

[18:08] <wolverian> gaal, I'm too young. :/

[18:09] <pasteling> "dudley" at 70.179.213.96 pasted "more makefile snippets" (18 lines, 1K) at http://sial.org/pbot/12237

[18:09] <Aankhen``> Thanks, dudley. :-)

[18:11] <Aankhen``> dudley, did installing there overwrite any Perl 5 modules?

[18:11] <dudley> No, everything that got installed to my perl5 dir was under perl6/

[18:11] <Aankhen``> Ah, okay.

[18:12] <dudley> PugsConfig.pm is getting it's data from perl5's Config.pm, right?

[18:12] <Aankhen``> Appears to be.

[18:20] <autrijus> stevan: this gotta be the most wacky function I wrote today

[18:20] <autrijus> -- Bootstrapped MetaClass - suitable for applying to environment

[18:20] <autrijus> theos :: Object

[18:20] <autrijus> theos = metamorph demiurge

[18:20] <autrijus> ;)

[18:21] * autrijus proceeds to check things in

[18:21] <dudley> yay!

[18:23] <dudley> Metamodels are much sexier than build systems

[18:23] <svnbot6> r6073 | autrijus++ | * Undef is a Val... I think now

[18:24] <autrijus> my head is still spinning :)

[18:24] <Aankhen``> dudley: Definitely.

[18:25] <svnbot6> r6074 | autrijus++ | * New PIL runcore: First step of the Perl 6 Theology.

[18:25] <svnbot6> r6074 | autrijus++ |   Er, I mean, MetaModel...

[18:26] <dudley> did I just describe an abstract compsci concept as sexy?

[18:26] * dudley hangs his head in shame

[18:26] <stevan> dudley: it's okay, we are all friends here 

[18:26] <pasteling> "Aankhen``" at 203.101.5.19 pasted "Makefile.PL patch" (51 lines, 1.7K) at http://sial.org/pbot/12240

[18:27] <Aankhen``> dudley, could you try that patch?

[18:27] <dudley> I could.

[18:27] <Aankhen``> You do that. :-D

[18:27] <Aankhen``> And let me know if anything blows up.

[18:27] <stevan> autrijus: it's like surfing along the edge of a whirlpool, always soooo close to  being sucked down in

[18:27] <Aankhen``> After 10 minutes, that is.  I'll be gone till then.

[18:28] <dudley> It'll take a little longer than that :-)

[18:30] <autrijus> stevan: verily, verily

[18:32] <autrijus> ingy's slide24 rings so true.

[18:32] <autrijus> Perl 6 is a completely Insane Language: Perl 6 makes the easier things even easier / And the hard things become truly weird! / No good idea has been left behind... / It is a language that is almost impossible to implement.

[18:32] <stevan> :D

[18:33] <autrijus> but then in the next slide he shows how an even more sane group of people who ignored the impossibility anyway :)

[18:33] <autrijus> I mean, even more insane.

[18:33] <autrijus> freudian slip.

[18:34] <wolverian> ewwww at larry's zip() message on p6l :(

[18:35] <autrijus> wolverian: yeah, but it's consistent for quite some time now

[18:35] <wolverian> yes, I just hate overloading ;

[18:35] <autrijus> maybe we can learn from ocaml and separate statements with ;;

[18:35] <autrijus> then ; is free for other uses

[18:35] <autrijus> </troll>

[18:35] <Khisanth> ...

[18:35] <wolverian> nah. just use \n 

[18:36] <Khisanth> ewww no

[18:36] <wolverian> :) agreed.

[18:36] <Khisanth> ;; would be better, it's not like people aren't using long enough lines as it is

[18:37] <wolverian> I'd rather use a different multi slice character

[18:37] <autrijus> hmm, like, ;; :)

[18:37] <wolverian> or fix the signature system so that we can specify zip() without ; 

[18:38] <wolverian> well. yes. :) 

[18:38] <dudley> Aankhen``:  \$(INST6_SCRIPT) \$(DESTDIR)/man/man1 \\ 

[18:39] <Aankhen``> Yus?

[18:39] <dudley> shouldn't that be \$(INST6_SCRIPT) \$(DESTDIR)/bin \\ ?

[18:39] <Aankhen``> Urk, it should.

[18:39] <Aankhen``> Is the rest of it working right?

[18:39] <Khisanth> it's zip(@foo;@bar;@baz) ?

[18:40] <wolverian> yes.

[18:40] <wolverian> maybe we could use :: ... oh, that's taken :(

[18:40] <autrijus> strange as this seems, it's not quite as crazy as the `unit idea.

[18:40] <Khisanth> Unicode to the rescue!

[18:41] <autrijus> I'm still waiting for a spec on that one.

[18:41] <wolverian> I tentatively like `unit

[18:41] <Khisanth> zip(@foo'@bar'@baz) :P

[18:41] <wolverian> (hard to say more without knowing how they're constructed)

[18:41] <autrijus> nod. maybe it's just a shorthand for single-parameter constructors.

[18:42] <wolverian> that's almost what I guessed in my reply to Larry. :)

[18:42] <wolverian> (which went unanswered, I guess he hasn't yet designed it.)

[18:42] <autrijus> then I'd like it to be a module :)

[18:43] <wolverian> hm. do you have interface ideas?

[18:43] <coral> zip?

[18:44] <coral> autrijus++ # even more sane

[18:44] <autrijus> wolverian: coercion based, I think like http://search.cpan.org/~jettero/Math-Units-PhysicalValue-0.46/PhysicalValue.pm

[18:44] <wolverian> coral, zip(1..3;"a".."c") == (1,"a",2,"b",3,"c")

[18:44] <coral> oh, interleave()

[18:44] <wolverian> right.

[18:44] <coral> bad name, good idea

[18:44] <autrijus> you can't zip 1..Inf though. bad idea :-/

[18:44] <coral> weave() or braid() would be better

[18:44] <coral> heh

[18:44] <coral> wait, so zip doesn't handle iterators?

[18:45] <autrijus> no, it bias toward longer

[18:45] <autrijus> not the shorter

[18:45] <ayrnieu> hah, I just wrote INTERLEAVE in CL.  /me has never liked the 'zip' family.

[18:45] <coral> oog

[18:45] <coral> so what function DOES zip iterators?

[18:45] <wolverian> autrijus, hm, why? 

[18:45] <autrijus> wolverian: why what?

[18:45] <wolverian> why does it bias towards longer?

[18:45] <autrijus> I have no idea at all.

[18:46] <autrijus> larry did mention a possibility of a YY short-circuiting version

[18:46] <autrijus> that bias toward shorter

[18:46] <ayrnieu> that's unlike actual physical zippers, even :-)

[18:46] <wolverian> hmm, right.

[18:46] <autrijus> yeah, but repeated symbol carry short circuit metaphor

[18:46] * coral wonders what unicode for interleave is

[18:47] <wolverian> yen

[18:47] <autrijus> in any case, the Array.kv interface does reduce the need of 1..Inf zip

[18:47] <autrijus> ¥

[18:47] <wolverian> yes. 

[18:47] <Aankhen``> dudley: Ping. Any progress?

[18:47] <wolverian> but coral's question is interesting

[18:47] <wolverian> is there a builtin zip() for iterators?

[18:47] <coral> if i want to interleave two infinite sets, how do i?

[18:47] <coral> set1 = 1,3,5,7,...

[18:47] <coral> set2 = 2,4,6,8,...

[18:47] <Khisanth> use Set; ! :)

[18:47] <autrijus> =$set1 Y =$set2;

[18:48] <autrijus> and pray that it returns a generator from list fusion

[18:48] <dudley> Aankhen``:  it's installing to lib/* instead of lib/perl6/* 

[18:48] <Amnesiac> uhm....

[18:48] * Amnesiac sets a set

[18:48] * coral nearly parse fails, but makes a saving throw for random math knowledge

[18:48] <Aankhen``> To your Perl's lib/*? :-S

[18:49] <coral> incidentally what's the notation to create an infinite set of 0..inf by 2's

[18:49] <autrijus> 0..:by(2);

[18:49] <autrijus> 0...:by(2);

[18:49] <dudley> Oh, no, sorry, to the prefix I specified (/Users/dudley/pit)

[18:49] <coral> does that return a generator from list fusion?

[18:49] <Aankhen``> Whew!

[18:49] <Khisanth> not 0..Inf:by(2)?

[18:49] <Aankhen``> Don't scare me like that. :-P

[18:49] <autrijus> coral: yes, I'd say so

[18:49] <wolverian> Khisanth, that works too.

[18:49] <autrijus> Khisanth: that works too

[18:49] <Aankhen``> Khisanth: That could work.

[18:49] <wolverian> heh.

[18:49] <dudley> Aankhen``: Sorry :-S

[18:49] <Aankhen``> ... is easier, though.

[18:49] <autrijus> ok, it works triply

[18:49] <coral> ?eval =1..2 Y =3..4

[18:49] <evalbot6> Error: Can't use readline() or getc() in safemode. 

[18:49] <coral> eh?

[18:50] <wolverian> pugs's = is for handles only, I think

[18:50] <autrijus> coral: 1..2 is a generator already

[18:50] <coral> oh, ok

[18:50] <coral> ?eval 1..2 Y 3..4

[18:50] <evalbot6> (1, 3, 2, 4) 

[18:50] <Aankhen``> ?eval =(1..2) Y =(3..4)

[18:50] <evalbot6> Error: Can't use readline() or getc() in safemode. 

[18:50] <autrijus> = turns iterator into a list gen

[18:50] <Aankhen``> Ah.

[18:50] <coral> ?eval 1..:by(2) Y 2..:by(2)

[18:50] <evalbot6> () 

[18:50] <coral> ?eval 1...:by(2) Y 2...:by(2)

[18:50] <evalbot6> Error:  unexpected ":" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[18:50] <autrijus> coral: adverb to infix is :todo

[18:50] <coral> wow

[18:50] <coral> oh, ok

[18:51] <Aankhen``> I thought putter got that to work?

[18:51] <wolverian> hmm.

[18:51] * coral files away for "try again next week"

[18:51] <wolverian> (1... Y "a"...) :by(2)

[18:51] <Aankhen``> Or did he only get it working for certain categories of operators?

[18:51] <wolverian> should that work?

[18:51] <coral> so wouldn't zip be akin to .pick() for interleaved sets?

[18:51] <coral> like, a meld of the interleave and pick operators

[18:51] <coral> eh

[18:51] * coral shuts up

[18:51] <fglock> mmm - 2...:by(2) could be implemented using Span.pm or Recurrence.pm

[18:52] <autrijus> fglock: verily

[18:52] <wolverian> hmm. what AES would iterators go in, numerically?

[18:52] <wolverian> (and generators)

[18:52] <wolverian> (and laziness in general :)

[18:52] <autrijus> wolverian: it's all p6l

[18:52] <wolverian> (although I guess the last goes in every AES)

[18:52] <autrijus> and most of them post-hackathon

[18:52] <wolverian> autrijus, right, I'm wondering about a future AES

[18:53] <autrijus> S02

[18:53] <autrijus> S02:Lists

[18:53] <wolverian> right. thanks!

[18:54] <Aankhen``> dudley: I take it the patch didn't break anything?

[18:55] <dudley> Nope.

[18:55] <Aankhen``> OK.

[18:55] <Aankhen``> gaal: Ping.

[18:59] <gaal> pong

[18:59] <Aankhen``> Hola. :-)

[18:59] <Aankhen``> How're you feeling?

[18:59] <gaal> hey :)

[18:59] <gaal> feverish, but less so than earlier. :)

[19:00] <Aankhen``> Good.

[19:00] <Aankhen``> Er, one sec.

[19:01] <Aankhen``> D'oh.

[19:01] <Aankhen``> Hmm, hmm, hmm.

[19:01] <Aankhen``> Where is the Perl 6 stuff installed by default?

[19:01] <gaal> i never ran make install :)

[19:02] <Aankhen``> Could you check the Makefile and tell me what you see under the last pure_site_install?

[19:02] <gaal> # /usr/lib/perl6 i think?

[19:02] <Aankhen``> OK.

[19:02] <dudley> it depends on where your perl5 is

[19:03] <gaal> c:\perl6\site\lib on my box

[19:03] <dudley> PERL_PREFIX/lib/perl6

[19:03] <Aankhen``> I see.

[19:03] <Aankhen``> I need to provide a default DESTDIR.

[19:03] <Aankhen``> Trying to figure out how to do that.

[19:05] <iblech> stevan: Hi :) How do I add a new method to an already existing class with Perl6.MetaModel?

[19:07] <iblech> stevan: Ah, classobj.meta().add_method(...).

[19:14] <gaal> all this ping / pong on the channel.... http://crass.on.ru/flash/pingpong.html

[19:16] <Aankhen``> Oi!  Stop looking at videos of guys playing ping pong and try and think of a way to specify a sane default DESTDIR!

[19:17] <autrijus> stevan: my journal will be up soonish containing a very rough writeup

[19:17] <autrijus> if I'm seriously mistaken, please deliver me :)

[19:21] <autrijus> journal up. good night! /me waves &

[19:21] <Aankhen``> Sleep well!

[19:21] <gaal> Aankhen``, won't makemaker_args work, like you did for PREFIX?

[19:21] <Aankhen``> The problem is figuring out a sane default. :-)

[19:21] <gaal> or is the problem choosing what to put ther?

[19:21] <gaal> ah

[19:21] <dudley> isn't the current default sane?

[19:22] <gaal> the current default is empty

[19:22] <gaal> why should you change it though, A?

[19:22] <dudley> Oh, right. I mean installing to the same path as the currently installed perl

[19:23] <Aankhen``> gaal: My patch makes everything use $(DESTDIR).

[19:24] <gaal> url?

[19:24] <Aankhen``> http://sial.org/pbot/12240

[19:24] <Aankhen``> With a small change to fix INST6_SCRIPT being installed into /man/man1.

[19:25] <gaal> ah, instead of prefix, i see.

[19:25] <dudley> biab

[19:26] <gaal> how about / ?

[19:26] <Aankhen``> gaal: `DESTDIR=/`?  Are you serious?

[19:27] <gaal> if i understand what destdir does, it's prepended to PREFIX

[19:27] <gaal> if prefix used absolute paths, / is a noop

[19:28] <Aankhen``> But PREFIX doesn't enter the picture at this stage...

[19:29] <gaal> i guess i don't understand this then. why do you need destdir at all?

[19:31] <Aankhen``> Dunno, that's just what was there in the first place, so I used it.

[19:31] <gaal> what's wrong with the current default for it? ("")

[19:31] <gaal> (i'm taking this in small steps)

[19:32] <gaal> brb

[19:32] <Aankhen``> I'm not sure how that works when you have this: $(NOECHO) $(MOD_INSTALL) $(INST6_LIB) $(DESTDIR)/lib

[19:32] <Aankhen``> As I understand, that would install everything under /lib.

[19:32] <Aankhen``> (assuming DESTDIR wound up containing "")

[19:34] <gaal> ah, right, because you aren't using p5's paths

[19:34] <gaal> right

[19:35] <gaal> okay, maybe you should s/// p5's paths for your defaults?

[19:35] <Aankhen``> ?

[19:35] <gaal> isn't that how we generate blib6?

[19:36] <Aankhen``> Not as far as I know; blib6 seems to be hardcoded...

[19:36] <gaal> i'm looking for some p5 install dir in the makefile....

[19:38] <gaal> see add_path in PugsConfig

[19:39] <gaal> it peeks at p5 config and looks for a p6 equiv

[19:39] <Aankhen``> Ah, right.

[19:39] <Aankhen``> I'll work on that in a while.

[19:39] <Aankhen``> Gotta take a berak.

[19:39] <Aankhen``> Break, even.

[19:39] <gaal> so maybe you should keep using those configs, but do the tweaking there

[19:40] <gaal> i had better get to bed

[19:40] <gaal> good luck :)

[19:55] <iblech> YAY! Perl6.MetaModel mostly integrated into PIL2JS :)

[19:55] <iblech> stevan++ # Excellent work

[19:56] <iblech> stevan++ # Very readable code

[20:18] <stevan> iblech: ping

[20:18] <iblech> stevan: pong

[20:18] <stevan> autrijus: BTW - your journal is (in)sane and correct

[20:18] <stevan> iblech: I am glad the Metamodel is working for you

[20:19] <stevan> feel free to change anything in it you need to

[20:19] <iblech> Excellent work, really.

[20:19] <stevan> thank  youy

[20:19] <stevan> that one is not self bootstrapping though

[20:20] <stevan> however that will probably not affect your end much

[20:20] <iblech> Right.

[20:20] <stevan> where can I look to see the intergration?

[20:22] <svnbot6> r6075 | iblech++ | * t/builtins/arrays/elems.t: Added tests for the subroutine form of elems.

[20:22] <svnbot6> r6075 | iblech++ | * PIL2JS: Integrated the MetaModel.

[20:22] <svnbot6> r6075 | iblech++ |   * PIL::Subs, PIL::Params: method declarations emit proper addmethod calls.

[20:22] <svnbot6> r6075 | iblech++ |   * PIL2JS.js: Use the Perl6.MetaModel.

[20:22] <svnbot6> r6075 | iblech++ |   * README: Added section about the metamodel.

[20:22] <svnbot6> r6075 | iblech++ |   * Still outstanding: Perl 6's $obj.meta has to intercept .add_method so one

[20:22] <svnbot6> r6075 | iblech++ |     can store methodrefs (i.e., boxed Functions with special calling

[20:22] <svnbot6> r6075 | iblech++ |     conventions).

[20:22] <iblech> There you go :)

[20:22] <stevan> :)

[20:22] <stevan> iblech++ 

[20:22] <iblech> stevan++ # you did the real work :)

[20:22] <stevan> iblech++ # my work is but an island, your work is the bridge to the mainland

[20:23] <iblech> Most magic is in PIL2JS.js:PIL2JS.call (line 396)

[20:23] <iblech> stevan++ # but without the island, I couldn't build the bridge :)

[20:24] <stevan> iblech++ # :P

[20:24] <iblech> stevan++ # We'll have to stop this eventually :D

[20:24] <stevan> autrijus++ # without him, we would not be here

[20:24] <iblech> autrijus++ # Indeed

[20:24] <coral> autrijus++ # sane

[20:25] * stevan is really very very excited seeing the metamodel being integrated

[20:26] <iblech> It does need some work on the -CPIL side until we actually see the oo/ tests passing, I think.

[20:26] <stevan> ok

[20:27] <stevan> it wont handle all the oo tests

[20:27] <stevan> but it is the foundation for them I think

[20:27] <iblech> Right.

[20:28] <stevan> either that or my design is horribly off mark :P

[20:28] <stevan> ohhhh : PIL2JS.new_empty_class("Item");

[20:28] <stevan> bootstrapping into the type system :)

[20:29] <stevan> I am like a proud father today

[20:29] <stevan> my baby (metamodel) is going off to college

[20:29] <stevan> or kindergarten maybe is a better metaphor

[20:29] <iblech> :)

[20:31] <stevan> iblech: sehr gut # my german is very rusty

[20:31] <iblech> Thanks :)

[20:33] <svnbot6> r6076 | iblech++ | PIL2JS: PIL2JS.js: Added comments about the metamodel stuff.

[20:59] <svnbot6> r6077 | iblech++ | * PIL2JS: README: Minor fixes.

[20:59] <svnbot6> r6077 | iblech++ | * PIL2JS: PIL2JS.js: Unbreak methods on hashes and pairs. Note to self: Never

[20:59] <svnbot6> r6077 | iblech++ |   assign to .prototype, it breaks obj.constructor == checking.

[21:01] <Aankh|Clone> G'night.

[21:11] *** Maddingue__ is now known as Maddingue

[21:14] <stevan> http://use.perl.org/~Stevan/journal/  :P

[21:14] <stevan> today was a good day :)

[21:14] <stevan> of course now I have to do the $work I have been neglecting all day

[21:16] <dudley> yay stevan++

[21:16] * dudley hopes to catch up on the metaland festivities this weekend

[21:17] <stevan> dudley: I think the JS version is probably the most readable

[21:17] <stevan> mostly cause it does not bootstrap

[21:18] <dudley> cool...

[21:21] <dudley> of course, I'll probably end up lisping all weekend if the Art of MOP shows up tomorrow...

[21:32] <kolibrie> stevan: congratulations on the metamodel stuff

[21:32] <kolibrie> I've been too busy with $work to pay attention here

[22:14] <iblech> stevan: class Foo {...}; say Foo.ref; say ::Foo.ref; say Foo.meta.ref  # what should these print?

[22:39] <svnbot6> r6078 | iblech++ | * PIL2JS:

[22:39] <svnbot6> r6078 | iblech++ |   * PIL2JS.js: Added ::Routine, ::Block, etc.

[22:39] <svnbot6> r6078 | iblech++ |   * PIL2JS.js: Made classes stringify to "<class>" and SomeClass.ref to "Class"

[22:39] <svnbot6> r6078 | iblech++ |     (but only temporarily, awaiting correction).

[22:39] <svnbot6> r6078 | iblech++ | * t/builtins/strings/length.t, t/data_types/anon_block.t: Added try {} blocks

[22:39] <svnbot6> r6078 | iblech++ |   (pending p6l confirmation of undef.chars).

[22:39] <svnbot6> r6078 | iblech++ | * t/data_types/pair.t: Commented 6 tests (pending p6l confirmation of

[22:39] <svnbot6> r6078 | iblech++ |   $pair[0], $pair[1]).

[23:21] <svnbot6> r6079 | iblech++ | * New test: t/oo/methods/not_found_fails.t: ""method not found" errors "fail"

[23:21] <svnbot6> r6079 | iblech++ |   instead of "die"" (http://www.nntp.perl.org/group/perl.perl6.language/22598).

[23:21] <svnbot6> r6079 | iblech++ | * t/data_types/pair.t: $pair[0] does, according to Luke

[23:21] <svnbot6> r6079 | iblech++ |   (http://www.nntp.perl.org/group/perl.perl6.language/22597), not work (this

[23:21] <svnbot6> r6079 | iblech++ |   confirms my understanding), so s/is/dies_ok/.

[23:21] <svnbot6> r6079 | iblech++ | * t/builtins/strings/length.t: Changed test to reflect methods/not_found_fails.t.

[23:27] <iblech> Night all :)

