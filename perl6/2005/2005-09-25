[00:37] <xinming_Beijing> hmm, anyone here can tell me why pugs still doesn't support the class attribute initializing? hmm, Just like `class A { has $.a = 1 };

[00:41] <wilx> Because nobody has implemented it yet? :)

[00:52] <xinming_Beijing> wilx: I don't think so... This bug has been staying for a month. :-) I think It might be something related to MetaModule. But I am not sure.

[02:01] *** khisanth_ is now known as Khisanth

[03:35] <buu> Where is evalbot's source?

[03:37] <buu> Or at least, where could I find information about safe mode?

[03:47] <QtPlatypus> buu: Its distributed with pugs.

[03:49] <buu> Yeah, I found it.

[03:49] <buu> Ick, evalbot forks pugs to execute the code?

[03:50] <buu> Is there any equivalent of the Safe module for p6/pugs?

[03:55] <QtPlatypus> Not to my knowlige, my advice would be to abstract out what evalbot does into a seperate module.

[03:56] <buu> Er

[03:56] <buu> I prefer not to do that.

[03:57] <buu> Mostly I prefer not to fork.

[05:01] <svnbot6> r7128 | stevan++ | Perl6::MetaModel 2.0 -

[05:01] <svnbot6> r7128 | stevan++ | * added stub POD to all the files in lib/ ... documentation to come

[05:01] <svnbot6> r7128 | stevan++ | * added the * (root) package then added $::Class, $::Object, $::Package

[05:01] <svnbot6> r7128 | stevan++ |   $::Module and $::Role into it.

[05:01] <svnbot6> r7128 | stevan++ | * added the ::Main package 

[05:01] <svnbot6> r7128 | stevan++ | * class() and role() in the Perl6::MetaModel now install all classes into

[05:01] <svnbot6> r7128 | stevan++ |   the * namespace (which actually is not always correct, but works for now) 

[05:54] <nothingmuch> rafl: ping

[07:08] <svnbot6> r7129 | Darren_Duncan++ | /ext/Locale-KeyedText : resync with newest perl 5 version changes

[08:05] <nothingmuch> hi scook0 

[08:05] <nothingmuch> did you see the impl of your force_async thing?

[08:05] <scook0> howdy nothingmuch

[08:05] <scook0> no?

[08:05] <nothingmuch> on the mailing ilst

[08:06] <scook0> oh, from the other day?

[08:06] <scook0> I saw it, but kind of glossed over it at the time -- I'll read it again now...

[08:07] <nothingmuch> http://groups.google.com/group/perl.perl6.language/browse_frm/thread/81dde1c00715df07/3ec91300b4f107b7?lnk=st&q=20050921072440.GH5797@woobling.org&rnum=1#3ec91300b4f107b7

[08:07] <nothingmuch> http://groups.google.com/group/perl.perl6.language/browse_frm/thread/81dde1c00715df07/3ec91300b4f107b7?lnk=st&q=20050921072440.GH5797@woobling.org&rnum=1#3ec91300b4f107b7

[08:07] <nothingmuch> hmm

[08:07] <nothingmuch> oh, i see

[08:07] <nothingmuch> the links are not really linkable

[08:07] <nothingmuch> http://groups.google.com/group/perl.perl6.language/tree/browse_frm/thread/81dde1c00715df07/5d8110655531e6c3?rnum=1&q=20050921072440.GH5797@woobling.org&_done=%2Fgroup%2Fperl.perl6.language%2Fbrowse_frm%2Fthread%2F81dde1c00715df07%2F3ec91300b4f107b7%3Flnk%3Dst%26q%3D20050921072440.GH5797@woobling.org%26rnum%3D1%26#doc_3ec91300b4f107b7

[08:08] <nothingmuch> http://xrl.us/hqm4

[08:10] <nothingmuch> autrijus: ping

[08:10] * nothingmuch realized he has a big question in there

[08:10] <nothingmuch> &OUTER::yield(@stuff); # how do we do this? Maybe $?CALLER_CONTINUATION.yield? 

[08:14] <scook0> nothingmuch: I'm not really following it, sorry :(

[08:14] <nothingmuch> buffer_lazy is a generator for a lazy list

[08:14] <nothingmuch> it takes a lazy list

[08:14] <nothingmuch> and returns it eventually

[08:14] <nothingmuch> but it keeps an array

[08:15] <nothingmuch> when there are no elements in it's array it takes an element from the lazy list directly

[08:15] <nothingmuch> when there are elements in the array it returns the first one from there

[08:16] <nothingmuch> whenever the array is smaller than $threshold elements, it also do an async { } that fetches more elements from the lazy list into the array

[08:16] <scook0> hang on, it's a generator? so it gets called from the start each time someone wants to fetch an element?

[08:16] <nothingmuch> yep

[08:16] <scook0> (that's what was confusing me on first reading)

[08:17] <nothingmuch> err, wait

[08:17] <nothingmuch> i have a bug

[08:17] <scook0> is that sort of stuff specced somewhere?

[08:17] <nothingmuch> 'yield shift @buffer' is bad

[08:17] <nothingmuch> the whole function should be a loop

[08:17] <nothingmuch> my @buffer

[08:17] <nothingmuch> state Sem $collecting;

[08:18] <scook0> that's what I thought

[08:18] <nothingmuch> while (@lazy) { ....; yield shift @buffer; }

[08:18] <scook0> otherwise the meaning of `yield` would have to be utterly insane

[08:18] <nothingmuch> and state Sem $collecting should be 'my Sem $collecting'

[08:18] <scook0> it makes a lot more sense to me now

[08:18] <nothingmuch> sorry ;-)

[08:21] <scook0> have you had a look at luqui's theory stuff?

[08:21] <nothingmuch> yes

[08:21] <nothingmuch> but not the new proposal

[08:21] <scook0> it's *very* ambitious

[08:22] <scook0> to be honest, I don't think it will be accepted, on account of changing everything too radically

[08:22] <scook0> but there's a lot of good stuff in there

[08:22] * nothingmuch hopes it does

[08:22] <nothingmuch> there is no reason for it not to be

[08:22] <nothingmuch> it's a superset of the current definition

[08:23] <scook0> are you talking about the old stuff, or the new stuff?

[08:23] <nothingmuch> what he was talking about for the past 2 weeks or so

[08:23] <nothingmuch> damnit!

[08:23] <nothingmuch> this bug is reproducing 30% of the time

[08:24] <nothingmuch> where 70% is the times that i have had a breakpoint on the problematic code, and didn't hit continue by accident

[08:24] <scook0> nasty

[08:26] <scook0> nothingmuch: any recruits for Blondie?

[08:26] <nothingmuch> not yet

[08:26] <nothingmuch> i haven't worked on it in the weekend either

[08:26] <nothingmuch> had a few obligations

[08:27] <nothingmuch> wnat to join the fun?

[08:38] <scook0> as much as I'd love to help, I:

[08:38] <scook0> a) don't have the time, and

[08:38] <scook0> b) am lousy at P5 :)

[08:45] <nothingmuch> =)

[08:47] <scook0> is it essentially a test-bed for your 'circular prelude' idea (and similar stuff)?

[08:48] <nothingmuch> yes, that and type inferrencing in a dynamic/static language mix

[08:49] <nothingmuch> The upshot is that you can easily delegate an arbitrary argument list to

[08:49] <nothingmuch> another function:

[08:49] <nothingmuch>     sub foo (*$args) { bar(*$args) }   # call bar with whatever args foo

[08:49] <nothingmuch>                                        # was called with

[08:49] <nothingmuch> luqui++

[08:49] <nothingmuch> luqui++

[08:49] <nothingmuch> luqui++

[08:50] <scook0> yes, I thought that was very clever

[08:50] <scook0> and a great re-purposing of the slurpy scalar

[08:50] <nothingmuch> yep

[08:50] <scook0> (which I thought was a little dubious)

[08:50] <scook0> and it's good that he came up with something to replace it too

[08:51] <nothingmuch> can you do a slurpy unpack?

[08:51] <nothingmuch> sub tail (*[$head, @tail]) { @tail }

[08:51] <nothingmuch> tail(1, 2, 3); [ 2, 3 ] ?

[08:52] <scook0> `sub first (*[ $x, *@xs ]) { $x }`

[08:52] <scook0> (from the doc)

[08:54] <scook0> one thing I don't get, though, is this:

[08:54] <scook0> "When you extend a union, you create a superset (but still a subtype)."

[08:54] <scook0> I'm pretty sure that union subtypes have to be SUBsets

[08:55] <nothingmuch> oh, nice.

[08:55] <nothingmuch> i still have to sync with that terminology

[08:55] <scook0> subtypes?

[08:56] <scook0> or model/theory/factory/generator etc?

[08:56] <nothingmuch> subtypes and supersets WRT theories

[08:56] <nothingmuch> i keep getting confused with which means what

[08:57] <scook0> maybe you should read TaPL :)

[08:57] <nothingmuch> yes, the moment i get it =)

[08:57] <scook0> so if S <: T  # S is a subtype of T

[08:58] <scook0> then any 'receiver' expecting an S can safely be given a T

[08:58] <scook0> uh, thinko

[08:58] <freakazoid> hiho

[08:58] <scook0> other way around

[08:59] <nothingmuch> vice versa

[08:59] <nothingmuch> hi freakazoid 

[08:59] <scook0> (see how confusing this is!)

[08:59] <freakazoid> hi nothingmuch 

[08:59] <nothingmuch> yep

[08:59] <scook0> so if I expect Type, you can give me Subtype without invalidating my assumptions

[08:59] <nothingmuch> what's up freakazoid ?

[08:59] <nothingmuch> define superset

[09:00] <scook0> wrt unions?

[09:00] <nothingmuch> no wait, don't bother

[09:00] * nothingmuch is not at even 30% concentration

[09:00] <nothingmuch> this bug is driving me nuts, and I ate something bad so i'm not really myself either

[09:00] <scook0> oh well

[09:01] <scook0> do you know what a superset is in general?

[09:01] <nothingmuch> in set theory?

[09:01] <nothingmuch> eys

[09:01] <nothingmuch> yes

[09:01] <scook0> do you know what a (tagged) union type is?

[09:01] <nothingmuch> nope

[09:01] <nothingmuch> no idea what tagging is

[09:01] <scook0> hmm

[09:02] <nothingmuch> and i'm not sure i know what a union type is either

[09:02] <nothingmuch> i could make an educated guess

[09:02] <scook0> I'm sure you know what I'm talking about; I just have to find the right words to bridge the gap

[09:02] <nothingmuch> which is either the C idea of union (probably not)

[09:02] <nothingmuch> or the subtype that is two types together

[09:02] <nothingmuch> or the supertype that is either type a or type b

[09:02] <scook0> do you know about defining datatypes in Haskell?

[09:02] <nothingmuch> yep

[09:02] <nothingmuch> e.g. data Foo = Bar | Gorch ?

[09:03] <scook0> or `data List a = Nil | Cons a (List a)`

[09:03] <nothingmuch> yes

[09:04] <nothingmuch> so Nil a and Cons a (List a) are subtypes of List?

[09:04] <scook0> I'm pretty sure 'union' is just luqui's Perl-friendly name for a Haskell-style data type

[09:04] <nothingmuch> and List is their union?

[09:04] <nothingmuch>  okay

[09:04] <scook0> umm, I don't think so

[09:05] <scook0> give me a sec to think of a good example

[09:06] <scook0> data Fruit = MkApple Apple | MkOrange Orange

[09:07] <scook0> Fruit is a 'union' which can hold either an Apple or an Orange

[09:08] <nothingmuch> hmm

[09:08] * nothingmuch sees it slightly differently

[09:08] <nothingmuch> since Fruit is boxed

[09:08] <nothingmuch> into two different constructors

[09:08] <scook0> yes

[09:08] <nothingmuch> so it can't really hold either an Apple or an Orange, it can hold an apple xor an orange

[09:09] <nothingmuch> okay

[09:09] <scook0> that's why it's a 'tagged' union

[09:09] <scook0> because it has the MkApple tag, or the MkOrange tag

[09:09] <nothingmuch> oh

[09:09] <nothingmuch> i see

[09:09] <scook0> (I'm not really following Haskell terminology, btw)

[09:10] <scook0> anyway, let's say I define another data type:

[09:10] <scook0> data Food = MkApple Apple | MkOrange Orange | MkBread Bread

[09:10] <scook0> notice that Food is a 'superset' of Fruit

[09:11] <nothingmuch> aha

[09:11] <scook0> because it has all the same constructors (plus more)

[09:11] <nothingmuch> makes sense

[09:11] <nothingmuch> does haskell allow that?

[09:11] <scook0> no, I don't think so

[09:12] <scook0> but let's imagine we're working in a language that does allow it

[09:12] <nothingmuch> yeah

[09:12] <scook0> you'll notice that any function taking Food as an argument

[09:12] <scook0> should be perfectly happy with receiving a Fruit

[09:12] <nothingmuch> can also take Fruit

[09:12] <scook0> exactly

[09:13] <nothingmuch> okay

[09:13] <nothingmuch> so what was the confusion again?

[09:13] <scook0> so Fruit <: Food

[09:14] <nothingmuch> fruit loves food

[09:14] <scook0> Fruit is a subtype of Food

[09:14] <nothingmuch> ;-)

[09:15] <scook0> luqui appears to be claiming the opposite

[09:15] <scook0> (from what I can tell, anyway)

[09:15] <nothingmuch> maybe it's just a wordo

[09:15] <nothingmuch> i'm lacking context for that sentance

[09:15] <nothingmuch> so when I get to it i'll state my opinion =)

[09:15] <scook0> oh

[09:15] <scook0> where are you up to?

[09:16] <nothingmuch> fixing a bug

[09:16] <nothingmuch> eating bread to pass nausea

[09:16] <nothingmuch> considering the rest of my lunch but waiting it out

[09:17] <scook0> anyway, I'll ask him when I next see him on IRC

[09:17] * nothingmuch opens the services panel for the nth time

[09:23] * nothingmuch doesn't know why he is maintaining code in C++ that does windows API calls when he doesn't really know either

[11:16] <svnbot6> r7130 | autrijus++ | * add link to cufp2005.pdf

[11:36] <nothingmuch> autrijus: cute talk

[11:36] <nothingmuch> a bit like a psychadellic movie witout the talking, I guess

[11:58] <wolverian> what is the link? :)

[12:00] <masak> http://no.perlcabal.org/~autrijus/cufp2005.pdf

[12:03] <nothingmuch> i hate windows

[12:04] * nothingmuch is trying to deal with service handle leaks across process space

[12:04] <nothingmuch> appearantly some kind of caching is making the object not die

[12:04] <nothingmuch> because the same code when run in it's own debugger does not leak

[12:04] <nothingmuch> but when exec'd by another process does leak

[12:04] * nothingmuch cries

[12:06] * masak hugs nothingmuch

[12:06] <masak> just don't use windows

[12:06] <nothingmuch> it's not me, it's our clients

[12:06] <masak> :(

[12:06] <nothingmuch> this is the horrible horrible instller

[12:07] <nothingmuch> that i have to maintain

[12:08] <masak> i've never heard anyone say "oh, this source code is so great! it must be written by a genious"

[12:08] <masak> possibly excepting autrijus' and damian's stuff

[12:08] * nothingmuch thinks damian's code is not great at all

[12:09] <nothingmuch> have you ever tried reading it? ;-)

[12:09] <masak> yes :)

[12:09] * nothingmuch has read some great code in his life

[12:09] <masak> but i was talking about what people say about it

[12:09] <masak> nothingmuch: really, what code?

[12:09] <nothingmuch> some stuff on CPAN

[12:09] <nothingmuch> let me think

[12:11] * masak is reading "Perl Best Practices" right now

[12:12] <masak> most things seem to make a lot of sense

[12:14] <nothingmuch> yeah

[12:14] <masak> most tips boil down to "don't be clever, be clear. write maintainable code"

[12:15] <nothingmuch> the problem is that most people say "damian says"

[12:15] <nothingmuch> perlmonks is filled with "damian said I should always do yadda"

[12:15] <nothingmuch> "but i have a situation where yadda is not so good"

[12:15] <masak> that's never a good reason to always do something :)

[12:15] <nothingmuch> "am I allowed to not do yadda just this once, even though Damian said not to?"

[12:15] <nothingmuch> i'm sure it's filled with wonderful advice

[12:16] <masak> people who ask that have already given up their free will to someone else

[12:16] <nothingmuch> but i think that the community has not been accepting it with enough maturity, and that it has actually caused some harm

[12:16] <nothingmuch> right

[12:16] <masak> the world is full of folks who don't want to think

[12:16] <QtPlatypus> I've read stuff from Damian where he say's its not ment to be used that way.

[12:16] <masak> he says it in the book too

[12:17] <masak> but maybe people don't read introductions :)

[12:17] <nothingmuch> i bet he did, but I doubt it matters =)

[12:17] <nothingmuch> right

[12:17] <QtPlatypus> Fundermentalizim seems to taint all things.

[12:17] <nothingmuch> i think i know why I can't think of any good code

[12:17] <nothingmuch> i haven't been traumatized by it

[12:17] <masak> :)

[12:18] <masak> that's just sad

[12:18] <masak> you only remember bad code

[12:18] <masak> because it's bitten you

[12:18] <nothingmuch> heh =)

[12:18] <nothingmuch> well, there's lots of good code here: http://search.cpan.org/~nuffin

[12:18] <nothingmuch> ;-)

[12:18] <masak> lol

[12:19] <masak> you're the modest one

[12:19] <nothingmuch> i think i judge good code by how hard it was to modify it so it gets what I want done

[12:20] <masak> then it's entirely possible that the programming community as a whole just isn't there yet

[12:20] <masak> and never will be

[12:20] <masak> reusability is durn hard

[12:20] <nothingmuch> i think it's there

[12:20] <nothingmuch> there are examples of code which I think is good since i never had to touch it's guts

[12:20] <nothingmuch> like Test::Deep, for example

[12:21] <nothingmuch> the interface is so good that it does everything i want without being bloated

[12:21] <masak> today, yes

[12:22] <nothingmuch> today?

[12:22] <masak> today you don't need to poke inside Test::Deep

[12:22] <nothingmuch> ah

[12:22] <masak> because it does everything you want

[12:22] <nothingmuch> well, it has very flexible semantics

[12:22] <nothingmuch> it's a pattern matching language for deep structures

[12:23] <masak> it might still not be very reusable, though it gets the first half (flexible interface) right

[12:23] <nothingmuch> and it's good enough because it offers abstraction at a level slightly higher than most patterns should use

[12:23] <nothingmuch> right... i'm not claiming anything about it's guts

[12:23] <nothingmuch> i've yet to see them

[12:23] <masak> the second half (maintainable code) is just as important, if not more so

[12:23] <nothingmuch> maybe they're a delight

[12:23] <masak> maybe

[12:23] <nothingmuch> maybe they aren't

[12:24] <masak> there was a dream a couple of years ago

[12:24] <masak> probably still is

[12:24] <masak> about software being like lego bricks

[12:24] <nothingmuch> what dream?

[12:24] <nothingmuch> ah

[12:24] <masak> component-based programming

[12:24] <nothingmuch> one reason I like autrijus's code (perl code) is that it's very non-pretentious

[12:25] <masak> do you have a good example?

[12:25] <nothingmuch> for example http://search.cpan.org/~autrijus/HTML-FromANSI-1.01/

[12:25] <nothingmuch> i needed to do a very weird thing with it

[12:25] <nothingmuch> as opposed to what it does at the moment

[12:25] <nothingmuch> instead of displaying a single screen, i needed a "termnal" that grows indefinitely

[12:25] <nothingmuch> the way it works is it uses the vtterm emulator on CPAN

[12:26] <nothingmuch> and then renders it's state to HTML

[12:26] <nothingmuch> i needed an incremental interface to display progress from colored output as HTML

[12:26] <masak> the code looks very clean

[12:26] <nothingmuch> and I needed the whole log to be displayed

[12:26] <nothingmuch> right... it's not very flexible interface wise

[12:26] <nothingmuch> but it's so simple that you can reuse it all the same

[12:27] <nothingmuch> i broke encapsulation, ofcourse

[12:27] <nothingmuch> which is a nono

[12:27] <nothingmuch> but I don't care

[12:27] <masak> that's what i mean

[12:27] <nothingmuch> the problem was:

[12:27] <nothingmuch> sub ansi2html {

[12:27] <nothingmuch>     my $vt = Term::VT102->new(

[12:27] <nothingmuch> 	cols	=> $Options{cols} || 80,

[12:27] <nothingmuch> 	rows	=> $Options{rows} || count_lines(@_),

[12:27] <nothingmuch>     );

[12:27] <nothingmuch> i needed it to be a factory method

[12:28] <nothingmuch> so that I could use my own hack, Term::VT102::AutoExtending, which had no concept of rows

[12:28] <masak> reusability, *real* reusability, is using those lego bricks without breaking encapsulation

[12:28] <nothingmuch> right

[12:28] <masak> i don't think it ever will happen

[12:28] <nothingmuch> one lesson learned from this is that I always use factory methods in my classes

[12:28] <nothingmuch> i would say $self->term

[12:28] <masak> that's why perl comes to the rescue, with its lawlessness :)

[12:28] <nothingmuch> and sub term { shift->term_class->new() }

[12:29] <nothingmuch> and this makes orthogonal overriding of this specific feature easy

[12:29] <masak> ah, ok

[12:29] <nothingmuch> you can change the class, or the instantiation, or both

[12:29] <masak> yes

[12:29] <nothingmuch> what frustrates me about static languages and closed source in general is that things like this are not the de-facto standard

[12:29] <nothingmuch> autrijus obviously needed to get the job done quickly

[12:29] <nothingmuch> and he did it well, and put up his code for others to use

[12:30] <nothingmuch> i am 99% sure he'll accept a refactoring patch, btw, but that's besides the point

[12:30] <masak> yes

[12:30] <nothingmuch> i was able to take his code and use it even though it was not 100% useful for me

[12:30] <nothingmuch> and i don't expect any code to be 100% useful for me, without infinite financial backing

[12:30] <masak> right

[12:30] <rafl> nothingmuch: pong

[12:31] <nothingmuch> rafl: did you find the image i sliced up for you?

[12:31] <rafl> nothingmuch: No, would you give me the URL again?

[12:31] <nothingmuch> http://nothingmuch.woobling.org/7peoples.png

[12:34] <masak> how's STDERR spelled in p6?

[12:34] <nothingmuch> $*ERR i would think

[12:34] <nothingmuch> see also $*OUT

[12:34] <masak> thx

[12:34] <masak> yes, *ERR, by S02

[12:35] <masak> err, $*ERR

[12:38] <rafl> nothingmuch: Thank you!

[12:48] * nothingmuch wonders why there is even 

[12:48] <nothingmuch> a discussion on the stringification/interpolation thread

[12:48] <nothingmuch> i haven't heard anyone say it was a good idea except for damian

[12:49] <masak> what, to differentiate between interpolation and stringification?

[12:49] <nothingmuch> yep

[12:49] <masak> no, me neither

[12:51] <nothingmuch> masak - Algorithm::Bucketizer was very nice to hack

[12:51] <nothingmuch> reusable, flexible, precise

[12:51] <masak> i'll go have a look

[12:51] <scook0> nothingmuch: off to bed; see you later

[12:51] <nothingmuch> ciao!

[12:53] <masak> yeah, Algorithm::Bucketizer looks real neat

[12:53] <masak> some code, and lots of docs

[12:53] <masak> all clearly written

[12:53] <nothingmuch> i forgot what kind of fucked up bucket implementation i needed

[12:53] <nothingmuch> but it handled it very gracefully

[12:54] <nothingmuch> ah

[12:54] <nothingmuch> i needed variable sized buckets

[12:54] <masak> you're crazy

[12:54] <nothingmuch> i had variadic resources

[12:54] <nothingmuch> and I needed to binpack them

[12:54] <nothingmuch> and it allowed me to use a generator

[12:54] <nothingmuch> so that it requests the next bucket each time

[12:55] <masak> sounds nifty

[12:55] <nothingmuch> it was a wonderful experience in that respect 

[12:55] <nothingmuch> SQLT otoh ;-)

[12:55] <nothingmuch> i gave up trying to use it because it was so not reusable

[12:56] <nothingmuch> it's biggest limitation is that it's filled with singletons by behavior (not definition)

[12:56] <nothingmuch> that is, classes which can only be successfully instantiated once

[12:56] <masak> ouch

[12:56] <nothingmuch> due to data structures being ruined

[12:56] <masak> nasty

[12:56] <nothingmuch> it also has huge subs  of interpolation madness

[12:56] <nothingmuch> i wanted to create a schema filled with temporary tables

[12:56] <nothingmuch> i had to use a s///

[12:57] <nothingmuch> i also had to split the statements to actually pass them to $dbh->do

[12:57] <masak> why?

[12:58] <nothingmuch> i think the sqlite driver didn't like to get semicolons in the statements

[12:58] <nothingmuch> it needed a statement per do

[12:58] <masak> :(

[12:58] <nothingmuch> the project was very fun though

[12:58] <nothingmuch> you create a schema in terms of sqlfairy schema objects

[12:58] <nothingmuch> with some sugary subroutines with nice prototypes, so that it slightly resemebles the declarative nature of real DDL

[12:59] <nothingmuch> then this stuff is used to generate CDBI classes at runtime

[12:59] <nothingmuch> optionally creating the actual tables in the DB.

[12:59] <nothingmuch> the gain was that production and testing used the same schema

[12:59] <nothingmuch> so tests could run on a temporary sqlite.

[13:00] <nothingmuch> while production was on postgres

[13:00] * masak is translating Getopt::Long to Perl 6 right now

[13:00] <nothingmuch> with no code changes except 'sub dsn { $0 =~ /\.t/ ? "test dsn" : "production dsn" } # in the config lib

[13:00] <nothingmuch> masak++

[13:00] <masak> and learning some Perl5 along the way

[13:01] <nothingmuch> you dunno perl 5?

[13:01] <masak> not 100%

[13:01] <masak> i've used it a lot lately

[13:01] <nothingmuch> how did you wind up here? haskell?

[13:01] <masak> no, following general p6 development

[13:01] <nothingmuch> ah

[13:01] <masak> i don't know any haskell

[13:01] <nothingmuch> what's your background?

[13:01] <masak> webmaster, programmer, bioinformatics student

[13:02] <nothingmuch> in perl 5?

[13:02] <masak> no, i just use perl5 on the side :)

[13:02] <masak> whenever i get the change

[13:02] <masak> chance*

[13:02] <nothingmuch> so what did you do those stuff with?

[13:02] <masak> those stuff?

[13:02] <nothingmuch> webmaster, programmer, bioinformatics student

[13:02] <masak> the two first: xml/xslt

[13:03] <masak> the two last: java, mainly

[13:03] <nothingmuch> you poor thing ;-)

[13:03] <masak> i know :)

[13:03] <masak> but it's a living

[13:03] <nothingmuch> hehe

[13:03] <masak> and it gives me something to complain about :)

[13:03] <nothingmuch> http://jobs.perl.org

[13:03] <nothingmuch> complaining is very important

[13:04] <masak> the url: ah, didn't know about that

[13:04] <nothingmuch> =)

[13:04] <masak> right now i'm not looking for more to do, though :)

[13:04] <masak> but thx

[13:05] <masak> i'm really buying into $larry's talk about perl being a postmodern language, btw

[13:05] <masak> and i do think it's a strength

[13:05] <masak> perl is not built to last, it's built to adapt

[13:06] <masak> especially perl 6 :)

[13:06] <nothingmuch> =)

[13:06] <nothingmuch> it is

[13:06] <masak> is there a way to p6ify this expression:

[13:06] <masak> $opt = $+ if $opt =~ /^$prefix+(.*)$/s;

[13:07] <nothingmuch> i think the only area perl 5 is lacking is the hard edge between inside and out (c, and perl)

[13:07] <masak> or should i just leave it as it is?

[13:07] <nothingmuch> and the fact that there is false huffmanization

[13:07] <masak> yes

[13:07] <nothingmuch> for example 'my $self = shift' 1000 times is not very huffy ;-)

[13:07] <masak> :)

[13:07] <nothingmuch> hmm

[13:08] * nothingmuch forgot what $+ is

[13:08] <masak> last paren match

[13:08] <masak> i had to look it up too

[13:08] <nothingmuch> ah

[13:08] <masak> that is, the paren in the postfix if

[13:08] <masak> not very intuitive by me

[13:08] <masak> my first instinct was to look at the line above...

[13:08] <nothingmuch> i would actually do $opt =~ s/^$prefix+//s;

[13:08] <masak> yes, i think so too :)

[13:09] <masak> thx

[13:09] <nothingmuch> and I'd use /x too to separate ^ from $

[13:09] <nothingmuch> $opt =~ s/^ $prefix+//sx;

[13:09] <nothingmuch> that way it's more readable that $prefix is an interpolated variable

[13:09] <masak> this is p6

[13:09] <masak> you don't need /x

[13:09] <nothingmuch> i'd also make a point of qr//ing $prefix, so that it's obvious what it'd be used as later

[13:09] <nothingmuch> the source in question is copypasted from perl5, isn't it?

[13:10] <nothingmuch> oh wait, you asked me to p6ify ;-)

[13:10] <masak> yes :)

[13:10] <nothingmuch> so what's in $prefix?

[13:10] <nothingmuch> a pattern? or a literal?

[13:10] <masak> a literal

[13:10] <masak> $opt ~~ s/^ $prefix+ //;

[13:10] <nothingmuch> yep

[13:10] <masak> ...maybe

[13:10] <nothingmuch> i like it

[13:11] <wolverian> $opt.subst(/^ $prefix+ /, ""); # ;)

[13:11] <masak> ;)

[13:12] <masak> i would say the postfix if was an overreaction in the first place

[13:12] <masak> since the regex would just fail silently if nothing matched

[13:13] <masak> ah, and I'll throw in a P5 too, just in case

[13:14] <masak> the original author has a few off-by-one errors here and there

[13:14] <masak> at least i think so

[13:14] <masak> maybe i should contact him

[13:14] <nothingmuch> are you porting it 1:1?

[13:14] <nothingmuch> or are you basing off it?

[13:14] <masak> err... i was going for 1:1

[13:14] <masak> but gaal had so many great ideas

[13:15] <masak> so i'm implementing some of them

[13:15] <masak> and i think i'll correct the obvious errors

[13:15] <nothingmuch> how long is Getopt::Long?

[13:16] <masak> like, he checks @ary > 0 before looking inside $ary[1]

[13:16] <masak> it's long

[13:16] <nothingmuch> do you think you could break it apart to several modules somehow?

[13:16] <masak> maybe, i haven't thought about it

[13:16] <masak> i just want it to pass the tests in the p5 version

[13:16] <nothingmuch> hmm

[13:17] <masak> which i have already ported and comitted

[13:17] <nothingmuch> the problem with Getopt and friends is that they are too big and not reusable enough

[13:17] <nothingmuch> they don't share any cod

[13:17] <nothingmuch> e

[13:17] <nothingmuch> did you hear my event parser rant?

[13:17] <masak> right

[13:17] <masak> no, i didn't

[13:17] <nothingmuch> okay

[13:17] <masak> oh, wait

[13:17] <masak> yes, i think so

[13:18] <masak> you wanted layered getopt, yes?

[13:18] <nothingmuch> yes

[13:18] <masak> that's beyond me

[13:18] <masak> i get the idea

[13:18] <nothingmuch> for example, clustered switches should replace the switch handler

[13:18] <nothingmuch> to create several switch events

[13:18] <nothingmuch> etc etc

[13:18] <masak> yes, i know

[13:18] <masak> it's really nice

[13:18] <masak> but it's not getopt:long

[13:18] <masak> at least not mine :)

[13:19] <nothingmuch> well, i would be very happy for observations on how you think getopt::long could be implemented in terms of event parsing

[13:19] <nothingmuch> or rather, where it wouldn't work

[13:19] <masak> i'll think about it

[13:19] <masak> as i translate

[13:20] <masak> right now i'm trying to break down work so i have something (half-done) to commit

[13:22] <nothingmuch> goody

[13:26] <masak> gaal and i already agreed on a non-trivial enhancement to getopt::long

[13:27] <nothingmuch> which one?

[13:27] <masak> returning the option hash/object instead of just a 1 if all went well

[13:27] <nothingmuch> ah yes

[13:27] <nothingmuch> boolean status return is never quite enough

[13:27] <nothingmuch> exceptions should be used for failure

[13:27] <masak> and disallowing non-hash use of getopt::long

[13:27] <masak> yes, exceptions

[13:27] <nothingmuch> and compound result for summary =)

[13:28] <nothingmuch> masak++

[13:28] <masak> where do i read more about fail?

[13:28] <masak> :)

[13:28] * nothingmuch forgets

[13:28] <nothingmuch> i think that s 04

[13:28] <masak> oki

[13:28] <masak> i'll have a look

[13:28] * nothingmuch really hopes that was the last handle leak plugged

[13:28] * nothingmuch also hopes that the next time he meats the author of this code he'll have a hatchet close by

[13:29] <nothingmuch> err... meats

[13:29] <masak> :)

[13:29] <nothingmuch> freudian slip, eh?

[13:29] <masak> fwiw, i like your p6l post

[13:29] <nothingmuch> HAH! fixed

[13:29] <nothingmuch> which one?

[13:30] <masak> the last one about interpolation/stringification

[13:30] <nothingmuch> ah

[13:34] <gaal> hello.

[13:35] <nothingmuch> hi

[13:35] <gaal> masak: some verbiage on 'fail' here: http://www.livejournal.com/users/gaal/170284.html

[13:36] <gaal> nothingmuch: either the fail builtin or Test.pm will have to back off :-)

[13:36] <nothingmuch> hmm?

[13:36] <masak> gaal: thx

[13:36] <nothingmuch> back off?

[13:37] <gaal> Test::fail and fatal::fail

[13:37] <gaal> one of them should likely be renamed.

[13:38] <nothingmuch> ah

[13:38] <nothingmuch> Test::fail, i think

[13:38] <nothingmuch> it's not as generic

[13:38] <nothingmuch> since we have variadic args:

[13:38] <nothingmuch> ok()

[13:38] <nothingmuch> nok()

[13:38] <nothingmuch> pass and fail

[13:39] <gaal> i don't follow the genericity/variadicness line of thought.

[13:39] <gaal> variadicity? :)

[13:39] <gaal> variady? :)

[13:42] <gaal> maybe rename to &passes and &fails?

[13:42] <nothingmuch> sorry

[13:42] <nothingmuch> well 'multi sub ok () { ok(1) }; multi sub nok () { ok(0) }'

[13:43] <nothingmuch> it gets tricky.... multi sub ok (Str $desc) { ok(1, $desc) }; multi sub ok ($x) { if ($x) { ... } else { ... } }'

[13:43] <nothingmuch> nevermind, it's silly

[13:44] <nothingmuch> i think 'ok(1, "desc")' for pass

[13:44] <nothingmuch> and 'nok("desc")' for fails

[13:44] <nothingmuch> or fail

[13:44] <nothingmuch> with aliases to passes and fails

[13:44] <gaal> urp?

[13:44] <gaal> no, it's good to have convenience methods for that

[13:44] <nothingmuch> hmm... okay

[13:44] <gaal> i insist they should exist :)

[13:44] * nothingmuch has a weird idea

[13:45] <nothingmuch> use fatal

[13:45] <gaal> only question is what to rename them to

[13:45] <nothingmuch> try { 

[13:45] <nothingmuch> CATCH ($e) { 

[13:45] <nothingmuch> $e.continuation

[13:45] <nothingmuch> }

[13:45] <nothingmuch> }

[13:45] <nothingmuch> that is, Test imports fatal to it's user

[13:45] <nothingmuch> fail("foo") is just fail("foo")

[13:45] <nothingmuch> and causes an exception

[13:46] <gaal> you are insane :)

[13:46] <nothingmuch> Test's exception handler prints a NOK

[13:46] <nothingmuch> and then goes to the exception's continuation as if the exception was non fatal

[13:46] <nothingmuch> =D

[13:46] * gaal is laughing out loud

[13:46] <nothingmuch> autrijus: please implement this

[13:46] <gaal> (demonically)

[13:46] <nothingmuch> i think i'd rather like this

[13:46] <nothingmuch> p6l time

[13:47] <gaal> i don't like it

[13:47] <nothingmuch> how come

[13:47] <nothingmuch> if code is already suitable for fail as an optional exception

[13:47] <gaal> because then innocent code that does die "moose" risks being interpreted as a non fatal failure

[13:47] <nothingmuch> then why not let the user decide on a case by case basis whether they want an error to be fatal or not?

[13:47] <gaal> (if i understand correctly)

[13:47] <nothingmuch> yes, it could

[13:47] <gaal> in tests!?

[13:47] <nothingmuch> but that's the user's fault

[13:48] <nothingmuch> remember that the exception handler can look at the exception object

[13:48] <nothingmuch> and determine if it was die or fail

[13:48] <nothingmuch> (i hope)

[13:48] <gaal> nnnnnuh, i don't think it can

[13:48] <nothingmuch> it should

[13:49] <gaal> how would you do that categorically?

[13:49] <nothingmuch> define.assuming(:context($this)).(categorically)

[13:49] <gaal> wrap all fails "str" in a die fatal.new("str")

[13:49] <nothingmuch> errm, no

[13:49] <gaal> but what about fail $obj

[13:49] <nothingmuch> every exception is already an object

[13:50] <nothingmuch> since there is a whole exception stack

[13:50] <gaal> well, fail $x is just like die $x

[13:50] <gaal> if use fatal is in effect

[13:50] <nothingmuch> every exception being raised captures the current value of $! and stores it

[13:50] <nothingmuch> so no nested exceptions are lost (unless explicitly deleted)

[13:52] <gaal> in my code, i do either die $x or fail $x. what do you do to tell the two apart?

[13:52] <nothingmuch> $

[13:52] <gaal> (you're the caller)

[13:52] <nothingmuch> $! will contain the data

[13:52] <gaal> yes, what i called $x

[13:52] <gaal> and?

[13:52] <nothingmuch> nono

[13:52] <nothingmuch> read s 04

[13:52] <nothingmuch> $! is more than $x

[13:52] <gaal> from your pov, the two $!s are identical

[13:53] <nothingmuch> it contains, for example, handled and unhandled

[13:53] <gaal> hmm

[13:53] <nothingmuch> i claim it should contain info on whether it was thrown because i used fatal

[13:53] <nothingmuch> or because it died

[13:53] <gaal> so you stipulate another member, `fail` or `exception`?

[13:53] <nothingmuch> well, they're both excceptions in this case

[13:53] <nothingmuch> read s04 on fail

[13:54] <gaal> i meant `fail` or `die`.

[13:54] <nothingmuch> 'fail examines lexical scope for use fatal... will return an unthrown exception or throw an exception' (paraphrase)

[13:54] <gaal> yes, of course

[13:55] <nothingmuch> sub fail ($stuff) { $?OUTER::IS_FATAL ? die($stuff) : return Exception.new($stuff) }

[13:55] <nothingmuch> i think

[13:55] <nothingmuch> the exception object is almost a proxy to $STUFF

[13:55] <nothingmuch> err, $stuff

[13:55] <nothingmuch> but it contains meta data

[13:55] <nothingmuch> like the value of $! before it was thrown

[13:55] <gaal> see class fatal in the Prelude.

[13:55] <nothingmuch> or whether some CATCH block matched it

[13:56] <nothingmuch> is it != what s04 says?

[13:56] <gaal> you can't use OUTER there, but nm

[13:56] <gaal> i must go now

[13:57] <nothingmuch> i meant $

[13:57] <gaal> back in ~40min

[13:57] <nothingmuch> ?CALLER

[13:57] <nothingmuch> ciao

[13:57] <gaal> can't use caller either

[13:57] <nothingmuch> how come?

[13:57] <gaal> never moose, that's not the interesting part

[13:57] <gaal> later &

[13:58] <nothingmuch> ciao

[14:18] <nothingmuch> hola autrijus 

[14:18] *** autrijus is now known as autrijus_tw

[14:18] *** autrijus_ is now known as autrijus

[14:18] <nothingmuch> already back?

[14:19] <autrijus> back?

[14:19] <autrijus> I'm still in Tallinn

[14:19] <autrijus> nothingmuch: patches welcome to FromANSI

[14:20] <nothingmuch> autrijus: patches unnecessary =)

[14:20] <nothingmuch> so what is _tw?

[14:20] <nothingmuch> it's Good Enough

[14:20] <autrijus> _tw is the screen from the server in.tw

[14:20] <nothingmuch> oh

[14:20] <nothingmuch> not your physical presence =)

[14:24] <autrijus> :)

[14:24] * autrijus goes back to releng

[14:25] <nothingmuch> autrijus: i think you're going to like my latest idea

[14:25] <nothingmuch> or be very frightened at the very least

[14:25] <autrijus> does it have something to do with attributive grammar?

[14:25] <autrijus> (probably not, it's just I'm reading about it now)

[14:25] <nothingmuch> no, about continuations, exceptions, and symmetry

[14:26] <autrijus> okay...

[14:26] <nothingmuch> p6l is getting a nice code example soon

[14:26] <autrijus> good, I'll look at that

[14:28] <gaal> rehi

[14:28] <gaal> nothingmuch: so the reason you can't use CALLER is that pragma values aren't regular vars

[14:28] <gaal> they're actually available at every node in the syntax tree

[14:28] <nothingmuch> gaal: i need to go... ride

[14:28] <nothingmuch> ttyl

[14:28] <gaal> remember they're a compile-time thing

[14:28] <gaal> bye.

[14:29] <gaal> autrijus: mind taking a look at lexical pragmas, maybe we can get them in for the release?

[14:29] <autrijus> yes

[14:29] <gaal> great, sec

[14:30] <autrijus> I'll fetch some drink, be back in 10 mins

[14:30] <gaal> ok, typing ahead:

[14:30] <autrijus> then I can work ~5 hours for release

[14:30] <gaal> the code that's currently in is bogus; we need something like this: http://sial.org/pbot/13305

[14:30] <gaal> except that that loops :-)

[14:32] <gaal> it loops in the second readTVar; nothingmuch suggested changing InitDat in the Env to be an IORef instead of a TVar but that entails writing Show and Ord methods, which might be hard?

[14:32] <gaal> i don't grok STM really; maybe all that's needed is just some atomic (...) around something?

[14:33] <gaal> also the Prim side of this may be mistaken, but that I can take care off.

[14:39] <autrijus> rehi

[14:41] <autrijus> parsing your typeahead

[14:43] <autrijus> ok

[14:44] <autrijus> so I'll apply it locally

[14:47] <gaal> okay, you can also remove the cruft from ruleClosureTraits

[14:47] <gaal> want a real patch?

[14:47] <autrijus> sure, that'd rock, and a oneline test

[14:47] <gaal> ./pugs t/packages/lexical_pragmas.t

[14:48] <autrijus> k

[14:48] <autrijus> ooh, nice test

[14:48] <autrijus> real-patch-p?

[14:48] <gaal> it's all mjd's :)

[14:48] <gaal> sec

[14:49] <gaal> feather:~gaal/lex_loop.patch

[14:49] <gaal> i can move that to the webspace if you prefer

[14:50] <autrijus> +import Data.IORef

[14:50] <autrijus> this is redundant right?

[14:50] <autrijus> in P.A.Internals

[14:50] <gaal> anyway, the test might still fail because of bugs in my pragma installing code: if you get it not to loop though then, good :)

[14:50] <gaal> yes, it is

[14:50] <autrijus> also btw, +        trace ("<1>") (return ())

[14:50] <autrijus> may be written as

[14:50] <gaal> from my rewriting attempt

[14:50] <autrijus> liftIO $ print "<1>"

[14:50] <gaal> print?

[14:50] <autrijus> er no

[14:50] <gaal> for some reason that didn't work

[14:50] <gaal> oh, liftIO $ print

[14:50] <autrijus> sorry, because Rule monad is not MonadIO

[14:50] <gaal> ok

[14:50] <autrijus> but it can be made as such

[14:50] <autrijus> may be better after all

[14:51] <gaal> ah, okay.

[14:52] <autrijus> compiling

[14:52] <autrijus> still trying to grok the patch

[14:52] <gaal> - set up a place for &import to write to

[14:52] <gaal> - call import

[14:52] <gaal> - import installs a list of new values (usually just one)

[14:53] <autrijus> "unsafePerformSTM $ atomically"

[14:53] <autrijus> you don't need the atomically

[14:53] <gaal> - slurp that and stick it in the ast

[14:53] <autrijus> that's what unsafePerformSTM does implicitly

[14:53] <gaal> oh right, that was just me grabbing at straws :)

[14:53] <gaal> the clever thing about the design is how new pragma values are prepended to the list

[14:54] <autrijus> I wonder if envInitDat needs to be TVar

[14:54] <gaal> so nothing except the head pointer needs to be copied

[14:54] <autrijus> I think it wants to be pure

[14:54] <gaal> oh! that'd simplify things

[14:54] <autrijus> since you can't modify it at runtime

[14:54] <gaal> true

[14:54] <autrijus> and then the unsighty side effects can go away

[14:54] <autrijus> we'll just store env as usual

[14:55] <nothingmuch> gaal: it was besides the point

[14:55] <gaal> so, in parser i can basically modify env as much as i like until i'm done?

[14:55] <autrijus> yes, that's the idea

[14:55] <nothingmuch> $?CALLER::IS_FATAL could be a constant compiled into the closure via the pragma

[14:55] <autrijus> see putRuleEnv

[14:55] <nothingmuch> i meant to convey the principal

[14:56] <gaal> nothingmuch: { use myprag; x; no myprag; y }

[14:56] <nothingmuch> err... really, it doesn't matter =)

[14:56] <gaal> i agree.

[14:57] <autrijus> so

[14:57] <autrijus>         -- Reset the initdat list

[14:57] <autrijus>         putRuleEnv env{ envInitDat = MkInitDat [] }

[14:57] <nothingmuch> Exceptuations on p6l

[14:57] <autrijus> makes some sense?

[14:57] <gaal> there's an internals api you have to use, and it could conveivably be made to work automagically from a var

[14:58] <gaal> autrijus: yes, changing

[14:59] * gaal praises type inference

[15:00] <gaal> great for refactoring :)

[15:00] <autrijus> yeah

[15:00] <autrijus> hm, if it is pure though, Pugs::Internals::install_pragma_value needs to be rethunk

[15:00] <gaal> brb

[15:04] * autrijus ponders using a regular @*PRAGMA

[15:04] <autrijus> I mean @*INITDAT

[15:05] <gaal> actually that was just a container for things passed from an &import hook

[15:06] <gaal> at first i made a mistake and thought the installation should have taken place from a BEGIN block, so i wanted to put VContorl (see possiblyExit) there too

[15:06] <gaal> but that was just a mixup

[15:06] <gaal> i can't think of anything else import needs to convey to the parser, so maybe we don't need initdat at all.

[15:06] <gaal> anyway, that's refactoring; it can wait till after the release

[15:07] <autrijus> k

[15:08] <gaal> (phone)

[15:09] <autrijus> so envInitDat is basically a list of pragmas _waiting_ to be installed

[15:11] <gaal> exactly

[15:12] <gaal> i wish it didn't have to exist on every Env, looks like a waste

[15:12] <autrijus> so any reason why we can't make it in line with @*END @*BEGIN etc?

[15:13] * nothingmuch patiently waits for feedback =)

[15:15] <gaal> hmm, what's the lifetime scope of that?

[15:15] <autrijus> gaal: local() scope

[15:15] <gaal> it can be a globalish thing

[15:15] <autrijus> nothingmuch: so the idea is $SIG{__DIE__} can "on error resume next"

[15:15] <gaal> dynamic, that's good

[15:15] <autrijus> that's basically the "on error resume next" idea

[15:15] <nothingmuch> err, sort of

[15:15] <nothingmuch> what is "next" in here?

[15:16] <gaal> autrijus: but doesn't that get us into thread safety stuff?

[15:16] <autrijus> same as your .continue

[15:16] <autrijus> gaal: compile time thread safety is overrated

[15:16] <nothingmuch> well, it depends

[15:16] <nothingmuch> since it's 'throw' like in other languages, but 'fail' it's slightly different

[15:17] <nothingmuch> if open returns a fail, instead of a handle, the exception handler has the oppertunity to change the return value to a handle

[15:17] <gaal> lol

[15:17] <autrijus> ok. I have no problem with that notion, but it should be a EC

[15:17] <autrijus> $!.continue should never return

[15:17] <nothingmuch> agreed

[15:17] <nothingmuch> it causes the 'fail' to return a different value than the exception

[15:18] <autrijus> also sometimes errors occur at a level below p6

[15:18] <autrijus> and is not easily resumable

[15:18] <autrijus> since the tonext is lost in a lower level

[15:18] <stevan> morning boys and girls

[15:18] <nothingmuch> that's as if the fail happenned as the last statment of the wrapper

[15:18] <autrijus> s/tonext/context/

[15:18] <nothingmuch> hi ho stevan 

[15:18] <autrijus> stevan: heyw 

[15:18] <nothingmuch> e

[15:18] <nothingmuch> g

[15:18] <nothingmuch> e.g. open

[15:18] <gaal> hey stevan

[15:18] <nothingmuch> it doesn't continue in the open system call

[15:19] <nothingmuch> it lets your exception handler take the 'fail "bah"' return by the perl 6 function open

[15:19] <nothingmuch> and replace the value with an equivalent handle

[15:19] <nothingmuch> just like in my example the permission denied error allows a chmod dialog to open up

[15:19] <autrijus> I wonder if $!.resume is a better name

[15:20] <nothingmuch> and exceptions from that exception handling code could be handled to do a sudo

[15:20] <autrijus> again, I have no problem with that notion.

[15:20] <autrijus> it's something I tried to hack into p5

[15:20] <nothingmuch> .resume is nice

[15:20] <autrijus> and failed miserably

[15:20] <nothingmuch> hehe

[15:21] <autrijus> do { return 1/0*3; CATCH { $!.resume(9) } } # 27

[15:21] <nothingmuch> yes

[15:21] <gaal> does resume move out of the scope, or actually resumes where we left off?

[15:21] <stevan> can anyone me to information about fail() and the BAILOUT method?

[15:22] <nothingmuch> gaal: if you assume everything is CPS then it's simpler

[15:22] <nothingmuch> fail has the continuation to * 3

[15:22] <nothingmuch> it applies that with the exception

[15:22] <autrijus> stevan: never heard of BAILOUT

[15:22] <gaal> do { my $x = 1/0*3; $x = "moose"; CATCH { $!.resume(9) } # moose?

[15:22] <nothingmuch> it also puts a copy of that continuation in the exception object

[15:22] <stevan> autrijus: it is in Test::Builder, I had never heard of it either :)

[15:22] <nothingmuch> and CATCH can apply the continuation with a different value, after the exception is thrown

[15:22] <nothingmuch> yes

[15:23] <gaal> isn't BAILOUT when a test crashes hard?

[15:23] <autrijus> stevan: I think it's not a builtin

[15:23] <stevan> hmmm

[15:23] <stevan> ok

[15:23] <nothingmuch> it's definately not a builtin

[15:23] * gaal gets back to implementation

[15:23] * stevan will just ask chromatic, since he wrote the thing :)

[15:23] <autrijus> gaal: so this:         let idat' = unsafePerformSTM $ readTVar $ envInitDat env

[15:23] <autrijus> loops

[15:24] <autrijus> that's the bug you're hitting?

[15:24] <gaal> yes

[15:24] <gaal> oh, i know why we can't just use a value, autrijus.

[15:24] <autrijus> but I'm seeing <5>

[15:24] <gaal> in Prim:

[15:24] <fraxtal> Woo I fixed a link on the wiki

[15:24] <gaal> Pugs::Internals::install_pragma_value

[15:24] <gaal> has to write to that list...

[15:24] <autrijus> yes, I said that :)

[15:25] <gaal> you did? oh when you mentioned @*PRAGMAS?

[15:25] <autrijus> yeah

[15:26] * gaal cargo cults some more

[15:26] <obra> nice slides, autrijus 

[15:26] <autrijus> obra: thanks!

[15:26] <gaal> oh, i missed 18:00 < autrijus> hm, if it is pure though, Pugs::Internals::install_pragma_value needs to be rethunk

[15:27] <autrijus> gaal: why the let between <1> and <2>

[15:27] <autrijus> why can't you say

[15:27] <autrijus>         return $ unsafePerformSTM $ writeTVar (envInitDat env) (MkInitDat { initPragmas = [] })

[15:27] <obra> "Arrow length over time"

[15:27] <autrijus> obra: *grin*

[15:27] <gaal> i can, i can.

[15:27] <autrijus> well, if so, it loops not

[15:28] <gaal> really? cool. why did it loop too with the let?

[15:28] <autrijus> because the value of writeTVar depends on idat

[15:28] <autrijus> idat's value depends on readTVar

[15:28] <autrijus> so circular dependency between idat and envinitdat

[15:29] <autrijus> (do note the Parsec Rule monad is lazy)

[15:29] <gaal> arrr

[15:32] <svnbot6> r7131 | autrijus++ | * fix random control chars in cufp2005.txt

[15:34] <autrijus> so it's still not passing tests

[15:35] <gaal> that may be because of errors in install_pragma_value

[15:35] <gaal> (still compiling here)

[15:36] <autrijus> it's always #        Got: '8'

[15:36] <gaal> beacuse maybe i'm not writing to the right plcae

[15:36] <autrijus> "unoptimised" is your friend :)

[15:36] <gaal> true :)

[15:36] <gaal> hey, i got that always-8 sometime too

[15:36] <gaal> i think that's the last value ever written, no?

[15:37] <gaal> yes, it is.

[15:37] <autrijus> it is.

[15:37] <gaal> yeah, well, i think i can take it from here then.

[15:37] <xinming_Beijing> autrijus: hmm, May I know if MetaModule design is finished?

[15:37] <stevan> xinming_Beijing: it is mostly finished

[15:38] <stevan> some work still remains, but the core design can be considered finished

[15:38] <xinming_Beijing> hmm, So, Does it mean, That rule support will be "soon" available? :-P

[15:38] <stevan> Rule? or Role?

[15:38] * nothingmuch explained CPS in another reply to the thread

[15:40] <autrijus> gaal: cool, do so then :)

[15:40] <gaal> am. thanks very much :)

[15:40] <xinming_Beijing> stevan: rule...

[15:40] <autrijus> no prob :)

[15:40] <xinming_Beijing> not role...

[15:40] <nothingmuch> gaal: did the scenario in the email convince you of the value of continuable exceptions?

[15:40] <autrijus> I think xinming means the shift-of-focus from 6.28 to  6.283 

[15:40] <stevan> xinming_Beijing: ah, that is not related to the MetaModel then,.. that is the Rule engine

[15:40] <nothingmuch> ofcourse, it only makes sense when exceptions are optionally fatal to me

[15:41] <gaal> nothingmuch: do you need an answer now? :) me brain be of limited capacity and i want this feature in the release

[15:41] <nothingmuch> gaal: take your time =)

[15:41] <nothingmuch> i would like to know if the example is clear though

[15:41] <nothingmuch> eventually

[15:41] <xinming_Beijing> autrijus: yes...

[15:42] <gaal> okay, will do.

[15:42] <xinming_Beijing> it seems, that the working progress walk skip the schedule... :-P

[15:43] <autrijus> xinming_Beijing: I'm working on basic releng at this moment for 6.2.10

[15:43] <autrijus> if we are very lucky, 6.28.0 may happen around euro oscon, which will make a good gift to the eurooscon people

[15:43] <xinming_Beijing> In my memory. that the rule support will be finished first... and then the role support will be added...

[15:43] <gaal> autrijus: btw parrot hangs when called as a separate exe on win32, may want to disable it for now

[15:43] <nothingmuch> what's 6.28 feature set supposed to be like?

[15:44] <xinming_Beijing> nothingmuch: maybe basic rule support...

[15:44] <nothingmuch> ah

[15:44] <xinming_Beijing> and the role support will be release as a surprise for the next day.. ;-)

[15:45] <autrijus> xinming_Beijing: actually, compile-time roles (Traits) are 6.28.0

[15:45] <autrijus> I guess I should fix the 6.2831.0 so it says something better than "other runtime features"

[15:46] <xinming_Beijing> the day after tomorrow, I will have more time to do the test... hmm, In fact, I was feeling a bit sorry on do-nothing. But take a line in the AUTHORS LIST. :'(

[15:46] <autrijus> maybe "type system features" and "constraint types" etc. not sure it matters

[15:46] <xinming_Beijing> tomorrow, I will go and change 2 x 512M ram into a 1 x 1G single ram...

[15:47] <xinming_Beijing> and will go out in the morning... :-)

[15:47] <autrijus> cool :)

[15:47] <xinming_Beijing> autrijus: hmm, by the way, Is 10.1 a festival in your area?

[15:47] <autrijus> xinming_Beijing: er, no, not by any measure

[15:47] <autrijus> 10.10 is.

[15:47] <svnbot6> r7132 | autrijus++ | * random kwid cleanup to 2005-09-21.kwid

[15:48] <xinming_Beijing> autrijus: Oh,

[15:48] <autrijus> I care very little about either one :)

[15:48] <nothingmuch> btw, i think 'on error resume next' is completely different now that i've learned a bit about it

[15:49] <nothingmuch> because it's declarative, and all or nothing

[15:49] <autrijus> it's not unlike a 

[15:49] <xinming_Beijing> autrijus: hmm, by the way, I ever wish to change the Simplified version of Apocrypha on some words... But I was a bit afraid of doing something wrong...

[15:49] <nothingmuch> continuable exceptions let you inspect the error first

[15:49] <nothingmuch> with regular try/catch semantics

[15:49] <autrijus> { CATCH { $!.resume } ... }

[15:49] <nothingmuch> and then choose

[15:49] <nothingmuch> right

[15:49] <autrijus> right, yes, yours is much more flexible

[15:49] <nothingmuch> which is obviously bad code =)

[15:49] <autrijus> xinming_Beijing: nah, just commit 

[15:49] <xinming_Beijing> autrijus: In fact, there are some characters we use less than "traditional Chinese",

[15:49] <nothingmuch> in order to 'on error resume next' you can just 'no fatal'

[15:50] <autrijus> xinming_Beijing: yeah, please fix away

[15:50] <autrijus> nothingmuch: er no, "no fatal" still dies on die"" and 1/0

[15:50] <nothingmuch> is there any random releng work i could help with?

[15:50] <nothingmuch> on 1/0?

[15:50] <xinming_Beijing> .

[15:50] <autrijus> nothingmuch: er, sure, ext/DateTime-Set/t/basic.t

[15:50] <autrijus> You probably don't want to export an operator name; instead

[15:50] <autrijus>   define a new variant on the new operator (eg. multi sub *infix:<+>):"&infix:\8745" at "blib6/lib/Set/Symbols.pm" line 17 column 1

[15:50] <nothingmuch> oh, perl 5 does too =)

[15:50] * nothingmuch didn't know that =)

[15:50] <xinming_Beijing> I ever changed it. But discard the change... :'(

[15:50] <autrijus> xinming_Beijing: :-/

[15:51] <autrijus> xinming_Beijing: right, I used machin etranslation

[15:51] <autrijus> xinming_Beijing: so it's bound to have many uncommon idioms

[15:51] <nothingmuch> wow, in that case 'on error resume next' is even dumber than I thought =)

[15:51] <autrijus> nothingmuch: it is for High Reliability Never Stop software

[15:52] <nothingmuch> haha!

[15:52] <xinming_Beijing> autrijus: Ok, I will do it now...

[15:52] * nothingmuch 's first rule of language design has now become:

[15:52] <nothingmuch> any language feature which is all or nothing is a design flaw

[15:53] <gaal> beh, i made a silly omission in the lexprag patch

[15:53] <gaal> i'm pushing pragmas to the env

[15:53] <gaal> i should be pushing them to the exp!

[15:54] <gaal> i obviously need a break with some chocolate in it :)

[15:54] * nothingmuch tells a joke:

[15:54] <autrijus> gaal: ^Cchocolate^C

[15:55] <nothingmuch> sub warn (*$a) { use fatal; fail(*$@); CATCH { $*ERR.print($!); $!.resume } }

[15:55] <gaal> %*SIG<BRK> = &chocolate

[15:57] <autrijus> greetings miyagawa-san!

[15:57] <miyagawa> hi!

[15:57] <miyagawa> just saw your journal on use perl and takahashi method

[15:57] <autrijus> :D

[15:57] <miyagawa> that's really funny to see

[15:57] <miyagawa> :)

[15:57] <autrijus> takahashi rocks

[15:57] <autrijus> so you read my slides?

[15:57] <miyagawa> yeah

[15:57] <nothingmuch> who is takahashi?

[15:57] <miyagawa> yeah, just saw that

[15:58] <miyagawa> takahashi is Ruby hacker in Japan

[15:58] <nothingmuch> ah

[15:58] <miyagawa> who invented a new methodology for presentations with huge fonts

[15:58] <nothingmuch> hehe

[15:58] <autrijus> right... various people has used something like that

[15:58] <autrijus> but only Takahashi has the gut to scale "1)" into 640pt

[15:59] <nothingmuch> i imagine the slides were very effective with spoken words

[15:59] * nothingmuch always tries to do that with his slides/text/whatever

[15:59] <miyagawa> yeah, Takahashi method has stolen something from Steve Jobs' presentation actually

[15:59] <nothingmuch> making things much more dense

[16:00] <autrijus> miyagawa: I ran into Eijiro Sumii san today

[16:00] <miyagawa> but using "1)" is really nice and funny though

[16:00] <miyagawa> aut: hmm, who's that_

[16:00] <autrijus> of the mincaml fame

[16:00] <autrijus> http://min-caml.sourceforge.net/

[16:00] <autrijus> he was with 2 other people from .jp -- we are the only people from asia here :)

[16:01] <miyagawa> is it some YAML conference? 

[16:01] <nothingmuch> heh

[16:01] <autrijus> :D

[16:01] <autrijus> it's ICFP

[16:01] <miyagawa> yet another meta language i maen

[16:01] <nothingmuch> autrijus: que es min-caml? what I think it is?

[16:01] <autrijus> nothingmuch: yes

[16:01] <autrijus> miyagawa: it's the gathering of weirdo lambdafolks

[16:02] <nothingmuch> min-caml is to ocaml like python is to perl?

[16:02] <miyagawa> cool

[16:02] <autrijus> erlang, scheme, ocaml, haskell, etc

[16:02] <nothingmuch> autrijus: i have a question about david roundy

[16:02] <nothingmuch> is he really the mega hippy he looks like in the pictures on abridgegame.net?

[16:02] <autrijus> he looks like larry wall

[16:02] <autrijus> 20 years younger

[16:03] <miyagawa> ha

[16:03] <autrijus> speaks like him, moves like him

[16:03] <autrijus> I keep resisting the impulse to call him larry

[16:03] <nothingmuch> http://www.abridgegame.org/screenshots/generalprefs.png

[16:04] <miyagawa> aut: did you make Takahashi method with MS Powerpoint?

[16:04] <autrijus> miyagawa: OOo impress actually, with some help from ppt whilst I was downloading OOo

[16:05] <miyagawa> my co-worker tried to make a Kwiki/Spork plugin to enable Takahashi-ism in Spork slides

[16:05] <autrijus> miyagawa: I wish there is a software that can scale automagically for me

[16:05] <autrijus> right, I worked on it a bit using Font::AFM

[16:05] <miyagawa> ah, cool

[16:05] <autrijus> but I can't get it working in the reasonable timeframe

[16:05] <miyagawa> ;)

[16:05] <nothingmuch> isn't a wafl block for some inline CSS enough?

[16:06] <autrijus> nothingmuch: it's surprisingly hard to scale fonts to fit window border using CSS.

[16:06] <nothingmuch> oh, you don't want it just big, but biggest

[16:06] <autrijus> yes.

[16:06] <nothingmuch> =)

[16:06] <nothingmuch> perhaps javascript can help?

[16:06] <autrijus> yes, I'm sure it could

[16:08] <nothingmuch> no replies yet =/

[16:08] * nothingmuch ponders making a warnock ratio calculator and seeing if he's the winner

[16:08] <autrijus> nothingmuch: if you want to help with releng -- maybe changelogging? :)

[16:09] <nothingmuch> changelogging is not a good idea, since i'm still slightly nauseous (hard to concentrate) and i'm not really in touch lately, but i would be very happy to help with janitorial work

[16:09] <autrijus> ah ok

[16:09] * nothingmuch 's stomache fail()ed yesterday

[16:09] <autrijus> you can chase away the "You probably don't want to export an operator name; instead

[16:09] <autrijus> "

[16:09] <autrijus> in fp.pm

[16:09] <nothingmuch> okay

[16:09] <autrijus> Set/Symbols.pm

[16:10] <autrijus> *** No compatible subroutine found: "&union"

[16:10] <autrijus>     at blib6/lib/Set/Symbols.pm line 28, column 5-21

[16:10] <autrijus> etc

[16:10] * nothingmuch svk pulls

[16:13] <autrijus> nothingmuch: also

[16:13] <autrijus>     unexpected "o"

[16:13] <autrijus>     expecting ";", statements or end of input

[16:13] <autrijus>     at t/packages/reflection.t line 14, column 1

[16:13] <autrijus> also

[16:13] <autrijus>     unexpected "{"

[16:13] <autrijus>     expecting word character, "::", ".", ":", "(", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[16:13] <autrijus>     at t/packages/symbols.t line 16, column 9

[16:15] <svnbot6> r7133 | stevan++ | Perl6::MetaModel 2.0 -

[16:15] <svnbot6> r7133 | stevan++ | * instance attribute keys are now locked, this is mostly to help

[16:15] <svnbot6> r7133 | stevan++ |   me out when debugging (autovivifacation makes for some ugly 

[16:15] <svnbot6> r7133 | stevan++ |   and hard to find bugs in the MM)

[16:15] <svnbot6> r7133 | stevan++ |     - added a means of adding attributes to live objects when

[16:15] <svnbot6> r7133 | stevan++ |       absolutely nessecary, but shhh I didn't tell you that ;)

[16:16] <nothingmuch> autrijus: pugs is still compiling, soo i'm off to dinner

[16:16] <nothingmuch> i'll do this stuff in ~15 mins

[16:16] <autrijus> cool

[16:17] <miyagawa> "Functional Programming As a Means, Not an End "

[16:17] <miyagawa> it's really cool

[16:17] <autrijus> miyagawa: aye, I think that's a good slogan

[16:17] <autrijus> and I learned all I can about MDA

[16:17] <autrijus> which is a very nice way to market the FP mindset

[16:17] <miyagawa> but I'm still wondering Pugs is "Commercial" usage of FP

[16:17] <miyagawa> MDA?

[16:17] <autrijus> it's not -- the chair said something about "Practical" instead

[16:18] <miyagawa> that makes more sense

[16:19] <autrijus> http://www.omg.org/cots

[16:19] <autrijus> http://www.cotsjournalonline.com/home/article.php?id=100297

[16:19] <autrijus> mostly it's a way to phrase code generation / metaprogramming so that pointyhairs can understand.

[16:20] <miyagawa> thanks. MDA reminds me of Mail Delivery Agent like procmail 

[16:20] <autrijus> :D

[16:22] <autrijus> alright, dinner, bbiab :) &

[16:28] <autrijus>  oh also, the test in t/rules/rules.t triggers weird numbers of 

[16:28] <autrijus> *** Warning: PGE doesn't actually do :ignorecase yet.

[16:28] <autrijus>     at tmp-Prelude.pm line 197, column 24-43

[16:29] <autrijus> the report site is not helpful (tmp-Prelude.pm) is not helpful

[16:29] <autrijus> so I wonder if that should be disabled, or somehow limited so it occurs only once, or somehow not warn during testing, or otherwise make the user less panicked

[16:30] <autrijus> but dinner for real. &

[16:44] <r0nny> hoi

[16:48] <nothingmuch> hi r0nny 

[16:54] <nothingmuch> autrijus: do you remember how we found out that Scalar::Util::blessed (the pure perl version) is so insane?

[16:57] <svnbot6> r7134 | yiyihu++ | Edit Simplified Chinese version of Apocrypha to make it more comfort for Simplified Chinese User....

[17:01] <xinming_Beijing> hmm, Some small bug will be fixed the day after tomorrow... hmm, Bye for now...

[17:01] <xinming_Beijing> good night

[17:34] <autrijus> rehi

[17:34] <nothingmuch> rehi

[17:34] <autrijus> nothingmuch: yeah, because we wished to find a way to test for objectness

[17:34] <autrijus> and we didn't want to munge UNIVERSAL

[17:34] <autrijus> so you thought S::Util may be good

[17:35] <nothingmuch> oh, right

[17:35] <nothingmuch> and then we figured out that thtat was exactly what it's doing =D

[17:35] <nothingmuch> luqui: good stuff

[17:35] <luqui> hmm

[17:35] <nothingmuch> theory.pod

[17:35] <luqui> ?

[17:35] <nothingmuch> luqui++

[17:35] <nothingmuch> luqui++

[17:35] <luqui> ahh, thank you

[17:36] <luqui> the factory/union connection has a few holes that I'm trying to work out, but other than that, I'm pretty happy with it

[17:36] <autrijus> hey luqui

[17:36] <luqui> hi autrijus, long time no irsee

[17:36] <autrijus> luqui: is @Larry currently addicted by AG?

[17:36] <autrijus> s/by/to/

[17:36] <luqui> AG?

[17:36] <autrijus> attributive grammars

[17:36] <nothingmuch> autrijus: briefly what is AG?

[17:36] <luqui> allison at least

[17:36] <nothingmuch> like , what does it give you

[17:37] <autrijus> luqui: oh... I thought $Larry mentioned something about it makign it part of perl6

[17:37] <autrijus> in your journal

[17:37] <luqui> oh yeah, the tree transform stuff

[17:37] <luqui> that is the hot topic

[17:37] <nothingmuch> what is that stuff, btw?

[17:37] <autrijus> nothingmuch: http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

[17:38] <luqui> *click*

[17:38] <autrijus> luqui: nice. I wonder what systems al and lwall worked with

[17:38] <autrijus> I'm with a bunch of AG guys here

[17:38] <luqui> really?

[17:38] <autrijus> UUAG in particular

[17:38] <autrijus> <- at ICFP

[17:38] <luqui> ... acronyms ...

[17:38] <autrijus> largest concentration of lambdafolks on the planet

[17:38] <luqui> cool

[17:38] <autrijus> (international conference of functional programming)

[17:39] <autrijus> it's uncharted territory, and performance can be unpredictable, and it does not mix well with imperative primitives

[17:39] <autrijus> but otherwise it's a good idea

[17:40] <autrijus> certainly saner than importing the monad primitives to perl6.

[17:40] <luqui> :-)

[17:41] <luqui> autrijus, lwall worked with perl 5; al worked with P6C

[17:41] <luqui> so.... they didn't

[17:41] <luqui> and I haven't either

[17:41] <luqui> so we need some docs

[17:41] <autrijus> where did they find AG then, hmm.

[17:41] <luqui> al's reading

[17:41] <autrijus> sure. I'm working with UUAG

[17:42] <autrijus> which is not actively developed but works pretty stable

[17:42] <autrijus> implementing AG transfomer on Parrot of any efficiency is going to be an _interesting_ problem

[17:42] <autrijus> certainly more so than PGE

[17:43] <autrijus> oh btw, I accidentally implemented .TEMP and temp()

[17:43] <autrijus> committing

[17:43] <luqui> neato

[17:43] * nothingmuch is not understanding anything

[17:43] <nothingmuch> brain is completely fizzy

[17:43] * luqui is a little lost too...

[17:43] <luqui> because I'm trying to read WhyAttributeGrammarsMatter and autrijus at the same time

[17:44] <autrijus> luqui: more helpful may be http://www.cs.uu.nl/wiki/Swierstra/ResearchTalks

[17:44] <autrijus> the 3rd one in particular

[17:45] <autrijus> some lambdafolk remarked that "AG was advanced technology in the 80s" :D

[17:45] <autrijus> ...and somehow ignored by the rest of the world

[17:46] <luqui> there seems to be a lot of that

[17:46] <luqui> like, oh, tail calls

[17:46] <sili> i hate pdf.

[17:46] <luqui> i hate bad music

[17:48] <autrijus> "after a lot of research on AG, we discovered that it is possible to write compilers in AG that is _almost_ as fast as hand written compilers"

[17:48] <luqui> lhs.length =1.0 + @tail.length -- cognitive dissonance :-) 

[17:48] <autrijus> "therefore compiler writers ignored AG, because it's not fast enough"

[17:48] <autrijus> "and therefore other people ignored AG, thinking it's only for compiler writers"

[17:48] <svnbot6> r7135 | autrijus++ | * proper temp() support even for nonlocal exits; also supports .TEMP as per s06

[17:49] <luqui> are there any AG thingies on CPAN?

[17:50] <sili> what's ag?

[17:50] <autrijus> CPAN, being what CPAN is, no. :)

[17:50] <autrijus> although the idea has been resurfacing with the term "aspect-oriented programming"

[17:50] <luqui> "being what CPAN is?"

[17:51] <luqui> what is CPAN

[17:51] <autrijus> comprehensive perl archive network :)

[17:51] <integral> but without the comprehensive bit?

[17:51] <autrijus> (referring to the fact that AG didn't have anything to do with perl prior to this point)

[17:52] <wolverian> AG looks like a really hard to read version of CSS

[17:52] <luqui> okay, fair enough

[17:53] <autrijus> wolverian: except you can't embed closures in CSS

[17:53] <autrijus> and CSS attributes can't propagate upwards

[17:53] <autrijus> so you are limited to one-pass downward propagation

[17:53] <luqui> from what I can tell, AG is tightly coupled to being lazy

[17:53] <luqui> this... is not a good sign

[17:54] <integral> what is "being lazy"?

[17:54] <autrijus> yes, it's a lazy oasis within a normally imperative setting

[17:54] <autrijus> or "declarative", so to speak

[17:54] <sili> declarative++

[17:55] * luqui wonders how much laziness Perl can get away with without people noticing it is lazy

[17:56] <luqui> and if it turns out to be a lot, parrot is screwed

[17:57] <luqui> that or it just isn't good at the parts of the language that are lazy ("good" read "fast"), but still works

[17:57] <integral> luqui: I don't quite understand why parrot would be screwed?

[17:58] * autrijus notes that UUAG is in Artistic License, curiously

[17:58] <luqui> integral, it's just not set up to handle millions of little teeny closures

[17:58] <autrijus> luqui: a CPS VM is at an advantage to model laziness

[17:58] <luqui> yeah, I suppose

[17:58] <integral> luqui: really? hrm.  ok, I thought it would be

[17:58] <luqui> but function calling has been designed too heaviweight

[17:59] <luqui> but then a lot of parrot has changed behind my back

[17:59] <luqui> because I haven't been looking for over a year

[17:59] <luqui> so don't listen to me

[17:59] <integral> but aren't you calling functions everywhere anyway with PMCs?

[17:59] <autrijus> that would be C level vtable function though

[18:03] * luqui is giving an all-day opengl tutorial

[18:03] <autrijus> nice

[18:03] * luqui will read up on AGs definitely

[18:03] <luqui> thanks for the seed :-)

[18:03] <luqui> adios

[18:03] <autrijus> np. :) I also ran into crazy scheme folks today

[18:04] <autrijus> one of which incidentally had a nice algorithm for making runtime "where {...}" constraints more efficient to implement

[18:08] * autrijus goes back to chase testfails...

[18:08] <autrijus> too bad the hotel room here does not have wireless, it's only in the lobby

[18:09] <autrijus> so I may randomly drop off soon and go back for electricity :)

[18:14] *** DesreveR is now known as r0nny

[18:15] <gaal> nothingmuch: "making up these subjects is fun": http://www.livejournal.com/~gaal/89779.html

[18:16] <gaal> (more at http://www.livejournal.com/~gaal/90197.html)

[18:17] <autrijus> nifty

[18:19] <nothingmuch> gayes, i remember.. that's good stuff!

[18:21] * nothingmuch wonders how the hell "gayes" came out of gaal

[18:21] <nothingmuch> oh... ga<tab>yes

[18:23] <nothingmuch> gaal: yes, I remember... that's good stuff!

[18:23] <sili> is anyone working on p6 documentation?

[18:26] <autrijus> sili: yes, see docs/quickref/ and other docs/ in the pugs tree

[18:28] <autrijus> bbl &

[18:33] <sili> ah, this is perfect

[18:34] <nothingmuch> UGH! not with the interpolation again!

[18:34] * nothingmuch cries

[18:35] <sili> what is defaul{} used for?

[18:37] <sili> oh i see.

[18:41] <sili> i take it back. i don't get it

[18:41] <sili> given/when/default :(

[18:43] <gaal> just for clarity.

[18:43] <sili> how do you use them?

[18:44] <gaal> see L<S04/"Switch statements">

[18:44] <sili> thanks.

[18:44] <sili> now i get it.

[18:44] <gaal> "The default case [...] is exactly equivalent to when true {...}"

[18:55] <xinming_Beijing> ?eval 3 ?? 1 :: 0;

[18:56] <xinming_Beijing> ??, pugs bot is gone? :-S

[18:57] <sili> looks like

[18:59] <xinming_Beijing> hmm, It seems, that the Synopsis is a bit outdated because of the ?? !! operator... :-)

[19:01] <sili> bad info is worse than no info :|

[19:04] <xinming_Beijing> :-S Language syntax changed a bit in these days... :'( I think I have to review to see how much changes has been made... 

[19:04] * gaal punts on lexical pragmas for tonight

[19:04] <gaal> see ya :)   zzzzZZZ &

[20:04] <meppl> is it possible to use perl5-modules momentaneous?

[20:05] <meppl> pugs says  "pugs_bin: *** perl5 is not available"

[20:08] <Khisanth> did you compile pugs with perl5 embedded?

[20:16] <meppl> oh

[20:16] <meppl> no

[20:16] <meppl> thx

[20:22] <svnbot6> r7136 | putter++ | docs/quickref/namespace: mention it is out of date.

[20:33] <svnbot6> r7137 | putter++ | crude_repl.pl: rename to pugs-p5.pl

[20:44] <putter> gaal: could you add a PUGS_EXECUTABLE environment variable to Main.hs, pointing to the pugs executable, so the backend helpers can reliably find their way back to the pugs which called them?  thanks.

[21:09] <svnbot6> r7138 | putter++ | PIL/Run/EvalX.pm: To find a pugs to run, use a --pugs=xxx argument, or a PUGS_EXECUTABLE environment variable, or depend on finding 'pugs' in PATH.

[22:04] <svnbot6> r7139 | putter++ | src/Main.hs: pass backends all arguments, not just some.  -I again works.

[22:46] <svnbot6> r7140 | putter++ | pugs-p5.pl: delay PIL-Run startup until runtime (instead of compile-time), so --pugs gets set in time.

[22:47] <putter> gaal: ok, so Main.hs could define a --pugs instead of, or in addition to, PUGS_EXECUTABLE.  The later is nice because it doesnt require backend perl "runtime" processing.  But a quick and superficial search suggests ghc doesn't have a portable (ie, non Posix) setenv.

[23:22] <svnbot6> r7141 | putter++ | runjs.pl: Kludge to tolerate -B JS argument.  Now runs with the new unwrapped pugs.  But jspugs.pl still doesn't.

[23:25] <putter> iblech: ./pugs the script was avoiding sending the backends the -B js argument.  The "unwrapped" haskell pugs doesn't.  And perhaps can't easily.  So runjs has to tolerate a -B.  So I kludged it.  But jspugs, aka './pugs -B js', is still broken.  It's probably easier to hack runjs, than to make Main.hs and Run/Args.hs smarter.  They're rather narrowly targeted at pugs's own needs.

[23:27] <putter> Though perhaps we could do our own "run"-like parsing in Main.hs, before handing off to 'run' if it's not a backend task.  But it's probably easier in perl than haskell.

[23:29] <putter> gaal: runjs already supports --pugs, so perhaps that's worth doing first.

[23:48] <putter> fglock: the only remaining pilrun regression from the ./pugs unwrapping should be "make test-perl5".  Everything else should be working again.  Please ping me if something else turns up.  I'll try to look into make test early this week.  Smoke works.

[23:49] <putter> After that, perhaps a bit of code dusting, and then maybe switch to mm2?   Unless that's done already? :)

