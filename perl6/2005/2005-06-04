[00:10] <svnbot6> r4361, eric256++ | nested_loops/oo.p6 - changed to make a little clearer what the example is doing (hopefully)

[00:18] <svnbot6> r4362, ninereasons++ | shuffle.p6: sprinkle with more perl 6 -isms 

[00:25] *** Limbic_Region_ is now known as Limbic_Region

[00:27] * Limbic_Region can't tell if that last commit worked or not

[00:33] <Limbic_Region> eric256 ping

[00:42] <Khisanth> Limbic_Region: he quit a while ago

[00:43] <Limbic_Region> thanks Khisanth

[00:43] <Limbic_Region> I was having problems myself

[00:43] * Khisanth just use tab completion :)

[00:44] <Limbic_Region> I am

[00:44] <Juerd> wolverian: What is the yyy in your hostname?

[00:44] <Limbic_Region> my client apparently continues to work after they have left

[00:44] <Juerd> wolverian: This has bothered me for almost 24 hours now.

[00:44] <Juerd> wolverian: I can't make any sense of it.

[00:44] <Khisanth> Limbic_Region: that is rather odd behaviour

[00:44] <Juerd> While cmxxvi certainly does look roman

[00:44] <Juerd> (926)

[00:45] <Limbic_Region> Khisanth - leafChat 1.8

[00:45] * Limbic_Region hasn't been nor does he intend to become an IRC weenie

[00:45] <Limbic_Region> it works and that's all I care about

[00:45] * Khisanth goes  to track down where the hell is is messing up the heap

[00:46] <wolverian> Juerd: I have no idea. :) You'd need to ask my ISP.

[00:47] <Juerd> awww.

[00:47] <Juerd> Damnit.

[00:47] <wolverian> maybe they are zeroes.

[00:49] <Juerd> zeroes in a roman number?

[00:50] <wolverian> exactly!

[00:50] <wolverian> it's a brilliant idea.

[00:52] <Khisanth> O_O valgrind is reporting quite a few bugs in my X11 library

[01:03] <nothingmuch> blah

[01:04] <svnbot6> r4363, Limbic_Region++ | Another arbitrary nested loops example (Roy Johnson)++

[01:08] <Limbic_Region> nothingmuch - I broke down and decided to read YAHT

[01:09] <nothingmuch> Limbic_Region: good luck

[01:09] <nothingmuch> i didn't get along with it

[01:09] <nothingmuch> it was nice

[01:09] <nothingmuch> up to the monads

[01:09] <nothingmuch> then it made perfect sense

[01:09] <nothingmuch> except I couldn't see what the heck it was actually doing

[01:09] <nothingmuch> in the general sense

[01:10] <nothingmuch> that is, i couldn't interpret the meaning, and try to apply it to a hypothetical problem I just invented

[01:10] <Limbic_Region> well - perhaps I will be able to add to my experience to your tutorial

[01:10] <Limbic_Region> s/to my/my/

[01:11] <Limbic_Region> I thought you were going to bed?

[01:31] * Limbic_Region is going to call it a night

[01:31] <Limbic_Region> TTFN all

[01:36] <svnbot6> r4364, mrborisguy++ | Added test for 'if' and 'while': if( my  = ... ) and while( my  = ... )

[01:44] <Khisanth> NCI should make calling C from Perl easier but how about calling Perl from C? anything to make that easier?

[01:50] <nothingmuch> any haskell heads around?

[02:03] <scook0> nothingmuch: I'm not awesome with Haskell, but what do you need?

[02:03] <nothingmuch> but i don't know exactly what GHC.Prim.State# is

[02:03] <nothingmuch> can you annotate `:i IO`?

[02:04] <nothingmuch> i can grok it sort of

[02:04] <pasteling> "nothingmuch" at 212.143.91.217 pasted "my interpretation of the IO monad" (51 lines, 1.9K) at http://sial.org/pbot/10693

[02:05] <nothingmuch> you can probably guess the context

[02:06] <scook0> nothingmuch: I always just think of IO as being opaque, myself

[02:06] <nothingmuch> i was never satisfied with that ;-)

[02:07] <nothingmuch> up already castaway ?

[02:08] <scook0> well, if you understand the State monad, the hand-waving process is easier

[02:08] <nothingmuch> it's the little pound signs which are confusing me, not state

[02:09] <scook0> nothingmuch: I dunno, it's probably just GHC internals stuff

[02:09] <nothingmuch> =)

[02:09] <scook0> I just think of IO as a State monad that somehow accepts values of the real world and produces new ones

[02:09] <scook0> except I can't actually fit the real world in my computer :)

[02:09] <nothingmuch> right, that's exactly what that definition says

[02:10] <nothingmuch> well duh, you evaluate it lazily using getChar ;-)

[02:10] <scook0> ultimately, I'm not sure there IS a satisfactory non-hand-waving explanation of IO

[02:11] <scook0> if it really bugs you, just explain State, then explain IO by analogy

[02:11] <nothingmuch> i was actually very very satisfied by taking 2 minutes to carefully read :i IO

[02:11] <nothingmuch> it's just those damn #'s now

[02:12] <scook0> my hunch is that # just means 'here be implementation-specific dragons', but I dunno

[02:12] <nothingmuch> fair enough =)

[02:12] <autrijus> oh. there's a good explanation of IO in the awkward squad paper

[02:12] <autrijus> complete with operational semantics

[02:13] <nothingmuch> morning autrijus 

[02:13] <nothingmuch> i think this experiment is becoming very successful, for me at least

[02:13] <autrijus> yo nothingmuch. great work on harrorth! not yet propagated to darcs?

[02:13] <autrijus> you can chase the references in the awkward squad paper if you want to understand IO thoroughtly

[02:14] <nothingmuch> no, i

[02:14] <nothingmuch> m still writing chapter 4

[02:14] <nothingmuch> i think this is good enough for 5:13 AM

[02:14] <autrijus> btw you can ignore the #

[02:14] <autrijus> the # means "unboxed"

[02:14] <autrijus> don't worry about that

[02:15] <nothingmuch> ah

[02:16] <autrijus> so it's like

[02:16] <autrijus> data IO a = IO (State RealWorld -> (State RealWorld, a))

[02:16] <nothingmuch> okay

[02:17] <autrijus> "the IO type, parameterised by another type 'a', means a function that takes the real world, then returns a modified real world, along with a computed value of the type 'a')

[02:17] <nothingmuch> autrijus: read my nopaste

[02:17] <autrijus> the key is the Haskell ensures each RealWorld is only used once

[02:17] <nothingmuch> please tell me if it's an accurate interpretation

[02:17] <autrijus> looking

[02:18] <autrijus> err, the RealWorld is parameter to State

[02:18] <autrijus> it's not two args

[02:18] <autrijus> if it's two args it'd be

[02:18] <autrijus> State -> RealWorld -> ...

[02:18] <autrijus> instead it's (State RealWorld) -> ...

[02:18] <nothingmuch> oh, right

[02:19] <nothingmuch> right

[02:19] <nothingmuch> ... This function accepts GHC.Prim.State containing a GHC.Prim.Realworld, and

[02:19] <nothingmuch> ...

[02:19] <autrijus> yup.

[02:19] <autrijus> otherwise correct.

[02:19] <autrijus> "the universe is just another parameter"

[02:20] <autrijus> but I need to run for breakfast now. ttul! &

[02:31] <nothingmuch> autrijus: darcs pull

[02:32] * nothingmuch goes to the shower

[03:26] <kelan> nothingmuch: IO isn't impure if you think about it like this: the IO computation will return the same value every time it's called with the same world

[03:27] <nothingmuch> kelan: as I see it it's a way for it to be impure, but consistent with pure semantics

[03:27] <nothingmuch> but i'm really asleep now, so this may be a lie

[03:27] <kelan> heh

[03:27] <nothingmuch> and even when I was awake, i was probably wrong

[03:28] <kelan> well practically it is impure

[03:28] <kelan> but you can think about it theoretically being pure

[03:28] <kelan> if you think of the world as an argument

[03:29] <nothingmuch> right

[03:29] <nothingmuch> i'll try to use these fnords, they have good potency

[03:29] <kelan> then you see that the IO is taking different arguments every time

[03:29] <nothingmuch> yup

[03:29] <kelan> so you're writing a haskell tutorial?

[03:29] <nothingmuch> yes, except i don't know haskell yet

[03:29] <kelan> hah

[03:29] <nothingmuch> so it might be easier for others to follow

[03:29] <kelan> yes

[03:30] <kelan> i think that is a good idea

[03:30] <nothingmuch> since i can't assume anything, we are really on the same level

[03:30] <nothingmuch> i'm also learning forth, and eventually parrot

[03:30] <nothingmuch> (that's the plan at least)

[03:30] <nothingmuch> and please don't comment on how horrible the forth representation is right now - we are going to rethink it soon ;-)

[03:30] <kelan> i was wondering what harrorth meant

[03:31] <kelan> i don't know forth, so no complaints from me

[03:31] <nothingmuch> did you read the nopaste? or the chapter itself?

[03:31] <kelan> the nopaste

[03:31] <nothingmuch> in that case: http://feather.perl6.nl/~nothingmuch/harrorth

[03:32] <nothingmuch> i think it's been a pretty successful experiment so far

[03:32] <kelan> someone should write a kwid2html filter for the docs

[03:33] <nothingmuch> yes, someone should

[03:33] <nothingmuch> someone probably did but forgot to put it on CPAN

[03:33] <kelan> ah, a forth compiler targetting parrot in haskell

[03:33] <kelan> that sounds complicated:)

[03:34] <nothingmuch> and someone did, but packaged it as part of spork

[03:34] <nothingmuch> yep =)

[03:34] <nothingmuch> the premise is: i don't grok haskell, the tutorials haven't been practical enough

[03:34] <nothingmuch> it's supposed to be

[03:34] <nothingmuch> by introducing complication (fun complication I hope), more real world scenarios can be encountered

[03:34] <nothingmuch> instead of nice examples being distilled

[03:34] <kelan> do you have an interest in forth, as well? or did you just pick that from a hat

[03:34] <SamB> someone wrote something about the G-machine in FORTH on haskell-cafe recently...

[03:34] <nothingmuch> i have a mild interest

[03:35] <arcady> forth is a pretty simple language, too

[03:35] <nothingmuch> i don't plan to develop in it, but it seemed like a very pretty language

[03:35] <arcady> plus, it comes free with openfirmware!

[03:35] <nothingmuch> annd now that i made some errors deciphering it, and realized them, i see that it's much prettier than I thought it was initially

[03:35] <nothingmuch> but we're going to learn those parts of forth tomorrow =)

[03:36] <nothingmuch> btw - for the record, i do like distilled examples very much

[03:36] <arcady> have you seen forth's if/then yet?

[03:36] <kelan> what is GADT?

[03:36] <nothingmuch> i think the most beautiful bit of haskell I saw so far is Eric Somethingorother's definition of fib

[03:36] <nothingmuch> GADT - i'm actually not sure i'll be using it now

[03:36] <nothingmuch> i think it's like guards for types

[03:36] <nothingmuch> see autrijus's journal entry on it

[03:36] <kelan> ah

[03:37] <nothingmuch> i just know it exists, and allows for more complicated type checking

[03:37] <nothingmuch> forth is appearantly too simple for it though

[03:37] <kelan> heh

[03:37] <nothingmuch> arcady: yes, but haven't thought of implementing yet

[03:37] <nothingmuch> on the other hand, I have been enlightened on the behavior of the ':' and ';' words, so i suspect it's something similarly elegant

[03:38] <nothingmuch> oh shit, it's nearly 7am

[03:38] <arcady> implemented the same way, basically

[03:38] <arcady> yeah, you should probably sleep first

[03:39] <nothingmuch> at least my hair dried a bit =/

[03:39] <nothingmuch> yeah, i have to teach assembler at 11 again

[03:39] * nothingmuch makes it 12:

[03:39] <SamB> I thought it was just a way to have data constructors fix certain arguments to the type constructor?

[03:39] <nothingmuch> SamB: you probably know more than me

[03:40] <autrijus> SamB: it's a way to write out data constructors as full functions

[03:41] <autrijus> so the element types do not neccessarily appear as parameters to the type constructor

[03:41] <SamB> oh?

[03:41] <autrijus> compare http://autrijus.org/tmp/gadt.hs with http://autrijus.org/tmp/old.hs

[03:42] * SamB googles his mailbox to look for one of those literate-haskell posts...

[03:43] * SamB wishes google would find GADTs when searching for GADT

[03:44] <nothingmuch> Ground Air Defence Threat

[03:44] <nothingmuch> eh?

[03:44] <SamB> oh, right, I getcha.

[03:45] <scook0> so Haskell is now a national security risk? :)

[03:45] * SamB groans.

[03:45] <nothingmuch> castaway.ruffle(SamB);

[03:46] <nothingmuch> kill STOP => nothingmuch.pid

[03:46] <SamB> "[Haskell] Fixed-length vectors in Haskell, Part 1: Using GADTs" may be of interest

[03:47] <SamB> ?google Fixed-length vectors using GADTs

[03:47] * SamB remembers that perl people have never heard of all-singing all-dancing bots

[03:48] <SamB> how do you google from the channel 'round these parts?

[03:49] <nothingmuch> actually purl is pretty annoyingly-all-singing-all-dancing

[03:49] <SamB> oh?

[03:50] <SamB> annoyingly-all-singing-all-dancing?

[03:50] <Odin-LAP> The craziest bot I ever saw can be recoded live.

[03:50] <Odin-LAP> THAT is insane.

[03:50] <SamB> Odin-LAP: what is it written in?

[03:50] <SamB> I know one that can reload plugins live...

[03:50] <Odin-LAP> SamB: Emacs lisp.

[03:50] <SamB> oh, well duh an elisp bot can be recoded live...

[03:51] <Odin-LAP> (So there's more than one source of crazy. ;)

[03:51] <SamB> as long as it leaves the input loop running

[03:51] <SamB> well, it sounds only slightly crazier than a mIRC-based bot...

[03:52] <Odin-LAP> I mean live, as in over IRC.

[03:52] <SamB> oh, that sounds like a security hole!

[03:53] <Odin-LAP> Nah. There is some insulation.

[03:53] <SamB> then again, I guess it isn't going to be much worse than a unix filesystem based MUD...

[03:53] <kelan> mooix!

[03:53] <SamB> thats the one

[03:53] <Odin-LAP> O_o

[03:53] <SamB> I don't think I installed it, it sounded so crazy...

[03:54] <kelan> i think its a pretty good idea if you don't need the box for anything else

[03:54] <Odin-LAP> That sounds ... interesting.

[03:54] <SamB> much saner to write an httpd in conventional MOO ;-)

[03:54] <kelan> why reinvent everything like the networking, multitasking, etc, when the OS will do it for you

[03:55] <kelan> Odin-LAP: mooix.net

[03:55] <kelan> er

[03:55] <kelan> hmm

[03:55] <SamB> kelan: maybe it would be a good use of UML

[03:56] <kelan> or xen!

[03:56] <kelan> i'd like to try xen, but its not drop-dead easy yet

[03:56] <kelan> and i'm too lazy:)

[03:57] * sproingie grumbles.  don't TALK to me about UML ... 2.6.8, gotta get the kernel myself...

[03:57] <Odin-LAP> Interesting idea, that.

[03:57] <sproingie> xen is something you have to boot into, right?

[03:57] <SamB> yeah, you need a special monitor and specially compiled kernels

[03:58] <SamB> (where monitors have nothing in particular to do with that screen on your desk)

[03:58] <sproingie> yah i want to build a minimal linux to use it strictly as a device driver host.  thought i could do the stripping down part with UML

[03:59] <scook0> autrijus: do you have a good reference for subcontinuations (shift/reset et al)?

[03:59] <sproingie> looks like i'll have to use a kernel.org kernel, since apt doesn't show a kernel that kernel-patch-uml supports

[04:00] <SamB> is it really a problem to run a 2.4-series UML?

[04:01] <autrijus> scook0: "shift to control" is how I learned it

[04:02] <autrijus> scook0: also see http://chneukirchen.org/blog/archive/2005/04/shift-reset-and-streams.html

[04:02] <autrijus> scook0: it's really easy to explain though

[04:02] <autrijus> (assuming you already grok callCC)

[04:02] <scook0> autrijus: thanks

[04:03] <autrijus> callCC $ \esc -> do { foo; bar; baz; esc 123; neverReached }

[04:03] <scook0> shift/reset aren't the easiest things to google for :(

[04:03] <scook0> yeah, I get callCC

[04:03] <autrijus> the problem with callCC is you always escape out the whole computation

[04:03] <autrijus> so neverReached is never reached

[04:03] <scook0> ah

[04:04] <scook0> so the escaping continuation needs to provide some way to get back to what it was doing previously?

[04:04] <autrijus> resetT $ do { foo; bar; shiftT $ \esc -> do { baz; esc 1; esc 2; esc 3; return 4 }; neveReached }

[04:04] <scook0> (to ensure that everything that's supposed to get executed eventually does)

[04:04] <autrijus> so look at that

[04:04] <autrijus> resetT creates a "prompt"

[04:04] <autrijus> then runs some computation

[04:05] <autrijus> inside that computation you can "shiftT"

[04:05] <autrijus> which is like callCC

[04:05] <autrijus> but the "esc" it gets can be called several times

[04:05] <scook0> nifty

[04:05] <autrijus> each time stopping at the place of resetT, never going beyond it

[04:05] <autrijus> finally at "return 4", it returns on resetT's behalf

[04:05] <autrijus> so neverReached is still neverReached

[04:06] <scook0> oh, that's easy--thanks for the explanation (autrijus++)

[04:06] <autrijus> but the important thing is that you "fetch" the \esc at the shiftT time

[04:06] <autrijus> instead of like, in callCC's case, you get the esc upfront

[04:06] <autrijus> and carry it all the way thru computation

[04:06] <autrijus> invoking it only once

[04:06] <scook0> I shall ponder this...

[04:07] <autrijus> so it's extremely handy to implement perl's return()

[04:07] <autrijus> where when you call some function, you push a prompt via resetT

[04:07] <autrijus> and to return from that function, you simply do a

[04:07] <autrijus> shiftT $ \esc -> return val

[04:07] <autrijus> the esc is ignored -- all we care is that we go back at the prompt

[04:07] <scook0> autrijus: I remember someone once explaining callCC as:

[04:07] <autrijus> \&return;

[04:08] <autrijus> (that's my explanation anyway)

[04:08] <scook0> sub callCC(&f) { f(\&return) }

[04:08] <autrijus> right. except it's kind of misleading

[04:08] <autrijus> because you'd think you can write &f as

[04:08] <autrijus> sub (&esc) { esc(1); esc(2) }

[04:08] <autrijus> while in fact esc(1) will never return

[04:09] <autrijus> so esc(2) will never happen

[04:09] <autrijus> unless you delimit it somehow (which is why resetT was invented)

[04:09] <scook0> because activating a callCC continuation will clobber the current path of execution

[04:09] <autrijus> yeah.

[04:09] <scook0> cheers

[04:09] <autrijus> =) glad to be of help

[04:10] <autrijus> for further enlightenment, read oleg's two posts

[04:10] <autrijus> http://www.haskell.org/pipermail/haskell/2005-April/015769.html http://www.haskell.org/pipermail/haskell/2005-May/015844.html

[04:11] <autrijus> in it he describes how to represent shiftT/resetT on a AST as a Zipper-like structure that can remember its position, so you can freely serialize them -- even multiple coroutine-like thread of execution

[04:11] <autrijus> trippy stuff.

[04:15] <autrijus> er, one correction

[04:15] <autrijus> resetT $ do { foo; bar; shiftT $ \esc -> do { baz; esc 1; esc 2; esc 3; return 4 }; neverReached }

[04:15] <autrijus> the "neverReached" is actually reached after "esc 1", "esc 2" and "esc 3"

[04:16] <autrijus> it's just not reached when you do "return 4".

[04:16] <autrijus> (for obvious reasons)

[04:16] <scook0> autrijus: I was just about to ask that :)

[04:16] <autrijus> :)

[04:16] <scook0> so when you activate 'esc', it provides the value to 'neverReached'

[04:16] <autrijus> well, yeah, but you need to write it properly

[04:16] <scook0> then when 'neverReached' steps off the end of the block, it goes back to after the 'esc' call

[04:17] <autrijus> { val <- shiftT $ \esc -> ...; neverReached val}

[04:17] <autrijus> or

[04:17] <autrijus> shiftT (\esc -> ...) >>= neverReached

[04:17] <autrijus> exactly.

[04:17] <scook0> oh, so in your example the value just gets discarded

[04:17] <autrijus> yes, as is the standard do notation

[04:17] <autrijus> when you don't write <- it's just discarded

[04:18] <scook0> aye

[04:18] <autrijus> when you have full callCC and runCont

[04:18] <autrijus> implementing shift/reset is trivial

[04:18] <scook0> so the <- would need to be attached to the shiftT for neverReached to see it

[04:18] <autrijus> a prompt is just a restart of runCont

[04:18] <autrijus> right.

[04:18] <autrijus> but that's just syntactic aspartame for >>=

[04:19] <autrijus> (but you already know that)

[04:21] <autrijus> ken's slides: http://www.eecs.harvard.edu/~ccshan/recur/talk.ps.gz

[04:23] <autrijus> page 8 gives operational semantics

[04:29] <autrijus> oh, you can actually pull a value out of "esc 1" to

[04:29] <autrijus> too

[04:30] <autrijus> shiftT (\esc -> do { x <- esc 1; ... })

[04:30] <scook0> talk.ps.gz was helpful, but scheme makes the control flow hard to understand

[04:30] <scook0> it's much easier with Haskell & do notation

[04:30] <autrijus> amen to that :)

[04:31] <autrijus> but you can hand-translate them; it's good (and easy) exercise

[04:31] <autrijus> i.e. (cons 'x (reset (cons 'y '())) becomes

[04:31] <autrijus> x <- return "x"

[04:32] <autrijus> rest <- resetT $ do

[04:32] <autrijus>     y <- return "y'

[04:32] <autrijus>     nil <- return []

[04:32] <autrijus>     return (y:nil)

[04:32] <autrijus> return (x:rest)

[04:32] <scook0> shiftT has an implicit resetT, right?

[04:33] <scook0> so with nested shiftTs, the inner one will only execute up to the end of the outer one

[04:33] <scook0> (the inner esc, I mean)

[04:34] <autrijus> yes. if you shiftT without any outer resetT

[04:34] <autrijus> then I imagine it behaving as callCC

[04:34] <autrijus> i.e. effectively undelimited

[04:34] <autrijus> oh wait. that's not what you're asking

[04:34] <autrijus> you're asking shiftT $ \esc -> shiftT $ \esc2 -> ...

[04:34] <autrijus> no, the outer shiftT doesn't create a new resetT

[04:34] <autrijus> the two esc share a single prompt

[04:35] <autrijus> leading to very mind-bending evaluation

[04:39] <autrijus> page 11 discusses a variant of shift, called control, that erases the reset when invoking esc

[04:40] <autrijus> SPJ discusses all those variants in depth, using monadic notation, at http://research.microsoft.com/Users/simonpj/papers/control/control.pdf

[04:40] <autrijus> (with dybvig and sabry)

[04:40] <autrijus> their treatment is what Pugs.Cont.* is based one

[04:40] <autrijus> s/one/on/

[04:41] <scook0> oh, I won't worry about it then

[04:42] <autrijus> it's hard for me to ponder these thoughts without feeling sanity crumbling away :)

[04:44] <scook0> oh, how come we have two different definitions for shiftT/resetT in Pugs?

[04:45] <autrijus> I think they are compatible

[04:45] <autrijus> the one given in AST.Internals is just rigidifying the types

[04:45] <autrijus> limiting both the prompt and the reset return type as Val

[04:46] <autrijus> it's there because EvalT is a new monad transformer

[04:46] <autrijus> so we can't simply reuse ContT's definition

[04:47] <autrijus> but have to define MonadCont-compatible shift/reset, by "boxing" EvalT/runEvalT

[04:47] <autrijus> on top of the existing definition

[04:47] <scook0> oh, ok

[04:47] <autrijus> all these trouble is only because I want a new definition of fail""

[04:47] <autrijus> if we were simply ContT ReaderT IO

[04:47] <autrijus> fail"" will trigger ioError

[04:48] <autrijus> and discard the prompt

[04:48] <autrijus> compare it with

[04:48] <autrijus>     fail str = do

[04:48] <autrijus>         pos <- asks envPos

[04:48] <autrijus>         shiftT . const . return $ VError str [pos]

[04:48] <autrijus> which gives a much better treatment

[04:48] <autrijus> (it'd be lovely if you can haddock this) :))

[04:49] <scook0> autrijus: that's the idea

[04:49] <autrijus> cool. basically the new fail"" semantic is

[04:50] <autrijus> "drop the current subcontinuation; report the error, along with the current position, at the caller's prompt"

[04:50] <autrijus> the caller will use Eval.trapVal to propagate the error upward

[04:50] <autrijus> adding the stack trace as it goes

[04:50] <autrijus> or handle the error itself

[04:50] <autrijus> compare it with the old fail"" semantic

[04:51] <scook0> I'm still not exactly sure what 'prompt' means though

[04:51] <autrijus> "drop the ContT context with ReaderT environment, raise IO error at the topmost execution"

[04:51] <autrijus> okay. a "prompt" means "something that waits for a value"

[04:51] <autrijus> resetT creates such a prompt

[04:51] <autrijus> do { val <- resetT; ... }

[04:51] <autrijus> do { val <- resetT computation; ... }

[04:51] <scook0> so the new fail lets you get sane stack traces, and even possibly recover?

[04:51] <autrijus> here the resetT is a prompt for computation

[04:51] <autrijus> exactly. that's the idea

[04:52] <scook0> curious

[04:52] <scook0> hopefully I can get something written up this weekend

[04:52] <autrijus> before this new fail"", almost all exceptions are uncatchable :)

[04:53] <scook0> because I have exams all next week :(

[04:53] <autrijus> ahh. take your time then.

[04:53] <autrijus> scook0++ # immensely helpful

[04:53] <scook0> autrijus++ # doubly so

[04:55] * scook0 is afk (going for a drive soon)

[04:55] <autrijus> :) I'll return to my paper now

[04:55] * autrijus afk &

[05:10] * autrijus ponders how to implement the harmful control construct goto/label in pugs.

[05:11] <autrijus> each label takes a callCC and store it in some global hash, probably.

[05:11] <autrijus> fortunately there is no active demand for that feature :)

[05:12] <QtPlatypus> Is there even a goto/label in the perl6 spec?

[05:14] <arcady> there should be a come from

[05:14] <autrijus> To jump into the next "when" block you must use  a "goto"

[05:14] <autrijus> (S04)

[05:15] <autrijus> Ordinary "goto" should work as long as it’s leaving the current "try" scope.

[05:15] <autrijus> (A04)

[05:15] <autrijus> so obviously it's still there

[05:15] <arcady> I thought that was "continue", but okay

[05:15] <autrijus> arcady: http://search.cpan.org/dist/Acme-ComeFrom/

[05:15] <autrijus> I even made sure that

[05:15] <autrijus> label: comefrom label; ... comefrom label;

[05:15] <autrijus> forks at the label: point

[05:15] <autrijus> ;)

[05:15] <arcady> heh

[05:16] <autrijus> implicit parallelisation!

[05:16] <arcady> but yeah, the falling through to the next when block is done with "continue" according to S04

[05:17] <arcady> "You can explicitly break out of a when block and go to the next statement by using continue. "

[05:17] <arcady> oh, hm

[05:17] <autrijus> arcady: the diff is

[05:17] <autrijus> given $blah {

[05:17] <autrijus>     when 1 { ... }

[05:17] <arcady> yeah, i see now

[05:18] <autrijus>     print "foo!"

[05:18] <autrijus>     when 2 { ... }

[05:18] <autrijus> }

[05:18] <autrijus> it results from the very loose coupling between given and when

[05:18] <arcady> continue overrides the implicit jump out of given

[05:18] <autrijus> yup

[05:21] <arcady> and i see pugs has continue

[05:21] <arcady> but not goto?

[05:21] <autrijus> yeah.

[05:21] <autrijus> because we don't yet have labels

[05:21] <autrijus> we have the &sub.goto() form

[05:22] <autrijus> which is just claling &sub without changing caller

[05:22] <arcady> oh ah

[06:01] <Khisanth> what would be the result of 1..10:by(3) ?

[06:02] <autrijus> (1,4,7,10) ?

[06:03] <chromatic> I'm feeling bug-fixing-ish.

[06:04] <chromatic> Particularly t/oo/submethods.t.

[06:05] <chromatic> Can anyone who understands signature handling give me a hint?

[06:05] <Khisanth> autrijus: oops, 1..11:by(3) :)

[06:05] <autrijus> chromatic: what do you want to fix?

[06:05] <autrijus> Khisanth: same I think

[06:06] <chromatic> Passing values to methods with named parameters that aren't object attributes.

[06:06] <chromatic> Khisanth, I agree with autrijus.

[06:07] <autrijus> chromatic: method foo ($bar) { ... } ; $obj.foo(bar=>3);

[06:07] <autrijus> like that?

[06:07] <chromatic> Yep, see t/oo/submethods.t tests 21, 22, and 24.

[06:07] <Khisanth> ok, so is there a haskell equivalent of perlfunc? (I know where to find the list them but not the actual descriptions)

[06:07] <chromatic> I'm looking in Pugs.Bind.

[06:08] <autrijus> chromatic: you give weird things

[06:08] <autrijus>       $.value = 'default calculated value' unless $value;

[06:08] <chromatic> Khisanth, from ghci try :b packagename.

[06:08] <autrijus> I'd thought

[06:08] <chromatic> :b Prelude

[06:08] <autrijus> submethod BUILD ( ?$.value = 0 )

[06:08] <autrijus> am I mistaken?

[06:08] <autrijus> chromatic: the way to write it of course the 100 is not assigned

[06:09] <chromatic> Yes, that's probably a bad example.

[06:09] <autrijus> s/to/you/

[06:09] <autrijus> so if I have

[06:09] <autrijus> method blah ($.x) { }

[06:09] <autrijus> does calling blah(3) automatically assign into $.x?

[06:09] <autrijus> that sounds weird, but if that's that, that's that.

[06:10] <chromatic> It's positional in that case into the first one I think.

[06:10] <autrijus> huh?

[06:10] <chromatic> I don't remember all of the rules on where the switch is from positional to named.

[06:10] <Khisanth> chromatic: I was thinking of something closer to "man strcpy" than "less string.h"

[06:11] <chromatic> :browse gives their names, :t gives more details on function types.

[06:11] <chromatic> That's as much as I use of ghci at the moment anyhow.

[06:11] <autrijus> :i is useful too

[06:11] <autrijus> chromatic: hey. I'm writing about perl6's execution model.

[06:12] <autrijus> chromatic: do you have some time so I can run it by you here for sanity-checking purposes?

[06:12] <chromatic> Sure!

[06:12] <chromatic> If you help me with making these tests a) better and b) pass.  :)

[06:12] <autrijus> sure thing :)

[06:12] <chromatic> Suppose I said submethod BUILD ( $?value = 1 ) { $.double_value = $value * 2 }

[06:13] <chromatic> Is that more sensible?

[06:13] <autrijus> sure.

[06:13] <chromatic> Alright, I'll check that in.

[06:13] <autrijus> the trick to make them pass is simple

[06:14] <autrijus> make op1WalkAll take an extra parameter, the list of args to new

[06:14] <autrijus> I mean to BUILD

[06:14] <chromatic> Is it only BUILD where this doesn't work?

[06:14] <autrijus> and make BUILDALL take a list of arguments, instead of nothing

[06:14] <autrijus> sure. the problem is only that .new() doesn't pass args to BUILD.

[06:15] <autrijus> that's all.

[06:15] <autrijus> also I think you want ?$value=1

[06:15] <autrijus> not $?value=1

[06:15] <chromatic> Yes, that was a typo here, not in the test.

[06:15] <autrijus> k. so just make BUILDALL a op2

[06:16] <autrijus> taking the named args as the argument

[06:16] <autrijus> then pass all of them as separate pair of values into BUILD

[06:16] <autrijus> that's all

[06:16] <chromatic> Where do I find the args?

[06:16] <autrijus> they are unpacked for you already

[06:16] <autrijus> in line 939 Prim

[06:17] <autrijus> as "named"

[06:17] <chromatic> Ah, I see.

[06:17] <autrijus> say if it's 

[06:17] <autrijus> a map of (:x<a>, :y<b>)

[06:17] <autrijus> then you want the op1WalkAll call as

[06:18] * chromatic writes a list comprehension in his head

[06:19] <autrijus> "&BUILD" (Just (Val obj)) [ App (Var "&infix:=>") Nothing [Val key, Val val] | (key, val) <- Map.assocs named ]

[06:19] <autrijus> er I mean

[06:19] <autrijus> App (Var "&BUILD") (Just (Val obj)) [ App (Var "&infix:=>") Nothing [Val key, Val val] | (key, val) <- Map.assocs named ]

[06:19] <ingy> hola camelambs

[06:19] <autrijus> or something like that.

[06:19] <autrijus> hi ingy

[06:19] <ingy> hi again =)

[06:19] <autrijus> chromatic: now, can I start ranting about the execution model? :)

[06:20] <chromatic> Hm, when I'm sure I have the right code.

[06:20] <chromatic> I'm in Pugs.Prim right now.

[06:20] <autrijus> I think I'll type away anyway :)

[06:20] <chromatic> Sure.

[06:21] <chromatic> I'm looking at op2 "BUILDALL", around like 550.

[06:21] <autrijus> (the background is section 2 of http://svn.openfoundry.org/pugs/docs/talks/hw2005.txt )

[06:21] <autrijus> (where I'd welcome sanity-checking too -- it's about perl 6 history without me having any first-hand knowledge)

[06:22] <chromatic> It looks pretty reasonable.

[06:22] <chromatic> There were a couple of Perl.com articles about the RFC process that might be interesting background.

[06:22] <chromatic> I don't know how much detail you need though.

[06:22] <autrijus> I've read all of them, I think :)

[06:22] <autrijus> so. perl 6 proposes a highly unusual execution model to address the metaprogramming needs.

[06:23] <autrijus> perl 6 assumes no static grammar. instead, the parser is assumed to be running inside a perl 6 execution environment

[06:24] <chromatic> Yes, mostly.

[06:24] <chromatic> It's unclear how that will work with IDEs and things that want to parse Perl.

[06:24] <autrijus> with an initial set of Rules that correspond to the default syntactic constructs.

[06:24] <chromatic> Yes.

[06:24] <autrijus> when a source code is parsed, the perl 6 program -- that is the parser -- runs

[06:24] <autrijus> taking the source as the input to the toplevel "program" Rule

[06:25] <autrijus> which is composed of sub-rules that returns AST nodes of various types.

[06:26] <autrijus> at various point during parsing, for example during a BEGIN{} block, the parser hands the partly finished AST to the code generator

[06:26] <autrijus> the codgen turns that partial AST into object code 

[06:26] <chromatic> At various points, rules can execute code themselves.

[06:27] <autrijus> load it into memory, and execute them.

[06:27] <autrijus> those object code have full access to the intermediate parse tree

[06:28] <autrijus> as well as the parser itself and the active grammar 

[06:28] <autrijus> and it can modify them freely at will

[06:28] <autrijus> (I'm not sure if the modification is constrained in the lexical scope.)

[06:28] <autrijus> (or indeed whether the idea of a lexical scope can be altered.)

[06:29] <QtPlatypus> chromatic: My understanding that its intended for perl6 to spit be able to spit out an AST for IDE's to be use for code highlighting ect.

[06:29] <chromatic> I'm not sure the scope is lexical either.

[06:29] <autrijus> chromatic: right, but the S* keeps referring those dangerous rewritings as lexical and hygenic

[06:29] <autrijus> but anyway.

[06:30] <autrijus> it is also not sure if the BEGIN{} block can modify the codegen.

[06:30] <chromatic> I've always thought of it as replacing parts of the grammar in a dynamic sense, if there's scope or such.

[06:31] <autrijus> i.e. by extending the types of AST nodes

[06:31] <autrijus> or augmenting the code generator by redefining of subclassing it.

[06:31] <autrijus> it sounds like a natural consequence of allowing BEGIN{} blocks _and_ having the parser/codegen running in a normal perl 6 execution context.

[06:32] <autrijus> I'm also not sure how it deals with multiple code generator backends.

[06:32] <chromatic> I'm not sure anyone asked that question before.

[06:33] <autrijus> but in any case, both the grammar, the parser and the code generator may be augmented -- or swapped out entirely -- by some compile-time code in the program.

[06:33] <chromatic> Exactly.

[06:33] <autrijus> so this is unlike the metaprogramming in Lisp or Forth

[06:33] <autrijus> acting on the parsed AST level

[06:33] <autrijus> this is instead acting on the concrete syntax level

[06:34] <autrijus> i.e. the source code string itself.

[06:34] <chromatic> That depends.

[06:34] <Khisanth> in other words "this bit of code might do something completely different from what you expect"?

[06:35] <autrijus> that is, while lisp macros typically transforms AST to AST, perl macros can redefine how the parser transform source code to AST.

[06:35] <chromatic> Clearly the easiest way to describe a new grammar is by writing rules that manipulate source code strings and produce AST nodes, but I've always expected to transform AST as well.

[06:35] <autrijus> (it can, by extension, also do AST->AST.)

[06:35] <autrijus> by augmenting the parser.

[06:35] <autrijus> but the "is parsed" and what little macro specification we see

[06:36] <chromatic> Ugh, now I have two different signatures for op1WalkAll.

[06:36] <autrijus> is all based on the C-macro-like source transformation model

[06:36] <autrijus> instead of operating on ASTs alone

[06:36] <autrijus> chromatic: that's fine, have DESTROYALL pass an empty args.

[06:37] <chromatic> autrijus, I think the C-macro-like is just the easiest entry point.

[06:38] <autrijus> chromatic: nod.

[06:38] <autrijus> but anyway. it's clear that how &infix:<(((> changes the grammar

[06:38] <chromatic> I mean, it's an actual language, not just an AST.  Lisp's had 50 years to come up with a syntax and Erlang's not exactly replacing C yet.

[06:39] <chromatic> Do you mean by text-substitution?

[06:39] <autrijus> I hope not.

[06:40] <chromatic> Me neither.  Good.

[06:40] <autrijus> I meant that &infix:<(((> creates a new rule in the precedence parser.

[06:40] <autrijus> and persumably "is parsed" and "macro foo" calls creates entries into the parser classes

[06:40] <autrijus> as callbacks that can potentially redefine parts of the parser

[06:41] <autrijus> finally, depending on the code generator in effect, BEGIN{...} blocks also have a chance of affecting how the object code is generated.

[06:41] <chromatic> The last I remember is that they override methods of the parser.

[06:41] <autrijus> right, that's what I thought too.

[06:41] <chromatic> Think of Grammar as a class and Rule as a method.

[06:42] <autrijus> so it's all highly dynamic and not at all what you'd expect from a separate compilation regime.

[06:42] <chromatic> Exactly.

[06:43] <autrijus> so suppose my program looks like:

[06:43] <autrijus> use Foo; print 1;

[06:43] <chromatic> I'm not sure exactly the role of BEGIN.  From the Perl 5 sense, that's where you'd load modules that could define macros or alternate grammars.

[06:43] <autrijus> can the Foo module alter how the "print 1" is parsed?

[06:43] <autrijus> perl 5 lets you do that via source filters among other things.

[06:44] <autrijus> however, if macros in the Foo module are constrained to be lexical, it cannot touch the calling program.

[06:44] <chromatic> I don't see why not.

[06:44] <autrijus> so they are not lexical.

[06:44] <chromatic> I think they can escape.

[06:44] <autrijus> okay. suppose they escape.

[06:44] <chromatic> Otherwise how would you use a grammar defined elsewhere?

[06:44] <autrijus> now Foo is not "Foo.pm"

[06:44] <autrijus> but rather "Foo.pbc"

[06:44] <autrijus> since we assume separate compilation

[06:45] <autrijus> (or "Foo.so", or "Foo.jar")

[06:45] <autrijus> right?

[06:45] <chromatic> I'm not sure.

[06:45] <autrijus> but that is a critical point :)

[06:46] <chromatic> Foo doesn't have to be Foo.pm, at least.

[06:46] <autrijus> I thought the idea was that we no longer need to keep the source code of all modules involved to compile a program.

[06:46] <autrijus> because it will make it impossible to hide the source code, among other things.

[06:46] <chromatic> Right.  You have the option of loading from bytecode.

[06:46] <autrijus> so assume Foo.pbc is bytecode.

[06:47] <autrijus> then we have a mismatch in the execution context.

[06:47] <autrijus> if Foo.pm is source code, it will be parsed along with my main.p6

[06:47] <chromatic> You need an alternate loader.

[06:47] <chromatic> I need an empty VHash in the DESTROYALL call.

[06:47] <autrijus> just as if I wrote "BEGIN { eval slurp("Foo.pm") }"

[06:47] <autrijus> chromatic: an empty VHash is written as Map.empty

[06:48] <autrijus> so. if Foo.pm is source code, it will be parsed along with my main.p6

[06:48] <chromatic> Yes.

[06:48] <autrijus> and its BEGIN{} block will run.

[06:48] <autrijus> whenever I compile my main.p6.

[06:48] <autrijus> if Foo.pbc is bytecode

[06:48] <autrijus> it has no BEGIN{} block.

[06:48] <autrijus> and whatever ways it has to affect the parser will be moot.

[06:49] <autrijus> when I compile my main.p6.

[06:49] <autrijus> that's the thing that bugs me.

[06:49] <autrijus> perl5 doesn't have this problem because we assume that source filters, BEGIN blocks and other macro things are always executed

[06:49] <chromatic> It should be able to affect the parser.

[06:49] <arcady> you could maybe put BEGIN blocks in the pbc somehow

[06:50] <chromatic> Parrot bytecode has @LOAD and @INIT hooks on subroutines.

[06:50] <autrijus> arcady: except they are specified to not effect runtime... INIT{} blocks do.

[06:50] <arcady> right

[06:50] <arcady> but they'd be run at compile time

[06:50] <autrijus> chromatic: I thought the idea of BEGIN block is that they are always compiled away.

[06:50] <autrijus> say Foo.pm has "my $x = BEGIN { 3 };"

[06:50] <autrijus> Foo.pbc should just mean "my $x = 3"

[06:50] <autrijus> if it's not like that, then the spec of BEGIN needs to change

[06:51] <arcady> well, it might have a "BEGIN" segment that's only for running by the compiler

[06:51] <chromatic> I see why you wonder if grammar changes are lexical.

[06:52] <autrijus> thanks for understanding.

[06:52] <chromatic> If they are, then they only affect the current compilation unit and by the time it produces an AST to turn into bytecode, it's as weird as it's going to be and it's fine.

[06:52] <autrijus> exactly! that's how most other language do that.

[06:52] <autrijus> but if it leaks out to other compilation units

[06:53] <autrijus> then those units will depend on the grammar changes to always be recomputed

[06:53] <chromatic> If it leaks out (as I think it does), then bytecode needs to save something to run on load to mangle the world again.

[06:53] <autrijus> but what exactly?

[06:53] <autrijus> because we can't just snapshot a delta

[06:53] <autrijus> there's no delta

[06:53] <chromatic> P5 import() keeps coming to my mind.

[06:54] <chromatic> At compile time of SomethingSpiffy.p6, it loads IngyGrammar.pbc.

[06:55] <chromatic> Then it calls the moral equivalent of import() which makes everything funky in SomethingSpiffy's grammar and life continues as nicely.

[06:55] <chromatic> I dunno.  That's my impression.

[06:55] <autrijus> the signature of that import() will be very curious then.

[06:56] <chromatic> import( "Everything I Know About Myself" )?

[06:56] <autrijus> right.

[06:57] <autrijus> { use LexicalPragma; python code here }

[06:57] <chromatic> Or there's some hook for current grammar.

[06:58] <autrijus> then LexicalPragma.pbc must contain some way to turn python code into PIR

[06:58] <autrijus> and swap out the parser entirely

[06:58] <chromatic> upgrammar

[06:58] <autrijus> upgrammar?

[06:59] <chromatic> It's like upvar, but scarier.

[06:59] <autrijus> and if the current compilation target is not PIR, then LexicalPragma.so must contain some way to compile python code to compatible .so

[06:59] <autrijus> and emit the neccessary loading magic.

[07:00] <chromatic> Can it just know how to compile whatever to the standard AST?

[07:00] <autrijus> there's no standard AST for inline C code, is there.

[07:00] <arcady> and isn't PIR supposed to be replaced with some sort of AST?

[07:00] <autrijus> arcady: sure, but those won't be Perl6 AST.

[07:01] <autrijus> unless of course perl 6's design goal of compiling to non-parrot machines gets dropped :)

[07:01] <chromatic> There's potential AST that knows how to wrap inline C code.

[07:02] <autrijus> chromatic: sure. but it's just handing the problem to the codegen.

[07:02] <autrijus> I don't think we can do

[07:02] <autrijus> foo.p6 -> foo.p6ast -> foo.pbc

[07:02] <autrijus> because the parser and codegen are executed in lockstep

[07:03] <autrijus> unless the .p6ast somehow serialises the active grammar, parser state and continuation

[07:03] <chromatic> It ought to serialize loading the grammar anyhow.

[07:04] <autrijus> hm?

[07:05] <chromatic> Maybe not.

[07:05] <chromatic> Tough question.

[07:06] <autrijus> this also means that the Parser and codegen must be written in Perl 6, or something isomorphic to Perl 6.

[07:06] <autrijus> (because otherwise you can't augment them with perl 6 code. )

[07:06] <chromatic> Yeah, that's been true for a long time.

[07:06] <autrijus> since perl 5.000.

[07:06] <autrijus> :)

[07:06] <autrijus> hm, 10 years.

[07:08] <autrijus> it also means the parser and codegen can't be two programs.

[07:08] <autrijus> they must share the each other's symbol table.

[07:08] <autrijus> i.e. a global variable defined in parser stage still needs to be visible during the partial codegen in BEGIN, and vice versa.

[07:10] <chromatic> Because parsing might have side effects?

[07:10] <autrijus> exactly.

[07:10] <autrijus> or may indeed depedn on side effects.

[07:10] <chromatic> Right.

[07:10] <chromatic> hm, op2 "BUILDALL" obj named

[07:10] <chromatic> named is a VHash, but op2 expects a Val there.

[07:11] <chromatic> Do I cast?  Wrap?  Curse?

[07:11] <autrijus> curse I think

[07:11] <autrijus> you can either:

[07:12] <autrijus> 1. wrap it into a (VRef . hashRef)

[07:12] <autrijus> or

[07:13] <autrijus> 2. unpack them into a VList

[07:13] <autrijus> or

[07:13] <autrijus> 3. expToEvalVal.

[07:13] <autrijus> i.e. prepare the Exp in new

[07:13] <autrijus> then use expToEvalVal to turn it into a Val

[07:14] <autrijus> you can get back that Exp using a regular fromVal.

[07:14] <autrijus> improvise :)

[07:14] <chromatic> #1 sounds the easiest

[07:14] <chromatic> op2 "BUILDALL" obj $ (VRef . hashRef) named

[07:15] <chromatic> Of course, "easy" often misses "subtly wrong".

[07:15] <autrijus> ok... then you can get "named" back with

[07:16] <autrijus> doHash val hash_fetch

[07:16] <autrijus> i.e.

[07:16] <autrijus> fetch <- doHash val hash_fetch

[07:16] <autrijus> named <- fetch

[07:16] <autrijus> or, more easily

[07:16] <autrijus> named <- join $ doHash val hash_fetch

[07:16] <chromatic> join?

[07:17] <autrijus> monadic join.

[07:17] <autrijus> join :: (Monad m) => m (m a) -> m a

[07:17] <chromatic> Ah.

[07:17] <autrijus> it turns a Eval (Eval a) into Eval a

[07:17] <autrijus> handy stuff.

[07:18] <chromatic> Y'know, at some point that's just silly.

[07:19] <autrijus> sure... but silliness beats insanity

[07:19] <autrijus> trying to reason about things without using types are far insaner.

[07:19] <autrijus> (if indeed easier)

[07:20] <autrijus> (for simple cases)

[07:20] <chromatic> Alright, I'm fairly stuck now.

[07:20] <chromatic> I'll paste the patch so far.

[07:20] <autrijus> cool. time to commit! :)

[07:22] <pasteling> "chromatic" at 63.105.17.30 pasted "Adding arguments to BUILDALL and DESTROYALL" (49 lines, 2.1K) at http://sial.org/pbot/10699

[07:23] <chromatic> Hmm, I'm guessing that having hashval after v is a problem now.

[07:25] <autrijus> all fixed, committed.

[07:25] <autrijus> two things: VStr key needs to be (Val (VStr key))

[07:25] <autrijus> and the Map.empty needs a signature of (::VHash).

[07:25] <autrijus> enjoy :)

[07:25] <autrijus> r4367

[07:26] * scook0 returns

[07:26] <chromatic> Were my parameters to op1WalkAll in the correct order in the proposed patch?

[07:27] <autrijus> no, you forgot the x

[07:27] <autrijus> but it's just currying

[07:27] <autrijus> so I did away the the explicit unpacking

[07:27] <autrijus> op2 "BUILDALL" = op1WalkAll id "BUILD"

[07:27] <autrijus> 'sall

[07:28] <chromatic> Yeah, I saw that and realized "Wait, that's not enough arguments, so it's currying."

[07:28] <autrijus> *nod*

[07:28] <autrijus> soon you'll be writing higher-order functions without thinking about it. :)

[07:28] <chromatic> Look at Text::WikiFormat sometime.

[07:29] <chromatic> Actually, don't.  Just trust me on that.

[07:29] <autrijus> I think I submitted a patch long ago :)

[07:29] <autrijus> possibly my first patch to the perl community

[07:29] <chromatic> It's a lot easier to identify HOF when there's syntax showing that you've partially applied arguments.

[07:30] <autrijus> sure, but it's much harder to do abstractions while having to think about it

[07:30] <autrijus> so it's all about what to optimise for :)

[07:31] <chromatic> Sure.  I'll complain about the opposite tomorrow.

[07:31] <autrijus> XD

[07:32] <autrijus> ok 24 - ... or value passed in # TODO bug

[07:32] <autrijus> isn't it nice that it works whenever it compiles? :)

[07:32] <autrijus> chromatic++

[07:33] <chromatic> I'm not sure why v and hashref aren't backwards.

[07:33] <chromatic> hashval

[07:34] <autrijus> the v is invocant

[07:34] <autrijus> the object itself

[07:34] <autrijus> the hashval is named args

[07:34] <chromatic> Ah, right.

[07:34] <chromatic> I thought V was for Vendetta though.

[07:34] <autrijus> heh.

[07:34] <autrijus> no, it's for von neumann

[07:35] <chromatic> There's a Von Neumann Drive just down the street a ways from here.

[07:35] <chromatic> I keep thinking "Road is Sidewalks" but they don't appreciate that.

[07:35] <autrijus> so it seems that I can change the rules that defines the grammar of Rules.

[07:36] <autrijus> thereby metaprogramming the macros.

[07:36] <chromatic> Seems right.

[07:36] <autrijus> can't do that while PGE is written in PIR though.

[07:37] <autrijus> needs to lift PGE into perl 6 to do that.

[07:37] <chromatic> Or at least have it overridable from Perl 6.

[07:37] <chromatic> That's the last plan I heard.

[07:37] <autrijus> hm, how?

[07:38] <autrijus> that sounds kind of impossible in light of callbacks from rules.

[07:38] <chromatic> Make them visible to Perl 6 as "objects".

[07:38] <autrijus> er, sure, but I mean the PGE/P6Rule parser itself

[07:38] <autrijus> say I want to rebind the "character class" subrule.

[07:39] <chromatic> Define a subrule that overrides it.

[07:39] <chromatic> Cringe.

[07:39] <autrijus> can't do that unless PGE/P6Rule is written in PGE.

[07:39] <autrijus> I'm sure you know what I mean :)

[07:39] <autrijus> say I want to rebind the 'a' token to always yield 'b'.

[07:39] <chromatic> Four hours ago, sure!  Right now?  It doesn't seem completely impossible.

[07:39] <chromatic> Oh, at an atomic level?

[07:40] <autrijus> yeah.

[07:40] <autrijus> 'a' is just another token, no?

[07:40] <autrijus> as part of a rule

[07:40] <chromatic> I see your point.

[07:40] <autrijus> hence "metaprogramming the macros"

[07:41] <chromatic> Right.

[07:41] <chromatic> Argh, that didn't fix everything I wanted to fix.

[07:41] <autrijus> what else you want to fix?

[07:41] <chromatic> I forgot that roles aren't quite there.

[07:41] <autrijus> oh. right.

[07:42] <autrijus> stevan is supposed to have a concrete implementatoin for me to copy.

[07:42] <autrijus> (written in perl5)

[07:42] <chromatic> I also have better rules for $?CLASS, $?MODULE, $?PACKAGE, and $?ROLE, but they depend on the metamodel to some extent.

[07:42] <autrijus> so I was thinking I'd wait on that while focusing on perl5embed and parrot codegen

[07:43] <autrijus> nod. I wonder if you can get in touch with stevan to hack the p5-based metamodel prototype

[07:43] <chromatic> All I really need at the moment is to be able to call BUILD submethods from roles.

[07:43] <autrijus> it seems an easy way to produce more rigorous tests.

[07:43] <chromatic> Will do.  I can look at that some tomorrow.

[07:44] <autrijus> chromatic++

[07:45] <chromatic> Are roles not parents?

[07:45] <chromatic> In the current implementation, I mean?

[07:46] <autrijus> role is synonym to class

[07:46] <autrijus> and does is synonym to is.

[07:46] <autrijus> and submethod is synonym to method. 

[07:47] <autrijus> so it's more like completely missing instead of subtly wrong :)

[07:47] <chromatic> I thought so.  Let me dig a little more into my failing tests.

[07:54] <chromatic> autrijus, can you look at tests 02[1-4]*t for Test::Builder?

[07:54] <chromatic> If I make $.diagnostic $diagnostic in BUILD() and set it manually, they pass.

[07:54] <chromatic> In Test::Builder::Test, that is, in the Test::Builder::Test::Base role.

[07:55] <autrijus> sure. because sub doesn't take dot-params yet.

[07:55] <autrijus> I need a definition of its semantic.

[07:55] <autrijus> method set_foo ($.foo) {;}

[07:55] <autrijus> method set_foo (?$.foo) {return $.foo}

[07:55] <autrijus> method set_or_get_foo (?$.foo) {return $.foo}

[07:55] <autrijus> is that legal?

[07:55] <chromatic> It sets some of them though.

[07:55] <sili_> where should i be looking to learn perl6 so far?

[07:55] <autrijus> "Rules are composable, first-class functions, written in a sub-language of Perl

[07:55] <autrijus> 6 that can parse context sensitive, infinite look-ahead grammars.

[07:55] <autrijus> "

[07:56] <autrijus> gawd that sentence is dense.

[07:56] <autrijus> sili_: docs/quickref/ in Pugs -- also examples/ -- also the Synopsis documents in dev.perl.org

[07:56] <sili_> thanks

[07:57] <autrijus> np :)

[07:57] <chromatic> autrijus, I'm not sure of your question.

[07:57] <autrijus> chromatic: okay.

[07:57] <autrijus> sub foo ($.x); # syntax error?

[07:57] <autrijus> sub foo ($.x) {...}; # syntax error?

[07:57] <chromatic> First one, probably without a block a syntax error.

[07:57] <autrijus> method foo ($.x) {}; # automatically set $.x upon calling?

[07:57] <chromatic> Second one, runtime error.

[07:58] <chromatic> Wait, sub... yeah, those are probably syntax errors.

[07:58] <chromatic> Third one, yes, the comment is right.

[07:58] <autrijus> method foo (?$.x) {}; # sets $.x to undef if called without arguments?

[07:58] <Khisanth> why does that block have a ;?

[07:58] <chromatic> Because it loves to cuddle ;s.

[07:59] <autrijus> Khisanth: no good reason :)

[07:59] <chromatic> How about "leaves $.x with its current value".

[07:59] <autrijus> I thought ?$x is specced as ?$x=undef .

[07:59] <autrijus> do we extend ?$.x to mean ?$.x=$.x ?

[07:59] <chromatic> Good question.  Let me peruse AES.

[08:00] <autrijus> I'm also wary of parameter bindings that does nonlexical assignment.

[08:00] <autrijus> but if that's the common case we're optimising for, oh well.

[08:01] <chromatic> $.foo is lexical in the sense that it's operating on a lexical invocant.

[08:01] <autrijus> but it erases something, namely $.foo's old value.

[08:01] <autrijus> i.e. it destroys information

[08:01] <autrijus> while normal binding doesn't do that.

[08:02] <chromatic> Yeah, but we *really* liked it when we came up with it.

[08:02] * autrijus dons the implementation monkey hat

[08:02] <autrijus> Ook!

[08:02] <chromatic> Alright, S06 confirms that they default to undef.

[08:03] <autrijus> easy then.

[08:03] <chromatic> I'm not sure about that for attributes, but there you go.

[08:03] <chromatic> Shouldn't that be "implementation orangutan"?

[08:03] <autrijus> heh.

[08:03] <autrijus> okay. now look at this.

[08:03] <autrijus> method foo ($.x) {"do nothing"; return}

[08:03] <autrijus> $obj.foo(1|2);

[08:04] <autrijus> say $obj.x;

[08:04] <autrijus> this is undefined right.

[08:04] <autrijus> i.e. it may print 1 or 2 depending on the phase of moon

[08:04] <chromatic> Can I mumble "autothread" and run out of the door in the ensuing confusion?

[08:04] <autrijus> among other factors

[08:04] <autrijus> sure, we know .foo is called twice :)

[08:05] <autrijus> and $.x is set either first to 1 then 2, or first to 2 then 1.

[08:05] <chromatic> Unless there's a pragma in effect that says "Don't autothread outside of a junctive expecty context".

[08:05] <chromatic> If there's such a pragma.

[08:05] <chromatic> I'm okay with leaving that undefined now though.

[08:05] <autrijus> I'd also like to know how to define such a pragma.

[08:05] <chromatic> It's an extension of taint mode.

[08:06] <chromatic> Call it uncertainty mode.

[08:06] <autrijus> not concrete enough :)

[08:06] <chromatic> "Future too hazy at some_program.p6, line 42: ask again later"

[08:06] <autrijus> but I'll let it pass for now... 

[08:07] <Khisanth> perl6 will also be a fortune teller :)

[08:07] <chromatic> I don't think that discussion has ended quite yet.  Damian and Patrick had a short conversation about how a core-enough implementation of sets would help unconfuse people about junctions.

[08:08] <autrijus> alright then.

[08:08] <autrijus> I'll wait until I can see test or code :)

[08:08] <autrijus> the easiest way to implement method ($.x) is by hacking applyExp to look at each bound symbol that matches (sigil:'.':name) 

[08:08] <sili_> i'm having troubles writing a for loop :( how do i iterate over 1,2,3 with a lexically scoped $foo?

[08:09] <autrijus> and execute a evalExp (Syn "=", [Var var, Val bound])

[08:09] <autrijus> on the spot.

[08:09] <chromatic> Okay, digging.

[08:09] <autrijus> you can do it at Pugs.Eval.applyExp level, or at line 1192 in doApply.

[08:09] <Khisanth> sili_: for 1..3 -> $foo { } ?

[08:09] <autrijus> ?eval for 1,2,3 -> $foo { }

[08:09] <evalbot6> undef 

[08:10] <autrijus> ?eval (1,2,3).map:{ $^foo + 3 }

[08:10] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:10] <sili_> $foo automagically gets lexically scoped? 

[08:10] <autrijus> ?eval (1,2,3).map:(-> $foo { $foo + 3 })

[08:10] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:10] <autrijus> sigh, evalbot6's quotemeta needs a serious fix

[08:10] <autrijus> sili_: right, because

[08:10] <autrijus> -> $foo {}

[08:10] <autrijus> is just syntactic sugar for

[08:10] <autrijus> sub ($foo) {}

[08:10] <autrijus> although the former is a block and the latter is a routine

[08:11] <autrijus> ?eval for 1,2,3 sub $foo { }

[08:11] <evalbot6> Error:  unexpected "f" expecting program reserved word 

[08:11] <autrijus> ?eval for (1,2,3) sub $foo { }

[08:11] <evalbot6> Error:  unexpected "f" expecting program reserved word 

[08:11] <autrijus> good. 

[08:11] <autrijus> so only blocks can work at that position

[08:12] <sili_> sub sili (Int $foo){say $foo}  sili("asdf") # what is the effect of "asdf" on Int $foo?

[08:12] <Khisanth> ?eval sub sili (Int $foo){say $foo}  sili("asdf")

[08:12] <evalbot6> Error: No compatible subroutine found: "&say" 

[08:12] <sili_> works for me :)

[08:12] <autrijus> sili_: theoretically "asdf" should be coerced into Int upon binding to $foo.

[08:13] <autrijus> sili_: practically it's not yet implemented in Pugs.

[08:13] <sili_> gotcha

[08:13] <autrijus> it however affects mmd.

[08:13] <autrijus> ?eval multi sub sili (Int $foo) {3}; multi sub sili (Str $foo) {4}; sili("str")

[08:13] <evalbot6> 4 

[08:13] <autrijus> ?eval multi sub sili (Int $foo) {3}; multi sub sili (Str $foo) {4}; sili(1483)

[08:13] <evalbot6> 3 

[08:14] <sili_> stop it you're turning me on

[08:14] <autrijus> glad to be of help.

[08:14] * Khisanth turns sili_ into a unix

[08:14] <chromatic> Something like applyExp ('$':'.':name) bound (Prim f) = ... ?

[08:14] <autrijus> chromatic: sadly, no. the Exp doesn't matter anymore

[08:14] <autrijus> chromatic: it's in the bound

[08:15] <chromatic> bound _ = ... ?

[08:15] <chromatic> Oh, wait.

[08:15] <autrijus> chromatic: look at Junc.hs for definition of ApplyArg

[08:15] <autrijus> you want to do something like

[08:15] <autrijus> applyExp styp bound body = do

[08:16] <autrijus>     sequence_ [ applyExp (Syn "=" [Var name, Val val]) | ApplyArg{ argName = name@(_:'.':_), argValue = val } <- bound ]

[08:16] <autrijus>     applyThunk styp bound (MkThunk $ evalExp body)

[08:16] <autrijus> hm, that's all ;)

[08:16] <autrijus> not sure if it should be "=" though. maybe ":="

[08:16] <autrijus> depending on spec

[08:17] <autrijus> er, make the applyExp a evalEXp

[08:17] <chromatic> What's sequence_?

[08:17] <autrijus> sequence :: (Monad m) => [m a] -> m [a]

[08:17] <chromatic> Right, don't want to recurse forever.

[08:17] <chromatic> Ahh.

[08:17] <autrijus> sequence_ :: (Monad m) => [m a] -> m ()

[08:18] <autrijus> map.assuming({$_()})

[08:18] <autrijus> &map.assuming({$_()})

[08:18] <autrijus> I think that's definition of sequence in perl6 :)

[08:19] <autrijus> in haskell, sequence can be defined as (mapM id)

[08:19] <chromatic> This won't handle private variables though.

[08:19] <autrijus> what private variables?

[08:19] <chromatic> $:foo

[08:20] <chromatic> Sorry, private attributes.

[08:20] <autrijus> [ ... | ApplyArg{ argName = name@(_:twigil:_), argValue = val } <- bound, (twigil ==) `any` ".:" ]

[08:21] <autrijus> something like that.

[08:21] <chromatic> How greedy is the first _ in the list?

[08:21] * autrijus likes how "any" and "all" works in haskell without worrying about junctions

[08:21] <autrijus> chromatic: it's always an element.

[08:21] <chromatic> Just one?

[08:21] <autrijus> i.e. a char.

[08:21] <autrijus> yeah. otherwise the types won't match.

[08:21] <autrijus> (:) :: a -> [a] -> [a]

[08:21] <autrijus> so all the _ except for the last is of "a" type.

[08:22] <chromatic> Oh right.  I forgot about that operator.

[08:22] <chromatic> Good, now it's giving a different error.  "Undeclared variable $.reason".

[08:23] <chromatic> At least the assignment is trying to work!  :)

[08:23] <autrijus> everyone wants the colon, so the most common operation -- namely cons, gets it

[08:23] <chromatic> Shhhh, cons is slow.

[08:23] <autrijus> colon is also cons in perl6.

[08:24] <autrijus> :a(:b(:c(nil)))

[08:24] <autrijus> so. hm.

[08:24] <autrijus> you need to write out the full form then.

[08:25] <autrijus> name@(_:twigil:key)

[08:25] <autrijus> and then

[08:25] <autrijus> (Syn "{}" [Var "$?SELF", Val (VStr key)])

[08:25] <autrijus> instead of

[08:25] <autrijus> (Var name)

[08:25] <chromatic> Ahh, yes.

[08:25] <autrijus> you can drop the name@ binding too.

[08:25] <chromatic> Can't ignore the invocant.

[08:25] <autrijus> yup.

[08:25] <chromatic> Is the twigil not part of the name?

[08:25] <autrijus> not part of the key

[08:25] <autrijus> because spec says you can't have both $:foo and $.foo

[08:25] <chromatic> Right, good.

[08:25] <autrijus> nor $.foo and @.foo

[08:26] <autrijus> dinner, bbiab. &

[08:28] * castaway peers at nothingmuch

[08:29] <gaal> ?eval (1,2,3,4).scalar.perl.say

[08:29] <evalbot6> Error: No compatible subroutine found: "&say" 

[08:29] <castaway> woops, ENOHDSPACE

[08:30] <gaal> ?eval (1,2,3,4).scalar.perl

[08:30] <evalbot6> '(1, 2, 3, 4)' 

[08:30] <gaal> shouldn't that be [1,2,3,4] ?

[08:30] <sili_> nmm. given looks like a switch, is that correct?

[08:30] <gaal> sili_, given localizes the expression to $_, so you can use 'when' to check cases

[08:31] <gaal> they implicitly use smartmatch (~~)

[08:31] <gaal> so you can compare against numbers, types, rules, etc. with very little verbiage.

[08:31] <arcady> also, a when's block automatically jumps out of the enclosing given

[08:31] <castaway> anyone alive? can one checkout just a subdir of a svn repository? (and how)

[08:32] <chromatic> Add the directory name to the end of the path when you do the checkout.

[08:32] <chromatic> svn co http://project.example.com/trunk/path/

[08:33] <autark-jp> ?eval qq[&pi()   = 3]

[08:33] <evalbot6> '3.141592653589793= 3' 

[08:33] <autark-jp> ?eval $?PUGS_VERSION

[08:33] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.6, June 2, 2005 (r4368)' 

[08:33] <sili_> where is ~~ documented?

[08:34] <gaal> end of s03 i think?

[08:34] <castaway> ?eval (1,2,3,4).scalar.perl

[08:34] <evalbot6> '(1, 2, 3, 4)' 

[08:34] <sili_> yup, thanks

[08:35] <sili_> ah, more in so4

[08:35] <gaal> yes, right, there's an important table there

[08:36] <gaal> eg %hash1 ~~ %hash2 may not do the first thing you imagine it to (it just compares keys)

[08:36] <castaway> hmm, doesnt it like me?

[08:36] <gaal> c, ?

[08:37] <sili_> neat

[08:39] <sili_> good ol perl

[08:39] <gaal> any haskellheads around?

[08:40] <scook0> gaal: what's your issue?

[08:40] <gaal> Pugs.Prim.Eval, around line 60:

[08:40] <gaal> the two lines guarding on "trans"

[08:40] <gaal> i don't understand the layout: why are these two lines indented?

[08:41] <gaal> only because of let in the line before them?

[08:41] <gaal> (the indent is required)

[08:42] <integral> trans is being let as well.   The let is for env' and trans

[08:42] <gaal> hmmmmm

[08:42] <gaal> ok, that makes more sense

[08:42] <gaal> thanks :)

[08:43] <integral> the  = is buried way out to the right :-)

[08:43] <scook0> trans gets set to (`mergeStmts` Syn "env" []) or id, depending on flag

[08:43] <gaal> so the trans is being let conditionally?

[08:43] <scook0> aye

[08:43] <gaal> yeah, okay

[08:43] <gaal> thanks.

[08:43] <integral> nicer than the ternary ;-)

[08:43] <gaal> no

[08:43] * gaal likes the ternary :)

[08:44] <scook0> I like the way all the '|'s line up though, looks pretty

[08:44] * gaal is reminded of the xmas three somewhere in p5 online docs

[08:44] <gaal> xmas tree

[08:44] <pasteling> "chromatic" at 63.105.17.30 pasted "Nearly Working Attribute-Setting in Method Signatures" (21 lines, 969B) at http://sial.org/pbot/10701

[09:08] <castaway> (durned freenode)

[09:10] <theorbtw1> Woo, all caught up.

[09:11] <theorbtw1> autrijus, chromatic, still awake?  Inside a module, the exportation of new grammars should probably be in import, not BEGIN.

[09:11] *** theorbtw1 is now known as theorbtwo

[09:11] <theorbtwo> ...and exported more or less like anything else that we can lexically export -- $OUTER::*GRAMMAR, or suchlike.

[09:14] <wolverian> heh, some lively p6i discussion!

[09:14] <theorbtwo> It's time to get going, though.

[09:15] <theorbtwo> Now I get to go to the post office, and go back, and read yet more scrollback buffer.

[09:28] <arcady> hm... S04 says that given/when's "default" is exactly equivalent to "when true {...}"

[09:28] <arcady> which isn't what pugs thinks

[09:28] <arcady> ?eval my $a = 0; given $a { when(bool::true) { 1 } default { 2} }

[09:28] <evalbot6> 2 

[09:28] <arcady> then again, I think pugs is probably doing the right thing

[09:30] <wolverian> hm. S04 is probably wrong there, as true() is the opposite of not(), not bool::true

[09:30] <wolverian> (even if it wasn't it's probably wrong, given the ~~ semantics)

[09:31] <arcady> oh, okay

[09:31] <arcady> there's no true() in pugs

[09:32] <wolverian> I think that's a good thing. it's the worst named builtin ever.

[09:32] <arcady> if $x == true

[09:32] <arcady> if ($x == true) == true

[09:32] <arcady> etc.

[09:32] <wolverian> yes, that's what newbies would think it does.

[09:39] <arcady> in fact, that probably wouldn't even work, because 2 is true but not == true

[09:39] <arcady> and there's no boolean comparison operator

[09:44] <wolverian> == is not boolean?

[09:44] <wolverian> (well, it doesn't take booleans as args..)

[09:45] <arcady> nope

[09:45] <arcady> == numifies its args

[09:45] <arcady> so bool::true becomes 1

[09:45] <wolverian> right, but it returns a bool.

[09:45] <wolverian> oh, that's what you meant

[09:45] <arcady> ?eval 2 == bool::true

[09:45] <evalbot6> bool::false 

[09:46] <wolverian> yes. :)

[09:46] <wolverian> ?eval true 2

[09:46] <evalbot6> bool::true 

[09:46] <wolverian> ?eval true 0

[09:46] <evalbot6> bool::false 

[09:46] <wolverian> implemented!

[09:46] <wolverian> ?eval true not true not not true 1

[09:46] <evalbot6> bool::false 

[09:47] <wolverian> (well, that was fun)

[09:48] <wolverian> arcady: if you want, you could ask p6l about the default thing in S04. it _looks_ wrong to me (did it mean 'if bool::true { ... }'?), but maybe people haven't noticed it.

[09:48] <arcady> wait, true just says if something is true

[09:48] <arcady> either way it's wrong

[09:49] <arcady> oh, and I guess we do have boolean comparison then

[09:49] <arcady> but two operators instead of one

[09:49] <arcady> and they're called &true and &not

[09:49] <wolverian> yes.

[09:50] <wolverian> exactly.

[09:50] <wolverian> and newbies generally will confuse &true and &bool::true

[09:51] <arcady> either way, that thing in S04 is wrong

[09:51] <wolverian> yes, that's my point

[09:51] <wolverian> as I said, if you want, ask p6l about it!

[09:51] <wolverian> (it should be 'if bool::true { ... }')

[09:52] <wolverian> (well, no it shouldn't - that doesn't break the switch.)

[09:52] <wolverian> (but something like that!)

[09:52] <arcady> it doesn't need to be anything

[09:53] <arcady> there's a way to write an always-matching when, and that way is "default"

[09:53] <wolverian> perl wants to implement itself in itself.

[09:54] <arcady> well then you'd need a macro or so

[09:54] <wolverian> hmm. no. you can attach a LEAVE { break } to the when's closure argument 

[09:55] <arcady> oh, okay

[09:56] <arcady> actually, that's what the macro would do

[09:57] <arcady> when expr, &block -> if $_ ~~ expr { &block; break }

[09:57] <wolverian> I'm not convinced when would need to be implemented as a macro. a sub *statement:<when> seems enough

[09:58] <wolverian> (if it's a statement. I think it is.)

[09:58] <wolverian> arcady: correct.

[09:59] <wolverian> sub *statement:<when> ($expr, &block) { if $CALLER::_ ~~ $expr { block; break } }

[10:02] <arcady> which is basically a fancy way of saying "macro"

[10:03] <wolverian> right, but I don't deal with implementation. ;)

[11:03] <nothingmuch> good afternoon

[11:04] <larsen> good afternoon

[12:29] <Juerd> I/win 32

[12:29] <Juerd> s/I//

[12:29] <wolverian> you win? :)

[12:30] <wolverian> (you have more windows than me. congratulations.)

[12:30] <svnbot6> r4371, iblech++ | evalbot/evalhelper.p5 -- Don't quote '^' (so $^a etc. works now).

[12:30] <svnbot6> r4372, iblech++ | evalhelper.p5 -- Oops, didn't delete a debugging warn().

[12:30] <svnbot6> r4373, iblech++ | svnbot.p6 and evalbot.p6:

[12:30] <svnbot6> r4373, iblech++ | * ?help

[12:30] <svnbot6> r4373, iblech++ | * ?quit only available in private messages so other bots on the same channel

[12:30] <svnbot6> r4373, iblech++ |   don't /QUIT as well.

[12:37] <Juerd> wolverian: I have more than 32. You have less?

[12:37] <Juerd> Two irssis combined, I have over 45

[12:38] <wolverian> Juerd: Yes, I only have 28. Why do you have two irssis?

[12:38] <nothingmuch> tabbed browsing is evil

[12:38] <Juerd> History.

[12:38] <Juerd> Until I joined this channel, I had all perl stuff in its own irssi.

[12:38] <Juerd> But this was a perl channel on a network I was already on :)

[12:38] <wolverian> Juerd: Right. :)

[12:38] <nothingmuch> i usually have aboug 500-750mb of ram taken by browsers

[12:38] <Juerd> wolverian: Note that my hostname on efnet and irc.perl.org is different.

[12:39] <Juerd> hartkeks++

[12:39] <wolverian> hartkeks?

[12:40] <Juerd> Hard and very nutricious biscuits

[12:40] <svnbot6> r4374, iblech++ | Limbic_Region++'s examples/nested_loops -- Usual svn props.

[12:40] <Juerd> Combined with water, one can replace a sandwich.

[12:40] <wolverian> Hmm. That reminds me, I haven't eaten anything today.

[12:40] <Juerd> They're also called "Army biscuits"

[12:41] <revdiablo> Juerd: do they taste how they sound like they might taste?

[12:42] <Juerd> revdiablo: If you find them sound like slighly vanilla-ish, then yes.

[12:42] <Juerd> They're quite addictive

[12:42] <Juerd> Which is a problem, because as soon as you drink anything, your stomach tends to explode if you ate too many ;)

[12:48] <nothingmuch> Hols Limbic_Region... how's YAHT going?

[12:51] <Limbic_Region> sorry - just woke up

[12:52] <Limbic_Region> my eyes were getting tired so I didn't make it much past the part where it said

[12:52] <Limbic_Region> "multiplication binds more tightly than division"

[12:52] <Limbic_Region> this struck me as a bit odd

[12:52] <Limbic_Region> so I decided a break was warranted

[12:53] <Limbic_Region> 3.3.1 - "Strings"

[12:53] <Limbic_Region> after I finish my morning routine I will start reading again

[12:53] <Limbic_Region> how's things with you?

[12:58] <autark-jp> S2 says: You may interpolate double-quotish text into a single-quoted string using the \qq[..] construct. Other "q" forms also work, including user-defined ones, as long as they start with "q".

[12:58] <autark-jp> is that _really_ meant as only using []?

[12:59] <autark-jp> ?eval q[ \qq[&pi()] ]

[12:59] <evalbot6> ' 3.141592653589793 ' 

[12:59] <autark-jp> ?eval q[ \qq{&pi()} ]

[12:59] <evalbot6> ' \\qq{&pi()} ' 

[12:59] <autark-jp> and what about the opposite:

[12:59] <autark-jp> ?eval qq[ \q{&pi()} ]

[12:59] <evalbot6> ' q3.141592653589793 ' 

[13:00] <Limbic_Region> autark-jp - that's not the way I read it

[13:00] <Limbic_Region> but that might just be that it is unimplemented

[13:00] <Limbic_Region> and not that who ever added the [] functionality disagreed with you

[13:01] <autark-jp> so you see the \qq[] as an example?

[13:01] <Limbic_Region> yeah

[13:01] <Limbic_Region> if not just an example

[13:01] <Limbic_Region> why bother say Other "q" forms also work

[13:01] <autark-jp> I thought maybe they were thinking of \qa[] \qs[] and so on.

[13:02] <autark-jp> anyway, then I'll try to add that feature.

[13:03] <Limbic_Region> oh - I see where the ambiguity might come in

[13:03] <Limbic_Region> but that really doesn't make much sense to me

[13:03] <autark-jp> where?

[13:04] <Limbic_Region> your counter examples

[13:04] <Limbic_Region> still [] but just changing the second letter

[13:04] <Limbic_Region> seems quite silly to me that would be what was meant

[13:04] <autark-jp> which second letter?

[13:05] <Limbic_Region> \qa[] vs \qq

[13:05] * Limbic_Region is obviously not communicating effectively

[13:06] <Limbic_Region> too early in the morning and not enough caffeine

[13:06] <autark-jp> almost bedtime here :)

[13:06] <Limbic_Region> IMO - all q constructs should work as you expect

[13:06] <Limbic_Region> 9:10PM is bedtime on a Saturday night?

[13:07] <autark-jp> ... :)

[13:07] <autark-jp> well 22pm, but I said _almost_ ;)

[13:13] <svnbot6> r4375, scook0++ | * Initial Haddocks for shiftT/resetT

[13:13] <svnbot6> r4375, scook0++ | * Minor tweaks to hw2005.txt

[13:20] <geoffb> *yawn*  g'morning, all

[13:22] <Limbic_Region> salutations

[13:22] <geoffb> Bloody hell -- firefox crashed, taking all of my half-read tabs with it.

[13:22] <Limbic_Region> geoffb - do you have a tab extension or two installed

[13:23] <gaal> geoffb - google for "firefox session saver"

[13:23] <geoffb> Bleah . . . what the world needs is a browser that maintains tab state through crashes, like a decent editor would.

[13:23] <Limbic_Region> geoffb - FF has it

[13:23] <geoffb> Limbic_Region, nope.  gaal, ooooh

[13:24] <wolverian> geoffb: epiphany does that too, built-in.

[13:24] <gaal> opera was the first that got it right i think

[13:24] <Limbic_Region> well FF can't do it out of the box

[13:27] <Aankhen``> geoffb >> Just search for SessionSaver.

[13:27] <geoffb> I love that they have a vibrant extension community and all, but I'd like to be able to `apt-get firefox-bloated-pig` and just get every extension that makes some modicum of sense.  Perhaps they need a pumpking who likes to merge extension modules into the core set . . . .

[13:29] <gaal> how do i export data constructors in haskell?

[13:29] <gaal> without enumerating them?

[13:29] <integral> Type(..)

[13:30] <gaal> that's on the import decl, no? how do i do it on the module (export) decl?

[13:30] <integral> err?  That is on the export decl

[13:30] <gaal> then it ain't working :)

[13:30] <integral> eg. module Pugs.AST.Internals ( Exp(..), ) where ...

[13:31] <gaal> i have to stare at this some more, i am trying that but am obviously doing something wrong.

[13:31] <integral> is GHC giving an error?

[13:32] <gaal> the code using that module gives a Not in scope error

[13:32] <gaal> isn't importing the constructor, obviously

[13:32] <integral> hmm, is it importing with a specific list?

[13:32] <gaal> no

[13:33] <gaal> oh, maybe another module before that one had already imported it?

[13:33] <integral> hmm?

[13:33] <gaal> i'd expect the compiler to do the right thing, but...

[13:33] <gaal> if i do import A, then import B

[13:33] <gaal> and B's the one i want the constructors from

[13:34] <gaal> but A itself had done import B with a qualified list

[13:34] <integral> they both export the same constructors?

[13:34] <gaal> no, no

[13:34] <integral> hmm!

[13:35] <gaal> oh, crap, just a typo!

[13:35] <integral> :-)

[13:35] <gaal> somehow these things always are.

[13:36] <gaal> but the rule is you never discover it until you ask someone etc.

[13:42] <gaal> hmm. okay, now how do i throw an exception not from Prim.hs?

[13:42] <gaal> fail doesn't do anything.

[13:42] * integral is out his depth there

[13:45] <geoffb> Limbic_Region, you logged off before I could mention to you: please do more p6 puzzles . . . puzzle 2 was a nice brain stretch, and fun to boot . . . ,

[13:47] <Limbic_Region> geoffb - have you seen some of the other p6 posts I have made?

[13:48] <geoffb> Nope, I was out for most of yesterday -- unexpected house guests.

[13:48] <geoffb> I know only of cribbage (p6 puzzle 1) and nested loops (puzzle 2)

[13:48] <Limbic_Region> http://perlmonks.org/?node_id=453215

[13:48] <geoffb> I've had no chance to explore your node history.  ;-)

[13:48] <gaal> seen autrijus

[13:48] <jabbot> gaal: autrijus was seen 5 hours 21 minutes 56 seconds ago

[13:48] <Limbic_Region> http://perlmonks.org/?node_id=451398

[13:49] <Limbic_Region> there's two more for you to play with

[13:50] <geoffb> Fed to newly session-saving Firefox, will take a look after backlog reading (and perhaps doing the --perl5 import tests autrijus asked for yesterday)

[13:50] <geoffb> thanks!

[13:51] <gaal> geoffb, tests for caller() would be very welcome too

[13:51] <Limbic_Region> ok - making slow progress with YAHT

[13:51] <geoffb> gaal, OK, will consider

[13:51] <gaal> L<s06/The "caller" function">, already some in t/builtins/caller.t

[13:51] <gaal> thanks!

[13:52] <geoffb> gaal, thanks for the S* and t/*/* pointers, saves me having to use my noodle at this ugly hour

[13:52] <gaal> sure

[13:53] <gaal> (here it's actually the most beautiful hour of the day -- i might go out for a walk)

[13:54] * Limbic_Region is going to meet another monk later today and make my wife happy by finally going to a filipino restaurant

[13:54] <Limbic_Region> only after the fact will I tell her that it is my anniversary gift to her

[13:57] <gaal> &

[14:16] <masak> Limbic_Region: why?

[14:16] <svnbot6> r4376, gaal++ | opEval refactoring, introduce EvalStyle type

[14:16] <svnbot6> r4376, gaal++ | TODO: allow some evals (eg., require/use) to raise exceptions on errors

[14:17] <Limbic_Region> masak - why what?

[14:18] <masak> why will you only tell her after the fact?

[14:18] <masak> s/only tell her/tell her only/

[14:18] <theorbtwo> Limbic_Region: You're going to take somebody else with you when going to your anniversary dinner?

[14:19] <Limbic_Region> theorbtwo - yep, jdporter and his wife

[14:19] <masak> ah, and I guess that's the reason too :)

[14:19] <geoffb> nothingmuch, (reading backlog) Very cool for doing TAP in assembly.  :-)

[14:19] <Limbic_Region> and because my wife is silly when it comes to things like flowers or chocolates or diamonds for gifts

[14:19] <Limbic_Region> she would rather me give her money

[14:19] <Limbic_Region> which I won't do

[14:19] <theorbtwo> Um, don't you keep joint accounts anyway?

[14:19] <masak> :)

[14:20] <Limbic_Region> theorbtwo - I am single acct holder on my account and joint on hers

[14:20] <Limbic_Region> >:-)

[14:20] <theorbtwo> Ah.

[14:20] <theorbtwo> Still seems kind of silly.

[14:21] <Limbic_Region> you weren't raised in a 3rd world country

[14:21] <theorbtwo> This is true.

[14:21] <Limbic_Region> where the cost of a dozen roses in the US equates to a week or two's salary

[14:22] <theorbtwo> This is true.

[14:22] * Limbic_Region is liking Haskell so far

[14:22] <Limbic_Region> but I am progressing very slowly

[14:22] <theorbtwo> I'd rather have money for my birthday from most people... but not from Jess.

[14:23] <theorbtwo> ...since there is effectively no difference between me having money and Jess having money.

[14:23] * Limbic_Region doesn't observe his bday and hasn't since he was 8 or 9

[14:23] * theorbtwo does.

[14:23] * Aankhen`` does too.

[14:23] <theorbtwo> More to the point, other people do, by giving me gifts.

[14:23] <Juerd> birthdays suck.

[14:23] <Aankhen``> Birthdays rock.

[14:24] <geoffb> Juerd, mine will if my wife's does.  :-)

[14:28] <theorbtwo> Somebody needs to write a firefox extension to .deb maker.

[14:28] <Juerd> extensions are installed in your user profile, not system wide.

[14:29] <theorbtwo> Juerd: Can do either way.

[14:30] <Limbic_Region> I know some modules ask if they should be installed locally or globally

[14:30] <Limbic_Region> I wasn't aware there was a way to make an extension that didn't ask install globally

[14:30] <Limbic_Region> s/modules/extensions/

[14:40] <svnbot6> r4377, autrijus++ | * related work: Perl6::Rules, P6C and PGE.

[14:41] <Aankhen``> Is `if(...)` a valid construct?

[14:42] <Aankhen``> Or is the space between the statement and the brackets required

[14:42] <Aankhen``> ?

[14:42] <theorbtwo> Aankhen``: So far as I know, there's no spacing dependency there.

[14:42] <Limbic_Region> those are backticks right

[14:42] <Limbic_Region> so it is shell dependent

[14:42] * Limbic_Region personally prefers ksh

[14:42] <Aankhen``> The backticks was just to distinguish the code from the rest of the sentence. :-)

[14:43] <Aankhen``> s/was/were/

[14:43] <Limbic_Region> oh

[14:43] <Limbic_Region> heh

[14:43] <Limbic_Region> and that isn't ls as in list the directory

[14:43] <Limbic_Region> it was Is as in a question

[14:43] * Limbic_Region really needs more caffeine

[14:43] <Aankhen``> Yep.

[14:43] <Aankhen``> Heh.

[14:43] <theorbtwo> Aye.

[14:44] <theorbtwo> OTOH, `-as-quote--

[14:44] <Aankhen``> Strange.

[14:44] <theorbtwo> ` looks nothing like a quote -- it looks like an accent mark, by no accident.

[14:44] <theorbtwo> I really hate it when things try to make quotes out of `` and ".

[14:44] <Aankhen``> When I run t/rules/from_perl6_rules/charset.t manually in Pugs, it runs the tests without problems.

[14:44] <theorbtwo> They don't match.

[14:45] <Aankhen``> But `nmake test` is giving me a parse error.

[14:45] * Aankhen`` wonders if the parsing changed in the newer versions.

[14:45] <Aankhen``> theorbtwo >> I'm just following Markdown syntax.

[14:45] <Aankhen``> I was using |...| earlier, but that looked marginally more ugly. :-)

[14:48] <arcady> hm, pugs does not support ``, or qx[]

[14:50] <theorbtwo> C< ... > is the perl5ish way to do it.

[14:50] <Aankhen``> That's three keystrokes instead of two, plus Shift.

[14:50] <theorbtwo> ` ... ` is the kwiki-doc-thingy way to do it, but I'm not too fond of that either.

[14:51] <theorbtwo> Generally, around here, just say what you mean with no quotes, and hope people know what you mean.

[14:51] <Aankhen``> Mmm, I guess.

[14:55] <Aankhen``> Wow.

[14:55] <Aankhen``> Win32: Only 45/6128 subtests failed.

[15:04] <eric256> ?eval localtime

[15:04] <evalbot6> Error: No compatible subroutine found: "&localtime" 

[15:05] <eric256> ?eval time

[15:05] <evalbot6> 171212725.332989 

[15:05] <Limbic_Region> ?eval localtime(time)

[15:05] <evalbot6> Error: No compatible subroutine found: "&localtime" 

[15:06] * Limbic_Region wanders off for breakfast

[15:07] <castaway> tumtitum

[15:07] <castaway> ah, much better

[15:07] <eric256> pugs doesn't have a local time equivalent yet?

[15:08] <theorbtwo> eric256: Not that I'm aware of.

[15:08] <theorbtwo> Write one in p6, and stick it in src/perl6/Prelude.pm?

[15:08] <castaway> wow, I can see something.. 

[15:08] <eric256> does the perl5 localtime convert those seconds to the date? or is there another form of magic that can be used?

[15:10] <theorbtwo> eric256: Convert the seconds since Jan 1 2000 to the localtime.

[15:10] <theorbtwo> The hard part is figuring out what TZ to use.

[15:10] <theorbtwo> That may need some extra magic...

[15:10] <eric256> and leap years, etc.

[15:10] <theorbtwo> Yeah, perhaps my plan is not the best.

[15:11] <eric256> lol. maybe haskel has a builtin for that. i'm googleing to see if the algorythm is sitting out there somewhere

[15:11] <wolverian> should the perl6 time primitives return time objects?

[15:14] <theorbtwo> wolverian: Don't think so... possibly, with overloaded nummification.

[15:14] * castaway sighs

[15:14] <geoffb> wolverian, I'd like them to . . . with appropriate numify and stringify

[15:15] <geoffb> While I hate that DateTime is slow as a dog, I'd have to say functionality-wise it has been a godsend

[15:16] <wolverian> I agree. :)

[15:16] <eric256> can you force context ?  my $x = Object time();

[15:16] <geoffb> I've had to subclass it on occasion to have a faster new(), but other than that, good stuff.

[15:17] <geoffb> I would assume my $x = time() would get the object.

[15:17] <integral> eric256: hmm, would my Time $x = time() maybe work?

[15:17] <geoffb> Then you would do +$x or ~$x to get the num or string

[15:17] <integral> someone said something about context including type information,  but it may have just been speculation

[15:17] <eric256> integral looks like the same idea

[15:18] <eric256> since you can tell subs what they return, you should be able to pick which sub based on what you want to get

[15:18] <geoffb> honestly, I'm not understanding why you don't want to always get the object here, and just numify and stringify properly . . . .

[15:18] <integral> I suppose I would never really want time() to return an Int anyway.

[15:19] <QtPlatypus> Does MMD match on return values?

[15:19] <theorbtwo> Having time return something you can treat as an integer is often nice... but there's no purticular reason I'd want to have it be a hard number, and when I really do, I can always use +.

[15:19] <theorbtwo> QtPlatypus: No.

[15:19] <integral> yes, _treat_ as an integer, but it's not an integer

[15:19] <integral> you can add it with other _times_, but adding an integer to it doesn't make sense.

[15:20] <eric256> i don't care so much about that specific case, but shouldn't dispatching take into account the return value?

[15:20] <theorbtwo> Well, no.

[15:20] <theorbtwo> If I want 10 seconds from now, time+10 should do what I want.

[15:20] <theorbtwo> (BTW, time should be straight nullary.)

[15:20] <integral> time + Time->new(seconds => 10)

[15:20] <integral> 10 doesn't encode the idea the it's seconds.

[15:20] <theorbtwo> Ugh.

[15:21] <theorbtwo> It's in seconds because that's what time returns.

[15:21] <integral> it does? eww!

[15:21] <eric256> i would hope at worst it would be Time.seconds(10) or even 10.seconds

[15:21] <theorbtwo> I'd rather have it in my head once then in every bit of code I write that manipulates time.

[15:22] <theorbtwo> 10`s would be OK, but the Units thing can override time().

[15:22] <eric256> time() + 10 ` sec; #isn't even that bad

[15:22] <geoffb> The problem is that if you always assume numbers are seconds, then you instantly get people thinking a day is 86400.  Which it's not.

[15:22] <geoffb> eric256, that would be more reasonable

[15:23] <eric256> is ` still the system quote thing or is that gone? /me is hoping it is gone

[15:23] <theorbtwo> eric256: `` is qx as a circimfix quote operator; ` as infix may be units (with a module, please!)

[15:24] <eric256> then how does it know my $x = 5`m + 10`f; is infix instead of circumfix?

[15:24] <integral> is there a reason to use ` rather than *?

[15:24] <integral> eric256: a circumfix operator doesn't make sense after a 5.

[15:24] <integral> my $x = 5 qx(...);

[15:25] <gaal> rehi

[15:25] <eric256> hmmm i as long as it understands. lol. as usual perl is going to be smarter than i give it credit for. ;)

[15:26] <geoffb> hi gaal

[15:26] <eric256> i thought barewords are no longer allowed... how do we do `m then? or do i make `m the whole operator and make it postfix?

[15:26] <integral> m is a bareword?

[15:27] <integral> sub m { return MassUnit.new }

[15:27] <eric256> my $x = 5`m;

[15:27] <eric256> hmmm. that is an interesting idea.  and since we now have prototype perl will know not to expect any arguments for m

[15:28] <integral> oops :-) sub m () returns Units::Unit { return Units::Mass.new }

[15:28] <QtPlatypus> Could it be a postfix function?  And pass 5 Units::Distence.new ?

[15:29] <QtPlatypus> (m is a unit of distence)

[15:29] * integral would be happy with: my $x = 5 * gramme;

[15:29] <eric256> then ` could be multisub infix:<`> (Int $value, Units::Unit $unit) { $unit.convert($value) };

[15:29] <integral> why does it need to be ` not * ?

[15:30] <eric256> i think it reads clearer

[15:30] <eric256> because you arn't multiplying, you are converting a number to a unit object

[15:30] <theorbtwo> I think so too.

[15:30] <theorbtwo> Also, not all "apply unit" is multiplication.

[15:30] <theorbtwo> 20`degC, for example.

[15:30] <integral> hmm, ok.  So ` combines a number with a unit, and * works on pairs of numbers or pairs of units

[15:30] <theorbtwo> 20`AWG even more so.

[15:31] <theorbtwo> Or combines a unit with a unit.

[15:31] <integral> mm, isn't that just * working on a pair of units?

[15:31] <theorbtwo> $yards = (20`ft + 10`m)`yd

[15:31] <theorbtwo> No.

[15:31] <theorbtwo> $area = (20*ft + 10*m)*yd

[15:32] <eric256> yea. you want math to read clear to.  my $x = 5'f * 6; is clearer than my $x = 5 * f * 6;

[15:32] <integral> ah, that's what I was missing

[15:32] <integral> I didn't think of converting a mixed thing to a unit like that.  theorbtwo++

[15:32] <theorbtwo> The idea is that in general, it messes with the units without you looking.

[15:32] <theorbtwo> But it can't pick between multiple equivlent units that way.

[15:33] <theorbtwo> (Of course, it can probably guess pretty well, pretty often.)

[15:34] <eric256> multiple equivalent units that way? what?

[15:34] <QtPlatypus> 25'm * 7'f

[15:34] <theorbtwo> If I add feet and meters, it doesn't know if the result should be in feet, or in meters.

[15:35] <QtPlatypus> I would default it to metric

[15:35] <eric256> yea. but it should convert to one, and put it in an object, the object could default to the last but since its an object it could be asked for either.

[15:36] <QtPlatypus> If the behavour if units(1) is a good indercator

[15:36] <theorbtwo> Right, I'd default to metric as well, where applicable.

[15:37] <theorbtwo> Well, probably whatever the input was in, but if we have to do any conversions, become metric.

[15:37] <theorbtwo> In any case, I'm also hoping I'll be able to convert to ftin and have it tell me that I'm 5ft + 6in.

[15:37] <gaal> anyone remember how to ask ghc to use less ram during make?

[15:38] <QtPlatypus> I realy cleaver implementation would guess from the local.

[15:51] <theorbtwo> No, QtPlatypus, that'd be horrible.

[15:51] <theorbtwo> Code would suddenly, unexpectedly, do something different when run elsewhere.

[15:52] <theorbtwo> uk pint vs us pint is bad enough.

[15:53] <integral> use Units::Imperial;  use Units::US;  use Units <US>; use Units::OneTrueSystem::Metric; ;-)

[15:55] <geoffb> integral, didn't metric change as well . . . I seem to remember cgs v. mks . . . 

[15:55] <integral> hmm, I would call the systems CGS and Metric

[15:55] <integral> I don't really know much, but I've never heard CGS be called metric

[15:55] <geoffb> fair enough . . . my History of Science is fairly poor

[15:56] <geoffb> I always found it odd that in either case, one of the fundamental units is prefixed.

[15:56] * integral went to some history of maths lectures but can't remember much

[15:57] <integral> it is a wee bit odd :-)

[15:57] * gaal can recommend one or two good books on the subject

[15:58] <gaal> look for ones by Morris Kline

[15:58] <svnbot6> r4378, gaal++ | fix to use EvalStyle

[15:58] <geoffb> gaal, which subject?  HoM or HoS?

[15:58] <gaal> math

[15:59] <eric256> in examples i just commited units.p6.. its just a basic proof of concept and its broken but i'm not sure why. ;)

[15:59] <geoffb> gaal, I have enough trouble with math itself.  HoM may just kill me

[16:00] <gaal> why? i imagine a history of haskell might be less lethal than haskell.

[16:01] <eric256> i did some weird things that arn't needed now...5 minutes after starting it. lol.  if anyone could help me figure out the error it throws that would be great. in the mean time i'm updating my pugs, perhaps its a bug thats fixed already

[16:01] <geoffb> gaal, point taken

[16:02] <gaal> which file, eric2^8?

[16:03] <geoffb> I just never had luck in political history classes, because I constantly got "On date foo, bar happened.  On date quux, baz happened."  And had no way of knowing if bar and baz were related.  I assume the same will happen in HoM.  Unless the author is very good and explains the items at hand I suppose.

[16:03] <svnbot6> r4379, eric256++ | The very start of a units module. Just proof of concept stuff so far.

[16:03] <eric256> units.p6 in examples.

[16:03] <geoffb> But that kind of writing skill is rare

[16:04] * Limbic_Region is finding Haskell incredibly difficult

[16:04] * Limbic_Region has spent too much time training his brain to think iteratively

[16:04] <gaal> geoffb, actually he uses just enough philo of math to make it cogent and interesting, withough (for me, at least) being overwhelming. --and i don't know mathe very well!

[16:04] <qmole> Limbic_Region: what are you struggling with?

[16:05] <Limbic_Region> thinking recursively

[16:06] <nothingmuch> good evening

[16:06] <geoffb> Out of curiosity, why did you train yourself to think iteratively?  (That's a real question, BTW)

[16:06] <qmole> ah

[16:07] <gaal> ugh, that unit stuff is giving me a headache, sorry eric, can't help i'm afraid.

[16:07] <eric256> lol. it seems if i qoute the Meter it works. ;)

[16:07] <nothingmuch> Limbic_Region: how's your YAHT progress going?

[16:07] <eric256> its ugly in its current state gaal

[16:07] <Limbic_Region> geoffb - that is a paragraph answer

[16:07] <nothingmuch> oh wait, have to cook for my sister

[16:07] <Limbic_Region> nothingmuch - still in chap 3

[16:08] <Limbic_Region> the underlying reason is that I am interested in writing efficient code efficiently

[16:08] <gaal> not your fault eric

[16:08] <geoffb> Interesting book list, gaal: http://www.marco-learningsystems.com/pages/kline/kline.html

[16:08] <theorbtwo> I thought CGS and MKS were both metric, but only the later is SI.

[16:08] <svnbot6> r4380, gaal++ | usual svn props on units.p6

[16:08] <theorbtwo> In any case, CGS and MKS are pretty well interchangable, no?

[16:08] <geoffb> (er, I assume you already knew that, I meant "it looked interesting to me")

[16:09] <Limbic_Region> iterative solutions to naturally recursive problems usually take far more time to come up with then is saved then running the recursive version

[16:09] <Limbic_Region> so by training my brain to think iteratively - I get the best of both worlds

[16:09] <gaal> i read _Mathematics in Western Culture_ and _Mathematics for Liberal Arts_, i think, maybe another one too (it was a while ago :)

[16:09] <geoffb> Limbic_Region, interesting.

[16:10] <crysflame> http://www.sidhe.org/~dan/blog/archives/000400.html # Dan exits Perl 6

[16:10] <gaal> the two i mentioned were fairly similar in scope, actually; with the latter being a little gentler.

[16:10] <geoffb> gaal, which would you reccomend to start with

[16:10] * Limbic_Region can't really think of any serious code that I have written with recursive functions (in Perl that is)

[16:11] <geoffb> Limbic_Region, whereas I can't think of a complex naturally recursive function that I got right when I tried to do it iteratively.  :-)

[16:11] <gaal> they were both good. if you haven't ever read anything about, oh, cantor for example, then the second might be more appropriate

[16:12] <gaal> for some reason when i look at that list most of the titles look familiar :) but i'm sure i couldn't have read them all

[16:13] <Limbic_Region> geoffb - besides - write a recursive function for fibonacci series w

[16:13] <Limbic_Region> without caching

[16:13] <Limbic_Region> and ask it to calculate fib(100)

[16:13] <geoffb> crysflame, *sigh*  too bad he's not planning to do a public postmortem -- though I suppose that means there's some personal issues involved

[16:13] <geoffb> gaal, thanks

[16:14] <gaal> sure

[16:14] <geoffb> Limbic_Region, right, true . . . but memoizing is a fundamental recursive concept.  Not optimally efficient, of course, but hugely better.

[16:15] <crysflame> it's perl

[16:15] <gaal> if the argument to a p6 function is a bare class, what's the signature? sub foo(Class $c) ?

[16:16] <gaal> ie called foo(Cat)

[16:16] <geoffb> Mind you, this is coming from someone whose first language after BASIC was Z80 assembly . . . so I get wanting to be able to do optimally efficient execution kernels

[16:17] <theorbtwo> Limbic_Region: [*] 1..$_

[16:18] <geoffb> I just have a hard time fitting enough of a complex iterative mess into my head to do algorithmic optimization . . . I find that easier to do when the code is very small.

[16:18] <theorbtwo> Isn't that just so wondefully concise?

[16:18] <Limbic_Region> theorbtwo - that's not fibonacci

[16:18] <geoffb> theorbtwo, different function

[16:18] <Limbic_Region> that's factorial

[16:18] <Limbic_Region> and yes

[16:18] <Limbic_Region> I know how to use infix operators

[16:18] <Limbic_Region> that's not the point

[16:18] <eric256> hmmm. done for now.. working more and looking cleaner yet. hehe. but the overridden + still isn't working, i think there are still issues with those

[16:18] <theorbtwo> Oh, fibonacci.

[16:18] <Limbic_Region> in general - haskell wants you to think recursively

[16:19] <geoffb> Actually, come to think of it, I often get just as much mental clarity out of using multiple iterative passes as going all the way to recursion -- sometimes more.

[16:19] <geoffb> Learning that it was OK to take more than one pass over my data made a HUGE difference to my ability to handle complex problems.

[16:19] <theorbtwo> Limbic_Region: I'm not 100% sure of that, but largely.

[16:20] <geoffb> I'd been taught for so long to only ever take one if algorithmically possible

[16:20] <Limbic_Region> geoffb - when I think of how to solve a problem I think how I would solve the problem myself (on paper usually)

[16:20] <Limbic_Region> iteratively - I only need to know the previous state to get the next one 

[16:20] <Limbic_Region> recursively you need to keep a running list of everything you have seen before until you get to some stop point

[16:21] <Limbic_Region> IOW - iteratively once you have completed an operation you can effectively throw it away

[16:21] <Limbic_Region> recursively you can't

[16:21] <geoffb> Limbic_Region, nodnod

[16:22] <theorbtwo> Yeah... I generally prefer thinking iteratively, because it prevents me from blowing /my/ stack.

[16:22] <theorbtwo> (I care a lot less about the computer's stack.)

[16:22] <geoffb> You know, now that I think of it, each new execution model I grok makes it easier for me to cast a given problem into some easy form.  Duh.  I suppose that's obvious

[16:23] <theorbtwo> Yeah.

[16:23] <geoffb> I just spent too long trying to force everything into the iterative model, and hence the reason I no longer trust it quite so much.

[16:23] <geoffb> theorbtwo, thanks for the vote of confidence.  ;-)

[16:24] <theorbtwo> Given enough eyeballs, all bugs are shallow.

[16:24] * geoffb reminds himself "Better to be thought an idiot than open ones mouth and prove it."  sigh.

[16:24] <Limbic_Region> s/prove it/remove all doubt/

[16:24] <geoffb> See, and there you go.

[16:24] <theorbtwo> Most things that humans can even consider will fit well in one model, given that you have enough to choose from.

[16:24] * geoffb is too tired to have a big ego.  That comes with sleep.

[16:25] <theorbtwo> geoffb: Everybody is idiotic sometimes.

[16:25] * theorbtwo is idiotic most of the time.

[16:25] <geoffb> Somebody just blogged about that on use.perl.org this week.

[16:26] * geoffb wonders whether hubris and tiredness are in fact inversely correlated

[16:27] * Limbic_Region puts YAHT down for a while to absorb what he has learned up to this point

[16:27] <theorbtwo> What is "this point", limbic?

[16:28] * eric256 heads off. could someone peek at units.p6 (in exmaples) and see if you can get the + overloading to actualy get called?

[16:28] <eric256> later

[16:28] <Limbic_Region> 3.8

[16:31] <Limbic_Region> ok - I think I am also going to go spend some time away from the puter

[16:31] <Limbic_Region> TTFN all

[16:33] <nothingmuch> phew

[16:33] <nothingmuch> too many things to do

[16:35] <gaal> is there something akin to ask, that gets my VCode?

[16:35] <gaal> actually, no

[16:35] <gaal> given an env, where's the VCode?

[16:36] <nothingmuch> which vcode?

[16:37] <gaal> i'm doing caller

[16:37] <gaal> i can get to the caller env

[16:37] <gaal> but i want to query the vcode

[16:37] <gaal> subName etc.

[16:38] <nothingmuch> hmm

[16:38] <nothingmuch> grep recursively for CALLER

[16:38] <nothingmuch> i forgot how it's done

[16:38] <nothingmuch> $?CALLER::SUB should contain the vcode in question

[16:38] <gaal> ah right, CALLER

[16:38] <gaal> thanks

[16:39] <gaal> btw:

[16:39] <gaal> :set grepprg=grep -n -r --exclude=*.svn* --exclude=*.o --exclude=*.hi

[16:39] <gaal> makes vimming happier

[16:39] <gaal> you obviously need gnu grep for this

[16:40] <nothingmuch> how does grep work from vim?

[16:41] <gaal> :grep moose src/

[16:41] <gaal> :cl       # shows a list of hits

[16:41] <gaal> :cn    # next on

[16:41] <gaal> :cp     # prev one

[16:41] <gaal> :6cc     # 6th one

[16:41] <gaal> same as quickfix

[16:42] * nothingmuch really has to learn to use quickfix

[16:42] <gaal> 06nothingmuch really has to learn to use quickfix01

[16:42] <nothingmuch> most of my compilations are on remote machines though

[16:42] <integral> o_O  purplish

[16:43] <theorbtwo> nothingmuch: When are you arriving in toronto?

[16:43] <nothingmuch> 21st

[16:43] <nothingmuch> i think afternoonish, but I'm not too sure

[16:44] <theorbtwo> Are you staying someplace for the night, and then being picked up?

[16:44] <nothingmuch> yep

[16:44] <theorbtwo> OK.

[16:45] <nothingmuch> why do you ask?

[16:48] <gaal> food, bbiab &

[16:56] <geoffb> iblech.ping

[16:56] <geoffb> Or hell, can anyone explain the story behind these:

[16:57] <geoffb> r4374, iblech++ | Limbic_Region++'s examples/nested_loops -- Usual svn props.

[16:57] <geoffb> I see several of them in the past hours.

[16:58] <gaal> docs/other/development_tips

[16:59] <geoffb> gaal, thx

[17:00] <geoffb> gaal: docbot  :-)

[17:00] * geoffb blinks

[17:01] <geoffb> Um, why is that not just done as the global default?  Does SVN not do that?

[17:03] <iblech> geoffb: Pong

[17:04] <iblech> geoffb: There're some ways to make that thing automatically, but they're, at least last time I checked, a bit kludgy

[17:05] <geoffb> ah

[17:05] <nothingmuch> back to teaching assembler... ciao guys!

[17:05] <geoffb> So I should just always do that sequence before commit

[17:05] <geoffb> nothingmuch++ just for doing that

[17:06] <nothingmuch> geoffb: eh?

[17:06] <iblech> ...before you checkin a new file, yep

[17:06] * iblech food &

[17:06] <geoffb> teaching assembler.  It's a good thing to do

[17:06] <geoffb> iblech, thx

[17:06] <nothingmuch> ah

[17:07] <nothingmuch> i'm afraid we aren't getting far with it... it's more of a "make sure it's done by tomorrow" sort of thing

[17:07] <geoffb> And TAP for assembly is genius, I might add

[17:07] <nothingmuch> she called me a bit too late

[17:07] <geoffb> s/teaching/tutoring/?

[17:07] <nothingmuch> oh, it's very ugly

[17:07] <nothingmuch> geoffb: perhaps, i don't really know the diff

[17:07] <nothingmuch> tutoring == 1 on 1?

[17:08] <geoffb> I often think of it as 1 on 1, sure, but I really meant "it sounds like she's taking a class (from someone else?), and asked for your help?"

[17:08] <geoffb> Or are you the prof?

[17:08] <nothingmuch> no, i'm not a prof

[17:09] <nothingmuch> her major was something else in school, i forgot what

[17:09] <nothingmuch> and then she was moved to computers

[17:09] <nothingmuch> and her sister is a very good friend of mine

[17:09] <nothingmuch> so i was called in to help

[17:09] <geoffb> heh

[17:09] <geoffb> gotcha

[17:09] <nothingmuch> make up for a year of missed studies mostly

[17:09] <geoffb> nodnod

[17:10] <nothingmuch> it's a shame it's so annoying to her

[17:10] <nothingmuch> she doesn't appreciate this stuff very much

[17:11] <nothingmuch> ooh, /me is like a snake.. burned finger 3 days ago, and now skin is peeling

[17:11] <geoffb> sigh

[17:11] <geoffb> (about the lack of appreciation)

[17:12] <nothingmuch> aye

[17:12] <Khisanth> nothingmuch: so why is she in this field of study?

[17:12] <nothingmuch> Khisanth: she was moved because her previous major course was canceled or something

[17:12] <nothingmuch> and in order to finish high school she needs to be tested on a subject

[17:13] <nothingmuch> someone decided for her, methinks

[17:13] <Khisanth> that seems rather silly

[17:13] <nothingmuch> it's very sill

[17:13] <Khisanth> that sounds worst than here in fact

[17:13] <nothingmuch> they also teach it quite badly

[17:13] <gaal> anyway, nothingmuch, CALLER unfortunately doesn't do what i need for, ah, caller.

[17:13] <gaal> i don't want to go through SUB

[17:13] <nothingmuch> gaal: look at how it's set up

[17:13] <gaal> in the parser?

[17:13] <nothingmuch> i forgot how it's done, but I remember that it's simple

[17:14] <nothingmuch> no, in the evaluator

[17:14] <gaal> but i don't have a handle on that through env

[17:14] <gaal> i can upstack, but that's only for env

[17:14] <nothingmuch> hmm

[17:14] <gaal> that has position, filename, etc, but not code.

[17:15] <gaal> i suppose i *can* readVar "&?SUB", but that's hacky

[17:15] <nothingmuch> their excercises are very stupid too... They are always dummy problems with no meaning, odd requirements, and they use the wrong tools for the job

[17:15] <nothingmuch> anyway, i must be off

[17:16] <gaal> byea.

[17:18] <gaal> i'll bbiab also. &

[17:54] <Aankh|Clone> Does Perl 5 embedding work for anyone on Win32?

[17:54] <Aankh|Clone> (MSVC++)

[17:54] *** Aankh|Clone is now known as Aankhen``

[18:05] <Aankhen``> And what exactly do !!! and ??? do?

[18:10] <Aankhen``> mugwump >> Ping.

[18:10] <theorbtwo> !!! dies when executed, ??? warns when executed, ... gives back a value that warns when looked at.

[18:10] <Aankhen``> theorbtwo >> Ah, thanks.

[18:13] <theorbtwo> AFAIK, the first two don't have names -- bang-bang-bang, huh, and yaddayaddayadda?

[18:13] <Aankhen``> LMAO.

[18:16] <svnbot6> r4381, Aankhen++ | * Date::Gregorian -- fixed Perl 5 array syntax.

[18:17] <mrborisguy> kharma Aankhen

[18:17] <mrborisguy> karma Aankhen

[18:17] <jabbot> mrborisguy: Aankhen has karma of 53

[18:17] <gaal> Aannkh - they don't currently work.

[18:17] <gaal> it

[18:17] <mrborisguy> karma Aankhen``

[18:17] <jabbot> mrborisguy: Aankhen`` has karma of 4

[18:17] <gaal> it dosen't work

[18:17] <gaal> (p5 embedding)

[18:17] <Aankhen``> Ah.

[18:17] <Aankhen``> Dang.

[18:17] <Aankhen``> I was hoping to use Date::Gregorian to replace HTTP::Date.

[18:18] <Aankhen``> But it might be a little hard to develop and debug if I can't even use the module. :-\

[18:18] <gaal> hard to fix, too, because GHC used msys gcc.

[18:18] <geoffb> mrborisguy, do you happen to know if it counts ++'s multiple times when a multiline svnbot6 appears?

[18:19] <geoffb> bah

[18:19] <geoffb> always just missing people

[18:19] <gaal> i think it does, geoffb.

[18:19] <Aankhen``> It does, geoffb.

[18:19] <Aankhen``> perlbot karma Aankhen

[18:19] <perlbot> Karma for Aankhen: 56

[18:20] <geoffb> perlbot karma geoffb

[18:20] <perlbot> Karma for geoffb: 5

[18:20] <geoffb> wow, I'll be damned.

[18:20] <Aankhen``> I think MusicMatch Jukebox didn't like being asked to prepare a CD label for a 5,000 song playlist...

[18:22] <geoffb> Is examples/perl5/ supposed to be for things that make use of use Foo--perl5 ?

[18:22] <gaal> seen autrijus

[18:22] <jabbot> gaal: autrijus was seen 9 hours 55 minutes 49 seconds ago

[18:23] <gaal> geoffb, dunno.

[18:23] <Aankhen``> Oh great, it finally wakes up and tells me I have no printers installed.

[18:24] <gaal> what were you expecting it to do, rampage?

[18:24] <gaal> ("it" sounds like you're constructing a golem :-)

[18:24] <Aankhen``> No, I was expecting it to show me a preview of how it would fit 5,000 artists and song titles on one tiny CD label.

[18:43] <pasteling> "geoffb" at 69.110.115.185 pasted "Something not right with use Foo--perl5; supposedly equivalent code in p5 and p6 don't act the same (but don't crash, either)" (35 lines, 1.1K) at http://sial.org/pbot/10709

[18:47] <geoffb> I have a funny feeling that debugging the above is beyond my current skills -- given that I don't read Haskell yet.  :-)

[19:12] <geoffb> afk for a bit (sandwich and head-clearing

[20:28] <mrborisguy> can somebody help me with trying to use XML::Simple's XMLin to work in p6?

[20:28] <svnbot6> r4382, mrborisguy++ | Vim Syntax Highlighting: support for q:1{..} and q:2{..} (so my entire file doesn't turn red if I use one of those! ;) )

[20:29] <mrborisguy> i can't seem to figure it out!

[20:32] <mrborisguy> when I do: use XML::Simple--perl5; my %hash = XMLin( "test.xml" );  it gives me an error about XMLin not found

[20:32] <mrborisguy> use XML::Simple--perl5 <XMLin>; my %hash = XMLin( "test.xml" );  gives me an error about not being able to find XML::Simple

[20:32] <mrborisguy> (i'm on feather, and I did a locate, and XML::Simple is in one of the perl5 directories

[20:33] * crysflame has no skill to answer the question

[20:36] <iblech> Try XML::Simple::XMLin?

[20:36] <iblech> (But I can't be of much help either, as my Pugs doesn't embed Perl 5)

[20:38] <geoffb> mrborisguy, sorry for delay:  Are you expecting &XMLin to be exported to you?  It isn't right now . . . its a feature.

[20:38] <geoffb> er, unimplemented feature

[20:38] <geoffb> export from --perl5 doesn't happen.

[20:38] <mrborisguy> iblech: *** No compatible subroutine found: "&XML::Simple::XMLin"

[20:39] <geoffb> Autrijus asked for tests, which I've been idly plaing with over time.

[20:39] <mrborisguy> geoffb: is there anyway I can use XMLin then?

[20:39] <mrborisguy> or will I just have to be patient?

[20:39] <geoffb> mrborisguy, yeah, see my pasteling above

[20:39] <geoffb> http://sial.org/pbot/10709

[20:39] <geoffb> (My problem seems to be farther down the line, but I did get past the initial binding problem)

[20:40] <mrborisguy> so just use 'eval_perl5' is my way to go?

[20:40] <geoffb> Autrijus also claims the following will work:

[20:41] <geoffb> autrijus: geoffb: it's merely adding "our &foo := Module::Name.can('blah')" calls

[20:41] <geoffb> Didn't try that variant though

[20:44] <hhhhh> hi

[20:44] <hhhhh> anyone awake?

[20:45] <geoffb> yep, for some of us it's still light out

[20:45] <arcady> or the middle of the day, even

[20:47] <ingy> hola

[20:47] <geoffb> allo

[20:47] <mrborisguy> geoffb++: alright, that definitely worked for me... thanks

[20:48] <geoffb> mrborisguy, np.  Did you go the eval_perl5 rought or the .can() route?

[20:48] <mrborisguy> eval_perl5 route

[20:49] <ingy> while pugs is compiling I have a question...

[20:49] <mrborisguy> ingy: fire away

[20:49] <ingy> does `prove` work with pugs testing?

[20:49] <ingy> prove t/foo/bar.t

[20:49] <ingy> etc

[20:50] <iblech> It does.

[20:50] <mrborisguy> geoffb:  i just tried the 'can' method too, and that works just as well!

[20:50] <geoffb> schweet.  And looks cleaner too, I may switch then.

[20:56] <ingy> iblech: thanks

[21:09] <geoffb> Wheeee . . . recompiling fun

[21:09] <svnbot6> r4383, mrborisguy++ | Vim Syntax Highlighting: a few more small changes ( q :1 { .. } )

[21:12] * ingy has a new module that should help make pugs testing faster...

[21:12] <geoffb> ingy, please!  It's brutally slow here

[21:13] <ingy> hmm

[21:13] <ingy> prove t/builtins/arrays/end.t  <--- *blows up*

[21:13] <ingy> t/builtins/arrays/end....Can't exec /usr/bin/pugs at t/builtins/arrays/end.t line 1.

[21:14] <geoffb> But other tests work?

[21:15] <ingy> it is `prove` that is not working

[21:15] <ingy> ./pugs t/builtins/arrays/end.t <--- passes all 13 tests

[21:15] <geoffb> sorry, I meant "But prove with other test files works"?

[21:15] <ingy> prove is not working with pugs environment

[21:16] <iblech> Ah, it's probably because of missing ENV variables

[21:16] <geoffb> I'm guessing you did not 'make install' pugs, given that you refer to ./pugs above, but you want it to notice that there is a bugs in the cur_dir and use that instead?

[21:16] <geoffb> er s/bugs/pugs/

[21:17] <geoffb> hmmm

[21:17] * geoffb is Obvious Boy today

[21:17] <iblech> Add your Pugs dir to $PERL6LIB and $PATH

[21:17] <ingy> well /usr/bin/pugs is not where my pugs installs

[21:18] <ingy> iblech: why would prove care about PER6LIB?

[21:21] <ingy> my answer likely lies in inc/Test/Harness.pm

[21:21] <ingy> hi DrForrester 

[21:21] <iblech> ingy: So the tests find Test.pm

[21:21] <ingy> iblech: that's not my problem though

[21:23] <ingy> hrm... prove is execing the #!/usr/bin/pugs

[21:25] <iblech> Ah, that's another problem. IIRC there's $PERL_HARNESS or so, but I've simply created a symlink from /usr/bin/pugs to $PWD/pugs

[21:26] <ingy> hmmm

[21:26] <ingy> well that is *one* way to do it

[21:26] * ingy dives into Test::Harness...

[21:27] <iblech> Yep. And it allows you to start Pugs by entering "pugs", and not "./pugs" :)

[21:44] <ingy> iblech: HARNESS_PERL=./pugs prove t/builtins/arrays/end.t

[21:44] <ingy> is what I neeed :)

[21:44] <iblech> :) This should definitely go into docs/other

[22:38] <SyntaxNinja> wow. lots of folks in here these days :)

[22:41] <ingy> hi SyntaxNinja 

[22:52] <SyntaxNinja> hi ingy

[23:04] <ingy> is there a way to set an environment variable such that it always interpolated to the current date

[23:05] <geoffb> ingy, I would think not without the complicity of any called programs -- otherwise, at best you could get an interpolation as of the start time of a subprocess.

[23:05] <geoffb> But maybe that's enough . . . .

[23:06] <geoffb> Sadly, though I think this would be possible, my shell-fu is too weak to do it.  Some sort of delayed evaluation beastie, I suppose

[23:06] <ingy> hmm. I know what to do now....

[23:22] <svnbot6> r4384, geoffb++ | Added golfed version from http://perlmonks.org/?node_id=463610

[23:23] <geoffb> And with that, I'm out for a while.

