[00:00] <theorbtwo> G'night, laz.

[00:00] <theorbtwo> liz.

[00:00] <liz6> g'night theorbthree  ;-)

[00:01] <leo> and four me g.night 2

[00:16] <svnbot6> r7912 | stevan++ | Perl6::ObjectSpace -

[00:16] <svnbot6> r7912 | stevan++ | * all methods in Bootstrap now have a checked return type :)

[01:17] *** Lopo_ is now known as Lopo

[05:16] <gaal> dduncan: I won't have time to hack .hs myself in the coming week or so, so by all means go for it if you want.

[05:17] <gaal> rafl: does what work for me?

[05:17] <rafl> gaal: pge support. You said it doesn't work on feather.

[05:18] <gaal> SamB: er, of course. Did I imply that you can somewhere? :) The sourcy macos package "uses a binary bootstrap compiler"

[05:18] <gaal> rafl: sec.

[05:19] <rafl> Does someone know under what license autrijus talks are? I want to give a Perl 6/Pugs talk on friday and would like to steal excessive from him.. :-)

[05:19] <pasteling> "gaal" at 192.115.25.249 pasted "pge not working" (3 lines, 143B) at http://sial.org/pbot/14193

[05:20] <rafl> Try to use /usr/bin/pugs?

[05:21] <gaal> long as the flight from .ch to .hk may be, i'm pretty sure he'll be landing by then :)

[05:22] <pasteling> "gaal" at 192.115.25.249 pasted "no go with system pugs either" (4 lines, 264B) at http://sial.org/pbot/14194

[05:22] <rafl> Hm. The system pugs error confueses me.

[05:23] <rafl> Doesn't it work on feather only?

[05:23] <rafl> Read as: Is there someone who has this running?

[05:24] <gaal> rafl: let me test on my colinux

[05:24] <gaal> but wait, are you doing parrot now too? wow

[05:25] <rafl> Noone else wants to, as it seems.

[05:25] <rafl> There has been a request for a Debian package for months and no one felt responsible, so I did.

[05:26] <gaal> i think there's at least one other way to put that, but rafl++ nonetheless :)

[05:26] <rafl> What's the other way? :-)

[05:26] <gaal> so i should just dpkg -i everything from ~rafl/public_html/debian/ ?

[05:27] <rafl> gaal: Not libghc6-* -- it's broken from SVN currently.

[05:28] <gaal> s/responsible/capable/, for one. or knowledgeful of debian. or temporally able.

[05:28] <gaal> ok

[05:29] <rafl> Well. It's not that much work currently. One release a month isn't that much.

[05:30] <gaal> isn't it kind of an asymptotic thing? huge inital overhead, gets easier the more frequent releases are?

[05:30] <rafl> If you packaged it once you'll only need to bump up versions in some places and everything works again. Nothing that you need really deep Debian knowledge for.

[05:31] <rafl> The initial overhead wasn't that huge. I thought that first so I hestiated to do a parrot package for some weeks. I also started to do it in a branch so I could not break anything because I thought there were some major changes to the build system needed.

[05:31] <rafl> But in fact it was done in only some hours and I merged the branch directly back some hours after creating it. :-)

[05:32] <gaal> i meant the whole debian gig.

[05:32] <rafl> I don't get you then.

[05:33] <gaal> part of the overhead is learning debian packaging, getting to know/be known by the other debian people.

[05:33] <gaal> if i had to package something once a year in debian, that once a year would be very hard

[05:34] <gaal> if i did it every week, it'd be crazy at first but then sorta ease out. no?

[05:34] <rafl> I guess that's right.

[05:35] <gaal> fwiw: on my test machine, PGE fails in the same way it did with eric's autobuild

[05:35] <gaal> not in the way /usr/bin/pugs failed on feather.

[05:35] <rafl> It usually takes me less around 5 minutes to make a Debian package of an average cpan module now. When I started it took hours and others still had to complain about it..

[05:35] <rafl> gaal: I've no idea then.

[05:35] <gaal> in any case i doubt the problem is in the package itself.

[05:36] <rafl> The problem with /usr/bin/pugs on feather maybe is. I'm not sure though.

[10:19] <buu> ?eval { 1 }

[10:19] <evalbot_7912> 1 

[10:19] <buu> ?eval { 1 }->()

[10:19] <evalbot_7912> Error:  unexpected ">" or "-" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[10:19] <buu> ?eval sub { 1 }

[10:19] <evalbot_7912> sub {...} 

[10:21] <buu> ?eval x => {1}

[10:21] <evalbot_7912> ("x" => sub {...}) 

[10:25] <azuroth> ?eval { 1 }.()

[10:25] <evalbot_7912> 1 

[10:25] <azuroth> ?eval -> $a { $a }.(5)

[10:25] <evalbot_7912> \5 

[10:25] <azuroth> slash five, eh?

[10:28] <theorbtwo> azuroth: evalbot, for reasons that I've never quite understood, often gives one level of enreferencing beyond what you'd expect to see.

[10:29] <azuroth> ahh

[10:29] <azuroth> I don't think I've noticed before

[10:31] <buu> eval: 1

[10:31] <buubot> buu: Return: 1 

[11:02] <love_ANGEL> selam k0131zlar benimle tan0131015fmak isteyen varm0131yd0131

[11:02] <love_ANGEL> ?

[11:03] <love_ANGEL> alo kimse yokmu dur

[11:03] <love_ANGEL> be

[11:03] <love_ANGEL> sizi bekliyorum ama ben

[11:03] <love_ANGEL> ?

[11:04] <azuroth> saluttt les pdddd, love angel!

[11:04] * azuroth wonders whether "for @foo -> $x, $y, $x" is a mistake in the quickref

[11:07] *** nnunley_ is now known as nnunley

[11:10] <azuroth> I'm going to assume it is, and change the last x to z. take that!

[11:10] <theorbtwo> Looks like a typo to me.

[11:17] <svnbot6> r7913 | azuroth++ | Changed quickref's control so that

[11:17] <svnbot6> r7913 | azuroth++ | 	for @foo -> $x, $y, $x

[11:17] <svnbot6> r7913 | azuroth++ | is now

[11:17] <svnbot6> r7913 | azuroth++ | 	for @foo -> $x, $y, $z

[12:25] <azuroth> "the list ctoring comma operator supplies this list context: sub *infix:<*> (*@things) { ... }" - should that be *infix:<,> ?

[12:26] <theorbtwo> Quite likely.  prefix:<*> also makes some sense, but not much.

[12:27] <azuroth> I also noticed it didn't mention * providing list context (but did mention ~, +, and ?) and thought that was a bit peculiar

[12:29] <rafl> Well, $x, $y, $x could also be useful. Even if there could be a better way like @foo -> undef, $y, $x or @foo -> _, $y, $x

[12:30] <azuroth> I think it actually assigned x to the first value it saw. but yeah, it _could_ be useful

[12:30] <azuroth> it's a peculiar and confusing case for being in the quickref though, in my opinion

[12:31] <rafl> Indeed.

[12:31] <theorbtwo> I don't think we want obfu cases in our quickref.

[12:32] <rafl> Don't we? Ooo :-(

[12:32] <theorbtwo> Putting "_ = foo() # Explicitly ignore the return of foo." in might be useful.

[12:34] <rafl> Is _ really perl 6? Where is it described?

[12:34] <theorbtwo> Donno; just seen it alluded to on the chan.

[12:35] <rafl> But I thing _ = foo() is ugly. foo() in void context does the same.

[12:35] <rafl> Well, I think the _ is stolen from haskell.

[12:35] <theorbtwo> But it's a simple example.

[12:35] <theorbtwo> (_, $x, $y) = foo() would be an actually useful one.

[12:36] <rafl> I think undef is Perl 6's _

[12:36] <rafl> Just like in Perl 5.

[12:43] <azuroth> good night, everyone

[12:44] <liz6> night, azuroth!

[12:45] <gaal> liz6: hi

[12:45] <liz6> gaal: hi!

[12:46] <gaal> thanks for the notes. :)

[12:46] <gaal> what did you mean by best practices in regard to the function call examples?

[12:47] <theorbtwo> Hi, liz.

[12:47] <theorbtwo> And gaal.

[12:47] <gaal> hey :)

[12:47] <liz6> foo( $a ) as opposed to foo ($a) ?

[12:48] <gaal> is that in PBP? I don't like it.

[12:48] <liz6> I think it is...

[12:48] <liz6> someone pls correct me if I'm wrong...  ;-)

[12:49] <theorbtwo> I wouldn't put a space between the name and the beginning of the arg list, because you shouldn't try to call perl 6 subs that way.

[12:49] <xinming> liz6: foo( $a ) = foo $a; but != foo ( $a );

[12:50] <xinming> foo ($a) is become a bit like, foo list( $a );

[12:50] <liz6> that's why I put a question mark in my comments...

[12:50] <liz6> so, please treat it as a slippo of my fingers..

[13:23] <wolverian> rafl, tentatively, ? (I think) and ! mean optional and required params that are ignored, in signature lists.

[13:23] <wolverian> rafl, the same could apply to any binding.

[13:48] <gaal> sorry, was whisked away by $work

[13:49] <gaal> I think I've settled on `sub foo (args)` in signatures and `foo(args)` in calls. `( args )` looks weird to my eyes.

[13:50] <theorbtwo> To mine too, gaal.

[13:50] <gaal> though in Perl 5 I often said things like for (@{ $listref }) { ... }

[13:50] <theorbtwo> OTOH, I don't like that calling a sub like you write the signature will silently do the wrong thing in many cases.

[13:54] <gaal> significant whitespace is teh weird, yeah. can't say it isn't useful at times, though!

[13:58] <rafl> autrijus: ping

[14:04] <Limbic_Region> salutations all

[14:05] <kolibrie> good morning, Limbic_Region 

[14:06] <liz6> rafl: I think autri is en route from helsinki to taipei right now...

[14:06] <rafl> liz6: Ah, OK. ETA?

[14:07] <liz6> not sure: I wouldn't expect anything from autri in the next 24 hours...

[14:07] * Limbic_Region wouldn't bet on that

[14:07] <liz6> ;-)

[14:07] <liz6> seen autrijus

[14:07] <jabbot> liz6: autrijus was seen 23 hours 50 minutes 40 seconds ago

[14:08] <liz6> L~R: I guess that would be a record, no? 48 hours?   ;-)

[14:09] <Limbic_Region> liz6 - there have been times where he wasn't around in IRC but was still checking in to svn

[14:09] <Limbic_Region> meant to ask you about your coroutine specs

[14:09] <Limbic_Region> if I create a coroutine and have a yield in the body of the loop, does the coroutine work like a full-body continuation?

[14:10] <Limbic_Region> and not like a p5 fancy goto?

[14:10] <liz6> it's my understanding that execution will continue after the yield() at the next invocation

[14:10] <Limbic_Region> IOW - can I resume inside a loop requiring initialization where in p5 (simulating coroutines with fancy goto tricks) you could not

[14:10] <liz6> regardless of where that is...

[14:11] <Limbic_Region> ok - cool

[14:11] * liz6 off to do some shopping and then back to $work

[14:59] <robkinyon> What's the difference between Ruby's coros and what is planned for P6?

[14:59] <Limbic_Region> read S17

[14:59] <robkinyon> thx

[14:59] <Limbic_Region> rather - read S17 that's in the Pugs repository

[15:00] <Limbic_Region> keeping in mind it was specced by liz and autrijus (with some influence by wendy)

[15:00] <Limbic_Region> IOW - it is a draft that @larry needs to stamp 

[15:00] <robkinyon> wendy?

[15:01] <liz6> my spouse...

[15:02] <r0nny> yo

[15:03] <Limbic_Region> in any case, Parrot has got the goods - the decision on the p6 side is how much/little to use 

[15:03] <Limbic_Region> and how to handle things like parameters

[15:03] <Limbic_Region> which can go several different ways with strong supporting arguments for each

[15:04] <robkinyon> liz6: Oh - I didn't know you were married. :-)

[15:04] <robkinyon> limbic_region: Hmmm ... I'm liking Ruby's coros a lot

[15:05] <Limbic_Region> robkinyon - I am Ruby ignorant, mind giving me an example?

[15:05] <svnbot6> r7914 | iblech++ | docs/quickref/data: Fixed somewhat critical typo, spotted by azuroth++.

[15:05] <robkinyon> one sec

[15:05] <Limbic_Region> and have you read Dan's "What the heck is a coroutine" blog?

[15:05] <robkinyon> LR: Yeah, I've read it

[15:06] <robkinyon> i need to reread it after having learned Ruby, though

[15:06] <Limbic_Region> http://www.sidhe.org/~dan/blog/archives/000178.html

[15:06] <robkinyon> my eyes glazed a bit cause i didn't have any experience. :-)

[15:06] <Limbic_Region> yeah - fortunately for me, I was in #parrot at the time and got some real time explanations

[15:07] <Limbic_Region> understanding how continuations and coroutines differed really solidified things for me

[15:07] <Limbic_Region> but I would be happy to see how coroutines work in Ruby

[15:07] <Limbic_Region> unfortunately - all implementations of coroutines that I know about are still just emulations of Knuth's original brain child

[15:08] <lisppaste3> robkinyon pasted "Ruby coros" at http://paste.lisp.org/display/13367

[15:08] <robkinyon> That's from my port of Tree.pm to Ruby - it gives traverse() both implements and uses coros

[15:09] <Limbic_Region> the case statement isn't required though right

[15:09] <robkinyon> I use the case statement to determine which traversal method I'm supposed to do

[15:09] <Limbic_Region> the yields could just as easily have been outside?

[15:09] <robkinyon> yeah

[15:10] <Limbic_Region> I don't see anything there that would lead me to believe there will be undesireable differences

[15:11] <robkinyon> well, you mentioned a number of different WTDI

[15:11] <Limbic_Region> 1 thing you have there is just what I was confirming with liz - that coroutines can yield and resume inside a construct requring initialization

[15:11] <robkinyon> "construct requiring initialization"?

[15:11] <Limbic_Region> in p5 speak, gotos can't jump inside a loop or a subroutine

[15:11] <robkinyon> ah

[15:12] <robkinyon> gotos can't enter a scope?

[15:12] <Limbic_Region> they can as long as initialization isn't required

[15:12] <liz6> from Dan's blog:

[15:12] <liz6> "One thing to remember is that you can yield out of a coroutine no matter how deeply you're into it. Our examples are really simple, but you could be nested ten or twenty levels of scope deep in a coroutine and still yield out--when you re-invoke the coroutine you'll be dropped back where you were, ten or twenty levels deep, with all your lexicals put back in place."

[15:12] <robkinyon> That's how Ruby's coros work

[15:13] <robkinyon> plus, you can pass in a Proc object that has a completely different scope and yield to it

[15:13] <Limbic_Region> in any even robkinyon, that's not the issue with different WTDI

[15:13] <robkinyon> (which is important)

[15:13] <Limbic_Region> the issue is with parameters

[15:13] <robkinyon> ok ... ?

[15:13] <Limbic_Region> let me nopaste

[15:13] <robkinyon> k

[15:13] <Limbic_Region> perlbot nopaste

[15:13] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[15:16] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "coroutines and parameter binding" (24 lines, 356B) at http://sial.org/pbot/14202

[15:16] <Limbic_Region> sorry - was filling in commentary

[15:17] <robkinyon> huh

[15:17] <Limbic_Region> what huh?

[15:18] <robkinyon> lemme see what ruby does

[15:18] <robkinyon> ok - ruby has a strict type signature

[15:19] <robkinyon> so, "def foo ( a )" requires that there's a parameter every time

[15:19] <robkinyon> Also, yield will only yield to the associated block

[15:19] <robkinyon> So, you cannot yield to your caller - you only yield to the coro that you've been handed to

[15:20] <Limbic_Region> hmmm - not sure I understand that last statement, but before you explain

[15:21] <Limbic_Region> does changing the parameter affect how that parameter is bound

[15:21] <Limbic_Region> for instance - does calling foo(3) where the yield is returning the parameter change

[15:21] <Limbic_Region> if you subsequently invoke with foo(5)

[15:21] <Limbic_Region> ?

[15:22] <robkinyon> yield doesn't yield to the caller

[15:22] <robkinyon> it yields to the associated Proc object

[15:22] <Limbic_Region> *shrug* - I guess I need to understand Ruby to understand that distinction

[15:22] <robkinyon> So, if you had "def foo ( a ) yield a", you would call it as "foo(3) { |x| print a }"

[15:23] <robkinyon> You associate a block with the method that has a yield in it

[15:23] <Limbic_Region> oh, I get it

[15:23] <Limbic_Region> hmmm

[15:23] <robkinyon> the caller isn't involved, save to potentially provide scope to the associated block

[15:23] <Limbic_Region> would definately have to defer you to liz, autrijus, etc on that one

[15:23] <robkinyon> heh

[15:23] <robkinyon> I like ruby's coros

[15:23] <robkinyon> they're very neat and clean

[15:24] <Limbic_Region> while I can conceptually understand it - I have no idea about Parrot's implementation and therefore Perl6's ability to bend that implementation to your will ;-)

[15:24] <robkinyon> hmm

[15:25] <robkinyon> coros, as I think you're understanding them, allow the function to yield to the caller, then resume functioning where the yield occurred the next time it's called?

[15:25] <Limbic_Region> yes

[15:25] <Limbic_Region> where as a continuation can be resumed anywhere

[15:25] <robkinyon> ok - in ruby, coros are primarily used to implement iterators

[15:25] <SamB> Limbic_Region: Parrot is a VM -- what difference does the implementation make?

[15:25] <robkinyon> for example, foo.each { |x| ... }

[15:26] <Limbic_Region> SamB - a matter of emulation (or how much work it takes to get the job done)

[15:26] <Limbic_Region> SamB - in p5, you can simulate coroutines - but only to a certain extent

[15:26] <robkinyon> LR: You could implement them fully, but you would have to maintain all the state yourself within the coro

[15:26] <Limbic_Region> for instance - goto's can't jump inside constructs requiring inialization

[15:26] <robkinyon> You'd practically have to implement a VM within each coro

[15:27] <SamB> Limbic_Region: maybe you meant Parrot's specification?

[15:27] <robkinyon> you'd have to unroll everything. :-)

[15:27] <Limbic_Region> SamB - right

[15:27] <Limbic_Region> thanks for clarification

[15:27] <liz6> isn't that what continuattions are about?

[15:27] <Limbic_Region> yes liz6

[15:28] <Limbic_Region> but to make robkinyon's Ruby syntax work in perl6 likely requires some manipulation

[15:28] <Limbic_Region> and I don't know how much or where to start

[15:28] <liz6> ah, ok, in that sense...

[15:28] <Limbic_Region> which is why I deferred 

[15:28] <SamB> now if we were talking about, say, Python's VM, it would be "implementation", because there is no spec for that.

[15:28] <Limbic_Region> and you would definately know

[15:29] <Limbic_Region> so WRT my earlier statement, I should have said spec and subsequent implementation of that spec (as there are no guarantees the implemenation matches the documentation)

[15:29] <robkinyon> well, it actually doesn't take much

[15:29] * Limbic_Region wanders off for a sec

[15:30] <robkinyon> In essence, Ruby's coros are more syntactical sugar for P5's & prototype that happens to be at the end instead of the beginning

[15:31] <robkinyon> And, you get a keyword for calling that subref called "yield [ARGS]" instead of doing $subref->([ARGS]) yourself.

[15:31] <robkinyon> Look at http://www.perlmonks.org/?node_id=506753 for a few different implementations of Ruby's Array.partition() in Perl

[15:32] <robkinyon> In Ruby, the block is at the end where it's in the beginning in Perl5

[15:32] <robkinyon> You could easily do this in P6 with a method signature

[15:32] <Limbic_Region> liz6 - has S17 been handed off to @larry for their perusal?

[15:33] <robkinyon> The only thing in Ruby is that you don't have to know about the block - it's just there for you unless you need to pass it along, as I did in my nopaste

[15:33] <Limbic_Region> if so, perhaps robkinyon wants to post a question to p6.l as food for thought when they are considering it

[15:33] <liz6> L~R: nope, still working on it, while $work is piling up...

[15:34] <liz6> ;-(

[15:34] <Limbic_Region> oh, well then I will shut up and let you get back to it

[15:34] <liz6> suggestions / patches welcome!

[15:34] <robkinyon> I'll wait until it's posted to ask my question

[15:38] * kolibrie just saved several minutes by using pugs to do some number crunching on a YAML file

[15:38] <kolibrie> (pugs)++ (Perl 6)++

[15:38] <r0nny> (black perlvodoo)++ ;P

[15:40] <dada> <<pugs perl6>>^++

[15:41] <dada> ?eval <<pugs perl6>>

[15:41] <evalbot_7914> ("pugs", "perl6") 

[15:41] <dada> ?eval my $x = 1; my $y = 2; ($x, $y)^++

[15:41] <evalbot_7914> Error:  unexpected end of input expecting term 

[15:41] <dada> oops

[15:42] <dada> my perl6 is rusty already

[15:42] <robkinyon> ?eval <<pugs perl6>>^++

[15:42] <evalbot_7914> Error:  unexpected end of input expecting term 

[15:42] <robkinyon> ?eval <<pugs perl6>>^++;

[15:42] <evalbot_7914> Error:  unexpected ";" expecting term 

[15:43] <robkinyon> ?eval <<pugs perl6>>^+ 1

[15:43] <evalbot_7914> 1 

[15:43] <robkinyon> ?eval <<pugs perl6>> ^+ 1

[15:43] <evalbot_7914> 1 

[15:43] <dada> ?eval <<1 2>> ^+ 1

[15:43] <evalbot_7914> 1 

[15:43] <dada> ?eval my @a = (1,2); @a^++; @a;

[15:43] <evalbot_7914> Error:  unexpected ";" expecting term 

[15:44] <dada> ?eval my @a = (1,2); @a^+=1; @a;

[15:44] <evalbot_7914> Error:  unexpected "=" expecting "0", digit or fraction 

[15:44] <dada> ?eval my @a = (1,2); @a>>+=1; @a;

[15:44] <evalbot_7914> Error:  unexpected ">" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:44] <dada> don't remember

[15:45] <dada> ?eval (1,2)>>+<<(2,3)

[15:45] <evalbot_7914> (3, 5) 

[15:45] <dada> ?eval (1,2)>>+1

[15:45] <evalbot_7914> Error:  unexpected ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:45] <dada> ?eval (1,2)>>+ 1

[15:45] <evalbot_7914> Error:  unexpected ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:46] <dada> isn't this a bug?

[15:46] <dada> ?eval (1,2)>>+<<1

[15:46] <evalbot_7914> (2, 3) 

[15:46] <dada> ?eval (1,2)>>++<<

[15:46] <evalbot_7914> Error:  unexpected "<" or ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:48] <dada> ?eval <<pugs perl6>> >>+<< <<perl6 pugs>>

[15:48] <evalbot_7914> (0.0, 0.0) 

[15:48] <dada> ?eval <<pugs perl6>>>>+<<<<perl6 pugs>>

[15:48] <evalbot_7914> Error:  unexpected "<" or ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:48] <dada> heh

[15:52] <dada> ?eval <<1 2>> >>+<< <<2 3>>

[15:52] <evalbot_7914> (3.0, 5.0) 

[15:56] <Limbic_Region> ?eval (1, 2) >>+<< (2, 3)

[15:56] <evalbot_7914> (3, 5) 

[15:59] <Limbic_Region> ?eval(1, 2, 3) >>+<< (4, 2)

[15:59] <evalbot_7914> (5, 4, 3) 

[16:03] <dada> ?eval <<j p 6>> >>~<< <<a h>>

[16:03] <evalbot_7914> ("ja", "ph", "6") 

[16:03] <dada> ?eval [~] <<j p 6>> >>~<< <<a h>>

[16:03] <evalbot_7914> "japh6" 

[16:03] <dada> yippee!! :-)

[16:03] <robkinyon> ?eval <<pugs perl6>> >>++

[16:03] <evalbot_7914> Error: Can't modify constant item: VStr "pugs" 

[16:03] <theorbtwo> Hm, [~] <<j p 6>>»~«<<a h>>

[16:03] <robkinyon> ?eval <"pugs" "perl6"> >>++

[16:03] <evalbot_7914> Error: Can't modify constant item: VStr "\"pugs\"" 

[16:04] <theorbtwo> ?eval [~] <<j p 6>>»~«<<a h>>

[16:04] <evalbot_7914> Error:  unexpected "\\" expecting term postfix, operator, ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[16:04] <robkinyon> ?eval <$x="pugs" $y="perl6"> >>++

[16:04] <evalbot_7914> Error: Can't modify constant item: VStr "$x=\"pugs\"" 

[16:04] <robkinyon> ?eval $x='pugs';$y='perl6';<$x $y> >>++

[16:04] <evalbot_7914> Error: Undeclared variable: "$x" 

[16:04] <robkinyon> ?eval my$x='pugs';my$y='perl6';<$x $y> >>++

[16:04] <evalbot_7914> Error: Can't modify constant item: VStr "$x" 

[16:04] <robkinyon> Gack!

[16:04] <robkinyon> ?eval my$x='pugs';my$y='perl6';($x $y) >>++

[16:04] <evalbot_7914> Error:  unexpected "$" expecting operator or ")" 

[16:04] <robkinyon> ?eval my$x='pugs';my$y='perl6';($x, $y) >>++

[16:04] <evalbot_7914> Error: Can't modify constant item: VStr "pugs" 

[16:05] <robkinyon> ?eval my$x="pugs";my$y="perl6";($x, $y) >>++

[16:05] <evalbot_7914> Error: Can't modify constant item: VStr "pugs" 

[16:05] <dada> it doesn't do ++ on strings yet, maybe

[16:05] <robkinyon> feh

[16:05] <dada> ?eval my $x=1; my $y = 2; ($x, $y) >>++

[16:05] <evalbot_7914> Error: Can't modify constant item: VInt 1 

[16:05] <dada> no, it's something deeper

[16:05] <dada> ?eval my $x=1; my $y = 2; ($x, $y) >>+<< 1

[16:05] <evalbot_7914> (2, 3) 

[16:06] <dada> ?eval my $x=1; my $y = 2; ($x++, $y++)

[16:06] <evalbot_7914> (1, 2) 

[16:06] <dada> that's unorthogonal

[16:07] <robkinyon> ?eval my $x=1; my $y=2;(++$x, ++$y)

[16:07] <evalbot_7914> (2, 3) 

[16:07] <robkinyon> ?eval (2,3) >>++

[16:07] <evalbot_7914> Error: Can't modify constant item: VInt 2 

[16:07] <dada> ?eval 2++

[16:07] <evalbot_7914> Error: Can't modify constant item: VInt 2 

[16:07] <robkinyon> yeah

[16:07] <dada> that's orthogonal

[16:07] <robkinyon> LOL

[16:09] <robkinyon> it's orthogonal to itself, but doesn't look very spec-ish

[16:09] <dada> no no

[16:09] <dada> it's unorthogonal

[16:10] <theorbtwo> my $x=1; my $y = 2; ($x, $y) >>++ not working doesn't make sense to me.  The rest do.

[16:10] <theorbtwo> ?eval my $x=1; my $y = 2; ($x, $y)>>++

[16:10] <evalbot_7914> Error: Can't modify constant item: VInt 1 

[16:10] <theorbtwo> Just making sure.

[16:10] <dada> you can't do 2++ and you can't do (2,3) >>++

[16:10] <dada> but you can do ($x++, $y++) and you can't do ($x, $y) >>++

[16:10] <dada> that's unorthogonal

[16:11] <robkinyon> or, rather ++$x,++$Y

[16:11] <dada> well, the result doesn't matter

[16:11] <dada> the fact is that ($x, $y) >>++ should be perfectly equivalent to ($x++, $y++)

[16:11] <PerlJam> dada: depends on if () created a tuple (ala python) or not.

[16:11] <PerlJam> if ($x,$y) is a tuple, then it's immutable.

[16:12] <PerlJam> no lvalue there, only rvalue

[16:12] <dada> nope

[16:12] <dada> ?eval my($x, $y) = (2,3); ($x, $y)

[16:12] <evalbot_7914> (\2, \3) 

[16:12] <dada> ouch

[16:13] <dada> ?eval my $x = 2; $x

[16:13] <evalbot_7914> \2 

[16:13] <dada> you see? it's orthogonal

[16:13] <dada> no tuple here

[16:14] <theorbtwo> dada: I think you are using orthogonal in non-useful ways.

[16:14] <theorbtwo> The problem is that the ($a,$b) that >>++ is trying to apply to needs to work somewhat differently from a random list-forming ($a, $b).

[16:15] <theorbtwo> It needs to act as the argument list to >>++, and get bound with :is rw, instead of :is copy or :is ro.

[16:15] <dada> mmm

[16:15] <dada> ?eval my @a = (1,2); @a >>++; @a

[16:15] <evalbot_7914> Error: Can't modify constant item: VInt 1 

[16:15] <theorbtwo> OK.

[16:15] <theorbtwo> Now I don't know WTF is going on.

[16:15] <dada> it's the same, I guess

[16:16] <dada> ?eval my @a = (1,2); @a++; @a

[16:16] <evalbot_7914> [3,] 

[16:16] <dada> !!!

[16:16] <theorbtwo> @a is taken in scalar context, get 2, ++ that, assign it back to @a.

[16:17] <dada> yes, right

[16:17] <theorbtwo> ?eval my @a = (1,1); @a++; @a

[16:17] <evalbot_7914> [3,] 

[16:17] <dada> ?eval my @a = (1,2,3,4); @a++; @a

[16:17] <evalbot_7914> [5,] 

[16:17] <dada> ok

[16:18] <theorbtwo> I'm not real sure that's what it should do, but I can't think of anything saner for it to do.

[16:18] <broquaint> It should die. Loudly.

[16:19] <dada> 1;

[16:19] <theorbtwo> "Die loudly" seems like a fairly good option, but how does it do that without making +@a or @a=3 not DTRT?

[16:20] <dada> mmm

[16:20] <dada> @a=3 ?

[16:20] <broquaint> Surely it would just be: method postfix:<++>() { die "Don't do that" }, or am I missing something?

[16:20] <dada> shouldn't that be interpreted as @a=(3) ?

[16:21] <dada> ?eval @a = 3; @a

[16:21] <evalbot_7914> Error: Undeclared variable: "@a" 

[16:21] <dada> ?eval my @a = 3; @a

[16:21] <evalbot_7914> [3,] 

[16:21] <dada> ?eval my @a = (3); @a

[16:21] <evalbot_7914> [3,] 

[16:21] <dada> it's a different thing

[16:21] <dada> err, no, wait, it's not that different

[16:22] <broquaint> Calling a scalar mutator on an array shouldn't work (unless it's overloaded, of course).

[16:23] <dada> ?eval my @a = (42, 43, 44); @a += 1; @a

[16:23] <evalbot_7914> [4.0,] 

[16:24] <broquaint> Odd that it converted to a float.

[16:24] <dada> ?eval +"1"

[16:24] <evalbot_7914> 1.0 

[16:25] <broquaint> Wacky.

[16:25] <dada> numification works with floats, it seems

[16:25] <dada> anyway, the >>++ problem croaking about constant items is a bug, IMHO

[16:26] <broquaint> Yeah, I thought I'd marked that up in a test before. Maybe I never got around to it.

[16:26] <broquaint> Or figured it'd be fixed RSN.

[16:26] * eric256 tries feathers web chat...this is cool

[16:27] <eric256> ?eval (+"1").ref

[16:27] <evalbot_7914> ::Num 

[16:27] <dada> ?eval (1).ref

[16:27] <evalbot_7914> ::Int 

[16:27] <dada> ?eval (+"1.2").ref

[16:27] <evalbot_7914> ::Num 

[16:27] <theorbtwo> (+1.ref)

[16:27] <broquaint> ?eval 0.1.ref

[16:27] <evalbot_7914> ::Rat 

[16:27] <theorbtwo> ?eval (+1.ref)

[16:27] <evalbot_7914> Error: cannot cast from VType (mkType "Int") to Double (VNum) 

[16:28] <theorbtwo> ?eval (+1).ref

[16:28] <evalbot_7914> ::Int 

[16:28] <dada> ?eval (1.2).ref

[16:28] <evalbot_7914> ::Rat 

[16:28] <dada> mmm?

[16:28] <dada> ?eval +(1.2).ref

[16:28] <evalbot_7914> Error: cannot cast from VType (mkType "Rat") to Double (VNum) 

[16:28] <theorbtwo> Whew.  If the + operator changed the type on things that were already numeric, then I'd be worried.

[16:28] <eric256> pugs has a couple fo number types ;)

[16:29] <theorbtwo> Int for integers, Num for floats, Rat for rationals.

[16:29] <dada> ?eval (+(1.2)).ref

[16:29] <evalbot_7914> ::Rat 

[16:29] <dada> ?eval my $x = 1.2; $x.ref

[16:29] <evalbot_7914> ::Rat 

[16:29] <theorbtwo> ?eval (1/3.14).ref

[16:29] <evalbot_7914> ::Rat 

[16:29] * Limbic_Region would still love to have a B&D way of declaring non-mutable datatypes that would blow up with prejudice at compile time if anything tries to cast them otherwise

[16:29] <theorbtwo> Odd; I expected that to be a Num.

[16:30] <broquaint> use SML;

[16:30] <Limbic_Region> ;-)

[16:31] <broquaint> Or perhaps some fancy perl6 way: use lang :SML; # Mmm, non-backward-compatible.

[16:31] <theorbtwo> use SML sounds right to me... not that I know what SML is...

[16:31] <Limbic_Region> 99% of the time, I am not going to care that I have lost a few optimization possibilities to have flexibility in my programs

[16:32] <Limbic_Region> actually - it is probably closer to 99.95%

[16:32] <broquaint> Standard ML, the language MJD bangs on about in his Strong Typing article.

[16:32] <dada> perl6 -pedantic -wall

[16:41] <svnbot6> r7915 | kane++ |  r123@coke:  kane | 2005-11-09 17:39:55 +0100

[16:41] <svnbot6> r7915 | kane++ |  * update S22 with kane's work in progress.. starting small with metadata -> package creation

[16:41] <svnbot6> r7915 | kane++ |  * describe what we have and where we should go

[16:41] <svnbot6> r7915 | kane++ |  * note the p4 prototype2 dir where live code can be found

[16:41] <svnbot6> r7915 | kane++ |  * move all previous notes to the header:

[16:41] <svnbot6> r7915 | kane++ |      =head1 Past Rantings/Notes/Etc

[16:45] <r0nny> yo

[16:45] <xinming> hmm, who wrote the cperl-mode.el for Emacs please?

[16:46] <Limbic_Region> xinming - if it is in the Pugs repository - use blame

[16:47] <theorbtwo> Limbic, cperl-mode is for perl 5 code.

[16:48] <theorbtwo> I seem to recall it being updated by somebody on p5p lately, though.

[16:49] <autrijus> it's since adopted p6-fu

[16:49] <Limbic_Region> ok - but it appears that renormalist is responsible for putting it in the Pugs repository

[16:49] <autrijus> using a (defun cperl-looks-like-perl6)

[16:49] * Limbic_Region wins the bet

[16:49] <Limbic_Region> hey autrijus

[16:49] <autrijus> greetings. just back to .tw and the net

[16:50] <Limbic_Region> right - liz6 suggested another 24 hours, I said don't bet on it

[16:50] <autrijus> finished the book jhi gave me during the plane trip

[16:50] <Limbic_Region> xinming - Steffen "renormalist" Schwigon   (SCHWIGON) is the one that apparently put the file in the Pugs repository

[16:50] <autrijus> "Unicode Demystified" - a mere 900 pages

[16:50] <autrijus> my eyes hurt ;)

[16:50] <theorbtwo> 900!

[16:51] * theorbtwo didn't know Unicode was that Mysterous in the first place.

[16:51] <PerlJam> theorbtwo: depends on which end you're looking at it from.

[16:51] <autrijus> I learned all about Hangul layout, Arabic shaping, BiDi and vertical, Han character composition forms, diacritical stacks, etc.

[16:51] <xinming> Limbic_Region: hmm, thanks, But It seems, the file has problem working with cvs version of Emacs.

[16:52] <xinming> Limbic_Region: there will be a message while loading the file. :-/

[16:53] <Limbic_Region> *shrug*, I use a real editor - vi

[16:53] * Limbic_Region ducks

[16:53] * eric256 pictures purl six written vertiacly. hmmm

[16:53] <Limbic_Region> autrijus - I speak a bit of Hangul

[16:53] * autrijus wonders who to charge with maintaining S15

[16:53] <autrijus> (Unicode)

[16:53] <Limbic_Region> it is one of the most scientific written languages ever created

[16:54] <xinming> by the way, anyone here knows why .p6 is chosen instead of .pl6 as extension.? it seems that .pl6 be more suitable.

[16:54] <autrijus> Limbic_Region: ooh, cool. yeah, it's very computational

[16:54] <PerlJam> autrijus: clearly you are the best choice!  ;-)

[16:54] <Limbic_Region> which happened only about 500 years ago

[16:54] <PerlJam> xinming: no way!

[16:54] <autrijus> PerlJam: clearly I'm not ;) dan kogai maybe

[16:54] <xinming> PerlJam: Why?

[16:54] <Limbic_Region> the spoken language (much older) was previously written in chinese and only the very affluent could read/write

[16:54] <PerlJam> autrijus: oh, Dan would be an excellent choice.

[16:54] <eric256> xinming:  .pl, .pm, .p6  (all two letters. don't break the pattern!)

[16:55] <autrijus> xinming: I think extensions are somewhat bogus, and you can certainly call perl6 programs .pl

[16:55] <theorbtwo> Yeah, so far I've simply gotten away with ignoring non-latin-based languages, and ignoring the actually putting characters on the screen bit.  (The former being hard since I don't know any, and the later being somebody else's problem.)

[16:55] <Limbic_Region> then came the 3rd king (his older two brothers abdicated so he could take the thrown) got all the countries bad @$$ linguists/scientists together to create a written language accessible to everyone

[16:55] <xinming> eric256: well, this makes sense. :-)

[16:55] <PerlJam> xinming: .pl6 is aesthetically displeasing for a variety of reasons

[16:56] <PerlJam> xinming: besides .pl has a troubled history

[16:56] <theorbtwo> So: Unicode isn't mysterious if you ignore the hard parts.

[16:57] <eric256> although if we use pl6 we could rename the languag plsix pronounced pel-ix ;)

[16:58] <PerlJam> eric256: plsix == please icks

[16:59] * Limbic_Region plans on compiling all of his p6 programs to byte code so the .pbc extension makes sense ;-)

[17:00] <autrijus> Limbic_Region: as soon as lexpad is there we can have -CPIR.PBC :)

[17:00] <xinming> autrijus: hmm, I know, on Os which determines the file is executable is by an attribute. But On Os which isn't, the extension is used. that's why I think .pl and .pl6 is better, as some program will generate .p1 .p2 .p3 for packages(though there isn't one), hmm, IIRC, winrar use this scheme if you compress a large file and divide them into small part.

[17:00] <autrijus> or should it be -CParrot.PBC

[17:00] <autrijus> xinming: I don't think winrar uses .p1 etc... or I might be wrong

[17:01] <LimbicRegion> grrr - I hate when that happens

[17:01] <theorbtwo> No, it uses r?? -- rar and r00, r01...

[17:01] <xinming> autrijus: winrar don't use .p1 or .p2. It use r01 r02 r03...

[17:01] <autrijus> right

[17:02] <LimbicRegion> autrijus - jhorwitz showed up in #parrot today asking about the state of Pugs/Parrot interopability (specifically with objects)

[17:02] <LimbicRegion> I mentioned the "awaiting lex implementation"

[17:02] <LimbicRegion> and pointed him to your "day before parrot release" journal entry

[17:02] <xinming> hmm, why choose p6, In my opinion, It might be for the compiled byte-code.

[17:02] <autrijus> the bytecode would be .pbc for the parrot runtime

[17:03] <autrijus> LimbicRegion: oh nice

[17:03] <PerlJam> xinming: Are .pl and .pl6 files for Perl Libraries and Perl 6 Libraries respectively?

[17:03] * Limbic_Region was only joking about compiling everything to bytecode though

[17:04] <PerlJam> xinming: and what about .plx files?

[17:04] <xinming> PerlJam: .pl is stand for the "current" version of perl(maybe perl 5, maybe perl 6), and .pl6 for specified version of perl, for perl 6

[17:04] <PerlJam> the trouble with having a good memory is that you don't forget stuff ;)

[17:05] <Limbic_Region> PerlJam - the problem with having a good memory with bad recall is that you feel even more stupid that you hadn't forgot something but needed someone else point it out to you

[17:06] <geoffb> [OT] Anyone happen to know a decent free tool that can easily diagram relationships in a SQL DB?  $client is allergic to ASCII art, I'm allergic to MS Access, and the sooner this gets dealt with, the sooner I can be a Perl 6 Playa again . . . :-)

[17:06] <xinming> PerlJam: It doesn't conflict with .pl? scheme. :-)

[17:06] * Limbic_Region wonders if there is a test that can actually measure memory without the limitations of recall

[17:07] <Limbic_Region> geoffb - you lost me at "free"

[17:07] <geoffb> sigh

[17:07] <geoffb> Time to relearn PIC . . . .

[17:07] <theorbtwo> You could try dia, I hear good things about it.

[17:07] <theorbtwo> Of course, that'd be nonautomated.

[17:08] <autrijus> geoffb: SQL::Translator::Producer::GraphViz

[17:08] <Limbic_Region> geoffb - http://www.databaseanswers.com/modelling_tools.htm

[17:08] <autrijus> (iirc.)

[17:08] <Limbic_Region> google is your friend

[17:09] <geoffb> theorbtwo, no problem, it's only 10 tables, half of which are just audit versions of the other half, with absolutely trivial relationships . . . but $client just hates doing things the easy way . . . 

[17:09] <geoffb> Limbic_Region, point taken

[17:09] <geoffb> autrijus, hmmm, thanks for the idea

[17:09] * Limbic_Region didn't realize there were so many free options out there 

[17:10] * Limbic_Region wonders if he should have fought the purchase of Erwin a little harder now

[17:10] * Limbic_Region wanders off for lunch

[17:12] <stevan> hullo autrijus :)

[17:14] <autrijus> greetings stevan 

[17:21] <robkinyon> autrijus: I have a question re: single-pass interpreters (like Ruby/Perl5), if you don't mind

[17:21] <autrijus> sure

[17:22] <robkinyon> I was looking at Ruby's source to see if I could add in user-defined lexically-scoped syntax

[17:22] <robkinyon> The way it's written, the keyword and ops lists are both static and the lexer is hard-coded

[17:22] <PerlJam> perl5 is single pass?  I've always thought of it more like a 2-steps-forward-one-step-back kind of compiler  :)

[17:23] <robkinyon> Shouldn't it be possible to have a table of funcps that respond to the longest-match lexeme, with context thrown in there for good measure, calling the top funcp on the stack (to provide user-defined capabilities) ?

[17:23] <eric256> perljam...i think i heard its a two pass, but the second pass progrresses right behind the first pass.  that ameka any sense? ;)

[17:23] <robkinyon> And, that, in theory, shouldn't be too much slower than the current switch table

[17:24] <autrijus> robkinyon: I think you just described perl6 macros.

[17:24] <robkinyon> Oh

[17:24] <robkinyon> :-)

[17:24] <robkinyon> In theory, that's not too hard to implement (assuming a strong graps of C which I had and lost)

[17:25] * PerlJam gives robkinyon a strong graps so that he can apply it to C

[17:26] <robkinyon> The only part I'm finding problematic in my mental model is how to determine which lexemes are legal where. For example, within the condition of an if-statement, certain things are legal that aren't legal outside it, and vice-versa

[17:26] <robkinyon> So, one would associate a lexeme within a given context to a given funcp ... ?

[17:27] <robkinyon> Or, am I off base?

[17:27] <autrijus> robkinyon: yes. the context is called grammatical category

[17:27] <robkinyon> ahhh

[17:27] <autrijus> the lexeme is parsed using "is parsed" specification

[17:27] * robkinyon wasn't lucky enough to take compiler theory in college

[17:27] <autrijus> the funcp is the macro

[17:28] <robkinyon> "is parsed" specification?

[17:28] <autrijus> and it's not comp theory, it's perl6 :)

[17:28] <robkinyon> heh

[17:28] <robkinyon> hmm

[17:29] <autrijus> for some bit about macros, see S06 (and A06 for fun)

[17:29] <autrijus> for grammatical categories, see S12

[17:29] <robkinyon> I was thinking about hacking this into the Ruby executable

[17:29] <robkinyon> seeing as ruby's codebase is significantly easier to work with than Perl's

[17:30] <autrijus> I'm not too sure about that :)

[17:30] <autrijus> you may have better luck with yc/yarv... maybe

[17:30] <robkinyon> yc/yarv?

[17:30] <autrijus> the nextgen ruby runtime

[17:30] <autrijus> yarv is ruby's parrot

[17:31] <autrijus> see this http://www.atdot.net/yc/compile

[17:31] <autrijus> also http://www.atdot.net/yarv/

[17:31] <stevan> YARV++

[17:31] <robkinyon> I want to avoid working with Parrot until I see Parrot actually implement a full range of stuff

[17:31] <robkinyon> Plus, I like how everything in Ruby is an object, including the runtime

[17:31] <stevan> robkinyon: not parrot,.. its an unrelated project

[17:32] <robkinyon> Oh - so ruby won't be targeting parrot?

[17:32] <stevan> robkinyon: who knows,. but that is not what YARV is :)

[17:32] <stevan> robkinyon: see the inst table http://www.atdot.net/yarv/insnstbl.html

[17:33] <stevan> the first 50 are all you really need,..everything after that is an optimization

[17:33] <stevan> #26 newrange

[17:33] <stevan> autrijus: speaking of bad-ass language runtimes :)

[17:34] <stevan> autrijus: any more thoughts/work on the sendmsg stuff?

[17:34] <autrijus> stevan: you saw that I'm converting the entire PIL special forms into sendmsgs

[17:35] <stevan> autrijus: no I didnt,.. where?

[17:35] <autrijus> next step is introduce Arglist and Siglist objs

[17:35] <autrijus> to replace even more special forms

[17:35] <stevan> nice

[17:35] <stevan> did you see I added a closure::signature last night

[17:35] <autrijus> stevan: see http://use.perl.org/~autrijus/journal/27490 on Apply, Bind and Assign

[17:35] <autrijus> yeah I saw that

[17:35] <stevan> so that is supports return type checking :)

[17:36] <theorbtwo> Oh, speaking of, did you see...

[17:36] <autrijus> very nice

[17:36] <theorbtwo> ?eval my ($a, $b) = (1,2); ($a, $b)>>++;

[17:36] <evalbot_7915> Error: Can't modify constant item: VInt 1 

[17:36] <rafl> autrijus: I want to give a talk about perl6/pugs on friday. I'd like to steak something from your pugs talks. How are they licensed? Am I allowed to steal?

[17:37] <theorbtwo> AFAICS, that's getting treated as j-random-list, and not like an arglist.

[17:37] <autrijus> rafl: I hereby release it in the Microsoft Permissive License ;)

[17:38] <autrijus> rafl: or SQLite "license", or CC-by-2.0, or BSD3, or whatever

[17:38] <rafl> autrijus: I interpret that as a "Yes" :-)

[17:38] <autrijus> that interpretation would be correct.

[17:38] <sili> charge royalties

[17:40] <rafl> autrijus: I'm also happy to hear your Pugs and Haskell talks in march :-)

[17:41] <robkinyon> autrijus: Thanks

[17:42] <autrijus> rafl: :D

[17:45] <rafl> I'm still in doubt about the visual basic talk, though.

[17:47] <rafl> autrijus: Hey! Stop making new talks or updating them.. I get a mail every time! ;-)

[18:00] <autrijus> couldn't quite bring myself to journal... tomorrow then

[18:00] <autrijus> good night folks :) &

[18:00] <geoffb> good night, autrijus 

[18:09] <Simonff> Hi - can anyone help me with a Pugs compilation error?

[18:09] <geoffb> Simonff, nopaste it

[18:10] <Simonff> geoffb: http://www.rafb.net/paste/results/IY7AkL50.html

[18:11] <geoffb> Hmmm, someone got this a day or two ago . . . I don't recall the answer, but it should be in the IRC logs (see pugscode.org -> IRC logs in the left menu)

[18:14] <Simonff> That was me, on Sunday. I was told to try the SVN version, but the problem persists.

[18:14] <geoffb> oh.

[18:14] <geoffb> sorry about that

[18:14] <Simonff> np :)

[18:30] <svnbot6> r7916 | asavige++ | added golfex.t misc golf examples

[18:48] <svnbot6> r7917 | asavige++ | fixed comments in golfex.t

[19:10] <robkinyon> In #ruby-lang, someone just asked "How do I write a function that accepts a single array containing two numbers?"

[19:10] <robkinyon> I'm curious - what would the P6 signature for that look like?

[19:12] <iblech> robkinyon: my sub foo ([$first_elem, $second_elem]) {...} IIRC

[19:12] <iblech> (Which will, of course, work with both foo @array and foo $arrayref)

[19:13] <robkinyon> my sub foo ([Int $width, Int $height]) { ... } ?

[19:13] <iblech> Yep.

[19:13] <iblech> see http://dev.perl.org/perl6/doc/design/syn/S06.html, "Unpacking array parameters"

[19:14] <robkinyon> What about: my sub foo ([Int $width, Int $height], $other_param) { ... } ?

[19:14] <iblech> Works too

[19:14] <robkinyon> when is this going to be released again?

[19:14] <iblech> You can even say things like ([Int $width, Int $height = $default_height, Int ?$optional_depth])

[19:14] <theorbtwo> When it's ready.

[19:14] <iblech> :)

[19:15] <robkinyon> theorbtwo: *sighs*

[19:28] <nothingmuch> if it's an array taking two params it might as well be a tuple

[19:59] <cognominal_> this is a form pattern matching (in the haskell sens). I wonder why perl6 does not go the whole way and does not explicitely support algebraic types

[19:59] <cognominal_> s/form/form of/

[20:04] <robkinyon> Question: Will there be an analog to Ruby's :foo?

[20:04] <robkinyon> That creates a singleton symbol called :foo that can be used everywhere

[21:05] *** spinclad_ is now known as spinclad

[21:53] <mugwump> ?eval "RT"++

[21:53] <evalbot_7917> Error: Can't modify constant item: VStr "RT" 

[21:53] <mugwump> :)

[21:53] <mugwump> ?eval ($x="RT")++

[21:53] <evalbot_7917> Error: Undeclared variable: "$x" 

[21:53] <mugwump> ?eval (mr $x="RT")++

[21:53] <evalbot_7917> Error: No compatible subroutine found: "&mr" 

[21:53] <mugwump> ?eval (my $x="RT")++

[21:53] <evalbot_7917> Error: No compatible subroutine found: "&my" 

[21:53] <mugwump> ?eval my $x ="RT"; $x++

[21:53] <evalbot_7917> "RT" 

[21:54] <mugwump> There you go, obra - RT++ is still RT

[21:55] <obra> :)

[22:05] <coral> interesting. it's ok to modify an instance of a constant but not the constant itself?

[22:36] <cognominal_> ?eval  say (0..)[0]

[22:36] <evalbot_7917> Error:  unexpected "(" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[22:36] <obra> seen autrijus

[22:36] <jabbot> obra: autrijus was seen 4 hours 36 minutes 10 seconds ago

[22:36] <cognominal_> ?eval  say (qw(a) )[0]

[22:36] <evalbot_7917> Error:  unexpected "(" expecting block construct, ":", operator, ")", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[22:36] <cognominal_> say qw(a)

[22:37] <cognominal_> ?eval say qw(a)

[22:37] <evalbot_7917> a bool::true 

[22:37] <wolverian> ?eval say (0...)[0]

[22:37] <evalbot_7917> 0 bool::true 

[22:37] <wolverian> cognominal_, you missed one .

[22:37] <cognominal_> thx

[22:38] <cognominal_> sub take(Int $n, Code &f) { (1..$n).map:{ f() } }

[22:38] <cognominal_> my $compteur = coro {   for  1...  -> $i {    yield $i; } };

[22:38] <cognominal_> my @a;

[22:38] <cognominal_> say ( @a = take 10, $compteur ) while @a[0] <20;

[22:39] <cognominal_> apparently 1.. is not lazy because it loops without returning anything

[22:40] <cognominal_> if I give an finitie integer as upper bound everything is fine

[23:06] <eric256> opps...don't hit F5 in the web based IRC chat ;)

[23:34] <cognominal_> encore une de ces conneries de la nasa pour eviter une collision d'un asteroid avec la terre sur /.

[23:35] <cognominal_> ils doivent vraiment avoir du mal a justifier leur budget.

[23:49] <buu> ?eval say +(0..)[2]

[23:49] <evalbot_7917> Error:  unexpected ")" expecting term 

[23:49] <buu> Eh?

[23:50] <buu> ?eval say (0..)

[23:50] <evalbot_7917> Error:  unexpected "(" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[23:50] <buu> ?eval my @x = (0..); say @x

[23:50] <evalbot_7917> Error:  unexpected ")" expecting term 

[23:50] <buu> Wtf?

[23:50] <buu> ?eval my @x = 0..; say @x

[23:50] <evalbot_7917> Error:  unexpected ";" expecting term 

[23:50] <wolverian> ...

[23:50] <wolverian> not ..

[23:50] <buu> ?eval my @x = 0...; say @x

[23:50] <evalbot_7917> pugs: out of memory (requested 1048576 bytes) 

[23:50] <buu> heh

[23:50] <buu> So much for 'lazy'

[23:51] <buu> ?eval say (0...)[0]

[23:51] <evalbot_7917> 0 bool::true 

[23:51] <buu> ?eval say (0...)[3]

[23:51] <evalbot_7917> 3 bool::true 

[23:51] <buu> ?eval say (0...)[180]

[23:51] <evalbot_7917> 180 bool::true 

[23:51] <buu> Interesting.

[23:57] <sili> eh? what is that?

[23:57] <sili> infinity?

[23:58] <mugwump> ?eval say (0...)[-1]

[23:58] <evalbot_7917> pugs: out of memory (requested 1048576 bytes) 

[23:58] <sili> i think that means yes.

[23:58] <mugwump> should be inf!  :)

