[01:05] <ingy> hola

[01:13] <Limbic_Region> is autrijus aware of http://rt.cpan.org/NoAuth/Bugs.html?Dist=Perl6-Pugs

[01:14] <theorbtwo> Hm, IIRC, bugs against your CPAN distros email you unless you tell it not to.

[01:15] <Limbic_Region> oh - good 

[01:15] <Limbic_Region> means no one has ever reported any bugs against Tie::Hash::Sorted ;-)

[01:16] * theorbtwo isn't that sure.

[01:17] * Limbic_Region is sorry he missed today's productivity

[01:17] <Limbic_Region> I was stuck in marathon meetings from hell all day

[01:19] <theorbtwo> Uff.

[01:19] <theorbtwo> I feel for you man.

[01:27] <Schwern> Ugg, darcs repo still not compiling.

[01:27] <Schwern> Chasing modules from: src/Main.hs

[01:27] <Schwern> src/Main.hs:

[01:27] <Schwern>     Can't find module `Compile'

[01:27] <Schwern>     (use -v to see a list of the files searched for)

[01:27] <Schwern> make: *** [pugs] Error 1

[01:28] <Schwern> src/Compile* didn't get imported into the darcs repo

[01:31] <theorbtwo> Use the SVN instead?

[01:32] <Schwern> Not the point. :)

[01:43] <jabbot> pugs - 1031 - Added examples/golf/tsanta.p6 (p6 versio

[02:03] <jabbot> pugs - 1032 - reorganizing the FileSpec module, I did 

[03:48] * flw ?

[03:48] * flw /me

[04:03] <Schwern> Hey, can I be horrified by $?CALLER::CALLER::CALLER::POSITION ?

[04:04] <Schwern> both by $?CALLER::CALLER::CALLER:: and by POSITION

[04:05] <Schwern> I don't even know what $? means

[04:25] <autrijus> Schwern: $?FOO is just a variable

[04:25] <autrijus> that is usually read only

[04:26] <autrijus> $PACKAGE::?FOO does not work

[04:26] <autrijus> it's spellled as $?PACKAGE::FOO

[04:26] <autrijus> so there you have it.

[04:28] <codesnik> ew

[04:28] <autrijus> better suggestions?

[04:29] <codesnik> autrijus: i didn't considered cons and pros..

[04:29] <codesnik> but what about PACKAGE::$?FOO

[04:29] <codesnik> assuming sigil is a part of name, this scheme don't involve any magic

[04:30] <autrijus> true, it just means a little lookahead

[04:30] <autrijus> p6l? :)

[04:30] <codesnik> what?

[04:30] <jabbot> codesnik: what is supposed to happen automagically 

[04:31] <codesnik> jabbot, yeah, still.. still.. dunno, it looks more sane and logical

[04:31] <jabbot> codesnik: Please go on.

[04:32] <codesnik> we either have sigils as some kind of data-type-purpose-whatever mark

[04:32] <codesnik> either as part of name, just a convention

[04:33] <autrijus> p6l means, "bring this suggestion to perl6-language" ? :)

[04:33] <codesnik> autrijus: already did

[04:33] <autrijus> k.

[04:33] <codesnik> two or three months ago, no respond:)

[04:34] <autrijus> that probably means it was considered even longer before

[04:34] <autrijus> and was resolved to not do that.

[04:34] * autrijus was not around for long, so can't remember any of this

[04:35] * codesnik considers all such desision as some rudimentary perl5 habit

[04:35] <luqui> about PACKAGE::$?FOO... we thought about that at one of the design meetings

[04:35] <luqui> and agreed that it was more consistent

[04:35] <luqui> but decided against it

[04:35] <codesnik> why?

[04:35] <luqui> for linguistic purposes

[04:35] <codesnik> oh my

[04:36] <autrijus> luqui: elaborate?

[04:36] <luqui> Sir Autrijus Tang, not Autrijus sir tang

[04:37] <luqui> It's always sigil package name, even though the name includes the sigil in the symbol table...

[04:37] <luqui> partly historical, partly because we want "this is a variable" out front where it's easy to see

[04:37] <autrijus> so then secondary sigils just follows

[04:37] <autrijus> for consistency's sake.

[04:37] <luqui> yeah, $Foo::?BAR would be very strange

[04:38] <luqui> (but then again, so would everything else we've been discussing)

[04:38] <autrijus> perl 6 is very strange.

[04:38] <Alias_> Dangerously strange at times

[04:38] <Alias_> But then if it means we can access CPAN from python, I'm totally cool with it

[04:39] <autrijus> Alias_: that day may be closer than you thought :)

[04:39] <codesnik> one who learn perl6 would need to make his brain inside out. that's good, when it for sense, but in *that* case, language need to make it inside out again

[04:39] <autrijus> Alias_: you saw --runparrot?

[04:39] <Alias_> I have far more allegiances to CPAN than to perl itself

[04:39] <Alias_> Although I really really like perl

[04:39] <autrijus> hear hear.

[04:39] <autrijus> <- won't be using perl if not for cpan

[04:39] <Alias_> It would just be a pity to throw away so much code

[04:40] <luqui> useful, well modularized code.

[04:40] <autrijus> that occasionally even works

[04:40] <Alias_> well testing, well documented... etc etc

[04:40] <Alias_> tested

[04:40] <Alias_> ... for the most part

[04:40] <Alias_> But then I imagine all of the top 10 CPAN people are in a similar position

[04:41] <luqui> (isn't autrijus a top 10?)

[04:41] <Alias_> autrijus is 1.

[04:41] <luqui> oh, cool

[04:41] * Alias_ is 4-6 depending on the calculation method

[04:42] * luqui steps into the background for his game design call

[04:42] <Alias_> But all of the top 10 are now at 50 packages or higher

[04:43] <obra> game design?

[04:44] <autrijus> mm, which means we account for 20% of the module list

[04:45] <codesnik> you know what. how python people could access all this sigilled stuff?

[04:46] <codesnik> or whatever else parrot based language

[04:46] <autrijus> they do it by using the sigilless interface

[04:46] <autrijus> so scalars are called without "$"

[04:46] <autrijus> arrays has this a_ prefix

[04:46] <autrijus> or something

[04:47] * codesnik feel some little unidentified doubts

[04:50] <cm> the doubt starts with p.. and ends in ..arrot?

[04:51] <autrijus> pizza_jar_cannot_rot?

[04:51] <autrijus> err, doesn't end in arrot.

[04:51] <cm> yeah, you lose :)

[04:51] <autrijus> pizzajarrot then.

[04:51] <cm> :|

[04:51] <cm> you win.

[04:52] <ayrnieu> pear-soup-with-carrots

[04:52] <autrijus> "with parrot, we all win!"

[04:52] <codesnik> you win and i'll have a pizza, all happy

[04:53] <autrijus> yay.

[04:54] <cm> donut

[04:55] <codesnik> i have strange feeling. like if i should go to psychiatrist, sit on sofa, and tell him all my perl6 expectations.

[04:56] <cm> sounds like fun

[05:13] <codesnik> lique: a bit late comment, but "sir autrijus tang" isn't a good example.

[05:14] <codesnik> we have: a name, a sigil, a package

[05:15] <codesnik> they could be mapped: name=>name, of course; package=>surname, place of birth(which is the same, basically); sigil is the most strange part. 

[05:15] <codesnik> proffession?

[05:18] <autrijus> Ms., Mr., Prof., 

[05:18] <autrijus> etc.

[05:18] <codesnik> if we going to have linguistic parallels, then, it could look like:   Var Module, the $; or: $Var from Module

[05:18] <codesnik> i think it isn't something we should look for linguistic parallels,

[05:19] <autrijus> the idea I think is for hinters to occur first.

[05:19] <autrijus> @?PKG::foo

[05:19] <autrijus> the @ is context hinter

[05:19] <autrijus> ? is scope/effect hinter

[05:19] <autrijus> those things are more "important at first glance" than the package name.

[05:20] <codesnik> it was hinter. now it's more the part of name

[05:20] <codesnik> but..

[05:20] <autrijus> it was the part of name that is the hinter

[05:23] <codesnik> if $location eq 'PKG::'

[05:23] <codesnik> how we could write @?PKG::foo 

[05:39] <Schwern> For the record, I wasn't horrified by $?  I was horrified by the CALLER::CALLER::CALLER::POSITION part

[05:41] <obra> sure. the previous version of that code actually propagated CALLER::POSITION all the way down

[05:41] <obra> which was really bloody ugly before we had named params

[05:41] <obra> it made the whole API insanely baroque

[05:42] <codesnik> would something like $?::(caller(3))::POSITION work in perl6?

[05:43] <jabbot> pugs - 1033 - Added my name

[05:44] <obra> for the record, I agree that a hardcoded depth there is the wrong thing longterm

[05:48] <Alias_> CALLER::CALLER::et al is stupud

[05:51] * ayrnieu puzzles at: my @a = "hello" ~~ rx:perl5/[el]/; @a[0] == @a # bool::true

[05:52] * ayrnieu plans to reread everything.

[05:53] <ayrnieu> on the bright side, @a<0> crashes pugs =)

[05:56] <Schwern> Alias:  Exxactly.

[05:56] <Schwern> I'd expect caller(3){POSITION} or something

[05:56] <gaal> ayrnieu: what are you getting?

[05:58] <ayrnieu> maybe not exact: Fail: cannot cast into [VPair]: VArray (MkArray [VInt 1])

[05:58] <gaal> that's not a crash, that's a syntax error :)

[05:58] <ayrnieu> with "(\n" output.

[05:58] <ayrnieu> that is also a crash, gaal =)

[06:00] <gaal> to your thinking, why is this syntactic and what should it mean?

[06:01] <ayrnieu> I don't think you are following.  Consider: http://sial.org/pbot/8517

[06:02] <ayrnieu> I realize that what crashes pugs happens to be a syntax error.

[06:02] <gaal> ah, *that* is a crash. :)

[06:03] <gaal> ./pugs -e 'my @a=(1); eval "@a<0>.say"; "still alive".say'

[06:04] <gaal> wanna add a test to t/pugsbugs?

[06:04] <ayrnieu> Sure.

[06:05] <Khisanth> ayrnieu: so you finally got svk working?

[06:05] <gaal> thanks!

[06:05] <ayrnieu> Khisanth - no -- I'm just using svn.

[06:13] <jabbot> pugs - 1034 - * Sample inline SHA1 module

[06:16] <gaal> !

[06:16] <ayrnieu> ?

[06:17] <gaal> though now that inlining from one language to another is becomming common, does the distinction between still src/ and lib/ make sense?

[06:17] <gaal> ayrnieu, I was referring to ++autrijus' latest commit.

[06:17] <autrijus> rehi lambdacamels

[06:18] <autrijus> gaal: for C we're still going to have include/ etc

[06:18] <cm> /\ /\ /o+_

[06:18] <autrijus> gaal: I think it makes sense to respect each language's culture

[06:18] <autrijus> gaal: if you don't want src/ just put all haskell code in DATA block

[06:18] <autrijus> =begin DATA sha1

[06:18] <autrijus> ...haskell code

[06:18] <autrijus> =cut

[06:18] <autrijus> and

[06:18] <Alias_> ugh

[06:18] <autrijus> inline :Haskell(%=DATA<sha1>)

[06:18] <gaal> sure, yes; if you're taking an existing module and "just" giving bindings for it

[06:18] <Alias_> actually... not so bad as putting shiteloads of actual data in it

[06:19] <Alias_> and far better than encoding data as perl

[06:19] <autrijus> yes.

[06:19] <autrijus> I think it's a legitimate use.

[06:19] <autrijus> speaking as a GW-BASIC refugee that remembers DATA

[06:19] <gaal> what if you have a projectof your own, want to write some of it in X and some in Y

[06:20] * ayrnieu finally realizes that Test.pm's lives_ok is listed under FUTURE PLANS.

[06:21] <gaal> ayrnieu: heh. though it would not have helped you anyway in this case.

[06:21] <autrijus> so, I hope the inline primitive is ok with you folks.

[06:22] <ayrnieu> oh, I just need eval =)

[06:22] <autrijus> (ingy just arrived a few hours ago and we are hacking this)

[06:22] <gaal> tres cool, autrijus

[06:22] <autrijus> what does tres mean? :)

[06:22] <obra> very

[06:22] <ayrnieu> In French.

[06:23] <gaal> ayrnieu, the test will pass when the hard parsefial is fixed, but until then you'll always get a crash

[06:23] <autrijus> ah.

[06:23] <obra> "tres chich"

[06:23] <obra> chic

[06:23] <gaal> not pronounced TRAY. :-p

[06:25] <gaal> add syntax to have the builtin slurp from a file maybe?

[06:25] <gaal> ....or a url? :)

[06:26] <autrijus> slurp() already does a file

[06:26] <autrijus> no?

[06:26] <autrijus> pugs -e 'say slurp "README"'

[06:26] <autrijus> worksforme.

[06:26] <autrijus> you are free to add url support in Prim.hs.

[06:26] <gaal> sure--i meant for inline

[06:27] <autrijus> what's wrong with "inline :Haskell(=<file>)" ?

[06:27] <autrijus> I like the consistency.

[06:27] <autrijus> i.e. not doing an -e test on the parameter string

[06:28] <autrijus> working on Foreign.hs now.

[06:28] <autrijus> To the Sea, to the Sea! The white gulls are crying,

[06:28] <autrijus> The wind is blowing, and the white foam is flying.

[06:28] <autrijus> West, west away, the round sun is falling.

[06:28] <autrijus> Grey ship, grey ship, do you hear them calling?

[06:28] <gaal> hmm, yes, that's just dandy

[06:31] <gaal> (i'd forgotten =<file> worked on a filename too, silly me)

[06:34] <ayrnieu> OK, would this work for a test?  http://sial.org/pbot/8519

[06:35] <autrijus> pugs is not always in path

[06:35] <autrijus> neither is that test always interpreted

[06:35] <autrijus> what does S02 say

[06:35] <autrijus> about $^X?

[06:35] <autrijus> hrm didn't say anything about it.

[06:36] <autrijus> what should happen is for me to always make parsefail trappable.

[06:39] <ayrnieu> ah, I see that you say what to do in t/README

[06:45] <autrijus> I'll call it External.hs instead of Foreign.hs

[06:46] <autrijus> because haskell already has a Foreign call interface and I don't want to confuse myself :)

[06:51] <ayrnieu> This should work: http://sial.org/pbot/8520

[06:52] <ayrnieu> seeing as eval currently returns undef on syntax errors, as in: eval "1>>>3"

[06:53] <gaal> ayrnieu++ # test case

[06:53] <gaal> better add a description on the ok line too

[06:53] <jabbot> pugs - 1036 - SHA1 should be ignored until it works

[06:53] <jabbot> pugs - 1035 - * External.hs landed.

[06:54] <gaal> though, hm, in this case i can't think of a good one :)

[06:54] <ayrnieu> http://sial.org/pbot/8521

[06:54] <autrijus> ayrnieu: add yourself to AUTHORS.

[06:55] <gaal> i meant in the ok() itself as the second parameter. but when this is in a file of its own it's pretty self-documenting.

[06:56] * gaal has to go now

[06:56] <gaal> see 'ya.

[06:56] <autrijus> see ya!

[06:56] <ayrnieu> thanks for the help, gaal =)

[06:56] <gaal> thank you for the bug report :)

[06:57] <gaal> &

[06:59] <ayrnieu> autrijus - what's my password, to commit the test and the AUTHORS change?

[07:00] <autrijus> ayrnieu: your email?

[07:00] <autrijus> (so I can make you a committer)

[07:00] <ayrnieu> [email@hidden.address]
[07:02] <autrijus> check your mail

[07:03] <crysflame> morning, autrijus

[07:03] <obra> morning? it's 3pm

[07:04] <crysflame> aie

[07:04] * crysflame learns

[07:04] <crysflame> +8?

[07:05] <ayrnieu> OK, changes commited =)

[07:06] <masak> the internet time is @337 .beats :)

[07:06] <masak> http://www.timeanddate.com/worldclock/

[07:07] <ayrnieu> ah, good to know that 'internet time' still exists.

[07:07] <masak> i have it on my watch

[07:07] <masak> never used it for anything :)

[07:07] <masak> except pissing people off

[07:08] <masak> "what time is it?" "uh, 338"

[07:23] <jabbot> pugs - 1038 - added self

[07:23] <jabbot> pugs - 1037 - added parsefail test

[07:24] <crysflame> masak++ # heh

[07:48] <nothingmuch> morning

[07:51] <masak> morning? it's @367 :)

[07:51] <nothingmuch> internet time is soooo 1999

[07:51] <nothingmuch> ;-)

[07:52] * nothingmuch is going to do currying, and then see what he can do about those 100 subtests

[07:52] * masak just realized that his watch actually is from 1999 ;)

[08:20] *** Grrrr is now known as Gruber

[08:36] * nothingmuch thinks he got it, and made bindParams much more readable in the process

[08:37] <nothingmuch> a funny side effect is that given:

[08:37] <nothingmuch> sub foo ($x, *@slurp);

[08:38] <nothingmuch> sorry

[08:38] <nothingmuch> sub foo ($x, +%slurp)

[08:38] <nothingmuch> foo(x => "1", x => "2")

[08:38] <nothingmuch> will yield "1" in $x, and x => "2" in %slurp

[08:39] *** cnhackTNT is now known as cnhackTNT|away

[08:40] <nothingmuch> we have embedded p5? my god...

[08:40] <autrijus> we will also have embedded haskell in another hour.

[08:41] <autrijus> and embedded C.

[08:41] <nothingmuch> ooh

[08:41] <autrijus> see ext/SHA1/

[08:41] <autrijus> pugs is suddenly very socialable with other languages.

[08:41] <nothingmuch> my time is very limited

[08:41] <nothingmuch> so i will err, delay

[08:41] <autrijus> sure!

[08:43] <nothingmuch> haskell's type system is soo good

[08:43] <nothingmuch> the day before

[08:43] <nothingmuch> yesterday i thought it was sadistic

[08:43] <nothingmuch> but it's becoming so much more coherent now

[08:44] <nothingmuch> not yesterday, yesterday i did nothing at all

[08:44] <obra> "perhaps the pugs needs to be fixed"

[08:44] <nothingmuch> autrijus: how tight is p5 integration?

[08:44] <autrijus> nothingmuch: not very tight at all

[08:45] <autrijus> it just does simple eval() that preserves context

[08:45] <autrijus> no value transformation yet

[08:45] <nothingmuch> do unresolved calls go to p5? i bet the other way around is much harder

[08:45] <nothingmuch> ah

[08:45] <autrijus> eval_perl5()

[08:45] <autrijus> is the only bridge right now

[08:45] <autrijus> once we have value casting then we have Inline::GHC.

[08:45] <autrijus> and Inline::Pugs.

[08:45] <autrijus> imagine the sickitude!

[08:45] <nothingmuch> i would love Inline::GHC

[08:45] <autrijus> sure. it is actually not that hard

[08:45] <nothingmuch> i think haskell will be very very useful for me, once i "get it"

[08:45] <autrijus> just not on my priority list

[08:46] <autrijus> if you have a larger window of time we may pair on it

[08:46] <autrijus> but not this week

[08:46] * nothingmuch doesn't know Inline::, or C (well, that is), or p5 guts, or ghc guts

[08:46] <nothingmuch> so i doubt i

[08:46] <nothingmuch> i'm useful =)

[08:46] <nothingmuch> oh compile already! i want to see if it's worked!

[08:47] * nothingmuch rereads the sentance, decides that it's wrong, and then changes his mind again.

[08:47] <autrijus> eh.?

[08:47] <nothingmuch> it's worked

[08:47] <nothingmuch> it has worked

[08:47] <nothingmuch> but i thought it was wrong for a second

[08:48] <nothingmuch> well, this is an improvement

[08:49] <nothingmuch> pairs not working yet?

[08:49] <autrijus> not working how what?

[08:50] <nothingmuch> in params

[08:50] <autrijus> I think it works and is parsed for nameds

[08:50] <nothingmuch> hmm

[08:50] <autrijus> but it gets passed in not as .val

[08:50] <autrijus> but as a pair

[08:50] <autrijus> which is wrong and caused obra problem

[08:50] <autrijus> so seeing you're already there, maybe you can attempt a fix

[08:50] <autrijus> nothingmuch++ # in advance

[08:50] <nothingmuch> well, passing in as a pair makes sense to me

[08:50] <nothingmuch> how was it a problem?

[08:51] <nothingmuch> and how will a val look in a pair?

[08:51] <autrijus> sub foo ($bar) { say $bar }

[08:51] <autrijus> foo( bar => 1 ); # needs to print 1, not "bar1"

[08:51] <nothingmuch> right

[08:51] <autrijus> you can get a val out from a pair obj by doing 

[08:51] <nothingmuch> bindSomeParams will get a pair?

[08:51] <autrijus> snd . vCast

[08:51] <nothingmuch> i can unwrap that

[08:51] <autrijus> yeah

[08:51] <nothingmuch> ok

[08:51] <nothingmuch> what is unPair?

[08:52] <autrijus> it matches the args

[08:52] <autrijus> to see if they are pairs

[08:52] <nothingmuch> map unPair foo

[08:52] <autrijus> and if yes, returns k/v pairs

[08:52] <nothingmuch> k/v pairs? eh?

[08:54] <nothingmuch> hold on, i need to grok bindNames

[08:55] <nothingmuch> i don't understand this: (bound, exps') = foldr doBind ([], []) (map unPair exps)

[08:55] <autrijus> ok

[08:55] <nothingmuch> mpa unPair exps

[08:55] <nothingmuch> what does that return?

[08:55] <autrijus> it returns a list of k/v

[08:55] <nothingmuch> a list of....

[08:55] <nothingmuch> which is?

[08:55] <nothingmuch> [ key, val, key, val ]?

[08:55] <autrijus> unPair :: Exp -> (String, Exp)

[08:55] <autrijus> so

[08:55] <nothingmuch> oh

[08:56] <autrijus> [(k, v), (k, v)]

[08:56] <nothingmuch> it returns a list of haskell pairs

[08:56] <nothingmuch> ok, that's good

[08:56] <autrijus> yes.

[08:56] <autrijus> now doBind takes that

[08:56] <autrijus> and process each in turn

[08:56] <autrijus> starting from ([],[])

[08:56] <autrijus> and fill in things.

[08:56] <autrijus> (assuming you grok folr)

[08:56] <autrijus> foldr

[08:56] <nothingmuch> i sort of do

[08:57] <autrijus> foldr replaces the final [] of a list with an init value

[08:57] <autrijus> in this case ([],[])

[08:57] <autrijus> and replaces all the intermediate : of a list with a function

[08:57] <autrijus> in this case doBind

[08:57] <autrijus> and evaluate the expression.

[08:57] <nothingmuch> yah

[08:58] <nothingmuch> so doBind is getting a pair of empty arrays, and a value of the list

[08:58] <nothingmuch> and then it's getting on the next iteration, the value it returned last time

[08:58] <nothingmuch> and the next value from the list

[08:59] <nothingmuch> of haskell kv pairs

[08:59] <nothingmuch> ok, and doBind supposedly finds a param whose name is the fst of that pair

[08:59] <nothingmuch> and then makes a new pair, (foundParam, snd pair)

[08:59] <nothingmuch> right?

[08:59] <nothingmuch> and accumilates things it can't bind in exps

[09:00] <nothingmuch> Just prm <- find ((name ==) . tail . paramName) prms

[09:00] <nothingmuch> will run the succeeding line only if there is such a param

[09:00] <nothingmuch> which will prepend (prm, exp) : bound

[09:00] <nothingmuch> read : as to

[09:00] <nothingmuch> and if find has a Nothing

[09:01] <nothingmuch> then exp is tacked on to exps instead

[09:01] <nothingmuch> right?

[09:01] <nothingmuch> i think unPair is called too late

[09:01] <nothingmuch> it should be done in the begining of bindSomeParams

[09:05] <nothingmuch> ah

[09:05] <nothingmuch> not true, because isPair is isVPair, actually

[09:05] <nothingmuch> autrijus: i don't see where the problem is

[09:13] <nothingmuch> oh crap, i see what's going on

[09:13] <nothingmuch> sub foo ($x, $y);

[09:13] <nothingmuch> foo(y => 4);

[09:13] <nothingmuch> $x = y => 5;

[09:13] <nothingmuch> i have no clue where to stick a trace

[09:14] <nothingmuch> oh! i think i see

[09:14] <nothingmuch> (name ==)

[09:14] <nothingmuch> because it's a perl pair

[09:14] <nothingmuch> then name won't really be a string

[09:14] <nothingmuch> it's an exp

[09:14] <nothingmuch> i think

[09:14] <nothingmuch> so that never is true

[09:14] <nothingmuch> unless it's supposed to generate a type error

[09:16] <nothingmuch> args: [App "&infix:=>" [Syn "cxt" [Val (VStr "Str"),App "&infix:~" [Val (VStr "x"),Val (VStr "")] []],Val (VInt 1)] []]

[09:16] <nothingmuch> this will attempt to bind x => 1

[09:16] <nothingmuch> eventually unPair should yield (k, v), right?

[09:16] <nothingmuch> which in this case applies infix ~ to [val (VStr "x") ... ]

[09:16] <nothingmuch> and applie s the context to that

[09:17] <nothingmuch> and applies infix => to "x", and Val (VInt 1)

[09:17] <nothingmuch> and unPair's 'vCast k' is supposed to make all that happen, right?

[09:17] <nothingmuch> why isn't it?

[09:18] <nothingmuch> i get, in the resulting binding:

[09:18] <nothingmuch> [(Param {...paramName = "$x"...}, App "&infix:=>" [Syn "cxt" [Val (VStr "Str"),App "&infix:~" [Val (VStr "x"),Val (VStr "")] []],Val (VInt 1)] []), ...]

[09:19] <nothingmuch> which means that the pair is not evaluated at all

[09:23] <jabbot> pugs - 1039 - supply default values only when vinalizi

[09:28] <nothingmuch> s/vinalizing/finalizing/... sorry!

[09:33] <jabbot> pugs - 1040 - * sample makefile

[09:37] <Juerd> "Larry          

[09:37] <Juerd>     hemmed for a bit, but decided to stick with true in the end   "

[09:37] <Juerd> That's not the way I read the true thread

[09:39] <nothingmuch> me neither

[09:40] <Schwern> That's not the way I read it either.  I didn't read it.

[09:41] <Schwern> It would be more like " "

[09:41] <rgs> hey Schwern

[09:42] <Schwern> Hey

[09:43] <jabbot> pugs - 1041 - * generated binding file

[09:48] <firzen> Does the bin package ok now?

[09:53] <firzen> Is the win32 bin package ok now?

[09:54] <lumi_> Hi, does anybody else have insane problems with t/magicals/caller_pos.t?

[09:59] <nothingmuch> lumi_: insane?

[09:59] <nothingmuch> i sort of grok that code, i might be able to help

[09:59] <lumi_> Well

[09:59] <clkao> nnunley!

[10:00] <lumi_> The tests never finish, because that one just takes all the memory it can get

[10:00] <nothingmuch> ah

[10:00] <nothingmuch> i'll check

[10:00] <nothingmuch> shit! i comitted traces

[10:00] <lumi_> I saw it grow to 600m before I killed it, I don't think it was planning on stopping

[10:01] <nothingmuch> i'll try to figure out what's going on

[10:01] <nothingmuch> latest R?

[10:01] <nnunley> clkao:

[10:02] <lumi_> Yes

[10:02] <nnunley> clkao:  I made it here!

[10:02] <clkao> nnunley: are you being treated well?

[10:02] <nnunley> clkao: Only minor hazing. :)

[10:02] <lumi_> Looks like it dies in 2nd test

[10:03] <jabbot> pugs - 1042 - Remove calls to trace (sorry everyone!)

[10:04] <nnunley> I leave for a couple of weeks and miss the bootstrap phase of pugs, almost 

[10:04] <lumi_> The indirect interpolation, whatever that means, works

[10:05] <Schwern> Norm!

[10:06] <nnunley> Schwern!

[10:17] <lumi_> IT seems to have stopped doing that, could it have been the traces?

[10:17] <lumi_> That's passing strange

[10:23] <autrijus> nothingmuch: it's broken yes.

[10:23] <autrijus> unPair/isPair that is.

[10:23] <jabbot> pugs - 1043 - * require_haskell() landed. dependency a

[10:26] <autrijus> so, eval_haskell() will come next.

[10:26] <autrijus> then a GHC.pir.

[10:26] <autrijus> which completes the runtime side of bootstrapping.

[10:30] <Juerd> autrijus: How would you describe the outcome of the s/true/better name/ thread?

[10:30] <autrijus> Juerd: the outcome is that it seems that true() is a better name.

[10:30] <Juerd> autrijus: The summarizer thinks larry stuck with true, while my interpretation is that we're having so now.

[10:30] <Juerd> Oh.

[10:30] <Juerd> Weird.

[10:30] <autrijus> and pugs is back to true().

[10:30] <autrijus> (6.0.12)

[10:30] <Juerd> I think I missed some messages then

[10:30] <autrijus> that may be the case

[10:31] <Juerd> What were the reasons for true?

[10:31] <autrijus> I don't really want to think about it :)

[10:31] <Juerd> I see

[10:31] <Juerd> I'll try google groups tonight

[10:32] <autrijus> nod

[10:33] <jabbot> pugs - 1044 - local Makefile.PL

[10:34] <autrijus> hi Jonathan__!

[10:34] <autrijus> your binary build of pugs seems to be borken

[10:35] <Jonathan__> Hi

[10:36] <Jonathan__> Yeah, it seems that the build overall is broken on Win32 at the moment.

[10:36] <autrijus> uh?

[10:36] <autrijus> it works for me.

[10:36] <luqui> *bling* (that's an appearing noise)

[10:37] <pasteling> "mj" at 147.229.221.107 pasted "WinXP, nmake failed" (33 lines, 1.5K) at http://sial.org/pbot/8528

[10:37] <Jonathan__> Just did latest checkout and...

[10:37] <Jonathan__> Could not find module `Internals.RuntimeLoader':

[10:38] <autrijus> oops, forgot to add

[10:38] <autrijus> fixed.

[10:38] <autrijus> try again?

[10:38] <autrijus> r1046

[10:39] <mj> seems ok

[10:39] <autrijus> cool!

[10:39] <autrijus> I'll bbiab.

[10:39] <Jonathan__> Yup, it's building now. Working build should hit my site in a minute or so. :)

[10:40] <autrijus> woot.

[10:41] <luqui> is it just me, or was that pugsbugs 'foo\' test script very broken?

[10:42] <luqui> and is it still...

[10:43] <jabbot> pugs - 1046 - * add missing module

[10:43] <jabbot> pugs - 1045 - * add require -version support stub

[10:44] <mj> nmake done, some warnings: In function `svLJ_entry':  ghc3624.hc:829: warning: implicit declaration of function `initLinker' . . .

[10:44] <nothingmuch> autrijus: so which is broken?

[10:44] <nothingmuch> isPair? or unPair/

[10:45] <nothingmuch> and how?

[10:46] <autrijus> I'm not quite sure :-/

[10:46] <nothingmuch> how would I go about testing it?

[10:46] <nothingmuch> i could ghci -Isrc src/Bind.hs, but what would I feed them?

[10:47] <luqui> I deleted pugsbugs/string_escaping.t .  It was testing incorrect semantics (and the correct ones are already tested plenty)

[10:48] <autrijus> luqui: thanks

[10:48] <autrijus> mj: known problem, don't worry 'bout it

[10:48] <autrijus> nothingmuch: just "svn up", "make ghci"

[10:48] <autrijus> and type 

[10:49] <autrijus> eval "sub foo (+$x) { say $x }  foo(x => 1)"

[10:49] <nothingmuch> i could take the outputs of Show

[10:49] <autrijus> that will then output "x1"

[10:49] <autrijus> this is wrong

[10:49] <autrijus> we want 1

[10:49] <autrijus> that's it.

[10:49] <nothingmuch> yeah, i know

[10:49] <nothingmuch> i broke it down further

[10:49] <autrijus> good.

[10:49] <nothingmuch> but it's hard for me to say whether the VCast in unPair is not evaling somehow

[10:50] <nothingmuch> or if isPair is broken, and thus unPair is not called at all

[10:50] <nothingmuch> but it's one of those problems

[10:50] <autrijus> just trace and see? :-/

[10:50] <autrijus> <- needs to work on $real_work right now

[10:50] <nothingmuch> i'll try

[10:50] <nothingmuch> but it's a bit hard for me to trace

[10:50] <nothingmuch> it being haskell and all that

[10:50] <autrijus> sorry for not being very helpful

[10:51] <autrijus> trace() is your friend

[10:51] <autrijus> we have it imported in Internal.hs

[10:53] <jabbot> pugs - 1048 - * make ghci

[10:53] <jabbot> pugs - 1047 - Removed bogus bug test.

[10:55] <nothingmuch> ook, i introduced some crap

[10:55] <nothingmuch> slrupy bindings should be appended

[10:55] <nothingmuch> smoetimes they appear twice

[10:55] * nothingmuch will fix

[11:01] <tomyan> autrijus: you probably know this, but pugs now runs fine on linux on sparc

[11:02] <nothingmuch> how do i "do" an exp?

[11:03] <autrijus> tomyan: woot.

[11:03] <autrijus> nothingmuch: do?

[11:03] <tomyan> yeah

[11:03] <jabbot> autrijus: do is pretty magic, yes

[11:03] <autrijus> val <- evalExp exp

[11:03] <nothingmuch> errm

[11:03] <nothingmuch> that's my last guess at a solution

[11:04] <nothingmuch> ok

[11:04] <nothingmuch> unPair (App "&infix:=>" k exp) = (vCast (castV k), exp)

[11:04] <nothingmuch> how do i DWIM?

[11:04] <nothingmuch> do i unpair () = do

[11:04] <autrijus> what do you want k to become?

[11:04] <nothingmuch> a String

[11:04] <autrijus> you can also make unpair monadic.

[11:04] <nothingmuch> should unpair be evalExp'ing?

[11:04] <autrijus> str <- fromVal k

[11:04] <autrijus> err.

[11:04] <nothingmuch> i think this is because of that fix

[11:05] <autrijus> let me think real quickly

[11:05] <autrijus> yes.

[11:05] <nothingmuch> that autoquotes lefthandside

[11:05] <autrijus> it should do that.

[11:05] <autrijus> it should evalExp k.

[11:05] <nothingmuch> unPair (App "&infix:=>" k exp) = do

[11:05] <nothingmuch>     kVal <- evalExp k

[11:05] <nothingmuch>     return (vCast kVal, exp)

[11:05] <nothingmuch> right?

[11:06] <nothingmuch> do i just 'import Eval' at the top?

[11:06] <nothingmuch> Module imports form a cycle for modules:

[11:06] <nothingmuch>         Eval Bind

[11:06] <nothingmuch> =/

[11:07] <nothingmuch> does Bind.hs need to be merged with Eval.hs?

[11:08] <nothingmuch> ?

[11:09] <autrijus> er. uhm.

[11:12] <nothingmuch> #haskell people say i'll need to merge

[11:12] <nothingmuch> oh, shapr is here, he said that =)

[11:12] <autrijus> no.

[11:12] <autrijus> you can do this instead

[11:12] <autrijus> move evalExp into AST.

[11:12] <nothingmuch> oh my

[11:12] <autrijus> that's the correct course of action.

[11:13] <autrijus> just move it from Eval to AST.

[11:13] <nothingmuch>  ok, why not =)

[11:13] <autrijus> it's nothing much =)

[11:13] <nothingmuch> it's bound to do less damage than i already have ;-)

[11:13] <shapr> punny

[11:14] <nothingmuch> putting it just above findSym

[11:14] <nothingmuch> it looks err, like a logical place

[11:14] * nothingmuch noticed he is very hesitent

[11:14] <nothingmuch> 'err' and 'uhm' all the time

[11:16] <shapr> aha - http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion

[11:17] <shapr> yup, just as troublesome as I remember.

[11:21] <nothingmuch> hmm

[11:21] <nothingmuch>         Inferred type: Eval Val

[11:21] <nothingmuch> how do i make that into a Val?

[11:22] <shapr> eval it?

[11:22] * shapr is guessing

[11:22] <nothingmuch> that's after i've evalExp'ed it =)

[11:31] *** shapr is now known as TheShapr

[11:34] *** TheShapr is now known as shapr

[11:39] <mj> win32 semm ok - r1048, WinXP, nmake, ActivePerl - 100/2809 subtests failed, 96.44% okay.

[11:40] <nothingmuch> 100 subtests is the correct number, IIRC

[11:43] <jabbot> pugs - 1049 -  r15205@kybristedi:  gugod | 2005-03-23 

[11:46] <gugod> stevan: about ghc version discussed early , turns out it was my fault. I didn't noticed that I have some local modification which make compilation failed. ghc 6.4 compiled fine

[11:49] <nothingmuch> what is the syntax i am trying to get?

[11:49] <nothingmuch> unPair pair@(App "&infix:=>" _ _) = do

[11:49] <nothingmuch> i want pair to be that type

[11:53] <shapr> Oh that was the SchwernLikesDarcs guy.

[11:53] <nothingmuch> yup

[11:53] <nothingmuch> he's really a perl guy

[11:53] *** cnhackTNT|away is now known as cnhackTNT

[11:54] <nothingmuch> http://www.perl.org/yapc/2002/movies/themovie/

[11:54] <nothingmuch> he's the guy talking about farmers

[12:25] <kungfuftr> is there a way to get a list of todo tests?

[12:25] <nothingmuch> grep -r todo_ t/

[12:26] <kungfuftr> =0)

[12:27] <kungfuftr> well... grep -r todo_ t/ | grep -v .svn

[12:27] <kungfuftr> 2113 apparently

[12:28] <nothingmuch> =)

[12:29] <shapr> kungfuftr: http://www.scannedinavian.org/~shae/kung.fu.jpg

[12:29] <nothingmuch> wtf?!

[12:30] <shapr> sorry, completely off-topic

[12:30] <nothingmuch> no, i'm really curious =)

[12:30] <nothingmuch> do you know the origin of that pic?

[12:30] <shapr> nope

[12:30] <nothingmuch> it just doesn't make sense

[12:30] <nothingmuch> oh well

[12:31] <shapr> looks cute, I dunno if it's gimp'd or not.

[12:33] <kungfuftr> anyone know if mugwump made it to tapei yet?

[12:34] <nothingmuch> gah!

[12:34] <nothingmuch> how do you make an anything out of an Eval Val?

[13:12] <elmex> oi

[13:13] <jabbot> pugs - 1051 - examples.t works now.

[13:13] <jabbot> pugs - 1050 - Added some new tests.

[13:18] <Limbic_Region> iblech - you about?

[13:20] <iblech> Limbic_Region: ? (don't understand)

[13:21] <Limbic_Region> oh - was just asking if you are around

[13:21] <iblech> Limbic_Region: ah, yes, I am :)

[13:22] <Limbic_Region> japhy recently was on a quest to pick n distinct colors and I remember the screen shot from iblechbot

[13:22] <Limbic_Region> he has since solved his problem, but I wanted to ask what you used anyway (in case it was different)

[13:22] <nothingmuch> that's a nice problem

[13:23] <iblech> Yes, the color algorithm iblechbot uses is different

[13:23] * nothingmuch thinks about distributing based on distance

[13:23] <iblech> First, the whole log is read to find out which nicks were online at the same time

[13:23] <Limbic_Region> iblech - is the source public?

[13:24] <iblech> Yes, an old version is online ATM, will upload the current one, a sec.

[13:24] <Limbic_Region> http://www.perlmonks.org/index.pl?node_id=441359 # is where japhy posted what he used, feel free to reply if you have some insight (which I thought you might)

[13:27] <iblech> http://m19s28.vlinux.de/iblech/iblechbot.tbz2 -- the interesting parts are weblog.pl (the webserver) and Heinz/Colors.pm

[13:28] <iblech> Then, an interference graph is created, bases on the information of step (1)

[13:28] <iblech> And this interference graph is then collapsed to the minimal number of colors necessary

[13:29] <Limbic_Region> thanks - will let japhy know if you don't post

[13:29] <iblech> http://www.perlmonks.org/index.pl?node_id=384347 might be interesting, too

[13:29] <iblech> I'll do

[13:36] <Limbic_Region> iblech - I remember that thread but I didn't remember you as the author

[13:37] <elmex> yaho, wanna get some

[13:39] <iblech> http://www.perlmonks.org/index.pl?node_id=441758

[13:40] *** iblech changes topic to: 101 subtests fail | pugscode.org <<Overview Journal>> | pugs.kwiki.org | logged: http://xrl.us/e98m

[14:17] <autrijus> nothingmuch: still there?

[14:17] <autrijus> nothingmuch: how do you get an Int out from an IO Int?

[14:17] <autrijus> by binding it!

[14:17] <autrijus> int <- io_int_thing

[14:18] <autrijus> so, to get an Exp from an Eval Exp, you do

[14:18] <autrijus> exp <- eval_exp_thing

[14:18] <nothingmuch> autrijus: uhuh

[14:19] <nothingmuch> ok

[14:19] <scw> autrijus: I always have ghc check my code when Monad is involved.. :p

[14:20] <autrijus> :p

[14:20] <nothingmuch> so what does it really look like?

[14:20] * scw never knows if it's correct.

[14:20] <autrijus> val <- evalExp exp

[14:20] <autrijus> str <- fromVal val

[14:20] <nothingmuch> unpair (App "&infix:=>" key value) = do

[14:20] <nothingmuch> k' <- evalExp key

[14:20] <nothingmuch> value <- k'

[14:20] <nothingmuch> ...?

[14:20] <autrijus> no

[14:20] <jabbot> nothingmuch: ... 是這樣子嗎

[14:20] <nothingmuch> it doesn't make sense to me

[14:20] <autrijus> value <- fromVal k'

[14:20] <nothingmuch> oh

[14:21] <autrijus> str <- fromVal k'

[14:21] <autrijus> int <- fromVal k'

[14:21] <autrijus> it all works

[14:21] <nothingmuch> what is App "infix:=>" btw

[14:21] <nothingmuch> it seems to be, err, weird

[14:21] <nothingmuch> it has a dangling thing

[14:21] <autrijus> it is just this pair constructor thing.

[14:21] <nothingmuch> the second element, which i dunno what it does

[14:21] <nothingmuch> i know, it's a perlop

[14:21] <nothingmuch> App seems to want 3 things

[14:21] <nothingmuch> what to apply (=>)

[14:21] <nothingmuch> apply on what (a list with two elems)

[14:22] <nothingmuch> and ....?

[14:22] <autrijus> and a series of arguments not related to invocation

[14:22] <autrijus> in this case, always empty.

[14:22] <nothingmuch> ah

[14:22] <autrijus> App op invs args

[14:22] <nothingmuch> ok

[14:22] <nothingmuch> since => is a multisub

[14:22] <nothingmuch> right?

[14:22] <autrijus> right.

[14:22] <autrijus> it is a multisub with 2 invocants.

[14:22] <nothingmuch> i might actually grok pugs internals at some point ;-)

[14:23] <autrijus> you already do :)

[14:23] <nothingmuch> much more hopeful than p5 guts

[14:23] <autrijus> that is very true.

[14:23] <autrijus> p5 guts is like impossible.

[14:23] <autrijus> you can understand a code path

[14:23] <autrijus> but you can't really reason about the whole of it.

[14:23] <autrijus> or, maybe you can, but I cannot.

[14:24] * nothingmuch can't

[14:24] <nothingmuch> tried reading some parts

[14:24] <nothingmuch> knowlege is too spread out, i think

[14:25] <nothingmuch> a vCast is a context sensitive thing

[14:25] <nothingmuch> making a <context expects this type> out of a Val?

[14:26] <nothingmuch> unPair (App "&infix:=>" (keyExp : valExp : []) _) = do

[14:26] <nothingmuch> keyExp' <- evalExp keyExp

[14:26] <nothingmuch> yields: Couldn't match `(,) String' against `ContT Val (ReaderT Env IO)'

[14:26] <nothingmuch>         Expected type: (String, t)

[14:26] <nothingmuch>         Inferred type: Eval Val

[14:26] <nothingmuch> In the application `evalExp keyExp'

[14:26] <nothingmuch> retrospectively nopaste =P

[14:26] <autrijus> er.

[14:27] <autrijus> you want to return (Sting, Exp)

[14:27] <nothingmuch> yes

[14:27] <autrijus> make it

[14:27] <autrijus> Eval (String, Exp)

[14:27] <nothingmuch> but i'm not returning till much later

[14:27] <autrijus> because you are now inside the eval monad

[14:27] <autrijus> and you can't escape the eval monad.

[14:28] <nothingmuch> unPair should return Eval (String, Exp)?

[14:28] <autrijus> if you to the eval inside there, yes.

[14:28] <nothingmuch> ok

[14:28] <autrijus> but that makes the whole Bind.hs monadic.

[14:28] <autrijus> which is sort of what I wished to avoid.

[14:28] <nothingmuch> i think it's unavoidable

[14:28] <nothingmuch> it's a thing that happens

[14:28] <autrijus> subcall( [$name1, $name2](rand 2) => 3 )

[14:29] <nothingmuch> it takes avlues

[14:29] <autrijus> yeah.

[14:29] <nothingmuch> and it connects them

[14:29] <nothingmuch> you could pre unPair, before actually binding

[14:29] <nothingmuch> i think

[14:29] <autrijus> I think that makes a lot of sense.

[14:29] <autrijus> when you are at the caller site

[14:29] <autrijus> first examine the pairs

[14:29] <autrijus> and eval the key part

[14:29] <nothingmuch> what does, monadic binding, or preunpairing?

[14:29] <autrijus> preunpairing

[14:29] <nothingmuch> then bind?

[14:29] <nothingmuch> zh

[14:29] <nothingmuch> ah

[14:29] <autrijus> then do a nonmonadic bind

[14:29] <autrijus> so you always have pure Val

[14:29] <nothingmuch> how do you preunpair?

[14:30] <nothingmuch> you obviously have the thing that does App unPair args

[14:30] <nothingmuch> (and invs)

[14:30] <nothingmuch> i think i can handle it

[14:30] <nothingmuch> but who does App

[14:30] <nothingmuch> Eval's apply? applyExp?

[14:30] <autrijus> reduce

[14:30] <autrijus> but you just eval them.

[14:30] <nothingmuch> ok

[14:30] <autrijus> using evalExp

[14:30] <autrijus> so basically

[14:30] <autrijus> extend isPair

[14:30] <autrijus> to recognize App "&infix:=>" as well

[14:30] <nothingmuch> how icky will this be in the long term?

[14:31] <autrijus> I think it will be just fine.

[14:31] <nothingmuch> isPair (App "&infix:=>" _ _)     = True

[14:31] <nothingmuch> that much I did ;-)

[14:31] <nothingmuch> but actually we don't want that, do we?

[14:31] <autrijus> good. did you check it in?

[14:31] <autrijus> we probably want just that.

[14:31] <nothingmuch> no, because that causes unPair to be fatal =)

[14:31] <nothingmuch> in that case bindNamed can't work

[14:31] <clkao> autrijus: what do i expect today?

[14:31] <nothingmuch> because it has Exps

[14:31] <autrijus> what?

[14:31] <jabbot> autrijus: what is App "infix:=>" btw

[14:31] <nothingmuch> when it should be getting pairs

[14:32] <nothingmuch> gugod owns jabbot, right?

[14:32] <autrijus> right. you are free to ignore it

[14:32] <nothingmuch> i think i will try to feed it defs that contain 'gugod--' ;-)

[14:33] <nothingmuch> it's RSS commit announce is useful

[14:33] <autrijus> nothingmuch: let me try

[14:33] <nothingmuch> but everything else is an annoyance

[14:33] <autrijus> a sec.

[14:33] <nothingmuch> let you try what, the pair fixing code?

[14:34] <autrijus> I checked in the App &infix code.

[14:34] <autrijus> r1052

[14:34] <nothingmuch> i could have told you that borks ;-)

[14:35] <nothingmuch> in fact, i did =D

[14:35] <nothingmuch> i think it's not the solution we want

[14:35] <autrijus> ./pugs -e sub foo (+$n) { say $n } foo( n => 3 )

[14:35] <nothingmuch> either isPair and unPair take the same thing

[14:35] <autrijus> now says "3" for me.

[14:35] <nothingmuch> ah

[14:35] <nothingmuch> then what is the diff, really?

[14:35] <nothingmuch> it's not just isPair that was fixed, was it?

[14:35] <autrijus> isPair (App "&infix:=>" [(Val _), _] [])   = True

[14:35] <autrijus> unPair (App "&infix:=>" [(Val k), exp] []) = (vCast k, exp)

[14:36] <autrijus> now that only works for simple values as keys.

[14:36] <autrijus> $n => 3

[14:36] <autrijus> will totally bork.

[14:36] <nothingmuch> ah

[14:36] <autrijus> so pre unpairing is still needed

[14:36] <nothingmuch> that's what I meant =)

[14:36] <autrijus> just want to make clear the point :)

[14:36] <nothingmuch> ok =)

[14:36] <nothingmuch> isn't messing with App ... after preUnpair a violation of separation of concerns?

[14:37] <nothingmuch> i mean, we both expect it to be dealt with, and deal with it ourselves

[14:37] <nothingmuch> anyway, i'll see what i can do for preunpairing

[14:37] <nothingmuch> is there any chance of it breaking anything?

[14:37] <autrijus> the correct thing is to preunparirng

[14:37] <autrijus> and preevaluation into simple Syn "=>" pairs

[14:37] <autrijus> that guarantees a simple Val in the LHS

[14:37] <nothingmuch> why syn pairs?

[14:37] <nothingmuch> is that what a VPair is?

[14:37] <autrijus> just so Bind.hs knows how to deal?

[14:38] <autrijus> VPair is Val, Val

[14:38] <autrijus> we want Val, Exp

[14:38] <nothingmuch> in the long term, too?

[14:38] <autrijus> you can arguably turn Exp into Val VThunk

[14:38] <autrijus> and get Val Val

[14:38] <autrijus> in that case sure, make them simple VPair vals

[14:38] <autrijus> is the long term best solution

[14:38] <autrijus> because that decouples the caller site with binding site.

[14:38] <nothingmuch> i believe in the long term

[14:38] <nothingmuch> so this is the aforementioned Param, Exp to Param, Val fix

[14:39] <nothingmuch> which i don't know where to start doing

[14:39] <nothingmuch> =)

[14:39] <elmex> autrijus++

[14:39] <elmex> nothingmuch++

[14:39] <autrijus> nothingmuch: sure :)

[14:39] <elmex> so cute

[14:39] <autrijus> what is so cute?

[14:39] <nothingmuch> cute?

[14:39] <Dabian> Emacs rocks!

[14:39] <autrijus> and yes, that is the aforementioned fix.

[14:40] <autrijus> greetings Dabian.

[14:40] <autrijus> or rather, closely tied to.

[14:40] <nothingmuch> autrijus: i'll work on it then, 

[14:40] * nothingmuch reads some more haskell...

[14:40] <Odin-LAP> Dabian: Does it?

[14:40] <autrijus> nothingmuch++

[14:40] <nothingmuch> Eval.hs's reduce, and apply is what I want, right?

[14:40] <nothingmuch> or rather, the callers of apply

[14:40] <Odin-LAP> :D

[14:40] <autrijus> yup.

[14:40] <nothingmuch> perlbot: highest karma

[14:40] <perlbot> The top 5 karma entries: autrijus: 38, nothingmuch: 36, ~brad2901: 26, stevan: 22, C: 22

[14:40] <nothingmuch> damn

[14:40] <nothingmuch> autrijus is still ahead

[14:40] <nothingmuch> two days ago i had an edge of 1 ;-)

[14:40] <Dabian> Odin-LAP: Yes!

[14:41] <autrijus> :p

[14:41] <pjcj> Dabian: pugscc --elisp works?

[14:41] <autrijus> see, that parrot compile things is popular

[14:41] <Odin-LAP> Dabian: Pffth. I don't believe you.

[14:41] <autrijus> ooh. want to work on it?

[14:41] <autrijus> --elisp that is

[14:41] <autrijus> that will so rock

[14:41] <Dabian> pjcj: try it :)

[14:41] <theorbtwo> I'm afraid I'm to blame... but I think --elisp would indeed so rock.

[14:42] <Odin-LAP> Hm.

[14:42] <elmex> you're so cute 

[14:42] <nothingmuch> that should allow for actual syntax highlighting by means of embedded perl, right?

[14:42] <Odin-LAP> That'd be ... interesting, to say the least.

[14:42] <elmex> C++

[14:42] <nothingmuch> elmex: some people might find that offensive ;-)

[14:42] <autrijus> nothingmuch: sure

[14:42] <elmex> what is about C++?

[14:42] <nothingmuch> C-- is also a nice backend

[14:42] <nothingmuch> in theory

[14:42] <autrijus> elmex: we alreay compile to GHC

[14:42] <autrijus> which compiles to C--

[14:42] <autrijus> which compiles to C

[14:42] <elmex> nothingmuch: that wasn't offensive. being cute is a very good thing

[14:43] <nothingmuch> i find it cute, being cute and all

[14:43] <nothingmuch> in fact, i look cute, and try to act cute, and stuff

[14:43] <elmex> ;)

[14:43] <elmex> cool

[14:43] <elmex> err..cute ;)

[14:43] <stevan> autrijus: any timeline on the s/// perl5 regexp support?

[14:43] <Odin-LAP> 'cute', you say.

[14:43] <nothingmuch> but that's because i realized early on i have no chances at looking cool

[14:43] <jabbot> pugs - 1052 - * pair fixing code

[14:43] <nothingmuch> or buff

[14:44] <nothingmuch> =)

[14:44] * Odin-LAP just looks like an idiot.

[14:44] <Odin-LAP> Easiest thing ever. Takes no effort at all. ;)

[14:44] <autrijus> stevan: you want backref to $1 and $2?

[14:44] <autrijus> and s///g?

[14:44] <autrijus> give me a priority list? :)

[14:45] <autrijus> on s/// that is

[14:45] <stevan> the backref is alreayd there I think

[14:45] <stevan> at least it seems to work :)

[14:45] <autrijus> right.

[14:45] <autrijus> s/(foo)/$1/g though

[14:45] <autrijus> is another matter.

[14:45] <stevan> s/// would be really really really nice

[14:45] <stevan> I am not so concerned about s/(foo)/$1/g

[14:46] <Odin-LAP> Erm.

[14:46] <stevan> thats nice and all, but could wait (at least for my purposes)

[14:46] <Odin-LAP> That'd be s:g/// now, wouldn't it?

[14:46] <stevan> Odin-LAP: yes

[14:46] * nothingmuch is half way through his 3rd liter of water today

[14:46] <autrijus> sure.

[14:46] * nothingmuch is impressed with himself

[14:46] <Odin-LAP> nothingmuch: What, only three?

[14:46] <stevan> s:g:perl5/// would be nice

[14:46] <theorbtwo> s:perl5:g///, to be more specific.

[14:46] <autrijus> is it still bound by ~~ ?

[14:47] <nothingmuch> Odin-LAP: i tend to drink too little

[14:47] <metaperl> nothingmuch, why drinking so much water?

[14:47] <autrijus> adverbs order doesn't matter

[14:47] <stevan> bound by? I am sure I understand?

[14:47] <nothingmuch> metaperl: i live in the desert, and i didn't drink enough yesterday

[14:47] <metaperl> nothingmuch, where do you live?

[14:47] <Odin-LAP> autrijus: I don't think any other operator would fit.

[14:47] <nothingmuch> Beer Sheva (suburb of thereof, to be exact)

[14:47] <Odin-LAP> nothingmuch: Ah.

[14:47] <metaperl> what country is beer sheva in?

[14:47] <theorbtwo> You live in the god of beer?

[14:48] <autrijus> god.

[14:48] <mkirank> im trying to install pugs at home on my linux machine .. this is the files that i have to download right http://www.haskell.org/fedora/haskell/1/i386/RPMS.stable/ghc64-6.4-2.i386.rpm   and  http://www.haskell.org/fedora/haskell/1/i386/RPMS.stable/ghc-6.4-2.i386.rpm  

[14:48] <autrijus> look at S04!

[14:48] <theorbtwo> Er, the suburbs of the god of beer...

[14:48] <autrijus> a native "subst" object previously unmentioned!

[14:48] <nothingmuch> well, either in Tennessee somewhere, or in israel

[14:48] <autrijus> what's with that?

[14:48] <metaperl> i see, are you jewish?

[14:48] <nothingmuch> metaperl: err, that depends on who you ask

[14:48] * metaperl has a slight interest in kabbalah

[14:48] <nothingmuch> mkirank: the second i think

[14:49] <nothingmuch> i'd say, yes, culturely, not religeously

[14:49] <nothingmuch> state of israel says no

[14:49] <metaperl> oh, where is the wailing wall?

[14:49] <nothingmuch> mom converted from catholicisim

[14:49] <nothingmuch> but to the conservative stream

[14:49] <nothingmuch> in the 80s

[14:49] <mkirank> nothingmuch only the second is it ?

[14:49] <nothingmuch> when only orthodox judasim was recognized as valid by the state

[14:49] <metaperl> i thought you had to be born as a jew...

[14:49] <nothingmuch> mkirank: the first is for opetron64 and friends, i think

[14:49] <nothingmuch> well, in theory yes

[14:50] <nothingmuch> you inherit it from your mother

[14:50] <stevan> metaperl: I think your mother has to be jewish

[14:50] <nothingmuch> if she converted then you count as a jew

[14:50] <metaperl> my impression of israel is that you could be blown up at any moment... no offense intended but that's all I see about Israel on the news here

[14:50] <nothingmuch> my dad is jewish, officially

[14:50] <autrijus> stevan: care to ask on p6c about how the "subst" obj is supposed to work?

[14:50] <autrijus> because it's only mentioned once

[14:50] <nothingmuch> metaperl: that is a bad impression, i think, for either side

[14:50] <nothingmuch> it's really not like this

[14:50] <autrijus> and I have no idea at all about its semantics.

[14:50] <stevan> p6c? or p6l?

[14:50] <metaperl> that's good to hear

[14:50] <autrijus> well it's in Syn, we're implementing it, so p6c maybe

[14:50] <nothingmuch> chances of being involved in a direct conflict with arabs is very low, even if in the army

[14:50] <Odin-LAP> nothingmuch: What's your view on that whole mess? :>

[14:50] <metaperl> Syn? as in Synagogue :)

[14:51] <theorbtwo> Well, the theory, I think, is that conversion happens when somebody who was always jewish but didn't realize it finds out.

[14:51] <nothingmuch> chances of dying in a bombing is much lower than car accident deaths

[14:51] <stevan> autrijus: ok, I will re-read Syn 04 and ask

[14:51] <autrijus> danke!

[14:51] <nothingmuch> etc etc

[14:51] <nothingmuch> but that stuff doesn't make new

[14:51] <nothingmuch> s

[14:51] <nothingmuch> i never head 'man got hit by car in australia'

[14:51] <nothingmuch> Odin-LAP: rational left wing, i think

[14:51] <nothingmuch> i believe that we can cautiously approach a peace if people that want to spoil it are under control

[14:52] <nothingmuch> and we don't get overzealous, and then say "Well, they started it" when it all false to bits

[14:52] <Odin-LAP> Heeh. They aren't, right now. :p

[14:52] <metaperl> arafat's death was a good thing for peace if you ask me

[14:52] <nothingmuch> metaperl: perhaps... we shall see

[14:52] <nothingmuch> right now it's still too chaotic to tell, IMHO

[14:52] <nothingmuch> but then again, he was not too hard to improve on

[14:52] <Odin-LAP> metaperl: Yes, but it won't mean anything until the nuts on the other side get out of the way, too.

[14:53] <Odin-LAP> Which, frankly, doesn't seem too likely. :(

[14:53] <nothingmuch> i really have high hopes about our side bucking up this time

[14:53] <nothingmuch> it seems so close, and so dead serious

[14:53] <mkirank> i get a   ghc64 is needed by ghc-6.4-2 .. so i guess i have to download both 

[14:53] <theorbtwo> His death was, but the Israelite government messed it all up by trying to control his funeral.

[14:53] <nothingmuch> likely someone will screw things up, and something will get bombed

[14:53] <nothingmuch> but experience tells me otherwise

[14:53] <jabbot> pugs - 1053 - add test for var in key side of pair

[14:54] <nothingmuch> and sharon could say "well, i tried, and they didn't help themselves"

[14:54] <nothingmuch> and we'd be back in spring 2002

[14:55] <nothingmuch> anywho, i dislike discussing politics, i tend to get carried away and then regret it

[14:55] <nothingmuch> to cut to the point:

[14:56] <nothingmuch> i'm more pro arab than most, but not in an "oh, we're so barbaric" sort of way. I think both sides bear a lot of guilt, or at least should, and will have to face it in the next decade or things will never get resolved

[14:59] <Juerd> ]}}

[15:02] <stevan> autrijus: actually subst is mentioned again in S05, all the way at the bottom

[15:02] <stevan> it seems to be a method for string objects

[15:03] <stevan> $str.subst(//, "replacement") is the example given

[15:03] <theorbtwo> Ah, that'd make more sense.

[15:03] <theorbtwo> ~~ is "smart match", and s/// isn't matching anything.

[15:03] <stevan> there is also a match() method

[15:03] <stevan> $stc.match(//);

[15:04] <theorbtwo> Right; $string ~~ $rule is syntatic sugar for $stc.match($rule)... I think.

[15:04] <theorbtwo> (Though I'm not clear why that's not $rule.match($stc).)

[15:04] * theorbtwo realizes he's making this up as he goes along, stops.

[15:05] <Odin-LAP> I think that's how Perl6 was designed, you know.

[15:05] <theorbtwo> That's how everything was designed, odin.

[15:05] <Odin-LAP> :p

[15:05] <iblech> Hm... latest r1053 fails *many* tests, "Fail: Prelude.last: empty list"

[15:06] <autrijus> so what is "subst" as a type?

[15:06] <autrijus> nothingmuch: you broke the tree

[15:06] <nothingmuch> how did I break it?

[15:06] <Odin-LAP> theorbtwo: Nah. Many things, but not everything, I think...

[15:06] <autrijus> or maybe I did.

[15:06] <theorbtwo> LISP, in purticular, was never designed to be actually /run/, and the guy who designed it was quite surprised when somebody made it do so.

[15:06] <stevan> autrijus: still not 100% sure, I am going to read some more so I can ask the question intelligently :)

[15:06] <autrijus> sure :)

[15:07] <nothingmuch> i think not

[15:07] <nothingmuch> my last ci was removing trace

[15:07] <nothingmuch> and that passed tests

[15:07] <Juerd> 16:09 < theorbtwo> Right; $string ~~ $rule is syntatic sugar for $stc.match($rule)... I think.

[15:07] <Juerd> 16:09 < theorbtwo> (Though I'm not clear why that's not $rule.match($stc).)

[15:07] <Juerd> theorbtwo: Shouldn't matter. $regex ~~ $string DWYM

[15:07] <nothingmuch> expect for a one line change to sub_named_params.t

[15:07] <Juerd> Most smart matches are reversable

[15:07] <Odin-LAP> theorbtwo: Lisp is an oddity. It was just a mathematical formalism that wound up having use as a programming language...

[15:07] <nothingmuch> and the correpsponding change to plan

[15:08] <Juerd> Only those with special syntax (i.e. hash subscripts) are not

[15:08] <theorbtwo> Right, because ~~ is more-or-less a highly funky equality operator; all the basic properties of equality operators should more-or-less hold.

[15:09] <autrijus> except when it is not.

[15:09] <autrijus> marked with *

[15:09] <Odin-LAP> Smart match is very well described with the term "funky". ;)

[15:09] <Juerd> All those new Perl 6 features are funky

[15:10] <Juerd> Those from other languages are boring

[15:10] <theorbtwo> I'm going to get dressed, find some cash, and buy some milk... see you in 30 or so.

[15:10] <Odin-LAP> Heeh.

[15:10] <Juerd> theorbtwo: years?

[15:10] <Juerd> theorbtwo: hours? minutes?

[15:10] <Odin-LAP> Juerd: Macros are boring? :>

[15:10] <Juerd> seconds?

[15:10] <autrijus> nothingmuch: not your fault. it's me.

[15:10] <Juerd> Odin-LAP: Quite.

[15:10] <autrijus> apologies.

[15:10] <nothingmuch> autrijus: =)

[15:10] <Juerd> Odin-LAP: Handy and useful, but boring.

[15:10] <nothingmuch> the pair fix?

[15:10] <theorbtwo> minutes.  Possibly much less, depends on if I feel like buying other things, and how long it takes to find cash.

[15:11] <autrijus> weird.

[15:11] <Odin-LAP> Juerd: Hm. I guess that's one perspective. I think it's going to be interesting to see how they mix with all the other stuff that's being thrown into the mix.

[15:11] <theorbtwo> I suspect everyone will find the new perl6 stuff much less wierd after we've actually programmed with them for a while.

[15:11] <Odin-LAP> But taken alone, I guess I'd agree. :)

[15:12] <theorbtwo> The same way lisp programmers don't find the lack of syntax and such funky.

[15:12] <Odin-LAP> theorbtwo: They usually acknowledge that it's weird, compared to other programming languages. :>

[15:17] <nothingmuch> good post: http://www.perlmonks.org/index.pl?node_id=440730

[15:18] <nothingmuch> i've wanted to answer a question like that for a long while

[15:18] <nothingmuch> it has implications about robustness, security, performance, etc

[15:18] <autrijus> the test fix has been worked around.

[15:18] <autrijus> ironically it's cased on write_log wkring.

[15:18] <autrijus> working.

[15:19] <nothingmuch> autrijus?

[15:19] <jabbot> nothingmuch: autrijus is still ahead

[15:19] <autrijus> please help me untodo.

[15:19] <autrijus> t/subroutines/sub_named_params.............ok

[15:19] <autrijus>         4/20 unexpectedly succeeded

[15:19] <nothingmuch> what is gugod--

[15:19] <nothingmuch> what?

[15:19] <jabbot> nothingmuch: what is gugod--

[15:19] <nothingmuch> hah!

[15:19] <lumi> That's not very nice..

[15:19] <lumi> But then, neither is the bot

[15:19] <nothingmuch> he should fix his bot =)

[15:20] <nothingmuch> i've decided not to ignore it

[15:20] <lumi> Heh

[15:20] <nothingmuch> because then I miss the commit messages

[15:20] <autrijus> it is worth noting that jabbot.blogspot.com exists.

[15:20] <nothingmuch> oh, it's a precanned rss<->irc bridge?

[15:20] <nothingmuch> boy, that website makes so much sense for me.... =)

[15:22] <stevan> autrijus: what exactly are you wondering about with subst?

[15:23] <stevan> the more I read the less I think it will be relevant until you implement the perl6 rules

[15:23] <jabbot> pugs - 1054 - * work around the Prelude.last bug cause

[15:23] * stevan freely admits that he is totally missing the point though

[15:24] <autrijus> stevan: say I have this

[15:24] <autrijus> s:perl5:g/foo/bar/

[15:24] <autrijus> is that a "subst" object?

[15:24] <autrijus> does a subst object .hasa rule object?

[15:24] <Juerd> Is it really :g with :p5?

[15:24] <autrijus> what exactly does a subst object do?

[15:25] <stevan> ok

[15:25] <autrijus> can I get a rule object from it?

[15:25] <autrijus> how does it stringify? etc.

[15:25] <stevan> and if its not an object, and just a Str method then?

[15:25] <autrijus> how is a method possible as RHS of ~~?

[15:25] <stevan> RHS?

[15:26] <stevan> Right Hand Side?

[15:26] <autrijus> right hand side

[15:26] <autrijus> is ~~ s:perl5:g/a/b/

[15:26] <autrijus> the same as

[15:26] <autrijus> ~~ .subst(rx:perl5/a/, "b") ?

[15:26] <autrijus> or

[15:26] <autrijus> ~~ .subst(rx:perl5/a/, {"b"})?

[15:26] <autrijus> questions questions.

[15:26] <stevan> I see now

[15:27] * stevan goes off to try and compose a mail on this insanity :P

[15:27] <nothingmuch> autrijus: should i raise "ok(!(eval '&foo.assuming(1)'), "can't curry without named params");" passing to p6l?

[15:27] <nothingmuch> the way we bind currying positionals does make sense

[15:27] <nothingmuch> backlink comment: # L<S06/Currying /takes a series of named arguments/>

[15:28] <autrijus> sure.

[15:28] <autrijus> go ahead.

[15:28] <autrijus> but

[15:28] <autrijus> phrase it as a perl6 question :)

[15:28] <autrijus> (as in, language proposal about how .assuming can also behave)

[15:29] <nothingmuch> i think i would rather ask it as:

[15:29] <nothingmuch> it says so

[15:30] <nothingmuch> we do it so that it can be otherwise

[15:30] <nothingmuch> this is because binding works like:

[15:30] <nothingmuch> ?

[15:30] <nothingmuch> sorry

[15:30] <nothingmuch> "is that a bad thing, or a good thing?" was what I meant to type

[15:30] <autrijus> that works too.

[15:33] <autrijus> stevan: s:perl5/// is landing. no :g :i yet

[15:33] <autrijus> or :m :s

[15:33] <autrijus> but trivial.

[15:33] <stevan> autrijus: thanks :)

[15:33] <stevan> autrijus++

[15:33] <jabbot> pugs - 1055 - More tests.

[15:34] <autrijus> glad to be of help ;)

[15:34] <stevan> nothingmuch++ # just so he won't feel bad :P

[15:34] * autrijus needs to journal and sleep soon

[15:34] <nothingmuch> stevan++

[15:34] <nothingmuch> =)

[15:34] <stevan> nothingmuch: no I haven't done anything today

[15:34] <nothingmuch> blah, whatever

[15:34] <stevan> perlbot karma mom

[15:34] <perlbot> Karma for mom: 1

[15:34] <nothingmuch> i haven't done much either

[15:35] <stevan> nothingmuch: thats your mom :)

[15:35] <nothingmuch> my mom?

[15:35] <stevan> we ++ her for giving birth to you :)

[15:35] <nothingmuch> heh

[15:35] <nothingmuch> =D

[15:35] <stevan> when you got her at the train yesterday :)

[15:35] <nothingmuch> mothers++

[15:35] <nothingmuch> that was yesterday? not the day before?

[15:35] <nothingmuch> yesterday i didn't even unpack the puter at home, i think

[15:35] <nothingmuch> just read a book, and went to bed

[15:36] <stevan> nothingmuch: hard to say, my yesterday is not always your yesterday :P 

[15:36] <stevan> damn time zones 

[15:36] <nothingmuch> i think i picked up mom around 45 hours ago

[15:36] <nothingmuch> so ;-)

[15:37] <stevan> well tell mom we all say "hi"

[15:37] <autrijus> patches welcome to implement the rest of :m :s etc

[15:37] <autrijus> just parse for adverbes and feed them to MkRegex

[15:37] <nothingmuch> ok =)

[15:38] <autrijus> pugs> my $x = "pugs"; $x ~~ s:perl5/u.[st]/arrot/; $x

[15:38] <autrijus> 'parrot'

[15:38] <stevan> autrijus: very cool, now I can finish File::Spec 

[15:38] <stevan> did I mention how UGLY File::Spec is?

[15:38] <autrijus> no. you did not.

[15:38] <stevan> its really really UGLY 

[15:38] <autrijus> t1056.

[15:38] <autrijus> enjoy!

[15:38] <autrijus> s/t/r/

[15:39] <stevan> danke; graci; thank you :)

[15:39] <autrijus> =)

[15:42] <autrijus> Day 51: Inline haskell, s:perl5///

[15:42] <autrijus> not too bad for a day :)

[15:42] <autrijus> sadly ingy did not commit his makefile.pl magic for inline()

[15:42] <iblech> BTW -- I get some warnings when compiling (GHC 6.2, Linux): http://sial.org/pbot/8541

[15:43] <autrijus> yeah they're expected.

[15:43] <iblech> Ok

[15:43] * theorbtwo is back.

[15:43] <jabbot> pugs - 1056 - * s:perl5/// support.

[15:44] <nothingmuch> ok, sent to p6l

[15:45] <autrijus> iblech: I attemped a fix; try again please?

[15:48] <autrijus> heads-up

[15:48] <autrijus> it may be the case that the whole evaluator will be moved into compiler

[15:48] <autrijus> once Compile.Haskell is working

[15:48] <autrijus> so the evaluator does on-the-fly compilation

[15:48] <autrijus> and always run code at fast speed.

[15:48] <autrijus> that will also save us from doing Eval.hs and Compile.Haskell separately.

[15:48] <autrijus> plus a set of very nice things.

[15:49] <nothingmuch> how does this hinder BEGIN {}, etc?

[15:49] <autrijus> but it will be done by essentially taking Eval.hs code and add [| |] for each reduce rule

[15:49] <iblech> http://sial.org/pbot/8542 -- new warnings

[15:49] <autrijus> nothingmuch: that is so we can get BEGIN work.

[15:49] <nothingmuch> ride leaving

[15:49] <nothingmuch> ah =)

[15:49] <nothingmuch> ciao everyone

[15:49] <nothingmuch> home &

[15:52] <autrijus> iblech: should be fixed now. try again?

[15:53] <jabbot> pugs - 1058 - * revert to old include style for 6.2.2.

[15:53] <jabbot> pugs - 1057 - * warning fixes

[15:55] <iblech> :) Only one warning left:

[15:55] <iblech> Compiling RRegex.PCRE      ( src/RRegex/PCRE.hs, src/RRegex/PCRE.o )

[15:55] <iblech> /tmp/ghc24855.hc: In function `RRegexziPCRE_zdwccall_entry':

[15:55] <iblech> /tmp/ghc24855.hc:498: warning: assignment discards qualifiers from pointer target type

[15:55] <autrijus> I have no idea :)

[15:55] <autrijus> maybe it's one of the signeness things.

[15:56] <autrijus> you're welcome to track src/pcre/ down :)

[15:57] <iblech> somebody with C skills may do that :)

[16:00] *** iblech changes topic to: 115 subtests fail | pugscode.org <<Overview Journal>> | pugs.kwiki.org | logged: http://xrl.us/e98m

[16:03] <jabbot> pugs - 1059 - * fixup inline syntax a bit

[16:11] <elmex> oi

[16:13] <iblech> luqui: IIRC, you created a perl6.vim syntax highlighting script :) -- URL?

[16:13] <jabbot> pugs - 1060 - * add credit for GHC-licensed RuntimeLoa

[16:15] <stevan> luqui: I have a quick question for you

[16:15] <stevan> when you have a second

[16:23] <luqui> stevan: hmm?

[16:23] <stevan> luqui: you removed the string escape test

[16:23] <stevan> for test\'

[16:23] <stevan> why?

[16:23] <luqui> yeah, it was wrong.

[16:23] <stevan> should that not work?

[16:23] <luqui> perl -e "print 'foo\'"

[16:23] <jabbot> pugs - 1061 - unTODO-ed tests; added in the File/Spec.

[16:24] <stevan> oh

[16:24] <stevan> whoops my bad

[16:24] <luqui> (not to mention that you were saying "$foo = 'hello\'", so the newly defined $foo was being interpolated, but that was fixable)

[16:24] <luqui> np

[16:24] <stevan> perl -e "print 'foo\\'"

[16:24] <stevan> that does work

[16:24] <luqui> yep, and in pugs

[16:24] <stevan> pugs -e "say 'foo\\'"

[16:24] <stevan> it fails

[16:25] <luqui> really?

[16:25] <stevan> unexpected end of input

[16:25] <stevan> expecting "\\'" or end of string

[16:25] <stevan> NonTerm SourcePos "-e" 1 12

[16:25] <luqui> i thought I tested that

[16:25] <luqui> make sure that your shell isn't turning \\ into \

[16:25] <stevan> sorry, that should have been the test

[16:25] <luqui> echo "say 'foo\\'"

[16:25] <stevan> luqui: how would I do that?

[16:25] <stevan> prints say 'foo\\'

[16:26] * luqui goes to test it in pugs

[16:26] <stevan> I actually ran into a number of weird things with \'s in strings

[16:26] <luqui> huh... my bad

[16:26] <stevan> but some of them were me :)

[16:26] <luqui> that deserves a test

[16:26] <stevan> not a big deal, I was testing for the wrong thing, so you were right to remove

[16:27] <stevan> do you want to look into it more? or should I put in the test again?

[16:28] <luqui> put it back in whether or not I want to look into it

[16:28] <luqui> but I probably will... tomorrow (my bedtime is approaching)

[16:28] <luqui> iblech, vim syntax url: http://luqui.org/public/perl6.vim

[16:28] <iblech> luqui: Thanks much :)

[16:29] <luqui> it's very, very out of date

[16:29] <stevan> luqui: where are you located?

[16:29] <luqui> colorado

[16:30] <stevan> bedtime at noon?

[16:30] <luqui> yes, it's about 9:00 am

[16:30] <luqui> and yes, it's almost my bedtime

[16:30] <stevan> whoops, got my timezones backwards

[16:30] <luqui> it's spring break

[16:30] <stevan> LOL

[16:30] <stevan> I just got up

[16:30] <stevan> ahhh

[16:30] <stevan> I am EST

[16:30] <stevan> connecticut to be exact

[16:30] <stevan> but I am not in college so I have to work :P

[16:31] <PerlJam> stevan: give us your exact latitude + longitude so that we know where to send the missles  ;-)

[16:31] <metaperl> stevan do you work in CT or NY?

[16:31] <metaperl> lol@PerlJam

[16:31] <stevan> metaperl: the company is out of NY, but I work mostly from home in CT

[16:32] * stevan prepares his bomb shelter in case PerlJam is serious

[16:32] <elmex> ?

[16:32] <luqui> Perl guided missles

[16:32] <luqui> of course he's serious

[16:32] <PerlJam> stevan: does this pugs stuff dove-tail with your work or is it just for fun?

[16:33] <luqui> Gives new meaning to the "D" in TMTOWTDI

[16:33] <stevan> PerlJam: mostly for fun right now

[16:33] <stevan> I am at the end of project, so I have some time

[16:33] <PerlJam> luqui: new meaning?  No, that's the same old meaning it always had it's just that people don't realize it (until it's too late ;)

[16:33] <luqui> hehe

[16:33] <jabbot> pugs - 1063 - * Upgrade to CVS version.

[16:33] <jabbot> pugs - 1062 - * Jump ship to DynamicLoader

[16:34] <PerlJam> I wish I could find a legitimate excuse to do this for work so I don't feel guilty when I spend work time playing with pugs.

[16:34] <metaperl> stevan, what dynamic HTML generation toolkit do you use at work?

[16:35] <stevan> PerlJam: my boss is very cool with open source work 

[16:35] <luqui> what's that perl module that returns more specific information about the context?

[16:35] <stevan> he knows that we rely on it, so if I have "free" time, I am allowed to use it for OSS stuff

[16:35] <stevan> luqui: Want?

[16:36] <stevan> metaperl: I used to use HTML::Template, now we switched to TT because I can do [% user.getFirstName %] and stuff

[16:36] <luqui> stevan: that's the one

[16:37] <stevan> PerlJam: I would love to use Pugs at work if I could, but we do mostly mod_perl (handler-style) and mod_pugs is not even on the radar yet :)

[16:37] <PerlJam> stevan: similar situation here.

[16:37] <stevan> PerlJam: where do you work?

[16:38] <stevan> assuming you can say, and its not Top Secret :P

[16:38] <PerlJam> stevan: I work at a research institute within Texas A&M University-Corpus Christi.

[16:38] <stevan> nice

[16:38] <autrijus> there's mod_parrot and there's mod_haskell.

[16:39] <PerlJam> Mostly we collect, process, store, process some more, etc. environmental data.

[16:39] <stevan> autrijus: and mod_pugs ?????

[16:39] <stevan> maybe YAPC::NA??

[16:39] <PerlJam> stevan: Are you challenging him?  ;)

[16:39] <stevan> PerlJam: my job is to challange him :) (aka write tests)

[16:39] <autrijus> stevan: err. you compile to haskell and run it with mod_haskell.

[16:39] <autrijus> or compile to pir and run it with mod_parrot.

[16:40] <autrijus> I believe mod_haskell can work with the --pugs backend.

[16:40] <autrijus> the other two backends will catch up.

[16:40] <stevan> wow

[16:40] <PerlJam> autrijus: that's the thing about actual high-volume output ... It always gets exaggerated and you become the lightning rod for any new cool ideas.

[16:41] <PerlJam> (not that this is a bad thing :-)

[16:41] <ninereasons> Is there any chance that in perl6 we will be able to declare multiple assignments?  I've often wished that I could say something like "my ($x = $y = $z) = $val;" to initialize mutiple equivalent variables in a single statement.

[16:41] <integral> my ($x, $y, $z) = $val x 3 ;-)

[16:41] <autrijus> journal up.

[16:41] <integral> my $x = my $y = my $z = $val;

[16:41] * autrijus sleeps. :)

[16:41] <PerlJam> ninereasons: er, what's wrong with  ... what integral just said

[16:42] <stevan> night autrijus 

[16:43] <luqui> integral: in p6 that's my ($x, $y, $z) = $val xx 3;

[16:43] <luqui> the -) on the end is a syntax error :-p

[16:43] * integral had a habit of just picking syntax at random ;-)

[16:44] <PerlJam> luqui: couldn't we get something like my ($x,$y,$z) =<< $val;  so as to not have to explicitly state the number?

[16:45] <integral> wouldn't the hyper be on the other side?

[16:45] <PerlJam> yeah, I guess so.

[16:46] <PerlJam> But my ($x,$y,$z) >>= $val; really looks like it's doing something different than what's wanted.

[16:47] <integral> maybe we need a combinator to turn $val into a infinite constant list

[16:47] <PerlJam> (the "flow" appears rightward rather than leftward)

[16:47] <integral> xx inf?

[16:47] <PerlJam> integral: $val xx Inf  + lazy eval

[16:48] <nothingmuch> evening

[16:48] <stevan> nothingmuch: howdy

[16:49] <PerlJam> buenos dias nothingmuch 

[16:49] <ninereasons> sorry, I was away.

[16:49] <nothingmuch> that was a reply, not an announcement

[16:49] <stevan> en Espanol 'naddamucho' :)

[16:49] <nothingmuch> evening

[16:50] <stevan> hey gaal

[16:50] <nothingmuch> autrijus seems to overestimate my work

[16:50] <nothingmuch> i don't give that much time to pugs

[16:50] <PerlJam> nothingmuch: why not?  Everyone else tends to overestimate his.  Learn to go with it ;)

[16:50] <ninereasons> fer heavensake.  I didn't know that that worked, integral.

[16:51] <nothingmuch> it makes me come out as, err, someone who is really devoted

[16:51] <nothingmuch> i don't want people to expect me to do things

[16:51] <stevan> nothingmuch: the commit logs speak differently

[16:51] <nothingmuch> i work on it when i get a spare 5 mins

[16:51] <PerlJam> nothingmuch: well, stop getting spare 5 mins

[16:51] <nothingmuch> and in the afternoons in bigger chunks

[16:51] <PerlJam> Or only use your spare 5 mins on pugs sparingly  ;)

[16:52] <nothingmuch> PerlJam: why? i enjoy it =)

[16:55] <nothingmuch> anyway, now is afternoon, and after mail i will pre unPair things before apply

[16:55] <nothingmuch> and that way we get proper named params

[16:55] <nothingmuch> and currying that works 100% of the time

[16:57] <luqui> PerlJam: my ($x, $y, $z) >>=<< $val; will do it now

[16:57] <luqui> ... unless $val happens to be an array reference (/me wants to get that changed)

[16:57] <nothingmuch> don't you mean my ($x, $y, $z) = >>= 

[16:58] <nothingmuch> $val

[16:58] <nothingmuch> without the <<?

[16:58] <luqui> no.  binary hypers always have them on both sides, even if you're only hypering one side

[16:58] <nothingmuch> so in that case isn't '.' binary 'apply method', which gets a method and an object, and applies?

[16:59] <luqui> that's one way to think of it

[16:59] * nothingmuch rereads hyper ops

[16:59] <luqui> but since . has special parsing rules on its right side, another way to think of it is as a postfix

[16:59] <luqui> which is apparently how Larry think of it

[16:59] <luqui> s/k/ks/

[17:00] <theorbtwo> The problem with thinking of . as an infix operator is that it doesn't take anything normal on it's RHS.

[17:00] <nothingmuch> i can grok that

[17:00] <luqui> in other words, $obj.<<@meths is illegal

[17:00] <nothingmuch> although first class methods and method calls should probably be there too, while we're at it ;-)

[17:01] <luqui> nothingmuch: I don't understand?

[17:01] <nothingmuch> is there a way to implement a different WALK?

[17:01] <nothingmuch> it would be nice if you could, for example, change the semantics of what is a method dispatch

[17:01] <nothingmuch> given the MMD dispatch

[17:01] <luqui> definitely.  I don't think anybody has any idea how.

[17:01] <nothingmuch> or whatever

[17:01] <luqui> oh, there's DISPATCH

[17:01] <nothingmuch> how does smalltalk do it?

[17:01] <nothingmuch> does it do it?

[17:02] <luqui> which alters single dispatch...

[17:02] <nothingmuch> i am under the impression that it should, given the way people talk about it

[17:02] * luqui doesn't know smalltalk

[17:02] * luqui should learn it though

[17:02] * nothingmuch is busy enough with haskell =)

[17:02] * luqui no kiddings

[17:02] <luqui> haskell is a... difficult language

[17:03] * nothingmuch is starting to enjoy it

[17:03] <nothingmuch> can read basic things now

[17:03] <nothingmuch> sometimes even without help

[17:03] <nothingmuch> i don't "get" monads yet, though

[17:03] <luqui> I've never learned a language by having to learn to read it

[17:03] <luqui> I've always learned by having to write

[17:03] <luqui> so this is a new experience

[17:03] <theorbtwo> I still think haskell would be a very nice language if it got reasonable parens and commas.

[17:04] <nothingmuch> theorbtwo: in that case $ is your friend, no?

[17:04] <ninereasons> I get frustrated when examples for ghc won't compile in hugs, and visa versa. 

[17:04] <luqui> and if it had any psychological footholds

[17:04] <luqui> and all these years of reading perl really throws me off when I see a $

[17:04] <nothingmuch> i bet if i read python now it'd confuse me

[17:04] <luqui> no other languages use $, so it's my "perl marker"

[17:04] <nothingmuch> but haskell looks /very/ different from perl

[17:05] <nothingmuch> luqui: i get that with bash, actually

[17:05] <theorbtwo> No, because I've never quite figured out what $ is quite supposed to do.

[17:05] <nothingmuch> i use the same keystrokes

[17:05] <nothingmuch> so, i sometimes confuse myself and switch to perl

[17:05] <nothingmuch> theorbtwo: (foo (bar param)) in perl would be said foo(bar(param))

[17:05] <luqui> f a b === ((f a) b)

[17:05] <luqui> f $ a b === f (a b)

[17:05] <nothingmuch> and in haskell can be said foo $ bar $ param

[17:05] <nothingmuch> or more concisely foo $ bar param

[17:05] <nothingmuch> or not =)

[17:06] <nothingmuch> foo $ (bar param) which is just plain stupid

[17:06] <theorbtwo> So $ acts like parens from that point, forward as far as possible to the end of the line.

[17:06] <nothingmuch> yup

[17:06] <nothingmuch> which usually works quite well

[17:06] <luqui> it's a right associative apply, rather than a left-associative one which is the default

[17:06] <nothingmuch> you can also infix things if it helps readability

[17:06] <luqui> most languages apply right-associative (the ones that don't use parens, like perl, that is)

[17:06] <theorbtwo> By using backticks.

[17:06] <nothingmuch> uhuh

[17:07] <nothingmuch> like list `zip` other

[17:07] <nothingmuch> although that's not the same kind of zip

[17:07] <elmex_> ?

[17:07] *** elmex_ is now known as elmex

[17:07] <luqui> that would be a nice thing for perl to have

[17:07] <luqui> unfortunately, perl is out of keyboard

[17:07] <nothingmuch> that's not hard, is it?

[17:08] <luqui> I'm not sure adding another wdti for sub calls is buying us anything though

[17:08] <nothingmuch> gather { for zip(@list; @list) -> $p1, $p2 { take ($p1 => $p2) } }

[17:08] <nothingmuch> what do you mean by that?

[17:08] <luqui> every programmer will have his favorite, and every programmer will have to learn all the wtdis to read code

[17:09] <nothingmuch> we could make a nice pair_up method

[17:09] <luqui> foo($a, $b);  $a.foo($b).  foo $a: $b.  ($a, $b) ==> foo

[17:09] <luqui> those are all the same, but subtly different

[17:09] <luqui> oh, (foo $a, $b)

[17:09] <nothingmuch> and tuple_up, which would really mean array_up

[17:09] <nothingmuch> err s/method/sub/

[17:09] <nothingmuch> user sub, mind you

[17:09] <nothingmuch> (&foo.assuming($a, $b))()

[17:09] <nothingmuch> i don't want that n the core

[17:10] <nothingmuch> or however you dereference that

[17:10] <nothingmuch> (not quite sure yet)

[17:10] <luqui> &foo.assuming($a, $b).()

[17:10] <nothingmuch> ah

[17:10] <nothingmuch> isn't $a: $b and $a, $b radically different?

[17:10] <nothingmuch> i've been playing with parameter binding these last few days, in pugs

[17:10] <nothingmuch> we have invs and args, which are entirely different things, as far as it's concerned

[17:10] <luqui> not at all in the absense of a sub foo (only methods)

[17:11] <luqui> yeah, and they're pretty different, until you start calling the multis

[17:11] <luqui> which should wash them together

[17:11] <nothingmuch> so how does it know what is an invocant and what is an arg in a multi?

[17:11] * luqui is trying pretty hard to convince @Larry that invocants are a bad idea

[17:11] <Odin-LAP> Isn't everything essentially a multi?

[17:11] <luqui> Odin-LAP: it's getting there

[17:12] <nothingmuch> i think invocants should be slurped from the args

[17:12] <nothingmuch> it'd be much more dwimmy

[17:12] <luqui> I think invocant's shouldn't exist, and we should have a smarter MMD behavior

[17:12] <nothingmuch> but less symmetric with sub prototypes

[17:12] <luqui> s/'//

[17:12] <nothingmuch> how would it be smarter?

[17:12] <Odin-LAP> luqui: Hm. But the concept of 'invocant' makes it a bit odd, you mean?

[17:12] <Odin-LAP> Yeah.

[17:12] <Odin-LAP> Hm.

[17:12] * Odin-LAP seconds nothingmuch's question.

[17:13] <luqui> p6l "Argument Patterns"

[17:13] <luqui> that was my first brainstorm

[17:13] <nothingmuch> you mean more like haskell's?

[17:13] <luqui> nothingmuch: that was my inspiration

[17:13] <nothingmuch> (btw, don't subtypes let us do that in an ugly way?)

[17:13] <luqui> but a dynamic language needs something a little different from haskell

[17:13] * nothingmuch waits for mutt to open

[17:14] * luqui is working on a module with which he can experiment with these things

[17:14] <luqui> and really should be working on it right now

[17:14] * luqui declares that he'll be in-and-out

[17:14] <nothingmuch> luqui: how would it look?

[17:14] <nothingmuch> Reading /home/nothingmuch/.maildir/... 14580

[17:14] <nothingmuch> it's growing too fast.... =(

[17:14] <luqui> yikes

[17:15] <luqui> it would look pretty much like it looks now

[17:16] <luqui> (because my proposals never really change much on the surface, they just mess around with the guts)

[17:21] <stevan> anyone inspired to hack in support for :g?

[17:21] <stevan> in s/// regexps that is

[17:22] <luqui> are they still using pcre?

[17:22] <stevan> yes

[17:22] <luqui> (still referring to a very short period of time)

[17:22] <luqui> ahh, then no

[17:22] <stevan> autrijus: just put in s/// for me 

[17:22] <luqui> a little jumpy on the tab key are we?

[17:22] <luqui> :-)

[17:23] <stevan> :)

[17:23] <stevan> too much coffee

[17:23] <nothingmuch> stevan: consider updating colloquy for a less convenient completion interface, if that's what you use ;-)

[17:23] <stevan> I am using X-Chat-Aqua actually

[17:24] <stevan> :P

[17:24] * luqui likes xchat

[17:24] <stevan> its the only one which worked well for me really

[17:24] <stevan> so I like it too

[17:25] <stevan> ok, since no one wants to work on s:g/// support

[17:25] <stevan> how about a nice hack to make this:

[17:25] <nothingmuch> luqui: you're on OSX? or are you referring to a different xchat?

[17:25] <stevan> $path ~~ s:g:perl5{/+}{/};

[17:25] <stevan> work without it

[17:25] <luqui> no, I'm on linux.

[17:25] <luqui> I think x-chat-aqua is probably a port of xchat to aqua

[17:26] <luqui> stevan: it's possible, but it's not pretty

[17:27] <stevan> luqui: its for the File::Spec hack/port, so pretty is not nessecary

[17:27] <stevan> if I wanted pretty I would not use File::Spec :)

[17:27] <luqui> you could always do:  while $path ~~ s{/{2,}}{/} { }

[17:27] <luqui> perhaps without the curly overload

[17:28] <Khisanth> xchat-aqua is xchat with the native mac thing for GUI widgets instead of GTK :)

[17:28] <luqui> that's what I thought :-)

[17:29] <nothingmuch> luqui: i've got to admit i don't see how that is much different than subtype matching on MMD

[17:29] <Odin-LAP> And is it open source, unlike the Win32 version of same? :>

[17:29] <luqui> it basically destroys invocants and makes subtype matching less verbose

[17:29] <luqui> destroying invocants is the biggest part

[17:29] <nothingmuch> invocants destroyed for SMD too?

[17:30] <luqui> SMD and MMD are the same thing

[17:30] <luqui> in perl 6

[17:30] <nothingmuch> so $self goes back to being $_[0], sort of?

[17:30] <luqui> class Foo { method bar() {...} }  and  multi sub bar(Foo $x) {...)

[17:30] <luqui> well, methods still have that nice syntactic sugar

[17:31] <Khisanth> Odin-LAP: yes

[17:31] <luqui> it's just that the colon goes away, because it makes the semantics all icky

[17:31] <nothingmuch> that means basically 'implicity add an argument of type ::?CLASS?

[17:31] <nothingmuch> i really didn't like the colon either

[17:31] <Odin-LAP> Khisanth: Cool. That's good. :)

[17:31] <nothingmuch> in fact, i'd like to be able to do matching on arbitrary params... is that possible?

[17:31] <Khisanth> Odin-LAP: although it does lack certain features

[17:31] <nothingmuch> not only constraining

[17:32] <luqui> nothingmuch: explain arbitrary

[17:32] <nothingmuch> darn! nobody ever answers my posts to p6l

[17:32] <luqui> what was your post about?

[17:33] <nothingmuch> class Human { method eat (Dog $regular_arg) { say "i don't eat dogs" } method eat (Food $regular_arg) { say "mmm" } }

[17:33] <nothingmuch> luqui: about currying positionals

[17:33] <luqui> to be honest, I didn't really understand it

[17:33] <nothingmuch> well, the first part is simple

[17:34] <nothingmuch> S06 says "This method takes a series of named arguments"

[17:34] <nothingmuch> but i don't see why

[17:34] <luqui> oh, that's what you were asking

[17:34] <nothingmuch> and then the second part says how we do it in pugs

[17:34] <nothingmuch> and what our way implies

[17:34] <luqui> and perl 6 probably ought to have a happy medium in there somewhere

[17:34] <nothingmuch> and asks whether our impl is broken, or OK?

[17:35] <nothingmuch> so luqui: can i do simple subs that have not only prototype constraints, but also matching?

[17:36] <nothingmuch> i'd like to be able to do that at the MMD level, to allow things to be added on the outside

[17:36] <nothingmuch> instead of using given { where }

[17:36] <nothingmuch> which means the entire def is one place

[17:36] <nothingmuch> (unless it should be in one place, in which case, don't remove switch statements ;-)

[17:36] <luqui> Ohh! smart matching inside parameter lists

[17:36] <nothingmuch> sort of

[17:36] <luqui> hmm... that might be an elegant way to define smart match :-)

[17:36] <nothingmuch> MMD dispatch

[17:37] <nothingmuch> but not only for arguments

[17:37] * nothingmuch assumed that's how smartmatch will be implemented ;-)

[17:37] <nothingmuch> except for evaluating the RHS, that is

[17:37] <luqui> what else would you do MMD on except for arguments?

[17:37] <luqui> (still trying to figure out exactly what you're asking)

[17:37] <nothingmuch> well, in many cases i like doing special cases separately

[17:38] <nothingmuch> your factorial (is prime) { $?SELF } example pretty much illustrates what I want

[17:38] <nothingmuch> basically, allow this specific-to-generic order matching of MMDs on all params, not just invocants

[17:38] <nothingmuch> and to tell you the truth, I expect MMD to allow that anyway

[17:39] <nothingmuch> since in theory, everything is an object

[17:39] <luqui> that's exactly what I'm proposing

[17:39] <nothingmuch> if you like to call it that

[17:39] <luqui> because I'm proposing to destroy the concept of "invocant"

[17:39] <nothingmuch> so isn't everything an invocant of a sub?

[17:39] <nothingmuch> right

[17:39] <nothingmuch> so what i'm really saying is: oh crap, i thought it was like this anyway

[17:39] <luqui> specific-to-generic order happens to be a pretty hard thing to define

[17:39] <luqui> and that's the only weak point of the proposal at this point

[17:39] <nothingmuch> i know it's hard

[17:39] <nothingmuch> =(

[17:39] * nothingmuch tried it a couple of times

[17:40] <nothingmuch> order of definition is also nice

[17:40] <nothingmuch> although less DWIMMY

[17:40] <luqui> Obviously, $x matches A imples that $x matches B iff B is more generic than A

[17:40] <nothingmuch> perhaps order of definition within specific-to-generic in a simpler way

[17:40] <nothingmuch> like, where clauses first

[17:40] <nothingmuch> then least derived types

[17:40] <nothingmuch> in order of constraint definition

[17:40] <luqui> but that test is hard, or impossible, for a computer to do

[17:40] <nothingmuch> upwards

[17:41] <luqui> nothingmuch: hmm...

[17:41] <nothingmuch> that test is impossible to optimize

[17:41] <luqui> that's an interesting idea

[17:41] <nothingmuch> and i think bad for humans to work with

[17:41] <nothingmuch> i don't know about junctive types

[17:42] <nothingmuch> obviously & is more specific than |

[17:42] <nothingmuch> but i'm not sure if & is less specific than just plain old unjunctioned

[17:42] <luqui> A&B more specific than both A and B which are more specific than A|B

[17:42] <luqui> it's that type lattice thing

[17:42] <luqui> but when you're doing that loose order, you might have to clump them all together

[17:42] <nothingmuch> basically what you get is a pretty DWIM "specificness" measure

[17:43] <nothingmuch> which is not heuristical, but well defined

[17:43] <luqui> I think the main thing that it needs to be is well defined

[17:43] <nothingmuch> and i think that's pretty good

[17:43] <nothingmuch> compared to order of definition

[17:43] <luqui> so people can understand what's wrong quickly

[17:43] <luqui> and allow them an easy way to fix it

[17:43] <nothingmuch> yes

[17:43] <nothingmuch> that's one of the things that seems the most scary for me in p6

[17:43] <nothingmuch> i get along well with special cases

[17:43] <nothingmuch> but too much dwimmery at runtime or something can really get on my nerves

[17:44] <luqui> one of my efforts in the p6 design team is to reduce runtime dwimmery

[17:44] <metaperl_> nothingmuch, then dont get into functiona programming. it is pure DWIM

[17:44] <metaperl_> :)

[17:44] <luqui> because it's bitten me too many times

[17:44] <nothingmuch> metaperl_: i don' think so... i think

[17:44] <nothingmuch> luqui: that's good

[17:44] <nothingmuch> the sigil dereference chain mess in p5 was the most annoying

[17:44] <luqui> metaperl_: the problem is that it takes you two hours to say what you mean, even if it only takes three lines

[17:44] <PerlJam> luqui: In perl or other languages?

[17:45] <PerlJam> luqui: Have you ever dealt with C++?

[17:45] <luqui> mostly in perl

[17:45] <nothingmuch> you just can't get it right without using @{ } et all (no off hand example)

[17:45] <luqui> I know C++ really well, and it never bites me.  It just bugs the hell out of me.

[17:46] <nothingmuch> one of the things i really appreciate in p6 is that it's very consistent

[17:46] <nothingmuch> p5 had some oddities

[17:46] <PerlJam> luqui: I know C++ really well too.  I know not to mess with it while it's eating or it *will* bite me  ;)

[17:46] <PerlJam> nothingmuch: you can say that again!

[17:46] <nothingmuch> but p6 finds nice way of wrapping everything up much better

[17:46] <nothingmuch> like builtins are really MMD

[17:46] <nothingmuch> and operators too

[17:46] <nothingmuch> and you can make them up

[17:46] <luqui> Larry's trying to put all the dwimmery into ~~

[17:47] <nothingmuch> so that means that they are well defined

[17:47] <nothingmuch> less guessing

[17:47] <luqui> which I like

[17:47] <nothingmuch> ~~ is very well defined, i think

[17:47] <luqui> but there are a lot of different cases

[17:47] <nothingmuch> but they are all intuitive

[17:47] <luqui> which should be considered dwim

[17:47] <luqui> sure

[17:47] <nothingmuch> i wrote most of t/operators/smartmatch.t

[17:47] <luqui> we don't want to put anything in perl 6 that isn't

[17:47] <nothingmuch> and i have a good opinion on it

[17:47] <luqui> (like, er, junctions?)

[17:48] <nothingmuch> i really like junctions

[17:48] <nothingmuch> except that I think autothreading should not have auto

[17:48] <nothingmuch> s/auto/easy

[17:48] <luqui> me too, they're a little tough for people to wrap their heads around though

[17:48] <nothingmuch> that's not what gets to me

[17:49] <nothingmuch> it's the same thing that annoys me with overzealous laziness

[17:49] <nothingmuch> you lose control

[17:49] <luqui> yeah...

[17:49] <nothingmuch> and since the language isn't pure in the FP sense, it really /reaallly/ matters

[17:49] <nothingmuch> what if i know that by doing x i indirectly fudge the file that is opened

[17:49] <luqui> well the idea behind junctions is that you usually know where they are

[17:49] <nothingmuch> and which that i assigned to @array beforehand?

[17:49] <luqui> (but damian still refuses to mark them in any way)

[17:50] <luqui> yeah, you have a point

[17:50] <metaperl_> stevan asked a good question about junctions... I dont know if he posted it to p6l or not

[17:50] <luqui> because of the recent p6l discussion, larry is really reconsidering the "everything lazy" perspective

[17:50] <PerlJam> luqui: I think junctions are one of those things where we'll get them in 6.0.0 and then by 6.1.0 we'll have found out if they were a good idea as implemented or not.

[17:50] <metaperl_> my $junc = $a | $b | $c; ++$b; # does this change the junction

[17:50] <PerlJam> metaperl_: no

[17:50] <luqui> no.

[17:50] <nothingmuch> i'd like to be able to have a n is lazy trait on lvalues

[17:50] <nothingmuch> metaperl_: in p5 it doesn't make sense

[17:50] <nothingmuch> unless $b is a reference

[17:51] <nothingmuch> i'd expect no

[17:51] <metaperl_> i see

[17:51] <nothingmuch> but what about if $b is a reference and ++ DWIMs on references/

[17:51] <luqui> and then it still doesn't change the junction, it changes something that something in the junction points to

[17:51] <nothingmuch> right

[17:51] <nothingmuch> how do you specify when a sub takes the junction as a junction

[17:52] <nothingmuch> and when a sub takes a junction as it's, err, unwrapping?

[17:52] <PerlJam> nothingmuch: sub foo (Junction $bar) { ... }

[17:52] <luqui> sub foo (Junction $j) {...}

[17:52] <luqui> one of your special cases :-)

[17:52] <nothingmuch> if we use Sub and Int and Str

[17:52] <nothingmuch> why not Jun or Junc?

[17:52] <nothingmuch> that's more consistent

[17:52] <nothingmuch> Junc, imho

[17:52] <nothingmuch> ends in a consonant

[17:53] <PerlJam> The whole Any|Junction thing bothers me though ... It kind of makes Any not really any.

[17:53] <luqui> yeah...

[17:53] <nothingmuch> hah

[17:53] <luqui> but you've got to remember what junctions are

[17:53] <luqui> they're things that, when you give them this:

[17:53] <luqui> if $x { say "foo" }  if !$x { say "bar" }

[17:53] <luqui> will say both foo and bar

[17:54] <nothingmuch> how do you specify a junction that has a type?

[17:54] <nothingmuch> like a junction of Ints

[17:54] <luqui> Junction of?

[17:54] <nothingmuch> Junction&Int?

[17:54] <luqui> then you're asking for something that is both a junction and an int

[17:54] <nothingmuch> why not make 'Any|Junction' into 'Junction Any' or 'Any :junctive

[17:54] <luqui> which I suppose... well... umm....

[17:54] <nothingmuch> i think ti's more than a type

[17:54] <nothingmuch> it's the state of the vlaue,

[17:55] <nothingmuch> or it's err, lack thereof

[17:55] <luqui> I think a junction is just a type, and perl is confused about what a type is

[17:55] <nothingmuch> again with the 'err' and the 'uhm'

[17:55] <luqui> you'll see that a lot of my proposals try to generify "type"

[17:55] <PerlJam> nothingmuch: btw, I'm sure that the actual type names are probably Integer, String, Number etc. and Int, Str, Num are convient shorthands.  I don't think Junction should have a convienent shorthand.

[17:55] <nothingmuch> so how do i specify a junction of types?

[17:55] <nothingmuch> like array shape?

[17:55] <luqui> I've always wanted to do something like:  role 2 { method is_prime() { 1 } }

[17:56] <luqui> PerlJam: no, they're actually Int, Num, and Str

[17:56] <nothingmuch> so that even a value can be a type?

[17:56] <luqui> yeah

[17:56] <luqui> or rather, a type can be a value

[17:56] <nothingmuch> that makes more sense with junctions

[17:56] <nothingmuch> and generalizes where {} a bit, methinks

[17:57] <luqui> uhhuh

[17:57] <nothingmuch> how does that fudge the runtime/compiletime mess?

[17:57] <PerlJam> luqui: then I'll blame haskell for messing with my mind!  ;-)

[17:57] <nothingmuch> i think it would work if we had haskell like type inferrence

[17:57] <nothingmuch> except that it's not strict

[17:57] <luqui> yeah, but it wouldn't be perlish

[17:57] <nothingmuch> in that once you make a type more generic

[17:57] <nothingmuch> it stays that way

[17:57] <nothingmuch> haskell inference tends to try to find the most specific case

[17:58] <nothingmuch> and anything that is not really that case exactly with no fucking exceptions and i mean it, is a compile time error

[17:58] <luqui> Larry said that type inference is a possibility as long as it doesn't yell at you

[17:58] <nothingmuch> exactly

[17:58] <nothingmuch> i'd really like to be able to strictify type inferrence selectively

[17:58] <luqui> I have to say, haskell's type inference has caught a lot more errors than C's type declarations

[17:58] <nothingmuch> it has

[17:58] <luqui> hmm

[17:58] <nothingmuch> i am starting to like it

[17:59] <luqui> well type inference is a difficult thing to implement

[17:59] <nothingmuch> and i really distrusted C's

[17:59] <nothingmuch> if we figure it out, though

[17:59] <luqui> especially with the complexity of Perl 6's object model

[17:59] <nothingmuch> MMD could be smarter

[17:59] <nothingmuch> smartmatch could be smarter

[17:59] <luqui> yeah, and contexts in calls could be smarter

[17:59] <nothingmuch> because the compiler will know much much more about the containers

[17:59] <luqui> which would be awesome

[17:59] <nothingmuch> and their values

[17:59] <luqui> one problem with type inference is that it is counter-opaque

[17:59] <nothingmuch> how is context insensitivity at the proxy level dealt with, btw/

[18:00] <nothingmuch> opacity could just be a border

[18:00] <nothingmuch> type inferrence stops here

[18:00] <luqui> yeah...

[18:00] <luqui> nothingmuch: what do you mean by comments[-3]

[18:00] <nothingmuch> it's class X's problem

[18:00] <nothingmuch> i don't recall if i sent a message about context insensitivity to p6l

[18:00] <nothingmuch> but it's one of the special cases i most hate dealing with in p5

[18:01] <nothingmuch> wantarray should never be seen, if it's not at the leaf or the root of a call chain

[18:01] <nothingmuch> what do you mean by "comments[-3]"?

[18:01] <nothingmuch> ;-)

[18:01] <luqui> poor naming choice.  nothingmuch[-3]

[18:01] <nothingmuch> english is so much easier to type than say

[18:01] <luqui> which is now nothingmuch[-9]

[18:01] <nothingmuch> proxy level?

[18:01] <luqui> yeah

[18:01] <nothingmuch> sub foo { }

[18:02] <nothingmuch> is a wrapper for sub bar { }

[18:02] <nothingmuch> which takes bar's result

[18:02] <nothingmuch> and also sends it into gorch {}

[18:02] <nothingmuch> how does it do that, if bar is context sensitive

[18:02] <luqui> oh yeah

[18:02] <nothingmuch> and gorch is polymorphic

[18:02] <luqui> Larry's thought of that too :-)

[18:02] <nothingmuch> without actually caring about the fact that both are

[18:02] <nothingmuch> and what it's own context is

[18:02] <luqui> he just hasn't come to a solution

[18:03] <luqui> It's almost globbish:  *foo = bar();  gorch(*foo)

[18:03] <nothingmuch> ah, i did

[18:03] <nothingmuch> 'retiring wantarray''

[18:03] <luqui> oh, excellent

[18:03] <nothingmuch> again, no replies =)

[18:03] <nothingmuch> like my taint idea

[18:03] <PerlJam> We need to get larry on here so that we can brainstorm in real-time with him.  

[18:03] <nothingmuch> and, ...

[18:03] <PerlJam> (mess up his mind faster that way ;)

[18:03] <nothingmuch> PerlJam: i asked him

[18:04] <nothingmuch> he said he doesn't want to do that, because he wants stuff logged

[18:04] <nothingmuch> and slowly

[18:04] <nothingmuch> and less ADD insensitive

[18:04] <luqui> you mean sensitive?

[18:04] <nothingmuch> i mean less disturbing

[18:04] <luqui> anyway, your wantarray problem is a tough one

[18:04] <nothingmuch> so that he can answer in his own time

[18:05] <nothingmuch> and not have to click on the irc window to see if new stuff has happenned every minute 

[18:05] <luqui> what it seems we need to do is to back-infer the type that bar() is supposed to return

[18:05] <PerlJam> nothingmuch: It's saner that way for him.  I'd do the same were I he.

[18:05] <nothingmuch> right, type inferrence really would help DWIMery here

[18:06] <luqui> The design calls are silent 40% or more of the time

[18:06] <nothingmuch> especially if it's weak

[18:06] <nothingmuch> (that is, type inferrence is not pedantic, just something you can leverege for sanity)

[18:06] <luqui> It goes "Larry, problem", Larry: "............... well.................. we could (very good idea that he ends up rejecting)"

[18:06] <nothingmuch> and it's good DWIMery

[18:07] <luqui> and then two days later he posts a really really good idea

[18:07] <nothingmuch> because it's very deterministic and defined

[18:07] <luqui> yeah

[18:07] <nothingmuch> retiring wantarray was about a week ago

[18:07] <luqui> but I don't think it's a good idea to start defining language semantics based on a feature that we're not sure we'll implement

[18:07] <PerlJam> luqui: maybe instead of the conference call, you guys should IRC once a week

[18:07] <nothingmuch> well, then you design for both cases

[18:07] <luqui> I think that would be dangerous

[18:08] <nothingmuch> isn't that how you find out what looks better in the end?

[18:08] <nothingmuch> you could autothread it ;-)

[18:08] <nothingmuch> oh wait, we don't know how to do that safely

[18:08] <luqui> nothingmuch: and the problem with that is that it starts restricting how we can define our type system

[18:08] <PerlJam> Everyone of you with the exception of Larry already regularly IRCs :)

[18:08] <nothingmuch> and then synopses will be contradicting

[18:08] <luqui> damian?

[18:08] <nothingmuch> allison?

[18:09] <rgs> jhi?

[18:09] <luqui> who's jhi?

[18:09] <PerlJam> okay, and maybe damian (I don't think I've ever seen him on IRC)

[18:09] <nothingmuch> isn't that jarkko?

[18:09] <luqui> ahh

[18:09] <PerlJam> He isn't part of the cabal is he?

[18:09] <nothingmuch> is he even involved in p6?

[18:10] <rgs> just throwing pumpkings in the arena

[18:10] <luqui> I don't think I've ever spoken to him

[18:10] <luqui> weren't you a pumpking rgs?

[18:10] <rgs> actually, I am one

[18:10] <rgs> for 5.10

[18:10] <luqui> oh.  neat.

[18:10] <nothingmuch> i think i might have seen some occurances in parrot

[18:10] <nothingmuch> s/weren/aren/

[18:10] * PerlJam DCCs some sympathy to rgs  ;)

[18:11] <nothingmuch> luqui: is Inline:: designed in p6?

[18:11] <rgs> sympathy, good :)

[18:11] <rgs> tuits, better

[18:11] <nothingmuch> i'd really like to mix and match given the fact that parrot "will make it easy"

[18:11] <nothingmuch> i just have no real clue how it will look

[18:11] <luqui> nothingmuch: I don't think we've really thought about it

[18:11] <luqui> Ingy did an awful good job in perl 5

[18:12] <luqui> we might just leave it up to him

[18:12] <nothingmuch> i think he's already doing it =)

[18:12] <luqui> good

[18:12] <nothingmuch> oh, last thing

[18:12] <nothingmuch> in p5 there is no lightweight threads

[18:12] <nothingmuch> it's either two processes which can share some memory if you think it's worth it

[18:13] <nothingmuch> or completely synchroneous, ala Coro, Event, POE

[18:13] <nothingmuch> will we have proper threads

[18:13] <luqui> lwall: "I think both the 5.005 model and the ithreads model are wrong to some extent"

[18:13] <nothingmuch> that can be created and destroyed /fast/?

[18:13] <luqui> the fast part is up to parrot

[18:13] <luqui> we hope

[18:13] <nothingmuch> 5.005 is more "right" for me

[18:13] <nothingmuch> it can't be fast just like that, obviously

[18:13] <jabbot> pugs - 1064 - just uploading the File::Spec progress -

[18:14] <nothingmuch> if we copy everything then it'll be slow, even with copy on write

[18:14] <nothingmuch> because you have to make everything readonly first

[18:14] <luqui> I think the threading model will be up to the parrot folks in general though

[18:14] <luqui> because they're having to tackle it, and we're not thinking about it

[18:14] <luqui> so whatever we do will probably be whatever parrot does

[18:14] <nothingmuch> =/

[18:14] <nothingmuch> i think that's asking for trouble, in a way

[18:14] <luqui> so get on parrot's ass if you want a particular model

[18:14] <nothingmuch> not giving requirements to a design team

[18:15] <nothingmuch> is not likely to come up synchroneous at the end

[18:15] <luqui> I could bring it up today on the design call

[18:15] * nothingmuch would like two things:

[18:15] <nothingmuch> throwaway threads

[18:15] <nothingmuch> that you create for cheap

[18:15] <nothingmuch> when you just want to do somehing and not be interrupted

[18:15] <luqui> every time I chat here on wednesdays I end up having to get a piece of paper for the call

[18:16] <nothingmuch> and two mix two things:

[18:16] <luqui> I think that's good

[18:16] <nothingmuch> long running heavy computation

[18:16] <nothingmuch> and responsive interfacing

[18:16] <nothingmuch> into one thing

[18:16] <nothingmuch> without making the the heavy computation complex, so that it can do funny things

[18:16] <nothingmuch> this is a big design ease

[18:16] <nothingmuch> i just ate crap with it in p5

[18:16] <nothingmuch> because i thought i was building a batch system

[18:16] <PerlJam> luqui: tell pmichaud "hi" for me if he's on the call.  He's been conspicuously absent from the places where I normally run into him.

[18:16] <nothingmuch> and it turns out it should have a nice responsive web GUI too

[18:17] <nothingmuch> so now i'm sort of screwed

[18:17] <PerlJam> I'm hoping that's a good thing and that he's focusing on pge and/or pugs

[18:17] <nothingmuch> and i will probably resort to using signal handlers

[18:17] <nothingmuch> what about serializability? is that also for parrot?

[18:17] <nothingmuch> i'd like to be able to store closures in a DB, sometimes

[18:17] <nothingmuch> it makes things easier

[18:17] <luqui> yeah, but they've declared their answer

[18:18] <luqui> "we'll do serialization, and we'll serialize continuations too"

[18:18] <luqui> which implies closures

[18:18] <nothingmuch> are they serious about it?

[18:18] <luqui> yep

[18:18] <nothingmuch> i really don't see how that could be generalized well

[18:18] * nothingmuch hopes that they get it right

[18:18] <PerlJam> nothingmuch: #parrot exists you know :)

[18:19] <nothingmuch> 0 members

[18:19] <nothingmuch> "You were demoted from operator by ChanServ."

[18:19] <nothingmuch> oh well

[18:19] <Khisanth> not this network :)

[18:19] <luqui> yeah, and luqui doesn't follow parrot *that* closely

[18:19] <nothingmuch> on perl.org, p'raps?

[18:19] <PerlJam> nothingmuch: magnet #parrot

[18:19] <PerlJam> nothingmuch: aye

[18:20] <PerlJam> All that's happened lately on #parrot though is that chip has been having fun nick switching.

[18:20] <PerlJam> perhaps you'll stir them up a little.

[18:21] * nothingmuch tried

[18:22] <nothingmuch> bah, i got carried away

[18:22] <nothingmuch> i promised myself i'd fix currying today

[18:22] <nothingmuch> i think i'm going to try to be sort of busy

[18:22] * luqui & { sleep 300; fg }

[18:23] <jabbot> pugs - 1065 - adding some more File::Spec docs

[18:25] <nothingmuch> well, /I/ answered another one of my p6l posts ;-)

[18:25] <sorje> And you're complaining nobody's answering it.. ;-)

[18:36] * luqui back

[18:40] <vladtz> hello

[18:41] <vladtz> yesterday I ran into problems with ghc5.4 for x86_64 

[18:41] <markstos> vladtz: That sounds like a fairly old version of ghc. Is a newer version available for your platform?

[18:42] <vladtz> today I tried using the i386 version of ghc6.4

[18:42] <vladtz> s/5.4/6.4/ sorry

[18:42] <vladtz> now it fails with asm errors, stillno luck (Fedore Core 3 gch64 rpm)

[18:43] <pasteling> "vladtz" at 80.127.84.50 pasted "ghc 6.4 problems" (7 lines, 525B) at http://sial.org/pbot/8545

[18:44] <vladtz> On the fedora haskell list I was told ghc for 64-bits lacks GHCi support needed for template syntac

[18:58] <kungfuftr> 125 subtests failing

[19:06] <nothingmuch> luqui: more ideas

[19:06] <nothingmuch> will closures be introspectable, in a way?

[19:06] <nothingmuch> i mean, could i look inside one, and see what it does, what it's bound to?

[19:08] <nothingmuch> re: type inferrence:

[19:08] <nothingmuch> this would do wonders for unicode<->other codes

[19:08] <nothingmuch> and for string representation and parsing of numers

[19:08] <nothingmuch> i'd also like to do things like:

[19:08] <nothingmuch> FH is file

[19:08] <nothingmuch> or

[19:08] <luqui> nothingmuch: about closures, umm... sortof

[19:08] <nothingmuch> FH is viewed

[19:09] <luqui> you probably can't look inside a closure unless we've kept its syntax tree around

[19:09] <nothingmuch> so that if i print "$data" into either, it gets displayed for the user

[19:09] <nothingmuch> i meant, could i do diotalevi type stuff to it

[19:09] <luqui> and if we have, then you can look all you like

[19:09] <luqui> diotalevi?

[19:09] <nothingmuch> perlmonks

[19:09] <nothingmuch> he does funny stuff in p5 guts

[19:09] <nothingmuch> except you won't have to know p5 guts to do it

[19:10] <luqui> splain

[19:10] * luqui is no monk

[19:10] <theorbtwo> You should fix that.

[19:10] <theorbtwo> B::Deobfuscate.

[19:10] <nothingmuch> i think he did it to demonstrate that inside out objects are also not a shotgun-in-the-livingroom type thing

[19:10] <nothingmuch> i can't remember when or in what context he said that

[19:10] <nothingmuch> i'll try to find the post

[19:10] <nothingmuch> B::Deobfuscate is a simpler example of diotalevisms, i think =)

[19:11] * nothingmuch really respects him

[19:11] <nothingmuch> diotalevi++

[19:11] <nothingmuch> the only one who didn't say i plagiarized MAPL on my first post

[19:11] <nothingmuch> because he actually read it to see the details

[19:11] * theorbtwo wonders WTF MAPL is.

[19:12] <nothingmuch> mastering algorithms with perl

[19:12] <theorbtwo> Ah.

[19:12] <nothingmuch> i took the approx matcher

[19:12] <nothingmuch> and redid it with closures

[19:12] <nothingmuch> except i didn't quite title it right

[19:13] <nothingmuch> and then everyone said i was an asshole for plagiarizing

[19:13] <nothingmuch> except i wasn't showing off that I grok manber-wu

[19:13] <nothingmuch> i was showing off that i grok closures

[19:16] <nothingmuch> http://www.perlmonks.org/?node_id=315186

[19:16] <nothingmuch> i know it's possible in pugs

[19:16] <nothingmuch> that's what i've been doing for a while ;-)

[19:33] <jabbot> pugs - 1066 - Begin of an (OO) Email::Simple port.

[19:55] * nothingmuch 's mom is now on a cholesterol (chosthelerol, tee hee)

[19:55] <nothingmuch> diet

[19:55] * nothingmuch is helping her with the red wine =)

[19:56] <nothingmuch> yay! larry answered!

[19:58] <stevan> iblechb++ # for the Email::Simple

[19:58] <stevan> naddamucho

[19:58] <stevan> wanna help me make :g work?

[20:00] <kungfuftr> Email::Simple?

[20:00] <kungfuftr> *blink*

[20:00] <stevan> http://svn.perl.org/perl6/pugs/trunk/modules/Email-Simple/lib/Email/Simple.pm

[20:01] <nothingmuch> stevan: naddamucho will not cause growl to pop a notification ;-)

[20:01] <stevan> nothingmuch: sorry

[20:01] <stevan> you need a bi-lingual IRC client :P

[20:01] <nothingmuch> ok, well, i fixed it

[20:01] <nothingmuch> try now

[20:01] <stevan> naddamucho: hey

[20:01] <nothingmuch> hola steffano!

[20:02] <stevan> guten tag :P

[20:02] <stevan> so before you get too silly on read wine, wanna help me with some Haskell?

[20:02] <nothingmuch> sure

[20:02] <nothingmuch> wine works slowly on me though

[20:02] <nothingmuch> last week i was in a wedding

[20:03] <nothingmuch> took 5 cups to get me willing to dance

[20:03] <nothingmuch> get me to be? english doesn't make sense for me

[20:03] * nothingmuch tries to think on that one

[20:03] <theorbtwo> ...make me willing...

[20:03] <nothingmuch> good point

[20:03] <theorbtwo> ...get me to be willing...

[20:03] <stevan> 5 cups to get you on the dance floor

[20:04] <nothingmuch> that makes sense too

[20:04] * nothingmuch should talk it sometime, not just type it

[20:04] <nothingmuch> i don't "hear" it otherwise

[20:04] <stevan> nothingmuch is *not* a cheap date

[20:04] <nothingmuch> oh i'm cheap ;-)

[20:04] <theorbtwo> ...should speak it...

[20:04] <nothingmuch> i'd do anything for free food, attention, more alcohol etc

[20:05] * theorbtwo recommends watching DVDs in english.

[20:05] <nothingmuch> theorbtwo: actually that was intentional

[20:05] <theorbtwo> Oh, whoops.

[20:05] <nothingmuch> =)

[20:05] <nothingmuch> even if it doesn't make sense, the point was to draw attention to the fact that it's 'talking', not just using it

[20:05] <nothingmuch> i think

[20:06] <nothingmuch> that's how i heard it in my head

[20:06] <nothingmuch> which again, doesn't make sense

[20:06] <nothingmuch> =(

[20:06] <nothingmuch> and hearing doesn't help much either

[20:06] <nothingmuch> i do that a lot

[20:06] <nothingmuch> but given a one week visit to an english speaking country, and I become much more coherent

[20:07] <nothingmuch> i think that's fair, because most of my usable english was not learned by conversation

[20:07] <nothingmuch> so anyway, staffenhof, what is your haskell problem?

[20:08] <nothingmuch> and please don't count on me being able to help ;-)

[20:11] <nothingmuch> stevan?

[20:11] <jabbot> nothingmuch: stevan is gone.

[20:12] <kungfuftr> heh, casey's liking the fact Email::Simple port is under way... looks like he's intrested in pugs 

[20:12] <kungfuftr> =0)

[20:13] <nothingmuch> maybe we can get simon cozens to become an atheist this way ;-)

[20:13] <nothingmuch> stevan is gugod--

[20:13] <nothingmuch> steva?

[20:13] <nothingmuch> stevan?

[20:13] <jabbot> nothingmuch: stevan is gugod--

[20:13] <nothingmuch> damn right, jabbot

[20:15] <Corion> Two questions: What is the magic svn incantation to get the latest Pugs? And has somebody started on porting LWP ?

[20:16] <nothingmuch> hola Corion!

[20:16] <nothingmuch> svn co http://svn.openfoundry.org/pugs

[20:16] <nothingmuch> and then you have ./pugs

[20:16] <Corion> Hi nothingmuch ! (and the rest of the crowd too :) )

[20:16] <crysflame> hi, corion

[20:16] <Corion> nothingmuch: Thanks!

[20:16] <stevan> sorry nothingmuch 

[20:17] <stevan> client is on the phone

[20:17] <nothingmuch> nono! your full attention is required at this time!

[20:17] <Corion> (does Pugs have sockets at all? )

[20:17] <nothingmuch> Corion: err, i doubt it

[20:17] <Corion> Yay - checkout was fairly quick :)

[20:17] <nothingmuch> you could write a todo_test

[20:17] <nothingmuch> and then when it passes, err, find out ;-)

[20:17] <crysflame> heh

[20:17] <nothingmuch> with LWP todo_testing a phone home address, that should be very easy =D

[20:18] <Corion> nothingmuch: Ah - well, I'll look how far I get with the native call interface and maybe hack up some sockets thing that only works on Win32 :)

[20:18] <nothingmuch> or you could stay involved with pugs

[20:18] <nothingmuch> Corion: it's probably easier than you think

[20:18] <Corion> nothingmuch: Heh - having Pugs tell me when it's ready would also be fun, true :)

[20:18] <nothingmuch> remember that haskell is a high level address

[20:18] <ayrnieu> a HLA, if you will.

[20:18] <nothingmuch> s/address/language/

[20:18] <Corion> nothingmuch: Well, I wanted to do a bit with Pugs and thought that starting a port of LWP would be a good thing :)

[20:19] <nothingmuch> dad is confusing me, sorry

[20:19] <Corion> Yeah - maybe Haskell has enough sockets to get me started...

[20:19] <nothingmuch> i would start with something a wee bit simpler if i were you ;-)

[20:19] <nothingmuch> what does sloccount LWP say?

[20:19] <ayrnieu> Corion - oh, GHC certainly has socket support.  Even somewhat OK support.

[20:20] <Corion> nothingmuch: Ah, I wrote something like LWP for Ruby (and then came back to Perl), so writing it for Pugs shouldn't be too hard :)

[20:20] <nothingmuch> well, ok =)

[20:20] <ayrnieu> Network.hs had a tiny maldesign, last I looked, but *that's OK*.

[20:20] <kungfuftr> File::Path, Scalar::Util (some of it at least) and um... Set::Object!

[20:20] <stevan> Corion: be forewarned that modules, packages and most importantly objects do *not* work in Pugs now

[20:20] <nothingmuch> Corion: do you grok haskell yet?

[20:20] <nothingmuch> Set::Object++

[20:21] <Corion> stevan: Ugh - but something as simple as LWP::Simple doesn't need much of objects :)

[20:21] <kungfuftr> Set operations in general are lovely

[20:21] <Corion> nothingmuch: No - I can read it, but I don't understand types... I need to read a book on that I fear.

[20:21] <nothingmuch> Corion: well, do remember that pugs is 51 days old

[20:21] <nothingmuch> perlbot YAHT

[20:21] <perlbot> Yet Another Haskell Tutorial -- http://www.isi.edu/~hdaume/htut/

[20:21] <Corion> (but it should be enough to learn from existing stuff and modify existing stuff)

[20:21] <stevan> Corion: sub returns values are sketchy right now too :)

[20:21] <nothingmuch> that helped most tof us

[20:22] <Corion> I already read YAHT (I think), but I didn't understand types.

[20:22] <nothingmuch> and so are sub param bindings

[20:22] <stevan> thanks to nothingmuch  :)

[20:22] * nothingmuch is working on that ;-)

[20:22] <nothingmuch> larry's post is confusing me

[20:22] <nothingmuch> ooh, guests are here

[20:22] <nothingmuch> bbiab

[20:22] <stevan> Corion: dont let us discourage you though

[20:23] <stevan> you can always port, and wait for the features

[20:23] <stevan> thats what we did with most of the stuff in there now

[20:23] <Corion> Hmmm. Param bindings aren't that necessary. But I guess I'll dig in and see how far I get and then bitch about it here :))

[20:23] <stevan> Corion: if you wanna see a port/hack which does work (sort of) look in ext/FileSpec/*

[20:24] <stevan> but beware, it gets ugly in there 

[20:24] <Corion> stevan: Yeah - your port gave me the idea of thinking what module I wanted to port, and LWP was the one I wanted (to make use of continuations)

[20:24] <stevan> Corion: glad to inspire :)

[20:25] <Corion> BTW - I got to chapter 4 of YAHT but the explanation of Types told me nothing (or I don't get what types are about)

[20:25] <stevan> Corion: I havent read YAHT, and can't write Haskell myself, I'm just here for the Perl6 :)

[20:26] <ayrnieu> Corian - in order to learn Haskell, I suspect that you will need to be able to leave many terms (such as 'monad') undefined for a while.

[20:26] <Corion> stevan: Writing Haskell isn't that important to me (at least now), I also mostly want to do Perl6 as some quick exercise :)

[20:26] <stevan> Corion: wanna help with the OO test suite?

[20:26] <Corion> ayrnieu: Yeah, I could do that, but I prefer to learn stuff properly :-)

[20:27] <Corion> stevan: I first have to get Pugs installed/compiled and get my feet wet a bit with it, then I can maybe churn out some tests for OO stuff, yes :)

[20:27] <stevan> excellent

[20:27] <Corion> (and I'd want some OO stuff for LWP sooner or later :) )

[20:27] <Corion> Whooops - Pugs fails some tests in t/examples :)

[20:27] <stevan> Corion: we have plenty of test failures in the current rev

[20:28] <stevan> 115-125 I think

[20:28] <ayrnieu> Corian - ... even if you want to learn Haskell properly, you may need to do as I suggested.

[20:28] <Corion> Ah - so it's nothing to worry about :)

[20:28] * ayrnieu will be offline for a few days.

[20:28] <stevan> Corion: they are on the TODO list 

[20:28] <Corion> ayrnieu: Ah - well, I'll skip on that for the moment I guess - I can read Haskell well enough, and I got far with being able to read C too :)

[20:30] <Corion> Ah - yes - 125 failures (25/118 scripts)

[20:33] <jabbot> pugs - 1067 - Both $mail.header("From") and $mail.head

[20:39] <nothingmuch> weeell

[20:47] <nothingmuch> hyper defined as a circumfix:<竄 罈>

[20:47] <nothingmuch> which returns an anonymous infix operator

[20:47] <nothingmuch> slurpy on both sides

[20:47] <nothingmuch> ?

[20:49] <theorbtwo> wouldn't that be circumfix:{'>><<'} ?

[20:49] <theorbtwo> Er, circumfix:<罈竄>

[20:49] <PerlJam> theorbtwo: Those guillemets don't know which way they're pointing

[20:51] <stevan> nothingmuch: is a multi-line comment in Haskell {-   -}?

[20:51] <theorbtwo> Yes.

[20:51] <nothingmuch> i have no clue

[20:51] <nothingmuch> err, yes, theorbtwo, but what does it matter

[20:51] <theorbtwo> {# ... #} is a compiler hint.

[20:52] <theorbtwo> Well, I'd call $a>>$b<<$c a circumfix operator macro with a strange middle parameter... possibly.

[20:52] <Corion> How do I tell Pugs to search the lib/ directory ? pugs -Ilib doesn't work, and C<use lib 'lib'> doesn't work either ...

[20:52] <stevan> Corion: you set the PERL6LIB env variable

[20:53] <theorbtwo> Oh, hi, Corion!

[20:53] <theorbtwo> I thought -Ilib was working now... but yea, PERL6LIB.

[20:53] <Corion> Hi theorbtwo!

[20:54] <Corion> theorbtwo: At least as of five minutes ago, -Ilib didn't work :)

[20:56] <nothingmuch> gugod++

[20:59] <Corion> Gah. With infallible instinct I beelined for ext/SHA1/SHA1.pm, which doesn't work yet. But using that would make stealing some http/socket code from Haskel soo much easier :)

[21:00] <nothingmuch> that's autrijus's latest hobby

[21:00] <Corion> nothingmuch: Yeah - I read that in his latest journal :)

[21:00] * nothingmuch feels redundant, and also tends to repeat information that is already known

[21:00] <nothingmuch> http://use.perl.org/~autrijus/journal

[21:02] <stevan> I don't think I like PCRE 

[21:02] <stevan> or Haskell either right now 

[21:02] <nothingmuch> stevan?

[21:02] <jabbot> nothingmuch: stevan is gugod--

[21:02] <Khisanth> PNCRE! :)

[21:02] <PerlJam> blasphemer!

[21:02] <nothingmuch> hah!

[21:02] <stevan> I just spent all this time,.. only to realize I was changing code which was commented out :P

[21:02] <theorbtwo> jabbot, forget stevan

[21:03] <jabbot> theorbtwo: ok

[21:03] <Khisanth> hmm NPCRE

[21:03] <nothingmuch> theorbtwo: this is an incentive for gugod to change it =)

[21:03] <theorbtwo> jabbot, stevan is Stevan Little (STEVAN)

[21:03] <jabbot> theorbtwo: 所以？

[21:03] <stevan> then once I realized it was commented out,.. it totally shattered my understanding of all this 

[21:03] <theorbtwo> Blink... WTF?

[21:03] <nothingmuch> stevan: use syntax coloring

[21:04] <stevan> nothingmuch: I think I will just stay away from Haskell for now :)

[21:04] <PerlJam> stevan: why?  Because you thought your changes were having the effects you wanted?

[21:04] <stevan> PerlJam: I was in way over my head

[21:04] <stevan> I was trying to add the :g support to Reg-exp

[21:04] <stevan> and I am barely literate in C, and no at all in Haskell

[21:05] <stevan> and :g takes understanding both 

[21:05] <PerlJam> stevan++  refusing to be limited by his lack of understanding  :-)

[21:06] <nothingmuch> PerlJam++

[21:06] <stevan> PerlJam: thanks :P

[21:06] <stevan> coding_by_accident-- 

[21:06] <PerlJam> stevan: sometimes it's okay to jump into the deep end even if you don't know how to swim--you'll learn real fast that way (occasionally)

[21:07] * nothingmuch can vouch for that

[21:07] <nothingmuch> at least perlbot karma nothingmuch can

[21:07] <nothingmuch> luckily in puters you can't really drown either =)

[21:08] <Khisanth> PerlJam: or you drown!

[21:08] <stevan> svn revert is my friend :)

[21:08] <PerlJam> Khisanth: metaphorical drowning is the best kind.

[21:09] <Khisanth> only if you enjoy drowning

[21:09] <stevan> svn++

[21:09] <nothingmuch> it's like reading a book about heroin addicts

[21:09] <nothingmuch> if it's really well written, you can nearly experience it

[21:09] <nothingmuch> but then the book ends

[21:09] <nothingmuch> and woah! you're not a junkie!

[21:09] <nothingmuch> gugod++

[21:09] <nothingmuch> stevan?

[21:10] <stevan> nothingmuch?

[21:10] <PerlJam> Khisanth: no, because once you've metaphorically drowned, you get that "phew! I'm glad *that's* over" kind of feeling and hopefully you've learned something

[21:10] <theorbtwo> nothingmuch++

[21:10] <nothingmuch> gugod++

[21:10] <PerlJam> nothingmuch: Have you ever read the book _Bore Hole_  ?

[21:10] * gugod *phew*

[21:10] <nothingmuch> gugod fixed jabbot, so it doesn't thing 'stevan is gone' or something

[21:10] <nothingmuch> and when people ask 'what?' it won't repeat the last 'what is ...' question

[21:10] <nothingmuch> thanks gugod!

[21:11] <PerlJam> what?

[21:11] <PerlJam> :)

[21:20] * nothingmuch delays bindSomeParams till larry replies

[21:20] <nothingmuch> does someone have a todo for me?

[21:21] <luqui> nothingmuch: about threading

[21:21] <luqui> http://groups-beta.google.com/group/perl.perl6.language/browse_frm/thread/5c925e833a73846f/678f5ac96b258981?q=threading+perl6-language#678f5ac96b258981

[21:21] <luqui> musings.  responses about it would be nice

[21:21] <luqui> (bring it up on p6l if you like)

[21:21] <stevan> nothingmuch: please do s:g:perl5/// :)

[21:22] <nothingmuch> stevan: i think that is beyond me, but i'll try

[21:22] <theorbtwo> nothingmuch, do -Ifoo

[21:22] <stevan> if  you can just grok how regexp are made that might help

[21:22] <nothingmuch> -I like in PERL6LIB?

[21:22] <theorbtwo> Yeah.

[21:22] <luqui> p6 design call going on now

[21:23] <luqui> any Great Questions, shout

[21:23] * nothingmuch gave a bunch of "details details" questions about param binding on p6l

[21:23] <nothingmuch> but aside from that i'm happy

[21:23] <nothingmuch> except for what we discussed earlier

[21:23] <nothingmuch> idea:

[21:23] <nothingmuch> is lazy semantics:

[21:23] <nothingmuch> it's an lvalue trait

[21:24] <nothingmuch> it causes the assignment to be made into a closure

[21:24] <nothingmuch> which executes as late as possible

[21:24] <nothingmuch> instead of now

[21:24] <nothingmuch> it's clear, it's controlled

[21:24] <nothingmuch> and it's, useful

[21:24] <nothingmuch> but it's not the default

[21:24] <nothingmuch> and it's not too magical

[21:27] <luqui> hmm...

[21:27] <luqui> i think that deserves a proposal to p6l

[21:27] <luqui> and I promise that I'll think about it and reply :-)

[21:28] <nothingmuch> ok, i'll do that

[21:28] <nothingmuch> but first i'll try to help stevan with :g

[21:28] <stevan> yeah!!!!!!!!!

[21:28] <PerlJam> lvalue trait?

[21:28] <stevan> nothingmuch + Inf

[21:29] <nothingmuch> PerlJam: the receiver gets to decide

[21:29] <PerlJam> It sounds more like a trait of the operator than the lvalue

[21:29] <nothingmuch> wait, no, that doesn't make sense

[21:29] <nothingmuch> mostly i'd like it in the sender

[21:29] <nothingmuch> but sometimes in the receiver

[21:29] <luqui> but it could be = that does the magic by checking the trait

[21:29] <nothingmuch> you're right, more of a trait of the operator

[21:30] <nothingmuch> and also, lazily assigned values passed on simply retain laziness

[21:30] <nothingmuch> (see also fruitful IRC backlog with theorbtwo and someone else about how this could be fun)

[21:30] <nothingmuch> (this could be done with taint generalization!!!! reply to that message!)

[21:31] <theorbtwo> Sounds like a trait of the values: if either side is but lazy then the thing being assined to ends up but lazy.

[21:31] <PerlJam> nothingmuch: when would you want it in the receiver?

[21:31] <theorbtwo> (Which makes lazyness quite infectious.)

[21:31] <nothingmuch> PerlJam: i don't know

[21:31] <PerlJam> theorbtwo: yeah, it could be a trait of the rvalue.

[21:31] <nothingmuch> it just made sense for a while

[21:32] <PerlJam> (so far, only rvalue traits make sense anyway :-)

[21:32] <nothingmuch> it could be a trait of the container

[21:32] <nothingmuch> actually the context

[21:32] <nothingmuch> which belongs to the container and the operator together

[21:33] <theorbtwo> I'm thinking on the rvalue or the operator makes sense.

[21:33] <theorbtwo> Though I'm not sure how traits on an infix operator would look.

[21:33] <nothingmuch> i see this relating to:

[21:34] <nothingmuch> my $var = BEGIN { make_a_value }

[21:35] <theorbtwo> Hm, I wonder if a lazy prefix operator is enough.

[21:35] <theorbtwo> my $var = lazy (42!);

[21:35] <theorbtwo> (Er, except there aren't numeric postfix operators, but you get the point.)

[21:36] <nothingmuch> type inferrence could help make things like that optimized lazy

[21:36] <nothingmuch> if luqui gets his way, we could have auto laziness in subsets where the compiler recognizes ops are pupre

[21:36] <nothingmuch> and then you wouldn't have to do that

[21:37] <nothingmuch> what it /would/ be useful for is to say:

[21:37] <nothingmuch> even though this op reads a file, and that should in general not be lazy

[21:37] <nothingmuch> i /do/ want it to be lazy

[21:37] <nothingmuch> because for this case i don't care

[21:37] <PerlJam> Hmm.

[21:37] <nothingmuch> my @array will vivify { }

[21:37] <nothingmuch> that's basically what i want

[21:38] <nothingmuch> but i don't want to tie

[21:38] <nothingmuch> and i don't want to if $sub ~~ Sub

[21:38] <nothingmuch> and so on, and so forth

[21:38] <nothingmuch> and i want to be able to send this stuff safely into the unknown

[21:38] <nothingmuch> that is, someone elses well behaved p6 code

[21:39] <PerlJam> Suddenly it seems that control of the lazy is ueber important.  Maybe it's just me though.

[21:39] <nothingmuch> lazy without control will not work in a non pure language, period

[21:40] <nothingmuch> unless it's guaranteed to be safe

[21:40] <nothingmuch> like haskell arranges for it to be

[21:40] <nothingmuch> it won't be safe

[21:40] <nothingmuch> and someone will cry

[21:40] <nothingmuch> or arrange for nested laziness myself

[21:40] <nothingmuch> i don't like the fact that gather will pause execution of a closure until it needs to take

[21:40] <PerlJam> perhaps we need a use-like operator called "be" ... then we can lexically scope laziness with "be lazy"  :-)

[21:40] <nothingmuch> if it were lazy i would expect it to be all or nothing

[21:41] <nothingmuch> but going that far, for coolness, or whatever, is just too much

[21:41] <nothingmuch> =)

[21:41] <nothingmuch> use sloth;

[21:41] <nothingmuch> but then again

[21:42] <nothingmuch> since 'use integer' was made into a type system thingy

[21:42] <nothingmuch> for better fine grained control

[21:42] <nothingmuch> i think we should aim for this in new features too

[21:42] <Corion> How do I find out in Haskell if a string starts with a certain substring?

[21:43] <nothingmuch> also, laziness is definately /not/ good backwards compatibility behavior

[21:43] <nothingmuch> because many people optimize with strictness in mind

[21:43] <PerlJam> perl 5's "use integer" has always annoyed me because it doesn't do what I want.

[21:43] <nothingmuch> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html

[21:44] <theorbtwo> You match it against ('x':rest), and rest will be the rest.

[21:44] <nothingmuch> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html

[21:44] <Corion> theorbtwo: That means I'll have to manually to a match for every element in the string/list ? Ugh.

[21:44] <theorbtwo> Note that that doesn't follow for longer strings -- it's ('-':'I':rest) for the rest.

[21:45] <Corion> theorbtwo: Ah - that's nicer :)

[21:45] <theorbtwo> I don't know if you can match "-I" ++ rest -- probably not, since ++ is a regular function but : is a constructor.

[21:46] <Corion> theorbtwo: How did you know that I want to match "-I" ? :-))

[21:46] * theorbtwo is psychic.

[21:46] <PerlJam> you could always  take 2 string

[21:47] <PerlJam> (and drop 2 string for when you need the rest)

[21:48] <nothingmuch> stevan: i think this is not going to be too easy

[21:48] <stevan> nothingmuch: yup :)

[21:48] <stevan> autrijus said it was,.. but I dont believe him

[21:48] <stevan> autrijus++

[21:49] <stevan> nothingmuch++ # for just looking at it

[21:49] <nothingmuch> i haven't given up yet =)

[21:49] <stevan> nothingmuch++ # for perseverence

[21:49] <stevan> perlbot highest karma

[21:49] <nothingmuch> bah

[21:49] <perlbot> The top 5 karma entries: nothingmuch: 40, autrijus: 40, C: 27, ~brad2901: 26, stevan: 24

[21:50] <nothingmuch> nothingmuch--

[21:50] <stevan> C--

[21:50] <PerlJam> autrijus++ because he can never have enough

[21:50] <stevan> who is brad2901?

[21:50] <nothingmuch> tr/,/d

[21:50] <nothingmuch> he came in, and implemented some important feature (given, was it?) in a blitz

[21:51] <nothingmuch> and, i think that was it

[21:51] <nothingmuch> i think rregex just doesn't really provide the interface

[21:52] <nothingmuch> it only knows /i and /s vs normal

[21:53] <stevan> but I think /g would work just like /i and /s

[21:53] <nothingmuch> yeah

[21:53] <stevan> it seemed to me that PCRE just too a combined flag or "options"

[21:53] <nothingmuch> but this would mean fixes at many levels

[21:53] <nothingmuch> PCRE seems to use an int

[21:54] <stevan> yeah, if you look at compile in src/RRegex/PCRE.hs

[21:54] <stevan> -> Int    	-- ^ Flags (summed together)

[21:55] <nothingmuch> uhuh

[21:55] <nothingmuch> that's the first place i looked

[21:55] <stevan> I had original made my changes at line 220 in src/RRegex/Syntax.hs

[21:55] <stevan> but then I realized it was commented out 

[21:55] <nothingmuch> perhaps with [RegexOpts] where data RegexOps = I | G | S ...

[21:55] <nothingmuch> now i want to see how i can make mkRegexWithOpts a bit nicer

[21:56] <nothingmuch> and then they are simply applied to the flag in order

[21:56] <stevan> yeah I messed with mkRegexWithOpts as well

[21:56] <stevan> that was the only thing which worked, although it spewed warnings

[21:57] <stevan> the one part I was unsure of was that there is no pcreGreedy

[21:57] <stevan> just an pcreUngreedy

[21:57] <nothingmuch> greedy = :g?

[21:57] <stevan> yeah

[21:58] <nothingmuch> why not "global"?

[21:58] <stevan> oh

[21:58] <stevan> uhm

[21:58] <stevan> I am not sure what the long form is

[21:58] <stevan> but it makes it match all the instances

[21:59] <nothingmuch> oh well

[21:59] <stevan> so I think of it as greed

[21:59] <stevan> y

[22:01] <Khisanth> stevan: for :g?

[22:01] <PerlJam> historically that's "global".  "greedy" is something else entirely  :)

[22:01] <stevan> doesn't s///g match greedily?

[22:01] <stevan> or is my nomenclature off?

[22:02] <nothingmuch> g is the 9th bit

[22:02] <Khisanth> erm no

[22:02] <Khisanth> that g is global :)

[22:02] <PerlJam> stevan: if you mean "globally", then yes. :)

[22:02] <Khisanth> greedy is on by default

[22:02] <theorbtwo> Greedy is if * matches as much as possible or as little as possible.

[22:02] <nothingmuch> Ungreedy makes .* behave like .*?

[22:02] <nothingmuch> i hope

[22:02] <theorbtwo> (In perl, plain * is greedy; *? is ungreedy.)

[22:02] <Khisanth> nothingmuch: with pcre?

[22:02] <stevan> ok, ignore me then,.. i mean global :)

[22:02] <nothingmuch> :g really just reiterates

[22:02] <nothingmuch> i don't know, i hope

[22:02] <nothingmuch> =)

[22:02] <nothingmuch> and i think reiterating is the wrapper's job

[22:03] <stevan> pcreUngreedy,   --  matches are not greedy by default

[22:03] <Khisanth> well not quite, according to pcre manpage

[22:03] <nothingmuch> hmmm

[22:03] <Khisanth> ungreedy makes * ungreedy but *? greedy

[22:03] <stevan> according to src/RRegex/PCRE.hs

[22:03] <PerlJam> Khisanth: that's so evil.

[22:03] <theorbtwo> Uff.  That's confusing.

[22:03] <stevan> *glug* *glug* <<< that is me drowning  :P

[22:03] <Khisanth> that particular option also makes it incompatible with Perl RE :)

[22:04] <nothingmuch> i think we should all read pcre docs first

[22:04] <Khisanth> should this really be including features that make it incompatible with Perl's RE for better or worse?

[22:04] <Corion> theorbtwo: How did you know that I want to match "-I" ? :-))

[22:04] <PerlJam> Khisanth: why not?  pcre will never be compatible with p6rules.

[22:04] <Corion> Ooops - sorry

[22:05] <theorbtwo> Hit talk, not reload.  ;)

[22:05] <PerlJam> Khisanth: as long as it's clear that you're using PCRE

[22:05] <Khisanth> PerlJam: neither is Perl's RE...

[22:05] <nothingmuch> perlbot nopaste

[22:05] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[22:06] <pasteling> "nothingmuch" at 212.143.91.217 pasted "pcre docs: ungreedy" (6 lines, 294B) at http://sial.org/pbot/8549

[22:06] <Khisanth> PerlJam: I was hoping that if I used perl5 REs in perl6, they would actually work exactly the same :/

[22:06] <Khisanth> you know, least suprise and all ...

[22:06] <stevan> Khisanth: I wouldnt worry I think PCRE is temporary

[22:08] <nothingmuch> By calling pcre_exec() multiple times with appropriate argu-

[22:08] <nothingmuch>        ments, you can mimic Perl's /g option, and it is in this kind of imple-

[22:08] <nothingmuch>        mentation where \G can be useful.

[22:08] <nothingmuch> you need to send it startoffset

[22:08] <nothingmuch> http://www.pcre.org/pcre.txt

[22:11] <nothingmuch> executeExtract

[22:11] <nothingmuch> we seem to want that for :g

[22:12] <stevan> execute calls c_pcre_exec too

[22:13] <nothingmuch> *yawn*

[22:15] <stevan> wow,.. its really snowing here now

[22:15] <stevan> nothingmuch: line 76 in Syntax.hs maybe?

[22:16] <nothingmuch> 72?

[22:16] <nothingmuch> it just makes a lazilist with matchOnce ;-)

[22:18] <stevan> *sigh* why does autrijus have to sleep :P

[22:18] <pasteling> "Corion" at 217.86.59.98 pasted "Types question - why doesn't this work when I add the types?" (15 lines, 393B) at http://sial.org/pbot/8550

[22:19] <nothingmuch> there's actually an infix =~

[22:19] <Corion> I got it working by punting and filtering out the empty string, but I think I should use "Maybe String" and "Nothing" instead

[22:19] <nothingmuch> cool =)

[22:20] <Corion> (and when I transfer my code into Run.hs, it blows up because of incompatible types still)

[22:22] <nothingmuch> Corion: Maybe stuff means you must put monad fun into it all

[22:22] <Corion> nothingmuch: I guess it's just too late in the evening for my brain %-)

[22:29] <nothingmuch> Corion: perhaps another solution:

[22:29] <pasteling> "nothingmuch" at 212.143.91.217 pasted "-Ifoo" (14 lines, 233B) at http://sial.org/pbot/8551

[22:29] <nothingmuch> maybe you like that better

[22:30] <nothingmuch> or even nicer:

[22:30] <pasteling> "nothingmuch" at 212.143.91.217 pasted "with drop" (12 lines, 204B) at http://sial.org/pbot/8552

[22:31] <Corion> nothingmuch: Yeah - that's OK too, but I would really want to introduce the types ( a -> Maybe a )... But maybe I just don't understand what the types are for :)

[22:31] <nothingmuch> what types?

[22:31] * nothingmuch didn't do any types

[22:33] <Corion> nothingmuch: Yes, but I want to do types.

[22:33] <nothingmuch> what for?

[22:33] <nothingmuch> line 48 of Run.hs:     (libs, args) <- getLibs environ args

[22:34] <Corion> nothingmuch: Or rather, when integrating the stuff with Pugs, I get type errors, so something in my understanding must be wrong

[22:34] <Corion> nothingmuch: Line 48 looks different in my version, but I added something to that effect, yes.

[22:35] <Corion> (or did I miss somebody adding -I support already? :) )

[22:35] <nothingmuch> i don't think

[22:36] <nothingmuch> that's what i suggested changing

[22:37] <Corion> Ah. It was just plain stupidity on my part. Cargo-culting only gets you so far :)

[22:38] <nothingmuch> i have a diff you might be interested in

[22:38] <Corion> (at least Pugs is now compiling again. I should now write a test against -I ...)

[22:38] <nothingmuch> want to share?

[22:39] <ninereasons> is a "topic" going to be read-only by default?

[22:39] <pasteling> "Corion" at 217.86.59.98 pasted "-I support for Pugs (preliminary, only against Run.hs, needs equivalent change in Main.hs)" (23 lines, 785B) at http://sial.org/pbot/8554

[22:39] <Corion> nothingmuch: Needs the reverse of your line 48 applied:

[22:39] <Corion>     libs    <- getLibs (args) (environ)

[22:39] <Corion> ... and the same in Main.hs

[22:40] <nothingmuch> ok, that's good

[22:40] <nothingmuch> except, you need to also return the new arg list

[22:40] <stevan> ninereasons: why do you ask?

[22:40] <nothingmuch> so that -Ifoo doesn't end up in @*ARGS

[22:40] <ninereasons> stevan, I wondered if we would be able to do something like map { $_++ }  @a

[22:40] <Corion> nothingmuch: Ooops - yeah, that's true ... But not tonight anymore :)

[22:41] <nothingmuch> want me to take it on from there?

[22:41] <nothingmuch> it's a simple fix

[22:41] <Corion> BTW, Failed 25/118 test scripts, 78.81% okay. 125/2867 subtests failed, 95.64% okay. <- nothing new broke, right?

[22:41] <Corion> nothingmuch: Yes, please do :)

[22:41] <nothingmuch> i would go with isLibArg

[22:41] <nothingmuch> and map drop 2

[22:41] <nothingmuch> and partition on that

[22:41] <nothingmuch> ok

[22:41] <stevan> ninereasons: I dont think that would work in Pugs right now, but I imagine it will in perl6

[22:41] <Corion> nothingmuch: Ah, well - I'm not wed to my implementation :)

[22:41] <nothingmuch> just because it's easier to shove it to partition ;-)

[22:42] <Corion> nothingmuch: I like the pattern-matching declaration style, but the other way seems just as good. I don't know any Good Style for Haskell anyway :)

[22:42] <Corion> (and now it's bedtime for me. I expect results tomorrow, nothingmuch :))

[22:42] <nothingmuch> ciao

[22:43] <Corion> Good night all :)

[22:43] <stevan> good night Corion 

[22:44] <ninereasons> stevan, am I correct to have supposed that my question concerns the properties of a "topic" ( that: "Topic eq $_")?

[22:44] <stevan> yes (but I am no expert on this)

[22:45] <stevan> there are many variables in Pugs which should be mutable, but are immutable instead

[22:45] <stevan> but that is a TODO item

[22:46] <ninereasons> ok - that gets to the real issue. Thanks.

[22:46] <ninereasons> I'm still trying to sort out the TODOs and the real constraints

[22:48] <nothingmuch> ninereasons: please write tests for these stuff

[22:49] <nothingmuch> things

[22:49] <nothingmuch> they make it impossible not to define it later

[22:49] <nothingmuch> if you need commit access autrijus, obra, stevan or me can all give you that

[22:49] <ninereasons> I'm not a programmer, though, nothingmuch.  

[22:49] <ninereasons> I am a luser of perl

[22:50] <nothingmuch> tests are in perl =)

[22:51] <nothingmuch> (perl6, that is)

[22:51] <ninereasons> I would like to help; but I don't want to screw things up with bad commits

[22:52] <stevan> ninereasons: thats what svn is for :)

[22:52] <nothingmuch> don't worry about that

[22:52] <nothingmuch> revision control lets you or anyone else cleanup

[22:52] <nothingmuch> and you can always test before you commit

[22:52] <stevan> we can always revert back if there is something wrong

[22:53] <ninereasons> then I would like to help

[22:53] <nothingmuch> ok, so just go for it =)

[22:54] <nothingmuch> any help is appreciated

[22:54] <nothingmuch> if you write a test, which is 50% good

[22:54] <nothingmuch> that's still 80% of the work

[22:54] <ninereasons> (since y'all are being so careless^h^h^h^h^h^h nice)

[22:54] <nothingmuch> carelessness has brought this project where it is today

[22:54] <nothingmuch> it's autrijus' mantra

[22:54] <nothingmuch> and it works =)

[22:54] <theorbtwo> You're a meta-comitter now, nm?

[22:54] <stevan> nothingmuch++

[22:55] <nothingmuch> committerbitter

[22:55] <nothingmuch> =)

[22:55] <stevan> me too :)

[22:55] <nothingmuch> you should also be, theorbtwo

[22:55] <nothingmuch> you have a funny sleep cycle

[22:55] <theorbtwo> Very.

[22:55] <stevan> i went to sleep on night not one,.. and woke up the next morning and I was :P

[22:55] <stevan> with theorbtwo we would be covered 24/7 for sure :P

[22:56] <stevan> all major time zones I think

[22:56] * theorbtwo ponders a reorg of AUTHORS.

[22:56] <stevan> theorbtwo: I think it is alphabetical

[22:56] <theorbtwo> It is.

[22:56] <stevan> to minimize egos maybe?

[22:57] <theorbtwo> To whit, alphebetical by what appears first on the line.

[22:57] <theorbtwo> Well, I did it because that's how Aut had it.  I suspect Aut had it that way because that is the correct way to alphebetize Han names.

[22:59] * theorbtwo wonders if autrijus minds "aut".

[22:59] <stevan> how were you going to re-org it anyway?

[22:59] <nothingmuch> i think Autrijus Tang is actually reversed for a westerny appearance, otherwise Bestian Tang won't make sense, right?

[23:00] <nothingmuch> we'd better ask him

[23:00] <stevan> who is Bestian?

[23:00] <stevan> iblech++ # for Geo::Distance this time

[23:00] <theorbtwo> Oh, I assumed they were unrelated people who happened to share a family name.  There aren't that many of them.

[23:02] <nothingmuch> in the perl6 interview he autrijus mentiones 'math minded brother Bestian'

[23:03] <theorbtwo> I meant reorg it to be more like the linux kernel's authors file, which is more like a flattened hash.

[23:03] <jabbot> pugs - 1069 - Port of Geo::Distance 0.08.

[23:03] <jabbot> pugs - 1068 - more File::Spec documentation and cleanu

[23:04] <stevan> never seen it, so I have no idea what you are talking about :)

[23:04] <nothingmuch> i want one variation that takes two args

[23:04] <nothingmuch> how do i do context polymorphic functions in haskell?

[23:04] <nothingmuch> and gives back a pair

[23:04] <nothingmuch> and one that takes one arg

[23:04] <nothingmuch> and gives back a list

[23:05] <stevan> ok, time for me too eat and hang with the wife and kids

[23:05] <stevan> see you guys later 

[23:05] <nothingmuch> beh!

[23:05] <nothingmuch> family smushiness is for nerds!

[23:05] <stevan> nothingmuch: isnt it past your bedtime :P

[23:06] <nothingmuch> if you are really a geek then you would be more|less nerdy

[23:06] <nothingmuch> more&less nerdy

[23:06] <nothingmuch> pushing it, stevan

[23:06] <stevan> nothingmuch++

[23:06] <stevan> theorbtwo++

[23:06] <stevan> autrijus++

[23:06] <nothingmuch> everyone++

[23:07] <stevan> iblech++ # for the Email::Simple test suite in perl6 too 

[23:07] <nothingmuch> we are very touchy-feely with all this ++ stuff

[23:07] <nothingmuch> we should start hugging each other

[23:07] <stevan> nothingmuch: its a virtual hug over the wires

[23:07] <stevan> ok,.. I am going for real now

[23:07] <stevan> adios

[23:07] <nothingmuch> ciao!

[23:09] <theorbtwo> Later, stevan.

[23:10] * theorbtwo wonders.

[23:10] <theorbtwo> perlbot karma everyone

[23:10] <perlbot> Karma for everyone: 2

[23:23] * theorbtwo wishes there was an easy way to say "keep going till you can't keep going no more" in a regex.

[23:23] <theorbtwo> That is, make everything optional.

[23:23] <theorbtwo> Sadly, I think that's a bit too close to AI to be doable.

[23:26] <luqui> theorbtwo: why do you want that?

[23:27] <theorbtwo> What I'm doing at present moment is a regex to grok the (present) AUTHORS format.

[23:27] <theorbtwo> ...in which pretty much everything is optional.

[23:28] <luqui> what's wrong with a bunch of question-marks?

[23:29] <theorbtwo> It's rather verbose, and I keep having to introduce (?: ... ) blocks for them.

[23:29] <luqui> oh, that's all

[23:29] <luqui> I thought you were talking about a real problem

[23:30] <luqui> anyway, it really is bedtime now (up for 23 hours).  night everybody

[23:30] * luqui &

[23:30] <theorbtwo> Sleep well.

[23:30] <theorbtwo> And long!

[23:32] <ihb> luqui: is development of Math::LOgic::Predicate dead?

[23:43] <nothingmuch> pugs -Ifoo is implemented

[23:44] <nothingmuch> twas a bit tricker than I thought

[23:50] <nothingmuch> 1070

[23:53] <jabbot> pugs - 1070 - pugs -Ilib hack (getArgs added in getLib

