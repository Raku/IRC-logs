[00:03] <eric256> ?eval 3e5.perl

[00:03] <evalbot_7621> "300000/1" 

[00:03] <eric256> ?eval (3e5.5).perl

[00:03] <evalbot_7621> Error:  unexpected "." expecting digit, "_", term postfix, operator or ")" 

[00:03] <eric256> ?eval (3/5).perl

[00:03] <evalbot_7621> "3/5" 

[00:09] <mrborisguy> does pugs use the Perl6 Prelude right now?  (src/perl6/Prelude/PIR.pm)

[00:11] <dolmen> ?eval (3eR).perl

[00:11] <evalbot_7621> Error:  unexpected "e" expecting digit, "_", "-", "+", exponent, term postfix, operator or ")" 

[00:11] <dolmen> ?eval (3e5).perl

[00:11] <evalbot_7621> "300000/1" 

[00:11] <dolmen> ?eval (3e5/5).perl

[00:11] <evalbot_7621> "60000/1" 

[00:11] <dolmen> ?eval (3e5/1).perl

[00:11] <evalbot_7621> "300000/1" 

[00:11] <mrborisguy> ?eval eval_parrot( "I0 = 8\nprint IO" );

[00:11] <evalbot_7621> Error: No compatible subroutine found: "&eval_parrot" 

[00:12] <dolmen> ?eval (3e5/Inf).perl

[00:12] <evalbot_7621> "0.0" 

[00:12] <dolmen> ?eval (1/Inf).perl

[00:12] <evalbot_7621> "0.0" 

[00:12] <mrborisguy> or does the Prelude just not really do anything right now?

[00:13] <dolmen> sorry, don't know

[00:13] <dolmen> ?eval (Inf ^ 2).perl

[00:13] <evalbot_7621> "(2 ^ Inf)" 

[00:13] <dolmen> ?eval (Inf ^^ 2).perl

[00:13] <evalbot_7621> "bool::false" 

[00:13] <dolmen> ?eval true

[00:13] <evalbot_7621> Error:  unexpected end of input expecting term 

[00:14] <dolmen> ?eval bool::true

[00:14] <evalbot_7621> bool::true 

[00:14] <dolmen> ?eval bool::true.perl

[00:14] <evalbot_7621> Error:  unexpected "p" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[00:14] <dolmen> ?eval (bool::true).perl

[00:14] <evalbot_7621> "bool::true" 

[00:14] <eric256> yes it uses the prelude

[00:14] <eric256> its compiled during make

[00:14] <dolmen> ?eval (4 ^ 2).perl

[00:14] <evalbot_7621> "(2 ^ 4)" 

[00:14] <dolmen> ?eval (4 ^^ 2).perl

[00:14] <evalbot_7621> "bool::false" 

[00:14] <eric256> ?eval (4**2).perl

[00:14] <evalbot_7621> "16/1" 

[00:14] <dolmen> ?eval (4 ^^ 4).perl

[00:14] <evalbot_7621> "bool::false" 

[00:15] <dolmen> what is ^ ?

[00:15] <dolmen> ?eval (4 ^^ 4/bool::true).perl

[00:15] <evalbot_7621> "bool::false" 

[00:15] <dolmen> ?eval (4 ^^ 4/7).perl

[00:15] <evalbot_7621> "bool::false" 

[00:16] <dolmen> ?eval bool::true + 2

[00:16] <evalbot_7621> Error: No compatible subroutine found: "&bool::true" 

[00:16] <dolmen> ?eval (bool::true) + 2

[00:16] <evalbot_7621> 3.0 

[00:16] <mrborisguy> dolmen: don't have a perl6 of your own to test on? :D

[00:16] <dolmen> no

[00:16] <dolmen> sorry

[00:16] <scook0> dolmen: ^ is a one() junction

[00:17] <scook0> ?eval ?( (1 ^ 2 ^ 3) == 1 )

[00:17] <evalbot_7621> bool::true 

[00:17] <scook0> ?eval ?( (1 ^ 1 ^ 3) == 1 )

[00:17] <evalbot_7621> bool::false 

[00:24] <mrborisguy> dolmen: I don't care if you do... but you can ask Juerd for an account on feather.perl6.nl too

[00:24] <mrborisguy> he gives 'em out so you can play with p6

[00:24] <mrborisguy> that's what I do

[00:33] <Juerd> mrborisguy: dolmen left 2 minutes before you said that.

[01:24] <eric256> quite today...except for me and dolmen blabbing to ourselves

[01:24] <eric256> lol

[01:25] <luqui> blabbing to evalbot you mean

[01:25] <eric256> yea, not sure thats much better though

[01:26] <luqui> well, we get to see the weird behavior you recover, like:

[01:26] <luqui> ?eval bool::false / 2

[01:26] <evalbot_7621> 0.0 

[01:26] <luqui> er, oh!

[01:27] <luqui>  / binds tighter than ^^, of course, so that stuff that dolmen did makes sense

[01:28] <putter> hey folks

[01:28] <luqui> hi putter 

[01:28] <scook0> hey putter

[01:28] <eric256> hola

[01:29] <putter> as dolmen just observed, bool::true/false have parsing issues currently.

[01:29] <putter> ?eval (0 ?? bool::false !! 0)

[01:29] <evalbot_7621> Error:  unexpected ")" expecting "x", "d", octal digit, "o", "b", digit, fraction, exponent, term postfix, operator, ":", "," or "!!" 

[01:29] <putter> ?eval (0 ?? (bool::false) !! 0)

[01:29] <evalbot_7621> 0 

[01:30] <luqui> ?eval 0 ?? bool::false() !! 0

[01:30] <evalbot_7621> 0 

[01:30] <luqui> the arity of bool::true/::false is not known at compile time

[01:30] * eric256 loves how putter shows up knowing stuff that happened before he came in. lol

[01:30] <luqui> that's my guess at least

[01:31] <putter> I was so happy I got error line numbers working well when I hit that... :)  (new p5 backend)

[01:31] <scook0> yeah, I don't think 0-ary subs are treated specially by the parser atm

[01:31] <luqui> ?eval sub foo() { "hello" }    say foo 1

[01:31] <evalbot_7621> Error:  unexpected "1" expecting "(", term postfix, operator, ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[01:31] <putter> re happening, http://colabti.de/irclogger/irclogger_logs/perl6 is your friend...

[01:31] <luqui> no, I think they are

[01:32] <eric256> i know putter, its still funny

[01:32] <putter> :)

[01:33] <putter> ?eval sub foo(){say "hi"} (1 ?? foo !! 0)

[01:33] <evalbot_7621> hi bool::true 

[01:34] <scook0> I guess they are then

[01:37] <putter> iblech: from a few? days ago: eval() should be working in PIL-Run.  :lang<perl6> and :lang<perl5> at least.  Not yaml or haskell.

[01:39] <scook0> (oh, now I see where they're handled)

[01:44] <putter> autrijus: is there a calendar time estimate on when pil2 might be available?

[01:47] <scook0> stevan__: ping # quick note re: 'metaclass'

[01:48] <eric256> ?eval ((1 =>2)).perl

[01:48] <evalbot_7621> "(1 => 2)" 

[01:48] <eric256> ?eval eval(((1 =>2)).perl).perl

[01:48] <evalbot_7621> "(1 => 2)" 

[01:48] <putter> after burning more hours than I'd like to think about doing a p5 backend overhaul, mostly writing things which will be trashed the minute pil2 exists, I'm reminded of my conviction that pil2 is a prerequisite for doing a real p5 backend.

[01:49] <putter> not that one cant do without.  witness pil2js.  but since the target is oo, you either approach things the NotRightWay(tm), like PIL-Run, or spend hours like water trying to fake around pil1.

[01:49] <eric256> "spend hours like water" ... ?

[01:50] <putter> lots of it goes by and the scene looks quite unchanged

[01:50] <putter> ;)

[01:50] <eric256> lol. okay

[01:51] <putter> ach.  /me is just a wee bit frustrated at the moment.

[01:53] <eric256> any specific?

[01:53] * eric256 watches as a feathers build process passes my local one started 15min earlier. lol

[01:56] <putter> one of those exercises where things are clearly converging, so you keep on making the "ok, continue just a little bit more, rather than switching to other things" (eg, rules engine).  but time estimates keep getting blown, so variance grows to the point of uselessness.  "done sometime between this evening and next year".  and you look back and realize the hours spent could have bought much more useful things. :/

[01:57] <stevan__> scook0: pong # what about metaclasses?

[01:57] <eric256> as long as you learn something from the hours spent then it was worth it. ;)  i try to view everything as a learning experience...even things that i know i could have done better in hind site

[01:58] * stevan__ can only ask, then backlog ,.. sorry :)

[01:58] <scook0> stevan__: please don't equivocate 'metaclass' and 'class metaobject'

[01:58] <scook0> it's just that it's really confusing

[01:59] <scook0> ideally, I'd like 'class metaobject' to be an object, and a 'metaclass' to be the class of that object

[01:59] <scook0> just a suggestion

[01:59] * eric256 's mind is going to turn to jello if he hears meta, class and object used ever agian. ;)

[02:00] <putter> eric256: true.  knew someone who treated major life disasters with a "I will put whatever effort needed looking, because there damn well better be something good in here proportional to the pain!".  ;)  even worked sometimes. :)

[02:01] <putter> hey stevan__

[02:01] <eric256> arg...stepped on tack strip in the carpet and it totaly chewed up my foot...stupid tack strips

[02:02] <putter> ouch

[02:02] <eric256> big wholes and blood.. is this pugs EVER going to finish compiling!!

[02:04] <putter> stevan__: any thoughts on why Chaos's  sub ::opaque_instance_attr : lvalue (line 40) might sometimes blow out with a Not an ARRAY reference?  no doubt I'm abusing it, but I wondered if you'd seen the symptom before.  tnx

[02:08] <eric256> ?eval :b(1).perl

[02:08] <evalbot_7621> "(\"b\" => 1)" 

[02:09] <eric256> ?eval ("b" => 1).perl

[02:09] <evalbot_7621> "(\"b\" => 1)" 

[02:09] <eric256> ?eval :b(1).ref

[02:09] <evalbot_7621> ::Pair 

[02:09] <putter> ?eval sub f(*%h){} f:a()

[02:09] <evalbot_7621> undef 

[02:10] <putter> ?eval sub f(*%h){say %h} f:a()

[02:10] <evalbot_7621> a1 bool::true 

[02:10] <putter> ?eval sub f($x,*%h){say "$x--",%h} f:a(6)

[02:10] <evalbot_7621> Error: Undeclared variable: "$x" 

[02:10] <putter> ?eval sub f($x,*%h){say "$x--",%h} f:a (6)

[02:10] <evalbot_7621> 6--a1 bool::true 

[02:11] <putter> ?eval sub f($x,*%h){say "$x--",%h} f:a(3)(6)

[02:11] <evalbot_7621> 6--a3 bool::true 

[02:12] <putter> ?eval sub f($x,*%h){say "$x--",%h} f(6):a

[02:12] <evalbot_7621> 6--a1 bool::true 

[02:12] <putter> ?eval sub f($x,*%h){say "$x--",%h} f(6) :a

[02:12] <evalbot_7621> Error:  unexpected ":" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[02:12] <eric256> ?eval sub x (@a) { for @a { print } }; x(1=>2);

[02:12] <evalbot_7621> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[02:12] <eric256> any idea how to fix that putter?

[02:12] <putter> hmm...

[02:12] <luqui> ?eval sub x (*@a) { for @a { print } }  x(1 => 2)

[02:12] <evalbot_7621> undef 

[02:13] <luqui> ?eval sub x (*@a) { say +@a }  x(1 => 2)

[02:13] <evalbot_7621> 0 bool::true 

[02:13] <eric256> ?eval sub x (@a) { @a.perl.say; for @a { print } }; x(1=>2);

[02:13] <evalbot_7621> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[02:13] <eric256> ?eval sub x (Pair @a) { @a.perl.say; for @a { print } }; x(1=>2);

[02:13] <evalbot_7621> [(1 => 2)] undef 

[02:13] <putter> "fix" as in workaround?  my fuzzy impression is Pair handling is currently a bit kludgy.

[02:13] <eric256> nah i have a work around. just though maybe you would have a real fix

[02:15] <putter> my fuzzy understanding is real fix is thought to consist of language spec change and non-trivial changes to pugs

[02:15] <eric256> gotcha...just seemed like since adding Pair fixed it, there might be an easier fix

[02:16] <eric256> ?eval  { a => [1,2,3] }.perl

[02:16] <evalbot_7621> "\{(\"a\" => [1, 2, 3])}" 

[02:17] <eric256> ?eval  ~{ a => [1,2,3] }

[02:17] <evalbot_7621> "a\t1 2 3\n" 

[02:18] <putter> my fuzzy recollection is there were a bunch of autrijus commit messages "drat, that didnt work, backing out" re Pairs.  so easy seems unlikely. ;)

[02:18] <eric256> lol. alright

[02:18] <eric256> ?eval  ~{ a => [1,2,3] }.perl.eval

[02:18] <evalbot_7621> "a\t1 2 3\n" 

[02:20] <putter> it's also worth trying pugs -Bjs with stuff like this.  pil2js has quite a few 'unexepected successes' on tests.

[02:21] <eric256> ?eval ~{ :a(1), :b(2), :c(3) }

[02:21] <evalbot_7621> "a\t1\nb\t2\nc\t3\n" 

[02:21] <eric256> ?eval { :a(1), :b(2), :c(3) }.perl.eval.perl

[02:21] <evalbot_7621> "((\"a\" => 1), (\"b\" => 2), (\"c\" => 3))" 

[02:21] <putter> wont help with parsing or compilation problems, but sometimes the js runtime works better

[02:21] <eric256> ?eval ~{ :a(1), :b(2), :c(3) }.perl.eval

[02:21] <evalbot_7621> "a\t1 b\t2 c\t3" 

[02:21] <eric256> ?eval { :a(1), :b(2), :c(3) }.perl

[02:21] <evalbot_7621> "\{(\"a\" => 1), (\"b\" => 2), (\"c\" => 3)}" 

[02:22] <eric256> how come evaling that returns a list?

[02:22] <putter> not a list, a hash, no?

[02:23] <eric256> ?eval eval("\{(\"a\" => 1), (\"b\" => 2), (\"c\" => 3)}" ).perl

[02:23] <evalbot_7621> "((\"a\" => 1), (\"b\" => 2), (\"c\" => 3))" 

[02:23] <eric256> ?eval { a => 1 }.perl

[02:23] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:23] <eric256> ?eval { a => 1 }.perl.eval.perl

[02:23] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:24] * eric256 scratches head

[02:24] <eric256> ?eval { :a(1) }.perl.eval.perl

[02:24] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:24] <eric256> ?eval { :a(1) }.perl

[02:24] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:24] <eric256> ?eval { :a(1), :b(2) }.perl

[02:24] <evalbot_7621> "\{(\"a\" => 1), (\"b\" => 2)}" 

[02:24] <eric256> ?eval { :a(1), :b(2) }.perl.eval.perl

[02:24] <evalbot_7621> "((\"a\" => 1), (\"b\" => 2))" 

[02:25] <eric256> see? or am i crazy?

[02:25] <eric256> ?eval { :a(1), :b(2) }.ref

[02:25] <evalbot_7621> ::Hash 

[02:25] <eric256> ?eval { :a(1), :b(2) }.perl.eval.ref

[02:25] <evalbot_7621> ::Array 

[02:25] <eric256> ?eval "{(\"a\" => 1), (\"b\" => 2)}".eval.ref

[02:25] <evalbot_7621> ::Array 

[02:25] <putter> ?eval { :a(1), :b(2) }.perl.eval

[02:25] <evalbot_7621> (("a" => 1), ("b" => 2)) 

[02:25] <eric256> ?eval "hash {(\"a\" => 1), (\"b\" => 2)}".eval.ref

[02:25] <evalbot_7621> ::Scalar 

[02:26] <eric256> ?eval "hash ((\"a\" => 1), (\"b\" => 2))".eval.ref

[02:26] <evalbot_7621> ::Scalar 

[02:26] <putter> ?eval my $x = { :a(1), :b(2) }.perl.eval; $x

[02:26] <evalbot_7621> [("a" => 1), ("b" => 2)] 

[02:27] <eric256> parse error? or pretty print error?

[02:27] <putter> that does seem excessively listy

[02:27] <eric256> ?eval "{(a => 1), (b => 2)}".eval.ref

[02:28] <evalbot_7621> ::Scalar 

[02:28] <eric256> ?eval "\{(a => 1), (b => 2)}".eval.ref

[02:28] <evalbot_7621> ::Array 

[02:28] <luqui> ?eval { :a(1) :b(2) }.perl

[02:28] <evalbot_7621> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[02:28] <putter> remember { is now magic in strings

[02:28] <eric256> ?eval {(a => 1), (b => 2)}.ref

[02:28] <luqui> ?eval { :a(1), :b(2) }.perl

[02:28] <evalbot_7621> ::Block 

[02:28] <evalbot_7621> "\{(\"a\" => 1), (\"b\" => 2)}" 

[02:28] <putter> ?eval '{(a => 1), (b => 2)}'.eval.ref

[02:28] <evalbot_7621> ::Array 

[02:28] <luqui> ?eval { :a(1), :b(2) }.perl.say

[02:28] <eric256> i think luqui has it

[02:28] <evalbot_7621> {("a" => 1), ("b" => 2)} bool::true 

[02:28] <putter> ?eval '\{(a => 1), (b => 2)}'.eval.ref

[02:28] <evalbot_7621> ::Block 

[02:29] <eric256> ?eval "{\{(a => 1), (b => 2)}}".eval.ref

[02:29] <evalbot_7621> ::Str 

[02:29] <eric256> hmmm

[02:29] <putter> ?eval "{say 'hi'}"

[02:29] <evalbot_7621> hi "1" 

[02:29] <luqui> ?eval { :a(1), :b(2) }.perl.eval

[02:29] <eric256> ?eval '\{(a => 1), (b => 2)}'.eval.ref

[02:29] <evalbot_7621> (("a" => 1), ("b" => 2)) 

[02:29] <evalbot_7621> ::Block 

[02:30] <luqui> ?eval { :a(1), :b(2) }.perl.say

[02:30] <evalbot_7621> {("a" => 1), ("b" => 2)} bool::true 

[02:30] <eric256> or not.... i dunno. something wierd is happening

[02:30] <luqui> ?eval eval '{("a" => 1), ("b" => 2)}'

[02:30] <evalbot_7621> (("a" => 1), ("b" => 2)) 

[02:30] <luqui> ?eval \eval '{("a" => 1), ("b" => 2)}'

[02:30] <evalbot_7621> [("a" => 1), ("b" => 2)] 

[02:30] <luqui> weird

[02:30] <luqui> the braces are just disappearing

[02:31] <eric256> can't seem to eval *anything* into a hash....

[02:31] <luqui> ?eval {("a" => 1), ("b"=>2)}

[02:31] <evalbot_7621> (("a" => 1), ("b" => 2)) 

[02:31] <luqui> there we go

[02:31] <luqui> ?eval my $x = {("a" => 1), ("b"=>2)}; $x

[02:31] <evalbot_7621> \sub {...} 

[02:31] <luqui> OH!

[02:31] <luqui> Got it

[02:31] <eric256> ?eval { :a(1) }.perl

[02:31] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:31] <luqui> its the parentheses

[02:31] <eric256> ?eval { :a(1) }.perl.eval.perl

[02:31] <evalbot_7621> "\{(\"a\" => 1)}" 

[02:31] <luqui> ?eval { a => 1 }.ref

[02:31] <evalbot_7621> ::Hash 

[02:32] <luqui> ?eval { (a => 1) }.ref

[02:32] <evalbot_7621> ::Hash 

[02:32] <luqui> what?

[02:32] <luqui> I thought I got it

[02:32] <eric256> lol

[02:32] <luqui> ?eval { (a => 1), (b =>1) }.ref

[02:32] <evalbot_7621> ::Block 

[02:32] <luqui> there we go

[02:32] <eric256> ?eval '\{a => 1, b => 2}'.eval.ref

[02:32] <evalbot_7621> ::Hash 

[02:32] <eric256> you were right

[02:32] <eric256> ;;)

[02:32] <luqui> only if the top level of a {} has a pair is it considered a hash

[02:32] <putter> ?eval { a => 1, (b =>1) }.ref

[02:32] <evalbot_7621> ::Hash 

[02:33] <putter> ?eval { (a => 1), b =>1 }.ref

[02:33] * eric256 goes off to fix it...hopefully

[02:33] <evalbot_7621> ::Block 

[02:33] <eric256> thanks luqui

[02:33] <luqui> hang on eric256 

[02:33] <luqui> it may not be broken

[02:33] <eric256> arg....my stupid putty screen to feather 

[02:33] <eric256> it is. its failing the tests for pretty printing and then evaling

[02:33] <luqui> oh right

[02:33] <eric256> when printing a hash it can't make them pairs

[02:33] <luqui> but how do you intend to fix it?

[02:34] <luqui> oh, you could kill the parens on output

[02:34] <eric256> dunno yet, haven't looked at the printing for hashes yet

[02:34] <luqui> ?eval { a => 1, b => 2 }.perl.say

[02:34] <evalbot_7621> {("a" => 1), ("b" => 2)} bool::true 

[02:34] <luqui> make that say { "a" => 1, "b" => 2 }

[02:34] <eric256> yep

[02:34] <putter> :)

[02:35] <eric256> do you know how to turn off line wraps in vi?

[02:35] <luqui> yeah, let me look at my .vimrc (I've done it)

[02:35] <luqui> set nowrap

[02:38] <eric256> hmmm could hashes be being printed by the list routine?

[02:39] <luqui> where are the braces coming from?

[02:39] <eric256> damn...found them...hmmm

[02:41] <eric256> is a hash truly a list of pairs?

[02:41] <scook0> by the way, I'm currently looking into demagicalizing pairs

[02:41] <eric256> and is there anyother way to force { into a hash?

[02:42] <eric256> ?eval '\{, (a => 1), (b => 2)}'.eval.ref

[02:42] <evalbot_7621> ::Scalar 

[02:42] <eric256> ?eval '\{ (a => 1), (b => 2)}'.eval.ref

[02:42] <scook0> I have a mostly-complete patch, but I'm running into trouble with primitives

[02:42] <evalbot_7621> ::Block 

[02:42] <eric256> ?eval '\{+ (a => 1), (b => 2)}'.eval.ref

[02:42] <evalbot_7621> ::Block 

[02:42] <eric256> ?eval '\{, (a => 1), (b => 2)}'.eval.ref

[02:42] <evalbot_7621> ::Scalar 

[02:43] <eric256> oh yea..just tried that. lol

[02:43] <stevan__> scook0: I would prefer not metaclass at all

[02:43] <stevan__> scook0: I think classes should be instances of Class (note the uppercase)

[02:43] <eric256> hash is treated as a list of pairs, so there is no easy way to drop the paran's....but if there is another way to force it into a hash i could handle that.

[02:43] <eric256> ?eval 'hash { (a => 1), (b => 2)}'.eval.ref

[02:43] <evalbot_7621> ::Scalar 

[02:43] <eric256> ?eval '\hash { (a => 1), (b => 2)}'.eval.ref

[02:43] <evalbot_7621> ::Scalar 

[02:43] <stevan__> the meta stuff just makes things more confusing

[02:43] <scook0> stevan__: as in, no distinction between a 'class', and the metamodel-object that represents it?

[02:43] <stevan__> yes

[02:44] <stevan__> why should there be

[02:44] <xinming> Hi, all, Now I am in ZheJiang... back... :-P

[02:44] <stevan__> we need to throw out the C++/Java notion that a class is anything special 

[02:44] <eric256> ?eval 'hash ( (a => 1), (b => 2))'.eval.ref

[02:44] <evalbot_7621> ::Scalar 

[02:44] <scook0> yes, but if $Larry *insists* on separating classes and objects, then 'class meta-object' is a better term

[02:44] <eric256> ?eval 'hash ( (a => 1), (b => 2))'.eval.perl

[02:44] <evalbot_7621> "undef" 

[02:44] <eric256> ?eval 'hash { (a => 1), (b => 2)}'.eval.perl

[02:44] <evalbot_7621> "undef" 

[02:44] <scook0> that was my main point--overall, I probably prefer dropping the distinction

[02:44] <eric256> ?eval { (a => 1), (b => 2)}.perl

[02:44] <evalbot_7621> "sub \{...}" 

[02:45] <eric256> ?eval hash ( (a => 1), (b => 2)).perl

[02:45] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[02:45] <eric256> ?eval hash( (a => 1), (b => 2)).perl

[02:45] <evalbot_7621> "\{(\"a\" => 1), (\"b\" => 2)}" 

[02:45] <eric256> ahhh... ;)

[02:45] <stevan__> I think $Larry needs to see how powerfull non-seperated class/object is

[02:45] <eric256> ?eval 'hash( (a => 1), (b => 2))'.eval.perl

[02:45] <evalbot_7621> "\{(\"a\" => 1), (\"b\" => 2)}" 

[02:45] <eric256> sweet

[02:45] <stevan__> but for now, I need to go watch a movie with my wife :)

[02:45] * stevan__ &

[02:45] <eric256> luqui .. that look about right to you?

[02:45] <luqui> eric256, are you going to output as a hash()?

[02:46] <eric256> i was thinking about it

[02:46] <eric256> down side?

[02:46] <luqui> not as pretty

[02:46] <eric256> i'm open to suggestions

[02:46] <luqui> can you keep the parens off the pairs?

[02:46] <eric256> working++ > pretty-- ;)

[02:46] <luqui> eric256, of course

[02:46] <eric256> no

[02:46] <luqui> ?eval (a => 3).perl

[02:46] <evalbot_7621> "(\"a\" => 3)" 

[02:46] <eric256> i can't, someone else might be able to

[02:47] <luqui> have any leads?

[02:47] <eric256> or provide some other signal to the parser that its a hash and not a block

[02:48] <luqui> hash() is probably good for now

[02:48] <eric256> well for now i'll do that. ;)

[02:48] <eric256> objections?

[02:48] <eric256> hearing non, eric heads out to break...i mean fix output. ;)

[02:51] <eric256> (return $ ("hash(":(init (tail str))) ++ ")")

[02:51] <putter> :)

[02:51] <putter> good night &

[02:51] <eric256> i'm reading something wrong on that line

[02:51] <eric256> later

[02:51] <putter> good luck

[02:56] <eric256> i don't know what the : is doing...anyone know haskell?

[02:57] <scook0> eric256: : is cons

[02:57] <PerlJam> eric256: The } is cons

[02:57] <PerlJam> er, :

[02:57] <eric256> ahhh. dunno how i forgot that ;)

[02:58] <eric256> do you see an error there then?

[02:58] <eric256> perlbot nopaste

[02:58] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[02:58] <scook0> I think you might need to try getting rid of some parens, so it's easier to read

[02:59] <pasteling> "eric256" at 24.8.74.230 pasted "parse error." (6 lines, 238B) at http://sial.org/pbot/13708

[02:59] <PerlJam> I agree with that.  Too many parens remind me of lisp

[02:59] <PerlJam> lisp is fine for a computer to read, but the excessing regularity is annoying to this human.

[02:59] <scook0> eric256: is it supposed to be returning a string, or a list of strings?

[03:00] <eric256> i thought a string, but now i think its a list of strings

[03:00] <scook0> return $ "hash(" ++ (init $ tail str) ++ ")"

[03:00] <eric256> thats the way it was already, i didn't do any of that except the hash( opart

[03:01] <scook0> eric256: what file/line?

[03:01] <eric256> Prim.hs 1363

[03:02] <eric256> trying yours there... looks like its going to make it...dunno what it will look like ;)

[03:02] <scook0> eric256: you replaced a single-char '{' with a string "hash("

[03:02] <eric256> i don't understand why they are abusing str like that

[03:02] <eric256> yea

[03:02] <scook0> which means (:) is no longer what you need

[03:02] <scook0> try (return $ "hash(" ++ (init $ tail str) ++ ")")

[03:02] <eric256> : was just a cheap way of joining strings?

[03:02] <eric256> lol

[03:03] <PerlJam> eric256: it's a "cheap" way of constructing lists of atomic things.

[03:03] <scook0> (:) only works for adding a single character (element) to the start of a string (list)

[03:03] <PerlJam> eric256: in haskell, a string is already a list

[03:03] <scook0> once you start joining two strings (lists), you need (++)

[03:04] <eric256> yea i just forgot what i knew..lol

[03:04] <eric256> ?eval "hash((\"1\" => 2))".eval.perl

[03:04] <evalbot_7621> "undef" 

[03:04] <PerlJam> eric256: "hello" == 'h':'e':'l':'l':'o':[]   ( I think, it's been a while since I've hacked haskell)

[03:04] <eric256> ?eval "hash((1 => 2), 2)".eval.perl

[03:04] <evalbot_7621> "\{(\"1\" => 2), (\"2\" => undef)}" 

[03:04] <eric256> ?eval "hash((1 => 2))".eval.perl

[03:04] <evalbot_7621> "undef" 

[03:04] * eric256 curses agian. lol

[03:04] <scook0> PerlJam: that's correct

[03:05] <eric256> fixed the output...but it doesn't work anyway. lol. i thought i tested that

[03:05] <eric256> ?eval "hash((1 => 2), (3=>4))".eval.perl

[03:05] <evalbot_7621> "\{(\"1\" => 2), (\"3\" => 4)}" 

[03:06] <eric256> ?eval "hash( (1 => 2) )".eval.perl

[03:06] <evalbot_7621> "undef" 

[03:06] <scook0> does anyone know how named-args get passed to primitives (specifically Object::new)?

[03:06] <eric256> ?eval hash( (1 => 2) )

[03:06] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[03:06] <eric256> ?eval hash( 1 => 2 )

[03:06] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[03:06] <eric256> ?eval hash( 1 => 2, 3 => 4 )

[03:06] <evalbot_7621> {("1" => 2), ("3" => 4)} 

[03:06] <eric256> hash is broken too??

[03:07] <eric256> magical pairs are cursing me agian arn't they?

[03:07] <scook0> &hash is a bit of a hack at the moment

[03:08] <PerlJam> Hmm.  Last time I looked hash(1=>2) complained about an odd number of elements.  I'm guessing someone has been working on hash()?

[03:09] <scook0> PerlJam: `hash {}` still complains

[03:10] <PerlJam> yeah, I was just looking at Eval.hs

[03:11] <PerlJam> All those "bloody hacks" need an application of haskell-fu

[03:11] * eric256 was trying. ;) well actualy mine are probably more on the hackish side. but i'm trying to work on my haskell-fu

[03:12] <PerlJam> eric256++ keep it up.

[03:14] <eric256> ahhh...single item...hmmm

[03:14] <eric256> looking at Eval.hs

[03:14] <Khisanth> well hopefully it won't have a hairier core than p5 :)

[03:15] <eric256> no way for it to know that one item is a pair is there? if there is that would/should be a simple fix to add

[03:15] <eric256> of course 3 pairs should still work. 

[03:15] <eric256> could we just let hash assume the best?

[03:16] <Khisanth> that doesn't sound good

[03:16] <eric256> well you should still get an error if it doesn't realy produce a hash. just not as early

[03:18] <eric256> hmmm...silently assumes last odd key has an undef value. not sure thats a feature

[03:18] <eric256> lol

[03:18] <eric256> ?eval { 1,2,3}.perl

[03:18] <evalbot_7621> "sub \{...}" 

[03:18] <eric256> ?eval { 1 => 2,3}.perl

[03:18] <evalbot_7621> "\{(\"1\" => 2), (\"3\" => undef)}" 

[03:18] <eric256> same behavior as that if you drop the warning

[03:20] <eric256> no comments?

[03:20] <eric256> seems like drop the error and add the error in the actual hash compisition

[03:22] <eric256> ?eval "\\{ 1, 2}"

[03:22] <evalbot_7621> "\\1 2" 

[03:22] <eric256> ?eval "\\{ 1, 2}".perl

[03:22] <evalbot_7621> "\"\\\\1 2\"" 

[03:22] <eric256> ?eval '\\{ 1, 2}'.perl

[03:22] <evalbot_7621> "\"\\\\\\\{ 1, 2}\"" 

[03:22] <eric256> ?eval \\{ 1, 2}.perl

[03:22] <evalbot_7621> Error:  unexpected "\\" expecting program 

[03:23] <eric256> ?eval '\\{ 1, 2}'.eval.perl

[03:23] <evalbot_7621> "\\sub \{...}" 

[03:29] <scook0> autrijus: ping # in a call to &Object::new, when/where do the named/positional args get segregated?

[03:30] <stevan> scook0: are you asking about pugs, or perl6 in general

[03:30] <scook0> stevan: pugs internals

[03:30] * stevan couldn't find a good movie to watch

[03:31] <stevan> scook0: ahh, can't help you there

[03:31] *** Supaplex is now known as linuxmammal

[03:31] *** linuxmammal is now known as Supaplex

[03:33] <stevan> scook0: re: meta junk

[03:34] <scook0> stevan: yeah?

[03:34] <stevan> if the entire meta-model can sit "on top" of the core interpreter

[03:34] <stevan> then it can be much more flexible

[03:34] <stevan> this requires that Class (uppercase, proper noun) is accessible and usable in the same way Object is

[03:34] <stevan> just having .meta is probably not enough

[03:35] <stevan> but then again, if you just put Class at the other end of .meta it is probably okay too

[03:35] <stevan> I think Larry has some really interesting ideas, my issue is that I want to understand them within the context of some meta-model

[03:36] <stevan> s/meta/object/

[03:36] <eric256> hmmm its doing something special droping the first and last character in Prim.hs .... for some reason that must get called twice on the same bit?  seems like a bit of a hack to drop the first and last letter and add your own though../me searches more

[03:37] <stevan> I based the current model heavily on CLOS because CLOS was built from the start to be able to encompass the behaviors of some of the other LISP Object systems  out there at the time

[03:38] <stevan> since p6 should interact with (at least) p5, and (at most) Python & Ruby, I thought going down this road would be a the right direction

[03:38] <stevan> in the end if you call it meta, that is fine, but it is my hope that the terminology will just be "names" and nothing more

[03:39] <scook0> stevan: the only point I was really trying to make

[03:39] <scook0> was that *iff* classes and objects are distinct kinds of entities

[03:40] <stevan> hey nothingmuch :)

[03:40] <nothingmuch> morning

[03:40] <scook0> then if you want a term for "the representation of a class in object-space"

[03:40] <stevan> morning 

[03:40] <scook0> nothingmuch: hi

[03:40] <eric256> hey nothingmuch

[03:40] <scook0> then that term should be "class metaobject" rather than "metaclass"

[03:40] <eric256> nothingmuch: do you know much about the Pretty printing ?

[03:40] <nothingmuch> the pretty printing of what?

[03:41] <stevan> scook0: In my mind, Class and Object are no different from Foo and Bar

[03:41] <eric256> .perl

[03:41] <nothingmuch> oh

[03:41] <nothingmuch> no clue at all

[03:41] <stevan> Class is an instance of Class, and Class is a subclass of Object

[03:41] <eric256> figured it was worth a shot. lol

[03:41] <scook0> stevan: I personally subscribe to that view

[03:41] * nothingmuch has some stupid macho friends

[03:42] <nothingmuch> they got slightly drunk

[03:42] <nothingmuch> and we drove this girl home on the way

[03:42] <stevan> scook0: my goal for the near future is to get Larry to subscribe to that as well :)

[03:42] <nothingmuch> all the time she was in the car they were shouting crap at the top of their lungs trying to impress her

[03:42] <nothingmuch> the moment she got out, they became quiet

[03:43] <nothingmuch> then one of them got a call from girlfriend, and they talked with her friend

[03:43] <nothingmuch> shouting again

[03:44] <scook0> stevan: I think in Larry's mind, none of Class, Object or Foo are 'proper' objects

[03:44] <stevan> scook0: well I think he is seeing them as Roles of some kind

[03:45] <scook0> so what you think of as Class, Object and Foo, he thinks of as Class.meta, Object.meta and Foo.meta

[03:45] <scook0> i.e. he's making the distinction between class and class-metaobject explicit

[03:45] <scook0> whereas you don't believe there's value in that distinction

[03:45] <stevan> scook0: my guess is that he is thinking of Class, Object, etc as being creatures of the interperter

[03:46] <stevan> and that they need some kind of Perl6 space facade, which is where the Roles come in

[03:46] <stevan> but I might be reading too much into it

[03:46] <nothingmuch> anyway, off to bed, lambdacamels

[03:46] <scook0> nothingmuch: bye

[03:46] * stevan shouts at nothingmuch 

[03:48] * stevan takes the dog out, be right back

[03:53] <eric256> i'm missing something obvious...must be...or it could be the fact that there are 15 different coding styles in a language i'm just starting to learn. ;)

[03:56] <luqui> eric256, you mean about haskell?

[03:56] <eric256> pugs source code in haskell

[03:56] <luqui> it's not that you're missing something obvious

[03:56] <luqui> it's that you're missing fifty subtle things all at once

[03:56] <luqui> that's learning haskell...

[03:56] <eric256> hehe yea i've noticed that already

[03:56] <eric256> going...duh thats a sub right there it just looks like an assignment lol

[03:57] <eric256> whole new way of thinking

[03:57] <luqui> yep

[03:57] <luqui> have you just played with ghci?

[03:57] <eric256> yep

[03:57] <eric256> and walked through a tutorial

[03:57] <eric256> ;) nothing like hands on though

[03:57] <eric256> prettyVal d v@(VRef r) = do

[03:57] <eric256> what does the @ mean there?

[03:58] <luqui> oh, that's just (v = (VRef r))

[03:58] <luqui> so you're extracting the r inside VRef, but still referring to the whole VRef as v

[03:58] <eric256> so why would the sub then refer to both the v and the  r?

[03:59] <eric256> oh wait i think i get it

[03:59] <scook0> eric256: for .perl-ifying hashes, have you tried `hash list (1=>2)`?

[03:59] <eric256> scook..hard part is i can't get it to ouput right yet

[03:59] <eric256> cuts off parts of hash( )

[03:59] <scook0> it just avoids having to write `let v = (VRef r)`

[03:59] <eric256> or doubles it up...ended up with hash(ash(1 => 2)) a couple times

[04:00] <scook0> eep

[04:00] <eric256> lol

[04:00] <eric256> yea

[04:01] <scook0> eric256: I wonder if that's related to the (init $ tail str)?

[04:02] <eric256> definitly is...but removing the init $ tail just makes it stop working at all and returns undef....dunno why

[04:02] <eric256> so there is something subtle going on. i just have to figure out what ;)

[04:03] <eric256> prettVal d v@(VRef r) is being called on the value twice as it is being printed..i think. :)

[04:03] <eric256> but i don't know where or why

[04:03] <luqui> (init $ tail str) takes off the first and last character of str

[04:03] <eric256> yea

[04:04] <scook0> my guess is that it's trying to remove redundant parens or braces

[04:05] <eric256> yea...but its doing it while adding them....why remove them and then add? 

[04:05] <eric256> remove parens while adding brackets...could be

[04:05] <scook0> seems most likely

[04:05] <eric256> but its also removing redundant brackets....

[04:05] <scook0> maybe the pretty-prenting of a hash (not hashref) has parens

[04:06] <scook0> so the pretty-print of a hashref takes that, removes parens, and adds braces instead?

[04:06] <eric256> and hashref uses it, but removes the parens to add brackets

[04:06] <eric256> yea that seems to follow the code there

[04:06] <scook0> exactly

[04:06] <eric256> okay...now to use this new knowledge ;)

[04:06] <eric256> thanks.  you have to think completely different in haskell...thats hard

[04:07] <eric256> not like learning VB or C++ or javascript...totaly differnt

[04:07] <scook0> eric256: it's not as though the program itself is easy, though

[04:07] <scook0> if you were doing something equivalently complex in C++, you probably would have given up by now :)

[04:09] <eric256> probably. i hate c++. lol

[04:12] <eric256> hmm broke something agian. ... wonder what. 

[04:13] <eric256> how do i have svk undo all local changes?

[04:13] <eric256> nm found it

[04:29] <eric256__> any idea why if i changed something and it broke something else, then i changed it back and remade...the break didn't go away? do i need to always perl Makefile.PL ?

[04:40] <luqui> eric256__, weird

[04:40] <luqui> i think it depends on what you changed...

[04:41] <luqui> no, nevermind

[04:41] <luqui> you should never have to Makefile.PL unless you rearrange files

[04:42] <eric256__> i commented out the # of elements check in Eval.hs and then pugs started returning undef for all hashrefs...so i uncommented it and recompiled but it still did it.

[04:43] <luqui> that was the only change you did between recompiles?

[04:44] <eric256__> yep

[04:44] <eric256__> commented, make, tested, uncommented, make, tested

[04:45] <eric256__> before the comment it worked, after both tests failed

[04:45] <luqui> very strange

[04:45] <luqui> don't know what to tell you

[04:45] <eric256__> hehe. i thought i'd done something wrong, thats why i revereted all files. didn't help

[04:45] <eric256__> well it di, it started working right. but then when i tried agian same thing happened

[04:46] <eric256__> like it wasn't noticing my change toe Eval.hs

[04:46] <eric256__> lol or i'm stupid

[04:46] <eric256__> lol. interactive pugs doesn't print the value

[04:46] <eric256__> you ahve to {1=>5}.perl.say;

[04:46] <eric256__> blah

[04:47] <eric256__> thats an hour of life wasted

[04:47] <luqui> :-/

[04:47] * luqui had a similar experience

[04:47] <luqui> I was debugging one of my modules for two hours only to find that the error was due to an error in the .t

[04:48] <PerlJam> luqui: always check both sides of the equation :)

[04:59] <eric256__> hmmm.. works fine. except for loop seems to do something realy strange

[04:59] <eric256__> ?eval my @t = (1, {1=>2} ); for @t {$_.perl.say;}

[04:59] <evalbot_7621> \1 {("1" => 2)} undef 

[04:59] <eric256__> ?eval my @t = (1, 1=>2 ); for @t {$_.perl.say;}

[04:59] <evalbot_7621> \1 Error: Insufficient number of required parameters: 0 actual, 1 expected 

[04:59] <eric256__> ?eval my @t = (1, hash(1=>2) ); for @t {$_.perl.say;}

[04:59] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[04:59] <eric256__> ?eval my @t = (1, hash(1=>2) ); for Any @t {$_.perl.say;}

[04:59] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:00] <eric256__> ?eval my @t = (1, hash(1,2) ); for Any @t {$_.perl.say;}

[05:00] <evalbot_7621> Error: Pattern match failure in do expression at src/Pugs/Eval.hs:419:4-12 

[05:00] <eric256__> ?eval my @t = (1, hash(1,2) ); for @t {$_.perl.say;}

[05:00] <evalbot_7621> \1 {("1" => 2)} undef 

[05:00] <eric256__> why is that \1?? its a ref to it?

[05:00] <luqui> a ref to 1

[05:00] * luqui dunnos why

[05:01] <eric256__> hmmm. so if you have a hashref in an array, then $_ ends up being a ref to a ref?... explains the odd behaviour at least.

[05:01] <eric256__> ?eval hash( hash( 1, 2) ).perl

[05:01] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:02] <eric256__> hehe. things start to make a sick kind of sense...why they coded it the way they did

[05:08] <luqui> ?eval hash( a => hash( b => c ) )

[05:08] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:08] <luqui> ?eval hash( a => hash( b => 'c' ) )

[05:08] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:08] <eric256__> whole thing is screwy . lol

[05:08] <luqui> yeah

[05:09] <luqui> I've been wanting to port some of my modules to perl 6

[05:09] <luqui> but then I start and I run into these bugs.   it's very frustrating

[05:09] <luqui> pugs is not very good with nested data strucutures... at all

[05:10] <luqui> ?eval hash( a => 'b' )

[05:10] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:10] <luqui> umm, I swear that used to work

[05:10] <eric256__> ?eval hash( a , 'b' )

[05:10] <luqui> ?eval hash( a => 'b' ).perl

[05:10] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:10] <eric256__> arg. wish escape wouldn't close the window

[05:11] <eric256__> ?eval hash(1,2)

[05:11] <evalbot_7621> {("1" => 2)} 

[05:11] <luqui> ?eval hash('a', 'b')

[05:11] <evalbot_7621> {("a" => "b")} 

[05:11] <luqui> ?eval hash('a' =>'b')

[05:11] <evalbot_7621> Error: cannot cast from VUndef to Handle (VHandle) 

[05:11] <eric256__> it sees it as a pair and a single element. dunno why evalbot isn't catching the warning though

[05:12] <luqui> ?eval hash('a' =>'b', 'c')

[05:12] <evalbot_7621> {("a" => "b"), ("c" => undef)} 

[05:12] <luqui> ?eval hash('a' =>'b', 'c', 'd', 'e' => 'f')

[05:12] <evalbot_7621> {("a" => "b"), ("c" => "d"), ("e" => "f")} 

[05:14] <eric256__> i'm confused...how can a hashref be pointing to a hashref? shouldn't a hashref have to point to the hash itself?

[05:15] <eric256__> or all refs that point to a hash in the end considered a hash?.....arg.

[05:15] <luqui> what do you mean a hashref pointing to a hashref

[05:15] <luqui> is there somewhere you are looking

[05:16] <eric256__> when i do that for loop thing...right now i wrap hashrefs in hash( ) instead of { }

[05:16] <eric256__> inside a for loop it becomes

[05:16] <eric256__> hash ( hash ( ) )

[05:17] <eric256__> only way i can get there in the code is if there is a ref (of type hash) pointing to a ref (of type hash)...

[05:17] <luqui> ... for Any @t ?

[05:18] <luqui> maybe the reftype code dereferences until it finds something that is not a ref

[05:18] <luqui> (just guessing here)

[05:18] <luqui> ?eval (\\\1).ref

[05:18] <evalbot_7621> Error:  unexpected "\\" expecting expression 

[05:19] <luqui> ?eval (\ \ \1).ref

[05:19] <pasteling> "eric256" at 24.8.74.230 pasted "pugs> my @t =(1, {2=>2}); for" (5 lines, 91B) at http://sial.org/pbot/13709

[05:19] <evalbot_7621> ::Int 

[05:19] <luqui> yeah, like that

[05:19] <luqui> ?eval \ \ \ 1

[05:19] <evalbot_7621> \1 

[05:20] <eric256__> hmmm

[05:20] <eric256__> well that presents a problem. lol

[05:20] <eric256__> but it explains what they did...gonna sleep on this. i think there might be an easy way around it.

[05:20] <luqui> perhaps

[05:21] <luqui> maybe autrijus will be around when you get back

[05:21] <luqui> so he can guide you

[05:21] <eric256__> i'm assumeing that if there is a way to jump to the final type that you could also jump to a final value. at least i know alot more than 4 hours ago

[05:22] * luqui is meaning to get back into pugs hacking at some point

[05:22] <luqui> thanks for inspiring me

[05:22] <eric256__> hehe thanks for the help. feel free to fix this if you can figure it out! i just picked tests that were failing and started. ;)

[05:22] <eric256__> later

[05:23] <luqui> later

[05:28] <mrborisguy> anybody know the story on 'src/perl6/Prelude/PIR.pm' ?

[05:29] <mrborisguy> does it somehow get included, or is it just there for the future?

[05:34] <luqui> you could grep the source

[05:34] <mrborisguy> to be honest, I don't even know where to start looking.  src/Pugs ?

[05:36] <runinshine> Is the source of Pugs  Hashell?

[05:36] <mrborisguy> runinshine: yeah, Haskell

[05:38] <runinshine> I don't understand it , can you give me some advise?

[05:39] <mrborisguy> you don't understand what?  Haskell?

[05:39] <mrborisguy> you don't understand Perl6?

[05:57] <scook0> runinshine: did you have a question before?

[05:58] <runinshine> yeah

[06:00] <runinshine> who can give me some advice of learning the Hashell ?

[06:01] <luqui> go to #haskell and ask where to start

[06:01] <luqui> give them your background as a programmer

[06:02] <runinshine> thanks

[06:02] <Khisanth> haskell looks very nice and appealing, just need to find something to do with it! :)

[06:03] <scook0> Khisanth: like writing a Perl 6 implementation! :P

[06:04] <Khisanth> well I mean personally

[06:04] <runinshine> why is it suitable for writing the implementation of Perl6?

[06:05] <mrborisguy> scook0: the problem with starting to write a Perl 6 implementation is that it's not really a good place for the beginner

[06:05] <scook0> mrborisguy: *grin*

[06:06] <mrborisguy> I tried to learn a little Haskell this summer, and I can do some stuff in it, but I poked around in the internals, and I'm clueless!

[06:06] <mrborisguy> (although, it might help if I knew what each file was trying to accomplish :D)

[06:06] <scook0> mrborisguy: well, don't hesitate to ask

[06:06] <luqui> runinshine, because that's what autrijus wrote it in

[06:06] <scook0> not everybody has to figure it out the hard way

[06:06] <luqui> :-)

[06:07] <mrborisguy> true, true.

[06:08] <mrborisguy> sometimes I think... just give me something to hack away on for a while until I figure it out, maybe I could help

[06:08] <mrborisguy> but I never know what... any ideas?

[06:09] <luqui> the high numbers of :todo<bug>s in .t

[06:09] <luqui> er, t/

[07:03] <scook0> attention: anyone who uses alternative backends

[07:04] <scook0> I have a patch that demagicalizes pairs/named-args in the Parser and the normal Haskell runcore

[07:04] <scook0> but it will almost certainly break named-args in the various backends

[07:08] <luqui> scook0, cool

[07:08] <svnbot6> r7622 | scook0++ | * Abracadabra, shalakazam, demagicalize pairs!

[07:08] <svnbot6> r7622 | scook0++ | (This will probably break all the other backends.)

[07:08] <svnbot6> r7622 | scook0++ | * A few minor style/readability tweaks

[07:09] <luqui> scook0++

[07:09] <luqui> (3 isn't enough)

[07:09] <scook0> luqui: it *almost* passes the entire test suite

[07:09] <scook0> (except for a few cases that are really caused by other parser bugs)

[07:09] <scook0> but, as I said, it will break the other backends :(

[07:09] <luqui> how come

[07:09] <luqui> did you change PIL?

[07:10] <scook0> luqui: no--that's why they'll break

[07:10] <luqui> oh...

[07:10] <scook0> I added (Sym "named"), which the compiler won't recognise

[07:10] <luqui> I see

[07:10] <luqui> well, it had to be done sometime

[07:11] <scook0> but, it's possible to temporarily undo the parser changes with a one-line fix

[07:11] <scook0> (basically, I have a 'named' combinator that wraps around the parsers for pairs)

[07:11] <scook0> if you replace that combinator's definition with "id", named-pairs get parsed as normal pairs again

[07:12] <scook0> by the way, did somebody check in some tests for demagicalized behaviour?

[07:13] <scook0> I seem to remember someone adding some, but I might have imagined it

[07:13] <luqui> ??

[07:13] * luqui will grep and then add if not

[07:13] <luqui> did you use the semantics from the recent p6l thread?

[07:14] <luqui> that is foo(a => b)  # named   foo((a => b));   # normal pair

[07:14] <scook0> luqui: yeah

[07:14] <scook0> but not everything works: e.g. `foo.(:a)` is broken

[07:15] <scook0> because of a bug in `foo.()` parsing

[07:15] <luqui> Retrieving log information from 7119 to 7622   # it's been a while

[07:16] <luqui> a day or two ;-)

[07:16] <gaal> kolibrie: pong

[07:16] <luqui> we'll catch up to parrot pretty soon here

[07:17] <scook0_> urk, net troubles :(

[07:18] <luqui> ?eval sub foo($x) { say $x }    foo(x => 4)

[07:18] <evalbot_7622> 4 bool::true 

[07:18] <luqui> ?eval sub foo($x) { say $x }    foo((x => 4))

[07:18] <evalbot_7622> x4 bool::true 

[07:18] <luqui> woot

[07:18] <luqui> ?eval sub foo($x) { say $x.ref }    foo((x => 4))

[07:18] <evalbot_7622> Pair bool::true 

[07:19] <luqui> ?eval sub foo($x) { say $x.ref }    my $p = (x => 4);  foo($p)

[07:19] <evalbot_7622> Pair bool::true 

[07:19] <luqui> ?eval sub foo($x) { say $x.ref }    my $p = (x => 4);  foo(*$p)

[07:19] <evalbot_7622> Array bool::true 

[07:19] <luqui> ?eval sub foo($x) { say $x.ref }    my %p = (x => 4);  foo(%p)

[07:19] <evalbot_7622> Hash bool::true 

[07:19] <luqui> ?eval sub foo($x) { say $x.ref }    my %p = (x => 4);  foo(*%p)

[07:19] <evalbot_7622> Array bool::true 

[07:19] <luqui> scook0_, didn't do the splat?

[07:19] <luqui> i.e. the remagicalizing operator

[07:20] <scook0_> luqui: I don't think hash-splat ever worked before

[07:20] <luqui> fair enough

[07:25] <scook0_> luqui: are you writing tests, or shall I start some?

[07:30] <luqui> I was updating pugs

[07:30] <luqui> but I shall start writing tests now

[07:32] <luqui> scook0_, looks like there are already tests in t/syntax/pairs.t

[07:34] <scook0_> iblech++ # demagicalized pair tests

[07:35] <luqui> how do I praise and not always see my own name with svk?

[07:36] *** scook0_ is now known as scook0

[07:38] <scook0> luqui: you don't happen to know the exact syntax of sub calls wrt where you can put adverbs, do you?

[07:39] <scook0> (I'm writing parse-tests for various sub-call forms)

[07:39] <Aankhen``> foo($bar, :baz :quux)

[07:40] <coral> .

[07:40] <coral> ww

[07:41] <scook0> I'm just wondering about these sorts of things:

[07:41] <scook0> foo:adv()($arg) # probably not

[07:41] <Aankhen``> I agree with the comment. :-)

[07:41] <scook0> foo():adv

[07:41] <scook0> foo() :adv # with space

[07:42] <Aankhen``> Those last two are probably possible.  They'd need to be for operators which take adverbial modifiers, e.g.: 1..10 :by(2)

[07:42] <scook0> foo(:alfa :bravo $arg :charlie :delta):echo :foxtrot

[07:42] <Aankhen``> Of course, I'm out of the loop, so I could be dead wrong.

[07:43] <Aankhen``> I believe you can't put a positional parameter in the middle of a bunch of named parameters...

[07:43] <scook0> maybe I'll write up a big list of all the corner cases, and send it to p6l

[07:43] <scook0> foo(:adv $arg)

[07:44] <Aankhen``> Positional parameters before named parameters!

[07:44] <Aankhen``> foo($arg, :adv);

[07:44] <Aankhen``> foo $arg, :adv; # dunno about this

[07:45] <scook0> Aankhen``: I think that should work too

[07:45] <luqui> Aankhen``, I'm trying to kill that

[07:45] <luqui> not sure what Larry thinks

[07:45] <Aankhen``> OK.

[07:45] <scook0> it's not really necessary any more

[07:45] <luqui> he's wanted "zones" for a while, but that may have been his implementation-head, which the demagicalized pairs proposal destroyed

[07:45] <Aankhen``> But if you kill it, what happens to operators that can take adverbial modifiers?

[07:46] <scook0> now that named-arguments can be determined statically

[07:46] <luqui> Aankhen``, what do you mean?

[07:46] <luqui> they still exist

[07:46] <Aankhen``> They're not affected?

[07:46] <luqui> no

[07:46] <scook0> Aankhen``: he was talking about "Positional parameters before named parameters!"

[07:46] <Aankhen``> Ah, I see.

[07:46] <scook0> not your example

[07:46] <luqui> ohh

[07:47] <scook0> foo $arg, :adv; # should work

[07:47] * Aankhen`` spanks his lag.

[07:47] <scook0> just like: foo $arg, adv=>1;

[07:48] <scook0> and as a matter of style, mixing named and positional args is still bad news

[07:48] <luqui> maybe

[07:49] <scook0> but it no longer needs to be illegal, from an implementation POV

[07:49] <scook0> luqui: i.e. foo($pos, :named, $pos, :named)

[07:49] <luqui> foo 1, 2, 3, :parallel, { big block of code }

[07:49] <luqui> it's an endweight thing

[07:49] <gaal> Hey Aankhen``, long time no moose.

[07:49] <Aankhen``> Hiya gaal. :-D

[07:50] <scook0> luqui: yes, your particular example was good

[07:50] <putter> a quick log check before sleep yields...

[07:50] <scook0> which is why it's nice that they don't need to be illegal

[07:50] <scook0> but things like *my* example should be frowned upon by P6 style guides

[07:50] <luqui> yeah probably

[07:50] <putter> on adverbs, re "# probably not", remember rx:perl5//  rx:x(4)// etc.

[07:51] <scook0> putter: but in the case of rules, you can choose your own delimiters

[07:51] <scook0> with sub calls, you're stuck with parens

[07:51] <luqui> putter, those are for quoters though

[07:51] <putter> hmm....

[07:51] <scook0> foo:adv<>($arg) # illegal ?

[07:51] * Aankhen`` ponders the perverseness of whoever termed these things delimiters.

[07:51] <luqui> I think so

[07:52] <scook0> foo :adv .($arg) # insane?

[07:52] <putter> ;)

[07:53] <luqui> s/\./,/ and it should work

[07:53] <luqui> but for a very different reason :-)

[07:53] <putter> ok.  quoters, good point.  good night &

[07:55] <Aankhen``> Quoters?

[07:55] <Aankhen``> Nah.

[07:55] <Aankhen``> Delimiters is the right word.   It's just a strange word. :-)

[07:56] <luqui> "quoter" speaking about the rx part, not the //, which are delimiters

[07:56] <Aankhen``> Ah, I see.  I overcompensated for my lag, then.

[08:33] <wolverian> Juerd, ah, thanks.

[11:40] <iblech> scook0++ # demagicalizing pairs

[11:40] <iblech> scook0: I'm fixing Pugs.Compile and then PIL2JS currently

[11:43] <svnbot6> r7623 | iblech++ | Pugs.Compile: Compile the new Syn "named". scook0++ for demagicalizing pairs!

[12:46] <svnbot6> r7624 | iblech++ | * t/syntax/pairs.t: Per

[12:46] <svnbot6> r7624 | iblech++ |   http://www.nntp.perl.org/group/perl.perl6.language/23532, the keys of

[12:46] <svnbot6> r7624 | iblech++ |   syntactical pairs should get stringified.

[12:46] <svnbot6> r7624 | iblech++ | * PIL2JS: Demagicalized pairs!

[12:46] <svnbot6> r7624 | iblech++ |   * libjs/PIL2JS.js: For now, special PIL2JS.NamedPair class -- named pairs

[12:46] <svnbot6> r7624 | iblech++ |     are no longer PIL2JS.Pairs, but PIL2JS.NamedPairs.

[12:46] <svnbot6> r7624 | iblech++ |   * libjs/PIL2JS.js, PIL::*: s/pairs/namedpairs/ where appropriate.

[12:46] <svnbot6> r7624 | iblech++ |   * PIL::PApp, PIL::PVal: Efficient &Pugs::Internals::named_pair.

[12:46] <svnbot6> r7624 | iblech++ |   * P6 Prelude::JS:

[12:46] <svnbot6> r7624 | iblech++ |     * *$normal_pair evaluates to a magical pair.

[12:46] <svnbot6> r7624 | iblech++ |     * Enabled code for *%hash (was always there, but because of a small

[12:46] <svnbot6> r7624 | iblech++ |       oversight not used).

[12:46] <svnbot6> r7624 | iblech++ |   * This means PIL2JS passes 16/17 of pairs.t! (And the single failing test

[12:46] <svnbot6> r7624 | iblech++ |     is because of Pugs.Parser, not PIL2JS). Hurray for demagicalized pairs :))

[13:05] <scook0> iblech: which pairs.t test-fail is caused by Parser?

[13:06] <iblech> scook0: foo @array => 42 -- this doesn't get a Syn "named"

[13:07] <iblech> scook0: (It's the last test of pairs.t)

[13:07] <scook0> now that I check...I don't think *any* pairs that don't have a bareword on the lhs get parsed properly

[13:08] <iblech> yep, the all seem to get converted into &infix:«=>»($lhs,$rhs)

[13:08] <scook0> seems the rule I'm using only matches the bareword variant

[13:09] <scook0> other ones are probably matched using normal operator parsing

[13:09] <iblech> ah, yes, makes sense

[13:16] <svnbot6> r7625 | scook0++ | * More sub-call parse tests

[13:28] <svnbot6> r7626 | iblech++ | t/syntax/pairs.t: More tests:

[13:28] <svnbot6> r7626 | iblech++ | * :a is a named, but (:a) is pair.

[13:28] <svnbot6> r7626 | iblech++ | * $arrayref => ... should stringify $arrayref (but ($arrayref => ...) should not).

[13:59] <eric256__> what do demagicalized pairs by us?

[14:01] <eric256__> ?eval sub x (@y) { @y.perl.say }; @y( x=> 2);

[14:01] <evalbot_7626> Error: Undeclared variable: "@y" 

[14:01] <eric256__> ?eval sub x (@y) { @y.perl.say }; @x( x=> 2);

[14:01] <evalbot_7626> Error: Undeclared variable: "@x" 

[14:01] <eric256__> ?eval sub x (@y) { @y.perl.say }; x( x=> 2);

[14:01] <evalbot_7626> Error: Insufficient number of required parameters: 0 actual, 1 expected 

[14:01] <eric256__> ?eval sub x (@y) { @y.perl.say }; x( (x=> 2) );

[14:01] <evalbot_7626> [("x" => 2)] bool::true 

[14:02] <eric256__> ?eval sub x (*@y) { @y.perl.say }; x( x=> 2 );

[14:02] <evalbot_7626> [] bool::true 

[14:02] <eric256__> ?eval sub x (*@y) { @y.perl.say }; x("test", x=> 2 );

[14:02] <evalbot_7626> ["test"] bool::true 

[14:02] <eric256__> ?eval sub x (Pair *@y) { @y.perl.say }; x("test", x=> 2 );

[14:02] <evalbot_7626> ["test"] bool::true 

[14:03] <eric256__> ?eval "hello".trans("h" => "t");

[14:03] <evalbot_7626> "hello" 

[14:03] <eric256__> you broke trans!!! 

[14:03] <eric256__> ;)

[14:03] <eric256__> ?eval "hello".trans(( "h" => "t" ));

[14:03] <evalbot_7626> "hello" 

[14:03] <eric256__> ?eval "hello".trans( ("h" => "t") );

[14:03] <evalbot_7626> "hello" 

[14:03] <eric256__> hmmm

[14:04] <eric256__> ?eval "hello".trans( (h => "t") );

[14:04] <evalbot_7626> "hello" 

[14:04] <iblech> eric256__: Demagicalized pairs are extremele important. In short: foo(bar => $baz) does now always pass $baz by the name "bar" to &foo. foo((bar => $baz)) does now always pass the pair (bar => $baz) positionally to &foo. foo($pair) does now always pass $pair positionally to &foo, even if $pair happens to contain a Pair object.

[14:05] <eric256__> gotcha...so how would we get trans( Str $self; Pair *@intable) to always take a list of pairs and not named parameters?

[14:06] <iblech> eric256__: Consider you wrote a generic subroutine, sub foo ($thing) { ...; bar($thing); ... }. Your &foo would probably break if somebody passed a pair to &foo, as this pair would get intepreted as a named arg by &bar.

[14:07] <eric256__> right. i understand, i think.  ;)

[14:07] <iblech> Larry meant we should use <== (so "hello".trans(<== "h" => "t", ...), IIUC)

[14:07] <eric256__> but how do i say, my sub doesn't accept named args so take named args as a list of pairs?

[14:07] <iblech> Or we have to add parens around each pair ("hello".trans((a => "b"), (c => "d")))

[14:07] <eric256__> okay thats what i was wondering

[14:08] <eric256__> i wonder why the parns aren't working right now though.

[14:08] <eric256__> ?eval "hello".trans( (h => "t") );

[14:08] <evalbot_7626> "hello" 

[14:09] <eric256__> ?eval sub x (Str $t, Pair *@intable) { @intable.perl.say }; x("t", (h => t));

[14:09] <evalbot_7626> Error: No compatible subroutine found: "&t" 

[14:09] <iblech> Yep, seems that the vanilla core has some kind of bug

[14:09] <eric256__> ?eval sub x (Str $t, Pair *@intable) { @intable.perl.say }; x("t", (h => 't'));

[14:09] <evalbot_7626> [("h" => "t")] bool::true 

[14:10] <eric256__> there are two cores?  thats the exact same signature and it works outside perlude.pm 

[14:10] <eric256__> ?eval sub x (Str $t, Pair *@intable) { @intable.perl.say }; x("t", (h => 't', q => 'r'));

[14:10] <evalbot_7626> [("h" => "t"), ("q" => "r")] bool::true 

[14:11] <iblech> Yep, there is the vanilla Haskell core, the JavaScript compiler, and the compiler to Perl 5

[14:11] <iblech> ah! Try rebuilding the Prelude

[14:11] * eric256__ still feels like there should be a way to say i'm expecting pairs so don't pars as args, but i'm guessing thats at the heart of magical vs. unmagical

[14:11] <eric256__> iblech++ 

[14:11] <eric256__> hadn't thought of that../me starts full rebuild

[14:17] <eric256__> do i have to make clean to force it to rebuild prelude?

[14:18] <iblech> eric256__: make clean works for sure, but modifying src/perl6/Prelude.pm (e.g. insert a space somewhere) will suffice

[14:18] * eric256__ slaps forhead....yea that would have worked, and triggered feather to rebuild too. lol 

[14:19] <eric256__> where you around last night when i was working on .perl ?

[14:19] <iblech> no, but I did saw your checkins

[14:20] <eric256__> do you know why when printing refs...it prints each layer and breaks the brackets off the previous layer until it reach the value?  fi you have $ref1 -> $ref2 -> Hash; it doe sthe first one, then does the second one breakcing the { } off the first and adding its own

[14:21] <eric256__> wouldn't it make sense just to skip printing anything till you get to the actual value?

[14:21] <iblech> ?eval my %hash = (a => 1); my $ref2 = \%hash1; my $ref1 = \$ref2; $ref1.perl.say

[14:21] <evalbot_7626> Error: Undeclared variable: "%hash1" 

[14:21] <iblech> ?eval my %hash = (a => 1); my $ref2 = \%hash; my $ref1 = \$ref2; $ref1.perl.say

[14:21] <evalbot_7626> {("a" => 1)} bool::true 

[14:22] <eric256__> you can't see it there because its removing the { } and then adding them agian. ever level

[14:22] <eric256__> but i changed the front { to hash... and i get hash(ash(1=>2))

[14:23] <iblech> Hm. The vanilla core always derefs references -- this might be important here

[14:23] <eric256__> which then took me an hour to trace around enough to realize that the multiple levels for ref created by for @z ( where driving me nuts

[14:23] <nothingmuch> morning

[14:23] <eric256__> morning

[14:24] <iblech> Hi nothingmuch :)

[14:25] <eric256__> if you look Prim.hs 1349 you'll see the function i'm talking about. it gets called twice if you do sub x (@y) { for @y ( $_.perl.print ) }; x({hello=>1});

[14:25] <eric256__> ?eval sub x (@y) { for @y ( $_.perl.print ) }; x({hello=>1});

[14:25] <evalbot_7626> \"perl6"Error: Pattern match failure in do expression at src/Pugs/Eval.hs:419:4-12 

[14:25] <eric256__> ?eval sub x (@y) { for @y ( $_.perl.print ) }; x(1);

[14:25] <evalbot_7626> \"perl6"Error: Pattern match failure in do expression at src/Pugs/Eval.hs:419:4-12 

[14:26] <iblech> ?eval sub x (@y) { for @y { $_.perl.say } }; x(1)

[14:26] <evalbot_7626> \1 undef 

[14:26] <eric256__> thats what i was going for. lol spaces ?

[14:26] <eric256__> ?eval 1

[14:26] <evalbot_7626> 1 

[14:26] <iblech> Actually, this call should die -- 1 is not an array. [1] or (1,) should work. Or, alternatively, the signature should read (*@y)

[14:27] <eric256__> see how the 'for'  makes a ref to 1 though

[14:27] <iblech> eric256__: It's for @array {...}, not for @array (...)

[14:27] <iblech> Ah

[14:27] <eric256__> that ref adds on top of exisiting refs, so if you pass it an array ref, you get a ref to an array ref

[14:27] <eric256__> duh

[14:27] <eric256__> lol

[14:27] <iblech> This is not a "real" ref, I think. It's because $_ is a full container, not only a value. See:

[14:27] <iblech> ?eval 1

[14:27] <evalbot_7626> 1 

[14:27] <iblech> ?eval my $foo = 1

[14:27] <evalbot_7626> \1 

[14:29] <eric256__> hmmm.. well if my moded version { x => 1 }.perl = "hash( (x => 1) )" while if use that sub above it prints "hash(ash( (x => 1))"

[14:31] <iblech> Ah, I get your problem now, I think. But anyway, { x => 1 } should .perl to either '{ x => 1 }' or '\hash((x => 1))'. And hash((x=>1)) should .perl to 'hash((x=>1))'

[14:32] <eric256__> yea and since i couldn't get the inner pairs to drop parents, i was going with hash or \hash...didn't matter till i could get it to print right though

[14:34] <iblech> ah, ok

[14:34] <eric256__> so i was trying to figure out a way in haskell to get to the bottum value instead of printing each one and stripping the { } off at different levels. 

[14:36] * eric256__ scratches his head....actualy it looks like it might be fixed already...oddnees

[14:39] <iblech> scook0: I just ran a new JS smoke with the demagicalized pairs patch in -- it seems that the only problem is that foo("x" => 1) is not recognized as a named (same bug as with foo(@array => 1)).

[14:39] <svnbot6> r7627 | iblech++ | PIL2JS: PIL::PApp: Properly handle complex structs (especially coderefs) as the

[14:39] <svnbot6> r7627 | iblech++ | RHS of a named (e.g. FETCH => {...}) (one-word patch).

[14:39] <iblech> scook0: But no other regressions :)

[14:44] <svnbot6> r7628 | iblech++ | src/perl6/Prelude.pm: Extremely minor cosmetical fix, so the Prelude gets

[14:44] <svnbot6> r7628 | iblech++ | rebuilt (needed by scook0++'s demagicalized pairs patch).

[14:48] <eric256__> ?eval '\hash(1,2)'.eval.ref

[14:48] <evalbot_7627> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-47 

[14:48] <eric256__> ?eval \hash(1,2).ref

[14:48] <evalbot_7627> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-37 

[14:48] <eric256__> ?eval hash(1,2).ref

[14:48] <evalbot_7627> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-35 

[14:49] <eric256__> ?eval 1;

[14:49] <evalbot_7627> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-21 

[14:49] <eric256__> ohh....okay. ?

[14:50] <eric256__> ?restart

[14:51] <eric256__> ?eval 1

[14:51] <evalbot_7628> 1 

[14:51] <eric256__> ?eval hash(1,2).ref

[14:51] <evalbot_7628> ::Hash 

[14:51] <eric256__> ?eval \hash(1,2).ref

[14:51] <evalbot_7628> \::Hash 

[14:51] <eric256__> ?eval {1,2}.ref

[14:51] <evalbot_7628> ::Block 

[14:51] <eric256__> ?eval {1 => 2}.ref

[14:51] <evalbot_7628> ::Hash 

[14:51] <eric256__> ?eval \{1 => 2}.ref

[14:51] <evalbot_7628> \::Hash 

[14:52] <nothingmuch> eric256__: this is discussed in s04 i think

[14:52] <nothingmuch> geoffb: ping

[14:52] <iblech> eric256__: \ binds stronger than method application, i.e. you've to use \(hash(...).ref)

[14:56] <nothingmuch> iblech: that seems odd

[14:56] <nothingmuch> it just doesn't look right syntactically

[14:57] <iblech> It's the same with ~long.expression(here)

[14:57] <iblech> (And, FWIW, it does look right to me, but I don't have a strong opinion on this)

[14:58] <eric256__> in pugs source...readRef gets the next layer of ref...unless i'm still way off base, is there a function that gets the actual value of the thing eventualy referenced?

[15:01] <iblech> eric256__: The problem is: you may only dereference exactly one real level, where "real levels" get created by prefix \, see t/var/autoderef.t. So a function which will dereference as often as needed to get the actual value would probably be against the spec

[15:02] <eric256__> hmmm. okay. so your saying if i'm in a for that is forcing an additionaly layer of ref, then when i perl print that it should be the extra ref?

[15:02] <iblech> eric256__: (But I do see your problem -- the vanilla core does a) not make a difference between real refs as created with \$foo and containers, and b) the vanilla core dereferences unlimitedly

[15:03] <eric256__> hehe..great

[15:03] <iblech> eric256__: Quite. The "additional layer of ref" you're seeing is not a real reference (which should get .perled), but only an indicator that you're .perling a container, not value. And this is a bug in pugs's internals, which is probably hard to fix

[15:04] <eric256__> but if i ignore the extra layer of ref then i might be ignore a true reference somewhere else?  but would a reference to a reference to a value, always be a reference to a value? (as far as .perl is concerned)

[15:05] <iblech> Exactly this is the problem, you can't know which refs are true refs and which aren't...

[15:06] <iblech> Yep. (\\5) should .perlify to \\5.

[15:06] <eric256__> ?eval \\5.ref

[15:06] <evalbot_7628> Error:  unexpected "\\" expecting program 

[15:06] <eric256__> ?eval (\\5).perl

[15:06] <evalbot_7628> Error:  unexpected "\\" expecting expression 

[15:06] <eric256__> ?eval (\ \5).perl

[15:07] <evalbot_7628> "\\5" 

[15:07] <eric256__> ?eval (\ \5).ref

[15:07] <evalbot_7628> ::Int 

[15:07] <eric256__> the docs say .perl just needs to output something that will eval back to the same ref type. 

[15:07] * eric256__ decides it must be time for cerial.

[15:08] <iblech> Here you see the bug -- (\\5) should be a Ref of Ref of Int, not a Int

[15:08] <eric256__> ohhh

[15:08] <eric256__> that seems like a pretty serious bug

[15:08] <eric256__> ?eval (\5).ref

[15:08] <evalbot_7628> ::Int 

[15:08] <eric256__> ?eval \(\5).ref

[15:08] <evalbot_7628> \::Int 

[15:08] <eric256__> ?eval \5.ref

[15:08] <evalbot_7628> \::Int 

[15:08] <iblech> Yep. The new Haskell runcore will fix this (and it is already fixed in the JavaScript runcore)

[15:09] <eric256__> when does the new one come out? becuase i'm not going to bother on .perl for now if its going to be fixed better soon ;)

[15:10] <iblech> autrijus has already started (see src/PIL*). IIRC porting stevan's metamodel to Haskell has got the highest priority ATM

[15:11] <eric256__> gotcha...guess i'll look for other tests to fix then. thanks

[15:11] <eric256__> drove me nuts all last night. ;)

[15:12] <iblech> nod...

[15:31] <rafl> Juerd: ping

[15:34] <gaal> hello everybody! has anyone here built their own ghc?

[15:35] <gaal> i want Hoogle to do GHC libraries, and the easiest way to get that is to run feather:~gaal/src/hihoo/hihoo.pl on a compiled GHC tree :-)

[15:35] <gaal> but ghc doesn't build correctly on feather or on my machine at home.

[15:36] <rafl> Juerd: ping

[15:37] <gaal> rafl: you're actually a likely candidate and you were logged out exactly as i was asking. do you happen to have ghc build from source yourself?

[15:38] <gaal> apt-get source ghc6 doesn't build out of the box.

[15:38] <Juerd> rafl: pong

[15:42] <nothingmuch> is irc.perl.org dead?

[15:42] <gaal> http://colabti.de/irclogger/irclogger_logs/perl6 is alive...

[15:42] <eric256__> irc.pugscode.org maybe?

[15:43] <gaal> oh, .perl.org, you're looking for #parrot?

[15:43] <gaal> ESCdd then.

[15:43] <nothingmuch> esc dd?

[15:43] <nothingmuch> oh

[15:44] <eric256__> how do you maodify the env for commands you are going to run with system?

[15:44] <gaal> env CAT=foo command

[15:44] <gaal> oh, from within Perl?

[15:44] <eric256__> yea

[15:45] <gaal> { local $ENV{CAT} = 'foo'; system ... } # p5

[15:45] <nothingmuch> eric256__: you can '{ local $ENV{xxx} = "foo"; system(@cmd_and_args) }'

[15:45] <gaal> { temp %*ENV<CAT> = 'foo'; ... } # p6, but won't work yet

[15:45] <nothingmuch> for a channel with 188 users #irssi is pretty dead

[15:48] <wolverian> nothingmuch, probably because it's just a help channel nowadays 

[15:48] <nothingmuch> i guesso

[15:48] <wolverian> nothingmuch, if you want development, #irssi2 (although I don't know how active it is either)

[15:48] <nothingmuch> i don't really =)

[15:48] <nothingmuch> i wanted help

[15:49] <eric256__> oh i was hoping to do it in p6...could i system('env CAT=foo command')

[15:49] <nothingmuch> eric256__: not portably

[15:50] <eric256__> okay. i think i have a way around it.  if a set the evn in a shell script, then run a perl script from the shell script, the env should carry over right?

[15:50] <iblech> eric256__: %*ENV<CAT> = "foo" does work, only temp on a hash element does not

[15:51] <rafl> gaal: That should be an RC bug.

[15:51] <rafl> gaal: I'll try to reproduce it.

[15:51] <eric256__> ohh. i don't care if i can temp it...do i?

[15:51] <gaal> this RC bug?

[15:51] <iblech> I.e. you have to my $old_cat = %*ENV<CAT>; %*ENV<CAT> = "foo"; system "..."; %*ENV<CAT> = $old_cat

[15:52] <gaal> s/this/what is an/

[15:52] <rafl> gaal: Release critical. I'll report it for you if you want.

[15:53] <rafl> Juerd: I wanted to ask if I can install tetex-extra and mzscheme on feather, but I just did it and removed it afterwards.

[15:54] <rafl> gaal: What's the error you get when building ghc?

[15:54] <gaal> rafl: okay. I just tried ./configure ; make

[15:54] <gaal> and there were a few C errors

[15:54] <Juerd> rafl: You can install anything via apt-get

[15:54] <Juerd> rafl: And anything else in your home directory

[15:54] <rafl> gaal: Do dpkg-buildpackage -us -uc -rfakeroot

[15:54] <gaal> the first one looked pretty silly, an undeeded static declaration, which i removed

[15:55] <gaal> but there were other problems later on.

[15:55] <Juerd> rafl: No debian packages without repositories in /etc/apt/sources.list, please though

[15:55] <Juerd> That sucks when libraries are upgraded :)

[15:55] <rafl> Juerd: Aye.

[15:57] <gaal> rafl: what do you need me to do?

[15:58] <rafl> gaal: Do apt-get source ghc6; cd ghc6.4-4.1; dpkg-buildpackage -rfakeroot -us -uc and tell me if it produces some errors.

[15:58] <gaal> it does, but i believe they don't have anything to do with my compilation errors.

[15:59] <gaal> because the compilation errors are very cish.

[16:01] <rafl> gaal: Paste them.

[16:01] <gaal> does debian have an automatic build system?

[16:01] <gaal> paste in a sec

[16:01] <rafl> Yes. It's started by doing dpkg-buildpackage -rfakeroot -us -uc in the src directory.

[16:01] <pasteling> "gaal" at 192.115.25.249 pasted "ghc6 source build error" (13 lines, 1.2K) at http://sial.org/pbot/13713

[16:02] <gaal> i mean, does every source upload get built for the maintainer?

[16:03] <gaal> rafl: so, this just looks like a bug in the GHC code, apparently simple to fix: remove the 'static' keyword from the declaration from static_objects'

[16:03] <rafl> There are no source-only uploads. Maintainers upload a source package + one binary build for their architecture. Other architectures gets build by build daemons.

[16:03] <gaal> but then there are different errors down the road

[16:03] <rafl> buildd.debian.org

[16:04] <gaal> rafl: so presumably the maintainer ought to know pretty fast about such a breakage?

[16:04] <rafl> I'm also compiling it ATM. Let's see if I can reproduce it.

[16:04] <rafl> Maybe you also want to try to build it in a clean chroot (pbuilder).

[16:04] <rafl> gaal: No. You don't get mails if the build fails.

[16:06] <gaal> rafl: the newest one at http://buildd.debian.org/build.php?arch=i386&pkg=ghc6 is from a while ago!

[16:07] <rafl> gaal: Yes. The 6.4-4.1 version was uploaded using binary-only NMUs for each architecture because it needed by-hand-bootstrapping.

[16:07] <rafl> (ghc6 build-depends on ghc6 and ghc6 wasn't installable)

[16:08] <rafl> OK, I need to go. See you in some hours.

[16:09] <gaal> bye rafl.

[16:10] <xerox> Searching for GHC .debs?

[16:11] <xerox> I'd say, use haskell-unsafe:  deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable testing stable

[16:11] <gaal> xerox: no, i want a built source tree

[16:11] <xerox> Maybe it has deb-src ?

[16:11] <gaal> to slurp function signatures from the .hi files

[16:11] <gaal> to create a .HOO file

[16:11] <xerox> Hoogle does that, iirc

[16:12] <gaal> so that Hoogle can finally show libraries

[16:12] <xerox> Ah!

[16:12] <xerox> You should talk with ndm.  He's doing that for Hoogle3.

[16:12] <gaal> # http://no.perlcabal.org/~gaal/hihoo.pl

[16:13] <gaal> (very rough first take)

[16:13] <gaal> xerox: he doesn't seem to be online on #haskell now.

[16:13] <xerox> Check #haskell-blah, he talked some mins ago.  Though he said something like "I'm drunk" :-P

[16:15] <svnbot6> r7629 | iblech++ | * t/syntax/pairs.t: foo("a" => 42) is named, foo(("a" => 42)) is not.

[16:15] <svnbot6> r7629 | iblech++ | * Pugs.Parser: Pairs with complex LHS may now be parsed as a Syn "named":

[16:15] <svnbot6> r7629 | iblech++ |     foo  @array => 42;   # named

[16:15] <svnbot6> r7629 | iblech++ |     foo (@array => 42);  # positional pair

[16:15] <svnbot6> r7629 | iblech++ | * PIL2JS:

[16:15] <svnbot6> r7629 | iblech++ |   * PIL::PApp, PIL::PVal: Stringify the LHS of a named pair.

[16:15] <svnbot6> r7629 | iblech++ |   * This means PIL2JS passes t/syntax/pairs.t 27/27! :) scook0++

[16:22] <iblech> ?eval sub foo { say caller().perl }; foo

[16:22] <evalbot_7629> Error: Must only use named arguments to new() constructor 

[16:22] <iblech> Ah, the Prelude needs to be recompiled again

[16:23] <svnbot6> r7630 | iblech++ | src/perl6/Prelude.pm: Again a trivial cosmetical change so the Prelude gets

[16:23] <svnbot6> r7630 | iblech++ | rebuilt (necessary because of r7622 and r7629).

[16:28] <brother> ?eval "ABC".trans("a" => "A", "b" => "B", "c" => "C")

[16:28] <evalbot_7629> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-98 

[16:29] <iblech> brother: Try again in a minute, feather is probably rebuilding pugs currently

[16:31] <wolverian> wow. that looks a wonderful interface. pairs are so natural for that sort of a thing.

[16:31] <wolverian> (really.)

[16:31] <wolverian> does it work if the value of a pair is more than one character? can I give it closures which it runs on every replacement?

[16:31] <wolverian> "ABC".trans(a => { ("A".."C").pick })

[16:32] <brother> Probaly not with a closure

[16:33] <wolverian> why not?

[16:34] <brother> but "<foo>".trans( '<' => "&lt;", '>' => "&gt;" ) is supposed to work

[16:34] <brother> ?eval "ABC".trans("a" => "A", "b" => "B", "c" => "C")

[16:34] <evalbot_7629> *** No compatible subroutine found: "&eval"     at -e line 11, column 5-98 

[16:34] <wolverian> right, that is similar use to that

[16:34] <brother> still not there

[16:34] <wolverian> and has nothing to do with my question :)

[16:35] <wolverian> i.e. why wouldn't closure work there (given that it could be implemented)?

[16:35] <gaal> Juerd: mind if I install + register hs-plugins on feather?

[16:36] <brother> ok, wrong answer. It doesn't work (now), not that it wouldn't work (eventually).

[16:40] <brother> ?eval "ABC".trans("a" => "A", "b" => "B", "c" => "C")

[16:40] <evalbot_7630> "ABC" 

[16:40] <brother> dohhh

[16:40] <wolverian> brother, ah. thanks!

[16:40] <wolverian> hahaha.

[16:40] <brother> you could have told me that first time I tried

[16:40] <wolverian> ?eval "ABC".trans(A => "a")

[16:40] <evalbot_7630> "ABC" 

[16:40] <brother> ?eval "abc".trans("a" => "A", "b" => "B", "c" => "C")

[16:40] <evalbot_7630> "abc" 

[16:40] <wolverian> oh, wow, => autoquoting doesn't work yet, I guess

[16:40] <wolverian> s,/wow, //

[16:40] <brother> ?eval "abc".trans("a" => "A", "b" => "B", "c" => "C")

[16:40] <evalbot_7630> "abc" 

[16:41] <wolverian> erm.

[16:41] <wolverian> oh, it's broken.

[16:41] <wolverian> sorry to confuse.

[16:41] <brother> ?eval "abc".trans("a" .. "c" => "A" .. "C")

[16:41] <evalbot_7630> "abc" 

[16:41] <brother> ?eval "abc".trans(["a" .. "c"] => ["A" .. "C"])

[16:41] <evalbot_7630> "abc" 

[16:42] <brother> ?eval "abc".trans(list ["a" .. "c"] => ["A" .. "C"])

[16:42] <evalbot_7630> Error: Unknown syntactic construct: Syn "named" [Syn "\\[]" [Pos (MkPos "<eval>" 1 19 1 29) (App (Var "&infix:..") Nothing [Cxt (CxtItem (mkType "Str")) (Val (VStr "a")),Cxt (CxtItem (mkType "Str")) (Val (VStr "c"))])],Syn "\\[]" [Pos (MkPos "<eval>" 1 35 1 45) (App (Var "&infix:..") Nothing [Cxt (CxtItem (mkType "Str")) (Val (VStr "A")),Cxt (CxtItem (mkType "Str")) (Val (VStr "C"))])]] 

[16:42] <wolverian> weird that it doesn't error either

[16:42] <brother> wow

[16:42] <brother> did I do that?

[16:42] <wolverian> well, now it did ;)

[16:42] <wolverian> ?eval list [1]

[16:42] <evalbot_7630> ([1]) 

[16:42] <wolverian> ?eval list [1] => [2]

[16:42] <evalbot_7630> Error: Unknown syntactic construct: Syn "named" [Syn "\\[]" [Pos (MkPos "<eval>" 1 7 1 8) (Val (VInt 1))],Syn "\\[]" [Pos (MkPos "<eval>" 1 14 1 15) (Val (VInt 2))]] 

[16:42] <wolverian> there you go.

[16:42] <wolverian> probably not your fault.

[16:43] <iblech> ?eval "abc".trans((a => "A"))

[16:43] <evalbot_7630> "abc" 

[16:44] <brother> Hmmm, "abc".trans(["a" .. "c"] => ["A" .. "C"])

[16:44] <brother> work on my pugs

[16:44] <xerox> Here does work too.

[16:45] <iblech> ?eval $?PUGS_VERSION

[16:45] <evalbot_7630> \"Perl6 User\'s Golfing System, version 6.2.10, October 10, 2005 (r7630)" 

[16:45] <brother> r7628 here

[16:46] <iblech> ?eval "abc".trans((["a" .. "c"] => ["A" .. "C"]))

[16:46] <evalbot_7630> "ABC" 

[16:46] <xerox> r7573 here

[16:47] <iblech> Since r7622, pairs are demagicalized (scook0++). Since r7629 complex named arguments are possible too. So .trans(["a".."c"] => ...) does not pass a Pair object to .trans, but the named argument "a b c"

[16:48] <iblech> Should pugs emit a warning in this case?

[16:49] <brother> So, for a short time r7617 till r7622 trans actually worked

[16:49] <iblech> It should still work if you add parens around the pairs

[16:51] <iblech> (It's a bug of the vanilla core that .trans(a => "A") doesn't die with "Unexpected named argument 'a'")

[16:51] <wolverian> oh, but that usage is so nice!

[16:52] <wolverian> ?eval "abc".trans( (["a"] => ["A"]) )

[16:52] <evalbot_7630> "Abc" 

[16:52] <wolverian> I guess I can live with that if I can remove the arrayreferences :)

[16:53] <wolverian> (I think that was the spec?)

[16:53] <wolverian> (wrt named arguments)

[16:59] <brother> ?eval "ABC".trans( 'A'=>'a', 'B'=>'b', 'C'=>'c' )

[16:59] <evalbot_7630> "ABC" 

[16:59] <brother> ?eval "XYZ".trans( 'XYZ' => 'xyz' )

[16:59] <evalbot_7630> "XYZ" 

[16:59] <iblech> wolverian: Yep, removing the [] ought to work

[17:00] <iblech> brother: You either need (the not yet implemented) <== or you have to add parens around the pairs. .trans("A" => "a") is parsed as passing the *named argument* "A" (with value "a") to .trans, not as passing the pair ("A" => "a") positionally to .trans

[17:00] <brother> ?eval "ABC".trans( ('A'=>'a'), ('B'=>'b'), ('C'=>'c') )

[17:00] <evalbot_7630> "ABC" 

[17:00] <iblech> yep, that should work.

[17:01] <wolverian> do I need to put the <== inside the parens?

[17:01] <wolverian> would this work: "ABC".trans <== a => "A";

[17:02] <iblech> dunno

[17:02] <wolverian> I think that works for normal functions

[17:02] <wolverian> foo ==> map { } ==> bar

[17:02] <wolverian> probably should work here too. I'll check for :todo tests

[17:02] <brother> ok, I give up.

[17:07] <iblech> http://www.nntp.perl.org/group/perl.perl6.language/23541 (message from Larry, "self" is now an alias for $?SELF)

[17:10] <iblech> http://www.nntp.perl.org/group/perl.perl6.language/23541 (message from Larry, "self" is now an alias for $?SELF)

[17:10] <iblech> err, wrong key

[17:15] <r0nny_> hoi there :)

[17:15] <gaal> ahoy r0nny_!

[17:17] <iblech> food &

[17:19] <Limbic_Region> anyone having problems building pugs from scratch on winders?

[17:19] * Limbic_Region just got a GHC out of heap error 

[17:20] <Limbic_Region> I am restarting the build now - but I have my doubts

[17:35] <mrborisguy> anyone here on feather?

[17:36] <mrborisguy> what's the best way to build pugs to test a change?

[17:36] <mrborisguy> I'd suppose it needs to be built locally in my /home somehow

[17:38] * Limbic_Region has an acct on feather but doesn't use it for anything other than IRC when I am at work

[17:44] <Limbic_Region> ok - succesfully built

[17:44] <Limbic_Region> any particular reason decimals are now showing up as fractions?

[17:44] <gaal> mrborisguy: read http://perlcabal.org/~autrijus/

[17:44] <Limbic_Region> ?eval my $foo = 11 / 10; say $foo

[17:44] <evalbot_7630> 1.1 bool::true 

[17:44] <gaal> mrborisguy: then cd into your pugs dir, and do perl Makefile.PL ; nice make

[17:45] <iblech> Limbic_Region: you mean:

[17:45] <iblech> ?eval say (11/10).perl

[17:45] <evalbot_7630> 11/10 bool::true 

[17:46] <gaal> whoa. is that intended?

[17:46] <Limbic_Region> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1); say $foo

[17:46] <evalbot_7630> 0.1 bool::true 

[17:46] <Limbic_Region> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  $foo

[17:46] <evalbot_7630> \1/10 

[17:46] <Limbic_Region> that's what I mean

[17:46] <gaal> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  "$foo"

[17:46] <Limbic_Region> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  $foo

[17:46] <evalbot_7630> "0.1" 

[17:46] <evalbot_7630> \1/10 

[17:46] <Limbic_Region> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  $foo

[17:46] <evalbot_7630> \1/10 

[17:46] <iblech> Yep, eric256 implemented this yesterday. The only requirement for .perl is, that $thing.perl.eval eqv $thing. Thus showing fractions as x/y is ok and doesn't loose precision

[17:47] <gaal> indeed. cool hack!

[17:47] <iblech> The stringification of fractions is unchanged, i.e.:

[17:47] <gaal> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  "$foo"

[17:47] <iblech> ?eval ~11/10

[17:47] <evalbot_7630> "0.1" 

[17:47] <evalbot_7630> 1.1 

[17:47] <gaal> :-p

[17:47] <Limbic_Region> this is definatley not what I mean though

[17:47] <iblech> eric256++ # indeed

[17:47] <Limbic_Region> if I multiply a decimal by an integer

[17:47] <Limbic_Region> I don't expect a fraction

[17:47] <Limbic_Region> ?eval my $foo = .1 * (int (rand 2) ?? 1 !! -1);  $foo

[17:47] <evalbot_7630> \1/10 

[17:48] <Limbic_Region> oh wait

[17:48] <Limbic_Region> nevermind

[17:48] <mrborisguy> gaal: thanks.

[17:48] <Limbic_Region> I am using .perl

[17:48] * Limbic_Region kicks himself

[17:48] <iblech> Limbic_Region: But if you say() or ~ $foo, you'll see normal 123.456-style output

[17:48] <Limbic_Region> this code is a bit old

[17:48] *** r0nny_ is now known as r0nny

[17:48] <Limbic_Region> I forgot how it worked

[17:48] <Limbic_Region> ok - so nmake required 2 runs for it to actually get all the way through

[17:48] <Limbic_Region> I ran out of ghc heap

[17:49] <Limbic_Region> but other than that - groovy

[17:49] <Limbic_Region> TTFN all

[17:50] <svnbot6> r7631 | iblech++ | examples/network/evalbot/{evalbot.p6,evalhelper.p5}: Support the other

[17:50] <svnbot6> r7631 | iblech++ | backends, e.g.

[17:50] <svnbot6> r7631 | iblech++ |   ?eval 5 + 3     # normal backend

[17:50] <svnbot6> r7631 | iblech++ |   ?eval:js 5 + 3  # PIL2JS

[17:50] <svnbot6> r7631 | iblech++ |   ?eval:p5 5 + 3  # PIL-Run

[17:53] <r0nny> is there somewhere a description of the pugs thread interface ?

[17:53] <iblech> r0nny: No... you may grep for Thread in src/Pugs/Prim.hs

[17:54] <r0nny> darn

[17:55] <iblech> ?eval "does evalbot still work?"

[17:55] <evalbot_7631> "does evalbot still work?" 

[17:55] <iblech> ?eval:js "and does -BJS work?"

[17:55] <evalbot_7631> *** Precompiled Prelude doesn't exist yet; precompiling...     (You can safely ignore the 'useless use of constant' warnings.) pugs: *** No compatible subroutine found: "&use"     at -e line 1, column 1 Use of uninitialized value in print at /home/fibonaci/devel/pugs-base/perl5/PIL2JS/lib/PIL2JS.pm line 142. *** Reading input from "/tmp/gJJDX52T0F"... *** Compiling PIL to JavaScript... Can't bless non-reference value at /home/fibonaci/devel/pugs-ba

[17:56] <r0nny> ?eval:c++ cout << "meh - wont work" << endl;

[17:56] <evalbot_7631> Error:  unexpected "c" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[17:56] <iblech> ?eval:p5 "hello from pil-run"

[17:56] <evalbot_7631> Can't locate Scriptalicious.pm in @INC (@INC contains: /home/fibonaci/devel/pugs-base/perl5/PIL-Run/lib /home/fibonaci/devel/pugs-base/perl5/PIL-Run/.. /home/fibonaci/devel/pugs-base/perl5/PIL-Run/../Perl6-Value/lib /home/fibonaci/devel/pugs-base/perl5/PIL-Run/../Perl6-Container/lib /home/fibonaci/devel/pugs-base/perl5/PIL-Run/../Perl6-MetaModel /home/fibonaci/devel/pugs-base/perl5/PIL-Run/../Perl6-MetaModel/lib /etc/perl /usr/local/lib/perl/5.8.7 

[17:58] <gaal> w00t!

[17:59] <gaal> ?eval say "iblech++ " xx 3

[17:59] <evalbot_7631> iblech++ iblech++ iblech++  bool::true 

[18:00] <iblech> ?eval say "thanks" xx 3  # :)

[18:00] <evalbot_7631> thanksthanksthanks bool::true 

[18:03] <r0nny> OMG

[18:04] <r0nny> pugs-threads are messy to understand

[18:07] <r0nny> can anyone tell me, if there is another way, then async, to create a thread ?

[18:09] <gaal> r0nny: nope. these are kind of uncharted water, too.

[18:09] <r0nny> hmm

[18:09] <r0nny> is there a way, to pass params in a nice way to a asynv block

[18:11] <gaal> dunno

[18:11] <gaal> funny pic of autrijus: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/14.html

[18:14] <xerox> We want names :D

[18:14] <gaal> names?

[18:15] <xerox> Of all those people! :-)

[18:15] <gaal> ah, ask syntaxninja on #haskell :)

[18:16] <integral> r0nny: pass params?  you just use closure surely?  sub foobar ($arg) { async { say $arg } } # ie, the sub generates asyncs that are closed over $arg

[18:17] <r0nny> integral: cool - thx

[18:18] <r0nny> so i can do a cmdline shell, and "fork" irc bots for different servers to the bg :)

[18:19] <gaal> r0nny: why would you not want to use separate processes for that?

[18:21] <r0nny> gaal: "fork" not fork ;P

[18:21] <r0nny> just let them be in the bg as threads

[18:25] <gaal> yes, i understand. why *not* use separate processes though? what do threads buy you?

[18:25] <iblech> brother: I think I have fixed $str.trans in r7632

[18:25] <svnbot6> r7632 | iblech++ | * src/perl6/Prelude.pm: Fixed $str.trans (trivial one-char patch).

[18:25] <svnbot6> r7632 | iblech++ | * t/var/constant.t: The initial value of a constant should get evaluated at compile-time.

[18:25] <iblech> gaal: inter-bot-communication :)

[18:26] <r0nny> no

[18:26] <r0nny> its one big bot handles different servers in different threads

[18:26] <gaal> iblech: that is a scary thought :)

[18:26] <iblech> :D

[18:27] <r0nny> btw - ho does variable-sharing betwen threads work in pugs ?

[18:28] <iblech> ?eval my $var; my sub forker () { async { $var++ } }; forker() for 1..20; $var

[18:28] <evalbot_7631> \19 

[18:29] <iblech> The framework for threading Pugs uses, STM, guarantees that the internal state etc. doesn't get corrupted

[18:29] <iblech> ?eval my $var; my sub forker () { async { $var++ } }; forker() for 1..20; 1 for 1..1000; $var

[18:29] <evalbot_7631> \20 

[18:29] <r0nny> so basically everything is not local is shared

[18:30] <gaal> '1 for 1..1000'? is sleep unsafe?

[18:30] <gaal> ?eval sleep 1; say "perhaps to dream"

[18:30] <evalbot_7631> Can't exec "./pugs": Permission denied at examples/network/evalbot//evalhelper.p5 line 46. 

[18:31] <gaal> ?eval sleep 1; say "perhaps to dream"

[18:31] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-59 

[18:31] <gaal> heh.

[18:31] <iblech> gaal: Yep, it is. Else you could ?sleep 1_000_000 (and this isn't trapped by BSD::Resource/ulimit, as sleep() doesn't burn any cpu time (IIRC))

[18:31] <gaal> it had better not ;)

[18:31] <r0nny>  ?eval my $var; ny sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:32] <r0nny> ?eval my $var; ny sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:32] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:32] <gaal> "ny sub"?

[18:32] <r0nny> ops

[18:32] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:32] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:32] <iblech> r0nny: Try again in a minute, the Prelude is currently recompiling, thus &eval isn't there yet

[18:33] <r0nny> ok

[18:33] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:33] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:33] <r0nny> hmm

[18:34] <iblech> s/try again in a minute/try again in two minutes/ ;)

[18:34] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:34] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:34] <r0nny> argh

[18:34] <r0nny> i got no patience

[18:35] <brother> iblech: nice, didnt see that

[18:35] * r0nny jumps around way to nervous, and breaks the src tree

[18:35] <r0nny> can i try now *dogy eyes*

[18:36] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:36] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:36] <r0nny> o0

[18:36] <theorbtwo> Hm, it was doing the 'No compatible subroutine found: "&eval"' thing the other day, too.

[18:37] <r0nny> damn - compile it faster

[18:37] * r0nny changed his mind-state to pre-insane

[18:38] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:38] <evalbot_7631> *** No compatible subroutine found: "&eval"     at -e line 11, column 7-229 

[18:38] <theorbtwo> r0nny: you could get your own copy...

[18:38] <theorbtwo> You can tell when evalbot fixes itself; it'll log out then log back in with a new username.

[18:38] <gaal> why, btw, are you declaring your subs 'my' at all?

[18:39] <theorbtwo> Yeah, like that, but it's supposed to log back in agin...

[18:39] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..10000; $var

[18:39] <theorbtwo> Thank you, evalbot.

[18:39] <r0nny> hope it eats it

[18:40] <evalbot_7632> (no output)

[18:40] <iblech> ?eval "abc".trans((a => "A"))

[18:40] <evalbot_7632> "Abc" 

[18:40] <theorbtwo> r0nny: Why are you trying to "eat" evalbot?

[18:40] <iblech> r0nny: s/10000/1000/ (evalbot has a cpu time limit)

[18:40] <r0nny> ehm - mean hope evalbot eats my code, and wont spill it out

[18:40] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..1000;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..1000; $var

[18:41] <evalbot_7632> \undef 

[18:41] <r0nny> ?eval my $var; my sub bsleep() { 1 for 1..10;} ; my sub forker () { async {bsleep for 1..rand(20); $var++ } }; forker() for 1..20; 1 for 1..1000; $var

[18:41] <evalbot_7632> \20 

[18:41] <r0nny> ?eval use xxo;

[18:41] <evalbot_7632> pugs: *** No compatible subroutine found: "&use"     at Prelude.pm line 61, column 30-59 

[18:42] <r0nny> ?eval my sub test(){use xxo;xxo->new;};

[18:42] <evalbot_7632> pugs: *** No compatible subroutine found: "&use"     at Prelude.pm line 61, column 30-59 

[18:42] <r0nny> it is secure

[18:52] <svnbot6> r7633 | iblech++ | t/operators/adverbial_modifiers.t: Fixed some tests WRT pairs now being

[18:52] <svnbot6> r7633 | iblech++ | demagicalized.

[18:58] <svnbot6> r7634 | iblech++ | New docs/journal/2005-10-15.kwid: scook0 demagicalized pairs; I updated PIL2JS

[18:58] <svnbot6> r7634 | iblech++ | accordingly; PIL2JS passes 27/27 of t/syntax/pairs.t.

[19:00] <geoffb> nothingmuch, I have not backlogged yet . . . but I saw you pinged?

[19:01] <nothingmuch> no longer relevant

[19:01] <nothingmuch> because I have to go

[19:01] <geoffb> ah

[19:01] <nothingmuch> but I wanted to start writing ;-)

[19:01] <geoffb> nothingmuch, I am gone most of today.  Back online tomorrow

[19:01] <nothingmuch> okies

[19:22] <Juerd> gaal: If it won't break automatic upgrades, go ahead

[19:22] <Juerd> gaal: If it's available through debian packages, use those.

[19:24] <wolverian> hm, now I have my own "feature" in perl6 as well.

[19:24] <Juerd> WHich?

[19:24] <wolverian> self is called 'self' by default.

[19:24] <Juerd> And .foo is $_.foo unconditionally?

[19:25] <wolverian> I assume so. the decision only pertained to naming, but that makes sense. I'll follow up if you want.

[19:25] <wolverian> actually, I guess I'll follow up anyway

[19:25] <wolverian> as it's important to me as well

[19:26] <wolverian> Juerd, or did you already?

[19:26] <Juerd> Nafaik

[19:26] <wolverian> how can you not know? :)

[19:27] <Juerd> I have faulty memory

[19:27] <wolverian> oh, okay. well, sending.

[19:27] <Juerd> It's not okay

[19:27] <Juerd> Not remembering things sucks

[19:28] <wolverian> I'm sorry.

[19:29] <wolverian> sent.

[20:31] <rafl> gaal: ghc6 (sid version) built fine in my chroot.

[20:31] <rafl> gaal: I don't know where your problem is. Please also try to build it in a clean environment.

[21:05] <svnbot6> r7635 | iblech++ | Moved primitive_named_params.t and passing_the_pair_class_to_a_sub.t out of

[21:05] <svnbot6> r7635 | iblech++ | pugsbugs/, as they pass now (because of the demagicalizing pairs patch).

[22:38] <wolverian> does S02 really mean to imply that you can use regexes as q:to (heredoc) terminators?

[22:45] <rafl> Pugs is in Debian testing, yay! (6.2.8, though. 6.2.10 needs to go though the NEW queue first)

