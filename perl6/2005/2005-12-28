[01:00] <Tman> so does the SVN system allow changes directly to the trunk or do committers have to branch out and let an admin of some sort merge their changes?

[01:01] <avar> directly to the trunk

[01:01] <Tman> interesting

[01:01] <avar> although that probably depends on how you set up the repository, but by default...

[01:01] <Tman> well I mean for pugs

[01:02] <Tman> how much abusement do you see?

[01:02] <avar> none?

[01:03] <Tman> cool

[01:03] <Tman> I was just wondering, since I read about the project and its openness

[01:04] <Tman> or whatever you want to call it

[01:04] <audreyt> "anarchy" is how I call it, but whatever :)

[01:04] <audreyt> nothingmuch: http://pugs.blogs.com/audrey/2005/12/why_did_the_jou.html

[01:04] <audreyt> # the reason(s) of the journal move

[01:04] <avar> people probably commit bad stuff once in a while, but not on purp

[01:05] <audreyt> yeah, and there's at least 3~4 people constantly watching every diff

[01:05] <audreyt> since commits are announced on the channel here

[01:05] <avar> audreyt: that bot should say which file was modified though..

[01:05] <avar> like CIA

[01:06] <avar> although it's easy to find out

[01:06] <audreyt> avar: nod... there's a knob to turn on reporting of subdirs

[01:07] <Odin-LAP> audreyt: Anarchist?

[01:07] <audreyt> but it's noisy already, and "svk desc HEAD" works happily

[01:07] <audreyt> Odin-LAP: yeah, publicly so, as listed on my wikipedia page

[01:07] <Odin-LAP> audreyt: Hmmm.

[01:09] <Odin-LAP> Individualist anarchism. Always struck me as a solid line of reasoning that didn't really dare going all the way. *grin*

[01:10] <Tman> was svnbot6 made specifically for this channel?

[01:11] <Tman> I want one for my project =)

[01:11] <avar> Tman: on freenode?

[01:11] <Tman> yup

[01:11] <Odin-LAP> It was, wasn't it ... exercise for perl6 IRC module, or somesuch?

[01:12] <avar> Tman: why not just use CIA?

[01:12] <Tman> never heard of it :p

[01:12] <avar> /join #commits

[01:12] <Tman> thanks

[01:12] <avar> you can get a bot like that for your channel and repository for free

[01:12] <avar> http://cia.navi.cx/

[01:13] <Tman> awesome :D

[01:18] <Odin-LAP> audreyt: Anyway. In that case, there's a lingering question. What do you think of the distinction made, by some, between 'property' and 'possession'?

[01:20] <audreyt> re

[01:21] <audreyt> Odin-LAP: I don't see a difference, frankly.

[01:22] <audreyt> otoh, as a non-native english speaker, I may have missed some nuances.

[01:22] <Alias_> I second that

[01:22] <Alias_> ;)

[01:23] <Alias_> There's another hundred or so lines of M:I docs now... covers the all_from-related things, requires, build_requires, and no_index

[01:23] <audreyt> Alias_: oooh oooh

[01:23] <Alias_> But that's it

[01:23] <Odin-LAP> The distinction is arbitrary, really. In general usage, the two don't signify very different ideas.

[01:23] <Alias_> One or two more chunks of doc and I think I'll be ready to bleat to the world about Task::

[01:23] <audreyt> Odin-LAP: I'm not familiar with the arbitrary distinction then

[01:24] <Odin-LAP> The author who proposed the distinction made an analogy, though. "The lover is possessor, the husband proprietor."

[01:24] <Alias_> audreyt: Also, XML generation works now for PITA::Report all the way out to the top tag

[01:24] <audreyt> Alias_: wow, you've been productive

[01:24] <Alias_> audreyt: Just working on the parser side and got sidetracked by bugs in IO-stringy, which I might need to take over :/

[01:25] <Alias_> audreyt: No commercial work you see, a week off does wonders.

[01:25] <audreyt> Odin-LAP: I grok the proprietor bit, but not the possessor bit ;)

[01:25] <Alias_> Did I mention there's a centralised API for sending SMS now too...

[01:25] <Alias_> SMS::Send :)

[01:25] <audreyt> now if it's "processor", that I understand...

[01:26] <audreyt> nice :)

[01:26] <Alias_> Of course, my minion just dropped in to fix a server and brought Aeon Flux and Lord of Ward with him... so I'll be useless for a few hours

[01:26] <Alias_> War

[01:27] <Odin-LAP> audreyt: Possessor is someone who possesses something. :p

[01:27] <Alias_> also generally implying ownership

[01:28] <audreyt> Odin-LAP: but in the case of love, it's more like "possessed"

[01:28] <audreyt> Odin-LAP: now, if my obssession on pugs makes me the possessor of pugs, that's certainly something I can relate to

[01:28] <Odin-LAP> The distinction is that a possessor is the 'owner' of something by virtue of using it. Proprietor is the 'owner' by virtue of being, for some reason or other, legally entitled to its control.

[01:29] <Odin-LAP> That was an analogy ... not the exact difference. :p

[01:29] <audreyt> Odin-LAP: oh. then I'd argue "possessor" is a really weak work of it. "shares" or "is part of" or "user" or "developer" works better

[01:29] <audreyt> s/work/word/

[01:30] <Alias_> benevolent dictator

[01:30] <Odin-LAP> audreyt: In the context of intellectual property, yes. I didn't invent the words. :/

[01:31] <audreyt> in any case... I'm all for things that grows more the more people use it. aka commons. :)

[01:32] <Odin-LAP> The distinction comes from Pierre-Joseph Proudhon, and the translation from Benjamin Tucker, who both did their important works over a century ago. :(

[01:32] <Odin-LAP> Heh. :)

[01:32] <Alias_> audreyt: collective

[01:33] <Alias_> "father of the collective"

[01:33] <audreyt> nod, now I begin to remember my Proudhon. otoh, I don't think the idea of comparing intellectual works to private properties is hip during his era, so the context have changed somewhat

[01:33] * Odin-LAP screams "commies!"

[01:33] * audreyt screams "lptties!"

[01:33] <Alias_> er... "mother of the collective"

[01:34] <Alias_> .patch

[01:34] <audreyt> I thought you'd prefer "evil genius over the minions collective"

[01:34] <Alias_> minions aren't a collective... they may be drones but don't contribute intelligence

[01:34] <Odin-LAP> audreyt: Yeah. "Intellectual property" is a bit of mess-up in this context. It depends on which simile you'll drive in which direction. Do you move "owner" to the arena of authorship, or "author" to the arena of ownership?

[01:35] <Alias_> In this case, you steer the ship less, so hive mind is more appropriate

[01:35] <audreyt> ahh, I see you have been in touch with less advanced minion forms

[01:35] <Alias_> You prefer anarchy, I prefer things to work first time :)

[01:35] <audreyt> my (unsuspecting) minions are all as intelligent as I am :)

[01:36] <audreyt> Odin-LAP: I much prefer lwall's use of "author"

[01:37] <Odin-LAP> audreyt: Hm. How does he use it?

[01:37] <audreyt> granted there's more than a bit of christianity in his use of authorship, but somehow I think it's a much more fit metaphor

[01:37] <audreyt> from perl5/README:

[01:37] <audreyt> Just a personal note:  I want you to know that I create nice things like this

[01:37] <audreyt> because it pleases the Author of my story.  If this bothers you, then your

[01:37] <audreyt> notion of Authorship needs some revision.  But you can use perl anyway. :-)

[01:37] <audreyt>   The author.

[01:38] <Odin-LAP> Heh.

[01:40] * Odin-LAP has, perhaps unfortunately, come to the conclusion that he cannot believe the christian narrative.

[01:40] <avar> refering to god?

[01:40] <Odin-LAP> But I understand where he's coming from.

[01:41] <audreyt> avar: yup

[01:41] <audreyt> Odin-LAP: I think he had refactored his narrative into something I can empathize with

[01:41] <audreyt> http://interviews.slashdot.org/interviews/02/09/06/1343222.shtml

[01:43] <audreyt> A) God exists, and B) God is good to people who really look for him.

[01:44] <audreyt> now, if you really look for something, it's highly likely that you'll perceive that something becomes good to you.

[01:44] <audreyt> so I have no problem with that :)

[01:44] <Odin-LAP> Hmm.

[01:44] <Odin-LAP> Yes. Maybe.

[01:46] <avar> It doesn't make sense to me that an omniscient being would tell you to be "good", because by definition 1. it already knew what you were going to do 2. what do you is by extension completely under its power since it's omniscient it would have done something differently if it wanted different results, and it knew the results before hand because it's ... omniscient

[01:46] <avar> does that make sense?;)

[01:46] <Odin-LAP> Look, my mother is a born-again christian. She's been quite active at church since I can remember. Through much of my childhood, I went to 'sunday school'. It just ... didn't catch.

[01:47] <audreyt> avar: I think omniscience is overrated... especially on the future part

[01:47] <avar> I like some religions, like Buddhism, but I think Christianity mainly focuses on setting rules for you and keeping you in check

[01:47] <audreyt> avar: I watch all commits to pugs, and I have _some_ control of what the next commit would be, but I have no idea what other people are going to do :)

[01:47] <avar> like "god loves you", and "fuck with god and you go to hell" ;)

[01:48] <avar> audreyt: well, you're not omniscient;)

[01:48] <audreyt> avar: my point being an author's omniscience of her characters doesn't really mean she's omnipotent on how to move them... there are limits, and there are really bad novelauthors.

[01:48] <Odin-LAP> Omniscience, omnipotence and a purely benovelent nature, to me, don't seem to match the world we live in.

[01:48] <Alias_> avar: Many religions feature heavily rules to make your life better the rulers couldn't consistently prove, "So trust us and do it anyway"

[01:49] <Alias_> "Don't kill, don't lust after your neighbour's wife, no pig meat, etc"

[01:49] <audreyt> at one time pig meat may really be harmful to health.

[01:50] <Alias_> it very much can be

[01:50] <avar> audreyt: the premise is that if you're omniscient there's by definition nothing you can't anticipate, and know before hand

[01:50] <avar> since every variable in the world and how it reacted to everything else would be known to you

[01:51] <avar> It's kind of like if I were the best programmer in the world and were to write a program that segfaults, declare that the program should be sent to hell for its sins which were quite obviously my fault;)

[01:52] <Alias_> IF you operate within the framework of religion, you cannot drawn an accurate conclusion

[01:52] <audreyt> avar: but once you've written a program that is computationally as unpredictable as you are -- or even better than you (seed AI)

[01:52] <avar> Or kick it out of the garden of eden because I gave it certain input and it reactedin a certain way;)

[01:52] <avar> *reacted

[01:52] <audreyt> avar: then the omnisicnec of its source code doesn't give you much :)

[01:54] <avar> audreyt: Okey let's presume that, but again the creator would be omniscient and would therefore know what input the AI would get before hand and by extension know how the AI reacted to it and what it would do...

[01:55] <avar> That's my main problem with christianity, it sounds too much like a kid with a magnifying glass smiting ants

[01:55] <avar> with the kid being god and the ants being the humans

[01:55] <Alias_> And read Genesis, it's bizarre

[01:55] <Odin-LAP> Omniscience is, literally, knowing *everything*. You don't have omniscience "regarding" something, or "of" something. There is no other definition or understanding of the term.

[01:56] <Odin-LAP> The Bible's god has Dissociative Personality Disorder.

[01:56] <audreyt> Odin-LAP: but there is something unknowable, and an omniscience being cannot know those. :)

[01:56] <Odin-LAP> audreyt: Not at all. If there are things which are unknowable, there cannot be an omniscient being.

[01:56] <audreyt> Odin-LAP: oh, just like the typical father figure as featured in in childhood psychology.

[01:56] <audreyt> our definitions differ then :)

[01:58] <Odin-LAP> omni = all, scient = knowing; if something cannot be known, then by extension nothing can be all-knowing. :p

[01:58] <audreyt> if something can kill every being, can it kill pi?

[01:59] <Odin-LAP> Is the irrational number a 'being'?

[01:59] <audreyt> and is an omnievitor impossible because of pi? :)

[01:59] <Alias_> If Pi falls in a wood and nobody is alive to here it, is it still irrational?

[01:59] <audreyt> Odin-LAP: aha, and I mean that there's some objects that does not have the .to_know method defined

[01:59] <audreyt> i.e. they are not in the Knowable role

[01:59] <avar> If Richard Stallman speaks and nobody hears him, does he make a sound?

[02:00] <audreyt> and so omniscience doesn't apply to those things in my definition, and that's fine to me

[02:01] <avar> audreyt: An omniscient being knows *everything*, if there's something it doesn't know it doesn't fall under the definition

[02:01] <audreyt> avar: unless he is somehow deaf, somebody must have heard him

[02:01] <Odin-LAP> audreyt: If they cannot be known, they cannot factor into anything else. They cannot influence knowable things, for that would make them knowable.

[02:01] <audreyt> Odin-LAP: as a Wittgenstein admirer, I must respectfully disagree :)

[02:02] <audreyt> (i.e. things can be shown but not known)

[02:02] <avar> audreyt: If you think an omniscient being can't know some things then by extension doesn't it know nothing at all, since everything can affect everything else?

[02:03] <avar> i.e. if they were to coexist in the same universe

[02:03] <audreyt> avar: how things affect other things in general is, I think, one of things that cannot be known :)

[02:03] <Odin-LAP> audreyt: Hmm. If an unknowable influences a knowable, you will know that the influence occurs. Therefore, even if you do not know exactly what it is, you will know that something is there. Since an omniscient being will have perfect knowledge, disregarding time, it will know of the influence - even before it occurs.

[02:04] <audreyt> Odin-LAP: the "influence" part is one of the unknowables... that makes me a mystic, and I think this line of argument doesn't quite apply anymore :)

[02:05] <Odin-LAP> Hrm. I see.

[02:05] <audreyt> (I also perceive causal systems as illusory, fwiw.)

[02:06] <audreyt> <- learned the "scientific" reasoning system and related vocabularies relatively late

[02:06] <Alias_> <- still hasn't

[02:07] <audreyt> lol

[02:07] <audreyt> Alias++

[02:07] <Alias_> I had to bootstrap my own belief system from first principles. Took me till 22

[02:07] <avar> mm,

[02:07] <avar> that's one of the problems with arguing with religion, it isn't falsifiable;)

[02:08] <Alias_> ah, but that's only if you accept the premise of it's existance

[02:08] <Alias_> When analysed as a non-biological life form, it displays elegant similarity to other forms of life

[02:09] <audreyt> and life forms in general doesn't do the Falsifiable role.

[02:09] <Alias_> It's not self-evident, it doesn't appear fully formed. It evolves...

[02:09] <Odin-LAP> Meh. The *problem* with arguing with religion is that argument is based on rationality; religion isn't.

[02:09] <Odin-LAP> Of course, you may have an issue with rationality, I don't mind that.

[02:09] <audreyt> Odin-LAP: I see you have a pass-by-value argument style :)

[02:09] <Odin-LAP> But it certainly makes sustained arguments easier. ;)

[02:10] <avar> yeah

[02:10] <Odin-LAP> audreyt: Hm?

[02:10] <audreyt> in pass-by-reference, where words are more like chess pieces, rationality is optional

[02:10] <avar> "x is true just because" as opposed to "x is true because..."

[02:10] <Odin-LAP> Hmmmm. Philosophy is very much playing with words.

[02:10] <audreyt> eg. I think the game of Go's goal is to make pretty patterns.

[02:11] <Alias_> There is but one truth, math. It's the one thing that deals with truth provably

[02:11] <Odin-LAP> Russell wanted to fix them, though. I'm not sure that was a good idea.

[02:11] <audreyt> Derrida thinks the same for philosophy :)

[02:11] <Alias_> And Haskell is math in code form, thus is you can prove it in Haskell, it is truth

[02:11] <avar> audreyt: thanks for that /. interview b.t..w

[02:11] <audreyt> avar: np :)

[02:11] <Alias_> Now implementing relgion in Haskell, THAT's an interesting problem

[02:13] <Odin-LAP> Alias_: Actually, mathematics is *not* verifiably concerned with truth. Mathematics is concerned with mathematics, and has its own definition of truth, which is quite distinct form epistemological truth. The fact that mathematics has a strong empirical relationship with what we call 'reality' is admittedly not entirely coincidental, but it's not an inherent feature...

[02:14] <Alias_> true

[02:15] <audreyt> cf. this paper:

[02:15] <audreyt> http://www.lecb.ncifcrf.gov/%7Etoms/Hamming.unreasonable.html

[02:15] <audreyt> which I like a lot

[02:16] <audreyt> "The Unreasonable Effectiveness of Mathematics"

[02:19] <audreyt> bbiab

[02:19] <Odin-LAP> Religion, defined as the belief in some superior principle which has defined form outside of human mentality, is perhaps the most dangerous concept ever to appear in this world.

[02:21] <Alias_> Maybe, but then god lives in the unknown, and as the unknown recedes, so does god. 

[02:21] <Alias_> Otherwise we see reality disfunctions

[02:21] <Odin-LAP> Alias_: If God really did exist, it would be necessary to abolish him. (Mikhail Bakunin)

[02:21] <Alias_> And then religion evolves to hande the change in the location of the unknown

[02:22] <Odin-LAP> Though I'd consider myself an agnost. I believe that the question of god's presence or absence is undecideable, and irrelevant to us.

[02:22] <Alias_> indeed

[02:22] <Alias_> Fundamentalist Agnostic

[02:23] <avar> Odin-LAP: same here;)

[02:23] <Odin-LAP> You might say that. I take a similar stance regarding free will, actually. We cannot know if free will is real, or mere illusion.

[02:24] <audreyt> ...or even means anything operationally.

[02:24] <Alias_> But at some point, it becomes unproductive to continue pondering until further evidence appears

[02:24] <Odin-LAP> audreyt: Hmm?

[02:25] <audreyt> Odin-LAP: I've yet to come across with a verifiable operational definition of free will.

[02:27] <Odin-LAP> Hmmm.

[02:28] <Odin-LAP> The ability to make decisions non-deterministically, I'd think. But how do you know if something is nondeterministic?

[02:29] <Alias_> Our form of decision making is just a compensation

[02:29] <Odin-LAP> That's the problem. The question is undecidable.

[02:29] <Odin-LAP> Alias_: Hm?

[02:29] <Alias_> complex nondeterministic questions require a complexity-derived answer

[02:29] <Alias_> Hence, our brains

[02:30] <Alias_> ETOOMANYPHDS

[02:31] * audreyt resists the temptation to invoke wolfram

[02:33] <audreyt> no disrespect meant, but to me his name does conjure a mental image of a wolf with lots of RAM.

[02:34] * audreyt goes back hacking Rules support.

[02:49] * Debolaz goes back to trying to make pugs work on FreeBSD with pkgsrc.

[02:49] <Debolaz> Which haskell doesn't seems to like. 

[02:50] <audreyt> fbsd does pkgsrc now?

[02:50] <audreyt> I thought it's a nbsd thing.

[02:57] <Debolaz> audreyt: pkgsrc works on many platforms. But for some reason I've not been able to figure out, it doesn't seem to be related to any environment variable or parameter, the test compilations done by Makefile.PL fails when run from pkgsrc, but succeeds when run manually.

[02:58] <Debolaz> I've been able to narrow it down to ghc not passing the proper arguments to ld in the former case, but I can't figure out why.

[03:00] <Debolaz> More specifically, -L/usr/pkg/lib/ghc-6.4.1 is passed on ld when not run through pkgsrc, which makes it work, but for some reason, something makes ghc substitute it for something else that doesn't seem tied to any environment variable or parameter when pkgsrc executes Makefile.PL

[03:00] <Debolaz> And right about now, I'm hating haskell. :P

[03:02] <audreyt> heh.

[03:02] <audreyt> which Cabal version does pkgsrc have?

[03:03] <Debolaz> /usr/pkg/lib/ghc-6.4.1/package.conf:

[03:03] <Debolaz>     Cabal-1.0

[03:04] <audreyt> hm, ancient cabal shipped as default

[03:04] <audreyt> also, did you run manually as yourself or as root?

[03:05] <audreyt> also, upgrading Cabal may help.

[03:05] <audreyt> http://haskell.org/cabal/download.html

[03:05] <Debolaz> I guess it's worth mentioning that I had to port ghc to pkgsrc myself since the stock version in pkgsrc only works on NetBSD. At least there is an irony to all of this, I read in an interview with Autrijus that parrot was more problematic to compile on FreeBSD.. parrot works flawlessly. :)

[03:05] <Debolaz> I ran this as root.

[03:05] <audreyt> heh, the irony :)

[03:06] <audreyt> bug reports go here -- http://hackage.haskell.org/trac/hackage -- also #haskell may help, esp. if SyntaxNinja (the cabal guy) is around.

[03:07] <audreyt> it worked flawlessly on freebsd... but I guess that's because one of GHC core team hackers hacks fbsd

[03:08] <audreyt> stevan_: yo

[03:08] <Debolaz> I'll try installing the new cabal first, then I go bother them. :)

[03:09] <audreyt> cool :)

[03:10] <Debolaz> It will probably end up being some minor detail I'm overlooking, it get the feeling it usually is.

[03:11] <audreyt> ah, the quest for Just Works :)

[03:18] <Alias_> Gawd IO-stringy is a mess :(

[03:36] <avar> http://interviews.slashdot.org/comments.pl?sid=39406&cid=4207979

[03:43] <audreyt> avar: that's a very good creation myth on par with FSM  :)

[03:47] <avar> It's the most internally consistant theory of creation I've read yet;)

[05:03] <_tcc> I got banned from #perl lol.

[05:03] <_tcc> Can someone help me with something?

[05:03] <_tcc> I changed something and I screwed everything up.

[05:05] <Alias_> why

[05:05] <_tcc> Because I am stupid.

[07:17] <svnbot6> r8494 | Darren_Duncan++ |  r1670@Darren-Duncans-Computer:  darrenduncan | 2005-12-27 23:14:05 -0800

[07:17] <svnbot6> r8494 | Darren_Duncan++ |  /ext/Rosetta-Incubator : begun converting current generic string exceptions to specific LKT ones; added 10 messages to LKT/L/en.pm, upgraded Message class in LKT.pm, added 3 private methods

[08:25] *** jiing_ is now known as jiing

[10:02] <clkao> seen audreyt

[10:02] <jabbot> clkao: audreyt was seen 6 hours 18 minutes 53 seconds ago

[10:08] <GeJ> wow YAML::Syck 0.03 already in the ports... that's fast

[10:12] * Grrrr bows

[10:14] <clkao> Grrrr++

[10:17] <GeJ> Ah, there's the guilty one... 

[10:17] <GeJ> Grrrr++

[10:17] <GeJ> indeed

[11:04] <gaal> say, remember the PLEAC stuff? where'd the p6 version go?

[11:28] <gaal> it seems to have been eaten completely :-(

[11:33] <svnbot6> r8495 | audreyt++ | * Text.Parser.Rule: All PGE nodes represented as Haskell structures.

[11:33] <svnbot6> r8495 | audreyt++ |   Next step is to found PArrows equivalents...

[11:34] <gaal> ah, just renamed (doh) http://svn.openfoundry.org/pugs/examples/cookbook/

[12:09] <rafl> Juerd: Boring, isn't it?

[12:10] *** rafl_ is now known as rafl

[12:14] <rafl> The following code croaks with this error. Why? "*** foo: openFile: resource busy (file is locked)"

[12:14] <rafl> { my $fh = open($file, :r) or die; } { my $fh = open($file, :w); }

[12:15] <rafl> Shouldn't the file be closed as soon as I leave the scope of the first block?

[12:15] <audreyt> because out of scope timely destruction can no longer be guaranteed.

[12:15] <audreyt> otoh, it makes sense to declar IO types to be GC'ed away on end of scope.

[12:15] <audreyt> write a test?

[12:16] <audreyt> I'll add it to PIL^N runcore. the current runcore have to call an expensive performGC

[12:16] <audreyt> which we tried, but crashes on OSX a lot

[12:17] <rafl> Why can't that be guaranteed anymore?

[12:17] <rafl> OK. I'll write a test. t/pugsbug/?

[12:19] <Alias_> audreyt: aaaaalmost there...

[12:26] <r0nny> yo

[12:26] <Alias_> audreyt: ftp://pause.perl.org/incoming/PITA-Report-0.02.tar.gz

[12:26] <Alias_> audreyt: So now about those minions :)

[12:26] <r0nny> audreyt: howz the object system now ?

[12:28] <audreyt> rafl: because we are not refcounting

[12:28] <audreyt> r0nny: Role support is in, I had not started container types

[12:28] <audreyt> plan to do it tomorrow after $work

[12:29] <audreyt> after container types (which should be straightforward) is ArgList and SigList

[12:29] <audreyt> and then we can hook it to parser

[12:29] <r0nny> hmm

[12:29] <r0nny> so in about a week everything should be fine, to continue ?

[12:29] <audreyt> that's the plan

[12:29] <audreyt> but I'm sidetracked to this PGE clone thing

[12:30] <audreyt> but I'm finishing it as we speak

[12:30] <audreyt> shouldn't take too long

[12:30] <r0nny> hf :)

[12:30] <r0nny> and if it works again, im going to have fun :)

[12:31] <audreyt> :D

[12:40] <svnbot6> r8496 | rafl++ |  r24288@ata:  rafl | 2005-12-28 13:29:30 +0100

[12:40] <svnbot6> r8496 | rafl++ |  * Added a test for closing open files if the filehandle goes out of scope.

[12:55] <gaal> audreyt: yo. didn't quite grok FFI and writing c in Haskell yet but am at $work soooo.. manana :)

[12:56] <Juerd> rafl: Yea

[12:56] <gaal> also: evalling yaml could use SyckNodes for intermediate structures and avoid coupling with pugs altogether. The other direction won't work, of course, since emitYaml needs to be Val -> IO String

[12:57] <gaal> and each node in the Val is another Val

[13:01] <audreyt> gaal: yup.

[13:01] <audreyt> although

[13:01] <audreyt> you can first do a

[13:01] <audreyt> Val -> Eval SyckNode

[13:01] <audreyt> and go from there

[13:02] <rafl> Juerd: The syntax made me kind of sick.

[13:02] <gaal> audreyt: and place that where? in Pugs.Prim.Yaml or in Data.Syck?

[13:03] <audreyt> P.P.Y

[13:04] <Juerd> rafl: I didn't have many problems with the syntax, to be honest. I just hate #() and alike syntaxes.

[13:04] <gaal> Do you have an example for a project that does more FFI work, btw? FastPackedString does, but the thing I was looking for was allocating memory inside a haskell function (to do keep the output buffer around via a "bonus" struct)

[13:04] <Juerd> rafl: What made me sick is the waaaay to high level of programming, for the web.

[13:05] <audreyt> gaal: you probably want "alloca" or even "malloc/free"

[13:05] <Juerd> Ignoring HTTP is simply not an option, if you want to ever be able to debug problems that are caused by bad clients.

[13:05] <audreyt> or even better, write some inline C

[13:05] <audreyt> and the just import it in

[13:06] <gaal> also: I will start with a haskell String, but it probably makes sense to use FPS for accummulating emitted yaml. The only thing is, does it make sense for one Data. to depend on another?

[13:06] <gaal> eeep, is alloca the alloca I think it is? I refuse to use that :-)

[13:06] <audreyt> it's not that bad

[13:06] <audreyt> it's scoped

[13:06] <audreyt> freed on the next action

[13:06] <audreyt> alloca :: Storable a => (Ptr a -> IO b) -> IO b

[13:06] <audreyt> the Ptr a never escapes

[13:07] <gaal> I refuse to use it in "real" c too

[13:07] <audreyt> what's wrong with it?

[13:07] <gaal> it has the right semantics, but the wrong portability etc.

[13:08] <audreyt> oh. the FFI one should be happily portable and strongly typechecked

[13:08] <audreyt> in any case, inline C is probably best bet.

[13:08] <audreyt> just like XS.

[13:09] * gaal nods

[13:09] <Juerd> "Just like XS" doesn't make people feel at ease, I guess ;)

[13:18] <rafl> Juerd: Some of the squeak features were neat, though.

[13:30] <Juerd> Certainly.

[13:31] <Juerd> But my opinion is that if you don't want to program for the web, you should just not program for the web. Don't make the web into something that it is not, because that will hurt extraordinarily when you try to support multiple user agents.

[13:43] <svnbot6> r8497 | audreyt++ | * Text.Parser.OpTable: Allow partial matches as well as whole matches.

[13:43] <svnbot6> r8497 | audreyt++ | * Text.Parser.Rule: ~80% of PGE's rule syntax parsed!

[13:46] <audreyt> bbiab...

[13:56] <gaal> very minor probably, but what's this doing?

[13:56] <gaal> # type Name = FastString

[13:56] <gaal> (Text.Parser.Rule)

[14:21] <scook0> gaal: makes Name an alias for the type FastString

[14:21] <scook0> (was that your question?)

[14:23] <gaal> scook0: it doesn't appear to be used anywhere :)_

[14:24] <scook0> gaal: it was used in a previous revision (which I had open when I answered)

[14:24] <gaal> audreyt: in YAML::Syck, does syck free bonus nodes automatically, or does Dump leak a struct emitter_xtra on every catch?

[14:25] <gaal> scook0: okay, I probably missed it (my vgrep is buggy)

[14:25] <gaal> s/catch/Dump()/

[14:26] <gaal> type :: Thought -> String   -- also buggy

[14:28] <gaal> also: what magic do you use that lets you not have inc/Module/Install in your YAML-Syck svn repo?

[14:29] <gaal> svn ignore lists? :)

[14:36] * gaal figures out the magic

[14:56] <stevan_> audreyt: ping

[14:59] <stevan_> hola nada mucho

[15:00] *** stevan_ is now known as stevan

[15:01] <nothingmuch> hola estevan

[15:34] *** integral_ is now known as integral

[15:34] <gaal> audreyt: ping

[16:06] <gaal> is anyone else getting compilation errors on Data.FastPackedString not finding fpstring.h ?

[16:07] <stevan> gaal: I had that issue once before,.. I dont recall the fix though

[16:07] <stevan> actually I think it had to do with the makefile, and getting something into my PATH correctly

[16:07] <stevan> this was for "make pili" though

[16:07] <gaal> yes, that time it was fixed

[16:07] <gaal> i remember

[16:08] <gaal> i think i know what's up now though.... let's see.

[16:08] <gaal> hmm no :(

[16:09] <gaal> urp, "make pili" doesn't respect config.yml's optimize setting.

[16:10] <stevan> that is because PIL is a rough and tumble mini-language,.. it has no respect for piddly little "data serialization languages" like YAML,.. in fact,.. it spits on YAML ! *spit*

[16:10] <gaal> probably not a problem though, it's so small

[16:10] <gaal> heh.

[16:15] <gaal> adding -Isrc/cbits manually fixed this, but I want to know if this is happenning only to me, and where's the right place to stick this in.

[16:19] <gaal> how do I avoid circular this dependency? Pugs.Prim.Yaml needs Data.Syck, but my Val -> Eval SyckNode which Data.Syck needs will live in P.P.Y.

[16:20] <gaal> s/(circular) (this)/$2 $1/

[17:02] <svnbot6> r8498 | audreyt++ | * Text.Parser.Rule: Support for proper rule construct precedence:

[17:02] <svnbot6> r8498 | audreyt++ |     (Alternation > Conjunction > Concat > Quantified > Term)

[17:02] <svnbot6> r8498 | audreyt++ | * Successful compilation for noncapturing parts of Rules.

[17:02] <svnbot6> r8498 | audreyt++ |   Capturing and binding will have to wait until tomorrow...

[17:02] <svnbot6> r8498 | audreyt++ | * Text.Parser.OpTable: Support for Infix AssocList.

[17:11] <tewk> cleq

[17:35] <tewk> u789ikl

[17:36] <tewk> u789ikl

[17:50] <tewk> 

[19:22] <gaal> ?eval for 1 .. 4 -> {say}

[19:22] *** evalbot_8476 is now known as evalbot_8498

[19:22] <evalbot_8498> OUTPUT[    ] undef 

[19:22] <gaal> ?eval my $x; for 1 .. 4 -> {$x ~= $_} $x

[19:22] <evalbot_8498> \"perl6perl6perl6perl6" 

[19:22] <Juerd> ?eval "perl6"x4  # ;)

[19:23] <evalbot_8498> Error:  unexpected "4" or "x" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[19:23] <Juerd> Awwh

[19:23] <gaal> ?eval my $x; for 1 .. 4 -> $i {$x ~= $i} $x

[19:23] <evalbot_8498> \"1234" 

[19:23] <gaal> FWIW: on the command line, "for 1 .. 4 -> {say}" does something very wrong

[19:24] <gaal> s/command line/REPL/

[19:24] <gaal> well. on the command line it doesn something else that's wrong.

[19:25] <Juerd> Which command line?

[19:26] <gaal> -e

[19:26] <gaal> ./pugs -e 'for 1 .. 4 -> {say}' => <SubPrim(&Num::ceiling)> four times

[19:26] <gaal> in the REPL, in contrast, $_ is leaking.

[19:27] <Juerd>  

[19:28] <gaal> ?

[19:29] <gaal> (was that a unicode zero-width-whitespace? :)

[19:44] <Juerd> gaal: Zero bytes even!

[19:49] <gaal> how do you send that in irc?

[19:50] <Juerd> Not at all :)

[19:50] <Juerd> I added a real ASCII space to overcome that limitation

[19:50] <Juerd> But it is surrounded by several zero byte zero width spaces.

[19:51] <Juerd> Count the bytes if you don't believe me :)

[20:48] <gaal> welcome, anatolyv!

[20:48] <anatolyv> thanks!

[20:49] <gaal> so, the invitation is on its way to you. let's start with the parser, it's a very simple change there.

[20:51] <gaal> in Pugs.Parser, find the function tightOperators

[20:51] * anatolyv nods

[20:51] <gaal> around line 1045

[20:52] <gaal> this feature needs no parser code, just letting the parser know this symbol is valid.

[20:52] <anatolyv> more like like 1384 here I think

[20:53] <gaal> so where you see preOps " = ! + - ** ~ ? +^ ~^ ?^ \\ "

[20:53] <gaal> stick a ^ as the last element of that list

[20:53] <anatolyv> done

[20:53] <gaal> I chose that line because that's where the operator comes in the precedence table in S02

[20:54] <gaal> right. now you have to write the code that's dispatched for this op. go to Pugs.Prim

[20:54] * anatolyv nods

[20:54] <gaal> this is where we keep the haskell builtins

[20:54] <gaal> the structure of this file is pretty simple: there are a few functions, op0, op1, .. op4

[20:55] <gaal> each one has zillions of guards, in each case with the string representing the op.

[20:55] <anatolyv> i guess op1 is what we need to modify?

[20:56] <gaal> yes; and also the very bottom of the file where there is a biiiig list of builtins

[20:56] <anatolyv> around like 217

[20:56] * anatolyv nods

[20:56] <gaal> anatolyv: 217 is exactly right

[20:56] <gaal> now the lucky thing is that ..^ is already defined

[20:57] <gaal> so we don't have to write any list code ourselves, just curry off whatever that does.

[20:57] <anatolyv>  \\n   List      non     ..^     safe   (Scalar, Scalar)

[20:57] <gaal> okay, yes, mimic that, but:

[20:58] <gaal> 1. change "non" to "spre", meaning this is a prefix op and the parser did some of the work for us

[20:58] <gaal> 2. change "(Scalar, Scalar)" to "(Scalar)"

[20:58] <gaal> note, btw, that when you do add ops with arity > 1, the space there is significant

[20:59] <gaal> ... unless somebody fixed that, which is not a bad idea :-)

[20:59] <anatolyv> right

[20:59] <gaal> so find op2 "..^"

[20:59] <anatolyv> op2 "..^" = op2RangeExclRight

[21:00] <gaal> op1 "^" is equivalent to 0 ..^ <something>

[21:00] * anatolyv ndos

[21:00] <gaal> so basically we just need to curry

[21:00] * anatolyv nods, even.

[21:00] <gaal> op1 "^"    = op2RangeExclRight 0 is *almost* correct

[21:01] <anatolyv> that's what I was thinking about

[21:01] <anatolyv> op1 "..^", you mean.

[21:01] <gaal> btw - we're again lucky that the arguments are in the right order, that is, the left operand is the one that's fixed at 0

[21:01] <gaal> no: we're defining op1 "^"

[21:02] <gaal> to be a curried version of op2RangeExclRight

[21:02] <anatolyv> oh, right.

[21:02] <gaal> "op2RangeExclRight 0" means sub { op2RangeExclRight(0, shift) }

[21:03] <gaal> (..whcih in perl 6 will be written simply "{ op2RangeExclRight(0, $^num) }"  :-)

[21:03] <anatolyv> OK :)

[21:04] <gaal> so, try compiling that; it won't work but the error message is good to know

[21:04] <anatolyv> going to try, yes. Just fixing a little mistake in the list down the bottom first, I messed that line up a bit.

[21:06] <anatolyv> src/Pugs/Prim.hs:217:28:No instance for (Num Val)arising from the literal `0' at src/Pugs/Prim.hs:217:2

[21:08] <gaal> right. so, what the error message obscurely means is that there's a type error with op2RangeExclRight

[21:08] <gaal> if you peek at 1215 you'll see

[21:08] <gaal> op2RangeExclRight :: Val -> Val -> Eval Val

[21:08] <gaal> this means op2RangeExclRight takes two Vals and returns a Val action

[21:08] <anatolyv> right

[21:09] <anatolyv> 0 is not a Val?

[21:09] <gaal> the important thing here is that Val is not a native haskell type, it's a pugs value

[21:09] <gaal> so we need to wrap up 0 to be a Val

[21:09] <gaal> in this case, it's very simple

[21:09] <gaal> replace "0" with "(VNum 0)"

[21:10] <gaal> while it compiles, I'll explain:

[21:10] <anatolyv> oh, that simple?

[21:10] <anatolyv> I'm trying to find where VNum is defined.

[21:10] <gaal> you know about data types, right?

[21:10] <anatolyv> yes.

[21:11] <gaal> Pugs.Types, line 137 has

[21:11] <gaal> type VNum  = Double

[21:11] <gaal> which means VNum is "really" a haskell double

[21:11] <gaal> but something else is going on

[21:12] <gaal> Pugs.AST.Internals, line 623

[21:12] <gaal> the "Val" datatype encapsulates values.

[21:12] <gaal> VNum is a data constructor there

[21:13] <anatolyv> I see (I think)

[21:13] <gaal> so when you say VNum 0, you get a Val (of the VNum variant).

[21:13] * anatolyv nods

[21:13] <gaal> the confusing bit is that the data constructors are almost all named for the type that they hold

[21:13] <anatolyv> it did compile this time, and I tested it. Sort of. :)

[21:14] <gaal> but these are different symbols

[21:14] <gaal> right, there's a bug in pugs in a nearby place:

[21:14] <gaal> don't do for ^4 { say }

[21:14] <gaal> do for ^4 -> $x { say }

[21:14] <gaal> errr

[21:14] <gaal> say $x

[21:15] <anatolyv> actually for ^4 { say $_; } seems to work fine

[21:15] <anatolyv> or for ^4 { say } for that matter

[21:16] <gaal> cool!

[21:16] <gaal> so now (or ideally, before we did this :-) we can write some tests

[21:16] <anatolyv> :)

[21:17] <gaal> uh, let's look in t/ ...

[21:17] <anatolyv> t/operators I would guess?

[21:17] <gaal> ah, yes

[21:17] <gaal> t/operators/range.t

[21:17] <anatolyv> range.t, yes

[21:17] <anatolyv> did a grep on ..^ :)

[21:17] <gaal> :)

[21:18] <gaal> \.\.\^, annoyingly :)

[21:18] <anatolyv> exactly

[21:18] <gaal> ?eval [~] ("\\" xx Inf) Y "..^".split("")

[21:19] <evalbot_8498> pugs: out of memory (requested 1048576 bytes) 

[21:19] <gaal> tsk, tsk, no laziness.

[21:19] <gaal> that will one day work though.

[21:19] <gaal> anymoose.

[21:19] <anatolyv> heh

[21:19] <anatolyv> hmm. let me try to figure out the test part.

[21:19] <anatolyv> tell me how to run it to check though.

[21:20] <gaal> ah that's the fun part

[21:20] <gaal> setenv PERL6LIB blib6/lib ; setenv HARNESS_PERL ./pugs

[21:20] <gaal> prove t/operators/range.t

[21:21] <gaal> well that isn't the fun part. the fun part is, you write the test before you get the feature to work, and mark the test :todo

[21:21] <anatolyv> well. setenv only for those of us using disrep*cough* shells :)

[21:21] <gaal> at first, it doesn't compile

[21:21] <gaal> yeah yeah

[21:21] <gaal> then it doesn't pass

[21:21] <gaal> then you see the sweet sweet words, "5 tests UNEXPECTEDLY SUCCEEDED"

[21:22] <anatolyv> how do I mark the test :todo? can you point me towards an example?

[21:22] <gaal> there are two ways. one is in a test call:

[21:23] <gaal> is "42", "43", "space shifted", :todo<feature>

[21:23] <gaal> the other way is to predeclare at the top of the test script all tests you want to "force_todo"

[21:24] <gaal> force_todo 5, 6;

[21:24] <anatolyv> hmm, ok

[21:24] <gaal> force_todo is mostly just useful when preparing for a release

[21:24] <anatolyv> however, I'm getting: Internal error while running expression: *** unexpected "r"

[21:25] <anatolyv> before even changing anything in range.t

[21:25] <gaal> hmm!

[21:25] <anatolyv> at <interactive> line 1, column 19

[21:26] <gaal> interactive? what's your command line?

[21:26] <anatolyv> I just set variables, ran ./pugs, and types prove t/operators/range.t in it

[21:27] <anatolyv> prove t/operators/quoting.t

[21:27] <anatolyv> err

[21:27] <anatolyv> getting the same mistake on any prove, always in line 1, column 19. seems my pugs is broke in some way.

[21:27] <gaal> ah, no

[21:27] <anatolyv> ah

[21:28] <anatolyv> quotes!

[21:28] <gaal> run prove from the command line

[21:28] <gaal> not via pugs

[21:28] <anatolyv> oh

[21:28] <gaal> prove is a p5 tool, but it can use other "perls" than its own

[21:28] <gaal> actually it can run anything that emits TAP, so if you want to do TDD in java...

[21:29] <anatolyv> a, d'oh

[21:29] <anatolyv> I misread your line because I'm so unused to the setenv's

[21:29] <gaal> :)

[21:29] <gaal> export ANATOLY=MOOSE

[21:29] <anatolyv> t/operators/range....ok 20/20# Looks like you failed 1 tests of 20 t/operators/range....FAILED test 8

[21:30] <gaal> prove -v it

[21:30] <gaal> that shows which tests failed

[21:30] <gaal> ah

[21:30] <gaal> it did say test 8

[21:30] <gaal> yes, that fails for me too.

[21:30] <anatolyv> it fails on carried chars, yes

[21:30] <anatolyv> ok, so now I add one of my own?

[21:31] <gaal> just put som "is" lines at the bottom

[21:31] <gaal> when you're done, update the plan

[21:32] <gaal> in our Test.pm, there's no such thing as no_plan

[21:32] <gaal> so you must say plan 22 or something like that.

[21:32] <anatolyv> where?

[21:32] <gaal> okay, I can confirm that this subtest has failed on an older pugs too, so it's not a bug we injected.

[21:33] <gaal> plan? near the top of the file

[21:33] <gaal> before the first test

[21:33] <gaal> i happened to have a pugs for doing that, but you can also go to http://smoke.pugscode.org/ to make sure

[21:34] <gaal> I showed you how those are linked to the tests themselves, right?

[21:34] <anatolyv> ok, I don't understand. 22 will be the total number of tests after I add mine?

[21:34] <gaal> assuming you add two, yes :-)

[21:35] <gaal> the purpose of "plan" is just to let the harness know if a test script had crashed before the last test ran

[21:35] * anatolyv nods

[21:35] <gaal> otherwise it might think that since (say) 4 tests passed, the complete file passed.

[21:36] <gaal> add as many tests as you like

[21:37] <gaal> I suppose testing against a negative number (or zero) should be useful -- they should produce a null range

[21:37] <gaal> although from our implementation it should obviously work

[21:37] <anatolyv> hmm, I can't really see the point of adding more than one here. unless... something like ^0 should produce a null range I guess.

[21:37] <anatolyv> heh

[21:38] <gaal> but once the test is written, it can service different implementations: either

[21:38] <gaal> 1. pugs, if somebody refactors

[21:38] <gaal> 2. a different compiler altogether that wants to borrow our test suite

[21:38] <anatolyv> right

[21:39] <gaal> so of course nobody overdoes the tests, but sometimes one extra "has *got* to pass!" can turn useful.

[21:41] <anatolyv> I've added 3

[21:41] <gaal> out Test.pm is richer than p5 Test::Simple (or Test::More), though very much similar to them

[21:41] <anatolyv> ^5 should be 0..4, ^1 should be (0) as the boundary condition, and ^0 should be ()

[21:42] <gaal> if you know Test::Exception, we have lives_ok and dies_ok too

[21:42] <anatolyv> hmm, I vaguely remember it. OK.

[21:42] <gaal> we don't have Test::Deep, but we often use is $x.perl, $y.perl to approximate that 

[21:42] <anatolyv> ok 21 - unary ^num produces the range 0..^num

[21:42] <anatolyv> ok 22 - unary ^ on the boundary ^1 works

[21:42] <anatolyv> ok 23 - unary ^0 produces null range

[21:42] <anatolyv> these messages look ok to you?

[21:43] <gaal> looking good! let's commit :)

[21:43] <anatolyv> alright :)

[21:43] <gaal> btw don't forget to validate your invitation

[21:43] <anatolyv> doing that right now

[21:45] <anatolyv> done

[21:45] <gaal> svnbot6: ?check

[21:46] <gaal> it's feeling kinda sleepy

[21:46] <gaal> did you commit?

[21:47] <anatolyv> not yet

[21:47] <gaal> ah :)

[21:47] <anatolyv> you'll have to walk me through that, svn still feels new

[21:47] <gaal> svn ci

[21:47] <anatolyv> in the top level dir?

[21:47] <gaal> yes

[21:48] <anatolyv> then I write a commit message? before --This line, and those below, will be ignored--

[21:48] <gaal> yup, and :wq

[21:48] <gaal> something like

[21:48] <gaal> * added unary ^ (0..^num shortcut) operator

[21:48] <anatolyv> how will it know who I am? don't I have to config svn first?

[21:49] <gaal> nope, it's magic :)

[21:49] <gaal> it'll ask you on your first checkin.

[21:49] <anatolyv> hmm, alright :)

[21:49] <gaal> and store the auth data in the repo. no more CVS recheckouts just because you'd used anonymous :)

[21:50] <gaal> s/repo/working copy/

[21:50] <anatolyv> hmm

[21:50] <anatolyv> doesn't seem to be authenticating me

[21:51] <gaal> what are you getting?

[21:51] <anatolyv> well, it asked me the password for my local login first :) after that failed, it re-asked username, password, and failed the check, now it's tried again, thought a long time, and wrote:

[21:51] <anatolyv> svn: MKACTIVITY of '/pugs/!svn/act/0e9ab592-0209-0410-9497-ebf9d9afe9e1': authorization failed (http://svn.openfoundry.org)

[21:52] <gaal> when it asked for a username, did you give it the pugs username?

[21:52] <anatolyv> the one I registered on rt.openfoundry.org just a minute ago.

[21:52] <gaal> hmm, that should have worked

[21:53] <anatolyv> magic never works reliably :)

[21:53] <anatolyv> I'll try to re-login there to check my password

[21:54] <gaal> try to ci again, maybe it's just some slowness in openfoundry.

[21:54] <anatolyv> openfoundry does seem sluggish. it won't log me in: Unverified account. Please verify your account first. - though I verified it twice by now, successfully.

[21:55] <anatolyv> I hope it's not using memcached!

[21:55] * anatolyv shudders.

[21:55] <gaal> lol

[21:55] <gaal> actually it's an excellent candidate for that!

[21:55] <gaal> it's (a) slow and (b) perl

[21:55] <anatolyv> right

[21:56] <gaal> all those SVN::Web views can certainly be cached

[21:57] <gaal> btw, I recently noticed that very new versions of GLib have a new slab allocator

[21:57] <anatolyv> nope, still can't log in. I guess it's best to wait until morning, then mail the admin if it still doesn't work.

[21:57] <anatolyv> and svn ci still doesn't work.

[21:58] <gaal> some of the admins are on this channel :) and luckily they're in GMT+7 and should be awake in a few hours

[21:58] <anatolyv> I won't be :)

[21:59] <gaal> too bad, because you won't be able to see this work:

[21:59] <gaal> ?eval for ^4 -> $i { say $i }

[21:59] <evalbot_8498> Error:  unexpected "f" expecting program not a class name or reserved word 

[21:59] <gaal> ?eval for 0..^4 -> $i { say $i }

[21:59] <evalbot_8498> OUTPUT[0 1 2 3 ] undef 

[21:59] <gaal> you know our evalbot?

[22:00] <anatolyv> I guess I do now :)

[22:00] <gaal> ?eval moose => 42

[22:00] <evalbot_8498> ("moose" => 42) 

[22:02] <gaal> well, I hope you had fun apart from this last hiccup. Welcome aboard! :)

[22:02] <anatolyv> thank you :)

[22:06] <nnunley> gaal: what does the ^ do in the range?

[22:06] <gaal> nnunley: it defaults to starting from 0, and having the range not include the operand

[22:06] <gaal> a..^b === a..(b-1)

[22:06] <nnunley> Cool.

[22:06] <nnunley> [a..b)

[22:06] <gaal> ^b == 0..^b

[22:06] <gaal> right.

[22:07] <gaal> but ranges are integral :)

[22:07] <nnunley> True.

[22:07] <nnunley> Would be messy if they were real.

[22:07] <anatolyv> not necessarily

[22:07] <anatolyv> hmm

[22:07] <nnunley> You'd have to give an epsilon.

[22:08] <gaal> could be stipulated by lexical pragma.

[22:08] <anatolyv> ah, right, ranges are integral but ~~ can match them as if they were real

[22:10] <gaal> you mean 0..1 ~~ 0.5 => true?

[22:11] <anatolyv> it seems it should be

[22:11] <anatolyv> according to S3

[22:12] <gaal> right, cool.

[22:12] <anatolyv> but actually I'm failing to grok it

[22:12] <anatolyv> 1^..^2 is an empty range

[22:13] <anatolyv> quoting S3: "Ranges are not autoreversing: 2..1 is always a null range, as is 1^..^2."

[22:13] <anatolyv> "However, smart matching against a Range object smartmatches the endpoints in the domain of the object being matched,"

[22:13] <gaal> right (some people think that's a mistake btw)

[22:13] <anatolyv> "so 1.5 ~~ 1^..^2 is true."

[22:13] <anatolyv> so think about it for a second, what this implies

[22:14] <anatolyv> 1^..^2 is a null range in integers, but not null in reals: in reals it's (1..2)

[22:14] <anatolyv> but until we do the matching, we just have a Range object

[22:14] <anatolyv> this implies that we can't store e.g. 3^..^8 as a Range 4..7

[22:15] <gaal> point.

[22:15] <anatolyv> not sure how pugs does it, but Range has to be smarter than that

[22:15] <anatolyv> and allow exclusion of an endpoint as a primitive notion inside it.

[22:16] <anatolyv> ?eval 1.5 ~~ 1^..^2

[22:16] <evalbot_8498> bool::false 

[22:16] <anatolyv> :)

[22:16] <gaal> I don't think it deals with it at all yet: Ranges are nowhere serialized, and smartmatchin against them probably dosen't work yet.

[22:16] <anatolyv> ?eval 1.5 ~~ 1..2

[22:16] <evalbot_8498> bool::false 

[22:16] <anatolyv> ah, well, it doesn't match at all

[22:16] <anatolyv> right

[22:16] <gaal> ?eval 3 ~~ 0 .. 10

[22:16] <evalbot_8498> bool::false 

[22:16] <anatolyv> what do you mean by nowhere serialized?

[22:16] <anatolyv> heh, it doesn't even match integers.

[22:16] <gaal> there is no "Range" type at all in pugs.

[22:17] <anatolyv> what's 1..4?

[22:17] <anatolyv> a list

[22:17] <anatolyv> I see :)

[22:17] <gaal> not quite... 1 .. 4 evaluates to a list

[22:17] <anatolyv> pugs> :d 1..4  App &infix:.. (: 1, 4)

[22:18] <anatolyv> ah, that's the syntax tree, sorry

[22:18] <anatolyv> VList [VInt 1,VInt 2,VInt 3,VInt 4]

[22:19] <gaal> that's the evaluation, yes.

[22:19] <anatolyv> are there built-in object types in pugs, in general, just not Range? Things like Int Str etc.? Or those are missing too?

[22:21] <gaal> I think order in that department is for the next milestone

[22:21] <anatolyv> ok

[22:22] <gaal> AFAIK, it's still an open question what this means: my Int $x = "not an int"

[22:22] <gaal> (coersion or error)

[22:22] <anatolyv> hmm

[22:22] <gaal> likewise sub foo (Int $x) etc.

[22:23] <anatolyv> ?eval (1..4).say

[22:23] <evalbot_8498> OUTPUT[1234 ] bool::true 

[22:23] <gaal> yes, that's a pretty major issue to still be open :)

[22:23] <anatolyv> ?eval 1..4.say

[22:23] <evalbot_8498> OUTPUT[4 ] (1,) 

[22:24] <gaal> ?eval 1 .. (4.say)

[22:24] <evalbot_8498> OUTPUT[4 ] (1,) 

[22:24] <anatolyv> what happens when i run (1..5).say, how does (1..5), a VList, automagically turns into an object which has a method say?

[22:26] <gaal> I'm not familiar enough with the details, but there's no special treatment for say here; the magic is in the dot.

[22:26] <avar> gaal: you can have my Int $x = undef though

[22:26] <avar> last I checked

[22:27] <gaal> avar: that will almost certainly be allowed even if "my Int $x = 'eep'" is not

[22:28] <gaal> I do wonder how Perl is going to express not-nullable types though.

[22:28] <gaal> ...did I see Int! somewhere?

[22:34] <avar> hah

[22:34] <avar> my !Int $x = "everything but Int";

[22:35] <gaal> ?eval my !Int $x = "everything but Int";

[22:35] <evalbot_8498> Error:  unexpected "!" expecting qualified identifier, variable name or "(" 

[22:35] <gaal> yeah, this isn't specced yet I think.

[22:35] <avar> I know, but it would be pretty insane if it were;)

[22:35] * gaal just parsed that the way avar meant. ha!

[22:36] <gaal> yeah, it would most certainly be insane :-)

[22:36] <avar> I wonder if it would be useful somehow...

[22:37] <avar> like, if you promised to not make something an array or a hash if the compiler could make some worthy optimizations of that...

[22:37] <gaal> doubtful. just limit it to one type

[22:37] <avar> my !Array or !Hash $x = "foo";

[22:37] <avar> yeah, I know, like I said, insane;)

[22:37] <gaal> that's Any :)

[22:37] <gaal> you mean !Array and !Hash

[22:38] <avar> ah, that;)

[22:38] <gaal> okay, I think it's time for me to sleep too :)

[22:38] <gaal> see you later :)

[22:38] <avar> cya

[22:38] <gaal> good night &

[23:56] <tewk> ll

