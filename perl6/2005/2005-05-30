[00:19] <jql> umm

[00:20] <jql> Foo.bar() would be a submethod, and Foo::bar() would be a sub. I think. Where's my synopsis?

[00:21] * jql is smoking something, clearly

[00:35] <theorbtwo> Darren_Duncan: That should be Foo::bar(), not Foo.bar().

[00:35] <Darren_Duncan> I see ...

[00:36] <theorbtwo> &Foo::bar is the &bar in Foo (and the & is optional when calling a sub).

[00:36] <theorbtwo> Foo.bar() means bar, called on Foo.

[00:36] <Darren_Duncan> will test now ...

[00:37] <Darren_Duncan> on a separate matter, it seems like .meta and etc aren't implemented, or I'm not calling them right ...

[00:37] <theorbtwo> I think  they aren't yet implemented.

[00:38] <autrijus> sri_: how exactly do you want me to improve the p5 glue? :)

[00:38] <autrijus> right, .meta is not yet there.

[00:41] <Darren_Duncan> okay, so I'll need .meta, .isa, and .can plus a can_ok() in Test.pm to get LKT working

[00:41] <svnbot6> r4133, autrijus++ | * Correct address of p6tu talk as wagner is now kaputt.

[00:41] <svnbot6> r4134, autrijus++ | * First sketch of my HW2005 talk -- due in next week --

[00:41] <svnbot6> r4134, autrijus++ |   feel free to hack my broken English. :-)

[00:41] <autrijus> whew. finally got at least some words of docs/talks/hw2005.txt written

[00:41] * autrijus has procrastinated this for ~2 months

[00:41] <theorbtwo> autrijus, what is your schedule like?

[00:42] <autrijus> theorbtwo: next week to Vienna for APW; then YAPC::NA; then back to Taipei

[00:42] <autrijus> afterwards in Sep., hopefully haskell workshop, then amsterdam for Euroscon

[00:42] <theorbtwo> I've been half-pondering a lot about getting back into the swing of pugs devel... and about making Code objects readable, and possibly even modifiable.

[00:43] <autrijus> that would be excellent.

[00:43] <theorbtwo> And am wondering if you can try walking me through some stuff.

[00:43] <theorbtwo> I meant schedule for the next few hours, not the next few weeks.

[00:43] <autrijus> ah.

[00:44] <autrijus> I need to catch up $work, but that means 60% of my brain gets to idle

[00:44] <theorbtwo> Nod.

[00:44] <autrijus> so you're free to ask questions and I'll answer them, not neccessarily in realtime

[00:44] <autrijus> but probably with a 5min turnaround at most

[00:44] <autrijus> is that okay?

[00:45] <theorbtwo> Sounds good to me.

[00:46] <Darren_Duncan> So far in testing, I haven't found any combination of Foo::bar() that works ...

[00:46] <autrijus> cool :)

[00:47] <Darren_Duncan> by itself or with leading ampersand, it says :  No compatible subroutine found: "&t_LKT_Util::message"

[00:47] <autrijus> Darren_Duncan: that is right. let me fix it now

[00:47] <Darren_Duncan> with leading '::' it says : pugs: cannot cast from VType (mkType "t_LKT_Util::message") to Pugs.AST.Internals.VCode

[00:48] <Darren_Duncan> autrijus, do you confirm that Foo::bar() is for modules and Foo.bar() is for class methods?

[00:50] <theorbtwo> So how do I make a method on the builtin types?  As a prim, or is there a better way?

[00:50] <autrijus> Darren_Duncan: that sounds about right.

[00:50] <Darren_Duncan> good

[00:50] <autrijus> Darren_Duncan: class methods can also be invoked like Foo.Foo::bar()

[00:50] <autrijus> or

[00:50] <autrijus> Foo::bar(Foo)

[00:51] <autrijus> just like in p5

[00:51] <autrijus> theorbtwo: currently there's only Prim to use. you can, however, fully qualify that prim name.

[00:51] <Darren_Duncan> sure ... though I never used those syntacies before

[00:51] <autrijus> eg. Code::blah

[00:51] <autrijus> then only &code.blah will invoke it

[00:51] <autrijus> not @array.blah

[00:51] <theorbtwo> Shall I make a new Prims/Code.hs?

[00:52] <autrijus> sure, why not.

[00:53] <Darren_Duncan> any particular goal for when 6.2.6 is going out?

[00:54] <theorbtwo> Is there a purticular set of emacs settings published somewhere for how pugsly haskell code should look?

[00:56] <Darren_Duncan> fyi, I noticed that my intended use of the '//' operator in Locale-KeyedText now compiles, where it didn't the other week, so that's good

[00:57] <autrijus> Darren_Duncan: next 24 hours

[00:57] <Darren_Duncan> pretty quick then

[00:57] <autrijus> ok, I think "is export" and qualified subroutines and other lovely things are implemented

[00:58] <autrijus> now let's see if it actually works...

[00:58] <autrijus> hm. it may or may not. I'll commit and you'll test. ok? :)

[00:59] <autrijus> theorbtwo: uh, no, but I used to use

[00:59] <autrijus> # c-indentation-style: bsd

[00:59] <autrijus> # c-basic-offset: 4

[00:59] <autrijus> # indent-tabs-mode: nil

[01:00] <theorbtwo> Are the cases of the op1 supposed to be in any purticular order?

[01:00] <autrijus> theorbtwo: no.

[01:00] <autrijus> theorbtwo: that is a big case-of statement.

[01:00] <Darren_Duncan> question: can I assume that perl 6 rules will never function except when Parrot is used with Pugs?

[01:00] <autrijus> Darren_Duncan: r4135 -- please test and let me know whether/if it is broken

[01:00] <autrijus> Darren_Duncan: yes, that is a good assumption.

[01:01] <Darren_Duncan> right then

[01:01] <autrijus> "never" is a bit strong though.

[01:01] <autrijus> it is conceivable that japhy will produce something that is independent of parrot.

[01:01] <autrijus> so you can use it with perl5 embedding -- and port it to p6

[01:01] <autrijus> so it can be used stand-alone

[01:01] <autrijus> but for now (and near future), we need parrot for rules

[01:02] * theorbtwo crosses his fingers after implementing his first method and typing make.

[01:02] <Darren_Duncan> given the simplicity of my module, a good half of the test suite just checks that it dis-allows bad input, and many of those use regexps, meaning that my module's test suite will never fully pass except when compiled with Parrot

[01:02] * autrijus notes that "make ghci" and ":r" makes a faster turnaround

[01:02] <autrijus> Darren_Duncan: you can use rx:P5//

[01:02] <svnbot6> r4135, autrijus++ | * At Darren's request, implemented qualified subroutine names;

[01:02] <svnbot6> r4135, autrijus++ |   as a result, `is export` must be used to expose a subroutine

[01:02] <svnbot6> r4135, autrijus++ |   outside its module.

[01:02] <autrijus> as many people now do

[01:02] <autrijus> which is always available

[01:02] <autrijus> if you want, you can add the equivalent p6rules as comments

[01:02] <Darren_Duncan> and rx:P5 does not require Perl 5 right?

[01:02] <autrijus> nope. we embed pcre

[01:02] <Darren_Duncan> will do

[01:03] <autrijus> you++

[01:03] <theorbtwo> (Also, p5 regexes are somewhat nicer when you are matching fairly simple things, I think.)

[01:03] <Darren_Duncan> thats my standard practice ... if a workaround exists, I use that and place what I really wanted to do in comments

[01:03] <autrijus> please do test that Foo::bar works

[01:03] <autrijus> yup. I found it to be very helpful

[01:03] <Darren_Duncan> commencing svn up now

[01:03] * theorbtwo yawns.

[01:04] <theorbtwo> It compiles so much slower when I actually expect it to do something different...

[01:04] <Darren_Duncan> commencing 'make'

[01:05] <autrijus> theorbtwo: ghci and :r, really :)

[01:05] <autrijus> <- can't use "make" for real development

[01:05] <autrijus> sometimes "make unoptimised"

[01:06] <theorbtwo> I keep having to delete things when I make ghci, which is ofputting.

[01:06] <Darren_Duncan> how does Pugs runtime speed compare between the two

[01:06] <theorbtwo> Looks like that's been fixed, though.

[01:06] <Darren_Duncan> I never did the unoptimized before now, though I also didn't hack the core and didn't recompile much anyway

[01:07] <autrijus> Darren_Duncan: if you are not hacking AST or Parser, and those two have beeing compiled with "make" before, then "make unoptimised" will produce quite fast code

[01:07] <autrijus> in any case though, unless you're running the entire test suite, "make unoptimised" will save time.

[01:08] <Darren_Duncan> anyway, its 'Compiling Pugs.Parser'

[01:08] <Darren_Duncan> now on Eval

[01:09] <Darren_Duncan> done make

[01:09] <autrijus> cool.

[01:11] <Darren_Duncan> unless I skipped a vital step, its now worse than before

[01:11] <Darren_Duncan> *** No compatible subroutine found: "&import"

[01:11] <Darren_Duncan> at t/lkt_10_msgprops.t line 1, column 1

[01:12] <Darren_Duncan> checking ...

[01:14] <autrijus> Darren_Duncan: ahh. fixing

[01:14] <Darren_Duncan> gotcha

[01:14] <Darren_Duncan> and I'll do unoptimized next time

[01:15] <Darren_Duncan> just to clarify, I never use 'is export' etc in my own modules

[01:16] <autrijus> 'kay.

[01:17] <autrijus> unbroken.

[01:17] <autrijus> r4136

[01:23] <svnbot6> r4136, autrijus++ | * unbreak `import`. Darren++

[01:29] <theorbtwo> God I hate my ISP sometimes.

[01:40] <Darren_Duncan> will svn up now

[01:41] <Darren_Duncan> now make un

[01:51] <theorbtwo> Hmmpf, I've got a type error that I can't figure how to resolve.

[01:52] <theorbtwo> code <- fromVal codeval

[01:52] <theorbtwo>     Ambiguous type variable `n' in the constraints:

[01:52] <theorbtwo>       `CodeClass n' arising from use of `code_assoc' at src/Pugs/Prim/Code.hs:13:20-29

[01:52] <theorbtwo>       `Value n' arising from use of `fromVal' at src/Pugs/Prim/Code.hs:12:12-18

[01:52] <theorbtwo>     Probable fix: add a type signature that fixes these type variable(s)

[01:53] <kelan> no evalbot?

[01:53] <theorbtwo> ?eval +pi

[01:53] <theorbtwo> Guess not.

[01:54] <Darren_Duncan> what a trade off ... testing my code was slow before, and its even slower now

[01:54] <autrijus> maybe I should launch evalbot from feather

[01:54] <Darren_Duncan> in any event, the added problem is gone

[01:54] <autrijus> theorbtwo: do that

[01:54] <autrijus> code <- formVal codeval :: Eval VCode

[01:54] <Darren_Duncan> and Foo::bar() seems to work now

[01:54] <Darren_Duncan> but have to leave comp for a bit, will confirm later

[01:54] <autrijus> Darren_Duncan: thanks!

[01:58] <theorbtwo> autrijus: Thanks.

[01:58] <autrijus> np :)

[01:58] <meppl> gute nacht

[01:58] <autrijus> 'nite meppl 

[01:59] <meppl> ;)

[02:01] <theorbtwo> Hm, I want \\n  Str   pre   Code::assoc   safe   (Code:)\, right?

[02:01] <theorbtwo> I'm getting "no compatable subroutine found" on say &say.assoc

[02:04] <autrijus> theorbtwo: hm. but if you mark it as simply "assoc" does it work?

[02:07] <autrijus> hm. that "is export" change seemed to break Set.pm

[02:07] <autrijus> needs to investigate a bit

[02:10] <theorbtwo> That works, autrijus.

[02:10] <svnbot6> r4137, autrijus++ | * report the erorr stack trace in the correct order.

[02:11] <theorbtwo> However, that way assoc("foo!") gives a cannot cast error.

[02:12] <autrijus> sure.

[02:12] <autrijus> check in the Code::assoc part doso I can fix?

[02:15] <theorbtwo> autrijus: Any way to tell openfoundry to mail me bug reports in english?

[02:15] <autrijus> theorbtwo: in your user preference set it to English. but that may not be there yet -- I'll look into it

[02:16] <autrijus> are there people submitting bug reports using openfoundry?

[02:16] <svnbot6> r4138, theorbtwo++ | say &say.assoc

[02:16] <autrijus> (the "test" thing was a mistake by me. sorry)

[02:16] <theorbtwo> Oh, no problem.

[02:23] *** joepurl_ is now known as joepurl

[02:24] <mugwump> hi there everyone!  What's on the plate for this week's release?

[02:24] <theorbtwo> Hi, mugwump!

[02:25] <theorbtwo> 02:57 < autrijus> Darren_Duncan: next 24 hours

[02:25] <theorbtwo> Grr.

[02:25] <theorbtwo> Sorry.

[02:25] <mugwump> Hmm, wonder if there's a log anywhere..

[02:26] <mugwump> what day/timezone was that from, theorbtwo ?

[02:27] <theorbtwo> CEST -- that was an hour and a half ago.

[02:27] * mugwump finds http://xrl.us/f9h9

[02:27] <theorbtwo> http://pugscode.org, click on logs.

[02:27] <theorbtwo> (Amongst other logs.)

[02:27] <autrijus> hey mugwump. I broke Set.pm  by introducing qualified names and `is export`

[02:27] <autrijus> will investigate in a bit

[02:32] * mugwump coos and looks

[02:35] <autrijus> ahh.

[02:35] <autrijus> method infix:<-> (Set $one, Set $two) returns Set {

[02:35] <autrijus> this is borken

[02:35] <mugwump> should be multi?

[02:36] <autrijus> either multisub or s/,/:/

[02:36] <mugwump> right

[02:36] <autrijus> as it stands it means something that is invoked by Set and takes another 2 Sets

[02:36] <mugwump> yet somehow indicated by a binary infix op

[02:36] <autrijus> strange no?

[02:36] <mugwump> set - (set, set) ?  :)

[02:38] <Darren_Duncan> I'm back ... was at dinner

[02:39] <theorbtwo> autrijus: Figure out what was wrong with my prim?

[02:45] <autrijus> theorbtwo: checking

[02:45] <svnbot6> r4139, autrijus++ | * .keys and .values for uninitialised scalars should be ().

[02:45] <svnbot6> r4140, autrijus++ | * err, juxtaposed commit log. _this_ change was the .keys/.values

[02:45] <svnbot6> r4140, autrijus++ |   fix -- last change was temporarily disabling infix:<-> in Set.pm

[02:45] <svnbot6> r4140, autrijus++ |   during the investigation, and fixing the overloading from method

[02:45] <svnbot6> r4140, autrijus++ |   into multi subs.

[02:49] <Darren_Duncan> it seems a lot of my .meta use can be replaced with .ref, which I think works (and is more like the perl 5 version), so that much closer to working

[02:52] <autrijus> nice

[02:53] <autrijus> theorbtwo: I see.

[02:53] <autrijus> &say is a Sub

[02:53] <autrijus> but ::Sub metaobject did not register that it has superclass of Code.

[02:53] <autrijus> so saying Code::assoc will break.

[02:53] <Darren_Duncan> or actually, plain .isa() rather than .meta.isa() is functional, so used that instead

[02:53] <autrijus> the proper fix here is to instantiate all the default classes with metaobjects.

[02:53] <theorbtwo> Hm?  But &say ~~ Code gives 1.

[02:53] <autrijus> .does() too

[02:53] <autrijus> theorbtwo: because isa check is different from metaobject walking

[02:54] <autrijus> isa check just uses the clsTree

[02:54] <autrijus> but metaobject looks at the actualy runtime thing

[02:54] <Darren_Duncan> I just want to know if a given object is part of a certain class, either built-in or my own

[02:54] <autrijus> Darren_Duncan: right... .does() is probably what you want

[02:54] <Darren_Duncan> s/part/a member/

[02:55] <theorbtwo> Darren_Duncan: You probably want .does.

[02:55] <Darren_Duncan> how is .does() different from .isa() for what I want?

[02:55] <theorbtwo> Does asks if it is compatable with foo; isa asks if it is implemented in terms of foo.

[02:55] <autrijus> theorbtwo: I don't have time to implement the proper fix myself right now -- it will be making a set of VObject as part of initSym based on the init tree

[02:55] <mugwump> what is this "is" business, anyway?  :)

[02:55] <autrijus> theorbtwo: for now for you to test, say Sub::assoc instead and see if works.

[02:55] <autrijus> double thanks if you can write a test for this :)

[02:56] <autrijus> I need to run to pay my income tax...

[02:56] <Darren_Duncan> so does() takes a class name as its argument?

[02:56] <autrijus> bbiab.

[02:56] <autrijus> Darren_Duncan: yeah

[02:56] <autrijus> Darren_Duncan: or role name.

[02:56] <autrijus> &

[02:56] <theorbtwo> Woo, sounds like tons of fun, autrijus.

[02:56] <Darren_Duncan> separate question ... what can I use in place of Perl 5's can()

[02:56] <Darren_Duncan> as in, does it declare this sub or method?

[02:56] <autrijus> Darren_Duncan: .can() of course. it's unimplemented. :)

[02:56] <Darren_Duncan> right, so no change there

[02:57] <Darren_Duncan> will try .does() meanwhile ...

[02:57] <autrijus> nod. the current sub lookup in Eval wants to be refactored there.

[02:57] <jql> hard to implement because of multimethods?

[02:57] <autrijus> really &

[03:00] <Darren_Duncan> question: is does() working right now in plain Pugs, or does it require the metamodel module?

[03:00] <Darren_Duncan> wait ...

[03:01] <theorbtwo> Darren_Duncan: There is no metamodel module, just docs for it, I think.

[03:02] <Darren_Duncan> pardon me, I was previously just searching in /ext for uses and found none, but now I found some in t/, so I see its in use

[03:03] * theorbtwo yawns.

[03:03] <theorbtwo> Goodnight, all.

[03:04] <putter> good night.

[03:05] <putter> this can't be intended behavior... can it?

[03:05] <putter> pugs> sub f() { my $h; $h<a>=1; $h<b>=2; $h}

[03:05] <putter> undef

[03:05] <putter> pugs> ref(f())

[03:05] <putter> ::Hash

[03:05] <putter> pugs> [ f(), 'foo']

[03:05] <putter> ({ref:<Hash>}, 'foo')

[03:05] <putter> pugs> [ f() ]

[03:05] <putter> ({ref:<Pair>}, {ref:<Pair>})

[03:05] <putter> pugs> []

[03:05] <putter> ()

[03:06] <mugwump> pugs> f

[03:06] <mugwump> ({ref:<Pair>}, {ref:<Pair>})

[03:06] <mugwump> ?

[03:07] <mugwump> sub g() { my %h; %h<a>=1; %h<b>=2; %h}

[03:07] <mugwump> ({ref:<Pair>}, {ref:<Pair>})

[03:07] <mugwump> that I didn't expect

[03:07] <mugwump> sub g() { my %h; say "Hello!"; %h<a>=1; %h<b>=2; %h}

[03:08] <mugwump> ::Hash

[03:08] <jql> interesting

[03:08] <mugwump> o_รณ

[03:08] <putter> ;)

[03:09] <mugwump> heh, ok try this

[03:09] <mugwump> start pugs

[03:10] <mugwump> ref(undef) ~ ", yar?"

[03:10] <mugwump> sub f() { my $h; $h<a>=1; $h<b>=2; $h}

[03:10] <jql> umm

[03:11] <mugwump> so, sub f() { } does not change the 'return' value of the current point in code

[03:11] <mugwump> pugs is continuing to display the old result, because the result as would be returned by the end-of-block from the current block is still the same

[03:12] <jql> also, I'm surprised a named sub decl doesn't have a Code return-value

[03:12] <jql> my &foo := sub bar () {...}

[03:13] <mugwump> but it's compile time..

[03:13] <mugwump> whereas the other one is run-time

[03:14] <jql> s/:=/::=/ would work, then? :)

[03:14] <jql> since it would return a Code at compile-time, I presume foolishly

[03:14] * jql presumes many things foolishly

[03:15] <mugwump> afaik $foo ::= is like making $foo an alias for the thing you bind it to at that point below

[03:22] <mugwump> so perhaps, yes

[03:23] <jql> well, it's probably last week's javascripting which makes me think sub foo() {...} would be the same as my &foo ::= sub () {...}

[03:24] <mugwump> Yeah, Javascript's neat like that isn't it?  Supports a surprising number of dynamic features

[03:24] <jql> I've been consistently impressed not only with its fun capabilities, but the decent likelyhood that whatever I think should work actually does

[03:25] <jql> nicely DWIMmy

[03:25] <mugwump> well, let me assure you the novelty wears off once you try to run stuff in IE

[03:25] <jql> well, having closures leak memory is very familiar to me

[03:25] * jql points at Perl5

[03:26] <mugwump> hmm

[03:26] <jql> IE ain't so bad. I like raping my own system with javascript

[03:26] <jql> don't like other people doing it, though

[03:27] <jql> I played with Javascript on my active desktop

[03:27] <jql> I turned that shit off

[03:27] <jql> alert() on mousemove on your desktop is scary

[03:27] <mugwump> pugs> my $bar = "Hmm"

[03:27] <mugwump> 'Hmm'

[03:27] <mugwump> pugs> $bar = "baz";

[03:27] <mugwump> 'Hmm'

[03:28] <mugwump> dropping the semicolon makes it work

[03:28] <jql> that's it

[03:28] <jql> pugs> my $bar = "hmm";

[03:28] <jql> ({ref:<Pair>}, {ref:<Pair>})

[03:28] * jql chuckles

[03:29] <jql> it's the evil semicolon implying a void statement

[03:30] <jql> pugs needs to display the return-value of the last non-empty statement

[03:36] <putter> sigh.  ive been doing a p6 rules on pcre bootstrap.  tried to be paranoid and use a very concervative subset of p6 to avoid problems.  (bootstraps being inherently confusing by themselves;)  it soooo hasnt turned out that way... :-(

[03:37] <mugwump> you're writing a perl6 rules engine?

[03:37] <putter> ah well.  sleep.  'night folks.

[03:37] <putter> oh, yes. well, sort of...

[03:38] <mugwump> well, may your dreams be full of inspirations to help you on that and other goals

[03:39] <mugwump> egads!  ghc has its own GNU ld incompatible ELF loader?!

[03:40] <putter> fake p6 rules parsetree -> backend using pcre rx plus capture repacker -> run on p6 rules description of p6 rules -> real parsetree.

[03:40] <putter> last version actually worked.  but I thought half an hour was a bit too slow. ;)

[03:41] <Khisanth> mugwump: hey! I guess that might explain the problem I was having :)

[03:43] <putter> the only thing compatible with gnu's ld is gnu's ld... it's embedded (read hairly entangled) w libc.  not a pretty picture.  my fuzzy impression is they are _finally_, after lo these many years, thinking of extracting it.  sigh.

[03:44] <putter> 'night.

[03:46] <mugwump> pasteling?

[03:46] <Khisanth> sial.org/pbot

[03:47] <mugwump> :)

[03:47] <Khisanth> did perlbot get itself k-lined again?

[03:47] <Khisanth> jabbot: seen perlbot

[03:47] <jabbot> Khisanth: perlbot was seen 2 days 3 hours 20 minutes 19 seconds ago

[03:47] <Khisanth> bah!

[03:57] <autrijus> rehi!

[03:57] <mugwump> hi autrijus ... I'm having problems getting a perl5/perl6/parrot chimaera going :)

[03:58] <mugwump> s/perl6/pugs/ of course

[03:59] <mugwump> when I go `make unoptimized', I get http://nopaste.snit.ch:8002/2753

[04:06] <autrijus> mugwump: try "make clean" first.

[04:06] <autrijus> currently toggling between p5embed will not cause the relevant .o files to rebuild

[04:06] <autrijus> so you end up with missing symbols.

[04:07] <autrijus> not sure how to fix that

[04:07] <autrijus> at least rm src/Pugs/*/Perl5*o

[04:07] <autrijus> and src/*/*/*stub*

[04:07] <autrijus> and maybe src/perl5/*o

[04:08] <mugwump> ah, that looks better.  I was in the process of being highly impressed that Haskell just needed to relink for that

[04:08] <autrijus> sometimes the impossible really is impossible :)

[04:09] <mugwump> such as interpreting GNU ld scripts without being GNU ld

[04:10] <mugwump> (ie, non-ELF entities such as libpthread.so that actually contain plain text loader directives)

[04:10] * autrijus shrugs... never really used GNU ld

[04:10] <mugwump> :P

[04:13] <Darren_Duncan> question, inside my own new() method, is this the right way to do things ? ...

[04:13] <svnbot6> r4141, chromatic++ | Don't add skip to TODO test status report.

[04:13] <svnbot6> r4141, chromatic++ | UnTODO some passing tests.

[04:13] <Darren_Duncan> method new( $class: Str $msg_key, Str ?%msg_vars ) returns Locale::KeyedText::Message {

[04:13] <Darren_Duncan> my $message = $class.SUPER::new( { msg_key => $msg_key, msg_vars => {%msg_vars} } );

[04:14] <Darren_Duncan> return $message;

[04:14] <Darren_Duncan> the second line doesn't seem to be returning what I expect

[04:14] <Darren_Duncan> also, if I say() $class, I get <obj:Class>

[04:14] <Darren_Duncan> if I say() $message, I get nothing

[04:17] <sri_> thats not good? "pugs: cannot cast from VRule (MkRulePCRE {rxRegex = Regex 0x01505c20, rxGlobal = False, rxStringify = False}) to [Char]"

[04:17] <mugwump> can't print a rule...

[04:19] <sri_> guess it's related to my P5 regexes

[04:19] <svnbot6> r4142, chromatic++ | Test that SUPER doesn't call the same method again.  (Currently failing)

[04:19] <Darren_Duncan> ah, that should fix it

[04:19] <Darren_Duncan> I just determined that an infinite recursion was happening

[04:20] <Darren_Duncan> the null $message was due to the method explicitly failing from bad input

[04:20] <Darren_Duncan> my new

[04:20] <Darren_Duncan> afaik, the built-in new() takes the hash ref that I mentioned

[04:21] <Darren_Duncan> will sevenup and try again

[04:23] <Darren_Duncan> that didn't fix it

[04:23] <Darren_Duncan> still infinite recursion by SUPER

[04:24] <Darren_Duncan> seen chromatic

[04:24] <jabbot> Darren_Duncan: chromatic was seen 2 days 2 hours 47 minutes 44 seconds ago

[04:25] <Darren_Duncan> another bug I noticed

[04:26] <Darren_Duncan> it seems that a hash argument passed an undefined value will spit out > 0 values when .keys() is called on it

[04:26] <sri_> yay, got HTTP::Server::Simple ported =)

[04:26] <Darren_Duncan> whereas, an empty/undef hash should always have zero keys

[04:27] <mugwump> sri++!

[04:27] <Darren_Duncan> eg, this will loop at least once: for %msg_vars.keys -> $var_name {

[04:27] <Darren_Duncan> ... when %msg_vars is undefined

[04:27] <obra> sri++

[04:27] <obra> Now I don't have to

[04:28] <sri_> you can still clean it up ;)

[04:28] * obra nods

[04:28] <sri_> next on the list is File::Find *shudder*

[04:28] <obra> Working on Cat6?

[04:28] <sri_> need that for Module::Pluggable

[04:29] <sri_> mhm

[04:39] <sri_> opendir/readdir is not yet implemented?

[04:42] <sri_> hmm...same for glob

[04:47] <sri_> i'll add a todo

[04:48] <mugwump> a :todo<feature> test?  :)

[04:48] <sri_> mhm

[04:48] <autrijus> theorbtwo: fixed the initialise bug.

[04:48] <autrijus> all builtin types now have their corresponded metaobjects.

[04:48] <autrijus> corresponding, even.

[04:49] <Darren_Duncan> I have checked in the LKT work I did today so everyone can be up to date with it

[04:49] <autrijus> Darren_Duncan: &new gets named args

[04:49] <Darren_Duncan> still several issues remaining

[04:49] <autrijus> not a hashref

[04:49] <autrijus> i.e. a hash, not a hashref

[04:49] <Darren_Duncan> is that what caused the infinite recursion?

[04:49] <autrijus> hadn't checked yet

[04:50] <Darren_Duncan> my code was acting like "SUPER::new()" did the same thing as "new()" -- the inf recursion

[04:51] <Darren_Duncan> that SUPER thing is the biggest thing blocking me at the moment

[04:51] <svnbot6> r4143, Darren_Duncan++ | updated ext/Locale-KeyedText files towards full executability (not there yet); using p5 regexes instead of p6 ones so Parrot not required; replaced use of as() since not implemented; replaced class.bless() with class.SUPER::new(); invoke all module subs using Mod::sub() rather than Mod.sub(); a few other misc fixes; replaced commented-out can_ok() with executing skip()

[04:51] <svnbot6> r4144, autrijus++ | * initialise metaobjects for the default class tree; this makes

[04:51] <svnbot6> r4144, autrijus++ |   `&say.assoc` correctly dispatch to `Code::assoc` through its

[04:51] <svnbot6> r4144, autrijus++ |   type `Sub`, a subtype of `Code`.

[04:51] <autrijus> hm. I fixed SUPER for objects

[04:51] <autrijus> but it's possible that class methods hadn't got fixed. I'll check now

[04:51] <IshaCocoa> HI. Once GHC 6.4 finishes downloading and is installed, and I've pulled the latest pugs with svn, do I need anythiing else before building using VC/nmake?

[04:52] <autrijus> IshaCocoa: you need Perl.

[04:52] <Darren_Duncan> I commented out the line in my LKT so someone running the tests will get an ordinary failure rather than inf recursion

[04:52] <IshaCocoa> Got 5.6.4 ok?

[04:52] <autrijus> possible.

[04:52] <autrijus> I think most developers are using 5.8.1+

[04:52] <IshaCocoa> S/6/8/ :)

[04:52] <Darren_Duncan> didn't know there was a 5.6.4

[04:52] <autrijus> heh.

[04:52] <autrijus> sure then

[04:53] <autrijus> if you plan to play with p6rules, also download http://www.jwcs.net/~jonathan/perl6/parrot-win32.zip and put the path to parrot.exe somewhere in your $ENV{'PATH'}

[04:53] <autrijus> otherwise don't worry.

[04:53] <IshaCocoa> Later. I'll get through to the pugs> prompt first.

[04:53] <autrijus> does Win32 have glob(3)?

[04:54] <Darren_Duncan> I'm using 5.8.1+, and my newer modules refuse to run with less too

[04:54] <IshaCocoa> Not native without mingw or cigwin--a native equvalent of course

[04:55] <autrijus> oh well.

[04:55] <autrijus> no easy glob("") support then, sri_ 

[04:55] <sri_> :(

[04:55] <autrijus> unless you can settle it working for POSIX first

[04:55] <autrijus> and Corion et all can add win32 later

[04:55] <autrijus> s/settle/settle for/

[04:55] <sri_> opendir/readdir is enough for now

[04:56] <sri_> s/is/would be/

[04:56] <IshaCocoa> There are various flavours of glob support by perl5. Any way to use those?

[04:57] <autrijus> IshaCocoa: sure. needs time :)

[04:58] <autrijus> Darren_Duncan: confirmed. fixing

[04:58] <Darren_Duncan> thanx

[04:59] <IshaCocoa> Understood. I just saw you had link P5 module support in and there are FIle::GLob and File::DosGLob modules...

[04:59] <Khisanth> glob uses File::Glob anyway :)

[05:01] <IshaCocoa> Egads 42 MB takes a long time at 4.1 k/s :(

[05:13] <autrijus> Darren_Duncan: fixed.

[05:13] <svnbot6> r4145, sri++ | Added test for opendir/readdir

[05:13] <svnbot6> r4146, autrijus++ | * ensure that ./SUPER::method never gets circular; Reported by Darren.

[05:16] <autrijus> IshaCocoa: right. but depending on p5 for globbing sounds... weird

[05:16] <autrijus> it is certainly one of the ways though.

[05:16] * autrijus still remembers DosGlob.exe

[05:17] * mugwump finally places an order for TaPL

[05:17] <autrijus> mugwump++

[05:17] <mugwump> I want to work through the examples in Perl 6 and put them in examples/  :)

[05:19] <Darren_Duncan> now sevenupping to check fix

[05:19] <autrijus> a lofty goal, mugwump

[05:19] <autrijus> sri_: you're on *nix right?

[05:20] <sri_> osx

[05:20] <Darren_Duncan> btw, did you see my other comment about an undefined hash returning an item from keys() ... should return nothing

[05:20] <mugwump> well, I'll give it a crack, anyway.  Or maybe _some_ crack.

[05:20] <sri_> so it's arguable ;)

[05:21] <Darren_Duncan> that is "for %foo.keys -> $bar" should never execute if the hash is empty, but the loop does at least once

[05:21] <autrijus> yay!

[05:21] <autrijus> op2 "split" = op2Split

[05:21] <autrijus> op2 "Scalar::split" = flip op2Split

[05:22] <autrijus> Darren_Duncan++ # prompting a good fix

[05:22] <autrijus> pugs> 1.split(4)

[05:22] <autrijus> ('1')

[05:22] <autrijus> pugs> split(1,4)

[05:22] <autrijus> ('4')

[05:22] <autrijus> all our invocant-based flippable subroutines should be rewritten this way

[05:22] <autrijus> including join, etc

[05:24] <Darren_Duncan> now on 'make'

[05:24] <Darren_Duncan> back shortly

[05:24] <svnbot6> r4147, autrijus++ | * &name and &arity are now `Code::` specific.

[05:24] <svnbot6> r4147, autrijus++ | * `$scalar.split($str)` is now treated correctly as

[05:24] <svnbot6> r4147, autrijus++ |   `split($str, $scalar)` by putting &Scalar::split as a 

[05:24] <svnbot6> r4147, autrijus++ |   different OP as &split.

[05:25] <autrijus> Darren_Duncan: 

[05:25] <autrijus> my %x; for %x.keys -> { die }

[05:25] <autrijus> this doesn't die for me

[05:25] <Darren_Duncan> my problem may be outdated ... will test again

[05:29] <Darren_Duncan> I can still recreate it, but I'm about 4-5 commits out of date, will try again once your new commits have finished compiling

[05:39] <Darren_Duncan> okay, there is a problem, but its different than what I said

[05:39] <svnbot6> r4148, SamB++ | Some changes in Pugs.Compile.Pugs, which I'm about ready to give up on

[05:39] <svnbot6> r4148, SamB++ | for being such a mess. dons++ in #haskell tells me that it is best to

[05:39] <svnbot6> r4148, SamB++ | use two steps for that kind of thing.

[05:39] <svnbot6> r4149, SamB++ | Yet another attempt at a Perl->Haskell compiler. Based on talking with

[05:39] <svnbot6> r4149, SamB++ | dons++ in #haskell about pretty printing.

[05:40] <Darren_Duncan> basically, a method's hash optional argument is somehow defaulting to containing one key when the method is invoked without passing anything to that argument

[05:40] <Darren_Duncan> or rather, this is happening ...

[05:40] <autrijus> give me a oneliner that exhibits the bug?

[05:41] <Darren_Duncan> newest Pugs has same behaviour ... attempting to simplify proble

[05:43] <autrijus> cool. thx

[05:45] <IshaCocoa> autrijus: I was thinking only of a stopgap measure until a native version can be written/derived.

[05:46] <IshaCocoa> autrijus: (Re: glob/).

[05:47] <Darren_Duncan> about to pastebot

[05:48] <pasteling> "Darren_Duncan" at 24.108.164.7 pasted "run this self-contained code thru pugs ... it prints 'two' but shouldn't" (26 lines, 737B) at http://sial.org/pbot/10576

[05:49] <Darren_Duncan> autrijus, that small sample exhibits the problem

[05:50] <IshaCocoa> Argh! 46.1 MB download of ghc 6.4.bld2 msi (5+ hrs) and "This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installler package." -- Anyone else got bld2 successfully?

[05:51] <Darren_Duncan> simpler example coming ...

[05:51] <autrijus> bld2?

[05:52] <autrijus> hrmph.

[05:52] <autrijus> IshaCocoa: it claims that it's 47mb

[05:52] <pasteling> "Darren_Duncan" at 24.108.164.7 pasted "much simpler code with same problem" (17 lines, 357B) at http://sial.org/pbot/10577

[05:53] <Darren_Duncan> this new version has one class and one method

[05:53] <Darren_Duncan> wasn't sure if indirect call caused problem, but problem persists with direct call, illustrated in second sample

[05:53] <Darren_Duncan> be back shortly

[05:53] <autrijus> how do I invoke new?

[05:53] <autrijus> just .new() ?

[05:54] <Darren_Duncan> the pasted sample includes the invocation

[05:54] <Darren_Duncan> the last line, saying my $msg1 = ...

[05:54] <Darren_Duncan> is the invoker

[05:54] <Darren_Duncan> paste all text in one file and run it

[05:55] <autrijus> k.

[05:55] <autrijus> I see "two"

[05:55] <Darren_Duncan> but logically you shouldn't, should you?

[05:55] <autrijus> sure. there's no logic

[05:55] <autrijus> fixing

[05:55] <Darren_Duncan> back shortly

[05:57] <autrijus> ->?%x{say %x.perl}.()

[05:57] <autrijus> is the minimal borking case

[05:59] <autrijus> paramDefault is the culprit.

[06:00] <IshaCocoa> According to wget:Length: 48,247,296 [application/x-msi] which translates to 46.0122 MB which I suppose is close to "~47 MB"...but it is a download error. My file is a few K short of the proper size. Hopefully wget -c will finish it properly

[06:01] <autrijus> paramDefault was at Undef

[06:01] <autrijus> it should clearly be Noop.

[06:03] <autrijus> thanks, fixed as r4150

[06:03] <svnbot6> r4150, autrijus++ | * Optional array and hash arguments were defaulting the a single-element

[06:03] <svnbot6> r4150, autrijus++ |   "undef" instead of the empty "Noop".  A minimal regression test:

[06:03] <svnbot6> r4150, autrijus++ |     ->?%x{say %x.perl}.()   # should be "{}"

[06:03] <svnbot6> r4150, autrijus++ |   Reported by Darren.

[06:07] <Darren_Duncan> I was going to say that this problem could be indicitive of something larger, and all sub-type things should be tested, subs, methods, class methods, plus arrays and hashes ... but it looks like you already thought of it

[06:08] <autrijus> :)

[06:08] <autrijus> anyway it should be fixed now.

[06:09] <autrijus> now trying to get opendir() written for sri_ 

[06:09] <Darren_Duncan> now making new version

[06:09] <autrijus> I get to play with the opaque object type. fun

[06:09] <Darren_Duncan> I actually still have to test that SUPER was fixed ... will do shortly

[06:19] <nothingmuch_> morning

[06:19] <Darren_Duncan> make complete ... now testing again

[06:19] <Darren_Duncan> oh, and morning to you, 11:19pm to me

[06:27] <Darren_Duncan> yep, SUPER doesn't recurse anymore

[06:27] <svnbot6> r4151, autrijus++ | * Code::* moved to Prim/Code.hs.

[06:27] <svnbot6> r4151, autrijus++ | * "say" and "print" gets invocantised with IO::* forms.

[06:28] <Darren_Duncan> however, it also made me realize that SUPER::new isn't actually what I need

[06:28] <Darren_Duncan> what I wanted to do is invoke the default constructor for my class, which I overrode with my own 'method new' declaration

[06:29] <autrijus> oh.

[06:29] <autrijus> then you want submethod BUILD.

[06:29] <autrijus> grep ext/ for samples

[06:29] <Darren_Duncan> okay

[06:33] <Darren_Duncan> part of what threw me off was the Test::Builder module

[06:34] <Darren_Duncan> the Test::Builder class does not declare that it inherits from any class

[06:34] <Darren_Duncan> yet its new() method invokes Class.SUPER::new()

[06:34] <Darren_Duncan> ... with its own arguments

[06:35] <Darren_Duncan> anyway ...

[06:37] <autrijus> $class.SUPER::new

[06:37] <autrijus> you mean

[06:37] <Darren_Duncan> yes

[06:37] <autrijus> it's a variable

[06:37] <Darren_Duncan> when I did that, it didn't work

[06:38] <autrijus> hrm.

[06:38] <Darren_Duncan> mind you, I said :   method new( $class:  ...

[06:38] <Darren_Duncan> while the other module specified a class name to the left of $class ...

[06:39] <Darren_Duncan> I say return $class.SUPER::new( msg_key => $msg_key, msg_vars => %msg_vars );

[06:39] <Darren_Duncan> will try something ... colons in front of key names

[06:40] <Darren_Duncan> I get this as output either way: *** No compatible subroutine found: "&SUPER::new"

[06:41] <autrijus> nod. maybe it's broken for T::B as well :-/

[06:41] <autrijus> sorry, I'm still in opendir

[06:41] <Darren_Duncan> I thought the default constructor expected its args in named format, with the keys matching the property names

[06:41] <autrijus> that is true

[06:41] <Darren_Duncan> no prob, finish what you started

[06:43] <Darren_Duncan> meanwhile, I will try using the default constructor for now, to get around this issue and see if anything else needs fixing in the module

[06:46] <autrijus> k.

[06:47] <autrijus> thanks for bearing with this infant puppy :)

[06:47] <luqui> hello

[06:47] <autrijus> hey luqui.

[06:47] <autrijus> we've just been OOizing all our Prims

[06:47] <luqui> what's new in the pugs world

[06:47] <luqui> yum

[06:47] <autrijus> Code::arity, IO::Dir::readdir, IO::say, etc.

[06:47] <autrijus> now that the default metaobjects and finalisers are in place

[06:48] * luqui has to look at that

[06:48] <luqui> but first

[06:48] * luqui has to install svk

[06:48] <autrijus> :D

[06:49] <luqui> do I have to copy over the whole repository when I svkize?

[06:49] <luqui> 4000 revisions is pretty hefty

[06:49] <autrijus> luqui: you can tell it to just sync the head.

[06:49] <autrijus> but then you lose all history

[06:50] <autrijus> so, depending on how fast your bandwidth

[06:50] <autrijus> SamB: hey, can you cleanup Pugs2 with the proper #ifdef over the next 24 hours or so?

[06:51] <autrijus> oh nvm you're not using TH.

[06:51] <autrijus> but still lots of warnings

[06:51] <chromatic> I'm mistrusting subName sub == qualified for some reason.

[06:51] <autrijus> chromatic: it is a good reason. it doesn't catch indirect circularity.

[06:51] <autrijus> but then, indirect circularity should be caught in another level.

[06:51] <autrijus> i.e. at inheritance level

[06:51] <chromatic> Ah, so it's good that I don't know where or how to fix it.

[06:51] <autrijus> that check is merely to prevent findSub' from finding the package-level scopes.

[06:52] <autrijus> i.e.

[06:52] <autrijus> if you're in package Foo

[06:52] <autrijus> resolving &foo will still yield Foo::foo

[06:52] <Darren_Duncan> some progress here ...

[06:52] <autrijus> so we explicitly forbid that.

[06:52] <Darren_Duncan> when I comment out my custom new() and replace invocations with calls to the built-in, the tests suddenly get a lot further along

[06:52] <autrijus> (we fallback to normal MMD &foo if a method can't be found in class hierarchy)

[06:53] <autrijus> (as specced in S12)

[06:53] <autrijus> Darren_Duncan: cool

[06:53] <luqui> what do we lose by making SMD and MMD run in the same engine

[06:53] <Darren_Duncan> the trade-off is that a lot of tests fail where undef is expected rather than an object

[06:53] <Darren_Duncan> but those don' t kill the script at least

[06:54] <luqui> or by checking those variants with fewer invocants first (maybe not a good idea)

[06:55] <Aankhen``> Our sanity?

[06:56] <Aankhen``> (and that's dispensable anyway ;-)

[06:57] <Aankhen``> Er, sorry, I just realised I hadn't scrolled all the way down after all.

[06:57] <autrijus> "you have nothing to lose except your sanity"

[06:58] <Aankhen``> Whoops... I think I left marks of debugging in ext/libwww-perl/t/base/headers-util.t

[06:59] <Darren_Duncan> found another bug

[06:59] <Darren_Duncan> try running this: my %foo = ('a'=>'b'); say %foo.pairs.sort.map:{ .key~'='~.value }.join( ', ' );

[07:00] <Darren_Duncan> it says : cannot cast from VStr "a" to (Pugs.AST.Internals.Val,Pugs.AST.Internals.Val)

[07:00] <Aankhen``> Does @*INC only need to contain "ext/name-of-module/lib" for the tests to work under `make smoke`?

[07:01] <chromatic> Does it also need the path to Test.pm?

[07:02] <Aankhen``> Darren_Duncan >> Pairs don't seem to be supporting .key and .value properly.

[07:02] <Aankhen``> pugs> ("a" => "b", "foo" => "bar").pairs.sort.map:{ .key ~ " = " ~ .value }

[07:02] <Aankhen``> ('0 = a b', '1 = foo bar')

[07:03] <Darren_Duncan> this also fails: my %foo = ('a'=>'b'); say %foo.pairs.map:{ .key~'='~.value };

[07:03] <Darren_Duncan> a shorter sample

[07:04] <luqui> How about:  $a = ('a' => 'b');  say $a.key;

[07:04] <Darren_Duncan> this does produce output : my %foo = ('a'=>'b'); say %foo.join();

[07:04] <Darren_Duncan> but it isn't formatted

[07:05] <Darren_Duncan> curiously, the Pugs command line always prints out the string 'undef' on a separate line following the normal input, no matter what I ask it to do

[07:05] <Aankhen``> luqui >> Actually, that works.

[07:05] <luqui> it looks like it's map that is broken

[07:05] <Aankhen``> Darren_Duncan >> Same here. :-)

[07:05] <luqui> wrt pairs

[07:05] <Aankhen``> Yeh.

[07:05] <Aankhen``> Hrm...

[07:06] <luqui> yeah, it's just getting a list

[07:06] <luqui> %foo.pairs.map:{say}

[07:06] <luqui> rather, say $_

[07:06] <Aankhen``> Er... how do you give a pointy block to map?

[07:07] <luqui> map -> { } %foo.pairs ?

[07:07] <jql> foo.map(->{})

[07:07] <Aankhen``> OK.

[07:07] <luqui> oh yeah, that works too

[07:07] <jql> timtowdi

[07:07] <jql> s/di/tdi/

[07:07] <luqui> map seems to be flattening the pairs

[07:08] <luqui> you can do your thing this way:

[07:08] <Darren_Duncan> whooo ... midnight here now

[07:08] <luqui> map -> $a, $b { say "$a => $b" } %foo.pairs

[07:08] <jql> midnight here too. go figure

[07:08] * jql pokes the clock

[07:08] <jql> you want %foo.kv, right?

[07:08] <Darren_Duncan> yes

[07:08] <luqui> yeah, but unfortunately, .pairs works too

[07:08] <Darren_Duncan> I'm serializing a hash for easy examination

[07:08] <luqui> it just shouldn't

[07:08] <jql> pairs shouldn't really work.

[07:09] <Darren_Duncan> here's the full line in my code, fyi

[07:09] <Aankhen``> Anyone here who understands what `make smoke` is and whether anything special needs to be done for it?

[07:09] <Darren_Duncan> return $message.:msg_key~': '~$message.:msg_vars.pairs.sort.map:{ .key~'='~(.value // '') }.join( ', ' );

[07:10] <jql> holy hell

[07:10] <Darren_Duncan> that's what I'm actually printing out

[07:10] <Darren_Duncan> a scalar followed by key=value pairs, with the value set to '' if undef (avoids warnings), sorted to give consistent string on all platforms

[07:11] <jql> p6 gives new depth to the one-liner

[07:11] <Aankhen``> Darren_Duncan >> What are you working on?

[07:11] <Darren_Duncan> result is used in my test suite

[07:11] <Darren_Duncan> this is from Locale::KeyedText

[07:11] <Aankhen``> Ah.

[07:11] <Darren_Duncan> here is the perl 5 version, fyi ...

[07:12] <Darren_Duncan> return $msg_key.': '.join( ', ', map { $_.'='.(defined($msg_vars->{$_}) ? $msg_vars->{$_} : '') } sort keys %{$msg_vars} );

[07:12] <svnbot6> r4152, Aankhen++ | * replaced ugly BEGIN { ... } block with pretty `use lib <...>` in ext/libwww-perl/t/base/headers-util.t

[07:12] <luqui> hmm, the p6 one-liner might end up being clearer using some pipes

[07:12] <Darren_Duncan> I think the perl 6 version is much prettier ... I love that Pairs object

[07:13] <luqui> and maybe separating out your prefix from your pipeline

[07:13] <jql> I wish postfic-statement given worked

[07:13] <jql> that'd be sick

[07:14] <jql> and obfuscated beyond reason

[07:14] <jql> but still sick

[07:14] <Darren_Duncan> I don't consider my code obfuscated

[07:15] <Darren_Duncan> I try to make it readable on purpose

[07:15] * jql puts 'say given 1' on his Acme::Given module wishlist

[07:15] <luqui> because say 1 isn't good enough

[07:15] <autrijus> sri_: *dir landed.

[07:15] <jql> well, it's meant for say .foo ~ .bar ~ .baz given $foo

[07:15] <autrijus> Win32 people, please confirm that r4153 still builds.

[07:15] <sri_> yay! :)

[07:15] <jql> of course, it's deeply evil to do that

[07:16] <luqui> yeah.  that's not so far-fetched.

[07:16] <Aankhen``> Dang.

[07:16] <sri_> autrijus++

[07:16] <autrijus> sri++

[07:16] <Aankhen``> I'm building... r4151.

[07:16] <autrijus> Aankhen``: maybe break it :)

[07:16] * Aankhen`` cancels and restarts.

[07:16] <Aankhen``> Yea.

[07:16] <autrijus> (also "make unoptimised" is your friend)

[07:16] <sri_> wait, now i have to touch File::Find :/

[07:16] <Aankhen``> I build once a day, so I just let it build the optimised version.

[07:16] <autrijus> sri_: port F::F!

[07:17] <autrijus> or F::F::Rules

[07:17] <autrijus> a File::Find based on coroutines will be...

[07:17] <svnbot6> r4153, autrijus++ | * opendir/readdir/rewinddir/closedir on *nix.

[07:17] <autrijus> ...not neccessarily a good idea. never mind

[07:17] <autrijus> now fixing pairs

[07:17] <chromatic> Pairs or SUPER?

[07:17] * Aankhen`` can't wait for his P4 630 and 1 GB of dual channel DDR 400 RAM.

[07:17] <autrijus> what's wrong with SUPER?

[07:18] <chromatic> t/oo/super.t

[07:18] <Aankhen``> That ought to speed up the build process some. :-D

[07:18] <autrijus> $class.SUPER::new is borken again?

[07:18] <chromatic> Yep, can't find &SUPER::new.

[07:18] <autrijus> k.

[07:18] <Aankhen``> Are you going to ask me to build r4154 now?

[07:18] <Darren_Duncan> autrijus fixed something with SUPER after you filed that test, but it was for infinite recursion

[07:18] <Aankhen``> Guess not. :-D

[07:18] <autrijus> nope :)

[07:19] <autrijus>  eval "{1 => 2}.pairs.map:{say 3}"

[07:19] <autrijus> this only say "3" once

[07:19] <autrijus> I think it's correct, no?

[07:19] <chromatic> Well it did fix the infinite recursion, but it fixed it by never calling it.  :)

[07:19] <autrijus> yeah. not neccessarily the best fix :)

[07:19] <jql> correct to me

[07:19] <chromatic> It makes one test fail a lot more quickly though, which is nice to diagnose.

[07:19] <jql> IANA@L

[07:20] <Aankhen``> autrijus >> Win32:

[07:20] <Aankhen``> Compiling Pugs.Compat      ( src/Pugs/Compat.hs, src/Pugs/Compat.o )

[07:20] <Aankhen``> src/Pugs/Compat.hs:151:25: Not in scope: type constructor or class `Typeable'

[07:20] <Darren_Duncan> map should run once per pair, so one total is correct here

[07:20] <autrijus> Aankhen``: uh oh

[07:20] <Aankhen``> :-(

[07:20] <luqui> hmm... method foo ($.bar) { }  is unsupported

[07:20] <autrijus> Aankhen``: attempted a fix

[07:20] <Aankhen``> Committed?

[07:21] <autrijus> r4154

[07:21] <autrijus> yeah

[07:21] <Aankhen``> OK, Pugs.Compat seems to have compiled alright.

[07:21] <Darren_Duncan> autrijus, the problem was a thrown exception about type coersion, trying to use .value in a string context

[07:22] <autrijus> oh. ok

[07:22] <svnbot6> r4154, autrijus++ | * unbreak win32

[07:22] <autrijus> minimal test case again?

[07:22] <Darren_Duncan> look up the log, but will post again

[07:23] <Darren_Duncan> try this: my %foo = ('a'=>'b'); say %foo.pairs.map:{ .key~'='~.value };

[07:23] <Darren_Duncan> says cannot cast from VStr "a" to (Pugs.AST.Internals.Val,Pugs.AST.Internals.Val)

[07:23] <luqui> with the same %foo, just do %foo.pairs.map:{say "hi"}

[07:24] <chromatic> Bad implicit topic?

[07:24] <Darren_Duncan> no error with your example

[07:24] <Darren_Duncan> but I think the problem is with the .key/.value not coercing to a string for the stitching properly

[07:24] <luqui> chromatic, no, it's flattening the pairs

[07:25] <luqui> the map will be called twice, once with "a", another time with "b"

[07:25] <chromatic> Into tuples?

[07:25] <luqui> it's like .pairs is acting just like .kv in this context

[07:25] <Darren_Duncan> oh right, its doing that too

[07:25] <luqui> that's the source of your problem

[07:26] <Darren_Duncan> each $_ in the map block should be a Pair object

[07:28] <Darren_Duncan> I'm going to bed soon ... will test any fixes tomorrow unless available soon

[07:29] <Darren_Duncan> 12:30 here

[07:29] <autrijus> chromatic: so it turns out to be simple

[07:29] <autrijus> chromatic: user-defined classes was not inheriting anything.

[07:30] <autrijus> so SUPER:: tree is empty

[07:30] <autrijus> ;)

[07:30] <autrijus> fixed r4155

[07:30] <autrijus> (adding a mandatory "Object" inheritance)

[07:30] <chromatic> Ah, excellent.

[07:30] <chromatic> That should fix all but two outstanding bugs and unimplemented features in T::B.

[07:30] <autrijus> roles and ?

[07:30] *** castaway_ is now known as castaway

[07:31] <scook0> what function do you use to write an eval test that should fail?

[07:31] <chromatic> Optional named non-attribute variables in method signatures.

[07:31] <autrijus> method foo (+$blah) {}

[07:31] <autrijus> like that?

[07:31] <Aankhen``> scook0 >> fails_ok { eval(...); } perhaps?

[07:31] <Aankhen``> Or maybe that was `dies_ok`.

[07:31] <Aankhen``> Yeah, I think that's the one.

[07:32] <scook0> Aankhen``: I shall try both, thanks

[07:32] <chromatic> Yeah, there's a test for that too.

[07:32] <Aankhen``> NP, hope it works. :-)

[07:32] <autrijus> chromatic: cool. but can't you make it optional positional as well?

[07:32] <autrijus> (not saying that's the correct design)

[07:32] <chromatic> It's the only argument to the method.

[07:32] <autrijus> method foo (?$blah)

[07:33] <Aankhen``> Then shouldn't it be optional positional, chromatic?

[07:33] <chromatic> Let me find the test and you can see what I mean.

[07:34] <chromatic> t/oo/submethods.t

[07:34] <svnbot6> r4155, autrijus++ | * all user-defined classes now inherit from "Object".

[07:34] <svnbot6> r4155, autrijus++ | * hence, fixed the problem of cannot find ./SUPER::new.

[07:34] <chromatic> The two tests at the end.

[07:35] * castaway wonders why "Object" and not "Class"

[07:35] <autrijus> castaway: class Foo is Object {}

[07:35] <lightstep> they are a Class, but their superclass is Object, since their instances are Objects, not Classes

[07:36] <jql> ugh

[07:36] <autrijus> class Foo is Class {}

[07:36] <castaway> sounds illogical somehow

[07:36] <jql> ugh x2

[07:36] <lightstep> autrijus, why would you want that?

[07:36] <autrijus> chromatic: I see what you mean.

[07:36] <jql> neither of those is what I'd want to see

[07:36] <castaway> SUPER::new is calling the new from the inherited class, not an inherited object, no?

[07:36] <autrijus> lightstep: class Foo { method new { ./SUPER::new() } } 

[07:36] <autrijus> that needs to work.

[07:37] <autrijus> so there must be a SUPER somewhere.

[07:37] <autrijus> that SUPER is Object

[07:37] <lightstep> in Smalltalk, the metaclasses are anonymous. are they so in perl6 too?

[07:37] <autrijus> calling the .new invokes Object.new

[07:37] <castaway> I'm guessing Object is like UNIVERSAL? 

[07:37] <autrijus> a class method invocation

[07:37] <autrijus> castaway: yeah.

[07:38] <castaway> classes inherit, not objects

[07:38] <castaway> whatever

[07:38] <integral> why isn't Object called UNIVERSAL?

[07:39] * castaway wonders if jql is going to make a statement or just go "ugh" ,)

[07:39] <castaway> cos its p6? ,)

[07:39] <jql> Classes are objects, though. If something "is" a class, you're extending the class-object

[07:39] <luqui> lwall: "I suspect we would make a lot of people happy if we named UNIVERSAL Object"

[07:39] <autrijus> heh. amazingly

[07:39] <autrijus> my %foo = (a=>1,b=>2); say join ',',  %foo.pairs.map(&perl)

[07:39] <autrijus> iterates twice

[07:39] <castaway> these lot of people are java programmers? :)

[07:39] <lightstep> jql, no, you create a new class-object

[07:39] <autrijus> my %foo = (a=>1); say join ',',  %foo.pairs.map(&perl)

[07:39] <autrijus> also iterate twice!

[07:39] <autrijus> ah. it's falling into this

[07:39] <autrijus> "a single pair is like a one-element list"

[07:40] <autrijus> definition

[07:40] <luqui> well, one of the goals of Perl 6 was to make it look like Java to managers and Perl to programmers

[07:40] <autrijus> so, say, is a single pair like a one-element list? ;)

[07:40] <jql> allow me to re-ugh. :)

[07:40] <autrijus> (a=>1)[1] # 1

[07:40] <autrijus> because if that is that

[07:40] <autrijus> then the .map behaviour falls out from that.

[07:40] <autrijus> er

[07:40] <autrijus> two-element list.

[07:40] <castaway> class-object wont fit in my brain ,)

[07:40] <luqui> right

[07:40] <autrijus> is a single pair like a two-element list?

[07:41] <jql> a single pair -> a one-element hash -> a single-element list containing a pair

[07:41] * jql chuckles diabolically

[07:41] <autrijus> jql: I'm leaning toward that.

[07:41] <jql> (1 => 2)[0] == (1 => 2)

[07:41] <castaway> managers actually look at code? Hmm

[07:41] <luqui> right

[07:41] <luqui> pairs don't flatten

[07:41] <autrijus> ok.

[07:41] <autrijus> but

[07:41] <autrijus> (1=>2){1}

[07:41] <autrijus> is 2.

[07:42] <autrijus> makes some kind of sense?

[07:42] <Darren_Duncan> a single pair is a one element list

[07:42] <chromatic> Indexing into a pair is like .has_key?

[07:42] <castaway> afair the docs say a pair of vals with a fat comma default to being a hash, yes

[07:42] <jql> that would make me think (%foo)[1] should return 2 as well

[07:42] * autrijus nukes 

[07:42] <jql> which it shouldn't

[07:42] <autrijus> instance ArrayClass (IVar VPair) where

[07:42] <luqui> autrijus, yeah, that makes sense I think

[07:42] <luqui> oh

[07:43] <luqui> wait

[07:43] <luqui> there's something going on with the tentative new definition of .{}

[07:43] <luqui> Maybe the "pair is a one element hash" is the thing that has to give

[07:43] <Darren_Duncan> in Perl 6, a => constructs a Pair object

[07:43] <Darren_Duncan> that's its definition

[07:44] <Darren_Duncan> a Pair object is a single element hash

[07:44] <luqui> yeah, but larry also said that it can be treated as a single element hash

[07:44] <luqui> yeah

[07:44] <autrijus> luqui: cool. get that codified in Syn so I can rewrite that chunk :)

[07:44] <Darren_Duncan> or a single element array, where the key is the array index

[07:44] <luqui> get what codified?

[07:44] <luqui> we've run into a conflict

[07:45] <castaway> oops, I was mixing it up with $hashref = { "a" => 1 };

[07:45] <jql> codify pair =:= hash where .keys == 1?

[07:45] <Darren_Duncan> the result of pairs() is a list of Pair objects; feeding pairs() to map() will give one Pair object per map iteration

[07:45] <luqui> jql, but that's probably wrong, if we're considering .{} to be an advanced .[]

[07:45] <Darren_Duncan> that's how pairs() is different from kv()

[07:46] <jql> I'd like to consider .[] a specialized form of .{}

[07:46] <Darren_Duncan> I think so too

[07:47] <luqui> whatever

[07:47] <Darren_Duncan> all array keys are integers starting at zero

[07:47] * jql hides $[

[07:47] <autrijus> luqui: what's the win of considering .{} to be an advanced .[]?

[07:47] <Darren_Duncan> $[ is deprecated anyway

[07:47] <Darren_Duncan> and should never appear in perl 6

[07:47] <luqui> autrijus, I don't remember ;-)

[07:47] * jql hid it

[07:47] <luqui> I think it had to do with multidim stuff

[07:49] <autrijus> not grokking it :)

[07:49] <autrijus> but anyway, I'll make pair never flatten first.

[07:49] * luqui is looking through is recent mail

[07:49] <Darren_Duncan> autrijus, thank you

[07:49] <luqui> ahh, one thing was this:  $ref{1;"foo";5}    (AoHoA)

[07:49] <Aankhen``> Oh, autrijus, just FYI: r4154 built OK.

[07:50] <lightstep> 4155 still builds here

[07:50] <luqui> [email@hidden.address]
[07:51] <jql> also [.{}]

[07:51] <autrijus> so, is Pair an Array?

[07:51] <luqui> nopaste?

[07:51] <autrijus> (a=>1).does(Array)

[07:51] <jql> pair.kv is the array. always, afaik

[07:51] <luqui> jabbot, paste?

[07:51] <jabbot> luqui: Tell me more about that.

[07:51] <autrijus> does it respond to .[] at all?

[07:51] <luqui> jabbot, nopaste?

[07:51] <jabbot> luqui: nopaste is http://irc.csie.org:8888/

[07:52] <Aankhen``> luqui >> sial.org/pbot/perl6

[07:52] <Aankhen``> s,sial,http://sial,

[07:52] <pasteling> "luqui" at 67.165.197.242 pasted ".[] vs .{}" (31 lines, 1K) at http://sial.org/pbot/10579

[07:52] <jql> I was under the impression that lvalue usage of the pair would possibly (depending on @Larry's whim) result in the .v

[07:53] <jql> so $pair[3] might end up meaning $pair.value[3] someday maybe

[07:53] <luqui> re paste: might be worth disputing, though

[07:53] <luqui> jql, I don't follow

[07:55] <jql> I don't recall it ever being decided, but I recall some mailing-list chatter about a pair acting as a container for the value, and pretending the key was a sort of read-only role thing

[07:55] <jql> this was long ago, so new stuff way overrides it

[07:55] <jql> but it seemed like a nice idea

[07:55] * autrijus decides to punt for now... seems very blurry

[07:55] <luqui> except not really, because what if the value is a pair

[07:55] <luqui> autrijus, good move, I think

[07:56] <luqui> that's the same complaint as my junctive methods complaint

[07:56] <autrijus> luqui: not good news for module writers tho :)

[07:56] <jql> if it's a pair, we're encouraging the heat-death of the universe. :(

[07:57] <luqui> no we're not, we just can't decide whether to call it on the pair itself or its value

[07:57] <luqui> so we'd have to call it on the pair itself

[07:57] <jql> you're right

[07:57] <luqui> causing the special case .value.method for that particular method

[07:57] <autrijus> Darren_Duncan: ok, I punt. use this form for now

[07:57] <luqui> and unpredictable semantics for $pair.$method

[07:57] <autrijus> [(a=>b)].map:{...}

[07:58] <autrijus> er, I mean

[07:58] <jql> I didn't like that for junctions, either

[07:58] <autrijus> [%hash.pairs].map:{...}

[07:58] <luqui> damian is convinced that it is The Right Way

[07:58] <Darren_Duncan> uh huh

[07:58] <autrijus> which is guaranteed to not treat single pair as a small list or a small hash or a small whatever.

[07:58] <luqui> so it's hard to do anything about it

[07:58] <Darren_Duncan> afaik, pairs() by definition returns an array whose elements are each Pair objects

[07:58] <jql> autrijus: how can that be the solution, though? doesn't [] impose the same context as .map would?

[07:58] <luqui> Darren_Duncan, a list, not an array

[07:59] <jql> and cause the same expansion of elements?

[07:59] <autrijus> Darren_Duncan: even the scalar context?

[07:59] <autrijus> sorry, I mean list context

[07:59] <autrijus> %h.pairs # under list context it flattens, no?

[07:59] <Darren_Duncan> I consider a Pair object to be somewhat like a scalar

[08:00] <Darren_Duncan> it is a value with an attached key for looking it up if it were in a list of pairs like a hash

[08:00] <Darren_Duncan> it doesn't make sense to flatten a Pair

[08:00] * jql agrees with Darren

[08:00] <Darren_Duncan> if you want the constituents, you say Pair.kv()

[08:01] <autrijus> sure.

[08:01] <Darren_Duncan> if you flatten an array, do you get the indicies interleaved with the values ... no, just the values

[08:01] <autrijus> okay, I think I see what you're saying. attempting a hopefully working fix.

[08:01] <jql> %hash.kv == %hash.pairs.kv

[08:01] <jql> err

[08:01] <jql> no

[08:01] <Darren_Duncan> not sure about that

[08:01] <autrijus> %hash.pairs.map:{.kv}

[08:01] <jql> %hash.kv == %hash.pairs.map:{ .kv }

[08:01] <jql> my bad

[08:02] <Darren_Duncan> you mean %hash.kv == %hash.pairs.map:{.kv}

[08:02] <autrijus> good that we agree vehemently.

[08:02] <jql> heh

[08:02] <Darren_Duncan> its important to have the semantics I see as being right ...

[08:02] <Darren_Duncan> it is just so useful to keep the Pair object in a map etc

[08:03] <Darren_Duncan> so nice to have each key/value in a neat package

[08:03] <Darren_Duncan> what I have to do in Perl 5 is rediculous ... keys followed by a lookup for each

[08:03] <autrijus> right.

[08:03] <autrijus> r4156.

[08:03] <autrijus> please test.

[08:03] <Darren_Duncan> ok

[08:03] * jql has often had to resort to map { $hash{$_} ... } keys %hash;

[08:04] <autrijus> stevan: sorry, I think ChangeLog may need to grow quite a bit :p

[08:05] <autrijus> okay. I think that's it for now

[08:05] <jql> umm... now that we're happy there, can we agree that %hash.map:{...} means %hash.pairs.map:{...}? heh

[08:05] <Darren_Duncan> now on 'make'

[08:05] <Darren_Duncan> I would be happy with that, though its less important than when you explicitly say .pairs

[08:05] <svnbot6> r4156, autrijus++ | * `.pairs` should never ever flatten when used as invocant to `.map`.

[08:05] <svnbot6> r4156, autrijus++ |   Reported by Darren.

[08:06] <autrijus> jql: we agree, but pugs doesn't (yet)

[08:06] <autrijus> pugs> {1=>3, 4=>5}.pairs.map:{.ref}

[08:06] <autrijus> (::Pair::HashSlice, ::Pair::HashSlice)

[08:06] <autrijus> pugs> {1=>3, 4=>5}.map:{.ref}

[08:06] <autrijus> (::Pair, ::Pair)

[08:06] <autrijus> (i.e. the .map form are not lvalues)

[08:06] <jql> ahh. okay

[08:06] <Darren_Duncan> make complete

[08:06] <jql> no worries

[08:07] <Darren_Duncan> uh oh

[08:08] <autrijus> breaks?

[08:08] <Darren_Duncan> unless its because I killed make ...

[08:08] <Darren_Duncan> Segmentation fault

[08:08] <autrijus> try a clean unoptimised build.

[08:08] <Darren_Duncan> will do

[08:08] <nothingmuch> morning

[08:08] <autrijus> yo nothingmuch

[08:08] * nothingmuch is sooo tired

[08:08] <jql> :foo(1) is now ref:(Pair) from pugs>?

[08:09] * jql asks, cause he hasn't compiled

[08:09] <castaway> awo nm

[08:09] <nothingmuch> define: awo

[08:09] <Darren_Duncan> did 'make realclean'; perl makefile ...; now on 'make unoptimized'

[08:10] <Darren_Duncan> away from comp for c 10 min

[08:10] <autrijus> pugs> my $x = :x<1>; $x.ref

[08:10] <autrijus> ::Pair

[08:10] <lightstep> optimized r4155 doesn't break

[08:10] <autrijus> same for :x(1)

[08:11] <jql> that worked before. :)

[08:11] <autrijus> er. sure.

[08:12] <jql> I wan referring to plain pugs> :x(0)\n

[08:12] <jql> I was just being curious

[08:13] <Darren_Duncan> done already ... much faster than expected

[08:14] <scook0> is it supposed to be legal to call a non-multi sub as though it were a method?

[08:14] <castaway> awo = hawo = hallo

[08:14] <luqui> = hello

[08:14] <luqui> putting it through the babelfish

[08:14] <scook0> (sri_ mentioned this yesterday, but I'm not sure if anyone else noticed)

[08:15] <luqui> you know, I don't know.  I wouldn't think so, though

[08:15] <luqui> (but there is an argument for making $foo.bar($baz) equivalent to bar($foo,$baz) everywhere)

[08:15] <luqui> (but we probably don't buy that argument)

[08:15] <Darren_Duncan> unfortunately, this still gives the same answer as the old version: my %foo = ('a'=>'b'); %foo.pairs.map:{say $_};

[08:15] <chromatic> It's like CPS for dispatch!

[08:16] <scook0> luqui: it makes sense for multi subs, but I'm a bit suspicious of allowing it for regular subs

[08:16] <luqui> I know what you mean

[08:17] <Darren_Duncan> autrijus, it still seems to be broken, or something else is busted here

[08:17] <scook0> I was putting together a patch for it, but Bind.hs is in a bit of a state after the recent shakeup of how invocants work

[08:18] <Darren_Duncan> however, lets see how SUPER works ...

[08:19] <autrijus> scook0: there is indded an argument for 1.sort() to fail with "method not found"

[08:19] <autrijus> instead of promoting it to (1) and returning it

[08:19] <scook0> also, I have a test, but I can't for the life of me figure out where to put it

[08:19] <autrijus> scook0: I can argue bothways. :)

[08:19] <autrijus> scook0: but I think p6l'ing it is the best idea

[08:19] <autrijus> the spec in S12 says it has to fallback to MMD

[08:19] <scook0> autrijus: roger

[08:20] <autrijus> and we know that MMD considers regular sub too (it trumps multi variants)

[08:20] <autrijus> but then that sentence can also be taken to mean that it _only_ consider 

[08:20] <autrijus> multis

[08:20] <autrijus> although it did not say that explicitly.

[08:20] <scook0> autrijus: yea, I shall petition the gods for a ruling

[08:20] <luqui> that seems the most reasonable to me

[08:21] <autrijus> luqui: only considering multis?

[08:21] <luqui> foo($bar);   # check subs, then multis

[08:21] <luqui> $bar.foo;   # multis only

[08:21] <autrijus> er, no.

[08:21] <autrijus> foo($bar); # always means &foo with $bar as invocant -- at least now

[08:21] <autrijus> you can argue that it has no invocant

[08:21] <autrijus> and only attempts to consider methods on runtime

[08:22] <luqui> soo foo($bar) and $bar.foo are equiv?

[08:22] <autrijus> but in any case please spec it down better than S12 :)

[08:22] <autrijus> luqui: that is what I gather. I may be totally wrong.

[08:22] <autrijus> close $fh;

[08:22] <luqui> that's just because there's no "close" in scope

[08:22] <luqui> maybe

[08:23] <luqui> I'm no authority on this matter.  I grok it the least of anything in p6 (except the political-type stuff)

[08:23] <autrijus> so is or is not $fh invocant?

[08:23] <autrijus> in close($fh)

[08:23] <luqui> Depends on whether there's a "sub close" above it

[08:23] <autrijus> does it get resolved at compile time?

[08:23] <luqui> !!

[08:23] <autrijus> eval '&close = {...}'; close($fh);

[08:23] <luqui> (perhaps)

[08:23] <scook0> the exact snippet that sparked this was:

[08:24] <autrijus> luqui: I can't see how it can be resolved at compile, like, at all.

[08:24] <jql> crapity crap

[08:24] <scook0> my Int $x = 1; $x.foo; sub foo { say 'lalala' }

[08:24] <luqui> hmm... dunno

[08:24] * luqui p6ls

[08:25] <jql> I can make educated guesses, but I can'

[08:25] <jql> s really say

[08:25] <nothingmuch> luqui, autrijus: i'm starting to write up the MMD proposal

[08:26] <autrijus> anyway, please let me know when this is hashed out :)

[08:26] <autrijus> (it will affect a lot on S29 and Prim)

[08:27] <sri_> autrijus: *** No compatible subroutine found: "&opendir"

[08:27] <svnbot6> r4157, autrijus++ | * `sub foo is rw` now toggles &foo's subLValue flag.

[08:27] <svnbot6> r4157, autrijus++ | * subroutines declared in main is marked as global for now

[08:27] <svnbot6> r4157, autrijus++ |   -- will revisit later

[08:27] <sri_> fresh baked pugs

[08:27] <autrijus> sri_: 

[08:27] <autrijus> pugs> opendir('/tmp')

[08:28] <autrijus> {obj:IO::Dir}

[08:28] <autrijus> sri_: look at src/Pugs/pugs_config and see if you have PUGS_HAVE_POSIX

[08:28] <autrijus> er, wait, that can't be it.

[08:28] <autrijus> you're using an old pugs , or you are invoking opendir weirdly.

[08:28] <autrijus> (note that it now returns the dh)

[08:28] <autrijus> (not taking dh as argument)

[08:29] <sri_> works on the interactive shell

[08:29] <autrijus> opendir($fh, '/tmp');

[08:29] <autrijus> are you doing something like that? :)

[08:29] <autrijus> $fh = opendir('/tmp'); # it's like this

[08:29] <autrijus> dh, even.

[08:30] <sri_> dammit :)

[08:30] <sri_> works

[08:30] * sri_ hides

[08:30] <autrijus> :)

[08:30] <autrijus> you have open/close/read/rewind

[08:30] <autrijus> there's no seek/tell yet, but I suspect you won't use that anyway

[08:31] <sri_> full File::Find::Rule would also require stat

[08:32] <autrijus> what kind of stat?

[08:32] <autrijus> the full kind?

[08:32] <sri_> the perl5 kind yes

[08:32] <sri_> but that has time

[08:32] <autrijus> yeah. we have various filetests

[08:33] <autrijus> rwxezsfd

[08:33] <autrijus> so try to use them first :)

[08:33] <autrijus> (and they work on win32)

[08:33] <sri_> nice

[08:34] <Darren_Duncan> autrijus, good news and bad news with your latest updates

[08:34] <autrijus> bad news please

[08:35] <Darren_Duncan> the SUPER fix, adding Object , works so my new() is back in action

[08:35] <Darren_Duncan> bad news is that Pair objects still separate

[08:35] <autrijus> as in %hash.pairs.map:{}?

[08:35] <Darren_Duncan> I still see the same behaviiour as before with pairs()

[08:35] <Darren_Duncan> yes

[08:36] <scook0> autrijus: Everything after line 1093 of AST/Internals shows up as methods of typeclass MonadEval...is this a mistake, or deliberate?

[08:36] <scook0> (it compiles fine either way...)

[08:37] <Darren_Duncan> near as I could tell, you only updated one file, Types or something; maybe multiple files were necessary?

[08:37] <autrijus> scook0: not deliverate

[08:37] <scook0> autrijus: I'll fix it in my next ci

[08:37] <Darren_Duncan> either way, your other fixes give me enough for another commit

[08:38] <autrijus> Darren_Duncan: it's the sort.

[08:38] <autrijus> if you take the sort away it works.

[08:38] <Darren_Duncan> looking ...

[08:39] <Darren_Duncan> fyi, Syn02 says that Pair objects sort on their keys by default

[08:39] <jql> sweet

[08:39] <autrijus> cool, so :x<3> sorts better than 'y'?

[08:39] <Darren_Duncan> and they don't get split up

[08:39] <Darren_Duncan> since its obscure, I even made a note of that in a module comment

[08:41] <luqui> autrijus, either that, or :x<3> sorts better than :y<2>, and we have yet to define how :x<3> sorts wrt 'y'

[08:41] <jql> hrm. are inline try{} blocks supposed to work?

[08:41] <jql> not in Pugs, but in P6

[08:41] <Darren_Duncan> I think it string sorts on the keys like with cmp

[08:41] <luqui> you mean 3 + try { 4 } ?

[08:41] <Darren_Duncan> by default

[08:41] <autrijus> jql: sure. try{} is just like p5 eval{}

[08:41] <jql> yes, like that

[08:41] <luqui> no

[08:41] <luqui> I don't think so

[08:42] <Darren_Duncan> try{} is like the block form of eval

[08:42] <luqui> That could be, but it could also be a statement: form like if

[08:42] <Darren_Duncan> and in perl 6 'eval' only has its string form

[08:42] * luqui realizes he has no idea

[08:42] <jql> so I need to write sub try_this (&foo) { try { return foo() } catch(...) {} }?

[08:42] <autrijus> well.

[08:42] <svnbot6> r4158, scook0++ | * Changed var names & comments in Bind to reflect (Maybe invocant)

[08:42] <svnbot6> r4158, scook0++ | * Removed errant functions from class MonadEval

[08:42] <svnbot6> r4158, scook0++ | * Corrected the "evil hack" comment for &not

[08:42] <autrijus> "The Perl 6 equivalent to Perl 5โs "eval {...}" is "try {...}"."

[08:42] <Darren_Duncan> so p5 "eval { ... };" equals p6 "try { ... }"

[08:42] <autrijus> (S04)

[08:42] <luqui> except for your bad syntax yeah

[08:43] <Darren_Duncan> and "eval '...';" is the same in both languages

[08:43] <autrijus> and later in S04

[08:43] <autrijus>            $x = try { given $foo { when 1 {2} when 3 {4} } + $bar;

[08:43] <luqui> oh

[08:43] <autrijus> so I think I'm correct in thinking that try is a normal sub.

[08:43] <autrijus> ;)

[08:43] <jql> ok, that's good

[08:43] <luqui> there we go

[08:43] <Darren_Duncan> try is a block

[08:43] <luqui> try is like do

[08:43] <Darren_Duncan> technically you don't even need the 'try' word

[08:44] <luqui> except that it catches all exceptions by default

[08:44] <jql> I asked so I could use @foo.sort:{ try { .value } // $_ }

[08:44] <autrijus> jql: you can use that.

[08:44] <jql> not that I'd *want* to use it

[08:44] <jql> just so I could

[08:44] <Darren_Duncan> if you put a CATCH block inside ANY other block, said outer block will act like a 'try'

[08:44] <autrijus> Darren_Duncan: that is right, except that try{} also runs the block.

[08:44] <Darren_Duncan> so the 'try' is syntactic sugar, except when you want to ignore the exceptions

[08:44] <autrijus> try{} is like

[08:44] <luqui> holy smokes, I just realized that try is the thing that converts exceptions into undefs, as people have requested

[08:44] <autrijus> do { CATCH: {}}

[08:45] <luqui> s/\://

[08:45] <nothingmuch> i am discussing binding matching

[08:45] <jql> umm... so @foo.sort:{ .value; CATCH { $_ } }?

[08:45] <nothingmuch> how do I call the thing that is entering the function

[08:45] <nothingmuch> and how do i call the thing that is accepting it?

[08:45] <nothingmuch> i know both can be called "param"

[08:45] <Darren_Duncan> the exception is in $!

[08:45] <Darren_Duncan> like all errors in Perl 6

[08:45] <luqui> jql, hmm... woah... nice

[08:45] <jql> I don't want the exception. I want $_

[08:46] <Darren_Duncan> Perl 6 uses just $! whereas Perl 5 used either $@ or $! depending on what caused the error

[08:46] <luqui> ohhh

[08:46] <luqui> right

[08:46] <luqui> @foo.sort(-> $a { .value; CATCH { $a } })

[08:46] <luqui> darn

[08:46] <nothingmuch> note that catch implies given $!, i think

[08:46] <luqui> CATCH is a topicalizer

[08:47] <luqui> yeah

[08:47] <nothingmuch> you can do $?OUTER::_

[08:47] <nothingmuch> err, ditch the ?

[08:47] <nothingmuch> anybody got named that distinguish the parameter getting into a function, and the parameter declaration that's taking it in?

[08:47] <nothingmuch> s/named/names/

[08:48] <jql> hrm. CATCH topicalizes...

[08:49] <Darren_Duncan> autrijus, I still get the cast error even with the .sort taken out

[08:49] <luqui> nothingmuch, you mean parameter and argument?

[08:49] <scook0> nothingmuch: you mean the distinction b/w formal parameter & actual parameter?

[08:49] <autrijus> Darren_Duncan: 

[08:49] <autrijus> pugs> list({x=>2}.pairs.map:{1})

[08:49] <autrijus> (1)

[08:49] <autrijus> pugs> list({x=>2}.pairs.sort.map:{1})

[08:49] <autrijus> (1, 1)

[08:50] <nothingmuch> so parameter is the thing that gets the argument?

[08:50] <scook0> I think I used 'parameter' and 'argument' in the Haddocks...

[08:50] <nothingmuch> that makes sense

[08:50] <nothingmuch> scook0: i'm not sure

[08:50] <autrijus> Darren_Duncan: can you confirm that?

[08:50] <nothingmuch> function($a); # what is $a?

[08:50] <Darren_Duncan> checking

[08:50] <jql> hrm. too bad $! doesn't let you examine your scope like a debugger

[08:50] <nothingmuch> sub function ($b); # what is $b?

[08:50] <jql> $!<$_> in that case

[08:50] <luqui> jql, are you sure?

[08:50] <Darren_Duncan> as far as I know there is a $! stack

[08:50] <Darren_Duncan> it keeps a list of error values

[08:50] <scook0> nothingmuch: parameter & argument seems to be the way to go

[08:50] <luqui> but it would have to be something like $![-2]<$_>

[08:51] <jql> there's no need for it to give you access to your lexical scope, though, since CATCH{} is already in it

[08:51] <luqui> $b is a parameter, $a is an argument

[08:52] <luqui> (parameters are also known as "formals")

[08:52] <Darren_Duncan> autrijus, my version spits out (1,1) both with and without the .sort

[08:52] <luqui> (which is less common, but also less ambiguous)

[08:52] *** ChanServ sets mode: +o autrijus

[08:52] <Darren_Duncan> is anyone else here up to the latest build, can you test this pairs thing?

[08:53] *** autrijus sets mode: -o autrijus

[08:53] <jql> looky there

[08:53] <svnbot6> r4159, autrijus++ | * converted more (return . VList) into returnList

[08:53] <autrijus> ?eval list({x=>2}.pairs.sort.map:{1})

[08:53] <nothingmuch> Darren_Duncan: my box should be pretty far along. want an account?

[08:53] <evalbot6> (1, 1) 

[08:53] <jql> ?eval "Hello #perl6!"

[08:53] <evalbot6> 'Hello #perl6!' 

[08:53] <jql> sweet

[08:53] <autrijus> ?eval list({x=>2}.pairs.map:{1})

[08:53] <evalbot6> (1, 1) 

[08:53] <jql> ?eval :x<1>

[08:53] <evalbot6> ('x' => '1') 

[08:53] <jql> ok, that's good

[08:53] <Darren_Duncan> mine is up to date

[08:54] <nothingmuch> if the smoke loop isn't dead, that is

[08:54] <nothingmuch> ?eval exit;

[08:54] <Darren_Duncan> nothingmuch, I wanted a third verify, since autrijus and I got different answers

[08:54] <evalbot6> Error: No compatible subroutine found: "&exit" 

[08:54] <nothingmuch> buahahaha

[08:54] <nothingmuch> i bet that's banned too

[08:54] <jql> lol

[08:54] <nothingmuch> ah

[08:54] <jql> I wanted to know exit()'s return value!!

[08:54] <luqui> !eval "system 'rm -rf /'"

[08:55] <nothingmuch> what will (1 ...)>>+<<(1...) do to evalbot?

[08:55] <autrijus> Darren_Duncan: r4159 should have both cases solved

[08:55] <nothingmuch> does it have accounting?

[08:55] <autrijus> nothingmuch: timeout

[08:55] <autrijus> it does.

[08:55] <Darren_Duncan> will check

[08:55] <jql> (:x<0>).map:{1}

[08:55] <nothingmuch> goody

[08:55] <jql> ?eval (:x<0>).map:{1}

[08:55] <evalbot6> () 

[08:55] <autrijus> ?eval $?PUGS_VERSION

[08:55] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[08:55] <autrijus> wait till it's r4159 ;)

[08:55] <jql> ?eval {:x<0>}.pairs.map:{1}

[08:55] <evalbot6> (1, 1) 

[08:56] <luqui> does it continuously update?

[08:56] <autrijus> it does.

[08:56] <jql> ?eval recompile yourself

[08:56] <evalbot6> Error: No compatible subroutine found: "&recompile" 

[08:56] <luqui> I don't think we made "yourself" a keyword

[08:56] <luqui> but there is a reflexive method call form

[08:56] <nothingmuch> evalbot runs pugs -e?

[08:56] <nothingmuch> ?eval $?SELF.recompile;

[08:56] <evalbot6> Error: Undeclared variable: "$?SELF" 

[08:56] <luqui> ?eval ./=recompile

[08:56] <evalbot6> Error:  unexpected "." expecting program 

[08:57] <jql> perhaps you need $*INTERPRETER?

[08:57] <jql> ?eval $*INTERPRETER.recompile

[08:57] <evalbot6> Error: Undeclared variable: "$*INTERPRETER" 

[08:57] <jql> darn

[08:57] <scook0> ?eval my &foo := {say 'hi'}; &foo.arity

[08:57] <evalbot6> 1 

[08:57] <nothingmuch> ?eval die die die stupid robot!

[08:57] <evalbot6> Error:  unexpected "!" expecting word character, "::", ".", "(", adverbial block, block construct, term, ":", term postfix, operator, ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:57] <luqui> scook0, that arity should be 0

[08:58] <scook0> luqui: aye

[08:58] <nothingmuch> ?eval die die die stupid robot;

[08:58] <evalbot6> Error: No compatible subroutine found: "&stupid" 

[08:58] <luqui> you found yourself a bug

[08:58] <autrijus> luqui: why?

[08:58] <nothingmuch> haha

[08:58] <autrijus> it's *@_

[08:58] <autrijus> *@_ is arity 1

[08:58] <autrijus> no?

[08:58] <jql> it croaked on stupid?

[08:58] <luqui> because it doesn't implicitly use $_

[08:58] <luqui> oh

[08:58] <autrijus> ;)

[08:58] <luqui> bare block is *@_ ?

[08:58] <autrijus> I don't know

[08:58] <scook0> autrijus: no, it behaves differently if you use @_

[08:58] <autrijus> is it only applied to sub{}?

[08:58] <Darren_Duncan> your test works now

[08:58] <scook0> ?eval my &foo := {say hi}; foo

[08:58] <evalbot6> Error: No compatible subroutine found: "&say" 

[08:58] <autrijus> Darren_Duncan: cool

[08:58] <Darren_Duncan> list({x=>2}.pairs.sort.map:{1}) 

[08:59] <jql> say "hi:

[08:59] <luqui> I thought, in the absence of $^s, that it was either 0 or 1, depending on the usage of $_

[08:59] <Darren_Duncan> now to test my module

[08:59] <nothingmuch> back to thinking

[08:59] <jql> ?eval my &foo := {say "hi"}; foo

[08:59] <evalbot6> Error: No compatible subroutine found: "&say" 

[08:59] <luqui> autrijus, I think it is only applied to sub, since that was a backwards-compatibility decision

[08:59] <jql> ?eval my &foo := {say "hi"}; foo(1,2,3)

[08:59] <evalbot6> Error: No compatible subroutine found: "&say" 

[08:59] * jql is amused

[09:00] <autrijus> luqui: sure.

[09:00] <luqui> ha, "backwards-compatibility" and perl 6t

[09:00] <luqui> s/t$//

[09:00] <autrijus> luqui: methods too?

[09:00] <autrijus> method foo { say @_ }

[09:00] <luqui> yeah, but methods also have a *%_

[09:00] <autrijus> sure

[09:01] <autrijus> ?eval $?PUGS_VERSION

[09:01] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[09:01] <autrijus> slow rebuild cycle

[09:01] <luqui> It wasn't so much backwards compatibility as it was to appease people who don't like signatures, and enjoyed the pain that was perl 5 arg processing

[09:01] <luqui> the question is, in method foo, is the invocant @_[0] ?

[09:01] <autrijus> don't think so.

[09:01] <jql> aww crap

[09:02] <luqui> I wouldn't think so, but the "old-style" type argument says yes

[09:02] <autrijus> as it stands it would mean something like ($?SELF:*@_)

[09:02] <jql> that's a nasty, vicious question there

[09:02] <autrijus> how do you write it "correctly" anyway?

[09:02] <autrijus> is the signature allowing double binding?

[09:02] <luqui> I don't think so

[09:02] <jql> I have to think it's not in @_

[09:02] <autrijus> well then. if you can't express it using introspectable syntax :)

[09:02] <autrijus> ...it can't happen

[09:02] <luqui> yeah...

[09:03] <jql> slurpy *@_ means only slurped arguments are in @_, I think

[09:03] <Darren_Duncan> my module's pairs() etc works now

[09:03] <autrijus> Darren_Duncan: yay

[09:03] <jql> @_[0] has to be the first slurped argument

[09:04] <luqui> well, we were arguing about whether *@_ is really the signature of methods

[09:04] <luqui> or whether it's some funny inexpressible thing

[09:05] <autrijus> I don't like funny inexpressible things, fyi.

[09:05] <luqui> and I have to agree than inexpressible things are bad

[09:05] <autrijus> I think it's perfectly well that we pretend there's always a 

[09:05] <autrijus> $?SELF = shift;

[09:05] <autrijus> in front of all methods.

[09:05] <autrijus> where "we" means "old perl 5 people"

[09:05] <luqui> yeah.  p5 junkies can't have it their way all the time

[09:05] <jql> you can always unshift it. method foo { unshift $?SELF; } # feels like perl5

[09:06] <luqui> yuck.  Well, the whole ()-less thing is yuck anyway.

[09:06] <jql> if the p5 people could live with shift @_, they can live with that.

[09:06] <luqui> At least we're preserving the bosonic nature of yucks

[09:07] <luqui> autrijus, who was that guy that you pointed me to who did something in relation to the many worlds interpretation?

[09:08] <luqui> long, long ago the pointing occured

[09:08] <svnbot6> r4160, autrijus++ | * according to luqui, bare {} and pointy -> both have no

[09:08] <svnbot6> r4160, autrijus++ |   default argument at all, unlikes sub/method/coro that has *@_.

[09:08] <autrijus> luqui: ashfar?

[09:08] * luqui wikipedias him

[09:08] <luqui> first name?

[09:09] <jql> ?eval {@_}.(1,2,3)

[09:09] <evalbot6> [1, 2, 3] 

[09:10] <luqui> that still looks right

[09:10] <autrijus> except it's not? ;)

[09:10] <luqui> no, just confirming

[09:10] <autrijus> so @_ is implicit var?

[09:10] <autrijus> or how does that work?

[09:10] <jql> ?eval {$^x}.(1,2,3)

[09:10] <evalbot6> Error:  unexpected "\\" expecting "::" 

[09:10] <luqui> I wonder what happens when you use $_ and @_ in the same block...

[09:10] <jql> phooey

[09:11] <autrijus> luqui: hey wait. @_ is implicitly extracted?

[09:11] <autrijus> Synopsis never said that

[09:11] <luqui> I don't like @_ implicit, but I think that's what people would expect

[09:11] <luqui> yeah, I'm extrapolating

[09:11] <luqui> don't gospel it

[09:11] <autrijus> whew.

[09:11] <jql> so @_ is the $& of perl6 subs? :)

[09:11] <jql> saw_slurpyargument

[09:11] * luqui thinks he should have a "speculating" sigil on his quotes

[09:12] <luqui> or, for proper huffmanization, a "not speculating" sigil

[09:12] <luqui> ;-)

[09:12] <jql> so placeholders don't work yet, or did I make a mistake?

[09:12] <autrijus> jql: I think it's a evalbot helper script problem

[09:13] <jql> ok. I tried it from pugs> and it works fine

[09:14] <jql> oh, and my 2 cents, I think luqui is right

[09:14] <jql> even though I made fun. :)

[09:15] <autrijus> what is right again? :)

[09:15] <luqui> jql, there are a lot of local $&s in perl 6.  Fortunately, we're trying hard not to make any of them global.

[09:15] <jql> if @_ is used, it implies a *@_ argument

[09:15] <autrijus> ?eval $?PUGS_VERSION

[09:15] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[09:15] <luqui> jql, only in implicit blocks

[09:15] * autrijus wonders if juerd's rebuilding script is really working

[09:16] <luqui> it's always there if there's no (), and it's never there if there is a () on normal declarations

[09:16] <jql> where a signature is not otherwise provided, and not a "sub"

[09:16] <jql> yah

[09:16] <autrijus> sub foo { $_ + @_ }

[09:16] <autrijus> what does this do?

[09:16] <autrijus> { $_ + @_ }

[09:16] <autrijus> what about this?

[09:16] <luqui> right

[09:16] <luqui> that was my question earlier

[09:16] <jql> $_ would be undef, @_ would be the count of slurpy args

[09:16] <autrijus> undef?

[09:17] <luqui> Or $_ would be first arg

[09:17] <luqui> who knows

[09:17] <jql> who defined $_ for sub foo{}? it's lexical

[09:17] <autrijus> and how do you spell out the full signature?

[09:17] <autrijus> jql: $_ is defined as implciit.

[09:17] <luqui> jql, I think $_ is the first arg still (that could have changed last week though)

[09:17] <jql> well, it's undef if @_ == 0

[09:17] * jql chuckl;es

[09:17] <autrijus> ...

[09:18] <luqui> I don't think anyone in here was around for my "nonex" proposal ;-)

[09:18] <autrijus> anyway. the Synopsis doesn't say how @_ autoextracts, and how it interacts with $_

[09:18] <autrijus> so I get to blissfully ignore it :)

[09:18] <luqui> %hash<foo> = nonex;    # equiv to delete %hash<foo>

[09:18] <luqui> that's fine

[09:18] <luqui> as long as it does $_ right

[09:18] <luqui> that's the important one

[09:19] <luqui> which it does not

[09:19] <luqui> {say}.(1)

[09:19] <autrijus> ?eval {int}.(1)

[09:19] <evalbot6> 0 

[09:20] <jql> ?eval {@_}.(10)

[09:20] <evalbot6> [10] 

[09:20] <jql> ?eval {$_}.(10)

[09:20] <evalbot6> \10 

[09:20] <jql> interesting

[09:20] <luqui> it works if you actually type $_, but it doens't do the implicit right, it seems

[09:20] <Aankhen``> sub foo { ... } gets an implicit signature of (*@_)...

[09:20] <autrijus> luqui: "say" worksforme

[09:20] <Aankhen``> ?eval say "hi"

[09:20] <jql> $?CALLER::_ doesn't work, then

[09:20] <evalbot6> Error: No compatible subroutine found: "&say" 

[09:21] <Aankhen``> ?eval {@_}.(foo => "bar")

[09:21] <evalbot6> [] 

[09:21] <luqui> autrijus, really?  {say}.(1) says 1?

[09:21] <autrijus> nvm.

[09:21] <Aankhen``> That ought to throw an error, innit?

[09:21] <autrijus> luqui: how does say signal that it needs $_ though.

[09:21] <autrijus> we currently have

[09:21] <Aankhen``> ?eval -> *@_ {@_}.("foo", "bar")

[09:21] <evalbot6> ['foo', 'bar'] 

[09:22] <Aankhen``> ?eval -> *%_ {@_}.(foo => "bar")

[09:22] <evalbot6> Error: Undeclared variable: "@_" 

[09:22] <autrijus> say(?$x=$CALLER::_)

[09:22] <Aankhen``> Oops.

[09:22] <luqui> through the $CALLER::_ in the declaration of say

[09:22] <luqui> ouch

[09:22] <Aankhen``> ?eval -> *%_ {%_}.(foo => "bar")

[09:22] <evalbot6> {('foo' => 'bar')} 

[09:22] <luqui> that seems nasty in the face of redefinition and such

[09:22] <Aankhen``> ?eval -> *@_, *%_ {%_}.("foo", "baz", "quux", foo => "bar")

[09:22] <autrijus> luqui: except this

[09:22] <evalbot6> {('foo' => 'bar')} 

[09:22] <Aankhen``> ?eval -> *@_, *%_ {@_}.("foo", "baz", "quux", foo => "bar")

[09:22] <jql> not bad

[09:22] <evalbot6> ['foo', 'baz', 'quux'] 

[09:23] <Aankhen``> I love P6 signatures. :-D

[09:23] <autrijus> {eval '&say := { $^x + $^y }'; say}.(1)

[09:23] <jql> they are spiffy

[09:23] <svnbot6> r4161, autrijus++ | * luqui pointed out that *@_ is only implicit for Routines.

[09:23] <luqui> autrijus, right

[09:23] <Aankhen``> ?eval sub ($odd where { $_ % 2 }) { $odd }.(1)

[09:23] <evalbot6> Error:  unexpected "w" expecting trait, ",", ":" or ")" 

[09:23] <Aankhen``> :-(

[09:23] <luqui> hmm

[09:23] <autrijus> luqui: if you can find an algorithm -- or indeed define that only compile-time binding counts -- I'm willing to implement it

[09:23] <luqui> maybe it's time to rollback 4160

[09:24] <Aankhen``> ?eval { ++@_ }.(1)

[09:24] <evalbot6> Error: Can't modify constant item: VInt 2 

[09:24] <Aankhen``> ?eval { ++@_[0] }.(1)

[09:24] <evalbot6> Error: Can't modify constant item: VInt 2 

[09:24] <Darren_Duncan> question ...

[09:24] <luqui> well, I wonder which is more complex

[09:24] <Darren_Duncan> I have a function that does this: return hash %{$message.:msg_vars};

[09:24] <luqui> compile-time binding that fails with redefinition, or just making .arity return 1 instead of 0

[09:24] <autrijus> ?eval $?PUGS_VERSION

[09:24] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[09:24] <luqui> from a language perspective, of course

[09:24] <Darren_Duncan> from the caller point of view, this seems to return a 'List' and not a 'Hash' as I expected

[09:25] <luqui> (ok, so it wasn't 4160, but it was recent)

[09:25] <autrijus> luqui: *shrug* you get that any way with any sort of mmd.

[09:25] <autrijus> in the face of runtime rebind

[09:25] <autrijus> so it's a general problem

[09:25] <Darren_Duncan> what's the easy way to make it return a 'Hash'?

[09:25] <jql> Darren: \hash

[09:25] <jql> ?

[09:25] <luqui> twoo, twoo

[09:25] <Darren_Duncan> will try that

[09:25] <autrijus> Darren_Duncan: return {hash %{}}

[09:26] <autrijus> or indeed

[09:26] <jql> ?eval \hash(1,2,3,4)

[09:26] <Aankhen``> ?eval sub (Range $foo) { "Range - " ~ $foo.perl; }.(1..10)

[09:26] <evalbot6> {('1' => 2), ('3' => 4)} 

[09:26] <evalbot6> 'Range - \\(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)' 

[09:26] <autrijus> { %{}}

[09:26] <autrijus> hm, that won't work.

[09:26] <autrijus> stupid autoclosuring heuristic.

[09:26] <Darren_Duncan> autrijus, return {hash %{}} doesn't work; it will construct an anonymous lock

[09:26] <Darren_Duncan> block

[09:26] <autrijus> indeed.

[09:26] <jql> ?eval hash(1,2,3,4)

[09:26] <evalbot6> {('1' => 2), ('3' => 4)} 

[09:26] <luqui> autrijus, huh?

[09:26] <luqui> which autoclosuring heuristic?

[09:26] <jql> hrm. same difference

[09:26] <Aankhen``> ?eval -> { return hash (1, 2, 3, 4); }

[09:26] <evalbot6> Error: cannot return() outside a subroutine 

[09:27] <Aankhen``> ?eval sub () { return hash (1, 2, 3, 4); }.()

[09:27] <jql> wtf?

[09:27] <evalbot6> {('1' => 2), ('3' => 4)} 

[09:27] <autrijus> luqui: 

[09:27] <autrijus> 2~If the closure appears to delimit nothing but a commaโseparated list starting with a pair (counting a single pair as a list of one element), the closure will be immediately executed as a hash composer.

[09:27] <autrijus> S04.

[09:27] <Aankhen``> ?eval sub () { return hash (1 => 2, 4 => 3); }.()

[09:27] <evalbot6> {('1' => 2), ('4' => 3)} 

[09:27] <autrijus> the stupid thing is that it doesn't say hash() counts too.

[09:27] <autrijus> but maybe it's intentional :)

[09:27] <autrijus> I think it is.

[09:27] <luqui> you mean hash { } ?

[09:27] <autrijus> I mean hash ().

[09:28] <luqui> oh right

[09:28] <Aankhen``> Darren_Duncan >> Try `return hash $message.:msg_vars;`?

[09:28] <autrijus> there is no hash {}

[09:28] <autrijus> that's another application of principle of most surprise, fwiw :)

[09:28] <Darren_Duncan> will that return a copy of the original hash?

[09:28] <luqui> yeah, but at least hash can be a function instead of a syntactic form then

[09:28] <IshaCocoa_> how big is a fresh checkout of the pugs source (roughly)?

[09:28] <castaway> thats what I was pointing at earlier

[09:29] <autrijus> luqui: what's wrong with hash{} running the adverbial block.

[09:29] <luqui> Maybe you could make an empty hash like {,}

[09:29] <luqui> that would be nice

[09:29] <luqui> oh

[09:29] <Aankhen``> Darren_Duncan >> It ought to.

[09:29] <luqui> that's an interesting proposition

[09:29] <autrijus> luqui: that's what many people expected on #perl6 :)

[09:29] <autrijus> I think I've seen it ~12 times

[09:29] <autrijus> including you

[09:30] <Aankhen``> ?eval my %foo = (foo => "bar", baz => "quux"); sub () { return hash %foo; }.();

[09:30] <evalbot6> {('baz' => 'quux'), ('foo' => 'bar')} 

[09:30] <luqui> I didn't think it ran the block, I thought it would interpret the next {} as a has composer

[09:30] <autrijus> it may even worth it to have

[09:30] <autrijus> multi sub hash (Code &x)

[09:30] <autrijus> multi sub hash (List *@_)

[09:30] <jql> hash %foo is wrong. you have to use hash %foo.kv

[09:30] <Darren_Duncan> all my variations didn't work

[09:30] <autrijus> as two multi things.

[09:30] <Aankhen``> ?eval my %foo = (foo => "bar", baz => "quux"); sub () { return hash %foo.kv; }.();

[09:31] <evalbot6> {('baz' => 'quux'), ('foo' => 'bar')} 

[09:31] <Aankhen``> jql >> Seems to work right either way. ^_^

[09:31] <autrijus> jql: hash %foo is right.

[09:31] <luqui> jql, a list of pairs works fine

[09:31] <autrijus> it really works either way, except when the hash is shaped to take pairs as keys.

[09:32] <autrijus> (in which case all hell break lose)

[09:32] <autrijus> luqui: so, why do you want to rollback *@_ on pointy and bare?

[09:32] <Darren_Duncan> well, I'll just skip this attempt for now

[09:32] <jql> alright. if hash accepts <a b c d> and :a<b>, :c<d> equally, I'm not going to complain

[09:33] <Aankhen``> Maybe it needs: multi sub hash (*%_)

[09:33] <Aankhen``> as well.

[09:34] <Aankhen``> (for `hash(:a<b> :c<d>)` to work)

[09:34] <jql> but then I see a difficulty in using pairs as keys that way in hash()

[09:34] <luqui> autrijus, I referred to the wrong revision

[09:34] <autrijus> luqui: so what you want to rollback?

[09:34] <autrijus> Aankhen``: it already workes

[09:34] <jql> that's why %hash.kv sprang to mind

[09:34] <luqui> I (possibly) want to roll back the arity-0 when $_ isn't used thing

[09:34] <Aankhen``> autrijus >> Ah, right.

[09:34] * Aankhen`` shuts up.

[09:34] <Aankhen``> ?eval $?PUGS_VERSION

[09:34] <jql> I assumed it would construct Pair => Pair otherwise

[09:34] <autrijus> luqui: oh, you mean passing in $_ anyway?

[09:34] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[09:34] <jql> since that's legal

[09:34] <autrijus> luqui: as in making the prototype as (?$_)

[09:34] <luqui> yeah, it seems simpler that way

[09:35] <luqui> and nice an opaque from a syntactic perspective

[09:35] <autrijus> i.e. disable implicit varring on $_

[09:35] <luqui> Actually, I think the best is:

[09:35] <autrijus> and if arglist is empty, put it as ?$_

[09:35] <luqui> (?$_ = $OUTER::_)

[09:35] <autrijus> for pointy and block

[09:35] <autrijus> and as *@_

[09:35] <autrijus> for routine and above

[09:36] * jql would implicitlly given $?::OUTER::_ {...} the sub body

[09:36] <jql> or however it's syntaxed

[09:36] <jql> s/:://

[09:36] <Aankhen``> BBL.

[09:36] <autrijus> luqui: makes sense to you?

[09:36] <luqui> yeah

[09:37] <luqui> the only thing I'm frightened about with the $OUTER::_ thing

[09:37] <luqui> is if you're passed an argument without knowing that your particular construct passes arguments (like while), and then you try to use the lexical $_

[09:37] <luqui> when it's your argument

[09:38] * jql slaps his forehead

[09:38] <luqui> when in doubt, use -> { }, but I'm not sure that's good enough

[09:38] * luqui ows for jql

[09:38] <autrijus> what does ->{} gain?

[09:38] <autrijus> ->{} has no implicit params _at all_ ?

[09:38] <luqui> it says "no, seriously, no arguments"

[09:38] <jql> when $_ is your argument (like in while()), it's your invocant. right?

[09:39] <luqui> (unless I'm mistaken about what -> {} means)

[09:39] <autrijus> so we have

[09:39] <autrijus> {} # defaulting on ?$_=$OUTER::_

[09:39] <autrijus> ->{} # defaulting on nothing

[09:39] <autrijus> sub {} # defaulting on *@_

[09:39] <luqui> jql, I don't think so

[09:39] <autrijus> is that the idea?

[09:39] <autrijus> however,

[09:39] <autrijus> {$^x}

[09:39] <autrijus> ->{$^x}

[09:39] <autrijus> sub{$^x}

[09:39] <luqui> except for the first one, yeah.  the first one is a maybe.

[09:39] <autrijus> all produce the same signature

[09:40] <autrijus> that is ($x)

[09:40] <luqui> can you use placeholders inside named subs?

[09:40] * luqui dunnos

[09:40] <autrijus> I can't see why not.

[09:40] <autrijus> it's not forbidden anywhere.

[09:40] <luqui> Well, no, those couldn't all create the same signature

[09:40] <autrijus> why?

[09:40] <luqui> the second one is like saying sub () { $^x }

[09:40] <luqui> "I have no arguments.  I have one argument."

[09:41] <luqui> I think you basically have to pick your argument style: named (with ->) or placeholder ($^x)

[09:41] <luqui> no mixing and matching

[09:41] * jql points at macro /->/ { "sub" } as a defense

[09:41] <luqui> s/named/declared positional/

[09:42] <luqui> jql, it's more like macro /-> stuff/ { "sub ($stuff)" }

[09:42] <jql> too true

[09:42] <autrijus> okay. so $^x in anything but Bare is banned.

[09:43] * jql cries

[09:43] <luqui> jql, how come

[09:43] <autrijus> as it would make no sense to disallow it in -> but allow in sub.

[09:43] <luqui> autrijus, right

[09:43] <jql> I'm a lazy bastard. that's all

[09:43] <autrijus> (?$_=$OUTER::_ is rw) ?

[09:43] <autrijus> (for bare)

[09:43] <autrijus> @_map:{chomp}

[09:43] <luqui> for now, yeah

[09:43] <autrijus> @x.map:{chomp}

[09:44] <jql> sub foo { print $^foo if $^bar }  # I suck. shoot me now

[09:44] <luqui> everything is crystal clear except for the placeholderless bare block

[09:44] <autrijus> for some reason I think jql's plea makes sense ;)

[09:44] <luqui> which is "get close until we figure it out for real"

[09:45] <luqui> jql, you realize that $^bar is your first argument

[09:45] <jql> yes. I know

[09:45] <jql> foo(DEBUG, "hello:)

[09:45] <autrijus> luqui: do you have tuits to codify all the three cases into tests?

[09:45] <luqui> how does that work with the implicit *@_ on ()-less subs

[09:45] <luqui> yeah

[09:45] <autrijus> danke.

[09:46] <jql> the sorted list of $^placeholders are indexes into @_?

[09:46] <luqui> where should I put them

[09:46] <autrijus> t/subroutines

[09:46] <autrijus> or t/syntax, pick one

[09:46] <luqui> cd pick glob 't/{subroutines,syntax}'

[09:47] <jql> ?eval <subroutines syntax>.pick

[09:47] <evalbot6> 'subroutines' 

[09:47] * jql likey

[09:47] <autrijus> lol

[09:48] <autrijus> luqui: I don't think I have tuits to rewrite the doExtract in Parser right now... I'd appreciate if you can p6l this whole summary

[09:48] <autrijus> (preferably with tests)

[09:48] <jql> we should use ?eval for all design decisions

[09:48] <autrijus> then I'll put it to code

[09:49] <jql> ?eval <./method $?SELF.method>.pick

[09:49] <luqui> autrijus, okay

[09:49] <evalbot6> '$?SELF.method' 

[09:49] <jql> stupid bot. lets not

[09:49] <luqui> btw, I notice that BEGIN finally works.  pugs++

[09:49] <autrijus> :)

[09:49] <autrijus> along with "use" and imports etc.

[09:49] <luqui> right

[09:50] <Darren_Duncan> I committed LKT again

[09:50] <Darren_Duncan> one of the main test files now runs

[09:50] <Darren_Duncan> the remaining two main files still short-circuit-exit

[09:50] <Darren_Duncan> thanks to Autrijus for all the Pugs updates that got it this far

[09:51] <autrijus> no prob :)

[09:51] <autrijus> I look forward in getting it all pass.

[09:51] <Darren_Duncan> one of the main issues left is in regards to how empty array arguments are handled

[09:51] <autrijus> hm?

[09:52] <jql> what?

[09:52] <Darren_Duncan> try removing the 'exit' in t/lkt_20_trnprops.t and see what happens

[09:52] <Darren_Duncan> essentially, making a new Translator object with two empty array arguments should be valid, but the function returns undef as on bad input

[09:53] <Darren_Duncan> this is probably simple and I'll look at it tomorrow

[09:53] <Darren_Duncan> but today's progress was very significant

[09:53] <luqui> dies_ok is the !eval test?

[09:53] <autrijus> luqui: something like that, yeah

[09:53] <autrijus> Darren_Duncan: cool. thanks!

[09:53] <luqui> well I knew it was something like that :-)

[09:53] <Darren_Duncan> the code doesn't die; it just returns the wrong output

[09:54] <Darren_Duncan> then it dies afterwards when trying to call a method on undef

[09:54] <autrijus> luqui: rtf[ms] -- it's try{} and making sure there's $!

[09:55] <luqui> right, I was just going for the "quick answer" approach

[09:55] <svnbot6> r4162, Darren_Duncan++ | Locale-KeyedText update, following some Pugs improvements by Autrijus - SUPER::new now works, so uncommented and fixed; commented out some tests, but most of 10_msgprops work now; other minor bits

[09:55] <luqui> ~ "at the expense of others' time"

[09:56] <Darren_Duncan> ain't that the way the world works

[09:56] <Darren_Duncan> its now 3am and I'm off to bed ... good night

[09:57] <autrijus> :)

[09:57] <autrijus> I need to sleep too.

[09:57] <autrijus> it's 6pm and I think it's 21st hour of my uptime

[09:57] <luqui> ouch

[09:57] <autrijus> (not that unusual.)

[09:57] <autrijus> (but still.)

[09:57] <luqui> (ikwym.)

[09:58] <Darren_Duncan> you're longer than me ... it's just my 19th hour or so

[09:59] <luqui> neaheheheheheh, you just said "you're longer than me"

[09:59] <luqui> (sry.  too much family guy)

[09:59] <Darren_Duncan> that's right, laugh it up

[09:59] <Darren_Duncan> that show is half good and half crass

[10:00] <luqui> yeah.  it's my favorite for the good part

[10:00] <luqui> I put up with the crass

[10:01] <luqui> (sometimes that's the mood I'm in)

[10:01] <Darren_Duncan> and we're out in 3...2...1

[10:05] <autrijus> :) *wave* &

[10:09] <Juerd> Bye

[10:09] <Juerd> And hi

[10:10] <luqui> hi

[10:12] * knewt ponders the terms "Hard Ref" and "Symbolic/Soft Ref"

[10:12] <luqui> hmmm... unixly delicious

[10:28] <svnbot6> r4163, luqui++ | Add implicit parameters test.

[11:01] <IshaCocoa_> pastebot

[11:06] <clkao> summon autrijus

[11:07] <castaway> he just went to bed after 21 hours up, poor guy

[11:07] * castaway turns off the summoner

[11:07] <Juerd> You turned off clkao! You bastard :)

[11:07] <clkao> i know, but he only needs 5 min sleep

[11:08] <clkao> i know him very well :)

[11:08] <Juerd> Yay - feather is up 4 days already

[11:08] <castaway> grats Juerd :)

[11:08] <Juerd> TBH, I expected it to face huge loads and crash within the first 3 days

[11:08] <Juerd> So this is positive :)

[11:09] <Juerd> If you want an account, let me know by mail :)

[11:09] <scook0> ? our $autrijus; $autrijus.does(::Sleep)

[11:09] <Juerd> There's still moments that it idles.

[11:09] <castaway> email where to? :)

[11:09] <Juerd> [email@hidden.address]
[11:10] <Juerd> top - 13:10:06 up 4 days, 18:12,  4 users,  load average: 0.13, 0.09, 0.03

[11:10] <Juerd> Tasks:  89 total,   1 running,  86 sleeping,   2 stopped,   0 zombie

[11:10] <Juerd> Cpu(s):  0.0% us,  0.0% sy,  0.0% ni, 100.0% id,  0.0% wa,  0.0% hi,  0.0% si

[11:10] <Juerd> Mem:   1031736k total,   581024k used,   450712k free,   167708k buffers

[11:10] <Juerd> Swap:   987896k total,    23204k used,   964692k free,   275716k cached

[11:10] * castaway makes a note :)

[11:10] <clkao> Juerd: i want too, should i send ssh key to you or ?

[11:10] <Juerd> clkao: send me a request for an account by email

[11:10] <Juerd> clkao: Attach your ssh key if you want

[11:10] <Juerd> Otherwise you will be given a temporary password

[11:11] <scook0> ?eval our $autrijus; $autrijus.does(::Sleep)

[11:11] <evalbot6> bool::false 

[11:11] <clkao> sent

[11:12] <Juerd> Do you want your nick as username?

[11:13] <Juerd> clkao: ping

[11:13] <Juerd> I'll just assume so

[11:13] <Juerd> Given your mail address :)

[11:15] <Juerd> You should be able to log in now

[11:19] <clkao> j	:)Juerd: [email@hidden.address]
[11:19] <Juerd> ?

[11:19] <Juerd> ^kj^I:)?

[11:21] <castaway> cat on keyboard? ,)

[11:23] <Juerd> aww

[11:23] <Juerd> Who poked your eye out?

[11:24] <castaway> various daft chat programs :)

[11:26] <rgs> shouldn't "make distclean" wipe out src/Config.hs et alii ?

[11:28] <rgs> or, there are old leftover files in my working copy

[11:47] <svnbot6> r4164, scook0++ | Non-toplevel type declarations

[11:48] <clkao> whoot, i feel feather is local to me

[11:48] <clkao> so fast

[11:49] <wolverian> hmm. why do I have emails about pugs from OSSF in my inbox? I can't even read it, whatever language it is!

[12:00] <clkao> grr, can't compile perl5 on feather. some crypt_r crap

[12:01] <rgs> tales from the crypt_r

[12:01] <clkao> rgs should know it well. what should we do?

[12:02] <rgs> it's freebsd ?

[12:02] <clkao> feather is .. debian i think

[12:03] <rgs> what Configure line do you give to perl 5 ?

[12:03] <clkao> wait a sec, why is ~autrijus/.svk/local 666.. and people are not in a same group?

[12:03] <clkao> i don't know. Juerd?

[12:03] <clkao> i think it's the -D_GNU_SOURCE from google.

[12:04] <clkao>   Compile-time options: MULTIPLICITY USE_ITHREADS USE_LARGE_FILES PERL_IMPLICIT_CONTEXT

[12:05] <rgs> you're not helping very much

[12:05] <clkao> Juerd: how was the perl5 compiled on feather? or installed from apt?

[12:05] <svnbot6> r4165, rgs++ | * Add missing files to be cleaned up by the realclean target

[12:09] <wolverian> perl is installed on feather from apt according to /var/lib/dpkg/status

[12:14] * castaway suspects its apt

[12:14] <broquaint> Are import methods now required? - pugs: *** No compatible subroutine found: "&Stream::import"

[12:15] <luqui> no

[12:15] <luqui> must be a bug

[12:16] <broquaint> Darn.

[12:16] <luqui> I'm trying to track it down

[12:16] <broquaint> Aha: use module <<stuff to import>>; # triggers the import call

[12:17] <broquaint> But without an import list there's no import() call.

[12:17] <luqui> hmm, that's wrong

[12:17] <luqui> use works just like perl 5's.

[12:17] <luqui> or should, rather

[12:18] <broquaint> Are empty parens still required to explicitly not call import?

[12:18] <luqui> yeah

[12:19] <luqui> well, maybe.  we might turn it into an adverb

[12:19] <luqui> use Foo :noimport;

[12:19] <luqui> but for now, just like perl 5.

[12:20] <broquaint> Alrighty.

[12:20] <castaway> broquaint!

[12:20] <broquaint> castaway!

[12:21] <castaway> allo there, got a job yet?

[12:21] <luqui> does anybody know what 'Just' does?

[12:21] <broquaint> #haskell might know ;)

[12:22] <luqui> good point

[12:22] <broquaint> 'lo, c :) Someone figured to employ me, finally! And yourself?

[12:22] <castaway> cool.. 

[12:22] <castaway> waiting for an answer from Sophos

[12:23] <castaway> was looking at places to rent and so on.. doesnt look all that rosy/fun tho :(

[12:23] <broquaint> Darn, now that import() is required subs aren't automagically stuck into the default mainspace. Can exporting be done with perl6 yet?

[12:23] <castaway> where did you get one?

[12:23] <broquaint> Multimap.com

[12:24] <broquaint> So it's a life of cartography for me! Not quite the high seas, but near enough.

[12:24] <castaway> cool

[12:37] <broquaint> What caller information can be obtained presently?

[12:38] <broquaint> Is it just file, line num, sub name?

[12:43] * castaway know nuthin :)

[12:47] <broquaint> It also appears if you use() a module it trys to call $Modulename.import, even if there is no package pertaining to $Modulename in the module. This makes things tricksy.

[12:52] <Juerd> clkao: apt

[12:59] <broquaint> pugsbug: perl -Mfoo=:stuff -e 1 # doesn't exit. looks like a bug in -M not use()

[13:08] <nothingmuch> autrijus: ping

[13:10] <SamB> !karma dons

[13:10] * SamB wonders what all the "++"s are for

[13:11] <castaway> karma castaway

[13:11] <jabbot> castaway: castaway has karma of 11

[13:11] <clkao> karma samb

[13:11] <jabbot> clkao: samb has neutral karma

[13:11] <castaway> (that)

[13:12] <clkao> karma SamB

[13:12] <jabbot> clkao: SamB has karma of 12

[13:12] <SamB> why is it case sensitive?

[13:12] <castaway> cos its perl? :)

[13:12] <nothingmuch> perlbot karma samb

[13:12] <nothingmuch> perlbot karma SamB

[13:12] <SamB> karma dons

[13:12] <jabbot> SamB: dons has karma of 3

[13:13] <nothingmuch> darn

[13:13] <Juerd> Its case sensitivity makes no sense on irce.

[13:13] <Juerd> irc.

[13:13] <nothingmuch> pugs takes forever and a day to load Class::Events

[13:14] <nothingmuch> gugod: please make jabbot's karma reporting case insensitive

[13:14] <nothingmuch> see? problem solved.

[13:14] <SamB> of course, it would have to use a special concept of case insensitivity for IRC...

[13:14] <SamB> iirc, some brackets are considered to be upper and lower case versions of the same thing...

[13:32] <nothingmuch> does anyone know a bit about parrot's MMD?

[13:32] <castaway> multi media display?

[13:32] <SamB> multi-method, probably

[13:33] <SamB> I think it means, paradoxically, dispatch over multiple method arguments...

[13:37] <theorbtw1> G'morning, lambdacamels.

[13:38] <scook0> ahoy

[13:41] *** theorbtw1 is now known as theorbtwo

[13:46] <theorbtwo> Correct, samb.

[13:47] <nothingmuch> gotta love tom waits

[13:47] <nothingmuch> "lay your head where my heart used to be"

[13:47] <nothingmuch> =)

[13:49] <broquaint> is rw hasn't been implemented, right?

[13:49] <theorbtwo> autrijus++ # Fixed my bug.

[13:49] <theorbtwo> ?eval sub foo ($a is rw) {$a++}; my $x=1; foo($x); $x

[13:49] <evalbot6> \2 

[13:50] <theorbtwo> ?eval 42

[13:50] <evalbot6> 42 

[13:50] <theorbtwo> Odd.

[13:50] <theorbtwo> What's that \ doing there?

[13:50] * theorbtwo guesses that is rw works and evalbot6 does not, but could well be wrong.

[13:50] <broquaint> ?eval sub f($a is rw) { $a = [$a] } f 'foo';

[13:50] <evalbot6> Error: Can't modify constant item: VRef <Array> 

[13:51] <theorbtwo> broquaint: That looks correct to me.

[13:51] <broquaint> Really? Why?

[13:52] <theorbtwo> Same reason 'foo' = ['foo'] is illegal.

[13:52] <theorbtwo> ?eval 'foo' = ['foo']

[13:52] <evalbot6> Error: Can't modify constant item: VRef <Array> 

[13:52] <integral> ?eval 'foo' = 5

[13:52] <evalbot6> Error: Can't modify constant item: VInt 5 

[13:52] <theorbtwo> (The error message is wrong, though -- it should say what is being modified.)

[13:52] <integral> slightly misleading error

[13:53] <broquaint> Ah, got it.

[13:53] <broquaint> is copy works for my porpoises anyhow :)

[14:01] <IshaCocoa> Where is the pugs makefile.pl expecting to find nmake.exe? I have put copies in perl\bin, windows\system cl\bin and the pugs directory and still every makefile run (17 and counting) isists upon re-downloading it from the web?

[14:04] <svnbot6> r4166, Aankhen++ | * finally added lovingly translated, sadly crippled version of HTTP::Message.

[14:05] <theorbtwo> IshaCocoa: You should probably ask in #perl, not #perl6.

[14:06] <IshaCocoa> Noone here is building pugs?

[14:07] <theorbtwo> Well, the question does apply to pugs.

[14:08] <theorbtwo> Somewhere in your PATH.

[14:08] <theorbtwo> (Actually in the PATH variable, which leaves out some things that are effectively in the PATH.)

[14:08] <IshaCocoa> All those locations are in my path

[14:09] <theorbtwo> Hm.

[14:09] <theorbtwo> The relevant bit is inc/Module/Install/Can.pm, can_run.

[14:09] <castaway> presuambly just calling "nmake" produces useful results?

[14:10] <IshaCocoa> Castaway: Yes. Pugs built and runs (unoptimised).

[14:11] <broquaint> pugsbug: pugs -e 'sub a { f @_ } sub f { my $s = @_.shift; say $s } a q[foo],q[bar]' # *** Can't modify constant item: VUndef

[14:11] <IshaCocoa> TYping nmake works fine from anywhere. I just can;t work out where the makefile is expecting to find it?

[14:11] <broquaint> But calling a() with one arg works fine.

[14:12] <broquaint> Further simplified to: pugs -e 'sub f is export { my $s = shift @_; say $s } f q[foo], q[bar]' # *** Can't modify constant item: VUndef

[14:13] <broquaint> And the 'is export' is superfluous.

[14:13] <broquaint> So, simply: pugs -e 'sub f { shift @_ } f 1,1 ' # *** Can't modify constant item: VUndef

[14:14] <nothingmuch> ?eval sub f (*@_) { shift @_ } f 1,1

[14:14] <evalbot6> Error: Can't modify constant item: VUndef 

[14:15] <nothingmuch> that's very odd

[14:15] <IshaCocoa> theorbtwo: con.pm is the problem. It doesn't append '.exe' so never sees the executable.

[14:15] <nothingmuch> ?eval sub f (*@_) { shift @_ }; my $a = 1; my $b = 2; f $a, $b;

[14:15] <theorbtwo> Ah!

[14:15] <evalbot6> Error: Can't modify constant item: VUndef 

[14:15] <IshaCocoa> s/con/can/

[14:15] <theorbtwo> Note that most callers of the thing that gives out "Can't modify constant item" pass it an explicit undef.

[14:16] * theorbtwo ponders... do I want to fix this, or work more on the Code methods.

[14:16] <theorbtwo> IshaCocoa: patch your local version so it works, then yell at ingy when you see him.

[14:18] <theorbtwo> We can put the changes into Pugs' copy of Can.pm, but we should push them upstream.

[14:19] <theorbtwo> Actually, write your patch, and we'll give you committer access so you can check it in.

[14:19] <broquaint> I see the bug is already in t/subroutines/subroutine.t.

[14:19] <castaway> Code methods?

[14:20] <theorbtwo> castaway: say &say.affix

[14:21] <theorbtwo> Er, that's not quite right.

[14:21] <theorbtwo> ?eval &say.assoc

[14:21] <evalbot6> Error: Undeclared variable: "&say" 

[14:21] <theorbtwo> Grr, and that's new...

[14:22] <theorbtwo> It works in my local copy...

[14:22] <theorbtwo> ?eval $?PUGS_VERSION

[14:22] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[14:23] <castaway> assoc?

[14:24] <Limbic_Region> did .assoc get added in the last 9 revisions?

[14:25] * castaway guesses svn blame would know

[14:26] <theorbtwo> No, but some relevant stuff may have gotten changed around.

[14:26] <svnbot6> r4167, broquaint++ | * added argShifter test for single arg and made test output more descriptive

[14:27] <Limbic_Region> if I want to add an example using features not yet supported by Pugs, where should I put it and/or how should I label it?

[14:28] <theorbtwo> I think treat it just the same as an example that is supported, and make sure there are additional normal tests for the features it uses.

[14:28] <theorbtwo> ...and the features will probably appear shortly.

[14:29] <Limbic_Region> doubt

[14:29] <castaway> tests tests tests :)

[14:29] <Limbic_Region> err

[14:29] <Limbic_Region> I doubt it

[14:29] <Limbic_Region> I am fairly certain the majority of the features have been marked todo for some time

[14:29] <theorbtwo> Yeah, but having an example that actually uses it provides additional motivation.

[14:29] <theorbtwo> What's the feature?

[14:30] <Limbic_Region> hyper derefing, last LABEL, plus a bug or two

[14:30] <Limbic_Region> let me see if I can find any others

[14:31] <Limbic_Region> wow - when I first started writing that there were a lot more things wrong

[14:31] <Limbic_Region> guess it is just 3

[14:31] <Limbic_Region> a bug

[14:31] <Limbic_Region> and two missing features

[14:31] <Limbic_Region> all of which have tests

[14:32] <theorbtwo> OK.

[14:32] <Limbic_Region> hmmm

[14:33] <Limbic_Region> it appears the label test(s) are no longer in for.t

[14:33] <Limbic_Region> I wonder if they got moved or removed

[14:33] <Limbic_Region> nevermind

[14:33] <Limbic_Region> they are in last.t

[14:33] <Limbic_Region> my mistake

[14:35] <Limbic_Region> oh - there is another weird bug

[14:36] <Limbic_Region> but it too has a test

[14:37] <Limbic_Region> I will add comments for the 4 tests that need to be implemented/fixed before it will work

[14:37] <svnbot6> r4168, luqui++ | Implement loop {} while and loop {} until.

[14:38] <wolverian> I thought larry didn't want to implement those. :)

[14:38] <luqui> hmm?

[14:38] * theorbtwo bets luqui will shortly fix last label.

[14:38] <theorbtwo> No, that's do {} while and do {} until.

[14:38] <luqui> I probably won't

[14:38] <wolverian> right. I thought the tail weight was his argument against that, which applies to loop { } ...; similarly

[14:38] <luqui> I'm clawing for ground here

[14:39] <luqui> I'm pretty sure that's the one we decided one

[14:39] <luqui> s/e$//

[14:39] <luqui> I don't recall, it could have just been damian's idea, with larry keeping silent

[14:40] <wolverian> I don't recall loop { } while at all, on p6l anyway.

[14:41] <luqui> it might have been a sixperl thing

[14:41] <nothingmuch> define: sixperl

[14:42] <castaway> Looping statement modifiers are the same as in Perl 5, except that to avoid confusion applying one to a do block is specifically disallowed. Instead of

[14:42] <castaway>     do {

[14:42] <castaway>         ...

[14:42] <luqui> secret cabal mailing list

[14:42] <castaway>     } while $x;

[14:42] <luqui> oh no

[14:42] <castaway> you should write

[14:42] <castaway>     loop {

[14:42] <luqui> now they'll have to kill me.

[14:42] <castaway>         ...

[14:42] <castaway>     } while $x;

[14:42] <castaway> (S04)

[14:42] <svnbot6> r4169, luqui++ | Let's not be an idiot.  Run the body the first time *outside* the recursive call.

[14:43] * nothingmuch wonders why all the secrecy

[14:43] <nothingmuch> could it be a readonly list?

[14:43] <nothingmuch> i understand the need to not flood with comments

[14:43] <nothingmuch> but I do think that the cycle is slightly too long, between things starting, and getting to the public

[14:44] <theorbtwo> s/is the community's rewrite of perl/is the cabal's rewrite of perl/

[14:44] <nothingmuch> which kind of makes me feel like i'm too much of an idiot to get undigested perl6ish discussion

[14:44] <lathos> theorbtwo: "The community" can't make decisions. Somebody has to.

[14:44] <wolverian> castaway: oh, thanks. :)

[14:45] <rgs> the cabal is the community's rewrite of the community.

[14:45] <theorbtwo> lathos: Accepting for the case of argument, but that person, or those people, could use informed commentary.

[14:45] <lathos> theorbtwo: They do use informed commentary. You think they don't read p6l?

[14:46] <luqui> well, the thing is, the comments would come to p6l, which we all read

[14:46] <theorbtwo> lathos: But if most of the discussion goes on where p6l can't see it, then p6l is uninformed commentary.

[14:46] <nothingmuch> lathos: it's not about vetoing, it's about transperancy

[14:46] <lathos> You're confusing discussion and decision again.

[14:47] <rgs> most of the discussion goes on p6l

[14:47] <nothingmuch> i wouldn't mind my opinion being ignored until it's "out"

[14:47] <luqui> larry says a lot of stuff

[14:47] <luqui> and we wouldn't want people to misinterpret that

[14:47] <nothingmuch> i'd just like a preview, so i can think about things before they are up for discussion

[14:47] <luqui> but I don't really understand the need for secrecy any

[14:47] <Limbic_Region> ok - comitted

[14:48] <theorbtwo> I think people would misinterpret less if they understood how sure or unsure Larry was at the time.

[14:48] <svnbot6> r4170, Limbic_Region++ | Added cribbage_scoring.p6 example which needs 2 bugfixes and 2 features implemented before it will work

[14:48] <nothingmuch> as for comments coming up on p6l - they can be ignored till it's time

[14:48] <lathos> Ah, you just need to look in the X-Larry-Confidence headers.

[14:48] * nothingmuch goes to check if that's a joke or not

[14:48] <theorbtwo> I think part of the problem is that Larry isn't always sure how confident Larry is.

[14:49] <lathos> Right.

[14:49] <lathos> Also, Larry's confidence counts for nothing when two days later another situation comes up and everything changes. :)

[14:49] <theorbtwo> More context is almost always good at helping misunderstandings.

[14:49] <luqui> nothingmuch, you can't really ignore people's comments

[14:50] <theorbtwo> (This is why we don't name functions <a b c d e>.)

[14:50] <luqui> we've been doing pretty badly on keeping up

[14:50] <luqui> but when you stop responding, people stop caring, it seems

[14:50] <theorbtwo> luqui: It creates the impression that p6l is an echo-chamber, and the real decisions are being made elsewhere.

[14:50] <lathos> But that's true.

[14:51] <lathos> Again you're confusing discussion and decision.

[14:51] <theorbtwo> lathos: Again, you are assuming discussion doesn't happen on the cabal list, only decision.

[14:51] <nothingmuch> I would also like code to be opened. No doubt the community could help Larry's dabs at the converter

[14:51] <luqui> a lot of times larry accepts proposals that people on p6l make without telling them on p6l

[14:51] <theorbtwo> That seems to be unfounded.

[14:51] <lathos> theorbtwo: Oh. I was on it, if you remember.

[14:51] <nothingmuch> does he accept them on cabal list?

[14:51] <luqui> because if he did, people get very defensive if he decides to change his mind

[14:51] <theorbtwo> Oh.  No, I didn't remember that.

[14:52] <lathos> Some discussion happens, but not much. It's only really discussion of the effects of a decision, as it were.

[14:52] <lathos> And that happens on p6l too.

[14:52] <luqui> yeah.  the real decision making really only takes place in a certain person's head

[14:53] <IshaCocoa_> theorbtwo: Okay.  I have the patch for the nmake problem. Where do I send it?

[14:53] <luqui> list?

[14:53] <theorbtwo> perbot nopaste

[14:53] <Limbic_Region> perlbot nopaste

[14:53] <luqui> or [email@hidden.address]
[14:53] <theorbtwo> jabbot, nopaste

[14:53] <jabbot> theorbtwo: Please go on.

[14:53] <luqui> jabbot, paste

[14:53] <jabbot> luqui: Does talking about this bother you?

[14:53] <nothingmuch> sial.org/pbot

[14:53] <luqui> hmph

[14:54] <lathos> By the time we work out the URL, you could have mailed it to the list. :)

[14:54] <castaway> (its such a memorable url too)

[14:54] <nothingmuch> castaway: but it's too easy to fetch it

[14:54] <nothingmuch> it also serves as a sort of trumpet sound

[14:54] <theorbtwo> Yeah, but I'd rather it go to the nopaste, so I can take a quick look and offer IshaCocoa_ a committer bit.

[14:54] <nothingmuch> "I am going to paste something!"

[14:55] <castaway> its easy?

[14:56] <theorbtwo> It is when perlbot is here.

[14:56] <Limbic_Region> perlbot is also missing from #perl and I can't seem to find Chris62vw's email addy

[14:57] <nothingmuch> use pbotutil, it's easier once you config it

[14:57] <nothingmuch> pbpaste | pbotutil -m "a description"

[14:57] <integral> Limbic_Region: just poke him when he comes online later

[14:57] <Limbic_Region> that assumes I will be around

[14:57] <integral> oh, someone in #perl will :-)

[14:57] <Limbic_Region> *shrug*

[14:58] <nothingmuch> pbotutil -c pugs

[14:58] * luqui is a lazy bastid

[14:58] <nothingmuch> oh, you have to make add a slash at the end, i think

[14:58] <nothingmuch> http://sial.org/pbot/

[14:58] <nothingmuch> otherwise the relative action is a 4004

[14:59] <integral> and http://sial.org/pbot/perl6 will automatically paste here :-)

[14:59] <luqui> 4004?  That's like "I couldn't find it, so I shot your mother"

[15:00] <theorbtwo> 4004 -- Not Found: The Next Generation.

[15:01] <theorbtwo> These are the voyages of the starship Missing, on it's continuing mission to seek out new deaths, and new anarchy... to bodly go where many people have gone before.

[15:02] <pasteling> "IshaCocoa" at 195.92.67.70 pasted "makefile.pl:nmake not found patch to Index: inc/Module/Install/Win32.pm" (13 lines, 543B) at http://sial.org/pbot/10590

[15:05] <nothingmuch> luqui: replied... thanks

[15:05] <theorbtwo> Oh, that's not the fix I thought you were going to make... but it'll do.

[15:05] <theorbtwo> Want a committer bit?

[15:05] <luqui> nothingmuch, sortof

[15:05] <luqui> oh

[15:05] <luqui> _you_ replied

[15:05] <nothingmuch> yep

[15:05] <Limbic_Region> theorbtwo - you aren't in sales are you

[15:05] <Limbic_Region> :)

[15:06] <Limbic_Region> the appropriate way to do that is

[15:06] <nothingmuch> given just a bit more restructuring this should go into svn

[15:06] <Limbic_Region> give me your email address so I can give you the commit bit

[15:06] <theorbtwo> God no.  I hated sales.

[15:06] <Limbic_Region> ;-)

[15:06] <Limbic_Region> me too - but autrijus is quite effective at it

[15:06] <nothingmuch> i feel bad about checking in something unreadable

[15:06] * theorbtwo worked at Staples recently.

[15:06] <Limbic_Region> ed?

[15:06] <theorbtwo> Er, s/recently/shortly/

[15:07] <Limbic_Region> didn't work out?

[15:07] <Limbic_Region> oh

[15:07] <Limbic_Region> nevermind

[15:07] <Limbic_Region> gotcha

[15:08] <theorbtwo> I was told that people there thought I was pretty good.

[15:08] <theorbtwo> ...after I quit after having a small nervious breakdown.

[15:08] <IshaCocoa_> theorbtwo: Not yet a while. See if I sustain my interest:)

[15:09] <theorbtwo> IshaCocoa_: Giving you a comitter bit costs us nothing, and is a good way to sustain your interest.

[15:09] <theorbtwo> I managed to work there by completely supressing myself during working hours as much as I could.

[15:10] <theorbtwo> This managed to make me calm and plesant during work hours, and make me have shakes before and after.

[15:11] <theorbtwo> Also, I constantly felt like my work was crap -- my repairs kept not working right, because I rushed through them.

[15:11] <theorbtwo> I couldn't bring myself to sell people stuff that they had no real need for.

[15:13] <luqui> It's like trying to convince your friend that java is a good language because your boss told you to

[15:13] <Limbic_Region> I was in telemarketing (credit card sales) for 2 weeks and 3 days

[15:13] <Limbic_Region> 2 weeks was training

[15:13] <theorbtwo> Also, I could never find anything in that damn store.

[15:14] <Limbic_Region> I had one of the top sales ratings in my group - but my ratio of calls/sales was abysmal

[15:14] <theorbtwo> Customer: "I want one of those".  Me: "OK, let me find it."  Me, 20 minutes later: "We're out of that, sorry."

[15:14] <Limbic_Region> If someone indicated they weren't interested I would hang up right away and go on to the next call

[15:14] <Limbic_Region> I figured people who wanted it would take less time

[15:14] <theorbtwo> (Even though the computer says we have 10... damn if I know where.)

[15:14] <Limbic_Region> my superiors didn't like this approach

[15:15] <castaway> the computer should say where..

[15:15] <theorbtwo> Limbic_Region: It's a matter of how much less time vs how many people actually want it.

[15:15] <theorbtwo> Yes, I agree.  It should.

[15:15] <theorbtwo> Sadly, I was their computer repair and a computer sales guy.

[15:15] <theorbtwo> Fixing their computer systems to actually do something useful was rather outside the scope of my job.

[15:16] <castaway> Staples is a chain, no?

[15:16] <svnbot6> r4171, luqui++ | Update loop tests.

[15:16] <theorbtwo> Yes.  A quite large one.

[15:16] <castaway> one would think they'd centralise such

[15:17] <theorbtwo> I worked at stapes #138.

[15:17] <theorbtwo> Yes, castaway, they did.

[15:18] <theorbtwo> There are presently 1,695 stapes stores in four countries.

[15:19] <theorbtwo> Including three in Munich.

[15:19] <theorbtwo> http://www.staples.de/DEU/StoreLocator/store_locator.asp?ID=03

[15:20] <theorbtwo> </stapesad>

[15:21] <theorbtwo> Blasted stupid build system.

[15:21] <svnbot6> r4172, jhorwitz++ | * compile methods w/ no arguments

[15:21] <theorbtwo> Modifing src/Pugs/Types/Scalar.hs and doing make unoptimized thinks that nothing has changed.

[15:23] <luqui> weird

[15:23] <theorbtwo> It's because we #include it into src/Pugs/Types.hs.

[15:23] <castaway> rm its .o?

[15:24] <luqui> you mean instead of importing it?

[15:26] <Khisanth> hmm

[15:26] <Khisanth> that pthread.so problem is gone

[15:29] <eric256> i looks like we need a person dedicated to the dailiy updates, autrijus seems a little overloaded lately...or i just got in on the week where he managed to do it all the time so i'm spoiled. lol

[15:31] <luqui> daily updates?

[15:31] <lathos> autrijus' journal

[15:31] <luqui> ah yes

[15:34] <nothingmuch> lambda the ultimate has a link to a very nice talk about a languge called Slate which does MMD + prototyped OO

[15:39] <wolverian> these guadec videos are _very_ interesting.

[15:39] <nothingmuch> wolverian: link?

[15:39] * luqui beds &

[15:40] <wolverian> nothingmuch: http://stream.fluendo.com/archive/

[15:40] <wolverian> nothingmuch: especially jeff waugh's project topaz (gnome 3.0) speech is illuminating

[15:40] <nothingmuch> how many topaz projects are out there?

[15:41] <wolverian> (basically: we're too conservative, we don't concentrate on features, so we're changing things, aiming for 10% global desktop marketshare and we're doing it in these ways...)

[15:43] <nothingmuch> from which conf are those?

[15:43] <wolverian> 6uadec kรถnig

[15:44] <wolverian> this was.. today, I think

[15:51] * eric256 still wishes method dispatch on class type worked.

[15:52] <theorbtwo> eric256: Not sure what you mean by that.

[15:52] <eric256> when you overload operators they don't dispatch correctly

[15:53] <eric256> multi sub *infix:<+> (Range $range, Int $inc) {  is getting called for all addition, not just addition between a range and an Int

[15:54] <theorbtwo> Odd.

[15:54] <theorbtwo> It seems to work OK for Set.

[15:54] <eric256> realy?

[15:54] <theorbtwo> ?eval (1..2).ref

[15:54] <evalbot6> ::List 

[15:55] <theorbtwo> That'd be why.

[15:55] <eric256> what?

[15:55] <theorbtwo> Oh, also, I think Set declares theirs somewhat differently.

[15:55] <theorbtwo> It's not a Range, it's just a List.

[15:55] <theorbtwo> Unless you didn't mean 1..2 when you said Range.

[15:56] <theorbtwo> BTW: Leaving off the parens on that ?eval makes my local pugs hang, or at least take a long time.

[15:56] <eric256> Range is a class i have defined

[15:56] <theorbtwo> Oh, OK.

[15:56] <theorbtwo> Check how Set does it?

[15:56] <eric256> odd Set definitly looks like it works.

[15:56] <eric256> yea i'll try it there way

[15:57] <eric256> hey thats a step in the right direction, but i think that must have gotten fixed just recently

[15:58] <theorbtwo> I seem to recall it did.

[15:58] <theorbtwo> Rather, that the changes to make is export work broke Set, then autrijus fixed it.

[16:01] <eric256> i spoke too soon. that doesn't work still. hmmm

[16:03] <eric256> i put warn "infix called on {$range.ref} and {$inc.ref}";

[16:04] <eric256> inside that infix + declaration and it produces

[16:04] <eric256> *** infix called on Num and Int

[16:04] <eric256> and

[16:04] <eric256> *** infix called on Scalar and Int

[16:04] <eric256> which obviously don't match the signature...that seems odd

[16:07] <theorbtwo> Yes, it seems very odd.

[16:08] <eric256> pasteling nopaste

[16:08] <eric256> how do you wake that thing up?

[16:32] <gaal> eric256, http://sial.org/pbot/perl6

[17:04] <svnbot6> r4173, theorbtwo++ | Fix the error for 42 = "a" to point out that the 42 is read-only, not what

[17:04] <svnbot6> r4173, theorbtwo++ | is being assigned to it.

[17:10] <ninereasons> ?eval  my %hash = zip 'c'..'f',3..6; %hash<d f>

[17:10] <evalbot6> [4, 6] 

[17:19] <broquaint> How do I get this to work?

[17:19] <broquaint> ?eval sub f($a,$b,$c) { say "$a,$b,$c" } my @a = 1 .. 3;

[17:19] <evalbot6> [1, 2, 3] 

[17:19] <broquaint> Hrm ...

[17:19] <broquaint> I get: *** No compatible subroutine found: "&f"

[17:19] <broquaint> ?eval sub f($a,$b,$c) { say "$a,$b,$c" } my @a = 1 .. 3; f *@a; #even

[17:19] <evalbot6> Error: No compatible subroutine found: "&f" 

[17:20] <Juerd> And if you do f(1,2,3)?

[17:20] <broquaint> ?eval sub f($a,$b,$c) { say "$a,$b,$c" } my @a = 1 .. 3; f(1,2,3); # probably works

[17:20] <evalbot6> Error: No compatible subroutine found: "&say" 

[17:20] <broquaint> Weird.

[17:21] <Juerd> say broken?

[17:21] <ninereasons> all IO broken, for evalbot6

[17:21] <broquaint> ?eval sub f(*$a,*$b,$c) { say "$a,$b,$c" } my @a = 1 .. 3; f @a; # this works :/

[17:21] <evalbot6> Error: No compatible subroutine found: "&say" 

[17:22] <broquaint> ?eval sub f(*$a,*$b,$c) { "$a,$b,$c" } my @a = 1 .. 3; f @a; # this works :/

[17:22] <evalbot6> '1,2,3' 

[17:25] <broquaint> Wah, pugs: cannot cast from VRule ... # no line number :/

[17:40] <broquaint> Is there a way to stringify rules?

[18:05] <putter> I just svn up'ed for the day, and yesterday's work stopped working.  (so an unknown pugs of yesterday morn or perhaps the day before).  specifically...

[18:06] <broquaint> Working with modules, putter?

[18:06] <putter> in a sub with some internal my subs, the first mysub called is now Undeclared variable: "&tree_id".

[18:06] <putter> broquaint: no modules,

[18:07] <putter> just sub { my sub f {...} my sub g { f } g; }  # conceptually

[18:11] <theorbtwo> broquaint: Know way that I know of to stringify a rule usefully... but it should be possible to do it uselessly without getting an internal error.

[18:12] <broquaint> Hrm, fiddly. Can a perl5 regex be used in rules?

[18:12] <theorbtwo> I doubt it.

[18:13] <theorbtwo> p5 regexes and p6 regexes, at least as currently written, are very different things.

[18:13] <broquaint> Darn. It also means perl5 regexes can't be used in perl5 regexes either :/

[18:13] <putter> hmm... pugs> sub f() { my sub g(){say "g"} my sub h(){g()} h()}

[18:13] <putter> Undeclared variable: "&g"

[18:16] <putter> any miraculous bug report for fix trades? ;) 

[18:20] <eric256> my sub?  that is weird syntax

[18:20] <eric256> why not just sub?

[18:20] <theorbtwo> eric256: Scope.

[18:20] <eric256> shouldn't the enclosing { } be enough for scope?

[18:21] <eric256> hmmm on testing apparently not. odd.  that seems counter intuitive

[18:22] <theorbtwo> eric256: normal subs scope the same way they did in p5: sub foo {} is visable everywhere.

[18:23] <eric256> didn't know that about p5.

[18:24] <theorbtwo> OTOH, there was no way to get a lexically-scoped sub in p5.  (Though you could fake it with a lexically scoped reference to a sub.)

[18:26] * putter cries "dooh!".  can live without mysub for today.  easier than regressing pugs.  eric256++

[18:26] * putter goes back to trying to bootstrap p6 rules on pcre...

[18:34] <nothingmuch> heya

[18:34] <nothingmuch> seen autrijus 

[18:34] <jabbot> nothingmuch: autrijus was seen 8 hours 28 minutes 59 seconds ago

[18:35] <nothingmuch> wakey time

[18:42] <putter> fyi, re the "my sub" regression, it works in r4070.

[18:49] <svnbot6> r4174, nothingmuch++ | New multimethod proposal, version 0.0.(1/2)

[18:50] <eric256> it would be interesting to make something that automaticaly built every revision number and listed all tests that started or stopped working for that version. ;)

[18:50] <nothingmuch> eric256: you can autogenerate YAMLs, and then diff the structure

[18:50] <eric256> YAMLS?

[18:50] <nothingmuch> i think rootmj did diffs for a while

[18:51] <nothingmuch> see util/smoke_loop.sh, util/yaml_harness.pl, make smoke

[19:00] <theorbtwo> The only problem with doing that is that when tests get moved around, you'll get non-useful output.

[19:03] <theorbtwo> It could work well if you figure tests by file, name tupple, and there aren't too many tests with the same name (including no name).

[19:06] <putter> or just treat file (dis)appearance separately.  one can also use "is their diff bigger than the file" to test new/old file approximate eqness.

[19:06] <theorbtwo> The problem is more test (dis)appearance.

[19:07] <theorbtwo> Adding a test in the middle of a file, in purticular

[19:10] <putter> ahh.  well, all are tests are commented aren't they... ;)

[19:14] <theorbtwo> Make a test yaml and find out.

[19:17] <putter> ok, I'm being blocked by the "hashes magically disolve in singleton arrays" bug.   what is the state of objects this afternoon?  anyone not/having problems?

[19:17] <theorbtwo> nothingmuch: It looks like a good plan to me.

[19:17] <eric256> some how my 17month old daughter knows exactly which button on the keyboard to hit to put the comptuer to sleep

[19:18] <nothingmuch> woah

[19:18] <nothingmuch> i think you need to spend more time in the lawn with her

[19:18] <putter> eric256: :)

[19:19] <eric256> its not even a button i ever use.  hehe lawn? not until we move and can finaly get a house! ;)

[19:20] <nothingmuch> good luck with it

[19:20] * putter clarifies -  I could switch from hashes and arrays to objects and arrays.  but if oo is unstable after the recent changes, then I'll punt...

[19:20] <nothingmuch> and i hope it's not too late for her to appreciate sun light ;-)

[19:25] <eric256> sun light? what's that?  BTW her mother is 3/4 japanese so she basicaly gets tan just walking outside for a minute....while i burn in about half that time. lol

[19:27] <nothingmuch> heh

[19:27] * nothingmuch has an amazing tanning spectrum

[19:27] <nothingmuch> dad is iraqi, mom is austrian

[19:27] <nothingmuch> i can be very dark, or very light, depending on how much time i spend outside

[19:28] <eric256> while I on the other hand can be very white or very soar depending on how much time i spend outside. lol

[19:31] * theorbtwo generally doesn't pay much attention to his own skin tone.

[19:35] * nothingmuch is thinking too much lately

[19:37] <eric256> is there a way to catch the output of system commands yet?

[19:44] <gaal> eric, yes, but not standard

[19:45] <gaal> option 1:

[19:45] <gaal> set @INC to src/perl6 and load Prelude, then use openpipe

[19:45] <gaal> this is simple and safe, but isn't finalized yet

[19:45] <gaal> option 2:

[19:46] <gaal> use the underliying Pugs::Internals::runInteractiveCommand

[19:47] <gaal> it returns a list with four values. 3 handles for stdin of the run command, stdout, stderr; and a Process handle which should be a pid on unix.

[19:48] <gaal> option 2 is faster but will certainly change. option 1 is currently a little slow, but the interface is a little less likely to change. (you will not need to say use Prelude in the future)

[19:48] <gaal> oh, actually the function will be renamed to Pipe.open once namespaces are fixed. (t/pugsbugs/namespace.t)

[19:49] <eric256> cool

[19:54] <nothingmuch> feh, yet another p6l post

[19:54] <nothingmuch> i think this will be around the 8th message warnocked in a row

[20:13] <putter> nothingmuch: on the upside, 8 are harder to overlook than 1... ;)

[20:13] <nothingmuch> i'm hoping they are dealt with at some point

[20:18] <broquaint> Is this a genuine parse error or a parse bug? if ($a,$b) = func() { ... }

[20:22] <broquaint> ?eval if ($a,$b) = func() { ... }

[20:22] <evalbot6> Error:  unexpected "i" expecting program reserved word 

[20:32] <eric256> ?eval if (($a,$b) = func() ) { ... }

[20:32] <evalbot6> Error: Undeclared variable: "$a" 

[20:35] <Aankhen``> ?eval my ($a, $b); if ($a, $b) = list(1, 2, 3) { "Y" }

[20:35] <evalbot6> Error:  unexpected "i" expecting ";" or end of input 

[20:35] <Aankhen``> ?eval $?PUGS_VERSION

[20:35] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.5, May 24, 2005 (r4158)' 

[20:35] <Aankhen``> Still r4158?

[20:36] <broquaint> Same behaviour on the latest build.

[20:36] <broquaint> It'd be very handy to have a pugs debugger now, I seem to have an infinite loop somewhere. I think.

[20:37] <Aankhen``> G'night.

[20:43] <vcv--> ?eval 'a'~'b'

[20:43] <evalbot6> 'ab' 

[20:43] <vcv--> neato

[20:45] <eric256> ?eval [~] ('a' ... 'z')

[20:45] <evalbot6> Error:  unexpected "(" expecting block construct, operator, ")", ":", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[20:46] <eric256> ?eval my @a = ('a' ... 'z'); [~] @a;

[20:46] <evalbot6> Error:  unexpected "'" expecting operator or ")" 

[20:46] <eric256> hmm. odd

[20:46] <eric256> ?eval my @a = (1 ... 10); [~] @a;

[20:46] <evalbot6> Error:  unexpected "1" expecting operator or ")" 

[20:46] <eric256> ?eval my @a = (1...10); [~] @a;

[20:46] <evalbot6> Error:  unexpected "1" expecting operator or ")" 

[20:46] <eric256> ?eval my @a = (1..10); [~] @a;

[20:46] <evalbot6> '12345678910' 

[20:46] <eric256> that seemed odd.  parse errors?

[20:47] <eric256> ?eval my @a = ('a'..'z'); [~] @a;

[20:47] <evalbot6> 'abcdefghijklmnopqrstuvwxyz' 

[20:48] <eric256> there we go ! ;).  it is getting a bit picky about spacing

[21:13] <nothingmuch> blah

[21:15] <vcv--> ?eval my @a = ('a'..'z'); @a >>~<< ',';

[21:15] <evalbot6> ('a,', 'b,', 'c,', 'd,', 'e,', 'f,', 'g,', 'h,', 'i,', 'j,', 'k,', 'l,', 'm,', 'n,', 'o,', 'p,', 'q,', 'r,', 's,', 't,', 'u,', 'v,', 'w,', 'x,', 'y,', 'z,') 

[21:20] <eric256> nice

[21:20] <eric256> a join operator ;)

[21:21] <vcv--> ?eval my @a = ('a'..'z'); *(@a >>~<< ',');

[21:21] <evalbot6> ('a,', 'b,', 'c,', 'd,', 'e,', 'f,', 'g,', 'h,', 'i,', 'j,', 'k,', 'l,', 'm,', 'n,', 'o,', 'p,', 'q,', 'r,', 's,', 't,', 'u,', 'v,', 'w,', 'x,', 'y,', 'z,') 

[21:21] <vcv--> darn

[21:21] <vcv--> one last one

[21:21] <vcv--> ?eval my @a = ('a'..'z'); [~] (@a >>~<< ',');

[21:21] <evalbot6> 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,' 

[21:21] <pasteling> "nothingmuch" at 212.143.91.217 pasted "warnocking =(" (12 lines, 475B) at http://sial.org/pbot/10595

[21:22] <nothingmuch> ?eval sub join (*@strings

[21:22] <evalbot6> Error:  unexpected end of input expecting word character, trait, ",", ":" or ")" 

[21:23] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@a Y ',') }; join(",", 'a'..'z')

[21:23] <evalbot6> Error: Undeclared variable: "@a" 

[21:23] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@strings Y $string) }; join(",", 'a'..'z')

[21:23] <evalbot6> Error: Undeclared variable: "$string" 

[21:23] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@strings Y $sep) }; join(",", 'a'..'z')

[21:23] <evalbot6> 'a,bcdefghijklmnopqrstuvwxyz' 

[21:23] <nothingmuch> ?eval sub join ($sep, *@strings) { [~]@strings Y ($string xx +@strings) }; join(",", 'a'..'z')

[21:23] <evalbot6> Error: Undeclared variable: "$string" 

[21:24] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] @strings Y ($sep xx +@strings) }; join(",", 'a'..'z')

[21:24] <evalbot6> ('abcdefghijklmnopqrstuvwxyz', ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',', undef, ',') 

[21:24] <nothingmuch> damnit

[21:24] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@strings Y ($sep xx +@strings)) }; join(",", 'a'..'z')

[21:24] <evalbot6> 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,' 

[21:24] <lathos> Urgh.

[21:25] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@strings Y ($sep xx +@strings - 1)) }; join(",", 'a'..'z')

[21:25] <evalbot6> 'a25bcdefghijklmnopqrstuvwxyz' 

[21:25] <nothingmuch> there we go.

[21:25] <nothingmuch> haha

[21:25] <nothingmuch> i think that's a bug

[21:25] <nothingmuch> ?eval sub join ($sep, *@strings) { [~] (@strings Y ($sep xx (+@strings - 1))) }; join(",", 'a'..'z')

[21:25] <evalbot6> 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z' 

[21:26] <vcv--> Hm, maybe #pugseval is in order ;)

[21:26] <nothingmuch> =)

[21:27] <nothingmuch> evalbot6: ?eval command is only available in public channels

[21:27] <nothingmuch> maybe that fix is better?

[21:28] <vcv--> Yeah, that too :p

[21:29] <nothingmuch> i like defining builtin ops

[21:30] <eric256> yea. it would seem if they are all implemented in perl then the docs could include the actual definition of it which would help people understand them better. ;)

[21:30] <nothingmuch> sub infix:<*> ($x, $y) { [+] $x xx $y };

[21:30] <nothingmuch> not only that

[21:30] <nothingmuch> if all the ops are defined in terms of each other

[21:30] <nothingmuch> as fallbacks

[21:30] <nothingmuch> we can autogenerate roles, by letting the role supply only one of them

[21:30] <nothingmuch> and figuring out the rest

[21:30] <nothingmuch> especially for math stuff

[21:31] <vcv--> sub infix:<*> ($x, $y) { [+] $x xx $y }; <--is that really a good idea??

[21:31] <nothingmuch> ordinality stuff

[21:31] <eric256> later

[21:31] <vcv--> so there will be a heavy dependency between the built-in ops

[21:31] <nothingmuch> vcv-- i doubt it, but what does it matter? it's nice mental masturbation

[21:31] <nothingmuch> vcv--: no, the builtin ones will be implemented in PIR, or even machine code

[21:31] <vcv--> Yes it is.

[21:34] <lathos> Also, that screws up overloading.

[21:34] <nothingmuch> lathos: how?

[21:34] <lathos> Well, if you're expecting a * method to be called and you get lots of + methods instead, you're not going to be doing the right thing.

[21:35] <vcv--> Hm.  So there is no op for join is there?

[21:35] <nothingmuch> if it's really *, then isn't it just a bunch of +?

[21:35] <nothingmuch> in theory

[21:36] <nothingmuch> or rather, when it's pure

[21:36] <nothingmuch> if it isn't it's your responsibility to do your own *

[21:36] <nothingmuch> personally I'm not sure that generic impls are really good in practice

[21:37] <nothingmuch> since they are basically junk

[21:37] <nothingmuch> but I don't think that overloading is the reason

[21:37] <nothingmuch> anybody got an opinion on mmd.kwid?

[21:51] <nothingmuch> perlbot seen autrijus

[21:51] <svnbot6> r4175, putter++ | Added pugsbugs/lexical_subs.t, showing recent "my sub" regression.

[21:51] <nothingmuch> seen autrijus

[21:51] <jabbot> nothingmuch: autrijus was seen 11 hours 45 minutes 28 seconds ago

[21:51] <nothingmuch> sleepy head

[21:56] <svnbot6> r4176, putter++ | Minor improvement / typo correction.

[22:11] <svnbot6> r4177, putter++ | Added pugsbugs/rx_perl5_match.t.  An unmatched capture returns true.

[22:27] <svnbot6> r4178, putter++ | Added failing tests to mixed_multi_dimensional.t, showing hash references being decomposed in singleton arrays.

[22:29] *** Limbic_Region_ is now known as Limbic_Region

[22:46] *** broquaint_ is now known as broquaint

[23:03] <putter> This is a bug, yes?   pugs> my $u; $u.elems

[23:03] <putter> 1

[23:03] <jql> aww crap

[23:03] <Khisanth> I think that is a yes

[23:05] <putter> I'll add a test to undef.t.

[23:05] <putter> Thanks for your help.

[23:06] <jql> pugs> my @u; [\@u].elems

[23:06] <jql> 0

[23:06] * jql frowns

[23:07] <jql> ?eval 1

[23:07] <evalbot6> 1 

[23:07] <jql> ?eval my @x; [\@x].elems

[23:07] <evalbot6> 0 

[23:07] <putter> jql: I noticed something similar with hashrefs earlier.

[23:08] <jql> yeah, we were chatting about it last night too

[23:08] <putter> ?eval my @x = (4,5,6); [\@x].elems

[23:08] <evalbot6> 3 

[23:08] <jql> the auto-flattening issue still needs working out. lotsa tests

[23:09] <Khisanth> hrm why are they autovivifying like that?

[23:09] <jql> ?eval my @x; [*@x].elems

[23:09] <evalbot6> 0 

[23:09] <jql> ?eval my @x = (1,2,3); [*@x].elems

[23:09] <evalbot6> 3 

[23:10] <putter> I wonder if it would help to have a TESTS_WANTED file, listing places where testing is known to be weak.

[23:11] <putter> Folks simply interested in writing tests would then not need to first, explore the test tree, recognize and confirm test gaps, and decide where to put them.  Simply "add tests of foo to file bar".

[23:12] <jql> "add tests of list/hash flattening behaviou?r to t/?"

[23:14] <putter> or perhaps even better, add tests of l/h fb (pointer to documentation of same) to t/specific_file.  basically separating the work requiring a big picture grasp from the groveling.

[23:14] <jql> I see your point

[23:15] <putter> could develop a test community analygous to current dev community... trade one paragraph description of desired tests for test file. ;)

[23:26] <Darren_Duncan> regarding the "my $u; $u.elems" returning 1, what did you expect to happen?

[23:27] <Darren_Duncan> a scalar is always 1 in size, I think

[23:27] <Darren_Duncan> whereas a list or array or hash can be zero or up

[23:29] <jql> I'm not so concerned about that. I could learn to accept it if it's declared Correct. It's pugs> my @u; [\@u].elems

[23:29] <jql> that disturbs me

[23:30] <putter> Darren_Duncan: are scalars 1-ary sequences?

[23:30] <Darren_Duncan> in my mind they are

[23:30] <putter> that's a plausible approach, though there is a bit of friction with array autovivification.

[23:30] <jql> I imagine .elems coerces List context on its LHS. $x.elems =:= ($x).elems

[23:31] <Darren_Duncan> I never liked autovivification

[23:31] <jql> not that () does anything

[23:31] <jql> just for illustrative purposes there

[23:31] <Juerd> Darren_Duncan: Lack of autovivification is the one thing that keeps me from really trying ruby

[23:31] <Juerd> It's so painful to construct every collection manually.

[23:32] <putter> autovivification can be immensely useful.  it would also sometimes be immensely useful to turn it _off_.

[23:32] <Darren_Duncan> I prefer to do it manually because it can reduce errors

[23:32] <Darren_Duncan> I liken autovivification use to writing perl without use strict

[23:32] <Darren_Duncan> its like simply using a variable without declaring it first

[23:33] * putter spent a block of time yesterday tracing down where unguarded tests on hashes were mutating them, causing hash lookup failures. :(

[23:34] <Darren_Duncan> its also odd because anywhere else you would get an error trying to dereference an array/hash ref that isn't defined

[23:34] <putter> err, that second "hash" meant "reduce the hash to a ...err, hash, and use it as an index".

[23:34] <Darren_Duncan> only in an array of arrays etc will it just create the inner array for you on reference; thats what I see autovivification being

[23:35] <Darren_Duncan> but without the outer array, if you had a scalar instead, it would give an error

[23:35] <jql> my $x; $x[0] = 1; $x[1]<foo> = woot;

[23:35] <Darren_Duncan> I see this as inconsistent

[23:35] <Darren_Duncan> I'm refering to p5 behaviour btw

[23:35] <putter> ah.

[23:35] <Darren_Duncan> and unless I hear otherwise, its as if p6 is emulating it by default

[23:37] <Darren_Duncan> following jql's example, I like to explicitly say "$x[1] ||= {};" between the above two lines

[23:38] <Darren_Duncan> assuming the hashes weren't known to be made in advance, such as with many dynamic operations

[23:38] <jql> the problem in perl5 was making my $x; for($x<y><z>) { $_ = 10 } work

[23:38] <jql> for some definition of "work"

[23:39] <jql> in perl6, I'd imagine autovivification would be implemented with let() or something

[23:40] <Darren_Duncan> I'm okay with autov being supported, if the user explicitly requests it; by default it should not happen

[23:41] <autrijus> 07:33 < Darren_Duncan> I see this as inconsistent

[23:41] <Darren_Duncan> yup

[23:42] <autrijus> well, it is consistent in a way; only undef gets autov.

[23:42] <autrijus> that's essentially what it is: a container that is undef is polymorphic over its container type.

[23:42] <obra>  hey autrijus 

[23:42] <autrijus> it is potentially a reference for any(Scalar, Array, Hash)

[23:42] <autrijus> hey obra. I slept 13 hours!

[23:43] <obra> autrijus: nice!

[23:46] <autrijus> obra: how's life?

[23:46] <obra> neck hurts.

[23:46] <autrijus> ew.

[23:46] <obra> glasser got the first version of DBIx::SearchBuilder::SchemaGenerator checked in

[23:47] <obra> so soon, factory dies and the perl becomes canonical for new apps

[23:47] <autrijus> (and my G3 went away during my sleep -- zonble's computer got stolen and I apparently gave it to him when he asked during my dreams)

[23:47] <Darren_Duncan> good for 'im

[23:47] <Darren_Duncan> I plan to do SQL::Routine and friends any day now

[23:47] <Darren_Duncan> once LKT is known working

[23:47] <obra> (for those playing the home game, we're not talking about perl6)

[23:47] <svnbot6> r4179, autrijus++ | * remove unused variable bindings in Pugs.Types.Scalar.

[23:47] <svnbot6> r4180, autrijus++ | * Pugs.Compile.Pugs2: for releng, before SamB gets next batch

[23:47] <svnbot6> r4180, autrijus++ |   of tuits, we comment out all unused var bindings.

[23:48] <obra> autrijus: will you be able to test on whiteg's laptop or somesuch?

[23:48] <clkao> hola autrijus

[23:49] <clkao> autrijus: hey, take a look at the failing tests in unspecced/p5/

[23:49] <Darren_Duncan> so autrijus, about that polymorphic undef thing, does that mean I can do this ...

[23:49] <Darren_Duncan> my $foo; $foo[1] =3;

[23:49] <Darren_Duncan> ?

[23:50] <SamB> hmm, about Pugs.Compile.Pugs2, Language.Haskell.Syntax is quite cumbersome...

[23:50] <clkao> autrijus: btw i've got perl5_apply returning av, you should be able to do stuff in haskell land

[23:50] <Darren_Duncan> back shortly

[23:50] <SamB> I even tried it with Language.Haskell.Hsx.Build and it was STILL too cumbersome.

