[00:38] <cm> camels

[00:38] <coral> moo

[02:13] <svnbot6> r5926 | Stevan++ | Perl6::MetaModel - (p5)

[02:13] <svnbot6> r5926 | Stevan++ | * removing more of the Perl 5 sugar

[02:13] <svnbot6> r5926 | Stevan++ |   - removed MetaClass::AUTOLOAD in favor of ::dispatch

[02:13] <svnbot6> r5926 | Stevan++ |   - converting tests to de-sugared versions 

[04:15] <putter> ping: autrijus

[04:16] <putter> err,

[04:16] <putter> autrijus: ping

[04:16] <putter> oo...

[05:04] <svnbot6> r5927 | putter++ | Exposed PGE's :w :words.  Now 'a b' ~~ rx:words/a b/.  Fyi, PGE on parrot head has been updated with fixes backported from the leo-ctx5 branch.

[06:29] <svnbot6> r5928 | autrijus++ | * remove dead code juncTypeIs from Junc.hs.

[07:24] <Darren_Duncan> hija

[07:24] <Darren_Duncan> s/j/y/

[07:25] <Aankhen``> Hi Darren_Duncan

[07:25] <Aankhen``> .

[07:25] <Darren_Duncan> so this is the first #perl6 message typed on the iBook I'm borrowing for OSCON ... I leave tomorrow

[07:25] <Darren_Duncan> just testing that everything I'm used to works

[07:26] <Aankhen``> Cool. :-)

[07:26] <Aankhen``> You're giving a talk at OSCON, right?

[07:26] <Darren_Duncan> here's a quick question you may know ... how do you best label a laptop, so if there is confusion in a group its easy to tell its mine ...

[07:27] <Aankhen``> Dunno, never been in that situation...

[07:27] <Darren_Duncan> eg, can you write on it with felt tip marker ..

[07:27] <Darren_Duncan> or better to use masking tape ...

[07:27] <Darren_Duncan> etc

[07:27] <Darren_Duncan> in answer to your question, I was approved to give a Lightning Talk

[07:27] <Darren_Duncan> on thursday

[07:27] <Aankhen``> Is that different from a normal talk?

[07:27] <Darren_Duncan> yes ... hard 5 minute time limit

[07:28] <Aankhen``> Ahh.

[07:28] <Aankhen``> Well, best of luck!

[07:28] <Darren_Duncan> tradition goes that if you go over that by 2 seconds, you get booed

[07:28] <Darren_Duncan> so I've heard

[07:55] * nothingmuch needs a multi dimentional outlining tool

[07:55] <nothingmuch> that is, create a hierarchal outline

[07:55] <nothingmuch> then create a new dimentoin

[07:55] <nothingmuch> and reorganize existing objects in the new dimention

[08:52] <svnbot6> r5929 | autrijus++ | * Unique id distribution for PIL containers, thanks to

[08:52] <svnbot6> r5929 | autrijus++ |   linear implicit parameters.

[11:39] <svnbot6> r5930 | iblech++ | examples/network/svnbot.p6 -- Keep svnbot from displaying R-status lines (AUM,

[11:39] <svnbot6> r5930 | iblech++ | etc. were all already hidden, but I missed R).

[12:23] <xinming> by the way, In perl 5, the constructor name of a "class" is user-defined. I wonder if perl 6 is also following this rule?

[12:25] <iblech> If you want to, you can give your constructor(s) every name you want, but by default Perl 6 gives you a standard .new.

[12:25] <QtPlatypus> The default constructor's name is new, and its rather DWIMish.  But there is nothing to stop you making your own constructor.

[12:26] <xinming> What does DWIMish mean please?

[12:26] <iblech> Do What I Mean

[12:26] <iblech> I.e. you won't have to change/override it most of the time

[12:28] <xinming> hmm.. ok, in perl 5, we may use qq{sub get_obj{ my $obj = bless{},${(shift)} } }

[12:29] <xinming> Do you mean if we use perl 6, we have to call default new method in our constructor?

[12:29] <iblech> You can do that, or alternatively call bless on your own

[12:30] <xinming> iblech: hmm, I wonder if word new is a key word for perl 6. :-)

[12:31] <iblech> No, it's only a normal class method, inherited from Class or so

[13:09] <xinming> by the way, anyone here can tell me which is more "correct" or "recent" for perl 6 grammer specification ? Exegesis or Apocalypses

[13:10] <iblech> The Synopsis are most uptodate

[13:11] <xinming> iblech: thanks.

[13:29] <xinming> what are the differences between moulde package?

[13:30] <xinming> class is definite clear. But I was confused by these two names. :-S

[13:32] <QtPlatypus> Are you asking the diffrence between a package and a module?

[13:33] <xinming> hmm... for keyword. :-)

[13:34] <xinming> between module and package. what are the differences. I just read the Synopsis

[13:36] <svnbot6> r5931 | iblech++ | * Usual svn props.

[13:36] <svnbot6> r5931 | iblech++ | * Test fixes:

[13:36] <svnbot6> r5931 | iblech++ |   * var/state.t -- Implicit deref is no more.

[13:36] <svnbot6> r5931 | iblech++ |   * builtins/caller.t, operators/smartmatch.t -- &foo is sufficient, no need for \&foo.

[13:36] <svnbot6> r5931 | iblech++ |   * operators/quoting.t -- Many unEVALs.

[13:36] <svnbot6> r5931 | iblech++ |   * operators/adverbial_modifiers.t -- Refs don't stringify.

[13:43] <svnbot6> r5932 | iblech++ | * PIL2JS:

[13:43] <svnbot6> r5932 | iblech++ |   * (Hopefully) correct reference handling:

[13:43] <svnbot6> r5932 | iblech++ |     Distiction between autodereffing refs and non-autodereffing refs --

[13:43] <svnbot6> r5932 | iblech++ |     [1,2,3] should autoderef, but \3 should not, see

[13:43] <svnbot6> r5932 | iblech++ |     http://www.nntp.perl.org/group/perl.perl6.language/22532.

[13:43] <svnbot6> r5932 | iblech++ |   * &tied: [1,2,3] autoderefs, but tied([1,2,3]) does not.

[13:43] <svnbot6> r5932 | iblech++ |   * Ported &prefix:<~> to native JS (massive speedup: 0.2s instead of 1.7s for

[13:43] <svnbot6> r5932 | iblech++ |     a simple say ~(1,2,3); 23min instead of 31min for smoke).

[13:43] <svnbot6> r5932 | iblech++ |   * Fixed the stringification of Bools.

[13:43] <svnbot6> r5932 | iblech++ |   * Added stub &eval, so tests which use eval are at least not doomed to fail.

[13:49] <iblech> putter: pong

[13:50] <iblech> autrijus: How will we handle "{ my $x; sub foo { $x++ } }; foo()", i.e. catching of lexicals, in PIL2?

[14:25] <iblech> gaal: I've just changed perl6/Prelude.pm, then run "make", but Run.hs was not rebuilt -- in fact, ghc wasn't even executed. Known?

[14:37] <gaal> iblech, we can add a dependency on Prelude.pm in the makefile, and a dummy target

[14:38] <gaal> but i'm not sure that's 100% correct either, because when the user isn't precompiling, the prelude isn't a dep.

[14:38] <gaal> then again, that's a rare case i suppose. fixing.

[14:38] <iblech> :) Thanks

[14:38] <iblech> gaal++

[14:52] <autrijus> heya iblech 

[14:52] <autrijus> iblech: I have a question for you too

[14:52] <autrijus> in our formulation, the & sigil is merely a restrained $

[14:52] <autrijus> that makes

[14:52] <autrijus> &{$x}

[14:52] <autrijus> effectively an no-op.

[14:53] <autrijus> &{$x} = $x; # no-op too!

[14:53] <iblech> Hi :)

[14:53] <iblech> Hm, yes.

[14:53] <autrijus> this is because Code is not a container

[14:53] <autrijus> so it loses its special deref status.

[14:53] <autrijus> now I'm thinking that we lose both *{} and &{}.

[14:53] <autrijus> lose, as in rid of

[14:54] <autrijus> we can say that &{$x} produces a nonassignable rvalue etc, but I'm not sure if it helps.

[14:55] <autrijus> so, do you think the & sigil should be rendered nonspecial, or we go back and declare Code a separate container interface?

[14:55] <iblech> Makes sense. Especially as you can write $x() instead of &{$x} if you want to call $x, to the special &{...} magic is unneeded, I think.

[14:55] <iblech> I'd take option #1

[14:55] <autrijus> me too.

[14:55] <iblech> Great :)

[14:56] <autrijus> esp. seeing & has _nothing_ to do with containing, that is storing, stuff.

[14:56] <autrijus> (unless you think that it is a hash keyed by parameters)

[14:56] <autrijus> (and contains return values)

[14:56] <iblech> I absolutely agree.

[14:56] <integral> hmm, what about @{} and %{}?

[14:57] <autrijus> integral: those are casts between Ref of Array|Hash and Array|Hash

[14:57] <integral> hmm, isn't that what &{} is?

[14:57] <integral> oh, there's no Ref of Code,  it's just Code?

[14:57] <autrijus> yup.

[14:57] <autrijus> exactly.

[14:58] <autrijus> they can't be distinguished

[14:58] <autrijus> is what I'm talking about.

[14:58] <autrijus> so why bother creating a first class container? it's the same logic used to eliminate the IO container type.

[14:58] <autrijus> that is TIEHANDLE and *{}

[14:58] <integral> so it's really a move to being object-oriented?

[14:59] <autrijus> yes. think java, which has objects, scalar that stores an object, and aggregates that store objects

[14:59] <autrijus> perl6 just introduces two distinct aggregate interfaces

[14:59] <autrijus> that's all.

[14:59] <integral> make sense now

[15:01] <autrijus> ok, scrollign back to iblech's question...

[15:03] <autrijus> iblech: the idea is that every time there is a PVar, there could be a PPad that declares that PVar

[15:03] <autrijus> i.e.

[15:04] <autrijus> $x = 1 # PAssign [(PVar "$x")] (PLit (PVal VInt 1)))))

[15:04] <autrijus> my $x = 1 # PAssign [(PPad SMy (PVar "$x"))] (PLit (PVal VInt 1)))))

[15:05] <autrijus> a PPad always ranges over to everything after its evaluation order

[15:05] <autrijus> within the current PIL [Stmt] body.

[15:06] <autrijus> end of story

[15:06] <iblech> Ok, but:

[15:06] <iblech> my $x = 1; sub foo { $x++ }

[15:06] <autrijus> that means the compiler that generates PIL will rewrite statements silently so lexical order is preserved.

[15:06] <iblech> The &foo is stored in pilGlob

[15:07] <iblech> And doesn't see anything of $x

[15:07] <autrijus> that will go away; that line will be compiled to 

[15:07] <autrijus> our &foo = sub { $x++ }

[15:07] <autrijus> pilGlob will just be the link set

[15:07] <autrijus> i.e. compile-time visible symbols

[15:07] <iblech> ah, ok, that will work :)

[15:07] <autrijus> cool. :)

[15:08] * autrijus ponders the implication of assignable &foo

[15:09] <autrijus> hm, another p6l post may be in order.

[15:13] <QtPlatypus> our &foo := sub { $x++}; # makes sence.

[15:14] <autrijus> QtPlatypus: we're talking about murdering the distinction between $ and &.

[15:14] <autrijus> i.e. my &foo is nothing but "my Code $foo"

[15:14] <autrijus> so you can assign into it.

[15:15] <QtPlatypus> Like in python and scheme?

[15:15] <autrijus> well, like in anywhere really

[15:18] <QtPlatypus> Correct me if I'm wrong but &foo is the ref to the function foo().  So if you assigned to &foo, it would result in foo becoming the funtion that was assighed to it?

[15:19] <autrijus> just replace, in your mind, &foo with $foo

[15:19] <autrijus> and foo(123) with $foo(123)

[15:20] <iblech> autrijus: my ($a, $b) = (3,4)  # Will that stay my ($a, $b); &infix:<,>($a, $b) = (3, 4) in PIL2?

[15:20] <autrijus> no, it will become

[15:21] <autrijus> (my($a), my($b)) = (3,4)

[15:21] <autrijus> if that's okay with you.

[15:21] <autrijus> currently neither Exp nor PIL deals with inline pad decls

[15:21] <autrijus> that is one of the things that needs to be fixed soonish

[15:22] <iblech> Fine WRT to the mys, but will &infix:<,> be used to assign? Or will that be splitted into my $a = 3; my $b = 4?

[15:23] <iblech> (Question is whether I have to mark &infix:<,> is rw.)

[15:23] <iblech> (And override the .STORE of &infix:<,>'s return value accordingly.)

[15:25] <autrijus> in general I can't split that, as you know

[15:25] <autrijus> my ($a, $b) = reverse(3,4);

[15:25] <iblech> Oh, right.

[15:25] <autrijus> in current pugs I used an throwaway tied Array.

[15:26] <autrijus> i.e. VList is an instance of IArray

[15:26] <autrijus> and if you assign to it then it behaves as expected.

[15:26] <autrijus> really we should have a bounded array, or tuple, interface

[15:26] <autrijus> but failing that, I think the current treatment is okay

[15:27] <autrijus> infix<,> is definitly rw.

[15:27] <iblech> Yep, ok, will do that then.

[15:27] <autrijus> anything that happens at lv position is rw.

[15:27] <iblech> Right.

[15:27] <iblech> Next question :)

[15:27] <iblech> my ($foo, *@rest) := foo()

[15:28] <iblech> We don't even parse this currently

[15:28] <iblech> But what'll be the PIL for that?

[15:29] <iblech> And even things like

[15:29] <iblech> my (+$foo, ?$bar) := foo()

[15:30] <iblech> should eventually work, i.e. you can specify a sub-like signature as LHS

[15:33] <svnbot6> r5933 | gaal++ | depend on Prelude.pm in building pugs. thanks iblech++ for pointing this out.

[15:33] <autrijus> yes.

[15:34] <autrijus> theoretically we should unify binding and function application

[15:34] <autrijus> i.e. they should use the same form.

[15:35] <autrijus> we can do this by considering a := as an inline function

[15:35] <autrijus> that preserves its lhs symbols with their original scope

[15:35] <autrijus> and with an empty body

[15:36] <autrijus> conversely, we can consider

[15:36] <autrijus> sub ($x) { $x + 1 }

[15:36] <autrijus> as having a PBind form as its parameter list, with the rhs being something magical.

[15:37] <autrijus> both are isomorphic, so it's a question of reduction

[15:37] <autrijus> in which case having Bind as a primitive form wins over special treatment of empty inline subs

[15:38] <autrijus> this will also enable us to do strange things like

[15:38] <autrijus> my ($b, $a) := { return(a => 1, b => 2) }.();

[15:39] <autrijus> sub foo () returns (Int $a, Int ?$b, Int +$c) {}

[15:39] <autrijus> as both the function application and function return form would be bindings.

[15:39] <autrijus> you think that's sane?

[15:40] <iblech> Ah! Yes, definitely!

[15:40] <autrijus> good, let's go with that then. I'll let PBind dominate over both functions and normal bindings :)

[15:40] <autrijus> _another_ p6c post will be in order then

[15:41] <iblech> :)

[15:41] <autrijus> ;)

[15:41] <autrijus> (the &{} one is on p6l now)

[15:41] <autrijus> this language really is strange.

[15:46] <autrijus> so, I'll go back to TaPL a bit and write journals if there's no further questions for now :)

[15:46] <iblech> Go ahead :)

[15:46] <iblech> And thanks :)

[15:46] <autrijus> np. thank _you_ :)

[15:51] <gaal> any thoughts on http://www.nntp.perl.org/group/perl.perl6.language/22543 ?

[15:56] <putter> gaal: so... use is like a temp declaration, which can be withdrawn by no, exposing that which was overshaddowed?

[15:56] <iblech> putter: pong

[15:57] <gaal> not really, that is i don't think you can really rollback the state of your program to what it was before you used a module

[15:57] <gaal> but in p5, "use" calls a hook

[15:57] <gaal> &import in your module

[15:58] <gaal> and "no" calls "&unimport"

[15:58] <gaal> if they are defined

[15:58] <putter> ok, that's wierd.  irc line triggers mass of nuronal firings, doing a search tree, which half a second before there was so no anticipation might be kicked off.

[15:59] <gaal> it's nothing fancy in p5

[16:00] <gaal> i don't think p6 needs something much fancier

[16:00] <gaal> but the lowercase names are probably going to change

[16:00] <svnbot6> r5934 | iblech++ | * EOLs at EOFs.

[16:00] <svnbot6> r5934 | iblech++ | * More test fixes:

[16:00] <svnbot6> r5934 | iblech++ |   * syntax/single_quoted_strings.t -- unEVAL and added plan.

[16:00] <svnbot6> r5934 | iblech++ |   * var/my.t -- Removed $::(...) tests; "my $x; $::('x')" does *not* work, see

[16:00] <svnbot6> r5934 | iblech++ |     explanation in t/var/symbolic_deref.t.

[16:00] <svnbot6> r5934 | iblech++ | * t/var/autoderef.t -- Added tests for &tied and that the retval of tied($ref)

[16:00] <svnbot6> r5934 | iblech++ |   should *not* autoderef.

[16:00] <svnbot6> r5934 | iblech++ | * t/data_types/subscripts_and_context.t -- Added more tests.

[16:00] <svnbot6> r5934 | iblech++ | * t/operators/inc.t -- &postfix:<++> should evaluate the expr it's ++ing only once.

[16:00] <putter> iblech: I fuzzily think the ping was to ask for a hand with a Parser.hs puzzle - getting rz:foo/bar/ working.  But I think for now I'm going to leave the haskell parsing in place, and just insert a p6 function between that and the creation of a rx PIL.  So I think I'm all set...  My thanks. :)

[16:01] <iblech> putter: :)

[16:02] <putter> autrijus: ping?

[16:05] <putter> gaal: ah.  so the semantics are clear, its just a matter of what names to use...?  (still isnt clear to me from note... ;)  (if there is more to it, note adverbs are one option for passing extra info...)

[16:05] * putter thought  $::('x') was ok... going to read  t/var/symbolic_deref.t...

[16:06] <iblech> putter: $::("x") will only find our $x, not my $x

[16:07] <iblech> You've to use $::("MY::x") to get to my $x

[16:07] <iblech> See symbolic_deref.t:50

[16:07] <putter> ah.  does my $x end up in %:: ?  or just in %MY:: ?

[16:08] <iblech> Only %MY::, I think.

[16:08] <svnbot6> r5935 | iblech++ | * PIL2JS:

[16:08] <svnbot6> r5935 | iblech++ |   * PIL2JS.js: $foo.isa("Any") is now true.

[16:08] <svnbot6> r5935 | iblech++ |   * PIL2JS.js: undef.ref does not longer die.

[16:08] <svnbot6> r5935 | iblech++ |   * Prelude::JS::Bool: Fixed booleanification of refs.

[16:08] <svnbot6> r5935 | iblech++ |   * Prelude::JS::Operators: Made $foo.abs, $foo.int, etc. work.

[16:08] <svnbot6> r5935 | iblech++ |   * We're at 54.14% test passes last time I checked (+10% compared with yesterday) :)

[16:08] <svnbot6> r5935 | iblech++ | * Missed some more EOLs at EOFs in r5934, fixed.

[16:09] <putter> hmm.  at times like this I'm tempted to write a small language reference doc just so I can keep it all straight.

[16:09] <iblech> docs/quickref/ :)

[16:11] <putter> yeah. :)  I was just thinking, but wait, I _did_.  docs/quickref/namespace.  but I never described its interaction with my/our/temp/etc.  I'm not even sure there is an "etc"...   rev2...

[16:12] <iblech> There's state and let

[16:12] <iblech> my $x = 20; { let $x = 3; 0 }; # $x restored to 20

[16:12] <iblech> my $x = 20; { let $x = 3; 1 }; # $x stays 3

[16:13] <putter> ah, yes.  key in regexps.

[16:13] <iblech> sub foo { state $x; say ++$x }; foo(); foo(); foo(); # 1,2,3

[16:15] <putter> it was never entirely clear to me what state's claim to fame is.  (other than getting storage in objects working for the first time.)   hmm, maybe I'll try a pithy one line on each... "declaration flavor"?... describing its behavior and most important uses.

[16:17] <iblech> sub foo { state $initialized; unless $initialized { ...; $initialized++ }; ... }

[16:17] <iblech> (but FWIW, this is better written as sub foo { FIRST {...} })

[16:18] <putter> iblech: btw, I've now used the PIL / JS backend combo a couple of times as an example of what can happen when you have insightful design and notably good people.  most impressive.  just thought I'd mention it.

[16:18] <iblech> :)

[16:18] <putter> re state/FIRST, ah, ok.

[16:34] <svnbot6> r5936 | putter++ | It's still largely unfilled it, but now there's a my/our/temp/etc vs symbol tables affected table in docs/quickref/namespace.

[16:34] <svnbot6> r5937 | putter++ | A few more empty rows in the new docs/quickref/namespace table.

[16:34] <iblech> putter++ # will certainly be helpful

[16:37] <putter> :)

[16:38] <iblech> putter: state will create a new lexical var, exactly like my.

[16:38] <iblech> temp and let only work with already declared vars, I think.

[16:40] <putter> k

[16:40] <svnbot6> r5938 | putter++ | Added empty my/our/temp/let/state vs meaning-and-common-use table in docs/quickref/namespace table.  Attention lurkers... here is a chance to read a clear section of the docs, learn an important bit of perl, and contribute... :)

[16:40] <xinming> what is the differences between the "package" which is defined using keyword "module" and "package" please? :-S

[16:41] <putter> see docs/quickref/namespace ... there's a nice table :) :)

[16:43] <putter> more helpfully... modules add export/import, version to package's namespace, traits, autoload

[16:44] <xinming> putter: so, this means that their differences are, package defined by keyword "package" may only be used for specified program. and module is used for upload to CPAN. Or act as lib, right?

[16:50] <putter> a good question.    a module isa package.  but a module can be declared with version info (eg,  Net::IRC-0.05) where a package would be just  Net::IRC .   My quite fuzzy understanding is you can still "use Foo;" to get Foo.pm with a package Foo;, but you dont get the versioning magic, and I suspect you wont "is export" stuff wont work.  But I'm really not quite sure.

[16:52] <putter> in general, perl5 ways of doing things will continue to work, and p6 introduces new nice ways of doing things which are otherwise painful in p5.

[16:52] <putter> so you can probably continue to use "package" on CPAN... but you likely wont want to... :)

[16:53] <xinming> putter: in fact, After I read synopses, I got this question. Class is sure to be different from package. as people don't wish to mix sub routine{ } with sub method{ }

[16:54] <xinming> But there is already a key word package. So I think module might be the thing as I guessed. :-)

[17:11] <putter> err, class isa package.  a class-flavored package can have both methods and subs ("sub foo(){} method bar(){}").  a simple just-a-package package can have subs.

[17:12] <putter> I don't _think_ Test.pm is doing something really weird... but I have a " {} " in a _comment_ causing a parsefail... ?!?!

[17:13] <gaal> what's the code?

[17:13] <iblech> putter: "{ your code here }"

[17:13] <iblech> "{...}" interpolates

[17:14] <iblech> oh

[17:14] <iblech> in a comment, not a string

[17:14] <iblech> ignore me please :)

[17:14] <gaal> ?eval say "moose" # works {}

[17:15] <evalbot6> moose bool::true 

[17:15] <putter> iblech: distilling now...

[17:15] <iblech> putter: Do you use <> to access a hash somewhere? Pugs once had a parsing bug that caused $a < 3 to be parsed as $a<3[error: no closing >]

[17:18] <putter> oh, booorrrinng.  It's just an odd variant on \} in rules causing Parser problems.  semi-minimal case is:

[17:18] <putter> rule block { \{ \} }

[17:18] <putter> #ok('sub () {}' ~~ /^<anonsub>$/,"Anon subs parsing");

[17:19] <putter> this, and the full file version with lots of tests, works fine without the comment (I assume Parser backtracks and finds something reasonable), but with the comment, parsefail.  workaround is to use <'}'> rather than \} in rules.

[17:23] <putter> iblech: thank you.   minimal case:

[17:23] <putter> rule foo { \{ }  #}'

[17:24] <putter> about to become pugsbug/

[17:25] <iblech> Great :)

[17:25] <iblech> putter++

[17:27] * iblech got my ($a, undef, $b) = (...) and returning 0 or 1-elem arrays in PIL2JS working :)

[17:27] <iblech> food &

[17:27] <putter> &

[17:31] <autrijus> iblech: ping

[17:32] <autrijus> oh well, I'll post to p6c.

[17:32] <autrijus> putter: pong... if not too late

[17:32] <gaal> i see src/Pugs/CodeGen/PIR.hs uses EvalResultModule in its eval style

[17:32] <gaal> that doesn't mean anything yet

[17:33] <gaal> but i think it's might be a good place to put in "run init hooks please"?

[17:33] <autrijus> nod.

[17:33] <gaal> oh, maybe not:

[17:34] <gaal> because there's also the distinction of "honor 'is export'"

[17:34] <gaal> between require/use

[17:34] <gaal> ResultModule was originally intended to mean "return a Module object"

[17:34] <gaal> bah!

[17:35] <gaal> this confuses me :(

[17:38] <autrijus> sub f ($x) { my $x };

[17:38] <autrijus> error? noop? new decl?

[17:38] <putter> late?  oh, "&" is ambiguous.  waving goodbye to someone else, vs for oneself....   perhaps we should use  .& and ./&  ? ;)

[17:38] <autrijus> lol

[17:39] <gaal> autrijus, looks like a new decl to me.. surely sub f ($x) { { my $x } } is no error

[17:39] <autrijus> but!

[17:39] <autrijus> { my $x; my $x }

[17:39] <autrijus> is error or noop but never new decl

[17:39] <autrijus> I'm thinking about hoisting _all_ lexical decls to the top of body along with params

[17:40] <gaal> in p5 it's just a warning

[17:40] <gaal> and a new decl i think.

[17:41] <gaal> s/just //

[17:41] <autrijus> nod. but my point is that

[17:41] <autrijus> sub f ($x) { ... }

[17:41] <autrijus> corresponds to p5

[17:41] <autrijus> sub f { $x = shift ... }

[17:41] <autrijus> instead of the p5

[17:41] <autrijus> sub f { $x = shift; { ... } }

[17:41] <gaal> i agree

[17:41] <autrijus> at least in my mind

[17:41] <ingy> hi autrijus 

[17:41] <autrijus> heya.

[17:41] <gaal> but i still think it should be a warning, not an error, for the same reasons :)

[17:44] <autrijus> a warning + noop

[17:44] <autrijus> or a warning + newdecl.

[17:47] <gaal> in p5, it's a new decl:

[17:47] <gaal> perl -lwe 'my $x = 5; print \$x; my $x = 8; print \$x; print \$x'

[17:47] <gaal> "my" variable $x masks earlier declaration in same scope at -e line 1.

[17:47] <gaal> SCALAR(0x804d630) / SCALAR(0x804d660) / SCALAR(0x804d660)

[17:48] <autrijus> I know that. :) I think larry wants it to be warning+noop

[17:48] <gaal> it'd be an error in any other language that had decls :)

[17:48] <gaal> probably

[17:48] <iblech> autrijus: pong

[17:49] <autrijus> iblech: floating all my() and our() decl to beginning of block. sane?

[17:49] <autrijus> I suspect it will greatly simplify your life.

[17:50] <autrijus> as you can alloc it along with params.

[17:50] <iblech> Right, it would be easier for PIL2JS. But then { say $a; my $a } would be legal, right?

[17:50] <autrijus> why? if there is an outer $a that compiles

[17:50] <autrijus> {my$a | say $OUTER::a }

[17:50] <autrijus> if not then error

[17:50] <autrijus> the floating is PIL

[17:50] <autrijus> not pre-PIL

[17:51] <autrijus> so we already guarded against bogus ref

[17:51] <iblech> ah, ok. I'm fine with that then :)

[17:51] <autrijus> ok, the only requirement is you need to handle nested $OUTER::

[17:51] <autrijus> but I suspect you already do that :)

[17:52] <iblech> No, I don't do that yet, and it's probably tricky...

[17:52] <iblech> (But doable -- basically I'd have to rewrite { my $a; { my $a } } to { my $a__0; { my $a__1 } }

[17:53] <integral> PIL.hs uses the ST monad, shouldn't this be the STM monad so that things like bind are threadsafe?

[17:53] <autrijus> integral: unsafePerformSTM instead of runST?

[17:54] <integral> autrijus: don't they get used from inside Eval?

[17:54] <autrijus> hm.

[17:54] <integral> or a runST that returns a STM monad

[17:55] <autrijus> I don't know, metamonads feel awkward

[17:55] <autrijus> and the semantic is wrong anyway

[17:55] <autrijus> you want TVar not STRef

[17:55] <autrijus> so yeah, maybe TVar it and go unsafe

[17:55] <autrijus> the thing about runST is just that it's easier to quickcheck

[17:55] <autrijus> I mean, safer

[17:56] <autrijus> but maybe it doesn't matter.

[17:56] <xinming> how to type "?" in keyboard please?

[17:56] <Khisanth> a question mark?

[17:56] <integral> hmm, quickchecking is good

[17:56] <xinming> It seems not a perl 6 question. In fact. It is.

[17:56] <xinming> Khisanth: No.

[17:56] <xinming> or the "zipper" operator to interleave them:

[17:56] <xinming>     for @a ? @b ? @c -> $a, $b, $c { print "[$a, $b, $c]\n" }

[17:56] <integral> xinming: your irc client isn't sending in utf-8

[17:56] <autrijus> integral: nah, unsafePerformIO . atomically is livable

[17:56] <Khisanth> oh the yen symbol

[17:56] <autrijus> integral: with suitable NOINLINE

[17:56] <Khisanth> just use Y

[17:57] <integral> autrijus: scary for use lesser mortals though 8-)

[17:57] <Khisanth> ¥

[17:57] <autrijus> integral: so, please feel free to change them to TVar

[17:57] <integral> *us

[17:57] <autrijus> integral: heh... in the awkward squad paper spj gave precise definition of how to make unsafePerformIO safe

[17:57] <Khisanth> ctrl+shift+a5 if you are using something built with GTK :)

[17:57] <autrijus> just evaluate each situation with those metrics :)

[17:57] <xinming> ¥

[17:58] <integral> hmm, I'll have to read those

[17:58] <gaal> xinming: see also docs/quickref/unicode

[17:58] <gaal> Khisanth: add that to the doc?

[17:59] <Khisanth> hrm?

[17:59] <gaal> the GTK binding.

[17:59] <Khisanth> you can use ctrl+shift+hex

[17:59] <Khisanth> that is how I have been typing the « and » :)

[18:00] <gaal> good :) could you add that to docs/quickref/unicode please? :)

[18:00] <xinming> Khisanth: hmm... In fact, I wonder why perl 6 will use other chars as operator which can't be typed from standard keyboard. :-S

[18:01] <Khisanth> xinming: only if you choose to

[18:01] <Khisanth> instead of ¥ you could just use Y

[18:01] <Khisanth> instead of « you can use <<

[18:02] <Khisanth> hmm

[18:02] <Khisanth> can't display the Set.pm operators

[18:02] <gaal> http://svn.openfoundry.org/pugs/docs/quickref/unicode

[18:02] <Khisanth> I mean in my terminal with vim :)

[18:02] <gaal> your browser probably has better fonts than your editor :)

[18:03] <Khisanth> moz vs. gnome-terminal

[18:07] <svnbot6> r5939 | autark++ | * add test for function interpolation gobbling up trailing whitespace

[18:07] <svnbot6> r5940 | iblech++ | * Pugs.Compile -- Don't emit [Noop] for the empty arrayref literal ([]).

[18:07] <svnbot6> r5940 | iblech++ | * t/var/symbolic_deref.t -- Fixed one test.

[18:07] <svnbot6> r5940 | iblech++ | * PIL2JS:

[18:07] <svnbot6> r5940 | iblech++ |   * Finally, returning 0- or 1-elem arrays works correctly, causing many tests

[18:07] <svnbot6> r5940 | iblech++ |     to pass, currently resmoking...

[18:07] <svnbot6> r5940 | iblech++ |   * Removed the now unneeded [...] hacks.

[18:07] <svnbot6> r5940 | iblech++ |   * my ($a, undef, $b) = ... works now.

[18:10] <autrijus> iblech: how do you resmoke?

[18:10] <autrijus> I don't see a "make jssmoke"

[18:11] <iblech> Right. The naive solution would be to simply use runjs.pl as HARNESS_PUGS, but that will work extremely slow, as Test.pm is then compiled again and again.

[18:11] <iblech> Instead, I use a 10 line script as HARNESS_PUGS which reads the input .t and s/use Test//

[18:11] <iblech> (Test.pm ist precompiled and always linked in.)

[18:12] <autrijus> please check it in somewhere :)

[18:12] <autrijus> in README if must

[18:12] <autrijus> I mean perl5/PIL2JS/

[18:13] <iblech> I tried pugs -MMarkTestPMAsLoaded -CPIL ...normal options here..., with MMarkTestPMAsLoaded.pm containing %*INC<Test.pm>++, but then pugs refuses to work ("can't open file")

[18:13] <Khisanth> gaal: another column in that would go over 80 chars

[18:14] <autrijus> iblech: how long does it take for your to jssmoke?

[18:14] <gaal> iblech, the precompilation mechanism prevents modules from being reloaded

[18:14] <gaal> in normal pugs at least

[18:15] <gaal> Khisanth: that was bound to happen sometime... either creatively decrease column width, or start another row

[18:15] <iblech> Will do.

[18:17] <iblech> re. Sorry, my IPv6 tunnelbroker lagged...

[18:17] <iblech> autrijus: ~~20min, but using -j1

[18:17] <autrijus> iblech: ok. post the new smoke as reply to my journal? :)

[18:17] <autrijus> the new one is up: http://use.perl.org/~autrijus/journal/25991

[18:17] <autrijus> I need to sleep a bit now

[18:17] <autrijus> see ya!

[18:18] <iblech> Ok

[18:18] <iblech> Night :)

[18:18] <autrijus> (and the my() hoisting is on p6c now)

[18:18] <autrijus> &

[18:47] *** marksto1 is now known as markstos_

[18:47] <markstos_> I just tried using the p5 to p6 converter utility on CGI::Application's "Application.pm". The result was much shorter. 

[18:48] <markstos_> But I was hoping there would be more of a result than what I found: if ref($class) { # No copy constructor yet!  $class = ref($class); }

[18:48] <markstos_> Any tips on how to make the conversion script more effective? 

[18:51] <iblech> markstos_: Do you refer to util/p5_to_p6.pl? This is only a helper for *manual* porting.

[18:51] <markstos_> I understand. 

[18:51] <iblech> Larry is working on a "real" P5 -> P6 translater, but he hasn't released it yet.

[18:52] <markstos_> I don't see how reducing the module to that line of code helped me with a manual port, though.

[18:53] <iblech> Right, util/p5_to_p6.pl isn't finished, IIRC

[18:54] <markstos_> Ok. 

[18:54] <markstos_> maybe I can patch it. 

[18:56] <iblech> markstos_: Great! :) Are you a committer yet?

[18:56] <markstos_> Not yet, but I prefer darcs, so I do 'darcs send'. 

[18:56] <markstos_> but I could use svn if it's easier for those would have to process my patches. 

[18:58] <Khisanth> well you can use darcs too and commit bits are given freely :)

[18:58] <svnbot6> r5941 | putter++ | Added t/pugsbugs/parsing_braces_in_rules.t.  Parsing curly braces in rules isnt quite working.  For now, always match a \{ (escape-open-curly) with a <'}'> (close-curly literal).

[18:58] <svnbot6> r5942 | iblech++ | PIL2JS: New file pugs-smokejs.pl: Use that as HARNESS_PUGS if you want to jssmoke.

[18:58] <iblech> Right :) markstos_: Give me your mail address please, so I can make you a committer? :)

[19:01] <iblech> markstos_: Invitation sent, welcome aboard :) Please add yourself to AUTHORS :)

[19:01] <markstos_> Thanks iblech. 

[19:03] <svnbot6> r5943 | putter++ | docs/quickref/namespace: Added some notes/examples.  iblech++

[19:05] <markstos_> If I want to create  a test for p5_to_p6.pl, where I should I put it? I don't see a precedent there for testing a utility script.  util/t ? t/util ? 

[19:06] <coral> t/script/

[19:06] * coral has no preference, merely observing possible name

[19:07] <markstos_> I'm not sure we want to put in the main test directory, because it depends on p5's Regexp::Common, which normally isn't needed. I'll just make something up, and someone can revise it later, if they don' t like it,  right. :)

[19:08] <gaal> markstos_: while you're at it, take a look at t/examples and t/pugsrun, and see if you can factor the running-an-extra-pugs bit into Test.pm

[19:08] <gaal> if you have the tuits.

[19:09] <markstos_> We'll see. I was hoping porting CGI::Application would be a lazy-Sunday-afternoon  project, but it has already turned it something larger...

[19:16] <Aankhen``> gaal: Running an extra Pugs?

[19:16] <Aankhen``> What do you mean?

[19:16] <gaal> spawning an external process

[19:16] <Aankhen``> Ah.

[19:16] <gaal> sorry, still got that fever :(

[19:16] <gaal> and, am going to bed.

[19:17] <Aankhen``> Sleep well.

[19:17] <Aankhen``> Get well soon!

[19:17] <gaal> bye... :)

[19:17] <gaal> thanks!

[19:18] <iblech> Night :)

[19:19] <gaal> &

[19:20] <Aankhen``> To get a pipe, do I have to call &Pipe::open explicitly, since there's a &File::open as well?

[19:21] <iblech> I think so, but not 100% sure.

[19:21] <Aankhen``> :-o

[19:21] <Aankhen``> You're not using IPv6?

[19:21] <Aankhen``> Or an IPv6 tunneler, as the case may be...

[19:22] <Aankhen``> Or a tunnel, even. :-

[19:22] <Aankhen``> p

[19:22] <Aankhen``> Jeez, my typing is messed up.

[19:23] <svnbot6> r5944 | iblech++ | docs/quickref/namespace: Section about binding, and removed question marks from

[19:23] <svnbot6> r5944 | iblech++ | things I know for sure :)

[19:23] <svnbot6> r5944 | iblech++ | docs/quickref/control: Section about closure traits (FIRST {...}, etc.).

[19:23] <iblech> Right, normally I do, but my tunnelbroker lagged extremely a bit ago

[19:23] <Aankhen``> OK.

[19:23] <iblech_> Welcome from the IPv6 world :)

[19:23] *** iblech_ is now known as iblech

[19:23] <Aankhen``> Eek!

[19:24] <Aankhen``> Ah well, back to seeing a bunch of useless stuff before every line...

[19:24] <iblech> :D

[19:24] <iblech> irssi++ # good client

[19:24] <Aankhen``> mIRC-- # piece of junk

[19:25] <iblech> irssi++ # does not show a bunch of useless stuff before every line :)

[19:25] <Aankhen``> mIRC-- # piece of junk

[19:26] <Khisanth> eh? what is it showing before every line?

[19:26] <Aankhen``> Here's a normal line:

[19:26] <Aankhen``> [00:51:25] <iblech> I think so, but not 100% sure.

[19:26] <Aankhen``> Here's what it looks like now?

[19:27] <Aankhen``> s/\?$//

[19:27] <Aankhen``> [00:54:39] <iblech> 8e0:abcd:14d:2e0:7dff:fee5:bff PRIVMSG #perl6 :irssi++ # good client

[19:27] <Khisanth> oO

[19:27] <Khisanth> heh looks like it screwed up with the parsing

[19:27] <Aankhen``> Yup.

[19:29] <Khisanth> hmm

[19:29] <Khisanth> Aankhen``: so can you see the unicode chars? :)

[19:30] <Aankhen``> Sorta.  Some of them.

[19:30] <Aankhen``> They seem to be interpreted as two characters, so I see a weird "A" followed by the actual character.

[19:31] <Khisanth> hmm no, don't think that is displaying the correct character when you see the A with the circle above it

[19:31] <Aankhen``> It is, sometimes.

[19:31] <Aankhen``> Sometimes it's totally off.

[19:36] <svnbot6> r5945 | iblech++ | docs/talks/Anatomie_eines_Compilers_am_Beispiel_von_Pugs.latex:

[19:36] <svnbot6> r5945 | iblech++ | Skeleton of my talk "Anatomy of a Compiler using Pugs as example" (German,

[19:36] <svnbot6> r5945 | iblech++ | work-in-progress) I'll hold 2005-08-04.

[19:36] <Aankhen``> Wouldn't it make sense to shift everything possible from Pugs.Prim to the Prelude so that new backends have less to implement?  New prims should preferably go in the Prelude, I know, but I'm talking about the ones already there...

[19:38] <integral> that's not happening atm?

[19:38] <iblech> Generally yes. But: Currently, the main Prelude isn't used in the compilation to other backends (unless explicitly demanded using some env var).

[19:38] <Aankhen``> iblech: Ah, I see.

[19:38] <Aankhen``> In that case, I will withdraw my suggestion for the moment. :-)

[19:38] <iblech> And then, we probably don't want to write some often used prims (if, map, etc.) in Perl 6 (speed)

[19:39] <Aankhen``> I thought the whole point of Prelude was to implement all the prims possible so that the runtime has to implement only the bare minimum?

[19:39] <autrijus> right, but the runtime can also elect to optimize beyond the bare minimum.

[19:39] <Aankhen``> OK.

[19:40] <iblech> For example, &infix:<+> is currently a real method call in PIL2JS -- slow

[19:40] <iblech> err, s/method/sub/

[19:40] * autrijus can't quite sleep... so might as well start some releng

[19:40] <iblech> :)

[19:41] <autrijus> $y = \@x; # $y is "tied"? wtf?

[19:42] <autrijus> (yes, I know that lwall said that. I just can't quire comprehend)

[19:42] <autrijus> $y the container should have _nothing_ to do with this

[19:42] <autrijus> tied concerns interception of further assignment

[19:42] <autrijus> which this definitely does not do

[19:43] * iblech agrees completely

[19:44] <autrijus> I'm rejecting line 62 onwards of autoderef.t until further clarification :)

[19:44] <iblech> Probably he just meant get_real_no_autodereffing_ref_out_of_autodereffing_ref($a) instead of tied($a) :)

[19:44] <autrijus> yes.

[19:44] <autrijus> that's your thread

[19:44] <autrijus> can you reply to him?

[19:44] <iblech> Will do.

[19:44] <autrijus> tied() can't be used this way. it's insane

[19:48] <svnbot6> r5946 | autrijus++ | * mark most of autoderef.t as TODO -- more unexpected success

[19:48] <svnbot6> r5946 | autrijus++ |   for PIL2JS. :-)

[19:48] <svnbot6> r5946 | autrijus++ | * also remove the sanity-challenged (or, "differently sane")

[19:48] <svnbot6> r5946 | autrijus++ |   use of tied() in tests.

[19:53] <Aankhen``> Strange.

[19:53] <Aankhen``> HTTP::Header parses on its own, but when pulled in via `use`, it parsefails.

[19:53] <svnbot6> r5947 | putter++ | Uncommented parts of modules/Grammar/Perl6.pm which now parse.  But some still dont.

[19:53] <svnbot6> r5948 | autrijus++ | * castfail is now captured by try{}, so drop eval"" in favour of try{}.

[19:53] <svnbot6> r5949 | autrijus++ | * some QuickCheck for PIL.hs

[19:54] <Aankhen``> `require` has the same effect.

[19:57] <autrijus> Aankhen``: hm. try reducing it a bit?

[19:57] <Aankhen``> One sec.

[19:58] <Aankhen``> Ah.

[19:58] <Aankhen``> I think the parser was confused by myriad ./foo() calls.

[19:58] <Aankhen``> Replacing them with `$?SELF.foo()` fixed it.

[19:58] <svnbot6> r5950 | autrijus++ | * -Inf now stringifies as "-Inf", not "-Infinity".

[19:58] <svnbot6> r5950 | autrijus++ | * TODOed fglock's infinite.t test for int(Inf).

[19:58] <svnbot6> r5951 | autrijus++ | * move infinite.t form Recurrence to toplevel t/ because it

[19:58] <svnbot6> r5951 | autrijus++ |   does not use Recurrence.pm.

[19:59] <Aankhen``> To use a class in your code, do you need to `use` it?  Can it just be `require`d?

[20:01] <autrijus> require DBI; ::DBI.connect();

[20:01] <autrijus> use DBI; DBI.connect()

[20:01] <Aankhen``> What about: require DBI; DBI.connect();

[20:01] <autrijus> I don't think that can work.

[20:01] <autrijus> barewords are banned in general

[20:01] <Aankhen``> Dang.

[20:01] <autrijus> and strings no longer pun for packages.

[20:02] <autrijus> both are imho good things :)

[20:04] <Aankhen``> True.

[20:04] <svnbot6> r5952 | autrijus++ | * correct (:foo => 1) syntax in DateTime's Date.pm into (foo => 1).

[20:04] <brentdax> Wow, someone was confused.

[20:04] <Aankhen``> But then what about the example you gave of `use DBI; DBI.connect()`?

[20:04] <autrijus> nod.

[20:05] <autrijus> Aankhen``: in compile time if either ::DBI or &DBI is bound then bareword take that meaning.

[20:05] <Aankhen``> Ah.

[20:05] <autrijus> if both are bound, ::DBI takes prec.

[20:05] <autrijus> alternatively we can take the very cynical view and say ::DBI automagically create a &DBI that returns the package object.

[20:06] <autrijus> not sure we want to go there though.

[20:06] <Aankhen``> Heh.

[20:07] <Aankhen``> Hrm.

[20:07] <Aankhen``> This would apply to stuff like .isa() as well?

[20:08] <autrijus> aye. tho currently I let .does and .isa take strings

[20:08] <Aankhen``> require Foo; my $foo = ::Foo.new(); ok($foo.isa(::Foo));

[20:08] <autrijus> and do a runtime lookup

[20:08] <autrijus> as in .isa('Foo')

[20:08] <autrijus> just to make people happier

[20:08] <Aankhen``> Right.

[20:08] <Aankhen``> Will that change?  As in, is it incorrect behaviour?  Or unspecced behaviour?

[20:08] <autrijus> it has the same semantics as ::::('Foo');

[20:08] <autrijus> ooh ::::.

[20:09] <autrijus> Aankhen``: that is unspecced.

[20:09] <svnbot6> r5953 | Aankhen++ | * HTTP::Headers: fixed typo.

[20:09] <svnbot6> r5954 | autrijus++ | * add a Makefile.PL for URI.pm so it can be tested.

[20:09] <svnbot6> r5955 | Aankhen++ | * HTTP::Headers: added explicit invocant wherever required.

[20:09] <Aankhen``> I see.

[20:09] <autrijus> if you'd like to canonize it, please p6l it

[20:10] <autrijus> indeed the string treatment is ambiguous

[20:10] <autrijus> because the ::Foo lookup could mean the inner ::Foo or the global *Foo (when looked up inside the prim)

[20:11] <iblech> IIRC Larry said once it's ok, and stressed that it doesn't do a global lookup, but a normal one, exactly as if you had dropped the quotes.

[20:11] <autrijus> good. that does mean some very strange ::CALLER foo then

[20:11] <autrijus> ::::('CALLER::Foo')

[20:17] <Aankhen``> Anyone got enough knowhow to make the Proxy class actually act as a proxy?

[20:18] <autrijus> you mean in the current runcore?

[20:18] <autrijus> that needs a tie() implementation

[20:18] <autrijus> and a new IScalar instance

[20:20] <Aankhen``> OK...

[20:21] <autrijus> if you can wait, the new runcore supports that natively

[20:21] <svnbot6> r5956 | Aankhen++ |  r5981@tef-base:  Aankhen | 2005-08-01 01:50:21 +051800

[20:21] <svnbot6> r5956 | Aankhen++ |  * ported a few tests for HTTP::Headers.

[20:21] <Aankhen``> Sure.

[20:21] <autrijus> otherwise maybe try js first :)

[20:21] <Aankhen``> Bleh.

[20:21] * Aankhen`` adds --verbatim mentally.

[20:22] <autrijus> that's fine, it's a badge of pride that says "I'm using svk and I'm not afraid of let the world know"

[20:22] * clkao grins

[20:23] <Aankhen``> Heh.

[20:24] <Aankhen``> I'd be happy to do it every time ;-), but as it is, people think that I'm "karma whoring" since I usually write fairly detailed commit messages, and add a header line indicating the relevant files if it's multi-line...

[20:24] <Aankhen``> s/files/files or modules or whatever/

[20:25] <autrijus> I don't think people care about that at all :)

[20:26] * Aankhen`` shrugs.

[20:26] <Aankhen``> I'm just trying not to be a pain.

[20:26] * autrijus ponders "I'm a Karma Courtesan and I'm proud of it"

[20:26] <svnbot6> r5957 | autrijus++ | * elems() should only work on Arrays, so it's an array method now.

[20:26] <svnbot6> r5958 | putter++ | modules/Grammars/Perl6.pm: rule block { <[{]> ... <[}]> } works.  Some comments temporarily removed from rules.  I noticed two unresolved issues (PGE bugs?).  Some comments in rules cause PGE parse failures.  And <foo>? is matching things [<foo>]? doesnt.

[20:29] <Aankhen``> Do you have any idea of how long it'll be before the new runcore is up and, um, runcore-ing?

[20:29] <autrijus> I have no idea.

[20:30] <autrijus> depending on how demanding $work is, about a month probably

[20:31] <Aankhen``> OK.

[20:31] <Aankhen``> Was just looking for a general timeframe.

[20:32] <autrijus> nod.

[20:32] <svnbot6> r5959 | autrijus++ | * move infinity.t again to builtins/math/.

[20:32] <autrijus> I'm also shooting for soundness and completeness instead of speed this time

[20:32] <Aankhen``> Is this new runcore the implementation of docs/notes/plan?

[20:33] <autrijus> it's the haskell evaluator for PIL2

[20:33] <autrijus> yes

[20:33] <Aankhen``> Kewl

[20:33] <Aankhen``> .

[20:33] <Aankhen``> Welp, it sounds great to me.

[20:33] <autrijus> to me too :)

[20:33] <Aankhen``> Especially if it has Proxy support builtin. ;-)

[20:33] <autrijus> sure ;)

[20:33] <autrijus> is there a failing proxy.t?

[20:33] <clkao> Aankhen``: newer svk will have command/path option matching hooks. so you can say for //pugs i want --verbatim in push

[20:34] <Aankhen``> autrijus: A TODO'd failing proxy.t, yes.

[20:34] <autrijus> good

[20:34] <Aankhen``> clkao: Sweet!

[20:34] <clkao> but it doesn't exist yet, wanna help? :)

[20:34] <Aankhen``> Heh.

[20:34] <Aankhen``> I wish I could atleast build it on Windows.

[20:35] <autrijus> if not for iblech's amazing work, I'd be aiming to use compile-to-perl5 as the reference compiler (while the haskell runcore being the reference interpreter)

[20:35] <clkao> how much tests are passing now in js?

[20:35] <autrijus> clkao: over 50%!

[20:35] <iblech> clkao: 57.07%

[20:35] <iblech> :)

[20:35] <Aankhen``> clkao: I would like to help, but not sure I will be able to.

[20:36] <Aankhen``> I'm not sure, even.

[20:36] <clkao> crazy folks

[20:36] <autrijus> but now it's even better; if js/p5 codegen does duplicated post processing then we know it should be pushed back to PIL level

[20:37] <autrijus> e.g. lexical hoisting

[20:37] <Aankhen``> Neat.

[20:37] <Aankhen``> iblech++

[20:37] <autrijus> iblech++

[20:38] <iblech> Pugs++ # does most of the work (parsing and emitting PIL) :)

[20:39] <autrijus> life++ # lots of fun

[20:39] * autrijus goes fixing $CALLER::_... should be <50 failures after that

[20:39] <autrijus> it's amazing how hundreds of failing tests gets produced every week or so.

[20:41] * Aankhen`` goes to sleep.

[20:41] <Aankhen``> G'night.

[20:41] <autrijus> 'nite Aankhen``

[20:42] <autrijus> hm

[20:42] <autrijus> sub{ say $CALLER::z }.() for 1

[20:42] <svnbot6> r5960 | iblech++ | * Usual svn props, including proper svn:ignore for docs/talks.

[20:42] <svnbot6> r5960 | iblech++ | * More work on talks/Anatomie_eines_Compilers_am_Beispiel_von_Pugs.latex.

[20:42] <autrijus> instant infinite loop

[20:44] <autrijus> iblech: 

[20:44] <autrijus> Umwandlung des Sourcecode in einen Abstract Syntax Tree

[20:44] <autrijus> I'd use Parse Tree for that

[20:44] <autrijus> AST is very overloaded... everything is AST :)

[20:44] <iblech> You can read German? :)

[20:44] <iblech> Good catch.

[20:44] <autrijus> yes, I stayed in .de for a year

[20:44] <autrijus> I can read most of your slides :)

[20:44] <iblech> :)

[20:44] <autrijus> so I laughed at 'als Übung' :)

[20:45] <iblech> :D

[20:50] <clkao> Ich spreche kein Deutsch!

[20:51] <autrijus> hahi buhuhi jihana nanigani!

[20:51] <svnbot6> r5961 | iblech++ | * t/operators/repeat.t -- unEVAL.

[20:51] <svnbot6> r5961 | iblech++ | * PIL2JS: Prelude::JS::Operators: Implemented &infix:<x> and &infix:<xx>, which

[20:51] <svnbot6> r5961 | iblech++ |   gives one additional unexpected success to PIL2JS. :)

[20:51] <svnbot6> r5961 | iblech++ | * docs/talks/Anatomie_eines_Compilers_am_Beispiel_von_Pugs.latex:

[20:51] <svnbot6> r5961 | iblech++ |   s/AST/Parse Tree/, autrijus++ for catching.

[20:51] <svnbot6> r5961 | iblech++ | * docs/talks/README: Added entry for ^.

[21:00] <svnbot6> r5962 | iblech++ | * t/operators/short_circuit.t: Minor cleanup.

[21:00] <svnbot6> r5962 | iblech++ | * PIL2JS: Prelude::JS::Operators: Implemented &infix:<^^> and &infix:<xor>,

[21:00] <svnbot6> r5962 | iblech++ |   short_circuit.t passes now (+30 successful tests (with 1 :todoed)).

[21:17] <svnbot6> r5963 | autrijus++ | * Trying to make unsafePerformIO safer with -fno-full-laziness

[21:17] <svnbot6> r5963 | autrijus++ |   -fno-cse and NOINLINE.  It feels almost like Scheme now!

[21:29] <svnbot6> r5964 | iblech++ | * util/gen_prelude.pl: Added autrijus's change of r5963 to gen_prelude.pl.

[21:29] <svnbot6> r5964 | iblech++ | * New test: t/builtins/io/exit.t, primarily used for PIL2JS.

[21:29] <svnbot6> r5964 | iblech++ | * Re-fixed t/operators/quoting.t (but normal runcore Pugs didn't bother).

[21:29] <svnbot6> r5964 | iblech++ | * PIL2JS:

[21:29] <svnbot6> r5964 | iblech++ |   * PIL2JS.js: Implemented &exit.

[21:29] <svnbot6> r5964 | iblech++ |   * Moved some operators from Prelude::JS::Operators to more appropriate

[21:29] <svnbot6> r5964 | iblech++ |     Prelude::JS::Str and Prelude::JS::Bool.

[21:29] <svnbot6> r5964 | iblech++ |   * Prelude::JS::Bool: Added &infix:<?|>.

[21:29] <svnbot6> r5964 | iblech++ |   * Prelude::JS: Added &infix:<=>.

[21:31] <autrijus> bbl &

[21:50] <iblech> Should $pair[0] and $pair[1] work?

[21:50] <iblech> t/data_types/pair.t suggests this

[22:09] <brentdax> Does 'trusts' work yet?

[22:10] <iblech> Probably not. But probably real privacy isn't there either, i.e. all classes trust all other classes.

[22:10] <svnbot6> r5965 | iblech++ | * Test fixes:

[22:10] <svnbot6> r5965 | iblech++ |   * magicals/subname.t, data_types/anon_block.t: unEVAL.

[22:10] <svnbot6> r5965 | iblech++ |   * data_types/pair.t: Test description fix.

[22:10] <svnbot6> r5965 | iblech++ |   * data_types/flattening.t: 3[0] should not work, but (3,)[0] should.

[22:10] <svnbot6> r5965 | iblech++ | * PIL2JS:

[22:10] <svnbot6> r5965 | iblech++ |   * PIL::Nodes, PIL2JS.js: $?SUBNAME.

[22:10] <svnbot6> r5965 | iblech++ |   * PIL2JS.js: Hacks: ::Num eq "Num", etc.

[22:10] <svnbot6> r5965 | iblech++ |   * PIL::Nodes, PIL::Parser: Accept macros as Codes.

[22:10] <svnbot6> r5965 | iblech++ |   * Prelude::JS:: Added .perl stub.

[22:10] <svnbot6> r5965 | iblech++ |   * Prelude::JS::Pair: Moved &infix:?\194?\171=>?\194?\187 here and added support for lvalue pairs.

[22:12] <brentdax> Nope... No compatible subroutine found: "&:foo"

[22:12] <brentdax> Guess I'll just use underscores instead of colons and put in a comment to change it later.

[22:13] <iblech> Also, have you read Larry's recent post on p6l about changing :foo to _foo and other things?

[22:14] <brentdax> Yeah, but I don't like it, and I'm writing this to run on Pugs anyway.

[22:15] <brentdax> (That is, I'm not going to make my code *not* express the correct semantics on a current Pugs when I'm hoping the ruling will change anyway.  And I haven't been touching the Pugs core anyway.)

[22:43] <iblech> http://m19s28.vlinux.de/iblech/stuff/not_perm/pil2js-demo/t/smoke.html # Yay, 5% more tests passing, we're not at 62.03% :)

[22:43] <iblech> s/not/now/

[22:44] <svnbot6> r5966 | iblech++ | t/builtins/io/time.t: unEVAL.

[22:54] <iblech> Night all :)

[23:42] *** mugwump_ is now known as mugwump

