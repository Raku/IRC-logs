[00:00] *** avarab is now known as avar

[00:24] <luqui> stevan, oh, don't worry, I'm highly inconsiderate as far as keeping what is already there

[00:24] <luqui> :-)

[00:49] <svnbot6> r8464 | luqui++ | Brand spankin' new, spectacularly extensible, extremely role-based, marvelously broken architecture for Parse::Rule.

[00:49] <svnbot6> r8465 | luqui++ | Added my architecture design doc.

[00:51] * clkao wonders why ` in pil ;)

[00:51] <luqui> they need a character other than .

[00:52] <luqui> and ` kinda looks like a dot on the top of the screen

[00:52] <luqui> er, line

[00:53] <clkao> i thought audreyt will use funky things like â˜ž

[00:53] <luqui> heh... other people have to type it too, you know

[00:54] <clkao> luqui: what happened to svk today?

[00:55] <luqui> I don't know

[00:55] <luqui> I pushed and it tried to merge a bunch of stuff that I had already pushed

[00:55] <luqui> giving me conflicts, since I had changed it since then

[00:56] * luqui supposed he should have saved the dialog

[00:58] <clkao> eek.

[01:37] <svnbot6> r8466 | luqui++ | It seems that the array context fix broke multiple

[01:37] <svnbot6> r8466 | luqui++ | inheritance.  (Didn't seem like those would be related,

[01:37] <svnbot6> r8466 | luqui++ | but you never know)   Fixed.

[02:07] <svnbot6> r8467 | luqui++ | All tests again pass.  The architecture move is complete!

[02:37] <svnbot6> r8468 | luqui++ | Medium- and strategy-independent interface.

[02:43] <clkao> audreyt: do i still need this:

[02:43] <clkao> +            let caller  = maybe "main" envPackage (envCaller env)

[02:43] <clkao> in Parser.hs ?

[02:48] <luqui> that actually looks a little dangerous

[02:49] <clkao> it's a bandaid for export bug

[02:50] <luqui> If you're trying to export but you don't have a caller, it should probably blow up

[02:56] <asavige> anyone there to help haskell beginner?

[02:56] <asavige> i'm trying to write my first haskell program for cheap thrills

[02:56] <luqui> I can.  Just a sec though

[02:59] <svnbot6> r8469 | Darren_Duncan++ |  r1634@Darren-Duncans-Computer:  darrenduncan | 2005-12-26 18:57:21 -0800

[02:59] <svnbot6> r8469 | Darren_Duncan++ |  /ext/Rosetta-Incubator : added new files lib/Locale/KeyedText/L/en.pm (start of LKT itself using Message exceptions) and lib/SQL/Routine/Migration.pod (start of a guide to translate between languages); small KeyedText.pm update

[03:00] <luqui> asavige, mmkay

[03:00] <asavige> i'm in ghci, loaded my little function and can evaluate it ok .. but I want to trace it

[03:00] <asavige> when i try putting trace before the function i get Not in scope: trace

[03:00] <luqui> import Debug.Trace

[03:01] <luqui> oh, in ghci

[03:01] <luqui> :module +Debug.Trace

[03:01] <luqui> (add Debug.Trace to the list of "search paths" for functions)

[03:04] <luqui> asavige, don't be afraid to ask over at #haskell too, but the answers get very detailed and stylistic

[03:04] <luqui> like asking a beginner perl question at #perl

[03:04] <luqui> nobody knows how to talk to beginners

[03:09] <phredmoyer> except other beginners :)

[03:09] <luqui> :-)

[03:09] <luqui> I always think that pedagogy is more an art than a science.  One teacher can usually explain things really well.

[03:09] <luqui> Ten give away too much and too little information at the same time.

[03:26] <asavige> ok, finally got it to work after grepping for trace in Pugs code

[03:27] <asavige> it seems trace is very, er, manual, you insert the statements ok for monads

[03:27] <asavige> but can you use trace for non monads?

[03:27] <asavige> (i haven't got up to monads yet)

[03:27] <asavige> is there a more generic less intrusive trace facility so i can just see what is going on when i evaluate a function

[03:29] <asavige> just a couple more general haskell questions, then I'll leave you in peace

[03:30] <asavige> is there a standard stack class in haskell std library?

[03:30] <asavige> what about hashes?

[03:30] <luqui> sorry, was afk

[03:30] <luqui> asavige, no, trace works even outside of monads

[03:30] <asavige> finally does haskell support exceptions try/catch? if so, what are they called? (i know about "error" function)

[03:31] <luqui> asavige, there's not much reason for a stack class, since a cons list works well for that as it is

[03:31] <luqui> asavige, haskell has exceptions within monads

[03:32] <luqui> (Control.Exception)

[03:33] <luqui> asavige, trace works like so

[03:33] <luqui> trace "message" (foo bar)    -- prints message to the screen, then returns whatever foo bar returned

[03:33] <luqui> there's no such thing as a statement boundary, so you have to "pass values through" trace

[03:34] <luqui> asavige, oh yeah, and there is a hash.  It's called Data.Map

[03:34] <luqui> (well, it's not technically a hash, but it does the same thing)

[03:34] <asavige> ahhh beauty! got it now. with this new trace-foo I'll be unstoppable ;)

[03:34] <asavige> thanks luqui!

[03:34] <luqui> sure

[03:35] <luqui> oh, and when using trace, remember that haskell is lazy so it doesn't surprise you

[03:35] <luqui> that is:  let foo = trace 42 in bar   -- where bar doesn't depend on foo

[03:35] <luqui> will not print anything to the screen

[03:36] <luqui> oh, s/trace/trace "baz"/

[03:38] <luqui> asavige, one more thing

[03:38] <luqui> do you know about "show"?

[03:39] <asavige> luqui: no

[03:39] <luqui> ahh, that can be helpful with trace

[03:39] <luqui> show turns various values into strings

[03:39] <luqui> so you can say:  trace ("got here with " ++ show myvalue ++ "fine") etc

[03:40] <luqui> but it won't do it with any value (functions for example don't work), so be prepared for it to whine at you

[03:41] <asavige> thanks, i remember now, i lied, I read about show and its opposite read (but no practical experience yet)

[03:41] <luqui> okay cool

[03:42] <asavige> thanks luqui++

[03:59] <svnbot6> r8470 | luqui++ | Changed $/.start and $/.end to $/.from and $/.to, as per spec.

[04:25] <phredmoyer>   hey is there some conduit to donate to the pugs project?  There's perl development on TPF but they have about $90k and I am interested in giving to the PUGs dev

[04:26] <Alias_> Just write a cheque for My C. Ash and send it to my address

[04:26] <Alias_> Mr

[04:27] <phredmoyer> lol

[04:28] <luqui> phredmoyer, are you serious?

[04:28] <phredmoyer> seriously though, I am interested in donating.  Would do so through TPF but I want to know that it's going to to pugs...

[04:29] <luqui> phredmoyer, you should tell TPF that you want it to go to pugs

[04:29] <luqui> I don't know much about TPF, but you can probably talk to obra and he'll get you on the right track

[04:30] <phredmoyer> who's obra? (on cli irc client)

[04:30] <luqui> jesse fsck com

[04:30] <luqui> Jesse Vincent

[04:30] <phredmoyer> ok

[04:31] <phredmoyer> gotta go, will email him.

[04:31] <luqui> thanks!

[04:31] <luqui> aww I missed him

[04:44] <svnbot6> r8471 | Darren_Duncan++ |  r1634@Darren-Duncans-Computer:  darrenduncan | 2005-12-26 18:57:21 -0800

[04:44] <svnbot6> r8471 | Darren_Duncan++ |  /ext/Rosetta-Incubator : added new files lib/Locale/KeyedText/L/en.pm (start of LKT itself using Message exceptions) and lib/SQL/Routine/Migration.pod (start of a guide to translate between languages); small KeyedText.pm update

[05:05] <obra> donating to pugs is still not trivial. 

[05:06] <luqui> how nontrivial?

[05:07] <obra> Well, first someone would need to apply for a grant for something pugs related

[05:08] <luqui> ah, that's how that works

[05:08] <luqui> maybe phredmoyer should apply

[05:08] <Alias_> Like a "keep audreyt now having to work" grant?

[05:08] <Alias_> s/now/not/

[05:09] <luqui> oh yeah, audreyt has been caught up in $work, hasn't he.  But I thought he didn't want grants.

[05:09] <Alias_> she, and not sure... would have to ask

[05:09] <luqui> damnit

[05:09] <luqui> :-)

[05:09] <Alias_> It will be a confusing month or two

[05:09] <luqui> that was the first time I used a pronoun for her, and I swore that I would get it right!

[05:10] <obra> She's getting there. She's hacking Jifty apps for customers ;)

[05:10] <Alias_> oh?

[05:11] <Alias_> Open Source ones presumably... unless they are paying that crazy $600 an hour proprietary rate...

[05:11] <obra> I don't believe they're open source, but I'll leave it to her

[05:11] * Alias_ nods

[05:21] <spinclad> it took me a while to figure out autrijus was from taiwan; the name sounded baltic to me...

[05:21] <spinclad> now i want to call her autrija ... must ask if ok first.

[05:21] <obra> spinclad: "Audrey" also works now

[05:22] <araujo> mm.. is autrijus == audreyt ?

[05:22] <obra> yes

[05:22] <spinclad> right, i've gathered... just wanting a least bend on 'autrijus'.

[05:22] <obra> &

[05:24] <spinclad> so... audreyt, question above?

[05:25] <qwr> iirc audreyt = audrey tang

[05:25] <Alias_> formerly Autrijus Tang

[05:29] <spinclad> she's blogged about this lately; see http://pugs.blogs.com/audrey/2005/12/runtime_typecas.html

[05:29] <araujo> mm.. she? :-/

[05:31] <spinclad> with full respect for her preference and self-understanding, yes.

[05:32] <araujo> oh, ok.

[05:34] <spinclad> a change like this takes some getting used to, but i know others (transgender/transsexual/whatever-term-applies) and i know it's important.

[05:39] <spinclad> i was away (sort of) for much of november and came back to a new name (and person, in a way) to make sense of, along with the rest of the community.

[05:41] <spinclad> anyway, i was most happy to see her blog lately.  audreyt, may this change find you safe, happy, and well!

[05:42] <spinclad> </OT>

[06:43] <audreyt> rehi

[06:43] <audreyt> spinclad: thanks! *smile*

[06:44] <luqui> audreyt, I can't figure out the best interface for the subrule combinators

[06:44] <luqui> s/s$//

[06:44] <audreyt> luqui: mmm?

[06:44] <audreyt> I see you are using (sort of) multiparameter roles

[06:45] <luqui> I am?

[06:45] <audreyt> yeah, except you call an instance "class" 

[06:45] <svnbot6> r8472 | audreyt++ | * As lexical import is implemented correctly by gaal++,

[06:45] <svnbot6> r8472 | audreyt++ |   we no longer need the withInlinedIncludes hack to get

[06:45] <svnbot6> r8472 | audreyt++ |   "use" statements working with PIL-based compilation.

[06:45] <svnbot6> r8472 | audreyt++ |   Thanks to clkao++ for prompting this fix.

[06:45] <audreyt> and encode the strategy part and media part as separate role mixins

[06:46] <luqui> oh yeah, it's a level of indirection to get around the absence of such roles

[06:46] <audreyt> luqui: but anyway. elaborate on the subrule combinator problem?

[06:46] <audreyt> *nod*

[06:47] <luqui> we're not lazy, so we can't just build recursive combinators like you do in haskell

[06:47] <luqui> and in any case, I'd like to be able to compile subrules

[06:47] <luqui> so "execute a closure that returns a Parser" doesn't work

[06:47] <luqui> and I'd also like subrules to take arguments

[06:48] <audreyt> you can make a strict language lazy by creating a closure that takes nil

[06:48] <audreyt> oh wait, arg-taking subrules

[06:48] <luqui> (as I've done many times ;-)

[06:48] <audreyt> hmm, that's hard

[06:48] <audreyt> you can still build recursive combinators

[06:48] <audreyt> using a level of reference

[06:49] <luqui> well, the recursive combinators isn't really what I'm concerned about

[06:49] <luqui> compilation is the bigger problem

[06:49] <audreyt> compile in two passes?

[06:49] <audreyt> or keep a .id-based cache

[06:49] <audreyt> and inject previously compiled results in

[06:49] <audreyt> memoize on arguments

[06:50] <luqui> hmm...

[06:50] <luqui> that's almost like packrat

[06:50] <audreyt> I think it's a cheap and cheerful fix

[06:50] <luqui> except not... nevermind

[06:50] <luqui> it seems like that would be extremely memory hungry

[06:51] <luqui> what I'm doing right now is having a Parser and a Rule, where Rule is a compiled form of Parser

[06:51] <luqui> and then the subrule combinator calls a closure which returns a *Rule*

[06:51] <luqui> supporting precompiled results

[06:51] <audreyt> I don't see the memory hungry part. are you concerned that memoize will not be GC'ed away in time?

[06:51] <luqui> oh... right... memoization gets GC'd

[06:51] <audreyt> yup

[06:51] <audreyt> and we are _not_ refcounting

[06:52] <audreyt> so selfref is just fine

[06:52] <luqui> can I make a memoization in pugs now?

[06:52] <luqui> (except... I don't really care, because I don't have a compiling runtime yet)

[06:52] <audreyt> nod

[06:52] <audreyt> just fake it as a per-sub-attached hash for now

[06:53] <luqui> hang on---

[06:53] <luqui> what if arguments are passed through the match object..

[06:53] <clkao> iblechbot!

[06:53] <audreyt> iblechbot: PIL2JS fails on @array.shift in shift.t (same for pop)

[06:53] <luqui> that doesn't seem to buy me anything... nevermind

[06:54] <audreyt> iblechbot: it seems that @array.shift is turned into shift(*@array) -- clkao and I suspect autoderef semantics in the dispatcher to Root::shift

[06:54] <audreyt> iblech: but I'm not sure if that's the correct reading

[06:56] <gaal> heya!

[06:56] <luqui> audreyt, so can the subrule(&code:(Match --> Rule)) interface support such memoization...

[06:56] <luqui> (I'm still not clear how that would work)

[06:57] <gaal> audreyt: can you suggest a next move on the import game? fold reduceSy{m/n} into ruleVarDeclaration?

[06:57] <audreyt> gaal: PIL2JS now supports lexical imports!

[06:57] <gaal> !

[06:57] <audreyt> <- hackathon'ing with clkao

[06:57] <gaal> for vars as well?

[06:57] <audreyt> all it takes is just _removing_ the withInlinedIncludes paragraph in Pugs.hs

[06:58] <gaal> Carter's Compass, isn't that's what it's called?

[06:58] <audreyt> mmm?

[06:58] <gaal> "I know I'm in the right direction when by removing code I'm adding functionality"

[06:58] <audreyt> right

[06:58] <gaal> or something to that effect.

[06:59] <audreyt> gaal: is lexical varimport working in vanilla runcore?

[07:00] <gaal> no, that doesn't even parse.

[07:00] <gaal> I left it off last week when there was a shortage of tuits and an unexpected comlication:

[07:01] <gaal> if you recall, allocating space happens in eval (reduceSym)

[07:01] <audreyt> yes

[07:01] <gaal> and chaining got in the way too. So chaining will have to move away for a bit :-)

[07:02] <gaal> but should I just inline the reduceSym code into ruleVarDeclaration and use its temporary values in the exportation?

[07:02] <audreyt> I think that's sane

[07:02] <audreyt> as we already agreed exporting lexical reentrant "my" vars is insane

[07:03] <gaal> okay. brb w/coffee.

[07:04] <svnbot6> r8473 | luqui++ | Subrule support.

[07:06] <audreyt> I'll brb as well

[07:07] <dduncan> hidee-ho

[07:07] <audreyt> Alias_: re open sourcesness of my Jifty app -- $company agreed to make all reusable part free software, and I can refactor any production code out freely

[07:07] <audreyt> dduncan: yo

[07:08] <Alias_> audreyt: neato... and I would too if it saved me $400-500 an hour :)

[07:08] <audreyt> yeah :)

[07:08] <Alias_> I'm surprised clients are commisioning Jifty apps when it's only been out for 1 day though

[07:08] <Alias_> You must know clients that live more on the edge :)

[07:08] <audreyt> er, actually, it's been around a while before that

[07:08] <dduncan> since there doesn't seem to be any movement that I'm aware of about scoping $! as an env, any time soon, I will incorporate workarounds into my code, so it doesn't suffer from untimely wipeouts

[07:09] <audreyt> dduncan: nod, I think that's prudent. sorry about that

[07:09] <luqui> all-rightythen... it seems I am ready to start on OPP

[07:10] <dduncan> not your fault per se ... p6l has to change the spec first, don't they?

[07:10] <audreyt> dduncan: yup

[07:10] <audreyt> I'm just this... coding monkey

[07:10] <dduncan> separately, whether due to something specced or not, I discovered how to determine if a package is loaded or not

[07:11] <dduncan> incorporation of that was checked in yesterday

[07:11] <audreyt> cool! how?

[07:11] <luqui> oh audreyt, do you think you could make it so that pugs-interactive doesn't care about trailing semicolons?

[07:11] <dduncan> test the value of ::($foo).ref

[07:11] <dduncan> it is 'Type' if the package isn't loaded

[07:11] * Alias_ takes notes for P6 Class::Inspector

[07:11] <dduncan> if the package is loaded, it is 'Module' or 'Class' or whatever

[07:11] <audreyt> dduncan: cool

[07:12] <dduncan> package named in $foo that is

[07:12] <dduncan> I don't know why that works, but it does the job

[07:13] <dduncan> see, for example:

[07:13] <dduncan> ?eval ::('Foo').ref

[07:13] *** evalbot_8444 is now known as evalbot_8473

[07:13] <evalbot_8473> ::Type 

[07:13] <audreyt> luqui: sure, implemented, committing

[07:13] <luqui> audreyt, thanks :-)

[07:13] <audreyt> :)

[07:13] <dduncan> ?eval module Foo {} ::('Foo').ref

[07:13] <evalbot_8473> ::Module 

[07:14] <dduncan> ?eval class Bar {} ::('Bar').ref

[07:14] <evalbot_8473> ::Class 

[07:14] <GeJ> greetings all

[07:14] <audreyt> it's nice seeing #perl6 back to constant activity/hacking :)

[07:14] <dduncan> ?eval package Baz {} ::('Baz').ref

[07:14] <evalbot_8473> ::Package 

[07:14] <audreyt> GeJ: greetings

[07:14] <GeJ> audreyt & stevan: congrats for PIL^N

[07:14] <dduncan> this is predictable, but in the longer term something more self-documenting should be available

[07:15] <dduncan> some meta-module function

[07:15] <audreyt> dduncan: yup

[07:16] <dduncan> on other notes, I discovered your moved journal and read the latest

[07:16] <dduncan> so I see your intentions for release dates

[07:17] <audreyt> yup

[07:17] <svnbot6> r8474 | audreyt++ | * In Pugs shell, drop all trailing whitespace and comma in

[07:17] <svnbot6> r8474 | audreyt++ |   interactive evaluated code.  Suggested by luqui++.

[07:18] <audreyt> GeJ: thanks! :)

[07:20] <svnbot6> r8475 | audreyt++ | * Data.FastPackedString: a specialized fast packChar.

[07:25] <gaal> ?eval ::('NoSuch').ref

[07:25] *** evalbot_8473 is now known as evalbot_8475

[07:25] <evalbot_8475> ::Type 

[07:29] <gaal> say, is reverse . <filter> . reverse fast in haskell, when the data is strictly a String?

[07:30] * gaal wants to see a discussion of how lists are implemented for special cases

[07:30] <gaal> or is that e.g. precisely why there's Data.FastPackedString etc?

[07:32] <audreyt> gaal: it's very space-inefficient

[07:32] <audreyt> and yes, that's why the PIL^N runcore switched to FPS

[07:32] <audreyt> and why Text.Parser.OpTable parses against FPS

[07:32] <audreyt> a linked list of UTF32 code points is simply too inefficient.

[07:33] <audreyt> (it's very convenient though.)

[07:33] <gaal> sure

[07:33] <audreyt> gaal: also, for randomly accessible growable arrays, instead of [a] we now use "Seq a"

[07:33] <gaal> Theoretically GHC could optimize in some cases, no?

[07:33] <audreyt> yes, GHC optimizes whenever "fusion" occurs

[07:33] <gaal> "could have optimized"

[07:34] <audreyt> and I think double reverse counts as fusion

[07:34] <audreyt> but not 100% sure

[07:34] <gaal> fusion == ?

[07:34] <audreyt> fusion is that a list producer and a list consumer can both handle things lazily

[07:34] <svnbot6> r8476 | Darren_Duncan++ |  r1641@Darren-Duncans-Computer:  darrenduncan | 2005-12-26 23:33:48 -0800

[07:34] <svnbot6> r8476 | Darren_Duncan++ |  /ext/Rosetta-Incubator : updated translate_message() of Locale::KeyedText to make a copy of $message arg, working around crashes caused by  being scoped globally

[07:35] <gaal> interesting: and there I was imagining that strictness would help things

[07:35] <gaal> but I can see why laziness if better in this case

[07:35] <audreyt> cf. http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3153312

[07:36] <dduncan> er, s//$!/

[07:36] <dduncan> I keep forgetting to escape some $ in the shell

[07:37] <audreyt> gaal: hm, there's no fusion rule for "reverse"

[07:37] <gaal> "forestation"... /me has some more to read up on :)

[07:39] <gaal> in the code generated for a list, are there sometimes backwards pointers + a size field?

[07:39] <gaal> this is interesting but distracting stuff :)

[07:39] <audreyt> and the short answer is no :)

[07:40] <gaal> sometimes a list doesn't even have next pointers per se, right? just a next thunk

[07:40] <gaal> ...lazy

[07:40] <audreyt> s/sometimes/always/

[07:41] <gaal> so reverse 1 .. 100 is very costly

[07:41] <gaal> well, I bet it's at least memoized

[07:41] <gaal> but still.

[07:42] <audreyt> yeah

[07:42] <audreyt> [100,99..1]

[07:42] <audreyt> is much better

[07:42] <gaal> I will resist reading more about this now. :)

[07:43] <audreyt> :)

[07:44] <gaal> in Eval, there's a special case I don't understand for reduceSym:

[07:44] <gaal> "Special case: my (undef) is no-op"

[07:44] <gaal> when does that happen?

[07:44] <gaal> reduceSym _ "" exp

[07:45] <gaal> probably some artifact of one of the parser rules needing to change their minds about a symbol?

[07:45] <audreyt> my (undef, undef, $x) = (1,2,3);

[07:46] <gaal> ah!

[07:46] <gaal> right. I like that syntax.

[07:46] <audreyt> DWIM kicks! DWIM bites! DWIM casts a spell! You feel dizzy... --More--

[07:47] <gaal> :)

[07:47] <gaal> my undef is export; # sounds like a Wallace Stevens poem

[07:48] <audreyt> my () is export;

[07:48] <gaal> my $bonnie is over_the(:ocean);

[07:49] <audreyt> Poetry Elucidation and Resonance Language

[07:50] * luqui read Elucidation as Eucliedean

[07:50] <luqui> that's how you know you've been a math major too long

[07:50] <luqui> s/lied/lid/ :-)

[07:51] <gaal> http://www.cs.rice.edu/~ssiyer/minstrels/poems/604.html

[07:52] <luqui> gaal, :-)

[07:53] <luqui> too bad I'm so terrible at interpreting poetry.  It had beautiful rhythm and rhyme though...

[07:55] * nothingmuch got his lost roll of 120 slide film developed

[07:55] <nothingmuch> got the pictures from canada

[07:55] <gaal> luqui: it's a purer version of "C-beams glitter in the dark near the Tannhauser Gate".

[07:55] <nothingmuch> well, one picture from canada

[07:55] <nothingmuch> a siluhette of $Larry hand-waving

[07:56] <nothingmuch> well, no, more pictures from canada were also taken

[07:56] <gaal> nothingmuch: any moose?

[07:56] <nothingmuch> but none of you guys, except castaway and theorbtwo and John actually came out of the building =)

[07:56] <nothingmuch> gaal: nope, didn't see any

[07:56] <nothingmuch> i have a shirt with a camel-moose though

[07:57] <gaal> Toronto used to have plenty of moose-statues on the streets

[07:58] <gaal> this is now mimiced by so many cities

[07:58] <gaal> Tel-Aviv now has a silly bull stint. I hate it.

[07:58] <luqui> audreyt, what is DynTerm/DynStr?

[07:59] <luqui> haha: instance Ord DynStr where compare _ _ = LT

[07:59] <luqui> every DynStr is less than every other

[08:00] <gaal> luqui: it's a lesson in modesty.

[08:01] <luqui> "all dynstrs are less, but some are more less than others"

[08:02] <gaal> eeeep! $Larry mentions this in his latest post:    my *@s := @a[0,2,4];

[08:02] <gaal> that would be interesting to implement.

[08:02] <luqui> why?

[08:02] <luqui> you have to do it anyway for argument binding, don't you?

[08:03] <gaal> hmm, I suppose so, yes.

[08:03] <luqui> (that's how he came up with it, after all)

[08:07] <luqui> ?eval 3/4

[08:07] *** evalbot_8475 is now known as evalbot_8476

[08:07] <evalbot_8476> 3/4 

[08:07] <luqui> when did that happen

[08:07] <luqui> ?eval 3.4/8.2

[08:07] <evalbot_8476> 17/41 

[08:08] <luqui> how do I get floats?

[08:09] <luqui> ?eval 1/2**100

[08:09] <evalbot_8476> 1/1267650600228229401496703205376 

[08:11] <scook0> ?eval sqrt( (3/4) ** 2 )

[08:11] <evalbot_8476> 0.75 

[08:11] <gaal> ?eval 3.4/8.2+0

[08:11] <evalbot_8476> 17/41 

[08:11] * scook0 ducks

[08:11] <gaal> ?eval (3.4/8.2)+0

[08:11] <evalbot_8476> 17/41 

[08:11] <gaal> ?eval +(3.4/8.2)

[08:11] <evalbot_8476> 17/41 

[08:12] <luqui> ?eval 3.4/8.2 + pi/pi

[08:12] <evalbot_8476> 1.4146341463414633 

[08:12] <gaal> contagious rats.

[08:12] <luqui> I think that things with decimal points should be doubles

[08:12] <gaal> ha, pi/pi's a nice idiom for the transcendental.

[08:13] <luqui> I'm actually overjoyed that rationals are so prevelant

[08:13] <luqui> but they can quickly eat up all your memory if you're doing something like, oh, say, computing mandelbrot

[08:13] <luqui> probably processor first, actually

[08:14] <audreyt> luqui: pong

[08:14] <audreyt> I changed DynStr

[08:15] <luqui> what do you mean you changed it?

[08:15] <audreyt> I mean it works

[08:15] <audreyt> svk up

[08:15] <svnbot6> r8477 | audreyt++ | * Text.Parser.OpTable: Implement DynStr correctly and removed

[08:15] <svnbot6> r8477 | audreyt++ |   the horrible emptyTerm/emptyOper hack in original PGE.

[08:15] <svnbot6> r8476 | Darren_Duncan++ |  r1641@Darren-Duncans-Computer:  darrenduncan | 2005-12-26 23:33:48 -0800

[08:15] <svnbot6> r8476 | Darren_Duncan++ |  /ext/Rosetta-Incubator : updated translate_message() of Locale::KeyedText to make a copy of $message arg, working around crashes caused by  being scoped globally

[08:15] <audreyt> pull, Imean

[08:15] <luqui> I did that right as you said you changed it and saw nothing ;-)

[08:15] <audreyt> look at r327

[08:16] <luqui> but then I did it again

[08:16] <audreyt> yeah, commit takes ~3 secs :)

[08:16] <audreyt> see line 327

[08:16] <audreyt>     , mk Term            (span isDigit)

[08:16] <audreyt> the idea of dynterm is that it parses a term first

[08:16] <audreyt> and then calls a sub to attempt parse more

[08:17] <audreyt> only if that sub succeeds, the match is considered complete

[08:17] <luqui> I don't quite understand.  Kind of like "ask if this is a listop"?

[08:17] <audreyt> no...

[08:17] <audreyt> for example, if you want to parse $1, $5, $945 as a term

[08:17] <audreyt> then you create a DynTerm

[08:17] <audreyt> with str as '$'

[08:18] <luqui> ahh

[08:18] <audreyt> and dynStr as (makeMaybe $ span isDigit)

[08:18] <audreyt> where makeMaybe rejects empty span

[08:18] <audreyt> useful stuff

[08:18] <luqui> well, I suppose

[08:19] <luqui> seems like a speed hack to me

[08:19] <luqui> (a very good and honest hack)

[08:19] <audreyt> also the dyn part is expected to be able to change opTable

[08:20] <luqui> can't opTable just call back into the rule parser?

[08:20] <luqui> (hmm, but I wonder if it should be able to call back into a *different* parser)

[08:20] <audreyt> yes.

[08:20] <luqui> (for pre-tokenized stuffs)

[08:20] <audreyt> so needs an generic interface

[08:20] <audreyt> yup

[08:21] <luqui> no, not really

[08:21] <luqui> pre tokenized stuffs would use a tokenlist medium

[08:22] <luqui> why does DynStr return (Str,Str)?

[08:23] <luqui> why two of them?

[08:23] <cm> ola

[08:23] <luqui> (initial,remainder)?

[08:24] <audreyt> yeah

[08:24] <audreyt> matched,remainer

[08:24] <luqui> that's what I meant

[08:24] <luqui> okay

[08:24] <audreyt> a lookafter will return initial

[08:24] <audreyt> but preserve remainder

[08:24] <audreyt> so can't just return a splitAt pos

[08:24] <audreyt> s/lookafter/lookahead/

[08:25] <luqui> ahh

[08:25] <gaal> urp. folding in reduceSym isn't enough, duh; I'd need to replace two unsafeEvalXXX functions.

[08:25] <cm> *folds audreyt*

[08:25] <luqui> okay, I think I can do the OPP parser now

[08:26] <luqui> still using this as a reference

[08:26] <gaal> argh! it's not even possible to refactor unsafeEvalEtc. funcs to accept a callback, because it needs to go all the way down to reduce. :-(

[08:26] <luqui> gaal, what are you trying to do?

[08:28] <luqui> audreyt, one more thing... what is Close?

[08:29] <gaal> luqui: export variables. the difficulty is that their memory is allocated in Eval, not the parser.

[08:29] <gaal> as opposed to Subs, where the mkCode was in Parser, making export much easier.

[08:30] <luqui> sub foo () { my $x is export; ... }

[08:30] <audreyt> luqui: Close is the closing part of a circum

[08:31] <luqui> you add that automatically when someone declares a circumfix?

[08:31] <audreyt> in circumfix:<[ ]>, the close:<]> token is manufactured

[08:31] <audreyt> yeah, and postcircum

[08:31] <luqui> okay, fair enough

[08:31] <audreyt> luqui: OpTable-mutator is in

[08:31] <luqui> oh, and rationals get rid of the whole string-compare trick

[08:31] <luqui> I was rather pleased to see that

[08:31] <svnbot6> r8478 | audreyt++ | * Text.Parser.OpTable - DynStr can now return a function that

[08:31] <svnbot6> r8478 | audreyt++ |   modifies the operator table for the remainer of parse.

[08:32] <audreyt> luqui: I think the string compare trick is _broken_ in PGE

[08:32] <audreyt> from what I see, a trailing ">" will continue be a trailing ">"

[08:32] <audreyt> even if it's specified twice

[08:32] <gaal> luqui: that line you just said would probably not be allowed

[08:32] <audreyt> since it's using substr($level, -1) to substitute

[08:32] * luqui knows

[08:32] <audreyt> but of course I may've read the assembly wrong

[08:32] <luqui> (re: gaal)

[08:32] <audreyt> in any case I much prefer rationals.

[08:33] <luqui> does the math you're doing work?

[08:33] <audreyt> you mean multiplying by 1.5 and 0.5 respectively?

[08:33] <luqui> yeah

[08:33] <luqui> oh, ternary

[08:33] <gaal> .oO( not that I see why we need to allow sub foo { our $x is export } )

[08:33] <luqui> base 3, no?

[08:34] <audreyt> yeah

[08:34] <luqui> that makes sense

[08:34] <audreyt> cool

[08:34] <audreyt> wlel, it's actually still binary

[08:34] <audreyt> because for "=" equiv you don't touch the number

[08:34] <audreyt> for ">" you add a trailing 0

[08:34] <audreyt> for "<" you dec by 1 and add trailing 1

[08:35] <audreyt> if the match doesn't work, feel free to fix it :)

[08:35] <audreyt> s/match/math/

[08:35] <luqui> I'll attempt to prove that it works before using it

[08:35] <audreyt> cool

[08:35] <luqui> got to put my school skills to work somehow

[08:35] <audreyt> I hope my use of implicit params is grokkable to you

[08:36] <audreyt> it's just writing Reader monad code in direct style

[08:36] <luqui> implicit params?

[08:36] <audreyt> ?tbl

[08:36] <audreyt> ?termStack

[08:36] <audreyt> they are like $+tbl

[08:36] <audreyt> glasgow haskell has native support for "env" vars

[08:36] <audreyt> and let-binding introduces new env

[08:37] <luqui> oh cool

[08:37] <luqui> wow perl is so original :-p

[08:37] <audreyt> let ?tbl = (transform ?tbl)

[08:37] <audreyt> heh :)

[08:37] <nothingmuch> where are env vars described?

[08:37] <luqui> I'll figure it out

[08:37] <luqui> S02

[08:37] <nothingmuch> s06 only mentions them

[08:37] <nothingmuch> ah

[08:37] <audreyt> the GHC implementation is  http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters

[08:38] <audreyt> note that in GHC, whether you accept env or not must be marked in type signature

[08:38] <audreyt> if you don't declare you want caller's env, you don't get them

[08:38] <audreyt> for speed reasons and type soundness

[08:38] <nothingmuch> ++

[08:38] <luqui> thus type Parse a?

[08:38] <audreyt> in p6 I imagine we always get the whole env stack? or do we hoist $+foo like $^foo?

[08:38] <audreyt> luqui: yup

[08:39] <luqui> ?

[08:39] <audreyt> Parse a is something that receives the env vars and has type a

[08:39] <luqui> you can return it?

[08:39] <luqui> that is, the function depends on ?tbl

[08:39] <audreyt> sure

[08:39] <luqui> do you return something that depends on ?tbl and it works?

[08:39] <audreyt> yup

[08:39] <luqui> okay

[08:39] <luqui> oh yeah, because return is covariant

[08:39] <nothingmuch> audreyt: what about '$( '+foo' ) ?

[08:40] * luqui feels stuff starting to make sense

[08:40] <nothingmuch> or do we need $+( 'foo' )?

[08:40] <audreyt> nothingmuch: I have no idea

[08:40] <audreyt> I imagine we just pass the whole frame around

[08:40] <audreyt> very slowly but surely

[08:40] <nothingmuch> continuations would be ouch wouchy

[08:41] <audreyt> yeah

[08:41] <nothingmuch> env lexicals are just regular lexicals that arrange in a graph though, right?

[08:41] <nothingmuch> i mean, if you look at 'sub { ... {  } ... }'

[08:41] <nothingmuch> the pads are chained

[08:41] <audreyt> env lexicals are things you pass implicitly to every function you call in your scope.

[08:41] <nothingmuch> env just means that you can chain pads dynamically instead of lexically

[08:41] <nothingmuch> right

[08:41] <nothingmuch> no need to pass the whole frame around

[08:41] <nothingmuch> just a pointer

[08:42] <nothingmuch> to the most recently declared env

[08:42] <nothingmuch> linked list of pads for in->out lookup

[08:42] <luqui> that puts the cost on lookup

[08:42] <luqui> which seems better than putting the cost on closure

[08:43] <nothingmuch> luqui: $+foo could be statically resolved into a hidden parameter

[08:43] <nothingmuch> while $( "+foo" ) would have expensive lookup

[08:43] <luqui> yes, if we can do such static binding

[08:43] <nothingmuch> we can

[08:43] <luqui> hmm... when you don't know, you just fill it in on demand

[08:43] <luqui> okay, I see that

[08:43] <nothingmuch> just add a $plus_foo_for_this_func to every caller of this_func that

[08:43] <nothingmuch> that has $+foo somewhere in it's env

[08:44] <nothingmuch> statically resolved env

[08:44] <luqui> I'm just thinking about function pointers

[08:44] <nothingmuch> it's just a matter of callgraph walking

[08:44] <nothingmuch> i don't understand the connection

[08:44] <nothingmuch> one sec, need chocolate

[08:44] <luqui> you can't statically bind $foo() without adding envs to the type system like Haskell did

[08:45] <nothingmuch> you can statically bind by compiling static envs into parameters

[08:45] <nothingmuch> function parameters

[08:45] <luqui> not when you don't know what you're calling

[08:45] <luqui> as in my $foo = get_random_coderef();  $foo()

[08:46] <audreyt> 09:45 < nothingmuch> you can statically bind by compiling static envs into parameters

[08:46] <nothingmuch> oh, right

[08:46] <audreyt> # which is exactly what GHC does at runtime

[08:46] <audreyt> because $foo in that case stilll has static type informatino

[08:46] <nothingmuch> i thought thep problem was '$+foo.()'

[08:46] <audreyt> as of what env they want

[08:46] <luqui> here's another question:

[08:46] <luqui> sub foo() { return { $+bar } }

[08:46] <luqui> $+bar comes from the caller of the returned closure?

[08:46] <audreyt> obviously, yeah

[08:47] <nothingmuch> i'd want it to be a closure closure, i think

[08:47] <luqui> I suppose you would do:  sub foo() { my $bar = $+bar;  return { $bar } }

[08:47] <audreyt> yup

[08:47] <nothingmuch> unless we explicitly mark it

[08:47] <nothingmuch> this is only because i tried to put $_ in closures too many times

[08:47] <nothingmuch> e.g. 'my @adder_subs = map { sub { $_ + shift } } 1 .. 10'

[08:47] <nothingmuch> but then again, i could say this now:

[08:48] <luqui> the idea that envs are part of the signature is nice, but it's probably too picky for perl users

[08:48] <nothingmuch> my @adder_subs = map -> $x { sub { $x + shift } } 1 .. 10'

[08:48] <audreyt> luqui: not if we hoist it like $^x

[08:48] <luqui> nothingmuch, yep.  perl 5 was crappy...

[08:48] <nothingmuch> hehe

[08:48] <audreyt> i.e. collect static info

[08:48] <audreyt> if you mention $+x in your code, you want $+x

[08:48] <luqui> audreyt, wouldn't you still get bogus type errors

[08:49] <audreyt> I don't see why.

[08:49] <luqui> yeah sure, they wouldn't write the type information

[08:49] <luqui> but it would still be that

[08:49] <luqui> *there

[08:49] <audreyt> no, because subsumption always happens

[08:49] <luqui> hmm

[08:49] <audreyt> there's no failure case

[08:49] <audreyt> so you never see an errmsg

[08:49] <audreyt> not in comp time anyway

[08:50] <luqui> okay... I can see that... 

[08:50] <luqui> my only other fear is that the lists of implicit parameters would get huge

[08:50] <luqui> in top-level functions

[08:50] <luqui> I suppose you can remove them from the list upon binding...

[08:50] <audreyt> yeah

[08:50] <audreyt> same for any other tunrime type passing

[08:50] <luqui> interesting

[08:51] <audreyt> s/tunrime/runtime/

[08:51] <luqui> heh tunrime

[08:51] <audreyt> which we'd need for runtime resolution of objtype polymorphism anyway. S12:

[08:51] <luqui> which runtime type passing are you referring to?

[08:51] <audreyt>        All public method calls are "virtual" in the C++ sense.  More surpris?

[08:51] <audreyt>        ingly, any class name mentioned in a method is also considered virtual,

[08:51] <audreyt>        that is, polymorphic on the actual type of the object.

[08:52] <nothingmuch> gah

[08:52] <audreyt> so at runtime, the actual type of object subsumes the (potentially superclass's) class name

[08:52] * nothingmuch is getting a pugs craving again

[08:52] <nothingmuch> i will be back very very soon

[08:52] <luqui> hooray!

[08:52] <audreyt> nothingmuch: I look forward to it :)

[08:52] <luqui> audreyt, must the derived class be a subtype of the original?

[08:52] <nothingmuch> but now i need to work ;-)

[08:52] <nothingmuch> i need a sabbatical from work

[08:53] <luqui> (hmm... unless it is used in contravariant position, in which case it must be a supertype)

[08:53] <luqui> (and you don't get any virtual anything if you use it in both positions; it must be precisely equivalent)

[08:53] <luqui> (I guess you can override behaviors)

[08:54] <audreyt> luqui: I thought that's the denotational definition of "derived"

[08:54] <audreyt> operationally what "deriving" means is what "subtyping" means on the type level

[08:55] <luqui> did S12 ever say derived?

[08:55] <luqui> oh, I did

[08:55] <luqui> s/derived/overrided/

[08:55] <audreyt> and S12 does too.

[08:56] <luqui> where?

[08:56] <luqui> I'm referring to the virtual class, not the class that contains the virtual class

[08:56] <audreyt> oh, sorry

[08:57] <audreyt> hm

[08:57] <audreyt> class Foo { method (Foo $self: Foo $other) { ... } }

[08:57] <audreyt> er

[08:57] <audreyt> s/method/method m/

[08:57] <audreyt> class Bar is Foo {}

[08:57] <audreyt> Bar.new.m(Bar.new)

[08:57] <luqui> is that what it's talking about?

[08:58] <audreyt> then the "Foo" in the method type becomes Bar automagically

[08:58] <audreyt> yes.

[08:58] <luqui> it says "any" class name

[08:58] <audreyt> sure

[08:58] <audreyt> same

[08:58] <luqui> i.e. Bar.new.m(Foo.new) # illegal?

[08:59] <audreyt> it is legal

[08:59] <audreyt> first Foo becomes Bar

[08:59] <luqui> well of course...

[08:59] <audreyt> second Foo untouched

[09:00] <luqui> I don't see what's virtual here...

[09:00] <audreyt> all it's saying is that there's no static precalculation of binding to Foo:methname

[09:00] <luqui> example if there were?

[09:00] <luqui> (sorry I'm being rather dense)

[09:02] <audreyt> class Foo { method m1 (Foo $other) { $other.m2 }; method m2 { 'z' } }

[09:02] <audreyt> class Bar is Foo { method m2 { 'zz' } }

[09:02] <audreyt> Bar.new.m1(Bar.new)

[09:02] <audreyt> # zz

[09:02] <audreyt> but if prebinding happens it would be 'z'

[09:02] <luqui> that's not what it's saying

[09:02] <audreyt> because it's dispatched to Foo::m2 on $other.2

[09:02] <audreyt> .m2

[09:02] <luqui> that's just "all methods are virtual"

[09:03] <audreyt> no, it's on "$other"

[09:03] <luqui> S12 says class *names* are virtual

[09:03] <audreyt> if it's on "$self", it'd be "all methods are virtual"

[09:03] <audreyt> oh wait, I see what you're talking about

[09:03] <audreyt> I think it's calking about this

[09:03] <luqui> s/c/t/?

[09:03] <audreyt>  class Foo { method m1 { Foo.new } }

[09:04] <luqui> you're having phoenetically appealing butterfingers today

[09:04] <audreyt> class Bar is Foo {}

[09:04] <audreyt> Bar.m1(); # returns a Bar obj?

[09:04] <luqui> yeah, that's on the right track, but I think that would be wrong

[09:04] <GammaRay> can anyone point to a real example of := ?

[09:05] <luqui> examples/advocacy/motd-i.p6

[09:05] <nothingmuch> my $short_name := $very_long.{expression}{with}[$subscripts]; $short_name = "foo";

[09:05] <nothingmuch> $short_name++;

[09:06] <luqui> GammaRay, know C++?

[09:07] <audreyt> GammaRay: know perl5? :)

[09:07] <GammaRay> depends... I'm more versed w/ C

[09:07] <audreyt> $foo = 1; *foo = *bar; $bar++; print $foo; # 2

[09:07] <GammaRay> and yes I "know" perl5.. though it's kinda hard to say that definitively

[09:08] <luqui> GammaRay, := is just like references in C++.   int& foo = bar;   # they're not exact aliases

[09:08] <luqui> s/not/now

[09:08] <audreyt> er, I mean *bar = *foo

[09:08] <audreyt> in perl6, you can say $bar := $foo to do that

[09:08] <audreyt> without getting %bar and @bar into the game

[09:08] <audreyt> and also works on lexical vars

[09:08] <luqui> which is important, because in perl5 you just do *foo = \$bar

[09:08] <luqui> for the former

[09:08] <luqui> but the latter doens't work without XS hackery

[09:09] <audreyt> and you just use Devel::LexAlias for the latter

[09:09] <audreyt> it's just the ergonomics sucks

[09:09] <audreyt> for both

[09:09] <luqui> or you use Perl6::Binding

[09:09] * luqui thinks that's the name of that module

[09:09] <nothingmuch> btw, Array::RefElem is the most wonderfully wonderful aliasing module

[09:10] * audreyt looketh

[09:11] <nothingmuch> it allows you to glue the data of different data structures

[09:11] <nothingmuch> on numerous occasions i used it to make views of structures

[09:11] <audreyt> wow, very syck

[09:11] <nothingmuch> that can be updated and queried from two different lookup structures

[09:11] <nothingmuch> one was good for updating, the other for lookup

[09:12] <audreyt> mm it's almost like zipper

[09:12] <audreyt> except rather destructively

[09:12] <nothingmuch> yeah =)

[09:13] <luqui> zipper?

[09:13] <nothingmuch> http://haskell.org/hawiki/TheZipper

[09:13] <luqui> ahh yes, that

[09:16] <luqui> I used that when we were brainstorming about the tree transformation language

[09:16] <luqui> it went over everybody's head (including mine, partially)

[09:16] <nothingmuch> btw, what's the status of that thing?

[09:16] <nothingmuch> will perl 6 have zippers and AGs?

[09:16] * audreyt prefers case classes over explict AGs, btw.

[09:16] * luqui is brainstorming about language-level constructs like that

[09:16] <luqui> under the name "data comprehensions"

[09:16] <luqui> but i haven't come up with much

[09:16] <luqui> and neither has anyone else

[09:16] <luqui> audreyt, what's a case class?

[09:17] <audreyt> luqui: so case classes (tagged unions, or what have you) is not yet designed?

[09:17] <luqui> oh

[09:17] <audreyt> case class is what Scala calls OO-happy tagged unions

[09:17] <audreyt> their implementation is wonderful.

[09:17] <nothingmuch> btw, if we do get AGs, please make them be inheritence friendly

[09:17] <cm> in which way?

[09:17] <cm> (wonderful)

[09:17] <audreyt> "classes that have enumerated subclasses that you can case from"

[09:17] <luqui> nothingmuch, of course

[09:17] <nothingmuch> and have support for N-ary children

[09:17] <luqui> nothingmuch, L::AG 0.07 has both of those

[09:17] <audreyt> cm: because the usual OO interospection and machinary are all available 

[09:17] <nothingmuch> (@ and % variants)

[09:18] <audreyt> cm: it's just they get an extra constructor form ClassName(...)

[09:18] <luqui> albeit the latter is a little awkward

[09:18] <nothingmuch> ooh

[09:18] <nothingmuch> i ought to update blondie to it

[09:18] <audreyt> and extra deconstruction form in case

[09:18] <cm> audreyt, what does the case-syntax look like?

[09:18] <luqui> audreyt, yeah, that pretty much sums up my union type proposal

[09:18] <luqui> :-)

[09:18] <luqui> you can derive from the individual cases

[09:19] <luqui> and you can "derive" from the case type as a whole, but it makes it bigger, not smaller

[09:20] <audreyt> cm: http://scala.epfl.ch/intro/caseclasses.html

[09:20] <audreyt> luqui: look at that link and see if we can get them into Synopses?

[09:20] <audreyt> luqui: I _really_ want that in p6, as you know :)

[09:20] <cm> *links*

[09:21] * luqui too

[09:21] <luqui> don't worry

[09:21] <luqui> Larry has already designed half of it

[09:21] <nothingmuch> audreyt: please say "case classes are to AGs what x are to y"

[09:22] <nothingmuch> i need to learn scalar, dylan, ruby and python in that order

[09:22] <luqui> audreyt, is the set of cases closed?

[09:23] <cm> doesn't appear so

[09:23] <luqui> that's a problem for static typing

[09:24] <nothingmuch> luqui: we have 'is closed' etc

[09:24] <nothingmuch> static typing where we can get it

[09:24] <nothingmuch> not everywhere

[09:24] <audreyt> luqui: yes, in scala they are closed

[09:24] <audreyt> because you can't construct new classes at runtime

[09:24] <luqui> I've already addressed this in theory.pod.  If you don't close the cases, then covariant typing breaks, and you have to do that nasty trick in the expression problem paper

[09:24] <audreyt> nothingmuch: case classes are just haskell "data" types.

[09:24] <audreyt> luqui: yes and yes.

[09:25] <nothingmuch> audreyt: so what has that got to do with AGs?

[09:25] <nothingmuch> and why are they cooler?

[09:25] <luqui> AFAICT, they are related, but one is not a substitute for the other

[09:25] <nothingmuch> isn't AGs a control flow paradgim on top of the data types?

[09:25] <audreyt> nothingmuch: AGs are just ways to write "fold" functions over tagged unions

[09:25] <nothingmuch> right

[09:25] <cm> audreyt, and you can't add a new case in a different module?

[09:25] <audreyt> nothingmuch: if you have tagged unions but not AG, it's trivial to add an AG system

[09:25] <nothingmuch> i'll have to see exactly how, without lazy evaluation

[09:26] <luqui> with naming convenience built in

[09:26] <nothingmuch> oh

[09:26] <audreyt> cm: I don't think you could

[09:26] * nothingmuch thinks about an AG module that fudges the grammar, and creates a AG meta class

[09:26] <audreyt> nothingmuch: and you can also write your own folds by hand

[09:27] <nothingmuch> audreyt: without lazy evaluation?

[09:27] * luqui is thinking about reviving theory.pod from a not-so-haskellish perspective

[09:27] <luqui> I think a lot of it is redeemable

[09:27] <luqui> just not the strong typing, undecidable stuff

[09:27] <audreyt> nothingmuch: sure, I don't see why not...

[09:27] <audreyt> s/strong/static/

[09:27] <audreyt> will perl6 have weak typing? ;)

[09:27] <nothingmuch> audreyt: well, with the fact that data comes from two "directions" in theory

[09:28] <luqui> and you could also write an attribute grammar module

[09:28] <audreyt> aka unsafeCoerce

[09:28] <nothingmuch> i mean you could, but the way you pass params would be ugly

[09:28] <luqui> which was so extremely hard that it took almost three days of work!

[09:28] <luqui> :-)

[09:28] <nothingmuch> luqui: i'm just wondering on how well integrated perl 6 will make an ag module feel

[09:28] <luqui> audreyt, sorry, my tongue keeps slipping there

[09:28] <audreyt> nothingmuch: yes, but the ugliness is well understood and can be hidden under eg. luqui's L::AG treatment

[09:28] <nothingmuch> L::AG is not well integrated (syntax or otherwise) - it simply can't be

[09:28] <nothingmuch> audreyt: oh

[09:28] <nothingmuch> in that sense, err, yeah

[09:28] <nothingmuch> =)

[09:29] <luqui> nothingmuch, it's very hard to make AG's integrated

[09:29] <nothingmuch> i have to go to univ now

[09:29] <luqui> because of memory issues

[09:29] <luqui> you have to be sure that you'll never access an attribute again so you can clean it up

[09:29] <audreyt> in any case... AG-based multipass compiler writing is fun

[09:29] <luqui> if you have ideas, I'd be delighted to hear them, though

[09:29] <audreyt> hopefully punie will move again

[09:30] <luqui> I hear it almost has conditionals

[09:30] <nothingmuch> luqui: compile time integration can mean we can use graph reduction

[09:30] <nothingmuch> potentially directly

[09:30] <luqui> nothingmuch, you have to be careful how much you assume about compile time knowledge

[09:30] <luqui> we're still talking about perl

[09:30] <nothingmuch> right

[09:30] <luqui> I find it easy to forget that

[09:30] <luqui> except for when I start writing in perl

[09:30] <audreyt> luqui: excellent, then you just need loops, assignments and all the Structured Programming is yours!

[09:30] <luqui> then I remember why I like dynamic typing

[09:30] <nothingmuch> if i were going to write an AG module i'd make it kinda compile-time-ish

[09:31] <luqui> basically L::AG, but without having to create a string...

[09:31] <luqui> the hardest part is coming up with syntax...

[09:31] <nothingmuch> i wonder if allison should be spending more time on punie

[09:31] <luqui> that's not already taken

[09:32] <nothingmuch> i think it's more important than some people think

[09:32] <luqui> more important to what?

[09:32] <nothingmuch> to getting her tools pushed out the door

[09:32] <luqui> oh yeah, I guess so

[09:32] <nothingmuch> the tools she said she wanted

[09:32] <luqui> I just think it's important to demonstrating that PIR is not a viable compiler-writing language

[09:32] <audreyt> indeed, a working minilanguage is probably the best way to get there

[09:32] <nothingmuch> luqui: i envision compile time AGs as more of a DSL inside perl

[09:33] <nothingmuch> that compiles to PIL

[09:33] <audreyt> luqui: heh ;)

[09:33] <nothingmuch> and has embedded perl

[09:33] <nothingmuch> luqui: yeah, that too

[09:33] <nothingmuch> it sounds like she spends ~2hrs a week on it

[09:33] <luqui> so basically L::AG but at compile time

[09:33] <audreyt> luqui: I think I can parse P6 rules in haskell within today

[09:33] <nothingmuch> luqui: yes

[09:33] <audreyt> luqui: then I'll compile it to Parsek

[09:33] <nothingmuch> luqui: but with the benefit of saying "no, this is not runtime"

[09:34] <luqui> audreyt, make sure you can output to my combinators, too

[09:34] <nothingmuch> anyway, i'm off

[09:34] <luqui> nothingmuch, yeah :-)

[09:34] <nothingmuch> ciao

[09:34] <luqui> bye

[09:34] <audreyt> luqui: Parsek's combinators is I think isomorphic to yours

[09:34] <nothingmuch> Parsek?

[09:34] <luqui> what's with the k?

[09:34] <nothingmuch> we need a purl on the channel

[09:34] <cm> Parsec without try

[09:34] <cm> (or rather, parallel parsing, to avoid the need for try)

[09:34] <audreyt> http://cvs.coverproject.org/marcin/cgi/viewcvs/Santa/Parsek.hs?rev=HEAD&content-type=text/vnd.viewcvs-markup

[09:34] <cm> (afaik..)

[09:34] <nothingmuch> btw, oh

[09:35] <nothingmuch> oh

[09:35] <audreyt> what cm said.

[09:35] <audreyt> because p6 rules default to try

[09:35] <audreyt> and PGE doesn't have "commit" yet anyway

[09:35] <nothingmuch> btw, how do p6 rules relate to parrow?

[09:35] <audreyt> so it makes sense to use a try-based thing

[09:35] <luqui> can Parsek do sane error messages?

[09:35] <luqui> I find that backtracking parsers have a hard time with that

[09:35] <audreyt> luqui: sure, same as parsec

[09:35] <nothingmuch> is it viable to eval p6 rules using parrow techniques?

[09:35] <audreyt> parsek doesn't backtrack

[09:36] <luqui> er, yeah

[09:36] <cm> what's parrow? :-)

[09:36] <nothingmuch> http://www.cs.helsinki.fi/u/ekarttun/PArrows/doc/Text.ParserCombinators.PArrow.Combinator.html

[09:36] <luqui> audreyt, my PGE does

[09:36] <nothingmuch> shit, i should just shutup

[09:36] <audreyt> luqui: I know

[09:36] <nothingmuch> afk

[09:36] <luqui> :-)

[09:36] <audreyt> luqui: it's still possible

[09:37] <audreyt> and remember, whatever you do, you are better than p5's regex ;)

[09:37] <audreyt> (which offers no errmsg whatsoever)

[09:37] <audreyt> except for the position information in //gc

[09:37] <luqui> heh

[09:37] <luqui> okay, time to start on OPP

[09:38] <luqui> after three hours of saying that i will

[09:38] <audreyt> what is OPP anyway?

[09:38] <luqui> ...

[09:38] <luqui> operator-precedence parser?

[09:38] <audreyt> oh ok

[09:38] <audreyt> yeah, I hope OpTable.hs is of use to you

[09:38] <audreyt> should be a very straightforward port

[09:38] <luqui> I don't really do straightforward ports though...

[09:39] <luqui> Instead I try to understand the problem really well and come up with my own design

[09:39] <audreyt> oh, you'd like to work out the dispatch from shift/reduce rules yourself

[09:39] <luqui> makes for frustrating modularity

[09:39] <audreyt> cool... have fun then :)

[09:39] <luqui> but I'll use OpTable.hs for ideas certainly

[09:40] <luqui> audreyt, oh, one thing

[09:40] <luqui> instance Eq DynStr where _ == _ = False

[09:40] <luqui> instance Ord DynStr where compare _ _ = EQ

[09:40] <luqui> those two lines seem to contradict each other

[09:40] <audreyt> lol

[09:40] <audreyt> fixed.

[09:40] <audreyt> thanks!

[09:41] <svnbot6> r8479 | audreyt++ | * Text.Parser.OpTable: a DynStr is "eq" not "ne" to any other DynStr.

[09:41] <svnbot6> r8479 | audreyt++ |   Spotted by luqui++.

[09:41] <audreyt> dinner, bbl &

[11:08] <Alias_> It's oh so quiet...

[11:10] <nnunley> shhhhh shhhh

[11:11] <svnbot6> r8480 | audreyt++ | * Text.Parser.OpTable: Allow returning of arbitrary data types

[11:11] <svnbot6> r8480 | audreyt++ |   as parser results instead of fix it on "Match" type.

[11:12] <Alias_> Ah, she is around

[11:13] <svnbot6> r8481 | audreyt++ | * Text.Parser.PArrow, modified to work on FastPackedString

[11:13] <svnbot6> r8481 | audreyt++ |   and return location info on error.

[11:13] <Alias_> audreyt: ok, so I've finished SMS::Send and my person driver for it, going to pick off some more doc stuff in M:I for a bit

[11:13] <Alias_> audreyt: You aren't doing anything with it atm are you?

[11:13] <Alias_> s/person/personal/

[11:36] <asavige> i have a couple of simple haskell questions. anyone want them or should i go to #haskell?

[11:53] <gaal> asavige: still need a hand?

[11:54] <asavige> hi gaal! isDigit applies to chars but what if you want to that each char in a String is a digit?

[11:54] <asavige> I tried isSDigit xs = and (map isDigit xs) 

[11:54] <asavige> seemed to work ok but what is recommended way to do it?

[11:56] <gaal> that looks reasonable to me

[11:57] <asavige> k. thanks. i search the haskell libraries and it seems there is not much String libs

[11:57] <asavige> i guess the haskell way is just to use generic list functions for Strings?

[11:57] <svnbot6> r8482 | luqui++ | Subrule support.

[11:57] <nnunley> asavige: Could change it to pointless style

[11:57] <asavige> is there a haskell regex library?

[11:57] <nnunley> asavige: ie, you could drop xs completely.

[11:57] <asavige> k

[11:58] <gaal> asavige: yes, there is, http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html#t%3ARegex

[11:58] <svnbot6> r8483 | luqui++ | The (* 1%2) (* 3%2) precedence relation was broken.  Fixed it.

[11:58] <luqui> I know I already committed that (Subrule support).  It's still in my IRC log.

[11:58] <gaal> I don't know how nice these regexes are compared to perl's.

[11:59] <gaal> afk &

[11:59] <nnunley> More complicated things should probably done with something like Parsec.

[12:00] <asavige> hmmm looks like they are not using PCRE, they talk of posix regexes :-(

[12:00] <integral> hmm, aren't we already embedding PCRE?

[12:00] <luqui> there is a pcre for haskell

[12:01] <integral> see RRegex.PCRE and RRegex

[12:10] <svnbot6> r8484 | luqui++ | "Ratio Int" is dangerous; you can only raise the precedence 31 times.

[12:10] <svnbot6> r8484 | luqui++ | Changed to "Ratio Integer".

[12:10] <Alias_> Any particular reason they roll the R?

[12:25] <nnunley> Alias_: Looks like the first R is for Reusable.

[12:34] * Alias_ is reaching his daily limit of Module::Install doc boredom

[13:08] <Juerd> rafl_: pong

[13:11] <Alias_> audreyt: OK, more docs committed, managed to get through the _from series, and finished at no_index

[13:34] <Debolaz> Good morning Vietnam.

[13:43] <Debolaz> Has anybody in here been able to compile pugs on FreeBSD? I'm getting "ghc-6.4.1: unrecognised flags: -Wl,-R/usr/pkg/lib" errors. While it's obvious to me why it isn't working, it's not quite obvious how to fix it. I'm using ghc 6.4.1 trying to compile pugs 6.2.10.

[13:57] <rafl_> Juerd: Already at 22c3?

[14:03] <rafl_> Juerd: I'm near the kitchen currently.

[14:04] <rafl_> Juerd: Oh, you don't know me. I'm sitting next to Timo, which you should know.

[15:21] <lisppaste3> avar pasted "overloading" at http://paste.lisp.org/display/15056

[15:22] <avar> operator overloading of doom!

[15:26] <svnbot6> r8485 | audreyt++ | * Tweaks to OpTable.hs and PArrow to support proper choice

[15:26] <svnbot6> r8485 | audreyt++ |   combinator and empty strings.

[15:29] * audreyt dances a little victory dance

[15:29] <audreyt> svnbot6: ?check

[15:29] <svnbot6> r8486 | audreyt++ | * Ladies and gentlemen, I present you... Text.Parser.Rule!

[15:29] <svnbot6> r8486 | audreyt++ |   Fast, pure Haskell Perl6 Rules implementation, based on PArrows.

[15:29] <svnbot6> r8486 | audreyt++ |   Currently only handles quantification, alternation and concat,

[15:29] <svnbot6> r8486 | audreyt++ |   but it's just a 20mins hack -- much more support planned soon.

[15:29] <clkao> yikes

[15:30] <gaal> 3wow.

[15:30] <audreyt> and it's easy to hack as well :)

[15:30] <avar> what was that thing that was changed in p6 so that if look mommy, no paranthesis { ... wouldn't be ambiguous?

[15:30] <audreyt> in 33 lines of code :D

[15:31] <audreyt> avar: this is made illegal

[15:31] <audreyt> $ENV {PATH}

[15:31] <audreyt> now you have to write

[15:32] <audreyt> %ENV .{PATH}

[15:32] <audreyt> to get whitespace

[15:32] <audreyt> that's it

[15:32] <audreyt> I doubt many people use that form in perl5 anyway.

[15:32] <Odin-LAP> Have you ever seen it?

[15:32] <audreyt> nope

[15:32] <avar> %ENV<PATH> or %ENV{"PATH"} though?

[15:32] <audreyt> sure

[15:33] <audreyt> both works

[15:33] <avar> since PATH would be a bareword

[15:33] <audreyt> yeah

[15:33] <audreyt> and <PATH> is so that it looks more distinct than the now-always-a-closure {}

[15:33] <audreyt> so... I wonder if we should ship a 6.28.0 _without_ requiring PGE :)

[15:34] <audreyt> I don't see why not.

[15:34] <Odin-LAP> Might be neat.

[15:34] <audreyt> and that will finally allow callbacks from rules to code

[15:35] <audreyt> hm, PGE doesn't handle listfix and chainfix.

[15:35] <audreyt> we need that to support fast alternation (a|b|c|d)

[15:36] * audreyt goes adding it to OpTable

[15:36] <audreyt> and the neat thing is PArrow provides common head optimization for free

[15:36] <gaal> I just noticed that a smoke I'd left running has plenty of memory problems at runtime

[15:36] <gaal> pugs: internal error: evacuate: strange closure type 11432

[15:36] <gaal> etc.

[15:36] <Odin-LAP> Riddle me this, though. Once you get rules support in pugs, wouldn't it be possible to write the Perl6 implementation of Perl6?

[15:36] <audreyt> (add|ant) becomes (a(dd|nt))

[15:36] <audreyt> Odin-LAP: yes.

[15:37] <audreyt> and once luqui finishes his Rules port in Perl6, that bootstrap can parse itself with itself.

[15:37] <audreyt> and there will be much joy, etc.

[15:37] <avar> \o/

[15:37] <Odin-LAP> But that's a couple of decades away, by any reasonable estimate? >:p

[15:37] <audreyt> if your year is my month, then sure :)

[15:38] <Odin-LAP> I'm just sayin'...

[15:43] <gaal> I hate it when this happens:

[15:43] <gaal> gaal> ghc errors

[15:43] <gaal> * time passes

[15:43] <gaal> BSOD

[15:44] <nnunley> Mmm.  Windows heap corruption.

[15:44] <gaal> last time I had to have my CPU replaced :/

[15:44] <gaal> GHC is my canary

[15:46] <gaal> that was just a few months ago, and I don't overclock. wtf?

[15:46] <nnunley> Did you check your system memory?

[15:46] <gaal> I'm sure the shop did when they replaced the CPU...

[15:50] <gaal> say, what's involved in emitting yaml via syck?

[15:50] <audreyt> gaal: see YAML::Syck

[15:52] <avar> a ha!

[15:52] <gaal> audreyt: is it on svn somewhere too?

[15:53] <audreyt> there's a syck_emit_* sequence -- also see ext/ directory in syck's source tree -- the latest svn has Lua examples; also Ruby ones is worth taking a look at

[15:53] <audreyt> http://svn.kwiki.org/audreyt/YAML-Syck/

[15:53] <audreyt> also, http://code.whytheluckystiff.net/svn/syck/

[15:54] <gaal> cheers

[15:54] <audreyt> in particular, http://code.whytheluckystiff.net/svn/syck/trunk/README.EXT

[15:55] <audreyt> if you'd like to learn Haskell FFI, coding up emitter support for Data.Yaml.Syck might be just the ticket :)

[15:55] <ingy> audreyt: how is Y::S coming?

[15:55] <audreyt> ingy: I ported Perl6 Rules to Haskell

[15:55] <audreyt> so nothing on Y::S front yet

[15:55] <audreyt> someone sent me a patch, I released it as 0.03

[15:56] <audreyt> so it can build in a perl built with debug flag on

[15:56] <gaal> audreyt: and just what I had in mind, seeing as all that variable stuff is giving me the brain-jello-syndrome.

[15:56] <audreyt> gaal: cool!

[15:56] <audreyt> it should be pretty straightforward.

[15:56] <ingy> okie, I'll keep my eyes on it. maybe we can get a pair of YAML releases by the end of the year

[15:56] <audreyt> since you already have the parser part as demos

[15:57] <gaal> audreyt: in your p5 module, it's the c Dump() I should be looking at?

[15:57] <audreyt> aye

[15:57] <audreyt> and for the first pass, you can ignore the mark_ part

[15:57] <audreyt> just assume nonrecursion

[15:58] <audreyt> consult http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html for enlightenment

[15:58] <audreyt> ingy: sounds good

[16:00] * Odin-LAP points out that the "end of the year" is a handful of days off...

[16:00] <audreyt> ingy works in nanosecond units anyway

[16:01] <gaal> good thing ghc is pico-ready

[16:01] <audreyt> :)

[16:02] <ingy> audreyt: read this and thought of you ;) http://www.paulgraham.com/paulgraham/procrastination.html

[16:02] <Juerd> rafl_: I'm at 22c3, yes, but only very rafl: Im 

[16:03] * gaal is stunned by how short Pugs.Prim.Yaml is

[16:03] <rafl_> Juerd: I'm in room 2 now.

[16:03] <rafl_> Juerd: And there's a free place to my right. ;-)

[16:05] <Juerd> rafl_: I have approx 1 minute per bootup

[16:05] <Juerd> rafl_: So not online much. Will come to s2

[16:05] <audreyt> gaal: why should it be any longer? this is not XS you know... :)

[16:05] <Juerd> Where in s2 are you?

[16:06] <rafl_> Juerd: Quite on the left side in the back.

[16:06] <Juerd> rafl_: ok; leaving s1 now.

[16:06] <rafl_> Juerd: Two empty chairs right to me.

[16:06] <gaal> audreyt: :-)

[16:08] <gaal> wheee TDD in syck's c code :-)

[16:09] <audreyt> :D

[16:10] <audreyt> allow me to quote Why in syck/ext/ruby/ext/syck/rubyext.c

[16:10] <audreyt>  * Emitter callback: assembles YAML document events from

[16:10] <audreyt>  * Ruby symbols.  This is a brilliant way to do it.

[16:10] <audreyt>  * No one could possibly object.

[16:10] <audreyt> end of quote.

[16:11] <audreyt> it's very... poignant.

[16:12] <gaal> suitable adjective for Why

[16:12] <gaal> but... how's it brilliant? isn't that exactly what it's there for?

[16:12] <audreyt> luqui: hi. interested in hacking Text.Parser.Rule? :)

[16:13] <luqui> uh, not terribly much so.  I'd like to get the Perl6 version nice and pretty

[16:13] <audreyt> that's going to be more important in the long run anyway :)

[16:13] <svnbot6> r8487 | luqui++ | Capture with no capture targets no longer dies, but introduces

[16:13] <svnbot6> r8487 | luqui++ | a new scope and discards the match object.

[16:13] <audreyt> but just thought you might be interested in taking a look

[16:13] <luqui> I'll have a look at least

[16:13] <audreyt> I'm very happy with how it's done :)

[16:13] <audreyt> 33 lines, with 2 more lines for each new construct

[16:14] <luqui> nice

[16:14] <Juerd> re :)

[16:14] <svnbot6> r8488 | luqui++ | Implemented "numerator" and "denominator" for Rats.

[16:14] <svnbot6> r8489 | luqui++ | Hacked in some dumb support for "our class".

[16:14] <svnbot6> r8490 | luqui++ | Switched over to using "our class" in PGE.  That would have felt good on the fingers.

[16:14] <svnbot6> r8490 | luqui++ | Still craving some kind of proper lexical exportation of class names.

[16:15] <Juerd> rafl_: Is this the NX bit talk?

[16:15] <luqui> audreyt, does it use list monad?

[16:15] <luqui> or no... what does it use?

[16:15] <audreyt> it justs PArrows

[16:15] <gaal> what's this "bonus" stuff in Syck?

[16:15] <luqui> ahh... arrows

[16:16] <luqui> those things that I still don't grok

[16:16] <luqui> ... at all

[16:16] <audreyt> I think I grok now

[16:16] <audreyt> it's really extremely simple

[16:16] <audreyt> a >>> b -- do a, then do b

[16:16] <audreyt> a >>^ b -- do a, then lift pure function b and do it to the result

[16:16] <audreyt> a *** b -- do a and b in parallel

[16:17] <luqui> a >>> b  <=>  a >> b  ; a >>^ b  <=>  fmap b a  ?

[16:17] <audreyt> yup

[16:17] <luqui> is there a >>= ?

[16:18] <luqui> I heard that all monads were arrows...

[16:18] <audreyt> yup

[16:18] <audreyt> so no

[16:18] <audreyt> a &&& b -- do a and b in parallel with the same input (*** would split the input in two)

[16:18] <luqui> oh.. right.  I'm thinking backwards

[16:18] <integral> the monad itself isn't the arrow though

[16:18] <audreyt> yeah, you need to apply Kleisli to it

[16:19] <audreyt> anyway... PArrows has a quite similar interface to Parsec

[16:19] <audreyt> and unlike Parsec, I tweaked it to work on FastPackedStrings easily

[16:19] <luqui> hmm... what does "split the input in two" mean?

[16:20] <audreyt> it means that the input source has to provide a pair as input

[16:20] <luqui> ahh

[16:20] <audreyt> and then each side of *** processes one

[16:20] <audreyt> and then it's recombined

[16:20] <audreyt> (***) :: a b c -> a b' c' -> a (b, b') (c, c')

[16:20] <luqui> pair meaning tuple?

[16:21] <luqui> yep

[16:21] <audreyt> yeah

[16:21] <audreyt> note that a function is an arrow, so that type can read

[16:21] <audreyt> (***) :: (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))

[16:21] <audreyt> which is straightforward as of what it does.

[16:21] <luqui> yeah, that part I did actually get when I first read about the

[16:21] <luqui> m

[16:21] <audreyt> and &&& is even easier

[16:21] <audreyt> (&&&) :: a b c -> a b c' -> a b (c, c')

[16:21] <luqui> why isn't that nice haskell syntax supported at the type level?

[16:22] <luqui> (***) :: b `a` c -> b' `a` c' -> (b,b') `a` (c,c')

[16:22] <audreyt> yup

[16:22] <Juerd> audreyt: Three character operators? Are they as desperately looking for free glyphs as we are? :)

[16:22] <audreyt> so *** implements alternation

[16:22] <audreyt> Juerd: yup :)

[16:22] <luqui> what is the input to a parser?

[16:22] <audreyt> and they don't even have unicode.

[16:22] <Juerd> Neither do we

[16:22] <luqui> Juerd, ?

[16:22] <audreyt> luqui: a list of anything

[16:22] <luqui> oh

[16:22] * Juerd is still in denial

[16:23] <luqui> but PArrow is a library :-)

[16:23] <audreyt> luqui: which I had hacked to be FastPackedString, pretending it's a [Char]

[16:23] <luqui> *** is alternation?  Wouldn't that be &&& ?

[16:24] <luqui> oh, and on a related topic, Juerd, how do you pronounce your name?

[16:24] <audreyt> &&& is simultaneous parse on the same position

[16:25] <audreyt> hm, actually no

[16:25] <luqui> sounds the same as <|> to me...

[16:25] <audreyt> &&& in PArrow is "followed by"

[16:25] <audreyt> many1 x = (x &&& MStar x) >>> pure (\(b,bs) -> (b:bs))

[16:25] <audreyt> so, parse "x" first, then parse "x*", get each's result as (b,bs)

[16:25] <audreyt> then cons them

[16:25] <audreyt> I think it makes perfect sense

[16:26] <luqui> hmm... okay, that makes sense

[16:26] <luqui> how can *** afford to take two different input types?

[16:26] <audreyt> between open close real = open >>> (real &&& close) >>^ fst

[16:27] <audreyt> again, very cute

[16:27] <audreyt> oh, you can't use *** as a normal combinator

[16:27] <audreyt> it's only used internally

[16:27] <Juerd> luqui: Much like as if it were German

[16:27] <luqui> what's alternation then?

[16:28] * luqui isn't familiar with German's phonology wrt the "J"

[16:28] <audreyt> alternation is implemented as a node

[16:28] <audreyt>     MChoice :: [MD i o] -> MD i o

[16:28] <audreyt> see pugs/src/Text/Parser/PArrow/MD.hs

[16:28] <audreyt> (and yes, it depends on GADT to function well)

[16:29] <luqui> how uncool

[16:29] <luqui> you mean the arrow formalism doesn't map 1-1 onto the parser combinator formalism?

[16:29] <luqui> what good is it then?

[16:29] <luqui> :-)

[16:29] <Juerd> luqui: Like english y.

[16:30] <audreyt> luqui: er, that's why Arrow is a class

[16:30] <audreyt> it's impossible to write parsers using >>= and >> alone, you know :)

[16:30] <audreyt> s/>>/return/

[16:30] <luqui> what's return= ?  ;-)

[16:31] <luqui> okay, enough silliness

[16:31] <audreyt> arr

[16:31] <luqui> do you mean "pure"?

[16:31] <audreyt> synonym

[16:31] * luqui knows...

[16:31] * luqui will have to play with arrows sometime

[16:32] * Juerd knows nothing about assembler and hardly understands German, and is listening to a German talk about assembly...

[16:32] <Juerd> My luck :)

[16:32] <luqui> Juerd, are you at a conference?

[16:32] <Juerd> luqui: Yep

[16:32] <rafl_> Juerd: Timo told me you obligated yourself to hack on sixpan?

[16:32] <Juerd> rafl_: Oh?

[16:32] <luqui> there's a conference going on?

[16:32] <luqui> which?

[16:32] <rafl_> Juerd: He told me.

[16:32] <Juerd> rafl_: He knows more than I do then :)

[16:33] <Juerd> rafl_: He asked me if I had anything to do with sixpan, and through feather, yes I did :)

[16:33] <Juerd> luqui: 22C3, in Berlin

[16:33] <rafl_> Juerd: Does feather have anything to do with sixpan (yet?)?

[16:33] <Juerd> rafl_: Just hosting.

[16:34] <Juerd> ;

[16:34] <Juerd> s/;//

[16:34] <luqui> cool.  /me likes cryptography

[16:34] <luqui> .. at least

[16:34] <Juerd> luqui: Why aren't you at CCC then?

[16:34] <luqui> <luqui> there's a conference going on?

[16:34] <luqui> (not to mention, I don't really have the $$ to fly to berlin)

[16:35] <luqui> (and I'm not gonna drive)

[16:35] <Juerd> I'm here, without flying. So why couldn't you? :)

[16:35] <Juerd> Oh. I didn't mind driving

[16:35] <Juerd> Though it was very tiresome

[16:35] <luqui> yeah.  might be a bit wet for me, too.

[16:35] <Juerd> luqui: Woher kommst du? :)

[16:36] <Juerd> Someone wants to know :)

[16:36] <luqui> Colorado

[16:36] <Juerd> That's not quite drivable anyway...

[16:36] <luqui> thus a bit wet...

[16:36] <Juerd> Yea

[16:36] <luqui> German is the most Englishish foreign language I've heard

[16:37] <Alias_> Which would make sense, since English started as a dialect of German

[16:37] <luqui> heh yeah... that happens

[16:37] <Alias_> Then had a bunch of other people's words dumped on it

[16:37] <Juerd> It's frozen-wet outside here. Quite white.

[16:37] <luqui> like Perl as a dialect of C

[16:37] <Alias_> Then had an ever larger bunch of French words dumped on it

[16:37] <Juerd> And the DHCP for wifi sucks.

[16:38] <Juerd> I think there may be extra access points out there. Fake ones, perhaps.

[16:38] <Alias_> Perl is English, the second language of the computer world

[16:38] <luqui> it's like 65 degrees outside here.  Amazing weather for the middle of december.

[16:38] <Juerd> luqui: English is Germanic, German isn't Englishish

[16:38] <rafl_> Juerd: It's even harder for me as I smoke.. :-(

[16:38] <Alias_> Juerd: Thank god

[16:38] <luqui> But Englishish is a way cooler word than Germanic

[16:39] <Juerd> luqui: But Deutsch-achtig beats Englishish.

[16:39] <luqui> point

[16:39] <Juerd> luqui: 65 Fahrenheit, I hope for you.

[16:39] <luqui> heh yeah

[16:39] <luqui> we don't go by reasonable scales

[16:40] <Juerd> I have no idea how cold Berlin is on any scale, but it's COLD.

[16:41] <luqui> as cold as canada was at yapc?

[16:41] <Juerd> I have no idea.

[16:41] <Juerd> Wasn't there

[16:41] <luqui> well, it was beautiful there

[16:41] <luqui> if there's one month I would live in canada, it would be july

[16:41] * Juerd will go to Saal 3 after this hourslot; There's a talk titled "Writing better code".

[16:42] <Juerd> I wonder what the angle is.

[16:42] <Juerd> And I hope my DECT is safe in Saal 1, where it's charging :)

[16:42] <rafl_> Juerd: The full title is "Writing better code (in Dylan)". WTF is Dylan?

[16:42] <Juerd> rafl_: What or who? :)

[16:42] <luqui> rafl_, Dylan is a language

[16:43] <Juerd> luqui: Worth an hour?

[16:43] <luqui> it's a hybrid language like Perl

[16:43] <Juerd> Sounds good enough

[16:43] <luqui> but it uses the opposite concepts

[16:43] <Juerd> Opposite?

[16:43] <Juerd> One way to do it, no modularity, strict OO?

[16:43] <audreyt> Dylan is a wonderful "dynamic when needed, static when possible" language

[16:43] <Juerd> Hmm

[16:43] <rafl_> "combines the best aspects of smalltalk and lisp" Urgh..

[16:43] <luqui> apparently it's cool

[16:43] <audreyt> starts as fully dynamic like smalltalk, but as you add type annotations, it can eventually produce very efficient code.

[16:43] <luqui> I was put off by it's linguistic unappeal

[16:43] <audreyt> sounds familiar? :)

[16:44] <Alias_> Is there a DPAN? :)

[16:44] <Juerd> Alias_: Sounds almost like a C++PAN

[16:44] <audreyt> sadly no, but they reliably win 2nd place at ICFP contests 

[16:44] <Juerd> Alias_: And what's Dentral? :)

[16:44] <luqui> the Dylprehensive Pointy Archive Network?

[16:44] <Alias_> Juerd: Good Question!

[16:45] <Juerd> Alias_: Thought so :)

[16:45] <Alias_> Do you know the answer?

[16:47] <Juerd> No

[16:47] <Juerd> rafl_: I want an 8 cell battery too.

[16:47] <Juerd> And something that finds out what's in the air here that slurps my battery empty.

[16:47] <rafl_> Juerd: Buy one?

[16:47] <Juerd> Less than an hour it lasts :(

[16:48] <rafl_> Juerd: And no: I wont sell mine.

[16:48] <Juerd> rafl_: Had ordered one, but it'd be delivered to Sven's two days after the event, so I cancelled it.

[16:48] <Juerd> Hehe

[16:49] <rafl_> Juerd: jacks are everywhere..

[16:49] <Juerd> Oh, really? Not in this saal

[17:06] <rafl_> Juerd: They were just behind us.

[17:14] <audreyt> journal up... sleep :)

[17:14] <audreyt> *wave* &

[17:28] <generalhan> whats going on everyone ?

[17:28] <Alias_> world domination... slowly

[17:28] <generalhan> ... but surely !

[17:28] <generalhan> give it some time ! lol

[17:29] <Odin-LAP> World domination has already been achieved. The controllers are just very, very careful not to let you see it.

[17:29] <Alias_> _my_ world domination

[17:29] <generalhan> haha

[17:30] <generalhan> anyone in here really good with Perl scripts ? i have a pretty newbish question

[17:30] <Odin-LAP> Alias_: Good luck with that. Last time I tried, they had assassins all over the place. Had to be on the run for a number of years.

[17:30] <Alias_> yes, and you have one minute before we send you to #perl

[17:30] <generalhan> lol

[17:30] <generalhan> k

[17:30] <generalhan> i need to "find" any file in a directory that starts with an alpha char. can i do that ?

[17:31] <Alias_> http://search.cpan.org/perldoc?File::Find::Rule

[17:31] <Alias_> NEXT!

[17:31] <generalhan> sweet thanks !

[17:31] <integral> man 1 find # uses less RAM and CPU

[17:31] <Alias_> and it forks

[17:32] <Alias_> which does use ram and CPU

[17:42] <svnbot6> r8491 | audreyt++ | * Support for "./pugs -B JS-Perl5 -e ...".

[17:42] <Alias_> audreyt: Sleep my ass

[17:44] <Juerd> rafl_: Oh, heh.

[17:44] <Juerd> BTW, how do you think this was meant: "That's not standard Dylan, but something that works."

[17:45] <petdance> generalhan: See also File::Find::Wanted.

[17:46] <Juerd> The examples used in this talk are quite contrived :|

[17:49] <rafl_> Juerd: Where are you?

[17:49] <Juerd> Sitting onthe ground, close by the door that is closest to the screen.

[17:49] <rafl_> Juerd: I think dylan doesn't have an interface for calling c stuff defined.

[17:50] <rafl_> Juerd: But the compiler that he's talking about can do it in its own way.

[17:50] <Juerd> It has "for" (foreach) implemented as a macro. Heavy desugaring.

[17:50] <rafl_> Juerd: Why? There are lots of free chairs.

[17:50] <rafl_> Indeed.

[17:50] <Juerd> rafl_: No specific reason.

[17:50] <Juerd> rafl_: I just entered this room a few minutes ago.

[17:50] <Juerd> rafl_: When I left room 2, I almost fainted, so I decided to eat and drink first.

[17:51] <Juerd> There's not enough oxygen in the talk rooms

[17:51] <Juerd> (unrelated)

[17:51] <rafl_> Juerd: There's not enough caffeine inside you.

[17:52] <rafl_> Juerd: You missed something. Dylan is pretty cool.

[17:52] <Juerd> I've already got a headache because of the low oxygen (open a window, !@#@#%!), cafeine would make it worse.

[17:52] <Juerd> rafl_: I see

[17:53] <Juerd> Now there's a complex description of the old "Abort, Retry, Ignore?"

[17:53] <rafl_> Juerd: Over here there's fresh air. It's even windy a bit.

[17:53] <Juerd> Where's "here"?

[17:53] <rafl_> Juerd: Near the camera.

[17:54] <Juerd> Hi

[17:57] <Juerd> Dylan has lots of parens :(

[17:57] <Juerd> Bracketing operators suck when overused

[17:57] <rafl_> Well, much less than usual lisp languages..

[17:57] <Juerd> Sure, but that's natural :)

[17:58] <Juerd> Only a paren based brainfuckish language could ever have more parens than the usual lisp-alike

[17:58] <Juerd> :P

[17:58] <rafl_> :-)

[17:58] <sili> hooray lisp

[17:59] <Juerd> afk  # saal1

[19:19] <rafl_> Juerd: ping

[19:21] <rafl_> Juerd: In mood for some pugs hacking? I'm in the hack centre and want to hack on XML-SAX..

[19:26] <rafl_> kane-xs: ping

[19:27] <rafl_> Juerd: Or maybe SmokeServ v2?

[19:34] <Alias_> Might want to wait a bit on the smoke stuff

[19:34] <Alias_> I have a basic version of the PITA::Report XML stuff almost done

[19:34] <Alias_> Once it's rolling you'd have something new to target :)

[19:35] <Alias_> s/new/new and interesting/

[19:36] <rafl_> Alias_: What's PITA::Report?

[19:37] <Alias_> Where's purl when you need her...

[19:37] <Alias_> Go read http://ali.as/pita/

[19:37] <Alias_> After talking to audreyt, it's going to be Perl 6 compatible too

[20:00] <rafl_> What's the perl 6 way of doing require "/path/to/Foo.pm"?

[20:18] <nothingmuch> audreyt++

[20:18] <nothingmuch> luqui++

[20:40] <svnbot6> r8492 | iblech++ | * Usual svn props.

[20:40] <svnbot6> r8492 | iblech++ | * Parse-Rule: Architecture.pod: Typo fix.

[20:54] <gaal> rafl_: I should think temping @INC and requiring Foo.

[20:54] <gaal> you also have evalfile, if you don't need load-once.

[21:03] <rafl_> gaal: Well, I want to load parser modules at runtime.

[21:09] <nothingmuch> out of curiousity - why was the pugs blog moved?

[21:26] <gaal> rafl_: parser modules?

[21:26] <dduncan> not sure exactly ...

[21:27] <dduncan> but I would guess that the new host offers a better experience

[21:29] <rafl_> gaal: Something needs a parser and those are implemented in modules. I want to load such modules on demand.

[21:30] <gaal> how is this distinct from wanting a random other module of functionality?

[21:31] <gaal> I'm off to bed. later &

[23:44] <svnbot6> r8493 | Darren_Duncan++ |  r1666@Darren-Duncans-Computer:  darrenduncan | 2005-12-27 15:39:54 -0800

[23:44] <svnbot6> r8493 | Darren_Duncan++ |  /ext/Rosetta-Incubator : in KeyedText.pm, changed all non-BUILD submethods to methods; in multiple files, removed any 'submethod' refs in documentation, changed any 'hash()' to '{}' in code

