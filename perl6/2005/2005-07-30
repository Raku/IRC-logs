[00:07] <ayrnieu> Are you sure?

[00:14] <brentdax> Pretty sure.  There's supposedly a deadline and stuff.

[00:30] <milna> hello

[00:30] <milna> Does anyone know of a good tutorial on haskell

[00:30] <milna> I have tried reading Pugs, but I dont understand it

[00:44] <meppl> i think there are many links on the haskell-website itself

[00:45] <meppl> www.haskell.org/learning.html

[00:49] <dudley> milna: If you want to shell out the money, Haskell: The Craft of Functional Programming is worth it

[00:51] <ayrnieu> milna - #Haskell also knows.

[01:51] <^conner_> There's been a request on #perl for Signatures::Readable::English

[02:16] *** brentdax_ is now known as brentdax

[04:38] <autrijus> greetings, Î›camels

[04:40] <Darren_Duncan> howdy

[04:41] <autrijus> :)

[04:46] <Khisanth> that is suppose to be an uppercase lambda?

[07:18] <gaal> morning

[08:02] *** coral_ is now known as coral

[09:01] <nothingmuch> hola

[10:07] <Aankhen``> ?eval role Foo { method bar () { "bar" } }; class Bar { does Foo; }; my $bar = Bar.new(); $bar.bar()

[10:07] <evalbot6> 'bar' 

[11:01] <Aankhen``> ?eval $?PUGS_VERSION

[11:01] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.8, July 13, 2005 (r5904)' 

[11:18] <gaal> ?eval ({a=>1,b=>2}).perl

[11:18] <evalbot6> '{(\'a\' => 1), (\'b\' => 2)}' 

[11:18] <gaal> ?eval {a=>1,b=>2}.perl

[11:18] <evalbot6> '{(\'a\' => 1), (\'b\' => 2)}' 

[11:18] <gaal> on the command line, this:

[11:18] <gaal> ./pugs -e 'say {a=>1,b=>2}.perl'

[11:18] <gaal> gives this:

[11:19] <gaal> a 1 b 2\undef

[11:19] <Aankhen``> Same Pugs version?

[11:19] <gaal> r5904

[11:19] <gaal> ?eval $PUGS_VERSION

[11:19] <evalbot6> Error: Undeclared variable: "$PUGS_VERSION" 

[11:19] <Aankhen``> ?eval $?PUGS_VERSION

[11:19] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.8, July 13, 2005 (r5904)' 

[11:20] <Aankhen``> I can't confirm, unfortunately; going through `make test`.

[11:20] <gaal> then you already have a pugs :)

[11:20] <Aankhen``> Oh yeah.

[11:20] <Aankhen``> Silly me.

[11:20] <iblech> ?eval say {a=>1,b=>2}.perl

[11:20] <evalbot6> a 1b 2\'perl6' bool::true 

[11:20] <iblech> ?eval say ({a=>1,b=>2}.perl)

[11:20] <evalbot6> {('a' => 1), ('b' => 2)} bool::true 

[11:20] <gaal> hey, say's back. cool..

[11:21] <Aankhen``> Same behaviour here, yeh.

[11:21] <Aankhen``> Hiya iblech. :-)

[11:21] <gaal> where'd that "perl6" come in from?

[11:21] <Aankhen``> o_O

[11:21] <gaal> i have "\undef", which is wrong but less surprising.

[11:22] <iblech> It seems it's parsed as (say {a => 1, b => 2}).perl -- the stringification of the hashref is "a\t1\nb\t2", and the result of the say is undef...

[11:22] <iblech> Hi :)

[11:22] <iblech> That's probably from evalhelper.p5's implementation of &say

[11:23] <gaal> hmm. what's say's return value specced to be?

[11:23] <Aankhen``> wolverian: Ping.

[11:23] <gaal> i'd assume p5 semantics?

[11:23] <iblech> Yep, 1 if the print worked, 0 (or false) otherwise

[11:23] <iblech> putter: pong

[11:23] <gaal> fail would be nice...

[11:24] <gaal> how useful is a 1 anyway?

[11:25] <gaal> the string printed might be nice.

[11:25] <gaal> s/nice/more useful/

[11:26] <iblech> Hm, I like fail... Probably it is fail, as I remember reading that &open fail()s too

[11:26] <Aankhen``> Why does `make install` trigger re-compilation of Pugs.Run and the pre-compiled modules?

[11:27] <gaal> weird, why did that say originally return undef? i'm looking at the code and it looks correct

[11:27] <gaal> return  $ VBool  True

[11:27] <gaal> Aankhen``: make smoke does, too :( i don't know how to fix this dependency business

[11:28] <Aankhen``> :-\

[11:38] <Aankhen``> gaal, got a minute?

[11:38] <gaal> sure

[11:39] <Aankhen``> Could you see whether test 55 of t/builtins/io/io.t fails for you?

[11:40] <gaal> http://perlcabal.org/gaal/smoke_xp.html will be up in a sec :-)

[11:40] <Aankhen``> Ah, great!

[11:41] <Aankhen``> I just want to make sure I didn't break the Prelude. :-)

[11:41] <gaal> up.

[11:41] <Aankhen``> Yay.

[11:41] <Aankhen``> gaal++

[11:41] <Aankhen``> Not Found

[11:41] <Aankhen``> The requested URL /gaal/smoke_xp.html was not found on this server.

[11:42] <gaal> missed a ~ there.

[11:42] <gaal> http://perlcabal.org/~gaal/smoke_xp.html

[11:42] <Aankhen``> Ah.

[11:42] <gaal> oops :)

[11:42] <Aankhen``> Hehe.

[11:42] <gaal> so, yeah, it fails.

[11:43] * Aankhen`` nods.

[11:43] * gaal has a temperature and a sore throat :(

[11:43] <Aankhen``> Awww. :-(

[11:48] <gaal> does any string evaluate as false in perl 6?

[11:48] <gaal> ?eval ?""

[11:48] <evalbot6> bool::false 

[11:48] <gaal> ?eval ?"0"

[11:48] <evalbot6> bool::false 

[11:48] <gaal> ?eval ?"1"

[11:48] <evalbot6> bool::true 

[11:48] <gaal> ah. :)

[11:49] <gaal> ?eval ?"0 but weird"

[11:49] <evalbot6> bool::true 

[11:49] <gaal> ?eval ?"00"

[11:49] <evalbot6> bool::true 

[11:49] <Aankhen``> I've created a `role Iter` in the Prelude, and modified `IO` and `Str` to `does Iter`.

[11:49] <Aankhen``> `Iter` defines &prefix:<=> like so: multi sub prefix:<=> (Iterator $self: ) { $self.shift() }

[11:49] <Aankhen``> Um, that's Iter $self:.

[11:50] <gaal> cool

[11:50] <Aankhen``> And method shift () { ... }

[11:52] <gaal> ?eval ?"0\n"

[11:52] <evalbot6> bool::true 

[11:53] <gaal> ?eval "" ~~ bool::false

[11:53] <evalbot6> bool::true 

[11:58] <Aankhen``> Hmmmmmmm.

[11:58] <Aankhen``> Any objections to my implementing a mutating `map` and `grep` in Prelude.pm?

[12:00] <gaal> i know i want them... but this looks like a Q for the language list

[12:00] <Aankhen``> Well, it's there in S29.

[12:00] * gaal looks

[12:00] <Aankhen``> Rather, they are already specified in S29.

[12:01] <Aankhen``> ?eval sub foo () { }; sub bar ($foo) { }; sub baz ($foo, *@bar) { }; (&foo.arity, &bar.arity, &baz.arity)

[12:01] <evalbot6> (0, 1, 2) 

[12:01] <Aankhen``> ?eval sub foo () { }; sub bar ($foo) { }; sub baz ($foo, *@bar, +$baz) { }; (&foo.arity, &bar.arity, &baz.arity)

[12:01] <evalbot6> (0, 1, 3) 

[12:01] <nothingmuch> is destructive map MMD?

[12:01] <Aankhen``> nothingmuch: Wha?

[12:02] <nothingmuch> e.g. class array { method map (@input is rw) returns Void { ... } }

[12:02] <nothingmuch> that is - it cannot be used in non void context

[12:02] <nothingmuch> and it must be matched against mutable types

[12:02] <Aankhen``> I don't understand.

[12:04] <gaal> A: what makes the s29 map mutating?

[12:04] <Aankhen``> gaal: S29 map isn't mutating.

[12:04] <gaal> ah

[12:04] <Aankhen``> But there's a t/builtins/lists/mutating_listops.t which appears to require mutating `map`.

[12:05] <Aankhen``> And `grep`.

[12:05] <gaal> for a while didn't is rw work in map? i seem to remember

[12:05] <gaal> anyway

[12:05] <gaal> i need to lie down a bit

[12:05] <gaal> later :)

[12:05] <Aankhen``> See ya.

[12:17] <iblech> re. http://m19s28.vlinux.de/iblech/stuff/not_perm/pil2js-demo/t/smoke.html, 43.75% ok :)

[12:17] <svnbot6> r5905 | Aankhen++ | * Prelude.pm: made formatting more consistent; fixed typo.

[12:17] <svnbot6> r5906 | Aankhen++ | * Prelude.pm: added Iter role, and modified IO and Str accordingly.

[12:17] <iblech> (Spidermonkey's /bin/js)++ # Approximately as fast as normal Pugs

[12:17] <iblech> Firefox-- # sloow

[12:19] <iblech> Most tests fail because a. feature not yet implemented, b. they use eval, or c. a scalar container ($foo) holds an aggregate, not a scalar (fixing this currently)

[12:21] <Aankhen``> ?eval $?PUGS_VERSION

[12:21] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.8, July 13, 2005 (r5906)' 

[12:21] <Aankhen``> How come my Pugs doesn't show the revision?

[12:22] <integral> Aankhen``: checked out by svn, svk or other?

[12:23] <Aankhen``> SVK.

[12:23] <integral> and you're using a local branch?

[12:23] <Aankhen``> Yes.

[12:23] <integral> the script for getting the revision number (util/version_h.pl) when working with svk tries to look for the revision number of the upstream repository, not the local revision number.   I think it's so there's no confusion

[12:24] <Aankhen``> Ah.

[12:25] <integral> hmm, I think I wrote this, so it is to avoid confusion :)

[12:25] <nothingmuch> seen ingy

[12:25] <jabbot> nothingmuch: ingy was seen 1 days 15 hours 32 minutes 55 seconds ago

[12:25] <nothingmuch> rats

[12:26] <QtPlatypus> Is anyone else having trouble connecting to news.perl.org ?

[12:34] <QtPlatypus> I guess everyone isn't having any problem with it, all there all idle.

[12:57] <autrijus> PIL2JS 43.75% OK? holy lambda.

[12:57] <clkao> crazy

[12:57] <Aankhen``> QtPlatypus: news.perl.org redirects use.perl.org, which is working...

[13:01] <Aankhen``> Redirects to, even.

[13:01] * Aankhen`` steps away from the computer.

[13:14] * nothingmuch makes large cat sounds

[13:15] <nothingmuch> has anyone here got any Test::Base fu?

[13:20] <autrijus> me.

[13:20] <autrijus> not terribly fluent, but passable.

[13:27] <nothingmuch> autrijus: i am trying to fudge some stuff

[13:27] <nothingmuch> with skip

[13:27] <nothingmuch> you know my p5orth test suite?

[13:27] <nothingmuch> i just did mutual recursion this morning (3 minutes - a small change in the forth prelude... isn't that amazing?)

[13:27] <nothingmuch> and now i defined a convenience word: ":deferred"

[13:27] <nothingmuch> so you can say:

[13:28] <nothingmuch> defer even

[13:28] <nothingmuch> : odd ?dup if 1 - even else false then ;

[13:28] <nothingmuch> :deferred even ?dup if 1 - odd else false then ;

[13:28] <nothingmuch> but gforth doesn't have :deferredc

[13:28] <nothingmuch> so in my test spec i want to say:

[13:28] <nothingmuch> === :deferred

[13:28] <nothingmuch> --- skip: gforth

[13:29] <nothingmuch> --- forth

[13:29] <nothingmuch> ...

[13:29] <nothingmuch> and I just did that, it's not that bad a hack either

[13:29] <nothingmuch> and I would like ingy to apply it, or judge it

[13:29] <nothingmuch> and since ingy isn't here i'd like a Test::Base moose to judge it

[13:32] <autrijus> rehi

[13:32] <autrijus> (was rebooting)

[13:33] <autrijus> ok. let me look at the patch?

[13:37] <nothingmuch> sure

[13:39] <pasteling> "nothingmuch" at 212.143.91.217 pasted "Test::Base patch" (188 lines, 5.1K) at http://sial.org/pbot/12084

[13:39] <nothingmuch> oops

[13:39] <nothingmuch> that's a dumb patch

[13:40] <pasteling> "nothingmuch" at 212.143.91.217 pasted "Test::Base patch" (144 lines, 3.9K) at http://sial.org/pbot/12085

[13:40] <nothingmuch> okay, that makes more sense

[13:40] <nothingmuch> it does two things:

[13:40] <nothingmuch> makes --- SKIP in to a test builder skip

[13:41] <autrijus> looks pretty good

[13:41] <autrijus> also you force a plan number

[13:41] <nothingmuch> and --- skip into the same thing, only after eval

[13:41] <nothingmuch> and yes, it forces a plan number

[13:41] <autrijus> so three things in all

[13:41] <nothingmuch> true

[13:41] <autrijus> it looks good to me. send to ingy?

[13:42] <nothingmuch> will do

[13:42] <nothingmuch> i think this is a nice example of how functional programming can be more flexible than OOp

[13:43] <autrijus> well nowadays most OOP languages admit first class functions anyway.

[13:43] <autrijus> other than cobol, I mean java

[13:43] <nothingmuch> true

[13:43] <nothingmuch> but most people I know don't use them

[13:44] <nothingmuch> except for things like callbacks

[13:44] <autrijus> the main tension is pro-data or pro-operation

[13:44] <autrijus> termed the "expression problem"

[13:44] <nothingmuch> i think they are not really in a tension

[13:44] <autrijus> I highly recommend you look into the original wadler link and Scala's solution

[13:44] <autrijus> (both linked from my journal of yesterday)

[13:44] <nothingmuch> you can usually slice each sub apart

[13:44] <nothingmuch> line by line

[13:44] <nothingmuch> and determine which line is either this or that

[13:45] <autrijus> nothingmuch: the main problem is that it takes a lot of effort in Haskell if you add new construcor variants to a "data" declaration

[13:45] <autrijus> while it takes a lot of effort in (say) Java to add a new method to a bunch of classes.

[13:45] * nothingmuch goes to read

[13:45] <nothingmuch> how would you say perl 6 is in this respect?

[13:46] <autrijus> generics + MMD solves this nicely

[13:46] <autrijus> just as the Scala paper had it

[13:46] <nothingmuch>  hmm

[13:46] <nothingmuch> what is the date on your side of the world?

[13:46] <autrijus> (MMD let you define methods outside class; generics lets you pass type parameters around)

[13:46] <autrijus> 2005å¹´ 7æœˆ30æ—¥ å‘¨å…­ 21æ™‚46åˆ†49ç§’ CST

[13:46] <jabbot> autrijus: 2005å¹´ 7æœˆ30æ—¥æ˜¯æ˜ŸæœŸå…­

[13:46] <autrijus> er

[13:47] <autrijus> sorry, 2005-07-30

[13:47] <nothingmuch> and did you wake up today, or yesterday?

[13:47] <autrijus> I woke up 6 hours ago.

[13:47] * nothingmuch is trying to determine if "yesterday" really means yesterday, and then sees that there is only one journal entry that can be either

[13:47] <autrijus> right.

[13:48] <nothingmuch> anyway, should i just follow the Scalar link?

[13:48] <nothingmuch> and will you please join the cabal temporarily so that we can have proper type support?

[13:48] <autrijus> the "solution" link

[13:48] <autrijus> tho the "expression problem" is fun too

[13:48] <autrijus> eh, what does that has to do with this?

[13:49] <nothingmuch> i'm just not getting the impression that anybody that in @Larry but luke really cares what will happen to the type system

[13:49] <autrijus> oh Damian cares too

[13:49] <autrijus> he's the one that brought intersection types and generics up originally

[13:49] <nothingmuch> ah

[13:50] <nothingmuch> but we still don't have a definition of parametrized and relational types, right?

[13:50] <autrijus> actually we do, S06 has them, it's just the semantics are very unclear

[13:51] <autrijus> I already identified the problem spots as I can see them and posted to p6l

[13:51] * nothingmuch remembered it as a very thin example

[13:51] <nothingmuch> so can we say "this method takes an object that does Moose and returns a subroutine that returns (an object that contains an object of type Moose)"?

[13:52] <nothingmuch> sub moose_container (Moose $x) { [ $x ] };

[13:52] <nothingmuch> sub moose_container (Moose $x) { { the_key => $x } };

[13:52] <nothingmuch> s/sub/multi/;

[13:53] <autrijus> multi foo (Moose $x) returns Any of Moose { ... }

[13:53] <autrijus> multi foo (Moose $x) returns Source of Moose { ... }

[13:53] <autrijus> (hypothetically adopting the Source/Sink behaviour)

[13:53] <autrijus> but really, you want

[13:53] <nothingmuch> err, i meant

[13:54] <autrijus> foo (Moose $x) returns (Array|Hash) of Moose { ... }

[13:54] <nothingmuch> sub moose_container (Moose $x) { -> { [ $x ] } }

[13:54] <autrijus> oh

[13:54] <nothingmuch> i think there is too much orthogonality in the perl 6 type system to allow 'Moose of Elk' to capture it well

[13:54] <autrijus> returns (Code returns Moose)

[13:54] <nothingmuch> right

[13:54] <autrijus> returns (Code of () returns Moose)

[13:55] <nothingmuch> can we manipulate types as first class objects?

[13:56] <autrijus> sure

[13:56] <autrijus> at runtime

[13:56] <nothingmuch> what is the type of a type?

[13:56] <autrijus> Type, supposedly

[13:56] <nothingmuch> an object of type Type?

[13:56] <nothingmuch> that is both liberating and limiting

[13:56] <nothingmuch> because i would like a Type to be parametrized on it's value

[13:57] <autrijus> that's called dependent types.

[13:57] <nothingmuch> well, yes, and no

[13:57] <autrijus> speak in code please :)

[13:57] <nothingmuch> yes, i'm trying

[13:57] <nothingmuch> my Moose $x;

[13:57] <nothingmuch> $x.container.meta.type is Type of Moose;

[13:58] <nothingmuch> it's also just a Type

[13:58] <nothingmuch> damnit! someone resubscribed me to the most bullshitting list in the world

[13:59] <nothingmuch> what is the type signature of 'ref'?

[13:59] <autrijus> &ref?

[13:59] <nothingmuch> i would say 'sub ref ((:a) $x) { Type of :a };

[13:59] <nothingmuch> yes

[14:00] <autrijus> sub ref (Any $x) returns Type;

[14:00] <nothingmuch> see, that sort of sucks

[14:00] <nothingmuch> i really meant:

[14:00] <autrijus> my p6l proposal has this:

[14:00] <nothingmuch> sub ref ((:a) $x) returns Type of :a { Type of :a };

[14:00] <autrijus> sub ref (Any $x) returns Type of ref($x);

[14:01] <autrijus> essentially having ref() as a type form

[14:01] <nothingmuch> hmm

[14:01] <nothingmuch> fair enough

[14:01] <autrijus> sub one_of ($x, $y of ref($x)) returns ref($x) { rand(2) ?? $x :: $y }

[14:01] <autrijus> this has the good property in that we avoid type variables.

[14:01] <autrijus> which never felt perlish to me anyway

[14:02] <nothingmuch> i think i want both this and type variables

[14:02] <nothingmuch> side tracking:

[14:02] <autrijus> but the only place the spec has tyvar is on generic roles

[14:02] <nothingmuch> can you define a variable in the parameter list that isn't a parameter?

[14:02] <autrijus> and I'm not even sure we what it there.

[14:02] <autrijus> nothingmuch: huh?

[14:03] <nothingmuch> sub moose ($x, ... # somehow define $y here #) { $y available }

[14:03] <nothingmuch> $y is based on $x

[14:03] <nothingmuch> but is not an optional parameter with a default expression that is based on $x

[14:03] <autrijus> sub moose ($x) { my $y := $x; }

[14:03] <autrijus> what's wrong with this?

[14:04] <nothingmuch> because i'd like to reuse $y in the prototype

[14:04] <nothingmuch> e.g.  $y = ref($x); manipilate $y a bit; ... returns $y;

[14:04] <autrijus> sub moose ($x) returns ref($x).of.blah.bleh {...}

[14:05] <autrijus> if you want to much with types, use type operators

[14:05] <nothingmuch> type operators?

[14:05] <autrijus> for example, | & ^ of

[14:05] <autrijus> selectors even

[14:05] <nothingmuch> that's not turing complete

[14:05] <autrijus> ah, you want the compiler to go into infinite loops

[14:05] <autrijus> how very unkind of you.

[14:06] <nothingmuch> =)/.

[14:07] <nothingmuch> seriously though

[14:07] <nothingmuch> in a language that is not completely compiled in one go

[14:07] <nothingmuch> but is optionally compilable at runtime

[14:07] <nothingmuch> we need two things:

[14:07] <nothingmuch> to be able to give the compile time enough info to be fast

[14:07] <nothingmuch> and to give the runtime enough access so it loses no features

[14:08] <nothingmuch> and i think there's a bunch of deltas in the type system

[14:08] <autrijus> and I completely agree ;)

[14:08] <nothingmuch> that is - they cannot express everything the runtime can make up

[14:08] <nothingmuch> or using them is a compile time only feature

[14:09] <autrijus> the important thing to bear in mind is that perl6 observes the separate compilation doctrine

[14:09] <autrijus> a module provides, to the external world, "link sets"

[14:09] <nothingmuch> right

[14:09] <autrijus> and as such _cannot_ trigger recompilation every time a consumer uses it

[14:09] <autrijus> that is in direct contrast to perl5

[14:10] <nothingmuch> but on the other hand if the module defines an import sub

[14:10] <nothingmuch> which eval's some code

[14:10] <nothingmuch> you get something like perl 5

[14:10] <autrijus> nope.

[14:10] <nothingmuch> nope?

[14:10] <autrijus> let me try to explain

[14:10] <nothingmuch> nono! i will never let you!

[14:10] <autrijus> alright.

[14:10] <autrijus> I won't explain then

[14:10] <nothingmuch> you have to pay a fee

[14:11] * nothingmuch charges autrijus for one cookie

[14:11] <nothingmuch> will you accept the charges?

[14:11] <autrijus> ;)

[14:12] <autrijus> cookie

[14:12] <nothingmuch> i'll take that as a yes

[14:12] <nothingmuch> you may continue

[14:12] <nothingmuch> no, i mean an IRL one, the next time we meet

[14:12] <nothingmuch> strings are just a representation

[14:12] <autrijus> whatever.

[14:12] <autrijus> the important thing is

[14:13] * nothingmuch jumps up triumphantly: I GOT A FREE COOKIE!

[14:13] <nothingmuch> (rocky soundtrack in the background)

[14:13] <autrijus> in p5, the consumer is allowed to set compilation hints that affects the compilation of the use'd module.

[14:13] <nothingmuch> like?

[14:13] <autrijus> use strict::with::pride;

[14:13] <autrijus> (bad example)

[14:14] <autrijus> a better one is

[14:15] <autrijus> foo.pm:

[14:15] <autrijus> say 123;

[14:15] <autrijus> main.pl:

[14:15] <autrijus> sub foo::say { die }; use foo;

[14:16] <autrijus> or, more explicitly

[14:16] <autrijus> foo.pm:

[14:17] <autrijus> our &boo ::= \&say;

[14:17] <autrijus> and main.pl being the same.

[14:17] <autrijus> in p5, &boo always binds to "die"

[14:17] <autrijus> in p6, it cannot be so.

[14:17] <autrijus> (actually, ::= &say), but you got the idea.

[14:19] <nothingmuch> yes

[14:20] <nothingmuch> so how do you change the module's say in perl 6?

[14:20] <nothingmuch> no way what so ever?

[14:20] <autrijus> oh, easy

[14:20] <autrijus> you load its textual content and eval it.

[14:20] <autrijus> ;)

[14:21] <nothingmuch> okay: a distinction is in order

[14:21] <nothingmuch> in perl 6 compilation is a caching strategy

[14:21] <nothingmuch> err 5, not 6

[14:21] <nothingmuch> that is - it's only purpose is to gain speed

[14:21] <nothingmuch> it doesn't have any functional effect whatsoever

[14:21] <nothingmuch> if it does, that's a bug

[14:22] <nothingmuch> in perl 6, on the other hand, a compiled module and the source to compile it are not necessarily parts of the same equasion

[14:22] <autrijus> er, no

[14:22] <autrijus> p5 has two phases

[14:22] <autrijus> two runtimes

[14:22] <autrijus> or rather three

[14:22] <autrijus> BEGIN, main, eval

[14:22] <autrijus> eval may contain its own BEGIN main and eval

[14:22] <autrijus> and so on

[14:22] <autrijus> to use a module is to eval its textual content in BEGIN time.

[14:22] <nothingmuch> yes

[14:23] <autrijus> in p6, each module is separately compiled from scratch

[14:23] <nothingmuch> and eventually you wind up with a tree of compiled stuff in memory

[14:23] <autrijus> as a fresh environment

[14:23] <nothingmuch> okay, rephrasing question:

[14:23] <nothingmuch> is the object CompiledModule

[14:23] <nothingmuch> a complete blackbox?

[14:23] <nothingmuch> does it only have the "exported_symbols" method?

[14:24] <nothingmuch> or is it a nested structure

[14:24] <nothingmuch> so that $some_module->linked_modules contains Prelude and Guts

[14:24] <nothingmuch> and their instances are provided by the runtime

[14:25] <nothingmuch> and are the same as the consuming modules

[14:25] <nothingmuch> and then the symbols can also be overridden:

[14:25] <nothingmuch> Prelude can have it's 'say' replaced

[14:25] <nothingmuch> or rather, say, that comes from prelude can be replaced

[14:26] <nothingmuch> thus not affecting externally compiled code, just what externally compiled code links to

[14:26] <autrijus> if Prelude has its "say" replaced

[14:26] <autrijus> it needs to be swapped in with something of equivalent type

[14:26] <autrijus> otherwise all typecheck was in vain.

[14:27] <nothingmuch> right

[14:27] <nothingmuch> when rebinding say if you replace it with something typed otherwise it's an error

[14:27] <nothingmuch> if you use ::= it's a compile time error

[14:28] <nothingmuch> if the types are coerciable

[14:28] <nothingmuch> for example sub { die }

[14:28] <nothingmuch> the return type of 'die' can be coerced into a string but error or string

[14:28] <nothingmuch> and the parameters can be coerced into a the same thing say uses

[14:29] <nothingmuch> except the parameters are thrown away

[14:29] <nothingmuch> (if there are things like 'where' or defaults which are more than just bindings then this cannot be done automatically)

[14:29] <nothingmuch> in a sense, this can be type sound

[14:29] <nothingmuch> unless it isn't

[14:29] <nothingmuch> in the many cases it is, there shouldn't be a reason for it not to

[14:30] <autrijus> yeah. I'm fine with you hacking in the environment

[14:30] <autrijus> as long as the linkset interface is immutable

[14:30] <autrijus> sacred, holy, etc

[14:30] <nothingmuch> right

[14:30] <nothingmuch> and the only situation that really happens is if everything is unboxed

[14:30] <nothingmuch> because you can just pass mock objects around instead

[14:31] <nothingmuch> uh, s/un//

[14:31] * nothingmuch ponders the 'faux' operatore

[14:31] <nothingmuch> $thing faux Type of ....;

[14:32] <nothingmuch> let's say something can't numify

[14:32] <autrijus> Faux pax Americana;

[14:32] <nothingmuch> "Moose" faux Num;

[14:32] <nothingmuch> +$faux; # 0

[14:32] <nothingmuch> or can't stringify:

[14:33] <nothingmuch> ~(Something.new faux String); # "DUMMY"

[14:36] * nothingmuch sidetracks again:

[14:36] <nothingmuch> can unboxing be generalized?

[14:37] <autrijus> I'm of the opinion that value types is a myth, so don't ask me

[14:37] <nothingmuch> especially WRT accessors for objects of closed classes

[14:38] <autrijus> I think value types is valid

[14:38] <autrijus> and value types should handle (un)boxing automagically

[14:38] <nothingmuch> hmm

[14:38] <autrijus> and that's all.

[14:38] <nothingmuch> please accurately define value types

[14:38] <nothingmuch> Int et al?

[14:39] <autrijus> right, base types that has no notion of identity

[14:39] <nothingmuch> why?

[14:40] <autrijus> 1 =:= 1

[14:40] <autrijus> 1 =:= 2

[14:40] <autrijus> also, it makes little sense to derive from value types.

[14:40] <nothingmuch> right

[14:40] <nothingmuch> but why stop at that?

[14:40] <nothingmuch> class Foo { has $moose };

[14:41] <nothingmuch> if Foo is closed and not basal,

[14:41] <nothingmuch> is there any reason to make 'my Foo $x; $x.moose' a method call?

[14:41] <nothingmuch> it should be an O(1) lookup

[14:41] <nothingmuch> since we have all the required knowlege at compile time:

[14:41] <nothingmuch> what is the definition of Foo

[14:41] <nothingmuch> what is in a moose

[14:42] <nothingmuch> what is the type of the method moose

[14:42] <nothingmuch> whether or not Foo can change

[14:42] <autrijus> really. what is the type?

[14:42] <nothingmuch> and what concrete types can be a Foo

[14:42] <nothingmuch> in this example Any or whatever the default type of is

[14:42] <nothingmuch> and scalar

[14:42] <autrijus> &moose:(Foo) returns Any?

[14:43] <nothingmuch> yup

[14:43] <autrijus> thing is Foo can't be guaranteed as closed :-/

[14:43] <nothingmuch> $moose can contain anything

[14:43] <nothingmuch> no it isn't

[14:43] <autrijus> which calls for two compilations, but we covered that in hackathon

[14:43] <nothingmuch> i'm talking just about the accessor

[14:43] <nothingmuch> you don't need to do something along the lines of $x.meta.class.find_method("moose").

[14:43] <autrijus> and I agree :)

[14:44] <nothingmuch> since you can assume that lookup will be constant, given your knowlege now that you are compiling it

[14:44] <autrijus> now, consider this

[14:44] <nothingmuch> this is just static dispatch

[14:45] <nothingmuch> no for the unboxing:

[14:45] <autrijus> class Foo { has Foo $moose }; my Foo $x; $x.moose.moose;

[14:45] <autrijus> can the second .moose call be done in O(1) as well?

[14:45] <nothingmuch> given $x.meta.class.find_method("moose") { when Accessor { # compile unboxed } default { # compile a call } }

[14:45] <nothingmuch> no

[14:45] <autrijus> why?

[14:45] <nothingmuch> wait

[14:45] <nothingmuch> does method chaining in perl 6 behave differently?

[14:46] <autrijus> it's same as p5.

[14:46] <nothingmuch> ($x.moose) can be compiled to an access directly into $x's structure

[14:46] <autrijus> $x->moose->moose;

[14:46] <nothingmuch> that can be of type any

[14:46] <nothingmuch> okay

[14:46] <autrijus> but I declared

[14:46] <autrijus> has Foo $.moose;

[14:46] <nothingmuch> oh, i didn't notice

[14:46] <nothingmuch> yes it can

[14:46] <autrijus> but why?

[14:46] <autrijus> because we have a type inferencer? ;)

[14:46] <nothingmuch> yes =)

[14:46] <autrijus> a local type inferencing propagation engine?

[14:47] <autrijus> that's what I'm arguing for :)

[14:47] <nothingmuch> but at this level it's just an optimization

[14:47] <nothingmuch> which we already have

[14:47] <autrijus> no, it can also reject programs.

[14:47] <nothingmuch> oh, right

[14:47] <autrijus> $x.moose.goose; # instant death under closed/final

[14:47] <nothingmuch> okay, in that case it's what i've been arguing for all along =D

[14:47] <nothingmuch> huraah!

[14:48] * nothingmuch does the Sound Type dance

[14:48] <autrijus> and severe warning -- i.e. has to be turned off specifically -- by default.

[14:48] <nothingmuch> i don't see why

[14:48] <autrijus> why warning?

[14:48] <nothingmuch> there is absolutely no scenario where this will not croak at runtime if Foo was closed

[14:48] <autrijus> nope.

[14:48] <nothingmuch> or am I missing something?

[14:48] <autrijus> multi goose (Foo $x) {1}

[14:49] <nothingmuch> foo is closed

[14:49] <nothingmuch> it can't be extended

[14:49] <autrijus> class Bar { method goose }; Foo is reopened does Bar;

[14:49] <nothingmuch> reopened?!

[14:49] <autrijus> (also MMD doesn't mean extension usually.)

[14:49] <nothingmuch> you don't gain anything from closed if you have reopen

[14:50] <nothingmuch> well, it might not "mean" extension in the logical sense

[14:50] <nothingmuch> but in effect by declaring a multimethod you're modifying the types of all the involved parameters

[14:50] <autrijus> ...which is why they are much better than visitor patterns...

[14:50] <nothingmuch> since they have added functionality when they are combined

[14:51] <autrijus> because they don't require anything on the behalf of original author of Foo

[14:51] <nothingmuch> right

[14:51] <autrijus> even inder closed + final

[14:51] <nothingmuch> except that you have an unclosed version of the module

[14:51] <nothingmuch> eep

[14:51] <nothingmuch> multi sub &infix:<+> (Int, MyType);

[14:52] <autrijus> although I'm also arguing that if you "close" current scope

[14:52] <nothingmuch> that breaks all unboxing whatsoever

[14:52] <autrijus> i.e. not only :classes<close> but also :packages

[14:52] <autrijus> then the only way to introduce multi goose is by "my sub" or "my multi"

[14:52] <autrijus> which is fine, because that'd be lexical.

[14:52] <nothingmuch> hmm

[14:52] <autrijus> and an "eval" won't be able to propagate out.

[14:52] <nothingmuch> i think the following closing semantics are sane:

[14:53] <nothingmuch> closedness of a class is lexically scoped to it's consumers

[14:53] <nothingmuch> that is Foo is closed to our $x.moose.moose call

[14:53] <nothingmuch> but unclosed bytecode is retained

[14:53] <autrijus> (I agree totally :))

[14:53] <nothingmuch> and a block that declares 'my goose (Foo $x) { 1 }' will have to  use the open one

[14:53] <autrijus> (yes. we've discussed this in hackathon.) :)

[14:53] <nothingmuch> ah =)

[14:53] <nothingmuch> really? i must have zoned out

[14:53] <autrijus> you were drunk.

[14:54] <nothingmuch> i was not drunk

[14:54] <autrijus> okay, then something worse

[14:54] <nothingmuch> i was sleep deprived

[14:54] <autrijus> ah.

[14:54] <nothingmuch> during the hackathon i slept about 4-5 hours a night

[14:54] <nothingmuch> went to bed late for Canada

[14:54] <autrijus> well the behaviour interface is isomorphic

[14:54] <nothingmuch> woke up late for Israel

[14:54] <nothingmuch> (which is 5-6 am canada)

[14:54] <nothingmuch> except on the last days

[14:54] * stevan remembers nothingmuch being drunk quite often

[14:54] <autrijus> nodnod

[14:55] <nothingmuch> stevan: i drank a lot of beer

[14:55] <nothingmuch> and i'm clumsy when sober

[14:55] <stevan> burning pizzas and such

[14:55] <nothingmuch> so i think you got the wrong impression

[14:55] <nothingmuch> that was a type coercion problem

[14:55] <nothingmuch> i explicitly said "Baking paper"

[14:55] <nothingmuch> and then john said "you mean wax paper?"

[14:55] <nothingmuch> and I made a bad optimization assuming "wax" means "baking" in canadian

[14:57] <nothingmuch> autrijus: do @Larry agree with us?

[14:57] <nothingmuch> because I was really traumatized when on the last or second day of YAPC when we were up in your room, and you mentioned that our type inferrencer is just optimizing, not type checking

[14:58] <autrijus> nothingmuch: I have no idea. we'll see how @Larry replies to my mails in the previous two days.

[14:59] <nothingmuch> okay

[14:59] <autrijus> TSa is very supportive, but he argues from a far more static position, so I'm not surprised.

[14:59] <nothingmuch> i have to reread them

[14:59] <nothingmuch> admittedly i only skimmed

[15:00] <nothingmuch> anyway, i feel like forthing a bit more

[15:00] <autrijus> that's fine, the main proposal is http://www.nntp.perl.org/group/perl.perl6.compiler/1000

[15:00] <autrijus> sure, go ahead. have fun :)

[15:00] <nothingmuch> i want to port most of p5orth to forth

[15:00] <nothingmuch> so that I don't have to code that much haskell ;-)

[15:00] * autrijus wonders if nothingmuch will enjoy Joy

[15:01] <nothingmuch> that's not very googleable

[15:01] <autrijus> nothingmuch: well if you like the lack of parens as much as schemers like parens, then forth is very deep and fun indeed :)

[15:01] <autrijus> http://www.latrobe.edu.au/philosophy/phimvt/joy.html

[15:01] <nothingmuch> parens ini lisp are just syntax

[15:02] <autrijus> lisp interpreter in joy: http://www.latrobe.edu.au/philosophy/phimvt/joy/lsplib.joy

[15:02] <nothingmuch> scheme is just a tree

[15:02] <nothingmuch> forth is just an array

[15:02] <autrijus> yes.

[15:02] <nothingmuch> but when you create the array you get to pretend it's a tree

[15:02] <nothingmuch> so hence forth has higher order macros, not functions =)

[15:03] <autrijus> and Joy to Forth is a bit like Perl5 to Perl4, if I may :)

[15:04] <nothingmuch> wow, that's sounds pretty

[15:04] <nothingmuch> wowowowww,  that's so cool

[15:04] <nothingmuch> http://en.wikipedia.org/wiki/Joy_programming_language

[15:04] <nothingmuch> the SQUARE

[15:05] <nothingmuch> if i got it right

[15:05] <nothingmuch> wait, is it pushing '*' on the stack or not?

[15:06] <autrijus> yes.

[15:06] <nothingmuch> *phew*

[15:06] <nothingmuch> that explanation is not very good

[15:06] <autrijus> I prefer http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html

[15:06] <nothingmuch> okay, where is the distinction?

[15:07] <nothingmuch> why isn't '.' applied to 'dup'?

[15:07] <nothingmuch> how do i get a higher order dup? just quasi quote it?

[15:07] <autrijus> the . is not there

[15:08] <autrijus> the . is ending DEFINE

[15:08] <nothingmuch> oh

[15:08] <autrijus> yes, quasiquoting is happy

[15:08] <autrijus> [1 2 3 4]  [dup *]  map

[15:08] <autrijus> ===> evaluates to [1 4 9 16]

[15:08] <autrijus> fun eh.

[15:08] <nothingmuch> so basically the only place where you can evaluate is top level?

[15:09] <autrijus> right. that's what a pure functional language means.

[15:09] <autrijus> see haskell :)

[15:09] <nothingmuch> because if I said DEFINE moose = [1 2 3 4] [dup *] map .

[15:09] <nothingmuch> and then I said moose

[15:09] <nothingmuch> it's like i said [[1 2 3 ...] map ], right?

[15:09] <nothingmuch> didn't say pure on the top of that page

[15:09] <nothingmuch> wikipedia, that is

[15:09] <autrijus> I think so, yes, it's referentially transparent

[15:09] <autrijus> oh. http://www.latrobe.edu.au/philosophy/phimvt/joy/forth-joy.html

[15:09] <autrijus> it's the first sentence.

[15:10] <autrijus> "The language Joy is a purely functional programming language."

[15:10] <nothingmuch> "The Joy programming language is a simple functional programming language"

[15:10] <nothingmuch> damn wikipedia

[15:10] <nothingmuch> since when are "purely" and "simple" intgerchangiable?!

[15:10] <autrijus> changed wikipedia.

[15:10] <autrijus> it now says "purely".

[15:11] <nothingmuch> =)

[15:11] * autrijus praises the writable web

[15:11] <brentdax> My little project is nearly at the same level of external sophistication as a basic wiki.

[15:12] <nothingmuch> brentdax: @{ }

[15:12] <autrijus> brentdax: ooh

[15:12] <autrijus> nothingmuch: so, Joy's style is utterly pointless

[15:12] <autrijus> I mean point-free

[15:12] <nothingmuch> =)

[15:13] <autrijus> and because of this, it agrees with the Forth structure perfectly

[15:13] <autrijus> I think it's a wonderful language to play with :)

[15:13] * nothingmuch wonders what you can do with it

[15:13] <brentdax> You can edit now with a preview mode.  I need to refactor to allow page creation, though.  After that, all it needs is a markup language for formatting and a little tweaking to the link-resolving code.

[15:13] <autrijus> larry is still thinking about my posts, I hope... he just fielded the simple ones 

[15:14] <autrijus> brentdax: demo demo

[15:14] <nothingmuch> brentdax: by @{ } i meant: please dereference the reference to your little project, i don

[15:14] <nothingmuch> 't know what it is =)

[15:14] <brentdax> Ah--WWW::Kontent, my Summer of Code project.

[15:14] <autrijus> oh, it's Kombat, his Winter of Microsoft project

[15:15] <brentdax> autrijus: takes about ten seconds to run a request on my laptop--I'd be insane to put it on a web server.

[15:15] <nothingmuch> ah

[15:15] <autrijus> brentdax: url to code?

[15:15] <nothingmuch> brentdax: perl6.nl

[15:15] <nothingmuch> feather.perl6.nl

[15:17] <brentdax> http://svn.brentdax.com/kontent/trunk

[15:18] * nothingmuch wonders how implementing Joy in Forth might be

[15:22] <nothingmuch> oh my, refactoring is indeed in order

[15:22] <nothingmuch> i reimplemented ' as a word

[15:23] <nothingmuch> when I had it implemented as a primitive ;-)

[15:38] * nothingmuch is very very evil

[15:38] <svnbot6> r5907 | Stevan++ | Perl6::MetaModel - (p5)

[15:38] <svnbot6> r5907 | Stevan++ | * moved all the magic in AUTOLOAD into ::dispatch 

[15:38] <svnbot6> r5907 | Stevan++ |    - first step in refactoring out Perl 5 sugar

[15:38] <autrijus> oooh.

[15:38] <autrijus> stevan++

[15:38] * nothingmuch thinks of adding forth code which will take listed data stack ops

[15:38] <nothingmuch> copy them

[15:38] <nothingmuch> relocate

[15:38] <nothingmuch> and then replace all the stack primitives in use by traversing the tree

[15:38] <nothingmuch> to generate RDUP from DUP, etc

[15:39] <nothingmuch> and to do this in the forth prelude

[15:39] <nothingmuch> stevan++

[15:39] <nothingmuch> will i be bitchslapped for this?

[15:42] <autrijus> iblech: you there?

[15:43] <iblech> autrijus: Yep

[15:44] <autrijus> care to lay out your preferred container semantics?

[15:44] <autrijus> I'm working on formalism now

[15:45] <autrijus> so I think I should start with the PIL2JS treatments

[15:45] <iblech> Sure :)

[15:45] <autrijus> so the bulk of code is in lib6/Prelude/JS/ContainerName.pm?

[15:46] <iblech> No, that file doesn't exist :) Most of it is in libjs/PIL2JS.js, the .GET, .STORE, and .BINDTO methods of PIL2JS.Box

[15:47] <autrijus> ok.

[15:47] <iblech> The general idea is that a variable name points to a container, and containers have the .GET method (returns the unboxed value), .STORE, and .BINDTO (basically this.GET = other.GET, this.STORE = other.STORE, etc.)

[15:47] <iblech> Every container has a .uid attribute which is used for =:=

[15:48] <autrijus> the STORE case is just for lvalue positions?

[15:49] <iblech> Right.

[15:49] <autrijus> and if BINDTO preserves uid, don't we need a clone?

[15:49] <autrijus> i.e. just like BINDTO but with different uid

[15:49] <iblech> PIL2JS.Box is the only real container class, PIL2JS.Box.Constant's .STORE only die()s.

[15:49] <autrijus> or, alternatively, a "copy" primitve operation on containers

[15:50] <autrijus> oh nvm, you already have it.

[15:50] <autrijus> just not spelled as CLONE

[15:50] <iblech> Yep, .STORE is used for that: my $a = $b is container_of_a.STORE(b), and .STORE sets this.value = b.GET()

[15:50] <autrijus>   // Needed for "is copy".

[15:50] <autrijus>   clone: function () {

[15:50] <autrijus>     return new PIL2JS.Box(this.GET());

[15:50] <autrijus>   },

[15:51] <autrijus> I'm referring to this

[15:52] <autrijus> that implementation looks suspicious

[15:53] <iblech> .clone is only a convenience function. For is copy support, I could emit $a = $a (container_of_a.STORE(container_of_a)), too

[15:53] <iblech> How so? It returns a new variable container, initialized with the current contents

[15:54] <autrijus> nvm, I was confused by the relation to perl6's .clone.

[15:54] <autrijus> (which is deep)

[15:54] <autrijus> never mind me :)

[15:55] <iblech> Right. This is why I've renamed it to .copy here :)

[15:55] <autrijus> good.

[15:56] <autrijus> so, why is BINDTO a prim?

[15:56] <autrijus> why is it not modifying the symbol table?

[15:57] <autrijus> i.e. why should a box be able to bind to another box of different shape?

[15:57] <autrijus> I can see NEW, FETCH, STORE, but I still don't quite grok BINDTO.

[15:57] <iblech> "We can't just use C<dest = source>, because C<dest> might be the result of some

[15:57] <iblech> function, e.g. C<@array[$idx] := $foo>."

[15:57] <iblech> (from README)

[15:57] <autrijus> I see.

[15:59] <autrijus> so this calls to yet another underlying level in the host environment

[15:59] <autrijus> that can maintain reallocation

[15:59] <autrijus> in Hs we used writeTVar for BINDTO, essentially, without naming it

[15:59] <autrijus> so, is this the shape for all containers, or just scalar containers?

[16:00] <iblech> For all.

[16:00] <autrijus> so if I implement "tiescalar", I'm implementing something on a higher level.

[16:00] <autrijus> or "tiehash" etc.

[16:00] <iblech> "Why isn't there a array_fetchElem?" -- Simply because I didn't need it -- i.e. some_array_container.GET().push(...) works fine

[16:01] <iblech> (or some_array_container.GET()[...], for that matter)

[16:02] <autrijus> still thinking

[16:02] <iblech> I think so. There's PIL2JS.Box.Proxy, too, but that's one the same level as PIL2JS.Box. It's used in &postcircumfix:<[ ]> and &postcircumfix:<{ }>

[16:03] <autrijus> ok.

[16:04] <autrijus> so when I run BINDTO, I basically overwrite both my uid and my content

[16:04] <iblech> Yep.

[16:04] <iblech> Which is effectively the same as container_a = container_b, but works with function return values, too

[16:05] <autrijus> in haskell:

[16:05] <autrijus> data Container = TVar (Box a)

[16:05] <autrijus> data Box a = MkBox { uid     :: Unique , content :: a }

[16:05] <autrijus> does that look correct?

[16:05] <autrijus> "a container is a mutable reference to a Box that carries its type"

[16:06] <autrijus> "a Box is a uid, with a content of some type"

[16:06] <iblech> Yep.

[16:06] <autrijus> now the hard question!

[16:06] <autrijus> in general you can't replace one content with another unless they are of the same type "a".

[16:06] <autrijus> is the type "a" essentially "Dynamic"?

[16:06] <autrijus> i.e. you can bind anything to anything.

[16:07] <autrijus> (I've read your posts, so I'm intentionally applying the socrates method) :)

[16:08] <autrijus> my Int $x; my Num $y; $x := $y;

[16:08] <autrijus> is essentially what I'm asking.

[16:08] <autrijus> assuming that the "Int" is 'a' here, i.e. we actually allocate different storage for different types.

[16:09] <iblech> Hm... I'd say that works, as the type is associated with the .value. But you can't %a := @b

[16:09] <iblech> Err

[16:10] <iblech> It should not typecheck, of course.

[16:10] <iblech> But my $x = 3; my $y = [...]; $x := $y should work

[16:10] <autrijus> how about

[16:10] <autrijus> my Int $x = 3; my $y = [...]; $x := $y;

[16:11] <autrijus> ?

[16:11] <autrijus> this is really a hard question, because as you observed

[16:11] <autrijus> %a := @b; # should be runtime error even passed typechecker

[16:12] <autrijus> but currently nothing in p6 explicitly forbids this.

[16:12] <iblech> Should not work, as [...] is not an Int. The type declarations are attached to the varname, I think -- if you see a "my Int $x" you should be able to be sure that $x is always a Int, even if some code rebinds $a somewhere

[16:12] <autrijus> ?eval my %a := [1..10]; %a[0]

[16:12] <evalbot6> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

[16:12] <autrijus> ?eval my %a := (1..10); %a[0]

[16:12] <evalbot6> \1 

[16:13] <autrijus> okay. so

[16:13] <autrijus> my %a

[16:13] <autrijus> means

[16:13] <autrijus> my Hash %a;

[16:13] <autrijus> essentially.

[16:13] <autrijus> (disregarding the fact that it means 'hash of hash' in external language)

[16:13] <autrijus> (I mean in internal language)

[16:13] <autrijus> iblech: so. try this

[16:14] <autrijus> my $x; $x := 3; $x := "Hello";

[16:14] <iblech> I think the reason %h := @a should not work is not of the types of the values in the containers, but because of incompatible container types (HASH vs. ARRAY)

[16:14] <autrijus> valid?

[16:14] <autrijus> I expect you to say valid. :)

[16:14] <iblech> Yep, as $x is of type Any, and both 3 and "Hello" are Anys

[16:14] <iblech> :)

[16:14] <autrijus> ok. so our definition is wrong

[16:14] <autrijus> data Container = TVar (Box a)

[16:14] <autrijus> data Box a = MkBox

[16:14] <autrijus>    { uid   :: Unique

[16:15] <autrijus>    , value :: forall b. b < a

[16:15] <autrijus>     }

[16:15] <autrijus> is the desired semantics

[16:15] <autrijus> now, who decides the '<' relationship.

[16:16] <autrijus> if I had said

[16:16] <iblech> Probably, but as I don't know what forall b. b < a means, I can't say for sure :)

[16:16] <autrijus> oh, it means "all values that instantiates this type needs to be a subtype of a"

[16:16] <autrijus> < is the subtype notation

[16:16] <iblech> Ok

[16:16] <autrijus> so Int < Any

[16:16] <autrijus> but not the other way around

[16:17] <autrijus> so, now

[16:17] <autrijus> my Int $x; $x := &say;

[16:17] <autrijus> is obviously bogus

[16:17] <iblech> Right.

[16:17] <autrijus> but can I say

[16:17] <autrijus> role Code is reopened does Int {...}

[16:17] <autrijus> ?

[16:18] <autrijus> and expect that to work

[16:18] <iblech> I think so.

[16:18] <autrijus> good. we are in agreement then :)

[16:18] <iblech> :)

[16:19] <autrijus> ok, now let's look at the scalar type.

[16:19] <integral> iblech++ autrijus++

[16:19] <autrijus> formalization++ :)

[16:19] <autrijus> what does scalar provide beyond a simple container?

[16:20] <iblech> Nothing, I think.

[16:21] <autrijus> I can think of one thing

[16:21] <autrijus> namely the TIE and UNTIE primitives.

[16:21] <autrijus> my $x; tie($x => OtherClass); untie($x);

[16:22] <autrijus> for the duration of the program, OtherClass is supposed to provide STORE and FETCH

[16:22] <autrijus> until untie()

[16:22] <iblech> Oh, right.

[16:23] <integral> does tie like that exist? (or need to?)

[16:23] <autrijus> integral: yes and yes

[16:23] <iblech> But OtherClass doesn't have, of course, any influence on BINDTO.

[16:23] <autrijus> yes.

[16:23] * autrijus wonders when will we start to disagree

[16:24] * autrijus is thinking

[16:25] <autrijus> so, a scalar augments a container's interface

[16:25] <autrijus> making it a subtype of a container

[16:25] <autrijus> still thinking

[16:26] <autrijus> we can adopt an open-world view or a closed-world view.

[16:26] <autrijus> a closed-world view says there are limited forms of container types

[16:26] <autrijus> and &tie can deduce them base on simple casing

[16:27] <wolverian> Aankhen``, pong

[16:27] <Aankhen``> wolverian: Hola.

[16:27] <autrijus> under that view, the language provides several mutually incompatible tie interfaces, and that's all

[16:27] <wolverian> hello. I've been away a bit. :)

[16:27] <Aankhen``> I was wondering: are you planning to port URI?

[16:27] <Aankhen``> s/port/refactor/ as appropriate.

[16:28] <wolverian> Aankhen``, yes, but I've been really tired now; my medication hasn't kicked in yet. 

[16:28] <autrijus> see the definition of IVar for an example of closed world

[16:28] <autrijus> do you think it makes sense?

[16:28] <Aankhen``> wolverian: What happened?

[16:28] <wolverian> I sleep 16 hours a day and I'm tired the rest.

[16:28] <wolverian> Aankhen``, hypothyroidism.

[16:29] <autrijus> (this is about tieability, not about container allocation per se)

[16:29] <Aankhen``> Ah.

[16:30] <iblech> autrijus: I think that'll work.

[16:30] <autrijus> an open-world view will mean that you can selectively tie anything.

[16:30] <autrijus> i.e. only tie FETCH but not STORE

[16:30] <wolverian> Aankhen``, I guess I'm out of it for a month still, or so. :\ 

[16:31] <iblech> But one can emulate not tieing STORE by simple relaying STORE requests to the original container

[16:31] <Aankhen``> wolverian: S'okay. Take your time.

[16:31] <autrijus> or tie both PRINTLINE _and_ KEYS.

[16:31] <wolverian> thanks. I will. :)

[16:31] <Aankhen``> wolverian: Is it curable?

[16:32] <autrijus> although with the ability of MMD'ing &{} %{} @{}, there's little gain in doing that.

[16:32] <wolverian> Aankhen``, yes, simply by administering thyroxine, the hormone the thyroid gland is supposed to produce.

[16:32] <Aankhen``> wolverian: I see.

[16:33] <wolverian> Aankhen``, it however takes a long time for the hormone levels to rise back to normal. it is also tricky to find the right amount to take daily.

[16:33] <autrijus> okay, closed world then. next question. who inhabits this closed world?

[16:33] <autrijus> Scalar, Handle, Array, Hash, obviously.

[16:33] <Aankhen``> wolverian: OK. Anyway, don't mind me, it was nothing important. Go rest.

[16:33] <iblech> Right. I think many of Perl 5's SPECIALTIESUBS aren't needed in P6, as they're simple method/mmd calls

[16:33] <autrijus> yup.

[16:34] <autrijus> but still tie acts on container and mmd on value

[16:34] <autrijus> so mmd can be open but it makes sense for tie to be closed.

[16:34] <wolverian> Aankhen``, nah, I have a few hours now of being semiawake. :) or an hour. that goes pretty much to checking the mailing lists and planets. and you guys here. :)

[16:34] <Aankhen``> wolverian: Ahh.

[16:34] <iblech> Hm, do we need Handle? As $fh is a simple scalar (which happens to contain an IO object)

[16:34] <iblech> Right.

[16:35] <Aankhen``> AFK for a bit. &

[16:35] <autrijus> iblech: you mean

[16:35] <autrijus> $*ERR := MyInterceptedThing.new

[16:35] <autrijus> ?

[16:35] <iblech> Right.

[16:36] <autrijus> oh, btw.

[16:36] <autrijus> my $x = 123; my Int $y; $y := $x;

[16:36] <autrijus> valid?

[16:37] <iblech> Hm, unsure. What if somebody does $x = "hi" later...

[16:37] <autrijus> (it's a very tricky question.)

[16:38] <autrijus> my $x = 123; sub f (Int $y is rw) { $x = "hello!" }; f($x);

[16:38] <autrijus> what really happens? :)

[16:39] <iblech> Type error.

[16:39] <autrijus> at which stage?

[16:39] <autrijus> function application or assignment?

[16:39] <iblech> $y = "hello!"

[16:39] <autrijus> I didn't say $y.

[16:39] <autrijus> $x = "Hello"

[16:40] <iblech> Oh, I assumed you typoed $x

[16:40] <autrijus> I didn't. :)

[16:40] <iblech> Ok, then no error at all, as $x isa Int

[16:41] <autrijus> not after the assignment tho.

[16:41] <autrijus> my $x = 123; sub f (Int $y is rw) returns Int { $x = "hello!"; $y }; f($x);

[16:41] <iblech> Oh!

[16:42] <autrijus> according to my treatment of Box above

[16:42] <autrijus> the function application should fail.

[16:42] <autrijus> but that's weird.

[16:42] <iblech> Ok, that's a type error then, and the appl shouldn't typecheck.

[16:42] <iblech> But it's correct, I think...

[16:43] <autrijus> nod. the problem does happen even if you had used normal $y

[16:43] <autrijus> i.e. read only

[16:43] <autrijus> only by "is copy" you avoid this.

[16:43] <autrijus> this just in from larry!

[16:43] <autrijus>     $x = @array;

[16:43] <autrijus>     $x := @array;

[16:43] <autrijus> Hey, who said anything about consistency?  :-)

[16:44] <autrijus> (he thinks those two forms should be identical)

[16:45] <iblech> He's wrong I think: If you re-assign the first $x, @array is unchanged, but if you change the second $x, @array is changed, too

[16:46] <iblech> my $x = [1,2,3]; my $y = $x; $x = [4,5,6]; say $y   # 1 2 3

[16:46] <iblech> my $x = [1,2,3]; my $y := $x; $x = [4,5,6]; say $y   # 4 5 6

[16:47] <autrijus> my @array = (1,2,3); $x := @array; $x = 10;

[16:47] <autrijus> this is a STORE call to an array container.

[16:48] <autrijus> should it work by pun?

[16:48] <autrijus> or should it be rejected?

[16:48] <autrijus> I don't like punning, so I'd say rejected.

[16:49] <iblech> Hm, I'd say it should be rejected, too.

[16:49] <iblech> But $-variables may never point to an array container, I think.

[16:49] <autrijus> why so?

[16:50] <autrijus> ah. because you are also a close worldist and think $ stands for Container::Scalar.

[16:50] <iblech> Yep, $ is always scalar, @ always array, % always hash.

[16:50] <autrijus> so the := fails due to container type mismatch.

[16:51] <autrijus> but larry says we vivify @array to a new anonymous scalar container that contains a ref to it.

[16:51] <iblech> Or, alternatively, should that reall be $x := \@array, which would work?

[16:51] <autrijus> and then BINDTO $x to that.

[16:51] <autrijus> and discard the anon scalar container

[16:51] <iblech> s/reall/really/

[16:51] <autrijus> this does have the net effect of having := to be same with =

[16:52] <autrijus> again, all this logic needs to be hard coded in the BINDTO.

[16:53] <autrijus> so, amazingly, we three are in agreement this time :)

[16:53] <iblech> Ah, right, I see it now :)

[16:54] <autrijus> ok. so we agree that we ditch TIEHANDLE.

[16:54] <autrijus> that plays well with the removal of the * sigil.

[16:54] <autrijus> we still have two sigils left, though.

[16:54] <autrijus> & and ::

[16:54] <autrijus> let's tackle & first

[16:55] <autrijus> tie(&say => SomeOtherClass)

[16:55] <iblech> I'd say & is really $, but with its type fixed to Code, so one can't say &foo = 3

[16:55] <autrijus> no.

[16:55] <autrijus> unless you want &foo = &say;

[16:55] <iblech> I want that :)

[16:55] <autrijus> oh, you want that. :)

[16:56] <autrijus> the idea of a separately tieable &foo is that we can intercept calls.

[16:56] <autrijus> or lie about parameters

[16:56] <autrijus> and .assuming.

[16:56] <autrijus> but all these can be done with function wrapping

[16:57] <iblech> Right.

[16:57] <autrijus> under &say;

[16:57] <autrijus> er

[16:57] <autrijus> undefine &say;

[16:57] <autrijus> what does that mean?

[16:58] <iblech> FWIW, TSa would probably say &foo(...) is really &postcirumfix:<( )>(&foo, ...), but this has got the problem of calling &postcirumfix:<( )>...

[16:58] <autrijus> TSa's view is essentially a tieable &foo with APPLY.

[16:58] <autrijus> which has its merits

[16:58] <autrijus> (APPLY, like FETCH, would be tieable)

[16:59] <autrijus> and &foo won't have FETCH and STORE; whenever you want FETCH, it yields a ref to it.

[16:59] <iblech> I think that's ok, but of course calling say won't work afterwards. Consider $x = &say; undefine $x; $x(...)

[17:00] <autrijus> ok.

[17:01] <autrijus> hm, we don't distinguish between an undefined array and a zero-length array.

[17:01] <autrijus> nvm.

[17:02] <autrijus> hm.

[17:02] <autrijus> internalls perl5 always saw CV as something other than SV

[17:02] <svnbot6> r5908 | chromatic++ | Make Test::Builder::Tester test pass (ignore tested module's test header).

[17:03] <autrijus> hm.

[17:04] <autrijus> ok. if we say &foo is merely like Foo $foo 

[17:04] <autrijus> er

[17:04] <autrijus> Code $foo

[17:04] <autrijus> then it follows that tie(&foo => ...) would work

[17:04] <autrijus> with only FETCH and STORE

[17:04] <autrijus> since it's tiescalar as usual.

[17:04] <iblech> Yep.

[17:04] <autrijus> i.e. it's a constrained scalar container.

[17:05] <autrijus> I'm actually fine with that.

[17:05] <iblech> :)

[17:05] <autrijus> okay. finally, ::

[17:05] <autrijus> which is the package type

[17:06] <autrijus> that implements exciting things such as nested namespaces, type inhabitation, dispatch, etc.

[17:06] <autrijus> allow tying on :: is akin to tying the symbol table, plus type checking and dispatch.

[17:06] <autrijus> perl5 never let you do that.

[17:07] <iblech> But we certainly want that in P6.

[17:07] <autrijus> ::CGI = ::Main;

[17:07] <autrijus> what does _that_ mean anyway.

[17:07] <iblech> our $foo = 42; ::CGI == ::Main; say $CGI::foo # 42

[17:08] <autrijus> aha, but there's more!

[17:08] <iblech> err, s/==/=/

[17:08] <autrijus> CGI.new.does(Main); # true

[17:08] <iblech> Right.

[17:09] <iblech> Everywhere you can say CGI you can say Main now.

[17:09] <autrijus> BEGIN { tie(::CGI => FakeCGI) }; package CGI; sub foo {...}

[17:09] <gaal> ?eval my IO $x; say ($x.say("should not print")).perl

[17:09] <evalbot6> should not print bool::true bool::true 

[17:10] <autrijus> FakeCGI gets to handle registration of new symbol!

[17:10] <autrijus> and reopend!

[17:10] <autrijus> and other things!

[17:10] <gaal> ?eval undef.say("hmm")

[17:10] <evalbot6> hmm bool::true 

[17:10] <autrijus> do you enjoy this level of madness? :)

[17:10] <iblech> Of course! :)

[17:11] <autrijus> now, hard question time

[17:11] <autrijus> ::CGI = (::Main | ::DBI);

[17:11] <autrijus> ::PPI = :(Int, Int);

[17:12] <autrijus> if your intuition is the first is okay and the second is not

[17:12] <autrijus> then that means packages and types are really orthogonal.

[17:14] <gaal> hey, a new planet was discovered.

[17:14] <iblech> Hm, I'd say both work... ::Foo can either be the same as Foo (i.e. class object), or it's a "real" type like :(Int, Int)

[17:15] <brentdax> &  #Touring an unconsecrated Mormon temple

[17:15] <brentdax> (of all the random things to be doing.)

[17:16] <iblech> BBIAB, food

[17:16] <autrijus> iblech: but, it makes sense to tie packages

[17:16] <autrijus> but less sense to tie types

[17:16] <autrijus> and if you are saying Type is the top level container and it just happens Package is Type

[17:17] <autrijus> then the tie interface on non-package types would be bogus.

[17:18] <autrijus> on the other hand, the tie interface fo scalar is also bogus for read-only things.

[17:18] <autrijus> so that's not a big problem.

[17:18] <gaal> autrijus: can you give me a hint on implementing 'use fatal'?

[17:19] <autrijus> gaal: see Fatal.pm

[17:19] <gaal> what, on p5?

[17:19] <autrijus> yup

[17:20] <gaal> there's already a fail_; should use fatal "just" set the caller's $?FATAL_SHOULD_DIE?

[17:20] <autrijus> oh, you mean _that_ fatal

[17:20] <autrijus> not Fatal

[17:20] <autrijus> sorry.

[17:21] <autrijus> you want it to be lexical, so you need to get lexical export to work

[17:21] <autrijus> other than that it's fine

[17:22] <gaal> %CALLER::<%MY::FATAL_SHOULD_DIE> modulo syntax etc?

[17:22] <autrijus> that works too.

[17:22] <autrijus> yes.

[17:22] <gaal> we don't have 'no' yet, do we?

[17:22] <autrijus> nope.

[17:22] <autrijus> iblech: ok. so, provisional recap

[17:22] <gaal> thanks.

[17:23] <autrijus> in Perl 6, container is a box with a type, an ID and a content.

[17:23] <autrijus> but users won't see containers directly.

[17:23] <autrijus> there are scalar, hash, array and type containers.

[17:24] <autrijus> those four can refer to a primitive container

[17:24] <autrijus> or be overriden with tie.

[17:25] <autrijus> if that sounds okay with you, I'll get a prototype going tomorrow :)

[17:25] <autrijus> meanwhile I need to nap a bit... bbiab.

[17:25] <autrijus> (or bbl, depends)

[17:32] <iblech> autrijus: re. Yep, that's exactly what I had in mind, I think :)

[17:44] <nothingmuch> shit! someone put my pants in the laundry before I took my wallet out

[17:45] <nothingmuch> my thumb drive is now cleaner

[17:45] <nothingmuch> but probably not functional

[17:45] <gaal> so much money laundering takes place in this country

[18:16] <autrijus> rehi.

[18:19] <nothingmuch> hola

[18:19] <autrijus> I'll start prototyping in PIL.hs

[18:19] <autrijus> and see how far it goes.

[18:20] <nothingmuch> the haskell PIL evaluator?

[18:20] <autrijus> yes, starting with the container primitives

[18:20] <autrijus> unlike certain other languages which only have "ref"

[18:20] <autrijus> as the sole container

[18:20] <nothingmuch> btw, do we have a perl 6 impl?

[18:20] <autrijus> we have mutable "scalar", "array", "hash" and "type".

[18:20] <autrijus> perl 6 impl of that?

[18:20] <nothingmuch> yes

[18:21] <nothingmuch> of a PIL evaluator

[18:21] <autrijus> metacircular evaluator?

[18:21] <nothingmuch> yes

[18:21] <autrijus> what fun is that?

[18:21] <autrijus> (sure, we need to have that, but I don't think it's neccessary or fruitful for this stage)

[18:21] <autrijus> although you are certainly welcome to work on it :)

[18:21] <nothingmuch> well, if it's too long then PIL<->Perl 6 is perhaps not a good mapping as we thought

[18:21] <svnbot6> r5909 | autrijus++ | * cleanup to remove obsolete IMC code.

[18:22] <autrijus> er.

[18:22] <autrijus> sub eval_pil (PIL $pil) { eval $pil.dump_as_perl6 }

[18:22] <autrijus> done!

[18:22] <nothingmuch> bah

[18:22] <nothingmuch> i mean implementing the perl 6 types in perl 6, using perl 6 types

[18:23] <nothingmuch> and really walking the structure, not compiling it

[18:23] <autrijus> yes, I know.

[18:23] <autrijus> and I'm saying sure, this needs to happen eventually, but it makes little sense until we can run that underlying code.

[18:23] <nothingmuch> again, not as something of any practical use

[18:23] <autrijus> no, eventually that will be of much use

[18:23] <autrijus> see docs/notes/plan

[18:23] <nothingmuch> i mean right now it doesn't have a practical use

[18:24] <nothingmuch> except to meter how pewrl 6 and pil juxtapose

[18:24] <autrijus> right.

[18:24] <autrijus> I don't think that meters anything really

[18:24] <autrijus> at this stage

[18:26] <nothingmuch> fair enough

[18:28] <autrijus> iblech: hm, I think the argument against TIEHANDLE applies to TIETYPE.

[18:28] <autrijus> iblech: i.e. container types should concern with data storage; types are always scalars in term of data storage

[18:29] <autrijus> hence any interception can be done by binding to a proxy

[18:29] <iblech> Oh, yes, of course

[18:29] <autrijus> I'm thinking about unifying Array and Hash into Keyed (or "Aggregate").

[18:29] <autrijus> since Hash is list of pairs and lookup of strings

[18:30] <autrijus> Array is list of values and lookup of ints

[18:30] <Aankhen``> A la JavaScript?

[18:31] <autrijus> but I'm not sure about that (the list/lookup relationship differ), so I'm keeping those two.

[18:33] <autrijus> in certain other languages, arrays are always bounded

[18:33] <autrijus> but in perl6 arrays are more like doubly linked lists.

[18:34] <Aankhen``> Bounded?

[18:34] <autrijus> having a finite set of possible keys.

[18:34] <autrijus> usually ordered

[18:36] <Aankhen``> Ah.

[18:38] <autrijus> instance Arbitrary Container where arbitrary   = oneof $ map return [ Scalar, Array, Hash ] coarbitrary = assert False undefined

[18:38] <autrijus> er.

[18:38] <autrijus> instance Arbitrary Container where

[18:38] <autrijus>     arbitrary   = oneof $ map return [ Scalar, Array, Hash ]

[18:38] <autrijus>     coarbitrary = assert False undefined

[18:38] * autrijus praises the infinite conciseness of QuickCheck

[18:47] <Aankhen``> ?eval sub foo () { sub bar () { "BAR" }; bar() }; say foo(); say bar();

[18:47] <evalbot6> BAR BAR bool::true 

[18:50] <iblech> Aankhen``: re. That's correct, sub bar {...} is really BEGIN { our &bar = sub {...} }, so &bar is not installed lexically

[18:50] <iblech> You've to use my sub bar if you want the second bar() to fail.

[18:51] <Aankhen``> Ah, I see.

[18:51] <Aankhen``> Is Hash::kv known to bomb in PIR?

[18:54] <autrijus> probably.

[19:28] <nothingmuch> http://www.cpushack.net/

[19:29] <nothingmuch> specifically http://www.cpushack.net/CPU/cpu.html#tableofcontents

[19:31] <nothingmuch> interesting processors:

[19:31] <nothingmuch> ARM

[19:31] <nothingmuch> AMD 29000

[19:31] <nothingmuch> intel IA-64

[19:31] <nothingmuch> DEC Alpha

[19:35] <Darren_Duncan> I'm happy to report that my OSCON Lightning Talk was accepted

[19:35] <Darren_Duncan> http://darrenduncan.net/OSCON/OSCON2005LightningTalk.txt

[19:35] <Darren_Duncan> I appreciate any input to chopping about a quarter of the speech length off while retaining the highest impact parts and/or say everything more tersely

[19:36] <Darren_Duncan> so who here is going to OSCON?

[19:37] <svnbot6> r5910 | iblech++ | PIL2JS:

[19:37] <svnbot6> r5910 | iblech++ |   * my $a := @a, my $a := %a work correctly now (hopefully).

[19:37] <svnbot6> r5910 | iblech++ |   * The @foo in sub foo (@foo) {...} is guaranteed to be an Array and not a

[19:37] <svnbot6> r5910 | iblech++ |     Ref, even if called like foo [1,2,3].

[19:37] <svnbot6> r5910 | iblech++ |   * The $foo in sub foo ($foo) {...} is guaranteed to be a Scalar (for example,

[19:37] <svnbot6> r5910 | iblech++ |     a Ref of Array), even if called like my @a = <a b c d>; foo @a.

[19:37] <svnbot6> r5910 | iblech++ |   * Removed Prelude::JS::OO as &ref and &isa need to operate not only on

[19:37] <svnbot6> r5910 | iblech++ |     references, but on aggregates, too. Moved the implementation of &ref and

[19:38] <svnbot6> r5910 | iblech++ |     &isa to libjs/PIL2JS.js.

[19:38] <svnbot6> r5910 | iblech++ |   * PIL::Nodes -- my @a is not my @a = (undef) any longer, but my @a = ().

[19:38] <svnbot6> r5910 | iblech++ |     Similar for %h.

[19:38] <svnbot6> r5910 | iblech++ |   * Probably many tests broke, will go through them and fix.

[19:39] <coral> wow

[19:39] <iblech> %hash.elems and $pair.elems should not work, right?

[19:39] <iblech> (Only @array.elems)

[19:42] <nothingmuch> coral: don't be alarmed, iblech simply likes karma D;-)

[19:42] <nothingmuch> for example "Probably many tests broke" should not be a ++ at all ;-)

[19:42] <iblech> But on the same line there's "will go through them and fix" ;)

[19:42] <nothingmuch> that's +=0

[19:43] <coral> no alarm here

[19:43] <coral> i've been scaring people by talking about PIL2JS

[19:43] <nothingmuch> okay then s/alarmed/impressed/

[19:43] <nothingmuch> seriously though, iblech++ # wonderful work

[19:43] <coral> yes

[19:43] <coral> iblech++

[19:43] <iblech> Thanks :)

[19:44] <nothingmuch> Darren_Duncan: please expand on Rosetta::Emulator::DBI

[19:44] <autrijus> iblech++ # my task is reduced to documenting and formalizing your work :)

[19:44] <nothingmuch> and give the state of current "drivers"

[19:45] <nothingmuch> ah, the term I was looking for is "Engines"

[19:45] <nothingmuch> "An app can easily query whether an Engine provides for its needs." <-- what does this mean?

[19:45] <coral> jini!

[19:45] <autrijus> :r

[19:45] <autrijus> oops.

[19:45] <nothingmuch> does Rosetta offer support certain features on top of the engines, in a slow way?

[19:46] <coral> nothingmuch: that phrase you asked about reminds me of an old sun idea called "jini".

[19:46] <Darren_Duncan> The query thing can be done by the Rosetta method features()

[19:47] <Darren_Duncan> Rosetta::Emulator::DBI has the same API as DBI but uses Rosetta as a back-end

[19:48] <nothingmuch> coral: what does it do?

[19:48] <Darren_Duncan> given the length of the talk, I consider this module to be a tersest-priority ... important to name, but not go into much detail

[19:49] <nothingmuch> i just read about not very old but pretty weird sun idea called "picoJava" on that cpushack page

[19:49] <coral> nothingmuch: imagine zeroconf crossed with api discoverability

[19:49] <nothingmuch> Darren_Duncan: that's one sentance that makes it obvious.

[19:49] <coral> "hm, i seem to be on a network. anyone know how to get to the internet?"

[19:49] <nothingmuch> coral: polymorphic zeroconf?

[19:49] <coral> "hm, i seem to be on a network. anyone want to get to the internet?"

[19:49] <Darren_Duncan> Rosetta itself mainly just defines an API ... its added features mainly amount to doing input checking

[19:50] <nothingmuch> that was always my fantasy about what apple's rendevouz is or will be

[19:50] <Darren_Duncan> I wanted to give Engines the maximum flexibility to implement how they like

[19:50] <coral> i very like the idea of advertising web services over rendezvous

[19:50] <nothingmuch> until i realized that it's just "i'm ._local.tcp.moose"

[19:50] <Darren_Duncan> putting too much in the API may constrain Engine developers from using best practices

[19:50] <nothingmuch> Darren_Duncan: what engines are available?

[19:51] <Darren_Duncan> there's no reason one Engine can't subclass another if they want to share

[19:51] <Darren_Duncan> only one Engine exists currently, Rosetta::Engine::Generic, and it is technically a reference implementation, not the be all and end all

[19:51] <Darren_Duncan> but until more are made, it should service many needs

[19:53] <nothingmuch> Darren_Duncan: so basically in my Rosetta::Mapper::OO i will give a spec of "These features of the rosetta api" and anything I use under that is interchangiable?

[19:54] <Darren_Duncan> all Engines are interchangeable that declare support for the features() you want to use ... you can use that function to see programmatically that a user-chosen Engine will work for your Mapper::OO

[19:54] <coral> ooo, i like that

[19:55] <Darren_Duncan> part of my debate is how much "how to" info I put in the talk, and how much is left for people reading the POD

[19:56] <Darren_Duncan> I would love to say a bunch of "how to", but time is short, the talk is mainly to get people interested to find out more

[19:57] <Darren_Duncan> this said, I will tweak it now to account for your questions, to help aid in *understanding*

[19:58] <autrijus> iblech: formalization #1 is in

[19:58] <svnbot6> r5911 | autrijus++ | * container type formalism, draft #1

[19:58] <iblech> oooh :) /me goes to look

[19:58] <autrijus> I need to write it down in English too, so I'll do it here

[19:58] <autrijus> if you can help integrating it into comments, all the better. I'll also post to p6c :)

[19:59] <autrijus> (or is this p6l? not sure)

[19:59] <autrijus> I suspect p6c

[19:59] <autrijus> the gist is that there are only three kinds of Box

[19:59] <autrijus> a symbol is only bound to one of them, and never changes the type of its binding

[20:00] <autrijus> so we essentially have three zones, so to speak

[20:00] <autrijus> there is no way to cross zones

[20:00] <autrijus> this is neatly signified by sigils, but in the sigiless variant one would need to use explicit annotation.

[20:01] <autrijus> now a box is a mutable cell containing two things. one is its id

[20:01] <autrijus> and one is a possibly-tied content.

[20:01] <autrijus> toggling tiedness does not change their IDs

[20:02] <autrijus> now, there is an open question

[20:02] <autrijus> what happens when you do

[20:02] <autrijus> untie(%ENV); ?

[20:03] <autrijus> is that even allowed?

[20:03] <iblech> Then +%ENV is 0?

[20:03] <iblech> I.e. %ENV is then a plain normal hash

[20:03] <autrijus> but that means %ENV need to keep a shadow normal hash around

[20:04] <autrijus> because when you tie something, untie, manip the content, tie again, untie again

[20:04] <autrijus> we expect the content to be still there

[20:04] <autrijus> right?

[20:04] <iblech> Right.

[20:05] <autrijus> okay, then every tied variant needs to keep an untied counterpart around.

[20:05] <autrijus> (also this is in marked contrast with perl5)

[20:05] <autrijus> where you can't untie %ENV

[20:06] *** brentdax_ is now known as brentdax

[20:06] <iblech> Yep, as in P5 %ENV is simply a special variable supplied by perl, and in P6 it's an ordinary tied variable which happens to call Perl6::Internals::get_env($key)

[20:08] <Darren_Duncan> okay, I just updated http://darrenduncan.net/OSCON/OSCON2005LightningTalk.txt ...

[20:08] <Darren_Duncan> mainly at the end

[20:09] <Darren_Duncan> one sentence was edited to "An app can easily query the features() method to see whether an Engine provides

[20:09] <Darren_Duncan> for its needs."

[20:09] <Darren_Duncan> onother became "Use the 'Rosetta::Emulator::DBI' module, a DBI clone, and your legacy apps will

[20:09] <Darren_Duncan> gain freedom with nary a change; so no porting is necessary."

[20:09] <Darren_Duncan> the ", a DBI clone" was the added part

[20:10] <Darren_Duncan> that's how I shortened "provides the same API as DBI does"

[20:10] <autrijus> iblech: ok, then I changed the model to reflect this

[20:10] <autrijus> r5912

[20:11] <svnbot6> r5912 | autrijus++ | * tied stuff keeps the untied version around.

[20:11] <autrijus> each box now has three things: an id, a boxed value, and maybe a tied version of the value.

[20:12] <iblech> Ok.

[20:13] <autrijus> I wonder if there can ever be that we have a box with scalar value

[20:13] <autrijus> but somehow tied as array.

[20:13] <autrijus> does this make any sense?

[20:14] <nothingmuch> tied version of the value == itype interface?

[20:14] <nothingmuch> and value = representation of box?

[20:15] <nothingmuch> Darren_Duncan: that sounds better

[20:15] <geoffb> (coming in very late to this discussion) -- autrijus, do you mean like tying a string as an array of chars?

[20:15] <geoffb> Or a blob as an array of lines?

[20:17] <iblech> autrijus: Hm, I'd say no. $s are always scalars, no matter what. You can make $foo an arrayref, or you could $foo = Foo.new; method Foo::postcircumfix:<[ ]>($idx) {...}

[20:17] <svnbot6> r5913 | autrijus++ | * not always tied.

[20:17] <Darren_Duncan> also prepended "Engines are interchangeable, and " to one sentence

[20:17] <Darren_Duncan> nothingmuch, thanks for your input so far

[20:18] <nothingmuch> when is OSCON?

[20:18] <Darren_Duncan> OSCON starts in 2 days, on Monday August 1st

[20:18] <Darren_Duncan> the Lightning Talks are on thursday the 4th

[20:18] <Darren_Duncan> I have until then to revise the speech to make it better and fit it in 5 minutes

[20:19] <Darren_Duncan> the current one takes about 6-7 minutes to read aloud at a normal pace

[20:20] <nothingmuch> do you think you can make an engine for a specific database in that time?

[20:20] <autrijus> iblech: ok, I'll reflect that then.

[20:20] <nothingmuch> i think Generic is not enough for most people to say "i'm trying that out as soon as I get home", but is enough to get most people to say "i'll try that out in a few months"

[20:20] <autrijus> that makes it extremely easy to model.

[20:21] <iblech> :)

[20:21] <autrijus> r5914.

[20:21] <autrijus> we're down to 6 lines!

[20:22] <autrijus> so, a Box of something is either untied, where it contains an Id and a something

[20:22] <svnbot6> r5914 | autrijus++ | * Tied box variant is not allowed to disagree with untied.

[20:22] <autrijus> or tied, where it contains Id, something, and a tied something.

[20:23] <autrijus> during tie/untie, that something stays invariant.

[20:23] <Darren_Duncan> nothingmuch; no, it would probably take longer

[20:23] <Darren_Duncan> I'm not exactly a fast worker

[20:23] * autrijus thinks that is miles better than SvMG

[20:23] <coral> aiee, SvMG

[20:23] * coral chants the ritual cleansing curse

[20:23] <coral> and when the magic has passed through me, only perl remains

[20:24] <autrijus> heh.

[20:24] <autrijus> now, this treatment is different from Mg

[20:24] <autrijus> in MG, you can layer multiple tiedness on a container

[20:24] <Darren_Duncan> its already taken me 3 years of development to get where I am now, and basic selects etc aren't fully implemented yet

[20:24] <autrijus> and selectively pull away ones

[20:24] <autrijus> do we want that?

[20:24] <geoffb> autrijus, can you explain what's wrong with my question earlier (Why is making a string look like an array of chars not a tie of different container types?)

[20:24] <autrijus> geoffb: oh, sorry, missed it

[20:25] <geoffb> np

[20:25] <Darren_Duncan> what does work in that regard is that you can define selects, and generate the SQL, and connect to databases ... I have to connect the dots where the SQL is actually issued

[20:25] <autrijus> geoffb: $str ~= "hello"

[20:25] <autrijus> you want this to trigger PUSH?

[20:25] <Darren_Duncan> brb

[20:25] <geoffb> yes, or alternately push @str, ['h','e','l','l','o'] doing a concat

[20:26] <autrijus> so

[20:26] <autrijus> $str = DBI.connect(...)

[20:26] <autrijus> is typefail

[20:27] <autrijus> since it's not a string

[20:27] <geoffb> nod

[20:28] <autrijus> then this is indeed tying a scalar to an array.

[20:28] <svnbot6> r5915 | iblech++ | * t/builtins/arrays_and_hashes/kv.t -- s/%hash.elems/+%hash/, as, according to

[20:28] <svnbot6> r5915 | iblech++ |   S29, .elems works only on arrays. s/$pair.elems/1/ for the same reason.

[20:28] <svnbot6> r5915 | iblech++ | * New t/builtins/arrays/elems.t -- Tests for .elems.

[20:28] <autrijus> I mean, as an array.

[20:28] <geoffb> My view of tie was always "This allows me to make anything look like anything else -- I can really pretend this object is an array, or in particular this string is an array, this DB is a hash . . . "

[20:28] <nothingmuch> the way i saw ties is polymorphism extended into N syntaxes

[20:28] <nothingmuch> you are no longer bound to $array.index($index) for polymorphism

[20:29] <autrijus> geoffb: that is not perl5's tie anymore

[20:29] <nothingmuch> you can use a more intuitive interface: @array[$index]

[20:29] <autrijus> that is something far more radical :)

[20:29] <nothingmuch> autrijus: example please =)

[20:29] <autrijus> nothingmuch: geoffb's.

[20:30] <nothingmuch> the str push?

[20:30] <autrijus> this has the net effect of implementing

[20:30] <autrijus> $str := @chars;

[20:30] <geoffb> Sure, perl 5's tie required an object (ref) underneath, but I always saw that as merely working around limitations of Perl 5's object model, not anything essential to the concept

[20:30] <nothingmuch> tie is just 'does on containers'?

[20:30] <geoffb> nothingmuch, if I understand you right, yes

[20:30] <autrijus> and then all manip on @chars gets reflected to $str, and all manip to $str reflects on @chars.

[20:31] <nothingmuch> doesn't that introduce N-ary propagation issues

[20:31] <autrijus> nothingmuch: yes.

[20:31] <autrijus> geoffb: you can already establish such relationship in perl5 using mutual refs

[20:31] <nothingmuch> like if the middle of a string was slices, what happenes to the object

[20:31] <autrijus> or one way ref and overload

[20:31] <autrijus> geoffb: but that is going to hurt performance a lot

[20:31] <autrijus> so are you asking for a more native support for this?

[20:31] <nothingmuch> if a char is inserted between two arrays, which does it belong to?

[20:31] <geoffb> I'm not saying perl 5 can't do that -- I was asking why you were insisting that a container has to have the same type in both tied and untied case

[20:32] <autrijus> geoffb: oh, it's just agreeing with perl5.

[20:32] <geoffb> OIC

[20:32] <autrijus> I wasn't insisting :)

[20:32] <autrijus> I was asking.

[20:32] <nothingmuch> does uising a string as an array create a new container containing an array value tied to the string?

[20:32] <autrijus> nothingmuch: if so, there's nothing new

[20:32] <geoffb> I would like the bigger concept -- but I grant that it may be difficult/non-performant

[20:32] <autrijus> nothingmuch: geoffb I believe is asking for the same container to act polymorphically.

[20:33] <nothingmuch> okay, so how does the value behave?

[20:33] <autrijus> i.e. you have a Box Scalar constrained to contain Str, and then tie it to Tie::Array::Something

[20:33] <autrijus> nothingmuch: it's not about the value

[20:33] <autrijus> it's more like ~= now calls PUSH

[20:33] <autrijus> instead of FETCH+STORE

[20:33] * geoffb shrugs.  I like having expressive power, and a cheat sheet that says "this will kill performance, but it's there if you ever need it"  :-)

[20:33] <autrijus> geoffb: but you can simulate that pretty easily :)

[20:33] <autrijus> so there is expressive power

[20:33] <geoffb> Well, fair enough.

[20:34] <nothingmuch> i don't understand why it's so cool, frankly

[20:34] <autrijus> like, if you mmd over all Str methods and translate it to PUSH calls etc.

[20:34] <autrijus> that will instantly work.

[20:34] <autrijus> just not very fast.

[20:34] <geoffb> Hmmm.

[20:35] <geoffb> Please correct my assumption here: My assumption is that containers come in two flavors, tied and untied.  Untied containers allow the compiler/prelude to be as dirty as desired to be fast.  Tied containers force the compiler to emit completely primitive operations.

[20:36] <geoffb> (er, and part of that last sentence was, "but everything still works, just slowly")

[20:38] * geoffb is clearly missing something, sigh

[20:56] * nothingmuch is confused

[20:56] <svnbot6> r5916 | autrijus++ | * reflect the design decision that "is Tieable" is a compile-time

[20:56] <svnbot6> r5916 | autrijus++ |   decision that cannot be reverted at runtime.

[20:56] <nothingmuch> i stretched my arms up

[20:56] <nothingmuch> and the light flickered

[20:56] <nothingmuch> so i drew them back, and did it again, and it flickered again

[20:57] <nothingmuch> turns out it was the auto-brightness adjustment thing on the laptop

[20:57] <nothingmuch> for some reason i *still* think it's cool

[20:58] <autrijus> geoffb: no, your understanding is sound

[20:59] <autrijus> see PIL.hs

[20:59] <autrijus> r5916

[21:00] <nothingmuch> oh shit, i have 50 browser tabs to close again

[21:00] <nothingmuch> uptime is a curse in the days of tabbed browsing

[21:00] <autrijus> geoffb: there are some comments finally. please check if they disagree with your intuition

[21:02] <autrijus> iblech: 

[21:02] <Aankhen``> G'night.

[21:02] <autrijus> my %x; %x := %*ENV;

[21:02] <autrijus> what happens?

[21:02] <autrijus> or, try vice versa.

[21:02] <nothingmuch> bzzt

[21:03] <autrijus> according to my current model, it's either error bothways, _or_ %x only binds to the normal storage of %*ENV and ignore the magic

[21:03] <autrijus> while %*ENV := %x would drop the existing magic. I think.

[21:04] <iblech> Hm, I'd say %x := %*ENV is error, as %x is not tieable, and %*ENV := %x causes %*ENV to loose its tiedness and becomes a normal a hash then

[21:04] <autrijus> but.

[21:04] <autrijus> %*ENV := %x; tie(%*ENV)

[21:04] <autrijus> is sound

[21:05] <autrijus> so what really happened is just an implicit untie()

[21:05] <autrijus> to match the tiedness of %x.

[21:05] <nothingmuch> holy crap!

[21:05] <nothingmuch> it seems my disk on key is alive!

[21:05] <nothingmuch> it's data got zapped

[21:05] <nothingmuch> but it's still functional!

[21:07] <iblech> Yes, but where's the contradiction with my assuption? :) %*ENV := %x causes %*ENV to still be marked as potentially tieable, but, as %x is not tied, %*ENV isn't either after the binding

[21:07] <iblech> But you can re-tie %*ENV, while you couldn't tie %x, as %x isn't marked as tieable

[21:11] <autrijus> in that case %x := %*ENV is a compile time error, even.

[21:12] <iblech> Yep.

[21:13] <autrijus> cool.

[21:13] <iblech> :)

[21:15] <autrijus> so

[21:15] <autrijus> untie(%*ENV); %x := %*ENV;

[21:15] <autrijus> sound?

[21:16] <iblech> Yep.

[21:16] <iblech> But

[21:16] <autrijus> but? :)

[21:16] <iblech> then we can't generally detect %x := %*ENV as a compile-time error, consider: (&untie, &id).pick()(%*ENV); %x := %ENV

[21:16] <nothingmuch> so how do you alias %*ENV to %x?

[21:17] <nothingmuch> ::= ?

[21:17] <iblech> (As we can't know at compile-time if %*ENV is tied or not)

[21:17] <iblech> s/if/whether/

[21:17] <autrijus> why?

[21:17] <autrijus> oh, you mean at runtime.

[21:17] <autrijus> right.

[21:18] <autrijus> that's why I asked :) that means no compile time error checking in general.

[21:18] <autrijus> you meant "we can't know, at compile time, whether %*ENV will be tied at runtime)

[21:18] <iblech> Right, exactly.

[21:18] <svnbot6> r5917 | iblech++ | * Usual svn props.

[21:18] <svnbot6> r5917 | iblech++ | * t/builtins/lists/join.t -- Tests for join on one-element lists (should work),

[21:18] <svnbot6> r5917 | iblech++ |   and "hi".join(...), which should not work (but ("hi",).join(...) should work

[21:18] <svnbot6> r5917 | iblech++ |   -- that's the same as (42).kv (should not work) and (42,).kv (should work)).

[21:18] <svnbot6> r5917 | iblech++ | * PIL2JS: Unbroke many tests:

[21:18] <svnbot6> r5917 | iblech++ |   * Prelude::JS -- Stringification of one-element arrays and hashes works now.

[21:18] <svnbot6> r5917 | iblech++ |   * "Fixed" the stringification of pairs with keys eq "a" -- it's the Pair

[21:19] <svnbot6> r5917 | iblech++ |     being used in named parameter binding as well as normal object thing.

[21:19] <svnbot6> r5917 | iblech++ |   * Prelude::JS::Array -- join on one-element lists should work.

[21:19] <svnbot6> r5917 | iblech++ |   * Prelude::JS::Keyed -- Unbroke delete on arrays.

[21:19] <svnbot6> r5917 | iblech++ |   * Prelude::JS::Hash  -- Unbroke { $only_one_pair }.

[21:24] <nothingmuch> damn, it won't even partition

[21:24] * nothingmuch wonders if he needs 1gb or 512mb

[21:45] <svnbot6> r5918 | kolibrie++ | added make_swatch.p6 for making a paint colors swatch

[21:45] <svnbot6> r5918 | kolibrie++ | autogenerates an SVG image

[21:45] <svnbot6> r5919 | autrijus++ | * bind and untie

[21:45] <svnbot6> r5920 | iblech++ | * Renamed t/builtins/lists/undef_in_map.t to empty_list_in_map.t and added two

[21:45] <svnbot6> r5920 | iblech++ |   more tests to it.

[21:45] <svnbot6> r5920 | iblech++ | * PIL2JS: PIL::Nodes -- Unbroke &try -- many tests should pass again now, resmoking...

[21:49] <Darren_Duncan> are there any plans to do another Pugs release before OSCON?

[21:49] <svnbot6> r5921 | autrijus++ | * cosmetic polishing and avoid warnings

[22:04] <autrijus> hm.

[22:04] <autrijus> Darren_Duncan: when is that?

[22:04] <autrijus> iblech: consider

[22:04] <autrijus> $x := \@y;

[22:04] <autrijus> $x = 3;

[22:04] <autrijus> # error: 3 is not Ref ?

[22:04] <iblech> Yep, think so.

[22:04] <Darren_Duncan> OSCON starts in 2 days

[22:04] <Darren_Duncan> Aug 1-5

[22:04] <autrijus> will ($x = \@z) work in place of ($x = 3)?

[22:05] <Darren_Duncan> the conference proper is Aug 3-5, tutorials on 1-2

[22:05] <autrijus> the question is whether \@y produce an rvalue container

[22:05] <autrijus> which I think it does

[22:05] <iblech> Yep. And @y ~~ @z will be true then, I think

[22:05] <autrijus> otherwise you have

[22:05] <autrijus> \@y = \@z;

[22:06] <autrijus> which is highly dubious.

[22:06] <Darren_Duncan> see http://conferences.oreillynet.com/os2005/

[22:07] <Darren_Duncan> I'm heading off there at this time tomorrow

[22:08] <autrijus> ok , then I'll try a release.

[22:15] <svnbot6> r5922 | iblech++ | PIL.hs -- Hadockified comments and added a #ifndef HADDOCK around the GADT def.

[22:31] <autrijus> iblech: 

[22:31] <autrijus> %a =:= $b;

[22:31] <autrijus> always false or always error?

[22:31] <autrijus> I'm inclining toward false.

[22:31] <iblech> Hm, what about: my $b := @a; @a =:= $b?

[22:32] <iblech> Probably false, as $b is a Ref of Array and @a is a Array

[22:32] <iblech> Both false then

[22:33] <autrijus> nod.

[22:33] <autrijus> I can argue the other way too

[22:33] <autrijus> but this way feels a bit cleaner.

[22:34] <autrijus> (I could argue that \@x always retain the Id).

[22:34] <autrijus> \@x =:= @x;

[22:34] <iblech> Hm.

[22:35] <autrijus> I don't think it's wise though :)

[22:36] <iblech> Consider: "How can things of different types (Ref of Array, Array) ever be identical" -- so, yes, \@x =:= @x should be false.

[22:36] <iblech> BTW, is there a negated =:= op (like ne or !~)?

[22:37] <autrijus> !:! ? I don't think so

[22:38] <iblech> You're right, according to S03. Probably because a. it wouldn't be needed that often anyway and b. !:! is *ugly*

[22:40] <Darren_Duncan> I was thinking about that the other day, because I want a negative =:=

[22:41] <Darren_Duncan> I thought perhaps calling it !=:= or !:=, to be parallel with != for ==

[22:42] <spinclad> =!= ?

[22:42] <svnbot6> r5923 | iblech++ | PIL2JS:

[22:42] <svnbot6> r5923 | iblech++ |   * PIL2JS.js -- Hack, all things which .isa("Array") are .isa("List") now, too.

[22:42] <svnbot6> r5923 | iblech++ |   * Prelude::JS::Keyed -- Fixed &pairs, &kv, and &values on one-elem

[22:42] <svnbot6> r5923 | iblech++ |     lists/arrays/hashes.

[22:44] <spinclad> like a symmetrized !=

[22:49] <spinclad> it doesn't keep the : (from :=), but preserves some of =:='s flavor.

[22:50] <autrijus> sure, but I highly doubt the practical need for this construct :)

[22:53] <spinclad> it forwards the crusade to program solely in punctuation!

[22:54] <autrijus> riight.

[22:55] <svnbot6> r5924 | autrijus++ | * nomenclature fixups; equivalence test.

[22:56] <iblech> Is stringification/numification/booleanification of real refs, i.e. refs which do not autoderef, specced somewhere?

[22:56] <autrijus> 3 + \$obj; ?

[22:57] <iblech> Right.

[22:57] <autrijus> my impression was that reference is always true, and does not have str/numify forms.

[22:57] <iblech> But err, \$obj will autoderef if $obj contains a "real object": http://www.nntp.perl.org/group/perl.perl6.language/22532

[22:58] <autrijus> right

[22:58] <autrijus> ...so?

[22:59] <iblech> so 3 + \$obj will evaluate to 3 + $obj, which in turn will eval to 3 + coerce:<as>($obj, Int) or somesuch

[22:59] <iblech> How about 3 + \3?

[22:59] <autrijus> 3+\3 is instant death, as no auto deref is done

[22:59] <autrijus> I was talking about that.

[23:00] <iblech> oh, ok.

[23:00] <autrijus> 3+$obj is also death if $obj has no coercion forms.

[23:00] <iblech> Right.

[23:00] <autrijus> good, we agree again

[23:00] <iblech> :)

[23:12] <svnbot6> r5925 | iblech++ | New test: t/var/autoderef.t -- Tests for autodereferencing/non-autodereferencing.

[23:13] <autrijus> I need to sleep. ciao! :)

[23:13] <iblech> Night :)

[23:13] <iblech> autrijus++ # "Definition of containers."

[23:16] <wolverian> hmm. debian is stopping mozilla support in stable, apparently.

[23:55] <iblech> Need to sleep, too. Night all! :)

