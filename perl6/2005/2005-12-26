[01:37] <sky> seen audreyt 

[01:55] <audreyt> sky: pong

[01:55] <audreyt> "comped"?

[01:56] <obra> "given a complimentary"

[01:57] <audreyt> oh. nope... I chose typepad mainly because sky and miyagawa are there :)

[02:00] <obra> nod :)

[02:02] <audreyt> and also because obra is not in the business of Blifty blog hosting :)

[02:03] <audreyt> mm, blifty.{net,org,com} is all open

[02:03] <obra> heh

[02:03] <obra> my demo blog app is still too trivial

[02:03] <obra> and will wait until i figure out how to abstract the authentication magic

[02:04] <obra> also, dispatcher

[02:05] <audreyt> nod

[02:05] <audreyt> need more tricks in Jesse's Insane Form Transforming Yoga

[02:07] <obra> hehh

[02:08] <audreyt> continuations and regions and selective form->action->model interactions does sound like yoga to me

[02:08] <audreyt> and the "insane" part is indisputable as well

[02:08] <obra> I'll give you that

[02:10] <stevan__> obra++ # Jifty looks very nice

[02:10] *** stevan__ is now known as stevan

[02:11] <obra> yay!

[02:11] <obra> it's still very beta

[02:11] <obra> and wants love

[02:11] <obra> but hopefully it will get your love

[02:12] <stevan> the "full stack" part was what convinced $coworker :)

[02:12] <stevan> he has been bugging the catalyst crew for that ever since he got the rails book

[02:13] <obra> heh

[02:13] <stevan> obra: I will surely get some lovin from us :)

[02:13] * obra is keeping track of which sorts of buzzwords attract which sets of people ;)

[02:13] <stevan> :D

[02:14] * stevan  "continutations" was what sold me

[02:14] <stevan> and the REST stuff too

[02:14] <stevan> I need to dig into the form handling more ,... it sounds really cool too

[02:15] <obra> that was my big original concept

[02:15] <obra> and it worked out really well

[02:15] <audreyt> I think demasonizing the dispatcher will attract another set of people

[02:15] <audreyt> rather large set too, considering TT2's audience

[02:16] <wolverian> yes, please :)

[02:17] <obra> so, I still want the dispatcher to end up falling through to serving a tree of templates, whatever the template engine

[02:17] <obra> And yes, I'd be thrilled to see good patches that let jifty use TT2 as an alternative

[02:18] * stevan likes TT, but has never used Mason so has no opinion yet

[02:19] <stevan> actually I care very little about my template engine, as long as it can do all the things I need (which I am sure Mason can)

[02:20] <obra> nod.

[02:20] <obra> the common complaint about mason is that perl is its domain language

[02:21] <stevan> well I know in Rails, eruby is the same way ,.. and people seem to have taken to it

[02:22] <stevan> I think it brings up thoughts of ASP and PHP development for some,... which is understandably not a good thing

[02:22] <wolverian> I just don't like perl in templates. templates are messy enough without it.

[02:22] <wolverian> (domain specific languages)++

[02:23] <stevan> wolverian: but why is the TT language really that much different?

[02:23] <wolverian> it looks like ruby :)

[02:23] <stevan> :D

[02:23] <audreyt> and also it's minimal like your favourite minilang :)

[02:25] * stevan ponders a Jifty::Template::MiniLang module

[02:25] * audreyt thinks stevan is insane

[02:25] <stevan> thinks?

[02:25] <audreyt> otoh, compiling minilang to perl5 takes very few lines

[02:25] <stevan> I would think you would know that by now

[02:26] <audreyt> given your previous Perl6-ObjectSpace

[02:26] <stevan> :)

[02:26] <audreyt> I dreamed (literally) of compiling minilang to native haskell code using GADT to precompute method bindings

[02:26] <audreyt> I've been dreaming strange things lately ;)

[02:26] <stevan> I was dreaming about vObj the other night 

[02:27] <audreyt> very nice

[02:28] <audreyt> I think I'd like to finish up YAML::Syck and PGE::OPTable port today

[02:28] <wolverian> I dreamt I was a elephant. that was very, very strange.

[02:29] <audreyt> and then turn to minilang dispatcher

[02:29] <audreyt> stevan: so still in $thinking phase about roles?

[02:30] <obra> audreyt: I'd like a perl one first ;)

[02:30] <obra> or minilang ala jifty::dbi::schema

[02:30] <stevan> audreyt: nope, in implementation mode now

[02:30] <audreyt> stevan: ooh cool

[02:30] <stevan> I am just going to add a way to handle "requirements"

[02:30] <stevan> for things like role Foo { method bar { ... }}

[02:30] <audreyt> wolverian: it could've been stranger... such as dreaming that you were 2+ elephants at once

[02:30] <stevan> and for method conflicts

[02:31] <wolverian> audreyt, hmm, yes. have you dreamed that? :)

[02:32] <audreyt> stevan: 'k. let me know if you need support from underlying level

[02:33] <stevan> audreyt: will do,.. I think I should be good though

[02:33] <stevan> I am commiting private method functionality right now

[02:33] <audreyt> wolverian: at one time when I had fever, I dreamed I was a dreamer and the dream itself at once in parallel

[02:33] <audreyt> that was quite strange 

[02:34] <audreyt> s/and/and also/

[02:34] <stevan> currently it just adds to %!methods until you get the dispatcher part working, then you can change them to add to %!private_methods

[02:34] <wolverian> audreyt, wow. I just dream about crabs attacking me when I have a fever.

[02:36] <stevan> audreyt: do you have any thoughts on adding types to the mini-language?

[02:36] <avar> You have the most funky dreams when you have a high fever

[02:37] <avar> i.e. fever to the point of you being in delirium

[02:38] <svnbot6> r8438 | stevan++ | PIL/Native/Bootstrap.pil

[02:38] <svnbot6> r8438 | stevan++ | - added support for private methods, still needs work on the

[02:38] <svnbot6> r8438 | stevan++ |   dispatcher end (in Haskell) for full proper support

[02:38] <svnbot6> r8438 | stevan++ | t/pil/metamodel/*

[02:38] <svnbot6> r8438 | stevan++ | - fixed all instances of . which should actually be `

[02:42] <avar> Is there a particular reason why perl makefiles have a PL extension instead of pl ?

[02:46] <audreyt> stevan: you can use private methods now

[02:46] <audreyt> stevan: first-class types-as-value would work

[02:47] <audreyt> stevan: why do you plan to use it?

[02:49] <stevan> audreyt: re: private methods ... really?

[02:49] <svnbot6> r8439 | audreyt++ | * PIL.Native.Eval - recognize %!private_method in dispatcher

[02:49] <svnbot6> r8439 | audreyt++ |   as well. not yet distinguished between $obj!meth and $obj.meth though.

[02:49] <stevan> :P

[02:49] <stevan> audreyt: so how does it work? does it use the MRO?

[02:50] * stevan reads the haskell source

[02:51] <audreyt> stevan: r8440

[02:52] <audreyt> I gotta run... bbl

[02:52] <stevan> ok

[02:55] <svnbot6> r8440 | audreyt++ | * private method calls should not consider MRO nor install &?NEXT.

[03:32] <avar> the only application that loads my computer more than ghc is phpdoc

[03:37] <svnbot6> r8441 | avar++ | * Does a character codepoint (\x..) evaluate to the same thing as its literal?, nah-ah in pugs 6.2.10

[03:37] <dduncan> I don't recognize %!private_method , unless that's just because all attrs implicitly have methods

[03:39] <stevan> dduncan: %!private_methods is a mini-language thing

[03:39] <stevan> it is part of the metamodel

[03:39] <dduncan> okay

[03:40] <stevan> it is an attribute of the ::Class object

[03:41] <stevan> dduncan: unless you want to hack the metamodel,.. you will never encounter it

[03:41] <dduncan> I hear that!

[03:46] <dduncan> ?eval ::Foo;

[03:46] *** evalbot_8436 is now known as evalbot_8441

[03:46] <evalbot_8441> ::Foo 

[03:47] <dduncan> ?eval class Bar {} ::Bar;

[03:47] <evalbot_8441> \Class.new(("name" => "Bar"), ("traits" => ("Object",))) 

[03:47] <dduncan> ::Foo;

[03:47] <dduncan> ?eval ::Foo;

[03:47] <evalbot_8441> ::Foo 

[03:48] <dduncan> this appears to be wrong

[03:48] <dduncan> class Foo was never declared

[03:48] <dduncan> oh wait

[03:49] <dduncan> I am seeing some differences in my pugs ... could have to do with state maintenance between requests

[03:49] <dduncan> superficially, it appears that after declaring any class, referencing the name of any other class, those not declared, returns true, or "{obj:Class}" to be specific

[03:50] <dduncan> those same undeclared class refs returned undef before the unrelated class declaration

[03:50] <dduncan> this is seen when running ./pugs on the command line

[03:51] <dduncan> a related question of mine ...

[03:51] <luqui> dduncan, I'm trying to reproduce this

[03:51] <luqui> can you give me a sequence of commands to execute?

[03:51] <dduncan> yes, just a minute

[03:52] <wolverian> isn't :: still the 'class that isn't yet declared' sigil?

[03:52] <luqui> uh... kinda

[03:53] <luqui> Larry recently killed the ^ type sigil, reviving ::

[03:53] <luqui> so maybe that's not what :: means anymore

[03:53] * luqui doesn't remember, but thinks that Larry addressed the issue

[03:53] <dduncan> here's a simpler case

[03:53] <dduncan> 1. ::Foo;

[03:53] <dduncan> 2. class Bar {}; ::Bar;

[03:53] <dduncan> 3. ::Foo;

[03:53] <dduncan> do that on a freshly opened Pugs

[03:53] <dduncan> if pugs is open, quit and reopen first

[03:54] <dduncan> line 1 returns undef

[03:54] <dduncan> line 3 returns {obj:Class}

[03:54] <dduncan> note that the ::Bar; on line 2 is important for line 3 to return somthing different than line 1

[03:55] <luqui> <lwall> The problem that worried me (about wanting to refer to a type that

[03:55] <luqui> will exist but hasn't been declared yet) does not arise often in

[03:55] <luqui> practice, and can be solved with a symbolic ref in any event, or

[03:55] <luqui> by predeclaring a stub type. 

[03:55] <wolverian> oh. so what's :: now?

[03:55] <luqui> type sigil

[03:55] <wolverian> ah. thanks

[03:55] <luqui> dduncan, try omitting those semicolons

[03:55] <wolverian> ::$(Foo) is the symref?

[03:55] <wolverian> er, s/$//, I think..

[03:56] <luqui> ::('Foo') maybe...

[03:56] <wolverian> right. thanks again :)

[03:56] <luqui> I'd prefer  class Foo {...}  Foo

[03:56] <luqui> man, that {...} thing is really starting to bug me

[03:56] <wolverian> heh.

[03:56] <dduncan> okay, that version treats Foo as a sub and fails

[03:56] <wolverian> in this case it is a bit bugging

[03:57] <wolverian> but usually you don't need to write stubs except when you want the ... to be visible

[03:57] <dduncan> in any event, the actual problem I want to solve is, how do I test whether a package (not a file) has been loaded or not, so I can just conditionally 'require' it

[03:57] <luqui> dduncan, omitting the *semi*colons, not the colons

[03:57] <dduncan> oop, 

[03:58] <luqui> pugs interactive is flaky with regard to semicolons.  It ends up ignoring various things

[03:58] <luqui> when in doubt in pugs interactive, never put a semicolon at the end of a line

[03:58] <dduncan> will try to remember that

[03:58] * luqui thinks he should get that fixed

[03:59] <dduncan> okay, leaving out the semis showed some useful info

[03:59] <dduncan> will try to make use of it in code ...

[04:00] <luqui> in response to your "actual problem"... I have no idea

[04:00] <dduncan> I noticed in pugs interactive mode

[04:01] <dduncan> that the result of the non-declared ::Foo had a ref of ::Type

[04:01] <dduncan> whereas, the result of declared ::Bar had a ref of ::Class

[04:01] <dduncan> this might do what I need

[04:01] <dduncan> need to test more though

[04:02] <luqui> that may just be a bug

[04:02] <dduncan> may be

[04:02] <diotalevi> Does pugs do threading?

[04:02] <luqui> diotalevi, uh huh

[04:02] <diotalevi> This is the "#pugs" place, and not actually perl6, right?

[04:02] <luqui> yes

[04:02] <luqui> well, perl6 too

[04:03] <diotalevi> Why is it called #perl6 then?

[04:03] <luqui> because perl6 spec and pugs implementation are tightly interrelated

[04:03] <luqui> it would be a pain to have to think about where each question belongs

[04:03] <diotalevi> Cuz people have told me that this is where to go to talk about pugs but that it isn't the place if I have other non-pugs perl6 stuff.

[04:03] <luqui> and the same people would be in both channels anyway

[04:04] <luqui> diotalevi, no, it's fine in both cases

[04:04] <diotalevi> oh ok.

[04:04] <luqui> (though writing to perl6-language is generally more appropriate with perl 6 language stuff, because that's where the design team is listening)

[04:05] <diotalevi> so was that "uh huh" to threading sarcastic or does it actually have threading support?

[04:05] <diotalevi> Can I run anything interesting on this thing yet?

[04:06] <stevan> diotalevi: see examples/ 

[04:06] <stevan> all are runnable 

[04:06] <stevan> t/* has about 10,000 tests (most of which run too)

[04:06] <stevan> ext/* has many ported modules, almost all of which has their own test suites too 

[04:06] <luqui> diotalevi, pugs really does do thread

[04:06] <luqui> s

[04:07] <stevan> diotalevi: to quote luqui,.. "uh huh" ;)

[04:07] <diotalevi> Sweet.

[04:08] <diotalevi> Can I run perl5 stuff on pugs?

[04:08] <luqui> diotalevi, you can use perl 5 modules

[04:08] <wolverian> you'll still need perl on your system.

[04:08] <luqui> use perl5:DBI;  # etc

[04:08] <stevan> diotalevi: there is a perl 5 bridge between the two, although it has some quirks IIRC

[04:08] <diotalevi> zowie.

[04:09] <diotalevi> How about stuff that cares about perl5 optrees? Does that stuff still work?

[04:09] <luqui> uh no

[04:09] <luqui> I mean, I'm not sure what you're talking about without an example

[04:09] <luqui> but any tricky stuff will probably not work

[04:10] <diotalevi> I'm the maintainer of a few B:: modules and author of several more. Nothing "tricky," that doesn't use documented interfaces.

[04:10] * luqui ponders use perl5:Perl6::Attributes

[04:10] <luqui> ;-)

[04:10] <luqui> well, pugs interprets itself, it does not convert itself to a perl5 optree

[04:10] <luqui> (well, I guess the perl5 backend does ;-)

[04:11] <diotalevi> so when pugs runs perl5 code, does it launch a real perl5 interpreter or emulate one?

[04:11] <luqui> launch

[04:11] <diotalevi> sweet. Then it should DRT.

[04:11] <luqui> see, I wasn't sure what you meant by "cares about optrees"

[04:11] <dduncan> luqui, thanks for your help

[04:12] <dduncan> whether based on a bug or not, I found a solution

[04:12] <diotalevi> oh. do you know what optrees are?

[04:12] <luqui> yes

[04:12] <dduncan> the expression ::($module_name).does(Module)

[04:12] <luqui> but the definition of "cares about" was a little vague

[04:12] <luqui> dduncan, interesting

[04:12] <dduncan> returns true if the module is loaded, and false if not

[04:12] <diotalevi> yeah, cares about is vague.

[04:12] <luqui> I was thinking like optimize.pm

[04:13] <dduncan> so I'll checkin a Locale::KeyedText with the relevant bug fixed in a moment ...

[04:13] <diotalevi> actually... anything that cares about those is already in bed with the interpreter.

[04:14] <sky> hmm

[04:15] <clkao> sky

[04:16] <stevan> audreyt: ping

[04:17] <stevan> luqui: wanna hack some haskell for me :) 

[04:17] <luqui> stevan, just a moment, then yes

[04:17] <stevan> its simple stuff,.. I just can't get the damn type sigs to match up

[04:17] <stevan> cool

[04:19] <luqui> stevan, mmkay

[04:19] <luqui> ready'

[04:20] <stevan> luqui: so I am looking to add delete to the mini-lang's hash type

[04:20] <stevan> it should work fine with Data.Map.delete

[04:20] <stevan> but I can't get the types to match up in PIL/Native/Coerce.hs

[04:21] <stevan> class IsPlural needs a proper signature

[04:21] <stevan> and I am not sure what that should be

[04:21] <stevan> then it needs to be added to the instance on line 106

[04:22] <stevan> but that part is easy ( I think)

[04:22] <luqui> should be

[04:22] <stevan> and it doesn't need to do in place delete,.. it can just return a new map

[04:22] <stevan> which I what Data.Map does anyway (i think)

[04:22] <luqui> haskell has no idea what "in place delete" is anyway ;-)

[04:23] <stevan> yeah I figured :)

[04:23] <luqui> (well, you could do it within STM monad)

[04:23] <luqui> (but naah)

[04:23] <stevan> I dont need ti anyway

[04:23] <stevan> it can just return the copy

[04:23] <luqui> in "IsPlural", the variables are:

[04:24] <luqui>  "a" - the type of the thing that's being declared plural (map in this case)

[04:24] <svnbot6> r8442 | Darren_Duncan++ |  r1604@Darren-Duncans-Computer:  darrenduncan | 2005-12-25 20:22:01 -0800

[04:24] <svnbot6> r8442 | Darren_Duncan++ |  /ext/Rosetta-Incubator : in KeyedText.pm, updated template_module_is_loaded() so it works correctly under current Pugs, though whether it is due to a specced or unspecced or bug is unknown

[04:24] <luqui>  "key" - keys; "val" - values

[04:24] <luqui> so the delete function should take a map and a key and return a new map with that value deleted, no?

[04:24] <stevan> yes

[04:24] <stevan> a -> key -> a?

[04:25] <luqui> yeah... well key -> a -> a probably

[04:25] <luqui> (it's convention in haskell to end signatures with a -> a)

[04:25] <luqui> (so that you can curry them to a mutator)

[04:25] <stevan> ok

[04:26] <luqui> but audreyt doesn't seem to be following that convention here

[04:26] <luqui> so you should probably do a -> key -> a

[04:26] <stevan> it compiled!!!!

[04:27] <luqui> coolness

[04:27] <luqui> you realize that you have to implement delete for all the other Plurals, right?

[04:27] <stevan> yup

[04:27] <luqui> (which could be an error message)

[04:27] <stevan> it warned only

[04:28] <stevan> but I am putting in stubs to throw errors

[04:28] <luqui> wait -- what does splice do?

[04:28] <stevan> :)

[04:29] <stevan> probably exactly what I want delete to do  :P

[04:29] <luqui> except it takes an Int

[04:29] <stevan> yup, and it is not assigned as in Prims.hs

[04:30] <luqui> it looks like it drops the first n elements of the container

[04:30] <luqui> splice is a pretty bad name for that...

[04:31] <stevan> yeah tail would  be more approriate I think

[04:31] <stevan> or rather,.. my usage of it... would be better expressed as &tail

[04:31] <luqui> well, "tail" and "drop" are taken by the prelude

[04:31] <stevan> cause all I ever do is splice(1)

[04:32] <luqui> (not that you can't hide those.. but they're useful, and it's a pain to hide them)

[04:33] * luqui wonders what Data.Seq is

[04:38] <stevan> eak! Data.Map.delete takes a Map as it's arg

[04:38] <luqui> uh huh? and?

[04:39] <luqui> oh

[04:39] <luqui> no, that looks fine

[04:39] <stevan> it barfs all sorts of errors now though

[04:40] <luqui> did you change the sig to a -> key -> a ?

[04:40] <stevan> deleteAt looks promising maybe

[04:40] <stevan> yes I did

[04:40] <luqui> that's the problem

[04:40] * stevan knows that

[04:40] <luqui> Map.delete :: key -> Map -> Map

[04:40] <luqui> so you need to flip Map.delete's argument order to make it match

[04:40] <luqui> using none other than the "flip" builtin, which does precisely that!

[04:40] <luqui> :-)

[04:40] <stevan> ok

[04:41] <stevan> where do I put that?

[04:41] <luqui> delete = flip Map.delete

[04:41] <stevan> nevermind I see

[04:41] <stevan> horray,.. we have compilation

[04:42] <stevan> and it works too :)

[04:42] <stevan> muchas gracias luqui 

[04:42] <luqui> de nada

[04:45] <luqui> ugh... learning a new instrument is so hard!

[04:45] * luqui cringes at his own violin playing

[04:46] * stevan can only play "Smoke on the Water" on violin

[04:46] <luqui> better than me

[04:46] * luqui tries

[04:46] <stevan> you just reverse the way your hands would go on a guitar since its tuned by 4ths instead of 5ths

[04:47] <luqui> and you do it with a bow...

[04:47] <stevan> ah

[04:47] <stevan> nah

[04:47] <stevan> strumming

[04:47] <luqui> oh, I sound a lot better strumming than bowing

[04:47] <stevan> its a power chord,.. you can't bow a power chord :P

[04:47] <luqui> you can bow a double stop

[04:47] <luqui> and a power chord only has two notes anyway

[04:48] <luqui> the biggest hardness about the violin is that it has no frets

[04:48] <luqui> so everything sounds off key

[04:48] <stevan> that takes time

[04:48] <luqui> yeah.  and I want to be a virtuoso NOW, damnit!

[04:49] <stevan> I used to play a lot of fretless bass (electric, not standup) and it just took some time to get your hands trained

[04:49] * luqui bows smoke on the water

[04:49] <luqui> using double stops.   Gee, that was fun.

[04:49] <stevan> most good players can hear if they are off,.. so they quickly slide up/down to compensate

[04:49] * stevan got extra credit in figure drawing class for being able to do that once :)

[04:49] <luqui> I can hear it too... and I slide up/down to compensate

[04:49] <luqui> "quickly".. not so much

[04:50] <luqui> by the time I compensate, I'm out of bow

[04:50] <luqui> :-)

[04:51] <stevan> :D

[04:52] * stevan gives himself "roles with proper conflict handling" for a chirstmas present 

[04:52] <luqui> Coolness!  (stevan xx 100)>>++

[04:52] <stevan> and if all the other tests pass I will share it with everyone else too

[04:52] <stevan> of course I can't die in the mini-lang...

[04:53] <stevan> so I just don't include it

[04:53] * luqui actually thinks that's almost the right way to go

[04:53] <stevan> I am considering returning a list of conflicts 

[04:53] <stevan> you need to call &resolve on the class to get all the roles to flatten into it

[04:53] * luqui thinks, at first glance, that the best way to do it is to replace the method with a die "conflict in these roles" message

[04:54] <stevan> well,.. yes and now

[04:54] <stevan> no

[04:54] <luqui> it would be nice to catch it at compile time

[04:54] <stevan> that would work, but it differs the error until runtime,.. this should be detectable at compile time

[04:54] <stevan> or at the very least class composition time 

[04:55] * luqui has to think about this

[04:55] <stevan> if &resolve returns a conflict object, that should give the next layer up enough infomation to decide what is best 

[04:55] <stevan> in other words,.. just punt to the next layer :)

[04:55] <luqui> we have to think in terms of interfaces

[04:55] <stevan> aka - make audreyt handle it 

[04:56] <luqui> when role A does role B, that means that if you conform to A, then you automatically conform to B

[04:56] <luqui> I think that's the metric that needs to guide our conflict handling

[04:56] <stevan> no, you are thinking something else

[04:56] <luqui> ?

[04:56] <stevan> if A has method &foo and B has method &foo,.. they are in conflict

[04:57] <luqui> I know

[04:57] <stevan> however, that is irrelevant until class C does them

[04:57] <luqui> if A does B and A does C, then implementing A must implement both B and C

[04:57] <stevan> yes

[04:57] <luqui> if B and C have a conflict, then that must be resolved by whatever implements A, or by A itself

[04:57] <stevan> yup

[04:58] <luqui> say that A doesn't resolve it...

[04:58] <luqui> that method gets added to the interface of A

[04:58] <luqui> (the necessary interface, that is)

[04:58] <luqui> and if the class doesn't implement that method, then it doesn't conform to A

[04:58] <luqui> that makes the most sense to me

[04:59] <luqui> of course, we should fudge the error messages

[04:59] <luqui> to point to the conflict in B and C, not the fact that the class doesn't do A

[04:59] <stevan> yes, correct on all accounts

[04:59] <luqui> okay good

[05:00] <stevan> the conflict between B and C is undiscovered until the class tries to consume A

[05:00] <luqui> well... not "undiscovered", but "unreported"

[05:00] <stevan> yes

[05:05] <luqui> I've been thinking about scoping and roles a bit

[05:05] <luqui> but it's very fuzzy, so bear with me

[05:06] <luqui> an object would have a "view role"

[05:06] * stevan is very "fuzzy" at the moment anyway (long day)

[05:06] <luqui> only methods in that role could be called on the object

[05:06] <luqui> other methods would pretend not to exist

[05:06] <stevan> downcasting

[05:07] <luqui> yeah... something like that

[05:07] <stevan> this is fairly common Java thing

[05:07] <luqui> but in Java "pretend not to exist" means "refuse to compile"

[05:07] <luqui> maybe that's what it means in static perl too

[05:07] <luqui> anyway, that's precisely how to handle private members

[05:08] <luqui> and the readonly-ness of attributes

[05:08] <stevan> MyInterface a = (MyInterface) collection_iterator.getNext(); 

[05:08] <luqui> that's an upcast, isn't it?

[05:08] <luqui> casting from Object into something more specific?

[05:08] <stevan> oh,.. well yes, in this case your right

[05:09] <luqui> but I think we're on the same page

[05:09] <stevan> but since it was probably some object which implements MyInterface, then ... well you get what I mean

[05:09] <stevan> I was actually thinking about this too

[05:09] <stevan> that really the user should only ever interact with Roles

[05:09] <luqui> anyway, to handle these things, you'd have:

[05:09] <svnbot6> r8443 | stevan++ | PIL/Native/Coerce.hs

[05:09] <svnbot6> r8443 | stevan++ | - added delete to IsPlural class, and appropriate instances

[05:09] <svnbot6> r8443 | stevan++ | PIL/Native/Prims.hs

[05:09] <svnbot6> r8443 | stevan++ | - added delete to the mini-lang's {} primative

[05:09] <svnbot6> r8443 | stevan++ | PIL/Native/Bootstrap.pil

[05:09] <svnbot6> r8443 | stevan++ | - added remove_method, remove_private_method and 

[05:09] <svnbot6> r8443 | stevan++ |   remove_attribute to ::Class

[05:09] <svnbot6> r8443 | stevan++ | - fixed ::Role.resolve so that it properly detects and removes

[05:09] <svnbot6> r8443 | stevan++ |   method and attribute conflicts. Need to talk to audreyt++

[05:09] <luqui> class Foo { has $.foo;  has $!bar }

[05:09] <luqui> becomes

[05:09] <svnbot6> r8443 | stevan++ |   about how I should return the conflicts so that errors can

[05:09] <svnbot6> r8443 | stevan++ |   be thrown appropriately 

[05:09] <svnbot6> r8443 | stevan++ | t/pil/metamodel/*

[05:09] <svnbot6> r8443 | stevan++ | - added role_conflicts.t to test basic role conflicts

[05:09] <svnbot6> r8443 | stevan++ | - added some more tests to roles.t

[05:10] <luqui> role Foo { method foo() {...} }   role FooImpl { does Foo;  method foo() is rw {...}  method bar() is rw {...} }

[05:11] <luqui> and the class would be created from FooImpl.  Inside the class, it would see itself as FooImpl, but outside, everything would see it as Foo

[05:11] <luqui> which doesn't have the "rw" accessor for the foo attribute

[05:12] <stevan> yup

[05:12] <stevan> I was thinking something very similar

[05:12] <luqui> the private member might be something different though; it should have a different scope than the public methods

[05:12] <stevan> and we get autogeneted accessor conflict resolution for free

[05:12] <luqui> but there's something a little tricky

[05:12] <stevan> I discussed this on p6l a while back

[05:13] <luqui> the reason I wanted $.foo to mean method call is so that you could override attributes on behalf of your ancestors

[05:13] <luqui> because you know better than they do

[05:13] <luqui> and that's all dandy... except what happens when your ancestor *writes* to such an attribute?

[05:14] <luqui> that hardly makes sense in the above model

[05:14] <stevan> do you have a use case for that?

[05:14] <stevan> a real world one

[05:14] <stevan> I would think that if you wanted to override attribute

[05:14] <luqui> for which?

[05:14] <stevan> you would have to seek out all the places it is used,.. and override those methods

[05:14] <luqui> which isn't cool...

[05:15] <stevan> but that really breaks stuff 

[05:15] <stevan> cause your sub class now behaves differently

[05:15] <stevan> very diff

[05:15] <luqui> well, my use case is that I create accessors for all my attributes when I create classes

[05:15] <luqui> so that my subclasses can do that

[05:16] <stevan> yes

[05:16] <luqui> and we already know that attributes autogenerate accessor methods

[05:16] <luqui> and everything is virtual, so those accessor methods can be overridden

[05:16] <luqui> but then when the ancestor writes to his attribute, it is simply ignored

[05:16] <luqui> which kinda seems like the wrong thing to m

[05:16] <luqui> me

[05:17] <stevan> ignored?

[05:17] <luqui> yeah; the outside world doesn't see his change

[05:17] <luqui> if he uses his own accessor method to get it back, his change hasn't happened

[05:17] <luqui> it hasn't even been considered by the subclass

[05:17] <stevan> accessor methods are virtual too

[05:18] <luqui> I know.  but the rw part of them is not

[05:18] <stevan> ah

[05:18] <stevan> interesting

[05:18] <stevan> ok

[05:18] <stevan> so if I override it with just r, then there is an issue

[05:18] <luqui> yeah.  especially since $.foo is the self-call syntax.

[05:19] <luqui> you can't tell the difference between writing to the underlying attribute and to its accessor (which I think is a step in the right direction, actually)

[05:19] <stevan> well that has to desugar into something,.. 

[05:19] <luqui> so it would seem that subclasses don't derive from the public role, but from the private impl class

[05:19] <luqui> which seems wrong...

[05:19] <stevan> no

[05:20] <luqui> no what?

[05:20] <stevan> because the subclass has a different relationship than the user of the class

[05:20] * stevan is reminded of a cool paper on composable encapsulation policies for Smalltalk

[05:20] <luqui> oh, and I don't have a use case for this weird rw stuff, because I have a tendency to write value types

[05:20] <luqui> i.e. constant classes

[05:21] <luqui> is it called "composable encapsulation policies"?

[05:21] <luqui> :-)

[05:21] <luqui> because I found that paper

[05:21] <stevan> something like that yeah :)

[05:22] * luqui reads

[05:22] <luqui> I'm glad that I'm finally thinking aloud about this

[05:22] <stevan> yeah thats it

[05:22] * stevan googled composable encapsulation policies and found it

[05:22] <stevan> its by the same people who did the original Traits paper

[05:23] <stevan> well, while I like the $.foo desugaring into a method call,.. I think it may be problematic 

[05:23] <luqui> neato

[05:23] <stevan> now that I think about it at least

[05:23] <stevan> because of exactly the example you made

[05:23] <luqui> right.  but before we abandon it, I'd like to work through it

[05:23] <stevan> the body of a method needs to have access to the innards of self 

[05:24] <luqui> because every other OO language uses the "autogenerated accessor" technique (most of the time without the "auto" part)

[05:24] <stevan> in a way which is more permissive than the code *outside* a methods body does

[05:24] <luqui> sure, thus Foo & FooImpl roles

[05:24] <luqui> you can still call $.foo an accessor, as long as the innards see the rw version and the "outards" don't

[05:25] <luqui> "information hiding is not necessarily an essential component of encapsulation."   I like this paper already.

[05:26] <stevan> yeah its a good one

[05:26] <stevan> ok,.. I have to sleep,.. 

[05:26] <stevan> read the paper,.. and we can continue this later

[05:27] <luqui> excellent

[05:27] <luqui> nite

[05:28] <stevan> actually the way to do this would be to make Foo the role,.. and FooImpl be a class

[05:28] <stevan> classes would have no notion of rw, or auto-generated accessors, etc

[05:28] <stevan> the Foo role would do all that

[05:28] <stevan> then your subclasses just deal with the class version

[05:29] <stevan> but the users always deal with the role version

[05:31] <luqui> basically what I was saying above, that subclasses do FooImpl

[05:31] <luqui> oh wait

[05:32] <luqui> "then your subclasses just deal with the class version"

[05:32] <luqui> how?  can you still override attributes?

[05:33] <stevan> yes

[05:33] <luqui> but classes have no notion of rw...

[05:33] <stevan> yes

[05:33] <stevan> it is always rw

[05:33] <stevan> for classes

[05:34] <luqui> oh.  yeah, so basically what I was saying above.

[05:34] <stevan> but $.foo does not desugar into self.foo

[05:34] <luqui> aa soo, that's the one

[05:34] <stevan> it desugars to self`get_attr('$foo')

[05:34] <luqui> hmm, that's an interesting idea

[05:34] <luqui> you can still override attributes, but it's not the same as overriding a method

[05:34] <stevan> yes

[05:35] <luqui> I think I like it.  Let me toy with it.  Go to bed! :-)

[05:35] <stevan> exactly :)

[05:35] <stevan> nite &

[06:56] <luqui> Perl 6 has no reason to have inheritance

[06:57] <luqui> role composition is monotonic, and we reject local precedence ordering (the idea that class Foo { is Bar; is Baz }  should look in Bar first)

[06:58] <luqui> s/is/does/g  :-)

[07:23] <gaal> luqui: what does monotonic mean? is that "and" up there used in the sense of "that is"?

[07:30] <luqui> monotonic means that you never get a base class's method having precedence over a derived class's version

[07:30] <luqui> basically, "stuff isn't totally insane"

[07:30] <luqui> by that definition, Perl 5 was totally insane

[07:30] <luqui> er, I guess that's not what it means (I tried to simplify)

[07:31] <gaal> when does that happen in p5?

[07:31] <luqui> It means that "if A precedes B in the linearization of a class C, then A will precede B in the linearization of any subclass of C"

[07:31] <luqui> it doesn't happen in p5; I oversimplified

[07:32] <gaal> ah, ack.

[07:32] <luqui> do you grok that?

[07:32] <gaal> i grok the correction :) I don't know what linearization means, though I have a guess.

[07:32] <luqui> the order in which you look for methods

[07:33] <gaal> no mixins (compiletime composition) involved? well my guess was wrong :)

[07:34] <luqui> hmm... actually, perl5 is insane

[07:35] <luqui> let me contrive an example

[07:35] <luqui> and I actually think that the oversimplification is correct

[07:36] <gaal> A pattern I've used in the past in P5 was inheritable singletons -- there was one instance of type B *or* C, both of which were derived from A. The actaul reference was stored in A. But this is a little weird, and doesn't have much to do with invocation anyway.

[07:37] <luqui> Okay, insane p5:  the standard diamond problem:  B isa A, C isa A, D isa B, D isa C

[07:37] <gaal> okay...

[07:37] <luqui> If C overrides one of A's methods, say "foo", but B doesn't, then D.foo will resolve to A

[07:37] <luqui> not to C where it "should"

[07:38] <gaal> C3 fixes that, no?

[07:38] <luqui> indeed

[07:38] <luqui> and so does role composition

[07:38] <luqui> role composition does it all by constructing vtables; it does no linearization

[07:39] <gaal> i'm not sure that's insane though :)

[07:39] <gaal> I mean it is consistent.

[07:39] <luqui> how is it consistent?

[07:39] <gaal> suppose B had overridden foo to do SUPER::foo()

[07:39] <gaal> you'd get B.foo

[07:39] <luqui> (also:   {"you are stupid", "stupid are you"} is consistent, but that doesn't mean it's good)

[07:40] <gaal> "stupid are you" is a question with a little help from intonation and punctuation :)

[07:40] <luqui> you'd need a comma, I think

[07:40] <gaal> I said punctuation :)

[07:40] <luqui> yeah, just realized that

[07:41] <luqui> wait, you said that B.SUPER::foo() would give you B.foo?

[07:41] <luqui> do you mean A.foo?

[07:41] <gaal> both :)

[07:41] <luqui> okay, I think I see what you're saying

[07:41] <gaal> in invocation, it'd give you B.foo

[07:41] <luqui> but we know that SUPER is broken, too

[07:41] <gaal> in behavior, A.foo, but that'd be *reasonable*.

[07:42] <luqui> so the fact that C overrided foo gets completely ignored when it is inherited multiply?

[07:42] <luqui> doesn't seem like inheriting from C did much good at all

[07:42] <gaal> what would you do if both had overridden foo?

[07:43] <luqui> that's what "local precedence ordering" is

[07:43] <gaal> hmm?

[07:43] <luqui> in python, it would have picked B, since it came first in the list of derivations

[07:43] <gaal> p5 also

[07:43] <luqui> but perl doesn't like ordering dependencies like that; i.e. we're rejecting the necessity of local precedence ordering

[07:44] <luqui> instead, we pitch a fit

[07:44] <gaal> that's the only alternative

[07:44] <luqui> was that a question?

[07:44] <gaal> an observation.

[07:44] <luqui> true

[07:45] <gaal> errr, I mean: "sure, if you don't want to do that, raising an early error is the only alternative"

[07:45] <luqui> and what you're left with is *precisely* the semantics of role composition

[07:45] * luqui understood

[07:45] <gaal> except that last time I read S12, there was mention of runtime role composition

[07:45] <gaal> which silently discarded conflicts

[07:45] <luqui> except it doesn't really

[07:46] <luqui> it just isn't "flat" like regular role composition

[07:46] <luqui> it introduces an ordering

[07:46] <luqui> the order in which they were composed at runtime

[07:46] <gaal> can you still call the other method?

[07:46] <nothingmuch> hola

[07:46] <gaal> hey nm

[07:46] <luqui> and I've thought about it; you can't get around that ordering

[07:46] <luqui> you can't make role composition commutative

[07:46] <luqui> gaal, the method that was overridden?

[07:47] <gaal> the one that I said was discarded

[07:47] <luqui> dubious, at least not without explicit qualification

[07:47] <gaal> I said, ha. S12 did.

[07:47] <luqui> :-)

[07:48] <gaal> luqui: qualification is fine here. alternatives are to demand an alias at composition time

[07:48] <nothingmuch> christmas sucks

[07:48] <nothingmuch> no email

[07:48] <nothingmuch> means i actually have to work

[07:48] <luqui> works for me...

[07:48] <gaal> stevan mentioned something about accessing the vtable programmatically, but most programmers wouldn't want to have to do that.

[07:49] <gaal> nothingmuch: that's why you're on the channel is it? :)

[07:49] <luqui> yeah, you might say <overridden_role>.meta.methods<method_name>($obj)

[07:49] * luqui thought nothingmuch was saying that email didn't work

[07:49] <luqui> rather than the phenomenon of nobody sending you email

[07:50] <luqui> after checking my mail, I understood ;-)

[07:50] <gaal> if there were something like a cast, you could do (<overriden_role>)$obj.<method_name>

[07:50] <nothingmuch> =)

[07:50] <nothingmuch> this CD is interesting

[07:50] <nothingmuch> i have no clue what to make of it

[07:51] <gaal> I don't know, I'm getting so much spam these days I always know if my mail stops working

[07:51] <luqui> gaal, that wouldn't respect the "virtualness" of methods

[07:51] <nothingmuch> The Big Gundown: John Zorn Plays the Music of Ennio Morricone

[07:51] <luqui> nothingmuch, which CD?

[07:51] <luqui> I don't know what to make of the title

[07:51] <gaal> nothingmuch: did you get a chance to hear the other lisa germano?

[07:51] <nothingmuch> ~http://en.wikipedia.org/wiki/John_Zorn

[07:52] <nothingmuch> gaal: i got some more off emusic

[07:52] <nothingmuch> but only heard it, didn't listen yet

[07:52] <gaal> yeah takes me a while too

[07:52] <nothingmuch> Hapiness, Excerts From a Love Circus, and I already had Geek the Girl

[07:52] <gaal> luqui: can you explain that virtualness comment?

[07:53] <gaal> nothingmuch: Lullaby for Liquid Pig is really, really beautiful

[07:53] <nothingmuch> got mp3/ogg/something?

[07:53] <luqui> well, if Bar does Foo:  my Foo $x = Bar.new;  $x.method_overridden_by_bar  # calls Bar's version

[07:53] <luqui> that's pretty much the definition of virtual dispatch

[07:53] <gaal> sure

[07:53] <nothingmuch> it's not on emusic, and it'll be a while till i get stuff from amazon

[07:53] <gaal> it's out of print :(

[07:54] <luqui> so even though $x had been "casted" to Foo, it should still behave like Bar, because it is one

[07:54] <nothingmuch> crap

[07:54] <luqui> unless you're redefining cast

[07:54] <luqui> but I'm under the impression that if you override an attribute in a base class, space for that attribute shouldn't even be allocated

[07:54] <luqui> so it may not even make sense to call the method of a base class

[07:55] <gaal> luqui: point.

[07:55] <luqui> man, we still have to figure out BUILD.  How can you claim to have an object system if you don't even have that?

[07:55] * gaal wants a subject system

[07:56] <gaal> but is more likely to get an abject system

[07:56] * luqui wants a dative system.   But there have to be hot chicks on it.

[07:57] * luqui wonders if he still has that latinesque toy language of his

[08:00] * gaal wonders what luqui's gallinaceous dative system would do in the case of method conflicts.

[08:01] <luqui> maybe it would be methodist-only

[08:01] * luqui looks up "gallinaceous"

[08:02] <gaal> galline golfs it down a bit, really.

[08:02] <gaal> you did want chicks eh.

[08:02] <gaal> anymoose: $work &

[08:02] <luqui> that even furthers the joke

[08:03] <gaal> hey, the reason I spell my name with two As is to prevent (American) people from thinking I'm a chick.

[08:04] <gaal> s/prevent/avoid having them assume/ etc.

[08:04] <gaal> (can't help what other people think)

[09:13] <gaal> luqui: in c#, base class attributes *are* allocated, and are reachable. fwiw.

[09:13] <gaal> # http://msdn.microsoft.com/library/en-us/csref/html/vclrfaccessorspg.asp

[10:01] <Alias_> OK, so

[10:01] * Alias_ waits until nothingmuch stops being distracted by salad

[10:02] <nothingmuch> ~30 mins

[10:02] <nothingmuch> ciao

[10:07] <gaal> Lettuce go now you and I... Is it dressing from a cucumber that makes me so encumbered?

[10:24] <luqui> gaal, yeah, I know.  I'm trying to change conventional OOP.

[10:24] <luqui> but thanks

[10:27] * luqui beds

[10:39] <nothingmuch> dancing moose moose moose moose laa di da di da

[10:40] <avar> zomg

[10:40] <avar> just how long does building pugs take?

[10:40] <webmind> depends on your cpu I think? :)

[10:41] <avar> It still hadn't compiled after ~6hrs

[10:41] <avar> started it when I went to sleep

[10:41] <nothingmuch> that's too much

[10:41] <avar> 1GHz iBook G4 running GNU/Linux

[10:41] <nothingmuch> doesn't make sense

[10:42] <avar> I even did make unoptimized!

[10:42] <nothingmuch> that makes even less sense

[10:43] <avar> how long should it take, approximately

[10:50] <gaal> avar: how much RAM have you got?

[10:50] <gaal> is the machine thrashing?

[10:50] <avar> 512MB real 512MB swap

[10:51] <gaal> luqui: ack; which is why I appended the qualification.

[10:51] <gaal> avar: how big is your ghc? you *sure* you're running with -O0?

[10:52] <avar> what would "big" mean in this sense?;)

[10:52] <nothingmuch> RSS, VSZ from top or ps

[10:54] <avar> mm, I tried turning swap off and I'm building it again, it was defenetly swapping before though, but I still think it took a bit too long

[10:54] <avar> (didn't finish, I killed it)

[10:55] <avar> trying again

[11:02] <gaal> avar: afair 'make unoptimized' shouldn't go over 200, maybe 220mb

[11:08] <avar> oh dear

[11:21] <avar> it always gets killed my linux because of lack of memory, trying with swap again

[12:30] <xinming> b

[13:25] * DaGo buenas!

[13:30] <avar> woo

[13:31] <avar> my pugs build worked like a charm when I reduced the heap size for ghc

[13:31] <avar> it was either that or setting precompile_prelude: false

[13:35] <gaal> avar: did you manage an unoptimized build with precompiled prelude? that's interesting

[13:35] <avar> of course it doesn't actually work;)

[13:36] <avar> well, I have to install it, it's trying to load some stuff from /usr/lib/perl6

[13:36] <avar> does PREFIX= still not work like it says in INSTALL?

[13:38] <gaal> dunno.

[13:39] <gaal> why do you need to install? i haven't installed in a loong while.

[13:39] <gaal> export PERL6LIB=blib6/lib

[13:39] <gaal> or setenv equivalent.

[14:31] <rafl_> Juerd: ping

[14:55] <svnbot6> r8444 | audreyt++ | * Text.Parser.OpTable: 100% feature-complete port of PGE::OPTable!

[14:55] <svnbot6> r8444 | audreyt++ |   Pure-Haskell port of PGE (compiling rules to parsec) is now within reach.

[14:55] * audreyt wonders if luqui will get some cycles to do a p6 port from this

[14:56] <clkao> WHOOT

[14:56] <clkao> audreyt++

[14:57] <audreyt> :)))

[14:57] <clkao> we should meet up

[14:57] <audreyt> verily. you @ taizhong or taibei?

[14:58] <clkao> taipei

[14:58] <clkao> till wednesday and then i am off for some hiking

[14:58] <clkao> i am having dinner with uni friends tomorrow

[15:00] <audreyt> k

[15:00] <audreyt> so you are free at daytime?

[15:01] <clkao> likely, and will probably be around ntu

[15:01] <audreyt> cool, I can probably go find you then

[15:01] <audreyt> you got a cell #?

[15:02] <clkao> yep. tmp one.

[15:02] <xinming> audreyt: will you come to China in the future? :-)

[15:02] <hcchien> clkao: where will you go for hiking

[15:02] <audreyt> xinming: sure, if there's a conference and preferably if someone pays for airfare :)

[15:03] <audreyt> xinming: if you can manage to come to Tokyo for YAPC::Asia, we can also meet there

[15:03] <clkao> hcchien: http://1b.hinet.net/~happyman/out/show.php?i=222000x2530000-8x12.tag.png

[15:04] <xinming> audreyt: I can't go anywhere after I learnt well, and make some money. :-P

[15:04] <xinming> I think I should use "before". :-/

[15:05] * xinming is going out for supper

[15:10] <gaal> is "bei" in taibei related to mandarin bei (north)?

[15:10] <nothingmuch> ARF

[15:10] * nothingmuch is getting segfault from inside libc's malloc

[15:11] <nothingmuch> =(

[15:11] <audreyt> gaal: yup

[15:12] <audreyt> nothingmuch: clearly you need a better libc

[15:12] <nothingmuch> audreyt: it's directly affected by a change I made

[15:12] <nothingmuch> i just need to figure out what =(

[15:12] <nothingmuch> redhat--

[15:12] <stevan_> hello all :)

[15:12] <nothingmuch> the set of all inputs to malloc is amazingly huge

[15:12] <nothingmuch> ofcourse, the bug lies therein

[15:12] <nothingmuch> but I trigger it somehow

[15:12] <nothingmuch> hola stevan_ 

[15:13] <stevan_> audreyt: roles are working now, but we need to chat about how to die when conflicts arise

[15:13] <nothingmuch> fuck this. i want to be out biking

[15:13] <nothingmuch> work-- # exhausting

[15:13] <stevan_> (C++)--

[15:13] <stevan_> hmm, that cancels itself out

[15:13] <nothingmuch> well, learning new stuff is exhasting

[15:13] <stevan_> learning new stuff is good though

[15:14] <nothingmuch> stevan_: you just tride to pass an rvalue as a rw to postfix --

[15:14] <nothingmuch> naghty

[15:14] <audreyt> stevan_: ::.error_conflict_arises

[15:14] <audreyt> stevan_: that may be to gonzo. you'd like an exception object I presume?

[15:14] <stevan_> audreyt: no need for exceptions actually

[15:15] <stevan_> I was thinking I would return you a "conflict" object

[15:15] <stevan_> I could collect detailed info 

[15:15] <audreyt> that's best

[15:15] <stevan_> basically punting to the next layer

[15:15] <audreyt> since at your level a conflict need not be fatal

[15:15] <stevan_> exactly

[15:15] <audreyt> so it makes sense to punt... damn we agree again.

[15:15] <stevan_> :)

[15:15] <stevan_> I blame nothingmuch 

[15:15] * nothingmuch kicks stevan_

[15:15] <nothingmuch> i'm exhausted, don't blame me for anything right now

[15:16] <stevan_> ok, I blame luqui then

[15:16] <nothingmuch> thanks

[15:16] <stevan_> he was the one helping me with the Haskell

[15:16] <audreyt> not fair, luqui's not even here :)

[15:16] <stevan_> exactly :)

[15:16] * stevan_ praises nothingmuch 

[15:16] <stevan_> you sound like you need it :)

[15:17] <nothingmuch> stevan_: tell rob i am willing to make a Catalyst plugin out of CGI.pm's html generation, so he can have his awesome rails feature ;-)

[15:17] <stevan_> audreyt: I will collect the follwing things: the name of the conflicting item, and the roles in which they conflicted

[15:17] <nothingmuch> it didn't occur to me till today that *that* was what he was really complaining catalyst lacks ;-)

[15:17] <stevan_> and return an opaque with a hash of these items, one for methods and one for attributes

[15:18] <stevan_> nothingmuch: no, what he wants is the Ruby on Rails idea of a "full stack"

[15:18] <stevan_> he wants the intelligent defaults too

[15:18] <nothingmuch> i'm not really serious

[15:18] <stevan_> which is counter to Catalyst in many ways

[15:18] <nothingmuch> but he gave 'textbox("foo", "bar")' as an example of a killer feature ;-)

[15:18] <stevan_> nothingmuch: :)

[15:18] <stevan_> nothingmuch: when was this? recently, like today?

[15:19] <nothingmuch> when was what?

[15:19] <stevan_> cause i told him to look at Jifty, which might be where he got that idea

[15:19] <nothingmuch> a while ago

[15:19] <stevan_> oh

[15:19] <nothingmuch> like 2-3 weeks

[15:19] <stevan_> yeah, blame me, I got him the Rails book on the company card :)

[15:19] <nothingmuch> aye

[15:19] * nothingmuch can't see how a fully integrated stack can be good for business though

[15:20] <nothingmuch> sure, it saves time the first 50% of the way

[15:20] <nothingmuch> but then...

[15:20] <stevan_> nothingmuch: well thats the thing, most of what we do is in the first 50%

[15:20] <nothingmuch> unless the app is so simple it might as well be just a scaffold

[15:20] <stevan_> well, the scaffold looks like shit though

[15:20] <stevan_> people want pretty applications :)

[15:20] <nothingmuch> heh

[15:21] <audreyt> stevan_: roger. is Bootstrap.pil ready for separate dispatch of .send and .send_private?

[15:21] <stevan_> but other than that, yes thats most of what we need

[15:21] <stevan_> audreyt: yes I think it is

[15:21] <nothingmuch> what I mean to say is that the reason I value catalyst is that when I had to plug it into some backends that were not fully integrated into a stack

[15:21] <audreyt> k

[15:21] <nothingmuch> backends which my company paid big bucks to have

[15:21] <stevan_> I am properly installing to %!private_methods and self!method is used where appropriate

[15:21] <audreyt> yeah, cat is very gluey. I like that a lot.

[15:21] <nothingmuch> then catalyst made it very easy, since I didn't have to a. learn magic b. learn how to undo that magic c. undo the magic d. reimplement the magic on my other backend

[15:22] <nothingmuch> the ratio of magic to usefulness is very good

[15:22] <nothingmuch> magic is only good if it gives usefulness

[15:22] <stevan_> nothingmuch: I agree, but the less time i spend on $work , the more time i can spend here ;)

[15:22] <audreyt> perl5/mg.c: "Sam sat on the ground and put his head in his hands.  'I wish I had never come here, and I don't want to see no more magic,' he said, and fell silent."

[15:22] <nothingmuch> that's true

[15:23] <nothingmuch> but i guess the real issue is what I had to work on and what you have to work on

[15:23] <stevan_> nothingmuch: very true

[15:23] <avar> Compiling Pugs.Run         ( src/Pugs/Run.hs, dist/build/src/Pugs/Run.o )

[15:23] <avar> GHC's heap exhausted: current limit is 99999744 bytes;

[15:23] <avar> hur hur

[15:23] <nothingmuch> you're thinking of reimplementing the ears thing?

[15:23] <audreyt> avar: "make" again should fix that

[15:23] <stevan_> nothingmuch: I actually think a full stack on top of catalyst is probably a good idea

[15:24] <audreyt> avar: we are working on fixing it with the minilang thing :)

[15:24] <avar> audreyt: it was a typo in config.yml

[15:24] <nothingmuch> stevan_: Catalyst::Enzyme is perhaps a full stack and then some

[15:24] <audreyt> avar: it was?

[15:24] <audreyt> oh, a missing 0

[15:24] <stevan_> nothingmuch: well, we have some new work which almost requires we re-write it (new features, more flexibility, etc)

[15:24] <nothingmuch> also, by not saying "full stack, la la la" you can't avoid design

[15:24] <stevan_> nothingmuch: I have been watching Catalyst::Enzymem

[15:25] <avar> I speled precompile_prelude: false bad!

[15:25] <nothingmuch> so people make the frameworks (e.g. HTML::Widget) be something that's both useful as a full stack (90% at least)

[15:25] <nothingmuch> and very reusable, too

[15:25] <avar> audreyt: nah, already doing "make unoptimized"

[15:25] <stevan_> nothingmuch: have you looked at seaside?

[15:25] <nothingmuch> if you look at lathos's maypole hacks for CDBI - eeeeeeeeeeeeeeeeeeeekk

[15:25] <nothingmuch> no, not yet

[15:25] <nothingmuch> i sort of planned to

[15:25] <audreyt> k.. very strangely, "unoptimized" is more likely to blow up heap in Run.hs

[15:25] <nothingmuch> but no i realized i'll never get to it

[15:25] <audreyt> if you just type "make" now, it will probably work :)

[15:25] <nothingmuch> now

[15:25] <stevan_> nothingmuch: it is very nice, and worth a look

[15:26] <avar> audreyt: already did make clean;)

[15:26] <audreyt> avar: sigh :)

[15:26] <nothingmuch> when I'm back in the webapp business, if ever, i promise to have a look

[15:26] <stevan_> if for nothing more than to steal the good ideas from

[15:26] <stevan_> nothingmuch: ok :)

[15:26] <nothingmuch> i know that it's continuation based, right?

[15:26] <stevan_> yup

[15:26] * stevan_ likes continutations :)

[15:26] <nothingmuch> what i'd like is to steal jifty's form dispatch orientation thing

[15:26] <nothingmuch> it sounds useful

[15:27] <nothingmuch> i just have to see what it is

[15:27] <nothingmuch> but again, punt till webapp business

[15:27] <nothingmuch> hint hint

[15:27] <nothingmuch> ;-)

[15:27] <stevan_> we are going to do a review of all the major frameworks in January, and build pros/cons lists too

[15:27] <stevan_> if it comes out useful we will put it up public somewhere

[15:29] <nothingmuch> aye

[15:29] <nothingmuch> my grudge with jifty at the moment: learn yet another ORM, and yet another template engine

[15:29] <stevan_> nothingmuch: learning new things is a Good Thing, it expands your vision ;)

[15:29] <nothingmuch> well, yes

[15:30] <nothingmuch> but (time / value)

[15:30] <nothingmuch> i already know the ORM and templating problem

[15:30] <stevan_> I like the sound of Jifty, my only concern is it's BETA state, but thats a temporary thing

[15:30] <nothingmuch> no matter how clever Jifty::DBI is, i doubt it will be as mind opening as the lambda shaped crowbar that audreyt shoved in to my ear and pried my mind open with

[15:30] <stevan_> nothingmuch: yes, we are looking for a long term investment though, so "learning new things" is not really a concern for us

[15:31] <nothingmuch> aye

[15:31] * stevan_ wonders if there is a Haskell on Rails :P

[15:31] <audreyt> aye, it's HSP

[15:31] <stevan_> :)

[15:32] <audreyt> very cool stuff with inline XML construction and regex match of XML patterns

[15:32] <stevan_> oh

[15:32] <nothingmuch> is it like that filesystem that oleg(?) wrote?

[15:33] <nothingmuch> using the zipper pattern and continuations to represent a repeatable read model for the data, through an HTTP view?

[15:33] <nothingmuch> that would be so cool that no one would use it

[15:33] <nothingmuch> =D

[15:33] <audreyt> nothingmuch: no, that's WASH

[15:33] <nothingmuch> that's not googleable

[15:33] <nothingmuch> oh, it is

[15:33] * stevan_ tries to recruit nothingmuch to work on a mini-language based web framework

[15:33] <audreyt> nothingmuch: http://www.haskell.org/communities/11-2005/html/report.html#wash

[15:34] <audreyt> also http://www.haskell.org/communities/11-2005/html/report.html#hasp

[15:34] <stevan_> audreyt: is the mini-language going to be PIL2? or is it that already?

[15:35] <audreyt> stevan_: no, PIL2 will have native construction nodes for SigList, ArgList and containers

[15:35] <audreyt> NativeMap etc is _not_ exposed to PIL2.

[15:35] <stevan_> ok

[15:35] <nothingmuch> AUGH

[15:35] <stevan_> we need a good name for it then

[15:35] <nothingmuch> i want to go out

[15:35] <nothingmuch> walk

[15:35] <nothingmuch> sick of sitting

[15:35] <nothingmuch> ENORIDE

[15:35] <stevan_> mini-language is too much to type, and not very sexy

[15:35] <audreyt> PILN

[15:36] <audreyt> for PIL-Native

[15:36] <audreyt> PIL.N

[15:36] <nothingmuch> Pee.NET

[15:36] * stevan_ gives nothingmuch a "get out of work free" card

[15:36] <nothingmuch> (the L is silent)

[15:36] <audreyt> do not pass IRC. do not collect 200 karma.

[15:37] <nothingmuch> karma nothingmuch?

[15:37] <nothingmuch> no jabbot?

[15:37] <nothingmuch> perlbot: karma for nothingmuch?

[15:37] <perlbot> Karma for nothingmuch: 27

[15:37] <stevan_> slow perlbot

[15:37] <nothingmuch> perlbot: karma for audreyt 

[15:37] <perlbot> Karma for audreyt: 15

[15:37] <nothingmuch> perlbot: karma for autrijus

[15:37] <perlbot> Karma for autrijus: 90

[15:37] <nothingmuch> hmm

[15:37] <nothingmuch> perlbot: karma for c

[15:37] <perlbot> Karma for c: 708

[15:38] <nothingmuch> i remember you had ~600 a while back

[15:38] <nothingmuch> oh well

[15:38] <gaal> so, who's changing their name to c?

[15:38] <nothingmuch> gaal: chromatic

[15:38] *** stevan_ is now known as c

[15:38] <c> c--

[15:38] <audreyt> c--++

[15:38] *** c is now known as stevan_

[15:38] <audreyt> # nice intermediate language

[15:38] <gaal> c-+-+

[15:38] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:38] *** evalbot_8441 is now known as evalbot_8444

[15:38] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> perlbot: karma for c

[15:39] <perlbot> Karma for c: 442

[15:39] <nothingmuch> laa di daa

[15:39] <stevan_> wow it worked :)

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <gaal> talk about "killer feature"

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> perlbot: karma for c

[15:39] <perlbot> Karma for c: 178

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 1000

[15:39] <stevan_> :D

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:39] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:39] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:40] <nothingmuch> perlbot: karma for c

[15:40] <perlbot> Karma for c: -86

[15:40] <nothingmuch> damn right!

[15:40] <stevan_> thats better :)

[15:40] <nothingmuch> ?eval say 'c-- ' for 1 .. 100

[15:40] <evalbot_8444> OUTPUT[c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  c--  

[15:40] <nothingmuch> one last time ;-)

[15:40] * gaal sets topic for #pugs: "nothingmuch doesn't like c very much"

[15:40] <audreyt> or rather, s/c/$work/

[15:40] <nothingmuch> no, i like work

[15:40] <nothingmuch> i'm just tired

[15:40] <gaal> s/pugs/perl6/

[15:40] <nothingmuch> and I want to go home and do stuff

[15:40] <audreyt> I see

[15:40] <nothingmuch> but I don't have a way home yet

[15:41] <audreyt> so s/$work/boredom/

[15:41] <nothingmuch> aye

[15:41] <nothingmuch> time for tea

[15:43] <stevan_> audreyt: I think I like PILN the best

[15:43] <gaal> audreyt: I'll finally have some time tomorrow for import/export stuff again. what do you think can be done w/o major refactorings?

[15:43] <nothingmuch> tPILN

[15:44] <nothingmuch> PILN

[15:44] <nothingmuch> somewhat hard to type

[15:44] <nothingmuch> Pee.NET, on the other hand

[15:44] <gaal> assuming i break chained assignments :) 

[15:44] <stevan_> nothingmuch: Pee stands for?

[15:44] <gaal> pull in reduceSyn's logic into ruleVarDeclaration etc?

[15:44] <nothingmuch> stevan_: it's a porn site

[15:44] <nothingmuch> just ignore me

[15:45] <stevan_> :) # programmer porn

[15:45] <nothingmuch> unixsex!

[15:45] <nothingmuch> i think i'm going to go home

[15:45] <nothingmuch> or rather, to b.s.

[15:45] <stevan_> where programmers go to look at unmanaged code

[15:45] * stevan_ has to go as well (family activities and such)

[15:45] <avar> audreyt: setting precompile_prelude = false worked;)

[15:45] <stevan_> adios all &

[16:11] <kenben> when is perl 6 coming out

[16:11] <clkao> by christmas, of course

[16:11] <nothingmuch> a christmas

[16:12] <kenben> lol

[17:10] <svnbot6> r8445 | audreyt++ | * PILN: Handle the three method dispatch forms (obj`prim,

[17:10] <svnbot6> r8445 | audreyt++ |   obj!private, obj.public) distinctly and correctly.

[17:10] <svnbot6> r8445 | audreyt++ | * Adjust Bootstrap.pil's invocations to use the new syntax.

[17:10] <svnbot6> r8445 | audreyt++ |   A few tests from bootstrap.t still fails; probably needs

[17:10] <svnbot6> r8445 | audreyt++ |   some input from stevan++.

[17:34] <svnbot6> r8446 | audreyt++ | * fix syntax tutorial in PIL.Native.Parser's comments.

[19:36] <luqui> guten tag

[20:19] <svnbot6> r8447 | gaal++ | * pil REPL: don't die on parse errors

[20:50] *** Mahmoud-Afk is now known as Mahmoud

[20:52] <wolverian> is there a specced method yet to tell what kind of values an array can hold?

[20:52] <wolverian> I see there's .shape.. I don't think that holds what I want, though

[20:52] <wolverian> (this is perl6, not pugs)

[20:55] <wolverian> .sig.returns maybe? 

[20:55] <wolverian> arrays are after all glorified subroutines :)

[20:56] <avar> mm, ideas

[20:57] <avar> I'm going to write a program that allows you do to stuff like my $res = $x + $y; where $x = "one" and $x = "forty-two"; $res would then become 43

[20:57] <avar> Obviously I'm going to have to overload the + operator and have $x and $y be some type I make up

[20:57] <wolverian> remember i18n :)

[20:57] <avar> but I don't quite know how to get started, the synopsis only glance over it..

[20:58] <avar> where can I read about how to do stuff like

[20:58] <gaal> multi &infix<+> (Str $x, Str $y) { ... }

[20:58] <avar> $y = new Number("forty-two"); 

[20:58] <diotalevi_> Say, this is OT but it seems like rt.perl.org isn't authenticating using the same database as rt.cpan.org. Is this true?

[20:58] <wolverian> avar, Number.new :)

[20:58] <avar> gaal: Yeah, I know, but I don't know how it works with classes..

[20:58] <avar> and I want to make it work through one

[20:59] <gaal> rt.cpan.org authes with PAUSE

[20:59] <gaal> what's at rt.perl.org? :)

[20:59] <avar> i.e. how does overloading an operator inside a class relate to the rest of the program?

[20:59] <wolverian> it's a global (ie, in the * namespace), unless you say 'my multi'

[20:59] <diotalevi_> avar, isn't there already a CPAN module for doing that? "one" + "two" is likely already handled in a p5 cpan module.

[20:59] <gaal> avar: this is multi dispatch

[21:00] <gaal> see the end of S12 IIRC

[21:00] <wolverian> so, no ideas about the array introspection? 

[21:00] <avar> ah, a multi sub is accesable below the scope which it was defined in?

[21:00] <diotalevi_> rt.perl.org is what perl5 is tracked in. Apparently it's not in the rt.cpan.org site.

[21:00] * wolverian goes look in S29

[21:00] <avar> I though it was just accessable if you included a file ...

[21:01] <wolverian> not in S29 :)

[21:01] <avar> if that's the case that's the answer I was looking for then;)

[21:01] <gaal> avar: like wolverian said, you want the method to be in *

[21:01] <avar> mm, okey, thanks!

[21:01] <gaal> ah, S13

[21:02] <wolverian> ..which is the default when you say 'multi foo ...', I think

[21:02] <gaal> wolverian: I think not

[21:02] <gaal> "Note the lack of * on those definitions. That means this definition of addition is only in effect within the scope of the package in which infix:<+> is defined. Similar constraints apply to lexically scoped multi subs. Generally you want to put your multi subs into the * space, however, so that they work everywhere."

[21:03] <wolverian> oh, sorry.

[21:06] <gaal> I think introspection is underspecced in general.

[21:08] <gaal> I'm sure luqui &co. have more rabbits up their sleeves, but I never saw how to interrogate a sub about whether it has a named arg called X and what's its type etc.

[21:08] <luqui> hmm... yeah, not specced

[21:08] <luqui> probably just goes with the OO interface for &codes

[21:09] <gaal> was I right about your rabbity sleeves? (does that tickle, I always wondered?)

[21:09] <luqui> i.e. it's not something that really needs to be specced

[21:09] <luqui> gaal, it hurts more than tickles

[21:09] <gaal> hum? why not?

[21:09] <luqui> well, it's almost arbitrary, as long as there is *some* WTDI

[21:09] <luqui> it's not a linguistic issue

[21:10] <gaal> OO interfaces can be better or worse too you know :)

[21:10] <luqui> though for multiple implementations, it's good to have it nailed down

[21:10] <luqui> gaal, yeah, sure, but that's not the kind of thing that's done often enough for it to matter

[21:12] <lisppaste3> avar pasted "overloading" at http://paste.lisp.org/display/15032

[21:12] <avar> mm, what am I doing wrong

[21:12] <avar> that's the basic concept of how this is going to look...

[21:13] <luqui> avar, well, what is going wrong?

[21:13] <avar> *** cannot cast from VObject (MkObject {objType = (mkType "Tala"), objAttrs = <ref>, objOpaque = Nothing, objId = 53}) to Double (VNum)

[21:13] <avar>     at int2is2.p6 line 31, column 5-12

[21:13] <gaal> avar: try putting the last three lines inside the class scope, for starters

[21:14] <gaal> not sure what the state of this is in pugs

[21:14] <luqui> avar, when you're overloading an operator

[21:14] <luqui> you want to put the multi into the global namespace

[21:14] <luqui> the only time you don't is when you want to lexically override some notation

[21:14] <luqui> that is, change multi sub infix:<+> ...

[21:14] <luqui> to multi sub *infix:<+> ...

[21:15] * gaal sleeps &

[21:15] <avar> woo, that works;)

[21:15] <avar> thx

[21:15] <luqui> we really ought to have warnings and whatnot about that

[21:15] <gaal> how would you avoid the warning?

[21:15] <luqui> no warnings ...

[21:16] <gaal> heh, that may be a while. :)

[21:16] <luqui> to me, and this could be argued, the only operator overloading that make sense are lexical and global

[21:16] <luqui> package doesn't make sense

[21:16] <luqui> but package is the default!

[21:17] <gaal> zzZZZ fer realzors &

[21:20] <avar> arr, nothing's working/

[21:20] *** avar is now known as avar\awk

[21:20] <luqui> avar\awk... \awk?

[21:21] <luqui> Aho, Weinberger, Kernighan?

[21:21] <luqui> avar is more famous that I thought...

[21:26] <wolverian> maybe should prod p6l about introspectoin?

[21:26] <wolverian> s,oi,io,

[21:27] <luqui> have at it

[21:30] *** avar\awk is now known as avar

[21:35] <wolverian> sent

[21:38] <lisppaste3> avar annotated #15032 with "infinite loop..." at http://paste.lisp.org/display/15032#1

[21:39] <avar> that's strange

[21:39] <luqui> avar, known bug

[21:40] * luqui plays with it to find a workaround

[21:44] <luqui> hmmm... the usual workaround is not working

[21:45] * luqui is stumped

[22:07] *** Mahmoud is now known as Mahmoud-Afk

[22:20] <avarab> luqui: did you find something?

[22:20] <svnbot6> r8448 | luqui++ | Fixed interpretation of curlies to make a hash.  The following:

[22:20] <svnbot6> r8448 | luqui++ |     { %foo }

[22:20] <svnbot6> r8448 | luqui++ |     { %$foo }

[22:20] <svnbot6> r8448 | luqui++ |     { %foo, a => 1, b => 2 }

[22:20] <svnbot6> r8448 | luqui++ | are now interpreted correctly.

[22:20] <luqui> wtf... svk is being a bitch

[22:20] <luqui> avarab, no, sorry

[22:21] <luqui> I could have sworn I already committed that!

[22:23] <avarab> that's pretty much a showstopper for my app if I can't find a workaround;/

[22:24] <luqui> hmm..

[22:25] <luqui> unless you can figure out a way to add without calling '+'...

[22:29] <svnbot6> r8449 | luqui++ | Backtracking controls.

[22:29] <svnbot6> r8450 | luqui++ | Change "cut"'s name to "commit", even though what I'm doing is a little more general than commit.

[22:29] <avarab> hahah

[22:29] <avarab> I found a workaround

[22:30] <luqui> how can I get conflicts when I'm the only one editing these files!?

[22:30] <luqui> avarab, cool, what did you do?

[22:30] <svnbot6> r8451 | luqui++ | A little documentation.

[22:31] <lisppaste3> avar annotated #15032 with "workaround" at http://paste.lisp.org/display/15032#2

[22:31] * luqui isn't sure why that works...

[22:31] <svnbot6> r8452 | luqui++ | A little bit more documentation, for the slightly tricky quantify combinator.

[22:31] <svnbot6> r8453 | luqui++ | Minimal quantifiers.

[22:32] <luqui> maybe it's the type annotations

[22:32] <avarab> is there a t/pugsbugs/ for it?

[22:33] <luqui> I think r0nny put in a test for a related problem

[22:33] <svnbot6> r8454 | luqui++ | Making sure that quantifiers are maximal by default.

[22:33] <svnbot6> r8455 | luqui++ | Optional, and some untested anchors.

[22:33] <luqui> but more tests never hurt

[22:33] <avarab> I'm not sure how to make a test for something that results in an infinite loop

[22:33] <avarab> and something I can't narrow down to a single statement...

[22:33] <luqui> it's easy to test the latter

[22:34] <luqui> just set up the necessary stuff before the actual test

[22:34] <svnbot6> r8456 | luqui++ | Renamed match_num and match_name to capture_num and capture_name, since

[22:34] <svnbot6> r8456 | luqui++ | they're better names for that.

[22:34] <luqui> if calling + results in an infinite loop...

[22:34] <luqui> then put a counter around the call to +

[22:35] <luqui> and make sure it doesn't exceed, oh, say, 10

[22:35] <luqui> it's an infinite *recursion*

[22:35] <svnbot6> r8459 | luqui++ | Get rid of some error checking in perl6.vim, because it has false negatives.

[22:35] <svnbot6> r8459 | luqui++ | Specifically: ( $s { } )

[22:35] <svnbot6> r8460 | luqui++ | Fixed editor.vim better.

[22:35] <svnbot6> r8461 | luqui++ | Allow ./method: arg1, arg2  (listop method with implicit invocant).  Refactored

[22:35] <svnbot6> r8461 | luqui++ | the parser a little in the process.

[22:35] <luqui> other sorts of infinite loops are not so easy

[22:35] <luqui> ugh, that was a painful push

[22:35] <luqui> I could have sworn that I pushed that stuff long ago

[22:35] <luqui> and I got conflicts all over the place

[22:36] <luqui> svk--

[22:40] <lisppaste3> avar pasted "hmm" at http://paste.lisp.org/display/15036

[22:42] * luqui &

[22:54] <stevan> audreyt: all tests pass now

[22:55] <stevan> mostly it was swapping . for ` 

[22:55] <luqui> stevan, did you see my proclimation yesterday?

[22:55] <stevan> see r8463

[22:55] <luqui> I don't have the guts to p6l it yet

[22:55] <stevan> luqui: yes I did 

[22:55] <stevan> I agree with you, but disagree at the same time :)

[22:55] <luqui> 'splain

[22:55] <stevan> I agree we dont really need them

[22:55] <stevan> but I disagree that we should do anything about that

[22:55] <svnbot6> r8463 | stevan++ | PIL.Native.Bootstrap.pil

[22:55] <svnbot6> r8463 | stevan++ | - added .class and .id methods to ::Object so that they are 

[22:55] <svnbot6> r8463 | stevan++ |   accessible to the metamodel

[22:55] <svnbot6> r8463 | stevan++ | - fixed is_a (it used . where it meant `)

[22:55] <svnbot6> r8463 | stevan++ | t/pil/metamodel/*

[22:55] <svnbot6> r8463 | stevan++ | - fixed all tests to pass, a lot of swapping . for `

[22:56] <stevan> people are used to classes

[22:56] <stevan> they like classes

[22:56] <luqui> oh, no, I didn't say we didn't need classes

[22:56] <stevan> classes make them feel all warm and fuzzy

[22:56] <luqui> I think we do

[22:56] <luqui> I said we didn't need inheritance

[22:56] <stevan> that all goes for inheritence too

[22:56] <stevan> you can't shake things up that much

[22:56] <luqui> i.e. there doesn't need to be a difference between inheritance and role composition

[22:56] <stevan> right

[22:56] <stevan> but shhhh don't tell people that

[22:56] <stevan> :P

[22:57] <stevan> you will scare them away

[22:57] <luqui> well, we could just s/is/does/g, and teach people that "does" is how you inherit

[22:57] <luqui> "is" is for trait application anyway

[22:57] <luqui> and I've never liked the overloading of that word

[22:57] <stevan> I think it is a case of "dont rock the boat" 

[22:57] <luqui> why?

[22:57] <stevan> perl 5 people will have enough time with a real object system

[22:57] <stevan> it takes some getting used to

[22:58] <stevan> I think most people will like it

[22:58] <stevan> but its an adjustment

[22:58] <luqui> yeah... except... 

[22:58] <luqui> there's this thing about "what does it mean for a role to inherit"?

[22:58] <stevan> so to snatch classes and things many people are comfortable with, out from under it,.. thats too much

[22:58] <stevan> roles dont inherit

[22:58] <stevan> thats the thing

[22:58] <stevan> they flatten

[22:59] <luqui> yeah

[22:59] <stevan> only like a handful of people really understand what that means

[22:59] <luqui> so they flatten in the inheritance

[22:59] <luqui> but then what does inheritance do?

[22:59] <stevan> its chains it

[22:59] <stevan> only langs like C++, where everything is analyzed to death, is inheritence flattend

[22:59] <stevan> into vtables

[22:59] <stevan> thats what vtables are basically

[22:59] <stevan> flattened inheritence

[22:59] <luqui> yep

[23:00] <stevan> but anyway,.. I agree with you,.. they are pretty much interchangeable in most cases

[23:00] <luqui> the "pretty much" is what scares me

[23:00] <stevan> but thats the technical side of the argument

[23:00] <luqui> we have two different things, which do almost the same thing

[23:00] <stevan> well I imagine there might be an edge case or two where they differ

[23:00] <luqui> exactly!

[23:00] <stevan> but I am paranoid like that

[23:00] <luqui> how do people know which one to use?

[23:00] <stevan> they will learn

[23:00] <luqui> I don't know yet... you don't either.

[23:00] <stevan> roles are new things,.. shiney,.. and ohhhh so purty

[23:01] <luqui> sure

[23:01] <stevan> it will take time

[23:01] <luqui> I'm thinking that it will only "rock the boat" for people who are into the metamodel already

[23:01] <stevan> consider this,.. you, and I ,... we can write the p6 OO style guide

[23:01] <stevan> so we can stear them in the right direction :)

[23:01] <luqui> for the end user, and for the folks who don't care about the OO design, it amounts to s/is/does/g

[23:01] <stevan> oh, it's not rocking my boat really

[23:01] <wolverian> I happen to agree. two keywords that do the almost same thing is weird.

[23:02] <stevan> i think its a question of comfort level

[23:02] <stevan> this is the human end of language design

[23:02] <luqui> you think people are more comfortable with the "is" keyword than the "does" keyword?

[23:02] <stevan> if you change something too radically,.. you will scare a percentage of people away

[23:02] <wolverian> I don't like "does" 

[23:02] <stevan> luqui: keyword is irrelevant,.. its the words you use

[23:02] <luqui> stevan, yeah...

[23:03] <luqui> and we use the words "inheritance"

[23:03] <stevan> to best describe roles,.. you say they are composed,..

[23:03] <luqui> and role composition becomes our inheritance model

[23:03] <stevan> to best describe classes... you say they are inherited

[23:03] <luqui> maybe.

[23:04] <stevan> I will think it over more,.. and try to come up with test cases both for and against

[23:04] <luqui> the thing that differentiates roles from classes is that they have sane conflict resolution

[23:04] <luqui> other than that, they are just abstract classes

[23:04] <stevan> and they are not inherited

[23:04] <stevan> no, they are not

[23:04] <luqui> pretend they are

[23:04] <stevan> they are modules

[23:04] <stevan> they are not able to be instantiated

[23:04] <stevan> they dont need constructors

[23:04] <luqui> neither are abstract classes

[23:04] <stevan> they are dumb collections of methods and attrs

[23:05] <luqui> stevan, hang on

[23:05] * stevan swings from his branch awaiting luqui's next thought :)

[23:05] <wolverian> I don't see any difference between abstract classes and roles, myself 

[23:05] <wolverian> (besides inheritance)

[23:06] <stevan> wolverian: exactly,.. thats a big difference I think

[23:06] <luqui> tell me the difference between class Foo { does Bar }  and class Foo { is Baz }, given that the Bar role is just like the Baz abstract class (no constructors, uninstantiable)

[23:06] <stevan> luqui: how does next METHOD work in a flattened context?

[23:06] <stevan> if you have no super,..then where do you go

[23:06] <luqui> point

[23:07] <stevan> because everything is composed together,.. thee is no parentage,.. and so you cannot go anywhere

[23:07] <luqui> I don't tend to use those guys, so they don't enter into my consideration...

[23:07] <stevan> yeah

[23:07] <luqui> hmm

[23:07] <stevan> I tend to agree that role composition can be a superior form of class composition

[23:07] <luqui> what do people use SUPER for?

[23:07] <stevan> but I dont agree that it should replace inheritence

[23:07] <stevan> time and a place for both

[23:07] <luqui> er, I mean, NEXT (SUPER is gone)

[23:07] <luqui> stevan, what is that time and place?

[23:08] <stevan> t/pil/metamodel/S12_example.t

[23:08] <stevan> luqui: I hate to cut this short,.. but I am running off to see King Kong,.. and my wife is going to kill me if I dont get off the computer :) 

[23:08] <luqui> okay

[23:08] <luqui> we'll discuss later

[23:09] <stevan> luqui: I dont know what those time/places are,.. but we can/will figure them out

[23:09] <luqui> that's important

[23:09] <luqui> if we have a distinction between is and does, we have to know what the heck it is

[23:09] <stevan> but NEXT is *very* useful,.. trust me :)

[23:09] <luqui> see ya

[23:09] <stevan> ok,.. I will try to pop in later tonight 

[23:10] <luqui> I'm here all day, I think

[23:10] * stevan runs off before he gets in trouble &

[23:26] <stevan> luqui: another thought (this time to support the "just use roles" end of the argument

[23:26] <stevan> if you use multi-methods instead of instance/class methods, then you can have call-next-method

[23:27] <stevan> since you would just be calling the next most appropriate method,.. which will likely be the same one you would call for SUPER or next METHOD

[23:27] <stevan> this is how CLOS works

[23:27] <stevan> then classes/instances are just purely about attribute management

[23:27] <stevan> this is also how Dylan works

[23:28] <stevan> it would be possible and be very cool

[23:28] <stevan> CLOS/Dylan call it generic functions

[23:28] <stevan> take a look :)

[23:28] * stevan can go and enjoy the movie now that he said that ;)

[23:29] <stevan> and for the record,.. I am down with whatever meta-model makes sense,.. I am not married to the current one

[23:29] <stevan> I like it,..but I would be happy to write another one too,.. I enjoy it :)

