[02:56] <obra> seen audreyt 

[02:56] <jabbot> obra: audreyt was seen 1 days 3 hours 18 minutes 50 seconds ago

[03:08] <mlh_> getting over jet lag no doubt

[03:24] <Alias_> jabbot doesn't know what there were saying?

[05:39] <gaal> morning

[06:00] <PerlJam> good morrow

[06:00] <jdv79> are we there yet?

[06:00] <PerlJam> Australia has been there for hours

[06:00] <Alias_> days even

[06:01] <jdv79> huh?

[06:16] <Alias_> Well, on any given day, we spend most of it in the American tomorrow :)

[06:33] <GeJ> greetings all

[06:34] <PerlJam> Alias_: I doubt that America will look like Australia tomorrow :)

[06:34] <Alias_> true

[06:35] <Alias_> Do you have any idea how much effort we put in trying to live in the future!

[06:35] <PerlJam> heh

[06:35] <gaal> what ought to happen in terms of exportation for this sub?

[06:36] <gaal> sub In::Your::Face { ... } is export;

[06:36] <gaal> Is it okay to disallow this?

[06:37] <gaal> ie, reject export requests for scoped subs?

[06:38] <PerlJam> "scoped subs"?

[06:38] <gaal> errrr, qualified ones.

[06:39] <gaal> this is &Face, from the package In::Your

[06:39] <gaal> what does the consumer need to do to get this export?

[06:40] <PerlJam> Why would you disallow the exportation?

[06:41] <gaal> I'm not sure what it means.

[06:41] <gaal> ignore the export for a a moment:

[06:41] <gaal> is this new symbol (or overridden symbol) visible everywhere?

[06:41] <gaal> like it would be in p5

[06:42] <PerlJam> Should be (unless there's a local policy that would disallow it by making packages "closed" for instance)

[06:42] <gaal> so what does it mean for this to be exported?

[06:43] <gaal> what it would have meant if the original package had defined Face is export?

[06:43] <PerlJam> gaal: What does it mean for this to be exported:   package Foo;  sub bar is export { ... }

[06:43] <PerlJam> And how does that differ from sub Foo::bar is export { ... } ?

[06:44] <gaal> those should be equivalent. but consider:

[06:44] <gaal> package Foo; sub Bar::baz is export { ... }

[06:45] <PerlJam> That would define the baz sub in the Bar package and make that baz subroutine available to the caller.

[06:45] <gaal> the problem is that someone using Foo has control over symbols that are exported via use:

[06:46] <gaal> use Foo <baz>   <- weird

[06:47] <gaal> and probably wrong too, because

[06:47] <gaal> package Foo; sub baz is export { <1> } sub Bar::baz is export { <2> }

[06:47] <gaal> I'd like use Foo <baz> to give me 1

[06:48] <gaal> (instead of a headache)

[06:48] <gaal> how does the caller even request the other export in this case?

[06:49] <gaal> use Foo <Bar::baz> looks perverted.

[06:49] <PerlJam> seems like a question for p6l

[06:49] <gaal> yeah..

[06:49] <gaal> writing up.

[06:50] <PerlJam> hopefully you don't get warnocked

[06:50] <gaal> that is always a hope.

[06:57] <Alias_> hmm yields from bulk line testing of PPI are tailing off

[06:57] <Alias_> one test failure per half million tests on 120 random line noise

[06:58] <Alias_> And with that case fixed... that's probably going to drop to 1 per multiple-million, so I'm really into the diminishing returns curve now

[06:59] <Alias_> which probably sits over the 1-CPU-hour mark

[07:00] <obra> Did you end up dealing with those last few known cpan edge cases?

[07:01] <Alias_> I don't know actually

[07:01] <Alias_> That's my next step

[07:01] <Alias_> The only thing nastier than random line noise is CPAN

[07:01] <Alias_> :)

[07:01] <Alias_> My biggest problem is there's a leak

[07:01] <Alias_> 1.1k per document, and I've confirmed it's not me leaking circulars

[07:02] <Alias_> (for a 120char document)

[07:02] <gaal> "valgrind perl -e1" is pretty... stark.

[07:02] <Alias_> I've expanded the CPAN fileset out to 90,000 files

[07:03] <Alias_> And I can't make it to the end without leaking enough memory to crash my tinderbox-box

[07:03] <Alias_> So there's still some issues obviously

[07:03] <Alias_> But I imagine as far as complexity goes it should handle the corner cases now

[07:04] <Alias_> we'll soo... I'm doing a final 1-million-document test run and I'll fire up CPAN::Metrics

[07:04] <Alias_> see

[07:06] <Alias_> obra: If I can't locate it by the weekend I'm going to post a beer-metre award

[07:06] <Alias_> Hopefully that should help a little

[07:18] <Alias_> AHA!

[07:18] <Alias_> It's the tests that are leaking, not PPI! :)

[07:20] * luqui is replying to gaal

[07:20] <luqui> turns out that I've been thinking a lot about exports recently

[07:24] <PerlJam> luqui++

[07:24] <gaal> luqui: good, me too :)

[07:30] <audreyt> stevan__: twigils is out of fashion now, especially %:foo

[07:30] <audreyt> stevan__: it became %!foo and then made optional

[07:30] <audreyt> stevan__: I'm sorting out some $job stuff; will check back ~4hrs from now

[07:32] <audreyt> I've seen the boot code; will read it after job

[07:32] <audreyt> (I changed the twigils to !)

[07:36] <tewk> boot code uses equals assignment ie ::Module = ::Class.new(); which doesn't parse yet, I believe.

[07:36] <svnbot6> r8248 | autrijus++ | * change twigils from : to ! to align with S12.

[07:36] <audreyt> mm

[07:36] <audreyt> it can certainly be desugared

[07:38] * luqui thinks the whole private thing can be handled better using exports

[07:39] <luqui> export to the "method namespace" of the object, or some such

[07:47] <Alias_> audreyt: PPI 1.108 uploaded to fix yet more here-doc corner cases

[07:48] <Alias_> audreyt: I can't make it crash any more

[07:48] <audreyt> tewk: implemented

[07:48] <Alias_> 1,000,000 x 120-character random line noise passes

[07:48] <audreyt> Alias_: excellent!

[07:48] <Alias_> Final phase is "all of CPAN"

[07:48] <audreyt> but this is tokenizer?

[07:48] <Alias_> Nope

[07:48] <audreyt> oh, the whole thing

[07:49] <audreyt> you rock

[07:49] <svnbot6> r8249 | autrijus++ | * PIL.Native.Parser: Binding is desugared:

[07:49] <svnbot6> r8249 | autrijus++ |         $a := 1; $a.add(2)

[07:49] <svnbot6> r8249 | autrijus++ |   becomes

[07:49] <svnbot6> r8249 | autrijus++ |         (-> $a {$a.add(2)}).(1)

[07:49] <svnbot6> r8249 | autrijus++ | * Fix boot code to using :=

[07:49] <Alias_> All the way out to full ::Document objects

[07:49] <audreyt> I thought you said you had enough of it

[07:49] <audreyt> ;)

[07:49] <Alias_> Turns out there were less problems than I thought

[07:49] <Alias_> Maybe 10-15

[07:49] <audreyt> wonderful

[07:49] <audreyt> but I need to be offline and work out this $job thing :)

[07:49] <Alias_> line noise doesn't stress the "lexer" enough though

[07:49] <audreyt> will be back in ~4hrs

[07:49] <Alias_> So I'll throw CPAN at it a few times and we'll see

[07:49] <audreyt> yeah you need token generator

[07:49] <audreyt> instead of random chr, make it random useful tokens

[07:50] <Alias_> right, CPAN

[07:50] <audreyt> and chain them together

[07:50] <Alias_> random useful tokens

[07:50] <audreyt> nah, cpan is not random enough... need a markov chain

[07:50] <audreyt> but CPAN is a good start

[07:50] <Alias_> You can write that for me then

[07:50] <Alias_> CPAN is phase 3, it will suffice

[07:50] <audreyt> sure :)

[07:50] <audreyt> yup

[07:50] <Alias_> phase 4... yeah, you can do

[07:50] <audreyt> tewk: See if := makes sense to you and write some tests?

[07:51] <audreyt> need to run now... bbiab

[07:51] <audreyt> &

[07:51] * gaal goes afk too &

[07:51] <Alias_> By "had enough" I generally mean "until I have a decent night's sleep"

[07:51] <Alias_> I get sucked back in

[07:54] <gaal> luqui++ # response makes sense

[07:54] <gaal> while you're at it please see my mail before that, on a similar subject

[07:54] <gaal> afk fer real &

[07:55] <Alias_> blm: did you get my response?

[07:55] <blm> Nope.

[07:55] <blm> Did you do /msg NickServ IDENTIFY ?

[07:56] <blm> Sorry!

[07:56] <Alias_> several times

[07:56] <Alias_> And it doesn't seen to like me

[07:56] <Alias_> oh well

[07:56] <blm> Yes thought you would have

[07:56] <Alias_> Actually, brb

[07:56] <blm> ok :-)

[07:58] <tewk> audreyt: will do.

[09:04] <svnbot6> r8250 | tewk++ | Pil.hs

[09:04] <svnbot6> r8250 | tewk++ |   - added -p and -P to just dump parsed output

[09:04] <svnbot6> r8250 | tewk++ | t/pil/bindings.t

[09:04] <svnbot6> r8250 | tewk++ |   - initial tests for := bindings in mini-lang

[09:23] <tewk> audreyt: Where do I go to add line and column for this error message, pil: user error (Invalid number of args [] vs params ["%params"])?

[09:25] <tewk> ./pil src/PIL/Native/Bootstrap.pil generates the above error message

[09:25] <svnbot6> r8251 | tewk++ | Fixed syntax error due to missing comas

[09:29] <pd> Missing comas isn't necessarily a bad thing.

[09:31] <meppl> guten morgen

[09:38] <clkao> who maintains the smokeserv?

[09:51] <svnbot6> r8252 | xgl++ | fixed squinting my variables

[09:51] <Alias_> grr... very very bored right now

[11:03] * nothingmuch sneezes

[11:21] <nothingmuch> http://perlmonks.org/?node=Visit%20Reaped%20Nodes&nodenum=515681

[11:26] <gaal> rehi

[11:28] <nothingmuch> hola gaal 

[11:29] <xinming> bool

[11:29] <xinming> ?eval bool

[11:29] *** evalbot_8246 is now known as evalbot_8252

[11:29] <evalbot_8252> Error: No such sub: "&bool" 

[11:29] <xinming> ?eval boolean

[11:29] <evalbot_8252> Error: No such sub: "&boolean" 

[11:30] <xinming> hmm, is there a function to use instead of ? for boolean context?

[11:31] <Alias_> bool::erm

[11:32] <gaal> yo nuff

[11:33] <gaal> xinming: where would you use it, for precedence fixing?

[11:36] <xinming> gaal: hmm, I will use ? most time, But I think if there is a Bool function which will turn the context into boolean would be good,

[11:38] <gaal> how is this function distinct from "?"?

[11:39] <xinming> no difference. :-P

[11:41] <gaal> clkao: iblech, I think.

[11:41] <gaal> xinming: :-)

[12:02] <gaal> xinming: by the way, type declarations will probably do coersion, not raise an error. so:

[12:03] <gaal> my Bool $x = some_expr;

[12:03] <gaal> $x will be boolean.

[12:03] <gaal> afaik this isn't final though.

[12:05] <kane-xs_> my $x = !!some_expr; # so much more intuitive!

[12:06] <gaal> well, in the case of punctuation the starting point was that you could say ?some_expr.

[12:15] *** Jooon_ is now known as Jooon

[12:17] <fglock> xinming: the function for boolean context is 'true()'

[12:17] <xinming> ?eval true("")

[12:17] <evalbot_8252> bool::false 

[12:18] <xinming> how about the numberic and string context?

[12:19] <fglock> +() and ~()

[12:19] <xinming> hmm, I mean the function.

[12:20] <xinming> not the prefix operator.

[12:20] <wolverian> function, operator, what's the difference? :)

[12:21] <fglock> you mean the text-named function - I don't know if there is one for num and str. There is int() for integer

[12:22] <xinming> wolverian: prefer to have a clear name for the operator.

[12:22] <xinming> after perl 6 can be hosted, I think I will make the suggestion.

[12:22] <xinming> s/hosted/self-hosted/

[12:24] <fglock> sub num($x){+$x} sub str($x){~$x}

[12:24] <xinming> hmm, I mean for default perl 6. :-)

[12:25] <gaal> och, I'm being bitten by autovivification not working on raw ASTs. Is there a convenient way to get it?

[12:25] <xinming> I know we can write it ourselves. But if default perl 6 has such functions will be better. :-)

[12:25] <fglock> xinming: you can make suggestions in p6l

[12:25] <gaal> Syn "=" [Syn "{}" [Syn "{}" [Syn "{}" [ ... ] ] ] ]

[12:27] <gaal> at least, I think that's what's happening... the expression fails.

[12:29] <fglock> xinming: for stringification, '1.as("%d")'

[12:31] <fglock> but 'as(1,"%d")' doesn't work yet

[12:32] <fglock> or you can use 'sprintf("%d",1)', which is pretty standard

[12:33] <fglock> oh, 'as(1:"%d")' works

[12:34] <wolverian> isn't there an infix 'as' operator too?

[12:34] <wolverian> it's in the precedence table, anyway, but I can't find its description :)

[12:36] <Alias_> as is a multi thing

[12:37] <wolverian> hm?

[12:37] <Alias_> it's something weird :)

[12:38] <wolverian> yeah. I have the impression it's not final, either.

[12:39] <wolverian> maybe just because coerce<as> makes no sense whatsoever to me.

[12:39] <Alias_> coercion needs to be graph-based, so you can't do it as a method

[12:40] <wolverian> coercion has disappeared from the synopses..

[12:40] <wolverian> or my grep is broken :)

[12:40] <Alias_> I talked it over with Audrey last week, and it's good

[12:40] <wolverian> it?

[12:40] <Alias_> coercion

[12:40] <Alias_> It will cover all the cases it needs to

[12:41] <Alias_> and do it the right way

[12:41] <wolverian> I'm talking about the syntax. :)

[12:43] <Alias_> the syntax is part of it I guess

[12:44] <wolverian> I don

[12:44] <wolverian> 't see it defined

[12:46] <svnbot6> r8253 | xgl++ | fixed t/pugsbugs/parsing_if.t;

[12:49] <svnbot6> r8254 | xgl++ | fixed t/pugsbugs/parsing_if.t;

[13:16] <svnbot6> r8255 | kane++ |  r499@coke:  kane | 2005-12-15 14:14:40 +0100

[13:16] <svnbot6> r8255 | kane++ |  * fix some pod in Installation.pm

[13:16] <svnbot6> r8255 | kane++ |  * make uninstall() work from pkg::installed->...

[13:16] <svnbot6> r8255 | kane++ |      * this should be moved to installation.pm in due time

[13:16] <svnbot6> r8255 | kane++ |  * fix bug in packlist generation in pkg::source

[13:16] <svnbot6> r8255 | kane++ |  * add basic uninstall tests

[13:22] <stevan__> tewk, audreyt: sorry if I was not clear, the Bootstrap has much hand waving in it :)

[13:33] <stevan__> audreyt++ # := makes things /much/ easier :)

[13:34] <fglock> stevan_: I'm translating the factorial program to p5

[13:34] <stevan__> fglock: cool

[13:34] <stevan__> audreyt: rebinding even seems to work as expected 

[13:35] <stevan__> $x := 3; $y := 5; $x := $x.add($y); $x; gives me 8

[13:35] <stevan__> tewk: please add some tests for rebinding too :)

[13:35] <fglock> bbiab

[13:36] <stevan__> audreyt: I have a small "wish list" for the mini-lang when you have some time

[13:36] <stevan__> if we could load the boostrap as a file, rather than embedding it in the Haskell, that would be good

[13:37] * stevan__ has evil alternate metamodel ideas :) *cough* prototype-based *cough*

[13:37] <stevan__> audreyt: and if we could make bit.and and bit.or more lazy, that would be great

[13:37] <Alias_> DIE DIE DIE!

[13:38] <stevan__> Alias_: is that for me? :)

[13:38] <stevan__> or HEREDOCS

[13:38] <Alias_> both!

[13:38] <stevan__> LOL

[13:38] <Alias_> Buit heredocs first

[13:39] <Alias_> home for me

[13:39] <Alias_> night

[13:39] <stevan__> night Alias_ ... sweet HEREDOC-less dreams

[13:39] <Alias_> I think I killed the last of the heredoc bugs... next up are the nightmares of 100,000 line 500k Perl files

[13:40] <Alias_> Go look at the source for Genezzo::Parser::SQL

[13:40] <Alias_> night

[13:44] <stevan__> audreyt: oh, one last thing.. I need some kind of looping construct

[13:44] <svnbot6> r8256 | stevan++ | PIL.Native.Bootstrap.pil

[13:44] <svnbot6> r8256 | stevan++ | - ::Class.bless now uses the := operator, which desugars into

[13:44] <svnbot6> r8256 | stevan++ |   exactly what was there before (however now it is much more 

[13:44] <svnbot6> r8256 | stevan++ |   readable :)

[13:45] <stevan__> list.apply(->$x { ... }) would be nice

[13:55] <stevan__> some kind of do while would be nice as well :)

[14:01] * stevan__ is off to $work 

[14:03] <pasteling> "avar" at 212.30.222.56 pasted "Fibonacci" (9 lines, 206B) at http://sial.org/pbot/14972

[14:03] <avar> woo;)

[14:04] <avar> I'm doing some algorithm benchmarking on different programming languages

[14:05] <avar> wrote a fibonacci algo in C, it calculated fibo(40) in 22 secs, currently doing php, 15mins and counting;)

[14:05] <xinming> pugs will defeat all by the slowliness. :-P

[14:05] <avar> we'll see;)

[14:07] <avar> would a:

[14:07] <avar> if expr

[14:07] <avar>         block;

[14:08] <avar> syntax have been ambiguous to something else in perl6?

[14:08] <avar> $ time php fibonacci.php 

[14:08] <avar> 165580141

[14:08] <avar> real    22m6.098s

[14:08] <avar> ;)

[14:09] <avar> we'll see about pugs;)

[14:12] <avar> ?eval 1 any(1,2)

[14:12] *** evalbot_8252 is now known as evalbot_8256

[14:12] <evalbot_8256> Error:  unexpected "a" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:13] <avar> ?eval 1 == any(1,2)

[14:13] <evalbot_8256> bool::false 

[14:14] <avar> ?eval 1 == any(1..2)

[14:14] <evalbot_8256> bool::false 

[14:14] <avar> ?eval 1 == 1|2

[14:14] <evalbot_8256> bool::false 

[14:14] <avar> ?eval 1 == (1|2)

[14:14] <evalbot_8256> bool::false 

[14:14] <SamB> your any is strange

[14:15] <avar> that should work, unless I'm missing something

[14:15] <avar> unless $roll == any(1..6) { print "Invalid roll" }

[14:15] <avar>      if $roll == 1|2|3 { print "Low roll" }

[14:15] <avar> from syn03

[14:16] <SamB> strange ways of doing things, you perl users have...

[14:17] <avar> ?eval 1 == 1 or 1 == 2

[14:17] <evalbot_8256> bool::true 

[14:17] <avar> must not be implemented or something

[14:17] <xinming> ?eval 1|2 == 1

[14:17] <evalbot_8256> bool::false 

[14:17] <SamB> in Haskell, I would write "any (==roll) [1..6]"

[14:17] <xinming> hmm, seems like a bug

[14:17] <SamB> ?eval any(1..6)

[14:17] <evalbot_8256> 1 

[14:17] <SamB> ?eval any(1..6)

[14:17] <evalbot_8256> 1 

[14:17] <avar> ?eval ~any(1..6)

[14:17] <evalbot_8256> "1" 

[14:18] <SamB> whats it supposed to do?

[14:18] <SamB> is it nondeterministic?

[14:20] <avar> 1 == any(1..6) is the same as 1 in range(1,6) in python

[14:20] <avar> returns true if a number belongs to the range

[14:20] <avar> or rather, not a range, but any of a given whatever

[14:21] <SamB> hehe.

[14:21] <avar> doesn't have to be a number range

[14:21] <avar> ?eval "foo" eq any("bar", "foo", "zar")

[14:21] <SamB> only 1 in range(1,6) actually returns true

[14:21] <evalbot_8256> bool::false 

[14:21] <avar> yeah, only that

[14:22] <avar> but we have a solution to this issue

[14:22] <avar> ?eval not "foo" eq any("bar", "foo", "zar")

[14:22] <evalbot_8256> bool::false 

[14:22] <avar> ahem

[14:22] <avar> ?eval not ("foo" eq any("bar", "foo", "zar"))

[14:22] <evalbot_8256> bool::false 

[14:22] <avar> ?eval !("foo" eq any("bar", "foo", "zar"))

[14:22] <evalbot_8256> bool::false 

[14:22] <avar> !!!!

[14:22] <avar> ?eval 1

[14:22] <evalbot_8256> 1 

[14:22] <avar> ?eval ?1

[14:22] <evalbot_8256> bool::true 

[14:22] <avar> there!

[14:22] <avar> ;)

[14:27] <xinming> avar: Did Pugs finished calculation? :-)

[14:28] <avar> 14 mins and running

[14:28] <avar> it can defeat php yet

[14:29] <xinming> I know,

[14:31] <xinming> ?eval (1..10000000).sum.say;

[14:31] <evalbot_8256> pugs: out of memory (requested 1048576 bytes) 

[14:33] <avar> ?eval (0..Inf).sum

[14:33] <evalbot_8256> pugs: out of memory (requested 1048576 bytes) 

[14:38] <pasteling> "gaal" at 192.115.25.249 pasted "exp failing" (8 lines, 364B) at http://sial.org/pbot/14973

[14:38] <svnbot6> r8257 | autrijus++ | * by stevan's request, implement three more methods (do_if, do_unless, do_for) for Sub:

[14:38] <svnbot6> r8257 | autrijus++ |     ->$x{$x.add(1)}.do_for(1,2,3,4)

[14:40] <gaal> audreyt: any idea? this doesn't look like an autovivifaction problem, autovivify happens elsewhere for me in similar usage.

[14:43] <avar> xinming: still going at 24min;/

[14:45] <xinming> avar: IMHO, It might go at least 40 min where the result is estimated by the 22 of PHP. :-P

[15:01] <pasteling> "gaal" at 192.115.25.249 pasted "order matters" (11 lines, 420B) at http://sial.org/pbot/14974

[15:01] <gaal> this is weird! in the order nopasted, it works.

[15:01] <gaal> when I switch (1) and (2), it doesn't. I can't figure out why, though.

[15:01] <kane-xs_> itym size matters

[15:01] * kane-xs_ hands gaal an extra few bytes

[15:02] * gaal transmutes kane-xs_'s bytes into words

[15:20] <avar> xinming: 44 mins and running

[15:20] <xinming> ...

[15:20] <xinming> I under-estimated the slowliness of pugs. >_<

[15:38] <pd> xinming, I tried running mops.p6 under pugs, clocked it at about 0.0013087 M op/s

[15:39] <pd> Which is less than 2000x slower than perl5, woo hoo!

[15:41] <xinming> It will be much faster after the perl 6 running on top of parrot. :-)

[15:42] <pd> Yeah, I'd like to know if/when that's the case. I haven't gotten pugs to emit anything that I could run on parrot, but at the moment it seems somewhat verbose.

[16:28] <avar> do modules like Digest::SHA1 work with pugs?

[16:28] <avar> ?eval use Digest::SHA1

[16:28] *** evalbot_8256 is now known as evalbot_8257

[16:28] <evalbot_8257> pugs: *** No such method: "&use"     at <prelude> line 62, column 30-59 

[16:28] <avar> right..

[16:30] <Khisanth> I don't think the evalbot allows that

[16:31] <rafl> Evalbot is restricted, yes.

[16:34] <masak> does anyone know how the p5 'exists $hash{$key}' idiom is written in p6?

[16:34] <gaal> avar: if you want a perl 5 package, you do use perl5:Digest::SHA1 (note one ':' after "perl5")

[16:34] <masak> i find that '%hash.exists($key)' works, but is there another way?

[16:35] <gaal> do find out if a hash key... exists? :-)

[16:37] <gaal> I think the imperative version needs to be a macro, if that's what you mean

[16:55] <masak> gaal: ...and we don't have macros yet, hence i have to write it as a method call, correct?

[16:57] <gaal> for now, yes

[16:57] <wolverian> I dislike the macro version 

[16:57] <wolverian> (the perl5 version)

[17:00] <svnbot6> r8258 | masak++ | changed tests because we don't have macro version of hash &exist yet

[17:03] <svnbot6> r8259 | kane++ |  r503@coke:  kane | 2005-12-15 15:09:06 +0100

[17:03] <svnbot6> r8259 | kane++ |  * move uninstall code to Installation->unregister

[17:03] <svnbot6> r8259 | kane++ |  * split out removing alternatives and available objects to seperate methods

[17:03] <svnbot6> r8259 | kane++ |      * linking is next

[17:06] <svnbot6> r8260 | kane++ |  r504@coke:  kane | 2005-12-15 16:21:34 +0100

[17:06] <svnbot6> r8260 | kane++ |  * abstract the linking code out to a sub in Installation.pm

[17:06] <svnbot6> r8260 | kane++ |  * remove pkg::installed->uninstall and make it point to Installation->unregister

[17:06] <svnbot6> r8260 | kane++ |  * remove a few uses of File::Spec in favour of path::class

[17:06] <svnbot6> r8261 | kane++ |  r505@coke:  kane | 2005-12-15 17:59:07 +0100

[17:06] <svnbot6> r8261 | kane++ |  * note we need more tests :)

[17:07] <rafl> kane-xs_: My work is done for this month. JIB hacking can continue :-)

[17:07] <kane-xs_> hooray!

[17:07] <rafl> kane-xs_: I think I'll start with writing Repo tests.. ;-)

[17:07] <kane-xs_> rafl: i've been hacking away wildly

[17:07] <kane-xs_> yes, tests good

[17:07] <kane-xs_> repo may be broken now, there were no tests to check :(

[17:08] <rafl> Why should it be broken now?

[17:08] <rafl> It seems to work for me.

[17:08] <r0nny> yi

[17:09] <rafl> Hello r0nny 

[17:09] <kane-xs_> i changed the way config works for example

[17:09] <kane-xs_> quite dramatically even

[17:09] <kane-xs_> although hte api shoudl be *mostly* the same.. unless you were catting paths together

[17:09] <kane-xs_> anyway, i didn't say it /was/ broken, just that it could be, as there were no tests :)

[17:10] <rafl> Does stuff like SUBDIR_OF_ROOT belong to the config?

[17:11] <rafl> Oh, yes. It does.

[17:12] <rafl> JIB::Config looks funny now. :-)

[17:12] <kane-xs_> yeah.. but it wokrs like a charm

[17:13] <rafl> THe only thing that looks wrong is that $r = JIB::Repository->new(root => "foo"); $r->create; $r->add_files("t/src/p5-Foo-Bar-1.2-cpan+KANE.jib");' creates a 'fr' directory.

[17:13] <kane-xs_> yeah.. the 'root' dir is 'fr' in teh config.. i set it to 'fakeroot' explicitly in the tests

[17:14] <kane-xs_> it should be '/' ultimately of course

[17:14] <kane-xs_> but with so much prototype code, that makes me nervous

[17:15] <rafl> When is it created?

[17:15] <kane-xs_> it's created in t/inc/conf.pl

[17:15] <kane-xs_> which is included in a few tests

[17:16] <rafl> But it's not created when running tests but when executing the above code to create a repo and add a jib to it.

[17:16] <kane-xs_> then your repo code creates it

[17:18] <gaal> audreyt: d'you think you'll be here about 12 hours from now?

[17:18] <kane-xs_>         $dir->mkpath() or error($!), return;

[17:18] <kane-xs_> so yeah, its' your repo code rafl

[17:19] <kane-xs_> rafl: just include conf.pl in your tests and All Will Be Well (tm)

[17:19] <kane-xs_> just copy the relevant chunk from say, 020.t

[17:21] <rafl> It should not do that. $config->root is not in @dirs, afaik.

[17:22] <kane-xs_>     my @dirs = (

[17:22] <kane-xs_>             $self->root,

[17:22] <kane-xs_> so i'd say it is

[17:22] <rafl> $self->root, not $self->config->root

[17:23] <kane-xs_> ok.. i don't know -- add tests, we'll see :)

[17:23] * kane-xs_ home now -- back later

[17:23] <rafl> Well, I blame JIB::Pkg. :-)

[17:25] <pasteling> "fglock" at 200.17.89.80 pasted "p5 version of: (-> $n {-> &f { $n.eq(0).cond( ->{1}, ->{$n.multiply(&f.($n.subtract(1)))}) }.(&?SUB)}).(10)" (29 lines, 758B) at http://sial.org/pbot/14975

[17:26] <fglock> stevan: I can't make it work - there may be a problem with the number of parameters to &f ?

[17:32] <fglock> I picked the code from t/pil/simple.t

[17:39] <tewk> fglock: what generated that code?

[17:43] <fglock> tewk: you mean the p5 code? it was hand written

[17:44] <tewk> stevan: $a := 5  should return nil right.

[17:44] <stevan> tewk: yes IMO at least

[17:44] <fglock> stevan: please see http://sial.org/pbot/14975

[17:50] <fglock> the factorial in r8195 log is different - I will try that

[17:50] <svnbot6> r8262 | tewk++ | PIL rebinding test

[17:51] <fglock> tewk: I'm writing p5 code by hand first, then I'll try to write a generator

[17:52] <stevan> fglock: my factorial doenst use the $?SUB

[17:54] <fglock> stevan: so I'm using the wrong one. Is this correct? http://colabti.de/irclogger/irclogger_log/perl6?date=2005-12-13,Tue&sel=168#l246

[17:56] <tewk> the simple.t factorial was a audreyt example I believe

[17:56] <stevan> fglock: this one (http://use.perl.org/~stevan/journal) is the one I have messed with

[17:56] <stevan> and then what tewk said :)

[17:56] <stevan> both work

[17:56] <stevan> $?SUB is magical though,.. so it means you have to write more stuff to deal with it

[17:56] <stevan> the one in my journal doesnt use $?SUB

[17:58] <fglock> ok - I'll try with the journal version

[18:08] <svnbot6> r8263 | tewk++ | wanted_features.t

[18:08] <svnbot6> r8263 | tewk++ |  - Test Driven Development :)

[18:08] <svnbot6> r8263 | tewk++ | t/pil/bindings.t 

[18:08] <svnbot6> r8263 | tewk++ |  - stevan's rebinding test

[18:08] <tewk> stevan: take a look at r8263

[18:11] <tewk> opps, wanted_features.t needs a little refactoring to make it lambda friendly

[18:11] <tewk> my imperative mind took control

[18:17] <stevan> tewk++ # doing all the things I dont currenly have the tuits to do :)

[18:18] <stevan> tewk: i will take a look when I can,.. I am currently putting out @fires for $work 

[18:18] <tewk> stevan: understood

[18:30] <tewk> hmmm if we have list.apply (map), do we need dowhile and loop?  generic loops are hard to write in lambda because they often involve accumulators.

[18:31] <tewk> maybe what we need is map, fold, zip which are special purpose looping structures.

[18:33] <stevan> tewk: I have a do_while for the block type in the ObjectSpace prototype, not sure if it would have the correct level or purity though

[18:34] <tewk> file, line number?

[18:39] <stevan> perl5/Perl6-ObjectSpace/lib/Perl6/Core/Block.pm

[18:40] <stevan> tewk: I also hacked this together this morning ... (wait for the nopaste bot)

[18:41] <tewk> no problem

[18:41] <pasteling> "stevan" at 69.3.245.254 pasted "Looping with the min-lang" (13 lines, 248B) at http://sial.org/pbot/14978

[18:41] <stevan> its a hack for sure,.. but its a start maybe

[18:41] <stevan> I think we need list-style macros in our mini-lang

[18:43] <stevan> macro infix<:=> ($lhs, $rhs) { -> $lhs { $rhs } }

[18:44] <stevan> simplistic yes, but something likethat would be nice :)

[18:49] <pasteling> "fglock" at 200.17.89.80 pasted "2nd try: minilang->p5 factorial" (50 lines, 1.3K) at http://sial.org/pbot/14979

[18:50] <fglock> this version doesn't work yet, but it prints a trace that can help find the bug

[18:53] <fglock> fixed! I'll post in a sec

[18:56] <pasteling> "fglock" at 200.17.89.80 pasted "working minilang->p5 factorial example" (48 lines, 1.3K) at http://sial.org/pbot/14980

[18:57] <fglock> stevan: does this make sense as a possible p5 implementation?

[18:59] <stevan> fglock: yes

[19:03] <stevan> fglock: I am not sure all the mini-lang stuff will be translatable to pure perl without issue

[19:03] <stevan> it might make sense to make a p5 impl of the underlying mini-lang objects

[19:06] <fglock> stevan: ok

[19:06] <fglock> I hope the minilang don't get too complex :)

[19:06] <tewk> stevan: right so what does f do, usually a recursive function passes some state along to itself as a parameter( the accumulator ).  the state can be a list.

[19:08] <stevan> fglock: it won't, I promise :)

[19:08] <fglock> I'm trying to find out why I need '->()' in the end of the sentence '$fun_f->( $fun_f, $var_n )->()' - this looks like an error. The minilang version doesn't need it.

[19:08] <fglock> stevan: :)

[19:08] <tewk> What I just described is called fold in lisp. Which can be extended to take integers as additional accumulators which gives you do_wuile, for

[19:08] <stevan> tewk: which f are you speaking of?

[19:09] <tewk> &f.($x, &f, &c) this one.

[19:09] <stevan> tewk: that is the body of the function 

[19:10] <stevan> fixed point combinator stuff

[19:10] <stevan> if you dont have named functions (which we dont), then you cannot have a recursive func

[19:10] <stevan> cause you cannot call it by name

[19:10] <stevan> so you have to pass it as an arg to itself,.. call-by-value,... then you can recurse

[19:11] <tewk> Right I get it.

[19:11] <tewk> So is &f defined in the mini-language or in Perl6

[19:11] <stevan> fglock: you need to do that extra ->() to keep things lazy

[19:13] <fglock> stevan: the minilang dereferences functions automatically?

[19:14] <stevan> hmm

[19:14] <stevan> wait,.. nevermind,.. lemme look again

[19:15] <fglock> bbiab

[19:20] <stevan> fglock: your cond() needs to eval the subs 

[19:20] <stevan> $_[0] ? $_[1]->() : $_[2]->()

[19:20] <stevan> that should aleviate the need for the extra ->()

[19:22] <tewk> stevan: doesn't binding := in a way give you named functions?, I know it gets desugared underneath, but what is different between := and (define) in scheme?

[19:23] <tewk> If &f is in perl6 that operates on an environment, It makes sense.

[19:24] <tewk> If &f is mini-lang defined (pure) it can only return a value.  Without additional state it is useless.

[19:25] <stevan> tewk: binding gives us named functions, but I am not sure they will work for recursion, it becomes a scoping issues at that point

[19:26] <stevan> tewk: I am not sure I understand the your point re: &f in mini-lang terms

[19:26] <stevan> with the pure approach you need to carry around the environment explicity 

[19:27] <stevan> you'd be suprised what you do with *just* functions :)

[19:29] <tewk> I'll put together a paste.

[19:29] <stevan> tewk: see (http://search.cpan.org/src/STEVAN/fp-0.03/lib/fp/lambda.pm) ,.. scroll down to the list implementation :)

[19:33] <xinming> why there will be Chinese Characters? *_*

[19:33] <stevan> xinming: ??

[19:33] <xinming> oops. sorry for the wrong encoding of the browser. :-/

[19:34] <xinming> λ in GB2312 encoding is a Chinese character. :-)

[19:34] <stevan> ah

[19:34] <stevan> :)

[19:34] <stevan> utf-8 :)

[19:35] <xinming> by the way, what's that exactly?

[19:36] <stevan> xinming: it is pure lambda calculus in perl 5

[19:36] <stevan> just for fun mostly :)

[19:40] * xinming is using m4 to make a cgi. :-P

[19:40] <xinming> the same reason

[19:45] <tewk> "you'd be suprised what you do with *just* functions",  yeah I understand pure lambda calculus.

[19:45] <stevan> tewk: :)

[19:46] <tewk> Well, this (named functions) seems to work even if it's not suppose to: $a := (-> $x { ($x.eq(0)).cond( ->{"Done"}, ->{$a.($x.subtract(1))}) }) ; $a.(10000)

[19:46] <stevan> tewk: nice :)

[19:47] <stevan> what does it parse as?

[19:48] <fglock> stevan: thanks - it works after fixing cond()

[19:48] <stevan> fglock: nice :)

[19:51] <tewk> 12:50 tewk@flaka:~/srcs/pugs]$ ./pil -p '$a := (-> $x { ($x.eq(0)).cond( ->{"Done"}, ->{$a.($x.subtract(1))}) }) ; $a.(10000)'

[19:51] <tewk> (-> $a {$a.(10000)}).(-> $x

[19:51] <tewk>                         {$x.eq(0).cond(-> {"Done"}, -> {$a.($x.subtract(1))})})

[19:52] <kane_> wow.. you wrote lisp!

[19:52] <stevan> tewk: yea that is strange

[19:52] <stevan> I didnt think that would work

[19:54] <tewk> kane_: pad  "Greenspun's Tenth Rule of Programming: any sufficiently complicated C or Fortran program contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp."

[19:54] * stevan makes a note to ask audreyt about scoping

[19:54] <tewk> - Philip Greenspun

[19:54] <tewk> s/C or Fortran/Perl :)

[19:54] <stevan> tewk: maybe the scopes are execution scope, instead of lexical scope

[19:56] <stevan> tewk: are you going to school for CS? 

[19:57] <tewk> I've graduated once, I'm finishing a masters thesis right now.

[19:58] <stevan> tewk: of course you thesis is on Pugs right :)

[19:59] <tewk> I wish, my masters thesis is XQuery natively embedded in scheme, I would love to do some phd work with pugs/perl6.

[19:59] <PerlJam> tewk: ick.

[20:00] <stevan> PerlJam: ick on the PHd or ick on Pugs :)

[20:01] <stevan> tewk: where are you going to uni?

[20:01] <tewk> That was my question?

[20:01] <tewk> BYU Phil Windley is my advisor.  www.windley.com.  That's my only tie to fame in the IT/geek world.

[20:02] <PerlJam> stevan: ick on XQuery embedded in Scheme.

[20:02] <stevan> ah

[20:02] <tewk> He is a pretty well know name. 

[20:02] <stevan> I second that one :)

[20:03] * stevan lunch has arrived ,.. yummy Pork in Garlic Sauce :)

[20:03] <tewk> Well as an aspiring lambda head, XQuery was designed by Phil Wader(one of the principle minds behind Haskell), so it is functional of course.

[20:03] * stevan eating &

[20:03] <stevan> tewk: XSL is a functional language too ;)

[20:04] <stevan> with a really really really ugly syntax 

[20:04] <tewk> Scheme has sexprs and Perl6 isn't finished, thats why I choose Scheme.

[20:05] <tewk> I'd like to graduate before Perl6 releases :)

[20:05] <tewk> but you could replace scheme with Haskell or Perl6

[20:06] <tewk> stevan: amen, XSL is very very nasty,  XQuery is not usually written in XML.

[20:06] <tewk> So the idea is to take XQuery semantics and put them in scheme as sexprs.

[20:07] <tewk> No more quoted query strings, SQL syntax, etc in code.

[20:07] <tewk> Microsoft "stole" my idea and with XLINQ in C# 3.0

[20:07] <tewk> :)

[20:09] <PerlJam> tewk: I'd rather see something in haskell than scheme.

[20:09] <pd> speaking of XML, XSL, and shorthand for them, there's also pxsl: http://community.moertel.com/ss/space/pxsl

[20:09] <PerlJam> tewk: or even perl6 (it doesn't matter that it's not finished)

[20:09] <pd> it looks more like something a python fan would love

[20:10] <PerlJam> pd: it does evoke a pythonesque mood

[20:12] <tewk> PerlJam: given infinite time I would have liked to do haskell or perl6, but graduation is alot like business.  You adopt some necessary evils to graduate :)

[20:12] <PerlJam> tewk++ good luck on that graduation thing :)

[20:13] <tewk> Well I've mentioned scheme, C#, and have been labeled as a pythonic.

[20:13] * tewk fears for his life :)

[20:13] <PerlJam> tewk: people who inhabit the true spirit of perl are language agnostic.

[20:14] * PerlJam wanders off to do some work

[20:15] <tewk> Thanks

[20:15] <tewk> I agree.

[20:17] <SamB> how can *people* be language-agnostic?

[20:44] <_fallen-> are hare somebody who worked with PARROT? =)))

[20:44] <obra> There are some. What's your question?

[20:45] <_fallen-> i need your opinion

[20:45] <_fallen-> about it

[20:45] * pd breaks out his magic 8 ball

[20:45] <integral> The blue definately looks better

[20:46] <pd> _fallen-, parrot is nifty. Anything in particular you want to do with it?

[20:46] <_fallen-> pd maybe =)

[20:46] <pd> Then maybe it'd work out. :)

[20:47] <_fallen-> lol

[20:50] <pd> Anyhow. My opinion is that parrot is fun to play with and hack on, but it can be a bit of a moving target, and thus you'd want to pay attention to the list and the (working) example code out there to see how things are done.

[20:51] <pd> For example, partcl, the (partial) Tcl implementation in parrot--it's generally kept up to date.

[20:53] *** mugwump_ is now known as mugwump

[21:14] <stevan> nothingmuch: ping

[21:15] * nothingmuch ducks

[21:16] <stevan> nothingmuch: can we talk on IM?

[21:16] <nothingmuch> sure

[21:16] <stevan> sign on please :)

[21:22] <kolibrie> so, I've been missing in action for a while (3rd child was born)

[21:22] <kolibrie> I notice that autrijus is now audreyt?

[21:24] <stevan> kolibrie: yes

[21:24] <kolibrie> stevan: reasoning?

[21:25] <stevan> he has promised a journal to explain

[21:26] <kolibrie> I looked for a journal entry with explanation... they do seem sparse of late

[21:27] <obra> Give it a bit of time. Audrey has been travelling and is now crunching on a customer project

[21:28] <stevan> he is still the same a(trijus|udreyt) as far as I am concerned, it just means my fingers need to adjust a bit :)

[21:28] <stevan> I mean no one seems to care that I am really a dog

[21:28] * stevan *woofs*

[21:29] <kolibrie> no hurries, the last journal suggested "brief pause"

[21:29] <obra> It's the internet. Your canineness is not an issue. This is well-established.

[21:30] <stevan> :)

[21:30] <kolibrie> stevan: no change for me, just type au-TAB

[21:30] * stevan wags his tail

[21:30] <stevan> kolibrie: that is how I see it too :)

[21:31] <pd> that's fortunate--I never could spell autrijus.

[21:31] <stevan> although my fingers were trained to aut-TAB because of autark-jp

[21:31] <kolibrie> yes

[21:32] <kolibrie> and I could almost pronounce autrijus, I think

[21:32] <kolibrie> all that time spent practicing

[21:41] <dduncan> I just looked up Perl 6 on Wikipedia for the first time ( http://en.wikipedia.org/wiki/Perl6 ), and noticed that some details are out of date, so I'm going to go and update them over the next few minutes

[21:42] <dduncan> put some use to the account I got there a few days ago

[21:43] <kolibrie> dduncan++ # keeping Wikipedia up-to-date

[21:45] <dduncan> I'll post a note here after I made the changes ... until then, assume I didn't do them yet

[22:15] *** evalbot_8257 is now known as evalbot_8263

[22:27] <dduncan> okay, today's set of changes are made ... http://en.wikipedia.org/wiki/Perl_6 ... diff history for exactly what I did

[23:14] <luqui> dduncan, you know that =<> is still valid, right?

[23:15] <luqui> the "fish operator"?

[23:15] <dduncan> perhaps, but I figured that =$*IN was more self documenting

[23:15] <dduncan> and hence put Perl 6 in a better light

[23:16] <dduncan> that's why I changed that one

[23:16] <luqui> I suppose

[23:16] <luqui> except that the semantics are not equivalent

[23:16] <dduncan> the main "correction" I made was actually the argument syntax, with the ? and : etc

[23:16] <luqui> right

[23:16] <luqui> =<> will read from files in @ARGS, $*IN won't.

[23:17] <dduncan> I also split up the paragraph on parrot at the top, since it looked confusing to have pugs info mixed in

[23:17] <luqui> yeah, I agree with that one for sure

[23:17] <dduncan> is that the same as perl 5?

[23:17] <dduncan> in perl 5, <> was stdin, I think

[23:17] <luqui> yep

[23:17] <luqui> oh, no

[23:17] <luqui> <> is the ARGV handle

[23:17] <dduncan> well, the example was showing a perl 5 equivalent, right

[23:17] <luqui> which defaults to STDIN when there are no command line arguments

[23:18] <dduncan> so what do people use more?

[23:18] <dduncan> personally, I used STDIN in perl 5 when I meant that

[23:18] <PerlJam> I wonder if =<> will be any different from ='' 

[23:18] <luqui> while (<>) is the convention for scripts, because you can pipe to them or specify files on the command line

[23:19] <luqui> PerlJam, I think we disallow the latter

[23:19] <PerlJam> luqui: why?

[23:19] <luqui> er, no, that probably just reads from the empty file

[23:19] <luqui> which probably doesn't exist

[23:19] <PerlJam> luqui: The <> in =<> are just funny looking quotes

[23:19] <luqui> they are funny looking *brackets*

[23:19] <luqui> <> is equivalent to []

[23:19] <luqui> er, rather, ()

[23:20] <PerlJam> er, what?

[23:20] <luqui> <foo bar baz> is equivalent to ("foo", "bar", "baz")

[23:20] <PerlJam> %hash<foo>  doesn't look at all like %hash('foo')

[23:20] <luqui> it's a subscripter there

[23:20] <luqui> in any case, they construct lists, not strings

[23:20] <luqui> (lists of strings)

[23:21] <PerlJam> Then what's <<foo bar baz>>

[23:21] <PerlJam> ?

[23:21] <luqui> the same things, except that it interpolates

[23:21] <luqui> <> is to '' as <<>> is to ""

[23:21] <luqui> double them to get interpolation :-)

[23:21] <PerlJam> oh right.

[23:21] * PerlJam continues to think it was wise that he stopped playing with perl6 so much.

[23:21] <luqui> heh

[23:21] <Qiang> my Point $point .= new;  is it equal to my Point $point = new  Point ?

[23:22] <luqui> Qiang, pretty much

[23:22] * Qiang reading the wikipedia page

[23:22] <PerlJam> Don't you need the : for IO notation?

[23:22] <Qiang> hm. is that necessary... who want that ;-)

[23:22] <luqui> if there were arguments

[23:22] <PerlJam> oh that's right.

[23:23] <luqui> though I'd say Point.new

[23:23] <luqui> just in case somebody put a "new" listop in my scope

[23:23] <luqui> Qiang, what do you mean who would want that?

[23:23] <luqui> Haven't you seen all that java code

[23:23] <Qiang> the .= new part. 

[23:23] <svnbot6> r8264 | clkao++ | Add necessary bits for smoking jsperl5

[23:23] <PerlJam> Qiang: I'd rather not be required to type the class name twice thank you.

[23:23] <luqui> ReadButNotWriteStringBuffer x = new ReadButNotWriteStringBuffer ()

[23:24] <Qiang> fair enough.

[23:25] <Qiang> i haven't done any java since graduated from university. :-)

[23:25] <PerlJam> Qiang: good for you!

[23:25] <Qiang> i like the @array[1] in perl6. indeed better than $array[1]

[23:26] <Qiang> PerlJam: :)  i think our dev team is going for Perl. that's even better news

[23:26] <luqui> yum

[23:26] <PerlJam> I haven't done any perl6 since I realized that it was affecting my ability to write perl5  (I kept wishing for features that weren't there :)

[23:26] <luqui> PerlJam, write modules!!

[23:26] <Qiang> heh.

[23:27] <luqui> but I know what you mean

[23:27] <luqui> I was thinking in coroutines when I was designing Logic.pm in my head

[23:27] <luqui> and then I realized that I couldn't have them :-(

[23:27] <PerlJam> luqui: Aren't you helping Pm with the perl6 compiler?  :)

[23:28] <luqui> not anymore.  I mean, yeah, but no

[23:28] <luqui> I have dibs on writing perl 6 in perl 6

[23:28] <luqui> (whatever "dibs" means in an open source project ;-)

[23:28] <luqui> But recently we've been coming up with the machinery to make that possible

[23:29] * PerlJam just wants the path from here to a working parrot-enabled perl6 compiler to be short

[23:29] <PerlJam> shorter

[23:29] <luqui> see, the thing is, they want to write the perl 6 compiler in PIR

[23:29] <integral> isn't the machinery to just write a grammar for perl6 already in place?

[23:29] <luqui> that's when I bailed

[23:29] <luqui> integral, to *parse* it, yes

[23:29] <PerlJam> I still have a perpetual "It'll be here in about 2 years" in my head.  Only 2 years keeps getting farther out.

[23:30] <integral> so can't someone take that forward, which other people faff around with the other bits of the spec?

[23:30] <integral> surely it all doesn't need to be there at once

[23:30] <luqui> but perl 6 still sucks at complex data structure processing

[23:30] <integral> especially since pugs can run code, it doesn't matter if the real parser can only parse

[23:30] <luqui> integral, that's true

[23:30] <integral> but?

[23:30] <luqui> I haven't been available since that happened

[23:31] <luqui> school and whatnot

[23:31] <luqui> before this semester started, PGE was in no state to parse perl 6

[23:31] <PerlJam> yeah, there's always "real life" getting in the way :)

[23:31] <luqui> but now it is ;-)

[23:31] <integral> hmm, did anyone try to write any grammar in the past?   I seem to remember some people trying to write some example bits of perl6 code at one point

[23:31] <luqui> yeah, I wrote a skeleton, and then pm & co. filled it out

[23:32] * buu pokes integral 

[23:32] <integral> buu?

[23:32] * luqui says "ow" on behalf of integral 

[23:32] <buu> integral: #perl

[23:32] <PerlJam> luqui: now that the semester is over, you should have lots of free time  ;-)

[23:32] <audreyt> for some definition of "fill it out"... 

[23:32] <luqui> until it starts again

[23:32] <audreyt> luqui: are you talking about http://svn.perl.org/perl6/grammar/trunk/Grammar.perl6  ?

[23:32] <luqui> but I hope to get some good work done over the break

[23:32] <luqui> audreyt, I think so

[23:32] <luqui> yeah

[23:32] <luqui> it flopped

[23:33] <audreyt> it's missing 95% or so of constructs :/

[23:33] <PerlJam> luqui: It didn't flop ... it just needs a shepherd

[23:33] <luqui> It needs to be able to be run is what it needs

[23:33] <integral> hmm, is there enough in PGE to feed that into it?

[23:33] <audreyt> integral: yes, including the precedence parser

[23:33] <audreyt> integral: it's memory efficiency is not great at all, but should run

[23:34] <luqui> It's very hard to write a grammar without seeing if it works as you go

[23:34] <luqui> especially one as big as perl 6's

[23:34] <integral> but isn't all the details like backtracking, and non-ambiguity in the specs?

[23:34] <luqui> but it's still software

[23:34] <integral> maybe the syntax needs to be simplified then?

[23:34] <PerlJam> Well, we have enough bootstraps, we just need someone hoist one of them into the "real" perl6 compiler.

[23:35] <luqui> you could write it and prove that it's correct, but we hackers prefer to try it out

[23:35] <luqui> PerlJam, how many bootstraps do we have?

[23:35] <audreyt> integral: I think it's been, a lot... the grammatical categories are there to simplify stuff

[23:35] <luqui> I suppose one is enough...

[23:35] <dduncan> luqui, so does that conversation mean that I actually did fix a bug, since <> is a string quote and not a filehandle?

[23:35] <audreyt> integral: otoh Grammar.perl6 was written long before the categories are figured out (for that matter, so is Pugs.Parser), so it looks messy

[23:35] <luqui> dduncan, no

[23:36] <luqui> =<> is "reading from the empty list"

[23:36] <luqui> which is magic

[23:36] <dduncan> then the other question is, should I change it back, or is the current one fine?

[23:36] <luqui> well, you should change it back if you want to be equivalent to that perl 5

[23:36] <luqui> but if you want to show how there's no magic, it's probably best to keep it

[23:36] <luqui> (but change the perl 5)

[23:36] <PerlJam> luqui: I was kinda hoping that one of the lambda camels who was well versed in haskell could start a competing implementation to PGE using Parsec since pugs seems to be the most promising as far as getting things done.

[23:37] <luqui> I was kinda hoping that one of the lambdacamels would port PGE to perl 6

[23:37] <PerlJam> or that

[23:37] <audreyt> it'd be easier if PGE has pseudocode comments explaining what it does :)

[23:37] <integral> isn't haskell a better language than perl6 for writing a grammar engine in though?

[23:37] <luqui> I was actually hoping that I'd do a lot of this stuff, but my brain doesn't seem to have that style

[23:37] <luqui> integral, certainly

[23:37] <luqui> but it's written in haskell

[23:38] <PerlJam> audreyt: sounds like someone should prod Pm in that direction then.  :)

[23:38] <luqui> so then you'd have to write one in perl 5, and you'd have to write one in javascript

[23:38] <luqui> if you write it in perl 6, then you get it everywhere

[23:38] <luqui> even if it's slow

[23:38] <audreyt> integral: also perl6 makes more accessible pseudocode s:)

[23:38] <luqui> audreyt, true

[23:39] <integral> why can't we have haskell and perl6 frontends to the perl6 compiler?  why does perl6 need to do everything?

[23:39] <PerlJam> integral: it's got all of the nifty rules semantis

[23:39] <PerlJam> er, semantics

[23:39] <audreyt> integral: I think it's for the same reason that GHC did away with Perl5 in most places (other than the evil mangler) :)

[23:39] <luqui> because of the JS and perl 5 backends!

[23:40] <audreyt> and those, too

[23:40] <luqui> you can have both a haskell and a perl 6 frontend

[23:40] <luqui> but then you have to maintain two things

[23:40] <integral> luqui: eh?  you're saying that you can compile perl6 to JS, but you can't compile haskell to JS?

[23:40] <luqui> I'm saying that you need a perl 6 compiler written in perl 6 if you want "eval" in JS

[23:40] * PerlJam home &

[23:40] <integral> but if you put enough machinery in perl6 to be able to do the things you can do easily with haskell, also easily in perl6, you've got just as much there

[23:41] <luqui> ?

[23:41] <integral> it's not easier to implement two simple languages, than one complex language?

[23:41] <luqui> I don't follow

[23:41] <integral> anyway, too argumentative, and off-track

[23:41] <luqui> no, please explain

[23:42] <integral> I was thinking of attribute grammars and rules.  Both of those are modules that implement their own DSLs

[23:42] <luqui> DSL?

[23:42] <audreyt> domain-specific language

[23:42] <integral> domain specific language

[23:42] <luqui> ahh

[23:42] <integral> but they integrate into the perl6 syntax somewhat (at least rules do)

[23:42] <clkao> audreyt

[23:42] * audreyt goes finding some breakfast and leave it to integral  :)

[23:42] <integral> but people have been trying to add type infering to perl6

[23:43] <integral> rather than taking something like haskell or ML which does that well, and integrating it as a sub-language into perl6

[23:43] <luqui> uh

[23:43] <luqui> what?  you're saying that if you want type inference in perl 6, you should write in haskell?

[23:43] <integral> yes.

[23:44] <integral> but it doesn't need to have haskell's syntax obviously.

[23:44] <luqui> oh, like audreyt's "pure functional subset" idea?

[23:44] <integral> yes, exactly

[23:45] <integral> you could use "fun" rather than "sub" to declare you sub for example, and get different semantics in it

[23:45] <luqui> okay, so what does that buy us?

[23:45] <integral> it's simpler.

[23:45] <luqui> it's simpler to implement

[23:46] <integral> easier to document, easier to implement, easier to teach to people, easier to check that it's working right, without all the tiny little corner cases perl5 has

[23:46] <luqui> harder to program in

[23:46] <luqui> I argue

[23:46] <luqui> harder to build standard libraries for

[23:46] <integral> why?

[23:46] <luqui> if you want to be pure functional and have side effects

[23:46] <luqui> you need monads

[23:46] <pasteling> "clkao" at 82.35.81.242 pasted "system jsperl5" (9 lines, 279B) at http://sial.org/pbot/14988

[23:46] <pd> 'fun' -- is that the keyword that haskell uses for function calls? Don't mind me.

[23:46] <integral> pd: ML :)

[23:46] <clkao> ./runjs.pl --run=jspm --perl5 -e 'system("echo 1")'Syntax error: word unexpected (expecting ")")

[23:46] <integral> luqui: sure

[23:47] <clkao> looks weird.. expecting ')' ??

[23:47] <luqui> so then you have monadic versions of a lot of the builtins that are there in the regular dialect

[23:47] <pd> aha, I somehow managed to not learn ML either. They taught us scheme instead. :)

[23:47] <luqui> the point is, we want perl 6 to be a language

[23:47] <luqui> not fifty languages that are very loosely connected

[23:48] <luqui> perl 6 has sublanguages

[23:48] <luqui> hmmm..

[23:48] <luqui> where am I going with this

[23:48] <integral> I don't understand why you think this "monad" thing require separate builtins

[23:48] <luqui> well you have the "say" that's a function and returns a monad

[23:48] <luqui> and you have the "say" that's a procedure, outputs to the screen, and returns nothing

[23:48] <luqui> you can't unify those

[23:49] <luqui> because of:

[23:49] <luqui> my $x = say 4;

[23:49] <luqui> in regular code means to print "4" to the screen and put "1" in $x

[23:49] <luqui> whereas in functional code it means to put a monad representing the action of putting "4" on the screen in $x

[23:50] <integral> oh, you want "say 4" to return a monad.

[23:50] <dduncan> okay, luqui, I replaced the magical <> with non-magical <STDIN>, which is more easily understood and matches the perl 6 =$*IN

[23:50] <luqui> integral, you have to if you are pure functional

[23:50] <luqui> dduncan, kay, cool

[23:50] <dduncan> thanks for pointing this out

[23:51] <integral> my $x = unsafe { say 4 }; # you could require explict unsafes, but that's sort of unsafe

[23:51] <dduncan> okay, so I'm off to town in a few minutes

[23:51] <luqui> integral, and then inside the unsafe you go back to regular side-effecty perl?

[23:51] <integral> yes.

[23:52] <luqui> why would anyone use the pure functional dialect then?

[23:52] <integral> I feel it's a wee bit like currying in perl5: sub { func($a, @_) }

[23:52] <integral> well, when you're *not* dealing with the IO monad!

[23:52] <integral> the same as in haskell really.

[23:52] <pd> yeah, perl5 does closures

[23:52] <svnbot6> r8265 | clkao++ | non-working system() in jsperl5.

[23:53] <integral> if you're writing code that's all in the IO monad, you do not use the functional sublanguage

[23:53] <luqui> integral, and you'd lose type inference in regular perl?

[23:53] <luqui> okay, let's back up, we're still talking about inference, right?

[23:53] <integral> you'd lose the very strict type infering and checking, yes.

[23:53] <integral> luqui: a bit, yes

[23:53] <luqui> adding inference to all of perl is not the problem

[23:54] <luqui> perl 6, despite being huge, still has a small core calculus

[23:54] <luqui> the problem is the type system it uses, which hasn't been defined yet

[23:54] <luqui> but it has subtyping

[23:54] <luqui> and haskell has no subtyping, which allows it to be good at inference

[23:54] <integral> how can you say inference isn't a problem, when you don't know what it's infering?

[23:55] <luqui> I don't follow?

[23:56] <integral> well, in Hindley-Milner you don't need any annotation, because your types are first-order and all that.  But when you add GHC's extensions, you sometimes need annotations.   So if you add all these extensions: subtyping, and the other things that haven't been defined, it can vastly change how much can be inferred

[23:56] <luqui> I kno

[23:56] <luqui> w

[23:56] <luqui> I don't see how a functional sublanguage helps

[23:56] <luqui> the functional sublanguage still has to handle subtyping

[23:56] <luqui> because perl's object system is based on subtyping

[23:57] <integral> hmm, did you see the paper a while ago from SPJ&co on mapping C# classes and interfaces into haskell typeclasses?

[23:57] <luqui> nope

[23:57] * luqui looks

[23:58] <luqui> still, afaik, haskell can't do covariant subtyping

[23:58] <luqui> that is, no existential types

[23:59] <luqui> you can simulate subtyping as you're passing arguments into a function

[23:59] <luqui> but not as you're getting them back out

[23:59] <integral> hmm

[23:59] <luqui> er, getting results out

