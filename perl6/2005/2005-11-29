[04:49] <cognominal_> ?eval "" ~~  rx ( qw( a b ) )

[06:03] <svnbot6> r8015 | Darren_Duncan++ |  r977@Darren-Duncans-Computer:  darrenduncan | 2005-11-28 22:01:50 -0800

[06:03] <svnbot6> r8015 | Darren_Duncan++ |  /ext/Rosetta-Incubator : added new file /docs/Plan which gives a roadmap for when different pieces will be made, and implementation detail for some

[06:13] <dduncan> Now committed /docs/Plan to both Rosetta repositories; as with /docs/Overview, any feedback is appreciated.

[06:42] *** autrijus_ is now known as autrijus

[06:44] <autrijus> ?eval "vanilla for now until someone revives version-specif one"

[06:44] <evalbot6> "vanilla for now until someone revives version-specif one" 

[06:52] * gaal meows

[06:52] <gaal> what had happened to it?

[06:53] <dduncan> I like cats myself

[08:15] <svnbot6> r8016 | luqui++ |  r1098@jabberwock:  luqui | 2005-11-29 01:14:48 +0000

[08:15] <svnbot6> r8016 | luqui++ |  Did a little editing on A20.

[08:33] <svnbot6> r8017 | luqui++ | Editing on S28.

[09:12] <gaal> luqui: ping

[09:17] <luqui> pong

[09:17] <luqui> gaal, pong.

[09:18] <gaal> hey. evelbot was borked

[09:18] <luqui> ?eval foo

[09:18] <evalbot6> Error: No compatible subroutine found: "&foo" 

[09:18] <gaal> autrijus fixed it temporarily, but this is a non-versioned version.

[09:18] <luqui> hmm

[09:19] <luqui> looking into it

[09:19] <gaal> cheers

[09:21] <luqui> ?eval say "hi"

[09:21] <evalbot6> OUTPUT[hi ] bool::true 

[09:21] <evalbot_8017> OUTPUT[hi ] bool::true 

[09:21] <luqui> don't know what the problem was.  It started up smoothly.

[09:21] <luqui> ?quit

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <luqui> woah

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <luqui> oh shit

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot_8017> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:21] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <evalbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:22] <luqui> whew

[09:22] <luqui> that was, um... interesting

[09:23] <luqui> let's fix that.

[09:25] * nothingmuch would like to see the URL shortening bots recursively shortening each other's shorts

[09:26] <luqui> Except, they only shorten when the url is above a certain length, right?

[09:26] <svnbot6> r8018 | luqui++ | When evalbot tells you that you shouldn't ?quit in public channels,

[09:26] <svnbot6> r8018 | luqui++ | the first word is "?quit", causing other bots to respond with the same

[09:26] <svnbot6> r8018 | luqui++ | message and causing an infinite loop.  Changed the message not to do that.

[09:27] * luqui crosses fingers

[09:27] <luqui> ?quit

[09:27] <svnbot6> ?quit only available per private message so other bots don't quit as well.

[09:27] <evalbot_8018> you should only do ?quit in a private message so other bots don't quit as well.

[09:30] <Khisanth> it shouldn't be so noisy

[09:30] <luqui> hmm?

[09:30] <Khisanth> how about no response instead of that message?

[09:31] <luqui> then people might wonder why it's not quitting

[09:31] <obra> luqui: what about putting that reply in a private message?

[09:31] <luqui> that's a pretty good idea

[09:31] <obra> :)

[09:34] <luqui> hmm, but then if an infinite loop accidentally happens, we can't see why

[09:34] <luqui> it would be a privmsg infinite loop

[09:35] <luqui> I think it's best to keep it noisy.  We can deal with it.

[09:36] <Khisanth> how about ignoring *bot*?

[09:37] <Khisanth> or a more specific pattern

[09:37] <luqui> Does it annoy you that much?

[09:38] <luqui> For example, purl is a bot, and there's certainly no way to tell that from the name.  (In one of my first IRC experiences, I tried to start a conversation with purl after he replied to one of my comments :-)

[09:38] <Khisanth> well there is always /ignore :)

[09:39] <devin> purl is a she, not a he

[09:39] <luqui> oh, sorry

[09:39] <devin> (see http://pound.perl.org/ )

[09:41] <Khisanth> luqui: my next suggestion was having the bots communicate with each other so they can better ignore each other :)

[09:41] <luqui> heh

[10:06] <gaal> evalbot was just making up for the time he was away.

[11:34] <luqui> ?eval "hi"

[11:34] <evalbot_8018> "hi" 

[11:42] <luqui> ?eval "hello"

[11:42] <evalbot_8018> "hello" 

[11:43] <luqui> ugh, what I would give for real IPC

[11:44] <luqui> I mean, without actually putting it in pugs myself :-)

[11:49] <luqui> ?eval "yo"

[11:49] <evalbot_8018> "yo" 

[12:37] <luqui> ?eval "mornin'"

[12:37] <evalbot_8018> "mornin\'" 

[12:40] <svnbot6> r8019 | luqui++ | Added my evalbot looper.

[12:49] <luqui> ?eval "whatup"

[12:50] *** evalbot_8018 is now known as evalbot_8019

[12:50] <evalbot_8019> "whatup" 

[13:08] <r0nny> yo

[13:08] <r0nny> got some problems with a complex multifile thing and inheritance

[13:10] <luqui> mkay, splain

[13:10] <r0nny> DARN

[13:10] <r0nny> such a stupid error

[13:11] <r0nny> forget to check if a member var is defined, but called a method of its object

[13:11] <r0nny> so it compleined about being unable to modify Vundef

[13:11] <luqui> hmm.. it'd be nice to have a better error message for that

[13:11] <luqui> did it give you a line number at least?

[13:11] <r0nny> yeah

[13:12] <luqui> that's good

[13:12] <r0nny> but still i had no idea

[13:12] <r0nny> method call on undef isnt a valid action would be much nicer

[13:12] <luqui> I'll see if I can do that

[13:13] <r0nny> nice

[13:13] <luqui> hmm, I get the error "no compatible subroutine found"

[13:13] <luqui> do you think you can reduce your code to a simple test case?

[13:14] <r0nny> im going to try

[13:23] <r0nny> i got something seems to create a endless loop

[13:23] <r0nny> luqui: may i dcc it to u - atm im in no position for a propper nopaste

[13:23] <luqui> uh, can you email?

[13:24] <luqui> I don't know how dcc works in irc...

[13:25] <r0nny> atm im also in no position to mail

[13:26] <luqui> so, how do I do this?

[13:26] <r0nny> well - your client is cappable

[13:26] <r0nny> im going to send it now

[13:27] <luqui> okay cool

[13:27] <r0nny> in my machine it seemed to loop endless

[13:28] <luqui> yeah, here too

[13:28] <r0nny> hmm

[13:28] <r0nny> odd

[13:28] <luqui> It might be a scoping issue

[13:28] <luqui> let me diag it a bit

[13:29] <luqui> yeah, it does the same thing if you say doit($.bar) instead of $.bar.doit($.bar)

[13:29] <r0nny> still i wasnt cappable of reprotoducing the other problem

[13:30] <luqui> it's okay, I'm working on good error messages for those kinds of errors in general

[13:30] <r0nny> hmm

[13:30] <r0nny> well - im going to continue on my normal project

[13:31] <r0nny> want to get it build simple apps

[13:31] <luqui> okay.  that problem is an infinite recursion (it calls doit() again and again)

[13:31] <luqui> if you can write a test for it, that'd be great

[13:31] <luqui> (to keep it from looping forever, keep a counter and abort if the counter gets too high)

[13:32] <r0nny> hmm

[13:32] <r0nny> a test helping class only counts up till a special value, and then exits might be nice

[13:34] <luqui> but the definition of "exits" is going to depend on the problem at hand

[13:34] <luqui> really a lexical variable should do.

[13:34] <r0nny> hmm

[13:34] <Juerd_> HELLO

[13:34] <Juerd_> :)

[13:34] <Juerd_> Eh

[13:34] <Juerd_> But without caps

[13:34] <luqui> my $counter = 0;   if $counter++ < 10 { recursive test case }

[13:34] <r0nny> i wonder how it could possibly be stuck at this loop

[13:35] <luqui> oh, it's quite simple

[13:35] <luqui> it thinks that doit() is a regular sub, so $.bar.doit looks like doit($.bar) to it

[13:35] <luqui> and it just calls itself over and over

[13:35] <luqui> the fix is to keep doit() from entering the regular sub symbol table...  but that probably has ramifications.

[13:35] <r0nny> but there is no doit() sub matches

[13:36] <luqui> yeah, uh, that's another problem

[13:36] <r0nny> but still it calls

[13:36] <luqui> yep.  it's obviously not doing multi dispatch on it.

[13:36] <r0nny> odd

[13:37] <r0nny> hmm

[13:37] <r0nny> time to read the docs about the testing modules

[13:39] <luqui> or just look at examples.  not like there's a shortage.

[13:52] <r0nny> luqui: got a problem with the recursion - dont know what it calls, but my exit-condition it complete ignored

[13:53] <luqui> what does it look like?

[13:53] <luqui> just sketch

[13:55] <r0nny> hmm

[13:57] <luqui> I was saying:  my $counter = 0;  class foo { has $.baz; method doit() { if $counter++ < 10 { $.baz.doit } } }

[13:57] <luqui> I have a hard time believe that it could ignore that counter...

[13:57] <r0nny> this way it told undefined var

[13:58] <luqui> what?!

[13:58] <luqui> something very screwy is going on...

[13:59] <luqui> works for me

[14:00] <r0nny> Undeclared variable: "$counter"

[14:00] <r0nny>     at t.p6 line 8, column 43-59

[14:00] <r0nny>        t.p6 line 12, column 1-9

[14:01] <luqui> did you declare it above where you used it?

[14:01] <r0nny> yeah

[14:01] <luqui> send

[14:01] <r0nny> its in the 2nd line

[14:01] <luqui> send the code.  this must be fixed.

[14:02] <r0nny> DARN

[14:02] <luqui> (if it is, in fact, broken)

[14:02] <r0nny> use Test # then no semicolon, and my $counter=0;

[14:02] <luqui> d'oh!

[14:03] <r0nny> not it works like expected

[14:03] <r0nny> eh now

[14:03] <luqui> woah, so it must have been interpreting that variable declaration as an argument to "use Test"

[14:03] <r0nny> yeah

[14:03] <r0nny> scarry

[14:03] <luqui> which means... inline declarations are working???!!!

[14:03] * luqui goes and tries

[14:03] <luqui> nope

[14:03] <luqui> :-)

[14:04] <r0nny> i hate these kinds of bugs

[14:04] <luqui> annoying, aren't they...

[14:05] <r0nny> yeah

[14:05] <luqui> but they are quickly reducing in number

[14:05] <r0nny> wich is generally a good sign

[14:05] <luqui> five months ago I couldn't code anything because there were so many weird bugs

[14:05] <luqui> now I can predict what's going to happen most of the time

[14:06] <r0nny> well - now im going to try continuing my build system

[14:07] <luqui> good luck

[14:07] <r0nny> yeah

[14:07] <r0nny> with the actual state of tools i might need more then just luck

[14:08] <luqui> :-)   anyway, thanks for being ambitious

[14:08] <luqui> you're finding lots of bugs for us

[14:09] <r0nny> i only helped to find about 4 or 5 - isnt this much

[14:10] <r0nny> well - need to go for some time

[14:10] <r0nny> later

[14:12] <nothingmuch> morning

[14:14] <luqui> morning

[15:08] <svnbot6> r8020 | luqui++ | Well, maybe the error messages haven't improved, but at least the 

[15:08] <svnbot6> r8020 | luqui++ | architecture for better error messages when subs are not found is there.

[15:41] <fglock> is it ok for Prelude.pm to include other files? (src/perl6/Prelude/*.pm)

[15:41] <fglock> or is it intentionally one big file

[15:44] <luqui> I'm pretty sure that it's okay to include other files

[15:48] <fglock> luqui: I'm thinking about moving some things that are under ext/Perl6-* into Prelude

[15:50] <luqui> hmmm.. like what?

[15:51] <luqui> (we must be careful so that we don't use up *all* the computer's memory and swap compiling the precompiled prelude)

[15:54] <fglock> like Range, List, and maybe Array (later) - it would be nice to make a separate compilation and link later

[16:03] <fglock> does Prelude compile to Haskell?

[16:09] <luqui> fglock, yes, Prelude is compiled to Haskell so we don't have to parse it every time.

[16:10] <luqui> I do wonder if it is possible to separate out the precompilations using hs-plugins.

[16:10] <luqui> then we could precompile eg. Test, which would speed up make test quite a lot

[16:27] <r0nny> re

[16:35] <pmurias> a python-like duality (py and pyo in python) system for perl6 modules would be handy 

[16:35] <gaal> luqui: vi config.yml, you can already precompile Test.

[16:35] <gaal> albeit not separately.

[16:37] <gaal> there was a reason why Prelude could not be broken up easily, but I don't remember what it was :/

[16:37] <gaal> maybe just @INC matters.

[16:47] <luqui> oh, yeah, I know

[16:47] <luqui> I tried that once, left to go get food, came back and it was still compiling

[16:47] <luqui> so I decided not to do that again

[16:47] <integral> pmurias: perl5 supports .pm and .pmc files

[16:48] <r0nny> how to compile perl5 module ?

[16:48] <luqui> .pmc?  really?

[16:48] <luqui> using ByteLoader?

[16:48] <integral> luqui: yep; it wastes masses of stat calls on it

[16:49] <luqui> Perl 6 better change the extension; .pmc means something else now :-)

[16:49] <r0nny> what does it mean ?

[16:49] <luqui> Parrot Magic Cookie

[16:49] <r0nny> and wich tool generates the compiled perl5 modules ?

[16:50] <luqui> We could follow python and make it .pmo, or follow Haskell and make it .pmi

[16:50] <luqui> I think it's ByteLoader

[16:50] <luqui> Ahh, B::Bytecode

[16:51] <luqui> but it doesn't buy you anything

[16:51] <luqui> it takes about as much time to parse a perl 5 source file as to read in a bytecode file

[16:51] <luqui> and you can deparse a bytecode file to see approximate source

[16:51] <luqui> that's why nobody uses it

[16:54] <pmurias> it would propably make more sense to precompile perl6 to backend specific stuff then

[16:54] <luqui> um, yes

[16:54] <luqui> oh, so the extension would be .pbc then, I guess

[16:54] <integral> hmm, since pugs' parser is so slow, serialised PIL2 might be useful though,  like for the Prelude :)

[16:54] <luqui> (or whatever other extension that is commonly used with whatever other backend we might target)

[16:55] <integral> but then we'd use .pil2 I suppose

[16:55] <integral> (and it'd be compiled in)

[16:55] <luqui> see, that's what makes me worry about compiling perl 6 with perl 6 rules

[16:55] <luqui> perl 6 rules are top down...

[16:55] <luqui> and top down parsers are slow

[16:56] <luqui> not only that, they're really stupid about being top down.  they're always backtracking, never predictive.

[16:57] <luqui> unless we can optimize to predictive without breaking any of the overdefined semantics

[16:57] <integral> umm, isn't this a pretty big flaw in the whole perl6 plan?

[16:57] <luqui> yes!

[16:57] <integral> luqui: actually how much backtracking is really going to happen?

[16:57] <integral> Isn't the bulk of the time spent in the operator parser?

[16:57] <luqui> ahh, yes, right.

[16:57] <luqui> that's why we introduced the OP parser

[16:58] <luqui> however, it seems that Pugs's parser uses one of those, too

[16:58] <luqui> but I really don't know enough about Parsec to know if that's its problem or the approach's problem

[16:58] <integral> hmm, I've been assuming that Strings have been Pugs' bottleneck

[16:58] <integral> hmm, I wonder if parsec can be instrumented to measure backtracking

[16:58] <luqui> you mean simply the fact that strings are lists?

[16:59] <luqui> well, sure, just define your own "try"

[16:59] <integral> and wedge in a little unsafePerformIO or use the builtin state, hmm

[16:59] <luqui> stick a trace in there, and then you can see how much each try backtracks

[17:02] <gaal> luqui: yes it takes ages and there's a long way to go, but if you intend on running make smoke it pays off.

[17:02] <r0nny> btw -will there be something to compile perl6 modules to native code ?

[17:03] * integral stares at try's code and wishes he'd payed more attention to the paper

[17:03] <luqui> r0nny, yes

[17:03] <luqui> well

[17:03] <luqui> if the backend supports it

[17:03] <integral> r0nny: several ways probably

[17:03] <r0nny> hmm

[17:03] <luqui> we intend on targeting parrot at least, which can compile to native cod

[17:03] <luqui> e

[17:03] <r0nny> nice

[17:03] <gaal> parrot can do that? cool!

[17:03] <luqui> integral, implement your own try in terms of Parsec's try

[17:03] <r0nny> hmm

[17:03] <gaal> how, actually, can it?

[17:04] <integral> luqui: hmm

[17:04] <luqui> gaal, it could at some point, I don't know if it still can

[17:04] <integral> actually I'm ok, I remember enough of the Consumed -> Empty thingie

[17:04] <luqui> gaal, using the "exec" runcore, IIRC

[17:04] <integral> it used the JIT for that I think

[17:04] <luqui> yeps

[17:04] <integral> actually in Jonathan's LPW talk he suggested it didn't work

[17:04] <integral> (and that the JIT was unloved :-()

[17:04] <luqui> awww :-(

[17:04] <luqui> the JIT is parrot's pride

[17:05] <r0nny> jit is great!

[17:05] <luqui> we can't abandon it

[17:05] <luqui> it produced faster benchmarks than any other VM out there

[17:05] <luqui> admittedly, for very specialized code :-/

[17:05] <integral> and compilers need to not use PMCs...

[17:06] <luqui> well, Perl 6 provides the lowercase types for optimized code when you need it

[17:06] <luqui> but the potential is dubious

[17:06] <pmurias> PMC could be unboxed by the optimizer in theory

[17:06] <pmurias> at least...

[17:06] <r0nny> limimiting the posibilities allways gives more room for special optimizing

[17:06] <luqui> er... I don't think the PIR level has enough information to do that well

[17:07] <integral> I hope there's not going to be a need to type infer PIR, ie if you know what type of PMC is in a P register you can skip it's vtable :-/

[17:07] <luqui> you really need that kind of optimization to happen on a very high level

[17:07] <integral> (and then you get a uncomputed jump if you're generated TIL)

[17:08] <luqui> If Perl 6 targets C (which isn't such a crazy idea if we use boehm), then your optimized code could be generated as native object code and linked in to parrot

[17:09] <luqui> <leo> [exec is] untested and probably not working much

[17:09] <luqui> darn

[17:09] <r0nny> bte - how long might it take, till perl6 is finally ready

[17:09] <leo> well, we do more optimizations - later

[17:10] <integral> ugh

[17:10] <luqui> why does everybody ask that

[17:10] <gaal> if someone ever does consider a c backend, please depend on glib instead of reinventing it :)

[17:10] <luqui> r0nny, the more people who work on it the faster it becomes ready

[17:10] <leo> but jit/x86 runs md5.pir at half of the speed of perl5/XS already now

[17:11] <luqui> gaal, what is glib?

[17:11] <r0nny> i think a c++ backend might be fine ;P

[17:11] <pmurias> luqui: The general part of GTK

[17:11] <gaal> luqui: gtk.org's underlying make-c-sane library.

[17:11] <integral> leo: but how fast does jit/x86 run md5.pl compiled from perl5 to PIR by a compiler?  that seems more relevant

[17:11] <PerlJam> r0nny: perl6 will be ready by christmas

[17:11] <r0nny> YAY

[17:11] <r0nny> ;P

[17:11] <leo> that just depends on the compiler :-)

[17:11] <luqui> r0nny, we don't need anything from c++ since we already have all the information that it provides as "convenience"

[17:12] <gaal> it has objects, closures, reasonable data structures

[17:12] <luqui> we get type information from Perl programs ourselves

[17:12] <gaal> and very high-quality code.

[17:12] <pmurias> c++ has clousures?

[17:12] <r0nny> neet to go - back when im back at home

[17:12] <integral> pmurias: c++ has objects.

[17:12] <luqui> r0nny, we just don't tell you which christmas

[17:12] <gaal> pmurias: glib does them in straight c; but they're tricky to use.

[17:13] <luqui> pmurias, no.  c++ has as much support for closures as c does, which was my point

[17:13] <PerlJam> r0nny: seriously though, I understand that pmichaud is working on a perl6 interpreter and we've already got pugs and the myriad ways to get from source to source, so it shouldn't be too long now.  I'm still betting on a "release" within 2 years.

[17:13] <luqui> oh

[17:13] <luqui> you were responding to gaal

[17:14] <PerlJam> But even if perl6 hits the street within 2 years, it'll take another 5 or so for it to mature.

[17:14] <integral> PerlJam: but will it be usable?  especially if "we"'ll do optimisation "later"

[17:14] <luqui> hahaha pmichaud's interpreter

[17:14] <luqui> (I'm not laughing at him)

[17:14] <luqui> (I'm laughing at the idea of Perl 6 implemented in PIR)

[17:14] <luqui> (and I've been laughing at that for a long time, but the rest of @Larry doesn't seem to agree)

[17:15] <integral> the rest of @Larry isn't writing code.

[17:15] <PerlJam> luqui: Indeed. I thought him insane at first, but then I got a look at all of the things pm has done with PGE and suddenly is seems sane. :)

[17:15] <integral> I'd have loved a "bootstrap perl6" something stripped down, simple grammar that could be written in PIR in an obvious way

[17:16] <luqui> well, we can still create that

[17:16] <PerlJam> Not sure if that's a dangerous kind of sanity though  :)

[17:16] <luqui> well, I fear that writing the compiler in PIR has all the disadvantages of writing it in Haskell

[17:16] <luqui> and none of the advantages

[17:16] <integral> luqui: hmm, disadvantages?   non-portability away from parrot, and too small a pool of developers who can cope with its code?

[17:17] <pmurias> is pmichaud creating a full perl6 implementation or a proof-of-concept 

[17:17] <luqui> the precise disadvantage I was thinking of was the low accessibility of the code

[17:17] <luqui> proof-of-concept... for now

[17:17] <integral> luqui: I think a lot of pugs' problem there is that the code isn't written as cleanly as it could

[17:18] <Juerd_> Aren't PoC's always "for now"?

[17:18] <pmurias> what are PoC?

[17:18] <luqui> most notably because *all* of the contributors (including the architect) have been *learning* Haskell while writing it

[17:18] <Juerd_> Proof of Concept

[17:18] <luqui> rather than already being familiar

[17:18] <luqui> well, except maybe integral 

[17:18] <Juerd_> integral: Is that a *problem*?

[17:18] <integral> hmm?  I did learn haskell while writing it

[17:18] <Juerd_> integral: Or an inconvenience?

[17:19] <geoffb> OOC, why has noone tried to write a Perl 6 -> (something) compiler in Perl 5?  Everyone got discouraged by Damian's Perl6::Rules problems?

[17:19] <luqui> oh, I thought you were already a haskeller, integral 

[17:19] <PerlJam> geoffb: someone did.

[17:19] <geoffb> PerlJam, ...?

[17:19] <integral> Juerd_: I think it is.   The precise problem I'm thinking of is that the code is way to interconnected so that you need to understand lots of stuff over lots of files to see what's happening

[17:19] <luqui> Juerd_, well, PoCs are supposed to be thrown away.  However, most of the time (as Larry points out), they end up evolving into the real thing instead.

[17:20] <luqui> integral, yeah, but I'm in a refactoring phase

[17:20] <luqui> so maybe after school settles down I'll clean stuff up

[17:20] <Juerd_> luqui: Sure, but I don't see that as a problem. The classical problem, as I see it happen, is that there are no tests, and once something is used in production, everyone's afraid to touch it to clean things up.

[17:20] <luqui> I've been wanting to clean up findSub for a long time now

[17:21] * integral is going to try to hack parrot these holidays

[17:21] <PerlJam> geoffb: I'm fairly sure there were the beginnings of a perl6 compiler (implemented in perl5) in languages/perl6 at one time.

[17:21] <Juerd_> It's no problem, imo, to put a PoC into production, iff you clean it up later.

[17:21] <geoffb> PerlJam, hmmm.

[17:21] * integral nods at PJ

[17:21] <luqui> Juerd_, I like the emphasis on tests in that interpretation

[17:21] <luqui> PerlJam, yes

[17:21] <luqui> and it was designed terribly

[17:21] <luqui> so it failed

[17:21] <Juerd_> integral: I've yet to see a big project without much interconnection. I don't know too many ways to avoid it.

[17:21] <pmurias> a bit of source code documentation would help a lot for grasping the pugs source code (not voluntiring for anything)

[17:22] <luqui> (it didn't use *any* compiler hourglasses)

[17:22] <PerlJam> luqui: were you the author?  I seem to remember that too.

[17:22] <luqui> no, I wanted to work on it

[17:22] <luqui> but never got into it

[17:22] <luqui> I think it was mostly Allison's project.

[17:22] <PerlJam> sean burke perhaps?

[17:22] <luqui> and sburke

[17:22] <PerlJam> ETOOMANYNAMES ;-)

[17:22] <integral> Juerd_: well I'm thinking of stuff like the runtime and the compiler both needing to manage pads, but doing different things with them,  but it's been coded to use the same data structure for both, so they're got a big connection that shouldn't be there

[17:22] <geoffb> luqui, no hourglasses == no intermediate rep?

[17:23] <luqui> right.

[17:23] <luqui> it just went straight from syntax to generated code

[17:23] <Juerd_> luqui: The emphasis is on tests because I think tests, not no-longer-using-PoCs-in-production, is the solution.

[17:23] <geoffb> ah.  Oops.

[17:23] <luqui> now we know that compilers are easy if you use *lots* of intermediate representations

[17:23] <luqui> squeeze the information into fundamental forms often

[17:23] <geoffb> Still, now that PIL2 exists, there's nothing to stop someone writing a Perl 5 frontend to it . . . 

[17:24] <integral> "exists"?

[17:24] <geoffb> integral, for some definition thereof.

[17:25] <geoffb> Yes, I know it's not fully there, but I would think enough of it is, to get started on the frontend.

[17:25] <integral> well that's the problem...   how do you write a perl 5 frontend for it when it's not actually compiling?

[17:25] <integral> oh, I'm out-of-date then

[17:25] * geoffb shrugs . . . but then, I'm currently writing an interpreter for a different language so I can learn how to write that sort of thing.

[17:26] * luqui recently wrote a toy language to experiment with type inference

[17:26] * luqui loves the three-node lambda calculus tree :-)

[17:26] * geoffb had a philosophical disagreement with his compilers prof in college, and thereby completely failed to learn anything about them.

[17:26] <luqui> what was the disagreement

[17:27] <PerlJam> geoffb: I had a disagreement with my compilers prof too ... but since I clearly knew more than he did, I too failed to learn anything.

[17:27] <geoffb> He argued that the compilers class should be done entirely in Common Lisp, not because of any advantage of CL per se, but because *he didn't want to write a list-handling library for C*.  I told him that's what grad students were for.

[17:28] <luqui> and libraries also

[17:28] <geoffb> I wouldn't have minded if he'd given me a real reason, but that was clearly bull.

[17:28] <PerlJam> (well, I didn't learn anything *from the class*.  I had my own outside reading and what not that I learned from)

[17:28] <geoffb> So my "suspicion wall" went up like lightning.

[17:28] <luqui> anyway, I think C is a pretty bad language for a compiler

[17:28] <geoffb> I eventually dropped the course.

[17:28] <luqui> as it is for anything

[17:28] <luqui> since you get too caught up in the bullshit details

[17:29] <luqui> and miss the big picture

[17:29] <luqui> When I first saw the Haskell representation of PIL, that's when I decided I needed to learn Haskell

[17:29] <luqui> that was it, the big picture, right there in 12 lines of haskell source

[17:29] <PerlJam> haskell++ 

[17:29] <luqui> and then I encoded it in Perl 6 for fun

[17:30] <luqui> and it was 30 lines of bullshit details

[17:30] <luqui> thus, I decided that Perl 6 must have tagged union types

[17:31] <geoffb> luqui, :-)

[17:32] <integral> tagged unions are a big thing that OO can't model :-(

[17:32] <integral> well, unless you switch it all around to methods, but sometimes it's easier to work with data than methods;  especially without multiple-dispatch

[17:32] <luqui> well, you *can* model it using CPS style

[17:32] <luqui> and then you get *polymorphic* tagged unions, which are totally sweet

[17:33] <integral> ugh, yes, but manual CPS is a big warning sign that you're using the wrong language

[17:33] <luqui> yeah

[17:33] <gaal> luqui: what are the current coordinates of those 12 lines?

[17:33] <luqui> well, it's not that bad if you have a clean closure support

[17:33] <integral> and in an OO language without closures, you end up passing the "continuation" as some kind of visitor-pattern thing

[17:34] * luqui /me looks

[17:34] <r0nny> re

[17:34] <svnbot6> r8021 | bsmith++ | Silenced a unused variable warning in Pugs.Eval.Var by changing x to _.

[17:35] <luqui> gaal, good question.

[17:35] <luqui> maybe they were factored away

[17:35] <luqui> (which is a good thing, because 11 node types is way out of the ball park)

[17:35] <luqui> (you need more like... 4)

[17:35] * geoffb sighs . . . I should have written this thing to be more debug-friendly

[17:35] <integral> in Pugs.PIL1? but that's been moved from GADTs to sane, simple stuff

[17:36] <luqui> ahh.  it was the GADT

[17:36] <luqui> autrijus showed it to me at the hackathon

[17:36] <integral> the problem there is that it was indexed with the wrong type

[17:37] <luqui> sure.  it didn't make a lot of sense in terms of a compiler

[17:37] <integral> it could have been fixed imho just by using phantom types to index it

[17:37] <luqui> but it definitely showed me the data structure in the essential detail and nothing more

[17:37] <luqui> phantom types?

[17:37] <integral> I mean a type without any constructors

[17:37] <integral> so it's just there at type-checking time

[17:38] <luqui> ahh

[17:38] <luqui> how do you define such a type?

[17:38] <luqui> just, data Foo?

[17:38] <integral> data Foo; IIRC

[17:38] <gaal> I wish I could see that version, this is side^H^H^H^Hheart of pugs I'm not familiar with

[17:39] <integral> hmm, it was in another file originally

[17:39] <gaal> another from ...? :)

[17:39] <luqui> I think it was in Compile.hs

[17:39] <luqui> in July?

[17:39] <integral> hmm, probably

[17:40] <gaal> PIL.Compile or Pugs.Compile?

[17:40] <luqui> probably Pugs.Compile

[17:42] * integral mutters about compilation times

[17:42] <luqui> there it is

[17:42] <luqui> svn cat -r "{2005-07-17}" http://svn.openfoundry.org/pugs/src/Pugs/Compile.hs

[17:43] <luqui> (on my birthday :-)

[17:44] <luqui> yikes, 17 nodes

[17:44] <luqui> that seemed small to me at the time

[17:44] <gaal> sleep $then-$now ; happy birthday

[17:44] <luqui> :-)

[17:45] <Juerd_> Hmmm... units :)

[17:46] <luqui> mmmmh?

[17:46] <Juerd_> I keep hoping we'll have omni-compatible everything :)

[17:46] <Juerd_> Using unittabs and stuff like that :)

[17:46] <Juerd_> $then a date, $now a date, sleep knows durations in any unit...

[17:46] <Juerd_> s/date/datetime/g

[17:47] <gaal> actually in DateTime.pm you can do that, but it doesn't produce a duration IIRC

[17:48] <Juerd_> Well, the point I'm hoping for is that sleep somehow can handle every kind of duration

[17:48] <Juerd_> Not just seconds.

[17:48] <gaal> including negative ones, yeah :)

[17:48] <gaal> I gotta go, see you :-)

[17:48] <luqui> well, using user-defined isomorphism in the new type calculus for Perl that I'm working on, that may be possible

[17:48] <luqui> I just need to make sure that the idea makes sense...

[17:48] <Juerd_> Either by having a type Time::Seconds for its argument, which other stuff coerces to, or by requiring specific unit specification :)

[17:49] <luqui> (unlike theory.pod v1 ;-)

[17:49] <Juerd_> sleep 5`s;

[17:49] <Juerd_> sleep 5;  # warning

[17:49] <integral> umm, isn't it basically exponential time to find a route from type A to type B given a bunch of isomorphisms? :-/

[17:50] <luqui> you mean dijkstra's algorithm?

[17:50] <luqui> cubic.

[17:50] <luqui> IIRC

[17:50] <integral> ah

[17:50] <integral> well that's still pretty darn long :)

[17:50] <luqui> only if you have large sets of isomorphisms

[17:50] <Juerd_> use units qw(time);

[17:50] <Juerd_> Eh, <time> :)

[17:51] <r0nny> btw - how is the claa tells me the mtime of a file ??

[17:51] <Juerd_> Many can just be hard coded, pre-calced.

[17:51] <luqui> r0nny, claa?

[17:52] <luqui> if it's going in the type calculus, it would all be done at compile time

[17:52] <luqui> and sure, you could give it hints

[17:52] <r0nny> ops call

[17:52] <integral> ugh, and so even longer compilers.   Please, please, please remember that perl is a dynamic language

[17:52] <luqui> yeah, I know

[17:53] <integral> for little scripts that open a text file, then run through a while(<>){} building some objects for each line, then frobbing the objects, and then dumping them.  that's how simple lots of stuff is :)

[17:53] <integral> I'd love to see some features design to make perl really fast to compile

[17:53] <luqui> and you're not using a set of 100 units to do that

[17:53] <luqui> don't worry, I at least have that in mind.  Pretty sure that's high on Larry's list too.

[17:53] <integral> but the module I loaded does

[17:53] <luqui> but modules are precompiled :-)

[17:54] <integral> but then installing modules takes ages :-(

[17:54] <r0nny> binary dist

[17:54] <luqui> for some definition of ages, yes.

[17:54] <integral> oh well, better trade off :)

[17:54] <r0nny> rafl and kane are allways working on a binary distribution system

[17:54] <luqui> I think the thing we really need to keep in mind is that it should always be possible to trade compile time for runtime

[17:54] <luqui> perhaps trading type safety also in the process

[17:55] <luqui> because Pugs is really annoying to work on because it takes so long to compile

[17:55] <r0nny> yeah

[17:55] <luqui> fast compile cycle is one of the anchors of XP

[17:55] <r0nny> i got just a few simple modules

[17:55] <integral> but type safety is really handy when hacking

[17:55] <luqui> well, you can speed it up by putting in explicit annotations

[17:56] <r0nny> type-savety is important

[17:56] <integral> (like I'm trying to build an email message, so I set the email address to $domain accidentally rather than the address object)

[17:56] <r0nny> u can use it to optimize more for the speial cases

[17:56] <luqui> yeah, but type inference is slow, we know that

[17:56] <Juerd_> integral: No, installing a module would be much faster than we're used to.

[17:56] <luqui> so we have to trade :-)

[17:56] <luqui> Juerd_, why?

[17:57] <Juerd_> The module is compiled once, in total, instead of once, per test script.

[17:57] <integral> ooh, that's a good one

[17:57] <Juerd_> It's compiled anyway. It takes very little extra to save it.

[17:57] <luqui> I guess if you consider asymptotic bounds

[17:57] <integral> but maybe we'll also have a sane way to not run billions of tests

[17:57] <luqui> but also remember that perl 5's parser/compiler is extremely fast

[17:58] <luqui> and we probably can't get perl 6's that fast

[17:58] <Juerd_> luqui: And so will Perl 6's *have to be*

[17:58] <Juerd_> Or it will not find acceptance.

[17:58] <Juerd_> Except amongst python and java coders, perhaps.

[17:58] <luqui> no, we're making other trades to compensate

[17:58] <luqui> like precompiled modules

[17:58] <Juerd_> Having a slower compiler is THE way to loose all ground on the web side of things.

[17:59] <luqui> okay.  well, like I said, there need to be trade-offs available to the user

[17:59] <Juerd_> I think there should be a fast immediate-run compiler. A compiler that stores things for later can be slower.

[17:59] * integral has had the case of the CGI script that took *seconds* to start up

[17:59] <Juerd_> The web thing is different because the web user typically has no write access anywhere, to store the compiled versions, and compiling manually SUCKS.

[18:00] <integral> ok, "say 'hello'" to the pugs prompt prints about two pages of "backtracking" assuming I stuck the trace in the right place :)

[18:00] <integral> s/pages/screenfuls/

[18:00] <luqui> hmm

[18:00] <integral> oops, dinner, see you all later

[18:01] <luqui> but I'm convinced that perl 6's compiler can't be as fast as perl 5's, even in the no-static-analysis case

[18:01] <Juerd_> It'll still have to be very, very fast

[18:02] <r0nny> but the overall time might be shorter, since all the precompiled modules save time

[18:02] <Juerd_> Maybe not exactly as fast, but the average user mustn't notice a difference in compile+execution speed

[18:02] <luqui> Well, I think the bound is a little more lenient than that

[18:02] <geoffb> And the fact that Perl 6 source can be considerably shorter may help the overall experience v. P5

[18:03] <luqui> that is, you have to be able to compile 5,000 lines in about a second.

[18:03] <Juerd_> Of course, if execution is so much faster that it compensates for slower compilation, that's okay too.

[18:03] <luqui> you have to be able to compile 1 line in a quarter of a second

[18:04] <luqui> because those are bounds that the average user can handle

[18:04] <luqui> once you go over 5,000 lines then people will start precompiling

[18:04] <Juerd_> geoffb: Don't forget that numerous people choose Perl not for its expressibility and conciseness, but because it's the only dynamic language that has good enough speed for today's demanding computer use.

[18:05] <luqui> er.

[18:05] <geoffb> Juerd_, no argument at all with that.  I simply meant, if the P6 compiler chews source half as fast as P5, but the source is only half as long . . . 

[18:05] <Juerd_> luqui: A second for 4 lines is totally unacceptable, even in the slowest of cases. We have to be at least 20 times as fast as tcl to be taken seriously :)

[18:05] <geoffb> of course, that depends on skilled use of P6

[18:05] <xinming> Juerd_: No, Why I choose perl is because of its expressibility. :-)

[18:05] <luqui> Juerd_, I was assuming an approximately linear interpolation between the two bounds :-)

[18:06] <geoffb> xinming, "numerous people", not all

[18:06] <xinming> and have a c-like style grammar. :-)

[18:06] <luqui> basically, a small script: 1/4 second.  A medium program: 1 second.  A large program: people are precompiling.

[18:06] <r0nny> hmm

[18:07] <Juerd_> xinming: So do I. Many do not.

[18:07] <r0nny> my small stuff allready needs about 3 seconds :/

[18:07] <r0nny> and it does allmost mothing

[18:08] <luqui> pugs is no example :-)

[18:08] <luqui> as far as speed goes

[18:08] <luqui> which I think is completely fine

[18:08] <luqui> it wasn't written to be fast

[18:08] <r0nny> still its paine

[18:09] <luqui> well, you can make it faster if you like

[18:09] <Juerd_> luqui: It's an example of bad speed ;)

[18:09] <luqui> heh

[18:09] <r0nny> btw - can pugs compile perl modulse tho hakell modules, and later use them ?

[18:09] <Juerd_> A very good example, even. It outperforms tcl in slowness! ;)

[18:09] <luqui> r0nny, do you mean, can you use perl 6 modules from haskell?

[18:10] <luqui> or can you use haskell modules from perl 6?

[18:10] <Juerd_> I think he means: precompile Perl 6 modules, for Perl 6 re-use.

[18:10] <r0nny> luqui: i want to precompile modules are loaded depending on a variable

[18:10] <Juerd_> But with some vague notion of how things happen :)

[18:10] * luqui isn't sure, to be honest

[18:11] <r0nny> else i need to hack it, to use all modules are there

[18:12] <luqui> r0nny, oh wait...

[18:12] <luqui> you want to control whether or not to use a module based on some flag?

[18:12] <r0nny> i want to compile tha app, but depending on a varialbe it uses different modules

[18:12] <r0nny> the variable isnt known at compile time

[18:13] <r0nny> but it resolves to a class name

[18:13] <luqui> oh, well I know that's impossible

[18:13] <luqui> in fact, it's really impossible, not just unimplemented

[18:13] <r0nny> well

[18:13] <r0nny> it would be possilbe, if i had all the modules put in at compile-time

[18:13] <luqui> but you may want to look at "require"

[18:13] <luqui> r0nny, of course

[18:14] <r0nny> is there a way to check if i compile, or not ?

[18:14] <luqui> but then you're not really "selectively using" them, are you?

[18:14] <luqui> r0nny, I don't quite know what you mean

[18:14] <r0nny> i am

[18:15] <r0nny> i read what class is needed, then i use the moduile for it, and create a instance

[18:15] <luqui> okay, you want "require"

[18:15] <r0nny> maybe

[18:16] <luqui> ./pugs -e 'if 0 { require Test }  ok(1)'

[18:16] <luqui> *** No such method: "&ok"

[18:16] <luqui> ./pugs -e 'if 1 { require Test }  ok(1)'

[18:16] <luqui> ok 1

[18:17] <luqui> ?eval require Test; ok(1)

[18:17] *** evalbot_8019 is now known as evalbot_8021

[18:17] <evalbot_8021> Error: No such method: "&require" 

[18:17] <luqui> okay, fine

[18:17] <r0nny> takes some time

[18:18] <luqui> of course.  you're compiling a module.

[18:18] <luqui> and no, I don't know of a way to precompile

[18:18] <r0nny> btw why not use ?

[18:18] <luqui> use runs at compile time

[18:18] <luqui> require runs at runtime

[18:19] <r0nny> hmm

[18:19] <r0nny> eval "use foo" was my actual doing

[18:20] <luqui> it's basically the same thing.

[18:20] <r0nny> now the prog is broken

[18:22] <r0nny> it just wont find the file any more

[18:22] <r0nny> all i di was changing from eval use to require

[18:23] <luqui> just a sec

[18:23] <luqui> just like in perl 5, require needs a full path

[18:23] <luqui> if you don't hard-code the name

[18:23] <luqui> require "blib6/lib/Test.pm"

[18:24] <luqui> is equivalent to

[18:24] <luqui> require Test

[18:24] <luqui> but not to

[18:24] <luqui> require "Test"

[18:24] <r0nny> is there a way to supply class names the eval use way ?

[18:24] <luqui> what do you mean "supply class names"?

[18:25] <r0nny> the pkg name is created by prepending a namespace prefix to the variable wich is only allowed to contain [a-zA-Z:]

[18:26] <luqui> oh, you're asking if you can make "require" behave like "eval use"

[18:26] <r0nny> yeah

[18:26] <luqui> the answer is no.  use "eval use".

[18:27] <luqui> but it's probably better to supply explicit paths anyway

[18:27] <luqui> so that you don't get people including standard modules

[18:27] <xinming> is there a way to dynamically generate a class which class is the same as file name exclude the extension? ;-)

[18:27] <luqui> which may have insecurities

[18:27] <xinming> the class name is the same as file name exclude the extension.

[18:28] <luqui> xinming, I'm not sure how the answer could possibly be "no"

[18:28] <luqui> maybe you need to clarify the question a bit

[18:28] <r0nny> luqui: i have allways a special prefix, and the module name isnt allowed to contain suspicious stuff

[18:28] <r0nny> hmm

[18:28] <luqui> r0nny, would Test::More be considered suspicious?

[18:28] <luqui> because it could introduce an insecurity for sure.

[18:30] <r0nny> im speaking of stuff might change the module path

[18:30] <r0nny> darn need to go again

[18:30] <xinming> hmm, for example, I have role defined. and we wish to write class. But we make a file contain a class. So, It's a bit like template. and we only need to make a file which only contains `class $file_name does role;`

[18:31] <xinming> and a new class is generated. :-/

[18:31] <luqui> xinming, well, perl has file I/O.

[18:32] <luqui> my $fh = open "$file_name", :w;  $fh.print("class $file_name does role \{\}\n")

[18:33] <luqui> oh, and $fh.close, of course, since we don't have GC of those things yet

[18:33] <xinming> hmm, I think we can find the files, and eval this string in that to dynamically generate the class. But we might wish to get a file list, and use require to load them.

[18:33] <luqui> I don't understand

[18:34] <xinming> we might prefer use require instead of eval "class $class_name does Role;"

[18:34] <luqui> well, that preference is keeping you from getting your job done then

[18:35] <luqui> eval is more powerful than require.   if you can't do it with require, you should be using eval.

[18:36] <luqui> maybe I'm still misunderstanding

[18:36] <luqui> if my answer doesn't make any sense, then I probably am

[18:37] <xinming> hmm I have 2 solutions, my @files = get_pm_list; for @files -> $f { eval "require $f" }

[18:39] <xinming> another is, my @files = ("A", "B", "C"); for @files -> $f { eval "class $f does Role;" }

[18:39] <luqui> if the only thing you're using the files for is to create the classes

[18:40] <luqui> then I don't see any reason that the first one is better

[18:40] <luqui> you have to create files only to immediately read them and evaluate the code

[18:40] <xinming> I prefer the previous.

[18:40] <luqui> but why?

[18:41] <xinming> as we can extend the class by your preference.

[18:41] <luqui> hmm, I see

[18:41] <luqui> so you want to generate the file only if it doesn't already exist?

[18:42] <luqui> ?paste

[18:42] <luqui> @pate

[18:42] <luqui> @paste

[18:42] <luqui> hmm..

[18:42] <geoffb> lisppaste3, url?

[18:42] <lisppaste3> To use the lisppaste bot, visit http://paste.lisp.org/new/perl6 and enter your paste.

[18:42] <luqui> thanks

[18:42] <geoffb> np

[18:42] * geoffb wonders

[18:42] <geoffb> pasteling, url?

[18:42] <geoffb> perlbot nopaste

[18:42] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[18:43] <xinming> luqui: hmm, IMHO, This is good for you to do a program which can specify module by a config file. If the module doesn't exist, then you can still get the default behaviour.

[18:43] <luqui> okay, I see where you're going

[18:43] <luqui> one sec

[18:44] <xinming> So, What I exactly want is... If there is a better way instead of using eval. :-)

[18:44] <luqui> what's wrong with eval?

[18:45] <PerlJam> eval has a negative stigma attached to it.  It's like using goto  ;-)

[18:45] <luqui> but require doesn't?

[18:45] <luqui> require just reads in a file and then evals it

[18:45] <luqui> (I guess while just generates a few gotos in the same respect)

[18:46] <PerlJam> If you hide the thing that makes people cringe, then , well ... they don't cringe.

[18:47] <xinming> how about when $f = "A {}; qx:rm ~ -rf:; class B" ?

[18:47] * SamB comes up with a scheme to coat monads in chocolate

[18:47] <lisppaste3> luqui pasted "Possible solutions" at http://paste.lisp.org/display/14117

[18:47] <luqui> xinming, that's why you have to filter your input

[18:47] <luqui> you always have to filter your input

[18:48] <xinming> why I don't like eval is because of these, eval has too much power. 

[18:48] <luqui> make sure it matches rx:P5/^[A-Za-z_:]+$/ and you don't have that problem

[18:48] <luqui> xinming, so does require

[18:48] <luqui> require My::Cpan::Module::That::Deletes::Your::Hard::Disk

[18:49] <xinming> ...

[18:49] <xinming> thanks for your solution. :-)

[18:49] <luqui> In fact, here's the implementation of require:

[18:49] <luqui> sub require($file) { eval(slurp $file) }

[18:49] <luqui> now is require better than eval?

[18:50] * xinming thinks so.

[18:51] <xinming> oops. the same as eval. :-/

[18:51] <luqui> when $file = "/tmp/rmrf";  /tmp/rmrf is qx:rm -rf /:

[18:52] * xinming thinks perl 6 is much easier to learn than haskell.

[18:52] * luqui thinks so too

[18:52] <r0nny> re

[18:52] <luqui> haskell is about the most difficult language to learn on the planet

[18:52] * luqui has to go to school

[18:53] <xinming> I still didn't catch the many ideas in haskell.

[18:53] <xinming> luqui: good good study. day day up. :-P

[18:53] <luqui> it took me two months to learn, and another two months to get comfortable with

[18:53] * luqui &

[18:53] <r0nny> re

[18:53] <xinming> I just started. that's the pain.

[18:54] <r0nny> found a nice solution

[18:54] <Juerd_> 19:54 < luqui> haskell is about the most difficult language to learn on the

[18:54] <Juerd_>                planet

[18:54] <Juerd_> I think Russian is.

[18:54] <luqui> heh.

[18:54] <r0nny> are there any modules dealing with other modules ?

[18:54] <xinming> Juerd_: why not say Chinese. :-/

[18:54] <luqui> programming language.  :-p

[18:54] <luqui> yeah, Chinese beats Russian by a long shot.

[18:54] <luqui> oh wait, I'm supposed to be gone

[18:54] <r0nny> i think im going to write a module creates insstances of special classes in special namespaces

[18:54] * luqui &

[18:55] <Juerd_> No, Russian wins.

[18:55] <Juerd_> It looks easier, by looking logical

[18:55] <Juerd_> But underneath, it is not.

[18:55] <Juerd_> It's a hell of a lot easier to learn lots and lots of unrelated things

[18:55] <Juerd_> Than to learn lots and lots of rules, with many exceptions each.

[18:56] <Juerd_> PHP is Chinese, Perl is Russian :)

[18:56] <Juerd_> PHP's easier.

[18:56] <Amnesiac> hey Juerd_ 

[18:56] <Juerd_> It has more stuff to learn, but you know beforehand there's no logic to it :)

[18:56] <luqui> then what's Haskell?

[18:56] <Juerd_> Perl has less to learn, but what's there is harder to grok, because it looks logical, and then an irregularity will painfully bite. :)

[18:56] <luqui> I'd say Japanese, but Haskell is harder conceptually than Japanese.

[18:56] <Juerd_> luqui: Esperanto, perhaps.

[18:57] * luqui doesn't know much about Esperanto... so, it's possible

[18:57] <xinming> Juerd_: well, PHP has so many functions which are not uniformed. But Chinese not. :-/

[18:57] <luqui> Chinese has so many characters!!

[18:57] <luqui> I don't expect the grammar is all that difficult

[18:57] <Juerd_> luqui: I've compared Esperanto to almost every programming language in existence, and funnily, it's always true in some way :)

[18:57] <r0nny> are there modules help with dealing with dynamic loading of other modules ??

[18:58] <luqui> in perl 6?

[18:58] <luqui> because there are plenty in perl 5

[18:58] <r0nny> in perl6

[18:58] <luqui> I don't think so

[18:59] <r0nny> then im going to hack one

[18:59] <xinming> luqui: But every characters has it's own meaning. And most used characters are only about 3000, which will composed with related base things. ;-) well, maybe I am a Chinese for I say this. :-/

[18:59] <luqui> cool

[18:59] <luqui> only about 3000 huh?

[18:59] <luqui> gee, that's not that many

[18:59] <luqui> I mean, I know 26

[18:59] <luqui> 3000 isn't that much more than 26

[18:59] <xinming> r0nny: just specify a dir, and then paste the code luqui show. :-P

[19:00] <Juerd_> luqui: You very probably already know many more than 3000 symbols

[19:00] <r0nny> xinming: im going to write a submodule loader

[19:00] <Juerd_> Think about traffic signs, warning signs, icons, all the character sets you know

[19:00] <luqui> sure, but I'd have to know 3000-26 more of them to learn chinese

[19:00] <xinming> luqui: But for express the meanings. Chinese is shorter. :-P

[19:00] <luqui> more concise.  Like perl :-)

[19:00] <r0nny> is the namespace Loader::Submodule ok ?

[19:00] <xinming> though Chinese sucks in Computing world. :-/

[19:01] <r0nny> or should i use something else

[19:01] <luqui> r0nny, maybe you should take the perl 5 module as a template?

[19:01] <luqui> I think it's called DynLoader or something

[19:01] * xinming goes to sleep

[19:01] <xinming> bye all for now.

[19:02] <luqui> r0nny, http://search.cpan.org/~vipul/Class-Loader-2.03/lib/Class/Loader.pm

[19:02] <luqui> is that what you're trying to make?

[19:02] <r0nny> luqui: yeah

[19:03] <r0nny> kinda

[19:03] <luqui> then Class::Loader seems like a good name ;-)

[19:03] <r0nny> mm

[19:04] * luqui &

[19:04] <r0nny> it should load subclasses of different kinds

[19:05] <r0nny> i think i can do

[19:05] <r0nny> but it might be a bit special from the beginning

[19:10] <r0nny> Class::Loader is using cpan to install missing stuff

[19:10] <r0nny> i can do it- there is no sixpan

[19:13] <ingy_> seen autrijus 

[19:13] <jabbot> ingy_: autrijus was seen 3 days 10 hours 10 minutes 34 seconds ago

[19:13] <ingy_> hmm

[19:13] <ingy_> anyone know autrijus home address?

[19:14] <obra> ingy_: do you have the email they sent us about where we were staying for yapc?

[19:16] <Jooon> ingy_: a_coach@somewhere_in_the_world

[19:16] <Jooon> or maybe not yet :)

[19:21] * Aankhen`` goes to sleep.

[19:21] <Aankhen``> G'night.

[19:22] <ingy_> obra: looking

[19:25] <Juerd_> ingy_: If he has one, I doubt you'll be able to reach him there often ;)

[19:25] <ingy_> I need it for visa application Juerd_ 

[19:25] <Juerd_> Ah

[19:26] <leo> ingy_: autrijus is currently heading towards .au AFAIK (osdc::au that is)

[19:26] <ingy_> I really need gugod

[19:28] <ingy_> oooo whois!

[19:30] <ingy_> Registrant Name:Autrijus Tang

[19:30] <ingy_> Registrant Street1:4f #8 way 1 lane 24 section 3 djr-nan road

[19:30] <ingy_> Registrant Street2:

[19:30] <ingy_> Registrant Street3:

[19:30] <ingy_> Registrant City:Taipei City

[19:30] <ingy_> Registrant State/Province:

[19:30] <ingy_> Registrant Postal Code:116

[19:30] <ingy_> Registrant Country:TW

[19:30] <ingy_> Registrant Phone:+886.222345961

[19:30] <ingy_> :p

[19:30] * ingy_ rocks

[19:33] <Amnesiac> ingy brianson

[19:34] <r0nny> darn

[19:36] <r0nny> doesnt a class usually have a default new func ?

[19:39] <Juerd_> r0nny: Method, and yes.

[19:46] <DesreveR> re

[19:46] <DesreveR> anything after the "any idea ..."

[19:46] <DesreveR> ?

[19:47] <Juerd_> What "any idea ..."?

[19:48] <DesreveR>  *** cannot cast from VType (mkType "Class::Loader::new") to Pugs.AST.Internals.VCode (VCode) <- i get this, if i  call NAMESPACE::new(:attr<val>)

[19:54] <DesreveR> darn - everything is just broken

[19:54] <DesreveR> some time ago it still worked fine :/

[19:55] <RangerNS> Hi all.. If I wanted to develop a compiler/interperter/somethingorother for an existing language, eventualy with parrot as its vm, what would be a reasonable route? P6 on pugs?

[19:56] <robkinyon> RangerNS: You'll need the parser/lexer for that language

[19:57] <robkinyon> Then, you'll need to learn either PIL or PIR

[19:58] <RangerNS> well, thats what Im thinking of writing in P6.. Its now implemented in S/SL, so conversion from one recdescent to another should be more timeconsuming then hard.

[19:59] <robkinyon> AFAIK, Allison is developing a set of compiler tools for use with Parrot

[19:59] <robkinyon> Allison Randal, that is

[19:59] <robkinyon> Autrijus developed PIL, but it's really for Perl6 -> other language (like JS)

[20:00] <RangerNS> When I was previously inspired, I was thinking of more or less cloning languages/perl6 - at least the structure - but thats gone now.

[20:00] <robkinyon> though, there is a PIL <-> PIR converter already written, so you can go Your language -> PIL -> PIR

[20:00] <robkinyon> if PIL is easier for you to work towards

[20:00] <RangerNS> I think parsing would be first on the list :)

[20:02] <leo> RangerNS: have a look at compilers/{pge,tge} inside the parrot tree

[20:03] <leo> especially the grammar parser, also used by tge

[20:04] <RangerNS> the language is zmsh (part of ZMailer), which started as a clone of sh, but with lispy things and perly things too

[20:11] <chip> seen autrijus 

[20:11] <jabbot> chip: autrijus was seen 3 days 11 hours 8 minutes 43 seconds ago

[20:11] <chip> that can't be right

[20:11] <chip> he was here yesterday

[20:14] <PerlJam> seen autrijus_

[20:14] <jabbot> PerlJam: autrijus_ was seen 96 days 41 minutes 10 seconds ago

[20:15] <PerlJam> the bot is clearly broken

[20:26] <Limbic_Region> seen autrijus

[20:26] <jabbot> Limbic_Region: autrijus was seen 3 days 11 hours 23 minutes 55 seconds ago

[20:26] <Limbic_Region> depends on how you spell the name I guess

[20:26] <Limbic_Region> oh, nevermind me I see chip already did that

[20:30] <pmurias> RangerNSL: Alternativly you could try to do it using Parsec, PIL, and something else for Tre Transformation (maybe Atribiute Grammars see UUAG)

[20:30] <pmurias> RangerNSL: You would learn haskell that way

[20:32] <pmurias> At least that's what I'm trying to do...

[20:34] <pmurias> i'am at the parsec^Hr Stage

[20:38] <gaal> DesreveR: .new, not ::new

[20:42] * DesreveR bangs his head on the table

[20:43] <DesreveR> *multiple times*

[20:46] <DesreveR> am i correct with the folowing : asigment of objects just copyes their "pointer", pushing/poping them, from a array, too

[20:50] <DesreveR> darn

[20:50] <DesreveR> i got a problem with some inheritance

[20:55] <DesreveR> i got a class got a special new submethod, but for some reason it wont call -_-

[20:57] <pmurias> ?eval class A {};A.new();

[20:57] <evalbot_8021> A.new(); 

[20:57] <pmurias> ?eval class A {method h {"hello world"};A.new().h;

[20:57] <evalbot_8021> Error:  unexpected end of input expecting end of input, ";", statements or "}" 

[20:58] <pmurias> ?eval class A {method h {"hello world"}};A.new().h;

[20:58] <evalbot_8021> "hello world" 

[20:58] <pmurias> ?eval class A {my $.a;method h {"hello world"}};A.new().a;

[20:58] <evalbot_8021> Error: No such method: "&a" 

[20:58] <pmurias> ?eval class A {has $.a;method h {"hello world"}};A.new().a;

[20:58] <evalbot_8021> \undef 

[20:58] <pmurias> ?eval class A {has $.a;method h {"hello world"}};A.new(a=>1).a;

[20:58] <evalbot_8021> \1 

[20:59] <DesreveR> um

[20:59] <DesreveR> my problem is, that a custom new isnt executed like it should

[21:12] <wolverian> DesreveR, you don't generally define a custom new, but a custom BUILD. I don't know if pugs implements this.

[21:13] <DesreveR> hmm

[21:23] <DesreveR> darn - all i want, is that this damn class sets a object to one of its attributes at startup

[21:28] <DesreveR> anyone got a hint, where changing the default ctors is described ?

[21:34] <wolverian> S12

[21:35] <wolverian> http://dev.perl.org/perl6/doc/design/syn/S12.html

[21:36] <DesreveR> found it

[21:37] <wolverian> DesreveR, note that if you need it to be initialised at class construction time, you can just write 'has $.foo = "bar";' if you need it initialised at _object_ creation time, you can just say 'has $.foo = { bar() };'

[21:41] <DesreveR> does this work, if the atribute is inherited ?

[21:41] <wolverian> it certainly should. I don't know if Pugs implements it.

[21:42] <DesreveR> well - atm i got another problem - File::Find wont work like described

[21:43] <wolverian> well, fix it. :)

[21:43] <DesreveR> in my actual state im not cappable of such thing

[21:44] <wolverian> well, pugs is certainly not ready for production yet.

[21:48] <DesreveR> why does $foo=`prog`; not work ?

[21:49] <DesreveR> and is there a alternative ?

[21:55] <DesreveR> wolverian: found the error - it uses the module keyword, where  it should use the class keyword

[21:56] <wolverian> qx(prog) works, I think.l

[21:56] <wolverian> s,\.l,.,

[21:58] <DesreveR> can someone fix the error in File::Find

[21:58] <DesreveR> its just making a class of the module, so it works like expected again

[22:13] <Khisanth> ?eval if(1){ my $foo = 1 } say $foo

[22:13] <evalbot_8021> Error: Undeclared variable: "$foo" 

[22:13] <Khisanth> phew

[23:13] <luqui> stevan, ping

[23:20] <buu> hrm

[23:20] <buu> Does the p6evalbot respond to join commands?

[23:21] <luqui> I think so

[23:22] <buu> er, how?

[23:22] <buu> evalbot_8021: join 

[23:22] <luqui>  ?join #channel

[23:22] <buu> evalbot_8021: join #buubot

[23:22] <buu> ?join #buubot

[23:22] <buu> Er

[23:22] <luqui> I don't think it responds to name, and it might only respond to privmsg

[23:22] <buu> No that worked

[23:22] <buu> But I got the svnbot as well

[23:22] <luqui> heh

[23:22] <wolverian> heh

[23:22] <luqui> so privmsg is a good idea

[23:22] <buu> Not quite what I had in mind

[23:22] <buu> oh

[23:22] <buu> heh

[23:23] <buu> Ah right.

[23:23] <Khisanth> luqui: what happened to the message spamming? :)

[23:24] <luqui> I don't think it spams for ?join, just for ?quit

[23:24] <buu> Heh, now how do you make them leave?

[23:24] * luqui look

[23:24] <luqui> s

[23:24] <integral> do you want it out of #perl, buu?

[23:24] <Khisanth> ?part ?

[23:24] <luqui> heh... you don't

[23:24] <Khisanth> leave? reconnect?

[23:25] <SamB> luqui: maybe you kick them

[23:25] <luqui> that would work

[23:25] <luqui> ... if you can

[23:25] <integral> if it's #perl, buu, I can kick easily

[23:27] <luqui> ?eval "someone is committing"

[23:27] *** evalbot_8021 is now known as evalbot_8023

[23:27] <evalbot_8023> "someone is committing" 

[23:27] <SamB> ?eval "hello"

[23:27] <evalbot_8023> "hello" 

[23:27] <SamB> ?eval "hello" "hello"

[23:27] <evalbot_8023> Error:  unexpected "\"" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[23:27] <SamB> ?eval "hello"("hello")

[23:27] <evalbot_8023> Error: cannot cast from VStr "hello" to Pugs.AST.Internals.VCode (VCode) 

[23:28] <luqui> ?eval ::("say")("hello")

[23:28] <evalbot_8023> Error: cannot cast from VType (mkType "say") to Pugs.AST.Internals.VCode (VCode) 

[23:28] <SamB> hmm, I guess that is something like a type error

[23:28] <luqui> ?eval &::("say")("hello")

[23:28] <evalbot_8023> OUTPUT[hello ] bool::true 

