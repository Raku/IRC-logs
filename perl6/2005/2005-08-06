[00:03] <wilx> Hehe.

[00:19] <brentdax> Does Pugs's CGI.pm support POST yet?

[00:26] <nothingmuch> hello

[03:12] <svnbot6> r6089 | Stevan++ | Perl6::MetaModel - (p5)

[03:12] <svnbot6> r6089 | Stevan++ | * Methods are now all created through the closure factory (even submethods)

[03:12] <svnbot6> r6089 | Stevan++ |    - fixed some tests and misc. code to accomidate this

[03:17] <meppl> lalala

[04:15] <svnbot6> r6090 | fglock++ | * new class "Iter::Range" - A lazy range iterator, 

[04:15] <svnbot6> r6090 | fglock++ |   like "1..Inf" or "-Inf..0" or "1..10000000"

[04:15] <svnbot6> r6090 | fglock++ | * Array::Lazy implements slice,push,pop,shift,unshift.

[04:15] <svnbot6> r6090 | fglock++ | * more tests

[05:51] <svnbot6> r6091 | Stevan++ | Perl6::MetaModel - (p5)

[05:51] <svnbot6> r6091 | Stevan++ | * updates to the 10,000 ft view

[05:51] <svnbot6> r6091 | Stevan++ |   - added BOOTSTRAPPING section

[05:51] <svnbot6> r6091 | Stevan++ |   - fixed diagram 

[05:51] <svnbot6> r6091 | Stevan++ | * added a ::create_P6opaque function to centralize

[05:51] <svnbot6> r6091 | Stevan++ |   the creation of instance structures

[05:51] <svnbot6> r6091 | Stevan++ |   * added an object ID to that P6opaque structure

[05:51] <svnbot6> r6091 | Stevan++ | * $obj->id now returns unique id for each instance

[05:51] <svnbot6> r6091 | Stevan++ |   - added new test file for this

[05:51] <svnbot6> r6091 | Stevan++ | * ::Class object are now more useful, however they 

[05:51] <svnbot6> r6091 | Stevan++ |   are not yet where I want them to be

[05:51] <svnbot6> r6091 | Stevan++ |   - misc. work moving towards seperating class creation 

[05:51] <svnbot6> r6091 | Stevan++ |     and applying classes to the object env. 

[05:51] <svnbot6> r6091 | Stevan++ |   - you can now call class Methods on Class objects 

[05:51] <svnbot6> r6091 | Stevan++ |     (which I think might be wrong)

[05:51] <svnbot6> r6091 | Stevan++ |   - added test file for class objects

[06:30] <brentdax> Hmm...possible issue in patterns with the sequence "\<-"...

[07:13] <GeJ> hello all

[07:15] <brentdax> Is there a maximum size for a rule, beyond which it's no longer parsed properly?

[07:15] <Aankhen``> Morning.

[07:16] <brentdax> I seem to be in a situation in which adding anything more to a rule makes it silently fail all matches, even ones which shouldn't be affected by it.

[07:19] <brentdax> (In this case, a 186 byte regex seems to work, while a 187 byte one fails.  Even spaces change it.)

[07:21] <brentdax> Interestingly, spacing earlier in the program affects it as well.  Could I be hitting the end of a buffer or something?

[07:22] <Aankhen``> The rule is in a Perl 6 file run by Pugs?

[07:22] <brentdax> Yeah.

[07:23] <Aankhen``> Could you try running it directly under Parrot?

[07:25] <brentdax> How do you suggest I do that?

[07:25] <Aankhen``> Uh, that would probably entail writing it out in PIR.

[07:25] <Aankhen``> Dang.

[07:26] <brentdax> Is there a way to see what it's trying to feed to Parrot?

[07:27] <Aankhen``> I'm not very familiar with the interaction between Pugs and Parrot, so I can't say.

[07:27] <brentdax> Kay...

[07:27] <wolverian> use the -C flag instead of -B

[07:27] <wolverian> that should only compile the PIR

[07:27] <wolverian> humm, unless I totally misunderstood the problem. :)

[07:28] <brentdax> I'm not using -B--I'm just concerned with how Parrot is seeing a rule PGE's being handed.

[07:28] <Aankhen``> Hmm.

[07:29] <Aankhen``> -C PIR would add a lot of other stuff... but you could probably find the rule in it.

[07:29] <brentdax> In any case, I have a workaround, even if it's "screw with spacing until it works".  Less nasty than the workaround for the method-chaning bug (namely, "use lots of intermediate variables").

[07:29] <brentdax> Aankhen: I'll see what I get from that.

[07:35] * Aankhen`` wanders off to shoot Terrorists. CZ, ho!

[07:35] <Aankhen``> Hmm, that sounded wrong.

[07:35] <Aankhen``> Ah well.

[08:06] <gaal> is it correct for the interactive shell to prepare a new Env every time you do :e/:E ?

[08:28] *** Aankh|Clone is now known as Aankhen``

[09:03] <nothingmuch> seen autrijus

[09:03] <jabbot> nothingmuch: autrijus was seen 12 hours 28 minutes 28 seconds ago

[09:08] <autrijus> rehi \camels

[09:08] <autrijus> http://pugscode.org/images/simple-compilation.png # first sketch

[09:09] <Aankhen``> Hi autrijus.

[09:09] <autrijus> hey Aankhen``.

[09:09] <ods15> nothingmuch: speak of the devil :P

[09:09] <ods15> (the seen thing)

[09:10] <Aankhen``> Reading the last post in a flamewar is like listening to the punchline without the joke.

[09:10] <Aankhen``> Ooh, pretty graphic.

[09:10] <nothingmuch> ods15: =)

[09:11] <nothingmuch> i actually managed without autrijus 

[09:11] <nothingmuch> but hola autrijus, anyway

[09:11] <autrijus> nice to hear

[09:11] <autrijus> hola nothingmuch. I feel like drawing pictures today

[09:11] <ods15> blah, i hate wine

[09:12] <nothingmuch> autrijus: why only one code generartor?

[09:12] <Aankhen``> Hey!  The Emitter for PIR doesn't have any blue in it!  DISCRIMINATION!!!

[09:12] * Aankhen`` coughs.

[09:12] <Aankhen``> Sorry.

[09:12] <Aankhen``> Evil alter-ego took over there for a sec.

[09:13] <nothingmuch> Aankhen``: beat it with a stick when it does that

[09:13] <nothingmuch> NO DON"

[09:13] <nothingmuch> T DO THAT!! AJHSTR

[09:13] <nothingmuch> SHUTUP!

[09:13] <nothingmuch> sorry, mine too

[09:13] <Aankhen``> nothingmuch: I tried that and ended up hurting myself.

[09:13] <autrijus> nothingmuch: right that shoul be plural

[09:13] <Aankhen``> (it ducked and left me to bear the brunt of the stick)

[09:14] <nothingmuch> autrijus: also disambiguate "Evaluator" to "pugs evaluator in haskell" or something like that

[09:14] <nothingmuch> we're also going to have a PIL parser, right? so that you can compile to PIL and evaluate it with pugs

[09:16] <autrijus> nothingmuch: the PI

[09:16] <autrijus> nothingmuch: the PIL parser is called Prelude.read

[09:16] <autrijus> or SerTH.read

[09:16] <autrijus> but some kind of read.

[09:17] <autrijus> (or YAML.load)

[09:18] <nothingmuch> autrijus: overall pretty drawing

[09:18] <nothingmuch> i like your somewhat arbitrary choice of symbols =)

[09:18] <nothingmuch> in that case add a loop: PIL code -> Disk

[09:18] <autrijus> hm? there is a underlying theme :)

[09:18] <nothingmuch> and then Disk -> PIL Loader

[09:18] <Aankh|Clone> nothingmuch: Sorry sir, I already used "pretty". I'm going to have to ask you to step away from my space.

[09:19] * nothingmuch beats up Aankh|Clone 

[09:19] <nothingmuch> GIVE US BACK OUR HACKER!

[09:19] <autrijus> nothingmuch: note that the PIL code already imply on-disk file.

[09:19] <Aankh|Clone> Ow!  Ouch!  Oh!  Ow!

[09:19] <autrijus> all square symbols are on disk

[09:19] <nothingmuch> unless, ofcourse, despite being evil you hack better than him

[09:19] <Aankh|Clone> Maybe I do, and maybe I don't.  Guess you'll never know. >:-D

[09:20] <Aankh|Clone> `fail` is preferred over `die`, right?

[09:20] <nothingmuch> autrijus: make a note of that

[09:20] <nothingmuch> or add a little disk icon on the lower right corner of each of these

[09:21] <Aankh|Clone> Or a safety pin.  I'm sure that'd make the meaning clear. :-D

[09:21] <nothingmuch> Aankh|Clone: fail == die under use fatal, or 'undef but error ...' under 'no fatal'

[09:21] <nothingmuch> so yes, prefer it

[09:21] <Aankh|Clone> Indeed.

[09:21] <Aankh|Clone> OK.

[09:21] <Aankh|Clone> Thanks.

[09:22] <nothingmuch> errors should be 'tainty' under my proposal that everyone ignored

[09:22] <nothingmuch> if you have a data structure that touched any error you should be able to recover the error from the top level

[09:23] <Aankh|Clone> How does a data structure touch an error?

[09:28] <autrijus> updated: http://pugscode.org/images/simple-compilation.png 

[09:31] <autrijus> brb...

[09:32] <nothingmuch> autrijus: nice =)

[09:45] <coral> nothingmuch: so any data structure modified within a transaction that errors out would be hinted with a link back to the error thrown during the transaction?

[09:45] <nothingmuch> even more general

[09:45] <coral> where transaction is probably block in perl lingo

[09:46] <nothingmuch> i have given a 'fail "moose"' to a module taht doesn't 'use fatal'

[09:46] <nothingmuch> it used the value

[09:46] <nothingmuch> to generate another

[09:46] <nothingmuch> but threw the value away

[09:46] <nothingmuch> so it's no longer 'undef'

[09:47] <nothingmuch> the 'but error "moose"' part leaks into structures it made that touched the undef

[09:47] <nothingmuch> so eventually i get an "ok" structure

[09:47] <nothingmuch> but it has a 'but error "moose"' attached to it

[09:47] <nothingmuch> i can use it

[09:47] <nothingmuch> and nothing will happen

[09:47] <nothingmuch> but if I fail in relation to that structure, the user can see the error that may have started it all

[09:48] <nothingmuch> the first and third references to first body are unique

[09:48] <nothingmuch> i mean: the first and second I aren't the same code author

[09:48] <nothingmuch> sorry for being confusing

[10:20] <integral> hmm, does PGE support cuts, or have some docs?

[10:50] *** Maddingue__ is now known as Maddingue

[11:50] *** Aankh|Clone is now known as Aankhen``

[15:39] *** Aankh|Clone is now known as Aankhen``

[15:56] <autrijus> rehi

[15:57] <autrijus> another picture! http://pugscode.org/images/container.png

[15:59] <stevan> horray for visual thinking!!

[16:00] <autrijus> :)

[16:00] <autrijus> actually I think symbolically

[16:00] <stevan> me too

[16:00] <autrijus> those are transliterated from Container.hs :)

[16:00] <autrijus> I hope this will make explaining to people easier

[16:00] <autrijus> stevan: saw http://pugscode.org/images/simple-compilation.png too?

[16:01] <stevan> yes, I saw this this morning

[16:01] <stevan> very nice as well

[16:01] <autrijus> stevan: as I move forward with the metamodel I'll do one for that too

[16:01] <stevan> cool

[16:01] <autrijus> also for the value types

[16:02] <stevan> so Id's are refs to other Scalars?

[16:02] <stevan> the =:= part

[16:03] <autrijus> er no

[16:03] <autrijus> all the links read "has-a"

[16:03] <autrijus> and Id is just a simple unique id

[16:03] <stevan> ah

[16:03] <stevan> ok

[16:03] <stevan> so each scalar has-a Id (shown as a big 4)

[16:04] <autrijus> yes.

[16:04] <autrijus> rather

[16:04] <autrijus> each cell has Id

[16:04] <stevan> yes, cell 

[16:04] <stevan> BTW - did you see I added $obj.id into the metamodel

[16:04] <autrijus> yes, cool

[16:05] <autrijus> I still see two potential problems with my container model drawing

[16:05] <autrijus> one is that "my $a is constant" would be rebindable to something nonconstant

[16:05] <gaal> so, how much of Prelude.pm can be compiled to PIL presently? that's the most appropriate target for precompilation, isn't it? (or a binary representation of PIL)

[16:05] <autrijus> so we may want to have a "Constant Container" variant that has a read-only link to a constant cell only

[16:05] <gaal> hi btw

[16:05] <autrijus> yo gaal

[16:05] <gaal> nice pics :)

[16:06] <stevan> if you have a moment, can you review the Bootstapping section in the 10,00ft view to make sure it fits with your understanding

[16:06] <autrijus> stevan: I have, and it does :)

[16:06] <stevan> autrijus: excellent, it is so nice to have some meta-company over here :)

[16:07] <stevan> autrijus: so "my $a is constant" means you cannot rebind $a?

[16:07] <autrijus> stevan: I don't know at all

[16:07] <autrijus> I think this is a p6c question

[16:07] <autrijus> I'll p6c it.

[16:07] <autrijus> (hm, maybe it's a p6l question. I have no idea)

[16:07] * autrijus thinks about cc'ing both.

[16:08] <stevan> cc both

[16:08] <autrijus> anyway, another problem is that 

[16:08] <gaal> naive Q about the container diagram: are there only pads? where are "our" vars stored?

[16:08] <stevan> on one hand it makes sense that $a is not rebindable, since it is a constant

[16:08] <autrijus> gaal: a pad, of course.

[16:08] <stevan> but being a variable, it seems it should be re-bindable

[16:08] <autrijus> another problem is that "my $a is SomehowTiedScalar"

[16:08] <autrijus> will be untie()able

[16:08] <stevan> otherwise the name $a is useless in the rest of the program 

[16:09] <autrijus> like, always untieable

[16:09] <autrijus> and I'm not sure whether that's correct.

[16:09] <autrijus> gaal: pad is something that maps names to containers :)

[16:10] <gaal> autrijus, that isn't the way it was in p5, is it? i said it was a naive question <g> but i seem to remember only lexicals are stored in pads there, with dynamic vars stored... elsewhere? :)

[16:12] <autrijus> gaal: dynamic vars are stored in hashes :)

[16:13] <gaal> the namespace hash, yes? eg %main::

[16:13] <autrijus> hm, you are right.

[16:13] <autrijus> under that drawing

[16:13] <autrijus> you can't remove names from a pad

[16:13] <autrijus> while under package vars

[16:13] <autrijus> we can do sick things like

[16:14] <autrijus> our $x; delete %OUR::<$x>;

[16:14] <autrijus> or can we?

[16:14] <gaal> in p5 we certainly can :)

[16:14] <autrijus> %OUR::<$x> = 9;

[16:14] <autrijus> right. :)

[16:15] <autrijus> but in p5 we handled it with globs

[16:15] <autrijus> I guess that means we use container refs in p6.

[16:16] <autrijus> on the other hand, I can argue that Pad is always read only

[16:16] <gaal> oh, i had something to ask about 'use fatal'... but i don't want to interrupt you guys so i'll pop by later?

[16:16] <autrijus> and the package symtable is a mutable hash

[16:16] <autrijus> and all it does is it reads up the readonly pad, augment it, and store it back

[16:16] <autrijus> I'll get there when I get there :)

[16:16] <autrijus> gaal: no, just ask :)

[16:17] <gaal> well, the provisional internals support for fail_ in Prim uses a magical $?FAIL_SHOULD_DIE

[16:17] <gaal> thing is, every scope should be able to mask the previous version of that var

[16:18] <gaal> and every fail should die/return undef according to the nearest scope's var.

[16:18] <wolverian> isn't it hte caller's scope's?

[16:18] <wolverian> s,hte,the,

[16:18] <gaal> yes.

[16:18] <wolverian> right. carry on, then :)

[16:19] <gaal> so the question is how should use fatal create a lexical in the caller's scope? can it be done at all without internals support?

[16:20] <gaal> %CALLER::<%MY::<$?FAIL_SHOULD_DIE>> = bool::true wont' work :)

[16:20] <autrijus> gaal: look at the "self.pm" thread.

[16:20] <autrijus> gaal: larry said all exports are lexical by default now

[16:20] <gaal> p6l?

[16:20] <autrijus> so you just do mandatory exports

[16:20] <autrijus> yeah, p6l I think

[16:21] <gaal> ok, i'll read up on that then. thanks.

[16:22] <autrijus> picture links sent to p6[cl].

[16:40] * gaal returns from looking up that thread and some MJD lexical pragmas, funked out.

[16:41] <gaal> 'punctuation' is particularly sick.

[16:43] <autrijus> hm, url?

[16:43] <autrijus> I've looked at mjd lexical pragmas but I don't remember 'punctuation'

[16:43] <integral> http://search.cpan.org/~mjd/punctuation-0.02/punctuation.pm

[16:43] <gaal> http://search.cpan.org/src/MJD/punctuation-0.02/punctuation.pm

[16:44] <gaal> note no "sub import"

[16:45] <gaal> actually, it isn't a lexical pragma, is it?

[16:45] <gaal> (as it works on the calling package.)

[16:46] <gaal> what pragmas were you looking at when you mentioned them, autrijus?

[16:55] <autrijus> gaal: http://perl.plover.com/TPF/Pragmas/PROPOSAL

[16:56] <autrijus> I'm not sure whether it's merged to 5.9 or not

[16:56] <autrijus> check with rgs and friends

[16:56] <gaal> v. interesting!

[16:56] <autrijus> he's got a working patch

[16:56] <autrijus> anyway, you can chase from the pointers :)

[17:01] <integral> curiously lexical pragmas were mentioned in passing in the last few days on p5p

[17:02] <integral> ah, by jhi in bug #969

[17:05] <nothingmuch> evening

[17:06] <autrijus> nothingmuch: new pretty pictures up :)

[17:06] <autrijus> s/s//

[17:07] <nothingmuch> i don't see the diff

[17:08] <autrijus> er, I mean, :

[17:08] <autrijus> http://pugscode.org/images/container.png

[17:08] <nothingmuch> ah

[17:08] <nothingmuch> i see you're in a graphical mood today =)

[17:08] <autrijus> yup :)

[17:09] <nothingmuch> explain not tiability please

[17:09] <nothingmuch> mutable cell contains a scalar value

[17:10] <nothingmuch> and also has a propertie?

[17:10] <nothingmuch> and that propertie may contain the object it's tied to?

[17:10] <nothingmuch> s/ie/y/

[17:10] <autrijus> nothingmuch: http://www.nntp.perl.org/group/perl.perl6.compiler/1030

[17:12] <nothingmuch> Mutable cells has-a mutable scalar value <-- scalar value is immutable, isn't it?

[17:12] <nothingmuch> it gets replaced, not changed

[17:12] <autrijus> right. the formal way to say it is

[17:13] <autrijus> data Cell = Mut Id (TVar Value) | Con Id Value

[17:13] <autrijus> which is immediately obvious.

[17:13] <nothingmuch> tying a cell is basically replacing it's implementation, right?

[17:13] <autrijus> (this is oversimplified as it ignores tiedness etc, but you get the point)

[17:13] <autrijus> yes.

[17:13] <autrijus> when a cell is tied, its value part cease to matter

[17:13] <nothingmuch> what about it's ID?

[17:13] <autrijus> that preserves.

[17:14] <nothingmuch> sounds sane

[17:14] <autrijus> you can't have a tied class to lie about the id.

[17:14] <autrijus> well, that's what p5 does

[17:14] <autrijus> not seeing a reason to change that :)

[17:14] <nothingmuch> can I create arbitrary cells, and play with them?

[17:14] <nothingmuch> like my $var = new Scalar::Cell::Mutable;

[17:14] <autrijus> that's just my $var :)

[17:14] <nothingmuch> my $container = $?PAD->new('$name');

[17:15] <autrijus> but you're asking about full reflection, and I have no idea.

[17:15] <autrijus> that's a p6l question.

[17:15] <nothingmuch> $container->bind($var);

[17:15] <nothingmuch> fair enough

[17:15] <nothingmuch> wait, no

[17:15] <nothingmuch> if i post no one will pay attention except the people who want to know

[17:16] <nothingmuch> can you please think about this, and slyly sneak it in?

[17:16] <nothingmuch> the interface really won't matter

[17:16] <autrijus> I think the high level interface

[17:16] <autrijus> that is := tie etc

[17:16] <autrijus> makes sense

[17:16] <autrijus> and since reflection is runtime dependent

[17:16] <autrijus> we'll get there when we actually have two PIL runtimes.

[17:16] <nothingmuch> uh, i don't get that

[17:17] <nothingmuch> runtime dependant == different on parrot and  pugs?

[17:17] <nothingmuch> or happens at runtime?

[17:17] <autrijus> different on parrot and js and p5.

[17:17] <nothingmuch> that's not a good thing =)

[17:17] <autrijus> no, but neccessary, as there are foreign objects.

[17:17] <autrijus> and foreign containers, and foreign references.

[17:18] <nothingmuch> i don't see why

[17:18] <autrijus> for the pure-perl part, reflection hardly gets you anything beyond what the languange already have

[17:18] <nothingmuch> the reflection interface can be just a set of proxy objects

[17:18] <autrijus> oh. that.

[17:18] <autrijus> in that case you can write it in userland.

[17:18] <autrijus> there's no need for direct builtin runtime support.

[17:18] <nothingmuch> it lets you introspect more accurately

[17:19] <nothingmuch> well, yes there is

[17:19] <nothingmuch> = is a sepcial construct, not an infix operatorf

[17:19] <nothingmuch> it's not strictly necessary

[17:19] <nothingmuch> but I can see how it may be desirable

[17:20] <nothingmuch> whatever happenned to this: http://perl.plover.com/TPF/DEBUGGER/PROPOSAL ?

[17:20] <autrijus> ::MY.container_named('$name').cell.assign(3);

[17:20] <autrijus> you mean things like that, right?

[17:20] <nothingmuch> yes

[17:21] <autrijus> and my response is that while the pugs's PIL runtime implement things this way, eg. PIR implements it entirely differently.

[17:21] <nothingmuch> i'd like a function I could pass by value that some other function can use to change the value of something that doesn't belong to them, that i've given them permission to change

[17:21] <autrijus> but they manage to present the same interface of := and = etc

[17:21] <nothingmuch> right

[17:22] <autrijus> so the introspection is likely to be either runtime dependent (not good)

[17:22] <nothingmuch> and my point is that there could be a thin api provided by each runtime

[17:22] <autrijus> or emulated somehow (not sure how)

[17:22] <nothingmuch> so that the dependant code could be given a uniform interface, just for introspection

[17:22] <nothingmuch> and a runtime that doesn't support it will have that api, filled with 'fail'

[17:22] <autrijus> and we can't know how until we actually have this container interface working on more than one runtimes.

[17:22] <autrijus> so we'll get there when we get there.

[17:23] <autrijus> bduf doesn't work in this case :)

[17:23] <nothingmuch> bduf?

[17:23] <autrijus> big design, up front.

[17:23] <nothingmuch> ah, big design up front

[17:23] <nothingmuch> heh

[17:23] <nothingmuch> yeah, that's why i didn't want to poist it =)

[17:23] <autrijus> good, then we agree (again)

[17:23] <nothingmuch> what I meant is: when we're done with it, let's propse that this is the one true interface

[17:24] <nothingmuch> and force the other runtimes to emulate it

[17:24] <autrijus> oh ok. sure.

[17:31] <buu> Hey. anyone happen to know how large the parrot binary/runtime is?

[17:32] <integral> buu: try #parrot on magnet/irc.perl.org

[17:34] <stevan> nothingmuch, autrijus: a think introspection layer atop the runtime sounds good

[17:34] <stevan> I am thinking the metamodel needs something similar

[17:34] <nothingmuch> yes, i will do it tomorrow

[17:34] <nothingmuch> uh, i mean, in 3 months

[17:35] <nothingmuch> or never.

[17:35] * nothingmuch ducks

[17:35] * stevan waits for nothingmuch to poke his head up again

[17:35] <svnbot6> r6092 | Stevan++ | Perl6::MetaModel - (p5)

[17:35] <svnbot6> r6092 | Stevan++ | * Perl6::MetaClass now has a proper ::Class object,.. whoops

[17:35] <svnbot6> r6092 | Stevan++ | * Perl6::Class now stores all classes created in %ALL_CLASSES

[17:35] <svnbot6> r6092 | Stevan++ |    - this is a prelude to allowing name based lookup, which 

[17:35] <svnbot6> r6092 | Stevan++ |      I will use to bootstrap while I am getting rid of the 

[17:35] <svnbot6> r6092 | Stevan++ |      current Perl 5 package based name lookup :)

[17:35] <svnbot6> r6092 | Stevan++ |    - added some tests to check if classes are being stored properly

[17:36] * nothingmuch slowly pokes head up

[17:36] * nothingmuch leaps up with Buddhist Palm Kung Fu

[17:36] <nothingmuch> and smashes the shit out of stevan 

[17:36] * stevan falls over, blood streaming from his nose

[17:36] <stevan> hey WTF!

[17:37] *** nothingmuch is now known as stevan__

[17:37] *** stevan is now known as nothingmuch

[17:37] * stevan__ picks his nose in Colorful Tiger style

[17:37] * nothingmuch is really a girl

[17:37] *** nothingmuch is now known as stevan

[17:37] <stevan__> holy lotus, we have swapped bodies (imagine mouth moving independantly of sound)

[17:38] <stevan__> now we are one!

[17:38] *** stevan__ is now known as nothingmuch

[17:38] <stevan> :P

[17:38] * nothingmuch feels his braw is not in the right place

[17:38] <jdv79> geoffb, around?

[17:38] * stevan feels the pain of seperation as nothingmuch tears free

[17:39] <stevan> jdv79: I have not seen him in a few days,..

[17:39] <jdv79> oh

[17:40] <jdv79> what literature would you recommend on the metamodel stuff?

[17:40] <stevan> jdv79: his article just came out on perl.com, so I imagine he was busy recently (damn $work, how I lothe thee)

[17:40] <jdv79> geoffb and i were supposed to be compiling and cleaning up that book list a while ago

[17:40] <stevan> ahh

[17:41] <stevan> jdv79: The Art of the MetaObject Protocol is my new bible

[17:41] <jdv79> cool

[17:41] <stevan> is all about CLOS, so you have to get used to lots of parens, but otherwise it is a very good read

[17:42] <stevan> jdv79: did you see the 10,000 ft view I wrote up yesterday

[17:42] <jdv79> parens - how untasty!

[17:43] <stevan> jdv79: the code is quite readable though, very well written

[17:45] <stevan> autrijus: do you think ::Foo and Foo should be interchangable?

[17:45] <stevan> so that given: class Foo { method bar (Class $c:) { 'bar' }}

[17:46] <stevan> (not sure if that is correct, but I mean bar to be a class method)

[17:46] <stevan> Foo.bar() and ::Foo.bar() are the same thing

[17:47] <autrijus> stevan: Foo sometimes mean &Foo

[17:47] <autrijus> and sometimes ::Foo

[17:47] <autrijus> depending on which is in scope

[17:47] <stevan> why &Foo?

[17:47] <autrijus> and the function one wins

[17:47] <stevan> you mean sub Foo {}

[17:47] <stevan> ok

[17:47] <autrijus> er I mean %Foo()

[17:47] <autrijus> bah, &Foo()

[17:47] <autrijus> consider

[17:47] <autrijus> say Foo;

[17:47] <autrijus> where there is a &Foo in scope.

[17:48] <stevan> hmmm

[17:48] <stevan> but if there is not a &Foo in scope, then Foo means ::Foo

[17:48] <autrijus> I think there's a lot to be said about Haskell's forced uppercase=class, lowercase=function convention, but as we know perl is not a B&D language :)

[17:48] <autrijus> stevan: if there is neither in scope, Foo is I think an error(!)

[17:48] <autrijus> the synopses said there's no barewords anymore.

[17:48] <stevan> and if I want ::Foo and there is a &Foo in scope, then I need to disambiguate with ::Foo

[17:49] <autrijus> yes.

[17:49] <stevan> ok, so Foo and ::Foo are interchangeable given the right circumstances

[17:49] <autrijus> Foo means ::Foo when the compiler knows about ::Foo

[17:49] <autrijus> _and_ there's no &Foo in scope.

[17:49] <Aankh|Clone> ?eval sub foo () { fail "This is supposed to happen" }; foo()

[17:49] <evalbot6> Error: No compatible subroutine found: "&fail" 

[17:49] *** Aankh|Clone is now known as Aankhen``

[17:50] <stevan> so class(Foo) aka ::Foo needs to respond to class methods

[17:50] <autrijus> nod.

[17:50] <stevan> autrijus: ok, cool, that is how I current have it working :)

[17:50] <autrijus> sadly I need to wake up for family union tomorrow early

[17:50] <autrijus> cool :)

[17:51] <stevan> autrijus: I aim to have all p5 magic removed by end of weekend

[17:51] <stevan> and it should then align with the Haskell version

[17:51] <autrijus> woot!

[17:51] <autrijus> stevan++

[17:52] <stevan> :)

[17:52] <stevan> ok, go to sleep, I need to go spend time with my family now too &

[17:53] * autrijus waves &

[17:53] <nothingmuch> ciao

[19:22] * nothingmuch goes to eat dinner

[19:32] * brentdax goes to eat lunch.

[19:32] <svnbot6> r6093 | Stevan++ | Perl6::MetaModel - ::Class now uses the ::create_P6opaque to create the instance (first step towards maybe bootstrapping this too)

[19:38] <buu> ?eval $obj.$meth

[19:38] <evalbot6> Error:  unexpected "." expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[19:41] <gugod> win 22

[19:42] <putter> autrijus: what is the pugs policy wrt PGE?  I started to suggest someone write a test, but we already have a bunch of tests which were disabled because "pge wasnt working at the moment".  so I wasnt sure whether to suggest it or not.

[19:43] <autrijus> putter: the policy is that t_disabled should be verified again on parrot 0.2.3 and if that works, move back to t/.

[19:43] <putter> brentdax: its fairly easy to directly test rules/grammars under pge.  see parrot t/p6rules/.

[19:44] <putter> autrijus: ok.  (ooo, 0.2.3 is out?:)

[19:45] <autrijus> yeah.

[19:45] <autrijus> Parrot 0.2.3 "Serenity"

[19:46] <autrijus> putter: actually I think a better way is to data-driven the test

[19:47] <autrijus> that way the same set of tests can be reused for PGE and Pugs and other implementations

[19:47] <putter> for completeness I'll mention that one can also test pge with ./parrot compilers/pge/demo.pir  and PCRE with ./pcretest in the pcre distribution.

[19:47] <autrijus> I think that'd be genuinely helpful.

[19:48] <putter> autrijus: agreed.

[19:48] <autrijus> so, if you're up to it, do it? after all pmichaud said that he needs to be driven by tests :)

[19:49] <autrijus> cf. http://use.perl.org/comments.pl?sid=27914&cid=42390

[19:50] <pasteling> "putter" at 66.30.119.55 pasted "brentdax: another pge test example" (63 lines, 2.7K) at http://sial.org/pbot/12284

[19:55] <putter> autrijus: ah, neat.   I'll... at least ponder it.

[19:55] <autrijus> sure :)

[19:56] <autrijus> Ovid++ # excellent AI::Prolog tutorial!

[19:56] <putter> swi?

[19:58] <autrijus> # http://use.perl.org/~Ovid/journal/

[19:58] <autrijus> putter: no, AI::Prolog, as in AI::Prolog

[19:58] * putter hasn't been thinking about targeting prolog as a backend.  no siree.  that would simply insane.

[19:59] <autrijus> maybe. however, Curry is an interesting target

[19:59] <ods15> perl6 is simply insane...

[19:59] <autrijus> that's true.

[20:00] <clkao> autrijus: you are sleeping!

[20:00] <clkao> go away!

[20:00] <putter> ah, I was thinking of Language::Prolog::Yaswi.

[20:01] <putter> clkao: lol

[20:08] <putter> re integrating prolog, on the syntactic end, p6 provides more than enough ammo.  underneath... it would be really neat if we could do hybrid runtimes, so a wam is integrated with the rest of a backend.

[20:08] * autrijus notes we _are_ already using hybrid runtimes.

[20:08] *** Aankh|Clone is now known as Aankhen``

[20:09] <autrijus> in the sense that OO core is a distinct part

[20:09] <putter> re, curry, there is also the Alice/Oz model... but while I like big state-space collapse games, what I'd really really like is a non-commited choice engine.  "spreadsheet"-like constraint propagation.

[20:11] <putter> re already/oo core, hmm... without a control-flow metamodel, I guess the compiler really needs to be the one to say "ok, this section of things will be handed off to wam"...

[20:12] <autrijus> why don't we have a control flow metamodel again?

[20:12] <autrijus> I'd like to play with trampolines too ;)

[20:12] <putter> :)

[20:12] <putter> add to the todo list? ;)

[20:13] <autrijus> sadly, to express bounces and stuff in Haskell is straightforward, so it's no fun

[20:13] <autrijus> now, to build it on perl5, that's getting interesting

[20:14] <putter> re constraint propagation, I think that's a biggie.  proceedural is great, and declarative is great, but for really hairy problems you need to create a big ball o hair that maintains invariants and otherwise updates itself as you proceedurally poke it.

[20:15] <autrijus> (I mean, if Java can host Kawa, Perl5 can surely host Perl6.)

[20:15] <putter> (the question is always, what does the speed vs conformance tradeoff curve look like)

[20:16] <autrijus> putter: how exactly does this differ from any OO/RDBMS model with a builtin DBD::AnyData?

[20:17] <autrijus> I mean, that's what most perl folks would imagine when you talk about embedded alternate runtimes.

[20:18] <putter> ohhhh, the alternate runtimes... I was consing up a description of what one wants in constraint propagation...

[20:18] <autrijus> go ahead and finish it. I hope you hashed your consing :)

[20:18] <putter> :)

[20:22] <putter> well, the only perhaps non-obvious part is, say you have $a $b $c and $a = $b ~ $c, you want to be able to set any of those variables and have the right thing happen, but large scale, you want them to maintain histories tagged with motivations you declare.  so you can then later retract motivations, which disables those elements of the history, adjusting values if appropriate.

[20:23] <putter> otherwise you can't backtrack.

[20:24] <autrijus> yes.

[20:25] <autrijus> perl6 does provide an extremely primitive form of backtracking, that is let-hypothesis

[20:25] <autrijus> but in itself it does nothing interesting

[20:25] <putter> re alternate runtimes, I guess just having enough of the runtime exposed as a C api that a separate library can "take control" of the runtime.  so if some other than usual engine is more appropriate for some section of code, control can be handed off for a time.

[20:25] <autrijus> it's supposed to be coupled with a backtracking runtime.

[20:25] <autrijus> (that can call back to p6)

[20:25] <autrijus> putter: well, yes, and PGE is upposed to be such a runtime.

[20:26] <putter> ah, good point.

[20:26] <putter> (Am I distracting you from sleep...:?)

[20:28] <putter> Hmm... a backtracking runtime...  I do like the sound of that.  Though I'm sure I don't understand the implications...

[20:28] * autrijus looks at this code from Success.curry and smiles

[20:28] <autrijus> choose (x:xs) = choosep x xs

[20:28] <autrijus>   where choosep x [] = x

[20:28] <autrijus>         choosep x (_:_) = x

[20:28] <autrijus>         choosep _ (x:xs) = choosep x xs

[20:28] <autrijus> do you see the bottom two cases that are fully overlapping?

[20:29] <autrijus> it chooses nondeterministically!

[20:29] <putter> ah. :)

[20:29] * putter tries to picture how to add probabilities...

[20:29] <autrijus> well, a backtracking runtime is just a fancy term for a runtime that supports full call/cc.

[20:30] <autrijus> putter: maybe by writing some case twice :)

[20:30] <putter> ;)

[20:31] <autrijus> however, I believe the idea is like junctions; you keep using it; it silently discards non-Success elements

[20:31] <autrijus> pretending it never chose them

[20:32] <putter> how do temps and call/cc interact?   (no pressing need to know, just musing)

[20:32] <autrijus> and when you inspect, the surviving one surfaces

[20:32] <autrijus> putter: how do temps and return() interact?

[20:32] <autrijus> oh, you mean the other direction, entering temp.

[20:32] <autrijus> I suspect nothing happens

[20:33] <autrijus> i.e. whatever old value was there, was there

[20:33] <putter> k

[20:33] <stevan> putter: the first version of Erlang was an interpreter built on top of Prolog

[20:33] <stevan> I bet you could do it for Perl 6 :)

[20:33] <putter> yes

[20:34] <putter> err, yes Erlang,  eeep for p6.

[20:34] <putter> prolog even has a portable object system at this point...

[20:35] <stevan> PIL -> Erlang would be cool

[20:36] <putter> Just guessing, but once PIL settles down, and as backends accumulate to use as prototypes, I kind of expect a not-small number of backends to suddenly appear.

[20:36] <stevan> How to write a Perl 6 backend in 24 hours - by putter

[20:36] <stevan> I would buy that book :P

[20:37] <autrijus> putter: I suspect such backends can only run the core imperative calculus -- well if the runtime is lucky, closures too

[20:37] <autrijus> but that's okay, as we plan to port everything else to p6 ;)

[20:37] <putter> It's just that once you have a working backend for language x, all the (invariably many) other languages with similar characteristics to x, can be backended with basically only transliteration - no great thought required.

[20:37] <autrijus> true.

[20:37] <autrijus> just look at Scheme.

[20:38] <autrijus> but I wouldn't use Perl6 to replace the source language in SICP ;)

[20:38] * putter was just this morning thinking in the shower that we need Cons and ConsProper roles...

[20:41] <integral> chapters 4&5 would be a wee bit tricky with perl6 ;-)

[20:41] <putter> I suspect we are reaaaally going to need, even more than p5 did, a cannonical/reference form of p6.  or perhaps instead java-like syntax/semantic policy checkers.  because p6 seems likely to be so very mutable, what is p6 seems likely to be a bit fuzzy.

[20:42] <putter> 4&5?  my ancient SICP is in a box... somewhere.

[20:43] <autrijus> putter: a canonical surface syntax you mean?

[20:43] <autrijus> i.e. PIL prettyprinter?

[20:43] <integral> (online at http://mitpress.mit.edu/sicp) chapters 4&5 are the ones where a metacircular interpreter and then a compiler are written

[20:43] <putter> btw, the structure and interpretation of classical mechanics is also a fun read.

[20:44] <autrijus> integral: ah, but you see, we are writing them gradually...

[20:44] <autrijus> it's just it may take 10x more pages

[20:44] <autrijus> but wait, the camel book is already like that.

[20:44] <integral> part of the beauty though is the conciseness of SICP

[20:44] <autrijus> indeed.

[20:44] <integral> in the camel it'd be chapters 50 through 60!

[20:45] <autrijus> beauty does not carry whipuptitude with it though :-/

[20:47] <putter> integral: and scheme's dirty little secret is it is sooo oft repeated very easy to write a metacircular interpreter, that no-one, in what, over 20 years?  a human generation?  has gotten around to writing a full one.  very frustrating.  I've a draft, SchemeOn, so you port a small core and a transliterator to, say (hypothetically you understand... not:) p6, and the rest of implementation is written in scheme.  but it required cobling toge

[20:47] <putter> ther pieces for all over the place.  scheme48++

[20:48] <integral> heh

[20:50] <putter> PIL will end up with very scheme-ish properties.  p6, ruby, cpan, etc, just end up being surface syntax and libraries.  ;)

[20:50] <autrijus> the binding semantics though is rich and not scheme, I think

[20:51] <autrijus> also, the type tags and constraints.

[20:51] <autrijus> to translate them into scheme is certainly fine but requires a partial runtime to handle that.

[20:52] <autrijus> and hence not neccessarily easily reuable by native scheme programs

[20:52] <putter> re prettyprinter, p5 already has the problem that everyone uses their own language-subset dialects, often mutually incomprehensible.  just as java punted macros to maintain the socially desirable property that people chould read other folks code, I think p6 will need anti-entropic tools less it gain a reputation for being even more unmaintainable than p5.

[20:53] <autrijus> ah, p6tidy?

[20:53] <putter> yes! :)

[20:53] <autrijus> how is it different from a customizable deparser?

[20:53] <putter> some of the java tools of this flavor are very customizable and powerful.

[20:53] <putter> (names escape me at the moment)

[20:54] <autrijus> I think java's machine-readability is a very good thing.

[20:54] <autrijus> as a result it's not very human-readable without machine support.

[20:54] <autrijus> but _everyone_ is using machine support, so that's fine.

[20:55] <putter> custom deparsers are a big part of it.  and probably sufficient.  theres also measuring the "distance" between some surface form and a reference (deparsed) form.

[20:55] <autrijus> nod.

[20:55] * autrijus is looking forward to refactoring browsers for p6 in p6.

[20:56] <putter> p6 meets intentional programming, now there's a slightly scare thought.

[20:56] * putter too

[20:56] <stevan> ooohhh intentional programming... Lucid++

[20:57] <putter> though a backend for emacs (to handle refactoring and tagging) would make me even happier.

[20:57] <putter> a refactoring engine for p6.

[20:58] <putter> generates taged text in a form which can be efficiently sucked into emacs, which then makes requests out to the engine, and repeat.

[20:59] <putter> I had a multilingual programming environment where one could tell emacs, ok, make this ruby instead (of perl)... called out, code regenerated, emacs buffers renamed and updated, and zap, all the code changed form.  most fun.

[21:00] <putter> http://merd.sourceforge.net/pixel/language-study/syntax-across-languages/   pixel++

[21:01] <putter> couple of other pages like it too, if anyone is interested.

[21:06] <svnbot6> r6094 | Stevan++ | Perl6::MetaModel - (p5)

[21:06] <svnbot6> r6094 | Stevan++ | * $?CLASS now returns the ::Class object

[21:06] <svnbot6> r6094 | Stevan++ | * all methods and attributes are now associated with the ::Class object

[21:06] <svnbot6> r6094 | Stevan++ |   instead of just the class name

[21:06] <svnbot6> r6094 | Stevan++ | * improved the name of ::get_obj_id to ::get_P6opaque_instance_id so that

[21:06] <svnbot6> r6094 | Stevan++ |   no one will try to use it :P

[21:06] <svnbot6> r6094 | Stevan++ | * also added ::get_P6opaque_instance_class to peek into the class slot 

[21:06] <svnbot6> r6094 | Stevan++ |   (needed this for submethods)

[21:07] <putter> mugwump: did you see my note about Scriptalicious failing to install out of CPAN.  is it something you think will be fixed, or should we back it out of crude_repl?

[21:12] <putter> sigh.  parrot 0.2.3 has been released, but has parrotcode.org been updated?  you're joking, right? </end negitivity>

[21:13] <integral> someone should just allow leo to edit the site :-/

[21:14] <putter> (anarchistic development)++

[21:15] <autrijus> or, do what pugscode.org doe

[21:15] <autrijus> does

[21:15] <autrijus> and contain minimal information from the homepage :)

[21:15] <Khisanth> hmm

[21:15] <Khisanth> integral: it should update itself using the ML :)

[21:15] <putter> yes.  far better to have no info than wrong info.  (classical argument against source code comments;)

[21:16] <autrijus> and I think people are better subscribing to any of the ML's RSS, or CPAN's, or even the Kwiki's

[21:16] <autrijus> (or the commit log)

[21:17] <putter> pity the web never developed a pervasive annotation mechanism.

[21:17] <autrijus> than periodically checking the homepage.

[21:17] <autrijus> you mean like annozilla and annotea?

[21:17] <autrijus> it's W3C standard and all that

[21:18] <autrijus> so the "developed" one is check. now, "pervasive" ;)

[21:18] <putter> annozilla and annotea?  ?  I'm afraid I have no idea what exists now... been a while since I looked at it.

[21:18] <putter> ;)

[21:18] <autrijus> but annotea is 2001 :)

[21:19] <putter> "been a while" == mid to late '90's. ;)

[21:19] <autrijus> oh wow.

[21:19] <putter> sigh.

[21:19] * autrijus suspects putter is older than appeared

[21:19] * putter suddenly feels very very old.

[21:22] <coral> wow, annotea

[21:22] * coral wakes up briefly

[21:22] * autrijus , however, goes to sleep &

[21:22] <autrijus> g'nite :)

[21:23] <putter> timbl was next door (had to walk through my office to get to his) when he first came to MIT LCS.  cautionary tale - get things you care about right in "the beginning".  as viscosity sets it, things defered just dont happen, even on a timescale of decades.

[21:23] <putter> g'night.

[21:25] * autrijus mumbles something about metaprogramming oneself and goes back to sleep &

[21:25] <putter> lol

[21:25] <putter> (for quite a while;)

[21:27] <putter> what things do we want p6 to have that might "just not happen"...  runtime flexibility more like ruby than p5... real ML/haskell-like typesystem... ...?

[21:28] <autrijus> sigh. I should've closed this window already. I think both will most likely happen :)

[21:29] <putter> :)

[21:29] <autrijus> what will not happen are mostly arbitary restrictions.

[21:29] <autrijus> even for the user's own good.

[21:29] <putter> ;)

[21:30] * putter tiptoes quietly away from computer.  good night autrijus...

[21:38] * Aankhen`` goes to sleep.

[21:38] <Aankhen``> G'night.

[21:41] <putter> &

[21:45] <putter> What's a good definition for PIL... http://pugs.kwiki.org/?Perl6Nomenclature doesnt have one yet...

[22:02] <putter> It might be worth upgrading to PCRE 6.1 (my fuzzy impression is we are still at 5.0?) for the \w and windows nl fixes.

[22:03] <coral> perl5 -> perl6; perl6 -> js; js -> greasemonkey

[22:03] <putter> Yipes.  my Compiling Pugs.Run is up to 20 cpu minutes.  was hovering around 5 recently.

[22:04] <putter> "up to" as in still running...

[22:04] <coral> is there a perl implementation of ccache?

[22:04] <coral> or shell

[22:04] <putter> ;)

[22:04] <autrijus> putter: Pugs Intermediate Language.

[22:04] <coral> ship it with the build system along with a directory of precompiled hints for the popular OS

[22:04] <autrijus> well, so much for sleeping.

[22:04] * autrijus decides sleep is overrated anyway

[22:05] <putter> erg.  that better have been typing in your sleep!!! ;-)

[22:05] <putter> sleep == clock speed

[22:05] <Khisanth> so much for being a cyborg :)

[22:05] <autrijus> riight.

[22:05] <coral> autrijus: dream well

[22:05] * autrijus counts electric sheeps

[22:06] <autrijus> but seriously, it's past 6am, and I need to be up at 9, so skipping sleep is looking more attractive

[22:06] * autrijus decides to 1)find food and 2)hack

[22:07] <wilx> Huh, even 3 hours of sleep are better than nothing.

[22:07] <wilx> At least for me it works.

[22:08] <autrijus> the precondition is that you are 1)actually sleepy and 2)not hungry

[22:08] <autrijus> sadly I'm neither currently

[22:08] <putter> coral: a standard perl caching system would also address one of the primary problems with Inline:: for compiled langauges.

[22:08] * autrijus food &

[22:09] <putter> &

[22:09] <putter> coral++ # building caching build system ;)

[22:14] <coral> i am very bad at implementing things still

[22:14] <coral> the ADD is yet unfocused in this one

[22:15] <coral> "ADD" of course

[22:15] * coral searches for a pugs web proxy

[22:21] <coral> hello ascii art on startup. very nice.

[22:25] <putter> so, my search was brief, but I didn't turn up a non-C/C++ compiler cache system.  IMHO, one would be very useful.

[22:26] <putter> There are a couple of C/C++ ones it could be modeled on...

[22:26] <putter> coral: no pressure.  just thought I'd flag this as a very neat idea.  coral++

[22:27] <coral> heh, no worries

[22:29] <coral> ship a diff between the distributed file and a hash of the configure.cache equivalent

[22:29] <coral> compression will eat that up

[22:29] <coral> it does require updating the cache file as more platform hashes are accepted

[22:30] <coral> or pregenerate a set and do new releases

[22:38] <coral> iBlech++ # POE

[22:47] <autrijus> chip talked about a new ruling forming.

[22:48] <autrijus> multi f (Int $x) {}

[22:48] <autrijus> multi f (Num $x) {}

[22:48] <autrijus> then:

[22:48] <chip> plural.  "variants"

[22:48] <autrijus> &f.variants(Num);

[22:48] <chip> yesah

[22:48] <autrijus> which may still return a multisub

[22:48] <autrijus> which is in alignment with both pugs and parrot.

[22:48] <chip> thing is, Larry still ponders the possibility of:

[22:48] <chip> a present participle instead

[22:49] <autrijus> anyway. it doesn't replace &f:(Num) in signatures

[22:49] <autrijus> and it doesn't respect return types.

[22:49] <autrijus> so, more clarification needed.

[22:49] <autrijus> but I think as a selector/narrower it's very good.

[22:50] <autrijus> I propose that we keep the &f:(Num) form in signatures.  either that, or have a "takes" trait.

[22:50] <chip> Larry is saying roughly the same here.  :() is gone as a multisub limiter, but remains as a more precise code type declaration

[22:51] <autrijus> sub f (Code &g takes (Num, Int) returns (Int, Num))

[22:51] <autrijus> (&g:(Num, Int) returns (Int, Num)) is fine with me too.

[22:52] <autrijus> note that all this, like .variants, treats return types as distinct from parameter types, which may be a problem if you want to talk about an abstract type that is Int->Int.

[22:53] <autrijus> so I propose stealing the type operator ->.... &g:((Num, Int) -> (Int, Num))

[22:53] <autrijus> but other ways are acceptable too.

[22:53] <chip> Larry is suggesting --> for a similar purpose

[22:54] <chip> I think IRC typed by a person who doesn't understand the whole history (i.e. me) is not the best way to communicate this.  Grr

[22:54] <autrijus> get larry to #perl6 :)

[22:54] <autrijus> I'm fine with --> if only because we use -> as the prefix sub constructor instead of the separator between params and body.

[22:54] <chip> Damian's about to write on the whiteboard.  Stand by

[22:54] <autrijus> k.

[22:55] <autrijus> do I get a skype feed?

[22:55] <autrijus> nvm if it's too much trouble.

[22:57] <autrijus> I wonder if damian will be around after YAPC::AU and whether I can work with him for a few days.

[22:57] <svnbot6> r6095 | putter++ | Undisabled a number of rules tests.  Moved t_disabled/rules/from_perl6_rules/temp_moved_here_because_pge_doesnt_work_atm/ back to t/rules/from_perl6_rules/, and modified the tests to all be well behaved with parrot-0.2.3.

[22:57] <autrijus> putter++ # yay PGE reunified with pugs tests

[22:59] <brentdax> Cabal meeting right now?

[22:59] <autrijus> looks like so. not sure who is present

[23:00] <brentdax> Nifty.

[23:00] <chip> Larry, Damian, Allison, chromatic, lucs, pmichaud, Dan Kogai, and yours truly

[23:00] <knewt> 'lo chip

[23:00] <chip> hosdy

[23:00] <chip> Not a ruling now but a discussion

[23:00] <autrijus> ah, kogan-san is there. nice

[23:00] <autrijus> kogai, even.

[23:00] <chip> sub f (Int) returns Str {...}   # NO TYPE INFERENCE

[23:01] <chip> then someday, maybe possibly, maybe maybe:

[23:01] <chip> sub f (Int --> Str) { ... } # Type Inference

[23:01] <autrijus> er, sure, you wrote out types, then surely no inference.

[23:01] <chip> autrijus: hey, I'm  with you

[23:01] <autrijus> wait!

[23:01] <autrijus> no type inference means

[23:01] <autrijus> f(3) + 4;

[23:02] <autrijus> compiler is not allowed to warn Str+Int mismatch?

[23:02] <autrijus> that's insanity.

[23:02] <autrijus> it'll be like perl5 ;)

[23:02] <autrijus> (where "strings used as numbers" is hard coded to literals)

[23:02] <autrijus> in the opcode themselves.

[23:02] <autrijus> and you can't have that behaviour to user defined subs

[23:02] <autrijus> so I hope I misunderstood the "no inference" thing there.

[23:04] <chip> Damian and I are both arguing this

[23:04] <autrijus> perl5 does inferencing, just very badly.

[23:05] <autrijus> to wit:

[23:06] <autrijus> $ perl -wce '$_ = 0 + "x"."y"'

[23:06] <autrijus> Argument "x" isn't numeric in addition (+) at -e line 1.

[23:06] <autrijus> $ perl -wce '$_ = 0 + reverse("x")'

[23:06] <autrijus> -e syntax OK

[23:06] <chip> back.

[23:06] <autrijus> $ perl -wce '$_ = 0 + ("x"x3)'

[23:06] <autrijus> -e syntax OK

[23:06] <autrijus> clearly either all of them should warn

[23:06] <autrijus> or none of them should.

[23:07] * autrijus waits for the other end of the world to type back

[23:08] <chip> OK.  consensus.

[23:08] <autrijus> good.

[23:08] <chip> is forming.

[23:08] * autrijus waits some more.

[23:08] <chip> syntax #1:   sub foo (Int) returns Str

[23:08] <chip> syntax #2:  sub foo (Int --> Str)

[23:09] <chip> syntax #3:   my Str sub foo (Int)

[23:09] <chip> syntax #1 does not enable inference; it says "the return(s) in this subroutine will all accept Str values".  It's a private note, like "is cached".

[23:10] <autrijus> so it does typecheck inside function body's return()

[23:10] <autrijus> but not propagate outside the function

[23:10] <chip> syntaxes #2 & #3 are equivalent and enable inference.  They make the Str return part of the signature.

[23:10] <chip> correct

[23:10] <autrijus> good. very nice.

[23:10] <autrijus> the "returns" then is more like specifying the parameter type of &return.

[23:11] <autrijus> do we get named returns?

[23:11] <autrijus> sub foo (Int $x --> Str $y) {...}

[23:11] <autrijus> my $y := foo(1);

[23:11] <autrijus> more precisely, that will unify the return side Cxt form and the param side Param form in Binding.

[23:12] <autrijus> sub f (() --> Int $x, Int $y); my ($x, $y) := f();

[23:12] <autrijus> it's a promise to return properly named pairs.

[23:13] <autrijus> so that &return can have a signature that resemblesnormal functions.

[23:14] <autrijus> (I already unified them in PIL2, so the question is whether I should hide this from user.)

[23:14] <chip> Larry: "If it happens to fall out of the implementation easily, then I'm sure Damian will find a use for it.  But let's not document it."

[23:14] <autrijus> okay.

[23:15] <chip> Personally, I like it, but Larry seems to be at the extent of his orthogonality tolerance for the afternoon

[23:16] <autrijus> *nod* just that it's not frowned against is good enough.

[23:16] <chip> ok

[23:18] <autrijus> it's not high priority, but I'd like to know whether this is legal:

[23:18] <autrijus> sub f ($x) { my $y; $x := $y; }

[23:18] <autrijus> that is, whether you are allowed to rebind an "is constant" container.

[23:19] <autrijus> my intuition is no, but that doesn't seem to be documented.

[23:19] <autrijus> on the other hand, I expect this to be okay: (my $x := 3; $x := 4;)

[23:19] <svnbot6> r6096 | putter++ | lib/pugs/hack.pod: Added notes on testing regexp engines.

[23:20] <brentdax> autrijus: I *seem* to remember it was yes, but that was probably a long time ago.

[23:20] <autrijus> brentdax: yes, as in "is constant" doesn't prevent rebinding?

[23:21] <autrijus> brentdax: http://pugscode.org/images/container.png # context picture

[23:21] <brentdax> Right, last I heard you can rebind an 'is constant'.

[23:21] <chip> My opinion: $x is an alias through which writing is not permitted.  The target of the alias cannot be modified through $x, but $x belongs to the scope, and I see no reason why you couldn't change what $x is a front for.

[23:23] <autrijus> chip: then your view coincides with the container.png.

[23:23] <autrijus> it also means that annotations can't really be trusted by the compiler as a userspace rebind can wreck all havoc :)

[23:24] <coral> heh, that sounds like the kind of thing i usually support

[23:25] <autrijus> and p5 does allow it to the fullest extent

[23:25] <autrijus> especially if you consider Data::Swap.

[23:25] <autrijus> my $x is constant = 4; my $y; $x := $y; $x = 5; # works

[23:25] <autrijus> that's fine with me if that's fine with you.

[23:26] <autrijus> that however means no constant folding for $x.

[23:26] <autrijus> not in sight of potential := and eval, at least.

[23:26] <brentdax> So it's an eval-dependent optimization.  The compiler can figure out if it can optimize it by checking for an explicit rebind or the use of `eval` or other dangerous stuff.  Perl has always had a lot of features like that.

[23:27] <brentdax> (And the user can presumably use a pragma to tell it to optimize anyway.)

[23:29] <autrijus> very true.

[23:29] <autrijus> anyway, if "is constant" is rebindable, then I don't need to do much about my container implementation :)

[23:30] <autrijus> I was worrying whether it's a flaw.

[23:30] <autrijus> (and when it's rebound, then all its previous traits are lost, and it assume the newly bound container's traits)

[23:31] <brentdax> Scary thought: `eval "multi sub postcircumfix:<( )> (&code : *@_) { die 'fnord' }"`

[23:31] <autrijus> brentdax: you realize that it does not affect any existing code?

[23:32] <autrijus> only things that is subsequently eval""'ed in that package scope

[23:32] <autrijus> so the damage is much smaller

[23:32] <brentdax> True, I suppose.

[23:34] <brentdax> (hmm...imagine wrapping *postcircumfix:<( )> at BEGIN time to get a free call-tracing mechanism...)

[23:35] <autrijus> still only for your current module.

[23:35] * autrijus praises the separate compilation doctrine.

[23:36] <autrijus> i.e. by "use CGI" you are using a precompile CGI that starts from nothing

[23:36] <autrijus> "require CGI" too. the only way to avoid it is to read it in and eval and etc.

[23:36] <brentdax> Can you export it to the including module to implement a `use trace`?

[23:36] <chip> 'userspace rebind wreaking havoc' ... hm.  that's bad.

[23:36] <autrijus> chip: in the synopsis:

[23:36] <autrijus> my $pi = 3;

[23:36] <autrijus> er

[23:36] <autrijus> my $pi is constant = 3;

[23:36] <autrijus> but that only means it can't be assigned to

[23:36] <autrijus> nothing prevents

[23:36] <autrijus> $pi := 4;

[23:37] <autrijus> although that can be contrued as feature

[23:37] <chip> quite. pity

[23:37] <chip> nothing is really unchangeable

[23:37] <autrijus> (and if := is intended to be a preservation of glob semantic, then that's certainly true.)

[23:37] <autrijus> *pi = \3; *pi = \4; # sure why not

[23:39] <autrijus> oh btw

[23:39] <autrijus> my $pi is constant = 3;

[23:39] <autrijus> this is very very special form, right?

[23:39] <chip> We briefly discussed the problem of Pairs appearing anywhere, that named arguments have no zone.  However, no improvements arose that seemed worth the trouble.

[23:39] <autrijus> my $pi := 3; # special form for this

[23:39] <chip> Nobody seemed happy with that, though.

[23:39] <autrijus> my $pi is constant(3); # or this?

[23:40] <chip> ew

[23:40] <autrijus> (the synopsis has the assignment form which can't possibly work.)

[23:40] <autrijus> (except by declaring it as a special form.)

[23:41] <chip> especially considering $a = { :x(1), :y(2) };  somefunc(*$a);

[23:41] * chip didn't realize that *$a was legal, but in retrospect it seems obvious

[23:43] <autrijus> I thought *$a was only legal if $a isa Pair, but obviously it can now be a Hash or Array too

[23:43] <chip> well, actually, that could be my error

[23:43] <autrijus> ok.

[23:43] <chip> what's $a = :x(1);  foo(*$a) mean?

[23:44] <autrijus> supposedly, same as foo(:x(1)).

[23:44] <autrijus> at least that's my impression at the hackathon.

[23:44] <chip> and how is that idfferent from foo($a)?

[23:44] <autrijus> that is different if the function is expecting Any or Pair.

[23:45] <chip> _sign_

[23:45] <chip> _sigh_ even

[23:45] <autrijus> oh. in my PIL formulation I have Pair's key as a value not a container -- i.e. you can never use $pair.key as lvalue

[23:45] <autrijus> sane?

[23:46] <chip> I'll ask when they're changing subjects.  Right now, Larry & Dan Kogai are talking Unicode

[23:46] <autrijus> oh, good

[23:47] <autrijus> did Kogai look at Dan's unicode string design for parrot from way back?

[23:47] <chip> they're much more abstract now, about policies etc.

[23:47] <autrijus> ah. unicode support levels?

[23:47] <autrijus> non-unicode context?

[23:47] <chip> "Do we need to be careful about which Unicode chars we can use for sigils?"

[23:47] <chip> "How about decomposition for string comparison?"

[23:48] <autrijus> I thought sigils are a fixed set and you can't introduce more sigils :)

[23:48] <chip> I figured there was a sigil:<> thing I hadn't heard about

[23:48] <autrijus> eh.

[23:49] <chip> don't worry about it, Larry seemed to think the question was unworrying

[23:49] <autrijus> I can't start to imagine what it does ;)

[23:49] <brentdax> Drives the implementor bat-*** insane, obviously.

[23:49] <chip> Mixing Hebrew with English.   $YHWH = 'almighty';  but if YHWH are Hebrew, should they be right-to-left?

[23:50] <autrijus> I thought that's what RTL markers and the display layer is for.

[23:50] <chip> Larry seems to have just remembered that.  :-)

[23:50] <autrijus> good. a very bad thing is unicode language tags.

[23:50] <autrijus> I suggest we pretend they don't exist.

[23:51] <chip> I won't mention them if you don't.

[23:51] <autrijus> (it's a block of character that let you write down "en-us")

[23:51] <autrijus> and then declare the text afterward as english.

[23:51] <autrijus> oh, no, I want it mentioned, and then ruled as ignorable :)

[23:52] <autrijus> (j/k... doesn't really need to bring that up.)

[23:53] * autrijus ponders what's the associativity of -->.

[23:53] <autrijus> sub f ($x --> $y --> $z)

[23:54] <autrijus> nonassoc seems like prudent.

[23:54] <chip> mm

[23:54] <autrijus> either that, or rightassoc.

[23:54] <autrijus> rightassoc will then enable combinator style programs ;)

[23:54] <autrijus> "everything is curried"

[23:55] <chip> Don't do that.  I'll have to get medieval on your, um, pugs.

[23:55] <autrijus> heh, it's occasionally useful and more handy than .assuming :)

[23:55] <autrijus> plus, it likely runs much faster than .assuming on parrot.

[23:56] <chip> time's up here

[23:56] <autrijus> *nod*

[23:56] <chip> we'll be back at 9am or so, US/Pacific

[23:56] <autrijus> I'll have it at right assoc for now.

[23:56] <autrijus> what's your localtime?

[23:56] <chip> 17:00

[23:56] <autrijus> okay. have fun :)

[23:56] <chip> a-firmative :-)

[23:58] <brentdax> We now return to your regularly scheduled hacking...

[23:58] * brentdax continues working on WWW::Kontent::Class::Setting.

