[00:00] <Juerd> Like $temp, which I'd call $input here, because it will contain the user's input, and only that...

[00:02] <Juerd>         unless ($choice eq 'f') {

[00:02] <Juerd>                 say "The $enemy.name() is dead!" ;

[00:02] <Juerd>            return 1;

[00:02] <Juerd>                   }

[00:02] <Juerd> How can someone work with indentation like that?

[00:02] <mauke> hmm, incompatible tabstop settings?

[00:04] <wolverian> tabstop? hard tabs? WHAT?

[00:04] <svnbot6> r4019, naesten++ | "Yet Another Haskell Tutorial" was written by Hal Daume III, not II

[00:05] <Juerd> Ah, yes.

[00:05] <Juerd> With ts=3, it's somewhat neater

[00:05] <Juerd> BUT

[00:05] <SamB> oh rats, I should have used SamB for my username...

[00:05] <autrijus> greetings.

[00:05] <Juerd> Don't mix tabs with spaces unless your tabs are 8 spaces

[00:05] <Juerd> And... don't use tabs, damnit.

[00:05] <wolverian> Juerd++

[00:06] <Juerd> The tab *key* is wonderful

[00:06] <Juerd> The tab *character* is not.

[00:06] <mauke> Juerd-- (I use tabs all the time)

[00:06] <Juerd> mauke--  # uses tabs.

[00:06] <kelan> tabs save space!

[00:06] <wolverian> argh, flamewar :)

[00:06] <mauke> but I don't mix them with spaces

[00:06] <Juerd> kelan: gzip saves space. I don't see you gzipping all your sources.

[00:06] <kelan> i can get 8 characters of space with just one character!

[00:06] <kelan> sure i do

[00:06] <kelan> compressed partition!

[00:06] <Juerd> I don't see you do it.

[00:07] <kelan> actually i don't use tabs either

[00:07] <kelan> i have vim convert them to spaces

[00:07] <Juerd> expandtab++

[00:07] <kelan> yes

[00:07] <Juerd> expandtab phone home.

[00:07] <wolverian> vim++ # makes things easy

[00:07] <mauke> # vi: set ts=4 sw=4 noet:

[00:08] <kelan> why not have 'yes' versions of the 'no' options? ':set yesexpandtab'

[00:08] <mauke> to save space

[00:08] <kelan> and just to be polite, add a please

[00:08] <wolverian> haha.

[00:08] <kelan> :set yesexpandtabplease

[00:08] <mauke> kelan: do you know INTERCAL?

[00:08] <kelan> no:(

[00:09] <kelan> but i've heard of it

[00:09] <kelan> COMEFROM

[00:09] <Juerd> kelan: Because in English, the word "no" (meaning 0) has no opposite.

[00:09] <kelan> hww

[00:09] <Juerd> Same for not.

[00:09] <kelan> er hmm

[00:09] <kelan> some!

[00:09] <Juerd> No, that's not an opposite.

[00:10] <kelan> :set someexpandtabs

[00:10] <kelan> hmm

[00:10] <Juerd> In Dutch (and it's almost the same in German), we have "wel", an opposite of "niet"

[00:10] <mauke> kelan: http://www.ofb.net/~jlm/rot13.i

[00:10] <Juerd> English:

[00:10] * SamB needs to seriously consider changing his irc nickname to naesten

[00:10] <Juerd> "I'm not doing it" - "But I *am* doing it"

[00:10] <Juerd> Dutch:

[00:10] <Juerd> "Ik doe het niet" - "Maar ik doe het wel"

[00:10] <Juerd> We stress the "wel" part, not the verb.

[00:11] <kelan> PLEASE FORGET #2

[00:11] <mauke> hmm, there should be something like c_space_errors for perl

[00:11] <wolverian> same in finnish. it's only used when whether the action will be done at all is questioned

[00:11] <chromatic> traverse_weak_ptr_list: not WEAK?

[00:12] <Juerd> wolverian: Yes

[00:12] <autrijus> SamB: you can register another SamB account and I'll add it to the committer list :)

[00:12] <Juerd> wolverian: Well, in Dutch it also has some other meaning, that I don't know how to translate

[00:12] <SamB> autrijus: oh, is that allowed?

[00:12] <autrijus> SamB: or, you can renick to naesten. make a decision :)

[00:12] <kelan> Juerd: take a sentence like, "I have no apples." would you use 'wel' to say the opposite?

[00:12] <autrijus> SamB: sure, of course... you need to pick another email though

[00:12] <Juerd> wolverian: "Dan doe ik het wel", with "ik" stressed, means "Then I'll do it". But imagine rolling eyes during saying this.

[00:13] <Juerd> kelan: Yes.

[00:13] <SamB> oh

[00:13] <Juerd> kelan: "I have no apples." - "I have (wel) apples"

[00:13] <wolverian> Juerd: hm. what does the rolling of eyes signify? 

[00:13] <kelan> right

[00:13] <kelan> that seems useful

[00:13] <Juerd> kelan: But as you have no opposite for "no", you can only stress an auxillary verb

[00:13] <kelan> we should have it!

[00:13] <Juerd> kelan: Turning your sentence into "I *do* have apples."

[00:13] * SamB wishes he could rename the user he has...

[00:13] <kelan> :set welexpandtabs

[00:14] <Juerd> "I *have* apples" is syntactically correct, but sounds weird.

[00:14] <autrijus> SamB: alright, let me invoke the SysOp power...

[00:14] <wolverian> Juerd: is wel used as a more powerful form of affirmative, or is it the common affirmative?

[00:14] <chromatic> autrijus, I'm seeing GC errors in t/oo/destruction.t.

[00:14] <autrijus> chromatic: hm?

[00:14] <svnbot6> r4020, chromatic++ | Test order of DESTROYALL calls.

[00:15] <Juerd> wolverian: Depends on stress

[00:15] <kelan> chromatic: did you get finalizers working?

[00:15] <Juerd> wolverian: It's not used unless to contradict the opposite.

[00:15] <Juerd> s/unless/except/

[00:15] <wolverian> Juerd: ok.

[00:15] <wolverian> Juerd: can you say the phrase above about apples without wel?

[00:16] <chromatic> I did, but now GHC gives an error about apparently finding a non-weak pointer as it's trying to traverse a list of weak pointers.

[00:16] <autrijus> SamB: you are SamB now.

[00:16] <Juerd> That'd just be "I have apples."

[00:16] <autrijus> SamB: try commit

[00:16] <autrijus> something

[00:16] <chromatic> I just checked in a new t/oo/destruction.t.  Does it pass for anyone else?

[00:16] <Juerd> With no indication left of someone else not having apples.

[00:16] <autrijus> I'm seeing

[00:16] <autrijus> pugs: internal error: EVACUATED object entered!

[00:17] <autrijus> sounds dangerous

[00:17] <autrijus> I know why that happens. sec

[00:17] <autrijus> (it's triggering a GC run during unsafePerformIO)

[00:17] <autrijus> (something that is almost certain doom)

[00:17] <Juerd> Also, "ik *heb* wel appels, maar ik verkoop ze niet" (I *have* apples, but I'm not selling them)

[00:18] <Juerd> Here "wel" is used for the contrast with the "niet" in the second part.

[00:18] <wolverian> Juerd: oh, with wel it indicates that you are the only one with apples?

[00:18] <Juerd> Not to contrast with someone not having apples.

[00:18] <chromatic> Yay, certain doom!

[00:18] <Juerd> wolverian: Of two people, likely.

[00:18] <kelan> Juerd: kind of like "I have apples, yes, but I'm not selling them."

[00:18] <wolverian> Juerd: it's actually the exact same in finnish, now that I think about it. 

[00:18] <wolverian> weird. :)

[00:19] <kelan> that does sound a bit odd in english tho

[00:19] <Juerd> wolverian: Or, if you see not having apples as an insult: "You have no apples! | Jij hebt geen appels!", the reply would be a strong "I DO have apples! | Ik heb WEL appels!".

[00:19] <Juerd> This is the entire problem with Perl 6's true.

[00:19] <Juerd> No, true is a BAD name.

[00:20] <wolverian> finnish would stress the 'do', but still also (optionally, but commonly) have the 'wel'

[00:20] <kelan> it *is* an insult to have no apples!

[00:20] <Juerd> It's the worst keyword Perl 6 has.

[00:20] <kelan> okay, what is true used for

[00:20] <Juerd> kelan: opposite of not

[00:20] <kelan> i didn't understand that whole list thread

[00:20] <autrijus> kelan: when true

[00:20] <wolverian> (finnish 'wel' is 'kyllÃ¤', which also is the finnish word for 'yes')

[00:20] <Juerd> I suggest we use 'wel' :)

[00:21] <wolverian> that's almost sensible.

[00:21] <Juerd> $foo = wel $bar;

[00:21] <wolverian> when there is no good equivalent, make up a new one.

[00:21] <Juerd> It's as short as not :)

[00:21] <Juerd> It's as short as "not" :)

[00:21] <Juerd> (It's not as short as it isn't short.)

[00:21] <Juerd> (It is short, the "as ..." is not "because ...")

[00:22] <kelan> Juerd: but isnt `true(anything)` the same as `?anything` ?

[00:22] <Juerd> ENGLISH SUCKS

[00:22] <wolverian> did anyone suggest 'yes' in the thread? :)

[00:22] <Juerd> kelan: Yes.

[00:22] <kelan> then is it just for completeness?

[00:22] <wolverian> kelan: the problem is that true is the opposite of false, not 'not'

[00:22] <Juerd> kelan: Yes.

[00:22] <wolverian> kelan: yes, just like 'not' is.

[00:22] <kelan> low precedence?

[00:22] <Juerd> kelan: Yes.

[00:23] <kelan> Juerd: i'm still not seeing the necessity. can you use it in a way that would matter?

[00:25] <kolibrie> I'm guessing I need $PUGS_EMBED=perl5 to get DBI support

[00:25] <kolibrie> but now I'm getting errors compiling Pugs.Embed.Perl5

[00:25] <autrijus> kolibrie: what errors?

[00:25] <kolibrie> first is:

[00:25] <kolibrie> /usr/lib/perl/5.8/CORE/reentr.h:611: error: field `_crypt_struct' has incomplete type

[00:26] <Juerd> kelan: Probably.

[00:26] <Juerd> kelan: I prefer low precedence ops anyway

[00:26] <autrijus> kolibrie: very weird. I do believe integral fixed it some time ago

[00:26] <kolibrie> autrijus: just pulled down 4020

[00:26] <wolverian> Juerd: aren't conversions to bool implicit, anyway?

[00:26] <autrijus> kolibrie: can you nopaste the full buildlog?

[00:26] <autrijus> kolibrie: including the ghc invocation line

[00:26] <Juerd> wolverian: Yes

[00:27] <wolverian> Juerd: then why have ops for them?

[00:27] <kolibrie> autrijus: yes

[00:27] <Juerd> wolverian: But as you say, true is in Perl 6 not the opposite of false.

[00:27] <Juerd> true can very well return false.

[00:27] <kolibrie> perlbot nopaste

[00:27] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[00:27] <Juerd> wolverian: To force boolean context

[00:27] <wolverian> Juerd: no, I mean; I don't get why you would explicitly need to force boolean context

[00:27] <Juerd> wolverian: not is useful to negate it, but !! is often used in perl 5 to force boolean context.

[00:27] <wolverian> I've never used it :)

[00:27] <Juerd> wolverian: Because you wish to unify the input.

[00:27] <Juerd> wolverian: Make it abstract.

[00:27] <wolverian> Juerd: then make the storage type bool?

[00:28] <wolverian> shouldn't that autocoerce?

[00:28] <Juerd> wolverian: And get rid of that 20 MB message that happens to be true.

[00:28] <Juerd> Yes, but nobody wants a certain language feature to require typing.

[00:28] <mauke> I only use !! for mapping nonzero numbers to 1

[00:28] <wolverian> Juerd: I guess. :)

[00:29] <wolverian> Juerd: to me, normalising _is_ typing

[00:29] <Juerd> To me, a scalar is a scalar

[00:29] <Juerd> wolverian: Type %foo<somesetting> for me.

[00:29] <Juerd> wolverian: Without typing %foo<anothersetting>

[00:29] <autrijus> chromatic: ok, I think I found the problem

[00:29] <Juerd> Afaik, there is no easy way to do that.

[00:30] <wolverian> but then it's not normalization, if you only normalize one thing and not the others :)

[00:30] <Juerd> %config.

[00:30] <chromatic> Nifty!  I'm about to check in another failing test then.  :)

[00:30] <svnbot6> r4021, autrijus++ | * (1 => 2 ?? 3 :: 4) now always constructs a pair, because Larry

[00:30] <svnbot6> r4021, autrijus++ |   ruled that => is the same precedence as = now.

[00:30] <svnbot6> r4021, autrijus++ |   ninereason++ for bringing it to my attention.

[00:30] <svnbot6> r4022, autrijus++ | * move GC to happen only when we are safely out of reach

[00:30] <svnbot6> r4022, autrijus++ |   of unsafePerformIO.

[00:30] <Juerd> Some settings are boolean

[00:30] <Juerd> It's nice if you can make them real bools asap

[00:30] <wolverian> hmm, good point

[00:30] <autrijus> chromatic: this test-driven thing is really nice :)

[00:31] <wolverian> there have been posts on p6l about typing arrays

[00:31] <wolverian> with different types per element

[00:31] <wolverian> dunno if any of that is official

[00:31] <Juerd> Now, with arrays, it doesn't make sense to have different types per element.

[00:31] <Juerd> As I told eric256, when things are unrelated, you're better off with a hash and names describing what things are.

[00:32] <Juerd> He had [ $accesskey, $description, $parameter ]

[00:32] <Juerd> But without names for any of these

[00:32] <Juerd> They were used as [0], [1] and [2]

[00:32] <mauke> I thought that's what structs are for :-)

[00:32] <Juerd> It would be much better to use a hash.

[00:32] <pasteling> "kolibrie" at 66.160.89.59 pasted "Pugs.Embed.Perl5 compile errors" (57 lines, 5.1K) at http://sial.org/pbot/10505

[00:32] <Juerd> mauke: Hashes are much simpler in many cases.

[00:32] <Juerd> But yes, if you need to type, then a struct works well.

[00:33] <Juerd> class Option { has $accesskey; has $description; has $parameter; }

[00:33] <chromatic> has $.?

[00:33] <Juerd> chromatic: My brain isn't accepting the wild asymmetry yet.

[00:34] <Juerd> And I think indicating duration with a sigil is unperlish.

[00:34] <chromatic> We'll domesticate it soon.

[00:34] <Juerd> So I tend to forget that dot.

[00:35] <Juerd> Sometimes on purpose. Not this time.

[00:36] <autrijus> kolibrie: I attempted a fix.

[00:36] <svnbot6> r4023, autrijus++ | * minor pod fix to use C<> in S29draft.

[00:36] <svnbot6> r4024, chromatic++ | Add tests for BUILD with signatures that don't map directly to attributes.

[00:36] <svnbot6> r4025, SamB++ | Add module Pugs.AST.Types to hold types from Pugs.AST.Internals

[00:36] <svnbot6> r4026, autrijus++ | * use double-quote in optl to be more portable

[00:36] <svnbot6> r4027, autrijus++ | * add ccflags too.

[00:36] <autrijus> kolibrie: try r4027?

[00:37] <kolibrie> autrijus: pulling now

[00:37] <mauke> man, and I thought emacs was supposed to be more customizable and less ad-hockish

[00:37] <Juerd> pugs> sub foo { ... } foo my $bar;

[00:37] <Juerd> *** Undeclared variable: "$bar"

[00:38] <autrijus> Juerd: my is currently statement:<my>

[00:38] <autrijus> I know it's wrong. it's todo.

[00:38] <Juerd> ok

[00:39] <Juerd> emaces MORE customizable?!

[00:39] <Juerd> s/ces/cs/

[00:39] <Juerd> One can write a news reader fori t.

[00:39] <mauke> that's just a SMOP

[00:39] <Juerd> Surely any editor feature can be implemented then.

[00:40] <mauke> yeah? try making it use the default cursor of my terminal

[00:41] <Juerd> Every operating system implements its own cursor.

[00:41] <Juerd> It's one of those things every OS programmer has to do

[00:41] <Juerd> Just like how every CGI monkey has to write their own parameter parser.

[00:41] <Juerd> e

[00:41] <svnbot6> r4028, chromatic++ | Tests for roles with submethods.

[00:42] <Juerd> Except the cursor is actually very useful to reimplement all the time.

[00:42] <mauke> I actually patched the C source to make it work "right"

[00:42] <autrijus> wow. I actually finished backlogging. journal up

[00:42] * autrijus is finding it harder and harder to keep up with every commit

[00:43] <chromatic> Only several thousand.

[00:44] <mauke> I think I've fixed all obvious emacs annoyances

[00:44] <mauke> now I want features like vim's "filetype indent on"

[00:45] <kolibrie> autrijus: same errors.  do I need to make realclean first?

[00:48] <Juerd> mauke: Are you trying to like emacs?

[00:49] <mauke> yes

[00:49] <wolverian> shouldn't Int.isa(Class) be true, and Int.isa(Int) false? or am I misunderstanding everything? :)

[00:49] <Juerd> mauke: I can only recommend vmware then ;)

[00:49] <chromatic> Yay, a test failure!

[00:50] <Juerd> wolverian: On syntax level, classes are not objects.

[00:50] <autrijus> kolibrie: no, just rerun makefile.pl should do

[00:50] <autrijus> kolibrie: hm, weird.

[00:50] <wolverian> Juerd: oh. that is weird.

[00:50] <autrijus> wolverian: I held the same misunderstanding too

[00:50] <autrijus> however!

[00:50] <Juerd> wolverian: Not really.

[00:50] <autrijus> foo(Int, Int)

[00:51] <autrijus> will dispatch to

[00:51] <autrijus> multi sub foo (Class, Class)

[00:51] <autrijus> not

[00:51] <autrijus> multi sub foo (Int, Int)

[00:51] <Juerd> wolverian: Otherwise Class.classmethod wouldn't work.

[00:51] <wolverian> autrijus: okay, that makes sense.

[00:51] <Juerd> wolverian: Otherwise SomeClass.classmethod wouldn't work.

[00:51] <Juerd> make better sense.

[00:51] <autrijus> so Int only stands for a class object when not used in invocant position.

[00:51] <autrijus> that is actually a pretty good argument for invocants.

[00:51] <wolverian> Juerd: why not?

[00:52] <Juerd> wolverian: Because Class has no &classmethod

[00:52] <autrijus> wolverian: consider CGI.new

[00:52] <autrijus> if CGI meant the CGI class object

[00:52] <autrijus> then it won't have the "new" method defined

[00:52] <autrijus> it will end up calling Class.new(::CGI)

[00:52] <wolverian> hmm. I thought the new would come from the metaclass.

[00:53] <autrijus> class Foo { method bar { 3 } }

[00:53] <autrijus> say Foo.bar;

[00:53] <svnbot6> r4029, chromatic++ | Tests for SUPER calls in methods declared in roles.

[00:53] <autrijus> we want it to print 3

[00:53] * chromatic remembers arguing for that a little while ago.

[00:53] <autrijus> (or not.)

[00:53] <autrijus> (but it's the way it's specced.)

[00:53] <kolibrie> autrijus: same errors...

[00:53] <kolibrie> shower &

[00:53] <autrijus> kolibrie: :-/

[00:53] <chromatic> autrijus, t/oo/roles/super.t has some interesting behavior.

[00:53] <autrijus> kolibrie: give me a shell or something?

[00:54] <kolibrie> on my computer?

[00:54] <chromatic> From his shower?

[00:54] <autrijus> hm. I remember theorbtwo had the same bug

[00:54] <autrijus> and he gave me a login

[00:54] <autrijus> so let me try that

[00:54] <wolverian> autrijus: I don't understand why that wouldn't work, frankly.

[00:54] <kolibrie> autrijus: one sec

[00:54] <wolverian> that is probably an indication that I'm not thinking straight.

[00:54] <autrijus> wolverian: so we have this ::Foo object

[00:54] <autrijus> wolverian: it is of class Class

[00:55] <wolverian> yes.

[00:55] <autrijus> now we invoke "bar" on it

[00:55] <autrijus> if it was a normal obj

[00:55] <autrijus> then it will just call its the "bar" method of its class

[00:55] <autrijus> namely Class.bar

[00:55] <autrijus> and passing it as inv

[00:55] <chromatic> my $CGI = DBI.new();

[00:56] <wolverian> ahh, now I see!

[00:56] <autrijus> :)

[00:56] <autrijus> now you can argue that the "bar" should be an _instance method_

[00:56] <autrijus> on the ::Foo metaobject

[00:56] <autrijus> distinct from its class methods and overriding them

[00:56] <autrijus> and I'd even be willing to agree.

[00:56] <wolverian> right, that's what I thought

[00:56] <autrijus> except it's not specced that way.

[00:56] <chromatic> That's awfully Self-ish, isn't it?

[00:56] <wolverian> that's logical!

[00:56] <autrijus> chromatic: yes and I think it's logical

[00:57] <autrijus> especially we now allow type arithmetic

[00:57] <autrijus> where you can write functions to calculate classes from classes

[00:57] <autrijus> and use them in dispatch via where{} clause

[00:57] <chromatic> There's just no syntax for saying "This method is okay to hoist into the appropriate metaclass".

[00:57] <autrijus> but. that will deviate from the Perl 5 tradition so much.

[00:57] <wolverian> autrijus: write about it on p6l? or is this set in stone?

[00:57] <autrijus> as an implementation monkey I don't really have a strong opinion :)

[00:58] <autrijus> wolverian: I don't feel strong enough to write p6l.

[00:58] <autrijus> s/strong/strongly/

[00:58] <wolverian> I just get a vague dread at Int.isa(Int)

[00:58] <svnbot6> r4030, Juerd++ | Example of better coding

[00:58] <wolverian> I don't know why exactly.

[00:59] <wolverian> (I haven't used OO enough to say.)

[00:59] <wolverian> I'm trying to say that I don't know how these systems differ in actual usage.

[00:59] <autrijus> $ perl -MDBI -e 'print DBI->isa("DBI")'

[00:59] <autrijus> 1

[00:59] <autrijus> wolverian: some people would like to test Int.isa(Num) 

[01:00] <chromatic> Even though they should use .does().

[01:00] <autrijus> same thing.

[01:00] <wolverian> autrijus: right. 

[01:00] <autrijus> instead of, say

[01:00] <chromatic> At some point though the semantics are important.

[01:00] <wolverian> Int.new.isa(Num) :)

[01:00] * Juerd wonders when inheritance is better than role stuff

[01:01] <autrijus> Int.new.isa(Num)

[01:01] <autrijus> yeah :)

[01:01] <Juerd> wolverian: DBI.new connects.

[01:01] <autrijus> actually

[01:01] <Juerd> Not every new is pure, and some you want impure.

[01:01] <wolverian> autrijus: so Int.meta.isa(Class)?

[01:01] <autrijus> Int.instance.isa(Num)

[01:01] <autrijus> wolverian: yeah

[01:01] <wolverian> or is that .meta.meta I want?

[01:01] <autrijus> the .instance thing is ruby.

[01:01] <autrijus> (singleton instance, aka class method, but not called that)

[01:02] <wolverian> right. I guess ruby's simplicity gets at you even after just a week or two of using it.

[01:02] <wolverian> (in the good sense. and the bad.)

[01:02] <autrijus> I should start writing some ruby :)

[01:03] <chromatic> Funny, the last code I wrote before Haskell was Ruby.

[01:03] <autrijus> :)

[01:03] <autrijus> I still think p6's type system is a mess :)

[01:03] <wolverian> I gave up after realising there's no built-in way to do Foo.new(named => 1, params => 2) and make it do accessors automatically. it just felt wrong not to have that built-in when the whole language is built around OO. but maybe that's just me and too much Attribute::Property. :p

[01:03] <svnbot6> r4031, Juerd++ | another variable name changed from meaningless name to descriptive of value

[01:03] <svnbot6> r4032, ninereasons++ | perl6.vim: capture vars and pod headers

[01:04] <autrijus> (a mess, as in the "specced in a vague self-contradictory way" sense)

[01:04] <autrijus> but at least I can help :)

[01:04] <wolverian> (note built-in versus do-it-yourself-with-meta-programming, which I did)

[01:04] <chromatic> autrijus, part of that is because no one really has experience defining a type system with the presence of actual roles.

[01:04] <autrijus> chromatic: Fortress!

[01:05] * autrijus thinks Fortress's got a sound design.

[01:05] <wolverian> does Fortress do this .isa thing differently?

[01:05] <autrijus> but it's all based on compile-time binding of types

[01:05] <chromatic> I feel a vague sense of unease, though, like in movie trailers that say "From the producers of <whichever Adam Sandler movie I didn't see last year>..."

[01:06] <autrijus> chromatic: you mean the Guy Steele name? :)

[01:06] <autrijus> wolverian: Fortress has typecasing!

[01:07] <wolverian> what is typecasing?

[01:07] <kolibrie> autrijus: log in so I can shower

[01:07] <autrijus> (MMD too)

[01:07] <chromatic> Yeah, the "Java is a lot like Lisp" thing bugs me.

[01:07] <autrijus> kolibrie: I didn't see login info..

[01:07] <kolibrie> e-mailed you

[01:07] <autrijus> oh ok

[01:08] <kolibrie> &

[01:09] <autrijus> wolverian: typecasing is a switch/case statement on the type of sometihng.

[01:09] <kelan> typecasting is when they only cast an actor for a certain type of role

[01:09] <kelan> and won't let him/her play anything else!

[01:10] <autrijus> given $obj { when Foo { ... } when Bar { ... } }

[01:10] <autrijus> but in p6 that is always runtime evaluated

[01:10] <autrijus> whereas in Fortress that is always compile time.

[01:10] <chromatic> Advance Polymorphism Substitute

[01:10] <autrijus> I think the problem is p5's type system is that

[01:10] <autrijus> Type == String

[01:11] <autrijus> so everything needs to happen at runtime

[01:11] <chromatic> When they compile that to real polymorphism, does the Vogon fleet sneak up on them again?

[01:11] <autrijus> but now p6 wants to move _something_ to compile time

[01:11] <autrijus> so that eg. unboxed types and compile-time mmd and context propagation works better

[01:11] <autrijus> but p6 also allows type-level arithmetic using Int|Str and :(...) 

[01:12] <autrijus> and I'm having a hard time figuring out how much of it can happen at compile time in a consistent manner ;)

[01:12] <autrijus> <- currently taking a "everything happens at runtime" attitude just to be 1)lazy 2)safe

[01:12] <autrijus> but that means we get almost no compile-time errors. not saying it's worse than p5 :)

[01:12] <chromatic> The last discussion I remember is that if you promise, at compile time, that you're not going to change the world at run time, you can optimize.

[01:13] <autrijus> chromatic: so how can we disallow

[01:13] <autrijus> eval ""'ing new subtypes

[01:13] <autrijus> or new mmds

[01:13] <autrijus> into existence?

[01:13] <autrijus> because once that happens, all type-level optimisation are off.

[01:14] <autrijus> consider

[01:14] <autrijus> eval '::int := ::str';

[01:14] <chromatic> The user has to promise that.

[01:14] <autrijus> yes. I'm asking how :)

[01:14] <kelan> use notypechangingpromise;

[01:14] <Juerd> $?USER will { ... };

[01:14] <chromatic> The last I remember (post-OSCON last year) was some sort of pragma to consider certain classes or modules closed or final or somesuch.

[01:15] <autrijus> that sentence is not of much help to this implementation monkey :)

[01:15] <PerlJam> chromatic: See Open vs. Closed Classes in S12

[01:15] * Juerd feeds autrijus bananas

[01:15] <chromatic> You know @Larry[0].

[01:16] <PerlJam> autrijus: you to.

[01:16] <PerlJam> er, too

[01:16] <Juerd> Good night!

[01:16] <chromatic> Ah, that's now how I remember it PerlJam, but thanks for the pointer.

[01:17] <chromatic> S12 *did* come out later.

[01:17] <autrijus> PerlJam: thanks!

[01:17] <wolverian> chromatic: no, you can only close and finalize _all_ classes

[01:17] <autrijus> mm optimize.pm and class.pm.

[01:17] <wolverian> not individual ones.

[01:17] <autrijus> I wonder if that line will join

[01:17] <autrijus> use strict;

[01:17] <autrijus> or

[01:18] <autrijus> 10 RANDOMIZER TIMER

[01:18] <autrijus> as something that is mandatory ;)

[01:18] <autrijus> (by convention, that is)

[01:18] <Juerd> Or, *horrible*, $|++.

[01:18] <autrijus> that too.

[01:18] <PerlJam> autrijus: I don't think so.  

[01:18] <Juerd> Which is a BAD default.

[01:19] <kelan> why do people write $|++ instead of $|=1?

[01:19] <PerlJam> kelan: because they can

[01:19] <Juerd> kelan: I have no idea.

[01:19] <kelan> the second is clearer to me: set this value

[01:19] <Juerd> cargo culting I guess.

[01:19] <kelan> not, increment buffering

[01:19] <autrijus> PerlJam: without that line, we can't do return type MMDs sensibly, and compile-time typechecking will be impossible

[01:20] <PerlJam> autrijus: so convince $Larry to make that the default  :)

[01:20] <autrijus> oh and we also can't compile "1+2" to use integer registers in Parrot.

[01:20] <autrijus> lots of things to lose ;)

[01:20] <autrijus> but that is actually a good argument for it not being the default

[01:20] <Juerd> Surely 1+2 is optimized at compile time to 3? :)

[01:20] <autrijus> since

[01:20] <wolverian> okay, time to sleep. 5am soon. :) cheers.

[01:21] <autrijus> Juerd: how do you know that one line above, the user won't eval another multisub + ?

[01:21] <Juerd> me sleep too

[01:21] <Juerd> bye

[01:21] <autrijus> Juerd: or redefine the int class?

[01:21] <Juerd> autrijus: Hm, ouch, that does hurt.

[01:21] <SamB> why does 1+2 have to do anything?

[01:21] <Juerd> Perl 6 can never be faster than 5 that way.

[01:21] <chromatic> optimize.pm is an optimization, that's why it's not the default.

[01:21] <Juerd> afk

[01:22] <autrijus> chromatic: er.

[01:22] <autrijus> itym "an optimization that changes semantic"

[01:22] <autrijus> if it doesn't, then it's always safe to make it default.

[01:22] <mauke> "it's easy to get the wrong answer in O(1) time"

[01:22] <autrijus> 42

[01:22] <SamB> Perl ought to be purely functional, then you wouldn't have all these problems!

[01:23] <autrijus> SamB: er, no. :)

[01:23] <PerlJam> SamB: we all know where to find Haskell :-)

[01:23] <autrijus> exactly.

[01:23] <chromatic> It's a lot more functional by not being purely functional.

[01:23] <autrijus> if there weren't Haskell or *ML, there may be a need to invent them.

[01:23] * SamB is kidding

[01:24] <chromatic> Yeah, he's kidding *now*.

[01:24] <chromatic> autrijus, there's an infinite loop in SUPER in roles.  See t/oo/roles/super.t.

[01:24] <autrijus> kolibrie: amazingly I'm building pugsembed fine on your machine

[01:24] <autrijus> perlembed even

[01:25] <autrijus> chromatic: roger. fixing

[01:25] <chromatic> Inheritance is the problem there I think.

[01:29] * PerlJam wanders off to write some perl6

[01:31] <autrijus> chromatic: yeah. it's resolving SUPER based on invocant.

[01:31] <autrijus> instead of class name.

[01:32] <chromatic> Easy mistake to make.  I did it in SUPER.pm myself.

[01:32] <autrijus> :)

[01:33] <autrijus> fixed. committing

[01:33] <chromatic> Just about everything of Test::Builder should work.  I added a couple of other test files that show off problems and there's one really odd thing that doens't make sense.

[01:33] <chromatic> s/ns/sn/

[01:33] <autrijus> which one? just this one?

[01:34] <autrijus> chromatic: are your writing some article about a working p6 Test::Builder module? :)

[01:34] <autrijus> r4033, btw.

[01:34] <chromatic> No, it's in the 020*t file.  It's complaining about not being able to find &Test::Builder::Test::Plan, which is odd.

[01:34] <svnbot6> r4033, autrijus++ | * chromatic++ noticed that ./SUPER::method() was looking

[01:34] <svnbot6> r4033, autrijus++ |   up SUPER from invocant, not the current class.

[01:35] <chromatic> It's in the Test::Builder::Test::Plan.new() call.

[01:35] <chromatic> Is there a length limit somewhere for identifiers?

[01:35] <autrijus> no.

[01:36] <autrijus> how stupid would that be :)

[01:36] <chromatic> Hey, I remember 1990.

[01:36] <chromatic> I have to go now though.  Thanks again.

[01:36] <autrijus> np :)

[01:36] <autrijus> kolibrie: it's complaining that it can't find -lperl

[01:37] <autrijus> and indeed there's only /usr/lib/libperl.so.5.8 not /usr/lib/libperl.so

[01:37] <autrijus> I manually tweaked the line to include /usr/lib/libperl.so.5.8 

[01:37] <kelan> i think standard C only recognizes the first 40 characters of an identifier for uniqueness

[01:37] <autrijus> look at ~autrijus/pugs/sh

[01:38] <mauke> kelan: which standard C?

[01:39] <kelan> um

[01:39] <kelan> dunno?

[01:39] <kelan> i just vaguely remember that

[01:39] <kelan> i havent used C in a long time

[01:39] <Khisanth> I thought that was only with OOOOOLD C compilers?

[01:40] <kelan> maybe it wasnt standard:)

[01:40] <kelan> could be

[01:40] <mauke> in C89 all you get is six characters

[01:40] <autrijus> kolibrie: but I didn't run into your build problem at all.

[01:40] <mauke> case insensitively

[01:40] <mauke> that's just the guaranteed minimum, of course

[01:40] <mauke> most compilers/linkers support more

[01:41] <kelan> after using visual basic for work, i actually like case insensitivity

[01:42] <mauke> ew

[01:42] <kelan> why would you possibly need two variable names that differed only in case

[01:42] <kelan> it just allows you to make typos

[01:43] <mauke> because case insensitivity is ill defined

[01:43] <autrijus> kolibrie: 

[01:43] <autrijus> $ ./pugs -e 'use CGI--perl5; say CGI.new'

[01:43] <autrijus> <obj:Scalar::Perl5>

[01:43] <autrijus> in vs3 ~autrijus

[01:43] <Khisanth> especially when you have unicode identifiers :)

[01:43] <mauke> do you really want GRÖSSE to be the same variable as größe?

[01:44] <mauke> (or grösse, depending on your current locale)

[01:44] <Odin-LAP> de_CH ?

[01:44] <mauke> yep

[01:44] <Odin-LAP> :p

[01:44] <svnbot6> r4034, autrijus++ | * add stub casting from SV to VList

[01:46] <kolibrie> autrijus: ok

[01:49] <autrijus> autrijus@vs3:~/pugs$ ./pugs -MCGI--perl5 -e 'say CGI.VERSION'

[01:49] <autrijus> 3.04

[01:49] <svnbot6> r4035, autrijus++ | * ugly horribly hack to get `DBI.VERSION` working

[01:49] <autrijus> looks all OK now.

[01:50] <autrijus> I don't know how to solve the -lperl not found problem

[01:50] <autrijus> the -lperl is from %Config

[01:51] <kolibrie> thanks very much

[01:51] <autrijus> np :)

[01:52] <kolibrie> if I try to rebuild in my pugs, will that work, or should I scrap that and start over?

[01:53] <theorbtw1> Autrijus: the -lperl issue is on lilith?

[01:53] *** theorbtw1 is now known as theorbtwo

[01:54] <autrijus> theorbtwo: no, on kolibrie's

[01:54] <autrijus> kolibrie: I think you can raze your checkout and start over

[01:54] <autrijus> kolibrie: copying my ~autrijus/pugs/sh if needed

[01:54] <kolibrie> :)

[01:54] <autrijus> $ ./pugs -MSVK::Simple--perl5 -e 'my $svk = SVK::Simple.new; $svk.ls("//")'

[01:54] <autrijus> mirror/

[01:54] <autrijus> pugs/

[01:54] <autrijus> yay.

[01:55] <autrijus> bin/svk in perl6 is now entirely trivial

[02:09] <meppl> gute nacht

[02:11] <theorbtwo> Goodnight, meppl.

[02:12] <meppl> ;)

[02:17] <kolibrie> autrijus: maybe I can figure out the -lperl thing tomorrow

[02:18] <kolibrie> can you e-mail me and tell me what your pugs/sh does? 

[02:18] <autrijus> kolibrie: that'd be great. then we can switch to build embperl by default (with probing that it actually works)

[02:18] <autrijus> kolibrie: I just changed -lperl into /usr/lib/libperl.so.5.8

[02:18] <autrijus> that's all.

[02:18] <autrijus> nothing else

[02:18] <kolibrie> ok

[02:19] <autrijus> I'll sleep now. see ya :) *wave* &

[02:19] <kolibrie> me too &

[02:39] <eric256> dead in here?  juerd still around?

[02:41] <vcv--> he's off fighting some OS wars

[02:42] <eric256> lol. i thought maybe he had another tab/space war somewhere. ;)

[02:45] <kelan> tabs are the best!

[02:56] <eric256> .<key> //= ++$i for @options ;

[02:56] <eric256> how do i make $_ rw there?

[03:00] <eric256> hmm maybe that isn't the problem....either way shouldn't that autovivify the hash key?

[03:00] <eric256> am i talking to myself?

[03:00] <eric256> lol

[03:13] <eric256> hmmm...seems it might just be an issue with using key as the name of a key...thinks you are trying to use a Pair object for some reason

[03:18] <kelan> i wouldnt think `key` would be special inside a string tho

[03:18] <eric256> .<key> keeps trying to call the method &key though

[03:18] <kelan> seems like a parse error then

[03:18] <eric256> *** No compatible subroutine found: "&key"

[03:20] <eric256> hmmm... trailing for + . syntax fails

[03:20] <eric256> .key for @options; # failes

[03:20] <eric256> $_.key for @options; # works

[03:21] <eric256> off to see if a test exists yet

[03:27] <eric256> hmmm it works in a test. that is odd.

[03:28] <eric256> or it was a bad test...yep bad tests....objects show as equal in an is() test even if there values arn't equal

[03:31] <eric256> okay i've officaly lost my mind. 

[03:40] <eric256> must be some sort of parse error because it depends on what operators you use after the .key portion

[03:43] <kelan> so like `.<key> + 2` might work but `.<key> for %foo` wouldnt?

[03:43] <kelan> yes, i would say parse error

[03:43] <eric256> almost exactly like that.

[03:43] <eric256> try { .key //= 1 for @array1 }; # works

[03:43] <eric256> try { .key //= ++$i for @array1 }; # fails

[03:47] <kelan> seems like the `for` modifier is messed up

[03:47] <eric256> now i know i have lost it....now .key fails either way.. i must be doing something stupid

[03:47] <kelan> heh

[03:47] <kelan> i don't have pugs installed so i'm no help either

[03:47] <eric256> i new i should have left those tests in there even though they passed...then maybe i could have noticed i what i did

[03:47] <eric256> you should get an account on feather

[03:48] <kelan> but what would i do?

[03:48] <kelan> i guess writing tests is easy enough

[03:49] <eric256> i program my little wizard game and write tests for bugs i find

[03:49] <eric256> i couldn't read the haskel part if my life depended on it. ;)

[03:49] <kelan> i can read some of it

[03:49] <kelan> i started learning haskell a couple months ago

[03:50] <kelan> is there networking yet?

[03:50] <kelan> like sockets, etc?

[03:51] <eric256> well there is access to all perl5 modules so i suppose in some fashion the answer is yes

[03:51] <eric256> so any ideas where in the haskel i would look for how it handles trailing for?

[03:52] <vcv--> if you've never done haskell, i dont think you want to even look

[03:52] <svnbot6> r4036, eric256++ | Added tests for bugs in trailing for statment

[03:52] <eric256> i just want to look, not touch.

[03:53] <kelan> i don't know the codebase at all, so i can't give any tips

[03:55] <vcv--> as did i.  then i cried.

[03:55] <kelan> heh

[03:55] <eric256> lol

[03:55] <eric256> it looks pretty interesting

[03:56] <vcv--> its just so foreign to me.  ill read a tutorial..but it seems each and every one will show stuff and not explain just a few things

[03:56] <eric256> reading Parser.hs which has a definition for a regular for...not sure if it covers teh trailing for though

[03:56] <clkao> *yawn*

[03:56] <vcv--> so i have no idea how they got from D -> E

[03:57] <eric256> any ideas what the trailing for might be called? like modifier or something

[04:02] <eric256> line 731 of Parser.hs .... no idea what it realy means. but that is definitly the definition of trailing for

[04:09] <clkao> autrijus: mmm roundtrip.t still fails

[04:09] <svnbot6> r4037, SamB++ | Export withArgs from Main

[04:09] <eric256> maybe it isn't parsing so much as .method failing to act on the correct $_

[04:24] <eric256> does { } no longer produce a hash ref?

[04:27] <clkao> ok 10 - invoke pugs method from p5

[04:27] <clkao> bwahaha

[04:28] <Khisanth> eric256: I think you have to have certain things inside it to be considered a hash

[04:28] <eric256> clkao: any idea on how to convert an array to a hash? 

[04:28] <eric256> my %hash = hash( map { $_ => $_ } @array ); failes

[04:31] <Khisanth> map { $_ => $_ }, @array; perhaps?

[04:32] <eric256> nope.... $_ => $_ is creating pair objects which %hash doesn't seem to be expecting

[04:32] <svnbot6> r4038, clkao++ | Properly invoke pugs object method from perl5.

[04:33] <Khisanth> map { $_ => $_ } @array with the {} being a hash is actually kinda confusing...

[04:33] <clkao> autrijus: i have some thoughts about DBI.VERSION stuff

[04:34] <eric256> the {} isn't a hash, its a code block

[04:34] <Khisanth> I thought you just said you wanted it to be a hash?!

[04:36] <eric256> lol. no no. you got lost somewhere. i want to take an array and map it to  a hash. like if @array is a set of objects with key values. use those key values as the key in a hash

[04:36] <eric256> my %hash = map { $_.key => $_ } @array;

[04:37] <eric256> my %hash; %hash.{ $_.key } = $_ for @array; might be the way to go. dunno

[04:37] <scook0> eric256: If your argument to map looks like a hash (but shouldn't be), you need to put a semicolon in there

[04:37] <svnbot6> r4039, eric256++ | applied Juerd's suggestions with modifications to make them actualy work. ;) + new Option object

[04:37] <scook0> map { $_.key => $_; }

[04:38] <eric256> ah ha! thanks

[04:38] <scook0> I think that needs to be put in a FAQ somewhere, if it isn't already...

[04:45] <Khisanth> Hang out in #perl6 and learn by osmosis! :)

[04:45] <svnbot6> r4040, eric256++ | small hash creation change...what a difference a ; makes inmy %hash = map { $_ => $_; } @array;

[04:47] <Khisanth> would @array ==> map { $_ => $_; } ==> %hash be valid?

[04:48] <eric256> i don't think ==> is done yet ;)

[04:49] <vcv--> are all of the operators going to be defined with perl code themselves?

[04:50] <eric256> probably not. that normaly isn't the fastest way to do it

[04:50] <eric256> but it looks like you would be able to define them all with perl code...

[04:50] <Khisanth> work first optimize later!

[04:51] <eric256> if only the same was true of statments then things like given and when and for etc could be defined by perl itself. now that would be something ;)

[04:51] <svnbot6> r4041, clkao++ | Fix roundtrip.t, invoker is now properly set to NULL for non-method call.

[04:51] <eric256> maybe macros will bring that

[04:54] <eric256> according to S06 that should work ye

[04:54] <eric256> s

[04:54] <Khisanth> hmm they all get turned into PIR anyway don't they?

[04:55] <eric256> maybe they will now then. i don't know anything about compilers so don't rely on me

[05:59] <svnbot6> r4042, gaal++ | fix Pugs::Internals::hSetBinaryMode and Pugs::Internals::openFile Prim decl records, autrijus++

[05:59] <Aankhen``> :-\

[06:00] <Aankhen``> I'm compiling!

[06:01] <IshaCocoa> is there a step-by-step guide to getting pugs to build on windows anywhere?

[06:01] <Khisanth> isn't "foo" ~~ m:perl5 /PATTERN/ equivalent to "foo" =~ /PATTERN/ ?

[06:03] <Aankhen``> IshaCocoa >> Are you having trouble with getting it to compile or do you just need to know the steps to follow?

[06:06] <IshaCocoa> Looking for what I need to download to get started.

[06:07] <gaal> there are binary builds of parrot and of pugs, that's a start :)

[06:08] <gaal> what c build system are you using?

[06:15] <Aankhen``> Remind me not to accidentally kick my router's power supply.

[06:28] <Darren_Duncan> fyi, following Autrijus' journal comment that class methods now work, I'll try over the next day getting the Locale-KeyedText test suite to run again, and identify the most pertinent remaining Pugs issues that exist

[06:56] <svnbot6> r4043, ninereasons++ | perl6.vim: highlight pod and kwid =head 1,2 and 3,4

[08:13] *** Aankh|Clone is now known as Aankhen``

[09:04] <Aankhen``> Yeesh.

[09:04] <Aankhen``> SVN doesn't like me much.

[09:06] <Khisanth> sacrifice a camel to Larry

[09:07] <Aankhen``> ...or `rm -rf ext` and `svn up`. :-D

[09:21] <svnbot6> r4044, Aankhen++ | * added first version of HTTP::Headers::Util.

[09:21] <svnbot6> r4045, Aankhen++ | * fixed small bug relating to , vs. ; in &HTTP::Headers::Util::join_header_words.

[09:31] <nothingmuch> morning

[09:33] <masak> morning

[09:39] <IshaCocoa> nick IshaCocoa

[10:20] <broquaint> pugsbug: pugs -e 'sub f { say $_ while $_ = @_.pop } f <<one two three four five>>' # Undeclared variable: "@_"

[10:20] <integral> is (*@_) the default signature on functions without one?

[10:22] <broquaint> Ya.

[10:22] <broquaint> *@_ is rw IIRC

[10:23] <broquaint> Although I think splatty with rw is meant to fail.

[10:23] <Aankhen``> Why?

[10:24] <broquaint> Can't remember. 'sprobably in an AES somewhere.

[10:24] <lathos> How do I declare a class variable?

[10:24] <integral> "our"?

[10:25] <lathos> Huh.

[10:25] <Aankhen``> Class variable or class member?

[10:25] <lathos> Class member, I think.

[10:25] <lathos> Yes.

[10:25] <broquaint> According to E12: Class attributes are declared with either my or our. The only difference from ordinary my or our variables is that an accessor is generated according to the secondary sigil: (some code)

[10:25] <Aankhen``> class Foo { has $.bar; has @.baz; has %.quux; }

[10:25] <lathos> That looks like an instance member to me.

[10:26] <Aankhen``> Hrm, maybe I'm the one who's confused.

[10:26] <integral> class Foo { our $bar; method a { $bar = 5 } method b { $bar } } my $f = Foo.new; $f.a; say $f.b; # works

[10:26] * Aankhen`` goes to read E12.

[10:26] <lathos> broquaint: OK, so "our $.foo"?

[10:26] <Aankhen``> Er... where is E12, broquaint?

[10:26] <integral> that looks unimplemented in pugs

[10:26] <Aankhen``> Nevermind, I'll read S12.

[10:27] <broquaint> According to S12, lathos.

[10:27] <lathos> I'm delighted to find that "require $.config.model_class" works.

[10:27] <broquaint> Sorry, Aankhen``, I meant S12 :)

[10:27] <lathos> Perhaps by accident, but I like it. :)

[10:27] <Aankhen``> Heh, I saw that later.

[10:28] <Aankhen``> So `has $.foo` is an instance variable and `our $.foo` is a class-scoped variable?

[10:28] <Aankhen``> Oops, gotta run.

[10:28] <Aankhen``> Later.

[10:28] <lathos> Hrm, yeah, pugs is unhappy with that.

[10:28] <lathos> I'll use instances for now.

[10:39] <lathos> Oh, class constants don't work yet in pugs?

[10:40] <broquaint> Probably not. The OO stuff is still pretty bare bones :?

[10:41] <lathos> *nod*. It looks like I can fake it with string constants.

[10:42] <lathos> Oh, no, I can't.

[10:42] <lathos> pugs> "x".new()

[10:42] <lathos> {obj:Str}

[10:42] <broquaint> Hmm ...

[10:42] <lathos> That makes sense, but how to I instantiate an object of class x?

[10:43] <clkao> .=new ?

[10:43] <broquaint> It's time to get reacquainted with that dear old friend, eval :)

[10:43] <lathos> Urgh, maybe.

[10:43] <broquaint> For the time being.

[10:48] <Juerd> Hello, lathos

[10:48] <Juerd> lathos: ::("x").new, IIRC

[10:49] <Juerd> But pugs doesn't know that yet :)

[10:49] <Juerd> integral, broquaint: the default is *@_, without rw -- conversion from Perl 5 requires explicit *@_ is rw

[10:51] <Juerd> autrijus: Are symrefs on your todo list yet?

[10:51] <broquaint> No symrefs in perl6 please!

[10:52] <Juerd> They have their uses.

[10:52] <broquaint> Because accessing the symbol table is kludgy.

[10:52] <Juerd> And practically, specifying a class by name as a string, is referencing it symbolically.

[10:52] <Juerd> Same goes for methods

[10:54] <broquaint> Everything needs to be looked up by a string, whether it be parsed as such or not, it doesn't mean that symrefs are a necessity though. I just the behaviour of symrefs could be wrapped away in some nice methods/builtins/whatever.

[10:54] <broquaint> s/just/just think/

[10:54] <Juerd> Not really, now classes are objects.

[10:54] <Juerd> You should be able to rename a class without making references to it unusable.

[10:55] <Juerd> There are anonymous classes too

[10:55] <Juerd> So ref by name as the standard solution no longer makes sense.

[10:57] <broquaint> I still want symrefs to go away, I reckon perl6 is a much cleaner language without them. Ho hum.

[10:58] <Juerd> We need them for class access.

[10:59] <Juerd> Well, we don't NEED to, but it's the one area where symrefs are accepted

[10:59] <broquaint> Accepted because there's no other way to do it.

[10:59] <Juerd> (The alternative is to use a dispatch table, but that quickly gets boring: :foo(::foo), :bar(::bar), etc. To build this table, you'd automate it, and that requires symrefs again :P)

[11:00] <Juerd> Sorry, should have used => syntax there of course

[11:00] <Juerd> foo => ::foo, bar => ::bar.

[11:00] <Juerd> lathos: That'd solve your problem for now, if you don't need arbitrary classes

[11:01] <Juerd> { foo => ::foo, bar => ::bar }{$string}

[11:01] <Aankhen``> If you have $foo of class 'x', you could create a new object of that class using $foo.ref.new()

[11:01] <broquaint> Why do you need a dispatch table to access the symbol table?

[11:01] <Juerd> broquaint: No, to avoid that.

[11:05] <broquaint> Maybe I should just write a symbol table access module to avoid symref hackery ...

[11:05] <Juerd> It's exactly the same thing in the end

[11:05] <Juerd> But with different syntax.

[11:06] <broquaint> Indeed. But why use that syntax in the first place? Seems a little backward, no?

[11:06] <Juerd> Because it's a very useful feature.

[11:06] <Juerd> Of course, like any feature, it can be used wrong.

[11:06] <Juerd> But it's not Perl's job to decide if symrefs are the right tool or not.

[11:06] <Juerd> Face it, Perl is a language that puts YOU in control.

[11:06] <Juerd> Even if you're stupid.

[11:07] <masak> Perl++

[11:07] <masak> I want to be able to be stupid in my language of choice

[11:07] <Juerd> It lets you use goto LABEL, it lets you use symrefs, it lets you use eval, it lets you execute system calls, it even lets your stupidity access the outside world through sockets.

[11:08] <Juerd> Perl, as generic technology, can be used for destructive purposes. And for good.

[11:08] <masak> Perl is a very efficient spamming tool. That's stupidity.

[11:08] <Juerd> Yes

[11:08] <Juerd> Spamming is bad

[11:08] <Juerd> But that doesn't meant Perl should do anything to avoid it.

[11:08] <broquaint> I like symrefs, or at least, what they represent, but not their interface.

[11:08] <Juerd> That's not Perl's area.

[11:09] <Aankhen``> masak++ # I agree.

[11:09] <Juerd> broquaint: I happen to like the ::() syntax.

[11:09] <broquaint> I've no doubt you do :)

[11:09] <Aankhen``> (about the language of your choice bit ;-)

[11:09] <broquaint> It's certainly much nicer than perl5's syntax.

[11:10] <Juerd> I never did mind ${"Foo::$_::BAR"}, really.

[11:10] <Juerd> $Foo::($_)::BAR is a little bit nicer

[11:10] <broquaint> ${"Foo::$_\::BAR"} ;)

[11:10] <Juerd> Eh, yes, that :)

[11:10] <Aankhen``> Why the \?

[11:10] <Juerd> autrijus: $_::BAR

[11:10] <Juerd> eh

[11:10] <Juerd> autrijus: ignore that

[11:11] <Juerd> Aankhen``: $_::BAR

[11:11] <broquaint> $_::BAR is a valid var, Aankhen``.

[11:11] <Aankhen``> OK.

[11:11] <Juerd> package _; $BAR = 5;

[11:11] <Aankhen``> Ah, double OK.

[11:11] <Aankhen``> It took some time for that to sink in. :-)

[11:11] <broquaint> There's no such thing as a package in perl6, right? It immediately assumes perl5 code doesn't it?

[11:12] <Aankhen``> According to the language specifications, yes, IIRC.

[11:12] <Aankhen``> WB.

[11:12] <Juerd> broquaint: But there is, afaik.

[11:12] <masak> <general-whine>oh, why is there such a thing as character encodings?</general-whine>

[11:13] <broquaint> Why does it do in perl6, Juerd?

[11:13] <Juerd> masak: You know why.

[11:13] <broquaint> s/Why/What/

[11:13] <Aankhen``> Hrm.

[11:13] <Juerd> broquaint: Same thing as in Perl 5 iirc

[11:13] <masak> Juerd: stupidity again?

[11:13] <Juerd> I really do see nothing wrong with namespaces.

[11:14] <Juerd> Not everything is good for OO.

[11:14] <Juerd> afk

[11:14] <masak> I want a way to be sure of which encoding I'm seeing without the string telling me excplicitly

[11:15] <masak> besides, the string might be lying

[11:15] <Aankhen``> o_O

[11:15] <masak> is there an (arbritary string)->(guessed encoding) tool?

[11:15] <Aankhen``> You'd need to port Encode.

[11:15] <Aankhen``> Umm... iconv?

[11:15] * masak searches of iconv

[11:16] <masak> Aankhen``: looks neat. thx!

[11:16] <Aankhen``> NP. :-D

[11:19] <zgrim> hello, i have a problem with Compiling Pugs.Embed.Perl5 ( src/Pugs/Embed/Perl5.hs, src/Pugs/Embed/Perl5.o ) -> /usr/lib/perl/5.8/CORE/reentr.h:611: error: field `_crypt_struct' has incomplete type

[11:19] <lathos> I do need arbitrary classes.

[11:19] <zgrim> on a debian box with ghc 6.4

[11:19] <zgrim> is this common ?

[11:21] <zgrim> it's the same problem as with swig unless passing -D_GNU_SOURCE to gcc ; how can one pass that one to ghc ? or is the problem elsewhere ?

[11:22] * integral got the same error on his overnight debian pugs build

[11:23] <integral> hmm, well ghc is invoked with a -D_GNU_SOURCE flag

[11:26] <zgrim> integral: ghc is called with $Config{ccflags}, so there shouldn't be this problem, but still ... :/

[11:26] * integral tries a rebuild

[11:27] <integral> nah, still broken :-)

[11:27] <zgrim> yes, i tried 4046 a few minutes ago

[11:28] * integral has no idea]

[11:32] <Aankhen``> There are a few tests for `where` in t/data_types/subtypes.t; any objections to my creating a seperate t/var/where.t?  t/subroutines/sub_parameter_traits.t is another place where I could add some, I think.

[11:38] <integral> ah, whoever was fiddling with Makefile.PL also broke it for OS X too :-)

[11:38] <integral> hmm, it might have been me come to think of it

[11:38] <Aankhen``> :-o

[11:39] <integral> ah, no, I used single quotes

[11:39] <integral> ah, ccflags was added, before only ccdlflags were used

[11:46] <svnbot6> r4046, bsmith++ | Fix to make the -optl flag adding work for at least myself

[11:46] <svnbot6> r4046, bsmith++ | (split into multiple -optl's one for each flag).

[11:47] * integral tries r4046 on debian

[11:48] <zgrim> integral: afair, the problem appeared before r4000

[11:48] <integral> nah, that doesn't fix it.

[11:49] <integral> hmm!  Well the two commits 3996, 3994 touched Makefile.PL and were mine...

[11:51] <Aankhen``> Could someone try and figure out why ext/libwww-perl/lib/HTTP/Headers/Util.pm won't parse?

[11:51] <integral> zgrim: hmm, I can't really see what might have broken it

[11:52] <integral> ok, it's before 3905

[11:52] <svnbot6> r4047, Aankhen++ | * HTTP::Headers::Util Ã¢â¬â fiddled with sub signatures a bit, fixed missing semi-colon!

[11:52] <svnbot6> r4047, Aankhen++ | * added version of &HTTP::Headers::Util::join_header_words that takes a slurpy array.

[11:54] <integral> ah, it builds with r3855 of Makefile.PL

[11:58] <integral> and it builds with r3864 of Makefile.PL.

[11:58] * integral goes to lunch

[12:00] <meppl> guten morgen

[12:06] <webmind> morgen

[12:06] <cognominal> bonjour :)

[12:06] <meppl> good morning webmind

[12:06] <meppl> and cognominal 

[12:07] <Aankhen``> Pugs doesn't seem to be handling an escaped delimiter within a regex too well.

[12:09] * Aankhen`` looks at t/rules/perl5.t and dies.

[12:13] <svnbot6> r4048, iblech++ | Usual svn properties added to t/oo/roles/{submethods,super}.t and

[12:13] <svnbot6> r4048, iblech++ | src/Pugs/AST/Types.hs.

[12:13] <svnbot6> r4049, iblech++ | * Added info about how to use the Compose Key to docs/quickref/unicode.

[12:13] <svnbot6> r4049, iblech++ | * Fixed a small error in docs/other/porting_howto (s/sub/method/).

[12:24] <integral> r3883  is the one that breaks debian embed perl

[12:26] <integral> hmm!  The only thing that changed to Makefile.PL there was PUGS_EMBED_PERL5 changes PUGS_HAVE_PERL5 !

[12:26] <Aankhen``> How do I dereference a scalar?

[12:26] <Aankhen``> $$foo doesn't seem to be working.

[12:27] <Aankhen``> Nor $$$foo.

[12:27] <Aankhen``> Nor $$$$foo.

[12:27] *** _meppl_ is now known as meppl

[12:34] <integral> hrm, I can't figure out what the difference is: rm -f src/Pugs/Embed/Perl5.o && svn update -r 3883 Makefile.PL && perl Makefile.PL && make # doesn't build

[12:34] <svnbot6> r4050, iblech++ | More work on util/perl6.vim.

[12:34] <integral> but change to r3864 and it builds :-/

[12:35] <integral> duh.

[12:35] <integral> I'm an idiot.  That's just changing PUGS_EMBED_PERL5 to PUGS_HAVE_PERL5, and of course I'm not changing any other source files...  *Sigh*

[13:09] <svnbot6> r4051, iblech++ | util/perl6.vim -- Highlight ::Class, too. Next thing is probably to highlight

[13:09] <svnbot6> r4051, iblech++ | class __HighlightClassname__ {...}.

[13:09] <svnbot6> r4052, autrijus++ | * remove the arbitary 128-char limit on perl5 calling pugs

[13:09] <svnbot6> r4052, autrijus++ |   methods, as the leading '&' is not mandatory in callconv.

[13:25] <svnbot6> r4053, autrijus++ | * perl6.vim: Correctly highlight the empty string quote `<>`

[13:25] <svnbot6> r4053, autrijus++ |   by using zero-width lookahead and lookbehinds

[13:29] *** broquaint_ is now known as broquaint

[13:52] <svnbot6> r4054, autrijus++ | * perl6.vim: constrain `< ... >` to one line, lest we

[13:52] <svnbot6> r4054, autrijus++ |   misparse `1 < 2` lines.

[13:52] <svnbot6> r4055, autrijus++ | * wizard.p6: Style fix -- `.foo` instead of `$_.foo`, use

[13:52] <svnbot6> r4055, autrijus++ |   more method interpolation in strings.

[13:52] <svnbot6> r4056, iblech++ | util/perl6.vim -- Highlight $*VARs, too.

[13:55] <lathos> perl6.vim should also highlight "has"

[14:02] <kelan> can alphabetic operators like `and` be used the the reduction meta-op? to wit: `$alltrue = [and] @somevals;`

[14:02] <kelan> maybe i should just get an account on feather so i can test these things myself. heh

[14:08] <broquaint> Should do, kelan.

[14:08] <svnbot6> r4057, scw++ |  r4120@scwnb:  scw | 2005-05-28 22:02:26 +0800

[14:08] <svnbot6> r4057, scw++ |  perl6.vim: hilight `has' and hilight q// only on word boundary.

[14:09] <scw> Oops, haven't use svk for a long time and forgot to add -l ..

[14:09] <broquaint> Yep, definitely works, kelan.

[14:10] <kelan> woo

[14:23] <ihb> in Perl 6, will I be able to redefine how e.g. "sub foo { ... }" acts? correct me if i'm wrong on this, but i believe that in Smalltalk you can redefine that because subcreation is a message to a class, and so is class creation, etc. I find that quite appealing.

[14:34] <integral> at the very least you can change the grammar

[14:38] <Aankhen``> integral >> Would you happen to know how to dereference a scalar?

[14:38] <integral> $$foo ?

[14:41] <Aankhen``> Doesn't work.

[14:41] <Aankhen``> Nor does $$$foo or $$$$foo.

[14:42] * integral has no ideas

[14:42] <Aankhen``> pugs> my $foo = \("bar"); say $foo.perl; say $$foo.perl;

[14:42] <Aankhen``> \'bar'

[14:43] <iblech> I think you don't have to dereference -- i.e. $foo ~ $bar will work. No need for $$foo

[14:44] <Aankhen``> I'm running into trouble with a sub that requires a Str.

[14:44] <integral> how does that square with the no-more-automatic-infinite-deref thing?

[14:45] <Aankhen``> Oh, and on a completely unrelated note, has the behaviour of modules which export subs been changed?

[14:45] <Aankhen``> Do we need to use `is export(:DEFAULT)` and so on now?

[14:46] <iblech> No, IIRC, all subs are still exported

[14:49] <iblech> ?eval 32 + 10

[14:49] <evalbot6> 42

[14:49] <iblech> ?eval [+] 1,2,3

[14:49] <evalbot6> 6

[14:49] <iblech> ?eval system "echo hi"

[14:49] <evalbot6> No compatible subroutine found: "&system"

[14:49] <iblech> :)

[14:51] <kelan> ?eval my $a=1; say $a;

[14:51] <evalbot6> No compatible subroutine found: "&say"

[14:52] <kelan> oh right

[14:52] <kelan> ?eval my $a=1; $a;

[14:52] <evalbot6> 1

[14:52] <kelan> ?eval my @a = (1,1,1,1,1,1,1); [and] @a;

[14:52] <evalbot6> 1

[14:52] <kelan> ?eval my @a = (1,1,1,1,1,1,0); [and] @a;

[14:52] <evalbot6> 0

[14:53] <integral> hmm, that seems somehow a wee bit nicer than all()...

[14:53] <kelan> well it gives different results. `all()` returns a junction, whereas `[and]` returns a bool

[14:53] <theorbtwo> [and] ands them all.  all creates a junction.

[14:53] <theorbtwo> Junctions are strange things.

[14:54] <integral> hmm, when would that actually matter?

[14:54] <kelan> after that huge thread on p6l about junctions with rob and damian going back and forth, i'm not sure junctions are useful enough to overcome their pitfalls

[14:54] <ihb> integral: changing the grammar isn't good enough for introspective and reflective programming.

[14:54] <kelan> people are going to want to use them like sets

[14:55] <integral> ihb: *nod* you really want the Code type to be reified into perl6

[14:55] <integral> and for sets we have a proper Set class

[14:55] <theorbtwo> reified?

[14:56] <ihb> integral: "reified"?

[14:56] <integral> thingified literally

[14:56] <integral> ie manipulatable as perl6 objects

[14:56] <theorbtwo> Ah.

[14:56] <theorbtwo> Yeah, I want that too.

[14:56] <theorbtwo> It lets you do real symbolic modification.

[14:56] <integral> Rather than being lots of hardwiring inside the haskell

[14:56] <kelan> integral: but i think people will want sets more than junctions, so it doesn't make sense to have junctions in the core and sets in a module

[14:56] <kelan> they should be switched

[14:57] <integral> kelan: well imho neither should be in core

[14:57] <integral> I quite like the Pugs.Internals module which just loads all the basic stuff Pugs need

[14:57] <kelan> integral: i would prefer neither in the core to junctions in but sets not

[14:57] <iblech> ?eval [and] (1,2,3,4) Â»>=Â« 2   # [and|or|...] and hyper ops can be used to emulate junctions, me thinks

[14:57] <evalbot6> (no output)

[14:57] <integral> but there's lots of stuff there that pugs needs everywhere, but your average project doesn't.

[14:57] <theorbtwo> I think the core is quite a bit t too big.

[14:57] <iblech> ?eval [and] (1,2,3,4) >>>=<< 2   # [and|or|...] and hyper ops can be used to emulate junctions, me thinks

[14:57] <evalbot6> (no output)

[14:57] <iblech> ?eval [and] ((1,2,3,4) >>>=<< 2)

[14:57] <evalbot6> (no output)

[14:57] <iblech> bleh

[14:58] <kelan> you have three > on one side

[14:58] <iblech> yeah, I want to >=

[14:58] <kelan> ah

[14:58] <theorbtwo> Evalbot needs to handle the error case better.

[14:58] <iblech> ?eval ([and] (1,2,3,4) >>>=<< 2).perl

[14:58] <evalbot6> bool::false

[14:58] <iblech> ?eval ([or] (1,2,3,4) >>>=<< 2).perl

[14:58] <evalbot6> bool::true

[14:58] <integral> hmm, maybe it should .perl the expression always?

[14:59] <iblech> Good idea.

[14:59] <kelan> ?eval +((1,2,3,4) >>>=<< 2)

[14:59] <evalbot6> 4

[14:59] <kelan> hm

[14:59] <kelan> should be 3?

[14:59] <kelan> oh maybe it counts the false value as an element

[14:59] <kelan> hmm

[14:59] <iblech> No, as the result is (false, true, true, true) -- a 4-element list

[14:59] <kelan> nod

[14:59] <Chewie[]> Hey, A04 says that if right curlies are on a line by themselves, they imply a semicolon, but curlies at the end of a line (that end a block) don't, and require one from the user. Wouldn't it make more sense to just think of it as a curly on the end of a line, instead of on a line by itself?

[15:00] <kelan> ?eval (1,2,3,4) >>>=<< 2

[15:00] <evalbot6>  1 1 1

[15:00] <iblech> ?eval ((1,2,3,4) >>>=<< 2).perl

[15:00] <evalbot6> (bool::false, bool::true, bool::true, bool::true)

[15:00] <integral> ah, >>>=<< is very confusing to read :-)

[15:00] <iblech> ?eval ((1,2,3,4) Â»>=Â« 2).perl

[15:00] <evalbot6> (bool::false, bool::true, bool::true, bool::true)

[15:00] <kelan> false stringifies to undef but true stringifies to 1?

[15:00] <iblech> :)

[15:00] <Chewie[]> ?eval hash { 'foo' => bar }.perl

[15:00] <evalbot6> No compatible subroutine found: "&bar"

[15:01] <iblech> false stringies to "", true to "1", yes

[15:01] <Chewie[]> Oh. I'm evil.

[15:01] <Chewie[]> ?eval hash { 'foo' => 'bar' }.perl

[15:01] <evalbot6> foo bar	\undef

[15:01] <iblech> ?eval (hash { 'foo' => 'bar' }).perl

[15:01] <evalbot6> {('foo bar' => undef)}

[15:01] <iblech> ?eval ({ 'foo' => 'bar' }).perl

[15:01] <evalbot6> {('foo' => 'bar')}

[15:01] <iblech> hash() seems to be a bit borken

[15:01] <kelan> ?eval all(1,2,3,4)

[15:01] <evalbot6> 1

[15:01] <kelan> ?eval all(1,2,3,0)

[15:01] <evalbot6> 0

[15:02] <kelan> hmm

[15:02] <kelan> how can i get evalbot to display the junction?

[15:02] <kelan> ?eval all(1,2,3,0).perl

[15:02] <evalbot6> (0 & 1 & 2 & 3)

[15:02] <kelan> ah

[15:02] <theorbtwo> (.perl)++

[15:03] <kelan> does the reduce meta-op always reduce from the left?

[15:03] <kelan> ?eval [>=] 2,1,2,3,4

[15:03] <evalbot6> (no output)

[15:03] <kelan> hm

[15:03] <kelan> not sure what that should give anyway

[15:04] <kelan> ?eval ([>=] 2,1,2,3,4).perl

[15:04] <iblech> ?eval ([>=] 2,1,2,3,4).perl

[15:04] <evalbot6> bool::false

[15:04] <Chewie[]> ?eval +<< (1 | 2 | 3)

[15:04] <evalbot6> Hyper OP only works on lists

[15:04] <Chewie[]> heh.

[15:04] <kelan> heh

[15:04] <Chewie[]> ?eval +<< [(1 | 2 | 3)]

[15:04] <evalbot6> any(1,2,3)

[15:04] <Chewie[]> ?eval +<< [1, (2 | 3)]

[15:04] <evalbot6> 1 any(2,3)

[15:04] <Chewie[]> ?eval +<< [1, 2, 3]

[15:04] <evalbot6> 1 2 3

[15:04] <kelan> you're calling prefix numification on them

[15:05] <Chewie[]> ahhh.

[15:05] <Chewie[]> ?eval >>+<< [1, 2, 3]

[15:05] <Chewie[]> or no?

[15:05] <Chewie[]> i'm only just reading about the hyperops.

[15:05] <kelan> do you want to sum them+

[15:05] <kelan> ?

[15:05] <Chewie[]> ?eval [+] [1, 2, 3]

[15:05] <evalbot6> 1 2 3

[15:05] <Chewie[]> kelan: that's my current project, yeah.

[15:06] <iblech> ?eval [+] (1,2,3)

[15:06] <evalbot6> 6

[15:06] <kelan> i think that last one didn't work because the arrayref doesnt deref

[15:06] <Chewie[]> that was my next try. heh.

[15:06] <Chewie[]> yeah.

[15:06] <Chewie[]> ?eval [+] *[1, 2, 3]

[15:06] <evalbot6> 6

[15:06] <kelan> ?eval [+] @{[1,2,3]}

[15:06] <evalbot6> 6

[15:07] <Chewie[]> ?eval [==] [2,3]

[15:07] <evalbot6> 1

[15:07] <svnbot6> r4058, autrijus++ | * Chained Perl 5 method invocation now works:

[15:07] <svnbot6> r4058, autrijus++ |     SVK::Simple.new.ls("//")

[15:07] <Chewie[]> that doesn't sound right.

[15:07] <Chewie[]> ?eval [==] [2,2]

[15:07] <evalbot6> 1

[15:07] <Chewie[]> er. heh.

[15:07] <kelan> ?eval ([==] [1,2]).perl

[15:07] <evalbot6> bool::true

[15:07] <kelan> hmm

[15:07] <Chewie[]> ?eval [==] *[2,3]

[15:07] <evalbot6> (no output)

[15:07] <kelan> oh right

[15:07] <Chewie[]> ?eval ([==] *[2,3]).perl

[15:07] <iblech> It's because of the []s, () is correct

[15:07] <evalbot6> bool::false

[15:07] <iblech> ?eval ([==] 2,3).perl

[15:07] <evalbot6> bool::false

[15:08] <iblech> ?eval ([==] 3,3).perl

[15:08] <evalbot6> bool::true

[15:08] <kelan> doesnt reduce provide list context?

[15:08] <kelan> i thought arrayrefs would deref in list context

[15:08] <iblech> Dunno, ask Juerd :)

[15:08] <kelan> yeah hes the context wizard

[15:08] <clkao> autrijus: what was the problem? also, pl_sv_undef needs to be handled.. otherwise invoking on that makes pugs sick

[15:09] <kelan> Juerd: wake up!

[15:09] <Chewie[]> is .perl going to replace Data::Dumper?

[15:10] <kelan> we need a magic8ball bot that answers yes/no questions

[15:10] <iblech> :)

[15:10] <kelan> magic8: is .perl going to replace Data::Dumper? <magic8> uncertain, it is

[15:12] <integral> perlbot 8ball is .perl very cool?

[15:13] <clkao> autrijus: SVN::Core.VERSION no longer works

[15:28] <svnbot6> r4059, iblech++ | evalbot added to examles/network.

[15:31] <theorbtwo> ?eval die "Test"

[15:31] <evalbot6> Error: Test

[15:32] <theorbtwo> ?eval +

[15:32] <evalbot6> Error: 

[15:32] <theorbtwo> Ah.

[15:33] <svnbot6> r4060, iblech++ | Pugs.Prim, Pugs.Internals, Pugs.Run: safemode.

[15:33] <svnbot6> r4060, iblech++ | If the environment variable %*ENV<PUGS_SAFEMODE> is set to "true", the prims

[15:33] <svnbot6> r4060, iblech++ | marked as "unsafe" in the big table of Pugs.Prim are not imported into the pad,

[15:33] <svnbot6> r4060, iblech++ | so they can't be used.

[15:33] <svnbot6> r4060, iblech++ | Autrijus: The simple substitution of runEvalIO to runEvalSTM isn't so simple as

[15:33] <svnbot6> r4060, iblech++ | we've thought, as there're many places where unsafePerformIO is used (e.g. in

[15:33] <svnbot6> r4060, iblech++ | the parser)...

[15:34] <iblech> ?eval +

[15:34] <evalbot6> Error:  unexpected end of input expecting term 

[15:34] <iblech> ?eval 1 == 0

[15:34] <evalbot6> bool::false 

[15:34] <iblech> :)

[15:41] <svnbot6> r4061, iblech++ | Added $?PUGS_VERSION pseudo-var to answer the question "what revision does

[15:41] <svnbot6> r4061, iblech++ | evalbot run on?".

[15:43] <integral> iblech: ./pugs -e'say %?CONFIG<pugs_version>' # you can just use %?CONFIG

[15:46] <integral> ?eval %?CONFIG.keys

[15:46] <evalbot6> () 

[15:46] <integral> ?eval %?CONFIG<pugs_version>

[15:46] <evalbot6> Error: Can't modify constant item: VRef <Hash> 

[15:46] <integral> ?eval do { my $a = %?CONFIG<pugs_version>; $a }

[15:46] <evalbot6> Error: Can't modify constant item: VRef <Hash> 

[15:46] <integral> o_O

[15:49] <iblech> integral: Yep, thought that too, but %?CONFIG is hidden in safemode, as %?CONFIG contains some more information one might not want to reveal

[15:49] <iblech> And it'd be more hard to only hide %?CONFIG{none "pugs_version"}

[15:50] <hcchien> interesting, split() is different with split ()

[15:50] <iblech> Yep, split(...) passes ... as parameters to &split, and split () passes () as parameter to &split

[15:51] <Chewie[]> iblech: Is that intentional?

[15:51] <stevan> iblech: I assume you are blocking against system calls with the eval bot

[15:52] <iblech> The split thing? Yep.  Hidden %?CONFIG in safemode? Yep, too.

[15:52] <iblech> stevan: Yep

[15:52] <iblech> ?eval system "hi"

[15:52] <evalbot6> Error: No compatible subroutine found: "&system" 

[15:52] <stevan> but are you guarding aginst odd uses of Inf?

[15:52] <iblech> ?eval [1...]

[15:52] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[15:52] <stevan> LOL

[15:52] <stevan> nice

[15:52] <integral> ?eval do { my $a := [1..] }

[15:52] <evalbot6> Error:  unexpected "{" expecting expression, ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:52] <iblech> ?eval 1 while 1 # will die after 7s or so

[15:52] <evalbot6> (no output)

[15:54] <iblech> ?eval do { my $a := [1...] }   # You forget a "."

[15:54] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[15:54] <iblech> s/forget/forgot/

[15:54] <integral> ah

[15:55] <Chewie[]> ?eval ([1...])[0]

[15:55] <evalbot6> pugs: out of memory (requested 1048576 bytes) 

[15:55] <integral> one wonders why an infinite list only needs a meg...

[15:56] <Chewie[]> integral: Pugs probably requests by the meg.

[15:56] <Chewie[]> integral: The error is just after the last meg that's successfully taken.

[15:56] <integral> hmm

[15:56] <Chewie[]> It requests until it can't request no mo'.

[15:57] <autrijus> iblech: hash() is not broken -- see definition

[15:57] <autrijus> ?eval hash(1, 2)

[15:57] <evalbot6> {('1' => 2)} 

[15:58] <iblech> Ah, yes, of course

[15:58] <Chewie[]> autrijus: ahh. it takes the object returned by the => and makes it a key, with a value of undef?

[15:58] <Chewie[]> autrijus: that's counterintuitive to me. it should absorb keys in-line with other data.

[15:59] <Chewie[]> er, not keys, key-value pairs.

[15:59] <Chewie[]> A04 said something about hash {} being for disambiguation for blocks.

[16:00] <autrijus> Chewie[]: S04 trumps it.

[16:00] <autrijus>            $coderef = sub { "a" => 1 };

[16:00] <autrijus>            $hashref = hash("a" => 1);

[16:00] <autrijus>            $hashref = hash("a", 1);

[16:02] <Chewie[]> ah. /me just started reading the apocalypses.

[16:06] <autrijus> hcchien: nopaste your ov program somewhere?

[16:06] <autrijus> pasteling: paste?

[16:06] <obra> hello, lambdacamels

[16:06] <autrijus> pasteling: nopaste

[16:06] <autrijus> pasteling: help

[16:06] <autrijus> obra: greetings jesse-san

[16:07] <stevan> ?eval ('iblech++') xx 5

[16:07] <evalbot6> ('iblech++', 'iblech++', 'iblech++', 'iblech++', 'iblech++') 

[16:07] <stevan> :)

[16:07] <autrijus> stevan: clever!

[16:07] <obra> evalbot6? does it have system? ;)

[16:07] <theorbtwo> ?eval `ls`

[16:07] <evalbot6> Error:  unexpected "`" expecting program 

[16:08] <autrijus> obra: pugs has got a Safe mode.

[16:08] <obra> a real safe mode?

[16:09] <iblech> obra: Of course not :) -- It is guarded against IO primitives (safemode) and eating too much RAM or CPU (setrlimit)

[16:09] <kelan> haskell makes it easy to forbid io interaction

[16:09] <iblech> obra: Try it and see: PUGS_SAFEMODE=true pugs -- and then try system, readline, etc.

[16:09] <obra> net

[16:09] <obra>  neat

[16:11] <autrijus> stevan: fancy starting changelogging? I won't have time to hack in major features before 6.2.6

[16:11] <autrijus> so I'm thinking a release within the next 24 hours or so

[16:11] <autrijus> if that's okay with you, that is

[16:11] <stevan> autrijus: sure 

[16:11] <stevan> autrijus: thanks for the journal entry too :)

[16:11] <autrijus> stevan: :)

[16:11] <stevan> although I must say, I usually go through the SVN log first, then augment it with your journal

[16:12] <autrijus> sure

[16:12] <clkao> autrijus: heym you broke DBI.VERSION

[16:12] <svnbot6> r4062, ninereasons++ | perl6.vim: minor; move some keywords around

[16:13] <autrijus> $ ./pugs -MDBI--perl5 -e 'say DBI.VERSION'

[16:13] <autrijus> 1.48

[16:13] <stevan> autrijus: BTW - I am still working on the metamodel, but I have started using perl5 because pugs was getting to slow

[16:13] <autrijus> clkao: worksforme

[16:13] <clkao> (!)

[16:13] <autrijus> stevan: wow. sure

[16:13] <stevan> autrijus: it is actually progressing much faster

[16:13] <clkao> *** No compatible subroutine found: "&VERSION"

[16:14] <stevan> but thats because I am better with perl5 then perl6 still :)

[16:15] <autrijus> clkao: I have no idea why it doesn't work for you

[16:17] <autrijus> clkao: did you use the same cmdline?

[16:17] * clkao tries to rebuild

[16:17] <clkao> ./pugs -MDBI--Perl5 -e 'say DBI.VERSION'

[16:18] <kelan> lowercase 'p' in perl5 maybe?

[16:18] <autrijus> nah, that's irrelevant

[16:18] * kelan nods

[16:22] <autrijus> clkao: really worksforme.

[16:25] <clkao> $ ab -clkao- [~/work/pugs] ./pugs -MSVN::Core--Perl5 -e 'say SVN::Core.VERSION'

[16:25] <clkao> *** No compatible subroutine found: "&VERSION"

[16:26] <autrijus> $ ./pugs -MSVN::Core--Perl5 -e 'say SVN::Core.VERSION'

[16:26] <autrijus> 1.2.0

[16:26] <clkao> :/ this happens after your chained invoke fix

[16:26] <autrijus> I'm razing my install and rebuilding.

[16:26] <autrijus> clkao: try

[16:26] <autrijus> ::SVN::Core.VERSION

[16:26] <clkao> btw, try eval_perl5("bad thing")

[16:26] <clkao> and then $that.something

[16:27] <clkao> dies horribly

[16:27] <clkao> doesn't work either

[16:27] <autrijus> I'm rebuilding from scratch

[16:29] <autrijus> still worksforme

[16:29] <autrijus> even after razing and remaking.

[16:31] <eric256> hey autrijus...any idea why

[16:31] <eric256> .method for @objects; fails?

[16:32] <autrijus> it does?

[16:33] <autrijus> ?eval class Foo {}; my @z = Foo.new; .meth for @z;

[16:33] <evalbot6> Error: No compatible subroutine found: "&meth" 

[16:33] <autrijus> ?eval class Foo {}; my @z = Foo.new; $_.meth for @z;

[16:33] <evalbot6> Error: No compatible subroutine found: "&meth" 

[16:33] <autrijus> ?eval class Foo { method meth { 3 }}; my @z = Foo.new; .meth for @z;

[16:33] <evalbot6> undef 

[16:33] <autrijus> that seems like ok

[16:33] <autrijus> ?eval class Foo { method meth { 3 }}; my @z = (Foo.new, Foo.new); .meth for @z;

[16:33] <evalbot6> undef 

[16:34] <eric256> rebuilding right now. but last night i went round and round with it and it wasn't working. let me go find the tests i wrote

[16:35] <eric256> hmm its not methods its accessors.. sorry.

[16:36] <eric256> ?eval class Foo { has $.key }; my @z = Foo.new; .key = 1 for @z;

[16:36] <evalbot6> Error: No compatible subroutine found: "&key" 

[16:36] <eric256> or did i get confused on . versus $_. agian?

[16:37] <autrijus> oh. that's a misparse between postfix loop 

[16:37] <autrijus> and implicit invocant

[16:38] <eric256> it drove me crazy because i kept ending up with cases that worked and then a small change would make them not work.  thought i was loosing my mind so i'm glad it didn't decide to work this morning. ;0

[16:43] <autrijus> fixing

[16:46] <Juerd> kelan: ?

[16:47] <Juerd> kelan: No, references do NOT deref in list context.

[16:47] <autrijus> plural context!

[16:48] <autrijus> sorry.

[16:48] <Juerd> kelan: In fact, no simple context dereferences - it's the LHS of the := that can do this.

[16:49] <lathos> Hey, autrijus, any chance that class literals will work soon?

[16:51] <autrijus> lathos: they already work

[16:51] <autrijus> what is it that is not working?

[16:52] <lathos> Oh. Funny, I couldn't get it to parse earlier. But it might have been something else.

[16:52] <lathos> Ah, no, it doesn't.

[16:52] <autrijus> try it with ?eval?

[16:52] <lathos>         $.frontend //= Maypole::Frontend::CGI;

[16:53] <lathos> It parses, but:

[16:53] <lathos> *** No compatible subroutine found: "&Maypole::Frontend::CGI"

[16:53] <kelan> Juerd: ok thanks

[16:53] <autrijus> oh. you're using p5?

[16:53] <lathos> No, this is all Perl 6.

[16:53] <autrijus> do you have a class Maypole::Frontend::CGI

[16:53] <autrijus> defined at compile time?

[16:53] <lathos> Ah, not at compile time.

[16:53] <autrijus> if you want to force a literal

[16:53] <autrijus> ::Maypole::Frontend::CGI

[16:53] <autrijus> will probably do. but it still need to find it

[16:54] <lathos> That works. Thanks.

[16:54] <autrijus> np :)

[16:54] <kelan> Juerd: is the LHS of `:=` the only place that they deref automatically?

[16:54] <kelan> Juerd: what is "Array context"?

[16:54] <lathos> I'm actually *really* enjoying porting Maypole to Perl 6. SO much cleaner.

[16:54] <autrijus> good!

[16:54] <autrijus> I'm glad you like it.

[16:55] <autrijus> next week me and leo will hopefully make it run with competitive speed as well.

[16:55] <autrijus> kelan: Juerd probably used the term "Array context" to mean "Item context that expects something that .does(Array)"

[16:56] <eric256> what is the syntax for use lib '/test';   it replies with unexpected "'"

[16:56] <kelan> autrijus: and that *creates* arrayrefs, right? from a regular list, say

[16:56] <autrijus> eric256: one thing at a time

[16:56] <autrijus> kelan: yes

[16:56] <kelan> ok

[16:57] <eric256> i just couldn't find it in the S or the A... didn't know if it was speced out yet or not ;)

[16:57] <autrijus> eric256: ./foo = 1 for 2

[16:57] <autrijus> is fixed.

[16:57] <autrijus> r4063

[16:57] <autrijus> I changed wizard.p6 too

[16:57] <autrijus> err I mean .foo = 1 for 2

[16:58] <Juerd> kelan: A scalar context in which an Array reference is expected.

[16:58] <eric256> cool

[16:58] <Juerd> lathos++  # porting maypole

[16:59] <Chewie[]> Does anyone know if there are frequently-updated contrib debs of the Perl 6 suite? I think I want to start work on a little project in Perl 6.

[16:59] <Juerd> kelan: Lists do not *exist* in scalar context.

[16:59] <Juerd> kelan: There is no such thing as converting a list to a scalar, or a list to an array.

[17:00] <kelan> hmm

[17:00] <svnbot6> r4063, autrijus++ | * `./property = 3 for @objects` now parse properly, eric256++

[17:00] <kelan> seems like you need to think about context quite a bit more in p6 than you had to in p5

[17:01] <kelan> to determine what something will do

[17:01] <Juerd> kelan: No, less.

[17:01] <autrijus> kelan: it's actually the same as p5 :)

[17:01] <Juerd> kelan: Context is more often clear

[17:01] <autrijus> there is an item context

[17:01] <autrijus> and a slurpy context

[17:01] <autrijus> in both p5 and p6

[17:01] <lathos> There's more theory about context in Perl 6; but experientially, it Just Works.

[17:01] <Juerd> kelan: But people need to realise that now, every type has its own context, which are all forms of Scalar context.

[17:01] <autrijus> the thing that changes is that in item context, aggregates enreferences

[17:01] <lathos> Time for dinner.

[17:02] <autrijus> Juerd: I have found that to be a confusing way to explain it.

[17:02] <kelan> autrijus: i think that's what is tripping me

[17:02] <autrijus> I prefer to say

[17:02] <autrijus> both Item and Slurpy also carry an optional "Type" flag

[17:02] <autrijus> to denote what kind of thing it expects

[17:02] <Juerd> autrijus: Yes and no.

[17:02] <Juerd> autrijus: There are four major types

[17:02] <autrijus> because you can have a Slurpy context that expects Int.

[17:03] <Juerd> autrijus: num, str, bool, ref

[17:03] <Juerd> Those are not references

[17:03] <Juerd> int is under num

[17:03] <Juerd> but stuff like array are under ref, and are thus references.

[17:03] <autrijus> Int is under ref right?

[17:03] <Juerd> No

[17:03] <Juerd> Nafaik.

[17:03] <autrijus> ok.

[17:04] <Juerd> Oh, and undef is a category of its own

[17:04] <autrijus> why isn't bool under enum?

[17:04] <autrijus> why is bool special?

[17:04] <Juerd> Because bools are dualvars, and there exists a special boolean context.

[17:04] <Juerd> boolean context is separate from num and str context

[17:04] <autrijus> I thought bools are enums.

[17:05] <Juerd> Something can be 15 or "hello", but false.

[17:05] <autrijus> sure, but it can also be 15 but color::red

[17:05] <autrijus> where color is a enum

[17:05] <Juerd> Really?

[17:05] <Juerd> I haven't read that yet

[17:05] <autrijus> pretty sure about that.

[17:05] <Juerd> Okay

[17:05] <autrijus> a sec, let me lookup

[17:06] <autrijus> Two builtâin enums are:

[17:06] <autrijus>  our bit enum *bool <false true>;

[17:06] <autrijus>  our bit enum *taint <untainted tainted>;

[17:06] <autrijus> so obviously they stand for the bit type

[17:06] <autrijus>  Note that "bool" and "taint" are really role names.  You can call

[17:06] <autrijus>  ".bool" on any builtâin type, but the value returned is of type "bit".

[17:07] <autrijus> 01:04 <@sri> autrijus: hah, i started the Perl6 port of Catalyst yesterday =)

[17:07] <Juerd> I see.

[17:08] <Juerd> Then I don't know how that part of context works. Ref?

[17:08] <Juerd> Hm, no

[17:08] <Juerd> Enums must have their own category I suspect

[17:08] <Juerd> Since it has nothing to do with the value

[17:08] <autrijus> yeah.

[17:08] <autrijus> or just the bit context ;)

[17:08] <Juerd> Weird...

[17:08] <autrijus> I think your theorisation is weird :)

[17:09] <Juerd> It worked until now.

[17:09] <autrijus> for me it just all carry a Type argument.

[17:09] <autrijus> which is just a simple type thing in the type tree.

[17:09] <Juerd> The problem with just carrying types is that some types are objects (references), others are primitive

[17:09] <Juerd> You can express it in terms of opaque and transparent references too.

[17:09] <Juerd> But I prefer not to.

[17:09] <autrijus> sure. but I also think of it as an implementation detail.

[17:10] <autrijus> where primitives are just unboxed variants of full objects.

[17:10] <Juerd> No, primitives are Str, Int, str, int

[17:10] <kelan> if i have `sub foo ( @ones, @twos ) {...}` and then call it like `foo( (1,1,1), (2,2,2) );` will it put the ones in @ones and twos in @twos?

[17:10] <autrijus> Juerd: ah. I see. sure

[17:10] <Juerd> An Str isn't an object.

[17:10] <autrijus> an Str isn't an object!

[17:10] <autrijus> "foo".does(Object)

[17:10] <autrijus> is false?

[17:10] <autrijus> amazing

[17:11] <Juerd> I'm not sure about that specific one.

[17:11] <Juerd> But it's not a reference

[17:11] <autrijus> it's not a reference, sure.

[17:11] <Juerd> Assignment copies the string

[17:11] <autrijus> but it is still an object

[17:11] <autrijus> which means you get to call .meta

[17:11] <autrijus> and get to do method dispatch

[17:11] <Juerd> Then Larry's explanation was wrong when he confirmed that objects are still references

[17:12] <Juerd> Yes, it can be used as an object 

[17:12] <Juerd> That doesn't make it an object :)

[17:12] <autrijus> heh. sure. underlying in Pugs

[17:12] <autrijus> it's not a VObject

[17:12] <autrijus> but from the syntax pov

[17:12] <autrijus> it might as well be an object.

[17:12] <Juerd> It's almost an object.

[17:12] <Juerd> The important difference is in assignment.

[17:12] <Juerd> $alias = $object

[17:12] <Juerd> But

[17:13] <Juerd> $copy = $string

[17:13] <Juerd> (roughly)

[17:13] <wolverian> er, shouldn't = always copy?

[17:13] <iblech> Str does role { method *infix:<=>(...) {...} } :)

[17:13] <wolverian> oh, right. references.

[17:13] <Juerd> wolverian: It copies the reference

[17:13] <Juerd> wolverian: So practically, the effect is that for the object (that the reference points to) is aliased

[17:13] <wolverian> the ruby system is continuously tripping me up when thinking about perl5 (and 6)

[17:15] <autrijus> import list works.

[17:15] <autrijus> use lib 'foo';

[17:16] <eric256> ?eval use lib 'foo';

[17:16] <evalbot6> pugs: *** No compatible subroutine found: "&use"     at -e line 2, column 13-43 

[17:16] <autrijus> hey sri_:)

[17:16] <svnbot6> r4064, autrijus++ | * `use lib 'path';` now works; eric256++ for asking about it.

[17:16] <autrijus> eric256: use is banned

[17:16] <eric256> probably a good move

[17:16] <autrijus> yup

[17:16] <Juerd> autrijus: Shouldn't import instead of a list, use import's signature?

[17:16] <sri_> autrijus: ;)

[17:16] <autrijus> Juerd: it passes a single expression to import's sig.

[17:17] <Juerd> I see

[17:17] <autrijus> so if it's

[17:17] <autrijus> method import (*@_) {}

[17:17] <autrijus> then it works as p5

[17:17] <autrijus> otherwise ymmv

[17:17] <Juerd> Good

[17:17] <autrijus> use Catalyst--perl5 'My::Module'; # works too

[17:18] <sri_> hope to get it ported in a few days...

[17:19] <autrijus> nice. you'll no doubt encounter pugsbugs. if so please commit tests :)

[17:19] <eric256> did you just fix that? because i'm still getting unexpected "'"

[17:19] <autrijus> sri_: give me your email? I'll make you committer

[17:19] <sri_> autrijus: np

[17:20] <Juerd> Weird

[17:20] <autrijus> sri_: welcome aboard!

[17:20] <Juerd> broquaint is logged on on feather

[17:20] <Juerd> But isn't in utmp

[17:20] <sri_> thx :)

[17:20] <autrijus> lathos: you want committer bit as well?

[17:24] <autrijus> eric256: worksforme

[17:24] <autrijus> $ ./pugs -e "use lib '/tmp/'; say @INC[0]"

[17:24] <autrijus> /tmp/

[17:25] <Juerd> Hm

[17:25] <Juerd> feather currently copies the pugs binary

[17:26] <Juerd> But it doesn't install libraries

[17:26] <Juerd> I need to change that.

[17:26] <iblech> autrijus: I think "use module" is broken -- try "use Set" or "use Net::IRC"

[17:26] <eric256> pasteling nopaste

[17:26] <iblech> (Parsefail on the first char of the module name)

[17:27] <Juerd> autrijus: Is there a way to without patching anything, specify @INC directories when compiling?

[17:29] <pasteling> "eric256" at 69.234.109.88 pasted "Import arguments on use failing to parse." (6 lines, 202B) at http://sial.org/pbot/10531

[17:30] <iblech> eric256: Ancient Pugs :) use lib '...' works since r4064

[17:31] <iblech> (But you have r4063)

[17:31] <eric256> lol i didn't notice the new update. excuse my stupidity please

[17:33] <iblech> autrijus: FYI, I fixed "use module" w/o following import list

[17:34] <autrijus> cool

[17:34] <autrijus> Juerd: yes, sure, fix your perl6 Config

[17:35] <autrijus> Juerd: point sitearch to something else, etc

[17:35] <autrijus> Juerd: use installprivlib

[17:37] <Juerd> autrijus: Not something I can pass to Makefile.PL?

[17:37] <eric256> thansk autrijus++ it works now. sorry for the conusion.

[17:37] <svnbot6> r4065, iblech++ | Unbreak "use Module" (without a import list following).

[17:37] <svnbot6> r4066, iblech++ | * Pugs.Run -- Hide %*ENV in safemode.

[17:37] <svnbot6> r4066, iblech++ | * evalbot/evalhelper.5 -- Pass the code to eval using -e, and not %*ENV anymore.

[17:37] <Juerd> In the autobuild script

[17:37] * Juerd prefers to not touch the contents of files, so that the automated tool will continue to work when a file's structure changes

[17:37] <autrijus> Juerd: uhm, I don't think so. the relevant code is util/PugsConfig.pm

[17:38] <Juerd> I'll have a look

[17:38] <autrijus> Juerd: if you want to invent a new ENV to control that at build time etc, feel free to hack

[17:38] <Juerd> Well, I just don't want a global make install

[17:38] <Juerd> But to keep things in my home dir

[17:39] <Juerd> Copying the binary works, but not if you want to use lib, for example :)

[17:39] <autrijus> nod. maybe just symlink /usr/lib/perl6 to your homedir.

[17:39] <autrijus> easiest

[17:39] <autrijus> but please improvise :)

[17:42] <Juerd> Hm

[17:42] <clkao> autrijus: a clean build now works. eh.

[17:43] <autrijus> eh indeed

[17:45] <autrijus> wow. &say is from REXX

[17:50] <autrijus> hm. do people really want anonymous declarators?

[17:50] <autrijus> "a"/"an"

[17:51] <autrijus> I can't see a easy use for it yet

[17:51] <autrijus> (not saying it won't be in pugs eventually, just not high on priority)

[17:51] <autrijus> bbiab

[17:56] <SamB> there are a lot of loops in Pugs.AST.Internals, aren't there...

[17:57] <integral> there are :-)  That's why it all ended up in there.   I had hoped more could be lifted out,  but to do that you need to start using existentials and thingies

[17:57] <SamB> or maybe just mutually-recursive modules...

[17:58] <integral> .hs-boot has some issues in the GHC implementation

[17:58] <SamB> with class declarations?

[17:58] <integral> I'm not sure

[18:06] <svnbot6> r4067, ninereasons++ | perl6.vim: trying to do a better job of matching "::","*",".",":","^",and "?" magical and lexical variables, as well as plain vars. Improve the alignment of various sections, for better visibility of regular expressions.

[18:06] <svnbot6> r4068, iblech++ | evalbot/evalhelper.p5 -- The code to eval should have an absolutely

[18:06] <svnbot6> r4068, iblech++ | non-polluted namespace, so we've to use an anonymous sub instead of a simple

[18:06] <svnbot6> r4068, iblech++ | $return_value.

[18:21] <Khisanth> so ... anyone working on an editor written in perl6? :)

[18:22] <vcv> an editor?

[18:22] <vcv> what kind?

[18:22] <Khisanth> text!

[18:22] <vcv> i would if there was a Win32 module :p

[18:23] <wolverian> why would anyone do that when we have vim? now, a perl6 interface to vim (so that we can use the perl6 grammar in it) would be nice..

[18:24] <autrijus> Khisanth: clkao mentioned he'll be working on it

[18:25] <clkao> on what?

[18:25] <autrijus> :perl6do

[18:25] <Khisanth> wolverian: because vim will fail to highlight correctly when you start redifining operators and stuff :)

[18:25] <clkao> delta editor, not editor.

[18:25] <autrijus> ah. heh ;)

[18:25] <autrijus> big difference

[18:25] <clkao> autrijus: so, is it possible to tweak the build system a bit

[18:26] <clkao>  os you have libpugs and main separated

[18:26] <clkao> i guess you guessed what i'm trying to do :)

[18:26] <autrijus> clkao: ghc's support for building .so is brittle

[18:26] <clkao> no, just a 

[18:26] <autrijus> clkao: you should separately link all the .o files

[18:26] <clkao> .a is fine

[18:26] <autrijus> oh. hm.

[18:26] <autrijus> clkao: look at scripts/pugscc

[18:26] <autrijus> it already links in all .o files explicitly

[18:26] <autrijus> now maybe we can do a .a

[18:27] <autrijus> but I'm not familiar with how to do that in ghc/cabal/etc

[18:27] <autrijus> you're welcome to try/ask around but I'm not terribly interested

[18:29] <clkao> but what i need to know is what would be the entrance of libpugs, things like init_perl.

[18:29] <wolverian> Khisanth: hmm. how so? as long as the grammar stays the same it will just work.

[18:30] <wolverian> Khisanth: and if you change the grammar, vim will see that.

[18:30] <Khisanth> vim will have access to the PGE? :)

[18:32] <clkao> autrijus: SVN::Client.new.log('http://svn.openfoundry.org/pugs' , 'HEAD', 'HEAD', 0, 1, sub { say @_ });

[18:32] <clkao> this now works. but running it for the second time segfaults

[18:33] <autrijus> clkao: hm. all you need to do is

[18:33] <autrijus>   hs_init(&argc, &argv);

[18:33] <autrijus> and on exit

[18:33] <autrijus>   hs_exit();

[18:33] <autrijus> that's all.

[18:33] <autrijus> see 8.2.1.1 in the GHC user guide

[18:34] <autrijus> inbetween the two calls you can call any foreign exports

[18:34] <autrijus> you can foreign export Main.eval 

[18:34] <svnbot6> r4069, ninereasons++ | perl6.vim: some more alignment.  Change the name of a match name.  Experiment with a different highlight type, for "&foo", "./foo", and ":/foo"

[18:34] <autrijus> or do something else clever

[18:41] <Limbic_Region> question - could you get a p5 stuff from parrot via p6 currently?

[18:41] <svnbot6> r4070, autrijus++ | * VList is now strict.  This means `1..Inf` will no longer

[18:41] <svnbot6> r4070, autrijus++ |   randomly sometimes work and sometimes not -- a better Lazy

[18:41] <svnbot6> r4070, autrijus++ |   implementation will be needed.

[18:43] <autrijus> Limbic_Region: that is a good question :)

[18:43] <autrijus> Limbic_Region: the short answer is no. if you want that, I can probably hack it in really fast.

[18:44] <knewt> what'd be really evil would be p6 accessing parrot accessing p5 accessing p6

[18:44] <knewt> with the two p6's being the same instance

[18:47] <Khisanth> but what would be the point?

[18:48] <knewt> the point would be to be evil *g*

[18:51] <broquaint> Is this a bug? pugs -e '["foo".split(rx:perl5//)].say' # pugs: cannot cast from VRule (MkRulePCRE {rxRegex = Regex 0x0862ff10, rxGlobal = False, rxStringify = False}) to [Char]

[18:52] <autrijus> I don't think we do the $str.split() thing yet

[18:54] <iblech> Currently, you have to say rx:Perl5//.split("foo")

[18:54] <broquaint> Ah, that makes sense, thanks :)

[18:54] <iblech> No, it does not make sense :) It should be $thing_to_split.split($split_at_what_chars)

[18:54] <iblech> (Fixing)

[18:55] <autrijus> (fixed)

[18:55] <iblech> :))

[18:55] <broquaint> I meant it makes sense in the current development environment ;)

[18:55] <autrijus> you can write tests tho :)

[18:55] <broquaint> Alrighty.

[18:55] <Khisanth> modifiers are case insensitive?

[18:55] <iblech> Don't think so

[18:55] <broquaint> Would it be difficult to implement getc? I wouldn't mind taking a stab if not.

[18:55] <autrijus> only perl5 vs Perl5

[18:56] <Khisanth> so :Perl5 :perl5 :P5 and :p5 all have different meanings?!

[18:56] <iblech> no, these are the same

[18:56] <autrijus> Khisanth: :p5 is illegal

[18:56] <iblech> but :i means case-insensitive and :I is an error

[18:56] <autrijus> all other three are currently the same

[18:56] <iblech> oh yes, right

[18:57] <Khisanth> this is what I get for reading the non existent FM :)

[18:57] <autrijus> broquaint: there's no getc -- feel free to implement

[18:58] <autrijus> the $str.split(//) patch is in

[18:58] <broquaint> It'd just be a wrapper to getChar, right?

[18:58] <autrijus> untested tho

[18:58] <svnbot6> r4071, autrijus++ | * Implement $str.split(//), as requested by broquaint

[18:58] <autrijus> broquaint: aye

[18:58] <autrijus> hGetChar

[18:58] <broquaint> Double thanks, autrijus :)

[18:58] <autrijus> :)

[18:59] * broquaint waits for pugs to magically recompile

[19:00] <autrijus> pugs> "asd".split(rx:P5//)

[19:00] <autrijus> ('a', 's', 'd')

[19:01] <broquaint> Sweet.

[19:01] <autrijus> hm, I mapped my Menu key to compose

[19:01] <autrijus> but can't get things entered

[19:01] * autrijus googles a bit

[19:02] <iblech> Hm, I think getc should be named getb (for get byte), as hGetChar doesn't read characters, but bytes (just tried with "Ã¤" (two bytes in utf-8) in GHCi)...

[19:03] <broquaint> Could we have an alias for mental-backwards-compatiblity?

[19:03] <autrijus> iblech: actually if you read a high bit, just continue

[19:04] <autrijus> as specced by utf8

[19:04] <iblech> Even better: A getc which reads chars, and a getb which reads bytes :)

[19:04] <autrijus> see src/UTF8.lhs

[19:04] <autrijus> line 238

[19:04] <autrijus> for how to implement this

[19:04] <autrijus> iblech: nah. I think getc should always get char

[19:05] <autrijus> iblech: and if you want that to be bytes, binmode it

[19:05] <autrijus> or set it to raw in other ways

[19:05] <iblech> I'm fine with that, too

[19:09] <broquaint> This sounds complicated

[19:09] <broquaint> Also, does split / /, still do the same magic as in perl5?

[19:11] <autrijus> er. no.

[19:11] <wolverian> split / / isn't magical

[19:11] <autrijus> and I think Larry said don't worry about that.

[19:12] <broquaint> Ok, just checking.

[19:14] <Juerd> broquaint: In Perl 5, split " " is special, but split / / is not.

[19:33] <svnbot6> r4072, autrijus++ | * fix `when .isa()` infinite loop introduced yesterday, 

[19:33] <svnbot6> r4072, autrijus++ |   as reported by eric256

[19:35] <broquaint> I've got a new split.t for whoever wants it (refactored to boot).

[19:36] <autrijus> broquaint: just commit it

[19:37] <broquaint> svk commit split.t # I take it?

[19:37] <autrijus> yeah. are you a committer?

[19:37] <broquaint> Nope.

[19:37] <autrijus> if not, give me your email addr and I'll make you one :)

[19:37] <autrijus> if split.t is the only thing you modified, "svk ci" will do

[19:38] <autrijus> (ci is short for commit)

[19:39] <broquaint> [email@hidden.address] :)

[19:41] <autrijus> welcome aboard :)

[19:41] <broquaint> pugs -e 'q[foo bar].split(q[ ]).perl.say' # (' ')

[19:41] <broquaint> pugs -e 'split(q[ ], q[foo bar]).perl.say' # ('foo', 'bar')

[19:41] <broquaint> Merci :)

[19:42] <autrijus> =)

[19:42] <broquaint> Shouldn't both those splits be equivalent?

[19:42] <autrijus> broquaint: yes. mark that bug as :todo<feature>

[19:42] <autrijus> (our primitives can't yet tell between invocants and non-)

[19:42] <autrijus> that should be fixed

[19:42] <broquaint> Alrighty, then.

[19:47] <lathos> autrijus: Thanks for the invite, but I don't think I have the time to learn Haskell right now.

[19:47] <lathos> If I can encourage from the sidelines and throw up issues in porting Maypole, that would be enough.

[19:48] <Juerd> lathos: committer bits are handy for adding tests

[19:48] <Juerd> lathos: And tests are the simplest form of bug report, for everyone :)

[19:49] <lathos> Oh, OK. :)

[19:49] <lathos> I know this is just the evil plot to move me onto svk. ;)

[19:49] <Juerd> You may use svn if you wish

[19:50] <Juerd> lathos: If you want, you can get access to feather, which has svk installed via a shared local repository

[19:51] <lathos> Oh, that would help.

[19:51] <Juerd> s/via/, and pugs accessible via/

[19:51] <Juerd> lathos: I need a simple email requesting it, for the record

[19:51] <Juerd> But I'll create your account right away

[19:51] <Juerd> (juerd@juerd.nl)

[19:51] <broquaint> Ok, split.t committed.

[19:56] <svnbot6> r4073, broquaint++ | * refactored testing code to a simple sub call

[19:56] <svnbot6> r4073, broquaint++ | * added tests for Str.split

[19:56] <broquaint> Neat.

[20:01] <robkinyon> Heyla all ... got a specs question for whomever wants to field it

[20:01] <iblech> Ok, getc() implemented, checking in in a sec

[20:02] <robkinyon> It's with respect to porting Module::Build (reference http://www.perlmonks.org/?node_id=461105 for more info)

[20:02] <broquaint> Thanks, iblech.

[20:03] <knewt> how are rules going right now?

[20:03] <knewt> how much is there so far?

[20:03] <robkinyon> Is it possible for the "use" keyword to depend on a module?

[20:04] <autrijus> knewt: charclass works in parrot but won't be in pugs until parrot 0.2.1 (in a couple weeks)

[20:04] <autrijus> knewt: using hypotheticals in rules doesn't yet work.

[20:05] <autrijus> otherwise it's pretty much all there, iirc.

[20:05] <autrijus> robkinyon: not sure what you mean...

[20:05] <autrijus> I need to run for food, though

[20:05] <autrijus> bbl

[20:05] <knewt> would charclass work with pugs + parrot trunk ?

[20:06] <autrijus> knewt: well, yes and no; you'd need to cp parrot/compiler/pge/* to pugs/src/pge/

[20:06] <autrijus> knewt: then it should work

[20:06] <robkinyon> Basically, I want to start the port of Module::Build/Module::Install/ExtUtils::MakeMaker type stuff toPugs

[20:06] <broquaint> Is the exported trait implement yet? I see it parses ok and it looks to work but I can't find it in the source :/

[20:06] <autrijus> but it's not tested

[20:06] <robkinyon> So, I'm gathering requirements right now. (q.v. the referenced Perlmonks thread)

[20:06] <autrijus> broquaint: all methods are currently exported ;)

[20:06] <broquaint> Ah, I see :)

[20:06] <autrijus> now, really &. I'll bbiab *wave*

[20:06] <svnbot6> r4074, iblech++ | * Pugs.AST.Internals -- Some more haddocks for the Val declaration.

[20:06] <svnbot6> r4074, iblech++ | * Pugs.Internals     -- Import hGetChar, too, so Pugs.Prim can use it.

[20:06] <svnbot6> r4074, iblech++ | * Pugs.Prim          -- Implemented getc().

[20:07] <robkinyon> I'm hitting a very interesting point which is that there are three different distros + the "use" keyword that need access to the same functionality

[20:07] <iblech> Night, folks :)

[20:07] <robkinyon> So, I was wondering if it would be ok if either "use" called out to these modules or if these modules were able to call into "use"

[20:07] <broquaint> Later, iblech.

[20:08] <broquaint> I imagine the modules can hook into use().

[20:08] <robkinyon> Possibly ...

[20:08] <robkinyon> Basically, there's a section of functionality that both use and the installer and the distro builder need to have access to

[20:09] <robkinyon> (This is why M::B and EU::MM do too many things. Also, the CPAN(PLUS) modules duplicate this functionality)

[20:09] <broquaint> What is this functionality?

[20:10] <robkinyon> it's the new functionality in P6 where you can have multiple versions of a module installed and choose between them at runtime

[20:10] <robkinyon> the syntax isn't fully fleshed out yet, but @Larry has said it will be there

[20:11] <robkinyon> There's no reason why the CPAN(PLUS) port, M::B port, and "use" all need to have this functionality separately

[20:12] <robkinyon> M::B as well needs to be split into two (or three) different distros, sharing functionality

[20:18] <Juerd> lathos: ping

[20:18] <wilx> ?eval 1+1

[20:21] <broquaint> What has $/ become (as it's now the regex match object)?

[20:22] <Juerd> broquaint: An fh property

[20:23] <broquaint> Ok, thanks, Juerd.

[20:31] <broquaint> What :todo<>'s are there? :todo<bug> :todo<feature> ... ?

[20:32] <castaway_> robkinyon: theres a perlmonks node about M::B for perl6, maybe you should go join in if you have ideas

[20:33] <Limbic_Region__> dragonchild is robkinyon

[20:33] <broquaint> robkinyon =:= dragonchild ?

[20:33] <Juerd> feather has email.

[20:33] <castaway_> oh

[20:33] <castaway_> (bah, people-picking-different0nicks--)

[20:34] <Juerd> hehe

[20:34] <castaway_> should not be allowed

[20:34] <Juerd> This is funny - go on :)

[20:41] <svnbot6> r4075, broquaint++ | * specify :todo in test 16

[20:41] <svnbot6> r4075, broquaint++ | * renamed the slurp() subroutine as that's the same name as a builtin

[20:47] <svnbot6> r4076, autrijus++ | * dons has changed hs-plugins url.

[20:49] *** Limbic_Region__ is now known as Limbic_Region

[20:50] <knewt> that was good timing. i was just wondering why i couldn't get a connection :)

[20:56] <kungfuftr> moo

[20:56] <svnbot6> r4077, autrijus++ | * fix url in README too.

[20:56] <kungfuftr> castaway_: hope it went well!

[21:03] <Corion> I get lots (10) unexpected successes - http://datenzoo.de/pugs/win2k.html - r407x , r4077 smoke is running

[21:06] <castaway_> pretty good, thanks kungfuftr .. I may be joining you yet ;)

[21:06] <knewt> well, extra dependencies for the latest hs-plugins, but it does at least build, which is better than some of the more recent ones :)

[21:06] * castaway_ met a director

[21:07] <knewt> castaway_: perl job at sophos?

[21:07] <svnbot6> r4078, SamB++ | Refactorings and a start on reducing line length in Pugs.Compile.Pugs

[21:08] * castaway_ nods

[21:10] <Corion> castaway_: Yay!!!

[21:11] <castaway_> not confirmed yet, Corion

[21:11] <Corion> castaway_: Oh ... So you're waiting on their decision ... I hope it works out!

[21:13] <castaway_> right

[21:13] <castaway_> thanks ;)

[21:14] <knewt> i've got a new job interview elsewhere now, after not getting the job at sophos

[21:14] <castaway_> good luck!

[21:15] <clkao> win23

[21:15] <knewt> coming over on the 2nd of june, will catch some of the lpm social, interview next day, then fly back that evening :)

[21:16] <castaway_> "over"? to/from where?

[21:16] <knewt> from hamburg, germany to london

[21:17] <castaway_> ah, fun

[21:17] <castaway_> fun, we did that for the may social

[21:17] <sri_> not much perl jobs in germany these days :/

[21:20] <knewt> and i don't speak germany, which makes it even more difficult

[21:20] <svnbot6> r4079, Aankhen++ | * rewrote and hopefully fixed &HTTP::Headers::Util::join_header_words.

[21:20] <svnbot6> r4080, Aankhen++ | * added (currently failing) tests for HTTP::Headers::Util.

[21:20] <knewt> hmm...

[21:21] <knewt> pugs> rule ident { [<alpha>|_] \w* }; my @strings = ("ident",, "9notident", "is_an_ident"); my @iids = grep /<ident>/, @strings

[21:21] <knewt> pugs: cannot cast from VList [VStr "ident",VStr "9notident",VStr "is_an_ident"] to Pugs.AST.Internals.VCode

[21:21] <knewt> castaway_: then on the 8th i'm flying over to vienna for apw2005

[21:23] <castaway_> what ae you doing here if not speaking german? (just curious)

[21:23] <castaway_> collecting miles? ;)

[21:23] <knewt> been living with my dad for a while while i sorted out some medical stuff

[21:24] <knewt> so, anyone got any clue why the above crashes out like that?

[21:24] * castaway_ nods

[21:25] <knewt> i've taken the rule and the grep from S05, and added my own array

[21:34] <Aankhen``> G'night.

[21:47] <eric256> my @iids = grep {/<ident>/} @strings;

[21:47] <eric256> maybe?

[21:49] <SamB> am I allowed to use TH?

[21:49] <Juerd> TH?

[21:50] <SamB> Template Haskell

[21:50] <castaway_> I think pugs is already using it somewhere.. check?

[21:52] <SamB> huh, in Pugs.Compile.Haskell...

[21:53] <SamB> though actually, I don't know that I want to bother yet.

[21:59] <SamB> I'll just write my plain-ordinary lower-order record-printing function myself...

[21:59] <SamB> I mean, even if I did use TH I'd want that ;-)

[22:04] <Darren_Duncan> funny thing happened yesterday night

[22:04] <Darren_Duncan> I found out for the first time what happens when Mac OS X 10.3 runs out of virtual memory

[22:04] <SamB> what?

[22:04] <Darren_Duncan> not pretty

[22:05] <SamB> well no duh

[22:05] <SamB> how could running out of virtual memory be pretty?

[22:05] <Darren_Duncan> it brings up a dialog box about running out of disk space, and suggests either killing off processes or deleting files

[22:05] <Darren_Duncan> in my case, I was away from the comp for a few hours, and only discovered it a few hours too late to fix it

[22:06] <SamB> what did it do?

[22:06] <SamB> just wedge?

[22:06] <Darren_Duncan> all of the applications were unresponsive, including the one to kill the others off, so I had to reset the computer

[22:07] <Darren_Duncan> this morning, I discovered that the swap files were about 4GB in size, and most of them were created within about 30 sec time

[22:07] <Darren_Duncan> 'make test' was running at the time, and I figure that's the only thing that could have done this

[22:08] <Darren_Duncan> suffice to say, I want to learn how to tell the computer to place hard limits on pugs so it dies before getting out of hand

[22:08] <Darren_Duncan> something like 'limit' comes to mind, but I've never used it

[22:08] <SamB> Darren_Duncan: you don't have 'ps' and 'kill'?

[22:09] <SamB> or even 'killall'?

[22:09] <Darren_Duncan> I do, but couldn't run them -- all applications unresponsive

[22:09] <Darren_Duncan> I certainly would have done that given the chance

[22:09] <SamB> Terminal.app was too slow, or not open?

[22:09] <wolverian> that sounds insane

[22:10] <Darren_Duncan> it was open, but all apps displayed the spinning pizza wheel

[22:10] <SamB> oh.

[22:11] <SamB> there ought to be a choice in that dialog to switch to a console or something...

[22:11] <Darren_Duncan> obviously, this speaks to something that could stand for improvement in the OS itself as far as automatic default actions to low memory situations

[22:11] <Darren_Duncan> the dialog in question was also unresponsive

[22:12] <Darren_Duncan> if it was responsive, it provided the necessary options to kill apps

[22:12] <SamB> oh

[22:12] <SamB> obviously someone needs to swipe some of the OS X devs' RAM...

[22:12] <Darren_Duncan> without fixing the OS itself, the only workaround I can see is to specify before running pugs that it can't use more than X memory

[22:13] <Darren_Duncan> FYI, I have 768M of physical RAM, and the startup disk had over 3G free space on it (the swapfiles were in /private/var/vm/)

[22:14] <SamB> maybe OS X should just kill the hogs itself, like Linux supposedly does...

[22:14] <castaway_> it does

[22:14] <Darren_Duncan> whatever the pugs test was doing, it seemed to eat up 3-4GB of memory in only 30 seconds time or so

[22:15] <Darren_Duncan> I think I'll file this with the Apple bug reporter

[22:16] <SamB> castaway_: linux does, or OS X does?

[22:16] <castaway_> linux does

[22:16] *** castaway_ is now known as castaway

[22:16] <Darren_Duncan> OTOH, I suspect they will only address this issue with 10.4, if it still exists there, and not spend the resources for this on the older 10.3 I'm on now; still wouldn't hurt to ask

[22:16] * SamB always gets fed up with the thrashing before running out of swap

[22:17] <Darren_Duncan> in my case, I was away from the comp for 3 hours, and any thrashing would have started hours before I saw it

[22:17] <SamB> yes, yes

[22:18] <Darren_Duncan> all this said, while the OS could stand for an improvement, the fact is that pugs and/or its test has/had a bug; should never use that much memory

[22:19] <Darren_Duncan> I have just updated and 'make' the newest pugs -- will run 'make test' again, but this time keep an eye on it to spot the offending test, if not yet fixed

[22:21] <Darren_Duncan> fyi, I got the 30 sec figure from the file creation dates of the swap files

[22:21] <Darren_Duncan> I booted up from another volume, so could see them as they were last night without the auto-removal of old swap files that happens on startup

[22:23] <SamB> pugs is *supposed* to have bugs, isn't it?

[22:23] <Darren_Duncan> yes

[22:24] <Darren_Duncan> but this is the first time I saw one that made swallow an ocean of memory

[22:24] <castaway> why, you adding some?

[22:24] <SamB> castaway: not on purpose!

[22:24] <castaway> ;)

[22:24] <Darren_Duncan> you usually would notice things like that prior to committing the change

[22:24] <SamB> anyway, the code I am working on doesn't even produce valid output...

[22:25] <Darren_Duncan> I don't even know yet if the test would have eventually stopped at a high ram level, or would have continued indefinitely

[22:25] <SamB> the current output of -CPugs contains <ref>s everywhere...

[22:30] <clkao> who knows how to compile a libpugs.a ? ghc insist main in Main even if i give it -no-hs-main

[22:31] <SamB> clkao: what do you mean?

[22:31] <SamB> what kind of libpugs.a?

[22:31] <SamB> is it to be called from C, or from Haskell?

[22:32] <clkao> to be called from c

[22:33] <SamB> are you sure it is exporting a C-level 'main'?

[22:33] <wolverian> I released this theme a few years ago. I had big plans for a follow-up, but real life stepped in and I never got around to finishing it. But I recently went back and cleaned up a lot of the bugs in Glossy P. I am almost done with an update ("Glossy Progress") that I'll probably release in about a month or so. I fixes lots of small problems and makes the theme all around more compatible with more recent versions of gtk. It also includes a new me

[22:33] <Darren_Duncan> currently running 'make test' -- for the early tests, Pugs VSIZE is staying around 39M

[22:33] <clkao> it just inists main to be eixst in Main

[22:34] <vcv> wow i just realized how easy xml is going to be to work with with perl6

[22:34] <SamB> clkao: why does it matter if Main contains main or not?

[22:35] <SamB> % nm src/Main.o|grep main

[22:35] <SamB> 00000ce4 D Main_main_closure

[22:35] <SamB> 00008dc4 T Main_main_info

[22:35] <SamB> 00000cb4 D Main_main_srt

[22:35] <SamB> 00000d0c D ZCMain_main_closure

[22:35] <SamB> 00008e80 T ZCMain_main_info

[22:35] <SamB> 00000d04 D ZCMain_main_srt

[22:35] <SamB> none of those will bother C!

[22:36] <clkao> mmm

[22:37] <clkao> so maybe i just don't use ghc to link and link those .o myself?

[22:39] <SamB> well, lets see...

[22:39] <SamB> you'll need the RTS

[22:40] <vcv> +%xmlhash<node> :)

[22:40] <SamB> there has to be something about this in the manual...

[22:41] <clkao> SamB: hey can you help me produce a libpugs.a that i can call from c? 

[22:42] <SamB> I can try

[22:43] <clkao> SamB++

[22:44] <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main should be of interest

[22:45] <clkao> that's what i was reading

[22:45] <clkao> ohno, mine is not latest

[22:46] <SamB> what were you reading?

[22:46] <nothingmuch> mmoevening

[22:46] <clkao> 8.2.1.1

[22:46] <clkao> http://www.haskell.org/ghc/docs/5.04/html/users_guide/sec-ffi-ghc.html

[22:46] <clkao> not latest, i meant.

[22:46] <clkao> anyway.. shower now

[22:47] <Darren_Duncan> following up my earlier comments, I don't know for sure that it was pugs that had the memory problem ... I did have several other apps open at the same time, including bit-torrent; but it seemed reasonable for pugs to be the first suspect; bt is my second suspect

[22:47] <Darren_Duncan> anyway, 'make test' still running without incident

[22:49] <Darren_Duncan> my main reason was the speed at which the swapfiles were made ... by contrast, in my experience bittorrent only used up vm based on the size of the files it was processing, and that's a much slower process

[22:50] <knewt> you have variable numbers of swap files? in fact, you have swap /files/ ???

[22:50] <Darren_Duncan> so unless bt had an obscure bug that just popped up, I don't see it being at issue

[22:50] <knewt> (in normal use i mean, of course)

[22:50] <Darren_Duncan> yes, it goes like this ...

[22:51] <nothingmuch> seen robkinyon 

[22:51] <jabbot> nothingmuch: robkinyon was seen 2 hours 39 minutes 2 seconds ago

[22:52] <Darren_Duncan> currently my /private/var/vm dir contains these 2 items: an 'app_profile' directory and the file 'swapfile0'; the latter is 65MB in size

[22:52] <Darren_Duncan> that would be a default I think, since only half of my real RAM is even in use now ... about 300M free

[22:53] <Darren_Duncan> what I saw from last night was about 7-8 swapfiles, with names like 'swapfile1', 'swapfile2' etc

[22:54] <lathos> Should I expect class data not to work yeT?

[22:54] <Darren_Duncan> 1 was also 65M, 2 was about 130M, 3 was about 260M, and the latest 2 files were both 1GB in size; I suspect that a third 1GB was in the process of being made when disk space was exausted, as about 600M remained

[22:55] <Darren_Duncan> I think those files are deleted when RAM usage drops, but they're definitely deleted at startup

[22:55] <Darren_Duncan> they are created dynamically

[23:11] <lathos> I have some failing tests, but I don't know if they're valid; should I commit them anyway?

[23:13] <Darren_Duncan> did you create those tests?

[23:13] <lathos> Yes.

[23:14] <Darren_Duncan> would your commit break anything besides your own new tests?

[23:14] <lathos> No, since it is simply new tests.

[23:14] <Darren_Duncan> I don't see a problem then

[23:14] <lathos> Well, the problem might be that my tests test for things which are not how Perl 6 should behave.

[23:15] <Darren_Duncan> in that case, you could try discussing the issues first, or commit anyway and say 'please look at this'

[23:16] <Darren_Duncan> what is the problem domain of the tests?

[23:16] <lathos> Class literals.

[23:16] <lathos> Here's the file: http://paste.husk.org/3334

[23:18] <lathos> Other thing is, should they be marked as todos, or left failing?

[23:22] <Juerd> lathos: In general, if it's lack of feature, todo, but if it's a real bug, fail

[23:23] <Juerd> Unless you need it soon - then leaving it failing can help

[23:23] <Juerd> That's a tool you need to be careful with though

[23:23] <lathos> OK. The second is a real bug, the third is a todo, then.

[23:26] <nothingmuch> is it possible to have thunk context?

[23:26] <Juerd> What is that again?

[23:26] <nothingmuch> if not, i think our hypothetical lazy context modifyer could be useful:

[23:26] <nothingmuch> sub infix:<||> ($left, lazy $right) { return $left if $left; return $right };

[23:27] <Juerd> That is something different from the proposed lazy context operator, which has the same role as list.

[23:27] <Juerd> And there is syntax for later evaluation

[23:28] <Juerd> There was discussion about this a week or so ago in p6l

[23:28] <nothingmuch> thread subject?

[23:28] <lathos> OK, I believe I've committed the test.

[23:28] <Juerd> lathos: grin - you *believe* you've committed it? :)

[23:28] <lathos> Yeah, but I was waiting for the bot to confirm it. :)

[23:28] <svnbot6> r4081, simon++ | Investigation of how class literals work at runtime.

[23:28] <nothingmuch> and why is it different?

[23:28] <lathos> There we go.

[23:28] <Juerd> Apparently you did :)

[23:28] <Juerd> Now I'm a believer too ;)

[23:29] <mauke> the bot defines our reality

[23:29] <Juerd> nothingmuch: We don't have either of <scalar list ~ + ?> in signatures

[23:29] <Juerd> nothingmuch: And that's the group of operators lazy would be added to (as a more specific list)

[23:30] <nothingmuch> ah

[23:30] <Juerd> Well, there are + and ? in signatures, but they have nothing to do with nums and bools.

[23:31] <nothingmuch> why is lazy like list, btw?

[23:31] <Juerd> Because only lists can be lazy

[23:32] <Juerd> (Well, an array can be lazy, when it is assigned a lazy list, but you don't specify the array as lazy, but instead the list on ='s rhs)

[23:32] <nothingmuch> wait wait wait, isn't our idea context independant?

[23:32] <Juerd> No, it is a context itself.

[23:33] <nothingmuch> i would like $foo = lazy 1 + 1; to work

[23:33] <Juerd> I wouldn't.

[23:33] <nothingmuch> by adding only when i do the itype fetch on $foo

[23:33] <Juerd> Well, it'd be useful to have it

[23:33] <nothingmuch> why not?

[23:33] <Juerd> But not with the name "lazy".

[23:33] <Juerd> Because "lazy" is what we call lazy lists.

[23:33] <nothingmuch> so what name?

[23:33] <Juerd> That's where discussion stranded.

[23:33] <SamB> you are beings silly!

[23:33] <svnbot6> r4082, SamB++ | More work on shorter lines in Pugs.Compile.Pugs

[23:33] <SamB> lazy means non-strick

[23:33] <nothingmuch> lazy is not a noun, that's an adjective

[23:33] <SamB> s/k/t/

[23:34] <Juerd> nothingmuch: What I want is to have "list gather { ... }" be in list context, and "lazy gather { ... }" be in lazy list context.

[23:35] <nothingmuch> ah

[23:35] <nothingmuch> did you read my p6l post about it?

[23:35] <clkao> SamB: did you find anything to make libpugs.a?

[23:35] <Juerd> The only thing being allowed to be implicitly lazy, the range operators.

[23:35] <nothingmuch> i think it gets that and more

[23:35] <Juerd> nothingmuch: Yes, and I wondered why it was so different from what was discussed here.

[23:35] <Darren_Duncan> well, 'make test' succeeded without any inordinate memory usage -- I think it never went over about 100M

[23:35] <nothingmuch> why not any expensive pure op

[23:35] <nothingmuch> well, you kind of faded out from the discussion

[23:35] <SamB> clkao: I was supposed to be looking for something?

[23:35] <Darren_Duncan> so either the problem I had last night was fixed, or pugs was never the problem

[23:36] <nothingmuch> why didn't you comment about it?

[23:36] <Juerd> But I currently lack the desire for yet another long discussion that makes my hands hurt.

[23:36] <nothingmuch> i still don't see why a superset of your behavior proposal is bad

[23:36] <Juerd> Some things in Perl 6 design are going wonderfully downhill.

[23:36] <nothingmuch> but i don't want your hands to hurt =)

[23:36] <Juerd> And I can't fight all of it.

[23:36] <clkao> 06:37 < clkao> SamB: hey can you help me produce a libpugs.a that i can call from c?

[23:36] <SamB> clkao: would it be feasable to have GHC installed when -lpugs

[23:36] <clkao> 06:38 < SamB> I can try

[23:36] <clkao> :P

[23:36] <SamB> is linked

[23:37] <SamB> anyway, I have to eat dinner now...

[23:37] <SamB> sorry :-(

[23:37] <Juerd> It's frustrating, but just the way things are.

[23:37] <SamB> you could try in #haskell, the natives are very friendly

[23:37] <SamB> they probably know a lot more about this than I do, too

[23:37] <clkao> ok hthanks

[23:38] <nothingmuch> Juerd: I don't understand why.. barely even what, i think i'm only getting that it frustrates you, but I'm not sure if it's current lazy list semantics, or the ones I proposed on p6l

[23:43] <Juerd> The ones you proposed are unclear to me.

[23:43] <nothingmuch> lazy takes it's right hand side, and wraps it in a coroutine

[23:43] <Juerd> It's an idea of introducing a modifier, but it lacks specification of what it'd really do. Your using it in a signature now says to me that you don't have a good picture of Perl 6 design overall. I'm probably wrong, though.

[23:44] <Juerd> There is no such thing as a generic coroutine wrapper

[23:44] <Juerd> You can't arbitrarily turn expressions or code blocks into coroutines.

[23:44] <nothingmuch> it is never visible that it is a coroutine

[23:45] <nothingmuch> and then puts it in the container or usage context it was applied

[23:45] <nothingmuch> when the data is needed from the container, the coroutine is evaluated

[23:45] <nothingmuch> it does not accept params, or whatever

[23:45] <Juerd> But if gather could know it was being called in lazy context (want.lazy), it could transparently use a coro.

[23:45] <nothingmuch> take in a lazy context gather would also yield

[23:45] <Juerd> nothingmuch: You're not getting my point. A language construct must be generic, and not have semantics for the thing it is applied to built into it.

[23:45] <Juerd> With gather, "take" is your yield

[23:46] <Juerd> But with a sub that builds an array -- where were you going to automatically place that yield?

[23:46] <nothingmuch> no where

[23:46] <Juerd> Are you going to analyze "return @array" and then walk up the tree until you find how it was constructed?

[23:46] <nothingmuch> if the user does not use a construct that knows to generate iteratively, the lazyness will be all or nothing

[23:46] <Juerd> If laziness is *context*, then the thing in that context can for itself decide whether it will use this piece of information that says "it's okay if you do this lazily"

[23:47] <nothingmuch> AOP heads have a nice word:

[23:47] <nothingmuch> buzzword, sorry

[23:47] <nothingmuch> a cross-cutting concern

[23:47] <nothingmuch> i don't want library code which handles the logic to determine for me, 3 levels deep, what my usage context should be

[23:47] <nothingmuch> that's where I want most lazyness to happen:

[23:48] <nothingmuch> the DBI execution to be lazified by my poop wrapper

[23:48] <Juerd> Do you agree that laziness should only be explicit, when the thing that generates COULD BE impure?

[23:48] <nothingmuch> expensive computation to be delayed by ...

[23:48] <nothingmuch> yes

[23:48] <Juerd> Then - who has to specify this explicitness?

[23:48] <Juerd> Context can propagate

[23:48] <Juerd> Any other modifier cannot, easily.

[23:48] * SamB thinks it would be more likely to work if you made the impurity explicit...

[23:49] <nothingmuch> think of lazy as a unary short circuiting OP

[23:49] <Juerd> SamB: That's a very different story.

[23:49] <Juerd> nothingmuch: That makes no sense.

[23:49] <SamB> yes, yes, I know...

[23:49] <nothingmuch> in my spec

[23:49] <nothingmuch> why not?

[23:49] <Juerd> Short circuiting has to do with bools.

[23:49] <Juerd> brb

[23:50] <nothingmuch> not necessarily

[23:50] <nothingmuch> my $value = lazy function_call(); # nothing happens

[23:50] <nothingmuch> $value += 10; # function_call() expression evaluated, but &infix:<+> would never know about it

[23:51] <SamB> how does it know which &infix:<+> to use?

[23:51] <nothingmuch> what does that matter?

[23:52] <nothingmuch> the moment that the value is needed

[23:52] <nothingmuch> for parameter matching

[23:52] <nothingmuch> or ....

[23:52] <SamB> oh

[23:52] <nothingmuch> it's evaluated

[23:52] <nothingmuch> if it's clear that it's not needed, this will be delayed further

[23:53] <nothingmuch> anyway, I want to sleep

[23:58] <clkao> Juerd: can i get a feather account? i'm getting tired of burning my lap with laptop while compiling pugs

[23:58] <Juerd> re

[23:58] <Juerd> 01:56 < nothingmuch> my $value = lazy function_call(); # nothing happens

[23:58] <Juerd> "nothing happens"?!

[23:59] <nothingmuch> exactly

[23:59] <Juerd> So the function call itself doesn't happen at that point?

[23:59] <Juerd> It has no idea it's being used?

[23:59] <nothingmuch> no

[23:59] <Juerd> No possibility of initializing anything?

[23:59] <nothingmuch> right

[23:59] <Juerd> Sounds like a bad idea to me.

[23:59] <nothingmuch> nope, nadda

[23:59] <Juerd> Can you explain what your "lazy" is, and does?

