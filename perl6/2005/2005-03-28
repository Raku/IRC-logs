[00:27] <Juerd> Seeing autrijus' photo was rather disappointing - he doesn't look like the mad genius I had pictured... :)

[00:27] <Juerd> He actually looks normal.

[00:29] <theorbtwo> Mmmpf, I'm drifting something horrible.

[00:50] <metaperl> Juerd, I feel sorry for you

[00:51] <metaperl> PLP is nicer than Mason, yet they are madly popular... how does that make you feel?

[00:53] <Juerd> "nicer"?

[00:53] <Juerd> It's leight weight and fast

[00:53] <Juerd> But Mason is a programming framework

[00:53] <Juerd> They don't really compete.

[00:53] <Juerd> s/leight/light/

[00:54] <Juerd> And I should note that I don't use PLP much myself, except as a CGI-replacement

[00:54] <Juerd> That is: "<:" has taken over "#!/usr/bin/perl"

[00:55] <Juerd> Because this lets me develop as easy as things go with CGI, but with mod_perl's speed

[01:06] <metaperl> I see... I am a CGI::Prototype fan

[01:10] <Juerd> You can probably very well use that from within PLP

[01:13] <metaperl> perhaps, but if I invented Seamstress, I need to use it

[01:14] <Juerd> Why that?

[01:14] <Juerd> xmath and I invented Attribute::Prototype, but you don't see any one of us use it :)

[01:15] <metaperl> yes, I like the Seamstress approach though... it's a bit indirect, but it gives me the non-invasive approach that I demand

[01:16] <metaperl> you know, you should ask to be in Perrin's "choosing a templating system" doc at perl.apache.org

[01:25] <Juerd> Why?

[01:27] <metaperl> exposure

[01:28] <Juerd> Exposure for PLP isn't necessarily a good thing.

[01:28] <metaperl> oh? why?

[01:28] <Juerd> It needs to be rewritten and I don't want to spend the little time I have on that

[01:29] <metaperl> oh

[01:29] <Juerd> PLP works, but it's UGLY

[01:29] <Juerd> And has some weird features that the world really would be better without.

[02:14] <theorb> Sigh... I know I still have problems with testgraph, but they seem to be firefox bugs, and I haven't a clue what to do with them... anybody have another project to suggest?

[02:21] <stevan> theorb: how about sleep? you sound tired :)

[02:22] <theorb> I'm not tired, just depressed.

[02:22] <stevan> nothingmuch and I were talking about forking the testgraph stuff off into its own module

[02:23] <stevan> it would be useful in other contexts

[02:23] * theorb nods.

[02:24] <theorb> I certianly wouldn't be opposed to such a thing.

[02:27] <jabbot> pugs - 1264 - adding in two new tests, one for rx:perl

[02:27] <jabbot> pugs - 1263 - making the exceptions lexical classes

[02:28] <stevan> theorb: have you ever tried 'make optimized'?

[02:29] <theorb> I have, but not for quite a while.

[02:29] <stevan> I am wondering if it worth it?

[02:29] <stevan> I suppose I should give it a try

[02:29] <theorb> In fact, come to think of it, I never have, but I'm the one who poked people into making it.

[02:30] <stevan> :)

[02:30] <theorb> Last I timed it, a compile-from-clean + run all tests ran longer with a -O1 and -O3 then with the default.

[02:31] <stevan> but was that all in the compile time?

[02:32] <stevan> if you are looking for another project though, maybe you can port File::basename

[02:32] <stevan> iblech started it

[02:32] <stevan> but it doesn't work, he just ported

[02:32] <stevan> you could hack it like I did File::Spec

[02:33] <stevan> its frustrating and satisfiying at the same time

[02:37] <jabbot> pugs - 1265 - un-TODO-ing the tests and making things 

[02:41] <cm> you guys are so motivated :)

[02:51] <stevan> cm: it keeps me out of trouble :)

[03:01] <theorb> It just keeps me depressed.

[03:06] <cm> :)

[03:09] <cm> does larry wall sometimes visit this channel?

[03:09] <theorb> Not that I've seen.

[03:10] <kungfuftr> larry, irc?

[03:11] <theorb> He's been known to talk on occasion on the CB of Perlmonks.

[03:12] <cm> what's "CB"?

[03:12] <theorb> Chatterbox.  Go to perlmonks.org, it's the thing near the top-left with conversation in it.

[03:12] <theorb> (Assuming anybody has said anything recently.)

[03:12] <cm> ah ok

[03:14] <theorb> Perlmonks: the reason I can put "god" on my resume and mean it.

[03:22] <kungfuftr> anyone ever built maxdb at all?

[03:27] <jabbot> pugs - 1266 - * fix warning

[03:47] <jabbot> pugs - 1267 - fix pugsrun tests. '&>' will go backgoun

[03:57] <jabbot> pugs - 1268 -  r1269@scwnb:  scw | 2005-03-27 21:45:10

[04:07] <jabbot> pugs - 1269 -  r1306@scwnb:  scw | 2005-03-28 12:00:12

[04:10] <mugwump> scw: use svk push --verbatim

[04:18] <scw> mugwump: Err, there are two things but I cannat find a way to push twice

[04:19] <scw> So I decided to push without verbatim..

[04:21] <scw> oop, I forgot to use --verbatim in r1269, is there some where to write it in config file?

[04:27] <jabbot> pugs - 1270 - more work on Pod::Stream::Parser; Added 

[04:47] <jabbot> pugs - 1272 - Fix :key(val) and unTODO tests.

[04:47] <jabbot> pugs - 1271 - Local redo.

[04:54] <gaal> mornin

[05:01] <masak> mornin

[07:05] *** cls_bsd__ is now known as cls_bsd

[07:17] <nothingmuch> hello

[07:21] <crysflame> .

[07:23] <scw> Hello, any one knows the meaning and rule of :key{ a => 1 } ?

[07:23] <nothingmuch> yes

[07:23] <nothingmuch> that's a pair

[07:24] <scw> e.g. what should it produce? can there be more than one pairs in {}?

[07:24] <nothingmuch> whose key is "key"

[07:24] <nothingmuch> and whose value is an anonymous hash

[07:24] <nothingmuch> with one pair inside it

[07:24] <nothingmuch> (a => 1)

[07:24] <nothingmuch> S04 discusses disambiguating blocks from hashes

[07:24] <scw> so :key{ a => 1, b => 2 } is also valid?

[07:24] <nothingmuch> yes

[07:24] <nothingmuch> it's really the same as key => { a => 1, b => 2 }

[07:25] <nothingmuch> or :key{ :a(1), :b(2) }

[07:25] <scw> great!

[07:25] <scw> nothingmuch: thank you vry much :)

[07:26] <nothingmuch> you're welcome =)

[07:26] <nothingmuch> this pair syntax is everywhere, btw

[07:26] <nothingmuch> double angle quotes know how to use it

[07:26] <nothingmuch> for example, enum <<:a(4) b c d>> means:

[07:26] <scw> I saw many :key('val'), :key<val>

[07:27] <nothingmuch> <val> and ('val') are equivelent

[07:27] <nothingmuch> back to the enum:

[07:27] <nothingmuch> the quotes make a list:

[07:27] <nothingmuch> ((a => 4), 'b', 'c', 'd')

[07:27] <nothingmuch> the enum gets that list

[07:28] <nothingmuch> and sees that a is a pair, so it enumerates 'a' with the value in the pair

[07:28] <nothingmuch> and then ++'s the value

[07:28] <scw> make things quite clear

[07:28] <nothingmuch> =)

[07:29] <nothingmuch> for each element that isn't a pair

[07:29] <nothingmuch> so b gets 5, etc

[07:30] <scw> btw, is :key(1, 2) also valid? I guess it should be  'key' => [1, 2] ?

[07:30] <nothingmuch> i think yes, but i'm not 100% sure

[07:31] <nothingmuch> luqui should probably know

[07:31] <nothingmuch> if $a = (1, 2) puts an array reference into $a then yes

[07:32] <nothingmuch> looks like yes

[07:32] <nothingmuch> pugs> my $a = (1, 2);

[07:32] <nothingmuch> pugs> ref $a

[07:32] <nothingmuch> 'List'

[07:32] <nothingmuch> it's pugs> my $b = [1, 2];

[07:32] <nothingmuch> pugs> ref $b

[07:32] <nothingmuch> 'List'

[07:36] <scw> Hmm.. so perl 6 is intuitional and implementation contains many reuses :p

[07:38] <luqui> I should know what

[07:38] * luqui is reading

[07:39] <nothingmuch> about how lists scalarify

[07:39] * nothingmuch hasn

[07:39] <nothingmuch> 't yet read those parts thoroughly

[07:39] <luqui> Yeah, pretty sure :key(1,2) means :key([1,2])

[07:43] <scw> luqui: And are :key('val') :key<val> :key{ k => 'v' } all the forms using 'key' as key?

[07:43] <scw> luqui: besides from key => 'val' and alternatives like :key  .('val)

[07:44] <luqui> hmm... 

[07:44] <luqui> I wonder if :key[stuff] is valid

[07:44] <luqui> for certain values of stuff

[07:45] <luqui> ahh, :key[1,2,3,4] is valid

[07:45] <autrijus> cool.

[07:45] <scw> equivalent to :key(1, 2, 3, 4) ?

[07:45] <luqui> Yeah...

[07:45] <autrijus> luqui: you've seen my IMCC.hs plan? thanks it's sane? :)

[07:45] <luqui> which begs whether one of those should not be allowed

[07:45] <autrijus> s/thank/think/

[07:46] <autrijus> well, :key[1] is explicitly a list

[07:46] <luqui> haven't seen it

[07:46] <autrijus> while :key(1) is an element

[07:46] <autrijus> probably makes sense

[07:46] <luqui> yeah

[07:46] <scw> agree

[07:46] <scw> autrijus: I can't find out how  (1, 2)  is parsed in pugs!

[07:46] <autrijus> luqui: oh ok. the plan is to ditch the Eval.hs (pugs evaluator)

[07:47] <autrijus> scw: it's just a binary op "," I think, no?

[07:47] <luqui> good, I never understood that part of it anyway :-p

[07:47] <autrijus> luqui: and merge Compile.Haskell (haskell compiler) with Compile.Parrot (IMCC compiler)

[07:47] <autrijus> the new architacture will be

[07:47] <autrijus> Perl 6 Source comes in

[07:47] <autrijus> we parse it to Pugs AST (ASTh.s)

[07:47] <autrijus> (AST.hs)

[07:47] <autrijus> then we compile it to IMCC AST

[07:48] <autrijus> (IMCC/AST.hs)

[07:48] <autrijus> then we translate that into Template Haskell

[07:48] <autrijus> then we evaluate the haskell code.

[07:48] <autrijus> using Haskell itself.

[07:48] <luqui> IMCC is referring to parrot's IMCC?

[07:48] <crysflame> hmmm

[07:48] <autrijus> the haskell code will just be a IMCC emulator

[07:48] <crysflame> neat

[07:48] <autrijus> re, I mean IMC (aka PIR)

[07:48] <luqui> oh..

[07:48] <scw> Oh, listSyn  " , "

[07:49] <luqui> so you're going to write a pir evaluator in haskell?

[07:51] <nothingmuch> why don't we just depend on parrot while we're at it, and spew things to it directly, via embedding or whatever?

[07:51] <luqui> I think that's a better idea than trying to emulate (ever-changing) pir

[07:54] <autrijus> right.

[07:54] <autrijus> not quite pir evaluator

[07:55] <autrijus> pir->to->nativehaskell compiler

[07:55] <autrijus> which can be compiled and evaulated on the fly

[07:55] <luqui> do you realize how many parrot ops there are?

[07:55] <autrijus> pir-relatd ones are few.

[07:55] <autrijus> it's just Perl*.imc

[07:55] <autrijus> no?

[07:55] <autrijus> Perl*.imc and Continuation and a few primitives

[07:56] <autrijus> don't need to be complete

[07:56] <luqui> opcodes, not pmcs

[07:56] <autrijus> should I care? :)

[07:56] <luqui> (maybe I'm not understanding)

[07:56] <autrijus> I'm not implementing a pasm cpu

[07:56] <autrijus> I'm merely implementing the small subset of pir/imc that is neccessary to run pugs

[07:56] <luqui> oh.. right

[07:57] <autrijus> nothingmuch: because:

[07:57] <autrijus> 1) embedding parrot is very hard at the moment.

[07:57] <autrijus>   (mainly because embed.h was not installed and theere's no ExtUtils::Embed like things)

[07:58] <autrijus> 2) a reference IMC implementatino will free us from the dreaded deadlock situation with PIR bugs and shortcomings

[07:58] <autrijus> 3) We can then understand the operational semantics of IMC without having to trace .c code.

[07:58] <autrijus> 4) The tests can be shared between IMC and Pugs.

[07:58] <luqui> are you going to write a register allocator too?

[07:59] <luqui> or just stick everything in separate registers

[07:59] <nothingmuch> i think we don't care about that

[07:59] <nothingmuch> unless we want performance

[07:59] <nothingmuch> parrot is supposed to be smart about mapping to real CPUs, right?

[07:59] <luqui> yeah, i realized that at some point between my two comments :-)

[08:00] <autrijus> right.

[08:00] <autrijus> I don't care :)

[08:00] * nothingmuch thinks it could be an interesting way to learn IMCC

[08:00] <autrijus> $I* is just a (Map Int Int)

[08:00] <nothingmuch> how complex is it, btw?

[08:00] <autrijus> and $S* is just (Map Int Strnig)

[08:00] <autrijus> nothingmuch: extremely simple :)

[08:00] <nothingmuch> so basically pugs will be:

[08:01] * luqui wonders, if it's so simple, what parrot has been doing for three years

[08:01] <nothingmuch> parser -> our p6 AST -> lazy compiler for IMCC -> evaluator for IMCC

[08:01] <nothingmuch> luqui: i think parrot's focus has been robustness and correcness and portability and efficiency, no?

[08:01] <nothingmuch> also, the design is not simple

[08:01] <nothingmuch> you have to theorize on how things will look

[08:02] <nothingmuch> and then abstract them

[08:02] <nothingmuch> and then break them down, discover their common roots

[08:02] <nothingmuch> and design a language to take care of that

[08:02] <nothingmuch> plus there's some implementation details that are easier in haskell

[08:02] <nothingmuch> GC, and threads, and whatnot

[08:02] <luqui> like the fact that GC is already taken care of

[08:02] <nothingmuch> ooh

[08:02] <nothingmuch> do we have a GC test?

[08:03] * nothingmuch reaaaally wants it to be a bug for things /not/ to be destroyed as soon as possible

[08:03] <nothingmuch> it's one of the most useful things in p5,

[08:03] <luqui> nothingmuch: no luck

[08:03] <luqui> parrot has to do it then, too

[08:03] <luqui> and parrot probably won't

[08:03] <nothingmuch> ?

[08:04] <nothingmuch> i thought parrot has means for smart and refcount GC

[08:04] <nothingmuch> and you get a sort of hybrid system

[08:04] <luqui> no refcount

[08:04] <nothingmuch> oi vey!

[08:04] <luqui> (unless there have been new developments recently)

[08:04] <nothingmuch> so much for compatibility

[08:04] <nothingmuch> how are they going to port Ponie?

[08:04] <luqui> by hijacking perl5 somehow

[08:04] <nothingmuch> that's just plain stupid

[08:05] <nothingmuch> GC can be overkill

[08:05] <crysflame> ponie replaces SVs with a PMC-based SV

[08:05] <nothingmuch> refcounting is fast

[08:05] <nothingmuch> and good

[08:05] <crysflame> port it to what?

[08:05] <nothingmuch> and enough 80% of the time

[08:05] * crysflame goes back to listening.

[08:05] <luqui> according to the studies that Dan read, apparently, refcounting is not fast

[08:06] <luqui> (and /me really wants to be able to use circular references liberally)

[08:06] <luqui> why is everyone so attached to timely destruction?

[08:06] <nothingmuch> timely destruction helps me manage resources

[08:06] <nothingmuch> it's a way to do cleanup

[08:06] <nothingmuch> but encapsulate it

[08:06] <nothingmuch> instead of saying $obj->im_done

[08:06] <nothingmuch> you just throw it away

[08:07] <nothingmuch> and $obj takes care of itself

[08:07] <luqui> how have you used that?

[08:07] <nothingmuch> i have a big system that runs tests on remote machines

[08:07] <nothingmuch> i have resource allocation for things like remote shells, semaphores representing remote resources

[08:07] <nothingmuch> daemons, work directories, etc

[08:07] <nothingmuch> it's not a big change to add $obj->im_done

[08:07] <nothingmuch> to the superclass that implements the job stealing resources from people

[08:08] <nothingmuch> but it's yet another thing i don't want to worry about

[08:08] <luqui> i understand completely

[08:08] * luqui just had to write cleanup() callbacks for Logic.pm

[08:08] <luqui> and it's a pain, even though it's not

[08:08] <nothingmuch> and /maybe/, /sometime/, perhaps they will be destroyed

[08:09] <nothingmuch> it's more of the horror stories from the other side that scare me

[08:09] <nothingmuch> lumi said something along these lines about java:

[08:09] <nothingmuch> you have objects, and err, then you're done with them

[08:09] <nothingmuch> he said it was very annoying

[08:10] <luqui> well, perl 6 has lexical hooks, which takes a good 80% off of the need for timely destruction

[08:10] <luqui> but there's still that 20%

[08:11] * nothingmuch wonders why a hybrid system can't be formulated

[08:11] <luqui> because Dan has been opposed to it

[08:11] <luqui> and leo has been silent about it

[08:11] <luqui> but maybe Chip will listen :-)

[08:11] <luqui> leo has been trying to work in a generational gc for awhile

[08:11] * luqui hasn't really followed that

[08:12] <nothingmuch> a hybrid system pleases both sides

[08:12] <nothingmuch> you get "proper" garbage collection

[08:12] <nothingmuch> which takes care of loops, in some smart way

[08:12] <nothingmuch> and some kind of reference count like system to invoke small increments of that thing when things are thrown away

[08:13] <luqui> you know that you can never get timely destruction on circular structures

[08:13] <luqui> so what if people start expecting timely destruction, and they have a circular structure, and then it doesn't work

[08:14] <luqui> as opposed to saying up front "there is no timely destrution"

[08:14] <luqui> if we say "there is timely destrution most of the time"

[08:14] <luqui> then bugs will be subtler

[08:15] <nothingmuch> what if a generational GC was triggerred by a refcount system?

[08:16] <nothingmuch> or at least a container destruction system/

[08:16] <nothingmuch> i mean, say a block exits

[08:16] <nothingmuch> it's lexical scope is thrown away

[08:16] <luqui> scw, to get back to you about an hour ago:  there is also :key<<value1 $value2 value3>>

[08:16] <nothingmuch> the generational GC can then treat the young generation as the stuff that was referred by the pad

[08:17] <luqui> because you still need to do a full sweep to guarantee anything

[08:17] <luqui> otherwise you're just guessing, and getting it right most of the time

[08:17] <luqui> but not all the time

[08:17] <nothingmuch> what about introducing mutual weakness at the reference level?

[08:17] <nothingmuch> trying to detect what is circular

[08:18] <nothingmuch> and when one of these links is traversed, it and it's siblings are weakened

[08:18] <luqui> I wonder if there's a good way to detect when you have circular structures

[08:18] <scw> luqui: How about unicode version of << >> ? they should be equivelant?

[08:18] <nothingmuch> detecting circularity in this manner shouldn't be too complicated

[08:19] <luqui> I was actually referring to the unicode versions, but I believe they're equivalent everywhere

[08:19] <luqui> the question is, can you do it efficiently enough

[08:19] * nothingmuch is really not familiar with graph theories

[08:19] <nothingmuch> should go learn compsci some time

[08:20] <luqui> the problem is that most of these "detections" are O(n)

[08:20] <luqui> and n is all the objects in the program

[08:20] <luqui> which brings you right back to what we have, mark-sweep

[08:20] <nothingmuch> http://www.cs.cornell.edu/boom/2004sp/ProjectArch/Memory%20Leak/csuglab.cornell.edu/index16.html

[08:20] <brentdax> My God, you Pugs people have been busy.

[08:20] <nothingmuch> that's interesting, though it doesn't solve our problem

[08:20] <luqui> I've hard of that

[08:20] <luqui> heard

[08:21] <luqui> Kim wrote an article about it

[08:21] <luqui> (Kim Burchett, of kimbly.com)

[08:21] <luqui> (one of Dan's favorite blogs, it seems)

[08:21] <luqui> heard it was very awkward

[08:22] <nothingmuch> how do ddd and other similar programs work?

[08:23] <luqui> I think they annotate the memory allocation structures

[08:23] <luqui> and then test whether any are remaining at program exit

[08:23] <luqui> like valgrind

[08:24] <luqui> A friend points us here: http://dev.perl.org/perl6/exegesis/E07.html

[08:24] <luqui> er not there

[08:24] <luqui> here: http://www.cs.colorado.edu/~lizb/private/phd-course/diwan2.pdf

[08:25] <lightstep> some early smalltalk systems had a hybrid system: you had refcounts, when they overflowed the object was delegated to the gc, and once in a while they did a full sweep

[08:25] <nothingmuch> http://citeseer.ist.psu.edu/context/13435/2716

[08:25] <lightstep> but this scheme wasn't good at all

[08:26] <luqui> what were the weaknesses?

[08:26] <nothingmuch> can we use typing to make GC sweeps less slurpy?

[08:26] <nothingmuch> or does parrot not support typing?

[08:26] <autrijus> sorry, bbiab :)

[08:27] <nothingmuch> ciao autrijus

[08:27] <luqui> well we certainly can't rely on it

[08:27] <lightstep> luqui, it was slower than generational gc

[08:27] <luqui> and most of the languages we support wouldn't give it any information

[08:28] <nothingmuch> but in theory a language compiler that is smart enough could help the GC system be quick

[08:28] <lightstep> nothingmuch, i don't understand. are you worried about memory leaks or about activation of finalizers?

[08:28] <luqui> it started as the latter :-)

[08:28] <nothingmuch> both

[08:29] <nothingmuch> =)

[08:29] <nothingmuch> i prefer activation of finalizers

[08:29] <nothingmuch> but most people prefer being trigger happy with circular structures

[08:29] <nothingmuch> my style for increasing robustness is to put all annoying details together

[08:29] <nothingmuch> in the begining

[08:29] <nothingmuch> that is, all refcount weakening is centralized

[08:29] <nothingmuch> for the same object

[08:29] <nothingmuch> unless I really can't pull that off

[08:29] <nothingmuch> this lets me rely on refcounting to stay pretty

[08:29] <nothingmuch> and for me it's worth the effort

[08:32] <luqui> have you seen what POE has to do to get around the circular structure bs?

[08:32] <luqui> it has to implement its own refcounter

[08:32] * nothingmuch guesses his programming style will have to change

[08:32] <nothingmuch> ook

[08:32] <nothingmuch> i've done that once

[08:32] <nothingmuch> i wanted to have an LRU cache that purges at O(1)

[08:33] <nothingmuch> ofcourse, it didn't, since it was using perl structures

[08:33] <nothingmuch> but it was just an excercise

[08:33] <nothingmuch> and when it's accessed it's spliced up to the top

[08:33] <nothingmuch> it had a doubly linked list, where references go in

[08:34] <nothingmuch> the hash that caches contains a reference to the link element

[08:34] <nothingmuch> when the cache overflows elements are popped off the list

[08:34] * nothingmuch loves writing things and feeling really clever, when he tries to understand a feature

[08:34] <nothingmuch> since then, when I learned about refcounting, and made myself face it the hard way, i like it

[08:35] <nothingmuch> because what it gives me, it gives at a cost i'm willing to pay

[08:35] <luqui> basically, which cost is the general programming public willing to pay?

[08:35] <lightstep> the common wisdom is that gc is at least as fast as refcounts (less page faults)

[08:36] <luqui> learning about refcounting, or calling .close on things

[08:36] <luqui> yeah, cache locality is a big issue, so I'm learning while working on parrot

[08:36] <nothingmuch> Cocoa has a 

[08:36] <nothingmuch> weird feature

[08:36] <nothingmuch> they call them allocation zones

[08:37] <luqui> go on

[08:37] <nothingmuch> which are a techinque to help optimize the allocation, so that related objects are paged from the swap together

[08:37] <lightstep> oh

[08:37] <lightstep> there's talk about regions in dome papers, but i don't know what they are

[08:38] <luqui> is cocoa refcounted?

[08:38] <lightstep> maybe it's related

[08:38] <nothingmuch> so the NSObject base class has [class alloc] and [class allocWithZone:Zone]

[08:38] <kakos> Obj-C is

[08:38] <nothingmuch> cocoa is refcounted manually

[08:38] <luqui> ok

[08:38] <nothingmuch> kakos - objective c isn't, it's just C

[08:38] <kakos> nothingmuch: Really?  My bad then.

[08:38] <nothingmuch> but you have a shortcut

[08:39] <nothingmuch> cocoa is, by supplying the allocation pool objects

[08:39] <nothingmuch> anyway, what you have is a sort of singleton

[08:39] <nothingmuch> objc/cocoa are very tightly coupled though, so it seems like it =)

[08:39] <nothingmuch> except it's really a stack

[08:39] <nothingmuch> you push an allocation pool onto it

[08:39] <luqui> are you really typing that fast?

[08:39] <nothingmuch> and then you tell objects to autorelease

[08:39] <nothingmuch> and they say to the release pool, destroy me whenever

[08:39] <nothingmuch> and when the pool is destroyed it refcounts it down

[08:39] <nothingmuch> yes, i am ;-)

[08:39] <luqui> you type faster than I read

[08:40] <nothingmuch> i type too slow, IMHO, or rather, I think that I think too fast

[08:40] <nothingmuch> i need to type slower, and think much slower, and then maybe i could make some sense

[08:40] <nothingmuch> languages have never been my friend

[08:41] <luqui> well, I've wasted far too much time

[08:41] <luqui> here

[08:41] <luqui> "wasted"

[08:41] <nothingmuch> ditto =(

[08:41] <luqui> I need to get back to my homework which is due in six hours

[08:42] * luqui &

[08:43] <nothingmuch> good luck, luqui 

[08:44] <nothingmuch> http://www.google.com/url?sa=U&start=42&q=http://portal.acm.org/ft_gateway.cfm%3Fid%3D361957%26type%3Dpdf&e=7152

[08:44] <nothingmuch> i think i'm reading that right now, not too sure

[08:44] <nothingmuch> it looks like generational meets alloc zones, or whatever

[08:55] * nothingmuch wonders if a zone system with an index of all refererences to and from foreign objects could be used to try and search for circular objects in a more graphical manner

[08:55] <nothingmuch> tightly related objects link within the zone

[08:55] <nothingmuch> so to not cause too much overhead

[08:58] <nothingmuch> with multiple zoning levels, and circularity between zones dealt with traditionally, you could move the complexity to a smaller N, i think

[08:59] <nothingmuch> the cost being at reference time

[08:59] <nothingmuch> within zones, an optimistic GC could be safer, because it knows what objects are foreign

[09:01] <nothingmuch> zones should be per object at the lowest level, and if two zones share a great number of links, then they are bound together in a new zone

[09:01] <nothingmuch> and insignificant zones can subsequently be optimized away

[09:01] <nothingmuch> which is really where there is a gamble

[09:02] <nothingmuch> since then you can't repartition a zone easily

[09:03] <lightstep> but when creating the program you have some idea of the memory allocation patterns. throwing it away and reconstructing in runtime is bad

[09:03] <nothingmuch> you mean, the object definitions, etc?

[09:04] <lightstep> the zones

[09:04] <lightstep> the programmer, and even the compiler, have data that can significantly improve the zone tree

[09:05] <nothingmuch> right

[09:05] <lightstep> and using this impormation might obviate the repartitioning at runtime

[09:05] <lightstep> the need for

[09:05] <nothingmuch> exactly

[09:05] <nothingmuch> with that data

[09:05] <nothingmuch> and also statistics

[09:05] <nothingmuch> either gathered, saved, and learned

[09:05] <nothingmuch> or during runtime, for prediction

[09:06] <nothingmuch> could help the GC throw away zones which can be safely forgotten about

[11:57] <jabbot> pugs - 1275 - Testing the wrong thing.

[11:57] <jabbot> pugs - 1274 - Accepting :key('val1', 'val2') and :key[

[11:57] <jabbot> pugs - 1273 - Accepting :key<val1 val2>.

[11:58] <autrijus> wow.i

[11:58] <nothingmuch> ?

[11:58] <autrijus> :key[] :key<> and :key()

[11:58] <autrijus> so nice.

[11:58] <obra> hey autrijus 

[11:58] <autrijus> hey obra.

[11:59] <autrijus> MRT++ # fast fast wireless

[11:59] <obra> nice

[11:59] <obra> autrijus: how'd you solve their issue?

[11:59] <autrijus> scw++ # mad and motivated

[11:59] <autrijus> obra: I had.

[11:59] <clkao> svk branched for 1.0 release engineering

[11:59] <luqui> hey autrijus, have you begun BEGIN?

[11:59] <autrijus> obra: their visual basic component was not freeing its handles.

[11:59] <autrijus> luqui: no, feel free to work on it.

[11:59] <obra> is that the issue?

[11:59] <nothingmuch> if it weren't for crazy people pugs would never have been... =)

[11:59] <obra> the whole issue?

[11:59] <autrijus> luqui: it's part of the 3-stage compilation plan.

[11:59] <autrijus> obra: well, there's various complications.

[12:00] <autrijus> obra: I switched DBD::ODBC to DBD::ADO; that fixed threaded contention

[12:00] <autrijus> then I increased timeout, which fixed starvation

[12:00] <luqui> hmm... I'm thinking the best way to do it is to implement macros

[12:00] <nothingmuch> autrijus: give me an idea for something to do for pugs

[12:00] <nothingmuch> i'm a bit sick of fighting with vim

[12:00] <autrijus> but the core bug is that their VB component was not doing things correctly.

[12:00] <luqui> and BEGIN is a very simple macro

[12:00] <autrijus> luqui: explain. BEGIN is compilation time, not runtime

[12:00] <luqui> fighting with vim?

[12:00] <luqui> vim is wonderful

[12:01] <autrijus> obra: so I'm like, charging them fully, because that's outside my contractual obligation.

[12:01] <nothingmuch> it is

[12:01] <nothingmuch> Text::VimColors is not, though

[12:01] <luqui> autrijus: macros are also compile time

[12:01] <nothingmuch> for some reason, even though it display =pod .... =cut as comments normally

[12:01] <autrijus> luqui: oh. macros with side effects, eh.

[12:01] <obra> autrijus: nice

[12:01] <autrijus> luqui: sure... I punted macros only because they are not specced at all.

[12:01] <nothingmuch> the html from Text::VimColors has the pod parsed as perl

[12:01] <luqui> they are a little bit

[12:02] <luqui> anyway, should I just use what's in place in Eval.hs?

[12:02] <autrijus> luqui: not to my eyes, so feel free to work on it :D

[12:02] <nothingmuch> the mysterious 'is parsed' trait is sooooo scary

[12:02] <autrijus> luqui: sure. none of Eval monad will be invalidated

[12:02] <luqui> okay cool

[12:02] <autrijus> it will just magically become a compiler.

[12:02] <autrijus> that's the point of this whole monadic revolution :)

[12:02] <nothingmuch> we're thinking of forking the test reporting stuff into another project

[12:02] <nothingmuch> what should we call it?

[12:03] <luqui> nothingmuch: but is parsed is not a macro-only thing

[12:03] <autrijus> nothingmuch: look at test failures and pick some easier ones?

[12:03] <nothingmuch> it should do the doc backlinking, the pretty graph things, and whatever

[12:03] <luqui> it's quite orthogonal

[12:03] <autrijus> nothingmuch: Test::Visualize ?

[12:03] <nothingmuch> smoker data consolidation

[12:03] <nothingmuch> it's more a collection of scripts

[12:03] <nothingmuch> why not

[12:04] <scw> autrijus: I just want the function call   write "something", :bold

[12:04] <scw> :p

[12:05] <autrijus> scw: and it works now?

[12:07] <scw> autrijus: definitely :)

[12:07] * nothingmuch wonders where his funky GC scheme is utterly broken

[12:07] <nothingmuch> luqui: did you read a bit?

[12:07] <scw> autrijus: t/subroutines/sub_named_params.t:88

[12:07] <luqui> no, I finished my math test :-)

[12:07] <autrijus> scw: wonderful!

[12:08] <luqui> nothingmuch: it might be good to outline it in a little doc

[12:08] <luqui> so people can think about it concretely

[12:08] <nothingmuch> are you sure that isn't pointless?

[12:09] <nothingmuch> it was more of an excercise in triz like thinking

[12:09] * nothingmuch tries anyway

[12:10] <luqui> well, mostly because I have no idea what your scheme is...

[12:10] <nothingmuch> ok

[12:10] <luqui> and I'm not paying enough attention right now to listen

[12:10] <nothingmuch> so i'll write =)

[12:11] * autrijus needs to work on PA02 too.

[12:11] <autrijus> but, taking MRT back home &

[12:15] <gaal> nothingmuch: how about Smoke and Mirrors? (S&M for short :)

[12:15] <nothingmuch> gaal: that's not very search.cpan.org savvy

[12:15] <gaal> the yaml harness is almost entirely not dependent on pugs

[12:15] <gaal> it needs some smarts to detect other source control system

[12:15] <gaal> s

[12:16] <nothingmuch> what I think we'll do:

[12:16] <nothingmuch> create a test reporter

[12:16] <nothingmuch> that creates YAML

[12:16] <nothingmuch> and inserts revision/arch info

[12:16] <nothingmuch> the YAML harness is used by it, but unrelated

[12:16] <gaal> plus there's one place where i get the version of pugs itself, but if there's a contract that the project declares its version somewhere clear, i could use that

[12:16] <nothingmuch> then we have data consolidation

[12:17] <nothingmuch> i think YAML harness should take that data out, and deal only with actual test results for now

[12:17] <gaal> "test reporter" can just be another output mode for Test.pm, no?

[12:17] <jabbot> pugs - 1276 - 

[12:17] <nothingmuch> the catalogging thing should be decoupled too

[12:17] <nothingmuch> into a doc/test link system

[12:17] <nothingmuch> where you can declare shortcuts for doc names

[12:17] <nothingmuch> so we can retain S02

[12:18] <nothingmuch> the grapher should be a bit smarter, and take consolidated results as a data structure

[12:18] <nothingmuch> and display them as such

[12:18] <nothingmuch> the consolidator takes YAML, and makes a structure for the grapher

[12:19] <nothingmuch> and lastly Test::Builder should have the $?CALLER::CALLER::POSITION hack for graph->file linking

[12:21] <gaal> that's a useful extentsion to TAP, in any case

[12:21] <nothingmuch> yah

[12:21] <nothingmuch> we should delegate that responsibility to andy lester

[12:22] <gaal> petition for it, you mean :) and offer our current Test.pm with our appeal

[12:26] <leo_> fireall test

[12:26] <luqui> is leo leo?

[12:26] <leo_> leo is leo :)

[12:26] <nothingmuch> leo_: pond

[12:27] <luqui> hi leo

[12:27] <nothingmuch> s/d$/g

[12:28] <leo_> my first visit to IRC ever - just looking what my firewall says

[12:28] <obra> heya leo

[12:30] <clkao> leo!

[12:30] * q[acme] waves

[12:30] <leo_> yes?

[12:33] <Juerd> Hi leo_ 

[12:34] <nothingmuch> leo_! leo_! leo_!

[12:34] <leo_> hi all 

[12:34] * nothingmuch mimicks someone elses voice: "is leo_ here?"

[12:34] <leo_> yes - first time on IRC

[12:34] <q[acme]> and what does the firewall say?

[12:35] <leo_> not sure yet but modeprobing ip_mask_irc seems have done it

[12:35] <autrijus> hi leo!

[12:35] <autrijus> I'm in middle of MRT station

[12:35] <autrijus> it only stops for 10 secs

[12:36] <leo_> hi autrijus

[12:36] <autrijus> so... brb :))

[12:36] <Juerd> Hi autrijus, Bye autrijus.

[12:36] <autrijus> = be right back

[12:37] <hcchien> fg

[12:37] <hcchien> ouch.....

[12:37] <Juerd> heh

[12:37] <Juerd> leo_: How have you managed to live without irc? :)

[12:37] <autrijus> :) at jian tan station now

[12:37] <autrijus> err, shih lin

[12:38] <obra>  hey autrijus 

[12:38] <Juerd> I'm 21, and spent the last 10 years on IRC... :)

[12:38] <Juerd> I can't imagine life without :P

[12:38] <obra> we got clkao to branch svk

[12:38] <leo_> well - the metered ISDN line. it already dropped the line once

[12:38] <hcchien> autrijus: back to Danshui?

[12:39] <leo_> I'm 47, and spent the last 12 minutes on IRC ;)

[12:40] <Juerd> Heh, I imagined you younger (no offense)

[12:41] <leo_> I feel younger

[12:42] <leo_> are there any Parrot related questions?

[12:42] <Juerd> Does IRC make you feel younger? :)

[12:42] <Juerd> I have no questions at this moment

[12:43] <leo_> IRC looks still very strange to me - but I get used to it

[12:43] <Juerd> If you need any help, just ask for it

[12:44] <leo_> thanks, not yet, I've to explore it a bit first

[12:48] <pjcj> Do you know where #parrot is?

[12:48] <q[acme]> pjcj: you scared him off!

[12:48] <Juerd> Not there :)

[12:48] <nothingmuch> luqui: http://nothingmuch.woobling.org/gc_zones.txt

[12:49] <nothingmuch> i have only thought about it about 10 minutes though

[12:49] <nothingmuch> so it's likely to have big holes

[12:49] <nothingmuch> but it appears to me that with a certain overhead when you refer to other objects, you can gain a lot later when looking for objects to destroy

[12:49] <nothingmuch> leo_: this might interest you too... ./configure --disable-layout --disable-tests --disable-samples

[12:49] <nothingmuch> oops, http://nothingmuch.woobling.org/gc_zones.txt

[12:50] <nothingmuch> though please take it with a grain of salt, as I have no clue what I'm doing.

[12:52] <integral> ah, zones can't form loops so it's safe to ref count them?

[12:53] <integral> oh, not at all.

[12:55] <nothingmuch> integral: ah?

[12:55] <nothingmuch> zones are a tree of partitions and sub partitions

[12:55] <nothingmuch> a zone can have only one parent

[12:55] <nothingmuch> and knows about zones it's children relate to

[12:55] <nothingmuch> a zone whose children relate to no one

[12:55] <nothingmuch> not even the roots of the data tree (registers, or the stack) can be simply deleted as is

[12:56] <integral> oh, so the zones nest, rather than partition the whole of memory

[12:56] <nothingmuch> right

[12:56] <nothingmuch> if they nest down to the lowest level, then you get nothing

[12:56] <nothingmuch> the real issue is to know what zones don't help you

[12:56] <nothingmuch> ideally many levels of leafs

[12:57] <nothingmuch> so that your low level zones are several hundred objects, maybe a little less, maybe a little more

[12:57] <nothingmuch> integral: am I being too naive?

[12:58] <integral> I don't really know enough to tell.   How are the low-level zones being built?

[12:58] <integral> Are they created from compile-time information?

[12:59] <nothingmuch> well, in theory each object has it's own zone when it's constructed

[12:59] <nothingmuch> and when it reaches out to other objects it should have it's zone optimized away very quickly

[12:59] <nothingmuch> in practice you could pre optimize, maybe

[12:59] <nothingmuch> compile time info helps you partition the zones more wisely, methinks

[12:59] <nothingmuch> by using type constraints you can know where zones won't touch, because their objects can't reference each other

[12:59] <nothingmuch> the hosted language could provide this data to the GC

[12:59] <Juerd> Holy crap, this channel has 86 nicks in it

[13:00] <nothingmuch> Juerd?

[13:00] <Juerd> nothingmuch: I don't know any other channel that has grown this fast

[13:00] <nothingmuch> err, not provide

[13:00] <nothingmuch> but help the GC

[13:00] <nothingmuch> ah

[13:00] <nothingmuch> it grows by about 5 people a week, on avg, afaict

[13:01] <Juerd> No, much faster.

[13:01] <nothingmuch> it seems like a lot, but then again, i have never lurked on IRC

[13:01] <Juerd> It has existed less than two months.

[13:01] <nothingmuch> i mean over the last 3 weeks or so, since i joined

[13:01] <integral> I don't know any project that has gathered commiters so fast either :-)

[13:01] <tombom> the only reason i came was because of ghc 6.4 reporting an impossible error in main.hs

[13:01] <nothingmuch> that is what's really impressive =)

[13:01] <Juerd> integral: yea

[13:01] <nothingmuch> (to me)

[13:02] <nothingmuch> so, does anybody have on opinion about that GC scheme?

[13:05] <leo__> line dropped again :(

[13:06] <Juerd> leo's collecting underscores

[13:07] <nothingmuch> i was just about to make a joke about leo___

[13:07] <leo__> I don't yet understand gc_zones.txt

[13:07] <leo__> yeah, what are these underscores?

[13:07] <nothingmuch> when the nick is taken

[13:07] <nothingmuch> since the old you did not log out yet

[13:07] <Juerd> leo__: When you reconnect and the old client is still "connected" to the server, the old nick is taken

[13:07] <leo__> by me

[13:07] <nothingmuch> then you get a temp

[13:07] <Juerd> leo__: Your client then has to make up another nickname, usually formed by ~= "_"

[13:08] <nothingmuch> anyway, the zones basically are:

[13:08] <Juerd> leo__: Use /nick leo to return to the original one

[13:08] <nothingmuch> a way to group objects into groups

[13:08] <nothingmuch> for the sake of simplifying grabage collection

[13:09] <nothingmuch> so that it's feasable to do something equivelent to a full sweep

[13:09] <nothingmuch> in a complexity closer to reference counting

[13:09] <nothingmuch> except that it's a bit more complicated than reference counting, and possibly (probably) completely wrong

[13:09] <leo__> one group per object kind?

[13:09] <nothingmuch> that's how it starts

[13:09] <skypp> #haskell

[13:09] <Juerd> skypp: Type /join #haskell to join that channel

[13:09] <nothingmuch> but very quickly the leaf level zones should be forgotten

[13:09] <Juerd> skypp: Without the /join, it's a normal message.

[13:10] <nothingmuch> and the objects close to each other just packed directly under one medium sized zone

[13:10] <lumi> "delete whole zones at a time" -- In what order are the objects destroyed?

[13:10] <nothingmuch> lumi: =P

[13:10] <lumi> Frankly I'll just be glad for finalizing at all... :P

[13:11] <nothingmuch> where do you start to destroy a cyclic structure?

[13:11] <nothingmuch> at the node that was first refcounted to zero?

[13:11] <nothingmuch> brb, i've got to rescue someone

[13:11] <lumi> True, but that's not an answer

[13:13] <nothingmuch> i don't know

[13:13] <lumi> I guess they'd need to order themselves if it's important

[13:13] <nothingmuch> i think that's for the language design to decide

[13:13] <nothingmuch> or provide hooks for

[13:13] <nothingmuch> in theory you have a set of object

[13:13] <nothingmuch> s

[13:14] <nothingmuch> unordered

[13:14] <nothingmuch> in a zone

[13:14] <nothingmuch> you could destroy based on reverse chronological order of creation, if that's your thing

[13:14] <nothingmuch> i dunno

[13:14] <nothingmuch> leo__: is it any clearer?

[13:15] <nothingmuch> lumi: err, i've been doing a lot of 'echo powerpc-apple-darwin7.8.0; exit' in config.guess files

[13:15] <leo__> not much, no - need probably a picture of object/zone relations

[13:15] <nothingmuch> think of a graph of objects

[13:15] <nothingmuch> and zones are non intersecting circles

[13:15] <nothingmuch> which could contain other smaller circles

[13:16] <theorbtwo> Mornin, all.

[13:16] <nothingmuch> morning theorbtwo 

[13:16] <leo__> I think a generational GC system has to tightly integrate with the interpreter

[13:17] <leo__> e.g. it has to know, when a scope is created or destroyed

[13:17] <nothingmuch> but generational GCs can't ensure immediate finalization, right?

[13:18] <leo__> we have to do a lazy GC sweep at scope exit

[13:18] <leo__> there are two cases: eagerly object is found - fine

[13:19] <leo__> or not then the next older generation has to be considered

[13:19] <theorbtwo> Is it just me, or is there a sharp increase in test fails?

[13:20] <nothingmuch> theorbtwo: i thought there was a decrease

[13:24] <nothingmuch> leo__: is a generational lookup equivelent (in terms of side effect) to a full seeep?

[13:24] <nothingmuch> swwp

[13:24] <nothingmuch> sweep

[13:24] <nothingmuch> damn

[13:26] <leo__> if e.g. the ParrotIO object is found in the youngest generation, only this generation is looked at

[13:26] * nothingmuch is a bit slow

[13:26] <nothingmuch> could this means that a now unreferred object exists in an older generation?

[13:26] <nothingmuch> like, if i explicitly 'undef' a global?

[13:27] <nothingmuch> or is that special case treated?

[13:27] <leo__> it depends. If someone was stuffing the IO object into an array, the generation of this arya has to be swept

[13:27] <leo__> that cab of course get expensive

[13:29] <nothingmuch> what my idea sort of tries to handle is to allow a reference counting like approach for finding data

[13:29] <nothingmuch> but with mark & sweep safety/correctness

[13:29] <nothingmuch> by doing some cross indexing when objects refer to each other

[13:30] <leo__> ref counint is nasty, especially with shared objects

[13:32] <luqui> nothingmuch: re gc_zones, your system seems to incur too much overhead for what we're looking at (people complain that java programs are memory hungry, we'd rather not say the same)

[13:32] <luqui> but it does bring up an interesting idea

[13:33] <nothingmuch> luqui: ofcourse, it's a question of balance

[13:33] <nothingmuch> i think the overhead is big

[13:33] <luqui> could we refcount on topological closures of objects

[13:33] <luqui> if we could, then we could handle circular references

[13:34] <nothingmuch> but if you optimize your zone tree like btrees are

[13:34] <nothingmuch> with wide nodes (wide zones), in theory it could work

[13:34] <nothingmuch> explain please =)

[13:34] <luqui> do you know what a graph closure is?

[13:34] <nothingmuch> no clue

[13:34] * nothingmuch only knows what 'edge' and 'dot' means

[13:34] <luqui> it's the set of nodes, starting with one node, that that node "eventually" points to

[13:35] <nothingmuch> oh, node is the term for dot =)

[13:35] <luqui> hehe

[13:35] <theorbtwo> Yup.

[13:35] <nothingmuch> how do you generate this closure?

[13:35] <luqui> using the closure algorithm

[13:35] <Limbic_Region> leo does IRC now?

[13:35] <luqui> basically a simple breadth-first search

[13:35] <Limbic_Region> welcome ;-)

[13:36] <luqui> for instance, the LR parser makes closures of productions in order to figure out what states it needs

[13:36] <luqui> what if the GC objects were object closures?

[13:36] <luqui> I'll have to think about this one a bit

[13:36] <luqui> it might be really cool

[13:36] <luqui> (and will probably be too expensive to do in practicality)

[13:37] <nothingmuch> luqui: i think it's sort of the same

[13:37] <luqui> yeah

[13:38] <luqui> gee, I wonder why I thought of it right after reading your description :-p

[13:38] <Juerd> Speaking of closures, can join '', 1..5 => map { foo() } be written as { foo() } x 5?

[13:38] <nothingmuch> =P

[13:38] <luqui> Juerd: it's an interesting proposition

[13:39] <luqui> but then we'd probably have to do (the much more commonly wanted) { foo() } xx 5

[13:39] <Juerd> Both.

[13:39] <luqui> which would prohibit us from duplicating a closure that way

[13:39] <luqui> but it might be a worthwhile trade-off

[13:39] <Juerd> Why would you want 5 times the same closure?

[13:39] <luqui> why would you want 5 times the same string?

[13:39] <nothingmuch> luqui: what i think i tried to do, if i understand the closure idea, is to attempt to optimize some of them away

[13:39] <Juerd> NOT SAME! :)

[13:39] <Juerd> That's the important thing.

[13:40] <Juerd> It should call foo() 5 times, as the map does

[13:40] <luqui> I'm just saying that (list)x5 was in Perl 5 for a reason

[13:40] <Juerd> Yes, I realise that

[13:40] <nothingmuch> and use the statistics collected to create an approximate representation of them, while the references are built up

[13:40] <Juerd> But I can't think of a reason for needing duplicate closures yet :)

[13:40] <luqui> well, closures are objects too

[13:40] <nothingmuch> Juerd: to trick something that thinks it's taking distinct closures

[13:41] <Juerd> And if you need them, the "sub" keyword can probably disambiguate

[13:41] <luqui> I think if we do it purely on the syntactic level I think it should be okay

[13:41] <luqui> my $foo = { bar() };  $foo xx 5;  # five of the same closure

[13:41] <Juerd> Or even double { } 

[13:41] <luqui> { bar() } xx 5;  # call bar() five times

[13:41] <Juerd> { { foo() } } xx 5;  # 5 closures

[13:41] <Juerd> sub { foo() } xx 5;  # 5 closures

[13:41] <nothingmuch> how do you tell apart a closure with a closure

[13:42] <luqui> Juerd: those would all be distinct (in your earlier example)

[13:42] <Juerd> { foo() } xx 5;  # whatever the 5 foos returned

[13:42] <nothingmuch> { { } } from { }

[13:42] <nothingmuch> at the user level?

[13:42] <Juerd> nothingmuch: What is 'user level'?

[13:42] <nothingmuch> using perl6

[13:42] <nothingmuch> how could i know if closure x is { { } }

[13:42] <nothingmuch> and closure y is { }

[13:42] <nothingmuch> where is the difference? only at the syntax level?

[13:42] <Juerd> You don't have to

[13:42] <nothingmuch> if so, then it isn't reusable

[13:42] <luqui> I think he's saying that if you execute the closure, you get another closure back

[13:42] <Juerd> { { } } benefits from executing the outer closure, returning the inner.

[13:42] <gaal> how do i declare a class constant? our $F_STORABLE is constant = 1; ?

[13:43] <nothingmuch> if there is a difference, then i think it leads to inconsistency

[13:43] <nothingmuch> ah

[13:43] <nothingmuch> ok

[13:43] <nothingmuch> i get it now

[13:43] <luqui> but the closures you get back would all be distinct

[13:43] <luqui> so that's a problem

[13:43] <Juerd> (Note that I haven't read on hash/sub choices yet)

[13:43] <Juerd> luqui: Good point.

[13:43] <nothingmuch> so basically what you want is for 'x' to interpolate /after/ it's repeated?

[13:43] <luqui> So like I said, it's probably okay if we do it on the syntax level rather then the semantic level

[13:44] <nothingmuch> i disagree with that

[13:44] <autrijus> leo_: greetings!

[13:44] <luqui> nothingmuch: por que?

[13:44] <autrijus> I'm now safely back to home.

[13:44] <nothingmuch> it's not p6ish in the consistency approach

[13:44] <nothingmuch> it's a special case

[13:44] <nothingmuch> "why was this called 5 times?"

[13:44] <luqui> Perl 6 has syntactic special cases

[13:44] <Juerd> nothingmuch: No, I want a better syntax for the extremely often used map 1..x where 1..x is just to make it loop x times

[13:44] <luqui> why does #line give me metainformation?

[13:44] <nothingmuch> "well, if you read chapter 54.3.2.5 you would have seen that"

[13:44] <nothingmuch> luqui: but we want to minimize them, right?

[13:44] <Juerd> nothingmuch: See ~~ - it has syntactic matches.

[13:45] <luqui> yeah, that's true

[13:45] <Juerd> nothingmuch: These you can't pass as values, for example

[13:45] <Juerd> But they are useful.

[13:45] <nothingmuch> isn't that better written as:

[13:45] <nothingmuch> ~({ foo () } xx 5)?

[13:46] <nothingmuch> instead of { foo() } x 5? or { { foo () } } x 5?

[13:46] <luqui> but that's the feature we're discussing

[13:46] <luqui> whether that closure would execute

[13:46] <luqui> or whether you'd just be trying to stringify the closure

[13:46] <nothingmuch> i think the more general the case, the more desirable it is

[13:46] <luqui> ?

[13:46] <nothingmuch> you could express { foo() } x 5 in Juerd's way

[13:46] <nothingmuch> even though it's typical

[13:47] <nothingmuch> with perl6 semantics that have no special case

[13:47] <Juerd> nothingmuch: I think the more practical use something has, the more desirable it is

[13:47] <nothingmuch> at around 3 chars more

[13:47] <nothingmuch> Juerd: but then you block out a certain feature

[13:47] <nothingmuch> or require adding a special case

[13:47] <Juerd> Perl stands for dwimmery more than for consistency.

[13:47] <luqui> nothingmuch: your ~({foo()} xx 5) is not standard perl 6

[13:47] <luqui> and would be a special case

[13:47] <nothingmuch> why is that a special case?

[13:47] <luqui> because currently that would not execute the closure

[13:47] <Juerd> nothingmuch: No, the other feature would require syntactic disambiguation, for example by adding a "sub" keyword.

[13:48] <nothingmuch> Juerd: but reading that for the first time

[13:48] <nothingmuch> without having read about the special case

[13:48] <nothingmuch> does not make any sense

[13:48] <nothingmuch> it's like pascal

[13:48] <luqui> Juerd: I think adding a "sub" keyword is the wrong way to disambiguate, but I agree with you in principle

[13:49] <luqui> I think it naturally falls out if we allow {foo()} xx 5

[13:49] <nothingmuch> inconsistencies with pascal that really hinder readability:

[13:49] <nothingmuch> in declaration you have 1 .. 5, in loops you have 1 TO 5

[13:49] <nothingmuch> begin ... end; are symmetric, except where they aren't

[13:49] <nothingmuch> some block openings are two lines, others are one line, or else they don't match up well

[13:49] <Juerd> This isn't pascal

[13:49] <nothingmuch> var is used too often

[13:49] <nothingmuch> to declare the property of a name

[13:50] <nothingmuch> and it's behavior

[13:50] <nothingmuch> and a section where names are declared

[13:50] <luqui> okay, I think you should go to #pascalrant

[13:50] <luqui> :-)

[13:50] <nothingmuch> these are things that perl sometimes exhibits

[13:50] <nothingmuch> though less obviously

[13:50] <nothingmuch> which is even more dangerous

[13:50] <luqui> then give us perl examples

[13:50] <nothingmuch> throwing a 'sub' to disambiguate is a bit yucky

[13:50] <Juerd> It's a problem if the result is hard to spot

[13:51] <nothingmuch> luqui: using parens and stuff to listify in p5

[13:51] <nothingmuch> () = ....

[13:51] <nothingmuch> () x 5 in list context

[13:51] <Juerd> nothingmuch: I agree that 'sub' is probably not the right way

[13:51] <nothingmuch> etc

[13:51] <Juerd> It's the best thing I can think of rigth now.

[13:51] <Juerd> right

[13:51] <nothingmuch> i really want this stuff to not exist in p6

[13:51] <Juerd> We're not discussing P5 either

[13:51] <nothingmuch> so the language will be less 'well, you should have used this magic construct'

[13:52] <Juerd> Without magic constructs, we end up with python, nothingmuch 

[13:52] <Juerd> That's not Perl.

[13:52] <nothingmuch> the power of hebrew, for example, is that you can construct logical parts of the language

[13:52] <nothingmuch> with special cases that are obvious

[13:52] <nothingmuch> and find out how something will look like

[13:52] <nothingmuch> and understand something we haven't met yet

[13:52] <luqui> and "obvious" is the subjective word here

[13:52] <nothingmuch> by means of a thought process

[13:52] <luqui> most everything in perl 6 is obvious to larry

[13:52] <nothingmuch> and not only by looking at a reference doc

[13:52] <Juerd> Maybe we can introduce X and XX

[13:53] <nothingmuch> again, my point is still about arbitrary use of a keyword with a /lot/ of meaning and cargo, to disambiguate a special case

[13:53] <nothingmuch> without some logical binding

[13:53] <Juerd> Where @foo xx 5 is 5 times \@foo, and @foo XX 5 is foo's elements, 5 times

[13:54] <Juerd> and { foo() } xx 5 is 5 times that closure, and @foo XX 5 is 5 different return values of foo()

[13:54] <nothingmuch> perhaps for consistency it could be made *x

[13:54] <nothingmuch> i don't see myself, as a newbie saying "oh, since the sub keyword is used, then it doesn't get executed till after it's repeated"

[13:54] <nothingmuch> Juerd: i like that much better

[13:54] <luqui> I p6l'd the discussion

[13:54] <nothingmuch> * has a strong link to flattenning vs. referencing

[13:54] <Juerd> nothingmuch: I understand the problem you have with the syntax - but please note that I'm more suggesting a feature with some syntax to demonstrate, than I'm actually proposing a syntax change

[13:55] <nothingmuch> Juerd: ok, sorry if i was a bit too nasty

[13:55] <luqui> Juerd: then you might want to reply and elaborate to my p6l message

[13:55] <luqui> if you have any other ideas, that is

[14:00] <rgs> are there q// strings in perl 6 ? besides qq//

[14:00] <luqui> yeah

[14:00] <rgs> not implemented yet, then

[14:01] <luqui> yeah they are

[14:01] <luqui> (I did that... unless they're broken)

[14:01] <leo_> I'm at #parrot now - bye

[14:01] <luqui> I may have only done qq

[14:01] <nothingmuch> leo_: #parrot is not on this network, btw

[14:01] <nothingmuch> so are you on freenode at all?

[14:01] <luqui> yeah, looks like I only did qq

[14:01] <Juerd> leo_: With a good IRC client (I suggest irssi), you can be connected to multiple servers and be in multiple channels at the same time.

[14:01] <leo_> on freenode and pobox - yes

[14:02] <leo_> thanks I'm using irssi

[14:02] <Juerd> Ah, you use irssi

[14:02] <Juerd> Then you can use /connect instead of /server

[14:02] <Juerd> And it'll *add* a connection, rather than replace it.

[14:02] <leo_> yep

[14:02] <Juerd> Every window gets a number, meta+digit switches between the first 10 windows

[14:03] <luqui> (something tells me he knows how to use irssi)

[14:03] <Juerd> (meta being alt or escape on a pc terminal)

[14:03] <Juerd> luqui: That'd be weird though, given that it's his first time on irc :)

[14:03] <scw> qw// is in pugs, too

[14:04] <lumi> Possibly spider sense, or tfm?

[14:04] <luqui> with closure interpolation and all

[14:05] <scw> if you have more than 10 windows, (quite usual, isn't it :p), meta-q meta-w ... is used

[14:06] <luqui> and more than 100 is ^Zrm -rf /

[14:06] <Juerd> luqui: replied

[14:06] <Juerd> The string x is more important in this respect, I think

[14:06] <Juerd> Because join+map communicates the wrong thing

[14:08] <luqui> agreed

[14:08] <luqui> well, now it's in larry's brain

[14:08] <Juerd> heh

[14:08] <luqui> (he's been holding forth, so maybe he'll have some insight about it)

[14:10] <luqui> any('a'..'z')x5, eh?

[14:10] <luqui> well, I think map { $_.pick } any('a'..'z')x5 would work

[14:10] <nothingmuch> damnit, someone is spamming as me

[14:10] <luqui> and now it's communicating the right thing

[14:11] <luqui> s/x/xx/

[14:40] <gaal> i just ci'ed a small patch to util/perl6.vim to support $:x and %.y, luqui and all please see if this makes sense to you.

[14:42] <gaal> beh, $work. bbiab

[14:44] <Juerd> I think I've just gone mad.

[14:44] <Juerd> (See p6l)

[14:45] <Juerd> afk  # typing hurts

[14:46] <autrijus> gaal++

[14:46] * autrijus is still brainracing with leo on #parrot.

[14:46] <Alias_> OH DEAR GOD NO!!!

[14:46] <Alias_> More operator modifiers! :(

[14:47] <Alias_> My brain should not have to hurt in order to add numbers to a list

[14:47] <jabbot> pugs - 1277 - Treat $:x and $:.y as variables

[14:47] <integral> hmm, I see the FiniteMap in Config.hs isn't exposed to perl6 code at the moment,  would it be inappropiate to expose it as %*CONFIG?

[14:47] <autrijus> it needs to be exposed separately as $*FOO

[14:48] <autrijus> I mean $?FOO

[14:48] <autrijus> since it's determined at compile time

[14:48] <autrijus> but please do

[14:48] <integral> ok, I'll have a go at hacking that.   Corion was asking for pugs version info to be accessible from perl6 you see

[14:48] <autrijus> danke

[14:49] * Alias_ sobs

[14:49] <rgs> ultimately, this would be useful to know whether some code runs under pugs or another interpreter

[14:50] <Alias_> On of the things I really like about perl is that I'm so much less likely to get RSI than when writing Java...

[14:50] <Juerd> Alias_: The upside is that you can just combine operators instead of remember many

[14:50] <Alias_> Perl 6 is going to change all that

[14:50] <PerlJam> Alias_: how so?

[14:50] <Juerd> Yes, there are many bitwise operators

[14:50] <Juerd> But it's really just a very simple table of things you can combine

[14:51] <Juerd> Alias_: Haven't you seen how much typing ~- and [-] save you?

[14:51] <Alias_> PerlJam: Because the contortions I'm going to need to go into in order to do anything...

[14:51] <Juerd> Adding features doesn't give you RSI - using them when another solution is better does

[14:51] <Alias_> PerlJam: $#$%#$...%%#$name = 'Alias';

[14:51] <PerlJam> Alias_: I don't see how it will be any different in perl6 as compared with perl5

[14:51] <Juerd> Alias_: That's $ and a comment ;)

[14:52] <Juerd> In fact, it stays meaningful syntax longer in Perl 5 than in Perl 6

[14:52] <rgs> I'm trying to add q/.../ to pugs

[14:52] <Alias_> PerlJam: !@#%@#!%#%!#lastname = $#$%#$...%#$name ~~~~~~~ 1; # <--- magical do what I mean operator

[14:52] <Juerd> Alias_: No, that's called >>dwim<< :)

[14:52] <stevan> Alias_: why is the double sigil so distasteful to you?

[14:52] <Alias_> stevan: Because something shouldn't have to matter...

[14:52] <PerlJam> Alias_: for instance, perl6 cleans up perl's "cognitive space" by being more verbose in some areas, but you can easily alias the verbosity if RSI becomes a problem  ;-)

[14:53] <Juerd> I like secondary sigils, but think they are used too much.

[14:53] <Alias_> It's forcing people to learn things way too early

[14:53] <PerlJam> Alias_: I disagree.

[14:53] <stevan> Juerd: but (at least IMO) they seem to be used very consistently

[14:53] <Juerd> For example, I'd like to just have one object with lots of methods instead of many $*VARIABLES and $?VARIABLES

[14:53] <Juerd> stevan: That is true.

[14:53] <PerlJam> Larry has jumped through hoops to *not* force people to learn too much too quickly.

[14:54] <Juerd> stevan: If $*PID is an alias for %*<PID>, it's fine by me, but I'd like to be able to dump these things all at once.

[14:54] <Juerd> afk

[14:54] <stevan> Alias_: it seems to me that they follow very basic and consistent rules (but I have not read all there is too read on them, so I may be wrong)

[14:54] <Limbic_Region> or use a slice to get just the ones I want (all at once)

[14:54] <Alias_> stevan: But that rule involves learning

[14:54] <Alias_> There are 5 different twigils yes?

[14:54] <stevan> Alias_: whats wrong with learning :)

[14:54] <PerlJam> Alias_: give or take.

[14:55] <Alias_> stevan: Because learning is _hard_, and it's a bad thing to increase the learning curve

[14:55] <Juerd> PerlJam: Heh, both given and take are new keywords :)

[14:55] <stevan> Alias_: perl6 will involve learning no matter what

[14:55] <PerlJam> Juerd: Lots of opportunities to pun in perl6 ;)

[14:55] <Juerd> Alias_: Then why are we even creating Perl 6, and not just using Ruby instead?

[14:55] <stevan> Alias_: it seems to me that the learning curve just has some steep plateaus in it, thats all

[14:55] <Juerd> PerlJam: take my $wife = 'drunk';

[14:56] <stevan> Alias_: I think they will get smoother over time

[14:56] <Alias_> I hope so

[14:56] <stevan> Alias_: its still early

[14:56] <metaperl> lol @ juerd "why are we even creating Perl 6, and not just using Ruby instead?"

[14:56] <Limbic_Region> Alias_ - I am not sure I agree with your original sentiment

[14:56] <Alias_> I'd rather not have for someone to learn about the zillion execution phases in order to just get access to the PID

[14:56] <Limbic_Region> given that I learned p5 less than 3 years ago, it is still fresh in my memory

[14:56] <Juerd> Ruby is Perlishness without learning curve

[14:56] <Juerd> And it is rather boring.

[14:56] <PerlJam> I haven't decided if people who know perl5 will have an easier or harder time with perl6.  I hope it's the former, but there may be too many subtle differences.

[14:57] <stevan> Alias_: thats what Ponie is for :)

[14:57] <Juerd> It does have minus for arrays though :)

[14:57] <Limbic_Region> I was able to accomplish what I wanted to do (which was beginner stuff) with only a few hours of learning

[14:57] <Limbic_Region> I very much expect p6 to be the same way for most

[14:57] <metaperl> Perl6 is going to lose it's human feel.

[14:57] <stevan> PerlJam: I think people who know perl5 AND some other langauges (java, lisp, etc) will find it easier

[14:57] <Juerd> Alias_: Have you ever needed to learn the hooks tied to %ENV, or even that %ENV is a hash, in order to use $ENV{PATH}?

[14:57] <Juerd> You see one thing and copy it

[14:58] <Juerd> And when you have used many similar things, a pattern begins to form in yourmind

[14:58] <Limbic_Region> on the other hand - once you get past the accomplishing 90% of the tasks to the remaining 10% - you could spend a lifetime mastering it ;-)

[14:58] <Juerd> And then you have learned rules you can apply to more things.

[14:58] <Alias_> Juerd: "It's a magical HASH"

[14:58] <Juerd> Alias_: But you don't have to know that in order to use it.

[14:58] <integral> and from there people are copying perl5 like "&func(...)", and they then wonder why "&un('string')" doesn't work

[14:58] <Juerd> Alias_: In the most basic form.

[14:58] <Alias_> Juerd: But now we need to know that it's a compile time variable?

[14:58] <Juerd> A bash scripter who learns Perl first tries $PATH

[14:59] <Juerd> And then asks why that doesn't work. He gets told $ENV{PATH}

[14:59] <PerlJam> why does it suddenly sound like everyone is saying that perl6 will be better for cargo cult programming than perl5?  ;)

[14:59] <Juerd> At that point, he may not already notice that all environment variables are in that hash. After all, bash makes local and environment variables look exactly the same

[14:59] <Juerd> Only after having seen another $ENV{HOME} like variable, the pattern is clearly visible

[14:59] <Juerd> Without reading any manual

[15:00] <metaperl> Larry Wall said: "Perl was designed to grow in between shell and C" --- Perl6 is clearly not in line with that philosophy

[15:00] <Juerd> Alias_: No, and for that I agree secondary sigils are a bad thing.

[15:00] <Alias_> But now it's %*ENV?

[15:00] <luqui> metaperl: Perl 6 is designed to grow in between Perl 5 and infinity (and beyond)

[15:00] <Juerd> * Because it's special. I don't like the ? secondary sigil and think it should all be just *

[15:00] <Alias_> %?ENV?

[15:00] <Juerd> $*PID, $*SUB, $*OS

[15:00] <luqui> Yeah, now it's %*ENV, which can usually be abreviated %ENV

[15:00] <Juerd> &*SUB that is

[15:01] <Juerd> eh

[15:01] <Juerd> &?SUB

[15:01] <luqui> Juerd: the $? stuff is always compile time resolved

[15:01] <Alias_> Wait... so if I leave off the twigil, it will just do what I mean?

[15:01] <rgs> guys, I've an implementation of q/.../ and '...' that works ; should I commit ?

[15:01] <PerlJam> Alias_: yes!

[15:01] <Juerd> luqui: Great, but as alias said: why does the programmer have to care about that?

[15:01] <luqui> Alias_: in *'s case

[15:01] <rgs> and should I remove the old '...' handling code

[15:01] <Alias_> what about in other cases

[15:01] <stevan> rgs: does it past the quoting tests?

[15:01] <luqui> Juerd: dunno, so he doesn't say &?SUB := sub { ... }

[15:01] <rgs> stevan: it solves single_quoted_strings.t

[15:02] <stevan> rgs: thats good

[15:02] <luqui> more like, $? stuff represents the environment the program was compiled in

[15:02] <Juerd> luqui: That can be an error regardless of the secondary sigil.

[15:02] <PerlJam> Alias_: In other cases the twigil means something that you can't get any other way.

[15:02] <luqui> and $* stuff represents the environment the program is running in

[15:02] <Alias_> luqui: Who cares? Why force it in people's faces?

[15:02] <PerlJam> luqui: and $?PID will do what exactly?  ;)

[15:02] <luqui> and that's a difference the programmer can care about

[15:02] <luqui> PerlJam:  $?PID will do "undefined variable"

[15:02] <Alias_> luqui: "can" or "must"

[15:03] <Juerd> Can care about and then look up in documentation

[15:03] <integral> why is $* necessary?  Can't you just replace $?PID with BEGIN { $*PID } ?

[15:03] <integral> s/\*/?/

[15:03] <Juerd> There's no specific reason these things need to be reflected in code

[15:03] <luqui> $?PID doesn't mean anything!

[15:03] <Juerd> They have nothing to do with the code

[15:03] <Juerd> They have nothing to do with the program you're writing

[15:03] <luqui> what about &?SUB?

[15:03] <PerlJam> integral: $?FOO is compile-time, $*FOO is run-time.  You don't see a need to differentiate?

[15:03] <Juerd> Where the PID comes from is utterly irrelevant, as long as you get the PID.

[15:03] <Juerd> PerlJam: Is there any FOO that exists in both then?

[15:04] <integral> PerlJam: not when the former can be obtained by adding a BEGNI{} block

[15:04] <luqui> okay, forget about environment stuff.  we might encapsulate those in objects somehow...

[15:04] <Juerd> luqui: I think the entire .* and .? thing needs to be objects

[15:04] <Alias_> If you _really_ care which it is, and that is a rare case, then you get a special method in a special package

[15:04] <luqui> Juerd: so tell me about &?SUB

[15:04] <Alias_> Scalar::Util::is_compile_time_variable( $*FOO )

[15:05] <schoch> arn't objects sometimes slower?

[15:05] <Juerd> luqui: $PROCESS.PID, %$PROCESS.ENV, &$PROGRAM.SUB

[15:05] <Alias_> or something of that nature

[15:05] <Juerd> luqui: $CONFIG.OS

[15:05] <PerlJam> integral: Hmm.  I think I agree with you.

[15:05] <luqui> schoch: quiet.  we're language designers. :-)

[15:05] <PerlJam> schoch: yeah, and sometimes their *faster* too

[15:05] <integral> PerlJam: it seems a bit more perl5ish to just use an existing feature than to invent something specific

[15:05] <luqui> I definitely agree with $CONFIG.OS, but I think $? is still necessary to reflect the lexical environment

[15:05] <Limbic_Region> schock - p5 objects are almost always slower because of the way they were shoe-horned in

[15:05] <Juerd> luqui: That is, if we really need to note where things come from

[15:05] <integral> &?SUB could be BEGIN { $*compiler.get_current_subroutine }

[15:06] <Juerd> luqui: For all I care, $PID, %ENV, &SUB, $OS are more than good enough.

[15:06] <Limbic_Region> they are taking more of a central role in p6 

[15:06] <schoch> i'm a java user, one of the things I liked about perl is being able to chose an object model when i need one, or not

[15:06] <Juerd> Add a secondary sigil to avoid clashing with your own variables

[15:06] <luqui> integral: ahh yes, and it was introduced to make anonymous recursion easy.  there that goes.

[15:06] <Juerd> $*PID, %*ENV, &*SUB, $*OS

[15:06] <luqui> Juerd: and %MY?

[15:06] <PerlJam> integral: Well, I'd expect some sort of hook to grab the entire compilation environment in one go though.

[15:06] <Juerd> luqui: That's ::MY

[15:06] <Juerd> Isn't it?

[15:06] <luqui> no, it's MY::

[15:06] <Limbic_Region> schock - p6 should mostly still let you do that

[15:06] <Juerd> luqui: That's ::MY:: :)

[15:06] <luqui> but %MY is a namespace hash

[15:06] <integral> PerlJam: (NEGIB { $*compiler}).get_current_subrtouine ;-)

[15:06] <Juerd> luqui: :: is the namespace sigil too

[15:07] <luqui> (maybe it's %MY::)

[15:07] <Juerd> luqui: Then that can be %MY or %*MY

[15:07] <luqui> Juerd: er, symbol table

[15:07] <Juerd> But I really, really don't care where it comes from.

[15:07] <luqui> %*MY doesn't make sense, because it's not global

[15:07] <schoch> i never liked the BEGIN{} either though

[15:07] <luqui> schoch: what would you prefer?

[15:07] <PerlJam> schoch: why not?  I've always thought BEGIN was one of the things perl did right.

[15:07] <Juerd> luqui: Why the heck care? In Perl, scope isn't visible in variable names. Type is.

[15:07] <schoch> not sure but it behaved oddly with some modules

[15:08] <PerlJam> schoch: Though my eyes tend to glaze over when you talk about INIT and CHECK subs  ;)

[15:08] <luqui> Juerd: and scope.  $^ is a scoper.  $* is a scoper (but you're arguing it)

[15:08] <luqui> $. is a scoper

[15:08] <Juerd> luqui: Declaration defines scope, not the sigil. In Ruby, sigils are for scope, in Perl, they're not. This shouldn't be any different for special variables.

[15:08] <PerlJam> schoch: BEGIN has never behaved oddly.  It's always quite predictable 

[15:08] <Juerd> $.foo is just a lexical declaration

[15:08] <luqui> Juerd: then what are secondary sigils for, if not scope?

[15:08] <schoch> not with par

[15:08] <Juerd> It happens to be an alias for the foo attribute of the current invocant

[15:08] <schoch> i don't rememeber the details...

[15:09] <Juerd> But that's not a scoping issue.

[15:09] <Alias_> I like $.foo

[15:09] * schoch goes back to lerkin

[15:09] <Juerd> I like it too.

[15:09] <luqui> Juerd: so what do secondary sigils stand for?

[15:09] <Alias_> It's special in a predictable way

[15:09] <luqui> Juerd: what does even one secondary sigil stand for?

[15:09] <Juerd> luqui: When things are defined, where they come from, and certainly not scope...

[15:10] <luqui> Juerd: example

[15:10] <Juerd> $*PID, * indicating that it comes from the system, as with %*ENV

[15:10] <luqui> to me, the secondary sigils represent those scopes that aren't declared.  

[15:10] <Juerd> $?OS, indicating it came from the compiler

[15:10] <Juerd> &?SUB, etc

[15:10] <luqui> the * sigil means simply "global"

[15:10] <luqui> nothing more

[15:11] <Juerd> Exactly how global is %*ENV when you've made it local, which should be possible in Perl 6?

[15:11] <PerlJam> luqui: well, * is runtime global, and ? is compile-time global n'est pas?

[15:11] <autrijus> temp %*ENV

[15:11] <luqui> Juerd: you know how temporization works better than to ask that, I think

[15:11] <Juerd> Eh, ignore that.

[15:11] <luqui> PerlJam: ? is compile-time lexical

[15:11] <Juerd> luqui: Yes, a stupid question it was.

[15:11] <PerlJam> luqui: er, right.

[15:12] <Juerd> luqui: Why are we indicating scope?

[15:12] <luqui> because we don't want to declare $^a

[15:12] <Juerd> And why can't secondary sigils just mean they're *special*?

[15:12] <luqui> well, they could

[15:12] <Juerd> And have only three

[15:12] <Juerd> * for special

[15:12] <luqui> but so far all the specials indicate types of scope

[15:12] <Juerd> . for aliased to public attribute

[15:12] <Juerd> : for aliased to private attribute

[15:12] <luqui> (sometimes odd ones, like $.)

[15:13] <PerlJam> Juerd: and ^ ?

[15:13] <Juerd> OR be consistent, and remove our/my

[15:13] <Juerd> And use secondary sigils for that.

[15:13] <luqui> Juerd: and state

[15:13] <Juerd> PerlJam: I don't know that one. What does it currently do?

[15:13] <Juerd> luqui: Yes, and state.

[15:13] <luqui> sort { $^a <=> $^b }

[15:13] <Juerd> Oh, right

[15:13] <PerlJam> Juerd: implicit sub parameter

[15:13] <Juerd> That's a lexical thing

[15:13] <luqui> it's implicitly declared

[15:14] <Juerd> They're special in that they're implicitly declared and they're actually parameters too

[15:14] <luqui> Juerd: well, I don't know the deeper reasons...

[15:14] <Juerd> Like with $. and $:, they're aliased to other values.

[15:14] <luqui> I've given a good argument, I think, but you might just have to ask larry for this one :-)

[15:14] <luqui> I know I like it

[15:14] <Juerd> The problem with ., : and ^ is that people think they indicate scope. 

[15:15] <Juerd> They do not - the scope is lexical

[15:15] <Juerd> However, the variables are bound/aliased

[15:15] <luqui> well, . isn't exactly lexical

[15:15] <Juerd> It is too.

[15:15] <Juerd> $.foo is one alias for many variables.

[15:15] <luqui> hmmm... I guess since method Foo::bar () is outlawed

[15:16] <luqui> You could think of it that way

[15:16] <Juerd> But the scope of the variable is defined entirely outside the class

[15:16] <luqui> Or you could think of it as "object scope", which is a weird kind of dynamic scope

[15:16] <Juerd> The scope is determined by construction and destruction

[15:16] <Juerd> Not by anything else

[15:17] <Juerd> Just like how our creates a LEXICAL alias for a GLOBAL variable

[15:17] <jabbot> pugs - 1278 - * Implement q/.../ string literals

[15:17] <Juerd> The scope is determined by that the variable is never destroyed except at the end

[15:17] <luqui> Juerd: ok.  there are a lot of ways to think about abstract programming language concepts. 

[15:17] <Juerd> Not by where the variable is declared.

[15:18] <Juerd> It's really important to separate variables from their names

[15:18] <Juerd> $foo is not a variable, it's just its name

[15:18] <luqui> that depends on how you're defining variable

[15:18] <Juerd> Well, explain to me what $foo := $bar does if $foo is anything other than a name.

[15:18] <rgs> woot.

[15:18] <Juerd> It binds the name $foo to the variable that is also called $bar

[15:18] <Juerd> It's the same variable, though

[15:19] <Juerd> Variables don't exist at syntax level

[15:19] <Juerd> We call these names "variables" in every day English, because that makes discussing things a whole lot easier

[15:19] <luqui> take:  $foo is a container, as is $bar, for a thing that holds values.  := takes the thing that holds values in $bar and puts it in $foo.

[15:20] <Juerd> No, container == variable

[15:20] <Juerd> Two containers cannot both contain the same value

[15:20] <Juerd> (Note: same isn't the same as equal)

[15:20] <luqui> Juerd: not always.  you're getting into semantics here.

[15:20] <Juerd> Think of real life containers

[15:20] <PerlJam> Juerd: sure they can! Superpositional containers :-)

[15:20] <Juerd> You cannot put the same apple in both

[15:20] <luqui> And I think you're beginning to define variable differently from what we think when we say "varaible"

[15:20] <luqui> and perl is designed to coincide with how we think

[15:20] <Juerd> luqui: When we say variable, we usually mean mutable container.

[15:21] <schoch> how do references work in this context?

[15:21] <Juerd> schoch: A reference is a VALUE (that lives in a single container, that in turn can have any number of names) that refers to any single container

[15:21] <Juerd> Possibly its own container.

[15:21] <Juerd> (Circular-reference-in-one)

[15:22] <Juerd> Names, containers and values are the three things a programmer/programming language deals with

[15:22] <luqui> Juerd: think about what my proposals do.  They take the existing language, rip out its guts and replace them with new ways to think about it without changing the syntax or semantics (or if so, in a very slight way).

[15:22] <Juerd> Names exist at syntax level

[15:22] <luqui> There's more than one way to think about thing.

[15:22] <luqui> s

[15:22] <Juerd> They're how we, programmers, address variables

[15:22] <Juerd> Containers are locations in memory. It's how the computer accesses the values

[15:22] <luqui> and language design is about finding the right way to think about things

[15:23] <luqui> and containers are certainly more than locations in memory for a high level language

[15:23] <Juerd> And the values are the actual values, and cannot be addressed by anything other than their container. A single scalar container has one value (disregarding dualvars), array or hash containers have many values, they being other containers)

[15:23] <luqui> In other words, you're cramming a way of thinking down our throats (not to say that that's bad, there's a famous saying about that :-)

[15:24] <luqui> When we're not even sure whether the way we're thinking is right.

[15:24] <Juerd> Given how references and objects work in Perl, this is a good way of thinking

[15:24] <luqui> And Larry is _incredibly_ good at thinking about _everything_ in many different ways.

[15:24] <Juerd> This model can't easily be used with, for example, Python

[15:24] <Juerd> Where "same" and "equal" are the same thing.

[15:24] <luqui> So, try and think how larry is thinking when he introduced $? before saying that it's the wrong way.

[15:24] <Juerd> And values are immutable.

[15:25] <Juerd> luqui: I haven't said it's wrong.

[15:25] <luqui> okay, s/saying that it's the wrong way/when disputing it/

[15:25] <Juerd> luqui: I think it's unnecessary to add another sigil

[15:25] <luqui> so it's an aesthetic issue?

[15:25] <Juerd> Certainly.

[15:25] <luqui> because you could have said that up front :-)

[15:25] <luqui> and then the discussion is much less deep and much easier to, er, think about

[15:26] <Juerd> You don't have to be able to see what kind of variable a variable is

[15:26] <Juerd> And if we're convinced that it is important, then we should ditch declarators like my and our, and replace that with sigils too.

[15:26] <Juerd> I don't understand, for example, why has is spelled has, if there's ALSO a secondary sigil

[15:26] <luqui> and then what does the null sigil stand for?

[15:27] <Juerd> luqui: Null sigil stands for subroutine call or namespace :)

[15:27] <luqui> Juerd: because larry "got tired of reading C++ code and wondering whether something was a member or a global"

[15:27] <jabbot> pugs - 1279 - Remove dead code corresponding to the ol

[15:27] <luqui> Juerd: sry, null secondary sigil

[15:27] <luqui> null twigil

[15:27] <Juerd> luqui: I know people who got tired of reading Perl code and wondering whether something was lexical or global. They have found a solution in Ruby.

[15:27] <autrijus> trigil! quaril!

[15:28] <Juerd> luqui: User defined non-special variables (that is: names for them), I hope

[15:28] <Juerd> Possibly user defin-able.

[15:28] <luqui> like lexicals?

[15:28] <Juerd> Scope is irrelevant.

[15:28] <luqui> so then what does my do?

[15:28] <Juerd> my initializes a container and declares a name for it.

[15:28] <luqui> it defines one of these user defined non-special variables

[15:28] <luqui> how about that

[15:28] <Juerd> The name is lexical

[15:29] <Juerd> The container is destroyed when there are no more names (references) left

[15:29] <Juerd> (Either at block end or a more convenient moment)

[15:29] <Juerd> But the container CAN live on long after the name is no longer attached to it

[15:29] <luqui> so um, what does the null twigil, in the new system where we've ditched my and our, mean?

[15:30] <Juerd> I wouldn't want to think of that system, because I like my and our, and not having twigils/sigils for scope.

[15:30] <luqui> i'm trying to get you to think about something

[15:30] <Juerd> But it could indeed mean the variable is lexical. That's huffmanly correct, and the way Ruby does it.

[15:30] <luqui> and it does

[15:30] <luqui> currently, even

[15:31] <Juerd> Huh?

[15:31] <luqui> which lexical scope it is attached to is defined by "my" or "our", though

[15:31] <Juerd> No, a user defined (twigilless) name is global unless declared otherwise

[15:31] <Juerd> no strict;

[15:31] <Juerd> $foo = 1;  # not lexical!

[15:31] <autrijus> use autolexical;

[15:31] <autrijus> $foo = 1; # lexical!

[15:31] * autrijus grins

[15:31] <Juerd> Yes, but that isn't default behaviour

[15:31] <luqui> Juerd: I'll say treat that as a special case

[15:31] <autrijus> Juerd: yours isn't the default.

[15:31] <autrijus> the default it neither.

[15:32] <luqui> the default is "$foo not declared"

[15:32] <autrijus> yup

[15:32] <Juerd> luqui: The scope of every explicitly declared name is lexical.

[15:32] <PerlJam> autrijus: not in my one-liner it's not.

[15:32] <Juerd> our, has, my

[15:32] <Juerd> The declaration, and thus the name, is lexical

[15:32] <luqui> PerlJam: yeah, that's the "no strict" or "use autoglobal" case

[15:32] <autrijus> PerlJam: maybe oneliners uses autolexical :D

[15:32] <autrijus> j/k.

[15:32] <Juerd> The variable itself (the *container*), is global, object-dynamic, or lexical

[15:33] <Juerd> autrijus: It depends on whether you see strict as the default, or no strict as something you can load.

[15:33] <luqui> Juerd: exactly

[15:33] <luqui> and both ways of thinking define, conflicting, ways to think about what a twigil means

[15:34] <Juerd> Yes, but now both ways of thinking are in Perl at the same time

[15:34] <luqui> yep

[15:34] <luqui> which is what perl is best at

[15:34] <Juerd> We use twigils to indicate scope, but only for special variables, because for normal user-definable variables, we use declarative keywords.

[15:34] <Juerd> That's inconsistent in a way that IMO gains nothing 

[15:35] <Juerd> It's not as if the distinction between $* and $? makes it any EASIER to use

[15:35] <PerlJam> btw, perl6 was starting to solidify ever so slightly in my head ... until I started paying attention to you guys  ;)

[15:35] <luqui> other than the fact that we've defined a meaning for the null twigil

[15:35] <Juerd> To the contrary: you have to know more.

[15:35] <luqui> PerlJam: solution, don't listen.  We're rambling theorists :-)

[15:36] <PerlJam> luqui: sure, but I had a belief of what was "right" and you've both shaken my belief

[15:36] <luqui> Juerd: $* is global.  you can't say $*SUB because that's not global.

[15:36] <rgs> autrijus: my three last commits are heavily cargo-culted. beware.

[15:36] <Juerd> luqui: I'd love to ramble some more, but I can't because my hands hurt beyond what pain killers can fix

[15:36] <Juerd> So I will have to stop now.

[15:36] <Juerd> Sorry.

[15:36] <luqui> do you have carpel tunnel or something?

[15:36] <Juerd> Not exactly that, but similar

[15:36] <autrijus> luqui: yes. (to save Juerd's typing)

[15:36] <luqui> hehe

[15:37] <luqui> any suggestions about how to avoid that? (I use my hands for everything)

[15:37] <luqui> supposing you can type it

[15:37] <Juerd> luqui: www.kinesis-ergo.com

[15:37] <luqui> (don't let me impose)

[15:37] <jabbot> pugs - 1280 - Factorize code between qLiteral and qqLi

[15:37] <nothingmuch> Juerd: get Jouke to make a vocal IRC for you, or something ;-)

[15:37] <Juerd> luqui: www.dvorak.nl

[15:37] <luqui> okay

[15:37] <Juerd> luqui: www.wacom.com

[15:37] <Juerd> luqui: Combine these three and you'll postpone it a long time

[15:37] <Juerd> afk

[15:37] <nothingmuch> these guys are pretty cheap: http://store.ergocube.com/

[15:38] <nothingmuch> because they are pretty much nonprofit

[15:38] <luqui> cheap enough not to have a website

[15:38] <luqui> n/m typo

[15:38] <autrijus> journaling, bbiab 

[15:38] <Juerd> nothingmuch: They sell a lot that has nothing to do with ergonomics, or makes things worse. They also have the good stuff.

[15:38] <Juerd> afk

[15:38] <autrijus> rgs: if it passes tests, cargo code is just fine :)

[15:39] <nothingmuch> luqui: also excercise a lot while you can

[15:39] <autrijus> rgs: and it looks ok.

[15:39] <luqui> nothingmuch: uh oh

[15:39] <nothingmuch> Juerd: i have not yet bought any ergo stuff

[15:39] <rgs> ok, then. bbl &

[15:39] <nothingmuch> luqui: stringed instruments have kept my writsts in excellent condition

[15:39] <nothingmuch> running in highschool ruined my knees

[15:39] * luqui plays piano and violin

[15:40] <nothingmuch> guitars & double bass

[15:40] <Juerd> luqui: Ouch!

[15:40] <luqui> where "plays" is defined loosely for violin :-)

[15:40] <PerlJam> luqui: ouch. you've tripled your chances for RSI at least

[15:40] <Juerd> luqui: 1. violin 2. computer 3. piano - top three rsi causes!

[15:40] <Juerd> afk

[15:40] <nothingmuch> but they must be played properly, ofcourse =)

[15:40] <Juerd> (for real)

[15:40] <luqui> I know.  that's why I'm asking for suggestions.

[15:40] <nothingmuch> piano - i don't know about

[15:40] <PerlJam> luqui: rest your hands.

[15:41] <nothingmuch> violin - i've heard that it is stressful to hold it like that 

[15:41] <luqui> it is... which is one of the reasons I don't practice much

[15:41] <luqui> it hurts to do it for very long

[15:41] <nothingmuch> on the bass everything is very round, and you are never supposed to do anything stressful. If there is discomfort, then it will sound horrible, and also hurt you

[15:41] <nothingmuch> and if it won't sound horrible, it will limit your progress

[15:42] <nothingmuch> the thumbing position for example, is very dangerous in this respect

[15:42] <PerlJam> luqui: For the computer and piano you can use alternate forms of input (chorded keyboards with big fat keys, foot pedals, etc).  You're pretty much stuck with the violin  though.

[15:42] <nothingmuch> i've been having lots of trouble with it

[15:42] <luqui> I imagine the same for violin....  at first piano was stressful, but now I think it relaxes my hands

[15:42] <nothingmuch> but my teacher never ever ever lets me go the cheap way

[15:43] <nothingmuch> i could just press harder, but that would ruin my thumb in no time, especially with my mother's genes controlling my joints

[15:43] <PerlJam> luqui: you could always redesign the violin.  Make an instrument with the same tonal qualities but less hand pain  :)

[15:43] <luqui> PerlJam: I'd love that :-)

[15:43] <luqui> play it "topwise"

[15:44] <Juerd> re

[15:44] <nothingmuch> PerlJam: that's what they've been doing for a long while, y'know ;-)

[15:44] <nothingmuch> was it paganini who ruined everything by making people stick it in their neck?

[15:44] <luqui> when was paganini?

[15:44] <Juerd> luqui: For any keyboard, make sure its keys are just heavy enough for your hands, and no key feels much different than the others. Make sure the feedback is good, both in feeling and hearing

[15:44] <PerlJam> nothingmuch: "they" perhaps aren't as smart or creative as luqui (or other perl people for that matter ;)

[15:44] <nothingmuch> i'm not sure, really

[15:45] <luqui> 1782-1840

[15:45] <Juerd> luqui: Church organists get rsi more quickly because of the delay there is between hitting the key and hearing the sound.

[15:45] <luqui> I know beethoven stuck it in his neck

[15:45] <Juerd> That's really bad feedback.

[15:45] <luqui> huh, why does feedback make a difference?

[15:45] <nothingmuch> i wonder if oboe players have rsi in their mouth ;-)

[15:46] <luqui> lol

[15:46] <metaperl> lol

[15:46] <nothingmuch> luqui: you automatically do more than you need

[15:46] * luqui used to play oboe...  yes.

[15:46] <Juerd> The better the feedback is, the more you know (subconsciously) what the right pressure is, so you don't use more force than necessary

[15:46] <PerlJam> The only time I ever played violin it felt completly natural ... Except that I can't play, so it probably sounded completely horrible too :)

[15:46] * rgs plays piano, trumpet and trombone

[15:46] <Juerd> luqui: Avoid cherry keyboards (silent and "soft touch" feeling) at all cost.

[15:46] <PerlJam> Juerd: those people need more faith!

[15:46] <luqui> oboe is stressful on the mouth.

[15:46] * nothingmuch wants to learn trumpet

[15:46] <luqui> Juerd: yay, I hate those things!

[15:46] <metaperl> I want to learn guitar/sitar

[15:46] <nothingmuch> luqui: what about the delay? how big is it? to me it's  legend more than anything

[15:47] <nothingmuch> metaperl: guitars are probably the most accessible instrument after piano

[15:47] <Juerd> luqui: For this reason, I don't think touchstream keyboards are any good. I'd have to try one first to be sure, though.

[15:47] <PerlJam> metaperl: me too, but my fingers are too fat.  (also why the violin sounded horrible I'm sure)

[15:47] <nothingmuch> technically and otherwise

[15:47] <nothingmuch> price, popularity, etc

[15:47] <luqui> and even moreso than piano if you consider price

[15:47] <nothingmuch> PerlJam: most people fingers aren't too fat for the guitar

[15:47] <luqui> nothingmuch: delay.. for oboe?

[15:48] <nothingmuch> that's what my dad told me

[15:48] <nothingmuch> oops, ride is leaving

[15:48] <luqui> hadn't played any instruments before, so I didn't really have anything to compare it to

[15:48] <luqui> and didn't get good enough

[15:48] <PerlJam> nothingmuch: well, I think I'd need a wider neck on the guitar but then my fingers wouldn't be long enough

[15:48] <metaperl> PerlJam, never underestimate yourself

[15:48] <Juerd> I want 6 fingers on each hand.

[15:48] <metaperl> Django Reinhardt kept playing after only having 2 fingers

[15:49] <luqui> playing Liszt will stretch your hands as much as you need :-)

[15:49] <Juerd> Or a shorter alphabet.

[15:49] <luqui> so I imagine your fingers could grow to a bigger guitar

[15:49] <luqui> Juerd: just six?

[15:50] <Juerd> Yes - with more than six, the keyboard would really require redesign

[15:50] <luqui> I want eight, because then I could count in hexadecimal

[15:50] <Juerd> And we all know how long it takes for people to create a sane keyboard.

[15:50] <luqui> haha

[15:50] <Juerd> Why count in hex if you can already count to 31 on a single hand, in binary?

[15:50] <Juerd> 31 is almost twice as much as 16 :)

[15:51] <luqui> you could count to 256 then

[15:51] <Juerd> Yep.

[15:51] <luqui> (255)

[15:51] <Juerd> +(@foo = 0..255)

[15:51] <Juerd> [0..255].elems

[15:51] * luqui is possibly one of the fast finger-binary counters ever... it just takes him a while to read back what he's counted to

[15:51] <Juerd> Probably +[0..255]

[15:52] <metaperl> playing piano was great for my career in the video game Joust

[15:52] <luqui> Joust?

[15:52] <rgs> trumpet trains you to binary-count with 3 fingers.

[15:52] <metaperl> you needed fast fingers to get the bird to flutter up

[15:52] <Juerd> We used binary in school to communicate test answers

[15:52] <metaperl> yes, a video game from the 80s

[15:52] <Juerd> 31 > 26, so enough for the alphabet

[15:52] <Juerd> And after 3 letters you have enough to fill in the rest

[15:53] <Juerd> And it really draws NO attention if you keep your fingers horizontal

[15:54] <luqui> except for when you stop at 4 ;-)

[15:54] <Juerd> Yes, the D can be troublesome.

[15:54] <luqui> eh, I never liked 4 anyway.  It was the first of the dreaded composites.

[15:54] <Juerd> We had an IRC channel we used with several people from my class

[15:55] <Juerd> On it, "132" meant a certain two fingers :)

[15:55] <Juerd> So we used 4 and 132, in decimal (shorter)

[15:56] <Juerd> Even the non-nerds copied that.

[15:57] <Juerd> Hm, alias didn't like it... :|

[15:57] <jabbot> pugs - 1281 - more Pod::Stream::Parser; improvement of

[16:00] <luqui> Off to school.  bye

[16:00] * luqui &

[16:30] <obra>      a

[16:31] <Juerd> I hate my brain

[16:31] <Juerd> My brain has decided that bitwise ops should be ?+ for OR, ?- for XOR and ?* for AND

[16:32] <Juerd> And that stringy and numeric should thus be ~?+, ~?-, ~?*

[16:32] <Juerd> And +?+, +?-, +?*

[16:32] <Juerd> It's a good thing I'm not inventing this language

[16:45] * mugwump *hic*

[16:47] <jabbot> pugs - 1283 - Move PhD logo to advocacy directory

[16:47] <jabbot> pugs - 1282 - First part - the DOM tree structure

[16:49] <Juerd> http://tnx.nl/3689VBOF  # mad consistency.

[16:55] <gaal> integral, still aroung?

[16:55] <integral> gaal: yep

[16:56] <gaal> i was afk and backlogging now i noticed oyu wanted to workon %CONFIG

[16:56] <gaal> didn't finish reading up yet, but before you do anything,

[16:56] <gaal> there's a thread where larry explains his plans for it

[16:56] <gaal> doesn't look decided

[16:57] <gaal> ~6 March on p6l i think

[16:57] <gaal> or search these logs for config

[16:57] <integral> oh, ok.   I asked autrijus and he just said go ahead.   I'm just exposing the FM in Config.hs as a hash

[16:57] <gaal> just wanted to warn you so you don't work a lot for nothing - sorry if someone already

[16:57] <gaal> ESCdd

[16:57] <gaal> okay :)

[16:58] <gaal> but be aware that this is specifically likely to change...

[16:58] <gaal> i had these same toughts myself.

[16:58] <integral> oh, I've no problem with my code being ripped out :-)   It's to access some pugs specific conf data though, so it's a hack anyway

[16:58] <elmex> hi

[16:59] <gaal> my %conf = map { split /:/, $_, 2 } `pugs -V`; # j/k :)

[17:13] <Juerd> chomp.

[17:13] <gaal> true, but i was being silly.

[17:13] <Juerd> Then so am I :)

[17:13] <gaal> also, the current separator is ": "

[17:14] <gaal> and there's a leading \t

[17:14] <gaal> and there's a header line

[17:15] <gaal> and there are some @INC entries too

[17:15] * Juerd is going to try to take a long break

[17:15] <Juerd> As you can see on p6l, I'm having too many thoughts right now :)

[17:15] <gaal> yeah, and outsilliying contests are tiring :)

[17:15] <Juerd> hehe

[17:15] <Juerd> Now you're just being silly

[17:15] <Juerd> :)

[17:16] * gaal bows

[17:16] <Juerd> I'm quitting - you win :P

[17:16] <Juerd> (this time)

[17:17] <gaal> what are "foes" on use.perl.org?

[17:18] <lumi> Like in /. I think, the opposite of friends

[17:18] <lumi> And freaks are the opposite of fans

[17:18] <gaal> i don't do /.

[17:18] <gaal> i have a feeling that outsillies me

[17:19] <gaal> so like if friends are those who read you regularly, foes are people who regularly don't read you?

[17:19] <crysflame> freaks are people who are friends of your foes, i think

[17:19] <lumi> No, friends are people whose opinion you value

[17:20] <lumi> And foes are the opposite

[17:20] <lumi> Freaks are people whose foe you are

[17:20] <crysflame> aha

[17:20] <lumi> (That parses, honest!)

[17:20] <crysflame> freak, foe, fan, fum

[17:20] <gaal> and that information needs site suppose because...?

[17:20] <lumi> Because you could give the people you value a bonus, so you'll see their writeups more

[17:21] <lumi> And people who value your opinion could give the people whose opinion YOU value a bonus

[17:21] <lumi> That's the theory, I think

[17:21] <lumi> e2 makes more sense though

[17:21] <lumi> Or not

[17:22] <gaal> i like my feeds a little more deterministic than that :)

[17:22] <lumi> It's for comments, not for main entries, as a rule

[17:22] <gaal> anyway, i didn't mean to go off topic for so long, lets take this off-channel

[17:40] <elmex> hi

[17:40] <gaal> ho

[17:47] <elmex> hmpf

[17:47] <elmex> how fast is pugs at the moment?

[17:48] <cm> schnell genug!

[17:48] <elmex> lol

[17:49] <elmex> cm: _how_ fast

[17:49] <cm> schnell wie der wind, wie der wihihind..

[17:49] <cm> elmex: 370

[17:49] <elmex> in comparsion to eg. perl5

[17:49] <cm> i've no idea, i'll stop trolling :p

[17:49] <elmex> cm: cuteee ;)

[17:50] <cm> =(

[17:52] <PerlJam> elmex: It is about as fast

[17:52] <PerlJam> (as perl5)

[17:53] <elmex> PerlJam: with pugs compilin to parrot? or interpretion?

[17:53] <PerlJam> both.  Slightly faster when compiled to parrot, slightly (a little more so though) interpretted

[17:54] <PerlJam> But all in all, they are about the same speed

[17:55] <elmex> hmm, wonder how fast it may be with a nicely  jit'ed parrot

[17:56] <cm> if it chips like a parrot, it surely is a parrot ;o

[17:57] <elmex> ?

[17:57] <elmex> cm: cuteee ;) are you female?

[17:58] <cm> o_0

[17:58] <xerox> 

[17:58] <xerox> Whoops, sorry.

[17:59] <elmex> cm: c'mon

[18:01] <cm> elmex: hm?

[18:02] <xerox> elmax /whois cm

[18:04] <elmex> xerox: no sign for male gender

[18:08] <xerox> elmex: 1) who cares 2) the name isn't enough?

[18:12] <elmex> xerox: ;)

[18:15] <kungfuftr> lo all

[18:19] <Corion> BTW - NickServ pesters me - should I really register my nick ?

[18:19] <elmex> if you want to, yes ;)

[18:21] <Steve_p> http://freenode.net/faq.shtml#nicksetup

[18:25] <stevan> autrijus: are you still awake?

[18:27] <kungfuftr> shit... another tsunami

[18:31] <Jouke> yes? sure? Last I heard on the news was that there might be a new tsunami, but that it wasn't sure yet

[18:31] <integral> see ##quake

[18:32] <kungfuftr> news.bbc.co.uk has a live video feed

[18:35] * Jouke reads about 'tsunami warnings' on CNN and bbc.co.uk, but not an official tsunami report yet

[18:37] <jabbot> pugs - 1284 - Shifting argument to subroutine fails

[18:42] <gaal> Corion, you there?

[18:42] <Limbic_Region> Corion is jaw jacking at PerlMonks about his bike - you want me to get his attention?

[18:43] <Corion> I'm also here :)

[18:43] <gaal> hey :) just a note about the parsefails since i read logs from last night :

[18:43] <Corion> (and I get an annoying beep whenever somebody mentions my name here :) I should switch that off)

[18:43] <Limbic_Region> how's that for timing ;-)

[18:43] <gaal> nm and i are at no disagreement.

[18:44] <gaal> if you get away with todo_is_eval on a test that doesn't parse, great.

[18:44] <Corion> gaal: Ah! I think I got away with that, yes :)

[18:44] <gaal> if the parsefail is "hard", though, it's b0rk eval, even, and that's what you need the comment + warning note in the form of a failing test for.

[18:45] <Corion> Win2k:r1284 (118/3242)

[18:45] <gaal> but since this is a kludge, we agree on a convention for marking these things.

[18:45] <Corion> ... so we now have scripts that fail their tests again :)

[18:45] <gaal> fails are ok

[18:45] <Corion> gaal: Aaah. OK - I hope I stay away from the eval-borking tests :)

[18:45] <gaal> no, evalb0rktitude is fun :)

[18:45] <Corion> gaal: But somebody converted lots of fails to todo_ stuff lately :)

[18:46] <gaal> i, however, have a chance to go home now, and therefore shall now take my leave of you, kind sirs.

[18:46] <Corion> Oooo - somebody must have fixed the warning that my code created yesterday - I'll have to look at how, so I learn :)

[18:46] * Corion is already home :)

[18:46] * gaal & svn blame is your friend

[18:48] <kcwu> i fixed it, but i don't know why it fixed ;)

[18:49] <Corion> kcwu: Heh :-)

[18:49] <Corion> kcwu: Ah - but that's exactly the fix I imagined - you have to tell Haskell somewhere what types you expect it to use for the numbers

[18:49] <Corion> kcwu: And you introduced Int as the type to use, so Haskell is happy now :)

[18:50] <Corion> ... now, BEGIN {...} blocks need to be made to work, I guess :)

[18:53] <kcwu> why tell haskell that? i image haskell will deduce that it is number, and use (compare) them without problems

[18:53] <Corion> Does anyone know off-hand how Perl5 handles C<-l> ? Is it translated into Perl code, like C<-e> ? Especially if you use "perl -l script.pl" ...

[18:53] <Corion> (if nobody knows, I'll go source diving :) )

[18:54] <kcwu> Corion: i am sure is it you want: perl -MO=Deparse -le 'print 1'

[18:55] <chip> Anybody remember whether Perl 6 /foo/ is more like Perl5's /foo/ or qr/foo/?

[18:55] <autrijus> chip: yes.

[18:55] <Corion> kcwu: Yeah - I know what Deparse outputs, but I don't know if that is some special fudging of B::Deparse or if Perl really created that code :-)

[18:55] <autrijus> (go not to autrijus for counsel...)

[18:55] <chip> I can't remember whether e.g.  C<$a of Str where { /^a/ }> is good Perl6 or not

[18:55] <autrijus> chip: in value context it does the match.

[18:56] <autrijus> otherwise it is rx//.

[18:56] <kungfuftr> hhhmmm... is there a simple way in perl6 of declaring many constants at once?

[18:56] <chip> "value context"?  That's not a context I know

[18:56] <autrijus> chip: i.e. not in direct RHS of a binding or assignment.

[18:56] <Corion> kcwu: But my plan is (currently) to translate C<-l> to C<-e "BEGIN{...}"> - but then I get to the problem of having both, a file AND a -e fragment. I could move the whole file-loading into Perl, of course :-))

[18:57] <autrijus> chip: it's specced in the synopsis, although I question its sanity a bit.

[18:57] <chip> I guess my cunning plan to avoid scanning the [AES] docs has been thwarted

[18:58] <Corion> svn blame is really cool btw ! I should add something similar to my Javascript SubEthaEdit clone :-)

[18:58] <autrijus> Corion: wait, your *what*!?

[18:59] <autrijus> Corion: url! url!

[18:59] <Corion> autrijus: http://zaphod.datenzoo.de - very early beta

[18:59] <Corion> FireFox / Mozilla preferred, but it works in IE6 as well. Opera is dodgy

[19:00] <autrijus> holy zaphod.

[19:00] <autrijus> I can now sleep with the belief that there is hope in this world. :)

[19:00] * autrijus waves &

[19:00] <Corion> autrijus: VERY early beta

[19:00] * Corion gave autrijus JS nightmares

[19:04] * Corion watches the children at play

[19:05] <Corion> (but some times, the children just time out :) )

[19:06] *** kungfuftr changes topic to: pugscode.org <<Overview Journal>> | pugs.kwiki.org | logged: http://xrl.us/e98m | FBSD_4.11:r1284(118/3242) win2k:r1284(118/3242) Linux:r1197(105/3116) MacOSX:r1197(105/3116)

[19:07] * Corion realizes just now that anybody can change the channel topic...

[19:08] <Corion> so I don't have to report my Win2k test results but can update the topic myself! D'oh !

[19:08] <kungfuftr> yup

[19:26] <kungfuftr> there's some sort of DBI lite module somewhere, right?

[19:27] <Corion> kungfuftr: Is there? There is DBD::SQLite, but I don't know of any Perl6 thing dbi-ish

[19:28] <kungfuftr> Corion: nah, i meant a lightweight version of DBI

[19:28] * kungfuftr has been looking at porting DBI::PurePerl, but it's a git

[19:28] <Corion> kungfuftr: Not that I'm aware of - DBI is the only DB interface that Perl has (although I use `isql` :) )

[19:29] <Corion> kungfuftr: I was pondering to learn Haskell to implement some smallish SQL machine in it (it would rock to have a built-in SQL DB for Perl6 :) )

[19:29] <Corion> kungfuftr: But you could look at porting SQLite, together with DBI :-)

[19:30] <kungfuftr> SQLite might be possible, but DBI is very very complex and uses a lot of perl5 specific things

[19:31] <Corion> kungfuftr: Ah - I would rather consider a reimplementation of the API, or at least connect, prepare, execute and fetch :-)

[19:32] <kungfuftr> DBI::PurePerl, is really DBI in disguise... it is used via an environment variable

[19:32] <Corion> kungfuftr: But I haven't looked at anything of the internals. Writing an SQL DB in Haskell should be "pretty easy", as Haskell can do parsers and lazy lists. It wouldn't be very efficient/performant, but bad performance is purely a hardware problem

[19:32] <kungfuftr> ie: $ENV{PUREPERL} = 2; use DBI; # will use DBI::PurePerl instead of the XS based dbi

[19:34] <kungfuftr> i reckon porting of some more core modules like Symbol.pm etc would be required

[19:38] <gaal> corion, you still at -l?

[19:38] <Corion> gaal: No - currently I'm hacking on a test to verify (multiple) -I switches (uppercase i, not lowercase L)

[19:38] <gaal> perl.c:2756, more or less. :)

[19:38] <Corion> gaal: But I plan moving back to -l tomorrow :) Oh - thanks for searching the stuff ! :)

[19:39] <gaal> search? what search? :p

[19:39] <Corion> gaal++ # knows perl.c by rote

[19:40] <Corion> Anyone got a good idea how to print out @INC (newline or \0 separated) without mentioning $_ ? pugs -e "print for @INC" doesn't compile for me

[19:40] <Corion> (also, other shell metacharacters should be avoided, of course :) )

[19:40] <gaal> by heart, you mean -- and actually no, it just happened to be open in some screen window in the past few days :)

[19:40] <gaal> @INC.perl.say

[19:40] <Corion> gaal: Yes - I meant "By Heart" :)

[19:41] <Corion> gaal: Ooooo ! Cool (except that I now have to parse that a bit more, but that's OK :) )

[19:42] <gaal> ./pugs -e 'map {say $_}, @INC'

[19:42] <Corion> gaal: That mentions $_

[19:42] <gaal> ah

[19:42] <gaal> so it does :)

[19:42] <gaal> ./pugs -e 'map -> $x {say $x}, @INC'

[19:42] <Corion> gaal: I want to stay as platform agnostic as possible, that means that the code should run in double quotes (Win32) and should not mention $_ (UNIX shells)

[19:43] <gaal> see latest

[19:43] <Corion> gaal: It uses $x - which is as bad as $_ :-) No $ sign in shell oneliners

[19:43] <gaal> aha!

[19:43] <Corion> gaal: I'll go with the @INC.perl.say - documenting/introducing Perl6ish oneliners is also important!

[19:45] <kungfuftr> hhhmmm... any idea about how we'll be doing tie() sort of stuff in perl6?

[19:46] <Corion> kungfuftr: Not at all, I hope ! :-)

[19:46] <Khisanth> isn't that what the my $foo is Bar; type of stuff is for?

[19:46] <kungfuftr> yup, i would assume so, since hashes are just objects are anyways

[19:47] <gaal> see e.g. <L09/"PDL support">

[19:47] <gaal> L<S09> that is

[19:47] <kungfuftr> Khisanth: yeah `my %hash is ixHash;` is what i'd reckon

[19:47] <gaal> interesting short circuit, that.

[19:48] <Corion> Grrr - the PCRE implementation seems to match dodgy ( or ~~ is broken ... ) - do we have C<like> implemented in Test.pm ?

[19:48] * kungfuftr has a read through the synopses again

[19:48] <Khisanth> hmm is there an 'of' in perl6? :)

[19:49] <Corion> Because "ok $got ~~ $expected" doesn't DWIM, even though $expected = rx:perl5/^('foo/; :-((

[19:49] <Corion> (it's always true)

[19:50] <gaal> Corion, we don't have like yet.

[19:50] <Corion> gaal: Ah - most likely, ~~ not DWIMming is the reason :-) So I'll go with substr() instead :)

[19:50] <Corion> (except that now, the newline stuff becomes uglier...)

[19:51] <gaal> then embed perl5 code. }:)

[19:52] <Corion> gaal: :-)

[19:52] <lumi> What I wouldn't give for Perl 6 rules, today

[19:52] <lumi> In the next 10 minutes, in fact

[19:53] <stevan> Corion: regexp support is spotty

[19:53] <stevan> best not to do like() yet

[19:53] <Corion> stevan: Looks like it :)

[19:54] <Corion> Anybody got a better idea than substr() to check if the first/last two lines in a scalar match what I expect?

[19:54] <stevan> most of what works, autrijus put in because I begged him for it :)

[19:55] <gaal> Corion, are you compiling a set of known p6 one-liners?

[19:55] <gaal> that would be a good node for perlmonks :)

[19:56] <gaal> grep around for eyespoplikeamosquito's first ever p6 japh, which i don't understand

[19:56] <Corion> gaal: Nope - I'm just writing a test script that checks that -I works properly. But your @INC.perl.say would be a good "verification oneliner" (that is, it should go into the docs IMO) - it has no shell metacharacters.

[19:57] <gaal> in that case, ./pugs -I /idontexist -V | grep idontexist should work too

[19:57] <gaal> (does in p5)

[19:57] <ninereasons> it's going to eventually be "print for @INC"; but that won't work right now, right?

[19:57] <gaal> ah, also works in pugs! :)

[19:58] <gaal> yes

[19:58] <Corion> ninereasons: Yes. And also, it will require the user to put the stuff in quotes, which is error prone. That's what I like with @INC.perl.say - one shell-word

[19:58] <Corion> gaal: I don't like grepping - that's error prone. I'm especially interested in the _order_ the stuff goes into @INC

[19:59] <rgs> what is @*INC.perl ?

[19:59] <gaal> Schwern was here a few days back saying that @ can be a metacharacter in some makes, ifyou care about that

[19:59] <elmex> f

[19:59] <Corion> But I think I know how to fudge it - I simply "initialize" my reference scalar from a single unadorned call to pugs.

[19:59] <gaal> rgs: think "Data::Dumper::Dump"

[19:59] <elmex> ?

[19:59] <Corion> gaal: Yes, but I don't care currently. This oneliner would be for shell verification and my test file :-)

[20:00] * rgs wants a @*INC.yaml.say

[20:00] <gaal> rgs, you're sure to get it when YAML.pm lands

[20:01] <gaal> in fact grep the channel logs for autrijus' explanation of how easy this kind of thing is to add

[20:01] <gaal> (modulo YAML.pm itself :-)

[20:02] * kungfuftr needs to buy the perl6 book

[20:02] <rgs> gaal: is it planned ?

[20:03] <gaal> what, a yaml module for p6? of course! if for some reason ingy doesn't port it i'm sure someone else will

[20:05] <Limbic_Region> has autrijus mentioned what the plan is on p6 rules/regexes is?

[20:05] <Limbic_Region> nevermind

[20:05] <Limbic_Region> # 6.283: Rules and Grammars.

[20:05] <xerox> Limbic_Region: url?

[20:05] <Limbic_Region> http://svn.perl.org/perl6/pugs/trunk/docs/01Overview.html

[20:06] <Corion> Err - if I have an array reference $t = [ "foo", "bar" ], what is the Perl6 equivalent to Perl5 @$t ?

[20:06] <Limbic_Region> xerox, if you haven't seen http://www.pugscode.org you might want to check that out too

[20:06] <Limbic_Region> as well as autrijus's use.perl journal

[20:06] <Limbic_Region> http://use.perl.org/~autrijus/journal

[20:07] <xerox> Danke.

[20:08] <ninereasons> $t.elems

[20:08] <ninereasons> I think, Corion

[20:09] <Corion> ninereasons: Looks good, at least no compiler error there anymore :)

[20:10] <ninereasons> I'm wrong, though.  That's not a deref, as you asked for.

[20:11] <Corion> ninereasons: Yeah - I just fixed the other bugs, and now Pugs tells me that it doesn't know about .elems :)

[20:11] <ninereasons> a TODO

[20:13] <Corion> Anyway - I get a real life timeout now, so -I test-hacking will have to be postponed.

[20:13] <Corion> later all!

[20:30] <gaal> so, is it Boolean (S04) or Bool (S06)? latter wins, right?

[20:33] <schoch> hmmm

[20:33] * schoch is reading synopsis

[20:34] <schoch> junctive types seems scary

[20:34] <gaal> also: how are constants spelled? is thre no sigiless form? my $val is constant = 8;

[20:34] <gaal> how does a constant imported from antoher class look like?

[20:39] <kungfuftr> yay! looks like i can finally signup for safari!

[20:39] * kungfuftr pokes activestate people about getting special rates

[20:39] <Khisanth> why poke activestate?

[20:39] <Khisanth> wouldn't you want to poke O'Reilly? :)

[20:40] <kungfuftr> Khisanth: activestate have a special safari arrangement... my company owns activestate

[20:40] <kungfuftr> =0)

[20:40] <Khisanth> hmm

[20:41] <kungfuftr> Khisanth: ActivePerl Studio Perl includes a safari subscription

[20:42] * Khisanth only uses activeperl occassionally :)

[20:44] * kungfuftr uses it only when he has to, but he gets it for free

[20:45] <Khisanth> well I only use it on windows and with the lack of a decent shell/terminal it isn't very fun

[20:47] <kungfuftr> Khisanth: some of the pro dev tools help a lot in that respect

[20:47] * Khisanth assumes a bunch of GUI stuff

[20:50] <kungfuftr> some commandline stuff too

[20:55] <schoch> wmic is quite nice

[21:00] *** brentdax_ is now known as brentdax

[21:05] <kungfuftr> wmic?

[21:06] <schoch> wmi command line

[21:06] <schoch> can do some crazy shit with it

[21:07] <jabbot> pugs - 1286 - Regression test for -I

[21:07] <jabbot> pugs - 1285 - Fixed typo

[21:08] <schoch> kernel panics are fun

[21:08] <schoch> kungfuftr for example you can do class win32_processor get MaxClockSpeed

[21:08] <schoch> on a remote box

[21:09] *** hide_ is now known as hide

[21:09] <kungfuftr> ah

[21:09] <wilx> Hmm, what good is it for? I've never figured out what can onde do with WMC.

[21:10] <wilx> s/onde/one/

[21:10] <schoch> WMI you mean?

[21:10] <wilx> Err, right. WMI.

[21:10] <wilx> wmic is the executable, right?

[21:10] <schoch> lets say you need to figure out every winblows box on your network that has an admin user

[21:10] <schoch> it makes that very easy

[21:10] <wilx> Hm.

[21:11] <schoch> almost everything in windows has a WMI interface

[21:11] *** metaperl_ is now known as metaperl

[21:12] <kungfuftr> schoch: http://search.cpan.org/~wyant/Win32-Process-Info-1.005/Info/WMI.pm ?

[21:12] <schoch> i used it once to coordinate remotly start/stopping perfmon for a stress test accross several web boxen

[21:12] <wilx> Heh, nice.

[21:14] <schoch> http://www.windowsitpro.com/Windows/Article/ArticleID/23854/23854.html

[21:15] <schoch> i'm sure it can be used for dastardly evil stuff too

[21:17] <jabbot> pugs - 1288 - renamed test for -I option

[21:17] <jabbot> pugs - 1287 - 'make test' ignores test files with uppe

[21:45] <kungfuftr> hhhmmm... does `%hash.kv -> $k, $v` bind variables?

[21:46] <stevan> kungfuftr: it should (i think), but i dont know if pugs can handle it yet

[21:47] <jabbot> pugs - 1289 - adding some io-in-loops tests

[21:47] <kungfuftr> stevan: hhhmmm... tbh, i can't really see a good reason to do it by copy as posed to bind

[21:54] <stevan> oh

[21:54] <stevan> hmmm, didnt read the bind part of the question

[21:55] <stevan> I would expect the keys to be immutable, since to do it any other way might get a little insane

[21:56] <stevan> then I would also expect the values to do that as well

[21:56] <schoch> krazy keys

[21:56] <stevan> and use %hash{$k} = $new_value if you wanted to change something

[21:56] <kungfuftr> stevan: yar, i suppose, not very dwim though

[21:56] <stevan> I recall reading something somewhere about hash interators and thier caveats and limitations

[21:57] <stevan> kungfuftr: what does p5 do with each(%hash)

[21:57] <stevan> I think it copies IIRC

[21:57] <schoch> iterators in java have some major problems in multithreaded apps

[21:57] <stevan> iterators in any langauges can have problems multithreading :)

[21:57] <kungfuftr> yar

[21:58] <schoch> ya, the locking can be painfull

[21:58] <stevan> (except for some weird parrallel logic/dataflow languages like Lucid)

[21:58] <schoch> will perl6 have any concept of threadsafe?

[21:59] <stevan> schoch: I have no idea,.. my guess is that they might differ that to Parrot

[21:59] <stevan> or at least as much as the can possibly differ to parrot

[22:02] <stevan> ingy: ping?

[22:03] <stevan> ingy: just wondering if your battle with MakeMaker re: Test.pm and File::Spec was fruitful

[22:17] <jabbot> pugs - 1291 - added END block to io tests to remove th

[22:17] <jabbot> pugs - 1290 - more Pod::Stream::Parser work; better ve

[22:24] <chip> Larry's last statement on threading was that Perl would expose whatever Parrot provided

[22:24] <chip> At least, that was his last statement in my personal reference frame

[22:25] <chip> the grass is always greener on the other side of the light cone

[22:37] <gcom> 

[23:27] <kungfuftr> (p6 and parrot essentials)++ # good reference

[23:54] <ingy> stevan: hola

