[00:01] <putter> iblech: looks like "make test-js" is currently broken.  smoke looks ok.

[00:07] <putter> sigh.

[00:07] <putter> &

[00:50] *** brentp is now known as _brentp

[04:38] *** _brentp is now known as brentp

[04:51] <gaal> putter: maybe we can just filter out -B [<opt>] in pugs and then not have to worry about it in the backend? like the perl frontend did with s///.

[04:52] <gaal> putter: also, you mean a magical variable, right, not environment. a p6 version of $^X.

[04:52] <gaal> I'll see to it when I have some free time, but as I've moved offices and tasks things are a little dense atm.

[04:59] <brentp> so

[05:00] <brentp> is there an estimated release date of perl6

[05:00] * brentp cant wait

[05:04] <dduncan> well, Larry knows, but isn't telling

[05:04] <dduncan> he said so in his last Onion speech

[05:05] <brentp> heh

[05:05] <brentp> how much work would be needed to port perl5 code to perl6

[05:06] <dduncan> very little, if the perl 5 code is written in a well-maintainable fashion

[05:07] <dduncan> and even then, automated tools are being produced now to make it almost effortless

[05:07] <Supaplex> qool

[05:07] <dduncan> Larry's modifying a branch of Perl 5 to maintain all whitespace etc in its parse tree, so it can spit out perl 5 code identical to what it parsed; the next step is that it can then generate equivalent Perl 6 code

[05:08] <dduncan> however, that's meant to be a quick-port solution

[05:08] <Supaplex> humph

[05:09] <dduncan> a better long term solution is to either take that output and massage it into better perl 6 code, or write it yourself

[05:09] <dduncan> you should still understand perl 6 if you're going to maintain the translated version

[05:10] <dduncan> but perl 6 provides ways to do the same things as perl 5, that look either identical or very similar, so a basic port isn't too hard

[05:10] <dduncan> but perl 6 also provides improvements that a developer should be exploiting, things that perl 5 can't do at all

[05:11] <dduncan> though some of those can be simulated with perl 5 modules

[05:15] <brentp> wheres the rundown on perl6

[05:15] <brentp> ie; the differences

[05:15] <brentp> etc

[05:25] <autrijus> greetings

[05:26] <geoffb> Hi there . . . still duing ICFP?

[05:28] <dduncan> greetings

[05:32] <brentp> haha

[05:32] <brentp> armed and dangerous dolphins were released in the hurricane

[05:32] <dduncan> funny, I just mentioned that on another IRC channel

[05:33] <brentp> heh

[05:33] <dduncan> http://observer.guardian.co.uk/international/story/0,6903,1577753,00.html

[05:33] <brentp> you reading /.?

[05:33] <dduncan> yes

[05:33] <brentp> heh

[05:33] <dduncan> one of the replies linked to this also: http://www.defensetech.org/archives/001580.html

[05:33] <dduncan> and that one has various funny links of its own

[05:34] <dduncan> the place I brought this up first was on the IRC channel for the 'joy of tech' comic strip

[05:34] <dduncan> always worth a read, that comic

[05:35] <dduncan> (add a .com to those words, for the url)

[05:35] <dduncan> ... to the website

[05:35] <brentp> wheres the joy of tech channel?

[05:36] <dduncan> its #joyoftech on irc.slashnet.org

[05:36] <dduncan> but the web site is the main show

[05:37] <autrijus> rehi

[05:37] <autrijus> sorry, was on taxi

[05:38] <autrijus> in the icfp site now -- the keynote is going to be very relevant and interesting

[05:38] <autrijus> (on how "optional" explicit type annotations really works from a language implementor's pov)

[05:41] <geoffb> Is it correct to decode that into "It's OK if we let the programmer decide between ducks and Mallards"?

[05:42] <dduncan> a Mallard is a type of duck

[05:42] <dduncan> I know, they live around where I do

[05:43] <geoffb> I knew that.  I was trying to be funny.  Apparently a bad thing to do when tired.

[05:43] <autrijus> geoffb: yeah, but the problem is that if the programmer only does that partially

[05:43] <dduncan> okay, fine if you were being funny

[05:43] <autrijus> and if the module author has different level of annotations than the user

[05:43] <autrijus> et cetera

[05:43] <dduncan> as long as the audience is educated enough to recognize that was intended

[05:44] <dduncan> never mind

[05:44] <geoffb> ah . . . misinterpreted "really works" -- I read it as "It does, in fact, work", as opposed to "this is how it happens internally"

[05:44] <autrijus> *nod*

[05:44] <autrijus> yeah, this area was very fuzzy

[05:45] <autrijus> lots of heuristics but very few formal theory

[05:53] <wolverian> Juerd, hey, nice p6l posts. I like the generic stringification proposal.

[05:55] <autrijus> mm benjamin pierce, the tapl author and icfp chair, is sitting next to me :)

[05:55] * autrijus starts taking notes

[05:56] <wolverian> autrijus, touch him for me, will you :)

[05:57] <autrijus> :D

[06:00] <autrijus> Keynote: Where is ML Type Inference Headed Types are good - safety etc; writing types down can be horrible. Type inference is constraint solving as we all know. As type system becomes more powerful, it needs to require more help from the probrammer. But many information are "blatantly obvious" to the programmer. A front end to the constraint based solver: aka "local type inference", propagates type information according to heuristics. We call it "strat

[06:00] <autrijus> (full transcript will be made online an indeterminable days in the future)

[06:07] <autrijus> In Classic H-M ("full") type inference, we pass candidates judgements around according to the constraints, solve them into the (provably) only solution possible, so the programmer needs not write any types down. Normal implementations maintain an enrivonment of known-valid judgements. But the speaker proposes that we eliminate the type environment, enrich syntax of constraints, and embed the judgements directly into constraint variables. (lots of formu

[06:11] <Khisanth> wolverian: that might be weird if he happens to look over at autrijus' screen

[06:11] <rafl> Morning

[06:12] <sili> all of that inference and constraint solving sounds slow

[06:12] <autrijus> Constraint generator for typed lambda calculus with subtyping in linear complexity. Generaion and solving are separate passes. Constaint language remains simple even when you add features into programming language. Ergo: it's a practical new way to write inferencers.

[06:12] <autrijus> sili: "linear"

[06:13] <sili> hmm

[06:13] <autrijus> now demonstrating this technique on a OO-ML language

[06:14] <autrijus> ...with GADTs

[06:15] <autrijus> hm, no, scratch the OO/subtyping part, that's for the next demonstration

[06:15] <autrijus> familiar GADT typing rules follows

[06:18] <autrijus> "case" over a GADT, with annnotations only on the toplevel, and infer everything else on the subterms

[06:18] <autrijus> (GHC 6.4 does that but has unpleasant interactions with type classes)

[06:18] <autrijus> now reducing this problem in the new light of constraint solving

[06:19] <GeJ> Good morning gentlemen

[06:19] <autrijus> first intuition is adding implicit constraints

[06:20] <autrijus> turns out to be a bad idea

[06:20] <autrijus> as they have no readily solvable rules

[06:21] <autrijus> and we lose principal types in many cases - a "constant int" has many many weird types

[06:23] <autrijus> # http://cristal.inria.fr/~fpottier/publis/pottier-regis-gianas-05.pdf

[06:24] <autrijus> ah. two-phase shape+type inferencing. makes lots of sense.

[06:25] <nothingmuch> morning

[06:25] <autrijus> yo.

[06:25] <geoffb> morning

[06:26] <autrijus> good, that paper explained wobbly types in a way that my brain can accept

[06:26] * nothingmuch shivers at the insanity

[06:26] <autrijus> nothingmuch: you saw the url link to the icfp invited talk? I think it will jibe well with you

[06:26] <nothingmuch> no

[06:26] <nothingmuch> where?

[06:26] <autrijus> http://cristal.inria.fr/~fpottier/publis/pottier-regis-gianas-05.pdf

[06:27] <nothingmuch> aha

[06:27] <autrijus> splitting type inference into two phases, using constraint resolving

[06:27] <nothingmuch> sounds nice

[06:27] <autrijus> yup

[06:27] <nothingmuch> is it already implemented? ;-)

[06:27] <autrijus> the understandability is the main win

[06:27] <autrijus> it is, in GHC 6.4, but not well understood

[06:27] <nothingmuch> no, i meant in pugs

[06:27] <autrijus> this is mostly an attempt to formalize the idea

[06:27] <autrijus> heh no ;)

[06:28] * nothingmuch goes to see what's new in his work mailbox today

[06:29] <nothingmuch> It's not a Date, it's a UnixEpochTimestamp. I'm choosing my classes                                      

[06:29] <nothingmuch> for maximum expositive effect

[06:29] <nothingmuch> there's a class for UnixEpochTime?!!!

[06:31] * nothingmuch thinks Ashley is crazy

[06:32] <nothingmuch> in fact, i think the pro interpolation-is-ne-stringification  people in the stringification-should-be-mega-fucking-overloaded thread have not yet hunted down any bug that has to do with this stuff yet

[06:33] <geoffb> . . . You know, having a one-line Forth definition work the first time is every bit as satisfying as having 10 or 20 lines of Perl work the first time . . . 

[06:34] <nothingmuch>  yes, that's true =)

[06:34] * nothingmuch would like to bring up such a bug

[06:34] <nothingmuch> a wonderful bug with stringification

[06:34] * nothingmuch had to do Algorithm::Dependency stuff with CDBI objects

[06:34] <nothingmuch> and since this was in Maypole the CDBI objects were automatically stringified to any column that slightly resembled the word "name"

[06:35] <nothingmuch> i made the objeccts inherit Algorithm::Dependency::Item (what a wonderful interface)

[06:35] <nothingmuch> and then I tried to calculate dependencies

[06:35] <nothingmuch> but it just didn't work

[06:35] <nothingmuch> because A::D used the stringified value of the objects in a hash, instead of using a refhash or Set::Object

[06:36] <nothingmuch> this took me about an hour to crack

[06:39] * rafl hat similar problems with catalyst and cdbi once.

[06:40] <rafl> s/hat/had/ :-)

[06:49] <nothingmuch> oh, no, i'm sorry

[06:49] <nothingmuch> that was another story

[06:49] <nothingmuch> while ( my $id = shift @queue ) {

[06:49] <nothingmuch> that was my problem

[06:52] <QtPlatypus> while (defined (my $id = shift @queue )) {

[06:53] <nothingmuch> no

[06:53] <nothingmuch> while (@queue) {

[06:53] <nothingmuch> my $id = shift @queue

[06:54] <nothingmuch> but nevermind, the whole concept of IDs is, quite frankly, stupid

[06:54] <nothingmuch> see also Algorithm::Dependency::Objects

[06:54] <nothingmuch> twice the convenience

[06:54] <nothingmuch> 1/5th of the slocs

[06:54] <nothingmuch> 10 times the safety

[06:54] <nothingmuch> and probably performs better too

[06:55] <nothingmuch> Set::Object instead of an Algorithm::Dependency::Source being a funny object interface for a hash (with a _load_items method), and every item being a wrapper or inheritence glue into an item which must now know about ids

[07:10] <nothingmuch> hola luqui 

[07:10] <luqui> hola

[07:10] * luqui writed an attribute grammar module

[07:10] <luqui> test-first (my first time)

[07:10] <nothingmuch> =)

[07:10] <luqui> albeit, there was only one test, but it was a complicated one

[07:11] <geoffb> luqui, just about to head off to sleep, but:  You said you were teaching an OpenGL class . . . are the slides linked anywhere?

[07:11] <nothingmuch> that actually makes test first hard

[07:11] <luqui> geoffb, no slides

[07:11] <nothingmuch> test first should be as incremental as possible

[07:11] <luqui> well then it wasn't test first

[07:11] <luqui> it was "I want this interface"

[07:11] <geoffb> luqui, notes, article, etc?

[07:11] <luqui> more like a user story I guess

[07:12] <luqui> geoffb, none of the above.  I was kinda like "I know about opengl, and you don't, so let's make something you want to make"

[07:12] <geoffb> ah.

[07:12] <geoffb> Since I write articles teaching OpenGL, I was looking for material to assimilate.  :-)

[07:13] <luqui> geoffb, both of my sessions spent an hour setting up

[07:13] <luqui> ugh

[07:13] <geoffb> bleah

[07:13] <luqui> if anything, a good starters template for the compiler-deficient would be nice

[07:13] <nothingmuch> Juerd++

[07:13] <nothingmuch> good post

[07:13] <luqui> mingw + sdl or something

[07:13] <luqui> Juerd++

[07:14] <geoffb> Wayne Keenan's SDL_perl for win32 . . . <cough>

[07:14] <nothingmuch> that relates to my Debuggable role proposal a bit

[07:14] <luqui> heh, these folks didn't know perl

[07:14] <geoffb> :-)

[07:14] <geoffb> ah well

[07:14] <geoffb> OK, must off to bed for real

[07:16] <nothingmuch> ciao!

[07:19] <autrijus> mm techniques for writing safely composable source filters

[07:19] <nothingmuch> *universee folds and makes a plop sound

[07:19] <autrijus> involves CPS macros, ASTs, and type-directed translation

[07:19] <autrijus> but would work even in perl5 setting

[07:20] <autrijus> it's just very counterintuitive ;)

[07:20] <nothingmuch> hehe

[07:20] <autrijus> the key idea seems to be in something called macro-continuations

[07:20] * autrijus reads some more papers

[07:21] <nothingmuch> sounds spooky =)

[07:21] <autrijus> not surprisingly it's yet another oleg papr =)

[07:21] * luqui conjectures that autrijus, by some freak of mathematics, has read an uncountably infinite number of CS papers

[07:21] <autrijus> # http://okmij.org/ftp/papers/Macros-talk.pdf 

[07:26] <luqui> oh, autrijus, you probably already know this, but it is possible to solve the expression problem in haskell

[07:26] <luqui> it's just an abstract pain in the ass

[07:26] <luqui> (as much a PITA as scala, but harder to think about)

[07:27] * Supaplex invokes kill(SIGSLEEP,getpid());

[07:27] <autrijus> aye, yes, I know that, I've read simonpj's paper

[07:28] <autrijus> involves typeclass encodings

[07:28] <luqui> yeah, sortof

[07:28] <autrijus> I'm sure it's possible to do a TH that simplifies the construction of adding variants

[07:28] <autrijus> but it's not yet available and I'm not going to be the one writing it :)

[07:29] <autrijus> (btw, the AG/UUAG solution to expression problem is elegant)

[07:29] <luqui> what it came down to for me was essentially:  data Tree tree = Branch tree tree | Leaf Int

[07:29] <luqui> autrijus, sortof

[07:29] <luqui> it doesn't seem to be easily typesafe

[07:29] <autrijus> oh also, you may want to play with EHC

[07:29] <autrijus> a haskell compiler writting entirely in UUAG

[07:29] <autrijus> very easy to understand

[07:30] <luqui> interesting

[07:30] <autrijus> # http://www.cs.uu.nl/wiki/Ehc/WebHome

[07:30] <luqui> I'd like you to look over Attribute::Grammar when I get a few more tests/features

[07:30] <autrijus> k. on cpan yet?

[07:31] <luqui> nope, soon

[07:31] <autrijus> cool

[07:31] <autrijus> luqui++ # put the C in CPAN

[07:31] <luqui> I implemented the module about three hours after learning what ann AG was :-)

[07:31] <luqui> so it will be missing some things :-)

[07:32] <nothingmuch> luqui: don't upload it as Attribute::Grammar please

[07:32] <nothingmuch> that will confuse people wrt attribute handlers

[07:32] <autrijus> Grammar::Attribute?

[07:32] <autrijus> you know, like org.pugscode.class.type.foo

[07:32] <autrijus> reversed nouns

[07:32] <nothingmuch> i think that works better, but perhaps '<some category::AttributeGrammers'

[07:33] <luqui> I like that, for the proper definition of <some category>

[07:33] <autrijus> Perl6 ;)

[07:33] <autrijus> j/k

[07:33] <nothingmuch> hehe

[07:33] <autrijus> Language::AttributiveGrammar

[07:33] <autrijus> Language::AG

[07:33] <luqui> heh, not quite.   some of the syntax is vaguely reminiscent though

[07:34] <nothingmuch> http://en.wikipedia.org/wiki/Category_Theory

[07:34] <luqui> nothingmuch, and...?

[07:34] <nothingmuch> generalized abstract nonsense WRT to <some category> could be amusing

[07:34] <nothingmuch> nevermind the confusion of the different sense of category

[07:34] * luqui will go with Language::AttributiveGrammar for now

[07:35] <nothingmuch> mui bien

[07:35] <luqui> what about the category of categories (from <some category>, not category theory)

[07:35] <luqui> I wonder what the morphisms on that category would be

[07:42] <scook0> luqui: ping  # theories

[07:43] <luqui> pong

[07:43] <scook0> well, mostly patterns anyway

[07:43] <scook0> I noticed the "how did that T get on the LHS of my pattern type" problem

[07:43] <scook0> but it occurred to me that that T is almost meaningless anyway

[07:43] <luqui> how so?

[07:44] <scook0> because it doesn't mean "if you give me a T, I'll give you a result"

[07:45] <scook0> because for the auto-generated patterns in particular, each pattern can only succeed for one union tag

[07:46] <scook0> so the T isn't telling us much about what's legal to give to the pattern

[07:46] <scook0> it's really only saying "if it ain't a T, don't even bother"

[07:46] <luqui> well, that would have to be a special property of patterns

[07:46] <luqui> but I see your point, it very well could be

[07:46] <luqui> the T does tell you something, though

[07:47] <luqui> T is bound by the theory

[07:47] <luqui> so it means "it is reasonable to match this pattern against this type"

[07:47] <scook0> yes, that's what I meant by "otherwise don't bother"

[07:48] <luqui> well, the question is, is it a "otherwise don't bother" failed match, or a "otherwise don't bother" failed typecheck?

[07:48] <autrijus> woot, just gave Pierce a pugs t-shirt

[07:48] <luqui> viva la revolucion

[07:49] <luqui> after all, a typecheck against a function makes sure that the argument is in the domain of the function

[07:49] <luqui> but I think patterns can be sort of special, because they are

[07:49] <scook0> hmm, I'm just thinking about the implications of that typecheck on superset-union types

[07:50] <luqui> however, in order to get good typechecking, I need some way to declare that "these five patterns will match all of this type"

[07:50] <luqui> and I don't think the theory does that

[07:51] <scook0> if the pattern matcher is typed as taking a Tree

[07:51] <scook0> what happens when you give it an AnnotatedTree?

[07:51] <scook0> the pattern might still be valid

[07:51] <luqui> how so?

[07:51] <luqui> oh, right

[07:52] <luqui> that's like giving an Animal to a function taking a Dog

[07:52] <scook0> but AnnotatedTree :> Tree

[07:52] <scook0> exactly

[07:52] <luqui> and so that ought to fail to typecheck

[07:52] <scook0> and then that would preclude meaningful behaviour

[07:52] <nothingmuch> autrijus: please jjoin in the stringification thread... Localization is being brought up, and I think you have a lot to contribute

[07:53] * luqui is surprised dan kogai hasn't piped up

[07:53] <scook0> so this is kinda what I meant when I said that T doesn't buy you much in the sig

[07:53] <luqui> well....

[07:53] <luqui> hmm...

[07:54] <luqui> if you have a function that tries to match that pattern, it tells you that the domain is at least that big

[07:54] <luqui> even when it's not

[07:54] <luqui> odd...

[07:54] <scook0> the pattern is valid for a type...

[07:54] <scook0> provided that /some/ of that types values are also Ts

[07:54] <luqui> so we must consider a union to really be a union

[07:55] <luqui> and we then have o'caml tagged types

[07:55] <scook0> 'really a union'?

[07:55] <luqui> which may not be so bad

[07:55] <scook0> was I missing something?

[07:55] <luqui> well, it just turned the union type into a factory and a bunch of roles

[07:56] <luqui> and there was nothing left that said that the roles are *the only things* that can make up the union

[07:57] <scook0> so we can't assume that unions are complete?

[07:57] <luqui> so we must have:  Branch <: Tree;  Leaf <: Tree;  Tree <: Leaf (+) Branch

[07:57] <luqui> which seems like it could possibly be hell for a typechecker

[07:57] <luqui> but possibly not

[07:58] <luqui> oh, and even Branch (*) Leaf == Bottom

[07:59] <luqui> now we're getting into things that are uncheckable

[07:59] <scook0> hold on, I'm not following

[07:59] <luqui> well, I'm just jabbering on about how a union type should look

[07:59] <luqui> without respect for patterns

[08:00] <luqui> then maybe the domain for pattern:<Leaf> ought to be Leaf

[08:00] <luqui> clearly.  and then it will never fail

[08:00] <scook0> yeah, that was one thing I was thinking of

[08:00] <scook0> but I'm not sure it generalises to arbitrary patterns

[08:00] <luqui> right

[08:01] <luqui> well, you'd have to pick the smallest representable superset of what you do actually match

[08:01] <scook0> what if you have something like pattern:<EvenLeaf> (matches a leaf containing an even number)

[08:02] <luqui> it's domain would probably have to be Lead

[08:02] <luqui> Leaf

[08:02] <scook0> exactly

[08:02] <luqui> anyway, that's not important, and is a widely studied area

[08:02] <luqui> what's important is that this has to fit into a theory

[08:02] <luqui> because my mock objects are beloved to me

[08:03] <scook0> mock objects?

[08:03] <luqui> pretending an object is of a type when it isn't

[08:03] <luqui> or rather, I'm trying to make that impossible

[08:03] <luqui> that is, you can make an object behave like it's in a certain type, and then it is defined to be in that type

[08:04] <scook0> ah

[08:04] <luqui> that's what the theory does.  Everybody else wants to separate "a real thing" and "its interface"

[08:04] <scook0> is that why you made every class a role?

[08:04] <luqui> uh huh

[08:04] <scook0> I thought so -- there are certainly some advantages

[08:05] <luqui> hmm, I was thinking the other day that you could implement patterns using classes

[08:05] <luqui> an object in class Tree just has methods pattern:<Branch> and pattern:<Leaf>

[08:06] <luqui> and an object in class AnnotatedTree has those two plus pattern:<Ann>

[08:06] <luqui> but the subtyping comes up backwards if you do that

[08:06] <luqui> however---

[08:06] <luqui> maybe if you define that an object in class Tree has method pattern:<Branch> *or* pattern:<Leaf>

[08:06] <luqui> then a union type is a union theory: you must implement this or that

[08:07] <luqui> {Branch | Leaf} <: {Branch | Leaf | Ann}  ??

[08:07] <luqui> clearly true

[08:08] <scook0> are you talking about unions or union theories?

[08:08] <luqui> trying to bring the two together

[08:09] <luqui> but I think the latter

[08:09] <luqui> that is, you obey Tree even if you only implement Leaf

[08:09] <scook0> and by extension, you also obey AnnotatedTree

[08:09] <luqui> yeah

[08:10] <luqui> but then you get the factory types, which is what gets us past the scala "abstract constructor" problem

[08:11] <luqui> that is, for a type T to obey Union, you have to either implement pattern:<Leaf> or pattern:<Branch>, and you have to be able to create both

[08:11] <luqui> I think I need some time with the mathematical implications of this

[08:11] <luqui> because I think it's the right foundation

[08:11] <luqui> er, s/Union/Tree/

[08:12] <scook0> I think the underlying problem is that unions tend to invert the subtyping relationship

[08:12] <luqui> is there a duality there

[08:12] <scook0> when compared to records/classes

[08:12] <scook0> because a class that does more is a subtype

[08:12] <scook0> but a union that does LESS is a subtype

[08:13] <luqui> depending on what you mean by *less*

[08:13] <luqui> but yes, that's the "problem"

[08:13] <luqui> which I've called a beautiful duality :-)

[08:13] <luqui> I'm just wondering if the creation bit has some duality with roles

[08:13] <scook0> s/problem/key point/

[08:14] <scook0> I wonder how that duality interacts with co/contra-variance

[08:14] <luqui> very elegantly

[08:15] <luqui> that's the whole point behind roles/factories

[08:15] <luqui> but then there's this pattern thing that is throwing everything off

[08:15] <luqui> and I hope I can get it back ;-)

[08:15] <scook0> I hope so too

[08:15] <scook0> auto-defined patterns would be easy to get back

[08:16] <scook0> but arbitrary patterns are the big win

[08:16] <luqui> to be honest, I never really cared about arbitrary patterns

[08:16] <luqui> but it seemed obvious if I was going to allow mock anything else

[08:16] <scook0> patterns are a bit like "reverse functions", actually

[08:17] <luqui> they are the reverse of the union case constructors :-)

[08:17] <scook0> which might be why we run into problems when treating them as normal functions

[08:17] * luqui wonders if a pattern is just a formalism for an inverse function

[08:18] <luqui> and of course, if you have a function and an inverse function, then you have an isomorphism

[08:18] <luqui> which could be construed as a "safe coersion"

[08:18] <luqui> wow... abstract nonsense

[08:19] <scook0> I'm impressed

[08:19] <luqui> I'm going to have to sleep on this

[08:19] <integral> luqui: Have you seen epigram?

[08:19] <luqui> by which I mean "lose sleep over this" :-)

[08:19] <luqui> integral, I read the project description

[08:20] <integral> it has a <= operator thing I don't full understand that appears to do it's pattern matching

[08:20] <luqui> oh wait, i did see some epigram code

[08:20] <integral> sorry, afk

[08:20] <luqui> I was completely lost

[08:21] <luqui> integral, thanks

[08:21] * luqui must sleep now

[08:21] <luqui> scook0, thanks, you stirred up ideas again

[08:22] <scook0> luqui: my pleasure -- bye

[09:03] *** davidra is now known as jp-autark

[09:04] <wolverian> identify divine

[09:04] <wolverian> hmm. oops

[09:04] <wolverian> :]

[09:05] <wolverian> now, let's everyone /clear together

[09:11] <buu>  zomg

[09:11] <buu> GOING TO GET PWNED

[09:14] <wolverian> :(

[09:15] <buu> Fear the wrath of my repressed inner script kiddy.

[09:17] <nothingmuch> wolverian: nickserv.pl is your friend

[09:20] <buu> eval: print "?eval say"

[09:20] <buubot> ?eval sayReturn: 1 

[09:20] <buu> hrm

[09:20] <buu> No bot cascades for me

[09:22] <QtPlatypus> Thats good, otherwise a quine would be an infinit loop

[09:22] <buu> I can but hope!

[09:25] <buu> Quites are entirely too complicated for me.

[09:25] <Juerd> Quines

[09:28] <nothingmuch> hi Juerd

[09:29] <nothingmuch> very good post on stringification

[09:29] <nothingmuch> thank you

[09:29] <buu> Juerd: Quines are quite complicated!

[09:30] <Juerd> nothingmuch: Thanks

[09:30] <Juerd> I felt this needed to be said 

[09:31] <Juerd> Typing it has severely cut in my sleeping time, though, so don't expect me to be very active today :)

[09:33] <spinclad> buu: 'is quite simple' is quite simple.

[09:33] <spinclad> but ''is quite simple' is quite simple' is a bit more complicated, true

[09:37] <buu> spinclad: Er, what?

[09:38] <spinclad> ''\_: _ is quite simple' is quite simple' is either simpler or more complicated than that...

[09:39] <spinclad> '\_: _ is quite simple' is just a function

[09:39] <spinclad> f, say; its quine is just (f f)

[09:40] <spinclad> so (f this)?

[09:44] <svnbot6> r7142 | scook0++ | * Minor code tweaks to Parser.hs

[09:44] <svnbot6> r7142 | scook0++ | * Doc typo fixes for Blondie and theory.pod

[11:17] <autrijus> nothingmuch: seen nothingmuch

[11:19] <autrijus> nothingmuch: ccshan just gave me this strange puzzle; I finished it and you may be interested in the result

[11:19] <autrijus> the puzzle is how to define "begin" "push" "add" and "end"

[11:19] <autrijus> such that

[11:19] <autrijus> begin push 3 push 4 add end

[11:19] <autrijus> evaluates to 7

[11:19] <autrijus> and in a typesafe way, so illegal forth programs can't typecheck

[11:20] <autrijus> the answer is

[11:20] <autrijus> begin = ($ ())

[11:20] <autrijus> push s x = ($ (x, s))

[11:20] <autrijus> add (x, (y, s)) = ($ (y + x, s))

[11:20] <autrijus> end (x, ()) = x

[11:46] <nothingmuch> autrijus: who is ccshasn?

[11:48] <autrijus> nothingmuch: http://search.cpan.org/~kenshan/

[11:48] <autrijus> I learned shift/reset delimited continuations from his papers, among other nifty stuff

[11:49] <nothingmuch> hmm

[11:49] * nothingmuch will look into it

[11:49] <nothingmuch> pbut right now Microsoft's delightful CryptAcquireContext is going to swollow up my time

[11:49] <nothingmuch> aas for the puzzle, that's pretty cool

[11:50] <nothingmuch> reminds me of how ski used . to make a nice forthish syntax

[11:51] <autrijus> but the fun thing is that it "typechecks" forth, so to speak

[11:51] <autrijus> by guarding against stack over/underflows

[11:52] <nothingmuch>  yep =)

[11:52] * nothingmuch is still trying to grok

[11:52] <pdcawley_> seen luqui?

[11:52] <nothingmuch> but sort of getting it

[11:52] <nothingmuch> pdcawley_: earlier today

[11:53] <nothingmuch> autrijus: essentially it's a CPS machine, right?

[11:53] <pdcawley_> I just wondered if he'd done another 'In their conference call this week, @Larry talked about...' summary.

[11:53] <nothingmuch> begin gets (push 3 push 4 add end)?

[11:53] <nothingmuch> pdcawley_: a second one? or a third one?

[11:53] <nothingmuch> see http://use.perl.org/~luqui/journal

[11:53] <pdcawley_> dunno. One for last week, I want to roll it into the summary.

[11:54] <nothingmuch> btw, sorry for giving you a hard time this week ;-)

[11:54] <autrijus> nothingmuch: easier version: http://nopaste.snit.ch:8001/4405

[11:54] <pdcawley_> You gave me a hard time? When?

[11:57] <autrijus> pdcawley_: the p6l portmanteaus

[11:58] * pdcawley_ confesses that right now he's doing a very cursory skim of the lists as stuff arrives and then reading in more depth when it comes time to write the summary.

[11:59] <pdcawley_> Which means that, in an hour or so when I reach p6l I'll probably pop up here and go "nothingmuch: No problems mate!", or "You *utter* bastard" depending on my mood.

[11:59] <pdcawley_> Sadly this week's summary will not include any cricket commentary.

[11:59] <nothingmuch> pdcawley_: i hope my mails are easy to skim ;-)

[11:59] <nothingmuch> Juerd said that I could try to do a better job of it

[12:01] <nothingmuch> autrijus: so i was write about it being CPS like

[12:01] <nothingmuch> it basically makes a Joy out of forth ;-)

[12:01] <nothingmuch> no wait, that pun is not only lame it's also inaccurate

[12:01] <nothingmuch> because k is not really on the stack

[12:02] <nothingmuch> btw, begin and end could be conveniently monadized, right?

[12:03] <autrijus> sure, but the cool thing they don't have to be

[12:03] <autrijus> it's just simple typed lambda calculus

[12:04] <nothingmuch> btw, i just read the first page of "The Essence of Compiling with Continuations" over lunch

[12:04] * nothingmuch is very proud that he didn't give up yet

[12:05] <autrijus> cool

[12:05] <nothingmuch> i actually understood everything so far ;-)

[12:05] <nothingmuch> even the BNF

[12:05] <nothingmuch> (for core scheme)

[12:07] <autrijus> nice :)

[12:08] <autrijus> I'm still trying to get my head around the first talk of today

[12:08] <autrijus> about separating partial (user-annotation-driven) type inference/checking

[12:08] <autrijus> from complete (compile-figure-out-everything) type inferencing

[12:08] <autrijus> into two phases

[12:09] <autrijus> which would hopefully give us a good way to talk about "static typechecking in p6" in a robust way

[12:11] <nothingmuch> autrijus++

[12:11] <nothingmuch> that's important

[12:12] <pdcawley_> Autrijus: Are you going to be at EuroOSCON?

[12:12] * nothingmuch tries to wrap his brain up and make it crap out useful data

[12:12] * nothingmuch has to do:

[12:12] <nothingmuch> some bug, monthly presence report, fix a wrapper script on the unixes

[12:12] <autrijus> pdcawley_: aye

[12:13] <pdcawley_> Is there a hackathon planned?

[12:13] <autrijus> pdcawley_: not currently, mostly due to having to go to NPW after that

[12:13] <pdcawley_> NPW?

[12:13] <autrijus> so if a hackathon is to be planned, has to be before the conf

[12:13] <autrijus> nordic perl workshop

[12:13] <pdcawley_> Gotcha.

[12:13] <autrijus> 24 hours after oscon

[12:13] <autrijus> eurooscon that is

[12:13] <pdcawley_> Yeah.

[12:13] <nothingmuch> what about before eurooscon?

[12:13] <autrijus> I'm fine with that

[12:13] <autrijus> I can arrive early if other people do

[12:14] * pdcawley_ won't be able to make it -- flights all booked for the Sunday before.

[12:14] <nothingmuch> i can arrive early if stev^Wsomeone pays me to ;-)

[12:16] <autrijus> :)

[13:12] <clkao> autrijus: i am arriving 5pm sunday

[13:20] <autrijus> clkao: excellent. which hotel are you in again?

[13:21] <clkao> nh city centre

[13:22] <autrijus> url?

[13:22] <clkao> just google

[13:22] <autrijus> k

[13:22] <autrijus> got it with a different spelling of "centre" ;)

[13:50] * pdcawley_ writes: So far there has been no discussion of the return value of C<< Pin.head.contents.grep -> Angel $a { $a.is_dancing } >> but I'm sure it's only a matter of time.

[13:51] <nothingmuch> uh?

[13:51] <nothingmuch> anybody got any statistics for OS popularity amongst desktop using?

[13:51] <pdcawley_> A p6l thread that won't die and is venturing into philosophy.

[13:51] <nothingmuch> which one?

[13:52] <pdcawley_> When you say popularity, do you mean 'number on the desktop' or 'liked the most'?

[13:52] <pdcawley_> Re: \(...)

[13:52] <pdcawley_> But I'm sure there are others.

[13:52] <nothingmuch> oh, that one

[13:52] <pdcawley_> There usually are.

[13:52] <nothingmuch> you poor thing =)

[13:52] <nothingmuch> i stopped reading it two weeks ago

[13:52] <pdcawley_> Hey, I get to be snide.

[13:53] * pdcawley_ notes that he just made up some grep syntax there that'd be really neat.

[13:53] <nothingmuch> i think it works too

[13:53] <nothingmuch> there is no reason why it shouldn't work

[13:53] <nothingmuch> right?

[13:53] <nothingmuch> btw, do you hate me yet?

[13:54] <pdcawley_> 'twould be cool if grep would check the signature of the block and if the current thing isn't of the appropriate type, simply go to the next one instead of throwing a type mismatch error.

[13:54] <pdcawley_> Not yet, no.

[13:54] <pdcawley_> IRC : mailto :: nothingmuch : ?

[13:55] <nothingmuch> ?eval $nothingmuch.real_name

[13:55] <nothingmuch> Yuval Kogman

[13:55] <pdcawley_> Oh, I've always hated you.

[13:55] <nothingmuch> hehe

[13:56] <nothingmuch> i think this week warrants a direct apology

[13:56] <nothingmuch> and that the linkage/compilation week does too

[13:57] <pdcawley_> Oh ghod. You're responsible for the 'conditional wrapper blocks' thread aren't you?

[13:57] <nothingmuch> yep

[13:57] <nothingmuch> and the blondie mess

[13:57] * pdcawley_ *so* wanted to respond with 'write a fucking macro'

[13:57] <nothingmuch> and the linker/optimizer

[13:58] <nothingmuch> that's an implementation detail

[13:58] <nothingmuch> frankly I couldn't care less whether it is a macro or not

[13:58] <pdcawley_> Not really it's not. If you can write a macro to do it, it's not part of the language, it's something you can supply as a library.

[13:58] <pdcawley_> It's certainly not something that needs to be baked in at this point in the game.

[13:58] <nothingmuch> hmm? how come?

[13:59] <nothingmuch> -> vs 'sub' was... what's the diff?

[13:59] <pdcawley_> Because if you need to do it, you include the library that implements the macro.

[13:59] <pdcawley_> Because -> and sub have different return semantics.

[13:59] <nothingmuch> that wasn't the point of the thread... i was trying to see if anyone has a better idea on how this can be expressed

[14:00] * pdcawley_ grins, "Well, I'm about to give it a rather closer reading. I may have missed the original point when I first read it."

[14:01] <pdcawley_> The trouble is, so much stuff that could and should be implemented as a library function/macro turns into something that people think the language itself needs.

[14:01] <nothingmuch> well, i'll argue that it's an implementation detail again

[14:01] <nothingmuch> 'use' is a macro that happens to be in the prelude, IIRC

[14:02] <nothingmuch> i just thought that the concept itself tends to come up from time to time, and maybe people with experience in thinking about how meaning is conveyed can help this be better resolved

[14:02] <nothingmuch> the post was not a "ooh ooh, perl 6 needs this, please add it"

[14:02] <nothingmuch> or was at least not intended as such

[14:03] <pdcawley_> Generally when faced with something like that, I see about factoring it out into multiple subs. Gives you a chance to name things well, and in Perl 6 the 'readability cost' of making a new subroutine is way lower than in Perl 6.

[14:03] <nothingmuch> please explain

[14:04] <nothingmuch> factoring what out?

[14:04] <nothingmuch> the macrosish behavior? or the actual problem?

[14:05] <QtPlatypus> pdcawley_: I'm wondering how much of "stuff" could be factored out and implemented as libary functions/macros.

[14:07] <dada> I'm afraid this is not meaningful at all

[14:07] <pdcawley_> Oh crap. I'm happy to have a philosophical discussion, but not when I'm supposed to be writing the summary. 

[14:07] <pdcawley_> Remind me tomorrow if you like.

[14:07] <nothingmuch> pdcawley_: have fun

[14:07] <pdcawley_> Heh. Sorry and all.

[14:07] <dada> IIRC, the parser itself is going to be implemented in Perl6. so from a certain point of view, _everything_ is in a library function

[14:08] <nothingmuch> dada: and if I get my way most of the builtins too

[14:08] <nothingmuch> at least reference implementations ;-)

[14:09] <dada> mmm

[14:09] <dada> maybe the builtins should be in a (pre)compiled library 

[14:10] <nothingmuch> ofcourse they should

[14:10] <nothingmuch> but there should also be reference implementation

[14:10] <nothingmuch> do you know of the Blondie plan?

[14:10] <dada> in P6, you mean?

[14:10] <dada> no, I don't know

[14:10] <nothingmuch> yes

[14:10] <nothingmuch> well, basically the prelude itself is circular

[14:10] <nothingmuch> for example map can be defined in terms of for

[14:10] <nothingmuch> for can be defined in terms of map

[14:10] <nothingmuch> whateve

[14:10] <nothingmuch> r

[14:11] <nothingmuch> the most readable and correct implementations should be chosen for each bit of code

[14:11] <dada> mmm

[14:11] <nothingmuch> each code block has a hash that can be computed

[14:11] <nothingmuch> let's look at &infix:<*> (Num $x, Int $y)

[14:11] <nothingmuch> it's body is:

[14:12] <nothingmuch> sub &infix:<*> (Num $x, Int $y is copy) { my $res = $x; while ($y--) { $res += $x } };

[14:12] <nothingmuch> --$y

[14:12] <nothingmuch> this block of code computes to a certain hash

[14:12] <nothingmuch> and the hash will change if the definition changes

[14:12] <dada> and?

[14:12] <pdcawley_> 10.1 * -10

[14:13] <nothingmuch> or if &postfix:<--> or += ever change

[14:13] <nothingmuch> pdcawley_: it was a silly example

[14:13] * nothingmuch is forcefully simplifying

[14:13] <dada> _but_

[14:13] <nothingmuch> now, we know that hte parrot runtime has an implementation of multiplication

[14:13] <dada> I guess &infix:<*> will be more something like { inject_parrot_bytecode('mul $x, $y'); }

[14:14] <nothingmuch> so the code emitter for PIR has a DB of hashes and their mapped primitives

[14:14] <nothingmuch> err, yes

[14:14] <nothingmuch> that's exactly what I'm getting to

[14:14] <dada> ok, I'll listen

[14:14] <svnbot6> r7143 | iblech++ | PIL2JS: runjs.pl: Extend putter++'s "-B JS" hack to include "-BJS", restoring jspugs.pl.

[14:14] <svnbot6> r7144 | iblech++ | util/smokeserv/smokeserv-server.pl: Appropriate <span title="..."> for the numbers.

[14:14] <QtPlatypus> So if would be something like &if (&test,&than) { &test() && &than() } # Ok its going to be a macro but you get my drift.

[14:14] <nothingmuch> so the parrot runtime says "i claim that the function whose hash is ... is equivalent to the code 'mul <operand1>, <operand2>'" or whatever

[14:15] <nothingmuch> given proper typing ofcourse

[14:15] <nothingmuch> equivalence is transitive, so when the reference implementation changes, it can have an 'is equiv("hash")' trait

[14:15] <nothingmuch> the purpose of this approach is compound:

[14:16] <nothingmuch> a. reference implementations provide the most accurate definition of behavior

[14:16] <nothingmuch> b. a runtime can implement far less than the whole prelude and can still run perl 6 code (slower)

[14:16] <nothingmuch> (faster development of new backends)

[14:16] <dada> mmm ok, I see the point

[14:17] <nothingmuch> c. things that cannot be expressed in terms of perl 6 code, e.g. open(), are stubbed

[14:17] <dada> you mean: if parrot today does 75% of what Perl6 needs, let's use that 75% and fake the remaining 25% for now

[14:17] <nothingmuch> yep

[14:17] <nothingmuch> or more likely: let's implement what we must

[14:17] <nothingmuch> and then profile

[14:17] <nothingmuch> and implement the slowest builtin

[14:17] <nothingmuch> for a given app

[14:17] <stevan> how do you handle ciruclarity issues on the prelude?

[14:18] <nothingmuch> stevan: the backend must provide at least one equiv has

[14:18] <nothingmuch> h

[14:18] <stevan> morning all :)

[14:18] <nothingmuch> to break the circulaarity

[14:18] <stevan> cool

[14:18] <nothingmuch> i.e. either map, or for

[14:18] <nothingmuch> or both

[14:18] <nothingmuch> but at least one

[14:18] <stevan> pluggable bootstrapping

[14:18] <dada> yes, it sounds cool

[14:18] <nothingmuch> this also makes perl 6 more "flexible" in that IO primitives are stubs in the "default" implementation

[14:18] <nothingmuch> if your runtime happens to support them, fun

[14:18] <nothingmuch> but it's not a requirement =)

[14:19] <nothingmuch> anyway, so Blondie is an AST that is supposed to test this idea

[14:19] <nothingmuch> and right now it has a perl 5 interpreter

[14:19] <nothingmuch> and a type inferrencer which emits C

[14:19] <stevan> does Blondie have macros?

[14:19] * stevan has been reading too much about LISP macros,.. oooohhh so nice

[14:20] <nothingmuch> stevan: nope

[14:20] <nothingmuch> it's not really for that level

[14:20] <pdcawley_> remind me what's the sytax for declaring an optional argument?

[14:20] <nothingmuch> it doesn't have syntax ;-)

[14:20] <nothingmuch> sub foo ($reqiured, ?$optional) { #positionals

[14:20] <stevan> nothingmuch: it seems to me that AST level macros can be an extremely powerful feature,.. especially for defining such low level things

[14:20] <pdcawley_> Ta.

[14:20] <QtPlatypus> sub foo(?$optional)

[14:20] <QtPlatypus> {...}

[14:21] <nothingmuch> stevan: explain "such low level things"

[14:21] * nothingmuch always saw Blondie as picking up after macro expansion has hypothetically already happenned

[14:21] <stevan> nothingmuch: it seems to me, that having map be defined by for, and vice-versa is best done using macros, rather than proper function calls

[14:22] <nothingmuch> stevan: ah

[14:22] <stevan> but Blondie is an AST

[14:22] <nothingmuch> right

[14:22] <stevan> right?

[14:22] <nothingmuch> the perl 6 prelude is perl 6

[14:22] <nothingmuch> it should have all that

[14:22] <stevan> user level macros are on thing

[14:22] <stevan> s/on/one/

[14:22] * pdcawley_ is having a seriously hard time coming up with some 'believable' example 'before' code to explain the 'conditional wrapper blocks' thread.

[14:22] <stevan> but AST level macros are another

[14:22] <nothingmuch> remember that macros in perl 6 can get PIL or whatever the AST ends up being =)

[14:23] <nothingmuch> pdcawley_: uh, i forget what I needed it for ;-)

[14:23] <stevan> nothingmuch: yes, but PIL is not here yet,... Blondie is ;)

[14:23] <nothingmuch> stevan: hmm

[14:23] <QtPlatypus> nothingmuch: My understanding is mostle likely we will not get the AST.

[14:23] <nothingmuch> want to contribute a macro layer that happens before the Blondie::Compiler pass?

[14:23] <pdcawley_> You are so going to have to do better than that.

[14:23] <nothingmuch> QtPlatypus: really? i was sure we're getting both

[14:24] <stevan> nothingmuch: sure, but I need your help to wrap my head around everything

[14:24] <nothingmuch> pdcawley_: i'm trying to remember what I was working on that day

[14:24] <pdcawley_> Macros were originally documented as getting the AST.

[14:24] <stevan> QtPlatypus: I think the rules is "it is open unless explicitly closed"

[14:24] <pdcawley_> Without a macro form that uses the AST and either transforms it or returns an AST fragment or whatever, Perl 6 macros will be severely crippled.

[14:24] <stevan> which translates to "if we can make it open, we will, otherwise you cant have it"

[14:24] <QtPlatypus> pdcawley_: Yes but that changed later on.  There is a bit in the notes about it.  Hold on I'll pull it up..

[14:25] <stevan> pdcawley: amen to that :)

[14:25] <pdcawley_> Stevan: That's my understanding too.

[14:25] <nothingmuch> pdcawley_: well, the c pre processor is obviously not so crippled

[14:25] <nothingmuch> i think one of the obfuscated C contests implemented an ALU in the preprocessor ;-)

[14:25] <pdcawley_> Yes it fucking is.

[14:25] <stevan> nothingmuch: yeah, write a multi line macro

[14:25] <stevan> you can see the splints

[14:26] <nothingmuch> stevan: no need, you can do \\\n

[14:26] <nothingmuch> ;-)

[14:26] <pdcawley_> The C preprocessor is a monstrous nightmare.

[14:26] <QtPlatypus> pugs/docs/plan read the bit at the end about macros

[14:26] * nothingmuch is not serious, you guys

[14:26] * pdcawley_ can never tell with you.

[14:26] <nothingmuch> sorry =(

[14:26] <QtPlatypus> You will most likely get something like PIL though.

[14:26] * stevan beats nothingmuch with a stick made of LISP

[14:26] <autrijus> nothingmuch: you had a missing ;-) after "crippled"

[14:26] <nothingmuch> autrijus: well, i was building up tension for the punchline

[14:26] <pdcawley_> So you'd have to parse the PIL to get an AST? Ick.

[14:26] <autrijus> pdcawley_: er no, those are objects.

[14:27] <autrijus> PIL is not a surfact language

[14:27] * stevan couldnt hear the drum roll

[14:27] <autrijus> surface, even

[14:27] <pdcawley_> Fairy nuff.

[14:27] <pdcawley_> Has anyone worked out how to do metaquoting in Perl 6?

[14:28] <autrijus> quasiquoting you mean

[14:28] <pdcawley_> That's it, yeah.

[14:28] <pdcawley_> `{...} ?

[14:28] <autrijus> nothing yet

[14:28] <autrijus> {| ... |}

[14:28] <autrijus> not sure. it's not yet on my radar for this milestone :)

[14:29] <pdcawley_> And then the equivalent of ,foo within the quasiquote region?

[14:29] <autrijus> (|...|) maybe?

[14:29] <autrijus> I don't know

[14:29] <pdcawley_> Perl 6 Quasiquoting would definitely make macros nicer.

[14:29] <autrijus> haskell uses [| ... $(foo) ... |]

[14:29] <broquaint> Quasi-quoting for what now?

[14:29] <svnbot6> r7145 | iblech++ | * t/data_types/pair.t: "$pair" eq ~$pair eq "$pair.key()\t$pair.value()", per [1].

[14:29] <svnbot6> r7145 | iblech++ | * t/operators/array_interpolation.t: "@array[]" eq ~@array, weird whitespace

[14:29] <svnbot6> r7145 | iblech++ |   exception rule gone, per [1].

[14:29] <svnbot6> r7145 | iblech++ | [1] http://www.nntp.perl.org/group/perl.perl6.language/23224

[14:29] <nothingmuch> broquaint: well, something close to perl is SQL

[14:30] <nothingmuch> you can have your driver check your SQL at compile time

[14:30] <nothingmuch> instead of as a string later on

[14:30] <pdcawley_> broquaint: Well, sometimes it's easier for a macro to return a stringish thing rather than a transformed AST.

[14:30] <nothingmuch> oh, that too

[14:30] <broquaint> So we're borrowing the LISPs idea of q-q?

[14:30] <pdcawley_> We're suggesting it :)

[14:30] <broquaint> Ack!

[14:30] <autrijus> I think it'd be a good idea :)

[14:30] <broquaint> I mean ... yay ...

[14:30] <nothingmuch> ack?

[14:30] <pdcawley_> And yes, being able to check the string you're about to eval at compile time is lovely too.

[14:30] <broquaint> Quasi-quoting makes my head hurt. Please let there be a sensible syntax highlighter for it.

[14:31] * autrijus points randomly to perl6.vim and cperl6-mode

[14:31] <nothingmuch> errm... i think that neither could really do it without an embedded perl compiler

[14:31] <nothingmuch> err... interpreter

[14:31] <nothingmuch> system

[14:31] * broquaint is still suspicious of the horror of q-q

[14:32] <pdcawley_> q-q isn't horrid.

[14:32] <pdcawley_> Without it LISP macros would be even more scary than they are already.

[14:32] <broquaint> If you're used to it.

[14:32] <pdcawley_> And that's the *bad* kind of scary.

[14:32] <Supaplex> is down - doo do doot doot doo do doot doot the system the system 

[14:32] <pdcawley_> Not the 'scarily powerful and therefore really rather good'

[14:32] <broquaint> Scarily powerful but still ugly.

[14:33] <QtPlatypus> nothingmuch: It doesn't need one, it just needs a something that takes in perl6  and spits out something digestable

[14:33] <pdcawley_> Yeah, but all lisp quoting is ugly.

[14:33] <broquaint> So let's not use it! :)

[14:33] <nothingmuch> QtPlatypus: ... by running macros written in perl?

[14:33] * pdcawley_ grins, the *concept* of quasiquoting isn't ugly though.

[14:33] <pdcawley_> And why am I chatting on IRC when I *still* haven't finished the summary.

[14:33] <pdcawley_> Can you say "Displacement activity"?

[14:34] * autrijus finishes the AG-for-perl6 review

[14:34] <broquaint> Copy and paste from IRC. It's nearly like the summary - a quasi-summary.

[14:34] <autrijus> or rather AG-for-parrot. still working on the AG-for-perl6

[14:34] <broquaint> AG?

[14:34] <nothingmuch> autrijus: what does "review" mean?

[14:34] <broquaint> Auto-generation?

[14:34] <nothingmuch> broquaint: you don't want to know, it's scary

[14:34] <broquaint> Will it make my head teh splode?

[14:34] <autrijus> nothingmuch: I'm thinking about playing with UUAG-for-PIL2

[14:35] <QtPlatypus> nothingmuch: *nods* Yep.  I'm thinking of doing as a marco that takes in the program and spits out the "How to highlight" instructions.

[14:35] <nothingmuch> QtPlatypus: ah, but it's still perl 6

[14:35] <autrijus> nothingmuch: the EHC compiler is beautiful

[14:35] <nothingmuch> autrijus: what's diff(GHC, EHC)?

[14:36] <autrijus> nothingmuch: GHC is written in functional-monadic style; EHC is written purely declaratively in AGs.

[14:36] <nothingmuch> what does it emit?

[14:36] * autrijus checks the CodeGen files

[14:36] <autrijus> Grin (and therefor C), Java, Haskell

[14:36] <broquaint> Is GHC implemented in Haskell?

[14:36] <autrijus> broquaint: aye, and so is EHC

[14:36] <broquaint> Groovy.

[14:37] * nothingmuch really ought to grok wtf AGs *really* are

[14:37] <integral> Groovy is pure Java apparantly

[14:37] <autrijus> nothingmuch: http://www.cs.uu.nl/wiki/Ehc/WebHome

[14:38] <nothingmuch> http://abaris.zoo.cs.uu.nl:8080/wiki/pub/Ehc/WebHome/AgTutorial.pdf (promising)

[14:39] <putter> autrijus: ping?

[14:39] <autrijus> putter: pong!

[14:39] <putter> :)

[14:39] <autrijus> how's life?

[14:40] <autrijus> ICFP rc0ks. I'm still in it, listening to someone who implemented an OS with haskell

[14:40] <stevan> House?

[14:40] <autrijus> yeah

[14:41] <stevan> nice, I was reading about that last week

[14:41] <autrijus> and the t-shirt penetration rate is increasing steadily

[14:41] <nothingmuch> t-shirt penetration rate?

[14:41] <autrijus> simon pj is wearing perl6 t-shirt all day today

[14:41] <nothingmuch> hah!

[14:41] <stevan> nice

[14:41] <stevan> autrijus: which one?

[14:42] <autrijus> stevan: the perl6/timeline one

[14:42] <autrijus> the "standard" one

[14:42] <stevan> very cool

[14:42] <putter> The next step for pilrun + mm2 is likely going to be a "massage everything into p6 with-conventions, hand to pugs, grovel over result to generate mm2 code".  Which means faking pil2.  What is the current state of pil2 thought?  By faking something similar, pain can be avoided later.

[14:42] <putter> re life, long overdue jobsearch. :/

[14:42] <autrijus> putter: state of thought for pil2 is being heavily reshaped in the past 3 days

[14:42] <autrijus> got _lots_ of discussions with lots of lambdafolks

[14:42] <putter> ok.  I'll optimize for easy.

[14:43] <autrijus> yes, that is very prudent.

[14:43] <autrijus> in particular I'll, at suggestion of allison, look into UUAG for PIL2 instead of the currently handcoded src/PIL*

[14:45] <autrijus> in any case the entire month ahead is for pugs hacking :)

[14:45] <stevan> horray!!!!!

[14:45] <autrijus> no $job interference finally

[14:46] <putter> gaal: not magic var.  an environment variable (as in export PUGS_EXECUTABLE) is available earlier in the life of the perl script called.  ie, at perl "compile-time".  a --pugs command line argument tends to get processed later.  to support --pugs, pugs-p5 currently wraps the 'use PIL::Run::everything' in a string eval, to delay it.  which is fine, if a bit ugly.  pilrun is currently trying to run as early as possible so the p6 setup is 

[14:46] <putter> available early, and can be used interchangably with p5.

[14:47] <autrijus> stevan: oh, he is the House author but it's not House

[14:47] <putter> re $job interference... just as I get a lot of it... :( ah well.

[14:47] <autrijus> house was too monolithic... he is demoing a micro kernel, of all things, in haskell

[14:47] <putter> autrijus: thanks

[14:48] <autrijus> putter: thank _you_... we dreamed of ./pugs -CPerl5 not even one month ago

[14:48] <putter> gaal: oh, but --pugs has priority.  that can immediately used for both pil2js and pugs-p5, so some of the "pumbing" through util can be removed.

[14:48] <autrijus> and just while I was away it's shaping up real good

[14:48] <autrijus> -BPerl5, even.

[14:48] <autrijus> I'm running out of battery -- be back in 12 minutes

[14:53] *** xinming_Beijing is now known as xinming

[14:54] <putter> strawman proposal: now that pugs-as-haskell is forking off perl backend helper programs, the next step seems to be setting up to permit movement towards unification.  so rather than teaching Main.hs to drop -B js/perl5, and then --repl (or some such - eval files and _then_ become interactive), and ... whatever else, perhaps Main.hs should call a single helper, which can drop -B, etc.

[14:55] <putter> If it was just -B, this would be silly.  and the list of other candidates is not large, so it's not a "no doubt" right thing.  so... thoughts?

[14:56] <putter> s/movement towards unification/movement towards backend unification/

[14:56] <stevan> autrijus: ping me when you are back, I would like to talk MM2 integration (assuming that is one of your priorities)

[14:56] <putter> hi stevan!

[14:56] <stevan> hey putter, how goes things

[14:58] <Jooon> autrijus: aha, batteries! I knew you were on something other than normal food

[15:01] <putter> I started down a path of source filtering simple p6 class/etc and sub/etc code into mm2 calls.  but I think the right thing is to instead preprocess it, to decorate it and avoid information loss, and then hand it to p6.  and grovel over the resulting pil to figure out what happened.  eg, massage "is Foo;" into "is Foo; method fake_is_Foo () {}".  fake... survives -C Perl5, where "is" doesn't.  it's a pain, but upside is we get concise p

[15:01] <putter> ilrun oo description, no more PrimP5, and user oo works(!)(modulo pugsbugs).

[15:01] <putter> s/hand it to p6/hand it to pugs/

[15:03] <putter> oh yes, question: MM:Pure can deal with native things - ARRAY, etc.  any thoughts on blending that with mm2?  so one can have the equivalent of ARRAY does Array, and unboxed ARRAY's suddenly work?

[15:06] <putter> stevan: ? ;)

[15:07] <autrijus> rehi

[15:08] <autrijus> putter: it makes sense, although I agree not with urgency. decoration is good.

[15:08] <autrijus> stevan: MM2 is definitely the priority

[15:09] <putter> the motivation for going in a more p6 approach is it concentrates things (currently an object's p5 and p6 are in three+ different places).  and simplifies them.  currently, we're seen a lot of "works locally, but not globally" kinds of bugs.

[15:10] <autrijus> nodnod.

[15:12] <stevan> autrijus: so what can I do to help on that?

[15:12] <stevan> I can start documenting details if you want

[15:13] <stevan> or I can write some of this in Perl 6 if that would help

[15:13] <autrijus> actually, help migrating pilrun to mm2 and highlight incompatibility would help a lot too

[15:13] <autrijus> since I think I have a fairly good idea of mm1

[15:13] <stevan> k

[15:14] <autrijus> and also then we get identical semantics for free for -BPerl5 and native core

[15:14] <autrijus> which I'm feeling is getting more important each day

[15:15] <Limbic_Region> autrijus - are you aware of Dan Sugalski's blog?

[15:16] <autrijus> you mean his fork? yes

[15:16] <stevan> I am wondering actually how the MM should fit with the runtime

[15:16] <Limbic_Region> salutations all btw

[15:16] <Limbic_Region> no - his blog

[15:16] <Limbic_Region> where he has been discussing his fork

[15:16] <autrijus> yes and yes.

[15:16] <Limbic_Region> figured you might be midly interested in it if you didn't already know

[15:17] <autrijus> nod. I'll be interested iff I see code.

[15:17] <autrijus> before that it's silently ignored :)

[15:17] <putter> stevan: any thoughts on getting "ARRAY does Array"?  the fake-pil2 approach get's a bit less attractive if that's not possible.

[15:18] <stevan> putter: I think maybe you, me and autrijus (fglock and iblech if they are around) need to discuss how the MM integrates with the runtime

[15:18] <putter> re "how the MM should fit with the runtime", any particular puzzles?

[15:18] <stevan> in particular when the MM takes over

[15:18] <stevan> the MM requires certain things to exist

[15:18] <autrijus> I can think of two places; one when class composition takes place (INIT time)

[15:18] <stevan> but the runtime wants these same things accesible via the MM

[15:19] <autrijus> and one when any invocation whatsoever happens

[15:19] <putter> what's an example of such a thing

[15:19] <stevan> autrijus: but what about packages, and such

[15:19] <stevan> how do they integrate?

[15:20] <stevan> they are defined in the MM,.. are they also in the runtime?

[15:20] * nothingmuch doesn't unload the blondie/macro talk yet... #perl6 seems to pleasantly busy ;-)

[15:20] <autrijus> stevan: MM mediates access to  p6 packages I'd think

[15:20] <stevan> ok

[15:20] <autrijus> how each runtime instantiate the primitive package-storage-things are their freedom

[15:20] <autrijus> but the API is part of MM I'd say

[15:21] <putter> stevan, so what's wrong with the "current scheme but with p6_lookup and method/etc assignment redirected to associated mm2 pkg object"?

[15:21] <stevan> autrijus: if the runtime provides hashes,.. they dont need to do anything else for package/namespace stuff

[15:21] <Limbic_Region> question WRT MMD - in p6 you can have a sub and a method with the same name since they are distinguished using sub/method keywords.  Additionally, each sub/method can have multiple variations based off signature right - so making a OO/imperative module is "too easy" right?

[15:21] <autrijus> stevan: I'm sure we can assume the runtime will provide flat dictionaries, extensible lists, strings and numbers.

[15:21] <stevan> putter: what is largely what I am thinking (I think)

[15:21] <nothingmuch> Limbic_Region: i think that generally the answer is yes

[15:22] <autrijus> Limbic_Region: a functional module is also too easy.

[15:22] <stevan> autrijus: what about functions?

[15:22] <stevan> autrijus: nested dictionaries are nice too

[15:22] <autrijus> oh, sure, maps and seqs needs to nest

[15:22] <svnbot6> r7146 | iblech++ | * PIL2JS: jspugs.pl: Accept same commandline-options as runjs.pl does (most

[15:22] <svnbot6> r7146 | iblech++ |   importantly --pugs=/path/to/pugs).

[15:22] <svnbot6> r7146 | iblech++ | * Main: Give --pugs=$*EXECUTABLE_NAME to runjs.pl so

[15:22] <svnbot6> r7146 | iblech++ |   /path/to/my/other/pugs/version -BJS doesn't call some other pugs in $PATH.

[15:22] <svnbot6> r7146 | iblech++ | * Main: Also repaired pugs -BJS, which should start jspugs.pl.

[15:22] <autrijus> I think we also want first-class function pointers, if not downright closures.

[15:22] <stevan> or at least some kind of dict reference which I can put into the dictionary

[15:22] <autrijus> I don't see a problem of wanting closures.

[15:23] <stevan> closures++

[15:23] <Limbic_Region> autrijus - I think mixing more than 2 paradigms in the same module is asking for trouble - but it would be less easy since there would be no way to distinguish between the functional subs and the imperative subs without adopting a naming convention

[15:23] <autrijus> since the lambda-lifting is well understood for runtimes without closures

[15:23] <stevan> if I have closures, I can make methods on my own

[15:23] <autrijus> Limbic_Region: indeed indeed. but that's a cultural issue

[15:23] <autrijus> stevan: I think you have closures.

[15:23] <nothingmuch> Limbic_Region: they can't be called the same way though

[15:23] <stevan> it would nice if the runtime provided,.. but not absolutlely needed

[15:23] <Limbic_Region> nothingmuch - what is the "they" in that statement?

[15:23] <nothingmuch> functional is a superset of imperative

[15:23] <autrijus> since it's so easy to fake closures nowadays

[15:24] <autrijus> and p6 needs closures anyway

[15:24] <nothingmuch> so 'subroutines' are foo(...)

[15:24] <Limbic_Region> functional subs and imperative subs would be called in the exact same way - methods would differ

[15:24] <nothingmuch> methods need to be called on an object

[15:24] <Limbic_Region> of course - if you are creative enough - all the functional subs would have a different signature

[15:24] <nothingmuch> you need to say exactly what class to search through

[15:24] <nothingmuch> in that sense if you have a module with 'sub foo' and 'method foo'

[15:24] <stevan> autrijus: so I have (in p5 terms) HASH, ARRAY, SCALAR, and CODE

[15:24] <autrijus> aye

[15:25] <autrijus> but not neccessarily REF

[15:25] <nothingmuch> then the method will be called when you are looking for a code chunk with the name 'foo' WRT a method invocation on an object

[15:25] <stevan> autrijus: okay, thats all MM2 uses (except for the magic)

[15:25] <nothingmuch> and the sub foo will be called otherwise

[15:25] <autrijus> that would be good.

[15:25] <nothingmuch> unlike perl 5 in that respect

[15:25] <stevan> autrijus: what do you mean by no REF

[15:25] <Limbic_Region> nothingmuch - I understand that - my issue isn't with methods and sub separation

[15:25] <autrijus> stevan: references to references and explicit dereferencing/blessing semantics ala perl5

[15:25] <stevan> ah

[15:26] <nothingmuch> then i don't see the issue... please re-explain, Limbic_Region 

[15:26] <stevan> autrijus: I think I can avoid that (for the most part)

[15:26] <autrijus> the REF-tagged-with-package semantic is somewhat preculiar to perl5

[15:26] <Limbic_Region> I was commenting on how nice/easy it will be to have OO/imperative or OO/functional modules in p6

[15:26] <autrijus> and it's fine to use it in the p5 magic/sugar

[15:26] <Limbic_Region> since they are distinguished with keywords and signatures using MMD

[15:26] <autrijus> but I thought the idea of MM2 is you avoided that

[15:26] <autrijus> so it should be fine

[15:26] <nothingmuch> ah

[15:27] <stevan> autrijus: that part if no criticial, it is only to make something easier

[15:27] <Limbic_Region> autrijus mentioned that it would also be easy to add functional to the mix (as originally I didn't include it)

[15:27] <stevan> could be removed I think

[15:27] <autrijus> stevan: s/removed/moved aside/

[15:27] <stevan> yes

[15:27] <Limbic_Region> I said that having 3 paradigms in one module was asking for trouble

[15:27] <stevan> autrijus: I only rely on that in one place,.. which is to make add_method simpler

[15:27] <Limbic_Region> as you would likely have to adopt a naming convention to distinguish between the functional and imperative

[15:27] <Limbic_Region> because you couldn't rely on the signatures always being different

[15:27] <autrijus> stevan: that totally works then

[15:27] <stevan> so that it puts class methods and private methods and such in to the right tables

[15:28] <autrijus> k

[15:28] <autrijus> where in the src?

[15:28] <stevan> perl5/Perl6-MetaModel2.0

[15:28] <autrijus> er I mean where in it

[15:28] <stevan> one sec,.. looking

[15:28] <autrijus> stevan: the plan is that during the next few days I'll releng toward 6.2.10

[15:28] <autrijus> and then focus on the .28.0 part which is MM2

[15:28] <autrijus> and try to get it out around eurooscon

[15:29] <stevan> autrijus: see gnosis.pl for the method "branch-by-type" 

[15:29] <nothingmuch> autrijus: please give me a two line explanation on what the diff between pretty printing and AG is?

[15:29] <autrijus> nothingmuch: AG propagates upwards.

[15:29] <autrijus> as well as downwards.

[15:29] <nothingmuch> oh, i see

[15:29] <autrijus> and no matter how much propagation you have, it only uses one (or, rather, minimal) pass

[15:30] <stevan> autrijus: a little more in metamorph.pl too.,.. basically anytime I use blessed() I am checking that 

[15:30] <putter> if swapping mm2 for mm1 isnt expected to be too painful, I'd suggest making the transition now.  it's not like there is an client expectation for -B perl5.

[15:30] <autrijus> whereas using visitor pattern you need to do it over +Inf passes

[15:30] <nothingmuch> is /me right in guessing that AG is a superset of prettyprinting?

[15:30] <autrijus> nothingmuch: AG makes prettyprinting very much trivial.

[15:30] <autrijus> so yes, but the superset is very super.

[15:30] <nothingmuch> s/prettyprinting/pretty printer combination stuff/?

[15:30] <nothingmuch> woot

[15:30] <nothingmuch> i'm using them for Pesto ;-)

[15:30] <stevan> putter: the pain swapping MM1 to MM2 will be in dealing with class objects

[15:30] <stevan> they have changed

[15:31] <stevan> they are not tied to p5 packages anymore,.. and there is no ->meta anynore

[15:31] <stevan> .meta is implemented in the sugar

[15:31] <nothingmuch> autrijus: thank you for introducing me to AG

[15:32] <putter> I'm not sure that's significant from the pilrun/P6::V/C perspective... checking...

[15:32] <autrijus> nothingmuch: np :) thank Wouter Swierstra for introducing it to me :)

[15:32] <autrijus> and $Larry and allison

[15:32] * Limbic_Region waits for the scandelous photos to emerge and for nothingmuch to blame his sordid affair with AG on autrijus

[15:32] <stevan> putter: I think we might want to removed the MM stuff in P6::V/C though

[15:32] <nothingmuch> stevan: that's the secret tree transformation stuff?

[15:32] <stevan> putter: it might be best to wrap it afterwards 

[15:32] <nothingmuch> woot!

[15:32] <stevan> nothingmuch: ??

[15:33] <nothingmuch> autrijus: so what were your thoughts on AG/parrot?

[15:33] <nothingmuch> emitting PIR?

[15:33] <nothingmuch> or implementing AG in PIR?

[15:34] <autrijus> nothingmuch: I think implementing AG in PIR is troublesome.

[15:34] <stevan> putter: so my thought is that we supply the needed primatives for the MM, and the post-bootstrap they are wrapped in the MM to make them accessible to the MM world

[15:34] <autrijus> emitting PIR-Tree is the correct idea

[15:34] <nothingmuch> okay

[15:34] <autrijus> so nothing we can't do with UUAG

[15:34] <autrijus> and all there's left is to replace the primitive rewriting logic from hs to p6

[15:35] <autrijus> which is considerably easier -- much much easier -- than redoing the compiler monad and gadt in p6.

[15:35] <autrijus> that's the main attraction of AG to me

[15:35] <putter> "primitives need by the mm" are what?

[15:35] <nothingmuch> oh, yyou want EHC to be written in perl?

[15:35] <stevan> putter: hashes, arrays, functions (closures) and scalars

[15:35] <nothingmuch> you're sick ;-)

[15:36] <autrijus> not sicker than I usually am

[15:36] <autrijus> but yes :)

[15:36] <autrijus> or preferably, _translated_

[15:36] <nothingmuch> well, in that case let me retoret

[15:36] <nothingmuch> yes, ofcourse

[15:36] <nothingmuch> stevan and I have been privately discussing macros in blondie

[15:36] <autrijus> good

[15:37] <stevan> nothingmuch: you told me that was our secret *weep*

[15:37] <nothingmuch> shutup, bitch

[15:37] <autrijus> eww

[15:37] <nothingmuch> ride leaving

[15:37] * nothingmuch will brief later

[15:37] <nothingmuch> but think:

[15:37] <autrijus> sure. I'm going to ICFP reception in an hour

[15:37] <autrijus> be back in two

[15:37] <nothingmuch> macro that takes a Seq and makes a [AST]

[15:37] <autrijus> Seq of what?

[15:37] <nothingmuch> Seq of nodes

[15:38] <putter> stevan: I'm confused.  how are the mm2 tests currently working, if there are unimplemented dependencies?

[15:38] <stevan> ASTs?

[15:38] <nothingmuch> seq of ASTs

[15:38] <nothingmuch> and a macro which takes a [AST] and makes a seq

[15:38] <autrijus> how is Seq of AST different from [AST]?

[15:38] <nothingmuch> seq2list map (macro) list2seq(... some seq ...)

[15:38] <stevan> putter: chaos.pl provides what I need,.. along with p5 (which is the current "host"/runtime)

[15:38] <nothingmuch> type safe macros

[15:38] <nothingmuch> that are just functions

[15:38] <nothingmuch> they aren't really different

[15:38] <nothingmuch> later on this

[15:38] <nothingmuch> *poof*

[15:39] * stevan was questioning the sanity of this actually,.. but.,..

[15:39] <putter> hmm... putter goes off to do an experiment...

[15:40] <autrijus> I'll be right back

[15:41] <gaal> putter: sure; but i wanted to avoid polluting the environment of every process started by pugs. what i was thinking of is letting pugs know its $^X as soon as it can, in fact soon enough for helpers spawned by -B to have that passed as an explicit parameter.

[15:45] <Juerd> I hope my latest message will be as well received as the previous

[15:45] <putter> gaal: iblech just now added --pugs= support, and -B tolerance to jspugs.  so I think we are all set for now.

[15:45] <autrijus> back

[15:47] <putter> stevan: something seems to be require/use'ing "lib/genesis.pm" rather than "genesis.pm".  maybe.

[15:48] <autrijus> ./lib/Perl6/MetaModel.pm:    require "lib/genesis.pl";

[15:49] <stevan> putter: yes, it should probably not have the lib in there

[15:50] <autrijus> also, what's lost if we name them as Perl6::MetaModel::Genesis etc?

[15:50] <stevan> let @INC deal with it

[15:50] <autrijus> note they are still namespaceless

[15:50] <autrijus> just so we can install them to normal sitelib

[15:51] <autrijus> (but I don't have a real problem of polluting the sitelib root with chaos.pl -- it just seems neater to follow the hier)

[15:53] <autrijus> (is this a very bad idea?)

[15:54] <stevan> no

[15:54] <stevan> that would work

[15:56] <putter> has ::SELF changed ?

[15:56] <stevan> one sec,.. call with $client

[15:57] <putter> ah, $::SELF

[15:58] <autrijus> okay, I'm going to ICFP reception

[15:58] <autrijus> be back in a couple hours

[15:59] <putter> &

[15:59] <putter> Can't locate object method "add_subclass" via package "Perl6::Object" (perhaps you forgot to load "Perl6::Object"?) at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-MetaModel2.0/lib/metamorph.pl line 116.

[16:00] <stevan> putter: no Perl6::Object anymore

[16:00] <stevan> that is in $::Object

[16:01] <putter> right

[16:01] <putter> tnx

[16:01] <stevan> no more strings for class names

[16:01] <gaal> putter: but what populates the command line with the correct values?

[16:04] <nothingmuch> so anyway

[16:04] <nothingmuch> essentially Seq is just 'type Seq = [AST]'

[16:04] <nothingmuch> and seq2list = id

[16:04] <stevan> nothingmuch: autrijus is a the ICFP reception

[16:04] <nothingmuch> and list2seq=id

[16:04] <nothingmuch> oh

[16:04] <nothingmuch> actually, bbiab too

[16:07] <putter> gaal: i don't understand...

[16:07] <putter> Can't locate object method "add_subclass" via package "Code" (perhaps you forgot to load "Code"?) at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-MetaModel2.0/lib/metamorph.pl line 116.

[16:08] <stevan> what is Code?

[16:08] <gaal> putter: pugs spawns "jspugs --pugs /home/putter/src/pugs/pugs"

[16:08] <putter> perl5/Perl6-Value/lib/Perl6/Code.pm

[16:08] <gaal> how did it know that was the path to use?

[16:08] <stevan> putter: I dont use that in the code

[16:08] <gaal> but: i must go now, back in ~40min

[16:09] <putter> gaal: don't know... iblech's work...

[16:09] <stevan> putter: you are trying to subclass it?

[16:09] <gaal> ah, he did the pugs side of this too? great :) iblech++

[16:09] <putter> the same file contains some other classes which subclass it

[16:09] <gaal> &

[16:09] <putter> iblech++ indeed

[16:09] <stevan> putter: what file?

[16:09] <putter> perl5/Perl6-Value/lib/Perl6/Code.pm

[16:10] <putter> &

[16:10] <stevan> putter: you need to assign the class to something

[16:11] <stevan> so class 'Code' => { ... } becomes 

[16:11] <stevan> my $Code = class 'Code' => { ... }

[16:11] <stevan> and then you pass is => [ $Code] 

[16:11] <putter> what was the effect of the mm1 construct - ie, what was assigned by it?

[16:13] <stevan> putter: MM1 created a "Code" package, which held a reference to the metaclass(Code) in it 

[16:13] <stevan> MM2 now returns a class(Code) which is the same as the old metaclass(Code)

[16:13] <stevan> this decouples the MM from p5 packages

[16:14] <putter> what was the reference named?

[16:14] <stevan> MM2 uses one package,.. called Dispachable,.. which just handles method dispatch

[16:14] <stevan> $Code::META

[16:14] <stevan> I stored it as a package variable

[16:14] <stevan> but to be honest,.. you should not be using the class() macros 

[16:14] <stevan> you should be creating the class manually

[16:15] <putter> ok, I'm going to do  package Code; our $META = class 'Code' ...    for a minimal-change "get it working again first" hack.

[16:15] <stevan> my $Code = $::Class->new('$:name' => 'Code')

[16:15] <stevan> putter: wont work

[16:15] <stevan> to many other things have changed too 

[16:15] <stevan> I am not sure there is an "easy" transition here

[16:15] <putter> I realize the mm uses of 'Code' will have to be changed to $Code::META.

[16:16] <stevan> MM1 just did meta($instance_of_Code)

[16:16] <stevan> MM1 just doe $Code

[16:16] <putter> understood

[16:16] <stevan> old way: meta($iCode)->add_method()

[16:16] <stevan> new way,.. $Code->add_method()

[16:17] <putter> will the class() macro's still work?

[16:17] <stevan> not the MM1 ones

[16:17] <stevan> they are different in MM2

[16:18] <stevan> and really are not meant for anything other than to make testing easier 

[16:18] <putter> "making testing easier" is what this is! :)

[16:18] <putter> how different?

[16:18] <stevan> putter: see t/10_Point.t and t/10_Point_MM.t for examples

[16:20] <putter> I dont see a class macro in t/10_Point.t

[16:20] <stevan> putter: attr is now "attributes"

[16:20] <stevan> and we have class_attributes instead of an class { attr => ... }

[16:20] <stevan> same with instance

[16:20] <stevan> we have "methods", "submethods" and "class_methods" now 

[16:20] <stevan> does is the same

[16:20] <stevan> and "is" is the same

[16:20] <stevan> putter: yup, that one doesnt use it

[16:20] <stevan> but t/10_Point_MM.t does

[16:21] <stevan> you should be writing code which looks like t/10_Point.t

[16:21] <stevan> not t/10_Point_MM.t

[16:21] <stevan> the class() macro should not be considered part of the metamodel

[16:22] <putter> stevan: yes, the code should eventually look like t//10_Point_MM.t.  and perhaps the right thing to do now is to stop, and rewrite all of Perl6::V/C from scratch.  But we have "running code".  And I'd hate to lose that, just because some syntax changed.

[16:23] <stevan> putter: no need to stop and start from scratch

[16:23] <putter> well, extensively edit? :)

[16:23] <stevan> yes, to a certain degree

[16:23] <stevan> my concern is that we have a number of MM classes in the core

[16:23] <stevan> the core needs to be MM free in order to bootstrap the MM

[16:24] <stevan> once the MM is bootstrapped,.. everything should be built on top of that

[16:24] <putter> I'd rather do a class() compatibility macro.  if that's not easy, then neither will the edit be (maybe).

[16:24] <putter> ok, perhaps I'm missing something.

[16:25] <stevan> let me ask a few questions re: PIL-Run

[16:25] <stevan> 1) where are P6::V/C used?

[16:25] <putter> is mm2 simply not swappable for mm1 in P6::V/C?  has mm2 introduced conflicts we can't deal with?

[16:25] <stevan> s/where/where and how/

[16:26] <stevan> putter: no, we can move P6::V/C over I think

[16:26] <stevan> but their "usage" might be an issue

[16:26] <putter> mostly ApiX.pm, ...(irc preempts)

[16:27] <putter> re "P6::V/C", err, so mm2 already provides Code, Array, Hash, Scalar objects?

[16:27] <stevan> putter: no, MM2 expects them to exist already

[16:27] <stevan> for it to create itself from

[16:27] <putter> Num, Int, Str, etc

[16:27] <stevan> MM1 was not self-bootstrapping (it was kind of,.. but not really)

[16:27] <stevan> MM2 is 

[16:27] <putter> so what do you mean move P6::V/C over?  puzzled

[16:28] <stevan> one moment,.. let me look at APIX

[16:28] <fglock> hi stevan, putter

[16:28] <putter> since it looks like class() format changed, the key question is can one create a mm1 class() compatability macro.  if so, we should be all set.  if not, there are semantic changes I dont understand yet.

[16:29] <putter> hi fglock :)

[16:29] <putter> currently trying to bang P6::V/C into mm2.  still not clear what that requires.

[16:29] <stevan> hey fglock 

[16:29] <stevan> putter: the key problem is in how the class objects produced by the class() macro are used

[16:30] <putter> looks like class() format changed.  thinking about adding a backwards compat version.

[16:30] <stevan> since they are no longer tied to p5 packages

[16:30] * stevan has to eat some lunch.. bbiab

[16:31] <putter> if it is merely a namespace, "how do I refer to this object" issue, then that should just be a n (where n is the number of classes) line change in P6::V/C, and a few localized tweaks in pilrun.

[16:31] <stevan> parting thought: P6:V/C need not be implemented with the MM for use in ApiX

[16:31] <putter> ie, 'Foo' becomes $Foo::MUMBLE.

[16:31] <stevan> putter: can P6::V/C be just primative elements of the runtime?

[16:32] <fglock> there are primitive classes already - but the wrapper is big

[16:32] <stevan> putter: but MM2 has it's own Package type which will implement p6 Package stuff

[16:32] <putter> that starts to look like throwing it away.  has the underlying semantics of class() changed incompatibly?

[16:32] <putter> or just the surface syntax?

[16:32] <stevan> putter: both

[16:32] <putter> since pilrun currently doesnt have a concept of pkg, that's not a problem.  simply a naming issue.

[16:33] <stevan> class() was always a quick and dirty macro for the underlying stuff

[16:33] <putter> stevan: the key question is:

[16:33] <stevan> putter, fglock: do P6::V/C need to be implemented with the MM?

[16:34] <fglock> stevan: P6::V/C uses perl5 classes, wrapped into MM

[16:34] <stevan> maybe we should unwrap them from the MM, and use the pure p5 for now

[16:34] <putter> can a backward compable class() macro be written.  if yes, then we're golden.  if not, ie, something really non-trivial changed, then we're obviously, necessarily, looking at rewrite.  no?

[16:34] <fglock> Array wraps Perl6::Container::Array

[16:34] <stevan> then we build the MM on top of them

[16:35] <stevan> fglock: so if we unwrap it now,.. then the MM bootstrapp can wrap it post-bootstrapping

[16:35] <putter> stevan: before I waste time trying, is there any reason a mm1-compatible class() cant be written on mm2?

[16:35] <stevan> putter: many many non-trivial changes have happened,.. MM 1.0 was largely "wrong"

[16:36] <putter> could you give me an example of a non-trivial change?

[16:36] <stevan> putter: the compatibilty macro can be written... however, all the code which uses any MM classes will still need to be changed  

[16:36] <stevan> putter:  there are no meta-classes

[16:36] <stevan> there are class instances

[16:37] <stevan> and there are instances of those classes

[16:37] <stevan> .meta is just sugar now

[16:37] <putter> right.  but that should just be order-10 lines... no?

[16:37] <putter> there is 1 (2?) uses of ::meta in the whole thing

[16:37] <stevan> in what whole thing?

[16:37] <stevan> ApiX?

[16:38] <putter> (aside from warn()ings)

[16:38] <putter> P6::V/C + PIL-Run

[16:38] * stevan really has to eat some lunch,.. bbiab

[16:38] <putter> ok, enjoy.  thanks.

[16:39] <fglock> since mm1 classes are p5 classes, we could just re-wrap them in mm2 (that is, use both at the same time) - is this possible?

[16:40] <putter> hum?  P6V/C have a lot of class() calls which no longer work...

[16:42] <fglock> ah ok - CLASS is a "global" sub

[16:42] <putter> it looks more like a "rename the hash keys, and generate accessors" problem than a "everything must change" one, but I'm not sure.

[16:45] <putter> for naming, we can just replace is => [ 'Foo' ] with is => [ $Foo::MUMBLE ], have the class macro do $Foo::MUMBLE = Class->new...;  fix p6_new(), and... hmm, there is various code which skipped p6_new and did Int->new('$.unboxed').  so all that loses now.  hmm.  well, if we're creating package Foo;, we can put a new() there too.

[16:46] <putter> but I still dont understand mm2's bootstrapping needs.

[16:48] <pdcawley_> Quick question is 6perl @Larry's mailing list?

[16:52] * Limbic_Region thinks so

[16:52] <Limbic_Region> luqui has mentioned it more than once

[16:55] * nothingmuch has been thinking

[16:55] <nothingmuch> the next thing Blondie is going to get is parametrizable types

[16:55] <nothingmuch> anyway, dinner

[16:56] * Limbic_Region wonders if Blondie knows about nothingmuch's scandalous affair with AG

[16:57] <stevan> Limbic_Region: Blondie is easy, so she doesn't mind

[16:57] <stevan> Blondie will just move on to the next lambdacamel

[16:58] <stevan> she knew of nothingmuch 's reputation before hand anyway

[16:59] * Limbic_Region is going to have to be careful about talking of his love affair with Perl as there is a high probability that his first born daughter will be named Pearl

[17:35] <putter> ok, P6V/C is compiling... working through pilrun issues...

[17:45] <putter> working through the prelude...

[17:45] <nothingmuch> p6v/c?

[17:48] <fglock> nothingmuch: perl5/Perl6-Container, perl5/Perl6-Value

[17:49] <nothingmuch> ah

[17:49] <putter> steven: ping?

[17:49] <nothingmuch> s/eve/eva/

[17:50] <putter> wondering what the mm2 equivalent of attr => [ [... build => sub{...} ]] is

[17:55] <putter> fglock: any idea?

[17:56] <fglock> looking

[17:59] <putter> since its only Scalar/Array/Hash, I'm tempted to edit them into BUILD's

[18:00] <putter> ha!  there is never more than one.  so it's a BUILD.

[18:00] <fglock> putter: see perl5/Perl6-MetaModel2.0/t/33_BUILD.t

[18:02] <putter> stevan: does ->add_method() work for BUILD?

[18:06] <putter> appears to

[18:15] <putter> stevan: ping?

[18:16] <putter> oh, doh.

[18:18] <putter> Bad instance (FORCE=SCALAR(0xac3d50)) ?

[18:19] <putter> FORCE=SCALAR(0xac3d50) is what ::SELF is bound to during the BUILD call.  thoughts?

[18:20] <putter> ok, I'm going to pause until stevan/someone can comment on BUILD.

[18:20] <putter> it's not clear yet that this exercise will converge, so I'll not commit it just yet.

[18:20] <putter> fglock: unless you wanted to play?

[18:24] <putter> pilrun relies heavily on Scalar and Scalar's  $:cell->store.  but since $:cell isnt getting initialized... nothing works yet.

[18:35] <stevan> putter: no automatic initializer anymore

[18:35] <stevan> putter: pong

[18:36] <stevan> the FORCE stuff should nto be happening though

[18:36] <putter> hi stevan

[18:36] <stevan> are you passing in BUILD as a submethod?

[18:36] <stevan> submethods => { BUILD => sub { ... }}

[18:36] <stevan> add_method still works

[18:36] <stevan> most of the API is still the same

[18:36] <stevan> just howyou use things has changed

[18:36] <putter> ->add_method('BUILD'=>...)

[18:37] <putter> MM->add_method('BUILD' => ::make_method(sub{

[18:37] <putter> 				shift;

[18:37] <putter> 				_($a => $build->());

[18:37] <putter> err, $MM.

[18:38] <stevan> MM->add_method('BUILD' => ::make_submethod(sub { ... });

[18:38] <putter> oo.  trying...

[18:38] <putter> is DESTROY also a submethod?

[18:38] <stevan> uhm

[18:39] <stevan> actually BUILD should not have to be a submethod

[18:39] <stevan> I should fix that

[18:39] <stevan> but in general it should be,... but the MM should not enforce this

[18:40] <putter> woot.  moving on from initialization to (failing) method invocation...

[18:40] <stevan> progress !!

[18:41] * geoffb fades in from the aether

[18:41] <geoffb> Hey, MM2 merge! W00t!  Good on ya, putter++ and stevan++

[18:42] <stevan> dduncan: you will enjoy this http://private.himi.org/%7Egwalla/flash/xmen.swf

[18:42] <stevan> as will any other XMen fans

[18:43] <stevan> ok putter so, why the failing method invocation? 

[18:43] <putter> hmm.  Array uses AUTOLOAD.  eep.  ok, how does one AUTOLOAD?

[18:44] <stevan> *cough* uhm... ah,.. hmm... autowhat?

[18:44] <putter> AUTOMETH? ;)

[18:44] * stevan scribbles up a TODO list

[18:44] * putter lol

[18:44] <stevan> yes, i was sort of punting on those

[18:44] * putter a lot

[18:44] <stevan> I will put that in for yah

[18:44] <putter> ah.  ok.  let's see...

[18:45] <stevan> the attr initalizers though I think need to be in the sugar

[18:45] <stevan> they dont make sense in the MM

[18:45] * stevan dashes up the stairs for more coffee, be right back

[18:46] * fglock is just lurking today

[18:47] * stevan should be $work-ing, but just can't muster the strength to force himself too

[18:47] * putter should be job searching.  ha.

[18:48] * geoffb resembles stevan's remark

[18:48] <stevan> ok, putter I will implement AUTOMETH, and maybe the AUTOSCALAR, etc stuff too

[18:48] <putter> attr intializers are in.  though everything is rw because I didnt want to deal.

[18:49] <putter> ok.

[18:50] <autrijus> greetings

[18:50] <autrijus> I was abducted by aliens and survived!

[18:51] <nothingmuch> ?

[18:51] <geoffb> Hopefully the probes didn't leave anything behind

[18:51] <geoffb> autrijus, congrats on $job relief

[18:51] * nothingmuch thinks an antenna that writes haskell, inside autrijus's ass might be pretty useful

[18:51] <dduncan> stevan, yes, thanks for sharing that ... incidentally, the creator of that one has made a variety of others too

[18:52] <nothingmuch> just be nice to the cows with it, okay autrijus?

[18:52] <geoffb> nothingmuch, eww and lol

[18:52] <autrijus> lol

[18:52] <autrijus> no, the alien is simon pj

[18:52] <autrijus> and I've been abducted into hacking record syntax and GADTs into GHC

[18:52] <autrijus> and it worked :D

[18:52] <putter> fglock: :)

[18:52] <geoffb> yay

[18:52] <nothingmuch> that sounds spooky

[18:53] <geoffb> oh, nothingmuch: if you hadn't already found it, this online edition of Brodie's Starting Forth actually has working links: http://home.iae.nl/users/mhx/sf.html

[18:53] <geoffb> (The first one I came across didn't.)

[18:53] <autrijus> nothingmuch: data Term a where IsZero { num :: Term Int } :: Term Bool

[18:54] <autrijus> has certain very good properties. but I digress

[18:54] <geoffb> We all do.  At least the digressions here tend to be technical . . . :-)

[18:55] <autrijus> ...but sometimes they involve cows instead

[18:55] <geoffb> Moooo

[18:55] <nothingmuch> wait, that sounds rather trivial

[18:56] <nothingmuch> geoffb: thanks

[18:56] <nothingmuch> didn't GADTs support this stuff already?

[18:56] <geoffb> nothingmuch, np

[18:56] <nothingmuch> or was GADT stuff a subset of haskell?

[18:56] <autrijus> GADT only supported normal prefix constructors

[18:56] <autrijus> the reason having to do with the hard-to-typeness for record selectors in GADT form.

[18:57] <autrijus> data D a where A { x :: a } :: D Int     B { x :: a } :: D String

[18:57] <autrijus> the 'x' can't be typed

[18:59] <putter> stevan: "2+2" on MM2 works :)

[19:00] <nothingmuch> ah

[19:00] <geoffb> putter: one small step for PIL-RUN . . .

[19:00] <putter> ;)

[19:02] <autrijus> wow, that was quick :)

[19:02] * autrijus backlogeth

[19:08] <putter> ok, I'm in wait state for AUTOMETH.  bbiab.

[19:15] <stevan> putter++

[19:16] * stevan searches for appropriate MM hacking music

[19:19] <stevan> putter: you should read this re-AUTOMETH, etc http://search.cpan.org/~ingy/Perl6-Bible/lib/Perl6/Bible/S10.pod

[19:20] <putter> reading...

[19:21] <putter> eeep.  though I like "There is still an AUTOLOAD hook that behaves as in Perl 5." ;)

[19:22] <putter> AUTOMETH looks like a bit too much extra stuff for this "swap MM1 for MM2" exercise...

[19:23] <putter> could I change that request to AUTOLOAD? :)

[19:23] <stevan> yeah I will do that

[19:23] <stevan> AUTOMETH is not speced enough IMHO

[19:25] <fglock> autoload is used as an "auto-dereferencer" - it can be substituted for a $x->fetch->$method

[19:25] <putter> certainly not for an afternoon quicky.

[19:25] <putter> hmm...

[19:26] <fglock> in Scalar, that is

[19:26] <putter> err, what about AUTOLOAD in Array

[19:26] <fglock> in Array it is mostly just wrapping calls to Perl6::Container::Array

[19:27] <dduncan> it appears that irc.perl.org is down today ... or I can't connect to it

[19:28] <fglock> AUTOLOAD is also used in Ref - for auto-dereferencing

[19:28] <putter> ~150 lines of wrapping...

[19:28] <putter> :)

[19:28] <stevan> putter, fglock: AUTOMETH and AUTOMETHDEF seem to be weird things,.. and I am not 100% what they are doing/trying to accompish (other than making can() more compatible with AUTOLOAD)

[19:29] <putter> AUTOLOAD would be fine by itself.

[19:29] <stevan> yeah, thats what I am doing

[19:30] <putter> k

[19:31] <fglock> putter: from Array TODO: "# TODO - there are too many methods under AUTOLOAD - upgrade them to real methods"

[19:31] <fglock> :)

[19:31] <putter> :)

[19:32] <fglock> Hash was written later - it has just 4 lines in AUTOLOAd

[19:33] <putter> if stevan encounter's difficulties, we can think about doing that now.  but I'd like to keep the changeset minimal, so there is less ambiguity about what has broken in transition, and what in P6VC+pilrun changes.

[19:44] <stevan> putter: pong

[19:44] <stevan> putter: MM2.0 has AUTOLOAD

[19:44] <stevan> I am not 100% happy with the implementation

[19:45] <stevan> it works like 1.0 did

[19:45] <eric256_> hmmm anyone have a link to the info about Juerds Feather server....if that is still running

[19:45] <stevan> except instead of AUTOLOAD($self), you check $::AUTOLOAD

[19:45] <autrijus> eric256_: it is, because I'm using it to irc

[19:45] <stevan> however I htink I am going to make it stash in the package like it really should

[19:45] <putter> stevan++

[19:45] <stevan> putter++

[19:46] <autrijus> stevan++ putter++

[19:46] <autrijus> (I may drop soon from this by-minute hotel wireless net)

[19:46] <eric256_> i forgot the url to ssh into for it...

[19:46] <autrijus> eric256_: ssh perlcabal.org

[19:46] *** DesreveR is now known as r0nny

[19:47] <eric256_> thanks

[19:47] <svnbot6> r7147 | stevan++ | Perl6::MetaModel 2.0 -

[19:47] <svnbot6> r7147 | stevan++ | * added AUTOLOAD for PIL-Run, works like it did for MM-1.0

[19:47] <eric256_> wanted to play somewhere on pugs but can't get it to compile on my machine...

[19:49] <stevan> putter: fixed,.. now it stashes into the package

[19:49] <stevan> however, it is kinda tricky with class methods vs. instance methods

[19:49] <stevan> FooClass->AUTOLOAD is a different method than $iFoo->AUTOLOAD

[19:50] <stevan> not sure how to approach this properly yet

[19:50] <putter> wooooooooot!   prelude loads w/o obvious problems.   "say 'hi'" works :)

[19:50] <stevan> I am also unsure of how this will work/react if you use next_METHOD too

[19:50] <stevan> putter++

[19:50] <putter> stevan++ fglock++

[19:52] <putter> ok.  I think it's safe to commit to the "try a quick swap of mm1 for mm2" exploration branch.  I'll clean a bit and commit.

[19:52] <svnbot6> r7148 | stevan++ | Perl6-MetaModel 2.0 -

[19:52] <svnbot6> r7148 | stevan++ | * proper our $AUTOLOAD variables, none of this global hackery

[20:00] <putter> oh, drats.  didn't commit fast enough.  :)  r7148 broke it. 

[20:01] <stevan> putter: its a simple change

[20:01] <stevan> the $AUTOLOAD is not in the class's pacakge

[20:01] <stevan> just change $::AUTOLOAD to 

[20:02] <stevan> ::opaque_instance_class($self)->FETCH('$AUTOLOAD')

[20:02] <putter> shudder

[20:02] <putter> ok

[20:02] <stevan> its not that bad

[20:02] <putter> _('$AUTOLOAD') ? :)

[20:02] <stevan> __('$AUTOLOAD)

[20:02] <stevan> 2 _

[20:02] <stevan> for class attributes :)

[20:02] <putter> :) tnx

[20:09] <putter> and it's in.

[20:10] <putter> there is a (in cleanup) Bad dispatcher (undef) at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-MetaModel2.0/lib/chaos.pl line 95 ...  on exit.

[20:10] <svnbot6> r7149 | putter++ | Perl6-Value, Perl6-Container, PIL-Run: Swap in Perl-MetaModel2.0.  Some regressions.  fglock++ stevan++

[20:11] * stevan curses perl's global "cleanup"

[20:11] <stevan> putter: I am actually look into fixing that

[20:11] <stevan> I need to have control over the desctruction order

[20:11] <stevan> I am looking at ogd (http://search.cpan.org/src/ELIZABETH/ogd-0.02/lib/ogd.pm)

[20:13] <putter> fglock: there didn't end up being much change to P6::V/C.  class changed to class1 (defined in Perl6::Value).  Some renames ('Perl::Object', ::SELF, ::CLASS, etc).  But that's about it.

[20:13] <putter> class1 did most of the work.

[20:13] <putter> stevan: ok

[20:15] <putter> hmm, is there something like END which runs before the globals are gced?

[20:16] <stevan> putter: yes, ENDs run in a certain order

[20:16] <stevan> assuming no one else uses END I can probably do the DESTROYing there

[20:16] <stevan> if someone uses END, then there is a trick I can use to insert a last END block using B

[20:18] <putter> err, can pilrun just replace END{} with a global which calls the p6 END hooks when it's DESTROYed? (as long as it can be forced to be destroyed first...)

[20:19] <Juerd> Wow, there's an unbelievably informed post.

[20:20] <putter> basically move p6/mm END to before any p5 END's run, by using early destruction of a global to trigger it.

[20:21] <putter> Juerd: post?

[20:21] <Juerd> p6l

[20:22] <putter> ah

[20:23] <fglock> Juerd: may I have an account in your server?

[20:24] <Juerd> If you request it by sending me an e-mail message requesting it, including your real name

[20:24] <Juerd> This assuming that you're referring to feather

[20:24] <Juerd> If you want an account on any other of by boxes, please contact me during business hours ;)

[20:24] <Juerd> s/by/my/

[20:25] <fglock> oh - it's feather - I'll send the mail, thanks!

[20:26] <Juerd> Oh, and include your preferred user name

[20:29] <eric256_> hey juerd...you might want to edit the message when you login, since it tells people to read /home/juerd/README which isnt' usefull yet.. ;)

[20:30] <Juerd> Or, anymore

[20:30] <Juerd> We should have a wiki

[20:30] <Juerd> Does anyone want to write a Perl 6 wiki?

[20:30] <Juerd> Because if it'll be a wiki, I think it'll have to be written in Perl 6

[20:35] <stevan> putter: hmmm, destroy things is not that simple

[20:35] <stevan> so many references ...

[20:36] <putter> Ok.  Still a number of regressions in pilrun.  Performance is down by something vaguely like 3x.

[20:36] <stevan> yeah, MM2.0 is slower :)

[20:36] <stevan> it just does more

[20:36] <stevan> because it uses less p5 stuff

[20:36] <putter> stevan: re destroy.  doh, yes, of course.  i was fixated on END.

[20:37] <putter> hmm... smokes will now likely take ~2hrs at 1GHz...

[20:38] <stevan> putter:  you could recode some stuff in C if you like :)

[20:38] <putter> ;)

[20:38] <putter> fglock: could you summarize how your unboxed stuff works?

[20:39] <fglock> unboxed just returns the underlying perl5 object or scalar

[20:39] <nothingmuch> omega just posted this on #catalyst... thought I might share: http://img330.imageshack.us/img330/8215/nooblol9em.jpg

[20:39] <putter> stevan: don't tempt me... http://www.vendian.org/mncharity/dir3/inline/illustration/  ;-)   just kidding.

[20:40] <putter> fglock: can p5 scalars be used as p6 objects?

[20:41] <fglock> not sure what you mean - you can tie Scalar to a p5 object, and you can use some kind of autoboxing to promote a perl5 scalar to Scalar

[20:41] <putter> does autoboxing exist now?

[20:41] <eric256_> how do i tell pugs to look in /ext for the Test module?

[20:42] <putter> eric256_: -Imumble ?

[20:42] <eric256_> ok. the help when you do pugs -h says -l is ignored

[20:42] <fglock> looking for an example...

[20:43] <fglock> PrimP5 coerce:as implements autoboxing (kind of)

[20:44] <putter> I noticed Class::Multimethods::Pure has support for ARRAY, HASH, etc.  Prompting daydreams of a p6  Perl5::NativeObject and class Perl5::Array does Array.

[20:46] <putter> Basically I'm wondering if the internals could all return native objects, which only get boxed if needed.

[20:46] <fglock> except for lazyness, Perl 5 arrays would do everything that is needed

[20:46] <pasteling> "stevan" at 67.186.136.119 pasted "Memory Cycle madness in the MM 2.0" (3144 lines, 179K) at http://sial.org/pbot/13320

[20:46] <stevan> putter: the cycles are pretty bad :)

[20:47] <wolverian> dammit, why doesn't my screen(1) refit to the terminal properly anymore?

[20:47] <fglock> putter: Hash keys behave differently. The rules for Scalar are a bit different too

[20:47] <wolverian> this is absurd

[20:47] <putter> perhaps it's just aclimation, but on my box, pilrun has subjectively gone from "a bit slow, but fine"(except for loops) to "slowwwwww".

[20:48] <putter> looking...

[20:48] <stevan> are you using multi methods?

[20:48] <putter> err, what am I looking at ;)

[20:48] <eric256_> using -l just causes pugs to quit

[20:49] <stevan> putter:  the Devel::Cycle report for find_cycle($::Class)

[20:49] <stevan> its unreadable,.. but it shows how impossible destruction would be

[20:49] <putter> re "are you using multi methods?", most of the interface to mm2 is class1 at the top of Perl6/Value.pm.

[20:50] <stevan> ok,.. 

[20:50] <stevan> MM2 is slower,.. but when you use Multimethods,.. its really slow

[20:50] <stevan> but thats because C::MM::Pure is slow on top of MM2.0 being slow

[20:50] <nothingmuch> that's ok... static analysis will save us 

[20:50] <nothingmuch> ;--)

[20:50] <stevan> Blondie to the rescue

[20:51] *** khisanth_ is now known as Khisanth

[20:51] <putter> p6_declare_class and p6_create_instance in ApiX.pm may be the only other place

[20:51] <stevan> putter: I think it might be wise to not use the MM at this level

[20:51] <fglock> putter: but a Perl 6 "dialect" that translated to pure-native Perl 5 would be fast, and probably useful

[20:52] <putter> stevan: ?

[20:52] <stevan> putter, fglock: what would be the impact of removing the MM code from P6::V/C ?

[20:52] <stevan> what is the value of having it use the MM?

[20:52] <stevan> then only p6_declare_class and p6_create_instance would use the MM

[20:53] <stevan> we can then wrap Perl6::Container::Array with the MM post bootstrapping

[20:53] <stevan> and the same with ::hash, etc

[20:53] <stevan> would that make sense? or no?

[20:53] <putter> maybe it's just my rubyness talking, but I expect to be able to overwrite, say, Num's methods...

[20:53] <putter> ;)

[20:53] <stevan> putter: and you will

[20:54] <stevan> because the user-level access will be to a MM object

[20:54] <stevan> but in the base impl it wont

[20:54] <stevan> basically this is like the diff between int and Int

[20:54] <stevan> one is native and controlled by the compiler/runtime, the other is part of the objecct model 

[20:55] <fglock> stevan: how about just delay loading Container and Value?

[20:55] <stevan> don't you need them?

[20:56] <stevan> Contianer and Value are just wrapped by the MM right?

[20:56] <stevan> with native p5 implementations?

[20:56] <fglock> I mean, load order: MM, Container/Value, then Prelude5, the Prelude6

[20:57] <fglock> Container/Value are actually part of the Perl5 prelude

[20:58] <putter> Ok, I'm completely confused again.  What "bootstrapping"?

[21:00] <stevan> putter: the MM is circular,.. Class is an instance of Class

[21:00] <stevan> chicken and the egg problem 

[21:00] <stevan> so at some point you break it

[21:00] <stevan> that is the boostrap

[21:00] <eric256_> don't break the egg!!!

[21:00] <stevan> no,.. the chicken :)

[21:00] * eric256_ apologizes for the outbreak...but couldn't ressist ;)

[21:00] <putter> MM is a black box.  it servers oo stuff.  VC  use it to create some.

[21:01] <putter> I don't see how mm bootstrap is relevant...???

[21:01] <stevan> it isnt really

[21:01] <putter> s/servers/serves/

[21:01] <stevan> but if P6::V/C are objects

[21:01] <putter> so "bootstrap" doesn't matter, yes?

[21:01] <stevan> are they objects of the runtime, or objects in the user space?

[21:01] <putter> both

[21:02] <putter> the runtime being partly implemented in p6

[21:02] <stevan> I disagree with that (I think)

[21:02] <stevan> I think P6::V/C should be runtime objects only

[21:02] <stevan> the user version of those is different

[21:02] <stevan> it calls the primative runtime objects to dispatch

[21:02] <stevan> but they should be seperate thing I think

[21:03] <putter> what properties do you envision "runtime objects" to have?

[21:03] * stevan is making this up as he goes along,.. so if I am wrong,.. please correct me

[21:03] <stevan> putter: I guess I see certain "things" as being part of the runtime... while other "things" are part of the language

[21:03] <stevan> the user-side of the language that is

[21:03] <putter> I'm still adrift/unclear on what's being suggested  # re please correct

[21:04] <stevan> I am suggesting we remove all MM code from P6::V/C

[21:04] <stevan> then make part of the PIL-Run Prelude the creation of MM objects which wrap the relevant P6::V/C stuff

[21:05] <stevan> so that internally PIL-Run does not use the MM

[21:05] <putter> ApiX has provided a proceedural "runtime" which isn't available in p6 space.  but there is currently no data object-ish "runtime".

[21:06] <stevan> I dont know what you mean by proceddural runtime

[21:06] <stevan> and data object-ish runtime

[21:07] <putter> pilrun basically just converts PIL'ed p6 code (and a bit of faked p6 code in PrimP5) to p5 code which uses the ApiX...err, api.  of p6_mumble subs.

[21:08] <putter> p6_apply()  then invokes methods on stuff.

[21:09] <putter> and converts objects to/from native int/str/etc.  but other than that, it doesn't deal with the nature or implementation of objects.

[21:09] <putter> s/and converts/and ApiX converts/

[21:12] <putter> So I can't quite picture a runtime vs non distinction for objects.  We could implement p6 int, array, etc, as native p5 objects.  And generally use them rather than Int, Array, Etc, when writing PrimP5 and PrimP6.  That sounds plausible.

[21:12] <stevan> putter: that is what I mean

[21:13] <stevan> although maybe not Primp6

[21:13] * PerlJam primps the 6

[21:13] <putter> But basically, p6 code is being transliterated into p5.  Not necessarily a great idea, junctions and autothreading are going to be... problematic.  But it's simple...

[21:14] <putter> Hmm... ok.  int array are the low hanging fruit....

[21:15] <putter> the division between PrimP5 and PrimP6 is an emphemeral implementation artifact.  if something seems to make sense in one but not the other... that's perhaps the sign of a problem.

[21:16] <putter> for int, array - how do they interact with mm2?

[21:17] * putter goes to check ./pugs for int/array handling...

[21:18] <putter> ?eval 1

[21:18] <putter> :(

[21:19] <stevan> 1

[21:19] <stevan> putter: I am not sure pugs make the distinction

[21:19] <putter> multi sub f(int $x){say "int ",$x;} multi sub f(Int $x){say "Int ",$x;} my int $z=3; f($z)

[21:20] <putter> yields "Int 3" :/

[21:20] <putter> :)  thank you stevanevalbot. :)

[21:21] <putter> mm2 handles types?

[21:21] <stevan> nope

[21:21] <stevan> types are not the metamodels problem

[21:21] <putter> ohhhh.

[21:21] <stevan> they are the containers issue

[21:21] <stevan> because they are compile time things

[21:22] <stevan> IIRC that is

[21:22] <stevan> autrijus: ping

[21:22] <putter> how can one do multimethods w/o types?

[21:22] <stevan> i hacked it :)

[21:22] <putter> sigh. ;)

[21:22] <stevan> I assumed they are implemented in the runtiome

[21:22] <stevan> multisubs

[21:23] <stevan> because multisubs are not part of the metramodel

[21:23] <stevan> and to make multisubs into multimethods is simple

[21:23] * eric256_ has been reading the conversation for quite a while now and has followed just about 0 of it. lol

[21:23] <eric256_> is there anything small i can do on pugs?

[21:23] <PerlJam> eric256_: don't feel lonely.  I haven't quite grokked it yet.

[21:23] <eric256_> tests cleanup or anything like that?

[21:23] <PerlJam> eric256_: tests are always welcome

[21:23] * stevan is not sure he gets it either :)

[21:24] <eric256_> any specific tests in mind?

[21:24] <PerlJam> eric256_: Anything that is sub-tested  ;-)

[21:24] <stevan> putter: I think we need to decide what is the MM responsibility and what is not

[21:25] <stevan> I have made some assumptions in the design about that

[21:25] * putter notes docs/quickref/namespaces no longer reflects recent posts on p6l...

[21:25] <stevan> I think they are sane ones,.. but I am starting to question this 

[21:25] <fglock> P6::Value::Code implements it's own Type object

[21:25] <PerlJam> stevan: was one of the assumptions that everything must pass through the MM dispatcher at some level?

[21:26] <PerlJam> s:2nd/the/a/

[21:26] <putter> does Code do multimethods?

[21:26] <stevan> PerlJam: only method calls

[21:26] <stevan> PerlJam: I assume there are primative subs available

[21:26] <PerlJam> stevan: Aren't subs just funny looking methods on the Sub/Code/whatever class?

[21:26] <stevan> I have to,.. i need to start with something :)

[21:26] <putter> and there are... :) fglock++

[21:27] <stevan> PerlJam: but how can I have a Sub/Code class without first having Class?

[21:27] <putter> (primitive subs available)

[21:27] <PerlJam> stevan: that's where the bootstrapping comes in  ;)

[21:28] <stevan> PerlJam: thats too much to bootstrap,.. to many subs are used before you even get to a point where you can create Sub/Code

[21:28] <fglock> putter: it does multisubs

[21:28] <stevan> I think it makes sense to assume a base level of functionality 

[21:28] <putter> stevan, I'm not suggesting insanity (re design assumptions).   just noting another blob functionality for our collective todo list.  

[21:28] <stevan> even smalltalk does that :)

[21:28] <putter> ooo

[21:29] * putter removes blob of functionality from our collective todo list. ;) fglock++

[21:30] <fglock> putter: Code.pm has a very simple "resolution order" algorithm - this needs to be implemented

[21:30] <putter> does ./pugs ever use int/array/mumble?  (so I can look at it in PIL...)

[21:30] <PerlJam> holy crap ... there's a guy walking across the parking lot here that looks just like a slightly balding Larry Wall

[21:30] <stevan> hey PerlJam werent you in TX? near the hurricane?

[21:31] <PerlJam> yes, I'm TX.  No where near the hurricane (though Corpus Christi had a mandatory evacuation just in case)

[21:31] <PerlJam> I'm *in* TX

[21:31] <stevan> I suppose it is a pretty big state ;)

[21:32] <stevan> for some reason I thought you were in that area though

[21:32] <putter> ah, no type information (attached to variables) is coming through PIL at all.

[21:33] <putter> fglock: any thoughts on int/array/etc?  Are they just native objects?

[21:33] <PerlJam> stevan: Texas is hyooge!  If a pick a direction, I have to drive at least 4 hours to be out of the state (and then I'm in Mexico), or if I want to stay in the US, I have to drive at least 6 hours along the coast or 8 hours north or 12+ hours east

[21:33] <putter> at 90 mph. ;)

[21:33] <stevan> PerlJam: yes, i drove from New Orleans to ElPaso once

[21:33] <PerlJam> putter: that's a given!

[21:33] <stevan> its a big-un fo sho ;)

[21:34] <stevan> via Austin too

[21:34] <PerlJam> stevan: did you get a good look at that sign as you come in TX on I-10 from LA that says 800-some-odd miles to El Paso ?

[21:35] <fglock> putter: they can be made into native objects - but this requires some work

[21:35] <putter> so, how would it work?

[21:35] <putter> they have to show up as Type's,

[21:36] <putter> the ApiX.pm  p6_to_mumble  need to be made happy with getting a native rather than mm object,

[21:37] <putter> the multimethod dispatcher has to be able to coerce them to boxed forms,

[21:37] <fglock> re Type: Type->new( name => 'Array', match => sub { $_[0]->isa('Array') }, .. and so on

[21:38] <fglock> re dispatcher: it is hard to tell str from int from num

[21:38] <fglock> but this may not be a problem

[21:39] <putter> re str vs num, there's a p5 magic trick for that.  int vs num could just be int($x)==$x ?

[21:39] * putter goes to look for magic...

[21:39] <PerlJam> wouldn't it just box them all as a Native type and have the appropriate magic buried within?

[21:39] <fglock> Int, NaN are not supported by Perl5 - it thinks they are str

[21:40] <fglock> Perl6::Value::stringify and Perl6::Value::numify handle native types - but it is slow

[21:41] <PerlJam> a Native thingy would be analogous to perl5's SV and have slots for IV, NV, etc. and couple of bits to tell you which native type it really is.

[21:41] <putter> (~$_&$_) eq 0  from damian's multimethods.

[21:42] <putter> PerlJam: but it would be nice (performance wise) if an "int" could be a native p5 int.

[21:44] <putter> If the long proposed p5 patch to permit non-blessed references (ARRAY, HASH, etc) to have methods had ever been applied, we wouldn't be struggling here.  It would be trivial.

[21:44] <fglock> putter: Value.pm, line 377 - implementation of unboxed types - you can use that

[21:44] <fglock> re ARRAY, HASH - p6 arrays can be infinite; hash keys can be objects

[21:45] <fglock> you can't easily reuse ARRAY and HASH, except in some cases

[21:48] <putter> is p6 "array" required to be infinte-capable?

[21:48] <putter> hash keys could just use object id.

[21:49] <fglock> Array is lazy by default, you have to use the "Eager" role to make them non-lazy

[21:49] <putter> ok,  Value.pm, line 377 seems straight forward.  one could add a fastpath for non-ref objects and for ARRAY.

[21:50] <putter> but what about "array" as opposed to "Array".  or does such exist?  like "int" and "Int".

[21:50] <PerlJam> there is no array vs. Array

[21:50] <putter> s/exist/speced/

[21:50] <putter> ah, ok.

[21:50] <fglock> re hash: that's what Perl6::Container::Hash::Object does (store id)

[21:50] <putter> perhaps an implementation language extension ;)

[21:51] <putter> does P6::V/C call methods on things which might end up being native objects?

[21:51] <putter> eg, if a native int get's placed in an Array, or Scalar.

[21:52] <fglock> this is done by the compiler, now

[21:52] <fglock> does PIL emits "int"?

[21:53] <putter> doesn't look like it unfortunately

[21:53] <putter> thus no coerce either

[21:55] <putter> anyone remember the name of the CPAN module which permits method calls on unblessed references?

[21:56] <fglock> putter: "autobox"

[21:56] <putter> fglock: how can it be done by the compiler?  if I do a Scalar->new()->store(3), does that work?  or will someone perhaps try to 3->mumble() it.

[21:57] <putter> ahh, autobox. thanks.

[21:59] <fglock> putter: it should work, if there is a mumble(Int) - I don't know if it works in pil-run 

[22:01] <putter> $x=Scalar->new();$x->store(3); $x->zark()  returns "3" !? :)

[22:02] <putter> as a Str.

[22:02] <obra> seen rkinyon

[22:03] <fglock> it was programmed like that (Scalar.pm 257) - I'm not sure why

[22:03] <putter> ok.  so it looks like things can be made faster.  perhaps even faster than they were.  but perhaps that should wait until after the switch to mm2 settles down.  there are still a bunch of regressions.

[22:03] <putter> :)

[22:04] <putter> so maybe just suffer for a bit until mm2 is working as well a mm1 did.  then add a fastpath.

[22:04] <putter> sound plausible?

[22:05] <fglock> is there a pugs release nearby? in that case, we could wait until after the release

[22:06] <fglock> or create pil-run2

[22:06] <geoffb> fglock, autrijus has been making sounds in that direction, but I doubt much will happen until he has absorbed ICFP for a couple days.

[22:06] <geoffb> He could surprise us, of course.

[22:08] <putter> since no release has ever really supported a pilrun, there are no support issues.  and expectation management wise, low-key and crufty is perhaps even better than putting effort into "having a pretty face".  p6/parrot has been so oversold, minimum time to extensive functionality is perhaps the only metric which matters.

[22:09] <geoffb> It would be nice though not to have the P5 backend on fire at release time

[22:09] <putter> yes

[22:10] <geoffb> at least something for the release-waiters to play with, even if it's not as good as it was, er, a few hours ago

[22:10] <putter> err, for some definitions of "on fire"

[22:10] <geoffb> nod

[22:11] <geoffb> .oO( Why doesn't iblech just leave the bot in 24x7?  Metered internet? )

[22:12] <fglock> PIL-Run no longer promises that "only say 'hi' works" :)

[22:12] <putter> :)

[22:13] <putter> I'm a great believer in minimizing client expectations... but that was beginning to seem excessive. :)

[22:15] <putter> fglock: so, how shall we approach getting mm2 settled in?  make smoke and test (iblech++?) are both working.  some things like ::meta are likely "things known to need updating".  I'm not sure what else is in that category.

[22:15] <putter> stevan: ping?

[22:16] <putter> smoke will take a few hours though.

[22:16] <fglock> Is Scalar an Array working? I could work a bit on that

[22:17] <putter> when I started a make test-perl5 run, it looked like there were some regressions both in sanity and array.

[22:18] <fglock> btw: I think adding junction support to Code->do is not too difficult (without threading)

[22:19] <putter> anything with {'instance_data'} probably needs to be changed.

[22:19] <putter> ! awesome. :)

[22:19] <fglock> I'll take a look later - I must leave in a while

[22:20] <putter> ok.  thanks.

[22:20] <putter> stevan: what is the mm2 version of $_[0]->{instance_data}{name}

[22:23] <fglock> putter: would you create an entry in docs/journal later (about pil-run/mm2 integration)?

[22:25] <putter> trying ->name

[22:25] <svnbot6> r7150 | Darren_Duncan++ | /ext/Locale-KeyedText : resync with perl 5 changes, and other perl 6 specific formatting changes

[22:28] <putter> fglock: err...  feel free?

[22:31] <putter> I've been avoiding logging progress as expectation management on this thing (p6 on p5) is going to be a doozy, and I'd like to avoid the usual p6/parrot thing of claiming things work, even when brief user experimentation will show they don't.

[22:33] <putter> Here, yes mm2 supports roles, modules, etc, etc.  Which is great.  But pilrun sure doesn't.  Even ./pugs -C doesn't.  So it's not going to happen real soon (unless I spend a day or few spending time I shouldn't;).

[22:36] <eric256_> does all this class work you are doing right now effect pugs?  i've kinda got the feeling it is a perl5 implementation that is going to be translated..or is that the wrong feeling?

[22:37] <putter> So what would one say?  pilrun has switched to mm2.  that is, it's now even more broken than it was before.  ?

[22:37] <putter> eric256_: pugs is only affected in that ./pugs -B perl5  now exists.  Which would be something to advertise... if only it worked a little better.

[22:39] <eric256_> any rough ETA when pugs is going to start seeing all these class and roles things?

[22:39] <putter> It works great from a development in progress perspective.  But rather less so from a "random user reading pugs release announcement" perspective.

[22:41] <putter> well, with mm2, and autrijus having time again, perhaps rsn.  as in a week or few.

[22:41] <geoffb> He seems to be pushing for 6.28.0 by EuroOSCON

[22:44] <pdcawley_> Remind me, what's the syntax for specifying the return type of a function?

[22:53] <putter> foo () returns Int {} ?

[23:01] <putter> stevan: p5ugs> :5 Str->new()->isa('Class')

[23:01] <putter> 1

[23:06] <pdcawley_> Ta.

[23:07] * pdcawley_ wonders if TSa will understand his point this time.

[23:13] <svnbot6> r7151 | putter++ | Perl6-Value, Perl6-Container, PIL-Run: updated uses of {'instance_data'}.  With DESTROY's now working, the gc errors are pervasive.  Perhaps the DESTROY's should be commented out, just so we can get work done.

[23:20] <svnbot6> r7152 | putter++ | Perl6-Container, Perl6-Value - disable DESTROY's to moderate MM2.0 gc problem.

[23:52] <stevan> putter: pong

