[00:01] <luqui> Class::Multimethods::Pure is my best so far, IMO.

[00:01] * luqui has to go

[00:01] * luqui &

[00:40] <rafl> luqui: Why the old artistic license, btw?

[00:41] * luqui dunnos

[00:41] * luqui doesn't really care about licensing

[00:41] <luqui> steal my code, mangle it, claim it's your own, see if I give a damn

[00:42] <luqui> I just use the default template

[00:44] <rafl> luqui: old artistic license isn't too cool. It mainly has some too vague formulations to be a real free software license.

[00:45] <rafl> luqui: I thought the default templates say "same license as perl (GPL/Artistic)"

[00:46] <luqui> hmmm

[00:46] <luqui> then that's what mine should say

[00:47] <luqui> Ahhh

[00:47] <luqui> the README is correct, the POD is not

[00:47] * rafl likes plain GPL better, but GPL/Artistic is fine of course, because it's compatible with the GPL.

[00:48] <rafl> luqui: Updating the license in the POD would be nice for packaging.

[00:49] <luqui> done, uploaded to pause

[00:50] <luqui> you can find the most recent version at http://luqui.org/public

[00:50] <luqui> because pause lags a bit

[00:53] <rafl> Thanks!

[00:53] <rafl> There's the pause incoming directory, so I don't care about that lag. :-)

[00:54] <luqui> ahh, good point

[01:04] <rafl> luqui: Can you think of a nice Description? The full introducion you give on the POD is a bit too much, I guess.

[01:12] <luqui> how long a description?

[01:13] <rafl> Let's say 10-20 lines.

[01:14] <luqui> not right now... :-(

[01:15] * luqui is leaving for gamedev in about, oh, say, -2 minutes

[01:15] <luqui> bye!

[01:15] * luqui &

[01:15] <rafl> Bye!

[01:15] <luqui> thanks for your debian work

[01:15] * luqui & # really

[01:25] * rafl gets another beer.

[02:30] <rafl> Here pugs build logs from hppa-linux and s390-linux. They have some tests failing that worked for me on i386. Maybe it helps to improve pugs in some way: http://buildd.debian.org/fetch.php?&pkg=pugs&ver=6.2.9-1&arch=hppa&stamp=1126661793&file=log&as=raw http://buildd.debian.org/fetch.php?&pkg=pugs&ver=6.2.9-1&arch=s390&stamp=1126655935&file=log&as=raw

[02:47] *** sleepster is now known as typester

[06:02] <spinclad> rafl_: pugs out of NEW means it should be in unstable now, no?

[06:03] <nothingmuch> morning

[06:03] <spinclad> not seeing it... probably propagating?

[06:03] <spinclad> mornin nuffin

[06:04] <nothingmuch> anything new?

[06:05] <spinclad> pugs in debian, rafl++

[06:06] <spinclad> for me, no... went to our church's zen center tonight, glad to be back there

[06:09] <spinclad> gonna look at pugs core and mm and ponder a haskell backend...  if i get somewhere i expect i'll talk with luqui

[06:10] <spinclad> don't know how realizable this is for me yet...

[06:10] <nothingmuch> stevan is actually your man, i think

[06:10] <nothingmuch> stevan++; # father of metamodels 1 through N, and meta model N 2.0

[06:11] <spinclad> sure, for the mm...  thinking luqui as one who's been catching the haskell bug

[06:11] <nothingmuch> ah

[06:12] <spinclad> so yeah, both of em

[06:12] <nothingmuch> in that case you can splice them

[06:12] <nothingmuch> you could take off stevan's head and put it on luqui's torso

[06:12] <nothingmuch> luqui would look much meaner that way

[06:12] <spinclad> no! i need both their heads!

[06:12] <nothingmuch> you

[06:13] <nothingmuch> 'll have both their heads in one package

[06:13] <spinclad> ah! like zaphod then.  yeah, might work

[06:14] <spinclad> anyway, this is for the morrow.  getting an early night tonight (02:15)

[06:14] * nothingmuch had one too

[06:15] <nothingmuch> came back from work, watched some telly, dinner, dishes and streight to bed

[06:15] <spinclad> is it sunup around by you?

[06:15] <nothingmuch> 9:15

[06:16] * nothingmuch is not getting good ride options to work, so everything is 2 hours later than i'd like it to be

[06:19] <spinclad> wish i could enjoy staying and chatting... 

[06:20] <spinclad> i think on balance i'll enjoy the morning more  *snf*

[06:20] <spinclad> &

[06:36] <Khisanth> HMM

[06:40] <Khisanth> is the pugs binary suppose to be in the repo? O_o

[06:48] <scook0> Khisanth: I think 'pugs' is now a Perl script that calls the actual binary

[06:48] <scook0> (confused me too...)

[08:47] <nothingmuch> what's a nice to compute mathematical function that is quite hard to compute but not insane (e.g. ackerman)

[08:51] <masak> nothingmuch: memoization?

[08:51] <nothingmuch> actually i'm trying to make my comptuer work harder than that =)

[08:52] <nothingmuch> i think i'll use a dually recursive fib function

[08:52] <Juerd> Calculate pi to more digits than currently known.

[08:52] <Juerd> Publish, profit.

[08:52] <nothingmuch> tsk tsk

[08:52] <nothingmuch> i should clarify: i'm trying to benchmark the circular prelude thing

[08:52] <Juerd> Or, in fact, just compute the final digit.

[08:52] <Juerd> :)

[08:53] <nothingmuch> "the" final digit?

[08:53] <Juerd> Yeah.

[08:53] <nothingmuch> heh

[08:53] <Juerd> Or the last three, or something like that.

[08:59] <Juerd> Can anyone reach feather by ssh?

[08:59] <nothingmuch> yes

[08:59] <Juerd> Oh, now I can too

[08:59] <Juerd> Weird.

[09:00] <Juerd> pugs has grown much.

[09:01] <Juerd> 8.3 MB now, was 5.x last time I looked

[09:02] <broquaint> Has this been passed around yet? http://www.cse.ogi.edu/~hallgren/House/

[09:05] <broquaint> It seems suitably mad so I thought it would go down well here.

[09:25] <masak> an OS in haskell... now why does that sound both crazy and agreeable at the same time?

[09:26] <broquaint> Agreeably crazy? Crazily agreeable? It's starting to sound a little like pugs ...

[09:32] <masak> broquaint: apart from playing around with, what is House good for?

[09:37] * masak reads the paper on House

[09:37] * Juerd curses

[09:37] <Juerd> Someone wrote a module that extends DBIx::Simple and uses DBIx::Simple namespace for that

[09:38] <Juerd> The annoying thing is that I like this module, and can't be as upset about the namespace issue as I want to be.

[09:39] <broquaint> No idea, masak. I think it's fairly academic :) Just interesting to see some Haskell operating close to the metal.

[09:42] <masak> Juerd: couldn't you patch the module to use another namespace?

[09:43] <Juerd> Of course I could, but it's not my module.

[09:44] <Juerd> I would be committing a very serious crime if I changed someone else's module.

[09:44] <Juerd> The author of the module in question has done this in the past, by the way, so he might not mind, but I'm not like that.

[09:45] <Juerd> I sent a message to him, cc [email@hidden.address] to discuss it.

[09:45] <masak> Juerd: what's the problem? you could submit your patch to the author for the next version of the module, and meanwhile use your patched version

[09:46] <Juerd> No, what I want requires changes to both modules.

[09:46] <Juerd> And as he invaded my namespace, I can't do this without clashing.

[09:46] <masak> ah

[09:46] <Juerd> So we need to communicate first, and try to synchronise our releases.

[09:46] <Juerd> (Assuming he's willing to change things.)

[09:46] <masak> is stuff like this written down somewhere in perldoc?

[09:47] <Juerd> What stuff?

[09:47] <Juerd> Namespace invasion?

[09:48] <masak> yes

[09:48] <Juerd> No - it's a social thing, not a technical one.

[09:48] <Juerd> You don't install a spoiler on someone else's car without asking first.

[09:49] <masak> you mean it's common courtesy not to invade namespaces

[09:49] <Juerd> Not even if it looks really neat and you're doing it for free.

[09:49] <Juerd> Yes.

[09:49] <masak> i agree

[09:49] <masak> but everybody might not have realized that

[09:49] <Juerd> This guy by now should have some sense of how people don't like this

[09:50] <Juerd> In the past, he's even *uploaded* his version of a not-his module

[09:50] <Juerd> Without maintainership.

[09:50] <masak> ouch

[09:51] <masak> people have varying levels of social skill :/

[09:51] <masak> he might still be a nice guy, too :)

[09:52] <Juerd> By the way - I have this from several perl mongers, and have not witnessed the fact myself.

[09:52] <Juerd> In person I haven't hated him yet.

[09:53] <masak> i'm sure if you ask him -- and he's not a sociopath -- he'll agree to get outta your namespace

[09:53] <Juerd> I hope so

[09:53] <Juerd> I'm trying, at least.

[09:54] <Juerd> I don't mind his invasion, really, but this way of working blocks further cooperation between our modules

[09:54] <Juerd> As long as he's not overriding existing methods, it's fine by me.

[09:54] <Juerd> But to really make this work, I'd have to have these methods too, and by doing so, he'd be overriding, which would be immensely ugly.

[09:55] * nothingmuch likes the fact his mini language had builtin support for higher order functions without thinking about it

[09:55] <Juerd> http://www.nntp.perl.org/group/perl.modules/44048  # this should work

[09:55] <Juerd> nothingmuch: Then you did something right.

[09:56] * nothingmuch is using a function called repeatedly_apply_and_accum to implement &infix:<*>, &infix:</>, and &infix:<**>

[09:56] <nothingmuch> sub &infix:<*>( repeatedly_apply_and_accum(&infix:<+>, $x, $x, $y) }

[09:57] <nothingmuch> syntax errors, but whatever

[09:57] <nothingmuch> except I have a stupid bug in /

[09:57] <nothingmuch> it doesn't work that way ;-)

[09:58] <QtPlatypus> nothingmuch: You could define +'s in terms of lambda functions.

[09:58] <nothingmuch> QtPlatypus: yeah, i know, but i'm not touching that with a 10 foot pole

[09:58] <nothingmuch> since i like defining my AST with things that really look like numbers

[09:59] <nothingmuch> and since the "compilation" phase is harder

[09:59] * QtPlatypus nods

[09:59] <nothingmuch> i'm trying to elegantly demonstrate the pluggability of builtin ops (**, * and / are all optionally built in)

[09:59] * QtPlatypus nods.

[09:59] <nothingmuch> then I'm computing (($_ ** 5) / ($_ ** 4)) for 1 .. 10

[10:00] <nothingmuch> which should ofcourse be 1 .. 10

[10:00] <nothingmuch> but should demonstrate the order of magnitude of difference between the runtime features

[10:19] <nothingmuch> wow, this is fun

[10:27] <nothingmuch> luqui: ping

[10:31] <nothingmuch> what is the canonical value of &infix:<...> internally? is it '&infix:...'? If I ask &infix:{'<'}.name what do i get?

[10:32] <nothingmuch> and does ::('&infix:<<>') or ::('&infix:{"<"}') work? or should it be ::(&infix){'<'} ?

[10:33] <nothingmuch> anyway, lunchtimne

[11:24] * nothingmuch returns

[11:27] * nothingmuch would like a neither operator and nor operator... they work very well

[11:27] <nothingmuch> neither $x nor $y

[11:28] <nothingmuch> listy neither is what you think it is

[11:29] <nothingmuch> oneary neither is no-op and nor is chainary '!$x and !$y

[11:47] *** _SamB_ is now known as SamB

[12:13] <pasteling> "nothingmuch" at 212.143.92.226 pasted "/me loves perl" (9 lines, 246B) at http://sial.org/pbot/13094

[13:35] <rafl_> spinclad: At least after the next dinstall run this evening.

[13:40] <rafl_> Here pugs build logs from hppa-linux, powerpc-linux and s390-linux. They have some tests failing that worked for me on i386. Maybe it helps to improve pugs in some way: http://buildd.debian.org/fetch.php?&pkg=pugs&ver=6.2.9-1&arch=hppa&stamp=1126661793&file=log&as=raw http://buildd.debian.org/fetch.php?&pkg=pugs&ver=6.2.9-1&arch=s390&stamp=1126655935&file=log&as=raw http://buildd.debian.org/fetch.php?&pkg=pugs&ver=6.2.9-1&arch=powerpc&stamp=11266

[13:40] <rafl_> Unfortunately the debian build failed for other archs (3 for Debian reasons, 2 for ghc reasons). http://buildd.debian.org/build.php?arch=&pkg=pugs

[13:45] <chinu> hi all

[13:45] <chinu>  i have a question

[13:45] <chinu> regarding crawler programming in perl

[13:46] <rafl_> Hello chinu 

[13:46] <rafl_> chinu: Are you asking about perl5 or perl6?

[13:47] <chinu> perl 6

[13:47] <elmex_> you can program something in perl6 ?

[13:47] <elmex_> wow, thats news

[13:47] <chinu> no

[13:47] <chinu> it is perl5

[13:47] <Qiang_> heh. he is asking the same question in #perl too.

[13:48] <rafl_> chinu: So please ask in #perl. This channel is about perl 6 and pugs development.

[13:48] <chinu> so what, if you know answer me

[13:48] <elmex_> i wonder when perl6 will be ready enough to be able to bind with SDL

[13:48] <chinu> but no one is answering there

[13:48] <rafl_> chinu: Ask a proper question, then.

[13:49] <Qiang_> "chinu , so what, if you know answer me"  that's quite a polite !!!

[13:52] <chinu> ok sorry

[13:52] <chinu> if i hurt you

[13:52] *** elmex_ is now known as elmex

[13:59] <nothingmuch> any Inline:: hackers here think they could they could hack an Inline:: for C--?

[13:59] <elmex> C-- ?

[14:00] <nothingmuch> the intermediate language

[14:01] <nothingmuch> i would like to avoid compiling to C because it doesn't have prefix form

[14:04] <nothingmuch> hah! I've totally lost my marbles and I want to generate C code at run time, and eval it into Perl. How do I do this?

[14:04] <nothingmuch> that so applies to me =/

[14:05] <nothingmuch> http://search.cpan.org/~ingy/Inline-0.44/C/C-Cookbook.pod#Evaling_C

[14:06] <McFist> how can I test if bless() works in pugs?

[14:07] <nothingmuch> ok(ref eval { bless $thing, "Class" }, "true value);

[14:07] <nothingmuch> is(ref eval { bless $thing, "Class" }, "Class",  "true value);

[14:07] <nothingmuch> look inside t/oo

[14:07] <nothingmuch> i'm willing to bet one cookie that it's already tested

[14:07] <stevan> nothingmuch: you might be wrong actually

[14:07] <nothingmuch> that's why I only bet one cookie

[14:07] <stevan> nothingmuch: bless() is much deeper magic now in perl 6 oo

[14:08] * stevan takes nothingmuch's cookie

[14:08] <nothingmuch> i thought it retains compatibility, no?

[14:08] <McFist> both this and one in t/oo doesn't work

[14:08] <nothingmuch> hmm

[14:08] <nothingmuch> in that case see how it's specced, make sure the test is good

[14:08] <nothingmuch> and add a TODO test ;-)

[14:08] <McFist> *** No compatible subroutine found: "&bless"

[14:08] <stevan> nothingmuch: I assume nothing about perl 6 anymore

[14:08] <nothingmuch> do you have commit bits?

[14:09] <stevan> McFist: what are you trying to do?

[14:09] <stevan> TIMTOWTD a lot more things in Perl 6

[14:09] <McFist> stevan: I'm trying p5-ish "sub new { bless shift }"-like class instantiation

[14:09] <stevan> McFist: yuk, why?

[14:10] <nothingmuch> bless shift != good

[14:10] <stevan> class C {} gives you the same thing

[14:10] <nothingmuch> bless $thing, shift == good

[14:10] <McFist> stevan: because I don't know how to do that properly

[14:10] <nothingmuch> class C { } is all you need

[14:10] <QtPlatypus> McFist: The default "new" does that for you

[14:10] <stevan> ?eval class C {}; my $c = C.new();

[14:10] <nothingmuch> class C {}; C.new;

[14:10] <evalbot_7006> \C.new(); 

[14:10] <stevan> huh>????

[14:11] * nothingmuch can already here Damian saying "Every object is a closure"

[14:11] <stevan> McFist: all objects now inherit from Object, and so are provided a default new() method

[14:11] <McFist> yes, default 'new' does it, but what if I want my own 'new' ?

[14:11] <nothingmuch> McFist: override BUILD

[14:11] <stevan> yes, that is usually the best solution

[14:11] <stevan> class C { submethod BUILD { ... } }

[14:12] <stevan> BUILD will get all the arguments new() got

[14:12] * nothingmuch corrects himself - ammend to BUILD, don't override it

[14:12] <stevan> and can be used to perform initializations

[14:12] <stevan> nothingmuch: actually you do override

[14:12] <stevan> because BUILDALL will call all BUILDs 

[14:12] <stevan> for all descendents

[14:12] <nothingmuch> and Class.BUILD calls nothing at all because they're submethods?

[14:13] <stevan> but you usually override with a submethod, so your BUILD wont get inherited

[14:13] <stevan> Class.BUILD() will blow up

[14:13] <nothingmuch> submethods should be method : uninherited 

[14:13] <stevan> at least I think it should

[14:13] <stevan> yeah, that

[14:13] * nothingmuch doesn't see why there's such a confusing name for something so scarce

[14:13] <McFist> another thing I wanted to new(1), because the default new() does only "** Must only use named arguments to new() constructor"

[14:13] <stevan> cause its perl ;)

[14:14] <stevan> McFist: that might be a restriction on pug's current OO state

[14:14] <stevan> we are working on that

[14:14] <nothingmuch> maybe you can override new to call supernew with fudged params?

[14:14] <stevan> yes

[14:15] <stevan> ?eval class C { method new (@args) { $?SELF.SUPER::new(args => @args) }; C.new(1, 2, 3)

[14:15] <evalbot_7006> Error:  unexpected end of input expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[14:15] <stevan> darn pugs

[14:16] <elmex> does pugs knoow classses /?

[14:16] <dudley_> barely

[14:17] <stevan> ?eval class C {}; my $c = C.new(); $c.ref

[14:17] <evalbot_7006> ::C 

[14:17] <stevan> ?eval class C {}; my $c = C.new(); $c

[14:17] <evalbot_7006> \C.new(); 

[14:18] <stevan> ?eval class C { has $.b; }; my $c = C.new(b => 'hello world'); $c.b();

[14:18] <evalbot_7006> \'hello world' 

[14:18] <McFist> aha, so s/bless/supernew/ works then... but there's a problem:

[14:18] <McFist> class C { method new (@args) { say @args.elems; $?SELF.SUPER::new(args => @args); } }; C.new(1, 2, 3);

[14:18] <McFist> says 1

[14:18] <McFist> do I expect that it should say 3 wrongly?

[14:19] <stevan> ?eval class C { has @.args; method new (*@args) { say @args.elems; $?SELF.SUPER::new(args => @args); } }; my $c = C.new(1, 2, 3); $c.args();

[14:19] <evalbot_7006> 3 [1, 2, 3] 

[14:19] <stevan> McFist: the @args should be slurpy *@args

[14:19] <stevan> otherwise you need to do:

[14:19] <stevan> ?eval class C { has @.args; method new (@args) { say @args.elems; $?SELF.SUPER::new(args => @args); } }; my $c = C.new([1, 2, 3]); $c.args();

[14:19] <evalbot_7006> 1 [[1, 2, 3]] 

[14:20] <stevan> hmm, that doesnt look right either

[14:20] <McFist> pugs seems not to know about *@args yet

[14:20] <stevan> ?eval class C { has @.args; method new (@args) { say @args.elems; $?SELF.SUPER::new(args => @args); } }; my @_args = (1, 2, 3); my $c = C.new(@_args); $c.args();

[14:20] <evalbot_7006> 3 [1, 2, 3] 

[14:20] <stevan> there we go

[14:20] <stevan> McFist: what version of Pugs are you using?

[14:20] <McFist> stevan: 6.2.9

[14:21] <stevan> ?eval $?PUGS_VERSION

[14:21] <evalbot_7006> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6945)' 

[14:21] <stevan> what revision?

[14:21] <McFist> r7004

[14:21] <stevan> hmm

[14:21] <stevan> paste your code where *@args is not working

[14:22] <McFist> my bad, mixed *@ and @*

[14:27] <McFist> hmmm... so @args is not slurpy by default? shouldn't it be slurpy for "sub new(@args)" declarations?

[14:27] <nothingmuch> no, never

[14:27] <nothingmuch> if you do that @args is a readonly binding to the @CALLER::args

[14:28] <McFist> is there TFM about that?

[14:28] <nothingmuch> synopsis 6

[14:28] <nothingmuch> http://dev.perl.org/perl6/doc/design/syn/S06.html

[14:28] <nothingmuch> someone please make up a name for my dumb intermediate language?

[14:28] <nothingmuch> DIL

[14:28] <nothingmuch> hmm

[14:30] <McFist> ah, no, of course there shoulb be explicit * for sub($a,%b,@c), i.e. where there's ambiguity... I can't understand why sub A($a,@b) and sub B($a,*@b) should behave differently

[14:31] <nothingmuch> because A($a, $b, $c) won't work - it needs an array, like A($a, @b)/

[14:31] <nothingmuch> while B($a, $b, $c) will work, like '@b = ($b, $c)'

[14:32] <McFist> no, I mean, I see that it doesn't work, but I can't understand the reason behind that

[14:32] <nothingmuch> oh

[14:33] <nothingmuch> sub splice (@array, $offset, $number, *@replacement) { ... }

[14:33] <nothingmuch> sub compare (@array, @other_array) { }

[14:33] <McFist> agreed, but there's ambiguity - 1st arg is an array

[14:33] <ingy> hi nothingmuch 

[14:33] <nothingmuch> hi ingy 

[14:33] <nothingmuch> please hack Inline::CMinusMinus for me

[14:33] <nothingmuch> and please apply the Test::Base patch

[14:33] <nothingmuch> and thank you for reminding me that i've totally lost my marbles =)

[14:34] <nothingmuch> #catalyst::abraxxa christened my language Blondie

[14:35] <McFist> my point is that if there's sub a(@b), why making a(1,2,3) fail, seems 100% DWIM for me?

[14:35] <nothingmuch> because a wants an array, not a list of elements to bind into an array

[14:36] <nothingmuch> DWIM is only good if it isn't limiting

[14:42] <stevan> nothingmuch: why Blondie?

[14:45] <stevan> in honor of your long golden locks (that Ingy loves so much)

[14:57] * nothingmuch returns

[14:57] <nothingmuch> in honor of it being dumb

[15:08] <stevan> nothingmuch: your not dumb :)

[15:08] <nothingmuch> the IL is

[15:14] <Khisanth> stevan: could be the cartoon character too

[15:34] <metaperl> 'lo all...

[15:35] <stevan> hey metaperl 

[15:35] <fglock> hi metaperl, stevan

[15:35] <metaperl> wondering what module gives me this for Perl5: my @j = foldr1 { (shift(), $sep, shift()) } @link ;

[15:35] <stevan> luqui: you keep forgeting the changelog for C::MM::Pure,.. <ren voice>I need to know what happened man!!!!</ren_voice>

[15:36] <stevan> hey fglock 

[15:38] <metaperl> List::MoreUtils::pairwise() will do it... Language::Functional has too strong an expectation of the return type of the folding function

[17:43] * nothingmuch wonders why adamk likes array refs so much

[17:48] * stevan wonders why nothingmuch likes adamk so much

[17:48] <Juerd> Who's adamk?

[17:48] <stevan> Adam "PPI" Kennedy

[17:52] <nothingmuch> stevan: he's got some pretty decent modules

[17:52] <nothingmuch> i was just using Class::Inspector->subclasses($my_class)

[17:52] <nothingmuch> and for the 40th time i forgot to dereference

[17:53] <nothingmuch> i guess it's more "efficient"

[18:02] <stevan> why do you need to deref?

[18:05] <wolverian> hmm. I want to write: given <> { when Int { say "I was given a string that looks like an integer" } }

[18:05] <wolverian> make sense?

[18:07] <wolverian> that is, I want to equate types and patterns. I guess.

[18:07] <wolverian> the problem is that it doesn't make sense for every type.

[18:08] <wolverian> it also doesn't make much sense given the current ~~ behaviour

[18:09] <wolverian> what I want is rule Int { ... }, I guess, and perl to know if I mean class or rule Int.

[18:09] <wolverian> (maybe this is what you get for reading Haskell for a few minutes without really understanding it)

[18:11] <wolverian> I guess 'given <> { when Int.rule { ... } }' might be sensible as well.

[18:11] <nothingmuch> hmm

[18:11] <nothingmuch> that's a nice problem

[18:11] <wolverian> right. I actually started thinking about this when using java.util.Scanner

[18:12] <nothingmuch> given <> { when try { +$_ } { "a Num" } }

[18:12] <nothingmuch> but that's a bit crude

[18:12] <nothingmuch> i like haskell's read

[18:12] <wolverian> which has methods to read from pipes, such as: .nextInt(), .nextDouble(), .hasNextInt(), which is horrible

[18:12] <wolverian> I want to generalise that.

[18:12] <nothingmuch> given read <> { when Int { }  }; # that would be cooooool

[18:12] <nothingmuch> read <> is MMD on the return type

[18:12] <wolverian> exactly. but the problem is that Int is a type 

[18:12] <nothingmuch> it is not resolved until when ... hits

[18:13] <nothingmuch> when there is enough data for the resolution (Int context test) it tries to apply the read that does Ints

[18:13] <wolverian> hmm. 

[18:13] <wolverian> I don't like read() as a name.

[18:15] <wolverian> given <> { when coerces Int { ... } } # another way to look at it

[18:16] <wolverian> that's probably putting the weight into the wrong place.

[18:17] <theorbtwo> The problem, I think, is that any string can be an integer...

[18:17] <theorbtwo> ...it's just that most of them are a 0.

[18:18] <wolverian> right. I don't like that.

[18:18] <nothingmuch> hmm

[18:18] <wolverian> I even remember a decision by larry that that doesn't happen anymore

[18:18] <wolverian> "foo" as Int => fail "Can't coerce"

[18:18] <wolverian> or something.

[18:18] <nothingmuch> that's good news

[18:18] <nothingmuch> fail under use fatal is death

[18:18] <wolverian> I'm not sure I remember right.

[18:18] <wolverian> nothingmuch, right.

[18:18] <Juerd> wolverian: Something can coerce to something lossily

[18:18] <nothingmuch> under bool or smartmatch context is no

[18:19] <nothingmuch> and under numeric context can be 0

[18:19] <nothingmuch> everyone is happy =)

[18:19] <wolverian> Juerd, yes. please elaborate, I'm not sure of the relevance :)

[18:19] <Juerd> "0.5" as Int is 0

[18:19] <Juerd> And then you probably don't want "0.5" ~~ (something) Int to be true

[18:19] <Juerd> Where your (something) was "coerces"

[18:20] <wolverian> right.

[18:20] <wolverian> that would require a stricter type system.

[18:20] <Juerd> Yes

[18:20] <nothingmuch> coerce(:strict)

[18:20] <Juerd> I think it would be good to have some difference between lossy and lessless coercion

[18:20] <nothingmuch> Juerd++

[18:21] <Juerd> And ways of testing ability of coercing in a specific way

[18:21] * nothingmuch is almost done refactoring Blondie, but is out of time

[18:21] <nothingmuch> *poof*

[18:21] <wolverian> I guess in this specific instance I'm only looking for a builtin wrapper to coercion that puts a try { } around the coercion and returns bool::false or the result of the coercion

[18:22] <wolverian> (although nothingmuch's read() would be a nice abstraction of that.)

[18:22] <Juerd> $bar.fits_in(Int) or fail; my Int $foo = $bar;

[18:22] <Juerd> fits_in and can_be? :)

[18:22] <wolverian> right. :)

[18:22] <wolverian> something like that.

[18:22] *** GeJ_ is now known as GeJ

[18:22] <wolverian> or Int.can_house($foo)

[18:22] <Juerd> This would make your when/~~ case simply: when .can_be(::type)

[18:23] <wolverian> to look at it in reverse

[18:23] <wolverian> right.

[18:23] <Juerd> House suggests encapsulation, though

[18:23] <wolverian> yes. bad name, my point was to reverse the arguments.

[18:23] <wolverian> (not that I think that would be better. just thinking aloud)

[18:23] <Juerd> I personally prefer instance methods in most cases

[18:23] <wolverian> me too.

[18:24] <wolverian> (especially now that I've had to code Java at the university)

[18:24] <Juerd> UNIVERSAL::isa($foo, 'ARRAY') feels so overly wrong to me...

[18:24] <Juerd> I understand why it's necessary

[18:24] <Juerd> But my brain just wants such things to be real instance methods

[18:25] <Juerd> And Array.is_this_one_of_yours_perhaps($foo) would be so much worse even than the manually written instance method call on UNIVERSAL

[18:26] <Juerd> Besides, we need these things to be instancy, because an instance might be composed of several roles.

[18:26] <Juerd> and/or classes.

[18:26] <wolverian> what do you think about 'give read $foo { when Int { ... } }'? read() being just a name from Haskell.

[18:26] <wolverian> s,give,given,

[18:27] <Juerd> That does a .does check.

[18:27] <wolverian> read() doing .can_be() when its return type is resolved

[18:27] <Juerd> I don't know if that applies to coercion.

[18:27] <wolverian> (that is, it doesn't evaluate until it knows its return type)

[18:27] <Juerd> Int does Num, but Num doesn't quite do Int, I suppose.

[18:27] <wolverian> hmm. does Code ~~ Type run the Code?

[18:28] <Juerd> Num can coerce to Int, though.

[18:29] <Juerd> I've ordered home-university stuff, just to find something to spend time on that has nothing to do with computers (because of the RSI)

[18:29] <wolverian> that's good. what kind of stuff?

[18:29] <Juerd> And the first course describes OO. It's SO annoying to read about classes (not even in code context, but in modelling context) and methods and KNOW there's much more than that.

[18:30] <wolverian> heh.

[18:30] <Juerd> I keep thinking: noooo!!!!!11111eleven, use roles there!

[18:32] <Juerd> re what kind of stuff: technical computer science

[18:32] <Juerd> It's just the introductory thingy, consisting of 2/21 of the entire thing.

[18:34] <Juerd> What I'm reading now makes me wonder: if university is the highest level of education that we have in this system, what the hell is below it?

[18:34] * Aankhen`` goes to sleep.

[18:34] <Juerd> I just hope it gets more challenging

[18:34] <Juerd> Good night, Aankhen`` 

[18:34] <Aankhen``> G'night.

[18:35] <wolverian> Juerd, my introductory courses are similar. however, looking at the second and third year courses things start to get really advanced there.

[18:35] <Juerd> For example, per learning unit they indicate time you should spend on it. I tend to spend half of that, including revisiting it later.

[18:35] <wolverian> Juerd, not to speak of postdoc, of course.. :)

[18:35] <Juerd> I'm not doing this for a certificate or title

[18:35] <Juerd> I'm actually literally killing time.

[18:35] <wolverian> Juerd, right. our CS department has the principle that knowing programming is not a requirement for getting in.

[18:35] <wolverian> Juerd, that is why the first courses are so idiotic, generally.

[18:36] <Juerd> I see

[18:36] <Juerd> This first course touches modelling and simple design. The next 2 chapters are about SQL. 12 hours into SQL, they first mention joins.

[18:37] <Juerd> It would be better if they condensed the text and removed all the filling material

[18:37] <wolverian> I think that is what lectures are for. maybe.

[18:37] <Juerd> Then I'd spend much less time reading everything, hoping to learn something

[18:37] <Juerd> No lectures in home education

[18:37] <wolverian> right. 

[18:38] <wolverian> can't you attend the lectures?

[18:38] <Juerd> There are none.

[18:38] <wolverian> (they are open for everybody here.)

[18:38] <wolverian> oh, well then.

[18:38] <Juerd> Afaik, they're not open to non-students here

[18:38] <wolverian> that sucks.

[18:38] <Juerd> I ordered this from the "open university"

[18:38] <Juerd> Which is home education with an occasional opportunity to ask questions

[18:39] <Juerd> They claim it's the same level as real university, and you can get the same degrees from them

[18:39] <wolverian> open university here is only in summers and you get in with money instead of skill.

[18:39] <Juerd> But that's all kind of irrelevant. I could just as well have ordered Spanish lessons, but I hope to learn some more about my hobby.

[18:39] <Juerd> Here, you need neither

[18:40] <wolverian> for open university? 

[18:40] <Juerd> It's relatively cheap (though expensive compared to just buying books), but there are no requireemnts.

[18:40] <Juerd> And people with no money can get discounts up to 80%. I would qualify for such a discount if my source of income wasn't entrepreneurship.

[18:41] <Juerd> The only requirements they have is that you speak and write Dutch fluently, and that you are over 18 years old. (21 if you want a discount)

[18:42] <wolverian> hmm. okay.

[18:42] <wolverian> here university is free but you need to pass the exams. open university doesn't have exams but costs money. (anything from 50 to 800 euros per course.)

[18:43] <Juerd> They project 7 years by default, and I recently heard that over 90% of their student never finishes

[18:43] <wolverian> I'd like a 80% discount too for the open university. then I could actually study in the summers.

[18:43] <wolverian> Juerd, wow. that's a lot.

[18:43] <Juerd> I'm probably not finishing it either

[18:43] <Juerd> So far, it hasn't managed to entertain me.

[18:44] <Juerd> The only thing I learned so far is how to draw OO stuff in UML diagrams.

[18:44] <Juerd> ... yay.

[18:45] <Juerd> afk

[18:45] <Juerd> Going home

[18:49] <stevan> obra: ping

[19:02] *** kgftr|konobi is now known as kgftr|wedding

[19:04] <obra> ayes?

[19:11] <stevan> hey obra I have some questions for you re: RT

[19:11] <stevan> can I email you?

[19:14] <obra> ok

[19:15] *** typester is now known as sleepster

[19:16] <wolverian> hmm. what does a manual accessor look like? has Int $.year = new Proxy: STORE => ...?

[19:29] <stevan> wolverian: no, there will be an autogenerated method 

[19:29] <wolverian> stevan, so I override the method myself, right? I was hoping for a syntax that ties into the has declaratin

[19:29] <wolverian> s,in$,ion,

[19:30] <wolverian> (such as in C#: class Foo { public int Bar { set { ... } get { ... } } }

[19:30] <wolverian> s,$,), # gah

[19:31] <wolverian> has Int $.year { FETCH { } STORE { } } would work. 

[19:33] <stevan> wolverian: thats just sugar, something like that si surely possible

[19:33] <stevan> I like the C# style myself

[19:33] <stevan> but you have to ask on p6l about that

[19:33] <wolverian> right. I will.

[19:33] <wolverian> thanks. :)

[19:33] <stevan> the problem with attaching the proxy to the has declaration

[19:33] <wolverian> actually, I'm really short on time - I have to return this assignment tomorrow to university

[19:33] <stevan> is that you are really declaring a meta-object there

[19:33] <wolverian> want to post to p6l for me?

[19:34] <stevan> I will check the docs to see if there is anything related

[19:34] <stevan> and post approriately

[19:34] <wolverian> (what sucks is that the assignment is vague and I'm stumbling in the dark and it takes more time because of that)

[19:34] <stevan> you writing about p6?

[19:34] <wolverian> stevan++ thanks a lot! 

[19:34] <wolverian> stevan, no. I wish I was.

[19:35] <wolverian> the assignment is to write about 300 words about this general CS classification article by Rosenbloom in IEEE Computer magazine

[19:35] <wolverian> I have no idea what I am supposed to write about it.

[19:36] <stevan> then write about p6 ;)

[19:50] <wolverian> another thought: can I turn autocoercion on/off lexically?

[20:01] <wolverian> yet another: does autothreading apply to return values? if I return a junction, does the rest of the program autothread?

[20:23] *** Qiang_ is now known as Qiang

[20:44] <Juerd> wolverian: I'd prefer not being able to turn of automatic coercion, as that is practically disabling context

[20:44] <Juerd> wolverian: Instead, specifically indicate that you don't want a value unless <condition>.

[20:44] <Juerd> .does(Int) or fail;

[20:44] <Juerd> .isa(Int) or fail;

[20:45] <wolverian> fail when not Int

[20:45] <Juerd> Perhaps.

[20:45] <Juerd> Coercion happens only because of context

[20:46] <Juerd> A Num in Int context coerces to an Int

[20:46] <wolverian> right.

[20:46] <Juerd> Except for .as, which I think is weird.

[20:46] <Juerd> It could just be that every type, when used as a function, provides context.

[20:47] <wolverian> I don't think you can decide when a type is used as a function

[20:47] <Juerd> Which would give us Int($foo), and automatically happily $foo.Int

[20:47] <wolverian> (grammatically)

[20:47] <Juerd> Used as a function with arguments.

[20:47] <wolverian> Int $foo # type or a function call without parens?

[20:47] <Juerd> In fact: it could **BE** a function, that when called without arguments returns its value -- like undef.

[20:48] <Juerd> undef($foo) makes $foo undef, undef() returns undef.

[20:48] <wolverian> that makes sense.

[20:48] <Juerd> Int($foo) makes $foo Int, Int() returns ::Int

[20:48] <Juerd> This could work.

[20:48] <wolverian> p6l about it. it fits larry's classes-are-prototypes idea, I think

[20:49] <Juerd> Maybe I will, in a few hours or otherwise tomorrow

[20:49] <wolverian> maybe we can abolish .new()? ;)

[20:49] <wolverian> (oh so python-y)

[20:49] <Juerd> Abolish it? Why and how?

[20:49] <wolverian> class Foo { } my $bar = Foo(args);

[20:49] <Juerd> Oh my. I just realised that undef this way can *easily* be a type.

[20:50] <Juerd> Which makes the special-case-of-undef case easy too: parametrized type.

[20:50] <Juerd> There's probably some trap in here

[20:50] <wolverian> tha went over my head. :)

[20:50] <Juerd> I just hope I think of it before I p6l anything.

[20:50] <wolverian> s,tha,that,

[20:50] <Juerd> Well, remember how exceptions are interesting forms of undef?

[20:50] <nothingmuch> that's a nice idea, Juerd 

[20:50] <Juerd> What if undef was in fact a type?

[20:51] <nothingmuch> undef is what enum makes

[20:51] <nothingmuch> but parametrizable

[20:51] <Juerd> nothingmuch: I'd need to look up enum to say anything about this.

[20:51] <nothingmuch> enum generates classes that behave like values

[20:51] <Juerd> I don't know what enum in perl 6 context is. I know enum for constants, but I fail to see how that could be related to undef.

[20:51] <Juerd> I see

[20:52] <nothingmuch> so 'bool = enu <<:False(0) True>>

[20:52] <nothingmuch> Bool not bool

[20:52] <wolverian> oh, right. now I see.

[20:52] <Juerd> I need a typing break

[20:52] <nothingmuch> hmm

[20:52] <nothingmuch> for symmetry we can have Undef ;-)

[20:52] <Juerd> Sorry, I'll go watch a Scrubs episode or two first now.

[20:53] <Juerd> nothingmuch: I'm almost thinking of proposing dumping item() and just using Scalar() for that.

[20:53] <Juerd> Please stop me :) I'm mad.

[20:53] <Juerd> Oh, right, Scalar() would change type, while item() would not.

[20:53] <Juerd> Pfew.

[20:53] <Juerd> afk

[20:53] <nothingmuch> have fun

[20:54] <nothingmuch> 'sub merge'... hmm

[20:54] <nothingmuch> do we have a submerge keyword?

[20:54] <nothingmuch> it makes about as much sense as submethod

[20:54] <wolverian> merge?

[20:55] * nothingmuch is just implementing a Map adt and typed 'sub merge'

[20:55] <wolverian> I have no idea what that means. :)

[20:55] <nothingmuch> neither do i

[20:56] <wolverian> (I mean, Map adt)

[20:56] <nothingmuch> oh

[20:56] <nothingmuch> a map abstract data type is a hash

[20:56] <nothingmuch> but it's abstract, so it has methods

[20:56] <nothingmuch> and one of them is 'fmap'

[20:56] <nothingmuch> which is why i'm not using a hash ;-)

[20:57] <wolverian> right, that p6l post was yours, right? I didn't understand what 'fmap' is.

[20:57] <nothingmuch> oh

[20:57] <nothingmuch> that was luqui

[20:57] <wolverian> oh. :)

[20:57] <nothingmuch> a thing that does fmap is a called a functor

[20:57] <nothingmuch> and basically it means that if you give this thing a function

[20:57] <nothingmuch> (it's a container)

[20:57] <nothingmuch> then it will apply the function to every element inside it

[20:57] <wolverian> oh.

[20:58] <wolverian> isn't that just like map?

[20:58] <nothingmuch> and return the mapped elements in the same structure

[20:58] <nothingmuch> yes it is

[20:58] <nothingmuch> but map is taken for lists

[20:58] <wolverian> fmap is for...?

[20:58] <nothingmuch> theoretically map is 'map :: (a -> b) -> [a] -> [b]

[20:58] <nothingmuch> map = fmap

[20:58] <wolverian> okay.

[20:58] <nothingmuch> i don't know why there is a diff

[20:58] <nothingmuch> but map is just for lists, while fmap is for stuff

[20:59] <wolverian> is it recursive?

[20:59] <nothingmuch> (stuff => Functor)

[20:59] <nothingmuch> it depends on the functor

[20:59] <nothingmuch> a tree is recursively fmapped

[20:59] <nothingmuch> but a tree of trees should not fmap the subtrees

[20:59] <wolverian> hmm. okay.

[20:59] <nothingmuch> unless you fmap (\x -> fmap function x ) tree_of_trees

[21:00] <nothingmuch> since the tree is a tree of any type

[21:00] <wolverian> a tree can be of arbitrary depth, though? (ie. not a flat list)

[21:00] <nothingmuch> yes

[21:00] <wolverian> so there fmap is different from map

[21:00] <nothingmuch> i'm reducing nodes in an AST

[21:00] <nothingmuch> and I need to convert them

[21:00] <nothingmuch> and traverse them

[21:00] <nothingmuch> since the nodes are either unary

[21:00] <nothingmuch> or nary

[21:00] <nothingmuch> or maps

[21:00] <wolverian> I'd call it .walk instead of fmap

[21:00] <wolverian> or something :)

[21:00] <nothingmuch> ah

[21:00] <nothingmuch> but it isn't that

[21:01] <wolverian> oh?

[21:01] <nothingmuch> it returns a different structure, that is the same shape

[21:01] <nothingmuch> but a copy

[21:01] <wolverian> oh.

[21:01] <nothingmuch> walk doesn't have a return value, I think

[21:01] <nothingmuch> in my head, anyway

[21:01] <wolverian> yeah.

[21:01] <wolverian> my $result = $foo.deep_copy.walk(&func);

[21:02] <nothingmuch> yup

[21:02] <nothingmuch> except that fmap is potentially lazy in a lazy langauge

[21:03] <wolverian> isn't it potentially lazy in perl6 too (if it had it)?

[21:03] <wolverian> rephrase: can it be implemented as such?

[21:03] <nothingmuch> i guess

[21:03] <nothingmuch> ofcourse

[21:03] <nothingmuch> every problem in computer science can be solved by another level of inderection

[21:03] <nothingmuch> (except the problem of too many levels of indirection)

[21:03] <wolverian> rephrase again, then: would it make sense to do so in perl6?

[21:03] <nothingmuch> just use subreferences =)

[21:04] <nothingmuch> or lazy { } (larry implied we have it now)

[21:04] <wolverian> oh, do we have lazy sub args?

[21:04] <wolverian> sub foo ($bar is lazy) { ... }

[21:04] <nothingmuch> multi sub fmap (&f, [$x, *@xs]) { lazy { [ $x, fmap &f @xs ] } }

[21:05] <nothingmuch> i hope so

[21:05] <wolverian> if so, how can I force evaluation of $bar?

[21:05] <nothingmuch> i dunno

[21:05] <nothingmuch> =)

[21:06] <wolverian> sub foo ($bar is lazy --> $bar) { change the environment; return $bar; LEAVE { change the environment back } }

[21:07] <wolverian> that is, change the environment for the duration of the evaluation of $bar, then change it back

[21:07] <wolverian> ie. how to evaluate $bar without using it in a context that requires evaluation?

[21:07] <wolverian> (I mean, without mutating it.)

[21:07] <wolverian> (eval $bar? :)

[21:08] <QtPlatypus> wolverian: Evaluate $bar in an eger context

[21:08] <wolverian> oh. return eager $bar?

[21:08] <wolverian> # :)

[21:09] <wolverian> return $bar as Eager;?

[21:20] *** rafl_ is now known as rafl

[21:38] <Juerd> I p6l'ed it.

[21:41] <Juerd> It's a little incoherent, heh.

[21:49] <wolverian> Juerd, nice post. thanks!

[21:51] <Juerd> I usually write my ideas directly in mail-form

[21:52] <Juerd> After that I talk about it and think it over some times before sending the final version eventually

[21:52] <rafl> http://ftp.us.debian.org/debian/pool/main/p/pugs/ :-)

[21:52] <Juerd> Summarizing something that spontaneously came up on irc is a very different thing.

[21:52] <Juerd> It's hard to find good structure for the message.

[21:53] <wolverian> agreed.

[21:57] <spinclad> rafl: 404 Not Found

[21:57] <Juerd> rafl: Wow, neat!

[21:58] <Juerd> rafl: How often is that updated? Only releases, or snapshots?

[21:58] <spinclad> i guess it hasn't reached all mirrors yet...  ok at ftp.debian.org (for me, this time)

[21:59] <spinclad> rafl++  # yay!

[21:59] <rafl> spinclad: It's on ftp.us and ftp.de, as far as I know.

[21:59] <rafl> Juerd: Releases, atm. But I also plan to upload snapshots to experimental.

[22:00] <rafl> haskell-src-exts also got in today, btw.

[22:01] <Juerd> rafl: Any specific reason for not using snapshots as a pugs-svn package?

[22:01] <spinclad> i look again and it's at ftp.us, it may be luck of the round robin yet

[22:03] <rafl> Juerd: Yes, I don't like that. What don't you like about uploading to experimental?

[22:04] <spinclad> the naming schemes are different, don't they have to be different packages?

[22:05] <spinclad> (versioning schemes)

[22:05] <rafl> What it different about what naming schemes?

[22:05] <rafl> spinclad: Yes, let's wait until the mirror update is complete.

[22:06] <spinclad> 6.2.9 v. xxx.r7000

[22:06] <rafl> Ah, it is (for ftp.de.debian.org :-)

[22:06] <rafl> spinclad: I'll use 6.2.9+svn7000 or something like that.

[22:07] <spinclad> (or 6.2.9.r7000 maybe)

[22:07] <rafl> spinclad: ${last stable revision}+r${svn revision}-${debian revision} I guess.

[22:07] <spinclad> yes, that should order properly i guess

[22:08] <Juerd> rafl: Only one lame reason :) Extra effort when installing :)

[22:08] <rafl> Juerd: That doesn't justify a second package, of course. :-)

[22:09] <spinclad> awk, bbl &

[22:12] <Juerd> rafl: I know :)

[22:12] <rafl> As well as the extra effort for me when building it. ;-)

[22:22] <luqui> Juerd, your proposal is interesting.  I have to say I like the concept of type names being context applicators better then the notion of them being interesting undefs...

[22:22] <Juerd> Thanks

[22:23] <Juerd> I forgot about that kind of interesting undef, by the way. The ones I referred to are exceptions.

[22:23] <luqui> yeah

[22:23] <Juerd> Oh, you replied to

[22:23] <Juerd> *reads*

[22:23] <Juerd> What's an identity map?

[22:24] <luqui> sub identity ($x) { $x }

[22:24] <luqui> for various types on $x :-)

[22:24] <Juerd> Doesn't really help me understand your reply though :)

[22:24] <luqui> don't worry about that part

[22:24] <Juerd> Okay

[22:25] <luqui> I was basically saying that for a type Foo, you'd be defining a function sub Foo (Foo $x) { $x }

[22:25] <luqui> that is, does nothing but return its argument

[22:25] <Juerd> Re ~ being Str(), yes, in my mind it currently is.

[22:25] <Juerd> Yep, that's what it'd do :)

[22:25] <Juerd> sub item ($foo) { $foo }

[22:25] <Juerd> Same thing :)

[22:26] <luqui> oh, speaking of which

[22:26] <luqui> ?eval my $x = 4; undef($x);  say $x

[22:27] <evalbot_7008> Error: cannot cast from VUndef to Pugs.AST.Internals.VCode (VCode) 

[22:27] <luqui> ?eval my $x = 4; undefine($x);  say $x

[22:27] <evalbot_7008>  bool::true 

[22:27] <luqui> good

[22:27] <wolverian> that looks like a start of a very interesting thread

[22:27] <wolverian> s,a start,the start,

[22:29] <Juerd> If so, it'll be a widely fanned out one, touching much of the language.

[22:29] * luqui realizes he is using the word "notion" a lot today :-)

[22:29] <luqui> Juerd, touching the guts of much of the language

[22:29] <Juerd> luqui: At least you didn't describe that as having a notion.

[22:30] <luqui> but the outside shouldn't change much, we know we're pretty happy with that

[22:30] <luqui> but that's how most of the proposals these days are going

[22:30] <Juerd> Yeah

[22:30] <Juerd> I really do hope to get Type as functions providing context, though

[22:30] <Juerd> It fits so much better with my image of how the rest of how context works 

[22:31] <luqui> well, don't get too attached to it :-)

[22:31] <Juerd> I'm not.

[22:31] <Juerd> I'm attached to <->, and that hurts enough already :)

[22:31] * luqui recalls the few proposals he's been attached to (eg. pure multimethods)

[22:31] <luqui> it's painful to argue them

[22:32] <luqui> (especially when Damian is the one against you :-)

[22:32] <Juerd> I am attached to .foo meaning $_.foo unconditionally

[22:32] <Juerd> Regardless of whatever, if any, shortcut for $?SELF.foo

[22:32] <wolverian> I agree with that one.

[22:32] <luqui> yeah, Larry is swinging that way too

[22:32] <Juerd> People do seem to think I really want ./foo -- I like it, but I could live without.

[22:32] <luqui> he just doesn't want to say so

[22:32] <luqui> because people whine

[22:33] <wolverian> a default self() would be fine with me. (whatever its name, but not $?SELF because that is ugly.)

[22:33] <Juerd> Nobody's with Larry on this point, so the current ruling can't be final if others have commit access :)

[22:34] <Juerd> brb  # in bed, with laptop...

[22:35] <wolverian> what, you're going porn surfing? :)

[22:35] * luqui was going to say # off for a quickie

[22:36] <wolverian> on an unrelated note, I've been using Eclipse to code some Java lately and I like how smart it is about the syntax.

[22:36] <wolverian> refactoring, inserting ) and " and such automatically and sensibly. that would be nice for perl too.

[22:36] <wolverian> anyway, that's an old subject, and I think I need something to eat now.

[22:37] * luqui was actually pondering an editor that would hook into the type inferencer

[22:37] <luqui> and red-underline type errors like Word does with spelling errors

[22:38] <luqui> especially for Haskell, but if Perl gets a static-type-inferenced dialect, it'd be nice for that too

[22:38] <wolverian> right. sounds nice.

[22:39] <wolverian> would be nicer if it could fix them for you.

[22:40] * luqui has trouble making his brain do that

[22:40] <wolverian> (which goes into DWIM area and possible errors in it, of course.)

[22:40] * luqui doubts a computer could

[22:40] <wolverian> right.

[22:40] <wolverian> Eclipse does what you describe, but that's trivial for a type-annotated language.

[22:41] <buu> Any language that requires a special editor to use properly, sucks.

[22:41] <luqui> we're not saying you need the editor to use it properly

[22:41] <luqui> we're just saying that it helps :-)

[22:41] <luqui> like office assistant, but smarter than a curious three year old 

[22:42] <wolverian> I'd really like some standard metadata things specified as well

[22:42] <luqui> eg?

[22:42] <wolverian> method documentation that can be trivially extracted, etc

[22:42] <wolverian> class interface + usage 

[22:42] <luqui> nonononononono

[22:42] <wolverian> hm?

[22:43] <luqui> this is my whole reason for knocking down javadoc-style documentation for perl

[22:43] <luqui> perl has a strong culture in documentation

[22:43] <kakos> Don't listen to luqui.  He is wrong in absolutely everything he does.

[22:43] <luqui> and people just don't use modules that have no documentation

[22:43] <wolverian> that is a good point. 

[22:43] <luqui> so if docs are generated automatically, the cultural pressure to write decent docs is gone

[22:44] <Juerd> re

[22:44] <luqui> <tab>

[22:44] <luqui> DWIM english autocomplete :-)

[22:44] <Juerd> wolverian: Porn surfing? No.

[22:44] <wolverian> I'd just like a method of attaching or referencing POD sections to classes and such

[22:45] <Juerd> wolverian: But I do enjoy IRC in bed, before sleeping. I hate books, you see :)

[22:45] <wolverian> Juerd, hm, why do you hate books?

[22:45] <Juerd> It's psychological

[22:45] <Juerd> I never finish books.

[22:45] <kakos> You still have to write decent docs with javadoc-style documentation

[22:45] <luqui> kakos, no, you still have to write *docs* with javadoc-style documentation

[22:45] <Juerd> So I can't stand them. It feels like they keep information from me, while it is me who doesn't get it from them.

[22:46] <luqui> that is, here is what each of my classes does, and here is what each of the methods does

[22:46] <wolverian> Juerd, why don't you finish books?

[22:46] <luqui> but perl culture demants a DESCRIPTION section that is almost tutorialesque and shows you how to *use* the library

[22:46] <Juerd> Almost all books manage to bore me after a while.

[22:46] <wolverian> luqui, right.

[22:46] <Juerd> luqui: Oh, not really

[22:47] <wolverian> luqui, I would like to make that standard to the bundle/package/whatever, or at least recommended, and then attach the specific documentations to the untis they describe

[22:47] <kakos> It might be better if perl culture demanded a description section instead of demanting one.

[22:47] <Juerd> luqui: I've seen the cultural demand more as: textual explanation followed by reference material

[22:47] <wolverian> Juerd, I find books extremely interesting. :)

[22:47] <Juerd> wolverian: So do I.

[22:47] <luqui> Juerd, fair enough...

[22:47] <luqui> depends on the module of course

[22:47] <Juerd> luqui: I can absolutely not stand CGI.pm-like documentation

[22:47] <wolverian> s,untis,units,

[22:47] <luqui> Juerd, but Parse::RecDescent?

[22:47] <Juerd> Let me see. I haven't seen that in a while.

[22:48] <Juerd> luqui: I don't like it in the main documentation, but I do like tutorials like that.

[22:49] <Juerd> IMO, documentation should in general provide stuff for reference, and a quick overview of possibilities

[22:51] <luqui> hmmm, I guess the thing I like about perl docs most is the SYNOPSIS section

[22:52] <Juerd> Depends on how it's handled

[22:52] <Juerd> Too often, the SYNOPSIS is a complete program of which only three lines are relevant

[22:53] <luqui> depends on the module whether that's good or bad

[22:53] <Juerd> This happens whenever an author doesn't see clearly that his module is actually modular and not part of a whole :)

[22:54] <Juerd> One of my favourite examples of that is DBIx::XHTML_Table

[22:54] <Juerd> Which isn't dependent on DBI at all

[22:55] <luqui> huh

[22:55] <Juerd> It does connect, prepare and execute

[22:55] <Juerd> But there's really no reason why this is in this module

[22:55] <Juerd> And you can in fact use it without DBI, or --this is what I do-- with DBI, but without telling it.

[22:55] <nothingmuch> damnit

[22:56] <Juerd> It just formats an array of arrays as an xhtml table...

[22:56] <luqui> nothingmuch, DAMNIT

[22:56] <wolverian> that looks like interface crud for the sake of performance optimisation.

[22:56] <nothingmuch> es, damnit

[22:57] <Juerd> What are the damnits about?

[22:58] <wolverian> I take that back. there is absolutely no reason for this module to have anything to do with DBI.

[22:58] <nothingmuch> something is inexplicitly not working

[22:58] <Juerd> It's still a nice module

[22:58] <nothingmuch> from that I can infer that I'm an idiot

[22:58] <nothingmuch> and it's frustrating to figure that out

[22:58] <luqui> theorem: something not working => nothingmuch is an idiot

[22:58] <luqui> proof?

[22:59] <Juerd> hehehe

[22:59] <nothingmuch> given condition a where status(a) == working

[23:00] <nothingmuch> and a condition a' = f(a) where status(a') == broken

[23:00] <nothingmuch> and a function g where g(a, a') = f

[23:00] <nothingmuch> if nothingmuch cannot solve g then nothingmuch is an idiot

[23:00] <luqui> lol

[23:00] <nothingmuch> in short - i have no clue what I did to break it

[23:00] <nothingmuch> but it broke!

[23:00] <luqui> version control?

[23:00] <nothingmuch> i have the original

[23:01] <nothingmuch> this is very odd

[23:01] <Juerd> diff it

[23:01] <nothingmuch> i did

[23:01] <Juerd> So, what's different?

[23:01] <nothingmuch> it reduces recursive thunks into (my $x = Thunk( Val($x) )

[23:02] <pdcawley> Is there a hackathon planned at EuroOSCON?

[23:04] <Juerd> I have no idea

[23:04] <Juerd> What is planned, or more: being planned, is an extra amsterdam.pm social meeting

[23:05] <Juerd> Not as part of euroscon, but because lots of perl minded people from far away will be in this country.

[23:05] <luqui> nothingmuch, when you say "my $x = Thunk(Val($x))", how abstract are you speaking?

[23:06] <nothingmuch> it's recursive

[23:06] * luqui was just making sure you weren't generating code that said that

[23:06] <nothingmuch> nope

[23:07] <nothingmuch> that's dumper output

[23:07] <nothingmuch> (i submitted a bug about it today ;-)

[23:08] <nothingmuch> shit

[23:08] <nothingmuch> it's the fucking pretty printer!

[23:09] <luqui> there goes the sufficient condition in your proof

[23:09] <nothingmuch> yes

[23:10] <nothingmuch> if i don't pretty print the compiled tree there is no infinite loop

[23:10] <wolverian> heh. I have a strange urge to say "lol" out loud.

[23:10] <luqui> eeeeeewww.

[23:10] <luqui> (to both preceding statements)

[23:10] <wolverian> hey, it's 2am. I'm allowed to say silly things.

[23:11] <luqui> okay, it was more an "eeeeeewww" to nothingmuch and a "haha" to you

[23:11] <nothingmuch> wolverian: where do you live?

[23:11] <wolverian> nothingmuch, home.

[23:11] <nothingmuch> beh

[23:11] <wolverian> (I mean, my home.)

[23:11] <wolverian> how do you mean?

[23:11] <nothingmuch> your time zone is mine, and that normally does not compute

[23:12] <wolverian> oh. Finland.

[23:12] <nothingmuch> ah

[23:12] <luqui> If you want something finnished, wolverian is your man

[23:12] <luqui> ahaaa, ahaaa, ahaaa

[23:12] <wolverian> heh heh heh.

[23:13] <nothingmuch> bwa

[23:13] * nothingmuch won't touch finland with a ten foot pole

[23:13] <nothingmuch> mainly because poland is farther than 10 feet from finland

[23:13] <nothingmuch> and there are no poles that tall anyway

[23:13] <nothingmuch> bwa

[23:14] <nothingmuch> i don't know any more like these, except the ones on Turkey

[23:14] <nothingmuch> but i think we've had enough, right?

[23:14] <wolverian> I only know jokes about Swedes and they're all reducible to "they're all homos"

[23:14] * nothingmuch has been doing lots of reductions

[23:14] <wolverian> that's why I said it. :)

[23:15] <buu> wolverian: Let's hear one!

[23:20] <wolverian> I don't actually remember any.

[23:20] <wolverian> I suck at jokes. :)

[23:21] <buu> =[

[23:21] <wolverian> anyway, time to sleep. I have six hours until morning

[23:22] <wolverian> cheers.

[23:23] <nothingmuch> okay, it unboke

[23:29] <Juerd> Good night

[23:52] * rafl is going to prepare an svn snapshot package for Debian now..

