[01:55] <Darren_Duncan> hiya

[01:55] <Darren_Duncan> right now I'm in a car on the way to OSCON, in north Washington

[01:56] <Darren_Duncan> speaking to you live over a GPRS bluetooth modem

[03:39] <brentdax> Man, $0 -> $1 is gonna take a real long time to get used to.

[03:39] <brentdax> (Or rather, the other way around.)

[03:48] <brentdax> ...could Undef be considered Perl 6's bottom type?  It's compatible with any type, any method can be called on it with any parameter...

[03:55] <svnbot6> r5967 | putter++ | Copied modules/Grammars/rx_grammar.pl to rx_grammar0.pl.  So PMichaud can overhaul rx_grammar.pl with abandon, while putter continues incrementally with rx_grammar0.pl.

[03:55] <svnbot6> r5968 | autrijus++ | * scope defaulting for parameters should not apply to primitives,

[03:55] <svnbot6> r5968 | autrijus++ |   as they are not supposed to have a lexical scope anyway.

[05:04] <putter> a quick release engineering note - the current failures of t/unspecced/p5 are odd.  roundtrip.t and method.t fail in make test harness, but work when run individually.  array.t fails in both, but in make test says

[05:04] <putter> No compatible subroutine found: "&my_elems"

[05:05] <putter> and by itself says

[05:05] <putter> No compatible subroutine found: "&elems"

[05:05] <putter> Odd.  Good night.

[05:13] <autrijus> hi stevan 

[05:13] <autrijus> how's life?

[05:13] <svnbot6> r5969 | autrijus++ | * "-Inf" should numify as -Inf, not 0.0.

[05:13] <autrijus> stevan: you up for changelogging for the oscon release? if not I can do it too, but I'm still chasing testfails

[05:18] <autrijus> hm, anyone remember if there was a ruling on mutating map/grep?

[05:18] <autrijus> map { $_++ } @_;

[05:18] <autrijus> according to S29 they are not mutating

[05:18] <svnbot6> r5970 | autrijus++ | * The `end` method on lists can't be parsed as an unary op...

[05:18] <svnbot6> r5971 | autrijus++ | * some TODOs; mutating map/grep needs a ruling

[05:18] <autrijus> but I vaguely remember some discussion

[05:43] <brentdax> autrijus: did you see my musing about Undef above?

[05:43] <autrijus> sub identity (Any $x) returns Undef {}

[05:43] <autrijus> somehow not ringing a bell

[05:44] <brentdax> True.

[05:44] <autrijus> also in p5, undef can't instantiate a list.

[05:44] <autrijus> or a hash for that matter

[05:45] <stevan> hola autrijus 

[05:45] <autrijus> and unless you want to change the semantics of (@x = undef) so @x is now a unthrown exception

[05:45] <autrijus> I don't think using Undef as Bot will fly.

[05:45] <autrijus> heya stevan

[05:46] <stevan> when do you want the changelog for? I am about to get some sleep actually

[05:46] <brentdax> Alright.  It just seemed like All had magic properties, and Undef had magic properties, and maybe the magic lined up.

[05:46] <autrijus> brentdax: it seems to me that undef is still a scalar

[05:46] <autrijus> and not (say) an array

[05:46] <autrijus> stevan: I don't know, in the next 36 hours

[05:47] <stevan> autrijus: ok, I can do that :)

[05:47] <autrijus> stevan++

[05:47] <stevan> autrijus: one quick questions before I sleep :)

[05:48] <autrijus> sure

[05:48] <stevan> actually more than one question,.. but i will start with one :)

[05:48] <stevan> is the eventual goal to have the metamodel in pure PIL?

[05:48] <autrijus> go ahead :)

[05:48] <autrijus> well, pure PIL is the same as pure Perl6

[05:48] <autrijus> so to speak

[05:49] <stevan> but isn't PIL a subset of Perl 6?

[05:49] <autrijus> I think it makes sense to base the reference implementation on that, yes.

[05:49] <autrijus> well, that depends on how you define "subset"

[05:49] <stevan> ok

[05:49] <autrijus> Perl 6 is the external representation

[05:49] <autrijus> PIL is the internal language

[05:49] <stevan> ok

[05:50] <autrijus> multiple perl 6 programs may compile to the same PIL node

[05:50] <autrijus> (say "Hello")  and  (say    "Hello") for example.

[05:50] <stevan> but ideally the metamodel will be written in a way that is pretty close to pure PIL

[05:50] <autrijus> (actually, no, they will differ in PPos, but what the heck)

[05:50] <stevan> :)

[05:50] <autrijus> stevan: no, any idiomatic Perl 6 that does not define new classes will do

[05:51] * QtPlatypus asks "So Perl6 is to PIL as M-expressions are to S-expressions?"

[05:51] <stevan> ok

[05:51] <autrijus> QtPlatypus: yes

[05:51] <stevan> autrijus: so what is my smallest feature set?

[05:51] <autrijus> stevan: perl5 without AUTOLOAD

[05:51] <autrijus> i.e. you are free to use namespaces and closures.

[05:51] <stevan> and no bless

[05:51] <autrijus> you can bless, you just can't do method calls :)

[05:51] <stevan> ok

[05:51] <autrijus> (so the bless is just tagging)

[05:52] <stevan> excellent

[05:52] <autrijus> that will enable the runtime to only implement the functional core

[05:52] <autrijus> and automagically receive a OO core

[05:52] <stevan> yes

[05:52] <autrijus> and then it can optimize from there.

[05:52] <stevan> autrijus++ 

[05:53] <stevan> this is what I was hoping you would say

[05:53] <autrijus> :D next question?

[05:54] <stevan> no more questions actually :)

[05:54] <stevan> I am about to check in some work from this weekend

[05:54] <stevan> it is kind of messy

[05:54] <autrijus> messy is good :)

[05:55] <stevan> but it implements a MetaClass with no AUTOLOAD, and minimal method calls (like 2 or 3 in total in the entire thing)

[05:55] <svnbot6> r5972 | autrijus++ | * It's now okay to use a module without &import defined in it.

[05:55] <autrijus> oooh.

[05:55] <stevan> it also bootstraps the MetaClass so that it isa Perl6::Object

[05:55] <autrijus> and then you can turn them into inside-out objects

[05:55] <autrijus> aka closure dispatch

[05:55] <autrijus> for those 2 or 3 calls

[05:55] <stevan> no need

[05:55] <autrijus> and then we'll be there

[05:55] <stevan> I just call local functions

[05:55] <autrijus> oh? normal function calls and case-expression will do?

[05:55] <autrijus> excellent

[05:56] <autrijus> stevan++

[05:56] <stevan> :)

[05:56] <stevan> I am really enjoying the CLOS MOP book too

[05:57] <autrijus> nice

[05:57] <stevan> although I can only get a few pages along before I have to go work onthe metamodel

[05:57] <autrijus> :)

[05:57] <stevan> it gets my mind working :)

[05:57] <stevan> ok, so I am going to check in the mess, and get some sleep

[05:57] <autrijus> okay. enjoy!

[05:57] <stevan> I have plans to clean it up 

[05:58] <stevan> :)

[05:58] <autrijus> my plan is to prototype it in PIL runcore

[05:58] <autrijus> and then use quickcheck to establish observable/provable invariants

[05:58] <autrijus> when this thing is sound (so I can write down using scary academic notation), backport from _that_ to idiomatic perl6

[05:58] <autrijus> meanwhile we can release 6.28.0 before that

[05:59] <autrijus> and get people experimenting with the model/runcore

[05:59] <stevan> I figure I can remove the rest of the AUTOLOAD (the part used by the regular classes) very easily

[05:59] <autrijus> wonderful

[05:59] <autrijus> I want to see the mess now :)

[05:59] <stevan> yes yes

[05:59] <stevan> writing my commit message :)

[05:59] <autrijus> :)) I'll bbiab

[06:02] <stevan> autrijus: commited r5973

[06:02] <svnbot6> r5973 | Stevan++ | Perl6::MetaModel - (p5)

[06:02] <svnbot6> r5973 | Stevan++ | * MetaClass does not use AUTOLOAD anymore, everything goes through ::dispatch

[06:02] <svnbot6> r5973 | Stevan++ | * MetaClass isa Perl6::Object (once everything is bootstrapped that is)

[06:02] <svnbot6> r5973 | Stevan++ | * MetaClass test has been de-sugared

[06:02] <svnbot6> r5973 | Stevan++ | * misc. other bootstrapping things as well

[06:03] <stevan> here is a list of a few things to look at:

[06:03] <stevan> MetaClass.pm - all the bootstrapping is done inside the meta() method

[06:03] <stevan> this is the only remaining method call for MetaClass right now

[06:04] <stevan> I am thinking this can be replaced by a global ::meta() function which will maybe lookup the metaclass instance in a global registry or something

[06:04] <stevan> (I am stealing this from CLOS, which has a find-class function)

[06:05] <stevan> next look in MetaModel at the ::dispatch function

[06:05] <stevan> it is ugly right now, but I think I can clean some stuff up.  

[06:07] <stevan> I fall into an infinite loop if MetaClass does not have a specific dispatch() function. I know why, but I am not sure how to break that circularity, so right now it is specialized, and just avoids method calls

[06:07] <stevan> The bootstrapping takes place at the bottom of this file (line 291)

[06:08] <stevan> all it does it load the Perl6::Object module and then makes Perl6::MetaClass->isa(Perl6::Object)

[06:08] <stevan> oh, and the 3rd arg to dispatch is a boolean for SUPER calls

[06:09] <stevan> I am going to remove that, I think this is a bad way to go about it, and I also have some thoughts as the relevancy of SUPER

[06:09] <stevan> (but that is for p6l)

[06:09] <stevan> Also look at line 82 of Perl6/Class.pm

[06:10] <stevan> it is a special case for building the Perl6::Object metaclass

[06:10] <stevan> all other classes build their metaclasses normally, the new() method defined in Perl6::Object

[06:11] <stevan> I am going to completely overhaul Perl6::Class

[06:11] <stevan> it will look more like the JS version when I am done I think

[06:12] <autrijus> ok.

[06:12] <stevan> I also have some plans for how to treat methods

[06:12] <stevan> I can use closures to handle the details of submethods and private methods

[06:12] <autrijus> I believe that's as lwall intended.

[06:12] <stevan> by just wrapping them 

[06:13] <stevan> yes, I think it is

[06:13] <autrijus> i.e. they should not be distinguishable from closure factories

[06:13] <autrijus> if it is that's a bug etc

[06:13] <autrijus> ok. I'll consume the Diet MetaModel on my way to $client

[06:13] <stevan> ok, enjoy

[06:13] <autrijus> I need to run. see you tomorrow when you're up :)

[06:13] <autrijus> &

[06:14] <stevan> yes

[06:14] <stevan> :)

[06:14] <stevan> nite :)

[06:22] <brentdax> Is there going to be a Pugs release RSN?

[06:23] * QtPlatypus thinks that the next release may co-incide with the new PIL. "But that is pure speculation on my part"

[06:29] <autrijus> brentdax: yes, in time to ingy's talk

[06:29] <autrijus> 36hrs is the current plan

[06:29] <autrijus> from now

[06:29] <brentdax> Alright.  I'll probably make sure that WWW::Kontent's first release runs with that version, even if I don't release at the same time.

[06:30] <autrijus> cool!

[06:31] <brentdax> (It's just a preview--no user system, parsers, or complete documentation--but I think it'll be a good demo...)

[06:31] <autrijus> indeed

[06:31] <autrijus> be sure to post to p6a when you're there :)

[06:31] <autrijus> I'll bbiab

[06:51] <Aankhen``> ?eval $?PUGS_VERSION

[06:51] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.8, July 13, 2005 (r5973)' 

[07:09] <brentdax> Okay, this bug is driving me *nuts*.

[07:10] <brentdax> It's that "call a method with the same name on an attribute" thing again, but in a different place in the code.

[07:10] <brentdax> And with a different method name.

[07:10] <brentdax> Although this time there are no subclasses involved...hmm.

[07:12] <brentdax> Yes, got a test case!

[07:13] <brentdax> pugs -e 'class A { method foo() { say "A::foo" } }; class B { has $.a; submethod CREATE() { $.a=A.new } method foo() { say "B::foo"; $.a.foo } } B.new.foo'

[07:13] <brentdax> Should print "B::foo\nA::foo\n", but instead it repeatedly prints "B::foo\n".

[07:15] <brentdax> ...wait, argh, no.

[09:26] <nothingmuch> stevan: ping

[10:29] <svnbot6> r5974 | iblech++ | t/builtins/lists/mutating_listops: Added link to p6l post.

[13:07] <autrijus> rehi

[13:08] * autrijus ponders between doing some PIL2 charting and chatting and relenging

[13:17] <scook0> autrijus: there's some fancy stuff in src/PIL.hs that's breaking Haddock at the moment

[13:17] <scook0> all that %i stuff -- just so you know

[13:20] <autrijus> hm, maybe linear implicit parameters ain't that nice after all

[13:21] <wolverian> heh, the pizza guy looked just like Larry

[13:21] <autrijus> oh?

[13:22] <autrijus> 3 =:= 3 # patent nonsense, right?

[13:22] <autrijus>        There is also an identity test, "=:=", which tests whether two names

[13:22] <autrijus>        are bound to the same underlying variable.  "$x =:= $y" would return

[13:22] <autrijus>        true in the above example.

[13:23] <autrijus> in that case, there need never be a tied rvalue

[13:42] <stevan> nothingmuch: pong

[13:43] <stevan> good morning all 

[13:47] <autrijus> yo stevan

[13:47] <autrijus> I'd like to discuss a weird issue with you if you have a bit time.

[13:47] <stevan> autrijus: sure

[13:47] <autrijus> ok. consider

[13:47] <autrijus> $x = 1;

[13:47] <autrijus> vs

[13:47] <autrijus> $x = $x;

[13:47] <autrijus> the latter actually means

[13:47] <autrijus> $x = FETCH($x);

[13:48] <autrijus> (or rather fetch(tied($x)) , but I'll just write FETCH)

[13:48] <stevan> ok

[13:48] <autrijus> and the expression can be written as

[13:48] <autrijus> $x.STORE($x.FETCH)

[13:48] <autrijus> vs

[13:48] <autrijus> $x.STORE(1)

[13:48] <autrijus> okay so far?

[13:48] <stevan> (tied() being the means of accessing the underlying object, correct?)

[13:48] <autrijus> yes

[13:49] <autrijus> ok. so we are dealing with two types

[13:49] <autrijus> one is (Scalar of Int)

[13:49] <autrijus> one is (Int)

[13:49] <stevan> yes

[13:49] <autrijus> you can assign into the first but not the second

[13:49] <autrijus> you can add with the second but not (directly) the first

[13:49] <stevan> correct

[13:49] <autrijus> so, by writing

[13:49] <autrijus> sub f (Int $x) { ... }

[13:50] <autrijus> we are actually saying

[13:50] <autrijus> sub f (Scalar of Int named '$x') { ... }

[13:50] <stevan> hmmm

[13:50] <stevan> yes

[13:50] <autrijus> with the coercion rule that promotes Int into a fresh container Int

[13:50] <autrijus> I mean, container of Int

[13:50] <autrijus> but!

[13:50] <stevan> :)

[13:50] <autrijus> we are told that the default argument is (is constant)

[13:51] <autrijus> which seems to me that is actually _removing_ the (Scalar of) part

[13:51] <autrijus> instead of as we assumed in hackathon, some weird readonly shim layer on it

[13:51] <autrijus> you agree with this intuition?

[13:51] <stevan> yes, what you say make sense

[13:51] <stevan> it is not good

[13:51] <stevan> but it makes sense

[13:51] <stevan> the logic is clean

[13:52] <autrijus> cool.

[13:52] <autrijus> so, it seems that

[13:52] <stevan> what does that mean though?

[13:52] <autrijus> it means that

[13:52] <autrijus> sub f ($x is constant) { \$x }; ${f($_)} = 3

[13:52] <autrijus> is instadeath

[13:52] <stevan> yes, that makes sense

[13:53] <autrijus> as we discussed in hackathon, but this time it can be detected statitcally

[13:53] <autrijus> instead of till runtime

[13:53] <autrijus> since it amounts to be saying

[13:53] <stevan> cool :)

[13:53] <autrijus> ${\3} = 3

[13:53] <autrijus> now, this worldview is all well if we only have objects.

[13:53] <autrijus> but!

[13:53] <autrijus> we also have collection :-/

[13:54] <autrijus> if $x is (Scalar of Int) and 3 is (Int)

[13:54] <autrijus> and if @x is (Array of Int)

[13:54] <autrijus> what is (1,2,3,4) ?

[13:54] <stevan> ouch

[13:54] <autrijus> that is the core ambiguity

[13:54] <stevan> an array of constants

[13:54] <autrijus> an array of constants?

[13:54] <autrijus> no, it's a constant array of constants.

[13:54] <stevan> ok, even worse :)

[13:55] <autrijus> but the strange thing is, if you start using it destructively

[13:55] <autrijus> ($x, $y) = (1,2);

[13:55] <autrijus> then it magically behaves as a tuple

[13:55] <autrijus> so, what does a constant array mean again?

[13:55] <integral> the LHS isn't a List of Scalar of Int ?

[13:56] <autrijus> integral: it is.

[13:56] <nothingmuch> jp;as

[13:56] <nothingmuch> hola stevan 

[13:56] <nothingmuch> actually it's no longer relevant

[13:56] <stevan> hey nothingmuch 

[13:57] <stevan> autrijus: maybe ($x, $y) = (1,2); is just sugar

[13:57] <autrijus> integral: so can we spell "Array of" as "Scalar of List of" ?

[13:57] <autrijus> think carefully before answering, as I was stuck right here :)

[13:57] <autrijus> (and still am)

[13:57] <stevan> for something like:  (let (multi-value-bind ($x $y)) (1 2))

[13:57] <mjl69> hi! :-)

[13:57] <autrijus> stevan: that's ($x, $y) := (1,2)

[13:58] <autrijus> stevan: the assignment is really destructive

[13:58] <integral> hrm,  I'm thinking no, since p5 has taught me that List != Array

[13:58] <stevan> (forgive my LISPishness)

[13:58] <stevan> autrijus: why is it destructive?

[13:58] <autrijus> stevan: ($x, $y) = ();

[13:58] <integral> hi mjl69 

[13:58] <mjl69> could someone take a look at this when they have a second... http://nopaste.snit.ch:8001/3538 maybe it's a common installation problem...

[13:58] <mjl69> integral: hi!

[13:58] <stevan> why is ($x, $y) = (); not the same as ($x, $y) = (undef, undef);

[13:58] <integral> autrijus: isn't that where a List is different from an Array?

[13:59] <autrijus> mjl69: macosx?

[13:59] <mjl69> yeah.

[13:59] <autrijus> mjl69: gcc_select to 3.3 already and make clean'ed?

[13:59] <mjl69> I definitely did gcc_select to 3.3.  I did make clean one time but I could try it again.

[14:00] <autrijus> mjl69: try doing that again, maybe you had 4.0 .o files

[14:00] <mjl69> autrijus: thanks, back in a few minutes...

[14:00] <autrijus> stevan: it is, effectively. let me think about it

[14:00] <Yaakov> What an eager guy, that mjl69.

[14:00] <autrijus> my @a := ($x, $y); push @a, 1;

[14:00] <autrijus> that should be error right?

[14:01] <mjl69> :)

[14:01] <autrijus> my @a := [$x, $y]; push @a, 1; # and this should work?

[14:01] <integral> if the List is not promoted to an Array, yes, imho

[14:01] <nothingmuch> What a cynical guy, that Yaakov.

[14:01] <autrijus> What a guy, that nothingmuch.

[14:01] <Yaakov> I am the inverse of a cynic, it turns out.

[14:01] <Yaakov> Heh.

[14:01] <autrijus> mm very cinycal

[14:02] <stevan> autrijus: neither of those examples make sense to me

[14:02] <stevan> pushing on an array ref should be no different then pushing on an array

[14:02] <autrijus> stevan: aw. let's try another form.

[14:02] <stevan> oh wait, sorry, didnt see the :=

[14:02] <autrijus> ($x, $y).push(1);

[14:02] <autrijus> better? :)

[14:02] <stevan> ok

[14:02] <stevan> hmm, thats a problem

[14:03] <autrijus> what I'm saying is whether we can describe an array as a container of a list

[14:03] <stevan> what about: my @b = (1, 2, 3).push(4, 5, 6);

[14:03] <autrijus> in exactly the same way a scalar as a container of a value.

[14:03] <autrijus> you mean

[14:03] <autrijus> (my @b = (1, 2, 3)).push(4, 5, 6);

[14:03] <stevan> no

[14:03] <stevan> I mean what I typed.

[14:03] <autrijus> if the rhs is an error then the expression as a whole is an error

[14:04] <stevan> what I am thinking is that maybe (1, 2, 3) can be autopromoted

[14:04] <integral> you shouldn't be able to mutate a "value", right?

[14:04] <autrijus> integral: right.

[14:04] <autrijus> I'm using "value" in the functional programming sense

[14:04] <stevan> yes

[14:04] <autrijus> so

[14:04] <autrijus> (1,2,3).push(4)

[14:04] <autrijus> is just like saying

[14:04] <stevan> but is perl really that strict?

[14:04] <autrijus> 5++

[14:05] <integral> yes, definately, imo

[14:05] <autrijus> both are a mutable action levelled to a nonmutable value

[14:05] <stevan> what about (1, 2, 3).shift

[14:05] <stevan> same thing?

[14:05] <autrijus> $ perl

[14:05] <autrijus> shift(1,2,3)

[14:05] <autrijus> Type of arg 1 to shift must be array (not list)

[14:05] <autrijus> I think perl5 agrees with me :)

[14:05] <stevan> ok

[14:05] <integral> push/shift should just be taking the list from the box, making a new list, and putting it back

[14:06] <autrijus> integral: good.

[14:06] <autrijus> then there's two questions remaining.

[14:06] <autrijus> $a = (1,2,3); $a.push(4);

[14:06] <autrijus> this always works, because Scalar cannot ever contain a List object. correct?

[14:06] <integral> "yes"

[14:07] <autrijus> and

[14:07] <autrijus> $a := (1,2,3);

[14:07] <autrijus> is promoted to

[14:07] <autrijus> $a := \(1,2,3);

[14:07] <autrijus> exactly as lwall described.

[14:07] <autrijus> and (@a := 1) is an error.

[14:08] <integral> what's \()?   And why not $a := [1,2,3] ?

[14:08] <autrijus> $a := [1,2,3];   # $a is Scalar of Array of Int

[14:08] <autrijus> $a := \(1,2,3);  # $a is Scalar of List of Int

[14:09] <autrijus> in the latter form you can't push into $a.

[14:09] <autrijus> but the first form is just fine.

[14:09] <autrijus> the thing is [] allocates mutable storage

[14:09] <integral> I don't understand $a = (1,2,3) then :-/

[14:09] <autrijus> integral: oh, it's easy. infix:<,> in scalar context allocates mutable storage.

[14:10] <autrijus> but I'm thinking about let it not do that for binding.

[14:10] <autrijus> otoh, maybe it should always allocate mutable storage just for consistency's sake. not sure

[14:10] <integral> owww, that's my head hurting level reached ;-)

[14:11] <autrijus> let's elide it for now; I'll QuickCheck it later

[14:11] <autrijus> another question is, what is Hash containing.

[14:11] <autrijus> I'd say it contains a Map.

[14:11] <integral> List of Pair?

[14:11] <autrijus> but another thought is List of Pair, yeah.

[14:12] <autrijus> so in that view, Hash is a constrained type of Array

[14:12] <integral> otherwise you've can only contruct Maps by magic from Lists of Pairs

[14:12] <autrijus> where elements are always pairs

[14:12] <autrijus> and further constained to guarantee fst uniqueness

[14:12] <autrijus> that is, key uniqueness

[14:12] <integral> but not with an ordering

[14:13] <autrijus> oh? (%x)[3]

[14:13] <autrijus> hm.

[14:13] <integral> ordered hashes by default?  isn't that a bad performance thing?

[14:13] <autrijus> no, I mean unordered

[14:13] <autrijus> but have that return a pair

[14:13] <autrijus> ah. I'm confusing levels

[14:13] <stevan> which pair?

[14:13] <autrijus> any pair

[14:14] <stevan> the 3rd one added?

[14:14] <autrijus> but no, .[] is a list op, surely it doesn't work on hash

[14:14] <integral> but the same pair under the constraints of keys/values in p5?

[14:14] <stevan> no it shouldnt (IMO that is)

[14:15] <Adam_> autrijus, talk to me about this thing of larry

[14:15] *** Adam_ is now known as Alias_

[14:15] <autrijus> Alias_: ?

[14:15] <autrijus> integral: the value part of hash is still a mystery to me.

[14:16] <Alias_> the perl 5 to perl 6 thing he was working on at the hackathon

[14:16] <Alias_> madskills?

[14:16] <autrijus> Alias_: yeah, perl-parse-dependent

[14:16] <autrijus> aka ppd

[14:16] <Alias_> is there any information on it anywhere?

[14:16] <autrijus> it re-adds everything folded away at compile time, serialize the op tree into xml and prints it.

[14:17] <Alias_> or just the source

[14:17] <Alias_> Need to add some information to my talk

[14:17] <Alias_> (in addition to this loverly photo http://www.spidereyeballs.com/os5/set1/small_os5_r23_1625.html)

[14:18] <autrijus> ok. you can safely say 1)it works less well than perlcc currently and 2)it's larry's repentance for toke.c.

[14:18] <autrijus> (i.e. developing ppd is a lot of suffering and pain and I'm not sure he'll carry it through.)

[14:19] <wolverian> is it a christian thing? :)

[14:19] <Alias_> But it's going to be good enough for a first cut at Perl 6 ports of things?

[14:19] <autrijus> Alias_: not currently, I doubt ever.

[14:19] <Alias_> oh yuck

[14:20] <Alias_> I thought that was the point?

[14:20] <autrijus> o/~ Larry walked this onesome valley / He had to walk it by himself o/~

[14:20] <autrijus> s/one/lone/

[14:20] <autrijus> Alias_: that was the point, but I think @Larry seriously underestimated the efforts involved.

[14:20] * Alias_ chuckles

[14:20] <wolverian> do you guys have recommendations for a Linux laptop?

[14:20] <Alias_> it is indeed a long and ugly road

[14:21] <wolverian> ack, maybe I should ask in a better channel, sorry.

[14:21] <autrijus> Alias_: I know you don't want PPI to be mistaken as a source parser, but really, a "regular form" of perl5 that can make both PPI and PerlTidy happy, may fare batter.

[14:21] <autrijus> I mean, better.

[14:22] <Alias_> sure

[14:22] <Alias_> And if anyone else can get around the whole "impossible" problem, I'll be happy

[14:22] <Alias_> s/else//

[14:22] <Alias_> (since I cheated)

[14:22] <autrijus> also we can take two stages

[14:23] <autrijus> a better, more-loseless more-regular B::Deparse for example. but it's still very tricky

[14:23] <Alias_> B::Deparse is a CODE serializer though

[14:24] <Alias_> (in the CODE reference) sense

[14:24] <autrijus> I'm sure we both understand the huge gap involved :)

[14:24] <Alias_> right

[14:24] <autrijus> in comparison, ponie is relatively easy, and pugs-compiled-to-perl5 is downright trivial.

[14:24] <Alias_> But I think it does have a lot of value as a CODEref serializer

[14:24] <autrijus> (but just in comparison; individually they are large tasks.)

[14:25] <Alias_> Not so sure trying to push it to a full blown thing is worthwhile

[14:25] <Alias_> But then I'm willing to cut @Larry a lot of slack on the subject, since I don't know any internals

[14:25] <autrijus> really the only one who knows that much about toke.c is $Larry.

[14:25] <autrijus> $*Larry, that is.

[14:26] <autrijus> you can ping him again on p6c if you like 

[14:26] <autrijus> or mail him privately to get a more uptodate status

[14:27] <Alias_> That's ok

[14:27] <Alias_> Might hunt him down today...

[14:27] <Alias_> I've got a few days yet to update (er... finish) the talk

[14:28] <autrijus> integral: you still there? I'm thinking about @x as Data.Array.IO, %x as Data.HashTable and $x as Data.IORef.

[14:28] <autrijus> Alias_: nod, please mail him to get the recent status; I'm only updated up to the hackathon

[14:29] <mjl69> autrijus, I made sure I was using gcc 3.3 and did make clean and got the same errors.

[14:29] <autrijus> integral: modulo the fact that Data.Array.IO is not resizable, suppose it does

[14:29] <integral> autrijus: I'm here, but let me check my haskell docs

[14:29] <autrijus> integral: and the two fundamental value types are Obj and [Obj].

[14:29] * mjl69 busy working at his pesky day job, will peek back in in a few...

[14:30] <autrijus> integral: and very strangely, you can't store [Obj] into $x directly.

[14:30] <autrijus> mjl69: you using any embedded flags?

[14:30] <autrijus> integral: the evaluation rule has that STORE on $x will promote [a] into (Array of a), recursively

[14:30] <autrijus> so

[14:30] <autrijus> $x = (1, (2, 3), 4);

[14:30] <autrijus> er

[14:31] <integral> bother, I'd forgotten nested lists were darn weird

[14:31] <autrijus> bummer, I can't even write nested lists.

[14:32] <autrijus> that is a good sign actually

[14:32] <autrijus> [Obj] never gets promoted to Obj; it's always (Ref of Array of Obj)

[14:32] <autrijus> so if I write

[14:32] <autrijus> $x = (1, (scalar(2, 3)), 4);

[14:33] <autrijus> then it first turns the inner (2,3) into mutable [2,3]

[14:33] <autrijus> then store [1,[2,3],4] (all mutable) into $x.

[14:34] <integral> yeah, that makes sense

[14:34] <autrijus> so the moral of story is, to put [Obj] into Scalar, it's promoted to (Ref of Array of Obj); to put Obj into Array or Hash, it's promoted into [Obj] with one element

[14:34] <autrijus> but then, what does

[14:34] <autrijus> sub f (%x is constant) { }

[14:34] <autrijus> means, really?

[14:35] <autrijus> does it mean %x is a List of Pair that happens to be viewed as a hash?

[14:35] <integral> autrijus: I think it should be a ConstantHash does Hash,  and it's just an implementation detail if there's really no container

[14:35] <autrijus> List of (Pair of (Str, Scalar))

[14:36] <autrijus> integral: then why not ConstantArray does Array, why list?

[14:36] <autrijus> and why not ConstantScalar does Scalar, why value?

[14:36] <autrijus> or is hash really second-class here?

[14:36] <integral> oh, I was thinking it should be same for the other two

[14:37] <autrijus> oy, but there is an important difference. a ref to ConstScalar is not the same as a ref to rvalue

[14:37] <autrijus> ${\3}++ # compile time error

[14:37] <autrijus> ${\(my $x is constant)}++ # not really detectable

[14:38] <autrijus> (if we adopt the ConstScalar view)

[14:38] <autrijus> let's try this simple experiment

[14:38] <autrijus> my $x is constant = 3; my $y = 4; $x := $y; $x = 5;

[14:38] <autrijus> legal?

[14:39] <integral> umm,  no?

[14:39] <autrijus> why not? "is constant" is just a normal tie-like layer

[14:39] <autrijus> surely you can destroy the association that ties you to ConstScalar via rebind?

[14:40] <autrijus> (I say 'no' too, because I think $x is as good as a rvalue, and binding should be disallowed)

[14:40] <autrijus> it's like saying (3 := $y) to me.

[14:40] <integral> yeah, it should.   But then from a maintenance standpoint "is constant" is upfront, and shouldn't change

[14:40] <integral> but "is constant" isn't a normal tie if it means the container is a ConstScalar not a Scalar

[14:41] <integral> ugh, that didn't help

[14:41] <autrijus> didn't help.

[14:42] <autrijus> ?eval my $a := 3; my $b; $a := $b; $a = 5

[14:42] <evalbot6> \5 

[14:42] <autrijus> I'd like that behaviour to die

[14:42] <autrijus> ?eval my $a is constant := 3; my $b; $a := $b; $a = 5

[14:42] <evalbot6> \5 

[14:42] <autrijus> er, sorry.

[14:43] <integral> hmm, I was about to say that is constant restricts the type allowed in the binding for the container

[14:45] <autrijus> hm.

[14:45] <autrijus> that is a valid view. that says the pad always maps symbols to containers, never to values.

[14:46] <autrijus> ({return 3}.()) := 4; # but this is patently absurd?

[14:47] <integral> yes,  must be

[14:47] <autrijus> note that (my $pi is constant = 3) is a special form already

[14:48] <autrijus> unless we take "constant" to mean single-assignment.

[14:48] <autrijus> mmm that's an even more interesting view.

[14:48] <integral> hmm, what exactly is the LHS to := ?  Is it a container, or is it a binding?

[14:48] <autrijus> the LHS to := is a container.

[14:48] <autrijus> or rather, a signature that contains containers.

[14:49] <integral> so, if $a := $b;  And then I do $b := $c,  then $a =:= $c too?

[14:49] <autrijus> for sure.

[14:50] <integral> oh, so it's more like it mutates the LHS container into a proxy for the RHS container...

[14:50] <autrijus> no... not so

[14:51] <autrijus> see PIL.hs :)

[14:51] <autrijus> it overwrites the LHS container with the Box of the RHS.

[14:51] <autrijus> Box being the content of the container

[14:51] <autrijus> which includes Id, Value, and maybe tiedness.

[14:51] <integral> oh, a Box has a *pointer* to the storage, not the storage itself

[14:51] <autrijus> aye.

[14:51] <autrijus> three layers.

[14:51] <autrijus> four if you count symbol table.

[14:52] <autrijus> value -> box -> container -> name

[14:52] <integral> hmm, well isn't the constness thing ok then?

[14:52] <autrijus> how so? I'm saying that name may map to either value or container

[14:52] <integral> my $a is constant; $a := $b; # oh, but then you can't update via $a, so you shouldn't be able to update via $b

[14:52] <autrijus> right but that allows

[14:53] <autrijus> oh wait

[14:53] <autrijus> who decides that you can't update via $a?

[14:53] <autrijus> what you said describes ($b := $a)

[14:53] <autrijus> not the other way around.

[14:53] <integral> but $a has "is constant" up front, so $a = 5 should be always disallowed, no?

[14:54] <autrijus> so you mean "is constant" is annotating the symbol table?

[14:54] <integral> yes

[14:54] <autrijus> hm.

[14:55] <integral> but then that's why I showed that action-at-a-distance := use ($a := $b; $b := $c; $a =:= $c)

[14:55] <autrijus> ok, I think we are converging

[14:55] <autrijus> what you are saying is that 

[14:55] <autrijus> instead of

[14:55] <autrijus> value -> box -> container -> name

[14:55] <autrijus> we have

[14:55] <autrijus> 1. (value -> box -> container) -> name

[14:55] <autrijus> 2. (value) -> name

[14:56] <autrijus> and "is constant" is not a "tie" in box anymore

[14:56] <autrijus> i.e. no ConstScalar 

[14:56] <autrijus> it's directly changing the shape of the thing the name points to.

[14:57] <integral> hmm

[14:57] <integral> yes

[14:58] <autrijus> hm

[14:58] <autrijus> my $x is constant is Tieable = 3; tie($x...)

[14:58] <autrijus> allowed?

[14:58] <autrijus> if allowed, that means (box) -> name

[14:58] <autrijus> instead of (value) -> name

[14:58] <integral> hmm, if it is allowed STORE will never be called,  and if FETCH is called, you can't get any constant optimizations

[14:59] <autrijus> that's fine, Tieable defeats optimization anyway

[14:59] <autrijus> I'm just talking about the usefulness of FETCH.

[14:59] <autrijus> I think we should keep that.

[15:00] <integral> with the semantic that FETCH is called for every mention of $x ?

[15:01] <autrijus> whenever $x occurs that demands a rvalue.

[15:01] <autrijus> note that perl, like C and Java etc, adds implicit FETCH and STORE depends on context

[15:01] <autrijus> and unlike ML etc.

[15:01] <integral> ok

[15:02] <mjl69> autrijus: sorry to ask a question and disappear.  Were should I look for embedded flags?

[15:02] <autrijus> mjl69: if you didn't modify your environment, then you didn't add embedded flags

[15:02] <gaal> @papers.push("Threads cannot be implemented as a library" => http://portal.acm.org/citation.cfm?id=1064978.1065042)

[15:03] <mjl69> oh yeah.  I did set various environment variables as directed in the directions.  Let me check which ones..

[15:13] <autrijus> mjl69: try disabling all embed first and slowly add more...

[15:27] <dudley> mjl69: Those errors are usually caused by gcc 4.0 pollution somewhere.

[15:27] <svnbot6> r5975 | autrijus++ | * New formulation of containers, taking into account the

[15:27] <svnbot6> r5975 | autrijus++ |   four combination of "tieable" and "constant" traits.

[15:27] <svnbot6> r5976 | autrijus++ | * $CALLER::_ is now again usable in defaults.

[15:28] <autrijus> I'm running out of names. ;)

[15:28] <dudley> mjl69: For example, if you've build parrot with gcc 4.0, you'll get those errors when you try to embed it into pugs

[15:29] <autrijus> a Pad maps Symbol to Container; Container is a Cell typed with Scalar/Array/Hash; a Cell is either mutable or a constant Box; a Box is either a tieable box or a nontieable box.

[15:29] <autrijus> the only mutable point here is the Cell; everything else is statically bound.

[15:30] <QtPlatypus> Any problem in computer scince can be solved by an extra leval of indirection.

[15:30] <autrijus> (and if it's constant, there's no way of changing the value except by introducing a new symbol with the same name in an inner scope)

[15:30] <autrijus> QtPlatypus: how very sadly true

[15:30] <autrijus> better names welcome though.

[15:36] <mjl69> dudley: maybe that's it.  It could be the parrot compilation.

[15:36] <svnbot6> r5977 | autrijus++ | * reformat and todoify splat_rw.t

[15:37] <dudley> I just confirmed that definitely causes it. Maybe that should be documented somewhere... :-)

[15:39] <rafl> Hm, my svk eats up 80% of 512MB RAM. :-/

[15:39] <mjl69> speaking of parrot... should PARROT_PATH be set to the path of where the source files are (the ones I downloaded) or to where the installation of parrot is?  I installed parrot to the default location, but set PARROT_PATH to the directory of source files.

[15:40] <dudley> mjl69: The source dir

[15:40] <clkao> rafl: what are you doing?

[15:41] <mjl69> dudley: that's what I thought.  Just wanted to be sure.  Thanks!  I am going to start over with everything when I get a few more free minutes.

[15:41] <dudley> np

[15:41] <rafl> clkao: A simple pull.

[15:44] <clkao> rafl: eek. how simple? large repository? many changes? 

[15:44] <clkao> rafl: or it's the first time you run pull. it's probably building some cache

[15:44] <clkao> and you are using 1.00 rather than 1.01, right?

[15:45] <rafl> clkao: the pugs repository, small changes to 3 files. Not the first pull. v1.00 (debian)

[15:48] <clkao> rafl: hmm. do you see 'auto-merge... ' message ? where does it hang?

[15:51] <rafl> clkao: I don't see such a message. It doesn't really hang. It just uses a huge amount of memory which makes the system swaping. This occurs before any output is made.

[15:51] <svnbot6> r5978 | dudley++ | *Document link failures on MacOS due to inadvertent linking of gcc 4.0 objects. *Add me to AUTHORS.

[15:52] <clkao> rafl: ya, that's a known problem for 1.00 when building copy cache.

[15:56] <rafl> Hm. The Debian wishlist bug for 1.01 is already filed 11 days with no reaction from the maintainer..

[15:57] <clkao> eek

[17:00] <Aankhen``> Yay!  I managed to build SVK 1.01!

[17:01] <autrijus> woot!

[17:01] <Aankhen``> Though only 84% of the tests pass...

[17:01] <Aankhen``> Then again, that's not as bad as I expected. :-D

[17:04] <clkao> Aankhen``: huh? 84% of svk tests? how come?

[17:06] <GeJ> Aankhen``: on which platform if i may ask?

[17:06] <Aankhen``> I have no idea.

[17:06] <Aankhen``> I just followed the instructions on the Wiki.

[17:06] <Aankhen``> (clkao)

[17:06] <Aankhen``> GeJ: Win32.

[17:06] <GeJ> hum, ok so it's not related on the problem I'm thinking of on FreeBSD.

[17:11] *** brentdax_ is now known as brentdax

[17:22] <svnbot6> r5979 | autrijus++ | * change PIL from ST monad to STM monad.

[17:24] <mjl69> dudley++ # you were right, had to make clean parrot and do all over.  no link errors this time.

[17:30] <dudley> mjl69: cool :-)

[17:46] <gaal> autrijus, ping

[17:57] <autrijus> hm, treacherous perl5

[17:57] <autrijus> gaal: pong

[17:57] <autrijus> $ perl -e '$_++ for 1,2'

[17:57] <autrijus> Modification of a read-only value attempted at -e line 1.

[17:57] <autrijus> $ perl -e '$_++ for 1..2'

[17:58] <autrijus> # ok

[17:58] <gaal> autrijus, i'm assuming more or less (trecherous) perl5 semantics in use/import

[17:58] <gaal> wow

[17:58] <gaal> one's a list and one's a... list? :)

[17:58] <autrijus> .. apparently promotes values into containers

[17:58] <gaal> is it because of ..'s special iterator magic added sometime in 5.00x?

[17:59] <autrijus> I have no idea.

[17:59] <autrijus> I'm so happy I'm not reimplementing perl5.

[17:59] <gaal> so i'm adding to EvalStyle a Bool evalInit member: if true, opEval attempts to run the function &import in the evalled code

[17:59] <gaal> problems:

[18:00] <gaal> 1. how do i know the namespace to look in?

[18:00] <gaal> 2. when we introduce finer export controls, we'll have to pass information to the parser, since that's where importation takes place now

[18:01] <autrijus> the parser currently calls &import

[18:01] <gaal> oh!

[18:01] <gaal> really?

[18:01] <autrijus> yeah.

[18:01] <autrijus> l586

[18:01] <gaal> i'm talking about init actually, not symbol importation

[18:01] <autrijus> Parser.hs

[18:01] <gaal> looking

[18:01] <autrijus> init too.

[18:01] <gaal> cool!

[18:01] <autrijus> :)

[18:02] <gaal> does this get called in "require" too? or does dumpEnv control that?

[18:02] <gaal> ah, it's directly on &use, i see

[18:03] <gaal> does use Foo; use Foo call Foo::import twice? (it should)

[18:05] <gaal> anyway: i'm adding &no.

[18:06] <autrijus> cool

[18:06] <gaal> i'm not sure why Prim has op1 "use"  at all though if the parser reduces this?

[18:06] <gaal> l255

[18:06] <autrijus> to give it a different form than "require"?

[18:06] <autrijus> I have no idea either

[18:08] <gaal> ah, i think they share the responsibility. if i'm reading this correctly, l583 in Parser does 'App (Var "&use")...' which delegates some of the work to the prim (and eventually to Prim.Eval)

[18:10] <autrijus> nod.

[18:16] <svnbot6> r5980 | autrijus++ | * lift up the "Id" from Container so that each container's Id

[18:16] <svnbot6> r5980 | autrijus++ |   remains mutable even if the content is immutable.

[18:23] <gaal> i don't understand the hack in Parser:588

[18:24] <gaal> it's supposed to tell whether the module defines &import

[18:24] <autrijus> gaal: the hack is to check for &Foo::import.name

[18:24] <autrijus> because there's no .defined yet

[18:24] <autrijus> and autovivified Code has empty names.

[18:24] <gaal> but what does .name mean?

[18:24] <gaal> aaahah!

[18:24] <gaal> i didn't know that existed. :)

[18:25] <autrijus> :)

[18:25] <autrijus> ?eval &say.name

[18:25] <evalbot6> '&*say' 

[18:25] <gaal> well, &no is almost exactly the same as &use

[18:25] <autrijus> ?eval &say::goodbye.name

[18:25] <evalbot6> '' 

[18:25] <gaal> ~/o say my name, say my name ~/o

[18:25] <gaal> ahem.

[18:25] <gaal> except that the hook it calls is unimport instead of import, and that it doesn't eval.

[18:26] <gaal> i'll see if i figure out how to factor this out.

[18:27] <mjl69> I hope that 'make test' finishes before I have to pack up and go home... can't wait to finish install and start playing.

[18:27] <gaal> oh: what's val doing in line 589? why does App sub need it?

[18:27] <gaal> mjl69: you can start playing already, you have a pugs :)

[18:27] <stevan> autrijus: any thoughts on the metamodel? should I continue along this direction?

[18:27] <autrijus> stevan: yes, I think it's sanity

[18:28] <mjl69> gaal: that's what I mean, play pugs :-)

[18:28] <autrijus> and I already has some good ideas of how to integrate it to PIL.hs runcore

[18:28] <stevan> autrijus: I will take it that sanity is a good thing in this situation :)

[18:29] <gaal> mjl69, i know. but if you're already testing then you already have an executable and you don't need for make test to complete to start playing :)

[18:29] <svnbot6> r5981 | iblech++ | * INSTALL: Wrap dudley++'s new paragraph.

[18:29] <svnbot6> r5981 | iblech++ | * ext/Algorithm-TokenBucket/t/test.t: Skip test which depends on low system load.

[18:29] <svnbot6> r5981 | iblech++ | * PIL2JS: s:g/GET/FETCH/ to align to PIL.Internals and Perl 5.

[18:29] <autrijus> gaal: I think it's a typo. supposedly import's invocant is the caller package

[18:29] <autrijus> stevan: yes. :)

[18:29] <gaal> good. :)

[18:30] <mjl69> gaal: oh.  good point.  didn't think of that.   Time to cmd-n a new terminal window...

[18:30] <dudley> doh. Damn soft wrap.

[18:31] <mjl69> you know how we Mac users are.  They want to take are terminals away because we are like a bunch of dangerous babies.

[18:31] <mjl69> s/are/our

[18:32] * autrijus parsed "degenerate barbies"

[18:32] <autrijus> obviously I need to sleep

[18:33] <mjl69> same thing :-)

[18:33] <mjl69> EEEh! it's true, pugs is already there!

[18:33] <gaal> unregenerate babbies?

[18:35] <mjl69> hello, worldbool::true

[18:35] <mjl69> the output of my first pugs program

[18:35] <autrijus> ?eval "Hello, world"

[18:35] <evalbot6> 'Hello, world' 

[18:35] <autrijus> ?eval say "Hello, world"

[18:35] <evalbot6> Hello, world bool::true 

[18:35] <gaal> (i have the feeling the vast majority of people living in babbie, alabama are christians, though.)

[18:35] * autrijus waves. sleep - bbl

[18:36] <mjl69> autrijus++

[18:58] <svnbot6> r5982 | iblech++ | PIL2JS: Step 1 of renaming PIL::Nodes to PIL and PIL::Papp, PIL::PLit, etc.

[18:58] <svnbot6> r5983 | iblech++ | PIL2JS: Step 2/3 of renaming.

[18:58] <svnbot6> r5984 | iblech++ | PIL2JS: Step 3/3 of renaming, PIL2JS works again now.

[19:23] <Aankhen``> G'night.

[19:36] <svnbot6> r5985 | gaal++ | have &use call &import with the caller package as first arg

[19:40] <integral> hmm, &import is a sub rather than some kind of "package method"

[19:45] <iblech> autrijus: Will the PIL2 for { my $a; { say $a } } look like { my $a; { say $OUTER::a } }? If so, implementing lexicals in PIL2JS without having to rely on JS's "lexicals" would be a bit easier :)

[19:46] <iblech> autrijus: (But it's not a problem if the answer is no :))

[19:49] <xinming> anyone here can do a prediction of perl 6 release time? :-)

[19:49] <integral> Christmas ;-)

[19:50] <dudley> xinming: This is the part where you say, "Which Christmas?" ;-)

[19:50] <Limbic_Region> integral - that has been long proven to be misrepresented truth - it is no mystery why p6 will have a built in way to count the number of days till Easter - it must be better than PHP in all ways afterall

[19:50] <integral> heh

[19:51] <Limbic_Region> the count does indeed start from Christmas though which is where the rumor got started

[19:51] * Limbic_Region ducks

[19:52] <xinming> In fact, I ever heard that there might be a rc of perl 6 relase this year. No sure.

[19:52] * integral had the impressive pm was still being optimistic

[19:53] <Limbic_Region> xinming - there was a FAQ stating that there might be something out by the 3rd quarter of this year - it has been removed

[19:54] <Limbic_Region> no one knows for sure when it will be out - hence the joke about "Christmas" with no year

[19:54] <Limbic_Region> Pugs happens to be the furthest along (and AFAIK the only actively developed) p6 compiler 

[19:55] <Limbic_Region> you can write an impressive amount of p6 code today

[19:55] <integral> the problem comes when you encounter an area that was made up on the spot ...

[19:55] <iblech> And you can even compile 62.68% to JavaScript :)

[19:55] <integral> iblech++

[19:57] <Limbic_Region> iblech++

[19:57] <iblech> Thanks, thanks :)

[19:57] <Limbic_Region> but only 62.68% of the X% of p6 that Pugs currently supports (and has tests for I would imagine)

[19:58] <Limbic_Region> or rather - what exactly does that 62.68% represent?

[19:58] <iblech> Oh, right. 62.68% of Pugs' testsuite

[19:59] <iblech> (36 unexpected success :) -- But many tests (t/oo, t/packages) don't even compile to PIL)

[20:01] <Limbic_Region> so it is 62.68% of the Pugs' test suite that compiles to PIL, which represents some percentage of p6 implemented by Pugs (hopefully we have 100% code coverage but I am not sure), which represents some percentage of how much of the p6 specification that has been completed (my guess is around 85%) which represents some portion of the entire spec (as in it hasn't been written down yet), which is more likely around 40%

[20:02] <iblech> Right.

[20:02] <Limbic_Region> still quite impressive

[20:15] <autrijus> iblech: the answer is "yes".

[20:15] <svnbot6> r5986 | autrijus++ | * thoroughly decouple Tieable and "is rw"; if a container is neither,

[20:15] <svnbot6> r5986 | autrijus++ |   then it is a pure value.  This means constant containers cannot

[20:15] <svnbot6> r5986 | autrijus++ |   ever be rebound.

[20:16] <autrijus> Limbic_Region: instead of 85% I'd say 25%.

[20:16] <autrijus> but the other numbers agree with my gut feeling

[20:16] <iblech> autrijus: Great :)

[20:17] <szabgab> hi nothingmuch !

[20:17] <autrijus> iblech: the idea is to enable all lexicals always addressable by absolute number anywhere.

[20:17] <autrijus> iblech: you still need to provide closures

[20:17] <autrijus> but at least that invariant makes closures far easier to simulate.

[20:18] <autrijus> (this is also so we can avoid the completely broken parrot lexical pad.)

[20:18] <iblech> autrijus: Makes perfect sense

[20:19] <autrijus> iblech: good. I hope my r5986 also makes perfect sense to you.

[20:19] <iblech> Looking

[20:19] <autrijus> the basic premise is that anything marked "is constant" is indeed constant and is always inlinable.

[20:20] <autrijus> if it is constant and tieable, then you need to point to the mutable cell that represents the tiedness

[20:21] <autrijus> some obvious consequences are:

[20:21] <autrijus> sub f ($x, $y) { $x := $y } # error

[20:21] <autrijus> sub f ($x is rw, $y) { $x := $y } # fine

[20:21] <iblech> Makes perfetct sense. :)

[20:21] <autrijus> yay. :)

[20:22] <autrijus> also, suppose %ENV is constant is tied

[20:22] <autrijus> (which it wasn't in the current example)

[20:22] <Limbic_Region> autrijus - of the known specifications available - you think only 1/4 has been implemented?

[20:22] <autrijus> Limbic_Region: aye

[20:22] <autrijus> iblech: then you can freely tie/untie it

[20:23] <Limbic_Region> from the synopses - or from decisions made on the list that aren't reflected in the docs or both?

[20:23] <autrijus> iblech: but it's =:= stays invariant.

[20:23] <autrijus> so if you have a constant but tied scalar, it is conceivable that you can still assign to it whilst it is tied.

[20:24] <iblech> Right, makes sense.

[20:24] <autrijus> and all these information are made upfront at compile time

[20:24] <autrijus> and never changeable, so reduction rule is straightforward.

[20:24] <autrijus> Limbic_Region: both

[20:25] <autrijus> Limbic_Region: but the delta is insignificant

[20:25] <autrijus> Limbic_Region: see, we don't even have roles :)

[20:25] <autrijus> and the container types are quite bogus, as anyone using "is rw" and references can attest

[20:25] <autrijus> etc.

[20:26] <autrijus> but we're fixing it faster than before. :)

[20:28] <Limbic_Region> hmmm - I think we are looking at this from two different perspectives - but that's the great thing about statistics - you can twist them to lie how ever you want

[20:29] <Limbic_Region> I was thinking of objects as 1 defined unit though that 1 unit likely represents a much larger portion of the language then I was previously giving it credit for

[20:29] <nothingmuch> evening

[20:29] <Limbic_Region> salutations

[20:31] <nothingmuch> szabgab: ping

[20:37] <svnbot6> r5987 | autrijus++ | * Remove the old vtable-based tie interface.

[20:37] <svnbot6> r5987 | autrijus++ | * Make all container contents generatable via Arbitrary.

[20:41] <iblech> sub foo (?$a = $a)  # ok? i.e., does the second $a refer to the first $a?

[20:41] <iblech> Hm, I think so.

[20:46] <autrijus> yes. that line is as good as saying ?$a.

[20:46] <autrijus> my $a = $a;

[20:48] <autrijus> hm. perl does not ever have list of lists as a value, right?

[20:48] <integral> hmm, so this rule means you can do stuff like my &bottom = { &bottom.() }

[20:48] <autrijus> it's always list of array references.

[20:48] <autrijus> integral: yes.

[20:48] *** moan is now known as moan_

[20:48] <autrijus> ?eval my &bot = { &bot() }; bot

[20:49] <evalbot6> (no output)

[20:49] <autrijus> good.

[20:49] <Khisanth> that is not infinitely recursive?

[20:49] <autrijus> that is.

[20:49] <integral> pity _|_ isn't a word

[20:49] <iblech> autrijus: re LoL, right, I think.

[20:51] *** moan_ is now known as moan

[20:52] <autrijus> integral: _L

[20:52] <autrijus> ?eval my &_L = { _L }; _L

[20:52] <evalbot6> (no output)

[20:52] <integral> is that the time out, or some really cool bottom detection?

[20:53] <autrijus> timeout.

[20:54] <integral> hmm, I suppose the hard bit of really good detection would be signals

[21:01] *** brentdax_ is now known as brentdax

[21:01] <moan> Kind of a faq, i guess, but nevertheless: Are the synopses in sync with the language pugs is currently implementing?

[21:05] <mugwump> that's the idea, moan, but pugs doesn't cover all the synopses specified behaviour

[21:06] <mugwump> nor do the synopses cover certain more 'out there' features aiui, like continuations.  tests for those features are in t/unspecced/

[21:07] <moan> thanks. Finally, I got something fresh to read, then... and to type, afterwards

[21:10] <autrijus> iblech: still there?

[21:10] <iblech> autrijus: Yep

[21:11] <autrijus> ok. r5988

[21:11] <autrijus> finally gave a reasonable (to me) semantics to evaluation results

[21:11] <autrijus> -- | Any PIL expression can only evaluate to one of three value results.

[21:11] <svnbot6> r5988 | autrijus++ | * formalizing the evaluation results domain

[21:11] <autrijus> Void | Item Item | List [Item]

[21:11] <integral> hmm, is ./pugs -I ext/Test/lib t/unspecced/cont.t the best way to run a test file manually?

[21:11] <autrijus> integral: or "prove"

[21:12] <integral> prove doesn't seem to work for uninstalled pugs

[21:12] <autrijus> iblech: the definition of "Item" is from S02

[21:12] <autrijus> integral: right.

[21:12] <autrijus> iblech: then there's the fact that Ref always point to a container.

[21:12] <autrijus> the last bit I'm less sure of; conceivable we can distinguish between container refs and value refs.

[21:13] <autrijus> or we can elect to promot values to constant containers and ref them.

[21:13] <autrijus> the delta seems to be on Void; do we have a way to obtain a reference to Void?

[21:13] <autrijus> (no container can contain Void directly)

[21:13] <autrijus> in perl5, \() is the same as ()

[21:14] <iblech> I'd take option #2, promoting values to constant containers

[21:14] <autrijus> that means

[21:14] <autrijus> \(Foo.new)

[21:14] <autrijus> is actually

[21:14] <autrijus> my $temp is constant = Foo.new; \$temp;

[21:15] <autrijus> and \(1,2,3,4) would be

[21:15] <autrijus> my @temp is constant = (1,2,3,4); \@temp;

[21:15] <autrijus> (disregarding the fact that \ is a listop for now, suppose it isn't)

[21:15] <autrijus> that sounds sane to you?

[21:15] <iblech> Right, makes sense.

[21:15] <Khisanth> so it is no longer \1,\2,\3,\4 ?

[21:16] <autrijus> Khisanth: I don't know, I'm assuming it still is

[21:16] <autrijus> ?eval \(1,2,3,4)

[21:16] <evalbot6> [1, 2, 3, 4] 

[21:16] <autrijus> heh.

[21:16] <autrijus> I'm defeated by pugs :)

[21:16] <autrijus> I don't know, I can argue bothways

[21:17] <Khisanth> ah to be defeated by you own creation ... isn't that always a goal? :)

[21:17] <autrijus> :)

[21:18] <autrijus> iblech: do you think Void/Item/List is comprehensive enough? I'm a bit uncertain about whether Junc is also a fundamental val type.

[21:18] <autrijus> otoh, I can argue that Junc is always an Item

[21:18] <autrijus> but there is still the question whether it's a Obj or a intrinsic.

[21:19] <autrijus> s/or a/or also a/

[21:19] <autrijus> i.e. whether it makes sense to talk about (1|2) as an unboxed intrinsic.

[21:19] <iblech> Hm, I'd probably see Junc as an Item.

[21:20] <autrijus> but what about Pair?

[21:20] <autrijus> where does the madness end?

[21:20] <autrijus> :)

[21:20] <iblech> :)

[21:20] <iblech> Hm, the pair thing

[21:20] <iblech> I'd take this to Item, and specialcase only in the binding code

[21:20] <autrijus> so you mean both are intrinsic?

[21:20] <iblech> I.e. treat Pair as an otherwise normal object

[21:21] <autrijus> nono, normal objects are Obj

[21:21] <autrijus> I shouldn't confuse you with the Item terminology

[21:21] <autrijus> let's call it something else.

[21:21] <iblech> :)

[21:22] <autrijus> data Val = Void | Single Single | Plural [Single]

[21:22] <autrijus> data Single = Bit Bit | Int Int | Num Num | Str Str | Ref Ref | Obj Obj

[21:22] <autrijus> a bit better?

[21:22] <iblech> Ok.

[21:22] <iblech> Yep.

[21:22] <autrijus> ok. the question is whether Junc and Pair are Single variants.

[21:23] <autrijus> i.e. whether they can exist in an unboxed form.

[21:23] <iblech> I'd place Pair and Junc on the same level as Bit, Int, etc., i.e. make them Singles

[21:23] <autrijus> i.e. non-object values

[21:23] <autrijus> anything else that come to mind?

[21:23] <autrijus> type?

[21:24] <iblech> I'd make Type a Single, too.

[21:24] <autrijus> do note that each Single has its lowercase types :)

[21:24] <autrijus> my pair $x = (1=>2);

[21:25] <iblech> Even my obj $x?

[21:25] <autrijus> no, that is the assumed form

[21:25] <autrijus> you always get Obj unless you declare one of the other forms.

[21:26] <iblech> Ok.

[21:26] <autrijus> ok. so we have pair, junc and type as the non-object intrinsics.

[21:26] <autrijus> dare I suggest Code?

[21:27] <iblech> Yes.

[21:27] <autrijus> ok, I'm out of madness bits :)

[21:27] <mugwump> I thought function application was the only intrinsic!

[21:27] <iblech> :)

[21:27] * autrijus beats mugwump with church numbers

[21:28] <autrijus> handles and rules can survive without being intrinsics.

[21:30] <autrijus> ok. I think I can argue that pair, junc, type and code fits in the "compact storage" mental model

[21:31] <autrijus> while everything else can't

[21:32] <autrijus> so, is Pair just two containers

[21:32] <autrijus> or two singles?

[21:33] <autrijus> two singles, I'd argue.

[21:33] <autrijus> hm, not neccessarily. they mean different things

[21:34] <autrijus> two containers feel less broken.

[21:34] <iblech> Right, and that's the way pairs are handles in PIL2JS, too.

[21:34] <iblech> Consider $pair.key = ...

[21:35] <autrijus> nod.

[21:35] <autrijus> but junctions are Singles

[21:35] <autrijus> as lvalue junction is doomed

[21:45] <autrijus> ok, the new Val is in. I can rest in peace for a bit... the new Eval would be fun.

[21:45] <svnbot6> r5989 | autrijus++ | * Completed first cut at the Val domain of new PIL runcore.

[21:45] <svnbot6> r5989 | autrijus++ |   iblech++ for joining my madness in adding four apocryphal

[21:45] <svnbot6> r5989 | autrijus++ |   unboxed types: Pair, Junc, Type, Code.

[21:45] <autrijus> &

[21:58] <QtPlatypus> autrijus: Shouldn't the unboxed types be called pair, junc, type, code ? I thought the convention was caps for objects and boxed types, no caps for unboxed types.

[22:00] <iblech> Right. But Haskell demands that constructors are ucfirst.

[22:00] <iblech> Of course, the unboxed types as seen from Perl 6 will be lowercase.

[22:12] * QtPlatypus nods.

[22:16] <buu> perlbot: karma autrijus 

[22:16] <jabbot> buu: autrijus  has neutral karma

[22:16] <perlbot> Karma for autrijus: 11

[22:17] <nothingmuch> perlbot: karma iblech 

[22:17] <jabbot> nothingmuch: iblech  has neutral karma

[22:17] <perlbot> Karma for iblech: 27

[22:17] <svnbot6> r5990 | iblech++ | * t/var/var.t: Added 25 more tests.

[22:17] <svnbot6> r5990 | iblech++ | * PIL2JS: Real lexicals. $OUTER::. Tree traversing is fun :)

[22:17] <svnbot6> r5990 | iblech++ |   * Previously, PIL2JS relied on JavaScript's broken "lexical" semantics (i.e.

[22:17] <svnbot6> r5990 | iblech++ |     "alert(foo); var foo" works). Now, PIL/PIL2JS handles lexicals.

[22:17] <svnbot6> r5990 | iblech++ |   * Thus, "say $a; my $a" is now illegal, and the $sub in

[22:17] <nothingmuch> that's not making any sense

[22:17] <svnbot6> r5990 | iblech++ |       my $a = 3; my $sub = { $a++ }; { my $a = 9; say $a; say $sub() }

[22:17] <svnbot6> r5990 | iblech++ |     captures the correct $a. The downside is that 05-sub.t stopped to pass, but

[22:17] <svnbot6> r5990 | iblech++ |     that problem will go away as soon as PIL2 enters the world. :) (Other tests

[22:17] <svnbot6> r5990 | iblech++ |     still work.)

[22:17] <svnbot6> r5990 | iblech++ |   * Because PIL2JS handles part of the lexical allocation thing, we got

[22:17] <svnbot6> r5990 | iblech++ |     $OUTER:: for free. :)

[22:18] <iblech> nothingmuch: Probably the database was reset or so

[22:18] <iblech> perlbot: karma iblech

[22:18] <jabbot> iblech: iblech has karma of 337

[22:18] <perlbot> Karma for iblech: 27

[22:18] <iblech> hrm

[22:18] <nothingmuch> jabbot: you need to stop drinking

[22:18] <jabbot> nothingmuch: Oh, I need to stop drinking?

[22:55] <svnbot6> r5991 | iblech++ | * t/magicals/dollar_underscore.t: s/eval/try/.

[22:55] <svnbot6> r5991 | iblech++ | * t/builtins/arrays_and_hashes/pick.t: Very minor comment fix.

[22:55] <svnbot6> r5991 | iblech++ | * PIL2JS:

[22:55] <svnbot6> r5991 | iblech++ |   * PIL::PVal: Fix compilation of VBools (I accidently broke it with the

[22:55] <svnbot6> r5991 | iblech++ |     ->fixup commit r5990).

[22:55] <svnbot6> r5991 | iblech++ |   * Prelude::JS::ControlFlow: &statement_control:<loop> should respect Perl's

[22:55] <svnbot6> r5991 | iblech++ |     idea of booleaness. Pro: Some more tests should pass (resmoking), con:

[22:55] <svnbot6> r5991 | iblech++ |     additional slowness... but "I can get wrong results fast, too" :)

[23:35] <brentdax> Is postfix:<++> (Str) still magical in Perl 6, and if so, is that implemented in Pugs?

[23:36] <iblech> Both yes:

[23:37] <iblech> ?eval my $a = "a"; $a++; $a++; $a++; $a

[23:37] <evalbot6> \'d' 

[23:37] <buu> ?eval my $a = "d"; $a--;

[23:37] <evalbot6> 'd' 

[23:37] <buu> awhh

[23:40] <ayrnieu> ?eval my $a = "d"; $a--; $a

[23:40] <evalbot6> \-1.0 

[23:40] <wolverian> haha.

[23:40] <ayrnieu> similar to perl 5.  perl -le '$a = "a"; $a--; print $a'

[23:41] <ayrnieu> postfix ++ hath magic.

