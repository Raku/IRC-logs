[00:57] <svnbot6> r8053 | Darren_Duncan++ |  r1069@Darren-Duncans-Computer:  darrenduncan | 2005-12-02 16:52:55 -0800

[00:57] <svnbot6> r8053 | Darren_Duncan++ |  /ext/Rosetta-Incubator : updated Overview.pod and TODO.pod following Bricolage developers' feedback

[00:58] <clkao> awzzz

[00:58] * justatheory Mua-ha-ha-ha-ha!

[02:33] <stevan_> luqui: ping/pong/whatever

[03:32] <luqui> stevan_, gnop

[03:32] <stevan_> hey luqui 

[03:33] <luqui> so, in case you didn't see, I did a 180 on the type system

[03:33] <stevan_> yup, I saw :)

[03:33] <luqui> and now it's going to depend a lot more on the metamodel...

[03:33] <stevan_> yup

[03:33] <luqui> so, how's that going

[03:33] <stevan_> LOL

[03:33] *** stevan_ is now known as stevan

[03:34] * luqui fails to see what's funny

[03:34] <stevan> luqui: the metamodel is stalled looking for a parser to connect with

[03:34] <luqui> hmm?

[03:34] * stevan has written at least 3 versions of the metamodel by now 

[03:34] <stevan> and I am exploring the idea of one in PIR right now

[03:35] <stevan> luqui: the most recent metamodel work is in the Perl6-ObjectSpace,.. but I dont think that is what you want

[03:35] <luqui> I'm really just looking for theoretical ideas

[03:35] <stevan> ah

[03:35] <stevan> get a copy of "The Art of the MetaObject Protocol"

[03:36] <stevan> that along with the Smalltalk "Brown Book" 

[03:36] * luqui reads the descriptions of said books

[03:36] <stevan> those were my guides

[03:36] <stevan> what specific theoretical ideas are you looking for though

[03:37] <luqui> well, I dunno, seeing as how they're ideas and if I had them then I wouldn't need to look for them

[03:37] <luqui> er... something

[03:37] <stevan> ok

[03:38] <luqui> basically I'm looking for some ground to stand on somewhere

[03:38] <stevan> ok

[03:38] <stevan> well the core building blocks of the metamodel are an "instance" type, a "method" type and an "attribute" type

[03:39] <luqui> what is this "brown book"?

[03:39] * stevan goes and looks for a link

[03:39] <stevan> it is called "Smalltalk 80 : The Language "

[03:39] <stevan> http://www.amazon.com/gp/product/0201136880/qid=1133581166/sr=8-4/ref=pd_bbs_4/002-1537651-4028061?n=507846&s=books&v=glance

[03:40] <stevan> its a classic ;)

[03:40] <stevan> so, once you have this "instance" type,.. you make an instance named Class

[03:40] <stevan> this is the class Class

[03:40] <stevan> then some bootstrapping handwaving

[03:41] <luqui> okay

[03:41] <stevan> then you create the class Object

[03:41] <stevan> then set the superclass of Class to Object

[03:41] <stevan> (this is your object model cycle)

[03:42] <stevan> because Object is an instance of Class, and Class is a subclass of Object

[03:42] <stevan> this is the core of the metamodel IMO

[03:42] <luqui> hm, okay

[03:43] <stevan> with this foundation, you can easily build a highly reflective object model along the lines of CLOS

[03:43] <stevan> you can ditch some of the early steps, and just make classes "exist"

[03:43] <stevan> but then you end up with Java/C#-ish classes

[03:44] <stevan> and you have to build your reflection layer on top of it

[03:44] <luqui> okay, that should be pretty easy to reason about in a type system.

[03:44] <luqui> (except the object/class cycle might give set theorist some heartburn, but whatever)

[03:44] <stevan> there is probably a good amount of work already done re: thing kind of model

[03:45] <stevan> oh wait,... one other book for you

[03:45] <luqui> bascially, I'm thinking that we expose AST to the language level

[03:45] <luqui> and let you annotate it with whatever kind of data you like

[03:45] <luqui> during this annotation you're allowed to die, of course.  this is where typechecking can occur.

[03:45] <stevan> http://www.amazon.com/gp/product/0201433052/qid=1133581532/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/002-1537651-4028061?n=507846&s=books&v=glance

[03:45] <luqui> the hard part about this is how to actually make use of the types other than yelling at the user

[03:46] <stevan> "Putting MetaClasses to Work" ,... this is the one which inspired Guido to use C3

[03:46] <luqui> so I want a way to communicate certain guarantees back to the runtime

[03:46] <stevan> so it is runtime type checking?

[03:46] <luqui> uh, not really

[03:46] <stevan> or are we exploiting that "run at compile time" bit here

[03:46] <luqui> I mean, you could insert runtime checks, but the idea is that this happens at compile time

[03:47] <luqui> yeah, definitely exploting that... a lot

[03:47] <stevan> like BEGIN phase runtime?

[03:47] <luqui> right

[03:47] <stevan> ok

[03:47] <luqui> (and typechecking of the BEGIN block would happen at the BEGIN's BEGIN time)

[03:47] <stevan> so one trick about the metamodel

[03:47] <stevan> it has to be built on something

[03:47] <stevan> (this is what Perl6-ObjectSpace investigates)

[03:48] <stevan> that something needs to exist prior to the metamodel existing

[03:48] <luqui> $150!!??

[03:48] <stevan> native types basically

[03:48] <stevan> what is $150?

[03:48] <luqui> that book

[03:48] <stevan> eak

[03:49] <stevan> I got it for like $1 off ebay

[03:49] <luqui> ahh, that's a good iea

[03:49] <stevan> yeah ,.. ebay is great for odd computer books

[03:50] <luqui> okay, built on something...

[03:51] <stevan> oh "Putting MetaClasses to Work" has lots of theory "stuff" in it (aka - skawiggly  things I dont understand)

[03:52] <stevan> yes,.. the P6-ObjectSpace attempts to define the smallest set of "thing" a "backend" would need to provide in order to support the metamodel

[03:52] <luqui> hmm

[03:52] <stevan> so you have really basic int, string, bit, list, hash, closure, etc

[03:52] <luqui> I see it as the type system's job to let the backend know when it can use a larger set of "things"

[03:53] <stevan> I dont understand that comment

[03:53] <luqui> (oh, also when it can unbox and whatnot)

[03:53] <luqui> well we have a minimal set of necessary support

[03:53] <stevan> these 'things' are not exposed at user level

[03:53] <stevan> they are all deep inside the runtime

[03:53] <luqui> sure

[03:53] <stevan> however, I was pondering ways to expose them to the runtime, but nothing final yet

[03:54] <luqui> that necessary support might be slow, if the runtime has better support for some native perl 6 concepts, it should be able to use those

[03:54] <stevan> anyway,.. in P6-ObjectSpace there is a metamodel which is composed of nothing more than those types, and message sends 

[03:54] <luqui> but then again, I guess that's more of the PIL->Native compiler's job than the type system's

[03:55] <luqui> cool

[03:55] <stevan> well, that was partially what I wanted to do with the "runtime thing" to "userland thing" bridge

[03:56] <stevan> the basic idea was to have some kind of core primative "thing" which looks suspicously like a Role

[03:56] <stevan> then provide a bridge from that "thing" to a Role in the post-metamodel bootstrap world

[03:57] <stevan> the large idea was that if we could define all "userland" access this way, then implementation of those underlying things is irrelevant

[03:57] <stevan> and we could then allow each backend to optimize according to the specific features it had

[03:58] <luqui> hmmm.. just trying to grok this.  on what level is this "thing" "core primitive"

[03:58] <stevan> but this is all still in my head,.. and I am not sure it will work anyway,.. so probably best to ignore all that

[03:58] * stevan ponders drawing a picture

[03:58] <stevan> core primatives | metamodel primatives | metamodel | userland

[03:58] <stevan> those are the 4 steps

[03:59] <luqui> okay

[03:59] <stevan> although we should probably insert a "container & boxed types" item in between "metamodel" and "userland"

[03:59] <stevan> since the container and boxed types should be implemented with the metamdoel

[04:00] <stevan> so this primative thing which looks like a role,.. lets call it a "sig"

[04:00] <luqui> mmkay

[04:00] <stevan> this "sig" lives in the "core primatives" level

[04:00] <stevan> a sig is much like a Java interface

[04:01] <stevan> (this is all ripped off from Standard ML's module system)

[04:01] <luqui> hmmm

[04:01] <stevan> you can also have some kind of implementation attached to the sig

[04:02] * stevan still hasn't worked all this out for real,.. so I am gonna handwave some

[04:02] <stevan> every "thing" defined prior to the end of the "metamodel" step will have a sig

[04:03] <stevan> then post metamodel bootstrap,.. we make a Role which corresponds to each sig in the system

[04:03] <stevan> and whalla we have Roles for all our primative "things"

[04:04] * stevan waves his hands madly

[04:04] * luqui wonders what a sig looks like at a low level

[04:05] <stevan> sig Bit { method to_num (Bit $self:) returns Num; method to_str (Bit $self:) returns Str; }

[04:05] <stevan> something like that

[04:05] <luqui> er, I mean, from the other end of the low level

[04:06] <luqui> how would the runtime we're implementing on see it

[04:06] <stevan> although the real thing woul be more like: $Bit = sig->new(name => Bit); $Big->add_method(....)

[04:06] * stevan waves his hands madly again

[04:06] <stevan> the runtime would probably not use it that much

[04:07] <stevan> although the ideal is that we do something like ML's Functors

[04:07] <luqui> but those are strongly typed IIRC

[04:07] <stevan> and we just program to the interfaces

[04:07] <luqui> and that's about the only interesting thing about them

[04:07] <stevan> well, they are polymorphic modules basically

[04:07] <stevan> so we can program to the Bit interface

[04:08] <stevan> and the underly impl is irrelevant

[04:08] <luqui> but polymorphic over what?

[04:08] * stevan wonders what should be under the polymorphism?

[04:08] <stevan> oh,.. 

[04:08] <stevan> over the other sigs

[04:08] <stevan> cyclical systems rock :)

[04:08] <luqui> so you give it a sig, and it gives you back a module

[04:09] <stevan> a sig and a impl

[04:09] <stevan> and it gives you back a "type" 

[04:09] <stevan> you use the type

[04:09] <luqui> er

[04:09] <stevan> yeah I know

[04:09] <luqui> yeah... see, I'm trying not to have types down there

[04:09] * stevan waves his hands madly once more

[04:09] <luqui> they must be getting tired

[04:09] <stevan> they arent really types

[04:10] <stevan> there is little value in having sigs for very primative things like "bit" 

[04:10] <luqui> how come?

[04:10] <stevan> except that with my sig->to->Role idea,.. you get role Bit {} for free

[04:10] <luqui> (what case supposed to be significant there?)

[04:10] <luqui> s/what/was/

[04:10] <stevan> well they are only used inside the runtime,... 

[04:11] <luqui> where by "free" you mean "implemented elsewhere"

[04:11] <luqui> instead of defining role Bit you just define sig Bit

[04:11] <luqui> and it's about the same either way ;-)

[04:11] <stevan> no, I mean the role Bit is just a box around the core primative "bit"

[04:12] <stevan> well you can't use roles below the "metamodel" layer

[04:12] <stevan> and you need to use bits in those lower levels

[04:12] <luqui> I'm still not seeing what, er, role sigs play

[04:13] <stevan> lets ignore it for now,.. I am smoking too much crack

[04:13] <luqui> is the idea that the metamodel defines sigs, and the runtime implements them?

[04:13] <stevan> no

[04:13] <stevan> sigs are a core runtime thing (below the metamodel layer)

[04:13] <stevan> the metamodel uses them

[04:14] <stevan> because the metamodel methods will return core runtime "things"

[04:14] * luqui isn't sure how you can really define a "core runtime thing", seeing as we are trying to target existing runtimes

[04:14] <luqui> i.e. that part isn't up to you

[04:14] <stevan> true, but if they want my metamodel.. I need to have some basic building blocks

[04:14] <luqui> we're probably in vocabulary hell here

[04:14] <stevan> yeah thats surely a problem too

[04:15] <stevan> oh wait,.. i think i see one issue

[04:15] <stevan> backend != runtime

[04:15] <stevan> parrot != runtime

[04:15] <luqui> backend is deeper than runtime?

[04:15] <stevan> parrot == backend

[04:15] <stevan> yes, think of parrot as the "platform"

[04:16] <luqui> but runtime would be implemented in PIR, not perl, right?

[04:16] <stevan> or in the case of Perl6-ObjectSpace,.. the "platform" is p5

[04:16] <stevan> I think some of the runtime will be in PIR, and other parts in perl

[04:17] <stevan> preludes and such

[04:17] <stevan> the metamodel can be part of the prelude actually

[04:17] <stevan> if the right 'things' are there

[04:20] *** gugod_ is now known as gugod

[04:20] <luqui> alright.  let me sleep on this.  I'll have a peek at Perl6-ObjectSpace

[04:20] <stevan> good idea :)

[04:21] <stevan> I think autrijus should be in on this converstation too

[04:21] <stevan> he and I discussed a lot of this

[04:21] <luqui> Well, I'll be back in about a week.

[04:21] <stevan> and I am sure he has some of the insight you are looking for that  I dont have

[04:21] <luqui> I really have some big projects to do for school and I'm procrastinating by thinking about htis

[04:21] <luqui> this

[04:22] <stevan> ok,.. $work is busy for me too, so my tuits are very limited

[04:22] <stevan> P6-ObjectSpace is probably a good place to start

[04:22] <stevan> so enjoy :)

[04:22] <stevan> and get those books if you can

[04:22] <stevan> they are great

[04:22] <luqui> alrighty

[04:23] <stevan> (+ (+ CLOS))

[04:23] <luqui> heh

[04:23] * stevan goes off to watch some TV &

[04:23] <stevan> later 

[04:23] <luqui> sayonara

[04:47] <meppl> gute nacht

[04:59] *** evalbot_8052 is now known as evalbot_8053

[05:09] <luqui> ?eval Inf+1

[05:09] <evalbot_8053> Inf 

[05:09] <luqui> ?eval Inf/Inf

[05:09] <evalbot_8053> NaN 

[05:09] <luqui> ?eval Inf-Inf

[05:09] <evalbot_8053> NaN 

[05:10] <luqui> ?eval 1/0

[05:10] <evalbot_8053> Error: Illegal division by zero 

[05:10] <devin> ?eval Inf*0

[05:10] <evalbot_8053> NaN 

[05:10] <luqui> seems to be correct

[05:10] <luqui> under the assumption that it treats infinity as a number in the first place

[05:13] <devin> see t/operators/arith.t around line 300

[05:14] <devin> i suppose there is an ieee or posix standard pugs should follow here

[05:15] <luqui> ?eval 1**Inf

[05:15] <evalbot_8053> 1.0 

[05:15] <luqui> I disagree

[05:15] <luqui> (I agree with the POSIX thing; I disagree with the result of that eval)

[05:18] <luqui> ?eval (-1)**Inf

[05:18] <evalbot_8053> 1.0 

[05:18] <luqui> ?eval (-2)**Inf

[05:18] <evalbot_8053> Inf 

[05:18] <luqui> and I definitely don't agree with those

[05:18] <devin> i agree that if you are going to say Inf*0 is NaN then you should say the same thing about 1**Inf

[05:18] <luqui> ?eval (-.5)**Inf

[05:18] <evalbot_8053> 0.0 

[05:19] <luqui> Oh, and:

[05:19] <luqui> ?eval Inf**0

[05:19] <evalbot_8053> 1.0 

[05:19] <devin> well i guess the first thing you should do is write failing tests for those cases and submit a patch to the test suite

[05:20] <luqui> yep

[05:20] <luqui> doing so

[05:21] <Khisanth> luqui: why do you disagree with 1**Inf?

[05:22] <devin> cool ... big parts of the pugs testsuite will be usable for other implementations 

[05:22] <luqui> because (1.00000000000000001)**Inf == Inf

[05:22] <Khisanth> heh assuming there is another :)

[05:22] <luqui> I can come up with a more rigorous example if you like

[05:23] <Khisanth> hmm but 1 is not a float

[05:23] <luqui> ahh... that's an interesting perspective

[05:23] <devin> ?eval 1.0**Inf

[05:23] <evalbot_8053> 1.0 

[05:24] <Khisanth> see that is disagreeable :)

[05:24] <luqui> but Inf is a float... and we surely don't have infix:<**>(Int, Num) defined... do we?

[05:24] <devin> Inf is not a float either, so who knows

[05:24] <devin> Inf is a float?

[05:25] <luqui> sure.  you can put it in floats in C at least

[05:25] <luqui> (we're on the edge of mathematics and engineering here, you see)

[05:25] <luqui> (a lot of bullshit happens in these lands)

[05:25] <devin> wow you are right, i have used floats in C for years and never realised Infinity was a possibility

[05:25] <luqui> the mathematician in me has strong objections to the allowance of Inf in any variable

[05:26] <luqui> but the programmer in me likes them, because I can use them in min() and max()

[05:26] <luqui> s:g/them/it/

[05:27] <devin> Inf and NaN are like undef and SQL's NULL etc .. sentinel values

[05:28] <luqui> and I definitely have objections to "if $x == Inf {...}"

[05:28] <luqui> anyway.

[05:28] <luqui> I don't consider this to be a part of the language design where rigor is essential

[05:28] <luqui> because people have been using floats with these possibilities for years

[05:28] <luqui> and every once in a while they have a good use

[05:29] <devin> Inf is not infinity.  it's a special purpose value that just represents infinity ... so it's not math, it's binary comparison.  don't think of it as algebra

[05:30] <devin> *shrug*  time for me to go pick up my cleaning

[05:30] <luqui> the thing is, when I don't think of it as algebra, then I can't use algebra to reason about it

[05:39] <devin> actually i think it should be rigorously defined... that is what the test suite does

[05:40] <devin> as long as it is rigorously defined, then for sure you will be able to use logic to reason about it, which is fine even if the logic isn't the same as algebra

[05:44] <luqui> oh, by "rigor", I suppose I meant "conventional mathematical rigor".

[05:44] <luqui> I agree that it should be precisely defined

[05:51] <devin> sounds like we're in violent agreement

[05:53] <luqui> ?eval 0**(-6)

[05:53] <evalbot_8053> pugs: Ratio.%: zero denominator 

[05:53] <luqui> ?eval 0.0**(-6.0)

[05:53] <evalbot_8053> pugs: Ratio.%: zero denominator 

[05:54] <luqui> ?eval 0.0**(-6.1)

[05:54] <evalbot_8053> Inf 

[05:54] <luqui> gr

[05:56] <luqui> ?eval 1/0

[05:56] <evalbot_8053> Error: Illegal division by zero 

[05:57] <luqui> hmm... shouldn't that just be NaN, since we seem to be applying that everywhere

[06:08] <svnbot6> r8054 | luqui++ | Added tests about infinity, and "fixed" op2Exp to make them pass.  They should

[06:08] <svnbot6> r8054 | luqui++ | be checked for correctness.

[06:08] <dwold> hello all

[06:09] <dwold> can anyone see this?

[06:10] <luqui> yep

[06:10] <dwold> good :)

[06:10] <dwold> got a one line paste do I still need to put it in the past urls?

[06:12] <luqui> you can just put it here

[06:12] <lisppaste3> dwold pasted "regex" at http://paste.lisp.org/display/14245

[06:12] <luqui> or.. not

[06:12] <luqui> that's one line?

[06:12] <lisppaste3> dwold annotated #14245 with "regex" at http://paste.lisp.org/display/14245#1

[06:13] <dwold> say well now lol

[06:13] <dwold> Well I just posted the whole thing

[06:13] <dwold> What I cant get to work properly is the regex, Im not too familiar with either perl or regex

[06:13] <luqui> first, this is not the correct place to ask this question

[06:13] <luqui> this channel is about Perl 6, which hasn't been released

[06:13] <luqui> go to #perl or #perlhelp

[06:13] <dwold> ahh Woops :)

[06:14] <dwold> sorry

[06:14] <luqui> no prob

[06:15] <luqui> ?eval 0**0

[06:15] *** evalbot_8053 is now known as evalbot_8054

[06:15] <evalbot_8054> 1/1 

[06:16] <luqui> ?eval (-1)**Inf

[06:16] <evalbot_8054> NaN 

[06:18] <luqui> It's possible that that commit was antispec

[06:18] <luqui> I seem to recall Larry specifying that Perl will follow some common floating point spec

[06:18] <luqui> rather than trying to reinvent the wheel

[06:18] <luqui> however wrong that spec might be

[06:25] <devin> yes, pugs should be "bug-compatible" with everyone else

[06:25] <luqui> I just read the IEEE spec wrt infinity.

[06:26] <luqui> I'll roll back my changes :-(

[06:27] <luqui> ?eval 0/90

[06:27] <evalbot_8054> 0/1 

[06:27] <luqui> ?eval 0/0

[06:27] <evalbot_8054> Error: Illegal division by zero 

[06:27] <luqui> ?eval 0.00/0.00

[06:27] <evalbot_8054> Error: Illegal division by zero 

[06:27] <luqui> ?eval 1.43/0

[06:27] <evalbot_8054> Error: Illegal division by zero 

[06:27] <luqui> hmm

[06:27] <luqui> that should be NaN... maybe

[06:27] <luqui> it really depends on whether we're interpreting it as a float or as a rat

[06:32] <svnbot6> r8055 | luqui++ | Darn.  Rolled back my "fixes", because of Larry's decree that

[06:32] <svnbot6> r8055 | luqui++ | we should follow IEEE floating point, even if it is broken.

[07:17] <autrijus> luqui: ping

[07:18] <luqui> pong

[07:19] <luqui> er, autrijus, pong

[07:19] <autrijus> we need to talk :)

[07:19] <autrijus> > Perl 6 has no type system.

[07:20] <autrijus> Perl 5 has a strong, dynamic (late-bound), type system

[07:20] <luqui> alright, fine, I was not being precise

[07:20] <autrijus> nowhere did I see in type_meta that says we do without it

[07:20] <autrijus> also:

[07:21] <luqui> (keep in mind that type_meta is largely a work-in-progress: I am still researching)

[07:21] <autrijus> my Socket $fh = open('/etc/passwd');

[07:21] <autrijus> I gather from the text of type_meta that this should _still_ fail at runtime?

[07:21] <luqui> yes

[07:21] <autrijus> if so, that is a type system... unless we discard "Socket" by default

[07:21] <autrijus> which would be kind of wacky.

[07:21] <luqui> right

[07:22] <luqui> I meant no "static" type system.  I intend to make a very simple pattern-based "type system", basically allowing roles to be functions from objects to bools

[07:22] <autrijus> also, MMD being late-bound... I see no problems with it.

[07:23] <luqui> ?

[07:23] <autrijus> the text seem to argue that MMD needs to be statically determined

[07:23] <autrijus> otherwise it's lost at sea

[07:23] <luqui> there is only one problem

[07:23] <autrijus> I fail to see that, really

[07:23] <luqui> and that is with "is lazy" and MMD

[07:23] <luqui> you know, the reason you added the tiny type inferencer currently in pugs

[07:24] <autrijus> yes, but that is not really MMD

[07:24] <autrijus> you can get it with SMD too

[07:24] <luqui> 'splain

[07:25] <autrijus> sub foo (Socket $s is lazy) { ... }; foo(open('/etc/passwd'));

[07:25] <luqui> that's not *deciding* what to execute based on the type of $s

[07:25] <luqui> you can delay a check

[07:25] <autrijus> how do I delay it?

[07:26] <luqui> but you can't roll back and say "oh, now that we've evaluated, I think we actually should have chosen this other sub instead"

[07:26] <autrijus> sub foo (Socket $s is lazy) { system("rm -rf /") }

[07:26] <autrijus> sub foo (Socket $s is lazy) { system("rm -rf /"); ... evaluate $s ... }

[07:26] <luqui> uh

[07:26] <autrijus> it's the same problem really... with lazy evaluation we still don't want rm-rf to happen

[07:26] <luqui> I suppose

[07:26] <autrijus> it's, in a sense, deciding which path to execute (rm-rf or type fail)

[07:27] <autrijus> it's asif all sub{} is actually multi{} with a default case that throws type error.

[07:27] <luqui> okay, I'll buy that

[07:27] <luqui> but that was a problem before

[07:27] <luqui> (and it's a hard one... hmm, hadn't thought about it before)

[07:28] <luqui> Incidentally, if you consider lazy passing as passing a coderef, i.e. my proposal a little while back, the problem gets swept under the rug

[07:29] <luqui> sub foo ($s is lazy:(--> Socket)) {...}

[07:29] <luqui> we can't check that that is the type of $s if it is untyped

[07:29] <luqui> we can only check that it is a code at all

[07:30] <luqui> hmm.  You can't really do MMD on function types.

[07:30] <luqui> dynamically, that is

[07:30] <autrijus> sure we can, if the function is explicitly typed.

[07:30] <luqui> yeah, but if it's not

[07:31] <luqui> there's nothing we can evaluate to figure out its type

[07:31] <autrijus> if it's not it's populated with Any by default, which is like CLR's "Object" catchall type

[07:32] <luqui> but now, supposing for a second that we did have a static type system, there is a subtle interplay between compile-time and runtime multiple dispatch

[07:32] <autrijus> anyway. my point is that if people discover that adding type annontation does not bring any errors forward to compile time

[07:32] <luqui> (and makes their programs slower to boot)

[07:32] <autrijus> then there is significantly less incentive of adding any sort of annotations.

[07:32] <autrijus> yup.

[07:32] <luqui> yeah.  But "use Types::Static" isn't so hard to type...

[07:32] <luqui> they just have to know about it

[07:33] <autrijus> ah but what would Types::Static bring to table, is the questoin.

[07:33] <luqui> The whole idea is that you put the static type system in the hands of CPAN, not eliminate it altogether

[07:33] <autrijus> yup, I understand that

[07:33] <luqui> okay...

[07:33] <autrijus> however, even under separate compilation, type constraints expected by a module still has to be understood by another

[07:34] <luqui> yeah, that's the part that I haven't figured out yet

[07:34] <autrijus> so there still have to be a static calculus somewhere

[07:34] <luqui> research, thinking, sketching, all of that

[07:34] <dduncan> autrijus, I'm not sure if it was addressed in the last couple weeks, but when I last tried to define a perl 6 class whose constructor had named arguments, it didn't work

[07:34] <autrijus> dduncan: minimal example?

[07:34] <dduncan> see Locale::KeyedText::Message

[07:35] * luqui thinks dduncan should write a test case instead ;-)

[07:35] <dduncan> I was under the impression that normally you just define a BUILD submethod, and not a new() ...

[07:35] <autrijus> luqui: nodnod... I think it's a healthy direction (not tied to any static calculus for the moment) but I think the static calculus is still needed -- it has to be very rich and not at all decidable

[07:35] <dduncan> and that named arguments are what the default new() has ... you only explicitly make a new() if you want positional args

[07:36] <luqui> autrijus, does that help us?

[07:36] <autrijus> luqui: if we don't have that, we can't capture constraints in module interfaces, and no static analysis can exist in multimodule programs

[07:36] <autrijus> luqui: and by limiting to a sensible subset in it (via some Types::* framework), the frameworks can provide users with interesting services

[07:36] <autrijus> like inferrence and whatnot.

[07:37] <luqui> hm...

[07:37] <dduncan> but when I declare just a BUILD having named arguments, the argument's value is a Pair

[07:37] <dduncan> the reason I'm asking you is ...

[07:37] <autrijus> submethod BUILD (Str :$msg_key!, Any :%msg_vars? = hash()) {

[07:37] <autrijus> }

[07:37] <autrijus> this one?

[07:37] <luqui> the thing I'm thinking is that the calculus in CLTI is not a subset of F<:

[07:38] <dduncan> when I last brought this matter up, there were opinions raised that the behaviour I expected wasn't what should be done ... someone had a problem with that design idea

[07:38] <dduncan> autrijus, yes

[07:38] <dduncan> part of the reason I'm bringing it to you is to see what you think the correct behaviour is supposed to be, so I can code to that

[07:38] <autrijus> luqui: p6 already has Ada's "range" constraint types... we can't be a proper subset of F<: anyway

[07:39] <autrijus> (unless you demote them all to runtime, but I think it's a pity)

[07:39] <autrijus> my Int where {1..5} $x = 3;

[07:40] <dduncan> I didn't make a test suite because I didn't know if an official decision had been reached about what the correct behaviour is supposed to be

[07:40] <luqui> dduncan, it's hard to understand what you're asking

[07:40] <luqui> can you write a little code please?

[07:40] <luqui> just paste or whatever

[07:40] <luqui> autrijus, ah, no, I'm just saying that there are interesting calculi which may not be a subset of ours

[07:40] <autrijus> dduncan: does BUILD work if you call it explicitly?

[07:40] <luqui> which may be okay

[07:40] <luqui> it'd be nicer to increase the demand for writing a Types:: module instead... if that is possible

[07:41] <luqui> autrijus, i.e. the type system would provide more an interface than a calculus

[07:41] <autrijus> luqui: nodnod... but you can have a calculus that is just collecting annotations and has _no_ static progression rules

[07:41] <luqui> still not quite sure what that would look like though

[07:41] <autrijus> (every thing is deferred to runtime)

[07:41] <luqui> oh

[07:41] <luqui> I see

[07:41] <autrijus> so you can typecheck this:

[07:42] <autrijus> 6.{7} = 1.(3)

[07:42] <autrijus> as there's no static progression)

[07:42] <luqui> autrijus, for example, so that two modues that use parametric types can agree with each other about what they mean

[07:42] <autrijus> yup

[07:42] <luqui> okay, I can see that that might be a necessity

[07:43] <autrijus> once that is in place, I'm going to argue there is still a default static type system that makes 1.(3) not typecheck

[07:43] <dduncan> autrijus, I didn't know I could call it explicitly, for some reason, but I could try that ...

[07:43] <autrijus> but we can save that arguement later :)

[07:43] <dduncan> when you say "call it explicitly", do you mean declare a new() that declares bless(), or call BUILD from the outside?

[07:44] <autrijus> call BUILD from outside

[07:44] <dduncan> will try ...

[07:44] <luqui> autrijus, well... what I argued in type_meta is that if you have a default, it has to be good

[07:44] <luqui> but I guess we're saving that argument until later ;-)

[07:44] * dduncan brb

[07:45] <autrijus> dduncan: nvm, I fixed the bug.

[07:46] <autrijus> luqui: yup... 1.[6.(3)] exceeds my definition of "good by default" :)

[07:46] <autrijus> meanwhile, can I commit this?

[07:46] <autrijus> --- notes/type_meta.pod (revision 8551)

[07:46] <autrijus> +++ notes/type_meta.pod (local)

[07:46] <autrijus> -Perl 6 has no type system.

[07:46] <autrijus> +Perl 6 has no single, canonical, static type system.

[07:46] <luqui> sure

[07:47] <luqui> it was kind of a shock effect thing, but I suppose I shocked you too much :-)

[07:47] <dduncan> oh, luqui ...

[07:47] <luqui> dduncan, asiiiiiiiii?

[07:47] <dduncan> I just remembered that I *did* write a test case

[07:47] <luqui> cool

[07:47] <dduncan> its the then-new file t/oo/named_parameters_in_BUILD.t, committed on Nov 13th

[07:48] <dduncan> after I committed this, it was on the list that someone said my expected behaviour was disagreeable

[07:49] <dduncan> so autrijus, if /oo/named_parameters_in_BUILD.t passes its tests, then my problem is probably fixed

[07:49] <luqui> dduncan, that's, um... I don't remember that

[07:49] <autrijus> dduncan: it should as of r8057

[07:49] <luqui> but I think the expected behavior is entirely agreeable

[07:49] <luqui> I don't see how one could argue otherwise

[07:50] <dduncan> I can check the log to see who disagreed ...

[07:50] <autrijus> anyway, it's caused by Prim.hs still using the &infix:=> form instead of the new exploded Syn "named" form

[07:51] <autrijus> dduncan: 

[07:51] <autrijus> 1..2

[07:51] <autrijus> ok 1 - BUILD arg declared as named and invoked with literal pair should contain only the pair value

[07:51] <autrijus> ok 2 - same arg should be of declared type

[07:51] <autrijus> enjoy :)

[07:51] <dduncan> thank you

[07:51] <luqui> hooray, bugfixes!

[07:51] <autrijus> np... sorry for being away this long :)

[07:51] <dduncan> checking the latest smoke from  a couple days ago, that was still broken ... great for the fix

[07:51] <svnbot6> r8056 | autrijus++ | * Perl 6 does have a strong dynamic type system

[07:51] <svnbot6> r8057 | autrijus++ | * In calling BUILD from BUILDALL, use named arguments instead

[07:51] <svnbot6> r8057 | autrijus++ |   of unexploded pair objects.  Reported by dduncan.

[07:51] <autrijus> I assure you it was by neccessity and on short notice. :)

[07:52] <dduncan> something else I'll bring up, which may have already been fixed, concerned CATCH blocks not being called

[07:52] <luqui> you going to blog about it autrijus?

[07:52] <dduncan> between what autrijus just fixed and that, which I think already had a failing test written by someone else ...

[07:52] <autrijus> luqui: I think I did already

[07:52] <dduncan> those are the main things in the way of the rewritten Locale::KeyedText working properly in perl 6

[07:53] <luqui> that really abstract blog that I didn't understand?

[07:53] <autrijus> luqui: yeah, and the current one talking about financial hell

[07:53] <autrijus> dduncan: I don't think we even parse CATCH blocks.

[07:53] <luqui> ah right, now I remember

[07:53] <dduncan> CATCH blocks did parse, but they didn't execute

[07:54] <dduncan> the only way I could check if an exception was thrown was to read $!, like how its done in perl 5

[07:54] <dduncan> I can do that as a workaround, but its ugly

[07:54] <autrijus> ?eval CATCH { 1 }

[07:54] *** evalbot_8054 is now known as evalbot_8057

[07:54] <evalbot_8057> Error: No such method: "&CATCH" 

[07:54] <autrijus> it did not parse :)

[07:54] <autrijus> ?eval BEGIN { 1 } # compare this

[07:54] <evalbot_8057> 1 

[07:54] <dduncan> if it didn't parse, why was the error not citing bad syntax?

[07:55] <dduncan> anyway ...

[07:55] <autrijus> maybe it was used in a function application position

[07:55] <luqui> It's trying to execute CATCH(sub { 1 })

[07:55] <luqui> in that case at least

[07:55] <autrijus> I see t/builtins/control_flow/try.t already has tests

[07:56] <autrijus> dduncan: for now you may have to test $! by hand until someone adds CATCH to ruleClosureTrait in Parser.hs 

[07:57] <autrijus> I can try to help but my pressing priority now is still Roles and .meta

[07:57] <autrijus> once that's done though, hooking closure traits like CATCH should be much simpler

[07:57] <dduncan> no problem ... at least there IS a workaround

[07:57] <autrijus> nod... whilst with BUILD there was none

[07:57] <dduncan> yes

[07:57] <autrijus> thanks for your persistence as usual :)

[07:58] <autrijus> I may need to run for a bit... be back in ~15 mins

[07:58] <dduncan> fyi, I think it was Juerd that disagreed with my assumption

[07:58] <luqui> oh, Juerd, that makes sense ;-)

[07:59] <dduncan> see http://colabti.de/irclogger/irclogger_log/perl6?date=2005-11-13 , time index 01:34

[07:59] <luqui> oh, that

[07:59] <luqui> it was on a larger scale than specific semantics

[08:00] <dduncan> and since he thought that, well it seemed maybe others did

[08:00] <luqui> like, oh, say, me

[08:00] <luqui> but that was unrelated to the issue

[08:00] <luqui> if it does change, it needs to be a major change

[08:00] <dduncan> I'm not sure

[08:00] <luqui> and endorsed by Larry especially

[08:01] <dduncan> actually, you were involved too

[08:01] <luqui> yeah, I remember

[08:02] <luqui> and I agree with Juerd that the new/BUILD thing is both wrong and overly complicated.  but that requires a proposal to fix, not a "this buggy behavior might actually be correct" kind of issue

[08:03] <luqui> well, I'm tired.  I wanted to go to bed at midnight and it's already 1:00

[08:03] <dduncan> meanwhile, now that it is fixed, my code written that way in Perl 6, and my mirroring Perl 5 code using Class::Std, can work the same

[08:03] <luqui> g'night.  thanks for poking holes in pugs where they need to be poked.

[08:04] <dduncan> good night

[08:04] * luqui &

[08:33] <autrijus> re

[08:33] <svnbot6> r8058 | root++ | * My original Chinese name is officially obsolete as of last week.

[08:33] <autrijus> oh wow, "root"

[08:34] <autrijus> (that's my misuse of svn+ssh -- apologies. fixing)

[08:35] <autrijus> fixed.

[09:31] <xinming> autrijus: ping

[09:31] <xinming> :-)

[09:32] <autrijus> xinming: pong

[09:32] <xinming> autrijus: what's your Chinese name for now? :-/

[09:32] <autrijus> xinming: that's a secret :)

[09:33] <xinming> or, are you going to become in hidden mode. :-/

[09:34] <autrijus> no... not really, just disassociating with my past as a notorious poster child for whatever

[09:34] <autrijus> so I can focus on work I like, eg. pugs

[09:36] <xinming> autrijus: well, But your English name still exists. :-P

[09:36] <autrijus> you mean the net-id "autrijus"? yeah, that's going to stay around

[09:37] * xinming want to be the first person who knows antrijus' changed name... :-D

[09:38] <autrijus> nah... it's already known by some people :)

[09:39] <xinming> could you send me private message to tell me this. :'(

[09:39] <autrijus> one day I will, but the day is not today... :)

[09:39] <xinming> ..

[09:39] <xinming> Well, Ok.

[10:03] <autrijus> kane_: hey!

[10:04] <autrijus> oops.

[10:05] <kane_> autrijus! long time no see :)

[10:05] <kane_> wherabouts are you now?

[10:06] <autrijus> just arrived to .au

[10:06] <autrijus> sorry I missed your msgs... I also just discovered I forgot to identify to nickserv again

[10:06] <kane_> ah, right... nice weather i hope? 

[10:06] <kane_> yeah, nickserv is annoying

[10:06] <autrijus> yup, excellent excellent weather

[10:07] <kane_> did you happen to have a chance to see what happened to S22?

[10:07] <autrijus> I've seen the misc/sixpan

[10:07] <autrijus> does it have something to do with you?

[10:07] <autrijus> and no, I havn't really read thru it. plan to do so now as part of journaling

[10:07] <kane_> eh, yeah :)

[10:07] <kane_> read the S22, check out hte prototype dir -- that's my code

[10:08] <kane_> in short: it'll work

[10:08] <kane_> but not on dpkg ;)

[10:08] <autrijus> that... is very reassuring

[10:08] <autrijus> very rare someone utter that in association with a synopsis/perl6 :)

[10:09] <kane_> well, i can make shit up as i go along -- no silly syntax problems, no legacy.. it's so much easier :)

[10:09] <kane_> oh, and this could technically be bolted on to existing p5 infrastructure, if we felt like giving it a good run

[10:10] <kane_> dpkg++ # good place to steal ideas from

[10:14] <r0nny> morning

[10:15] <autrijus> kane_: excellent... I'll read, sleep on it, and get back :)

[10:15] <autrijus> (going to meet alias tomorrow morning and fly to melbourne)

[10:16] <kane_> autrijus: okidoki -- have some sleep & fun, we'll talk later

[10:16] <autrijus> cool! kane++

[10:19] <r0nny> autrijus: can u take a look at http://rafb.net/paste/results/J1QI3k92.html and tell me if im wrong, or the method dispatcher ?

[10:21] <autrijus> do you mean that doit should not be able to be called as a subrountine?

[10:21] <autrijus> as $.baz is undef

[10:21] <autrijus> that is a bug alright, but it's kinda subtle

[10:21] <r0nny> well - it aslo happens, if $baz has a method with the name doit

[10:22] <r0nny> i had a design, where i had a class with a method, and if u called the method it calles a method with the same name on a attribute, with itself as 2nd param

[10:22] <autrijus> ok, I think I know why

[10:22] <r0nny> it allways ended up in endless loops

[10:22] <r0nny> why ?

[10:23] <r0nny> i really want to know

[10:23] <r0nny> (else im forced to switch to python)

[10:24] <autrijus> ?eval class Foo { has Bar $.bar; method doit { $.bar.doit } } class Bar { method doit { 'bar' } }; Foo.new(bar => Bar.new).doit

[10:24] *** evalbot_8057 is now known as evalbot_8058

[10:24] <evalbot_8058> "bar" 

[10:24] <autrijus> that works

[10:24] <r0nny> btw - does evalbot run on pugs ?

[10:24] <autrijus> yes

[10:25] <autrijus> ?eval class Foo { has Bar $.bar; method doit { $.bar.doit } } class Bar { method doit { 'bar' } }; say Foo.new(bar => undef).doit

[10:25] <autrijus> so you see, the dispatch is really keyed on the actual runtime type of $.bar

[10:25] <evalbot_8058> (no output)

[10:26] <r0nny> hat appens, if i dont define the type of bar ?

[10:26] <autrijus> it depends on what actually is in it

[10:26] <autrijus> the bug here is that if it is undef

[10:26] <autrijus> then it degrades into a call to doit() in the current scope

[10:26] <autrijus> which is obviously wrong.

[10:26] <autrijus> but in your design it should not be undef, should it.

[10:26] <autrijus> (as the first case of my ?eval above)

[10:27] <autrijus> (and also... give ruby a try before switching to python. :-))

[10:27] <r0nny> it is never undef

[10:28] <autrijus> can I see some actual code?

[10:28] <autrijus> where it is not undef, that is

[10:28] <r0nny> actually im on rewriting everything

[10:28] <r0nny> i just deleted my code using it

[10:28] <autrijus> ok

[10:28] <r0nny> but i think a new one will be ready in about 6-7 hours

[10:29] <autrijus> k... I'll check back after I wake up tomorrow morning

[10:29] <r0nny> ok

[10:29] <r0nny> gn

[10:40] * gaal looks at 8058 and wonders if the domain name should perhaps have been eruditorum.org

[10:41] <autrijus> it's obra's domain :)

[10:42] <gaal> yeah, I found that out a while ago :-)

[10:42] <gaal> what is your favorite color?

[10:42] <autrijus> dark purple

[10:43] <gaal> "Autrijus the dark purple" doesn't have quite the same ring to it as "Enoch the Red", but I guess we'll have to make do with that.

[10:44] <autrijus> ...

[10:44] <autrijus> I still havn't read anything in that cycle other than cryptonomicon

[10:45] <gaal> I wonder if it's SPJ the (referentially) Transparent

[10:45] <autrijus> I'm sure chromatic is chromatic.

[10:45] <gaal> autrijus: I've got them all if you're into speed-reading ;-)

[10:46] <gaal> Crypronomicon, of course, is number i in that series.

[10:46] <autrijus> cc2e, with barely 1000 pages, already took me more than a week

[10:46] <autrijus> I think speed reading is not my forte :)

[10:46] <integral> but CC is rather serious compared to TBC :)

[10:46] <autrijus> I don't know... I flipped thru some of the later TBC tomes

[10:46] <autrijus> they look serious

[10:47] <autrijus> or at least seriously long

[10:48] <integral> you don't read on planes/trains much?

[10:48] * integral reads another pterry every time he travels

[10:48] <gaal> a friend is really excited about the Aubrey/Maturin series by Patrick O'Brian. They apparently are quite "serious" in the sense that they are impeccably reserached.

[10:49] <autrijus> integral: I do... now that I don't bring laptops into (say) bath, I've got even more slices of time to read

[10:50] <autrijus> gaal: I heard someone saying that wrt Rule of Four. then I read it. a bit underwhelmed. :/

[10:51] <autrijus> the pizza is kicking in... I'll be back after a short nap :)

[10:51] <gaal> actually although I really dig Stephenson's writing, this isn't exaclty my favorite genre

[10:52] * gaal makes a wish for pizza

[10:52] <autrijus> I note you read Nobokov... which really really helped, btw.

[10:52] <autrijus> gaal++

[10:52] <autrijus> Nabokov, even

[10:53] <autrijus> bbiab... &

[10:54] <gaal> bye :)

[11:17] <dduncan> good night

[11:44] <r0nny> is there a global var, tells if im in debug mode, ot not ?

[12:40] <gaal> what's debug mode, r0nny?

[13:02] <r0nny> gaal: my app

[14:44] <gaal> r0nny: but what is debug mode? afaik we don't have a debugger in pugs yet. in p5 I suppose you could do this:

[14:44] <gaal> # perl -le 'print "IN DEBUG MODE" if keys %DB::'

[14:47] <Juerd_> There being something in %DB:: could also mean someone used the include-trick (tnx.nl/include)

[14:48] <gaal> wow, that's a dirty hack :)

[14:49] <Juerd_> Dirty but incredibly useful :)

[14:49] <Juerd_> It's a shame that this feature can only be accessed this way.

[14:49] <gaal> but so ok, the test above can trivially be fixed to look for one of the expected debugger routines.

[15:39] <r0nny> does anyone know, how the yadayada operaots are done ?

[15:39] <r0nny> eg ..., ??? and !!!

[15:41] <gaal> what do you mean, how they are done?

[15:41] <gaal> look in Parser.hs, IIRC at the bottom of the file.

[15:42] <r0nny> i want to write a own yadayada operator

[15:42] <gaal> ?eval sub castle_of_aaaaaah { !!! } castle_of_aaaaaah()

[15:42] <evalbot_8058> Error: !!! - not yet implemented 

[15:42] <gaal> what do you want it to do?

[15:43] <r0nny> print wich class, wich method , wich instacne class, then exit

[15:43] <r0nny> eh return failure

[15:44] <gaal> ?eval sub XYX { Carp::confess } sub A { B() } sub B { C() } sub C { XYZ() }

[15:44] <evalbot_8058> undef 

[15:44] <gaal> grrrr.

[15:44] <gaal> ?eval sub XYX { say Carp::longmess } sub A { B() } sub B { C() } sub C { XYZ() }

[15:45] <evalbot_8058> undef 

[15:45] <gaal> grrrr!

[15:45] <gaal> ?eval sub XYX { say Carp::longmess() } sub A { B() } sub B { C() } sub C { XYX() }

[15:45] <evalbot_8058> undef 

[15:45] <r0nny> u miss to call one of the subs

[15:45] <gaal> GRRRRR!

[15:45] <gaal> ?eval sub XYX { say Carp::longmess() } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:45] <evalbot_8058> Error: No such method: "&Control::Caller::caller" 

[15:45] <gaal> wtf!?

[15:46] <r0nny> i think hell foze in an instant

[15:51] <r0nny> hmm

[15:51] <gaal> ?eval sub XYX { say caller() } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:51] <evalbot_8058> OUTPUT[<obj:Control::Caller> ] bool::true 

[15:51] <gaal> ?eval sub XYX { say caller().subname } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:51] <evalbot_8058> OUTPUT[&main::C ] bool::true 

[15:52] <r0nny> ?eval sub XYX { say caller.caller.subname } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:52] <evalbot_8058> Error: No such sub: "&subname" 

[15:52] <gaal> you need the ()

[15:53] <r0nny> ?eval sub XYX { say caller().caller().subname } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:53] <evalbot_8058> Error: Can't modify constant item: VUndef 

[15:53] <r0nny> ?eval sub XYX { say caller().meta } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:53] <evalbot_8058> Error: No such method: "&meta" 

[15:53] <r0nny> darn

[15:53] <gaal> oh and you can't call caller() on the object returned by caller().

[15:53] <r0nny> is there a way, to get more of the stack ?

[15:54] <gaal> read the source for caller in Prelude.pm.

[15:55] <Juerd_> Yeah, but don't stray to the dark side of the source.

[15:55] <gaal> ?eval sub XYX { say caller(skip => 2).subname } sub A { B() } sub B { C() } sub C { XYX() } A()

[15:55] <evalbot_8058> OUTPUT[&main::A ] bool::true 

[15:56] <gaal> when did longmess break, is what I want to know.

[15:56] <gaal> my fault for not writing a test for it :/

[15:59] <Juerd_> Does mess stand for message?

[15:59] <Juerd_> We need standard abbreviations. msg, mess, mesg... Too confusing

[15:59] <gaal> yeah. this is unspecced, lifted straight from p5 Carp.

[16:00] <rafl> I guess it stands for messiness

[16:00] <gaal> that too

[16:00] <gaal> as it loops on caller rather than using some more efficient API.

[16:00] <gaal> then again people who need upstacking to be efficient may have other problems.

[16:01] <r0nny> hmm

[16:05] <svnbot6> r8059 | kane++ | * whitespace fixes

[16:13] <rafl> kane_: Hello

[16:15] <rafl> kane_: Do you know a nice p5 module that does the stuff File::Copy::Recursive stuff but with support for patterns? I don't want to clutter up the code for copying the module src to _jib/build to exclude _jib from that..

[16:16] <Juerd_> rafl: package Acme::Nice::Module::Copy; sub cpr { system "cp -r @_" }

[16:16] <Juerd_> rafl: ;)

[16:17] <gaal> cpr reminds me of Inline::CPR (which is totally cool)

[16:17] <rafl> If it comes with a portable cp script.. why not?

[16:17] <gaal> what, Inline::CPR? No, it doesn't :-)

[16:20] <kane_> rafl: i think you could use File::Find::Rule and add the output to File::Copy

[16:20] <kane_> rafl: btw, i'm working on JIB::Source now -- to build our source package sfrom a dir (analog to prototype's create.pl)

[16:21] <gaal> kane_: you have to create dirs too.

[16:21] <kane_> doesn't file::copy just Get That?

[16:21] <gaal> I think it doesn't, at least not portably.

[16:21] <rafl> kane_: Oh, I'm as well. Well, maybe commit your's so I can code there as well.

[16:22] <gaal> bbiab&

[16:22] <kane_> rafl: heh.. typical... ok, i'll do an intermediate commit

[16:22] <kane_> rafl: btw, i lowercased the methods in config.pm -- seemed more consistent with the rest of the code, i'll submit that too

[16:23] <kane_> rafl: btw, the JIB::Meta needs some consistency checks in it too, to make sure the META.info is 'sane' -- if you feel like that, by all means :)

[16:23] <rafl> kane_: First I need to do some work that I get paid for.

[16:24] <kane_> rafl: np.. i'll hack on source.pm in the meantime

[16:24] <kane_> commit coming up

[16:30] <svnbot6> r8060 | kane++ | * lowercase config.pm methods

[16:30] <svnbot6> r8060 | kane++ | * add first rendition of source.pm + tests

[16:51] <rafl> kane_: Thanks.

[16:52] <rafl> kane_: I'll do the Repository stuff next, if you're fine with that.

[16:53] <kane_> rafl: i am -- i'm adding some utils & constants modules too.. good place to cram stuff (stealing most of it back from CPANPLUS) -- i'll check those in next

[16:53] <kane_> rafl: oh.. the meta sanity checks also good -- if you find the time/energy of course

[16:54] <rafl> kane_: OK. I'll look into it when I've done my work for monarch.

[16:54] <kane_> ok

[17:00] <svnbot6> r8061 | kane++ | * add jib::constants & basic tests

[17:00] <svnbot6> r8061 | kane++ | * add jib::utils & basic tests

[17:00] <svnbot6> r8061 | kane++ | * add 'build_dir' to config.pm

[17:00] <svnbot6> r8061 | kane++ | * work in progress

[17:00] <svnbot6> r8062 | kane++ | * basic tests for config.pm

[17:06] <svnbot6> r8063 | kane++ | * replace the loc() strings 

[17:28] <rafl> kane_: Why do the Utils method start with an underscore?

[17:34] <Khisanth> hmm weird

[17:34] <Khisanth> make unoptimized takes 46 minutes to fail but "make" succeeds in 29 minutes :/

[17:48] <kane_> rafl: internal use only

[17:48] <kane_> not part of the published API

[17:48] <kane_> and i'm hating perl... frigging no decend path manipulation tools

[17:49] <rafl> kane_: I actually like Path::Class.

[17:49] <rafl> kane_: At least its api. Some things are still missing to make it good enough.

[17:50] <kane_> it's missing the manipulation though.. or maybe i should say fs manipulation tools

[17:50] <kane_> like 'mv' and 'cp -R' and 'rm -r' that Just Frigging WOrk on *nix

[17:50] <kane_> it takes me 20 lines to do a clever recursive copy

[17:50] <kane_> that's just stupid

[17:50] <kane_> wheras cp -R does what i need

[17:51] * kane_ ponders jsut leaving the system()'s in for now, and clean it up later

[17:51] <kane_> will go Much Faster

[17:52] <SamB> Khisanth: that is peculiar

[17:52] <SamB> maybe there are tools in the tree that need to be optimized to fit in memory and/or work right?

[17:54] <Khisanth> SamB: seems to be fairly consistent as well

[17:55] <SamB> well, this sort of thing does tend towards being that way

[17:56] <SamB> usually there is one thing that doesn't work quite right if a certain optimization doesn't happen

[18:01] <bsb> kane_: IO::All has $io->all to recurse dir trees

[18:01] <bsb> Don't know about copying though

[18:01] <kane_> i got the recursion.. it's the copying

[18:01] * kane_ prays for a good file::copy::recursive

[18:02] <kane_> hrmpf

[18:03] * kane_ hates software some more

[18:03] <rafl> kane_: It does some manipulation..

[18:03] <kane_> screw it, i'll fix this later

[18:03] <rafl> kane_: $dir->rcopy($dest), etc.

[18:03] <rafl> (WRT Path::Class)

[18:03] <clkao> kane!

[18:03] <kane_> cl, dude!

[18:04] <kane_> rafl: /rcopy/ is not mentioned in the path::class docs

[18:05] <rafl> kane_: You're right. The only thing I can find for path manipulation are mkpath and rmtree.

[18:05] <kane_> yeah, this blows... i'll use the old root-* way of building and we'll fix this later

[18:05] <kane_> i hate getting stuck on this nonsense for 45 mins becasue perls tools blow :(

[18:10] <gaal> kane_: I assure you, cp is more than 20 lines of code :-)

[18:11] <r0nny> re

[18:13] <rafl> kane_: I can give a try to fix that. My create.pl equiv was able to copy everything into the right place.

[18:13] <kane_> rafl: good.. i'll check it in with prototype code, and we can just tear out the system()'s one by one

[18:28] <svnbot6> r8064 | kane++ | * add more deps to makefile.pl

[18:28] <svnbot6> r8064 | kane++ | * fail miserably in getting cp -R to work Proper

[18:28] <svnbot6> r8064 | kane++ | * stay with system() calls, remove them later

[18:28] <svnbot6> r8064 | kane++ | * also, i hate perl sometimes

[18:31] <r0nny> i got a problem with the yadayada operator ??? - it exits the program - acording to the docs it just prints a warning 

[18:33] <r0nny> anyone can tell me whats up with this ?

[18:37] <kane_> ?eval print 1 if ???

[18:37] *** evalbot_8058 is now known as evalbot_8064

[18:37] <evalbot_8064> Error: cannot cast from VUndef to Handle (VHandle) 

[18:37] <kane_> ?eval if( 1 ) { ??? }

[18:37] <evalbot_8064> Error: cannot cast from VUndef to Handle (VHandle) 

[18:37] * kane_ eyes the bot

[18:39] <r0nny> sub test{???}; test;

[18:39] <r0nny> ?eval sub test{???}; test;

[18:39] <evalbot_8064> Error: cannot cast from VUndef to Handle (VHandle) 

[18:41] <wolverian> ?eval ???

[18:41] <evalbot_8064> Error: cannot cast from VUndef to Handle (VHandle) 

[18:41] <wolverian> ?eval !!! 

[18:41] <evalbot_8064> Error: !!! - not yet implemented 

[18:41] <r0nny> ?eval ...

[18:41] <evalbot_8064> *** ... - not yet implemented     at <eval> line 1, column 1-4 

[18:41] <r0nny> ?eval sub foo{...};foo

[18:41] <evalbot_8064> *** ... - not yet implemented     at <eval> line 1, column 9-12 

[18:42] <r0nny> darn it

[18:42] <r0nny> eval $?VERSION

[18:42] <r0nny> ?eval $?VERSION

[18:42] <evalbot_8064> Error: Undeclared variable: "$?VERSION" 

[18:42] <r0nny> eval $?V

[18:42] <gaal> ?eval $?PUGS_VERSION

[18:42] <evalbot_8064> \"Perl6 User\'s Golfing System, version 6.2.10, October 10, 2005 (r8064)" 

[18:42] <gaal> please see Run.hs for globals

[18:42] <r0nny> i will do

[18:44] <gaal> kane_: File::Path has a mkpath function.

[18:44] <kane_> it's recursive copying with exclusion i want

[18:44] <kane_> but thanks for trying :)

[18:44] <gaal> yes, i was referring to _mkdir

[18:45] <kane_> it calls, under the hood:     eval { File::Path::mkpath($args->{dir}) };

[18:45] <kane_> it's  just a wrapper to DTRT and handle errors

[18:45] <gaal> oh.

[18:45] <r0nny> btw - is there a global is set, when compiling ?

[18:46] <gaal> r0nny: explain?

[18:46] <gaal> kane_: what do you want a recursive copy to do? you mentioned "exclusion"...?

[18:46] <r0nny> if i coampile, i want to include the stuff usually is loaded based on runtime-determined variables

[18:47] <kane_> in shell speak, along the lines of cp -R source_dir destination_dir, where source_dir has been grep -v'd for a pattern

[18:47] <kane_> like no txt files or so

[18:48] <gaal> kane_: rcopy($from, $to, Rule $except?) { ... } ?

[18:49] <gaal> is the filter applied deeply as well?

[18:49] <kane_> yes

[18:49] <kane_> in our case, it's 'dont copy one particular subdir somewhere in the tree'

[18:50] <gaal> oh. but what if a file with the same name exists somewhere else?

[18:50] <gaal> a regex would not be enough. looks like you need your own visitor.

[18:50] <kane_> i can do the filtering with file::find::rule

[18:50] <kane_> just the -R doesn't do the right thin any more on cp or anything else

[18:50] <gaal> then what's missing?

[18:50] <kane_> but rafl said he had some code that worked, so hopefully that does the trick

[18:50] <gaal> ok.

[18:50] <kane_> the implicit mkdir -p for one

[18:51] <gaal> r0nny: sorry, I don't understand

[18:51] <kane_> and the mkdir'ing of hte basename, rather than the whole path you feed it

[18:51] <kane_> and stuff like that

[18:51] <gaal> kane_: I must have written this a few times in the past. :-)

[18:52] <r0nny> gaal: when i conpile, i want to include all modules could be needed, while if i run it, i just want to use these are actually needed

[18:52] <gaal> r0nny: so you want something like AUTOLOAD that possibly loads additional modules?

[18:53] <gaal> ...but which are forced-loaded when precompiling

[18:53] <r0nny> yeah

[18:53] <gaal> ah, now I understand the "global" you were asking about.

[18:53] <r0nny> how to do this ?

[18:54] <gaal> I don't think this is specced anywhere, since the perlrun stuff hasn't been specced.

[18:54] <r0nny> :/

[18:55] <r0nny> then my build system will be very slow

[18:55] <gaal> as a workaround, not very neat, you can check %*ENV in a BEGIN block.

[18:55] <gaal> and conditionally load things if sometihng like IS_PRECOMPILING is set.

[18:56] <gaal> that'd be your applicative env flag, though.

[18:56] <r0nny> hmm

[18:59] <gaal> this can be made into a module fairly easily, the question is what interface to give it. Ask p6-l maybe?

[18:59] <r0nny> hmm

[19:00] <r0nny> maybe i should wait, till binary modules are suppported

[19:00] <r0nny> btw - kane_ what will be used for binary module building

[19:01] <kane_> r0nny: in what regard?

[19:01] <r0nny> sixpan

[19:02] <kane_> no binary modules on sixpan

[19:03] <r0nny> hmm

[19:03] <r0nny> then what willbe used on the client to compile them ?

[19:03] <rafl> The Perl Compiler? *duck*

[19:03] <kane_> r0nny: Some Build Tool (tm)

[19:03] <kane_> package manager ne build tool

[19:04] <r0nny> kane_: mind if i contribute the default build tool ?

[19:04] <kane_> knock yourself out -- that would be the replacement of EU::MM/Module::Build

[19:04] <kane_> you might wanna take it up with those guys for the guts

[19:04] <r0nny> hmm

[19:05] * kane_ doesn't know much about the ev0l of building modules

[19:05] <r0nny> EU::MM ?

[19:05] <r0nny> long name ?

[19:06] <kane_> ExtUtils::MakeMaker -- current 'default' installer for perl5

[19:06] <kane_> the JIB code (sixpan pm) will invoke 'a' build tool with certain arguments at certain times.. what happens next is up to the buildtool, etc

[19:07] <r0nny> hmm

[19:08] <kane_> the end result of what hte buildtool should do is install thigns in a target directory which it should treat as /..f rom there, JIB takes over again

[19:08] <r0nny> hmm

[19:08] <r0nny> my build tools default is to create a directory wich contains everything needed to copy to / to install the thing

[19:09] <kane_> that's pretty much what i said

[19:09] <kane_> only difference would be is that we say 'here is that dir' rather than you making one up :)

[19:10] <r0nny> my tol will be happy to eat your preferences

[19:10] <r0nny> but atm its not mature enough

[19:10] <rafl> kane_: Everything commited by now? I'd like to leave now and hack on my way.

[19:10] <kane_> no, much hacking in progress

[19:10] <kane_> i got $src->biuld working, so we have .jibs now

[19:11] <kane_> doing JIB::Installation next, so we can do $src_pkg install as well

[19:11] <r0nny> jibs ?

[19:11] * kane_ points r0nny at the S22 draft

[19:11] <rafl> When do you expect to be done so I can pull it and leave?

[19:11] <kane_> hopefully within the hour

[19:11] <kane_> provided no stupid perl things annoy me :)

[19:12] <kane_> you can pull now though, and just remember i'm hacking on those 2 sections :)

[19:12] <kane_> i'll just commit something that's save then

[19:12] <rafl> OK. I hope the WLAN at $rafls_destination hasn't changed its WEP key again. :-)

[19:13] <kane_> just committed 

[19:14] <kane_> Committed revision 8065.

[19:14] <kane_> that should be fairly safe

[19:14] * kane_ finds hacking stuff in and leaving lots of XXX markers speeds things up :)

[19:15] *** _SamB_ is now known as SamB

[19:15] <svnbot6> r8065 | kane++ | * rework config.pm to be mutable

[19:15] <svnbot6> r8065 | kane++ | * add a few config settings from prototypes _inc.pl

[19:15] <svnbot6> r8065 | kane++ | * add more tests for config.pm

[19:15] <svnbot6> r8065 | kane++ | * add a conf.pl to be loaded at the beginning of a test to set up the environment

[19:15] <rafl> kane_: Thanks.

[19:15] <r0nny> Module::Build is fun - unfortunately is supports only perl

[19:15] <rafl> kane_: Hm... acceleration X's :-)

[19:15] <kane_> rafl: exactly.. im just taking our prototype and throwing it in a good API

[19:15] <kane_> the guts will need fixing up then obviously

[19:17] <rafl> Indeed.

[19:17] <rafl> Bye!

[19:18] <r0nny> kane_: are u going to support multiple build systems ?

[19:18] <kane_> r0nny: yes

[19:18] <r0nny> sweet

[19:19] <r0nny> plz tell me, if its ready

[19:20] <kane_> ok

[19:21] <r0nny> i want my system to fit from the beginning

[19:22] <r0nny> btw - how are u doing the depency solving ?

[19:24] <kane_> there's a dependency engine -- i suggest you read the S22 draft, it explains a lot

[19:27] <r0nny> hmm

[19:28] <r0nny> i'd say add llvm support, and then allow bytecode modules

[19:29] <kane_> what are you talking about?

[19:30] <r0nny> right - forgot to mention the context

[19:32] <r0nny> i'd like to see a distribution, where the users can load bytecode modules, are faster loaded - and since llvm supports this for c-bits and reachs native speed it would be very usefull

[19:34] <kane_> sounds great... do it :)

[19:35] <r0nny> omg - im allmost on my limits with studying, the build system and the os

[19:36] <r0nny> how could i possibly get llvm support into perl6

[19:36] <kane_> dunno... persuade someone else to do it then.. just dont look at me :)

[19:37] * r0nny looks at kane_ with the "who else coud do" eyes

[19:37] <kane_> package manager > bytecode imho

[19:37] * kane_ points at his just 2 hands

[19:38] <r0nny> i could give u some others - i know much people only need one ;P

[19:38] <svnbot6> r8066 | kane++ | * remove loc() strings

[19:39] <kane_> ok, now you're just freaking me out 

[19:40] * r0nny puts another "freaked-out-person" stamp on his wall

[19:56] <svnbot6> r8067 | kane++ | * add a .jib file for testing

[19:56] <svnbot6> r8067 | kane++ | * add work in progress install code to package.pm

[19:56] <svnbot6> r8067 | kane++ | * remove loc() string from constants

[19:56] <svnbot6> r8067 | kane++ | * add installation.pm & tests to use for query local installation information

[20:01] <Alias_> .jib?

[20:01] <DesreveR> hmm

[20:01] <DesreveR> jesus is back

[20:02] *** DesreveR is now known as r0nny

[20:02] * kane_ waves in the general direction of S22 once more :)

[20:02] <r0nny> ;P

[20:02] * r0nny hands kane a wave-mashine

[20:14] <svnbot6> r8068 | kane++ | * get basic install working jib::package

[21:18] <Khisanth> hmm yaht.kwid

[21:19] <Khisanth> kane_: where is the perldoc program that can actually parse S22draft.pod?

[21:24] <r0nny> Khisanth: usually its part of the perl5 dist

[21:25] <Khisanth> hmm this version handles it but someone what having problems with some of the directives

[21:26] <r0nny> hmm

[21:52] *** Lopo_ is now known as Lopo

[22:38] <venk> attach irc.perl.org

[22:57] <autrijus> the "nap" turns out to be 13 hours :/

[22:59] <wolverian> it's good for you :)

[23:00] <wolverian> goo looks really neat, I just can't figure out how to use it

[23:00] <wolverian> if anyone has tips, please do share :)

[23:08] * autrijus runs to airport to meet Alias

[23:09] <Khisanth> goo?

[23:10] <Khisanth> use Goo; splatter "wolverian"; ?

[23:18] <wolverian> see http://thegoo.org/about.html, particularly the tour

[23:19] <wolverian> (and the LPW slides, too.. they're on the LPW site I believe.)

[23:19] * Khisanth damns the ,

[23:19] <wolverian> sorry :)

