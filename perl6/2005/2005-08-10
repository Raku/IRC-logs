[00:44] <svnbot6> r6154 | iblech++ | PIL2JS: Hack to make PIL2JS work again. Instead of calling return

[00:44] <svnbot6> r6154 | iblech++ | continuations, we throw a function which runs them. PIL2JS.runloop catches the

[00:44] <svnbot6> r6154 | iblech++ | exception and runs the function then. Thereby we break the stack problem,

[00:44] <svnbot6> r6154 | iblech++ | but it feels extremely hacky to always throw exceptions... Sadly #javascript

[00:44] <svnbot6> r6154 | iblech++ | doesn't have a less hacky answer, either.

[00:45] <iblech> JS people: How can I tailcall to a function?

[00:45] * iblech goes to sleep and hopes he'll find an elegant solution to the stack overflow problem :)

[00:45] <iblech> Night all :)

[00:47] <stevan> anyone familiar with PIL or PIL2 around?

[02:29] <dudley> stevan: I'm committing what I've got so far on the Java meatmodel.

[02:30] <dudley> It needs a lot of work, but real life threatens to take a lot of my time soon, so I figured I'd just check in what I have.

[02:50] <svnbot6> r6155 | dudley++ | org.perl6.metamodel (Java):

[02:50] <svnbot6> r6155 | dudley++ | * Added some stuff to stevan++'s Java port of the JS meatmodel. Still very much

[02:50] <svnbot6> r6155 | dudley++ | a work-in-progress.

[02:56] <stevan> dudley++

[02:56] <stevan> dudley++

[02:56] <stevan> dudley++

[02:56] <stevan> dudley++

[02:57] <f0rth_> Java!

[02:57] <stevan> f0rth_!

[02:58] <dudley> stevan++ # I'm just a metaimplementation monkey.

[02:59] <stevan> dudley: very nice

[03:00] <stevan> dudley: you did quite a lot

[03:00] <stevan> this looks great

[03:01] <dudley> :-)

[03:03] <stevan> dudley: it looks like the only thing missing is the Perl6.Object right?

[03:04] <dudley> Yeah.

[03:04] <stevan> wow

[03:04] <stevan> dudley++ # :)

[03:04] <dudley> if you don't count roles, multimethods, etc... 

[03:04] <stevan> the JS metamodel does not have them yet either

[03:04] <stevan> well I hacked multimethods really badly the other day

[03:05] <dudley> I heard that, but I've been intentionally ignoring it while I worked on this stuff :)

[03:05] <stevan> dudley: it is a horridly ugly hack, so keep ignoring :P

[03:06] <dudley> :)

[03:06] <stevan> we had to add an arity parameter to methods

[03:06] <stevan> which we then checked against the args.length

[03:06] <stevan> the first match of number of paramters won

[03:06] <stevan> *cough* bad-hack *cough*

[03:12] <dudley> ooh, I like $obj.meta.describes(Foo)

[03:12] <stevan> me too

[03:12] <stevan> I am not sure if it works for subclasses

[03:12] <stevan> like Foo.meta.describes(Bar) where Foo isa Bar

[03:13] <stevan> but isa() could easily be implemented with WALKCLASS then

[03:13] <dudley> Seems sane to me.

[03:14] <stevan> I like WALKCLASS and WALKMETH, they are very useful

[03:14] <stevan> those are right out of APoc 12 too

[03:15] <dudley> But that's just for entertainment, you can't take it seriously :)

[03:15] <stevan> :D

[03:15] <stevan> info-tainment 

[03:16] <stevan> I am starting to feel like Roles are the catch-all for anything which does not fit nicely into any other category

[03:16] <dudley> I've had that feeling in the back of my brain for a while.

[03:17] <dudley> But I haven't read the Trait papers yet, so I assumed I just didn't understand them.

[03:18] <stevan> dudley: I think I might one of the only, if not *the* only one on p6l who has read all the trait papers

[03:19] <stevan> because after you read all the paper you think adding attributes to traits is just insanity

[03:19] <dudley> I wouldn't count autrijus out, but you're probably right

[03:20] <dudley> can you instantiate a role?

[03:20] <stevan> actually I have been meaning to try and get the guy who wrote those involved with Pugs 

[03:20] <stevan> you can, but it wraps it in an anon class first

[03:20] <dudley> well that feels a little better, then.

[03:20] <stevan> yes

[03:21] <stevan> but attributes is just really hard,.. because the questions becomes,.. who owns them

[03:21] <stevan> the role? the composing class?

[03:21] <stevan> and then what to do with conflicts?

[03:21] <stevan> surely methods refer to the attribute

[03:22] <stevan> so two methods which are not in conflict access two different attributes which are in conflict

[03:22] <stevan> the possibilities for ugly things are huge

[03:22] <stevan> s/things/things to happen/

[03:23] <dudley> This is perl, remember?

[03:23] <stevan> :)

[03:24] <stevan> my biggest worry is that something like this will make roles too unpredictable to be useful

[03:24] <stevan> because you will need to look inside the role too much

[03:24] <stevan> and that will kill their reusability on anything but a very small scale

[03:26] <dudley> What does a role get you that you can't get from mixins and interfaces?

[03:26] <stevan> well, the method conflict resolution is one, the second is the compositional aspect

[03:27] <stevan> interfaces have no impl, so having an impl is a big win right there

[03:27] <stevan> mixins tend to be implemented in a number of ways

[03:27] <stevan> sometimes they inject themselves into the inheritence heirarchy

[03:27] <stevan> which is ugly

[03:27] <stevan> if I wanted that, I would make a class

[03:28] <svnbot6> r6156 | fglock++ | * Perl6::Value::List - Started syncing Perl6/Perl5 versions

[03:28] <svnbot6> r6156 | fglock++ | * Removed class Lazy::Range

[03:28] <svnbot6> r6156 | fglock++ | * Lowercase Array methods fetch(), store()

[03:28] <svnbot6> r6156 | fglock++ | * Removed redundant Array methods next(), previous()

[03:28] <stevan> with Roles/traits, the methods are actually composed into the class

[03:28] <stevan> so the methods are actually added to the metaclass

[03:28] <stevan> the role itself is just a holder, it is not needed once it is added into the class

[03:29] <stevan> then when you add in a bunch of roles, there is specific method conflict rules

[03:29] <stevan> if two methods conflict, neither is used

[03:29] <dudley> I guess that's what I always thought mixins were

[03:29] <dudley> wait, neither is used?

[03:29] <stevan> yup

[03:30] <dudley> Exception?

[03:30] <stevan> the beauty of this, is that it means order of roles does not matter

[03:30] <stevan> no, it is just removed from the list

[03:30] <stevan> the class must implement it to resolve the conflict

[03:30] <stevan> or exception

[03:30] <stevan> so it forces you to deal with the problem

[03:30] <dudley> ahh, okay

[03:30] <stevan> and the composition becomes "safer"

[03:31] <stevan> and not having to worry about role ordering is also very useful

[03:31] <stevan> it simplifies the combinations

[03:32] <stevan> class Foo does Bar does Baz {} is the same as class Foo does Baz does Bar {}

[03:32] <stevan> a whole class of subtle bugs disappear

[03:32] <dudley> I like that very much.

[03:32] <stevan> yes me too

[03:33] <stevan> but you add attributes into the mix, and a whole new class of bugs show up

[03:33] <stevan> one of these days I will go on a p6l crusade to abolish role attributes, but I just dont have the time to fight it right now

[03:33] <dudley> are role attributes canon, or is there room for discussion?

[03:34] <stevan> well, hard to say, roles are still fuzzy

[03:34] <stevan> we had many discussions about them at the hackathon and at YAPC

[03:34] <stevan> but never any resolution, only more questions really

[03:34] <mugwump> I take it you're talking about private attributes only

[03:34] <stevan> mugwump: no, public too

[03:34] <mugwump> as public role attributes are just methods

[03:34] <mugwump> which are subject to normal dispute resolution

[03:34] <stevan> mugwump: yes, that was in your thread

[03:35] <stevan> but is it "the way" now?

[03:35] <mugwump> I've been out of the loop - I didn't get time to push through the $.foo vs ./foo() thing yet

[03:35] <stevan> because that also impacts how methods are defined in classes as well

[03:35] <stevan> I liked where larry was going with it, but it seemed to fizzle out (or maybe I just got distracted)

[03:36] <mugwump> It was laid down to settle I guess

[03:36] <stevan> ah

[03:37] <stevan> honestly, the best thing will probably be for people to start using roles

[03:37] <stevan> and see what happens

[03:37] <stevan> I have been known to overthink things like this, and be too pessimistic

[03:39] <dudley> pessimism--

[03:39] <stevan> I like to think of it as pragmatism, but my wife disagrees :)

[03:40] *** ods15_ is now known as ods15

[03:42] <dudley> :)

[03:46] <dudley> Goodnight. &

[03:46] <stevan> night dudley 

[03:46] <stevan> dudley++ # welcome to meta-land

[03:49] *** spinclad_ is now known as spinclad

[04:31] *** khisanth__ is now known as Khisanth

[04:57] <brentdax> I have a system of approximately 2725 lines, plus CGI.pm and FindBin.pm.

[04:57] <brentdax> It takes 55 wallclock seconds (44 real) to run pugs -c on it.

[04:59] <brentdax> (Oh, the 2725 includes POD.)

[06:09] <svnbot6> r6157 | Stevan++ | Perl6::MetaModel - (p5)

[06:09] <svnbot6> r6157 | Stevan++ | * eliminated dependence on $<package>::META variables 

[06:09] <svnbot6> r6157 | Stevan++ |   (except in MetaClass, but thats for the bootstrap)

[06:09] <svnbot6> r6157 | Stevan++ | * added a ::find_class global fuction to map names to classes

[06:09] <svnbot6> r6157 | Stevan++ | * added ASCII art from p6l post to 10,000 view

[07:21] <autrijus> rehi

[07:21] * autrijus is still at $work :-(

[07:22] * castaway_ comforts autrijus 

[07:22] *** castaway_ is now known as castaway

[07:22] * autrijus purrs

[07:24] <castaway> all this having to work in order to eat, in order to be able to do the fun stuff, is annoying ,)

[07:25] <autrijus> I'd say

[07:25] <castaway> there should be some way to get an exemption 

[07:34] <svnbot6> r6158 | autrijus++ | * rename "Single" to "Item" and "Plural" to "List".

[07:34] <svnbot6> r6158 | autrijus++ | * the "Str" representation is now using Data.PackedString

[07:34] <svnbot6> r6158 | autrijus++ |   for efficiency.  Still gotta fix its latin1 bias.

[07:34] <castaway> .oO( 6158 !? )

[07:37] <masak> 6158 is an impressive number by any standard

[07:37] <masak> since feb 1, that many changes have been made to pugs

[07:37] <masak> wow

[07:38] <castaway> yup

[07:39] <GeJ> is there some CIA-like site for pugs?

[07:39] <autrijus> GeJ: CIA :)

[07:39] <autrijus> (look for 'perl6')

[07:40] <GeJ> autrijus: thanks

[07:40] <autrijus> np...

[07:40] <GeJ> I just wish CIA could respond

[07:40] <autrijus> :)

[07:40] <castaway> CIa-like?

[07:41] <autrijus> cia.navi.cx

[07:41] <autrijus> currently offline

[07:42] <castaway> ah.. and why does it sound like its run by the central intelligence agency? :)

[07:43] <autrijus> because it's designed to be a central intelligence centre for open source proejcts

[07:43] <autrijus> bbiab

[07:45] <castaway> aha (dont we have enough of those?)

[07:57] <autrijus> maybe -- I'm not too familiar with those

[07:58] <castaway> well, me either ,)

[10:05] <nothingmuch> autrijus: how goeth pil2?

[10:05] <castaway> he's $working, or was..

[11:09] <autrijus> nothingmuch: still $working.

[11:10] <autrijus> 50% less time available means something like 75%+ less productivity

[11:10] <autrijus> because it takes time to enter the zone, etc.

[11:17] <nothingmuch> yeah, i know the feeling

[11:17] * nothingmuch suffers too much from context switching at work

[11:19] <autrijus> c'est la vie :)

[11:20] <castaway> (multitasking++)

[11:24] <ods15> lol nothingmuch 

[11:24] * Arathorn seems to be context switching with about 2.5-day timeslices and a load of about 14 :(

[11:26] <autrijus> I'm switching in ~5hr chunks :(

[11:52] *** Aankh|Clone is now known as Aankhen``

[11:55] <vkon> are there serious reasons why *.o and '*.hi' files got copied when 'make install'?

[11:57] <nothingmuch> vkon: whether serious or silly, they are probably wrong

[11:57] <nothingmuch> Arathorn: my slices are between 10 minutes and 5 hours

[11:57] <nothingmuch> and load average is between .5 to 6 or so

[11:58] <vkon> as always, patches welcome?

[11:59] <nothingmuch> vkon: indeed

[11:59] <nothingmuch> do you have a commit bit?

[12:00] <vkon> I am able to commit, and will try to fix it, but not right now. (few hours later)

[13:26] <autrijus> er, .o will get installed

[13:26] <svnbot6> r6159 | fglock++ | New List methods: is_contiguous(), to_str(), clone(), to_ref(), to_bit(), to_num()

[13:26] <autrijus> because that's how pugscc can work

[13:26] <autrijus> .hi too

[13:26] <autrijus> so please don't touch that part

[13:26] <autrijus> think of it as libperl.o

[13:26] <autrijus> (or rather .a)

[13:27] <dudley> I was wondering about that when I was looking at the installer

[13:27] <dudley> and then promptly forgot about it :)

[13:36] <fglock> autrijus: I'm trying to find the right place for my files - 'perl5/' is for Perl5 runtime - where do Perl6 (and javascript, parrot) files go?

[13:38] <autrijus> fglock: Perl6 files go to ext/.

[13:38] <fglock> ok - just to be sure

[13:39] <autrijus> I think javascript runtime should eventually go to javascript/; parrot runtime should maybe go to parrot/.

[13:39] <luqui> hey autrijus, I'm writing the thingy that disallows assignments in conditionals

[13:39] <autrijus> but that's not very imporatnt right now

[13:39] <luqui> isn't this the identity function:

[13:39] <luqui> condCheck parser = do { exp <- parser; parser }

[13:39] <autrijus> no

[13:39] <autrijus> exp <- parse; return exp

[13:39] <autrijus> also don't do that in parser please...

[13:39] <luqui> por que?

[13:40] <autrijus> I thought larry said that all assignements is to be disallowed in boolean context.

[13:40] <luqui> I wasn't sure about that

[13:40] <autrijus> my Bool $x = ($_ = 3); # also disallowed

[13:40] <luqui> and to get it you could say:

[13:40] <autrijus> <lwall>

[13:40] <autrijus> because we've said that assignment to an *existing* variable in a boolean

[13:40] <autrijus> context is illegal:

[13:40] <luqui> my Bool $x = do { $_ = 3 }

[13:40] <luqui> except... that's still in boolean contet

[13:40] <autrijus> yes

[13:41] <autrijus> even

[13:41] <luqui> so, uh, how do you do it if you want to

[13:41] <autrijus> ($_ = 3) ?? 1 :: 0

[13:41] <autrijus> is still boolean context.

[13:41] <autrijus> my Bool $x = ?($_ = f());

[13:41] <autrijus> is fine, though.

[13:41] <fglock> autrijus: i was rethinking 1|2..Inf - I think it should be compiled to 1..Inf|2..Inf - lists don't have to worry about junctions

[13:42] <luqui> I don't understand why

[13:42] <autrijus> hm, no, as ? still imposes boolean context.

[13:42] <autrijus> you can't win

[13:42] <autrijus> my Bool $x = do { $_ = f(); $_ }

[13:42] <autrijus> is the only way out.

[13:42] <luqui> ouch

[13:42] <luqui> maybe we need a function ::T --> Bool

[13:43] <autrijus> that function is called (as Bool)

[13:43] <luqui> so it is

[13:43] <autrijus> my Bool $x = (($_ = f()) as Bool)

[13:43] <autrijus> as is coerce, so imposes no context.

[13:43] <luqui> yikes... well... fair enough

[13:44] <luqui> where do you suggest that I approach it

[13:44] <autrijus> if you don't like it, check with larry, but don't touch the parser

[13:44] <autrijus> it's not the layer

[13:44] <luqui> okay, but just on the haskell side about my earlier question, isn't:

[13:44] <luqui> condCheck parser = do { whatever I dont care blah blah blah; parser } the identity no matter what?

[13:44] <autrijus> (if you want, make it a runtime error, in Eval.hs's reduceSyn "=")

[13:45] <autrijus> (but it really belongs to the typecheck layer)

[13:45] <luqui> which doesn't exist yet?

[13:45] <autrijus> which will exist src/PIL/

[13:45] <autrijus> but is not available to the current runcore.

[13:45] <autrijus> so, to answer your question

[13:46] <autrijus> it's identity only if the "whatever" does not involve the "parser"

[13:46] <autrijus> consider

[13:46] <autrijus> condCheck parser = do { parser ; parser ; parser }

[13:46] <autrijus> surely it's not identity.

[13:46] <luqui> hmm... oh yeah, it goes through the combinator three times

[13:46] <autrijus> so you want

[13:47] <autrijus> condCheck parser = do { exp <- parser ; ... exp ... ; return exp }

[13:47] <luqui> it is only the identity for the combinators that I'm using for my mental model :-)

[13:47] <autrijus> yes. :)

[13:47] <autrijus> maybe we should call the things mentalmodels.

[13:47] <autrijus> mentalclass, mentalobjects

[13:48] <autrijus> fglock: that is certainly my intuition, yes.

[13:48] <fglock> thanks

[13:48] <autrijus> :)

[13:48] <autrijus> luqui: btw, do you think my unification algorithm is sane?

[13:49] <luqui> where?

[13:49] * luqui isn't quite through all his mail after the trip home

[13:49] <autrijus> role Coerce[::to] { method coerce (--> ::to) { ... }

[13:49] <autrijus> }

[13:49] <autrijus> multi *coerce:<as> (( Coerceable[T] $from : Type ::T

[13:49] <autrijus> ) --> T) { $from.coerce }

[13:49] <autrijus> the unification proceeds by inspecting type variables in both type and param position

[13:49] <autrijus> as denoted by ::

[13:50] <autrijus> and unify toward common supertype

[13:50] <autrijus> then it binds the instantiated (monomorphic) types

[13:50] <autrijus> and typecheck the term types normally.

[13:50] <autrijus> so

[13:51] <autrijus> sub id (::T $x --> T) {}

[13:51] <autrijus> will not degenerate to Any

[13:51] <autrijus> while

[13:51] <autrijus> sub id (::T $x --> ::T) {}

[13:51] <autrijus> just degenerates to Object or Any in the worst case.

[13:51] <luqui> ah, we considered that

[13:52] <luqui> basically, sub foo (::T $x, ::T $y) {...}

[13:52] <luqui> looks symmetric and is symmetric

[13:52] <luqui> but sub foo (::T $x, T $y) {...}

[13:52] <autrijus> great. sick minds think alike

[13:52] <autrijus> so @Larry is okay with that?

[13:52] <luqui> doesn't look symmetric and doesn't behave that way either

[13:52] <luqui> well, he's kind of punting the exact semantics of type inference

[13:52] <autrijus> also the binding is not positional

[13:52] <autrijus> sub foo (T $x, ::T $y) {}

[13:52] <autrijus> will also DWIM.

[13:53] <luqui> that's an interesting prospect

[13:53] <autrijus> sure, he can punt because I'd like to make it my job :)

[13:53] <luqui> I was actually thinking about this some

[13:53] <autrijus> just that he's not actively against this idea, is good enough

[13:53] <luqui> Any degeneracy isn't as much as a problem as I thought

[13:53] <autrijus> huh.

[13:53] <luqui> sub id (::T $x --> T) { $x }

[13:54] <autrijus> with degeneracy, it means adding id() around terms will suddenly make everything typecheck.

[13:54] <luqui> my Int $foo = id("Bar");

[13:54] <autrijus> bzz, does not typecheck

[13:54] <autrijus> but if you wrote ::T and ::T

[13:54] <luqui> okay, assume I wrote that

[13:54] <autrijus> then it degenerates and typechecks.

[13:54] <luqui> no, it doesn't

[13:54] <autrijus> binding T to Item or something.

[13:54] <luqui> watch:

[13:55] <luqui> the system above is equivalent to the following equations:

[13:55] <svnbot6> r6160 | scook0++ | * Un-break Haddock for the new PIL stuff

[13:55] <svnbot6> r6160 | scook0++ | * s/it's/its/ in 10_000_ft_view.pod

[13:55] <luqui> does("Bar", T)

[13:55] <luqui> does(T, Int)

[13:55] <luqui> which can only have a solution if "Bar" does Int, which it doesn't

[13:55] <autrijus> er no.

[13:56] <autrijus> you can have Any as a solution, or (Str (+) Int) as a solution.

[13:56] <luqui> Any is not a solution that

[13:56] <luqui> because !does(Any, Int)

[13:56] <luqui> likewise with (Str (+) Int)

[13:56] <autrijus> eh?

[13:56] <autrijus> I'm missing something.

[13:57] <luqui> can you clarify what you're missing :-)

[13:57] <autrijus> ok.

[13:57] <autrijus> you said Any does Int is false.

[13:57] <autrijus> yet

[13:57] <autrijus> sub id (Any $x --> Any) { $x }

[13:57] <autrijus> is the default type.

[13:57] <luqui> no it's not

[13:57] <autrijus> i.e. when the user has no annotation.

[13:57] <autrijus> ooh it's not.

[13:58] <luqui> we were considering, before we abolished junctions, that sub id (Whatever $x --> Whatever)

[13:58] <luqui> is default

[13:58] <luqui> where Whatever is the mere mortal name for none()

[13:58] <fglock> about the 'comma' operator - if 1,2,5..Inf is a list - scalar,scalar,list - a 'List' may contain lists? (the implementation would be cleaner if comma returned 'Array')

[13:58] <luqui> because none() never fails to typecheck

[13:58] <luqui> however, using such junctions, you can prove that every type is equal to every other type

[13:58] <luqui> so we killed them

[13:58] <luqui> now we need a way to introduce untypechecked values again

[13:59] <autrijus> yes.

[13:59] <autrijus> in haskell it's known as Dynamic.

[13:59] <luqui> is there a mathematically pure way to introduce such a type?

[13:59] <luqui> (if haskell has it, I would assume so)

[13:59] * luqui goes and looks at the Dynamic docs

[14:00] <luqui> but Whatever is an interesting prospect

[14:00] <svnbot6> r6161 | Stevan++ | Perl6::MetaModel - (p5)

[14:00] <svnbot6> r6161 | Stevan++ | * more untangling from the p5 package the de-sugared form

[14:00] <svnbot6> r6161 | Stevan++ |   seems to be package/AUTOLOAD free now though.

[14:00] <autrijus> sure, Dynamic is just a simple type with two coercers:

[14:00] <luqui> it can represent anything and can coerce to anything

[14:00] <autrijus> toDyn :: a -> Dynamic

[14:00] <autrijus> fromDynamic :: Dynamic -> Maybe a

[14:00] <luqui> well, yeah, that looks good

[14:00] <autrijus> but haskell has no subtyping

[14:00] <autrijus> ;)

[14:01] <luqui> why does subtyping kill things?

[14:01] <autrijus> oh, because in haskell asking .does is silly

[14:01] <autrijus> no monotype .does another

[14:01] <luqui> ahh

[14:01] *** autark is now known as jp-autark

[14:01] <autrijus> anyway.

[14:01] <luqui> I'm trying to figure out how coercions work

[14:01] <luqui> in the set world-view

[14:01] <autrijus> please explain why (Int (+) Str).does(Int) is false.

[14:02] <autrijus> what about Int.does(Int (+) Str) ?

[14:02] <autrijus> also false?

[14:02] <luqui> because "Int" (in) (Int (+) Str)

[14:02] <luqui> sorry

[14:02] <luqui> because "foo" (in) (Int (+) Str)

[14:02] <luqui> but "foo" is not (in) Int

[14:02] <autrijus> right, so it only responds covariantly

[14:03] <autrijus> now how do I write a type that .does(Int) and also .does(Str)?

[14:03] <autrijus> I used to be able to say Int|Str.

[14:03] <autrijus> which is the standard union type.

[14:03] <luqui> Int (+) Str

[14:03] <luqui> yeah

[14:03] <autrijus> er.

[14:03] <luqui> oh

[14:03] <luqui> wait

[14:03] <luqui> wrong

[14:03] <luqui> Int (*) Str

[14:03] <autrijus> good

[14:03] <luqui> intersection

[14:04] <autrijus> but nothing instantiates that.

[14:04] <autrijus> (disallowing '1' for now)

[14:04] <luqui> right, because Int and Str are by default disjoint

[14:04] <luqui> so Int (*) Str is the same as writing Bottom (or whatever we call it)

[14:05] <luqui> but there's nothing stopping you from writing:

[14:05] <luqui> role IntStr does Int does Str {...}

[14:05] <luqui> then Int (*) Str is not empty, as long as IntStr has an instance

[14:06] <luqui> this is what we get out of having Int and Str be roles

[14:06] <autrijus> but still, it's not the same as Int|Str.

[14:06] <luqui> not at all

[14:06] <autrijus> so you took that functionality away.

[14:06] <autrijus> yay, one less thing to worry about.

[14:07] <luqui> this was the proof that convinced the rest of @Larry to take that away:

[14:07] <luqui> Foo (<=) (Foo|Bar)

[14:07] <luqui> Bar (<=) (Foo|Bar)

[14:07] <luqui> therefore, Foo = Bar

[14:07] <luqui> (hmm, for some reason my head is broken)

[14:08] <autrijus> yeah

[14:08] <autrijus> your proof is not sound at all.

[14:08] <luqui> (that might be wrong, but the one I wrote on the whiteboard was right)

[14:08] <autrijus> 1 <= 3; 2 <= 3; 1 = 2

[14:08] <autrijus> yay

[14:08] <nothingmuch> hola

[14:08] <autrijus> whatever proof you wrote, it can be repeated at value domain with junctions.

[14:08] <luqui> yeah

[14:09] <luqui> that's why it's important that "use junctions" be off by default

[14:09] <luqui> so they're merely a syntactic convenience

[14:09] <autrijus> ?eval 2 <= (1|2)

[14:09] <evalbot6> bool::false 

[14:09] <luqui> hi nothingmuch 

[14:09] <autrijus> eh.

[14:09] <luqui> autrijus, wtf?

[14:09] <autrijus> ?eval ?(2 <= (1|2))

[14:09] <evalbot6> bool::true 

[14:09] <autrijus> luqui: bad output parser.

[14:09] <luqui> oh...kay

[14:09] <luqui> ahh

[14:09] <autrijus> ?eval ?((1|2) <= 1)

[14:10] <evalbot6> bool::true 

[14:10] <autrijus> ?eval ?(2 <= (1|2) <= 1)

[14:10] <evalbot6> bool::false 

[14:10] <autrijus> clever!

[14:10] <autrijus> that's entirely correct!

[14:10] <luqui> how does it do that?

[14:10] <autrijus> so your proof isn't much of proof at all :)

[14:10] <autrijus> luqui: it expands to ((2 <= 1 <= 1) | (2 <= 2 <= 1))

[14:10] <autrijus> because multiway comparison autothread as a listfix.

[14:10] <autrijus> or rather chainfix.

[14:10] <luqui> oh neat

[14:10] <luqui> good for it

[14:11] <nothingmuch> autothreading is teh suxx0r

[14:11] <luqui> here's the proof, though since my brain is broken, it's longer than it was on the whiteboard:

[14:12] <luqui> A (<=) (A|B); (A|B) (<=) B; B (<=) (A|B); (A|B) (<=) A; therefore A = B

[14:12] <luqui> so every type is equal to every other type :-)

[14:12] <luqui> nothingmuch, por que?

[14:13] <integral> (A|B) (<=) B?  aren't the methods available (statically) on A|B the intersection of the methods available on A and B?

[14:13] <luqui> integral, damian wanted junctive types to behave like junctive values

[14:13] <luqui> since those types are utter nonsence, we changed (A|B) to (A (+) B) (the set union of A and B)

[14:14] <integral> oh, ok, | is a junction constructor to you,  I wasn't thinking of it as that

[14:14] <autrijus> ok. go back to union types.

[14:14] <autrijus> sub f (Int (+) Str $x) {}

[14:14] <autrijus> what can you do to $x

[14:14] <autrijus> ?

[14:14] <autrijus> only things that you can do to _both_ Int and Str right?

[14:14] <luqui> hmm.. I suppose so

[14:15] <autrijus> which is not at all useful.

[14:15] <integral> but isn't perl dynamic?

[14:15] <luqui> right, this is the static side

[14:15] <integral> So statically you don't know if it'll always be possible,  but you can do it anyway at runtime

[14:15] <luqui> and I'd like to work things out strictly, and then figure out how we can elegantly relax it

[14:15] <autrijus> integral: but then all hope is lost for the results

[14:16] <autrijus> I mean the result types.

[14:16] <autrijus> because we don't have junctive types now.

[14:16] <autrijus> previously you can carry type information around

[14:16] <autrijus> using junctives

[14:16] <luqui> autrijus, example?

[14:16] <autrijus> subtype Int_Str of (Int (+) Str);

[14:17] <autrijus> thinking

[14:18] <autrijus> multi sub foo (Str $x --> Int) {...}

[14:18] <autrijus> multi sub foo (Int $x --> IO) {...}

[14:18] <autrijus> my Int_Str $x := 3;

[14:19] <autrijus> what's the type of "foo(3)" statically?

[14:19] <luqui> IO

[14:19] <luqui> but

[14:19] <autrijus> ok. what is "foo($x)"?

[14:19] <luqui> Int (+) IO

[14:19] <luqui> ... I think

[14:19] <autrijus> ok. what if I take the first case (Str --> Int) away?

[14:20] <luqui> type error

[14:20] <luqui> eew

[14:20] <autrijus> ;)

[14:20] <autrijus> how can I write something that's (Int_Str --> IO) then.

[14:21] <autrijus> sub f (Int_Str $x --> IO) {

[14:21] <autrijus>     given $x {

[14:21] <autrijus>         when Int { foo($x) }

[14:21] <autrijus>     when Str { foo(-1) }

[14:21] <autrijus>     }

[14:21] <autrijus> }

[14:21] <luqui> we could do that if we had a wicked smart inferencer

[14:21] <luqui> but I think in general it's undecidable

[14:21] <autrijus> this is called typecasing ;)

[14:21] <luqui> but where you really want to be is in pattern space

[14:22] <luqui> hmm, in haskell if you define a function :: SomeData -> Something

[14:22] <autrijus> there is a reason why no languages beside Algol 68 has union types ;)

[14:22] <luqui> if you don't exhaustively case SomeData, it lets you get away with it

[14:22] <autrijus> but it raises a warning that is fatal under -Wall

[14:22] <autrijus> also that's variant casing

[14:23] <autrijus> and this is typecasing.

[14:23] <luqui> eh, in perl land those are the same thing

[14:24] <autrijus> not at all... variant casing is statically sound

[14:24] <luqui> the top-level data is just a role that all the variants do

[14:24] <luqui> you mean by guaranteeing that you won't add at runtime?

[14:24] <autrijus> right, closed world

[14:24] <autrijus> you enumerate possible contructors, all yielding a monotype, at compiel time.

[14:25] <autrijus> while with typecasing you can change the .does relationship quite randomly.

[14:25] <autrijus> actually, entirely randomly.

[14:25] <luqui> at runtime?

[14:25] <luqui> no.. you can only add to it

[14:25] <luqui> or am I misunderstanding

[14:26] <autrijus> when you add to it, the original casing cease to be exhaustive

[14:26] <autrijus> anyway, let me think about it

[14:26] <autrijus> the Dynamic type is a pair of 

[14:26] <autrijus> (T, v)

[14:26] <autrijus> where T is a type tag and v is a value of that type

[14:26] <luqui> if you write it like Foo (+) Bar, then if you case over Foo and Bar, you're necessarily exhaustive

[14:27] <autrijus> right.

[14:28] <autrijus> ok.

[14:28] <autrijus> my Int_Str $x;

[14:28] <autrijus> you can only fetch $x in an environment that can accept both Int and Str

[14:28] <autrijus> right?

[14:28] <autrijus> (contravariance)

[14:29] <luqui> okay

[14:29] <luqui> as usual, ignoring perl's dynamic nature

[14:29] <autrijus> sometimes there's no dynamic nature :)

[14:29] <autrijus> it's just runtime failures

[14:29] <autrijus> or compile time error

[14:29] <luqui> anyway, go on

[14:29] <autrijus> my Int_IO $x; close($x)

[14:29] <autrijus> my Int_IO $x; ...; close($x);

[14:30] <autrijus> is blatantly unsafe

[14:30] <autrijus> either runtime or compile time.

[14:30] <luqui> yeah

[14:30] <autrijus> hm, so that pretty much means we need to have typecasing as a compile time form

[14:30] <autrijus> to recover its member types.

[14:30] <luqui> ?

[14:30] <autrijus> otherwise it's as good as Dynamic, aka Any.

[14:31] <luqui> ah

[14:31] <autrijus> because you can't write close($x) in any typesafe way

[14:31] <autrijus> unless you can typecase it apart.

[14:32] <autrijus> alright. I'll deal with it.

[14:32] <luqui> it would be nice to have a form of given that can pattern guard

[14:32] <luqui> given $x { when Int -> $int { ... } when IO -> $io {...} }

[14:32] <luqui> except actually good

[14:33] <autrijus> I thought it's legal.

[14:33] <autrijus> I mean, it's valid p6 already.

[14:33] <luqui> but would it imply that $int is an Int

[14:33] <autrijus> it would also imply that $x is Int.

[14:33] <luqui> true

[14:33] <luqui> hmm

[14:33] <luqui> could you infer that?

[14:33] <luqui> i mean, actually use it

[14:34] <autrijus> good question.

[14:34] <autrijus> given binds $x to $_

[14:34] <autrijus> so we need binding propagation, check

[14:34] <autrijus> when matches $_ to type

[14:34] <autrijus> so I need a rule for the when form.

[14:34] <autrijus> sub statement:<when>

[14:34] <autrijus> (...)

[14:35] <autrijus> but when is a macro that expands to

[14:35] <autrijus> if ($_ ~~ Int) { (-> $int {...}).($_) }

[14:35] <autrijus> right?

[14:35] <luqui> sub statement:<when> (Class ::T, &code:(T)) {..}

[14:36] <luqui> yeah, pretty much

[14:36] <autrijus> I need type environment for $_.

[14:36] <autrijus> hm.

[14:36] <luqui> when you reduce to single-assignment, can you reduce the type environment based on tests?

[14:36] <autrijus> yay, dependent types

[14:37] <autrijus> multi infix:<~~> (Any $x, Type ::T) { $x.does(T) }

[14:37] <autrijus> but that does not constrait $_ at all.

[14:37] <autrijus> which is why typecase is a special form.

[14:38] <luqui> makes sense

[14:38] <autrijus> so let's forget about that.

[14:38] <autrijus> I'll adopt your form.

[14:38] <autrijus> statement:<when> is a normal subroutine and contraints the $int

[14:38] <autrijus> but not the outer $x.

[14:39] <autrijus> you wrote Class ::T

[14:39] <autrijus> does it mean Int_Str is a Class?

[14:39] <autrijus> how come?

[14:39] <luqui> yeah, that was fudgeful

[14:39] <luqui> well, I want a type to be passed in, and then I want to use that type statically

[14:39] <autrijus> I thought you just write ::T.

[14:40] <luqui> doesn't that mean a value of type T

[14:40] <autrijus> huh.

[14:40] <autrijus> sub f (Int, Int) {...}

[14:40] <autrijus> I thought that's illegal.

[14:40] <autrijus> I thought you always need to name the params.

[14:40] <luqui> possibly so

[14:40] <luqui> well

[14:40] <autrijus> how else will you refer to it?

[14:40] <autrijus> ?eval sub f (Int) {}

[14:40] <evalbot6> Error:  unexpected ")" expecting word character, "?", "*", "+", "++" or parameter name 

[14:40] <luqui> except for siglets

[14:41] <autrijus> siglets?

[14:41] <luqui> but it's unclear whether you can put a siglet in a regular sub declaration

[14:41] <luqui> &foo:($,$)

[14:41] <luqui> short for &foo:(Any, Any)  (or (Whatever,Whatever), or whatever) :-)

[14:41] <autrijus> er no.

[14:41] <autrijus> it's short for

[14:42] <autrijus> &foo:(Scalar of Any, Scalar of any)

[14:42] <autrijus> &foo:(Scalar of Whatever, Scalar of Whatevery)

[14:42] <luqui> I don't really care

[14:42] <autrijus> nod. but as I said, it makes no sense to write it in sub decl.

[14:42] <autrijus> in p5 we had excuse because you can recover with @_

[14:42] <autrijus> not so in p6.

[14:42] <luqui> right

[14:42] <luqui> although, haskell has a use fo _

[14:42] <luqui> s/fo/for

[14:43] <autrijus> I'm fine with _.

[14:43] <autrijus> sub f (_) {}

[14:43] <luqui> how can you tell whether that's an array?

[14:43] <luqui> Array _

[14:43] <luqui> Array *_

[14:43] <autrijus> you can't, _ is anything.

[14:43] <luqui> ?

[14:43] <autrijus> if you want to enforce one of the container types always

[14:43] <luqui> anyway

[14:43] <autrijus> then allow

[14:44] <luqui> back to the issue at hand

[14:44] <autrijus> sub f ($, $) {}

[14:44] <autrijus> is fine

[14:44] <autrijus> sub f (Int $, Int $) {}

[14:44] <autrijus> is fine also

[14:44] <autrijus> but

[14:44] <autrijus> sub f (Int, Int) {}

[14:44] <autrijus> never makes any sense.

[14:44] <luqui> how do you say "I want a type that does Foo, not an object that does Foo"

[14:44] <autrijus> sub f (Foo ::T){} for sure?

[14:45] <luqui> ?

[14:45] <autrijus> for object you write sub f (Foo $o)

[14:45] <luqui> yeah, but it's a little different

[14:45] <luqui> for that, you're asserting that $o (in) Foo

[14:45] <autrijus> ...yes?

[14:45] <luqui> where as with Foo ::T, you're asserting that ::T (<=) Foo

[14:45] <autrijus> sure

[14:45] <autrijus> that's what the sigils means

[14:46] <autrijus> sub f (Foo @a)

[14:46] <luqui> hmm... but with array, you're asserting that Array.returns(Foo)

[14:46] <luqui> okay

[14:46] <luqui> cool

[14:46] <luqui> I like that quite a lot

[14:46] <autrijus> so sigils direct the relationship

[14:46] <autrijus> ok. now, does ::T and &x have a container type again?

[14:47] <luqui> hmm... you could also say that $o.returns(Foo) is being checked

[14:47] <autrijus> my proposals is that they are either values, or use the scalar container type.

[14:47] <autrijus> i.e. it makes no sense to tie either of them.

[14:47] <luqui> it's difficult to rebind values, no?

[14:47] <luqui> oh, but you can rebind names

[14:47] <autrijus> if you rebind &x, then you rebind using scalar's rebinding

[14:47] <autrijus> yes.

[14:48] <luqui> that depends on whether you can still say BEGIN { T := OtherType }

[14:48] <autrijus> also

[14:48] <autrijus> my &f = sub { 3 };

[14:48] <autrijus> should be legal.

[14:48] <autrijus> on the ground that

[14:48] <luqui> that might be nice

[14:48] <autrijus> my $x is constant = 4;

[14:48] <autrijus> is ruled legal.

[14:49] <luqui> and my T = Int

[14:49] <luqui> ?

[14:49] <autrijus> sure.

[14:49] <autrijus> my ::T = Int;

[14:49] <autrijus> you don't have prior T yet

[14:49] <autrijus> so can't use it as bare.

[14:49] <luqui> probably

[14:50] <autrijus> anyway. I want to establish a invariant:

[14:50] <autrijus> my Int $x; my Str $y; $x := $y;

[14:50] <autrijus> should not typecheck.

[14:50] <autrijus> but if that's allowed

[14:50] <autrijus> then the inferencer is hindered, but I'll deal.

[14:50] <luqui> It makes sense to me not to allow that

[14:51] <autrijus> my Int $x; my Str $y; if (rand(2)) { $x := $y; }; f($x);

[14:51] <autrijus> try infer that!

[14:51] <luqui> I wonder what the larger implications of that are though

[14:51] <luqui> does that mean:

[14:51] <luqui> my Int $foo;

[14:52] <luqui> use AModule <$foo>;   # error, can't rebind $foo

[14:52] <fglock> I need some help with array slices

[14:52] <autrijus> it's a double declaraion clash anyway.

[14:52] <autrijus> similar to "my $x; my $x"

[14:52] <luqui> in other words, we can't let people use types as a way to say "don't mess with me"

[14:52] <autrijus> you need another scope.

[14:53] <autrijus> my Int $foo; { use Module <$foo>; }

[14:53] <autrijus> is entirely fine.

[14:53] <luqui> but I guess you could always "use dynamic" on those bastards

[14:53] <autrijus> it's just normal shadowing.

[14:53] <luqui> so I think that should be okay

[14:53] <autrijus> it's just normal shadowing :)

[14:53] <luqui> oh yeah, because use is compile time

[14:53] <autrijus> no binding occurs here, sir

[14:53] <luqui> duh

[14:54] <luqui> and stuff

[14:54] <luqui> I get it

[14:54] <luqui> okay, my Int $x;  my Str $y;  $x := $y;  is illegal for now

[14:54] <autrijus> cool.

[14:54] <autrijus> it also means

[14:55] <autrijus> my Int $x; my Num $y; $x := $y; 

[14:55] <autrijus> is illegal

[14:55] <autrijus> my Num $x; my Int $y; $x := $y; 

[14:55] <autrijus> is illegal too.

[14:55] <autrijus> the only exempt type is Any, or Whatever, or Dynamic.

[14:55] <autrijus> fglock: yes?

[14:55] <luqui> not necessarily

[14:56] <luqui> it only needs to be contravariantly compliant if it is constant

[14:56] <autrijus> eh, a container is used bothways.

[14:56] <autrijus> you need invariance.

[14:56] <autrijus> oh constant, duh

[14:56] <autrijus> mmm that also means you can't rebind constancy away.

[14:56] <autrijus> right?

[14:56] <fglock> I think I found the solution myself. When you ask for a slice @a[1,2,10..Inf], the compiler splits this into 3 splices, so I don't have to care about complex lists, I think

[14:56] <luqui> if you can, then you lose your optimizations

[14:56] <autrijus> my Int $x is constant; my Int $y is rw; $x := $y;

[14:57] <autrijus> exactly so, but if you can rebind types away

[14:57] <autrijus> then those optimizations are doomed anyway.

[14:57] <autrijus> so for now we say neither.

[14:57] <luqui> fair enough

[14:57] * luqui just thought of something

[14:58] <luqui> if you can fudge (<=), then you can pretend that you're the same type as something else (call it Foo)

[14:58] <luqui> just make it so you are (<=) Foo, and Foo (<=) you

[14:58] <luqui> whee

[14:58] <autrijus> yup.

[14:58] <autrijus> I wonder why you didn't write (*) as /\ and (+) as \/

[14:58] <autrijus> ;)

[14:58] <luqui> we considered it

[14:59] <autrijus> (*) to me implies product types, not intersection.

[14:59] <luqui> and (<=) as (=

[14:59] <luqui> cartesian product you mean?

[14:59] <autrijus> yeah, as in tuples.

[14:59] <luqui> for some reason Larry seems to be reluctant to add tuples

[15:00] <autrijus> you can add tuples easily yourself anyway.

[15:00] <luqui> but if we do add them, it will probably look more like (A, B) than A (*) B

[15:00] <autrijus> sure.

[15:00] <autrijus> ok. I'll go back to my inferencing work. if you question assignment-in-boolean's sanity, please report back :)

[15:01] <autrijus> I don't think it can be a special form for if() and while().

[15:01] <autrijus> if ($x := 3) { ... }

[15:01] <autrijus> I wonder if people will learn to write that ;)

[15:01] <autrijus> if ($x := f()) { ... }

[15:02] <autrijus> which is almost as good as 

[15:02] <autrijus> if f() -> $x { ... }

[15:02] <autrijus> especially now we consider that $x's type stands.

[15:03] <luqui> yeah, that might be the way to go if you want the effects to continue after the if

[15:03] <autrijus> yup.

[15:03] <autrijus> p6 does seem more and more functional every day.

[15:04] <autrijus> as in, shying away from destructive updates.

[15:04] <autrijus> I wonder why.

[15:04] <luqui> but without being the bitch that functional languages seem to be for certain kinds of problems

[15:04] <autrijus> oh, ocaml handles those problems just fine :)

[15:04] * luqui has tried to learn ocaml several times

[15:04] <luqui> but not very well

[15:04] <autrijus> and ocaml has a good property - it doesn't confuse (Scalar of Int) with (Int)

[15:04] <luqui> s/well/hard/

[15:05] <autrijus> p6 confuses that, which is the root cause of endless confusions about container types.

[15:05] <luqui> how could p6 not confuse that?

[15:05] <autrijus> it can't... all C-family languages confuse that.

[15:05] <autrijus> in ocaml to read from a variable you need to write !ref

[15:05] <autrijus> not just ref

[15:06] <luqui> oh

[15:06] <autrijus> so

[15:06] <autrijus> print "hello, world"

[15:06] <autrijus> but

[15:06] <autrijus> print fetch($x)

[15:06] <autrijus> or something.

[15:06] <luqui> that's linguistically yucky

[15:06] <autrijus> print $x.val

[15:06] <luqui> but i can see its appeal

[15:07] <autrijus> sure it is, but at least you don't have the "function arguments are is constant" dilemma.

[15:07] <autrijus> instead you say "function arguments are values"

[15:07] <luqui> right

[15:07] <autrijus> so, different languages and different strengths, etc.

[15:07] <luqui> waterbed and whatnot

[15:07] <autrijus> yup.

[15:08] <autrijus> oh.

[15:08] <autrijus> my Bit $x = undef;

[15:08] <luqui> oh, I'm about to write the "value types manifesto"

[15:08] <autrijus> legal?

[15:08] <luqui> well, we'd have to special case it in order to disallow undef

[15:08] <autrijus> so yeah, another C-inherited thing :)

[15:08] <luqui> I kind of like undef being the sole instance of Bottom

[15:09] <luqui> maybe Undef is Bottom's name

[15:09] <autrijus> maybe. but then Undef can be used as really everything.

[15:10] <autrijus> a hash container, for example.

[15:10] <autrijus> for undef.kv() -> $k, $v { ... }

[15:10] <autrijus> you want that? :)

[15:11] <luqui> my $foo = rand 2 ? {} : undef

[15:11] <luqui> I kinda do

[15:11] <autrijus> my %x := undef;

[15:11] <autrijus> that is a large divergence from p5.

[15:11] <autrijus> where undef is an item

[15:11] <autrijus> never a collection.

[15:11] <autrijus> there is only empty array

[15:11] <autrijus> no undef array

[15:12] <luqui> but Larry has some problems with that

[15:12] <luqui> undef can carry error messages with it

[15:12] <autrijus> ok

[15:12] <autrijus> my Bit $x = fail "this is undef with error"

[15:12] <luqui> but it definitely requires more thought and exploration

[15:12] <autrijus> my %x := fail "hey look some error"

[15:12] <masak> why := ?

[15:12] <luqui> 'cept that ought to fail the current scope

[15:13] <autrijus> luqui: not when it's not fatal

[15:13] <luqui> no, it still exits current scope

[15:13] <autrijus> well

[15:13] <luqui> you want:  my $x = foo() // fail

[15:13] <autrijus> my %x := do { fail "hey look" }

[15:13] <luqui> to put something into $x and continue?

[15:13] <autrijus> better?

[15:13] <luqui> ?

[15:13] <autrijus> I want to bind undef into %x.

[15:13] <luqui> maybe you use "error" to create one or something

[15:14] <autrijus> and carry a message

[15:14] <autrijus> anyway, with that semantic, every type "a" in perl becomes

[15:14] <autrijus> Either Error a

[15:14] <autrijus> down to Bit level

[15:14] <luqui> but not bit

[15:14] <autrijus> right

[15:14] <luqui> because those guys don't participate in the type lattice

[15:14] <autrijus> granted.

[15:14] <autrijus> what about enums?

[15:14] <autrijus> nvm, they do

[15:15] * luqui doesn't grok enums in perl yet

[15:15] <autrijus> my Bool $x = undef;

[15:15] <autrijus> is just fine.

[15:15] <autrijus> so, fun, because no typecasing can catch that.

[15:15] <autrijus> or rather, the first when() typecase will succeed.

[15:15] <luqui> eew

[15:15] <autrijus> as Undef indeed inhabits it.

[15:16] <luqui> why does stuff have to be so complicated :-)

[15:16] <autrijus> usually a typeful language doesn't do this implicit null thing ;0

[15:16] <luqui> I wish it would all Just Work

[15:16] <luqui> dwimmy language design :-p

[15:16] <autrijus> actually I never saw one that does.

[15:16] <luqui> except, oh, C

[15:16] <autrijus> C is typeful?

[15:16] <luqui> if you pretend every type is a *

[15:16] <autrijus> C is so weakly typed, it's not typeful at all.

[15:16] <luqui> okay, C++

[15:17] <autrijus> ...still weakly typed.

[15:17] <luqui> C++ is typeful, it's just awkward

[15:17] <luqui> how is it weakly types

[15:17] <autrijus> (type*)

[15:17] <luqui> assume the nonexistence of the various casts

[15:17] <luqui> it's possible to write C++ without them

[15:17] <autrijus>  int a = 5;

[15:17] <autrijus>  float b = a;

[15:17] <luqui> yeah, Perl has those too

[15:17] <luqui> oh

[15:17] <luqui> what are you talking about?  that's just sugar

[15:17] <autrijus> no, perl does a explicit coercion based on inference. at least I hope so.

[15:18] <luqui> int a = 5;  float b = a;  cout << b;   # 5, not *(float*)&a

[15:18] <autrijus> oh!

[15:18] <autrijus> sorry, my bad then.

[15:18] <autrijus> thinko.

[15:19] <luqui> np

[15:19] <autrijus> anyway

[15:19] <autrijus> but int in C++ is not a pointer type.

[15:19] <luqui> nor in Perl

[15:19] <autrijus> while Int in p6 is a maybe type.

[15:19] <luqui> int isn't

[15:19] <autrijus> right. what about Code?

[15:20] <autrijus> Pair?

[15:20] <autrijus> Type?

[15:20] <autrijus> they are all maybe types ;)

[15:20] * luqui thinks pragma

[15:20] * autrijus doesn't think pragma is going to save you

[15:20] <autrijus> (fwiw, I think (code, pair, type, junc) should be intrinsics)

[15:21] <autrijus> if just to avoid undef probing in the runtime.

[15:21] <autrijus> as the runtime uses those 4 types a lot.

[15:21] <autrijus> having no unboxed form for them forces the prelude to use maybe types

[15:21] <luqui> yeah, undef as bottom is starting to sound worse

[15:21] <luqui> who expects my $x = undef;  $x.does(MyObject);  to be true

[15:21] <autrijus> er, but those four are not collections

[15:22] <autrijus> right.

[15:22] <autrijus> in PIL2 runtime:

[15:22] <autrijus> data Item = Undef | Object Object

[15:22] <autrijus>     | Int Int | Num Num | Str Str | Ref Ref | Bit Bit

[15:22] <autrijus>     | Pair Pair | Junc Junc | Type Type | Code Code

[15:22] <autrijus> the last line is apocryphal.

[15:22] <autrijus> but both iblech and I feel that need.

[15:22] <autrijus> as in, forcing all pair and code to be boxed back to Object

[15:23] <autrijus> is a pain :)

[15:23] <luqui> Int Int is "int" ?

[15:23] <autrijus> yes.

[15:23] <luqui> okay

[15:23] <autrijus> everything else is Object.

[15:24] <autrijus> and a Object type is actually a Maybe type.

[15:24] <luqui> I wonder if this has something to do with the declarative closed data types that I keep trying to propose

[15:24] <autrijus> Scala handles it thus:

[15:24] <autrijus> my Animal $x;  # never undef

[15:24] <luqui> "enums", but better

[15:24] <autrijus> my ?Animal $x;  # possibly undef

[15:24] <autrijus> and with a $x in type ?Animal

[15:24] <luqui> that was what I was thinking in the pragma

[15:24] <autrijus> you need to use defined() casing

[15:25] <autrijus> to call a method on it.

[15:25] <autrijus> this way you guarantee to eliminate _every_

[15:25] <autrijus> Can't call method "meth" on an undefined value 

[15:25] <autrijus> error

[15:25] <autrijus> in compile time.

[15:25] <luqui> the "use undef" (on by default) pragma would imply that every Foo is actually a ?Foo

[15:25] <autrijus> cool eh? :)

[15:26] <autrijus> my Animal $x is defined;

[15:26] <autrijus> XD

[15:26] <autrijus> actually it's not that bad.

[15:26] <autrijus> and then "no undef" will add "is defined" to things.

[15:26] <luqui> right

[15:26] <svnbot6> r6162 | fglock++ | * renaming Array-Lazy to Perl6-Container-Array, Perl6-Value-List

[15:26] <luqui> I think the pragma is important, because, like ::_, people who use it are going to want to use it all the time

[15:26] <autrijus> you think it's cool?

[15:27] <luqui> I like the idea though

[15:27] <autrijus> what's ::_ again

[15:27] <luqui> oh, it's not real (yet)

[15:27] <autrijus> ok. I'll p6l this idea.

[15:27] <luqui> it was brought up in the meetings to mean "this is strongly typed, but infer what type it should be"

[15:27] <luqui> my ::_ $x

[15:27] <autrijus> eh.

[15:28] <autrijus> isn't 

[15:28] <luqui> later reduced to my :: $x

[15:28] <autrijus> my $x

[15:28] <autrijus> good enough?

[15:28] <luqui> and later killed

[15:28] <luqui> no, my $x means my Whatever $x

[15:28] <autrijus> I see.

[15:28] <luqui> don't write any of this down

[15:29] <autrijus> sure.

[15:29] <luqui> it was a lot of speculating, without deciding whether it was a good idea

[15:29] <autrijus> my $x is typed;

[15:29] <luqui> you and your traits

[15:29] <autrijus> this is p6 ;)

[15:29] <luqui> but, after all, that's why we introduced them

[15:29] <luqui> good for you, get us out of linenoise hell

[15:30] <autrijus> use traits <constant typed defined Tieable>;

[15:30] <autrijus> my $x; # automagically said

[15:30] <autrijus> mmmmmm.

[15:31] <autrijus> I must say I like that.

[15:33] <luqui> you're now writing in a static language

[15:33] <svnbot6> r6163 | fglock++ | * removed old Array-Lazy

[15:33] <luqui> that you can declare to be dynamic when you feel like it

[15:33] <autrijus> yes.

[15:33] <autrijus> { no traits <typed>; ... }

[15:33] <luqui> if only writing compilers for static languages weren't orders of magnitude harder than for dynamic languages

[15:33] <luqui> I mean, and getting them to be optimally fast

[15:34] <autrijus> I would point out that writing good runtimes for dynamic languages is order of magnitudes harder.

[15:34] <luqui> fair enough

[15:34] <autrijus> it's the same carpet.

[15:34] <luqui> so that means that... um

[15:34] <luqui> we've got the worst of both worlds

[15:34] <autrijus> so that means p6 is very hard to implement.

[15:34] <autrijus> thank you, I already know that :)

[15:34] <luqui> haha

[15:34] <luqui> oh, did you fix the syntax error thingy that was bugging me so much

[15:35] <luqui> or do I still need to do that

[15:35] <autrijus> you mean ::Class::Name?

[15:35] <luqui> no, I mean syntax error line numbers propagating way too far up

[15:35] <luqui> given {  # 500 lines }

[15:35] <luqui> error on line of given

[15:35] <autrijus> oh that. I think I fixed that.

[15:35] <luqui> hooray

[15:35] <autrijus> not 100% sure

[15:35] <autrijus> but I think so

[15:36] <luqui> maybe I can start again on some p6p6 stuff

[15:36] <luqui> (not that I was really blocking on that)

[15:36] <luqui> (it was just annoying me)

[15:36] <luqui> (and I was just being lazy)

[15:36] <luqui> but I've come back from OSCON with a much better understanding of haskell at least

[15:37] <luqui> all I need to do is multiply that understanding by 10 and maybe I can hack on the .hs files in pugs

[15:38] <autrijus> :) I think I'll welcome your help on the PIL2 type inferencer.

[15:38] <autrijus> but I need to do some more Visiolization first.

[15:38] <autrijus> so I can visiolize the problem better.

[15:38] <luqui> what does V11n mean?

[15:38] <autrijus> luqui: it means drawing stuff out like http://pugscode.org/images/container.png

[15:38] <luqui> ahh that stuff

[15:39] <autrijus> it's made by visio, hence the name.

[15:39] <luqui> well, I'm interested in type inferencing stuff

[15:39] <luqui> so I welcome your invitation :-)

[15:39] <autrijus> yay. all you need is TaPL. failing that, the paper "colored type inference" is enough

[15:39] <luqui> is this going to be written in haskell

[15:39] <autrijus> the first pass, for sure, because you really want a minimally vague language to write that in.

[15:40] <luqui> or are we going to write the inferencer in perl6 and call out

[15:40] <autrijus> but when it's there, we can write it in the static dialect of p6 ;)

[15:40] <luqui> hehe

[15:40] <autrijus> problem is we don't have a static dialect yet.

[15:40] <luqui> right

[15:41] <integral> autrijus: "Colored local type inference"?

[15:41] <luqui> I've been working on an algorithm to solve the does() equations above

[15:42] <autrijus> right. sorry

[15:42] <autrijus> our problem is even harder than that paper's

[15:42] <autrijus> because we have both union and intersection types.

[15:43] <luqui> and difference :-)

[15:43] <autrijus> right, and difference types. that's very new, thank you.

[15:43] <luqui> no, we had it before with and(..., none(...)), but it was very poorly defined.

[15:44] <autrijus> I didn't think you can use junction literals in type position.

[15:44] <autrijus> I thought only infix

[15:44] <autrijus> and none() is not infix.

[15:44] <luqui> I thought you could before

[15:44] <luqui> anyway, it doesn't matter anymore

[15:44] <autrijus> none of AES says that.

[15:44] <autrijus> hurray :)

[16:12] <autrijus> luqui: my proposal is on p6l now :)

[16:13] <luqui> reading

[16:13] <luqui> hmm, do you realize that "use traits <defined>" is pretty similar to "use fatal"

[16:14] <autrijus> no.

[16:14] <autrijus> "use fatal" covers void functions

[16:14] <luqui> yeah

[16:14] <autrijus> as well as bindings

[16:14] <autrijus> as well as other things.

[16:14] <luqui> that's why I said "similar"

[16:14] * Limbic_Region wants a 'me' pragma

[16:14] <autrijus> well, yeah...

[16:14] <luqui> use me;

[16:14] <autrijus> sue me;

[16:15] <Limbic_Region> require me;

[16:16] <luqui> hmm, would "use me" just be a recursive call to "import" ?

[16:17] <luqui> oh, sorry, :-)

[16:17] <autrijus> I think you need the Ac prefix.

[16:17] <luqui> it could be implied by default when you're using Perl 6 at all

[16:17] <autrijus> luqui: I've read this rumour: http://www.sauria.com/blog/2005/08/04#1365

[16:17] <autrijus> "...The most interesting bit of information from Larry's talk is that the Pugs project appears to be the choice for the compiler for Perl 6. At least, I think that's what he said, because it was a little difficult to separate the information bits from the humor bits."

[16:18] <obra> Yeah. He said nice things about pugs.

[16:18] <obra> But not quite that

[16:18] <autrijus> I wonder what transpired to make ed think that.

[16:18] <autrijus> s/ed/Ted/

[16:19] <autrijus> *nod*.

[16:19] <luqui> I don't recall anything

[16:19] <luqui> but that's mostly because I consider pugs to be the same thing

[16:19] <autrijus> okay, just want to derumour rumours :)

[16:19] <luqui> so he could have said it, and I would just keep nodding

[16:21] <autrijus> obra: ok... I'll reply to that blog then. is it okay if I quoted your two lines?

[16:22] <obra> Sure.

[16:22] * autrijus hits "Submit"

[16:22] <autrijus> thanks :)

[16:23] <obra> Larry praised autrijus and pugs for making perl6 fun again and getting up lots of momentum and excitement for perl6.

[16:23] <obra> oops. too late ;)

[16:24] <autrijus> :)

[16:24] <autrijus> "is typed is defined" alone would make me want to use perl6 :)

[16:26] <autrijus> hm. come to think about it, I wonder why perl5 people, even without access to "err" and "//", tolerates null pointer exception this much.

[16:26] <autrijus> not to mention easy-to-remember hard-to-get-right "if (length())", "if (defined())".

[16:27] <luqui> I don't use either of those

[16:27] <luqui> but I'm very liberal in my use of undef

[16:27] <autrijus> luqui: you just test for truth?

[16:27] <luqui> yeah

[16:27] <autrijus> so if you write a web form and I fill in "0"

[16:27] <luqui> I don't write web forms :-)

[16:27] <autrijus> I can count on my input to disappear :)

[16:27] <autrijus> ah. that explains :)

[16:28] <luqui> I think my code works exactly how it's supposed to, but I only recently started using warnings

[16:28] <luqui> so that means I only recently learned about "no warnings 'uninitialized'"

[16:29] <luqui> bbs

[16:29] <autrijus>        Value of %s can be "0"; test with defined()

[16:29] <autrijus>            (W misc) In a conditional expression, you used <HANDLE>, <*>

[16:29] <autrijus>            (glob), "each()", or "readdir()" as a boolean value. 

[16:30] <autrijus> yow. ad-hoc inferencing... I can't add my functions to that list :-/

[16:30] <integral> "null-pointer exceptions" in perl a more benign that C ones though: they can be caught, and they give better error messages

[16:30] <autrijus> integral: right, but it's of the same benignness as Java

[16:30] <autrijus> and Java people doesn't exactly love those.

[16:32] <autrijus> google for "error occurred" nullpointerexception  yields ~10k pages

[16:32] <autrijus> on the other hand

[16:32] <autrijus> "software error"  "on an undefined value"

[16:32] <autrijus> yields more than 35k.

[16:33] <autrijus> I guess either perl5 is more popular for web scripting, or is more affected by this :)

[16:33] <autrijus> (or both)

[16:39] <Limbic_Region> autrijus - it is has been my experience that p5 programmers who make the mistake of only testing for truth when defined false values are valid are just as likely to make other assumptions about input (that end up being wrong)

[16:39] <Limbic_Region> so I would say it is quite prevalent

[16:40] <Limbic_Region> "Know your data" is a lot easier said than done

[16:40] <autrijus> what are other assumptions?

[16:41] <Limbic_Region> people who parse html with regexen expect input to conform to THEIR idea of valid

[16:41] <autrijus> I'd single out defined/length/truth as the one thing that p5 encoruages people to confuse.

[16:42] <Limbic_Region> and every case where division is involved

[16:42] <autrijus> yeah, not testing regexen is indeed bad.

[16:43] <Limbic_Region> I am just saying that the code assumes certain input and don't add error handling for input that doesn't match that expectation (or better yet handle it)

[16:43] <autrijus> *nod*

[16:44] <Limbic_Region> fixing defined/length/truth isn't going to make the people making bad assumptions start writing better handling routines - it is just going to prevent them from shooting themselves in the foot as much

[16:44] <autrijus> right. it's the same idea as // and err

[16:44] <autrijus> if the programmer is clueless, it's doomed anyway

[16:44] <autrijus> but for clueful programmers, it shouldn't be that painful.

[16:45] <Limbic_Region> of course, playing devil's advocate - one might say by making certain cases less likely to result in a blown off face - the coder is more likely to be careless

[16:45] <autrijus> yup.

[16:45] <clkao>  // as default depot

[16:45] <autrijus> // as comment

[16:45] <autrijus> clkao: you can type "/ //" you know :)

[16:45] <Juerd> # to indicate IRC channel names

[16:46] <Juerd> hm... :)

[16:46] <autrijus> mm bad ideas.

[16:46] <Limbic_Region> of course there needs to be a new operator created - one that says if defined but false do this, if defined and true do that, and if ! defined to something else entirely

[16:47] * Limbic_Region ducks

[16:49] <autrijus> given $x { when undef { ... } when true { ... } default { ... } }

[16:49] <autrijus> not exactly hard.

[16:50] <Limbic_Region> right - which makes // and err completely un-necessary

[16:50] <Limbic_Region> I was playing antagonist again

[16:50] <autrijus> no, err is neccessary as an infix :)

[16:50] <Limbic_Region> finding the first defined value in a list ;-)

[16:50] * Limbic_Region likes that example too

[16:50] <autrijus> riiight.

[16:51] <autrijus> ?/? :/:

[16:51] <Limbic_Region> I guess what I was saying is that while // and err make life easier they aren't necessary

[16:51] * autrijus stops bad ideas

[16:51] <Limbic_Region> and if you are going to make life easier - why draw the line there

[16:51] <autrijus> it is neccessary when you don't have a good given/when form

[16:52] * Limbic_Region knows why but was being an antagonist anyway

[16:52] <autrijus> as otherwise you need to invent a new temporary storage :)

[16:52] <autrijus> do { for (f()) { if (defined) { ... } elsif ($_) { ... } else { ... } } }

[16:52] <autrijus> is the p5 form.

[16:52] <autrijus> very readable, that :)

[16:54] <Limbic_Region> there is a price to be paid for having a language rich enough to support clean, clear, concise code

[16:55] <Limbic_Region> and both the consumer (programmer) and supplier (developer) have to pay the piper

[16:55] <autrijus> that is undoubtably true.

[16:55] <autrijus> but the price is always there, either in language or in idiom.

[16:55] <Limbic_Region> admittedly the consumer gets the better end of the deal

[16:55] <autrijus> sub f ($x, $y) {}  # language

[16:56] <autrijus> sub f { my $x = shift; my $y = shift; }  # idiom

[16:56] <autrijus> sub f { my ($x, $y) = @_; }  # another idiom

[16:57] <Limbic_Region> as a consumer, I first have to learn the developers concept of clean, clear, concise use of the language

[16:58] <Limbic_Region> second, I have to learn enough of that language to make it do what I want since rich means big

[16:58] <Limbic_Region> that's not too bad considering what the developer has to pay

[17:02] <luqui> Of course, the whole idea of Perl 6 is to make it easy for people to come from any paradigm

[17:02] <luqui> which means that we developers have to know all paradigms...

[17:02] <luqui> there's a covariance/contravariance thing going on here

[17:04] <autrijus> luqui: you saw my === semiproposal? :)

[17:04] *** Aankh|Clone is now known as Aankhen``

[17:04] <luqui> nopers

[17:05] <luqui> where?

[17:05] <autrijus> multi append ([], @ys) { @ys }

[17:05] <autrijus> multi append ([*$x, *@xs], @ys) { ($xs, append @xs, @ys) }

[17:05] <autrijus> sub last (@l) { my ($`x, @`xs); append(@`xs, [$`x]) === @l; $`x }

[17:05] <autrijus> silly example

[17:05] <autrijus> but illustrates the point.

[17:06] <luqui> it does?  what are the backticks?

[17:06] <autrijus> free logic variables.

[17:07] <luqui> don't those multis need to know that they're working on logic variables

[17:07] <svnbot6> r6164 | fglock++ | * rearranging ext/Perl6-* dirs

[17:07] <autrijus> no, that's structural.

[17:07] <luqui> ?

[17:08] <autrijus> the unpacking, listfix comma etc all contain solvers

[17:08] <luqui> logic variables have the same kind of evil that junctions do... perhaps even greater

[17:08] <autrijus> so multis defined with them can be solved as well.

[17:08] <autrijus> luqui: right... but I've been studying Curry and it makes Haskell logical just by introducing two forms

[17:08] <autrijus> let x free

[17:08] <autrijus> x =:= y

[17:08] <autrijus> that's all :)

[17:08] <autrijus> and

[17:08] <autrijus> if you don't use them, you get vanilla haskell

[17:09] <autrijus> when you start using them, you get a logical languag.

[17:09] <luqui> and you start infinite looping

[17:09] <autrijus> most of the infinite loops are detected in constant time.

[17:09] <luqui> ?

[17:09] <luqui> how

[17:09] <Arathorn> wouldn't you need a WAM to detect that?

[17:10] <autrijus> Arathorn: yes.

[17:10] <autrijus> luqui: by modifying the runtime to be powerful enough.

[17:10] <autrijus> luqui: I'm not saying I want this in perl6 :)

[17:10] <autrijus> but it is nice to think about.

[17:11] <luqui> you would combine predicates by just &&ing them together, and they would try as hard as they could to make it true

[17:11] <luqui> even, backtrack if they couldn't

[17:11] <autrijus> ah, you are talking about exponential time, not infinite

[17:11] <autrijus> right, you can't avoid those.

[17:12] <luqui> no, infinite.  I've been writing a bit of prolog recently, and infinite loops are pretty common

[17:12] <autrijus> fortunately, in a mixed functional/logical language, the free variables are lexical and can be constrained.

[17:12] <svnbot6> r6165 | fglock++ | * updated P6::V::List makefile

[17:12] <svnbot6> r6166 | fglock++ | * P6::C::Array cleanup

[17:12] <autrijus> luqui: and prolog doesn't detect them for you?

[17:12] <luqui> nope

[17:12] <autrijus> how strange. curry does that all the time.

[17:12] <autrijus> give me an example?

[17:12] <luqui> let's see, I'll give you a sketch

[17:12] <luqui> when I was trying to write a type inferencer, I had predicates like:

[17:13] <luqui> sup(X, Y, X) :- does(Y, X).

[17:13] <autrijus> Curry explicitly says "Prolog is inefficient, contains infinite loops, due to its uncontrolled nondeterminism"

[17:13] <luqui> sup(X, Y, Y) :- does(X, Y).

[17:13] <luqui> sup(X, Y, lub(x,y)).

[17:13] <autrijus> and the Curry report claims that it solves that

[17:13] <luqui> huh

[17:14] <autrijus> so maybe you'd like to take a look.

[17:14] <luqui> I was planning to anyway

[17:14] <autrijus> (I'm using http://danae.uni-muenster.de/~lux/curry/)

[17:14] <luqui> can I run it on my amd64 without template haskell

[17:14] <autrijus> sure

[17:14] <autrijus> I think the implementation is h98.

[17:14] <autrijus> or at least no TH.

[17:15] <luqui> oh, you should see my Monad.pm

[17:15] <Limbic_Region> luqui - it isn't polite to be showing off your monads in public

[17:15] <autrijus> does it come with Monad/Transformer.pm?

[17:15] * luqui doesn't grok monad transformers yet

[17:15] <luqui> so no

[17:15] <autrijus> k

[17:16] <luqui> it also doesn't have a lot of convenience functions that it should

[17:16] <SamB> heh

[17:16] <luqui> it's just the basic closure transform on blocks, basically

[17:16] <autrijus> ah.

[17:16] <autrijus> in p5 or in p6?

[17:16] <luqui> p5

[17:16] * luqui awaits p6 grammar munging

[17:16] <autrijus> k.

[17:16] <luqui> though it's not cpanned, because I haven't written any documentation

[17:17] * luqui goes to read about monad transformers

[17:17] <svnbot6> r6167 | fglock++ | * P6::C::Array cleanup (2)

[17:19] * autrijus thinks luqui is in for a lot of fun

[17:19] <autrijus> luqui: Harrorth talks about them quite a bit

[17:20] <luqui> "fun" or fun?

[17:20] <autrijus> fun.

[17:23] <svnbot6> r6168 | fglock++ | * Perl6-Container-Array passes all tests again

[17:24] <Limbic_Region> autrijus - do you keep regular hours for $work ?

[17:24] <autrijus> Limbic_Region: semiregular, yes.

[17:24] <Limbic_Region> so when do you um sleep?

[17:24] <autrijus> every (monday and/or tuesday), thursday.

[17:24] <Limbic_Region> ahhhh

[17:25] <Limbic_Region> nevermind

[17:25] <autrijus> more and than or.

[17:26] <autrijus> the work hours are usually noon to 7pm or so

[17:26] <autrijus> so I can get by by sleeping at 2am or so.

[17:26] <autrijus> which translates to no serious hacking on workdays.

[17:28] <autrijus> help, I'm scared by larry.

[17:28] <autrijus> stevan:     say defined IO; # prints 0

[17:28] <autrijus> That is, we already have an object of type IO that doesn't really

[17:28] <autrijus> have a value yet.

[17:28] <autrijus> I can't seem to understand this. :-/

[17:29] <autrijus> that sentence spells "prototype based OO" to me

[17:29] <autrijus> and I'm not sure I understand that

[17:31] * autrijus tries to understand the concept that ::IO isn't defined.

[17:31] * autrijus also wonders why bool::false suddenly stringify to '0'.

[17:35] * autrijus asks larry.

[17:37] <obra> What should it stringify to?

[17:37] <obra> and what does bool::true stringify to?

[17:38] <autrijus> ?eval ~(1 == 1)

[17:38] <evalbot6> '1' 

[17:38] <autrijus> ?eval ~(1 == 0)

[17:38] <evalbot6> '' 

[17:38] <autrijus> i.e. same as p5

[17:38] <autrijus> (I assumed.)

[17:39] <obra> *nod* For some reason stringifying as 1 and 0 does seem to make a bit more sense in my head

[17:39] <autrijus> me too, but I want larry to confirm that :)

[17:39] <obra> :)

[17:39] <autrijus> I mean it's certainly not as controversial as Y2K.

[17:39] <autrijus> but still a large diverge.

[17:40] <autrijus> hm, new ruling

[17:40] <autrijus> perl6 -e 'print foo()'

[17:40] <autrijus> compile time error!

[17:40] * obra wonders how much the y2k thing will fuck up novices.

[17:40] <autrijus> sanity.

[17:41] <autrijus> I always thought it's a very bad idea to delay that error to runtime.

[17:41] <autrijus> compare perl5:

[17:41] <autrijus> $ perl -cwe 'use strict; print foo()'

[17:41] <autrijus> -e syntax OK

[17:42] <mauke> yeah, but perl5 has Symbol::Approx::Sub

[17:42] <autrijus> ...you can't have it take effect when you don't load it...

[17:42] <mauke> ok

[17:42] <autrijus> also, the presence of AUTO* defeats that check

[17:43] <autrijus> and that's exactly what S::A::Sub does.

[17:43] <autrijus> so it's same in p6.

[17:45] <fglock> I still don't get how to tell if a parameter is an Array or not - I just introduced a bug I can't find out how to fix

[17:45] <fglock> (i'm working in the zip() implementation)

[17:45] <autrijus> .does(Array)?

[17:46] <fglock> I'll try that

[17:46] * geoffb admits to himself that trying to backlog 2 weeks of #perl6 is insane

[17:46] <fglock> how do I expect a list of array? "List of Array @list" ?

[17:47] <autrijus> Array @list

[17:47] <autrijus> is good enough.

[17:47] <geoffb> autrijus, is STATUS relatively up to date?

[17:47] <autrijus> Array *@list

[17:47] <fglock> when do I use *@list ?

[17:47] <autrijus> if you expect slurpy

[17:47] <autrijus> fglock: you use *@ if the fun is variadic

[17:47] <autrijus> you use @ if you expect only one argument

[17:48] <fglock> so *@list can be a list of array, right? my problem is elsewhere then

[17:48] <autrijus> geoffb: wow. you triaged it with my journal of yeterday?

[17:48] <autrijus> fglock: however, *@l has a bad habit

[17:48] <autrijus> you can't pass in

[17:48] <autrijus> foo(@a, @b, @c)

[17:48] <autrijus> need to say

[17:49] <autrijus> foo(@a, \@b, \@c)

[17:49] <autrijus> er

[17:49] <autrijus> foo(\@a, \@b, \@c)

[17:49] <autrijus> think perl5 for why

[17:49] <Aankhen``> That sux0rz.

[17:50] <fglock> "Array @list" didn't work

[17:50] <moan> hm, 2 questions

[17:50] <moan> why doesnt this parse?

[17:50] <moan> my Sub $sub = sub (Str $param) returns Void { $param.say(); };

[17:50] <moan> and why does it parse if i remove the trait, but still does not care about the parameter-list?

[17:50] <autrijus> fglock: typechecks generally doesn't wokr.

[17:51] <geoffb> autrijus, not sure I understood the question . . . in any case, checking I find that no, STATUS is way out of date.  Hmmm.

[17:51] <autrijus> geoffb: my journal of yesterday is a STATUS of sorts.

[17:51] <geoffb> :-)

[17:52] <geoffb> autrijus, OK, I'll see if I can fix up STATUS to match.

[17:52] <fglock> I found the problem - CORE::zip has a higher precedence than $object.zip !!!

[17:52] <geoffb> Then maybe hack.pod if it turns out to be OOD

[17:52] <autrijus> geoffb++

[17:52] <autrijus> fglock: yow!

[17:53] <fglock> it wasn't calling "my" zip

[17:53] <autrijus> fixing!

[17:53] <autrijus> fixed.

[17:53] <autrijus> committing

[17:53] <fglock> BTW, how can I force calling CORE::something instead of the method?

[17:53] <autrijus> &*zip($a, $b);

[17:54] <autrijus> the & is optional.

[17:54] <autrijus> *zip  works too

[17:54] <fglock> cool - I was trying *::zip ...

[17:55] <geoffb> ?eval "testing, testing, checkcheckcheck"

[17:55] <evalbot6> 'testing, testing, checkcheckcheck' 

[17:55] <svnbot6> r6169 | autrijus++ | * CORE::zip should not override $object.zip.

[17:56] <stevan> autrijus: say defined IO;

[17:56] <stevan> that makes sense (sort of)

[17:57] <stevan> if your platform or version does not have ::IO, it wont be defined

[17:57] <autrijus> but isn't IO resolved to ::IO

[17:57] <stevan> yes I think so

[17:57] <autrijus> eh sure but this is

[17:57] <autrijus> defined

[17:57] <geoffb> Has iblech reported a new JS test %?

[17:57] <autrijus> larry is saying ::IO is the undef instance for IO

[17:57] <autrijus> geoffb: no, he's CPS'ing

[17:57] <stevan> ??

[17:57] <autrijus> so the high water mark is 64% or so

[17:57] <stevan> undef instance??

[17:57] <autrijus> stevan: look at the p6l post

[17:57] <autrijus> I think he is utterly confused

[17:57] <autrijus> or I am

[17:57] <autrijus> can't tell

[17:57] * stevan looks

[17:58] <stevan> autrijus: BTW - did you see my $obj.meta.add_method() post?

[17:58] <autrijus> Now I realize that in perl 6 you can re-open classes and add methods to

[17:58] <autrijus> them. However this is not convenient for programmatic class generation.

[17:59] <stevan> yes

[17:59] <autrijus> you mean runtime, don't you

[17:59] <autrijus> introducing new methods at runtime :)

[17:59] <stevan> yes runtime programmatic class generation without eval

[17:59] <stevan> yes

[17:59] <stevan> or even a new class, but thats something for later

[18:00] <autrijus> larry ruled anon methods must exist.

[18:00] <stevan> ok, good

[18:00] <stevan> then I like the anon method approach then

[18:00] <autrijus> so something like 1) obviously works.

[18:00] <autrijus> yeah.

[18:00] <stevan> it is cleaner

[18:00] <autrijus> it is.

[18:00] <autrijus> it involves no reblessing.

[18:00] <stevan> :) 

[18:00] <autrijus> I hate reblessing

[18:00] <geoffb> P5 and PIR backends are still stalled waiting on PIL2 eval, yes?

[18:01] <autrijus> geoffb: PIR is really waiting on leoctx5.

[18:01] <stevan> autrijus: why is undef not like null in Java?

[18:01] <geoffb> oy, leoctx5 is still not merged?  Heavens

[18:01] <autrijus> stevan: I think they are identical.

[18:01] <stevan> ok

[18:01] <autrijus> geoffb: *sigh*

[18:01] <stevan> so I see your POV then

[18:02] * stevan looks at larrys post

[18:02] <autrijus> geoffb: P5 is not stalled on anything really... it's moving as a backend on the metamodel and container type front.

[18:02] <autrijus> I don't think it's stalled.

[18:02] <dudley> is larry saying that a Class is an undef value, whereas an Instance is defined?

[18:02] <stevan> oh,... who is doing the container types?

[18:02] <autrijus> stevan: fglock did Array

[18:02] <autrijus> or rather is doing.

[18:02] <stevan> dudley: nice

[18:02] <autrijus> Scalar is trivial.

[18:02] <stevan> I thought he was doing it in Perl 6 for some reason

[18:02] <autrijus> Hash is not yet touched.

[18:03] <autrijus> he is doing it in both.

[18:03] <autrijus> he is insane.

[18:03] <fglock> :)

[18:03] <autrijus> :)

[18:03] <stevan> this project seems to atract those types :)

[18:03] <autrijus> verily.

[18:03] <fglock> i thought there would be a "mini-perl6" that could use it

[18:03] <fglock> there exist something like a "lazy hash"?

[18:06] <autrijus> heavens no.

[18:06] <stevan> autrijus: see Larry's post on the metamodel thread

[18:06] <autrijus> yes?

[18:06] <geoffb> (sorry for delays, multitasking here): OK, so P5 MM and containers are being written, but the runloop is unchanged?

[18:06] <autrijus> Foo is the name of a potentiality.  It's the name of anything you can

[18:06] <autrijus> construct using the Foo package, the Foo undefined value, and the Foo

[18:06] <autrijus> metaobject (if any).

[18:06] <stevan> Foo is the name of a potentiality.

[18:07] <autrijus> I need an operational semantic for that potentiality.

[18:07] <stevan> autrijus: let me think this over some more

[18:07] <autrijus> ok.

[18:07] <stevan> I see a glimmer of sanity in it 

[18:07] <stevan> I just need to let it sink in

[18:07] <PerlJam> lwall++  (class as a spotlight)

[18:08] <stevan> autrijus: This actually feels like a clarifaction of the ambigious "Foo" 

[18:08] <stevan> but I have to think about it some more

[18:08] <autrijus> stevan: but it's resolved to one or another.

[18:08] <autrijus> "the Foo undefined value"

[18:08] <autrijus> is particularly strange.

[18:08] <PerlJam> autrijus: but it kind of makes sense.

[18:08] <autrijus> I hope he is not talking about

[18:08] <autrijus> my Foo $x .= new;

[18:08] <autrijus> but I think he is.

[18:09] <stevan> If you read it as: Don't care 'bout that.  ::Foo is just the delegator, the

[18:09] <stevan> dispatcher of dispatchers, judging everything and nothing.

[18:09] <geoffb> Does PIL2JS use PIL2 or PIL1 still?

[18:09] <stevan> or sorry "Foo" is just the delegator

[18:09] <PerlJam> autrijus: I don't.  I think he's talking about  my Foo $x;  $x is Foo

[18:09] <autrijus> geoffb: PIL1. PIL2 is not there at all. I've been building support code for it.

[18:09] <PerlJam> Er, that last bit really isn't perl6 syntax though it looks it. :)

[18:09] <geoffb> autrijus, OK, gotcha

[18:09] <stevan> I agree w/ PerlJam 

[18:09] <autrijus> okay. if that is the case

[18:10] <stevan> ::Foo and meta(Foo) are really backstage components

[18:10] <autrijus> $x.whatever is as good as Foo.whatever ?

[18:10] <stevan> and "Foo" is the bridge

[18:10] <PerlJam> I wonder what a typed undef stringifies to?   my Foo $x;  $x.say;  #   Foo(undef)

[18:10] <stevan> and Foo can be undef in certain contexts

[18:10] <autrijus> PerlJam: it stringifies into a warning and an empty string.

[18:11] <stevan> autrijus: this is not unlike Java

[18:11] <autrijus> stevan: but in java, null can't be used as a class method

[18:11] <autrijus> I mean, if you have a variable of type Foo that contains null

[18:11] <PerlJam> autrijus: oh right.  My mind was starting to wander  :)

[18:11] <stevan> yes, and neither should the undef form of "Foo"

[18:11] <autrijus> you can't suddenly pretend it's a first-class class object.

[18:11] <stevan> so my Foo $x;

[18:11] <stevan> $x is a special Foo(undef)

[18:12] <autrijus> I see 

[18:12] <autrijus> my Foo $x

[18:12] <autrijus> as being

[18:12] <stevan> until you STORE something into $x

[18:12] <autrijus> x :: Scalar (Maybe Foo)

[18:12] <autrijus> which can be instantiated by either Foo

[18:12] <autrijus> I mean (Just Foo)

[18:12] <PerlJam> stevan: But would  my Foo $x = undef; be the same as my Foo $x;   ?

[18:12] <autrijus> or Nothing.

[18:12] <autrijus> which is still exactly the same as java.

[18:12] <stevan> PerlJam: good question, no idea

[18:13] <autrijus> PerlJam: the first one burns some more cycle.

[18:13] <autrijus> ;)

[18:13] <stevan> :D

[18:13] <PerlJam> stevan: I'd imagine that it would as the container is responsible for storage.

[18:13] <autrijus> the observable result though is the same.

[18:13] <stevan> PerlJam: yes that does make sense

[18:13] <PerlJam> right

[18:14] <stevan> but when you were not looking, all hell would break loose

[18:14] <autrijus> however, consider

[18:14] <autrijus> my Foo $x is constant = undef;

[18:14] <autrijus> vs

[18:14] <autrijus> my Foo $x is constant; $x = undef;

[18:14] <autrijus> should the second form die?

[18:14] <stevan> those would have to be valid

[18:14] <autrijus> my Int $x is constant; $x = 10;

[18:15] <stevan> only if it was in violation of the "is constant" part

[18:15] <autrijus> I'm talking about that part, yes.

[18:15] <stevan> I dont know

[18:15] <stevan> maybe

[18:15] <autrijus> i.e. does "constant" means "single assignment; assign before use"

[18:15] <autrijus> or

[18:15] <autrijus> "is constant = 123" is actually a special form for "is constant := 123"

[18:16] <autrijus> or is the example in synopsis a typo? :)

[18:16] <stevan> I think both forms should work then 

[18:16] <stevan> Larry says: Apoc are purely for entertainment purposes

[18:16] <autrijus> but not Syn

[18:16] <geoffb> Is the JS MM integration complete, or in progress?  And how close is the JS MM to the P5 MM in terms of completeness?

[18:16] <stevan> I assumed the definition sould be extended to them

[18:17] <stevan> geoffb: JS MM is the most integrated

[18:17] <autrijus> my $x is constant; if (0|1).pick { $x = 'initialized' }; $x = 'foo!'

[18:17] <PerlJam> stevan: no way, Syn are definitivish  :)

[18:17] <stevan> however it is not boostrapped in the same way

[18:17] <autrijus> hm, I'll ask p6l.

[18:17] <stevan> geoffb: the p5 MM is bootstrapped, but not integrated at all

[18:17] <PerlJam> autrijus: my $x is constant; # compile time error as there is no initializer.

[18:17] <geoffb> stevan, can you explain that a little further?  How can the JS MM be integrated without bootstrapped?

[18:18] <stevan> PerlJam: it's the :ish" part that'll getcha

[18:18] <PerlJam> autrijus: maybe not if what was wanted was a constant undef :)

[18:19] <stevan> geoffb: in the bootstrapped MM, the following is true: MetaClass is instance of MetaClass; Object is an instance of MetaClass; MetaClass is a subclass of Object;

[18:19] <stevan> this is not true in the JS model

[18:19] <stevan> only in the p5 model

[18:19] <geoffb> ah, I think I get it.

[18:19] <geoffb> As long as you don't look to deep, the MM works in JS.  But in P5, it's deeply correct, but not working

[18:20] <stevan> geoffb: see the 10,000 ft view in the perl5/Perl6-MetaModel/docs dir, it has some more details and pretty pics of this bootstrap stuff

[18:20] <stevan> geoffb: kind of yes

[18:20] <geoffb> Stevan, yeah, looked at that.  Trying to make up for OSCON and related loss of #perl6 by doing something useful and updating STATUS.  :-)

[18:20] <stevan> geoffb: bootstrapped means less work for the integrator (in theory that is, no in practice yet)

[18:21] <stevan> geoffb++ # some one has to do the dirty work :)

[18:21] <Juerd> gmc_: Possibly, the "connection" you saw did not involve the network at all.

[18:21] <Juerd> eh

[18:21] <Juerd> What the.

[18:21] <svnbot6> r6170 | fglock++ | * New method Perl6::Value::List.from_coro( $sub )

[18:21] <svnbot6> r6170 | fglock++ | * tests pass (again)

[18:21] <Juerd> What am I doing in this window, so suddenly?

[18:21] <Juerd> ww

[18:21] <stevan> and speaking of dirty work, I have to get back to my $work 

[18:21] <geoffb> stevan++ # I have it easy, stevan's actually writing the code  :-)

[18:22] <stevan> :) &

[18:22] * autrijus does more p6l brain-triaging

[18:23] <stevan> BTW - if anyone who wants to un-warknock my $obj.meta.add_method() thread it would be much appreciated :)

[18:25] <fglock> a question about lazy list operators - if I do "@a=@x.grep{..}", and @x changes, then the non-instantiated part of @a will change, right?

[18:26] <fglock> (otherwise I have a big problem to solve)

[18:26] <autrijus> stevan: did so.

[18:27] <geoffb> Parrot embedding still working as of 0.2.3?  (I can never know, because this POS system can't link a parrot-embed pugs)

[18:27] <autrijus> fglock: if @x is strict, then @a is strict

[18:27] <autrijus> fglock: so if you change @x, nothing happens

[18:27] <geoffb> Or are people stuck using 0.2.2?

[18:28] <autrijus> geoffb: I think both work, but I'm not entirely sure.

[18:28] * geoffb reflects unsureness directly to STATUS file.  :-)

[18:29] <autrijus> fglock: the lazy parts of @x would certainly reflect to @a.

[18:29] <autrijus> fglock: so if you have

[18:29] <autrijus> @a = grep { /^foo/ } =open('/etc/passwd');

[18:29] <autrijus> and read the first line of @a

[18:29] <autrijus> and change /etc/passwd

[18:29] <fglock> autrijus: so I need a to_strict() method. What if I push a lazy list into a strict Array? does the Array turns Lazy, or the list turns strict?

[18:29] <autrijus> then strange things may happen, yes.

[18:30] <geoffb> Am I correct in assuming that since you two are actively speaking of laziness, it doesn't work yet, but is in rapid progress?

[18:30] <autrijus> fglock: an Array is composed of any number of either eager or lazy components.

[18:30] <autrijus> fglock: pushing a lazy list into it simply adds a lazy component to its end.

[18:30] <fglock> ok, so there is no such thing as a strict or lazy Array - that's good

[18:30] <geoffb> I never thought I would ever be a self-appointed doc monkey on any project . . . .

[18:31] <autrijus> geoffb: yes and yes.

[18:31] <autrijus> fglock: sadly, there is a strict array that forces everything stored into it to be subject to **

[18:31] <autrijus> ** is the steam roller that demands the values

[18:31] <autrijus> (not recursively)

[18:32] <autrijus> you can implement it as .flatten

[18:32] <putter> geoffb: 0.2.3 embedds fine (at least on FC3 amd64)

[18:32] <fglock> by not-recursively do you mean other dimensions? (flatten sounds like flatten dimensions)

[18:33] <geoffb> putter, thanks!

[18:33] <geoffb> (and thanks to autrijus and stevan for answering my questions)

[18:33] <putter> nothingmuch: your smoke is dead :(  *tear*   and if it supported parrot/rules, we could just point pm at it to find out what is/isnt working...

[18:34] <putter> np. :)

[18:34] <putter> geoffb++ # STATUS

[18:35] <autrijus> larry revealed his true intention!

[18:35] <autrijus> : My current understanding is that the typechecker considers IO to be of

[18:35] <autrijus> : Class type, not of IO type; the fact that IO.does(IO) is true is purely

[18:35] <autrijus> : an illusion created by special dispatch for .does.

[18:35] <autrijus> Well, that's what I thought last week.  :-)

[18:36] <autrijus> and then..

[18:36] <autrijus> But these days I'm wondering if the whole point of a class is to proxy

[18:36] <autrijus> for its missing members, and everything else is deferred to the metaclass.

[18:36] <autrijus> hrmph.

[18:37] * autrijus ponders whether to ask for code examples, or to wait until dust settles

[18:38] * autrijus also ponders whether larry is restating the prototype-based OO idea.

[18:38] * putter thinks we need feather running a smoke... it looks like jonathan's is the only working public smoke... other times it seems to just be nothingmuch...

[18:40] <fglock> what is the result of the "comma" operation in 1..10,20..30 ? (I hope it is an Array made of 2 lists)

[18:40] <autrijus> fglock: your hope is granted.

[18:41] <fglock> :) I thought comma was a list builder

[18:41] <autrijus> it is an array made of two lists, but with 21 elements.

[18:41] <fglock> sure

[18:41] <autrijus> :)

[18:42] <putter> autrijus: re "I hate reblessing" ... when individual objects can add and remove methods and fields (and if they can't, ruby remains a more powerful language) you pay most of the compile pain right there.  individual objects being able to does and undoes rules follows.  at which point reblessing is rather painless.  no?  ;)

[18:42] <putter> s/rules/roles/

[18:42] <svnbot6> r6171 | geoffb++ | Update STATUS to 2005-08-10

[18:43] <autrijus> putter: when you start removing methods from classes, you enter the typeless realm.

[18:43] <autrijus> putter: where no error can be detected statically

[18:43] <autrijus> so yes, sure, you can do that, but I hate that :)

[18:43] <autrijus> I think we can start bill perl6 as "Ruby with Types"

[18:43] <autrijus> or something like that :)

[18:43] <putter> renormalist: subpatterns work.  the syntax is  <subrule>  rather than <$subrule>

[18:44] <autrijus> or "Ruby with Types and Unicode"

[18:44] <avar> mm unicode

[18:44] <putter> autrijus: use typelessrealm; :)

[18:44] <geoffb> A language designed by a Japanese person doesn't do Unicode?

[18:44] <autrijus> geoffb: shocking isn't it

[18:44] <autrijus> cf. Why's "Time.now" movie.

[18:44] <geoffb> uh, YEAH

[18:45] <autrijus> you know, J was the most antiunicode people.

[18:45] <autrijus> of CJK

[18:45] <autrijus> who were the most antiunicode region.

[18:45] <geoffb> Why?!?

[18:45] <avar> you can add unicode support to ruby by modifying the core classes at runtime though

[18:45] <geoffb> And why is it sometimes CJK and sometimes CJKV?

[18:46] <autrijus> geoffb: because vietnamese shares some traits and not some others

[18:46] <geoffb> geoffb-- # ignorant American

[18:46] <geoffb> Fair enough

[18:46] <autrijus> avar: right, and guess how fast it is :)

[18:46] <autrijus> geoffb: anyway, jp people hated unicode

[18:46] <putter> re typelessrealm, given that the world is moving towards long running self-updatable systems, I think the bug lies in the compile/runtime distinction.  That has to be blurred.

[18:46] <geoffb> They wanted codepage hell?

[18:46] <autrijus> because Unicode didn't contain enough characters for their use

[18:47] <autrijus> and blatantly ignored characters written differently

[18:47] <geoffb> Are recent versions still missing what they want?

[18:47] <autrijus> and cap things at 16bit.

[18:47] <autrijus> but all of these gone away after Unicode 3.0

[18:47] <geoffb> ah, good

[18:47] <autrijus> but old impressions die hard.

[18:47] <avar> autrijus, geoffb: http://pastebin.com/333941

[18:47] <SamB> so how long until japanese source files are in utf8

[18:47] <geoffb> nodnod

[18:47] <avar> prints 2 then 1

[18:47] <autrijus> but 3.0 is 1999

[18:47] <SamB> and how long until emacs properly supports that?

[18:48] <geoffb> SamB, I don't think you can say that emacs properly supports anything, and I say that as an emacs user

[18:48] <autrijus> and Ruby is 1993

[18:48] <SamB> well, I mean instead of just having placeholders for everything

[18:48] <autrijus> 1993 is unicode 1.1... unicode at its worst

[18:48] <geoffb> AH!  It all makes sense now

[18:49] <putter> ride's here.  &

[18:49] <putter> cheers :)

[18:49] <autrijus> avar: yup, but you can't mix things.

[18:49] <SamB> I still think unicode is an ugly tangled mess

[18:49] <SamB> but it is PROBABLY an improvement over encoding hell

[18:49] <autrijus> avar: wacky though perl5's unicode model is, you can at least mix stuffs with different encodings.

[18:49] <autrijus> (and charsets.)

[18:49] <geoffb> You know, I really wish US schools actually made even a vague attempt to teach children about anything other than local politics

[18:50] <avar> they teach politics?

[18:50] * avar suprised

[18:50] <autrijus> ...and intelligent design

[18:50] * geoffb thankfully avoided ID hell . . .

[18:50] <SamB> you know, I don't have a clue about local politics. probably because I'm homeschooled.

[18:50] <dudley> US schools have a hard enough time convincing kids they need to know anything about their own government

[18:51] <dudley> much less someone else's

[18:51] <geoffb> avar, yep: "Commies Bad.  Slavery bad, but only if you call it that." 

[18:51] <autrijus> it's really funny reading en.wikipedia and watch people thinking that ID is somehow a worldwide movement.

[18:51] <SamB> what is ID?

[18:51] <SamB> oh, right, intelligent design.

[18:52] <geoffb> SamB, an attempt to put a christian ethos on things without actually referring to particular christian entities

[18:52] <geoffb> But there I go again.

[18:54] <SamB> hmm, I can't remember the phrase for "God-directed evolution"...

[18:54] <autrijus> is that like type-directed evaluation?

[18:54] <geoffb> SamB, I suppose that depends on how directed you mean.

[18:54] <SamB> how about "extreme creation"?

[18:55] <geoffb> SamB, heh

[18:55] <geoffb> Would creationism directed by matched male and female gods be "pair programming"?

[18:55] <dudley> how about "metacreation"?

[18:55] <autrijus> "Evolutionary creationism"?

[18:55] <autrijus> "Theistic evolution"?

[18:56] <dudley> autrijus: You can't say evolution. It's just a _theory_ , not a _fact_

[18:56] <stevan> IMO "intelligent design" is as much a valid argument for UFOs as it is "God"

[18:56] <SamB> yeah, "theistic evolution" is what I thought to, but I looked "theistic" up in dict, and I wasn't sure if that was right or not...

[18:56] <dudley> or so goes the argument around here.

[18:56] <PerlJam> dudley: just like the electron

[18:57] <autrijus> dudley: just like peano numbers!

[18:57] <geoffb> Personally, I still like the idea of someone being proud of designing fjords.  'Cause damn, they're just cool.

[18:57] <SamB> wait, I thought peano numbers were real!

[18:57] * PerlJam signs up for the faith-based science classes now

[18:57] <autrijus> SamB: numbers are facts? surely you jest

[18:58] <SamB> stacks of cans act just like peano numbers

[18:58] <geoffb> To pythagoreans, I suppose they were

[18:58] <SamB> unless you knock them over

[18:58] <autrijus> SamB: that's what "theory", or "model", means, really :)

[18:58] <autrijus> we model cans with peano numbers, falling stuff with gravity, etc.

[18:58] <SamB> hehe. anyway, why can't we say the names of theories again?

[18:59] <autrijus> maybe because they are now undefined instances of themselves?

[18:59] <autrijus> ;)

[18:59] <dudley> Oh, you can say it, but it's not true because it's not a fact

[18:59] <svnbot6> r6172 | fglock++ | * New methods Perl6::Value::List.flatten(), is_lazy()

[18:59] <PerlJam> autrijus: in Larry's world all we can say about them then is their name!

[18:59] <autrijus>    say +defined Evolution; # prints 0

[19:00] <dudley> it's only a theory, which means "something some scientist guy made up to get money from the government"

[19:01] * dudley lives in a place where people actually believe things like that

[19:01] <geoffb> wow, sorry to hear that dudley

[19:02] <PerlJam> dudley: you live in Kansas?

[19:02] <autrijus> well it looks like a rebindable, dynamic, weakly typed belief system.

[19:02] <dudley> PerlJam: damn close. Arkansas.

[19:02] <geoffb> Of course, I live in a place were people are equally likely to believe the Pope is all-knowing, and that crystal energies are the key to global harmony . . . .

[19:03] <PerlJam> geoffb: except for the all-knowing pope that sounds like somewhere in California

[19:03] <PerlJam> oh wait!  Are you in Canada?

[19:04] <geoffb> PerlJam, Sonoma county in Northern CA.  Catholics, Mormons, Hippies, you name it.

[19:04] <geoffb> CA == California, not Canada

[19:04] <geoffb> And LOTS of each

[19:05] <PerlJam> geoffb: don't let them breed and it shouldn't be a problem.

[19:05] * geoffb has always thought it must be odd living somewhere that almost everyone believes the same thing

[19:05] <geoffb> PerlJam, I wish!

[19:05] <PerlJam> geoffb: or introduce a predator to the ecosystem.

[19:05] <autrijus> geoffb: it's easy... all hermits know that

[19:05] <geoffb> LOL

[19:05] <dudley> geoffb: Especially if you believe nearly the polar opposite

[19:05] <autrijus> for small values of everyone, of course

[19:06] <geoffb> dudley, oh yeah, I'll bet!

[19:06] <dudley> but autrijus is right, it's a lot easier if you're a hermit

[19:06] <PerlJam> I'm in south texas were conservative republicans are rampant.  There are small pockets of free thinkers but they are few and far between.

[19:07] <geoffb> PerlJam, what else besides Austin in Texas has free thinkers?

[19:07] <geoffb> (honest question)

[19:09] <PerlJam> geoffb: you need to think in terms of communities around the size of 20 or 30 people rather than cities.  Free thinkers are embedded everywhere in all Texas cities, it's just that there are so few of them.

[19:11] <svnbot6> r6173 | autrijus++ | * add an abstract, hopefully more efficient and one day

[19:11] <svnbot6> r6173 | autrijus++ |   also more powerful, Str type.

[19:28] <autrijus> bah. w3m ate my journal.

[19:28] <obra> :(

[19:29] * autrijus doesn't feel upbeat enough to write it again :-/

[19:29] <obra> did it leave a vim tmpfile?

[19:29] <autrijus> er, nothing like that

[19:29] <autrijus> I clicked "Preview" and then quitted w3m.

[19:29] <autrijus> probably not w3m's fault.

[19:29] <autrijus> I blame it nevertheless.

[19:29] <obra> huh. my w3m always leave tmpfiles around, both for render and for texteditor files

[19:29] <autrijus> no vim tmpfiles

[19:29] <obra> ls -lart ~/.w3m?

[19:30] <autrijus> obra: nono... I saved it, hit preview

[19:30] <autrijus> thought I hit save

[19:30] <autrijus> then quite

[19:30] <autrijus> *quit

[19:30] <autrijus> checked, no luck

[19:30] <obra> eit :/

[19:30] <obra> I'm sorry

[19:30] <autrijus> np... I think I'm too zonked anyway

[19:30] * autrijus proceeds to sleep :) *wave*

[19:31] <Qiang> night 

[19:31] <autrijus> night Qiang :)

[19:31] <autrijus> &

[19:32] <geoffb> (GI infections)-- # 2-year-olds are better at sharing sickness than anything else

[20:00] <svnbot6> r6174 | fglock++ | * New methods Array.flatten(), is_lazy()

[20:00] <svnbot6> r6175 | geoffb++ | Update source map to 2005-08-10; reorder a couple lines that don't match tree output

[20:06] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { order($commits).as('%.2f') }" }  commit_order('foo', '29')

[20:06] <evalbot6> Error: No compatible subroutine found: "&as" 

[20:08] <geoffb> What number formatting function works in pugs right now?

[20:09] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  commit_order('foo', '29')

[20:09] <evalbot6> 'foo has commit order 4.85' 

[20:18] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  sub cheer ($user, $commits) {my $autrijus = order(2206); my $order = order($commits); my $left = int($autrijus / $order * 100) / 100; commit_order($user, $commits) ~ ($order > $autrijus ?? " and is in the lead!" :: "; only $left to go!") } cheer('foo', 64')

[20:18] <evalbot6> Error:  unexpected "c" expecting ";", statements or end of input 

[20:19] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  sub cheer ($user, $commits) {my $autrijus = order(2206); my $order = order($commits); my $left = int($autrijus / $order * 100) / 100; commit_order($user, $commits) ~ ($order > $autrijus ?? " and is in the lead!" :: "; only $left to go!"); } cheer('foo', 64

[20:19] <geoffb> ')

[20:19] <evalbot6> Error:  unexpected "c" expecting ";", statements or end of input 

[20:19] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  sub cheer ($user, $commits) {my $autrijus = order(2206); my $order = order($commits); my $left = int($autrijus / $order * 100) / 100; commit_order($user, $commits) ~ ($order > $autrijus ?? " and is in the lead!" :: "; only $left to go!") } cheer('foo', 64)

[20:19] <evalbot6> 'foo has commit order 6; only 1.85 to go!' 

[20:20] <chip> At some point it'd be fun to hook up a C++ compiler to IRC, just to see what people would feed it

[20:21] <geoffb> chip: heh

[20:22] <mauke> horrible template metaprograms, of course

[20:22] <geoffb> hmmm, my eval above is giving the wrong answer . . . sigh

[20:23] <geoffb> oh, DUGH

[20:23] <chip> I picked up the ORA STL pocket guide.  STL _is_ just as horrifying as I remembered

[20:23] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  sub cheer ($user, $commits) {my $autrijus = order(2206); my $order = order($commits); my $left = int(($autrijus-$order) * 100) / 100; commit_order($user, $commits) ~ ($order > $autrijus ?? " and is in the lead!" :: "; only $left to go!") } cheer('foo', 64)

[20:23] <evalbot6> 'foo has commit order 6; only 5.1 to go!' 

[20:23] <chip> "bind2nd<int>(..."  no, I can't go on

[20:23] <geoffb> ?eval sub log2($num) { log($num) / log(2) } sub order($num) { log2($num) } sub commit_order ($user, $commits) { "$user has commit order { int(order($commits) * 100) / 100 }" }  sub cheer ($user, $commits) {my $autrijus = order(2206); my $order = order($commits); my $left = int(($autrijus-$order) * 100) / 100; commit_order($user, $commits) ~ ($order > $autrijus ?? " and is in the lead!" :: "; only $left to go!") } cheer('foo', 35)

[20:23] <evalbot6> 'foo has commit order 5.12; only 5.97 to go!' 

[20:25] <geoffb> Silly things to do while waiting for pugs to compile . . . .

[20:26] <geoffb> Hmmm, maybe I should direct that energy towards shopping for a new system

[20:28] <mauke> chip: http://boost.org/libs/libraries.htm#Function-objects

[20:29] <chip> yeah, boost is in the book too

[20:29] <svnbot6> r6176 | fglock++ | * Added perl5/Perl6-Container-Array skeleton

[20:29] <chip> it's just that you can't actually introduce anything that isn't a built-in operation without defining a new class, with a name, that does it.  (Unless C++ invented anonymous classes with operator ()() while I wasn't looking)

[20:30] <chip> Would it kill the C0X committee to introduce anonymous functions?!

[20:30] <chip> for_each(iter.first(), iter.last(), void anon (char *p) { cout << $p })

[20:31] <chip> s/\$/*/ 

[20:31] <mauke> for_each(iter.first(), iter.last(), cout << _1);

[20:31] <SamB> I heard something about some kind of template-language turing-completeness magic for something like lambdas...

[20:32] <mauke> http://boost.org/doc/html/lambda/using_library.html

[20:32] <chip> oh, sure.  I'd rahter stick a fork in my eye than turn my brain inside-out just so I can write C++ expressions in template-ese

[20:33] <chip> and of course my example is simple because this is IRC

[20:34] <chip> boost++ for at least making the effort, though

[20:34] * Aankhen`` goes to sleep.

[20:34] <svnbot6> r6177 | fglock++ | * updated ext/Perl6-* TODO

[20:34] <Aankhen``> Nite.

[21:04] <svnbot6> r6178 | fglock++ | * TODO update

[21:04] <svnbot6> r6179 | fglock++ | * TODO update

[22:21] <fglock> obra?

[22:22] <obra> hi

[22:22] <fglock> I found out the bug in DateTime::Set - it is a problem in DateTime.pm

[22:22] <fglock> I sent it do the DateTime list

[22:23] <obra> cool.

[22:23] <obra> Thanks

[22:24] <fglock> The time zone thing looks so easy - until you start working with it :)

[22:24] <fglock> I just got another bug report

[22:24] <obra> Yeah. I know :/

[22:27] <fglock> hey, just found out who you are :)

[22:28] <obra> *laugh* 

[22:28] <obra> Hi, I'm Jesse. I wrote RT.

[22:28] <fglock> yes!

[22:31] <fglock> I still use the ICal parser you wrote for Date::Set - it is in DateTime::Format::ICal

[22:32] <obra> Nice.

[22:32] <obra> You saw that I recently replaced Net::ICal with Data::ICal?

[22:34] <obra> Wow. I don't remmeber the DateTime::Format::ICal code at all. must have mentally blocked it out

[22:36] <fglock> You wrote it a day when "I" was blocked :)  - Data::ICal is nice - are you planning to go on with the calendar protocols?

[22:36] <fglock> (most of the code in DT::F::ICal is Dave's - your snippet is marked)

[22:37] <obra> This is a logged channel. I'm going to reply in personal messages

[22:55] <iblech> [PIL2JS] Yay, PIL2JS fully works again, now! :) Resmoking... (but expecting many test fails)

[22:57] <brentdax> I'm trying to switch to svk.  Where is the dump file thing for Pugs, so I don't have to pull 6100 revisions down?

[22:58] <fglock> iblech - do you have lazy lists implemented?

[22:59] <iblech> fglock: No. But, as soon I have coro etc. implemented, I could simply compile your code to JS, right?

[22:59] <mugwump> brentdax: can these be made from an existing svk repo?

[22:59] <fglock> it doesn't need coro actually - you can use normal subs (or I could rewrite that part)

[22:59] <brentdax> I'm not really sure--I've just seen it mentioned that if you're going to start using svk, there's a file you can use to avoid downloading all the revisions.

[23:00] <mugwump> that sure would have helped me check out parrot.  as it was I left it overnight

[23:00] <svnbot6> r6180 | iblech++ | * Usual svn props.

[23:00] <svnbot6> r6180 | iblech++ | * PIL2JS fully restored:

[23:00] <svnbot6> r6180 | iblech++ |   * Fixed exportation, default values for params, and &exit.

[23:00] <svnbot6> r6180 | iblech++ |   * my $x; sub foo { $x = { return 3 } }; foo();

[23:00] <svnbot6> r6180 | iblech++ |     PIL2JS.cps2normal(function () { $x() }) does not die now, but returns

[23:00] <svnbot6> r6180 | iblech++ |     undefined.

[23:00] <svnbot6> r6180 | iblech++ |   * Fixed &prefix:<+> on Strs (turned out I only forgot a "new").

[23:01] <fglock> iblech: I thought the perl6 version would not be useful - that's nice

[23:01] <iblech> fglock: It is extemely useful. Later, we could optimize it by porting it to native JS, but I think it'd be ok for now.

[23:02] <fglock> :)

[23:02] <iblech> PIL2JS is damn slow anyway ATM, a little bit additional slowness won't be noticed ;)

[23:03] <fglock> it would be nice to have a "baby-perl6" to perl5 converter - I could use that for syncing the libs

[23:17] <mugwump> brentdax: ok, I have a dump for you :)

[23:17] <brentdax> Great--I'm only up to r453 so far.

[23:18] <brentdax> How do you want to send it?

[23:19] <mugwump> I'll give you a url in a sec

[23:19] <mugwump> it's still trawling through my massive svk depot

[23:19] <brentdax> Alright.

[23:20] <mugwump> guess I might start making new depots for each mirrored path ... should be easy using svndump | svndumpfilter include --preserve-revprops

[23:22] <mugwump> 3,500 revs to go!  :)

[23:26] <mugwump> brb &

[23:34] <brentdax> Okay, why is Pugs giving a Perl 6 regex to PCRE?

