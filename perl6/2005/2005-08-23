[03:23] <jasho> pugs fedora binaries where?

[03:27] <xinming> jasho: hmm, I think you have to checkout the source and compile yourself

[03:28] <jasho> xinming:  it seems like perl6 is only for Windows.

[03:28] <xinming> jasho: BTW, the machine with less than 256M, for compiling GHC and Pugs is not recommended. :-)

[03:28] <xinming> jasho: No, I am in Linux.

[03:29] <jasho> xinming:  I mean in terms of community.  it seems to be all Windows now.

[03:29] <jasho> there are binaries for Windows, but you are on your own for Linux, etc.

[03:29] <xinming> jasho: hmm, I hadn't used Fedora for over months, So I might not be able to help much,

[03:30] <xinming> jasho: hmm, I think most linux distro can compile ghc and pugs.

[03:30] <xinming> jasho: hold on.

[03:31] <jasho> I can't find anything for Linux which is ready to go.  the pugs docs say that by 6.2.0 there will be builds for various common platforms.  but so far it seems only Windows.

[03:33] <xinming> jasho: In fact, that's true, I don't know if Fedora has compiled binary, But Mandrake does. :-)

[03:34] <jasho> I looked for Fedora and Suse.  couldn't find anything.  I didn't check Mandrake.  I don't have it.

[03:36] <xinming> jasho: hmm, I think, You don't need to change so much, The easiest way to compile pugs, might be, do a full install for with Fedora, And then, download ghc6.4 and pugs source, compile yourself.

[03:36] <xinming> s/for with/with/

[03:37] <jasho> I think perl6 will become a Windows community if there are no builds readily available for Linux.  8(

[03:37] <jasho> xinming:  thanks for your help.

[03:37] * xinming is still sleepy, But can't fall asleep, so go on reading the Synopsis.

[03:37] <xinming> jasho: well, I am a newbie also, that might be what I can help :-)

[03:38] <revdiablo> jasho: I think the prevalence of windows builds are simply an indication of the fact that people using that platform don't tend to build stuff themselves

[03:38] <revdiablo> jasho: compared to the average unix user, who tends to be comfortable doing their own compiling

[03:39] <jasho> revdiablo:  but Linux is also trying to become an OS for people who just want to get stuff done.  for now, that seems to mean Windows for perl6, or maybe stick with perl5.

[03:40] <coral> whoah

[03:40] <coral> linux in two windows

[03:40] <revdiablo> jasho: pugs is hardly to the Get Stuff Done phase

[03:40] <revdiablo> jasho: it's still a developer's toy.

[03:40] <revdiablo> a mighty nice and fun toy, but a toy nonetheless

[03:41] <jasho> revdiablo:  I want to test grammars.  I understand this was working already with pugs?

[03:41] <xinming> jasho: Most basic grammar is supported. :-) There are lots things to do.

[03:41] <revdiablo> the basic framework is there; I don't know how complete it is

[03:42] <jasho> does this mean there is nothing even to test?  maybe I should forget perl6 for my project and stay with perl5.

[03:43] <xinming> revdiablo: IMHO, If the full OO support for pugs is finished, some( or maybe many ) modules can be started writting in "perl 6",

[03:43] <spinclad> plenty to test.  just compile and play.

[03:43] <revdiablo> jasho: you can test it by building it

[03:43] <revdiablo> jasho: it builds easily on linux

[03:43] <revdiablo> xinming: *nod* a lot of stuff can be written in perl6 with pugs.

[03:44] <jasho> now I think pugs is not worth it to test yet.

[03:44] <revdiablo> don't get me wrong -- playing with pugs helps everyone, I encourage it

[03:44] <xinming> revdiablo: But the problem is, There are "many" test exists... :-)

[03:45] <jasho> I would play with pugs if there were binaries available for Linux.

[03:45] <xinming> jasho: well, In fact, for Now, You try Pugs, You might get more than learning "only" the grammar. :-)

[03:45] <revdiablo> jasho: "to test" and "get things done" are two different things. which one do you really want to do?

[03:46] <jasho> revdiablo:  I want to install binary pugs and test, to decide if perl6 is ready for my project.  but I hear now pugs is not ready and not available for Linux without compile.

[03:46] <jasho> I think I should stay with perl5.

[03:46] <jasho> thanks for the help.

[03:47] <revdiablo> jasho: I would say that is correct. I would still like you to try pugs and help us make it better

[03:47] <jasho> make it easy for me to try.  on Linux.

[03:48] <revdiablo> I don't use any of the distros you listed.

[03:48] <revdiablo> so I can't really make a binary build for you

[03:48] <xinming> If the money falls from sky, I would go out. But the fact is, If there is no money fall from sky, We still have to go out, the only thing important is, "when"

[03:48] <xinming> :-)

[03:49] <xinming> Now is the time to try pugs, It won't make you disappoint. :-)

[03:50] <jasho> xinming:  I wanted to try.  maybe when pugs is available for my OS.

[03:50] <revdiablo> it is, jasho 

[03:50] <xinming> jasho: In fact, Even if the pugs finished working on all "perl 6" specification. There might not be enough module for you to use...

[03:50] <jasho> revdiablo:  you said it is only a toy.

[03:50] <revdiablo> jasho: it is available for your distro, just not in the form you want.

[03:50] <spinclad> at this point, any binary package will be out of date quickly.  parrot has debian packaging, pugs not yet (or vice versa, i forget offhand), but you would want recent packages in any case.

[03:50] <jasho> xinming:  do I need modules to use grammars?

[03:50] <xinming> jasho: well, Linux is a toy also, Why do you use it? :-)

[03:50] <jasho> in need modules for perl5.

[03:51] <xinming> jasho: No, But for your project, I think There are ( "should" be ) many modules depends on other modules.

[03:51] <revdiablo> I think I'm talking in circles now

[03:51] <jasho> xinming:  Linux with perl5 works well for me now, but I wanted to test grammars with perl6.  but it seems perl6 is for Windows community now.

[03:51] <xinming> ...

[03:52] <xinming> ?eval "painful to go out this circle.".say

[03:52] <evalbotzy> painful to go out this circle. bool::true 

[03:52] <xinming> jasho: There are still perl 5 modules can't co-work with pugs.

[03:52] <spinclad> btw, grammars are not well integrated as yet.  there's PGE and there's pugs, but they don't talk in both directions with each other.

[03:52] <xinming> jasho: some are working, But some are not.

[03:53] <jasho> xinming:  yes, I should stay with perl5 for my project.

[03:53] <revdiablo> I think jasho had a set of points he wanted to make when he came in here, and is ignoring any evidence to the contrary.

[03:53] <jasho> spinclad:  do I need modules for grammars for PGE?

[03:53] <revdiablo> I'm done with this

[03:53] <spinclad> not sure

[03:54] <jasho> revdiablo:  I think you helped me to decide to stay with perl5.  so I don't have to test pugs now.  that helps me.

[03:55] <jasho> I like to try myself.  but no binaries, and not sure it is worth my time.  you tell me that it is not ready yet, and is still for developers only.  so no binaries.  I will use perl5.

[03:55] <spinclad> i think they're good points, we could welcome patches to build drop in packages, for debian at least, with each release...

[03:55] <xinming> jasho: hmm, If you need the pugs to finish the full "perl 6" specification, you might still have to wait for 4 months, And also, for the other modules, maybe half a year, hmm, But can't assure this exactly.

[03:56] <spinclad> (i think that's optimistic...)

[03:56] <xinming> spinclad: pugs can use perl 5 modules. :-)

[03:57] <xinming> though It's a kind of pain on "speed".

[03:57] <spinclad> sure.  the full specs need a lot of work still though.

[03:58] <xinming> spinclad: I just mean the "grammar" specification.

[03:58] <jasho> maybe after this project we can try for pugs again.

[03:58] <spinclad> ok, you may be closer there then.

[03:58] <xinming> jasho: ?? what do you mean? After pugs, the perl 6 is out.

[03:59] <jasho> I mean my project, not the pugs project.  my project can't wait for pugs to finish I think.

[04:00] <spinclad> xinming: not quite:  plans are to release perl6 written in perl6, which calls for a rewrite after pugs...

[04:01] <xinming> spinclad: hmm, well, the "perl 6"s father. :-) maybe pugs can be grand-pa... :-P

[04:01] <jql> as soon as pugs can be used to write perl6, pugs is perl6 enough for me

[04:01] <xinming> jql: So am I, I don't care speed much as I just use it as a toy. :-)

[04:02] <jql> it'll be good -- our programs can only get faster

[04:04] <jasho> my project doesn't care about speed, but I want to use perl6 syntax for advanced constructions.  but I need correct results, so maybe pugs needs some debugging first before I choose perl6 for projects.

[04:06] <xinming> jasho: you are right. :-)

[04:06] <xinming> pugs still can't be used for production.

[04:06] <spinclad> that sounds like a different gate than whether there are binary packages for it.  it definitely needs development on many fronts still.

[04:07] <jasho> spinclad:  I only wanted binaries for quick test.  but you give me the answers already.  pugs is not ready for me to test.  I will use perl5.

[04:08] <spinclad> sure.  check again later, things will have gotten further.

[04:08] <jasho> ok.  thanks for the help.

[04:10] <luqui> jasho, what is your project

[04:11] <luqui> it's always nice to have people using stuff in production

[04:11] <luqui> we get lots of bug reports that way

[04:11] <luqui> (and from what I've seen, no bug goes untended for more than 24 hours :-)

[04:13] <xinming> luqui: I don't suggest to use pugs on project for now really. :-)

[05:07] <svnbot6> r6414 | putter++ | PIL-Run - MetaModel is now used for Sub. fglock++

[05:07] <svnbot6> r6414 | putter++ | Macro is now the only remaining non-mm Run/Type/.

[05:07] <svnbot6> r6414 | putter++ | PrimX.pm: primitives' argument lists are now written in perl6 form.

[05:07] <svnbot6> r6414 | putter++ | crude_repl.pl: :v verbose is now even more so, including a nicely readable yaml dump of the PIL.  iblech++

[05:07] <putter> jasho:

[05:08] <putter> jasho: there are binary builds of ghc available for FC from haskell.org.  (as long as you dont have x86_64 - that requires 6.4.1, which hadn't been released the last time I checked).

[05:10] <putter> good night all &

[05:43] * luqui understands type inferrence... a little bit

[05:44] * luqui will write a perl module that does type checking on trees to see if he really groks it

[05:46] <QtPlatypus> Type checking?

[05:47] <QtPlatypus> What do you plan to do.

[05:47] <QtPlatypus> ?

[05:49] <stevan> luqui: what about Devel::TypeCheck?

[05:49] <stevan> or is it not the same thing you are talking about

[05:49] <luqui> That's the new inferrence module for perl 5?

[05:49] <stevan> yes sir

[05:49] <luqui> that's not what I'm talking about

[05:49] <luqui> Perl 6's type inferrence must be much more general than that

[05:50] <stevan> then you sir, are talking crazy :P

[05:50] <stevan> can you elaborate? 

[05:50] <luqui> I'm just going to let the user specify a tree structure and then try to fill it in

[05:50] <stevan> type checking on trees?

[05:50] <luqui> such as, oh, say, PIL

[05:50] <luqui> With typed nodes

[05:50] <stevan> ah

[05:50] <luqui> and it will check that everything makes sense as you fill it in

[05:50] <stevan> so you are not talking about making a "type tree" and checking types with that

[05:51] <luqui> I'm not sure what you mean by "type tree"

[05:51] <stevan> testing derived types and such

[05:51] <luqui> oh I will be testing derived types and such

[05:51] <luqui> It's pretty easy to do -- you don't ever need to look outside the types that were actually mentioned

[05:51] <luqui> It's just a little expensive (n^2 in the number of type variables)

[05:51] <stevan> no I mean making a tree of types like (Any Node(Scalar), Node(Int)) stuff like that

[05:52] <luqui> you mean union types

[05:52] <luqui> ?

[05:52] * stevan is going to stop asking and wait for luqui to write some code :)

[05:52] <luqui> okay

[05:52] <luqui> I have a five hour gap at school tomorrow

[05:52] <luqui> that's probably when it will get done

[05:53] <luqui> bedtime now

[05:53] <stevan> I think we are probably talking about 2 diff things, but not in the same dialect 

[05:53] <luqui> probably

[05:53] <luqui> good night

[05:53] * luqui sleep &

[05:53] <stevan> bah,.. for a college student you are a wussy

[05:53] <stevan> it is early still

[05:53] * luqui wake

[05:53] * luqui smacks stevan

[05:53] <stevan> no no,.. you need your beauty sleep

[05:53] <luqui> tomorrow is the second day of classes

[05:54] <luqui> I'd really rather not sleep through that one

[05:54] * luqui puts in earplugs and sleeps &

[05:54] <stevan> :)

[05:54] <stevan> nite

[05:54] * stevan cracks open MetaModel 2.0 and gets to work

[06:03] <coral> oo, unaffiliated

[06:22] <geoffb> stevan, what is MM 2.0?  (Sorry, been away for a while because of RL)

[06:31] <stevan> geoffb: 2.0 is a better tasting metamodel with only half the calories of 1.0

[06:32] <stevan> geoffb: it is based on MiniMetaModel

[06:32] <geoffb> Will it replace MM 1 everywhere?

[06:32] <stevan> I am trying to clean things up, and be as minimalist as possible

[06:32] <stevan> geoffb: eventually, yes

[06:33] <stevan> I am trying to keep the changes to the user-facing API to a minimum

[06:33] <geoffb> nodnod

[06:33] <stevan> just re-write the core

[06:33] <geoffb> How up to date is STATUS wrt your stuff?

[06:33] <stevan> no idea

[06:33] <geoffb> ah

[06:33] <stevan> I have been totally swamped with $work

[06:33] <geoffb> Understood, I've been totally swamped with $life

[06:34] <stevan> $life++

[06:34] <stevan> but $work-- 

[06:34] <QtPlatypus> none($work)--

[06:34] <stevan> basically this is my "relaxation" after about 14+ hours of work

[06:34] <geoffb> Hmmm, maybe tomorrow or so I need to do another round of asking people for status and updating docs to match

[06:34] <geoffb> good choice, stevan  :-)

[06:34] <stevan> :)

[06:35] * geoffb is relaxing by writing notes on optimization strategies 

[06:35] <stevan> :D

[06:35] <stevan> last night I read papers on implementing subtypes/generics with metamodels

[06:35] <geoffb> :-)

[06:36] <stevan> and got inspired,.. so I wanted to finish 2.0 enough to try ideas

[06:36] <stevan> I probably actually should be doing $work

[06:36] * geoffb recognizes that behavior

[06:36] <geoffb> (having been there many times)

[06:37] <geoffb> bah, must run, thanks for the info, stevan

[06:37] <stevan> geoffb: enjoy :)

[06:57] *** _jql is now known as jql

[07:45] <svnbot6> r6415 | Stevan++ | Perl6::MetaModel 2.0 -

[07:45] <svnbot6> r6415 | Stevan++ | * $::Object is now defined, but does not yet work 

[07:45] <svnbot6> r6415 | Stevan++ |   correctly. I need to figure out the best way to

[07:45] <svnbot6> r6415 | Stevan++ |   deal with class methods and meta methods still.

[07:45] <svnbot6> r6415 | Stevan++ | * a few more test files, however not many tests

[07:45] <svnbot6> r6415 | Stevan++ |   can be written until the class/meta method issue

[07:45] <svnbot6> r6415 | Stevan++ |   is resolved.

[07:58] <nothingmuch> morning

[08:05] <QtPlatypus> Mornig.

[08:13] * nothingmuch concludes from the 1.e5 thread that his solution is the best

[08:13] <nothingmuch> anyone want to implement an AUTOMETHOD that does that?

[08:16] <nothingmuch> it should be something like 'method AUTOMETHOD (Int $int:) { parse_as_float("$int$AUTOLOAD") }' where parse_as_float is one of haskell's 'read's

[08:17] <nothingmuch> ah, oops

[08:18] <nothingmuch> s/AUTOLOAD/_/;

[08:18] <nothingmuch> as per s10

[08:21] * nothingmuch is off to clean up the house

[10:01] <xinming> sub head(*$head, *@tail) { return $head }

[10:01] <xinming> hmm, I can understand this one, What about this example please?

[10:02] <xinming> sub head( *$head, $special, *@tail ) { return $special; )

[10:02] <xinming> sub head( *$head, $special, *@tail ) { return $special; };

[10:03] <xinming> ouch... I think I mislead myself...

[10:53] <svnbot6> r6416 | rgs++ | * a note on split STRING

[10:53] <svnbot6> r6416 | rgs++ | * shortly mention =$fh

[11:32] <svnbot6> r6417 | yiyihu++ | Add the test for S06 List parameters, which will test slurpy scalar, slurpy array, and slurpy hash.

[11:33] <QtPlatypus> What is the meaning of a slurpy scalar?

[11:34] <xinming> Slurpy scalar parameters capture what would otherwise be the first elements of the variadic array:

[11:35] <xinming> hmm, QtPlatypus Sorry for my confusion, I think I should say ("slurpy scalar"| "slurpy array"|"slurpy hash") parameters

[11:35] <xinming> s/my/the/

[11:36] * xinming is considering to go to Junior School for learning English.

[11:38] * QtPlatypus nods.

[12:50] <xinming> seen autrijus 

[12:50] <jabbot> xinming: autrijus was seen 1 days 9 hours 16 minutes 18 seconds ago

[12:57] <nothingmuch> hola

[13:02] <Limbic_Region> como esta ustede?

[13:28] <svnbot6> r6418 | fglock++ | * perl5/ Code - TODO update

[13:36] <itz> print @foo.len(); # this returns  No compatible subroutine found: "&len" with the SVN version?

[13:36] <nothingmuch> ?eval my @foo = (1, 2, 3); @foo.length

[13:36] <evalbotzy> Error: No compatible subroutine found: "&length" 

[13:36] <nothingmuch> ?eval my @foo = (1, 2, 3); @foo.elems

[13:36] <evalbotzy> 3 

[13:37] <nothingmuch> this is an explicit distinction

[13:37] <nothingmuch> length is ambiguous

[13:37] <nothingmuch> otoh the number of elements is unambiguous

[13:37] <nothingmuch> for strings too - let me try to remember:

[13:37] <nothingmuch> ?eval my $foo = "abc"; $foo.chars

[13:37] <evalbotzy> 3 

[13:37] <nothingmuch> ?eval my $foo = "abc"; $foo.graphemes

[13:37] <evalbotzy> Error: No compatible subroutine found: "&graphemes" 

[13:37] <nothingmuch> ?eval my $foo = "abc"; $foo.bytes

[13:37] <evalbotzy> 3 

[13:37] <nothingmuch> ?eval my $foo = "לה לה לה"; $foo.bytes

[13:37] <evalbotzy> 3 

[13:38] <nothingmuch> ?eval my $foo = "לה לה לה"; $foo.chars

[13:38] <evalbotzy> 3 

[13:38] <nothingmuch> that's bollocks

[13:38] <nothingmuch> ?eval "fooooo".chars

[13:38] <evalbotzy> 6 

[13:38] <nothingmuch> ?eval "שלום".chars

[13:38] <evalbotzy> 1 

[13:38] <nothingmuch> anyway, nevermind, appearantly evalbot is not grokking the unicode

[13:39] <nothingmuch> in my terminal it works correctly

[13:41] <nothingmuch> as for graphemes, ñ is one char, but two graphemes, and i don't know how many bytes (encoding dependant)

[13:41] <nothingmuch> ?eval 'ñ'.chars

[13:41] <evalbotzy> 1 

[13:42] <nothingmuch> ?eval 'ñ'.craphs

[13:42] <evalbotzy> Error: No compatible subroutine found: "&craphs" 

[13:42] <nothingmuch> ?eval 'ñ'.graphs

[13:42] <evalbotzy> 1 

[13:44] <nothingmuch> itz: fair enough?

[13:46] <iblech> autrijus: Could you please explain what isNamed indicates? sub foo ($a) -- isNamed is 1, sub foo (+$a) -- isNamed is 0

[13:47] <nothingmuch> iblech: named vs  positional params

[13:47] <iblech> nothingmuch: Right, but why is isNamed 1 for a positional?

[13:47] <nothingmuch> because it can be named

[13:47] <nothingmuch> wait

[13:48] <nothingmuch> ughhh, confusion!

[13:48] <itz> nothingmuch: you lost me there :) is @foo.len not valid syntax? I thought it worked in the past?

[13:48] <nothingmuch> itz: there is no 'len' method for arrays

[13:48] <iblech> nothingmuch: Thought so too. But then I wondered why isNamed is 0 for a name-only param...

[13:48] <nothingmuch> and not even 'length' like there should have been

[13:48] <iblech> itz: It is valid syntax, though

[13:49] <nothingmuch> itz: the error is not a syntax one, it's a "can't find such a method" one

[13:49] <iblech> ?eval "a string can't be .summed".sum

[13:49] <evalbotzy> 0.0 

[13:49] <itz> was it ever in pugs or did I dream it?

[13:49] <iblech> d'oh

[13:49] <iblech> itz: You must have dreamed it :)

[13:50] <nothingmuch> itz: there are no more abbrv func names in p'l 6

[13:50] <itz> hmm I must be confusing p6 with ruby or something

[13:50] <nothingmuch> so it was never 'len' but rather 'length', but even that doesn't make sense, because arrays don't have a length

[13:50] <nothingmuch> they have a size in a certain dimension, like the number of elements

[13:51] <nothingmuch> uh

[13:51] <itz> I want "elems" then?

[13:51] <nothingmuch> damnit, shouldn't it be @array.elements ?

[13:51] <nothingmuch> i thought they were dropping all the gethostbynm type crap

[13:51] <iblech> nothingmuch: Huffmann, etc. chars, graphs, bytes, elems

[13:51] <nothingmuch> are there full sized aliases?

[13:52] <iblech> itz: If you want the number of elements in an array, yes -- you can use @array.elems or +@array

[13:52] <iblech> nothingmuch: our &elements ::= &elems?

[13:52] <nothingmuch> iblech: i mean by default

[13:52] <nothingmuch> but yes

[13:53] <nothingmuch> ?eval my @foo = <1 2 3>; @foo.elements

[13:53] <evalbotzy> Error: No compatible subroutine found: "&elements" 

[13:53] <nothingmuch> ?eval my @foo = <1 2 3>; @foo.elems

[13:53] <evalbotzy> 3 

[13:53] <nothingmuch> also 'graphs' is not as clear as 'graphemes

[13:54] <nothingmuch> and shouldn't the tilde on ñ be a different grapheme?

[13:55] <iblech> .graphs is currently the same as .chars

[13:55] <nothingmuch> ah

[13:55] <nothingmuch> btw, should we also have phonemes?

[13:57] * iblech doesn't have a strong opinion, as long as he has .bytes and .chars

[13:57] <nothingmuch> http://en.wikipedia.org/wiki/Terminology_in_graphonomics

[13:57] <nothingmuch> well, .chars is sometimes diff

[13:57] <nothingmuch> it's the most common usage

[13:57] <nothingmuch> and .bytes is totally orthogonal

[13:58] <nothingmuch> in hebrew, for example, we have nikud

[13:58] <nothingmuch> we have very few vowels

[13:58] <nothingmuch> and most motions are implicit, when there is no nikud present

[14:13] <svnbot6> r6419 | fglock++ | * perl5/ List

[14:13] <svnbot6> r6419 | fglock++ |   - implemented ('a' x 100) style lists

[14:13] <svnbot6> r6419 | fglock++ |     this can be used to create sparse arrays like:  [ 1, undef x 1_000_000, 2 ]

[14:13] <svnbot6> r6420 | iblech++ | * Usual svn props and EOLs at EOFs.

[14:13] <svnbot6> r6420 | iblech++ | * t/builtins/lists/: map.t, sort.t, grep.t, sum.t, reduce.t:

[14:13] <svnbot6> r6420 | iblech++ |   Test that 42.sum, 42.map, etc. do not work (but (42,).sum, etc.) should work.

[14:13] <svnbot6> r6420 | iblech++ | * t/subroutines/slurpy_param.t: Fixed some minor details, changed the expected

[14:13] <svnbot6> r6420 | iblech++ |   results of some tests to make more sense, started a p6l thread concerning

[14:13] <svnbot6> r6420 | iblech++ |   the test and skipped all tests ("semantics not confirmed by p6l") until p6l

[14:13] <svnbot6> r6420 | iblech++ |   replies.

[14:14] <iblech> fglock: undef x 1_000_000 should not create a list containing 1_000_000 items, but a string of length 1_000_000:

[14:14] <iblech> ?eval "42" x 5

[14:14] <evalbotzy> '4242424242' 

[14:14] <iblech> ?eval "42" xx 5

[14:14] <evalbotzy> ('42', '42', '42', '42', '42') 

[14:15] <lhooq> ?eval my $i = 0; sub i { $i++ }; i() for (1..5);

[14:15] <evalbotzy> undef 

[14:16] <lhooq> ?eval my $i = 0; sub i { $i++ }; (i, i, i, i, i);

[14:16] <evalbotzy> (0, 1, 2, 3, 4) 

[14:16] <lhooq> ?eval my $i = 0; sub i { $i++ }; i xx 5;

[14:16] <evalbotzy> Error: No compatible subroutine found: "&xx" 

[14:16] <lhooq> ?eval my $i = 0; sub i { $i++ }; i() xx 5;

[14:16] <evalbotzy> (0, 0, 0, 0, 0) 

[14:16] <lhooq> eager!

[14:17] <iblech> lhooq: Right. You need something like (1..5).map:{ i() }

[14:17] <iblech> But IIRC luqui (or was it somebody else?) wants to change that to { i() } XX 5

[14:17] <iblech> s/change that to/make the following possible/

[14:18] <lhooq> with uppercase XX?

[14:18] <iblech> Yep.

[14:18] <iblech> But the proposal hasn't been accepted by @Larry

[14:19] <PerlJam> map is easier to type

[14:19] <nothingmuch> iblech: i think it was Juerd

[14:19] <iblech> nothingmuch: Ah, thanks

[14:20] <PerlJam> I'd take  i() xxx 5  before I'd like XX

[14:21] <nothingmuch> &:infix:{'x' x 3}

[14:21] * nothingmuch thinks it should have been 'x' instead of 'xx' and '~x' instead of 'x'

[14:22] <PerlJam> nothingmuch: maybe.  We already have that consistency elsewhere, so it makes sense with x I guess.

[14:22] <nothingmuch> PerlJam: did you hear my rant about == ?

[14:22] <PerlJam> nope

[14:22] <nothingmuch> i think ~== and +== should replace 'eq' and '==' respectively

[14:22] <nothingmuch> where '==' is generic equality

[14:23] <PerlJam> Hmm.

[14:23] <nothingmuch> so "foo" == "bar";

[14:23] <nothingmuch> and "foo" == 1

[14:23] <nothingmuch> they work

[14:23] <PerlJam> What does "work" mean?

[14:23] <nothingmuch> it's stringwise in these cases, because coercion works that way better than numification works

[14:23] <nothingmuch> otoh 10 == 10  and 10 == 10.0 is also good

[14:24] <nothingmuch> although "10.0" == 10

[14:24] <nothingmuch> that is bad, because it's ~==

[14:24] <nothingmuch> for that you need to say "10.0" +== 10, and instead of the right side being stringified, the left side is numified

[14:24] <nothingmuch> autrijus hates it

[14:24] <nothingmuch> but my argument is that i need generic equality much more often than I need "eq" or "=="

[14:25] <PerlJam> nothingmuch: I'll tell you that I don't believe in "generic equality"

[14:25] <PerlJam> You have to know the types of the things you're comparing at some level.

[14:25] <nothingmuch> it's not generic equality in the sense that it's super smart

[14:25] <nothingmuch> it's a part of the Eq role

[14:25] <nothingmuch> and object must implement it if it wants to

[14:26] <nothingmuch> like "use overload '=='" in perl 5

[14:27] <PerlJam> my $a = new Foo;  my $b = new Bar;  $a == $b   # What's this?  An error if both don't do the Eq role?

[14:27] <nothingmuch> yes

[14:27] <nothingmuch> unless MMD defines it otherwise

[14:28] <nothingmuch> perhaps ~== is the default ==

[14:28] <nothingmuch> but it lets you have truely meaningful things:

[14:28] <xinming> iblech: :-) In fact, I considered the slurpy *%hash carefully, And I think I "might" be right, So I wrote the test. :-P

[14:29] <nothingmuch> multi sub &infix:<==> (@l, @r) { @l.elems +== @r.elems && (@l »==« @r)

[14:29] <xinming> iblech: thanks for your modification.

[14:29] <PerlJam> trigraphs are little loved though.  If you could make them digraphs even they'd be more palatable.

[14:29] <iblech> xinming: Lets wait for p6l to respond :)

[14:30] <iblech> xinming: But I don't think it makes much sense that you can't pass any parameters by name if there's a *%slurpy_hash

[14:31] <nothingmuch> PerlJam: what bothers me about eq vs == is that in perl 5 the choice was mostly aesthetic

[14:31] <nothingmuch> people overload == more often because it looks more like =

[14:32] <lhooq> ?eval my @a = (); @a.push('x') for(1..3); @a;

[14:32] <evalbotzy> ['x', 'x', 'x'] 

[14:32] <lhooq> ?eval my $i = 0; sub i { $i++ }; my @a = (); @a.push(i) for(1..5); @a;

[14:32] <evalbotzy> [0, 1, 2, 3, 4] 

[14:32] <nothingmuch> and for many things, especially structures it makes sense to overload equality (sets, arrays, junctions, etc) for reasons of efficiency as well as accuracy

[14:33] <nothingmuch> further uses:

[14:34] <nothingmuch> path handling: the path object's == consolidates 'dir/..' so that Path.new("foo/../bar") == Path.new("bar")

[14:34] <nothingmuch> you can overload == locally for float tolerance:

[14:35] <nothingmuch> my &infix:<==> (Float $l, Float $r) { abs($l - $r) < $threshold }

[14:35] <nothingmuch> this doesn't interfere with +== on numbers

[14:37] <PerlJam> nothingmuch: careful ... Larry may like your idea but use +eq and ~eq instead  ;-)

[14:37] <nothingmuch> does this seem somewhat sane?

[14:38] <lhooq> nothingmuch: sorry, but I don't like +== for comparison, it looks too much like +=

[14:39] <iblech> nothingmuch: I agree, it's very useful. *But* I want eq to stay string eq and == to stay numeric eq.

[14:39] <iblech> nothingmuch: But now there's eqv :)

[14:39] <iblech> nothingmuch: my multi &infix:<eqv> (Float $l, Float $r) {...}

[14:39] <nothingmuch> right, i know eqv

[14:39] <nothingmuch> and I hate it

[14:40] <nothingmuch> lhooq: what do you think about the other ~/+/? distinctions?

[14:40] <PerlJam> There's too much cultural history for == or eq to go away.

[14:40] <nothingmuch> what about the consistency? &&, || and ^^ are generalized

[14:41] <nothingmuch> ?&, ?|, +&, ~^, etc are specialized

[14:42] <broquaint> ?eval class MyArray is Array { sub push { say "pushing things: {@_.perl}" }  }my @a = MyArray.new; @a.push("a string"); # What am I missing?

[14:42] <evalbotzy> 2 

[14:43] <broquaint> No, I don't think there's a 2 missing, evalbotzy.

[14:43] <broquaint> But nice guess.

[14:43] <nothingmuch> ?eval class MyArray is Array { sub push { method "pushing things: {@_.perl}" }  }my @a = MyArray.new; @a.push("a string");

[14:43] <evalbotzy> 2 

[14:43] <nothingmuch> ?eval class MyArray is Array { method push { say "pushing things: {@_.perl}" }  }my @a = MyArray.new; @a.push("a string");

[14:43] <evalbotzy> 2 

[14:43] <iblech> broquaint: That wouldn't work, you have to use my @a is MyArray

[14:43] <nothingmuch> oops, wrong subs ;-)

[14:43] <iblech> broquaint: Otherwise it's simply my @a = (MyArray.new)

[14:44] <nothingmuch> ?eval class MyArray is Array { method push { say "pushing things: {@_.perl}" }  } my @a is MyArray; @a.push("a string");

[14:44] <iblech> broquaint: But it's not implemented yet

[14:44] <evalbotzy> 1 

[14:44] <broquaint> Indeed, iblech. Using := instead of = does the trick too.

[14:44] <broquaint> ?eval class MyArray is Array { sub push { "pushing things: {@_.perl}" }  }my @a := MyArray.new; @a.push("a string"); # What am I missing?

[14:44] <evalbotzy> 'pushing things: [MyArray.new();, \'a string\']' 

[14:45] <broquaint> Neat.

[14:45] <broquaint> And sub Array::push works too, which is very cool.

[14:45] <xinming> iblech: where can I find the contents for the `built-in sum`?

[14:45] <iblech> xinming: IIRC src/Pugs/Prim/List.hs

[14:46] <xinming> iblech: thanks

[14:46] <iblech> xinming: Or perl5/PIL2JS/lib6/Prelude/JS/Array.pm if you want to see a pure-Perl 6 version of it :)

[14:46] <xinming> Oops... Isn't there a perl version?

[14:46] <xinming> thanks

[14:46] <lhooq> nothingmuch: well, I don't like the distinctions too much, especially the ? one

[14:47] <iblech> xinming: The sum in the .hs file is in Haskell

[14:47] <lhooq> nothingmuch: but &&, || and ^^ are different, they are always boolean in context

[14:47] <nothingmuch> so is ==

[14:47] <nothingmuch> wait

[14:47] <nothingmuch> no, only == is

[14:48] <nothingmuch> && and || and ^^ are not boolean at all

[14:48] <nothingmuch> or do you mean the context they force on their args?

[14:48] <fglock> stevan: ping

[14:48] <lhooq> yes, I mean the context

[14:48] <xinming> iblech: yes, In fact, I want to know If I can do as the "same" as the built-in ones. :-)

[14:48] <nothingmuch> sub &infix:<||> ($l, $r) { return $l if ?$l; return $r }

[14:49] <nothingmuch> i always saw them as passthrough

[14:49] <lhooq> there is an explicit ? there

[14:49] <nothingmuch> yes

[14:49] <lhooq> so they "force" boolean context somehow

[14:49] <nothingmuch> if $l in boolean context is true, then return $l, otherwise return $r

[14:49] <nothingmuch> $r is never boolean

[14:49] <nothingmuch> unless they stack

[14:50] <lhooq> well, ok, I think you understood what I'm talking about

[14:50] <iblech> xinming: Not sure I've understood you correctly, but yes, you can override the builtin implementantions. I.e. even sub say (*@args) {...} is fine

[14:50] <lhooq> you don't really need something like +||, +&& etc.

[14:51] <QtPlatypus> lhooq: You need it to distingiush between +|| and ~||

[14:52] <lhooq> QtPlatypus: you _don't_ _need_

[14:52] *** autark is now known as jp-autark

[14:52] <lhooq> the distinction is +(A || B) vs. ~(A || B), maybe

[14:53] <QtPlatypus> lhooq: So using context to deside which one?

[14:53] <broquaint> Let's just drop boolean operators and be done with it.

[14:53] <lhooq> QtPlatypus: no, because the || is always the same

[14:53] <nothingmuch> how is operator precedence specified for 'sub &infix:<blah>' ?

[14:53] <lhooq> the _external_ context may be different, but || doesn't care

[14:53] <nothingmuch> or which synopsis is that in?

[14:54] <QtPlatypus> Hold on || is bitwise or isn't it?

[14:54] <lhooq> (doesn't care in the sense that it is "passthrough", as nothingmuch noted)

[14:54] <nothingmuch> or (~A || ~B)

[14:54] <xinming> iblech: what I mean, is, I want to know, If I catch the "right" idea of writing perl 6 program. :-) the built-in certainly would be the best example for me to follow.

[14:54] <xinming> iblech: by the way, did you read the Synopsis?

[14:54] <nothingmuch> the passthrough-ness of &&, and && should apply to ==, IMHO

[14:54] <xinming> the S06

[14:54] <nothingmuch> ^^ returns Bool anyway

[14:55] <nothingmuch> so == is not in a different ballpark

[14:55] <xinming> iblech: It was updated this "morning" (here now is evening, maybe midnight)

[14:55] <lhooq> nothingmuch: I disagree

[14:55] <nothingmuch> lhooq: i know you don

[14:55] <nothingmuch> t

[14:56] <nothingmuch> it's just my opinion =)

[14:56] <lhooq> I don't see _how_ == is supposed to passthrough

[14:56] * xinming away to go out to take something to eat.

[14:56] <xinming> bbl

[14:56] <iblech> xinming: Of course, I have read all AES several times :)

[14:56] <iblech> xinming: Right, but the update didn't effect the section about slurpies, right?

[14:57] <lhooq> variables in Perl are not strong-typed, so unless you use == or eq, you can't possibly know what to numify and what to stringify

[14:57] <iblech> xinming: I've thought of slurpy hashes similar as of slurpy arrays -- they slurp all *remaining* arguments (positionals or pairs)

[14:58] <nothingmuch> lhooq: it's not passthrough, but it's generic

[14:58] <lhooq> define "generic"

[14:58] <nothingmuch> does anybody remember how you say what an &infix's precedence is? i can't find it

[14:58] <nothingmuch> lhooq: multi sub &infix:<==> (@l, @r --> Bool) { @l.elems +== @r.elems and @l.elems  }

[14:58] <nothingmuch> uh, crap, that's 50%

[14:59] <nothingmuch> lhooq: multi sub &infix:<==> (@l, @r --> Bool) { @l.elems +== @r.elems and @l »==« @r  }

[14:59] <lhooq> nothingmuch: is tighter(...) or something like that

[14:59] <nothingmuch> lhooq: thanks

[15:01] <lhooq> nothingmuch: this can't be what you want

[15:01] <nothingmuch> it is

[15:01] <lhooq> nothingmuch: if I want a == to compare each element in two arrays, I prefer to explicitly use >>...<<

[15:02] <nothingmuch> what if it's a generic collection? like a tree?

[15:02] <lhooq> eg. when I do something that could bog down my CPU like a slug, I don't want it to be _so_ easy to do

[15:03] <nothingmuch> do you need to define multi &circumfix:{'>>', '<<'} (Code $op, Tree $tree) { .... } ?

[15:03] <nothingmuch> lhooq: why bog down?

[15:03] <nothingmuch> stringification of an array takes just as long

[15:03] <nothingmuch> and @array == @other is very confusing

[15:03] <nothingmuch> that is really (@array.elems == @array.elems)

[15:04] <nothingmuch> newbies will weep

[15:04] <lhooq> but their CPUs will rejoice :-)

[15:04] <nothingmuch> (@array +== @other) is much more "clear cut"

[15:04] <nothingmuch> but it'll be wrong code

[15:04] <nothingmuch> and infix == is more "optimized" than >>==<< because it checks @l.elems +== @r.elems first, too =)

[15:04] <nothingmuch> and in fact, i think that >>==<< can be misleading if the shape of two arrays isn't the same

[15:05] <nothingmuch> are undefs substituted in the shorter list?

[15:05] <lhooq> then it is (@array == @other && @array >>==<< @other)

[15:05] <nothingmuch> i know, but i think that's aweful

[15:06] <nothingmuch> what it is now is much better:

[15:06] <nothingmuch> if (@array eqv @other)

[15:06] <nothingmuch> but that still kinda sucks

[15:06] <nothingmuch> IMHO at least

[15:06] <iblech> nothingmuch: That won't do what you think it does, I think.

[15:06] <iblech> nothingmuch: eqv expects two scalars, so that really is \@array eqv \@other

[15:06] <nothingmuch> ugh

[15:06] <lhooq> shouldn't that be @array ~~ @other?

[15:07] <nothingmuch> is it multi?

[15:07] <nothingmuch> lhooq: ~~'s conveyed meaning is completely different, IMHO

[15:07] <iblech> nothingmuch: Then these refs (in the absense of some rebinding) don't point to the same container, so it'll always be false

[15:07] <iblech> lhooq: Right, @array ~~ @other should work, I think

[15:07] <nothingmuch> my @array = <a b c>, my @other = (rx/a/, rx/[abc]/, rx/\w+/); @array ~~ @other;

[15:07] <nothingmuch> *BOOM*

[15:08] <nothingmuch> it's way too smart

[15:08] <nothingmuch> which is good for most things

[15:08] <nothingmuch> but not for some things

[15:08] <lhooq> nothingmuch: anyway, your example still doesn't answer this question: is each element in @l and @r compared numerically or stringish?

[15:08] <nothingmuch> lhooq: that depends on each pair of elements, and the MMD that matches

[15:08] <nothingmuch> =)

[15:08] <iblech> nothingmuch: Hm, to the problem is that it recurses too much... @array ~~ @other :recurse(0)

[15:09] <nothingmuch> iblech: i beg to differ

[15:09] <nothingmuch> ~~ is just as recursive, even if it's implicit

[15:09] <nothingmuch>     Array   Array     arrays are identical     match if $_ »~~« $x

[15:09] <nothingmuch> from s04

[15:10] <iblech> nothingmuch: Right, I meant that by using an adverbial modifier you could change that behaviour

[15:10] <nothingmuch> in a sense I think that &infix:<==> should have the same "recursive" semantics as &infix:<~~> in the prelude

[15:10] <nothingmuch> oh

[15:10] <nothingmuch> it's just that == is applied instead of ~~ to the elements

[15:10] <nothingmuch> so why not have @array == @other :recurse(0);

[15:11] <iblech> Because == means number, and I doubt that this changed

[15:12] <iblech> (I don't want it to change, too :))

[15:12] <iblech> But that's what ~~, paired with modifiers, is there for, I think

[15:13] <nothingmuch> ick

[15:13] <nothingmuch> i'm mailing to p6l

[15:13] <nothingmuch> please make sure to voice your protest

[15:13] <iblech> I will :)

[15:15] <nothingmuch> &infix:<~~>.add_variant(sub (Code &op, Array @l, Array @r) { @l >>&op<< @r }.assuming(&infix:<~~>))

[15:15] <iblech> ooh

[15:15] <iblech> but

[15:15] <iblech> how do you specify your own comparator, given that ~~ is not ternary?

[15:15] <nothingmuch> rephrase please

[15:16] <iblech> I mean, ~~ takes only two arguments, LHS and RHS

[15:16] <nothingmuch> right

[15:16] <iblech> But your snippet adds a third param

[15:16] <nothingmuch> so does ==

[15:16] <iblech> Right.

[15:16] <nothingmuch> assuming =)

[15:16] <iblech> Right.

[15:16] <iblech> But:

[15:17] <iblech> If I don't want to use .assuming

[15:17] <iblech> But if I want to override it only for one single call

[15:17] <nothingmuch> then it's just a weird variant

[15:17] <nothingmuch> that takes an entirely different set of params

[15:17] <iblech> I.e. something along the lines of @foo ~~:{ $^a eq $^b } @bar

[15:17] <iblech> (But this look very ugly)

[15:18] <nothingmuch> huh?

[15:18] <iblech> Hm, @foo ~~ @bar :comparator{ $^a eq $^b }

[15:18] <nothingmuch> ah

[15:18] <nothingmuch> you just take the generic comparator generator from the prelude, and apply it to your own op

[15:19] <nothingmuch> in my email it will be cleared

[15:19] <iblech> ok, /me waits :)

[15:19] <nothingmuch> sent

[15:19] <iblech> (I like that general idea, as far as I've understood it, BTW)

[15:20] <nothingmuch> yes, i like it too =)

[15:20] <nothingmuch> btw, i've changed my mind slightly

[15:20] <nothingmuch> =='s affinity is towards multi sub &infix:<==> (Num $l, Num $l) { ... }

[15:20] <lhooq> nothingmuch: anyway, I think that "generic equality" a) causes more problems than it tries to solve and b) is too CPU-intensive to implement

[15:20] <nothingmuch> so "10.0" == 10 is backwards compatible

[15:21] <nothingmuch> lhooq: most of perl 6 is too CPU intensive already

[15:21] <lhooq> so you fight fire with fire? :-)

[15:21] <nothingmuch> as for a) we're trying to clean this up... MMD is helping, but I definately don't want 'use overload' all over again

[15:22] <nothingmuch> lhooq: no.. See also Psyco, type inferencing, and what not to make it "just work"

[15:22] <nothingmuch> as well as the fact that despite this we still have >><< and [] which are *very* dangerous in that respect, but so useful we can't give uup

[15:22] <nothingmuch> the caveat in my proposal is that (@a == @b) cannot be translated as is

[15:22] <nothingmuch> and makes things slower for that case

[15:23] <nothingmuch> but when I want to compare the number of elements we have all sorts of disambiguations anyway.. .for example, it's not @a.length like in other programming languages, it's @a.elems

[15:23] <nothingmuch> so in that sense I think Perl 6 is progressing to another plane of usefulness

[15:23] <nothingmuch> and correctnes

[15:23] <nothingmuch> s

[15:23] <nothingmuch> and in that sense we should strive to give bazookas to shoot your foot with

[15:24] <lhooq> but you're giving a bazooka that looks like a lollipop

[15:24] <nothingmuch> because in the long run, as people become adept in perl this will pay off, as a programmer time optimization, and that's what really matters at the end of the day

[15:24] <nothingmuch> i agree

[15:24] <nothingmuch> but i think perl 6 is far enough from history to allow us to make it look like a lollipop

[15:24] <lhooq> well

[15:25] <nothingmuch> because it's a very sweet bazooka

[15:25] <lhooq> I remember the first time I saw a regexp

[15:25] <nothingmuch> as in totally cool

[15:25] <lhooq> I thought "bazooka!"

[15:25] <nothingmuch> (ref: http://www.realultimatepower.net/)

[15:25] <lhooq> now I master it, and can shoot with it

[15:26] <nothingmuch> iblech: extend_comparators on the bottom

[15:27] <nothingmuch> These guys are cool; and by cool, I mean totally sweet

[15:27] <nothingmuch> i got it backwards =(

[15:27] <nothingmuch> anyway, perl 6 is all about real ultimate power... think about it:

[15:27] <nothingmuch> 1990s: regexes... perl 6: full blown parser engine

[15:27] <nothingmuch> 1990s: for loops... perl 6: vectorizations

[15:28] <nothingmuch> 1990s: overloading... perl 6: higher order infix subs, and MMD dispatch make it all just functions

[15:28] <nothingmuch> 1990s: boolean logic... perl 6: junctive types encapsulate logic in data

[15:29] <nothingmuch> (slow! autohtreading! dangerous! but still in there!)

[15:30] <nothingmuch> anyway, i have to get back to house work

[15:30] <nothingmuch> i have to finish putting the books back on the shelf

[15:30] <nothingmuch> and vaccum the cement dust from my room

[15:35] * nothingmuch thinks about restarting fryTunes in perl 6

[15:35] <nothingmuch> the metamodel for music data is much easier to do with such a tough object system

[15:35] * nothingmuch will think about it while cleaning... Ciao!

[15:35] <iblech> nothingmuch: Could you elaborate a bit on extend_comparators later?

[15:36] <nothingmuch> iblech: still here, was reading mail

[15:37] <nothingmuch> iblech: are you asking?

[15:37] <iblech> nothingmuch: Yep :)

[15:37] <nothingmuch> okay =)

[15:38] <nothingmuch> btw, is control over whether --> is used for inferencing or not in the lexical scope?

[15:38] <nothingmuch> (strong inferrencing)

[15:38] <iblech> Huh? Can it be used for something different that inferencing?

[15:38] <nothingmuch> (we should always have [partial] static inferencing)

[15:39] <nothingmuch> well, if &infix:<==> (.... --> Bool) (regardless of whether it's generic or numerical)

[15:39] <nothingmuch> then can I use it and ignore the fact that it wants to return a Bool ?

[15:39] <nothingmuch> or do I have to use it in a type safe way? (BAD BAD BAD)

[15:39] <iblech> Ah, I understand

[15:39] <nothingmuch> i'd like to say "use types 'inferred'"

[15:40] <nothingmuch> and that way all functions can have (-->)

[15:40] <nothingmuch> or maybe that's just moot

[15:40] <nothingmuch> anyway, i'd like to be able to make use of any library that says what it returns in a type inferred way, and in an unsafe way

[15:41] <nothingmuch> and i'd like types to be inferred in both cases, and only when there is a conflict for the distinction to shine: safe - compile time error, unsafe - coercion compiled in

[15:41] <iblech> I think that will definitely work, given that we're talking about Perl (and not Haskell) :)

[15:41] <iblech> You always have coercion, I think

[15:41] <iblech> I.e. "1" + 1 will always work

[15:42] <nothingmuch> should it always work?

[15:42] <iblech> Hm, I think so

[15:42] <iblech> Because

[15:42] <nothingmuch> even if i "use types 'nazi'"? 

[15:42] <iblech> There exists a coerce:<as>(Str $str, Num ::to)

[15:42] <iblech> I think you need to talk with autrijus about that :)

[15:42] <nothingmuch> "use types 'inferred' :forbid<coercion>"

[15:43] <nothingmuch> there, problem solved =)

[15:43] <iblech> Right, something along this line

[15:43] <nothingmuch> i think everyone agrees that it's time for a language that is as type safe as the programmer wants it to be =)

[15:43] <nothingmuch> so what is your question about extend_comparators?

[15:44] <nothingmuch> btw, is the sigil & just a macro for 'Code $' ?

[15:45] <nothingmuch> i think that is pretty cool, except for 'my $var; my &code';

[15:45] <nothingmuch> uh, i meant 'my $foo; my &foo;

[15:45] <QtPlatypus> nothingmuch: Not in all cases.

[15:45] <nothingmuch> QtPlatypus: morally =)

[15:46] <QtPlatypus> sub foo {...}; &foo;

[15:46] <nothingmuch> iblech: faster!

[15:46] <nothingmuch> think of sub $name as just a macro for BEGIN { &symbol = $parsed }

[15:46] <nothingmuch> if it's not preceeded by 'my' or 'our' it gives our

[15:46] <iblech> nothingmuch: Sorry, was afk for a moment

[15:46] <iblech> nothingmuch: Right, autrijus and I want to change it that way

[15:47] <iblech> nothingmuch: But the sigil is till &

[15:47] <iblech> s/till/still/

[15:47] <QtPlatypus> nothingmuch: I like that.

[15:47] <nothingmuch> sorry

[15:47] <iblech> So there's no conflict between $var and &var

[15:47] <nothingmuch> there is the macro 'sub'

[15:47] <nothingmuch> and the function 'sub'

[15:47] <nothingmuch> which is just like 'id'

[15:47] <nothingmuch> but also takes parameters

[15:47] <nothingmuch> (a prototype)

[15:47] <nothingmuch> beh, it's a bit more difficult than that, obviously

[15:48] <nothingmuch> but in a sense the declaration 'sub' is a macro just like 'use' is a macro

[15:48] <iblech> nothingmuch: WRT extend_comparators, could you give me some code lines to illustrate your idea? :)

[15:48] <nothingmuch> iblech: think of that as the part of the prelude that defined ~~

[15:48] <iblech> ok

[15:48] <nothingmuch> there are already &infix:<~~> ($_, $code)

[15:48] <nothingmuch> and so on and so forth

[15:49] <nothingmuch> and then more generic comparisons regarding collections are generated

[15:49] <nothingmuch> like $item ~~ %hash;

[15:49] <nothingmuch> or @array ~~ @array

[15:49] <nothingmuch> the rules for how ~~ matches WRT to collections can be applied to == too

[15:49] <iblech> ok

[15:50] <nothingmuch> btw, can I define aggregate functions like this?

[15:50] <nothingmuch> &foo := for.assuming(:block -> $x, $y { ... });

[15:51] <iblech> &foo := &statement_control:<for>.assuming(block => -> $x, $y {...}) should work

[15:51] <nothingmuch> woot!

[15:51] <nothingmuch> iblech: is the extend_comparators issue cleared up?

[15:51] <nothingmuch> because I really need to become useful now

[15:52] <nothingmuch> holy shit! http://leaf.dragonflybsd.org/mailarchive/submit/2005-08/msg00028.html

[15:52] <iblech> nothingmuch: No, but I have to think a bit longer about that and I don't want to keep you from becoming useful :)

[15:52] <nothingmuch> iblech: then reply to the p6l post please =)

[15:53] <iblech> nothingmuch: Yep, will write it in a minute :)

[15:53] <nothingmuch> ciao!

[15:53] <iblech> bye nothingmuch :)

[16:00] <xinming> iblech xinming: I've thought of slurpy hashes similar as of slurpy arrays -- they slurp all *remaining* arguments (positionals or pairs)

[16:00] <xinming> iblech: then, This would cause Error.

[16:00] <xinming> the positional argument is normally required, right?

[16:01] <xinming> slurpy *%hash slurped it, Then, You didn't specify the $positional, It would be a compile time error.

[16:05] <xinming> iblech: hmm, But what I do not agree with is if there is a ( pair ) need to pass to the hash, but not the keyword is the same as positional's name, then, It's an error. just like 

[16:06] <xinming> sub fun( $a, *%h ) { ... }; In my opinion, If there is a slurpy hash, pass the arguments with "pair-form" should be disabled.

[16:06] <xinming> iblech: Sorry, I went out for the "supper" :-)

[16:08] <xinming> iblech: In fact, I even thought that if @Larry hesitates to choose in these two choices.

[16:09] <mambotech> hi, can anyone here tell me what is missing please Can't locate Config/IniFiles.pm in @INC (@INC contains: /usr/local/lib/perl5/site_perl/5.8.7/mach /usr/local/lib/perl5/site_perl/5.8.7 /usr/local/lib/perl5/site_perl /usr/local/lib/perl5/5.8.7/BSDPAN /usr/local/lib/perl5/5.8.7/mach /usr/local/lib/perl5/5.8.7 .) at /usr/local/sbin/vuser line 9.

[16:09] <mambotech> BEGIN failed--compilation aborted at /usr/local/sbin/vuser line 9.

[16:10] <xinming> mambotech: How do you run pugs?

[16:10] <xinming> do you use make install as root?

[16:10] <mambotech> ?

[16:11] <xinming> mambotech: command make just compile the sources. It seems that your installation isn't complete

[16:16] <iblech> xinming: luqui replied to my question on p6l

[16:16] <iblech> mambotech: I think you want #perl, not #perl6, #perl6 is only about Perl 6

[16:18] <iblech> xinming: The point is, that slurpy hashes only slurp remaining pairs, i.e. only pairs which were *not* already consumed by naming other positionals

[16:18] <iblech> I.e. sub foo (*%hash, *@rest) -- %hash always gets all pairs

[16:19] <iblech> sub foo ($x, *%hash, *@rest) -- foo(bar => "baz") -- %hash gets (bar => "baz")

[16:19] <iblech> sub foo ($x, *%hash, *@rest) -- foo(x => "baz") -- %hash gets (), $x gets "baz"

[16:24] <xinming> iblech: hmm, Ok, I think your right. So, will there be a "shadow-copy" of x => "baz" in %hash?

[16:25] <iblech> xinming: luqui wasn't sure

[16:25] <iblech> xinming: But currently, not

[16:26] <xinming> iblech: :-) I think If we need to explicit specify the pair to hash, we could use a keyword to explicitly specify it.

[16:26] <xinming> iblech: I would change the test later. :-)

[16:26] * jql goes even farther off the deep end... foo("baz") should imply %hash<x> eq 'baz'

[16:27] <jql> positionals should just default the key-name, IMO

[16:27] <iblech> xinming: Or we could simply use sub foo (*%hash), which will unconditionally slurp all pairs

[16:28] <xinming> iblech: hmm, But that lack the flexibily of foo "bar", "this", ( x => 'y' )

[16:30] <xinming> why @Larry made spcify the *%hash might because of, Some of the arguments might not be needed, And the optional 'named-param' can't handle all the situation.

[16:30] <xinming> hmm, That's just my opinion. :-)

[16:30] <iblech> Right, then you'd have to use sub foo (*%hash, *@rest)

[16:31] <xinming> iblech: The problem also exist, *@rest can't do "type-checking" :-)

[16:31] <xinming> s/exist/exists/

[16:32] <xinming> eg: sub foo ( Str $str, *%h ) { ... }, If you use @rest, Then, The first param can be every thing.

[16:32] <iblech> Right. In this case, simply don't use *@rest :)

[16:33] <iblech> I.e., sub foo ( Str $str, *%h ) { ... } is perfectly fine

[16:33] <xinming> hmm, I think, sub foo( [Type $var, ... *@rest ], *%hash ); might help.

[16:33] <iblech> oh, right! :)

[16:34] <xinming> iblech: well, these example doesn't cover all the cases. And @Larry wish to cover them all, to obey m0tto, "TMTOWTDIT" :-)

[16:34] <xinming> seen autrijus 

[16:34] <jabbot> xinming: autrijus was seen 1 days 13 hours 20 seconds ago

[16:34] <xinming> hmm, Where did autrijus go?

[16:35] * xinming is missing him...

[16:36] <iblech> xinming: Right, TIMTOWTDI++ :)

[16:36] <iblech> He's deep into $work, I think

[16:36] <iblech> deadline, etc.

[16:36] * xinming hopes he can be more helpful in the future.

[16:40] <fglock> iblech: I'm reading PIL2JS - trying to see if we can unify some code

[16:43] <iblech> fglock: ooh (unifying code)++

[16:43] <iblech> fglock: Especially lib6/Prelude/JS/ControlFlow.pm could probably share some code with PIL-Run

[16:44] <iblech> E.g. map, for, while, until, etc. all use loop

[16:44] <fglock> why is it written in p5 (not p6)?

[16:44] <iblech> It is written in P6 :)

[16:45] <iblech> With some JS code, of course

[16:46] <fglock> I mean, the main program, not the library

[16:47] <iblech> ah.

[16:47] <iblech> Speed, I think

[16:50] * fglock goes away for a while

[16:55] <xinming> ?eval ( a => 'abc', b => 'xyz' ).key

[16:55] <evalbotzy> ('a', 'abc') 

[16:56] <xinming> ?eval ( a => 'abc', b => 'xyz' ).keys

[16:56] <evalbotzy> (0, 1) 

[16:56] <xinming> hmm... :-)

[16:56] <iblech> http://m19s28.vlinux.de/iblech/stuff/not_perm/pil2js-demo/t/smoke.html # New PIL2JS smoke, 65.59% ok, ~~40min

[16:57] <iblech> Hm, seems to be a bug

[16:57] <xinming> ?eval ( a => 'abc', b => 'xyz', c => 'ddd' ).keys

[16:57] <evalbotzy> (0, 1, 2) 

[16:57] <iblech> (the first one)

[16:57] <iblech> ?eval (a => "abc").key  # should give "a"

[16:57] <evalbotzy> 'a' 

[16:57] <iblech> ?eval (a => "abc", bar => "baz").key  # should be an error

[16:57] <evalbotzy> ('a', 'abc') 

[16:57] <iblech> as (a => "abc", bar => "baz") is not a Pair

[16:57] <iblech> food &

[16:58] <xinming> ?eval { a => 'abc', b => 'xyz', c => 'ddd' }.values

[16:58] <evalbotzy> ('abc', 'xyz', 'ddd') 

[16:58] <xinming> ?eval { a => 'abc', b => 'xyz', c => 'ddd' }.keys

[16:58] <evalbotzy> ('a', 'b', 'c') 

[17:06] <ods15> hi nothingmuch 

[17:06] <ods15> nothingmuch: do you use your laptop as your main box?

[17:07] <nothingmuch> i have two "main boxes" in this sense

[17:07] <nothingmuch> the laptop does everything PCish: text editing, movie viewing, browsing

[17:07] <ods15> ircing?

[17:07] <nothingmuch> and I also have pasta, which is headless... it does apache, postfix, dhcp, dns, routing, etc

[17:07] <nothingmuch> irc is on the laptop

[17:08] <nothingmuch> i tried irc in screen on pasta for a while

[17:08] <nothingmuch> but then I realized that I don't really need to be available 24/7 through backlogs

[17:08] <nothingmuch> I do read my email on pasta, via mutt inside screen

[17:08] <nothingmuch> muttng actually

[17:08] <nothingmuch> but that is the only regular use for pasta that isn't implicit

[17:09] <ods15> muttng?

[17:09] <nothingmuch> mutt + many patches (maildir header caching, side bar, nntp, pgp password forgetter, and more and more and more)

[17:10] <nothingmuch> iblechbot: :comparator is trivial, read mail

[17:10] <wolverian> I use muttng just for the caching :)

[17:10] <nothingmuch> it's wonderful

[17:10] <wolverian> yes.

[17:10] <nothingmuch> i switched to reiserfs when i made the move towards LVM + software raid

[17:10] <nothingmuch> so that I could have online resizing of partitions

[17:11] <wolverian> online?

[17:11] <nothingmuch> so old mutt became unbearably slow (maildirs + reiser + nocaching)

[17:11] <nothingmuch> wolverian: no unmount

[17:11] <nothingmuch> you can only grow though

[17:11] <wolverian> hm. I thought rfs is supposed to be fast in a scenario like that?

[17:11] <nothingmuch> i thought so too, but it's not fast, it's just size efficient, i guess

[17:11] <nothingmuch> i have notail now

[17:12] <nothingmuch> maybe I should copy my maildir and swap

[17:12] <nothingmuch> anyway, muttng and screen were very good optimizations

[17:12] <ods15> caching?

[17:12] <ods15> as in, when you open a really big maildir?

[17:12] <nothingmuch> ods15: instead of reading each maildir file it keeps an index of the headers

[17:12] *** Maddingue__ is now known as Maddingue

[17:12] <nothingmuch> each message file in a maildir, that is

[17:13] <ods15> doesn't mutt already support this?

[17:13] <nothingmuch> yes, but with a patch that isn't in mainline

[17:13] <ods15> header_cache Type: path Default: ""

[17:13] <ods15> The  header_cache  variable  points  to the header cache database.  If header_cache points to a directory it will contain a  header  cache  database   per  folder.  If header_cache  points  to  a file that file will be a single global header cache. By default it is unset and so no header caching will be used.

[17:13] <ods15> thats from man muttrc, and afaik i'm using regular mutt

[17:13] <nothingmuch> ods15: it may be your distro being nice to you

[17:14] <ods15> 20:13) ods15@linux15:~ $ mutt -v

[17:14] <ods15> Mutt 1.5.9i (2005-03-13)

[17:14] <ods15> no sidebar that i know of btw

[17:15] <wolverian> hmm. I have that too. odd.

[17:15] <nothingmuch> the sidebar is actually quite nice, b ut I dont really use it

[17:15] <nothingmuch> wolverian: that's in muttng

[17:15] <wolverian> it might have come with 1.5.9i, I guess.

[17:15] <wolverian> nothingmuch, I have that in man muttrc

[17:15] <nothingmuch> oh

[17:15] <wolverian> (debian sid)

[17:15] <nothingmuch> the headercache, not the sidebar

[17:15] <wolverian> right.

[17:16] <nothingmuch> i used mutt + headercache for a long time though, and i think muttng felt faster

[17:16] <ods15> whats the sidebar

[17:16] <wolverian> I'll try it.

[17:16] <nothingmuch> so I think it caches on another level

[17:16] <ods15> folder list?

[17:16] <nothingmuch> ods15: a mailbox list on the side

[17:16] <nothingmuch> that shows you counts

[17:16] <ods15> ah, one of the things i'm MOST missing in mutt

[17:16] <ods15> but tbh doesn't sound "quite" right in console

[17:16] <nothingmuch> tbh?

[17:16] <ods15> even with high res framebuffer, console isn't THAT big that you can stuff a sidebar too :/

[17:16] <ods15> to be honest

[17:17] <nothingmuch> ods15: you toggle it

[17:17] <nothingmuch> default binding to toggle is 'b'

[17:17] <ods15> hmm

[17:17] <wolverian> ah. mutt doesn't have header_cache_compress

[17:17] <ods15> btw, is there any SIMPLE mime command line tool?

[17:17] <wolverian> not that that should affect speed, at least negatively...

[17:17] <ods15> and btw, how d you deal with hebrew in mutt?

[17:18] <nothingmuch> ods15: i don't deal with hebrew too well

[17:18] <nothingmuch> the terminal is utf-8, which is Good Enough™

[17:18] <nothingmuch> but i don't write mail

[17:18] <nothingmuch> in theory it's possible, with vim supporting it

[17:18] <ods15> i don't deal with it at all.. if it's something i REALLY want to read, i open it with kmail

[17:18] * justathe1ry removes it

[17:18] <justathe1ry> I'm an Emacs guy, after all.

[17:18] *** justathe1ry is now known as justatheory

[17:19] <ods15> i find the emacs/vim war extremely funny, because i personally think both suck :P

[17:19] <ods15> i REALLY like nano

[17:19] <xinming> justatheory: So am I, :-) I love Emacs really...

[17:19] <ods15> seriously

[17:19] <ods15> anyway, nothingmuch , you can READ hebrew mails in mutt though?

[17:19] <justatheory> I don't love Emacs, but I do love cperl-mode. :-)

[17:19] <nothingmuch> ods15: nano is decent because it's simple, and all the commands are displayed on the screen, so you don't even need to find out what command brings up help

[17:20] <nothingmuch> but for anything more it's... eh...

[17:20] <ods15> nothingmuch: i use for C coding, perl coding, bash scripting, mail editor, etc. etc.

[17:20] <nothingmuch> no quantification, no pattern matching, no complex regular expressions, no pipes...

[17:20] <xinming> ods15: hmm, But I don't think Vi is a poor Editor, Why I don't like Vim is because, For long time programming, If I am in Vim, The left hand (arm) won't feel so good.

[17:20] <nothingmuch> I can read most hebrew mails

[17:20] <ods15> i have syntax highlighting, copy paste of entire lines or selected region, etc. etc.

[17:20] <nothingmuch> xinming: tried ctrl + bracket?

[17:21] <ods15> nothingmuch: you lost me with all you said regarding pipes etc.

[17:21] <ods15> if i need to do some kind of 'generic' editing to a file, i do in bash, no an editor.. that's insane

[17:21] <nothingmuch> ods15: how easy is it to pipe your buffer through 'expand' for example, if you're editing ingy's code?

[17:21] <ods15> expand? ingy?

[17:21] <ods15> oh, ingy is a person

[17:21] <nothingmuch> ingy doesn't use tabs, I do

[17:21] <ods15> expand is "indent"?

[17:22] <nothingmuch> expand is s/\t/    /;

[17:22] <nothingmuch> buut smarter

[17:22] <xinming> nothingmuch: How do you konw my problem? -)

[17:22] <ods15> i've never seen a need for that...

[17:22] <nothingmuch> ofcourse, this is permanently fixable by saying '# vim:set expandtab:' or whatever the syntax is

[17:22] <nothingmuch> ods15: do you edit other people's code?

[17:22] <ods15> if i do need such a thing, i do:  c bla.pl P 's/\t/  /' > bla2.pl      nano bla2.pl

[17:23] <nothingmuch> WTF?!

[17:23] <nothingmuch> use expand -4

[17:23] <ods15> i've never even friggin heard of expand

[17:23] <ods15> i've never expanded tabs

[17:23] <nothingmuch> x\ty is not x    y it's x   y

[17:23] <xinming> nothingmuch: In fact, I would prefer Emacs to reindent the code.  C-M-h C-M-/ :-)

[17:23] <nothingmuch> ods15: that's not my fault

[17:23] <ods15> that was just an example

[17:23] <ods15> i've never done such a thing or wanted to do such a thing

[17:24] <ods15> i wasn't complaining about not knowing expand :) because i've never had a use for it

[17:24] <nothingmuch> and btw, ods15 if yhou're doing bla.pl and bla2.pl

[17:24] <ods15> in MPlayer, tab expansion is illegal anyway

[17:24] <nothingmuch> you might as well do `perl -pi -e's/\t/    /' bla.pl'

[17:24] <ods15> (you can't send patches which change indentation)

[17:24] <ods15> nothingmuch: yes i know, but i already have the aliases..

[17:24] <nothingmuch> ods15: in ingy code tabs are illegal

[17:24] <nothingmuch> (you can't send patches which change indentation)

[17:24] <ods15> i really should make a 'perl -pi.bak -e' alias...

[17:25] <ods15> need a name for it.. 'P' is taken.. 'p' maybe?

[17:25] <nothingmuch> pi

[17:25] <ods15> hmm, yes, 'p' good enough

[17:25] * nothingmuch added a short alias today

[17:26] <nothingmuch> i have a sogudi alias 'pd' that is 'http://search.cpan.org/perldoc?@@@'

[17:26] <ods15> heh

[17:26] <nothingmuch> so when I started typing 'pd' in the command line for already installed modules I realized I need an alias

[17:26] <obra> sogudi?

[17:26] <nothingmuch> obra: a safari hack

[17:27] <nothingmuch> you type into the URL bar 'pd Some::Module'

[17:27] <nothingmuch> and it takes the string on the right and substitutes for the '@@@'

[17:27] <ods15> heh i've never used url aliases

[17:27] <obra> ah. *nod*

[17:27] <nothingmuch> very convenient, except you can no longer type spaces in URLs and have safari replace them with %20

[17:27] <nothingmuch> obra: I have wikipedia, regular cpan search, cpan perldoc, c2.com

[17:28] <obra> *nod* I tend to work from the cli, not a browser

[17:28] <ods15> btw what's your browser nothingmuch 

[17:28] <nothingmuch> oh, and recently 's 06' etc for synopses 

[17:28] <obra> I need to get a quicksilverish microterminal.

[17:28] <nothingmuch> ods15: safari which isa konqueror

[17:28] <ods15> mine is 50:50 between elinks and firefox

[17:28] <nothingmuch> obra: me too, but for things that aren't installed I use the browser

[17:29] <nothingmuch> as for quicksilver, I think it complements the terminal

[17:29] <nothingmuch> http://www.atamadison.com/w/kitzkikz.php?page=Sogudi

[17:29] <ods15> nothingmuch: anyway, nano is surprisngly more powerful than most people think

[17:29] <nothingmuch> ods15: i know nano is not like pico

[17:29] <obra> nothingmuch: I'm not on a mac ;)

[17:29] <nothingmuch> but it's not a full blown editor either

[17:29] <nothingmuch> obra: for some reason I thought you were... hmm

[17:29] <ods15> wtf is a "full blown editor"

[17:29] * nothingmuch tries to remember

[17:30] <nothingmuch> ods15: one with at least one embedded language

[17:30] <nothingmuch> ods15: which can autoindent smartly

[17:30] <ods15> heh?

[17:30] <nothingmuch> and nest syntax highlighting modes

[17:30] <ods15> autindent is crap, all you need is keeping previous line's indent

[17:30] <nothingmuch> ods15: not when you're writing bullets in email instead of code

[17:30] <ods15> nano has syntax highlights, and i wrote pretty nice regexes for it for C and Perl

[17:31] <nothingmuch> regexes for perl? EEK

[17:31] <xinming> hmm, for a newbie, I really don't know why don't you choose Emacs, :-P for it is slowly?

[17:31] <nothingmuch> you can't really write a *GRAMMAR* for perl

[17:31] <ods15> yes.. they are no failsafe (mostly with # inside strings), but they work pretty damn well

[17:31] <obra> nothingmuch: I used to use a mac. I got better :)

[17:31] <obra> or rather, I got a laptop that suits me better. my desktop is still a mac

[17:31] <nothingmuch> obra: congrats.. I'm still too lazy and happy with macs =)

[17:31] <nothingmuch> did you see the mac I bought at YAPC?

[17:32] <obra> The thing that sold me was the Toshiba R100. 

[17:32] <obra> nothingmuch: no. what is?

[17:32] <nothingmuch> PB 17"

[17:32] <ods15> my only 2 pet peeves with nano is bad pasting (if i forget auto-indent is goes wild), and it has some weird mem leak or something that causes it to slow to a crawl if you use it for a long while with syntax highlighting

[17:32] <obra> The R100 weighs 2 pounds. but is a real laptop.

[17:32] <ods15> other than that i love it

[17:32] <nothingmuch> ods15: ah, the opposite of what I was searching for =)

[17:32] <nothingmuch> i needed a desktop computer I could take to work

[17:33] <ods15> nothingmuch: btw, know the hebrew song 'kawaka'?

[17:33] <ods15> nothingmuch: ?

[17:33] <ods15> desktop what huh

[17:33] <nothingmuch> uh, haven't heard of it

[17:33] <ods15> hold on

[17:33] <obra> nothingmuch: I travel too much ;)

[17:33] <ods15> http://www.supersite.co.il/manzur/kawakafliz.mp3

[17:33] <ods15> friggin hilarious song, dl it :)

[17:34] <nothingmuch> ods15: i don't understand it

[17:35] <nothingmuch> only a few words

[17:35] <nothingmuch> oh wait, the verse isn't as bad

[17:35] <xinming> ?eval sub fun { ... }; fun();

[17:35] <evalbotzy> *** ... - not yet implemented     at <eval> line 1, column 11-15 

[17:35] <xinming> ?eval sub fun { ; }; fun();

[17:35] <evalbotzy> undef 

[17:35] <xinming> hmm, So what are the differences please?

[17:36] <nothingmuch> xinming: ... is an error under 'use fatal'

[17:36] <nothingmuch> and it also says "not yet implemented"

[17:36] <xinming> nothingmuch: Ok, thanks, just for "visual" effect. :-)

[17:36] <nothingmuch> xinming: not only that, it 

[17:36] <nothingmuch> bah

[17:37] <nothingmuch> it really means 'undef but error "not yet implemented"

[17:37] <nothingmuch> so if it propagates upwards, i think it should be collected in the error stack for any errors happenning because of it

[17:37] <ods15> nothingmuch: listen to the words, the "punchlines" are always completely clear... :)

[17:37] <nothingmuch> ods15: it was... OK, i guess

[17:37] <xinming> :-)

[17:37] <ods15> nothingmuch: http://mp3music.gpg.nrg.co.il/lyrics/9881.html

[17:37] <nothingmuch> not really hilarious

[17:38] <ods15> bleh :)

[17:40] <nothingmuch> oh wait, if I remove the 'default' sogudi thing then I can type spaces again... Woohoo!

[17:43] <ods15> nothingmuch: so could you explain to me the tab thing?

[17:43] <nothingmuch> ods15: tab thing?

[17:43] <ods15> why on earth would you want such a thing

[17:43] <nothingmuch> i use tabs

[17:43] <nothingmuch> ingy uses spaces

[17:44] <ods15> oh, i just remembered what else i syntax highlight, .patch :)  and mail ofcourse (starts with '> ')

[17:44] <nothingmuch> if I edited code and forgot to :set expandtab

[17:44] <nothingmuch> then I pipe to 'expand -4'

[17:45] <ods15> :set expandtab does what

[17:46] <nothingmuch> it means that every time I type a tab, or it autoindents, it'll be with spaces

[17:46] <nothingmuch> but other tabs in the file are not replace

[17:46] <nothingmuch> d

[17:46] <ods15> wait, if you forgot to set it, other tabs are replaced?

[17:47] <nothingmuch> ods15: no, if I set it after a while, then other tabs are still tabs

[17:47] <nothingmuch> and it's only new tabs

[17:47] <nothingmuch> also, another feature I bet nano doesn't have is hints to the editor placed in comments

[17:48] <ods15> explain?

[17:48] <nothingmuch> for haskell I do use spaces instead of tabs

[17:48] <nothingmuch> it just works out bettetr

[17:48] <nothingmuch> so I have {- vim:set expandtab: -}

[17:48] <nothingmuch> in the top of the file

[17:49] <nothingmuch> {- -} is haskell for "block comments"

[17:49] <ods15> i don't think i've really ever piped code through a program.. i have pipes data through scripts to make em generate code though, but rarely anything else

[17:49] <ods15> ok

[17:49] <ods15> ah, i got what you meant

[17:49] <ods15> no, it doesn't have that

[17:50] <ods15> there aren't that many options so you really don't need such a thing

[17:50] <nothingmuch> ods15: also, sometimes when I'm editing xSV files I want to stay in my editor to see the tabulated data properly, but use "real men" commands to edit them, like awk or perl

[17:50] <ods15> nano's "auto-indent" is straightforward - whatever whitespace was in the begginning of the line, is repeated when you press enter...

[17:51] <nothingmuch> anyway, I've got to get back to house work

[17:51] <ods15> i've never really used awk :)

[17:51] <ods15> ok bye

[17:51] <nothingmuch> ciao!

[17:51] <ods15> heh

[18:00] <geoffb> Limbic_Region, you tried to reach me a couple days ago, and I've been just missing you ever since (like sitting down at keyboard a minute after you quit, sheesh).  What did you need me for?

[18:02] <xinming> ?eval sub foo is rw { state $var }; foo = 1; 

[18:02] <evalbotzy> Error: Can't use readline() or getc() in safemode. 

[18:02] <xinming> ?eval sub foo is rw { state $var }; foo() = 1; 

[18:02] <evalbotzy> \1 

[18:02] <xinming> ?eval sub foo is rw { state $var }; foo() = 1; foo.say;

[18:02] <evalbotzy>  \1 

[18:05] <xinming> ?eval sub foo is rw { state $var }; foo() = 1; foo().say;

[18:05] <evalbotzy> 1 bool::true 

[18:09] <nothingmuch> heh, larry appearantly forgot that I'm "nothingmuch", and that I lobbied for lazy { } in the first place ;-)

[18:10] <geoffb> Hey iblech, how is the JS backend coming?

[18:11] <iblech> nothingmuch: Seems your lazy proposal is accepted :)

[18:11] <nothingmuch> yep =D

[18:11] <nothingmuch> hurrah, dancing, whatnot

[18:11] <iblech> geoffb: Great, 65%, latest smoke is at http://m19s28.vlinux.de/iblech/stuff/not_perm/pil2js-demo/t/smoke.html

[18:11] <geoffb> iblech: do you have a blog I can just follow?

[18:11] <geoffb> iblech, schweet

[18:11] <iblech> No, no blog

[18:12] <geoffb> What's the best way to follow PIL2JS work, other than bugging you?  Do diffs on the README?

[18:13] <iblech> Bugging me is fine :)

[18:14] <geoffb> OK then: how is MM integration coming?

[18:14] <iblech> And yes, I try to keep README in sync with the code

[18:14] <geoffb> iblech++ # Keeping docs updated

[18:14] <iblech> Everything I could integrate is integrated -- but that's only methods.

[18:14] <geoffb> Why not other stuff?

[18:14] <iblech> Waiting for -PIL2 so PIL2JS gets class declarations etc.

[18:14] <geoffb> AH!

[18:15] <geoffb> OK, that answers the next question about the status of PIL2 -- I take it autrijus's $work has delayed that?

[18:15] <iblech> (Currently, even small things like class Foo { has $.x } do not compile to PIL, so PIL2JS can't do anything.)

[18:15] <iblech> Yep, he has deadlines etc. as far as I know

[18:16] <geoffb> bleah, suckage

[18:16] <geoffb> .oO( What that boy needs is a MacArthur (sp?) award)

[18:18] <xinming> iblech: could you please reveal some information about the deadline?

[18:19] <iblech> xinming: I dunno, all I know is from autrijus' journal (http://use.perl.org/~autrijus/journal): "It is tomorrow now and I'm still neck deep in this $work deadline thing"

[18:20] <geoffb> Who's working on the P5 backend these days?

[18:21] <nothingmuch> geoffb: fglock stevan and putter IIRC

[18:21] <nothingmuch> i pretend to do it ;-)

[18:21] <fglock> what kind of information 'want' returns - is it a type or class?

[18:21] <geoffb> iblech, is the failing 35% mostly because of lack of PIL2 and therefore full P6 OO?

[18:21] <nothingmuch> fglock: i think 'want' returns an object which yuou can ask questions

[18:21] <nothingmuch> and the object is a Context, i presume

[18:22] <nothingmuch> and maybe you can say Context::Scalar.new.enforce(&code);

[18:22] <nothingmuch> that could be fun 

[18:22] <ods15> bleh

[18:22] <nothingmuch> but either way, it stringifies

[18:22] <nothingmuch> and has the notation of arity

[18:22] <ods15> firefox is taking 200mb of ram :(

[18:22] <nothingmuch> (how many items you want from a list)

[18:22] <iblech> fglock: nothingmuch's correct, and there're test for it in t/builtins/want.t

[18:22] <nothingmuch> and laziness, too, i think

[18:22] <ods15>              total       used       free     shared    buffers     cached

[18:22] <ods15> Mem:        515500     511812       3688          0       5552     125320

[18:22] <ods15> -/+ buffers/cache:     380940     134560

[18:22] <ods15> Swap:       787148     393572     393576

[18:22] <ods15> i have a total of 750mb of "ram" used...

[18:23] <ods15> heh more actually

[18:23] <nothingmuch> ods15: want to do some porting? there was a patch to linux 2.2 that scanned processes after they forked

[18:23] <nothingmuch> it remerges identical but spoiled pages

[18:23] <ods15> scanned how

[18:23] <nothingmuch> so that they are read only again

[18:23] <geoffb> any(< nothingmuch fglock stevan putter ): what is the current status of the P5 backend?  Pointer to appropriate place is OK, I'm updating STATUS right now.

[18:23] <nothingmuch> and shared

[18:23] <iblech> geoffb: The main missing parts are OO and packages, P5 and P6 regexes, temp/state/let vars, and some missing builtins

[18:23] <nothingmuch> geoffb: I only pretend to know ;-)

[18:23] <ods15> what are you talking about

[18:23] <ods15> and i know nothing of kernel programming

[18:24] <nothingmuch> ods15: say you launched two firefox processes

[18:24] <nothingmuch> it would scan them (eventually, i think it's an idle time loop)

[18:24] <nothingmuch> and compare identical memory pages

[18:24] <ods15> firefox is stupid and doesn't allow multiple instances, but ok, go on

[18:24] <nothingmuch> when it finds pages that are the same, it will merge them

[18:24] <nothingmuch> so that they are read only, and shared

[18:24] <ods15> that's somewhat dangerous and mostly not worth it

[18:24] <nothingmuch> dangerous?

[18:25] <iblech> geoffb: OO and packages needs PIL2 support, P5 would be relatively simple (because JavaScript has a Regex class), ask putter for P6 regexes :), temp/state/let vars needs a little bit of work on -CPIL/-CPerl5 and then some work on the PIL2JS side

[18:25] <ods15> unless it does it safely.. copy on write...

[18:25] <ods15> it's not worth it though

[18:25] <nothingmuch> ods15: ofcourse it does copy on write

[18:25] <fglock> geoffb - stevan is working on the metamodel-2; putter is improving PIL-RUN; I'm working on the implementation of base classes

[18:25] <nothingmuch> and it's very worth it if similar processes are starting up the same way

[18:25] <geoffb> (nothingmuch: interestingly, at least one virtualization product (VMware ESX) does this across VMs, which I find quite cool.  I wonder if the Xen guys do it)

[18:25] <ods15> brk hardly ever has common data, stack is tiny, and code is shared anyway by linux kernel

[18:25] <nothingmuch> geoffb: i like virtualizations... they have many cool features

[18:26] <nothingmuch> like a cache of translated code pages, and whatnot

[18:26] <geoffb> virtualization++

[18:26] <nothingmuch> ods15: if brk has common data due to malloccing of the same stuff

[18:26] <nothingmuch> like common initialization

[18:26] <nothingmuch> especially if these are aligned to arenas

[18:27] <nothingmuch> (a new window has a new javascript interpreter, for example)

[18:27] <ods15> firefox is mem leaking anyway, it should not be taking 200mb of ram

[18:27] <ods15> (and 320mb of swap...)

[18:27] <nothingmuch> ods15: another option is to poke in the "heavy" config params

[18:27] <geoffb> fglock, happen to how is PIL-RUN coming, since putter appears offline?  Passing any of test suite?

[18:27] <nothingmuch> it might cache history pages in memory

[18:27] <nothingmuch> safari does that so that the back button is almost instantenous

[18:28] <nothingmuch> the prev page is completely parsed, all it has to do is draw

[18:28] <ods15> yes, i did find some option.. "browser.cache.memory.enable"

[18:28] <nothingmuch> well, back to chores

[18:28] <ods15> but i disblaed it now.. only way to check if it helped it restart firefox and wait again..

[18:28] <iblech> geoffb: IIRC, 01-sanity.t passes

[18:28] <ods15> still, 200 mb is extreme for it

[18:29] <iblech> geoffb: But there's no "make p5smoke" or so yet

[18:29] <geoffb> iblech, the whole dir?  Cool.

[18:29] <ods15> heh, that's funny, X is using 400mb of virtual :P

[18:29] <iblech> geoffb: No, only the first test.

[18:29] <geoffb> oh, 01-sanity/01-tap.t

[18:30] <iblech> geoffb: Right, meant that

[18:30] <iblech> geoffb: But let me look so we know for sure

[18:30] <iblech> geoffb: oooh even 03-equal.t passes! :)

[18:31] <ods15> anyway, i can probably free quite a bit of ram by just closing kdevelop and qt designer, not using em right now anyway

[18:31] <putter> hey guys.  hi geoffb.

[18:31] <fglock> hi putter

[18:31] <ods15> but come to think of it, why should i :) the whole point of having a lot of ram and swap is to use it.. (althought not ABUSE it, like firefox is doing...)

[18:32] <geoffb> iblech, heh:

[18:32] <geoffb> er, heh.

[18:32] <geoffb> putter, hey there

[18:32] <putter> hi fglock.   putter was rather hoping fglock was working on PIL-Run, and putter was just dabbling. ;)

[18:33] <ingy> BURN ALL TABS!

[18:33] <geoffb> iblech, when you say -CPIL/-CPerl5 are needed for temp/state/let -- are these PIL2 or PIL1?

[18:34] <iblech> geoffb: PIL1 is sufficient

[18:34] <iblech> geoffb: (Currently, let $foo = 3 is emitted as my $foo = 3)

[18:34] <iblech> geoffb: So that's a relatively simple change

[18:34] <putter> as I consider creating pirsmoke and perl5test and perl5smoke and ...  how about make test-pir test-js test-per5 smoke-pir smoke-js etc test-all smoke-all.  thoughts?  I expect we will have additional backends, and things are already getting crufty... no?

[18:34] <xinming> Just read the comment of autrijus' Journal, I sometimes wonder why will people like wish perl to "become" php. :-)

[18:35] <xinming> s/just/just now/

[18:35] <putter> pugs -BJS -e 'use php; ....php code...'

[18:36] <iblech> putter: I like that :) (But I don't mind them staying jssmoke, pirsmoke, etc.)

[18:36] <putter> iblech: any thoughts on jssmoke and jstest becoming somewhat depreciated?

[18:36] <putter> ok.  awsome.  will do.

[18:36] <iblech> putter++

[18:36] * putter wonders if there is a word for irc messages that cross in the writing...

[18:38] <mjl69> cross?

[18:39] <putter> two msgs written at the same, sent with seconds of each other.  each of which obsoletes the other.  if you could see the other person's keystrokes, it wouldnt happen...

[18:40] <putter> or a weaker form, one of which obsoletes the other.

[18:41] <mjl69> I remember years ago, we used to chat online and you would see keystrokes in real time.  backspacing was a talent.

[18:41] <geoffb> mmm, ytalk . . . .

[18:43] <fglock> would it take much coding to replace pugs 'List' implementation with a perl6 version?

[18:47] <putter> pugs ability to use p6 code is currently a bit limited.  Prelude.pm has issues, as does the type checker, and ... .  rules development is currently stopped waiting for something to improve just enough for regexs (Prelude rx_common_) to return a Rul.

[18:48] <putter> s/(currently stopped)/$1 (modulo pm's continuing work on pge etal)/

[18:49] <putter> iblech: jssmoke uses PUGS_RUNTIME rather than -BJS, any particular reason, or just historical artifact?

[18:49] <geoffb> putter, you were working on P6 rules implemented in P6, yes?

[18:49] <iblech> putter: PUGS_RUNTIME is a hack, -BJS is the way to go

[18:50] <putter> iblech: ok. thanks.

[18:50] <iblech> putter: PUGS_RUNTIME is only used to tell run-smoke to skip the ext/ tests and use a perl5/PIL2JS/pugs-smokejs.pl instead of ./pugs

[18:54] <putter> geoffb: I was working on all sorts of rules stuff.  on p5, on p6/pcre, on p6/native, etc.  except with p5, spent most of the time dealing with pugsbugs.  was too ambitious a project for the then/now state of pugs.  finally, switched to frontend-backward development approach.  get something in, improve it, allowing others to see and contribute.  after a lot of trying, failed to get something in.  well, have warnings about modifiers now. 

[18:54] <putter>  but cant return a Rul, means everthing else is stuck. :(

[18:56] <geoffb> putter, bleah

[18:58] <geoffb> putter, do you mean Rule, or is Rul a magic type?

[18:59] <putter> Rule is currently (against/un-spec) a role, with Rul intended to be the usual class doesing it.

[19:00] <geoffb> ah

[19:01] <geoffb> OK, pugs' memory requirements to build have gotten completely insane

[19:01] <putter> Rul is just a couple of lines.  infix:<~~> calls a sub.  oh, and will carry around a copy of the pattern and modifiers.

[19:02] <putter> optimized?

[19:03] * putter still feels guilty about the rx rules hook in Prelude.  its a non-trivial fraction of Prelude, and Prelude is a bit painful to compile, and the hook isnt buying much at the moment.  I have a "rip out hook" patch just incase we need it for a release...

[19:04] <Juerd> iblech: No, there was no discussion about *changing* map to repetition

[19:04] <Juerd> iblech: Map on a range, and then using none of the numbers in the range, is misuse of a range and of map.

[19:05] <iblech> Juerd: Right, I s// my wording (unless I forgot it)

[19:05] <putter> iblech: does PIL2JS/pugs-smokejs.pl suggest we need a pugs wrapper script, say p5, which deals with these kinds of things, to insulate pugs?  or is that not worth it...

[19:05] <iblech> Juerd: I agree with you completely

[19:05] <Juerd> iblech: This also means that, contrary to what some people have been requesting with the XX, there should be no easily accessible standard counter variable

[19:06] <Juerd> For when you do need the number, you should use map.

[19:06] <geoffb> putter: *un* optimized (sorry for delay, this box is thrashing its brains out)

[19:06] <iblech> putter: Hm. runjs.pl (which is a thin wrapper around pugs -CPerl5 and pil2js.pl) is theoretically sufficient. The only problem is that runjs.pl doesn't stop pugs from compiling Test.pm.

[19:07] <iblech> putter: Therefore pugs-smokejs.pl applies this evil hack (s/use Test//)

[19:07] <iblech> putter: If we had a cleaner way to say pugs "trust me, I've precompiled that module to JS, don't load it", we wouldn't need pugs-smokejs.pl

[19:07] <iblech> Juerd: Right.

[19:08] <putter> -m (the case inverse of -M;)?

[19:09] <iblech> putter: I pondered a TrustMeTestPMIsAlreadyLoaded.pm, which'd only contain "%*INC<Test.pm>++", and then using pugs -MTrustMeTest... -CPerl5 ..., but unfortunately, pugs' option parser doesn't like that

[19:10] <geoffb> Why not just a flag that specifies which modules (generically) have been preloaded?

[19:11] <geoffb> Given the thrashing on this system, I can't look for a free flag letter ATM :-)

[19:12] <iblech> This would work too, and is cleaner, I think, so I like it :)

[19:12] <fglock> Juerd: isn't lazyness going to fix this? (sorry maybe I don't know what the problem is exactly)

[19:12] <Juerd> fglock: Oh, Perl 6 will have this operator one way or another, I'm sure.

[19:12] <Juerd> If not in the standard language, then in the standard dialect.

[19:13] <PerlJam> Juerd: and if not there, then in your own personal dialect :)

[19:13] <Juerd> PerlJam: That is the standard dialect.

[19:14] <Juerd> I plan perlego, that has stuff that didn't make it to the base language, but adds value without breaking existing code.

[19:14] <Juerd> This can be read as the esperanto word perlego (perl-eg-o, the noun meaning: a greater pearl), or as per-lego (adding building blocks) or as perl-ego (MINE!)

[19:15] <geoffb> nice, Juerd

[19:16] <geoffb> bah, have to boot yet more systems

[19:16] <Juerd> So far, my perlego document that I have been maintaining has had all its original items removed because they got implemented somehow in the base design.

[19:16] <Juerd> This strengthens my belief that my ideas aren't that stupid :)

[19:16] * geoffb feels the temperature in his office climb a couple more degrees (again)

[19:16] <Juerd> If only I used a versioning system for it, then I'd know exactly which they are

[19:19] <PerlJam> Juerd: Those weren't your ideas.  You just imagine that you had some really great ideas that were then implemented only it's that they were implemented and then you thought of them.   (hint: get a versioning system :)

[19:21] <Juerd> Oh, that's perfectly possible :)

[19:22] <PerlJam> I'm still quite ... shocked?  surprised?  in disbelief?  over all the ./ hoopla

[19:23] <geoffb> sheesh, is that *still* going on?

[19:23] <svnbot6> r6421 | iblech++ | * t/subroutines/slurpy_param.t: unSKIP as luqui confirmed my thoughts.

[19:23] <svnbot6> r6421 | iblech++ | * t/unspecced/lazy.t: Added three more tests to it and added a pointer to

[19:23] <svnbot6> r6421 | iblech++ |   Larry's p6l post which implicitly accepted nothingmuch++'s lazy {...}

[19:23] <svnbot6> r6421 | iblech++ |   proposal.

[19:23] <svnbot6> r6422 | iblech++ | Moved t/unspecced/lazy.t to t/var/lazy.t, as nothingmuch's proposal has been accepted.

[19:23] <Juerd> I kind of stopped following all Perl 6 developments because of that.

[19:23] <Juerd> I usually abandon ships with drunken captains

[19:24] <PerlJam> geoffb: no, no one has mentioned it on-list in a while, but I bet if you did, it would start all over again.

[19:24] <xinming> luqui: are you there please?

[19:24] <Juerd> It'll get better

[19:24] <xinming> oops, hmm,

[19:24] <Juerd> But I think all Larry's done is disappoint people and make them less ethusiastic

[19:24] <geoffb> oh holy crap, this newly-booted box hasn't been updated in a while -- 233 packages to update, according to apt

[19:25] * putter notes Juerd is always gloomy about @Larry and p6 design decisions...

[19:25] <Juerd> Oh, not always

[19:26] <Juerd> Let it be and stay clear that the majority of the design decisions together make a really great language that I'm looking forward to use 

[19:27] <putter> ah

[19:28] <putter> is there a pattern to the kinds of things you disagree with?

[19:28] <Juerd> Yes, they are all syntax.

[19:28] <Juerd> My primary concern is with syntax, in any case.

[19:29] <Juerd> Some very nice features can be implemented with operators that are new, but don't require any learning

[19:30] <Juerd> The best example I can give for that is <->. When used in the position where we now use ->, there can be no doubt in any intelligent lifeform's mind that it is closely related to -> itself.

[19:30] <Juerd> It doesn't live in one's brain as "another way to create a sub". -> and <-> are the same operator, except that <-> implies "is rw" for all parameters

[19:31] <Juerd> And there are really many occasions where "is rw" on multpile parameters is the best solution

[19:32] <xinming> Juerd: I think <-> will confuse newbie with <=> ...

[19:32] <Juerd> It'd suck to ever have to write "for @foo -> $foo is rw, $bar is rw, $baz is rw, $quux is rw { ... }" if we could have "for @foo <-> $foo, $bar, $baz, $quux { ... }" at absolutely no cost.

[19:32] <xinming> Juerd: They are too smimilar.

[19:32] <Juerd> xinming: I think newbie should commit suicide if that's a problem.

[19:32] <Juerd> We already have -> and => which are radically different and in no way related.

[19:32] <putter> (that was putter's first thought, what is <->?  a variant on <=>?)

[19:33] <putter> (no doubt clearer in context)

[19:33] <PerlJam> Juerd:  for @foo -> ($foo,$bar,$baz,$quux) is rw { ... }    #  :-)

[19:33] <Juerd> <-> by itself is unclear. But when used in context, I have yet to encounter one species that has no clue what it means while knowing Perl 6's -> operator.

[19:33] <xinming> Juerd: well, In fact, => is looks like a key point the "value"

[19:33] <xinming> Juerd: and -> should make people think for a little while,

[19:35] <putter> what portion of the syntax concerns are foward compatible? (eg, define op foo)  not, but parse? (eg, redefine ==)  and require fiddling with the parser rules? (??)

[19:35] <xinming> Juerd: maybe suggest @Larry consider my ($a, $b, $c, $d) is rw...

[19:35] <Juerd> xinming: I think you're missing the point

[19:35] <PerlJam> xinming: I think he'd rather have $Larry consider <-> instead

[19:36] <Juerd> xinming: The point is not that there should be a way to do it. The point is that there should be the *obvious* way to do it.

[19:36] <Juerd> This particular example has an appendix

[19:36] <xinming> for @foo -> ($foo, $bar, $baz, $quux) is rw { ... }

[19:36] <xinming> Juerd: I don't, I think This might be clear to me... :-)

[19:36] <Juerd> The default is now "-> $_ is rw", which is a pattern seen nowhere else: a trait added by default, but no longer when you specify a variable.

[19:37] <PerlJam> Juerd: yeah, that is a bit odd.

[19:37] <Juerd> This asymmetry can easily be broken by simply saying that the default operator is <->, instead of ->. The effect and hopefully bytecode of which are equal, but this being a much easier way to live with the situation consistency wise.

[19:38] <PerlJam> But I figure that Larry is trying to unhobble the hobgoblin of foolish consistency where ever he can.  Sure he makes mistakes, but in the long run, he gets most things right.

[19:38] <Juerd> Most things, yes.

[19:38] <wolverian> is there a unicode version of ->?

[19:38] <Juerd> Foolish consistency would be adding <- as well.

[19:38] <wolverian> (just curious...)

[19:39] <PerlJam> Besides, I recall when perl5 was first released there were tons of things that got changed right away as Larry's intuition diverged from the perl populace

[19:39] <Juerd> Because write-only is hardly ever used, as opposed to read-write and read-only, and <- introduces a parsing nightmare (qw<-...) that -> and <-> do not.

[19:39] <fglock> { say } <- for 1..10

[19:40] <Juerd> fglock: Have you any idea what the -> operator does?

[19:40] <fglock> something with binding a variable to the block scope, I think

[19:41] <Juerd> fglock: That's only half, if not less, of what it does.

[19:41] <xinming> fglock: In my understanding, It stands for "sub"

[19:41] <Juerd> fglock: "-> $foo { bar }" is a way of writing "sub ($foo) { bar }" (except the class of the block is different)

[19:42] <Juerd> $foo = -> { ... }; is valid syntax.

[19:42] <Juerd> <-, if it existed, would be in the same position:

[19:42] <Juerd> for @foo <- $elem { ... }

[19:42] <xinming> Juerd: then, what does for @foo <- $elem { } mean?

[19:43] <Juerd> xinming: @foo <- $elem { $elem = 5 } would assign 5 to each of @foo

[19:43] <Juerd> s/: /: for/

[19:43] <Juerd> While for @foo <- $elem { say $elem } would raise an exception because $elem is write-only.

[19:44] <Juerd> BUT AGAIN: "<-" would be incredibly silly

[19:44] <svnbot6> r6423 | putter++ | Makefile.PL: added targets {test,smoke}-{pir,js,perl5,all}.  their old names still work.  some of the targets, eg *-perl5, dont work yet.

[19:44] <Juerd> The correct way to write this would be: @foo = { ... } XX +@foo

[19:44] <Juerd> For now assuming an XX op

[19:45] <Juerd> Otherwise: @foo = map { ... } 1..@foo

[19:45] <Juerd> Or any variant on that (consider pipes)

[19:45] <Juerd> 1..@foo ==> map { ... } ==> @foo

[19:46] <wolverian> @foo>>= 5

[19:46] <Juerd> Well, yes, in the specific case of assigning a single value, that would be a better way to go.

[19:46] <Juerd> I don't think that'll ever happen in code written by any of us, though.

[19:47] * putter realizes what has been bugging him about Juerd's descriptions - "_Larry_ this and that", personalities, rather than just discussing positions and their merits.  feels un-academic. ;-)  (err, at least in engineering! ;) some fields it seems like sop)

[19:48] <PerlJam> putter: It's personal.  Larry has the ultimate say for better or worse.  Juerd just focuses on the "worse" aspects sometimes (for those issues where it's bothersome)

[19:49] <iblech> putter: Does it affect PIL-Run if PSub gets a boolean pSubLValue indicating "sub foo is rw {...}" vs. "sub foo {...}"?

[19:50] <iblech> putter: (I.e. just like pSubName)

[19:53] <putter> iblech: dont let any aspect of PIL-Run slow you down.  just go for it.  PIL2JS is critical path on improving PIL.  any PIL-Run fallout can be cleaned up in its wake.  that said, no affect, no problem. ;)

[19:53] <iblech> putter: ok then :)

[19:53] <putter> :)

[19:57] <Juerd> PerlJam: I hope the reason for the focus is obvious, though

[19:57] <PerlJam> Juerd: it is to me.

[19:58] <Juerd> putter: I've referred to Larry once only. Did this really bother you, or did you mistake the many references by others for mine?

[20:00] <Juerd> Oh, and please do note that the things I mention were (and some still are) widely supported ideas that didn't make it for one man's veto.

[20:01] <Juerd> There may be more opposers, but they are silent and thus ignored.

[20:02] <xinming> Juerd: well, In fact, @Larry design Perl 6, with mutable features, You can write rule your own. ;-)

[20:02] <Juerd> xinming: I know that

[20:02] <Juerd> But I'm a very strong believer in sane defaults.

[20:02] <putter> Juerd: no bother.  perhaps my mistake.

[20:03] <xinming> Juerd: well, So am I, I use Emacs, And I never erased any default key-bindings.

[20:03] <Juerd> putter: I found your remark surprising, as I constantly try to keep it technical.

[20:05] <xinming> Juerd: But the problem is, Perl 6 now is "a bit" like Emacs, Some one would use Gnus to read email, some may not, And some others like w3m better than w3, 

[20:05] <xinming> s/better/more/

[20:05] <Juerd> I don't see how that relates to recent discussion, xinming 

[20:06] <xinming> Juerd: So, default might not be the best, But might be most suitable to many people to others.

[20:06] <putter> re "constantly try to keep it technical", err, "I usually abandon ships with drunken captains" and "I think all Larry's done is disappoint people and make them less ethusiastic"...

[20:07] <putter> ;)

[20:07] <Juerd> We were discussing default existing of syntax 

[20:07] <xinming> Juerd: hmm, In my opinion, You can define any "op" right? But Your perfect might not be perfect to other.

[20:07] <Juerd> Not a default of options.

[20:07] <Juerd> xinming: I'm not even referring to perfection

[20:07] <Juerd> It's leaving things out of the language that fit in so well that bothers me most.

[20:07] <xinming> Juerd: hmm, Well, the "perfect" there mean "suitable", sorry for the confusion,

[20:08] <putter> bbiab

[20:08] <xinming> what does bbiab mean? T_T

[20:08] <Juerd> putter: I can't help but be sad about some recent decisions. This is, by the way, about the ./ decision, which upset almost everyone.

[20:09] <Juerd> putter: And thus goes much further than syntax.

[20:09] <xinming> It's a pain to chat with "hacker". Too many Jargon...

[20:09] <PerlJam> putter: When Larry makes a poor choice, I expect to see "Larry screwed up"  

[20:10] <PerlJam> anything else is just putting "political correctness" before truth

[20:10] <xerox> xinming: Be Back In A Bit

[20:10] <iblech> Hm, does t/01-sanity/06-use.t fails for others, too? (Working with Pugs.Parser...)

[20:11] <xinming> xerox: Thanks.

[20:11] <xerox> xinming: yw.

[20:13] <fglock> xinming: see http://www.computerhope.com/jargon.htm

[20:14] <putter> xinming: google bbiab.  you can even just use the first hit;)

[20:14] <xinming> fglock: bookmarked.

[20:15] <xinming> putter: hmm, Sometimes, I am lazy to open the google to search.. :-)

[20:15] <xerox> Yeah, that's why you have `wtf` :-)

[20:16] <xinming> The three virtues of a perl programmer: laziness, impatience, hubris

[20:16] <xinming> I wish to be a programmer, So I have to learn how to become "Lazy". :-P

[20:17] <xinming> and you seee, "Laziness" comes to the first...

[20:17] <putter> "open" google?  putter looks buffudled.   ooohhh, you dont roll out of bed in the morning thinking, "hmm, lets google what to have for breakfast"!  ;-)

[20:18] <svnbot6> r6424 | iblech++ | * Pugs.PIL1: Added pSubLValue/pLValue to PSub and PCode, indicating the

[20:18] <svnbot6> r6424 | iblech++ |   difference between "sub foo {...}" and "sub foo is rw {...}".

[20:18] <svnbot6> r6424 | iblech++ | * Pugs.Compile: Extract the (subLValue vcode) and put in in the appropriate

[20:18] <svnbot6> r6424 | iblech++ |   field of PSub/PCode.

[20:18] <svnbot6> r6424 | iblech++ | * Pugs.CodeGen.PIR: Accomodate for the above changes.

[20:18] <svnbot6> r6424 | iblech++ | * Pugs.Parser: Parse traits for anonymous subs, too (i.e. "sub () is rw

[20:18] <svnbot6> r6424 | iblech++ |   {...}" parses and works now).

[20:20] <putter> I've been a great believer in the "laziness" standard.  autrijus has forced me to... reconsider how broadly to apply it.

[20:22] <xinming> m:w/ \( <expr> [ , <expr> ]* : \) /

[20:22] <xinming> is this the same as `m:w/ \( <expr> \)+ /` ?

[20:23] <svnbot6> r6425 | iblech++ | PIL2JS:

[20:23] <svnbot6> r6425 | iblech++ | * PIL, PIL::Subs: Previously, all subs were implicitly "is rw", because

[20:23] <svnbot6> r6425 | iblech++ |   Pugs.Compile didn't include pSubLValue. As this is fixed now, PIL2JS

[20:23] <svnbot6> r6425 | iblech++ |   distinguishes "sub foo is rw {...}" from "sub foo {...}" now.

[20:23] <svnbot6> r6425 | iblech++ | * PIL2JS.js: Minor cosmetic fix regarding the error message you get if you try

[20:23] <svnbot6> r6425 | iblech++ |   to assign to a readonly box.

[20:23] <xinming> I can't understand what the : mean here really,

[20:27] <xinming> anyone would tell me?

[20:30] <fglock> they mean different things - (a,b,c:) and (a)(b)(c)

[20:31] <putter> Juerd/PerlJam: Despite solutions always being social+technical, its of course best to separate policy from mechanism in design.  and to, at least initially, to discuss issues independently of the people involved.  so when I see "my-position-technical-argument vs another-position-people-argument", my alarm bells go off.  but no doubt there has been more strictly technical arguments elsewhere.  and, err, I vaguely recally someone named pu

[20:31] <putter> tter flaming at length a day or two ago about the repeated decision not to allow p5 ->methodcalls on unblessed- and non- reference values. ;)  anyway, back to hacking.

[20:32] <fglock> putter: may I help you? (maybe I need a break with my modules)

[20:34] <Juerd> xinming: read S5

[20:34] <putter> oh, with PIL-Run?  have at it.  or with integrating js and p5 backends with pugs?  or... ;)

[20:34] <PerlJam> xinming: colon is the "cut" operator inside of a p6 rule.

[20:34] <PerlJam> xinming: :, ::, :::, <cut> and <commit> are the various flavors of cut operators.

[20:35] <xinming> PerlJam: Yes, I know, But What is it does for one :

[20:35] <PerlJam> a single : means don't backtrack into the previous atom

[20:35] <xinming> PerlJam: I can feel that :: and ::: and even <commit> ( maybe like :::: ) will do a break( return ) in a level

[20:36] <putter> re  PIL-Run, one next step might be to get the next sanity test working.  needs if().  which means if() bodies, Thunks and their Code Applications, need to be handled better by EvalX (which currently ignores both Thunks and Code).

[20:37] <PerlJam> xinming: for the rule you posted, once we've matched to the :, if the RE doesn't match a ) then the whole rule will fail (because it can't backtrack)

[20:38] <iblech> putter, fglock: FYI, implementing thunks were easy in PIL2JS -- they're simply subs which never take params and which only have a single expression as their body

[20:39] <xinming> PerlJam: Thanks, Might catch the main idea...

[20:39] <svnbot6> r6426 | fglock++ | * perl5/ List - fixed "ambiguous call to int"

[20:40] <putter> statement_control:<if> is in PrimX.  takes three p5 strings, and returns a combined string of code.  perhaps "if (p6_to_b($xx1)) { $xx2 } else { $xx3 }". or without the {}, depending on what thunks get converted to.

[20:40] <putter> iblech: thanks! :)

[20:40] <fglock> putter: crude_repl.pl is refusing to run, with errors in PrimP5.pm

[20:41] <putter> bleep!  checking...

[20:41] <iblech> putter: Oooh, so PIL-Run inlines &statement_control:<if>?

[20:41] <iblech> putter: (Instead of really calling &statement_control:<if>)

[20:42] <fglock> iblech: the P5 runtime is actually a mix of P6/P5 structures

[20:43] <putter> fribble.  there is no such thing as an ok hand-written change after a pre-commit test.  missing semicolon on the end of the <if> line.

[20:44] <putter> fixed. r6427

[20:44] <svnbot6> r6427 | putter++ | PrimP5.pm: typo fix.  fglock++

[20:46] <putter> iblech: yes.  so far at least, things are being agressively converted to p5 code.  but no interesting control flow is done yet, so we'll see if that lasts.  macros got put in to do  &&  .

[20:46] <iblech> putter: Ah! This is probably a very good optimization

[20:47] * iblech ponders this for PIL2JS...

[20:47] <fglock> putter: are you using Value::List? I'd like to test lazy lists

[20:47] <putter> could be.  I'm not sure how it will interact with (potential?) cps...

[20:47] <fglock> and implement functions in Prelude

[20:47] <fglock> cps?

[20:48] <putter> fglock: I dont think lists are in yet.  "say 3" "say 'hi'"  and I havent checked "say 3 + 4" in a while...;)

[20:48] <iblech> Could somebody check with latest Pugs whether our still works? I might have broken it...

[20:49] <iblech> fglock: Continuation Passing Style

[20:49] <iblech> fglock: Instead of foo(); bar(), you compile foo({ bar() }, basically

[20:50] <putter> fglock, what was the question again? (sorry, I've become confused:/)

[20:50] <fglock> putter: can I use lazy lists?

[20:51] <putter> iblech: I was thinking one might pass the continuation using local(), to permit calls from plain p5 code.

[20:51] <putter> fglock: in PIL-Run?

[20:51] <putter> or in pugs and Prelude.pm?

[20:51] <iblech> putter: Ah! That should work, too

[20:52] <fglock> yes - the object is implemented in Value::List, and the functions would be in Prelude 

[20:52] <fglock> it needs callbacks - but it can use P5 callbacks

[20:52] <putter> call, bbiab

[20:53] <putter> back

[20:54] <fglock> p5ugs> (1,2,3) -- Method not found: .do in Scalar.pm 224

[20:55] <fglock> this actually means that the scalar is undef

[20:57] <xinming> hmm, where to find the `built-in` method for default Class?

[20:57] <putter> fglock: assuming we are talking PIL-Run, Value::List can be required in MainX.pm.  There is a lib6/P5Runtime/PrimP6.pm for extra stuff, but I dont think the file is used at all yet.  (thats probably a matter of changing the pugs line (-I etc) in EvalX - I could do that).  EvalX would need a PIL entry for however PIL represents the lists.  which uses either a new p6_{to,from}_list in ApiX, or uses Value::List directly and we'll worry abo

[20:57] <putter> ut ApiX later.   I think that's it...

[20:58] <putter> :v will show the PIL and generated p5 code.

[20:58] <putter> p5ugs> :v

[20:58] <xinming> Just like, Array will get a sum method by default, I still didn't know there is a built-in sum method until iblech told me.

[20:59] <putter> p5ugs> ...whatever...

[20:59] <iblech> xinming: Look at src/Pugs/Prim.hs, there's a table at the end of the file

[21:00] <xinming> thanks..

[21:02] <svnbot6> r6428 | putter++ | PrimP5.pm: remove debugging output from previous too-rapidly-applied patch.

[21:02] <svnbot6> r6429 | fglock++ | * perl5/ Container - more descriptive error message in Scalar

[21:03] <putter> fglock: ok, it looks like that error message is the current way of saying "the function you tried to apply isnt defined".

[21:03] <putter> there is a prefix:<,>, but no infix:<,>

[21:03] <putter> is infix:<,> what defines Lists?

[21:05] <fglock> don't know - but it looks like it is

[21:05] <iblech> putter: Right, &infix:<,>(1,2,3) is (1,2,3)

[21:05] <putter> (With :v , I evaluated (3,4), which gave the p5 code  p6_apply(p6_var('&infix:,'),p6_new('Int','3'),p6_new('Int','4'));  but checking Prim, infix:<,> didnt exist...)

[21:06] <fglock> and infix:<..> implements ranges

[21:06] <iblech> &infix:<,> can be implemented extremely easy: sub infix:<,> (*@elems) { @elems }

[21:06] <iblech> (Presuming, * works, of course)

[21:06] <putter> ok, so MULTI SUB infix:<,> (*@a) { p6_to_list(@a) }   and ApiX defines p6_to_list  using Value::List...

[21:07] <fglock> so I can hack ApiX p6_to_list?

[21:07] <putter> err, thats p6_from_list

[21:07] <putter> err, ok, that naming scheme is fraying around the edges.

[21:08] <putter> yes, ApiX, whateveryouwanttocallit(@a) { Value::List->new(@a) }

[21:08] <putter> in ApiX

[21:09] <fglock> I think the function is not there

[21:09] <putter> and the reverse too, getting an array from a List, for the primitives which need to deal with it...

[21:09] <putter> (I assume some primitives need to deal with it...)

[21:10] <fglock> putter: you can't always map lazy lists to P5 array

[21:10] <putter> p6_from_list?  no, not there yet.  no lists yet at all.

[21:10] <fglock> but lazy list to P6 Array is fine

[21:11] <putter> ah well, do p5 array -> List now, worry about using List later, as the need arises.

[21:12] * iblech notes that PIL2JS doesn't differentiate between Array and List, without causing any (apparent) problems

[21:12] <fglock> so it would be p6_to_l / p6_from_l ?

[21:12] <fglock> iblech: I'm not sure what the difference is, actually - maybe just because Array are containers (mutable)

[21:13] <fglock> the p5 implementation of Array is much more complex than List

[21:13] <putter> p6_from_l for now.  we can revisit how they are named at some point.

[21:13] <iblech> fglock: I don't know either. Probably something along that line

[21:14] <putter> or p6_list()

[21:14] <putter> whatever.  there are only three files.  change is easy.

[21:16] <putter> iblech: prefix:<,> is just  (*@a){@a} as you describe.  say() should take a List rather than a p5 list, that might need to change.

[21:16] <putter> s/say/but if say/

[21:17] <iblech> Hm, does a plain @a evaluate to a P5 list, instead of a P6 List/Array?

[21:18] <iblech> (If not, I don't understand your sentence.)

[21:19] <putter> fglock: bottom line - there are only three smallish files of code (well, Prim is big, but only the first few lines are hand-written).  so follow your wimsy.  do anything.  its easy to frob it back and forth.  And I kind of suspect noone be me has ever run it.  And I sure dont mind it breaking. ;)

[21:20] <xerox> Hey.

[21:20] <xerox> Why do I have a pypy supporter saying "perl6 people copied the object spaces idea" ?

[21:20] <xerox> I mean, is it like this or the other way around?

[21:20] <wolverian> object spaces idea?

[21:21] <xerox> So he says O_o

[21:21] <wolverian> what does he mean with it?

[21:21] <putter> yes, right now, say(3,4)  compiles as  p6_apply(p6_var('&say'),p6_new('Int','3'),p6_new('Int','4'));   and... (hmm... the 4 doesnt get printed at all!?!?) ... anyway, so a regular p5 list of arguments is being used.  once we have List, perhaps something needs to change there.

[21:21] <iblech> putter: Ah, ok.

[21:22] <xerox> wolverian: I'm asking...

[21:22] <wolverian> xerox, in any case, it doesn't much matter. everything was done with lisp in the 60s or 70s, anyway. we're just reinventing the wheel - with nicer syntax. :)

[21:23] <putter> xerox: perhaps the same reason some people think "you used my software patent!"?  ;)

[21:23] <integral> I got the impression that "object spaces" was just that you have objects which have an interface to the code,  but they're implemented by something in your runtime engine,  but you can implement them in different ways :-/

[21:23] <xerox> wolverian: indeed.

[21:23] <xerox> putter: haha, good point.

[21:23] <iblech> geoffb: I just implemented temp in PIL2JS :)

[21:24] <iblech> geoffb: (As you were asking earlier today)

[21:24] <xerox> k thanks :)

[21:24] <putter> pugs is a bit unusual, in that autrijus is a paper monster.  a lot of projects putter along with only a fuzzy feel for the state of the art, and consider the solutions the work out to be novel.

[21:24] <putter> s/the/they/

[21:25] <wolverian> xerox, so, did he mean what integral said?

[21:25] <putter> oooo, temp!   putter considers doing rules development on PIL2JS...

[21:25] <xerox> wolverian: he meant nothing, he seem to do not know what he was talking about - it should be something like "having different backends for code generation"

[21:25] <wolverian> xerox, right.

[21:26] <xerox> Sorry for bugging you on this.

[21:26] <iblech> putter: let will follow in a minute :)

[21:26] <fglock> putter: done ApiX

[21:28] <fglock> putter: List contains a Perl6::Value::List object, so that there is no problem if you 'unbox' it 

[21:28] <svnbot6> r6430 | fglock++ | * implemented to/from p6 List functions in ApiX.pm

[21:30] <putter> iblech: :)

[21:31] <putter> fglock: neat!  so...  should say(3) be, instead of p6_apply(p6_var('&say'),p6_new('Int','3')), something like p6_apply(p6_var('&say'),p6_from_l(p6_new('Int','3'))) ?

[21:31] <fglock> I think so

[21:32] <fglock> did you find what is the node type for List?

[21:32] <putter> sorry, I havent looked...

[21:32] <fglock> I'm trying to find out

[21:33] <putter> if you do :v  and then (3,4)  you get a nice yaml dump of the pil tree.

[21:33] <fglock> yep. I'm trying to understand it

[21:33] <putter> looks like nothing more than a call to infix:<,>

[21:33] <svnbot6> r6431 | putter++ | PrimP5.pm: say() now prints all its arguments, not just the first one.

[21:33] <iblech> nothingmuch: As I'm going to commit a change to Pugs.AST.Scope (which could possibly break everything), I'd appreciate if you restart your smoke script, thanks very much :)

[21:34] <fglock> I tried (1,2).shift

[21:35] <putter> which compiles to an excessively brief  p6_apply(p6_var('&shift')); , because infix:<,> doesnt exist yet...

[21:36] <putter> the key things to look for in the pil dump is the PApp's, pVarName's, and simple literals.

[21:38] <putter> fglock: did you define an infix:<,> in Prim?

[21:38] <fglock> no - I'll open it

[21:40] <putter> something like   MULTI SUB infix:<,> (*@a) { p6_from_l(@a) };  should do it.

[21:40] <fglock> there is one already - I'll try to modify it

[21:42] <fglock> what is prefix:<,> used for?

[21:43] <iblech> fglock: To construct a list/array

[21:43] <putter> I was wondering that a moment ago.  must be something, or I wouldnt have defined it.  maybe leave it, write the infix:<,> we need now, and worry later.

[21:43] <svnbot6> r6432 | iblech++ | * Pugs.AST.Scope: Reorder the declarations of the various scope types -- SLet

[21:43] <svnbot6> r6432 | iblech++ |   and STemp do something to *existing* variables. Accidentally, this causes

[21:43] <svnbot6> r6432 | iblech++ |   temp.t to pass on normal Pugs!

[21:43] <svnbot6> r6432 | iblech++ | * Pugs.Lexer, Pugs.Compile: Acommodate for that change.

[21:43] <svnbot6> r6432 | iblech++ | * PIL2JS: temp! let!

[21:43] <svnbot6> r6432 | iblech++ |   * PIL: All JS functions have a block_leave_hooks array now, containing native

[21:43] <svnbot6> r6432 | iblech++ |     JS functions to be called at block exit.

[21:43] <svnbot6> r6432 | iblech++ |   * PIL::PPad uses this variable to implement the (possible) variable

[21:43] <svnbot6> r6432 | iblech++ |     restoration needed for temp and let.

[21:43] <svnbot6> r6432 | iblech++ | * t/var/let.t, t/var/temp.t: Should "temp @array[$index]" work? I think so, but

[21:43] <svnbot6> r6432 | iblech++ |   Pugs doesn't even parse that. Added appropriate tests in a =pod block.

[21:43] <putter> iblech: so when infix:<,> and when prefix:<,>?

[21:43] <svnbot6> r6432 | iblech++ |   BTW, let.t passes 7/7, temp.t passes 22/22 (with TODO tests).

[21:44] <iblech> putter: Never prefix:<,>

[21:45] <putter> hmm....

[21:45] <iblech> (At least, I've never seen that one.)

[21:46] <svnbot6> r6433 | putter++ | ApiX.pm: moved Value::List->from_single() call to p6_new

[21:46] <svnbot6> r6434 | putter++ | ApiX.pm: oops, added missing return.

[21:47] <putter> guess I imagined it...

[21:51] <putter> iblech, does temp() unwind when exceptions are thrown?

[21:52] <putter> and does temp.t passing on pugs mean it really works (!?!), or that temp.t needs more tests...?

[21:52] <svnbot6> r6435 | putter++ | PrimP5.pm: deleted mythical prefix:<,> primitive.

[21:52] <iblech> putter: Oh, no, haven't thought of that. Writing test and thinking about implementation

[21:52] <putter> ok

[21:52] <iblech> ?eval $?PUGS_VERSION

[21:52] <evalbotzy> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6378)' 

[21:53] <putter> my fuzzy recollection is doing unwind-protect (aka temp) in the face of full continuations is a "long studied but regretably inherently hard problem".

[21:54] <fglock> I'll commit what I have so far and go after a problem with 'List'

[21:56] <iblech> putter: oh. hm.

[21:56] <putter> k

[21:57] <putter> hmm... temp $obj.attribute = 5;  ;)

[21:57] <svnbot6> r6436 | fglock++ | * small fix in ApiX

[21:57] <iblech> That's actually extremely easy to implement in PIL2JS, presuming that this parses :)

[21:58] <putter> !:)

[21:59] <nothingmuch> parrot is headed in the right direction... ;-)

[21:59] <nothingmuch> http://www.sidhe.org/~dan/blog/archives/000425.html

[21:59] <nothingmuch> dan's parrot, at least

[22:02] <putter> iblech: oops.  I'm wrong (vis continuations vs unwind-protect)  http://bc.tech.coop/blog/050731.html (bottom) and perhaps http://www.nhplace.com/kent/PFAQ/unwind-protect-vs-continuations.html

[22:03] <putter> dan's parrot would have been an interesting thing to play with...

[22:04] <fglock> putter: p6_from_l works, but there seems to be a problem with the object somewhere else

[22:05] <putter> hmm...  just in case it was too hidden, note that in crude you can :5 <perl5 expression>, which helps with debugging...

[22:05] <fglock> It might be a problem with the object - I'll check this first

[22:05] <putter> k

[22:09] <putter> nothingmuch: one thing I take away from having seen both parrot and pugs, is that if the domain is amenable to prototyping (it was in both cases), at least in an open source setting, it really helps if your system architect can spew code, instead of just spec.

[22:09] <svnbot6> r6437 | fglock++ | * updated ApiX.pm

[22:10] <nothingmuch> putter: fairy nuff, but MMD as an implementation detail (even when it's exposed to the high level language) is a smart move, since it vastly simplifies optimization when static analysis and type inferrence becomes involved

[22:10] <nothingmuch> and optimization is incremental, and modular

[22:11] <nothingmuch> for example the assignment operation on integers as given in dan's blog post makes a lot of sense

[22:12] <nothingmuch> especially when static analysis lets you just emit machine code that has absolutely no respect to an encapsulated object's guts, since the data type is shared

[22:12] * putter goes back to read article more closely...

[22:12] <nothingmuch> this can be bolted on later, after you've got "safe" assignment implemented

[22:12] <nothingmuch> which is very good, because it can be profile driven

[22:13] <nothingmuch> if your integer operations are too slow, you meter them, and figure out that assignment is taking too long, so you special case assignment on integers, and you save a little here

[22:13] <nothingmuch> then you find that too much time is wasted on MMD dispatch, so you improve static assignment, and inline the MMD candidates as machine code where they can be known in advance

[22:14] <nothingmuch> this approach to making things fast is known to work, and is easy to design well, and is good for many-hacker few full timer projects

[22:14] <nothingmuch> where someone who cares can whip up a specialization of the system for the small part they cares about

[22:15] <nothingmuch> s/cares/care/;

[22:15] <nothingmuch> uh, damnit

[22:15] <nothingmuch> the second cares

[22:16] <fglock> weid error - calling a closure as a method doesn't pass $_[0] (in Perl5)

[22:16] <fglock>  /weid/weird/

[22:16] <nothingmuch> fglock: really? i've relied on it a million times

[22:17] <nothingmuch> if (my $sub = $obj->can("method")){ $obj->$sub(@args) };

[22:17] <nothingmuch> for example

[22:17] <iblech> putter: Thanks much for the links :) I'll (have to) read them carefully, tomorrow

[22:17] <svnbot6> r6438 | iblech++ | t/var/: let.t, temp.t: Test that let and temp restore variables even when the

[22:17] <svnbot6> r6438 | iblech++ | block they're in has been left via an exception (and not via an (possibly

[22:17] <svnbot6> r6438 | iblech++ | implicit) call to &return).

[22:17] <fglock> I just had to fix this in List.pm

[22:17] <putter> np :)

[22:17] <putter> they were just a quick google, so there may well be better stuff out there.

[22:17] <iblech> Maybe I dream of the solution, similar to autrijus :)

[22:18] <fglock> sub str { $_[0]->{cstringify}( $_[0] ) } -- doesn't work without ($_[0])

[22:18] <iblech> Which reminds me, I should sleep now. Night all! :)

[22:18] <putter> Good night iblech! :)

[22:20] <wolverian> fglock, {cstringify} is not a method

[22:20] <putter> fglock: but the () is sub-call (not method call) to the sub ref in the hash (index cstringify) pointed to by $_[0].

[22:20] <nothingmuch> wtf is this hoodwink.d thing?

[22:20] <putter> ?

[22:20] <fglock> mm right - I thought it was a method

[22:21] <fglock> putter: it works now - the list prints weird, but that's because stringification is very simple

[22:21] <putter> neat!

[22:21] <fglock> 1,2 prints Int=HASH(0x88f6894)....Int=HASH(0x88f6270)

[22:22] <putter> and actually, the answer to the earler "does say get called with a list" is.... only if PIL says so! ;)  which it doesnt at the moment.

[22:22] * putter svn up's to look...

[22:22] <svnbot6> r6439 | fglock++ | * perl5/ List - fixed stringification

[22:23] <fglock> now trying to find out how to do 1..2

[22:24] <fglock> actually 'shift' is easier

[22:25] <putter> err, did you define infix:<,>...?  I'm getting an error on (3,4)

[22:25] <fglock> ah ok, I didn't commit PrimP5

[22:25] <putter> k

[22:26] <fglock> done

[22:27] <putter> iblech: prefix:<,> is in Pugs/Prim.hs  (after DESTROYALL)

[22:27] <wolverian> prefix ,? that's weird

[22:28] <putter> fglock: I'm still seeing 6439

[22:29] <fglock> I'm getting a svn conflict - resolving...

[22:30] * putter takes a moment to marvel at working with someone in another part of the planet, and thinking a 3minute latency in tossing a file back and forth, via taiwan, is like *taking forever*. ;)

[22:30] <putter> fglock: oops, sorry.  probably my dropping prefix:<,>.

[22:31] <fglock> done - 6440

[22:32] <fglock> (1,2) works, but (1,2).shift doesn't

[22:32] <putter> prefix:<,> came back, and that's fine.  I'll add a note to it saying we're puzzled.

[22:32] <wolverian> (1,2).shift is invalid perl6, if that's the problem :)

[22:32] <wolverian> (I don't know what you're doing, so just ignore me if you know that.)

[22:32] <svnbot6> r6440 | fglock++ | * defined (1,2).shift

[22:33] <wolverian> well, I thought it would be. oh well. (lists are mutable now?)

[22:33] <fglock> strange - how do you take a value from a list?

[22:33] <putter> hmm, (3,4) gives me Can't use string ("") as a subroutine ref while "strict refs" in use at /home/net1/perl6/pugsxpl2/perl5/PIL-Run/../Perl6-Value/lib/Perl6/Value/List.pm

[22:33] <wolverian> my question exactly, fglock. :)

[22:33] <fglock> putter - you have to update Value::List

[22:34] * putter hits his head, "doh!".  svn up in wrong (two low) dir.

[22:34] <putter> too low, even

[22:34] <fglock> lists aren't exactly mutable, but you have to traverse them (?)

[22:34] <wolverian> [] traverses, doesn't it? I don't understand what (1,2).shift would do.

[22:35] <fglock> it returns 1, and keeps a list (1). the original list doesn't exist anymore

[22:35] <fglock> oops, returns 1 and keeps 2

[22:36] <wolverian> but the list isn't "kept". that's the definition of a list. only arrays are kept.

[22:36] * putter leaves fglock to do interesting things with List's and goes to get a snack...

[22:36] <wolverian> (well, the definition of a list is that it's immutable, I guess. :)

[22:38] <fglock> anyway, shift it is not an error at this level of implementation - I'm getting a message saying that I'm trying to shift from an 'undef'

[22:40] <wolverian> right. (the error should be that you're trying to shift from a List)

[22:42] <putter> feeping creatures, snack -> dinner.  later &

[22:42] <fglock> bye - I'm getting home too

[22:43] <putter> err, fglock, hmm... if you do :v, (3,4).shift for me is compiling as  p6_apply(p6_var('&shift'));  so somethings not quite right...

[22:44] <fglock> I'll try again later - maybe storing the list in a Scalar first

[22:44] <putter> say(say 3) works...

[22:44] <putter> ok, later! :) &

[22:44] <fglock> my $a=(1,2); $a.shift doesn't compile too

[22:46] <putter> $a = (3,4)

[22:46] <putter> :5 p6_var('$a')

[22:46] <putter> Scalar=HASH(0x1164710)

[22:46] <putter> which perhaps isnt what you intended?

[22:47] <putter> oh, duh.  yes, that's right.

[22:47] <putter> 5 p6_var('$a')->fetch

[22:47] <putter> List=HASH(0x116c0c0)

[22:48] <putter> i'm late.  this was fun, thanks! :) &

[22:53] <luqui> ?eval 42

[22:53] <evalbotzy> 42 

[22:53] <luqui> good

[22:53] <coral> ?eval 42.pick

[22:53] <evalbotzy> Error: pick not defined: VInt 42 

[22:53] <luqui> ?eval (42|5).pick

[22:53] <evalbotzy> 42 

[22:53] <luqui> ?eval (42|5).pick

[22:53] <evalbotzy> 5 

[22:53] <coral> whoah! neat!

[22:53] <coral> someone++

[22:54] <luqui> I think  that's been there awhile

[22:54] <buu> Holy wtf.

[22:54] <buu> ?eval (42|5)

[22:54] <evalbotzy> 5 

[22:54] <buu> ?eval (42|5)

[22:54] <evalbotzy> 5 

[22:54] <luqui> I think that's a parsing error

[22:54] <buu> Really?

[22:54] <luqui> there is no automatic collapse of junction

[22:54] <wolverian> I think evalbot doesn't output junctions right

[22:54] <buu> shux.

[22:54] <wolverian> ?eval 1 & 2

[22:55] <evalbotzy> 1 

[22:55] <wolverian> ?eval "a" | 42 | "c"

[22:55] <luqui> ?eval (42|5).states

[22:55] <evalbotzy> 42 

[22:55] <evalbotzy> Error: No compatible subroutine found: "&states" 

[22:55] <luqui> ?eval (42|5).values

[22:55] <evalbotzy> (5, 42) 

[22:55] <luqui> there we go

[22:55] <wolverian> ?eval "a" | 42 | "c" | "d"

[22:55] <evalbotzy> 42 

[22:55] <wolverian> that's still not right. :)

[22:55] <luqui> it seems to give you the first one when sorted

[22:55] <wolverian> right.

[22:55] <wolverian> or it's trying to tell us something important..

[22:57] <wolverian> ?eval "a".."b".pick

[22:57] <evalbotzy> Error: pick not defined: VStr "b" 

[22:58] <wolverian> ?eval ("a".."z").pick

[22:58] <evalbotzy> 'x' 

[22:58] <wolverian> just curious about precedence. now, good night. :)

[22:58] <nothingmuch> *yawn*... time for shower & bed

[22:58] <nothingmuch> so much dust.. yuck!

[22:58] <luqui> eew dust

[22:59] <nothingmuch> the worst kind too - cement dust

[22:59] <luqui> sticky

[22:59] <nothingmuch> it's corrosive, and it dries up the skin

[23:00] <luqui> hmmm.. that's worse than sticky

[23:00] <luqui> I've never been around it too long

[23:00] <nothingmuch> we're rennovating, so there's lots of it

