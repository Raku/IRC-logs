[00:09] <leo> say 'ok' for fluck(fluck) # does it finish if fluck is lazy ;-)

[00:10] * PJF wonders what happened to the cheerful banter of svnbot?

[00:14] <Khisanth> it died and stayed dead

[00:25] <lollan> yop

[00:26] <lollan> somebody can tell me why you use askhell to write perl6 , it's not too slow ?

[00:26] <Alias_> haskell can be faster than C

[00:26] <Alias_> It's also extraordinarily good at writing parsers

[00:26] <Alias_> In fact, it's arguably it's primary commercial role at the present time

[00:27] <Alias_> That and crypto

[00:27] * SamB didn't know haskell had a commercial role

[00:27] <Alias_> parsers and proof-carrying military crypto

[00:27] <SamB> proof-carrying crypto sounds dangerous

[00:27] <Alias_> the opposite

[00:28] <Alias_> It's crypto that you can proove correctly implements the math behind the crypto

[00:28] <Alias_> for all cases

[00:28] <lollan> ok

[00:28] <SamB> I assume it doesn't actually send the proof with the encrypted data?

[00:28] <Alias_> Haskell is tightly based on math... math can prove things

[00:29] <Alias_> Thus, with Haskell you can write code that is proveably correct

[00:29] <lollan> so i understood if you program well in askhell, it can be faster than C/C++ ?

[00:29] <Alias_> yes

[00:29] <Alias_> Because it has some really crazy optimisations available to it that C doesn't

[00:30] <Alias_> C is very close to the metal, but Haskell has math on it's side

[00:30] <integral> a big thing in a C optimiser can be reconstructing some of the facts about functions (eg sideeffects) that haskell preserves in the first place

[00:30] <lollan> ok i begin to learn askhell today ,it's really amazing but i bielive it was slow, because you can do too much things

[00:30] <Alias_> It can be VERY slow to compile :)

[00:31] <SamB> note that a lot of the time haskell is slower than C, but most of the time you can't imagine how to do what you are doing in C anyway

[00:31] <Alias_> Haskell is going to be the next "hot" language I suspect

[00:31] <lollan> there is function in askhell to optimize ?

[00:31] <Alias_> Or rather Perl6/Haskell as a pair

[00:31] <SamB> Haskell is already HOT

[00:31] <SamB> (Higher-Order Typed)

[00:31] <Alias_> SamB: Not like Ruby on Rails :)

[00:31] <integral> lollan: it's spelled "haskell" by the way

[00:31] <SamB> ugh, don't mention that book, its very title has become repugnant

[00:31] <Alias_> heh

[00:31] <lollan> ok sorry

[00:32] <SamB> not that I've read it, but it never makes any sense no matter how many times I hear it.

[00:32] <Alias_> Of course, even though I like the idea of Haskell, I can't think of anything I actually might need it to write :)

[00:32] <lollan> <Alias_> Haskell is going to be the next "hot" language I suspect << i don't think soo, functional language are particular i think

[00:33] <SamB> Alias_: you must not have played with it enough yet

[00:33] <luqui> Well, Haskell's not going anywhere in the popular world

[00:33] <luqui> because it's too hard to understand

[00:33] <SamB> if you play with it enough, you'll have no trouble thinking things in it that you can't think in other languages

[00:33] <luqui> every "hot" language has to look to some extent like C

[00:33] <Alias_> luqui: For now... marketing is largely based on products

[00:33] <luqui> SamB, agreed entirely

[00:33] <SamB> yay for being unpopular!

[00:34] <SamB> (it keeps the idiots away)

[00:34] <Alias_> ... and jobs

[00:34] <luqui> :-)

[00:34] <luqui> :-(

[00:34] <lollan> sorry what is HOT ?

[00:34] <SamB> higher-order typed

[00:34] <Alias_> "buzz"

[00:34] <lollan> -00.41.44- <luqui> because it's too hard to understand << i am agree with you

[00:35] <luqui> however, I'd say it's well worth putting in the effort to understand it

[00:35] <Alias_> Perl 6 may well form a nice bridge

[00:35] <lollan> Lisp is a functional language no ?

[00:35] <Alias_> Because it spans both sides to some degree

[00:35] <SamB> no.

[00:35] <SamB> well, not like Haskell is.

[00:35] <SamB> lisp is more of a... well, lisp.

[00:35] <luqui> Well, Lisp was supposed to be a functional language

[00:35] <lollan> ok lol

[00:36] <luqui> but a lot of people program imperatively in it.

[00:36] <SamB> they'll call it functional, but thats because they don't know better.

[00:36] <SamB> (or are using a different definition)

[00:38] <Alias_> SamB: One less directly based on the math perhaps

[00:38] <lollan> You can optimize haskell by some particular instruction or by a particular way to compile ?

[00:38] <Alias_> no, by language features

[00:38] <SamB> er.

[00:38] <SamB> what about -O?

[00:39] <Alias_> "no (yes but that's not the point)

[00:39] <Alias_> Given f(a, b) you can get yourself f(b) with a optimised out very easily

[00:39] <lollan> thanks Alias_ and other for answers

[00:39] <Alias_> So algorithmic optimisation is almost trivial

[00:40] <Alias_> Which still blows my mind

[00:40] <lollan> it's a mathematical language

[00:40] <lollan> lol

[00:40] <SamB> thats what makes it so easy ;-)

[00:40] <SamB> and yet so hard :-(

[00:40] <Alias_> or hard :)

[00:41] <Alias_> On the plus side, because math is the only field of human endeavour that can deal with truth and proof, that gets carried into the code

[00:41] <SamB> but in the end, a pleasure to use :>

[00:41] <Alias_> Which is a huge benefit

[00:41] <Alias_> SamB: If math fits your brain

[00:41] <SamB> Alias_: not if, when

[00:41] <Alias_> heh

[00:42] <lollan> you work with larry for new perl version ?

[00:43] <Alias_> me, no

[00:43] <Alias_> But I wrote the only Perl 5 parser that doesn't have side-effects, so I'm helping in a few areas for a few days

[00:43] <lollan> ok

[00:43] <lollan> Alias_ you must love math, math is good of course not too much

[00:43] <Alias_> I like the _idea_ of math.

[00:44] <Alias_> Math doesn't fit my brain so well though

[00:44] <lollan> to tell you the true i know perl (and some other language)

[00:44] <Alias_> Automata and algorithms much more so though

[00:44] <lollan> but i use perl only for small things too hard to maintain 

[00:45] <lollan> but i am waiting for this new version :) so thanks guys :)

[00:45] <lollan> and i begin to learn haskell

[00:47] <SamB> how are algorithms different from math?

[00:47] <lollan> you don't use other language to make perl6 ?

[00:47] <Alias_> Some of the more advanced bits of Perl 6 will look similar to Haskell

[00:48] <Alias_> SamB: My mind gets small things interlocked in myriads of ways assembled into ever larger machines

[00:48] <lollan> <SamB> how are algorithms different from math? << algorithm are here to help you to write your program , mathematic create new one

[00:48] <Alias_> It doesn't get large complex expressions, manipulations of said expressions, and things like stats and so on

[00:48] <lollan> ok thanks Alias_

[00:49] <SamB> stats?

[00:49] <Alias_> I flunked statistics 1a for Egnineers at uni

[00:49] <SamB> you don't need stats...

[00:50] <Alias_> wanna bet

[00:50] <Alias_> I need it next week

[00:50] <Alias_> :(

[00:50] <SamB> not for Haskell, I mean...

[00:50] <Alias_> sure

[00:51] <Alias_> But that's not what he commented on

[00:55] <stevan_> autrijus: ping 

[00:55] *** stevan_ is now known as stevan

[00:57] <Alias_> she's here, but trying to concentrate on some coding

[00:57] <stevan> ah

[00:57] <Alias_> If it's important I can nudge her

[00:57] <stevan> please tell her if she has questions I am available

[00:57] <stevan> but if she is on a roll,.. dont bother her :)

[00:57] <Alias_> "yay"

[00:58] <autrijus> stevan: I'm finishing up native bits

[00:58] <autrijus> 5 mins

[00:58] <stevan> autrijus: I am available for the next couple hours

[00:58] <stevan> so whenever you are ready

[01:01] <autrijus> okay. I think I've done the design part

[01:01] <autrijus> so I'm finally into coding

[01:01] <stevan> cool

[01:01] <autrijus> please pull r8139 and look at src/PIL/Native.hs

[01:01] <stevan> ok

[01:01] <autrijus> and we'll go thru the questions one by one.

[01:02] <autrijus> mostly they are the diffs between fglock's spec and yours

[01:03] <stevan> ok

[01:04] * stevan has not updated pugs in a little while,..... still pulling

[01:04] <autrijus> 1. how is Symbol used differently than Str in your Core?

[01:04] <stevan> well, symbol has a type annotation attached

[01:05] <stevan> and is meant to be code symbols (variables, method names, etc)

[01:05] <stevan> they are largely interchangeable with strings

[01:05] <stevan> however, strings can be compared, and concatenated,.. symbols cannot

[01:05] <autrijus> so are they meant to carry only native types

[01:05] <autrijus> or also OO types

[01:05] <stevan> but if you need to do that,.,. just coerce

[01:06] <stevan> well,.. I call it "type" but to be honest, it can hold anything you need it to

[01:06] <stevan> they only carry native types because they currently only live on that level

[01:07] <stevan> but that is not a restriction

[01:07] <stevan> make sense?

[01:07] <autrijus> mm

[01:08] <autrijus> but you have a Type type

[01:08] <autrijus> that is distinct from a Sym

[01:08] <stevan> yeah that is the base "type", probably not a good idea

[01:08] <autrijus> so is Sym essentially (ImmutableString, Type) pair?

[01:08] <stevan> s/idea/name/

[01:08] <stevan> yes, that is Sym

[01:09] <autrijus> okay. in that case I'll just use strings for now, as the type is enforced by the haskell compiler

[01:09] <stevan> sure

[01:09] <autrijus> 2. in order to carry larry's "undef but error" idea, I promoted Nil to carry a runtime-specific native exception object and renamed it as "error". is it sane?

[01:09] <autrijus> this is because you return Nil for a lot of different failures

[01:10] <autrijus> but on the upper level we can't provide useful msg

[01:10] <stevan> ok

[01:10] <autrijus> without the Nil actually saying something

[01:10] <stevan> Nil is pretty much the same as Void in p6 land

[01:10] <autrijus> but you had @array[9999] return nil for out of bound

[01:10] <autrijus> so it also doubles as undef

[01:11] <stevan> hmm,.. yeah

[01:11] <stevan> bad design I think :)

[01:11] <stevan> I didnt give undef much thought

[01:11] <autrijus> k, that's fine

[01:11] <autrijus> 3. mutability

[01:12] <autrijus> your Str is immutable

[01:12] <autrijus> i.e. destructive updates are not allowed -- only constructive ones that makes new strs

[01:12] <autrijus> s/Str/NativeStr/

[01:12] <autrijus> but for the two other plural type (List and Hash)

[01:12] <autrijus> they are destructively updatable

[01:13] <autrijus> i.e. remove

[01:13] <stevan> yes, I borrowed the Str thing from Java ... again,.. nothing critical,.. so you can change it if it makes sense to 

[01:13] <autrijus> I'm thinking about it

[01:13] <autrijus> how do you use your Hash?

[01:13] <autrijus> do you know all its keys beforehand?

[01:13] <stevan> nope

[01:14] <autrijus> ok. I'm thinking about the idea that makes Hash and List immutable as Str

[01:14] <stevan> ok

[01:14] <stevan> I suppose the compiler could know all the keys, etc 

[01:14] <autrijus> because in the MM once we finished construction of objects, that saves several levels of indirection

[01:15] <autrijus> which leaves NativeRef as the only destructive type (as it's essentially a pointer)

[01:15] <stevan> I have no objection to that, it sounds very sane

[01:15] <clkao> autrijus

[01:15] <autrijus> perlcabal.org is getting very slow :/

[01:15] * autrijus tries hops on irc from here

[01:16] *** audrey_ is now known as audreyt

[01:16] *** autrijus is now known as _autrijus

[01:16] <audreyt> there we go

[01:16] * stevan is amazed at the gender transformations happening right before his eyes :)

[01:16] <audreyt> stevan: so, if NativeRef is the only destructive type, its coercion rules become weird

[01:16] <audreyt> :D

[01:17] <stevan> why do they become weird?

[01:17] <audreyt> stevan: in your ::Core, you have ref stringify to CODE(0xDEADBEEF)

[01:17] <audreyt> and numify to 0xDEADBEEF

[01:17] <clkao> seen putter

[01:17] <audreyt> that sounds to be as weird.

[01:18] <audreyt> I wonder if it makes more sense to just rule them out in the core runtime

[01:18] <stevan> audreyt: I was borrowing from P5 here,.. feel free to adjuct it as you see fit

[01:18] <stevan> hmm

[01:18] <audreyt> i.e. when in the runtime would we be stringifying refs?

[01:18] <audreyt> the uppercase Ref can stringify however larry wants

[01:18] <audreyt> but NativeRef?

[01:18] <audreyt> I thought they are only used to hold mutable bits in the MM

[01:19] <stevan> so rule out NativeRef coercions in the runtime? or NativeRefs themselves

[01:19] <audreyt> so I propose that they Bitify as True, and die for everything else

[01:19] <stevan> hmm

[01:19] <stevan> I think that would work

[01:19] <audreyt> no, we need NativeRef because now that Array/Hash become immutable

[01:19] <audreyt> it provides the only source of mutability

[01:19] <stevan> ok

[01:20] <audreyt> if we don't allow userland mucking of metamodel

[01:20] <audreyt> then NativeRef doesn't need to be here

[01:20] <stevan> but we want userland mucking

[01:20] <audreyt> but if we do, then it may make sense to use NativeRef to hold the bits that the userland can muck with

[01:20] <stevan> I think you can safely remove the coercion functions from Ref

[01:20] <xah_> good morning _autrijus 

[01:20] <stevan> I dont see any place I actually use them

[01:21] <audreyt> greetings xah.

[01:21] <xah_> greetings audreyt

[01:22] <audreyt> stevan: so the source of mutabilities are:

[01:22] <audreyt> class of an object

[01:22] <audreyt> eg $NULL_OBJECT->[1]

[01:23] <stevan> yup

[01:23] <stevan> and IIRC the only reason that is there is for bootstrapping

[01:23] <audreyt> wait... you have a refernece at Object_id slot?

[01:23] <stevan> possibly that could be removed

[01:23] <stevan> do i?

[01:23] <audreyt> oh, no

[01:23] <audreyt> nvm, ->new makes objid implicitly

[01:24] <stevan> yes

[01:24] <audreyt> I looked at ->new(reference->new) and thought it's ->[0]

[01:24] <audreyt> it's actually [1]

[01:24] <stevan> yup :)

[01:24] <stevan> we could remove that reference actually

[01:24] <stevan> by createing Class with a nil there instead

[01:24] <audreyt> it looks like there's very limited use of Ref then

[01:24] <audreyt> yes

[01:24] <stevan> then using the change_class to do the self ref

[01:25] <audreyt> yes

[01:25] <audreyt> which will get rid of the only mutability point

[01:25] <stevan> that is how the PIR prototype was doing it

[01:25] <audreyt> cool... because if we don't have Ref, the state of the runcore native image at any given point is purely value

[01:26] <audreyt> so can be safely serialized without pointer chasing

[01:26] <audreyt> (problem with Ref is that they can disappear from under you)

[01:26] <stevan> oh

[01:26] <stevan> then remove remove remove

[01:27] <audreyt> cool :)

[01:27] <stevan> although closure::env uses refs

[01:27] * audreyt praises Haskell for making all effects explicit

[01:27] <stevan> so they can be update able

[01:27] <stevan> but there is probably a way around that

[01:27] <audreyt> yes, but again it's like native array

[01:27] <audreyt> or strings

[01:28] <audreyt> you can update them without destroying old copies

[01:28] <audreyt> or do you actually want that?

[01:28] <stevan> no need to destroy I guess

[01:29] <audreyt> cool... Ref is gone. a sec

[01:29] <stevan> the only other place is list->each

[01:29] <stevan> which just passes a ref to the closure 

[01:29] <stevan> but again,.. can be repleaced im sure

[01:30] <audreyt> why can't it pass the value?

[01:30] <audreyt> I thought the idea of undercase native types is they are all value types

[01:30] <audreyt> that has passbyval semantics

[01:30] <audreyt> s/under/lower/

[01:30] <stevan> well each does implace modification

[01:31] <stevan> apply is like map in p5,.. it returns a new list

[01:31] <stevan> it can be safely removed I am sure

[01:31] <audreyt> ok

[01:31] <stevan> TIMTOWTDI :)

[01:31] <audreyt> moving right along...

[01:32] <audreyt> closures and blocks.

[01:32] <audreyt> blocks are nonparametric closures?

[01:33] <stevan> yup

[01:33] <audreyt> ok, so block is essentially a speed hack

[01:33] <audreyt> or does it do something that violates liskov?

[01:33] <stevan> typing speed actually :)

[01:33] <stevan> I could use closure in all places I used block

[01:33] <stevan> but setting up a closure was more code

[01:34] <audreyt> yup, which is what I meant by liskov

[01:34] <stevan> :)

[01:34] <audreyt> okay, I'll just have one native code type then

[01:34] <stevan> yeah that works

[01:35] <audreyt> so, what is a NativeCode?

[01:35] <stevan> the primary use of blocks is for the do_while and do_until features :)

[01:35] <audreyt> an lexical environment, a signature of parameters, and a body?

[01:35] <stevan> yes pretty much

[01:35] * stevan stole this one from LISP

[01:36] <audreyt> there is one difference from Lisp though... the body of code is not perl6 code :)

[01:36] <audreyt> not even serialized perl6 code

[01:37] <audreyt> I recall we have discussed the idea of serializing the body

[01:37] <stevan> well yes, for now,.. but if the entire body of the code is msg sends,.. it should possibly be translatable (I think)

[01:37] <audreyt> into msg sens

[01:37] <audreyt> sends

[01:37] <stevan> yes :)

[01:37] <stevan> native code structures should only be in the native types

[01:37] <audreyt> because it won't ever be portable (or serializable) if it's a ref(CODE) :)

[01:37] <audreyt> (well, there's Storable which uses B::Deparse)

[01:37] <stevan> the MM and above should use all msg sends

[01:38] <audreyt> but it's icky

[01:38] <stevan> yeah

[01:38] <audreyt> anyway, I looked at all block->new instances

[01:38] <stevan> ok

[01:38] <audreyt> it looks like it's really only just message sends

[01:38] <audreyt> and nothing perl5 specific

[01:39] <stevan> yup

[01:39] <stevan> by the time it gets to Bootstrap.pm it should all be message sends 

[01:39] <audreyt> ok

[01:39] <stevan> I think the only non-msg send in Bootstrap is the opaque::send definition

[01:39] <audreyt> so body is really just a list of method calls.

[01:40] <stevan> yeah it could be thought of like that

[01:40] <audreyt> ok... so I'll make a tiny tiny language and serialize the method calls as structures

[01:40] <stevan> sure

[01:41] <audreyt> next question: peripheral types

[01:41] <audreyt> closure::signature, closure::params, closure::env

[01:42] <stevan> yessss

[01:42] <audreyt> we know that for each native type we have a boxed form

[01:42] <audreyt> and p6 demands autoboxing

[01:42] <stevan> yup

[01:42] <audreyt> so those three needs to be exposed as well, because they are used like first class objects in bootstrapping

[01:43] <audreyt> do they roughly corresponds to SigList, ParamList, Pad?

[01:43] <stevan> yes

[01:43] <audreyt> where Pad is something with a hash interface like %MY::

[01:43] <stevan> yup

[01:43] <audreyt> and how does it differ from a NativeStr->Native hash?

[01:44] <audreyt> (brb)

[01:44] <stevan> I chose to do closure::env more like a linked list 

[01:44] <stevan> which itself has a hash

[01:45] <stevan> the env has to point to it's parent

[01:45] <stevan> closure::env stores a next pointer to do this

[01:47] <audreyt> back

[01:47] <audreyt> so my design was NativeCode itself keeps a linked list of pads

[01:47] <audreyt> each pad being a simple NativeMap

[01:47] <stevan> sure

[01:47] <stevan> yup

[01:47] <audreyt> ok, that rids us of a mismatch

[01:47] <audreyt> (to userland)

[01:47] <stevan> sure

[01:48] <audreyt> now, signature.

[01:49] <audreyt> or rather, params.

[01:49] <stevan> ok

[01:49] <stevan> it is just a list of symbols

[01:49] <audreyt> where is closure::params defined?

[01:50] <audreyt> oh in Closure itsemf

[01:50] <stevan> in closure.pm

[01:50] <stevan> yes

[01:50] <audreyt> k, so it can be modeled as NativeSeq pointing to NativeStr

[01:50] <stevan> sure

[01:51] <audreyt> but does it have to be a NativeSeq? can we just use [NativeStr]?

[01:51] <audreyt> the question is relevant because the former makes it possible for other data types to serve as params

[01:51] <audreyt> by introducing message handlers that emulates a native list

[01:51] <stevan> would [NativeStr] be less exportable to userland?

[01:51] <audreyt> if there's no such possibility, I'll fold it back like "env"

[01:52] <stevan> ok

[01:52] <stevan> then it is up to you

[01:54] <audreyt> the params and pads are all finite, right?

[01:54] <stevan> yes I think so

[01:54] <stevan> well,... define finite

[01:54] <audreyt> not self recursive

[01:55] <audreyt> in some way

[01:55] <stevan> yes

[01:55] <audreyt> i.e. if you "print" it it will terminate

[01:55] <stevan> they are finite then

[01:55] <audreyt> ok. is the "body" structure ever useful without it being wrapped in Code?

[01:56] <audreyt> i.e. "$x.foo" without a pad or params that can bind $x to

[01:56] <audreyt> I'd argue no

[01:56] <stevan> no I dont see any real usage for that

[01:58] <audreyt> -- NativeCode

[01:58] <audreyt> -- body:   FiniteArray CodeExpression

[01:58] <audreyt> -- pads:   FiniteArray NativeMap

[01:58] <audreyt> -- params: FiniteArray NativeStr

[01:58] <audreyt> so that's all the structure there is, I presume

[01:58] <audreyt> where CodeExpression is not first-class

[01:58] <audreyt> i.e. user can't bind it to an object

[02:00] <audreyt> there's no lambda expressions (anonymous Code) in the body, right?

[02:00] <audreyt> it's all just nested message sends

[02:01] <stevan> hmm

[02:01] <stevan> yes

[02:01] <stevan> it can be all message sends

[02:01] <stevan> dispatcher does return a closure,.. but that can be changed too

[02:02] <audreyt> and it's fine

[02:02] <audreyt> returning a NativeCode is kosher

[02:02] <stevan> yup

[02:03] *** revdiabl1 is now known as revdiablo

[02:05] <audreyt> ok, I'm formalizing the code expression forms

[02:08] <wolverian> reading that dialogue has been the most exciting thing this week :)

[02:08] <stevan> :)

[02:08] <stevan> it has been quiet around here lately 

[02:09] <audreyt> stevan: so, literals in the native code bootstrap

[02:09] <audreyt> (think s-expr)

[02:09] <audreyt> (= sym LITERAL)

[02:09] <audreyt> is this the only form where you used LITERAL?

[02:09] <audreyt> or do you also use literals in message arguments?

[02:11] <stevan> the message string is a str

[02:11] <stevan>     $label = str->new($label) 

[02:11] <stevan>         unless (blessed($label) && $label->isa('str'));

[02:11] <audreyt> (or as message recipient)

[02:11] <stevan> but i made that optional 

[02:14] <audreyt> optional?

[02:14] <stevan> $obj->send("foo") # the literal "foo" gets converted to str->new("foo")

[02:14] <stevan> or is that not what you mean

[02:14] <audreyt> no, that's exactly what I mean :)

[02:14] <stevan> ok

[02:17] <audreyt> so the control forms are short-circuiting or/and

[02:17] <audreyt> plus "while"

[02:17] <audreyt> that's all?

[02:17] * stevan checks to see .........

[02:18] <stevan> there are a few do_until,.. but those should be easy to convert to do_while

[02:18] <stevan> list::each and list::apply are used too

[02:19] <audreyt> but those are messages

[02:19] <stevan> yes

[02:19] <stevan> so it do_until and do_while

[02:19] <audreyt> yes

[02:19] <stevan> those are messages on block

[02:19] <audreyt> but it's not and/or

[02:19] <stevan> and & or are message on bit

[02:19] <audreyt> because you fully evaluate message args

[02:19] <audreyt> however, and/or is not used like that

[02:19] <audreyt> they are short circuiting

[02:20] <stevan> yeah

[02:20] <audreyt> oh, that's why you pass a block!

[02:20] <stevan> yes

[02:20] <audreyt> it's used as thunks

[02:20] <stevan> yes

[02:20] <audreyt> yow :)

[02:20] * stevan stole this from lambda calc :)

[02:21] <audreyt> yup :)

[02:21] <audreyt> but blocks also capture pads

[02:22] <audreyt> so you just save the params part

[02:22] <stevan> your blocks do :)

[02:22] <audreyt> your blocks don't?

[02:22] <stevan> block has an env, but thats only so you have have a lexical env and refer to the OUTER:: lexical env

[02:22] <audreyt> oh ok.

[02:23] <stevan> I am not sure if this makes sense really,.. I was in new territory for me :)

[02:23] <audreyt> actually it makes a lot of sense :)

[02:23] <stevan> :)

[02:24] * audreyt thinks a bit

[02:25] * stevan flips audreyt's bit

[02:25] <audreyt> stevan: wait... closure > block in two ways

[02:25] <audreyt> params, explicit pads

[02:25] <audreyt> but you don't ever make use of explicit pads

[02:26] <audreyt> the only two closure->new calls have $::ENV passing $::ENV itself

[02:26] <audreyt> did I miss something?

[02:26] <stevan> well dont forget method isa closure

[02:26] <stevan> it just adds $?SELF, $?CLASS and $?PACKAGE to the local env

[02:26] <audreyt> yeah but that can be explicit (=) forms

[02:27] <stevan> WALKCLASS and WALKMETH are the only two closures I think

[02:27] <audreyt> prepended to the body

[02:27] <stevan> ok

[02:27] <stevan> so what are you thinking ?

[02:28] <audreyt> going to commit in a sec

[02:29] * stevan is glad audreyt is here now, cause that autrjus guy was starting to slack off ;)

[02:29] * audreyt smiles

[02:30] <audreyt> ok. so the expression only has three forms: literals, variable lookups, and message sends

[02:31] <stevan> define expression please

[02:31] <audreyt> whatever the body of a block can contain

[02:31] <audreyt> s/block/code/

[02:31] <stevan> yes

[02:32] <stevan> well variable lookups could become message sends to the env,.. but otherwise yes

[02:32] * audreyt thinks about message sends to the env

[02:33] <stevan> it could even be msg sends to the Code

[02:33] <stevan> self . env . lookup (LITERAL)

[02:33] <audreyt> sub f ($x) { $x }

[02:34] <audreyt> oh

[02:34] <audreyt> got it.

[02:35] <audreyt> but your expression only works because closure::env is destructive

[02:35] <audreyt> as it ultimately calls ->set

[02:35] <stevan> yes

[02:36] <audreyt> so it's either a Var form

[02:36] <audreyt> or an explicit "self" form that can introspect the current code

[02:36] <audreyt> and get env from there

[02:37] <stevan> or calling do() on the code passes the env and params 

[02:37] <audreyt> essentially limiting var lookup to $?SELF

[02:37] <stevan> yeah that would work (I think)

[02:38] <stevan> actually that should probably be $?SUB

[02:38] <stevan> instead of $?SELF

[02:38] <audreyt> k

[02:39] <audreyt> cool... we just reinvented fixpoint ;)

[02:39] <stevan> :)

[02:40] <stevan> reinvention is good... we know we are on the right track, and can also benifit from other peoples mistakes 

[02:40] <audreyt> *nod*

[02:42] <audreyt> k, committing

[02:43] <tewk_> Wow what a conversation, reminds me of the IO language and EOPL

[02:43] <audreyt> hm

[02:44] <audreyt> stevan: do you use $?BLOCK for anything but .env ?

[02:44] <audreyt> i.e. do you really use recursion?

[02:44] * stevan thinks...

[02:44] <audreyt> (assuming the explicit .do_while form is there)

[02:45] <stevan> MRO is recursive, but that can be removed if we make a native C3 method like in PIR/Parrot

[02:46] <stevan> all recursion can be worked around,.. not need to support it with $?BLOCK

[02:46] <audreyt> because it's isomorphic

[02:46] <audreyt> whether we have $?BLOCK as primitive and $?BLOCK.env as the pad

[02:46] <audreyt> or %::MY as primitive and %::MY<$?BLOCK> as the block

[02:47] <audreyt> if you don't make use of explicit $?BLOCK.apply(..args...) fixpoint form, then I'll make variable lookup the primitive

[02:48] <audreyt> I mean, making retrival of current lexical environment the primitive

[02:48] <stevan> ok

[02:48] <audreyt> purely as an optimize-for-common-case

[02:49] <audreyt> do you explicitly use OUTER:: in bootstrapping?

[02:49] <audreyt> i.e. is there any lexical lookup that involves exposing the linked list structure?

[02:49] <audreyt> I don't see one, but it's safer to check

[02:49] <stevan> no, there shouldnt be

[02:50] <audreyt> ok... then variable lookup is the primitive.

[02:51] <audreyt> yay it compiles.

[02:51] <stevan> ship it!!!

[02:53] <audreyt> now the fun part

[02:53] <audreyt> writing coercion for code

[02:53] <audreyt> how does closures cast to other types?

[02:54] <stevan> badly

[02:54] <audreyt> I'd imagine

[02:54] <stevan> I basically used the same kludge as references 

[02:54] <stevan> stringify/numify the native code ref

[02:54] <stevan> bit was always true IIRC

[02:55] <audreyt> mm.

[02:55] <audreyt> ok, make it an error seems easiest

[02:55] <stevan> yes

[02:56] <stevan> this looks like ti might be interesting : http://lambda-the-ultimate.org/node/view/1166

[02:58] <stevan> hey fglock 

[02:58] <audreyt> stevan: verily

[02:59] * audreyt adds it to her to-read list (currently still blocked by code complete 2 by 400 pages)

[02:59] <stevan> at first skim it looks like the sig/structure silliness I was talking a little while back 

[02:59] <audreyt> stevan: yup, but proving it became SomeOneElse'sProblem :)

[02:59] <fglock> hi stevan, audreyt

[03:00] * stevan loves delegating, especially when it is automatic :P

[03:00] <stevan> s/automatic/implicit/

[03:01] <audreyt> s/implicit/unsuspected/

[03:01] <audreyt> (as in "unsuspected minions")

[03:02] <audreyt> stevan: hm. actually, any attempt to use nil as a Int is an error, no?

[03:02] <audreyt> (in bootstrapping code)

[03:02] <audreyt> or did you abuse its coercion deliberately?

[03:02] <stevan> I dont recall actually

[03:02] <audreyt> mmm.

[03:03] <audreyt> ok. maybe coercion is fine for nils but sending it messages causes the original error to happen

[03:03] <audreyt> I think that's the semantic -- at least under "no fatal" which is default

[03:04] <stevan> that makes sense

[03:04] <audreyt> %ENV{no_such_key} + 1; # 1

[03:05] <stevan> would that become %ENV{no_such_key}->to_num + 1

[03:05] <stevan> this is maybe where nil and undef are different

[03:05] <audreyt> honestly I don't know :)

[03:05] <stevan> undef should coerce,.. nil shouldnt

[03:06] <audreyt> larry may say ->to_complex

[03:06] <audreyt> but is too_complex

[03:06] <stevan> :)

[03:06] <audreyt> p09 mandates native unboxed support for complex numbers though

[03:06] <audreyt> I mean s09

[03:06] * stevan never understood complex numbers .... 

[03:07] <fglock> audreyt: I think it means the same as in compact arrays (pdl)

[03:07] <fglock> complex numbers are just an array of 2 elements

[03:07] <audreyt> fglock: yup, but then that means num is not the highest in unboxed numeric tower

[03:08] <fglock> you don't need to support this in the MM, because it is unboxed

[03:08] <audreyt> but "complex" is also unboxed

[03:08] <audreyt> otherwise it would be "Complex"

[03:08] <audreyt> or am I missing something

[03:09] <fglock> think compact array - it looks like Array, but it is stored as unboxed

[03:09] <audreyt> you mean "complex" is just bounded array of two

[03:09] <fglock> yes

[03:09] <audreyt> I think I can ask this question operationally.

[03:09] <audreyt> pugs -e 'say sqrt(-1)'

[03:09] <audreyt> is this an error or not :)

[03:10] <fridim> hi all

[03:10] <audreyt> if it is not, is it a NaN, i, or undef?

[03:10] <audreyt> if it's i, then the runtime needs to recognize complex as native type

[03:10] <audreyt> fridim: greetings

[03:10] <fridim> I would like to see an example (else than cpan's one) of using of perl6::classes

[03:11] <fglock> how about: sqrt( complex( -1 ) ), where complex() is a type

[03:11] <audreyt> fridim: I think that module is unmaintained

[03:11] <fridim> oh

[03:12] <fridim> Are you using perl6 ? and if yes, how could i run it ? with parrot ?

[03:12] <audreyt> fridim: you can download it from http://pugscode.org/

[03:12] <stevan> fridim: no with Pugs

[03:12] <audreyt> but it's an early alpha, we are still working on it.

[03:13] <fglock> I mean sqrt( complex( -1, 0 ) )

[03:13] <fridim> ok I look

[03:13] <fridim> Haskell ?

[03:13] <fglock> but sqrt(-1) would be an error, I think

[03:13] <audreyt> fridim: which platform (operating system) are you on?

[03:14] <fridim> linux (debian sid)

[03:14] <audreyt> fridim: "apt-get install pugs"

[03:14] <fridim> aptitude install pugs in my case ;-)

[03:14] <audreyt> sorry for not running debian :)

[03:15] <fglock> audreyt: I made some tests with PIL2 and Classes

[03:15] <audreyt> fglock: ok, I think Complex can go from native runtime then

[03:15] <audreyt> (it's not like parrot has a C register type either)

[03:15] <audreyt> we'd need to use two N registers to emulate a complex when it comes to that

[03:16] <fridim> I'am interested in perl6, because of curiosity (?), but when can i expect to see perl6 out ?

[03:17] <audreyt> fridim: you should be able to use perl6 productively sometime next year. but we don't yet know when it will be marked as final release.

[03:17] <audreyt> to satisfy your curiosity though, pugs is here and would work well for that purpose :)

[03:18] <fridim> thanks :-)

[03:18] <audreyt> stevan: explain this "nil shouldn't coerce" idea

[03:18] <audreyt> @foo[999] + 1;

[03:18] <audreyt> vs

[03:18] <audreyt> @foo[999] = undef; @foo[999] + 1;

[03:18] <audreyt> you're saying there should be a difference?

[03:18] <audreyt> (assuming @foo is empty)

[03:19] <audreyt> fglock: cool, I'll check the tests out. 

[03:19] <fglock> audreyt: 'Complex' can be 2 N registers, but 'complex' would be native array of int|num with shape 0..1

[03:19] <audreyt> fglock: also I removed Complex from native types for now... they are too complex

[03:19] <stevan> well, I gues the idea is that things which shouldnt coerce would be nil

[03:19] <stevan> and things that should coerce are undef

[03:19] <audreyt> fglock: gotcha

[03:19] <stevan> just drawing a line thats all

[03:20] <audreyt> stevan: I wonder what are the things that should not coerce...

[03:20] * stevan wonders too :)

[03:20] <fglock> audreyt: may I post some results if you don't mind?

[03:21] <fglock> I compiled this: 'Class c; method m( Int @a) {1+1}'

[03:22] <fglock> result: &main::m ($?SELF! is rw : Int @a!, Hash *%_!) { (&infix:<+>(1, 1));  }  (&Class((&c())));

[03:23] <fglock> there are some problems - $?SELF! should have a type; the class name should be a constant, I think

[03:24] <audreyt> the trailing ! is "is required"?

[03:24] <fglock> yes

[03:24] <audreyt> fglock: yes. I'm moving away from hooks into serialized opaques. just give me another day or two :)

[03:24] <fglock> ok!

[03:24] <audreyt> stevan: still around?

[03:24] <stevan> yes

[03:27] <audreyt> stevan: ok. three other types

[03:27] <audreyt> Opaque, Attribute, Method

[03:28] <audreyt> stevan: let's start with the easy one (Method)

[03:28] <stevan> just wraps the Code type

[03:28] <stevan> it enforces a $self parameter is passed

[03:28] <stevan> and maps $?SELF, $?CLASS and $?PACKAGE

[03:28] <stevan> it should also deal with $?ROLE as well

[03:29] <audreyt> yup. but if we do that at method insertion time and prepends the neccessary stuff to the generated Code, it can go, right?

[03:29] <stevan> sure

[03:30] <audreyt> and same for Attr vs String

[03:30] <audreyt> because it's doing the lexer's job in the runtime

[03:31] <audreyt> so that leaves Opaque

[03:31] <stevan> its just a compound type

[03:31] <stevan> its built from the other types 

[03:32] <audreyt> but it's also mutable

[03:32] <audreyt> except for Id, the two other fields can get reassigned

[03:32] <stevan> well

[03:32] <stevan> the class can be

[03:32] <audreyt> (note that NativeMap here is immutable)

[03:32] <stevan> but the map of attributes need not be reassigned

[03:33] <stevan> you just add to the map

[03:33] <audreyt> yeah, but map here is immutable, so you can't add anything to it :)

[03:33] <stevan> oh wait

[03:33] <stevan> we need to be able to add to it

[03:33] <audreyt> yup

[03:33] <stevan> when you dynamically add attrs

[03:33] <audreyt> that's what I meant but mutable

[03:33] <audreyt> yes

[03:33] <stevan> ok

[03:34] <stevan> so you would create a new immutable map with the new attr?

[03:34] <audreyt> ok. coertion to and from opaque.

[03:34] <audreyt> stevan: lazily updating it. it's haskell, all memory are shared

[03:34] <stevan> :)

[03:34] <audreyt> no memcpy() involved

[03:34] <audreyt> how does opaque coerce with by-value types?

[03:34] <audreyt> does unboxed "int" magically becomes an opaque object with Int class?

[03:35] <stevan> they always coerce to true

[03:35] <audreyt> that's how I would imagine it

[03:35] <stevan> yes, int -> Int

[03:35] <audreyt> okay. how about opaque->int

[03:35] <audreyt> do we send as_int message to it?

[03:35] <stevan> I would imagine it would be like in p5

[03:35] <stevan> it would return the obj id

[03:36] * stevan is not sure about that

[03:36] <audreyt> in pugs's current runtime it's an error

[03:36] <audreyt> also if we don't define as_int or something like that

[03:36] <audreyt> you can't ever write a MyInt to masquerate as Int

[03:37] <audreyt> because there's no control for native coercion

[03:37] <audreyt> so I think we go the normal (i.e. python, ruby) way instead of the insane (i.e. perl5) way

[03:37] <fglock> audreyt: opaque->Int->int ?

[03:37] <audreyt> fglock: depends...

[03:38] <audreyt> method as_int { 1 };

[03:38] <audreyt> does not need to go thru ->Int part

[03:42] <fglock> audreyt: re complex - it can hold more than 2 elements (a "tensor" in s09)

[03:44] <audreyt> fglock: gotcha -- we need someone more PDL minded to write the runtime casting and methods for complex

[03:44] <audreyt> for now I'm leaving them out

[03:46] <stevan> audreyt: how are we doing? 

[03:46] <audreyt> stevan: I've finished the layout of all value types

[03:46] <stevan> ok

[03:46] <stevan> excellent

[03:46] <audreyt> sanity check them?

[03:46] <audreyt> (r8145)

[03:46] <stevan> audreyt++ #

[03:46] <audreyt> will now move to container types

[03:46] <stevan> same place src/PIL/Native?

[03:46] <audreyt> yeah

[03:46] <audreyt> actually we probably wouldn't need container types for any of bootstrapping

[03:47] <stevan> nope

[03:47] <audreyt> excellent. I'll now port your bootstrap code.

[03:47] <audreyt> (brb)

[03:47] <stevan> any area past MM bootstrap is still fuzzy for me

[03:47] <audreyt> nodnod

[03:47] <audreyt> feel free to sprinkle Native.hs with comments

[03:48] <audreyt> if there's any line you can't grok, please add 

[03:48] <audreyt> -- XXX

[03:48] <audreyt> and I'll try to explain them.

[03:48] <audreyt> (in the code, not on irc)

[03:48] <audreyt> you may notice that my identifier names are much longer this time around :)

[03:52] <stevan> audreyt: I think I grok it all

[03:53] <stevan> my Haskell-fu has always been fairly weak

[03:53] <stevan> but it seems to make sense 

[03:53] <fglock> audreyt: Array/List are going to be real 'Object'->'Container' things now?

[03:53] <stevan> fglock: yes

[03:54] <fglock> :)

[03:54] <stevan> the design we were just discussing is loosely based on this diagram

[03:54] <stevan> http://svn.openfoundry.org/pugs/perl5/Perl6-MetaModel/docs/Object_Space.jpg

[03:55] <stevan> Scalar, Array and Hash will all be MM classes

[03:56] <fglock> no 'array' in the core runtime?

[03:57] <stevan> fglock: there will be some sequencable type,.. call it list, array, floober... whatever you like :)

[04:01] <audreyt> fglock: Seq and Map are immutable one-dimentional stuff

[04:01] <audreyt> fglock: in your laziness.txt they are "array" and "hash"

[04:02] <audreyt> I deliberately used different names to avoid confusion 

[04:02] <audreyt> (the names are incidentally from the YAML spec)

[04:02] <fglock> are closures clonable? - such that (1..1000).clone gives 2 independent generators - that would fix a problem I've had with map() on lazy lists

[04:02] <audreyt> fglock: sure, I don't see why not. and it's a range not a closure anyway

[04:02] <fglock> audreyt: ok

[04:02] <audreyt> oh, a language idea

[04:03] <audreyt> alias and I were discussing the idea of getting rid of global variables

[04:03] <audreyt> namely, $*IN and %*ENV becomes $+IN and %+ENV

[04:03] <audreyt> the idea is the object space runner binds those stuff lexically as the outermost caller frame

[04:03] <stevan> audreyt: I have to run, are we good for now?

[04:03] <audreyt> as "env" vars

[04:04] <audreyt> stevan: yes. I'll let you know when I finished bootstrapping

[04:04] <stevan> yes, no globals, your program is wrapped inside one big closure :)

[04:04] <audreyt> yup

[04:04] <fglock> audreyt: that was a bad example - I meant closures - because when you map() a range you end up with a closure on the range, and you need to have a way to clone this thing

[04:04] <stevan> audreyt: cool, I will check in later and see :)

[04:04] <audreyt> and the symbol * is heavily overloaded anyway

[04:04] <audreyt> and global variables are oh-so-hard to optimize.

[04:05] <audreyt> and "our" variables are still there anyway.

[04:05] <audreyt> I still can't find a good example of useful cross-class truly global lookup-defeating variables.

[04:07] <audreyt> fglock: yes. closures will definitely be clonable.

[04:07] <audreyt> although that only applies to upper-case Code and Block, not lowercase ones

[04:07] <audreyt> but that's okay, because unboxed "block" is not exposed to language level, hurray.

[04:09] * audreyt goes to lunch (and reputedly a 2-hr walk to a nearby rain forest)

[04:09] <audreyt> but may become 3

[04:09] <audreyt> so... bbl :-) *wave*

[04:09] <fglock> bye!

[05:27] <Alias_> ARRRRR!

[06:59] <gaal> audreyt: ping and how was the walk? :_

[06:59] <gaal> )

[07:01] <audreyt> gaal: pong, give me 5 mins, let me finish the parser for the bootstrapping language

[07:01] <audreyt> the walk was nonexistent... we never found the rain forest. it's too elusive

[07:02] <gaal> ah, the Elusive Rainforest!

[07:04] <Alias_> There's not much left...

[07:04] <Alias_> At least we probably missed it to the north and not the south... otherwise we would have ended up in the swamp

[07:05] <gaal> the South Swamp! This sounds like some fairy tale to me :)

[07:05] <Alias_> It kind of is :)

[07:05] <Alias_> It used to be the home of the "Big Fig"

[07:06] <Alias_> A tree so large it towered above the rest of the canopy

[07:06] <Alias_> In fact, so large it was spotted from the ocean by Captain Cook and noted in his logs when he first found autralia

[07:06] <gaal> !!

[07:06] <gaal> what happened to it?

[07:07] <Alias_> It fell down in an enormous wind storm about 50 years ago

[07:07] <gaal> ouch :(

[07:07] <Alias_> I remember seeing the trunk when I was a kid, say 20 years ago

[07:07] <gaal> d'you remember what tree it was? (species that is)

[07:08] <Alias_> Probably a strangler fig

[07:08] <Alias_> It took 45-50 years for the bugs and fungus to eat the trunk away

[07:08] <Alias_> 5-10 metres across

[07:08] <Alias_> enormous buttresses

[07:09] <gaal> oh, nature. oh, wikipedia: http://en.wikipedia.org/wiki/Strangler_fig

[07:09] <gaal> "

[07:09] <gaal> Strangler figs begin their lives as parasites as their seed lodge in the cracks and crevices of the bark of a host..."

[07:10] <Alias_> I took RENEEB out there a few months ago

[07:10] <Alias_> There's a shot of him around (probably on his memory card) with a 5 metres tree there

[07:11] <Alias_> http://www.screenworks.com.au/locations/index.php?c=13&i=230

[07:11] <Alias_> Something like that

[07:12] <Alias_> aha!

[07:12] <Alias_> http://www.lismore.nsw.gov.au/tourism/001/view_doc.asp?id=212&cat=21

[07:12] <Alias_> Ah, fell in 1987

[07:13] <Alias_> Except it lost some ... erm... big pieces over the century before that :)

[07:13] <gaal> wow

[07:13] <Alias_> ok, and moreton bay fig, not strangler

[07:14] <Alias_> but yeah, fracking huge

[07:14] * gaal recently learned about the biggest tree

[07:14] <gaal> it's a whole grove of one aspen really

[07:15] <gaal> weighs about 6500 tons(!)

[07:15] <gaal> all interconnected with aerial roots

[07:16] <Alias_> yeah... although it's hard to see how that counts as "a tree"

[07:16] <Alias_> You kind of need to create a new category

[07:16] <Alias_> "Composite vegetable life"

[07:16] <Alias_> Like that enormous box hedge thing

[07:17] <gaal> there are a few reasons

[07:17] <Alias_> ooo, "collective vegetation"

[07:17] <Alias_> Borgish

[07:17] <gaal> it's one DNA

[07:17] <Alias_> right

[07:17] <Alias_> I get the reason why

[07:17] <gaal> and if one part is hungry, the others feed it

[07:17] <gaal> and there is in fact physical continuity.

[07:17] <Alias_> I just find it a little iffy in regards to comparing it to something with a single superstructure

[07:17] <gaal> there's a creepier (and iffier) example:

[07:18] <gaal> in oregon there's a honey mushroom spread across almost 9 acres

[07:18] <gaal> (!!!!!!)

[07:18] <gaal> but nobody knows if it's physically connected.

[07:18] <Alias_> Nothing can be creepier than the things TorgoX saw spawning in his harbour

[07:18] <gaal> do I want to hear? :)

[07:19] <Alias_> Some sort of weird green worm thing with thousands of little flippers

[07:19] <gaal> the the water? a worm? how large?

[07:19] <Alias_> It's head detaches from it's body, turns into a sexual organ, and floats to the surface where it emits green goo

[07:19] <Alias_> The whole family of animals is really screwy

[07:20] <Alias_> You'd have to ask him about what it actually was, I forget the details

[07:20] <gaal> I think we are genetically programmed to emit an "ewww!" sound whenever we think of green goo.

[07:21] <Alias_> Coming from a country primarily designed for chemical warfare, I'd say it's because we are wired to fight on another level

[07:21] <Alias_> brains beat chemistry, so in most places there aren't many chemistry-oriented things left

[07:22] <audreyt> gaal: are you going to be around for at least another 30 min or so?

[07:22] <audreyt> (I'd like to finish the parser)

[07:22] <Alias_> (sorry, I'm distracting)

[07:22] * Alias_ goes back to work

[07:22] <gaal> audreyt: sure

[07:23] <gaal> Alias_: NAK on the "country primarily designed" bit...

[07:26] <Alias_> NAK?

[07:26] <gaal> "I didn't get it"

[07:26] <Alias_> If you look around Australia (where I'm from) it seems to be "designed" for another time.

[07:27] <Alias_> When most of the interspecies warfare was done at a chemistry level, rather than claws/teeth/brains

[07:27] <Alias_> But it also applies to the plants too

[07:27] <Alias_> Eucolyptus trees leech alkalines into the soil to kill other trees, etc

[07:27] <gaal> so, venom and phermones?

[07:27] <Alias_> all sorts of stuff, yeah

[07:28] <gaal> they do? we have plenty of them here, imported from australia some I don't know, 70 years ago

[07:28] <gaal> that must expain why we have ONLY them now. j/k :-)

[07:28] <Alias_> They are considered a pest in large parts of africa

[07:29] <Alias_> A eucolypt forest is quite sparse with no undergrowth

[07:29] <Alias_> or at least, little undergrowth

[07:29] <Alias_> where is "here"

[07:29] <gaal> .il

[07:30] <Alias_> eep

[07:30] <Alias_> You guys have enough issues with toxic humans

[07:31] <gaal> hey, maybe the trees leak toxicity in general and it was all the aussies' fault?

[07:31] <Alias_> The day we feel like we "control" the country is the day it becomes a worse place

[07:31] <gaal> in fact, given the local constellation, it's enough if they leak toxicity *to generals*.

[07:32] <Alias_> You still kind of just try to gently influence nature here

[07:33] <gaal> big land, complex ecosystem.

[07:34] <Alias_> emphasis on the big

[07:34] <gaal> here it's small land, complex ecosystem.

[07:34] <Alias_> and humans gradually bulldozing everything to build stuff

[07:36] <gaal> well, yes, but there are a few relatively big areas left open that will stay open for a while.

[07:52] * gaal makes tea

[08:11] <audreyt> all done :)

[08:11] <audreyt> gaal: still there?

[08:14] <gaal> yes, hello again :)

[08:15] <gaal> so I think we need to start by refactoring Exp to get an Annotation node, right? You of course saw this months ago.

[08:16] <gaal> Ann can encapsulate Cxt, Pos and [Prag]

[08:17] <gaal> data Ann Cxt !Cxt | Pos !Pos | Prag ![Prag]   ?

[08:17] <audreyt> that sounds sane, yes

[08:18] <audreyt> and a form of Exp that reads

[08:18] <audreyt> Ann !Ann !Exp

[08:18] <audreyt> I think that's all there it is

[08:18] <audreyt> basically put every unwrappable stuff into it

[08:19] <gaal> now, what's not clear to me is where annotations need to be added - is there anything common between cxt and pos and prag in that respect?

[08:19] <gaal> eg pragma lists are supposed to come per "statement"

[08:20] <gaal> this structure can express annotations over any Exp, but is that too loose?

[08:23] <audreyt> so, we have discusses adding it to the Stmts form instead

[08:23] <audreyt> but I think it makes sense to just leave it as child to Exp

[08:23] <audreyt> because: 1. we are not pretty printing Exp back to perl6, so roundtrip safety is no concern

[08:24] <audreyt> 2. they really do share unwrap logic

[08:24] <audreyt> 3. it's easier to implement

[08:24] <svnbot6> r8149 | autrijus++ | * Native runcore minilanguage parser is ready -- this is the

[08:24] <svnbot6> r8149 | autrijus++ |   minilanguage we are going to write the bootstrapping code in.

[08:24] <svnbot6> r8149 | autrijus++ |   It's isomorphic to Stevan's s-expression model but with a 

[08:24] <svnbot6> r8149 | autrijus++ |   much better syntax.  Details later.

[08:24] <svnbot6> r8149 | autrijus++ | * "make pil" now builds a parser shell to this minilang. 

[08:24] <audreyt> 4. Exp is the parse tree, not the semantic tree, so it's okay to have bogus stuff

[08:24] <gaal> in the case of pragmas, it would have made sense -- but not fot the others your points are valid :)

[08:24] <gaal> (missing ";" after "others" in that sentence)

[08:24] <audreyt> :)

[08:24] <audreyt> so, I think go for it

[08:25] <gaal> ok, let me see where this leads me.

[08:27] <gaal> btw, when you are in refactoring mode, do you keep a ghci and do :r, or do you :make from vim?

[08:27] <gaal> (i love vim's quickfix, but in the case of pugs make is slow)

[08:28] <gaal> errrrr, eep? make ghci doesn't work now?

[08:28] <audreyt> eep?

[08:28] <gaal> it loads some Main but it does it too fast

[08:28] <audreyt> it worksforme

[08:28] <audreyt> oh. right. it's using the .a file

[08:29] <gaal> oh, right

[08:29] <audreyt> and to answer your question, I use "make pili"

[08:29] <audreyt> it may make sense to revert ghci to use src/* instead

[08:29] <audreyt> instead of the .a file

[08:29] <audreyt> but that's icky... because we are now keeping .hi and .o in dist/

[08:30] <audreyt> pugs make is okay if you put -O0 to config.yml

[08:30] <gaal> weird, "make pili" gives me an error about FastPackedString.hs

[08:30] <audreyt> fixing

[08:31] <gaal> :make via vim does the whole directory walk, which is usually unecessary in a dev cycle

[08:31] <audreyt> fixed

[08:32] <audreyt> (r8150)

[08:33] <svnbot6> r8150 | autrijus++ | * "make pili" should build "make pil" first. reported by gaal++

[08:35] <gaal> hmm. what's the latest word on precompiling prelude in unoptimized builds? it'll probably take forever, no?

[08:35] <gaal> we wanted to put back prelude source inlining, did anyone get to do it?

[08:36] <gaal> eh. ran "make" on a broken pugs (just at the start of a refactoring), it stopped; then i ran "make pili" and it looks like it worked. but Pugs.AST.Internals can't be available...

[08:36] <audreyt> gaal: source inlining -- I implemented it.

[08:37] <gaal> oh, great.

[08:37] <gaal> audreyt++

[08:37] <audreyt> gaal: the pili/pil tree does not interfere with the main ghci/pugs tree

[08:37] <audreyt> the latest word is that the Exp->Haskell form needs to be replaced with the "bytecode"

[08:38] <gaal> :-)

[08:38] <audreyt> which is the NativeLang thing I'm doing here

[08:38] <gaal> drifted pil?

[08:38] <audreyt> pil is even higher level... this is decomposed everything to lexical lookup, literals and method calls

[08:38] <audreyt> hence "native"

[08:38] <audreyt> as in runtime independent; virtually no codegen needed

[08:39] <audreyt> (assuming the target can do lexical lookup, literals and method calls natively)

[08:39] <audreyt> which is like, all of them

[08:39] <audreyt> not sure if this idea is going to work; but it's needed for the metamodel boostrap, so at least for the new runcore internalls

[08:40] <audreyt> so even if we don't codegen from here to (say) Perl5 because it's going to be grossly inefficient

[08:40] <audreyt> it can still be the PreludePC data structure

[08:40] <audreyt> because it's pure value (i.e. not some monadic code), compilation time and heap use will be much reduced.

[08:40] <audreyt> give me another week or so :)

[08:40] <gaal> :)

[08:51] <gaal> extract is confusing me :)

[08:52] <audreyt> how so?

[08:53] <gaal> its purpose is to turn ??? an expression and a list of unconsumed strings to a better-constructed expression that consumed part of the strings?

[08:54] <audreyt> please give it a better name

[08:54] <audreyt> it's doing only one thing

[08:54] <audreyt> which is extracting the implicit parameter list

[08:54] <audreyt> from a syntax tree

[08:54] <audreyt> like $^a $^b

[08:55] <audreyt> taking the previously accumulated set of syms as argument

[08:55] <audreyt> and return the rewritten Exp (with all ^ from implicits removed)

[08:55] <audreyt> and the accumulated set of syms

[08:55] <audreyt> it's implemented as a List but actually a set because of nub

[08:56] <gaal> why are Cxt &co. even mentioned there then?

[08:56] <audreyt> they are passthru'ed.

[08:57] <audreyt> because you need to preserve Ann

[08:57] <audreyt> but extract downward

[08:57] <audreyt> so just take the Pos case and change Pos to Ann

[08:57] <gaal> so, we're deducing placeholders vars yes?

[08:57] <audreyt> that'd be a correct implementation

[08:57] <audreyt> yes, at the parser level

[08:58] <audreyt> so maybe call that function extractPlaceholderVariables

[08:58] <gaal> what's that given/when case there? deducing $_?

[08:58] <audreyt> yes, because $_ is also implicit

[08:58] <gaal> @hoogle nub

[08:58] <gaal> er, not here.

[08:59] <audreyt> 19:58 < lambdabot> forall a. (Eq a) => [a] -> [a]

[08:59] <audreyt> remove duplicates

[08:59] <gaal> like unix uniq?

[08:59] <gaal> or for real?

[08:59] <audreyt> for real

[08:59] <audreyt> unlike uniq

[08:59] <gaal> but slower

[08:59] <gaal> OK

[08:59] <audreyt> should probably use a real Set there

[08:59] <audreyt> but whatever :)

[08:59] <gaal> yeah

[08:59] <audreyt> no need to microoptimize (yet)

[08:59] <gaal> ack.

[09:00] <audreyt> ...unless you really feel like to

[09:00] <gaal> one thing at a time :)

[09:02] <gaal> can pattern matching go deep? eg Pugs.AST:131

[09:02] <gaal> now can't stay x@(Pos pos (Syn syn _))

[09:02] <gaal> oh wait

[09:02] <gaal> the answer is staring at my face

[09:03] <gaal> x@((Ann (Pos pos) (Syn syn _))) modulo syntax

[09:03] <audreyt> :)

[09:03] <audreyt> and yes, it goes deeparbitrarily

[09:04] <gaal> haskell++ # if someone would have told me of this feature, I'd give them a weird look, but now, I'm impressed yet again

[09:16] <gaal> pandora++

[09:16] <gaal> soooo much fun

[09:26] <gaal> argh, I still need some syntax calibration :/

[09:27] <gaal> Instead of Pos being a form of Exp, now it is a form of Ann which is a form of Exp

[09:28] <gaal> I should be able to figure this out! But it hasn't happened yet and I want to get on :(

[09:28] * audreyt calibrates gaal

[09:28] <audreyt> yay, pretty printing works for the minilang.

[09:29] <audreyt> now an evaluator.

[09:29] <gaal> wheee!

[09:29] <gaal> so give me a hint please

[09:30] <gaal> re: that "modulo syntax line

[09:31] <audreyt> er...you do it by

[09:31] <audreyt> s/Pos/Ann/

[09:31] <audreyt> s/pos/ann/

[09:31] <svnbot6> r8151 | autrijus++ | * pretty printing works for the native minilang.

[09:31] <svnbot6> r8151 | autrijus++ | * parens are now optional in minilang surface syntax if the

[09:31] <svnbot6> r8151 | autrijus++ |   method call takes no arguments.

[09:31] <audreyt> done

[09:31] <audreyt> that was the whole point :)

[09:33] <gaal> word.

[09:34] <gaal> yeah, abstraction

[09:35] <gaal> which is something that makes things easier for brains that have been made sufficiently fluid.

[09:41] <r0nny> yo

[09:41] * audreyt goes adding "Instance" to the runtime

[09:41] <audreyt> r0nny: yo

[09:42] <audreyt> (brb)

[09:43] <r0nny> well - im updating pugs - hope the problems with data-less clases are fixed

[09:50] <gaal> src/Pugs/Bind.hs:107:28: Couldn't match `Exp' against `Ann'

[09:51] <gaal> but surely, Ann *is* an Exp?

[09:54] <luqui> do you mean Ann the data constructor or Ann the type?

[09:54] * luqui is just guessing, he doesn't have time to look at anything

[09:54] <gaal> yes, you're right: in Exp, there's Ann !Ann !Exp

[09:55] <gaal> and a Cxt is not a form of Exp any longer

[09:55] <gaal> so I need to construct an Ann (Exp form) from my ann (thing of a type)

[09:56] <gaal> errr, I have an Exp to much thn.

[09:57] <gaal> data Ann = Cxt !Cxt !Exp | etc., or shouldn't it be just

[09:57] <gaal> data Ann = Cxt !Cxt | Pos !Pos | ...

[09:57] <gaal> ?

[09:57] <gaal> the !Exp chaining comes only in one place

[10:06] <gaal> OK, I think I got it.

[10:12] * Alias_ kidnaps audreyt for dinner with his family

[10:12] <Alias_> Back in hourish

[10:12] <gaal> bon mousse!

[10:22] <audreyt> gaal: the later

[10:23] <audreyt> dinner, bbiab &

[10:26] <gaal> audreyt: yes, got it and making progress.

[10:43] <svnbot6> r8152 | bsb++ |  r26@rex:  bsb | 2005-12-10 11:35:46 +0100

[10:43] <svnbot6> r8152 | bsb++ |  Update INSTALL's parrot 0.3.0 embedding caveat

[10:46] <gaal> looks like it works; rebuilding an optimized version for smokes.

[10:54] <r0nny> anyone there 

[10:55] <r0nny> when will the serious bugs be fixed (like defined vars are seen as undefined in some cases, and in others not)

[10:58] <gaal> r0nny: are there tests for that?

[11:11] <r0nny> gaal: i have no idea

[11:11] <r0nny> and i have no idea what chaused this behave (some revision earlyer it worked fine)

[11:15] <gaal> r0nny: could you add a test to t/pugsbugs then please?

[11:17] <r0nny> but what to test ? i have no idea how this bahave works

[11:18] <gaal> I didn't hear of this problem before, do you remember when it was discussed at least?

[11:18] <r0nny> no

[11:19] <r0nny> but i asked a few times, and was ignored

[11:20] <gaal> sec, this is a problem you encountered yourself, or did you see people talk about it?

[11:21] <r0nny> im not sure - there where some days where i wasnt here

[11:21] <r0nny> but the problem exists since last week

[11:22] <gaal> you aren't helping me understand what the problem is :)

[11:23] <r0nny> i have a class, wich has a attribute - this atribute gets a instance of another class in the build method - canning ref on the attribute tells me the class name of it, calling defined tells me _FALSE_

[11:23] <r0nny> s/canning/calling/

[11:23] * gaal looks in pugsbugs

[11:26] <gaal> r0nny: I don't see anything like it in t/pugsbugs. Could you submit a test case please?

[11:26] <r0nny> gona try to write one

[11:27] <gaal> thanks!

[11:29] <gaal> hmmm, I'm getting linker errors, has anyone been seeing things like this?

[11:30] <r0nny> wich version ?

[11:30] <r0nny> i made Version: 6.2.10 (r8151)

[11:30] <gaal> http://sial.org/pbot/14871

[11:31] <gaal> '52.

[11:31] <gaal> 8152 that is.

[11:32] <r0nny> hmm

[11:32] <r0nny> make clean or make realclean ?

[11:32] <gaal> this probably has to do with parrot.

[11:32] <r0nny> gona try if it compiles for me

[11:32] <gaal> bdb, ping

[11:32] <gaal> bsb even

[11:33] <bsb> yup

[11:33] <r0nny> if it fails, im gona install recent svn parrot

[11:33] <r0nny> i wrote ebuilds for parrot and pugs can install the recent svn version

[11:33] <gaal> just did.

[11:34] <r0nny> hmm

[11:34] <r0nny> btw - pugs needs to inherit from ghc-package or something

[11:34] <r0nny> else one of the compiling backends wont work

[11:39] <bsb> gaal: pong

[11:40] <gaal> hey. actually I'm no longer sure this is has to do with parrot.

[11:40] <r0nny> gaal: the test i wrote ends up in a endless loop

[11:40] <gaal> but, bsb, did you manage to build the latest r?

[11:40] <r0nny> gaal: and it does inexppected stuff

[11:41] <gaal> r0nny: is there a way to make it display your bug without doing that?

[11:42] <r0nny> gona try

[11:45] <bsb> Do you mean with parrot embedded? no

[11:47] <bsb> I just remove the reference to 0.3.0 being the latest (if this what you're talking about?)

[11:47] <gaal> OK. Since you sent in a patch, I presumed you made a build lately. never mind :)

[11:49] <bsb> I did build just now

[11:49] <bsb> Want me to try something?

[11:49] <gaal> bsb, was it parrot-enabled?

[11:49] <gaal> weird.

[11:50] <gaal> these may be unrelated problems I'm seeing... will wait for this nonembed build to complete.

[11:50] <r0nny> ARGH

[11:50] <r0nny> its in a endless loop in a build submethod

[11:50] <r0nny> and i dont know how this could happen

[11:50] <bsb> it wasn't, I have parrot externally (I think)

[11:55] *** _autrijus is now known as audreyt

[11:58] <audreyt> rehi

[11:58] <gaal> hi again.

[11:58] <r0nny> new nick ?

[11:59] <audreyt> yup

[11:59] <r0nny> there are several problems in pugs now

[11:59] <gaal> audreyt: I think I have the refactoring done, but am getting weird linkage errors. I just started a clean build w/o parrot.

[12:00] <gaal> (in make unoptimized it all worked)

[12:00] <r0nny> i never tought i so simple BUILD submethod would end up in a endless loops

[12:00] <audreyt> r0nny: give me an example?

[12:00] <audreyt> gaal: nuking dist/build/ usually worksforme to clear up linker errors

[12:01] <r0nny> audreyt: http://rafb.net/paste/results/HM8QrB43.html

[12:01] <gaal> oh, thanks for the tip!

[12:01] <audreyt> r0nny: fixing

[12:02] <r0nny> and it got problems with ref and defined

[12:02] <audreyt> you spelled "ref" as "rev"

[12:02] <r0nny> hmm

[12:03] <r0nny> well - the problem is what defined return

[12:03] <r0nny> i got a class, where a atribute has a class (got it with ref), but is not defined

[12:04] <audreyt> nod, that is known, I'm midway fixing it.

[12:04] <r0nny> hmm

[12:04] <audreyt> as re the infinite lop, it's a genuine bug. currently you can workaround by saying ::foo.new

[12:04] <audreyt> but I'm fixing it for good. a sec

[12:04] <r0nny> plz highlight me when done

[12:04] <audreyt> highlight, as in, mentioning your name?

[12:04] <r0nny> jepp

[12:04] <audreyt> k

[12:23] <gaal> TDD++; # find t -name \*context\* |grep -v svn | xargs prove => All tests successful.

[12:24] <svnbot6> r8153 | gaal++ | * Refactor Cxt, Pos, and Prag nodes in Exp to a unified Ann

[12:24] <svnbot6> r8153 | gaal++ |   (for Annotation) type. This should ease work on lexical pragmas.

[12:25] <gaal> audreyt: could you please take a look at this patch for sanity?

[12:25] <audreyt> a sec, I've fixed r0nny's reported bug

[12:26] <audreyt> about to commit

[12:26] <gaal> yay

[12:28] <audreyt> mm, needs to merge with yours anyway

[12:28] * audreyt goes revewing

[12:35] <audreyt> gaal: preludePC broke for some reason

[12:37] <audreyt> gaal: Pugs.Compile.Pugs instances are broken

[12:38] * gaal frowns

[12:39] <gaal> good thing we have different build settings

[12:39] <audreyt> somehow freenode borked my password

[12:39] * audreyt tries renicking to get around it

[12:39] <svnbot6> r8154 | autrijus++ | * r0nny reported that "foo.bar" was parsed as "&bar(&foo())" for

[12:39] <svnbot6> r8154 | autrijus++ |   no particularly good reason.  it now parses as "::foo.bar"

[12:39] <svnbot6> r8154 | autrijus++ |   when ::foo is in scope, and "&foo(.bar)" otherwise.  Not entirely

[12:39] <svnbot6> r8154 | autrijus++ |   sure the latte is the sanest way -- suggestions?

[12:39] *** audreyt is now known as audrey

[12:40] <audrey> already registered by someone else. bah :/

[12:40] * audrey gives up on this nick registration thing for now

[12:41] <gaal> audrey: /msg lilo to reset the password?

[12:41] <audrey> ok

[12:41] <gaal> I always have the urge to reboot when I see his nick though.

[12:43] <audrey> ditto :)

[12:43] <gaal> I just realized what I was eating for lunch. audrey, when you're here, we must let you taste this.

[12:43] <gaal> "pumpkin ravioli"

[12:43] <audrey> sounds very tasty indeed

[12:44] <Juerd_> gaal: It's the one and only positive thing about the guy: he reminds me implicitly that I should upgrade my kernel every now and then

[12:44] <Juerd_> :P

[12:46] <gaal> audrey: by Pugs.Compile.Pugs instances you meant compileShow2 etc.?

[12:47] <svnbot6> r8155 | autrijus++ | * Pugs.Compile.Pugs: Accomodate for gaal++'s otherwise

[12:47] <svnbot6> r8155 | autrijus++ |   excellent and sane Ann changes, so PreludePC.hs can still

[12:47] <svnbot6> r8155 | autrijus++ |   function as usual.

[12:47] <audrey> gaal: I mean r8155. yes

[12:47] <audrey> just lift it to Ann is all

[12:47] <gaal> heh. fastest gun in the west.

[12:47] <gaal> for some value of gun, and west.

[12:48] <audrey> and fast.

[12:48] <gaal> lol

[12:48] <audrey> and "in". fortunately "the" is constant enough.

[12:49] <gaal> oh, duh, of course re Ann lifting

[12:49] <gaal> thanks :)

[12:50] <gaal> ok, now how to carry Prag Anns from one statement to the next.

[12:52] <audrey> carefully

[12:52] <gaal> :)

[12:52] <audrey> line 278 Eval

[12:52] <audrey>     | Noop <- unwrap this = reduce rest

[12:53] <audrey> you need a case before that

[12:53] <gaal> in Eval? The parser oughta know this already, no?

[12:53] <audrey> oh, sure

[12:54] <audrey> so you are going to replicate it in each Stmt structure

[12:54] <audrey> that's certainly a valid way of doing it

[12:55] <gaal> cheap too, in principle.

[12:55] <audrey> you can do it in mergeStmts

[12:55] <audrey> if you find it too icky (one function doing many things)

[12:56] <audrey> then add another propagatePragmaInStmts function

[12:56] <audrey> that goes in Parser.hs each time you are dong creating a Stmts structure

[12:56] <audrey> it will inspect the cons calls like thus

[12:58] <audrey> propagate (Ann (Prag prag) exp) (Stmts x y) =

[12:58] <audrey>    exp1 hm

[13:00] <audrey> propagate prag (Stmts x@(Ann (Prag prag') _) y = Stmts x (propagate (prag `mergePrag` prag') y)

[13:00] <svnbot6> r8156 | fglock++ | * misc/Parser-Mini/pil2_json_emit_forth.p6 - an emitter for

[13:00] <svnbot6> r8156 | fglock++ |   Forth (or something like that)

[13:00] <svnbot6> r8156 | fglock++ |      1 1 &infix:<+> &say

[13:00] <svnbot6> r8156 | fglock++ | * pil2_json_emit_p6.p6 - refactored the language-independent 

[13:00] <svnbot6> r8156 | fglock++ |   parts in a module

[13:00] <audrey> something like that.

[13:01] <gaal> ACK, I think.

[13:02] <audrey> cool

[13:04] <gaal> now re: blocks:   ruleStandaloneBlock needs to know the Prag context it was started in

[13:05] <gaal> so it can instill it on the body, but also so it can reset it after the lexical scope finishes.

[13:06] <gaal> (actually I'm not sure if that's ruleStandaloneBlock or one of the other rules that should be responsible for this)

[13:06] <audrey> yay, I got my password reset

[13:06] <audrey> lilo++

[13:06] *** audrey is now known as audreyt

[13:07] <gaal> in the last attempt I stashed the pragma list in a hacky place in Env - but that's weird and feels wrong.

[13:07] <audreyt> if it's me implementing this

[13:07] <audreyt> I'll do it in Eval

[13:07] <audreyt> because Exp is really just a document parser

[13:08] <audreyt> and the yielded Exp may be bogus in many ways already

[13:08] <azuroth> evening

[13:08] <audreyt> it's okay to rely on the consumer of Exp, be it evalExp or cmopileToPIL, to make sure the pragmas happen

[13:08] <clkao>  /win27

[13:09] <audreyt> currently it feels a lot like the perl5 parser/runtime mixed environment already

[13:09] <audreyt> and each recursive queries like propagatePragma makes it a bit worse

[13:09] <gaal> The whole reason why this isn't an easy port is that it *isn't* like the perl5 parser/runtime :)

[13:09] <audreyt> nod... but why not just keep the Ann?

[13:09] <audreyt> and leave it to Eval.hs reduceStmts to resolve it

[13:10] <gaal> I think I totally don't understand that, but I'm hoping I'm wrong. :)

[13:10] <audreyt> ok.

[13:11] <audreyt> you are talking about envInitDat, right?

[13:11] <gaal> yes

[13:12] <gaal> that's probably bogus though.

[13:13] <audreyt> in my mind, pragmas should work just like lexical exports

[13:14] <audreyt> but currently our exports are package scoped

[13:15] <gaal> they should work a lot like lexical exports

[13:15] <audreyt> so maybe solving lexical export is the correct way to go

[13:15] <gaal> but you can do { use X; x-is-on; no X; x-is-off }

[13:17] <audreyt> right, so unlike lexical exports, annotations doesn't have the hoisting property that it's unique in a scope

[13:17] <r0nny> re

[13:18] <gaal> yes; every change to the value is prepended to a list.

[13:18] <gaal> is there some code for lexical exports already?

[13:19] <ingy> hi audreyt 

[13:21] <audreyt> no. I very much regret the fact that "export is lexical" missed my first reading of p6 spec

[13:22] <audreyt> gaal: what would make most sense is for X.pm to directly manipulate the MY:: package.

[13:22] <audreyt> for the importer

[13:22] <audreyt> i.e. @?PRAGMA there would hold the pragmas

[13:23] <audreyt> so "no X" will modify it as usual

[13:23] <audreyt> and each statement will carry the @?PRAGMA with it

[13:23] <audreyt> which is destroyed when the MY:: went out of scope of course

[13:23] <audreyt> as part of the pad

[13:23] <audreyt> am I making some sense?

[13:23] <audreyt> ingy: hi!

[13:25] <r0nny> audreyt: yes, u do

[13:25] <gaal> I think that would work. Can it be fast?

[13:25] <gaal> and not memory hungry?

[13:27] <gaal> making @?PRAGMA a real var that is.

[13:28] <audreyt> gaal: it's all compile time

[13:28] <audreyt> parse time in fact

[13:28] <gaal> that is hidden in each new scope

[13:28] <audreyt> I don't think we need to care that much in this stage

[13:28] <gaal> oughta be, yes

[13:28] <gaal> OK

[13:28] <r0nny> btw - howz the fix witrh the ref<=>defined problem

[13:29] <Alias_> ok, all possible 4-char programs work

[13:29] <audreyt> Alias++ # yay finally. release!

[13:29] <Alias_> releasing

[13:29] <gaal> in what language, Alias_?

[13:29] <r0nny> 4 char progs ?

[13:29] * audreyt goes release Module::Install as well

[13:29] <audreyt> r0nny: working on it. give me another week

[13:29] <r0nny> ok

[13:29] <Alias_> gaal: Perl 5

[13:30] <gaal> what does "work" mean in this context? 

[13:30] <audreyt> "work" as in "PPI tokenizer won't break up and can actually produce something that can be transformed to PIL"

[13:30] <r0nny> how many 4-char progs are possible with perl5 ?

[13:30] <Alias_> And 4-char meaning exhaustively testing every possible case

[13:30] <Alias_> r0nny: About 50^4

[13:30] <audreyt> ?eval 50 ** 4

[13:30] *** evalbot_8131 is now known as evalbot_8156

[13:30] <evalbot_8156> 6250000/1 

[13:30] <r0nny> sounds like fun

[13:31] <r0nny> btw - why must ** return a rational ?

[13:31] <Alias_> Handing more cases than the perl interpreter? yeah...

[13:31] <gaal> .oO(how do you say "dump" in PIL?)

[13:32] <r0nny> eval 30 ** 30000

[13:32] <Alias_> PPI 1.106 uploaded

[13:32] <audreyt> r0nny: mostly because haskell only has builtin (^^) :: VRat -> VInt -> VRat

[13:32] <audreyt> and no VInt->VInt->VInt form

[13:33] <audreyt> and I was too lazy to define one.

[13:34] <gaal> audreyt: where is export specced? i can't find it in S10

[13:35] <audreyt> S11 "lexical scope"

[13:35] <gaal> cool, that.

[13:39] <gaal> what I don't see is where module configuration options went

[13:40] <gaal> use Test::More 'no_plan'

[13:41] <gaal> and export tags, not that I liked those anyway

[13:52] <audreyt> sorry, was away

[13:54] <audreyt> gaal: I think the module has to override IMPORT 

[13:56] <audreyt> gaal: it's 1pm here, and I think we need to leave the office soonish :)

[13:56] <audreyt> I'll be back ~10hr from now

[13:57] <audreyt> stay for 2~3hr and then fly to Sydney, then back here for another two hacking days

[13:57] <audreyt> then there's some more talks to give. :)

[14:06] <audreyt> be back tomorrow... &

[14:16] <meppl> guten morgen

[14:32] <azuroth> good morning

[14:50] *** Maddingue_ is now known as Maddingue

[15:03] <gaal> audreyt: was away, myself. enjoy the rest of your time over there...

[15:05] <gaal> overriding IMPORT wasn't the answer I was hoping for :) because it means "it can be done, but there's no conventional means we recommend"

[15:06] <gaal> c

[15:41] <cognominal> audreyt like Audrey Tautou?

[17:16] *** integral is now known as bs338

[17:27] *** bs338 is now known as integral

[18:59] <fridim> hi

[19:13] <fridim> can i use strict with pugs ?

[19:14] <gaal> currently you can't not use strict with pugs :)

[19:16] <fridim> I've seen that we can use some cpan modules with pugs (in examples section in pugscode.org). But is there something to configure ?

[19:20] <gaal> when building pugs, make sure you enable perl5 embedding.

[19:21] <fridim> oh.

[19:21] <fridim> i've just apt-get it

[19:21] <gaal> the debian packages include p5 embedding.

[19:21] <gaal> so you can do, right away:

[19:21] <fridim> Can't locate WWW/Mechanize.pm

[19:22] <gaal> pugs -e 'my $val = eval "42", :lang<perl5>; say $val'

[19:22] <gaal> OK, print your p5 @INC:

[19:23] <gaal> pugs -e 'my @p5inc = eval q{@INC}, :lang<perl5>; @p5inc.perl.say'

[19:23] <fridim> @*INC (@*INC contains: /usr/lib/perl6/5.8 /usr/share/perl6/5.8 /usr/local/lib/perl6 /usr/local/share/perl6 /usr/share/perl6/5.8/auto/pugs/perl6/lib /usr/local/share/perl6/auto/pugs/perl6/lib .).

[19:23] <gaal> no, your p5 inc

[19:23] <gaal> your p6 inc shouldn't include p5 libs, after all

[19:24] <gaal> use that one-liner

[19:25] <fridim> it seems quite different from perl using... i should read some doc about pugs.

[19:25] <fridim> [{obj-perl5}]

[19:25] <gaal> hmmm

[19:25] <gaal> yeah, sec

[19:25] <fridim> (i've www::mechanize installed, and works with p5)

[19:30] <gaal> hmmm, apparently returning an array is a little problematic. try this:

[19:30] <gaal> pugs -e 'my $p5inc = eval q{\@INC}, :lang<perl5>; say $p5inc[$_] for 0 .. 10'

[19:30] <fridim> /etc/perl

[19:30] <fridim> /usr/local/lib/perl/5.8.7

[19:30] <fridim> /usr/local/share/perl/5.8.7

[19:30] <fridim> /usr/lib/perl5

[19:30] <fridim> /usr/share/perl5

[19:30] <fridim> /usr/lib/perl/5.8

[19:30] <fridim> /usr/share/perl/5.8

[19:31] <fridim> /usr/local/lib/site_perl

[19:31] <fridim> /usr/local/lib/perl/5.8.4

[19:31] <fridim> /usr/local/share/perl/5.8.4

[19:31] <fridim> .

[19:31] <gaal> you have mech installed in one of those?

[19:31] <fridim> probably not, how could i know ?

[19:31] <gaal> perldoc -l WWW::Mechanize

[19:32] <fridim> /usr/local/share/perl/5.8.7/WWW/Mechanize.pm

[19:32] <fridim> haha

[19:32] <gaal> so it should work. the use should look like this:

[19:32] <gaal> use perl5:WWW::Mechanize

[19:32] <fridim> !

[19:32] <gaal> notice only one : after "perl5"

[19:33] <fridim> I didn't put the perl5

[19:33] <gaal> ah. module loading isn't transparent

[19:33] <gaal> which when you think of it is a good thing

[19:33] <fridim> gaal: it works well, thank you

[19:33] <gaal> in principle one day you could do use ruby:Rails

[19:34] <gaal> or python:twisted

[19:34] <gaal> etc.

[19:34] <gaal> sure :)

[19:35] <fridim> i've "read" some article like "why perl6 won't work"

[19:35] <fridim> to my mind, it will work

[19:36] <fridim> Just the new classes design could make perl6 work :)

[19:37] <Juerd_> Well, some of the OO bloat could/should be removed imo

[19:37] <Juerd_> To avoid a catastrophy

[19:38] <lollan> there is always people to say it never work without trying anything

[19:39] <fridim> imo ?

[19:39] <Juerd_> In My Opinion

[20:01] <r0nny> i would be fine, if at least the undefined instances was out of the world

[20:01] <r0nny> +problem with

[20:08] <rindolf> Hi all!

[20:08] <rindolf> In Spork, why doesn't [a 1990 http://groups.google.com/group/comp.lang.perl/msg/b7b1650e90b89c0b?hl=en message] renders as a link with the text?

[20:10] <rindolf> I ran into a bug on my first slide...

[20:34] <svnbot6> r8157 | pjf++ | Butchered numerous tests that were causing infinite loops, replacing them with flunk()s.

[20:52] <svnbot6> r8158 | pjf++ | Removal of tests that cause infinite loops and replaced with flunk.

[21:03] <Khisanth> fridim: I think that article was written by rindolf :)

[21:21] <stevan> audreyt: ping

[21:40] <svnbot6> r8159 | pjf++ | Improved pugs_revision detection on hybrid Cygwin/Win32GHC systems.

[21:49] * PJF wonders if there's an easy switch to make run-smoke.pl display verbose output of all tests to the console as they run.

[22:08] <fridim> Khisanth: i don't know rindolf

[22:11] <gaal> PJF: there is not. you want to hack util/yaml_harness.pl around line 203 more

[22:11] <gaal> or less.

[22:13] <gaal> probably it's a good idea to make this configuration visible from config.yml

[22:13] <fridim> Khisanth: ok, i've seen his apparition

[22:14] <PJF> Thanks Gaal!

[22:14] <PJF> Gaal: Am I correct that Audrey has a separate repository for Module::Install, and just syncs it back into pugs from time to time?

[22:15] <PJF> The most recent update to Module::Install breaks 'make test' in pugs.  I've written a patch, but I'm wondering if I should be pushing it out to a separate M::I repository as well.

[22:16] <obra> PJF: can you nopaste the patch?

[22:16] * obra is a maintainer for M::I

[22:16] * gaal isn't here

[22:17] <PJF> obra: Just submitted as 8160 in pugs.  The only code change is:

[22:17] <svnbot6> r8160 | pjf++ | Only query '$self->tests' if we haven't been given an explicit list

[22:17] <svnbot6> r8160 | pjf++ | from makemaker_args.

[22:17] <svnbot6> r8160 | pjf++ | This should be reviewed/submitted/corrected for main M::I inclusion.

[22:17] <PJF> $args->{test} ||= {TESTS => $self->tests};

[22:17] <PJF> Gah, that's not very useful, is it?

[22:17] <obra> where does that live?

[22:18] <PJF> Index: Makefile.pm

[22:18] <PJF> ===================================================================

[22:18] <PJF> --- Makefile.pm (revision 8159)

[22:18] <PJF> +++ Makefile.pm (working copy)

[22:18] <PJF> @@ -61,8 +61,12 @@

[22:18] <PJF>      $args->{NAME} = $self->module_name || $self->name || $self->determine_NAME($args);

[22:18] <PJF>      $args->{VERSION} = $self->version || $self->determine_VERSION($args);

[22:18] <PJF>      $args->{NAME} =~ s/-/::/g;

[22:18] <PJF> -    $args->{test} = {TESTS => $self->tests};

[22:18] <PJF> +    # Only call $self->tests if we haven't been given explicit

[22:18] <PJF> +    # tests from makemaker_args.

[22:18] <PJF> +

[22:18] <PJF> +    $args->{test} ||= {TESTS => $self->tests};

[22:18] <PJF> +

[22:18] <PJF>      if ($] >= 5.005) {

[22:18] <PJF>         $args->{ABSTRACT} = $self->abstract;

[22:18] <PJF>         $args->{AUTHOR} = $self->author;

[22:18] * PJF apologies for the spam.  He really should have a coffee before pasting things into irc.

[22:19] <obra> PJF: you've seen paste.husk.org?

[22:19] <obra> (And the other nopasters?

[22:19] <PJF> That's in M/I/Makefile.pm.  We're only calling $self->tests if we haven't been given an explicit argument from makemaker_args.

[22:19] <integral> there's two with bots here in the topic.

[22:19] <PJF> I've seen paste.husk.org now. ;)

[22:19] <obra> :)

[22:21] * PJF apologies again for the spam, having misparsed the 'no' in 'nopaste'.

[22:21] <obra> no worries

[22:22] <obra> PJF: how do you like to be credited?)

[22:22] <PJF> obra: It's a two character change.  I'm not sure if that's worthy of crediting.

[22:23] <PJF> obra: But if you have to credit, then just "Paul Fenwick" is fine.

[22:25] <obra> committed

[22:25] <obra> credit is at least as much about blame as praise ;)

[23:02] <svnbot6> r8161 | gaal++ | * quell haddock

[23:19] <Alias_> on returner

[23:22] <audreyt> PJF: I've made you committer to http://svn.openfoundry.org/modinstall/trunk as well.

[23:22] <audreyt> PJF: please commit the same patch there :)

[23:22] <PJF> Good morning Audrey, Alias.

[23:22] <audreyt> (and I'll roll it out in 0.41)

[23:23] <audreyt> PJF++

[23:23] <obra> audreyt: you must have missed my push

[23:23] <PJF> I think that obra has already beaten me to it.  But I'll double-check.

[23:23] <obra> Should be commit #45

[23:23] <audreyt> oh wait, obra pushed it

[23:23] <audreyt> yup, my svk pull -a hadn't yet run that far

[23:24] <audreyt> looks clean. pjf++ obra++

[23:36] <svnbot6> r8162 | autrijus++ | * Pugs.Shell: turn CmdRun into a record type for better clarity

[23:36] <svnbot6> r8162 | autrijus++ |   as the new PIL runtime is using it.

[23:51] <svnbot6> r8163 | autrijus++ | * "make ghci" now actually do something useful, as was the

[23:51] <svnbot6> r8163 | autrijus++ |   case before cabalization; ":r" in the ghci prompt will now

[23:51] <svnbot6> r8163 | autrijus++ |   reload changed .hs files as expected.  gaal++ for mentioning it.

[23:55] * PJF cheers as his first pugs 'make test' completes under cygwin.

[23:59] <PJF> Audrey: I've noticed that on Win32 (and Cygwin under Win32) that ghc doesn't add itself to $PATH.  In the interests of making pugs easier to install on those systems, are you happy for me to add some autodetection code to Makefile.PL such that $PATH or $GHC doesn't need to be explicitly set on those systems?

