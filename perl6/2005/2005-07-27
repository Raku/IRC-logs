[00:21] <dudley> A Gentle Introduction to Haskell has a misleading title... but it makes much more sense after reading TCFP.

[00:26] <ezra_> TCFP?

[00:43] <dudley> Haskell: The Craft Of Functional Programming

[00:43] <ezra_> ah, thanks

[00:46] <Khisanth> YAHT is pretty nice .... if a bit sparse :)

[00:48] <dudley> Yeah, I would definitely recommend starting with one of those two. Or both of them.

[00:59] <wolverian> I can count in lojban :)

[01:07] <mugwump> mi kafka

[01:07] <mugwump> mi kafka ganxo

[01:09] <wolverian> your anal kafka? did I get that right? :)

[01:09] <wolverian> er, no. you are kafka-anal? 

[01:21] <mugwump> I tried to say "I fart"

[01:21] <mugwump> the first meant "I expel a gas", not specifically from any orafice

[01:21] <wolverian> hmm, the dictionary I consulted didn't know kafka

[01:22] <wolverian> is it compound?

[01:30] <mugwump> kafke

[01:30] <mugwump> so, it should have been, mi kafke zo'e ganxo

[01:31] <mugwump> (lit. I expel something from my anus)

[01:33] <wolverian> right

[02:35] *** acme___ is now known as acme

[03:18] <buu> Is there any thoughts/documentation/etc for the new perl6 pod type thing?

[03:30] <mugwump> buu: see the S26draft-mugwump.pod and let me know what you think

[03:31] <mugwump> atm it's simply suffering from lack of feedback

[03:31] <mugwump> There's the Perl 5 Perldoc module, of which a port to Perl 6 has begun, that's waiting on tuits

[03:32] <mugwump> There's also the Kwid-Event-Parser and Pod-Event-Parser modules, which are semi-suitable for making into Perldoc::Parser classes

[03:32] <mugwump> At the time it was also blocking because of some broken functionality that is probably not the case now.

[03:33] <buu> Ok

[03:33] <mugwump> And slow, slow pugs startup which is solved now with precompiled Prelude

[03:33] <buu> Where might I find ye old .pod file?

[03:33] <mugwump> in docs/ I think

[03:33] * mugwump checks

[03:33] <buu> er

[03:33] <mugwump> docs/AES

[03:34] <buu> Can I get that in the form of a URI?

[03:34] <mugwump> that is a URI.  the base URI is file://where/you/checked/out/pugs/to ;)

[03:34] <buu> Ah.

[03:35] <mugwump> the Perl 6 Perldoc port is in ext/Perldoc

[03:35] <mugwump> the Perl 5 version of Perldoc is at http://search.cpan.org/dist/Perldoc/

[03:35] <buu> Where are the pugs svn servers hiding?

[03:35] <mugwump> oh, not a committer yet?

[03:35] <buu> haha, no.

[03:35] <mugwump> http://svn.openfoundry.org/pugs

[03:36] <buu> Can I just check out from there?

[03:36] <mugwump> sure

[03:36] <buu> Excellento.

[03:37] * buu tries

[03:37] <buu> Sucess!

[03:42] <buu> Hrm. I'd like to register a complaint.

[03:42] <mugwump> let me guess, it doesn't even parse POD yet?  :)

[03:42] <mugwump> or something else?

[03:42] <buu> Naw

[03:42] <buu> My problem is, pod fucking sucks

[03:43] <buu> I should note that this opinion is formed from trying to *parse* perl5's current collection of pod.

[03:43] <mugwump> right, well the idea behind the new POD system is to allow pod dialects, like Kwid which is a wiki-style POD

[03:43] <buu> For example, perlop

[03:43] <buu> =item $/

[03:43] <buu> =item $FOOBAR

[03:43] <buu> Oh, those are the same variable?

[03:44] <buu> My basic problem is that POD reminds me of HTML1 type things. It focuses way too much on the presentation.

[03:44] <Amnesiac> shaddup

[03:44] <Amnesiac> you don't know anything about HTML1

[03:44] <Amnesiac> you were in diapers!

[03:44] <buu> Amnesiac: Go back to mexico.

[03:46] <wolverian> I think that's everyone's problem with POD, buu 

[03:46] <wolverian> at least I hope it is. :)

[03:46] <buu> wolverian: Well, I haven't been particuraly active in development, but I haven't seen any indications of that.

[03:48] <wolverian> then you should get active!

[03:48] <buu> Of course the problem is, I can't think of anything that would be better at actually storing the meta data than xml.

[03:49] <mugwump> buu: have a look at the Perl 5 Perldoc distribution; the basic test cases are all xml based

[03:49] <buu> Ick =[

[03:49] <buu> mugwump: Where is that again?

[03:49] <mugwump> xml is great for documents

[03:49] <mugwump> http://search.cpan.org/dist/Perldoc/

[03:49] <mugwump> so long as no human is editing the file, of course

[03:50] <buu> yeah that is the trick.

[03:51] <buu> But I really just want an easy way to parse semantic meaning from a document with out having to do it by hand.

[03:52] <mugwump> yes, that would be nice.  so, what I've focused on so far is just basic infrastructure - how the structures are represented in memory (a DOM, if you like) and how they are transmitted about (a serial event API)

[03:52] <buu> Stupid events.

[03:52] <wolverian> I don't see much of a problem as long as the PODv2 we'll end up with defines semantic 'tags' instead of things like =over 

[03:53] <buu> Yeah, =method would be vastly preferable.

[03:53] <wolverian> yes.

[03:53] <buu> Or something. Anything but the current muck.

[03:53] <wolverian> and hopefully the perldoc backend can extract signatures and such to automatically add metadata to the documentation

[03:53] <buu> Eh, how?

[03:54] <wolverian> buu, &Foo::method.signature

[03:54] <wolverian> or so. 

[03:54] <buu> Er, oh.

[03:54] <buu> Those kind of signatures.

[03:54] <wolverian> yeah. :) 

[03:54] <buu> PPI !

[03:55] <mugwump> this will be possible, with the obvious caveats

[03:55] <wolverian> buu, PPI isn't necessary with perl6. :)

[03:55] <buu> Well yeah, but I get the idea.

[03:55] <buu> But of course, the pod back end will have to know where to insert these signatures

[03:56] <buu> So we're back to =methods.

[03:56] <mugwump> again, the operation of this stuff shouldn't be hardcoded.  it would probably be more like;

[03:56] <mugwump> =use Methods

[03:56] <wolverian> I was thinking of it outputting those when requested (pod2html, etc)

[03:57] <buu> Er, what?

[03:57] <wolverian> mugwump, I disagree. that is not semantic at all.

[03:57] <wolverian> what is 'use'? 

[03:58] <buu> wolverian: It's a flag to the interpretering parser thingy.

[03:58] <buu> At least I think that's the idea.

[03:59] <mugwump> ok, if we want to keep PODv1 backwards compatibility it would be called =for Plugin::Methods or something

[03:59] <wolverian> compatibility? why? perl6 isn't perl5 compatible.

[03:59] <buu> Fuck compatability in the ass.

[04:05] <mugwump> enough people have different ideas on the level of backwards compatibility that it is worth allowing it.  Also, the design in S26draft-mugwump.pod leaves plenty of room for POD dialects to diverge

[04:06] <mugwump> But if we get a POD dialect nice enough, it's possible that enough people will agree to make it standard that it will become so

[04:06] <mugwump> at the worst you're looking at one extra line to pull in your favourite dialect

[04:06] <mugwump> the idea is that these can all be read in a standard way by just accessing the $=DOC object (or @=DOC or %=DOC...)

[04:09] <mugwump> please feel free to write test cases - in other words - your own POD dialect or POD trick - and place them in the Perldoc distribution in t/

[04:10] <mugwump> perhaps there is an existing Perl 5 module that you want to see working in Perl 6 and you're curious how it would work

[04:22] <buu> I'm still pondering the design.

[04:28] <mugwump> good, I'd be delighted to hear what you think, even if it consists only of expletives and personal pronouns

[04:37] <luqui> I UNDERSTAND MONADS.  HAHHAHAHAHAHAHAHAAA

[04:38] * mugwump gives luqui a bright, shiny medal

[04:38] <luqui> it took me long enough...

[04:43] <mugwump> from one Perlite to another, can it be summarised easily?

[04:44] <mugwump> I know that they encapsulate IO in a Haskell program

[07:11] <svnbot6> r5823, Aankhen++ | * HTTP::Request::CGI: inherit from HTTP::Request.

[07:22] <luqui> mugwump:  can they be summarized easily? ...

[07:22] <luqui> let's see, they encapsulate a behavioral model

[07:22] <svnbot6> r5824, Aankhen++ | HTTP::Request::CGI:

[07:22] <svnbot6> r5824, Aankhen++ | * `use URI::Escape`

[07:22] <svnbot6> r5824, Aankhen++ | * added explicit invocant for &BUILD.

[07:22] <svnbot6> r5824, Aankhen++ | * added &:unpack_params.

[07:23] <wolverian> that reminds me that I still have to rewrite URI. :/

[07:23] <luqui> they essentially overload ; and =

[07:24] <luqui> which means that you can implement backtracking

[07:24] <luqui> and statefulness

[07:25] <luqui> that's the best I can do

[07:41] <svnbot6> r5825, Aankhen++ | * HTTP::Request::CGI: added &:load_params.

[08:09] <szabgab> open +>  and +< , should they become open :rw  and open :wr respectively ?

[08:09] <szabgab> where can I read the most up to date spec ?

[08:09] * QtPlatypus likes "+>" and "+<"

[08:11] <szabgab> and also there was a  +>> read and append

[08:27] <svnbot6> r5826, Aankhen++ | HTTP::Request::CGI:

[08:27] <svnbot6> r5826, Aankhen++ | * fixed mistake in &BUILD.

[08:27] <svnbot6> r5826, Aankhen++ | * implemented &params().

[08:27] <svnbot6> r5826, Aankhen++ | * implemented all variants of &param().

[08:27] <svnbot6> r5827, Aankhen++ | * HTTP::Request::CGI: implemented &delete_param and &delete_params.

[08:34] <svnbot6> r5828, Aankhen++ | HTTP::Request::CGI:

[08:34] <svnbot6> r5828, Aankhen++ | * renamed &:unpack_params to &:parse_params.

[08:34] <svnbot6> r5828, Aankhen++ | * added &:parse_keywords, and appropriate handling in &:load_params.

[08:36] <Aankhen``> ?eval multi sub foo () { "no args" }; &foo:<Str> := -> Str $bar { $bar.uc() }; foo("bar")

[08:36] <evalbot6> Error:  unexpected ":" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:36] <Aankhen``> ?eval multi sub foo () { "no args" }; &foo:(Str) := -> Str $bar { $bar.uc() }; foo("bar")

[08:36] <evalbot6> Error:  unexpected ":" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:37] <wolverian> hmm, try ::=

[08:37] <Aankhen``> ?eval multi sub foo () { "no args" }; &foo:(Str) ::= -> Str $bar { $bar.uc() }; foo("bar")

[08:37] <evalbot6> Error:  unexpected ":" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:37] <Aankhen``> ?eval multi sub foo () { "no args" }; &foo:<Str> ::= -> Str $bar { $bar.uc() }; foo("bar")

[08:37] <evalbot6> Error:  unexpected ":" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[08:37] <wolverian> right. not supported yet :)

[08:37] <Aankhen``> Yep.

[08:37] <Aankhen``> ^_^

[08:40] <Aankhen``> OK, I need to shower.

[08:40] <Aankhen``> Later.

[08:40] <svnbot6> r5829, Aankhen++ | * HTTP::Request::CGI: fixed &:parse_keywords and implemented &keywords.

[09:47] <mugwump> luqui: thanks, I'll let that sit and ponder itself and maybe later it'll help me :)

[10:49] <nothingmuch> moose

[10:54] <szabgab> ?eval my $fh = open "/tmp/file", :r, :w err print $!

[10:54] <evalbot6> Error: No compatible subroutine found: "&:w" 

[10:54] <nothingmuch> szabgab: evalbot protects itself against opens

[10:54] <szabgab> ?eval my $fh = open("/tmp/file", :r, :w) err print $!

[10:54] <evalbot6> Error: No compatible subroutine found: "&Pugs::Internals::openFile" 

[10:55] <szabgab> I hoped so :-)

[10:55] <szabgab> but this does not seem to work on my machine either :-(

[12:05] <autrijus> try :rw?

[12:08] <szabgab> :rw does not seem to work either

[12:08] <szabgab> returns Scalar

[12:10] <autrijus> :rw worksforme

[12:10] <autrijus> I committed a fix for :r :w

[12:13] <szabgab> I added tests, will check them

[12:13] <svnbot6> r5830, autrijus++ | * Try not using junctions in the prelude where normal short-circuitting

[12:13] <svnbot6> r5830, autrijus++ |   boolean operators would do.

[12:13] <svnbot6> r5831, autrijus++ | * make MIME::Base64 installable and skip its tests when

[12:13] <svnbot6> r5831, autrijus++ |   PGE is unavailable.

[12:20] <svnbot6> r5832, szabgab++ | * t/builtins/io/io.t

[12:20] <svnbot6> r5832, szabgab++ |   add tests for open with :rw and open :r, :w

[12:20] <svnbot6> r5833, autrijus++ | * unTODO a passing pair binding test

[12:22] <scook0> autrijus: did you see the p6c thread about PIL nodes?

[12:22] <autrijus> scook0: I did

[12:22] <autrijus> I'm however still neck deep in PIL redesign :)

[12:23] <scook0> ah

[12:23] <QtPlatypus> autrijus: I would like to remove the code that does  ="string"  It looks incredably wrong to me. 

[12:23] <QtPlatypus> (In prelude)

[12:23] <QtPlatypus> But would like to know if that would be welcomed.

[12:23] <autrijus> for =<> { ... }

[12:23] <scook0> I was trying to figure out what each of them does by using context, but that's hard when half of the needed context doesn't exist yet

[12:24] <autrijus> was the motivation

[12:24] <autrijus> for =<README.txt> -> $line { ... } # this too

[12:25] <autrijus> see S04

[12:25] <kolibrie> autrijus: I found your Template::Extract yesterday.  Very handy.  Might use it.

[12:25] <autrijus> kolibrie: thanks :)

[12:26] <scook0> oh, quick question:

[12:26] <autrijus> QtPlatypus: otoh, maybe =<> is really the special case and =$str should not have worked

[12:26] <autrijus> QtPlatypus: but I don't know... I kind of like that in fact

[12:26] <scook0> in 'TCxt' and 'TParam', what does the 'T' mean?

[12:26] <autrijus> the T means "Translate" which is the old name for "CodeGen"

[12:27] <autrijus> maybe rename them to CCxt and CParam now

[12:27] <autrijus> but Cxt and Param should be unified anyway

[12:27] <QtPlatypus> But it goes against = meaning "Iterate this itereator"

[12:27] <autrijus> QtPlatypus: but if a string is taken to be an iterator over the file named by it

[12:27] <autrijus> I mean that's not worse than the empty string meaning iterating over $*ARGS

[12:27] <QtPlatypus> Ok I can live with that

[12:28] <scook0> how come they need to be separate from Cxt/Param -- different requirements for the compiler?

[12:28] <autrijus> cool. if you can't, post on p6l to fix S04 :)

[12:28] <autrijus> scook0: sure, Param's paramDefault is a parse tree Exp

[12:28] <autrijus> whilst TParam's is already compiled

[12:28] <autrijus> etc

[12:29] <autrijus> TCxt is mostly there just for the TTailCall case.

[12:29] <scook0> I see

[12:35] * nothingmuch makes noises

[12:39] <autrijus> brb, fbsd-6 installed, rebooting

[12:46] <Aankhen``> ?eval class Foo { }; class Bar[::Baz] { }; Bar[Foo].new

[12:46] <evalbot6> Error:  unexpected "[" expecting word character, "::", "-", trait, ";" or end of input 

[12:53] <Aankhen``> Are parameterized classes slated for inclusion in Perl 6, at this time?

[12:55] <scook0> Aankhen``: I don't recall reading otherwise--I'd be very disappointed if they weren't

[12:56] <Aankhen``> Me too, now that I've come to realize what they could be used for.  I was getting a little worried since I heard @Larry was considering removing them.

[12:57] <Aankhen``> But that was quite a while ago, so maybe the "considering" was completed and the notion discarded. =)

[12:57] <Aankhen``> ?eval my $foo = <a b c d>; "$foo"

[12:57] <evalbot6> 'a b c d' 

[12:58] <scook0> you need them if you ever want to write "my @a of Thing is MyArrayClass"

[12:58] <scook0> and using static typing without them is a bit of a pain

[12:59] <Aankhen``> I'll take your word for it.

[12:59] <scook0> not that I'm authoritative

[12:59] <Aankhen``> S'okay, you are more so than me. :-)

[13:00] <scook0> It's just that I can't imagine Larry being silly enough to deliberately omit them

[13:31] *** Aankh|Clone is now known as Aankhen``

[13:36] <svnbot6> r5834, Aankhen++ | * moved large part of functionality from HTTP::Request::CGI to new class: HTTP::Query.

[13:36] <svnbot6> r5834, Aankhen++ | * fixed &param (rw version).

[13:36] <svnbot6> r5834, Aankhen++ | * renamed &delete_param to &delete, &delete_params to &clear within HTTP::Query (HTTP::Request::CGI still uses the former versions).

[13:45] <svnbot6> r5835, Aankhen++ | * parameter added to HTTP::Headers, HTTP::Request, HTTP::Request::CGI and HTTP::Response -- URI_CLASS.

[13:45] <svnbot6> r5836, autrijus++ | * Implement the new object hierarchy as proposed in

[13:45] <svnbot6> r5836, autrijus++ |   "Elimination of Item|Pair and Any|Junction" on p6l:

[13:45] <svnbot6> r5836, autrijus++ |     - Object

[13:45] <svnbot6> r5836, autrijus++ |         - Any

[13:45] <svnbot6> r5836, autrijus++ |             - Item

[13:45] <svnbot6> r5836, autrijus++ |                 - ...pretty much everything

[13:45] <svnbot6> r5836, autrijus++ |             - Pair

[13:45] <svnbot6> r5836, autrijus++ |         - Junction

[13:45] <svnbot6> r5836, autrijus++ |     http://www.nntp.perl.org/group/perl.perl6.language/22462

[13:47] <Aankhen``> Break. &

[14:07] <svnbot6> r5837, Aankhen++ | * removed URI_CLASS parameter from HTTP::Headers.

[14:07] <svnbot6> r5837, Aankhen++ | * fixed inheritance for HTTP::Request and HTTP::Response.

[14:07] <svnbot6> r5838, Aankhen++ | * sanitized HTTP::Request::CGI somewhat. "What the heck was I thinking?"

[14:26] <jdv79> this may be an odd if not evil question but... its really novel and cool that p6 can be compiled to js but are there any plans to compile to the JVM and/or the .NET VM?

[14:26] <svnbot6> r5839, szabgab++ | * examples/ppt/cat.p6

[14:26] <svnbot6> r5839, szabgab++ |   added

[14:26] <svnbot6> r5840, szabgab++ | * docs/other/porting_howto

[14:26] <svnbot6> r5840, szabgab++ |   add info about file reading/writing

[14:26] <svnbot6> r5841, szabgab++ | * examples/cookbook/07file-access/

[14:26] <svnbot6> r5841, szabgab++ |   More cookbook entries regarding file access

[14:26] <svnbot6> r5842, autrijus++ | * `make ghci` should not trigger prelude building -- it is meant to be

[14:26] <svnbot6> r5842, autrijus++ |   run after a regular `make` or `make unoptimised`.  The reason

[14:26] <svnbot6> r5842, autrijus++ |   is that ghci won't produce the stage-1 pugs executable anyway.

[14:26] <jdv79> might be a little more practical:)

[14:27] <dudley> jdv79: stevan checked in the beginnings of a Java version of the metamodel

[14:28] <dudley> it's in perl5/org.perl6.metamodel

[14:30] <autrijus> jdv79: we need the metamodel for CLR

[14:30] <autrijus> as well as an emitter -- maybe port AbsIL over to perl6 and/or haskell.

[14:31] <svnbot6> r5843, autrijus++ | * Primitive listops now handles Pairs as regular arguments

[14:31] <svnbot6> r5843, autrijus++ |   instead of named bindings.

[14:33] <pdcawley_> Argh... any svk whizzes about?

[14:33] <autrijus> hm?

[14:33] <pdcawley_> I've deleted a subdirectory, and can't seem to get it back.

[14:33] <pdcawley_> if I do svk up, nothing returns.

[14:33] <autrijus> svk revert -R subdir

[14:34] <pdcawley_> Thanks. Obvious if you're not stupid :)

[14:34] <autrijus> :)

[14:35] * QtPlatypus ponders nominating Damian Conway for Australian of the year.

[14:44] <svnbot6> r5844, autrijus++ | * Fix Test::Builder test to run correctly from pugs's basepath.

[14:44] <svnbot6> r5844, autrijus++ |   We really should consolidate the run_pugs stuff into Test.pm...

[14:56] <geoffb> QtPlatypus, not that I disagree, but what prompted that?

[14:56] <geoffb> (the Damian comment)

[14:58] <geoffb> BTW, went to my first Perl Mongers meeting last night, and preached the Pugs/Perl 6 goodness.  People were impressed and highly curious.  Especially the part about Haskell being involved . . .

[14:59] <autrijus> especially? :)

[14:59] <autrijus> nice. and which .pm is that?

[15:00] <geoffb> Sonoma

[15:01] <osfameron> Sonoma?

[15:01] <osfameron> ah, San Francisco area

[15:01] <geoffb> It's interesting how the new available things are scaring people, because they believed them to be required.

[15:02] <geoffb> The type system especially.  Making Perl 5 junkies very nervous that their one liners and micro hacks are a thing of the past

[15:02] <acme> there's a sonoma.pm?

[15:03] <geoffb> osfameron, yea, O'Reilly HQ area (it used to be there, but then moved to a guitar factory in Santa Rosa)

[15:03] <geoffb> acme, yep

[15:03] <acme> and i missed it!

[15:03] <geoffb> I never thought to look before, since I knew there were a couple in SF and Oakland I think, but sure enough, there it was

[15:05] <geoffb> And BTW, the guy that owns the guitar factory (Alembic) is one of the coolest ubergeeks I can think of.  Storage areas there are like a history of computing.  They still use a commodore PET on the factory floor to control a machine that used to be driven by paper tape.  :-)

[15:11] <stevan> howdy all

[15:11] <geoffb> howdy, stevan 

[15:12] <stevan> geoffb: preachin' the P6::Bible I see :)

[15:12] <geoffb> nodnod

[15:13] <geoffb> I started to describe meta-operators, and the guitar company owner goes "Oh, like APL?"

[15:13] <stevan> everybody secretly loves APL I think

[15:13] <geoffb> heh

[15:13] <stevan> just no one will admit it

[15:14] <geoffb> This guy stood a decent chance of actually being able to competently program in it, though I didn't ask

[15:18] <coral> APL?

[15:18] <svnbot6> r5845, autrijus++ | * `Item`, not `Scalar`, becomes the default type for unannotated $param

[15:18] <svnbot6> r5845, autrijus++ |   in parameter list.

[15:18] <svnbot6> r5846, autrijus++ | * Tree.pm's use of `Any $node` in BUILD defeated named binding

[15:18] <svnbot6> r5846, autrijus++ |   under the new treatment of `Any` that includes `Pair`. fixed.

[15:18] <stevan> coral: A Programming Language is what it stands for IIRC

[15:18] <stevan> google it

[15:18] <coral> heh, got it

[15:19] <QtPlatypus> geoffb: Seeing an Australian of the year nonimation add.

[15:19] <geoffb> nodnod

[15:22] <QtPlatypus> I think perl programers like it because combines extreem power with line noise like chars.

[15:22] <QtPlatypus> (APL that is)

[15:32] <eric256> over a week without a journal entry?   is everyone okay? ;)

[15:33] <stevan> I got the shakes 

[15:33] <stevan> cold sweats

[15:33] <geoffb> And I've got a new facial tic

[15:33] <stevan> leg cramps, and flu like symptoms

[15:33] <autrijus> eric256: I'm alive... that's all. got lots of $job all of a sudden.

[15:33] <Khisanth> stevan: you have been sitting around too long!

[15:33] <geoffb> iblech: at the PM meeting when I talked about pugs, the biggest oohs and aahs came when I explained that we have a JS backend.

[15:34] <stevan> Khisanth: :)

[15:34] <Khisanth> hmm are any of the adverbial stuff being parsed yet?

[15:34] <stevan> autrijus: I assumed you were playing the Sims... not $working

[15:34] <iblech> geoffb: :)

[15:34] <Khisanth> besides for s/// and m//

[15:34] *** knewt_ is now known as knewt

[15:34] <iblech> Khisanth: @array.map:{...}?

[15:34] <autrijus> stevan: the Sims only lasted for 2 days

[15:34] <autrijus> the rest is $work

[15:34] <stevan> autrijus: not virtual enough a reality for you ;)

[15:34] <autrijus> that's right

[15:35] <autrijus> actually most of the time I'm still in paper-reading (and TaPL rereading) mode

[15:35] <eric256> $work is evil. ;)

[15:35] <autrijus> as I'm trying to map PIL into something less baroque, and apply colored local type inferences

[15:35] <stevan> autrijus: I have been learning CLOS myself :) # the Art of the MetaObject protocol

[15:35] <autrijus> so I can unify Cxt with Typ

[15:35] <stevan> $work--

[15:36] <stevan> autrijus: if I do a metamodel for the CLR, what language should I do it in? C#? or ISALM?

[15:36] <geoffb> & # cat ==> vet

[15:36] <eric256> class Work is Evil and Bad {}   # we need an "and" for classes

[15:36] <stevan> geoffb: if you keep squishing the cat through pipes, of course you going to have to take it to the vet 

[15:37] <autrijus> stevan: C# for sure

[15:37] <stevan> eric256: class Work is Evil|Bad {} 

[15:37] <stevan> junctive types :)

[15:37] <stevan> (although that wont really work)

[15:37] <stevan> autrijus: ok, if I can get Mono working, I will drop the Java port (at least for now)

[15:38] <autrijus> cool

[15:39] <Khisanth> does the java port emit bytecode?

[15:39] <stevan> autrijus: when you have a second, take a look at MetaClass.pm, about 50% of it is defined as a MetaClass instance :)

[15:39] <autrijus> Khisanth: the java port is only object space for now, not emitter

[15:39] <stevan> Khisanth: no, it is just a port of the MetaModel classes

[15:39] <autrijus> stevan: oooh

[15:39] <stevan> autrijus: :) 

[15:40] <stevan> (The Art of the MetaObject Protocol)++ (CLOS)++

[15:40] <autrijus> so, you think I can start porting?

[15:40] <stevan> autrijus: not yet (if you can wait) I want to try and get that percentage higher

[15:40] <autrijus> sure, I can wait

[15:42] <autrijus> I want to get the depth subtyping for role's .does() working

[15:42] <autrijus> to kill the java bug of invariant subtyping for parametric types

[15:42] <autrijus> eg:

[15:42] <stevan> depth subtyping?

[15:42] <autrijus> role Foo[$t] { ... }

[15:42] <autrijus> Foo[Int].does(Foo[Num]) # t? f?

[15:43] <autrijus> in Java that needs to be false always

[15:43] <stevan> Funky

[15:43] <autrijus> actually CLR too

[15:44] <integral> does perl6 compute contra/co-variancy like o'haskell?

[15:44] <autrijus> integral: that's what I'm trying to hack in, yes.

[15:44] <autrijus> o'haskell does that?

[15:45] <autrijus> ah. indeed it does

[15:46] <autrijus> so the idea is to inspect the definition in the body of Foo to see the use of $t

[15:47] <integral> that'll be cool,   it'll confuse the hell out of newbies,  but it'll be damn cool using long words to explain it :-P

[15:47] <autrijus> and if it's only used in "returns" position then Foo[Int].does(Foo[Num]) indeed is true.

[15:48] <autrijus> however if $t is used in parameter lists, then Foo[Num].does(Foo[Int]) instead.

[15:48] <autrijus> if it's used in both positions, we'll be forced to do what java/clr does and declare that neither does the other.

[15:48] <integral> so if a class gets extended it's variancy could change

[15:48] <autrijus> (and if it's not used, then Foo[whatever].does(Foo[whatever_else]))

[15:48] <integral> autrijus: that's what o'haskell does too

[15:48] <autrijus> yes.

[15:48] <autrijus> good. I ran into that idea in TaPL

[15:49] <autrijus> TaPL calls it Source and Sink, and I thought it's really cool.

[15:50] <autrijus> integral: so yes, when you reopen a type, then variancy would indeed change. which is just as well, because .does is a runtime operation.

[15:51] <autrijus> all compiler-inferred hints in p6 is just hints.

[15:51] <Aankhen``> ?eval sub foo (*&block) { &block() }; foo():{ "foo" }

[15:51] <evalbot6> pugs: Internal error:     doBindArray: unexpected char: '&' Please file a bug report. 

[15:51] <autrijus> they can be destroyed and recalculated in runtime.

[15:51] <Aankhen``> ?eval sub foo (Code *$block) { $block.() }; foo():{ "foo" }

[15:51] <evalbot6> 'foo' 

[15:51] <Aankhen``> Is there any chance `*&block` could be made to work?

[15:51] <autrijus> sure. fixed. committing.

[15:51] <autrijus> please write a test

[15:52] <Aankhen``> Yay.

[15:52] <Aankhen``> OK, one sec.

[15:59] <Aankhen``> Added as t/subroutines/slurpy_code_param.t -- very basic tests.

[15:59] <Aankhen``> Gotta run to dinner.

[15:59] <Aankhen``> BBIAF.

[15:59] <svnbot6> r5847, autrijus++ | * This should work:

[15:59] <svnbot6> r5847, autrijus++ |     sub foo (*&block) { &block() }; foo():{ "foo" }

[15:59] <svnbot6> r5847, autrijus++ |   i.e. slurpy non-@ sigils should be treated as slurpy scalars.

[15:59] <svnbot6> r5848, Aankhen++ | * added tests for `Code *$block` and `*&block`.

[15:59] <svnbot6> r5849, Aankhen++ | * t/slurpy_code_param.t - usual SVN props.

[16:17] <autrijus> Atom.isa(Item), not Item.isa(Atom), because you say "that pair of people are an item."

[16:17] <autrijus> -- lwall

[16:17] * autrijus rolls eyes

[16:17] <autrijus> er.

[16:18] <autrijus> Pair.isa(Item), not Item.isa(Pair), because you say "that pair of people are an item."

[16:18] <autrijus> good. he changed his mind immediately two lines below.

[16:20] <dudley> so, Item.isa(Atom)?

[16:25] <autrijus> no, not really. I don't think Atom is a great idea

[16:25] <autrijus> I need to sleep. see ya tomorrow :) *wave*

[16:26] <dudley> 'night

[16:36] <Aankhen``> ?eval class Foo { does Hash; }

[16:36] <evalbot6> ['Object', 'Hash'] 

[16:36] <Aankhen``> ?eval class Foo { does Hash; }; my $foo = Foo.new(); $foo<bar> = "baz"; $foo.keys

[16:36] <evalbot6> Error: Not a keyed reference: VObject (MkObject {objType = (mkType "Foo"), objAttrs = <ref>, objOpaque = Nothing, objId = 51}) 

[16:39] <iblech> Aankhen``: Pugs doesn't care ATM whether somebody does the Hash role -- it only checks $foo for being a VHash

[16:39] <Aankhen``> OK, thanks.

[16:39] <Aankhen``> Would that work the way it seems to, though?

[16:42] <iblech> Yep

[16:42] <Aankhen``> Kewl.

[16:43] <Aankhen``> What about this: class Foo does Hash { has %:bar; method STORE ($name, $val) { %:bar{$name} = $val }; method FETCH ($name) { %:bar{$name} } }

[16:45] <iblech> I asked Larry this once. The actual method names might be different, but that's the idea, I think. Also note that IIRC the key ($name) is *not* a Str, but a special Key object supporting multi-dimensional lookup

[16:46] <Aankhen``> Ah, okay.

[16:46] <Aankhen``> So it would entail different method names and... a different way of using $name?

[16:47] <iblech> Yep, I think so

[16:47] <svnbot6> r5850, Aankhen++ | * HTTP::Query: populate `@:params` with names to preserve order.

[16:47] <Aankhen``> Kewl.

[16:47] <Aankhen``> Thanks for the info. :-)

[16:48] <iblech> Sure :)

[16:48] <Aankhen``> ?eval my $foo = "__ab_cd__"; $foo .= trans(_ => '-'); $foo

[16:48] <evalbot6> \'__ab_cd__' 

[16:48] <Aankhen``> ?eval my $foo = "__ab_cd__"; $foo .= trans('_' => '-'); $foo

[16:48] <evalbot6> \'__ab_cd__' 

[16:48] <Aankhen``> ?eval my $foo = "__ab_cd__"; $foo.trans('_' => '-')

[16:48] <evalbot6> '__ab_cd__' 

[16:48] <Aankhen``> ?eval my $foo = "__ab_cd__"; $foo.trans('a' => '-')

[16:48] <evalbot6> '__-b_cd__' 

[16:49] <Aankhen``> Weird.

[16:50] <iblech> Ah! That's probably because _ => ... is bound to the parameter %_ (which all methods have (dunno why though)), not to *@all_substitutions

[16:51] <Aankhen``> Oh, right.

[16:51] <Aankhen``> All methods... hmm, IIRC, only submethods ought to have an automatic %_.

[16:51] <Aankhen``> *%_, even.

[16:51] <Aankhen``> Would it be a problem if I changed *%intable to *%_?

[16:52] <Aankhen``> Wait, that still wouldn't fix it.

[16:52] <Aankhen``> Bah.

[16:52] <iblech> Dunno, as I don't know what *%_ is exactly :)

[16:53] <Aankhen``> Ahh, it's okay, it's not of critical importance.

[17:05] <svnbot6> r5851, Aankhen++ | * HTTP::Query: fixed FETCH and STORE blocks for &param.

[17:41] <svnbot6> r5852, iblech++ | * Usual svn properties.

[17:41] <svnbot6> r5852, iblech++ | * t/builtins/bool/true.t, t/builtins/lists/map.t, t/builtins/control_flow/try.t:

[17:41] <svnbot6> r5852, iblech++ |   unEVALs.

[17:41] <svnbot6> r5852, iblech++ | * PIL2JS:

[17:41] <svnbot6> r5852, iblech++ |   * my $arrayref = @array causes $arrayref to actually contain an arrayref now.

[17:47] <iblech> FYI, updated JS testsuite: http://m19s28.vlinux.de/iblech/stuff/not_perm/pil2js-demo/t/

[17:51] <autrijus> do we get a jssmoke? :)

[17:53] <iblech> runjs.pl works :) But, as I haven't found a way to disable loading of Test.pm (it's precompiled), it's sloow...

[17:55] <iblech> Anyway, need to sleep now (like you, autrijus :D) :)

[17:55] <iblech> Night all :)

[17:56] <autrijus> iblech++ # great work

[18:29] <gaal> meow

[18:32] <autrijus> purr

[18:32] <gaal> sup :)

[18:33] <autrijus> doing boring $job ;)

[18:33] <gaal> lots of $work for everyone...

[18:33] <autrijus> indeed

[18:33] <autrijus> when's the hackathon again?

[18:33] <gaal> :(

[18:33] <gaal> it was, except that it wasn't

[18:33] <autrijus> aw. how come

[18:34] <gaal> because not many people came. nothingmuch was incapacitated

[18:34] <gaal> well, szabgab (my successor in Israel.pm moose-with-the-hatitude) came, and eilara did too (he's the hacker responsible for Apect.pm)

[18:35] <gaal> and it was lots of fun showing off pugs to interested people

[18:35] <gaal> but they could only stay for part of the time

[18:35] <gaal> so my fridge is full of mozarella and other pizza parts :(

[18:36] <gaal> i think next time i'll make registration mandatory :)

[18:36] <autrijus> riight :)

[18:36] <gaal> !-2 =~ s/Apect/Aspect/

[18:37] <gaal> very cool module

[18:37] <gaal> made somewhat redundant by p6; or maybe not.

[18:39] <gaal> lumi and shlomi also came, and it was fun for a while but not much hacking was acocmplished.

[18:41] <gaal> i'm off to help a friend move two cats. later!

[18:42] <autrijus> ciao!

[18:52] *** tewk_ is now known as tewk

[19:27] * QtPlatypus giggles mildly "Whenever I search for perl6 stuff in google, google adds trys to sell me books about training my pug puppy"

[19:30] <geoffb> heh

[19:55] <svnbot6> r5853 | iblech++ | Changed paths:

[19:55] <svnbot6> r5853 | iblech++ | * t/subroutines/subroutine.t -- unEVAL.

[19:55] <svnbot6> r5853 | iblech++ | * Pugs.Compile -- Emit &circumfix:<${ }> for Syn "${}" (and similar for

[19:55] <svnbot6> r5853 | iblech++ |   @{}, etc.) so I can implement the dereferencers in PIL2JS.

[19:55] <svnbot6> r5853 | iblech++ | * PIL2JS: Prelude::JS::Ref -- Implemented ${}, @{}, etc.

[19:58] <autrijus> I thought iblech is sleeping.

[19:58] <autrijus> obviously he acquired the commit-from-sleep power too

[20:07] <Steve_p> There you are!

[20:07] <Steve_p> autrijus, I'm trying to test some "edge-case" type modules on ponie

[20:07] <autrijus> cool

[20:08] <Steve_p> Are there some of your's that you would suggest?

[20:08] <autrijus> Devel::Hints

[20:08] <autrijus> PAR itself

[20:08] <Steve_p> I tried PAR and it failed on blead and ponie

[20:09] <autrijus> PerlIO::eol

[20:14] <Steve_p> OK, back

[20:15] <Steve_p> Yeah, I need to look into the blead breakage a bit more to see what's happening.  It might just be an OpenBSD thing :-/

[20:15] <autrijus> *nod*

[20:35] <Steve_p> Hmmm...Devel::Hints had problems, but I think that the hint code has been touched in blead.  I try it there too, but it looks like a great edge case ;-)

[20:39] <Aankhen``> G'night.

[21:16] <Darren_Duncan> I didn't see any replies yet to my p6l posting ... what do you guys think about Item being broken down into Single and Pair?

[21:16] <Darren_Duncan> where Item is parallel to Junction

[21:17] <coral> Junction!

[21:17] <coral> er, scuse me. hi.

[21:19] <autrijus> Darren_Duncan: there's still the problem of Any 

[21:19] <autrijus> if Any is accepted to be the top type, then sure, Single is a good name

[21:20] <autrijus> but I don't think p6l consensus was for Any to include Junction. in that case Any takes place of Single.

[21:20] <svnbot6> r5854 | fglock++ | Changed paths:

[21:20] <svnbot6> r5854 | fglock++ | * can't find out the right syntax for coroutine-to-list conversion

[21:21] <kolibrie> so, Any really should get a new name, if it doesn't describe anything

[21:21] <autrijus> er, a type system needs a top type

[21:21] <autrijus> usually in other languaes it's Object

[21:21] <kolibrie> true, there needs to be something there

[21:22] <autrijus> and if bottom type is called All, then that's cute to call the top type Any. but I think that's too cute. I have no problem for the top type be called Object, myself

[21:23] <autrijus> hm, "Eigen" for the non-junction type

[21:23] <autrijus> nah. bad idea

[21:23] <Darren_Duncan> In any event, my answer was separate from the Any/Object thing ...

[21:23] <Darren_Duncan> I was coming up with some way to organize single items, pairs, and junctions

[21:23] <Darren_Duncan> something that isn't a junction

[21:23] <autrijus> right, your proposam amounts to s/Atom/Single/

[21:24] <Darren_Duncan> yes

[21:24] <autrijus> which I don't have a problem with either :)

[21:24] <Darren_Duncan> but also that Pair isa Item

[21:24] <kolibrie> I like Single better than Atom

[21:24] <kolibrie> I think

[21:24] <autrijus> basically I was arguing that there's a value for Any to be the NonJunction type

[21:24] <autrijus> because

[21:25] <autrijus> -> Any $x { ... } 

[21:25] <Darren_Duncan> Anyway, if there is support for what I proposed, it would be nice to hear it on list where it's more visible

[21:25] <autrijus> should probably not accept junctions in $x position

[21:25] <autrijus> in that case we don't need Single; Item can be Single and Any can be Item.

[21:26] <autrijus> but if Any is instead taken to include Junction, then I fully support what you said :)

[21:26] <Darren_Duncan> I think that Any should include Junction

[21:26] <kolibrie> in my mind, the word Any includes Junction

[21:26] <kolibrie> but I'd like to have a NonJunction thing

[21:27] <kolibrie> just maybe not called Any, to avoid confusion

[21:27] <autrijus> right. in that case Item is fine.

[21:27] <Darren_Duncan> in my mind, Any is about as broad as anything can be ... when you say Any, there isn't anything it can't be

[21:27] <autrijus> and NonPair Item is Single.

[21:27] <kolibrie> yes, sounds right

[21:28] <clkao> heh autrijus. svk is now on eurooscon schedule.

[21:29] <Darren_Duncan> meaning what?

[21:29] <Darren_Duncan> do you mean its development team?

[21:30] <autrijus> Darren_Duncan: I replied on list.

[21:31] <Darren_Duncan> great

[21:32] <autrijus> Darren_Duncan: as you are one of the few people who actually wrote 'returns'

[21:32] <Darren_Duncan> I saw you had a post on it

[21:33] <autrijus> maybe you'd like to check whether my #2 and #3 checks both makes sense to you

[21:33] <autrijus> even on compile time

[21:34] <autrijus> i.e. for both to happen on compile time, when you write "returns Str", you can't return a supertype of Str, nor can you use that function in a position that demands a subtype of Str.

[21:34] <autrijus> (I happen to think that's sane)

[21:34] <Darren_Duncan> have to think

[21:35] <osfameron> can you cast in perl6 like in Java?

[21:35] <autrijus> osfameron: coerce:<as>

[21:35] <autrijus> A12

[21:35] <osfameron> okie

[21:36] <Darren_Duncan> before reading too far in, my impression with typing a 'returns' is that it has the same purpose as typing an argument

[21:36] <osfameron> so... more verbose, but presumably has to be used much less

[21:36] <Darren_Duncan> doing for output what is done for input

[21:36] <autrijus> osfameron: er no, it is the name of sub

[21:36] <autrijus> it's used like

[21:36] <autrijus> foo("123" as Int)

[21:37] <autrijus> Darren_Duncan: right... but output has two sides

[21:37] <osfameron> heh, 'll reread A12, sorry :-)

[21:38] <Shillo> Hullo, folks!

[21:38] <Darren_Duncan> considering that the line between compile and runtime actions is kind of blurred, both types of declaration look more like a coersion or promotion

[21:38] <Darren_Duncan> actually, just coersion

[21:39] <autrijus> hi Shillo 

[21:39] <autrijus> Darren_Duncan: sure. my point was, is that two coercions or one

[21:39] <Darren_Duncan> in my mind, if you declare a 'returns Any', and the function returns a Str, then a test on the function's return value should say it is a Str and not an Any

[21:40] <autrijus> yup but that check can't be done until runtime

[21:40] <Darren_Duncan> yes

[21:40] <Shillo> autrijus: Hey! Looking at your blog, thought you were abducted by evil agents of Lambda!

[21:40] <autrijus> so that amounts to solution #A of mine

[21:40] <autrijus> Shillo: no, evil agents of $work

[21:41] <autrijus> I think #A agrees with people's intuition; however it also means practically no type errors will happen at compile time

[21:41] <autrijus> since all compound terms will essentially pass all typechecks in any position

[21:41] <Darren_Duncan> yes, I noticed the journal is out of date

[21:42] <Darren_Duncan> still thinking

[21:42] <autrijus> #C is the solution adopted by local type inferencing

[21:42] <autrijus> if you leave the "returns" off, the inferencer will use "Any|All"

[21:43] <autrijus> that has the elegance of when you actually write a type annotation, you will get typecheck

[21:43] <autrijus> but if you leave it off nothing bad will happen

[21:43] <autrijus> it's closer to the ideal of soft, incremental typing

[21:44] <autrijus> #D is the classical ML-style solution. works really well, not neccessarily perlish.

[21:44] <autrijus> I don't know if anyone actually thinks #B is sane.

[21:45] <Darren_Duncan> it seems to me that using Any could simply force checking to run time, whereas to get compile time checking you can't use Any

[21:45] <autrijus> but that's not limited to Any

[21:45] <autrijus> consider if I've written Object instead

[21:45] <autrijus> or Item

[21:45] <autrijus> or Single

[21:45] <Darren_Duncan> yes

[21:45] <autrijus> so it's really, how "dynamic" perl6 is

[21:48] <svnbot6> r5855 | iblech++ | Changed paths:

[21:48] <svnbot6> r5855 | iblech++ | PIL2JS:

[21:48] <svnbot6> r5855 | iblech++ |   * New primitive: &infix:<cmp>

[21:48] <svnbot6> r5855 | iblech++ |   * &sort implemented, but doesn't work yet if the comparator block is omitted,

[21:48] <svnbot6> r5855 | iblech++ |     willl look into this tomorrow.

[21:50] <Darren_Duncan> perhaps Perl 6 could provide a signature for type declarations that forces tests to happen at compile time ...

[21:51] <Darren_Duncan> such that any same type or promotable type would work, but a coercable type would cause a compile error

[21:51] <autrijus> that's a thought, but then we still have the problem of which one is the default. :)

[21:51] <autrijus> which, really, is what most people will use.

[21:51] <Darren_Duncan> yes

[21:51] <stevan> autrijus: see r5856 

[21:52] <stevan> the circle is now complete... MetaClass is defined as an instance of MetaClass

[21:52] <Darren_Duncan> attaboy

[21:52] <stevan> one bootstrap hack, and some private methods are all that remain

[21:53] <kolibrie> stevan: woo hoo!

[21:53] <autrijus> oooh.

[21:53] <stevan> autrijus: we need to discuss how to do things like attributes and methods

[21:53] <kolibrie> any way, later all

[21:53] <svnbot6> r5856 | Stevan++ | Changed paths:

[21:53] <svnbot6> r5856 | Stevan++ | Perl6::MetaModel - (p5 version)

[21:53] <svnbot6> r5856 | Stevan++ | * MetaClass is now defined in an instance of MetaClass

[21:53] <svnbot6> r5856 | Stevan++ | ... the circle is now complete !!!!! muhahahahaha :)

[21:54] <stevan> they cannot be defined in the metamodel (at least not easily)

[21:54] <stevan> but this is a discussion for later, time for me to eat &

[21:54] * stevan is also on dial-up, so I must sign off as well... dial_up--

[22:38] <putter> I observe that with pugs head optimized on amd64 FC3 with ghc 6.4.1.20050711,

[22:38] <putter> Compiling Pugs.Run.Perl5   ( src/Pugs/Run/Perl5.hs, src/Pugs/Run/Perl5.o )

[22:38] <putter> /tmp/ghc18476.hc: In function `__stginit_PugsziRunziPerl5_':

[22:38] <putter> /tmp/ghc18476.hc:3117: warning: implicit declaration of function `getStablePtr'

[22:38] <putter> And while make test is doing ok, some simple things segfault it.

[22:40] <Limbic_Region> putter - I see those kinds of messages on Win32 but don't think I have a problem with make test

[22:41] <Limbic_Region> well - since I have been in lurker only mode I only build Pugs about once a day and make test - well, I haven't

[22:43] <putter> bah!  as so frequently happens, putter is simply confused.  two test files, same name, in different directories.  one does something simple.  one invokes pge/parrot.  confuse one with another, and the resulting segfaults are unexpected.  sorry for the noise.

[22:45] <putter> For clarity - my segfaults were due to calling pge.  which is unsurprising.  ghc is behaving just fine.

[22:46] <PerlJam> Are there open tickets for the PGE problems?

[22:54] <putter> PerlJam: I'm afraid pge/parrot development isn't quite organized that way.  The "best" PGE is on a parrot branch (leo-ctx5) which hasn't been merged into trunk yet.  And contributing failing tests is a curated process which can take, well, a long time.  So no.

[22:55] <PerlJam> in that case I think I'll return to waiting for leo to merge his changes into the trunk

[22:55] <PerlJam> and occasionally prod Pm about PGE

[22:56] <PerlJam> Hmm. oscon is next week isn't it.

[22:56] <PerlJam> ?

[22:59] * PerlJam wanders in a homeward direction

[23:00] <putter> leo-ctx5 has been usable in the past, though it doesn't build for me (amd64?) at the moment.  note that sometimes making pugs with an external parrot, rather than embedded, is more stable.

[23:01] <putter> PerlJam: do you have something particular you were going to use pge for?  (putter looks around for motivation to finish a rules-on-pcre kludge).

[23:27] <Darren_D1ncan> testing

[23:27] <Darren_D1ncan> how does this happen?  that my nick just changes?

[23:28] <Darren_D1ncan> I didn't logout/in

[23:28] <Darren_D1ncan> also, I got 3 copies of that 'topic changed to ...' that are the same

[23:31] <Darren_D1ncan> will leave and return ...

[23:34] <Darren_Duncan> testink

[23:34] <Darren_Duncan> looks right again

[23:44] <putter> &

