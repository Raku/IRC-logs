[01:44] <kelan> ?eval 1+1

[01:45] <QtPlatypus> Eval bot is dead kelan 

[01:46] <kelan> oh?

[02:34] <geoffb> Re: the "usual SVN properties" -- I have another project that I have just moved to SVN, that should work on both *nix and Win32.  Is there any reason not to just apply the same SVN props as we use here to basically every non-binary file?

[02:35] <mugwump> sure, if you have mixed win32/unix devs and prefer utf-8

[02:35] <geoffb> Meaning "sure, it's the right thing to do"?

[02:36] <mugwump> Āŷĕ

[02:36] <geoffb> OK, wheee

[02:36] <geoffb> Now to update properties on 160 files . . . .

[02:41] <Darren_Duncan> you should just use utf-8 everywhere regardless of platform

[06:23] <nothingmuch> evening from the hackathon

[06:34] <nothingmuch_> hackathon networking has been restored

[06:44] <Darren_Duncan> good evening to you too

[06:44] <Darren_Duncan> checking journal ...

[06:45] <Darren_Duncan> I noticed no svn commits since this morning or earlier

[06:45] <Darren_Duncan> no journal ... maybe another time

[06:45] <Darren_Duncan> good night

[07:10] <nothingmuch_> no internet up till now

[07:10] <nothingmuch_> autrijus already went to bed

[07:10] <nothingmuch_> which means the commit should start momentarily

[07:10] *** nothingmuch_ is now known as nothingmuch

[08:50] <nothingmuch> foo!

[08:52] <broquaint> bar!

[09:11] <nothingmuch> good night good people of the world

[09:26] <Juerd> Is being able to init a hash with a hashref a bug?

[09:26] <Juerd> It certainly ought to be, because a hashref is a valid hash key.

[09:27] <broquaint> Is it not magically deref'ed in list context?

[09:27] <Juerd> No

[09:28] <Juerd> References may never deref in list context or generic scalar context

[09:28] <Juerd> Dereffing can only happen with explicit use-as-array or use-as-hash

[09:29] <Juerd> %hash = { 1 => 2 } should set %hash{ { 1 => 2 } } = undef

[09:32] <broquaint> Fair enough. Sounds like a bug.

[10:12] <arcady> I'm not so sure it's a bug

[10:15] <arcady> oh, wait, it is

[10:15] <arcady> %hash = [ 1, 2] also does the same thing

[12:22] *** Nattfodd is now known as Odin

[12:22] *** Odin is now known as Nattfodd

[13:07] <pdcawley> ?eval sub foo { my $x = 1; return sub ($codestring) { eval $codestring } }; foo()("$x")

[13:08] <broquaint> I think the evalbot is down atm.

[13:09] <pdcawley> Yeah, I guessed that. Just tried it on feather instead.

[13:10] <broquaint> This looks to work as expected: sub foo { my $x = 1; return sub ($codestring) { eval($codestring).perl.say } }; foo()(q[$x])

[13:10] <Juerd> What was expected?

[13:11] <broquaint> To return the value of $x

[13:11] <Juerd> I see.

[13:11] <Juerd> I think it should by default not work

[13:12] <broquaint> Why is that?

[13:12] <Juerd> It kind of defeats the purpose of having a garbage collector.

[13:12] <broquaint> ?

[13:12] <pdcawley> I'd disagree, you know lexically that you've got an 'undecided' scope down there, so for that function you hang onto the entire lexical stack.

[13:13] <Juerd> pdcawley: Because of the eval? Or always?

[13:13] <Juerd> I can live with smart detection of things that eval

[13:13] <pdcawley> Because of the eval.

[13:13] <Juerd> But not if that is taken to extremes: calling another sub that evals, which could in theory try to access $CALLER::x

[13:14] <Juerd> Although it will be weird to have code that starts working when you add eval ''; :)

[13:14] <Juerd> I'm not sure what I think of this

[13:14] <Juerd> The impact of deep analysis is huge, but it would be needed to avoid weirdness

[13:15] <pdcawley> I'm not sure what GC has to do with anything tbh.

[13:15] <pdcawley> At least, not in that example.

[13:15] <pdcawley> Actually, no, tell a lie.

[13:15] <Juerd> If variables are held onto, they cannot be destroyed.

[13:16] <pdcawley> Until the instance of teh sub that's holding onto them is itself destroyed.

[13:16] <Juerd> That is true, but that can take a very long time.

[13:16] <pdcawley> And that's a problem to someone writing that kind of code because?

[13:17] <pdcawley> If you're writing that it's because it's precisely what you want.

[13:17] <Juerd> Because my values are often 100 MB.

[13:17] <Juerd> One little string eval used as a shortcut could severely fuck up memory usage for the kind of scripts I use.

[13:17] <Juerd> I'm not sure I like the idea of big red flags with every single string eval, as in PHP.

[13:18] <pdcawley> Juerd: But things like that are only going to be seriously long lived when you do &whatever := func_that_returns_a_func.

[13:18] <pdcawley> Remember, you don't start holding onto the stack until and unless you call foo.

[13:19] <Juerd> Or put them in a hash for much later use.

[13:19] <Juerd> Which I tend to do. I use anonymous subs all over the place. I like working with them.

[13:19] <pdcawley> Anon subs with evals in them?

[13:19] <Juerd> I admit that I don't usually combine these two things: string eval and storing closures

[13:19] <pdcawley> And you're stashing them with side effects?

[13:19] <Juerd> But I do use both, and often too, so it's bound to happen.

[13:19] <pdcawley> How very impure of you.

[13:20] <Juerd> Not always side effects

[13:20] <pdcawley> Stashing them in a longlived hash smacks of side effects to me.

[13:20] <Juerd> The problem is that Perl can't see that eval "$integer1 / $integer2" is in fact rather pure -- it has to account for $integer1 being a string that uses a variable.

[13:21] <pdcawley> Yeah. Great isn't it?

[13:21] <Juerd> No, not really.

[13:21] <pdcawley> All htat means is that every sub in that sub's lexical chain (not dynamic) needs to close over everything.

[13:22] <Juerd> Which may mean my 100 MB variable is closed over without any chance of it ever being needed. That's a terrible waste of memory.

[13:22] <pdcawley> Then write your code more carefully.

[13:22] <Juerd> In general, if extra memory can be used to gain some speed up, I'm all for it. But this is waste.

[13:22] <Juerd> I don't always want to write code carefully. That is WHY I like Perl.

[13:23] <Juerd> It lets me code carefully, when I want that.

[13:23] <Juerd> But is still the useful fast tool if I don't.

[13:23] <Juerd> I'm not in the "if you code sloppily, every bit of slowdown is your own fault" camp

[13:24] <pdcawley> I'm not in the 'closing down useful possibilities in order to chase performance' camp either.

[13:25] <Juerd> We don't have string eval to code carefully. It's there especially for the people who don't care much about purity, because they can sometimes cut a few corners and be home earlier.

[13:25] <pdcawley> That's something the programmer should be doing, not the language.

[13:25] <pdcawley> Disagree, very strongly.

[13:25] <Juerd> pdcawley: The problem with this is that analysis is expensive. You can't just look for eval, you also have to look for my_eval, that uses eval.

[13:25] <Juerd> Which means that in practice, every single sub needs to have a flag that says wether it uses something that is flagged.

[13:26] <pdcawley> But you know the lexical structure at compile time. This has nothing to do with the dynamic structure.

[13:26] <Juerd> Which can result in numerous subs being tainted in the way that using it will cause the enclosing block to close over the entire lexical scope, which is a slowdown at very great distance.

[13:27] <Juerd> This isn't a bug you could easily find even if you wanted to.

[13:27] <pdcawley> What on earth do you mean 'using them'?

[13:27] <Juerd> I think there should be a way to close over everything, but never this implicit.

[13:28] <pdcawley> The only time it's going to crop up is when you *write* a function.

[13:28] <Juerd> pdcawley: foo calls bar, which calls quux, which calls xyzzy, which calls Some::Module::blah, which calls Other::Module::whee, which calls YetAnother::Module::blergh, which evals a string.

[13:28] <Juerd> pdcawley: Now foo is as eval, in that when it is used, perl must close over all variables in scope.

[13:28] <Juerd> pdcawley: Because miles away, something evals, which could use $CALLER::CALLER::CALLER..::x

[13:29] <pdcawley> And which has no effect on teh lexical state of bar, quux, xyzzy, Some::Module::blah, or Other::Module::whee.

[13:29] <Juerd> Now, if I use foo in the closure that I return from a sub that also gets a huge variable, the variable is kept, even if it will never be necessary in YetAnotherModule::Blergh's eval

[13:30] <Juerd> And all that because one module author of code I presumably neither wrote nor read cut a corner by using eval.

[13:30] <Juerd> Good luck figuring out why your program performs so badly...

[13:30] <pdcawley> To even begin to implement your straw man you have to solve the halting problem. That's not what I'm proposing.

[13:31] <Juerd> I'm saying that if you want eval '$x' to work, you should somewhere draw the line, and that that line is CALLER. If you also want '$CALLER::x' to work, you lose a terrible amount of efficiency.

[13:31] <pdcawley> Or you say "This is a language where we value that, turn it on for everything".

[13:32] <Juerd> So the purity and predictability must be broken somewhere in order to avoid greater problems.

[13:32] <pdcawley> Full speed ahead and damn the torpedoes.

[13:32] <Juerd> pdcawley: I don't think enabling it for everything is an option even, if we want Perl to ever be recognised as a smart and efficient language.

[13:33] <Juerd> So half-enabling and not-enabling are the things I'm personally trying to choose from, and I tend to choose not-enabling by default, with some option of half or fully enabling.

[13:34] <Juerd> (If it were up to me, CALLER:: would be enterily illegal outside signatures)

[13:34] <pdcawley> Argh. Actually, I used Perl as the pseudocode for something I'm arguing that Parrot must support; the CALLER thing should come fenced about with "Using this is as bad as using $& was in Perl 5 days!" warnings.

[13:34] <pdcawley> Juerd: I like it for weird introspective and macroy ideas.

[13:35] <Juerd> I agree that CALLER is a problem. Still, it is specced, and we need to work around problems it creates.

[13:35] <Juerd> pdcawley: Then if you need it, you can specify that in the signature :)

[13:35] <Juerd> But never ever in any eval :)

[13:35] <pdcawley> Illegal outside macros and signatures I could go with -- you can always write a macro tweaks the signature.

[13:35] <Juerd> And CALLER::CALLER:: is just waaay to horrible to even think about, for me :)

[13:36] <pdcawley> Right. Must. Write. Summary.

[13:36] <Juerd> Have fun

[13:41] <svnbot6> r4917, iblech++ | Prelude::PIR -- Unbroke &sleep and &exit (was broken because of the recent

[13:41] <svnbot6> r4917, iblech++ | Pugs::Internals -> Perl6::Internals name change).

[13:45] <masak> Juerd: I must admit that I'm on your side in this issue. I think the analysis required for it would be too hairy.

[13:47] <autrijus> greetings lambdacamels!

[13:47] <pdcawley> Hi autrijus.

[13:47] <autrijus> we have network!

[13:47] <PerlJam> greets autrijus 

[13:48] <PerlJam> autrijus: who are "we"?  :)

[13:48] <autrijus> people who have network, of course

[13:49] * PerlJam patiently waits for someone to prod lwall into joining #perl6

[13:49] <autrijus> lambdacamels, please check this for insanity

[13:49] <autrijus> http://perlcabal.org/~autrijus/perl6-as-of-20050623.txt

[13:49] <autrijus> before I rip the relevant parts of pugs out

[13:50] <autrijus> (based on discussion with lwall last night -- but we didn't have network so I didn't get to upload it)

[13:51] <PerlJam> autrijus: prefix:<=> is .shift ?  That seems odd.

[13:51] * integral likes the bits he understands

[13:51] <autrijus> PerlJam: it's a destructive update on an iterator

[13:51] <autrijus> (in item context)

[13:51] <autrijus> for =@array { ... } ; # @array is empty after this

[13:52] <integral> Does the Any change mean that: sub foo (Any $a) { ... } no longer autothreads?

[13:52] <PerlJam> And we use the slurpy variant when we don't want destruction?

[13:53] <autrijus> er, no, slurpy context prefix:<=> is also destructive...

[13:53] <autrijus> it's more like splice(@x, 0, -1)

[13:53] <autrijus> but now splice also preserves generators

[13:53] <PerlJam> So I have to somehow explicitly declare an Iterator (or just copy the thing) if I don't want destruction?

[13:54] <autrijus> if you don't want destruction... drop the = :)

[13:54] <autrijus> for @array { ... }

[13:54] <pdcawley> I'm unsure about the my thing.

[13:54] <autrijus> pdcawley: it's conforming to the spec

[13:55] <autrijus> almost too literally.

[13:55] <PerlJam> autrijus: oh duh.  I was getting hung up.

[13:55] <pdcawley> But it can be worked around I'm sure.

[13:55] <autrijus> my $x; { say $x; $x += my($x) * $x if $x; }

[13:56] <autrijus> here the first three $x (lexically) are the same

[13:56] * pdcawley was thinking of the classic sub is_odd { $^a == 1 || is_even($^a - 1) }; sub is_even {...} type thing.

[13:56] <autrijus> and the last three $x are the same.

[13:56] <pdcawley> Eew!

[13:56] <pdcawley> And bugger me but that's bad and evil code.

[13:56] <autrijus> but the third $x is "erroneous"; we may or may not actually support it. if not supported, that'd give an error.

[13:57] <autrijus> integral: right, sub foo ($a) now means

[13:57] <autrijus> sub foo (Item $a)

[13:57] <autrijus> and the top type Any is divided into Item and Junction

[13:58] * pdcawley has been thinking idly about dependency injection... I want to write UtilityClass.new in my 'client' code and have my application framework decide that, today, UtilityClass is actually implemented using ThisSpecificUtilityClass.

[13:58] <pdcawley> Which is tangential, and I'm supposed to be writing the summary.

[13:58] * integral keeps thinking of "Knit" when things like pdcawley's are mentioned

[13:59] <PerlJam> I always think of summarys when pdcawleys are mentioned  ;-)

[14:00] <Arathorn> autrijus: in the my() example above, wouldn't the final $x be from the outer block's scope?

[14:00] <Arathorn> despite being physically placed at the end of the line, wouldn't the if-clause's condition be evaluated before the left-hand-side?

[14:00] <autrijus> Arathorn: I'd expect that too

[14:01] <autrijus> but larry sort of insisted on the strict lexicalness.

[14:01] <autrijus> i.e. it doesn't have anything to do with eventual evaluation order

[14:01] <Arathorn> but only the physical position in the file

[14:01] <Arathorn> that's diabolical, imo :\

[14:01] <autrijus> it does make it easier to explain.

[14:02] <integral> hmm, but what about: my $x = 5; { my $x = $x } ?   Isn't a strict left-to-right reading mean that this doesn't work?

[14:02] <autrijus> integral: yeah, you'd have to say $OUTER::x. that's in the spec

[14:02] <pdcawley> Well put that man!

[14:02] <pdcawley> Ghod but that's ugly.

[14:02] <integral> oh.  That makes me sad. :-)

[14:03] <autrijus> beginning of S04

[14:03] <autrijus> but consider:

[14:03] <pdcawley> my $x = 5; { $x ==> my $x } ?

[14:03] <autrijus> pdcawley: amazingly that works

[14:03] <autrijus> my $y = my($x) zor $x;

[14:03] <autrijus> now zor's evaluation order is unspecified

[14:03] <autrijus> maybe it evaluates the second argument first.

[14:03] <autrijus> you don't know.

[14:03] <autrijus> so that's the argument for strict lexicalness.

[14:04] <integral> hmm, is the old rule of declaration only taking effect after the statement too confusing?

[14:04] <Arathorn> are there any other pseudo-functions like my() whose behaviour would depend on their physical lexical position rather than their position in the parse-tree had they been a real function?

[14:05] <autrijus> integral: it was my second alternative but larry struck that down as well... because following that rule you get unspecified intra-statement results

[14:05] <autrijus> my $x if 0;

[14:05] <autrijus> Arathorn: those are called scope declarators... currently in PIL there are only three special forms that is not function application:

[14:05] <autrijus> assignment, binding, scoping

[14:05] <integral> hmm, how does this new rule fix that?

[14:06] <PerlJam> Are there any other languages that adhere to such strict lexicalness in declaration?

[14:06] <Arathorn> right

[14:06] <autrijus> PerlJam: actually, most languages do, where they are known as the let-forms

[14:06] <autrijus> and they are bound strictly lexically without regard to the evaluation order also.

[14:07] <Khisanth> hmm ugly but who in their right mind would write code like that? :)

[14:07] <pdcawley> autrijus: Woo!

[14:07] <pdcawley> PIL sounds promising.

[14:08] <autrijus> pdcawley: see src/Pugs/Compile.hs

[14:08] <autrijus> line 30 to 51 contains the entire spec of pil (For this moment)

[14:11] <pdcawley> I will. But not 'til I've finished the summary.

[14:12] <Arathorn> hm, when you for @x -> $y {} # the $y is implicitly lexically scoped, right?

[14:12] <pdcawley> BTW, do we have full continuations yet? I want to solve that sudoku.

[14:12] <pdcawley> Arathorn: It's a parameter in the block, and lexically scoped to that, yes.

[14:12] <Arathorn> pdcawley: a sudoko solver using proper continuations would def be very nice evangelism example :)

[14:12] <Arathorn> right

[14:13] <autrijus> pdcawley: let me see if i can compile it to PIR today

[14:13] <pdcawley> Arathorn: It's a horribly inefficient brute force thing, but it should work.

[14:13] <pdcawley> Once the core is working I'll see about adding the shiny interface.

[14:13] <pdcawley> The code is gloriously declarative.

[14:14] <pdcawley> NonDeterministic programming makes me happy.

[14:18] <theorbtwo> Greetings from the hackathon, BTW.

[14:18] <Juerd> 15:51  * PerlJam patiently waits for someone to prod lwall into joining #perl6

[14:19] <Juerd> PerlJam: TBH, I don't think that would be a great idea. Many ideas need to be discussed long before decision makers see them.

[14:19] <theorbtwo> The connection here sucks, so don't expect it in the next three days.

[14:20] * stevan is shocked to see autrijus did not take his laptop into the shower

[14:20] <rjbs> he did, but he's playing solitaire

[14:20] <theorbtwo> Nah, it's on the table next to me.

[14:20] <ihb> Juerd: "TBH"?

[14:21] <Khisanth> to be honest 

[14:21] <theorbtwo> We managed to get through a lot of corneer cases last night, though.

[14:22] <ihb> Khisanth: danke.

[14:22] <theorbtwo> (Not that I actually understood many of them, but...)

[14:22] <Arathorn> cana nyone point me to the right apoc/synopsis number for a discussion of how the -> bind operator thingy works?

[14:22] * Khisanth wonders how autrijus has been able to avoid electrocution with the laptop in the shower

[14:22] <Arathorn> ('cos it don't seem to be in [AS]0[1-4])

[14:23] <theorbtwo> It's defined to work just like sub, except when it doesn't/

[14:23] <QtPlatypus> I thought that -> was a sub

[14:23] <Arathorn> ah, found it in S06

[14:23] <Arathorn> bingo - thanks :)

[14:24] <pdcawley> my $a = 10; my $c = 30; my $b := $a; $a := $c; say $b;

[14:24] <pdcawley> What should that print out?

[14:27] <PerlJam> 30

[14:27] <theorbtwo> Yeah.

[14:27] <pdcawley> Exactly. So Brent's wrong about 'alias' being spelled ':=' in perl 6.

[14:30] <svnbot6> r4918, iblech++ | Emit.PIR, Prelude::PIR -- &eval_parrot (but Parrot segfaults when trying to

[14:30] <svnbot6> r4918, iblech++ | invoke a sub compiled at runtime).

[14:30] <Juerd> autrijus: How do levels work as in "0-level" for deref?

[14:31] <pdcawley> Oh fsck! 132 more messages in p6l before I've done this summary.

[14:31] <autrijus> Juerd: oh, it just means there's no autodeferencing anymore.

[14:31] <autrijus> dot explicitly dereferences

[14:31] <Juerd> autrijus: But there is for coercion, right?

[14:31] <theorbtwo> (There's still autoENreferenceing on %.foo.)

[14:31] <autrijus> bracketlikes eg $foo[0] is merely shorthand for $foo.[0]

[14:31] <Juerd> ~$aref and ~@array

[14:31] <autrijus> @foo.[0] auto-enreferences @foo into something.

[14:31] <Juerd> That I know

[14:32] <autrijus> so it'd be in effect the same as (\@foo).[0]

[14:32] <autrijus> but if you have a reference to a number, you can't use it as a number.

[14:32] <Juerd> postfix ops provide Array|Hash|Code context to their LHS

[14:32] <autrijus> so basically we're back at p5 land.

[14:32] <Juerd> Good!

[14:33] <autrijus> theorbtwo was very happy too :)

[14:33] <Juerd> Now, I do think there should be some postfix scalar dereffer, but that's for later :)

[14:33] <autrijus> maybe we can hijack .val for that.

[14:33] <Juerd> And I *still* think it can be just $, but people seem to be very opposed to that ;)

[14:33] <Juerd> $scalarref$ :)

[14:33] <autrijus> $Id$ $Date$

[14:33] <theorbtwo> .val already does enough... $foo.deref sounds good.

[14:33] <Juerd> So don't call your references that

[14:34] <PerlJam> Juerd: $foo\  :-P

[14:34] <Juerd> The exception we have to make for #! is bad enough already :)

[14:34] <Khisanth> autrijus: so on that first one it would be $y.++?

[14:34] <Juerd> PerlJam: I wish to reserve \ for infix operation.

[14:34] <theorbtwo> We do?  Isn't #! just a comment?

[14:35] <Juerd> theorbtwo: Not if it's the first line

[14:35] <autrijus> Khisanth: I don't know if it should work like that.

[14:35] <Juerd> Shebang behaviour is emulated

[14:35] <Juerd> It has to be for the -T exceptio

[14:35] <Juerd> n

[14:35] <autrijus> $$y++ # is the way I'd envision

[14:35] <Khisanth> autrijus: I am kinda hoping it wouldn't :)

[14:36] <Juerd> theorbtwo: Ooh! .deref

[14:36] <Juerd> theorbtwo: A generic whateverref dereffer!

[14:36] <Juerd> BUT

[14:36] <Juerd> How it's not possible for it to be generic.

[14:36] <Juerd> That's unfortunate, really.

[14:36] * theorbtwo isn't so sure of that.  It'd... yeah, that's not possible.

[14:36] <Juerd> So let's have syntax. Then the asymmetry isn't so blatantly obvious.

[14:37] <theorbtwo> Which is unfornunate, because it means that we have to find a name where people don't expect it to be one.

[14:37] <PerlJam> So is there going to be some syntax for the infinite deref?

[14:37] <Juerd> http://perlcabal.org/~autrijus/perl6-as-of-20050623.txt ++  # I like much of it.

[14:37] <Juerd> PerlJam: Yes, it can be postfix $ :)

[14:38] <theorbtwo> There already is syntax, just not postfix syntax (for finate deref.)

[14:38] <Khisanth> return is just another way to throw an exception? :)

[14:38] <Juerd> And infinite is a problem :)

[14:38] <Juerd> That takes too long.

[14:38] <theorbtwo> Yep, Khis.  A very unexceptional exception.

[14:38] <PerlJam> theorbtwo: perhaps I should have said "is there some simple punctuation?"  :-)

[14:39] <Juerd> So... what is the current state of <->?

[14:39] <theorbtwo> Juerd: I don't think anybody thinks it's useful enough.

[14:39] <PerlJam> Juerd: it still only exists in your imagination :)

[14:40] <Juerd> Grumble.

[14:40] <Khisanth> the lightsaber operator? :)

[14:40] <theorbtwo> So make one

[14:40] <Juerd> Khisanth: No, that's ====================@##@####

[14:40] <Juerd> hmm

[14:40] <Juerd> Khisanth: No, that's 4====================@##@####

[14:40] <Juerd> there.

[14:41] <Juerd> theorbtwo: I want <-> to be the default for $_-blocks.

[14:41] <Juerd> theorbtwo: rather than "-> $_ is rw"

[14:41] <Juerd> Because that adds some weirdness to the defaulting thing

[14:41] <Khisanth> ah a sith lightsaber at that!

[14:41] <Juerd> Anywhere $_ is a default, adding $_ shouldn't break things.

[14:41] <theorbtwo> We're trying to decide what to change it to right now.

[14:41] <Juerd> "$_ is rw" as a default makes very little sense.

[14:42] <Juerd> <-> solves this in a subtle way

[14:42] <theorbtwo> -> ?$_ default $OUTER::_ seems to be the conclusion.

[14:42] <Juerd> And makes possible my for %hash <-> $key, $value { ... }, which is still much easier to type than for %hash -> $key is rw, $value is rw { ... }

[14:43] <Juerd> theorbtwo: Holy bovine.

[14:43] <theorbtwo> OK, the conversation is getting aways from me.

[14:43] <Juerd> There goes simplicity :(

[14:44] <PerlJam> Juerd: I was going to say that <-> only seems really useful when you have multiple parameters that you want rw, but then theorbtwo's comment shocked me into silence.

[14:44] <Juerd> PerlJam: It's even more useful there, and that's when it becomes tedious to write "is rw" instead

[14:44] <PerlJam> Can we do   for @foo -> ($a,$b,$c) is rw { ... }   ?

[14:45] <Juerd> PerlJam: I'm more concerned with the default of "-> $_ is rw", because I'm rather convinced the default should be "-> $_" or "<-> $_", not something involving an external property like "is rw"

[14:45] <Juerd> PerlJam: Not currently.

[14:45] <Juerd> PerlJam: I find for @foo <-> $a, $b, $c { ... } a hell of a lot easier on the eyes and fingers still.

[14:45] <Khisanth> PerlJam: but wouldn't that mean the list and not the individual elements are rw?

[14:45] <Juerd> The thing is that <-> is conceptually NOT "yet another way"

[14:46] <PerlJam> for some reason <-> always makes me think of the "in", "out" and "inout" parameters in XS

[14:46] <Juerd> It's like q() and q[].

[14:46] <Limbic_Region> perlbot nopaste

[14:46] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[14:46] <Juerd> PerlJam: I don't know what those are, but <-> does really mean things are bidirectional, and -> means they're unidirectional.

[14:47] <Khisanth> -> readonly, <- write only, <-> read write? :)

[14:47] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Could someone please run this code - and if it works, nopaste the results for me?" (76 lines, 2.7K) at http://sial.org/pbot/11293

[14:47] <Juerd> Yes, except that write only has no practical use and can thus be skipped.

[14:47] <Juerd> Especially because <- is qw(-, which is too dangerous a thing.

[14:47] <Limbic_Region> the binary build Jonathan puts out is broke today (after I already wiped out my working copy of Pugs) - so I have no way of testing

[14:47] <Limbic_Region> but if someone wouldn't mind trying it for me I would be very appreciative

[14:47] <PerlJam> Khisanth: or ...  for @a -> $a,$b { ... }   ===   for $a,$b <- @a { ... }    :-)

[14:47] <Juerd> <-> is acceptable because it makes one thing different, instead of an infinite number of things.

[14:48] <Juerd> PerlJam: But that screams for $value <= $key too, which isn't going to work.

[14:49] <PerlJam> Beware the hobgoblins of foolish symmetry  ;)

[14:49] <Juerd> Limbic_Region: 

[14:49] <Juerd>     unexpected "{"

[14:49] <Juerd>     expecting operator, ",", ":", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or "}"

[14:49] <Juerd>     at - line 33, column 17

[14:50] <chip> "the boy who cried 'foolish consistency'"

[14:51] <Limbic_Region> thanks Juerd - will investigate

[14:51] <PerlJam> Limbic_Region: what's the top level when acting upon?

[14:52] <PerlJam> Limbic_Region: i.e., I see no given $result_1 { ... }

[14:53] <Limbic_Region> PerlJam - I am still working on it - hard to debug without Pugs

[14:53] <Juerd>   30                 when  1 { return %ball{3} == %ball{10} ?? (5, 1) :: (3, -1); }

[14:53] <Juerd> Not that it has to do with the problem at hand, but doesn't that need () around the comparison?

[14:54] <PerlJam> Juerd: Why should it?

[14:54] <Juerd> Oh, no

[14:54] <Juerd> That was with = :)

[14:54] * Juerd always has a problem remembering ?:'s precedence

[14:54] <Juerd> BASIC's iif() isn't so stupid, really :)

[14:55] <theorbtwo> Juerd: you mean ??::... <g>

[14:55] <Juerd> No

[14:55] <Juerd> I used ?: to indicate that the problem is bigger than just Perl 6

[14:55] <theorbtwo> Oh.

[14:55] <Limbic_Region> btw - does adding in the given $result_1 { line make it work?

[14:56] <Juerd> Great, I got a warning by SMS that the sun would be dangerously powerful today, and I read it way after the most dangerous times!

[14:56] <Juerd> So much for avoiding skin cancer.

[14:56] <Limbic_Region> I want to verify that it does prior to merging -1 and 1 into a single default case

[14:56] <PerlJam> Limbic_Region: Can't you just use feather.perl6.nl to test this stuff?

[14:57] <Limbic_Region> no - I can't get access to anything outside other than http and https

[14:57] <PerlJam> Time to tunnel ssh over http  ;)

[14:58] <Limbic_Region> *shrug* - normally isn't a problem as I can download binary builds - but today's build is broke and I didn't bother to check that before wiping out a working one

[14:59] <PerlJam> Limbic_Region: perhaps you should build a form interface to feather such that you can paste code snippets, have feather execute them and show you the results.

[14:59] <PerlJam> (assuming Juerd is okay with that)

[15:00] <Juerd> If it's properly ulimited, sure

[15:01] <Limbic_Region> well - I have to run to a meeting now anyway

[15:06] <Khisanth> shouldn't line 9 in Limbic_Region's code result in a warning? or is that not implemented yet? :)

[15:07] <autrijus> only compiler can give a warning -- pugs's main evaluator is not yet a compiler :)

[15:09] <Khisanth> I just recall someone in #perl mentioning a -w for pugs yesterday

[15:29] <autrijus> theorbtwo++

[15:29] <svnbot6> r4919, autrijus++ | * make PIR backend respect @*INC.

[15:29] <svnbot6> r4920, theorbtwo++ | Change castV to fromVal for better monadic goodness.

[15:29] <svnbot6> r4920, theorbtwo++ | Oh, and it's ft, not FT, but m is already used, so it's still M.

[15:57] <geoffb> Dammit people, why must all the good conversations happen when I'm asleep?

[15:57] <geoffb> :-)

[15:57] <geoffb> Good morning, all

[16:01] *** nnunley__ is now known as nnunley

[16:06] <Limbic_Region> geooffb - mind helping me troubleshoot something (I think you will find it a fun project)

[16:07] <geoffb> sure, watcha got for me?

[16:08] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "If this runs without error - what are the results" (55 lines, 1.9K) at http://sial.org/pbot/11294

[16:08] <Limbic_Region> it is a puzzle - I am presenting a solution in p6, but the challenge will to be to derive a solution using code (not your head)

[16:08] <geoffb> (And I'll trade you -- I need people to test compiles of http://svn.openfoundry.org/sdlperl1/ , and let me know how it goes, since I only have compilers for Debian)

[16:09] <Limbic_Region> well - you will have to wait until I get home then

[16:10] <geoffb> running it . . . 

[16:10] <geoffb> Does it take a long time to run, normally?

[16:10] <geoffb> oh wait, it dies

[16:11] <Limbic_Region> dunno - never ran it

[16:11] <geoffb>     unexpected "{"

[16:11] <geoffb>     expecting operator, ",", ":", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or "}"

[16:11] <geoffb>     at ./lr-thingie line 13, column 21

[16:11] <geoffb> (that line is off by two, I added a #! and a blank line at the top)

[16:11] <Limbic_Region> ahh - likely need parens around the infix operators

[16:11] <Limbic_Region> or maybe not

[16:12] <Limbic_Region> can we do /msg so that I don't flood the main channel with "try this" 

[16:12] <integral> geoffb: the Makefile.PL does nothing on OS X,  not even complain.

[16:12] <geoffb> oh sure, why not?  :-)

[16:13] <geoffb> integral, yeah, the makefile mess is something I gave off tackling until today -- yesterday I noticed that someone had created a Makefile.netbsd, and then never put an entry in Makefile.PL for it, so I added that myself, but I haven't done anything else to fix the mess.

[16:14] <geoffb> It's definitely next up on the priority list . . . but if you'd like to contribute, I'd be VERY happy, since OS X is the one major thing SDL_Perl 1 didn't run on, I think.

[16:14] * integral doesn't even know if he's got SDL installed

[16:15] <theorbtwo> Oh, not pug's makefile.pl.

[16:16] <geoffb> theorbtwo, sorry for the confusion, no -- it just came up as a trade with L_R, and integral was his usual cool self.  :-)

[16:25] <PerlJam> pdcawley++ on transparent v. opaque references ... "I'll tell you what, let's swap places: you read the thread and write me a summary of it"

[16:26] <Limbic_Region> should my $number = .1 * -1; # fail to parse

[16:26] <Limbic_Region> my $number = 0.1 * -1; # parses fine btw

[16:26] * PerlJam is catching up on his summaries

[16:27] <wolverian> well, that'll disallow method names that are only digits, but oh well..

[16:27] <PerlJam> Limbic_Region: good question.  I'd think it should parse fine.

[16:27] <PerlJam> wolverian: we're already there aren't we?

[16:27] <wolverian> PerlJam: probably. 

[16:29] <geoffb> FWIW, it would annoy me to have to do 0.1 everywhere -- because I have a lot of code with values between 0 and 1, in arrays -- so that would actually be significant clutter for me

[16:29] <Limbic_Region> well - it doesn't currently work in pugs so it is either a bug or needs a doc patch

[16:30] <autrijus> it's a parsebug. tests welcome

[16:31] <Limbic_Region> will wait until geoffb has finished helping me debug all the code so I can get them all at once

[16:31] <geoffb> :-)

[16:37] * autrijus is still fighting with the fallout of theorbtwo's patch...

[16:57] * Limbic_Region thinks he has found another odd parse bug where the presence or absense of prior statement will make it work/break

[16:58] <Limbic_Region> autrijus - I don't think http://sial.org/pbot/11300 is small enough for a test case

[16:59] <Limbic_Region> but if you remove the line - say "balancing group A and B"; # it stops working

[17:40] * geoffb got tired of wondering what Sudoku was, and finally read http://www.nationmaster.com/encyclopedia/Sudoku . . .

[17:40] <geoffb> pretty cool, that.

[17:43] <Khisanth> latest checkout doesn't compile ...

[17:44] <theorbtwo> Khisanth, autrijus is working on it.

[17:45] <Khisanth> oh that is what he meant :)

[17:46] <theorbtwo> Yup.

[17:46] <theorbtwo> All my fault.

[17:46] <theorbtwo> .oO(fmap!)

[17:52] <svnbot6> r4921, iblech++ | * Pugs.Eval  -- Removed unneeded import.

[17:52] <svnbot6> r4921, iblech++ | * Test       -- s/say/print/ -- now a failed test outputs "not ok n" again (was

[17:52] <svnbot6> r4921, iblech++ |   "not \nok n").

[17:52] <svnbot6> r4921, iblech++ | * examples.t -- unTODOed a succeeding test.

[18:04] <Arathorn> they're quite fun

[18:12] * geoffb finally catches up with backlog

[18:13] * geoffb praises the death of infinite auto-deref

[18:13] * nothingmuch wakes up

[18:14] <geoffb> welcome to the land of the living, nothingmuch 

[18:30] <obra> hey luqui_. how's the hackathon?

[18:31] <luqui_> it's like a design meeting

[18:31] <luqui_> but without a damian :-)

[18:31] <obra> Heh.

[18:31] <luqui_> fun

[18:32] <obra> Last night, Allison sold me on the Artistic 2.0.  (Pointed out why most of my concerns weren't actually an issue)

[18:32] *** khisanth_ is now known as Khisanth

[18:32] <Limbic_Region> geoffb - see http://perlmonks.org/index.pl?node_id=469482

[18:33] * luqui_ knows nothing of legalness

[18:33] <Limbic_Region> actually, everyone is welcome to try the challenge - sorry about the broken p6 code but it seems I have uncovered several bugs in pugs

[18:33] <obra> luqui_: I'm a bit jealous ;)

[18:33] * luqui_ just barely skimmed over artistic 2.0

[18:33] <Limbic_Region> does anyone else have a Win32 binary build of Pugs I can download?

[18:34] <Limbic_Region> luqui - did you get a chance to see my follow up email?

[18:34] <luqui_> limbic_region, yeah, but I forgot what you asked

[18:34] <luqui_> and the net is sloooow here so I'd rather not look

[18:35] <Limbic_Region> ok - will regurgitate here if you don't mind

[18:35] <Limbic_Region> while $ref() -> @array { ... } # doesn't currently work in Pugs

[18:36] <Limbic_Region> you indicated that if $ref() returned a list, it would become an array, and then bound to the block parameter

[18:36] <luqui_> yeah, we made that decision pretty quickly

[18:36] <Limbic_Region> that's what I want to happen and I will return an empty list so that it knows when I am done

[18:36] <luqui_> and it's not implemented

[18:36] <Limbic_Region> using undef won't work - must be empty list

[18:36] <geoffb> sorry, l_r, was AFK.  reading back ...

[18:37] <luqui_> but for such a thing, you're probably better off using an iterator

[18:37] <Limbic_Region> it is an iterator

[18:37] <Limbic_Region> the $ref() returns a list until it is done at which point it returns an empty list

[18:37] <Limbic_Region> anyway - moving on

[18:37] <Limbic_Region> you said while condition -> ?$x {

[18:37] <luqui_> oh, but you're not using the perl iterator interface

[18:38] <Limbic_Region> right

[18:38] <PerlJam> oh yeah, that reminds me  ... Limbic_Region++ for the iterators article

[18:38] <Limbic_Region> p5 -> p6 with as little translation as possible

[18:38] <Limbic_Region> that last part while condition -> ?$x { confused me for a couple of reasons

[18:38] <Limbic_Region> #1 shouldn't that be ?@x and not ?$x

[18:38] <Limbic_Region> second - why use ? (assuming that means it is optional)

[18:38] <luqui_> I was just outlining our decision about while's topicalization nature

[18:39] <Limbic_Region> ok

[18:39] <luqui_> it had little to do with your question, but your question triggered the decision

[18:39] <Darren_Duncan> fyi, 4291 fails to compile ; problem is in src/Pugs/AST/Internals.hs:538:13

[18:39] <Limbic_Region> gotcha

[18:39] <Limbic_Region> so back to my question then

[18:39] <Limbic_Region> when the bound array is empty - the while loop finishes?

[18:39] <luqui_> Darren, we're aware of that :-(

[18:39] <Darren_Duncan> okay

[18:40] <luqui_> well...

[18:40] <luqui_> your undef thing doesn't quite work I think

[18:40] <luqui_> basically the loop is finished whenever the return evaluates false

[18:40] <Limbic_Region> it shouldn't be undef

[18:40] <Limbic_Region> undef is a single element resulting in an array of 1 element and hence true

[18:40] <luqui_> in scalar context

[18:40] <Limbic_Region> that's why I was explicit about returning an empty list

[18:41] <Limbic_Region> empty meaning 0 elements

[18:41] <luqui_> yeah, but the single element might not turn itself into an array ref in scalar context

[18:41] <Limbic_Region> grrrr

[18:41] <Limbic_Region> if in my iterator I have a line like

[18:41] * luqui_ is asking

[18:41] <Limbic_Region> return () if $finished;

[18:42] <Limbic_Region> I would expect that to know I want a list of 0 elements

[18:43] <nothingmuch_> "...that works?..."

[18:43] <nothingmuch_> =D

[18:43] <Limbic_Region> which is different IMO from return undef if $finished or return if $finished;

[18:43] <PerlJam> Limbic_Region: return [] if $finished; doesn't do it for you?

[18:43] <PerlJam> (what with the transparent reference semantics and all)

[18:44] <Limbic_Region> PerlJam - I would think that would be non-intutive

[18:44] * geoffb is increasingly hating transparent (de/en)referencing

[18:44] <Limbic_Region> you are returning an explicit list everywhere else but when you mean empty list you change to array ref

[18:44] <Limbic_Region> that's less dwimery

[18:45] <PerlJam> "explicit list"?

[18:45] <Limbic_Region> return (1, 2, 3);

[18:45] <PerlJam> parens aren't list constructors.

[18:45] <Limbic_Region> right

[18:45] <geoffb> Plus, I can easily see people following the rule elsewhere and saying "that's a list containing one element, an empty arrayref"

[18:45] <luqui_> Limbic_Region, we think this will do the trick

[18:45] <luqui_> return (,) if $finished

[18:45] <PerlJam> Limbic_Region: yeah, I see your point though.

[18:45] <luqui_> (not sure that , needs to be there)

[18:45] <luqui_> anyway

[18:45] * Limbic_Region hugs luqui_ and the rest of the hackathoners

[18:46] <luqui_> if you want to return a single element list that turns into an arrayref in scalar context, it's like this:

[18:46] <luqui_> return (1,)

[18:46] <luqui_> so return (0,) will evaluate true according to while

[18:46] <PerlJam> why am I suddenly reminded of python?

[18:46] <luqui_> larry was too ;-)

[18:46] <PerlJam> (because that's one of the pythonisms that bugs me the most! that's why)

[18:47] <luqui_> well, we've got to get through this issue somehow

[18:47] <Limbic_Region> the return (); would be best but return (,) is acceptable

[18:47] <PerlJam> right.

[18:47] <luqui_> return () might work

[18:47] <luqui_> but return (1) does not

[18:47] <PerlJam> I don't have any good answers

[18:47] <geoffb> Fair enough . . . my requirement is basically that I have a single simple rule that will allow me to disambiguate () and {}, because otherwise I can't even imagine the bughunts trying to figure out what I really should be getting

[18:47] <Limbic_Region> ok - so now about all the other bugs I found with my latest challenge

[18:47] <PerlJam> return () is syntactically clear if you ask me.

[18:48] <Limbic_Region> does anyone have a Win32 binary build of pugs available for download?

[18:48] <PerlJam> luqui_: surely [1] works as (1,) ?

[18:48] * Limbic_Region would like to write tests for the things identified so far before he forgets them

[18:48] <geoffb> Personally, while I really love most of Perl 6 so far . . . methinks Perl 5 did Just Fine (tm) with the semantics of return

[18:48] <luqui_> perljam, [1] is a listref even in list context

[18:48] <luqui_> we want a flat list

[18:49] <luqui_> basically, we want an X such that:

[18:49] <luqui_> $x = X   # listref

[18:49] <luqui_> @x = X    # no listref

[18:49] *** luqui_ is now known as luqui

[18:50] * Limbic_Region believes luqui's time is better spent with the other people in the hackathon then answering his silly questions

[18:50] <PerlJam> luqui: are you saying that if X were [1] that @x[0] would be [1] rather than 1 ?

[18:50] <luqui> right

[18:50] <Limbic_Region> now that I have a warm fuzzy that something sane will be done - I will stop whining

[18:51] <luqui> :-)

[18:51] * luqui &

[18:51] <PerlJam> I wonder what a hackathon sounds like.

[18:51] <Limbic_Region> no one has a Win32 binary build available huh?

[18:51] <geoffb> loud, I would think

[18:52] <luqui> oh, jonathan was making those for a while

[18:52] <PerlJam> geoffb: it's either loud or silent but always with keyboards clicking away  :)

[18:52] <luqui> I don't know much about it though

[18:52] * luqui fg

[18:52] * luqui &

[18:52] <Limbic_Region> jonathan's build is broke ATM and hence the problem

[18:56] <autrijus> Limbic_Region: I can build one for you but it'd take a very long while to upload it from the cell phone connection here

[18:57] <Limbic_Region> heh

[18:57] * Limbic_Region hugs autrijus too for being willing to go the extra mile

[18:57] <Limbic_Region> I have written down the bugs well enough to hopefully be able to write tests later tonight

[18:59] <luqui> hey autrijus, I can get parrot talking to pug

[18:59] <luqui> pugs

[18:59] <luqui> but I'm not sure how to get pugs's output into parrot

[18:59] <PerlJam> what does a parrot say to a pug?

[18:59] <luqui> eval?

[19:01] <autrijus> luqui: I'm converging to minimize our location delta

[19:05] <Darren_Duncan> eval? 1+1

[19:05] <Darren_Duncan> ?eval 1+1

[19:08] <Limbic_Region> the evalbot's not on the channel ATM Darren_Duncan

[19:08] <svnbot6> r4922, autrijus++ | * clean up theorbtwo's vCast patch.  I expect most tests

[19:08] <svnbot6> r4922, autrijus++ |   to still break... :)

[19:08] <Limbic_Region> but I guess you figured that out already

[19:09] <PerlJam> Is it too transitioning to the hackathon?

[19:14] <Darren_Duncan> yes, it hasn't been for several days now

[19:31] <Darren_Duncan> r4922 compiles successfully for me

[21:01] <arcady> pugs' ~~ doesn't do some of the things that it's supposed to

[21:01] <arcady> 42 ~~ 40..45 returns false, where S04 says it should be true

[21:02] <arcady> since matching a number against a range tells if the number is in the range

[21:03] <theorbtwo> arcady: Find a test, or write one?

[21:04] <arcady> aha, there are in fact tests

[21:06] <arcady> I think what I really need to do is learn Haskell and fix all these things

[21:06] <arcady> if only I had the time for that...

[21:18] <autrijus> using a pair variable to bind into named params finally works

[21:19] <Limbic_Region> autrijus++

[21:19] <svnbot6> r4923, autrijus++ | * After extensive discussion with lwall, the named binding semantics

[21:19] <svnbot6> r4923, autrijus++ |   is now implemented as an inferencing phase before binding:

[21:19] <svnbot6> r4923, autrijus++ |     sub foo ($x) { ... }

[21:19] <svnbot6> r4923, autrijus++ |     sub bar { (x => 3) }

[21:19] <svnbot6> r4923, autrijus++ |     sub baz returns Pair () { (x => 3) }

[21:19] <svnbot6> r4923, autrijus++ |     foo(bar());         # This assigns (x=>3) to $x

[21:19] <svnbot6> r4923, autrijus++ |     foo(baz());         # This assigns 3 to $x

[21:19] <svnbot6> r4923, autrijus++ |     foo(*baz());        # This assigns (x=>3) to $x

[21:19] <svnbot6> r4923, autrijus++ |     foo($y);            # This assigns 3 to $x, too

[21:19] <Limbic_Region> how is the timezone difference treating you autrijus?

[21:20] <autrijus> i'm doing fine :)

[21:20] <Limbic_Region> i'm currently building Pugs (at home) to write tests for the bugs geoffb helped me find earlier

[21:21] <Limbic_Region> how relavent is the patch theorbtwo applied 

[21:21] <Limbic_Region> WRT bugs not really being bugs?

[21:23] <autrijus> theoretically theorbtwo's patch only makes all castfails trappable.

[21:23] <autrijus> practically though... it breaks almost everything. I'm still sorting thru it

[21:24] <geoffb> autrijus, let us know when the coast is clear to do another pull/build and be able to assume life will be good

[21:24] <geoffb> er, please

[21:24] <pmichaud> how goes the hackathon?

[21:24] <Limbic_Region> well - I know these bugs were b0rk prior to the patch so I will post em anyway

[21:29] <theorbtwo> .oO(I tried to warn him...)

[21:32] <Limbic_Region> ughh - /me checks revision history to see what rev # was theorbtwo's patch

[21:32] <autrijus> sure

[21:32] <autrijus> pmichaud: very well! got lots of corner cases specced and/or clarified

[21:32] <pmichaud> excellent.  I'm looking forward to arriving tomorrow.  Anything the group wants me to work on between now and then?

[21:33] <Limbic_Region> how do I (using svk) go back to an older revision?

[21:33] <Limbic_Region> 4919 for instance

[21:34] <autrijus> pmichaud: invokecc for PGE closures? :)

[21:34] <pmichaud> oh yeah, I can probably have that done at some point in the hackathon, np

[21:35] <pmichaud> I'm curious to know more about parrot namespaces and how we expect perl 6 objects (esp. subroutines) to appear in those namespaces

[21:36] <pmichaud> also, anything we have on the ast representation

[21:38] <autrijus> I can braindump to you tomorrow :)

[21:38] <autrijus> as you can already compile Test.pm and other stuff to PIR

[21:39] <autrijus> eg. Test::ok is just &ok in the Test namespace

[21:39] * Limbic_Region kicks svk for not listening to him

[21:39] <autrijus> also luqui is looking on getting compreg working even for external parrot (by shelling out to pugs)

[21:39] <autrijus> so in any case you should be able just to ask compreg to produce something for you that you can call.

[21:39] <autrijus> I'll take care of compiling the closure in the Rule into a Closure object pmc.

[21:40] <autrijus> (it's already done, actually)

[21:40] <pmichaud> np

[21:40] <autrijus> as for AST, the PIL nodes should be a decent start; we can work out how to map them into p6 space

[21:41] <autrijus> luqui and I sort of think to represent them adequately we'd need parameterised classes, aka generics

[21:41] <pmichaud> yeah, that's the piece I'm wondering about next

[21:41] <pmichaud> so being able to go through that over the weekend will be really helpful

[21:41] <autrijus> sure... I look forward to it. when do you arrive tomorrow?

[21:42] <pmichaud> I should make it to the hackathon around 3pm, depending on airline delays and traffic

[21:42] <Juerd> has anyone experienced downtime of feather, or was it my home connection?

[21:42] <pmichaud> my flight arrives toronto 1pm

[22:00] * Limbic_Region finds it very hard to believe that you can't checkout a specific revision with svk

[22:00] <svnbot6> r4924, autrijus++ | * If the parameter is expecting a Pair... don't namify it.

[22:03] <autrijus> yow.

[22:03] <autrijus> 7532 test cases: 6916 ok, 616 failed, 942 todo, 432 skipped and 4 unexpectedly succeeded

[22:03] <autrijus> Limbic_Region: huh? svk up -r

[22:03] <autrijus> svk co -r

[22:05] <geoffb> That test summary looks close to normalcy -- only a few percent still failing

[22:05] <svnbot6> r4925, autrijus++ | * test cleanups; add makefile.pl so smoke tests run

[22:09] <Limbic_Region> autrijus - it doesn't work

[22:09] <Limbic_Region> Invalid filesystem revision number: No such revision 4919

[22:10] <mugwump> svn switch -r

[22:10] <mugwump> (another way for svn)

[22:10] <Limbic_Region> they all say the same damn thing

[22:10] <Limbic_Region> Invalid filesystem revision number: No such revision 4919

[22:12] <mugwump> are you connecting from the right space/time zone?

[22:12] <autrijus> weird... ^W^Wsvk takes local rev numbers

[22:12] <autrijus> not remote ones

[22:12] <autrijus> so you can't do -r 4919 when 4919 is the pugs svn rev

[22:13] <Limbic_Region> I even tried wiping out the entire pugs distribution, svk, and starting out fresh with an initial checkout of 4919 - it just looked at me funny and kept doing the same crappy things

[22:13] <autrijus> you need to translate it to your local number using svk log or something

[22:14] * Limbic_Region tries something

[22:16] <Limbic_Region> this is just plain stupid

[22:17] *** knewt__ is now known as knewt_

[22:20] <geoffb> It should be easy to specify a revision relative to the repo being mirrored -- if not, there's a good complaint for clkao

[22:24] <Limbic_Region> I am firmly under the belief that I am just too stupid to run a computer

[22:24] <Limbic_Region> I have tried it relative to local revisions

[22:24] <Limbic_Region> I have tried starting out fresh checking out a specific versions

[22:24] <Limbic_Region> I have tried everything I can think of

[22:24] <Limbic_Region> it refuses to do anything other than give me the latest

[22:30] * geoffb blinks

[22:30] <geoffb> Limbic_Region, did you nuke the offending depot in between all these efforts?

[22:30] <geoffb> (here I'm assuming pugs is the only thing you're mirroring in that depot . . . )

[22:31] <Limbic_Region> geoffb - yes, in fact I uninstalled everything and rmdir /s /q anything that remained

[22:33] <geoffb> wowsers

[22:33] <Limbic_Region> and so I tried to download svn 1.2.0 and it seems all those links are broken

[22:33] * Limbic_Region thinks the universe really doesn't want him to be playing with Pugs tonight

[22:34] * Limbic_Region opts for svn 1.1.4 and hopes for the best

[22:34] <Limbic_Region> you have got to be kidding me 

[22:35] <Limbic_Region> now I am getting a "Program too big to fit into memory" error

[22:35] <geoffb> OK, not to disparage your system or anything, but that's fubar.

[22:36] <geoffb> Hmmm . . . maybe SVK reacts badly to OOM issues?

[22:36] <Limbic_Region> that doesn't make any sense

[22:37] <Limbic_Region> it works fine unless I ask for something other than the most recent directory

[22:37] <Limbic_Region> s/directory/revision/

[22:37] <geoffb> and "Program too big to fit into memory" does?!?

[22:37] <Limbic_Region> no - that's svn not svk

[22:37] * Limbic_Region gives up for tonight

[22:37] <Limbic_Region> it isn't meant to be

[22:38] <Juerd> Too many things are not meant to be

[22:38] <geoffb> Limbic_Region appears to be playing "boss who blows up everything vaguely technical when he walks in the door" today

[22:38] <Juerd> Those things take us to be

[22:38] <Juerd> Perl 6 is one of those things

[22:38] <Juerd> Getting living beings in and out of space was too

[22:39] <mugwump> dang, I'm getting that field `_crypt_struct' has incomplete type error building Pugs.Embed.Perl5 now

[22:41] <Juerd> I find the parrot binary rather large. Is there a reason it has to be so big?

[22:41] <mugwump> stripped it?

[22:42] <Juerd> Oh, it's not stripped by make?

[22:42] <Juerd> That explains it :)

[22:42] <Juerd> Thanks, this helps much

[22:42] <mugwump> Mine's 2Meg after stripping

[22:42] <Juerd> That saves a lot of memory during runtime

[22:44] <Juerd> And a second execution time!

[22:44] <Juerd> Imagine what that does to testing.

[22:45] <mugwump> you don't embed? :)

[22:45] <Juerd> Hm?

[23:04] <svnbot6> r4926, luqui++ | Added pugsSlurp.

[23:10] <autrijus> luqhttp://en.wikipedia.org/wiki/Afshar_experiment

[23:10] <svnbot6> r4927, autrijus++ | * unTODO succeeding tests.

[23:17] <Juerd> Is there a test for %hash = { ... } yet?

[23:17] <svnbot6> r4928, autrijus++ | * after consulting with lwall and luqui, in light of the new

[23:17] <svnbot6> r4928, autrijus++ |   semantic of bare blocks always taking a (?$_=$OUTER::_) as

[23:17] <svnbot6> r4928, autrijus++ |   parameter, the "Parametric" type is now obsolete.  Also gone

[23:17] <svnbot6> r4928, autrijus++ |   with it is the "Bare" type -- all blocks are just Block now.

[23:17] <Juerd> It works (at least worked earlier today), but shouldn't work. 

[23:17] <Juerd> Well, it should work, but using the hashref as the first key, not as the entire new hash.

[23:24] <autrijus> right. that was one of the deref issues following 0-level

[23:24] <autrijus> I'll fix... actually the entire deref semantics is now changed

[23:24] <autrijus> I'm also trying (not very successfully) to release a version today before really ripping everything out

[23:32] <Darren_Duncan> that is a good time to do it

[23:33] <Darren_Duncan> keeps a more permanent record of a lot of older work that would seem to get destroyed

[23:34] <revdiablo> heh, "older"

[23:34] <revdiablo> the ancient code that's 2 weeks old

[23:34] <geoffb> Um, isn't that what version control is for, Darren_Duncan?

[23:34] <Darren_Duncan> I said MORE permanent

[23:34] <geoffb> (well, one of the uses, anyway)

[23:34] <geoffb> heh

[23:34] <geoffb> fair 'nuf

[23:34] <Darren_Duncan> all the versions in cvs aren't on CPAN

[23:34] <Darren_Duncan> I mean svn

[23:34] <revdiablo> and not only record but recognition

[23:35] <Darren_Duncan> for those that only see CPAN, the releases contain all the visible work

[23:35] <geoffb> sigh

[23:35] <revdiablo> people are sensitive butterflies

[23:44] <coral> flap, flap

[23:44] <svnbot6> r4929, autrijus++ | * first cut of transliterating &pugs_eval into Emit.PIR

[23:49] <theorbtwo> Change going in for better error messages on castfails.  There's probably a better way to do it, but this way works...)

