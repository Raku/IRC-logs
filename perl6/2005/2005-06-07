[11:37] * nothingmuch just read `char buffer[10000]=""` as a derclaration that the adjective 'buff' is applied to something of type char 10000 more, relative to ""

[11:37] <nothingmuch> functional programming is making me stupider

[11:37] <nothingmuch> but I *feel* like i'm actually smarter

[11:43] * kungfuftr looks forward to marty pauleys monads talk at yapc::eu

[11:43] <xerox> kungf00f, what a nickname :)

[11:44] <kungfuftr> xerox... what an unoriginal name

[11:44] <kungfuftr> =0)

[11:45] <xerox> :(

[11:55] <lathos> Slowly filling up with old data: http://buscador.simon-cozens.org/

[12:05] <QtPlatypus> When is invoke() called on a Class?

[12:27] <Limbic_Region> salutations all

[12:28] <autrijus> hey Limbic_Region.

[12:28] * autrijus is waiting at boarding area

[12:29] <nothingmuch> autrijus: did you get my private messages?

[12:31] <Limbic_Region> have a "happy trip" 

[12:31] <Limbic_Region> that appears to be a filipino saying

[12:33] <autrijus> nothingmuch: yeah

[12:34] <autrijus> Limbic_Region: thanks. I'm feeling quite trippy already

[12:34] <nothingmuch> i forgot what I wrote

[12:34] <autrijus> nothingmuch: something about brain temperature.

[12:34] <nothingmuch> but does my deduction of what runReader initInterp interpret []

[12:34] <nothingmuch> make any sense?

[12:35] <autrijus> nothingmuch: sure.

[12:35] <autrijus> but it has nothing to do with laziness.

[12:35] <autrijus> the monadic functions are "boxed" on top of one another

[12:35] <autrijus> so they are just functions, not evaluated values

[12:35] <autrijus> runReaderT evaluates the topmost computation

[12:36] <autrijus> which runs the inner computation to yield the value it requires

[12:36] <autrijus> et cetera, like russian dolls

[12:36] <autrijus> so it doesn't matter if it's lazy or strict

[12:36] <nothingmuch> so it's an inversion of the tree

[12:36] <nothingmuch> the AST

[12:36] <nothingmuch> and the reason that the computer doesn't explode is that it's lazy?

[12:36] <autrijus> you can say that, yes

[12:36] <autrijus> no, you can do the same in perl.

[12:36] <autrijus> or any other strict language

[12:37] <autrijus> because monadic functions are only _composed_

[12:37] <nothingmuch> so why doesn't the computer explode

[12:37] <autrijus> because it's just packing function pointers around

[12:37] <autrijus> there's no data involved

[12:37] <autrijus> at all

[12:37] <autrijus> so it's cheap

[12:38] <svnbot6> r4443, autrijus++ | * hw2005.txt - very random notes jotted down during the taxi drive to airport

[12:39] <scook0> nothingmuch: looks like harrorth is coming along nicely

[12:40] <nothingmuch> scook0: except that autrijus has melted my brain, and now i'm trying to recover

[12:40] <scook0> ah well

[12:41] <scook0> I must get around to writing some Haskell one of these days...

[12:41] <autrijus> nothingmuch: that is the result of your desire to actually understand how ReaderT works :)

[12:41] <autrijus> not that it's a bad thing... but most people just learns how to use it and stop at that

[12:42] <scook0> deeper understanding is always nice

[12:42] <autrijus> I didn't fully grok it either, yet I used it for ~3 months for openafp :)

[12:43] <autrijus> and I didn't trully grok it until I defined a new monad (SIO) and a new monad transformer (EvalT)

[12:43] <scook0> oh, the irc logger seems to be back up :)

[12:44] <nothingmuch> autrijus: i think that my problem with haskell is that I didn't understand the details completely

[12:44] <nothingmuch> so I didn't know how to use them properly

[12:44] <autrijus> brb...

[12:44] <nothingmuch> i am considering delaying the introduction of your patch into harrorth's tutorial chronology though

[12:44] <autrijus> nothingmuch: sure.

[12:50] <Limbic_Region> learning Haskell to me is akin to learning an alien (as in space) language

[12:50] <Limbic_Region> people typically learn stuff by building a bridge by relating stuff they already know to new stuff in steps until the gap has been bridged

[12:50] <Limbic_Region> too foreign to me for that

[12:57] <nothingmuch> going home early... woo!

[12:57] <svnbot6> r4444, Aankhen++ | * small changes to HTTP::Message.

[12:57] <nothingmuch> lets see if I grok Reader by the end of the day

[12:58] *** theorbtw1 is now known as theorbtwo

[13:04] <kungfuftr> seen castaway?

[13:04] <jabbot> kungfuftr: castaway was seen 2 days 21 hours 55 minutes 53 seconds ago

[13:05] <theorbtwo> kungfuftr: Castaway is on vacation.

[13:06] <theorbtwo> She's in the south of france with her family :) -- SOs not invited :(.

[13:07] <kungfuftr> theorbtwo: any idea for how long?

[13:08] <theorbtwo> Until the 9th.  Then the next day she flies to the US with me.

[13:09] <theorbtwo> We're going to have a funky schedule for a while... which sadly means that we can't start coordinating the move for a bit.

[13:09] <svnbot6> r4445, autrijus++ | * Incorporate Damian's review notes to the main text.

[13:09] <theorbtwo> .oO(That was the info you were going for, right?)

[13:11] *** batdog|gone is now known as batdog

[13:12] <kungfuftr> theorbtwo: *blink* what?

[13:19] <theorbtwo> kungfuftr: She got offered the job.

[13:19] <kungfuftr> oh right...

[13:19] * kungfuftr has been away on holiday

[13:19] <kungfuftr> congrats to her!

[13:20] <autrijus> ok, boarding time.

[13:20] <autrijus> wish me a safe flight etc :)

[13:20] * autrijus waves &

[13:20] <kungfuftr> autrijus: have fun!

[13:20] <clkao> autrijus: ciao!

[13:20] <theorbtwo> autrijus: Safe flight!  Have fun!

[13:21] <xerox> autrijus, have fun fun fun!

[13:21] <theorbtwo> May you make mad fat hacks together with Leo!

[13:22] <larsen> autrijus: have a good time :)

[13:25] <kungfuftr> theorbtwo: you be moving as well then?

[13:26] <theorbtwo> Yes!

[13:27] <kungfuftr> theorbtwo: beer must ensue!

[13:27] <theorbtwo> Indeed!

[13:27] <theorbtwo> Me wanting to move was actually a major motivation for Jess seeking a job.

[13:28] <theorbtwo> Now we need to figure out what to pack, and what to get rid of, and how to make the move, and how to get me a visa, and where we're moving too, and about a million other things.

[13:28] <kungfuftr> theorbtwo: british/american ?

[13:28] <theorbtwo> She's british, I'm american, yeah.

[13:28] <kungfuftr> stop stealing our jobs!

[13:28] <kungfuftr> and women!

[13:28] <kungfuftr> =0)

[13:29] <kungfuftr> theorbtwo: if you need lists of where to get flats, etc. lemme know

[13:30] <theorbtwo> I probably will.

[13:30] <theorbtwo> It seems a bit early for that, though, since we won't be moving until September.

[13:30] <kungfuftr> September!?

[13:31] <theorbtwo> There's lots of notice to give, and getting me a visa before that would be difficult, and there's this vacation.

[13:32] <kungfuftr> theorbtwo: have you any irish heritage?

[13:32] <theorbtwo> A very little, possibly... why?

[13:33] <kungfuftr> as long as great-grandparents were irish citizens, you can become an irish citizen, which allows you to become an EU citizen and therefore work in the UK

[13:33] <kungfuftr> =0)

[13:33] <iblech> autrijus: [evalbot's quotemeta bug] I fixed it a week ago or so, but it seems that the machine running evalbot still has the old evalhelper.p5

[13:33] <kungfuftr> which reminds me, need to renew my irish passport

[13:35] <theorbtwo> Hm, I wonder if I can proove that.

[13:35] <kungfuftr> *shrug* will look up the details

[13:35] <kungfuftr> theorbtwo: http://www.irelandemb.org/fbr.html

[13:35] <theorbtwo> I was planning to get an unmarried partner UK visa -- I can proove I've been with Jess two years in September.

[13:38] <theorbtwo> Ah, needs to be a grandparent, not great-grandparent, so no can do.

[13:39] <kungfuftr> theorbtwo: it's great-grandparents (actually), but there's a few restrictions

[13:40] <kungfuftr> such as the grandparent would have had to have their birth recorded with the Eire authorities

[13:40] <kungfuftr> thought it could be overseas

[13:59] <iblech> Hm... Net::IRC is broken.

[13:59] <svnbot6> r4446, iblech++ | mklivecd.pl -- Added hint about stripping pugs and parrot.

[14:35] <arcady> apparently "map @list -> { stuff }" is supposed to be written as "map @list, -> { stuff }"

[14:35] <arcady> somehow, I think the comma shouldn't be required there

[14:36] <iblech> @list -> { stuff } is (correctly) parsed as sub (@list) { stuff }

[14:37] <iblech> So there has to be something to disambiguate

[14:37] <arcady> um... that's not correct

[14:37] <arcady> I mean @list -> $i { stuff }

[14:37] <arcady> the args of the pointy sub appear between the -> and the {

[14:38] <iblech> D'oh! Of course

[14:38] <arcady> and in "for", it needs no comma

[14:38] <arcady> this is confusing, I think

[14:39] <crysflame> pugs livecd?

[14:39] <iblech> Jep. That's because for is on statement-level (there's no corresponding &foo, only a &statement:<foo>), while map is a regular function.

[14:40] <iblech> crysflame: Yep. Pretty minimal ATM, though. Included is Pugs, its modules, Parrot, and sh, nothing else.

[14:40] <crysflame> cool

[14:40] <crysflame> torrent?

[14:40] <arcady> I should install pugs and parrot on my zaurus...

[14:40] <iblech> HTTP, it's only 5 MiB or so :)

[14:40] <crysflame> heh

[14:40] <iblech> But wait a sec, I'll upload a recent version

[14:40] <arcady> and what is the prototype of &map ?

[14:41] <arcady> because for can be made a function with the same prototype

[14:41] <iblech> crysflame: http://linide.sf.net/pugs-livecd-latest.iso (version from yesterday)

[14:42] <iblech> arcady: Yep. The difference is that map has a return value (e.g. my @foo = map ... works), while for hasn't (my @foo = for ... is illegal, even)

[14:42] <crysflame> sucking sound commences

[14:42] <arcady> yeah

[14:42] <iblech> arcady: And because for is statement-level, it can have extra syntactic support from the grammar

[14:42] <iblech> arcady: Like dropping the ","

[14:43] <crysflame> would be neat to overload for to have a return value of the @foo that was passed into it

[14:43] <crysflame> modified or not

[14:43] <arcady> in ruby it does have a return value

[14:43] <arcady> in fact, everything there does, or almost everything

[14:44] <arcady> but it wouldn't be too hard to change the grammar to not require the "," on map, would it?

[14:44] <crysflame> what would break if such was done?

[14:45] <iblech> Yep. You even wouldn't have to modify the grammar, you could use a macro with an appropriate "is parsed" trait, I think

[14:45] <arcady> no, really, what is the prototype of map?

[14:45] <arcady> iblech, that is modifying the grammar...

[14:46] <iblech> According to S29: multi sub Perl6::List::map (Code $expression : *@values) returns Lazy

[14:46] <iblech> arcady: Yep, but much more simple -- i.e. you don't create a new grammar which inherits from the original grammar and then overload some rules

[14:47] <arcady> I suppose

[14:47] <arcady> and the map prototype is not right

[14:47] <arcady> oh wait

[14:48] <wolverian> wow that's a bizarre signature

[14:49] <arcady> okay, I think that's not working very correctly

[14:49] <theorbtwo> So you can use a , or a : between the list and the sub... but you've got to have something?

[14:49] <wolverian> &code.map(@foo); # er.

[14:49] <theorbtwo> Or that, wolverian.

[14:50] <arcady> yeah, I'm talking about the "map(*@list, &code)" one

[14:50] <wolverian> theorbtwo: if that's the signature, you _have_ to have the : 

[14:50] <wolverian> theorbtwo: , doesn't work

[14:51] <wolverian> (I think. I'm not sure about the MMD fallback mechanisms)

[14:51] <wolverian> arcady: map @list: &code; you mean?

[14:52] <wolverian> map ({1}): ({1}); # I wonder which one this dispatches to...

[14:52] <wolverian> (Assuming the special case of (one_element) creating a List)

[14:53] <arcady> okay, but I can say "map 1,2,3, -> $x { $x+2 }" 

[14:53] <wolverian> hmm. that doesn't dispatch to anything, then.

[14:53] <arcady> ?eval map 1,2,3, -> $x { $x+2 }

[14:53] <evalbot6> pugs: cannot cast from VList [VInt 2,VInt 3,VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubPointy, subEnv = Just (MkEnv {envContext = CxtSlurpy (mkType "Any"), envLValue = False, envLexical = MkPad {"$?1":=[(<ref>,<ref>)],"%_":=[(<ref>,<ref>)]}, envGlobal = <ref>, envPackage = "main", envClasses = Node {rootLabel = (mkType "Any"), subForest = [Node {rootLabel = (mkType "Void"), subForest = [Node {rootLabel = (mkType "Object"), subForest

[14:53] <wolverian> ?eval map 1,2,3 : -> $x { $x+2 }

[14:53] <evalbot6> Error:  unexpected "a" or "m" expecting program Only one invocant allowed 

[14:54] <Limbic_Region> ?eval map 1,2,3 -> $x { $x   2 }

[14:54] <evalbot6> Error:  unexpected ">" or "-" expecting operator, ",", ":", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:54] <Limbic_Region> heh - my plus symbol is broke

[14:54] <arcady> ?eval map (1,2,3), -> $a { say $a }

[14:54] <evalbot6> Error: No compatible subroutine found: "&say" 

[14:54] <wolverian> that's pretty nonfunctioning

[14:54] <Limbic_Region> ?eval map 1,2,3 -> $x { $x - 2 }

[14:54] <evalbot6> Error:  unexpected ">" or "-" expecting operator, ",", ":", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:54] <wolverian> who broke pugs? :)

[14:54] <Limbic_Region> dunno

[14:54] <arcady> you need the comma!

[14:54] <wolverian> ?eval (1,2,3).map(-> $x { $x - 2 })

[14:54] <evalbot6> (-1, 0, 1) 

[14:55] <Limbic_Region> ?eval (1,2,3).map:{ $x - 1 }

[14:55] <evalbot6> Error: Undeclared variable: "$x" 

[14:55] <wolverian> ?eval (1,2,3).map:{ $^x - 1 }

[14:55] <evalbot6> Error:  unexpected ":" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:55] <Limbic_Region> ?eval (1,2,3).map:{ $_ - 1 }

[14:55] <evalbot6> (0, 1, 2) 

[14:55] <wolverian> hmm right. really broken

[14:55] <iblech> wolverian: ?eval "^" doesn't work in the old evalbot

[14:55] <Limbic_Region> wolverian - you need to use $_ in that last one

[14:55] <theorbtwo> ?eval map (1,2,3), {$^x-1}

[14:55] <wolverian> iblech: old evalbot?

[14:55] <evalbot6> Error:  unexpected "{" expecting "::", ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:55] <Limbic_Region> I think

[14:55] <theorbtwo> ?eval map (1,2,3): {$^x-1}

[14:55] <evalbot6> Error:  unexpected "{" expecting "::", ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:56] <theorbtwo> ?eval map (1,2,3): -> {$^x-1}

[14:56] <evalbot6> Error:  unexpected ">" or "-" expecting "::", ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:56] * Limbic_Region goes back to $wrok

[14:56] <svnbot6> r4447, iblech++ | Net::IRC -- Quick fix to make it work again.

[14:56] <theorbtwo> Hm.

[14:56] <wolverian> Limbic_Region: not in perl6. evalbot/pugs might differ

[14:56] <iblech> wolverian: Yeah. The machine running evalbot has an outdated evalhelper.p5, causing ^ to be (incorrectly) escaped.

[14:56] <Limbic_Region> right - I missed the ^

[14:56] <wolverian> iblech: ah. can it be upgraded? :)

[14:56] <wolverian> Limbic_Region: oh, okay.

[14:57] <iblech> wolverian: Of course, I fixed this bug a week ago or so :) But I don't have access to the machine it's running on. In fact, I even don't know on what machine it runs

[14:58] <wolverian> iblech: okay.

[14:58] * nothingmuch makes a large stupid smile

[14:58] <nothingmuch> after about 10 sessions of 10 minutes, and one session of about an hour of thought, I think I figured out the reader monad

[14:58] <wolverian> hmm. is there any need for a POE-style framework in perl6?

[14:59] <nothingmuch> wolverian: yes, but It won't be like POE, i think

[14:59] <nothingmuch> it will define far less than POE

[14:59] <wolverian> right.

[14:59] <wolverian> that's what I'm thinking too.

[15:01] <wolverian> yield for =<>; # :)

[15:01] <iblech> I'd like POE6 to make more use of continuations and coroutines, so I can write code like "my $input = post($wheel, "read")" -- post() should be some kind of magic sub which returns to POE's event loop and resumes execution of my sub when the event finished

[15:02] <iblech> Right now, you have to define many callback events

[15:02] <nothingmuch> =)

[15:02] <wolverian> iblech: you mean $wheel.post("read"), right?

[15:02] <wolverian> :)

[15:03] <wolverian> anyway, that's pretty trivial really, if we have callcc

[15:03] <iblech> Yeah. Or POE::Kernel.post($wheel, "read"), or whatever it'd be called :) BTW, assuming $wheel.post("read") will work, then post($wheel, "read") will work, too, thanks to MMD

[15:04] <wolverian> I thought you'd need ($wheel : "read")

[15:05] <nothingmuch> how does POE actually yield, btw?

[15:05] <nothingmuch> is it recursive?

[15:05] <wolverian> POE doesn't yield.

[15:05] <nothingmuch> doesn't it have a yield() function?

[15:05] <wolverian> right, but that's not coroutines, if you meant that

[15:05] <nothingmuch> if so, ignore my comments, i was under the assumption that it emulates cooperative multithreading in p5

[15:06] <iblech> I'm not 100% sure, but IIRC $obj.method($arg), method $obj: $arg, and method($obj, $arg) all do the same thing (the first two directly dispatch to $obj, the last one uses MMD to find the correct codevar)

[15:06] <wolverian> iblech: ah, okay.

[15:07] <wolverian> nothingmuch: $kernel->yield($event, @args); is just a regular call. so yes, recursive.

[15:08] <wolverian> (yield() is just a shorthand for post($current_session, ...)

[15:08] <wolverian> s,$,),

[15:08] <nothingmuch> so yield goes to the dispatcher, and it decides which component to give time to?

[15:08] <nothingmuch> how does it return to the yield? does it have to let all the thins that were started in the mean while finish?

[15:08] <wolverian> yes.

[15:08] <wolverian> Events posted with yield() must propagate through POE's FIFO before they're dispatched. This effectively yields timeslices to other sessions which have events enqueued before it.

[15:08] <wolverian> (perldoc POE::Kernel)

[15:09] <iblech> nothingmuch: yield() returns (almost) immediately, the event queue is only processed when the current even handler returns

[15:09] * wolverian watches iblech and perldoc fight

[15:09] <iblech> :D

[15:09] <nothingmuch> i need to read it's source

[15:09] <wolverian> "its"

[15:10] <wolverian> iblech: so it yields to other sessions?

[15:10] <nothingmuch> okay okay

[15:10] <wolverian> if there are no other sessions, the current event handler is at the top of the queue, naturally

[15:10] <nothingmuch> iblech: so how is time sliced between sessions?

[15:11] <iblech> wolverian: Yep, but the event "call this event in that session" is not called until it's first in POE's FIFO

[15:12] <wolverian> iblech: right, but the $event that you yield() isn't put to the top of the FIFO

[15:12] <svnbot6> r4448, iblech++ | Added a new pugsbugs test testing for the bug which caused Net::IRC to stop

[15:12] <svnbot6> r4448, iblech++ | working (t/pugsbugs/parsing_lexical_code_vars.t).

[15:12] <wolverian> iblech: to me that seems like the FIFO must be processed first

[15:12] <wolverian> but I'm not a POE expert by any means :)

[15:13] <iblech> nothingmuch: POE::Kernel has a runloop which calls event handlers. During the execution of an event handler, POE's runloop does (of course) not run. You can queue in a new event by calling POE::Kernel->post or POE::Kernel->yield. These put the info "call event foo in session bar" on POE's FIFO

[15:13] <iblech> wolverian: Yep, you're right.

[15:14] <nothingmuch> ooh!

[15:14] <nothingmuch> i get it

[15:14] <nothingmuch> so when the current session finishes it's call, then all the things it yielded get run fifo order

[15:14] <iblech> wolverian: yield() and post() only push to the FIFO, they never unshift it

[15:14] <nothingmuch> much simpler than I thought

[15:14] <iblech> nothingmuch: Yep, exactly

[15:14] * nothingmuch hasn't followed the reduce metaoperator on empty list thread

[15:15] <nothingmuch> is it going to be as flexible as foldr?

[15:15] <wolverian> it's more flexible.

[15:15] <nothingmuch> is the identity value only going to be used if there's only 1 element?

[15:15] <wolverian> or rather - it has different semantics.

[15:15] <wolverian> nothingmuch: no. it's used whenever you provide the :initvalue adverb.

[15:15] <wolverian> (or :identvalue.)

[15:16] <nothingmuch> when you don't provide it?

[15:16] <iblech> I like Juerd's explanation on [...] best -- [...] is simply a join($operator, $args) on the syntax level. So "[+] 3" means "3" and "[+] 1,2,3" means "1 + 2 + 3"

[15:16] <wolverian> then there is no identity value 

[15:16] <wolverian> and a reduce on a zero length list fails

[15:17] <nothingmuch> okay

[15:17] <wolverian> iblech: at least if the operator is defined as a listop

[15:17] <wolverian> well. it's like that in any case.

[15:17] <iblech> Yep.

[15:17] <nothingmuch> makes sense =)

[15:17] <theorbtwo> wolverian: You mean if it's /not/ defined as a listop.

[15:17] <theorbtwo> If it is defined as a listop, it'd possible be called with a zero-length list.

[15:17] <wolverian> (it's just that whether it's a fold or a real reduce depends if the op is a listop or a binary op)

[15:18] <wolverian> theorbtwo: yes, but that's not the semantics Larry wants.

[15:18] <theorbtwo> OK.

[15:18] <wolverian> (according to the post he just sent to p6l.)

[15:18] * theorbtwo bows to the wisdom of the Larry.

[15:20] <wolverian> it makes sense to me. and you can always do &precircumfix:<[ ]>.=assuming(:initvalue);

[15:20] * Limbic_Region just finished reading it

[15:20] * wolverian loves .=

[15:21] <osfameron> what does .= do ?

[15:21] <iblech> inplace method call

[15:21] <iblech> @foo .= bar() is equivalent to @foo = @foo.bar

[15:21] <wolverian> foo .= bar; is the same as foo = foo.bar;

[15:21] <wolverian> just like +=, -= etc

[15:21] <iblech> (but foo is evaluated only once)

[15:22] <osfameron> eeek, doing that on a method is quite scary

[15:22] <osfameron> does it work?

[15:22] <iblech> And quite useful: @array .= sort:{...}; @array .= map:{...} etc

[15:23] <wolverian> one has to remember that @array .= map:{ s/foo/bar/ }; is redundant, though

[15:23] <nothingmuch> how do you apply precircumfix ... to an op?

[15:23] <wolverian> unless map:{ } really does copy by default

[15:23] <iblech> @array .= uniq; $string .= lc; $num .= abs

[15:23] <nothingmuch> &precircumfix:<[ ]>.=assuming(:initvalue).(&infix:<+>, @list)?

[15:23] <wolverian> which is horrible efficiency-wise

[15:24] <wolverian> nothingmuch: the .= modifies the &precircumfix.<[ ]>, so all calls after that to it will use :initvalue

[15:24] <nothingmuch> oh, i didn't notice!

[15:24] <wolverian> &precircumfix:<[ ]>.=assuming(:initvalue); say [*]; # doesn't fail 

[15:24] <iblech> IIRC, in Pugs, it's readwrite

[15:24] <nothingmuch> you are crazy

[15:24] <osfameron> so you can assign to a sub, you don't need to bind?

[15:24] <wolverian> hmm, good point. I have no idea. :)

[15:25] <wolverian> $foo = @bar; $foo = @baz; # doesn't modify @bar

[15:25] <osfameron> otherwise .:= ?

[15:25] <wolverian> I don't know.

[15:25] <iblech> I think so. But binding is ok, too

[15:25] <osfameron> the wheeled cannon operator

[15:25] <wolverian> someone could run that by p6l :)

[15:25] <wolverian> since for normal values, assigning to the ref doesn't modify the original value

[15:26] <wolverian> does it do so for subs?

[15:26] <iblech> IIRC, &foo in "my &foo" is no longer a real reference, so it'll work

[15:26] <wolverian> is it specced?

[15:27] <iblech> (But the $foo in "$foo = &foo" is)

[15:27] <iblech> Not sure

[15:28] <iblech> But I'm pretty sure of that, and it matches the behaviour of @ and %: my @a = (...); @a = (...); # changes @a, my %a = (...); %a = (...); # changes %a, my &a = {...}; &a = {...}; # should change &a

[15:28] <wolverian> good point.

[15:28] <wolverian> so &a isn't a ref at all, but a container

[15:29] <iblech> Yep, I think so.

[15:29] <wolverian> that's a bit odd. then arrays can hold subs and refs. :)

[15:29] <osfameron> ooo, lovely javascripty goodness

[15:30] <wolverian> (which doesn't make sense since &foo isn't a vector container)

[15:30] <wolverian> (s,vector,plural,)

[15:30] <iblech> But, binding, especially compile-time binding is useful, too: my &infix:<plus> ::= &infix:<+> (creates the "plus" operator at compile-time) But: my &infix:<plus> = &infix:<+> will only work in eval()s

[15:31] <iblech> I think the types will still be enforced, so @foo can only hold things which are Arrays

[15:31] <iblech> Similarily for % (Hash) and & (Code)

[15:31] <wolverian> no, I didn't mean that

[15:32] <wolverian> I meant that you can store a Sub directly into @foo then

[15:32] <wolverian> which would make it equivalent with a Scalar

[15:32] <wolverian> @foo.push({ ... }); # doesn't push a ref

[15:34] <iblech> Meant that too (I think). And I think that won't work, as a Code is not an Array. So a @-container always has to point (point in the internal sense, not meant as a reference) to an Array (but of course an Array can hold Any)

[15:34] <wolverian> my @foo; @foo.push({...}); # now @foo holds a Code

[15:35] <wolverian> oh, can Arrays hold Any now and not just Refs?

[15:35] <wolverian> (or Scalars)

[15:38] <iblech> Yeah. @foo then contains one elem, a Code reference. But @foo still isa Array.

[15:38] <wolverian> yes.

[15:38] <wolverian> I didn't mean that you could change that!

[15:39] <iblech> No, I should have better said Scalar of Any or somesuch

[15:39] <wolverian> I just meant that it feels odd to me - as a perl5 coder - that there would be another scalar type besides ref (and scalar) that an array can hold

[15:39] <iblech> ah :)

[15:39] * iblech understands

[15:39] <wolverian> :)

[15:39] <iblech> The {...} which is pushed to @foo is a Code *reference*

[15:40] <iblech> But the &foo in "my &foo = ..." is not, this &foo is an actual value

[15:40] <wolverian> hmm. okay.

[15:40] <wolverian> that's subtly weird in its own way, too, since &foo isn't a plural container

[15:40] <wolverian> like %foo is

[15:40] <wolverian> (or @foo)

[15:41] <iblech> Yeah, but $foo is a scalar container, too

[15:41] <wolverian> right, and I'm used to having only one scalar container :)

[15:41] <wolverian> (that is, scalar)

[15:41] <wolverian> (er, Scalar. or so.)

[15:41] <iblech> :)

[15:41] * nothingmuch thinks of writing a p5 obfu with an implementation of monads

[15:41] <nothingmuch> especially this scary reader monad

[15:42] <nothingmuch> i'll call it "Whither do notation"

[15:42] <iblech> :D

[15:42] <iblech> And you even wouldn't have to obfuscate it syntax-wise ;)

[15:43] <theorbtwo> nothingmuch: Source filter that converts ; to >>=, and an overload that makes >>= do something funky?

[15:43] <nothingmuch> iblech: did you try to understand how Reader works?

[15:43] <nothingmuch> i think I need a metaphor for it

[15:43] <nothingmuch> i think i finally understood how it works

[15:43] <nothingmuch> theorbtwo: no, the opposite.. I'll define >>=, (non circumfix, mind you)

[15:43] <nothingmuch> sorry, non infix

[15:43] <theorbtwo> Non-infix?

[15:43] <nothingmuch> and local, and ask

[15:43] <theorbtwo> Can perl 5 do that?

[15:43] <nothingmuch> yes

[15:43] <nothingmuch> bind(sub { }, sub { });

[15:44] <nothingmuch> err, sorry

[15:44] <nothingmuch> bind($result, sub { })

[15:44] <theorbtwo> Oh.

[15:44] <theorbtwo> I meant actually naming it >>=.

[15:44] <theorbtwo> (Bitshift right and assign.)

[15:44] <wolverian> theorbtwo: >>= is a numeric bitshift assignment already, so you can just override it.

[15:44] <iblech> nothingmuch: [understanding of Reader] Thanks to your conversations with autrijus, I think I got it mostly :)

[15:44] <nothingmuch> oh no, that's too much info

[15:45] <theorbtwo> wolverian: Yes, but that's infix; he specified non-infix.

[15:45] <nothingmuch> iblech: what I see it doing is the first call to >>= creates a function

[15:45] <wolverian> oh. that won't work. :)

[15:45] <iblech> And BTW, nothingmuch, you might want to look into examples/functional/monads.p6

[15:45] <nothingmuch> it contains the first doExp

[15:45] <nothingmuch> on the left hand, if you will, and the rest on the right side

[15:45] <nothingmuch> this is returned

[15:45] <nothingmuch> then runReader (this thing) initInterp takes the new interp

[15:46] <nothingmuch> and hands it to the function it got out of (this thing)

[15:46] <nothingmuch> and that function takes the interp, and passes it to the lambda that was generated on the right side of >>=

[15:46] <iblech> Makes sense

[15:46] <nothingmuch> that is, the doExp, and then this thing's result is unwrapped, and fed into the right side

[15:46] <nothingmuch> that is, the next thing in the do notation

[15:47] <nothingmuch> so it's just chained

[15:47] <nothingmuch> but the interesting part is how the chain starts

[15:47] <nothingmuch> basically

[15:47] <nothingmuch> op :: Reader x

[15:47] <nothingmuch> op

[15:47] <nothingmuch> generates a lambda

[15:48] <nothingmuch> runreader (op) value

[15:48] <nothingmuch> is a bit like saying

[15:48] <nothingmuch> op value

[15:48] <nothingmuch> if it were not in the reader monad

[15:48] <nothingmuch> autrijus: when you backlog, please verify

[15:52] <nothingmuch> iblech: monads.p6 is cool, but i grokked the IO monad a long time ago

[15:52] <nothingmuch> like, yesterday, or the day before

[15:52] <iblech> :)

[15:52] <nothingmuch> see chapter 4 of harrorth =)

[15:59] <iblech> 217.12.145.3: http://m19s28.vlinux.de/iblech/pugs/livecd.iso is very outdated. The most recent version is at http://linide.sf.net/pugs-livecd-latest.iso

[16:01] * theorbtwo wonders if people have played with %CALLER::, and found problems with it, yet.

[16:06] <ninereasons> m

[16:07] <ninereasons> ^H^H^H^H

[16:07] <ninereasons> ^H

[16:07] <ninereasons> ^H^H^H^H^H^H^H

[16:07] <ninereasons> ^H^H^H^H^H

[16:07] <ninereasons> ^H^H^H^H^H^H^H^H^H^H^H^H

[16:07] <ninereasons> ^H

[16:07] <ninereasons> it

[16:08] <nothingmuch> terrorist

[16:10] <ninereasons> that was odd.  sorry about the gibberish.

[16:35] <SamB> yes, quite odd. A lot of U+007Fs...

[16:43] <svnbot6> r4449, ninereasons++ | motd.p6, motd-i.p6: these pointy subs now seem to require parens

[16:45] <Limbic_Region> there is a Code type?

[16:45] <Limbic_Region> where should I have read that?

[16:47] <iblech> L<S06/"Types">

[16:47] <iblech> In S06 there's a nice graph of the Code hierarchy, too

[16:48] <Limbic_Region> well - with signature type checking raising complaints - it probably would have made some of my code a lot easier

[16:48] <Limbic_Region> IOW - if I have an optional parameter that is supposed to be a code reference

[16:48] <Limbic_Region> I don't need to see if it is defined AND if it .does(CODE)

[16:49] <Limbic_Region> btw - does Pugs do any type checking yet?  I remember it didn't a while ago

[16:49] <Limbic_Region> err - WRT sub signatures that is

[16:50] <iblech> ?eval sub a(Code $x) { 42 } a(42);   # Still doesn't, I think

[16:50] <evalbot6> 42 

[16:51] <iblech> Yep, not yet implemented

[16:51] <gaal> nothingmuch: http://sleepingsquirrel.org/monads/monads.html # "Monads in Perl"

[16:52] <wolverian> I'd use &x :) 

[16:53] <Limbic_Region> oooh - all kinds of want.method tests I think I should add

[16:53] <wolverian> please do!

[16:54] <wolverian> Limbic_Region++

[16:54] <Limbic_Region> going to have to wait until tonight though - just read http://perlmonks.org/index.pl?node_id=464022

[16:54] <Limbic_Region> want.count is unimplemented

[16:55] <Limbic_Region> as apparently is want.Void

[16:58] <Limbic_Region> currently providing incorrect behavior

[16:58] <Limbic_Region> at least as I understand it

[16:59] <Limbic_Region> perlbot nopaste

[16:59] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[16:59] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "want should be a number not a junction" (8 lines, 106B) at http://sial.org/pbot/10819

[17:00] <gaal> L~R, if you've got tuits, tests for caller are welcome too ;-)

[17:00] <gaal> i however must prepare a lecture for $work tomorrow...

[17:00] <gaal> oh! also, tests for %SIG

[17:01] <gaal> %*SIG even.

[17:01] <Limbic_Region> heh - one thing at a time

[17:01] <gaal> :)

[17:01] <Limbic_Region> these won't happen until tonight anyway

[17:01] <gaal> yeah, i shouldn't really be #perl6ing, myself :)

[17:02] <iblech> Limbic_Region: http://sial.org/pbot/10819 does not output junctions here

[17:04] <Limbic_Region> really

[17:04] * Limbic_Region wonders how old his Pugs is

[17:04] <Limbic_Region> 6.2.6 - so that's a good sign

[17:05] <wolverian> neither on feather.

[17:05] <Limbic_Region> perhaps I should see if Jonathan has updated the binary build

[17:05] <wolverian> returning List (Any) instead.

[17:05] <iblech> Yep, here it outputs List (Any), too

[17:06] * Limbic_Region uncrosses his eyes and sees that List (Any) is not any(LIST)

[17:06] <Limbic_Region> ok - well it is still wrong output

[17:07] <wolverian> where is want specced?

[17:07] <wolverian> S06?

[17:07] <Limbic_Region> yes

[17:07] <Limbic_Region> although A06 goes in a bit more details

[17:08] <wolverian> hmm.

[17:08] <wolverian> my $foo = { want }(); gives some pugs internal things.

[17:08] <wolverian> I think.

[17:08] <wolverian> (mkType?)

[17:11] <Limbic_Region> wolverian - I am reading the part of A06 that says "The want value can simply be used as a number:"

[17:11] <Limbic_Region> if want >= 2 { return ($x, $y) }         # context wants >= 2 values

[17:11] <Limbic_Region> or explicitly, want.count

[17:12] <wolverian> right. but only in numeric context.

[17:13] <theorbtwo> Sadly, we don't have overridable stringification or nummification of general objects.

[17:13] <Limbic_Region> yeah - but it isn't in Pugs ATM 

[17:13] <wolverian> well that's why it didn't work :)

[17:13] * wolverian wondered for a second

[17:13] <Limbic_Region> or so I was lead to believe by that thread I referred to

[17:13] <theorbtwo> Well, you can do it by giving it it's own class.

[17:14] <wolverian> given want { yield when Desperate }

[17:14] * wolverian hums

[17:14] <theorbtwo> But you can't implement it as a method, because doing it that way creates circular dependencies.

[17:15] <Limbic_Region> theorbtwo - I am not at all concerned about implementation

[17:15] <svnbot6> r4450, iblech++ | Added an experimental POE module (ext/POE).

[17:15] <Limbic_Region> I read the spec, notice it missing or deficient, write the test(s) - and let someone else worry about implemenation

[17:15] <wolverian> hmm. what kind of?

[17:15] <integral> ooh, a POE for perl6 interesting.

[17:16] <Limbic_Region> of course, if I ever make it past chap 4 of YAHT, I might start implementing stuff too

[17:16] <integral> iblech: have you talked to the perl5 POE folks about a perl6 version?

[17:19] <mrborisguy> ?eval my @a=(0,1); if 1 == any( @a ) { say "yes" } else { say "no" }

[17:19] <evalbot6> Error: No compatible subroutine found: "&say" 

[17:20] <mrborisguy> woah, didn't expect that...

[17:20] <mrborisguy> ?eval my @aoa=([0,1],[0,1]); if 1 == any( @aoa[0] ) { say "yes" } else { say "no" }

[17:20] <evalbot6> Error: No compatible subroutine found: "&say" 

[17:20] <integral> it's run in safe mode by the bot, so there's no &*SAY

[17:20] <integral> err, &*say

[17:21] <wolverian> use the return value.

[17:21] <mrborisguy> okay, so that's not working.  anyway, i have a question.  the first line gives me "yes", but the second line gives me "no"

[17:21] <wolverian> (just remove the 'say')

[17:21] <Limbic_Region> missing semicolons

[17:22] <mrborisguy> ?eval my @aoa=([0,1],[0,1]); my @b = @aoa[0]; if 1 == any( @b ) { "yes" } else { "no" }

[17:22] <evalbot6> 'yes' 

[17:22] <mrborisguy> why can't i use any( @aoa[0] ) ?

[17:22] <wolverian> ?eval 1 == any ([0,1],[0,1])[0]

[17:22] <evalbot6> (bool::false) 

[17:22] <Limbic_Region> ?eval my @a=(0,1); if 1 == any( @a ) { say "yes"; } else { say "no"; }

[17:22] <evalbot6> Error: No compatible subroutine found: "&say" 

[17:23] <Limbic_Region> hmmm

[17:23] <mrborisguy> ?eval my @a=(0,1); if 1 == any( @a ) { "yes" } else { "no" }

[17:23] <evalbot6> 'yes' 

[17:23] <Limbic_Region> say is unsafe

[17:23] <wolverian> yes, we already realised that :)

[17:23] <wolverian> ?eval ([0,1],[0,1])[0]

[17:23] <evalbot6> \(0, 1) 

[17:23] <wolverian> right, it's a ref.

[17:23] <Limbic_Region> sorry - was thinking that it was a missing ; issue

[17:23] <Limbic_Region> which I have seen elsewhere

[17:23] <Limbic_Region> wasn't paying attention to your discovery

[17:23] <wolverian> Limbic_Region: ah, okay.

[17:23] <Limbic_Region> which makes a whole lot of sense

[17:24] <wolverian> hmm. so how do I deref the array inline?

[17:24] <mrborisguy> can i make it a list somehow?  i tried any( list @aoa[0] ), but that didn't seem to work either

[17:24] <wolverian> mrborisguy: that just makes a list of one element - the arrayref

[17:25] <mrborisguy> so i have to make a new list then?  my @b = @aoa[0]; any( @b )   ?

[17:25] <mrborisguy> it doesn't seem like i should have to do that

[17:25] <wolverian> oh. *

[17:25] <mrborisguy> is there a better way?

[17:25] <Limbic_Region> **

[17:25] <wolverian> ?eval *([0,1],[0,1])[0]

[17:25] <evalbot6> (0, 1) 

[17:25] <wolverian> * is enough here, thanks. :)

[17:25] * Limbic_Region was attempting to be funny

[17:26] <wolverian> ?eval 1 == any *([0,1],[0,1])[0]

[17:26] <evalbot6> (bool::false | bool::true) 

[17:26] <wolverian> there we go.

[17:26] <mrborisguy> sweet

[17:26] <mrborisguy> thanks!

[17:26] <wolverian> you're welcome!

[17:26] <mrborisguy> ?eval my @aoa=([0,1],[0,1]); if 1 == any( *@aoa[0] ) { "yes" } else { "no" }

[17:26] <evalbot6> 'yes' 

[17:27] <mrborisguy> good thing i asked, i almost thought it was a bug/unimplimented

[17:35] <Limbic_Region> ?eval my $foo = all(1..10); $foo.pick;

[17:35] <evalbot6> undef 

[17:35] <Limbic_Region> ?eval my $foo = any(1..10); $foo.pick;

[17:35] <evalbot6> 1 

[17:35] <Limbic_Region> does that strike anyone else as odd?

[17:35] <wolverian> I'm not sure.

[17:35] <wolverian> ?eval (1..10).pick

[17:35] <evalbot6> 6 

[17:35] <wolverian> just do that? :)

[17:36] <iblech> integral: re. No, it's just a very, very simple experiment. I'd be happy if someone with knowledge of POE internals does a real POE port :)

[17:36] <mrborisguy> you would think you should be able to pick from an any or an all though...

[17:36] <wolverian> how about none?

[17:36] <wolverian> none(1..10).pick

[17:36] <wolverian> er

[17:36] <wolverian> ?eval none(1..10).pick

[17:36] <evalbot6> undef 

[17:36] <wolverian> that does make sense to me

[17:36] <wolverian> and rankly, so does the all() behaviour

[17:37] * iblech nods

[17:37] <mrborisguy> wouldn't that be the same as (1|2|3|4).pick ?

[17:37] <mrborisguy> (for the any case)

[17:37] <wolverian> yes.

[17:37] <mrborisguy> (and obviously out to 10 instead of 4)

[17:37] <wolverian> (and that works.)

[17:37] <mrborisguy> ?eval (1|2|3).pick

[17:37] <evalbot6> 1 

[17:37] <mrborisguy> ?eval (1|2|3).pick

[17:37] <evalbot6> 3 

[17:37] <wolverian> as you can see. :)

[17:37] <mrborisguy> i'd say write a test then

[17:37] <mrborisguy> ?eval (1&2&3).pick

[17:37] <evalbot6> undef 

[17:38] <wolverian> is .pick specced?

[17:38] <mrborisguy> what exactly does it mean for something to be 'specced'

[17:38] <mrborisguy> if it's in any(<A E S>)?

[17:39] <wolverian> yes.

[17:39] <wolverian> any<A E S> works too, by the way :)

[17:39] <mrborisguy> i think i read it in there, then... that really points you in a good direction, huh?

[17:39] <wolverian> heh.

[17:39] <mrborisguy> really?  i'll have to remember that

[17:40] <mrborisguy> it's just a learning day for me then!

[17:40] <svnbot6> r4451, ninereasons++ | motd: change tabs to spaces for consistency. remove artifacts of earlier experiments, and improve the perl-6ishness somewhat

[17:44] <ninereasons> hmm.  POE has landed.

[17:44] <wolverian> hmm?

[17:46] <ninereasons> class MySession is POE::Session { ... }

[17:47] <integral> it would be interesting to implement POE::Session as a perl metaclass

[17:48] <ninereasons> another iblech++ useful port

[17:49] <wolverian> hmm. that is nice.

[17:49] <wolverian> doesn't use continuations though :(

[17:49] <iblech> Note though that's only a small experiment, not a full port yet

[17:49] <ninereasons> noted :-)

[17:50] <iblech> wolverian: Yep. I tried a bit in interactive Pugs, but there &?CALLER_CONTINUATION didn't seem to work, or at least not in the way I thought it should work

[17:50] <integral> there's some bugs with that :-)

[17:50] <wolverian> iblech: right. :)

[18:12] <Aankhen``> iblech++ # POE

[18:12] <svnbot6> r4452, Aankhen++ | * HTTP::Message -- realised that hashes can be specified in signatures.

[18:12] <svnbot6> r4452, Aankhen++ | * HTTP::Message -- added C<returns Foo> wherever applicable.

[18:14] <Juerd> iblech: Unfortunately, it's made much more complex :(

[18:14] <Juerd> iblech: And I really don't agree that reduce with an empty list should ever be able to fail.

[18:18] <Aankhen``> Is there any equivalent to localtime() that I can use for now?

[18:23] <Juerd> Aankhen``: `date`? :)

[18:24] <webmind> oi

[18:24] <mrborisguy> eval_perl5( localtime() ) ? # without really knowing what you're looking for

[18:25] <PerlJam> Aankhen``: you could just implement localtime()  :-)

[18:30] *** khisanth_ is now known as Khisanth

[18:30] <iblech> Aankhen``: Yeah, implement it :) Adding the op is not very hard (I could guide you, I think), but I don't know about Haskell's calendar routines

[18:33] <Aankhen``> The only problem is that I dunno any Haskell...

[18:35] <Aankhen``> Oh, and Juerd: *** No compatible subroutine found: "&date"

[18:36] <iblech> I didn't, either, before I started hacking Pugs :) Anyway, localtime() is unspecced ATM and IIRC the plan is that localtime() and gmtime() should be substituted by a clever result object from time().

[18:36] <Aankhen``> Ah.

[18:37] <iblech> (So one can do time().hour or somesuch)

[18:37] <Aankhen``> I wouldn't mind that... I just need something that'll help port Time::Local and thereby HTTP::Date, which will perhaps let HTTP::Headers work. :-)

[18:42] <theorbtwo> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Time.html#v%3AtoCalendarTime

[18:49] <mrborisguy> ?eval my @a = (1); sub modify( @in is copy ) { @in[ 0 ] = 7; } modify( @a ); @a;

[18:49] <evalbot6> [1] 

[18:49] <mrborisguy> say my @aoa = ([1]); sub modify( @in is copy ) { @in[0][0] = 7; } modify( @aoa ); @aoa;

[18:49] <mrborisguy> ?eval my @aoa = ([1]); sub modify( @in is copy ) { @in[0][0] = 7; } modify( @aoa ); @aoa;

[18:49] <evalbot6> [[7]] 

[18:50] <mrborisguy> is that what should happen?

[18:50] <mrborisguy> i thought my @in was a copy, so i shouldn't be able to modify it, right?  even though it's a somewhat deep modification?

[18:52] <iblech_> There was some discussion about that on p6l, but I don't recall the decision...

[18:52] <mrborisguy> oh, i'll look for it then

[18:54] <mrborisguy> you have a general idea of how long ago it was?

[18:54] <iblech_> Some months, I think. Try to search for Perl6::Subs and Chip

[18:54] *** iblech_ is now known as iblech

[18:55] <iblech> (Chip implemented the Perl 6 sub definition syntax in Perl 5, releasing it as Perl6::Subs on CPAN. Then he asked how deep "is copy" and "is rw" are)

[18:56] <knewt> ok, that's more like it. the only non-localhost port i've got open on my laptop now is ssh. will feel better out at the apw now

[18:56] <mrborisguy> can i search on nntp somehow?  groups.google.com is blocked at my work

[18:57] <obra> nntp.x.perl.org?

[18:57] <mrborisguy> (www.nntp.perl.org)

[18:57] <knewt> gmane is pretty good for most stuff

[19:10] <mrborisguy> well, time to go play poker again

[19:20] *** kcwu_ is now known as kcwu

[19:27] <svnbot6> r4453, iblech++ | * New pugsbugs test: t/pugsbugs/return_in_anonymous_subs.t

[19:27] <svnbot6> r4453, iblech++ | * Added note about POE in ChangeLog

[19:33] <wilx> So...what version of hs-plugins do I neet for Pugs?

[19:37] <theorbtwo> wilx: A daily.

[19:41] <wilx> Ok.

[19:53] <wilx> Hmm, how healthy is gmake check of hs-plugins?

[19:53] <wilx> What tests are expected to fail?

[19:54] <theorbtwo> No idea.

[20:14] <fnord123> Hey all. What is the golf part of pugs for. 

[20:15] <theorbtwo> fnord123: Fun.

[20:16] <fnord123> fun as in "what should we make G stand for?" or fun as in there is actually some golf game here that i dont see

[20:17] <Limbic_Region> fnord123 - the face of pugs has changed dramatically in the little over 4 months it has been around

[20:17] <theorbtwo> Oh, in the name?

[20:17] <Limbic_Region> right

[20:17] <Limbic_Region> it was a play on words

[20:17] <Limbic_Region> hugs

[20:18] <theorbtwo> (The haskell users' golfing system)

[20:18] <fnord123> oh ok

[20:18] <Limbic_Region> fnord123 - there are several golf examples though btw

[20:18] <Limbic_Region> http://svn.openfoundry.org/pugs/examples/golf/

[20:18] <fnord123> because hugs was written in scotland, i presume

[20:20] <fnord123> is perl golf some kind of 'one liner' game?

[20:20] <Limbic_Region> fnord123 - golf is a game of skill and fun

[20:20] <Limbic_Region> a problem is presented (usually with some rules and restrictions)

[20:21] <Limbic_Region> and the contest is to solve the problem in the fewest strokes as possible

[20:21] <Limbic_Region> where strokes refers to keystrokes not swings

[20:21] <geoffb> hola

[20:21] <Limbic_Region> salutations

[20:21] <geoffb> Not that I'm telling anybody here anything new, but budgets can take a LOT of time to create

[20:21] <Limbic_Region> there are many many many examples of golf around in various different languages

[20:23] <theorbtwo> examples/golf and t/golf contain perl6 golf.

[20:23] <geoffb> Golf is a game that I can do decently at, but never win, because I just can't bring myself to strangle the interpreter quite that much.

[20:23] <geoffb> :-)

[20:23] * Limbic_Region isn't a very good golfer nor is he very good an obfusication

[20:24] <theorbtwo> Nor am I, Limbic.

[20:24] <geoffb> Every part of me that's into maintainable code just screams "DEAR GOD NO!!!" from every corner of my cranium.

[20:24] <theorbtwo> Exactly, geoffb.

[20:24] * theorbtwo needs something to hack on now.

[20:24] <geoffb> That said, some of the winning golf entries I've seen have been beautiful in their brilliance.

[20:24] <ninereasons> theorbtwo, actually hugs has something to do with gofer, not golfing

[20:24] <mj41> ?eval { 'a' !~ rx:perl5{a} }

[20:25] <evalbot6> bool::true 

[20:25] <Limbic_Region> the most obfu thing I ever wrote was purely accidental

[20:25] <Limbic_Region> http://perlmonks.org/index.pl?node_id=384885

[20:26] <mj41> ?eval { 'a' ~~ rx:perl5{a} }

[20:26] <evalbot6> MkMatch {matchOk = True, matchFrom = 0, matchTo = 1, matchStr = "a", matchSubPos = [], matchSubNamed = {}} 

[20:26] <geoffb> Trying to deeply understand the code in BASIC Computer Games and More BASIC Computer Games when I was a kid pretty much ended any desire I ever had to be obfuscated.

[20:27] * Limbic_Region notes the time and heads homewards

[20:27] <geoffb> I still don't have any idea how some of that code worked

[21:06] *** khisanth_ is now known as Khisanth

[21:24] <mj41> ?eval { sub a { say '1'; } sub a { say '2'; } a(); eval qq| sub a { say'3'; }|; a(); }

[21:24] <evalbot6> Error: No compatible subroutine found: "&say" 

[21:26] <geoffb> mj41, it will automatically print whatever your code returns, but say is not allowed

[21:27] <mj41> ?eval { my $s = ''; sub a { $s ~= '1'; } sub a { $s ~= '2'; } a(); eval qq| sub a { $s ~= '3'; }|; a();  $s; }

[21:27] <evalbot6> \'232' 

[21:31] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say '1'; } sub a { say '2'; } a(); eval qq| sub a { say'3'; }|; a(); $_ebs; }

[21:31] <evalbot6> \'2 3 2 ' 

[21:36] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say 1; } sub a { say 2; } a(); eval 'sub a { say 3;'; a(); $_ebs; }

[21:36] <evalbot6> \'2 2 ' 

[21:37] <mj41> ?eval { sub a { 4; }; a(); }

[21:37] <evalbot6> 4 

[21:50] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say '1'; } sub a { say '2'; } a(); eval qq| sub *a { say '3'; }|; a(); $_ebs; }

[21:50] <evalbot6> \'2 3 2 ' 

[21:50] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say 1; } sub a { say 2; } a(); eval 'sub *a { say 3;'; a(); $_ebs; }

[21:50] <evalbot6> \'2 2 ' 

[21:51] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say 1; } sub a { say 2; } a(); eval 'sub *a { say 3;}'; a(); $_ebs; }

[21:51] <evalbot6> \'2 3 ' 

[21:52] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } sub a { say 1; } sub a { say 2; } a(); eval 'sub a { say 3; }'; a(); $_ebs; }

[21:52] <evalbot6> \'2 2 ' 

[21:52] <PerlJam> Does the evalbot respond to msg?

[21:59] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } eval 'sub *a { say 3; }'; a(); $_ebs; }

[21:59] <evalbot6> \'3 ' 

[22:00] <mj41> ?eval { my $_ebs = ''; sub say ( $str ) { $_ebs ~= "$str\n"; } sub print ( $str ) { $_ebs ~= $str; } eval 'sub *a { say 3; }; a();' $_ebs; }

[22:00] <evalbot6> Error:  unexpected "$" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[22:00] <vcv--> ?eval 1 x 'a'

[22:00] <evalbot6> '' 

[22:01] <vcv--> ?eval 'a' x 5

[22:01] <evalbot6> 'aaaaa' 

[22:12] * geoffb sinks into newly purchased Aeron -- not bad . . . 

[22:40] <nothingmuch> darcs pull harrorth

[22:40] <nothingmuch> therein is explained the wonders of the Reader monad

[22:40] <nothingmuch> in the chaotic chapter 6

[22:41] <nothingmuch> which will be cleaned up tomorrow

[22:41] <nothingmuch> autrijus: http://feather.perl6.nl/~nothingmuch/harrorth/doc/06.kwid

[22:43] * nothingmuch would really appreciate people who are trying haskell, but not really "getting" it to read through the harrorth tutorial, and see if it helps

[22:50] <geoffb> nothingmuch, you should consider adding harrorth to READTHEM

[22:51] <nothingmuch> geoffb: patches welcome. I need to go sleep ;-)

[22:51] <nothingmuch> actually, this isn't so much of an effort, i can do it

[22:52] <geoffb> heh

[22:55] <nothingmuch> there

[22:56] <nothingmuch> everyone feel free to rephrase the premise, i'm not good at that sort of stuff

[22:56] <nothingmuch> geoffb++; # thanks for the suggestion

[22:57] <nothingmuch> ciao!

[22:57] <svnbot6> r4454, nothingmuch++ | Harrorth in READTHEM

[23:02] *** batdog is now known as batdog|gone

[23:15] *** misc is now known as JoeFox

[23:15] *** JoeFox is now known as misc

[23:21] <mj41> http://wiki.kn.vutbr.cz/mj/attach/pugs/http-server/  ... good night

[23:21] <crysflame> neat

[23:33] <Limbic_Region> nothingmuch - will revisit harroth soonish now

[23:33] * Limbic_Region is off

