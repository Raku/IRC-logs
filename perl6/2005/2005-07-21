[00:36] <brentdax> Is there a Perl 6 tail call syntax, and if so is it implemented in Pugs?

[00:37] <autrijus> &sub.goto(...);

[00:37] <autrijus> and yes.

[00:42] <autrijus> brentdax: do you see a problem with Block params default to Item|Pair|Junction -- i.e. any ?

[00:42] <autrijus> s/any/Any/

[00:42] <brentdax> Just that the for 1|2|3 { ... } behavior is no longer automatic.

[00:43] <autrijus> but it is of dubious value anyway

[00:43] <brentdax> Oh...are tail method calls possible?

[00:43] <brentdax> True.

[00:44] <autrijus> tail method calls. hrmph.

[00:44] <autrijus> what would you suggest as a syntax?

[00:44] <brentdax> Basically, it means that a lot of things that were expected to autothread before won't.  But that's not necessarily a bad thing, because those were mostly surprising places to autothread.

[00:44] <autrijus> (tail methcalls is only not there because of unspeccedness)

[00:47] <brentdax> I don't know...Perl 6 doesn't have an equivalent of a C# delegate (besides general-purpose currying, that is).  In the worst case, you could do something along the lines of $obj.can('method').goto($obj, ...);

[00:50] <brentdax> But clearly that's rather ugly.  Maybe $obj.\method can give you a reference to the method, pre-curried to $obj.

[00:51] <autrijus> maybe .can('method') should precurry to $obj anyway. maybe.

[00:51] <autrijus> goto $obj.can('method'): @args;

[00:52] <autrijus> anyway, try p6l it and we'll see how to implement that :)

[00:52] <brentdax> Will do, soonish.

[00:53] <autrijus> eggcellent.

[00:58] <Khisanth> first ./ now .\? :/

[00:58] <coral> autrijus: with Quantum::Entanglement it's possible to tell it to pick one of the entangled numbers in the junction

[00:58] <coral> how do i do that with (0|1)?

[00:59] <autrijus> Khisanth: I don't think it's a good idea :)

[00:59] <autrijus> ?eval (0|1).pick

[00:59] <evalbot6> 1 

[00:59] <coral> aha

[00:59] <autrijus> ?eval (0|1).pick

[00:59] <coral> thanks

[00:59] <evalbot6> 1 

[00:59] <autrijus> ?eval (0|1).pick

[00:59] <evalbot6> 1 

[00:59] <autrijus> mmmmm.

[00:59] <coral> ?eval ((0|1).pick) xx 10

[00:59] <evalbot6> (0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 

[00:59] <coral> hmm

[00:59] <Khisanth> autrijus: I am envisioning a perl6 variant called toothpick

[00:59] <autrijus> Khisanth: I \\ /|\ | \//|\ \

[01:00] <coral> ?eval sub decision () returns Int { (0|1).pick }; (decision) xx 3

[01:00] <evalbot6> (1, 1, 1) 

[01:00] <coral> ?eval sub decision () returns Int { (0|1).pick }; (decision) xx 50

[01:00] <evalbot6> (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 

[01:00] <Khisanth> that looks like a bridge :)

[01:00] <autrijus> coral: xx is merely repeat

[01:00] <coral> hm

[01:00] <coral> so it evals left side and THEN repeats

[01:01] <coral> is there a way to force left side to eval *after* the repeat occurs?

[01:01] <autrijus> ?eval map { (0|1).pick } 1..10

[01:01] <evalbot6> (0, 0, 1, 1, 1, 0, 1, 0, 0, 1) 

[01:01] <coral> aha!

[01:01] <coral> unf!

[01:01] <coral> thank you :)

[01:01] <autrijus> np :)

[01:01] <coral> ?eval map { (0|1).pick } 1..any(5..10)

[01:01] <evalbot6> ((0 | 1)) 

[01:01] * coral blinks

[01:01] <coral> ?eval map { (0|1).pick } 1..5

[01:01] <evalbot6> (0, 1, 1, 1, 1) 

[01:02] <coral> ?eval map { (0|1).pick } 1..(any(5,10))

[01:02] <evalbot6> ((0 | 1)) 

[01:02] <coral> ?eval any(5,10)

[01:02] <evalbot6> 5 

[01:02] <coral> i don't get it

[01:02] <autrijus> ?eval 1..(5|10)

[01:02] <evalbot6> (1, 2, 3, 4, 5) 

[01:02] <autrijus> ?eval 1..(5|10)

[01:02] <evalbot6> (1, 2, 3, 4, 5) 

[01:02] <autrijus> ?eval 1..(5|10)

[01:02] <evalbot6> (1, 2, 3, 4, 5) 

[01:02] <autrijus> ?eval 1..(5|10)

[01:02] <evalbot6> (1, 2, 3, 4, 5) 

[01:02] <autrijus> hrm.

[01:02] <coral> well, i think there's one or two bugs in that somewhere

[01:02] <autrijus> what's wrong with the randomizer.

[01:02] <coral> ?eval 1..any(1)

[01:02] <evalbot6> (1) 

[01:02] <coral> ?eval 1..any(10)

[01:02] <evalbot6> (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 

[01:02] <autrijus> ?eval map { 1 } 1..2

[01:02] <evalbot6> (1, 1) 

[01:02] <coral> ?eval 1..any(2,4)

[01:02] <evalbot6> (1, 2) 

[01:03] <autrijus> ?eval map { 1 } 1..any(2,2)

[01:03] <evalbot6> ((1)) 

[01:03] <autrijus> ?eval map { 1 } 1..any(3)

[01:03] <evalbot6> ((1)) 

[01:03] <autrijus> ?eval map { 1 } 2..any(3)

[01:03] <evalbot6> ((1)) 

[01:03] <coral> neato

[01:03] <coral> i think 2..any() is busted

[01:03] <autrijus> only as argument to map

[01:03] <coral> ?eval map { (0|1).pick } 1..(4|5|6).pick

[01:03] <evalbot6> (0, 1, 1, 1) 

[01:03] <autrijus> I think what happens is that it autothreads over map

[01:03] <coral> ?eval map { (0|1).pick } 1..(4|5|6|7|7|7|7|7|7|7|7|7|7|7).pick

[01:03] <evalbot6> (0, 1, 0, 0, 1, 1, 0) 

[01:04] <coral> hey, that worked. neato.

[01:04] <autrijus> as a list of junctions with one element

[01:04] <autrijus> and recombine back to any(1,1,1,1,1)

[01:04] <autrijus> which is ((1))

[01:04] * coral nods

[01:05] <coral> ?eval 0^1

[01:05] <evalbot6> 0 

[01:05] <coral> ?eval 2^4

[01:05] <evalbot6> 2 

[01:07] <coral> ?eval my @code = (0|5).pick..(6|10).pick; @code

[01:07] <evalbot6> [5, 6] 

[01:07] <coral> ?eval my @code = (0|5|5|5|5|5|5|5|5).pick..(6|10|10|10|10|10|10).pick; @code

[01:07] <evalbot6> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

[01:07] * coral bows.

[01:10] <stevan> rehi autrijus 

[01:10] <stevan> if you have a spare moment, can you please look over perl5/Perl6-MetaModel/t/80_Code.t

[01:11] <stevan> I need an (in)sanity check on the class layout :)

[01:13] <autrijus> looks excellent

[01:13] <stevan> autrijus: :)

[01:13] <stevan> thank you

[01:14] <autrijus> :)

[01:14] <stevan> ok, nothingmuch and I are going to prototype some MMD stuff this weekend

[01:14] * autrijus worries a bit about name clash with existing CPAN Perl6::* modules

[01:14] <stevan> yes, I thought about that too

[01:15] <stevan> I am punting on it for now though

[01:15] * autrijus ponders Perl6::Runtime::Signature, P6::Signature, etc

[01:15] <autrijus> sure

[01:15] <stevan> hmm, P6:: might be nice

[01:16] <mugwump> stevan: out of interest, why wouldn't you use check_params at new() time ?

[01:16] <mugwump> I just hate seeing unmarshalled @_ going into objects ;)

[01:16] <mugwump> (reminds me of the Tangram code base too much)

[01:16] <stevan> mugwump: where specifically?

[01:17] <mugwump> oh, wait, duh, this is a test script.  I just saw the packages

[01:17] <mugwump> and my brain flipped into "you are reading a module" mode

[01:17] <stevan> mugwump: yes, it was just a first draft

[01:18] <stevan> s/was/is/

[01:18] <autrijus> hm, I really need to find some breakfast, lest I'll be late, as in late autrijus tang

[01:19] <autrijus> bbiab &

[01:26] <mugwump> Maybe I should write a version of Class::Tangram::Generator that makes Perl6::Class objects

[01:31] <mugwump> hmm, no, it would have to work from T2 objects.

[01:32] <mugwump> that seems like an interesting distraction

[02:12] <autrijus> rehi.

[02:12] * autrijus praises food

[02:16] * cm is hungry

[02:39] <Khisanth> hmm

[03:16] * mugwump prods svnbot6 

[03:16] <svnbot6> r5722, mugwump++ | A little doodle

[03:16] <svnbot6> r5723, Stevan++ | Perl6::Code - changes execute() to do() because $Larry hates COBOL

[03:16] <stevan> mugwump: very interesting

[03:17] <mugwump> You like?  :D

[03:17] <stevan> so can that make Perl6::MetaModel classes from a DB schema?

[03:17] <mugwump> so long as (DB schema) does Tangram::Schema

[03:17] <stevan> nice

[03:20] <mugwump> I have an example schema that is modelled against an RT schema in the Tangram distribution.  There is also a simpler "musicstore" schema

[03:20] <stevan> very nic

[03:20] <stevan> e

[03:21] <stevan> so using this I can build normal Class::Tangram classes, and they will make Perl6::MetaModel classes?

[03:21] <svnbot6> r5724, Stevan++ | Perl6.MetaModel : JS port of Perl6::MetaModel

[03:21] <svnbot6> r5724, Stevan++ | * only (partial) Perl6.MetaClass so far, but the C3 MRO is ported

[03:21] <svnbot6> r5724, Stevan++ |     - some tests as well 

[03:21] <stevan> iblech: that one is for you :P

[03:22] <autrijus> say what?

[03:22] <stevan> :P

[03:22] <autrijus> wow, I see some loving from JSAN

[03:22] <autrijus> maybe this can indeed hit JSAN ;)

[03:23] <autrijus> cwest: look! Perl6/MetaClass.js!

[03:23] <stevan> we will see how the actually class builder part turns out, the MetaClass is the easy part

[03:23] <autrijus> JSAN-compliant even

[03:23] <autrijus> stevan: perl5/ ? :)

[03:23] <cwest> woo!

[03:23] * autrijus ponders jsan/ or js/

[03:24] <stevan> autrijus: I wasnt sure where to put it actually

[03:24] <mugwump> stevan: Class::Tangram generates accessors, it doesn't try to represent them.  T2::Class is the "meta" object, if you like

[03:26] <stevan> mugwump: ok, I think I get it. I will wait for some more tests to really grok it

[03:56] <jdv79> how does one generate js?

[03:56] <autrijus> jdv79: see PIL2JS/README

[03:56] <autrijus> perl5/PIL2JS/README

[03:57] <jdv79> oh, thanks!

[03:59] <autrijus> :)

[04:03] <brentdax> Hmm...are there any parts of Pugs that are especially slow?  Each page request is taking several seconds of max CPU right now...

[04:04] <autrijus> yes, the evaluator is especially slow.

[04:04] <autrijus> it will be faster in the new evaluator, and is already faster if compiled to PIR.

[04:05] <brentdax> Heh.

[04:05] <autrijus> i.e. known issue, working on it :)

[04:05] <autrijus> (we apologise for the inconvenience)

[04:05] <brentdax> (Code base is 700-odd lines, and uses both Perl 5 interop and some simple regexen via Parrot embedding.)

[04:06] <autrijus> nod... likely not your problem.

[04:07] <brentdax> Alright.  I was thinking that maybe the pattern matches might be a problem, and that I should use :p5 instead.

[04:07] <autrijus> you can bench, but I don't think that is the bottleneck.

[04:13] <brentdax> I don't think I'll bother, then--this doesn't have to be fast yet, it just has to work.

[04:16] <luqui> none(): poke

[04:19] <jdv79> mandel to js in FF ran a little faster this time:)  cool.

[04:21] <luqui> there's a js backend now?

[04:22] <stevan> luqui: yes

[04:26] <brentdax> I'm not sure if the JS backend is the coolest or most twisted thing I've ever heard of.  Or maybe both.

[04:47] <cwest> brentdax: My vote is both.

[05:57] *** calvin__ is now known as calvin_

[06:24] <svnbot6> r5725, Stevan++ | Perl6.MetaModel - 

[06:24] <svnbot6> r5725, Stevan++ | * added Perl6.Method class

[06:24] <svnbot6> r5725, Stevan++ |     - tests for this

[06:24] <svnbot6> r5725, Stevan++ | * added Perl6.MetaClass.Dispatcher class

[06:24] <svnbot6> r5725, Stevan++ |     - added tests for this

[06:24] <svnbot6> r5725, Stevan++ | * added dispatcher support and method support for MetaClass

[06:24] <svnbot6> r5725, Stevan++ |     - added tests for that

[08:07] <Darren_Duncan> I've just been working on writing my Lightning Talk now ...

[08:07] <Darren_Duncan> and boy is 5 minutes ever short

[08:07] <Darren_Duncan> near as I can tell, it takes 5 seconds to read a line of text, so I have to max out at 60 full lines, or better yet 60 partial lines to allow pauses and breathing

[08:07] <Darren_Duncan> that's not very much at all

[08:08] <Darren_Duncan> my original intro was 2.5 minutes itself, and I'll have to chop it way down

[08:08] <Darren_Duncan> anyway, that's all fyi

[08:19] <kks> How to call a shell script from a perl cgi?

[08:20] <QtPlatypus> I think that you need #perl rather then #perl6

[08:24] <kks> QtPlatypus, thanks

[08:26] <QtPlatypus> No problem.

[10:49] <QtPlatypus> ?eval class Foo {...};ref(Foo);

[10:49] <evalbot6> *** ... - not yet implemented     at <eval> line 1, column 12-15 

[10:49] <QtPlatypus> ?eval class Foo {};ref(Foo);

[10:49] <evalbot6> ::Class 

[10:52] *** Aragone is now known as Arathorn

[13:39] <svnbot6> r5726, fglock++ | * Added tests for negative infinity stringification 

[13:39] <svnbot6> r5726, fglock++ |   (-Inf ne '-Inf')

[13:39] <svnbot6> r5727, fglock++ | (fixed test count)

[13:51] <svnbot6> r5728, fglock++ | * Tests int() of special values Inf,-Inf,NaN

[14:39] <dada> ?eval ref('Foo');

[14:39] <evalbot6> ::Str 

[14:39] <dada> ?eval ref(Foo);

[14:39] <evalbot6> Error: No compatible subroutine found: "&Foo" 

[14:39] <dada> ?eval my $sub = \&print; ref($sub);

[14:39] <evalbot6> Error: Undeclared variable: "&print" 

[14:40] <dada> ?eval my $sub := \&print; ref($sub);

[14:40] <evalbot6> Error: Undeclared variable: "&print" 

[14:40] <dada> ?eval my $sub = sub { 42 }; ref($sub);

[14:40] <evalbot6> ::Sub 

[14:41] <dada> ?eval my $array = (1,2,3); ref($array);

[14:41] <evalbot6> ::Array 

[14:47] <nothingmuch> http://home.cwru.edu/%7Ejnt5/Planarity/

[14:47] * nothingmuch is already at level 12

[14:47] <nothingmuch> productivity is down

[14:47] <nothingmuch> but fun is up

[15:07] <dada> nothingmuch: Planarity++ (even +++)

[15:07] <nothingmuch> oh man

[15:18] <Khisanth> that thing again

[15:36] <dada> ?eval ref 42

[15:36] <evalbot6> ::Int 

[15:36] <dada> ?eval ref \42

[15:36] <evalbot6> ::Int 

[15:36] <dada> ?eval ref 1,2,3

[15:36] <evalbot6> (::Int, 2, 3) 

[15:36] <dada> ?eval ref(1,2,3)

[15:36] <evalbot6> Error: No compatible subroutine found: "&ref" 

[15:36] <dada> ?eval ref [1,2,3]

[15:36] <evalbot6> ::Array 

[15:37] <QtPlatypus> ?eval ref (1,2,3)

[15:37] <evalbot6> ::Array 

[15:42] <Aankhen``> ?eval my $foo = 10; $foo is random_trait;

[15:43] <evalbot6> undef 

[15:43] <Aankhen``> ?eval my &foo := sub () { "foo" }; &foo is random_trait; foo

[15:43] <evalbot6> 'foo' 

[15:44] <Aankhen``> ?eval module Foo { my &Foo::("foo") := sub () { "foo" }; &Foo::foo is random_trait; foo }

[15:44] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[15:44] <Aankhen``> ?eval module Foo { &Foo::("foo") := sub () { "foo" }; &Foo::foo is random_trait; foo }

[15:44] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[15:44] <Aankhen``> ?eval module Foo { &Foo::foo := sub () { "foo" }; &Foo::foo is random_trait; foo }

[15:44] <evalbot6> Error: Undeclared variable: "&Foo::foo" 

[15:44] <Aankhen``> ?eval module Foo { &foo := sub () { "foo" }; &foo is random_trait; foo }

[15:44] <evalbot6> Error: Undeclared variable: "&foo" 

[15:45] <Aankhen``> ?eval module Foo { }; &Foo::foo := sub () { "foo" }; foo

[15:45] <evalbot6> Error: Undeclared variable: "&Foo::foo" 

[15:45] <Aankhen``> Bah.

[15:45] <dada> QtPlatypus: does the space matters?

[15:45] <QtPlatypus> dada: Yes

[15:45] <dada> awful

[15:46] <QtPlatypus> ref(1,2,3); Means call the three argument form of &ref.  There is no three arugment form of ref so it fails.

[15:46] <dada> yes, I understand this

[15:46] <osfameron> eeek!

[15:47] <QtPlatypus> ref (1,2,3); Means call ref on the array (1,2,3).  So it works.

[15:47] <dada> but then, "mysub (1,2,3) means "call mysub with a single arrayref parameter?"

[15:47] <QtPlatypus> ref .(1,2,3)l Means call the three arguement form of &ref

[15:47] <dada> oops

[15:47] <dada> but then, "mysub (1,2,3) means "call mysub with a single arrayref parameter?"

[15:47] * dada is unable to type

[15:48] <QtPlatypus> Thats my (and pugs) understanding.

[15:48] <dada> ?eval sub foo(*@args) { join ", ", @args; }; foo(1,2,3);

[15:48] <evalbot6> '1, 2, 3' 

[15:48] <dada> ?eval sub foo(*@args) { join ", ", @args; }; foo (1,2,3);

[15:48] <evalbot6> '1, 2, 3' 

[15:48] <dada> mmm

[15:49] <QtPlatypus> ?eval sub foo(@args) { join ", ", @args; }; foo(1,2,3);

[15:49] <evalbot6> Error: No compatible subroutine found: "&foo" 

[15:49] <QtPlatypus> ?eval sub foo(@args) { join ", ", @args; }; foo (1,2,3);

[15:49] <evalbot6> '1, 2, 3' 

[15:49] <dada> I'm not sure *@args should take [1,2,3] as (1,2,3)

[15:50] <dada> ?eval sub foo(*@args) { join ", ", @args; }; foo (1,[2,3],4);

[15:50] <evalbot6> '1, 2 3, 4' 

[15:50] <QtPlatypus> What do you mean?

[15:51] <dada> I expected @args to contain only one element, an arrayref

[15:51] <dada> oh, but my expectation is wrong, I see

[15:52] <dada> (1,2,3) (which is [1,2,3] in p5 terms) is evaluated in list context here, so it correctly derefs

[15:52] <QtPlatypus> It still is the list context.

[15:52] <dada> ?eval sub foo(*@args) { join ", ", @args; }; foo \(1,2,3);

[15:52] <evalbot6> '1 2 3' 

[15:52] <dada> heh

[15:53] <QtPlatypus> ?eval sub foo(@args) { join ", ", @args; }; foo [1,2,3];

[15:53] <evalbot6> '1 2 3' 

[15:53] <dada> ?eval sub foo(@args) { join ", ", @args; }; foo \(1,2,3);

[15:53] <evalbot6> '1, 2, 3' 

[15:53] <dada> this is very, very subtle

[15:54] * QtPlatypus nods "It is"

[15:54] <dada> but wait, why [1,2,3] comes in as @args[0]?

[15:55] <dada> ?eval sub foo(@args) { join ", ", @args; }; my @x = (1,2,3); foo @x;

[15:55] <evalbot6> '1, 2, 3' 

[15:55] <dada> ?eval sub foo(@args) { join ", ", @args; }; my @x = (1,2,3); foo \@x;

[15:55] <evalbot6> '1, 2, 3' 

[15:55] <dada> ?eval sub foo(@args) { join ", ", @args; }; my $x = (1,2,3); foo $x;

[15:55] <evalbot6> '1 2 3' 

[15:56] <dada> ouch

[15:56] <QtPlatypus> The lession here, use the spaceless form unless you realy realy knwo what your doing.

[15:57] <dada> I think the spaced form should elicit a warning, unless you "use mastery;"

[16:03] <gaal> hola

[16:05] <lumi> Hola

[16:08] <stevan> hey gaal 

[16:11] <gaal> greetings from the tel-aviv hackathon!

[16:11] <stevan> gaal: nice

[16:12] * geoffb waves in the general direction of tel-aviv

[16:14] <PerlJam> tel-aviv hackathon?

[16:14] <PerlJam> these hackathons are *everywhere*  ;)

[16:15] <lumi> "Join us..."

[16:15] <geoffb> Need to have one at my house.  :-)

[16:16] <stevan> PerlJam: if you are going, can you pick me up on the way? My jet is in the shop

[16:16] <geoffb> Of course, not any time soon, what with the coming baby and all . . . 

[16:18] <stevan> geoffb: hackathon hours are not all that different from new baby hours actually :)

[16:18] <geoffb> Yeah, but both together would have me up the entire time the hackathon was going.

[16:19] <geoffb> By day 3 my code could be mistaken for fluent Drunkeneese

[16:19] <stevan> geoffb: we could all take turns feeding, burping and changing diapers,... hackers tend to be good at such things :P

[16:19] <geoffb> LOL

[16:20] <stevan> though in all seriousness, I think gaal has a great idea

[16:20] <geoffb> oh, totally

[16:20] <stevan> (mini-local-hcakathons)++

[16:22] <stevan> if I didnt think my wife would kill me, I would have one :)

[16:41] <gaal> whoa, gaal also has some grocieries he forgot to put in the fridge. brb

[16:48] <Jon1> has anybody used placeholders with use perl5:DBI ?

[16:48] <Jon1> my @a = $db.selectrow_array('select * from emp where pid = 1'); works for me

[16:48] <Jon1> my @a = $db.selectrow_array('select * from emp where pid = ?', undef, 1); does not work for me

[16:50] <Jon1> the parameters are the sql, then a hashref of statement attributes or undef, then the parameters to bind

[16:51] <Jon1> in perl 5 I almost always just used undef

[16:51] <Jon1> pugs gives me: DBI::st=HASH(0x8968c10)->_prepare(...): attribute parameter 'pugs=SCALAR(0x881e55c)' is not a hash ref at /usr/lib/perl5/site_perl/5.8.4/i686-linux/DBD/Oracle.pm line 321.

[16:52] <geoffb> Given what you just said, is there a problem with s/undef/{}/?

[16:53] <Jon1> what is the p6 syntax for an literal empty hashref? (I've tried various things with no luck) in p5 it was just {}

[16:53] <geoffb> ?eval \{}

[16:53] <evalbot6> \sub {...} 

[16:53] <geoffb> ah, interesting

[16:54] <geoffb> ?eval {,}

[16:54] <Khisanth> ?eval +{}

[16:54] <evalbot6> Error:  unexpected "," expecting ";", statements or "}" 

[16:54] <evalbot6> Error: cannot cast from VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subEnv = Just (MkEnv {envContext = CxtItem (mkType "Any"), envLValue = False, envLexical = MkPad (padToList [("$?1",[(<ref>,<ref>)]),("$_",[(<ref>,<ref>)]),("$code",[(<ref>,<ref>)]),("$lang",[(<ref>,<ref>)]),("&?BLOCK_EXIT",[(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>)]),("&break",[(<ref>,<ref>),(<ref>,<ref>)]),("&

[16:54] <Khisanth> !

[16:54] <geoffb> ?eval {;}

[16:54] <evalbot6> undef 

[16:54] <geoffb> !

[16:54] <Jon1> I think in p6 {} is always a closure

[16:54] <geoffb> ok

[16:54] <geoffb> hmmm

[16:54] <Khisanth> ?eval hash{}

[16:54] <evalbot6> {('<SubBlock(<anon>)>' => undef)} 

[16:54] <geoffb> ?eval hash()

[16:54] <evalbot6> {} 

[16:54] <geoffb> A-ha!

[16:54] <Khisanth> ah

[16:55] <Khisanth> so it IS looking more and more like PHP :)

[16:55] <geoffb> evalbot6++ # just for being there when I needed it most

[16:55] * geoffb sees 'PHP' and starts saying 'la-la-la-la-la-la'

[16:55] <Khisanth> hmm

[16:55] <Khisanth> ?eval {=>}

[16:55] <evalbot6> Error:  unexpected ">" expecting term 

[16:56] <Jon1> my @a = $db.selectrow_array('select * from emp where pid = ?', hash(), 1);

[16:56] <Jon1> DBI::st=HASH(0x8968c10)->_prepare(...): attribute parameter 'ARRAY(0x8968d30)' is not a hash ref at /usr/lib/perl5/site_perl/5.8.4/i686-linux/DBD/Oracle.pm line 321.

[16:56] <Khisanth> ?eval {undef=>undef}

[16:56] <evalbot6> {('undef' => undef)} 

[16:56] <geoffb> Jon1, eww

[16:57] <geoffb> Jon1, try 'my $empty = hash(); my @a = $db.selectrow_array(..., $empty, 1);

[16:57] <geoffb> just to help narrow this one down

[16:57] <Jon1> my @a = $db.selectrow_array('select * from emp where pid = ?', {('undef' => undef)}, 1);

[16:57] <Jon1> DBI::st=HASH(0x8968c10)->_prepare(...): attribute parameter 'ARRAY(0x8968d30)' is not a hash ref at /usr/lib/perl5/site_perl/5.8.4/i686-linux/DBD/Oracle.pm line 321.

[16:57] <Jon1> ok

[16:57] *** Maddingue__ is now known as Maddingue

[16:58] <Jon1> my $empty=hash(); my @a = $db.selectrow_array('select * from emp where pid = ?', $empty, 1);

[16:58] <Jon1> DBI::st=HASH(0x8968c10)->_prepare(...): attribute parameter 'ARRAY(0x8968d30)' is not a hash ref at /usr/lib/perl5/site_perl/5.8.4/i686-linux/DBD/Oracle.pm line 321.

[16:58] <geoffb> pugs seems to have invariance problems with literal things versus same stuffed in variables.  Or maybe it is a Perl 6 issue . . . 

[16:58] <geoffb> bah

[16:59] <geoffb> embed-layer bug, mayhaps

[16:59] <Khisanth> geoffb: perl5 has a bit of problem with that too

[17:00] <geoffb> Khisanth, fair enough, but I've still been amazed at how often it comes up in pugs . . . I think my mental model of the internals must be wrong.

[17:00] <Khisanth> well only one I know of in p5 is with undef

[17:01] <geoffb> Khisanth, example?

[17:01] <Aankhen``> ?eval 1 => 2 => 3 => 4

[17:01] <evalbot6> (1 => (2 => (3 => 4))) 

[17:02] <geoffb> ... and there was much rejoicing

[17:02] <Aankhen``> Hi.

[17:02] <gaal> hey Aanken``!

[17:02] * Aankhen`` pouts.

[17:03] <Aankhen``> s/nk/nkh/

[17:03] <Aankhen``> And: HI gaal. =)

[17:03] * gaal can't type. sorry :)

[17:03] <Aankhen``> What's shakin'?

[17:03] <gaal> tlv hackathon's up, yo

[17:03] <Aankhen``> Oooh, awesome.

[17:04] <Aankhen``> Man.  I'm thoroughly exhausted today.  It's only 10:30 PM and I'm already thinking of turning in.

[17:04] * geoffb would follow up with a similar slangfest, but I just can't bring myself to do so.

[17:04] <geoffb> Aankhen``, are you in Bangalore?

[17:05] <Aankhen``> Somewhere in India. :-)

[17:05] <geoffb> Dang.  Was trying that "Think of a card.  Is it the Ace of Spades?" trick

[17:05] <Aankhen``> o_O

[17:06] <Aankhen``> With "Bangalore"?

[17:06] <Aankhen``> How does that go?

[17:06] <geoffb> You're in the right timezone, and Bangalore is a tech center, so the percentages were good enough to try it.  If I'd been right, you'd have gone "How the heck did you know that?"  :-)

[17:07] <geoffb> I think the Ace of Spades and the Queen of Hearts are the most popular cards, so just guessing one of those will get a certain percentage of your audience to be impressed.

[17:07] <geoffb> "Think of a number.  Is it 3?" Is similar

[17:07] <Aankhen``> Ah, thataway.

[17:08] <Aankhen``> ?eval (1, 2, 3) >>+ 4

[17:08] <evalbot6> Error:  unexpected ">" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[17:08] <Khisanth> ?eval (1, 2, 3) >>+<< 4

[17:08] <evalbot6> (5, 6, 7) 

[17:09] * Aankhen`` lost his bearings with regard to `>>+` vs. `>>+<<` today.

[17:12] <Khisanth> ?eval sub prefix:<sub prefix:<+> ($val) { $val + 4 } +<< (1,2,3)

[17:12] <evalbot6> (1, 2, 3) 

[17:13] <Khisanth> hmm

[17:13] <Khisanth> oops

[17:13] <Khisanth> ?eval sub prefix:<+> ($val) { $val + 4 } +<< (1,2,3)

[17:13] <evalbot6> (5, 6, 7) 

[17:13] <Khisanth> Aankhen``: need the >> and << unless it's a unary op :)

[17:14] <Aankhen``> Er... wha?

[17:18] <Khisanth> ?eval (1,2,3) >>++

[17:18] <evalbot6> Error: Can't modify constant item: VInt 1 

[17:18] <Khisanth> hmm

[17:19] <Khisanth> ?eval my @foo = (1,2,3);  @foo >>++

[17:19] <evalbot6> Error: Can't modify constant item: VInt 1 

[17:21] <Khisanth> ?eval my @foo = (1,2,3);  ++<< @foo

[17:21] <evalbot6> Error: Can't modify constant item: VInt 1 

[17:21] <svnbot6> r5729, Aankhen++ | * HTTP::Cookies: added `NEXT` block within &add_cookie_header.

[17:21] <svnbot6> r5730, Aankhen++ | * HTTP::Status: (hopefully) better generation of mnemonic subroutines.

[17:21] <svnbot6> r5731, Aankhen++ | * HTTP::Status: fixed mistake in previous commit.

[17:22] <Khisanth> why is that a constant?

[17:24] <Aankhen``> ?eval sub foo (&block) { &block() }; foo(-> { "foo" })

[17:24] <evalbot6> 'foo' 

[17:24] <Aankhen``> ?eval sub foo (*&block) { &block() }; foo(-> { "foo" })

[17:24] <evalbot6> pugs: Internal error:     doBindArray: unexpected char: '&' Please file a bug report. 

[17:24] <Aankhen``> ?eval sub foo (Code *$block) { &block() }; foo(-> { "foo" })

[17:24] <evalbot6> Error: No compatible subroutine found: "&block" 

[17:24] <Aankhen``> ?eval sub foo (Code *$block) { $block.() }; foo(-> { "foo" })

[17:24] <evalbot6> 'foo' 

[17:25] <Aankhen``> ?eval sub foo (Code *$block) { $block.() }; foo():{ "foo" }

[17:25] <evalbot6> 'foo' 

[17:25] <Aankhen``> How come `*&block` doesn't work?

[17:30] <geoffb> slurpy block?

[17:32] <geoffb> dammit, can't even make unoptimized anymore.

[17:32] * geoffb goes about trying to clean VM

[17:32] <geoffb> (sigh)

[17:32] <Aankhen``> Yes, slurpy block.

[17:33] <Aankhen``> I would have thought it'd function in the same way as `Code *$block`.

[17:33] <Khisanth> what exactly does a slurpy block mean?

[17:33] <Aankhen``> A block that can be passed as an adverb (see last ?eval above).

[17:39] <Aankhen``> G'night.

[17:39] <svnbot6> r5732, iblech++ | * Usual svn properties.

[17:39] <svnbot6> r5732, iblech++ | * New test added to t/data_types/hash.t:

[17:39] <svnbot6> r5732, iblech++ |   my %hash = (a => 1, b => 2, a => 3); say %hash<a>  # should be 1, not 3

[17:39] <svnbot6> r5732, iblech++ |   (see http://www.nntp.perl.org/group/perl.perl6.language/22401)

[17:45] <geoffb> Hmmm.

[17:46] <geoffb> iblech++ # including a link to the ruling

[17:46] <geoffb> .oO( But what's wrong with foo(*%defaults, a => 1)? )

[17:47] <gaal> hey folks. i'm getting ready to check in the file-based build config stuff; it might break stuff so i need your help testing + fixing :)

[17:47] <geoffb> "file-based build config stuff"?

[17:47] <geoffb> oh, the YAML thing?

[17:47] <gaal> yeah, at last.

[17:48] <geoffb> I was in try-to-build mode anyway, so as soon as I can build (aka kill some windows chewing VM), I can help test

[17:49] <gaal> cool, thanks

[17:49] <geoffb> np

[17:50] <gaal> sec, i want to make clean once after the svn up to make sure i'm not committing total bollcks :)

[17:51] <gaal> anyone know why $ccdlflags aren't being passed to make ghci today?

[17:52] <gaal> dinner :)   &

[17:55] <iblech> stevan: FYI, I'm reading the docs of Perl6[.-]MetaModel now so we can integrate it into PIL2JS today/tomorrow :)

[17:57] <svnbot6> r5733, iblech++ | PIL2JS: Splitted the main Prelude::JS into smaller parts, e.g.

[17:57] <svnbot6> r5733, iblech++ | Prelude::JS::Array, Prelude::JS::Code, etc.

[17:59] <gaal> hola szabgab

[17:59] <szabgab> hey gaal are you also here ?

[17:59] <gaal> i see the hummous got to you. :)

[18:00] <szabgab> that and all the other the things I stuffed

[18:00] <iblech> stevan: "Submethods are methods which can only be called by an invocant whose class is the same as which the submethod has been defined in. Meaning they are not inherited."

[18:01] <iblech> stevan: But the following does work (I asked Larry): class Foo { submethod blarb {...} }; class Bar is Foo { submethod blarb {...} }; Bar.new.blarb() (calls &Bar::blarb); Bar.new.Foo::blarb() (calls &Foo::blarb)

[18:01] <Limbic_Region> $larry just muddied the decision on hash assignment btw

[18:02] <geoffb> It's times like this I remember why I haven't subscribed to p6*

[18:03] <iblech> stevan: The relevant posting is at http://groups-beta.google.com/group/perl.perl6.language/msg/e9174e5538ded4a3, at the very end

[18:05] <iblech> Hm... WRT to hash creation with duplicate keys: I don't care if we choose the Perl 5 behaviour or Luke's, but I think I definitely want the behaviour to be the same in assignment and binding (consistency...)

[18:06] <geoffb> agreed

[18:06] <PerlJam> iblech: I've come to rely on p5's behavior in a couple of places.  I'd prefer that it remain that way  :-)

[18:06] <PerlJam> though if it's right-most wins on assignment and left-most on binding I could probably deal.

[18:07] <geoffb> That seriously violates least surprise

[18:08] <PerlJam> well ... talk to $Larry about it.

[18:10] * PerlJam contemplates writing a "science fiction" story where a large community of programmers follow the lead of  their chief language designer despite his occasional bizarre decisions only to find out in the end that the language designer has gone crazy mid-way through the design process  ;-)

[18:11] * geoffb takes comfort in the fact that we can make a 0-day Perl 6+i if need be

[18:11] <svnbot6> r5734, iblech++ | t/oo/submethods.t -- SomeSubclass.Superclass::some_submethod() should work (and

[18:11] <svnbot6> r5734, iblech++ | does), see http://groups-beta.google.com/group/perl.perl6.language/msg/e9174e5538ded4a3.

[18:15] * geoffb has mentally brutalizing children's songs going through his head

[18:15] <geoffb> .oO( as opposed to all of them that *aren't*? )

[18:16] <geoffb> Must replace with something opposite . . . hmmm, Ozzy in order, I think

[18:16] <geoffb> gaal, my current compile still continuing.  How close are you to committing?

[18:17] * dudley is reminded of the duet that Ozzy did with Miss Piggy...

[18:17] <geoffb> Man, that would have been fun to watch

[18:19] <geoffb> Sigh . . . ghc going on 4 min of CPU time for Pugs.Run

[18:20] <iwlx> Huh, only?

[18:20] *** iwlx is now known as wilx

[18:20] <wilx> I remember AST.hs to take much more time.

[18:21] <geoffb> wilx, *just for that one file*

[18:21] <geoffb> Oh, perhaps, but this is pass 2.

[18:21] <geoffb> whee, linked

[18:21] <geoffb> (using 290 MB of VM . . . I really need to finish up that separate-link-pass patch)

[18:22] <geoffb> wilx, oh, and unoptimized . . . I can't build optimized at all on this box

[18:23] <Limbic_Region> I am completely confused by Pugs compile times - my work machine (which is beefier) takes forever while my home machine takes no time at all (relatively speaking)

[18:23] <geoffb> Odd . . . same OS and toolchain versions?

[18:24] <integral> Limbic_Region: more memory at home?  (more free memory?)

[18:25] <Limbic_Region> integral - beefier = more resources all around

[18:25] <integral> hmm, are you using those resources?

[18:26] <Limbic_Region> well, not me personally - but it is possible that there are some uber hidden monitoring devices I don't know about - but if there are I can't detect them

[18:26] <geoffb> gaal, OK, previous pugs made/installed/realcleaned -- ready when you are

[18:26] <Limbic_Region> hmmm - that's odd

[18:27] <Limbic_Region> there very well may be hidden processes

[18:28] <Limbic_Region> *shrug* - it isn't like I can complain really - what exactly is Pugs and how does it relate to your job would be a tough question to answer

[18:28] <geoffb> Work machine is locked down, yes?  I wonder if they went so far as to run the visible env under a VM supervisor . . . .

[18:30] <Limbic_Region> yes, locked down.  But it works, and that is what counts.

[18:30] <geoffb> sure . . . just theorizing

[18:31] <geoffb> ?eval my $foo = [1, 4, 9]; say $foo[0]; $foo[0]++; $foo[0];

[18:31] <evalbot6> 1 \2 

[18:32] <geoffb> hmm

[18:32] <Limbic_Region> makes sense

[18:32] <Limbic_Region> 1 is the return code of say

[18:32] <geoffb> sorry, evalbot was failing to replicate a strangeness in my code

[18:33] <geoffb> ?eval my $foo = [1, 4, 9]; say $foo[0]; $foo[0] += 10; $foo[0];

[18:33] <evalbot6> 1 \11 

[18:34] <geoffb> ?eval my $foo = {bar => [1, 4, 9]}; say $foo<bar>[0]; $foo<bar>[0] += 10; $foo<bar>[0];

[18:34] <evalbot6> 1 Error: Can't modify constant item: VInt 1 

[18:34] <geoffb> Aha!

[18:34] <geoffb> Caught you, you bastard

[18:34] <geoffb> ?eval my $foo = {bar => [1, 4, 9]}; say $foo<bar>[1]; $foo<bar>[1] += 10; $foo<bar>[1];

[18:34] <evalbot6>  Error: Can't modify constant item: VUndef 

[18:34] <geoffb> urp?

[18:35] <geoffb> ?eval my $foo = {bar => [1, 4, 9]}; say $foo.perl; say $foo<bar>[1]; $foo<bar>[1] += 10; $foo<bar>[1];

[18:35] <evalbot6> {('4' => 9), ('bar' => 1)}  Error: Can't modify constant item: VUndef 

[18:35] <geoffb> wah?

[18:35] <geoffb> ?eval my $foo = (bar => [1, 4, 9]); say $foo.perl; say $foo<bar>[1]; $foo<bar>[1] += 10; $foo<bar>[1];

[18:35] <evalbot6> ('bar' => [1, 4, 9]) 4 \14 

[18:35] <coral> Limbic: "skills development"

[18:36] <geoffb> coral: ?

[18:36] <geoffb> ?eval my $foo = {bar => [1, 4, 9],}; say $foo.perl; say $foo<bar>[1]; $foo<bar>[1] += 10; $foo<bar>[1];

[18:36] <evalbot6> {('bar' => (1, 4, 9))} 4 Error: Can't modify constant item: VInt 4 

[18:36] <Limbic_Region> coral ?

[18:37] * geoffb fervently hopes that hash parsing wierdness is a pugs issue and not a design misfeature

[18:38] <geoffb> ?eval my $foo = {bar => [1, 4, 9], baz => 6}; say $foo.perl; say $foo<bar>[1]; $foo<bar>[1] += 10; $foo<bar>[1];

[18:38] <evalbot6> {('bar' => (1, 4, 9)), ('baz' => 6)} 4 Error: Can't modify constant item: VInt 4 

[18:39] <geoffb> ?eval my $foo = {bar => [1, 4, 9], baz => 6}; say $foo.perl; say $foo<baz>; $foo<baz> += 10; $foo<baz>;

[18:39] <evalbot6> {('bar' => (1, 4, 9)), ('baz' => 6)} 6 \16 

[18:41] * geoffb considers his options:

[18:41] <geoffb> 1. Bang head against wall until bloody

[18:41] <geoffb> 2. Go crazy and get a visit from the nice men carrying a white coat with long sleeves

[18:41] <geoffb> 3. Table current several projects and actually get around to learning Haskell

[18:42] <geoffb> Dammit, this isn't an easy decision

[18:42] <PerlJam> Learning Haskell has some side benefits.  you should choose option #3

[18:43] <iblech> geoffb: FYI, your last two ?evals work fine in PIL2JS :)

[18:43] <geoffb> sigh, you're probably right

[18:43] <Limbic_Region> geoffb - you could add an option 4 (which is what I have decided to do)

[18:43] <Limbic_Region> take a break

[18:43] <Limbic_Region> http://use.perl.org/~Limbic%20Region/journal/25807

[18:43] <gaal> okay, the build system thing - lumi cause me to think about it a bit

[18:44] <gaal> which is good

[18:44] <gaal> because i realized that it sucks

[18:44] <gaal> s/cause/caused/

[18:44] <gaal> it doesn't suck badly

[18:44] <gaal> but it does suck somewhat.

[18:44] <geoffb> iblech, sure, but I have some very cool things I'd like to do in the pugs world that A) require Perl 5 embedding right now, and B) were making me happy to think about doing *soon*

[18:44] <geoffb> gaal, fair enough

[18:45] <gaal> here's the deal

[18:45] <gaal> it has two purposes:

[18:45] <gaal> 1. factor out duplicate lines in Makefile.PL

[18:45] <gaal> 2. centralize config options

[18:45] <gaal> (making it possible to put your personal prefs in a file)

[18:46] <gaal> (and override them temporarily from env)

[18:46] <gaal> so, #2 achived.

[18:46] <gaal> problems is, i removed about 20 lines from Makefile.PL

[18:46] <gaal> by adding about 200 elsewhere :)

[18:46] <geoffb> I've shelved some of my makefile tweaks in the hope that your stuff would do #1, to make my changes easier

[18:46] <stevan> iblech: ping

[18:47] <iblech> stevan: pong

[18:47] <stevan> iblech: re: submethods

[18:47] <geoffb> gall, Well, just not having 20 different variations on ghc's command line params would be nice . . . 

[18:47] <gaal> so maybe i'll ci this and let y'all try and see if you like it?

[18:47] <geoffb> gaal, That's the Pugs Way.

[18:47] <stevan> yes, what larry said was that if you call the submethod bypassing the dispatch table, then all bets are off

[18:48] <stevan> see Perl6::SubMethod::force_call 

[18:48] <gaal> just have to add a little dep on the config file so that editing it then running make triggers a rebuild.

[18:48] <iblech> stevan: ah, ok then

[18:49] <geoffb> gaal, cool

[18:49] <stevan> iblech: it is not the idea solution, but it works for BUILDALL DESTROYALL, and I punted on the other details

[18:50] <stevan> mostly because I dont have proper packages in the prototype

[18:50] <stevan> iblech: also, i will be updating the Perl6.MetaModel (JS) more this weekend, but it is not yet complete enough for integration

[18:51] <stevan> I still need to figure out how to do Perl6.Object

[18:51] <stevan> and Perl6.Class

[18:51] <stevan> basically, JS does not have AUTOLOAD

[18:51] <stevan> which is the crux of how I deal with method dispatching

[18:53] <iblech> Hm... we could emit .dispatch("subname")() instead of .subname(), then .dispatch can deal with AUTOLOAD appropriately

[18:53] <stevan> iblech: that would work

[18:53] <stevan> or I can try to pre-populate the prototype of the generated class

[18:54] <iblech> Ah, basically AUTOLOAD at compile-time :)

[18:55] <stevan> yes

[18:55] <stevan> bloated, but it would work

[18:55] <stevan> however, It would make classes closed

[18:55] <stevan> unless I wrapped .meta.add_method to add into the class as well

[18:55] <stevan> but then I would have to handle all classes

[18:55] <iblech> Hm... couldn't you extend the prototype at runtime, if necessary?

[18:56] <stevan> yuk

[18:56] <stevan> iblech: yes, but say I add to Perl6.Object, I need to mess with every prototype in the system

[18:56] <stevan> because I am not using the prototpyes for inheritance

[18:56] <stevan> I am doing it on my own

[18:56] <iblech> Ah..., ok

[18:56] <stevan> oh, wait

[18:57] <stevan> Object.watch might do what we need

[18:57] <stevan> I am investigating right now

[18:57] <iblech> Object.watch?

[18:58] <iblech> Ah!

[19:01] <coral> Limbic: pugs at work. skills development.

[19:02] <Limbic_Region> coral - that's an extreme stretch given that I am not a programmer by trade

[19:02] <geoffb> Limbic_Region, what is your trade then?

[19:03] <Limbic_Region> geoffb - well, since working as a government employee I don't really do much of anything

[19:03] <geoffb> *chuckle*

[19:03] <geoffb> Besides that, silly man

[19:03] <Limbic_Region> but my previous job titles included "Systems Engineer"

[19:04] <geoffb> I can definitively say (having hired several "system engineers") that programming is Most Definitely skills development

[19:04] <Limbic_Region> basically - I design solutions to problems which may involve hw, sw, networks, etc

[19:04] <Limbic_Region> right - but as I said, I am not a systems engineer anymore

[19:05] <geoffb> It stretches the brain in a way that makes for much better solutions.

[19:05] <geoffb> so what does the government think you do, how about that phrasing?

[19:05] <stevan> iblech: I don't think Object.watch will do what we need 

[19:06] <Limbic_Region> geoffb - I review documentation, sit on an engineering review board to render decisions - um - hard to say

[19:06] <stevan> Limbic_Region: that sounds like *gasp* management??

[19:07] <Limbic_Region> our IT staff consists of 2 people - myself and a network goon - everything else is contracted out

[19:07] <geoffb> yikes

[19:07] <Limbic_Region> stevan - nope, not people mgmt nor project mgmt - just decisions on if a particular approach meets the contractual requirements

[19:08] <stevan> Limbic_Region: suuuuurrreeee :)

[19:08] * Limbic_Region does get to code some perl sometimes when data needs to get converted from 1 format to another in a hurry

[19:08] <Limbic_Region> go figure

[19:09] <stevan> iblech: I have to do $work now, but I will be doing some MetaModel stuff more tonight (approx 5-6 hours from now)

[19:10] <geoffb> apt-get install hugs # The adventure begins . . .

[19:21] <geoffb> <newbie_mode>Does Haskell have a way to combine multiple lines into one?  (as with ; in Perl)

[19:22] <gaal> ; ? you mean \ ?

[19:22] <gaal> geoffb, one function application?

[19:23] <geoffb> No, I meant I want to be able to do a pile of definitions on one line, like the custom when feeding evalbot6.  These tutorials all show prettyprinted files, and I'm a one-liner guy

[19:23] <gaal> ahhh, you want non-layout

[19:23] <gaal> { a ; b ; c }

[19:23] <gaal> you need the braces too

[19:23] <geoffb> ok, /me tries that . . . 

[19:25] <geoffb> Hmm, hugs doesn't seem to like that

[19:25] <geoffb> bah, ok, food has arrived

[19:25] <geoffb> &

[19:50] <kolibrie> hmm, larry is rewriting method and attribute syntax

[19:51] <geoffb> o_O

[19:51] <geoffb> Link, kolibrie ?

[19:52] <iblech> stevan: re. Great :)

[19:52] <iblech> geoffb: http://www.nntp.perl.org/group/perl.perl6.language/22404

[19:57] <kolibrie> iblech: thanks for providing the link

[19:57] <svnbot6> r5735, fglock++ | * Added a "Set::Symbols" role that implements unicode

[19:57] <svnbot6> r5735, fglock++ |   operators in Span.pm and Recurrence.pm (it could be

[19:57] <svnbot6> r5735, fglock++ |   used in Set.pm too)

[19:57] <kolibrie> geoffb: sorry, I was on the phone

[19:58] <geoffb> kolibrie, oh, no prob.

[19:58] <geoffb> Interesting -- so now convention becomes authoritative

[19:59] <geoffb> er, wrong word there

[19:59] <geoffb> "becomes binding"?

[20:18] <svnbot6> r5736, fglock++ | * svn properties

[21:31] <Khisanth> hmm why not just method foo is private ... ?

[21:33] <geoffb> .oO( He wants two uses for the same thing (_ == privacy) so that people don't complain about it being a singleton concept in the language? )

[21:35] *** Maddingue__ is now known as Maddingue

[21:38] <iblech> Night all :)

[21:38] <svnbot6> r5737, iblech++ | PIL2JS:

[21:38] <svnbot6> r5737, iblech++ | * Added some new primitives and fixed some bugs.

[21:38] <svnbot6> r5737, iblech++ | * Refactored &run_pugs, run_pil2js, etc. into separate module lib/PIL2JS.pm.

[21:38] <svnbot6> r5737, iblech++ | * runjs.pl automatically precompiles the Prelude now, if needed.

[21:38] <svnbot6> r5737, iblech++ | * Test.pm is now precompiled, too. Now tests using Test.pm compile and run

[21:38] <svnbot6> r5737, iblech++ |   with a satisfactoring speed -- if s/use Test//:

[21:38] <svnbot6> r5737, iblech++ |   "use Test" still loads and compiles Test.pm -- bad. BEGIN {

[21:38] <svnbot6> r5737, iblech++ |   %*INC{"Test.pm"}++ } would work, but: pugs -E "BEGIN {...}" t/.../foo.t does

[21:38] <svnbot6> r5737, iblech++ |   (of course) not work...

[22:18] <ocarina> greetings

[22:19] <ocarina> autrijus, i'm reading the interview chromatic made you at perl.com... pretty cool :)

[22:19] *** ocarina is now known as Excalibor

[22:29] <geoffb> OK, end of _Haskell Tutorial for C Programmers_, time for a break before _Tour of the Haskell Syntax_

[22:34] <Excalibor> geoffb, :)

[22:37] * Excalibor still reading _Functional Programmin with Haskell_ :-P

[22:40] <geoffb> I'm trying to keep my partially-read book stack small, but I'm pretending that online tutorials do not constitute pushing onto that stack

[22:43] <Excalibor> geoffb, yeah, keep lieing to yourself... ;)

[22:44] <geoffb> yep, it's completely OK that I'm several levels deep in Haskell and Forth tutorials because of harrorth.  Damn nothingmuch++.  :-)

[22:47] <Khisanth> you can't damn someone while increasing their karma!

[22:49] <geoffb> Certainly you can.  "Damn you for being right" makes total sense to me.  Besides, damnation and karma aren't on the same vector, though they have non-zero dot product.

[22:49] <geoffb> Oh dear, I'm losing my mind.

[22:51] <Khisanth> since we are damning things I would like to damn wikipedia :)

[22:51] <geoffb> For managing to replicate the whole surfing-off-into-the-sunset problem of the web as a whole, all in just one site?

[22:53] <Excalibor> geoffb, haha only serious?

[22:54] <geoffb> nodnod

[22:54] <Excalibor> well... time for bed to me

[22:55] <geoffb> g'night

[22:55] <Excalibor> take care... thx

[22:56] <Excalibor> gotta keep trying to understand those monads in pugs, though... some IO module in mind, no way to do w/o them though, lol

[22:56] <Excalibor> i'll keep studying :)

[22:56] <Excalibor> laters!

[23:00] <szabgab> ?eval "gabor" ~ " szabo"

[23:00] <evalbot6> 'gabor szabo' 

[23:00] <szabgab> (gaal here showing off safe mode)

[23:01] <szabgab> ?eval open "/etc/passwd"

[23:01] <evalbot6> Error: No compatible subroutine found: "&Pugs::Internals::openFile" 

[23:02] <Khisanth> geoffb: neither

[23:02] <geoffb> neither?

[23:02] * geoffb can't remember having asked a disjunction

[23:02] <Khisanth> oops "no" :)

[23:03] <geoffb> So why *are* you damning wikipedia?

[23:03] <Khisanth> because I read something on it before and now I can't recall the name!

[23:03] <geoffb> heh

[23:04] <geoffb> ?eval use perl5:Cwd; cwd

[23:04] <evalbot6> pugs: *** No compatible subroutine found: "&require_perl5"     at src/perl6/Prelude.pm line 110, column 30-59 

[23:04] <Khisanth> ah http://en.wikipedia.org/wiki/Programming_paradigm should lead me to the right place :)

[23:10] <geoffb> Cute: [10,9..1] in Haskell

[23:12] <wolverian> ?eval 3..1

[23:12] <evalbot6> () 

[23:12] <wolverian> :(

[23:17] <Khisanth> geoffb: why is that cute?

[23:18] <Khisanth> [10,8..1] is even nicer :)

[23:19] <Khisanth> hmm

[23:19] <Khisanth> ?eval 3..1:by(-1)

[23:19] <evalbot6> Error:  unexpected ":" expecting digit, fraction, exponent, term postfix, operator, "does", "but", "is", "^..^", "cmp", "<=>", "^..", "..^", "..", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[23:19] <geoffb> OK, so I hadn't come up with the most powerful example.  I just meant the idea of determining the step by showing two in series, rather than some "by" syntax, is a cool idea

[23:20] <Khisanth> bah, do both for the sake of TIMTOWTDI! :)

[23:20] <geoffb> well, yes, there is that

[23:21] <Khisanth> I see nothing particularly wrong with :by though

[23:21] <geoffb> OK, this is beginning to bug me, and the tutorials so far have not cleared this up.  Is there either A) a base type that unifies with every other type, or B) a data structure in Haskell that is variable-length like a list and contains differently-typed contents, like a tuple?

[23:21] <Khisanth> [10..] :)

[23:22] <Khisanth> heh a list of tuples? :P

[23:23] <geoffb> Hmmm, doesn't seem to work.

[23:23] <geoffb> "Cannot infer instance"

[23:23] <geoffb> So I guess that kills A as a likely possibility, or it would have Just Worked

[23:24] <Khisanth> heh I think I had/have the same problem

[23:24] <geoffb> I was appalled to see the definition of Eq on tuples, with only tuples of length 1 to 10 or so defined

[23:25] <geoffb> For a language that prides itself on flexible typing, that's just odd

[23:29] <Khisanth> isn't zip only define for up to 3 lists? :)

[23:29] <geoffb> That's just wrong.

[23:30] <geoffb> "Language designers should be forced to pass language ideas past the average 5 year old . . . "

[23:31] <Khisanth> geoffb: although I seem to recall autrijus writing a oneliner that does the same as zip but works for an arbitrary number of lists :)

[23:31] <nothingmuch> seen ingy

[23:31] <jabbot> nothingmuch: ingy was seen 2 days 6 hours 31 minutes 5 seconds ago

[23:31] <nothingmuch> blast

[23:31] <nothingmuch> thunder

[23:32] <geoffb> Khisanth, yeah, for a list of lists . . . but what about an arbitary length tuple of lists?

[23:36] <ingy> nothingmuch: whuh?

[23:47] <geoffb> _Tour of the Haskell Syntax_ down . . . next!

