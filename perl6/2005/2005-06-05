[00:02] <Alias_> Hi folks

[00:02] <Juerd> Hello, :=

[00:02] <Alias_> Anyone know where I can find the docs for the 'as' function

[00:02] * Alias_ is debating turning Params::Coerce into a more general as.pm P5 module

[00:02] <Juerd> No, but should you find it, let me know :)

[00:02] <Alias_> I'd like not to cause terminology clashes withy P6

[00:03] <Alias_> Juerd: Well... there's something already that lets you define a Foo as Bar type thing

[00:03] <Alias_> right?

[00:03] <Juerd> There are IIRC $object.as(SomeClass) for explicit coersing

[00:03] <Alias_> that's it

[00:03] <Alias_> hmmm

[00:03] <Juerd> And as(format, LIST) to replate sprintf

[00:03] <Alias_> Where is that documented?

[00:03] <Juerd> And there is a postfix as that joins is and but, that does the same thing

[00:04] <Juerd> Alias_: p6l

[00:04] <Alias_> So not in the docs?

[00:04] <Juerd> nafaik

[00:04] <Alias_> ok then...

[00:04] <Alias_> hmm

[00:04] <Alias_> use as something => 'method';

[00:05] <Alias_> use as something => sub () { };

[00:05] <Alias_> use as something => \&function;

[00:05] <Alias_> look good to you?

[00:05] <Juerd> No

[00:05] <Juerd> Looks perl5ish.

[00:05] <Alias_> Well, this is a Perl5 as.pm

[00:05] <Juerd> I don't know what as.pm does, but this syntactic sugar is very perl6 ish

[00:06] <Juerd> Realise for example that => now creates a pair

[00:06] <Alias_> as.pm doesn't do anything in P5 now, it doesn't exist

[00:06] <Alias_> Apparently I'm the only person doing coercion

[00:07] <Alias_> A pair may well still be appropriate in that case

[00:08] <Juerd> Yes, but "as" reads like a prefix

[00:08] <Juerd> "use as $pair"

[00:08] <Juerd> That should make sense as well as the literal pair, for this syntax to look good to me.

[00:08] <Alias_> fair nuff

[00:08] <Alias_> But then we have a syntax for P6 already

[00:09] <Alias_> And it's some sort of multi-method declaration

[00:09] <Juerd> "use foo as bar" makes more sense, and this really makes me wonder if you should use a "pragma" for this. We have better syntactic sugar through macros now.

[00:09] <Juerd> Again, I have no idea what this as.pm should do

[00:09] <Alias_> Well, provide a declaration point for coercion in P5

[00:09] <Alias_> maybe asa, instead

[00:10] <Alias_> Task on UNIVERSAL::asa :)

[00:10] <Alias_> s/Task/Tack/

[00:10] <Alias_> That would be even more Perl5ish

[00:10] <Juerd> It's really unclear to me.

[00:10] <Alias_> $Object->isa(Foo)

[00:10] <Alias_> $Object->asa(Foo)

[00:10] <Alias_> etc etc

[00:11] <Juerd> is this "can coerce to Foo"?

[00:11] <Alias_> yes

[00:11] <Juerd> That's does

[00:11] <Alias_> See Param::Coerce for my existing implementation

[00:11] <Alias_> sorry/

[00:11] <Juerd> And whether it coerces or just fakes it, shouldn't be relevant, should it?

[00:11] <Alias_> hmm... possibly

[00:11] <Juerd> (Same reason why you use isa, not ref, in p5)

[00:12] <Alias_> Depends if you want something that obeys an API, or you want the ACTUAL is

[00:12] <Juerd> afk

[00:12] <Alias_> ok

[00:12] <luqui> I think ACTUAL is should be hard

[00:12] <luqui> and obeys API should be easy

[00:13] <Alias_> luqui: The big difference is that it might not be trivial to get the ->as thing...

[00:13] <Alias_> You might need to create a whole new object

[00:13] <Alias_> And doing that per-method call could be bad

[00:13] <Juerd> Alias_: $foo as Str

[00:13] <Juerd> (~$foo)

[00:14] <Alias_> The trivial ones are trivial, yes :)

[00:14] <Juerd> I don't know if that clones.

[00:14] <Alias_> That's hard too

[00:14] <Alias_> To clone or not to clone is a bitch

[00:14] <Juerd> Yes, because if you don't clone, you mutate, and that may cause action at great distance

[00:15] <Alias_> Although there could be clues if you wanted the as thing to be rw or ro

[00:15] <Juerd> At least with IOKs NOKs and POKs you know what you can expect ;)

[00:15] <Alias_> But then that's got other issues

[00:15] <Alias_> anyways

[00:15] <Alias_> back to work

[02:11] * Juerd wonders if autrijus has stopped writing journals altogether

[02:12] <Alias_> You mean other than the daily summary?

[02:29] <ingy> seen autrijus 

[02:29] <jabbot> ingy: autrijus was seen 18 hours 2 minutes 29 seconds ago

[02:35] <Arathorn> presumably post-release fatigue

[03:16] <svnbot6> r4385, ingy++ | ingy the human spelling/grammar checker

[03:16] <Alias_> heh

[03:17] <PerlJam> Arathorn: or he could have been hit by a truck.

[03:17] <PerlJam> (pugs' truck-number is 1 I think as autrijus *is* the momentum of the project)

[03:28] <Alias_> Hey ingy, any news in the last month of Kwiki::Publish related work?

[03:34] <gaal> hola!

[03:40] <Darren_Duncan> hola

[03:41] <ingy> hola

[03:41] <ingy> Alias_: :p

[03:41] <Alias_> Tell me that's a yes :)

[03:43] <Darren_Duncan> if I remember right, there'll be a hackathon in about a week in Europe

[03:44] <Darren_Duncan> so it probably makes sense to me that 6.2.7 will go out just before that, and perhaps 6.2.8 soon after

[03:45] <Darren_Duncan> likewise just bounding the larger one in Toronto

[03:46] <Darren_Duncan> in any event, I plan to revisit Locale-KeyedText in a day or two, or today, and try to get *all* of the tests to pass before the Europe hackathon

[03:46] <Darren_Duncan> likewise for SQL-Routine prior to the Toronto hackathon

[03:46] <Darren_Duncan> fyi

[04:13] *** batdog|gone is now known as batdog

[04:35] *** theorbtw2 is now known as theorbtwo

[04:46] <autrijus> er, I'm alive.

[04:46] <autrijus> I'm just, like, working on the paper and other preflight -- literally -- things

[04:48] <theorbtwo> autrijus: I'm dropping castaway off at a flight soon...

[04:48] <theorbtwo> When is yours?

[04:48] <theorbtwo> IIRC there's not going to be much connectivity at the Vienna hackathon?

[04:49] <autrijus> the vienna hackathon will be at Leo's no?

[04:49] <autrijus> which means ISDN

[04:49] <autrijus> I think there's also network around the conference

[04:49] <autrijus> my flight is some 60 hours from now

[04:49] <Alias_> autrijus: You know what happened to Dan?

[04:49] <theorbtwo> Oh.

[04:49] <Alias_> out of curiosity...

[04:49] <autrijus> what happened to Dan?

[04:49] <Alias_> He quit parrot...

[04:50] <autrijus> oh. Leo changed his design and things.

[04:50] <Alias_> ah

[04:50] <Alias_> so subsystem wars?

[04:50] <autrijus> and communication problems, yeah

[04:51] <autrijus> mm he's not in #parrot anymore

[04:51] <autrijus> so probably quitted for real

[04:51] <Alias_> it's on his Parrot blog

[04:52] <autrijus> reading

[04:52] <Alias_> little information

[04:53] <autrijus> hmm he thinks only Larry remains of the original Perl 6 team.

[04:53] <autrijus> Schwern is still around -- kind of

[04:53] <Alias_> He had to get a job or something

[04:54] <Alias_> I tried to find a project for him, but $client pulled out.

[04:54] <autrijus> aw.

[04:55] <Alias_> So I imagine he's doing whatever work he could find

[04:55] <autrijus> k.

[04:55] <autrijus> blah.

[04:56] <autrijus> I'm now _really_ glad that I'm not involved with the cabal whatsoever :)

[04:56] <Alias_> Still... it's a bit annoying seeing Perl 6 wandering off in the cabal's personally prefered direction

[04:57] <autrijus> hm?

[04:57] * Alias_ doesn't like several parts of Perl 6 :)

[04:57] <autrijus> not sure  what you mean

[04:57] <Alias_> For starters, attribute addition

[04:58] * Alias_ is not a huge fan of attributes... It's never caused a problem for me to not have them

[04:58] <Alias_> Except now I can't dictate the order in which my constructors get called

[04:59] <autrijus> uh p5 has attributes.

[04:59] <autrijus> not sure how it relates to constructor order though.

[04:59] <Alias_> As an optional extra

[04:59] <Alias_> Oh, when you have attributes and so on, there seems to be a natural progression to having to have constructor automation

[04:59] <gaal> hey autrijus, welcome back. how do i cause a fail to raise an exception from Prim.Eval? :)

[04:59] <Alias_> And thus, defining one true way to do constructors

[05:01] <gaal> (see the FIXME on line 82)

[05:04] <autrijus> Alias_: you mean BUILD and BUILDALL?

[05:04] * Alias_ shudders

[05:04] <autrijus> there's a well-defined order but you can override it freely, I think

[05:04] <Alias_> I hope so

[05:05] <autrijus> er, it works in pugs

[05:05] <autrijus> you can see it in action :)

[05:05] * gaal goes to $work - will backlog. &

[05:05] <autrijus> gaal: fail"" will throw exception no?

[05:05] <Alias_> I was extremely handy to be able to either call superclass first, and do additional init, or be able to get in BEFORE the super and modify the constructor params before passing through, or both

[05:05] <Alias_> Not to mention BUILD is a horrible name :)

[05:06] <autrijus> Alias_: er sure... by definition your own "new" you still have exact control

[05:06] <Alias_> I thought we couldn't do that because the autoconstructy stuff had to run properly

[05:10] * Alias_ throws further problems aside till he gets the chance to play for real

[05:10] <Alias_> Wish I had a good reason to use P6

[05:10] <Alias_> ;)

[05:10] <autrijus> :)

[05:10] <autrijus> all that changes is there's a minimal implementation of UNIVERSAL::new.

[05:11] <Alias_> hrm...

[05:11] <Alias_> ok

[05:11] <Alias_> BTW, I've finally gotten sick and tired of others talking about JSAN and not going

[05:11] <autrijus> JSAN?

[05:11] <autrijus> CPAN?

[05:11] <Alias_> JavaScript CPAN

[05:11] <Alias_> http://ali.as/devel/PSJS/

[05:11] <Alias_> http://ali.as/devel/PNJS/

[05:12] <nothingmuch> morning

[05:12] <Alias_> So I've started it myself

[05:12] <autrijus> oh cool... I think. where do I upload?

[05:12] <Alias_> You don't yet :)

[05:12] <Alias_> There's some missing pieces still

[05:13] <autrijus> oh. well. :)

[05:13] <Alias_> Need to get stuff like base.pm ported over

[05:13] <QtPlatypus> Shouldn't that be CJAN?

[05:13] <Aankhen``> Yeah...

[05:13] <autrijus> that'd be Java ;)

[05:13] <Alias_> QtPlatypus: The term being throw around the net has been JSAN

[05:13] <Alias_> thrown

[05:13] <Aankhen``> JavaScript Comprehensive Perl Archive Network? :-S

[05:14] <autrijus> JEAN for ecma maybe

[05:14] <Aankhen``> Oh, sorry, I read it wrong.

[05:14] <Aankhen``> JavaScript Archive Network, hmm?

[05:14] <Alias_> Mine is still PNJS for just "Phase N JavaScript"...

[05:14] <autrijus> hm, that'd be CEAN

[05:14] <Alias_> ECMAPAN

[05:14] <Alias_> CECMAAN

[05:15] <Alias_> erk

[05:15] <Alias_> ECMASAN ...

[05:15] * Aankhen`` stares in fascination at Alias_.

[05:15] * Alias_ blushes

[05:16] <Alias_> autrijus: Anyways, two main issues to resolve, being some class creation helper stuff, and how to not have one giant tree, then I'll open it for business

[05:16] <Alias_> Oh, and the JavaScript::Pod parser

[05:16] * Alias_ couldn't resist the combination of POD and JavaScript

[05:28] <svnbot6> r4386, autrijus++ | * Pugs's contributions; PGE and PAST

[05:32] <nothingmuch> what's PAST?

[05:32] <Aankhen``> Parrot AST? :-D

[05:33] <nothingmuch> uh, ok =)

[05:33] <autrijus> yup.

[05:33] <Aankhen``> ^_^

[05:33] * Aankhen`` BBL.

[05:33] <Aankhen``> &

[05:33] <nothingmuch> ciao

[05:34] *** batdog is now known as batdog|gone

[05:36] <Darren_Duncan> just got back ... re the conversation an hour ago ...

[05:36] <Darren_Duncan> sorry to hear about Dan

[05:37] <Darren_Duncan> for some reason I thought all those people were a big happy yadayada and not that there were problems (other than having bread money)

[05:38] <Darren_Duncan> I'd hate for the group to become disfunctional

[05:38] <svnbot6> r4387, autrijus++ | * minor reorg of paragraph

[05:38] <autrijus> indeed.

[05:44] <autrijus> however my brain is feeling quite dysfunctional

[05:44] *** batdog|gone is now known as batdog

[05:45] <autrijus> writing English is definitely not my forte

[05:48] <Alias_> How about speaking?

[05:48] <autrijus> I can manage but not either

[05:49] <Alias_> If your code wasn't so twisty sometimes, it probably wouldn't matter so much :)

[05:50] <Alias_> not bad, just very "advanced"

[05:50] <Alias_> I speak here of M:I :)

[05:50] <autrijus> :)

[05:50] <gaal|work> heyagain. autrijus, no, fail does not raise an exception - you can comment out the trace in Pugs.Prim.Eval ~ 80ish and see (eg "use" a nonsense file)

[05:50] <autrijus> gaal: it just silently fails?

[05:50] <gaal|work> yes

[05:51] <autrijus> gaal: do you want the failure to be trappable?

[05:51] <gaal|work> that block is entered all right

[05:51] <autrijus> i.e. inside eval""

[05:51] <autrijus> try simply return a VError?

[05:51] <gaal|work> hmm, it's for evals which have the EvalErrorFatal style

[05:51] <gaal|work> (your suggested refactorings are in)

[05:51] <gaal|work> okay, that's an idea :)

[05:52] <autrijus> if you want to force failure, ioError

[05:52] <gaal|work> also: how do i get a VCode from an env? without looking up $&SUB

[05:52] <autrijus> ioError :: IOError -> IO a

[05:52] <autrijus> you want to what?

[05:52] <autrijus> what VCode?

[05:53] <autrijus> liftIO $ fail "this will always fail"

[05:53] <autrijus> is the way to raise ioError

[05:53] <gaal|work> sorry, different subject. in doing caller, i want the subname etc., not just the line and filename.

[05:53] <autrijus> you can read $?SUBNAME

[05:53] <gaal|work> i will try the ioError thingie.

[05:53] <autrijus> if you want more things, you need &?SUB.

[05:54] <gaal|work> okay, i was sorta under the impression i should be able to do it without going throuh symbols

[05:55] <ingy> autrijus: working on a little surprise for pugs dev

[05:55] <autrijus> when we switch to CC_2CPST we'll have that sort of introspection.

[05:55] <autrijus> ingy: oooh

[05:56] <ingy> hopefully it will be of use

[05:56] <autrijus> gaal: the current reductino has no notion of tree position

[05:56] <gaal|work> all right, i'll go that way for now. we can always refactor.

[05:56] <gaal|work> thanks.

[05:56] <autrijus> gaal: the plan is to switch the Eval monad to a ZipperD that can remember where in the entire envExp we are

[05:56] <autrijus> np :)

[05:56] <autrijus> gaal++

[05:57] <ingy> anyone know how to redirect STDOUT or STDERR to a string at runtime?

[05:57] <gaal|work> in p5?

[05:57] <ingy> nod

[05:57] <gaal|work> Test::Output has some nifty code to lift

[05:57] <autrijus> $*OUT = open(...)

[05:57] <Alias_> ingo: overwrite it with a IO::Scalar

[05:57] <Alias_> oh wait, wrong channel

[05:57] <Alias_> :/

[05:58] * Alias_ wanders off

[05:58] <autrijus> it's actually the right channel.

[05:58] <autrijus> $*OUT = open('>', $scalar); # ought to do that, but not yet implemented

[05:58] <ingy> autrijus: perl*5*

[05:58] <autrijus> it's a matter of implementing the IHandle class 

[05:58] <gaal|work> autrijus, prolly not!

[05:58] <autrijus> ingy: oh. heh.

[05:59] <gaal|work> hmm

[05:59] <autrijus> you can tie STDOUT. easiest that way

[05:59] <ingy> thanks

[05:59] <gaal|work> well or maybe yes

[05:59] <autrijus> np :)

[05:59] <gaal|work> but the open will be spelled differently

[06:03] <autrijus> *nod*

[06:03] <Darren_Duncan> I plan to continue hacking LKT tomorrow or monday, to get all the tests working ... see y'all then

[06:03] <Darren_Duncan> meanwhile, its perl 5 for me

[06:05] <autrijus> cool. see ya!

[06:07] <Darren_Duncan> fyi, the last thing I was trying to do during my commit last week was explicitly return a hash reference from a function, and not a list; I never figured out yet how to get that working

[06:08] <Darren_Duncan> at least, no matter what I did in the function that returned the value, calling .ref() on the result always returned List and not Hash, what I wanted

[06:08] <svnbot6> r4388, autrijus++ | * fixes from obra's review

[06:08] <svnbot6> r4389, eric256++ | Apparently this commit didn't stick last time so i'm trying agian.  Unit module start. Not much here yet

[06:08] <eric256> autrijus any ideas when overloading with class's in the signature should work?

[06:09] <Darren_Duncan> anyway, I'll bring this up again next day if necessary

[06:09] <Darren_Duncan> good night

[06:10] <autrijus> overloading as in overloading operators?

[06:11] <autrijus> multi sub &infix:<+> (Unit $x, Unit $y) { .. .} 

[06:11] <autrijus> it should work -- Set.pm uses that

[06:11] <autrijus> hey chromatic. I managed to finish the non-haskell part of my paper!

[06:11] <eric256> i've heard that before. but when we investigated it looked like that part of Set.pm wasn't actualy working, and the OO tests for it where marked as todo...unless that changed since last night

[06:12] <chromatic> Excellent.  Did you check it in?

[06:12] <autrijus> chromatic: yes. I'd appreciate a sanity check because I had no first-hand knowledge.

[06:13] <chromatic> Alright, I'm looking through that as I'm waiting for my compile to fail.

[06:13] <chromatic> http://sial.org/pbot/10701

[06:13] <chromatic> :)

[06:13] <autrijus> chromatic: it's in docs/talks/hw2005.txt

[06:13] <chromatic> Hm, there was/is an attempt in Parrot's languages/perl6.  It's on its second or so version right now.

[06:14] <autrijus> chromatic: er, this is about which sentence?

[06:14] <chromatic> The problem was three-fold.  First, there were very few people working on it.  Second, it's really hard to write parsers for Perl 6 with any sort of performance.  Third, Parrot wasn't very mature.

[06:14] <chromatic> First paragraph, final sentence.  I think my comments are semantic quibbles though.

[06:14] <autrijus> (I gave a treatment of P6C in the "related work" thing)

[06:15] <autrijus> better wording than "materialise" welcome :)

[06:15] <chromatic> "flourish"?

[06:15] <autrijus> eric256: it wasn't? ext/Set/t/overload.t worksforme

[06:15] <autrijus> "take off" perhaps/

[06:15] <autrijus> ?

[06:15] <eric256> i'm updating right now and i will check it agian

[06:16] <autrijus> chromatic: er, hey, $?SELF

[06:17] <chromatic> In the sentence about the unusual execution model, my understanding of the current understanding of the plan is that the parser and compiler will be overridable in Perl 6, sort of like how you can rewrite the VM in Smalltalk... if you really want to.

[06:17] <autrijus> chromatic: I think you can take (Val (argValue $ head bound))

[06:17] <chromatic> I mean GC.

[06:17] <autrijus> to be the invocant.

[06:17] <chromatic> I'll try that, thanks.

[06:18] <autrijus> "to be overridable in Perl 6"

[06:18] <autrijus> how is it different from my "implemented as a Perl 6 program"?

[06:18] <chromatic> There's some doubt that it will actually be Perl 6 code.

[06:19] <chromatic> Think CPerl not Perl.

[06:19] <autrijus> I cannot easily think how you can override a nonperl6 compiler with perl 6 code.

[06:19] <autrijus> unless the said compiler embed perl6

[06:19] <chromatic> You can override built-in functions of Perl 5 with Perl 5 code, even though PP code is C.

[06:21] <autrijus> I fail to understand.

[06:21] <chromatic> Look things up by name and swap names or look things up by pointers in vtables and swap vtables.

[06:21] <autrijus> this is maybe confusing Perl 6 the self-hosting language

[06:22] <chromatic> Just don't always jump to memory addresses!

[06:22] <autrijus> with something that is more like Perl 5 where the compiler and runtime are the same thing.

[06:22] <autrijus> or is the plan no longer for Perl 6 to be self-hosting?

[06:22] <autrijus> if so that is not yet well-known :)

[06:23] <chromatic> The plan is for Perl 6 to be able to be self-hosting.

[06:23] <chromatic> That does not change.

[06:23] <chromatic> The pragmatic is that the lowest-level parser may not actually be self-hosting Perl 6 rules.

[06:24] <autrijus> say I'd like to port perl 6 to llvm.

[06:24] <chromatic> I can hook you up with $4500 if you do!

[06:24] <autrijus> the procedure to do that is very differnt for a self-hosting language

[06:24] <autrijus> and a language that depends on some other language for compilation.

[06:25] <chromatic> Okay, I will try to be clearer.

[06:25] <chromatic> Yep, self-hosting is a goal and a plan.

[06:25] <chromatic> The default implementation may cheat by not self-hosting until you override that.

[06:25] <chromatic> That's a *may*.

[06:26] <autrijus> oh then it's just optimisation hack.

[06:26] <autrijus> that's fine. 

[06:26] <chromatic> Yes.

[06:26] <autrijus> "Perl 6 proposes an unusual execution model to address this problem.  The parser

[06:26] <autrijus> and compiler are implemented in Perl 6, with an initial set of Rules to parse

[06:26] <autrijus> source code into ASTs."

[06:26] <autrijus> better?

[06:26] <chromatic> Wiggle room.  Better.

[06:26] <autrijus> 'kay.

[06:26] <chromatic> I'm not sure about the intent that Perl 6 should run on CLR or JVM.

[06:27] <chromatic> I do admit to some personal dubiousness about at least one of them.

[06:28] <autrijus> okay. it's however widely advertised though.

[06:28] <autrijus> for example, http://dev.perl.org/perl6/ -- "Interchangable runtime engines let you interpret your bytecode or convert it to something else (e.g., Java, C, or even back to Perl)."

[06:28] <autrijus> among several places.

[06:29] <chromatic> Hm.  Stick with the wide advertisement then.

[06:29] <autrijus> ;)

[06:29] <chromatic> Hm, my new code still isn't working.

[06:30] <chromatic> Were you suggesting that I replace the Var "$?SELF" with the code you posted?

[06:30] <autrijus> yeah.

[06:30] <autrijus> btw, today I encouraged Bestian to apply for summer of code's perl 6 hacking.

[06:30] <chromatic> I have

[06:31] <autrijus> not sure if he'll end up going to OOo or something else, though

[06:31] <chromatic> (Syn "=" [Syn "{}" [(Val (argValue $ head bound)), Val (VStr key)], Val val]) ...

[06:31] <chromatic> at the start of the list comprehension in applyExp.

[06:31] <autrijus> yes, that's the idea. doesn't work?

[06:32] <chromatic> I'm still seeing the undeclared $?SELF errors.

[06:32] <autrijus> so you're seeing the errors with writing $?SELF

[06:32] <autrijus> you sure it passed compilation?

[06:32] <chromatic> Yep, everything went fine.

[06:33] <chromatic> In the second paragraph of 3.1, there's a possible interpretation that Perl6::Rules might have worked on older versions of the regex engine.  No chance!  :)

[06:34] <autrijus> it did pass tests.

[06:34] <chromatic> Damian bumped up against the regex size limit a few times.  I don't remember if he had re-entrancy issues, though I know that the closure problems are troublesome.

[06:34] <eric256> autrijus almost all the tests in \ext\Set\t\overload.t are marked as todo.

[06:34] <autrijus> 132552  PASS 5.8.2 on Freebsd 5.2-current (i386-freebsd)

[06:35] <autrijus> eric256: are we looking at the same file?

[06:35] <autrijus> I see 4 todo tests

[06:35] <autrijus> and 7 skipped

[06:35] <chromatic> ahh, I do remember P6::Rules failing on 5.8.3 or something.  Good point.

[06:35] <autrijus> with some 20ish working

[06:36] <autrijus> closure problems?

[06:36] <chromatic> In 3.2, another of the problems with P6C is that Parrot changed calling conventions a few times.

[06:36] <chromatic> (?{}) constructs in regexes.

[06:36] <chromatic> They're sort of code and sort of not.  They're really weird lexically.

[06:37] <eric256> the first test in the one i am looking at is the infix one on line 17 which is marked as todo... my early guess at most was wrong, but many more than 4 marked as :todo(somereason)

[06:37] <autrijus> chromatic!

[06:37] <autrijus> class Foo { has $.z; method bar ($.z) {} } my $x = Foo.new; $x.bar(3); say $x.z

[06:37] <autrijus> this yields "3"

[06:37] <chromatic> Which revision?

[06:37] <autrijus> the same code as you pasted -- I'll commit

[06:38] <chromatic> Try the T::B tests.

[06:39] <autrijus> sec.

[06:39] <autrijus> the 4 are in line 17, 21, 41, 47

[06:39] * eric256 is confused 

[06:39] <svnbot6> r4390, autrijus++ | * chromatic's initial review

[06:39] <svnbot6> r4391, autrijus++ | * Support for `method foo ($.x) {}` to set $.x.

[06:39] <svnbot6> r4391, autrijus++ |   Submitted by: chromatic

[06:39] <autrijus> the bottom 7 are skipped and arguably shouldn't be supported at all

[06:40] <autrijus> note the "exit" in line 88 and "skip_rest"

[06:40] <eric256> that test file takes forever to run

[06:40] <autrijus> literally? :-/

[06:40] <eric256> the skipped one is infix:<+> though, so is this a bug with just +  (/me missed the exit)

[06:41] <eric256> i started the test when you mentioned it, and it just failed the second todo (~)

[06:44] <autrijus> chromatic: which test you want me to try?

[06:44] <chromatic> 021*t

[06:44] <chromatic> 02[1-4]*t all give the same failure.

[06:44] <autrijus> there's no $?SELF errors.

[06:45] <autrijus> also I see

[06:45] <autrijus> ok 5 - diagnostic() should report the default diagnostic if needed # TODO feature

[06:45] <chromatic> Odd.

[06:45] <chromatic> Why am I seeing errors and you aren't?

[06:45] <chromatic> I just updated and am rebuilding.

[06:45] * eric256 thinks autrijus has a secret advanced copy of pugs. ;)

[06:45] <autrijus> right, and I'm just handing out bits at a time.

[06:46] <autrijus> wouldn't that be nice :)

[06:46] <gaal|work> ghc-6.4 is still ok, right?

[06:46] <autrijus> gaal|work: I use 6.4

[06:46] <autrijus> is 6.4.1 out?

[06:46] <gaal|work> no, but 6.5-snapshot is always an option :)

[06:47] <autrijus> years of freebsd experiences taught me to not trust snapshots :)

[06:47] <gaal|work> (new machine here. compiling perl5.8.7 as i speak)

[06:47] <gaal|work> so *that's* why you release pugs so often! :)

[06:48] <autrijus> exactly!

[06:48] <autrijus> nothing better to keep people honest than relenging

[06:48] <chromatic> autrijus, now I think they're only getting the default values and not any passed-in values.

[06:49] <autrijus> class Foo { has $.z; method bar ($.z) {} } my $x = Foo.new; $x.bar(3); say $x.z;#3

[06:49] <chromatic> method bar ($.z = 6)

[06:49] <autrijus> you really want a ?.

[06:49] <autrijus> ?$.z=6

[06:49] <chromatic> Yes.

[06:49] <autrijus> the parser should maybe warn for syntax error.

[06:50] <chromatic> So should my brain, but I don't think it runs any language either of us know.

[06:50] <gaal|work> we don't have warnings at all, do we? also: how would we write tests for them?

[06:50] <autrijus> chromatic: in fact writing ($.z=9) gives out syntax error.

[06:51] <chromatic> Good.

[06:51] <autrijus> gaal|work: well, we can call op1 "warn" or refactor it to "warn" primitives in the eval monad

[06:52] <autrijus> gaal|work: but I'm not at all sure what perl 6's warning model is

[06:52] <autrijus> rebinding &warn makes it testable.

[06:53] * eric256 finaly discovers he is fighting with operator precedence without even knowing it

[06:53] <autrijus> eric256: sometimes the ":d" command in pugs shell helps

[06:53] <autrijus> :D too

[06:53] <eric256> my $x = 5`F; my $y = 6`M; my $z = $x + $y; # works

[06:53] <eric256> while

[06:54] <lathos> What on earth does that mean?

[06:54] <eric256> my $z = 5`F + 6`M; #fails very quitly

[06:54] <eric256> ` is an overloaded operator to pretend to handle units

[06:54] <pasteling> "geoffb" at 69.110.115.185 pasted "Something not right with use Foo--perl5; supposedly equivalent code in p5 and p6 don't act the same (but don't crash, either)" (42 lines, 1.1K) at http://sial.org/pbot/10733

[06:54] <lathos> oh.

[06:54] <autrijus> ah. wait. damian said something that makes it tighter (or looser) than plus

[06:55] <geoffb> autrijus, can you look at the above paste and give me an idea whether it's a known problem, or how to start debugging it?

[06:55] <autrijus> he suggested looser than <+> by default.

[06:55] <autrijus> that will also mess with your 5`F thing.

[06:56] <eric256> btw i had a problem in the debuger i loaded the unit file, but then executing the above line worked while :d ing it failed... let me go get the error it gave

[06:56] <autrijus> geoffb: try forcing a cast.

[06:56] <autrijus> glClear(+GL_COLOR_BUFFER_BIT);

[06:56] <eric256> any way to specify precedence?

[06:56] <autrijus> glClear(~GL_COLOR_BUFFER_BIT);

[06:56] <autrijus> glCleaint (~GL_COLOR_BUFFER_BIT);

[06:56] <autrijus> glClear(int GL_COLOR_BUFFER_BIT);

[06:56] <autrijus> geoffb: it is possible that glClear doesn't grok overloaded SVs.

[06:56] <autrijus> forcing a cast will ensure we only pass back a single SvIV (or SvPV etc)

[06:56] <chromatic> IIRC, those are constant subs in Perl 5.

[06:57] <geoffb> Hmmm, OK, lemee give it a try

[06:57] <autrijus> chromatic: yeah, but I don't think the wrapper groks that

[06:57] <autrijus> they will become compound values after roundtrip

[06:57] <autrijus> there's a todo for that too I think

[06:57] <lathos> autrijus: Has anyone offered to proof your Haskell Workshop paper yet? If not, consider this an offer

[06:57] <chromatic> S'okay, SDL constant handling gives me the howling fantods anyway.

[06:57] <pasteling> "eric256" at 69.234.147.101 pasted "odd" (8 lines, 236B) at http://sial.org/pbot/10735

[06:57] <geoffb> + didn't work, trying int

[06:58] <autrijus> eric256: "is tighter" and "is looser" and "is equiv" -- see S03 -- there's no tests! please write some.

[06:58] <chromatic> autrijus, see t/oo/attributes.t test 59 please.

[06:58] <autrijus> (also, not implemented yet)

[06:58] * eric256 watches clock tick towards midnight and thinks... maybe tommarrow.

[06:58] <autrijus> eric256: ok :)

[06:59] <eric256> i've just been having a heck of a time narrowing this down because i thought it was a signature error and it turned out to be a precedence error.  check my paste there, made debuging a little hard

[06:59] <autrijus> chromatic: eerie

[06:59] <autrijus> eric256: ok, will check.

[06:59] <autrijus> eric256: get some sleep first then :)

[06:59] <eric256> later ;)

[06:59] <autrijus> lathos: offer gladly taken.

[06:59] <chromatic> "but I LIKE having the default value!"

[06:59] <autrijus> lathos: please commit ahead in docs/talkes/.

[07:00] <gaal|work> beh, 5.8.7's cpan is broken, i think.

[07:00] <autrijus> I'll 3-way merge as needed

[07:00] <svnbot6> r4392, chromatic++ | Added tests for optional default attribute/non-attribute values in methods.

[07:00] <geoffb> int and ~ no workie as well.  Hmmm, perhaps num cast for the args to glClearColor . . .

[07:00] <autrijus> geoffb: :-/. you can debug the roundtrips in src/perl5/perl5.c 

[07:01] <autrijus> if clkao is around, bug him as well -- I may need to run for food soonish

[07:01] <geoffb> autrijus, OK, thanks.

[07:02] <autrijus> lathos: I need to submit it before APW, though, so it'd be best if you can proof it this weekend

[07:02] <chromatic> Eerie?

[07:03] <gaal|work> ngg!@#!@#! why does perl5 still not ship with something that can do http!? bootstrapping cpan with ftp.exe is such a pain.

[07:03] <lathos> I'll do it this afternoon.

[07:06] <autrijus> lathos++

[07:07] <autrijus> chromatic: 

[07:07] <autrijus>  class Foo { has $.z; method BUILD (?$.z = 9) {} }

[07:07] <autrijus> my $x = Foo.new( z => 10 );

[07:07] <autrijus> say $x.z

[07:07] <autrijus> # 10

[07:09] <autrijus> chromatic: I'd love to triage from this to the t/oo failure

[07:09] <autrijus> but I really gotta run. bbiab

[07:09] <chromatic> Sure, I need to sleep now too.

[07:09] <autrijus> =)

[07:11] <geoffb> I should probably do the same, given that I share chromatic's timezone.

[07:12] <gaal|work> gnight, geoffb.

[07:12] <geoffb> autrijus, what's your usual time range in here?  I have the sinking feeling it's almost precisely centered over my sleep cycle.  :-(

[07:12] <gaal|work> autrijus nevre sleeps (except for when he does)

[07:13] <geoffb> That's why I said "in here" . . . :-)

[07:14] <geoffb> ah well, looks like I managed to hit his food cycle.  :-)

[07:15] <geoffb> OK, g'night all.

[07:15] <gaal|work> bye.

[07:18] <autrijus> geoffb: so I'm GMT+8

[07:18] <autrijus> geoffb: and I usually sleep at anywhere between 2pm to... 2pm

[07:18] <autrijus> of the next day, thatis.

[07:19] <autrijus> or maybe the same day and I only sleep for an instant. hard to tell sometimes

[08:28] <svnbot6> r4393, gaal++ | "critical" evals (use, require, prelude) now raise exceptions on comilation errors (autrijus)++

[08:28] <svnbot6> r4393, gaal++ | TODO: figure out why error coordinates for Prelude are wrong;

[08:28] <svnbot6> r4393, gaal++ | Have the build process sanity-test the Prelude

[08:42] <gaal|work> in make, is there no (nice) way of saying "this rule must be run *after* a target is built"?

[08:42] <gaal|work> like a dependency, but post-

[08:43] <gaal|work> the problem i want to solve:

[08:43] <gaal|work> Prelude.pm is now loaded on every pugs start

[08:44] <gaal|work> so if someone breaks prelude, it's an immediate pugs breakage, but will only be seen when pugs is run

[08:44] <gaal|work> i want 'make' to do 'pugs -e1'

[08:44] <gaal|work> but i also want make [un]?optimized to do that

[08:48] <integral> hmm, make make test faster so we can all run it before check in ;-)

[08:48] <svnbot6> r4394, gaal++ | cosmetics

[08:48] <gaal|work> make pugs blazingly fast so we can all run a full smoke test, you mean :)

[08:49] <gaal|work> ah

[08:49] <gaal|work> that *is* what you said

[08:49] <gaal|work> i didn't see the word 'test'

[08:49] <gaal|work> we're at the end of the weekend here, you see.

[08:49] <integral> or have some subset of tests that just run some basic tests

[08:50] <gaal|work> t/sanity? good idea.

[09:03] <nothingmuch> i hate online bank policies

[09:04] <nothingmuch> i have a good password I use for few things

[09:04] <nothingmuch> i remember it well

[09:04] <nothingmuch> i could use it for the bank, but no

[09:04] <nothingmuch> gotta change password every 3 months

[09:04] <nothingmuch> this way i forget it, and i have to write it down somewhere

[09:04] <nothingmuch> so obviously my account is much more secure this way. =P

[09:40] <Enveigler> Anyone know of any examples that use Haskell FFi to map over a Cstruct that contains two or more fixed-sized C-style byte arrays? 

[10:49] *** sbkhh is now known as Odin-

[11:18] <nothingmuch> Enveigler1: did you ask on #haskell? they are usually very helpfufl

[11:18] <svnbot6> r4395, simon++ | Style and grammar nits.

[11:35] <Enveigler1> nothingmuch: I haven't found my way over there yet. Mostly cos I don't think that I can express my questions in a way that will engender answers. A complement to the Haskel LibRef that gave a few examples would be so nice. Especially if I could type those examples into GHCi and have them do something other than give me a message that isn't even clear as to whether what i've done is an error or not!. 

[11:36] <nothingmuch> i think you should give #haskell a try, they are good folk

[11:36] <Enveigler1> What does "module `Foreign' is a package module" mean? Is that an error? A statement of fact? A random quote?

[11:36] <nothingmuch> as for refs... sorry, can't help you, not enough of a know-how myself

[11:36] <nothingmuch> i think it's a statement of fact

[11:36] <nothingmuch> in relation to an error

[11:36] <Enveigler1> :) Thanks! 

[11:37] <Enveigler1> Sorry if that wasn;t meant to be funny, but it made me laugh anyway!

[11:38] <Enveigler1> I'll try #haskell.

[11:41] <Enveigler1> Hmmm. Safe sex and non-monogomous relationships seems to be th etopic over there at the moment :(

[11:41] <crysflame> heh

[11:42] <lightstep> Enveigler1, don't fear. on-topic is always on-topic

[11:42] <Enveigler1> I was trying to think of some connect between safe-sex and referential transparency?

[11:43] <lightstep> don't

[11:43] <lightstep> they just like talking about sex every few weeks

[11:43] <Enveigler1> 'K :)

[11:56] <sri_> hmm...wonder if Dan ever looked at Pugs...no wonder one gets bitter when he just sees Parrot...

[11:56] <crysflame> he was in #perl6 from time to time

[11:56] <crysflame> at least, i saw him once and i think twice

[11:57] <crysflame> could have been a different Dan

[11:57] <sri_> we have 2 or 3 dan's alone in #catalyst ;)

[11:57] <crysflame> lightstep++ # "they" could be any community

[11:57] <crysflame> sri: mm, yes

[11:59] <wolverian> sri_: don't use the apostrophe for plurality :)

[11:59] <sri_> oh, not another inquisitor...

[12:00] <wolverian> the others are just mild copies of me!

[12:00] <sri_> hah, i'm used to having an editor of the oxford english dictionary around ;P

[12:01] <wolverian> "I'm"

[12:01] <wolverian> (that's the only capitalization rule I'm going to nit about)

[12:02] <sri_> you would like each other...

[12:02] <scook0> wolverian: even when I'm typing in all lowercase, I can't bring myself to type 'i' :)

[12:03] <sri_> i even use the oxfor comma now "1, 2, and 3" :)

[12:03] <sri_> oxford

[12:03] <wolverian> scook0: right. I think mostly lower case is okay for IRC, but lowercasing 'I' is just nefarious.

[12:03] <wolverian> sri_: are you british?

[12:03] <sri_> i'm german ;)

[12:05] <sri_> i should invite jesse...

[12:05] <svnbot6> r4396, iblech++ | hw2005.txt -- Typo fixes.

[12:05] <sri_> :)

[12:06] <crysflame> i use apostrophes on irc to differentiate plurals from nicknames

[12:06] <crysflame> lathos's

[12:06] <crysflame> if you consider 'lathos' a pictogram formed of a series of strokes known as 'ASCII'..

[12:08] <wolverian> lathoses

[12:08] <wolverian> okay, food! bye.

[12:11] <nothingmuch> lathoss

[12:11] <nothingmuch> that looks like a typo

[13:03] <Enveigler> so much for #haskell :(

[13:51] <svnbot6> r4397, autark++ | * Made the \q[...] interpolation in singelquoted strings accept all q-structures.

[13:51] <svnbot6> r4397, autark++ | * Added tests for \q-interpolation

[13:51] <gaal|work> i want to introduce a deprecation warning to the "open" builtin (people should now use File::open). is adding a call to op1 "warn" "blah blah blah" in the open Prim the way to do it?

[13:54] <pjcj> Do things need to be deprecated at the moment?  I thought they just needed to be made to work according to spec.

[13:55] * integral would take the view that if something's never been in a synopsis, it doesn't need deprecation

[13:56] <gaal|work> okay, then i'll just go ahead and break open :-)

[13:56] <gaal|work> i wanted to be nice to module/tests authers

[13:56] <gaal|work> authors

[13:56] <autrijus> er. open() is not builtin anymore?

[13:56] <gaal|work> i can't type

[13:56] <autrijus> I thought it's imported from File:: by default

[13:56] <gaal|work> do we have import?

[13:56] <autrijus> I may be imagining things though

[13:56] <autrijus> we do have "is export" and aliasing

[13:56] <gaal|work> there's a Prim

[13:57] <autrijus> if you declare File::open as "is export" it will be exported to main

[13:57] <gaal|work> cool, then this should be almost a silent move

[13:57] <integral> it still shouldn't be a prim

[13:57] <gaal|work> except that ">filename" no longer works that way.

[13:57] <gaal|work> it isn't a prim.

[13:57] <autrijus> wouldn't it be nice to say

[13:57] <gaal|work> i mean the one called from prelude

[13:57] <autrijus> is (unsafe & primitive & export)

[13:57] <autrijus> but I'll not jump to implement that

[13:57] <integral> that would be nice :-)

[13:58] <gaal|work> though it does rely on Pugs::Internals::openFile, which is.

[13:58] <autrijus> that is an implementation detail

[13:58] <gaal|work> okay, breaking some code. ;-)

[13:59] <autrijus> people are not supposed to call that anymore than calling Internals::rehash_seed

[13:59] <autrijus> or "Internals::hv_clear_placeholders

[13:59] <autrijus> (both are perl 5 primitives.)

[13:59] <gaal|work> right.

[14:00] <integral> or Internals::SvREADONLY on arrays...

[14:00] <autrijus> or (GHC.Prim.State# GHC.Prim.RealWorld)...

[14:00] <theorbtwo> Or Internals::SvREADONLY on true and false.

[14:00] <integral> hmm, implementing Prelude.pm for perl5 might be interesting

[14:00] <theorbtwo> integral: Largely you could steal the algos from other modules.

[14:01] <theorbtwo> For example, there's a sin in Math::BigFloat that I don't think relies on the core's sin.

[14:01] <theorbtwo> Allo, all.

[14:01] <integral> I'd like to get rid of opcodes like ghbyname (gethostbyname)

[14:01] <svnbot6> r4398, autrijus++ | * change RuleState constructor to MkRuleState to agree with

[14:01] <svnbot6> r4398, autrijus++ |   the Pugs convention.

[14:03] <autrijus> I think it's fine for pugs -- like any runtime -- to have internal primitives that may change from time to time :)

[14:04] <autrijus> ∀ moon. ∃ side ∈ moon | side ≑ dark

[14:04] <integral> hmm, what's the difference between a primitive and something like XS?

[14:04] * gaal|work giggles. autrijus' lambda looks like the hebrew letter gimmel.

[14:04] <autrijus> gaal|work: there's no lambda :)

[14:04] <gaal|work> really?

[14:04] <gaal|work> my name starts with that letter.

[14:05] <gaal|work> 􏿽xE2􏿽xEC

[14:05] <autrijus> that line (in UTF8) reads: "forall moon. there exists a side that is member of the moon geometerically equal to dark"

[14:05] <autrijus> but maybe I'm not setting encoding correctly...

[14:06] <integral> no, you're find autrijus, that's utf-8

[14:06] <gaal|work> in what calculus?

[14:06] <integral> I can't see gaal|work's character(s) though

[14:06] <autrijus> gaal|work: in #perl6 calculus

[14:06] <integral> *fine

[14:06] <autrijus> integral: curiously, neither can I

[14:07] * autrijus checks in an entire section 4

[14:07] <autrijus> 50% done, only 90% to go

[14:08] <autrijus> er, I mean 100% to go

[14:08] <scook0> autrijus: are caller side splatted arguments broken, or just unimplemented yet? (responding to andras on p6l)

[14:09] <autrijus> scook0: they are unimplemented.

[14:09] <scook0> I thought so

[14:09] <autrijus> currently the splat acts somewhat like "list"

[14:09] <autrijus> but that's the extent of what it does

[14:09] <theorbtwo> I thought caller side was working, and callee side was parsed-but-ignored?

[14:09] <autrijus> I wouldn't say it's ignored...

[14:10] <autrijus> ?eval *[1,2], *[3,4]

[14:10] <evalbot6> (1, 2, 3, 4) 

[14:10] <autrijus> ?eval [1,2], [3,4]

[14:10] <evalbot6> ([1, 2], [3, 4]) 

[14:10] <knewt> gaal|work: could you just repeat the letter from earlier please?

[14:10] <autrijus> but in function argument position, it does not automagically promote the corresponding parameters to slurpy

[14:11] <gaal|work> knewt: 􏿽xE2

[14:12] <Aankhen``> scook0 >> Are you planning to respond to the Rules question too, by any chance?

[14:12] <autrijus> it requires some analysis for args in bindParams -- not trivial but is a quite contained change

[14:12] <autrijus> lathos++ # proofreading

[14:12] <knewt> gaal|work: excellent, i've got charset conversion set up properly for you now :)

[14:12] <scook0> Aankhen``: no I'm not, so feel free

[14:12] <svnbot6> r4399, autrijus++ | * hw2005.txt -- section 4 complete!

[14:12] <Aankhen``> Mmm.

[14:13] <gaal|work> amn't i sending utf-8?

[14:13] * Aankhen`` tries.

[14:13] <autrijus> gaal|work: looks not

[14:13] <knewt> gaal|work: nope, iso8859-1

[14:13] <knewt> or something very similar

[14:13] <lumi> iso8859-8?

[14:13] <autrijus> it's iso-8859-8.

[14:13] <autrijus> the big5 of the hebrew world ;)

[14:13] <knewt> heh

[14:14] <theorbtwo> I'm not sure describing rules as a sub-language of perl6 is a clean thing to do.  It's not a subset, or a superset -- in fact, it's logically disjoint.

[14:14] <knewt> ok, changed the conversion from -1 to -8, just in case

[14:14] <Aankhen``> Indeed.

[14:15] <autrijus> an embedded language then?

[14:15] <theorbtwo> I don't know about that; isn't iso-8859-8, likes the other iso 8859 series encodings, purely 8-bit.

[14:15] <theorbtwo> Sounds good, autrijus.

[14:15] <theorbtwo> s/bit\./bit?/

[14:15] * theorbtwo needs to get irssi to think it's terminal is utf8.

[14:16] <gaal|work> figures. this is the first mass-market OS to use unicode in the kernel, yet all apps use stupid 8 bit encodings.

[14:16] <autrijus> /set term_type

[14:16] <autrijus> which kernel is that?

[14:16] <gaal|work> windows

[14:17] <gaal|work> ucs-2

[14:18] <autrijus> ah. I thought mac os did it first. I may be wrong though

[14:18] * autrijus was briefly thinking that gaal is running Plan 9

[14:18] <autrijus> then I read the "mass-market"

[14:18] * knewt runs purely utf8 himself, and converts incoming messages from people who don't do so into utf8. have to explicitly turn on the conversion though; i turned off the guessing code because it was getting it wrong too much

[14:18] <autrijus> knewt: irssi/recode?

[14:18] <theorbtwo> The NT series has been ucs-2 for a while.

[14:18] <knewt> autrijus: irssi/charsetwars

[14:18] <autrijus> ooh wars.

[14:19] <gaal|work> actually, i may be wrong too. :)

[14:19] <theorbtwo> (Which is sad, since it means that they still need ugly hacks to deal with characters over 0xFFFF, so have all the slowness of utf8, with all the size of utf-16.)

[14:19] <gaal|work> i wasn't really giving it a compliment, you know.

[14:19] <autrijus> the first Mac OS to use unicode internally is 8.5, released on 1998

[14:20] <gaal|work> i think nt 3.5 was around then, too.

[14:20] <autrijus> nt is two full years earlier

[14:20] <gaal|work> don't remmeber whether unicode came in in 4 or 3.5

[14:20] <autrijus> nt4 I think.

[14:20] <autrijus> in 1996

[14:21] <autrijus> so (windows nt)++

[14:21] <autrijus> but (notepad.exe)-- for insisting to save BOM marks in utf8 ;)

[14:21] <gaal|work> notepad-- for 1..Inf;

[14:21] <autrijus> $notepad -= Inf;

[14:22] <gaal|work> i have that set up as an async coro

[14:22] <autrijus> lol

[14:22] <gaal|work> notepad -= 􏿽xE0_0

[14:22] <theorbtwo> Hm, still can't see Autrijus's unicode, but I'm beyond caring.

[14:22] <theorbtwo> _0?

[14:22] <gaal|work> superscript zero

[14:22] <gaal|work> subscript

[14:22] <theorbtwo> Ah.

[14:23] <autrijus> theorbtwo: ☹

[14:23] <autrijus> (U+2639, white frowning face)

[14:23] <gaal|work> let's see if i can tell trillian to use utf8....

[14:24] <wolverian> hmm, andale mono doesn't have U+2639 :/

[14:24] <gaal|work> hey, what good unicode terminal font do you all use?

[14:24] <knewt> oh, in case anyone doesn't know, when in gnu screen, you can easily enter unicode codepoints by doing ctrl-a ctrl-v U+NNNN  (literal U and +)

[14:25] <wolverian> gaal|work: I use Terminus. I'm not sure how much of unicode it implements, though

[14:25] <gaal|work> i use courier new because it's the most complete that i've seen, but i don't really like it.

[14:25] <wolverian> (on windows I use Andale Mono)

[14:25] <gaal|work> knewt++ yay!

[14:25] <gaal|work> screen++

[14:25] <theorbtwo> Ugh.

[14:26] <theorbtwo> Set screen's encoding to utf8 utf8, and now it's even worse; I see three characters for autrijus' two-byte utf8 character.

[14:26] <autrijus> knewt: wow, I didn't know that. I ♥ this function

[14:26] <wolverian> is your terminal in UTF-8? is your IRC client in UTF-8?

[14:27] <knewt> autrijus: i figured it out when code diving the source a while back

[14:27] <theorbtwo> They both should be.

[14:27] <knewt> theorbtwo: what does :dinfo report?

[14:28] <theorbtwo> (125,48) UTF-8 xterm color iso2022

[14:28] <autrijus> hm, I need a font that can display ⧺ (U+29FA double plus)

[14:28] <knewt> autrijus: heh, i don't see that either

[14:28] <nothingmuch> evening

[14:28] <autrijus> hey nothingmuch

[14:28] <wolverian> autrijus: monospaec?

[14:28] <QtPlatypus> Oddly thats one I can see.

[14:28] * theorbtwo wonders if he wants to get around to a web site that previews free fonts.

[14:28] <wolverian> s,ec,ce,

[14:29] * nothingmuch goes to add user words to harrorth

[14:29] <theorbtwo> (Where you can ask "what fonts do you know of that contain U+29FA?"

[14:29] * autrijus installs x11-fonts/texcm-ttf

[14:29] <knewt> theorbtwo: hmm, so screen thinks you're using utf8 then. are you using xterm? if so, when you ctrl-rightclick, is utf-8 ticked at the bottom of the menu?

[14:29] <wolverian> windows's charmap sucks.

[14:30] <autrijus> ooh there's x11-fonts/mathfonts too

[14:30] <knewt> theorbtwo: and what's your $LANG?

[14:30] <theorbtwo> I'm using gnome-terminal; it's encoding is set to utf-8.

[14:31] <theorbtwo> LANG seems to be "", which is odd.  locale reports "posix" for evert

[14:31] <theorbtwo> everything.

[14:32] <knewt> heh, that's probably causing you problems then. what does locale -a report?

[14:32] <knewt> i'm very minimal myself; i only have C, POSIX and en_GB.utf8

[14:32] <theorbtwo> en_US.utf8, amongst a few other things.

[14:33] <theorbtwo> Could have sworn I set that in .bashrc...

[14:33] <svnbot6> r4400, gaal++ | Obsolete the old open builtin. Everything should use Prelude's File::open.

[14:33] <knewt> ok, what does [[ LANG=en_US.utf8 locale ]] say?

[14:33] <theorbtwo> "en_US.utf8" for everything.

[14:34] <theorbtwo> Ah, .bashrc sets LOCALE instead of LANG (which does nothing).

[14:34] <theorbtwo> The Prelude is ignored when in safe mode... should this be the case?

[14:35] <autrijus> theorbtwo: well, currently everything in Prelude.pm is unsafe

[14:35] <autrijus> so it makes no difference

[14:35] <theorbtwo> ‽

[14:35] <theorbtwo> Woo, works.

[14:35] <autrijus> woot

[14:36] <theorbtwo> Currently, yeah.

[14:36] <integral> you can always have two preludes,  one safe only, and one which loads the first and adds unsafe stuff

[14:36] <knewt> theorbtwo: ♀ ♁

[14:36] <autrijus> I'd like to have two preludes independent of each other.

[14:36] <autrijus> but yes, the safe one should load first.

[14:36] <autrijus> the unsafe one may use functions defined in the safe one

[14:37] <integral> ah :-)

[14:37] <theorbtwo> knewt: See them.

[14:37] <theorbtwo> Thanks for the help, all.

[14:37] <autrijus> so maybe PreludeUnsafe.pm or something.

[14:37] <autrijus> PreludeIO.pm

[14:37] * theorbtwo wonders if nethack supports unicode yet.

[14:37] <autrijus> theorbtwo: it still only does the ibm console charset

[14:37] <autrijus> and I can't find a font for that :-/

[14:37] <integral> that would be better than yucky tiles ;-)

[14:38] <gaal|work> i have an open task to make loading prelude files more generic - now we hardcode the one file

[14:38] <svnbot6> r4401, gaal++ | open transition: missed some files in ext/

[14:38] <svnbot6> r4402, gaal++ | and some more in examples/

[14:38] <theorbtwo> I don't see the point of two preludes at all.

[14:38] <autrijus> gaal++ # transition

[14:39] <gaal|work> if anyone has any perl6 code at large, please note this incompatible change

[14:39] <autrijus> theorbtwo: mostly to save the parsing-and-discarding-everything for safe mode

[14:39] <gaal|work> open ">file" attempts to open a file named ">file"

[14:39] <theorbtwo> OK, that works.

[14:39] <gaal|work> in read mode

[14:40] <gaal|work> theorbtwo: my own prelude task is mostly for easing code development, so that not everything has to be in one file in the perl6 subdir

[14:40] <gaal|work> i haven't thought about the safeness issue at all yet.

[14:40] <theorbtwo> Nod, gaal.

[14:41] <theorbtwo> It would be nice to have unsafe functions not exist, rather then erroring when called, so you can safely check if you can do something.

[14:41] <integral> (compile time safety checking)++

[14:41] <theorbtwo> (Not try to open your config file if in safe mode, for example, rather then trying and dying... though I suppose you could scatter around try blocks instead.)

[14:42] <gaal|work> how's having them not exist better?

[14:42] <theorbtwo> if (&open) {open_config_file("foo")}

[14:42] <gaal|work> sounds easier to me to open err die

[14:42] <gaal|work> or

[14:42] <gaal|work> open err cant_open

[14:43] <theorbtwo> You have a point.

[14:43] <theorbtwo> Though "running in safe mode" shouldn't neccessarly be the same as "I have no config file", which should probably not be the same as "I have a config file, but can't open it".

[14:43] <gaal|work> actually open err cant_open isn't very good, at least not always, because sometimes you care why you can't open.

[14:43] <gaal|work> exactly :)

[14:44] <gaal|work> how often do we write code that doesn't know at authoring time if it's going to be run in safe mode?

[14:45] <iblech> autrijus: Just read hw2005.txt -- two issues: line 332 (s/1..$x/1 + $x/, add "our" before &add1?) and line 376 ("We choose it..." -- shouldn't it be "We've chosen it" or "We chose it"?)

[14:45] <gaal|work> i see integral's point...

[14:45] <integral> it's would be nice just to say: perl6 -c --safe-mode myprog.p6

[14:46] <theorbtwo> integral: But then you can't "use" anything.

[14:46] <gaal|work> that can't work in perl, though, *if* safe mode allows some sort of use.

[14:46] <theorbtwo> Safe mode is pretty limited.

[14:46] <integral> hmm!

[14:46] <gaal|work> and i think it should, to be useful for anything except bots

[14:47] <theorbtwo> I'm not sure about that.

[14:47] <osfameron> p5 Safe mode isn't particularly, iirc

[14:47] <theorbtwo> But safe mode should be enterable from within the session.

[14:47] <autrijus> iblech: both please fix away

[14:48] <iblech> autrijus: Ok

[14:48] <gaal|work> i still like my lexical safe mode idea, but i have no idea how to implement it :(

[14:48] <gaal|work> lexically scoped

[14:48] <autrijus> I still think lexical scope safe mode is just runEvalSTM.

[14:48] <svnbot6> r4403, iblech++ | autrijus++'s hw2005.txt -- Two minor fixes.

[14:49] <theorbtwo> Sounds right to me.

[14:49] <autrijus> it needs to eliminate the few places that we (ab)use liftIO and unsafePerformIO for debugging etc

[14:49] <gaal|work> i'm afraid what i just said obtains -- i have no idea how to implement that :-)

[14:49] <autrijus> but should really be doable. plus we gain atomically{} for free.

[14:49] <autrijus> which is big win.

[14:50] <knewt> gah. i just did a xrdb .Xresources, instead of xrdb -merge .Xresources. any easy way to get everything back that was there before?

[14:50] <gaal|work> we have plans for a 'no' keyword, right?

[14:51] <gaal|work> let's just remember to make 'no safe' a special case which is a noop :-)

[14:52] <theorbtwo> Hm, the downside of making the Prelude an AST instead of a string of perl code is that we'd have to compile a pugs, do the pugs -CPugs (or whichever), create the new Prelude.hs, and recompile.

[14:52] <autrijus> gaal|work: right but it's just calling unimport()

[14:52] <theorbtwo> ...and compile is slow enough already.

[14:52] <autrijus> speaking of that, currently

[14:52] <autrijus> use Foo; # does not call import

[14:52] <autrijus> use Foo (); # calls import with ()

[14:52] <autrijus> that's backwards and needs to be fixed

[14:52] <nothingmuch> jesus christ

[14:52] <nothingmuch> doExp i@Interp{ dict = dict } (NewWord word body) = return i{ dict = insert word body dict }

[14:52] <nothingmuch> doExp i@Interp{ dict = dict } (Invoke userWord) = interpret i $ dict ! userWord

[14:53] <nothingmuch> that's all there's to it

[14:53] <nothingmuch> : foo 1 2 ; foo . 

[14:53] <nothingmuch> 2

[14:53] <nothingmuch> Interp {stack = [1], dict = {"foo":=[Push 1,Push 2]}}

[14:53] <nothingmuch> harrorth has user words

[14:53] <theorbtwo> Whee!

[14:54] <gaal|work> autrijus, it's just opRequire True

[14:54] <gaal|work> brb

[14:58] <theorbtwo> Oh, blast.  I never finished my ~-on-VObject, and now it's broken.

[14:58] <autrijus> nothingmuch: let me know when you are willing to monadise it :)

[14:59] <theorbtwo> Oh, wait.  Nevermind, it was always broken.

[14:59] <nothingmuch> autrijus: monadize how?

[14:59] <nothingmuch> like we talked?

[15:01] <theorbtwo> I need findSub and applySub from Pugs.Eval in Pugs.AST.Internals, but Pugs.Eval needs Pugs.AST.Internals itself.

[15:01] <theorbtwo> The circularity semisupportedness is really annoying.

[15:05] <theorbtwo> Odd.  If I just do the changes from castV to fromVal in the definition of instance Value VStr, I get "Warning: Pattern match(es) are overlapped".

[15:05] <theorbtwo> Why do I get that with fromVal, and not castV?

[15:07] <theorbtwo> Oh... because there's a fromVal v, with some sort of strange special handling for Hash.

[15:07] <theorbtwo> Oddly, it doesn't mention that as one of the overlapping patterns.

[15:10] <autrijus> nothingmuch: yes... basically StateT or ReaderT or WriterT

[15:10] <nothingmuch> okay

[15:10] <autrijus> or indeed RWST

[15:10] <nothingmuch> lets do it now

[15:10] <nothingmuch> 5 minutes

[15:11] <nothingmuch> how do i turn an Integer into an Int?

[15:11] <autrijus> fromInteger

[15:12] <autrijus> fromInteger :: (Num a) => Integer -> a

[15:12] <nothingmuch> will that do error if it can't downgrade?

[15:12] <autrijus> no idea

[15:12] <autrijus> do you worry about that?

[15:12] <nothingmuch> nope

[15:13] <nothingmuch> just curious

[15:13] <autrijus> so check in user words first

[15:13] <autrijus> theorbtwo: vCast is same direction as fromVal

[15:13] <autrijus> castV is something else entirely.

[15:14] <theorbtwo> Er, right, sorry.

[15:16] <autrijus> nothingmuch: hm?

[15:16] <nothingmuch> one second

[15:16] <autrijus> ok. I'll type ahead.

[15:17] <autrijus> the idea is to make anything of form

[15:17] <autrijus> interpret :: Interp -> Forth -> IO Interp

[15:17] <autrijus> into the form

[15:18] <autrijus> eval :: Forth -> Eval Literal

[15:18] <autrijus> (or something like that)

[15:18] <autrijus> eval :: Forth -> Eval Interp -- maybe this

[15:18] <autrijus> depending on how you want the final result

[15:18] <autrijus> or even

[15:18] <autrijus> eval :: Forth -> Eval ()

[15:19] <nothingmuch> i think Eval () is the best

[15:19] <nothingmuch> so that it can be dumped on the screen at the end of the program

[15:19] <nothingmuch> but for now I like Eval Interp

[15:19] <nothingmuch> darcs pull, btw

[15:20] <autrijus> ok. say we have

[15:21] <autrijus> type Eval a = ReaderT Interp IO a

[15:21] <autrijus> it means that the eval monad has access to interp at all times via "ask"

[15:21] <autrijus> and can change the interp state for sub-computation using "local".

[15:22] <autrijus> so we have

[15:22] <autrijus> interpret [] = ask

[15:22] <nothingmuch> wow, pretty

[15:22] <autrijus> interpret (exp:exps) = local (doExp exp) (interpret exps)

[15:22] <autrijus> doExp becomes:

[15:23] <nothingmuch> btw, ReaderT stores one state per instance of the type variable?

[15:23] <autrijus> doExp :: Exp -> Interp -> Interp

[15:23] <autrijus> nothingmuch: "ReaderT Interp" maintains a single Interp, yes

[15:23] <autrijus> look at signature of "local":

[15:24] <nothingmuch> no, i mean a single interpreter for every type that can be in `a`?

[15:24] <autrijus> local :: (MonadReader r m) => (r -> r) -> m a -> m a

[15:24] <nothingmuch> or a single interpreter period?

[15:24] <autrijus> a single interpreter period... the "a" is result type

[15:24] <autrijus> like "IO a"

[15:24] <autrijus> think Eval as a super-IO

[15:25] <autrijus> in the IO monad you can do lots of different computations

[15:25] <autrijus> like (IO Int) or (IO Char)

[15:25] <nothingmuch> but they are the same monad

[15:25] <autrijus> but they don't touch the real world

[15:25] <nothingmuch> okay, i get it

[15:26] <autrijus> you can think that ReaderT augments the real world with Interp.

[15:26] <autrijus> that would not be far from truth.

[15:26] <autrijus> ok. so "local"'s signature is kind of hard to read.

[15:26] <autrijus> local :: (MonadReader r m) => (r -> r) -> m a -> m a

[15:26] <autrijus> the context head says "given the monad m that implements a reader of type r"

[15:26] <nothingmuch> what's MonadReader?

[15:26] <nothingmuch> oh

[15:27] <autrijus> it's a type class.

[15:27] <autrijus> a type class with two parameters

[15:27] <nothingmuch> what's a reader of type r?

[15:27] <autrijus> that usually means a relationship between the two types.

[15:27] <autrijus> Eval is a monad type

[15:27] <autrijus> it implements a reader of type Interp.

[15:27] <nothingmuch> type readerOfTypeR = Reader Int -- r is t?

[15:27] <nothingmuch> r is int

[15:27] <nothingmuch> so a reader of type Interp in our case?

[15:28] <autrijus> yup.

[15:28] <wolverian> I need a "how Haskell concepts map to normal languages" handbook

[15:28] <autrijus> nothingmuch: so. "local" takes two arguments.

[15:28] <nothingmuch> so local takes a function that does stuff to an Interp

[15:28] <autrijus> the first one, (r -> r), dictates how to update an Interp

[15:28] <nothingmuch> and uses it to change the value that will be returned on the next 'ask'?

[15:28] <autrijus> the second one, (Eval a), is the sub-computation we are about to perform

[15:29] <autrijus> "local" applies the (r->r) to our current Interp

[15:29] <cognominal> autrijus, about w2005.txt,  "Perl 5 has no static grammar" is very confusing.  I would say something like "the lexing is very context dependant which affects the parssing"

[15:29] <autrijus> then returns a (Eval a) that would evaluate the original (Eval a) argument, but in an modified Intepr.

[15:29] <cognominal> yacc is not a very dynamic grammar...

[15:30] <nothingmuch> okay, Reader sort of makes sense

[15:30] <nothingmuch> so local changes the Interp permanently?

[15:30] <autrijus> cognominal: thanks, fixed

[15:30] <autrijus> nothingmuch: no. that would be StateT

[15:31] <nothingmuch> so how does ReaderT roll it back?

[15:31] <autrijus> x <- local fun actionA

[15:31] <autrijus> y <- local fun actionB

[15:31] <nothingmuch> and why is it a ReaderT and not a Reader?

[15:31] <autrijus> interp <- ask

[15:32] <autrijus> in that example, actionA and actionB will always evaluate in the same interp

[15:32] <autrijus> and the "interp" will always be the same interp before evaluating x and y

[15:32] <autrijus> because "local" only changes the interp "lexically", so to speak.

[15:33] <nothingmuch> right, how does it do the lexical behavior?

[15:33] <cognominal> autrijus, do you mind if I translate that into French for French linuxmag?

[15:33] <autrijus> cognominal: not at all

[15:33] <cognominal> oki

[15:34] <cognominal> I will see how it works moneywise

[15:34] <autrijus> nothingmuch: the second question is easier so I'll handle that first.

[15:34] <autrijus> nothingmuch: "Reader" would be pure.

[15:34] <autrijus> it's just a monad.

[15:34] <autrijus> "ReaderT" however transforms another monad

[15:34] <autrijus> in this instance IO

[15:34] <autrijus> and imbue it with extra super power

[15:34] <autrijus> so you can both "print" and "ask".

[15:35] <autrijus> if it was a single "Reader" you could not print.

[15:35] <autrijus> because it's not IO.

[15:35] <autrijus> nothingmuch: now, the hard part. how does Reader implement the lexical behaviour?

[15:36] <autrijus> newtype Reader r a = Reader { runReader :: r -> a }

[15:37] <autrijus> this defines a reader of "r" that computes type "a"

[15:37] <autrijus> what is the signature of runReader?

[15:37] <svnbot6> r4404, autrijus++ | * fixes from cognominal and theorbtwo to hw2005

[15:38] <autrijus> let's recall that, in definition like

[15:38] <autrijus> data Interp = Interp { dick :: Dict }

[15:38] <autrijus> er, typo ;)

[15:39] <autrijus> data Interp = Interp { dict :: Dict }

[15:39] <autrijus> the "dict" accessor is of type

[15:39] <autrijus> dict :: Interp -> Dict

[15:39] <autrijus> so, similarily, runReader would have type

[15:39] <nothingmuch> freudian finger slip

[15:39] <autrijus> runReader :: Reader r a -> r -> a

[15:39] <autrijus> yup

[15:40] <nothingmuch> isn't that runReader r a -> (r -> a)?

[15:40] <nothingmuch> oh wait, it doesn't matter

[15:40] <autrijus> yeah.

[15:40] <nothingmuch> *blush*

[15:40] <autrijus> this is the autocurrying haskell after all

[15:41] <autrijus> so we can read out that type:

[15:41] <autrijus> runReader takes a computation in the Reader monad that reads type r and yield type a

[15:41] <autrijus> and an initial environment r

[15:41] <autrijus> and runs the computation to yield a.

[15:41] <autrijus> clear?

[15:41] <nothingmuch> i think

[15:42] <nothingmuch> what does `asks` look like?

[15:42] <autrijus> asks f = do { r <- ask; return (f r) }

[15:42] <autrijus> so maybe you'd like to learn what "ask" look like for "Reader r a".

[15:42] <autrijus> surprisingly, the defintion is

[15:42] <autrijus> ask = Reader id

[15:42] <autrijus> that's all.

[15:43] <autrijus> understanding it will instantly enlighten you to the theta level 11.

[15:43] <autrijus> er, I mean, to the reader monad.

[15:43] <autrijus> let's look at an concrete example.

[15:45] <autrijus> askInterp :: Reader Interp Interp

[15:45] <autrijus> askInterp = ask

[15:45] <autrijus> runReader askInterp someInterp

[15:45] <autrijus> this will yield... someInterp.

[15:46] <autrijus> askInterp is "Reader id"

[15:46] <autrijus> which is

[15:46] <autrijus> Reader { runReader = id }

[15:46] <autrijus> so "runReader askInterp" turns out to be reading that field out again.

[15:46] <autrijus> runReader (Reader { runReader = id })

[15:46] <autrijus> is just id

[15:47] <autrijus> so that computation turns out to be

[15:47] <autrijus> "id someInterp"

[15:47] <nothingmuch> okay

[15:47] <nothingmuch> maybe

[15:47] <autrijus> finally we ponder "local" :D

[15:48] <autrijus> local f m = Reader (runReader m . f)

[15:48] <autrijus> ask = Reader id

[15:48] <autrijus> so what "local" does is that it constructs a new Reader

[15:49] <autrijus> if the body of the reader is "runReader m"

[15:49] <autrijus> say

[15:49] <autrijus> notLocal m = Reader (runReader m)

[15:49] <autrijus> that may be written as

[15:50] <autrijus> notLocal m = (Reader . runReader) m

[15:50] <autrijus> that may be written as

[15:50] <autrijus> notLocal = Reader . runReader

[15:50] <autrijus> which means

[15:50] <autrijus> notLocal = id

[15:50] <autrijus> yay. ;)

[15:50] <autrijus> but "local" is unlike "notLocal"

[15:51] <autrijus> "notLocal" simply runs the "m" computation and re-return the result

[15:51] <autrijus> "local" however, puts the initial function thru "f" first, before handing it to "runReader m"

[15:52] <autrijus> so it means that saying "local (+1) someComputation" will pretend to run that someComputation

[15:52] <autrijus> but before it runs it via runReader, it prepends the environment with (+1)

[15:53] <autrijus> then hand the modified environment with someComputation to runReader.

[15:53] <nothingmuch> what would be the type of someComputation?

[15:53] <autrijus> so that's why the change is lexical; there is no mutable variable involved.

[15:54] <autrijus> the type of someComputation is

[15:54] <nothingmuch> wait, does it matter?

[15:54] <nothingmuch> eek, too much data

[15:54] <autrijus> Reader someNumType someReturnType

[15:54] <autrijus> the someNumType is there to make (+1) make sense :)

[15:55] <nothingmuch> yeah, that much i gathered

[15:55] <autrijus> the type "Reader Interp Literal" can be understood as a function that turns Interp into Literal.

[15:56] <autrijus> will that make it easier to understand?

[15:56] <clkao> hola autrijus

[15:56] <autrijus> instead of thinking Interp as environment

[15:56] <autrijus> think of it as initial input.

[15:56] <autrijus> strangely, that's what you've always been doing!

[15:56] <autrijus> as your eval functions all begin with (Interp -> ...)

[15:56] <nothingmuch> hmm

[15:56] <autrijus> and "local" is like taking a

[15:56] <autrijus> Interp -> Interp

[15:56] <autrijus> and a

[15:57] <autrijus> Interp -> Foo -> Bar

[15:57] <nothingmuch> i need to re-read this more slowly, too hungry to think clearly right now

[15:57] <autrijus> and gives you back something that is still

[15:57] <autrijus> Interp -> Foo -> Bar

[15:57] <autrijus> but underneath it takes the first argument, transform it using that Interp->Interp

[15:57] <autrijus> then re-hand the modified interp to the second argument, the original Interp->Foo->Bar

[15:57] <autrijus> and return its result as the result.

[15:58] <nothingmuch> so actually why is it necessary?

[15:58] <autrijus> why was Reader neccessary?

[15:58] <nothingmuch> yes

[15:58] <nothingmuch> just to move this out of the param list?

[15:58] <autrijus> uh, it's not "just" :)

[15:59] <autrijus> by moving it out of the param list, you decouple the (Interp->) context from the underlying implementation.

[15:59] <nothingmuch> hmm

[15:59] <nothingmuch> ook

[15:59] <autrijus> so the same evaluation code, composed with "ask" and "local"

[15:59] <nothingmuch> okay, i need to try it

[15:59] <nothingmuch> i'll bbiab though

[15:59] <autrijus> can be re-used in different monads.

[16:00] <nothingmuch> and i'll continue in 10 mins

[16:00] <autrijus> it can be used in a pure context that involves no IO

[16:00] <autrijus> or it can be used on top of IO via ReaderT

[16:00] <nothingmuch> hmm

[16:00] <autrijus> or even as a compiler that emits parrot code!

[16:00] <nothingmuch> aha

[16:00] <autrijus> see, in the Compile monad

[16:00] <autrijus> "ask" would actually produce some PIR code.

[16:01] <nothingmuch> how does that compare to making Interp a polymorphic thingy?

[16:01] <autrijus> you mean something like

[16:01] <nothingmuch> Interp = RuntimeInterp | ParrotEmitter ?

[16:01] <autrijus> interpret :: (InterpThingie i) => i -> Forth -> IO Interp ?

[16:01] <autrijus> bzzt, because that IO is still there

[16:02] <nothingmuch> ok, i think i get it

[16:02] <autrijus> there's no way to reuse "interpret"

[16:02] <nothingmuch> okay, i'll try to wrap my head around this in a bit

[16:02] <autrijus> because it's fixed in a rigid abstraction layer :)

[16:02] <autrijus> cool. but in implementation it's actually dead simple. I'll try to nopaste something before I sleep :)

[16:02] <nothingmuch> okay

[16:03] <nothingmuch> put "spoiler" in the title

[16:03] <nothingmuch> i want to try before reading

[16:03] <autrijus> lol. ok

[16:06] * gaal|work shudders

[16:07] <gaal|work> i was interrupted an hour ago by a new coworkre

[16:07] <theorbtwo> Why is that shudderable?

[16:07] <gaal|work> gave him a spiel on perl5 symbol tables, runtime sub wrapping,

[16:07] <gaal|work> dynamic class generation etc

[16:07] <gaal|work> then i showed him perlmonks

[16:07] <gaal|work> then i showed him wikipedia

[16:08] <theorbtwo> Oh, that reminds me, I wanted to get the symbol table hashes working.

[16:08] <theorbtwo> %MY:: and friends.

[16:08] <gaal|work> (i'm a wandery kinda guide)

[16:08] <gaal|work> here comes the shudderable part:

[16:08] <gaal|work> after showing him PM and wikipedia, he came up with the briliant idea of SPAMMING ONLINE COMMUNITIES! yes.

[16:08] <theorbtwo> Ugh.

[16:09] <gaal|work> you can advretise cheaply *and* increase your google ranking!

[16:09] <theorbtwo> Did he suggest putting up advertising, or really spamming?

[16:09] <theorbtwo> There's at least /something/ of a difference.

[16:09] <gaal|work> the real thing.

[16:09] <theorbtwo> Uggh.

[16:09] <gaal|work> he's still convinced he thought of an excellent idea!

[16:10] <gaal|work> shudder!

[16:10] <gaal|work> anyway, theorbtwo, if you do add symtable stuff, i'm appy to inform you there are already some tests for this.

[16:10] <theorbtwo> Oooh, good!

[16:11] <theorbtwo> Where?

[16:11] <gaal|work> symtable.t

[16:11] <gaal|work> in syntax/ i think

[16:11] <autrijus> nothingmuch: you gave identical implementation of DUP and OVER

[16:11] <theorbtwo> Ah: ./syntax/symbol_table.t:

[16:11] <autrijus> that can't be right

[16:11] <theorbtwo> Oh, there's a new chapter?

[16:11] <autrijus> theorbtwo: in hw2005?

[16:12] <gaal|work> they don't include the (undecided) hierarchical symbolic lookups mentioned somewhere in the Syns

[16:12] <theorbtwo> No, for harroth.

[16:12] <gaal|work> you may want to hit p6-l on that

[16:15] <gaal|work> oh: s02 sayeth

[16:15] <gaal|work> Package names are searched for from inner lexical scopes to outer, then from inner packages to outer.

[16:16] <gaal|work> tricky.

[16:16] <gaal|work> this is for $::( )

[16:16] <gaal|work> i didn't write tests for that, though, to2.

[16:17] <theorbtwo> Gaal: I'm not sure that's related.

[16:17] <gaal|work> symbolic lookup.

[16:17] <gaal|work> not symtable

[16:17] <gaal|work> symhash is always a hard comparison

[16:18] <theorbtwo> Well, the first thing to do is to make ruleVarNameString accept that variable names can end in a ::.

[16:19] <iblech> ...but only if the sigil is %, right? Or is $bar:: allowed?

[16:20] <theorbtwo> iblech: I don't know.

[16:20] <autrijus> nothingmuch: [SPOILER] http://autrijus.org/tmp/readerT-spoiler.txt

[16:21] <autrijus> we'll talk about writerT tomorrow ;)

[16:22] <pasteling> "autrijus" at 220.132.132.105 pasted "[SPOILER] ReaderT for Harrorth" (74 lines, 1.9K) at http://sial.org/pbot/10747

[16:22] <autrijus> the code is much, much cleanr.

[16:22] <autrijus> (as one would expect from a monadic transformer)

[16:23] <autrijus> need to sleep now. see you tomorrow. :) &

[16:24] <autrijus> nothingmuch: oh, another answer for the "why monad?" question. imagine if Parsec is implemented as a simple

[16:25] <autrijus> parse :: String -> Tokens

[16:25] <autrijus> combinator. that would not be very composable; it'd be impossible to add user state; there would be no way to decouple the input token type with output token type

[16:25] <autrijus> and most imporatntly, things like <|> cannot be reused at all.

[16:26] <autrijus> as you need to define a <|> for each combination of UserState -> InputStream -> SourcePosition -> OutputToken function type.

[16:32] * theorbtwo wonders why the haddocks of Parsec do not include the information from the reference guide at http://www.cs.uu.nl/~daan/download/parsec/parsec.html#ReferenceGuide.

[17:02] <theorbtwo> Sigh; I have been corrupted by perl.

[17:02] <theorbtwo> I keep trying to write '...' strings in my Haskell.

[17:06] <theorbtwo> Odd.

[17:06] <theorbtwo> I just made what seems like a very simple change, and started a make test run.

[17:06] <theorbtwo> Now there seems to be a very very long (several seconds?) startup delay.

[17:33] * theorbtwo wonders why adding a option "" (string "::") just before the end of Pugs.Parser.ruleVarNameString doesn't do what I want in the slightest.

[17:34] <theorbtwo> It seems to return "" if there isn't a ::, and die if there is... That is, %x parses as before, and %x:: dies with a syntax error.

[17:35] <theorbtwo> I've got no clue where to begin debugging this, other then to note that it's not just completely ignoring it, since option "x" (string "::") works as I expect.

[17:40] <theorbtwo> Bah.

[17:41] <iblech> try: option "" (try $ string "::") -- but I'm just guessing

[17:54] <gaal> hey, if something :: Int, to turn it into a VInt shouldn't I just "VInt something"?

[17:55] <gaal> ah, do i need toInteger?

[17:58] <gaal> ah: yes. don't you love solving yer own damn problems? :-p

[18:38] <gaal> yippie! caller works on the internals side.

[18:39] <gaal> what is the P6 type of the object that caller returns? (that has methods sub, line, etc.?)

[18:41] <iblech> Don't think that has been speeced yet. Just pick an appropriate type, e.g. Caller or so

[18:42] <gaal> eval in S29 is blessed into Control::Basic. maybe I should pick Control::Caller then?

[18:44] <gaal> hmm, this is the first oop builtin! :) does "has" and BUILD actually work now, iblech?

[18:44] <iblech> Sounds reasonable

[18:44] <svnbot6> r4405, gaal++ | caller, internals side

[18:44] <iblech> IIRC, they both work

[18:45] <gaal> cool. i forsee a flourish of Prelude commits as people discover this fact :)

[18:45] <iblech> :)

[18:46] <gaal> actually pipe can be refactored now in light of this.

[18:47] <gaal> oh, maybe not, since not having weak refs will spoil the fun of having the object contain itself.

[19:01] <gaal> i want to use zip to construct a hash. how?

[19:02] <gaal> map { $^a => $^b}, @a, @b won't work, would it?

[19:02] <gaal> errr

[19:02] <gaal> @a Y @b that is

[19:05] <iblech> map { $^a => $^b; } @a Y @b

[19:05] <iblech> (I think.)

[19:05] <gaal> no go in current pugs

[19:06] <gaal> "undeclared variable: $b"

[19:06] <gaal> sucks, because i never mentioned $b

[19:06] <gaal> i mentioned $^b

[19:06] <iblech> $^X is $X internally

[19:06] <integral> hmm, I thought that'd been fixed.   You just have to use pointy subs for now

[19:06] <gaal> ?eval map -> $k, $v { $k => $v }, (1,2,3) Y (<o t th>)

[19:06] <evalbot6> ((1 => 2), 'o', (3 => undef), 't', undef, 'th') 

[19:07] <gaal> oops :)

[19:07] <iblech> ?eval map { ;$^k => $^v } (1,2,3) Y (<o t h>)

[19:07] <evalbot6> Error:  unexpected "{" expecting "::", ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[19:07] <iblech> ?eval map { ;$^k => $^v }, (1,2,3) Y (<o t h>)

[19:07] <evalbot6> Error:  unexpected "{" expecting "::", ":", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[19:07] <iblech> meh

[19:07] <gaal> beh

[19:07] <iblech> Ah, old evalhelper.p5

[19:07] <gaal> urgh?

[19:08] <gaal> shto eta?

[19:08] <iblech> the old evalhelper.p5 escaped ^ incorrectly

[19:08] <iblech> therefore, $^X doesn't work in ?eval

[19:08] <gaal> doesn't workforme in interactive pugs.

[19:08] <gaal> (undeclared $v)

[19:09] <iblech> pugs> map { ;$^k => $^v }, (1,2,3) Y (<o t h>)

[19:09] <iblech> ({ref:<Pair>}, 'o', {ref:<Pair>}, 't', undef, 'h')

[19:09] <gaal> that's the br0kage.

[19:11] <gaal> after fixing this we can be cute and write a List::Utils func called 'vk', so called because it does the opposite of %hash.kv

[19:14] <gaal> okay, the more practical question then:

[19:14] <gaal> my internals function returns a list in dependable order, of n values

[19:14] <gaal> they map reliably to n attributes of my prelude class.

[19:15] <gaal> what's the elegant solution to construct an object?

[19:17] <gaal> okay, goind with the inelegant solution.

[19:18] <nothingmuch> phoeey

[19:18] <gaal> wow, must have been so ugly that he really had to leave

[19:23] <gaal> is there a "short zip" operator? zip until one list ends

[19:30] <gaal> if i have class Froop { has $.hop }, shouldn't Froop.new(:hop<111>).hop.say' say 111 ?

[19:30] <gaal> hmmm, it *does* say that. ulp, my problem must be elsewhere.

[19:31] <Aankhen``> Heh.

[19:31] <wolverian> gaal: YY has been proposed, or the other way around.

[19:32] <wolverian> gaal: (Y = until shorter ends, YY = until longer ends. that's more logical, anyway. nothing definite has been decided I think.)

[19:32] <gaal> cool. 0 .. Inf  is infinitely useful.

[19:32] <wolverian> yes.

[19:32] <wolverian> well.

[19:32] <wolverian> since @array.kv works, it's not _as_ useful as without it

[19:32] <gaal> though in *that* particular case,

[19:32] <gaal> yeah.

[19:32] <gaal> even (List).kv works.

[19:33] <wolverian> right. 

[19:33] <gaal> and you can flip (which isn't a builtin in Pair, is it?)

[19:34] <Aankhen``> Is `multi submethod BUILD` acceptable?

[19:34] <gaal> %revidx = flip @arr.kv, 0 .. Inf;

[19:34] <gaal> i keep forgetting to say Y

[19:35] <wolverian> gaal: flip? I don't know that one.

[19:35] <svnbot6> r4406, Aankhen++ | * refactored &HTTP::Message::BUILD.

[19:35] <wolverian> (it's not in S29)

[19:35] <iblech> Aankhen``: I think so, although I've never seen multi submethod

[19:36] <Aankhen``> iblech >> Check the new versions of &HTTP::Message::BUILD and you'll see it. ;-)

[19:36] <iblech> Jep, just done :)

[19:37] <Aankhen``> ^_^

[19:37] <Aankhen``> (using a type junction and the smartmatch operator was looking ugly to me)

[19:38] <iblech> Think so, too

[19:40] <Aankhen``> Do you think you could take a look at the &content method and offer a better way of doing it? :-)

[19:40] <svnbot6> r4407, Aankhen++ | &HTTP::Message::BUILD -- be more explicit about assigning properties.

[19:42] <iblech> Ah... I think you've have to "my multi sub FETCH (...) {...}", and then "new Proxy: FETCH => &FETCH"

[19:42] <iblech> But I think in this case, it isn't worth it

[19:44] <Aankhen``> What would be worth it?

[19:46] <Aankhen``> Er... should I be using $:foo instead of $.:foo?

[19:46] <svnbot6> r4408, Aankhen++ | * &HTTP::Message::parse -- small changes for (hopefully) better code.

[19:46] <svnbot6> r4408, Aankhen++ | * marked &HTTP::Message::content as C<is rw>.

[19:46] <iblech> I mean, it's ok to ~~ in this case, as the subs aren't large and there's only one distinction (want ~~ List or want !~ List). You *could* refactor this using lexical multisubs, but I'd leave it as it is

[19:46] <iblech> IIRC $:foo is correct

[19:46] <gaal> k, need some internals help. my internals caller returns a list, which i can print and which so far looks correct.  but when i try doing fancy stuff with this list on the perl stuff, eg map, i get this:

[19:46] <Aankhen``> OK.

[19:46] <Aankhen``> Thanks for both answers. :-)

[19:47] <gaal> cannot cast from VList [VStr "",VStr "file",VStr "line",VStr "package" ,VStr "subname",VStr "subtype"] to Pugs.AST.Internals.VCode

[19:47] <iblech> What's the snippet which yields this error?

[19:47] <gaal> oh wait, this probably has nothing to do with the internals side.

[19:47] <gaal> here:

[19:48] <desis> Hello

[19:48] <pasteling> "gaal" at 192.115.25.249 pasted "blow" (15 lines, 680B) at http://sial.org/pbot/10753

[19:49] <Aankhen``> iblech++ # helpful as always!

[19:49] <gaal> (incidentally: for some reason i can't put %idx outside that sub)

[19:50] <Aankhen``> perlbot karma iblech

[19:50] <perlbot> Karma for iblech: 414

[19:51] <desis> any know wht is cpan used for

[19:51] <desis> please

[19:54] <iblech> gaal: Try say %idx.perl -- I think %idx is not really a hash or so

[19:54] <svnbot6> r4409, Aankhen++ | * HTTP::Message -- n00b mistake, s:P5/\$.:/$:/

[19:54] <svnbot6> r4409, Aankhen++ | * fixed &HTTP::Message::add_content.

[19:54] <svnbot6> r4409, Aankhen++ | * cleaned up &HTTP::Message::content_ref somewhat.

[19:54] <svnbot6> r4410, Aankhen++ | * added stringification for HTTP::Message.

[19:54] <svnbot6> r4410, Aankhen++ | * fixed stringification overload for HTTP::Headers (I hope).

[19:55] <gaal> my bad  -  that first line wasn't crashing; the one after w/o the leading semicolon was.

[19:55] <gaal> sorry, just noticed myself.

[19:56] <iblech> ah, k

[19:56] <gaal> coding to beat fatigue causes fatigue causes slowness causes to lose against fatigue.

[19:56] <iblech> desis: CPAN is the Comprehensive Perl Archive Network, a large collection of Perl software and documentation. You can begin exploring from either http://www.cpan.org/, http://www.perl.com/CPAN/ or any of the mirrors listed at http://www.cpan.org/SITES.html and http://mirror.cpan.org/.

[19:57] <iblech> desis: (Got that from http://cpan.org/misc/cpan-faq.html)

[19:57] <iblech> ;)

[20:04] <svnbot6> r4411, Aankhen++ | * HTTP::Message -- small formatting changes, bumped up version number.

[20:07] <iblech> Aankhen``++ # hacking on libwww-perl :)

[20:09] <Aankhen``> Heh, I've only resumed after a fairly long hiatus.

[20:09] <svnbot6> r4412, Aankhen++ | * HTTP::Message -- uncomment delegation since it apparently parses alright.

[20:14] <iblech> Gonna sleep, cu tomorrow :)

[20:14] <gaal> caller(5555), if there's no such stack frame, returns undef.

[20:15] <gaal> problem is, often people would like to do caller(5555).line

[20:15] <gaal> should i let that raise an exception on undef, or should i have a dummy object created?

[20:15] <gaal> probably let it raise an exception, right?

[20:18] <gaal> caller in, /me off

[20:19] <gaal> night everybody! zzzZZZ &

[20:20] <svnbot6> r4413, gaal++ | caller, Perl side. Please add tests to t/builtins/caller.t

[20:33] <svnbot6> r4414, Aankhen++ | * HTTP::Headers -- :parts should be an array, not a scalar.

[20:33] <Aankhen``> Oh bleh.

[20:33] <Aankhen``> That should have been HTTP::Message.

[20:39] <Aankhen``> G'night.

[20:39] <svnbot6> r4415, Aankhen++ | * &HTTP::Message::parts should respect :parts being an array.

[21:09] *** Limbic_Region_ is now known as Limbic_Region

[21:33] <Corion> I have an old smoke report at http://datenzoo.de/pugs/win2k.html - r4404 - some unexpected successes in Test::Builder, but also some breakage of pugsbugs/ and pugsrun/ and File::Spec::Win32 that shouldn't happen... May be out of date, but a smoke run takes 40 minutes here and I'm going to bed now :)

[21:33] <Corion> Good night ;)

[22:01] <flgr> I guess this is getting asked a lot right now, but what about the future -- will perl6 officially switch over to pugs completely until it is self-hosting?

[22:02] <theorbtwo> Once it is self-hosting, you mean?

[22:02] <obra> That's not quite the right questoin

[22:02] <obra> question.

[22:02] <theorbtwo> I don't know, flgr.

[22:02] <theorbtwo> I also don't know if it much matters.

[22:02] <obra> pugs is _an_ implementation of perl6. At the moment, it's the most solid and the most complete.

[22:03] <obra> The eventual intent is to have perl6 written in perl6 on a parrot virtual machine.

[22:03] <obra> Certainly one of pugs aims is to be able to compile perl6 source code to parrot bytecode running on the parrot virtual machine.

[22:04] <obra> at that point, someone could "easily" implement perl6 in itself, making the haskell implementation (pugs) unnecessary.

[22:04] <flgr> obra: I am just not sure how Larry Wall will react so I am wondering how all this is going on

[22:05] <obra> flgr: larry is fascinated by pugs and seems quite excited by it.

[22:05] <obra> He's been giving lots of language-design support to autrijus and the rest of the pugs team

[22:05] <flgr> ah, that is good to know

[22:05] <wolverian> I just wish he could work more on perl6.

[22:05] <obra> larry will be at the pugs hackathon in toronto later this month

[22:06] <flgr> hm, could parrot be implemented in perl6 (the non-parrot-bytecode version) as well?

[22:06] <flgr> OTOH that would be starting over from scratch

[22:07] <theorbtwo> We could write a haskell to perl6 compiler, probably with a helper module.

[22:07] <theorbtwo> Or we could write a haskell to pasm compiler, which is looking somewhat more reasonable.

[22:07] <flgr> that is an interesting idea

[22:08] <flgr> I just hope that parrot will still somehow be completed -- having dynamic languages talk to each other would be very wonderful indeed

[22:08] <theorbtwo> It would be.

[22:08] <theorbtwo> parrot is pretty well along.

[22:08] <theorbtwo> What it's missing is sometimers that target it.

[22:10] <theorbtwo> Er, compilers.

[22:20] <SamB> did you change words three times in midword?

[22:29] <theorbtwo> Just two -- some compilers.

[22:29] <SamB> oh, oh, yeah, two. I got mixed between three changes and three words

[23:17] *** MrKrueger is now known as _meppl_

[23:35] *** _meppl_ is now known as meppl

[23:57] <stevan> I assume no release today :)

