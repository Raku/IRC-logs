[00:05] <Juerd>   Str ?$ircname  = $nick,

[00:05] <Juerd>   Str $host,

[00:05] <Juerd>   Int ?$port          = 6667,

[00:05] <Juerd> How is this valid? I thought mixing zones was impossible?

[00:05] <Juerd> (I can't think of a way to interpret this!)

[00:05] <arcady> that can't possibly be valid

[00:06] <Epix> can i have perl6 now? how far is pugs?

[00:06] <Juerd> (Still, very impressive, that Net::IRC)

[00:06] <Juerd> Epix: Yes, you can. Far enough to write useful stuff in.

[00:06] <Limbic_Region> Epix - see http://pugscode.org

[00:06] <arcady> well... actually it could possibly be valid, but not according to the documentation as I've seen it

[00:06] <Juerd> Epix: For example, today, Net::IRC was ported to Perl 6

[00:06] <Juerd> Epix: http://svn.openfoundry.org/pugs/ext/Net-IRC/lib/Net/IRC.pm

[00:06] <Juerd> (I was just reading it)

[00:06] <Epix> Juerd: thats cool.

[00:07] <stevan> any lambda folk about?

[00:07] <Epix> what about POE? is there that for perl6

[00:07] <stevan> Epix: nope

[00:07] <nothingmuch> Epix not quite

[00:07] <Epix> what is lambada. is it the MOO?

[00:07] <Epix> is there a cgi for it

[00:07] <Epix> or mod_perl

[00:07] <nothingmuch> lambda refers to functional programming

[00:07] <Juerd> Epix: Note that since Pugs doesn't support OO yet, hashes of closures are used instead. That works very well with Perl 6's syntax :)

[00:07] <stevan> Epix: lambdafolk == Haskell programmer

[00:07] <nothingmuch> pugs is implemented in haskell

[00:07] <Juerd> (It works for Javascript too!)

[00:08] <stevan> Epix: there is CGI

[00:08] <Juerd> Epix: See http://pugs.kwiki.org/?Perl6Nomenclature

[00:08] <nothingmuch> and as for CGI - there's a nice example of a memory game CGI

[00:08] <nothingmuch> and stevan has written CGI.pm

[00:08] <stevan> http://svn.openfoundry.org/pugs/ext/CGI/lib/CGI.pm

[00:08] <stevan> Epix: and work has begun on mod_pugs

[00:09] <Epix> stevan: and later, mod_perl6?

[00:09] <nothingmuch> this thing looks yummy: http://www.wallbike.com/Conquest.html

[00:09] <stevan> Epix: more than likely mod_perl6 will be mod_parrot

[00:09] <arcady> there was a mod_parrot at some point

[00:09] <stevan> arcady: it is still alive and well

[00:09] <arcady> ah, that's good to know

[00:10] <Epix> woah. so all of parrot will be usable with apache

[00:10] <stevan> arcady: jhorowitz (of mod_parrot fame) is working with autrijus to get parrot embedded in pugs

[00:10] <stevan> Epix: I think that is the plan

[00:10] <stevan> so you can have mod_(perl|python|ruby|scheme|CommonLisp) in one app

[00:11] <Juerd> stevan: Please stop now, before I ejaculate spontaneously :)

[00:11] <Odin-LAP> Juerd: What strange paraphilias you must have...

[00:11] <arcady> don't forget brainfuck

[00:12] <arcady> you can write a cgi in brainfuck!

[00:12] <arcady> now that would be... unique

[00:12] <Odin-LAP> Yes, please. Forget brainfuck. Otherwise you'll go nuts.

[00:12] <Juerd> My brain is fucked already.

[00:12] <Odin-LAP> Juerd: By whom?

[00:13] <Juerd> Childhood experiences

[00:13] <Juerd> Let's not discuss the details

[00:13] <Odin-LAP> I ... see.

[00:14] <Juerd> Then you are not yet blind.

[00:14] <nothingmuch> in hebrew to fuck someone's brain means to yack

[00:14] <stevan> Juerd: Describe in single words, only the good things that come in to your mind about: your mother.

[00:15] <Juerd> stevan: I can't possibly describe the good things about my parents in single words. They are wonderful people.

[00:15] <stevan> Juerd: (bladerunner reference)

[00:15] <Juerd> We don't always get along, of course. I think that's normal.

[00:19] * Limbic_Region feels like yacking

[00:19] <Limbic_Region> not to be confused with yack shaving

[00:19] <Juerd> What is that?

[00:20] <Limbic_Region> yacking = vomiting

[00:20] <Juerd>   yack

[00:20] <Juerd>        n : noisy talk [syn: {yak}, {yakety-yak}, {chatter}, {cackle}]

[00:20] <Juerd>        v : talk incessantly and tiresomely [syn: {jaw}, {yack away}, {rattle

[00:20] <Juerd>            on}, {yap away}]

[00:20] <Juerd> Why do you feel like vomiting?

[00:21] <stevan> Limbic_Region: I wrote a basic Config::Tiny test suite based on your SYNOPSIS

[00:21] <stevan> dont know if you saw yet

[00:21] <nothingmuch> what I meant by yacking is not vomiting, but what Juerd defined

[00:21] <stevan> so brain fuck in hebrew is to talk incessantly?

[00:21] <stevan> how odd

[00:22] <Odin-LAP> Them hebrew-speakers are odd. Like everyone else.

[00:22] <stevan> although maybe it does make sense,.. brain-fuck == mess with someones mind

[00:25] <Epix> lemme get this straight

[00:25] <Epix> perl6 will be compiled with pugs

[00:25] <Epix> the perl6 program itsself

[00:25] <stevan> Epix: Pugs is a perl6 interpreter

[00:25] <stevan> we will use it to bootstrap the perl6 compiler

[00:25] <stevan> which will be written in perl6

[00:26] <Epix> stevan: why do that

[00:26] <stevan> Epix: cause it is fun :)

[00:26] <Epix> no, really... why

[00:26] <stevan> Epix: honestly, I have no idea why that way is better than other ways

[00:26] <Epix> lol

[00:27] <stevan> actually I do,... on a very basic level

[00:27] <Epix> maybe because then the compiler will run anywhere perl6 will run?

[00:27] <stevan> it makes it much easier to port to other platforms

[00:27] <stevan> Epix: exactly

[00:27] <Odin-LAP> Perl6 wants to be like most other languages ... self-supporting!

[00:27] * stevan is not the compiler guy, just the test guy

[00:27] <Epix> will p6 benchmark faster than p5?

[00:28] <stevan> Epix: some early tests autrijus did with compiling to Parrot actually were faster than p5

[00:28] <stevan> Epix: I imagine that in some ways perl6's speed will be bounded by parrot's speed

[00:29] <Epix> ok so faster :D

[00:29] <stevan> Epix: i hope so :)

[00:29] <stevan> although perl5 isnt really that slow

[00:29] <stevan> it is comparable to Java in many situations

[00:29] <Epix> stevan: can you compile pytyon/ruby/CLisp to parrot yet?

[00:29] <stevan> of course Java can be slow as dirt, so thats not much of a comparison

[00:29] <stevan> Epix: I have no idea, that a question for #parrot :)

[00:30] <Odin-LAP> There is some ongoing work.

[00:30] <arcady> at least with python and CLisp, not so much with ruby

[00:31] <Odin-LAP> I think Common Lisp is actually the most active...

[00:32] <arcady> or just the most recent

[00:32] <Odin-LAP> Heh. Might be. :)

[00:32] <arcady> people haven't gotten bored or found better things to do

[00:32] <Limbic_Region> stevan - thanks - I really appreciate it

[00:32] <Limbic_Region> I have come down a bit under the weather

[00:32] <Odin-LAP> arcady: Better than Lisp? ;>

[00:32] <Limbic_Region> don't think I will be playing at all tomorrow

[00:33] <Epix> whats the job market for perl

[00:33] <arcady> yes.

[01:11] <Epix> hmm

[01:11] <Epix> it looks like perl6 could make perl huge or break it.

[01:12] <Epix> well not so much break it

[01:12] <puetzk> stevan: revision - pugs does embed parrot now

[01:13] <puetzk> as of r2750, 2005-05-05 15:20:07 -0500 :-)

[01:13] <puetzk> you are forgiven for not being able to keep up :-)

[01:20] <Limbic_Region> oh no

[01:20] <Limbic_Region> something doesn't look right

[01:20] <Limbic_Region> I sure hope I didn't fuck up

[01:21] <Limbic_Region> I just checked in a test for a bug in //= autovivication and svk is committing many many revisions???

[01:22] <puetzk> Limbic_Region: thus far I see one revision from you...

[01:22] <puetzk> r2764 | Limbic_Region | 2005-05-05 20:19:23 -0500 (Thu, 05 May 2005) | 1 line

[01:22] <puetzk> Changed paths:

[01:22] <puetzk>    M /t/operators/assign.t

[01:22] <puetzk> Test for //= autovivication bug

[01:23] <Limbic_Region> oh - so must be local sync then

[01:23] * Limbic_Region is quite new to this stuff

[01:23] <puetzk> yeah, svk would have to sync/smerge up to HEAD before it could commit

[01:23] * Limbic_Region could have swore he synced before modifying the test

[01:23] <Limbic_Region> *shrug*

[01:24] <Limbic_Region> that's only 1 of the 2 confirmed bugs I found today

[01:24] <Limbic_Region> the other one I am not sure how to test

[01:25] <Limbic_Region> if you write to a file but don't close it - the update is not reflected in the file even after the program ends

[01:26] <puetzk> hmm. system("pugs",...) and then check the file contents?

[01:26] <Limbic_Region> well if the *proper* behavior is to flush/write at end of scope - it is easier to test

[01:26] <Limbic_Region> but I am not sure - I just know what it is doing right now isn't right

[01:27] <puetzk> indeed. flush should happen when the filehandle is finalized, if not before

[01:27] <puetzk> but I don't think pugs has any way to force a gc sweep

[01:27] <puetzk> (nor am I sure what pugs has for memory managent in general when not using parrot)

[01:28] <Limbic_Region> right

[01:29] <Limbic_Region> so it boils down to having the single test broken out over two test files

[01:29] <Limbic_Region> 1 to write the file

[01:29] <Limbic_Region> the second to read

[01:30] * Limbic_Region is checking existing io tests now to see if he can piggy back

[01:32] <Limbic_Region> yeah - I can just move the unlike in io.t to a new test that is guaranteed to run after

[01:49] <Limbic_Region> puetzk - I added that test too

[01:49] <Limbic_Region> now I just need to investigate the possiblility of 2 other bugs

[01:49] <Limbic_Region> another time perhaps

[01:53] * Limbic_Region calls it a night for the second time

[01:59] <meppl> gute nacht

[04:21] <puetzk> holy Schmiel the painter... I know parrot isn't meant to be optimized yet, but Parrot_byte_index is impressive

[04:22] <puetzk> espescially given how it's used in does_isa (which is itself a not particularly optimal implementation of a seriously slow way to implement isa)

[04:22] * puetzk now has a bit less fear for how parrot intends to close the performance gap between it and perl5

[04:22] <Khisanth> are you sure it's not just your machine? :P

[04:22] <puetzk> Khisanth: looking at oprofile :-)

[04:22] <puetzk> and at the code

[04:24] <Khisanth> ooh PGE, PUGS will have P6 Rules RSN? :)

[04:24] * puetzk has "hmm, is this really the hotspot?" patch that makes mandel.p6 40% faster, but I wonder if there's some larger scheme afoot - there must be some reason for it to be this bad besides neglect :-)

[04:27] <puetzk> even with it in place, isa checks are still directly account for 10% of the runtime

[04:47] <Khisanth> puetzk: that sounds pretty bad

[04:51] * puetzk can post the patch after he's done eating

[04:51] <puetzk> it's very small

[05:25] <puetzk> hmm, or perhaps not; the test failures aren't what I thought they were

[05:26] <puetzk> apparently there's a real bug in it :-P

[05:28] <puetzk> yup

[05:29] <puetzk> durn testsuite :-P

[05:29] <puetzk> or not

[06:16] * puetzk is away: zzz

[07:08] *** chady_ is now known as chady

[07:48] *** chady is now known as Every-one

[07:48] *** Every-one is now known as chady

[08:04] <autrijus> puetzk: I want your patch :)

[08:28] <bsb> What is the inverse of zip called?  part?

[08:28] <bsb>  -> ?

[08:32] <autrijus> not sure there is one

[08:38] <bsb> I can't find it, maybe I imagined it

[08:44] *** decay is now known as decay_

[08:47] <mj> mj hates linking problems

[08:48] <mj> perlbot nopaste

[08:48] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[08:50] *** b6s_ is now known as b6s

[08:54] <pasteling> "mj" at 147.229.221.107 pasted "Win32 Makefile.PL sub parrot_config - works for me" (13 lines, 375B) at http://sial.org/pbot/9959

[08:56] <autrijus> I tweaked it a bit

[08:56] <autrijus> and committed as r2767

[09:07] <scook0> ooh, looks like someone put all the poetry into haddock

[09:11] <autrijus> I'd be that someone :)

[09:17] <bsb> Is helping to fill in the haddock docs any appropriate haskell newbie task?

[09:18] <autrijus> sure!

[09:18] <scook0> That's what I'm doing

[09:18] <autrijus> as long as you commit fast enough, there's little chance of duplicating work :)

[09:18] <autrijus> scook0: and I *heart* you for it :)

[09:18] <autrijus> scook0++

[09:19] <autrijus> without haddock I can't refactor anything

[09:19] <autrijus> that was partily what caused the AST.hs huge bloat

[09:19] <autrijus> now I can finally put the dependency graph in my mind and think about restructuring things

[09:19] <scook0> Actually, I'm surprised at how much of the evaluation I actually understand now

[09:19] <bsb> We if I ever understand anything, I'll be sure to write it up

[09:19] <bsb> I'm getting there, slowly

[09:20] <scook0> What I did was to make printouts of Eval.hs and AST.hs, then study those and make notes

[09:20] <autrijus> bsb++

[09:20] <scook0> Which parts are you looking at?

[09:21] <bsb> I've got a haskell question: why is comine "foldr (.) id" not foldr1 something?

[09:21] <bsb> scook0: I'm bouncing all over the place with vim and hasktags

[09:21] <scook0> My main tool is 'find | xargs grep' :)

[09:21] <autrijus> bsb: because 

[09:21] <autrijus> combine []

[09:22] <autrijus> needs to be 

[09:22] <autrijus> id

[09:22] <autrijus> as there is potentially zero things to combine

[09:22] <bsb> Ok, I couldn't find combine use in that way, but wasn't sure

[09:23] <bsb> Actually, I've been trying to work out how pointy subs can get control exceptions

[09:23] <scook0> autrijus: there was a whole bunch of things I was planning to ask you about pugs internals

[09:23] <autrijus> scook0: sure, ask ahead

[09:23] <scook0> but I've forgotten most of them -- must write them down in future

[09:23] <scook0> :(

[09:23] <autrijus> that's ok :)

[09:24] <bsb> data SubType = SubMethod | SubRoutine | SubPointy | SubBlock | SubPrim

[09:24] <autrijus> yeah, those are "levels" of subroutines

[09:24] <autrijus> of Code, really

[09:25] <bsb> I added SubPointy locally

[09:25] <bsb> doesn't link to anything much yet

[09:25] <scook0> I just commited a little bit of stuff for that

[09:25] <scook0> So now you'll probably get a merge conflict :(

[09:26] <bsb> I think I'll be svn revert-ing anyway

[09:26] <bsb> I was more to try and understand

[09:26] <bsb> s/I/It/

[09:26] <autrijus> bsb: how is Pointy diff. from Block?

[09:26] <autrijus> I thought they are same

[09:26] <bsb> Pointy's do control exceptions

[09:27] <scook0> which control exceptions are you talking about?

[09:27] <bsb> Any set &?BLOCK not &?SUB

[09:27] <bsb> s/Any/And/

[09:27] <bsb> And return doesn't work, returns from outer sub

[09:28] <autrijus> bsb: er. I mean pointy vs block

[09:28] <bsb> scook0: last, redo, etc

[09:28] <autrijus> not pointy vs routine

[09:28] <autrijus> I know how pointy differs vs routine :)

[09:28] <scook0> AFAIK, pointy and block are the same

[09:28] <autrijus> -> $x { say $x }

[09:28] <autrijus> { say $^x }

[09:28] <scook0> block is just a pointy without an explicit arglist

[09:28] <autrijus> I though those two are equiv

[09:28] <autrijus> if so, then we just use SubBlock to represent both

[09:29] <bsb> Yeah, as long as blocks are doing "next" and co

[09:29] <bsb> bare blocks, not just in for/loop/...

[09:30] <bsb> I might have this wrong btw

[09:30] <scook0> isn't the loop responsible for handling &next etc.?

[09:30] <scook0> I think that's how pugs does it (not sure)

[09:30] <bsb> from s06:It also behaves like a block with respect to control exceptions.

[09:30] <scook0> let me consult s06 for a sec...

[09:31] <scook0> "The arrow operator -> is almost a synonym for the anonymous sub keyword,"

[09:31] <autrijus> I think loopish constructs are installed by the loop 

[09:32] <autrijus> not by the block

[09:32] <autrijus> pugs reflects that understanding

[09:32] <bsb> autrijus: pointy vs block,  do they topicalize $_ differently?

[09:32] <autrijus> I may or may not be wrong, but it makes sense to me

[09:32] <autrijus> bsb: no idea... that may be the case

[09:32] <bsb> I'll look for a reference on that

[09:33] <scook0> autrijus: about junctions...

[09:33] <scook0> the extra set (dups) is for /one/ junctions, not /none/ junctions, right?

[09:33] <bsb> A06: "Bare subs" If no placeholders are used, $_ may be treated as a placeholder variable

[09:34] <scook0> the IRC logs quote you as saying 'none', but looking at the code I'm pretty sure you meant to say 'one'

[09:34] <scook0> threw me for a loop though

[09:34] <autrijus> scook0: yup

[09:34] <autrijus> scook0: my thinko

[09:34] <scook0> your thinko is currently enshrined in metaperl's writeup... :(

[09:35] <scook0> but I think my docs explain it

[09:36] <autrijus> scook0: writeup?

[09:37] <scook0> pugs/doc/src/Junc.pod

[09:37] <autrijus> fixed

[09:38] <autrijus> thanks so much

[09:38] * autrijus going to dinner &

[09:38] <scook0> later

[09:39] <scook0> autrijus: when you get back, I have a question about Pads and multisubs

[09:42] <bsb> scook0: What's on you documentation todo list?

[09:43] <scook0> I'm just filling in gaps in AST & Eval at the moment

[09:43] <bsb> Ouch

[09:43] <scook0> dribs and drabs -- nothing big atm

[09:44] <scook0> my biggest problem was trying to understand the AST, without knowing why the parser was generating different bits

[09:48] <bsb> Where does big picture documentation go? (Once you can see it)

[09:49] <scook0> What do you mean by 'big picture' documentation?

[09:50] <scook0> As in, a high-level overview of how a particular module operates?

[09:52] <bsb> Yes, and how modules interoperate

[09:57] <bsb> bye for now

[09:58] <scook0> bye

[10:04] *** Aankh|Clone is now known as Aankhen``

[11:20] <nothingmuch> morning

[11:21] *** chady is now known as chady_

[11:25] <scook0> evening

[11:25] <scook0> :)

[12:54] <stevan> autrijus: ping

[12:56] <puetzk> autrijus: I'll post the speedup on p6i after I get the "" case handled right so it passes tests again

[13:26] <stevan> autrijus++ # for making MMD work (well mostly work, be enough for my needs)

[13:28] <Limbic_Region> salutations all

[13:28] <Limbic_Region> autrijus ping

[13:30] <stevan> Limbic_Region: morning

[13:30] <Limbic_Region> morning

[13:31] * Limbic_Region was just wondering if the two tests he checked in last night to expose the two bugs he found while writing Config::Tiny were ok

[13:31] <stevan> Limbic_Region: which tests?

[13:31] <Limbic_Region> one to assignment.t

[13:32] <Limbic_Region> and a test that had to be spread across two test files

[13:32] <Limbic_Region> so I modified io.t

[13:32] <Limbic_Region> and added io_final.t

[13:32] <stevan> Limbic_Region: I only saw a few .hs files in the last svn update

[13:32] <stevan> so I am not sure

[13:32] <Limbic_Region> this was from last night

[13:33] <Limbic_Region> I did what I thought was right WRT testing them - but still a bit unsure of this stuff

[13:33] <stevan> Limbic_Region: my update was first thing this morning, and before that was about 10pm EST last night

[13:33] <stevan> Limbic_Region: I have to restart my machine, but I will take a look when I am back up

[13:34] * puetzk is away: work

[13:55] <stevan> Limbic_Region: the $fh.say "hello" issue is not really an issue IIRC

[13:55] <stevan> invocant syntax requires parans

[13:55] <stevan> I will see if I can find the reference

[13:58] <Limbic_Region> stevan - are you referring to my journal or to my test?

[13:59] <Limbic_Region> I already spoke with autrijus about this

[13:59] <stevan> your journal

[13:59] <Limbic_Region> yeah

[13:59] <Limbic_Region> I listed everything even if it turned out not to be a bug

[13:59] <stevan> ah

[13:59] <stevan> ok

[13:59] <Limbic_Region> just so others would have the benefit of me learning in public

[13:59] <stevan> so am I correct? or crazy? :)

[14:00] <Limbic_Region> correct

[14:00] <Limbic_Region> parens are required

[14:00] <stevan> :)

[14:00] * stevan was starting to wonder for a second there

[14:00] <Limbic_Region> autrijus confirmed 2 were real bugs and was unsure about 2

[14:00] <Juerd> Say...

[14:00] <Limbic_Region> 2 were confirmed to be proper behavior

[14:01] <Juerd> If :{} can be used without parens

[14:01] <Juerd> Then can the same thing be done for :""?

[14:01] <Juerd> $fh.say:"hello"

[14:01] <Limbic_Region> so I will investigate the 2 in question another time

[14:01] <stevan> Juerd: have you tried it?

[14:01] <Juerd> Although say $fh: "hello" looks awfully alike.

[14:01] <Juerd> stevan: I'm sure this isn't already the spec. I'm thinking out loud.

[14:02] <Juerd> stevan: I'm not wondering whether it is currently possible - I'm sure it's not.

[14:02] <stevan> Juerd: ah

[14:02] <Juerd> I'm wondering whether this would fit in the overall design

[14:02] <Juerd> Though I don't think the required parens make any sense anyhow.

[14:02] * Limbic_Region thinks if you put a reference to a hash A as the value to a key in hash B, you should be able to modify hash A by dereferencing hash B appropriately

[14:03] <Limbic_Region> I am just not sure my syntax at attempting to do it was correct

[14:03] <Juerd> Limbic_Region: WRT references, as long as they're explicit, you can test with perl 5.

[14:03] <Limbic_Region> but I think that is a bug

[14:03] <stevan> Juerd: personally I like the look of (say $fh: "hello"), but not ($fh.say:"hello") so much

[14:04] <stevan> Limbic_Region: the test in io.t, I am going to wrap in a bare block, so that your $fh goes out of scope

[14:04] <Limbic_Region> stevan - not sure that is ok to do

[14:05] <Limbic_Region> I wasn't sure about GC guarantees

[14:05] <stevan> Limbic_Region: shouldnt finalization ideally happen when the variable is out of scope

[14:05] <Limbic_Region> but when the program ends - it should DEFINATELY be gc'd/finalized

[14:05] <stevan> Limbic_Region: agreed

[14:05] <stevan> but two checks cant hurt

[14:05] <stevan> if there is no guarentee, oh well

[14:05] <Limbic_Region> stevan - I am not sure if the p6 side of the house and the parrot side of the house has come to agreement on timely destruction

[14:06] <stevan> Limbic_Region: true

[14:06] <Limbic_Region> so - I did the obvious thing and didn't assume

[14:06] <stevan> ok

[14:06] <stevan> I will leave it be then

[14:06] <Limbic_Region> in any case - if you could investigate the hash reference in a different hash being able to be dereferenced - I would appreciate it

[14:06] <stevan> which test is that?

[14:07] <Limbic_Region> I am off to attempt to paint the new house though I am still feeling extremely under the weather

[14:07] <stevan> Limbic_Region: enjoy :)

[14:07] <Limbic_Region> my %hashA;  my %hashB = ( 'foo' = \%hashA );

[14:07] <Juerd> stevan: How about map @foo: { ... } versus @foo.map:{ ... }, then?

[14:07] <Limbic_Region> and then modifying %hashA through dereferencing %hashB

[14:07] <Limbic_Region> it doesn't work

[14:07] <Limbic_Region> see my journal entry

[14:07] <Limbic_Region> on that note

[14:07] <Limbic_Region> I am off

[14:07] <Juerd> stevan: Of say, you don't usually use the return value for another methed

[14:07] <Juerd> method

[14:08] <Juerd> stevan: But think in a broader scope, and think about more generic functions

[14:08] <stevan> Juerd: either map is fine with me, they both look ok

[14:08] <Juerd> stevan: With indirect method syntax, nesting is a hell of a job

[14:08] <Juerd> stevan: Why is either map fine with you, while the same thing with "" instead of {} is not?

[14:08] <stevan> Juerd: I am going purely on aesthetics :)

[14:09] <Juerd> That's very dangerous.

[14:09] <stevan> I agree nesting could get very ugly with the indirect approach

[14:10] <stevan> Juerd: I dont claim to be a language designer at all, nor to have the knowledge/training to be one

[14:11] <Juerd> stevan: $foo.bar:"baz".length  # hm, impossible too

[14:11] <Juerd> The :{} must be very special

[14:11] <stevan> Juerd: and ugly too :)

[14:11] <stevan> I never liked perl5 indirect OO notation either

[14:11] <PerlJam> I've always thought :{} pretty and elegant

[14:12] <Juerd> as $foo.bar:{}.baz calls baz on $foo.bar:{}, not just the {}

[14:12] <stevan> Juerd: I am not sure why :{} is so special

[14:12] <stevan> I think it may be a less than elegant reason

[14:12] <stevan> it worked before map {} @a did

[14:12] <Juerd> So : sort of binds much tighter than the previously tightest thing, the dot

[14:13] <Juerd> Which makes me wonder, a lot, how the hell :pair.key is supposed to work.

[14:13] <Juerd> Given foo:pair.key

[14:13] <Juerd> Or would that have to be foo(:pair.key) to pass the key?

[14:14] <Juerd> Hm, has to.

[14:14] <stevan> Juerd: now your just stiring up trouble :)

[14:14] <Juerd> stevan: You have to, if you want to test a language's design.

[14:14] <PerlJam> Juerd++ 

[14:14] <Juerd> s/your/you're/

[14:15] <Juerd> Also, how lhs-whitespace-sensitive is :{}? Anyone?

[14:16] <stevan> pugs -e 'my @a = 1..5; say @a.map :{ $_ + 2 }'

[14:16] <stevan> pugs: cannot cast from VList [] to Pugs.AST.VCode

[14:16] <stevan> pugs -e 'my @a = 1..5; say @a.map:{ $_ + 2 }'

[14:16] <stevan> 34567

[14:16] <stevan> pugs -e 'my @a = 1..5; say @a.map: { $_ + 2 }'

[14:16] <stevan> pugs: cannot cast from VList [] to Pugs.AST.VCode

[14:17] <stevan> pugs -e 'my @a = 1..5; say @a.map:{ $_ + 2 }.join(", ")'

[14:17] <stevan> 3, 4, 5, 6, 7

[14:17] <PerlJam> Juerd: I'd imagine that it's not at all sensitive to whitespace.

[14:22] <Juerd> PerlJam: You and pugs disagree

[14:22] <Juerd> But is there any spec that can point out who's right?

[14:22] <Juerd> I can't find it

[14:23] <PerlJam> Juerd: surely I must be right.  :-)

[14:23] <Juerd> Because?

[14:24] <PerlJam> there's no difference between :{} and :foo as far as whitespace goes.  Surely you've seen example code that uses "blah :foo"?

[14:25] <Juerd> Why isn't there difference?

[14:25] <Juerd> And yes, I've seen code that uses blah :foo, but not code that uses $foo.blah :foo

[14:26] <Juerd> The first is valid anyway, because :foo there is just a simple argument

[14:26] <Juerd> For the method thing, special syntax is needed to make the call valid without parens

[14:30] <PerlJam> Juerd: the "best" way to find out is to ask p6l I guess.

[14:33] <Odin-> That assumes a rather twisted definition of 'good'.

[14:33] <Odin-> ;)

[14:36] <PerlJam> Juerd: Check out the section on methods in http://dev.perl.org/perl6/doc/design/syn/S12.html

[14:39] <PerlJam> but surely there must be some whitespace disambiguation for  method $obj: :foo  (if that's even legal)

[14:39] <PerlJam> perhaps that can be written method :foo $obj: too

[14:45] <PerlJam> ick.   .:method :modifier  looks to be legal (implied from S12).   the leading dot is washed away when I look at that.  It apears just as a series of :this :that :theother

[14:45] <stevan> Larry's First Law of Language Redesign: Everyone wants the colon.

[14:45] <stevan> http://dev.perl.org/perl6/doc/design/syn/S01.html

[14:46] <PerlJam> In this case I *don't* want the colon.  I'm suffering from colon overload

[14:47] <PerlJam> Can you call private methods using the IO notation?   :method $obj: :modifier

[14:47] <PerlJam> that too is icky.

[14:47] <PerlJam> (I hope it's also illegal)

[14:48] <stevan> PerlJam: that notation is just ugly, and difficult to understand 

[14:48] <stevan> I hope it is illegal as well

[14:48] <stevan> regardless of whether it /should/ be possible or not

[14:50] <osfameron> shame Perl6 won't have a regular syntax making IDE/refactoring browser type magic possible.

[14:50] <osfameron> s/regular/half sane/

[14:51] <wolverian> but it'll have the whole syntax tree available on the language level, which seems sane enough.

[14:51] <stevan> TIMTOWTDI has it's disadvantages

[14:52] <osfameron> discussed this at london.pm meet yesterday

[14:52] <osfameron> the language might be able to parse itself (thus still allowing IDE magic)

[14:53] <osfameron> but because Perl would be embedded in the editor, a crackfuelled enough module could actually crash the editor

[14:53] <PerlJam> osfameron: perl6 MUST be able to parse itself.

[14:53] <wolverian> my vim is compiled with perl and it never crashes. :)

[14:54] <osfameron> wolverian: yes, but it doesn't `use` modules on the fly in order to

[14:54] <Odin-> grammar Perl6; # Or something like that...

[14:54] <osfameron> warp the syntax it's using.

[14:55] <PerlJam> osfameron: I'm sure at some point we'll end up with something akin to a markup language for tagging grammars such that syntax colorers can do their job.

[14:55] <osfameron> that'd be cool

[14:56] <osfameron> though I'm really interested in the magic ability of, say, IDEA (and I guess Eclipse now?) to highlight syntax errors in Java code as you type,

[14:57] <osfameron> tell you which arguments functions take, and help you browse the object tree etc.

[14:57] <PerlJam> osfameron: As context sensitive as perl is, that might be a wee bit more difficult :-)

[14:57] <PerlJam> osfameron: however, an integrated help system is within easy reach I think (It's just a SMOP)

[14:59] <osfameron> PerlJam: so is it "context sensitivity" rather than lack of regular syntax that I should be bewailing?

[14:59] <osfameron> (or muttering about at any rate)

[15:00] <PerlJam> Well, they're intertwined really.  

[15:11] <Juerd> PerlJam: Re the colon: things wouldn't be so bad if we could use \w prefix operators

[15:11] <Juerd> But Larry has said that [a-z] should be for the user

[15:43] <jabbot> pugs - 2775 - * restrict findSub to &var now

[15:53] *** meta_perl_ is now known as meta_perl

[16:01] *** [2]meta_perl is now known as _metaperl

[16:01] *** _metaperl is now known as metaperl

[16:07] <Corion> Yay - 2 unexpected successes with r2774 ! sub_ref.t seems to grow closer to completion :)

[16:09] <Corion> Hmmm. I'm currently merely wondering. If we have STM, shouldn't C<let> be "easily" implemented by using an STM wrapper for the block/rule that let() lives in?

[16:09] <Corion> ... and then simply rolling back the whole transaction?

[16:10] <PerlJam> Corion: seems like it should work.

[16:10] <Corion> PerlJam: ... except of course, that I don't even know how to get my fingers on an STM container, and how to differentiate between let-assignments and non-let-assignments ;)

[16:11] <PerlJam> Corion: mere details!  ;-)

[16:11] <Corion> PerlJam: Yes - that's what we have autrijus for ! :)

[16:24] <Juerd> After writing a post to p6l, I get the feeling @(*&(*%&$^&*!)) should actually mean something in Perl 6...

[16:25] <sorje> Some things never change. ;-P

[16:25] <Juerd> And some things change continuously

[16:25] <Odin-> Juerd: Hmmm. Suggest it, and someone will find a way to make it have a meaning...

[16:25] <Juerd> It's interesting to see Perl 6 fit in both categories

[16:27] <Juerd> Odin-: I sort of already did. I sent a table to perl 6 that has many gaps in it, that just scream for a feature

[16:27] <Juerd> Odin-: Golfing will never be the same again

[16:27] <Odin-> Ouch.

[16:28] <Odin-> Dammit. Why can't Gmail have a fixed-width font for the mail messages? >:|

[16:28] <Juerd> Apparently, it sucks.

[16:29] <PerlJam> Juerd:  ??? looks like a really good "huh?"  operator

[16:29] <Odin-> Yeah. And one will be needed, given the operator soup we already have...

[16:34] <Corion> We already have ... - so maybe ??? should be the failing variant of it :)

[16:34] <Corion> That is, ??? := ... but fatal

[16:34] <PerlJam> rather than a pragma to modify the behavior of ...   ?

[16:35] <Corion> PerlJam: Ah, pragmata are useful, but think of the huffman coding :) You might want to have different kinds of ... - I imagine ... , ??? and XXX FIXME! :-)

[16:35] <Corion> Maybe !!! as well ;-)

[16:36] <PerlJam> Corion: suggest it to p6l.

[16:36] <PerlJam> seriously.

[16:36] <Odin-> Hrm. !!! should rather be the fatal one...

[16:36] <Corion> PerlJam: I've stayed away from p6l - I would need to subscribe to it, and that would direct even more spam in my direction ...

[16:36] <Corion> Odin-: Maybe ??? should be caught in a try{} block, while !!! aborts the program? :)

[16:36] <PerlJam> Corion: no need to subscribe.

[16:36] <Corion> PerlJam: No need to?

[16:37] * Corion goes looking

[16:37] <Odin-> Corion: Hmm. That'd be an interesting distinction, yes.

[16:37] <Corion> ... but first, we should find consensus on what !!! should do, opposed to ???, and maybe XXX

[16:38] <Juerd> PerlJam: Sure, but what does the huh? operator do?

[16:38] <Corion> I think that "XXX" should take a string to EOL (like, XXX FIXME) and die, while ... outputs the "unimplemented" warning, "???" dies, and "!!!" really dies.

[16:38] <Juerd> PerlJam: Is it good friends with the wtf? operator, "?!"?

[16:38] <Corion> Maybe ??? and !!! should also take a string until EOL

[16:38] <PerlJam> Juerd: I'm not the language designer.  My job is to make a mess, @larry's job is to clean it up  ;)

[16:38] <Corion> Like "??? magic" and "!!! Should never happen"

[16:39] <Odin-> Juerd: 'say "What the hell am I supposed to do here?";'!

[16:39] <Juerd> PerlJam: Then make a mess already, and tell me what the huh? operator does

[16:39] <Juerd> Odin-: In other words, we're just making ??? and !!! aliases for ...?

[16:39] <Corion> Hmmm. I'm not sure I see the/a difference between "???" and "XXX" ...

[16:39] <Odin-> Juerd: So it would seem.

[16:39] <Juerd> XXX is a fixme

[16:40] <Juerd> But it must continue to run.

[16:40] <Juerd> It can mean undef.

[16:40] <Corion> Juerd: Ah - the difference is maybe simply the syntax - "XXX" takes an implicit string until EOL, while "..." continues to parse.

[16:40] <Odin-> Hmm. Those would sort-of work like in-code comments?

[16:41] <Corion> ... which will make autrijus scream because special-casing in the parser is ugly :)

[16:41] <PerlJam> Corion: so  ...; say "foo"  would work?

[16:41] <Juerd> Corion: It's no special case if you group it with #

[16:41] <Juerd> PerlJam: Be valid syntax, but die.

[16:41] <Corion> Odin-: Yes, except that they produce output in the program :) "XXX FIXME" is like "warn 'FIXME at $?LINE"

[16:41] <Corion> Juerd: True

[16:41] <Corion> Juerd: No, "..." continues to run from what I know

[16:42] <Juerd> Corion: wtf?

[16:42] <Corion> (but then, I'm out of sync with the official Perl6 syntax since two or three years)

[16:42] <Juerd> Corion: I thought it'd die.

[16:42] <PerlJam> Corion: Larry has said that such behavior would be modulated by pragmata

[16:42] <Juerd>   * However, ... as a term is the "yada, yada, yada" operator, which is used as the body in function prototypes. It complains

[16:42] <Odin-> Corion: Yeah. Which might be interesting...

[16:42] <Corion> Juerd: I thought it would output "unimplemented code at ...", but continue to run

[16:42] <Juerd>     bitterly if it is ever executed.

[16:42] <Juerd> S03

[16:42] <Juerd> "complain bitterly" I agree is somewhat too vague

[16:42] <Corion> Juerd: "Complain bitterly" is "output a warning" to me.

[16:42] <Juerd> It's "die" to me

[16:43] <Corion> Juerd: But "..." is more like "uh - I hope you know what you're doing", where "???" is more like "WTF?", and "!!!" is more like "WTF!"

[16:43] <Odin-> Juerd: Hmm. I'd read it as "print a huge, ten page banner alerting to an error, and then go on"...

[16:43] <Corion> Juerd: I see "..." as having practical use when stubbing out code - I would want the code to warn but continue. How else would you do that?

[16:44] <Corion> sub do_magic { ... }

[16:44] <Corion> looks good, and should warn "do_magic is not yet implemented at $?LINE"

[16:44] <Corion> while

[16:44] <Corion> sub magic { ??? }

[16:45] <Corion> should die.

[16:45] <Corion> (I don't have a funky error message handy)

[16:45] <Odin-> "functionality not available"?

[16:46] <Juerd> Corion: Do you mind if I quote you verbatim on this?

[16:46] <Corion> Juerd: np :)

[16:46] <Corion> Juerd: I think the "..." is used often in pseudo code, and Perl6 should run pseudo code :)

[16:46] <Odin-> At this rate ... eventually it will.

[16:48] <Corion> "??? (.*)$" is sufficiently vague to warrant a "die $1", and "!!! (.*)$" should "say $1;POSIX::exit(1)". Maybe it should execute END{} blocks. Maybe !!! is just a bad idea.

[16:50] <Corion> (of course there should be a pragma, like "use fatal;" or "use fatal 'elipses'" to turn even "..." into a die())

[16:51] <Corion> "no fatal 'elipses' or $you.get( burned => by, 2*foci );

[17:28] <pmichaud> juerd:  your table of ops is excellent -- I'm thinking I'd like to put a copy in the perl6 svn

[17:41] <autrijus> hm

[17:41] <autrijus> anyone knows what precedence does [+] have?

[17:41] <autrijus> is it in the same slot as "loose" list operating prefix functions?

[17:41] <Juerd> pmichaud: Be my guest

[17:42] <Juerd> autrijus: Are there tight prefix listops then?

[17:45] <autrijus> that is, between

[17:45] <autrijus> , Y

[17:45] <autrijus> and

[17:45] <autrijus> ==>

[17:45] <autrijus> i.e. normal function application precedence

[17:45] <autrijus> no, there is none

[17:45] <pmichaud> what's the arity of [+] ?

[17:46] <pmichaud> it's unary, yes?

[17:47] <pmichaud> I'm going to guess that [+] is fairly tight, so one can write

[17:48] <pmichaud> if [+]@array > $max { ... }

[17:48] <autrijus> [+] is tight?

[17:48] <Juerd> I'd think it's a list op

[17:48] <autrijus> [+] 1, 2, 3;

[17:48] <Juerd> So very untight

[17:48] <autrijus> uh oh.

[17:48] <autrijus> round 1, fight!

[17:48] <pmichaud> heh

[17:48] <pmichaud> no, I'd think that [+] 1, 2, 3 is really written   [+] [ 1, 2, 3 ]

[17:48] * Juerd plays the annoying arcade music 

[17:49] <pmichaud> again, it's a metaprefix op

[17:49] <Juerd> pmichaud: Wow, that almost says out loud that it wants to be written as [+: 1, 2, 3]

[17:49] <pmichaud> most prefix ops are unary

[17:49] <Juerd> Uh oh.

[17:49] <autrijus> larry has written something like

[17:49] <autrijus> [+] 1..9;

[17:49] <autrijus> does it parse as

[17:49] <autrijus> ([+]1)..9;

[17:49] <autrijus> ?

[17:49] <autrijus> or is .. even tighter?

[17:49] <pmichaud> .. is in the non-chaining binary ops

[17:50] <autrijus> .. is actually quite loose

[17:50] <autrijus> there's no symbolic unary looser than it

[17:50] <autrijus> so it will be parsed as ([+]1)..9

[17:50] <autrijus> if it is symbolic unary

[17:50] <pmichaud> indeed

[17:50] <autrijus> so by neccessity I think it's a listOp

[17:50] <autrijus> (I think.)

[17:51] <pmichaud> if we put it too loose, we'd be writing   if  ( [+]@array ) > $max   when we want to sum an array

[17:51] <autrijus> but that's not diff than

[17:51] <autrijus> if sum(@array) > $max

[17:51] <autrijus> rather than

[17:51] <autrijus> if sum @array > $max

[17:51] <pmichaud> I'm not advocating a particular position here :)

[17:52] <autrijus> so hm.

[17:52] <autrijus> another alternative if we keep it as symbolic unary

[17:52] <autrijus> is

[17:52] <autrijus> [+](1,2,3)

[17:52] <pmichaud> well, if you think it fits better down with the listops, that's okay with me for now.  A good question for p6l, however

[17:53] <autrijus> I am, incidentally, also not advocating a particular position :)

[17:53] <autrijus> symbolic unary is slightly easier to understand

[17:53] <autrijus> as we didn't really have symbolic listops

[17:53] <autrijus> other than ==> <==

[17:53] <pmichaud> yes, that's what I was thinking -- that it's easier to understand as a unary than a listop

[17:54] <autrijus> Juerd?

[17:54] <Juerd> Yes?

[17:55] <pmichaud> I probably shouldn't say this, but part of the reason that "not" and "true" got bundled into "list op (rightward)" precedence was to avoid creating another "loose unary" level :)

[17:55] <autrijus> pmichaud: so, how tight do you think [+] wants to be?

[17:56] <autrijus> the existing "Symbolic Unary" level?

[17:56] <pmichaud> I dunno -- I'd have to look at more of the examples.  Larry's  [+] 1..9 makes a pretty convincing case for a loose level

[17:56] <Juerd> Shall I query p6l?

[17:56] <autrijus> pmichaud: but later luqui switched to write [+](1..9)

[17:57] <pmichaud> maybe luqui wasn't sure of the precedence, in which case the parens disambiguate so you don't have to worry about them :-)

[17:57] <autrijus> Juerd: sure, with a note that 1)pugs at this moment has it as symbolic unary level, same as filetests

[17:57] <pmichaud> I do that a lot

[17:57] <autrijus> and that [+] works now. about to commit

[17:57] <Juerd> ok

[17:58] * autrijus praises the builtin foldl, foldM, foldr, foldr1

[17:59] <autrijus> so [] is foldl, right?

[18:00] <autrijus> i.e. it starts taking the leftmost 2 elements

[18:00] <autrijus> and fold rightwards

[18:00] <autrijus> instead of the other way around

[18:01] <autrijus> if the list is empty, I assume undef?

[18:01] <autrijus> and if the list is size of one, returns that element?

[18:02] <pmichaud> it might need to contextualize the element

[18:02] <autrijus> hm?

[18:02] <pmichaud> but yes, return the element

[18:02] <pmichaud> well,    <+> "hello"   should return zero

[18:02] <autrijus> the context casting is done elsewhere :)

[18:03] <autrijus> op1Fold op v = do

[18:03] <autrijus>     args    <- fromVal v

[18:03] <autrijus>     case args of

[18:03] <autrijus>         (a:as)  -> foldM (op2 op) a as

[18:03] <autrijus>         _       -> return undef

[18:03] <pmichaud> I'm probably not following your question closely enough (I'm doing about three tasks at once here :-| )

[18:03] <Juerd> Whoa, what's <+>?

[18:03] <autrijus> I think that's it. testing

[18:03] <pmichaud> sorry I meant [+]

[18:03] <Juerd> pmichaud: You scared me there :)

[18:03] <autrijus> pugs> [+] 1, 2, 3

[18:03] <autrijus> (1, 2, 3)

[18:03] <autrijus> pugs> [+](1, 2, 3)

[18:03] <autrijus> 6

[18:04] <autrijus> done as r2777.

[18:05] <pmichaud> hmmm

[18:06] <autrijus> pmichaud: counterintuitive? :)

[18:06] <pmichaud> well, I think I'll wait for p6l to decide.  Looking at that example I'm guessing it'll end up at listop precedence, but I can't say for sure

[18:06] <autrijus> incidentally, me do, too

[18:06] <pmichaud> something like   [+]  foo(), 3, 4  looks kinda funny

[18:07] <pmichaud> as would   [+]  (3+2)*4, 5, 6

[18:07] <pmichaud> that seems to argue for symbolic unary op precedence :)

[18:07] <pmichaud> or maybe not

[18:08] <pmichaud> I'm glad I'm not a language designer :)

[18:08] <autrijus> probably not :)

[18:08] <pmichaud> foo( [+] (3+2)*4, 5, 6 )

[18:08] <Odin-LAP> [+] (3+2)*4, 5, 6 == 31 # ?

[18:09] <autrijus> pugs> [+] (3+2)*4, 5, 6

[18:09] <autrijus> 31

[18:09] <autrijus> switched to listop.

[18:09] <pmichaud> so, my last example is a single-argument call to &foo,  yes?

[18:10] <pmichaud> i.e., to use a reduce op in a function call list of params you'd need to parenthesize it

[18:10] <Odin-LAP> It should be, shouldn't it?

[18:10] <autrijus> yup

[18:10] * Odin-LAP would find anything else rather strange...

[18:10] <pmichaud> fair 'nuff.  I'm sure @Larry will come up with the answer and the (in retrospect obvious) reasons why :)

[18:11] <pmichaud> oh yes, Luke has the relevant quote

[18:11] <pmichaud> listop, definitely.

[18:12] <autrijus> it's done :)

[18:12] <pmichaud> okay, back to parrot and pge

[18:13] <jhorwitz> mornin' autrijus  :)

[18:13] <autrijus> hey jhorwitz

[18:13] <Juerd> autrijus: Heh, we were typing a reply at the same time :)

[18:13] <jabbot> pugs - 2776 - * ghci can't handle embed_flags.

[18:13] <jabbot> pugs - 2777 - * First cut at folding metaoperator: [+]

[18:13] <jabbot> pugs - 2778 - * switch [+] to list operator precedence

[18:13] <jabbot> pugs - 2779 - * prettify App better. 

[18:13] <jabbot> pugs - 2780 - fix a typo in hangman.kwid

[18:13] <autrijus> Juerd: this often happens.

[18:14] <jhorwitz> reading over logs from yesterday...were you asking for a registered parrot compiler for pugs (e.g. parrot's compreg/compile?)

[18:14] <autrijus> jhorwitz: yes.

[18:15] <autrijus> jhorwitz: I'd like to, once pmichaud et all get to it, allow callback from pge to perl6

[18:15] <autrijus> that is, code blocks

[18:15] <autrijus> and it needs pugs being registered as a parrot compiler

[18:15] <pmichaud> there's good reasons for having pugs as a registered compiler anyway :)

[18:15] <pmichaud> but yes, being able to call back from pge would be really cool

[18:16] <autrijus> common lisp and tcl callback would be cool too :)

[18:16] <pmichaud> (BTW, the callback itself isn't going to be hard once we have that -- I can put that into PGE now)

[18:16] <autrijus> nice

[18:16] <jhorwitz> parrot will need to somehow call the backend (like doCompileDump).

[18:16] <pmichaud> we haven't really figured out the syntax for callouts to other langs

[18:16] <autrijus> but I think for replacing Parsec, named capture is the one missing feature

[18:17] <pmichaud> I'm doing subrules now, simple named captures will be very soon

[18:17] <autrijus> cool, pmichaud++

[18:17] <pmichaud> I've already got the support in for it -- just need to parse the rules correct

[18:17] <autrijus> jhorwitz: right. give me the signature?

[18:18] <pmichaud> actually, I could probably do named captures first

[18:18] <pmichaud> before subrules

[18:18] <pmichaud> hmmm

[18:18] <autrijus> jhorwitz: oh, it's a weird type

[18:18] <pmichaud> unfortunately, right now what I really need to do is lunch, so I'll do that and be back

[18:18] <jhorwitz> autrijus: signature for what

[18:18] <autrijus> pmichaud: see ya

[18:19] <autrijus> ParrotInterp -> CString -> Ptr PMC

[18:19] <jhorwitz> ah, for the compile

[18:19] <autrijus> jhorwitz: Parrot_compiler_func_t

[18:19] <autrijus> now the obvious question is... I have PIR now, how do I manufacture a PMC?

[18:19] <pmichaud> call the pir compiler :-)

[18:19] <autrijus> clever!

[18:20] <pmichaud> that's how PGE does it :)

[18:20] <jhorwitz> yep

[18:20] <autrijus> mm twolevel compilation

[18:20] <autrijus> ok. that's utterly simple then

[18:20] <pmichaud> and that's why PGE does it that way :)

[18:20] * pmichaud lunch &

[18:21] <autrijus> jhorwitz: you have time to add compreg code? you can safely assume a compileToParrot

[18:21] <autrijus> compileToParrot :: ParrotInterp -> CString -> Ptr PMC

[18:22] <jhorwitz> how are we calling this from a non-embedded parrot?

[18:22] <autrijus> we are not

[18:23] <autrijus> :)

[18:23] <jhorwitz> ah.

[18:23] <autrijus> GHC 6.4 can make .so, true

[18:23] <autrijus> but that's relatively unimportant

[18:23] * jhorwitz flips over brain

[18:23] <autrijus> it's there purely for callbacks into pugs.

[18:23] <jhorwitz> got it

[18:23] <autrijus> but I guess we can also make pugs an evaluator for arbitary .imc

[18:23] <autrijus> pugs foo.imc

[18:24] <autrijus> and have it Just Work

[18:24] <autrijus> that's easy, too :)

[18:24] * autrijus embraceth and extendeth

[18:24] <jhorwitz> well, my ultimate goal is to have a pugs compiler for mod_parrot, which *will* be called from outside of pugs.  this will help jumpstart that, though.

[18:25] <autrijus> you can link against libpugs. :)

[18:25] <autrijus> which will include libparrot.

[18:26] * autrijus smiles

[18:26] * jhorwitz laughs diabolically

[18:29] <luqui> it appears that [+] isn't behaving as a listop

[18:29] <luqui> pugs -e 'say [+] 1,2,3'

[18:29] <luqui> 123

[18:31] <luqui> perlbot: seen anybody?

[18:31] <jabbot> luqui: I havn't seen anybody , luqui

[18:31] <luqui> perlbot: seen autrijus?

[18:31] <jabbot> luqui: autrijus was seen 5 minutes 21 seconds ago

[18:31] <luqui> perlbot: seen pmichaud?

[18:31] <jabbot> luqui: pmichaud was seen 11 minutes 2 seconds ago

[18:31] <autrijus> hey luqui.

[18:31] <luqui> hello

[18:31] * luqui thinks his alternate nick should be "anybody"

[18:32] <autrijus> so. the thing is

[18:32] <autrijus> [+] is not taking params cross the "," line

[18:32] <autrijus> unlike normal function application

[18:33] <luqui> shouldn't it?

[18:33] <autrijus> you think it should be just like function application?

[18:33] <luqui> well it has lower precedence than ,

[18:33] <luqui> so say([+](1,2,3), 6) should probably print 66

[18:34] <Juerd> autrijus: Yes, that's what listops do :)

[18:34] <luqui> hmm, but that means [+] (1,2,3)  isn't the same as [+](1,2,3)

[18:34] <autrijus> right. was about to say that.

[18:34] <Juerd> autrijus: All named ones at least

[18:34] <luqui> nevertheless, I think it's the right thing

[18:34] <autrijus> luqui: there's a reason why spre is different from pre

[18:34] <autrijus> ok then.

[18:34] <Juerd> autrijus: I think [+] is like <==

[18:34] <Juerd> autrijus: precedence-wise

[18:35] <Juerd> lower than <==, but not function-like

[18:35] <Juerd> eh

[18:35] <Juerd> lower than comma

[18:35] <autrijus> $obj.[+](1)

[18:35] <autrijus> is this legal?

[18:35] <luqui> oh my

[18:35] <autrijus> that's what happens when you are coding things :)

[18:35] <Juerd> autrijus: Well, it shouldn't be :)

[18:35] <autrijus> Juerd: why not? :)

[18:35] <luqui> because it's an array deref

[18:36] <autrijus> ok.

[18:36] <Juerd> autrijus: Because .[ is array deref, and +] isn't valid syntax

[18:36] <luqui> listops are different from methods, they just happen to share a lookup table

[18:36] <Juerd> I think.

[18:37] * luqui wonders whether foo $bar, $baz is really equivalent to $bar.foo($baz)

[18:37] <autrijus> is the term

[18:37] <autrijus> "reductive metaoperator"

[18:37] <autrijus> "reduction metaopetor"

[18:37] <autrijus> "reduce metaoperator"

[18:37] <autrijus> "folding metaoperator"

[18:37] <luqui> I find the third to be the clearest

[18:39] <autrijus> implemented. testing

[18:40] <autrijus> "In other words, it's okay to call an undefined function in your

[18:40] <autrijus> prototype as long as you don't actually use the value."

[18:40] <autrijus> wow.

[18:40] <luqui> larry's most recent posts about hashes scare me

[18:41] <luqui> yeah, and that one too

[18:41] <luqui> heh... we'll talk on wed. about that

[18:41] <luqui> I'm sure Damian's not going to go for that either

[18:41] <Corion> r2780 - 4762 ok, 56 failed - http://datenzoo.de/pugs/win2k.html

[18:41] <autrijus> so, arrayLiteral needs to backtrack

[18:42] <autrijus> or, it needs to build a lookahead table of all infix ops at the current scope.

[18:42] <autrijus> the first one is faster.

[18:42] <autrijus> I'll do that for now.

[18:43] <Corion> btw - t/var/default_scalar.t dies with pugs: cannot cast from VHandle {handle: tmpfile} to [Char]

[18:43] <Corion> what does one do to hunt down these cast errors?

[18:43] <autrijus> Corion: well, arguably a handle should be stringifiable

[18:43] <autrijus> (I hope)

[18:43] <autrijus> so the easiest fix is in AST.hs to add VHandle as a Value VStr instance.

[18:44] <autrijus> you can do that?

[18:44] <Corion> autrijus: I'll look into trying it ;)

[18:44] <autrijus> cool

[18:44] <Corion> I need Pugs to convert my boss from Python to Perl ;)

[18:44] <autrijus> really!?

[18:45] <autrijus> how do you do that? :)

[18:45] <pmichaud> autrijus should have that functionality built into pugs soon :)

[18:45] <autrijus> boss conversion?

[18:45] <autrijus> mmm.

[18:45] <Corion> autrijus: Perl6 is currently the only language with a non-delusional promise :)

[18:45] <autrijus> I thought Python 2.5 is quite practical too

[18:45] <pmichaud> my, what a difference a few months can make :)

[18:46] <autrijus> it's almost 100 days :)

[18:46] <Corion> autrijus: No - they already have solidified their classes, haven't they?

[18:46] <autrijus> yeah, that is true

[18:46] <Corion> and Python 3000 sounds even worse

[18:46] <Juerd> 100 days of RAGING GENIUS INSANITY

[18:46] <autrijus> er. don't even think about the 3K

[18:46] <pmichaud> my impression was that back in january people thought perl 6 was quite delusional :)

[18:46] <Juerd> pmichaud: Yea.

[18:46] <Juerd> pmichaud: And people who haven't heard about Pugs still do

[18:47] <Corion> pmichaud: Yes, but Pugs delivers what Perl6 promises ;)

[18:47] <Corion> ... well, up until now, that is. Dunno about tomorrow :))

[18:47] <pmichaud> well, pugs plus the things I'm seeing in the grammar engine have convinced me it's all doable

[18:47] <Juerd> pmichaud: There were some of those people at Rotterdam.pm. I had totally forgotten that perhaps not everyone knew about Pugs

[18:47] <autrijus> pmichaud: what things are you seeing?

[18:47] <pmichaud> just the way the lexer and parser and codegen will all come together

[18:47] <autrijus> oh. right.

[18:47] <Juerd> pmichaud: After my what-happened-with-pugs-while-we-were-having-fun lightening talk, someone asked me: "so there is a perl 6 interpreter now?" "Yes" "But... ehm... hey... er... huh? wow!"

[18:48] <autrijus> Juerd: I hope there's a recording or slides somewhere for that talk of yours :)

[18:48] <Juerd> autrijus: None at all

[18:48] <Juerd> autrijus: I came up with the idea during another talk, and accumulated data for it via svn log

[18:48] * pmichaud goes back to pge and parrot for a while

[18:49] <Juerd> autrijus: I also did a talk on context in Perl 6 (30 minutes or so), on ... flipover - also completely unprepared

[18:49] <autrijus> pmichaud: enjoy

[18:49] <autrijus> luqui: try now? r2781

[18:49] <Juerd> autrijus: Besides, if there was a recording, it'd still be Dutch.

[18:49] <luqui> trying

[18:49] <Juerd> autrijus: Also, there's nothing in those talks that you didn't already know

[18:49] <autrijus> all true

[18:49] <Juerd> s/Rotterdam.pm/Amsterdam.pm/ by the way

[18:49] <Juerd> Rotterdam.pm has been dead for years

[18:50] <luqui> Oh, Pugs.Parser is compile

[18:50] <luqui> compiling

[18:50] <Juerd> (Which is unfortunate, as it's much closer to where I live)

[18:50] * luqui puts on some coffee

[18:50] <autrijus> luqui: you can do "make unoptimized" or "make ghci"

[18:50] * luqui expects it to almost be done after he finishes

[18:50] <autrijus> both will be much faster

[18:50] <pmichaud> autrijus: do you have a preference as to named captures versus subrules priority?

[18:50] <Juerd> Corion: It looks as if you get all three your ..., ??? and !!! to do exactly what you want.

[18:50] <Corion> Juerd: Thanks man!

[18:50] <luqui> seeing as how I don't care about the speed of the code, that might be a good idea

[18:51] <Corion> (and all the world will blame me for eternity... Yay! :) )

[18:51] <autrijus> pmichaud: both are needed for bootstrapping, so whichever you see fit, but  named capture  will be more killer appish :)

[18:51] <Juerd> luqui: In that message, I read "undefined function" as "*defined* function yada'ing"

[18:51] <autrijus> i.e. something you almost absolutely cannot do in Perl5

[18:51] <pmichaud> well, let's see if I can get them both out today.  named capture is slightly simpler I think

[18:51] <autrijus> ("almost" because people still did it)

[18:52] <Juerd> I like the proposed semantics

[18:52] <Juerd> Especially that ... fails, leaving things up to fatal for specification along with your preferred strictness

[18:52] <Corion> Heh. Juerd: Though we'd have to discuss the precise meanings of "WTF?" and "WTF!". :-)))

[18:53] <jabbot> pugs - 2781 - * [+] is now truly listop.

[18:53] <jabbot> pugs - 2782 - * fix signature

[18:53] <jabbot> pugs - 2783 - Made it more clear that our Net::IRC is 

[18:54] <luqui> ohhhhhhhh [+] is just a plain ol' operator, not a meta operator combined with +

[18:55] <autrijus> does it mean that if I define infix:<Z>

[18:55] <autrijus> I don't get [Z] automagically?

[18:55] <luqui> I think you doo

[18:55] <luqui> do

[18:55] <luqui> I mean in pugs

[18:56] <Juerd> luqui: It's a meta-operator that creates a new operator, allowing it to have different precedence, unlike with the >><< metaoperator

[18:56] <luqui> unless the stuff that Larry's been talking about, rooting for the overdog and such

[18:56] <autrijus> sure, that's just get precedence working; if you want autogen from infix ops, it's quite easy too

[18:56] <autrijus> luqui: grep for

[18:56] <autrijus> -- XXX - Query all infix here

[18:56] <autrijus> and query all infix there :)

[18:56] <luqui> ahh

[18:57] <Juerd> autrijus: Is -- the comment operator in haskell?

[18:57] <autrijus> look at currentUnaryFunctions etc for how.

[18:57] <autrijus> Juerd: it's the comment introducer.

[18:57] * luqui is hosting a bbq in a half hour

[18:57] <Juerd> That's what I meant

[18:57] <luqui> he can probably dive in later today

[18:57] <Juerd> luqui: I'm hosting websites  ALL THE TIME :)

[18:57] <luqui> yes, bbq, predecessor to bbs

[18:58] <Juerd> Social stuff

[18:58] <luqui> (bbr is no good, because nobody likes to be cold)

[18:58] <Juerd> bbq => social, bbs => social, internet => no longer social

[18:58] <luqui> hmm?

[18:58] <luqui> you lost me around "Social stuff"

[18:59] <Juerd> What 'bbs' did you mean?

[18:59] <Juerd> I assumed bulletin board system

[18:59] <luqui> yeah

[18:59] <Juerd> Nowadays explained as "small internet"

[18:59] <Juerd> It's a social place, like a bbq :)

[18:59] <Juerd> You meet people there

[18:59] <luqui> I see, I think

[18:59] <luqui> therefore, I am

[18:59] <Juerd> You see that you think?

[18:59] <Juerd> Teach me that some day

[19:00] <luqui> yeah, bbq requires more immediate time commitment

[19:00] <Odin-LAP> I think none of us thinks.

[19:00] <Odin-LAP> Especially not me.

[19:00] <luqui> people probably wouldn't like to hear "hey, entertain yourselves for an hour, I'm going to go hack on pugs"

[19:00] <Odin-LAP> ('us' referring to humanity as such.)

[19:00] <luqui> and they think "hack?" "pugs?" "entertain?"

[19:01] <stevan> luqui: you might scare your guests off if you hack on some pugs at the BBQ

[19:02] <stevan> not to mention the fact they have very small ribs

[19:02] <luqui> haha

[19:02] <autrijus> so

[19:02] <autrijus> !!!3

[19:02] <autrijus> is false

[19:02] <autrijus> but

[19:02] <autrijus> !!! 3

[19:03] <autrijus> is false?

[19:03] <Juerd> is a syntax error?

[19:03] <autrijus> !!! -3 ?

[19:03] <Juerd> Why would yada accept arguments?

[19:03] <stevan> what about !!!(3)

[19:03] <Juerd> I think ...|???|!!! is a term by itself

[19:03] <Juerd> &term:<...>

[19:03] <autrijus> they are

[19:03] <jabbot> pugs - 2784 - Added tests testing [+], [-], etc.

[19:03] <Juerd> They're undef when used as a value

[19:03] <Juerd> And undef can't be used as a subref

[19:04] <Juerd> So yada() doesn't make enough sense

[19:04] <autrijus> I'm just saying that, currently parsing !!!-3

[19:04] <autrijus> needs more than 1-char lookahead

[19:05] <Juerd> Why?

[19:05] <Juerd> That's just undef - 3, but an undef that dies as soon as it's evaluated

[19:05] <Corion> autrijus: Your idea worked. Now I should maybe print out a bit more than just "<Handle (maybe should be more explicit)>" :-)

[19:05] <autrijus> Corion: "show" maybe

[19:05] <Juerd> Unless someone overrides die to do nothing (I HATE THAT!!!!!, but people like kane (jos) want this), in which case the result is -3 with a warning of using undef

[19:05] <Corion> autrijus: That's what I'm trying right now :)

[19:06] <Corion> Juerd: Don't complain about weird things that Jos does - he's trapped in his own world :)

[19:07] <Juerd> Corion: I hate his idea that a module should never be allowed to die, and that die should be a noop sometimes, because he should just get some clue and use eval (try in p6), so that safety mechanisms aren't broken, but I do want Perl to be the flexible language in which idiots can actually do what they think is right.

[19:08] <autrijus> including On Error Resume Next ?

[19:08] <autrijus> can we have that in perl 6? :)

[19:09] <luqui> ask Chip

[19:09] <Corion> autrijus: Scary as it is, On Error Resume Next was the only sane way to program in VB

[19:09] <Juerd> autrijus: That's what jos does, yes, but he puts that on other people's code.

[19:09] <Juerd> Corion: No, it was not.

[19:09] <autrijus> Juerd: no, overriding die() doesn't stop 1/0

[19:09] <Corion> (because it was the only way you could trap the error and then check for it)

[19:09] <autrijus> nor other fatal errors

[19:10] <Juerd> Corion: on error gosub 123, and 123 HANDLEERROR : RESUME NEXT was.

[19:10] <Juerd> autrijus: That is true.

[19:10] <autrijus> Corion: I know that too well...

[19:10] <autrijus> <- programmed Basic for 10 years, including 3years as VB consultant

[19:10] <Corion> Juerd: Ah, yes, but that would mean you had one central error handler. I checked after each operation

[19:10] <Corion> autrijus: I did so too, in VB4/5 I think

[19:11] <autrijus> *shudder*

[19:11] <Corion> But life is better now :)

[19:11] <PerlJam> autrijus: 10 *years*?  Your torture was longer than most.

[19:11] <autrijus> yeah, from 8 to 18 yrs old

[19:12] <autrijus> my finger still remembers "cls; randomize timer"

[19:12] <luqui> which is a linguistic travesty

[19:12] <luqui> why am I randomizing the timer?

[19:13] <Juerd> Corion: ON ERROR GOSUB 123 : OPEN "foo" FOR OUTPUT AS #1 : ON ERROR WHATEVERTHEDEFAULTWAS

[19:13] * luqui programmed in qbasic for the first five years of his cyberlife

[19:13] <jabbot> pugs - 2785 - Added test for builtin fail().

[19:13] <jabbot> pugs - 2786 - * Added EOLs at EOFs.

[19:13] <luqui> Juerd: you know, capitals weren't required

[19:13] <stevan> Apple ][e Basic my my first :)

[19:14] <Juerd> luqui: It made it that. 

[19:14] <Juerd> luqui: You'll note that my example is old style basic, as I'm using an explicit #1 (bad style in later basic, that had FREE(), later Free())

[19:14] * Juerd also used basic for a way too long time

[19:14] * jhorwitz remembers C64 Basic...

[19:15] <Corion> Hah. VHandle stringification is now in (courtesy of show()), just passing the tests ...

[19:15] <Juerd> age 7..17

[19:15] <Juerd> Started using Perl when I was 15

[19:15] <luqui> Juerd: I didn't notice... I remember very little basic

[19:15] <Juerd> But continued to use VB for a few years

[19:15] <luqui> Juerd: that's about the same as me

[19:16] <Juerd> I also don't remember much of it

[19:16] <Juerd> Which is good.

[19:16] <Juerd> autrijus: My fingers don't remember that, because I switched to Dvorak :)

[19:16] <luqui> you actually did it?

[19:16] <luqui> good for you

[19:16] <Juerd> luqui: Years ago.

[19:16] * luqui kept saying "yeah, I'll switch"

[19:16] <autrijus> Juerd: my input method(s) doesn't play well with dvorak

[19:16] <Juerd> luqui: Just do it.

[19:17] <autrijus> chinese input methods, that is :-/

[19:17] <luqui> it's not really practical when you have something to type for school in an hour

[19:17] <Juerd> autrijus: Do you use those input methods for entering roman text too?

[19:17] <Juerd> luqui: How much of your typing do you do at school?

[19:17] <autrijus> Juerd: holding Shift key enters roman text

[19:17] <luqui> no, not at school

[19:17] <luqui> *for* school

[19:17] <Juerd> luqui: I type more than 99% of all my typing on my own keyboards.

[19:18] <Juerd> luqui: I can live with 1% discomfort

[19:18] <luqui> if I'm learning dvorak, I can't type a paper in an hour

[19:18] <Corion> Ah, you know you programmed too much basic when you get flashbacks of print chr(34) & "Hello World" & chr(34) & vbCrLf

[19:18] <Juerd> luqui: Oh, yes, you need some free time to switch

[19:18] <Juerd> Corion: Puh, that's modern basic (visual basic)

[19:18] <luqui> that's what I've been missing

[19:18] <Khisanth> autrijus: you must have some very strong fingers...

[19:18] <Juerd> Corion: Old basic used only + for string contact.

[19:18] <Corion> Juerd: The only basic I get flashbacks from ;)

[19:18] <luqui> Corion: I see junctions of strings

[19:18] <Juerd> Corion: And CHR$, not Chr, because, well, sigils indicated type. For functions too.

[19:19] <luqui> maybe they're called sligis?

[19:19] <Corion> Juerd: VB has both, chr$() and chr() I think. But then, I only dream of it at night, or when I have to debug some MS Access code.

[19:19] <Juerd> autrijus: And is that on a qwerty-like mapping? Then you can use Dvorak just as well.

[19:19] <autrijus> right! that will solve all our ambiguities!

[19:19] <Juerd> Corion: Yes, it has both.

[19:19] <autrijus> instead of sort, say

[19:19] <autrijus> $sort@

[19:19] <Juerd> hahaha

[19:20] <Corion> What about &sort@ ? Like, hungarian notation, except with sigils ! Mwahahahhahahahha

[19:20] <autrijus> say*@( 1$ $+$ $sort@ @a )

[19:20] <luqui> which would do what?

[19:20] <PerlJam> sigils *are* hungarian notation

[19:20] <Corion> VHandle stringify is in now ;-)

[19:20] <autrijus> connecting dots was never that easy

[19:20] <Corion> PerlJam: But not for the complete signature ;-)

[19:20] <autrijus> luqui: function prefix and suffix to denote their context 

[19:21] <Corion> Like, @sort&@(&block, @list); # :-))

[19:21] <autrijus> yup

[19:21] <luqui> ahh, then we can achieve C++'s worthless goal of context independence

[19:21] <PerlJam> Corion: oddly enough I think we already have that in perl6 with :()  ;-)

[19:21] <autrijus> yes. you write @reverse@ when you mean it

[19:21] <autrijus> and $reverse$ when you mean that

[19:21] <autrijus> there can't be mistakes anymore

[19:21] <luqui> except for choosing to do that :-)

[19:21] <autrijus> :D

[19:22] <Juerd> autrijus: @reverse$

[19:22] <Juerd> Hmm...

[19:23] <autrijus> DEFINT A-C

[19:23] <Juerd> NOOOOOOOOOOOOOO

[19:23] <autrijus> DEFSTR D-F

[19:23] <autrijus> DEFHASH G-Z

[19:23] <autrijus> painless sigilless

[19:23] <Juerd> Although DEFINT A-Z used to make most programs much faster

[19:23] <jabbot> pugs - 2787 - Stringify VHandle

[19:23] <autrijus> macro DEFINT { ... } # left as exercise 

[19:24] <Juerd> Remember Perl 5's reset?

[19:24] <Juerd> reset 'a-z'

[19:24] <Juerd> Hmmm!

[19:24] <autrijus> hmm!

[19:24] <Juerd> Suspicious.

[19:24] <Juerd> D'ya think Larry was a BASIC nerd too?

[19:24] <autrijus> study; reset; study; reset; dump dump dump

[19:25] <autrijus> Juerd: sure, look at __DATA__

[19:25] <Juerd> haha

[19:25] <Juerd> __DATA__ was a good idea though

[19:26] <luqui> DEFINT /\$\w*int\w*/

[19:26] <Juerd> ew

[19:26] <Juerd> labels

[19:26] <Juerd> Now I know where they come from.

[19:26] <luqui> every programming language ever?

[19:26] <Juerd> And why I dislike their unquoted uglyness :)

[19:26] <Juerd> luqui: nahhh, I try to ignore that there's more in this world.

[19:27] <Juerd> Especially Python I like to think does not exist.

[19:27] <Juerd> luqui: But $printer...

[19:27] <luqui> The thing is about quoted labels.  If you can say "foo":,  what's stopping you from saying $foo:

[19:28] <Juerd> Nothing, isn't it great?

[19:28] <Juerd> It'd be silly to actually do so.

[19:28] <autrijus> PRINT USING "@<<<<<<   @||||||   @>>>>>>"

[19:28] <luqui> you imagine that a code generator for a register-based virtual machine would like that?

[19:28] <Juerd> autrijus: heee heee

[19:28] <luqui> oh no

[19:28] <luqui> it all makes perfect sense now

[19:28] * luqui goes to hang himself

[19:29] <Juerd> I do miss BASIC's PRINT USING 

[19:29] <Juerd> Because that could perfectly separate thousands

[19:29] <Juerd> Which in Perl is a hell to get right.

[19:29] <autrijus> luqui: You have exceedded the maximum number of tries.

[19:29] <autrijus> Sorry, the committer was 'Amir Livine Bar-On'

[19:33] <jabbot> pugs - 2788 - * parse for ??? and !!! (incomplete)

[19:33] <jabbot> pugs - 2789 - Added -B to Help.hs.

[19:36] <Corion> r2787 - http://datenzoo.de/pugs/win2k.html - 4768 ok, 57 failed, 899 todo

[19:36] <Corion> Oh. I should write pugsrun tests for -B ...

[19:41] <ninereasons> when a sub is on the LHS of  'xx' , should we be able to spell  'sub() xx 4 ' in a way that it fills a list with 4 unique values?

[19:41] <ninereasons> sub or function

[19:42] <ninereasons> etc. ..

[19:42] <autrijus> jhorwitz: I think I got compreg working

[19:43] <Juerd> ninereasons: Currently, it returns 4 times the same sub

[19:44] <Juerd> ninereasons: But see my proposal for XX in p6l, where I suggest that $closure XX 4 actively calls the closure 4 times, possibly returning 4 different values

[19:44] <ninereasons> I think I got it.   my @a = { rand(10) } xx 4

[19:44] <ninereasons>  @a[2]() # etc.

[19:44] <ninereasons> is that right?

[19:44] <Juerd> ninereasons: Right and ugly.

[19:44] <ninereasons> very ugly

[19:45] <Juerd> ninereasons: While waiting for XX or another alternative, just use plain old map, even though that's not really what you mean.

[19:45] <Juerd> ninereasons: my @a = map { rand 10 }, 1..4;

[19:45] <ninereasons> how should I track down your proposal?  what's the title, Juerd ?

[19:46] <Juerd> ninereasons: The initial post was done by luqui, titled "xx and closures"

[19:46] <ninereasons> found it.  thank you.

[19:46] <Juerd> ninereasons: Larry still avoids blessing XX, probably hoping for something prettier, but he has used it one time in example code.

[19:47] <autrijus> eval_parrot ' compreg $P0, "Pugs" $S0 = "say qq[There... and back again!]" $P0 = compile $P0, $S0 invoke $P0

[19:48] <autrijus> ';

[19:48] <autrijus> er.

[19:48] <autrijus> eval_parrot ' compreg $P0, "Pugs" $S0 = "say qq[There... and back again!]" $P0 = compile $P0, $S0 invoke $P0

[19:48] <autrijus> ';

[19:48] * autrijus blames gnome-terminal

[19:48] <autrijus> sigh.

[19:50] <Juerd> Neat, autrijus 

[19:50] <autrijus> perlbot: nopaste

[19:50] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[19:51] <pasteling> "autrijus" at 220.132.132.105 pasted "roundtrip" (10 lines, 205B) at http://sial.org/pbot/9971

[20:09] <jhorwitz> autrijus: compreg!

[20:10] <autrijus> jhorwitz: completed (in 6 lines)!

[20:10] <jhorwitz> autrijus++

[20:10] <jhorwitz> autrijus++

[20:10] <autrijus> I think writing C with a white glove is actuallly enjoyable :)

[20:10] <obra> with a white glove?

[20:11] <autrijus> obra: haskell FFI

[20:12] <autrijus> jhorwitz: so, leo says we should probably define the embed.h or extern.h or whatever thing we'd like to use

[20:12] <obra> ah

[20:13] <jhorwitz> autrijus: sounds good.  gotta run.  back in an hour.

[20:13] <autrijus> k. and I gotta sleep

[20:13] <jhorwitz> sleeeeeeeeep

[20:13] <obra> night, autrijus 

[20:13] <autrijus> nite!

[20:17] <Juerd> Good night

[20:33] <jabbot> pugs - 2790 - * Pugs is now a registered Parrot compil

[20:33] <jabbot> pugs - 2791 - * add missing import

[20:33] <jabbot> pugs - 2792 - Fix help text to mention say() instead o

[21:11] <autrijus> nite :)

[21:11] <autrijus> &

[21:53] <jabbot> pugs - 2793 - * make parrot_config work when parrot is

[21:53] <jabbot> pugs - 2794 - basic pod2html support (the HTML is ugly

[21:53] <jabbot> pugs - 2795 - fixed some POD errors

[22:00] <stevan> Basic pod2html is working now (if anyone cares)

[22:00] <stevan> pugs ext/Pod-Event-Parser/scripts/pod2html.p6 lib/Perl6/Pugs.pm > Pugs.html

[22:03] <jabbot> pugs - 2796 - fixing the pod2html script

[22:23] <jabbot> pugs - 2797 - Added a small script generating a Pugs L

[22:33] <jabbot> pugs - 2798 - * Added a README pointing at mklivecd.pl

[22:36] <iblech> FYI, I created a livecd-generating script in util/livecd. A precompiled image is at http://m19s28.vlinux.de/iblech/pugs/livecd.iso.

[22:53] <jabbot> pugs - 2799 - golf.t now uses unique temp file names, 

[22:53] <jabbot> pugs - 2800 - Removed skip of all golf.t tests, becaus

[23:56] <pjcj> Juerd: iff = if and only if

[23:56] <Juerd> How is that different from if?

[23:57] <pjcj> it is stronger

[23:59] <Juerd> Hm. Okay.

[23:59] * Juerd doesn't understand, but thanks

[23:59] <arcady> "a iff b" means "a implies b" and "b implies a"... basically, a and b are equivalent

