[00:09] <Darren_Duncan> I am in the middle of 'make test' for 6.2.5 now ...

[00:11] <mugwump> where's a test/demo of coro's, anyone?

[00:11] <mugwump> ah, t/unspecced/coro.t

[00:50] <svnbot6> r3805, autrijus++ | * fix typo

[00:50] <svnbot6> r3806, revdiablo++ | updated version number in debian build files

[00:50] <svnbot6> r3807, mugwump++ | Playing with coroutines and iterators - Tree test now fails gracefully.  New open question about using yield() within closures.

[01:44] <japhy> I've found a typo in the pattern matching apoc. (#5)

[01:44] <japhy> [[:alpha:][:digit:]   <<alpha><digit>>      # POSIX classes are built-in rules

[01:44] <japhy> the first thing is missing a closing ], but I'm more concerned with the Perl 6 equiv.

[01:45] <japhy> it seems to be saying that < <alpha> <digit> > is some sort of assertion that matches like [[:alpha:][:digit:]] does in Perl 5

[01:46] <japhy> now, character classes in Perl 6 seem to be defined as <[...]>

[01:47] <japhy> so how does one intersperse built-in rules with range-based character classes?

[01:47] <japhy> would it be < <alpha> [0-9] > ?

[01:47] <japhy> or is there a typo in the original?  should it be <[<alpha><digit>]>

[01:50] <Darren_Duncan> the result of 'make test' on 6.2.5 is: 297 subtests skipped, Failed 1/297 test scripts, 99.66% okay. 9/5661 subtests failed, 99.84% okay.

[01:50] <japhy> hrm, perhaps page 12 clears that up abit

[01:50] <Darren_Duncan> failed one is: t/oo/class/nested_use.t                9    9 100.00%  1-9

[01:51] <Darren_Duncan> this is on Mac OS X 10.3.9, system Perl 5.8.1, no Parrot etc, all default config

[01:51] <Darren_Duncan> leaving comp now

[02:08] <theorbtwo> Ah!  Finally!

[02:08] <theorbtwo> freenode wasn't letting me reconnect for the longest time...

[02:14] <diotalevi> Hola, mugwump.

[02:15] <theorbtwo> Hola to you too, dio.

[02:19] <diotalevi> So can I write my perl in Haskell now? Or can a perl function call a haskell function? Or the reverse?

[02:20] <diotalevi> Without just doing eval-string or the equivalent.

[02:21] <diotalevi> (actually, I really want to write my perl in lisp, I'm just asking about the Haskell part because it seems more likely)

[02:21] <theorbtwo> Well, you can eval haskell strings from perl.

[02:21] <theorbtwo> (If you want to get back a string.)

[02:21] <theorbtwo> This is probably not what you were really asking, but I'm not sure what you /were/ really asking.

[02:22] <diotalevi> Yeah... but just eval-string isn't terribly interesting, you know?

[02:22] <theorbtwo> It's not?

[02:22] <theorbtwo> You can do anything with eval string.

[02:23] <diotalevi> It depends on when it runs and it depends on whether it interpolates the result into the surrounding code or whether it just runs the resulting code.

[02:24] <theorbtwo> I feel like I'm being stupid.

[02:24] <mugwump> You could add that to autrijus' new wishlist Perlmonks node.  You're basically looking for the perl6 Inline:: equivalent, which is supposed to be a "core" feature

[02:24] <mugwump> iirc

[02:25] <theorbtwo> Oh, you're looking for Inline::Haskell?  Um, I think I may have written that, but I can't quite recall.

[02:25] <mugwump> you want definitions in the eval string to be available to the Perl, for instance.  Inline:: does this the other way (Perl 5 to Perl 6), but I don't think the reverse is true

[02:25] <diotalevi> I want macros.

[02:25] <diotalevi> That's what I'm really after.

[02:25] <theorbtwo> Oh.

[02:25] <theorbtwo> You should have asked for them, then.  :)

[02:25] <mugwump> oh.  Perhaps I'll stop second guessing you then :)

[02:25] <diotalevi> If macros can be written in multiple languages, so much the better.

[02:26] <theorbtwo> Um, planned, but there are still significant bits of them that the design team hasn't given us /any/ clue.

[02:26] <theorbtwo> That is, when they are called, and what arguments they get.

[02:26] <diotalevi> Well... macros are a more limited form of what I'm really asking for. It doesn't sound like it exists yet anyway.

[02:27] <theorbtwo> Ah.

[02:27] <theorbtwo> You want the ability to just write Haskell, and have it figure out what you mean?

[02:27] <theorbtwo> Try fp.pm, which is something along the same basic idea.

[02:27] <theorbtwo> We don't have macros, but we /do/ have user-defined operators.

[02:28] * diotalevi is distracted by mom on the phone.

[02:32] * theorbtwo ponders --> as an equiv for ==> ->

[02:32] <theorbtwo> ...which I think would serve well as a substitute for Haskell's ->.

[02:32] <theorbtwo> ...possibly.

[02:33] * diotalevi hasn't even gotten GHC ported to the machine he wanted to use perl6 on yet.

[02:35] <diotalevi> Ok, consider this in perl5 terms. As soon as BEGIN is compiled, it is imediately executed. If BEGIN were able to *not* execute but instead just return a fragment of an optree, that would be what I'm talking about.

[02:37] <diotalevi> I'm pretty sure this is a sane idea in perl6 terms but don't know how to say it yet.

[02:37] <theorbtwo> What you really want to be able to do is take a Code object and do lots of introspection on it, I think.

[02:38] <theorbtwo> You also want macros, in the LISP and perl 6 sense.

[02:38] <diotalevi> Well, introspection, yes. I will always want infinite introspection.

[02:39] <Odin-LAP> He's describing lispian macros.

[02:39] <Odin-LAP> Which, A6 promised us, we should have.

[02:39] <Odin-LAP> ... sooner or later.

[02:39] <diotalevi> Well... lispian except I don't really care if they have names most of the time.

[02:40] <Odin-LAP> diotalevi: They're on the same level as subroutines and methods and such. Dunno about anonymous ones...

[02:41] <diotalevi> If I had to *name* every macro... ech.

[02:50] <diotalevi> Why did we have to move this to IRC anyway? Perlmonks was just fine.

[02:50] <theorbtwo> try { sleep 60**2; CATCH ('z') {redo} }

[02:51] <theorbtwo> Oh, you should reply to that wishlist post with "macros".

[02:51] <vcv> Perl6 needs atomic transactions

[02:52] <diotalevi> Wishlist post?

[02:52] <diotalevi> Color me clueless.

[02:52] <mrborisguy> if only i had that color in my box...

[02:53] <mrborisguy> nope, just the classic 8 color set.

[02:56] <mrborisguy> don't really care if they have names most of the time.

[02:56] <mrborisguy> <Odin-LAP> diotalevi: They're on the same level as subroutines and methods and such. Dunno about anonymous ones...

[02:56] <mrborisguy> woah... sorry about that, just playing with the mouse

[03:23] <svnbot6> r3808, ninereasons++ | make more defaulty defaults

[03:54] <japhy> which perl6 mailing list is the most useful to be on?  perl6-language?

[03:55] <svnbot6> r3809, Stevan++ | Perl::MetaModel - more clarification on docs/perl6_meta_meta_class_hierarchy.pod

[03:55] <japhy> this is probably a weird question.

[03:57] <mugwump> perl6-language has the most posts from all(@Larry)

[03:57] <mugwump> but I'm not on *all* of them :)

[03:57] <japhy> I'm most interested in posting and debating questions about pattern matching syntax and purpose

[03:58] <mugwump> pge?

[03:58] <mugwump> oh, rules syntax itself

[03:59] <japhy> what's pge?

[03:59] <revdiablo> the rules engine written for parrot, in PIR

[04:00] <japhy> oh, right.

[04:00] <japhy> memory lapse.  I have that bookmarked.

[04:00] <mugwump> "The most merciful thing in the world ...  is the inability of the human mind to correlate all its contents." -- H P Lovecraft

[04:00] <japhy> basically, I need people to ask about specific syntax and purpose issues.  to find out what's changed or what's fuzzy since the apoc. #5

[04:01] <revdiablo> p6l would be the place, I think

[04:01] <mugwump> write tests!  :)

[04:01] <japhy> I'm writing a Perl 6 rules parser in Perl 5 right now

[04:01] <japhy> tests come later, once I've got Perl 6 on a machine of mine.

[04:01] <mugwump> Juerd might give you a login on his

[04:01] <japhy> yeah, I heard about that

[04:02] <mugwump> IMHO, writing a Perl 5 rules engine without co-ordinating it with PGE development would be a bad idea

[04:03] <japhy> mug - my model for the regex parser is probably considerably different from PGE

[04:04] <mugwump> sure, implementation might be radically different.  but you'd want the test suites to be shared

[04:04] <mugwump> in fact you could probably use Inline::Pugs for this now

[04:05] <mugwump> but then I probably don't know enough about the intricacies of rules to comment fully on this.  not really my area.  consider my input given :)

[04:06] <japhy> the extent of the work I'm doing right now is simply this:

[04:06] <japhy>   my $parser = Perl6::Rule::Parser->new;

[04:06] <japhy>   $parser->parse($string_representing_perl6_regex);

[04:06] <japhy> and then you can access a data structure representing the regex.

[04:07] <japhy> how it's used by other developers is up to them.

[04:07] <revdiablo> you might also want to look at Perl6::Rules, if you haven't already

[04:07] <japhy> I have

[04:07] <japhy> it's incomplete, though, because it's a translater

[04:07] <revdiablo> oh, it just translates to p5re?

[04:07] <japhy> it doesn't create a parse tree.  that's what mine is for.

[04:09] <japhy> the next step would be writing an expansion to P6::Rule::Parser that parses the *context* of the rules as well

[04:09] <japhy> that is, the m:whatever/ ... / part

[04:09] <japhy> this module just parses the ... part.

[04:09] <japhy> anyway, good night.

[04:10] <revdiablo> night japhy 

[04:10] <mugwump> 'night

[04:55] <masak> morning

[04:55] * masak svn ups

[05:30] <masak> did you release two consequtive versions of pugs within the same half hour?

[05:30] <masak> you guys are nuts :P

[05:30] <masak> pugsteam++

[05:31] <mugwump> yes, this is because some idiot broke a test just before a release

[05:44] * mugwump trolls http://perlmonks.org/?node_id=459750

[05:50] <masak> mugwump++ # as consolation

[06:04] <mugwump> thanks, masak :)

[06:05] <revdiablo> mugwump++ # for saying what I was thinking

[06:08] <mugwump> I hate FUD, and BrowserUk's post was full of it

[06:43] *** castaway_ is now known as castaway

[07:01] <gaal> can i call p6 from haskell?

[07:02] <mugwump> http://nopaste.snit.ch:8002/2691 # A fuller, more constructive post, anyone care to review?

[07:02] <mugwump> revdiablo perhaps?

[07:07] <castaway> Its certainly an improvement on the thing you posted.

[07:07] * castaway reads the rest

[07:08] <castaway> to part 1) I would answer there that cleanup and document comes after preliminary implementation is done.. (IMO anyway..)

[07:10] * castaway has no idea what B*UK means about the "existing implementations of the underpinnings" .. 

[07:10] <mugwump> yes, absolutely.  I was taking the angle that the primary implementation of the *specifications* is complete, and that pugs is the cleanup and documentation process for those specifications

[07:11] <mugwump> s/primary/preliminary/

[07:11] <mugwump> he's referring to parrot, given the previous point.  I don't know which spec he's referring to, it might exist.  I know Leo has a huge amount of experience, possibly even with other VMs.  But in any case it's about something in the past

[07:12] <castaway> I read that first to mean he doesnt want to use it until its done being defined.. which makes some sense, its just not worded very.. politely

[07:12] <castaway> You might want to stress somehow that Pugs (implementation of P6 syntax) is NOT parrot (generic bytecode thingy)

[07:13] <mugwump> ok good idea

[07:13] <castaway> ie that Pugs runs completely independently from parrot

[07:13] <castaway> maybe he is confused on that point

[07:13] <castaway> (several people seem to have the idea that P6 == Parrot=

[07:14] <castaway> s/t=/t)/

[07:15] <castaway> the runtime library/virtualisation thing also seems to refer to parrot

[07:16] <castaway> as for bypassing tests that wont work/make no sense on some platforms, I feel thats a good thing to do, as long as the bits that wont work are documented..

[07:16] <castaway> for eg, if p& gets used as an embedded language (or something) theres bits of it that are just not going to work or be needed

[07:16] <castaway> oops p6

[07:16] <castaway> Ok, I'm done reading now, hope it was helpful

[07:18] <castaway> hmm, I thought I posted a reply to that node this morning

[07:18] <mugwump> very, thanks :)

[07:18] <mugwump> castaway++

[07:19] <castaway> oops, no that was the other one

[07:19] * castaway blushes

[07:19] <castaway> you're welcome

[07:28] <drbean> Does the comment about parrot delivering the semantics in real time

[07:29] <drbean> mean that he wants parrot to be finished soon? What does it mean?

[07:29] <castaway> who knows :)

[07:29] <castaway> I suspect that he thinks parrot runs slowly

[07:31] <mugwump> http://www.perlmonks.org/index.pl?node_id=459834   # :)

[07:32] <integral> well mandel.p6 was slower than perl5 last I checked (with parrot) (because we're using PMC for everything)

[07:32] <drbean> Who is he referring to when he says those speccing Parrot should have

[07:33] <mugwump> I thought I saw it running on autrijus' laptop a factor of 10 times faster than the Perl 5 version via Parrot in hualien

[07:33] <drbean> used previous implementations before speccing.

[07:33] <mugwump> I'm not sure, drbean :)

[07:33] <integral> mugwump: yeah, it was running very fast earlier

[07:37] <mugwump> yay, that made me level up to abbot :)

[07:37] <gaal> Juerd about?

[07:38] <mugwump> where can I go to spend my XP on more character skills?

[07:42] <castaway> ,)

[07:42] <castaway> grats, mugwump!

[07:44] <nothingmuch> morning

[07:44] <mugwump> hi nothingmuch 

[07:49] <integral> ah, maybeColon is for matching the : in private members?

[07:49] <svnbot6> r3810, bsmith++ | Moved mergeStmts and isEmptyParams from Pugs.Parser to Pugs.AST.

[07:50] <castaway> allo nothingmuch

[07:50] <nothingmuch> hi ho castaway 

[07:54] <integral> hmm, you can't say: class { sub :my_private_sub { ... } }

[08:10] <nothingmuch> Juerd: nothingmuch, [email@hidden.address] Yuval Kogman

[08:10] <nothingmuch> i'll set up a smoke loop

[08:25] <wolverian> mugwump: nice re: perl6 wishlist on perlmonks :)

[08:31] <nothingmuch> wolverian: link?

[08:32] <wolverian> nothingmuch: http://www.perlmonks.org/index.pl?node_id=459834

[08:36] <Aankhen``> mugwump == mugwumpjism on PerlMonks?

[08:37] <wolverian> I don't know, I just assumed!

[08:37] <Aankhen``> Oh, heh, I just noticed you were talking about that too.

[08:38] <Aankhen``> mugwump++ # excellent reply. =)

[08:38] <castaway> yeah that was him, we were discussing it earlier

[08:39] <Aankhen``> Darnit, I'm not getting a dual-core processor after all.

[08:39] <Aankhen``> I'm just getting a 64-bit P4.

[08:40] <afdf> who is in taiwan?

[08:40] <Aankhen``> Ah well, it's lightyears ahead of my Athlon 1.63 GHz. anyway. :-D

[09:09] *** spinclad is now known as spinclad_

[09:12] <Juerd> gaal: pong

[09:12] *** spinclad_ is now known as spinclad

[09:19] *** wilx` is now known as wilx

[09:21] *** f0rth_ is now known as f0rth

[09:26] <lumi> Hi

[09:27] <Juerd> Hello

[09:27] <webmind> morning

[09:28] <spinclad> Hi, all

[09:28] <Aankhen``> Hi.

[09:29] <Juerd> perlmonks--  # slow again

[09:30] <nothingmuch> aix's make is soooo flakey

[09:30] <lumi> Was I imagining that $string.chars would give me the chars?

[09:30] <Juerd> lumi: Those methods are all rather confusing

[09:30] <lumi> Yes

[09:30] <Juerd> lumi: @array.elems gives the *number of* elements

[09:30] <Juerd> lumi: $string.chars gives the *number of* characters

[09:30] <lumi> Although I can see how it's stupid to have .elems return the elems

[09:31] <Juerd> lumi: $string.split('') gives the individual characters

[09:31] <Juerd> lumi: I can't.

[09:31] <lumi> Don't arrays numify correctly though?

[09:31] <Juerd> lumi: Yes, they do.

[09:31] <Juerd> And so could .elems

[09:31] <lumi> So...

[09:31] <lumi> Yes

[09:31] <Juerd> And so could .chars

[09:31] <Juerd> So I'm all for having these return smarter things than just numbers.

[09:31] <lumi> It really makes sense to me to iterate over $string.chars

[09:32] <Juerd> To me too.

[09:32] <Juerd> And if someone wants the number, +$string.chars

[09:32] <lumi> And still no need of the L-word

[09:33] <Juerd> l?

[09:33] <lumi> Length

[09:40] <nothingmuch> moy hed is hoirting, oi oi oi

[09:42] <mauke> Juerd: do you know why tnx.nl doesn't load here?

[09:45] <Juerd> It'll have something to do with the server's 0.04 load

[09:45] <Juerd> Investigating...

[09:45] <Juerd> I killed apache and restarted it. Works now.

[09:45] <Juerd> Thanks for letting me know.

[09:46] <mauke> yay, thanks

[10:05] * integral mutters about his mails not reaching p6c/p6l

[10:12] <integral> ah ha.   Using perl6-language.perl.org does not work ;-)

[10:14] <Juerd> H. Merijn Brand sent his replies to [email@hidden.address] and only yesterday discovered that none of those messages ever arrived :)

[10:14] <Juerd> They don't bounce :)

[10:16] <integral> heh.   I never check my inbox on that account, just all the ML folders, so I'm always missing bounces :-)

[10:35] * nothingmuch wonders how cool a lazy DBI would be in perl 6

[10:36] <nothingmuch> instead of calling weird bindparams, etc

[10:36] <nothingmuch> but fetched as needed

[10:36] <nothingmuch> everything will be inverted

[10:36] <nothingmuch> blobs will be filehandles or strings, depending on how they are handled

[10:36] <nothingmuch> the entire set is symbolically returned at once

[10:36] <nothingmuch> in chunks set as a param to DBI

[10:37] <Juerd> nothingmuch: I made something like that once

[10:37] <Juerd> nothingmuch: But Perl's tieing made syntax awkward

[10:37] <nothingmuch> right, p5 can do this stuff

[10:37] <nothingmuch> but it's awkward

[10:37] <nothingmuch> in perl6 it will be clean and natural

[10:37] <Juerd> It's useful to know that foreach (ARRAY) is different from foreach (LIST)

[10:38] <nothingmuch> in p5 you mean?

[10:38] <Juerd> Yes

[10:38] <castaway> Tie::DBI++ (or is it DBI::Tie, I can never remember)

[10:38] <nothingmuch> that's good to know

[10:38] <Juerd> foreach (ARRAY) does not flatten before it starts looping

[10:38] <nothingmuch> Tie::DBI *is* pretty cool

[10:38] <castaway> I should send in the db2 patch.. naughty me

[10:39] <Juerd> So if ARRAY is tied, it fetches values as they are needed

[10:39] <nothingmuch> The pure-specifier (= 0) is not valid for the non-virtual function "LoadedFunctions::getSharedLibraryName".... *sigh*

[10:39] <nothingmuch> this is my most painful learning experience ever

[10:40] <nothingmuch> i know all the abstract and concepts

[10:40] <nothingmuch> but getting the details right is such a slow iterative process

[10:40] <Juerd> What are you doing then?

[10:40] <nothingmuch> this is the base class for dynamically loaded classes in our C++ thingy

[10:40] <nothingmuch> we are binding to some other companies dynamic libs

[10:41] <nothingmuch> i'm fixing the installer so that it installs the dynamic lib

[10:41] <nothingmuch> and then loads it

[10:41] <nothingmuch> so that the API to the other product is more consistent than it is now (uses a CLI tool and parses it's output... eek!)

[10:42] <nothingmuch> the problem is that the API we're using is split up into many libs, and to clean this stuff up i need to add support to map the libname by symbol

[10:43] <nothingmuch> now my problem is that I don't really know C++

[10:44] <Juerd> 21 users already for a server that doesn't exist yet

[10:44] <Juerd> I wonder if it's going to hold :|

[10:44] <nothingmuch> hah

[10:44] * Juerd is glad L~R didn't announce it on PM :)

[10:44] <nothingmuch> oh fun

[10:44] <nothingmuch> now i screwed up the macro that declares a dynamically loaded function

[10:45] * Juerd hopes the users are spread over timezones well enough :)

[10:46] <webmind> Juerd, what is this server for? except have perl6 ?

[10:46] <Juerd> webmind: Provide access to a linux box with good connectivity for those who don't have this 

[10:46] * integral is refactoring Parser.hs this afternoon which is a *big* file

[10:47] <Juerd> webmind: And some want to use screen+irssi for this channel and irc.perl.org #parrot

[10:47] <nothingmuch> oh wow, different errors this time

[10:47] <Juerd> webmind: So in the end, this server is supposed to boost productivity of many volunteers at the same time.

[10:48] <castaway> assuming it doesnt bog down under the load and reduce it :)

[10:48] <Juerd> castaway: Yea.

[10:48] <webmind> Juerd, hmk

[10:48] <Juerd> castaway: I'm a bit worried about that.

[10:48] <integral> castaway: incentive to learn how to refactor Haskell ;-)

[10:48] <nothingmuch> integral: isn't it supposed to be easy to refactor, being a combinator parser?

[10:49] <castaway> heh, indeed

[10:49] <Juerd> castaway: I think a dramatic decrease of memory use for pugs would be about the nicest thing that could happen right now :)

[10:49] <nothingmuch> i mean, Pugs.Parser.Primtitives, Pugs.Parser.Blocks etc

[10:49] <integral> nothingmuch: it's the more refactoring into separate files that's the problem

[10:49] <nothingmuch> then you have Pugs.Parser which defines the top level grammer,

[10:49] <nothingmuch> and imports, no?

[10:49] <integral> take for example parsing quotes

[10:49] <Juerd> castaway: But if this doesn't hold, I'll try the Perl Foundation for an upgrade

[10:49] <Juerd> castaway: At least if it doesn't hold, that itself proves people want to use this :)

[10:50] <integral> You can have code interpolated in quotes,  so expressions need to parse quotes which need to parse expressions.   So you get these massive loops of cyclic dependencies.

[10:50] <nothingmuch> ah

[10:50] <nothingmuch> so you need the hs_boot crap?

[10:50] <nothingmuch> or are you trying to avoid that?

[10:50] <integral> yes, but we're not using that due to GHC unstableness

[10:51] <nothingmuch> that part about GHC really struck me as odd

[10:51] <nothingmuch> something as elegant as haskell really ought to support this kind of stuff

[10:51] <castaway> what are you putting in it, for RAM?

[10:52] <Juerd> castaway: 1 GB of DDR SDRAM

[10:52] <castaway> I'm sure you could get/ask the various users to donate a euro or two for more

[10:52] <castaway> (each that is)

[10:52] <integral> how much is that stuff? >200€?

[10:52] <Juerd> castaway: I ordered 2*512, filling up both slots

[10:53] <Juerd> integral: An upgrade to 2 GB would cost around 240 euros

[10:53] <nothingmuch> it compiled...

[10:53] <Juerd> But as a company, I can't take donations without HUGE (32%) income tax

[10:53] <castaway> what, only 2 slots? is this a mini board?

[10:53] <integral> ouch

[10:53] <castaway> umm, then take them as a private person?

[10:53] <Juerd> castaway: Yes, micro atx

[10:53] <Juerd> castaway: Same thing, in .nl

[10:53] <castaway> boggle

[10:53] <Juerd> castaway: See Jouke's rants from the time he got a big donation for pvoice

[10:54] <castaway> then let somebody else take, and send you the RAMs :)

[10:54] <Juerd> castaway: But perhaps this can be arranged through the stichting perl promotie (dutch perl promotion foundation)

[10:54] <Juerd> castaway: That's another option

[10:54] <Juerd> Let's first see if this'll hold

[10:54] <castaway> hmm, how do the tax people know someone donated you cash? thats.. weird

[10:54] <castaway> (privately, anyway)

[10:55] <Juerd> castaway: There are ways to make sure they don't. But that is called fraud, and is a felony.

[10:56] <castaway> somehow this doesnt make sense.. but I guess thats just the cultural difference

[10:56] <nothingmuch> Juerd: we can establish a trust protocol of some sort where money is paypalled to one of us without such constraints, which then pays with CC for hw ordered from dutch places to you

[10:56] <webmind> Juerd, you could donate space/bandwith/time as a company to the stichting who provides hardware and receives donations for this ?

[10:56] <Juerd> nothingmuch: Dutch places and CC. Heh. That's very rare.

[10:56] <Juerd> webmind: That would be possible

[10:57] <webmind> Juerd, do you have a tax advantage in the netherlands for donations ?

[10:57] <webmind> as a company

[10:57] <Juerd> First, I wish to stick to the current plan of Convolution owning the entire machine, which is a much simpler legal construction.

[10:57] <nothingmuch> legal stuff sucks so bad,

[10:57] <Juerd> webmind: Nee, alleen een stichting kan donaties krijgen zonder inkomstenbelasting te betalen.

[10:57] <webmind> ok

[10:57] <nothingmuch> look how much overhead over such a simple thing

[10:58] <Juerd> nothingmuch: Just for juridical simplicity, I have to own this box instead of donate it. I could donate money, not hardware. Long live weird regulations.

[10:59] <Juerd> And this money buys less hardware in stores than from wholesale suppliers

[10:59] <Juerd> If this box is a success, perhaps we can get other ISPs to sponsor entire boxes

[11:01] <Juerd> castaway: Oh, and the reason for mini-itx is the small enclosure. The small enclosure is because rackspace is expensive

[11:01] <kungfuftr> Juerd: http://www.bytemark.co.uk

[11:01] <Juerd> kungfuftr: What about it?

[11:02] <kungfuftr> could always sponsor multitudes of those lvm accounts

[11:02] <Juerd> Heh

[11:02] <Juerd> I don't think they like huge memory users on virtual accounts :)

[11:03] <Juerd> There is a reason I didn't just install user-mode-linux (virtual machine) on one of my existing boxes :)

[11:03] <kungfuftr> Juerd: they don't care... it's limited

[11:03] <Juerd> kungfuftr: To 64 MB, yes

[11:04] <kungfuftr> =0)

[11:04] <integral> 64MB makes your pugs builds take 8 hours :-)

[11:04] <Juerd> kungfuftr: Sorry, but that just isn't even close to enough

[11:04] <integral> but how many people are going to be hacking the Haskell?  Won't most people be writing tests, docs and p6 code?   If so, you just need a system-wide pugs installation

[11:04] * kungfuftr wonders if fotango would be willing to sponsor some hardware, etc.

[11:05] <Juerd> integral: Probably - but some people want to compile pugs, for whatever reason

[11:05] <integral> *nod*   I'm trying 2 parallel pugs builds at the moment with 1G ram

[11:05] <Juerd> integral: For example, just after a fix that should make *their* test pass

[11:06] <integral> well as long as it's not a fix in the Parser, Prims or AST it's not bad ;-)

[11:06] <Juerd> But - the smoke cycle can probably install fresh pugses all the time

[11:06] <integral> and make install gets tested :-)

[11:06] <Juerd> Is there a way to cache ghc compiles globally?

[11:07] <Juerd> Like ccache does for gcc

[11:07] <Juerd> s/does/can do/

[11:07] <xinming> anyone here can tell me where to find the perl 6 doc? I mean the language specification or something else.

[11:08] <xinming> I've read perl essentials 2nd (version 2004 June). So I want to know if the book is out dated.

[11:09] <mauke> http://dev.perl.org/perl6/doc/synopsis.html

[11:09] <xinming> mauke: thanks

[11:10] <Juerd> xinming: Every *book* about Perl 6 is outdated.

[11:11] <Juerd> xinming: They are outdated two hours after they are pressed.

[11:11] <Juerd> xinming: By the time they are in stores, they are a month behind

[11:11] <Juerd> xinming: And by the time you buy and read them, an entire perl 6 interpreter was written by autrijus :)

[11:12] <scook0> it's hard enough keeping up with Perl6 as it actually happens...

[11:12] <mauke> while he was sleeping!

[11:12] <castaway> autrijus sleeps?

[11:13] <nothingmuch> castaway: sometimes he claims that

[11:14] * castaway doesnt believe it

[11:15] <mauke> maybe his computer has a neural interface and he codes in his dreams

[11:15] <castaway> this would not surprise me :)

[11:16] <Juerd> castaway: Well, he sometimes says he's off to bed, and then after a few hours you see a huge commit in the logs. So I don't believe it :)

[11:17] <castaway> hehe

[11:17] <castaway> from what I figure, he sleeps only in max. 30 min chunks, or something

[11:17] <Juerd> I think he hyperthreads

[11:17] <Juerd> One brain sleeps while the other waits for input

[11:17] <castaway> ahhh.. thats it .)

[11:17] <Juerd> No, the other way around :)

[11:18] <Juerd> One brain sleeps while the other PROCESSES :)

[11:18] <Juerd> One brain sleeping with the other waiting is MY brains :)

[11:18] <castaway> :)

[11:21] * nothingmuch sometimes hyperthreads 3-4 active brains, but it only lasts about 5-6 hours

[11:21] <nothingmuch> then all the brains have overheated and are clocked down by the BIOS

[11:21] <nothingmuch> for about 2 days

[11:22] <nothingmuch> i think that is mostly dependant on exactly 8 hours of sleep

[11:22] <nothingmuch> good sleep too

[11:22] <nothingmuch> not too much sugar

[11:23] <nothingmuch> and headphones

[11:25] *** chady is now known as chady_

[11:29] <Juerd> Ooh, first part arrived: the main board :)

[11:30] <nothingmuch> =)

[12:12] <nothingmuch> deceptive code is sooo bad

[12:12] <nothingmuch> code that seems to be doing something

[12:12] <nothingmuch> but actually never happens

[12:12] <nothingmuch> especially with everyone around you telling you that's what it does

[12:17] <integral> ah, I've found the real killer memorywise: having a 168M ghc sitting there whilst cc1 balloons up to 250M

[12:18] <integral> so the trick if you're running multiple GHC's is to not have them compiling Pugs.AST.Internals simultaneously

[12:21] <svnbot6> r3811, autrijus++ | * add Eric's Tutorial to READTHEM

[12:25] <wolverian> argh, people who can't use mailing lists drive me insane. I don't want mailing list posts in my inbox!

[12:25] * integral hides under a rock

[12:26] <wolverian> better to learn so you won't starve :)

[12:33] <castaway> wolverian: I would put the blame on mail/news clients that insist on default to "answer all" and not the mailing list

[12:35] <wolverian> castaway: if the client has the functionality to reply to the mailing list only, even if it's not the default action when one pressed 'reply', I think the user should be blamed. if the client has no such functionality at all (thunderbird..) it's certainly horribly broken.

[12:36] <wolverian> s,pressed,presses,

[13:03] <masak> wolverian: sorry, I accidentally pressed 'send' without removing you :/

[13:03] * masak won't do it again

[13:03] <masak> help reason

[13:04] * masak apparently struggles both with email and IRC today

[13:04] <Limbic_Region> ok - a while back I asked about @hand[1..3]>><suit> syntax

[13:05] <Limbic_Region> IIRC, it was valid but unimplemented

[13:05] <Limbic_Region> sound right?

[13:07] <wolverian> masak: ah, don't worry. it doesn't really bother me that much, at least if it doesn't happen all the time. :) (I replied to you, by the way, on the list.)

[13:07] <integral> hmm, why is Pad a data rather than a newtype?

[13:08] <wolverian> Limbic_Region: looks right. does it need .<suit>?

[13:09] <Limbic_Region> I think . is only necessary when it is necessary (but I am not positive on that)

[13:09] <wolverian> well. I think I agree! :)

[13:10] <Limbic_Region> ok - so >> is like a distributive directive - how would I have said the same thing if I meant the whole array?

[13:10] <Limbic_Region> @hand>><suit> ?

[13:10] <wolverian> yes.

[13:10] <Limbic_Region> ok

[13:10] <Limbic_Region> so then doing something like - all( @hand>><suit> ) eq 'D' should be valid syntax?

[13:10] <wolverian> yes.

[13:11] <wolverian> (the parens should be optional there.)

[13:11] <Limbic_Region> ok - well then I guess I should write a test for it so it gets implemented then ;-)

[13:11] <wolverian> please do that. :) I thought >> worked for methods already, by the way. does it not?

[13:11] <Limbic_Region> I am sure that it does

[13:11] <wolverian> (I don't have access to pugs currently, I'm at university)

[13:11] <Limbic_Region> I think it is just limited implementation

[13:12] <wolverian> right. please write a test then.

[13:12] <Limbic_Region> you can always browse the subversion repository though

[13:12] <wolverian> by the way, has anyone been updating perl6.vim in utils/? Its last modification date is marked as something in 2002!

[13:13] <wolverian> Limbic_Region: HTTP doesn't lend itself well to a grep :)

[13:13] <Limbic_Region> right

[13:13] <Limbic_Region> which is my problem ATM

[13:13] <Limbic_Region> I forgot to ask Jonathan if he could include the test suite in his binary builds

[13:13] <Limbic_Region> any idea where there may be existing tests for >> ?

[13:14] <wolverian> looking, sec

[13:14] <wolverian> operators/hyper.t

[13:15] <wolverian> it tests for @r>>++ and such

[13:15] <wolverian> it doesn't seem to test for hyper subscripts

[13:15] <wolverian> only method and ++

[13:16] <Limbic_Region> ok - so let me see about adding a test for slice and for dereferencing

[13:16] <gaal> wolversian, sure, svn log it.

[13:16] <wolverian> gaal: I don't have svn here.

[13:16] <wolverian> and I can't install it. 

[13:16] <theorb> wolverian: wget?

[13:16] <gaal> well, yes: there have been minor changes.

[13:17] <wolverian> theorb: is the raw svn log available via HTTP or something else besides svn?

[13:17] <Limbic_Region> I think so

[13:17] <theorb> The raw log, not that I'm aware of.

[13:17] <Limbic_Region> hang on

[13:17] <theorb> You can get it cookied, though.

[13:17] <theorb> Er, cooked.

[13:17] <wolverian> what's cooked? :)

[13:17] <gaal> http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/log/ ?

[13:17] <wolverian> ah. right. thanks!

[13:18] <gaal> that also has diffs between versions, but i found it a little awkward to use.

[13:18] <wolverian> woo, openfoundry has a search function too :)

[13:18] <wolverian> oh, that is for projects, not inside a project. :/

[13:20] <wolverian> have to go. bye!

[13:20] <svnbot6> r3812, gaal++ | %h{"key"} -> %h<key>, plus a couple of fixes to the TODOed AUTOLOAD section.

[13:22] <Limbic_Region> perlbot nopaste

[13:22] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[13:23] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Do these tests look reasonable for adding to t/operators/hyper.t" (11 lines, 279B) at http://sial.org/pbot/10372

[13:24] <Limbic_Region> and if they do look reasonable - would someone mind comitting them?

[13:24] <gaal> you don't have the commit bit, l~r?

[13:25] <Limbic_Region> I do

[13:25] <Limbic_Region> but I have an issue from committing from work

[13:25] <gaal> ah :)

[13:25] <Limbic_Region> and I have been without net access at home for nearly a month

[13:26] <Limbic_Region> which if that isn't rectified by tomorrow - I am going to be a very unhappy camper

[13:26] <Limbic_Region> and I'm not very nice when I am not happy

[13:26] <gaal> i have a very weird recurring transient network problem here. sometimes it looks like HTTP stops working. :)

[13:27] <Limbic_Region> out of curiosity - does anyone know how easy it is to configure svk (or svn if I could get it installed) working through an HTTP proxy?

[13:27] <gaal> doesn't svk require svn?

[13:27] * integral would hope you just set $*ENV<<http_proxy>>

[13:28] <Limbic_Region> gaal - if it does it is all under the covers

[13:28] <Limbic_Region> I think it just needs some library or something

[13:28] <Limbic_Region> not sure

[13:29] <Limbic_Region> I would have to clear it with security anyway - rather hard to justify since p6 doesn't have any tangible relation to my job

[13:30] <Limbic_Region> my boss buys the "by learning new stuff I am making myself more valuable" bit - not sure security would be so understanding

[13:30] <Limbic_Region> in any case, if those tests look reasonable I would appreciate someone comitting - I should be able to start carrying my own load tomorrow

[13:32] <gaal> i just got my port 80 back. looks okay to me... suggest a name, l~r?

[13:32] <gaal> oh, sorry, you did

[13:33] <theorb> I should suspect it'd be easy, but depends on the firewall.

[13:33] <clkao> Limbic_Region: same as svn. you modify ~/.subversion/config

[13:33] <clkao> or servers, can't remember

[13:34] <Limbic_Region> thanks clkao - will keep it in mind should I find a real application of p6 for work

[13:35] <gaal> r3813, l~r.

[13:36] <Limbic_Region> cool - thanks

[13:36] <svnbot6> r3813, gaal++ | hyper dereferencing tests by Limbic~Region++

[13:38] <Limbic_Region> once that gets implemented - all the places where I used map I can use >> which will be a major improvement visually

[13:38] <integral> hmm

[13:38] * integral stares at what ruleSubHead is doing

[13:39] <integral> it uses maybeColon to grab a colon in `method :foo' for example,  but the maybeColon is missed from the `sub :foo' case, but this still parses :-/

[13:40] <integral> also, is using ":d sub bar { }" meant to produce just 'Noop; Noop;" as output?

[13:41] <Limbic_Region> integral - did you just uncover a Schroedinbug ???

[13:42] <Limbic_Region> http://www.huis.hiroshima-u.ac.jp/jargon/LexiconEntries/Schroedinbug.html

[13:42] <integral> I really, really, hope not.

[13:46] <Juerd> feather is built

[13:46] <Juerd> Now I have to wait 100 minutes for KNOPPIX to download.

[13:46] <integral> it's not going to be debian?

[13:46] <Juerd> It is

[13:46] <Juerd> http://juerd.nl/debianraid

[13:47] <Juerd> I accidentally removed the knoppix iso from my laptop, and someone stole my cd (again)

[13:47] <castaway> (knoppix IS debian..)

[13:47] <Juerd> where is is is, not == or eq :)

[13:48] <integral> *blink*, your swap is raided?

[13:48] <Juerd> Of course!

[13:49] <integral> why? 

[13:49] <Juerd> Don't want part of system memory to suddenly go away when a drive fails

[13:49] <Juerd> The system should keep running at least until I'm there to service it.

[13:49] <Juerd> And not die at the first crash

[13:49] <Juerd> RAID is about more than just data safety

[13:49] <integral> hmm, interesting

[13:50] <Juerd> Interesting? I'd call it common sense :)

[13:50] <Juerd> Although you're probably the fifteenth to react like this :)

[13:50] * integral would have gone for double the swap space, but with less reliability

[13:50] <Juerd> I would certainly not

[13:51] <Juerd> Do you know what happens if you pull one of two DIMMs from a running system?

[13:51] <Juerd> Apart from the electrical damage, the difference with failing swap space is not that big.

[13:51] <Juerd> Programs using that part of memory will segfault

[13:51] <Juerd> Or die with bus errors

[13:51] <Juerd> etcetera

[13:52] <Juerd> Now, what if the long idle *init* got part of it paged out? That must hurt.

[14:14] <svnbot6> r3814, bsmith++ | Moved a few pad handling functions to Pugs.AST.Pad.

[14:15] * theorb shrugs.

[14:15] <theorb> Like everything else, it's a trade-off.

[14:17] <castaway> ah, there you is

[14:17] <theorb> I am everywhere.

[14:17] <castaway> hmm, well my /msg's arent being answered..

[14:21] <svnbot6> r3815, bsmith++ | Removed the use of maybeColon from ruleSubHead because it doesn't appear to

[14:21] <svnbot6> r3815, bsmith++ | actually do anything since ruleSubName just takes the : as part of the name

[14:21] <svnbot6> r3815, bsmith++ | anyway.

[14:23] <iblech> integral: [:d sub ... {...} shows Noop; Noop] That's ok, as all sub declarations are implicitly done in BEGIN blocks

[14:23] <integral> sure, but it's not very useful for debugging the parser

[14:23] <iblech> integral: This is so sub infix:<...> {...} can work

[14:23] <integral> I had to use: :d my sub ... { ... }

[14:23] <iblech> integral: Right

[14:23] <integral> it would be nice if the noop node hung onto what what ran, when you're doing debugging

[14:27] <dakkar> did anyone write any Perl6 JAPHs we could put on the t-shirt for the Italian Perl Workshop?

[14:27] <dakkar> or golfs..

[14:28] <iblech> dakkar: There's examples/golf

[14:28] <japhy> is <after ...> a look-AHEAD or a look-BEHIND?

[14:28] <japhy> is it saying "this pattern must come after where we are"

[14:29] <japhy> or "we must be after this pattern"

[14:29] <japhy> I think it's a terrible name :/

[14:30] <Juerd> japhy: with /foo <after bar>/, "after" is about "bar" and has nothing to do with foo

[14:30] <Juerd> This match fails because foo cannot be bar

[14:31] <Juerd> It is look behind

[14:31] <Juerd> See it from pos(): "we are after bar"

[14:31] <japhy> so "after" is look behind, and "before" is look ahead

[14:31] <Juerd> Yes

[14:32] <japhy> ok.

[14:32] <japhy> it's from the point of view of pos().  good explanation.

[14:34] <gaal> iblech, please see http://perlmonks.org/?node_id=459888

[14:36] <gaal> who's responsible for the svn commit feed?

[14:36] <gaal> it isn't escaping HTML

[14:37] <dakkar> is @a »+« @b the same as map {$^a + $^b} zip @a,@b ?

[14:37] <Khisanth> try it out and see? :)

[14:37] <iblech> gaal: Thanks, replied

[14:37] <japhy> dakkar - I think that is exactly what it's like.

[14:38] <gaal> iblech++

[14:51] <integral> ah, the Context in ruleSubScopedWithContext is actually the return type

[14:52] <dakkar> if I try to run map {$^a + $^b} zip @a,@b I get '$b undeclared'

[14:55] <ninereasons> dakkar, that bug has been seen.  but I don't know whether there is a test written to demonstrate it.

[14:55] <dakkar> ok

[14:56] <dakkar> on the same note, map $a,$b -> {$a+$b} zip @a,@b should work?

[14:56] <dakkar> (i.e. is it correct syntax?)

[14:56] <iblech> dakkar: I think you need a "," after the "}"

[14:57] <iblech> dakkar: Not sure, though

[14:57] <dakkar> pugs (svn up 10 min ago) doesn't parse the '->'

[14:57] *** Aankh|Clone is now known as Aankhen``

[14:57] <integral> err, the syntax for -> is: -> $a, $b { $a + $b }

[14:58] <iblech> integral: D'oh, of course, you're right

[14:58] <dakkar> oh. ok.

[14:58] <ninereasons> however, it also will not work, if I recall

[14:58] <dakkar> it does something.

[14:58] <dakkar> pugs> print map -> $a,$b {$a+$b} zip [1,2,3],[4,5,6]

[14:58] <dakkar> 142536bool::true

[15:00] <ninereasons> it doesn't appear as though map is doing anything there.

[15:00] <dakkar> righ

[15:00] <integral> hmm

[15:00] <theorb> I would expect that to give 5, 7, 9, though.

[15:01] * integral ponders doing the Pugs.Parser -> Pugs.Parser.Internals move

[15:01] <ninereasons> it would, if it saw $b

[15:01] <ninereasons> but it doesn't - that's the bug, I think

[15:01] <dakkar> pugs> print map -> $a,$b {"$a + $b"} zip [1,2,3],[4,5,6]

[15:01] <dakkar> 1 + 4 + 2 + 5 + 3 + 6 + bool::true

[15:01] <Juerd> 22

[15:01] <dakkar> yes, $b is not used

[15:01] <iblech> Hrm -- I thought map is supposed to only take one argument?

[15:02] <ninereasons> oh.  well, you may be right, iblech 

[15:02] <Juerd> iblech: No, if the closure has arity of 2, it takes 2 per iteration.

[15:02] <dakkar> just like 'for'

[15:02] <iblech> Juerd: Oh! Didn't know that. It doesn't seem to be implemented yet, though

[15:03] <Forth_> does 'next' work in while loop?

[15:03] <Juerd> dakkar: Write a test?

[15:03] <dakkar> works in 'for'

[15:03] <Juerd> Forth_: It should.

[15:03] <dakkar> pugs> for (zip [1,2,3],[4,5,6]) -> $a,$b {print "a: $a b: $b"}

[15:03] <dakkar> a: 1 b: 4a: 2 b: 5a: 3 b: 6undef

[15:04] <dakkar> Juerd: where should I write it?

[15:04] <Juerd> dakkar: In your favourite editor's write buffer

[15:04] <dakkar> Juerd: ;-)))

[15:04] * Juerd doesn't understand the question, really

[15:04] <dakkar> let me rephrase

[15:05] <dakkar> how should I let the rest of the world know that I wrote the test, what is the content of said test, and that it should be included (as todo) in pugs's test suite?

[15:05] <ninereasons> [+] zip[1,2,3],[4,5,6]

[15:05] <ninereasons> :)

[15:05] <Juerd> dakkar: Ask autrijus for an svn login with commiter access

[15:06] <Juerd> dakkar: http://perlmonks.org/?node_id=455988

[15:06] * dakkar ponders whether he wants that much power...

[15:06] <Juerd> Why not?

[15:06] <Juerd> Every mistake you make, and you probably won't make any, can be reverted.

[15:07] <dakkar> hmm... I might do it

[15:08] <PerlJam> dakkar: in lieu of getting commit access, you can send a message to [email@hidden.address] and someone with commit access will probably make it happen.

[15:10] <ninereasons> dakkar, I can assure you that you probably deserve commit access more than I do :-)

[15:11] <Juerd> I don't think it's about deserving

[15:11] <Juerd> But instead about productivity

[15:11] <Juerd> If you can work with svn directly, you can do more in less time and you don't have to bother others every time you have a patch

[15:12] <ninereasons> Juerd, nicely made point

[15:13] <ninereasons> should parens be required, for hyperoperators to work on lists like 3..8 ?

[15:13] <PerlJam> And if you screw up in a subtle way, you can fix it without getting others involved :)

[15:14] <PerlJam> ninereasons: er, why would they be required?

[15:14] <ninereasons> (1..3) >>+<< (4..6)

[15:14] <Juerd> ninereasons: No

[15:14] <ninereasons>  1..3 >>+<< 4..6

[15:14] <ninereasons> Internal error while running expression:

[15:14] <ninereasons> a but, I guess

[15:14] <Juerd> ninereasons: >>+<< as a while has the same precedence as normal +

[15:14] <ninereasons> s/but/bug/

[15:15] <dakkar> so it gets parsed as 1..(3>>+<<4)..6 ?

[15:17] <Juerd> Hm, yes

[15:17] * Juerd didn't expect .. to have such low priority

[15:19] <wolverian> hmm. that's a surprise. I've always done 1..($a+$b) in perl5 too, even though + has tighter precedence.

[15:20] <Juerd> Me too

[15:34] <Limbic_Region> Juerd - your offer has leaked to the Monastery

[15:34] <Limbic_Region> albeit - buried in a thread

[15:34] <Limbic_Region> http://perlmonks.org/index.pl?node_id=459994

[15:38] * integral wonders about the point of methOps

[15:39] <Limbic_Region> integral - so we can all be as productive as autrijus

[15:39] <integral> heh

[15:39] <Limbic_Region> meth does keep you up for days on end with an alert mind right?

[15:40] <Odin-LAP> Depends.

[15:41] <Odin-LAP> You're referring to methamphetamine, correct?

[15:41] <Limbic_Region> Odin-LAP yes, and I do realize it doesn't have the same effects in all people (ADD/ADHD for instance)

[15:42] <Limbic_Region> it was meant to be an attempt at humor

[15:42] <Odin-LAP> Well, that wasn't what I was referring to, actually. :>

[15:43] <Odin-LAP> It depends on what you mean by 'alert', largely. ;)

[15:44] <integral> hmm, the stuff for quotes is *scary*

[15:45] <Odin-LAP> Indeed.

[15:48] <dakkar> is there any way to apply a s/// to a constant and get a modified copy?

[15:50] <PerlJam> dakkar: that makes no sense.

[15:50] <gaal> doesn't the p5 idiom work? (my $modified = $constant) =~ s///

[15:50] <PerlJam> what gaal said

[15:50] <dakkar> no, it looks for a &my subroutine

[15:50] <gaal> alternatively, in some cases you might do with "is copy" :)

[15:51] <gaal> it does? that looks like a precendece problem, maybe a bug, too.

[15:51] <Limbic_Region> dakkar - you don't need the s in the ///

[15:51] <Limbic_Region> unless you do that is

[15:51] <dakkar> I don't?

[15:52] <Limbic_Region> my ($match) = $string =~ /(foo)/;

[15:52] <dakkar> I want to do s:g/\s+/ /

[15:52] <Limbic_Region> if you don't actually need to change the string but need to capture some pattern - you can get away without the s

[15:52] <dakkar> I think I need the 's'

[15:52] <Limbic_Region> if that made any sense at all

[15:52] <integral> ah ha!  There's some RuleParsers that don't actually do parsing, but just read the state

[15:52] <Limbic_Region> dakkar - no you don't

[15:52] <Limbic_Region> course I don't know how to do this in p6

[15:53] <Aankhen``> What's wrong with t/builtins/lists/uniq.t?

[15:53] <dakkar> Limbic_Region:  how do you collapse the spaces in perl5?

[15:53] <gaal> L~R, when you have /g w/o capture the approach you suggest doesn't work that well.

[15:53] <Limbic_Region> my $foo = join '', <extract all non-strings>

[15:53] * integral wonders if getState can be changed to ask

[15:55] <integral> oh, ask is reader, state is get/put

[15:56] <integral> bah, there's no MonadState instance for GenParser

[15:56] <Limbic_Region> errr - sorry, someone was talking to me

[15:56] <Limbic_Region> my $foo = join '', <capture all non-whitespaces>;

[15:57] <integral> my $foo = [~] <capture all non-whitespaces> ...

[15:57] <Limbic_Region> right - so we just need the fill in <>

[15:57] <Limbic_Region> in p5 you might use () = $str =~ /(\S )/g;

[15:58] <Limbic_Region> or something like it

[16:02] <iblech> Yay! Juerd, you remember we talked about map dealing with n-ary functions, and I said they were not yet implemented? I correct myself :)

[16:02] <autrijus> rehi

[16:02] <iblech> Hi

[16:02] <autrijus> <- deep in $work, so will lurk a bit :)

[16:02] <autrijus> dakkar: [email@hidden.address] ? I'll send an invitation mail

[16:03] <autrijus> iblech: want to be metacommitter? :)

[16:03] <iblech> autrijus: Sure :)

[16:03] <autrijus> iblech: done. welcome aboveboard :D

[16:03] <iblech> autrijus: :D

[16:04] <autrijus> the admin ui url is http://rt.openfoundry.org/Foundry/Project/Admin/Members/?Queue=270

[16:04] <Juerd> iblech: Wasn't that, like, just an hour ago?

[16:04] <dakkar> print [~] (-> @c is copy {gather { while @c[0] { for @c -> {take shift $_} } } }(map { [ split "",$_ ] } ('Joec','utrk','shle','te6r',' r .','a h.','nPa.')));

[16:04] <iblech> Juerd: Yep :)

[16:04] <dakkar> (that's what I was working on...)

[16:05] <autrijus> dakkar: whoa.

[16:05] <Juerd> iblech: I remember that.

[16:05] <autrijus> dakkar: commit it to examples/obfu/ please :)

[16:05] <integral> :0

[16:05] <autrijus> actually, examples/japh/

[16:05] <dakkar> It will get printed on the t-shirt at the Italian Perl Workshop

[16:05] <Limbic_Region> dakkar - in p5, this is how you might do it (without substitution)  perl -e 'my $str="white spaces suck";my $new= join "", $str =~ /(\S )/g;print $new'

[16:06] <dakkar> autrijus: ok, I'll do. 

[16:06] <Limbic_Region> not sure if the same thing would work in p6

[16:06] <dakkar> Limbic_Region: but it's ugly ;-))

[16:06] <Limbic_Region> not really

[16:06] <Limbic_Region> join '', $str =~ /(\S )/g # is ugly?

[16:06] * Limbic_Region thinks it is kinda sexy

[16:07] <dakkar> you're building a list to move between strings...

[16:07] <PerlJam> uglier than ($new = $str) =~ s/\s+//g;

[16:07] <osfameron> At 3815, nmake gives "makefile(420) : fatal error U1087: cannot have : and :: dependents for same target"

[16:07] <gaal> should -n on the commandline autochomp? it does now.

[16:07] <gaal> contrast: /bin/echo -e "one\ntwo\nthree" | ./pugs -ne 'say "> $_"'

[16:07] <Limbic_Region> *shrug* - I tend to not modify strings that I only want copies of

[16:08] <gaal> and /bin/echo -e "one\ntwo\nthree" | ./pugs -e 'say "> $_" for =$*IN'

[16:08] <Limbic_Region> and if it is a constant I really didn't mean to modify it

[16:08] <PerlJam> Limbic_Region: but that doesn't modify $str at all.

[16:08] <Aankhen``> Ahh.

[16:09] <Aankhen``> uniq.t failed because there was no argument between the code block and the next parameter in a function call.

[16:09] <Limbic_Region> *shrug*

[16:10] <dakkar> gaal: to get autochomp in p5 you have to use -l

[16:11] <PerlJam> "say" makes -l largely irrelevant for perl6

[16:11] <PerlJam> gaal: I think autochomping is probably best.

[16:11] <gaal> er, please look at my examples

[16:11] <autrijus> hm

[16:11] <autrijus> print [~] (-> @c is copy {

[16:12] <autrijus>     gather {@c.map:{take(.shift)} while @c[0]}

[16:12] <autrijus> } ([<Joec utrk shle te6r>,' r .','a h.','nPa.'].map:{[split "",$_]}));

[16:12] * autrijus can't resist the golfing urge

[16:12] <autrijus> but in particular, $_.shift can be shortened to .shift

[16:12] <gaal> i know how you autochomp in p5. i know about say. i was wondering if -n is supposed to autochomp, while =$fh not.

[16:12] <dakkar> aha! that's the way. I got bitten by 'shift' not dofaulting to $_

[16:13] <autrijus> yeah, I'm glad there's ./method so .foo can mean $_.foo

[16:13] <autrijus> Juerd++

[16:13] <autrijus> and also, s/print/say/

[16:13] <PerlJam> gaal: and I think that -n autochomping is probably the best behavior (and =$fh not unless we asked it to)

[16:14] <autrijus> say [~] (...)

[16:15] <autrijus> also, if you make the @c slurpy, I think it will copy by default

[16:15] <autrijus> but that may be construed as a bug.

[16:15] <autrijus> or not. not sure

[16:16] <gaal> autrijus, since you mentioned slurpiness :) i'm revisiting pipe open

[16:16] <gaal> and don't see why its fhs are indeed slurpy!

[16:16] <autrijus> say [~](-> *@c { { @c.map:{take(.shift)} while @c[0] }.gather }

[16:16] <autrijus>     ([<Joec utrk shle te6r>,' r .','a h.','nPa.'].map:{[split "",$_]}));

[16:17] <autrijus> I shouldn't golf. it's even more addictive than nethack.

[16:17] * autrijus tries to fight the withdrawal

[16:17] <autrijus> gaal: slurpy in which sense?

[16:17] <gaal> it returns VHandles just like open, but look at this:

[16:17] <gaal> ./pugs -e 'my($i,$o,$e,$p) = Pugs::Internals::runInteractiveCommand("cat -"); say $i: "one";say $i: "two";close $i;say =$o'

[16:17] <gaal> that last say, it slurps everything in $o

[16:18] <gaal> shouldn't it have only read one line?

[16:18] <autrijus> no, list context and all.

[16:18] <autrijus> say scalar =$o

[16:18] <gaal> eh

[16:18] <gaal> right

[16:18] <autrijus> that hadn't changed since p5 :)

[16:18] * gaal is teh dumb

[16:18] <autrijus> nah. cryptocontext is teh confusing

[16:19] <gaal> heh :) okay, got pointers for me on how to make a facade for this written in perl6?

[16:19] <autrijus> facade? this?

[16:20] <autrijus> you mean open("cat -")?

[16:20] <gaal> i know i keep bringing this up and it isn't specced yet, but i want a.. usable open + pipe open already

[16:20] <autrijus> open("cat -|"), even

[16:21] <autrijus> so, I don't know... I think both IPC::Run3 and IPC::Run are good UIs

[16:21] <gaal> not that one, i think it was agereed it's a bad idea and that magic is reserved for io("cat -|")

[16:21] <autrijus> so I'd be happy to see either ext/IPC-Run3/ or ext/IPC-Run/

[16:21] <autrijus> but really, improvise :)

[16:22] <gaal> hmmm, okay; but how does the run-of-the-mill programmer use a unidirectional pipe?

[16:22] <svnbot6> r3816, iblech++ | * map can now take n-ary functions.

[16:22] <svnbot6> r3816, iblech++ | * Added a test for n-ary map to map.t.

[16:22] <gaal> really i'm asking: how to add a prim, that's implemented in perl6

[16:22] <autrijus> gaal: you can use op1 eval :)

[16:23] <autrijus> and write perl 6 in Prim.hs

[16:23] <autrijus> (not saying it's a good idea neccessarily)

[16:23] <autrijus> (but if you refactor it away a bit as Prelude.pm it probably works better)

[16:23] <autrijus> (Prelude.pm can also contain all the signatures for Prims, so we can kill the bad table)

[16:23] <gaal> that's the step i'm missing, i don't see how that would work

[16:24] <autrijus> how calling eval and evalExp would work?

[16:24] <autrijus> it's easy... you already have params in the form of $?0 $?1 etc

[16:24] <autrijus> so in Prim.hs you can just say

[16:24] <gaal> how Eval finds the code to actually run when it encounters a "prim" that isn't in Prim.hs

[16:25] <autrijus> gaal: oh. you still need to declare it in Prim.hs table below

[16:25] <autrijus> or find other ways to put it into initDecl

[16:25] <autrijus> or the emptyEnv

[16:25] <gaal> what's initDecl?

[16:25] <autrijus> gaal: anyway, you can first do it as a module and we can see how to integrate it makes more sense

[16:25] <autrijus> err, primDecl

[16:26] <autrijus> it's the list of symbols to load at init. env.

[16:26] <gaal> gotcha, thanks.

[16:26] <autrijus> np :) 

[16:26] * autrijus $works and lurks

[16:27] <autrijus> I think with good codegen, I'd welcome defining most prims as Prelude.pm

[16:27] <gaal> src/Prelude/Prelude.pm ?

[16:27] <autrijus> but currently it will slow things down a lot

[16:28] <gaal> i'm starting modestly, with pipe1

[16:28] <gaal> so that most tests can get rid of the temporary files :)

[16:28] <Limbic_Region> speaking of things being slow

[16:28] <autrijus> gaal: src/perl6/Prelude.pm probably

[16:28] <Limbic_Region> I think my cribbage hand scoring code might be good to profile to find bottlenecks

[16:28] <Limbic_Region> it is S-L-O-W

[16:28] <autrijus> but maybe ext/Prelude/ for now really

[16:28] <theorb> If it's under src, it should be under Pugs.

[16:28] <autrijus> or ext/Builtins/

[16:29] <Aankhen``> Would introducing HTML::Entities as a required module for CGI be a Bad Thing (tm)?

[16:29] <autrijus> Limbic_Region: yeah. sadly the bottlenexk is well known

[16:29] <autrijus> Limbic_Region: it's op dispatch loop

[16:29] <Limbic_Region> ok

[16:29] <Forth_> hmm...my make install on FreeBSD stopped at /usr/bin/perl -Iinc util/version_h.pl src/Pugs/pugs_version.h

[16:29] <autrijus> Limbic_Region: and that part can't be fixed in interpreter core without rewriting Eval.hs -- something I don't want to do

[16:29] <theorb> Hm, autrijus, I considered this a while ago, but didn't say anything.

[16:29] <autrijus> Limbic_Region: so instead I'll just improve the codegen part.

[16:29] <theorb> Should opN return a bit of code to do something, rather then doing it?

[16:30] <Limbic_Region> well - I can improve things by using less ops of course

[16:30] <autrijus> Limbic_Region: because we know that by compiling things to something lower leve, the op dipsatch loop will be gone

[16:30] <autrijus> Limbic_Region: sure, but that's not the solution for general adopters

[16:30] <Limbic_Region> but I intentionally made it a boheamoth so there would be a lot of room for improvement

[16:30] <autrijus> theorb: "code"

[16:30] <autrijus> theorb: p6 code?

[16:30] <Limbic_Region> right autrijus

[16:31] <theorb> Then we can replace the opN call with the thing that opN returns, so we only have to do the lookup once.

[16:31] <theorb> No, haskell code.

[16:31] <autrijus> Limbic_Region: as I said on pm, my priority now is 1)interop 2)codegen

[16:31] <autrijus> theorb: oh. in -O mode GHC already does that for you.

[16:31] <autrijus> I think that's what skew found out.

[16:31] <theorb> Oh.

[16:31] <autrijus> referential transparency and all that.

[16:31] <theorb> Noddage.

[16:32] <theorb> That's why I haven't brought this up before -- I thought haskell might have already been that smart.

[16:32] <autrijus> it is indeed that smart :)

[16:32] <theorb> Turns out I should have stayed with that first thought.

[16:33] <autrijus> that's okay :)

[16:33] <autrijus> the GHC optimiser is still largely a mystery to me.

[16:35] <Limbic_Region> autrijus - out of curiosity, which should be faster (assuming both were implemented currently)

[16:35] <Limbic_Region> grep { $_<val> == 5 } @combo;

[16:35] <Limbic_Region> or none( @combo>><val> ) == 5;

[16:35] <Limbic_Region> err - there should have been a ! in front of the grep

[16:36] <Limbic_Region> I ask because part of the problem with the cribbage scoring is that I had to work around unimplemented features (which may make things faster naturally)

[16:36] <autrijus> any(@combo>>.<val>) == 5

[16:36] <Limbic_Region> is the . necessary?

[16:36] <autrijus> I think so.

[16:37] <Limbic_Region> if so, the two tests gaal added for me need to be changed

[16:37] <autrijus> the . is mandatory unless the preceding things is a quotelike

[16:37] <Limbic_Region> t/operators/hyper.t (dereferencing tests)

[16:37] <autrijus> or an identifier

[16:37] <autrijus> which >> is neither

[16:37] <Limbic_Region> ok - so the test needs to be changed

[16:37] <autrijus> k. I'm sure someone will take care of that :)

[16:37] <Limbic_Region> and having >> would make it faster 

[16:37] <autrijus> to answer your question -- I don't nkow. that's why I want clkao's Benchmark.pm.

[16:38] <Limbic_Region> ahhh

[16:38] <Limbic_Region> ok

[16:38] <autrijus> it looks like same number of runloop will be needed.

[16:38] <autrijus> but any() will only run once if all val in @combo is identical

[16:38] <autrijus> so it has the potential of being faster.

[16:39] <Limbic_Region> and I have a lot of map() that could be transformed to >> as well

[16:39] <autrijus> but identity/equiv test may not be faster than "== 5"

[16:39] <autrijus> so I don't know. :)

[16:39] <gaal> do we have  ([ $x, $xs ])  sub params already?

[16:39] <Limbic_Region> *shrug* - clkao's Benchmark.pm will be a great value indeed

[16:39] <autrijus> gaal: no, not unpacking yet

[16:40] <autrijus> I think he's already got it written. but he said he's to lame to finish up and check in

[16:40] <gaal> 'nks.

[16:40] <Limbic_Region> seen clkao

[16:40] <jabbot> Limbic_Region: clkao was seen 3 hours 6 minutes 48 seconds ago

[16:41] <Limbic_Region> I will beg/grovel next time I see clkao for it then

[16:41] <autrijus> I think clkao only accepts the .complain method

[16:41] <autrijus> so that's what you should invoke him with

[16:41] <theorb> autrijus++

[16:42] <Limbic_Region> oh - I am sure the way I am going about counting 15s in the cribbage hand is definately not the smartest way to do it

[16:42] <Limbic_Region> and runs for that matter

[16:45] <gaal> do we have all(<module package>) ?

[16:46] <svnbot6> r3817, adehohum++ | Fixing undef tests

[16:47] <autrijus> gaal: yes

[16:47] <autrijus> but currently they are synonyms

[16:47] <gaal> good enough for me :)

[16:48] <autrijus> amusing answer to revdiablo's thread: http://perlmonks.org/?node_id=460030

[16:49] <autrijus> "I'm not using Perl 6 because... I'm too busy learning Haskell. Seriously. The Pugs project has convinced me that Haskell is an incredibly powerful language and I want to know why and use that power myself."

[16:49] <gaal> heh

[16:51] <Juerd> lol

[16:51] <Juerd> Meanwhile, I'm wasting my time fighting yet another php fanboy on PM

[16:51] <Juerd> http://perlmonks.org/?node_id=460015

[16:52] <theorb> It's actually a very interesting question for me.

[16:52] * autrijus mumbles something about north wind and the sun

[16:53] <theorb> I don't think we've done that much stealing from Haskell -- in purticular, I still see lots of useful Haskellisimis that p6 doesn't have.

[16:53] <Juerd> I wonder how [thinker] with only 100 posts, the top post having a reputation of around 50, can be saint.

[16:53] <Juerd> Were the boundaries lowered?

[16:54] <autrijus> theorb: such as?

[16:54] <gaal> ./pugs -e 'module A; package B; say $?PACKAGE'       -->  'main'

[16:54] <autrijus> I'd like "is pure" in functions.

[16:54] <theorb> The ability to write lots of variants on a function so easily.

[16:54] <autrijus> is it not multisub?

[16:55] <theorb> Pattern-matching makes it so easy, though.

[16:55] <autrijus> I think cabal got value-based mmd in, too

[16:55] <autrijus> and the where forms

[16:55] <gaal> that's a bug, isn't it?

[16:55] <autrijus> so the thing we don't have yet is pattern guard

[16:55] <gaal> when put in a file, the resutl is "A".

[16:55] <theorb> Where forms?  You mean the backwards lexical scope thing?

[16:55] <dakkar> gaal: try with a newline after each semicolon...

[16:56] <autrijus> theorb: no, p6 where forms

[16:56] <autrijus> multi sub moose ($x where { $x > 7 }) { ... }

[16:56] <theorb> Gotcha.

[16:56] <gaal> dakkar, no  difference.

[16:56] <theorb> Hm.

[16:57] <gaal> autrijus++ # moose reference

[16:57] <autrijus> gaal: that's a bug. write test for it :)

[16:57] <theorb> I still feel like there's a difference there, but possibly because I haven't seen the p6 version in action.

[16:57] <autrijus> theorb: there is one single feature that haskell have that I wish p6 has.

[16:57] <autrijus> that is, tagged unions.

[16:57] <autrijus> haskell's pattern matching is so powerful because all its data types are tagged unions.

[16:58] <autrijus> and so we can get warnings about incomplete multisubs, and do structural folds, etc

[16:58] <autrijus> but I'm not sure how to fit tagged unions with enums and roles and objects

[16:58] <autrijus> so I don't really see a p6l proposal soon :)

[16:58] <gaal> urrrr? package doesn't work at all.

[17:00] <Juerd> gaal: But if you have been paying attention to the PHP hype, you'd know that namespaces are old fashioned anyway

[17:00] <Juerd> A modern dynamic language that most beginning programmers choose to work with doesn't need them

[17:00] <Juerd> So neither does Perl 6

[17:00] <Juerd> ;)

[17:00] * gaal will see about mending his ways

[17:01] * integral has a silly idea for the parser

[17:01] <Forth_> I build pugs as user, make install as root, so it stops in version_h.pl waiting for 'svk info', maybe we can skip it

[17:01] <Juerd> integral: Silly ideas can grow to be huge projects

[17:01] <integral> rather than calling ruleExpression directly all over the place,  we store the ruleExpression as a field in the RuleParser monad.   Just so everything doesn't depend on ruleExpression

[17:01] * integral mentions something about performance sucking

[17:02] <theorb> Forth_: The problem is that with svk there's no one file that's always touched when the version goes up, so we can't make the rule depend on a file.

[17:02] <boch> is perl6 still under development?

[17:03] <theorb> boch: Yes, but it's often usable anyway.

[17:03] <integral> boch: it's going to be for the forseeable future :-)

[17:03] <boch> where can i get it?

[17:04] <theorb> Get svn, do svn co http://svn.openfoundry.org/pugs/, and compile.

[17:04] <theorb> There are also binary distributions.

[17:04] <autrijus> boch: http://pugscode.org/ :)

[17:05] <autrijus> Jonathan++ # new parrot/pugs binbuilds up on http://www.jwcs.net/~jonathan/perl6/ 

[17:06] <dakkar> I just checked in my JAPH

[17:06] <autrijus> dakkar++ # welcome aboard!

[17:06] <svnbot6> r3818, dakkar++ | a simple JAPH written for the t-shirt of the Second Italian Perl Workshop

[17:06] <autrijus> dakkar: you should note the t-shirt thing in the script itself :)

[17:06] <autrijus> as comments

[17:06] <dakkar> how doI run a single test?

[17:07] <autrijus> dakkar: make install, then ./pugs t/foo/bar.t

[17:07] <dakkar> oh, install is required...

[17:07] <autrijus> or make

[17:07] <autrijus> then ./pugs -Iblib6/lib t/foo/bar.t

[17:08] <Forth_> in my case, the root has no repository so 'svk info' ask user to press y/n, do we need to handle this in script?

[17:09] <dakkar> autrijus: ok, I hadn't seen the 'blib6' dir

[17:09] <autrijus> Forth_: I don't know... if you can figure out how, just fix it in script

[17:16] <dakkar> I'm going home, see you later

[17:16] <svnbot6> r3819, dakkar++ | added a comment to the JAPH stating purpose and authorship

[17:16] <svnbot6> r3820, dakkar++ | test for a bug in the way map looks (or doesn't look) at the signature of the passed sub/block

[17:21] <svnbot6> r3821, iblech++ | unTODO dakkar++'s test, as map with n-ary functions is implemented now. :)

[17:23] <autrijus> wt...? :)

[17:23] <obra> heh

[17:23] <obra> presumably a copy and paste

[17:24] <autrijus> no, it's already there :)

[17:24] <autrijus> so just a simple unTODO.

[17:25] <gaal> in terms of t/ organization.... namespaces belong in? syntax? general? builtins?

[17:26] <gaal> pugsbugs? :)

[17:30] <gaal> well, r3822.

[17:32] <gaal> oh! SomePack::func() doesn't work either!

[17:32] <svnbot6> r3822, gaal++ | add tests for failing namespace declarations

[17:32] <autrijus> gaal: right, that only works for methods at the moment

[17:33] <gaal> ....while functions are always exported?

[17:33] <autrijus> gaal: so please test away! this will all be fixed when I import the metametametametametamodel

[17:33] <autrijus> yeah

[17:33] <gaal> coro meta { "meta" } commit [~] meta

[17:34] <Aankhen``> When you have a `given (...) { ... }`, can you put statements like `if (...) { }` within it and then have any `when` statements within that statement also refer to the original `given`'s topic?

[17:35] <iblech> Aankhen``: I think so.

[17:35] <Aankhen``> OK.

[17:35] <Aankhen``> Thanks. :-)

[17:35] <autrijus> yes. given and when are very decoupled

[17:35] <autrijus> that is very good design.

[17:35] <Aankhen``> Yey.

[17:37] <gaal> autrijus, i'm getting a "cannot cast from" error. how can i add coordinates to the three places in AST.Internals that emit this error?

[17:37] <svnbot6> r3823, Aankhen++ | * CGI.pm: added &escapeHTML and &unescapeHTML.

[17:37] <autrijus> gaal: sure!

[17:37] <autrijus> gaal: and convert them to castFailM if you have tuits. but adding coord is fine

[17:38] <gaal> there was a "how" there :)))

[17:38] * gaal <<- willing to work on this, of course, but i still need some handholding when it comes to Haskell

[17:38] <autrijus> gaal: just change the strings

[17:39] <autrijus> oh wait, you mean the Pos

[17:39] <autrijus> you really need to promote castFail to castFailM

[17:39] <gaal> yes, i don't think i have it with me there.

[17:39] <autrijus> you do that by rewriting doCast/vCast into fromVal forms

[17:41] <gaal> i thought some about what you just said, autrijus.

[17:41] <gaal> the best response i could come up with was, "huh?"

[17:42] <autrijus> look at line 423

[17:42] <autrijus> there's lots of vCast there

[17:42] <gaal> yes

[17:42] <svnbot6> r3824, Aankhen++ | * CGI.pm: allow &escapeHTML and &unescapeHTML to be exported.

[17:42] <Aankhen``> BBL.

[17:42] <autrijus> you can fix it trivially by changing all the vCast into fromVal'

[17:43] <autrijus> and change the RHS of = into return

[17:43] <autrijus> eg:

[17:43] <autrijus>     vCast VUndef        = ""

[17:43] <autrijus> into

[17:43] <autrijus>     fromVal' VUndef        = return ""

[17:43] <autrijus> and finally, change the castFail to castFailM.

[17:43] <autrijus> I wish I can be more helpful, but I need to work a bit now :)

[17:43] <gaal> :)

[17:48] <iblech> Yay, reduce with n-ary functions implemented, too :)

[17:49] <autrijus> iblech++

[17:50] <Juerd> Yay

[17:51] <Juerd> Is arity detected for placeholder blocks yet?

[17:51] <autrijus> sure is.

[17:51] <Juerd> { $^a + $^b }.arity == 2

[17:51] <Juerd> Nice

[17:51] <autrijus> pugs> { $^a + $^b }.arity

[17:51] <autrijus> 2

[17:51] <Juerd> Whee

[17:51] <Juerd> I'm burning knoppix by the way

[17:51] <Juerd> So the new server can do more than just blow out hot air

[17:55] <gaal> nice.say $autrijus: `fromVal'' is not a (visible) method of class `Value'

[17:58] <autrijus> gaal: oh. sorry. do away with the '

[17:58] <autrijus> gaal: or use a "where" form

[17:58] <autrijus> and call the fromVal' from the second fromVal thing

[17:59] <autrijus> or introduce another doFromVal to the Class Value definition

[17:59] <autrijus> and call it from there, etc.

[17:59] <autrijus> not sure. try to improvise :)

[18:00] <gaal> i'll have to, because just fromVal makes a pattern overlap...

[18:20] <svnbot6> r3825, autrijus++ | * fix typo in READTHEM

[18:29] <svnbot6> r3826, iblech++ | * reduce() can now take n-ary functions.

[18:29] <svnbot6> r3826, iblech++ | * Added a test for n-ary reduce to reduce.t.

[18:29] <svnbot6> r3827, iblech++ | Oops, forgot to checkin the modified Prim/List.hs.

[18:29] <svnbot6> r3828, iblech++ | die "abc\ndef\nghi" correctly vertically aligns now.

[18:29] <svnbot6> r3829, iblech++ | util/livecd -- Increase the default initrd size, as Pugs (and/or Parrot) gained

[18:29] <svnbot6> r3829, iblech++ | size. I changed this yesterday, but didn't checkin as we were in preflight.

[18:32] <iblech> dakkar: Remember the test you wrote (n-ary map)? n-ary map is now implemented, as well as n-ary reduce :)

[18:34] <dakkar> iblech: yes, I just noticed. You implemented n-map before I commited the test ;-)

[18:34] <svnbot6> r3830, iblech++ | READTHEM -- Corrected Leopold TÃ¶tsch's name (it's Ã¶, not Å).

[18:34] <Khisanth> hmm

[18:34] <Khisanth> svnbot6: doesn't do unicode yet?

[18:38] <iblech> Khisanth: It's not svnbot which can't do Unicode, but the svn log of the system svnbot6 runs on

[18:39] <iblech> Khisanth: (svnbot just pipes the output of svn log to IRC)

[18:41] <Khisanth> I see, was just a bit confused since it seemed like you can have your source in unicode but not actually write code that does I/O that handles it :)

[18:41] <iblech> :)

[18:42] <Corion> Hmmm. Can anyone come up with tests that maybe confirm that times() actually works? I'm not sure that it does, but I don't know how to really put that into a test... (I believe my Win32 implementation is buggy due to GHC complaining)

[18:42] <autrijus> Corion: ./t/unspecced/times.t

[18:43] <Corion> autrijus: Hmmm. According to that test, it works, but it doesn't convince me really :)

[18:43] <autrijus> Corion: you can sleep 10, do a long while loop, then see what times() returns

[18:43] <Corion> Aaaah - maybe I should also test the converse. [-] times(), times() ~~ (0,0,0,0,0)

[18:43] <Corion> (except that the syntax is wrong, of course)

[18:43] <autrijus> you had me mind-bended for a moment :)

[18:44] <Corion> ... what would be the syntax to apply a minus-zip for the two lists returned from two times() calls?

[18:44] <knewt> iblech: no *.UTF-8 locale installed on the system it runs on?

[18:44] <iblech> knewt: Exactly.

[18:44] <ninereasons> man, I really like the reduce metaoperator.  When I'm working in perl5 I really feel the lack of it.  It's a good pain.

[18:45] <knewt> iblech: i only have en_GB.UTF-8 on mine nowadays :)

[18:45] <Corion> I want @a = times(); @b = times(); @c = zip(@a, @b) -> $a, $b { $a - $b }; @c ~~ (0,0,0,0,0); # except more elegant

[18:45] <Corion> ... but maybe I should not write obfu in test code :)

[18:46] <iblech> Corion: @a = times(); @b = times(); @c = map { $^a - $^b } zip @a, @b

[18:46] <iblech> knewt: de_DE.UTF-8 on my desktop systems here :)

[18:46] <Corion> iblech: That's somewhat nicer, true :) But still, I feel that this would be an ideal use of [-], except that it doesn't work that way :)

[18:47] * Corion edits times.t

[18:47] <dakkar> @c= @a »-« @b ?

[18:47] <Corion> dakkar++

[18:47] <autrijus> ninereasons: I also miss multi-param for(){} a lot :-/

[18:47] <Corion> That was what I was looking for (except that I'll use the ASCII variant

[18:47] <autrijus> but I feel I'm writing better perl5 because of perl6's influence :)

[18:48] <dakkar> regarding n-ary reduce:

[18:48] <knewt> iblech: i switched over back before christmas, since i knew that hoary was moving over to native utf8, so i thought i'd do that bit before the hoary shift

[18:48] <dakkar> 1st: the test doesn't work because of the '$^c undeclared' bug

[18:49] <dakkar> 2nd: is it supposed to work the way the test implies?

[18:49] <ninereasons> autrijus, me too.  I think that's the way it's supposed to work - perl6 eloquence forces better perl5ish imitation

[18:49] <iblech> knewt: Yeah, utf-8 definitely pays off, especially with Perl 6's «» :)

[18:49] <ninereasons> s/force/encourage/

[18:49] <iblech> dakkar: Did you svn up and recompile?

[18:49] <autrijus> s/encourage/force/ # really!

[18:50] <ninereasons> :-)

[18:50] <knewt> ok, request for crash space in vienna during the workshop made. next it's time to book the flights (which is made more annoying due to it not being me paying :( )

[18:50] <dakkar> iblech: maybe not recently enough... say, 30minutes

[18:50] <dakkar> I'll recompile

[18:50] <iblech> dakkar: Yeah, 30min are ancient in Pugs terms :) I checked the n-ary reduce code 20:29 in

[18:51] <autrijus> 30min is downright stone age.

[18:51] <knewt> iblech: yep. and i've got a script loaded into irssi that converts stuff from people using other charsets into utf8 for me

[18:52] <iblech> knewt: How does the script detect it's not utf-8? Because in many cases, (say) iso-8859-15 is valid utf-8, too...

[18:52] <dakkar> iblech: re: encoding: only for the ASCII subset, usually

[18:53] <dakkar> it takes more time for my machine to compile pugs than for you guys to commit a new version...

[18:53] <iblech> (make unoptimized)++

[18:53] <dakkar> still '$c undeclared'... am I missing something?

[18:54] <knewt> iblech: it has some (very) small autodetection (/á|é|í|ó|ú|ã|ç|à|ô|ê/). in cases it doesn't figure out automatically i can manually tell it that person A is using charset B

[18:54] <PerlJam> dakkar: did you not declare $c?

[18:54] * Corion learns that where Perl has @Larry, Haskell has @Simon :)

[18:54] <knewt> iblech: i could add other stuff to the guess list, but i can't be bothered

[18:54] <iblech> knewt: Ah, that explains it.

[18:54] <PerlJam> dakkar: er, what's some code that exercises the bug?

[18:55] <iblech> dakkar: Both reduce.t and map.t run fine here

[18:56] * iblech checks if he hasn't forgotten to checkin a file

[18:56] <iblech> No, all files checkedin.

[18:56] <ninereasons> dakkar, I've changed a test to eval_is.  svn up and see if it works, now.

[18:57] <ninereasons> for reduce.t, that is

[18:57] <dakkar> that's strange... If I do '{$^a+$^b+$^c}(1,2,3)' it works

[18:58] <iblech> dakkar: What's the code you tried which does *not* work?

[18:58] <dakkar> iblech: reduce.t :-(

[18:58] <iblech> ninereasons: It can't work now, as eval_is won't find @array

[18:58] <ninereasons> iblech, test 8 of reduce.t fails for me as dakkar describes.

[18:58] <Corion> Hmm. If I get negative values from times() I guess it's safe to assume that my implementation is broken ;)

[18:59] <ninereasons> i see. iblech. I'll try something else.

[19:00] <iblech> dakkar: Try, in interactive Pugs: reduce { $^a + $^b + $^c } 1,2,3,4,5,6

[19:00] <svnbot6> r3831, ninereasons++ | reduce.t change a failing test to eval_is

[19:00] <svnbot6> r3832, iblech++ | unEVAL n-ary reduce test so the test can find its lexical vars.

[19:01] <autrijus> poll: If I get next round of tuits to work on interop, should I work on inlining perl 5 in Pugs (libperl embedding), or inlinng Pugs in Perl 5 (libghc embedding)?

[19:01] <autrijus> assuming each takes equal time. I'm trying to measure use case here :)

[19:01] <autrijus> i.e. whether it makes more sense to use perl5 code from foo.p6, or to use perl 6 code from foo.p5

[19:02] <autrijus> libperl embedding probably wins us libponie embedding in parrot codegen when it's there

[19:02] <autrijus> libghc embedding wins us Inline::Haskell as well.

[19:02] <stevan> wow

[19:02] <stevan> thats a hard one

[19:02] <dakkar> sorry all, my bad: svn up; make doesn't build correctly, maybe some problems with timestamps on my machine

[19:02] <iblech> Inlining Perl 5 in Pugs, i think, but I'd like Inline::Haskell for Perl 5, too :)

[19:03] <stevan> I think libperl embedding it more useful

[19:03] <stevan> but libghc is more fun :)

[19:03] * iblech agrees with stevan

[19:03] <autrijus> mmm. :)

[19:03] <dakkar> iblech: now everything works as it should

[19:03] <stevan> autrijus: I think you should go for "fun" since Pugs is not really ready to be "useful" yet

[19:03] <iblech> dakkar: :)

[19:04] <dakkar> which makefile target build the 'blib6' dir?

[19:04] <autrijus> dakkar: "all"

[19:04] <autrijus> stevan: ok. Pugs is optimised for fun anyway

[19:04] <stevan> and actually Inline::Haskell could be useful more so than Inline::Pugs

[19:04] <autrijus> (will probably continue to be)

[19:04] <dakkar> and if I want an unoptimized build, and an updated bilb6?

[19:05] <autrijus> "make unoptimised; make"

[19:05] <dakkar> doh

[19:05] <autrijus> (I know, counterintuitive)

[19:07] <ninereasons> iblech, how about if I make the declaration of @array part of the eval.  That should work, shouldn't it? 

[19:08] <iblech> ninereasons: Yeah, and is eval('...') would work too. But does it still not work? Latest revision?

[19:09] <ninereasons> mm. 3815 ?

[19:10] <dakkar> ninereasons: up, make, test again. works for me

[19:10] <iblech> ninereasons: 3815 is ooold, try at least r3827

[19:10] <ninereasons> iblech, dakkar, will do.  thank you.

[19:11] <ninereasons> I don't know why it was so old anyway.  my last build must have failed.

[19:13] <ninereasons> ah.. environment fuzziness, actually.  r3830 was available, but not in my path.  All works now.

[19:13] <iblech> :)

[19:22] <dakkar> a non-type-safe reduce is scary...

[19:23] <dakkar>  my @a=([0,1],2,3,4,5);@a.reduce:{[$^a[0]+$^b,$^a[1]*$^c]}

[19:23] <dakkar> prints

[19:23] <dakkar>  (6,15)

[19:26] <iblech> Yep, and an appropriate (Haskell) type signature would be: reduce3 :: ((a,a) -> a -> a -> (a,a)) -> [a] -> (a,a)

[19:28] <dakkar> ((a,a)->a->a->(a,a))-> (a,a) -> [a] -> (a,a) ?

[19:29] <iblech> So it is type-safe -- the start value and the result are two-element lists, and the reducing function takes those two-element lists and two values, and returns another two-element list

[19:29] <iblech> dakkar: That's the way to denote a type in Haskell. It reads as:

[19:29] <dakkar> well, my @a is not really an homogeneus list...

[19:29] <dakkar> more than [a] it sholud be [Either a (a,a)]

[19:30] <dakkar> or something to that effect

[19:30] <iblech> reduce3 is a function which takes a function which needs a tuple of a's and two a's and produces a tuple of a's, a tuple of a's and a list of a's and returns a tuple of a's.

[19:30] <iblech> And because nobody can parse this sentence, there're type signatures :)

[19:31] <iblech> dakkar: That's because the first element of the input list denotes the start element

[19:31] <dakkar> yes, I know foldl ;-)

[19:31] <iblech> dakkar: Therefore I passed the start value as an own parameter

[19:32] <dakkar> iblech: and were is it, in your reduce3 signature?

[19:32] <iblech> dakkar: It's the third (a,a)

[19:33] <dakkar> isn't taht supposed to be the *return* value? (cfr. the signature I wrote)

[19:34] <Aankhen``> Is this valid: for %hash.kv -> $key is rw, $value is rw { ... }

[19:34] <iblech> No, there're four (a,a)s in the signature. The third one is the start elem, and the last one the return value

[19:34] <dakkar> my client must have dropped some chars...

[19:35] <Corion> Is there a noninteractive way to make GHC show (in trace()) the type of a variable?

[19:35] <PerlJam> Aankhen``: surely you can't modify the keys of a hash like that.

[19:35] <Aankhen``> I figured it wouldn't hurt to ask. :-)

[19:36] <iblech> PerlJam: Why not? Iff .kv returns a list of lvalue lists...

[19:36] <iblech> dakkar: Oh

[19:36] <dakkar> .kv returns aliases or copies?

[19:36] <integral> what happens if you change the key to be equal to another key in the hash?   That seems to me to be the real corner case

[19:36] <Aankhen``> In a function call, can you use `foo(*%bar)` to pass %bar in such a way that it's assigned to the slurpy named params of &foo?

[19:36] <iblech> Corion: Wanted that, too.

[19:37] <Corion> I guess we could steal it from ghci, but I'd prefer a premade solution ;)

[19:37] <iblech> integral: Hm, right...

[19:37] <PerlJam> "slurpy named params"?

[19:37] <integral> plus a hash isn't a function from a box to a box, it's a function from a value to a box

[19:38] <Aankhen``> PerlJam >> If you have `sub foo (*%extra)`, can you use `foo(*%hash)` so that %extra := %hash?

[19:39] <PerlJam> Aankhen``:  Hmm.

[19:39] <Aankhen``> IIRC, `foo(*@bar)` would let the slurpy @_ or equivalent in foo take on @bar.

[19:39] <PerlJam> slurpies are copies in pugs I think.  I don't know if that's the proper behavior though

[19:40] <Aankhen``> Well, basically, if I use `foo(*%hash)`, can I access the keys in %hash using %extra<name>?

[19:40] <PerlJam> Aankhen``: sure.

[19:40] <Aankhen``> Yeesh, I need to be more consistent with my backticks.

[19:40] <Aankhen``> OK.

[19:40] <Aankhen``> Thanks.

[19:41] <PerlJam> Just keep in mind that foo(*%hash) will flatten %hash into a list before foo() ever sees it.

[19:42] <Aankhen``> Ah.

[19:43] <Aankhen``> Hrm, that doesn't work.

[19:43] <svnbot6> r3833, bsmith++ | * moved newClass from Pugs.Parser to Pugs.AST.

[19:43] <svnbot6> r3833, bsmith++ | * moved ruleProgram and runRule to Pugs.Parser.Program.

[19:43] <svnbot6> r3833, bsmith++ | * moved unsafe* from Pugs.Parser to Pugs.Parser.Unsafe.

[19:49] <Aankhen``> Aha!

[19:49] <Aankhen``> The solution was one of those obvious things which my mind refuses to see.

[19:50] <Aankhen``> foo(hash => %hash);

[19:52] <autrijus> your mind is p5ised :)

[19:52] <Aankhen``> Heh.

[19:52] <Aankhen``> I'm working on &CGI::redirect.

[19:53] <autrijus> ooh

[19:53] <Aankhen``> Was trying to figure out how to pass extra parameters from that to &CGI::header.

[19:53] <Aankhen``> (I don't know Haskell, so I'm trying to help by working on porting modules)

[19:54] <Aankhen``> So far, I love Perl 6.  Once it becomes popular, people will probably feel it's just more advanced line noise, but personally, I think it's looking quite elegant so far. :-)

[19:54] <svnbot6> r3834, bsmith++ | Removing unused imports from Pugs.Parser.Program.

[19:55] <Aankhen``> Of course, my own opinion might change once more of it is implemented. :-P

[19:55] <ninereasons> s/-noise/-music/

[19:56] <Aankhen``> s/-/ /g

[19:56] <autrijus> s:g/-/ /

[19:56] <Aankhen``> OK, OK, my mind is P5ised. :-P

[20:02] <Corion> Can anybody tell me what getProcessTimes() returns under Unix? Is it an int, or a 64bit number? And what units?

[20:03] <svnbot6> r3835, iblech++ | Pugs.Pretty -- Use split function instead of hand-rolled foldl.

[20:03] <Corion> (or, if it returns clock_t, what is clock_t on Win32 and is it compatbile with the 64-bit stuff returned by GetProcessId() ?)

[20:04] <dakkar> Corion: getProcessTimes in what language/library?

[20:05] <Khisanth> getProcessTimes doesn't look very unixy :)

[20:05] <Corion> dakkar: glibc or whatever libc

[20:05] <Corion> whatever is used to implement Perl5 times() on Unixy systems ;)

[20:05] <dakkar> ok

[20:05] <Khisanth> ah that

[20:05] <Corion> Hmm - I should Just Check what Perl5 on Win32 does and reimplement that ;)

[20:06] <Khisanth> it returns time_t

[20:06] <gaal> which is an int, isn't it?

[20:06] <Corion> Ewww. It returns seconds. Good bye resolution :(

[20:06] <Corion> Oh well - makes my job easier :)

[20:07] <gaal> noooo! let's have hi res by default

[20:07] <Corion> If you tell me where to stuff the extra precision ...

[20:07] <Corion> Hmmm - I could return a float upwards and let other people worry about it :)

[20:08] <Corion> ... instead of returning a CClock, which is clock_t

[20:08] <gaal> setitimer

[20:08] <gaal> seems to have ms granularity

[20:09] <Corion> Does Haskell have a fixed point numeral ? Or an arbitrary precision numeral?`

[20:11] * integral wonders why runRule takes a function as its second argument

[20:11] <gaal> Corion++; # helping with this: pugs -V | find "archname"    --> archname: MSWin32-x86-multi-thread

[20:11] <Corion> Maybe Data.Ratio

[20:11] <integral> the caller can just compose runRule with that function for the same effect :-/

[20:11] <Corion> gaal: ? Where did I help with that?

[20:11] <Corion> gaal: BTW, pugs -V:archname is shorter :)

[20:11] <gaal> the compiler thingie.

[20:11] <Corion> (and doesn't require a second program)

[20:12] <gaal> indeed! nor one as atrocious as window's find

[20:12] <autrijus> integral: please refactor mercilessly

[20:12] <autrijus> Corion: VRat is infinite precision

[20:12] <Khisanth> hmm

[20:12] <integral> autrijus: oh, I am, I have a very nasty trick up my sleeve ;-)

[20:12] <autrijus> integral++ # getting nasty with pugs

[20:12] <Corion> autrijus: Yeah - I'll try to use that when (re)implementing getProcessTimes for Win32

[20:13] <Corion> ... resp. I'll return Data.Ratio and let the upper levels worry :)

[20:13] <autrijus> Ratio takes a param

[20:14] <autrijus> VRat is Ratio for VInt

[20:14] <autrijus> VInt is Integer

[20:15] <Corion> Ewww. That means that Compat.hs needs to know about Pugs.Types, right?

[20:15] <autrijus> no

[20:16] <autrijus> you just return a Rational

[20:16] <autrijus> you see, VRat is a synonym for Rational

[20:16] <autrijus> how convenient :)

[20:16] <Corion> ;)

[20:16] <autrijus> type Rational = Ratio Integer

[20:16] <autrijus> type VInt = Integer

[20:16] <autrijus> type VRat = Ratio VInt

[20:16] <autrijus> ergo, VRat =:= Rational

[20:16] * autrijus praises the power of syllogism

[20:17] <gaal> Haskell also supports enthymeme, autrijus

[20:17] <gaal> minimal complete definitions.

[20:17] <autrijus> indeed.

[20:18] <autrijus> Haskell is a very reasonable language.

[20:18] <autrijus> using Haskell is like having the power of Reason.

[20:18] <autrijus> all bad guys listen to Reason.

[20:18] <autrijus> (obscure Snow Crash reference)

[20:18] * gaal acknowledges that, and also notes this is why it sometimes looks Greek to him

[20:19] <gaal> i got the reference :)

[20:19] <ninereasons> someone will have to pick up that quote, for sure: <autrijus> using Haskell is like having the power of Reason.

[20:19] <gaal> and mine was an obscure reference to Aristotle

[20:19] <gaal> but not PM's aristotle

[20:19] <autrijus> ninereasons: just throw it to QuotesPage

[20:19] <autrijus> # http://haskell.org/hawiki/QuotesPage

[20:19] <autrijus> I'm sure shapr will appreciate that

[20:20] <autrijus> I got that too

[20:20] <autrijus> seems passing by reference is quite efficient around here

[20:24] <Corion> Hmmm. How do I declare my types? I have "data FILETIME = CULLong", but ghc complains later that it can't match Expected: CULLong against Inferred: FILETIME

[20:25] <Corion> Maybe I should just banish my intermediate type and hope for the best ...

[20:27] <iblech> Corion: (foo :: FILETIME)?

[20:27] <integral> wouldn't you want: data FILETIME = CULLong CULLong, or s/data/newtype/, or type FILETIME = CULLong ?

[20:28] <autrijus> type FILETIME = CULLong

[20:28] <Corion> autrijus: Aaah - "type", not "data" ...

[20:28] <Corion> Maybe I should do some of the exercises again ...

[20:29] <autrijus> type is a simple alias

[20:29] <autrijus> data is a tagged union

[20:29] <Corion> Aaaaah

[20:29] <autrijus> and newtype is a tagged union that only has one constructor.

[20:29] <autrijus> (oversimplifying a lot)

[20:29] <Corion> autrijus: Oversimplifying is good! :)

[20:30] <autrijus> so newtype is more like just a simple box label that will always be compiled away

[20:33] <Aankhen``> Hrm.

[20:33] <Aankhen``> Our CGI.pm has some parameters switched around.

[20:33] <Aankhen``> Is it okay if I fix it so that we're as backward-compatible as possible?

[20:33] <Corion> Haskells power is really cool - the different type for the times values just bubbles upwards without problems ;) (except in the implementation, but that's secondary :) )

[20:34] <Corion> Aankhen``: People should use named parameters anyway, but it should either do sanity checks or have them the same.

[20:34] <Aankhen``> That's a yes, then?

[20:34] <Corion> Aankhen``: But you might want to discuss that with the respective author - maybe there is a reason.

[20:34] <Aankhen``> Hrm, that's right.

[20:34] <gaal> http://forum2.org/gaal/pugs/smoke-xp.html # i'll get parrot included in a bit

[20:34] <Aankhen``> Ovid doesn't seem to be around...

[20:35] <Aankhen``> autrijus?

[20:35] <autrijus> yo Aankhen``

[20:35] <Aankhen``> Hi.

[20:35] <autrijus> Aankhen``: sure, switch around, write more detailed commit log, earn more ++s

[20:35] <autrijus> and check a bit that examples/memory_game still runs

[20:36] <autrijus> which is important (kind of)

[20:36] <Aankhen``> Heh, okay.

[20:39] <Corion> Hmmm. What should the clocksPerSecond() thing in Prim.hs be? Should that go into Compat.hs, because under Win32, it could become 10 million, while it currently is 1 million...

[20:40] <Corion> (I could also fix getProcessTimes to return the values divided by 10 already :) )

[20:41] <autrijus> nono

[20:41] <autrijus> just move it to compat where it belongs

[20:43] <Corion> autrijus: Willdo - except that Win32 maybe has different timer resolutions, but I'll see that through the breaking tests :)

[20:43] <autrijus> Corion: you can have a different clocksPerSecond for the win32 part and posix part

[20:44] <Corion> autrijus: Yes, but I think that Win32 itself is inconsistent :)

[20:44] <Corion> ... because time() works, and times() returns something different. We'll see.

[21:02] <gaal> ooh, precedence bug, i think:

[21:02] <gaal> my $handle = $r ?? $fh1 :: $fh2

[21:02] <gaal> where $r is Bool

[21:03] <gaal> pugs: cannot cast from VBool True to Handle

[21:03] <autrijus> weird. it looks okay here

[21:03] <autrijus> what if you put () around $r??:: ?

[21:03] <gaal> happens to me in both win32 and linux

[21:03] <autrijus> that part can't be platform dependent :)

[21:03] <gaal> :)

[21:04] <gaal> looks like it's helping

[21:06] <gaal> hmmm, but i think it evaluates to a reference to the handle?

[21:07] <Aankhen``> Was temp() implemented?

[21:07] <gaal> no, my bad

[21:07] <Aankhen``> Ah, okay.

[21:07] <gaal> it isn't.. but sometihng's still strange

[21:07] <Aankhen``> No worries, can always work around it. :-)

[21:08] <gaal> er that was to autrijus :)

[21:08] <Aankhen``> Oops.

[21:08] * Aankhen`` runs to his code.

[21:11] <Corion> What units does time() return nowadays?

[21:13] <revdiablo> floating point seconds

[21:14] <Corion> Hmmm. Still seems to be seconds (floating)... Weird ...

[21:14] <revdiablo> isn't that what it's supposed to be?

[21:17] <Corion> revdiablo: No, I'm hunting bugs in my code :))

[21:17] <revdiablo> ah, ok. I'll go back to my lurking corner. :)

[21:23] <gaal> finally: openpipe.

[21:23] <svnbot6> r3836, gaal++ | First step at Standard Prelude: &openpipe primitive in Perl 6

[21:23] <svnbot6> r3836, gaal++ | (which should be renamed to Pipe::open once namespace bugs are fixed)

[21:24] <gaal> now tests can use fewer temp files :)

[21:28] <Corion> Hmmm. Are while() loops broken?

[21:28] <Aankhen``> Hrm, I will have to commit in the morning.

[21:29] <Aankhen``> Don't nobody break CGI in the meantime. :-P

[21:29] <Aankhen``> G'night.

[21:30] <gaal> worksforme Corion: my $i = 10; while $i-- { say $i }

[21:30] <Corion> gaal: Yeah - I'm trimming it down - it seems related to time() ... Or something ...

[21:30] <gaal> by the way, isn't it a bug that "my $i = 10" evaluates to undef?

[21:31] <Corion> I'm stupid - I got the expression wrong ;)

[21:31] <gaal> in pugsi, at least

[21:31] <gaal> or pigs

[21:31] <gaal> or whatever we're calling it now :)

[21:31] <Khisanth> hogs

[21:38] <gaal> i just noticed README says: "Running all tests unfortunately requires a lot more memory (perhaps 1000M)"

[21:38] <gaal> did someone see this happen?

[21:51] <japhy> so.  there's been a bunch of updates to apocalypse 5...

[21:52] <japhy> there are "capturing assertions" and "non-capturing assertions"

[21:52] <japhy> this is rather esoteric.

[21:56] <wolverian> the A05 on dev.perl.org is still the dec 2004 vesrion

[21:56] <wolverian> version, rather

[21:57] <vcv--> where at japhy?

[21:59] <mugwump> try http://svn.perl.org/perl6

[22:00] <autrijus> also try S05 :)

[22:02] <mugwump> heh, true.  how goes it, autrijus ... up late or early?

[22:02] * mugwump looks at the backlog

[22:02] <mugwump> hmm there's the answer

[22:03] <wolverian> both A05 and S05 on svn.perl.org/perl6/doc/trunk/design are from dec 2004

[22:03] <japhy> what's the most recent A05?

[22:03] <wolverian> (at least they claim they are.)

[22:04] <japhy> if not the Dec 2004 one?

[22:04] <japhy> and the synopsis isn't what I'm after

[22:04] <japhy> I need to read the whole thing so I have a complete set of characters and tokens

[22:04] <wolverian> I thought you knew that; you did say there had been updates :)

[22:04] <wolverian> or did you mean that there are new rules that are not yet written down in A05?

[22:04] <japhy> well, if there's a more recent one, I need it

[22:05] <japhy> I don't know if there's new stuff.  since the Dec 2004 A05

[22:05] <japhy> if there's a more recent version, I need to know where it is

[22:06] <autrijus> ok. the deal is A* is no longer updated

[22:06] <autrijus> all updates will be inS*

[22:06] <autrijus> S*

[22:06] <autrijus> and damian's new capturing semantics is the first part of S05 updates

[22:06] <autrijus> that will eventually be committed to svn

[22:06] <autrijus> but I'm not sure how soon

[22:07] <autrijus> so you'd need to prod p6l a bit to gauge the current status

[22:07] <autrijus> I don't have more info than you -- I'm not in the cabal either :)

[22:07] <japhy> ok.

[22:07] <japhy> I have to say, the weirdest thing is the **{n..m}

[22:07] <japhy> WTF, mate?

[22:08] <Corion> Only people hating Perl5, like Shlomi Fish, get to be in the cabal!

[22:09] <vcv--> The only people who hate Perl5 are those who do not understand it.

[22:09] <autrijus> er, no.

[22:09] <Corion> vcv--: How true :)

[22:09] <autrijus> I know of people who knows perl5 and hate it :)

[22:10] <integral> it's more perl5 that's hateful than Perl5

[22:10] <autrijus> right!

[22:10] <autrijus> perl5 sucks a lot.

[22:10] <autrijus> Perl5 is generally okay.

[22:10] <kelan> they know it

[22:10] <kelan> but they do not understand

[22:10] <kelan> hows that for zen!

[22:10] <autrijus> hm, is Juerd's server online?

[22:10] <autrijus> I think I'll redirect perlcabal.org there.

[22:10] <autrijus> (!)

[22:11] * integral thought he was still at the Knoppix stage

[22:11] <vcv--> Well Perl5 only sucks now because of Perl6 ;)

[22:11] <ijoyce> p5's object system sucks balls

[22:11] <vcv--> true

[22:11] <ijoyce> hard

[22:12] <integral> nah, it's not the object system, it's not having a proper record type

[22:12] <autrijus> p5 has an object system?

[22:12] <autrijus> I missed it

[22:12] <integral> there's little wrong with having a bless primitive...

[22:12] <ijoyce> exactly

[22:12] <mugwump> huh?  What's a *SV if not an object?  :)

[22:13] <integral> a monstrosity that makes perl5 hateful? ;-)

[22:13] <autrijus> mugwump: it's a V :)

[22:13] <ijoyce> quit being smart asses, you guys know wha I mean

[22:13] <wolverian> I like perl5's OO. I just don't like its lack of syntax.

[22:13] <wolverian> (enter Spiffy)

[22:14] <autrijus> heh. ingy still has that Perl5i thing in his OSCON talk abstract

[22:14] <vcv--> I think it's time for some PHP bashing too...

[22:14] <autrijus> I wonder what he will speak about it :)

[22:14] <wolverian> Perl5i?

[22:14] <autrijus> wolverian: before pugs started, ingy threatened to do Perl 6 syntax on top of p5 vm

[22:14] <autrijus> because it seems p6 will never be there

[22:14] <wolverian> ah, okay.

[22:15] <wolverian> well, perl5 is fast, at least.

[22:15] <autrijus> maybe I get to steal that name for the mixed perl5/perl6/parrot interpreter project

[22:16] <Corion> & # getProcessTimes should now Just Work Everywhere

[22:16] <Corion> # Everywhere is in the Java.Everywhere monad :)

[22:16] <autrijus> lol

[22:17] <autrijus> Corion++

[22:17] <Juerd> autrijus: No, I want it online tomorrow

[22:17] <svnbot6> r3837, corion++ | getProcessTimes now really works on Win32. Added some tests, moved a constant out of Prim.hs into Compat.hs

[22:17] <Juerd> autrijus: (Original planning was Friday, and that's still the fallback if tomorrow for some reason isn't working)

[22:17] <Juerd> afk

[22:18] <autrijus> Juerd: ok. I'd like to assign perlcabal.org to that IP

[22:18] <autrijus> I think it makes a lot of sense :)

[22:20] <ingy> autrijus: I think  ORA has my bio from 3 years ago

[22:20] <ingy> so I'm not surprised about perl5i

[22:20] <autrijus> ingy: I thought you had a chance to submit a new bio

[22:20] <ingy> I may still talk about perl5i anyway

[22:20] <autrijus> really! what will you talk about?

[22:21] <ingy> I'm not sure what i angle I can present a talk on pugs about

[22:21] <autrijus> oh btw, I need to consult you with some strategy based on your mad Open Source Manager-fu

[22:21] <ingy> I mean, every last detail will be rehashed by someone else

[22:22] <japhy> ah ha.  <foo> captures to $foo, <?foo> just matches

[22:22] <ingy> so I will likely give a history and insiders view of how pugs gets developed

[22:22] <japhy> FINALLY things are explained to me.

[22:22] <ingy> autrijus: you are the heir to the OSM throne

[22:23] <ingy> the queen is dead

[22:23] <mugwump> long live the queen!

[22:23] <autrijus> ingy: ok. so it goes like this

[22:24] <autrijus> I'm convinced that having $perl5_dbh in perl 6 programs is the #1 priority

[22:25] <autrijus> I think I can do it by embedding pugs in-memory to a perl5 interpreter

[22:25] <autrijus> and marshal object calls like I did with Language::MzScheme

[22:25] <autrijus> so perl 5 is the main language, but you can transparently define perl 6 subroutines and load perl6 methods

[22:25] <vcv--> autrijus did i read wrong, or are you going to YAPC::NA this year?

[22:25] <autrijus> s/method/module/

[22:25] <autrijus> vcv--: I am

[22:26] <vcv--> and larry too ?

[22:26] <clkao> huh? why not just perlembed? and have xs glue for calling back to code in pugs when needed

[22:26] *** ingy is now known as php--

[22:27] <vcv--> php makes little kittens cry 

[22:27] *** php-- is now known as ingy

[22:27] <obra> "encrypted php"

[22:27] * obra twitches

[22:28] <ingy> what is $perl5_dbh

[22:28] <autrijus> ingy: it's an object defined by running the "connect" method on the "DBI" package.

[22:28] <autrijus> both defined in perl5

[22:28] <autrijus> clkao: that is another route. and that's what I need consulting for

[22:29] <autrijus> clkao: perlembed means marshalling Perl 5 API in Haskell

[22:29] <obra> Wouldn't it be faster to just write a B backend to generate pure perl6 for native perl5 code and XS code?

[22:29] *** obra is now known as troll___

[22:29] <vcv--> why couldnt YAPC::NA be down the street from me THIS year instead of last year? 

[22:29] <troll___> oops. sorry

[22:29] <autrijus> troll___: very trollish

[22:29] <troll___> should have /nicked first

[22:29] *** troll___ is now known as obra

[22:29] <autrijus> vcv--: hm?

[22:30] <autrijus> clkao: but it also means that, once parrot backend is there, we'd need to always involve ghc as the binder

[22:30] <autrijus> clkao: i.e. running the pugs program with linked in libparrot and linked in libperl and marshal calls inbetween

[22:31] <autrijus> clkao: but if we do it the Inline::Perl6 way, we can precompile Perl 6 to PIR, and just involved libparrot and perl5

[22:31] <autrijus> so GHC can be out from the equation

[22:31] <mugwump> What about something IPC based?

[22:31] <autrijus> so it boils down to whether it makes more sense to use Perl 5 + PIR modules from Perl 6 code, or to use Perl 6 + Haskell modules from Perl 5 code.

[22:32] <autrijus> and I don't really know the answer.

[22:32] <vcv--> autrijus: last year YAPC::NA was at the University at Buffalo in New York, which is literally a minute away..down the streeet from me.  then this year they get all the people id be interested in hear talking

[22:32] <ingy> autrijus: my OSM-fu tells me if you want my opinion ask me in private when I have some  time ;)

[22:32] <clkao> autrijus: hang on

[22:32] <autrijus> mugwump: opqaue objects don't generally survive IPC

[22:32] <autrijus> ingy: ok :)

[22:32] <ingy> autrijus: I'll ping you in 36 hours

[22:32] <autrijus> k

[22:32] <clkao> marshalling perl5 api in haskell... no, you do it in c, and make haskell wrap that piece of code

[22:33] <clkao> should be trivial.. and i bet you can make use of the perl_call stuff in libsvn_swig_perl i wrote

[22:33] <ingy> autrijus: er, more like 18 hours, sorry

[22:34] <ingy> autrijus: fyi, I still see value in the perl5i marshalling api I was shooting for 

[22:34] <clkao> hate marginal network

[22:34] <obra> ==clkao

[22:34] <obra> clkao: make sky give you a 3G card

[22:35] <ingy> anyway, need to run...

[22:35] <clkao> summon sky

[22:35] <ingy> &

[22:36] <autrijus> clkao: I do what in C?

[22:36] <autrijus> clkao: I still need to link in libperl no?

[22:36] <clkao> yes

[22:36] <autrijus> oh but you mean a saner API level

[22:36] <autrijus> better than perlapi

[22:36] <autrijus> just for object marshalling

[22:37] <clkao> autrijus: see libsvn_swig_pl

[22:37] <autrijus> but why would I do that in C?

[22:37] <autrijus> I don't even know C.

[22:37] <clkao> hang on

[22:37] <clkao> http://svn.collab.net/repos/svn/trunk/subversion/bindings/swig/perl/libsvn_swig_perl/swigutil_pl.c

[22:38] <clkao> see svn_swig_pl_callback_thunk

[22:38] <clkao> make a little libray that export similar entry to perl for you to use in haskel

[22:39] <autrijus> oh wow!

[22:39] <autrijus> callconv in p5!

[22:39] <autrijus> how did I miss that?

[22:39] <clkao> because you didn't love me anymore

[22:39] <autrijus> heh

[22:40] <clkao> sadly im a perlembed expert. it's more sad that i'm sad about it.

[22:40] <autrijus> hm. and that looks like totally swig independent

[22:40] * autrijus feels a bit more convinced to try perlembed

[22:41] <autrijus> but do you think it makes sense, strategically speaking

[22:41] <autrijus> to encourage people write Perl 6 and reuse perl 5 libraries

[22:41] <clkao> yes. only one part is missing if you take this route

[22:41] <autrijus> instead of encouraging people mixing in some perl 6 in their perl 5 programs?

[22:41] <clkao> we can do both. but the former is more usefuly to me

[22:42] <clkao> while there are lots of bricks in perl5, we can start use perl6 to assemble them.

[22:43] <autrijus> so p6 as glue is better than p5 as glue?

[22:43] <clkao> as assembling is mainly what people do with perl. so they now have a cleaner way, without all those nice bricks

[22:43] <clkao> er

[22:43] <clkao> withouth throwing away

[22:43] <autrijus> strangely that makes some kind of sense

[22:43] <autrijus> ok. so what part is missing?

[22:43] <autrijus> (and I don't think we have tuits to do both)

[22:43] <autrijus> (as the marshalling involved is quite different)

[22:44] <clkao> what's missing should be in one side of ffi

[22:44] <autrijus> ffi doesn't handle vararg currently, btw.

[22:44] <clkao> can you do lower level call to c without ffi

[22:44] <clkao> we take the arg typemap from ffi. 

[22:44] <autrijus> sure can.

[22:44] <autrijus> I mean, GHC compiles to C.

[22:44] <clkao> and invoke the vararg directl.y

[22:45] <clkao> *nod*

[22:45] <autrijus> so you can inline arbitary .c

[22:45] <clkao> so thats why i think it's doable.

[22:45] <clkao> just the data needs to be properly typemaped

[22:47] <autrijus> hm.

[22:47] <autrijus> ok. so we do what I did in par/myldr/main.c

[22:47] <autrijus> that is a custom xsinit code

[22:48] <autrijus> that installs additional callconv functions

[22:48] <autrijus> which includes HsTypes.h

[22:48] <autrijus> and do unpacking on the C side

[22:48] <autrijus> neither p5 nor haskell knows about this

[22:48] <autrijus> from their POV it's just a couple callconv functions

[22:48] <autrijus> that solves p5 objects in p6 space

[22:48] <clkao> install callconv to what?

[22:48] <autrijus> what about the other way?

[22:49] <autrijus> install callconv to call into perl5 

[22:49] <autrijus> but if there's a p6 obj in p5 space

[22:49] <autrijus> we can certainly tie it up and overload it for all operators

[22:50] <clkao> i think just support simple types, coderef, wrapped blessed thing that invokes properly

[22:50] <autrijus> but how to invoke back is the questoin

[22:50] <autrijus> we need call_perl6 visible from p5 space

[22:51] <autrijus> that's what the xsinit code need to do... install extra Interals:: functions

[22:51] <autrijus> Internals::, even

[22:51] <autrijus> I'm worried about this

[22:51] <clkao> give me an example

[22:51] <autrijus> sure 

[22:51] <autrijus> use_perl5 DBI;

[22:52] <autrijus> my $p5_obj = DBI.connect("...");

[22:52] <autrijus> my $p5_hash = $p5_obj.selectall_hashref(...);

[22:53] <autrijus> actually, make that

[22:53] <clkao> damn, you are getting old, type faster!

[22:53] <autrijus> my $p5_array = $p5_obj.selectall_arrayref("Select * from foo", { :AutoCommit }));

[22:53] <autrijus> ok, that's all

[22:54] <ijoyce_laptop> use_p5 DBI;

[22:54] <autrijus> no, I'm maintaining several threads of talk ;)

[22:54] <clkao> these seem simple

[22:54] <clkao> make something like a callback in perl6

[22:55] <clkao> autrijus: damnit, take the next flight and we can do this in 4 hours

[22:55] <autrijus> clkao: heh.

[22:55] <autrijus> why don't _you_ take the flight to APW ;)

[22:56] <clkao> BECAUSE I NEED A FUCKING VISA

[22:56] <clkao> and if you make any appointment now for that you are very lucky to be interviewd in JULY!

[22:56] <mugwump> you need a VISA for fucking?  does that depend on the nationality of the bird?

[22:56] <autrijus> aw wtf. you don't have those euro visa thing?

[22:57] <clkao> mugwump: thank you!

[22:57] <clkao> autrijus: anyway. let me talk and see if it makes sense

[22:58] <autrijus> ok.

[22:59] <autrijus> so line by line.

[22:59] <clkao> autrijus: on use_p5 DBI, perl6 has an "evil5" object DBI. any call to that goes to underlying evil c callconv, with CALL_METHOD and arguments mapped to simple types or evil6 objects

[22:59] <autrijus> but DBI is just a namespace!

[22:59] <clkao> make it magic! you can invoke something on it

[22:59] <autrijus> so what we need to do is to actually load DBI in the libperl5

[22:59] <clkao> sure.

[23:00] <autrijus> and install a magical ::DBI that is actually a Perl5::Package obj

[23:00] <autrijus> that pugs can do right now

[23:00] <clkao> yes.

[23:00] <clkao> let me know if i should go on.

[23:00] <autrijus> and that is very thin anyway

[23:00] <autrijus> because a p5pkg is just a VStr.

[23:00] <autrijus> go ahead

[23:00] <clkao> so no problem with $p5_obj = DBI.connect("") line for its invoke and return value?

[23:01] <clkao> the return value is also a evil5 object

[23:01] <clkao> (as it's not a simple type)

[23:01] <autrijus> wait

[23:01] <autrijus> ther "..."

[23:01] <autrijus> the "..." is a p6 VStr

[23:01] <autrijus> we need to make it a SV right?

[23:01] <clkao> yes. in callconv it's converted.

[23:01] <autrijus> a simple SV str

[23:01] <autrijus> because DBI->connect prolly can't handle overloaded p6obj

[23:01] <autrijus> it's in XS and all

[23:02] <autrijus> so strings needs to remain strings

[23:02] <clkao> unless you want to play with mg

[23:02] <clkao> but people who do those thing should be able to rewrite dbi in p6

[23:03] <clkao> is that line cleared?

[23:03] <autrijus> you need [OFF]

[23:03] <clkao> why?

[23:03] <autrijus> to clear that line :)

[23:03] <autrijus> nvm.

[23:03] <clkao> gr

[23:03] <autrijus> go ahead

[23:03] <autrijus> now the {:AutoCommit} thing

[23:04] <autrijus> that was what I was referring to

[23:04] <autrijus> because it's potentially not a simple hash that can be HV'ed

[23:04] <autrijus> I mean of course we can do a .yaml call or the moral equiv

[23:04] <clkao> so, the p5_obj.selectall_hashref is the same, invokes the CALL_METHOD on the evil5 obj

[23:04] <autrijus> and unmarshal it in p5 space

[23:04] <autrijus> the arg

[23:04] <clkao> but the return value is quite simple type.

[23:04] <autrijus> no, I mean the arg :)

[23:04] <autrijus> the hashref that I pass in

[23:04] <autrijus> that is very nonsimple

[23:04] <autrijus> because a hash is a mutable structure

[23:04] <autrijus> suppose I do

[23:05] <autrijus> my %hash = :AutoCommit

[23:05] <autrijus> $p5_obj_.selectall_arrayref("xxx", %hash)

[23:05] <autrijus> $p5_obj.selectall_arrayref("xxx", %hash)

[23:05] <autrijus> and further suppose that selectall_arrayref does this

[23:05] <autrijus> my ($dbh, $string, $attr_ref) = @_;

[23:05] <autrijus> $attr_ref->{AutoCommit} = 3; # destructive update!

[23:05] <autrijus> that needs to work

[23:06] <autrijus> otherwise we can't use compound structures

[23:06] <autrijus> and that will need to invoke p6 primitives

[23:06] <mugwump> sounds like you're making an argument that both ways need to work..

[23:06] <clkao> you can make that work later.

[23:06] <clkao> for now

[23:06] <autrijus> for now, p6 objs are fully serialised and not at all magical in p5land?

[23:07] <autrijus> i.e. they are reduced to pure yaml streams?

[23:07] <clkao> see svn_swig_pl_to_hash

[23:07] <autrijus> I saw it

[23:07] <clkao> and convert_hash

[23:07] <clkao> to make it work you just use mg to invoke p6 prim

[23:08] <clkao> use mg to invoke haskell callback for ffi to invoke p6 prim

[23:08] <autrijus> but that part is very fuzzy

[23:08] <clkao> like all other invocation of p6 obj that would happen in p5 land.

[23:08] <autrijus> right, I'm not sure about that either

[23:08] <clkao> no, the only unsure thing is the ffi part.

[23:08] <autrijus> we don't yet have an arena

[23:08] <autrijus> in pugs

[23:08] <autrijus> so you can't just load obj by id

[23:09] <autrijus> I suppose we can add it, but it complicates things

[23:09] <clkao> what obj by id?

[23:09] <mugwump> what about making a perl 6 class which encapsulates Perl5 primitives, like Hash/Array/SV/Stash.. and provides methods to call macros etc on them

[23:09] <autrijus> see, we have this $p6_obj

[23:09] <autrijus> we pass it to p5_func

[23:09] <clkao> you hold a reference to the underlying obj.

[23:09] <autrijus> now in p5 land

[23:09] <clkao> mugwump: we are talking about the other direction

[23:09] <autrijus> we invoke $p6_proxy_obj->foo

[23:09] <autrijus> now we resolve that

[23:09] <autrijus> in swig's case it's trivial

[23:10] <autrijus> because there's always a underlying Ptr

[23:10] <autrijus> right?

[23:10] <clkao> you don't have such thing in haskell?

[23:10] <autrijus> we do

[23:10] <autrijus> but that means creating a stablename for each obj

[23:10] <clkao> no!

[23:11] <autrijus> heh. without that GHC will GC it away!

[23:11] <clkao> if you implement something in ffi, how do you refer the coderef you passin?

[23:11] <autrijus> you create a StablePtr

[23:11] <autrijus> and mark it as foreign export

[23:11] <autrijus> the point is we are dealing with two GCs

[23:11] <autrijus> GHC's is generational

[23:11] <autrijus> Perl5 is refcounting

[23:11] <clkao> so what do you see in Cl and?

[23:11] <clkao> land

[23:11] <autrijus> in C land it's just a *HsPtr

[23:12] <autrijus> generic

[23:12] <autrijus> the point is that we need to mark it as out of reach by normal GHC GC

[23:12] <clkao> ok. how od you invoke that hsptr from ffi ?

[23:12] <autrijus> you cast it as a funptr.

[23:12] <autrijus> its signature needs to match the foreign export signature.

[23:12] <autrijus> and it will magically work.

[23:13] <autrijus> I don't know how :)

[23:13] <clkao> work as in... gets back to pugs just properly?

[23:14] <autrijus> let's talk in code ;)

[23:14] <autrijus> foreign import ccall "wrapper" mkCompileCallback :: ParrotCompilerFunc -> IO (FunPtr ParrotCompilerFunc)

[23:14] <autrijus> type ParrotCompilerFunc         = ParrotInterp -> CString -> IO ParrotPMC

[23:14] <autrijus> compileToParrot :: ParrotInterp -> CString -> IO ParrotPMC

[23:14] <autrijus>    ... haskell function ...

[23:14] <autrijus> that's the haskell side.

[23:14] <clkao> but i write no haskell. but i have a feeling that the other magic besides eval will help in this

[23:15] <autrijus> never mind then. assume we have a generic $p6obj in p5land

[23:15] <autrijus> we do

[23:15] <autrijus> $p6obj->meth($arg1, $arg2, $arg3)

[23:16] <autrijus> we need to have something FFI exported like

[23:16] <autrijus> invoke_perl6_method(ObjPtr $obj, Str $methodname, ArgPtr @args)

[23:16] <autrijus> where each ArgPtr is a union type that may contain pure values

[23:16] <autrijus> or other ObjPtr

[23:17] <autrijus> makes sense?

[23:17] <clkao> *nod*

[23:17] <autrijus> the point is that the callconv can't be variadic... it needs to always go thru an array

[23:17] <clkao> that's the magic i was talking about

[23:17] <clkao> "apply"

[23:17] <clkao> interestingly i'm wearing the purple tshirt

[23:18] <autrijus> heh

[23:18] <mugwump> I have to wonder if making it look like Perl 5 objects exist in Perl 6 is trying to be overly clever at this point... I do think that the language is powerful enough to do this all in Perl 6 with a decent Perl5::Interpreter.pm that supplies opaque Perl 5 objects and lets you make perlapi calls on them via methods..

[23:18] <mugwump> eg, my $perl5 = Perl::Interpreter->new();

[23:18] <autrijus> mugwump: perlapi calls! you know how many there is?

[23:18] <clkao> bwahaha

[23:19] <mugwump> sure, but each is fairly simple, surely

[23:19] <mugwump> You'd have to explicitly create Perl 5 objects to receive return values from calls

[23:19] <autrijus> sure. but say we have them

[23:19] <autrijus> now what?

[23:19] <autrijus> we have gv_fetchmeth_autoload

[23:19] <mugwump> my $perl5_sv = $perl5.newSV;

[23:20] <autrijus> er, you can't do that

[23:20] <autrijus> you have to do 

[23:20] <autrijus> $perl5.dSP;

[23:20] <autrijus> $perl5.ENTER;

[23:20] <autrijus> $perl5.SAVETMPS;

[23:20] <autrijus> $perl5.PUSHMARK($perl5.SP);

[23:20] <autrijus> before your newSV can be called

[23:20] <autrijus> that way lies insanity

[23:21] <autrijus> clkao: ok. so the C level is:

[23:21] <autrijus> * Converting P6 native types to P5 SVs

[23:22] <autrijus> * Convert P5 SVs to P6 native types (but only for SVs without SVMG and not SVRV)

[23:22] <autrijus> * For all P6 VObject types, take the stable pointer from FFI and manufacture a shallow SV that is of the correct class

[23:22] <autrijus> hm. do we append perl6:: and perl5:: ?

[23:23] <autrijus> i.e. is $perl5_dbh's class on the perl6 side still DBI?

[23:23] <autrijus> there could be namespace clashes

[23:23] <autrijus> but if that happens we're doomed at the class space anyway

[23:23] <clkao> *nod*

[23:23] <autrijus> so probably no prefix.

[23:23] <autrijus> i.e. use DBI; use_p5 DBI;

[23:23] <autrijus> # already doomed

[23:23] <clkao> anyway.. this can be worried after something works

[23:23] <autrijus> right. 

[23:23] <autrijus> * For all SVRVs, invoke a special wrap_object FFI export

[23:24] <autrijus>   passing in the SVPtr and get back a VObject ptr

[23:24] <autrijus>   and use it in pugsspace

[23:24] <autrijus> then we only need to handle method calls and coderefs.

[23:24] <autrijus> what about overload? don't worry about it for now?

[23:24] <autrijus> SvMG that is

[23:24] <clkao> don't worry about it

[23:24] <autrijus> $perl6_object + 1;

[23:24] <autrijus> ok. people relying on that deserves to be shot, right?

[23:24] <clkao> overload in p5 is buggy anyway

[23:24] <autrijus> so no IO::All in p6 ;)

[23:25] <clkao> hate

[23:25] <autrijus> sad, because I did make Math::Complex work in MzScheme

[23:25] <autrijus> but MzScheme is much easier to target ;)

[23:25] <clkao> ha. so, how do i create p6 prim with ffi callbacks?

[23:25] <autrijus> that's actually simple and done before

[23:25] <autrijus> we do that in Pugs.Embed.Parrot

[23:26] <clkao> ok.. i will have a look tomorrow

[23:26] <autrijus> you just come up with anything and FFI can simulate it :)

[23:26] <clkao> *nod*

[23:26] <autrijus> you want to look at compreg

[23:26] <autrijus> it's closest to what we're doing

[23:26] <autrijus> Parrot_compreg in the parrot api

[23:26] <clkao> parrot.hs ?

[23:26] <autrijus> er, parrot source itself

[23:27] <autrijus> but sure, src/Pugs/Embed/Parrot.hsc too

[23:27] <clkao> where in parrot source?

[23:27] <autrijus> I'll make xsinit work today

[23:27] <autrijus> clkao: interpreter.h

[23:27] <autrijus> not sure where the .c form is. grep a bit

[23:27] <autrijus> <- doesn't even pretend to understand parrot's .c side

[23:28] <clkao> i mean where does it call back to create pugs prim

[23:29] <autrijus> oh.

[23:29] <autrijus> no, it's not there at all. we need a compreg from pugs side too.

[23:29] <autrijus> so you can hook arbitary code into pugs namespace.

[23:31] <autrijus> anyway, I'll work on xsinit and revcallback now

[23:31] <autrijus> just to make both side's eval"" work

[23:31] <autrijus> since string is easist to marshall

[23:31] <autrijus> I'm sure you can pick up there :)

[23:32] <clkao> ya :_

[23:32] <autrijus> clkao++ # mmm expert

[23:32] <clkao> so sad

[23:32] <autrijus> and btw, you're wrong -- it's not that I don't love you anymore, it's that I don't love C anymore ;)

[23:33] <autrijus> my relationship with C has evolved from love-hate to hate-hate.

[23:33] <clkao> no.. i thought you never love c

[23:33] <autrijus> well, I've loved some part of it by neccessity

[23:33] <autrijus> but that neccessity has just went away

[23:33] <autrijus> ;)

[23:33] <clkao> away with segfault

[23:34] <autrijus> no, away with GHC, which is like GCC but without segfaults

[23:34] <clkao> anyway, i'll see what you've done after shower

[23:34] <clkao> and decdide if i will stay up a bit

[23:35] <autrijus> clkao++ # thanks. lots of fun

[23:35] <autrijus> clkao++ # this is much more fun (to me anyway) than hacking SVN::Mirror ;)

[23:35] <autrijus> or (gasp) VCP

[23:38] <japhy> I'm coming up with an exhaustive list of Perl 6 rule syntax elements.  once I *think* I'm done, I'll post it online and alert p6l of it.

[23:38] <japhy> once we have it down, I'll really be able to make my perl6 rule parser work

[23:39] <autrijus> japhy++ # sanity! sanity!

[23:39] <japhy> in between those two statements, I meant to say "if anyone knows of anything I missed, I'll add to the list"

[23:39] <japhy> I know damian's got his capturing schema coming out, but that's implementation, not syntax, right?

[23:40] <autrijus> yup

[23:41] <japhy> um, syn05 (version 7) doesn't mention the \c[...] syntax

[23:41] <japhy> but the corresponding apo does.

[23:42] <japhy> so I'm going to assume the syn just overlooked that.

[23:42] <japhy> I really should have gotten more involved 2 years ago

[23:42] <japhy> I'm a regex junkie.  I would have left no stone unturned.

[23:45] <autrijus> but really, without the syns, you and I can't easily involve.

[23:46] <autrijus> and the syns are not ready until dec 2004 ;)

[23:46] <clkao> autrijus: ok, have you got something? :)

[23:46] <autrijus> (which is not too long ago)

[23:46] <autrijus> clkao: yes. you know what dXSUB_SYS does?

[23:46] <clkao> no

[23:47] <autrijus> gah. it's a noop for all cases

[23:47] <autrijus> wtf.

[23:47] <autrijus> that's why I can't grep anything

[23:47] <autrijus> because it's defined as null for all cases

[23:47] <autrijus> so it's persumably there for some 5.005 compat

[23:47] <autrijus> did I mention I hate C?

[23:48] <clkao> ok.. show me the example for making a new number . like new_svIV

[23:49] <autrijus> just a sec

[23:49] <autrijus> oh, you can build pugs with EMBED_PERL5 meanwhile

[23:49] <autrijus> er

[23:49] <autrijus> env PUGS_EMBED=perl5

[23:49] <clkao> i know

[23:49] <clkao> and it's wrong. you should be able to specify which perl

[23:49] <autrijus> eh.

[23:50] <autrijus> it's the perl that you run makefile.pl with

[23:50] <autrijus> isn't that good enough?

[23:50] <autrijus> it saves lots of trouble

[23:50] <clkao> ah right :)

[23:50] <clkao> there's no test for p5 embed

[23:50] <autrijus> right, write to write some?

[23:50] <ninereasons> r3837 : src/Pugs/Compat.hs:208:21: Not in scope: type constructor or class `CInt'

[23:51] <autrijus> ninereasons: os?

[23:51] <ninereasons> FreeBSD 4.11

[23:51] <clkao> there's nony leval_p5 ?

[23:52] <ninereasons> autrijus, also debian

[23:53] <clkao> eek

[23:53] <autrijus> clkao: right, and it's currently 

[23:53] <autrijus> String -> IO ()

[23:53] <autrijus> we need it to be

[23:53] <autrijus> Stirng -> IO Perl5SV

[23:53] <clkao> so how do construct new p6 num from c land?

[23:53] <autrijus> or something like that, right?

[23:53] <autrijus> clkao: you do this

[23:54] <clkao> TRUNK IS BROKEN

[23:54] <autrijus> clkao: wtf?

[23:54] <clkao> what ninereasons said

[23:54] <clkao> r3837 brweaks it

[23:54] <clkao> i up'ed to previous

[23:54] <autrijus> no, don't do that

[23:54] <autrijus> r3838 fixed it... 3837 is ancient

[23:54] <clkao> ok, what do i do?

[23:55] <autrijus> your copy is 10 seconds ago

[23:55] <autrijus> it's like eternity

[23:55] <ninereasons> :_)

[23:55] <clkao> 07:50 < autrijus> clkao: you do this

[23:55] <clkao> i mean this

[23:55] <autrijus> oh ok.

[23:55] <clkao> no, 3838 fails too

[23:56] <mugwump> src/Pugs/Compat.hs:209:38: Not in scope: type constructor or class `CString'

[23:56] <svnbot6> r3838, autrijus++ | * unbreak trunk.

[23:56] <autrijus> did I say r3838?

[23:56] <autrijus> I mean r3839

[23:56] <autrijus> but anyway. you do this

[23:56] * clkao kills autrijus 

[23:56] <ninereasons> whee :)

[23:56] <autrijus> HsPtr* val = pugs_eval("1");

[23:57] <clkao> no eval please

[23:57] <autrijus> pugs_eval has the haskell side type of

[23:57] <autrijus> String -> Eval Val

[23:57] <autrijus> why not?

[23:57] <autrijus> I like eval

[23:57] <clkao> i like apply

[23:57] <clkao> src/Pugs/Embed/Perl5.o(.text+0x44): In function `r5Mz_info':

[23:57] <clkao> : undefined reference to `eval_pv'

[23:57] <autrijus> your perl has no eval_pv?

[23:57] <autrijus> or your perl is not shared libperl?

[23:58] <clkao> sure it is

[23:58] <clkao> how do i tell itto be verbose so i can see how stupid it is when linking?

[23:58] <autrijus> just "make"

[23:58] <clkao> Linking ...

[23:58] <clkao> i want to see exactly what was happening

[23:59] <autrijus> the first line of make does that no?

[23:59] <clkao> rather than hateful ...

[23:59] <japhy> w00t.

[23:59] <japhy> job interview on tuesday :)

[23:59] <autrijus> oh. ghc -v4

[23:59] <autrijus> hack makefile to replace ghc with ghc -v4

[23:59] <autrijus> (warning: never tried)

[23:59] <autrijus> and 4 may be overkill

