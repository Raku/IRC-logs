[00:00] <integral> I think I was thinking that within the functional sublanguage you wouldn't need that stuff, if you were using it for the haskellish stuff, since you don't need them in haskell

[00:01] <luqui> yeah, but then you get two disconnected languages in the same file, and having them both Perl doesn't help

[00:01] <luqui> might as well use Inline::Haskell

[00:01] <integral> What do you think would be the main disconnect between them?

[00:01] <luqui> the fact that you couldn't use perl modules within the functional sublanguage?

[00:01] <luqui> er, you couldn't use OO modules, rather

[00:02] <integral> you could use modules and classes via an interface/typeclass type thing

[00:02] <luqui> only certain ones

[00:02] <luqui> I think you'd end up writing a bunch of glue code to glue the different paradigms together 

[00:03] <luqui> which is becoming counterproductive

[00:04] <integral> oh well, you do seem much more right on the glue code issue than me :)

[00:04] <luqui> oh..kay....

[00:05] <luqui> anyway, I'm thinking type inference might be a little bit dreamy

[00:05] <luqui> that's what I'm trying to achieve with type_meta.  Keep the door open to type inference without having to figure out how to do it for a language like perl

[00:05] <luqui> it's a really hard problem that we might be arrogant to think we can solve

[00:06] <luqui> (hubristic maybe, but just in case we're not)

[00:07] * integral considers some sleep

[00:20] <avar> xinming: I killed it at 500mins

[00:56] <luqui> yum.  Pugs.Run takes 300M of ram to compile

[01:14] <svnbot6> r8266 | luqui++ | &die may take an object, but it's still allowed not to.

[01:28] <svnbot6> r8267 | luqui++ | Changed "no such method" error to report in which class it is looking for the method.

[01:33] *** Odin-FOO is now known as Odin-LAP

[01:46] <stevan> hullo luqui 

[01:51] <luqui> hallo stuvan

[01:52] <luqui> evan stevan

[01:52] <stevan> howdy

[01:53] <luqui> g'day

[01:53] <stevan> so are you back now? no more pesky school stuff?

[01:53] <luqui> not until mid january

[01:53] <stevan> bah

[01:53] <stevan> you should quit,.. its no good

[01:53] <stevan> school that is

[01:53] <luqui> I agree

[01:53] <stevan> :P

[01:53] <luqui> well, I've only like... oh, six more years left

[01:54] <stevan> then you need to get a job :P

[01:54] <luqui> pf, jobs are for the proletariat

[01:54] <stevan> LOL

[01:54] <stevan> did you ever get a chance to read this -> http://svn.openfoundry.org/pugs/perl5/Perl6-ObjectSpace/docs/Meta-User-Bridge.pod

[01:54] <luqui> nein

[01:55] * luqui reads

[01:55] <stevan> it's that module/role/signature stuff I was babbling about a while back

[01:56] * luqui is starting to port pge to perl6

[01:56] <stevan> eak!

[01:56] <stevan> better you than me ;)

[01:56] <luqui> I'm doing it basically by redesigning it from the top

[01:56] <stevan> I started porting the metamodel to PIR,.. 

[01:56] <luqui> I know all the algorithms he uses, and I can't read PIR

[01:57] <stevan> stopped that insanity real fast 

[01:57] <stevan> PIR--

[01:57] <stevan> PIL2++

[01:57] <luqui> :-)

[01:57] <stevan> have you seen our pure functional mini-lang?

[01:57] <luqui> no..

[01:57] <stevan> NO

[01:57] * stevan is shocked

[01:57] <luqui> donde esta?

[01:58] <stevan> una momento bitte

[01:58] <luqui> jaja

[01:58] <stevan> here is the Parser with some code examples at the top : http://svn.openfoundry.org/pugs/src/PIL/Native/Parser.hs

[01:59] <stevan> here is the skeleton of the MetaModel bootstrap -> http://svn.openfoundry.org/pugs/src/PIL/Native/Bootstrap.pil

[01:59] <audreyt> stevan: do you think do_if etc is enough?

[01:59] <audreyt> or do you really need shortcut and_do ?

[01:59] <stevan> hey audreyt :)

[01:59] <audreyt> hey stevan :)

[02:00] <stevan> uhm

[02:00] <audreyt> also is do_for enough, or are you thinking about do_while?

[02:00] <stevan> I have not messed around with the do_* yet, so I am not sure

[02:00] <audreyt> do_while is very tricky without containers

[02:00] <stevan> well the do_while I need because I wanted to do this:

[02:00] <audreyt> I think we're better with do_for and recursion with &?SUB

[02:00] <stevan> while (my $c = WALKCLASS($dispatcher)) { ... }

[02:01] <stevan> audreyt: I will mess around with them and get back to you if I need anything more,.. I really cant tell until I try em :)

[02:01] <audreyt> stevan: I think you want a tail recursion

[02:01] <audreyt> with &?SUB

[02:01] <audreyt> should be easier than a container

[02:01] <stevan> ok

[02:01] <stevan> audreyt: what about LISP style macros?

[02:01] <stevan> do you think that might be possible ?

[02:02] <audreyt> it's very well possible, but what can you get from macro you can't from binding a function?

[02:02] <stevan> compile time expansion :)

[02:02] <luqui> oh, so the mini-lang is a small readable syntax for PIL?

[02:02] <audreyt> luqui: yes.

[02:02] <stevan> luqui: for the most part, yes (kinda, sorta)

[02:03] <luqui> good idea

[02:03] <audreyt> it's not the full pil yet, but will expand it with another layer (after bootstrapping MM) so it is

[02:03] <luqui> can you dump to it, too?

[02:03] <audreyt> not sure what it means

[02:03] <audreyt> stevan: compile time expansion?

[02:03] <audreyt> example please :)

[02:03] <luqui> given a pil structure, can you generate minilang code?

[02:04] <stevan> audreyt: I assume too that since we are keeping "pure" about things, we can perform rigorous optimizations, is that part of your plan 

[02:04] <audreyt> luqui: that's the goal, which should be right there after we bootstrap MM and code in SigList + ArgList

[02:04] <audreyt> stevan: yes.

[02:04] <luqui> neato

[02:04] <audreyt> stevan: more importantly, the easly-vs-late binding of symbols can be statically determined.

[02:04] <audreyt> (see: visual basic)

[02:05] <stevan> audreyt: macro infix:<:=> ($lhs, $rhs) { -> $lhs { $rhs } }

[02:05] <audreyt> not sure it works that way :)

[02:05] <stevan> overly simplified I know,.. but thats the idea

[02:05] <audreyt> nod... I think we hardcode sugars into PIL.Native.Parser for now.

[02:05] <stevan> ok

[02:05] <audreyt> not convinced macros is the way to go in minilang

[02:06] <audreyt> macros in surface syntax surely, but otherwise shorthands should just be hardcoded

[02:06] <stevan> I would think they would be easier in the mini-lang than in p6

[02:06] <audreyt> they surely would, but then we need to get into grammatical categories

[02:06] * stevan defers to audreyt on this one though :)

[02:06] <audreyt> like infix

[02:06] <luqui> audreyt, feature request if you have time: "our class"

[02:06] <luqui> and if it's fairly easy

[02:07] <luqui> I looked into it, but I'm afraid to touch the scoping as I don't understand it

[02:07] <audreyt> luqui: all OO hackery delayed until minilang bootting

[02:07] * stevan looks for luqui's test .... ;)

[02:07] <luqui> okay

[02:07] <audreyt> tests welcome though

[02:07] <luqui> :-p

[02:07] <luqui> okay

[02:07] <audreyt> I have a $job demo to do this afternoon

[02:07] <audreyt> but should be free tomorrow and the day after

[02:07] <audreyt> so I should go back to working now :)

[02:07] <audreyt> will checkback tonight

[02:07] <audreyt> (it's 10am here)

[02:07] <stevan> enjoy $work :)

[02:08] <audreyt> I try :)

[02:08] <audreyt> it involves ajax, web continuations and Perl6::Subs

[02:08] <audreyt> so at least it's fun

[02:08] <stevan> nice

[02:08] <audreyt> bbiab &

[02:32] <buu> Scary

[02:36] <mdiep> audreyt: you around?

[03:00] <audreyt> mdiep: no, sorry

[03:01] <mdiep> audreyt: I was hoping you could take a look at "Variables, Aliasing, and Undefined-ness" on p6i

[03:01] <audreyt> noted, will do tonight. anything in particular you'd like to note about it?

[03:02] <mdiep> I'm just wondering how you plan to handle things for Perl. Things are pretty similar in this case for Tcl. It should be pretty clear, I hope.

[03:13] <mdiep> thanks

[03:38] *** _SamB_ is now known as SamB

[04:46] <q[Skud]> who's awake?

[04:47] <obra> hi

[04:47] <hcchien> here

[04:47] <q[Skud]> i'm about to dive back into the docs but wanted to make sure there was someone here to deal with my dumbass questions

[04:47] <obra> Oh.

[04:47] <obra> I may or may not be able to help

[04:47] * luqui is awake

[04:48] <q[Skud]> here's a dumbass svn question

[04:48] <obra> audrey is offline until O(8 hours from now)

[04:48] <obra> oh. svn I can do ;)

[04:48] <q[Skud]> what's the svn equivalent of "cvs diff", i.e. "in what way does what i have here differ from the latest checked in version in the repository?"

[04:48] <luqui> q[Skud], svn diff

[04:48] <q[Skud]> errr. that didn't work.

[04:48] <luqui> hmm?  how so?

[04:48] <q[Skud]> i'm sitting in docs/p6doc

[04:48] <obra> svn diff compares to what you checked out

[04:49] <q[Skud]> i know that gaal committed something yesterday that he said was some minor tweaks to what i'd written so far

[04:49] <obra> svn diff -r HEAD file   may work better

[04:49] <q[Skud]> (i saw the commit message in the irc backlog)

[04:49] <luqui> q[Skud], you might also just update...

[04:49] <q[Skud]> i want to diff across the entire contents of the dir

[04:49] <obra> (svn optimizes by caching a copy of your checked out files so you can do diffs whilst offline

[04:49] <obra> svn diff -r HEAD .

[04:49] <q[Skud]> luqui:  but then how will i know which bits he changed?

[04:49] <luqui> ahh

[04:50] <luqui> use "svn diff -r1237:1238"

[04:50] <q[Skud]> obra: thanks, that worked!

[04:50] <obra> :P

[04:50] <luqui> where those are the revision numbers before and after his checkin

[04:50] <luqui> but -r HEAD works too ;-)

[04:50] <luqui> (apparently)

[04:50] <q[Skud]> how can i tell it to use "diff -u"?

[04:50] <obra> svn help diff

[04:50] <luqui> doesn't it always?

[04:51] <q[Skud]> hang on, never mind. it does. i was just making dumb assumptions

[04:51] <obra> Skud: ~/.subversion/config

[04:51] <q[Skud]> i should probably rtfm ;)

[04:51] <q[Skud]> but i've been r-ing so many fms lately my brane is kinda starting to fry.

[04:52] * luqui understands

[05:11] <revdiablo> q[Skud]: Maybe a bit later, but something I find quite handy is 'svn log -vr BASE:HEAD' -- it will tell you what has changed since your WC's current revision

[05:11] <revdiablo> q[Skud]: The -v part has it show you a summary of the changes rather than just the log messages

[06:16] <gaal> Skud: you can also use the web interface:

[06:16] <gaal> # http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/log/

[06:17] <gaal> # http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/revision/?rev=8243

[06:17] <gaal> I've been meaning to add a "show complete patch" feature to Web::SVN for exactly that page for exactly this purpose, but tuits ran out.

[06:19] <gaal> luqui, still around?

[06:21] <luqui> aye

[06:22] <luqui> gaal, still around?

[06:22] <gaal> heya.  I'm trying to put exportation in the right place

[06:22] <luqui> right place?

[06:22] <gaal> but am not sure about the syntax/usage

[06:22] <luqui> what are you working on?

[06:22] <gaal> rightplace /= parse time of a sub :-)

[06:23] <luqui> oh, code

[06:23] <gaal> luqui: yeah

[06:23] <gaal> if you do  package A; use Foo; package B; use Foo, sub_exported_by_foo();

[06:23] <gaal> it won't work now

[06:24] <gaal> because ruleSubDeclaration is currently where the exportation (hackily) takes place

[06:24] <luqui> ack, because Foo exports symbols as it's being compiled?!

[06:24] <gaal> yeah.

[06:24] <luqui> yeah, that's not right

[06:24] <luqui> do we have IMPORT?

[06:24] <gaal> so for starters I'm fixing that.

[06:24] <luqui> well, it shouldn't be too tough to get if we don't anyway

[06:24] <gaal> no; I'm putting it for now in the code for parsing use.

[06:24] <luqui> what about that module stuff I rambled about on p6l?

[06:25] <gaal> certainly that needs to be acounted for

[06:25] <luqui> well, that seemed like an implementation strategy to me

[06:25] <gaal> yes, my question is now haskell/pugs' Parser.hs

[06:25] <gaal> but you know about that don't you?

[06:25] <luqui> a little bit

[06:26] <gaal> I'm putting the "module" information in %*INC<Foo><exports>

[06:27] <luqui> hmmm

[06:27] <gaal> the keys are symbol names; values are supposed to be closures that transform a Pad

[06:27] <luqui> how about %Foo::EXPORTS

[06:27] <luqui> it would be nicest if we could do it without using anybody's namespace

[06:27] <gaal> might do that; but never moose -- suppose they do exist in a well-known hash

[06:28] <gaal> the technical question is, how to run those closures :-)

[06:28] <luqui> unsafeEvalExp?

[06:28] <gaal> I think a parser needs to return the exp with an updated Pad, no?

[06:29] <gaal> e.g. a regular lexical symbol installation from subs looks like this:

[06:29] <gaal> lexDiff <- unsafeEvalLexDiff $ mkSym nameQualified

[06:29] <gaal> return $ Pad scope lexDiff $ mkExp name

[06:30] <luqui> shouldn't that be the closure's job?

[06:30] <gaal> ( ruleSubDeclaration )

[06:30] <gaal> yeah, that's what I'm trying to figure out

[06:30] <luqui> ?eval my sub infix:<%%> ($x, $y) { $x + $y }

[06:30] *** evalbot_8263 is now known as evalbot_8267

[06:30] <evalbot_8267> \sub {...} 

[06:31] <luqui> ?eval my sub infix:<%%> ($x, $y) { $x + $y } 3 %% 4

[06:31] <evalbot_8267> 7 

[06:31] <luqui> ?eval my sub infix:<%%> ($x, $y) { $x + $y } my $op; BEGIN { $op = '%%' } infix:{$op}(3, 4)

[06:31] <evalbot_8267> 7 

[06:31] <gaal> whee

[06:31] <luqui> hmmm... I'm just thinking about that

[06:32] <luqui> seemed to work without any special lexdiff stuff

[06:32] <luqui> ?eval my $op; BEGIN { $op = '%%' } my sub infix:{$op} ($x, $y) { $x + $y }  3 %% 4

[06:32] <evalbot_8267> 7 

[06:32] <luqui> both ways...

[06:32] <luqui> but that may not be the same thing

[06:33] <luqui> well, we don't have an interface to %MY do we?

[06:33] <gaal> I don't fully grok the way symbols are installed though: always there's a mutation of a pad

[06:33] <luqui> ?eval my $op = 32;  say %MY<$op>;

[06:33] <evalbot_8267> Error: Undeclared variable: "%MY" 

[06:33] <luqui> ?eval my $op = 32;  say %?MY<$op>;

[06:33] <evalbot_8267> Error: Undeclared variable: "%?MY" 

[06:33] <gaal> which Eval later actually reduces

[06:33] <gaal> that's why a parser rule (I think!) just returns the Pad exp element

[06:34] <gaal> I'm not sure how to build that element

[06:34] * luqui noses around in Parser.hs for a moment

[06:36] <luqui> ?eval my &infix:<%%> ::= -> $x, $y { $x + $y };   3 %% 4

[06:36] <evalbot_8267> Error:  unexpected "%" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[06:36] <luqui> okay, yeah, you need to do something special

[06:39] <luqui> that's odd

[06:39] <gaal> so, with a list of Pad update requests, how do I arrange for a Pad really?

[06:39] <luqui> it looks like ::= is trying to handle the lexical stuff, but it's not

[06:39] <gaal> isn't it?

[06:40] <luqui> well, the ?eval above seems to suggest that it's not

[06:42] <gaal> ruleVarDeclaration / lexDiff does treat it

[06:43] <luqui> I'm stumped.  I tried doing some stuff with the lexdiff stuff and it just confused me

[06:43] <luqui> that is, getting a sub to install itself right when it is defined

[06:44] <gaal> I'm missing how to fold together more than one object to a pad transformation

[06:44] <obra> 27

[06:44] <gaal> luqui: the old code does just that

[06:45] <gaal> in ruleSubDeclaration

[06:45] <luqui> no, I mean in its own namespace, and I meant *before* it sees the sub's implementation block

[06:45] <luqui> so that you can use an operator you're defining in its definition

[06:46] <luqui> but... IIRC I failed

[06:46] <luqui> Probably just experiment and wait for audreyt  :-/

[06:46] <gaal> wow, Y keeps coming up these days

[06:46] <luqui> the zip operator?

[06:46] <luqui> or fix?

[06:46] <gaal> combinator

[06:46] <gaal> fix

[06:46] <luqui> yeah, doesn't it?

[06:46] <luqui> I actually wanted it earlier today

[06:47] <luqui> I mean the lazy version

[06:47] <gaal> btw wikipedia cites a ludicrous one:

[06:47] <gaal> Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L L L)

[06:47] <gaal> where L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))

[06:47] <luqui> haha

[06:48] <luqui> I think that should be the official implementation of fix in the perl 6 compiler

[06:49] <gaal> nah, need to port it to Han first.

[06:49] <luqui> sorry I can't help with the lexpad stuff

[06:50] <gaal> IIUC it works for any list if you use the last variable once last in the inner parens and just outside them.

[06:50] <gaal> ok, thanks though!

[06:50] <luqui> on the good news front, I'm making amazingly quick progress on the PGE port

[06:50] <luqui> we have context-free, baby!

[06:50] <gaal> luqui: btw on a local pugs, do "use Some::Module; say %*INC.perl"

[06:50] <gaal> nice!

[06:51] <luqui> gaal, okay..

[06:51] <luqui> and, this shows me what?

[06:52] <luqui> besides %*INC :-p

[06:52] <gaal> it no longer works like the silly p5 INC

[06:52] <gaal> keyed by reasonable name and valued with useful information

[06:52] <gaal> (that's why exports provisionally is hanged there and not in %Foo::EXPORTS)

[06:53] * luqui looks at a similar statement in perl 5 and understands

[06:53] * luqui never messed with %INC in perl 5

[06:53] <gaal> In p5, you recall, it'd be "Some/Module.pm" => "/usr/eek/perl5/Some/Module.pm"

[06:54] <gaal> now the idea is to eventually formalize the struct side of this -- this is where I was smiling when I read your mail -- into some module description object

[06:54] <gaal> but i'll let you get back to much more interesting things :-)

[06:54] <luqui> cool

[06:54] <luqui> alrighty

[06:55] <luqui> once I get out of hacking mode and into design mode, I'll have an interesting treatise on exports

[06:55] <luqui> I promise

[06:55] * gaal looks forward to it, and hopes it is sane. :-)

[06:59] * luqui notices that .perl doesn't handle recursive structures

[07:00] <gaal> does it loop?

[07:01] <luqui> it just keeps printing and printing and printing...

[07:01] <gaal> ?eval my $a = \$a; $a.perl

[07:01] <evalbot_8267> "\\undef" 

[07:01] <gaal> ?eval my $a; $a = \$a; $a.perl

[07:01] <evalbot_8267> "\\undef" 

[07:01] <luqui> references suck

[07:01] <luqui> ?eval my $a = [0];  $a[0] = $a;  $a.perl

[07:01] <evalbot_8267> "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[

[07:02] <gaal> ?eval my $a = moose => $a; $a.perl

[07:02] <evalbot_8267> "(\"moose\" => undef)" 

[07:02] <gaal> ?eval my $a; $a = moose => $a; $a.perl

[07:02] <evalbot_8267> "(\"moose\" => undef)" 

[07:02] <luqui> and unfortunately, you have to make recursive structures two-pass.

[07:02] <gaal> oh vell.

[07:02] <gaal> how to save .perl then? there's an objid for objects, but not i think for native aggregates.

[07:03] <luqui> ?eval say [3].id;  say [3].id

[07:03] <evalbot_8267> OUTPUT[  ] bool::true 

[07:03] * luqui thinks gaal is right

[07:03] <luqui> make an objid for native aggregates?

[07:03] <luqui> or come up with something even more clever?

[07:03] <gaal> :-) probably, yeah.

[07:03] <gaal> the former, lacking the latter.

[07:04] <luqui> actually, I was trying to implement value_fix

[07:05] <luqui> which would be a fixpoint for values, so for my array example, you could say:

[07:05] * gaal notes .id doesn't work as I think it's advertised.

[07:05] <luqui> my $a = fix (-> $x { [$x] })

[07:05] <gaal> it gives a hash, not an id.

[07:05] <gaal> should it give a unique id?

[07:06] <luqui> probably

[07:06] <gaal> where's it specced? I don't remember

[07:06] <luqui> we can always come up with enough unique ids if we use Integer

[07:06] <luqui> It's specced as giving the memory address

[07:06] <luqui> but that's stupid

[07:06] <luqui> we can take liberty to change the spec

[07:07] <gaal> in the case of .perl, a memory address is sufficient (and fast)...

[07:07] <luqui> that's true

[07:07] <luqui> good luck getting haskell to tell you one though

[07:07] <gaal> .clone, btw, generates a different id now. is that correct?

[07:07] <luqui> uh huh

[07:07] <gaal> I think it must be

[07:08] * luqui thinks about .perling an infinite data structure

[07:08] <luqui> and whether memory address would always be sufficient in that case

[07:08] <luqui> like [1...].perl  or something

[07:08] <gaal> what are the disadvantages of using an address, in general?

[07:08] <luqui> where you can throw away the earlier elements as you print them

[07:08] <gaal> not unique across processes?

[07:08] <gaal> across serialization?

[07:09] <luqui> not unique across destruction

[07:09] <luqui> if you store a hash of ids

[07:09] <luqui> a different object may come along once the first one has been destroyed with the same id

[07:09] <gaal> ah, the Replay Attack

[07:10] <gaal> so a strong monotonic function, eg, { ++$id }, is basically the only way.

[07:10] <gaal> I think.

[07:10] <luqui> probably

[07:10] <luqui> I don't think it's a big deal

[07:11] <luqui> the id will never exceed 8 bytes, right?

[07:11] <gaal> hahaha

[07:11] <luqui> and you only have to create it when somebody asks for it

[07:11] <luqui> (not that the 8 bytes thing can be used as an optimization)

[07:12] <gaal> (what lives at 8 bytes, btw? Haskell Integer?)

[07:12] <luqui> (but seriously, you come up with a program that will use 10^19 objects)

[07:12] <luqui> int64

[07:12] <luqui> haskell Integer is variable length

[07:12] <gaal> int64 of course, but we're still a while off

[07:12] <gaal> Integer's the one that promotes automatically?

[07:12] <luqui> if it's ever demoted

[07:12] <luqui> yes

[07:13] <luqui> it's a gmp int

[07:13] <gaal> ...still a while off before *everybody* has it that is.

[07:13] <gaal> anymoose the point about ids being generated lazily is an excellent one

[07:13] <luqui> Unique ids only have to be unique for one invocation of the program, methinks

[07:14] <gaal> but I wonder if it really works out, if eg some operation doesn't in practise always trip an id.

[07:14] <luqui> 'splain

[07:14] <gaal> ...like putting in a hash :)

[07:14] <luqui> you mean making it the *key* of a hash

[07:15] <luqui> which isn't very common for things other than strings

[07:15] <gaal> point.

[07:16] <gaal> btw, there's a way of fixing the memory-addr problem.

[07:16] <gaal> it's a little RAM-expensive though.

[07:16] <gaal> #define free

[07:16] * gaal ducks

[07:17] <luqui> haha

[07:17] <luqui> *smack*

[07:17] <luqui> ooh, when you weren't expecting it

[07:17] <gaal> I think I'll go have breakfast now :-)

[07:17] <svnbot6> r8268 | luqui++ | Very beginnings of a PGE port in perl 6.

[07:40] <Khisanth> luqui: PGE written in perl 6?

[07:41] <dduncan> it has to happen eventually

[07:41] <dduncan> otherwise the full Perl 6 won't work on a non-Parrot host

[07:51] <luqui> Khisanth, aye

[07:52] <luqui> ha'dy kakos` 

[07:52] <kakos`> Hey there

[07:52] <kakos`> What's up?

[07:52] *** kakos` is now known as kakos

[07:52] <luqui> working on perl 6 regex engine

[07:53] <luqui> highly un-theoretical for a change

[07:53] <kakos> Sounds like fun

[08:05] <gaal> stevan_: ping

[08:05] <gaal> I noticed a small documentation bug in lambda.pm

[08:05] <gaal> # FALSE :=  λ x. λ y. x

[08:05] <gaal> itym

[08:05] <gaal> # FALSE :=  λ x. λ y. y

[08:06] <gaal> the implementation is correct though.

[08:10] <luqui> what is lambda.pm

[08:11] <gaal> luqui: http://search.cpan.org/src/STEVAN/fp-0.03/lib/fp/lambda.pm

[08:12] <gaal> sure to look better in p6 :)

[08:12] <gaal> it's just started raining.

[08:12] <luqui> quite sure

[08:12] <gaal> notable because we're in the middle of december and people were wearing t-shirts yesterday.

[08:13] * luqui envies gaal

[08:13] <luqui> that's how it was last month

[08:13] <luqui> but come Dec 1, it started to feel like winter

[08:14] <gaal> where do you live?

[08:14] <luqui> colorado

[08:14] <gaal> oh, why did I imagine you were from the UK?

[08:14] <luqui> er, usa, of course. I mean, does anybody live anywhere else?

[08:15] <luqui> maybe because I keep UK hours?

[08:15] <gaal> audreyt lives all over! :)

[08:15] <gaal> you do, at that.

[08:16] <gaal> so when you say it started to feel like winter, you mean you had to get out and shovel snow off the driveway to leave the house?

[08:16] <luqui> we haven't had all that much snow this year

[08:16] <luqui> but it's been friggin cold

[08:26] <gaal> one of the nice things of rarely getting sub-freezing temperatures is citrus fruits. fresh orange juice, and I mean the kind you just squeezed yourself, is the bestest.

[08:28] <gaal> when I spent some time in the UK I'd buy imported oranges for about $75823582 a kilo. Here they're practically free.

[08:30] <luqui> where are you now?

[08:30] <gaal> .il (not the US state)

[08:32] <luqui> er... umm... oh, yeah... .il... that's a great place

[08:32] * luqui feels stupid

[08:32] <gaal> Tel-Aviv, Israel

[08:33] <luqui> ah, right

[08:33] <luqui> for some reason I was confusing you with iblechbot 

[08:33] <luqui> er, iblech

[08:34] <luqui> I even knew that if my brain hadn't been so flatulent

[08:34] <gaal> iblech is rather more productive :)

[08:36] * luqui was wondering why you were asking me about the parser

[08:36] <luqui> I was thinking, man, I should be asking you

[08:37] <luqui> after writing in Haskell for a couple months now... i'm really quite disgusted with pugs's internals

[08:37] <gaal> whoa! google does it again: http://www.google.com/musicsearch?q=beethoven&btnG=Search+Music

[08:37] <luqui> of course, it was a rocket open source project, so you can't expect beauty

[08:38] <gaal> there's still a ways to go before it becomes p5 :-)

[08:38] <obra> gaal: you mean before it's that bad?

[08:38] <gaal> yeah

[08:39] * luqui checked out the perl 5 source code once and his vision started fading, so he promptly deleted it

[08:39] <luqui> that is to say, I haven't really looked at perl 5 much at all

[08:40] <luqui> I had a negative two line patch go in once

[08:40] <luqui> but apparently it was taken back out

[08:40] <luqui> or put back in.  or whatever happens to negative patches

[08:41] <gaal> "reverted" is sign-neutral.

[08:49] <luqui> gaal, do you have any idea where "new" is defined?

[08:50] <luqui> oh, there she is in Prim.hs

[08:51] <luqui> Object::new, so searching for '"new"' didn't work

[09:04] <svnbot6> r8269 | luqui++ | Implemented $obj.clone(attr => newval)

[09:06] <GeJ> servus

[09:10] <gaal> luqui: sorry, I was practicing solfege.

[09:10] <luqui> np, I figgr'd it out

[09:10] <luqui> solfege?

[09:11] <gaal> I'm learning to read.

[09:11] <gaal> http://www.livejournal.com/users/gaal/177921.html

[09:12] <luqui> music?

[09:12] <gaal> yeah

[09:12] <gaal> (GNU Solfege)++

[09:13] <luqui> that is some crazy music you posted there

[09:14] <gaal> Must be an equivalent of a japh.

[09:14] <luqui> if it makes you feel better, I've been playing classical music on the piano for 5 years (from sheet music) and still can't sightread the simplest of pieces

[09:15] <gaal> how much work did you put into that particular aspect of your training

[09:15] <gaal> ?

[09:15] <luqui> "okay, so the bottom line is middle C, so B, A, G, there we go

[09:15] <luqui> well, not much on sightreading in particular, but you'd think after reading 12 beethoven sonatas I'd get the hang of it

[09:16] <gaal> I don't really think that :-(

[09:16] <luqui> now I want to go play some beethoven

[09:17] <luqui> yeah, but you *would* think that

[09:18] <gaal> I would, if I'd never tried to learn this stuff

[09:19] <luqui> though I've found that I'm a lot quicker if I have small relative intervals I can use

[09:19] <luqui> that is, I haven't memorized the lines--at all--but I can do intervals pretty well now

[09:20] <luqui> that is to say, the music you posted on your blog would be hell for me

[09:20] <gaal> I'm trying to get used to a sixth now, so that I can find C given 440Hz.

[09:20] <luqui> you only need a minor third for that, right?

[09:21] <luqui> but you're talking about singing?

[09:21] <gaal> not singing for performance level, but to be able to, you know, anticipate the next note or follow a score

[09:21] <luqui> ear training

[09:22] <gaal> yes.

[09:22] <gaal> colliquially known as solfege :-)

[09:22] <luqui> ahh

[09:22] <luqui> I've never really had to work at that.  Just kinda came naturally

[09:23] <luqui> (except rhythms.  I've had to work at that a bit)

[09:24] <luqui> well, anyway, good luck.  off to beethoven I am

[09:24] <gaal> enjoy :-)

[09:30] <gaal> ah! all i have to remember is that the album Let it Be starts with a sixth, in Two of Us.

[09:34] <luqui> also Chopin's famous nocturne in Eb

[09:35] <luqui> which is my "sixth metric"

[09:35] <gaal> right!

[09:36] <r0nny> yo

[09:36] <gaal> (I could never had ACKed that without knowing the piece and having a guitar with me)

[09:36] <r0nny> anyone knows the state of audreyt's object system rewrite ?

[09:37] <gaal> "under construction", I think.

[09:38] <GeJ> r0nny: stevan has an entry in his journal with links to some relevant files

[09:40] <r0nny> url ?

[09:42] <GeJ> seen on planet perl 6

[09:42] <jabbot> GeJ: I havn't seen on, GeJ

[09:43] <GeJ> r0nny: http://planetsix.perl.org/

[09:50] <r0nny> nice stuff

[09:50] <GeJ> indeed

[09:50] <r0nny> its goot its worth waiting

[09:51] <r0nny> eh god

[09:54] <gaal> fwiw, lj users: http://www.livejournal.com/userinfo.bml?user=stevan_rss

[09:55] <gaal> come to think of it, http://www.livejournal.com/userinfo.bml?user=planet_perl_six

[10:00] <clkao> http://m19s28.vlinux.de/iblech/stuff/pugs-smokes/pugs-smoke-6.2.10-r8265-freebsd-pil2js--1134725375-4936--7869-6249-1620-701-2179-210--c4286321f231f0a00353775b99c96c21.html

[10:00] <clkao> so this is a smoke run for jsperl5

[10:01] <gaal> very cool! up from how much before io?

[10:01] <gaal> oh, everything yellow?

[10:01] <gaal> 210 tests. clkao++

[10:03] <clkao> i don't have eval

[10:03] <clkao> s/i/we

[10:22] <svnbot6> r8270 | luqui++ | Backtracking controls.

[10:34] <svnbot6> r8271 | luqui++ | Better names for Union and Concat's subtrees.

[10:41] <Juerd_> Compiling XML to Perl leads to insane, but nice, results.

[10:41] <wilx> Huh?

[10:42] <nnunley> So turning an XML template into a Perl based XML generator?

[10:42] <Juerd_> XML scripts, XML modules, XML input, XML output...

[10:42] <Juerd_> A bit extreme, maybe, but so far it works and is grokkable :)

[10:43] <Juerd_> nnunley: Not necessarily, but yes, that's one of the envisioned uses.

[10:43] <luqui> Juerd_, why?

[10:43] <wilx> XML is like cancer.

[10:44] <wilx> It spreads everywhere and usually when you spot it it is already too late.

[10:44] <Juerd_> luqui: We had an XML document containing conditions and attached (nested) specifications of actions

[10:44] <Juerd_> luqui: Skipping a few steps was decided to be much easier

[10:44] <luqui> wilx, apparently I went to the hospital and they caught it early.  I used it for one project, was discusted and swore never to touch it again if I could manage

[10:44] <Juerd_> luqui: So there is no semantic parse of the XML, only a direct translation, which then requires a module for semantics.

[10:45] <wilx> luqui :)

[10:45] <luqui> Juerd_, okay, that actually sounds a bit more sane than what I was picturing

[10:45] <Juerd_> luqui: Then, the engine built appeared to be useful in many other ways too, and it was extended.

[10:45] <Juerd_> luqui: Trust me, it's extremely insane anyway :)

[10:46] <Juerd_> The environment this will be used in is already soaked with XML

[10:46] <Juerd_> So the choice for XML for new components is natural

[10:47] <Juerd_> The project manager was positive about opening up the source onto CPAN, but not before it's in a more finished and polished state.

[10:48] <luqui> that's cool

[10:48] <Juerd_> I think so :)

[10:48] <luqui> I like "open"-minded  managers

[10:50] <Juerd_> Gone now

[10:50] <Juerd_> Bye

[13:15] <r0nny> re

[13:20] <svnbot6> r8272 | iblech++ | PIL2JS: Prelude::JS::IO: Possible fix to clkao++'s &system.

[13:23] <nnunley> iblech: BTW,  clkao just got exceptions working correctly from Perl space to Javascript space.

[14:31] <audreyt> yo

[14:33] <svnbot6> r8273 | autrijus++ | * PIL/Native/Bootstrap.pil parses... runs... bootstraps!

[14:33] <svnbot6> r8273 | autrijus++ |   Going to implement the proper C3 correctly tomorrow.

[14:33] <svnbot6> r8273 | autrijus++ |   But for now, suffice it to day stevan++'s work had finally

[14:33] <svnbot6> r8273 | autrijus++ |   arrived to the new PIL runcore. :)

[14:34] * audreyt survided $work and reenters pugsland

[14:34] <audreyt> survived, even

[14:37] <GeJ> welcome home!

[14:37] <GeJ> :)

[14:37] <audreyt> :))

[14:38] <r0nny> audreyt: does this mean the undefined instance prob is solved ?

[14:39] <audreyt> r0nny: still need to implement container classes (like, Scalar) for that to be solved

[14:39] <audreyt> again, give me another few days :)

[14:40] <r0nny> darn

[14:40] <r0nny> well - again time to point a "this one rules" sign into your direction

[14:40] <audreyt> which test is that?

[14:40] <audreyt> (undefined instance that is)

[14:40] <r0nny> test ?

[14:41] <audreyt> yeah... like, something in the t/ directory that I can run to make sure when I've fixed it

[14:41] <r0nny> didnt u guys make one when u discussed the problem ?

[14:41] <audreyt> I didn't quite recall, which is why I ask :)

[14:41] <r0nny> who knows

[14:46] <gaal> hi!

[14:46] <r0nny> yo gaal 

[14:47] <audreyt> gaal: hey

[14:48] <audreyt> sadly I will probably sleep soon -- still got this jet lag thing a bit

[14:48] <audreyt> will be back and work on pugs all day after I wake up though :)

[14:48] <r0nny> :)

[14:49] <gaal> audreyt: i'm hoping to sneak in a quick Q :-)

[14:49] <audreyt> sure, go ahead

[14:49] <r0nny> cant do anything tomorow

[14:49] <gaal> have to figure out pbotutil config first :-)

[14:49] <audreyt> will look at it after (instead of inside) shower

[14:50] <r0nny> pbotutil ?

[14:52] * gaal thinks audrey's new topology is prudent

[14:52] <gaal> r0nny: you know pastebot? there's a script fort interacting with it via the commandline

[14:55] <pasteling> Someone at 192.115.25.249 pasted "Index: src/Pugs/Parser.hs ====" (87 lines, 4.2K) at http://sial.org/pbot/14995

[14:56] <gaal> errr, so that was supposed to be "svn diff | pastebot" except I forgot to config it with my nick, and give it a title.

[14:57] <gaal> audreyt: so my question is about the "handwaving" portion. how do I spell "export everything from this list"?

[14:58] <audreyt> you... just return a Pad.

[14:58] <audreyt> I think.

[14:58] <audreyt> instead of emptyExp.

[14:58] <audreyt> hand waving hits! hand waving bites! hand waving turns to flee! --More--

[14:59] <gaal> yes, that was the idea :-)

[14:59] <gaal> okay, but I have potentially several symbols

[14:59] <gaal> how do I combine them?

[14:59] <gaal> and: is the way I set them up correct?

[15:00] <gaal> (elsewhere in the diff; where I'd ripped out ruleSubDeclaration's export

[15:00] <gaal> )

[15:00] <audreyt> hm? you don't have to combine

[15:00] <audreyt> just introduce them and get lexDiff

[15:00] <audreyt> it will contain however many symbols you introduce

[15:01] <gaal> also also, this is a lot like programming in the Prelude: how do I arrange for this value to actually be returned (and for the other try option to return an emptyExp if it was successful)?

[15:02] <audreyt> try (do { verbatimParens whiteSpace; return emptyExp }) <|> do

[15:02] <audreyt>     ...

[15:02] <audreyt>     return somePadhere

[15:02] <audreyt> that's it

[15:03] <gaal> ok

[15:03] <audreyt> bbiab. :)

[15:03] <gaal> now how do I get them into lexDiff? Is what I have there with the fold actually correct? :-)

[15:03] <audreyt> it looks at least plausible :)

[15:03] <audreyt> brb

[15:03] <gaal> sure

[15:04] <gaal> thanks :-)

[15:11] <gaal> ouch. I need Pugs.Prim.Keyed's valuesFromRef. How malignant would reexporting it through Prim be?

[15:12] <gaal> or maybe I should just App "&values" ?

[15:13] <gaal> Yeah, I'll do that. Programming in AST!

[15:17] <audreyt> ...or you can ask pugs to give it to you with :D

[15:17] <audreyt> pugs> :D 1+1

[15:17] <audreyt> (App (Var "&infix:+") Nothing [Val (VInt 1),Val (VInt 1)])

[15:18] <audreyt> oh, wait, you just need to call one thing.

[15:18] <audreyt> then sure, just say App

[15:18] <audreyt> you are in the parser, producing AST is the correct thing to do there

[15:19] <gaal> is the :D op so named because it makes you happy?

[15:19] <audreyt> no, but you are free to infer so :)

[15:20] <r0nny> lol

[15:22] <gaal> ok now I have to figure out how to de-Exp-ify:    exports <- unsafeEvalExp ..., which gives me an but I want to fish out a hash ref from that.

[15:23] <gaal> (all the fromVals there are, of course, wrong)

[15:25] <gaal> can I simply pattern-match against Val?

[15:26] <audreyt> sure if you are sure

[15:26] <audreyt> alternatively use a fromVal

[15:26] <audreyt> (more canonical form)

[15:26] <audreyt> but if you control both sides, don't bother

[15:27] <gaal> fromVal doesn't work, because of monadic problems:

[15:27] <gaal> # Couldn't match `EvalT (ContT Val (ReaderT Env SIO))' against `(->) t'

[15:27] <audreyt> yeah, because you are in Parser

[15:27] <audreyt> so just patmatch

[15:27] <audreyt> feel free to check in once you get it to work -- or at least not breaking all tests -- I'll take a look tomorrow

[15:28] <audreyt> good night!

[15:28] <audreyt> gaal++

[15:28] <gaal> btw I couldn't find the definition of fromVal (well, just = fromVal', but no further)

[15:28] <gaal> thanks, sweet dreams :-)

[15:29] <audreyt> fromVal is defined for each variant

[15:29] <audreyt> all in Pugs.AST.Internals

[15:29] <gaal> ah, typeclasses and that funky stuff. this is a good time for another iteration on the tutorials.

[15:30] <audreyt> as you are in parser, you can't use it easily, so just patmatch against VRef

[15:31] <gaal> okay, hopefully I can take it from here :)

[15:31] <audreyt> (Val (VRef ...)) I mean

[15:31] <wolverian> svk up -sm is the same as svk pull, right?

[15:31] <audreyt> alternatively, do another form of unsafeEvalExp

[15:31] <audreyt> wolverian: yes

[15:31] <wolverian> thanks :)

[15:31] <wolverian> (I have a bad memory)

[15:31] <audreyt> unsafeEvalExpValue :: Value a => Exp -> RuleParser a

[15:32] <audreyt> which is just copying unsafeEvalExp but add a fromVal to it

[15:32] <audreyt> then you ca n make unsafeEvalExp = unsafeEvalExpValue

[15:32] <audreyt> er

[15:32] <audreyt> unsafeEvalExp = fmap Val unsafeEvalExpValue

[15:33] <audreyt> or some such... improvise.

[15:33] * audreyt waves and goes to sleep :) &

[15:33] <gaal> :-)

[15:52] <fglock> +4 hours work, then 32 day vacation!

[16:00] <Juerd_> Sounds like a very fair trade, fglock 

[16:00] <rafl> Juerd_: Got the mail from guckes?

[16:05] <clkao> fixing js exception makes slurp.t all passed

[16:22] <svnbot6> r8274 | clkao++ | update jspm snapshot url.

[16:32] <Juerd_> rafl: Yes, he wants us to consider flying. Might I ask why moving by car is such a bad idea?

[16:33] <Juerd_> rafl: I've found a passenger who can also drive, which solves my only two downsides: cost (when split in two, it's no longer an issue), and duration (we can alternate drivers)

[16:35] <rafl> That's good!

[16:42] <rafl> Juerd_: I also have no idea why guckes doesn't like moving by car. Maybe because he doesn't have a car? :-)

[17:38] <Juerd_> Hm

[17:39] <Juerd_> I have the impression that people in america tend to IRC much less in work time than west-european people

[17:41] <rafl> Juerd_: How do you come to that impression?

[17:43] <PerlJam> Juerd_: Those people that I know that IRC at work are on it all the time.

[17:48] <Juerd_> rafl: IRC :)

[18:30] <r0nny> Juerd_: some of them might just lack intention to set away states

[19:29] <Juerd_> Does vim have a key like w that goes BACK one word?

[19:29] <sili> b

[19:29] <Juerd_> My keyboard driver is broken and lacks repetition :(

[19:29] <Juerd_> Ah, thanks

[19:30] <sili> if you haven't learned them yet, there is W and B also.

[19:30] <sili> and e/E

[19:32] <Juerd_> Thank you

[19:54] <webmind> Juerd_, you're suposed to know that for your lpic1

[19:55] <Juerd_> Strange. I thought you only needed to know :q! ;)

[20:00] <webmind> tss :)

[20:02] *** integral is now known as ntgrl

[20:05] <sili> ntgrl: not girl.

[20:10] <luqui> I don't know what all this spambot hubbub (sp?) is about

[20:10] <luqui> I've never seen any such spambot here

[20:11] * stevan spams luqui

[20:11] <luqui> Ow?

[20:11] <stevan> luqui: was it a short Perl 6 meeting , or did you not transcribe the entire thing?

[20:11] <luqui> It was very short, because nobody was there

[20:11] <stevan> ah

[20:11] <luqui> Including me

[20:12] <luqui> I think the community might give me more credit for the notes than deserved

[20:12] <stevan> why?

[20:12] <luqui> chromatic actually takes the notes, I just edit them (which usually is doing nothing) and post them

[20:12] <stevan> ah

[20:13] <luqui> I only get to edit when chromatic isn't there any somebody who isn't as good at notetaking is.

[20:13] <PerlJam> Why doesn't chromatic put them up then?

[20:13] * luqui ?s

[20:14] * luqui invented a new verb :-)

[20:15] <PerlJam> If you "edit" them by doing nothing, then why doesn't chromatic put them up on his use.perl journal?

[20:15] <luqui> oh, my new verb is confusing

[20:15] * luqui dunnos

[20:15] <luqui> peer-review?

[20:15] <PerlJam> fair enough

[21:09] <Juerd_> I'm beginning to like XML. Someone please find me a rant :)

[21:10] <Juerd_> Google++  # found some :)

[21:11] <Juerd_> http://www.zefhemel.com/archives/2004/09/12/the-church-of-xml

[21:11] <Juerd_> Oops, wrong one.

[21:22] <luqui> I think XML is a fine markup language

[21:22] <luqui> but it sucks as a data language

[21:23] <luqui> that is, XML and YAML are two very different things, and one should not be used where the other is appropriate 

[21:40] <Juerd_> 22:26 < luqui> I think XML is a fine markup language

[21:40] <Juerd_> 22:27 < luqui> but it sucks as a data language

[21:40] <Juerd_> And how do you feel about XML as a programming language? :P

[21:42] <obra> XPL!

[21:43] <pd> http://sexpr.sourceforge.net/

[21:44] <Odin-LAP> Juerd_: Silly, but possible, I'd wager.

[21:45] <Juerd_> http://tnx.nl/4352BIUW

[21:45] <Juerd_> Can't believe I actually wrote that years ago and nobody has noticed it yet.

[21:45] <Juerd_> obra, pd: thanks for the references. I'll have a look.

[21:46] <obra> oh god. XPL was an msft internal joke

[21:47] <Juerd_> Oh; heh :)

[21:47] <Juerd_> sexpr doesn't seem to be related to what I said

[21:47] <obra> then someone shipped it

[21:47] <Juerd_> Grin

[21:47] <obra> it used xslt to turn programs in XML into C and VB

[21:47] <Juerd_> Ahh

[21:47] <Juerd_> That's a little like what I'm doing

[21:48] <Juerd_> I can't find anything useful about XPL. What should I ask Google?

[21:48] <Odin-LAP> obra: A house of horrors, one would think.

[21:49] <obra> Juerd_: not sure it ever made it out under that name

[21:49] <obra> it was literally an april 1 joke

[21:49] <obra> I'll keep my eye on my old backups to see if I can find it

[21:49] <Juerd_> ok

[21:50] <Juerd_> http://www.topxml.com/XPL/spec_draft.asp

[21:50] <obra> that is not my XPL

[21:50] <obra> "my"

[21:50] <luqui> if I see "svm" in the commit logs, what does it mean?

[21:50] <Juerd_> luqui: Ehm. Which commit logs?

[21:51] <Juerd_> I've today tried to write an ssh-agent like thing called svm.

[21:51] <Juerd_> I hope you don't have access to that repository :)

[21:51] <luqui> I did a svk praise and there are a bunch of lines attributed to "svm"

[21:51] <Juerd_> Ohh, okay :)

[21:51] <Juerd_> *wipes sweat off forehead*

[21:51] <luqui> :-)

[21:51] <Juerd_> The NDA is quite specific about the svn repositories, you see :)

[21:57] <Shillo> Juerd_: Hopefully your NDA doesn't ban you from saying that you were writing an ssh-agent like system...

[22:01] <Juerd_> Shillo: It does, and I've actually not signed it. But the eventual NDA that I will sign will not.

[22:03] <PerlJam> luqui: svm == svn mirror

[22:03] <Juerd_> PerlJam: Is that an existing tool, or jargon?

[22:04] <PerlJam> jargon I think. 

[22:04] <PerlJam> or maybe it's a tool that comes with SVN::Mirror

[22:05] <luqui> that sucks

[22:05] <luqui> how do I find out who really modified those lines then?

[22:05] <Juerd_> [   ] svm                         12-Dec-2005 12:39  3.0K  

[22:05] <Juerd_> Darn.

[22:05] <PerlJam> luqui: you'll have to ask clkao 

[22:05] <Juerd_> I'll have to change my svm's name.

[22:06] <Juerd_> PerlJam: Thanks

[22:06] <Juerd_> PerlJam: You avoided horrible things

[22:06] <Juerd_> afk  # going home

[22:17] <buu> "It's beginning to look a lot like.. fish men! Everywhere I go.."

[22:17] <luqui> stop stealing our water!

[22:19] <buu> Fishmas++

[22:38] <dduncan> ?eval my $x = 3; my $y = undef; my $z = $x + $y; say $z;

[22:38] *** evalbot_8267 is now known as evalbot_8274

[22:38] <evalbot_8274> OUTPUT[3 ] bool::true 

[22:38] <dduncan> now, this is another issue I plan to raise

[22:39] <dduncan> but first ...

[22:39] <dduncan> what does 'undef' mean to you?

[22:39] <dduncan> to me, it means 'unknown'

[22:39] <dduncan> and hence, any operation using an undefined variable which expects a defined one should not return a defined value

[22:40] <dduncan> it should either fail or return undef itself

[22:40] <dduncan> eg, the expression 4 + 3 should return 7, but 5 + undef should return undef or fail

[22:40] <dduncan> what do you guys think?

[22:41] <dduncan> undef should not be treated the same as zero

[22:41] <dduncan> does the language spec talk about this somewhere?

[22:41] <dduncan> looking ...

[22:43] <buu> I *like* undef as zero.

[22:44] <buu> It makes me happy.

[22:44] <sili> you are ugly.

[22:44] <buu> =[

[22:44] <buu> When the great old ones arise they will destroy your feeble sanity.

[22:46] <dduncan> having undef in numerical context being equal to zero is only helpful to lazy developers ... for any real work, it is just a source of bugs

[22:47] <dduncan> of course, I'm not against there being some pragma or Class trait that says how undefined variables of their type are treated in certain contexts, but in the absense of this they should default to not being equal to anything, zero or otherwise

[22:48] <dduncan> so undef always != undef

[22:49] <buu> Hmph.

[22:49] <dduncan> I'm going to writeup a p6l post on this shortly

[22:50] <buu> Yay for making basic operations take more lines of code.

[22:50] <dduncan> oh?  what would take more code?

[22:50] <dduncan> example?

[22:51] <buu> $x + ( defined $y ? $y : 0 )

[22:51] <dduncan> you forgot the // operator

[22:51] <buu> Well, yes

[22:51] <buu> And actually you could use || too.

[22:51] <buu> But I don't see the point.

[22:51] <buu> You can already check if you care, if not let it do something sensible.

[22:52] <dduncan> the thing is, if you already know from somewhere earlier in your code that $y was defined, you don't have to do what you did

[22:52] <buu> $y = sub_that_may_return_undef

[22:52] <dduncan> and if you don't know, such as if $y is an argument, then checking your input for correctness is the proper action

[22:53] <buu> Yes, but you can already check. Changing this behaviour doesn't *add* anything.

[22:53] <dduncan> using $y // 0 means that you know $y may be undef, and you are defaulting it to zero if it is

[22:53] <buu> Sure, but why should you be forced to do that? That's how it works right now.

[22:53] <dduncan> the problem relates to bugs sneaking in

[22:53] <buu> How so?

[22:54] <dduncan> what if you forgot to initialize something but your code assumed you did?

[22:54] <dduncan> having altered behaviour would lead to Perl itself pointing this out

[22:54] <buu> So would warnings.

[22:54] <dduncan> and you could more quickly find the source of your bug

[22:54] <buu> What does that get you that adding a warning on undef doesn't?

[22:55] <dduncan> you don't have to add the warning on undef

[22:55] <dduncan> and your code itself is better self-documenting

[22:55] <buu> *shrug*. I've always absolutely detested the 'warn on undef' feature of warnings.pm, but I'm not sure I can fully articulate why.

[22:56] <dduncan> the change I suggest brings things out into the open that would be magical and hidden otherwise

[22:56] <dduncan> I consider auto-change of undef into a defined value to be magical and non-intuitive

[22:57] <buu> Heh. I suppose I'm just used to programming with it. I suppose if you forced that change on me  I would resort to specifically returning 0 or some such.

[22:57] <buu> I enjoy my magical and hidden feautres =/

[22:57] <dduncan> the intuitive thought is that your variables don't change unless you tell them to or they are defined by a class that is volitile

[22:58] <buu> Er, but how is the variable changing?

[22:58] <dduncan> people are used to lots of things in perl 5 but that doesn't make them best behaviour

[22:58] <dduncan> its changing to zero from undef without being explicitly told to

[22:58] <buu> It's overloaded

[22:58] <dduncan> an undef is a distinct value, or absense of value, that is different from all others

[22:58] <buu> ?eval 32 + undef;

[22:58] <evalbot_8274> 32 

[22:58] <buu> ?eval "a"~0

[22:58] <evalbot_8274> "a0" 

[22:59] <dduncan> so what you see now in pugs is the perl 5 way

[22:59] <buu> dduncan: And what is the string definition of "absense" of value?

[22:59] <dduncan> an empty string and an undefined string are 2 different things

[22:59] <dduncan> an empty string is ''

[22:59] <dduncan> an undefined string can't be printed

[23:00] <buu> I suppose.

[23:00] <dduncan> in debugging situations, the thing can print something like <undefined> in place of an undefined value

[23:00] <dduncan> like it prints <obj:foo> now

[23:00] <buu> I'm just having trouble thinkinf of a situation where it would help me.

[23:01] * dduncan mail run, back in 15m

[23:04] <nwc10> evalbot_8274: help?

[23:05] <nwc10> evalbot_8274 say "Hello world\n"

[23:05] <nwc10> OK. I'm not winning here.

[23:06] <dduncan> nwc, you invoke evalbot with a leading ?eval

[23:06] <dduncan> like this

[23:06] <dduncan> ?eval say 'foo';

[23:06] <evalbot_8274> OUTPUT[foo ] bool::true 

[23:07] <nwc10> ?eval say "foo\n"

[23:07] <evalbot_8274> OUTPUT[foo  ] bool::true 

[23:07] <nwc10> ?eval say "foo"

[23:07] <evalbot_8274> OUTPUT[foo ] bool::true 

[23:07] <nwc10> aha. I take it that there's always 1 \n added to say?

[23:07] <dduncan> yes

[23:07] <dduncan> say is like print but with a "

[23:07] <dduncan> \n added

[23:07] <dduncan> very handy for common case

[23:08] <dduncan> you don't need to have a say or print though

[23:08] <dduncan> eg

[23:08] <dduncan> ?eval 4 + 4

[23:08] <evalbot_8274> 8 

[23:08] <dduncan> so you just say ?eval <code-to-run>

[23:08] <dduncan> simple

[23:08] <nwc10> ?eval 2 < (0|6) < 4

[23:08] <evalbot_8274> bool::false 

[23:08] <dduncan> anyway, back in 15m

[23:55] <mlh_> ?eval "hello"->?

[23:55] <evalbot_8274> Error:  unexpected ">" or "-" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[23:55] <mlh_> ?eval "hello"

[23:55] <evalbot_8274> "hello" 

[23:55] <mlh_> ?eval "hello" + 0

[23:55] <evalbot_8274> 0.0 

[23:55] <mlh_> ew

