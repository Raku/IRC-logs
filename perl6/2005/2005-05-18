[00:00] <mugwump> sure, Boots.  it certainly has stalled.  I wrote a nice stream processor and DOM module in Perl 5, but ingy hasn't come up with a parser yet

[00:00] <mugwump> otoh, stevan has written two modules in Pugs that stream Pod and Kwid

[00:01] <Boots> can they convert between eachother or do they just stream to a common format?

[00:01] <mugwump> nothing like that in the Perl 5 implementation yet

[00:01] <mugwump> haven't looked at stevan's work in detail yet

[00:03] <Boots> alright thanks for the input.  I hope kwid progress as I really like the look of it.

[00:04] <Boots> s/progress/progresses/

[00:04] <mugwump> sure.  I think that Pugs is actually ready to have the Perl 5 project ported to it already... which will certainly help progress

[00:26] <svnbot6> r3368, mugwump++ | Set - Test 'overloaded' operators

[00:33] <theorbtwo> Hm.  Once I disable -fno-warn-missing-signatures I can add in most of the missing signatures.

[00:34] <theorbtwo> But for src/Pugs/Compile/Haskell.hs, if I leave it as-is, I get an error that I haven't given a type signature for mainCC.  If I try adding a type signature, I get Not in scope: `mainCC'.

[00:39] <svnbot6> r3369, mugwump++ | More operator overloading tests...

[00:39] <svnbot6> r3370, mugwump++ | More operator overloading tests...

[00:42] <kelan> where can you even add a type signature for mainCC in src/Pugs/Compile/Haskell.hs? is it being defined there on that 'liftIO' line?

[00:42] <kelan> inline type signatures are kinda done like this

[00:43] <kelan> liftIO ... [d| (mainCC :: typesig) runComp ...

[00:43] <kelan> but!

[00:43] <kelan> i'm also rather a newb with haskell, and don't know Template Haskell at all, so i may be way off

[00:44] <svnbot6> r3371, mugwump++ | More operator overloading tests (sorry for the flurry of commits)

[00:44] <svnbot6> r3372, theorbtwo++ | More signatures, a few more haddocks.

[00:44] <kelan> er, forgot an equals sign "(mainCC :: typesig) = runComp ..."

[00:47] <theorbtwo> Trying to do it that way makes the impossible happen.

[00:47] <kelan> the impossible?

[00:47] <kelan> sweet

[00:48] <theorbtwo> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4): Failed binder lookup: a{tv a3tU}

[00:48] <kelan> hah

[00:48] <mugwump> er, can't you just put it on another line?  doesn't have to be inline, surely

[00:49] <kelan> how do you specify type signatures for local functions?

[00:50] <kelan> i thought it had to be inline

[00:50] <mugwump> sure, it won't be local any more

[00:50] <kelan> ah:)

[00:50] <mugwump> my haskell fu is weak :)

[00:50] <kelan> mine too

[00:51] <theorbtwo> Mine is weaker.

[00:52] <kelan> well you can make the impossible happen

[00:52] <kelan> that sounds pretty powerful

[00:55] <mugwump> perl makes hard stuff possible, and haskell makes impossible stuff happen.  excellent

[00:57] <meppl> gute nacht

[00:57] <meppl> good night

[00:58] <theorbtwo> G'night, meppl.

[00:58] <theorbtwo> G'localtime, sproingie.

[00:58] <meppl> ;)

[00:58] * sproingie waves

[00:59] <sproingie> hm.  trying to get pugs built on win32.  ghc cant seem to find my platform sdk libs

[01:18] <stevan> mugwump: howdy

[01:18] <stevan> hey theorbtwo (long time no see round here)

[01:18] <mugwump> hi stevan

[01:18] <sproingie> arg arg arg.  how do i make ghc see my platform sdk?

[01:18] <sproingie> gcc: oldnames.lib: No such file or directory

[01:18] <sproingie> gcc: kernel32.lib: No such file or directory

[01:18] <sproingie> gcc: user32.lib: No such file or directory

[01:18] <sproingie> gcc: oldnames.lib: No such file or directory

[01:18] <sproingie> and so on

[01:19] <mugwump> stevan: Is the Tree module usable yet?  I'm wondering about converting Perldoc to pugs

[01:19] <stevan> mugwump: it sure is

[01:19] <stevan> mugwump: it does not follow the Tree::DAG_Node API though

[01:19] <stevan> but it should be able to do all the same opererations

[01:19] <stevan> and if it can't I will add them

[01:20] <mugwump> damn, gender neutral tree navigation is disgustingly PC :)

[01:20] <stevan> you can always alias the methods if it makes you feel better :)

[01:20] <mugwump> ok

[01:21] <stevan> oooh nice operator overloading in Set.pm

[01:21] <mugwump> :)

[01:21] <mugwump> I especially like the E (\x{220b} - member of) operator

[01:21] <stevan> oh

[01:21] <mugwump> a pity none of it works

[01:22] <stevan> I didnt even see that one yet

[01:22] <stevan> oh yeah all infix (or at least most of them)

[01:22] <stevan> but I think autrijus said it was just a prec issue

[01:22] <mugwump> well, now he has lots of tests !  :D

[01:23] <stevan> nice

[01:23] <sproingie> \x{220b}  - member of ?

[01:23] <sproingie> i take it that's the unicode char for the mathematical operator?

[01:23] <stevan> sproingie: it looks like a backwards E

[01:23] <mugwump> unicode... it's a little backwards rounded E

[01:23] <Odin-LAP> That'd return a boolean value, I presume.

[01:24] <mugwump> sure

[01:24] <sproingie> oy.  perl is turning into APL

[01:24] <Odin-LAP> sproingie: Of course. Plenty of those.

[01:24] <Odin-LAP> sproingie: You didn't know?

[01:24] <stevan> sproingie: this is operator overloading, so it is "optional" APL

[01:24] <Odin-LAP> sproingie: "Default" stuff remains latin-1, though.

[01:24] <stevan> mugwump: you need to implement the "hot springs" operator for Set.pm

[01:25] <mugwump> would that be postfix, prefix or infix?

[01:25] <Odin-LAP> ¥ «» <-- So these are the weirdest things you're likely to see... :p

[01:25] <stevan> I dunno, one for each :)

[01:26] <Odin-LAP> Pffth. Isn't there a hammer-and-sickle in Unicode?

[01:26] <sproingie> so who's compiled pugs on win32?  i can't get it to link

[01:26] <mugwump> Odin-LAP: \x{262d}

[01:27] <Odin-LAP> Hmm. "In soviet russia, perl6 codes you!"

[01:27] <stevan> :D

[01:27] <mugwump> ☭

[01:27] <mugwump> :-/

[01:27] <mugwump> don't know if that worked

[01:27] <Odin-LAP> It did.

[01:27] <sproingie> what's the char db name for the codepoint?

[01:28] <sproingie> \U{HAMMER_AND_SICKLE} ?

[01:28] <mugwump> something like that :)

[01:29] <Odin-LAP> U+262D HAMMER AND SICKLE

[01:29] * sproingie looks around for \U{THIRD_REICH_SWASTIKA} (to contrast with the original sanskrit swastika of course)

[01:29] <mugwump> wow ... no swastikas in unicode

[01:30] <mugwump> unless they're called something else

[01:30] <sproingie> probably using a different name

[01:30] <Odin-LAP> Neither are there encircled-As.

[01:30] <Odin-LAP> Politically correct, them folks.

[01:30] <mugwump> this is censorship!  :)

[01:30] <mugwump> they could at least have the backwards facing one

[01:31] <Odin-LAP> 24B6 doesn't count.

[01:31] <mugwump> of course not

[01:31] <Odin-LAP> Meh. There's a building in downtown Reykjavík with a biiiiig swastika (facing the same way as the one NSDAP used).

[01:31] <mugwump> and how am I supposed to write NIN without a backwards N?

[01:32] <Odin-LAP> Indeed.

[01:32] <sproingie> there's a buddhist temple in sf that displays the indian one as well.  it was their symbol before one wacky austrian appropriated it

[01:32] <sproingie> still, they must get a lot of hatemail from ignorant folks

[01:33] <Odin-LAP> Hm.

[01:33] <Odin-LAP> The austrian didn't steal it from them, though.

[01:33] <mugwump> NI\x{202A}N perhaps ?  :)

[01:33] <mugwump> er, NI\x{202B}N

[01:33] * sproingie whines about pugs on win32.  no one?

[01:34] <stevan> sproingie: I think someone was doing a binary distro

[01:34] <mugwump> I wonder if \x{202B} actually reverses the glyphs

[01:34] <Odin-LAP> He took his from old norse religion.

[01:34] <stevan> Jonathan maybe

[01:34] <Odin-LAP> It's a thor's hammer.

[01:34] <puetzk> mugwump: no, it doesn't

[01:34] <sproingie> stevan: meh, not interested in a binary distribution.  just want to figure out how to make the damn link step work

[01:34] <stevan> ah

[01:34] <mugwump> puetzk: even when dealing with arabic letters?

[01:34] <stevan> sorry

[01:35] <puetzk> mugwump: well, they are drawn right to left in the first place :-)

[01:35] <sproingie> tried putting the platform SDK lib in LIBRARY_PATH, didn't seem to work

[01:35] <Odin-LAP> mugwump: They already face the 'right way' don't they?

[01:35] <mugwump> well, there are some languages that reverse direction at the end of each line and write back the other way

[01:35] <mugwump> s/languages/scripts/

[01:36] <mugwump> hence the right-to-left override characters etc in \x{20xx}

[01:36] <Odin-LAP> ℗ <-- Huh. The music industry lobby sure is powerful.

[01:36] <mugwump> what's the codepoint for that, Odin-LAP ?

[01:36] <Odin-LAP> 2117

[01:36] <puetzk> U+2117

[01:37] <mugwump> that's not too bad.  thought it might be a grammophone with a dog or something

[01:37] <Odin-LAP> Well, they have that, but no swastika?

[01:37] <Odin-LAP> The neonazis need better PR...

[01:38] <sproingie> uh

[01:38] <mugwump> they have, it's called GOP

[01:38] <sproingie> *drum fill*

[01:38] <sproingie> i think the conversation godwin'd itself

[01:38] <puetzk> oh, it's in there

[01:38] <puetzk> U+534D and U+5350

[01:39] <Odin-LAP> Ⓐ <-- Just by accident, they provide one of those. Not good enough, though! :(

[01:40] <Odin-LAP> Ooooh. Neat.

[01:40] <Odin-LAP> No slanted version, though.

[01:40] <mugwump> cdcd

[01:40] <puetzk> since chinese uses it

[01:40] <mugwump> doh

[01:41] <mugwump> Definition: swastika fourth of auspicious

[01:42] <mugwump> babelfish doesn't want to translate that

[01:42] * sproingie wonders what would happen if he just took out all those redundant libs in the win32 makefile

[01:43] <sproingie> i have a hard time believing that pugs needs odbc32.lib for instance

[01:43] <puetzk> sproingie: wouldn't surprise me too much; if you use anything COM you pick that up

[01:43] <puetzk> and a lot of windows APIs are COM

[01:43] <sproingie> yeacch

[01:44] <sproingie> ok fine, then how the hell does one actually link pugs

[01:44] <puetzk> well, not *anything* COM I guess, but anything IDispatch

[01:44] <sproingie> make process is absolutely busted as far as i can see

[01:44] * sproingie is starting to run out of patience with ghc

[01:51] <sproingie> tch.  it's parrot embedding that breaks it

[01:51] <svnbot6> r3373, Stevan++ | Perl::MetaModel - findMethod and invokeMethod methods coded and tested (and an isMethodSupported too); Smalltalk Meta-Model++

[01:52] <kelan> well you only need that if you want rule support

[01:52] <kelan> ditch it!

[01:52] <sproingie> aren't rules kind of important

[01:53] <kelan> hah, thats what they want you to believe

[01:53] <kelan> ditch it!

[01:54] <mugwump> I think a lot of authors will use rx:perl5/.../ for a while yet

[01:55] <mugwump> should be rx:pcre/.../ really

[01:55] <sproingie> so rules are considered more or less experimental ?

[01:56] <mugwump> PGE is still pretty alpha AFAIK

[01:57] <sproingie> apparently quite broken on win32 it would seem

[01:57] <sproingie> or could have a simpler explanation.  my parrot tree looks broken

[02:00] <sproingie> rules are like the #1 thing about perl6 for me.  behooves me to buiild 'em

[02:02] <mugwump> well, you could try the pugs live CD :)

[02:03] <sproingie> egad.  i'd just as well boot linux

[02:03] <sproingie> which i'll probably do once fedora 4 comes out of test

[02:04] <mugwump> Does PxPerl not come with Parrot?

[02:05] <sproingie> was running ubuntu, but got burned by old packages for ghc and pgsql, and the very-often-broken unstable version

[02:05] <sproingie> that and i don't consider a chroot to be 32 bit support

[02:05] <sproingie> so once fedora 4's out, i'll do my pugs stuff on it

[02:05] <mugwump> you on amd64?

[02:05] <sproingie> yep

[02:07] <mugwump> tried SuSE?  if you want a 'proper' 32/64-bit environment, theirs is probably the best

[02:07] <sproingie> eh, it's pricey

[02:07] <mugwump> you want it all!

[02:07] <sproingie> fedora's is supposed to be pretty much side-by-side too

[02:07] <mugwump> ok

[02:09] <kelan> what ghc does pugs need now, 6.4?

[02:09] <sproingie> yep

[02:09] <kelan> debian has ghc 6.4 for amd64

[02:10] <sproingie> last i looked, in experimental

[02:10] <kelan> not sure how debians amd64 support is in general tho

[02:10] <sproingie> beware of the leopard

[02:10] <kelan> in unstable now

[02:10] <kelan> leopard?

[02:10] <sproingie> kelan: debian's is pretty nonexistent, it's all "unofficial".  ubuntu's is fine, but the only thing tracking unstable is breezy

[02:10] <sproingie> and breezy just breaks massively

[02:11] <sproingie> kelan: in a locked filing cabinet in a disused lavatory with a sign on the door saying "beware of the leopard"

[02:11] <sproingie> hhgtg reference

[02:11] <kelan> ah

[02:11] <sproingie> ubuntu's 64 bit support is fabulous.  its idea of 32 bit support is "go run a chroot"

[02:15] <sproingie> rebuilt parrot, rebuilt pugs, still broken with PUGS_EMBED=parrot

[02:15] <sproingie> bah

[02:15] <kelan> ditch it!

[02:15] <kelan> okay, i'll stop saying that now

[02:16] <sproingie> meanwhile i have charming artifacts on the build commandline like -L\usr\local\lib

[03:23] <svnbot6> r3374, Stevan++ | Perl::MetaModel - isPropertySupported method coded, needs tests

[03:33] <putter> fyi, folks attempting to use pugs on amd64 should read the pugs README (and perhaps let me know if it still doesn't work;)

[04:42] <svnbot6> r3375, putter++ | t/rules/from_perl6_rules/named_cap.t un-Disabled.

[04:50] <svnbot6> r3376, putter++ | Un-Disabled some t/rules/from_perl6_rules/ tests.

[05:07] <svnbot6> r3377, putter++ | Tweaked t/rules/Disabled/from_perl6_rules/stdrules.t.  It no longer Errors, but it still hangs unembedded parrot.

[05:16] <svnbot6> r3378, putter++ | eval_ok()ed some tests in t/rules/Disabled/from_perl6_rules/assert.t.  It is still disabled only because it hangs external parrot.

[05:38] <svnbot6> r3379, mugwump++ | Make MetaProperty test use less 'foo' and more 'real-world' examples

[05:45] <crysflame> someone++ # karma for commits

[05:45] <svnbot6> r3380, putter++ | UnDisabled t/rules/from_perl6_rules/prior.t.

[06:01] <mugwump> stevan: I just read through tests 10-12, will look at 20-40 another day

[06:01] <svnbot6> r3381, mugwump++ | Make MetaMethod test use less 'foo' and more 'real-world' examples - untested

[06:01] <svnbot6> r3382, putter++ | Commented out some parsefails in t/rules/Disabled/from_perl6_rules/subrule.t.  It is left disabled only because it seems to hang when used with external parrot.

[06:01] <mugwump> (in Perl::MetaModel)

[06:01] * mugwump & # flathunting time

[06:27] <nothingmuch> morning

[06:31] *** crysflame is now known as floatingatoll

[06:33] *** floatingatoll is now known as crysflame

[06:34] <autrijus> when sproingie shows up next time, we need to tell him that external parrot can do rules just as well

[06:36] <autrijus> \camel -> rehi

[06:36] <nothingmuch> hola autrijus 

[06:36] <nothingmuch> did you get my spam from yesterday?

[06:37] <autrijus> yes

[06:38] <autrijus> something like http://autrijus.org/svk-overview.png ?

[06:38] <autrijus> sure, I'd be happy to do an interview with you :D

[06:38] <autrijus> but I need to run. I'll be back in a hour or so

[06:40] <nothingmuch> okay, i'll be here

[06:40] <nothingmuch> ping me when you feel like it

[06:40] <autrijus> danke

[06:40] <autrijus> &

[06:49] *** chady_ is now known as chady

[06:54] <wilx> Whoa, nice pic.

[06:54] <wilx> What tool is it drawn in?

[06:55] <nothingmuch> the icons look kde-esque

[06:57] <nothingmuch> maybe it's this: http://www.koffice.org/kivio/

[07:17] *** castaway_ is now known as castaway

[08:02] <autrijus> nothingmuch: it's Nuvola

[08:02] <autrijus> and I'm back :)

[08:03] <nothingmuch> i need 10 minutes or so, and then we'll get to it =)

[08:03] <autrijus> sure :)

[08:04] * nothingmuch is actually having fun reading C+=1

[08:04] <autrijus> C+=1?

[08:04] <autrijus> C++?

[08:04] <nothingmuch> yeah, but without the karma =)

[08:05] <autrijus> heh

[08:05] <nothingmuch> this is relative to the code i've been reading yesterday

[08:05] <nothingmuch> void function (

[08:05] <nothingmuch> #ifdef _SOME_DEF

[08:05] <nothingmuch> param

[08:05] <nothingmuch> / other_param

[08:05] <nothingmuch> that was a '//'

[08:05] <nothingmuch> #endif

[08:06] <nothingmuch> third param

[08:06] <nothingmuch> );

[08:06] <nothingmuch> that was how most functions were both called, and defined

[08:06] <nothingmuch> *sigh*

[08:06] <autrijus> I think I've seen code like this somewhere

[08:06] <autrijus> ahh. nethack.

[08:07] <nothingmuch> nethack is in C++?

[08:07] <autrijus> no, in C, but it likes to use #ifdef too

[08:07] <autrijus> #ifndef WIZARD

[08:07] <autrijus> #  ifndef KR1ED

[08:07] <autrijus> etc

[08:08] <nothingmuch> but this code is C++

[08:08] <nothingmuch> i guess you could #ifdef _SOME_DEF / #define OPTIONAL x x / #else / #define  OPTIONAL x /* */

[08:08] <nothingmuch> it really should be instance data, not paramters

[08:08] * autrijus mumbles something about C-style macros and safety

[08:08] <nothingmuch> this is the EEK (AOP's EEK) at it's worst

[08:08] <autrijus> not saying that String->String source filter is better.

[08:08] <autrijus> EEK?

[08:08] <nothingmuch> extreneous embedded knowlege

[08:09] <Gruber> hmm

[08:09] <Gruber> tobez@hrum src/pugs> ./pugs -e '"x" ~~ m/y/;'

[08:09] <Gruber> tobez@hrum src/pugs> echo '"x" ~~ m/y/;' | ./pugs

[08:09] <Gruber> Parrot IO: Failed init layer(unix).

[08:09] <Gruber> zsh: 16506 done       echo '"x" ~~ m/y/;' | 

[08:09] <Gruber> zsh: 16507 exit 65    ./pugs

[08:09] <nothingmuch> http://www.perl.org.il/YAPC/2004/talk.html?id=24

[08:13] <autrijus> Gruber: ./pugs -

[08:13] <autrijus> hm, still not working

[08:13] <Gruber> strange, eh?

[08:13] <autrijus> indeed

[08:14] <Gruber> an isatty() somewhere must be a culprit from the looks of it

[08:14] <autrijus> line 88

[08:14] <autrijus> Main.hs

[08:14] <autrijus>     isTTY <- hIsTerminalDevice stdin

[08:14] <autrijus> does the additional "-" workforyou?

[08:14] <Gruber> nope

[08:14] <nothingmuch> okay, lets start

[08:15] <autrijus> nothingmuch: cool. fire away

[08:15] * autrijus opens up a window for haddock

[08:15] <autrijus> # http://pugscode.org/haddock/

[08:15] <nothingmuch> as you requested, my smoke result also has haddock

[08:15] <nothingmuch> http://nothingmuch.woobling.org/pugs_test_status/haddock/

[08:15] <nothingmuch> now we only need to link that in =)

[08:16] <autrijus> done.

[08:16] <nothingmuch> no, i meant link like the tests link to synopses

[08:16] <autrijus> "API documentation" in pugscode.org now links to you :)

[08:16] <autrijus> oh. :)

[08:16] <nothingmuch> =)

[08:16] <autrijus> anyway.

[08:17] <nothingmuch> we can probably pull off test -> haddock easily

[08:17] <nothingmuch> but i think haddock -> synopsis is more interesting

[08:17] <nothingmuch> so

[08:17] <nothingmuch> at the core we have src/Pugs

[08:17] <nothingmuch> lets ignore that for now

[08:17] <nothingmuch> it has external deps:

[08:17] <nothingmuch> Parrot (optional)

[08:18] <autrijus> hs-plugins (optional)

[08:18] <nothingmuch> Data.Yaml.Syck (supplied)

[08:18] <nothingmuch> be parrot and provide rules

[08:18] <nothingmuch> Unicode (Supplied)

[08:18] <nothingmuch> provide eval_yaml

[08:18] <nothingmuch> RRegex (supplied)

[08:18] <nothingmuch> provide rx:p5

[08:18] <autrijus> libperl (optional, possibly bitrotten)

[08:18] <nothingmuch> the jobs of these components respectively are:

[08:19] <nothingmuch> okay

[08:19] <nothingmuch> i see this as a star

[08:19] <nothingmuch> pugs at the center, these around it

[08:19] <autrijus> yes

[08:19] <nothingmuch> name + optional purpose

[08:20] <nothingmuch> parrot also has a sub component, PGE

[08:20] <nothingmuch> okay, so lets begin with pugs

[08:20] <nothingmuch> from the simple

[08:20] <nothingmuch> no, top down via haddock

[08:20] <nothingmuch> that way we won't miss anything

[08:20] <autrijus> k

[08:20] <nothingmuch> oh, i forgot IMC

[08:20] <autrijus> forget it :)

[08:20] <nothingmuch> heh

[08:21] <autrijus> the IMC thing won't be reactivated until next month

[08:21] <autrijus> for the grand codegen rewrite

[08:21] <nothingmuch> okay

[08:21] <nothingmuch> so lets dissect AST

[08:21] <autrijus> ok. AST is the core of Pugs

[08:22] <nothingmuch> an instance of an AST is a parsed perl 6 program

[08:22] <nothingmuch> AST provides the means to execute it, right?

[08:22] <autrijus> start from AST.Internals

[08:22] <autrijus> which is the core of core of Pugs

[08:22] <nothingmuch> does the AST ask the parser to build it? or vice versa?

[08:23] <autrijus> ok, it goes like this

[08:23] <nothingmuch> i see in internals the various things you can do to perl data

[08:23] <nothingmuch> perl internal data

[08:23] <autrijus> 1. Main.hs

[08:23] <autrijus> your program enters there

[08:23] <nothingmuch> as well as the env monads

[08:23] <autrijus> it's a simple String

[08:23] <autrijus> 2. Run.hs

[08:23] <autrijus> that string is passed to runEnv

[08:24] <autrijus> er, no, sorry

[08:24] <autrijus> 2. Parser.hs

[08:24] <autrijus> that string is passed to runRule

[08:24] <autrijus> Parser turns the String into an Env

[08:24] <nothingmuch> pause

[08:24] <autrijus> ok

[08:24] <nothingmuch> what exactly is an env?

[08:24] <autrijus> see haddock

[08:24] <nothingmuch> is it a sort of lexical entity in the program?

[08:24] <autrijus> "Evaluation environment."

[08:25] <autrijus> it's the interpreter state

[08:25] <autrijus> everything is in it

[08:25] <nothingmuch> oh, the whole thing

[08:25] <autrijus> right

[08:25] <nothingmuch> so it is basically "the program"

[08:25] <autrijus> yes.

[08:25] <autrijus> note that by the time Env is built by Parser

[08:25] <autrijus> all BEGIN block has been executed

[08:25] <autrijus> so we are at the start fo runtime

[08:26] <autrijus> I was going to talk about the BEGIN thing :)

[08:26] <nothingmuch> okay

[08:26] <nothingmuch> lets =)

[08:26] <autrijus> ok. so Parser gets a String

[08:26] <autrijus> and start parsing it

[08:26] <autrijus> the Parser also gets an initial environment

[08:26] <autrijus> created with prepareEnv in Run.hs

[08:27] <autrijus> which contains @*INC %*ENV and all primitves

[08:27] <autrijus> the Parser works by constructing an Exp

[08:27] <autrijus> which is the abstracted syntax tree of a Perl 6 program

[08:27] <autrijus> (Exp stands for "expression")

[08:27] <autrijus> from the String

[08:27] <autrijus> but when the Parser sees a BEGIN block (or equivalent)

[08:27] <autrijus> (such as `use Foo;` and `sub blah {...}`)

[08:27] <autrijus> then it pauses parsing

[08:28] <autrijus> and launch into the evaluator

[08:28] <autrijus> Eval.hs

[08:28] <nothingmuch> okay

[08:28] <nothingmuch> one sec, sharpenning pencil

[08:28] <autrijus> right ther using the partially constructed Env

[08:28] <autrijus> sure

[08:28] <nothingmuch> wait,

[08:28] <nothingmuch> it constructs the Exp tree

[08:28] <autrijus> yes, but it also keeps a Env as state

[08:28] <nothingmuch> when it finishes a BEGIN, it takes the BEGIN's Exp and eval's it immediately?

[08:28] <autrijus> that's the idea, yes

[08:28] <nothingmuch> a Env or the Env?

[08:29] <autrijus> well, it starts off with the initial Env

[08:29] <autrijus> then during parsing, from time to time, it modifie sthe Env

[08:29] <autrijus> the final return value of Parser is Env

[08:29] <autrijus> _not_ Exp

[08:29] <autrijus> ruleProgram :: RuleParser Env

[08:29] <nothingmuch> which contains Exps

[08:29] <autrijus> the parsed Exp is there as envBody

[08:29] <autrijus> exactly.

[08:29] <nothingmuch> it does the haskell record modifying shenanigan, right?

[08:29] <autrijus> right.

[08:30] <nothingmuch> so it's a env

[08:30] <nothingmuch> but all the derived envs are thrown away

[08:30] <autrijus> a mutable one, yes.

[08:30] <autrijus> let's just say it incrementally builds the Env along with the Exp.

[08:30] <nothingmuch> right

[08:30] <autrijus> 3. Eval.hs

[08:30] <autrijus> when Parser seens BEGIN

[08:30] <nothingmuch> what do BEGIN blocks boil down to?

[08:30] <nothingmuch> an Exp with the return value?

[08:30] <autrijus> it launches into unsafeEvalExp

[08:31] <autrijus> yes.

[08:31] <autrijus> BEGIN blocks is just a Exp

[08:31] <nothingmuch> why unsafe?

[08:31] <autrijus> an Exp can be reduced to a Val

[08:31] <autrijus> nothingmuch: because it involves unsafePerformIO

[08:31] <autrijus> (the parser is supposed to be pure)

[08:31] <nothingmuch> because it does a sideffectful action inside the parsing, which isn't?

[08:31] <nothingmuch> oh, right

[08:31] <autrijus> yes.

[08:31] <nothingmuch> i forgot Exps can do IO

[08:31] <autrijus> if you do a rand() inside BEGIN

[08:32] <autrijus> then there's no guarantee that your parse tree will be identical

[08:32] <nothingmuch> the universe splits up?

[08:32] <nothingmuch> oh,

[08:32] <autrijus> heh :)

[08:32] <autrijus> so it's unsafe from the haskell meaning

[08:32] <autrijus> but perl6 is unsafe like that. so we deal

[08:32] <autrijus> anyway. so BEGIN {...} is an Exp that is the parsed stuff from ...

[08:33] <autrijus> each Env knows how to eval itself

[08:33] <autrijus>     envEval :: !(Exp -> Eval Val)

[08:33] <nothingmuch> brb

[08:33] <autrijus> this currently always binds to "evaluate" in Eval.hs

[08:34] <autrijus> -- | Evaluate an expression. This function mostly just delegates to 'reduce'.

[08:34] <autrijus> evaluate :: Exp -- ^ The expression to evaluate -> Eval Val

[08:34] <autrijus> er

[08:34] <autrijus> evaluate :: Exp -> Eval Val

[08:34] * castaway wonders what history is currently being made..

[08:34] <castaway> mornin, for any to whom that applies

[08:35] <autrijus> greetings castaway.

[08:35] <castaway> hiho, hows tricks?

[08:36] <autrijus> just fine. nothingmuch is interviewing me because it looks like he to help writing PA02 :)

[08:36] <autrijus> s/he to/he wants to/

[08:36] <castaway> Ah, Ok

[08:36] <nothingmuch>  okay, back

[08:36] * castaway sits back and watches ,)

[08:36] <autrijus> so. we see a

[08:37] <autrijus> BEGIN { print "compiling!" }

[08:37] <nothingmuch> what happens with nested begins?

[08:37] <nothingmuch> as early as possible?

[08:37] <autrijus> it does what you think it does :)

[08:37] <autrijus> yeah, just like p5.

[08:37] <nothingmuch> or are they considered as a boolean state

[08:37] <autrijus> no, as early as possible

[08:37] <autrijus> all BEGINs are fully evaluated as soon as they are parsed.

[08:37] <autrijus> even nested ones.

[08:38] <autrijus> so with

[08:38] <autrijus>  BEGIN { print "compiling!" }

[08:38] <nothingmuch> if in any begin we are compiling

[08:38] <nothingmuch> okay

[08:38] <autrijus> we have an Exp

[08:38] <autrijus> App &print ('compiling!')

[08:38] <nothingmuch> hola castaway 

[08:38] <autrijus> (using the Pretty form)

[08:38] <autrijus> instead of the Haskell form which is

[08:38] <nothingmuch> how is it marked as a BEGIN exp?

[08:38] * castaway ruffles nothingmuch 

[08:38] <nothingmuch> is this notation set in the parser?

[08:38] <autrijus> App (Var "&print") [Val (VStr "compiling!")] []

[08:38] <nothingmuch> or does the Exp know about itself being that way?

[08:39] <autrijus> nothingmuch: what notation?

[08:39] <autrijus> it is not marked as a BEGIN exp

[08:39] <nothingmuch> that something needs to happen at  compile time

[08:39] <nothingmuch> so the parser sees the BEGIN { }

[08:39] <autrijus> then the Parser runs the evaluator

[08:39] <autrijus> right there

[08:39] <nothingmuch> takes the exp, from {}

[08:39] <nothingmuch> and because this was BEGIN evals the {}

[08:39] <autrijus> yes.

[08:39] <autrijus> line 573

[08:39] <nothingmuch> so it's sort of like a block modifyer

[08:39] <nothingmuch> okay

[08:39] <autrijus>         "BEGIN" -> do

[08:39] <autrijus>             rv <- unsafeEvalExp fun

[08:39] <autrijus>             return $ if rhs then rv else emptyExp

[08:40] <autrijus> in Parser.hs

[08:40] <autrijus> ok. so we are in the evaluator now

[08:40] <autrijus> the Env used by evaluator is the partially constructed one fro Parser

[08:40] <autrijus> because we had not finished parsing

[08:41] <autrijus> in Eval.hs, the evaluator case-analyzes the incoming Exp

[08:41] <autrijus> see it's an App

[08:41] <nothingmuch> is there a distinction between a partial and finished env?

[08:41] <autrijus> nothingmuch: it's not marked in the structure, so I'd say no

[08:41] <autrijus> I say "partial" only because there's still parts of program being parsed

[08:41] <nothingmuch> okay, so a partial env is completely functional

[08:41] <nothingmuch> are the unparsed parts of the program inside the env/

[08:42] <nothingmuch> like,

[08:42] <nothingmuch>  is the string expanded (metaphoricaly) in place, within the env?

[08:42] <autrijus> no, they are not.

[08:42] <nothingmuch> okay

[08:42] <autrijus> the Eval.hs at this point knows nothing of the remainder of program

[08:42] <autrijus> if any

[08:42] <nothingmuch> how do incompeltee exps look like?

[08:42] <autrijus> I guess we need to assign the $?COMPILING var

[08:42] <autrijus> there are no incomplete exps ;)

[08:42] <autrijus> all exps are complete by definition.

[08:43] <nothingmuch> is it accessible via envBody?

[08:43] <nothingmuch> so where does the begin exp exist

[08:43] <nothingmuch> if it's parent have not yet finished parsing?

[08:43] <autrijus> so it's not in envBody

[08:43] <Gruber> autrijus: in parrot, io/io_unix.c, fcntl(fd, F_GETFL, 0) for stdin returns EBADF in the case above, so it looks like pugs closes stdin at some point

[08:43] <autrijus> look at line 602

[08:43] <autrijus> Parser.hs

[08:43] <autrijus> Gruber: ahh. that explains

[08:44] <autrijus> Gruber: I wonder how to read everything from stdin without closing it

[08:44] <autrijus> asking on #haskell now

[08:44] <Gruber> any way to just leave it at eof?

[08:44] <autrijus> asking :)

[08:44] <Gruber> heh

[08:45] <autrijus> how would you normally do that? read 4k bytes until eof?

[08:45] <autrijus> nothingmuch: you'll see that the evaluator is invoked directly 

[08:45] <autrijus> nothingmuch: the evaluator is basically

[08:45] <autrijus> Exp -> Eval Val

[08:45] <nothingmuch> ah

[08:45] <Gruber> autrijus: in perl5 while (<STDIN>)  :-)

[08:45] <nothingmuch> and env typically has an embedded evaluator that belongs to it?

[08:46] <autrijus> Gruber: I don't want linebased

[08:46] <autrijus> which means that it takes Exp, and evaluates it in the context of Env, into a Val

[08:46] <autrijus> nothingmuch: yes. always

[08:46] <Gruber> read chunks until sysread returns 0 or undef

[08:46] <Gruber> again, in perl5 therminology

[08:47] <nothingmuch> in that case $\ = 4 * 2 ** 10;

[08:47] <nothingmuch> err, ref

[08:47] <nothingmuch> or better yet, the blksize you get from stat on the handle

[08:48] <nothingmuch> okay, i see

[08:48] <nothingmuch> { my $var; BEGIN { $OUTER::var } };

[08:48] <nothingmuch> does that make any sense?

[08:49] <nothingmuch> can a begin block be a closure at all?

[08:50] <autrijus> Gruber: ok, I tried a fix. committing

[08:51] <autrijus> nothingmuch: you don't need the OUTER

[08:52] <autrijus> pugs> my $var; say BEGIN { $var = 5 }; say $var;

[08:52] <autrijus> 5

[08:52] <nothingmuch> autrijus: imagine a scenario where i did

[08:52] <nothingmuch> more lexical scopes maybe

[08:53] <autrijus> nothingmuch: the lexical scope is part of Env

[08:53] <autrijus> as envLexical

[08:53] <autrijus> of course the Exp being evaluated sees the envLexical.

[08:53] <nothingmuch> ooh, lunch

[08:53] <nothingmuch> bbiab

[08:53] <nothingmuch> okay

[08:53] <nothingmuch> envLexical is what, exactly?

[08:53] <nothingmuch> the current scope being parsed and/or eval'ed?

[08:53] <svnbot6> r3383, autrijus++ | * Gruber reports that getContents was closing stdin, rendering

[08:53] <svnbot6> r3383, autrijus++ |     echo '"x" ~~ /y/' | ./pugs -

[08:53] <svnbot6> r3383, autrijus++ |   unusable.  Fixed.

[08:53] <autrijus> it is all symbols visible from your lexical space.

[08:54] <autrijus> it is a Pad

[08:54] <autrijus> A Pad keeps track of the names of all currently-bound symbols, and associates them with the things they actually represent.

[08:54] <autrijus> It is represented as a mapping from names to lists of bound items. This is to allow for multi subs, because we will need to keep multiple subs associated with one symbol. In other cases, the list should just contain a single value. See genSym and genMultiSym for more details.

[08:54] <autrijus> TVar indicates that the mapped-to items are STM transactional variables. 

[08:54] <autrijus> (from haddock)

[08:54] *** decay__ is now known as decay_

[08:55] <nothingmuch> ok, gotta go

[08:55] <nothingmuch> bbsoon

[08:55] <autrijus> k

[08:56] * autrijus discovers that Pugs is larger than it looks

[08:57] <autrijus> we're up to 12k lines... but more than half is documentation I think

[08:57] <autrijus> still, 6klines is large :)

[09:01] <castaway> doesnt sound all that huge to me.. (for what it does, it sounds pretty compact)

[09:02] <autrijus> seen in #debian-devel:

[09:02] <jabbot> autrijus: I havn't seen in , autrijus

[09:02] <autrijus> <trave11er> dilinger: i cannot trust people who can write a 100+ line haskell program :-)

[09:02] <autrijus> <trave11er> that's almost a legal definition of insanity

[09:03] <castaway> heh

[09:03] <autrijus> fwiw, I consider 6klines of perl huge, too

[09:03] * castaway checks

[09:03] <luqui> and 6k lines of Java small ;-)

[09:04] <autrijus> right :)

[09:04] <autrijus> I think for <100 lines range, perl is usually more compact than haskell

[09:04] <autrijus> but after that haskell is far more concise :)

[09:04] * autrijus wonders how good perl6's abstractions will improve this

[09:04] <castaway> hmm, 6k in one file is certainly a lot..

[09:05] <castaway> I have several in the 1k-4k range

[09:05] <castaway> and probably adding various modules used for one program together would get me near 10..

[09:08] <Gruber> autrijus: works, thanks!

[09:09] <autrijus> Gruber: woot!

[09:09] <autrijus> Gruber++

[09:09] * autrijus praises the "bugs are shallow" effect

[09:09] <autrijus> I'll bbiab

[09:38] * autrijus ponders a "Building a cross-language community" for euro oscon

[09:39] <autrijus> hm, maybe 45min talk 

[09:41] <autrijus> hm,  require 'open-uri' is clever

[09:42] <autrijus> it's somewhat like "use IO::All::LWP" but with a saner name :)

[09:42] <kolibrie> did you post your 'learning parsec' paper anywhere public?

[09:42] <autrijus> do I have this paper?

[09:43] <kolibrie> I thought you submitted something for OSCON

[09:43] <autrijus> no, for euro oscon

[09:43] <autrijus> and it won't be due until Sep 5

[09:43] <autrijus> so I'll start writing at Sep 5 :)

[09:43] <kolibrie> ah

[09:43] <autrijus> and it's "Learning Haskell"

[09:43] <autrijus> and it's probably slides, not a paper

[09:44] <kolibrie> I'm intregued

[09:44] <autrijus> I still have to submit my Haskell Workshop paper about using GADT, STM and TH to implement a real language :)

[09:44] <autrijus> (which is due in a couple of weeks)

[09:45] <autrijus> not sure if it's "Lambdas in the Camel land" or "Camels in the Lambda land"

[09:46] <kolibrie> or some of both

[09:47] <autrijus> Camelambda?

[09:47] <kolibrie> that's nice

[09:47] <kolibrie> but I like lambdacamels, too

[09:48] <kolibrie> lambdacamels in the camelamda land

[09:50] <autrijus> "Lambdas in the Camel land: Building Perl 6 with GADT, STM, and Template Haskell"

[09:50] <autrijus> probably good enough for the first cut

[09:50] <castaway> sounds good

[09:51] <kolibrie> I like it

[09:52] <autrijus> :) bbiab &

[09:53] *** Belial- is now known as Belial

[09:53] *** Belial is now known as Belial-

[10:17] <kungfuftr> anyone know where there's a Tk perl regexp gui thing? (i found one a while back but lost the url)

[10:18] <autrijus> kungfuftr: http://perl.plover.com/Rx/paper/ ?

[10:19] <autrijus> it may be horribly bitrotten; Komodo has a newer version of it

[10:19] <kungfuftr> autrijus: yeah, i would use RxToolkit in komodo (since i get it for free) but it's a hassle to get it installed on our development boxes

[10:23] <kungfuftr> autrijus: ah, wasn't really a debugger i was after tho

[10:26] <castaway> hey kungfuftr 

[10:27] <kungfuftr> lo

[10:28] <castaway> that sounds like a useful tool

[10:28] <castaway> (whatever it does)

[10:28] * castaway gets an email from Sophos HR ,)

[10:29] <castaway> Hmm, and she cant read her calendar.. "Thursday 24th May"?

[10:32] <nothingmuch> wow, what a lunch

[10:33] <nothingmuch> autrijus.resume

[10:33] <autrijus> nothingmuch: yes?

[10:33] <autrijus> where were we

[10:34] <autrijus> ah. envLexical

[10:34] <autrijus> so yes. Parser keeps track of the visible symbols in the Env's envLexical Pad

[10:35] <autrijus> and reverts to old envLexical whenever we're done parsing a block

[10:35] <autrijus> line 77, Parser.hs, ruleBlockBody

[10:35] <nothingmuch> okay

[10:35] <nothingmuch> one second

[10:35] <nothingmuch> what is envLexical - a sort of stack head of sorts?

[10:35] <autrijus> it's a Map

[10:35] <nothingmuch> no, not the impl detail

[10:35] <autrijus> it's a map from name to symbols.

[10:35] <nothingmuch> you have a stack of envLexicals

[10:36] <autrijus> I don't.

[10:36] <autrijus> I have amap.

[10:36] <nothingmuch> the parser pushes more envs

[10:36] <nothingmuch> (hypothetically)

[10:36] <autrijus> it's not pushed or popped

[10:36] <autrijus> it's more like a hash.

[10:36] <nothingmuch> so keys are removed?

[10:36] <autrijus> yes.

[10:36] <autrijus> if you do

[10:36] <autrijus> my $foo = ...

[10:36] <autrijus> {

[10:36] <autrijus>    my $foo = ..

[10:36] <autrijus> }

[10:36] <nothingmuch> how does each exp know what it's lexical env looks like?

[10:36] <autrijus> the inner $foo overwrites the outer.

[10:36] <autrijus> well, it doesn't. that's what the env provides

[10:36] <nothingmuch> how is this rolled back? iwith a stackish metaphor?

[10:37] <autrijus> an Exp is just a expression

[10:37] <autrijus> it's rolled back by resetting to old lexical on block exit.

[10:37] <nothingmuch> given exp { my $foo = 1; { $foo ++; my $bar = $foo; } }

[10:37] <nothingmuch> old lexical scopes are kept in a metaphor for a stack?

[10:37] <autrijus> the map is still destroyed

[10:37] <autrijus> no.

[10:37] <autrijus> the storage remains

[10:37] <autrijus> the thing that is mapped to remains

[10:38] <autrijus> but the map is destroyed forever

[10:38] <autrijus> (unless you take a closure.)

[10:38] <autrijus> when you take a closure, the closure remembers the pad

[10:38] <nothingmuch> backup a bit

[10:38] <autrijus> k

[10:38] <nothingmuch> in the the whole program AST is an env

[10:38] <nothingmuch> this env contains a tree of Expr

[10:38] <autrijus> er, no, the AST is the Expr

[10:38] <nothingmuch> and the data these Expr use

[10:38] <autrijus> we have a Env that contains AST among other things

[10:38] <nothingmuch> okay

[10:39] <autrijus> the Exp may look like

[10:39] <autrijus> (App (Var "&say") [(Var "$x")] [])

[10:39] <autrijus> which is

[10:39] <autrijus> $x.say

[10:39] <nothingmuch> apply method say to var x?

[10:39] <autrijus> but it knows nothing about what &say and $x is bound to.

[10:39] <autrijus> yeah

[10:39] <autrijus> or rather, apply the function bound to &say variable

[10:39] <autrijus> with the $x variable as the only and first invocant

[10:40] <nothingmuch> okay

[10:40] <nothingmuch> the thing that expands the Var things does the lookups, right?

[10:40] <nothingmuch> right

[10:40] <nothingmuch> okay

[10:40] <nothingmuch> it's how we get the proper thing into envLexical

[10:40] <nothingmuch> so where do we look for them?

[10:40] <nothingmuch> for this particular Exp

[10:40] <nothingmuch> the answer i'm looking for is not envLexical

[10:40] <autrijus> the Exp doesn't even know where to look

[10:40] <autrijus> it's just a piece of data

[10:40] <nothingmuch> rephrase:

[10:40] <autrijus> the thing that looks for them is the evaluator

[10:40] <autrijus> in Eval.hs

[10:41] <nothingmuch> the evaluator working in the context of an Exp

[10:41] <nothingmuch> okay

[10:41] <autrijus> you can think of the evaluator as an object

[10:41] <autrijus> with an internal "state" of a Env

[10:41] <autrijus> and a method called "evaluate"

[10:41] <autrijus> where it accepts a Exp and gives you back a Val.

[10:41] <nothingmuch> (the thing the Exp reduced to?)

[10:41] <autrijus> yes.

[10:41] <autrijus> in the $x.say case, it gives back a bool::true

[10:42] <nothingmuch> (does evaluate get an Exp + Context?)

[10:42] <autrijus> and as a side effects, prints something.

[10:42] <autrijus> no, it just gets Exp.

[10:42] <nothingmuch> okay

[10:42] <autrijus> the Context is also in the Env.

[10:42] <autrijus> the Exp may explicitly requiest a context by using the Cxt node.

[10:42] <nothingmuch> oh, i think i'm starting to grok

[10:42] <nothingmuch> let me try then:

[10:42] <nothingmuch> the evaluator traverses the Exp tree

[10:42] <nothingmuch> reducing as necessary

[10:43] <nothingmuch> upon entering an Exp, if applicable a new lexical scope is provided

[10:43] <nothingmuch> and fused with the dynamic scope?

[10:43] <nothingmuch>  the new lexical scope is created by ...

[10:44] <nothingmuch> ... how do we know what OUTER:: is? CALLER:: is simpler for me to imagine, but i don't see how OUTER:: fits in without it being inside parent Exps

[10:44] <autrijus> the easy answer is that, we don't have support for OUTER:: under this scheme.

[10:44] <autrijus> since it's just a Map, not a [Map].

[10:44] <autrijus> needs refactoring :)

[10:44] <autrijus> (pugs has no OUTER support.)

[10:44] <autrijus> (yet.)

[10:45] <autrijus> but were we to implement that

[10:45] <autrijus> the Pad will be a list of Map

[10:45] <nothingmuch> so we are going to switch to a stack metaphor?

[10:45] <autrijus> and whenever a new block is entered, the list is pushed

[10:45] <autrijus> and when it's out, it's popped.

[10:45] <autrijus> yes.

[10:45] <nothingmuch> okay

[10:45] <nothingmuch> so for the dynamic scope a new empty map is added

[10:45] <autrijus> hm?

[10:45] <nothingmuch> and for the lexical scope the correct map is fetched and also pushed

[10:45] <autrijus> yup

[10:46] <nothingmuch> temp $foo

[10:46] <autrijus> when you call another function

[10:46] <nothingmuch> okay

[10:46] <autrijus> then the current envLexical is dropped

[10:46] <autrijus> and the function's own subPad resumes

[10:46] <autrijus> as the envLexical

[10:46] <nothingmuch> and the global pad is another stack

[10:46] <nothingmuch> okay

[10:46] <autrijus> yes. it's different because it's a pointer to a stack

[10:46] <nothingmuch> so right now, how is envLexical produced?

[10:46] <autrijus> so you can freely modify it

[10:46] <autrijus> envLexical is initially empty

[10:46] <autrijus> when you declare a variable

[10:46] <autrijus> my $foo

[10:46] <autrijus> the parser sees it

[10:47] <autrijus> parses it as

[10:47] <autrijus> (Sym SMy "$foo" ...)

[10:47] <autrijus> where the ... is the statements that follows it

[10:47] <nothingmuch> Sym == ?

[10:47] <autrijus> Sym is a constructor for Exp node

[10:47] <autrijus> means "new symbol"

[10:47] <autrijus> but anyway. the parser will generate a

[10:47] <nothingmuch> okay

[10:47] <autrijus> (Sym SMy "$foo" (Syn "env" []))

[10:47] <autrijus> Exp

[10:48] <autrijus> the Syn "env" is a special exp that evalutes the the env

[10:48] <autrijus> as a VControl (ControlEnv Env)) value

[10:48] <autrijus> it's saying "snapshot the Env and return it"

[10:48] <nothingmuch> so when you compose a lexical scope you fish all the Sym SMy for all the non block sub Exps of the one you're entering, and add them into the lexical scope?

[10:48] <autrijus> so Parser constructs that, unsafeEvalExp it

[10:48] <autrijus> and get back a modified env with the new symbol in envLexical

[10:48] <nothingmuch> oh, i see

[10:48] <autrijus> the Parset sets the current Env as that

[10:48] <nothingmuch> "every block is a closure"?

[10:49] <autrijus> yes.

[10:49] <autrijus> so, the Parser does something clever

[10:49] <autrijus> for "my" variables

[10:49] <autrijus> or rather, any nonglobal ones

[10:49] <autrijus> it snapshots the "env"

[10:49] <autrijus> and calculates the delta

[10:49] <autrijus> i.e. what new symbols are generated

[10:49] <autrijus> it's in unsafeEvalLexDiff in Parser.hs

[10:49] <autrijus> so it discovers that there's a new symbol $foo

[10:50] <autrijus> with an allocated storage

[10:50] <autrijus> (all these is done by the reduction rule for Sym)

[10:50] * nothingmuch smiles

[10:50] <autrijus> the Parser then returns a Exp that says

[10:50] <nothingmuch> the reduction rule for sym happens at parse time, and closure return time?

[10:50] <nothingmuch> oh i see

[10:51] <autrijus> Pad SMy newPad restOfExp

[10:51] <nothingmuch> it puts a wrapper around the exp that adds and removes new variable storage from the map

[10:51] <autrijus> where newPad only contains the new symbols

[10:51] <autrijus> yes.

[10:51] <nothingmuch> unionPads?

[10:51] <nothingmuch> that's very cute

[10:51] <autrijus> unionPads merges OUTER with the new INNER

[10:51] <autrijus> if we were to use a stack for envLexical

[10:51] <autrijus> we simply rewrite unionPad to do the pushing thing.

[10:52] <nothingmuch> okay

[10:52] <autrijus> makes sense?

[10:52] <nothingmuch> closures

[10:52] <nothingmuch> yes it does =)

[10:52] <nothingmuch> how do closures keep their lexical scope?

[10:52] <autrijus> so to answer your question, Sym is only generated and executed by Parsing time

[10:52] <autrijus> at runtime they are all Pads

[10:52] <nothingmuch> vsub has an envlexical that it stole from it's parent at the time the sub ref was given?

[10:52] <autrijus> all these tricks is to make the "my" pads reallocate storage when reentered

[10:52] <autrijus> yes!

[10:53] <autrijus> Eval.hs line 351.

[10:53] <nothingmuch> oh! i forgot

[10:53] <nothingmuch> i was trying to think how you tell apart a sub being returned and rescue it's parent's lexical scope

[10:54] <nothingmuch> when returning a sub is really an application of an op to a block

[10:54] <nothingmuch> okay, very cool

[10:54] <autrijus> yup.

[10:54] <nothingmuch> okay

[10:54] <autrijus> ok. so parsing is probably just that

[10:54] <nothingmuch> the notion of a dynamic scope a la perl5 local is not yet ready for pugs, right?

[10:54] <autrijus> you mean temp?

[10:55] <nothingmuch> that would require the global env being done in a stack?

[10:55] <nothingmuch> yes, but for globals

[10:55] <nothingmuch> in p5 i imagine each stash slot has a stack

[10:55] <nothingmuch> local pushes a pointer to the head of the stash stack onto the call stack

[10:55] <autrijus> temp is for globals.

[10:55] <autrijus> p5 local is exactly p6 temp

[10:55] <nothingmuch> when the call stack is cleaned up then all the stacks in the localized list are popped

[10:56] <nothingmuch> i thought temp also works for lexicals

[10:56] <nothingmuch> wait, that doesn't make sense

[10:56] <nothingmuch> only let makes sense for that

[10:56] <autrijus> yeah.

[10:56] <autrijus> in pugs, I think we will implement it as part of BLOCK_EXIT 

[10:56] <nothingmuch> actually, it could make sense to localize lexicals

[10:56] <autrijus> where is called whenever a exit happens

[10:57] <nothingmuch> { my $var; sub { temp $var = $var + 1; &?SUB() } }

[10:57] <autrijus> I don't disagree... and it should be the same thing

[10:57] <nothingmuch> wait, add another sub to that

[10:57] <nothingmuch> { my $var; sub foo { temp $var = $var + 1; bar () }; sub bar { $var.say };

[10:57] <nothingmuch> there, that makes sense

[10:57] <autrijus> yeah.

[10:58] <autrijus> I think what we'll do

[10:58] <nothingmuch> it's very different from saying sub foo { my $var ...

[10:58] <autrijus> is to install LEAVE blocks

[10:58] <autrijus> aroun the sub foo

[10:58] <autrijus> as part of its trait

[10:58] <autrijus> that restores $var

[10:58] <nothingmuch> brb, need to pee =)

[10:58] <autrijus> I think we need to renormalize all this into the S04 system of closure traits.

[11:00] <nothingmuch> ok, back

[11:00] <nothingmuch> sorry, i had beer and coffee at lunch

[11:00] <nothingmuch> okay, how does context application work?

[11:00] <autrijus> it's simply

[11:00] <autrijus> that envContext stores the context :)

[11:00] <nothingmuch> as i see it we have two cases

[11:00] <nothingmuch> one is that eval returns a value

[11:00] <nothingmuch> and then this value is coerced

[11:01] <autrijus> a context is just a Cxt

[11:01] <nothingmuch> the other is that this happens as well, but the thing in the evaluator gets to ask what the context is too

[11:01] <autrijus> a Cxt is just Void/Item/Slurpy plus a type

[11:01] <nothingmuch> okay

[11:01] <autrijus> the two cases are the same

[11:01] <nothingmuch> given { stmt; stmt };

[11:01] <nothingmuch> the outer context, and the second innner context are the same

[11:01] <autrijus> when you want to evaluate a Exp in a certain cxt

[11:01] <autrijus> uh no

[11:01] <autrijus> in stmt1

[11:02] <autrijus> the cxt is forced to by CxtVoid.

[11:02] <nothingmuch> the first inner context is void

[11:02] <autrijus> only stmt2 assumes outer context.

[11:02] <autrijus> precisely

[11:02] <autrijus> it's in line 286 Eval

[11:02] <nothingmuch> is there a stack of contexts?

[11:02] <autrijus> reduce (Stmts this rest) = do val <- enterContext cxtVoid $ reduce this

[11:02] <autrijus> no.

[11:02] <autrijus> you can ask for caller's context easily

[11:02] * nothingmuch has been liking stacks a lot these past 2 weeks

[11:02] <autrijus> but there's no OUTER::Context

[11:03] <nothingmuch> okay, so leaving an eval you just replace envContext with your parent's

[11:03] <nothingmuch> ?

[11:03] <nothingmuch> that could be useful

[11:03] <autrijus> uh, leaving an eval always keep Env pristine.

[11:03] <nothingmuch> to implement the call builtin, for example

[11:03] <autrijus> the only things that can change is the global pad.

[11:03] <autrijus> and things in storage.

[11:03] <autrijus> but from the Env point of view, it never changed.

[11:03] <nothingmuch> who builds the env up, the eval, or the thing calling the eval

[11:03] <autrijus> that's what the ReaderT part of Eval monad ensures.

[11:04] <autrijus> the thing calling the eval

[11:04] <autrijus> using runEvalIO

[11:04] <nothingmuch> so read 'leaving an eval' 'after the eval returned'

[11:04] <nothingmuch> and that's correct?

[11:04] <autrijus> yup

[11:05] <autrijus> inside the eval monad, when you evaluate any subexpression

[11:05] <autrijus> you can freely modify its Env

[11:05] <nothingmuch> alllright

[11:05] <nothingmuch> so we have parsing and evaluation, basically

[11:05] <autrijus> but the modification _always_ wears off when the subexpresisonr eturns

[11:05] <autrijus> yes.

[11:05] <nothingmuch> i think the next logical part is explaining how data is accessed

[11:05] <nothingmuch> ITypes, etc

[11:05] <nothingmuch> and i think after that VSubs and Prims

[11:05] <nothingmuch> which I sort of know, but not 100%

[11:06] <nothingmuch> and either way it's good documentation

[11:06] <autrijus> ok. each variable is a binding from name to storage

[11:06] <autrijus> there are all kinds of storage.

[11:06] <autrijus> we currently all it ITypes

[11:06] <nothingmuch> are variables first class data themselves?

[11:06] <autrijus> s/all/call/

[11:06] <autrijus> but they will be unified to the new object core.

[11:06] <autrijus> yes, they are.

[11:06] <autrijus> or rather, the storage are.

[11:06] <nothingmuch> i.e., when I take a reference, do i get a variable in a variable? or only the container part of the variable?

[11:06] <autrijus> a variable is just name and storage

[11:07] <autrijus> you can take a symbolic reference

[11:07] <autrijus> which refers to the name

[11:07] <nothingmuch> okay, so variable is a kvp for name and container

[11:07] <autrijus> or a hard reference

[11:07] <autrijus> which refers to the storage.

[11:07] <nothingmuch> damn, i'm lagging

[11:07] <autrijus> nothingmuch: yes, if you discount multisubs.

[11:07] <nothingmuch> okay

[11:07] <nothingmuch> multisubs?

[11:07] <autrijus> (which is a name referring to multiple storages.)

[11:07] <autrijus> multi sub foo (Int $x) { ... }

[11:07] <autrijus> multi sub foo (Str $x) { ... }

[11:07] <nothingmuch> oh, that thing

[11:07] <autrijus> here &foo refers to two things.

[11:07] <autrijus> we can safely ignore it now.

[11:07] <nothingmuch> right

[11:08] <nothingmuch> but it's not really

[11:08] <nothingmuch> foo is a lookup

[11:08] <nothingmuch> the "name" is the full signature?

[11:08] <autrijus> right. so I need to fix that.

[11:08] <autrijus> yeah.

[11:08] <autrijus> but it's not implemented like that currently

[11:08] <autrijus> headsup: I need to go to dinner in a few mins

[11:08] <nothingmuch> okay, lets ignore it now

[11:08] <nothingmuch> so lets finish itypes, and then you can go?

[11:08] <nothingmuch> i need to work myself

[11:08] <autrijus> k. so ITypes. 

[11:09] <autrijus> ITypes are the same as TIE*

[11:09] <nothingmuch> i types are perltie in haskell?

[11:09] <autrijus> yes.

[11:09] <nothingmuch> damn, i'm to oslow

[11:09] <nothingmuch> =)

[11:09] <autrijus> which means they are containers that responds to different things.

[11:09] <autrijus> you're fast enough.

[11:09] <autrijus> each IType demands a different interface

[11:09] <autrijus> but the underlying implementatino is opaque.

[11:10] <autrijus> all IType responds to object_iType

[11:10] <autrijus> which is their Type, or Class

[11:10] <nothingmuch> let me get something streight:

[11:10] <nothingmuch> okay

[11:10] <autrijus> k

[11:10] <nothingmuch> is itype method dispatching going to be the same as MMD?

[11:10] <nothingmuch> wait, no, tihat's nonsense

[11:11] <nothingmuch> is implementing a new itype going to be similar to creating an overloaded object

[11:11] <nothingmuch> which pretends to be a Str, or a Num

[11:11] <nothingmuch> except that it pretends to be a container?

[11:11] <nothingmuch> or are there some subtle distinctions?

[11:12] <nothingmuch> btw, is the opaque type an itype too?

[11:12] <autrijus> you know, that's an excellent question we have no spec of.

[11:12] <autrijus> you're asking the API for Tieable.

[11:12] <autrijus> my best estimate is that when we have Role 

[11:12] <nothingmuch> given enough meta meta on containers this is trivial

[11:12] <autrijus> we can merge itype with role

[11:12] <autrijus> exactly!

[11:12] <nothingmuch> my $var is container(Class);

[11:12] <autrijus> yup.

[11:13] <autrijus> and that's where we would go

[11:13] <nothingmuch> okay, funky

[11:13] <autrijus> internal wise.

[11:13] <autrijus> but no idea about syntax.

[11:13] <autrijus> I don't think @Larry has settled it yet.

[11:13] <nothingmuch> syntax is for p6l to discuss and @Larry to vetoe

[11:13] <autrijus> we may need to improvise.

[11:13] <autrijus> yup.

[11:13] <autrijus> so to answer your question

[11:13] <nothingmuch> okay, what about opauqe?

[11:13] <autrijus> the VOpaque type is not used.

[11:13] <autrijus> it's strictly for my $work ;)

[11:14] <autrijus> with VOpaque you can masquerade any haskell type as a Pugs Val type.

[11:14] <autrijus> as long as you implement fromVal.

[11:14] <autrijus> it may also be useful for eval_haskell

[11:14] <autrijus> and other haskell integration things

[11:14] <nothingmuch> okay

[11:14] <autrijus> but it's not part of p6 proper.

[11:14] <nothingmuch> so how are object attrs dealt with?

[11:14] <autrijus> you use the VObject 

[11:15] <autrijus> data VObject = MkObject { objType   :: !VType , objAttrs  :: !IHash , objId     :: !Unique } deriving (Show, Eq, Ord, Typeable)

[11:15] <autrijus> the objAttrs is a hash

[11:15] <autrijus> an object is just: type, attrs, id.

[11:15] <nothingmuch> so that *is* an itype interface?.

[11:15] <autrijus> it's not

[11:15] <autrijus> currently objects are just values

[11:15] <autrijus> never containers

[11:15] <autrijus> so you can't do tie().

[11:15] <nothingmuch> actually why aren't they?

[11:15] <autrijus> because we need Role for itypes

[11:15] <autrijus> and Role isn't yet implemented.

[11:15] <autrijus> when it is, it will.

[11:16] <nothingmuch> okay, coolness

[11:16] <kungfuftr> nothingmuch: implement Role!

[11:16] <kungfuftr> =0)

[11:16] <nothingmuch> kungfuftr: maybe after we all know about pugs internals =)

[11:16] <autrijus> so anyway.

[11:16] <nothingmuch> go eat, have fun

[11:16] <autrijus> oh, that's all? :)

[11:16] <nothingmuch> when we are both back we can continue, unless you feel like doing some more =)

[11:17] <autrijus> nah. I'll go eat and pick up $work.

[11:17] <autrijus> see ya

[11:17] <autrijus> thanks for volunteering to do this :)

[11:17] <nothingmuch> i need somethintg to get me reinvolved

[12:31] <scook0> hmm, looks like I missed lots of cool internals stuff while I was at work

[12:32] <scook0> autrijus & nothingmuch: please ping me if you continue talking about internals :)

[12:32] <nothingmuch> scook0: i'll try to remember

[12:32] <nothingmuch> either way, I'm going to graph and write up all this stuff

[12:33] <nothingmuch> and put it in doc

[13:03] *** odin__ is now known as Odin-LAP

[13:46] <svnbot6> r3384, Stevan++ | Perl::MetaModel - making the methods test pass again

[13:46] <svnbot6> r3385, Stevan++ | Perl::MetaModel - its MetaClass not Meta::MetaClass, forgot to rename the tests

[13:52] * broquaint finally gets his grubby hands on HOP

[13:53] <Limbic_Region> broquaint - are you on the HOP discuss mailing list

[13:53] <broquaint> I certainly am, L~R.

[13:53] <Limbic_Region> or more importantly, are you aware that the errata are plentiful and on-line

[13:53] <Limbic_Region> ok

[13:53] <castaway> grats, broquaint :)

[13:53] <broquaint> Thanks, c :)

[13:53] <castaway> and more penguin classics? :)

[13:53] <lumi> What is HOP?

[13:53] <broquaint> Not yet ...

[13:54] <broquaint> Higher Order Perl, lumi.

[13:54] <castaway> Higher Order Perl

[13:54] <autrijus> $^perl

[13:54] <broquaint> A hype-deserving book by Mark-Jason Dominus.

[13:55] <kungfuftr> i've had HOP beside me for a few days now, haven't read it yet...

[13:55] * Limbic_Region has yet to read a single programming book all the way through but HOP came damn close

[13:55] <broquaint> It looks shiny.

[13:55] <broquaint> The cover's purty too.

[13:55] <castaway> heh

[13:55] <castaway> shiny++

[13:57] <autrijus> broquaint: the cover's romantic

[13:57] <broquaint> Indeed, autrijus, maybe that's why it makes for a good "coffee table" look.

[13:58] <broquaint> Most tech book covers are little on the ugly side, IMO.

[13:58] <autrijus> it has the best explanation for CPS as I ever saw.

[13:58] <broquaint> It has a CPS explanation? Marvellous!

[13:58] <autrijus> (in the part of converting factorial() from recursion to iteration)

[13:58] <autrijus> he didn't name it CPS :)

[13:58] <autrijus> in fact, he doesn't really name things as they are named in the lisp circle.

[13:58] <Limbic_Region> where CPS = Continuation Passing Style?

[13:58] <broquaint> Aha, what should I be looking for?

[13:58] <autrijus> (which is a good idea.)

[13:59] <autrijus> broquaint: converting recursion to iteration, or something like that

[13:59] <autrijus> Limbic_Region: yes

[13:59] <broquaint> Ah, ok. Isn't recursion to iteration known as "recursion unrolling"?

[13:59] <autrijus> yes.

[13:59] <broquaint> Oh. I've done that before. Darn it. I was looking for deep scary magic :)

[14:00] <autrijus> but in this specific case, he uses a explicit program counter and execution stack

[14:00] <autrijus> and maintains the handler for returning continuation

[14:00] <autrijus> so it's not quite spelt-out CPS

[14:01] <autrijus> but all it lacks is an abstraction function that makes this explicit

[14:01] <broquaint> Groovy.

[14:02] <svnbot6> r3386, iblech++ | EOL at EOF, usual svn properties.

[14:02] <svnbot6> r3387, iblech++ | Rubyish infix ops for set operations: [1,2,3] +# [1,2,6] ==> [1,2,3,6]

[14:02] <broquaint> So it's deep voodoo for the non-shaman?

[14:02] <pasteling> "iblech" at 80.81.16.226 pasted "Patch to implement user defined infix ops" (53 lines, 2.5K) at http://sial.org/pbot/10225

[14:03] <autrijus> oh wow!

[14:03] <autrijus> what's this about +# ?

[14:03] <autrijus> is this t/unspecced/ stuff?

[14:03] <autrijus> oh, it's Set.pm.

[14:03] <autrijus> whew

[14:04] <Limbic_Region> broquaint - mostly I would say that you have seen all and/or used all of the techniques in the book - maybe something will be new but unlikely

[14:04] <broquaint> Can user-defined operators be scoped?

[14:04] <Limbic_Region> what is more likely is you will see it applied in ways you hadn't considered before

[14:04] <autrijus> iblech: kill line 1223

[14:04] <autrijus> \\n   List      list    ,       (List)\

[14:04] <autrijus> in Prim.hs

[14:04] <broquaint> Ah, nicely put, L~R :)

[14:04] <autrijus> that shouldn't be there anyway

[14:04] <autrijus> iblech: and you'll be fine. please check in after that. you++

[14:04] <Limbic_Region> or, just as likely, you will see it taken a step further than you have seen before

[14:04] <autrijus> iblech: or, if it still breaks, say so and I'll tkae a look

[14:05] <Limbic_Region> I think MJD was getting at the fact that we tend to stay in our safe little perl sandbox and even when we invite other kids to play, it is still "our" sandbox

[14:05] <iblech> autrijus: Whoa! That was easy =) Checking in...

[14:05] <Limbic_Region> the book is about getting up with the other kids and walking over to their sandbox

[14:06] <iblech> Committed as r3388.

[14:06] <autrijus> iblech++

[14:06] <iblech> Haskell++ :)

[14:06] <broquaint> I have an interview on Wednesday so I wonder if it's a good idea to read HOP before or after ...

[14:07] <castaway> heh.. where to?

[14:07] <svnbot6> r3388, iblech++ | User defined infix ops! :)

[14:07] * castaway is over there again a week thursday

[14:07] <Limbic_Region> ok - I am off to $work

[14:07] <Limbic_Region> good job iblech et all

[14:07] <broquaint> Later, L~R.

[14:07] <castaway> Sounds like a fun book

[14:07] <broquaint> multimap.com, castaway :)

[14:08] <castaway> cool

[14:08] <iblech> autrijus: Hrm... The patch seems to have broken "$"... :(

[14:10] <jhorwitz> just read today's logs -- autrijus++ # pugs internals discussion

[14:10] <iblech> autrijus: Or rather, it broke ";"

[14:14] <iblech> autrijus: Found the bug, committed as r3389 (was the same as with ",") :)

[14:14] <svnbot6> r3389, iblech++ | Unbreak ";".

[14:17] <autrijus> iblech++

[14:28] <autrijus> iblech: I'll merge your infixOps into the faster envStash cache

[14:28] <autrijus> sec

[14:29] <iblech> sure :) I was a bit unsure about this

[14:29] <autrijus> pugs> sub infix:<.> (Code &x, Code &y) { sub ($z) { x(y($z)) } }

[14:29] <autrijus> pugs> (&say . &int)(10/3)

[14:29] <autrijus> 3

[14:29] <iblech> yay!

[14:30] <autrijus> this is really something :)

[14:30] <autrijus> hey, would you ask on p6l about the prec level you chose?

[14:30] *** x86_ is now known as x86

[14:31] <iblech> You mean, what the default prec level of user defined infix ops should be?

[14:31] <autrijus> yeah

[14:31] <iblech> sure

[14:32] <autrijus> yeahpugs> sub infix:<`map`> (&x, *@y) { map &x, @y }

[14:32] <autrijus> er

[14:32] <autrijus> pugs> sub infix:<`map`> (&x, *@y) { map &x, @y }

[14:32] <autrijus> pugs> &int `map` (1.28, 2.56)

[14:32] <autrijus> (1, 2)

[14:32] * autrijus is having much fun

[14:32] * autrijus is having a really bad idea...

[14:33] <iblech> tell us :)

[14:33] <svnbot6> r3390, autrijus++ | * merge Unary and Infix userdefined ops into a shared

[14:33] <svnbot6> r3390, autrijus++ |   cached envStash in Parser to speed up processing

[14:33] <castaway> uhoh :)

[14:33] * iblech guesses... circumfix:<` `>?

[14:34] <Limbic_Region> likely he is thinking a way of turning p6 inside out to reveal haskell

[14:46] <autrijus> hm

[14:46] <autrijus> can't quite do it.

[14:46] <autrijus> pugs> say [ {$_ * 3} | $_ <- [1 .. 10],:{ $_ % 2 } ]

[14:46] <autrijus> 3 9 15 21 27

[14:46] <autrijus> that's the closest I got

[14:46] <jhorwitz> autrijus: for the parrot backend, is there a way to determine the order subs and module declarations are declared?  right now we can't have more than one namespace since all those ops are grouped at the top.

[14:47] <autrijus> jhorwitz: I think the subs should be prefixed with the package name too

[14:47] <autrijus> methods currently are

[14:47] <autrijus> maybe you can try methods first

[14:47] <jhorwitz> and just output a .namespace op when i see the package qualifier?

[14:48] <autrijus> yeah. I think.

[14:48] * jhorwitz will investigate

[14:49] <x86> man

[14:49] <x86> these new operators and modified syntax is gonna be the death of me ;)

[14:54] <autrijus> iblech: oh, the definition of prec is by "is tighter" "is looser" "is equiv"

[14:54] <autrijus> I'll bbiab.

[14:55] <iblech> autrijus: Ah :) I remembered something like that, but wasn't entirely sure

[14:59] <mkirank> i get this error when i do a make

[14:59] <mkirank> sorry

[15:00] <castaway> thats a strange error

[15:00] <mkirank>  /usr/bin/hsc2hs  -Isrc/syck  src/Data/Yaml/Syck.hsc

[15:01] <mkirank> Syck.hsc: In function `main'

[15:01] <mkirank> Syck.hsc:62: error: syntax error before "SyckParser"

[15:26] <autrijus> mkirank: hm. ghc 6.4?

[15:26] <mkirank> yes

[15:27] <autrijus> weird.

[15:27] <autrijus> which platform is this?

[15:27] <autrijus> and do you have an old hsc2hs lying around maybe?

[15:27] <mkirank> fedora core 1

[15:28] <mkirank> i did this n /usr/lib/ghc-6.4/hsc2hs-bin /usr/bin/hsc2hs

[15:28] <mkirank> ln

[15:28] <autrijus> latest pugs?

[15:28] <autrijus> (from svn)

[15:28] <autrijus> try running

[15:28] <mkirank> just a min , i deleted the code and am now getting the latest from svn

[15:29] <autrijus> you should have a wrapper hsc2hs

[15:29] <autrijus> you're not supposed to run hsc2hs-bin like that

[15:29] <mkirank> still get the same error 

[15:29] <mkirank> oh ok

[15:29] <autrijus> http://autrijus.org/tmp/hsc2hs

[15:29] <autrijus> that's hsc2hs on my system

[15:31] <svnbot6> r3391, iblech++ | * Fixed and unTODOed t/subroutines/operator_overloading.t.

[15:31] <svnbot6> r3391, iblech++ | * Unbroke "is".

[15:31] <svnbot6> r3392, iblech++ | Added an experimental fp (functional programming) module, with tests and

[15:31] <svnbot6> r3392, iblech++ | documentation.

[15:32] <autrijus> iblech++ # craziness

[15:32] <autrijus> iblech: why "o"? why not "."? ;)

[15:33] <mkirank> autrijus: it works  ..thanks

[15:33] <autrijus> np :)

[15:33] <iblech> autrijus: I thought "." would be visually too overloaded with the method invocation thing... (At least to me)

[15:34] <osfameron> <aol>me too</aol>

[15:34] <iblech> When is export tags work, we can do things like use fp :. or use fp :o (which looks somewhat strange ;))

[15:35] <autrijus> ok. I'll use 22C5 ;)

[15:35] <autrijus> &x ⋅ &y

[15:36] <iblech> yeah :)

[15:36] * iblech adds that

[15:37] <integral> not ∘ ?

[15:38] <osfameron> I could have sworn my irc client did unicode, but I can't see those.

[15:38] <autrijus> it's neither, hrm

[15:39] <iblech> osfameron: My fixed size font can't either (but copy&paste and view with some variable size font works)

[15:39] <autrijus> it's a o in middle

[15:40] <osfameron> ah, gvim shows the first as a . in the middle

[15:41] <osfameron> the second as a degree sign (raised circle)

[15:41] <autrijus> 25CB is it.

[15:42] <autrijus> &x  &y

[15:42] <autrijus> iblech: go with 25CB :)

[15:42] <iblech> ok :)

[15:42] <autrijus> mm the block starting from 2336 is fun

[15:42] <autrijus> 2336;APL FUNCTIONAL SYMBOL I-BEAM;So;0;L;;;;;N;;;;;

[15:42] <autrijus> 2337;APL FUNCTIONAL SYMBOL SQUISH QUAD;So;0;L;;;;;N;;;;;

[15:42] <autrijus> ...and so on...

[15:42] <autrijus> we can plunder them all!

[15:42] <autrijus> use APL;

[15:43] <kolibrie> cutting and pasting still doesn't produce nice characters for me

[15:43] <kolibrie> am I missing a font?

[15:44] <autrijus> probably

[15:44] * putter thinks pugs/p6 will need to include pointers to unicode resources...

[15:44] <kolibrie> guesses as to which one I should get?

[15:45] <autrijus> Vera doesn't have them?

[15:45] <autrijus> I think arialuni.ttf is good

[15:45] <autrijus> although I don't use it currently

[15:45] <integral> yeah, it's got all those APL symbols

[15:47] <autrijus> iblech: 

[15:47] <autrijus> sub infix:<⇒> { $^x => $^y }

[15:48] <kolibrie> debian doesn't have a package :(

[15:48] <svnbot6> r3393, iblech++ | fp -- Added â as function composition op. Unicode++ :)

[15:48] <iblech> Hm... does that fit fp.pm? I think it should go into Prelude.pm :)

[15:49] * iblech adds it nevertheless :)

[15:49] <autrijus> you mean sub infix:<⇒> { $^x => $^y }

[15:49] <autrijus> ?

[15:49] <autrijus> lol

[15:50] <iblech> yes

[15:53] <iblech> Hmm... we need circumfix (I want ⎣...⎤ :))

[15:53] <svnbot6> r3394, iblech++ | fp -- Added â (=>).

[16:00] <svnbot6> r3395, iblech++ | Added test testing that the reduce meta op works with user defined ops.

[16:01] <putter> Could someone do a test for me?  On a non-amd64 cpu with _external parrot_, move t/rules/Disabled/from_perl6_rules/subrule.t elsewhere, say t/aaa/, and tell me if you get a nice PGE failure, or an unfortunate test hang.  I have

[16:01] <putter> several tests with this behavior, but if its just amd64, I'll un-disable them...

[16:02] <autrijus> putter: 

[16:02] <autrijus> <?abc> 

[16:02] <autrijus> is not yet supported in PGE.

[16:02] <autrijus> with latest pugs I get nice PGE error.

[16:02] <autrijus> try it in amd64 again? Gruber and I fixed a related bug

[16:09] <putter> autrijus: r3392.  mostly works. :)  as for the "hang"...

[16:09] <svnbot6> r3396, autrijus++ | * according to luqui, we place userdefined infix as the

[16:09] <svnbot6> r3396, autrijus++ |   same precedence as &infix:<+>.

[16:09] <svnbot6> r3397, autrijus++ | * Igloo pointed out the Unicode standard has 

[16:09] <svnbot6> r3397, autrijus++ |   infix:<â>, not infix:<â>, as the function composition

[16:09] <svnbot6> r3397, autrijus++ |   "ring" operator.  Oh well.

[16:11] <putter> at least today, the "hang" on subrule.t is a just a long pause... followed eventually by a skip tests ?!?  ok, that's wierd...

[16:13] <wolverian> er. â doesn't look like a composition operator :)

[16:14] <svnbot6> r3398, iblech++ | Added more Unicode ops :)

[16:15] <putter> as everyone scurries about improving the unicode support, lets capture the info in say a unicode section of README?

[16:15] <putter> s/the/their/

[16:15] <autrijus> wolverian: blame the bot

[16:17] <wolverian> gladly :)

[16:24] <autrijus> hm, 

[16:24] <autrijus>   qsort =: ]`(($:@:((}.<:{.)#}.)),{.,($:@:((}.>{.)#}.)))@.(*@#)

[16:24] <autrijus> cute.

[16:25] <umbop> eh what does that do?

[16:25] <putter> eeep.

[16:25] <autrijus> umbop: it implements the quicksort algorithm

[16:26] <umbop> ahh

[16:27] <autrijus> ] is id, @. is ??::, {. is head, }. is tail, @: is o, [: is (), *: is sign, #: is length, :# is grep

[16:27] <autrijus> $: is $?SUB

[16:27] <autrijus> amazing, no?

[16:27] <autrijus> # http://en.wikipedia.org/wiki/J_programming_language

[16:27] <autrijus> (this is for real)

[16:28] <autrijus> alphabets are for wimps! ;)

[16:28] <autrijus> "punctional programming"

[16:30] <wolverian> looks like an ugly version of APL

[16:30] <autrijus> more advanced too

[16:30] <autrijus> maybe there's a correlation

[16:30] * umbop checks it out

[16:30] <autrijus> it's a marriage between APL and Backus's FP

[16:31] <autrijus> two language widely known for clear-as-ink legibility

[16:31] <autrijus> I'm feeling much better for perl now :)

[16:32] <iblech> :)

[16:32] <autrijus> use j;

[16:33] <autrijus> hmmmmmm.

[16:33] <ninereasons> what does "autochomping" look like? is that exactly equivalent to "is chomped" ? # A06 "Or better, use an autochomping filehandle"

[16:34] <autrijus> ninereasons: I don't know, it's essentially unspecced

[16:35] <putter> hmmm,  use perl5; ... use apl;  ... use j; ... use ruby; ... use python; ... use scheme; ... weeeee.

[16:35] <autrijus> wheee

[16:35] <ninereasons> use hugs with pugs;

[16:36] <putter> *laugh*

[16:37] <autrijus> ./pugs -e '∿⌶⋪⊨⌆⊛∷∑⌿⌋∰⊣⊄∊≏∝⌄≯≿⌶⋈≳⋗∨∘⊔⋼⋍⊺⊉⌞∍≓⌖⋛⌋∷⌗≏⌑≐≐≰⌄≦≗⋲∏∲⌓⊌⋛≊⋜⊻≐∙⊶⌶≄≧∟⋡⌟≅⊌≅⊪⋓∊['

[16:37] <autrijus> Hello, World!

[16:38] <wolverian> haha.

[16:39] <PerlJam> autrijus: you just exponentiated JAPHs to a rather large power.

[16:40] <autrijus> PerlJam: I hear there is a a JA*H contest in APW/FPW.

[16:41] <autrijus> where people submit JA*H with any of the Parrot languages

[16:41] <autrijus> including Pugs (in interpreter mode)

[16:41] <autrijus> and PIR/PASM

[16:41] <autrijus> I'm one of the judges :)

[16:43] <putter> autrijus: should something like subrule.t be/notbe unDisabled?  It PGE Parse fails, it "dubiosly" dies, it (or at least some others) hangs make test on amd64-external-parrot... which, if any of these, should keep something Disabled...?

[16:43] <autrijus> putter: I think I'd like to move all the rule tests to Parrot tree.

[16:43] <autrijus> under t/p6rules/

[16:44] <autrijus> where they belong, really

[16:44] <putter> k

[16:44] <autrijus> I wonder if you can investigate into a simple conversion that transfoer our Test.pm format to parrot's

[16:44] <autrijus> wouldn't be hard

[16:44] <autrijus> the external/embedded/unavailable thing is perhaps too much to handle here

[16:44] <autrijus> since we just use PGE verbatim

[16:44] <autrijus> it makes sense to transfer our 800ish tests there

[16:45] <putter> 5000ish+800ish ;)

[16:46] <autrijus> :)

[16:50] <svnbot6> r3399, iblech++ | fp -- Updated the documentation of fp.pm.

[16:54] <putter> autrijus: ok, some of from_perl6_rules could be moved over.  but some is necessarily p6 (captures, grammars, etc).

[16:55] <putter> so... with me bearing in mind that some cruft can be pushed off to parrot... same question (unDisabling contraindictors)...

[17:02] <putter> unless I missed something obvious?  one could do many/most of the tests with p6rule_like, but some of the tests are of p6 rules, grammars, etc, not merely of PGE.

[17:08] <autrijus> right.

[17:08] <autrijus> but subrules can be pushed to add_subrule too

[17:09] <autrijus> I can help with that

[17:09] <autrijus> the .from .to etc tests we can test with PCRE

[17:09] <autrijus> it may make sense to do a minimal set of sanity test with PGE

[17:09] <autrijus> that are unlikely to fail

[17:09] <autrijus> with either embed or extern

[17:11] *** TSa is now known as TSa_

[17:12] *** TSa_ is now known as TSa

[17:14] * putter steps back to peer bleary-eyed at the big picture...

[17:16] <putter> some issues are pure pugs, eg parsefails, and I know how to deal with them (fail("FIXME...)#...)

[17:23] <putter> external parrot on amd64, which used to be entirely broken, failing explosively, is now sometimes working.  it looks like

[17:24] <putter> current there may be, perhaps, two failure modes.  it seems rules which are skipped are sufficient to cause difficulty.  this may or may not suggest

[17:25] <putter> that it is a codgen, rather than pge problem.

[17:27] <svnbot6> r3400, ninereasons++ | fiddle with quote generator (esp. "pick any" to "pick")

[17:29] *** _metaperl_ is now known as _metaperl

[17:38] <putter> autrijus: how about this:

[17:40] <putter> I'm going to ignore the test hanging unless it turns out to affect something other than amd64/external.  It's not clear anyone but me is using amd64, and its still not "real" (eg, you get cvs head, which may or may not compile on amd64 on any particular afternoon, and ...).

[17:40] * autrijus listens

[17:40] <autrijus> sure, I can live with that

[17:40] <autrijus> but I still want to get to bottom of hanging

[17:40] <autrijus> hanging is always external?

[17:40] <autrijus> can you point me to a hanging case?

[17:41] <putter> agreed, yes, and ...

[17:42] <putter> Disabled/from_perl6_rules/anchors.t ... I've never seen it run external, and runs fine internal.

[17:43] <autrijus> hangs here to. so there :)

[17:43] <putter> non-amd64?

[17:43] <autrijus> aye

[17:43] <putter> oohhhh..... foo!

[17:44] <autrijus> I know why.

[17:44] <autrijus> externpge hangs when matchstr contains \n.

[17:44] <autrijus> sorry I had not got around to test this earlier, causing you much trouble

[17:44] * autrijus fixes

[17:45] <putter> sooo np.  trbl caused drawfed by joy of anticipated coming trouble dissappearing, poof.

[17:49] <putter> post mortem note to self - make sure the "it's not my problem" exploration bound keeps getting updated to include atleast a depth 1 look at all surrounding problems.  oops.  my oversight.

[17:50] <autrijus> gah. line buffering.

[17:50] <autrijus> who invented this line buffering thing?

[17:50] <clkao> autrijus: oh i thought my tests are passing.. not in class 

[17:50] <clkao> method form?

[17:51] <autrijus> clkao: right, that's next

[17:51] <autrijus> iblech got infix working

[17:51] <autrijus> be patience ;)

[17:51] <autrijus> s/patience/patient/

[17:51] <putter> my fuzzy recollection is it's a teletype thing.

[17:51] <autrijus> you can use sub form already though.

[17:53] <clkao> how good is parrot's native call invocation?

[17:54] <autrijus> very good

[17:54] <autrijus> see pdd16

[17:54] <Juerd> I HATE SOFTWARE

[17:54] <autrijus> http://www.parrotcode.org/docs/pdd/pdd16_native_call.html

[17:54] <autrijus> hi Juerd

[17:54] <Juerd> Except Pugs, of course.

[17:57] <putter> Juerd: And yet, I periodically encounter otherwise rational and experienced people who don't think of software engineering as breathtakingly massive unmitigated disaster.  Bizarre.

[17:57] <svnbot6> r3401, ninereasons++ | hash more correct than array

[17:59] <Juerd> putter: I doubt they really are experienced

[17:59] <Juerd> putter: With regards to software, that is

[18:03] <putter> Juerd: if ones experience is limitted to one or two communities, eg C++ and Java, and throughout your career "things have only been getting better and better"... it's not difficult to miss the big picture.

[18:04] <ajs> I regard software engineering as a whole to be astoundingly successful to the point of near-miraculous. It's like a sustained 50 year long 10million car crash that manages to produce any amount of useful work ;-)

[18:06] * autrijus mumbles something about proof-carrying code

[18:07] <ajs> autrijus: Most discussions I've heard about using such a construct end in "how does one represent the proof for 'I kinda, wanna, sorta... you know... and then print the result'"

[18:07] <ajs> ;)

[18:08] <ajs> Which I think is -Q in Perl 5....

[18:08] <autrijus> -Q?

[18:08] <autrijus> ./pugs -e '∀ x. DWIM x'

[18:09] <ajs> made it up... point being that perl "kinda sorta ... you know"s all over the place, and that has its use, even when you can't prove it's WIM

[18:09] <ajs> Hmmm... I guess that leads to TMTOWIM ...

[18:10] <putter> eval('class Foo{}'); Foo.new();  ... *** Error: No compatible subroutine found: "&Foo" :(

[18:13] <putter> eval('class Foo{}; sub foo(){Foo.new()}'); ... *** Error: No compatible subroutine found: "&Foo"... ^.^

[18:15] <autrijus> it worksforme...

[18:15] <autrijus> pugs> eval 'class Foo{}; sub foo(){Foo.new()}'

[18:15] <autrijus> undef

[18:15] <autrijus> pugs> foo()

[18:15] <autrijus> {obj:Foo}

[18:15] <iblech> works here, too

[18:19] <putter> for me too.  but eval "class Foo{}; sub foo(){Foo.new()}" doesn't. (" instead of ')

[18:19] <iblech> ah! That's because {...} interpolates in double quotes strings

[18:20] <putter> duh.  tnx.

[18:20] <ajs> Someone needs to start building the "what you'll do wrong in the first 15 minutes of using P6" list... hmmm, maybe I should...

[18:21] <putter> (oft repeated) postmortem - cut and paste your test cases exactly.  no, it *does* matter. ;)

[18:21] <ajs> But not until I'm done sorting out the changes to S29, which I'm now doing on hands and knees to make sure I don't do anything really stupid.

[18:24] <putter> autrijus: is the externpge fix still in progress?

[18:27] <autrijus> aye

[18:27] <autrijus> I'm close

[18:30] <putter> no hurry.  just checking.

[18:32] <putter> pugs> class Foo{}; undef pugs> sub foo(){Foo.new()}; undef pugs> foo() *** Error: No compatible subroutine found: "&Foo": NonTerm (MkPos "<interactive>" 1 11 1 20) at <interactive> line 1, column 1-6

[18:35] <putter> pugs> sub f(){"f1"} undef pugs> f() 'f1'pugs> sub f(){"f2"} 'f1'pugs> f() 'f1'

[18:35] <autrijus> done.

[18:35] <vcv--> autrijus: do you sleep man? im dumbfounded how one man could produce a perl6 interpreter and make as much progress as you have in a matter of 3 1/2 months. you are not human.

[18:36] <putter> re done, :)

[18:37] <autrijus> putter: check?

[18:37] <autrijus> r3402.

[18:37] <putter> in progress...

[18:37] <autrijus> vcv--: Pugs is also a compiler now :)

[18:37] * vcv-- jaw drop

[18:37] <autrijus> that's how we can make mod_pugs work.

[18:37] <svnbot6> r3402, autrijus++ | * Fix a bug in run_pge in external single-process parrot mode:

[18:37] <svnbot6> r3402, autrijus++ |   Previously, rules cannot contain newlines due to line buffering.

[18:37] <svnbot6> r3402, autrijus++ |   putter++ for catching this.

[18:37] <autrijus> (it compiles to parrot assembly.)

[18:38] <vcv--> compilers to w--ooh

[18:38] <vcv--> -r

[18:38] <autrijus> and embeds parrot too, so you can try

[18:38] <autrijus> ./pugs -BParrot examples/mandel.p6

[18:38] <autrijus> for example.

[18:38] <vcv--> i want to get my hands dirty with all this stuff in the future. just need to get myself adapted to everything going on

[18:38] <autrijus> :)

[18:39] <vcv--> not perl6/pugs itself, but the development :)

[18:39] <autrijus> read journal from way back then :)

[18:39] <autrijus> as for progress... note how the list of AUTHORS grows almost 1:1 with days

[18:39] <vcv--> Yeah. I've been reading up as much as I can

[18:39] <autrijus> we had 101 people at 101st day

[18:39] <vcv--> Oh. heh.

[18:39] <autrijus> so it's not me :)

[18:39] <autrijus> <- accounts for a very small percentage of checkin now... 10% or so

[18:39] <vcv--> still impressive

[18:40] <autrijus> thanks :)

[18:40] <autrijus> yo theorbtwo.

[18:40] <vcv--> I wanted to try to contribute, but i've never used haskell before and learning it has proven harder than i thought

[18:40] <autrijus> you can write modules, tests, examples, docs :)

[18:40] <autrijus> there's no need to mess with src/...

[18:40] <autrijus> ...initially anyway

[18:41] <vcv--> That's what I'm best at though, raw code.. not the other stuff :p but not a bad idea anyway.

[18:41] <autrijus> modules are also raw code...

[18:41] <autrijus> Perl::MetaModel is as hardcore as you can get :)

[18:42] <svnbot6> r3403, iblech++ | One step closer to get the [...] metaop working on all (and user defined ops).

[18:42] <svnbot6> r3403, iblech++ | They now parse correctly (I think), but the necessary &prefix:[...] subs aren't

[18:42] <svnbot6> r3403, iblech++ | yet generated automatically.

[18:42] <svnbot6> r3403, iblech++ | Added more tests to reduce.t.

[18:43] <theorbtwo> Ho, autrijus.

[18:43] <autrijus> iblech++ # yay

[18:43] <vcv--> my dream is to be able to use an embedded perl6 within my own native applications. whats more powerful for extensibility than being able to control an app with p6 scripts? :)

[18:44] <autrijus> after you get [...] working, >> << too :)

[18:44] <integral> hmm, do we have shaped arrays in pugs?

[18:44] <autrijus> vcv--: modparrot already does that!

[18:44] <autrijus> integral: no

[18:44] <integral> oh.  pity

[18:44] <vcv--> you gotta be kidding me. what havent you guys thought of?!

[18:44] * integral is going to write some matrix code one day

[18:45] <theorbtwo> Matrices are a big PITA.

[18:45] <autrijus> vcv--: I don't know, I can't think of things that I can't think of

[18:45] <vcv--> wait.. mod_parrot or modparrot..?

[18:45] <vcv--> mod_parrot is for apache isnt it?

[18:45] <autrijus> yeah

[18:45] <autrijus> mod_parrot

[18:45] <vcv--> ah. well im talkin' like windows applications, or *nix apps, not web apps.

[18:46] <autrijus> there's this XSLT library

[18:46] <vcv--> Like an IRC client im working on. i know xchat can do perl scripts, and irssi too? but..hm..

[18:47] <putter> parrot is supposed to be embeddable, with a C api.  the C api has historically lagged rather far behind PIR however.  I don't know current state.

[18:47] <autrijus> that lets you use perl6 to define xslt functions :)

[18:47] <autrijus> putter: oh, thanks to jhorwitz it's pretty usable now.

[18:47] <vcv--> thanks for that info putter.

[18:47] <vcv--> that would be perfect

[18:47] <autrijus> otherwise pugs couldn't have use embedded PGE

[18:47] <theorbtwo> Autrijus: I need some way to start feeling like I'm contributing again.

[18:47] <theorbtwo> Any suggestions?

[18:48] <autrijus> theorbtwo: eval_haskell for arbitary Value datatypes?

[18:48] <vcv--> any estimate on how much of a footprint embedded parrot+p6 would be? memory and disk space.

[18:48] <autrijus> theorbtwo: or, if you're crazy, port Perl::MetaModel back to haskell?

[18:49] <autrijus> vcv--: parrot can be run in a shared-vm mode so the footprint is minimal for multiple instances

[18:49] <theorbtwo> Hm, I wonder if I can do that without circularity.

[18:49] <putter> hmm, in that case I should figure out who's doing ruby on parrot and mention I have a "mutate ruby source to produce ruby/parrot hybrid" for a migrational approach...

[18:49] <autrijus> vcv--: as for single process, I'm seeing 2609k here

[18:49] <autrijus> (for actively used memory in libparrot)

[18:50] <autrijus> putter: ponie for ruby?

[18:50] <vcv--> hm.. not too bad. my irc client uses very little memory as is right now, so i can throw something like embedded parrot in there without hurting mem usage too much

[18:51] <PerlJam> heh, "embedded parrot" sounds strange to me.

[18:51] <autrijus> PerlJam: not stranger than embedded libperl

[18:52] <autrijus> (which is used in irssi among other places)

[18:52] <PerlJam> true.

[18:52] <vcv--> ill have to look at libperl too.

[18:52] <PerlJam> parrot would be more embeddable if it weren't for icu 

[18:52] <vcv--> have an abstract layer for scripting and put libperl in there for now.

[18:53] <integral> I thought the icu dep was dead now?

[18:53] <autrijus> icu dep is gone.

[18:53] <autrijus> thank eris.

[18:55] <PerlJam> oh good.  /me hasn't paid too close attention to his parrot build

[18:55] * autrijus starts thinking a bad thought.

[18:55] * autrijus tries to make it stop.

[18:55] <PerlJam> even still, an icu-less parrot is freaking huge.  ;)

[18:55] <autrijus> 2609k active isn't _that_ bad :)

[18:56] <autrijus> esp. when it can be shared among all processes

[18:56] <autrijus> that is a good design, I think

[18:56] <vcv--> hows the Win32 version(s) of pugs? no difference from the *nix version?

[18:56] <autrijus> vcv--: there are some minor differences

[18:56] <autrijus> similar to how win32 perl vs unix perl

[18:56] <autrijus> concerning blocking, thread behaviour, sockets, etc

[18:57] <autrijus> (and you don't have symlink() and link() yet)

[18:57] <PerlJam> autrijus: yeah, I'm still adjusting to the economics of plenty.  I have vivid memories of when memory/disk/etc. *weren't* cheap or easy to come by

[18:57] <autrijus> but otherwise should be the same

[18:57] <autrijus> PerlJam: me too.

[18:57] <vcv--> ah..gotcha. to only differences are related to the different architecture in the platforms

[18:57] <autrijus> "I still remember when a hard disk is less than one gigabyte!"

[18:57] <autrijus> "er, what is a gigabyte?"

[18:57] <vcv--> haha :)

[18:57] * theorbtwo still remembers when hard drives were near-mythical.

[18:57] <jhorwitz> autrijus: i want eval_parrot to output literal PIR when using the parrot backend, but can't seem to get around its being assigned to a PMC reg.  ideas?

[18:58] <vcv--> I'm sacrificing memory efficiency for performance in my app. some stuff uses more memory than i could make it, but the advantage is performance gains.

[18:59] <PerlJam> theorbtwo: Do you mean "near mythical to ordinary people"  or "near mythical" in general?

[18:59] <theorbtwo> To ordinary people.

[18:59] <theorbtwo> I'm not that old.

[18:59] <PerlJam> just checking ;-)

[18:59] <autrijus> jhorwitz: what do you want literal pir for?

[18:59] <PerlJam> I remember saving my programs to tape

[18:59] <PerlJam> and 8" floppies

[18:59] <autrijus> jhorwitz: in external parrot mode we already do literal pir

[19:00] <autrijus> that's what _DoCompile gives you

[19:00] <jhorwitz> autrijus: i can use it as a stub for missing functionality in mod_pugs HLL layer 

[19:00] <PerlJam> fortunately though, I never used punch cards

[19:01] <vcv--> Can pugs or parrot make sandwiches yet? seems like the only thing left on the list of things it cant do.

[19:01] <jhorwitz> vcv--: if you write a test for it, it will eventually.  ;-)

[19:02] <gaal> @sandwich = bum_generator Y $filling, no?

[19:02] <autrijus> jhorwitz: sure

[19:02] <vcv--> Nice! :P

[19:03] * autrijus resumes the train of bad idea

[19:03] <jhorwitz> autrijus: will check it out -- thanks

[19:03] <gaal> bun_generator, actually, would probably make for better sandwiches.

[19:03] <vcv--> Y eq zip operator?

[19:04] <PerlJam> vcv--: yep

[19:04] <PerlJam> (ish)

[19:04] * autrijus still wants YY

[19:04] <vcv--> Didn't know if that was valid or gaal just didnt want to type the real op :p

[19:04] * gaal wants $$$

[19:05] <gaal> autrijus, what would YY do?

[19:05] <vcv--> 

[19:05] <PerlJam> gaal: analogous to x and xx

[19:05] <gaal> that works too, vcv--

[19:06] <gaal> ah, interleave whole lists?

[19:06] <gaal> would that preserve their lazines?

[19:06] <vcv--> I assume p6/parrot will support unicode out of the box. Meaning, there won't be an aSCII version and a Unicode version?

[19:06] <gaal> 1 .. Inf YY ("never seen")     ?

[19:06] <PerlJam> vcv--: that's the plan!

[19:07] <vcv--> Aw. damn unicode overhead :(

[19:07] <autrijus> gaal: YY is like Y but get shortest.

[19:07] <PerlJam> vcv--: what overhead?  It's only there if you use it just like anything else.

[19:07] <autrijus> vcv--: the entire unicode overhead is 32360 bytes :)

[19:08] <autrijus> (in executable size, if you only use utf8 and basic level 1 support)

[19:08] <wolverian> I need something to code in perl6.

[19:08] <PerlJam> autrijus: perhaps he was thinking of the cognitive overhead?

[19:08] <vcv--> Hey! let me illogical hate unicode in peace :)

[19:08] <vcv--> illogically

[19:08] <PerlJam> wolverian: wordfind

[19:08] <wolverian> PerlJam: what's that?

[19:08] <PerlJam> wolverian: troll MJD's qotw

[19:08] <theorbtwo> vcv, we like unicode around here.

[19:08] <theorbtwo> Note the AUTHORS file.

[19:09] <vcv--> Yes. I'm just joking, no offense meant :)

[19:09] <PerlJam> theorbtwo: My god, it's full of foreigners!  ;-)

[19:09] * autrijus finishes the train of bad idea.

[19:09] <PerlJam> autrijus: did it wreck?

[19:09] <autrijus> no, it works

[19:09] <autrijus> I think pugs OO may need to wait a couple days so I can spike this :)

[19:09] * autrijus decides to write Inline::Perl6 (without Inline::GHC)

[19:10] <vcv--> autrijus: did you implement ./ for method calls on the invocant or is that not a finalized decision?

[19:10] <ninereasons> it'

[19:10] <autrijus> vcv--: that is as finalised as we can get (larry said go ahead)

[19:10] * PerlJam thinks of /. everytime he sees ./  

[19:10] <ninereasons> it's part of wizard.p6, vcv-- 

[19:10] <vcv--> I thought that too at first, PerlJam. Made my blood boil for a minute ;) But I like it

[19:11] <autrijus> you can define the /. operator

[19:11] <autrijus> sub prefix:</.> { "troll $_ dup $_ dup $_ troll" }

[19:11] <autrijus> or something like that.

[19:11] <vcv--> hahaha :)

[19:12] <theorbtwo> karma vcv

[19:12] <autrijus> pugs> sub prefix:</.> { "troll $_ dup $_ dup $_ troll" }

[19:12] <autrijus> pugs> /. <SCO>

[19:12] <autrijus> 'troll SCO dup SCO dup SCO troll'

[19:12] <autrijus> works just fine

[19:12] <vcv--> why the <>?

[19:12] <autrijus> it looks better than '' and ""

[19:12] <autrijus> :)

[19:13] <autrijus> the perl 6 <> is perl 5's qw()

[19:13] <vcv--> Heh.. ok.

[19:13] <vcv--> qw() is so ugly

[19:13] <wolverian> hrm. does anyone know of a clean way to use the debian ghc packages on ubuntu hoary? debian ghc6 wants to upgrade my cpp packages to the debian versions, which strikes me as risky..

[19:13] <autrijus> hm. Inline::Perl6 or Inline::Pugs?

[19:13] <autrijus> or Inline::Perl6::Pugs?

[19:13] <autrijus> opinions?

[19:13] <Corion> wolverian: Install Debian in a chroot jail? :)))

[19:13] <wolverian> Corion: don't mock me. :)

[19:14] <Corion> Inline::Perl6 - you can exchange Pugs and Perl6 later :-)

[19:14] <vcv--> What for autrijus?

[19:14] <ihb> Inline::Perl6::Pugs.

[19:14] <autrijus> vcv--: for a CPAN module that lets you mix perl6 code with perl5.

[19:15] <integral> Inline::Pugs

[19:15] <autrijus> vcv--: by basically running an external pugs process in harness mode.

[19:15] <autrijus> oh wow. three people, three different options

[19:15] <autrijus> that's very diversed :)

[19:15] <vcv--> Inline::Pugs

[19:15] <theorbtwo> Inline::Perl6::Pugs or Inline::Pugs both sound good to me.

[19:16] <autrijus> it looks like Inline::Pugs is winning then :)

[19:17] <vcv--> Inline::Perl6UsersGolfingSystem

[19:17] <ihb> vcv-- and integral: why Inline::Pugs over Inline::Perl6::Pugs?

[19:17] <vcv--> :)

[19:17] <Corion> mmm. I think that ghc system() is at least as broken as Perl5 Win32 system() -- does anyone have experience with GHC system() vs. quoting ?

[19:17] <integral> there's no need to a) broadcast it's perl6, we know, and b) no need to prevent name space pollution

[19:17] <vcv--> I think Inline::Perl6::Pugs is a bit redundant

[19:17] <autrijus> Corion: there's a nonescaped way

[19:17] <castaway> Inline::Pugs++

[19:17] <autrijus> probably the same reason as why it's not Inline::Scheme::MzScheme but Inline::MzScheme

[19:17] <vcv--> Pugs has "Perl6" in it already ;)

[19:17] <autrijus> vcv--: mm very good point!

[19:17] <Corion> autrijus: On Win32, system(@list) is , more or less, system("@list")

[19:18] <theorbtwo> The "we know" argument depends on the value of "we".

[19:18] <Corion> ... so the program has to do some param encoding.

[19:18] <integral> well when real people start using perl6 there'll hopefully be a real perl6 called perl6...

[19:18] <Corion> I think I should add the tests I have for Perl5 and then maybe make Pugs better than Perl5 :)

[19:19] <ihb> when inlining a language i think the existing pattern on CPAN is Inline::<lang>, and Pugs isn't the language (is it?).

[19:19] <Corion> integral: Yeah. It would be a shame if Perl6 remained restricted to us irc bots ...

[19:19] <autrijus> Corion: invoke it like

[19:19] <autrijus> system("cmd", @list)

[19:19] <integral> well what Pugs implements isn't perl6 really, ihb ...

[19:19] <autrijus> still badly escapes?

[19:19] <theorbtwo> It isn't, integral?

[19:19] <castaway> they're not all that schema ihb, iirc

[19:20] <integral> It can't be surely?   We didn't have user-defined operators until yesterday for example

[19:20] <autrijus> ihb: there's really no pattern :)

[19:20] <ihb> castaway: some Inline modules aren't about languages at all, e.g. Inline::Files, but i don't count them right now :-)

[19:20] <integral> and there's ./ which isn't in the spec

[19:20] <autrijus> Inline::Guile, eg

[19:20] <Corion> autrijus: That won't work with quoting. I'm quite sure of that, but I'll check, of course ;)

[19:21] <stevan> iblech++ # fp.pm is soooo cool

[19:21] <stevan> howdy all :)

[19:21] <theorbtwo> integral: Well, it aims to be perl6, in the limit.

[19:21] <autrijus> hey stevan-san

[19:21] <iblech> stevan: Thanks :)

[19:21] <theorbtwo> as t -> Inf, pugs -> perl6.

[19:21] <ihb> autrijus: now that's a good reason to call it Inline::Perl6::Pugs because i had no idea Guile was a scheme interpretor. :-)

[19:21] <castaway> Inline::Guile - Inline module for Guile Scheme interpreter

[19:21] <autrijus> ihb: rofl!

[19:21] <vcv--> noo. too redundant!

[19:22] * theorbtwo thought Guile was a dialect of scheme, not simply an implementation of it.

[19:22] <theorbtwo> (Reminds me, I wanted to start doing the MIT OCW...)

[19:22] <stevan> iblech, autrijus: I think we need to think about perl6 and the ICFP contest :)

[19:22] * castaway shrugs

[19:22] <ihb> theorbtwo: yeah, that's probably more correct.

[19:22] <autrijus> stevan: yes :)

[19:22] <Corion> How soonish is the next release planned? Next Monday?

[19:22] <autrijus> Corion: that's the idea

[19:22] <autrijus> monday my time, sunday probably your time

[19:22] <autrijus> with changelog and bugfix in weekend

[19:22] <autrijus> i.e. as usual.

[19:22] <Corion> Ah - so I have a bit of time to put in (failing) system() tests and maybe even fix these.

[19:23] <ihb> Inline::Scheme::Guile, even I get what that module is about... ;-)

[19:23] <autrijus> go ahead :)

[19:23] <Corion> Most likely they'll only break on Win32 anyway.

[19:23] <autrijus> Corion: you know there's no freeze really :)

[19:23] <Corion> autrijus: Yeah, but I don't want to suddenly commit a lot of stuff while everybody else is in preflight ;-)

[19:24] <autrijus> Corion: it will simply result in all those stuff being force_todo'ed, marked out of MANIFEST, or simply ignored :)

[19:25] <vcv--> I need to get my hands dirty with Win32 stuff in Pugs. thats my area of expertise

[19:25] <Corion> vcv--: Welcome to the club ;)

[19:25] <autrijus> vcv--: then learn from Corion :)

[19:25] <vcv--> woohoo, not alone!

[19:26] <vcv--> i do find it funny that I love perl so much and what its capable of, but dont use or even really like *nix

[19:26] <Corion> autrijus: I think I'll include a small Win32 .exe file just like Perl5 does - we don't want to rely on a C compiler being available, do we?

[19:26] <Corion> vcv--: The OS is merely a way to run Perl

[19:26] <autrijus> Corion: perl5 includes a small win32.exe?

[19:26] <vcv--> yes yes i know

[19:26] <vcv--> Write your own C compiler :)

[19:26] <Corion> autrijus: The test suite for system() does.

[19:26] <autrijus> oh. that.

[19:27] <autrijus> sure, go ahead

[19:27] <autrijus> include a copy of its source :)

[19:27] <Corion> autrijus: I have a suite of tests for Perl5 and what I think is a good fix, but I never got around to actually patch Perl5

[19:27] <ninereasons> there doesn't seem to be a quote operator that has quote protection, yet.  Is that so, or am I wrong ?

[19:27] <Corion> autrijus: It comes with source and tries to compile it before uudecoding it :-)

[19:27] <Corion> ninereasons: "quote protection"?

[19:27] <vcv--> Well, that wouldnt be so bad. A hello world .NET application (just a form and a "hello world" label) uses 12MB of memory

[19:27] <ninereasons> <<a b "a and b">>

[19:27] <ninereasons> ('a', 'b', '"a', 'and', 'b"')

[19:28] <Corion> ninereasons: Maybe you want \a0 - nonbreaking whitespace?

[19:28] <autrijus> is <<>>  specced to offer quote protection?

[19:28] <Corion> (but no, there is no such protection that I'm aware off)

[19:28] * theorbtwo can write something that win32 will interpret as a foo.exe in 2 bytes.

[19:28] <ninereasons> I believe so, autrijus

[19:28] <ninereasons> S02

[19:28] <vcv--> theorbtwo: ???

[19:28] <Corion> theorbtwo: The .exe has to echo back the command line ;)

[19:28] <autrijus> ok. bug then, write test, link to S02 :)

[19:28] <theorbtwo> 0xF0 0x0F

[19:29] <vcv--> hold on lemme open up my masm32 manual :p

[19:29] <ninereasons> yes sir, autrijus 

[19:29] <ninereasons> :)

[19:29] <Corion> 0xF0 is jump near I think

[19:29] <autrijus> ninereasons++

[19:29] <Corion> "++" is like conditioning of dogs, dolphins or other animals after they've performed a neat trick :-)))

[19:29] <autrijus> Corion: you can write a small "haskell" application ;)

[19:30] <vcv--> F0 = lock

[19:30] <autrijus> Corion: and build it with pugs. or even use pugs itself

[19:30] <Corion> autrijus: Aaaah - interesting idea! Except that I then get Haskell command line parsing.

[19:30] <vcv--> what does "lock" do on x86? never seen it

[19:30] <Corion> autrijus: I don't trust pugs - I want to test the pugs command line construction via system(@list)

[19:30] <theorbtwo> Does nobody but me remember the 0xF00F bug?

[19:30] <autrijus> Corion: no, not really

[19:30] <Corion> vcv--: It locks the bus - I've never used the instruction, but I think it was when the math coprocessor was still in use

[19:31] * castaway has a cpu with that bug

[19:31] <vcv--> gotcha.

[19:31] <vcv--> 0xF00F isnt a single instruction then is it?

[19:31] <theorbtwo> It's a single instruction with a prefix.

[19:31] <autrijus> Corion: 

[19:31] <autrijus> foreign import ccall unsafe "getProgArgv" getProgArgv :: Ptr CInt -> Ptr (Ptr CString) -> IO ()

[19:32] <autrijus> then

[19:32] <autrijus>   alloca $ \ p_argc ->

[19:32] <autrijus>   alloca $ \ p_argv -> do

[19:32] <autrijus>      getProgArgv p_argc p_argv

[19:32] <vcv--> hm. well this op code list i have says 0F is a prefix, and F0 is "lock"

[19:32] <autrijus>      argv <- peek p_argv

[19:32] <autrijus> that's all

[19:32] <Corion> autrijus: Aaah - but on Win32, ProgArgv is not an array but a string ;)

[19:32] <vcv--> so im just confused by F00F

[19:32] <autrijus> Corion: then you print that string

[19:32] <autrijus> :)

[19:32] <theorbtwo> Yeah, it confused the CPU too.

[19:32] <vcv--> Oh, gotcha :p

[19:32] <autrijus> oh wait, I'm not making sense am I

[19:32] <vcv--> so you were just being a bastard, heh.

[19:33] <autrijus> you need some API call to get the original string

[19:33] <vcv--> not a fan of Win32 eh?

[19:33] <autrijus> whatever you do in that small C program, 

[19:33] <autrijus> just FFI it

[19:33] <Corion> autrijus: I'll look at it - but if that gets me around using/implementing uudecode (pack/unpack), that's fine ;)

[19:33] <Corion> autrijus: yeah - FFI is easy now, at least for me ;)

[19:33] <vcv--> autrijus: API to get the command line arguments?

[19:33] <theorbtwo> It was a CPU bug, not a OS bug.  (Though it can be worked around in the OS.)

[19:33] <vcv--> oh. duh.

[19:33] <autrijus> Corion++ # "easy"

[19:34] <theorbtwo> The point is that win32 will happly execute a old-sk00l .com file named foo.exe.

[19:34] <theorbtwo> ...which is useful when you want to produce very small executables.

[19:34] <vcv--> like 5 bytes

[19:35] <theorbtwo> Yeah.

[19:35] <theorbtwo> If I had my peter norton asm book, I'd write one.

[19:35] <vcv--> a COM file is just basically an EXE with no headers?

[19:36] <theorbtwo> It's just a plain memory image.  It's loaded at offset 0x100 from the beginning of a sector, and the first byte JMP'd to.

[19:36] <theorbtwo> (The first 0x100 bytes are the PSP.)

[19:37] <vcv--> gotcha. i always just thought it was a different formatr

[19:39] * theorbtwo grrs.

[19:40] <theorbtwo> GNU Make should have a default Makefile.PL -> Makefile rule.

[19:42] <putter> autrijus: re pony, yes.  (back from a call, will have externalpge tests done in a bit...)

[19:43] <Darren_Duncan> I have a question about the include directories

[19:43] <Darren_Duncan> I wonder why '.' is last on the list rather than first?

[19:44] <Darren_Duncan> I considered reporting that as a bug in Pugs, but then saw that Perl 5 did it too, so figured there may be a reason

[19:44] <vcv--> I hate makefiles with a passion. am i the only one?

[19:45] <theorbtwo> Keeps attackers from overriding some well-known module in the CWD, and hoping an admin will do something from that dir.

[19:45] <Darren_Duncan> in my mind, '.' is like a local scope of sorts, and it usually makes sense for items of the same name there to override others, such as if you are testing an upgrade to one

[19:45] <theorbtwo> vcv--: I hate Make too.

[19:45] <theorbtwo> Allo, nothingmuch.

[19:45] <Darren_Duncan> but now that I think of it, as you say, security seems to be a great big reason in favor of the current system

[19:45] <nothingmuch> evening

[19:45] <nothingmuch> seen autrijus 

[19:46] <nothingmuch> seen autrijus?

[19:46] <Darren_Duncan> a few minutes ago

[19:46] <castaway> 10 minutes ago, nm

[19:46] <vcv--> when im working on a project in c/c++, i just want to add the files to a project file, and let the compiler decide what to do

[19:46] <putter> yeah!  no-hang.  it's still different though.  anchors.t gives a nice 12/19 TODO bug tests on embedded, but on external...:

[19:46] * theorbtwo last saw autrijus at 21:33

[19:46] <putter> t/aaa/anchors...................................ok 19/19# Looks like you failed 1 tests of 19

[19:46] <vcv--> i dont want some 10kb file describing how to compile it

[19:46] <putter> t/aaa/anchors...................................FAILED test 5

[19:46] <putter>         Failed 1/19 tests, 94.74% okay

[19:47] <nothingmuch> which bot does the seen stuff?

[19:47] <putter> my Test-fu isn't good enough to immediately tell what's happening.

[19:47] <Corion> putter: pugs -Iblib6\lib -w t/aaa/anchors

[19:47] <Corion> putter: pugs -Iblib6\lib -w t/aaa/anchors.t # I meant

[19:48] <vcv--> Makefiles are like women. gotta get every detail right. huge complicated list of how things need to be done. instead of just doing it.

[19:48] <theorbtwo> perlbot: seen theorbtwo

[19:48] <theorbtwo> jabbot: seen theorbtwo

[19:48] <theorbtwo> ...or not.

[19:49] <castaway> silly bots

[19:49] <Darren_Duncan> maybe the bot is down at the moment?

[19:49] <Darren_Duncan> someone used seen within the last 2 days, and it worked then

[19:50] <autrijus> hi nothingmuch.

[19:51] <autrijus> I'm almost done with first cut of Inline::Pugs

[19:51] <autrijus> a sec

[19:51] <Corion> seen theorbtwo

[19:51] <nothingmuch> oooh

[19:51] * theorbtwo can see theorbtwo's hands typing.

[19:51] <autrijus> I think it makes sense to put it within lib/Inline/Pugs.pm.

[19:51] <autrijus> in the pugs tree

[19:51] <autrijus> (I think.)

[19:51] <Corion> Does Pugs have "do $file" ?

[19:51] <nothingmuch> i think so to

[19:52] <nothingmuch> o

[19:52] <autrijus> Corion: no, and I think that's gone

[19:52] <Corion> autrijus: Too bad :)

[19:52] <nothingmuch> how does Inline::Pugs do the glue? GHC in perl?

[19:52] <autrijus> nothingmuch: eventually.

[19:52] <autrijus> currently it uses this clever thing

[19:53] <autrijus> my $ZZZ= =$*IN;while 1{$_=perl eval eval=$*IN;say$!//$ZZZ;print$x;flush$*OUT}

[19:54] <theorbtwo> ENOTENOUGHSTROKES

[19:54] <nothingmuch> oh my

[19:54] <autrijus> er, I mena

[19:54] <autrijus> my $ZZZ= =$*IN;while 1{$_=perl eval eval=$*IN;say$!//$_;print$ZZ;flush$*OUT}

[19:54] <nothingmuch> it's like use forks

[19:54] <autrijus> s/ZZZ/ZZ/

[19:54] <theorbtwo> How can the other end tell the difference between $! and $_ in the output?

[19:54] <autrijus> it is.

[19:54] <autrijus> theorbtwo: one will always be one line

[19:54] <autrijus> and one will be multiline ;)

[19:55] <theorbtwo> Ah, IWFM.

[19:55] <putter> Corion: thanks!

[19:56] <nothingmuch> the guy who sold us the house is anti wifi. Appearently there was a sale on concrete

[19:57] * theorbtwo decides to skip the jokes about bomb-resistant archetechture.

[19:59] *** Aankh|Clone is now known as Aankhen``

[20:01] <putter> autrijus: while it worked once, I'm now seeing a consistent minute and a half delay.  I todo'ed the test which was

[20:01] <autrijus> okie.

[20:03] <putter> behaving differently embedded vs extended.  the delay seems to occur after the final test is run, and the "# Looks like you failed" line if there is going to be one.

[20:04] <putter> ie, with ./pugs -Iblib6/lib -w t/aaa/anchors.t , one gets the full test report, and then 1min30ish goes by before the process terminates.

[20:05] <putter> it's waiting quietly, no computes.

[20:09] <putter> autrijus: err, could multiple test runs be stomping on each other?  I just cleared out all pugs-like processes, and its working consistently.  now I can't duplicate the failue... err...

[20:14] <autrijus> putter: yes, they could (and would)

[20:16] <ajs> "theorbtwo has quit ("Lost terminal")" ... hmmm that's in Australia somewhere, right?

[20:16] <stevan> autrijus: I have a question about object instance creation if you have a moment

[20:17] <autrijus> yes?

[20:18] <stevan> I saw when you were talking to nothingmuch that objects are currently data only

[20:18] <autrijus> yes.

[20:18] <stevan> and they are basically like this (type, hash of instance vars, id)

[20:18] <stevan> actually I have 2 questions :)

[20:19] <stevan> 1) is the Type worthy of a full blown object in the MetaModel?

[20:19] <putter> autrijus: it looks like if a test run is interrupted, it may leave behind processes which can then affect subsequent test runs.  though I haven't managed to get the same magnitude of delay as previously observed...

[20:19] <stevan> 2) do you copy the instance var defaults? or just do a COW for defaults

[20:21] <putter> I would have thought test runs would be independent, using random filenames etc... :/

[20:23] <autrijus> woot, worked.

[20:24] <autrijus> stevan: Type is just Class.

[20:24] <autrijus> although junctive types may pose problems

[20:24] <putter> ok, test hang looks dealt with.  thanks autrijus.  anythoughts on whether it should mutate into "figure out why test runs arent independent and make them so", or simply declare success and move up the stack?

[20:25] <autrijus> but they it's just junctive object with class as members

[20:25] <stevan> autrijus: where in the Haskell is it?

[20:25] <svnbot6> r3404, autrijus++ | * First cut at Inline::Pugs

[20:25] <autrijus> stevan: Types.hs, data Type

[20:25] <stevan> ok

[20:26] <_metaperl> how are hyperoperators coming along? hope i'm not interrupting...

[20:27] <stevan> ok so I can convert that into a simple class for now

[20:28] <stevan> I wont worry yet about junctive types

[20:31] <autrijus> _metaperl: iblech is doing those metaops

[20:31] <stevan> autrijus: where is the code for Object creation ?

[20:31] <autrijus> stevan: Prim, "new"

[20:31] <autrijus> fg

[20:32] <autrijus> err, ww

[20:39] <autrijus> use Inline Pugs => '

[20:39] <autrijus>     sub postfix:<!> { [*] 1..$_ }

[20:39] <autrijus>     sub sum_factorial { [+] 0..$_! }

[20:39] <autrijus> ';

[20:39] <autrijus> print sum_factorial(3); # 21

[20:40] <Shillo> Hullo, all. :)

[20:40] <putter> PerlJam: re "embedded parrot" sounding strange, Lua for instance has that as a major use case.  re adjusting to plenty, you could always switch to cellphones...

[20:41] <integral> autrijus: is that embedded pugs in interpreter mode or running using an embedded parrot?

[20:41] <Shillo> putter: Funny you should mention it. I'm connected and do all my svn access through my cellphone... :)

[20:41] <autrijus> integral: no, it's external interactive process.

[20:42] <autrijus> integral: same thing as extern pge in src/pge/

[20:42] <integral> oh, pity :-)

[20:42] <Shillo> putter: And it could prolly run parrot, at least if carefully compiled down to size. 20 megs of RAM, expandable to 256 megs... cheaply.

[20:42] <svnbot6> r3405, autrijus++ | * more fixes to inline pugs; proper escaping and multiple subs.

[20:43] <putter> Shillo: ;)

[20:43] * Shillo scratches his head. A devel question: I have troubles with UTF-8. They come as line noise. Not sure where to begin to track it.

[20:44] <Shillo> That is, in gnome-term and vi.

[20:44] <Corion> Shillo: Only with Pugs or also with other programs?

[20:45] <Shillo> Ctrl-K << works as expected when vi runs fresh. I think svn munges my encoding.

[20:46] <Shillo> Hm, gah. man svn is being useless on me.

[20:48] <Corion> Hmmm - what was the equivalent of $^X in Perl6 again? Do we have it at all?

[20:48] <Shillo> putter: I wasn't kidding about the cellphone, BTW. It's my primary net access.

[20:52] <Shillo> Corion: I think svn requires charset among the metadata. Thing is, why is it working for everyone else?

[20:52] <Corion> Shillo: Dunno, but it worksforme. But I use Win32

[20:53] <Shillo> Corion: Defaultix, here. Linux, in other words. :)

[20:53] <mugwump> Shillo: perhaps you need to select a UTF-8 locale?

[20:53] <mugwump> or use emacs of course :)

[20:53] <svnbot6> r3406, autrijus++ | * docs, etc.

[20:54] <Shillo> mugwump: Was broken in emacs, too. svn co'ed the broken files.

[20:55] <Shillo> mugwump: Using ext/fp/lib/fp.pm for testing.

[20:55] <Shillo> sub infix:<~H~X> (Code &f, Code &g) { sub($x) { f g $x } }

[20:55] <stevan> hey mugwump :)

[20:55] <mugwump> morning stevan 

[20:55] <Shillo> stevan: Hi. :)

[20:55] <stevan> mugwump: I moved some of the comments in the test files to the meta-model doc

[20:55] <stevan> hey Shillo 

[20:56] <stevan> That is some good stuff :)

[20:57] <stevan> mugwump: I am kind of stuck on the instance creation stuff

[20:57] <stevan> any thoughts?

[20:58] <Shillo> Eh. Note to self: Don't press CTRL-ALT-LEFT while backspacing...

[20:59] <mugwump> stevan, you're talking about instances of Classes / Objects?

[20:59] <svnbot6> r3407, Stevan++ | Perl::MetaModel - adding Property related methods; added tests for these too

[20:59] <svnbot6> r3408, ninereasons++ | add functions to perl6.vim; add :todo<bug> tests to quoting.t

[21:00] <vcv--> svn. yay. good to see cvs is not being used.

[21:00] <stevan> yes

[21:00] * Shillo scratches his head about this.

[21:00] <Shillo> mugwump: Could you paste me your $LOCALE and $CHARSET?

[21:00] * Shillo isn't sure $CHARSET exists. :)

[21:01] <stevan> mugwump: yes, how should I represent an instance

[21:02] <stevan> how do I create that reprsentation

[21:02] <stevan> etc

[21:02] <stevan> is an instance just an instance of Perl::Meta::Class?

[21:02] <mugwump> Shillo: well, I use LANG=en_NZ.UTF-8 and LC_CTYPE=en_NZ.UTF-8.  But then, I don't seem to get good unicode support in my xterms

[21:04] <revdiablo> why does sub{} create a Sub but ->{} or {} create a Block? I think I found where it happens in Parser.hs, but I'm just wondering why sub{} can't just make a Block?

[21:04] <autrijus> revdiablo: because sub {return} dwim

[21:04] <mugwump> stevan: I don't see anything wrong, at this point, with having a MetaMethod that "applies" the Class object to the current execution environment..

[21:05] <autrijus> revdiablo: and {return} dwim.

[21:05] <putter> autrijus: the following works embedded but not external.  I've started to grovel over run_pge.pir and  Embed/Parrot.hsc, but if you wanted to...;)

[21:05] <putter> pugs> "\n" ~~ m/\n/

[21:05] <putter> *** Cannot parse PGE: \n

[21:05] <putter> *** Error: end of file

[21:05] <autrijus> putter: please do... it's 5am here :)

[21:05] <stevan> mugwump: what do you mean by "applies"

[21:05] <autrijus> putter: ping me again tomorrow when I show up if you didn't get it to work

[21:05] <putter> ok.  "your eyelids are groowwwinnng  heaaavvvyyyy"

[21:05] <revdiablo> autrijus: what do they dwim to?

[21:06] <autrijus> revdiablo: sub { return } returns from that sub

[21:06] <autrijus> revdiablo: { return } returns from the enclosing sub.

[21:06] <revdiablo> autrijus: aah

[21:06] <autrijus> while (1) { return 2 if /.../ }

[21:06] <autrijus> vs

[21:06] <revdiablo> autrijus: is that the only difference?

[21:06] <autrijus> while (1) { sub { return 2 if /.../ } }

[21:06] <autrijus> revdiablo: also the magicals are spelled differently: $?SUB vs $?BLOCK

[21:06] <autrijus> I think that's pretty much it

[21:06] <revdiablo> ok, thanks

[21:06] <autrijus> np :)

[21:06] <revdiablo> I just got curious :)

[21:07] <Shillo> mugwump: That solved it. Thanks! :)

[21:07] <Corion> heh - system("program_that_does_not_exist") # is really fatal :)

[21:08] * Corion goes on to create a really basic system.t :)

[21:08] <Shillo> mugwump: (once I told gnome-term to also use UTF-8)

[21:08] <Shillo> Oh. Forgot. mugwump++

[21:10] <mugwump> by "applies", I mean it takes the Class object and makes it recognisable to pugs, probably by (for now) eval'ing a class definition and poking code refs into the right places with ::=

[21:10] <stevan> ok

[21:15] <revdiablo> autrijus: so a sub and a block have a different depth, that's what causes the different return behavior?

[21:15] <svnbot6> r3409, autrijus++ | * Matt Diephouse pointed out that run_pge.pir can easily

[21:15] <svnbot6> r3409, autrijus++ |   turn off buffering for stdin and stdout.

[21:16] <autrijus> revdiablo: right.

[21:16] <autrijus> blocks are shallow.

[21:16] <autrijus> they don't count into the call stack.

[21:16] <autrijus> your CALLER is never a block.

[21:16] <revdiablo> wow, I can actually kind of understand what's going on in this haskell code!

[21:16] <autrijus> they are in the OUTER stack.

[21:16] <revdiablo> :)

[21:16] <autrijus> good :)

[21:24] <ninereasons> I have a friend who's been coding in Haskell since grad school (7 years ago) who tells me he's never seen working code using some of the features that are incorporated into Pugs.  His shop is still partly unconverted from ghc 6.3, which may be why.

[21:24] <svnbot6> r3410, corion++ | Added basic tests for system(LIST)

[21:24] <svnbot6> r3411, ninereasons++ | add a link to the relevant Synopsis

[21:24] <svnbot6> r3412, putter++ | Minor fix of run_pge.pir

[21:24] * Shillo checksout all over again, starts full rebuild. Woot, I Can See Weird Characters.

[21:24] <Shillo> ninereasons: 'shop' - he gets to use Haskell at work?!

[21:25] <ninereasons> yes, Shillo 

[21:25] <ninereasons> crypto

[21:25] * Shillo goes all fuzzy-eyed. :)

[21:25] <autrijus> ninereasons: yeah, Pugs is full of GHC 6.4ism.

[21:25] <autrijus> GADT, STM, TH2 being the top three

[21:25] <revdiablo> ninereasons: his productive insanity knob obviously needs adjustement

[21:26] <ninereasons> I've been trying to get him to read up on Pugs

[21:26] <ninereasons> He's interested, but (although a great guy) he's a bit of a snob, as far as other languages are concerned

[21:26] * Shillo is still going through Haskell docs. And I really feel stupid for being unable to figure what $ does.

[21:27] <mugwump> ninereasons: tell him that Perl 6 is really a dialect of Haskell

[21:27] <mugwump> it just looks like Perl

[21:27] <ninereasons> a good line, mugwump :)

[21:27] <Shillo> mugwump: Is not! :p It's a dialect of Common LISP. :)

[21:29] * Shillo really ought to defmacro a bunch of unicode noise for SBCL... :)

[21:31] <ninereasons> autrijus, he also told me that ghc has some absolutely brilliant optimization features that should make Pugs as fast as anything

[21:31] <autrijus> ninereasons: right, but we are using very few of that yet. :)

[21:31] <ninereasons> when the time is right for that, of course :)

[21:31] <autrijus> in compiler mode, that is

[21:32] <autrijus> Pugs.Compile.Haskell has the potential of being faster in speed than Pugs.Compile.Parrot

[21:32] <autrijus> but it's not priority ;)

[21:32] <autrijus> <- sees Parrot codegen as more urgent

[21:32] <autrijus> another thought is Pugs.Compile.Grin and hand it to Jhc. maybe.

[21:32] <autrijus> but it's all empty speculation :)

[21:33] <osfameron> is anyone building Pugs.Compile.JVM ?

[21:33] <autrijus> osfameron: no

[21:36] <Shillo> osfameron: It's be more interesting to compile Java bytecode to Parrot. :)

[21:36] <Shillo> s/It's/It'd

[21:36] <osfameron> true

[21:37] <osfameron> someone already started that iirc?

[21:37] <ninereasons> btw, Shillo, I'm speaking from my _ss but I think that the $ sprinkled throughout src/ is Haskell spoken with a local accent

[21:38] <osfameron> oh, acme did # http://www.nntp.perl.org/group/perl.perl6.internals/9816

[21:38] <Shillo> ninereasons: Er... huh? :)

[21:38] <Shillo> ninereasons: I've actually been digging through Haskell docs trying to figure what it does. My best guess is apply

[21:38] <ninereasons> it's something that autrijus uses a lot, but I don't think it's in the books -- if I recall a past discussion correctly

[21:39] <Shillo> It is, found it in ghc examples

[21:39] <ninereasons> ah

[21:39] <Shillo> But I still can't figure what it does. :p

[21:39] <integral> the $ operator?

[21:39] <Shillo> integral: Yeah

[21:40] <ninereasons> yes, integral 

[21:40] <integral> It's apply but with a different precedence to juxtaposition

[21:40] <Shillo> integral: My guess was something like that... what's the argument order?

[21:40] <Shillo> arg $ fn ==> fn arg ?

[21:40] <integral> compare: foo bar baz {- passes bar and baz as args to foo -}; vs. foo $ bar baz {- passes baz to bar to foo -}

[21:40] <integral> it's function $ argument

[21:41] <Shillo> Oh.

[21:41] <Shillo> I tend to use foo (bar baz) for that. But that's my speech disorder. LISP. ::)

[21:42] * Shillo itches to utter ,',,@<> in a real LISP code.

[21:42] <Shillo> (and yes, that's legal)

[21:42] <Shillo> (provided you use <> as a variable name :) )

[21:45] <wolverian> is anyone else seeing \"s in Thomas Sandlaß's From: header on p6l?

[21:45] <mugwump> Looks like a weierstrauss to me

[21:46] <mugwump> er, I mean sharp s

[21:46] <Shillo> No, garbled for me.

[21:46] <Shillo> But xchat isn't running with UTF-8 environment.

[21:46] <mugwump> From: =?ISO-8859-1?Q?=22TSa_=28Thomas_Sandla=DF=29=22?= [email@hidden.address]
[21:46] <Shillo> I really need to look into Ubuntu default env. :p

[21:46] <wolverian> mugwump: ew. what the hell is that?

[21:46] <mugwump> I think it's an iso-8859-1 entity

[21:46] <mugwump> that's the raw header

[21:47] <wolverian> hmm. thanks. 

[21:47] <wolverian> is that valid?

[21:47] <Shillo> Hmm, can't read my list mail from here. Sorry 'bout the non-info.

[21:47] <revdiablo> Shillo: if ubuntu is still enough like debian, you'd need to install locales, build an en_XX.UTF8 locale, and set that as your default

[21:47] <wolverian> and how should it display? I see \"TSa ...\"

[21:47] <mugwump> works in Thunderbird

[21:47] <wolverian> which looks just weird.

[21:47] <wolverian> Shillo: sudo dpkg-reconfigure locales

[21:47] <revdiablo> Shillo: install or reconfigure locales, depending

[21:48] <wolverian> although hoary is in UTF-8 by default

[21:48] <wolverian> and there's a migration tool in main if you need that.

[21:49] <wolverian> mugwump: what does "works" mean? as in, what should it display?

[21:50] <wolverian> mugwump: I see the sharp s (where his email address itself has 'ss'), but the surrounding entities come out as '\"' 

[21:50] <mugwump> \x{00df} - small sharp s.  Looks a bit like a B.  See also http://masculinehygiene.com/sburke/unicode_sliderule/

[21:50] <wolverian> (without the single quotes)

[21:50] <wolverian> mugwump: no. that I can see. :)

[21:50] <Shillo> wolverian: I'll have to read up on the stuff, too. So, that'll wait for a while. :)

[21:50] <mugwump> oh, ok

[21:50] <wolverian> Shillo: sure. :)

[21:50] <Shillo> wolverian: But thanks for the advice. :)

[21:50] <wolverian> mugwump: just wondering what the hell the surrounding entities are supposed to be.

[21:50] <wolverian> Shillo: no problem. 

[21:51] <Shillo> Failed 36/269 test scripts, 86.62% okay. 174/5160 subtests failed, 96.63% okay. (3409) This normal?

[21:51] <mugwump> I see it as: Tsa (Thomas Sandlaß)

[21:51] <wolverian> hrm.

[21:52] <wolverian> hmm. vim shows the raw header, mutt shows \"

[21:53] <mugwump> conclusion: we hate software!

[21:53] <wolverian> oh. I think it does the \ because it'd otherwise be an invalid email 

[21:53] <wolverian> as in: ""Thomas ...""

[21:53] <wolverian> because it does _not_ show those in the list header display. right. well. that was confusing, and why does he have double "s there?

[21:58] <iblech> Whoa! I got the [...] reduce metaop working, I think :)

[21:58] <iblech> Will checkin in a minute

[22:01] * Shillo just transcribes his Croatian name into 7-bit. Most computer users here autoconvert within their eye bulbs. :)

[22:01] <Shillo> Saves me soooo much grief.

[22:06] <Corion> From where do I need to import Maybe and Nothing? I (think I) want/need to use them in Prim.hs, but ghc complains they aren't there ..

[22:07] <iblech> Corion: You mean, for example, Just 3 doesn't work?

[22:08] <Corion> iblech: Haven't tried that. Maybe ExitFailure x doesn't work.

[22:08] <Corion> Gah. I should have used Just there. Stupid me. Thanks!

[22:08] <iblech> Corion: It can't, I think, as Maybe is not a constructor, but Just is

[22:08] <Corion> iblech: Yes. I just realized that ;)

[22:16] <integral> ./pugs -e'async { while(1) { say "foo!" } } while(1) { say "bar!" }' appears to be parsed wrong

[22:17] <integral> (I missed out the semi-colon after the async block.)  Shouldn't one be needed after the while?

[22:17] <autrijus> integral: async is not Syn; you need a semicolon

[22:17] <autrijus> while is Syn

[22:17] <autrijus> so it's statement level

[22:17] <integral> yeah, I know, but that's not the problem

[22:17] <autrijus> hence not needed

[22:18] <integral> Why does that whole thing parse as valid?

[22:18] <autrijus> worksforme.

[22:18] <integral> err, you mean without any semicolons it's valid too?

[22:19] <autrijus> $ ./pugs -e'async{while 1 {say"foo"}};while 1 {say"bar"}'

[22:19] <autrijus> no, of course you need the one

[22:19] <autrijus> why wouldn't this parseok?

[22:19] <integral> yes, that's what I *meant* to type,  but I mistyped,  and it parsed the version _without_ semicolons correctly

[22:20] <autrijus> $ ./pugs -e'async{ while 1 {say"foo"}} while 1 {say"bar"}'

[22:20] <autrijus> *** Error:

[22:20] <autrijus> unexpected "{"

[22:20] <integral> I included ()s around the 1s

[22:21] *** _metaperl is now known as metaperl

[22:21] <autrijus> pugs> . async{ while (1) {say"foo"}} while (1) {say"bar"}

[22:21] <autrijus> Noop;

[22:21] <autrijus> Syn "while" {Syn "{}" {1;

[22:21] <autrijus>                        App &say ('bar')};

[22:21] <autrijus>              App &async (Syn "sub" {sub {...}})}

[22:22] <autrijus> postfix while!

[22:22] <autrijus> of course it works!

[22:22] <integral> but doesn't postfix while need a semicolon after it?

[22:22] <autrijus> not if it's lone sentence

[22:22] <integral> ie. async{ while (1) {say"foo"}} while (1) ; {say"bar"}

[22:22] <autrijus> it's like

[22:22] <autrijus> ./pugs -e '1 while 2'

[22:22] <autrijus> (1){say "bar"}

[22:22] <autrijus> is parsed like

[22:22] <autrijus> 1{say "bar"}

[22:22] <autrijus> hash subscript

[22:23] <autrijus> 1.{say "bar"}

[22:23] <integral> ah

[22:23] <autrijus> now the fact that ) globs trailing whitespace

[22:23] <autrijus> is Wrong.

[22:23] <autrijus> (1) { foo }

[22:23] <integral> this is just a little confusing all...

[22:23] <autrijus> should not be parsed as (1).{foo}

[22:23] <autrijus> commit a test?

[22:23] <autrijus> I think somewhere in Parser, parens shoudl be written as verbatimParens

[22:23] <integral> pugsbugs?

[22:23] <autrijus> yeah

[22:25] <integral> err, how do I run just one test file again?

[22:26] <integral> ah, just the blib

[22:26] <mugwump> PERL6LIB=/path/to/pugs/blib/lib pugs t/foo.t

[22:27] <mugwump> is what I use

[22:27] <eric256> blib?  why not just 

[22:27] <eric256> pugs t/foo.t   ?

[22:27] <integral> you need Test.pm

[22:27] <mugwump> er, blib6/lib

[22:28] <mugwump> and I don't `make install'

[22:28] * integral never uses make install in development

[22:33] <eric256> i don't use make install either... hmm i don't have any PERL6LIB set either.. windows can be an odd beast sometimes

[22:33] <svnbot6> r3413, bsmith++ | Added pugsbugs test to check that parens are not eating spaces that appear

[22:33] <svnbot6> r3413, bsmith++ | after them.

[22:33] <svnbot6> r3414, iblech++ | Autogenerated &prefix:[...]! :)

[22:33] <svnbot6> r3414, iblech++ | (But the parser doesn't seem to accept multichar ops, but that's another story.)

[22:33] <iblech> Haskell++ # damn concise

[22:33] <iblech> Ok, must sleep now

[22:33] <autrijus> iblech: infix:<<>> landed too

[22:33] <autrijus> Set.pm fully functional!

[22:33] <iblech> :))

[22:33] <autrijus> iblech++

[22:34] <iblech> Haskell is fun :)

[22:34] <iblech> Ok, must sleep now =) &

[22:34] <eric256> whats Set.pm do?

[22:34] <autrijus> eric256: implements Sets

[22:35] <autrijus> i.e. hashes with anything as keys and no values

[22:35] * eric256 needs to ask more specific questions. lol

[22:35] <eric256> ....why would you want those?

[22:35] <wolverian> the PDL folk will most certainly want them. :)

[22:35] <autrijus> because sometimes you want to join two arrays together

[22:35] <autrijus> but discount duplicates

[22:36] <autrijus> there's no real good way besides using a Set

[22:36] <autrijus> esp when the array elements are not simple scalars

[22:36] <autrijus> s/scalars/strings/

[22:36] <wolverian> do perl6 hashes stringify the keys?

[22:36] <autrijus> wolverian: by default yes. you can lift it using shape

[22:36] <wolverian> autrijus: ah. thanks.

[22:36] <autrijus> np :)

[22:37] <eric256> all(all(@a) !=:= any(b)) + all(all(@b) !=:= any(a))  ;)

[22:37] <autrijus> eric256: junctions are, incidentally, sets with a flag on it

[22:37] <autrijus> using junctions just to throw that flag away is wasteful :)

[22:37] <autrijus> and it's harder to calculate differences for junctions efficiently

[22:38] <mugwump> The earlier Set.pm used junctions internally.  I was thinking about changing it back

[22:38] <autrijus> oh wow

[22:38] <autrijus> pugs> [<] 1, 2, 3

[22:38] <autrijus> bool::true

[22:38] <autrijus> iblech++

[22:38] <svnbot6> r3415, autrijus++ | * allow infix:Â«Â» and infix:<<>>

[22:38] <svnbot6> r3415, autrijus++ | * Set.pm now accepts `<` `<=` `>=` and `>`.

[22:38] <svnbot6> r3416, iblech++ | Usual svn properties added to t/.

[22:38] <autrijus> iblech++

[22:39] <ninereasons> those reduce operators are very cool, autrijus

[22:40] <autrijus> indeed.

[22:40] <mugwump> hi b6s 

[22:41] <wolverian> hrm. I can iterate over a list two elements at a time. can I do that with map?

[22:42] <integral> just use a two arg block maybe?

[22:42] <mugwump> for @foo -> ($a, $b) { }

[22:42] <mugwump> iirc

[22:42] <autrijus> map doesn't count arity yet

[22:42] <autrijus> not sure if it should.

[22:42] <wolverian> mugwump: yes, I asked about map

[22:42] <wolverian> integral: maybe.

[22:42] <integral> it's sort of intuitive...

[22:42] <autrijus> s29 says it should.

[22:43] <autrijus> so implementors welcome

[22:43] <autrijus> just look at the for() code.

[22:43] <integral> err, the same as for even

[22:43] <autrijus> in Eval.hs for Syn "for"

[22:43] <wolverian> autrijus: it's pretty functional, isn't it? that is, fold the input by the arity

[22:43] <wolverian> ah. okay. :)

[22:43] <autrijus> wolverian: well, it's generalising all the zipWiths :)

[22:44] <autrijus> er, somebody left debug stmt in Eval.hs.

[22:44] <autrijus> please fix

[22:44] <svnbot6> r3417, iblech++ | Oops, forget to remove trace() messages.

[22:44] <svnbot6> r3418, autrijus++ | * repair infix:<>

[22:44] <autrijus> oh. and he did

[22:44] <wolverian> .grep(-> $x, $y { ... }) is mightily ugly though

[22:44] <autrijus> er

[22:44] <wolverian> er. map.

[22:44] <autrijus> .grep{ $^x % $^y }

[22:44] <autrijus> .map:{ $^x % $^y }

[22:44] <autrijus> that's what implicit twigils are for

[22:44] <wolverian> oh. ^foo vars count towards arity?!

[22:44] <autrijus> yes!

[22:45] <wolverian> that's awesome. :)))

[22:45] <autrijus> in fact you can't specify both

[22:45] <autrijus> -> $x { $^y }

[22:45] <autrijus> is illegal.

[22:45] <wolverian> good.

[22:45] <wolverian> (that's confusing.)

[22:45] <autrijus> that's one of the very good things about p6 :)

[22:45] <autrijus> $^key $^value

[22:45] <ninereasons>  my @a = 1..3; map -> $a,$b{ $a+1,$b+1 } @a

[22:45] <ninereasons> (2, 1, 3, 1, 4, 1)

[22:46] <autrijus> ninereasons: it's not yet implemented :)

[22:46] <wolverian> this allowes me to write some lovely OO+FP code.

[22:46] <wolverian> s,allowes,allows,

[22:46] <autrijus> I thought that's the point of p6 :)

[22:46] <ninereasons> sort of semi-implemented, autrijus

[22:46] <wolverian> yes. :)

[22:47] <autrijus> just wait till hypotheticals and nondet :)

[22:47] <autrijus> (and coro across nondets)

[22:47] <wolverian> nondet?

[22:47] <autrijus> nondeterminism.

[22:47] <wolverian> where does that crop up

[22:47] <wolverian> s,$,?,

[22:47] <autrijus> Ovid has been working on it.

[22:47] <autrijus> something like

[22:48] <mugwump> oh, so ([+] @foo) isn't a synonym for foldr(&infix:<+>, @foo)

[22:48] <mugwump> it's actually an operator

[22:48] <autrijus> ensure $x + y == 3;

[22:48] <autrijus> etc.

[22:48] <autrijus> mugwump: it's foldl

[22:48] <integral> mugwump: nope. [+] is done at the syntax level.  It's really a reduce, not a fold

[22:48] <autrijus> because + is leftassoc.

[22:48] <wolverian> isn't + a list op?

[22:48] <wolverian> oh, I guess it doesn't matter. :)

[22:48] <autrijus> no, it's unary and binary

[22:48] <autrijus> but not a listop :)

[22:49] <wolverian> right. not quite intuiting with the mathematical properties of ops yet

[22:49] <wolverian> autrijus: hmm. I'm not sure what that ensure thing means.

[22:49] <autrijus> $x + $y == 3, even.

[22:49] <wolverian> is that a mutating statement or an assertion?

[22:50] <wolverian> I don't understand :)

[22:50] <autrijus> and the ensure syntax is something I just made up from nowhere :)

[22:50] <autrijus> it's an assertion that backtracks.

[22:50] <autrijus> (think prolog)

[22:50] <wolverian> ah, right.

[22:50] <wolverian> cramming logic programming in perl6 as well? 

[22:51] <autrijus> I think @Larry's idea is that someone needs to spike a module for that (which Ovid is sort of doing)

[22:51] <autrijus> and then we can figure out syntax

[22:51] <mugwump> ooo, I feel a new sendmoremoney version coming on, then

[22:51] <autrijus> mugwump: exactly.

[22:51] <autrijus> wolverian: I think the idea is that the core language may not have syntax for it

[22:51] <autrijus> but the semantics needs to ensure efficient implementation via a module or some such.

[22:52] <wolverian> Juerd: very nice p6l post, clarifying the [] () issue. :)

[22:52] <wolverian> autrijus: right. I think I'm more comfortable with it that way, too.

[22:56] <Juerd> wolverian: TBH, thomas sandlass really manages to piss me off

[22:57] <wolverian> I get the picture. :) (although you're not being overly rude by any means)

[22:57] <Juerd> wolverian: I expect full knowledge of Perl 5 basics from people discussing Perl 6 semantics

[22:57] <wolverian> yes, me too.

[22:57] * Juerd goes now

[22:57] <Juerd> Bye!

[22:57] <wolverian> bye :)

[22:57] <wolverian> gamespot-- # requires you to register to download videos

[22:58] <amaurea> don't they let you stream them for free?

[22:58] <amaurea> and since streaming and downloading is the same...

[22:59] <wolverian> yes, using a windows media player plugin.

[22:59] <wolverian> which is a bit hard to come by on linux.

[22:59] <amaurea> you don't have to dig much to find the real stream url

[22:59] <wolverian> I guess not, but it's not as trivial as simply clicking 'download'

[22:59] <amaurea> true

[22:59] <ninereasons> mplayer, wolverian ?

[23:00] <wolverian> ninereasons: I don't have it installed. 

[23:00] * wolverian boggles

[23:00] <wolverian> these videos are in .zip files

[23:05] <autrijus> Set.pm now supports ∩, ∪ and ∋ 

[23:05] <svnbot6> r3419, autrijus++ | * Set.pm - â© for intersection and âª for union.

[23:05] * autrijus ponders what more to throw in

[23:08] * putter mutters "rules, the easiest way to segfault pugs..."

[23:15] * knewt can't understand why TSa doesn't go off and actually read up a bit about perl before posting anything more to p6l

[23:15] <svnbot6> r3420, autrijus++ | * utf8 please

[23:21] <wolverian> should 'gather { ... }.join(", ")' parse as 'gather({...}).join(", ")' or 'gather({...}.join(", "))'?

[23:21] <svnbot6> r3421, putter++ | Tweaked and unDisabled several t/rules/from_perl6_rules/ files.

[23:21] <autrijus> knewt: TSa is here. you can discuss it when he shows up :)

[23:21] <putter> r3421 should be subtitled "but they are _interesting_ Errors and segfaults (...maybe)".

[23:21] <autrijus> wolverian: gather is a stmt

[23:21] <autrijus> to get the first behaviour you want

[23:21] <autrijus> do{ gather { ... } }.join()

[23:22] <autrijus> it's like if(){}

[23:22] <knewt> autrijus: heh *g*

[23:22] <autrijus> incidentally do{} works :)

[23:22] <wolverian> autrijus: hmm. right. how about 'do gather { ... }.join'? 

[23:22] <wolverian> is it possible for the blockless do to DWIM there?

[23:22] <autrijus> do must be followed by a block

[23:22] <autrijus> implicit braces is verboten by larry.

[23:23] <wolverian> there has been talk on p6l (by larry himself) to put in a braceless do

[23:23] <eric256> any ideas why for (1..9) -> $x,$y,$z { say $x,$y,$z }; prints an undef at the end?

[23:23] <autrijus> oh? hm.

[23:23] <autrijus> I'll wait until it's specced :)

[23:23] <wolverian> to make transforming statements to expressions easier, I guess

[23:23] <wolverian> yeah.

[23:23] <autrijus> eric256: stmt level always evaluate to undef

[23:23] <wolverian> (I like it since it strikes me as haskell-ish)

[23:23] <autrijus> eric256: if you are in the pugs shell that's what it prints

[23:23] <wolverian> (even though it's used for a different purpose)

[23:23] <autrijus> it's like

[23:23] <autrijus> pugs> say 1

[23:23] <autrijus> 1

[23:23] <autrijus> bool::true

[23:24] <autrijus> here bool::true is say's return value.

[23:25] <eric256> ohhh. lol. gotcha. thanks

[23:26] <autrijus> np :)

[23:26] <eric256> that is a pretty cool use of for though, is there a name for that -> style?

[23:26] <wolverian> pointy sub

[23:27] <autrijus> ok. journal up.

[23:28] <autrijus> 7:30am... I _really_ should sleep

[23:28] <autrijus> esp. seeting how I have to wake up in 7 hours.

[23:28] <autrijus> s/seeting/seeing/

[23:28] * autrijus waves &

[23:28] <eric256> so the for loop automagicaly doles out enough elements to fill the paramters of the sub given to it?

[23:29] <putter> re, sets... it would be nice to have equivalence classes...

[23:29] <wolverian> bye, autrijus 

[23:29] <wolverian> eric256: yes.

[23:29] * theorbtwo waves to autrijus if he isn't too late.

[23:29] <autrijus> :) *wave*

[23:29] <putter> good night, thanks for the fish.

[23:30] <autrijus> putter: thanks to you as well :)

[23:39] * eric256 creates his own z operator....okay that jsut totaly rocks.

[23:42] <eric256> will it check the parameters of each definition and pick the one that matches?  do i need to delcare that with the multi keyword?

[23:43] <wolverian> yes.

