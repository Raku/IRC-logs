[01:09] <luqui> ?eval sub foo($bar?) { say $bar }   foo()

[01:09] <evalbot_7938>  bool::true 

[01:10] <luqui> ?eval sub foo(?$bar) { say $bar }   foo()

[01:10] <evalbot_7938> Error:  unexpected "?" expecting formal parameter, ":" or ")" 

[01:10] <luqui> sweet

[01:11] <luqui> ?eval sub foo(:$bar) { say $bar }   foo bar => 42

[01:11] <evalbot_7938> bar42 bool::true 

[01:11] <luqui> ?eval sub foo(:quux($bar)) { say $bar }   foo quux => 42

[01:11] <evalbot_7938> Error:  unexpected "q" expecting space or ")" 

[01:15] <svnbot6> r7939 | Darren_Duncan++ |  r811@Darren-Duncans-Computer:  darrenduncan | 2005-11-12 17:12:00 -0800

[01:15] <svnbot6> r7939 | Darren_Duncan++ |  added new utilty script util/add-test-file.sh that combines 'svn/k add foo' and 'add-svn-props.sh' into one convenient step, good for mass text file adds

[01:15] <Juerd> The postfix ? in signatures is blessed now?

[01:15] <Juerd> Hurrah!

[01:16] * luqui is rather happy about that too

[01:17] <dduncan> the script is actually add-text-file; the commit message is typod

[01:17] <Juerd> I wonder if the + to ! change is official too

[01:17] <dduncan> and it was tested by adding itself

[01:17] <Juerd> Hoping pugs is a good reference,

[01:17] <Juerd> ?eval sub foo (:$bar!) { say $bar } foo()

[01:17] <luqui> yeah, postfix ! for mandatory

[01:17] <evalbot_7939> Error: No compatible subroutine found: "&foo" 

[01:17] <luqui> is blessed :-)

[01:18] <dduncan> I like the postfix ! for mandatory

[01:18] <Juerd> Neat!

[01:18] <luqui> ?eval sub foo (:$bar!) { say $bar } foo(bar => 42)

[01:18] <evalbot_7939> 42 bool::true 

[01:18] <Juerd> That's my first, ehm, signature symbol, I think it's called. Do these decorators have a name?

[01:18] * luqui thinks that the "no compatible subroutine found" error must be given a better message

[01:18] * luqui goes off to fix that

[01:18] <dduncan> now, if only saying that would result in 42 ending up in $bar

[01:18] <Juerd> luqui++  # fixing

[01:19] <dduncan> I wonder ...

[01:19] <luqui> dduncan, what do you mean?

[01:19] <dduncan> just a minute ...

[01:19] <dduncan> ?eval sub foo (:$bar!) { say $bar } foo('bar' => 42)

[01:19] <evalbot_7939> 42 bool::true 

[01:19] <Juerd> dduncan: Note that the first 42 is the result of "say", the second is that of foo

[01:20] <dduncan> I had a problem with this yesterday, have to debug

[01:21] <Juerd> luqui: Can you change the evalbot so that it does something to separate output from return value? The two being next to eachother is often confusing, especially as people use "say" a lot, not expecting the return value to be listed too.

[01:21] <Juerd> Is the bot in the pugs repository, by the way?

[01:21] <theorbtwo> I'm not sure what people's excuse for redundant says.  Juerd, yes, somewhere under examples.

[01:22] <Juerd> theorbtwo: "say" is very useful, as it allows you to output anything at any point, without considering call/return stacks.

[01:22] <dduncan> the problem I had yesterday concerned "submethod BUILD" having named arguments

[01:22] <Juerd> dduncan: Note that BUILD is called by, not an alias for, new.

[01:22] <dduncan> yes

[01:23] <theorbtwo> Yeah, but it gets used a lot in examples when it's completely redundant... it's probably actually because people are so used to perl -le '...'

[01:23] <Juerd> theorbtwo: Possibly.

[01:23] <Juerd> Still, I think both are useful.

[01:23] <theorbtwo> Absolutely.

[01:23] <Juerd> A little separation would probably solve this.

[01:23] <dduncan> if BUILD is working for other people, I'll try debugging mine now

[01:23] <theorbtwo> It'd be nice if it printed Output: ...  Returned: ...

[01:23] <luqui> Juerd, I'll look at it

[01:23] <theorbtwo> (Or Output: ...  Died: ...)

[01:24] <theorbtwo> ?eval die "Foo!"

[01:24] <evalbot_7939> Error: Foo! 

[01:24] <Juerd> theorbtwo: ... I was just typing something very similar.

[01:24] <theorbtwo> Close enough.

[01:24] <theorbtwo> Hm, though, I wonder...

[01:24] <theorbtwo> ?eval say "Output"; die "Error"

[01:24] <evalbot_7939> Output Error: Error 

[01:24] <Juerd> theorbtwo: Still, even a simple separator char would work. And be easier to implement, probably :)

[01:24] <Juerd> Or something circumfix

[01:25] <Juerd> Output [[Error: Error]]

[01:25] <Juerd> Output [[4]]

[01:25] <Juerd> (Double brackets to avoid confusion with the often used .perl)

[01:25] <luqui> what if I omitted the return value if there was output?

[01:26] <theorbtwo> Nah, sometimes you want to see both.

[01:26] <luqui> then maybe you put an extra say there?

[01:26] <Juerd> luqui: I think that the return value can be useful even if it wasn't expected to be.

[01:26] <dduncan> the situation is that, following an invocation of Locale::KeyedText::Message.new( 'msg_key' => 'MYAPP_HELLO' ) ...

[01:26] <Juerd> In my bash shell, I have $? as part of my prompt.

[01:26] <luqui> fair enough

[01:26] <dduncan> spitting out the value of the msg_key property displays both the pair key and value

[01:26] <Juerd> Most of the time, I don't think about it. Sometimes, seeing a non-0 there warns me something was wrong, even though the output was normal.

[01:27] <dduncan> now I'm trying to track down why the pair value wasn't extracted in BUILD

[01:27] <Juerd> You've probably noticed this in feather's default $PS1 ;)

[01:27] <dduncan> the signiture is ... submethod BUILD (Str :$msg_key!, Any :%msg_vars? = hash())

[01:28] <Juerd> dduncan: How does new call BUILD? Does it use *?

[01:28] <wolverian> is that = hash() redundant?

[01:28] <dduncan> I use the default new(), and don't declare my own

[01:28] <theorbtwo> Somebody remind me what the : there does?

[01:28] <luqui> ?eval my %foo = hash(a => 1, b => 2);  say %foo.keys

[01:28] <evalbot_7939> Error: Unknown syntactic construct: Syn "named" [Val (VStr "a"),Pos (MkPos "<eval>" 1 21 1 22) (Val (VInt 1))] 

[01:28] <luqui> ?eval my %foo = hash('a', 1, 'b', 2);  say %foo.keys

[01:28] <evalbot_7939> ab bool::true 

[01:28] <Juerd> (Should it? How does one properly call another sub/method using the same arguments, assuming compatible signatures? Do we have argument lists in variables?)

[01:29] <dduncan> right now, the issue is with the msg_key, a scalar

[01:29] <wolverian> Juerd, yeah, we do. 

[01:29] <Juerd> theorbtwo: :$foo in a signature means it is a named-only parameter. 

[01:29] <Juerd> theorbtwo: The argument will be in $foo.

[01:29] <Juerd> theorbtwo: The name is 'foo'

[01:30] <theorbtwo> OK.

[01:30] <theorbtwo> ":" is named, ? or ! is required or optional.

[01:30] <Juerd> theorbtwo: :foo($bar) means it is a named-only parameter; the argument will be in $bar; the name is still 'foo'.

[01:30] <theorbtwo> IWFM.

[01:30] <Juerd> theorbtwo: Yes.

[01:30] <wolverian> Juerd, see 'Argument list binding' in S06

[01:30] <wolverian> if that's what you meant. I'm really tired.

[01:31] <wolverian> good night :)

[01:31] <Juerd> theorbtwo: Positional defaults to mandatory, named to optional. Anything with a specified default value is also automatically optional.

[01:31] <Juerd> wolverian: Good night.

[01:32] <theorbtwo> I ought to read the changelogs of the S*, if not reread all of the S*es.

[01:32] <dduncan> ?eval class Foo; submethod BUILD (:$bar) { say $bar; } Foo.new('bar'=>'baz');

[01:32] <evalbot_7939> barbaz Foo.new(("bar" => "baz"),); 

[01:32] <Juerd> All mandatory positionals must come before optional positionals, but this should be entirely natural. If not, please experiment with alternatives ;)

[01:32] <dduncan> so, there's the bug

[01:33] <dduncan> 'barbaz' was spit out, not 'baz'

[01:33] <Juerd> dduncan: Write a test.

[01:33] <dduncan> okay

[01:34] <Juerd> And one day, either you will find your test removed or changed, which would mean the bug is on your side, or the bug is on pugs's side, and you will find it fixed :)

[01:34] <dduncan> does my code look wrong?

[01:34] <theorbtwo> You might want to comment the test, but don't comment it out.

[01:35] <Juerd> dduncan: I dunno.

[01:35] <Juerd> dduncan: I find the new/BUILD thing unnecessarily complicated.

[01:35] <luqui> yeah

[01:36] <dduncan> I think its designed to make class inheritence easier

[01:36] * Juerd fails to see the need for separation.

[01:36] <Juerd> Or the need for submethods, for that matter...

[01:36] <luqui> but I think it has failed for that

[01:36] <Juerd> This may be my ignorance.

[01:36] <luqui> since usually a subclass wants to control the parameters to the superclass, not the person creating the object

[01:36] <dduncan> one can write a manual new() instead and call bless(), such as if you want the constructor to take positional args, like in perl 5

[01:37] <Juerd> dduncan: I'm usually more interested in the default (thus implicitly preferred or even recommended) way of doing things than in what is possible.

[01:37] <Juerd> A lot is possible, and certainly enough is

[01:38] <dduncan> I think the advantage of the BUILD approach is that if a subclass doesn't want to know about all the optional args a superclass constructor takes, it doesn't have to

[01:38] <Juerd> But the language is not defined by what it can do, but by what it does.

[01:38] <dduncan> various other advantages discussed at length elsewhere

[01:38] <Juerd> Creating a dialect does not make the base language any better :)

[01:38] <dduncan> suffice it to say that using BUILD is fairly standardish now, and what I'm trying to use

[01:39] * luqui thinks it is worth arguing

[01:39] * Juerd doesn't even know which things should go into new and which into BUILD.

[01:39] <dduncan> I do know

[01:39] <Juerd> I've never cared, and the names aren't explaining anything to me.

[01:39] <Juerd> So I'd have to read documentation.

[01:39] <dduncan> BUILD is what bless() calls

[01:39] <Juerd> Which I haven't done yet.

[01:40] <dduncan> after bless creates an object, BUILD sets its attributes

[01:40] <dduncan> new() is called before bless

[01:40] <Juerd> We still set attributes by executing code?

[01:40] <Juerd> Why not has $.foo = "initial value"?

[01:40] <luqui> Juerd, that is allowed

[01:40] <luqui> just not implemente

[01:40] <luqui> d

[01:41] <dduncan> it is possible that you may want to do several things at init time in response to the same input or combination thereof

[01:41] <Juerd> And why would attributes not already be available in new? Would they have to be class attributes?

[01:41] <luqui> it turns out that attributes are not available in BUILD

[01:41] <dduncan> object attrs aren't available in new, because the object hasn't been made yet

[01:41] <luqui> defaults are set at the *end* of BUILD

[01:41] <luqui> for some stupid reason

[01:41] <Juerd> luqui: That appears counter productive :)

[01:41] <luqui> yep

[01:41] <dduncan> attrs are available in BUILD, to be set

[01:42] <dduncan> when BUILD is called, you have a new object whose attrs are all undefined, and you set them

[01:42] <luqui> yeah

[01:42] <luqui> it needs a rehash

[01:42] <luqui> we need to simplify and optimize for common cases

[01:42] <luqui> Complex is a good common case

[01:42] <Juerd> dduncan: So what? We have hypothetical variables, all kinds of implicit declaration, and even interesting forms of undef, that already know what class they belong to (think my Dog $fikkie .= new). This should be possible.

[01:44] <dduncan> its like if in perl 5, BUILD is called in this context: sub new { my $obj = bless {}, shift; $obj->BUILD(@_); } ... thereabouts

[01:45] <dduncan> BUILD starts from the point that the hash-replacement is blessed, when one starts to set its attrs

[01:46] <dduncan> I like this approach because I can then use my invocant as the object even in the constructor, and not just all the other methods or destructor

[01:46] <luqui> we know how it works.  *why* is what we're contesting

[01:46] <Juerd> Okay, fine that that is what it is, but I still don't like it or see why it's needed.

[01:46] <dduncan> what do you propose instead ... the perl 5 way?

[01:46] <luqui> I think BUILD is okay

[01:46] <Juerd> luqui: Actually, I didn't know how it works :)

[01:46] <luqui> I don't like that the parameters are forced to be named

[01:46] <luqui> I don't like that defaults are set at the end

[01:47] <luqui> I've had to work around it once or twice

[01:47] <luqui> and I have reasons for those

[01:47] <dduncan> last I checked, defaults were actually set at the start of BUILD, not the end ... but Class::Std sets them at the end for perl 5 folks

[01:47] <Khisanth> change it before it's too late! :)

[01:47] <luqui> but I think it would be more productive to p6l them

[01:47] <Juerd> Wouldn't it make a lot of sense to have new and BUILD have exactly the same signature?

[01:47] <dduncan> at least that's how I read A6

[01:48] <dduncan> new() defaults to having the same signiture as BUILD, the same as bless, if you don't declare a new() but you do declare a BUILD ... if you declare a new(), it has what you declare instead

[01:48] <dduncan> and bless takes only named args

[01:49] <luqui> that would be nice

[01:50] <Juerd> I see

[01:50] <Juerd> How does it do that? :)

[01:50] <Juerd> Is there a syntax to take another sub's signature?

[01:50] <dduncan> if you declare neither, then both default to taking named args matching your public attributes

[01:51] <luqui> Juerd, arg tuple :-)

[01:51] <dduncan> er, new() does

[01:51] <Juerd> luqui: What syntax do you imagine in declarations?

[01:51] <luqui> sub new (\$args) { ....  $obj.BUILD(*$args) }

[01:51] <dduncan> in my case, I make all my attributes private, and so I have to define explicit args in my constructor

[01:51] <dduncan> I think

[01:51] <Juerd> Aha, backslash.

[01:51] <wolverian> Juerd, I pointed you at the relevant S06 section :)

[01:52] <Juerd> wolverian: It's almost 3am, I'm in bed, tired, really can't stand any white background :)

[01:52] <Juerd> wolverian: So I'm postponing any serious reading until tomorrow :)

[01:52] <wolverian> excuse accepted! :) now I'm really going to fall asleep, as well.

[01:52] <Juerd> In fact, I was just going to wish you all a good night

[01:52] <Juerd> Good night :)

[01:52] <dduncan> good night

[01:52] <wolverian> good night!

[01:54] <dduncan> if anyone needs another analogy, BUILD() in perl 6 is what initialize() generically means in any language

[01:54] <luqui> the philosophy isn't the problem, it's the details

[01:54] <Juerd> dduncan: Then the name "BUILD" would be wrong, imo.

[01:54] <Juerd> Does it actually build anything?

[01:55] <Juerd> Or does it initialize?

[01:55] <Juerd> But I'm sleeping, really

[01:55] <Juerd> afk

[01:55] <dduncan> well, "build" is generic enough to include initialize

[01:55] <dduncan> in the english sense of the word

[01:57] <theorbtwo>  [01:38] [theorbtwo(+i)] [4:#perl6(+n)] [Act: 1,5]

[01:58] <theorbtwo> Sorry.

[01:58] <azuroth> unrelated, but...

[01:59] <azuroth> anyone think this warning might be causing a segfault? ;-p "/usr/bin/ld: warning: libstdc++.so.6, needed by /usr/lib/gcc-lib/i486-linux-gnu/3.3.6/../../../libpqxx.so, may conflict with libstdc++.so.5"

[02:00] <azuroth> or can I make it un-link to stdc++.so.5 ?

[02:01] <luqui> ?

[02:01] <luqui> no idea

[02:01] <azuroth> I probably ought to be asking in #c++ :-)

[02:28] <luqui> ?eval

[02:28] <luqui> ?eval ()

[02:28] <evalbot_7939> () 

[02:39] <svnbot6> r7940 | luqui++ | Minor spelling/grammatical fixes.

[02:39] <svnbot6> r7941 | luqui++ | Made evalbot distinguish output from return value.

[02:48] <luqui> ?eval 42

[02:48] <evalbot_7941> 42 

[02:48] <luqui> ?eval say "hi"; 42

[02:48] <evalbot_7941> OUTPUT[hi ] 42 

[02:48] <luqui> it's ugly, but it'll do

[02:49] <azuroth> ?eval sub foo() { say "blah"; 1;} say "a"; foo();

[02:49] <evalbot_7941> OUTPUT[a blah ] 1 

[02:49] <azuroth> woot

[02:51] <luqui> do newlines work

[02:51] <luqui> in irc?

[02:51] <luqui> oh, not really

[02:51] <azuroth> they do in jabber :-)

[02:55] <rafl> I'd also prefer using a jabber MUC over IRC.

[03:04] <luqui> ?eval "it's a test bot"

[03:04] <luquivb> "it\'s a test bot" 

[03:04] <evalbot_7941> "it\'s a test bot" 

[03:05] <luqui> ?eval "it's a test bot, seriously"

[03:05] *** luquivb is now known as luquivb_2

[03:05] <luquivb_2> "it\'s a test bot, seriously" 

[03:05] <evalbot_7941> "it\'s a test bot, seriously" 

[03:05] <luqui> good

[03:09] <svnbot6> r7942 | luqui++ | Lazy nick resetting.

[03:12] <luqui> ?eval "\$quotemeta?"

[03:12] <evalbot_7941> "$quotemeta?" 

[03:12] <luqui> hmm, that's a bug too

[03:13] <luqui> ?eval "update yourself!"

[03:13] *** evalbot_7941 is now known as evalbot_7942

[03:13] <evalbot_7942> "update yourself!" 

[03:13] <luqui> woohoo

[03:14] <azuroth> that's cool

[03:15] <dduncan> "update yourself!"

[03:15] <dduncan> ?eval "update yourself!"

[03:15] <evalbot_7942> "update yourself!" 

[03:15] <dduncan> oh well, timing not so good

[03:15] <luqui> it just checks to see if it has been updated when you eval something

[03:15] <luqui> it updates every five minutes

[03:16] <luqui> that was the best I could do without getting into yucky ipc stuff

[03:16] <dduncan> well, it won't break anything, given that it's a string literal

[03:17] <luqui> hmm?

[03:17] <dduncan> except that this is an interpolating string, so presumably any interpolation is done first, then if the result is whatever it does whatever

[03:17] <luqui> right

[03:17] <luqui> fixing

[03:32] <luqui> ugh, this is more difficult than I though

[03:32] <luqui> t

[03:38] <eric256_> ?eval say "hello";

[03:38] <evalbot_7942> OUTPUT[hello ] bool::true 

[03:38] <eric256_> just wanted to see the new output ;)

[03:52] <Khisanth> where did the extra space come from?

[03:52] <azuroth> they're \ns I think

[03:58] <svnbot6> r7943 | luqui++ | Fixed '$foo'.perl (wasn't properly escaping the $).

[03:58] <svnbot6> r7943 | luqui++ | In the process, I blessed and implemented "\d[123]".

[04:06] <luqui> ?eval "\$quotemeta"

[04:06] *** evalbot_7942 is now known as evalbot_7943

[04:06] <evalbot_7943> "\$quotemeta" 

[04:07] <luqui> ?eval "\$quotemeta\{curly\}"

[04:07] <evalbot_7943> "\$quotemeta\{curly}" 

[04:07] <luqui> excellent

[05:26] <gaal> autri, hello. a few questions for when you wake up :)

[05:27] <gaal> first, I was adding smartmatch against closures, but couldn't get literal when { } { } to work -- any idea why adding ruleBlockLiteral as an option to ruleCondPart (or a similar rule intended just for "when" didn't do the trick)?

[05:27] <svnbot6> r7944 | Darren_Duncan++ |  r811@Darren-Duncans-Computer:  darrenduncan | 2005-11-12 17:12:00 -0800

[05:27] <svnbot6> r7944 | Darren_Duncan++ |  added new utilty script util/add-test-file.sh that combines 'svn/k add foo' and 'add-svn-props.sh' into one convenient step, good for mass text file adds

[05:27] <svnbot6> r7945 | Darren_Duncan++ |  r818@Darren-Duncans-Computer:  darrenduncan | 2005-11-12 21:14:34 -0800

[05:27] <svnbot6> r7945 | Darren_Duncan++ |  added new test t/oo/named_parameters_in_BUILD.t about that BUILD() receives declared-named argument values correctly

[05:28] <gaal> second, more genrally, i was looking for ways to increase my Parsec fu by tracing it -- not just add trace calls, but maybe put the whole thing in a debugger. couldn't find one that works though -- any ideas about that? #haskell sady was no help, but perhaps i should poll again.

[05:30] <luqui> gaal, re: when, it's possible that we'll disallow that form anyway

[05:30] <luqui> in favor of when ({ }) { }

[05:32] <dduncan> clkao, it appears that svk again sent the same commit to the pugs main server twice ... this time the pugs commits 7939 and 7944 are actually the same one, which (as with the first such error) involved adding a new file

[05:32] <dduncan> this time, however, I have a partial terminal log that I will nopaste ...

[05:32] <gaal> third, I'm going through TaPL now. I'm very pleased to find I can read the OCaml there. when you started pugs, did you consider OCaml? Without pugs today, I would have assumed OCaml to be more suitable than Haskell -- did you already know about the fancy modern Haskell stuff when you started off, or did you not worry about getting to need any of it? :-)    (this last Q I need for the article)

[05:33] <dduncan> that shows what happened from the moment of my second actual commit of the day, named_param...

[05:33] <pasteling> "dduncan" at 24.108.164.7 pasted "client-side details of what happened when same commit pushed to pugs mainserver a second time" (44 lines, 2.6K) at http://sial.org/pbot/14266

[05:34] <gaal> luqui: ACK. in fact ruleCondPart has a maybeParens in it so that should have worked but doesn't

[05:36] <dduncan> seen clkao

[05:36] <jabbot> dduncan: clkao was seen 1 days 5 hours 38 minutes 49 seconds ago

[05:36] <gaal> luqui: if you're already here -- do you have an idea for the semantics of has = default? for example:

[05:37] <gaal> if there's both a has-default and a BUILD routine, does the default get installed before the routine is called?

[05:38] <gaal> if there's a has-default, and a BUILD routine that specifies an optional value for the same attribute, I guess that's a compilation error

[05:42] <gaal> ..back on the when {} {} thread, of course I want to fix this but it's more important to me in the long shot to have a better understanding of parsec. ideally i'd like an AOPish tool that at runtime can give me a trace of productions tried, like RD_TRACE (I think it is? in P::RD).

[05:42] <gaal> or something along the lines of this: http://www.cs.kent.ac.uk/people/rpg/tatd2/goodFib.pdf

[05:43] <gaal> It's pretty darn impressive we've gotten this far without a debugger! haskell++ I suppose

[05:50] <luqui> gaal, unfortunately, it is specced so that the defaults are initialized *after* execution of BUILD

[05:50] <luqui> there was some reason for this, but it wasn't a very good one :-)

[05:52] <gaal> can't the spec be updated?

[05:53] <gaal> the case where I say ...new(something => undef) should probably also work (that is, something really should be undefined, not get the default)

[05:56] <dduncan> considering that undef is a legitimate value, perhaps the test as to whether to apply to a default is if the name key 'exists' rather than if its value is 'defined'

[05:56] <dduncan> exists in the argument list

[05:57] <gaal> dduncan: yes, that's the idea. problem is if you apply has-defaults AFTER BUILD, it may be tricky to go back and look at the argument list.

[05:57] <dduncan> if that happened, then you could correctly set to undef if defaults are applied after

[05:57] <dduncan> I don't see why the argument list would have expired ... it should still be around for the has-defaults to look at

[05:58] <dduncan> since that happens before the bless call returned

[06:00] <gaal> well, i was just pointing out a possible corner case to nail down. it may have been obvious.

[06:00] <gaal> $work &

[06:01] <dduncan> in any event, I sort of agree that defaults should be applied before BUILD

[06:01] <dduncan> or I'm not actually sure what should happen

[06:01] <dduncan> for now, I just set all my attributes in BUILD explicitly, whether from arguments or defaults

[06:02] <dduncan> and don't define defaults in any other place

[07:35] <gaal> well, I also wonder if has $.member = { somecode } should assign a closure or perhaps run the thunk on instantiaition

[07:36] <gaal> probably it makes more sense for it to be consistent and assign a closure.

[11:15] <Juerd> gaal: Assign a closure, because that's what's written

[11:16] <Juerd> gaal: But wasn't there something like "has $foo will init { ... };"?

[12:02] *** theorbtw1 is now known as theorbtwo

[12:12] <gaal> Juerd: where did you see that?

[12:17] <masak> gaal: something like that is hinted at http://search.cpan.org/dist/Perl6-Bible/lib/Perl6/Bible/S04.pod#Closure_traits

[12:19] <gaal> masak: thanks. (and hi :-)

[12:19] <gaal> "will first" ?

[12:28] <gaal> in any case: this was not explicitly for instance data, but rather for my/our vars.

[12:32] <gaal> seen brentdax

[12:32] <jabbot> gaal: brentdax was seen 30 days 7 hours 38 minutes 18 seconds ago

[12:32] <gaal> darn

[12:34] <r0nny> yo

[12:34] <azuroth> hey

[12:34] <gaal> ho

[12:37] *** lampus_ is now known as lampus

[13:07] <Juerd> gaal: I have no idea.

[13:08] <qwm> so, when will we see an ISO standard of Perl 6?

[13:12] <Juerd> Were old style +$foo named parameters optional or mandatory by default?

[13:12] <Juerd> qwm: Hopefully never, because ISO standards are expensive.

[13:14] <scook0> Juerd: optional IIRC; mandatory was ++$foo

[13:15] <Juerd> Ah, thanks.

[13:17] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, ++$nma, ++$nmb, +$noa, +$nob) { ... }

[13:17] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, +:$nma, +:$nmb, :$noa, :$nob) { ... }

[13:17] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, +:$nma, +:$noa, :$noa, :$nob) { ... }

[13:17] <Juerd> sub foo ($pma, $pmb, $poa?, $pob?, +:$nma, +:$noa, :$noa, :$nob) { ... }

[13:17] <Juerd> sub foo ($pma, $pmb, $poa?, $pob?, :$nma!, :$noa!, :$noa, :$nob) { ... }

[13:17] <Juerd> Is that the correct order in which things happened?

[13:18] <Juerd> p => positional, n => named, m => mandatory, o => optional, a => first, b => second

[13:19] <Juerd> Ohm, there are some mandatory named arguments mistakenly labelled 'o'

[13:19] <Juerd> s/Ohm/Oh/

[13:19] <rafl> is :noa! really named optional a?

[13:20] <Juerd> No, that's one of the mislabeled.

[13:20] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, ++$nma, ++$nmb, +$noa, +$nob) { ... }

[13:20] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, +:$nma, +:$nmb, :$noa, :$nob) { ... }

[13:20] <Juerd> sub foo ($pma, $pmb, ?$poa, ?$pob, +:$nma, +:$nma, :$noa, :$nob) { ... }

[13:20] <Juerd> sub foo ($pma, $pmb, $poa?, $pob?, +:$nma, +:$nma, :$noa, :$nob) { ... }

[13:20] <Juerd> sub foo ($pma, $pmb, $poa?, $pob?, :$nma!, :$nma!, :$noa, :$nob) { ... }

[13:20] <rafl> OK then.

[13:21] <rafl> :$nma! two times for the last three lines? should be :$nmb!, I guess.

[13:21] <Juerd> You're right

[13:21] <Juerd> I think my IQ was divided by 2 last night.

[13:22] <rafl> What did you do last night?

[13:22] <Juerd> Stubbornly not sleep, while being exhausted.

[13:25] * liz6 wonders whether chanting "OM" to Juerd would help  ;-)

[13:25] <Juerd> OM?

[13:26] <rafl> Juerd: Unfortunately I did the same. :-)

[13:26] <Juerd> As in "het roer om", "Openbaar Ministerie", or something else?

[13:26] <liz6> http://en.wikipedia.org/wiki/Aum

[13:26] <Juerd> Ah

[13:27] <Juerd> Don't think it'd help :)

[13:27] <Juerd> rafl: Then perhaps your IQ is also half of what it was before.

[13:29] <rafl> Juerd: I already work about two hours to fix a segfault in some perl bindings. You're probably right. :-)

[13:30] <Juerd> :)

[13:38] <svnbot6> r7946 | iblech++ | * Changes to accomodate to new (r6582) S02, S03, and S06 in src/, ext/, t/,

[13:38] <svnbot6> r7946 | iblech++ |   perl5/, docs/ and examples/:

[13:38] <svnbot6> r7946 | iblech++ |   * eqv is now spelled ===.

[13:38] <svnbot6> r7946 | iblech++ |   * (:who($name), :why($reason)) := ... is now a syntax error, one has to

[13:38] <svnbot6> r7946 | iblech++ |     explicitly use :(...) syntax to disambiguate:

[13:38] <svnbot6> r7946 | iblech++ |     :(:who($name), :why($reason)) := ...

[13:38] <svnbot6> r7946 | iblech++ |   * Fixed many occurances of =:= which actually meant === (but, as in the

[13:38] <svnbot6> r7946 | iblech++ |     current Haskell runcore, &infix:<=:=> ::= &infix:<===>, these mistakes went

[13:38] <svnbot6> r7946 | iblech++ |     unnoticed).

[13:39] <svnbot6> r7946 | iblech++ | * docs/quickref/op was in iso-8859-1; fixed.

[13:39] <svnbot6> r7946 | iblech++ | * t/oo/type.t is outdated (no current Synopsis speaks about .type and the

[13:39] <svnbot6> r7946 | iblech++ |   notion of types and classes etc. is changing currently).

[13:39] <svnbot6> r7947 | iblech++ | * PIL2JS: lib/PIL2JS.pm: Do not write to "deleteme_eval.js" any longer when

[13:39] <svnbot6> r7947 | iblech++ |   using JSSM (putter++!).

[13:39] <svnbot6> r7947 | iblech++ | * t/oo/attributes/undeclared_attribute.t: Improved xinming++'s test to

[13:39] <svnbot6> r7947 | iblech++ |   also test for binding of undeclared attributes to be illegal.

[13:39] <svnbot6> r7947 | iblech++ | * New t/operators/binding/attributes.t: Tests for binding {public,private}

[13:39] <svnbot6> r7947 | iblech++ |   {instance,class} attributes.

[13:47] <r0nny> re

[13:48] <Juerd> ===?

[13:48] <Juerd> Oh my!

[13:48] <Juerd> HELP

[13:48] <Juerd> (NOOOOOOOOOO!)

[13:50] <liz6> some equals are more equal than other equals?

[13:50] <Juerd> =, ==, === doesn't make the language any clearer.

[13:50] <Juerd> PHP has this. It sucks.

[13:50] <theorbtwo> That was always true... but = and == is already plenty, thankyouverymuch.

[13:51] <theorbtwo> Eeep, I'm an echo.

[13:51] <dakkar> Juerd: JS is even stanger

[13:51] <Juerd> 14I'm an echo...

[13:51] <r0nny> i'd rather have eqv then ===

[13:52] <r0nny> i think eqv is much more readable

[13:52] <Juerd> I dislike eqv too. I think this thing should be a method, not an infix op.

[13:52] <Juerd> Or maybe not.

[13:52] <r0nny> i tihnk infox op is ok

[13:52] <Juerd> Ah well, at least we don't have to use this often.

[13:53] <dakkar> is 'eqv' pointer-comparison?

[13:53] <r0nny> it does what it should do - in a radable way

[13:53] <Juerd> Readable, yes, distinguishable, hardly.

[13:53] <Juerd> = versus == is doable.

[13:53] <Juerd> == versus === is much less.

[13:53] <r0nny> syntax-highlighting is needed for sure

[13:54] <Juerd> The language should never depend on syntax highlighting for things to be clear.

[13:54] <r0nny> yeah

[13:54] <Juerd> Besides, I doubt any syntax highlighting engine can make anything useful from:

[13:54] <r0nny> but humans tend to see it more clear if the machine hepla a bit with colors

[13:55] <Juerd> /<before foo %bar{/<quux>/}>/

[13:55] <theorbtwo> I think infix op is not only OK but right.  If there's no difference between the invocant and the argument, making it a method is confusing.

[13:55] <Juerd> theorbtwo: You're right.

[13:56] * Juerd tends to see $foo infixop $bar as $foo.infixop($bar) though.

[13:56] <theorbtwo> It's not, though.

[13:56] <theorbtwo> It's infixop($foo, $bar)

[13:56] <Juerd> (1.+(2)).==(3)

[13:56] <Juerd> )

[13:56] <theorbtwo> ?eval 1.+(2)

[13:56] *** evalbot_7943 is now known as evalbot_7947

[13:56] <evalbot_7947> 3/1 

[13:56] <theorbtwo> OK then.

[13:57] <dakkar> what was that?

[13:57] <r0nny> ?eval 1.+(3)

[13:57] <evalbot_7947> 4/1 

[13:57] <dakkar> ?eval (1).+(3)

[13:57] <r0nny> wtf ? why is the reult 4/1 - it should be 4

[13:57] <evalbot_7947> Error:  unexpected "." expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[13:57] <dakkar> r0nny: might that be a Rational?

[13:58] <r0nny> hmm

[13:58] <theorbtwo> Pugs has several different sort of numbers; that's a rational.  Doesn't much matter; as everybody knows 4/1 is 4.

[13:58] <dakkar> And I think it gets parsed as <1.> <+> <(> <3> <)>

[13:58] <r0nny> confusting

[13:58] <theorbtwo> sub{1.+(3)}.perl

[13:58] <theorbtwo> ?eval sub{1.+(3)}.perl

[13:58] <evalbot_7947> "sub \{...}" 

[13:59] <theorbtwo> Grr.

[13:59] <dakkar> the 'decimal dot' should be consumed by the 'number' token

[13:59] <theorbtwo> I keep forgetting it can't do that.

[13:59] <r0nny> usually i expect a integer and not a rational as result of addidion from integers

[13:59] <dakkar> 1. is not an integer ;-)

[13:59] <r0nny> hmm

[13:59] <r0nny> ?eval 1+(3)

[13:59] <evalbot_7947> 4 

[13:59] <theorbtwo> OK then...

[13:59] <theorbtwo> anyway, we're drifting.

[13:59] <r0nny> argh

[14:00] <r0nny> ?eval 1.infix:>>+<<(3)

[14:00] <evalbot_7947> Error:  unexpected "i" or "." expecting digit, "_", exponent, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[14:00] <theorbtwo> What should "are these the same variable" look like?

[14:00] <theorbtwo> ?eval 1.infix<+>(3) #, I think...

[14:00] <dakkar> I asked: waht does exaclty 'eqv' do? pointer equality?

[14:00] <evalbot_7947> Error: No compatible subroutine found: "&infix" 

[14:00] <theorbtwo> dakkar: "Are these two things really different names for the same thing?"

[14:00] <r0nny> dakkar: =:= does pointer equal

[14:01] <r0nny> i trhink i shoud read more

[14:01] <theorbtwo> === is the new name for =:=, I think.

[14:01] <dakkar> argh. so C<a === b> iff the two names refer to the same container

[14:01] <dakkar> so it's a relation on names, not values, so it cannot be a method, since methods operate on values

[14:02] <theorbtwo> ?eval $a=1; $b=[$a, $a]; $b[0] === $b[1]

[14:02] <evalbot_7947> Error: Undeclared variable: "$a" 

[14:02] <theorbtwo> ?eval my $a=1; my $b=[$a, $a]; $b[0] === $b[1]

[14:02] <evalbot_7947> bool::true 

[14:02] <Juerd> dakkar: Methods operate on containers.

[14:02] <Juerd> dakkar: The container is the invocant

[14:03] <theorbtwo> (The container often falls back^W^Wredispatches to the value, though, if it doesn't handle the method itself.)

[14:03] <dakkar> Juerd: ? an object is a value... or am I missing something? C<tie>s operate on containers

[14:03] <Juerd> dakkar: Your terminology is off :)

[14:03] <theorbtwo> ?eval $a=1; $b=[$a, 1]; $b[0] === $b[1]

[14:03] <evalbot_7947> Error: Undeclared variable: "$a" 

[14:03] <theorbtwo> ?eval my $a=1; my $b=[$a, 1]; $b[0] === $b[1]

[14:03] <evalbot_7947> bool::true 

[14:03] <dakkar> ok, where is the "terminology quick-reference"? ;-)

[14:03] <theorbtwo> Blink... is that last result wrong, or is my understanding wrong?

[14:04] <Juerd> dakkar: There are names, containers and values, originally, but Autrijus thought of a new scheme with cells instead of containers. The new one isn't in my head yet.

[14:04] <Juerd> theorbtwo: It is wrong, or === isn't container-equivalency

[14:04] <dakkar> Juerd: oh. I might have looked at a picture, once...

[14:05] <Juerd> dakkar: Anyway, a "value" is the contents of a container.

[14:05] <dakkar> ehm... $b=[$a,$a];$b[0]===$b[1] -> true is wrong, too, so

[14:05] <dakkar> Juerd: yes, and a container is (more or less) a "memory location"

[14:05] <Juerd> dakkar: After $foo = 3, the container named $foo holds the value three.

[14:05] <Juerd> Operators like + use the value.

[14:06] <dakkar> Juerd: ok

[14:06] <Juerd> Normally, when passing an argument, you pass the container, even without "is rw". Some magic is applied to make the container read only in the sub.

[14:07] <dakkar> where is the type annotation stored, though? As I see it, all three levels need some kind of type annotations

[14:07] <Juerd> "is copy" makes perl copy your value from one container to another.

[14:07] <Juerd> dakkar: In the container.

[14:08] <dakkar> but I can't do @foo := $bar, so the names must be typed in some way

[14:08] <dakkar> (or can I?)

[14:08] <Juerd> dakkar: The value has type too, and there can even be two different values in a single container, but that's not something a language user should care about.

[14:08] <Juerd> dakkar: Sure you can, if $bar is a reference to an array.

[14:08] <Juerd> It will then make @foo an alias for @$bar.

[14:08] <dakkar> so it has to know that @foo is an array name

[14:09] <Juerd> @.

[14:09] <Juerd> It's easy to think of real arrays and real hashes as references without the $ :)

[14:09] <dakkar> yes, obvious. so we *do* have three levels of type annotation

[14:09] <Juerd> dakkar: Well, sort of. We have more, even.

[14:10] <dakkar> (BTW, this seems to be true of Perl5, too)

[14:10] <Juerd> We need more words than "type"

[14:10] <dakkar> yes. must start making them up ;-)

[14:11] <Juerd> Or adjectives. Easier.

[14:11] <theorbtwo> typf, typg...

[14:11] <dakkar> lol

[14:11] <Juerd> Variable types, container types, value types.

[14:11] <dakkar> "variable" is a bit overloaded, don't you think? I keep using "name"

[14:11] <theorbtwo> (Fortunately, we can use the shorter term "sigil" for the first one.)

[14:12] <Juerd> A variable doesn't have to have a name.

[14:12] <theorbtwo> ...unless I'm confused about the meaning.

[14:12] <Juerd> It can have a name. Or even several.

[14:12] <Juerd> So "name" as a replacement for "variable" is wrong.

[14:12] <theorbtwo> (Think of the (somewhat abused) perl term "anonymous".)

[14:12] <Juerd> But yes, there may also be name types.

[14:12] <dakkar> Juerd: argh. what is a "variable"? (I'm deeply confused)

[14:13] <dakkar> I have names ($foo), containers (memory locations), values (thing stored therein)

[14:13] <Juerd> I'm wrong. "variable type" is misleading.

[14:13] <Juerd> Should indeed be "name type".

[14:13] <dakkar> oh, I'm relieved ;-)

[14:13] <theorbtwo> Juerd: Can you give an example of a name type?

[14:13] <Juerd> theorbtwo: $, @, %, &

[14:13] <Juerd> theorbtwo: Sigils indicate name type.

[14:14] <dakkar> theorbtwo: the name C<$foo> has scalar name type

[14:14] <Juerd> Variable types are arrays, hashes, scalars

[14:14] <theorbtwo> OK.  But the name is "$foo", untyped -- the $ is part of the name.

[14:14] <Juerd> Container types are Scalar, Ref, Num, Str, Dog, Cat  (containers are scalar things)

[14:15] <Juerd> theorbtwo: "foo type" != "type".

[14:15] <Juerd> Disregarding that != is for numbers.

[14:15] <Juerd> Value type is number, integer, float, string, reference

[14:15] <dakkar> Juerd: "containers are scalar things"? what is the container that @a refers to?

[14:15] <Juerd> dakkar: None.

[14:15] <Juerd> dakkar: An array is a collection, not a container, in the jargon I'm used to.

[14:16] <theorbtwo> So what's self in @a.foo?

[14:16] <dakkar> Juerd: when I tie an array, don't I tie the container? (tie are trasparent to argument passing, are they not?)

[14:16] <Juerd> A collection (aggregate) points to multiple containers

[14:16] <Juerd> dakkar: I refuse to discuss tie, because it's so extremely complicated in Perl 5, and I don't know the semantics in Perl 6.

[14:16] <dakkar> Juerd: good point

[14:17] <theorbtwo> I don't think there is such a thing in perl 6.

[14:17] <dakkar> there was something in autrijus's pictures...

[14:17] <theorbtwo> OTOH, you can do my BTree @foo;

[14:17] <Juerd> theorbtwo: That gives you "my @foo of BTree", i.e. scalars of BTree type, aggregated in a normal array.

[14:18] <dakkar> and it should mean that the containers referred to by the subscripting @foo can olny contain values derived from the BTree value type, right?

[14:18] <theorbtwo> Um... are you sure?

[14:18] <Juerd> theorbtwo: Never.

[14:18] <dakkar> lol

[14:27] <r0nny> rafl: does your sixpan stuff have any usable depency solving classes ?

[14:30] <Juerd> Fuck. 

[14:30] <Juerd> spamd hasn't been running for an hour.

[14:30] <Juerd> Two hundred spam messages in my inbox.

[14:30] <r0nny> omg

[14:30] <Juerd> Good thing clamd was still running.

[14:30] <r0nny> this many in 1 hour ?

[14:30] <Juerd> Yep.

[14:30] <Juerd> Numerous duplicates too

[14:31] <r0nny> they should have a death-penalty for spammers

[14:32] <Juerd> No.

[14:33] <Juerd> Did you actually think about that before you typed it?

[14:33] <r0nny> not really

[14:33] <theorbtwo> Try doing that in the future.

[14:34] <r0nny> but at least they should cut them from internet for 10 or 20 years

[14:34] <Juerd> I disagree.

[14:34] <theorbtwo> So do I.

[14:34] <r0nny> so they should be left cappable of spamming ?

[14:34] <Juerd> People selling drugs via the internet should be punished as drugs dealers.

[14:34] <Juerd> Because that's what they are. The means of doing so is irrelevant.

[14:35] <Juerd> This is half of today's spam.

[14:35] <r0nny> hmm

[14:35] <gaal> Juerd: if you use procmail, look at the force-rescan script in one of the manpages

[14:35] <theorbtwo> People fradulantly claiming to deal drugs should be punished as fraudsters.

[14:35] <Juerd> Then, there's the scams, same thing. Scamming is forbidden.

[14:35] <pasteling> "gaal" at 192.117.178.34 pasted "(OT) force-rescan with procmail" (19 lines, 455B) at http://sial.org/pbot/14270

[14:36] <r0nny> in some countryed they have desth-penalty for selling hard drugs

[14:36] <r0nny> countryes

[14:36] <theorbtwo> countries.

[14:36] <r0nny> ack

[14:36] <Juerd> If you treat all these things via existing laws, you will end up with commercial spam, legal stuff. This should be allowed via strict guidelines, and punisheb by money fines.

[14:37] <Juerd> gaal: My server can't take it if I use non-spamd

[14:37] <gaal> you can do that with spamd too i think, assuming the procmail recipe calls spamc.

[14:37] <Juerd> I need qpsmtpd-forkserver because tcpserver spawning things is too much.

[14:37] <r0nny> i think they should disallow main as adversting platform

[14:38] <Juerd> gaal: The problem in question was that spamd died :)

[14:38] <r0nny> eh mail

[14:38] <Juerd> r0nny: I disagree.

[14:38] <r0nny> since mail id for comunication, not roasting your beain with the newest ads

[14:38] <gaal> Juerd: and is still dead? that's a problem all right :)

[14:38] <theorbtwo> So do I.

[14:38] <Juerd> r0nny: Direct marketing can be very useful for both seller and target audience.

[14:38] <Juerd> gaal: No, I re-started it.

[14:38] <Juerd> r0nny: Marketing and advertisement are communication.

[14:39] <r0nny> i see most of it as roasting peoples brain with untrue stuff

[14:39] <Juerd> The problem with spam is that most spam is for illegal goods and activities, or porn related.

[14:39] <Juerd> But that should be dealt with using non-spam laws.

[14:40] <Juerd> Sending porn to minors is illegal in many countries. If you cannot verify that someone is an adult, don't send it.

[14:40] <r0nny> yeah

[14:40] <Juerd> If someone is an adult, go ahead, send the porn spam

[14:40] <theorbtwo> "people's brains".  You do have a point, r0nnie, but if the problem is the untrue stuff, then make sending untrue stuff illegal, and prosecute for it.

[14:40] <Juerd> Just keep it reasonable.

[14:41] *** lampus_ is now known as lampus

[14:41] <Juerd> theorbtwo: Guess what - it already is ;)

[14:41] <theorbtwo> Juerd: I'm not sure I like that solution, but only because I like free spam.

[14:41] <Juerd> In most countries.

[14:41] <theorbtwo> Juerd: I'm aware.

[14:41] <theorbtwo> Er, s/spam/porn/

[14:41] <Juerd> Countries without laws are a problem.

[14:41] <r0nny> problem iss most of these spammer asholes are very unreasonalbe - i think for these unreasonable people there should be unreasonable penaltyes

[14:41] <Juerd> theorbtwo: There are many opt-in mailinglists for that.

[14:42] <theorbtwo> Juerd: But if they have to verify your age, they will become non-free.

[14:42] <Juerd> r0nny: No, even for unreasonable people, there should be reasonable penalty.

[14:42] <Juerd> theorbtwo: "Sending to", I meant in the non-american form :)

[14:43] <Juerd> If someone *requests* it, give it. They should be able to judge for themselves.

[14:43] <Juerd> If a minor requests porn, by all means give it to them. The minor is at fault here.

[14:43] <r0nny> they dont ask u - its like menthal terror

[14:43] <Juerd> I meant "sending to" in the spam way. Unsollicited mail relating to porn.

[14:44] <Juerd> That should not be done without verification.

[14:44] <theorbtwo> I rather like the smell of menthol.  You meant mental.

[14:44] <Juerd> menthol terror :)

[14:44] <Juerd> lol.

[14:44] <r0nny> rofl

[14:44] <r0nny> bad english is allways good for a joke ;P

[14:44] <theorbtwo> Juerd: The problem is that, in theory, a minor is never at fault.  r0nny: "always".

[14:45] * theorbtwo sighs.

[14:45] <Juerd> theorbtwo: Still, one shouldn't require providers of non-real-life-interactive erotica to verify age.

[14:45] <theorbtwo> I don't much care for that theory, and in pratice, it doesn't do any good, nor is it very true.

[14:46] <Juerd> theorbtwo: This would be unreasonable, as it indeed destroys free porn.

[14:46] <Juerd> This is unrelated to spam, though :)

[14:47] <Juerd> Pull and push media should have different rules.

[14:47] <Juerd> And opt-in is pull

[14:48] <Juerd> And then there's still an important difference between synchronous and asynchronous.

[14:48] <svnbot6> r7948 | iblech++ | docs/quickref/data: Outlined the current variable name, container, and cell

[14:48] <svnbot6> r7948 | iblech++ | semantics, as they're implemented in PIL2JS and as they will be implemented in

[14:48] <svnbot6> r7948 | iblech++ | the new runcore and the new PIR compiler.

[14:48] <svnbot6> r7948 | iblech++ | * Note: Do not use the current Haskell runcore for experiments with

[14:48] <svnbot6> r7948 | iblech++ |   containers, =:=, ===, etc. In the current runcore,

[14:48] <svnbot6> r7948 | iblech++ |   $a = 42; $b = 42; $a =:= $b is true!

[14:48] <svnbot6> r7948 | iblech++ | * Note: Reading t/operators/binding/*, t/operators/identity.t, and

[14:48] <svnbot6> r7948 | iblech++ |   t/operators/value_equivalence.t is strongly recommended.

[14:48] <Juerd> Erotica on TV is fine late at night, not just before kiddy bedtime

[14:48] <Juerd> But sending it by mail would be wrong at any time.

[14:48] <Juerd> This can also be seen as a broadcast/direct difference.

[14:48] <Juerd> E-mail isn't a broadcast medium, even though it is used like it.

[14:49] <Juerd> $a = 42; $b = 42; $a =:= $b is true!

[14:49] <Juerd> ahh

[14:49] <Juerd> That explains some stuff :)

[14:49] <r0nny> the problem is they do everything to get it torugh filters

[14:50] <Juerd> Define "they"

[14:50] <r0nny> porn and drug spammers

[14:50] <Juerd> The fun thing is that the people who evade filters, are usually doing something illegal and can be punished based on that.

[14:50] <Juerd> Spam isn't bad by definition.

[14:50] <Juerd> I get some good spam.

[14:51] <Juerd> The only reason I run a filter thingy is that most spam is indeed the kind that I don't want.

[14:51] <Juerd> And that I don't mind not getting the good spam.

[14:51] * dakkar starts to read the documents on name-container-value stuff...

[14:51] <r0nny> last time i got a usefull spam msg was 6 months ago

[14:52] <r0nny> i think there should be laws, define how to use mail - so all thos damn mails with fake information are very illegal

[14:53] <r0nny> and it should be threaded like faking documents like a testament or a contact

[14:54] <r0nny> so the penatyes of this massive abuse the bad spammers do will automagically add up to very high ones

[14:55] <r0nny> for example there could be a rule all ad-mails must have a valid sig, so the sender can be proven and a note in the subject

[14:56] <theorbtwo> "penalties".  I think it should certianly be far lower a penalty then for purgery in a court of law.

[14:56] <theorbtwo> I'm not real sure if it should be illegal.

[14:56] <theorbtwo> Note that giving a false name is not, in general, illegal.

[14:56] <r0nny> fakind data to make users look at it should be illegal

[14:56] <theorbtwo> (In the US, at least.)

[14:57] <r0nny> theorbtwo: why should the penalty for people just making money if casuing financial dammage to others be low ?

[14:57] <r0nny> s/if/of

[14:58] <theorbtwo> r0nny: I couldn't make sense of that sentance.

[14:58] <r0nny> actualy bad-spam-technology does huge dammage

[14:58] <r0nny> i dont see why there should be low penalty on this

[15:00] <theorbtwo> Because it's a fairly minor offese.

[15:01] <r0nny> they wont stop if there is low penalty

[15:02] <r0nny> btw - Juerd i rechecked the definition of spam - selective adversting could be usefull for the customer doesnt count as spam

[15:02] <theorbtwo> r0nny: Whose definition?

[15:03] <theorbtwo> r0: They'll stop if there's a fairly low penalty, and that penalty is more commonly assessed.

[15:03] <r0nny> theorbtwo: the one on wikipedia

[15:04] <r0nny> theorbtwo: a low penalty per spam mail is ok - as long, as it adds up - and since the amount is high, the resulting penalty will be, too

[15:04] <theorbtwo> WP is fairly clear that different people define it differently.

[15:04] <theorbtwo> Read the whole first paragraph, not just the first sentance.

[15:05] <theorbtwo> The thing is that false advertising is illegal, dealing drugs is illegal, sending porn to minors is illegal.

[15:05] <theorbtwo> (Not only that, but those are all /criminal/ charges.)

[15:06] <theorbtwo> ... hm, I shouldn't have parenthisized that -- it's an important point.

[15:06] <r0nny> hmm

[15:06] <theorbtwo> When you do any of those things, the State can charge you.

[15:07] <theorbtwo> The federal government fairly recently made sending email with false header information illegal.

[15:07] <theorbtwo> http://en.wikipedia.org/wiki/CAN-SPAM

[15:09] <theorbtwo> The problem is not that things aren't illegal.

[15:10] <theorbtwo> The problem is that law enforcement does things that they see as more important, and in many cases they are absolutely correct.

[15:10] <theorbtwo> I'd much rather have agents working kiddy-porn rings then spammers.

[15:10] <theorbtwo> OTOH, I'd rather have them tracking down major phishers then either.

[15:11] <theorbtwo> ...but phishing is illegal by dint of it being fraud, far more imporant the fake email headers.

[15:49] <wolverian> (in some countries, it's illegal to send advertising at all without prior acceptance from the customer, and that acceptance must be active, not passive ("default").)

[16:20] <Juerd> There should be penalties for sending duplicate mail with different message-id's :)

[16:20] <Juerd> i.e. for sending mail and letting the MTA generate a message-id.

[16:22] <theorbtwo> It's easy to set the penalty for that -- drop the message.

[16:22] <Juerd> It's expensive to test for it :)

[16:22] <theorbtwo> (Or reject it -- do not bounce, ever.)

[16:22] <theorbtwo> Not on the reciving MTA it's not.

[16:22] <Juerd> It means keeping records of previous messages.

[16:23] <Juerd> Which sucks.

[16:23] <theorbtwo> If there's no message-id, drop.

[16:23] <Juerd> There's usually a message-id generated by the sending MTA.

[16:24] <Juerd> It should be generated in the client, for identification of duplicate messages.

[16:25] <theorbtwo> You could always md5+sha1 the body, and drop if it matches.  You'll have minor problems with hash colissions, but shouldn't have too many.

[16:25] * theorbtwo wonders if there are any good hash algos of user-settable length.

[16:28] <Juerd> sha-n

[16:33] <theorbtwo> D'oh.

[16:33] <svnbot6> r7949 | autrijus++ | * luqui's \d[] patch eats the trailing space after the bracket;

[16:33] <svnbot6> r7949 | autrijus++ |   change "brackets" to "verbatimBrackets" to solve this.

[16:33] <svnbot6> r7949 | autrijus++ | * moreover, fix the old bug of "&foo() &bar()" eating the

[16:33] <svnbot6> r7949 | autrijus++ |   whitespace inbetween, due to the same cause.

[16:33] <svnbot6> r7949 | autrijus++ | * test for both in t/syntax/interpolation/strings.t

[16:34] <Juerd> autrijus! :)

[17:23] <gaal> autrijus: ping

[18:23] <r0nny> re

[19:42] *** bc is now known as venk

[19:46] <venk> .

[19:57] <gaal> Parser.hs change in last patch

[19:57] <gaal> # http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/diff/src/Pugs/Parser.hs?rev1=7946&rev2=7949

[19:57] <gaal> shouldn't that say "verbatimBrackets" ?

[19:57] <gaal> maybeVerbatimBrackets in Lexer.hs is unused.

[20:00] <gaal> ah: no that refers to the old bug.

[20:00] <gaal> Still, I'm wondering about maybeVerbatimBrackets; why is it there?

[20:23] <svnbot6> r7950 | gaal++ | when ({ closure }) { ... } - fix tests (they pass now)

[20:23] <svnbot6> r7950 | gaal++ | (following luqui's remark on the channel that this is the likely spelling.)

[23:10] <liz6> ?eval 1^..3

[23:10] *** evalbot_7947 is now known as evalbot_7950

[23:10] <evalbot_7950> (2, 3) 

[23:10] <liz6> ?eval 1..^3

[23:10] <evalbot_7950> (1, 2) 

[23:11] <Juerd> ?eval 1^..^3

[23:11] <evalbot_7950> (2,) 

[23:11] <Juerd> ?eval 0^..^0

[23:11] <evalbot_7950> pugs: Prelude.init: empty list 

[23:11] <theorbtwo> Anime operators!

[23:11] <Juerd> ?eval 0^..^0; say "foo"

[23:11] <evalbot_7950> pugs: Prelude.init: empty list 

[23:11] <Juerd> Bug.

[23:12] <liz6> report!

[23:12] <liz6> ;-)

[23:13] <liz6> ?eval 0..^0

[23:13] <evalbot_7950> () 

[23:13] <theorbtwo> Create a test.

[23:13] <liz6> ? eval 0^..0

[23:14] <liz6> ?eval 0^..0

[23:14] <evalbot_7950> () 

[23:14] <liz6> ?eval 7^..^7

[23:14] <evalbot_7950> pugs: Prelude.init: empty list 

[23:14] <liz6> not just for 0...

[23:14] <liz6> ?eval 7^..^8

[23:15] <evalbot_7950> () 

[23:15] <liz6> ?eval 7^..^6

[23:15] <evalbot_7950> pugs: Prelude.tail: empty list 

[23:15] <liz6> ?eval 5..1

[23:15] <evalbot_7950> () 

[23:15] <theorbtwo> Somehow, I fail to see the use of ^ed infix:<..>.

[23:17] * liz6 was just going through S03 and noticed N^..^M for the first time

[23:19] <Juerd> I knew it exists, but think it shouldn't. :)

[23:19] <Juerd> theorbtwo: Re the report - will perhaps do later.

[23:20] <liz6> ?eval 5..1

[23:20] <evalbot_7950> () 

[23:20] <liz6> isn't that supposed to generate (5,4,3,2,1) ?

[23:21] <theorbtwo> ?eval 5..1:by(-1)

[23:21] <evalbot_7950> Error:  unexpected ":" expecting digit, "_", fraction, exponent, term postfix, operator, "does", "but", "is", "^..^", "cmp", "<=>", "^..", "..^", "..", postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[23:21] <Juerd> Though if you feel like copy/pasting for me: ok(eval "0^..^0; 1", "Empty list doesn't die");

[23:21] <Juerd> liz6: Unfortunately, no.

[23:21] <Juerd> liz6: Larry still isn't convinced.

[23:21] <theorbtwo> Anyway, that's supposed to do 5,4,3,2,1.

[23:22] <liz6> theorbtwo: yes, I remember from the talk at Euro OSCON now...

[23:23] <liz6> lookin ar S03, "=:=" is now "===", is that right?

[23:23] <clkao> r7rl

[23:23] <clkao> 

[23:23] <Juerd> liz6: Yes

[23:24] <theorbtwo> I think iblech patched to that effect earlier today.

[23:24] <liz6> ?eval $a := $b; if ($a =:= $b} say "yes"

[23:24] <evalbot_7950> Error:  unexpected "i" expecting ";", statements or end of input reserved word 

[23:24] <liz6> ?eval $a := $b; if ($a =:= $b) say "yes"

[23:24] <evalbot_7950> Error:  unexpected "i" expecting ";", statements or end of input reserved word 

[23:24] <liz6> ?eval $a := $b; if ($a =:= $b) {say "yes" }

[23:24] <evalbot_7950> Error: Undeclared variable: "$b" 

[23:25] <liz6> ?eval $b = 1;$a := $b; if ($a =:= $b) {say "yes" }

[23:25] <evalbot_7950> Error: Undeclared variable: "$b" 

[23:25] <xinming> ?eval $.a = 1;

[23:25] <evalbot_7950> Error: Undeclared variable: "$?SELF" 

[23:25] <liz6> ?eval my $b = 1;my $a := $b; if ($a =:= $b) {say "yes" }

[23:25] <evalbot_7950> OUTPUT[yes ] bool::true 

[23:26] <liz6> ?eval my $b = 1;my $a := $b; if ($a === $b) {say "yes" }

[23:26] <evalbot_7950> OUTPUT[yes ] bool::true 

[23:26] <liz6> hmmm... can both be right?

[23:28] <luqui> in pugs === and =:= are the same thing

[23:28] <luqui> but they're not supposed to be

[23:29] <liz6> ah, ok

