[00:44] <svnbot6> r8405 | luqui++ | Large, gut-mangling change to fix:

[00:44] <svnbot6> r8405 | luqui++ |     my $a = [1,2,3];  my @b = $a;  @b.elems  # 3

[00:44] <svnbot6> r8405 | luqui++ | Incidentally, unary * works correctly now, too.

[00:45] <luqui> ?msg svnbot6 ?check

[00:45] <svnbot6> r8406 | luqui++ | P6GE now has captures, in their fully-specified glory.

[00:45] <svnbot6> r8406 | luqui++ | Once backtracking controls are in, then it will be a complete combinator library for perl 6 rules!

[00:54] <nothingmuch> luqui: please note to @Larry that your latest discussion, wrt rules reimplemented in perl 6 relates to circular prelude, etc

[00:54] <nothingmuch> and that this is a very nice example of why it's so important to think of this early

[00:55] <luqui> I guess so...

[00:56] <luqui> on the other hand, you can just think of the rules implementation as the beginning of the post-bootstrapping process for rules

[00:56] <luqui> (not to say that PGE won't be used---it most definitely will, because my implementation is a dog)

[01:00] <nothingmuch> well

[01:01] <nothingmuch> the point is that there's a reference implementation for everything

[01:01] <nothingmuch> which gives us:

[01:01] <nothingmuch> a. something users can refer to in doubt

[01:01] <nothingmuch> (when the docs aren't good enogh)

[01:01] * luqui has used that for Haskell a few times :-)

[01:01] <nothingmuch> b. something slow, but that still works

[01:01] <nothingmuch> (very quick backend writing)

[01:01] <nothingmuch> c. something that allows each backend to implement what they really need to implement

[01:01] <nothingmuch> even in a profile oriented way

[01:01] <nothingmuch> implement an opcode

[01:02] <nothingmuch> profile your code

[01:02] <luqui> I think the biggest block is the graph theory involved

[01:02] <nothingmuch> see what the next opcode to add should be

[01:02] <nothingmuch> we can simplify it a bit

[01:02] <nothingmuch> make it non circular

[01:02] <nothingmuch> a bit more ad hoc

[01:02] <nothingmuch> or whatever

[01:02] <nothingmuch> no, make it circular

[01:02] <luqui> uh... make the circular preluded noncircular?

[01:02] <nothingmuch> no

[01:02] <nothingmuch> that was a brain fart

[01:03] <luqui> I don't think you're going to get away from the graph theory... somebody just has to figure it out

[01:03] <luqui> it's probably related to a well-known algorithm

[01:03] <nothingmuch> aye

[01:03] <nothingmuch> but I have no time to think of it right  now

[01:03] <nothingmuch> job to demanding

[01:03] <luqui> the JS backend is pissing me off

[01:03] <nothingmuch> when my Catalyst stint ends, i'll get back to pugs land

[01:04] <nothingmuch> right now rewritten sessions and authen/authz are getting less problems

[01:04] <nothingmuch> better docs

[01:04] <nothingmuch> daily

[01:04] <luqui> cool, understood

[01:04] <nothingmuch> things are solidifying

[01:04] <nothingmuch> and after that I can just leave it to the community

[01:04] <nothingmuch> so anyway

[01:05] * audreyt wonders if it's possible to lure nothingmuch to Jifty6

[01:05] <nothingmuch> Jifty6?

[01:05] <audreyt> speculative idea of perl6 port of Jifty

[01:06] <luqui> why the heck can't I use modules from JS?!

[01:06] <audreyt> Jifty is the thing I've switched from catalyst to for $job

[01:06] <nothingmuch> what is Jifty?

[01:06] <nothingmuch> oh

[01:06] <luqui> for some reason it's looking for the "Parse" module, even though I'm using "Parse::Rule::Combinators"

[01:06] <audreyt> it was once known on my journal as "Bamboo"

[01:06] <nothingmuch> i see only Jifty::DBI on CPAN

[01:07] <nothingmuch> is it still a layer on top of Catalyst et al?

[01:08] <nothingmuch> ?

[01:09] <obra> It's never had anything to do with cat

[01:09] <obra> It comes out on XMAS

[01:09] <obra> Jifty::DBI is just the object-relational mapper we've got

[01:12] <nothingmuch> what does it do differently?

[01:12] <audreyt> nothingmuch: it's this continuation-capable, page-region-based, scriptaculous-powered, declaratively-modelled, absolutely-no-sql-needed-for-schema-generation, REST-action-based, buzzword-compliant thing

[01:13] <audreyt> nothingmuch: I think mostly the idea of page regions, decomposition to REST actions, and web continuations, are quite different

[01:14] <obra> It's also much more in the "one good way" than "everywhich way" camp than Catalyst.

[01:14] <audreyt> also, it has ajax_autocomplete, ajax_validate, ajax_link, ajax_tangent, ajax_everything that happens to degrade happily on w3m.

[01:14] <obra> (autocomplete doesn't work in w3m ;)

[01:15] <obra> hm.

[01:15] <obra> it could.

[01:15] <audreyt> I did say "degrade" :)

[01:15] <audreyt> and it could.

[01:16] <audreyt> however, its default presentation layer library is really primitive (the same level as Catalyst's default Scaffold); it can definitely be improved

[01:16] <nothingmuch> hmm

[01:16] <nothingmuch> sounds cool

[01:17] <nothingmuch> i don't have anything to do webapp wise in the short term future though

[01:17] <nothingmuch> so my answer is no ;-)

[01:17] <audreyt> that's fine :)

[01:17] <obra> audreyt: yes. the presentation-layer library wants love. lots of love.

[01:18] <obra> also a coherent theory behind it

[01:18] <audreyt> and also it probably wouldn't hurt to adopt catalyst-style attribute based controller

[01:18] * justatheory clears his throat

[01:18] <audreyt> if not as a default, certainly as an option

[01:18] <audreyt> to avoid dhandler overflow

[01:18] <obra> attribute-based controller?

[01:19] <obra> justatheory: when are you releasing your web framework?

[01:19] <audreyt> sub details : Regex('^product/(\w+)/details$') {

[01:19] <audreyt>     ....

[01:19] <audreyt> }

[01:19] <obra> ah. *nod*

[01:19] <obra> I sort of wonder if a dispatch table is a better answer than that.

[01:20] <obra> at least to fit with the jifty model.

[01:20] <audreyt> well, but it is a dispatch table :)

[01:20] <justatheory> obra: No idea. Will probably launch some apps first.

[01:20] <justatheory> Hopefully in 2006, though.

[01:20] <obra> sorry. but _just_ a dispatch table.

[01:20] <audreyt> ah. hm.

[01:20] <obra> how many apps do you have in the pipeline?

[01:20] <audreyt> maybe. I have no idea. have to experiment

[01:20] <obra> audreyt: nod.

[01:20] <justatheory> obra: One at th emo.

[01:20] <audreyt> but that's one single thing I miss from Cat.

[01:20] <obra> agree that we want it.

[01:20] <obra> *nod* I don't like the dhandler game

[01:21] <nothingmuch> okay, i'm off to bed

[01:21] <nothingmuch> also, i must warn you guys

[01:22] <nothingmuch> the reason i like catalyst is it's complete lack of one-good-way

[01:22] <obra> it'll get a lot easier when we get a working mason plugin.

[01:22] <audreyt> nothingmuch: indeed, that's what I liked -- and still like -- about perl5 as well

[01:22] <nothingmuch> because that makes flexibility be thought out very hard in advanced

[01:22] <nothingmuch> *advance

[01:23] <audreyt> but sometimes it doesn't hurt to experiment with bright white castels :)

[01:23] <nothingmuch> anyway, i'll take a long hard look at Jifty when it's out, and i'm doing web stuff again

[01:23] <audreyt> castles, even

[01:23] <nothingmuch> *yawn*

[01:23] <nothingmuch> shit, i wanted to bike tomorrow morning

[01:23] <luqui> audreyt, do you think Parse::Rule should do its own rule parsing, or should it just provide combinators for the perl 6 parser to call?

[01:23] <nothingmuch> luqui: two layers

[01:23] <luqui> nothingmuch, clearly

[01:23] <audreyt> luqui: Parse::Rule::Parse::Rule

[01:24] <luqui> :-)

[01:24] <nothingmuch> luqui: i mean, two modules

[01:24] <luqui> I was just wondering if the top layer was even necessary.  Like lemon meringue without the meringue

[01:24] <nothingmuch> make them pluggable

[01:24] <nothingmuch> and then make them easy

[01:24] <nothingmuch> anyway, i'm off

[01:25] <audreyt> luqui: you can do the pmichaud thing and use a precedence parser frontend that has no concre te syntax

[01:25] <audreyt> and bootstrap rule parsing from there

[01:26] <luqui> yeah, I figured.  So the answer is "yes you should do your own parsing"

[01:26] <luqui> It kinda makes sense if we want perl 6 to be self-hosting

[01:26] <luqui> something's got to parse the grammar spec

[01:30] <audreyt> *nod*

[01:30] <audreyt> porting 323 lines of PIR

[01:31] <audreyt> probably isn't that difficult

[01:31] <luqui> right

[01:35] <svnbot6> r8407 | luqui++ | Added test for [ [ x ]* ]* infinite loop, and made it pass.

[01:35] <luqui> there, now I'm officially better than PGE ;-)

[01:36] <audreyt> rofl

[01:37] <audreyt> hm, I wonder how long it can take to port that 323 lines to Hs

[01:37] * audreyt goes trying

[01:37] <luqui> why?

[01:38] <audreyt> for fun, mostly

[01:38] <luqui> ah.  I wrote a regex engine in like 30 lines of Hs using the list monad

[01:38] <audreyt> also parsec doesn't handle circumfix cleanly

[01:38] <luqui> to try out my approach...

[01:40] * luqui noticed with sadness that you couldn't define circumfix operators

[01:42] <audreyt> why?

[01:42] <luqui> er, in pugs

[01:42] <audreyt> er, that's another reason to write Text.Parser.OPTable now

[01:43] <luqui> makes sense

[01:43] <audreyt> parsec can emulate bottom up, but it's not going to be fast

[01:43] <audreyt> in fact that's one of the slowest parts

[01:43] <luqui> really?  how strange

[01:43] <audreyt> due to a lot of shifting in circumfix/postcircumfix

[01:44] <audreyt> currently we dynamically construct an prec parser every time we enter BEGIN

[01:44] <audreyt> and cache it inside the parser

[01:44] <audreyt> which does speed up things

[01:44] <audreyt> but I'd like something less dependent on unsafePerformEval

[01:44] <luqui> aye

[01:45] <luqui> well, I guess we'll all be writing OPTable at the same time then

[01:45] <audreyt> it's a race!

[01:45] <luqui> however, I have to sleep now.

[01:45] <luqui> oh darn, I'll lose

[01:45] <luqui> stupid sleep

[01:45] <audreyt> :)

[01:45] <audreyt> good night, sleep well

[01:45] <audreyt> if I manage to pull it off, you'll probably have a much easier time porting it to p6

[01:45] <luqui> because it's possible to read haskell?

[01:46] <audreyt> sir, you are really mean when you're sleepy :)

[01:46] <luqui> what?

[01:46] <audreyt> just go sleeping already

[01:46] <luqui> oh, mean towards PIR.  but it deserves it.  :-)

[01:46] <luqui> mwahaha

[01:47] <luqui> sayonara

[01:47] <audreyt> (yes, because haskell makes algorithm flow more explicit. but no, I don't think PIR is impossible to read)

[01:47] * luqui &

[01:47] <luqui> yeah, but you're audrey

[01:47] * luqui fg;bg

[01:54] <luqui> oh, audreyt, one more thing

[01:54] <luqui> how is pugs's support for continuations these days

[01:57] <audreyt> luqui: limited to coroutines and nonreentrant &?CALLER_CONTINUATION

[01:58] <audreyt> again, the new runcore is designed with full serializable continuations

[01:58] <luqui> ooh, serializable... shiny

[01:58] <luqui> using continuations, Parse::Rule could be made quite a bit more readable

[01:59] <audreyt> but the JS core is fully resumable in $?CALLER_CONTINUATION

[01:59] <luqui> but I'll wait on the new runcore to convert it to that

[01:59] <audreyt> oh? you can't just use exceptions?

[01:59] <audreyt> try { die $obj }

[01:59] <luqui> hmm

[01:59] <audreyt> because you the throw out whole coros or closures, that's sometimes easier than continuations

[01:59] <audreyt> (sometimes it's even easier just to code things as coro, as parrot hackers seem prone to do)

[02:00] <luqui> I tried as coro

[02:00] <luqui> lots of repetition

[02:00] <luqui> I ended up explicitly looping over results way too much

[02:00] <luqui> CPS was a good fit

[02:00] <luqui> but explicit CPS is inherently hard to read

[02:01] <luqui> (on the plus side, It can be transliterated easily to perl 5 with the current implementation)

[02:01] <luqui> anyway, off to bed

[02:01] * luqui &

[02:01] <avar> fg

[02:03] <audreyt> strangely I've got the API implemented in no time

[02:03] <audreyt> now to implement the shift/reduce rules...

[02:18] <dduncan> commit pending ...

[02:18] <stevan> audreyt: ping

[02:22] <dduncan> done

[02:22] <svnbot6> r8408 | Darren_Duncan++ |  r1549@Darren-Duncans-Computer:  darrenduncan | 2005-12-23 18:20:09 -0800

[02:22] <svnbot6> r8408 | Darren_Duncan++ |  /ext/Rosetta-Incubator : in Language.pod, rewrote the 'Native Primitive Types' section, particularly about numeric types, and edited some other parts

[02:22] <dduncan> I did a fair amount of thinking about that numerics stuff ... feedback appreciated

[02:23] <dduncan> considering I tend to buck the trend's there that I know about

[02:24] <stevan> obra: re: Jifty, how are you doing continuations? Coro? something else?

[02:25] <obra> we're doing app-level continuations.

[02:25] <obra> "We're faking it"

[02:25] <stevan> ah

[02:25] <stevan> fake it until you make it :)

[02:25] <obra> but, it seems to work pretty well

[02:25] <stevan> is Jifty public yet?

[02:25] <audreyt> managing one's own heap is definitely the way to go

[02:25] <obra> Sunday

[02:25] <audreyt> if you control both the controller _and_ the presentation

[02:25] <stevan> excellent

[02:26] <obra> audreyt: we should talk some time about gc strategies for continuations

[02:26] * stevan has to find a new web framework & ORM solution for $work

[02:26] <audreyt> obra: I still advocate stashing it all to the webpage

[02:26] <audreyt> obra: zero gc on server side

[02:26] <stevan> $client is not into the ide of using ruby

[02:26] <audreyt> obra: so, SHA1_HMAC

[02:27] <obra> audreyt: chmrr had some good reasons not to do that

[02:27] <obra> stevan: how soon?

[02:27] <audreyt> obra: I'd like to hear them

[02:27] <obra> audreyt: after sunday morning ;)

[02:27] <obra> but yeah, I'd like you and him to debate it.

[02:27] <obra> :)

[02:27] <stevan> obra: well, the current project ends Feb. 1, and we need to decide what to use before the next project (around March)

[02:28] <obra> ok. so not a need-a-test-release-cut-tonight

[02:28] <stevan> not at all :)

[02:29] <obra> cool

[02:30] <dduncan> fyi, from my reading, the term ORM is a bit of a misnomer

[02:30] <dduncan> considering that many objects are essentially just multi-part types

[02:30] <dduncan> and the plain relational model allows for those

[02:30] <stevan> dduncan: I agree, but its recognizable :)

[02:30] <dduncan> sure

[02:31] <obra> it maps from Objects into a Relational Database

[02:31] <dduncan> but I'm just pointing out that people mention object-relational as if it were different from relational

[02:31] <dduncan> whereas plain-relational supports objects

[02:31] <obra> In standard use, has nothing to do with an object-relational database

[02:31] <obra> it's talking about first-class in-your-language objects

[02:32] <avar> dduncan: doesn't ORM refer to stuff like defining a table as extending the definition of another table?

[02:32] <dduncan> of course, the relational model was designed to be embedded in another programming language, rather than being something separate

[02:32] <dduncan> the relational model says that you have sets which are related to other sets

[02:32] <dduncan> it provides common ways of organizing and processing those

[02:33] <dduncan> its loosely like how Perl has hashes as a first class variable type

[02:33] <dduncan> a relation is like a hash where the key is multi-valued, and there is no hash value

[02:34] <dduncan> and all hash keys have the same number and type of values

[02:34] <dduncan> so one hash key is a tuple

[02:34] <dduncan> the whole hash is a relation

[02:34] <dduncan> of course, that assumes no duplicates allowed or undefs/nulls

[02:35] <dduncan> a multiset is like a relation but that you use the hash value to count occurances where the key occurs in the set more than once

[02:35] <dduncan> adding nulls complicates things

[02:36] <dduncan> put another way,

[02:36] <dduncan> a relation is like a junction of array refs, where each array has the same number of elements

[02:36] <dduncan> and corresponding elements are of the same type

[02:37] <dduncan> I'm not sure if Perl supports junctions of array refs, though

[02:37] <dduncan> oh yes

[02:37] <dduncan> and each array element / hash key part can be arbitrarily complex type

[02:38] <dduncan> either a scalar or multi-part object

[02:40] <audreyt> stevan: er, sorry, pong.

[02:40] <stevan> audreyt: :)

[02:40] <stevan> did  you see my ramblings earlier 

[02:41] <stevan> the new infix ops dont work since there is no send defined (at least not one I or ./pil could find)

[02:41] <audreyt> $ ./pil -e '1`add(3)'

[02:41] <audreyt> 4

[02:41] <stevan> :/

[02:41] <stevan> lemme svk up again

[02:42] <stevan> everything still works though,.. 

[02:43] <stevan> Bootstrap.pil still compiles and the tests pass

[02:43] <stevan> is that intentional?

[02:43] <stevan> do_if, do_for, etc are not subject to this right?

[02:45] <audreyt> currently .send just dispatch to ` if it's not userdefined

[02:45] <stevan> audreyt: ./pil -e '::Class`is_nil`cond(-> { true }, -> { false });'

[02:45] <audreyt> so it's operationally the same

[02:46] <stevan> I am sorry... I didnt look deep enough,.. that last bit fails

[02:46] <stevan> other ones work

[02:46] <stevan> but it seems it fails when chained

[02:47] <audreyt> fixed

[02:47] <stevan> :)

[02:47] <audreyt> brb

[02:47] * stevan resumes reasing about R/OM while he waits for svnbot 

[02:49] <svnbot6> r8409 | audreyt++ | * allow chained `method calls.

[02:55] <obra> R/OM?

[02:55] <stevan> obra: this article http://www.onjava.com/lpt/a/6366

[02:55] <stevan> it is an interesting point of view on the idea

[02:56] <stevan> basically the idea is that in some cases,.. the R should lead the O

[02:56] <stevan> where most ORM tools (especially Java ones) force the other way around

[02:57] <stevan> audreyt: the null instance now is ::`new_opaque({})

[02:57] <stevan> I kinda like that 

[03:01] <r0nny> yo

[03:01] <r0nny> howz the state of the object system atm ?

[03:01] <stevan> r0nny: if you dont need imperitive features like assignment and loops,.. it is pretty good :)

[03:02] <stevan> r0nny: we have the entire class system, and a slightly broken (but usable) role system, and the foundation of the boxed type system

[03:02] <dduncan> stevan, that article has good ideas

[03:02] <stevan> but it is all still in PIL

[03:03] <stevan> dduncan: yes, i think so too,.. it is particularly applicable to the work I do, where the data model really should lead

[03:03] <r0nny> n8 then, and marry christmas

[03:04] <stevan> r0nny: same to you :)

[03:04] <dduncan> its certainly safer for the data model to lead, since that lets the database do what it's good at, and helps make the data safer

[03:05] <stevan> dduncan: yes, and it helps in seperating responsibilties too,.. if the DBA owns the database, rather than maintains the mess the ORM system created,.. he/she is more likely to be happy

[03:06] * stevan has decided that he is a really really *really* bad DBA, and should never be trusted with control of anything but a really simple schema

[03:07] <stevan> so $coworker is now in charge of it since he is a good DBA 

[03:09] <stevan> audreyt: I have just converted everything to use ` and . appropriately, and I am running the tests to make sure all is well

[03:10] <stevan> if all goes well, can we make it so that ` and . /only/ work for prims and user-defined respectively?

[03:11] <stevan> I would like to make sure there is nothing I missed which might bit me later

[03:19] <svnbot6> r8410 | audreyt++ | * Text.Parser.OpTable -- Haskell port of PGE::OPTable.

[03:19] <svnbot6> r8410 | audreyt++ |   All data structures and APIs are there; need to fill in

[03:19] <svnbot6> r8410 | audreyt++ |   implementation now, but it should help luqui++ a lot already :)

[03:28] <audreyt> yes

[03:28] <audreyt> what about !

[03:28] <audreyt> does it not consult MRO?

[03:28] <stevan> no, that should

[03:28] <stevan> it is for user defined private methods right?

[03:28] <audreyt> yes

[03:29] <audreyt> my method foo

[03:29] <stevan> yes, that doesnt use the MRO anyway

[03:29] <stevan> it consults the current class, if it doesnt find the method,.. it fails

[03:30] <stevan> sorry,.. (re-reading previous statements),... ! should *not* consult MRO

[03:30] <audreyt> good, then we are still on the same page

[03:32] <stevan> no ;)

[03:32] <audreyt> oh? ;)

[03:32] <stevan> ok, you convinced me 

[03:33] <audreyt> heh :p

[03:33] <audreyt> do you think $closure`() is hard to type? should we introduce sugar $closure() ?

[03:34] * audreyt feels like a sugar dealer in the past week or so

[03:35] <stevan> well, if we did $closure(), then we need to do -> { }do_if(...)

[03:35] <stevan> to keep things consistent

[03:35] <audreyt> no, it's just for `()

[03:35] <stevan> or, we can do $closure() and -> { }`do_if(...)

[03:35] <audreyt> yeah

[03:35] <audreyt> but then $closure.() will mean different things as $closure()

[03:36] <stevan> hmm

[03:36] <stevan> maybe it should be $closure`() then

[03:36] <audreyt> k

[03:36] <stevan> I think you and I will likely be the only ones ever writing this anyway (at least for the forseeable future)

[03:37] <audreyt> yup

[03:40] <audreyt> let me finish OpTable.addToken first

[03:40] <audreyt> pmichaud's clever algorithm is a bit too clever

[03:40] <audreyt> I'm not sure if it is actually correct on precedence handling

[03:40] <stevan> ok, take your time,.. I need to think/read about roles anyway

[03:41] * stevan wanders over to Scala  

[03:43] <audreyt> fwiw, while our dynamic side calculus resembles YARV, I'd like the static side to resemble vObj/lambdaCube

[03:44] <audreyt> (vObj is what Scala uses internally)

[03:44] <audreyt> they have this new self-hosting compiler for Scala written in Scala that I kept meaning to check out but didn't got the timeslice

[03:45] <stevan> do you have links for vObj lambdaCude papers? 

[03:46] * stevan needs to just get an ACM membership so he can read all the good papers

[03:46] <audreyt> all vObj papers are in http://scala.epfl.ch/docu/related.html

[03:48] <audreyt> one implementation of lambda cube is in Jhc's "data E" type:

[03:48] <audreyt> http://repetae.net/john/repos/jhc/E/E.hs

[03:49] <audreyt> lambda cube related papers: http://www.cs.ru.nl/~henk/papers.html

[03:49] <audreyt> Jhc's take on reified types: http://repetae.net/john/computer/jhc/jhc-reify-typeclass.html

[03:50] <stevan> which paper is most relelvant to Lambda Cude

[03:51] <audreyt> well... as usual we turn to the great educator SPJ

[03:51] <audreyt> http://research.microsoft.com/~simonpj/Papers/henk.ps.gz

[03:53] <azuroth> test

[04:08] <audreyt> stevan: henk is coauthored by emeijer, who brought much of the type calculus to VB's soft typing which I hope to emulate

[04:08] <stevan> ok

[04:09] <stevan> this stuff is a little over my head,.,. but I will attempt to grok as best I can (well at least the vObj stuff so far)

[04:09] <audreyt> I suggest you focus on vObj for 6.28.0 :)

[04:10] <audreyt> we won't need \Cube until 6.2813

[04:10] <stevan> ok

[04:10] <stevan> can you explain "dependent types",.. I am confused by the term

[04:10] <audreyt> ok

[04:13] <stevan> the "nominality" stuff sounds similar to @Larrys "class but undef" thing

[04:14] <audreyt> normally we have functions, which is a term whose value depend on other terms

[04:14] <audreyt> then we also have higher-rank types like "Hash of ::t", which is a type that depend on other types

[04:15] <stevan> ah

[04:15] <stevan> ok, this makes sense then in the context they are talking about

[04:15] <audreyt> there are also term depending on types, which is typecasing

[04:15] <stevan> they are talking about the SML module system... where stuff like that is easy to express

[04:15] <audreyt> or compile-time ref()

[04:15] <audreyt> so far so good?

[04:16] <stevan> so far so good

[04:16] <stevan> typecasing or typecasting?

[04:16] <audreyt> typecasing... think want()

[04:16] <stevan> ok

[04:16] <audreyt> which is a term whose value depending on the (return) type

[04:16] <audreyt> finally we come to dependent types

[04:16] <audreyt> which is a type that depends on terms

[04:17] <audreyt> for example, the "n-Tuple" type

[04:17] <audreyt> depends on a concrete value "n"

[04:17] <stevan> Hash of foo()? where foo() returns some kind of type?

[04:17] <audreyt> think shape()

[04:18] <audreyt> :shape, even

[04:18] <stevan> ok

[04:18] <stevan> SML functors come to mind

[04:18] <stevan> types which depend on types whose value may not be known at that moment

[04:19] <stevan> am I on the right track? or smoking crack?

[04:19] <audreyt> that's still tyop

[04:19] <audreyt> type operator

[04:19] <audreyt> you have to depend on some concrete runtime term's value

[04:19] <audreyt> it's not expressible in ordinary ML or Haskell98

[04:20] <audreyt> arrayOfThreeInts :: Array 3 Int

[04:20] <audreyt> here the "3" is not a type, but a normal term (literal value)

[04:20] <audreyt> that's a dependent type

[04:21] <stevan> oh

[04:21] <stevan> hmmm

[04:21] <stevan> how is this useful? is there a real world context for this?

[04:21] <audreyt> is arrays of three ints not useful?

[04:21] <audreyt> boundedNumber :: IntBetween 3 4

[04:22] <stevan> ok

[04:22] <audreyt> with GADTs haskell gains the ability to express dependent types

[04:22] <stevan> now I am thinking about Ada subtypes

[04:22] <audreyt> yes, but does Ada check them at compile time, or are they all turned into assertions?

[04:23] <stevan> I think Ada checks at compile time,.. but thats because it's Ada, and planes are better left in the sky :)

[04:23] <audreyt> also, bounds are easy... what's harder is

[04:23] <stevan> but conceptually it is helping me make the leap

[04:23] <audreyt> n = 4

[04:23] <audreyt> foo = 2 :: IntBetween 1 n

[04:23] <audreyt> or even

[04:24] <audreyt> makeFoo n = 2 :: IntBetween 1 n

[04:24] <audreyt> in perl6:

[04:24] <stevan> so runtime type construction?

[04:24] <audreyt> sub makeFoo ($n) { my Int where { 1..$n} $x = 2 }

[04:24] <audreyt> yeah

[04:24] <stevan> oh

[04:24] <stevan> very cool

[04:25] <audreyt> yup, very cool.

[04:25] <audreyt> I think it's definitely 1)useful 2)sexy 3)finally somwhat understood

[04:25] <stevan> what would the return value of that p6 function be?

[04:25] <audreyt> it will be 2

[04:25] <audreyt> unless $n is < 2

[04:26] <audreyt> where it is an error

[04:26] <stevan> ok

[04:26] <audreyt> and presumably you can check it at compile time if you see makeFoo(0).

[04:26] <stevan> but it seems that this brings the power of compile time type-checking to runtime

[04:27] <stevan> or does it bring the flexibility of runtime to compile time (where it can be checked)?

[04:28] <audreyt> both.

[04:28] <audreyt> it... blurs the boundary between runtime and compile time.

[04:28] <stevan> even better :)

[04:28] <audreyt> which perl has been doing (very crudely and dangerously) for ages.

[04:29] <stevan> yes

[04:29] <stevan> I see why this is important for us

[04:29] <audreyt> and now there's finally some light in formalizing this :)

[04:35] <stevan> one more questions

[04:36] <stevan> when they say in the vObj paper ... "objects and classes with type members"... they mean the object has attributes which are types?  

[04:39] <audreyt> yes.

[04:39] <stevan> like inner classes? 

[04:40] <stevan> class Foo { has Class $.bar = Class.new(name => 'Bar'); }

[04:40] <audreyt> something like that, yes

[04:40] <stevan> or maybe

[04:40] <stevan> class Foo { my class Bar { } }

[04:42] <audreyt> aye

[04:43] <stevan> class Foo[::T] { my class Bar is ::T { } }

[04:43] <stevan> would that be a "dependent type"?

[04:44] <stevan> since the value of T would be deferred until later in the program 

[04:45] <audreyt> well, if all this happens at compile time, no, that's just a type operator

[04:45] <audreyt> a type depending on type

[04:45] <audreyt> class Foo[&f] { ... }

[04:46] <audreyt> is another matter

[04:46] <stevan> my $foo  = new Foo[@ARGV[0]]  :P

[04:46] <audreyt> now, allowing that syntax makes it effectively dependent typing, yes.

[04:46] <stevan> how would &f be used in the body of Foo?

[04:47] <audreyt> it would presumably be invoked.

[04:47] <stevan> and its return value be used in a type annotation/definition?

[04:49] <audreyt> presumably, yes. it's not really p6, just for illustration

[04:49] <audreyt> I'll brb

[04:49] <stevan> ok

[05:08] * stevan sleep &

[05:24] <asavige> anybody there to answer my dumbass p6 questions?

[05:26] <azuroth> I'll give it a go, if they actually are dumbass :-)

[05:26] <asavige> ok, thanks i've got @lol = ( [ '1a', '1b' ], [ '2a', '2b' ] );

[05:27] <asavige> now I want to iterate for @lol -> $t { say "1st='$t[0]' 2nd='$t[1]'" } works

[05:27] <asavige> but i want to write: for @log -> $x, $y but I don't know how to flatten

[05:28] *** wolv is now known as wolverian

[05:29] <dduncan> yes, "Laugh Out Loud" sounds like typically dumbass conversation :)

[05:29] <azuroth> ?eval my @a = (['1a','1b'],['2a','2b']); for @a -> [$x,$y] { say $x ~ $y; };

[05:29] *** evalbot_8404 is now known as evalbot_8410

[05:29] <evalbot_8410> Error:  unexpected "f" expecting ";", statements or end of input reserved word 

[05:29] <azuroth> ?eval my @a = (['1a','1b'],['2a','2b']); for @a -> $x,$y { say $x ~ $y; };

[05:29] <evalbot_8410> OUTPUT[1a 1b2a 2b ] undef 

[05:30] <azuroth> ?eval my @a = (['1a','1b'],['2a','2b']); for *@a -> $x,$y { say $x ~ $y; };

[05:30] <evalbot_8410> OUTPUT[1a 1b2a 2b ] undef 

[05:30] <azuroth> hmm. sorry, I've got no idea

[05:32] <asavige> azuroth: thanks (I groped around with those variations too;-)

[05:33] <azuroth> that's alright. I'm gonna try installing nvidia drivers, brb!

[06:17] <svnbot6> r8411 | audreyt++ | * Text.Parser.OpTable: addToken fully implemented.  that's 50% of the functions...

[06:59] <svnbot6> r8412 | audreyt++ | * Text.Parser.OpTable: Helper classes to construct optables easily

[07:04] <obra>  having fun, audreyt 

[07:07] <audreyt> yeah, cloning PGE.

[07:07] <audreyt> almost there now.

[07:07] <audreyt> (the shift/reduce part; the full grammar part is luqui's job)

[07:14] <audreyt> bbiab &

[07:14] <svnbot6> r8413 | audreyt++ | * Text.Parser.OpTable: DynStr node, which covers callbacks

[07:14] <svnbot6> r8413 | audreyt++ |   to PGE::Match and other callback-code nodes.

[07:17] <obra> Next task: implement PGE in Sendmail.cf

[07:59] <dduncan> question:

[07:59] <svnbot6> r8414 | asavige++ | added some more split tests

[08:00] <dduncan> what is the perl 5 equivalent of aliasing a lexical variable from another, like := does in perl 6?

[08:00] <dduncan> a bit of experimenting I tried with '\' and '*' didn't seem to work

[08:00] <dduncan> perhaps the * only works on globals

[08:01] <dduncan> '*' meaning glob

[08:06] <asavige> dduncan: S2 says "typeglobs are gone. Use binding (:= or ::=) to do aliasing"

[08:06] <asavige> typeglobs don't work on lexicals though

[08:06] <dduncan> yes

[08:07] <dduncan> but I'm trying to make some perl 5 code act like perl 6

[08:07] <dduncan> in perl 6, I can say %foo := %bar

[08:07] <dduncan> what is the perl 5 equivalent of that?

[08:07] <dduncan> and note that %foo and %bar are both lexicals, declared with 'my'

[08:07] <asavige> k. sorry, don't know how to do aliasing on lexicals

[08:11] <dduncan> specifically, I want to do something like this: my %hash; \%hash = $hash_ref;

[08:11] <buu> dduncan: Tie, generally.

[08:11] <buu> dduncan: Or scary glob vooodooo

[08:11] <dduncan> if anyone else knows, glad tohear it

[08:11] <buu> try

[08:11] <dduncan> yes, what is the scary glob vodoo?

[08:12] <buu> eval: %h1 = qw/foo bar/; *h2=*h1; $h2{foo}

[08:12] <dduncan> it seems that *foo = \$bar doesn't work

[08:12] * buu pokes eval

[08:12] <buu> oh

[08:12] <dduncan> that may only work for globals

[08:12] <buu> eval: %h1 = qw/foo bar/; *h2=*h1; $h2{foo}

[08:12] <p5evalbot> buu: Return: bar 

[08:12] <buu> eval: %h1 = qw/foo bar/; *h2=*h1; $h2{foo}='wtf'; $h1{foo}

[08:12] <p5evalbot> buu: Return: wtf 

[08:13] <buu> You can make pseudo lexical globs with local.

[08:13] <buu> Obviously you can't refer to the globs of lexicals.

[08:13] <asavige> maybe look at Lexical::Alias on CPAN by Japhy?

[08:13] <integral> lexicals don't have globs.    There's also Data::Alias

[08:13] <dduncan> my situation is that I'm trying to emulate 'trusts' in perl 5

[08:13] <jdv79> trusts?

[08:13] <dduncan> I have a function that exports \%foo from one package, and that func is called by the other

[08:14] <dduncan> what the func returns is a hash-ref

[08:14] <dduncan> I want a lexical hash in the calling package to point to what the hash-ref does

[08:14] <buu> Abuse tie.

[08:14] <buu> It's fun and profitable!

[08:14] <integral> I think you'll have to

[08:14] <dduncan> it should be a non-tie solution

[08:14] <buu> Too bad.;

[08:15] <dduncan> I was hoping some simple symbol manip would work

[08:15] <buu> Obviously symbol manipulation works. /me points upwards

[08:15] <integral> not for lexicals.  there's no symbol to manip unfortunately.    But PadWalker, Lexical::Alias, Data::Alias might help

[08:15] <dduncan> I'll look up the Lexical::Alias

[08:17] <asavige> Lexical::Alias is done at XS level

[08:17] <jdv79> are we there yet?

[08:17] <buu> Yes.

[08:18] <dduncan> oh ... don't want to use xs

[08:18] * buu aliases here to there.

[08:18] <buu> You are whiny.

[08:18] <integral> dduncan: umm, you'll have to...

[08:18] <jdv79> the man knows what he wants and he wants it now!

[08:18] <jdv79> :)

[08:18] <buu> Data::Alias doesn't seem to have xs

[08:19] <buu> Oh wait, I lie

[08:19] <dduncan> if I can't find a solution, then at least I have the workaround of using the $hash_ref->{foo} instead of $hash{foo}

[08:19] <buu> It's there at the top.

[08:19] <buu> dduncan: Yes.. workaround..

[08:19] <dduncan> but I wanted to try something new, make the code look nicer

[08:19] <buu> dduncan: What earthly reason do you have to be so picky?

[08:20] <dduncan> making similar-acting code look similar

[08:20] <dduncan> its just a preference

[08:20] <buu> dduncan: So about my question?

[08:20] <dduncan> will look at data::alias

[08:21] <dduncan> I wanted to do this aliasing thing as a style preference

[08:21] <buu> So use tie

[08:21] <buu> Where's the problem?

[08:22] <dduncan> the problem was that I wanted it to be simple, more importantly

[08:22] <dduncan> if its not as simple as $hash_ref, I'll just use $hash_ref

[08:22] <buu> Uh

[08:23] <buu> tie %x,$y; $x{y}

[08:23] <dduncan> is that all that's necessary?

[08:23] <buu> Yes

[08:23] <dduncan> I thought I had to declare accessors

[08:23] <buu> Well, yes, in the module.

[08:23] <buu> But the using code is clean.

[08:23] <buu> Tie actually needs a third argument.

[08:24] <dduncan> thank you for your help

[08:24] <buu> Hrm. sub FETCH { $self->{$_[0]} }

[08:59] <dduncan> okay, commit pending ...

[09:08] <dduncan> ... delayed ... have to find my password again ...

[09:11] <azuroth> tell me when you find it

[09:12] <dduncan> I just have to so rarely enter it ... don't know why I'm being prompted now of all times

[09:12] <dduncan> oh, that's why

[09:12] <dduncan> the server's down

[09:13] <azuroth> yeah, auto-remember password things always end in disaster

[09:13] <dduncan> audreyt, it appears that the svn service is down, but the physical server's up, so maybe you can fix it remotely?

[09:18] <dduncan> well, the perl 5 version is committed to utsl anyway ... the perl 6 version will have to wait until tomorrow, unless the server's back up shortly

[11:56] <luqui> buu, somebody had to tell him :-)

[12:37] <luqui> ?eval my %hash = (a => 1, b => 2);  my $h = { %hash };  $h.perl

[12:37] *** evalbot_8410 is now known as evalbot_8414

[12:37] <evalbot_8414> "\\sub \{...}" 

[12:37] <luqui> ?eval my %hash = (a => 1, b => 2);  my $h = { b => 2, c => 3 };  $h.perl

[12:37] <evalbot_8414> "\{(\"b\" => 2), (\"c\" => 3)}" 

[13:01] <luqui> Umm..... why can't I commit?

[13:02] <azuroth> dduncan was saying earlier that svn is down, even though the server is up

[13:02] <luqui> I can update...

[13:02] <luqui> but the openfoundry webpage is giving me internal server error

[13:02] <luqui> so maybe their auth database is causing problems

[13:02] <luqui> good think I have svk ;-)

[13:03] <azuroth> hmm, yeah

[13:03] <luqui> s/k/g/

[13:23] <luqui> ?eval sub hr() { { a => 1, b => 2 } }  hr.{'a'}

[13:23] <evalbot_8414> \undef 

[13:23] <luqui> ?eval sub hr() { { a => 1, b => 2 } }  hr{'a'}

[13:23] <evalbot_8414> \1 

[13:23] <luqui> ?eval sub hr() { { a => 1, b => 2 } }  hr .{'a'}

[13:23] <evalbot_8414> \undef 

[14:41] <Mahmoud> hi

[14:43] <luqui> hola

[14:47] <Mahmoud> what is perl six

[14:47] <luqui> do you know what perl 5 is ?

[14:48] <Mahmoud> a scripting language

[14:49] <Mahmoud> compiled and interporated language

[14:49] <Mahmoud> i already use perl five but i head a lot about perl six.. but too lasy to read all what was said

[14:49] <luqui> perl 6 is the next version of perl the language

[14:49] <luqui> okay

[14:49] <luqui> you can play with it in here:

[14:49] <Mahmoud> it will be like a new language right?

[14:49] <luqui> ?eval say "hello, world"

[14:49] <evalbot_8414> OUTPUT[hello, world ] bool::true 

[14:49] <luqui> yeah, pretty much

[14:50] <Mahmoud> close to c and c++?

[14:50] <luqui> uh.... farther than perl 5 was

[14:50] <azuroth> ?eval my @a = (1, 2, 3, 4, 5); @a >>+<< (5, 3);

[14:50] <evalbot_8414> (6, 5, 3, 4, 5) 

[14:50] <Mahmoud> wtf?

[14:50] <luqui> azuroth, don't scare him right of the bat, geez

[14:50] <azuroth> sorry. I think it's cool

[14:51] <luqui> j/k

[14:51] <Mahmoud> perl six will be better for OOP?

[14:51] <luqui> yep

[14:51] <Mahmoud> but little slower and more resources needed?

[14:51] <azuroth> ?eval my @a = (1, 2, 3, 4, 5); @a >>*<< 2; # double all

[14:51] <evalbot_8414> (2, 4, 6, 8, 10) 

[14:51] <luqui> ?eval class Foo { has $.bar;  method say_bar() { say $.bar } }  my $foo = Foo.new(bar => 4);    $foo.say_bar()

[14:51] <evalbot_8414> OUTPUT[4 ] bool::true 

[14:51] <Mahmoud> print "foo";

[14:52] <Mahmoud> ?eval print "foo";

[14:52] <evalbot_8414> OUTPUT[foo] bool::true 

[14:52] <luqui> Mahmoud, at the moment it's a lot slower

[14:52] <azuroth> hopefully not, Mahmoud! parrot's our dedicated VM, and it's pretty fast

[14:52] <Mahmoud> why there is no ';' at the end? canceled?

[14:52] <luqui> but the current implementation is just a bootstrap

[14:52] <luqui> the idea is that it will be faster, because it will be more aggressively compiled

[14:53] <Mahmoud> ?eval my $var;

[14:53] <evalbot_8414> undef 

[14:53] <luqui> (but that may be a dream given all the new features.  I imagine it will end up being about the same speed overall)

[14:53] <Mahmoud> i think OOP is always slower

[14:53] <Mahmoud> just like C and CPP..

[14:53] <luqui> well, Perl 5 had OO

[14:53] <luqui> it was just a pain to use

[14:53] <Mahmoud> C has OO too

[14:54] <Mahmoud> i should not talk about OOP..

[14:54] <luqui> it's really more about the style of programming when you're in an OO language

[14:54] <azuroth> s/has/can do/ ?

[14:54] <Mahmoud> i didn't do it with perl

[14:54] <Mahmoud> will they include multi line comments?

[14:54] <Mahmoud> c style comments

[14:54] <luqui> heh, no

[14:54] <luqui> but there's always POD

[14:54] <Mahmoud> ?eval #comment

[14:54] <evalbot_8414> undef 

[14:55] <Mahmoud> larry wall hates c style comments for personal reasons

[14:55] <luqui> yeah.  I don't recall the argument

[14:55] <Mahmoud> any reason?

[14:55] <luqui> yeah, he had some reasons, and they weren't that bad

[14:55] <Mahmoud> i read something like 'c guys don't use it so much so why would perl guys use it?'

[14:56] <luqui> you could write to [email@hidden.address] and ask

[14:56] <Mahmoud> i'm afraid from perl six... it may kill the language and no one write on it

[14:56] <luqui> yeah, that's a common fear

[14:56] <Mahmoud> just like why people use ASP, because it's easy and lots of programmers know it

[14:57] <luqui> but perl is losing ground as it is to python, ruby, and php

[14:57] <luqui> people don't seem to have a problem learning new languages

[14:57] <Mahmoud> losing ground? explain?

[14:57] <luqui> a lot of perl programmers are using those languages instead because they're better at certain things

[14:58] <luqui> python looks cleaner to many people, ruby is better at OO, and php is better for quick web stuff

[14:58] <Mahmoud> php is faster than perl with mod_perl?

[14:58] <luqui> you know, that ends up not mattering very much

[14:59] <luqui> well, faster for the programmer

[14:59] <luqui> not necessarily for the web server

[14:59] <Mahmoud> coding in php is faster?

[14:59] <luqui> uh huh

[14:59] <luqui> coding web sites, that is

[14:59] <Mahmoud> because of embeding php in the html you mean?

[14:59] <luqui> yeah.  it has a high "whipupitude"

[15:00] <azuroth> heheh.

[15:00] <Mahmoud> it think it makes it faster for the server side too.. no?

[15:00] <luqui> with perl you have to put something in cgi-bin, know about modules, etc.

[15:00] <luqui> Mahmoud, whatever

[15:00] <luqui> maybe, maybe not

[15:00] <Mahmoud> the server doesn't send any thing to mod_php unless it sees <?

[15:00] <luqui> that's not what's important to people, even though they think it is

[15:01] <luqui> php is certainly not faster than Mason

[15:01] <Mahmoud> i use mod_perl by extention

[15:01] <luqui> but Mason is a bitch to use, so people use php instead

[15:01] <azuroth> mason?

[15:01] <Mahmoud> < files *.pl> directive in my httpd.conf for perl-script

[15:01] <luqui> azuroth, it's a Perl 5 web templating module

[15:01] <azuroth> ahh

[15:01] <Mahmoud> i hate the idea of embeding perl/php/xxx with html.. better to use template engines

[15:02] <luqui> yeah, experienced programmers think that way

[15:02] <Mahmoud> thanks :P

[15:02] <luqui> but there are many unexperienced programmers for whom templating engines are crap

[15:02] <luqui> and it's easier to embed code in html

[15:02] <Mahmoud> for quick and dirty tasks it's better to not use template

[15:03] <Mahmoud> saving time

[15:03] <Mahmoud> i think we were talking about perl six

[15:03] <luqui> ah yes

[15:03] <luqui> well, that's why we want to make perl 6

[15:04] <Mahmoud> ?eval print "foo";

[15:04] <evalbot_8414> OUTPUT[foo] bool::true 

[15:04] <Mahmoud> OMG..

[15:04] <Mahmoud> shoult it be capital OUTPUT?

[15:04] <luqui> that's just the evalbot

[15:04] <luqui> if you did it on the console, it would be what you expect

[15:04] <Mahmoud> i thought evalbot is a perl five to perl six convertor

[15:04] <luqui> oh, no

[15:04] <audreyt> that would be nice

[15:04] <luqui> it's a perl 6 evaluator

[15:04] <Mahmoud> heh..

[15:04] <audreyt> but no it is not

[15:05] <Mahmoud> how would i say print "foo"; in perl six?

[15:05] <luqui> print "foo"

[15:05] <audreyt> you say

[15:05] <integral> ?eval say "foo"

[15:05] <evalbot_8414> OUTPUT[foo ] bool::true 

[15:05] <audreyt> print "foo"

[15:05] <Mahmoud> no ;? 

[15:05] <audreyt> well, if you like semicolon, you can add that

[15:05] <audreyt> just like in perl 5.

[15:05] <luqui> they're optional on the last statement, just like in perl 5

[15:05] <luqui> I'm hearing an echo

[15:05] <luqui> except it's coming before me

[15:05] <Mahmoud> how does perl divide statements if no ;s are used?

[15:05] <audreyt> it's an ohce

[15:06] <luqui> semicolons are used!  They're just optional on the last statement of a group

[15:06] <luqui> ?eval say "foo"; say "bar"; say "baz"

[15:06] <evalbot_8414> OUTPUT[foo bar baz ] bool::true 

[15:06] <Mahmoud> it is optional in some cases with perl five too

[15:06] <azuroth> ?eval say "concat " ~ "strings";

[15:06] <evalbot_8414> OUTPUT[concat strings ] bool::true 

[15:07] <azuroth> ?eval say "concat " . "split"("");

[15:07] <evalbot_8414> Error:  unexpected "." expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:07] <azuroth> ?eval say "concat " . split("");

[15:07] <evalbot_8414> Error:  unexpected "." expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:07] <Mahmoud> wtf? 

[15:07] <audreyt> ?eval "concat".split;

[15:07] <evalbot_8414> ("concat",) 

[15:07] <luqui> we changed string concat from . to ~

[15:07] <audreyt> ?eval "concat".split('');

[15:07] <luqui> so that we could have . for method call

[15:07] <evalbot_8414> ("c", "o", "n", "c", "a", "t") 

[15:07] <Mahmoud> heh why?

[15:07] <azuroth> ?eval say "concat " .split("");

[15:08] <evalbot_8414> OUTPUT[concat  ] bool::true 

[15:08] <azuroth> ?eval "concat " .split("");

[15:08] <Mahmoud> so . is for only method call?

[15:08] <evalbot_8414> ("c", "o", "n", "c", "a", "t", " ") 

[15:08] <azuroth> ?eval "concat " ."split"("");

[15:08] <evalbot_8414> Error:  unexpected "." expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:08] <luqui> Mahmoud, yes

[15:08] <luqui> azuroth, what are you trying to do?

[15:08] <Mahmoud> nice..

[15:09] <azuroth> I dunno. can you do sort of method pointers?

[15:09] <azuroth> ?eval $a = &String::split; "blah".$a(""); # kind of like this maybe?

[15:09] <evalbot_8414> Error:  unexpected "." expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:09] <luqui> yeah, but they're harder in perl 6 (you have to really shout at perl to say I'M USING A SYMBOLIC LOOKUP)

[15:09] <luqui> but I don't think it's implemented in pugs yet

[15:10] <azuroth> ahh

[15:10] <audreyt> mm? pugs does do symbolic lookup.

[15:10] <luqui> ?eval my $a = "say";  "foo".::($a)()

[15:10] <evalbot_8414> Error:  unexpected "." expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:10] <luqui> then is my syntax wrong

[15:10] <audreyt> ?eval my $x = 1; $::('x')

[15:10] <evalbot_8414> \1 

[15:10] <luqui> audreyt, how do you do it for methods?

[15:11] <azuroth> ?eval ("a", "b", "c").join(" ")

[15:11] <evalbot_8414> "a b c" 

[15:11] <audreyt> luqui: I'm sorry but, I don't think that is in the spec.

[15:11] <azuroth> ?eval ("a", "b", "c")>>.~(" test")

[15:11] <evalbot_8414> Error:  unexpected ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:11] <luqui> audreyt, oh.  let me look.  I'm pretty sure that's the way it's done.

[15:11] <luqui> so the spec may need to be updated ;-)

[15:12] <audreyt> yes, please do.

[15:12] <azuroth> ?eval ("a b c", "b c d", "c d e")>>.split(" ")

[15:12] <evalbot_8414> Error:  unexpected ">" expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:12] <azuroth> ?eval ("a b c", "b c d", "c d e") >>.split(" ")

[15:12] <evalbot_8414> Error:  unexpected ">" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[15:12] <azuroth> hmm. is that not how you do hyper-method, or is it not implemented?

[15:12] <audreyt> azuroth: yeah, unidirectional hyper is not yet parsed.

[15:12] <audreyt> we currenly only do bidirectional ones.

[15:12] <audreyt> luqui: have you seen my OpTable.hs?

[15:13] <azuroth> aww. that's still cool :-D

[15:13] <audreyt> ?eval (1, 2, 3) >>+<< 4

[15:13] <evalbot_8414> (5, 6, 7) 

[15:13] <luqui> audreyt, well, it was in A12, but there's nothing in the synopses

[15:13] <audreyt> luqui: A12 is not normative so I pretend it does not exist :)

[15:13] * luqui thinks that's a good plan

[15:13] <audreyt> please do a carry over

[15:13] <luqui> audreyt, I did look at OpTable.hs

[15:14] <luqui> but not very much

[15:14] <luqui> I'm pretty much done with the basic combinators

[15:14] <audreyt> k. I think mostly you just need the data structures

[15:14] <audreyt> spent quite some time getting them concise enough

[15:14] <audreyt> the parse algorithm itself can be implemented in every which way.

[15:14] <luqui> sure

[15:15] <luqui> Larry says "OP parsing is not quite so simple as bubble sort, but not quite so subtle as quicksort"

[15:15] <luqui> and I don't think quicksort is subtle

[15:15] <luqui> so... should be fine

[15:15] <audreyt> heh

[15:15] <audreyt> it's definitely more complicated than quicksort

[15:16] <audreyt> because we allow dynamic alternation of optable

[15:16] * luqui doesn't see how that makes anything more complicated

[15:16] <audreyt> (which PGE::OpTable doesn't yet do, so I'd have to invent my own callback system)

[15:16] <audreyt> luqui: some terms may be functions that alters the table itself

[15:16] <audreyt> so when you parsed the first half of circumfix

[15:17] <audreyt> it may introduce something that clashes with the closing half

[15:17] <luqui> but that's okay, you'll get the clash when you get there

[15:17] <azuroth> ?eval sub postfix:<!> (Num $a) { if $a == 1 return 1; return $a * ($a - 1)!;} say 10!;

[15:17] <evalbot_8414> Error:  unexpected "i" expecting ";", statements or "}" conditional missing body or reserved word 

[15:17] <luqui> but I guess I won't really understand until I try to do it

[15:18] <luqui> azuroth, I don't think postfix works

[15:19] <audreyt> $x[ BEGIN{our &prefix:<]> := ...} ];

[15:19] <audreyt> ?eval sub postfix:<!> ($x) {[*]1..$x}; 10!

[15:19] <evalbot_8414> 3628800 

[15:19] <audreyt> it does work.

[15:19] <audreyt> it's the "if" syntax

[15:19] <luqui> oh right

[15:19] <azuroth> ohh yeah. :-p

[15:20] <luqui> I just remember playing with postfix and being frustrated

[15:20] <azuroth> ?eval sub postfix:<!> (Num $a) { if $a == 1 { return 1; } return $a * ($a - 1)!;} say 10!;

[15:20] <evalbot_8414> Error:  unexpected "}" expecting term postfix, operator, ">>xx<<", ">>+&<<", ">>+<<<", ">>+><<", ">>~&<<", ">>~<<<", ">>~><<", ">>*<<", ">>/<<", ">>%<<", ">>x<<", "\187xx\171", "\187+&\171", "\187+<\171", "\187+>\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187*\171", "\187/\171", "\187%\171", "\187x\171", "xx", "+&", "+<", "+>", "~&", "~<", "~>", "*", "/", "%", "x", ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[15:20] <luqui> heh, I find myself writing this in Perl a lot:

[15:20] <luqui> if $foo {

[15:20] <luqui>     then bar

[15:20] <luqui> oh crap

[15:20] <luqui> it's perlskell

[15:20] <azuroth> ?eval sub postfix:<!> (Num $a) { if ($a == 1) { return 1; } return $a * ($a - 1)!;} say 10!;

[15:20] <evalbot_8414> Error:  unexpected "}" expecting term postfix, operator, ">>xx<<", ">>+&<<", ">>+<<<", ">>+><<", ">>~&<<", ">>~<<<", ">>~><<", ">>*<<", ">>/<<", ">>%<<", ">>x<<", "\187xx\171", "\187+&\171", "\187+<\171", "\187+>\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187*\171", "\187/\171", "\187%\171", "\187x\171", "xx", "+&", "+<", "+>", "~&", "~<", "~>", "*", "/", "%", "x", ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[15:20] <azuroth> ?eval sub postfix:<!> (Num $a) { if ($a == 1) { return 1; }; return $a * ($a - 1)!;} say 10!;

[15:20] <evalbot_8414> Error:  unexpected "}" expecting term postfix, operator, ">>xx<<", ">>+&<<", ">>+<<<", ">>+><<", ">>~&<<", ">>~<<<", ">>~><<", ">>*<<", ">>/<<", ">>%<<", ">>x<<", "\187xx\171", "\187+&\171", "\187+<\171", "\187+>\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187*\171", "\187/\171", "\187%\171", "\187x\171", "xx", "+&", "+<", "+>", "~&", "~<", "~>", "*", "/", "%", "x", ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[15:20] <azuroth> eek. time to give up

[15:21] <luqui> azuroth, it may be a problem with using ! inside your definition of !

[15:21] <luqui> I think that's a currently half-working feature

[15:21] <azuroth> ahh

[15:21] <audreyt> ?eval sub postfix:<!> (Num $a) { if ($a == 1) { return 1; } return $a * ($a - 1)!; }; 10!

[15:21] <evalbot_8414> Error:  unexpected " " expecting term postfix, operator, ">>xx<<", ">>+&<<", ">>+<<<", ">>+><<", ">>~&<<", ">>~<<<", ">>~><<", ">>*<<", ">>/<<", ">>%<<", ">>x<<", "\187xx\171", "\187+&\171", "\187+<\171", "\187+>\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187*\171", "\187/\171", "\187%\171", "\187x\171", "xx", "+&", "+<", "+>", "~&", "~<", "~>", "*", "/", "%", "x", ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or "}" 

[15:21] <audreyt> weird

[15:21] <luqui> (azuroth, though in perl 6 it is legal)

[15:21] <Mahmoud> looks like larry wall created a new hash algorithm

[15:21] <luqui> Mahmoud, ?

[15:22] <azuroth> ?eval [~]("a ", "b ", "c")

[15:22] <avar> ?eval <æ ð>

[15:22] <evalbot_8414> "a b c" 

[15:22] <evalbot_8414> ("\\", "\\") 

[15:22] <audreyt> ?eval sub postfix:<!> (Num $a) { if ($a == 1) { return 1; } return $a * &?SUB($a - 1); }; 10!

[15:22] <evalbot_8414> 3628800 

[15:22] <Mahmoud> i was away, and when I returned back to the irc window, i shocked with all the symbols on the screen 

[15:22] <luqui> haha

[15:22] <avar> $ pugs -e 'say <æ ð>.perl'

[15:22] <avar> ('Ã¦', 'Ã°')

[15:22] <luqui> yeah, azuroth has been making perl barf all over the screen

[15:22] <azuroth> ^_^;

[15:22] <Mahmoud> heh

[15:22] <avar> $ pugs -e 'say for <æ ð>'

[15:22] <avar> æ

[15:22] <avar> ð

[15:22] <avar> why does this happen

[15:22] <Mahmoud> i was googling for 'mod_perl vs mod_php' .. i hope i'm not trolling

[15:23] <luqui> avar, it's probably something with the IRC interface

[15:23] <avar> pugs normally prints out multibyte characters properly but the .perl method doesn't

[15:23] <luqui> oh

[15:23] <avar> luqui: that's on my local machine...

[15:23] <luqui> yeah, I just figured that out ;-)

[15:23] <Mahmoud> any benchmark you guys know about mod_php vr mod_perl?

[15:23] <avar> ;))

[15:23] <luqui> avar, good question.

[15:23] * luqui experiments

[15:24] <avar> looks like I need to write another t/pugsbugs/file ;)

[15:24] <luqui> avar, works for me

[15:24] <audreyt> please do :)

[15:24] <luqui> something with your config maybe

[15:24] <Mahmoud> i'm afraid that i wasted my time with Perl :D

[15:24] <Mahmoud> devorce time.. 

[15:24] <Mahmoud> :P

[15:24] <luqui> Mahmoud, huh?  Why?  Why? Don't leave!!

[15:24] <luqui> :-)

[15:24] <Mahmoud> no sorry.. i'll leave..

[15:25] <avar> luqui: what locale are you using?

[15:25] <avar> luqui: I have en_US.utf8, maybe that's it..

[15:25] <luqui> en_US.utf8

[15:25] <avar> mm

[15:25] * Mahmoud rides his horse and leaves

[15:25] <luqui> avar, oh, by the way

[15:26] <luqui> your example above, where you quoted $ pugs -e 'say for <...>'  # I can't type those characters

[15:26] <luqui> looked completely fine to me

[15:26] <luqui> the output was precisely those two characters

[15:26] <Mahmoud> luqui, don't worry.. i'll not leave.. i'm staying with you.. don't be afraid

[15:26] <avar> luqui: it looks fine here too, what doesn't look fine is say <æ ð>.perl

[15:26] <luqui> oh

[15:26] * luqui looks

[15:27] <avar> $ perl -Mutf8 -e 'print ord for split //, "say <æ ð>.perl"; print "\n"'

[15:27] <avar> 115971213260230322406246112101114108

[15:27] <avar> just to make sure we're  giving it the same input;)

[15:27] <luqui> ("\d[230]", "\d[240]")

[15:28] <luqui> yep, it's the same

[15:28] <luqui> that line is what I get

[15:28] <avar> $ pugs -e 'say "æ".perl; say "æ"'

[15:28] <avar> 'Ã¦'

[15:28] <avar> æ

[15:28] <avar> simplified testcase

[15:29] <avar> do those two come out the same for you?

[15:29] <luqui> avar, try putting some input in a file

[15:29] <luqui> "\d[230]"

[15:29] <luqui> æ

[15:29] <luqui> that's what I get

[15:29] <avar> $ pugs say.p6 

[15:29] <avar> 'Ã¦'

[15:29] <avar> æ

[15:29] <avar> $ cat say.p6 

[15:29] <avar> say "æ".perl;

[15:29] <avar> say "æ";

[15:29] <avar> same stuff

[15:29] <avar> $ file say.p6 

[15:29] <avar> say.p6: UTF-8 Unicode text

[15:29] <luqui> avar, what terminal are you using?

[15:30] <luqui> well, your term is probably fine

[15:30] <luqui> given that you can cat correctly

[15:30] <avar> I'm sure my terminal is fine with regards to spitting out UTF-8, I work on UTF-8 all day;)

[15:30] <avar> xterm with -en utf8 and LC_ALL=en_US.utf8 

[15:30] <avar> (the LC_ALL is important)

[15:30] <avar> -en UTF-8 actually..

[15:31] <luqui> avar, that's very strange then

[15:31] <luqui> avar, and this is the latest svn?

[15:31] <avar> nah, 6.2.10

[15:31] <luqui> oh, that could be it

[15:31] <avar> I should compile the latest maybe;)

[15:31] <luqui> I put in a patch a month ago or some that dealt with this sort of thing

[15:32] <luqui> s/some/so/

[15:33] <avar> I'll make a testcase for it regardless, just to make sure there aren't any regressions

[15:33] <luqui> thanks

[15:34] <luqui> oh, avar 

[15:34] <luqui> you probably can't commit

[15:34] <luqui> openfoundry is being a bastard

[15:34] <luqui> what kind of business isn't open on christmas eve!  Geez!

[15:35] <avar> christmas day;)

[15:35] <luqui> christmas day?  You're saying you're 16 hours away from me?

[15:35] <avar> I'm saying that CD isn't the 25th everywhere in the world;)

[15:35] * luqui doesn't know much about timezones, but he didn't think that that was possible

[15:35] <luqui> oh

[15:35] <luqui> oh, I get it

[15:36] <avar> It's the 24th here

[15:36] <luqui> that's cool

[15:36] <luqui> where are you?

[15:36] <avar> Iceland

[15:36] <luqui> interesting

[15:36] <avar> It's like that in .dk too

[15:36] <avar> and probably .no,, .sv

[15:36] <avar> although I'm not sure

[15:38] <avar> mm

[15:38] <avar> the perl6.vim file needs fixing

[15:38] <avar> It doesn't autodetect perl6 for some reason

[15:38] <avar> plus it defaults to that awful coding style *ducks*

[15:39] <luqui> perl6.vim isn't the thing that autodetects

[15:40] <luqui> you need a filetype detector, and I'm pretty sure there isn't one in the pugs repo

[15:40] <avar> mm

[15:40] <avar> the std vim syntax files do that somehow

[15:40] <avar> I think

[15:40] <luqui> yeah

[15:40] <luqui> .vim/filetype.vim is where you put custom ones

[15:40] <luqui> vim has a global filetype.vim that it uses

[15:40] <Mahmoud> going to cut my beard heh :P

[15:41] <Mahmoud> 1+ cm long

[15:41] *** Mahmoud is now known as Mahmoud-Afk

[15:42] <pasteling> "luqui" at 67.165.197.242 pasted "My .vim/filetype.vim" (19 lines, 655B) at http://sial.org/pbot/15110

[15:43] <avar> heh, .wiki ;)

[15:43] <avar> does that actually work for anything non-simple?

[15:43] <luqui> does what actually work?

[15:44] <avar> mediawiki syntax highlighting

[15:44] <avar> that file works a charm, thx;)

[15:44] <luqui> it seems to be pretty good

[15:44] <avar> mm

[15:44] * avar MW dev

[15:44] <avar> our syntax sucks;/

[15:44] <luqui> it doesn't make any sense if you dont have those filetypes in your ftplugin

[15:44] <luqui> of course

[15:45] <luqui> by which i mean in your syntax/

[15:45] <avar> hah

[15:45] <avar> It's kind of like php

[15:45] <avar> it wasnt designed, it kind of just grew like cancer

[15:45] <luqui> you guys should abruptly change to kwid

[15:45] *** Mahmoud-Afk is now known as Mahmoud

[15:45] <avar> what's that?

[15:46] <luqui> kwid is a wiki syntax designed by ingy

[15:46] * luqui likes it a lot

[15:46] <Mahmoud> heh.. php is cancer LOL

[15:46] <avar> well, actually the main problem with it is not the syntax itself, but the parser we're using

[15:46] <luqui> avar, really?

[15:46] <avar> it doesn't use a parse tree because php would be too slow for that, it's just a regexp hack

[15:46] <luqui> yuck

[15:46] <luqui> like Pod::Parser

[15:47] <luqui> yeah, I always thought that MW was a fairly nice piece of software

[15:47] <luqui> I wanted to submit a patch, and found that it was only nice on the outside

[15:47] <luqui> with a heart black as coal

[15:48] <avar> It's very different,

[15:48] <avar> that parts I write are nice & clean;)

[15:48] *** Mahmoud is now known as Mahmoud-Afk

[15:48] <luqui> of course.  all those other parts are hard to understand ;-)

[15:48] <avar> since I'm pretty fanatical about cleanness...;)

[15:49] <avar> I guess it suffers from pretty much the same problem as most php apps

[15:49] <avar> 1. written as a hack

[15:49] <avar> 2. still a hack

[15:49] * luqui is being a good boy at the moment and documenting his code

[15:49] <avar> 3. hard to extend hack

[15:49] <luqui> php makes it hard to exercise good software engineering practices

[15:50] <luqui> whereas perl makes it easy to do so... (but perl also makes it easy to write complete crap)

[15:50] <avar> php5 is slightly better

[15:50] <luqui> (which java claims it makes hard to do)

[15:50] <avar> you can't make private members for classes in php4 for example, which is .. insane

[15:50] <luqui> (but I claim that it's impossible for any language to do that)

[15:51] <luqui> (except Haskell.  it's very hard to write crap in haskell, because it's hard to write anything in haskell)

[15:51] <avar> hahah

[15:51] <luqui> (if you don't really think through the problem, Haskell's vagueness-killer will get you)

[15:51] <luqui> (end of long parenthetical)

[15:51] <luqui> (really)

[15:52] <avar> Working on MW is kind of fun because you get to please the crowd, few FS projects are like that, I guess;)

[15:52] <luqui> what is that acronym FS?

[15:52] <avar> free software

[15:52] <luqui> oh, of course

[15:53] <luqui> well, you get to do that to a certain crowd in Perl

[15:53] <luqui> except that is a crowd that seems not capable of being pleased

[15:53] <avar> ;)

[15:53] <luqui> avar, spent any time on p6l?

[15:54] <avar> perl6-language?

[15:54] <luqui> yeah

[15:54] <avar> I subscribe to it since ~1wk ago, haven't posted anything

[15:54] <luqui> ahh

[15:54] <luqui> so you missed the "self", um, "debate"

[15:55] <luqui> that's good

[15:55] <avar> self.* ?

[15:55] <luqui> coming up with *optional* syntax to call methods on self

[15:55] <luqui> even the people who said they would never ever use it fought against it

[15:56] <luqui> and then when we said "okay, there's no syntax"

[15:56] <luqui> everybody said "no, there needs to be a syntax"

[15:56] <luqui> which is much more like "it needs to be *my* syntax"

[15:56] <avar> you mean something like $this-> and this. in php, ruby & C# ?

[15:56] <luqui> yeah

[15:56] <luqui> the one I liked best was ./method

[15:57] <luqui> oh, and in C# at least, can you just say method() as shorthand for self.method() ?

[15:58] * luqui hasn't done much C#

[15:58] <Khisanth> not really like $this-> and this. ... since that would just be $self.

[15:58] <Khisanth> or whatever depending on you prototype and pragmas? :)

[15:59] <luqui> use Perl6::Attributes;  ./method(...)  :-)

[15:59] <avar> I like self.method

[15:59] <Khisanth> that is irrelevant for that particular thread :P

[16:00] <luqui> yeah

[16:00] <luqui> so Larry made a decision that pleased nobody at all

[16:00] <luqui> and then later he quietly changed it to something else

[16:00] <luqui> without telling anyone about it

[16:00] <luqui> "if you have an objection to it, you'll have to read the spec to find out what you're objecting to first!"

[16:01] <Khisanth> our $Larry is sneaky;

[16:01] <luqui> and all the whiners are too lazy to read the spec

[16:01] <Khisanth> perl6 is just a plot to make writing poetry easier!

[16:02] * luqui doesn't get it

[16:02] * luqui knows about perl poetry

[16:02] * luqui still doesn't get it

[16:02] <Khisanth> I mean it adds a lot more usable vocabulary

[16:04] <luqui> oh, you were referring to "our $Larry is sneaky;".  Now I get it.  

[16:04] <luqui> is, but, does, when, ...

[16:06] <Khisanth> lazy :)

[16:17] <audreyt> whew. 4 journal entries today.

[16:17] <audreyt> I think I deserve sleep :)

[16:18] * luqui should read those

[16:18] * luqui thinks it's funny that you can write pages of code and still need more

[16:18] <luqui> but write 4 journal entries and be wasted

[16:19] * luqui works the same way, though

[16:19] <audreyt> I think English is a really sloppy programming language.

[16:20] <audreyt> but maybe that's a virtue :)

[16:20] <gaal> either that, or humans are a hell of a complex platform.

[16:20] <luqui> Well, you think that, until you meet an expert English programmer.

[16:20] <audreyt> it's probably both :)

[16:20] <avar> audreyt: mm, url yo journal?;)

[16:20] <avar> *to

[16:20] <audreyt> avar: see topic

[16:20] <audreyt> (pugs.blogs.com)

[16:21] <audreyt> ingy: see you in RL tomorrow :)

[16:21] * audreyt waves &

[16:21] <gaal> bye audreyt :)

[16:26] <avar> I wonder if there are any rss viewser (preferrably for firefox) that don't suckl

[16:27] <avar> I'm using gmail's ATM

[16:31] <luqui> openfoundry is back

[16:32] <clkao> zzz

[16:32] <svnbot6> r8415 | luqui++ | Fixed interpretation of curlies to make a hash.  The following:

[16:32] <svnbot6> r8415 | luqui++ |     { %foo }

[16:32] <svnbot6> r8415 | luqui++ |     { %$foo }

[16:32] <svnbot6> r8415 | luqui++ |     { %foo, a => 1, b => 2 }

[16:32] <svnbot6> r8415 | luqui++ | are now interpreted correctly.

[16:32] <svnbot6> r8416 | luqui++ | Backtracking controls.

[16:32] <svnbot6> r8417 | luqui++ | Change "cut"'s name to "commit", even though what I'm doing is a little more general than commit.

[16:32] <svnbot6> r8418 | luqui++ | A little documentation.

[16:33] <rafl_> Who wrote the smoke/yaml_harness stuff?

[16:33] * luqui dunnos

[16:34] <clkao> iblech?

[16:38] <rafl_> He only wrote the smokeserv, afaik.

[16:40] <audreyt> yaml harness is nothingmuch and gaal's doing I believe

[16:44] <svnbot6> r8419 | luqui++ | A little bit more documentation, for the slightly tricky quantify combinator.

[16:46] <gaal> rafl_: yup, I wrote the initial version based on Straps and nothingmuch did most of the refactoring into the TAP modules.

[16:53] <svnbot6> r8420 | luqui++ | Minimal quantifiers.

[16:53] <svnbot6> r8421 | luqui++ | Making sure that quantifiers are maximal by default.

[17:08] <Khisanth> rafl_: couldn't you ask the svn server? :)

[17:10] <slavik> so, when is perl6 supposed to be released?

[17:14] <Khisanth> EOT

[17:22] <integral> Christmas! :-P

[17:29] <Khisanth> tomorrow?!

[18:12] <slavik> sweet :P

[18:54] <avar> my 1st post to perl6-language;)

[18:58] <luqui> except you're wrong :-)

[18:59] <luqui> no, not really.  but you could have been a little more right

[19:00] <luqui> @Larry (or, more specifically, @Larry - lwall - luqui) think that there should be an "official" implementation

[19:00] <luqui> which is written in PIR (ugh) and runs on Parrot

[19:01] <luqui> and all other implementations try as hard as they can to conform to that one

[19:01] <luqui> but I'm ashamed of that position, so I didn't want to reply...

[19:02] <avar> @Larry?

[19:02] <luqui> design team

[19:02] <avar> ah

[19:02] <luqui> clever pun...

[19:02] <avar> explain;)

[19:02] <luqui> the array of Larrys

[19:02] <luqui> anyway...

[19:03] <luqui> oh, cool name, by the way

[19:03] <luqui> er, cool looking.  I have no idea what it sounds like.

[19:03] <avar> ;)

[19:03] <avar> I have an ogg vorbis of the pronounciation somewhere...

[19:06] <avar> so what *is* the status with regards to specs?

[19:06] <svnbot6> r8422 | luqui++ | Optional, and some untested anchors.

[19:06] <luqui> well, the reason there are specs is because larry didn't want to program

[19:06] <avar> hah

[19:06] <luqui> (he did this for the sake of the code... or so he says)

[19:07] <luqui> Larry creates little languages wherever he goes, so it's often hard for people to grok his code without immersing themselves in it

[19:07] <luqui> there are a couple more reasons that it's good that larry doesn't program

[19:08] <luqui> for instance, when you're writing the language, it's easy to specify the behavior that's easiest to implement

[19:08] <luqui> rather than easiest to use

[19:09] <avar> Of course there are downsides to that as well, you're likelier to specify things that might conflict if you're not implemnting it too

[19:10] <luqui> that's actually not true...

[19:10] <luqui> we get plenty of conflicts in pugs

[19:10] <luqui> and nobody realizes them for a long time

[19:10] <luqui> until somebody says "hey, this doesn't seem like what it's supposed to do"

[19:11] <luqui> There is one downside that I see

[19:11] <luqui> and it's the same as the upside

[19:11] <luqui> I have a strong belief that what's easiest to implement is often the right thing to do

[19:11] <luqui> (as long as there is a solid design)

[19:12] <luqui> so you don't get some of those wacky over-dwimmy situations that we've seen throughout the design process

[19:12] <luqui> (all of which eventually get boiled down into something consistent and predictable, thankfully)

[19:40] <avar> an assembly language would be easiest to implement;)

[19:41] *** DesreveR is now known as r0nny

[19:58] <SamB> the trouble with DWIM is that it is overly hand-wavey; sometimes you still haven't figured out what you mean yourself, how can you expect the computer to do it?

[20:04] <buu> SamB: If you haven't figured out what you want, why are you typing code? 

[20:23] <Mahmoud-Afk> hi buu :)

[20:23] *** Mahmoud-Afk is now known as Mahmoud

[20:24] <Mahmoud> IRC Rule #586: Bosses never replay 'Hi's. :/

[20:25] <Mahmoud> reply*

[20:25] <buu> ZOMG.

[20:26] <Mahmoud> looks like calture difference.. here it's very rude to not reply 'hi','salam' or any welcome message.

[20:26] <Mahmoud> here means UAE

[20:27] <tewk> ls

[20:28] <obra> Mahmoud: around here, it's not particularly rude. With the number of folks coming and going, that would be..a lot of traffic

[20:28] <obra> But welcome :)

[20:28] <Mahmoud> I see..

[20:28] <Mahmoud> reasonable :)

[20:28] <Mahmoud> practical people ;)

[20:29] <obra> That is the perl thing, yes ;)

[20:37] <azuroth> good morning

[20:57] <dduncan> mawnin

[20:58] <dduncan> foundry's up, so will push momentarily

[20:58] <azuroth> hey hey

[20:58] <dduncan> and the same person who was here just before I left, and had the f trouble

[21:00] <dduncan> done; now the p6 and p5 repos are in sync

[21:00] <svnbot6> r8423 | Darren_Duncan++ |  r1562@Darren-Duncans-Computer:  darrenduncan | 2005-12-24 01:04:36 -0800

[21:00] <svnbot6> r8423 | Darren_Duncan++ |  /ext/Rosetta-Incubator : major update to lib/SQL/Routine.pm; for the Document and Node classes both, added full attr decls in code and docs, added full BUILD submethod, and export_as_hash() method, to code and docs

[21:42] <dduncan> ?eval my %h = { 4 => 5 }; my $bar = { %foo }; $bar;

[21:43] *** evalbot_8414 is now known as evalbot_8423

[21:43] <evalbot_8423> Error: Undeclared variable: "%foo" 

[21:43] <dduncan> ?eval my %foo = { 4 => 5 }; my $bar = { %foo }; $bar;

[21:43] <evalbot_8423> {("4" => 5),} 

[22:02] <Juerd> dduncan: Don't assign a *reference* to a hash.

[22:02] <luqui> that actually seems to be a bug

[22:02] <luqui> his code shouldn't work, but it did.

[22:02] <dduncan> oh

[22:03] <Juerd> { } returns a reference. Hash assignment works with lists.

[22:03] <dduncan> I have had issues with related matters for awhile

[22:03] <luqui> ?eval my %a = { a => 1, b => 2 };  say %a<b>

[22:03] <evalbot_8423> OUTPUT[2 ] bool::true 

[22:03] <luqui> yep, wrong

[22:03] <Juerd> ?eval my @foo = [ 1 ];

[22:03] <evalbot_8423> [[1,],] 

[22:03] <luqui> I fixed it for lists, though

[22:03] <Juerd> That works better.

[22:03] <Juerd> luqui: Arrays :)

[22:03] <dduncan> so is %hash = $hashref wrong then?

[22:03] <luqui> it didn't before yesterday

[22:04] <luqui> Juerd, :-)  stupid words.  why couldn't they be more like numbers?

[22:04] <dduncan> there was a checkin about this yesterday

[22:04] <Juerd> dduncan: Not if %hash is declared to have non-string keys.

[22:04] <Juerd> %hash = $hashref just means %hash = ($hashref => undef)

[22:04] <luqui> with a warning

[22:04] <dduncan> so what is the proper way to copy a hash

[22:04] <Juerd> Yeah, odd number blah blah :)

[22:05] <Juerd> dduncan: my %hash2 = %hash1.copy;

[22:05] <luqui> dduncan, you copied the hash correctly

[22:05] <Juerd> Alterantively, just: 

[22:05] <Juerd> my %hash2 = %hash1;

[22:05] <dduncan> so that works then

[22:05] <Juerd> Sure.

[22:05] <dduncan> and %!hash2 = %hash1 works

[22:05] <Juerd> %hash1 is in list contex

[22:05] <dduncan> and $foo!hash2 = %hash1 works?

[22:05] <Juerd> What's %foo?

[22:05] <Juerd> eh

[22:06] <Juerd> What's %!foo?

[22:06] <luqui> private member

[22:06] <Juerd> Oh my, when did that happen?

[22:06] <luqui> dduncan, the latter is doing something quite different

[22:06] <luqui> because %hash1 in that case is in *scalar* context

[22:06] <Juerd> Does %foo in list context eval to .kv or to .pairs?

[22:06] <luqui> .pairs

[22:06] <Juerd> Great :)

[22:06] <dduncan> my last 2 lines were both referring to object attributes that were hashes

[22:07] <Juerd> No more while-each. I hate while-each.

[22:07] <dduncan> but one specified the object name

[22:07] <luqui> dduncan, it's all about the sigil

[22:07] <luqui> if you write it with a %, then it's a hash

[22:07] <luqui> otherwise it's a hash reference

[22:07] <Juerd> I tend to write short subs, and to return as early as possible. while-each sucks so much that I'm accustomed to for (keys %foo) { $foo{$_} )

[22:07] <dduncan> so if $obj is an object ...

[22:07] <luqui> Juerd, me too

[22:07] <Juerd> Which is ugly, but at least works.

[22:08] <dduncan> what is the syntax to set its %!hash attr?

[22:08] <Juerd> I don't get why people love iterators. They SUCK :)

[22:08] <Juerd> Lists rock, iterators suck.

[22:08] <luqui> $obj!hash = {...}   # note the curlies

[22:08] <Juerd> And we don't need iterators now that we have lazy lists. Hurrah!

[22:08] <luqui> that is, you assign it a reference

[22:08] <dduncan> okay

[22:09] * luqui doesn't mind iterators

[22:09] <dduncan> so with %!foo I assign as a %hash, and with $obj!foo I assign as a $hashref?

[22:09] * luqui hates implicit iterators

[22:09] <luqui> yep

[22:09] <dduncan> okay ...

[22:09] <Juerd> luqui: Okay, that works for me :)

[22:09] <dduncan> I have committed code that isn't sure how to do it ... will fix

[22:09] <dduncan> one more thing ...

[22:09] <Juerd> I've abused scalar glob yesterday, though ;)

[22:09] <dduncan> the syntax to generate one hash ref that is a copy of another hash ref?

[22:10] <dduncan> is it {*%{$hashref}} ?

[22:10] <luqui> Juerd, isn't the fact that you're using it in the first place a good indicator that you're abusing it :-)

[22:10] <luqui> dduncan, unfortunately, that doesn't work

[22:10] <Juerd> luqui: If there's no ? or * in there, yea :)

[22:10] <luqui> { %$hashref } will work fine

[22:11] <dduncan> and { %{$hashref} } too I assume?

[22:11] <luqui> also in perl 6 (but not necessarily in pugs), $hashref.copy

[22:11] <Juerd> glob "{a,b,c,...,z}{0,1,2,...,9}{0...9}{0...9}", but in full, can be SO useful :)

[22:11] <luqui> ah, that glob

[22:11] * dduncan called away ... back in 15m or so

[22:12] <Juerd> my @ids = lazy_ids();  shift @ids;

[22:12] <Juerd> Lalala :)

[22:12] <luqui> yes, but there really needs to be a more general mechanism

[22:12] <luqui> list comprehension

[22:12] <Juerd> Agreed

[22:12] <Juerd> Though syntax is hard.

[22:12] <dduncan> I was using the '*' there to mean splatty, or something

[22:13] <luqui> yeah, that's the biggest problem

[22:13] <luqui> everything's already taken

[22:13] <Juerd> For more advanced stuff like list comprehension, I'd think WORDS as opposed to SYMBOLS, would help a lot.

[22:13] <luqui> dduncan, yeah, but if there's anything besides a hash or a pair in curlies, it's taken to be a coderef, not a hash

[22:13] <dduncan> say if you want to populate a sub's arg list from a %hash

[22:13] <luqui> that's the problem with the *

[22:13] <luqui> Juerd, you might be onto something there

[22:13] <Juerd> Because symbols are taken, but also because much of the Perl target audience (sysadmins, one time scripters) doesn't regularly use these techniques.

[22:13] <luqui> "where", the best word, is already taken though

[22:13] <dduncan> back in a few mins

[22:14] <Juerd> luqui: "where" isn't clear anyway

[22:14] <luqui> true

[22:14] <luqui> any suggestions?

[22:14] <Juerd> It may read naturally, but it communicates very little semantic information

[22:14] <Juerd> luqui: This is a good moment to admit I don't really know what list comprehension consists of :)

[22:15] <luqui> it's just a notation that mixes multiple maps and greps together

[22:15] <luqui> for example:

[22:15] <luqui> (in haskell, but I'll keep it simple)

[22:15] <luqui> [ x + y | x <- [1..10], y <- [1..10], x > y ]

[22:16] <luqui> [3,4,5,5,6,7,6,7,8,...

[22:16] <luqui> (had to go to ghci to figure out what that would actually output)

[22:17] <Juerd> Oh, right, audrey showed me in the very first days of pugs. Now I remember.

[22:18] <luqui> map { f($_) } @list  <==>  [ f(x) | x <- @list ]    # Haskerl

[22:18] <Juerd> Well, remember... Not really, but I do recognise the example. 

[22:18] <Juerd> Eh, s/example/syntax/

[22:18] <Juerd> haskerl; heh

[22:18] <luqui> grep { f($_) } @list   <==> [ x | x <- @list, f(x) ]

[22:18] <luqui> and it's all just generalizations from there

[22:19] <luqui> [ expression | x <- sourcelist1, y <- sourcelist2, ..., condition1, condition2, ... ]

[22:19] <Juerd> Right

[22:19] <Juerd> And why not using foreach?

[22:20] <luqui> you mean:  for @sourcelist1 -> $x { for @sourcelist2 -> $y { push @result, expression($x,$y) if condition1 && condition2 } }

[22:20] <luqui> that's why

[22:20] <Juerd> my @res = for @foo -> $foo, @bar -> $bar { next unless condition; ...; f($foo + $bar); }

[22:21] <Juerd> What exactly is why? Notation?

[22:21] <luqui> we could let for return the list of its results instead of the last thing evaluated

[22:21] <luqui> and then that might work

[22:21] <Juerd> Otherwise, simply:

[22:21] <luqui> the main reason for mine was that it's imperative

[22:21] <luqui> but for can't do that yet

[22:21] <Juerd> my @res = gather { for { for { take ... if ... } } };

[22:22] <Juerd> Larry doesn't want if and for to return things. I want them to. :(

[22:22] <Juerd> ??:: should simply desugar to if/else

[22:22] <luqui> Juerd, you can

[22:22] <Juerd> But so far, it's just in my head.

[22:22] <luqui> ?eval my $x = do if 1 { 4 } else { 5 };  $x

[22:22] <evalbot_8423> \4 

[22:22] <Juerd> I see.

[22:22] <Juerd> I don't think I understand "do" there.

[22:22] <luqui> you can "do" that with any statement-level construct

[22:23] <luqui> it just turns statementy things into expressiony things

[22:23] <Juerd> Why is the word needed?

[22:23] <Juerd> We have context!

[22:23] <dduncan> question, if the sigl's the thing ...

[22:23] <luqui> because there's a syntactic difference

[22:23] <Juerd> void context: statement, other context: expression.

[22:23] <Juerd> What difference?

[22:23] <dduncan> say we have @list_of_obj ...

[22:23] <luqui> first, semicolons

[22:23] <Juerd> Semicolons were fixed with the whitespace hack

[22:23] <luqui> only sortof

[22:23] <dduncan> how do we set a hash attribute of one array element that is an object?

[22:23] <luqui> anyway, Larry thinks it's important to have a difference between statements and expressions

[22:24] <Juerd> I know he does :(

[22:24] <dduncan> eg, @list_of_obj[0].hash = ?

[22:24] <dduncan> or also

[22:24] <Juerd> dduncan: Have you ever used Perl 5?

[22:24] <dduncan> yes

[22:24] <dduncan> but there we have $ all the time

[22:24] <Juerd> Because in the current state of Perl 6, it may not be wise to use it to learn Perl.

[22:25] <luqui> Juerd, braces.  if if $foo { } else { } { } else { }

[22:25] <dduncan> Juerd, ...

[22:25] <luqui> or rather

[22:25] <luqui> if if $foo { } else { }

[22:25] <dduncan> I am very experienced with perl 5, but for some strange-seeming aspects

[22:25] <Juerd> dduncan: % is for hashes, @ is for arrays, $ is for scalars (including references)

[22:25] <dduncan> and I'm also trying to write correct code in perl 6

[22:25] <Juerd> dduncan: This does not change.

[22:25] <Juerd> dduncan: Even if the hash is used for a slice or a single element, it's still %.

[22:25] <luqui> dduncan, okay, it's not all about the sigil there...

[22:26] <Juerd> However, if you have a reference, even if it points to the same hash, it's $.

[22:26] <dduncan> so I'm learning perl 6

[22:26] <luqui> it's more like, it's all about the variable

[22:26] <luqui> or something

[22:26] <luqui> um... @foo and %foo expand themselves in list context

[22:26] <luqui> that's the only thing that distinguishes them from scalars

[22:27] <Juerd> luqui: But the braces thing is the same thing that happens with any bracketed construct: if it becomes complex, more parens are needed. We have precedence for paren-thingies, but more importantly: warnings. Nesting curly-thingies could simply be made impossible without parens.

[22:27] * dduncan back in a bit

[22:27] <luqui> "it's all about the sigil" was an overgeneralization

[22:27] <Juerd> if (if $foo { } else { }) { ... } else { ... }

[22:27] <luqui> no, the second one

[22:27] <Juerd> With "if if" being a parse error

[22:27] <luqui> why is if if a parse error?

[22:27] <luqui> Juerd, do you know about parsers?

[22:28] <Juerd> Because it uses to statement: things without encountering parens :)

[22:28] <luqui> so when can you use a statementy thing?

[22:28] <Juerd> statement:* would then be allowed only on statement level, and within parens.

[22:28] <luqui> so only after parens?

[22:28] <luqui> then you can't say:  my $x = if 1 { }

[22:28] <luqui> you'd have to say:  my $x = (if 1 { })

[22:29] <luqui> which is kinda what we did with do, except do looks nicer

[22:29] <Juerd> I don't know much about parsers. I do believe that parsing should be the last, not first, thing to consider when inventing syntax.

[22:29] <luqui> yes, but thinking about how the parser does it is kinda like Haskell in that it defoggies your thinking

[22:29] <Juerd> I see your point re my parens suggestion.

[22:30] <Juerd> But I don't get why do-if would be possible while if would not.

[22:30] <luqui> Chomsky believed that human languages were context-free.  So if a parser can't do it, then humans can't easily do it.  But Chomsky was full ot it anyway. ;-)

[22:30] <Juerd> The first thing I'd be tempted to do is write an error handler automatically inserting "do" whenever parsing an "if" failse... 

[22:31] <Juerd> s/failse/fails/

[22:31] <luqui> well...

[22:31] <luqui> then you wouldn't get missing semicolon errors

[22:31] <luqui> and we experienced programmers never get those anyway

[22:31] <luqui> but noobs get them all the time

[22:31] <Juerd> If you say so :)

[22:31] <luqui> do you understand why you wouldn't get missing semicolon errors?

[22:32] <Juerd> Javascript fixes the missing-semicolon thing the same way I'd fix the do-if thing: insert them automatically whenever parsing differently didn't work :)

[22:32] <luqui> sub foo { }   my $x = foo \n if condition {...} else {...}

[22:32] <Juerd> (Well, almost)

[22:32] <luqui> except my example is a genuine error, and it parses fine

[22:33] <luqui> foo will be getting a weird argument, though

[22:33] <Juerd> But without the else { }, that's already not a trappable error.

[22:33] <luqui> Juerd, how so?

[22:33] <Juerd> my $x = foo if condition({ ... })

[22:34] <luqui> but that's been specified

[22:34] <luqui> when you see a block in operator position, it's the statement-level block

[22:34] *** Mahmoud is now known as Mahmoud-Afk

[22:34] <Juerd> But back to list comprehension. I've read some more, and now understand it's not magic, but actually quite simple :)

[22:34] <luqui> yep

[22:35] <Juerd> One thing I don't understand yet. Are the input lists walked in parallel?

[22:35] <Juerd> Or do you get @x*@y iterations in total?

[22:35] <luqui> no.  they're done glob-style

[22:35] <luqui> yes @x*@y

[22:35] <Juerd> ok

[22:35] <luqui> in Haskell, they're last-first

[22:36] <luqui> (which makes the most sense to me, but could be argued either way)

[22:36] <Juerd> comprehend @foo; @bar -> $foo, $bar { next unless $cond1 and $cond2 and $cond3; f($foo + $bar); }

[22:37] <Juerd> Which can be written in a minute or two?

[22:37] <Juerd> Or am I not understanding it correctly yet?

[22:37] <luqui> Juerd, that's what I was thinking

[22:37] <Juerd> That I'm not understanding it yet?

[22:37] <luqui> no, the comprehend syntax

[22:38] <luqui> the thing I like about list comprehension syntax from haskell and python is that it reads just like "set-comprehension" in maths

[22:38] <luqui> in fact, it *is* that syntax :-)

[22:38] <Juerd> I think the easy solution is to make for (be able to) return lists, even if it's only with do.

[22:39] <Juerd> You can always introduce macros for the nice syntax later.

[22:39] <luqui> basically making for a statement-level map with reversed arguments

[22:39] * luqui could live with that

[22:39] <Juerd> What would we still need map for?

[22:40] <Juerd> Isn't map just list-returning for? :)

[22:40] <luqui> reversed arguments.  reads better sometimes.  also, statement-level.

[22:40] <Juerd> And can't one already do for { ... } <== @foo, if they really want arguments to be reversed?

[22:40] <luqui> but statement-level isn't going to sell *you* :-)

[22:40] <Juerd> No, statement level does nothing to me. Everything's an expression, and I'm happy. :)

[22:41] <Juerd> sub foo { ... } should just return \&foo.

[22:41] <luqui> Juerd, you should take up haskell

[22:41] <luqui> let x = if 1 then 4 else 5

[22:41] <Juerd> I know.

[22:41] <Juerd> If only I had a big bag of tuits

[22:41] <luqui> yeah.  It took me until we were driving out to Portland to get tuits

[22:41] <avar> x = 1 ? 4 : 5;

[22:41] <avar> ;)

[22:42] <luqui> yeah, but Juerd is objecting to the fact that there are things that aren't expressions

[22:42] <luqui> oh, avar, and you mean $x = 1 ?? 4 !! 5;

[22:42] <Juerd> I've began programming again, partly ignoring pain (CTS-like, but not CTS), because I'm a little more than out of cash.

[22:42] <avar> luqui: that was C

[22:42] <luqui> uh huh

[22:42] <Juerd> avar: I thought it was Perl.

[22:42] <luqui> but this is #perl6

[22:42] * luqui notices that that's perfectly good perl

[22:43] <Juerd> { my $x; sub x : lvalue { $x } } x = 1 ? 4 : 5;

[22:43] <Juerd> Heck, who needs sigils anyway.

[22:43] <avar> are subroutines expressions or declerations in p6?

[22:43] <luqui> I believe there was a module that gets rid of sigils precisely by doing that

[22:43] <luqui> avar, if they have a name, then they are declarations

[22:44] <luqui> if not, then they are expressions

[22:44] <avar> mm

[22:44] <Juerd> luqui: Getting rid of sigils (optionally!!) is one of the ideas in Perlego.

[22:44] <avar> too bad, 

[22:44] <luqui> avar, por que?

[22:44] <Juerd> Perlego is my reference Perl 6

[22:44] <avar> I kind of like def x(y) puts y; end if 2 in ruby;) 

[22:44] <luqui> avar, you mean you like how it looks, or you like the ability to do that?

[22:45] <Juerd> my foo = 3;  # from now on, we know what "foo" is, but we can use $foo too, if we want.

[22:45] <avar> how it looks, I know I can do it just by wrapping stuff in another block or something..

[22:45] <luqui> (to me, that looks like the "end" is under control of the "if", but nothing else)

[22:45] <Juerd> It solves 50% of the line noise issue :)

[22:45] <luqui> Juerd, should be pretty easy with a grammar munge

[22:45] <Juerd> luqui: I thought so :)

[22:45] <luqui> Juerd, might even be pretty easy with a source filter

[22:46] <luqui> you should write it in perl 5

[22:46] <Juerd> But I keep striving to get things like that into standard Perl.

[22:46] <luqui> yeah, but remember who I am...

[22:46] <luqui> I'm that guy who hates when people talk about standard perl...

[22:46] <Juerd> I think that configurability is GREAT, but that the default should be sane.

[22:47] <Juerd> And that syntax is one of the few things that needs specal sanity.

[22:47] <Juerd> special

[22:47] * luqui too.  he personally doesn't think that my foo = 3;  is all that sane

[22:47] <avar> mm, no sigil?

[22:48] <Juerd> Well, that's okay. You're far from alone in thinking that, which just means that my idea wasn't a good one in the first place.

[22:48] <Juerd> Which in turn means that I can save a lot of time writing a module that does it too.

[22:48] <luqui> :-)

[22:49] <Juerd> There are only two things left in my wishlists that I find really important. For the other things, I've been convinced that my ideas aren't sound, or they are already standard Perl 6.

[22:49] <avar> what does my x = 5; do ?;)

[22:49] <Juerd> The two things left are <-> and parenless method calls.

[22:49] <luqui> avar, nothing.

[22:49] <luqui> Juerd, wants it to do the obvious thing.

[22:49] <luqui> s/,//

[22:49] <Juerd> avar: Nothing, but in the hypothetical Perlego, it'd declare $x and a sigilless alias for it, called x.

[22:50] <luqui> Juerd, you do know that we have listop method call

[22:50] <avar> eh, what's the point?

[22:50] <luqui> ?eval "foo bar".substr: 1, 3

[22:50] <evalbot_8423> \"oo " 

[22:50] <Juerd> luqui: That's nice, but substr as a listop?!

[22:50] * luqui thinks he agrees with Juerd about <->

[22:51] <avar> what would <-> do?

[22:51] <luqui> The : turns any method call into a listop

[22:51] <Juerd> I see.

[22:51] <Juerd> I can very well live with that I think :)

[22:51] <Juerd> Although.

[22:51] <luqui> avar, <-> is like ->, but it declares its arguments rw

[22:51] <Juerd> Does it imply list context too? That would be unfun :(

[22:52] <luqui> Juerd, well, I think "turns into a listop" they meant "parses like a listop"

[22:52] <luqui> Context is callee-side now anyway

[22:52] <luqui> so it definitely doens't imply list context

[22:52] <Juerd> Oh, that's interesting. How does that work?

[22:52] <luqui> Juerd, it kinda doesn't

[22:52] <luqui> that's one of the big gaping holes in the design

[22:52] <Juerd> An @foo is flattened on the callee side?

[22:53] <Juerd> (when in slurp context)

[22:53] <luqui> if foo is a multi:  foo(bar());

[22:53] <luqui> we can't know what context to call bar() in until we know which foo() to call

[22:53] <avar> luqui: isn't there an existing syn for that?

[22:53] <luqui> but we can't know that until we call bar()

[22:53] <Juerd> Hehe

[22:53] <luqui> because it's a multi

[22:53] <Juerd> Hmmm

[22:53] <luqui> avar, existing syn for <-> ?

[22:54] <luqui> yes:  -> $x is rw, $y is rw { }

[22:54] <Juerd> I've always assumed the context would be a disjunction

[22:54] <avar> like for %hash.kv -> $k is rw, $v is rw { or somthing...

[22:54] <luqui> yeah, that's legal

[22:54] <luqui> it's just not as nice as <->

[22:54] <luqui> which is very mnemonic

[22:54] <avar> I like is rw better...;)

[22:54] <Juerd> multi foo (Foo $x) { ... }; multi foo (Bar $x) { ... }; foo(bar());  # bar is in Foo|Bar context

[22:54] <Juerd> And the foo is chosen according to what bar() actually returned.

[22:55] <luqui> Juerd, that's one way to do it

[22:55] <avar> or were you planning to munge "<->" into subroutine argument lists ?

[22:55] <avar> or would they be a special case?

[22:55] <luqui> Juerd, but if you're in Scalar|List context, what do you return?

[22:55] <luqui> avar, -> declares a sub as it is

[22:55] <luqui> ?eval (-> $x { $x + 1 }).(10)

[22:55] <evalbot_8423> 11 

[22:56] <Juerd> luqui: That's a context that doesn't exist in my head, for two reasons: 1. there are no List objects; 2. Main context type (item versus list) shouldn't be mixable across multis.

[22:56] <luqui> Juerd, the first one is just semantics.  The second one probably ends up being right

[22:56] <Juerd> List objects just don't work.

[22:56] <avar> luqui: ew;)

[22:56] <luqui> you don't use it unless it looks nice

[22:57] <luqui> that's how a lot of perl programming goes

[22:57] <luqui> you can abuse the syntax, but you can also use it to make things very readable

[22:57] <Juerd> And I still think we should rename "list context" 

[22:57] <luqui> Juerd, it is renamed

[22:57] <avar> I meant, if you want to replace for %hash.kv -> $k is rw, $v is rw { with for %hash.kv <-> $k, $v { what do you want to replace sub x(Num $x is rw) with?

[22:57] <luqui> it's "Slurpy" context

[22:57] <avar> nothing?

[22:57] <luqui> yes, nothing

[22:57] <Juerd> luqui: That's Pugs, not Perl 6.

[22:57] <avar> or sub x(Num <-> $x or something

[22:57] <luqui> Juerd, I believe it's perl 6, too

[22:58] <Juerd> luqui: A conscious stray from Larry's path.

[22:58] <luqui> avar, certainly not!

[22:58] <Juerd> No, Larry recently confirmed it's item versus list.

[22:58] <luqui> Juerd, really?

[22:58] <Juerd> Yes.

[22:58] <luqui> messageid?

[22:58] <Juerd> Hold on

[22:58] <avar> luqui: I don't like it, two totally different ways to declare something as rw?

[22:58] <Juerd> Mailbox is growing too large

[22:58] <Juerd> ...

[22:58] <luqui> avar, it's just sugar

[22:59] <dduncan> okay, I'm back ... will fix and checkin stuff now ...

[22:59] <luqui> look at it for for:

[22:59] <luqui> for @a <-> $x { $x++ }

[22:59] <luqui> @a goes into $x, then $x goes back into @a

[23:00] * leo is pondering if perl6 {is,will be} released today;)

[23:00] <Juerd> That Larry doesn't To: people makes finding answers to your own message hard.

[23:00] <Juerd> Normally I'd ~f larry ~t juerd ~b context

[23:00] <Juerd> (I've stopped To:'ing people myself too, though)

[23:00] <luqui> leo, yes

[23:00] <obra> leo: no ;)

[23:00] <luqui> hehe

[23:01] <avar> luqui: could I do for @a ⇔ $x { ++$x } ?;)

[23:01] <Juerd> luqui: Message-ID: [email@hidden.address]
[23:01] <Juerd> luqui: And thread

[23:01] <dduncan> I never To: people myself if they're on the mailing list

[23:01] <dduncan> when people do that to me, I get 2 copies

[23:02] <Juerd> dduncan: Which really is better.

[23:02] <Juerd> dduncan: But it does make finding replies harder.

[23:02] <dduncan> I just look at all the replies to threads I participate in

[23:02] <luqui> avar, you might have to declare that yourself

[23:02] <dduncan> particularly ones I start

[23:02] <Juerd> As searching has no threading functionality.

[23:02] <Juerd> dduncan: Yeah, but that isn't quite a viable alternative to searching archives

[23:03] <luqui> unless that symbol is latin-1, in which case we might (but probably won't) make it a synonym

[23:03] <Juerd> dduncan: Mind you, of the over 7500 p6l messages in this mailbox, I wrote over 600

[23:03] <dduncan> so I always To my list responses to the list itself and only that ... most of the time ...

[23:04] <dduncan> I only add a To for a specific person in rare chances I want it to stand out to them / have them see it sooner

[23:04] <luqui> Juerd, but brent has a good point

[23:04] <luqui> not a great point

[23:06] <luqui> dduncan, I wonder if that works

[23:07] <Juerd> luqui: It's a good point indeed.

[23:07] <dduncan> with some mailers, they format a message list so that direct mails stand out more than indirect mails

[23:07] <Juerd> luqui: But it's a definition without argumentation. *why* nouns? I agree that if any one is a noun, they should all be.

[23:07] <Juerd> But they can also all by adjective.

[23:08] <avar> ?eval "æ"

[23:08] <evalbot_8423> ***      unexpected "("     expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input     at -e line 15, column 6 

[23:08] <Juerd> In fact, since the main contexts both (excluding void) have the same tree of types underneath, adjective may make sense.

[23:08] <avar> ?eval say "æ"

[23:08] <evalbot_8423> ***      unexpected "("     expecting term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input     at -e line 15, column 6 

[23:08] <avar> ...

[23:08] <avar> ?eval 1+1

[23:08] <evalbot_8423> 2 

[23:08] <Juerd> "singular Dog context", "plural Dog context"

[23:08] <avar> ?eval "\303\246"

[23:08] <evalbot_8423> "\d[303]\d[246]" 

[23:08] <avar> odd

[23:09] <avar> ?eval "\303\246".perl

[23:09] <evalbot_8423> "\"\\d[303]\\d[246]\"" 

[23:09] <Juerd> avar: Please try such things with pugs directly. Use the evalbot if you want to show the channel something specific.

[23:10] <avar> Trying to figure out if there is something to show;)

[23:19] <Juerd> I just had a toilet revelation

[23:19] <Juerd> item context should be "one" context.

[23:19] <Juerd> With a low precedence "one" operator, and a high precedence "1" operator.

[23:19] <Juerd> "1", the number, differs from "1", the operator, in that it has 0 arguments.

[23:20] <Juerd> And 1foo is unambiguous because it's an invalid identifier anyway

[23:20] <Juerd>  

[23:20] <Juerd> Ignore all that :)

[23:20] <Juerd> Toilet revelations aren't the greatest anyway

[23:21] <Juerd> luqui: A bare closure should just start iterating if it gets any input lists.

[23:23] <Juerd> luqui: { @foo.push: $x + $y if condition and condition } <== @x, @y;

[23:23] <Juerd> Though where exactly $x and $y come from, I don't know ;)

[23:23] <nothingmuch> $^x and $^y ?

[23:23] <Juerd> Oh, of course, they're $^y and... what nm said :)

[23:24] <Juerd> Hm

[23:24] <nothingmuch> this concludes mmy helping pugs today ;-)

[23:24] <Juerd> comprehend { $^x + $^y } <== @x, @y, { condition }, { condition };

[23:24] <nothingmuch> now i'm off to sleep.... i'm frozen stiff from a walk in the rain

[23:24] <Juerd> nothingmuch: Awww

[23:24] <nothingmuch> it was voluntary

[23:24] <nothingmuch> i *like* the rain

[23:25] <nothingmuch> we get it very seldom

[23:25] <Juerd> nothingmuch: Still, I wish to you a warm evening

[23:25] <nothingmuch> thank you =)

[23:25] <Juerd> I absolutely hate rain.

[23:25] <Juerd> We have way too much of it.

[23:25] <nothingmuch> it's always like that =)

[23:25] <Juerd> It's unfortunate that weather can't be exported easily.

[23:25] <Juerd> Other natural resources, like gas and oil, can.

[23:26] <nothingmuch> if we had a lot of rain i wouldn't have liked it either ;-)

[23:26] <dduncan> ?eval sub bar () { my %foo = (4=>5); return { %foo }; } say bar();

[23:26] <evalbot_8423> OUTPUT[4	5  ] bool::true 

[23:26] <Juerd> No, but a healthy world market would balance things out a bit :)

[23:26] <nothingmuch> hehe

[23:26] <nothingmuch> then the US would try to attack seattle

[23:26] <Juerd> Haha

[23:26] <dduncan> ?eval sub bar () { my %foo = (4=>5); return { %foo }; } say bar().ref;

[23:26] <evalbot_8423> OUTPUT[Hash ] bool::true 

[23:27] <Juerd> dduncan: Do you have a local pugs installation?

[23:27] <Juerd> dduncan: Or access to feather?

[23:27] <dduncan> yes

[23:27] <dduncan> but in my situation, its treating the sub's return value as a block

[23:27] <Juerd> dduncan: Please use that. Or, if you were trying to make a point, don't forget the point itself.

[23:28] <Juerd> luqui: How about: comprehend { $^x + $^y } <== @x, @y, { condition }, { condition };

[23:29] <Juerd> Ehhh

[23:29] <Juerd> luqui: How about: comprehend { $^x + $^y } <== @x <== @y <== { condition }, { condition };

[23:30] <Juerd> luqui: It'd be nice if there was a way to carry lexicals out of a block.

[23:31] <Juerd> luqui: Because $^apple doesn't sort well with $^pear, if @pear was the first input list

[23:33] <Juerd> luqui: Or maybe this all just means we need postfix ->, then <-, as well.

[23:34] <Juerd> luqui: comprehend { $x + $y if condition } <- (@x; $y);

[23:35] <Juerd> luqui: Which for all I care, can just replace map. map { $x + $y if $x > 10 } $x, $y <- (@x; @y);

[23:35] <Juerd> luqui: Though I'd write it args-first: map (@x; @y) -> $x, $y { $x + $y if $x > 10 }

[23:35] <Juerd> I think that's nice enough syntax to work with :)

[23:41] <Juerd> Hm, no, map of course walks arrays in parallel

[23:41] <Juerd> comprehend then.

[23:42] <Juerd> It's a shame -> can't be placed in the middle of something.

[23:42] <Juerd> @foo -> $foo, @bar -> $bar feels more logical, syntax wise, than @foo; @bar -> $foo, $bar

[23:43] <dduncan> okay, here's a demo of the problem ...

[23:43] <dduncan> ?eval class M { has %!h; submethod BUILD () { %!h = (4=>5); } method geth () { return { %!h }; } } class T { method tra ($m) { .useh( $m.geth() ) } method useh (%h) { say "got {%h}"; } }; my $gm = M.new(); my $gt = T.new(); $gt.tra( $gm );

[23:43] <evalbot_8423> OUTPUT[got <SubBlock(<anon>)>	 ] bool::true 

[23:43] <dduncan> that's distilled from the actual failing code

[23:43] <dduncan> what I demo'd earlier, a simpler case of the same, does work

[23:44] <dduncan> so I'm trying to figure out what to fix in the newest example so that the copy of %!h gets to useh() intact

[23:44] <Juerd> Hmmm

[23:44] <dduncan> but somehow it becomes an anon block

[23:45] <Juerd> What if -> (and <-> of course) would just declare parameters for "the next bare block"

[23:46] <Juerd> And without statement control keyword, it'd just pre-alias

[23:46] <avar> $ ghc -v

[23:46] <avar> Glasgow Haskell Compiler, Version 6.4, for Haskell 98, compiled by GHC version 6.2.2

[23:46] <avar> \o/

[23:46] <avar> no more 5.* ;)

[23:47] <Juerd> $foo + $bar -> $x; $xyzzy * $quux -> $y; { $x + $y };

[23:48] <Juerd> There's VERY little point in that, though.

