[01:20] <mugwump> brentdax: utsl.gen.nz/pugs-svk-dump.bz2 will be ready shortly...

[01:20] <mugwump> brentdax: both PCRE and P6 Rule objects look like rules when you say them

[01:26] <brentdax> mugwump: PCRE is emitting errors when I try to run Perl 6 regexes.

[01:26] <mugwump> ah

[01:26] <mugwump> hmm, that dump file is 20MB

[01:26] <mugwump> still going, too.  almost ready.

[01:26] <brentdax> Alright.

[01:27] <brentdax> How do I use ti once I get it?

[01:27] <brentdax> *it

[01:30] <mugwump> ok, it's finished.  I would guess that piping through | bunzip2 | svnadmin load ~/.svk/local should do it

[01:30] <brentdax> Okay, thanks.

[02:27] <svnbot6> r6181 | fglock++ | * Migrated all containers, tests from ext/ to perl5/

[02:27] <svnbot6> r6181 | fglock++ |   (with help of a 5-line regex)

[02:28] <hobbs> (5-line regex)++

[02:50] <svnbot6> r6182 | iblech++ | * Usual svn props.

[02:50] <svnbot6> r6182 | iblech++ | * PIL2JS: More recovery after the CPS change.

[02:50] <svnbot6> r6182 | iblech++ |   * If you return a flattened array, its flatenessness is preserved now. This

[02:50] <svnbot6> r6182 | iblech++ |     re-enables &prefix:<*>. (Before the CPS change, it was not possible to

[02:50] <svnbot6> r6182 | iblech++ |     return flattened arrays, either, but I worked around that by using a hack.

[02:50] <svnbot6> r6182 | iblech++ |     It's solved correctly now.)

[02:50] <svnbot6> r6182 | iblech++ |   * Other things that work again: Prettyprinting of unhandled exceptions,

[02:50] <svnbot6> r6182 | iblech++ |     stringification of arrays with holes (e.g. arrays where .delete was used),

[02:50] <svnbot6> r6182 | iblech++ |     return(...) in subrefs.

[03:11] <dbrock> is svnbot6 tracking Pugs?

[03:12] <autrijus> dbrock: yes.

[03:19] <dudley> "we don't have to be strong typists to enjoy Strong Typing"

[03:19] <dudley> autrijus++

[03:20] <obra> heh

[03:25] <hobbs> groan-o-meter++

[03:39] * Aankhen`` groans.

[03:39] <Aankhen``> "Scotty, beam me up"?

[03:39] <Aankhen``> I dislike Star Trek, and that still jumped out at me.

[03:44] <Aankhen``> Oh well. TSa++ # obviously understands more than me :-)

[03:44] <svnbot6> r6183 | fglock++ | * fixed syntax errors in /perl5 containers

[05:01] <svnbot6> r6184 | Stevan++ | Perl6::MetaModel - removing the container types, fglock++ is doing a much better job :)

[05:24] <putter> brentdax: re PCRE errors with p6 regexp - do you have a test case?  (I ask hopefully:)   It is my current obstacle on improving pugs rule support.  But I've only seen it in mutant versions of pugs.  I'd love a replicable example on unmodified pugs...  Thanks! :)

[05:27] <brentdax> Let me see if I can get it to happen with a single module and a one-liner...

[05:27] <brentdax> (Unfortunately, it's not the best time--I'm packing for a trip to Europe.)

[05:30] <putter> ah, np.  whenever you get a chance.  I've backburnered it for now.

[05:30] <brentdax> Hmm, looks like I have an unhappy Parrot.

[05:30] <brentdax> Complaining about the fingerprint on PGE.pbc.

[05:31] <putter> mugwump: I snarfed a copy of your dump.  Thanks!  At some point I'll stop thinking "if only I had svk, I could have done x instead" and finally switch. ;)

[05:31] <autrijus> possibly you have different installed parrot and build path parrot.

[05:31] <autrijus> clean out one of those.

[05:33] <brentdax> I'm configured with Parrot embedding--do I have to rebuild Pugs after I rebuild Parrot?

[05:33] <autrijus> yes, this is exactly like modperl.

[05:33] <autrijus> (and for the same reason)

[05:34] <autrijus> (when you upgrade perl to a nonbincompat version, modperl may cease working)

[05:34] <brentdax> Okay...just `make`, or `make clean`?

[05:34] <autrijus> rm src/Pugs/Embed/Parrot*o then make

[05:34] <autrijus> or something like that.

[05:34] <putter> brentdax: but beware mission creep.  brief pause in packing to see if a test is easy, ++.  longer excursion into debug land when packing needs to be done, --.  number of human neurons devoted to mastercard commercial, easily 1e8+. ;)

[05:34] <autrijus> clean out the temp files.

[05:35] <brentdax> putter: Heh.

[05:35] <autrijus> putter++

[05:38] <brentdax> Hell, I'll just make clean and let pugs rebuild itself.  That'll give me packing time anyway.

[05:38] <putter> Yipes.  Ok, that was easy.  Just finished a fresh build of pugs on parrot 0.2.3.   Guess what 'a' ~~ /\N/ yields.  Thanks brentdax, looks like we have simple test case. :)

[05:39] <brentdax> Heh.  Any idea how far back I'll have to go to get a working build of Parrot?  As I mentioned, I'm packing to head to another country and such...

[05:39] <putter> checking my dog pile...

[05:42] <putter> Ok, r6108 works.  (and a _modified_ r6110 doesnt).

[05:43] <brentdax> Of Pugs?  Alright...

[05:45] <putter> Of pugs.  I'm afraid I'm not sure which parrot is embedded.  From the dates, it is almost certainly 0.2.3.

[05:46] * putter goes to see what r6109 and r6110 were...

[05:49] * putter discovers his patch broke regexps...

[05:53] <putter> brentdax: I'm sorry, my fault.  Would you benefit from a very fast 60 second fix to head, or shall I just fix it for real, which will take a bit more time?

[05:53] <putter> I apologize for the time it no doubt cost you. :-(

[05:54] <brentdax> It's alright--I've been busy with other stuff today anyway, it hasn't cost me much time.

[05:54] <brentdax> If a real fix is possible within a few hours, that'd be great.

[05:54] <putter> Ok.  In progress...

[06:03] <dduncan> putter, were you at OSCON this year?

[06:04] <dduncan> someone with a nick like that was there, but was a female; however, your comment said 'his'

[06:11] <dbrock> would it cause much trouble to allow $foo-bar.moomin-snufkin as a synonym for $foo_bar.moomin_snufkin?

[06:12] <putter> dduncan: nope...

[06:12] <brentdax> dbrock: Is that an identifier or a math equation?

[06:12] <coral> are you saying $foo - bar.moomin - snufkin?

[06:13] <dduncan> so what is the nick of Ingy's girlfriend?

[06:13] <obra> boojum

[06:13] <dbrock> I can see that $foo-$bar might be somewhat common, but $foo-bar?

[06:13] <dduncan> real name?

[06:13] <coral> death

[06:13] <brentdax> $foo-bar()?

[06:13] <coral> er, ww

[06:13] <dduncan> I could swear it sounded like an accented puuter

[06:14] <dduncan> maybe my memory's just bad

[06:16] <dbrock> brentdax: right... but do people write that?

[06:16] <dbrock> I guess they probably do, don't they

[06:17] <brentdax> $foo-bar = { foo; bar }; $foo-bar();

[06:18] <brentdax> Basically, once you do that, you start drifting into Heuristicland, which is a place language designers try to avoid.  It's the land of uncertain behavior, where the ground can shift under one function's feet because of an innocuous change 500 lines away.

[06:18] <dbrock> I'm proposing to unambiguously (i.e., non-heuristically) make $foo-bar always mean $foo_bar

[06:19] <brentdax> Or, less poetically: it's not *that* hard to hold the shift key.  :^P

[06:19] <coral> wouldn't the routine that changes - to _ internally when it's an identifier be a heuristic?

[06:19] <dbrock> s/(\w)-(\w)/\1_\2/g

[06:20] <coral> s/(?<=\w)-(?=\w)/_/

[06:20] <coral> anyways, i'm not being helpful and i'm not cheerleading

[06:20] <coral> so g'night #perl6 :)

[06:20] * coral zz

[06:21] <brentdax> module DBD::mysql-1.23-cpan:TIMB;

[06:28] <putter> good night coral.

[06:28] <svnbot6> r6185 | putter++ | r6109 introduced a bug in which p6 rules were also given to PCRE, the :perl5 rule handler, which sometimes threw an error.  Eg, 'a' ~~ /\N/ threw a 'PCRE does not support \N' error.   The bug is now gone.  But r6109's support for :global in PCRE rules is now commented out, as I failed to find a haskell phrasing to keep it in place.

[06:29] <dbrock> yeah yeah, but mine is just as short and easier to read, so there :-)

[06:29] <dbrock> brentdax: no, it's not *that* hard, but I also happen to prefer hyphens to underscores when reading the identifiers

[06:29] <dbrock> the typographical center of gravity of $foo-bar.baz-quux feels better than that of $foo_bar.baz_quux

[06:29] <dbrock> moreover, the method call periods stand out better in the hyphenated style

[06:29] <dbrock> brentdax: I'm not familiar with that syntax --- what does it mean?

[06:29] * dbrock is not a Perl hacker, but is in complete awe of Perl 6

[06:30] <putter> brentdax: r6185 removes the bug (at the cost of :global on pcre rules going back to being slightly incorrect).

[06:31] <dbrock> what does the `::to' mean in `multi sub *coerce:as (Us $us, Them ::to) { to.transmogrify($us) }'?

[06:33] <wolverian> it's a Type. (:: is the type sigil.)

[06:33] <dbrock> ah, okay

[06:35] <putter> Ok, r6185 tests look plausible.

[06:36] <putter> Good night folks. &

[06:36] <putter> Safe travels brentdax.

[06:37] <castaway_> sheep?

[06:44] <dbrock> assuming that `has Foo $foo = .new()' is sugar for `has Foo $foo = $foo.new()', is there any less redundant way to write `has Foo $foo = { Foo.new }'? --- i.e., I want a new Foo object to go with each new instance of the container

[06:45] <dbrock> uh, I mean `has Foo $foo .= new()', not `has Foo $foo = .new()'

[06:45] <dbrock> oh, and I mean $.foo instead of $foo :-)

[06:46] <jql> you can initialize has?

[06:47] <jql> oh, larry had an email about that today. never mind

[06:47] <dbrock> I'm reading A12, and am otherwise just another clueless fan

[06:47] <castaway_> (oops)

[06:47] *** castaway_ is now known as castaway

[06:48] <jql> it works. magically. don't mind me. :)

[06:49] <dbrock> okay, I'll try another question :-)

[06:50] <dbrock> what is the difference between $.foo and $:foo, apart from the fact that declaration of the former will automatically define accessor methods?

[06:51] <jql> public/private visibility

[06:51] <dbrock> I mean, why distinguish between public and private attributes, when the real difference is in whether or not accessor methods are defined?

[06:52] <jql> cause it's handy to have private member variables -- see various other languages we stole it from

[06:52] <dbrock> I might have gotten this wrong, but it appears $.foo attributes are in fact not visible directly from the outside

[06:52] <jql> indeed they aren't

[06:52] <dbrock> they have to go through a .foo method, correct?

[06:53] <jql> $obj.foo really calls the method on $foo, which supposedl;y returns $.foo

[06:53] <jql> err, on $obj, but you get the idea

[06:53] <dbrock> but that method could just as well return $:foo, couldn't it?

[06:53] <jql> indeed. or it could calculare sqrt(2) and return that

[06:54] <jql> the beauty of methods

[06:54] <dbrock> yeah, so again, what is the difference between $.foo and $:foo?

[06:54] <jql> $.foo is automatically (and obviously) accessable from outside

[06:54] <dbrock> can you say `has $.foo is private', or something to that effect?

[06:55] <jql> no

[06:55] <jql> but you can override the accessor method and make it ...

[06:55] <dbrock> okay, so that'd have to be `has $:foo is private' (which is redundant)

[06:56] <jql> quite redundant

[06:56] <jql> and it's the name itself that makes it private. method :foo is also private

[06:56] <dbrock> but if you declare $:foo and an accessor named .foo, isn't that effectively the same as declaring $.foo?

[06:57] <jql> yes, but subclasses can access $.foo directly, while they can't $:foo

[06:57] <dbrock> oh I get the distinction between public and private *methods*: public methods are visible from the outside, whereas private methods are only visible from within the class

[06:57] <dbrock> aah

[06:58] <dbrock> I hadn't considered subclasses

[06:58] <jql> in C++ parlance, only methods can be "public". $.foo is "protected", $:foo is "private"

[06:58] <dbrock> okay, I see.  It all makes sense now, thanks :-)

[06:58] <jql> :)

[07:00] <brentdax> Thank you putter.

[07:00] <brentdax> putter++

[07:20] <brentdax> (And yes, it does work with the fix.)

[07:41] * autrijus still at $work

[07:42] <autrijus> the spec just changed to be much scarier :-/

[07:42] <castaway> eep

[07:42] * autrijus ponders writing this one in ocaml

[08:29] <vkon> looking at 02 util/src_to_blib.pl 01 I see that copying of all *.hi and *.o files is intentional, but are those really needed? May be *.hs are enough??

[08:30] <integral> vkon: autrijus said yesterday that the .hi and .o files are needed for pugscc.   I think he means when compiling perl6 to haskell, you need the perl6 runtime available as a library

[08:31] <autrijus> right, that is so.

[08:32] <autrijus> it'd be cool if you can ar the .o into .a

[08:32] <autrijus> and install that only 

[08:32] * integral wishes ghc could manage to produce shared libs

[08:32] <autrijus> much as CORE/libperl.a does

[08:32] <autrijus> integral: it does

[08:32] <autrijus> at leats, cabal does

[08:32] <autrijus> but I had not digged into how

[08:32] <integral> ooh

[08:32] <autrijus> also .so only works on certain platforms

[08:32] <autrijus> but iirc .a works on all

[08:32] <autrijus> and we really only want .a

[08:33] <autrijus> there's no need to have pugs628.dll currently.

[08:34] <vkon> this means pugscc works well even on Windows? (unlike perlcc, which is troublesome?)

[08:34] <autrijus> vkon: it's supposed to, yes.

[08:34] <autrijus> but currently it gives

[08:34] <autrijus>     Overlapping instances for MonadSTM IO

[08:34] <autrijus>       arising from use of `liftSTM' at /home/autrijus/i/MainCC.hs:37:25-31

[08:34] <autrijus> it used to work in 6.2.8 (I think) though

[08:35] * brentdax watches the parrot dump load into svk (thanks, autrijus!).

[08:37] <autrijus> np, glad to be of help :)

[08:37] <nothingmuch> morning

[08:37] <autrijus> yo nothingmuch.

[08:38] <vkon> autrijus: then src_to_blib.pl should combine all *.o into *.a ... (but this looks like asking for problems?)

[08:43] <vkon> wow: pugscc -we "say[*]1..@*ARGS[0]"    and then a.exe is 7Mb executable doing its work!  way good.

[08:45] <autrijus> yeah and it would not need any runtime

[08:45] <autrijus> you can then copy it anywhere.

[08:45] <gaal> hello

[08:45] <autrijus> hey gaal.

[08:46] <vkon> autrijus: you will take a speech about pugs in Tallinn?? (sorry if this is FAQ:)

[08:46] <autrijus> vkon: sadly the haskell workshop rejected my paper

[08:47] <autrijus> so I'll speak about it in CUFP

[08:47] <autrijus> but CUFP is closed-door last I heard

[08:47] <gaal> i'll have to punt on the lexical pragma stuff, at least in the coming month

[08:47] <autrijus> gaal: *nod*

[08:47] <vkon> autrijus: sad indeed.... but why??

[08:47] <dbrock> what does say[*] mean?

[08:48] <autrijus> vkon: my english presentation is not good enough and that was my first academic paper :)

[08:48] <gaal> will be hiking in northern turkey

[08:48] <vkon> autrijus: you will take part as listener?

[08:48] <autrijus> dbrock: [*] is "product"

[08:48] <autrijus> vkon: yes

[08:48] <autrijus> dbrock: ([*] 1,2,3) means (1*2*3)

[08:48] <dbrock> oh

[08:48] <autrijus> the [] is the folding -- or reduction -- metaoperator

[08:48] <dbrock> wow, that's cool

[08:49] <gaal> was there a verdict on identity/empty list behavior for that, btw?

[08:49] <dbrock> this language is so awesome

[08:49] <autrijus> gaal: no.

[08:49] <autrijus> ?eval [*] ()

[08:49] <evalbot6> undef 

[08:49] <autrijus> fine with me.

[08:49] <gaal> ?eval [/] ()

[08:49] <evalbot6> undef 

[08:50] <autrijus> dbrock: even better is that it works on your user-defined infix too :)

[08:50] <dbrock> yeah, I figured as much :-)

[08:50] <autrijus> ?eval [||] 0,0,0,3,2,1,0,0,0,3,2,1

[08:50] <evalbot6> 3 

[08:50] <autrijus> (first-true)

[08:50] <gaal> ?eval [//] (undefined, undefined, undefined, 7, 55)

[08:50] <vkon> autrijus: however that paper is very interesting to read anyways

[08:50] <autrijus> ?eval [and] 1,2,3,0

[08:50] <evalbot6> Error: No compatible subroutine found: "&undefined" 

[08:50] <evalbot6> 0 

[08:50] <gaal> errrr

[08:50] <autrijus> vkon: thank-you :)

[08:51] <gaal> ?eval [//] (undef, undef, undef, 7, 55)

[08:51] <integral> ?eval [//] (undef, undef, undef, 7, 55)

[08:51] <evalbot6> 7 

[08:51] <autrijus> gaal: haskell-brained :)

[08:51] <wolverian> I finally streamlined my *cough* working *cough* and created a personal feed aggregator. yay!

[08:51] <autrijus> wolverian: nice!

[08:51] <gaal> autrijus, :)

[08:52] <dbrock> are there ternary infix operators?

[08:52] <gaal> ?eval bool::true ?? "moose" :: "elk"

[08:52] <evalbot6> 'moose' 

[08:52] <clkao> mugwump_, if you let others use your dump, be sure to ask people to use --ignore-uuid when loading it

[08:52] <gaal> dbrock, is that whay you mean?

[08:52] <dbrock> I want to define the ... if ... else ... operator

[08:52] <gaal> ?? :: then.

[08:53] <autrijus> dbrock: yes, supposedly it's

[08:53] <vkon> ?eval "test;".say

[08:53] <evalbot6> test; bool::true 

[08:53] <autrijus> &ternery:< ?? :: >

[08:53] <autrijus> or something resembling that

[08:53] <autrijus> but pugs does not support it yet.

[08:53] <Aankhen``> &ternary:<?? ::> perhaps?

[08:53] <autrijus> yeah

[08:53] <dbrock> gaal: no, I want `a if b else c' to mean `b ?? a :: c'

[08:53] <Aankhen``> One sec.

[08:53] <gaal> ahhh

[08:53] <wolverian> that looks pythonic, somehow.

[08:54] <wolverian> hack in list comprehensions, too, will you :)

[08:54] <dbrock> autrijus: maybe it could just be &infix:<?? ::>?

[08:54] <gaal> don't say that when autrijus is listenting, wolverian :)

[08:54] <autrijus> dbrock: right, maybe that.

[08:54] <autrijus> gaal: I did a fake list comprehension the day that userdefined infix was available

[08:54] <autrijus> :)

[08:54] <wolverian> yeah, I remember that. :)

[08:54] <gaal> heh heh heh :)

[08:55] <dbrock> what did it look like?

[08:55] <autrijus> something silly. I no longer remember

[08:55] <wolverian> but I don't like the 'action for items if condition' syntax. the for and if are reversed.

[08:55] <wolverian> and I know it's cultural and resembles math notation but I still hate it.

[08:55] <dbrock> by the way, would it even be possible to define an operator named `if'-something?

[08:56] <Aankhen``> Doesn't seem to be any `ternary:` category.

[08:56] <wolverian> autrijus, { x | x <- a..b } I think. I don't think it had a condition.

[08:56] <wolverian> but I don't remember that well.

[08:56] <dbrock> wolverian: yeah, I too have always thought Python has that backwards

[08:57] <gaal> eval("[ x | x <- xs, x `mod` 2 ]" :lang<haskell>)

[08:57] <wolverian> oh, and I also hate putting options at the end of the arg list

[08:57] <Aankhen``> gaal: You missed a comma. :-P

[08:57] <gaal> hmm, there's an 'even' function in haskell's prelude

[08:57] <gaal> oops, right

[08:57] <scook0> is there a spec around for how type-variables (my Foo ::x) work?

[08:58] <wolverian> there's a reason why Larry moved the m// flags to the front!!!

[08:58] <gaal> i am a generator function yielding errrors :(

[08:58] <scook0> or is it just something floating around the p6l ether?

[08:58] <Aankhen``> gaal: Nah, just occasional typos. :-)

[08:58] <dbrock> so wouldn't eval:lang<haskell> "..." be possible?

[08:59] <wolverian> now that's how I like my options!

[08:59] <wolverian> dbrock++

[08:59] <dbrock> why is it not allowed?

[08:59] <Aankhen``> dbrock: You would have to specifically name the "..." parameter.

[08:59] <integral> can't you do: eval:lang<haskell> <=== "..." ?

[09:00] <wolverian> I guess it's because normal arguments can be passed in as named, too? 

[09:00] <gaal> eval( :lang<haskell> code => $string) ?

[09:00] <Aankhen``> eval(:lang<haskell> :code<...>);

[09:00] <gaal> again missing a comma :)

[09:00] <Aankhen``> Or code => '...', whichever one.

[09:00] <dbrock> is Aankhen`` missing one too?

[09:00] <Aankhen``> No, commas are allowed to be omitted between pairs.

[09:00] <dbrock> oh, okay

[09:00] <Aankhen``> Atleast, when they're specified using that funky syntax.

[09:01] <gaal> which reminds me

[09:01] <dbrock> what about eval:lang<haskell>:code<...>?

[09:01] <dbrock> is that allowed?

[09:01] <gaal> in the interpreter, i typed :H by mistake once

[09:01] <wolverian> that should work, yes.

[09:01] <gaal> and of course got

[09:01] <gaal> ?eval :H

[09:01] <evalbot6> ('H' => 1) 

[09:01] <wolverian> gaal, that seems correct.

[09:01] <gaal> should we just for the sake of user friendliness make it an alias for :h ?

[09:01] <wolverian> but what I really want to write is: $obj.method:option(arguments)

[09:01] <Aankhen``> The reason why you can't put `:lang<haskell>` in front and '...' later without naming it is that in the signature of `eval`, the `lang` parameter is specified as a named parameter, whereas the `code` parameter is a positional parameter.

[09:01] <gaal> wolverian, sure

[09:02] <wolverian> gaal, oh, right, I didn't remember :h :)

[09:02] <wolverian> gaal, or maybe change the prefix from : to something else?

[09:02] <Aankhen``> Named parameters are optional.  I hope you do understand why required parameters always have to come before optional parameters. ;-)

[09:02] <dbrock> I actually don't :-)

[09:02] <Aankhen``> Hrm.

[09:03] <Aankhen``> Very simplified: sub foo ($foo, $bar, ?$baz, $quux) { ... } # this declares `baz` as an optional parameter, the rest as required

[09:03] <jql> can't do that

[09:03] <dbrock> oh, I get why that doesn't work

[09:03] <Aankhen``> jql: Shh.

[09:03] <jql> optional at the end

[09:03] <jql> :P

[09:03] * jql passes? :)

[09:03] <Aankhen``> That is what I'm trying to explain. :-)

[09:03] <dbrock> but make that sub foo ($foo, $bar, +$baz, $quux) { ... }

[09:03] <gaal> another interpreter question: is it correct for :e to reload an env (including prelude) every time?

[09:04] <Aankhen``> dbrock: `+$baz` declares the named parameter `$baz`.  Named is optional.

[09:04] <dbrock> why can't you call that as foo(1, 2, :baz, 3)?

[09:04] <jql> Aankhen``: actually, that was a better example. :)

[09:04] <wolverian> Aankhen``, ++$baz :)

[09:04] <dbrock> (yeah, I know the signature is invalid, but it doesn't matter)

[09:05] <dbrock> pairs are slippery in the sense that they don't easily bind to positional parameters, right?

[09:05] <Aankhen``> What do you mean?

[09:05] <wolverian> hmm. how do you pass in a pair as a positional?

[09:06] <jql> foo(my $var = :pair) ?

[09:06] <Aankhen``> wolverian: Not sure; maybe flatten it?

[09:06] <wolverian> sub foo ( $x ) { ... } foo :a; # $x == :a, or "no such argument"?

[09:06] <wolverian> jql, ewww.

[09:06] <jql> what? you no like?

[09:06] * jql chuckles

[09:06] <Aankhen``> In the case you gave, `foo` is being passed a single named argument (`a`) with a value of `1`.

[09:07] <Aankhen``> (which is, of course, incompatible with the signature)

[09:07] <jql> what's the perl6 magical noop? it's not + anymore

[09:07] <dbrock> I mean if you have sub foo($foo, ?$bar, +$baz) {...} and call foo(123, :baz), then $baz is 1 and $bar is undef

[09:07] <Aankhen``> dbrock: Yep.

[09:07] <dbrock> so why can't you stick named arguments in between positional parameters?

[09:07] <wolverian> Aankhen``, how do I put :a in $x then?

[09:07] <wolverian> Aankhen``, without calling it as foo x => :a

[09:08] <dbrock> it's not like they affect the positional parameters in any way

[09:08] <Aankhen``> wolverian: Er, I used "flatten" earlier... that was the opposite of what I meant.

[09:08] <Aankhen``> dbrock: They do, since they are optional arguments too.

[09:08] <wolverian> Aankhen``, foo \:a? :)

[09:08] <Aankhen``> You can't specify "positional, positional, optional, positional".

[09:09] <dbrock> wolverian: ISTR that happens if you declare ?$bar as a Pair

[09:09] <jql> dbrock: I think the @Larry agree with you in principle, but it's something which could be added later without breaking anything, so I think it's been punted

[09:09] <Aankhen``> In the same way, you can't specify "positional, positional, named, positional".

[09:09] <Aankhen``> ?eval sub foo (Pair $x) { $x.key }; foo(:a)

[09:09] <evalbot6> 'a' 

[09:09] <Aankhen``> ?eval sub foo (Pair $x) { $x.value }; foo(:a)

[09:09] <evalbot6> \1 

[09:09] <Aankhen``> dbrock++

[09:09] <wolverian> hmm. okay.

[09:09] <wolverian> I still want to write $foo.meth:option(args) :)

[09:10] <Aankhen``> wolverian: Wha?

[09:10] <dbrock> Aankhen``: but optional parameters in general (i.e., positional ones) affect positional ones; named parameters don't

[09:10] <wolverian> Aankhen``, isn't it logical? think m:2nd/.../ generalised to method/sub calls.

[09:10] <dbrock> hmm, that is one lousy formulation

[09:10] <wolverian> of course I guess it can't work, but one can always wish.

[09:10] <Aankhen``> dbrock: You're probably right, come to think of it.  Now I have no answer. :-P

[09:10] <scook0> wolverian: but that passes (args) to (option), not to (meth), doesn't it?

[09:11] <Aankhen``> wolverian: Sorry dude, you lost me there.

[09:11] <wolverian> scook0, yes. 

[09:11] <wolverian> that's obviously what I don't want. maybe force options to use <> instead of (), or something.

[09:11] <Aankhen``> (I am functioning on no sleep, so my ability to comprehend things is somewhat diminished)

[09:12] <wolverian> Aankhen``, hm. $file.write:chomped($lines)

[09:12] <Aankhen``> Ahh, you mean placing the modifiers at the beginning.

[09:12] <wolverian> I guess it's visually confusing if ($lines) were an arg to write instead of chomped there.

[09:12] <wolverian> Aankhen``, yes.

[09:12] <Aankhen``> (as opposed to the end)

[09:12] <scook0> would $file.write:chomped:($lines) be able to work?

[09:12] <wolverian> yes. 

[09:12] <scook0> I think that was one workaround that rules had

[09:12] <Aankhen``> I was looking at the behaviour, rather than the syntax.  My bad.

[09:13] <wolverian> scook0, no idea. 

[09:13] <Aankhen``> [14:41:35] <wolverian> that's obviously what I don't want. maybe force options to use <> instead of (), or something. # please don't take away my `:foo(0)`... :-(

[09:14] <wolverian> :!foo ;)

[09:14] <wolverian> (or !:foo, I guess.)

[09:14] <Aankhen``> You can have that for your subs. :-P

[09:14] <Aankhen``> Hmm, time to shower.

[09:14] <Aankhen``> BBIAB.

[09:15] <gaal> remind me, how do you use two* dimensional arrays in p6?   (* or n > 1)

[09:15] <gaal> this looks wrong: 

[09:16] <gaal> ?eval my @x; @x[5][5] = 5; @x.perl

[09:16] <evalbot6> '[undef, undef, undef, undef, undef, [undef, undef, undef, undef, undef, 5]]' 

[09:16] <jql> w t f?

[09:16] <jql> oh, nm. missed the inner []

[09:17] * jql is blind -- sorry

[09:17] <gaal> oh, maybe it isn't wrong? like p5 really

[09:17] <jql> it's p5 behavior

[09:17] <jql> allthough perl6 introduces @x[5;5]

[09:17] <scook0> gaal: the other elements haven't been autovivified yet

[09:17] <gaal> right right of course

[09:17] <jql> ?eval my @x; @x[5;5] = 10; @x.perl

[09:17] <evalbot6> Error:  unexpected "[" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[09:17] <jql> yeah, didn't think that worked yet

[09:17] <dbrock> ?eval my @foo is shape(3; 3) = [1,2,3; 4,5,6; 7,8,9]; @foo[1][1] = 0; @foo.perl

[09:17] <evalbot6> Error:  unexpected "[" expecting expression 

[09:18] <gaal> my brain needs resurrection

[09:18] <jql> magic semi doesn't do its thing yet

[09:18] <jql> there a test for it in pugs?

[09:18] <scook0> jql: was that just syntactic sugar, or is it distinct from nested arrays (can't remember...)

[09:18] <jql> it was syntactic sugar for anonymous array creation... then it got redefined

[09:19] <dbrock> oh

[09:19] <dbrock> ?eval my @foo is shape([3],[3]) = [[1,2,3],[4,5,6],[7,8,9]]; @foo[1][1] = 0; @foo.perl

[09:19] <evalbot6> '[((1, 2, 3), (4, 5, 6), (7, 8, 9)), [undef, 0]]' 

[09:19] <jql> (1, 2; 3, 4) used to mean [1, 2], [3, 4], which would've had special meaning for the postfix:<[]> op

[09:19] * dbrock actually doesn't have much of a clue :-)

[09:19] <jql> but now I dunno

[09:20] <dbrock> ?eval my @foo is shape([3],[3]) = [[1,2,3],[4,5,6],[7,8,9]]; @foo[[1][1]] = 0; @foo.perl

[09:20] <evalbot6> Error:  unexpected "[" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[09:20] <dbrock> ?eval my @foo is shape([3],[3]) = [[1,2,3],[4,5,6],[7,8,9]]; @foo[[1],[1]] = 0; @foo.perl

[09:20] <evalbot6> Error:  unexpected "[" expecting word character, "::", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[09:20] <jql> ?eval my @foo is bogus;

[09:20] <evalbot6> undef 

[09:20] <jql> yeah, didn't think do

[09:21] <dbrock> :-)

[09:21] <scook0> ?eval my @foo is totally_awesome

[09:21] <evalbot6> undef 

[09:21] <scook0> :)

[09:21] <dbrock> ?eval my @foo is shape([3],[3]) = [[1,2,3],[4,5,6],[7,8,9]]; @foo.perl

[09:21] <evalbot6> '[((1, 2, 3), (4, 5, 6), (7, 8, 9))]' 

[09:22] <jql> ?eval my $car is bitchin will kick :your<ass>

[09:22] <evalbot6> Error:  unexpected "w" expecting trait, "=", ".=", ":=", "::=", ";" or end of input 

[09:22] <dbrock> well that seems somewhat right anyway... right? :-)

[09:22] <jql> will requires a block, nm

[09:23] <dbrock> haha jql rules

[09:24] <QtPlatypus> ?eval my @foo is shape([3],[3]) = [[1,2,3],[4,5,6],[7,8,9,10]]; @foo.perl

[09:24] <evalbot6> '[((1, 2, 3), (4, 5, 6), (7, 8, 9, 10))]' 

[09:24] <dbrock> ?eval my @foo is shape([3],[3]) = [1,2,3],[4,5,6],[7,8,9]; @foo.perl

[09:24] <evalbot6> '[(1, 2, 3), (4, 5, 6), (7, 8, 9)]' 

[09:24] <dbrock> hmm, your example is interesting :-)

[09:24] <QtPlatypus> I guess array shaping isn't implemented yet.

[09:24] <dbrock> ?eval my @foo is shape([3],[3]) = [1,2,3],[4,5,6],[7,8,9,10]; @foo.perl

[09:24] <evalbot6> '[(1, 2, 3), (4, 5, 6), (7, 8, 9, 10)]' 

[09:25] <dbrock> I guess not

[09:25] <QtPlatypus> ?eval my @foo is shape(3) = (1,2,3,4); @foo.perl

[09:25] <evalbot6> '[1, 2, 3, 4]' 

[09:26] <QtPlatypus> ?eval my @foo is doc("My array for containing foo") = (1,2,3,4); @foo.perl

[09:26] <evalbot6> '[1, 2, 3, 4]' 

[09:26] <dbrock> ?eval my @foo is doc("My array for containing foo") = (1,2,3,4); @foo.doc

[09:26] <evalbot6> Error: No compatible subroutine found: "&doc" 

[09:27] <dbrock> ?eval my @foo is doc("My array for containing foo") = (1,2,3,4); @foo.meta.doc

[09:27] <evalbot6> Error: No compatible subroutine found: "&doc" 

[09:27] * dbrock is totally clueless :-)

[09:27] * QtPlatypus wonders what exactly the behavour of my example should be "Should the shaped array (1) Act in degraded mannor. (2) Throw an error. (3) Silently truncate the input"

[09:28] <QtPlatypus> Arguments can be made for all three.

[09:28] <dbrock> how do you get at the variable itself?

[09:28] <QtPlatypus> How do you get at the trait do you mean?

[09:28] <dbrock> ?eval my @foo is doc("My array for containing foo") = (1,2,3,4); \@foo.doc

[09:28] <evalbot6> Error: No compatible subroutine found: "&doc" 

[09:28] <dbrock> yeah

[09:29] * QtPlatypus doesn't know "I think there will be some sort of introspection, but I don't think its defined"

[09:29] <dbrock> I figured I needed to call the method on the variable as opposed to the value referenced by the variable

[09:29] <jql> that's the correct way -- however, the role has to exist for it to work, and it has to have a property of its own name

[09:29] <jql> at least according to the apocalypse

[09:29] <dbrock> oh

[09:29] <QtPlatypus> thanks jpl.

[09:30] <dbrock> jql: got an example of an existing role that has an eponymous property?

[09:31] <jql> my Role bitchin { has $.bitchin }

[09:32] <dbrock> ?eval my Role bitchin { has $.bitchin }; my $variable is bitchin; \$variable.bitchin

[09:32] <evalbot6> Error:  unexpected "b" expecting variable name or "(" 

[09:33] * jql pokes the parser

[09:33] <dbrock> ?eval my role bitchin { has $.bitchin }; my $variable is bitchin; \$variable.bitchin

[09:33] <evalbot6> Error:  unexpected "b" expecting variable name or "(" 

[09:33] <jql> ?eval role foo {};

[09:33] <evalbot6> undef 

[09:33] <jql> ?eval role bitchin {};

[09:33] <evalbot6> undef 

[09:33] <jql> ?eval role bitchin { has $.bitchin; };

[09:33] <evalbot6> undef 

[09:33] <dbrock> ?eval my role bitchin {};

[09:33] <evalbot6> Error:  unexpected "b" expecting variable name or "(" 

[09:33] <dbrock> :-)

[09:33] <jql> can't declare lexical roles yet

[09:34] <jql> not my fault. :)

[09:34] <dbrock> ?eval role bitchin { has $.bitchin }; my $variable is bitchin; \$variable.bitchin

[09:34] <evalbot6> Error: No compatible subroutine found: "&bitchin" 

[09:34] <dbrock> ?eval role bitchin { has $.bitchin }; my $variable is bitchin; \$variable

[09:34] <jql> ?eval role bitchin { has $.bitchin; }; 0 but bitchin

[09:34] <evalbot6> \undef 

[09:34] <evalbot6> Error: cannot cast from VObject (MkObject {objType = (mkType "Class"), objAttrs = <ref>, objOpaque = Nothing, objId = 50}) to Pugs.AST.Internals.VCode (VCode) 

[09:35] <jql> woot

[09:35] <dbrock> gg

[09:35] <jql> oh, there's an annoying wordy syntax

[09:36] <jql> ?eval role bitchin { has $.bitchin; multi sub trait_auxiliary:is(bitchin $trait, Any $container) { ... } }

[09:36] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:37] <jql> ?eval role bitchin { has $.bitchin; multi sub trait_auxiliary:<is>(bitchin $trait, Any $container) {...} }

[09:37] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:38] <jql> ?eval role bitchin { has $.bitchin; multi sub trait_auxiliary:<is>(bitchin $trait, Any $container:) {...} }

[09:38] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[09:40] <dbrock> ?eval sub trait_auxiliary:<is>($trait, $container) {...}

[09:40] <evalbot6> undef 

[09:41] <dbrock> ?eval sub trait_auxiliary:<is>(bitchin $trait, Any $container) {...}

[09:41] <evalbot6> Error:  unexpected "b" expecting formal parameter, ":" or ")" 

[09:41] <jql> it's a todo

[09:41] <dbrock> ?eval role bitchin {}; sub trait_auxiliary:<is>(bitchin $trait, Any $container) {...}

[09:41] <evalbot6> Error:  unexpected "b" expecting formal parameter, ":" or ")" 

[09:41] <vkon> ?eval $*OS

[09:41] <evalbot6> \undef 

[09:42] <dbrock> ?eval role Bitchin {}; sub trait_auxiliary:<is>(Bitchin $trait, Any $container) {...}

[09:42] <evalbot6> undef 

[09:42] <jql> w t f?

[09:42] <vkon> ?eval $*PERLVER

[09:42] <evalbot6> \undef 

[09:42] <jql> ?eval role Bitchin {multi sub trait_auxiliary:<is>(Bitchin $trait, Any $container) {...} }

[09:42] <evalbot6> undef 

[09:43] <dbrock> haha

[09:43] <jql> ?eval role Bitchin {multi sub trait_auxiliary:<is>(Bitchin $trait, Any $container) {...} } my $var is Bitchin

[09:43] <evalbot6> undef 

[09:43] <vkon> there are no version variable in pugs (like $] in perl) isn't it?

[09:43] <autrijus> ?eval $?PUGS_VERSION

[09:43] <evalbot6> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r6185)' 

[09:43] <jql> ?eval role Bitchin {multi sub trait_auxiliary:<is>(Bitchin $trait, Any $container) {die("what?") }} my $var is Bitchin

[09:43] <evalbot6> undef 

[09:44] <autrijus> jql: trait_auxiliary is not handled.

[09:44] <jql> I noticed, but I don't understand the parse error on 'b'

[09:44] <vkon> autrijus: thanks. worth mention in docs\quickref\var, isn't it

[09:44] <autrijus> almost all metaprogramming generic features is disabled :)

[09:44] <autrijus> vkon: sure, commits welcome

[09:44] <autrijus> s/disabled/TODO/

[09:44] <dbrock> ?eval sub trait_auxiliary:<is>(int $trait, Any $container) {...}

[09:44] <evalbot6> Error:  unexpected "i" expecting formal parameter, ":" or ")" 

[09:45] <dbrock> that's definitely wrong, right? :-)

[09:45] <jql> I don't get that, either

[09:45] <autrijus> I think that's because we don't handle unboxed types :)

[09:45] <autrijus> and as such all types are assumed to be upper cased.

[09:45] <dbrock> is there any problem with not assuming so?

[09:45] <jql> ahh. parser shortcut. all parameters begin with [A-Z:$%@&]

[09:45] <autrijus> I don't think so, so feel free to change

[09:46] <autrijus> it's in Lexer.hs line 304

[09:46] <autrijus> change "upper" to "letter" will do, I think.

[09:46] <autrijus> although I don't know about the _ type.

[09:46] <autrijus> sub f (_ $trait) {}

[09:46] <dbrock> what's the _ type?

[09:46] <autrijus> it's a valid package name that will not be matched by "letter".

[09:47] <vkon> autrijus: will try...  this eval bot is that one on Juerd's 'feather.perl6.nl' ??

[09:47] <dbrock> oh, right

[09:47] <autrijus> so maybe you want wordAlpha instead.

[09:47] <autrijus> vkon: right

[09:47] <autrijus> come to think about it, maybe _ is a good way to say "is typed"

[09:47] <autrijus> as in "compiler, please fill in the type here"

[09:47] <autrijus> my _ $x;

[09:47] <wolverian> could we generalise ... to that? :)

[09:48] <autrijus> I think ... is the term :)

[09:48] <dbrock> and what does that do?

[09:48] <autrijus> dbrock: it's a proposed feature that restricts $x to have a static type.

[09:48] <wolverian> which is determined when the variable is first assigned something?

[09:48] <autrijus> my $x is typed; $x = "x"; $x = length($x);

[09:48] <autrijus> wolverian: no, which is unified via the usual inference rules

[09:48] <dbrock> oh...

[09:48] <autrijus> i.e. at compile time

[09:48] <autrijus> not runtime

[09:48] <wolverian> autrijus, I have no idea what unification means in this context :)

[09:49] <autrijus> wolverian: it means that it gathers the three constrains

[09:49] <dbrock> so is that equivalent to my Object $x; ... or something?

[09:49] <autrijus> (store($x) <-- Str), (fetch($x) --> Str), (store($x) <-- Int)

[09:49] <autrijus> and try to find a type that satisfies them

[09:49] <autrijus> which of course fails

[09:49] <wolverian> ah, right.

[09:50] <wolverian> I do think a 'use static;' is more useful here.

[09:50] <autrijus> I suggested "use traits 'typed'".

[09:50] <autrijus> i.e. append "is typed" to all var decls.

[09:50] <dbrock> isn't there a top type?

[09:50] <wolverian> right. that makes sense.

[09:51] <autrijus> dbrock: yes, but $x can't be Object because you can't guarantee fetch(Scalar of Object) can yield Str.

[09:51] <autrijus> so top type doesn't help here.

[09:51] <wolverian> autrijus, would the typed mode be equivalent to haskell?

[09:52] <dbrock> so what?  Isn't it sufficient to guarantee that it can yield Object?

[09:52] <autrijus> wolverian: or OCaml, or Scala, or Nemerle... but yes.

[09:52] <wolverian> autrijus, right. :)

[09:52] <autrijus> dbrock: no, because then it may contain something that cannot be stringified.

[09:52] <autrijus> dbrock: then calling length() on it is bogus.

[09:52] <dbrock> ah

[09:52] <wolverian> autrijus, did you solve the undef problem you talked about on p6l?

[09:52] <autrijus> the idea of "is typed" is make sure that runtime errors are raised

[09:53] <autrijus> wolverian: looks like "is defined" can work

[09:53] <autrijus> wolverian: but larry is musing something very crazy

[09:53] <autrijus> hopefully he will elaborate.

[09:53] <autrijus> something about defined(Str) is false.

[09:54] <wolverian> that makes sense, and doesn't.

[09:54] <wolverian> depending on what defined() does, I guess.

[09:54] <autrijus> which is typically larry

[09:54] <autrijus> so I asked for code examples :)

[09:54] <wolverian> yeah. :)

[09:55] <wolverian> hmm. why aren't classes called templates?

[09:55] <wolverian> (in general.)

[09:55] <autrijus> because templates don't have this "inheritance" thing?

[09:56] <autrijus> ->SUPER and ->NEXT

[09:56] <wolverian> I think various templating modules do handle that sort of a thing...

[09:56] <autrijus> really.

[09:56] <autrijus> usually they do INCLUDE

[09:56] <wolverian> I think Mason has inheritance

[09:56] <wolverian> component inheritance, anyway

[09:57] <autrijus> that's true, but that's stretching its templating metaphor.

[09:57] <wolverian> I guess. the undef thread just made me think about classes as templates.

[09:57] <wolverian> idle speculation. :)

[09:58] <wolverian> I have to go, now. I'll check back in the evening to see if Larry has elaborated.รถ

[09:58] <autrijus> the prototype-based world share you view :)

[09:58] <wolverian> s/รถ//

[09:58] <autrijus> sure, ciao

[09:58] <wolverian> cheers!

[10:08] <autrijus> dbrock: under which name should I add you to AUTHORS? 

[10:08] <svnbot6> r6186 | vkon++ | describe more variables and reorganiza a bit quickref/var

[10:13] <vkon> ?eval say %*CONFIG.keys

[10:13] <evalbot6>  bool::true 

[10:13] <vkon> ?eval %*CONFIG.keys

[10:13] <evalbot6> () 

[10:14] <vkon> I see quickref/var are alphabetically sorted... I didn't noticed this first time... but is this reasonable??

[10:14] <svnbot6> r6187 | autrijus++ | * Allow lowercase and underscore for type names, eg:

[10:14] <svnbot6> r6187 | autrijus++ |     sub f (foo $x) { ... }

[10:14] <svnbot6> r6187 | autrijus++ |   Reported by jql.

[10:20] <vkon> ?eval %?CONFIG.keys

[10:20] <evalbot6> () 

[10:21] <autrijus> disabled in safe mode.

[10:22] * autrijus logs out from $work

[10:22] <autrijus> bbl

[10:24] <vkon> autrijus: see (from Run.hs)

[10:25] <vkon> autrijus: but what @=POD do? can't test it...

[10:25] <putter> dbrock, Aankhen``, et.al.,  eval:lang<haskell> "True" should be just fine...

[10:25] <putter> ?eval sub ev(+$lang,$code){$lang~" > "~$code}  ev :lang<haskell> "foo"

[10:25] <evalbot6> 'haskell > foo' 

[10:26] <putter> ?eval sub ev(+$lang,$code){$lang~" > "~$code}  ev "bar" :lang<haskell>

[10:26] <evalbot6> 'haskell > bar' 

[10:26] <putter> ?eval sub ev(+$lang,$code){$lang~" > "~$code}  ev:lang<haskell> "foo"

[10:26] <evalbot6> Error:  unexpected "\"" expecting ":", "(", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[10:26] <putter> That last is a bug.  I haven't gotten around to examining it.  Please feel free... :)

[10:27] <putter> Eventually want to be able to parse rx:foo/bar/ .

[10:28] <putter> And  1..10 :by(2)   but adverbs on infix is completely unimplemented.

[10:28] <scook0> vkon: I thought that was supposed to be %=POD

[10:28] <scook0> but @=POD is in the source...

[10:30] <vkon> scook0: but how it can be used? can't figure out...

[10:31] <scook0> vkon: my impression was that if you say %=POD<FOO>

[10:31] <scook0> that gets you a string with the contents of

[10:31] <scook0> =FOO

[10:31] <scook0> in the current source file (or something like that)

[10:32] <vkon> it does not accepts '='; may be it is not implemented??

[10:32] <scook0> i.e. it's a hash you can use to access all the different POD regions in the current file

[10:32] <scook0> vkon: I don't think it would be implemented

[10:33] <scook0> I was talking in terms of the spec

[10:33] <scook0> I don't think pugs handles POD at the moment

[10:33] <scook0> (could be mistaken...)

[10:33] <vkon> scook0: aha!  where are spec?

[10:34] <scook0> vkon: http://dev.perl.org/perl6/doc/synopsis.html

[10:34] <vkon> scook0: thanks!

[10:35] <scook0> there's also the Apocalypses and Exegeses, but those aren't as current

[10:35] <scook0> and there's a LOT of stuff that's accepted on p6l, but hasn't been written up in the Synopses

[10:35] <scook0> so don't take it as gospel :)

[10:36] <putter> also  http://search.cpan.org/~ingy/Perl6-Bible-0.19/  and stuff in pugs/docs/AES/

[10:36] <svnbot6> r6188 | vkon++ | describe more variables and reorganize quickref/var, 2nd try

[10:42] <Aankhen``> ?eval class Foo { has $.bar = { "bar" }; method baz () { $.bar } }; Foo.new.baz

[10:42] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[10:42] <Aankhen``> ?eval class Foo { has $.bar = "bar"; method baz () { $.bar } }; Foo.new.baz

[10:42] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[10:42] <Aankhen``> ?eval class Foo { has $.bar = { "bar" }; method baz () { $.bar } }; Foo.new().baz()

[10:42] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[10:42] <Aankhen``> ?eval class Foo { has Str $.bar; method baz () { $.bar } }; Foo.new().baz()

[10:42] <evalbot6> \undef 

[10:42] <Aankhen``> ?eval class Foo { has Str $.bar = "bar"; method baz () { $.bar } }; Foo.new().baz()

[10:42] <evalbot6> Error:  unexpected "{" expecting trait, ";" or end of input 

[10:42] <Aankhen``> Ah.

[10:43] <Aankhen``> ?eval class Foo { has $.bar is ro; submethod BUILD () { $.bar = "bar" }; method baz () { $.bar } }; Foo.new().baz()

[10:43] <evalbot6> \'bar' 

[10:49] <putter> It needs some work, but appending this

[10:50] <putter> site:dev.perl.org OR site:aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl6-language

[10:50] <putter> to the phrase of interest yields an intriguing google search.  I wonder if this could be tweaked to the point of usefulness?

[10:50] <Aankhen``> I think it'd be more useful if you changed the second `site:` to `inurl:`.

[10:52] <dbrock> Aankhen``: why did that avoid a parser errorL

[10:52] <dbrock> s/L/?/

[10:52] <Aankhen``> dbrock: What?

[10:52] <putter> yes!  http://www.google.com/help/operators.html  Aankhen``++

[10:52] <Aankhen``> :-D

[10:54] <Aankhen``> dbrock: Why did what avoid...?

[10:59] <Aankhen``> The "Changes" file for CGI.pm (Perl 5 :-) scares me.

[11:00] <Aankhen``> Especially the mentions of "Netscape 2.0b2".

[11:02] <Aankhen``> OK, I'm almost asleep anyway, so I'm gonna go lie down in my bead and hope to finish the job.

[11:02] <Aankhen``> BBL. &

[11:07] <putter> &

[11:19] <putter> an improved google suffix:

[11:19] <putter>  inurl:aspn.activestate.com/ASPN/Mail/Message/perl6-language OR inurl:www.nntp.perl.org/group/perl.perl6.compiler OR inurl:dev.perl.org/perl6/doc/design

[11:20] <putter> (though something has been lost - you need to search with omitted results included to get all the relevant stuff some other searches returned...:(

[11:27] <putter> google has 10k+ pages from rt.openfoundry.org, but no pugs; and a few pages from svn.perl.org/perl6/pugs/trunk/docs/ , but not enough.  does have pugs.kwiki.org.

[11:28] <dbrock> Aankhen``: adding the BUILD submethod

[11:28] <putter> &

[11:29] <dbrock> if I wanted to have hyphens be interchangable with underscores inside identifiers, could I implement that as some kind of custom parser thing?

[11:29] <dbrock> assuming it would be possible --- any idea of how it might look?

[11:43] *** nothingm1ch is now known as nothingmuch

[11:45] <scook0> dbrock: you mean like lisp-style identifiers?

[11:46] <scook0> I suppose in a fully-implemented Perl6 you would be able to replace the default identifier rule

[11:47] <scook0> (you'd probably want to s:g/-/_/ internally for compatibility with everyone else's code)

[11:54] <QtPlatypus> dbrock: You could do it with a macro

[11:56] <dbrock> scook0: ah, right

[11:57] <dbrock> (and yeah, that's what I'd do --- use underscores internally)

[11:57] <dbrock> QtPlatypus: like wrap all my code in a macro call?

[11:58] <scook0> well, you'd probably end up putting it in a package

[11:58] <scook0> then just put 'use LispyIdentifiers' at the top of all your source files

[11:58] <QtPlatypus> Possably.  Or an infix macro called "-" that glues the identifier together. 

[11:58] <scook0> QtPlatypus: that would be rather inelegant...

[11:59] <QtPlatypus> Or as scook0 says, replacing the identifier rule.

[12:00] <scook0> "There's more than one way to do it" # but not all of them are sensible :)

[12:00] <dbrock> yeah, that'd obviously be the most elegant way

[12:00] <dbrock> (well, it wasn't obvious to me when I asked the original question, but now that scook0 has mentioned it, it seems blatantly obvious :-))

[12:22] <estel> hi

[12:23] <estel> have you seen iblech here lately? I'm a friend and I'm starting wondering where he is...

[12:24] <gaal> seen iblech

[12:24] <jabbot> gaal: iblech was seen 13 hours 21 minutes 35 seconds ago

[12:25] <estel> thank you, you don't have his ip (maybe he's on holidays...)

[12:30] <Limbic_Region> heh - patches I submitted for Parrot over a year old just got applied

[12:30] * Limbic_Region is still involved with Parrot development and didn't even know it

[12:32] <Limbic_Region> Has Pugs noticed another startup performance gain recently?

[12:53] <Limbic_Region> fglock ping

[12:53] <fglock> hi

[12:54] <fglock> bom dia

[12:57] <Limbic_Region> how does the new ruling about native sets affect what you are working on

[12:57] <Limbic_Region> from the commits I have seen - I know you have put in a lot of work on them

[12:57] <fglock> I understand it is a new type - it is nor a List or Array

[12:58] <fglock> more like 'Set', which is likely to be reused

[12:58] <Limbic_Region> err um - does this mean that any/all of the modules you have created are now obsolte

[12:58] <Limbic_Region> does it mean you can recode some of it to use a new data type

[12:58] <Limbic_Region> and make some of the things you have already done easier

[12:58] <Limbic_Region> or are they completely unrelated

[12:58] <Limbic_Region> or something else entirely?

[12:59] <fglock> Set != Ordered Set

[12:59] <fglock> Although I would like to see ordered sets supported

[13:00] <Limbic_Region> ok - so none of what you have done changes and it is still needed/useful

[13:01] <fglock> yes - if you had ordered sets you could do things like (1..100) (-) (20..30) --> (1..19),(31..100)

[13:01] <fglock> you can do this with sets, but it is a waste - and it wouldn't work with infinite lists

[13:02] <fglock> currently you can't do (1..Inf) (-) (20..30) --> (1..19),(31..Inf)

[13:02] <fglock> you can do this with Set::Infinite

[13:03] <Limbic_Region> ok - I think I got it

[13:03] <Limbic_Region> thanks

[13:03] <fglock> too many data types

[13:04] <fglock> i'm only starting to grok List x Array and Container x Value

[13:06] <fglock> I guess I should rename Set::Infinite to Set::Ordered

[13:20] <fglock> I'm learning to switch back and forth between $x.method and $x->method

[15:05] <svnbot6> r6189 | fglock++ | * perl5/Perl6::Value::List - t/array-lazy.t passes all tests

[15:07] <svnbot6> r6190 | iblech++ | * docs/quickref/var: Added note about p6l musing about $*ENV and $?ENV.

[15:07] <svnbot6> r6190 | iblech++ | * PIL2JS: runjs.pl:  Added PIL2JS_RESOURCE_GUARD from pil2js.pl to runjs.pl.

[15:14] <svnbot6> r6191 | iblech++ | t/magicals/, t/builtins/io/: skip_rest if $*OS eq "browser".

[15:18] <Limbic_Region> OS = browser?

[15:18] <Limbic_Region> Emacs trying to take over the world again?

[15:19] <iblech> No, PIL2JS :)

[15:19] <iblech> I.e. JavaScript

[15:26] * Limbic_Region was of course kidding

[15:26] <svnbot6> r6192 | fglock++ | * perl5/ List passes grep(), map() tests

[15:32] <hexmode> I'm pretty sure the world is already ruled by emacs

[15:32] * hexmode ducks and covers

[15:38] <stevan> iblech: someone was looking for you earlier

[15:38] <svnbot6> r6193 | fglock++ | * perl5 List - map, grep working - "coro-less"

[15:38] <svnbot6> r6194 | fglock++ | * updated TODO

[15:39] <iblech> stevan: Yep, talked to him, thanks for noticing :)

[15:39] <stevan> iblech: cool :)

[15:39] * iblech fixed -CPIL not printing multi sub decls, committing in a minute

[15:40] <stevan> iblech++ :)

[15:40] <iblech> Thanks :)

[15:42] <svnbot6> r6195 | iblech++ | Pugs.Compile: -CPIL prints multi sub decls now. (It's a 2-line patch,

[15:42] <svnbot6> r6195 | iblech++ | (Haskell's conciseness++) :))

[16:18] <scrottie> uploading to slowass. this will take about an hour ;)

[16:18] <svnbot6> r6196 | brentdax++ | Initial Pugs checkin.

[16:18] <scrottie> ack, wrong window.

[16:18] * scrottie looks at svnbot6, startled

[16:18] <brentdax> ...crap, didn't mean to do that.

[16:21] <autrijus> what the...

[16:21] * autrijus takes swift action.

[16:22] <autrijus> ...you beat me to it. ;)

[16:22] <chip_> autrijus: could you give me a quick answer how hoisting is supposed to work given the presence of   { my $x; { my $x; $x = 1 } }

[16:22] <autrijus> chip_: note the inner scope is a closure.

[16:22] <brentdax> Wow, I screwed things up.  Sorry.

[16:22] <autrijus> i.e. a Code.

[16:24] <chip_> it's a Code in principle, but given the "as-if" rule I'm not planning to make it a real Code

[16:24] <svnbot6> r6197 | autrijus++ | ...undo...

[16:24] <chip_> darn it, I have to go.  transportation

[16:24] <chip_> grr

[16:24] <autrijus> chip_: a inner label is as good as a inner routine, no?

[16:24] * chip_ &

[16:24] <autrijus> oh well. ciao

[16:24] <chip_> not for pad reasons

[16:24] <chip_> labels dont' have pads

[16:24] * chip_ & really

[16:25] <autrijus> I suggest that I can hang pads to labels.

[16:25] <autrijus> or I'll use a real inner routine for it.

[16:25] <autrijus> ciao :)

[16:26] <autrijus> brentdax: it's fine, you wasted maybe 10 bytes on the repository

[16:26] * autrijus praises svk, lazy copy

[16:26] <brentdax> True.  Hurray for cheap copies.

[16:26] <Limbic_Region> autrijus - so you don't go back to $work till next Monday right?

[16:26] <autrijus> Limbic_Region: right, I plan to give PIL another push this weekend

[16:27] <autrijus> however I need to sleep first :)

[16:27] <Limbic_Region> right

[16:27] <autrijus> clkao++ # cheap copies across offline repositories and back

[16:28] <brentdax> I'll try using 'pull' instead of 'sync' from now on.  ;^)

[16:28] <clkao> damnit, I am so cheap!

[16:28] <autrijus> clkao++ # cheap and cheerful!

[16:29] <Limbic_Region> autrijus - as you have a pretty good handle on who is concentrating on what - who, if anyone, is focusing on implementing more of the spec'd p6 into Pugs

[16:29] * Limbic_Region was suprised to hear you estimate only 25% of the spec'd language has been implemented

[16:29] <autrijus> Limbic_Region: note that of the remaining 75%, over half was vaguely, badly, or inconsistently specced.

[16:30] <autrijus> which we don't really notice until we go ahead and implement them anyway.

[16:31] <brentdax> Proof that you only use 20% of the language for 80% of your tasks...

[16:31] <autrijus> indeed.

[16:31] <autrijus> or

[16:31] <autrijus> Proof that perl6 is a 10x richer language than perl5.

[16:31] <autrijus> ;)

[16:32] * brentdax is vaguely tempted to fake MMD with nested hashes.

[16:33] <brentdax> (or rather, MMD with arbitrary constraints.)

[16:33] <autrijus> you mean value mmds

[16:33] <autrijus> yeah.

[16:34] <brentdax> I figure I could do %adapter{$revision.attributes<kontent:class>}{$request.mode}{$request.format}, then try undefing one, then two.  Or something.  But that would be insane.

[16:36] <autrijus> how did you survive in p5? :)

[16:37] <brentdax> I could have written this project in Perl 5 anytime if I thought the language was up to it.

[16:41] <brentdax> With Pugs I at least know the hacks are temporary.  I couldn't stand them being permanent.

[16:43] <brentdax> Gah, I hate how when you pack the night before, you always end up needing stuff you've packed the next morning.

[16:54] * autrijus proceeds to defend inferencing some more.

[16:57] <fglock> autrijus: set operations are list ops?

[16:58] <fglock> or will be a separate entity for sets

[16:58] <autrijus> fglock: just provide two coercers. :)

[16:59] <autrijus> Set.to_list and List.to_set

[16:59] <autrijus> chip_: larry lifted the ban!

[17:00] <autrijus> the ban on documenting about named returns :)

[17:00] * autrijus is happy

[17:00] <autrijus> sub f ($x --> $y) { $y = $x * 2; say "I return $y anyway!" }

[17:00] <fglock> 1..Inf.to_set could yield a Span object - you can do 1..Inf intersection -Inf..10 and get 1..10

[17:01] <autrijus> fglock: right. that'd be cool

[17:03] <fglock> *shift doesn't call the core shift, it calls the method

[17:03] <autrijus> you need &*shift

[17:03] <autrijus> otherwise it's taken as slurpizing shift().

[17:04] <fglock> :)

[17:11] <autrijus> sub init_dbh (--> DBI $dbh) { $dbh .= connect('dbi:...'); $dbh.do('some init code'); say "I return $dbh no matter what :-)" }

[17:17] <integral> eww, how fortranish :)

[17:19] <PerlJam> fortranish?

[17:21] <stevan> reminds me of "out" parameters in Ada

[17:22] <autrijus> I don't think it's a bad idea :)

[17:22] <autrijus> (but yes it's very fortranish.)

[17:22] <autrijus> it also enables

[17:22] <autrijus> sub foo (+$dbh) { ... }

[17:22] <autrijus> and then

[17:23] <autrijus> foo(init_dbh())

[17:23] <autrijus> without explicitly passing in the name

[17:23] <autrijus> (not sure it's a feature, but it falls out naturally)

[17:23] <integral> foo init_dbh; # more perlish

[17:24] <ods15> if((a=p[m]&~15)&&a==p[m-1]>>4?(!(++n^1)&&!(U[n-1]=p[m-1]&15))||(U[n]=p[m]&15)<<1:n){

[17:25] <autrijus> yeah.

[17:25] <ods15> i'm trying out for ioccc

[17:25] <ods15> do i have a chance :/

[17:25] <ods15> tbh, i think not

[17:25] <autrijus> you can learn to program in J instead.

[17:26] <ods15> my program is mostly just ugly, not obfuscated :/

[17:26] <autrijus> # http://en.wikipedia.org/wiki/J_programming_language

[17:26] <autrijus>   qsort =: ]`(($:@:((}.<:{.)#}.)),{.,($:@:((}.>{.)#}.)))@.(*@#)

[17:30] <ods15> i've seen worse. i think

[17:33] <autrijus> oh?

[17:33] <coral> ow ow

[17:34] <coral> the source to formail looks like what you said, ods15

[17:34] <ods15> formail?

[17:34] <ods15> F(j,9,0)n=(m=r[j*9+i].i)+r[i+j*9].t,x[n?m:1]-=0&y[r[j+i*9].i]--||n?!z[r[L(i,j)].i]--|1:(j=0,3);

[17:35] <ods15> F(i,10,1)i=b->n[i]?main(Q(r+((V*)memcpy(b+1,r,!~3+sizeof(r))-1)->p,b->i=i),0)?

[17:35] <ods15> b->i+(memcpy(r,b+1,sizeof(r))&&0):1:i;

[17:35] <ods15> for(a=(k[10]==n)*9;a--||(m++,n=0);)F(i,9*!!(p[m]&(8<<(a+2))),(k[i]?R(c,i):1));

[17:35] <ods15> those are all my best expressions

[17:36] <ods15> the rest are nowhere near as good, and even these are not that good :/

[17:37] <fglock> i'm debugging perl5/Lazy for half an hour - can't find the bug

[17:37] <ods15> as perl programmers i was wondering if you guys can help me obfuscate...

[17:38] <fglock> ods15:  i'm trying to learn to do the opposite :)

[17:39] <ods15> http://rafb.net/paste/results/M9AM4o72.html

[17:39] <ods15> that's an out of date version actually.. my newer version is about 300-400 bytes smaller and hasn't been formatted yet

[17:40] <ods15> the design IS supposed to mean something, but it's hardly understandable, only if you already know it...

[17:43] <autrijus> journal up. /me waves &

[17:43] <dduncan> alright

[17:43] <obra> night

[17:45] <ods15> bite

[18:06] <mauke> sizeof(*p)? how boring

[18:08] <mauke> I'd use sizeof*p or sizeof n or sizeof L(3, 'x')

[18:24] <svnbot6> r6198 | fglock++ | * perl5/ List - almost all tests pass

[18:36] <ods15> mauke: ?

[18:36] <ods15> what's sizeof L(3, 'x') ?

[18:36] <mauke> do you know what sizeof is?

[18:37] <ods15> well, i know it's a C construct, not a function...

[18:37] <ods15> hmm, a keyword.. meaning is can tolerate not having ()...

[18:38] <ods15> anyway, finally, this one is the first good expression i made using recursions.. (i have a recursive main(), but it's not a very good recursion)

[18:38] <ods15> T Q(t,o)V*t;{u t->i?o&16?t->t=0:(t->n[o+1]=Q(t,R(L((t->p%9/3+t->p/27*3),o),R(o*9+t->p%9,

[18:38] <ods15> R(o+t->p/9*9,t->i)))?o-1:e)):(e=t->i=o)&&Q(t,8);}

[18:38] <mauke> sizeof is a (unary) operator

[18:38] <mauke> the nice thing about it is that it doesn't evaluate its operand

[18:38] <ods15> mauke: ok, but what's that 'L' thing got to do with it

[18:39] <mauke> that's a function in the source

[18:39] <ods15> yeah, it only cares about the typeof

[18:39] <ods15> hmm, so, if i have some functions which returns typeof *p, i can use it there, and it will never be called?

[18:40] <mauke> yes

[18:40] <mauke> typeof *p seems to be int, so sizeof printf("hello") would work

[18:40] <ods15> hmm, yeah, that one is an int

[18:41] <ods15> i got another sizeof though for a struct

[18:41] <ods15> and none of my functions return that struct, it's global

[18:42] <ods15> no, wait, it's a sizeof of the entire array

[18:42] <mauke> (2<<5)^17 is the same as 2<<5^17

[18:42] <mauke> typedef struct {...} V; "better" written as struct {...} typedef V;

[18:42] <ods15> that's odd, i thought i removed all redundant ()

[18:43] <ods15> ohhh, it's the one in the very begginning

[18:43] <ods15> lol, i hadn't touched that part in quite a while, i just needed to spazz up a const :)

[18:43] <mauke> there are many redundant () there

[18:44] <mauke> sizeof(r) => sizeof r

[18:44] <mauke> .deparse :p (p[m]&~15)&&(p[m]>>4==p[m-1]>>4)

[18:44] <mauke> p[m] & ~15 && p[m] >> 4 == p[m - 1] >> 4

[18:44] <mauke> no parens needed

[18:44] <ods15> mauke: i think that one has already been fixed

[18:44] <ods15> if((a=p[m]&~15)&&a==p[m-1]>>4? \ (!(++n^1)&&!(U[n-1]=p[m-1]&15))||(U[n]=p[m]&15)<<1: \

[18:45] <ods15> yeah

[18:45] <ods15> some are to prevent compiler warnings, my program compiles cleaning without warning in -Wall

[18:46] <ods15> hmm, that's a bug! .. ?

[18:47] <ods15> odd that it worked

[18:47] <ods15> that '<<1' should've been '>>4'

[18:48] <mauke> still too many parens

[18:49] <mauke> but I guess gcc warns about && in ||

[18:50] <ods15> mauke: yes

[18:50] <ods15> that's the only redundant paranthesis there

[18:50] <ods15> anyway, the new version...

[18:51] <ods15> http://rafb.net/paste/results/PfdeWb36.html

[18:51] <ods15> afaik not a single redundant () there, except sizeof

[18:51] <mauke> wow, C++ rocks: int x ; :: new (& x) int ( 42);

[18:52] <ods15> mauke: ??

[18:52] <mauke> it compiles

[18:53] <ods15> what is it though

[18:53] <ods15> new is a keyword, not a function, so i'm not sure what ::new() does...

[18:54] <mauke> putchar((putchar(p++->i+3*16)&1<<5)-22*!(i%9)) could be rewritten as putchar(putchar(p++->i+3*16)%2*32-22*!(i%9))

[18:54] <ods15> i didn't even know new could get a 9&)

[18:54] <mauke> that's just placement new

[18:54] <ods15> (&x) i mean

[18:54] <mauke> that's how you tell it to construct an object at a specified address

[18:55] <mauke> it should be equivalent to x = 42;

[18:55] <ods15> putchar(p++->i+3*16)%2*32 - i don't get it.. how would this work?

[18:55] <mauke> hmm, or not

[18:55] <mauke> haha, I'm an idiot

[18:55] <ods15> mauke: and it destroys the previous object?

[18:55] <mauke> no, it doesn't call any destructors

[18:55] <ods15> it should...?

[18:55] <mauke> never mind, my "rewrite' is wrong

[18:56] <mauke> it's useful if you want to implement a container like std::vector

[18:56] <ods15> but, i think it should call the destruct is x's type is some kind of weird advanced thing

[18:57] <ods15> because it's basically overwriting it

[18:57] <mauke> you can get a chunk of memory with new char[x], then construct objects in it with new (buf) T;

[18:57] <ods15> if x was pointwer, it would be like:   delete x; x = new something

[18:57] <ods15> anyway, forget it, i hate C++

[19:00] <ods15> anyway, my next TODO is to make it "pretty print"

[19:00] <ods15> instead of dull output

[19:00] <ods15> 2 8 6 9 1 3 7 5 4

[19:00] <ods15> 3 9 1 5 7 4 6 8 2

[19:00] <ods15> 1 4 3 | 5 8 6 | 2 9 7

[19:00] <ods15> ======+=======+======

[19:00] <ods15> 8 9 4 | 2 1 5 | 7 6 3

[19:00] <ods15> like that

[19:01] <ods15> i can easily do it with more putchars(), but putchar is an expensive funxtion name...

[19:01] <ods15> it won't fit easily in my formatting later, and it's a lot of bytes

[19:04] <ods15> mauke: any ideas?

[19:04] <ods15> maybe puts

[19:32] <kolibrie> stevan: ping

[19:33] <stevan> kolibrie: pong

[19:33] <pdcawley> pang

[19:33] <kolibrie> stevan: about to commit 20_000_ft_view.txt

[19:34] <stevan> kolibrie: nice!

[19:34] <kolibrie> in response to your adding my name to your 10_000 ft view

[19:34] <stevan> :P

[19:35] <masak> at which altitude will the file contain just one dot? :)

[19:35] <kolibrie> stevan: r6200

[19:35] <kolibrie> what a nice number that is

[19:35] <svnbot6> r6199 | kolibrie++ | initial import of metamodel 20_000_ft_view.txt

[19:35] <kolibrie> oh, 6199

[19:35] <stevan> masak: orbital_view.txt

[19:36] <masak> oh :)

[19:37] <kolibrie> stevan: I was planning on sending a post to p6c, to kick off discussion

[19:38] <nothingmuch> evening

[19:38] <kolibrie> hi nothingmuch 

[19:38] <stevan> evening nothingmuch 

[19:38] <kolibrie> that made a nice pyramid

[19:40] * kolibrie hits send

[19:41] <stevan> kolibrie: cool

[19:41] <svnbot6> r6200 | masak++ | spelling

[19:44] <svnbot6> r6201 | iblech++ | PIL2JS:

[19:44] <svnbot6> r6201 | iblech++ | * Unbreak Test.pm procompilation (was broken because -CPIL outputs the multi

[19:44] <svnbot6> r6201 | iblech++ |   &Test::skip now -- needs proper multi support in PIL2JS).

[19:44] <svnbot6> r6201 | iblech++ | * Speed up compilation by 300% or so by not indenting the output unless

[19:44] <svnbot6> r6201 | iblech++ |   explicitely wanted -- i.e. ":js ..." in the interactive shell still outputs

[19:44] <svnbot6> r6201 | iblech++ |   indented code, but Prelude.js is mostly unindented. This also fixes the

[19:45] <svnbot6> r6201 | iblech++ |   problem that compiling t/operators/arith.t takes 1.5 GiB of RAM...

[19:45] <svnbot6> r6201 | iblech++ | * Rewrote the indenting code to use a regex instead of manually splitting and joining.

[19:45] <integral> 1.5GiB :-/

[19:46] <Khisanth> and I thought compiling pugs itself was bad...

[19:50] <stevan> kolibrie: should I respond with changes/updates/clarifications on p6c? or add to the doc?

[19:51] <stevan> ok, not seeing a p6c post yet, so I will update svn :)

[19:52] <kolibrie> stevan: whichever - the post should be coming - but svn is the "master"

[19:53] <stevan> ok

[19:54] <svnbot6> r6202 | iblech++ | Prelude::JS::ControlFlow: Fix if $junc {...} and unless $junc {...} (was

[19:54] <svnbot6> r6202 | iblech++ | incorrectly autothreading).

[19:59] <svnbot6> r6203 | iblech++ | PIL2JS: PIL::Params: Always $?SELF := invocant in methods.

[20:01] * nothingmuch is hearing sirens and automatic gun fire

[20:01] <nothingmuch> you'd think I was in israel or something

[20:01] <Khisanth> you're not?

[20:01] <nothingmuch> ;-)

[20:02] <nothingmuch> silliness aside - this is a quiet part of israel, and the sirens and gunfire were unrelated

[20:02] <nothingmuch> i expect possibly more sirens later in response to the gunfire, but i think the first ones were an ambulance

[20:03] <nothingmuch> the gunfire we get around here is usually beduim tribes duking it out because someone's sister had a crush on a guy from another family

[20:03] <masak> romeo and juliet theme

[20:04] <masak> nothingmuch: are you in any danger?

[20:05] <nothingmuch> masak: i don't think so

[20:05] * nothingmuch has a good feeling about the snail-mail mailbox

[20:06] * nothingmuch goes to check (an excuse to ride my bike)

[20:06] <masak> :)

[20:07] <nothingmuch> shit... my bike is stuck in piles of books and I can't wedge it out

[20:08] <masak> i hate when that happens

[20:08] <nothingmuch> yeah, we're rennovating

[20:08] <Khisanth> read faster! :P

[20:08] <masak> lol

[20:08] <nothingmuch> Khisanth: i can't read german and these are mostly in german, and not mine, either

[20:08] <nothingmuch> mostly my mother's

[20:08] <masak> then i guess your bike is stuck

[20:09] <Khisanth> hmm burn the books!

[20:09] <nothingmuch> yes, it is, till they finish retiling our floors and we can refill the bookshelves

[20:09] <masak> maybe someone else who knows german can read them and remove them?

[20:09] <nothingmuch> Khisanth: they're in my room, next to my: bed, books, bass, furniture

[20:09] <masak> you should ask TSa for help

[20:10] <masak> or stevan

[20:10] <nothingmuch> heh =)

[20:10] <nothingmuch> 'rents read german, so that's not a problem, and most of these books were already read

[20:10] <nothingmuch> anyway, i'm going to go by car =(

[20:10] <masak> ...if it's not obstructed by giant servers :)

[20:14] <svnbot6> r6204 | iblech++ | PIL2JS:

[20:14] <svnbot6> r6204 | iblech++ | * PIL::Params: Don't autothread junctions if in Bool context. (To be

[20:14] <svnbot6> r6204 | iblech++ |   fair, I'm not really checking if we're in Bool context (that'd need some more

[20:14] <svnbot6> r6204 | iblech++ |   work on the -CPIL side as well), but if the param expects a Bool.)

[20:14] <svnbot6> r6204 | iblech++ | * PIL::Params: Params which expect Pairs do not participate in named binding.

[20:18] <Khisanth> nothingmuch: walk!

[20:18] <nothingmuch> Khisanth: too lazy time wise

[20:19] <nothingmuch> bike is quick, car is quick and cumbersome, walk is slow

[20:20] <nothingmuch> anywho, good news - my new pocket knife has arrived. I bought it 3 months ago when I was supposed to go camping, but they ran out of stock. Camping was subsequently delayed till cancellation, and now the knife arrives just as plans for camping are reformulating

[20:21] <nothingmuch> this is possibly a good sign, since it could mean that camping might actually happen this time around

[20:34] <svnbot6> r6205 | iblech++ | PIL2JS: README: Updated to current status (no return exceptions any more, but CPS).

[20:56] <svnbot6> r6206 | fglock++ | * perl5/ List - only 2 bugs left

[21:07] <svnbot6> r6207 | Stevan++ | 20,000 ft view - updates, clarifications and corrections to kolibrie++ document

[21:14] * Aankhen`` goes to sleep.

[21:14] <Aankhen``> G'night.

[21:27] <kolibrie> stevan: thanks for your clarifications and corrections

[21:27] * kolibrie will ponder overnight

[22:03] <svnbot6> r6208 | iblech++ | * Usual svn props.

[22:03] <svnbot6> r6208 | iblech++ | * PIL2JS:

[22:03] <svnbot6> r6208 | iblech++ |   * Unbreak subs which take params which are not Any or Pair (was broken

[22:03] <svnbot6> r6208 | iblech++ |     because of r6204).

[22:03] <svnbot6> r6208 | iblech++ |   * return(...) always jumps out of the enclosing subroutine, not block/whatever.

[22:03] <svnbot6> r6208 | iblech++ |   * Still haven't figured out why .pairs does not work 100% correctly, seems to

[22:03] <svnbot6> r6208 | iblech++ |     have to do with pairs, will investigate further tomorrow.

[22:05] <iblech> Night all :)

[22:16] <svnbot6> r6209 | fglock++ | * perl5/ List

[22:16] <svnbot6> r6209 | fglock++ |   - all tests pass!

[22:16] <svnbot6> r6209 | fglock++ |   - Removed pair() - this module does not has access to the Pair constructor

[22:16] <svnbot6> r6209 | fglock++ |   - updated MANIFEST

[22:16] <svnbot6> r6209 | fglock++ |   - Separate from_num_range() and from_range() constructors. 

[22:16] <svnbot6> r6209 | fglock++ |      - from_num_range() is a numeric range. 

[22:16] <svnbot6> r6209 | fglock++ |      - from_range() is a generic range for strings, etc. 

[22:16] <svnbot6> r6209 | fglock++ |      Both constructors are just new() wrappers.

