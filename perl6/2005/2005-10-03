[01:02] <stevan> autrijus: ping

[01:06] <stevan> autrijus: I assume you backlog,.. so I will tell you

[01:06] <stevan> I got singleton methods working

[01:06] <stevan> see t/36_singleton_methods.t

[01:07] <stevan> I found out how Ruby does it,.. which is insert an anon-class in between the regular class an the instance

[01:07] <stevan> so you have this [Object] -> [Foo] -> [anon class for $foo]-> $foo

[01:07] <stevan> then all the singleton methods get stashed into the anon class

[01:07] <stevan> since it is specific to $foo only,.. it works

[01:08] <stevan> I did this with a subclass of $::Class

[01:08] <stevan> :)

[01:08] <stevan> ok... time to watch some TV &

[01:10] <svnbot6> r7225 | stevan++ | Perl6::MetaModel 2.0 -

[01:10] <svnbot6> r7225 | stevan++ | * fixed the test to create *proper* singleton methods (ala Ruby)

[01:10] <svnbot6> r7225 | stevan++ |   basically we just insert an instance specific anon-class into

[01:10] <svnbot6> r7225 | stevan++ |   the mix at the right time, and whalla you have singleton methods.

[01:10] <svnbot6> r7225 | stevan++ |   I implemented this by making a subclass of $::Class, however it

[01:10] <svnbot6> r7225 | stevan++ |   might make sense to actually integrate this into the core of the

[01:10] <svnbot6> r7225 | stevan++ |   metamodel itself. I would certainly make class methods easier, and

[01:11] <svnbot6> r7225 | stevan++ |   allow for some very interesting assorted evil tricks :)

[06:19] <brentdax> ?eval class X { submethod BEGIN { say "X" } } class Y is X { submethod BEGIN { say "Y" } } Y.new

[06:19] <evalbot_7225> Y.new(); 

[06:19] <brentdax> ?eval class X { submethod BEGIN { say "X" } } class Y is X { submethod BEGIN { say "Y" } } Y.new()

[06:19] <evalbot_7225> Y.new(); 

[06:20] <brentdax> ?eval class X { submethod BEGIN() { say "X" } }; class Y is X { submethod BEGIN() { say "Y" } }; Y.new()

[06:20] <evalbot_7225> Y.new(); 

[06:20] <Khisanth> heh

[06:20] <brentdax> evalbot is not being very helpful.

[06:21] <Khisanth> ?eval class X { submethod BEGIN() { say "X" } } class Y is X { submethod BEGIN() { say "Y" } } Y.new()

[06:21] <evalbot_7225> Y.new(); 

[06:21] <Khisanth> ?eval class X { submethod BEGIN() { say "X" } } class Y is X { submethod BEGIN() { say "Y" } } my $y = Y.new()

[06:21] <evalbot_7225> \Y.new(); 

[06:21] <Khisanth> well ...

[06:22] <brentdax> Even when I take X out of the equation, Y still doesn't print.  This is odd.

[06:22] <brentdax> ...oh, wait, I'm an idiot.

[06:22] <brentdax> ?eval class X { submethod BUILD { say "X" } } class Y is X { submethod BUILD { say "Y" } } Y.new

[06:22] <evalbot_7225> X Y Y.new(); 

[06:23] <brentdax> Okay.  Doesn't explain why actions being taken by X's (or Cipher's) constructor aren't registering, but it's a start.

[06:24] <brentdax> Er...except that I made the same mistake there, too.  Heh.

[06:42] <nothingmuch> glorf

[06:42] <svnbot6> r7226 | brentdax++ | Cipher API:

[06:42] <svnbot6> r7226 | brentdax++ |   * Full testing of Cipher.pm (including new test cipher)

[06:42] <svnbot6> r7226 | brentdax++ |   * Documentation for Cipher::Caesar

[06:43] <brentdax> I actually have copies of Cipher::Stream and Cipher::Arcfour (RC4) locally, but I haven't tested either of them.

[06:46] <nothingmuch> check in

[06:46] <nothingmuch> we can submit some tests

[06:46] <nothingmuch> the most basic test for all of them is round trip

[06:47] <nothingmuch> and that the thing at the middle of the trip ne the thing before and after it

[06:47] <nothingmuch> and that middle of trip is ne middle of trip when key is different

[06:58] <nothingmuch> brentdax: ?

[07:04] <nothingmuch> http://www.cypherspace.org/adam/rsa/rc4.html

[07:12] <brentdax> I'd at least like to get some test vectors pulled together first.  Testing it is pretty easy--I just have to do it.

[07:17] <nothingmuch> i'm willing to help if you like

[07:25] <svnbot6> r7227 | nothingmuch++ | test for optional trailing semicolon on blockish exprs.

[07:46] <brentdax> ?eval class X {} my %options = (:foo<bar>); X.new(*%options)

[07:46] <evalbot_7227> Error: Must only use named arguments to new() constructor 

[07:47] * brentdax curses quite a bit.

[07:47] <brentdax> ?eval class X {} my %options = (:foo<bar>); X.new(%options.pairs)

[07:47] <evalbot_7227> Error: Must only use named arguments to new() constructor 

[07:47] <brentdax> ?eval class X {} my %options = (:foo<bar>); X.new(map { $_ } %options.pairs)

[07:47] <evalbot_7227> Error: Must only use named arguments to new() constructor 

[07:48] <brentdax> That makes it rather hard to pass options from the various wrapper routines into the constructor.

[07:51] <brentdax> Guess I'll just test with the OO core.

[07:58] <brentdax> Gah, I'll commit it anyway.  Stupid OO.

[07:59] <nothingmuch> hehe

[07:59] * nothingmuch wants luqui's tuples to make it in

[08:01] <svnbot6> r7228 | brentdax++ | Cipher API:

[08:01] <svnbot6> r7228 | brentdax++ |   * Undocumented Cipher::Stream

[08:01] <svnbot6> r7228 | brentdax++ |   * Undocumented Cipher::Arcfour (RC4)

[08:01] <svnbot6> r7228 | brentdax++ |   * arcfour.t, which fails the second test for mysterious reasons

[08:01] <svnbot6> r7228 | brentdax++ | Ideas on what's causing arcfour.t to fail would be appreciated.

[08:14] <nothingmuch> theorbtw1: long time no see!

[08:15] <theorbtw1> Allo, nothingmuch!

[08:16] <nothingmuch> what's up?

[08:19] <theorbtw1> Been working on a contest entry, and ended up possibly missing the entry deadline by 40 minutes because the terms weren't clearly written.

[08:20] *** theorbtw1 is now known as theorbtwo

[08:21] <kgftr|konobi> theorbtwo: oioi

[08:21] <theorbtwo> Yeah.

[08:21] <theorbtwo> Well, it'll still get used, if only by Jess and I.

[08:21] <kgftr|konobi> theorbtwo: jess on her way or still feeling under the weather?

[08:21] <theorbtwo> Sorry I wasn't at the pub on Friday; Jess wasn't feeling well (and is staying home sick again today).

[08:22] <kgftr|konobi> ah... hokey dokey... no probs! perhaps next time?

[08:22] <theorbtwo> Next time indeed.

[08:22] <nothingmuch> bah

[08:22] * nothingmuch backlogs

[08:23] <theorbtwo> I should probably finish the "create a new user" page before I point you at it...

[08:23] <nothingmuch> what is the contest?

[08:31] <nothingmuch> theorbtwo: ?

[08:38] <kgftr|konobi> theorbtwo: damn prvmsgs are blocked... can you ask jess to ring anthony to confirm sick, etc.

[08:44] <spinclad> ?eval $?PUGS_VERSION

[08:44] <evalbot_7228> \'Perl6 User\'s Golfing System, version 6.2.9, August 3, 2005 (r7228)' 

[08:44] <spinclad> ?eval class X {} my %options = (:foo<bar>); X.new(*(map { $_ } %options.pairs))

[08:44] <evalbot_7228> Error: Must only use named arguments to new() constructor 

[08:45] <spinclad> ?eval class X {} X.new(:foo<bar>)

[08:45] <evalbot_7228> X.new(('foo' => 'bar')); 

[08:48] <dada> ?eval class X {} my %options = (:foo<bar>); X.new(%options)

[08:48] <evalbot_7228> Error: Must only use named arguments to new() constructor 

[08:48] <dada> mmm

[08:48] <dada> that's unorthogonal

[08:49] <theorbtwo> backstage.bbc.co.uk.

[08:50] <theorbtwo> I created a TV schedule grid that shows customized ratings -- it tells you what's on that it thinks you'd like.

[08:50] <nothingmuch> hola castaway_!

[08:51] <castaway_> kgftr|konobi: I already called HR, doesnt that cover it? Else, whats his number?

[08:53] <nothingmuch> wow, attribute grammars are fun

[08:53] <nothingmuch> now lets see if they actually work ;-)

[08:54] * castaway_ nudges Scott

[08:54] <svnbot6> r7229 | brentdax++ | Cipher API:

[08:54] <svnbot6> r7229 | brentdax++ |   * Documentation for Cipher::Arcfour.

[08:54] <scook0> gah, goddamn tests!

[08:55] <scook0> I spend half an hour getting the damn test script to run

[08:55] <scook0> and then it pretends my test statements don't even exist!

[08:56] <scook0> (and the test takes about a minute to load before doing nothing!)

[08:58] <nothingmuch> blah

[08:58] <scook0> well, hopefully it'll be worth all the trouble

[08:59] <scook0> !

[09:00] <svnbot6> r7230 | iblech++ | * Usual svn props.

[09:00] <svnbot6> r7230 | iblech++ | * System.FilePath: Added a not (null fname) guard (i.e., fixed a bug).

[09:00] <svnbot6> r7230 | iblech++ |   We should probably propagate the fix upstream (at least when ok'd by a real

[09:00] <svnbot6> r7230 | iblech++ |   lamda hacker).

[09:00] <svnbot6> r7230 | iblech++ | * Main: Added %?CONFIG<sourcedir> to the list of paths to search and

[09:00] <svnbot6> r7230 | iblech++ |   added a tryIO call so the search doesn't die.

[09:01] * nothingmuch struggles with his pretty printer

[09:02] <kgftr|konobi> castaway_: ah... that should be fine... will let anthony know

[09:03] <castaway_> ok good

[09:03] * castaway_ passes around the Sinupret

[09:04] <nothingmuch> luqui: !!!!!!!!!!!!

[09:04] <nothingmuch> i've been waiting for ever

[09:04] <luqui> hi nothingmuch

[09:04] <nothingmuch> fix your svn repo

[09:04] <luqui> yeah, I've had my nose in school

[09:04] <luqui> it is fixed

[09:04] * castaway_ wanders again

[09:04] <nothingmuch> also, i need to do some funky stuff with L::AG

[09:04] <luqui> (it dies every once in a while ??)

[09:04] <nothingmuch> i have a test for threaded attributes

[09:04] <luqui> nothingmuch, like?

[09:04] <luqui> Oh, I figured out a new lazy algorithm that could be much better than the one I am using memory-wise

[09:04] <luqui> I have to do some analysis though

[09:05] <nothingmuch> and also i have e.g. type::operator::arrow isa type::operator::binary

[09:05] * luqui hates threaded attributes

[09:05] <luqui> do it without punning if you can

[09:05] <luqui> type::operator::arrow?

[09:05] <svnbot6> r7231 | iblech++ | util/smokeserv/smokeserv-server.pl: Always set $*ENV<TZ> to "UTC" so the

[09:05] <svnbot6> r7231 | iblech++ | template ("Timezone is UTC") doesn't lie.

[09:05] <nothingmuch> i would like 'to say operator::binary: layout($$) = { join(" ", layout($.left), $.symbol, layout($.right)) }'

[09:06] <nothingmuch> and have that work on type::operator::arrow and type::operator::pair

[09:06] <luqui> ahh yes

[09:06] <luqui> you mean it should respect inheritance?

[09:06] <pasteling> "nothingmuch" at 82.81.247.180 pasted "an AG for pretty printing types" (40 lines, 1.2K) at http://sial.org/pbot/13424

[09:06] <nothingmuch> also yes

[09:06] <nothingmuch> if there is no attr defined on blessed($node) it should iterate Class::ISA::super_path

[09:07] <nothingmuch> i guess that C3 order is a good choice

[09:07] <nothingmuch> anyway, that's why i need threaded attributes

[09:07] <nothingmuch> see free_in and count_in?

[09:07] <nothingmuch> well, admittedly "need" is a strong word

[09:08] <luqui> yeah, you can always make a threaded attribute with a inherited+synthesized attribute of different names

[09:08] <luqui> threaded is just a pun making two different attributes have the same name

[09:08] <nothingmuch> but it's tres cool ;-)

[09:08] <nothingmuch> anyway, that grammar is dying, and i can't figure out why

[09:09] <nothingmuch> Nonlinear attribute: you have two or more ways to assign a value

[09:09] <nothingmuch> to the attribute 'layout' near grammar line 11.

[09:09] <nothingmuch> but i have no attrs that are nonlinear, IMHO

[09:09] <nothingmuch> this is about variable::free: layout($$) = { ... }

[09:09] <nothingmuch> anyway, new tests submitted to L::AG

[09:09] <nothingmuch> you're welcome to mark t/threaded.t as TODO ;-)

[09:09] <luqui> yeah, I saw that, thanks

[09:10] <nothingmuch> wait... conflicts

[09:10] * luqui did a little renaming around, and then unrenaming, and yucks

[09:10] <luqui> I don't think I'm going to use Kasten's ordered approach.  Lazy is just too much easier.

[09:10] <luqui> er, Kastens's

[09:11] <nothingmuch> how do you get 3-way merge with svk?

[09:11] <luqui> ??

[09:11] <nothingmuch> i want the conflict to go to FileMerge.app

[09:11] <nothingmuch> i don't know what command I want =)

[09:11] <luqui> nothingmuch, this grammar is dying with the CPAN version of L::AG (ie. you haven't made any changes?)

[09:11] <nothingmuch> this is with the svn version, but i have not edit the .pm file

[09:11] <nothingmuch> s/have/did/

[09:12] <luqui> hmm okay.  That might be a bug.

[09:12] <luqui> let me look at it

[09:12] <nothingmuch> okay

[09:12] <luqui> even though I'm about to rewrite the .pm

[09:13] <luqui> oh, do you have a file with a test for this grammar?

[09:13] <nothingmuch> not yet

[09:13] <nothingmuch> i'm trying to get my earlier tests in

[09:13] <nothingmuch> struggling with svk

[09:13] <luqui> no, I mean, you said the grammar was dying

[09:13] <luqui> on what input tree?

[09:14] <pasteling> "nothingmuch" at 82.81.247.180 pasted "the input tree" (10 lines, 430B) at http://sial.org/pbot/13425

[09:15] <nothingmuch> oh shit, i think i get it

[09:15] * nothingmuch confused himself in the constructors

[09:16] <pasteling> "nothingmuch" at 82.81.247.180 pasted "the correct input tree, generates same error" (9 lines, 398B) at http://sial.org/pbot/13426

[09:16] <pasteling> "scook0" at 220.253.106.5 pasted "What the heck is wrong with my test?" (52 lines, 1.1K) at http://sial.org/pbot/13427

[09:22] <nothingmuch> luqui: any idea what's going on?

[09:22] <luqui> hmmm...

[09:22] <nothingmuch> i'll post the full script

[09:22] <luqui> well, it is installing layout of that thing twice

[09:22] <luqui> I'm trying to figure out why

[09:23] <pasteling> "nothingmuch" at 82.81.247.180 pasted "type pretty printer & misc" (193 lines, 3.5K) at http://sial.org/pbot/13428

[09:23] <nothingmuch> just run perl on that thing

[09:24] <luqui> are you using "root" as the meta root, or as type::root?

[09:24] <nothingmuch> no, type::root

[09:25] <luqui> okay good

[09:25] <nothingmuch> shouldn't that be ROOT: ?

[09:25] <nothingmuch> (for pseudo-root)

[09:25] <luqui> yeah it should

[09:25] <luqui> in other words, you did it right for what you were trying to do

[09:25] * luqui just realized that ROOT and -prefix don't mix

[09:28] <luqui> huh, the root is being scanned twice

[09:28] <luqui> interesting, that shouldn't happen

[09:28] <luqui> (and would explain the error)

[09:28] <nothingmuch> hrmm

[09:29] * luqui is on the trail though

[09:29] <nothingmuch> oh, also have a look at t/errors.t later

[09:29] <nothingmuch> it tests for current behavior

[09:29] <nothingmuch> i'm not 100% sure it's the right behavior

[09:30] <luqui> got it

[09:30] <luqui> count_in is an inherited attribute

[09:30] <nothingmuch> and also, in basic.t one test tries to assign the same attr to ROOT and Foo, where Foo is the root anyway

[09:30] <luqui> but it doesn't have anybody to inherit it from

[09:30] <nothingmuch> right now ROOT overrides

[09:30] <nothingmuch> oh crap

[09:30] <nothingmuch> =(

[09:31] <luqui> (the new structure with declared unions ought to make finding errors like that easier)

[09:31] <nothingmuch> root: count_in($.type) = { 0 } is not helping =(

[09:31] <luqui> do you have a root node in your structure?

[09:32] <nothingmuch> $pretty->apply(bless { type => $self }, "type::root")->layout;

[09:32] <nothingmuch> }

[09:32] * luqui tries

[09:32] <luqui> uh, type => $self?

[09:32] <nothingmuch> yep

[09:32] <luqui> what's $self?

[09:32] <nothingmuch> type::operator::arrow->new(type::variable::free->new, type::variable::free->new);

[09:32] <luqui> oh, I see

[09:33] <nothingmuch> pseudoroot is not good enough for root: layout($$), right?

[09:33] <luqui> I think a real root was a good choice in this case

[09:34] <nothingmuch> counting works

[09:34] <nothingmuch> if i root: cont_out($$) = { count_out($.type) } then I get back 2

[09:35] <nothingmuch> free_out doesn't work

[09:35] <nothingmuch> i'll investigate

[09:36] <luqui> yikes.  need much more error checking code

[09:36] <luqui> free_in is an inherited attribute

[09:36] <nothingmuch> right

[09:36] <luqui> but operator::binary does not set free_in of its child

[09:36] <luqui> ren

[09:36] <nothingmuch> right...

[09:37] <luqui> but it should

[09:37] <nothingmuch> fixing

[09:37] * luqui wants automatic attr generation now

[09:37] <luqui> I'll start the rewrite

[09:38] <nothingmuch> yay!

[09:38] <luqui> works?

[09:38] <nothingmuch> luqui++

[09:38] <nothingmuch> not yet, i'm rewriting the stuff

[09:38] <nothingmuch> yay for the rewrite

[09:38] <luqui> ah

[09:39] * luqui wishes he didn't have homework

[09:40] <nothingmuch> woot!

[09:40] <nothingmuch> #          got: '∀ω. ω → α'

[09:40] <nothingmuch> #     expected: '∀α. ∀β. α → β'

[09:40] <nothingmuch> not *exactly* it, but the AG side is working =)

[09:41] <luqui> oohh pretty

[09:41] <nothingmuch> blammo!

[09:41] <nothingmuch> ok 1

[09:42] <nothingmuch> i have an elegance issue

[09:42] * dada smells APL

[09:42] <nothingmuch> operator::binary: free_in($.left) = { Set::Object->new }

[09:42] <nothingmuch> operator::binary: free_in($.right) = { Set::Object->new }

[09:42] <nothingmuch> operator::binary: free_out($$) = { free_out($.left) + free_in($$) + free_out($.right) }

[09:42] <nothingmuch> or

[09:42] <nothingmuch> or thread the free stuff

[09:42] <nothingmuch> so that free_in($.left) = { free_in($$) }

[09:42] <nothingmuch> free_in($.right) = { free_out($.left) }

[09:42] <nothingmuch> free_out($$) = { free_out($.right) }

[09:43] <nothingmuch> which is cooler?

[09:43] <luqui> well the latter doesn't do any set operations at all

[09:43] <nothingmuch> right

[09:44] <luqui> so I would probably like that better, as it's more general

[09:44] <luqui> without understanding your problem very well, of course

[09:44] <nothingmuch> hmm

[09:44] <nothingmuch> right

[09:44] <nothingmuch> looking up all the free variables

[09:44] <nothingmuch> luqui++; # thanks

[09:46] <pasteling> "nothingmuch" at 82.81.247.180 pasted "working test script" (207 lines, 3.9K) at http://sial.org/pbot/13429

[09:46] * luqui ponders "multi attribute"

[09:46] <nothingmuch> luqui: don't worry about backwards compatibility

[09:46] * luqui won't

[09:46] <nothingmuch> i'll be glad to upgrade my code

[09:47] <luqui> in particular, I'm going to start requiring data structure declarations, I think

[09:47] <nothingmuch> but also try to make it at least semi efficient

[09:47] <nothingmuch> since now that I've practiced a little with the pretty printing, i'm going to try to represent type inferrence in AGs

[09:47] <luqui> interesting

[09:47] <pasteling> "nothingmuch" at 82.81.247.180 pasted "working test script" (207 lines, 3.9K) at http://sial.org/pbot/13430

[09:47] <nothingmuch> shit

[09:47] <nothingmuch> sorry everyone

[09:50] <nothingmuch> oi vey

[09:50] <nothingmuch> {

[09:50] <nothingmuch> 	my $type = type::operator::arrow->new(

[09:50] <nothingmuch> 		my $a = type::variable::free->new,

[09:50] <nothingmuch> 		my $b = type::variable::free->new,

[09:50] <nothingmuch> 	);

[09:50] <nothingmuch> 	$a->instantiate($b);

[09:51] <nothingmuch> 	is($type->stringify, "∀α. α → α");

[09:51] <nothingmuch> }

[09:51] <nothingmuch> this is problematic since $b exists both under $type and under $a now

[09:51] <nothingmuch> Nonlinear attribute: you have two or more ways to assign a value

[09:51] <nothingmuch> to the attribute 'free_in' near grammar line 27.

[09:52] <nothingmuch> is there any way to deal with one thing appearing in several places in an AG?

[09:52] <luqui> "one thing appearing in several places"?

[09:52] <luqui> what kind of thing

[09:52] <nothingmuch> look at 'sub instantiate'

[09:53] <nothingmuch> it assigns $b to $a.instance

[09:53] <nothingmuch> and reblesses $a to type::variable::instantiated

[09:53] <luqui> okay

[09:54] <luqui> ...

[09:55] <nothingmuch> the AG module tries to apply free_in($b) once from variable::instantiated and once from type::operator::binary

[09:56] <luqui> oic...

[09:56] <luqui> uh, reblessing is not supported :-)

[09:56] <luqui> (however, one could fix it)

[09:56] <luqui> by instead of using overload::StrVal everywhere, use refaddr or whatever from Scalar::Util

[09:57] <nothingmuch> luqui: reblessing happens wayb the AG gets to eat it

[09:57] <rafl_> luqui: I prepared a Debian package for Class::MultiMethods::Pure (it will be the first one that I'll upload with the newly created @debian.org account I'll get that week, btw. :-) But I still need a nice text for the description. You said you could provide one to me once..

[09:57] <luqui> oh

[09:57] <nothingmuch> forget the reblessing

[09:57] <nothingmuch> it sets $a.instance to $b.

[09:58] <luqui> rafl_, oh, yeah, but that requires work

[09:58] * luqui is a lazy bastard

[09:58] <luqui> bug me on email and I'll email you one back

[09:59] * nothingmuch asked about this on #haskell

[09:59] <nothingmuch> and figured out that true lazy evaluation of AGs should eat this

[10:00] <luqui> so what's going on?

[10:00] <nothingmuch> what do you mean/

[10:00] <luqui> I never understood your question

[10:01] <nothingmuch> well

[10:01] <nothingmuch> we're constructing a type, right?

[10:01] <nothingmuch> in a lambda

[10:01] <luqui> mkay

[10:01] <nothingmuch> fun: type($$) = { type::operator::arrow->new( $a, $b ) }

[10:01] <nothingmuch> $a and $b are two free type variables

[10:01] <nothingmuch> in the env, the param is bound to $a

[10:02] <nothingmuch> so whenever the param is used, $a is used

[10:02] <nothingmuch> now, at some point a deeper operation is going to unify $a with something else

[10:02] <nothingmuch> e.g. type::operator::named->new("int")

[10:02] <nothingmuch> it does this by instantiating $a to be the new type

[10:02] <luqui> by putting it in the env right?

[10:03] <nothingmuch> in e.g. λx. x

[10:03] <nothingmuch> $a is unified to $b

[10:03] <nothingmuch> to yield the type a -> a

[10:03] <nothingmuch> forall a. a -> a

[10:03] <luqui> alright

[10:03] <nothingmuch> 	my $type = type::operator::arrow->new(

[10:03] <nothingmuch> 		my $a = type::variable::free->new,

[10:03] <nothingmuch> 		my $b = type::variable::free->new,

[10:03] <nothingmuch> 	);

[10:03] <nothingmuch> 	$a->instantiate($b);

[10:03] <nothingmuch> this is the operation i'm trying to do 

[10:03] <nothingmuch> is($type->stringify, "∀α. α → α");

[10:03] <nothingmuch> this is the result

[10:04] <nothingmuch> variable::instantiated: free_in($.instance) = { free_in($$) }

[10:04] <nothingmuch> that is where it blows up

[10:04] <nothingmuch> since free_in($b) is set by that

[10:04] <nothingmuch> but also by this:

[10:04] <nothingmuch> operator::binary: free_in($.right) = { free_out($.left) }

[10:04] <luqui> how is that possible?

[10:05] <luqui> is this a dag?

[10:05] <svnbot6> r7232 | iblech++ | * t/operators/operator_overloading.t: s/sub/multi/ in one case

[10:05] <svnbot6> r7232 | iblech++ | * t/packages/{symbols,reflection}.t: =begin obsolete'd the tests,

[10:05] <svnbot6> r7232 | iblech++ |   see thread "Packages, Modules and Classes" on p6l started by Stevan:

[10:05] <svnbot6> r7232 | iblech++ |   http://www.nntp.perl.org/group/perl.perl6.language/23019

[10:05] <svnbot6> r7232 | iblech++ | * t/packages/{autoload,scope,import,require_and_use}.t:

[10:05] <svnbot6> r7232 | iblech++ |   skip all tests under PIL2JS and PIL-Run, as the tests need eval().

[10:05] <luqui> (me is still a little lost, so I'll ask a bunch of questions)

[10:05] <luqui> interesting grammar, luqui

[10:05] <nothingmuch> you're going to ask a bunch of questions, and you want to have them answered immediately?

[10:06] <nothingmuch> the reason it's possible:

[10:06] <nothingmuch> $type = (a -> b)

[10:06] <nothingmuch> $a.instantiate($b);

[10:06] <nothingmuch> $type = ($a($b) -> $b)

[10:06] <nothingmuch> $type = ($b -> $b)

[10:06] <nothingmuch> so far it's a DAG

[10:06] <luqui> that's why

[10:07] <luqui> dag not supported.  If you can think of a way where an AG would make sense on a dag

[10:07] <luqui> I'll try to do it

[10:07] <luqui> but you have two ways to set an attribute of a single node.  Which do you pick?

[10:07] <nothingmuch> if it's evaluated lazliy, the attr of $b is once this, and once that

[10:07] <nothingmuch> depending on it's caller

[10:08] <luqui> you mean it takes on two values over the course of the evaluation?

[10:08] <nothingmuch> hmm... yes

[10:08] <nothingmuch> dynamically scoped

[10:08] <nothingmuch> but that's hard

[10:08] <luqui> that doesn't sound like a well-defined attribute to me

[10:09] <nothingmuch> hmm

[10:09] <nothingmuch> i think i'm slightly screwed

[10:09] <nothingmuch> i'll seperate the phase so that the check for frees and allocation of symbols happens before the AG pass

[10:09] <luqui> you're not mutating anything over the course of the evaluation though, are you?

[10:10] <nothingmuch> no, i'm not

[10:10] <luqui> hmm.  yeah, it might be that what you're trying to do is not in AG's domain

[10:10] <nothingmuch> *sob*

[10:11] <nothingmuch> it was such a pretty grammar

[10:11] <luqui> on the other hand, it could be, and your brain is being foggy about exactly what an attribute should be

[10:11] <luqui> but I don't really grok the problem... again.

[10:12] <nothingmuch> do you know how milner type inferrence works?

[10:12] <luqui> not in detail

[10:12] <nothingmuch> okay

[10:12] <nothingmuch> essentially going into the AST you allocate type variables, which are free

[10:12] <nothingmuch> you bind type variables to identifiers

[10:13] <nothingmuch> going out of the recursion you unify stuff

[10:14] <luqui> by building a "substitution object", right?

[10:14] <nothingmuch> "substitution object"?

[10:14] <luqui> a map from variables to types

[10:14] <nothingmuch> hmm

[10:14] <nothingmuch> i went slightly more OO

[10:14] <nothingmuch> yes

[10:14] <nothingmuch> but the map is embedded in the vars

[10:15] <nothingmuch> so each var is either free or instantiated

[10:15] <nothingmuch> and it can be instantiated to point at another free var

[10:16] <luqui> okay, fair enough

[10:16] <luqui> you want to do all this inside an AG?

[10:16] <nothingmuch> this part can be in AG

[10:16] <nothingmuch> because the AG that infers is not touching the types

[10:16] <nothingmuch> i

[10:17] <nothingmuch> the AG that comes later, to print the types cannot work with the DAG that is the output of the type inferring AG

[10:17] <luqui> ahh

[10:17] <luqui> yeah, you'd have to convolve it into a tree

[10:17] <nothingmuch> yep

[10:17] <nothingmuch> i'll just do a single pass traversal first

[10:18] <nothingmuch> cna you traverse a DAG with synthesized attrs only?

[10:18] <nothingmuch> no, that doesn't make sense either

[10:18] <luqui> well, it sorta does

[10:19] <luqui> but it would be tough not to use any inherited attributes anywhere

[10:19] <nothingmuch> only for relative calls though

[10:19] <nothingmuch> root: layout($$) = {

[10:19] <nothingmuch> 	join(" ",

[10:19] <nothingmuch> 		(map { "?${_}." } sort map { layout($_) } free_out($.type)->members ),

[10:19] <nothingmuch> 		layout($.type),

[10:19] <nothingmuch> 	);

[10:19] <nothingmuch> }

[10:19] <nothingmuch> that will be undefined

[10:19] <nothingmuch> no, it won't, sorry

[10:19] <nothingmuch> but anyway, i'll just make a higher order traversal cmd

[10:21] <svnbot6> r7233 | iblech++ | t/unspecced/chop.t: &chop should be non-destructive, exactly as &chomp is.

[10:21] <svnbot6> r7234 | iblech++ | PIL2JS:

[10:21] <svnbot6> r7234 | iblech++ | * Prelude::JS::Str: Implemented non-destructive chop.

[10:21] <svnbot6> r7234 | iblech++ | * Prelude::JS::Array: Fixed array autovivification ($undef[42] = 23) (two-char patch).

[10:21] <nothingmuch> frank zappa is sick

[10:22] <nothingmuch> http://www.lyricsfreak.com/f/frank-zappa/56813.html

[10:22] <luqui> I hope he gets well soon

[10:22] <nothingmuch> i think it's way too late

[10:23] * luqui is frightened by those lyric

[10:23] <luqui> s

[10:26] <luqui> I need to source filter attributes now

[10:27] <luqui> what would be a good syntax?

[10:27] <nothingmuch> ?

[10:27] <luqui> Node: SOMESYNTAX $.foo = { SOMESYNTAX $$ }

[10:28] <luqui> it needs to be recognizable, so I can turn it into, eg. $parent->{'child:attr'}->()

[10:28] <nothingmuch> what's bad with the function call interface?

[10:28] <nothingmuch> eep

[10:28] <luqui> it doesn't work with the new algorithm

[10:28] <nothingmuch> ah

[10:28] <nothingmuch> i kinda wished for $$.attr

[10:28] <luqui> yeah, and I guess it only makes sense anymore to do it on direct children

[10:28] <luqui> then we could compute deps to

[10:28] <luqui> *too

[10:28] <luqui> so we have $$.attr and $.left.attr

[10:29] <luqui> that should do it

[10:29] <nothingmuch> yep

[10:29] <nothingmuch> and anything that isn't an attr is a method call / hash key?

[10:29] <luqui> error?

[10:29] <nothingmuch> oh, wait

[10:29] <nothingmuch> yes, i see

[10:29] <nothingmuch> $$.attr vs $.key

[10:29] <luqui> right

[10:29] <nothingmuch> what about $.left.right.attr ?

[10:30] <luqui> illegal

[10:30] <nothingmuch> okay

[10:32] <svnbot6> r7235 | iblech++ | PIL2JS: Prelude::JS::Array: &push and &unshift autovivificate undefined vars

[10:32] <svnbot6> r7235 | iblech++ | now, too (this means "my $arrayref; push $arrayref, 42" works now and

[10:32] <svnbot6> r7235 | iblech++ | t/var/autovivification.t passes 19/20).

[10:35] * nothingmuch has a half picture of what AGs could look like as a true language feature in perl 6

[10:35] <luqui> written or mental?

[10:35] <nothingmuch> they are just methods

[10:35] <nothingmuch> both

[10:35] <nothingmuch> not syntax

[10:35] <nothingmuch> but structuure

[10:35] <nothingmuch> usually they are in a role tailored for a class

[10:35] <nothingmuch> but that role is not integrated

[10:36] <nothingmuch> instead you do a runtime mixin to get the effect of apply

[10:36] <nothingmuch> that way you can use grammars with conflicting namespaces on the same object

[10:36] <nothingmuch> but also use them statically to define a class

[10:37] <nothingmuch> attribute resolution within the role uses itself in a fully qualified manner before method resolution

[10:37] <svnbot6> r7236 | iblech++ | Pugs.Prim: &chop is now non-destructive (&chomp is non-destructive, too -- consistency).

[10:37] <luqui> you should probably write something up

[10:37] <nothingmuch> so when it is applied to root object, it will apply itself as a role to all the children implicitly

[10:37] <nothingmuch> (i'm still brainstorming)

[10:37] <luqui> also see: http://svn.luqui.org/svn/misc/luke/work/code/perl/attrgrammar.pl

[10:38] <luqui> for a reasonable implementation strategy

[10:38] <nothingmuch> i haven't read the guts yet

[10:38] <nothingmuch> so i can't diff

[10:38] <nothingmuch> please explain it a bit

[10:38] <luqui> which one?

[10:38] <nothingmuch> the reasonable impl strategy

[10:39] <nothingmuch> visit creates all the possible attrs as thunks, right?

[10:39] <luqui> you just do a one-pass traversal on the tree (using the "visit" method in this example)

[10:39] <luqui> nothingmuch, yeah, you got it.  that's about it

[10:39] <nothingmuch> what is t() constructing?

[10:39] <luqui> that's just debug code

[10:40] <luqui> (defined at top)

[10:40] <nothingmuch> ah

[10:40] <nothingmuch> oh, i see

[10:40] <nothingmuch> you should have used Devel::STDERR::Indent ;-)

[10:40] <luqui> heh, yeah, I guess so :-)

[10:41] <luqui> hmm, how would you like to see attrs declared?

[10:41] <luqui> UUAG style (that always bothered me a bit)

[10:41] <nothingmuch> same syntax as they're called

[10:41] <nothingmuch> yes, me too

[10:41] <nothingmuch> foo: $$.attr = { ... }

[10:41] <nothingmuch> foo: $.child.attr = { } # inherited

[10:41] <luqui> hmm.. I suppose we could just construct on the fly

[10:42] <luqui> no declaration then

[10:42] <svnbot6> r7237 | iblech++ | * t/general/basic.t: unEVAL, skipped the eval test under PIL2JS and PIL-Run,

[10:42] <svnbot6> r7237 | iblech++ |   and moved the MMD test to the end of the file.

[10:42] <svnbot6> r7237 | iblech++ | * t/general/config.t: $*OS eq "browser" is ok.

[10:42] <nothingmuch> ?

[10:42] <luqui> defining it declares it, type-inference-style

[10:42] <nothingmuch> oh, i see

[10:42] <luqui> ("can't use attribute as both synthesized and inherited at grammar line...")

[10:42] <nothingmuch> why do you hate threaded attrs?

[10:43] <luqui> because it's a pun

[10:43] <luqui> you're really defining two different attributes

[10:43] <nothingmuch> in that case, do you think a macro-ish approach to defining threaded attrs could work/

[10:43] <luqui> I'd like to find a way to define a threaded attribute cleanly without punning

[10:44] <luqui> I mostly hate them because of how confused I was when I saw this in UUAG:

[10:44] <luqui> @lhs.number = @lhs.number + 1

[10:44] <nothingmuch> $$.number = $$.number + 1 is a bit clearer

[10:45] <luqui> uh, no

[10:45] <luqui> it's precisely as unclear.  this is functional, damnit!  $$.number is $$.number!

[10:45] <nothingmuch> it feels like OO to me

[10:45] <nothingmuch> okay okay =)

[10:45] <luqui> :-)

[10:46] <nothingmuch> the rule for this is pretty simple though, isn't it/

[10:46] <nothingmuch> ?

[10:46] <nothingmuch> the real .number is the synthesized one

[10:46] <nothingmuch> and any calls to it from within it's body goes to the inherited one

[10:46] <luqui> that's the rule?

[10:46] <nothingmuch> and conflicting inherited ones get name-mangled

[10:46] <luqui> yeah, I guess so.

[10:47] <luqui> I'd like to search for a better solution for a little while though

[10:47] <luqui> since it's macroey and doesn't really require any magic on the part of the core, I can put it off

[10:47] <nothingmuch> what i would really like is to be able to be more generic

[10:48] <nothingmuch> i wouldn't mount lack of threaded as a convenience if i could write

[10:48] <nothingmuch> attr_out($$) = { attr_out($.child) }

[10:48] <nothingmuch> and attr_in($.child) = { attr_in($$) }

[10:48] <nothingmuch> only once

[10:48] <nothingmuch> and have $.child be some sort of fmap

[10:48] <luqui> elaborate

[10:48] <nothingmuch> implemented with unordered (or order undefined) fold

[10:49] <nothingmuch> so that i could either cons the thing up to get a map

[10:49] <nothingmuch> or I could aggregate in the fold it to unify the attr into a scalar

[10:50] <luqui> so the attr_in magic, afaict, is planned

[10:50] <luqui> you're saying that $.child represents more than one child?

[10:50] <nothingmuch> no, that syntax is crazy

[10:50] <nothingmuch> but I would like to be able to define aggregate attrs without enumerating all my children

[10:50] <nothingmuch> especially for n-ary trees

[10:51] <nothingmuch> since map { attr($_) } @{ children($$) }

[10:51] <nothingmuch> whill no longer be alloweed

[10:51] <luqui> oh. shit.

[10:51] <luqui> maybe allow @.children

[10:51] <luqui> as long as it is uniformly typed

[10:52] <luqui> hmm, maybe not though

[10:52] <luqui> I don't want to parse $.children[4].attr

[10:53] * luqui wonders what it would take to make it more dynamic

[10:53] * luqui stares at his attrgrammar.pl example

[10:53] <luqui> hmmm

[10:54] <luqui> It might be possible still to allow map { attr($_) } @{ children($$) }

[10:54] <nothingmuch> btw, for all the haskell heads who don't appreciate foldr enough: let mymap f l = foldr ((:) . f) [] l

[10:55] <nothingmuch> mymap (+ 1) [ 1 .. 3 ]

[10:56] <nothingmuch> how is it possible?

[10:56] <nothingmuch> and please allow reduce instead of map, it's more general

[10:56] <luqui> wow

[10:56] <nothingmuch> wow?

[10:56] <luqui> the foldr thingy

[10:56] <nothingmuch> ah

[10:56] <luqui> by "It might be possible still..."

[10:57] <nothingmuch> yes, I like it a lot, after figuring it out a few mins ago =)

[10:57] <luqui> I meant that for arbitrary definitions of map

[10:57] <nothingmuch> okay =)

[10:57] <nothingmuch> how will that work?

[10:57] <luqui> for parents that set inherited attributes

[10:57] <luqui> they just have a thunk hash key that looks like 'attr:Object=HASH(...)'

[10:58] <luqui> and then you look up yourself in your parent's hash

[10:59] <nothingmuch> i don't understand

[10:59] <joao> mymap seems obvious :) haskell is neat :)

[10:59] <nothingmuch> who is yourself?

[10:59] <nothingmuch> the user? the attr def?

[10:59] * luqui doesn't think mymap seems obvious.  but it does seem cool

[10:59] <luqui> the node who is inheriting the attribute

[10:59] <joao> luqui, do you understand foldr function?

[11:00] <nothingmuch> attrs are not really inherited?

[11:00] <luqui> no, they are looked up in the parent

[11:00] <nothingmuch> oh

[11:00] <nothingmuch> so the impl of inheritence is like OO inheritence

[11:00] <nothingmuch> instead of putting the value in the child, it stays in the parent... right?

[11:00] <luqui> joao, I understand it to the degree that I understand the compose operator:  I know what it does, but I have to think about it for a while

[11:01] <luqui> nothingmuch, right

[11:01] <nothingmuch> what is the compose operator?

[11:01] <luqui> (.)

[11:01] <nothingmuch> ah

[11:01] <luqui> so then a definition that uses compose and foldr in the same statement takes a little more while

[11:01] <nothingmuch> simpler form will be 'let my map f l = foldr (\x, xs -> (f x):xs) [] l

[11:02] <luqui> right, that makes sense

[11:02] <broquaint> That's a map() implementation, right, nothingmuch?

[11:02] <nothingmuch> broquaint: yep

[11:02] <luqui> that's one of my complaints with [+] and reduce in p6

[11:02] <joao> i think the other is better :)

[11:03] <luqui> there are two kinds of reduce, and we don't let the user pick

[11:03] <joao> you can even forget that l :)

[11:03] <nothingmuch> joao: ofcourse =)

[11:03] <broquaint> I think, sometimes, Haskell is a little too terse.

[11:03] <nothingmuch> you can also use autocurrying and flip to get rid of f too

[11:03] <nothingmuch> let me try

[11:03] <luqui> joao, the reason that people liked "the other better" is the reason that it took me two months to learn haskell instead of a week

[11:04] <joao> luqui, :)

[11:04] <joao> have you ever seen those catamorphisms diagrams? :)

[11:04] <luqui> uh... catamorphism... rings a bell

[11:04] <joao> after that, foldr (which is a catamorphism on lists) seems nicer

[11:05] <nothingmuch> what's a catamorphism?

[11:05] <nothingmuch> google has no defs

[11:05] <luqui> @pl let mymap f l = foldr ((:) . f) [] l in mymap

[11:06] <luqui> flip foldr [] . ((:) .)

[11:06] <nothingmuch> let mymap = ((flip foldr) []) . ((:) . )

[11:06] <luqui> how very clear

[11:06] <nothingmuch> right

[11:06] <nothingmuch> oh, lambdabot does it? and i worked by hand? how lame!

[11:06] <luqui> :-)

[11:07] <nothingmuch> so what's a catamorphism?

[11:08] <joao> well

[11:08] <joao> a catamoorphism is a function

[11:08] <joao> that operates on an indutive type

[11:08] <joao> and builds some value

[11:09] <joao> this is the most "general" definition I can give

[11:09] <joao> I am searching a paper to show you

[11:09] <joao> http://wiki.di.uminho.pt/wiki/pub/Education/MetodosProgramacaoI0405/iscalc_2.pdf

[11:09] <joao> page 58 :)

[11:09] <nothingmuch> "inductive type" is what I would call an aggregate type?

[11:09] <luqui> recursive

[11:09] <luqui> like a list

[11:09] <nothingmuch> ah

[11:09] <joao> If an aggregate type is a recursive type, yes :)

[11:10] * nothingmuch really needs to take his dad's course

[11:10] <joao> [] -> base ; (:) -> constructor

[11:10] <joao> You can decompose [a] in ([] + a x [a])

[11:10] <joao> meaning: the list is empty OR it is composed by an element (head) followed by another list (tail)

[11:11] <luqui> ahh, x like cartesian product

[11:11] <joao> yes

[11:11] <joao> (a,[a]) :-)

[11:12] <joao> Using diagrams to express catamorphisms is nice to explain recursive pointfree programming :)

[11:12] <nothingmuch> define: decompose

[11:12] <nothingmuch> be able to take it apart recursively?

[11:12] <joao> yes, I think so :)

[11:12] <luqui> he's just saying data List a = [] | a : [a] again

[11:12] <luqui> er, data [a]

[11:13] <nothingmuch> and what is the + saying in that expr?

[11:13] <luqui> union

[11:13] * nothingmuch tries to transpose what he knows about unions and products into this discussion

[11:13] * luqui thinks joao is using ocamlesque notation

[11:14] <nothingmuch> so much to learn, so little brain

[11:14] <joao> luqui, it's the notation I've learned to do pointfree proofs...

[11:14] <joao> luqui, not sure if it derived from ocaml :P

[11:14] <luqui> okay

[11:15] <nothingmuch> what is pointfree?

[11:15] <luqui> it's what you did to mymap

[11:15] <rep> you mean pointless :P

[11:15] <luqui> getting rid of all the names

[11:15] <nothingmuch> ah

[11:15] <joao> The nice thing about this stuff is that you capture the datatype recursion in the catamorphism definition (there is also the anamorphism notion, which is the opposite)

[11:15] <joao> and then.. having a library defining the type and their cata and ana

[11:16] <luqui> this is sounding like category theory

[11:16] <joao> you just define the little pieces (called the gene) that make what you want :)

[11:16] <joao> the recursion is captured in the libraries :)

[11:16] <joao> you haskell code reduces a lot :)

[11:16] <luqui> reminds me of the type analog of fix

[11:17] * nothingmuch thinks he wants to know that business =)

[11:17] <nothingmuch> i have to quit my job and go study already

[11:17] <joao> nothingmuch, I can give some examples someday (not now, sorry)

[11:17] <joao> I'd be happy to show you how that stuff works :)

[11:17] <luqui> joao, please do someday

[11:17] <nothingmuch> joao: i'll try to remember to ask you... thanks =)

[11:17] <joao> I will, thanks for letting me do it :)

[11:18] <nothingmuch> luqui: whatever that stuff is, we want it in perl 6, right?

[11:18] <nothingmuch> ;-)

[11:18] * joao laughs

[11:19] <luqui> of course

[11:19] <joao> I'll eat something, be back later :)

[11:19] <nothingmuch> ciao joao, and thanks again =)

[11:19] <luqui> perl 6 is *the* fat language: everything that is in anything anywhere is in perl 6

[11:19] <nothingmuch> s/is/will be/

[11:19] <luqui> mathematically: perl6 = Union_(x in anything){ x }

[11:20] <nothingmuch> where x is whitespace and anything is python?

[11:20] <luqui> uh

[11:20] <luqui> perl6 = Union_(x is a feature of anything) { x }

[11:20] <joao> but without cholesterol :)))

[11:22] <luqui> and the stuff that is unique to perl 6 comes from the fact that perl6 (in) anything.

[11:22] <nothingmuch> i think you want [ x | <- x in anything, f(x) > t ] where f x = (flip foldr [] . ((:) . )) (likes x) @larry

[11:22] <nothingmuch> oh wait

[11:23] <nothingmuch> no, you actaully want a real reduction, not a map ;-)

[11:23] <luqui> haha

[11:23] <nothingmuch> btw, wrt foldr - i learned to appreciate from the why ags matter article

[11:23] <luqui> really?

[11:23] <nothingmuch> so you should have done your homework better =)

[11:23] <nothingmuch> yes, i thought that the def of diff *without* the AGs was really superb

[11:24] <nothingmuch> not as maintainable or clear as an AG

[11:24] <nothingmuch> but much more impressive ;-)

[11:24] <luqui> in listing two?

[11:24] <nothingmuch> yes

[11:24] * nothingmuch expanded it on paper

[11:25] <nothingmuch> and then realized WTF was going on

[11:25] <luqui> see, that's why I haven't switched to haskell yet.  Programming is the middle ground between literature and mathematics

[11:25] <nothingmuch> ?

[11:25] <luqui> Haskell is much further on the right than most programming

[11:26] <luqui> you're supposed to be able to "read" code

[11:26] <nothingmuch> yes, but the moment you bring yourself to that space, you can read almost as well

[11:26] <nothingmuch> but write books that are black with ink

[11:27] * luqui is too tired to deal with metaphor right now

[11:27] <luqui> :-)

[11:27] <nothingmuch> okay

[11:27] <nothingmuch> basically: once you get used to haskell, you can still read code

[11:27] <nothingmuch> less people in the world can

[11:27] <luqui> that's sorta true

[11:27] <nothingmuch> but the code you are now used to handling is much more dense

[11:28] <nothingmuch> because most of the things that make your mental stack overflow become idiomatic the moment you understand them once.

[11:28] <luqui> exactly, it's much further on the right, i.e. much more like mathematics

[11:28] <luqui> nothingmuch, good point

[11:28] <nothingmuch> i don't want perl 6 to be this way though ;-)

[11:28] <luqui> exactly

[11:28] <nothingmuch> i think haskell, despite all it's advantages, is not accessible to enough people

[11:29] <luqui> well, haskell forces you to rewire your brain

[11:29] * nothingmuch has a friend he would like to experiment on

[11:29] <nothingmuch> the friend is just learning to program

[11:29] <luqui> something that perl 6 is trying really hard not to do (but it's hard, because you'll have to rewire *more* to read code)

[11:30] <nothingmuch> and the idea of teaching him haskell from day one crossed my mind

[11:30] <nothingmuch> it will help me improve

[11:30] <luqui> that would be a very interesting experiment

[11:30] <nothingmuch> the problem is that his army duties have increased recently

[11:30] <nothingmuch> so far we've gotten around to the meaning of structure and binding

[11:30] <nothingmuch> he coded up a bottles of beer program

[11:31] <nothingmuch> but we haven't done anything but get drunk together since

[11:31] <luqui> haha

[11:33] <rep> hehe

[11:34] * nothingmuch suddenly realized that there is more than met his brain, but seemed to have met your eyes in his last two sentances ;-)

[11:36] <masak> :)

[11:36] <nothingmuch> i need a break, i'm being silly instead of writing code

[11:38] <svnbot6> r7238 | iblech++ | * t/builtins/{arrays,hashes}/slice.t: Added tests for @array[1,2,3] :=

[11:38] <svnbot6> r7238 | iblech++ |   @array_containing_less_than_3_items;

[11:38] <svnbot6> r7238 | iblech++ | * PIL2JS: Prelude::JS::Array, Prelude::JS::Hash:

[11:38] <svnbot6> r7238 | iblech++ |   Implemented binding of array and hash slices. This means

[11:38] <svnbot6> r7238 | iblech++ |   t/builtins/{arrays,hashes}/slice.t pass 99% now.

[11:38] <svnbot6> r7238 | iblech++ | * t/builtins/undef.t: Added a try {...} around a (in PIL2JS) dieing test.

[12:03] <luqui> nothingmuch, there was an AG discussion on PerlMonks

[12:03] <luqui> ?

[12:04] * nothingmuch returns

[12:04] <nothingmuch> where?

[12:05] <luqui>   r8709@syeeda:  nothingmuch | 2005-10-01 14:52:23 +0200  renamed 'avg' to 'global_avg' to make things clearer (this confused Corion on perlmonks)

[12:05] <nothingmuch> ah

[12:05] <nothingmuch> i talked to Corion about this in pm chat

[12:05] <nothingmuch> and he said 'i don't fully grok that yet'

[12:05] <nothingmuch> so we went over it

[12:05] <nothingmuch> and then he said 'well, i don't see how avg can be inherited, that just doesn't make sense'

[12:06] <luqui> I see

[12:06] <nothingmuch> so i said 'oh, that's because it's not really the average, it's the global average'

[12:06] <nothingmuch> so yes, but not a posted discussion

[12:08] <nothingmuch> arf!

[12:08] <nothingmuch> i lost my copy of the hair soundtrack!

[12:09] * nothingmuch wonders how such idiocy happenned

[12:28] *** Aankh|Clone is now known as Aankhen``

[12:30] * luqui sent off theory.pod to @Larry

[12:31] <nothingmuch> woot

[12:31] * nothingmuch really hopes it'll be accepted

[12:31] <nothingmuch> btw, i was meaning to implement the tuple type at some point

[12:31] <nothingmuch> and type infer it

[12:31] <nothingmuch> but i need to type infer regular pairs first ;-)

[12:32] <luqui> oh you mean the arg tuple...

[12:32] <luqui> that could be a challenge

[12:32] * luqui hopes it isn't though

[12:32] <nothingmuch> i don't think it's too hard

[12:33] <nothingmuch> it's just a concrete data type that nests

[12:33] <nothingmuch> err, abstract

[12:33] <nothingmuch> but can be implemented concretely

[12:33] <nothingmuch> and happens to be manipulated at compile time as well as runtime.

[12:37] <luqui> well, I have to be off to school now

[12:37] <nothingmuch> http://a.as-us.falkag.net/dat/bgf/200410/13/1085.gif (Add a FREE SpyWare program to your desktop)

[12:37] <luqui> heh

[12:38] <luqui> &

[12:38] <nothingmuch> ciao

[13:20] <svnbot6> r7239 | iblech++ | PIL2JS: Prelude::JS::Array: Sped up the new autovivification-capable &push and

[13:20] <svnbot6> r7239 | iblech++ | &unshift by 88% by porting the necessary if-clause to JS. As &push is used very

[13:20] <svnbot6> r7239 | iblech++ | often (for, map, etc. all use it), this should speed up make smoke by 10 min or so.

[13:50] <nothingmuch> http://en.wikipedia.org/wiki/Wayne_McLaren

[13:50] <nothingmuch> cute

[14:19] <joao> nothingmuch, but people continue to smoke...

[14:19] <nothingmuch> i smoke too, occasionally

[14:19] <nothingmuch> i just think it's funny =)

[14:19] <nothingmuch> not so much the actual cancer stuff

[14:20] <joao> I don't mind if others want to destroy their health, actually. I'm just bothered when they don't respect mine..

[14:20] <svnbot6> r7240 | iblech++ | * t/builtins/perl.t: Added tests for "\t".perl, "\n".perl, etc.

[14:20] <svnbot6> r7240 | iblech++ | * perl5/Perl6-Value/lib/Perl6/Value.pm: Fixed the stringification

[14:20] <svnbot6> r7240 | iblech++ |   ("$key\t$value") and .perlification of pairs ("($key.perl() =>

[14:20] <svnbot6> r7240 | iblech++ |   $value.perl())").

[14:20] <nothingmuch> but the fact that an icon of maniliness (implying stamina, power, etc), that caused people to consume cigarettes so directly meets such an end

[14:21] <nothingmuch> and i also find it ironic that while advertisement makes it easy for people to start smoking, you don't see it stopping anyone (my bet is the budget difference is the reason for this)

[14:22] <joao> Probably

[14:22] <nothingmuch> as for your health - smoking is like peeing in a swimming pool... I totally agree, and people should ask permission before smoking next to anyone

[14:23] <nothingmuch> as for mine - i'm not too worried - i smoke around once a week

[14:23] <joao> Well, I read somewhere that being a passive smoker gives you more 40% possibilities of having coronary issues 

[14:23] <joao> I'm not worried if someone smokes near me; I just think it's disrespect

[14:24] <nothingmuch> it is

[14:24] <joao> I'm from Portugal, and believe me, portuguese smokers don't care about others ;)

[14:25] <joao> For instance, in my department I've seen people smoking below the "NO SMOKING" sign

[14:25] <joao> Instead of removing the smokers... they removed the sign! :)

[14:25] <nothingmuch> i thought the trend in europe in the past 20 years was against smoking

[14:26] <nothingmuch> i remmeber that 10 years ago in austria you couldn't walk into a resteraunt without choking

[14:26] <nothingmuch> but nowadays even my aunt's husband quit

[14:29] <joao> It's funny, some days ago, I've seen some old men who want to sue tobacco companies because the companies made them believe that smoking was a "men thing"

[14:29] <joao> Today they need special devices to emit some sounds... it's sad.

[14:30] <nothingmuch> it is

[14:30] <nothingmuch> i think you'll like this: http://www.adbusters.org/spoofads/alcohol/absolutimpotence/

[14:31] <joao> hehe :)

[14:31] <joao> shakespeare was a bright fellow :)

[14:32] <nothingmuch> yup

[14:36] <joao> nothingmuch, where are the list operations defined?

[14:36] <nothingmuch> src/Pugs/Prim.hs or src/perl6/Prelude.pm

[14:36] <svnbot6> r7241 | iblech++ | util/run-smoke.pl: "You may want to submit the report to the public

[14:36] <svnbot6> r7241 | iblech++ | smokeserver: [...]"

[14:37] <Aankhen``> I definitely am worried if people smoke near me.  They are consciously choosing to adversely affect my health through secondhand smoke.  "Disrespectful" is not the word.

[14:37] <joao> I am trying to get into Pugs...

[14:38] <joao> Aankhen``, I agree, byt my english level don't allow me to be more explicit :))

[14:38] <Aankhen``> Heh.

[14:38] <joao> :)

[15:33] <nothingmuch> yowza!

[15:33] <nothingmuch> type inferrence of non generic functions is working

[15:33] <nothingmuch> now to do generics

[15:36] <svnbot6> r7242 | iblech++ | * STATUS: s/PIL2JS passes almost 90%/PIL2JS passes 90%/ :)

[15:36] <svnbot6> r7242 | iblech++ | * pugs::hack: s/a public server/the public smokeserver/

[16:47] <svnbot6> r7243 | iblech++ | * t/builtins/strings/substr.t: substr(..., $replacement) superceded by

[16:47] <svnbot6> r7243 | iblech++ |   substr(...) = $replacement?

[16:47] <svnbot6> r7243 | iblech++ | * PIL2JS: Prelude::JS::Str: &substr:

[16:47] <svnbot6> r7243 | iblech++ |   * Fixed &substr when $start_pos > 0 and $len < 0.

[16:47] <svnbot6> r7243 | iblech++ |   * Made &substr return a readwrite proxy object:

[16:47] <svnbot6> r7243 | iblech++ |       substr($str, $pos, $len) = $replacement;  # works now

[16:47] <svnbot6> r7243 | iblech++ |   * This means substr.t passes 30/31 now, with 6 unexpected successes. :)

[16:57] <joao> what is the equivalent for "apt-get update; apt-get upgrade;" on freebsd? "freebsd-update fetch; freebsd-update install" ?

[16:57] <nothingmuch> uh

[16:57] <nothingmuch> autrijus: ping?

[16:57] <nothingmuch> i guess you ought to try #freebsd

[16:57] <nothingmuch> i don't know about anyone but autrijus who uses freebsd and is active on this channel

[16:57] <nothingmuch> seen autrijus 

[16:57] <jabbot> nothingmuch: autrijus was seen 1 days 22 hours 38 minutes 38 seconds ago

[16:58] <joao> nothingmuch, thanks :)

[16:58] <b6s> /c/c

[16:58] <b6s> oops, sorry

[16:58] <joao> let me see the handbook, first :D

[16:58] <nothingmuch> b6s: that's really unacceptable

[16:59] <nothingmuch> please take this behavior to another channel

[16:59] * joao grins

[17:00] <nothingmuch> OOOF!!! Milner is melting my bRAIN

[17:00] <joao> nothingmuch, Pugs should have a TODO list in its root :-)

[17:00] <nothingmuch> errm. there's too much to do ;-)

[17:00] <nothingmuch> i can spit out some random stuff

[17:00] <nothingmuch> if you want to hack core - look at the smoke reports

[17:00] <nothingmuch> if you want to hack perl 6 - make the smoke report have bigger numbers

[17:01] <nothingmuch> or port/write a module

[17:01] <nothingmuch> otherwise there are some side projects:

[17:01] <nothingmuch> PIL2JS, PIL-RUN, the metamodel, Blondie

[17:01] <nothingmuch> blondie has a side project that I'm working on right now - hindley-milner inferrencing in perl

[17:02] <nothingmuch> with enough hooks to be able to generate type runtime type boxing and unboxing apps instead of type errors where applicable

[17:02] <nothingmuch> when this is done it'll get backported to blondie

[17:02] <nothingmuch> then that will hopefully give us knowlege on how to compile perl 6 statically

[17:03] <nothingmuch> PIL2JS is a PIL compiler that emits JS written in perl 5

[17:03] <nothingmuch> and PIL-RUN is a PIL interpreter written in perl 5

[17:04] <nothingmuch> the metamodel is a spiritual project, and is implemented mostly in perl 5, but is supposed to be ported to haskell

[17:04] <nothingmuch> i hope some of these interest yyou

[17:04] <nothingmuch> and if they don't - you can add a TODO file ;-)

[17:04] <nothingmuch> do you have commit access?

[17:04] <joao> yes, I do

[17:04] <nothingmuch> good

[17:05] <joao> I just need to get into the structure, and then into *something* where I can be useful :)

[17:06] <nothingmuch> would you like a brief explanation of how pugs works?

[17:06] <joao> I don't want to bother or make you guys loose your time... but I'd appreciate if you really want to do it :)

[17:06] * nothingmuch thinks long and hard if he *really* wants to override isa

[17:07] <nothingmuch> joao: well, in the long term I guess by helping you out I could be saving time ;-)

[17:07] <nothingmuch> either way, it's worth the effort

[17:07] <nothingmuch> even if only for the hype

[17:07] <nothingmuch> so ask away

[17:07] <joao> :)

[17:08] <joao> well, what would you say to someone who's looking into the source for the first time? :)

[17:08] <nothingmuch> ermm

[17:09] <nothingmuch> pugs is an interpreter written in haskell

[17:09] <nothingmuch> it parses (src/Pugs/Parser.hs) perl 6 with parsec

[17:09] <nothingmuch> and constructs an AST

[17:09] <nothingmuch> this AST is then reduced

[17:09] * joao nods and pays attention

[17:09] <nothingmuch> the reduction is done along side an Env

[17:09] <nothingmuch> this contains symbols and stuff

[17:10] <nothingmuch> when you compile pugs an interesting thing happens:

[17:10] <nothingmuch> src/perl6/Prelude.pm is compiled

[17:10] <nothingmuch> into haskell

[17:11] <nothingmuch> which is #included into Run.hs

[17:11] <nothingmuch> that is +- the initial env

[17:11] <nothingmuch> this is the big slow down in compiling Run.hs, btw

[17:11] <nothingmuch> the AST itself can be serialized or evaluated by pugs

[17:12] <nothingmuch> the serialization emits PIL (pugs intermediate language)

[17:12] <nothingmuch> and the evaluation emits 'IO ()'

[17:12] <nothingmuch> now your turn to ask more questions

[17:12] <nothingmuch> *now it's

[17:14] <joao> ok, first: you said the AST is reduced along with an Env. I didn't understand what you mean. (The reduction is optimizing code, right? Evaluating certain things to get a smaller AST, etc..)

[17:14] <nothingmuch> no, the reduction is the actual evaluation

[17:14] <nothingmuch> i kind of confused the order

[17:14] <nothingmuch> we have no optimizer yet

[17:14] <joao> oh

[17:14] <nothingmuch> (though a peep hole optimizer for PIL could be a cool project)

[17:14] <joao> ok, so..

[17:15] <joao> the AST is evaluated using an Environment, is that it?

[17:15] * joao smiles

[17:15] <nothingmuch> yes

[17:15] <nothingmuch> the env keeps the symbols and stuff

[17:15] <nothingmuch> i forgot the precise details

[17:15] <joao> where is that env defined? :)

[17:15] <joao> Run.hs ?

[17:15] <nothingmuch> let me see

[17:15] <nothingmuch> i doubt it

[17:15] <nothingmuch> Run.hs is the command line arg processing stuff

[17:16] <nothingmuch> and the code to take source from a file/string/interactive input, and compile/run it

[17:16] <nothingmuch> AST.hs is everything AST

[17:16] <nothingmuch> and AST/Internals.hs contians 'data Env'

[17:16] <joao> ok, another question. Run.hs includes a PreludePC, is it the Prelude.pm compiled into haskell?

[17:16] <nothingmuch> yes

[17:17] <joao> ok, last question for now: when you say "AST serialization" what do you mean?

[17:17] <nothingmuch> the AST can be dumped to a file/stdout

[17:17] <nothingmuch> for example:

[17:17] <joao> oh, ok

[17:18] <joao> No need to explain

[17:18] <nothingmuch> ./pugs -CPIL -e 'say 10'

[17:18] <joao> :)

[17:18] <nothingmuch> just FYI regarding the PIL: it's scheduled to be replaced by PIL2 soon

[17:18] <nothingmuch> but it should be quite similar

[17:18] <joao> hmm

[17:18] <joao> PIL is also used for Parrot Intermediate Language, right?

[17:19] <nothingmuch> as you can see the PIL output contains MkPos etc to give back nice runtime errors

[17:19] <joao> (the acronym)

[17:19] <nothingmuch> (no, that's PIR - which is like assembler, while PIL is like ANF)

[17:19] <nothingmuch> (not that I know what ANF is - excpet the acronym ;-)

[17:19] <joao> Good, PIL is defined as an Haskell DT

[17:20] <nothingmuch> yes

[17:21] <rep> DT?

[17:21] <joao> What is the role of Prelude.pm in this figure? (sorry, I am just trying to put things together)

[17:21] <joao> datatype

[17:21] <nothingmuch> data type

[17:21] <nothingmuch> Prelude.pm is written in perl

[17:21] <nothingmuch> and it's just the basic functions

[17:21] <nothingmuch> that can be implemented in perl

[17:22] <nothingmuch> (src/Pugs/Prim.hs contains the table of perl stuff implemented in haskell)

[17:22] <nothingmuch> it's precompiled for speed

[17:22] <joao> Oh, but you could implement those in haskell too, right?

[17:22] <nothingmuch> instead of being compiled as perl into every program

[17:22] <nothingmuch> whatever's implemented in perl is not implemented in haskell

[17:22] <nothingmuch> if I get my way (which there is no reason that won't happen, because no one said it's a stupid way yet) this distinction won't be there

[17:23] <nothingmuch> the prelude will implement stubs for E.G. IO

[17:23] <nothingmuch> and each runtime will implement whatever prelude functions it wants for efficiency/features/whatever

[17:23] <joao> E.G. ?

[17:23] <nothingmuch> err, e.g.

[17:23] <nothingmuch> you should know, you speek a latin derived lang, don't you?

[17:23] <nothingmuch> for example in english.. i forget the latin

[17:24] <joao> ou

[17:24] <joao> :)

[17:24] <nothingmuch> i remember id es

[17:24] <joao> I thought it was some acronym :)

[17:24] <nothingmuch> exempli gratia

[17:24] <nothingmuch> no, i just had a brain fizz and typed it uppercase by accident ;-)

[17:25] <joao> :)

[17:25] <joao> Ok...

[17:26] <joao> Southen_, it would be nice for me to start by Parser.hs

[17:26] <joao> And then take a look at Run.hs

[17:26] <joao> s/Southen_/So,

[17:26] * nothingmuch tab completes words he shouldn't all the time too

[17:26] <joao> :)

[17:26] <nothingmuch> sure

[17:26] <nothingmuch> you should know:

[17:26] <joao> xchat, here..

[17:26] <nothingmuch> in perl we have begin blocks

[17:27] <nothingmuch> they are executed the moment they are done parsing

[17:27] <joao> uh? you execute a block after parsing it?

[17:27] <nothingmuch> ?eval BEGIN { say("foo") } oiu2165 {}{{{{{ syntax error

[17:27] <evalbot_7243> foo Error:  unexpected "{" expecting block construct, ":", term, term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[17:27] <nothingmuch> as you can see it emitted foo before even parsing the other stuff

[17:28] <nothingmuch> that's the unsafe stsuff in the parser

[17:28] <joao> hmm, what's the reason?

[17:28] <nothingmuch> uh, perl just is that way =)

[17:28] <nothingmuch> it's useful

[17:29] <joao> I'm learning perl6 at the same time I look into Pugs. It will be nice ;)

[17:29] <nothingmuch> =)

[17:29] <joao> The problem is all the stuff I have to end this month

[17:29] <joao> (work stuff)

[17:29] <nothingmuch> work is always a problem ;-)

[17:29] <nothingmuch> http://dev.perl.org/perl6/doc/synopsis.html

[17:29] <nothingmuch> that link contains most of what you need to know about perl 6

[17:30] <joao> yes... I was following the oreilly book

[17:30] <nothingmuch> as a delta against perl 5

[17:30] <nothingmuch> ah

[17:30] * nothingmuch bought it but hasn't read it yet

[17:30] <joao> but I think some little things are already old

[17:30] <nothingmuch> it's probably way out of date by now

[17:30] <nothingmuch> so i'm undermotivated to start reading it now ;-)

[17:30] <joao> :)

[17:31] <joao> why 1-6, 9-13, 29 ?

[17:32] <nothingmuch> 7 is obsolete, i think

[17:32] <nothingmuch> 8 is unwritten

[17:32] <joao> oh , ok

[17:32] <nothingmuch> 13-28 are unwritten (but mostly minor)

[17:32] <nothingmuch> http://dev.perl.org/perl6/doc/apocalypse.html

[17:33] <nothingmuch> these are much bigger, more detailed, and less processed

[17:33] <nothingmuch> as you can see A7 is a placeholder

[17:33] <nothingmuch> and E explains how that behavior will be implemented for backwards compatibility with perl 5 as a standard module

[17:34] <joao> I think I won't read the book. Synopses look better :)

[17:34] <nothingmuch> i think they're easier

[17:34] <nothingmuch> since they encourage interactivity

[17:34] <joao> :) thank you

[17:34] <nothingmuch> you can find syopsis and tests that are interlinked here: http://nothingmuch.woobling.org/pugs_test_status/Synopsis/

[17:35] <nothingmuch> for example operator overloading, in s06 is tested in two placed

[17:35] <nothingmuch> denoted by the small 't' links next to the heading

[17:36] <nothingmuch> the tests can also point to text within the section by matching a regex

[17:36] <nothingmuch> that can help you see how these things look and run

[17:37] <joao> thanks! very cool :)

[17:40] * nothingmuch will go biking soon

[17:41] <nothingmuch> lets see if i can finish the generic function stuff first though

[17:44] <nothingmuch> shit

[17:48] <joao> what?

[17:48] * nothingmuch is not getting along with AGs at the moment

[17:48] <nothingmuch> i have to keep track of which type variables are generic

[17:48] <nothingmuch> and my code to unify the set with a new member is not being invoked at all =(

[18:00] <autrijus> greetings from .fi!

[18:00] <nothingmuch> hola autrijus!

[18:00] <nothingmuch> what is fi?

[18:01] <nothingmuch> finland?

[18:01] <joao> finland?

[18:01] <joao> :)

[18:01] <obra> 'afternoon, autrijus

[18:01] <autrijus> yup :)

[18:01] * autrijus gets ready for the weekly parrot meeting

[18:01] <nothingmuch> autrijus: full milner type inferrencing is almost ready for blondie

[18:02] <autrijus> nothingmuch: excellent. then we can talk about adding the annotation strata on it

[18:02] <nothingmuch> define: strata

[18:02] <nothingmuch> gah: No method found for args (type::operator::nullary=HASH(0x196c5b0) ide=HASH(0x191f440) val=HASH(0x196c550)) at (eval 138) line 20

[18:02] <nothingmuch> i have no 'No method' or 'args' in the file

[18:02] <nothingmuch> i wonder what bit of code is making that ;-)

[18:03] <autrijus> nothingmuch: see Francois Pottier's paper... a sec

[18:03] <nothingmuch> nono

[18:03] <nothingmuch> no more papers today

[18:03] <nothingmuch> my brain is at 98c

[18:03] <autrijus> nothingmuch: search for "From ML Type Inference to Stratified Type Inference"

[18:03] <autrijus> oh ok.

[18:03] <nothingmuch> a little more stress and it'll melt

[18:03] <nothingmuch> let me ask another question:

[18:03] <nothingmuch> what is stratified type inference good for?

[18:04] <autrijus> it's good for propagating user-annotated types first

[18:04] <nothingmuch> ah

[18:04] <autrijus> because you see, in H-M the user doesn't have to annotate any time.

[18:04] <nothingmuch> right

[18:04] <autrijus> but in richer type systems, H-M no longer suffice

[18:04] <nothingmuch> yep

[18:04] <autrijus> one well known example being higher ranked polymorphism

[18:04] <nothingmuch> i learned some things about haskell that I didn't imagine really were

[18:04] <autrijus> so there need to be a systematic way to codify the heuristic

[18:05] <autrijus> of taking user annotations and propagate in "obvious" direction

[18:05] <autrijus> befor you run the M-L

[18:05] <autrijus> thus saving the user from having to type in every type.

[18:05] <nothingmuch> woah

[18:05] <autrijus> it's also known as "local type inference" and "wobbly types"

[18:05] <nothingmuch> hmm

[18:05] <nothingmuch> makes sense

[18:05] <autrijus> but pottier gave it a consistent treatment.

[18:05] * nothingmuch will look at it tomorrow

[18:06] * nothingmuch 's code is actually running again

[18:06] <nothingmuch> #          got: '∀α. α'

[18:06] <nothingmuch> #     expected: 'int'

[18:06] <nothingmuch> bah

[18:06] <nothingmuch> now to find out where i forgot to unify now that we're dealing with generic types

[18:07] * autrijus is playing around with Visual Haskell

[18:07] <nothingmuch> shyte

[18:07] <nothingmuch> if i clone the a in a -> b and b is intantiated to a i need to keep them in synch

[18:07] * nothingmuch will do a deep clone of both

[18:10] <nothingmuch> WOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOTTTTT

[18:11] <nothingmuch> it actually work!

[18:11] <nothingmuch> s

[18:13] <nothingmuch> now to fix the pretty printer

[18:14] <nothingmuch> what's the perl switch to make all handles utf8 by default?

[18:14] <nothingmuch> Test::Builder is not listening to 'BEGIN { binmode STDOUT, ":utf8" }

[18:19] <autrijus> nothingmuch: use encoding 'utf8'

[18:19] <nothingmuch> doesn't help

[18:19] <nothingmuch> the problem is sub _new_fh in T::B

[18:19] <nothingmuch> perl -CDS is somehow not convincing *that* instance of open to use utf8 by default

[18:20] <nothingmuch> oh well

[18:20] <nothingmuch> whatever

[18:20] <nothingmuch> now to splat a DAG into a tree

[18:23] <joao> when I remove a file in  a svn rep, doing svn up restores the file. svk pull shouldn't do the same?

[18:23] <autrijus> joao: no, it's "svk revert" and for directories, "svk revert -R".

[18:23] <autrijus> hey stevan! got questions for you!

[18:23] <autrijus> (but in a meeting now)

[18:23] <joao> autrijus, thanks

[18:26] <Khisanth> nothingmuch: seems to work fine with the binmode

[18:26] <nothingmuch> Khisanth: the problem is that T::B::_new_fh is opening local *FH

[18:26] <nothingmuch> as a dup of STDOUT, i think

[18:26] <nothingmuch> and somehow it's not applying to it

[18:27] <Khisanth> hmm

[18:27] <nothingmuch> Wide character in print at /System/Library/Perl/5.8.6/Test/Builder.pm line 1078.

[18:27] <nothingmuch> asee also 'sub output' and 'sub _new_fh'

[18:41] <autrijus_tw> gah. my laptop is drinkign tea again.

[18:41] * autrijus_tw hopelessly waits it to dry up

[18:47] <Khisanth> oO

[18:52] <nothingmuch> heh

[18:52] <nothingmuch> WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

[18:53] <pasteling> "nothingmuch" at 82.81.247.180 pasted "inferrence" (18 lines, 344B) at http://sial.org/pbot/13440

[18:54] <pasteling> "nothingmuch" at 82.81.247.180 pasted "inferrence" (18 lines, 449B) at http://sial.org/pbot/13441

[18:54] <nothingmuch> oops

[19:01] * nothingmuch whores lots of karma in this commit =)

[19:03] <nothingmuch> we need more smokers

[19:03] <nothingmuch> linux is not being done at all

[19:04] <nothingmuch> oh, sorry

[19:04] <nothingmuch> wrong group

[19:09] <svnbot6> r7244 | nothingmuch++ | Milner - Hindley type inferrencing for blondie

[19:09] <svnbot6> r7244 | nothingmuch++ | * implemented with Language::AttributeGrammar and Class::Multimethods::pure

[19:09] <svnbot6> r7244 | nothingmuch++ |   (thanks to luqui++)

[19:09] <svnbot6> r7244 | nothingmuch++ | * new temporary AST for easier polymorphic thunks, will be backported

[19:09] <svnbot6> r7244 | nothingmuch++ | * type pretty printer with unicode

[19:10] <autrijus_tw> smoke.pugscode.org is up as an easier-to-remmber facade 

[19:10] <nothingmuch> how do you svn prop?

[19:11] <nothingmuch> yay!

[19:11] <nothingmuch> svk

[19:11] <autrijus_tw> nothingmuch++ for spreading the love to parrot :)

[19:11] <autrijus_tw> svk prop?

[19:11] <nothingmuch> no, i mean the "default" ones we use

[19:12] <autrijus_tw> svn:mime-type    text/plain; charset=UTF-8

[19:12] <nothingmuch> gaal told me about the script

[19:12] <autrijus_tw> svn:eol-style    native

[19:13] * nothingmuch feels like this could have been really beautiful code if it were perl 6

[19:13] <nothingmuch> we need AGs for p6

[19:13] <autrijus_tw> port L::AG over?

[19:14] <autrijus_tw> shouldn't be that hard :)

[19:14] <nothingmuch> luqui is redoing it

[19:14] <nothingmuch> so not now

[19:14] <nothingmuch> and I think this can be implemented with a much better integrated interface with perl 6

[19:14] <svnbot6> r7245 | nothingmuch++ |  r8815@syeeda:  nothingmuch | 2005-10-03 21:12:32 +0200

[19:14] <svnbot6> r7245 | nothingmuch++ |  propfix

[19:14] <nothingmuch> eepp

[19:14] * nothingmuch always forgets to push --verbatim

[19:15] <vladtz> I could do some linux smoking (however my box is a amd-64 and I use the 32 bit compilers)

[19:15] <nothingmuch> autrijus_tw: thanks *yet again* for introducing me to AGs

[19:15] <nothingmuch> vladtz: it still runs, doesn't it?

[19:15] <vladtz> Did yesterday, lets svn and check, back in an hour,....

[19:16] <nothingmuch> vladtz++

[19:20] <autrijus_tw> nothingmuch: looks like you are having a lot of fun with AG :)

[19:20] <nothingmuch> autrijus_tw: lots

[19:20] * autrijus_tw wonders if nothingmuch will benefit from the EHC tutorials/code

[19:21] <nothingmuch> i'll have a look tomorrow

[19:22] <autrijus_tw> it's a surprisingly complete Haskell implementatino :)

[19:22] <nothingmuch> what does it compile to?

[19:22] <nothingmuch> or is it an interpreter?

[19:22] <autrijus_tw> it compiles to Grin

[19:22] <nothingmuch> cool

[19:23] <autrijus_tw> from there to native, I think

[19:23] <autrijus_tw> there's some talk about LLVM but didn't transpire

[19:23] <autrijus_tw> P6 probably doesn't want grin, I think it wants ANF with some modifications.

[19:24] <nothingmuch> is there any place I can learn about ANF that isn't the compiling with continuations paper?

[19:24] <nothingmuch> it's a bit over my head

[19:25] <nothingmuch> i'll go over it with dad tomorrow (he's a logician, so he can read this stuff)

[19:25] <autrijus_tw> oh, ANF is actually very simple

[19:26] <nothingmuch> what is diff(ANF, SSA) ?

[19:26] * Aankhen`` goes to sleep.

[19:26] <Aankhen``> G'night.

[19:27] * joao wonders what ANF is

[19:27] <b6s> A-something normal form?

[19:27] <autrijus_tw> Administrative.

[19:27] <autrijus_tw> nothingmuch: http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html

[19:27] <joao> American Nurses Foundation? :)

[19:31] <b6s> oh, restricts to lambda

[19:31] <vladtz> pugs still build on linux/amd-64, cpan however is confused somehow and tries to run tests with pugs iso perl, anyone???

[19:32] <autrijus_tw> vladtz: nopaste a log?

[19:32] <vladtz> where is pastebot?

[19:34] <kolibrie> perlbot nopaste

[19:34] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[19:34] <pasteling> "vladtz" at 80.127.84.50 pasted "CPAN confused into usign pugs" (13 lines, 841B) at http://sial.org/pbot/13443

[19:34] <vladtz> kolibrie: thanks

[19:35] <kolibrie> vladtz: no problem

[19:39] <vladtz> time for a drink with the so, bye

[19:40] <vladtz> Iĺl check the logs for possible anwers....

[19:42] <Limbic_Region> nothingmuch - did you see luqui just journaled on AG again?

[19:42] <nothingmuch> yep

[19:42] <nothingmuch> he raised the topic earlier today

[19:43] <kolibrie> nothingmuch: can you figure out what vladtz's paste means?  Test-TAP-Model problem

[19:43] <nothingmuch> phooey

[19:44] <nothingmuch> i wonder what version of Module::Build it is

[19:44] <kolibrie> who knows

[19:44] <nothingmuch> T::TH has no relation what so ever to pugs

[19:44] <nothingmuch> perhaps PERL_TEST_HARNESS leaked?

[19:44] <kolibrie> that's what's so weird

[19:44] <nothingmuch> it looks like it

[19:45] * autrijus_tw gives up on he h6-e 6f the 2eyb6ard behavng t nght

[19:45] <nothingmuch> heh

[19:45] <nothingmuch> i hope there was no sugar in the tea

[19:45] <autrijus_tw> we'33 see if tomorrow wil3 mae it better

[19:45] <autrijus_tw> gah :(

[19:45] <nothingmuch> go to sleep autrijus-san

[19:45] <nothingmuch> you deserve it

[19:46] <autrijus_tw> well at leat I'm bac to full wireless world

[19:46] <obra> autrijus_tw: ow :/

[19:46] * autrijus_tw waves &

[19:46] <cognominal> autrijus is cloning himself, for more productivity?

[19:47] <kolibrie> autrijus_tw: good night, better laptop success tomorrow

[19:49] <Limbic_Region> so without waking autrijus back up - how much has he gotten done with the Haskell MM implementation?

[19:59] * nothingmuch commented milner.pl

[19:59] <nothingmuch> the algorithm is so much simpler than I had initially thought

[20:01] <Limbic_Region> Just about everything, properly understood, is simple

[20:02] <svnbot6> r7246 | nothingmuch++ |  r8817@syeeda:  nothingmuch | 2005-10-03 21:57:57 +0200

[20:02] <svnbot6> r7246 | nothingmuch++ |  Minor cleanup and lots of comments in the milner script

[20:07] <svnbot6> r7247 | nothingmuch++ | Also explain the unification multimethods

[20:32] * nothingmuch goes biking

[20:38] <svnbot6> r7248 | autrijus++ | * GHC 6.4.1 reportedly works without gcc_select,

[20:38] <svnbot6> r7248 | autrijus++ |   so reflect this in Makefile.PL.

[20:42] <nothingmuch> $30 for a fucking article?!

[20:42] <nothingmuch> phooey!

[20:42] <nothingmuch> this world needs to appreciate free knowlege better

[20:42] <nothingmuch> ciao

[20:42] <vladtz> found my CPAN problem: HARNESS_PERL was set (is that still needed?)

[20:43] <nothingmuch> vladtz: that is not a good thing if you are installing perl modules instead of testing pugs

[20:43] <nothingmuch> and for pugs it's only needed if you're running 'prove' instead of 'make test'

[20:43] <vladtz> nothingmuch: it's seems to a bad thing while smoke testing as well...

[20:44] <nothingmuch> could be... but i don't see why

[20:44] <vladtz> nothingmuch: I'lll remove it from my profile, thanks. Smoke coming up soon (I hope).

[20:44] <nothingmuch> yummy

[20:44] * nothingmuch leaves for the 2nd time ;-)

[21:58] <obra> Which lambdacamels are blogging about perl6?

[21:58] <autrijus> luqui in particular

[21:58] <autrijus> stevan too

[21:59] <obra> what's stevan's url?

[21:59] <obra> Luke I've got

[21:59] <autrijus> http://use.perl.org/~stevan/journal/

[22:00] <obra> Last name is Little? 

[22:00] <autrijus> aye

[22:02] <obra> anybody else who should be on planetsix?

[22:04] <autrijus> not sure... nothingmuch didn't keep a journal iirc

[22:04] <autrijus> gaal's got livejournal but not usually p6 related

[22:06] <obra> nod

[22:06] <obra> ok

[22:30] <joao> autrijus, weren't you sleeping? :))

[22:31] <autrijus> ah, but my keyboard came back to live...

[22:31] <joao> or you just need to sleep 2 or 3 hours? :)

[22:32] <autrijus> nah, usually 10hrs.

[22:32] <joao> really? wow

[22:33] <joao> and still have time for everything you do? 

[22:33] * joao smiles

[22:33] <autrijus> the trick is to sleep 10 hours for every 25 or 26 hours :)

[22:33] <joao> I thought you were like Paul Erdos, that needed 4/5 hours :)

[22:33] <joao> hehe!

[22:33] <autrijus> nah, I'm not currently powered by  amphetamine :)

[22:34] <joao> "currently" :)

[22:34] <rep> i sleep 6 hours every 24 hours..

[22:34] <rep> well

[22:34] <rep> as in i go to bed at around 4am every day

[22:35] <rep> and wake up at 10am

[22:35] <joao> I can't do less than 8 hours. it's phisically impossible :PP

[22:37] <joao> 25 continuous hours looks a lot.. even with the 10h sleep :P

[22:37] <svnbot6> r7249 | autrijus++ | * finish removing IRC-OO.pm

[23:07] <clkao> agent tang

[23:07] <svnbot6> r7250 | autrijus++ | * Cabalization for real, thanks to Visual Haskell's help.

[23:07] <svnbot6> r7250 | autrijus++ | * Also checks in the "solution" file for VS2003.

[23:12] <clkao> src/Pugs/Compat.hs:80:5:

[23:12] <clkao>     Duplicate instance declarations:

[23:12] <clkao>       src/Pugs/Compat.hs:80:5: instance Typeable DirStream_

[23:46] <justatheory> seen autrijus

[23:46] <jabbot> justatheory: autrijus was seen 1 hours 12 minutes 48 seconds ago

[23:53] <buu> How many freaking bots do we have any here?

[23:53] <buu> s/any/in/

[23:53] <QtPlatypus> None, all our buts are freek free.

