[00:00] <autrijus> sub infix:<$> (&f:(::A --> ::B) --> A $x --> B) { f($x) }

[00:00] * autrijus is motivated to make that happen ;)

[00:01] <autrijus> hm, the body should be

[00:02] <autrijus> return { f($^x) }

[00:02] <svnbot6> r6097 | putter++ | Undisabled two more test files.  t/rules/rules.t has many failing tests which still need to be :todo<bug>ed.  While some failing tests are no doubt incorrect, PGE should now have lots of real failing tests to drive its development.

[00:16] <svnbot6> r6098 | putter++ | t_disabled/rules/from_perl6_rules/subrule.t: Now well behaved.  Some former parsefails now work.  Some failures todoed.

[00:16] <svnbot6> r6099 | putter++ | t_disabled/rules/from_perl6_rules/subrule.t: Undisabled by moving to t/rules/from_perl6_rules/subrule.t.

[00:16] <svnbot6> r6100 | iblech++ | * pugs::hack: PODified putter++'s new section.

[00:16] <svnbot6> r6100 | iblech++ | * Array-Lazy: Added Makefile.PL so the tests are run from make test.

[00:16] <svnbot6> r6100 | iblech++ | * Usual svn props.

[00:16] <svnbot6> r6101 | iblech++ | PIL2JS: PIL2JS.js, PIL::Subs, PIL::Params: Necessary infrastructure to

[00:16] <svnbot6> r6101 | iblech++ | implement junctions.

[00:30] <putter> autrijus: ok, now plenty of simple pge failure cases to chew on.

[00:30] <svnbot6> r6102 | putter++ | t/rules/from_perl6_rules/stdrules.t: Undisabled.  Well behaved and todo-ed.

[00:31] <putter> good night all &

[00:33] <autrijus> woot!

[00:33] * autrijus wonders if we should send all failures to pmichaud, or convert them data-driven to parrot rules tests, or both

[00:34] * autrijus hacks --> parsing in.

[00:39] <brentdax> Hmm...Pugs is consuming seemingly infinite amounts of time before it even executes the first statement of test.p6, and I'm not really sure why.

[00:39] <svnbot6> r6103 | autrijus++ | * Parse for the tentative return type feature:

[00:39] <svnbot6> r6103 | autrijus++ |     sub inc (Int $x --> Int) { $x + 1 }

[00:39] <svnbot6> r6103 | autrijus++ | * Also, this form is parsed too, although full named binding

[00:39] <svnbot6> r6103 | autrijus++ |   havn't been implemented, documented, or canonized:

[00:39] <svnbot6> r6103 | autrijus++ |     sub inc (Int $x --> Int $y) { $x + 1 }

[00:39] <svnbot6> r6104 | autrijus++ | * CodeGen: currently commented-out hook for -C PIL2.

[00:41] <QtPlatypus> brentdax: Are you using the precompiled Prelude?

[00:41] <brentdax> As far as I know.

[00:41] <autrijus> what's test.p6?

[00:41] <brentdax> (I say "seemingly" because I Ctrl-C after about ten minutes.)

[00:42] <autrijus> and did it work before?

[00:42] <brentdax> The script for WWW::Kontent.  And yes, it did, but I haven't updated Pugs since 2.6.9 was released, so it has to be something I did.

[00:43] <jql> that return type feature is so blatantly stolen from other languages... I love it

[00:43] <autrijus> jql: right, perl (was|is|will still be)  all about stealing the right features

[00:44] <QtPlatypus> autrijus: Does that mean we will get sub curryadd (Int $x --> Int $y --> Int) { $x + $y }

[00:44] <svnbot6> r6105 | autrijus++ | * new PIL.Container design based on this drawing:

[00:44] <svnbot6> r6105 | autrijus++ |     http://pugscode.org/images/container.png

[00:44] <autrijus> QtPlatypus: no, that is

[00:45] <autrijus> return { $x + $^y }

[00:45] <autrijus> but yes.

[00:45] <autrijus> and the signature is 

[00:45] <autrijus> Int $x --> Int --> Int

[00:45] <autrijus> although doesn't hurt if you add $y.

[00:45] <autrijus> cool eh?

[00:46] * autrijus ponders

[00:46] <QtPlatypus> 0 Kelvin man, 0 Kelvin.

[00:46] <autrijus> my $x is free; $x + 3 === 4; say $x; # 1

[00:46] <brentdax> Happens after kontent-config.yaml is read in, but before the configuration is completely applied.  Maybe it's having trouble loading one of the modules...

[00:47] * autrijus decides that particular kind of insanity is better left for another day.

[00:48] <brentdax> The HTML renderer?  Hmm.

[00:48] * jql wonders if we're gonna get a tuple syntax, next

[00:48] <autrijus> jql: (1,2,3) is a tuple no?

[00:49] <autrijus> and :(Int,Int,Int) is a tuple type.

[00:49] <jql> hmm... :(Int,Int,Int) specifies something?

[00:49] <autrijus> yeah, it's a type literal.

[00:50] <brentdax> Aaaah, a stray quotation mark.  That's pretty random, and possibly a bug in Pugs...

[00:50] <autrijus> brentdax: tests welcome :)

[00:51] <brentdax> That depends on my ability to reproduce it.

[00:51] <brentdax> Or rather, produce a test case from it.

[00:51] <brentdax> It's also a bug that manifests itself as Pugs freezing up during parsing--I'm not sure how to test safely for that.

[00:52] <QtPlatypus> Can we use a simmler technique to create type restricted hashes?

[00:52] * jql can't picture how that would be used... my @foo is :(Int,Num,Str) can't be right

[00:53] <autrijus> jql: infix "as"

[00:53] <autrijus> QtPlatypus: that's the shape of hash, so yes

[00:53] <jql> that's better

[00:54] <scook0> autrijus: the new Container/Cell structure makes a lot more sense

[00:54] <autrijus> scook0: thank you, and it seems that "is constant" is indeed rebindable

[00:54] <scook0> yeah

[00:54] <autrijus> and MultiSub is just a kind of Code.

[00:54] <autrijus> so all is well

[00:55] <scook0> before, I was having trouble figuring out which of Container/Cell/Box fits with which parts of my mental model

[00:55] <scook0> but now it fits anyway

[00:55] <autrijus> scook0: and I dropped the Box :)

[00:55] <autrijus> I figure that was the key move.

[00:55] <scook0> so, Container kinda-sorta represents the variable /name/

[00:56] <scook0> and Cell represents the anonymous slots that names get bound to

[00:56] <autrijus> yeah, although you have anonymouse containers.

[00:56] <autrijus> my $x = \3; # reference to an anonymous constant container.

[00:57] <scook0> because 3 is just a value

[00:57] <scook0> so we need somewhere to store it

[00:57] <scook0> if we're going to take a reference

[00:57] <autrijus> right. and references refer to containers, so it's promoted to a constant container.

[00:57] <autrijus> $$x := 4; # hat trick!

[00:58] <autrijus> (that works.)

[00:58] <jql> and, containers implement stuff like "will undo" and value constraints and whatnot?

[00:58] <scook0> (brain explodes!)

[00:58] <autrijus> jql: yes.

[00:58] <scook0> mind you, I was examining the metamodel yesterday

[00:58] <scook0> so I already have skull fragments all over my walls :)

[00:59] <scook0> I think I get it now though

[01:00] <autrijus> good. and if you don't, I'll shower you with more diagrams :)

[01:00] <autrijus> actually, I'll shower you with diagrams anyway even if you got it.

[01:00] <scook0> so, in your meta-universe:

[01:00] <scook0> Classes and Objects are two completely separate kinds of things

[01:01] <scook0> (i.e. a Class is /not/ an Object)

[01:01] <scook0> but then we have clsMeta

[01:01] <scook0> which points to what is essentially the Object-reification of the class

[01:01] <scook0> (woo, I used 'reification' in a sentence!)

[01:01] <autrijus> yes!

[01:02] <autrijus> the Class is a very thin shadow wall

[01:02] <autrijus> between the metaverse and mortal land

[01:02] <scook0> my stumbling block was all the meta-this and meta-that

[01:02] <autrijus> to the mortals it's an object

[01:02] <autrijus> oh, it's easy. when you read meta, think "guts"

[01:02] <scook0> so I translated it into my own notation, in which the word 'meta' doesn't appear at all

[01:02] <autrijus> as in, non-user-visible internals.

[01:02] <scook0> yeah, my interpretation of 'meta' was different

[01:02] <scook0> that's what threw me off

[01:02] <autrijus> same here

[01:03] <autrijus> but then I learned "meta" means "below" here.

[01:03] <autrijus> just like I just learned that "eigenclass" is just your ordinary singleton classes.

[01:04] <scook0> what sort of stuff is involved in metamorphing (demiurge) into (theos)?

[01:04] <autrijus> scook0: stevan explained that in the 10k ft view

[01:05] <autrijus> it happens at Perl6::MetaClass::_build_meta.

[01:05] <autrijus> hence, "metamorph"

[01:05] <scook0> having all the gnostic names for everything is /so/ much cooler :)

[01:05] <autrijus> :D

[01:05] <autrijus> glad you like it

[01:05] <autrijus> it first adds the add_method method

[01:05] <autrijus> by binding it to the primitive _add_method

[01:06] <autrijus> so we can call add_method from there on

[01:06] <scook0> you have to add 'add_method' magically, right?

[01:06] <scook0> that's part of the bootstrapping

[01:06] <autrijus> right.

[01:06] <autrijus> then we add accessor methods to all its structure

[01:06] <scook0> because you can't add it normally until it's already been added, which is too late

[01:06] <autrijus> completing the reflection.

[01:06] <autrijus> then we add magics like _merge

[01:07] <autrijus> which handles role merging

[01:07] <autrijus> all using add_method

[01:07] <autrijus> then we add a method, add_attribute

[01:07] <autrijus> then use that add_attribute to add attribute declarations

[01:07] <brentdax> Okay, what I think this comes down to is that it takes Pugs a really long time to figure out that quotation marks are mismatched, and the amoung of time increases dramatically with code size.

[01:07] <autrijus> to all its structure

[01:07] <autrijus> brentdax: good. example?

[01:07] <brentdax> *amount

[01:08] <autrijus> brentdax: I bet it's a redundant "try" in parsec.

[01:08] <autrijus> although if it wasn't, then the grammar structure is in trouble.

[01:08] <autrijus> but I think it is.

[01:08] <autrijus> scook0: so it adds the attribute layer of introspection also

[01:09] <autrijus> scook0: then we can use attribute accessor to manage the superclass attribute.

[01:09] <autrijus> which is what genesis does.

[01:09] <autrijus> end of story

[01:09] <brentdax> The pastebot isn't agreeing with me...

[01:09] <brentdax> Okay, hold on a sec.

[01:10] <scook0> (genesis) just declares that the 'Class' class is a subclass of the 'Object' class

[01:10] <scook0> but in order to do that, (theos) needs to be reflective/introspective enough

[01:10] <pasteling> "brentdax" at 64.81.33.205 pasted "Parsing this takes 43 seconds to fail (1.6GHz x86, 512 MB RAM, very lightly loaded)" (15 lines, 293B) at http://sial.org/pbot/12288

[01:11] <brentdax> Removing any of the lines inside that if block decreases the failure time dramatically.

[01:12] <brentdax> (Oh, and I'm using stock CPAN 6.2.9.)

[01:24] <autrijus> scook0: that's right.

[01:25] <autrijus> brentdax: can you turn it into a test?

[01:25] <autrijus> i.e. make something that takes 10sec to parsefail and test that it should fail for <3sec

[01:25] <autrijus> or something like that.

[01:25] <brentdax> That would depend on the speed of the computer...

[01:26] <autrijus> I need to run now, so unless it's turned into a test (or less preferably a p6c post) I may forget about it

[01:26] <autrijus> brentdax: well, test two strings, one 2x the other

[01:26] <autrijus> and test that it scales linearly or something

[01:26] <autrijus> improvise :)

[01:26] <brentdax> Alright, I'll see what I can do.

[01:26] <autrijus> thanks! brentdax++

[01:26] <autrijus> &

[01:59] <svnbot6> r6106 | iblech++ | PIL2JS: Junctions, but with some problems which I'll probably fix tomorrow:

[01:59] <svnbot6> r6106 | iblech++ | * +$junc doesn't return a new junction, but dies.

[01:59] <svnbot6> r6106 | iblech++ | * If a sub accepts more than one parameter, it will always autothread, even if

[01:59] <svnbot6> r6106 | iblech++ |   one of the parameters accepts raw Junctions.

[01:59] <svnbot6> r6106 | iblech++ | * Probably minor slowdown as most subs call PIL2JS.possibly_autothread now, and

[01:59] <svnbot6> r6106 | iblech++ |   this sub involves various loops... We'll see.

[03:12] <svnbot6> r6107 | fglock++ | * Junctions supported in 'Lazy::List' and 'Array::Lazy'

[03:12] <svnbot6> r6107 | fglock++ | * Multi-dimensional Lazy Array with 'Array::Lazy'

[03:12] <svnbot6> r6107 | fglock++ | * New lazy methods: reverse(), grep(), map()

[03:12] <svnbot6> r6107 | fglock++ | * Removed 'Iter' class; renamed 'Iter::Range' to 'Lazy::Range'

[03:12] <svnbot6> r6107 | fglock++ | * A few new internal Classes

[03:12] <svnbot6> r6107 | fglock++ | * More tests

[04:07] <scook0> brentdax: is this your (takes-ages-to-fail) bug from before?

[04:08] <brentdax> Yes.

[04:09] <scook0> maybe in t/pugsbugs ?

[04:09] <brentdax> t/pugsbugs/parse-fail.t, maybe?

[04:10] <scook0> are you expecting it to work, or just to fail elegantly?

[04:11] <scook0> that's probably fine; if anybody really cares they can always move/rename it later

[04:11] <brentdax> I'm expecting it to fail elegantly.  Right now, if it encounters the code `"$1$2$3$4 {}{}{}{}` (note the unmatched quote), it fails in 0.4 seconds.  If it encounters `"$1$2$3$4$5$6$7 {}{}{}{}{}{}{}`, it takes about thirty seconds.

[04:12] <scook0> ker-razy

[04:12] <brentdax> Place a stray double quote in the middle of a 150-line module and you can imagine the result.

[04:13] <brentdax> I was having instances of Pugs that I would Ctrl-C after ten minutes of trying to parse.

[04:15] <brentdax> My test makes sure it doesn't take more than ten times as long to parse the latter than the former.

[04:59] <svnbot6> r6108 | brentdax++ | Test for a degenerate case in the parser triggered by an incomplete literal 

[04:59] <svnbot6> r6108 | brentdax++ | string.  (It's not that it should succeed, it's that it shouldn't take fifty 

[04:59] <svnbot6> r6108 | brentdax++ | times as long for a string with less than twice as many interpolators.)

[05:10] <meppl> in german perl6 sounds like perl-sex

[05:11] <meppl> ("sechs")

[05:11] <meppl> just info

[05:11] <meppl> class Perl is Sex {}

[05:11] <meppl> :D

[05:33] *** gaal_ is now known as gaal

[05:38] <meppl> (6 sounds like "sex" in german - written "sechs"....)

[05:41] <ods15> heh

[06:27] <brentdax> ...go me?

[06:27] <brentdax> brent@motoko:~/Workspace/Kontent$ ./test.p6 PATH=/kontent/settings/uri_prefix

[06:27] <brentdax> Segmentation fault

[06:27] <coral> hi, brentdax

[06:27] <brentdax> Hello, coral.

[06:34] <brentdax> I swear, the errors get more and more severe as I go on.

[06:35] <brentdax> Okay, happens during rendering...

[06:39] <brentdax> ...Scalar::Perl5.  Looks like it tried to call a method on a Perl 5 string.

[06:52] <meppl> http://relay.slayradio.org:8000  is a cool radio

[06:52] <meppl> http://relay.slayradio.org:8100  for isdn-users or some low bandhwiths

[06:52] <meppl> asdf

[06:53] <meppl> bandwidth

[09:44] *** Maddingue__ is now known as Maddingue

[11:23] <Aankhen``> ?eval my %foo = (a => 'b', c => 'd'); my $bar = "f"; %foo<e> := $bar; %foo

[11:23] <Aankhen``> Bah.

[11:48] *** nnunley3 is now known as nnunley

[12:36] *** cnhackTNT is now known as cnhackTNT|away

[16:13] *** Aankh|Clone is now known as Aankhen``

[16:48] * chip calls this meeting of the cabal to order

[16:50] * stevan wonders who chip is talking to :)

[16:50] <autrijus> chip: in cabal meeting again?

[16:50] <autrijus> what's the topic?

[16:50] <autrijus> hi stevan 

[16:50] <stevan> rehi autrijus 

[16:51] <autrijus> stevan: drawing metamodel is challenging

[16:51] <stevan> autrijus: yes it is

[16:51] <autrijus> I can do a data-oriented drawing like yours

[16:51] <autrijus> or a timeline

[16:51] <chip> list operator forward declaration

[16:51] <autrijus> of the bootstrap sequence

[16:51] <autrijus> but very hard to do them in one

[16:51] * nothingmuch waves

[16:51] <stevan> autrijus: timeline of bootstrap is a good thing

[16:51] <autrijus> hey nothingmuch.

[16:51] <stevan> hola nadda-mucho

[16:52] <stevan> autrijus: I dont think it would make sense to have both in the same drawing

[16:52] <autrijus> eh but you wouldn't know what the players in the bootstrap contains

[16:52] <autrijus> without a structure

[16:52] <autrijus> anyway, I'll figure it out.

[16:52] * stevan will be releasing a highly experimental Class::C3 in the next hour or so 

[16:52] <autrijus> oooooh.

[16:53] <stevan> autrijus: link the pictures

[16:53] <stevan> or maybe a legend

[16:53] <putter> nothingmuch: looks like smoke hasnt been updated in a bit...

[16:53] <stevan> autrijus: I know you would like that :)

[16:53] <autrijus> :)

[16:53] <nothingmuch> putter: uh, will fix

[16:53] <autrijus> I'll go grab some food. bbiab

[16:53] <autrijus> chip: if some _breaking_ news occurs be sure to post it here :)

[16:54] <autrijus> whoa, I got a bug report, test cases and possible patch to Acme::Hello.

[16:54] <autrijus> the perl community is very advanced.

[16:54] <autrijus> food &

[16:54] <chip> autrijus: question for when you get back.  given a forward declaration that says literally 'sub foo {...}', what function prototypes are compatible for the actual definition of sub foo?

[16:55] <autrijus> chip: surely, sub foo (*@_) {...}.

[16:55] <autrijus> unless we rule that the {...} special form without parens is all-catching

[16:56] <nothingmuch> putter: restarted

[16:56] <autrijus> because {...} is a special form already

[16:56] <autrijus> that's not a bad thing.

[16:56] <putter> Regards :global :g matching - my @a = "aaa" ~~ rx:g/a/; +@a # => 0, instead of 3.  A three-line patch fixes simple cases, but not quite.  Here is the commit message for a patch I believe I'm going to punt:

[16:56] <nothingmuch> chip: as if he actually leaves the computer behind when he goes for food

[16:56] <putter> Match.hs: matching against a global pattern without a subpattern now uses the entire pattern instead.  'aaa' ~~ rx:g/a/ # => 3, not 0.  (The .from and .to positions remain wrong.)  This is however an incorrect kludge.  Lacking a way to ask the pattern if it has a capture group, the match array is used instead.  But that could be empty for other reasons.  'ba' ~~ rx:g/ba|(a)/ should return a one element array of a failed match (the (a)), 

[16:56] <putter> not of a sucessful match 'ba'.

[16:56] <autrijus> chip: though if we do that, it needs to be consistent with roles.

[16:56] <chip> autrijus: it seems easier to rule what definitions are _not_ compatible.  AFA Larry can tell, only declarations that would turn foo into unary or nonary operator would be _in_valid.  'sub foo () {...}' would be invalid.  'sub foo ($x) {...}' would be invalid.  Everything else should be OK.

[16:56] <autrijus> role Foo { method stub { ... } }

[16:56] <putter> fyi.

[16:57] <chip> autrijus: since methods all use parens for their parameters, the current issue (parsing compatibility) seems not to apply to methods

[16:57] <putter> It seemed the simple and consistent incorrect behavior, even if it were more common, was prerferable to a more complex incorrect behavior.

[16:58] * putter now returns you to your regularly scheduled program...

[16:58] <autrijus> chip: meth $obj: 1, 2, 3

[16:58] <autrijus> chip: is that always listop?

[16:58] <autrijus> anyway, bbiab &

[16:59] <chip> autrijus: yes

[16:59] <chip> cya

[17:26] <chip> multi f(U, All);   # lucs didn't notice this until he'd written it

[17:26] <stevan> :)

[17:26] <stevan> riiiight,.. sure he didnt notice

[17:27] <chip> really!  when he figured out why everyone was laughing he was surprised

[17:27] <stevan> :)

[17:28] <stevan> I assume lucs == Luke Palmer, in which case, I am not actually suprised then

[17:28] <integral> luqui == Luke Palmer

[17:29] <stevan> who is lucs then?

[17:29] * stevan assumed it was some secret cabal nick of luqui's

[17:29] <integral> hmm, not sure

[17:29] <chip> I know him only as "Luke" in realspace

[17:30] <chip> so I guess that's him.  luqui

[17:32] <stevan> chip: tell luke "multi f(U, 2)" for me

[17:33] <stevan> actually this works quite well: multi f(U, 2)   { ... }

[17:33] <stevan> multi f(U, All) { ... }

[17:33] <chip> will do

[17:33] <stevan> muchas gracias chip 

[17:34] * stevan is thinking in mutually recursive insults now

[17:36] <nothingmuch> lucs != luqui

[17:36] <nothingmuch> lucs is someone else... ingy knows him well, IIRC

[17:38] *** ods15 is now known as o1s5d

[17:38] *** o1s5d is now known as ods15

[17:39] <autrijus> rehi!

[17:40] <autrijus> ooh, the All type!

[17:40] <autrijus> I actually propose that Any means both the Top type and the Bottom type.

[17:41] <autrijus> the fact that it has no finite manhatten distance will then fall directly from that

[17:41] <autrijus> and (Array of Any) can then be used both in return and param position

[17:41] <autrijus> and 

[17:41] <autrijus> sub f (Any $x --> Any) {...}

[17:41] <autrijus> will DWIM.

[17:41] <autrijus> sounds sane?

[17:42] <autrijus> effectively it'd play the same role as wildcard types in java

[17:42] <autrijus> which we've been using that informally anyway.

[17:43] <chip> double plus is back, Larry says, for mandatory named params

[17:44] <chip> I don't know what Top and Bottom are

[17:44] <autrijus> I didn't know it was gone.

[17:44] <autrijus> chip: it's the top type and bottom type

[17:44] <autrijus> everything .does(Top), and Bottom.does everything

[17:44] <chip> WTF?

[17:45] <autrijus> it's not perl6

[17:45] <chip> oh.

[17:45] <autrijus> it's just type theory terms

[17:45] <autrijus> luke's All is supposedly Bottom

[17:45] <autrijus> and Any is Top

[17:45] <autrijus> I've been using Any|All informally but I think it sutis perl6 better if Any|All is unified as just "Any".

[17:45] <autrijus> I think luqui will like that.

[17:46] <autrijus> ?eval sub f (++$x) { $x };  f(x=>3)

[17:46] <evalbot6> \3 

[17:46] <autrijus> ?eval sub f (++$x) { $x };  f()

[17:46] <evalbot6> Error: No compatible subroutine found: "&f" 

[17:46] <chip> what he really wrote was  f(U, Object)  and we suggested jokingly that it should be  f(U,All)

[17:46] <autrijus> good, ++ is still there.

[17:46] <autrijus> oh. heh. but still, my suggestion stands, especially now that --> type is in

[17:46] <autrijus> without that treatment, (Any --> Any) needs to be written as (Any --> Any|All)

[17:46] <autrijus> which is less than good.

[17:47] <chip> you'll have to write that up

[17:47] <autrijus> I did

[17:48] <chip> what I mean is, I don't understand the proposal yet, so I can't express it here

[17:48] <chip> specifically I don't know the delta from current truth

[17:48] <autrijus> ok.

[17:48] <autrijus> the current truth is that Any is top but not bottmo.

[17:49] <chip> ok

[17:50] <chip> then why doesn't sub f (Any $x --> Al) {...}  work?

[17:50] <chip> s/Al/All/

[17:50] <autrijus> because inside the function, the &return has the type

[17:50] <autrijus> sub return (All $v) {...}

[17:50] <autrijus> which means the actual parameter passed to return must be an instance of All

[17:51] <autrijus> which can't happen

[17:51] <autrijus> as you can't instantiate All

[17:51] <autrijus> it's the bottom type

[17:51] <chip> Hm.  So then, why can't  sub f (Any $x --> Any)  work?

[17:51] <autrijus> because then inferencing would die

[17:51] <autrijus> chr( f( 3 ) )

[17:51] <autrijus> chr expects Int

[17:51] <autrijus> but f() promises Any

[17:51] <autrijus> so you need to test Any.isa(Int)

[17:52] <autrijus> which is terribly false

[17:52] <autrijus> it's all in http://www.nntp.perl.org/group/perl.perl6.language/22482

[17:52] <chip> ah.  I see the geometric value of the Top and Bottom names

[17:52] <autrijus> the C) proposal has Any|All form.

[17:52] <autrijus> and it's terrible to type

[17:52] * chip reads

[17:52] <autrijus> so I think unifying them as Any would work.

[17:53] <autrijus> because it will also solve the "Array of Any" problem

[17:53] <autrijus> see http://www.nntp.perl.org/group/perl.perl6.language/22492

[17:53] <autrijus> as it stands

[17:53] <autrijus> (Array of Int).does(Array of Num); # false

[17:53] <autrijus> (Array of Num).does(Array of Int); # false

[17:54] <autrijus> but we actually want (Array of Any) to be okay

[17:54] <autrijus> since that's the default type we use for arrays

[17:54] <autrijus> so it needs to be able to contain any type and yield any type

[17:54] <autrijus> i.e. be useful in both return position and param positoin

[17:54] <autrijus> so I proposed

[17:54] <autrijus> (Array of Any|All)

[17:54] <autrijus> in that thread for the same reasons

[17:54] <autrijus> but I think that's cumbersome to type, so again, unify Any|All into just Any will work

[17:55] <autrijus> as an additional bonus, we no longer need to explain the All type to people.

[17:55] <autrijus> __END__

[17:55] <chip> ok

[18:12] <svnbot6> r6109 | putter++ | PCRE :global rules, without a subpattern, now return the correct match array.  my @a = 'aaa' ~~ rx:perl5:g/a/; +@a #=> 3, not 0.  PGE rules are not fixed, awaiting a way to determine if they contain a subpattern.  Match .from and .to still incorrect.  The patch is a bit messy.  This would all be better handled by p6-side analysis and implementation of :global.

[18:12] <svnbot6> r6110 | iblech++ | * Usual svn props and EOLs at EOFs.

[18:12] <svnbot6> r6110 | iblech++ | * PIL2JS: More work on junction support.

[18:12] <svnbot6> r6110 | iblech++ |   * PIL2JS.js: Added ::Junction class.

[18:12] <svnbot6> r6110 | iblech++ |   * PIL::Params, PIL2JS.js: Now only parameters not accepting a raw Junction

[18:12] <svnbot6> r6110 | iblech++ |     may cause autothreading.

[18:12] <svnbot6> r6110 | iblech++ |   * PIL::Params: Minor compile-time optimization: If all subparams accept raw

[18:12] <svnbot6> r6110 | iblech++ |     Junctions, PIL2JS.possibly_autothread is not even called.

[18:12] <svnbot6> r6110 | iblech++ |   * Prelude::JS::Keyed: Implemented $junc.values and $obj.pick.

[18:12] <svnbot6> r6110 | iblech++ |   * *BUT*: Most of the t/junction tests won't pass, as -CPIL outputs 1|2|3 as (1|2)|3.

[18:13] <autrijus> iblechbot: Eval line 784 needs to be ported over.

[18:14] <autrijus> either that, or Parser needs to actually understand AssocList

[18:14] <autrijus> the later is arguably easier.

[18:14] <brentdax> autrijus: I did end up committing a test for that too-long-to-fail issue.

[18:15] <autrijus> brentdax: yeah, I saw that. thanks!

[18:15] <brentdax> np.

[18:18] <putter> Hmm, if Parser is still in a poorly understood state, I think I'll wait on my rx hook patch (as it has the potential to acheive a poorly understood state all by itself...;).

[18:18] <autrijus> putter: no, go ahead

[18:19] <autrijus> we have tests

[18:19] <autrijus> that's what tests are for.

[18:20] <putter> Are you sure... I saw a 25+ minute Prelude compile last night (5x normal)... and Prelude is also touched...

[18:20] <putter> Ah well, I'll dust it off and plug it in.

[18:30] <autrijus> mmm craziness.

[18:30] <autrijus> multi append ([], @ys) { @ys }

[18:30] <autrijus> multi append ([*$x, *@xs], @ys) { ($xs, append @xs, @ys)

[18:30] <autrijus> }

[18:30] <autrijus> sub last ($l) { my ($`x, @`xs); append(@`xs, [$`x]) === $l; $`x;

[18:30] <autrijus> }

[18:30] <chip> We just discussed the Any/All problem.

[18:30] <autrijus> chip: oh cool. consensus?

[18:30] <chip> It is now understood.

[18:32] <Khisanth> what is the ` suppose to mean?

[18:32] <chip> Consensus is that "sub Any foo (Any $x) { return $x }" needs to work, and "Array of Any" needs to work.  This may imply that 'Any' becomes a magical object that understands how to respond appropriately to covariant vs. contravariant type checks.  If that's the case, then the top of the type hierarchy (and the bottom, for that matter) will probably have more obscure and technical names.

[18:32] <autrijus> good. I propose "Object" :D

[18:32] <chip> I did too.

[18:32] <autrijus> also I don't think we need a bottom type.

[18:32] <autrijus> many language did without one.

[18:32] <chip> Allison busted that

[18:33] <autrijus> oh well. I guess we better take "everything is an object" slogan down then :)

[18:33] <autrijus> j/k

[18:33] <chip> "But isn't the point of types to eventually instantiate them?", I asked?

[18:33] <chip> "No," responded Allison.

[18:33] <chip> I boggled, and life went on.

[18:33] <autrijus> hm. I wonder why.

[18:33] <autrijus> hm, typo in that "sub last"

[18:33] <autrijus> sub last (@l) {

[18:33] <autrijus>     my ($`x, @`xs);

[18:33] <autrijus>     append(@`xs, [$`x]) === @l;

[18:33] <autrijus>     $`x;

[18:33] <autrijus> }

[18:34] <autrijus> Khisanth: $`x reads "let $`x be free"

[18:34] <autrijus> and "===" means "we assert that"

[18:34] <Khisanth> ...

[18:34] <autrijus> luqui proposes the ` twigil, not me

[18:34] <chip> Free variables?  WTF?

[18:34] <autrijus> chip: this is not canonical

[18:34] <autrijus> just playing with syntax.

[18:34] <chip> ok.  I vote for 'our' or other explicit declaration.

[18:34] <autrijus> because Ovid's presentation is nice

[18:34] <autrijus> and now it gets people thinking

[18:35] <autrijus> chip: the "free" here means "logic programming"

[18:35] <autrijus> look at that sub body again :)

[18:35] <Khisanth> I hope we won't have to start changing the name to Erl ...

[18:35] <autrijus> it deducts how to satisfy them.

[18:35] <chip> oh.  n/m

[18:35] <autrijus> Khisanth: you think logic programming isn't practical? :)

[18:35] * autrijus notes that Rules is a limited form of logic programming

[18:36] <Khisanth> no opinion on that but Perl might not be that practical to use :/

[18:36] <autrijus> because you will encouter unfamiliar code styles?

[18:36] <chip> autrijus: BTW, the 'weird object' definition of Any is essentially your proposal, it's just that luqui gets the screaming heebie jeebies when he contemplates that  A.isa(B) could be false, while A.isa(Any) and Any.isa(B) are both true.

[18:37] <chip> autrijus: so he can't admit that Any really is Top and Bottom, even if it acts just like it is

[18:37] <autrijus> chip: Any is a wildcard.

[18:37] <autrijus> okay. we won't force him to admit it.

[18:37] <chip> heh

[18:37] <autrijus> Any has no identity

[18:37] <autrijus> the Any that isa B and the Any that A isa

[18:37] <autrijus> isn't the same Any.

[18:37] <autrijus> problem solved

[18:37] <autrijus> also, to wit

[18:37] <chip> nice

[18:37] <autrijus> A.isa(A|B)

[18:37] <autrijus> (A|B).isa(B)

[18:38] <autrijus> look ma, same problem

[18:38] <chip> hey, neat: Any is shorthand for any(@all_types)

[18:38] <autrijus> yeah.

[18:38] <autrijus> that's what it means :)

[18:38] <chip> "I love it when a plan comes together."

[18:38] <autrijus> :D

[18:39] <autrijus> Khisanth: anyway, rest assured... I don't think we'll get this prolog stuff into perl6 in the near future

[18:39] <autrijus> Khisanth: if it can't be made coherent and practical it won't go in. it's just early speculation here

[18:41] <Khisanth> actually I think my reaction was more from "ugh perl6 takes another step towards not finished"

[18:41] <autrijus> you think perl5 is finished? :)

[18:42] <autrijus> biology, stable, etc

[18:42] <Khisanth> couldn't think of a better word than finished

[18:42] <Khisanth> I don't know any word that means "finished but not really" :)

[18:42] <autrijus> nod... but I don't think logic programming will delay perl6's production release

[18:44] <Khisanth> but will perl6 maintain the backwards compatibility thing like perl5?

[18:44] * brentdax would really like MMD with subtyping...

[18:45] <brentdax> (It would simplify many aspects of this project.)

[18:47] <autrijus> Khisanth: I think so, inasmuch as that existing programs won't break easily

[18:47] <autrijus> but that certainly doesn't stop adding new features

[18:47] <autrijus> brentdax: I thought pugs MMD has subtyping.

[18:48] <autrijus> ?eval multi f (Num $x --> Int) { int($x) }; multi f (Int $x --> Int) { $x * 2 }; f(9)

[18:48] <evalbot6> 18 

[18:48] <autrijus> ?eval multi f (Num $x --> Int) { int($x) }; multi f (Int $x --> Int) { $x * 2 }; f(4.5)

[18:48] <evalbot6> 4 

[18:48] <autrijus> isn't that that?

[18:48] * autrijus loves the arrow type notation. larry++

[18:49] <autrijus> ?eval multi f (Any $x --> Int) { int($x) }; multi f (Num $x --> Int) { $x * 2 }; f(9)

[18:49] <evalbot6> 18 

[18:49] <autrijus> so it calculates distance too

[18:49] <brentdax> ?eval multi f(Num $x where { $_ % 2 }) { say "odd" }; multi f(Num $x where { ! $_ % 2 }) { say "even" }; f(2)

[18:49] <evalbot6> Error:  unexpected "w" expecting trait, "-->", ",", ":" or ")" 

[18:49] <autrijus> oh you mean constraint subtyping.

[18:49] <brentdax> Yeah.

[18:50] <autrijus> it's a matter of desugar them into given/when

[18:50] <autrijus> so you can write them with given/when using the same number of lines, no? :)

[18:50] <autrijus> (but yeah, it'd be nice to have them)

[18:53] <stevan> autrijus: http://perlcabal.org/~stevan/Class-C3-0.01.tar.gz

[18:53] <stevan> uploading to PAUSE right now too

[18:53] <autrijus> ?eval 'stevan++' xx 5

[18:53] <evalbot6> ('stevan++', 'stevan++', 'stevan++', 'stevan++', 'stevan++') 

[18:54] <stevan> autrijus: it basically pre-caches the method dispatch

[18:54] <stevan> so classes are effectively closed

[18:54] <stevan> but I think I can work around that maybe

[18:54] <autrijus> can you trigger recalculation at runtime?

[18:54] <autrijus> perl5 does that, I think

[18:54] <stevan> autrijus: not yet, but its only a short refactor away

[18:55] <autrijus> cool!

[18:55] <stevan> I have to look at how Perl 5 actually does it

[18:55] <brentdax> It is and it isn't.  In most cases I want to say `multi method adapter(WWW::Kontent::Class::Whatever $class, WWW::Kontent::Request $request where { .mode eq (something) }: )`, which I can fake with given/when.  But occasionally I want to do something like `multi method adapter(WWW::Kontent::Class $class, WWW::Kontent::Request $request where { .mode eq 'history' } where { .format eq 'html' })`

[18:55] <stevan> autrijus: and I want to build some kind of call-next-method mechanism as well

[18:55] <autrijus> it's a when and 

[18:55] <autrijus> infix:<and>

[18:55] <autrijus> stevan: like NEXT?

[18:56] <brentdax> Which is somewhat harder when you don't know all of the combinations beforehand.

[18:56] <stevan> autrijus: yes, but it chooses the next more relevant class in the MRO

[18:56] <autrijus> true.

[18:56] <autrijus> ahh k

[18:56] <stevan> autrijus: like next_METHOD() in the metamodel

[18:57] <autrijus> k

[19:03] <Yaakov> autrijus: Will parrot be able to compile Piet?

[19:04] <autrijus> I have no idea. but leo is crazy enough

[19:04] <autrijus> so if you present the idea to him he might implement it.

[19:05] <Yaakov> Heh.

[19:05] <gaal> wow

[19:05] <gaal> that looks interesting

[19:05] <Yaakov> I bet emacs has a Piet mode :)

[19:06] <gaal> Yaakov, you mean this? http://en.wikipedia.org/wiki/Piet

[19:06] <Yaakov> Yes, that.

[19:08] <gaal> damn, now i'll have to code a p6 version.

[19:08] <Yaakov> Heh, you should.

[19:09] <stevan> that looks nothing like Piet Mondrian's work, but its still pretty cool 

[19:10] <Yaakov> It is in the spirit of it, not an imitation.

[19:10] <stevan> yes

[19:10] <gaal> actually it dosen't sound very hard to implement

[19:11] <Yaakov> I suppose you could do a variation based on only |, -, + and .

[19:11] <gaal> hard to *write* in, fer sure :)

[19:12] <stevan> restricting the color palette to primaries would have probably been too restrictive

[19:14] <chip> breaking news.

[19:14] <chip> autrijus?

[19:14] <autrijus> yes?

[19:14] * autrijus is just pondering the elimination of Code container type

[19:14] <chip> luqui has explained that type junctions are not types, which is Bad.

[19:14] <autrijus> but breaking news first

[19:14] <autrijus> Int --> Int

[19:14] <autrijus> is not a type?

[19:14] <chip> (Int|Str) is not a type, mathematically

[19:15] <autrijus> | is a type operator

[19:15] <autrijus> that takes two types and return one.

[19:15] <chip> It's a junction operator.

[19:15] <autrijus> it is of kind *->*.

[19:15] <chip> It returns a Junction object.

[19:15] <autrijus> that's not going to work.

[19:15] <chip> Apparently you are already cheating.  :-)

[19:15] <autrijus> is a junction of int considered int?

[19:15] <Yaakov> Hey there, chip.

[19:15] <autrijus> i.e. can you call chr() on it?

[19:16] <chip> TENTATIVE NEW PLAN:  Type does Set.  Set operators standard in Perl: (+) union, (-) difference, (*) intersection.

[19:16] <autrijus> not sure I grok type differences.

[19:16] <autrijus> Num-Int

[19:16] <chip> What we now call (Int|Str) shall be henceforth (Int (+) Str) ... the junion of all Ints and all Strs

[19:16] <autrijus> like that?

[19:16] <chip> the parens are required.  Unicode version is circled.

[19:16] <autrijus> (Num (-) Int)

[19:17] <chip> All non-integral numbers, yes

[19:17] <autrijus> ok. so we still have higher kinded type operators

[19:17] <chip> Right

[19:17] <autrijus> just not sharing it with junctions

[19:17] <autrijus> I'm entirely fine with that.

[19:17] <chip> Excellent.

[19:17] <chip> "Let's do it." - saith Larry

[19:17] <autrijus> woot.

[19:18] <autrijus> yay.

[19:18] <autrijus> btw, can I get a quick review on

[19:18] <autrijus> sub id (::T $x --> T) { $x }

[19:19] <autrijus> which is my current working syntax, but I'm open to other suggestions

[19:19] <autrijus> (it means that ::T binds from $x and the latter T unifies passively with ::T)

[19:19] <autrijus> essentially, scoped type variables.

[19:19] <chip> I can't bring up a new thing until after lunch (about an hour), as Luke is still working out what value might still adhere in the Junction object that results from Int|Str

[19:19] <autrijus> oh ok. then don't bother

[19:20] <autrijus> after lunch is fine, and I'll be asleep anyway

[19:20] <autrijus> will you continue tomorrow?

[19:20] <autrijus> tomorrow your time, that is

[19:20] <chip> No, we're dispersing soon.  Damian in 1hr, me in four

[19:21] <autrijus> okay, see you on the list then

[19:21] <autrijus> excellent work done

[19:21] <autrijus> thanks for your relaying

[19:21] <chip> I'll ask him about the ::T thing at lunch, if I can

[19:21] <autrijus> cool

[19:21] <chip> My pleasure

[19:21] <chip> Yaakov: hi there

[19:21] <chip> sorry missed you above

[19:21] <Yaakov> No problem, you are focused :)

[19:21] <Yaakov> Hope you and all of yours are well.

[19:22] <chip> thank you; you too

[19:22] <Yaakov> Thanks.

[19:24] <autrijus> sub f (((Int ⊖ Num) ⊕  Str) ⊘ Tieable) { ... }

[19:24] <autrijus> I guess I can grow to like it.

[19:25] <wolverian> I just see boxes :/

[19:26] <autrijus> sub f (((Int ⊖ Num) ⊕  Str) ⊘ Tieable) { ... }

[19:26] <autrijus> still boxes?

[19:26] <wolverian> yes.

[19:26] <wolverian> I think the font just doesn't have those characters

[19:26] <wolverian> (courier new)

[19:26] <autrijus> oh well. probably not good for public consumption then.

[19:26] <autrijus> what happened to "unicode operators will be within latin1" :)

[19:27] <autrijus> in that case, we might as well write --> as → 

[19:27] <wolverian> doesn't fortress do that?

[19:27] <autrijus> just so type operators are sufficiently unicody.

[19:27] <autrijus> wolverian: probably just for typesetting

[19:27] <wolverian> oh, okay.

[19:28] <autrijus> haskell people do that in latex mode too

[19:28] <wolverian> confusing.

[19:28] <Aankhen``> Yowza.

[19:28] <autrijus> hi Aankhen``.

[19:28] <Aankhen``> What's the whole `Int $x --> Int` thing?

[19:28] <Aankhen``> Hi. :-)

[19:28] <autrijus> Aankhen``: it's a type of Code

[19:28] <Aankhen``> I just popped in to backlog before I go to sleep.

[19:28] <autrijus> that takes a positional or named $x of Int type or its subtype

[19:29] <autrijus> and returns something that can be used as Int or its supertype.

[19:29] <Aankhen``> The --> Int means the sub returns an Int?

[19:29] <autrijus> the "-->" reads "yields" or "returns" or "gives"

[19:29] <autrijus> yeah.

[19:30] <Aankhen``> Ah, I see.

[19:30] <Aankhen``> How does that work with multiple parameters?

[19:30] <Aankhen``> You just put the --> at the end?

[19:30] <wolverian> does it differ from the 'returns' trait?

[19:30] <autrijus> I think , binds tighter than -->

[19:30] <autrijus> so

[19:30] <autrijus> Int $x, Int $y --> Num

[19:30] <autrijus> means

[19:30] <autrijus> (Int $x, Int $y) --> Num

[19:30] <Aankhen``> Mmm, okay.

[19:30] <autrijus> wolverian: the returns trait is private to the function

[19:30] <wolverian> autrijus, oh. is that useful

[19:31] <wolverian> s,$,?,

[19:31] <autrijus> wolverian: yes, because then you have covariance but avoid contravariance.

[19:31] <Aankhen``> ?eval sub foo (Num $x, Num $y --> Int) { int($y) }; foo(10.3953893)

[19:31] <evalbot6> Error: No compatible subroutine found: "&foo" 

[19:31] <Aankhen``> ?eval sub foo (Num $x, Num $y --> Int) { int($y) }; foo(10)

[19:31] <evalbot6> Error: No compatible subroutine found: "&foo" 

[19:31] <autrijus> Aankhen``: it takes two params.

[19:31] <autrijus> x and y

[19:31] * Aankhen`` bangs forehead on wall.

[19:31] <autrijus> ...

[19:31] <Aankhen``> I ought to go to sleep, really.

[19:31] <wolverian> autrijus, I'm going to have to wikipedia those. :)

[19:31] <Aankhen``> ?eval sub foo (Num $x, Num $y --> Int) { int($y) }; foo(10, 15.2348)

[19:31] * wolverian reads

[19:31] <evalbot6> 15 

[19:32] <autrijus> wolverian: go ahead :)

[19:32] <Aankhen``> Yay.

[19:32] <Aankhen``> OK.

[19:32] <Aankhen``> Sleepy time.

[19:32] <Aankhen``> G'night.

[19:32] <autrijus> wolverian: namely

[19:32] <autrijus> sub foo (Int $x) returns Int {}

[19:32] <autrijus> both Int cannot accept a Complex

[19:33] <autrijus> but you can call foo when it was expecting a subtype of Int, say Prime

[19:33] <autrijus> and it will die if coercion fails

[19:33] <autrijus> however

[19:33] <autrijus> sub foo (Int $x --> Int) {}

[19:34] <autrijus> you can't call foo when you are expecting Prime, then.

[19:34] <autrijus> inferencer will stop you.

[19:34] <wolverian> hmm. that's not obvious to me.

[19:34] <autrijus> neither is it to me. I don't know why they kept the "returns Int" form.

[19:35] <autrijus> probably because that you can say "returns Animal"

[19:35] <autrijus> and coerce it into a Dog

[19:35] <autrijus> I don't really know, not my decision :)

[19:35] <wolverian> right. this is complicated stuff. I guess it can't be exactly obvious

[19:36] <autrijus> wolverian: http://www.nntp.perl.org/group/perl.perl6.language/22482

[19:36] <autrijus> http://www.nntp.perl.org/group/perl.perl6.language/22492

[19:38] <wolverian> mm.

[19:39] <wolverian> choosing between --> and returns makes my head hurt

[19:39] <autrijus> intuitively, if you want compile time checking, choose -->

[19:40] <autrijus> if you can accept runtime casting failures, use returns.

[19:40] <chip> More set setuff

[19:41] <chip> (<=) (<) (>=) (>) (in) (==)   are all infix ops that take Sets on both sides

[19:41] <autrijus> chip: if (Array of Num) is, as the spec says, Array[returns => Num], and we take "returns" to be coercive

[19:41] <chip> Unicode equivs not available here

[19:41] <autrijus> then (Array of Int).isa(Array of Num) can be true

[19:41] <autrijus> because it will always coerce on fetch

[19:41] <autrijus> and only check store type

[19:41] <autrijus> that may be intuitive to some

[19:42] <autrijus> but anyway, that's time consuming to discuss fully, so probably for another day

[19:42] <chip> New 'set' op, like junction types

[19:42] <chip> junction creators, that is

[19:42] <chip> binary Set operators coerce their listlike parameters into Sets

[19:42] <autrijus> I expects that junctions are sets ;)

[19:43] <chip> No, they're not.  Very much not.

[19:43] <autrijus> either that, or $junction.values returns a set?

[19:43] <chip> <1 2> (+) (2, 3)   is a Set of Any with three elements

[19:43] <autrijus> or is that $junction.set?

[19:43] <chip> Junctions are not Sets, any more than arrays are.

[19:43] <chip> Even less, really.

[19:43] <autrijus> hm, I thought that's a Set of (Str (+) Int).

[19:43] <autrijus> not a Set of Any.

[19:44] <autrijus> also, <1 2> is qw(), hence it's four elements.

[19:44] <putter> nothingmuch: a bit more red smoke in t/rules/ than expected.  are you running parrot-0.2.3?

[19:44] <chip> Hm.  I was assuming '2' eq 2 therefore duplicate.  Hm.

[19:45] <autrijus> sets uses string equality? horrors.

[19:45] <chip> No, that was my assumption, not a discussion conclusion

[19:45] <autrijus> k.

[19:45] <autrijus> perl6's lack of generic equality is felt :)

[19:45] <chip> the default test is identity, not equality.  =:=     <- word of Larry

[19:46] <autrijus> larry is confused. =:= tests container eqality; .id == .id tests object eqality; values have neither.

[19:46] <autrijus> or are we extending =:= to objects to test their .id

[19:47] <autrijus> and rule that autoboxing will give identialy id to identical pure values with the same type?

[19:47] <autrijus> that's a bit confusing levels but fine with me.

[19:47] <autrijus> actually, a lot confusing levels :) $a =:= $b is testing containers? objects? values?

[19:49] <chip> We're reviewing that issue.

[19:49] <autrijus> k.

[19:50] <autrijus> in the current spec, if ($a =:= $b) is true, then assigning to $b will always touch $a.

[19:50] <autrijus> so extending that to mean object identity test is very risky.

[19:50] <autrijus> better use ~:~ or something else.

[19:50] <autrijus> or just .id == .id

[19:51] <autrijus> and then rule that 3.id always == 3.id

[19:51] <autrijus> and never == '3'.id

[19:56] <pasteling> "putter" at 66.30.119.55 pasted "rules Parser hook - snapshot of an unfinished patch. fyi." (152 lines, 5.7K) at http://sial.org/pbot/12303

[19:57] <putter> I was going to apply the patch with the known first regression.  But the second is not acceptable.  I won't be able to bang on it further today, so this is simply a "what's up" fyi.  ah well.

[19:57] <autrijus> ok.

[19:59] <chip> it's going oddly.

[20:00] <autrijus> I bet.

[20:00] <autrijus> I hope http://pugscode.org/images/container.png would help... probably not at this point :)

[20:05] <autrijus> hm, I can't wait to see what  {==} means.

[20:05] <autrijus> since [...] is reduction and (...) is set.

[20:05] <autrijus> (not quite the same, I know, but same mental space)

[20:05] <chip> back

[20:05] <putter> how would one create a Complex which could be passed to  foo(Int $i) and throw a runtime error it was imaginary or non-integral?  ie, how does one arrange at class level for implicit casting?

[20:06] <chip> hash keys and set elements will default to the same comparison rules, i.e. =:=

[20:06] <autrijus> putter: $complex as Int;

[20:06] <autrijus> what is =:=?

[20:06] <putter> (random question as I skim the backlog - feel free to punt)  oh, ah.

[20:06] <autrijus> are we getting rid of the relationship between := and =:= ?

[20:06] <chip> =:= is value identity for value types, and reference equality for everything else

[20:06] <autrijus> so it no longer tests for binding equivalence.

[20:06] <autrijus> oops.

[20:07] <autrijus> S03:

[20:07] <autrijus>        There is also an identity test, "=:=", which tests whether two names

[20:07] <autrijus>        are bound to the same underlying variable.  "$x =:= $y" would return

[20:07] <autrijus>        true in the above example.

[20:07] <autrijus> (the above example is $x := $y)

[20:07] <putter> err.  well, I'm still puzzled, but later.

[20:07] <putter> cheers &

[20:07] <chip> asking

[20:07] <autrijus> =:= was specced to "whether the two sides has been := 'ed before"

[20:07] <chip> "oh yeah." - luqui

[20:07] <autrijus> now you're using it for something entirely orthogonal.

[20:08] <autrijus> not going to work really well.

[20:08] * autrijus proposes ~:~ again

[20:10] <chip> ow.

[20:10] <autrijus> or just .id == .id

[20:10] <autrijus> please don't write it as   =id=

[20:10] <chip> Well, I think =:= is staying referential equality.  Nobody wants to lose that

[20:10] <autrijus> you mean, whether they point to the same container

[20:10] <chip> I suggested infix:<equiv> but nobody's really happy with that

[20:11] <autrijus> so 3 =:= 3 won't make any sense

[20:11] <chip> yes, =:= for same container

[20:11] <autrijus> well, we can rule that it makes sense, but I'd rather not.

[20:11] <chip> Right, no sense, because it may or may not be true at implementation's whim

[20:11] <autrijus> yup.

[20:11] <autrijus> so I'll just demand both side to be lvalues.

[20:11] <autrijus> easiest to unask the question.

[20:13] <chip> 1 eqv 1?

[20:13] <autrijus> sure.

[20:13] <autrijus> high typo rate though.

[20:13] <autrijus> different things looking similar.

[20:14] <chip> I like 1 equiv 1 , but luqui thinks it's too much typing for something he'd say often

[20:14] <autrijus> I don't think he will say often at all.

[20:14] <autrijus> I think huffman should penalize this.

[20:15] <autrijus> Java has == as eqv and .equals as eq

[20:15] <autrijus> globally considered as bad idea

[20:16] <autrijus> and all Java dialects switch them ;)

[20:16] <autrijus> s/all/most/

[20:16] <chip> Larry still wants "eqv", as shorthand for "equal by value"

[20:16] <autrijus> sure then.

[20:17] <autrijus> 1 iso 1

[20:17] <autrijus> "is object" and "isomorphic"

[20:17] <autrijus> bad idea, ignore

[20:20] <clkao> 1 orz 2

[20:20] <autrijus> 1 <> 2

[20:20] <autrijus> gwbasic rules

[20:23] <clkao> gwperl

[20:23] <clkao> etperl.rom

[20:30] <chip> luqui is suggesting that equiv is so important that it ought to be spelled "==".  Not getting much traction.  Fortunately.

[20:30] <autrijus> whew.

[20:31] <autrijus> please don't forget our blue collar roots, where I'd very much like coercion everywhere and == denotes numeric coercion.

[20:31] <autrijus> increase manipulexity is good but only if gradually :)

[20:37] <autrijus> okay, I need to sleep. g'nite

[20:38] <autrijus> chip: I've put the writeup to http://use.perl.org/~autrijus/journal/26160 -- corrections welcome as comments

[20:38] <autrijus> if the whim changes, I'll update the journal tomorrow

[20:38] * autrijus waves &

[20:44] <autrijus> chip: oh. do we get

[20:44] <autrijus> gtv ltv lev gev

[20:44] <autrijus> for generic ordering? ;)

[20:44] <autrijus> &

[21:04] <chip> luqui has made a suggestion that generic ordering is a Good Thing, but we're right now considering to what extent Set does Hash

[21:05] <mugwump> Set does Map, Hash does Map perhaps?

[21:06] <chip> that's closer to what he meant, I think

[21:06] <integral> sets don't map (mathematically thinking)

[21:06] <chip> Yes they do;  object => boolean

[21:06] <chip> for membership

[21:06] <mugwump> sure they do, integral, they map identity

[21:07] <integral> hmm!

[21:07] <coral> what

[21:07] <coral> i said that in one channel

[21:07] <coral> and irssi put it in two!  pardon the ww

[21:09] <chip> food

[21:09] <chip> &

[21:11] <mugwump> Actually the differences in answer there are worth considering.

[21:12] <mugwump> Does a Set map identity ?  ie ($x => $x), or ($x => Bool)

[21:12] <integral> hmm, sounds a wee bit more like there's a map that can be derived from it,  but it's not a map itself

[21:12] <integral> mugwump: in the former, what is the d

[21:12] <integral> what is the domain in each case?

[21:13] <mugwump> The difference is that the boolean can represent the absence of particular members

[21:13] <mugwump> which is important if you are interested in inverting the set

[22:58] <chip> mugwump: Set maps $x to 1 for all $x (E) @set

[23:08] <chip> autrijus: still up?

[23:10] <brentdax> You know what would be useful?

[23:10] <brentdax> `eval $var, :lang<Perl6qq>`

[23:11] <luqui> and that would refer to your lexical scope?

[23:12] <brentdax> Yeah.  It'd be like saying `eval "qq($var)", except you wouldn't have to worry about escaping the delimiters.

[23:12] <brentdax> `eval "qq($var)"`

[23:12] <luqui> right... I suppose that would be useful

[23:13] <luqui> is there a module that does that in p5?

[23:13] <luqui> if not, it would probably be about four lines long

[23:14] <brentdax> Don't think so, but with closure interpolation, Perl 6 strings are a good deal more powerful than Perl 5 ones were.  (I've said before that I don't think Perl 6 will need an ASP-style templating language...)

[23:15] <brentdax> (And yes, I know about @{[]}, but that's cheating.)

[23:15] <luqui> it will eventually get one (or ninety) anyway

[23:16] <brentdax> True, but at least I'll be able to go "haha, that's silly" and use `eval :lang<Perl6qq>` instead.

[23:17] <luqui> well, I'm sure nobody's opposed to it

