[00:01] <dudley> vkon: last I heard, pmichaud (the guy writing PGE) had been swamped with $work

[00:02] <dudley> so PGE development has slowed down

[00:02] * stevan_ thinks maybe exposing luqui to functional languages was a bad idea ;)

[00:03] <vkon> luqui: I was tempted adding proper code into PGE within parrot, but I fear I can't do all that properly...

[00:04] <stevan_> vkon: it is always worth a try

[00:04] <stevan_> vkon: that's what VCS is good for,.. if it doesnt work... roll back

[00:04] <vkon> :) may be I'll give it a try :)

[00:04] <stevan_> vkon: any code is good code at this point, especially if pmchaud is not able to work on it

[00:05] * Supaplex hears vkon crack all his nuckles *pop* *pop*

[00:05] <Supaplex> I'd say he's ready :)

[00:08] <luqui> stevan_, why?

[00:09] <luqui> the fmap thing?

[00:09] <stevan_> yes :)

[00:09] <stevan_> dont get me wrong,.. I like it

[00:09] <luqui> I was thinking that before I was exposed to Haskell.  I just knew what to call it now :-)

[00:09] <stevan_> and I like the general direction Haskell has made your brain go in

[00:09] * luqui does too :-p

[00:10] * fglock_ should learn Haskell some day

[00:10] <stevan_> I guess I mostly fear the "neverending spec"

[00:10] <luqui> yeah, we've all been fearing that about perl 6

[00:10] <dudley> Everyone should learn Haskell some day.

[00:10] <stevan_> bah, Haskell if just for PhDs who cant get real jobs ;)

[00:11] <luqui> my guess is that perl 6's spec will be finished when the implementation becomes mature enough that people start using it a lot

[00:11] <luqui> it's happening now

[00:11] <stevan_> LOL

[00:11] <stevan_> I've worked on projects like that

[00:11] <fglock_> I started a PhD - but unfortunately not in CS

[00:11] <stevan_> the implementation *is* the spec

[00:12] <stevan_> fglock_: in what?

[00:12] <luqui> oh, you mean perl 5?

[00:12] <luqui> :-)

[00:12] <fglock_> medicine

[00:12] <luqui> that's not really what I was referring to

[00:12] <stevan_> Dr. fglock_ ?

[00:12] <fglock_> yes

[00:12] <fglock_> my MsC was in CS

[00:12] <luqui> it's just that once perl 6 gets mature, people will focus their energy on screwing with the language through modules rather than through politics

[00:13] * stevan_ does his best groucho marx imitation "Is there a doctor in the house".... 

[00:13] <luqui> it's a lot easier to just write a module that implements my proposals than trying to argue with Damian :-)

[00:13] <stevan_> luqui: isn't that how you do it now?

[00:13] <luqui> yeah, I write perl 5 modules to show that it's doable and that I want it for perl 6

[00:13] <luqui> once I start writing the modules in perl 6 (which is too frustrating for me right now)

[00:14] <luqui> I really don't think I'll care whether it's in the "core language"

[00:14] <stevan_> fglock_: interesting education track there

[00:14] <fglock_> actually "off track"

[00:14] <luqui> except for things that I think are flat-out wrong like the former MMD semantics

[00:15] <stevan_> luqui: well MMD semantics really have to be in the core IMO

[00:15] <stevan_> you cant write them in modules and expect the performance to be acceptable

[00:16] * luqui wonders how things are faster when you don't write them in modules

[00:16] <luqui> I don't really see a difference

[00:16] <luqui> I just see the fact that I don't really care about performace

[00:16] <luqui> which is why C::MM::P is slow

[00:17] <luqui> but I believe that it could be made pretty fast

[00:17] <luqui> esp. with eg. a C backend

[00:17] <stevan_> luqui: well,.. I am making the assumption that if it is in the core, it can take advantage of certain optimizations 

[00:17] <luqui> ah yes

[00:17] <luqui> well, I want Perl 6 to be pluggable-optimizable too :-)

[00:18] <stevan_> luqui: well a proper type system would help make C:MM::Pure fast too :)

[00:18] <luqui> so you'd just use an optimization module

[00:18] <luqui> stevan_, that's true

[00:18] <stevan_> ah yes... use optimizations;

[00:18] <luqui> the problem with that is a lot of optimizations will be backend-dependent

[00:18] <luqui> but that's okay i guess

[00:18] <luqui> if you want it to be fast, you run the one for which all the optimization modules are written

[00:19] <luqui> and if you need to use a different backend, tough luck

[00:19] <stevan_> or write your own 

[00:19] <stevan_> :)

[00:19] <luqui> yeah

[00:19] <luqui> bbiab

[00:19] <luqui> &

[00:22] <fglock_> thw wind stopped and the electricity is back :) 

[00:22] <stevan_> fglock_: where are you in the world?

[00:22] <fglock_> Brasil

[00:22] <stevan_> ah

[00:23] <fglock_> near Uruguay

[02:20] <risse> Can anyone help me understand how to send a normal UDP packet using only socket module?

[02:21] <obra> try #perl or #perlhelp

[05:00] <new-b> hello

[05:00] <luqui> hello new-b

[05:00] <new-b> hi luqui :)

[05:25] <gaal> morning!

[05:29] <new-b> hi gaal 

[05:30] <gaal> hola

[05:32] <gaal> oh, just read autrijus' last journal entry. ouch!

[07:28] <dduncan> that bites ... did he not do CD backups or such?

[07:58] <gaal> wow, this is really Bad Hardware Month. I just came to work after putting my home box in the shop

[07:58] <gaal> and my *work* computer is dead!

[08:05] *** scw_ is now known as scw

[08:08] <luqui> ?eval [1,2,3] >>+<< [4,5,6]

[08:08] <evalbot_6930> (5, 7, 9) 

[08:08] <luqui> ?eval [1,2,3] >>+<< [4,5,[6,7]]

[08:08] <evalbot_6930> (5, 7, 5.0) 

[08:10] <gaal> ?eval [1,2,3] >>+<< [4,5,[<a b c d>]]

[08:10] <evalbot_6930> (5, 7, 7.0) 

[08:10] <gaal> it's counting elements, isn't it.

[08:11] <luqui> yeah

[08:12] * luqui is actually much happier with this than with the specified "deep" semantics

[08:13] <gaal> oh, i didn't remember these existed.

[08:13] <luqui> "these" meaning "deep semantics"?

[08:13] <gaal> yes. what are they?

[08:14] <luqui> well, basically you have the identity:

[08:14] <luqui> ?eval 3 >>+<< [1,2,3]

[08:14] <evalbot_6930> (4, 5, 6) 

[08:14] <luqui> and then you just repeat that as you map deep structures

[08:14] <luqui> so [1,2,3] >>+<< [4,5,[6,7]] == [5,7,[9,10]]

[08:14] <luqui> recursively defined

[08:15] <gaal> ah

[08:15] <luqui> what bugs me about that is if you're programming generically, and you just *happen* to get a list in one of your lists, the semantics of hyper automatically change

[08:15] <gaal> i haven't grokked perl 6 dereferencing at all yet.

[08:15] <gaal> yes.

[08:16] <luqui> though I'm fine with deep semantics if they're swept off into a corner somewhere, like: my @a is deep

[08:16] <nothingmuch> hi ho

[08:16] <luqui> hi ho

[08:17] <gaal> heya nuffin

[08:22] * nothingmuch had a nice weekend

[08:22] <nothingmuch> hiking, and swimming, and other stuff

[08:47] <nothingmuch> luqui++; # hyper + fmap

[08:48] <new-b> hello

[10:39] <gaal> so, i need some haskell help porting the following data structure from c:

[10:40] <gaal> a linked list, where data can only be *prepended* to the list, but different pieces of code receive different head pointers

[10:41] <gaal> so that earlier code can see something like <bar baz>, and the next piece of code will see <foo bar baz>, and so on;

[10:41] <gaal> data is otherwise immutable;

[10:41] <gaal> and this has to be really efficient in terms of memory.

[10:42] <gaal> any ideas about how to do this?

[10:44] <integral> that sounds exactly like the built-in list []

[10:45] <gaal> is x:oldx efficient?

[10:45] <integral> It's built as: data List a = Cons a (List a) | Nil, and in C would look a bit like: struct List { void *data; struct List *next } with something like next == NULL as Nil

[10:45] <integral> gaal: yes, that just constructs a new Cons-cell

[10:46] <integral> everything is passed around by pointer (essentially)

[10:46] <gaal> good :)

[10:47] <gaal> I think it'll even be a [Int#] for real efficiency

[10:47] <gaal> this has to exist for every Exp, probably.

[10:47] <gaal> or whatever represents a "statement", i'm not sure.

[11:26] <autrijus> gaal: you don't need the explicit "#"

[11:26] <autrijus> GHC can optimize boxes away most of the time under -O

[11:26] <autrijus> and with help from -funbox-strict-fields

[11:26] <gaal> how come? the compiler needs to know whether to put a data* or a straight int, no?

[11:26] <autrijus> gaal: also, got your mail, thanks! I can leave at Feb 1st or so

[11:27] <autrijus> gaal: er, I was referring to Int# vs Int

[11:27] <autrijus> they are of same precision; Int# just drops the box

[11:27] <gaal> autrijus, yes: so isn't Int# a real int and an Int a pointer to an Integer struct of some sort?

[11:28] <gaal> re: Feb, cool! we still don't have final dates though.

[11:28] <gaal> for the conf that is.

[11:31] <integral> but the optimiser knows that sometimes the semantics of a "real int" and a "pointer to an int" are the same

[11:32] <gaal> I'm not really sure about it being an Int really. Ideally it should be a Val, so that lexical pragmas have total freedom in the kind of information they store for themselves, but that might be prohibitive.

[11:33] <gaal> ...and so we might only allow a bit vector of fixed size, like in MJD's trial patch.

[11:34] <gaal> how do i actually put the list in Exp, btw?

[11:37] <gaal> and is it a problem that there's no Exp type that maps to a "statement"

[11:37] <gaal> ?

[11:45] *** Aankh|Clone is now known as Aankhen``

[11:46] <autrijus> gaal: no, Int is just Int, with 32bit precition. so Int# is C's "int" and Int is a pointer to a struct with metadata part and a int

[11:46] <autrijus> gaal: there is a Exp type, Stmt

[11:46] <autrijus> that serves as a cons list of stmts

[11:46] <autrijus> but, I gotta run for a bit and go back to do more data salvage

[11:47] <autrijus> &

[11:47] <nothingmuch> ciao

[11:47] <nothingmuch> good luck

[12:25] <gaal> autrijus: I saw Stmts. Where can I hang actual metadata though? Change "Stmts !Exp !Exp" to "Stmts !Pragmas !Exp !Exp" ?

[12:47] <autrijus> gaal: either that or invent a "Pragma" node

[12:47] <autrijus> Similar to Cxt and Pos

[12:48] <autrijus> or you can hang pragma off the Syn node

[12:48] <autrijus> Syn "pragma" (Val ...) ()

[12:48] <autrijus> er

[12:48] <autrijus> Syn "pragma" [Val ..., node]

[12:48] <autrijus> improvise :)

[12:49] <gaal> :) this unfortunately still doesn't feel natural to me, but sure :)

[12:50] <autrijus> the "Syn"way is least natural and most broken

[12:50] <gaal> but is it really supposed to be on a Syn node?

[12:50] <autrijus> a Pragma node sounds best; you can then modify "unwind" to unwind Pragma

[12:50] <gaal> ah

[12:50] <autrijus> maybe we can unify Cxt, Pos and Pragma

[12:51] <autrijus> into an "annotation" note type

[12:51] <autrijus> Ann

[12:51] <autrijus> Ann !Ann !Exp

[12:51] <autrijus> data Ann = Pos ... | Cxt ... | Pragma ...

[12:51] <autrijus> that may or may not be overkill

[12:51] <autrijus> it's up to you :)

[12:52] <gaal> here's hoping my computer comes out of the shop - i don't have anything that can build pugs atm :)

[12:52] <gaal> well there's feather

[12:52] <gaal> feather++

[13:01] <svnbot> r6931 | iblech++ | * t/builtins/lists/{minmax,uniq}.t,

[13:01] <svnbot> r6931 | iblech++ |   t/builtins/arrays/{shift,pop,push,splice,unshift,end}.t:

[13:01] <svnbot> r6931 | iblech++ |   Added tests testing that 3.min/3.uniq/etc. does not work (but (3,).min etc.

[13:01] <svnbot> r6931 | iblech++ |   should, of course).

[13:01] <svnbot> r6931 | iblech++ | * t/builtins/lists/empty_list_in_map.t: Added some more tests.

[13:25] <svnbot> r6932 | iblech++ | * t/builtins/lists/one_elem_list_kv.t: Added try{...}-blocks so normal Pugs

[13:25] <svnbot> r6932 | iblech++ |   doesn't die.

[13:25] <svnbot> r6932 | iblech++ | * t/builtins/control_flow/try.t: Added tests for @array = try {...} and %hash =

[13:25] <svnbot> r6932 | iblech++ |   try {...}. Also moved the tests testing whether return() inside

[13:25] <svnbot> r6932 | iblech++ |   try{...}-blocks works to the end, as PIL2JS runs them twice (detailled

[13:25] <svnbot> r6932 | iblech++ |   explanation in the test).

[14:02] <_sublime> hello

[14:02] <_sublime> how do i use a regular expression to break this string '2005/08/25 10:12:01 GMT' into parts so i can pass them into a function and create a date object.

[14:03] <QtPlatypus> _sublime: What version of perl are you asking about?

[14:03] <_sublime> the latest

[14:04] <QtPlatypus> So perl5.something?

[14:04] <_sublime>  v5.8.7

[14:04] <_sublime> yes

[14:04] * QtPlatypus nods "You need to ask in #perl"

[14:05] <_sublime> ok

[14:05] <_sublime> thanks

[14:20] <svnbot> r6933 | fglock++ | * perl5/Array - fixed @a=(1,2,3) 

[14:20] <svnbot> r6933 | fglock++ |   - the error was caused by the pre-processing of parameters in Array AUTOLOAD

[14:26] <svnbot> r6934 | iblech++ | * Pugs.AST.Internals, Pugs.Bind:

[14:26] <svnbot> r6934 | iblech++ |   isNamed is set correctly now (i.e. it's False for normal positional

[14:26] <svnbot> r6934 | iblech++ |   parameters and True for "+" and "++" params).

[14:26] <svnbot> r6934 | iblech++ |   Testing t/subroutines/* indicates that this change is sane, i.e. all but one

[14:26] <svnbot> r6934 | iblech++ |   tests which worked previously still work.

[14:26] <svnbot> r6934 | iblech++ | * src/perl6/Prelude.pm: Trivial change so the Prelude gets rebuild (probably

[14:26] <svnbot> r6934 | iblech++ |   needed because of the isNamed change).

[14:26] <svnbot> r6934 | iblech++ | * t/subroutines/{splatty_in_caller_position,sub_ref}.t: unTODO/try

[14:32] <svnbot> r6935 | iblech++ | * t/01-sanity/07-try.t: Fixed a test number.

[14:32] <svnbot> r6935 | iblech++ | * t/data_types/lists.t: Added tests for \(...) (list of refs constructor) and

[14:32] <svnbot> r6935 | iblech++ |   pinged p6l again: http://www.nntp.perl.org/group/perl.perl6.language/23085

[14:32] <svnbot> r6935 | iblech++ |   (See the =begin more-discussion-needed'ed tests.)

[14:32] <svnbot> r6935 | iblech++ | * t/pugsbugs/io_finalize_part[12].t: skip if $*OS eq "browser";

[14:32] <svnbot> r6935 | iblech++ | * PIL2JS: PIL::Params: Respect the (since r6934 working) isNamed field.

[14:32] <svnbot> r6935 | iblech++ |   This means that t/pugsbugs/named_2_positional.t passes now.

[14:44] <svnbot> r6936 | fglock++ | * perl5/Array - added back some AUTOLOAD preprocessing

[14:45] <nothingmuch> next PIL project: PIL on Groovy (http://groovy.codehaus.org/)

[14:45] <nothingmuch> or Java

[14:46] <nothingmuch> but I guess Groovy ought to be easier to implement the runtime

[15:32] <dudley> nothingmuch: Have you looked at Scala?

[15:32] <nothingmuch> nope

[15:32] * nothingmuch has to leave though

[15:36] <rafl_> haskell-src-exts is in Debian now. Next step to total world domination: hs-plugins.

[16:32] <svnbot> r6937 | iblech++ | * util/smokeserv/smokeserv-server.pl: Show smoke details only when requested --

[16:32] <svnbot> r6937 | iblech++ |   the page is much more concise now.

[16:32] <svnbot> r6937 | iblech++ | * PIL2JS: PIL::*: Many "no warnings 'recursion'"

[16:44] <svnbot> r6938 | iblech++ | * t/var/my.t: Fixed plan.

[16:44] <svnbot> r6938 | iblech++ | * Test.pm: Fixed &dies_ok, &lives_ok, and &throws_ok:

[16:44] <svnbot> r6938 | iblech++ |   ok(..., $todo);         # wrong

[16:44] <svnbot> r6938 | iblech++ |   ok(..., :todo($todo));  # correct

[16:44] <svnbot> r6938 | iblech++ |   This error went unnoticed as 1) the normal runcore doesn't care about isNamed

[16:44] <svnbot> r6938 | iblech++ |   and 2) Pugs used to emit wrong isNamed properties. But, as 2) is fixed since

[16:44] <svnbot> r6938 | iblech++ |   r6934 and thus PIL2JS respects isNamed now, the bug was revealed.

[16:46] <putter> autrijus: I'm sorry for your loss.  The only upside I have found in such little deaths is they can help remind you what is important, and what not, and thus live life better for a time.

[16:46] <putter> fglock: thank you for fixing @a=(...)

[16:46] <putter> iblech: smokeserv layout improvements ++

[16:47] <putter> iblech: a couple of suggestions:

[16:47] <putter> leave off the column headers.  the data speaks for itself rather well.

[16:48] <putter> except when it is lieing.  PIR shows 60%.  The invisible context is that's 60% of half of a tenth of a percent.

[16:50] <putter> I suggest groveling over the smokes present, and pulling the largest test count for reference.   and including a distilled test report on the top line - one shouldnt in general hide the key data.

[16:58] <nothingmuch> pretty: http://projectoffset.com/downloads.html

[17:04] <putter> (sorry, phone call)

[17:09] <putter> so maybe  6.2.9  r6531  linux  28 Aug 2005 21:44 Sun  0%   3: 2 ok 1 fail 0 todo 0 skip 0 us

[17:09] <putter> as a top level line for PIR

[17:11] <putter> Pugs removed as null-info-content, time-seconds as not worth the ink, Sun moved after, so dates line up, except for month variation, where the staggering is actually informative,

[17:12] <putter> percent normalized against total tests,  and then the key data,  duration skipped because it is currently misleading, though perhaps it should go last, 

[17:12] <putter> on, and I forgot,  direct link to full smoke content, so maybe

[17:13] <putter>  6.2.9  r6531  linux  28 Aug 2005 21:44 Sun  0%   3: 2 ok 1 fail 0 todo 0 skip 0 us / 60 min Full >>

[17:13] <putter> thoughts?

[17:14] <putter> I'd be glad to hack it, but wanted to run it by you.  Though, since you wouldnt have to fake up data, I you wanted to... :)

[17:16] <putter> Key principles for these suggestions were:  ink which doesnt carry information content should go away; and expose the data, don't require digging.

[17:19] <putter> maybe distinguish release from repository by having the revision blank, or say "release", and keeping it at the head of the section, rather than having two sections, one release and one non.  the hierarchy is getting a bit cluttered

[17:20] <putter> or not.  the extra sections might be ok if the column headings went away.

[17:22] <putter> nothingmuch: pretty as in the page or game is pretty graphically?  in a ui sense?  ??

[17:23] <nothingmuch> putter: the movies are very impressive

[17:23] <putter> ah, ok

[17:24] <putter> doh, I left off UTC, so

[17:24] <putter> 6.2.9  r6531  linux  28 Aug 2005 21:44 UTC Sun  0%   3: 2 ok 1 fail 0 todo 0 skip 0 us / 60 min Full >>

[17:27] <putter> though if there ends up beeing a column key at the top of the page, the UTC can go since it's constant ink and thus can/should be refactored

[17:27] <putter> hi fglock_

[17:27] <fglock_> hi!

[17:30] <putter> running a last (hopefully) smoke with the Test.pm simple replacement.  hope to get the real Test.pm working today.  it was passing 08-test.t, but the test harness didn't like it at all.  every make test like complained about hating software! :)

[17:30] <fglock_> I'm still working on Array problems - I'm writing tests this time :)

[17:31] <putter> awesome.  one think I didn't expect was how few tests there seemed when viewed in detail, rather than in total.

[17:33] <putter> 10k tests sounds great, but when you write feature foo, and there are only 3 tests, and they each fail for some reason unrelated to foo, but hand test run, you realize there need to be many more tests. ;)

[17:34] <putter> though the downside of more tests is more to edit as spec changes.  the namespace changes, while desireable, mean a whole lot of code and doc are now non-spec.

[17:34] <fglock_> putter: I did a quick @INC hack - see bottom of ApiX.pm - should this be put elsewhere?

[17:35] <fglock_> btw - no, you can't easily convert p6 Array to p5 ARRAY, because of lazyness

[17:35] <putter> I haven't looked at it yet, but that's fine.  Cruft is accumulating, but that just means it's almost time for a cleanup pass.

[17:35] <putter> Does an array know if it's lazy or not?

[17:36] <fglock_> yes, you can test with $a->is_lazy

[17:36] <putter> for a non-lazy array, can one convert?

[17:37] <fglock_> but $a->is_infinite is more useful - if it is not infinite, you can do $a->flatten

[17:37] <fglock_> or just shift out elements until $a->elems == 0

[17:37] <fglock_> which is probably the sanest thing to do

[17:38] <putter> is there a non-mutating way to get a p5 array representing a p6 array?

[17:38] <fglock_> using tie, I think

[17:39] <putter> (putter meant to say:  is there a non-mutating way to get a p5 array from a non-lazy p6 array)

[17:39] <putter> ah,

[17:39] <putter> (putter meant to say:  is there a non-mutating way to get a p5 array _copy_ from a non-lazy p6 array)  ;)

[17:40] <fglock_> you can also use fetch, which is non-mutating (instead of shift, you mean?)

[17:40] <fglock_> but tie is better, because it is 2-way

[17:40] <putter> i was kind of hoping for a builting.  ->to_native_array()  or somesuch

[17:40] <fglock_> np, I can add that

[17:40] <putter> tie, in a universe of very slow things (method calls for instance), is very very very slow.

[17:42] <putter> but you are right.  especially for mutating primitives (hmm, do we really need them?), a my @a; $o->tie_to_p5_array(\@a); ...   could be nice.

[17:43] <putter> but perhaps we should try to avoid needing it first...

[17:43] <fglock_> oh, see the @INC implementation

[17:43] <putter> k

[17:43] <fglock_> I didn't tie @INC to p6, but the other way out

[17:44] <fglock_> which means @INC is not modified, and is still native and fast

[17:44] <putter> but a ->to_p5_array_copy() or whatever seems essential.  cant do p6_to_a()  without it. :)   hmm, should work on List's too.

[17:45] <fglock_> where is p6_to_a() used?

[17:46] <putter> @INC is generally associated with touching the filesystem.  one would have to try really hard to make an implementation so slow that it was of any significance compared with touching disk.  so its one place we dont need any optimization at all.

[17:47] <putter> hmm... checking...

[17:49] <fglock_> it looks like p6_to_a() was only needed for @INC after all - is this correct?

[17:49] <fglock_> in require() implementation

[17:49] <putter> p6_to_a and p6_to_l dont seem to be used anyplace but @INC handling in PrimP5 at the moment.  which makes sense as it seems they never worked. :)

[17:50] <fglock_> how about removing (commenting out) p6_to_a and p6_to_l ?

[17:50] <svnbot> r6939 | stevan++ | Perl6::MetaModel 2.0 -

[17:50] <svnbot> r6939 | stevan++ | * some more notes on Roles

[17:50] <svnbot> r6939 | stevan++ | * revised object model picture,... the number of circles now means something

[17:53] <putter> on the one hand, avoiding unecessary work appeals.  on the other, one-way functions are the bane of software engineering.  unless it is a large burden, I'd like to be able to get back from an Array, not just get to one.

[17:53] <putter> stevan: lol

[17:54] <fglock_> ok - I'll fix p6_to_a

[17:55] <putter> "bane" is too understated.  One-way functions, the "I couldn't think of a reason why anyone would want to do that, so you cant", is the fetid festering gangrenous pervasive self-inflicted wound of software engineering.

[17:55] <putter> ;)

[17:56] <fglock_> is it ok to return stringified things? deep-converting p6 structs to p5 would take a bit more work 

[17:58] <fglock_> OTOH, p6_to_a could return a ARRAY of p6 objects - that's straightforward

[17:58] <putter> "I'm sorry, the linker cant do that, the compiler unrecoverably threw away the needed information."  "Yes, the linker uses a simple look-up table, an array of a few pointers in memory.  You can read it with dl_foo.  What?  You want to write to the array?  Why would anyone want to do that?"

[17:59] <putter> grr.

[17:59] <putter> array of p6 objects would be great. :)

[17:59] <putter> sorry for bending your ear.

[17:59] <fglock_> :)

[18:02] <putter> do Array's support bind yet?  I notice a lot 3k+ of "argument to bind() must be a Scalar" errors in the log.  but perhaps that's poor code generation calling bind with a bogus argument.

[18:03] <fglock_> it does support - can you find a particular example?

[18:05] <putter> then it's probably just being called with undef or somesuch.  no biggy.  I just noticed it going by in the log.

[18:07] <stevan_> greating all 

[18:07] <stevan_> autrijus: I assume with the HD failure, we are not planning a release this weekend

[18:07] <putter> there are some in t/var/var.t, but I suspect chasing after specific error messages at this point is not the best way to spend time.

[18:07] <putter> stevan_!

[18:08] <svnbot> r6940 | iblech++ | util/smokeserv/smokeserv-server.pl: Incorporated most of putter++'s suggestions:

[18:08] <svnbot> r6940 | iblech++ | * Removed the table headers, as the contents are self-explaining.

[18:08] <svnbot> r6940 | iblech++ | * We don't display the seconds of the upload date any longer.

[18:08] <svnbot> r6940 | iblech++ | * Moved the weekday name to the end so things line up nicely.

[18:08] <svnbot> r6940 | iblech++ | * putter's idea to calculate the percentage of passed tests using the total

[18:08] <svnbot> r6940 | iblech++ |   number of tests as given by any other test (so PIR no longer shows up as

[18:08] <svnbot> r6940 | iblech++ |   passing 67%) does not work, as new tests are added over time and, more

[18:08] <svnbot> r6940 | iblech++ |   importantly, some backends don't run the tests in ext/.

[18:08] <svnbot> r6940 | iblech++ | * Minor padding adjustments.

[18:08] <stevan_> hey putter 

[18:12] <putter> iblech: great!

[18:12] <putter> iblech: couple of thoughts:  ;-)

[18:13] <putter> the system name can go away on the indivitual lines, now that one can see the section headings which give them

[18:16] <putter> my #1 priority is being able to see the data.  so a "3: 2 ok 1 fail 0 todo 0 skip 0 us" or even "3:2/1/0/0/0" is important.  I'd trade any other field(s) on the line to make room for it.  (btw, why is the table so narrow?)

[18:17] <putter> having 4 digits of % on the one-line display seems excessive.  NN% would make the big picture clearer, and one could always click on >> for more.

[18:18] <svnbot> r6941 | fglock++ | * PIL-Run - fixed p6_to_a

[18:19] <putter> but in priority order (#1 show breakdown numbers at top level, #2 provide a direct link to the full smoke, #3 provide some clue what % means).  on this scale, I don't think there's a #4.

[18:20] <putter> re #3, perhaps...

[18:20] <putter> what was a's estimate of the total number of tests needed for p6?

[18:21] <putter> say 20000, so one could do   50% 99%   as the line for pugs, and 0% 66%  as the line for PIR.  (where pugs is currently using 10k tests)

[18:23] <putter> otherwise the % number is problematic, even for intra-platform comparisons (ext/ vs non-ext/), and just about useless for inter-platform comparison.

[18:24] <putter> hey stevan_.  how goes mm2? ;)

[18:26] * putter think's to himself "I want Modules, Modules, Modules.  Packages, Classes, Roles and Modules.  Yaaaay, Modules!"  (with obvious tempo and inflection)

[18:29] <SamB> what are Roles?

[18:31] <luqui> SamB, http://dev.perl.org/perl6/doc/design/syn/S12.html

[18:31] <luqui> look about 1/3 of the way down

[18:32] <putter> ooo, the smokeserver evolves even as I use it... very neat...

[18:33] <putter> iblech, I actually liked your summary boxes, because they were an intermediate between "see the big picture" one-liners, and the "requires non-trivial examiniation" smoke headers.

[18:35] <putter> with the click downs, the one-liners can be terser, less cluttered, relying on the click downs to give the uninitiated a clue.  perhaps two links on each line, one for the full and one the old push-down?

[18:35] <putter> then

[18:35] <putter> 153.02 min  	16.52 % ok  	7172 total:  	1185 ok,  	5987 failed,  	2 todo,  	7 skipped,  	0 us

[18:36] <putter> could be

[18:38] <putter> oh, putter notices the site has improved while he typed...

[18:39] <putter> anyway, the thought was having the push down would permit the one-liners to be more obscure, if that seemed the best way to show the big picture.

[18:39] <putter> though if things end up in columns, then one could punt the column labels.

[18:40] <putter> and the "NN min", as the least useful bit of data, seems out of place at the front (left).

[18:41] <putter> feel free to say "thanks, putter.  that's it for today"  at some point. ;)

[18:44] <putter> fglock_: the recent changes (lexicals and control flow) seem to have both broken tests, and fixed tests.  the large drop in % is perhaps mostly due to regexps breaking.

[18:45] <putter> http://m19s28.vlinux.de/cgi-bin/pugs-smokeserv.pl

[18:45] <putter> I'm pondering whether to go ahead and make the Test.pm switch, and then see where things stand, or debug a bit first.

[18:45] <fglock_> does Test.pm works already?

[18:47] <putter> by itself, it did.  inside of test harness (make test),  it completely failed (with an odd message).

[18:49] <putter> oo, fglock_, if you wanted to replace  warn "Help!  How do I stringify Class into a class name?" in ApiX, that would be great :)

[18:49] <fglock_> ok

[18:51] <putter> hmm, that's new.   perl perl5/PIL-Run/crude_repl.pl -Iblib6/lib t/01-sanity/08-test.t  currently has a

[18:51] <putter> Fyi: Can't locate object method "push" via package "Perl6::Container::Array::Native" at /home/net1/perl6/pugsxpl1/perl5/PIL-Run/../Perl6-Container/lib/Perl6/Container/Array.pm line 513.

[18:51] <fglock_> @INC was a quick hack :)

[18:54] <putter> hmm.  so the reason for tying p6 @INC to p5 @INC was what?   putter doesnt think he understands the implications...

[18:54] <fglock_> p5 and p6 share the same @INC (but I don't know if that is desirable)

[18:55] <fglock_> what does Pugs do with Perl 5 @INC?

[18:57] <putter> hmm.  we still dont have a concept of how p6 and p5 namespaces interact, with the mm landing so heavily in p5 space.  or I'd be tempted to have a p6 @*INC and a p5...  @Perl5::INC ?

[18:57] <putter> re pugs, not sure.  checking..

[18:59] * putter realized just as he hit return that it would not be easy...

[19:00] <putter> how about @*INC and @Perl5::INC, and we'll worry about it later?

[19:02] <fglock_> ok - you can change the array name in Apix.pm, and it should just work

[19:02] <fglock_> @INC will be empty on start?

[19:04] <putter> The PrimP5 require() checks a few extra dirs (".",etc) in addition to @INC.  the -I's get pushed on @INC first.

[19:04] <putter> which is probably where the push() error comes from.

[19:05] <putter> oh, btw, i notices foo(*@a) didnt seem to be working.  not sure why.

[19:06] <fglock_> is the splat flag being set before calling Code->do() ? I'm not sure if this was implemented, but I think so

[19:08] <putter> splat flag?  that's probably it then.

[19:09] <rafl_> After the haskell-src-exts Debian package now also hs-plugins is packaged. I think I'll upload tomorrow. Now only parrot is missing to get a full-featured pugs into Debian. :-)

[19:11] *** GeJ_ is now known as GeJ

[19:11] <svnbot> r6942 | putter++ | ApiX.pm: moved tied p5 \@INC to Perl5::\@INC.  08-test.t passes (p6_to_a() is working).  fglock++

[19:11] <putter> oh, wow

[19:11] * putter considers switching to debian.... again...

[19:11] <fglock_> slurpy flag - see Code.pm, Perl6::Param->new(), line 134 - and bind_params() - line 270

[19:11] <putter> looking...

[19:12] <Juerd> putter: Just do it.

[19:14] <putter> ;)

[19:14] <putter> putter got stuck wondering why 08-test.t says  pugs: user error (Can't locate 5.004 in @*INC 

[19:17] <putter> there _are no_ 5.004's in pugs (well, in comments and talks and such).  something seriously odd is going on.

[19:17] * putter goes to do splat

[19:17] <fglock_> stevan: is there a way to get the class name from the class object in mm1 ?

[19:18] <fglock_> putter: s/splat/slurpy/ - my mistake

[19:20] <putter> f(*@a)  gets PILed as a 

[19:20] <putter> iblech: ooooooo,  prettttyyyyyy

[19:21] <putter> as a &f( &prefix:*(@a) )

[19:22] <putter> that is, a normal f application, with a single argument, the result of applying &prefix:* to @a.

[19:23] * putter never even thought of using color... sigh...

[19:25] <putter> btw,  make test-perl5  says

[19:26] <putter> t/01-sanity/01-tap.................................hate software so much.

[19:26] <putter> t/01-sanity/01-tap.................................dubious

[19:26] <putter>         Test returned status 9 (wstat 2304, 0x900)

[19:26] <putter> which suggests we are trying to run perl5.  !?!?

[19:28] <putter> fglock_: re slurpy.  ah.  this is the other end...  sub f($x,$y){$x+$y}   @a=(3,4);   f(*@a)

[19:29] <putter> I'm not sure what officially happens.   &prefix:* returns a List?

[19:30] <putter> f(*@a,$b,*@c)  PIL's as f called with 3 arguments, *(@a), $b, and *(@c)

[19:31] <fglock_> putter: I think *@a returns a native array, that will be bound to $x and $y

[19:32] <fglock_> this may need some additional work 

[19:32] <putter> k

[19:33] <fglock_> p6_to_a may be useful here

[19:33] <svnbot> r6943 | iblech++ | util/smokeserv/smokeserv-server.pl: More de-optimizing for 640x480 (putter++):

[19:33] <svnbot> r6943 | iblech++ | * Display total/ok/failed/skipped/us directly at the top level, with colors.

[19:33] <svnbot> r6943 | iblech++ |   Also done s/ /&nbsp;/g so the layout doesn't break at 640x480.

[19:33] <svnbot> r6943 | iblech++ | * Added a second >> link which points directly at the full smoke report (this

[19:33] <svnbot> r6943 | iblech++ |   is not very user-friendly, suggestions?)

[19:33] <svnbot> r6943 | iblech++ | * Removed the osname column, as the os is already shown in the section heading.

[19:33] <svnbot> r6943 | iblech++ | * Minor alignment fixes.

[19:38] <putter> given that people have varied machines, I suspect the durations are not comparable anyway.  unless you know which items you yourself uploaded. ;)

[19:38] <putter> very nifty.

[19:38] <putter> re suggests, hmm... "full"?

[19:39] <putter> but actually I think the >> >> looks fine

[19:40] * putter starts to wonder if the "hate software so much" error messages are a suggestion, rather than an observation.

[19:42] <putter> oh, duh.  its not like pugs -B PERL5 was ever implemented...

[19:43] <putter> oh, so what were the thoughts on doing a pugs rapper?

[19:43] <svnbot> r6944 | iblech++ | PILJ2S: README: Added section about &prefix:<*> (splatty/flattening).

[19:44] <putter> timely reading...

[19:46] <putter> lol # @array but flatten_me

[19:46] <putter> thank you iblech :)

[19:48] <putter> strawman proposal: pugs renamed pugs_bin,  pugs becomes a perl5 script which calls pugs_bin.  thoughts?

[19:51] <putter> alternative, pugs exec's a pugs1 script when it gets -B arguments it doesnt know what to do with.

[19:53] <putter> upside, simpler change.  no issues of wrapper finding right version of _bin.  downside, bit of kludge.  cant easily augment normal pugs use.

[19:54] <autrijus> I like pugs_bin.

[19:54] <putter> hi autrijus

[19:54] <putter> ok, pugs_bin it is.

[19:55] <putter> any dissent?  reservations?  cautions?

[19:57] <fglock_> the purpose is to allow redirecting pugs to PIL-Run, for example?

[19:59] <autrijus> ^Wyes.

[20:02] <fglock_> will there be a separate PIL2Haskell? (just curious)

[20:09] <putter> fglock_: its more like there are a class of things, like forking to backends, or backend-independent argument and environment handling, that are more easily done in perl5 than in haskell.  once there is a layer of insulation, where things happen within "pugs", haskell, p5, p6, combinations, becomes a "mere implementation" issue.  pugs.hs would only need to break out pil2haskell if there was some reason it wanted to.

[20:12] <fglock_> k. nice idea, btw

[20:13] <putter> my experience writing windows-compatible distributions is limited.  can we write a simple "pugs" perl5 file, or do we need a install preprocessing opportunity to make portability work?  (eg, "pugs.in" massaged into to "pugs")

[20:14] <putter> err, pugs.exe, whatever.  do we need a .in?

[20:14] <putter> tnx

[20:15] <putter> it's come up before, so collective credit

[20:15] <fglock_> windows would need a pugs.bat in order for 'pugs' to work - I think the Makefile takes care of this (not sure though)

[20:21] <fglock_> putter: re stringifying a class name - $ref->{instance_data}{identifier} returns the long name 

[20:21] <putter> tnx.  I'll give it a chance to be simple and see what breaks.

[20:21] <putter> !:) 

[20:21] <fglock_> {name} is the short name

[20:22] <putter> If you haven't seen iblech's new smokeserv look, it's worth a look  http://m19s28.vlinux.de/cgi-bin/pugs-smokeserv.pl

[20:24] <fglock_> putter: thanks to ':5 use Data::Dumper' :)

[20:26] <putter> :)

[20:26] <fglock_> biab &

[20:28] <putter> k

[20:29] <putter> :5 does turn out to be very useful sometimes.

[20:31] <svnbot> r6945 | putter++ | ApiX.pm: p6_to_s() now work on instances of Class.  eg, p6_to_s(Num).  fglock++

[20:45] <putter> hey nothingmuch

[20:50] <nothingmuch> hi ho

[20:51] <putter> what are you up to nowadays?  forthing?

[20:51] <nothingmuch> no

[20:51] <nothingmuch> we had the rennovation business

[20:52] <nothingmuch> then my brain was shutdown for a week

[20:52] <nothingmuch> due to medication

[20:52] <nothingmuch> then we went on vacation

[20:52] <nothingmuch> and then it became today

[20:52] <putter> lol

[20:53] * dudley wishes he could speak of renovation in the past tense...

[20:53] <putter> pulverized cement, pulverized brain, pulverized rock?

[20:53] <putter> (sand)

[20:53] <nothingmuch> putter: what's next?

[20:54] * putter wishes he had something to renovate...

[20:55] <putter> don't know.  was wondering about that myself.

[20:55] <dudley> nothingmuch: Have you written much Groovy?

[20:55] <nothingmuch> dudley: no, i don't know it =)

[20:55] <nothingmuch> it just seemed to be the easiest way into JVM 

[20:56] <dudley> http://www.cabochon.com/~stevey/sokoban/docs/article-groovy.html

[20:56] <dudley> this article put groovy about fourth on my list of jvm languages to try

[20:56] <putter> improved object support, either on pugshs or pil2js, would be nice.

[20:57] <dudley> stevan and I were talking about implementing the mm2 in scala

[20:58] <dudley> but scala's lack of a decent unit testing framework killed that

[20:58] <dudley> so now I'm looking at Nice

[21:00] * Aankhen`` goes to sleep.

[21:01] <putter> big picture, parser->compiler->pil->backends...  parser - only pugs.  Parser.hs could use some cleanup and extension.  next big step is a p6 rules based parser.  requires rules.  PGE has been too buggy (failure to backtrack issue).  rules-on-prolog is another way to get there, at least temporarily.

[21:01] <Aankhen``> G'night.

[21:01] <putter> night

[21:03] <putter> compiler - only pugs. lots of work which could be done.  next big step is a p6 based compiler.  no-one has been trying lately, so its not clear what the issues are.  limited experience suggests big p6 things experience pain vis pugsbugs.  it would be nice to see someone try.

[21:04] <putter> pil - a's working on pil2.  I have no idea how imminent that is, or if there's anything one might do to help.

[21:04] <nothingmuch> i think we need to learn more about compilable units before this starts

[21:04] <nothingmuch> the semantics have many fine lines

[21:04] <putter> interesting

[21:05] <putter> could add -c -o  to pilrun :)

[21:05] <nothingmuch> -c -o ?

[21:05] <putter> -c foo.p6 -o foo.p5

[21:05] <nothingmuch> ah

[21:06] <putter> or to pil2js.  but the dynamism of both environments could obscure issues.

[21:06] <nothingmuch> right

[21:06] <nothingmuch> i think that the "real" compilable units are encapsulated PIL

[21:06] <nothingmuch> and that the PIL runner thingies need to implement runtime linking with well defined semantics

[21:07] <nothingmuch> and that we have to test that these semantics are sane where they weren't sane before:

[21:07] <nothingmuch> mod_perl

[21:07] <nothingmuch> WRT BEGIN, INIT, CHECK etc

[21:07] <nothingmuch> eval vs use

[21:07] <nothingmuch> in perl 5 it was a single imperative process modifying some runtime data

[21:08] <nothingmuch> which affected the compile time and the compile time of other code in ways that the compiler could not predict at all

[21:08] <nothingmuch> and we need to retain backwards compatibility to some extent

[21:08] <nothingmuch> but also make the semantics stabler, and easier for the compiler to eat

[21:09] <nothingmuch> so that the very complex semantics of perl 6 can be made to actually do math faster than a human

[21:10] <putter> "PIL runner thingies" ++ :)

[21:10] <putter> I was toying with idea of going one level up from lazy languages, and trying a PIL compiler in a constraint language.

[21:10] <nothingmuch> =)

[21:13] <putter> I worry a bit that we only have one oo-capable backend, which doesnt seem quite ready for really heavy use (eg, a compiler), and that is not really undergoing active development.

[21:13] <nothingmuch> stevan's work is very heavy development

[21:13] <putter> when piljs does oo, at whatever speed, I'll be much happier.

[21:14] <putter> right, but the rest of pilrun is very non-heavy-use-ready.

[21:15] <nothingmuch> well, i guess that the metamodel, once finalized

[21:15] <nothingmuch> or rather, once it feels finalized

[21:15] <nothingmuch> and once autrijus will be done with PIL2

[21:15] <nothingmuch> will be ported quite rapidly

[21:16] <putter> certainly whenever mm2 is runable, finalized or not, pilrun can switch.

[21:16] <nothingmuch> have you tried hacking it in?

[21:16] <putter> no

[21:16] <putter> stevan said "not yet"

[21:17] <nothingmuch> hmmm

[21:17] <nothingmuch> persuade him to hack in the delta to usability and clean it up later

[21:17] <putter> nah.  main point of pilrun at the moment is to _help_ the mm work, not to distract.

[21:18] <nothingmuch> heh

[21:21] <putter> the lack of robust oo means that to be productive, people write in other languages.  so the p6 core - a regex engine, a parser, a parsetree->pil compiler, gets defered.

[21:22] <nothingmuch> yup

[21:22] <putter> also things like a ruby->p6 frontend, which would help stress the pil semantics.

[21:22] <putter> err, not pil, but the what you desribed a moment ago.

[21:23] <putter> saying static things about dynamic code

[21:23] * nothingmuch really hoped more people would have commented on the linking thread

[21:24] <putter> oh, there's a sick thought.   pil2js can be run linked to perl.  how about pilrun compiling to p5 which is supposed to run with either itself, or pil2js?

[21:24] <integral> nothingmuch: hmm, what thread is that?

[21:25] <putter> err, s/run with either itself/run with a runtime of either pilrun or pil2js/

[21:25] * nothingmuch tries to find it

[21:26] <nothingmuch> do you mean compiling to perl 6

[21:26] <nothingmuch> and compiling that to js?

[21:26] <nothingmuch> if you mean compiling this module to js

[21:26] <nothingmuch> and that module to perl

[21:26] <nothingmuch> and running them together

[21:26] <nothingmuch> than it's the responsibility of a js/perl bridge

[21:27] <nothingmuch> and the responsibility of the compilers to integrate well enough to js and perl so that the bridge thinks it's running native code.

[21:28] <xinming> seen autrijus 

[21:44] <putter> nothingmuch: sorry, phone

[21:44] <nothingmuch> =)

[21:46] <putter> pilrun compiles to p5, which would naturally work with the pilrun runtime, but instead try to make it work with pil2js via a bridge.  the shape of the needed bridge tells you something about linking.

[21:47] <nothingmuch> hmm

[21:47] <nothingmuch> i

[21:47] <putter> ok, pugs as perl5 script is in.

[21:47] <nothingmuch> i think this is too hard a problem

[21:47] <nothingmuch> what i'd like to see is an API for loading PIL bits

[21:47] <putter> hasnt been tested on windows.  nor make install.  nor...

[21:47] <nothingmuch> where each PIL bit was compiled by a different process

[21:48] <nothingmuch> and where the beginings of static analysis can be made

[21:48] <putter> I image some shake down will be needed.

[21:48] <nothingmuch> for example a 'use optimize :static_subs'

[21:48] <nothingmuch> where each sub call is resolved as early as possible into a by value deref, instead of a by name one

[21:49] <nothingmuch> then we can start seeing where the boundries of static compilation as an excercise in caching can be darwn

[21:49] <svnbot> r6946 | putter++ | pugs is now a p5 script which calls pugs_bin.  Only limited testing - make test on linux.

[21:49] <nothingmuch> drawn

[21:49] <nothingmuch> when we start running tests against interpolated forms then we can learn what needs to be changed

[21:50] <nothingmuch> and because so much of the perl6 plan relies on good support for AST or IL transformations, when we can back port this support into PIL3, then we can *really* start writing good code meitters

[21:51] <nothingmuch> i'd also like to see the prelude/native bridge plan come out

[21:51] <nothingmuch> where the prelude is a circular implementation

[21:51] <nothingmuch> and the runtime says what pristine versions of prelude calls it implements natively

[21:53] <putter> is there a import exclusion-set concept?   so we could start having a common prelude now, and various backends could just import (-foo -bar)  their foo bar choices for primitives?

[21:53] <nothingmuch> i think this should be handled on a lower level

[21:53] <nothingmuch> each single code ref should have a "binary alternative" attribute

[21:54] <nothingmuch> prelude multimethods can have variants with or without backend implementations

[21:54] <nothingmuch> bits of the prelude like File::open that can't be "emulated" circularly are stubbed

[21:54] <nothingmuch> but have alternatives

[21:55] <nothingmuch> the test suite ensures that all the backends implement the prelude with the same semantics as the prelude itself

[21:55] <putter> what are the first steps to move in that direction?

[21:56] <nothingmuch> so, for example &infix:<*> (Int $x, Int $y) { $x + ($x * $y-1) }

[21:56] <nothingmuch> that way * is defined in terms of + and -

[21:56] <nothingmuch> ofcourse, parrot will say that * on two ints is simply the native opcode

[21:56] <nothingmuch> and * on two Nums is more more complicated

[21:57] <nothingmuch> the things that are needed are a high level API for static binding of parameters

[21:57] <nothingmuch> and a code object with attributes

[21:57] <nothingmuch> and introspection methods to allow the runtime to load the PIL for the prelude

[21:57] <nothingmuch> annotate it with it's native operations

[21:58] <nothingmuch> (this will need versioning for functions, because bug fixes need to be ported)

[21:58] <putter> hmm

[21:58] <nothingmuch> now, once we have this code emission can be generalized a bit

[21:59] <nothingmuch> PIL functions that static analaysis shows have not been overridden (This can be omitted initially) are replaced with opcodesD

[21:59] <nothingmuch> non opcodes are translated

[21:59] <nothingmuch> or simply stored as PIL and interpreted

[22:00] <nothingmuch> i think this is a sane model because it's very supportive of incremental changes

[22:00] <nothingmuch> for example, to add an opcode for for loops you annotate &control_structure:<for>;

[22:01] <putter> emphasizing _first_ steps, it sounds like a the creation of a greatly expanded prelude.p6, yes?

[22:01] <nothingmuch> yes

[22:01] <putter> that would be neat.

[22:01] <nothingmuch> with a very heavy emphasis on correctness

[22:01] <nothingmuch> quality testing

[22:01] <nothingmuch> that is a reference implementation of perl 6 in perl 6

[22:02] <nothingmuch> this is how it's tested:

[22:02] <putter> pil2js and pilrun are currently roling their own p6 preludes (in addition to their primitives of course).  it would be nice to combine and extend.

[22:02] <nothingmuch> to test the p6 prelude you use any runtime, and compile it to that VM

[22:02] <putter> s/primitives/things implemented using primitives/

[22:02] <nothingmuch> but allow only a minimal set of opcodes

[22:02] <nothingmuch> if you randomize the minimal set enough times

[22:02] <nothingmuch> and the tests keep passing

[22:02] <nothingmuch> then your IMPL is OK

[22:03] <putter> ;)

[22:03] <nothingmuch> to test a runtime against itself you do the same for it's opcodes vs it's other opcodes vs vanilla prelude

[22:03] <nothingmuch> or against another runtime 

[22:03] <putter> so, where should the new prelude.p6 go?   perl5/ ;-)

[22:03] <nothingmuch> with or without the same function swapping

[22:03] <nothingmuch> heh

[22:03] <nothingmuch> where it is right now

[22:03] <nothingmuch> but it must grow a whole lot

[22:04] <putter> src/perl6/Prelude.pm  needs to continue working (well) with pugs.  which is actually an painfully strong constraint.

[22:04] <nothingmuch> and it must implement silliness such as &infix:<+> (Int $x, Int $y) { inc($x) + dec($y) }

[22:04] <nothingmuch> &infix:<+> (Int $x, 0) { $x }

[22:04] <putter> growth in particular is a problem

[22:05] <nothingmuch> &infix:<+> (0, Int $y) { $y }

[22:05] <nothingmuch> hmm

[22:05] <nothingmuch> i think Prelude.pm could simply import the functions from e.g. Prelude::Math::Integral into the global namespace

[22:06] <nothingmuch> btw, with my understanding of the pugs internals

[22:06] <nothingmuch> which is not too updated

[22:06] <nothingmuch> the pugs model should support this annotation quite easily

[22:06] <nothingmuch> instead of missing functions in the prelude where there are pugs builtins

[22:07] <nothingmuch> the builtins are actually stored in the data structure of stuff like 'sub &infix:<+> ($x, $y) { ... }' [sic]

[22:07] <nothingmuch> and then that code can be filled in

[22:07] <nothingmuch> does this sound sane at all?

[22:08] <putter> pondering...

[22:11] <nothingmuch> let me ask a question:

[22:11] <nothingmuch> does this model not support any of the things you guys are doing right now?

[22:12] <putter> I'm leary of anything non-optional which affects pugs_bin, as it is a common dependency of everything else.  Precompiling the Prelude was added because speed of loading the raw p6 became an issue.  Anything which involves other p6 files in the prelude will thus likely first have to deal with precompiling them too.

[22:13] <nothingmuch> well, we don't have to make it grow just yet

[22:13] <nothingmuch> an incremental plan

[22:13] <nothingmuch> add support for opcode annotations without changing the prelude

[22:13] <nothingmuch> make it translate to the current representation of prims

[22:14] <nothingmuch> then implement replacement of prelude functions with opcodes

[22:14] <nothingmuch> as an optional feature

[22:14] <nothingmuch> and implement several Prelude functions as pugs-hs builtins to test

[22:14] <nothingmuch> then gradually add sub foo { ... } for each builtin

[22:14] <nothingmuch> and change the hard coded internal representation to use that

[22:15] <nothingmuch> when that's done make the internal representation more like the annotation model

[22:15] <putter> performance concequences?

[22:15] <nothingmuch> ~2 more pointer derefs for each prim on the haskell side

[22:15] <svnbot> r6947 | fglock++ | * perl5/Array - fixed (1..Inf).reverse 

[22:15] <svnbot> r6947 | fglock++ |   - the error was in Array.str after all

[22:15] <nothingmuch> incremental

[22:16] <fglock_> PIL-Run passes 16/30 of t/data_types/lazy_lists.t

[22:16] <nothingmuch> what I hope this does give us is things like DBD::PurePerl being DBD

[22:16] <nothingmuch> annotated with runtime dependant versions

[22:16] <nothingmuch> and I also hope it gives us the ability to clean up the mess of builtin functions

[22:17] <nothingmuch> like putting 'eval_yaml' in Prelude::Deprecated

[22:17] <nothingmuch> and annotating that into the haskell binding to Syck

[22:17] <nothingmuch> untill a "true" YAML for perl 6 is out (at which point the Syck binding can simply be moved)

[22:18] <nothingmuch> does this make more sense now?

[22:18] * putter wonders why crude_repl.pl in head is missing things he's sure he committed...

[22:18] <putter> I'm afraid I'm not entirely following the proposal, let alone understanding it's implications.

[22:19] <putter> try doing a local branch in svk?

[22:19] <nothingmuch> no chance i'm that competent

[22:19] <nothingmuch> and I don't have enough time

[22:19] <putter> the big common prelude file sounded like a nice idea

[22:19] <putter> a place to start?

[22:20] <nothingmuch> i think the opcode replacing API is better

[22:20] <nothingmuch> how do you guys implement the prelude translation?

[22:20] <nothingmuch> how do you guys implement &infix:<+>?

[22:22] <putter> my understanding is neither pil2js nor pilrun use src/perl6/Prelude.pm.  Each rolls its own.

[22:23] <putter> if you mean Prim.hs, again, each has its own mix of pure native code, p6 code with "inline" native code, and pure p6.

[22:24] <nothingmuch> okay

[22:24] <nothingmuch> so this is not far from what I'm proposing

[22:24] <nothingmuch> how does the definition of &infix:<+> look in pilrun?

[22:24] <nothingmuch> is it "native" in the sense that its "PIL::Run::Code->new(...prototype_info..., body => sub { $a + $b })"?

[22:25] <nothingmuch> because if you have that as a data structure, all I'm saying is that Prelude.pm should be annotated by the runtime

[22:25] <nothingmuch> and that a reference to the thing that implements &infix:<+> should be accessible via the code object of &infix:<+> in the prelude

[22:25] <nothingmuch> which really isn't that much =)

[22:27] <putter> perl5/PIL-Run/lib/PIL/Run/PrimP5.pm perl5/PIL-Run/lib6/P5Runtime/PrimP6.pm

[22:27] <putter> MULTI SUB infix:<+>  ($xx0,$xx1) { p6_from_n(p6_to_n($xx0) + p6_to_n($xx1)) };   in PrimP5.

[22:28] <nothingmuch> aha

[22:28] <nothingmuch> that was easy =)

[22:28] <nothingmuch> MUHLTI SUB is jsut 'sub MULTI' with a fancy prototype, right?

[22:28] <putter> pilrun doesnt have pil2js's nice Inline concept, so the body is actually p5, and the sig, which is p6,  source filter expands to whats needed to declare it.

[22:28] <nothingmuch> ah

[22:28] <nothingmuch> okay

[22:29] <nothingmuch> so what I'm saying is that pilrun should know for every opcode which prelude function it implements

[22:29] <nothingmuch> for starters

[22:29] <putter> pil2js has nice foo.p6 containing sub foo () { Inline::JS('...')() }  or somesuch

[22:30] <putter> opcode?

[22:30] <nothingmuch> opcode == builtin

[22:31] <nothingmuch> then when this cross index is completed the code builtin emitter thingy could load the prelude, compile the PIL code to use prelude.pm, and then go through the PIL code, and eliminate calls to the prelude, replacing them with calls to builtins, by resolving the prelude symbol and seeing if it has a native version

[22:32] <nothingmuch> ?

[22:34] <nothingmuch> canm someone please run t/rules/perl5.t and tell me if it terminates in under 5 minutes on a reasonable machine?

[22:34] <fglock_> pre-compiling prelude to pil would be a first step - is it possible?

[22:34] <nothingmuch> fglock_: what do you think of all this?

[22:35] <putter> perl5.t is about 6 on mine (pugs), and 10+ a bit (pilrun), and boom (pil2js)

[22:36] <nothingmuch> i have one that has had 1:37 of CPU time and didn't even output a plan yet

[22:36] <putter> 386 cpu?

[22:37] <fglock_> before optimization, '+' can be a Code object. after optimization, native p5 is necessary. but it makes sense, I think

[22:38] <putter> fglock_: re precompiling to pil, that wouldnt be difficult.  but pugs is currently not the speed bottleneck, at least for pilrun.  perhaps on pil2js.

[22:39] <putter> though it also isnt trivial.  but its going to be less than a 2x speedup.

[22:39] <putter> nothingmuch: so you were thinking of doing groovy?

[22:40] <nothingmuch> no, not at all

[22:40] <nothingmuch> it was just "someone, please look"

[22:40] <putter> ok.  i'm confused.

[22:40] <nothingmuch> fglock_: that's exactly what I wanted... the before optimization and after optimization distinction should be a language semantic, not only an optimization

[22:40] <putter> s/i'm/i was/

[22:41] <fglock_> nothingmuch: I'm rereading the irc log - can you summarize in a few words what problem this solves? (introspection, etc?)

[22:42] <nothingmuch> several points:

[22:42] <nothingmuch> * should make writing a backend simpler

[22:42] <nothingmuch> implement the minimum that your backend needs and reference implementation of prelude.pm can fill in the rest with slow but correct code

[22:42] <nothingmuch> * unifies approach towards compiling to opcode driven VMs

[22:43] <nothingmuch> the code emitter could be a generalized superclass in p6

[22:43] <nothingmuch> which just happens to emit code in js, p5, or whatever

[22:43] <nothingmuch> * opens door to optimizing certain things for speed

[22:44] <nothingmuch> for example, if I want to write a perl module for the perl/parrot/js/whatever runtime of the future, i should be able to provide native allternatives easily

[22:44] <nothingmuch> the interface remains the same, since it must be callable from everywhere

[22:44] <nothingmuch> but the perl 6 code that can be compiled to parrot and js or something completely different

[22:45] <nothingmuch> should have the option of easily including a PIR alternative if i want it to run fast on runtime foo and i'm willing to make the effort

[22:48] <nothingmuch> an example of how people are doing this today in perl 5 is http://search.cpan.org/~abw/Template-Toolkit-2.14/lib/Template/Stash/XS.pm

[22:48] <nothingmuch> i think it should be more incremental

[22:48] <fglock_> the runtime loads it's native libs, and then loads Prelude, except for the subs that are already defined natively - right?

[22:48] <nothingmuch> allowing partial optimization

[22:48] *** chibiryuu is now known as chibiryuu`gone`

[22:48] <nothingmuch> no, it loads the entire prelude and links to it

[22:49] <nothingmuch> then it iterates the PIL structure

[22:49] <nothingmuch> and resolves all the sub calls that it can

[22:49] <nothingmuch> in the future the inferrencer should do this more safely and smartly

[22:49] <nothingmuch> whenever it can be sure of a call going to a particular code ref, it checks if that code ref has a native alternative

[22:49] <nothingmuch> if it does, it uses that

[22:50] <nothingmuch> if it doesn't it compiles a hard call to the code ref

[22:52] <nothingmuch> ping?

[22:52] <fglock_> pong :)

[22:52] <nothingmuch> is this clear enough?

[22:53] <fglock_> yes - we need to add a linker - we don't have that yet

[22:53] <nothingmuch> exactly

[22:53] <nothingmuch> that's how this discussion started =)

[22:54] <fglock_> whether we link bytecode or pil doesn't make much difference

[22:54] <nothingmuch> i think the linker should link high level structures

[22:55] <nothingmuch> so it should be PIL or something with a compatible enough interface

[22:55] <nothingmuch> this is then passed to the optimizers

[22:55] <nothingmuch> which is then passed to the code emitter

[22:55] <nothingmuch> which might have optimziers of it's own

[22:55] <nothingmuch> and with some luck this is flexible enough to happen incrementally during runtime, interleaved with normal execution in order to increase responsiveness

[22:56] <fglock_> how about contributing a drawing to /docs ?

[22:57] <nothingmuch> i'll make an attempt

[22:57] * nothingmuch fires up bundled version of omnigraffle for the 2nd time in his life

[23:02] <nothingmuch> iblech: smoke server wants rss

[23:04] <nothingmuch> huraah! parrot issues fixed: http://m19s28.vlinux.de/iblech/stuff/pugs-smokes/pugs-smoke-6.2.9-r6945-darwin-normal--1126479788-3708--10114-9454-660-1337-231-0--68af4e20c83b953b15e7bd35f6bc3a0d.html

[23:07] <svnbot> r6948 | putter++ | pugs: initial support for -B perl5 and -B JS.  There is still an issue of how runjs/pugsjs/crude_repl find their way back to pugs.  Currently, you still have to set your PATH correctly.

[23:07] <putter> nothingmuch: :)

[23:08] <nothingmuch> UGH! dduncan--

[23:08] <nothingmuch> broke my smoke loop since it updated itself with a conflict due to the space silliness

[23:08] <nothingmuch> *sigh*

[23:09] * nothingmuch ponders forcing it back to tabs

[23:09] <dduncan> sorry 'bout that

[23:09] <dduncan> its been a week though ...

[23:09] <dduncan> I didn't do any detabbing since last weekend

[23:09] <nothingmuch> right, and the script hasn't been running all that while, since some tests were hanging

[23:10] <nothingmuch> which just goes to show what a mess these kinds of changes due to working copies =(

[23:11] <dduncan> still, I only intended for that mass change to be done once ... from now on its up to individual sections to maintain themselves with the appropriate whitespace for their situation

[23:11] <nothingmuch> but why was it done in the first place?

[23:11] <dduncan> I consider the problem you faced to be the 1% exception, though

[23:11] <nothingmuch> what was so horribly wrong with the way things were?

[23:11] <dduncan> better maintainability

[23:11] <nothingmuch> *cough*

[23:12] <nothingmuch> i find spaces annoying to maintain

[23:12] <nothingmuch> some people don't

[23:12] <svnbot> r6949 | fglock++ | * perl5/Array - yet another try to fix Array.str

[23:12] <svnbot> r6950 | putter++ | pugs: minor correction

[23:12] <svnbot> r6951 | putter++ | pugs: untabbify

[23:12] <nothingmuch> that's just what it is, a user choice

[23:12] <dduncan> the problem with mixed tabs and spaces in the same file is that they display differently depending on who's looking at them

[23:12] <nothingmuch> not if they are edited consistently

[23:13] <dduncan> why would you indent some lines with tabs and others with spaces?

[23:13] <nothingmuch> no

[23:13] <nothingmuch> i would indent all lines in the same indenting format the file was in the first place

[23:13] <nothingmuch> the reason i'm upset is that my code, which i'm the only one who uses, the smoke loop, which I share for the purpose of reference

[23:13] * putter starts a fresh install, just to make sure he hasnt broken things...

[23:14] <nothingmuch> should not be broken by massive updates that have no value

[23:14] <dduncan> however, when I came along, greater than 90% of the files having tabs in them were mixed tabs and spaces ... there was only a handful with pure tabs

[23:14] <wolverian> http://www.jwz.org/doc/tabs-vs-spaces.html

[23:15] <dduncan> currently I recognize that makefiles must indent with tabs, but what other kinds of files require that?

[23:15] <nothingmuch> files that nothingmuch was editing in his working copy

[23:15] <nothingmuch> that were with tabs to begin with

[23:15] <nothingmuch> and well formatted

[23:15] <nothingmuch> which now have conflicts

[23:15] <nothingmuch> (due to conflicts they now have tabs, spaces and syntax errors instead of just tabs)

[23:16] <dduncan> you're welcome to reverse the change on those specific files in the repository, and then try to commit your work

[23:16] <nothingmuch> i won't do that because that will only make things worse off than before

[23:16] <dduncan> you would remove the tabs again after your changes

[23:17] <dduncan> that's just a temporary step so you avoid your conflicts

[23:17] <nothingmuch> i'd just really like to be sure that the next time someone wants to make a big change that affects the whole code base that someone would stop

[23:17] <nothingmuch> and ask people to try to do it incrementally as they check in files

[23:17] <dduncan> who would remember?

[23:17] <nothingmuch> no one

[23:17] <nothingmuch> but the point is - tabs and spaces don't matter

[23:18] <dduncan> and the issue was discussed on this channel in advance

[23:18] <nothingmuch> if it really would have bothered someone that a file is "unmaintainable" then they could fix it on the fly, and commit that

[23:18] <dduncan> everyone agreed that having spaces consistently was better

[23:18] <nothingmuch> i'm not sure everyone agreed that changing them all in one go was better

[23:18] <nothingmuch> many people bitched about this all week long

[23:19] <dduncan> most people were already using spaces from the start, only a minority weren't

[23:19] <dduncan> I was one of those minority

[23:19] <nothingmuch> it doesn't matter

[23:19] <nothingmuch> i really don't care if it's tabs or spaces

[23:19] <dduncan> the main thing is that one is consistent in the choice

[23:20] <dduncan> as I said, most files mixed both of them, which helped no one

[23:20] <nothingmuch> what I do care about is that if things are broken WRT horizontal whitespace, they could be fixed on the fly, carefully, and manually

[23:20] <nothingmuch> but files which worked, and were not inconsistent (or no one noticed they were inconsistent) aren't bugging anyone

[23:20] <nothingmuch> hence they are not broke, hence they should not be fixed

[23:20] <putter> then we're all set.  and dduncan's rollback concept is an easy way to merge changes which only affect a few files.  though it might be easier just to M-x untabbify your local file.

[23:21] <dduncan> they bug people who want to maintain them and indenting is inconsistent

[23:21] <nothingmuch> then those poeople will update them the next time it bugs them

[23:21] <nothingmuch> it's really much simpler, no headache, no fuss

[23:21] <nothingmuch> no breakage

[23:21] <nothingmuch> that's all i'm trying to get... a "yes, i see how this broke, i'll be more careful next time"

[23:22] <dduncan> I already recognized that before

[23:22] <dduncan> and said so

[23:22] <nothingmuch> you seem to keep trying to say "no, you're rong, just untabify and you'll be happy"

[23:22] * putter thinks this so isnt a problem.  Even if he hasn't pursuaded perl-mode to not use tabs, and has to remember to M-x untabbify.

[23:22] <dduncan> I also said how to work around the problem now that it is already caused

[23:23] <nothingmuch> i already worked around this problem... and i'll say it again: this isn't the point

[23:23] <dduncan> okay, I'll say it again ... I recognize that my large change did lead to some problems

[23:24] <nothingmuch> will there be any massive if/else cuddling or uncuddling, or parenthesis padding, or automatic assignment vertical alignment next week?

[23:24] <dduncan> no

[23:24] <dduncan> only with my own code

[23:24] <nothingmuch> okay

[23:24] <nothingmuch> =)

[23:24] <dduncan> the space thing was the only thing I was doing on a wide scale

[23:24] <dduncan> because it was the simplest and easily agreed on problem

[23:27] <svnbot> r6952 | fglock++ | * t/.../lazy_lists.t - fixed syntax

[23:27] <svnbot> r6953 | fglock++ | * t/.../lazy_lists.t - another syntax fix

[23:29] <putter> dduncan: so what are you working on nowadays?

[23:29] * nothingmuch really likes the crayon color picker

[23:29] <dduncan> mainly the Perl 5 versions of my Rosetta framework

[23:29] * putter tries to get a feel for what folks are up to...

[23:29] <dduncan> for databases

[23:29] <putter> ah

[23:29] <putter> right

[23:29] <dduncan> and eventually translating them to Perl 6y

[23:30] <putter> neat

[23:30] <dduncan> I just want to do a whack of stuff in Perl 5 first, so I don't have to translate all those fixes separately

[23:30] <putter> any idea what the timeframe is on starting p6?  any showstoppers?

[23:30] <putter> makes sense

[23:30] <dduncan> moreover, I'm making my Perl 5 look more like Perl 6, to reduce the maintenance later in having both versions updated in parallel

[23:31] <dduncan> hopefully I'll start translating SQL::Routine to Perl 6 within 2-4 weeks

[23:31] <dduncan> that's the most-core one

[23:31] <putter> in what way(s) are you making your p5 p6-like?

[23:31] <dduncan> I last translated it to Perl 6 around April-May

[23:32] <dduncan> whole bunch of ways ...

[23:32] <dduncan> 3-part version numbers ... already on CPAN

[23:32] <dduncan> use of 'only' for 'use Foo' statements, allowing all the same flexability

[23:33] <dduncan> Class::Std

[23:33] <dduncan> other various

[23:33] <dduncan> I have to go to lunch ... talk later

[23:33] <putter> "how to make your p5 code more p6-like" could make a good quickref/wikipage/article.

[23:33] <putter> later &

[23:35] <dduncan> P.S. At the same time, I'm making a whole bunch of changes inspired by Best Practices ... which are largely the same as making perl 6 like

[23:37] <putter> :)

[23:38] <putter> oh, drat.  make test uses /blib/script/pugs rather than /pugs

[23:39] <putter> so pugs -B perl5/js   tries to find them in /blib/script/perl5/... not /perl5/...

[23:45] <putter> iblech: any thoughts on the RightWay for pugs to find runjs and runjs to find pugs?

[23:46] <putter> or anyone?

[23:46] <putter> the callback can certainly be an environment variable

[23:46] <putter> but the call....  

[23:47] <putter> iblech: any object to runjs and jspugs being installed in blib/script/  ?

[23:47] <putter> makes editing a bit more of a pain

[23:52] <svnbot> r6954 | putter++ | PIL-Run: moved the simple and fast lib6/Test.pm to lib6_disabled/.  The real Test.pm now runs by default.

[23:52] <fglock_> putter++

