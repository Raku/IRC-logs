[00:01] <Shillo> Is the disk drive scratching all the time while you compile?

[00:02] * Shillo is scared of low-RAM machines. Get-more-RAM was the first upgrade I ever did.

[00:03] <mauke> yes, of course. the swap daemon uses like 70% cpu :-)

[00:04] <Shillo> :)

[00:13] * Shillo buh-links?! multi sub works?

[00:14] <Shillo> Neat. :)

[00:17] <mugwump> I found you can't really compile pugs on less than 256MB RAM

[00:19] <Shillo> Failed 14/229 test scripts, 93.89% okay. 38/3512 subtests failed, 98.92% okay.

[00:19] <Shillo> Last checkout.

[00:20] <dvtoo> has anyone built ghc 6.4 on any version of solaris?

[00:23] * Shillo heads to sleep. Later, all!

[00:25] * mugwump points dvtoo at #haskell

[00:31] <dvtoo> yeah, shillo mentioning bootstrapping just reminded me

[01:33] <pasteling> "revdiablo" at 66.218.36.163 pasted "anonymous subs as closures" (30 lines, 574B) at http://sial.org/pbot/9717

[01:33] <revdiablo> hey guys, I'm too lazy/unknowledgable to figure out for myself. is that a known problem?

[02:43] <mugwump> revdiablo: do you have pugs commit access?

[02:57] <machack666> anyone particularly familiar with pugs' internals?

[02:57] <TreyHarris> it is so odd to be writing Haskell again after 15 years.  Haskell was the language they taught in freshman CS 100

[02:57] <machack666> (that can answer a question)

[02:58] <obra> heh.

[02:59] <machack666> I'm trying to add closure traits to blocks, and I'm trying to find out how to associate arbitrary state with a particular block

[02:59] <machack666> We need to know if a FIRST {...} closure has executed already, for instance

[03:00] <machack666> because FIRST {...} and other closure traits are set at the block level, there must be some sort of storage per block which we can refer to

[03:00] <machack666> anyone care to point me in a direction?

[03:01] * TreyHarris points towards the Netherlands

[03:01] <machack666> north north east, then?

[03:01] <mugwump> I take it you've found the closure trait stuff in Parser.hs

[03:02] <machack666> yup, I'm trying to modify it to recognize all of the closure traits

[03:02] <machack666> instead of just BEGIN/END

[03:02] <machack666> I've got stubs which are supposed to fail with an error message upon parsing, and I'm trying to fill in the gaps

[03:03] <TreyHarris> machack666: from Seattle, I think Amsterdam is due northeast.  don't know where you are :-)

[03:03] <machack666> TreyHarris: Lawrence, KS

[03:04] <machack666> are exceptions working at the block level?

[03:04] <machack666> if so, I can use that as a basis.

[03:05] <mugwump> machack666: I'm guessing that the `data VCode' declaration in AST.hs is close

[03:05] <machack666> I'll take a look.  It doesn't help that I don't really know haskell... :)  But, what better way to learn?

[03:06] <mugwump> A tutorial would be a good start

[03:06] <machack666> I've read some...up on the basics, it just isn't flowing as fluidly as most languages I know

[03:07] <mugwump> yeah, me too.  must be a functional vs imperative thing

[03:07] <mugwump> I liked "two dozen short lessons", very interactive

[03:07] <machack666> so is subName only set for named blocks?

[03:07] <machack666> me too...it way easy to follow along

[03:08] <machack666> after I finished that, yaht was a little more comprehensible, up until about chapter 9...

[03:08] <machack666> figured it was time to jump in and get my feet wet

[03:08] <machack666> :)

[03:09] <mugwump> cool.  My plan is twoDozen -> TAPL :)

[03:09] <TreyHarris> http://www.haskell.org/tutorial is pretty good.  well, it was good as a refresher for me... i guess i'm slightly an odd case :-)

[03:09] <mugwump> it's been on hold for a bit though, been busy with chansmartialarts.com and Perldoc

[03:09] <mugwump> and abit of work

[03:10] <machack666> work is good when you can get it.

[03:10] <machack666> or, more precisely when you don't need to...

[03:10] <mugwump> o/~ and you can get it, if you submit... o/~

[03:11] <machack666> do you know enough about the data structure types?

[03:12] <machack666> is a null string (), [], or something else?

[03:12] <mugwump> er, "" I think.  Which should be the same as []

[03:12] <mugwump> However, the former implies the type

[03:13] <machack666> I guess I shouldn't care if a sub is named or not -- it shouldn't affect the traits which are applied

[03:13] <mugwump> I think the name defaults to "&?"

[03:13] <mugwump> at least, that's how I read that bit

[03:13] <machack666> however, it looks like LAST {} and NEXT{} apply only to loops

[03:13] <machack666> is that a special perlvar?

[03:14] <mugwump> I doubt it :)

[03:14] <machack666> I see, a local sub with no name

[03:14] <mugwump> it's probably just to name the debug output work

[03:14] <mugwump> s/name/make/

[03:14] <machack666> isn't the trigil "?" a runtime flag?

[03:14] <machack666> compared to "*" for compiletime

[03:14] <mugwump> I'd have to consult the bible

[03:15] <machack666> the Book of Larry, Synopsis 02, Verse 12: Variables

[03:15] <machack666> or something

[03:15] <machack666> ...:)

[03:15] <mugwump> S28 actually, but yeah :)

[03:16] <machack666> show why going off of memory is a bad idea for me...

[03:16] <mugwump> $* must be run time

[03:16] <machack666> yes

[03:16] <mugwump> $? being compile time makes sense, too

[03:16] <mugwump> S28 is still only in pugs as a draft

[03:16] <machack666> well, one's one and one's the other.  I forget which

[03:18] <machack666> do you know what the definition of successful vs unsuccessful block exit is?  Seems like it would be whether we died() or not...

[03:19] <mugwump> not sure.  sounds like a reasonable assumption it's nothing to do with the return value, though

[03:19] <TreyHarris> would last be successful or unsuccessful?

[03:19] <mugwump> successful

[03:19] <mugwump> imho

[03:20] <machack666> i agree

[03:20] <machack666> we would also run the LAST {} block, as well as LEAVE {}

[03:20] <mugwump> should be just like jumping to the end of the loop and the condition being false

[03:20] <mugwump> sure

[03:21] <mugwump> so, FIRST, NEXT, LAST only apply to loops, but LEAVE applies to all blocks?

[03:21] <machack666> I'm going to see if there is a strict block execution order

[03:21] <mugwump> what about loops that never run once?  Do any of their subs get run?

[03:21] <machack666> s04: LEAVE at every block exit time

[03:22] <machack666> mugwump: like lazily evaluated subs that are never called?

[03:22] <machack666> or do you mean a while () where the while condition evaluates to false?

[03:23] <TreyHarris> LEAVE should only happen if you entered the block... so if the loop never runs, you shouldn't run LEAVE.  i think. :-)

[03:23] <mugwump> LEAVE is actually an 80186+ instruction :)

[03:23] <mugwump> I think for a loop, LEAVE and NEXT would be very similar, if that analogy holds

[03:24] <mugwump> the way I see it, LEAVE is called when the current pad is destructed.

[03:24] <machack666> I see LEAVE as being the total exit from the block

[03:24] <crysflame> when execution transfers to that which is beyond the scope of the block, LEAVE will have been called directly prior?

[03:24] <machack666> i.e., ENTER ( NEXT, NEXT, NEXT) LEAVE

[03:24] <machack666> is there a strict ordering defintion in S04 or A04?

[03:25] <machack666> because if there isn't, that would be a useful thing to get information about

[03:25] <mugwump> crysflame: yes, but each time you run the closure of the loop you're entering a block

[03:25] <mugwump> especially noticable when you write it like: for @foo -> $bar { }

[03:25] <crysflame> beyond the scope of the loop block

[03:25] <machack666> can closure traits have closure traits?

[03:25] <crysflame> so my imagination has a full block surrounding for {}

[03:26] <crysflame> implement LEAVE as { for @foo -> $bar { } LAST {} }

[03:26] * crysflame shrugs

[03:26] <mugwump> this is why we have LAST :)

[03:26] <machack666> i.e. sub myfunc { foo() or die ; UNDO { FIRST{"myfunc died.  Don't do it again."}} }

[03:27] <mugwump> sure, why not.

[03:28] <machack666> let's see... VCode's subPad --- is this purely the snapshot of the lexicals at this point?

[03:29] <machack666> if I'm wanting to store some data about the block, it seems like this is (unfortunately) not the place to stick it

[03:29] <TreyHarris> machack666: Larry at one point said on p6-l that the ordering is FIFO on entrance, LIFO on exit.  whether he later retracted, i have no idea :-)

[03:30] <mugwump> machack666: I'm wondering whether they would actually be properties of the loop AST node

[03:30] <machack666> TreyHarris: I'm wondering as much about the order of the various different traits

[03:31] <machack666> mugwump: that works for the loop-scoped traits, but what about ENTER or any other closure-scoped traits?

[03:31] <machack666> is a simple block just a loop node without the loop?

[03:32] <revdiablo> mugwump: no I don't have commit access

[03:33] * revdiablo responds an hour later

[03:33] <mugwump> yes, correct, machack666 - they're traits/properties of the things they hang off

[03:33] <mugwump> heh, revdiablo, I've added your test to the pugs test suite

[03:34] <mugwump> you'll need to ask an admin for commit access - see the openfoundry page for the list

[03:34] <revdiablo> ok, thanks

[03:34] <stevan> revdiablo: whats is your email, I will give you access

[03:34] <revdiablo> is that something known to be not working?

[03:34] <mugwump> there's one now

[03:34] <revdiablo> stevan: [email@hidden.address]
[03:34] <mugwump> revdiablo: it is now ;)

[03:34] <stevan> :)

[03:34] <revdiablo> mugwump: :)

[03:34] <revdiablo> smilefest

[03:35] <mugwump> I suspect probably, in an indirect way.  but your test is perfect for inclusion.

[03:36] <stevan> revdiablo: your invite is on the way

[03:36] <revdiablo> stevan: excellent

[03:36] <stevan> please remember to add you name to the AUTHORS list as well 

[03:36] <stevan> welcome aboard

[03:36] <revdiablo> thanks

[03:36] <machack666> I'm not seeing loop in AST.hs

[03:37] <machack666> looks like enterLoop is defined in Monads.hs

[03:37] <stevan> mugwump: did I read you are working on Perldoc?

[03:38] <mugwump> yes, I am ... http://svn.kwiki.org/ingy/Perldoc/

[03:38] <machack666> hmm...ruleBlockLiteral looks like it is just a block constructor

[03:39] <mugwump> There's several constructors for loop-like things

[03:39] <mugwump> which doubtless need to be refactored into a single loop class for this

[03:39] <machack666> stevan: do you know much about the internals?

[03:39] <stevan> mugwump: does this include kwid? 

[03:39] <mugwump> yes, of course

[03:40] <stevan> machack666: sorry no

[03:40] <stevan> machack666: my Haskell book is in the mail :)

[03:40] <mugwump> I'm doing the infrastructure and ingy's doing the parser ... I think he's a bit behind on committing his changes though, he sounds like he's been busy

[03:40] <stevan> mugwump: ahhh, ok

[03:41] <stevan> machack666: I actually was going to start documenting some of the internals to help learn them

[03:41] <stevan> mugwump: so do you have any thoughts on when we will have a functioning kwid parser/converter? or should I just ask/bug ingy?

[03:42] <machack666> I'm trying to figure out how to attach closure traits to the blocks, but I don't know if I need to modify the VCode structure to add some sort of state-tracking

[03:42] <mugwump> yeah, I'm working on trying to compress "XML in a nutshell" into the system :)

[03:42] <machack666> i.e., these are the blocks to run upon entry, this one has run already, etc...

[03:43] <stevan> machack666: you should ask nothingmuch about this

[03:43] <machack666> is nm about?

[03:43] <stevan> he implemented .assuming 

[03:43] <stevan> nothingmuch: ping!

[03:44] <machack666> darn world-oriented time zones...

[03:44] <stevan> machack666: he is in israel, I am not sure what time it is there

[03:44] <machack666> substantially later

[03:45] <stevan> his AIM has been idle for 4 hours

[03:45] <stevan> but that doesnt mean much

[03:45] <machack666> I've run into him before, so we share some hours

[03:45] <stevan> and I sometimes question if nothingmuch ever sleeps :)

[03:45] <stevan> machack666: where are you?

[03:45] <machack666> Lawrence, KS

[03:45] <machack666> USA

[03:46] <stevan> William S Boroughs home town :)

[03:46] <machack666> yes, indeed

[03:46] <machack666> some lady who

[03:46] <stevan> machack666: look for nothingmuch around mid-day to early evening tomorrow

[03:47] <machack666> 'd been a "good friend" of his was just auctioning off a lot of his stuff.  Like napkins he'd signed and other miscellenous things

[03:47] <stevan> and actually autrijus might be up soon too

[03:47] <machack666> thanks for the info

[03:47] <stevan> weird, I am not sure I want an old Burroughs napkin :P

[03:47] <machack666> looks like retVerbatimBlock is where I probably want to start some modifications

[03:48] <stevan> machack666: no harm in trying, there is always svn revert :)

[03:48] <machack666> heh...:)

[03:54] <machack666> I've been reading Env as environment variables... is this actually execution environment?

[03:54] <machack666> in which case, envStash may be what I'm looking for

[03:54] <mugwump> that's probably a pointer to the current package's stash

[03:54] <mugwump> (was that too obvious to point out)?

[03:55] * mugwump & # work :)

[05:05] <chromatic> Anyone awake?  I have a question about inc::Module::Install.

[05:05] <stevan> hey chromatic 

[05:05] <chromatic> hey stevan

[05:06] <stevan> what can I help you with :)

[05:06] <chromatic> I just checked out a fresh copy of Pugs from svn and ran Perl Makefile.PL.

[05:06] <chromatic> Looks like load_extensions() loaded some .pm files under the .svn directory.

[05:06] <chromatic> I added a line to skip such directories in find_extensions() and things built properly.

[05:07] <stevan> odd

[05:07] <stevan> which directory?

[05:07] <chromatic> Is there something weird with the repository or was there a recent checkin that made this work?

[05:07] <chromatic> I had errors like:

[05:07] <chromatic> Uh, hold on.  That window disappeared.

[05:07] <mugwump> well, most of the core devs use svk which doesn't litter your working copy with crap ;)

[05:08] <chromatic> That's nice, but luddites like me should be able to use it too!

[05:08] <stevan> mugwump: I really need to start using svk too, I was craving it today since I was on the raod and away from net access

[05:09] <stevan> I have noticed some weirdness with builds myself

[05:09] <chromatic> syntax error at inc/Module/Install/.svn/props/Base.pm line 1, at EOF

[05:09] <chromatic> Compilation failed in require at inc/Module/Install.pm line 137.

[05:09] <stevan> I have to always make clean (which I usually do anyway) or the buidl fails

[05:10] <mugwump> going from svn to svk is dead simple

[05:10] <stevan> mugwump: I know, its a matter of taking the time to set things up

[05:10] <mugwump> 1. apt-get install svk (or local equivalent ;))

[05:10] <chromatic> Sure, but the recursing is wrong in the code.

[05:10] <mugwump> 2. svk depotmap --init

[05:10] <mugwump> 3. svk mkdir -m "my mirrors" //mirror

[05:11] <mugwump> 4. svk mirror http://svn.openfoundry.org/pugs //mirror/pugs

[05:11] <stevan> chromatic: is there really a Base.pm in you .svn/props dir? that is odd, it should be Base.pm.svn-work

[05:11] <mugwump> 5. svk cp -p -m "my local branch" //mirror/pugs //local/pugs

[05:11] <mugwump> 6. svk co //local/pugs

[05:12] <mugwump> then, to `update' working copy;

[05:12] <mugwump> svk pull

[05:12] <mugwump> to push changes back;

[05:12] <mugwump> svk push

[05:12] <stevan> chromatic: when was the last time you pulled from svn? or is this a completely fresh copy

[05:12] <mugwump> (er, after a svk commit)

[05:12] <chromatic> This is a completely fresh copy.

[05:13] <stevan> chromatic: what SVN version/OS?

[05:13] <chromatic> Hm, an old version of svn.  That's odd.

[05:14] <chromatic> Let me upgrade and see if that's still wrong.

[05:15] <stevan> chromatic: working on Test::Builder?

[05:15] <chromatic> That's right.

[05:28] * SM_ax has a problem with Hyper OP

[05:29] <SM_ax> (1,3,4,5) >>+<< 1; is fine while 

[05:29] <SM_ax> my @a = (1,3,4,5); @a >>+<<1; reports an error...

[05:30] <SM_ax> is this ok?

[05:39] <revdiablo> SM_ax: *@array >>+<< 1 # works

[05:40] <revdiablo> I dunno if it's supposed to work only with lists though

[05:43] <SM_ax> so in this case context must be specified explicitly..

[05:44] <Khisanth> how about @array >>+ 1 ?

[05:45] <SM_ax> this is not supposed to work

[05:58] <chromatic> Hm, works okay with a newer Subversion.  Bug closed.  :)

[06:02] <autrijus> ;)

[06:02] <autrijus> hey chromatic.

[06:02] <autrijus> rehi lambdacamels!

[06:02] <obra> hey autrijus 

[06:02] <mugwump> evening!

[06:02] <autrijus> mugwump: thanks, sync.pl restarted

[06:04] <autrijus> ooh T::Builder

[06:04] <autrijus> chromatic: you going to write it in a procedural way, or are you spelling out the minimal support for class/roles we need?

[06:05] <autrijus> chromatic: also, is it okay if I just assume that the perl6 trait system, in the internals is the same with the Fortress trait system? :)

[06:05] <chromatic> I'll use minimal class/role support.

[06:05] <chromatic> I haven't looked at Fortress in much detail.

[06:05] <mugwump> ouch, using "minimal", "class" *and* "roles" in the same sentence

[06:05] <chromatic> T::B isn't very complicated.

[06:06] <autrijus> chromatic: cool. care to audit t/oo/

[06:06] <mugwump> oh, you mean using as little of them as possible :)

[06:06] <autrijus> and pick the ones you think are immediately useful?

[06:06] <chromatic> Only as much as necessary.

[06:06] <autrijus> if you can do that, just remove the :todo status to them.

[06:06] <autrijus> that will make them fail, and make it more attractive to implement :)

[06:07] <chromatic> I'll look at them.

[06:07] <autrijus> chromatic++

[06:07] <chromatic> Right now I want to sleep though, so I'll see you all later.

[06:08] <nothingmuch> what? who? where?

[06:08] <autrijus> machack666: you can (and should) extend VCode to include a set of traits. I think.

[06:08] <nothingmuch> colloquy was bouncing in the dock

[06:08] <nothingmuch> what did you need, machack666?

[06:09] <autrijus> nothingmuch: machack666 wants to hack in closure traits like NEXT

[06:09] <autrijus> LEAVE

[06:09] <autrijus> etc.

[06:10] <autrijus> I think the way to go is extending VCode

[06:10] <autrijus> to add named closures

[06:11] <autrijus> subTraits :: Pad

[06:11] <autrijus> something like that.

[06:11] <autrijus> or as explicitly spelled fields

[06:11] <mugwump> will that work for loops, though?

[06:11] <autrijus> subNext :: [VCode]

[06:11] <autrijus> mugwump: sure, loops are just VCode

[06:11] <autrijus> all loops are just closures

[06:12] <autrijus> but I gotta run for work

[06:12] <mugwump> work?  it's like 2pm, no?  :)

[06:13] *** chady_ is now known as chady

[06:16] <nothingmuch> okay

[06:16] <gaal> the yaml harness doesn't explicitly sort tests before it runs them. i'm fixing that

[06:16] <gaal> but it might break some test analysers

[06:16] <Aankhen``> NOooooooooooOOOOOOoooooooooooOOOOO

[06:16] * Aankhen`` coughs.

[06:16] <nothingmuch> gaal: why do that?

[06:16] <Aankhen``> Sorry.

[06:16] <gaal> it might also fix some :)

[06:17] <gaal> eg. the wiki make test thing someone has

[06:17] <gaal> nothinmuch: so that i can diff two yaml runs

[06:17] * Aankhen`` finally gives in and updates Firefox to 1.0.3.

[06:17] <gaal> one from a pristine tree, and one from my hack tree

[06:17] <obra> sorting will make life easier long term, no?

[06:17] <gaal> and see what i broke.

[06:17] <nothingmuch> can't youu diff them now?

[06:17] <nothingmuch> i mean, FS sort order should work in theory

[06:17] <gaal> obra: imho yes; and there's always --shuffle if you wnat it explicitly.

[06:18] <gaal> sure i can diff now, but the diff sucks :)

[06:18] <gaal> i don't know why, but on my system two runs of a basically identical tree don't run in the same order.

[06:18] <nothingmuch> oh well

[06:18] <gaal> i'm sorting the names anyway.

[06:19] <nothingmuch> i reckon mj could just sort the YAML files and rediff

[06:19] <gaal> ie it is "FS sort order"

[06:19] <nothingmuch> or whatever the files he was diffing were

[06:19] <nothingmuch> they were just plaintexts, right?

[06:19] <gaal> mj is the wiki guy, yes?

[06:19] <nothingmuch> yep

[06:19] <gaal> i think he's just diffing make test

[06:19] <gaal> so this doesn't matter to him really

[06:27] <gaal> btw there's a funny bug in the harness

[06:27] <gaal> somehow get_smoker gets called twice

[06:27] <gaal> did you notice that?

[06:27] <gaal> i suppose that means _init is called twice.

[06:31] <jabbot> pugs - 2415 - Add test for function that returns a fun

[06:31] <jabbot> pugs - 2416 - adding some basic last and next tests, t

[06:31] <jabbot> pugs - 2417 - added myself as requested

[06:31] <jabbot> pugs - 2418 - adding single quotes around the got and 

[06:31] <jabbot> pugs - 2419 - adding the Pod-Stream-Parser back into e

[06:31] <jabbot> pugs - 2420 - adding mkirank and dragonchild to the AU

[06:32] <jabbot> pugs - 2421 - indent contents of block

[06:41] <jabbot> pugs - 2422 - * yaml harness sorts tests when we not i

[06:49] <bsb> Does "make ghci" work for others?  I get duplicate symbol for blkcmp

[06:49] <gaal> bsb: ok on msys

[06:49] <bsb> src/UnicodeC.o 

[06:50] <bsb> I'm using debian's ghc-cvs/unstable.  6.5

[06:50] <gaal> i'll start a linux smoke, will take a bit though.

[06:50] *** castaway_ is now known as castaway

[06:51] <bsb> this has been since I first tried it, a few days ago

[06:51] <gaal> s/smoke/build/

[06:51] <bsb> not a new problem

[06:51] <gaal> oh

[06:51] <bsb> ok

[06:52] <gaal> make ghci worked for me on linux

[06:52] <gaal> i was using ghc 6.4 from experimental

[06:52] <bsb> Not linking UnicodeC.o starts ok but dies in eval "1" 

[06:52] <bsb> <interactive>: src/Unicode.o: unknown symbol `u_iswdigit'

[06:52] <gaal> does make clean etc. not help?

[06:53] <gaal> no, i think you kinda need that obj file :)

[06:54] <bsb> yep, though I might sneak past

[06:56] <gaal> nothingmuch: ping

[06:56] <gaal> the yaml dump is about twice as big as it needs to be :(

[06:57] <gaal> we have dupes of everything in "events" and "deails"

[06:58] * nothingmuch arrives at work

[06:59] <castaway> mornin nothingmuch 

[06:59] <nothingmuch> morning

[06:59] <gaal> just in time :)

[07:05] <gaal> bsb: make ghci worksforme (ghc 6.4/debian )

[07:05] <bsb> Thanks gaal

[07:05] <bsb> I might back up to ghc6.4

[07:05] <gaal> try to clean up the tree with some tough love?

[07:06] <gaal> like co it from scratch? :)

[07:06] <gaal> also, fwiw, i preceded 'make ghci' with 'make optimized'.

[07:08] <bsb> I'll rebuild when I'm not doing anything, later tonight

[07:12] <nothingmuch> gaal: ping

[07:12] <gaal> bonk

[07:13] <nothingmuch> darcs pull Test::TAP::Model

[07:13] <gaal> some make targets fail for me on msys with: tests.out:LD_RUN_PATH="" ld2  -s Pugs.o  -o /c/wks/pugs/blib/arch/auto/Perl6/Pugs/Pugs.dll 

[07:13] <gaal> i don't have ld2!

[07:13] <gaal> ok

[07:13] <gaal> (that ok was to nm

[07:13] <gaal> )

[07:14] <gaal> darcs failed:  (scp) failed to fetch: Test::TAP::Model/_darcs/inventory

[07:14] <Aankhen``> 4/34 skipped: various reasons

[07:14] <Aankhen``> Very informative. =)

[07:14] <nothingmuch> mui grazie

[07:15] * gaal updates EU::MM

[07:15] <nothingmuch> Aankhen``: view the verbose output

[07:15] <nothingmuch> eh

[07:15] <nothingmuch> cd to your darcs copy of Test::Tap::Model

[07:15] <nothingmuch> and then 'darcs pull'

[07:15] <Aankhen``> 􏿽xABnothingmuch􏿽xBB: It's okay, I'm not really interested. I was just amused by the message.

[07:15] <gaal> duh!

[07:15] <nothingmuch> Aankhen``: Test::Harness goodness, eh?

[07:16] <Aankhen``> Oh, and I couldn't submit a patch for example.html because apparently it needs the module to be installed, which is not possible since one of the prerequisites refuses to install for me.

[07:16] <nothingmuch> which prereq?

[07:16] <gaal> nm, any chance of an svn mirror to T:*? i don't have darcs on the windows box.

[07:17] <nothingmuch> gaal: get a binary, it's trivial

[07:17] <nothingmuch> i really don't want to maintain an svn repo

[07:17] <Aankhen``> I think it was Test::TAP::Something.

[07:17] <nothingmuch> darcs is just normal HTTP

[07:17] <Aankhen``> Petal installed fine.

[07:17] <nothingmuch> Test::TAP::Model was released on the same day

[07:17] <nothingmuch> it's also mine

[07:17] <gaal> trivial is not instantaneous, nm.

[07:17] <nothingmuch> gaal: an SVN repo requires:

[07:17] <nothingmuch> 1) learning

[07:17] <nothingmuch> 2) installing

[07:17] <nothingmuch> 3) configuring

[07:17] <nothingmuch> 4) getting a mirror script

[07:17] <nothingmuch> ...

[07:17] <gaal> fine, be that way.

[07:18] <gaal> :p

[07:18] * nothingmuch is puzzled

[07:18] <nothingmuch> you can just wget -r it

[07:19] <gaal> i prefer not to do any p5 work on this windows box, because, for example, it can't compile xs.

[07:19] <bsb> Any haskelleiros about?

[07:19] <nothingmuch> bsb: sometimes i pretend to be one

[07:19] <nothingmuch> gaal: so why would you want it there at all?

[07:19] <nothingmuch> i don't see how an SVN repo would solve that

[07:19] <bsb> Could you cast an eye at a patch of mine (on the way..)

[07:19] <nothingmuch> sure

[07:20] <pasteling> "bsb" at 203.214.67.82 pasted "pick op patch in pugs prim" (19 lines, 857B) at http://sial.org/pbot/9719

[07:20] <bsb> fix for: /usr/bin/pugs -e 'say one(1,1).pick'

[07:20] <nothingmuch> is Set unordered?

[07:20] <nothingmuch> bsb: looks good afaict

[07:21] <gaal> nm, if i'm just puling fixes from you, i'd rather do it with an scm i already have. but okay; i'm installing darcs

[07:21] <bsb> yes, at least in the interface

[07:21] <nothingmuch> gaal: no need to install darcs

[07:21] <nothingmuch> you can just download the dir recursively

[07:21] <bsb> Also, Set.cardinality is decprecated in favour of Set.size according to my docs

[07:21] <bsb> Should I change that too?

[07:21] <nothingmuch> i think so

[07:22] <gaal> that's convenient. but i don't have wget (that works) on this machine. never mind, it'

[07:22] <bsb> Ok, thanks nm

[07:22] <gaal> i'll copy from the linux box.

[07:22] <nothingmuch> bsb: what about jall's non size=1

[07:22] <gaal> and yes, i don't like msys. :)

[07:22] <nothingmuch> what's the behavior there?

[07:23] <nothingmuch> and shouldn't any pick a random one?

[07:23] <bsb> Like all(1,2) ?

[07:23] <nothingmuch> all(1,2).pick -> ?

[07:23] <nothingmuch> any(1, 2).pick -> 1 or 2

[07:23] <nothingmuch> i think

[07:23] <bsb> Maybe, I was more trying to stop the bad head in one(1,1).pick

[07:24] <bsb> The rest should be as it was

[07:24] <bsb> Not sure what the official behaviour should be

[07:24] <nothingmuch> okay, so i think you should commit that fix

[07:24] <nothingmuch> all returns undef right now

[07:24] <nothingmuch> any picks a random one

[07:25] <nothingmuch> oh i see

[07:25] <nothingmuch> there are more op1Picks above your patch  ontext

[07:25] <nothingmuch> I say go ahead, bsb

[07:26] <bsb> I'll just finish some tests, then ci

[07:30] * nothingmuch has a go at wrap

[07:31] * gaal is disgusted at the slowness of msys's scp, pipes a tar to netcat

[07:31] <jabbot> pugs - 2423 - one(1,1).pick bug fix&test

[07:38] <Juerd> nothingmuch: I think pick makes sense only on any()

[07:39] <Juerd> Or perhaps only on one() :)

[07:40] <nothingmuch> Juerd: true

[07:40] <bsb> I agree

[07:40] <nothingmuch> my plan for .wrap:

[07:40] <Juerd> oooh

[07:40] <nothingmuch> VSub will also be a dually linked list member

[07:40] <nothingmuch> with an ID

[07:40] <Juerd> Chicken wrap with some pesto!

[07:41] <nothingmuch> sub names will have the top level wrapping in place

[07:41] <nothingmuch> no, that doesn't work

[07:41] <nothingmuch> subnames will have the original sub in place

[07:41] <Juerd> Why not just use a simple closure?

[07:41] <nothingmuch> but invokation of a sub who knows it's being wrapped will look upwards

[07:41] <nothingmuch> it is implemented with closures

[07:41] <nothingmuch> but it modifies the sub

[07:41] <Juerd> Add the original sub as a local variable and call that...

[07:41] <jabbot> pugs - 2424 - j(...) to convert junc -> string

[07:41] <nothingmuch> it doesn't return a wrapped version

[07:41] <Juerd> Oh.

[07:42] <nothingmuch> the problem is that references to the sub must be wrapped too

[07:42] <nothingmuch> i think

[07:42] <Juerd> nothingmuch: Then isn't changing the rules a better plan?

[07:42] <nothingmuch> Juerd: maybe, maybe not

[07:42] <Juerd> nothingmuch: Make it return a wrapped version, and use .= if you want modification

[07:42] <Juerd> This should IMnsHO be done consistently

[07:42] <nothingmuch> that sort of makes sense

[07:42] <nothingmuch> what happens here:

[07:42] <nothingmuch> my $subref = \&sub;

[07:43] <nothingmuch> &sub.wrap { blah };

[07:43] <nothingmuch> $subref.()

[07:43] <nothingmuch> sorry:

[07:43] <nothingmuch> &sub.=wrap { blah }

[07:43] <Juerd> Well, if you mutate the invocant, then it blahs

[07:43] <nothingmuch> okay

[07:43] <nothingmuch> so we have to change the semantics of entering a sub

[07:43] <Juerd> Don't make it too hard, and check the logic with simple scalars:

[07:43] <Juerd> my $scalarref = \$scalar;

[07:44] <Juerd> $scalar.=sqrt

[07:44] <Juerd> say $scalarref;  # square root of old $scalar

[07:44] <Juerd> eh

[07:44] <Juerd> $$scalarref there

[07:44] <nothingmuch> i think that makes sense

[07:44] <nothingmuch> but it doesn't really matter

[07:44] <nothingmuch> the question is what exactly is wrapping

[07:44] <nothingmuch> is it destructive or not

[07:45] <Juerd> It helps if you consider subs like normal variables: name, container and value are separate

[07:45] <nothingmuch> right

[07:45] <Juerd> Where the value is the body of the code plus the pad etc

[07:45] <nothingmuch> but if we do that ii think we are losing a bit with wrapping

[07:45] <nothingmuch> wait

[07:45] <nothingmuch> before i make a fool out of myself

[07:46] <Juerd> And mutation only applies to the value, not the container, as the container is the real invocant and you can't possibly exchange that without losing any more sanity.

[07:46] <nothingmuch> .=wrap <-- implications on value, or variable?

[07:46] <Juerd> value

[07:46] <nothingmuch> so it's not like &sub = sub { }

[07:46] <nothingmuch> right?

[07:46] <Juerd> "variable" is confusing because it can mean almost anything - I avoid its use when discussing semantics

[07:47] <nothingmuch> s/variable/container/

[07:47] <Juerd> Well, the problem with sub { } is that it has always returned a reference in Perl 5

[07:47] <Juerd> And that &sub was unassignable

[07:47] <nothingmuch> okay

[07:47] <nothingmuch> $i = $i + 5;

[07:47] <Juerd> This makes that &sub = subref has to dereference in order to make sense

[07:47] <nothingmuch> $i += 5;

[07:47] <nothingmuch> this is obviously different

[07:47] <Juerd> And the '=' always only copies value.

[07:48] <nothingmuch> \$i taken before would leave the first as it is, but change the second

[07:48] <Juerd> If it "copied" the container (which is impossible), it would be aliasing, which is done with ':='

[07:48] <nothingmuch> okay

[07:48] <nothingmuch> so how do .= semantics change the value of the invocant?

[07:48] <nothingmuch> (For a method that doesn't really know how to do that?)

[07:48] <nothingmuch> by being slightly more magical?

[07:48] <Juerd> Which would mean that (assuming a SANE '=:=', not like what Larry thinks he wants), !(&sub =:= whatever that sub { } was)

[07:49] <Juerd> nothingmuch: Why wouldn't it know how to do that?

[07:49] <nothingmuch> Juerd: my $obj = ...;

[07:49] <nothingmuch> $obj.clone_with_new_value($x);

[07:49] <nothingmuch> $obj.=clone_with_new_value($x);

[07:49] <nothingmuch> is that magically correct?

[07:50] <Juerd> I expect so

[07:50] <nothingmuch> okay

[07:50] <nothingmuch> and if i take a ref to sub

[07:50] <Juerd> Although.

[07:50] <nothingmuch> sub wrap_it_for_me ($subref) {

[07:51] <Juerd> I wouldn't know how it could be.

[07:51] <nothingmuch> sorry... is rw

[07:51] <gaal> nothingmuch, thanks for the Model fix, it helps

[07:51] <nothingmuch> $subref.=wrap { };

[07:51] <nothingmuch> }

[07:51] <Juerd> Or, well, it is magically correct assuming that you don't mind that $obj.id doesn't change.

[07:51] <nothingmuch> gaal: thanks for being flexible with darcs =)

[07:51] <gaal> i just used a proxy :/

[07:52] <nothingmuch> pulled to another box and then rsync'd or something?

[07:52] <gaal> yeah

[07:52] <nothingmuch> Juerd: okay, so assuming .wrap returns a closure, what happens here:

[07:52] <nothingmuch> my $sub = $original.wrap { foo };

[07:52] <nothingmuch> my $shiney = $sub.wrap { bar };

[07:52] <nothingmuch> # now i want to unwrap the  { foo } from $shiney

[07:52] <Juerd> Why do you make things harder by using references? :)

[07:53] <Juerd> 1: $sub gets a reference to { foo }, which calls &$original

[07:53] <nothingmuch> Juerd: give me a counter example without them please

[07:53] <Juerd> 2: $shiny gets a reference to { bar }, which calls &$sub

[07:53] <Juerd> nothingmuch: my &sub = &original.wrap:{foo};

[07:54] <Juerd> nothingmuch: my &shiney = &sub.wrap :{ bar };

[07:54] <nothingmuch> okay, same thing to me

[07:54] <Juerd> The colon is needed if you want to pass a block without using parens

[07:54] * nothingmuch likes the consistency of this

[07:54] <Juerd> nothingmuch: Same thing perhaps, but it saves 4 implicit (de)references, making discussing it easier :)

[07:55] <nothingmuch> suddenly i realized the subnames can also be lexical =)

[07:55] <nothingmuch> Juerd++; # enlightening

[07:55] <nothingmuch> okay

[07:55] <nothingmuch> i liked this property: $id = $sub.wrap :{ foo };

[07:55] <nothingmuch> sorry

[07:55] <nothingmuch> $id = &sub.wrap :{foo};

[07:55] <nothingmuch> $id2 = &sub.wrap { bar };

[07:55] <Juerd> The id thing is hard to use...

[07:55] <nothingmuch> &sub.unwrap($id);

[07:56] <Juerd> Yes, unwrap($id)

[07:56] <nothingmuch> but it's very flexible

[07:56] <Juerd> What happens if the $id passed is not the top level?

[07:56] <Juerd> It just splices one out there?

[07:56] <nothingmuch> then it just gets yanked out the middle

[07:56] <Juerd> I see

[07:56] <nothingmuch> i think so

[07:56] <nothingmuch> since we use a 'call' in there

[07:56] <Juerd> You can of course use:

[07:56] <nothingmuch> we don't really care who we are wrapping

[07:57] <nothingmuch> this is useful because it lets you do tracing wraps and then remove them without damage

[07:57] <nothingmuch> even in the context of other wraps

[07:57] <Juerd> &sub.=wrap(my &wrapthingy = sub { foo })

[07:57] <Juerd> &sub.=unwrap(&wrapthingy);

[07:57] <nothingmuch> ooh, nice

[07:57] <Juerd> Which also means that you can nicely use

[07:57] <Juerd> &sub.=wrap(&generic_subwrapper);

[07:57] <Juerd> &sub.=unwrap(&generic_subwrapper);

[07:58] <nothingmuch> and a wrapped sub could unwrap itself with &?SUB

[07:58] <Juerd> Where &generic_subwrapper can, for example, memoize!

[07:58] <nothingmuch> Juerd++

[07:58] <nothingmuch> it's much more consistent than ID

[07:58] <Juerd> And no less efficient, I think

[07:58] <nothingmuch> the only thing it doesn't let you do is wrap the same sub twice with the same wrapper

[07:58] <Juerd> PLEASE NOTE THAT my first example was wrong!

[07:59] <Juerd> Has to be:

[07:59] <Juerd> &sub.=wrap(my &wrapthingy := sub { foo })

[07:59] <nothingmuch> why does it matter?

[07:59] <Juerd> Otherwise you're copying the value, which should have no identity of its own

[07:59] <Juerd> AFAIK

[07:59] <nothingmuch> isn't &wrapthingy just a copy in both places?

[07:59] <Juerd> But Thomas Sandlass has been arguing that values have identity

[07:59] <nothingmuch> iin which case it's the same thing?

[07:59] <Juerd> I can't logically place that in a Perl perspective.

[08:00] <Juerd> nothingmuch: Assignment copies value, not container

[08:00] <nothingmuch> in perl5 values have identity: refaddr($ref); # id of thingy

[08:00] <nothingmuch> thingy in this context is referant

[08:00] <Juerd> nothingmuch: That's the container, not value!

[08:00] <nothingmuch> ah

[08:00] <nothingmuch> SCALAR(o123i7u3108951) is a container

[08:00] <Juerd> refaddr(\$scalar) does not change if you assign something new to $scalar!

[08:00] <nothingmuch> and \1 is a reference to an anonymous container

[08:01] <nothingmuch> i see

[08:01] <Juerd> Which means that the value's identity, if it has any, is certainly not visible in this way.

[08:01] <nothingmuch> but in your example &wrapthingy is a container

[08:01] <nothingmuch> doesn't the assignment return that?

[08:01] <Juerd> nothingmuch: Which has its own identity

[08:01] <nothingmuch> right

[08:01] <Juerd> Consider

[08:01] <Juerd> SUB = SUBREF

[08:02] <Juerd> SUBREF is dereferenced first

[08:02] <nothingmuch> so arguably your first example is correct, but it doesn't give sub { foo }, rather the container of a copy of it

[08:02] <Juerd> Because SUB cannot hold a reference, because it is not scalar

[08:02] <Juerd> Then, you have

[08:02] <Juerd> SUB = SUB

[08:02] <autrijus> that should be :=, btw.

[08:02] <Juerd> Which, in pseudo code, means

[08:02] <autrijus> not sure that assigning to &sub makes sense.

[08:02] <Juerd> SUB.value = SUB.value

[08:02] <Juerd> or indeed

[08:02] <Juerd> s/or indeed/

[08:02] <Juerd> s/$/\//

[08:02] <Juerd> autrijus: Indeed, that's what I'm arguing right now :)

[08:03] <nothingmuch> Juerd: before we get carried away:

[08:03] <nothingmuch> &sub.=wrap(&generic);

[08:03] <nothingmuch> &sub.=wrap(&generic); # again

[08:03] <nothingmuch> &sub.=unwrap(&generic); # ambiguous? last?

[08:03] <Juerd> nothingmuch: :nth(-1)

[08:03] <autrijus> you can't .= wrap

[08:03] <autrijus> that is not legal anywhere in synopses

[08:03] <Juerd> autrijus: I suggested changing wrap to un-mutating.

[08:03] <autrijus> at best you can

[08:04] <autrijus> &sub := &sub.wrap(...)

[08:04] <Juerd> autrijus: To be consistent throughout the language, and force use of .= for mutation

[08:04] <autrijus> Juerd: I think you are confusing levels.

[08:04] <nothingmuch> autrijus: we're changing the semantics =)

[08:04] <nothingmuch> autrijus: think of it this way:

[08:04] <autrijus> Juerd: "=" applies to the IScalar IType

[08:04] <nothingmuch> .wrap returns a closure

[08:04] <nothingmuch> wrapping is done in a special place in the pad it gets

[08:04] <autrijus> or IArray, or IHash

[08:04] <Juerd> As $foo.sqrt returns the sqrt without changing $foo's value, and $foo.=sqrt replaces $foo's value with the old $foo's sqrt.

[08:04] <nothingmuch> when you enter a wrapped sub, semantics change

[08:05] <nothingmuch> .wrap and .unwrap return closures

[08:05] <Juerd> autrijus: I am at language level *only*. That is my strength in finding logic.

[08:05] <autrijus> the .wrap is not destructive.

[08:05] <autrijus> who says it is destructive?

[08:05] <autrijus> it is never destructive.

[08:05] <nothingmuch> then what does it do?

[08:05] <autrijus> it returns the wrapped sub.

[08:05] <Juerd> autrijus: And at language level, all one has to deal with are names, containers and values

[08:05] <autrijus> s06 makes it quite clear

[08:05] <autrijus> the original sub is untouched

[08:06] <Juerd> autrijus: Not according to specs I read. It changes the invocant and returns an id.

[08:06] <nothingmuch> as I recall it treats every VSub as a sort of stack

[08:06] * Juerd goes to read s06

[08:06] * nothingmuch agrees with Juerd here

[08:06] <autrijus> oh. wow.

[08:06] <autrijus> I misread. my bad.

[08:06] <autrijus> and that is bad, bad, bad semantics.

[08:06] <nothingmuch> indeed

[08:06] <Juerd> autrijus: You read it the right way, it just wasn't written to be right :P

[08:06] * mugwump agrees on that

[08:06] <autrijus> that makes no sense.

[08:06] <Juerd> autrijus: Hence my suggestion to change things

[08:07] <autrijus> whomever written that is on the bad crack that is Hook::LexWrap.

[08:07] <nothingmuch> okay

[08:07] <Juerd> The madness with IDs leaves a very nasty taste with me.

[08:07] <autrijus> ok. let's revolt ;)

[08:07] <nothingmuch> how does unwrapping look like?

[08:07] <nothingmuch> if i take a heavily wrapped sub

[08:07] <autrijus> nothingmuch: easy; you can call &newsub.unwrap to retrive the unwrapped sub

[08:07] <nothingmuch> wait no, i'm making no sense

[08:08] <nothingmuch> autrijus: no, you get a closure with wrapping removed

[08:08] <Juerd> It makes me think of mirc scripting, irssi timers, TCl, filedescriptors and other low level crap we camelboys like wrapping in dwimmy objects.

[08:08] <nothingmuch> IMHO that works in all dimentions

[08:08] <nothingmuch> you can add and remove wrappings

[08:08] <nothingmuch> arbitrarily, in all directions

[08:08] <nothingmuch> and never reach an inconsistent state

[08:08] <autrijus> ok. when you see wrap, think taking a reference

[08:08] <autrijus> when you see unwrap, think dereference

[08:08] <autrijus> neither operation is destructive

[08:08] <autrijus> and there's no ID needed

[08:09] <autrijus> unwrap a sub that was never unwrapped returns itself.

[08:09] <autrijus> that's just that.

[08:09] <nothingmuch> no, because unwrrap is not a stack

[08:09] <nothingmuch> you can wrap a, wrap that with b, and  then unwrap a, and get onnly b

[08:09] <nothingmuch> okay

[08:09] <nothingmuch> what about &sub.=wrap(&a);

[08:09] <autrijus> er. what

[08:09] <nothingmuch> &sub.=wrap(&b);

[08:09] <nothingmuch> &sub.unwrap(&a);

[08:09] <autrijus> &sub := &sub.wrap(&a)

[08:10] <autrijus> &sub := &sub.wrap(&b)

[08:10] <nothingmuch> # is &sub wrapped now?

[08:10] <autrijus> &sub := &sub.unwrap

[08:10] <autrijus> that's what I'm getting at.

[08:10] <nothingmuch> i don't like a stack

[08:10] <nothingmuch> it makes wrapping less ninja

[08:10] <autrijus> did I hear ninja?

[08:10] <Juerd> nothingmuch: How about it can be a searchable stack?

[08:10] <nothingmuch> you can't unwrap in a lexical scope where you wrapped without maybe stepping on someone else's feet

[08:11] <autrijus> &sub := &sub.wrap(&a, :key<a>);

[08:11] <autrijus> &sub := &sub.wrap(&b, :key<b>);

[08:11] <nothingmuch> sub add_trace ($sub) { $sub.=wrap :{ say "entering"; call } };

[08:11] <autrijus> &sub := &sub.unwrap(:key<a>);

[08:11] <autrijus> happy?

[08:11] <Juerd> nothingmuch: unwrap(SUBREF) unwraps until it has unwrapped SUB, and then wraps all the other layers again. Same effect, only less efficient when doing weird ninja things noone normally does anyway.

[08:11] <nothingmuch> Juerd: okay

[08:11] <nothingmuch> that's the same as what I mean

[08:11] <Juerd> (Warning: guessing usage statistics)

[08:11] <autrijus> Juerd: I worry about identity.

[08:12] <nothingmuch> autrijus: i like that

[08:12] <nothingmuch> but i think you should be able to use either

[08:12] <nothingmuch> wrappings have an optional arbitrary key

[08:12] <Juerd> autrijus: &subref.id

[08:12] <nothingmuch> they can be unwrapped based on &sub being passed

[08:12] <nothingmuch> or the key that was choses at wrap time

[08:12] <Juerd> 0+$subref in Perl 5

[08:12] <nothingmuch> or with no arguments to pop one off

[08:12] <Juerd> (Assuming a .id method!)

[08:13] <Juerd> urgh, &sub.id of course

[08:13] <Juerd> Not *ref*.

[08:13] <nothingmuch> guys?

[08:13] <Juerd> I don't like a method called .id for all objects

[08:13] * nothingmuch neither

[08:13] <Juerd> Because that means you can no longer use that for your own schemes

[08:14] <autrijus_> hm, autrijus.org just went offline

[08:14] <nothingmuch> (key is optional)

[08:14] <Juerd> afk

[08:14] <nothingmuch> autrijus_: i think unwrapping semantics with a key don't conflict:

[08:14] <nothingmuch> err, idiot

[08:14] <nothingmuch> &sub.wrap(&sub);

[08:14] <nothingmuch> &sub should be two different things there

[08:14] <nothingmuch> &sub.wrap(&sub :key<a>);

[08:14] <nothingmuch> &sub.unwrap(&other); # finds first

[08:14] <nothingmuch> &sub.unwrap(:key<a>);

[08:14] <autrijus_> so.

[08:14] <nothingmuch> &sub.unwrap; # pops last

[08:15] <autrijus_> &sub.wrap({ ... anon closure ...})

[08:15] <autrijus_> there is no way to unwrap by that again, right?

[08:15] <autrijus_> since identities differ for all anon closures

[08:15] <nothingmuch> &sub.wrap({a anon } :key<closure>);

[08:15] <autrijus_> so you can't call it with a good key

[08:15] <nothingmuch> the code creating a wrap can do book keeping to make it sane

[08:15] <nothingmuch> or it could say:

[08:16] *** autrijus_ is now known as autrijus

[08:16] <nothingmuch> &sub.wrap(my &container := { anon });

[08:16] <nothingmuch> and anon is given an ID, right?

[08:16] <nothingmuch> i mean, we allow both ways

[08:16] <autrijus> for some reason I don't like this idea :)

[08:16] <autrijus> I think if you don't pass :key

[08:16] <autrijus> then you can't unwrap by name

[08:17] <autrijus> if you pass :key

[08:17] <autrijus> then you can always unwrap by name

[08:17] <nothingmuch> why should i make up a key if i know who the wrapper is?

[08:17] <nothingmuch> &sub.wrap(&generic_wrapper);

[08:17] <autrijus> because you really don't...

[08:17] <nothingmuch> &sub.unwrap(&generic_wrapper);

[08:17] <autrijus> the &generic_wrapper may itself change identity

[08:17] <autrijus> &generic_wrapper := ...something else...

[08:17] <nothingmuch> then other copies of it must be used to fetch it

[08:17] <autrijus> ok.

[08:17] <nothingmuch> but it's the user's problem

[08:18] <autrijus> let's agre that

[08:18] <nothingmuch> if someone destroys the wrapper they used as a key, why should the language be responsible?

[08:18] <autrijus> method wrap (Code &wrapper, +$key = &wrapper) { ... }

[08:18] <autrijus> happy?

[08:18] <nothingmuch> yes

[08:18] <nothingmuch> that's exactly what I wanted =)

[08:18] <autrijus> go ahead and make it so :)

[08:19] <autrijus> (and send S06 patch to p6l)

[08:19] <autrijus> viva la revolution, etc

[08:19] <nothingmuch> okay

[08:19] <nothingmuch> (btw, is the pad an first-class object?)

[08:19] <nothingmuch> so i plan to do it by adding the wrapper list into a place in the lexical pad

[08:19] <autrijus> nothingmuch: anything can be made a first-class object

[08:19] <nothingmuch> autrijus: first i'd like to know why you don't like &sub.=wrap(&foo);

[08:19] <autrijus> nothingmuch: do you want to access pad as a hash?

[08:20] <nothingmuch> i don't want it

[08:20] <autrijus> like %OUTER::<foo>

[08:20] <nothingmuch> not yet

[08:20] <autrijus> nothingmuch: ok.

[08:20] <nothingmuch> well, i do =)

[08:20] <autrijus> &sub .= wrap(&foo)

[08:20] <autrijus> stands for

[08:20] <nothingmuch> i was just wondering if it exists

[08:20] <autrijus> &sub = &sub.wrap(&foo)

[08:20] <autrijus> but

[08:20] <autrijus> pugs> &print = 123

[08:20] <autrijus> *** Error: Can't modify constant item

[08:20] <nothingmuch> Juerd: just spent 10 minutes explaining to me that .= is magical in that it doesn't do that

[08:20] <autrijus> and for good reason

[08:20] <autrijus> I don't see a reference to that magic.

[08:20] <nothingmuch> that it changes the value, not the container

[08:21] <nothingmuch> by example:

[08:21] <nothingmuch> @list = ....

[08:21] <nothingmuch> my $ref = @list;

[08:21] <nothingmuch> @list.sort;

[08:21] <autrijus> sort is not inplace

[08:21] <nothingmuch> @$ref <-- sorted?

[08:21] <nothingmuch> sorry

[08:21] <nothingmuch> @list.=sort;

[08:21] <autrijus> pugs> my @list = (3,2,1); my $ref = @list; @list .= sort; $ref

[08:21] <autrijus> (1, 2, 3)

[08:21] <nothingmuch> i remember that being used as an example where in place sort could optimize

[08:22] <nothingmuch> okay, so i think that's consistent with &sub.= wrap in the same way

[08:22] <autrijus> it is not :)

[08:22] <autrijus> $sub .= wrap()

[08:22] <autrijus> is sane

[08:22] <autrijus> &sub .= wrap()

[08:22] <autrijus> is less so

[08:22] <nothingmuch> i don't see the connection

[08:22] <nothingmuch> @ is akin to & here, no?

[08:22] <autrijus> no, because array supports STORE

[08:22] <Juerd> autrijus: A sub could too!

[08:23] <autrijus> Juerd: I don't see anywhere that it could

[08:23] <autrijus> Juerd: I'd much rather it could not

[08:23] <autrijus> it could not in p5

[08:23] <Juerd> But I agree that it might be much better to not allow this.

[08:23] <nothingmuch> &sub = sub { foo } ; # what does this do?

[08:23] <autrijus> nothingmuch: error -- assign to constant

[08:23] <autrijus> you'd have to use := throughout.

[08:23] <autrijus> the synopses are consistent on that manner

[08:23] <autrijus> and for once I agree :)

[08:24] <nothingmuch> so what about &sub.:=wrap ?

[08:24] <nothingmuch> that looks like one of those cheesy HTML <title>s in a hacker site

[08:24] <autrijus> I'm fine with that.

[08:25] <autrijus> but I still think &sub := &sub.wrap() makes most sense, fwiw.

[08:25] <nothingmuch> where is this stuff written?

[08:25] <nothingmuch> i would like to read thoroughly

[08:25] <autrijus> you mean distinction between := and = ?

[08:25] <nothingmuch> yep

[08:26] <nothingmuch> especially with IDs, copying, laziness, constants

[08:26] <nothingmuch> distinction between container and value

[08:26] <autrijus> s06 has something like that

[08:26] <nothingmuch> destructiveness of .= onto value

[08:26] <nothingmuch> btw, i think ~:= should also work

[08:26] <autrijus> oh, nothingmuch 

[08:26] <nothingmuch> *pause*

[08:27] <nothingmuch> my $str = "foo";

[08:27] <autrijus> &textfrom := &substr.assuming(str=>$text, len=>Inf);

[08:27] <nothingmuch> $str .= "foo"; # value?

[08:27] <autrijus> I like the equiv of .assuming vs .wrap

[08:27] <nothingmuch> $str = "${str}foo"; # same thing?

[08:27] <nothingmuch> $str := "${str}foo"; # value not modified?

[08:27] <nothingmuch> i think in the last two examples the value is not modified

[08:27] <nothingmuch> because it's copied

[08:27] <autrijus> uh, .= "foo" doesn't do what you think it does

[08:27] <nothingmuch> heh

[08:28] <nothingmuch> i meant ~=

[08:28] <autrijus> $str ~= "foo"

[08:28] <nothingmuch> but it's not modified in a different way

[08:28] <nothingmuch> p6 habit

[08:28] <nothingmuch> grr

[08:28] <nothingmuch> p5

[08:28] <autrijus> $str ~= "foo" ## means $str = $str ~ "foo"

[08:28] <autrijus> pugs> my $str = 123; $str := $str~"foo"; $str = 9

[08:28] <autrijus> *** Error: Can't modify constant item

[08:28] <nothingmuch> but $obj .= method does not always mean $obj = $obj.method;

[08:28] <autrijus> why? I maintain it always mean that

[08:29] <nothingmuch> array container

[08:29] <nothingmuch> okay

[08:29] <nothingmuch> is @list.=sort working on the list container?

[08:29] <nothingmuch> and in this case it's complicated because the container is an interesting kind of value in itself?

[08:30] <nothingmuch> my $one = @list;  my $two = list;

[08:30] <nothingmuch> @list.=sort;

[08:30] <nothingmuch> @list = @list.sort

[08:30] <nothingmuch> what is @$one and @$two in either example?

[08:31] * nothingmuch coughs loudly

[08:32] <bsb> autrijus: what investigation does "if (has_ghc_package('readline'))" need in Makefile.PL?

[08:33] <nothingmuch> my god! pugs is fast!

[08:33] <bsb> Adding it back locally seemed to settle my skittish repl loop

[08:35] <nothingmuch> autrijus?

[08:35] <nothingmuch> Juerd?

[08:35] <nothingmuch> lunch

[08:38] <nothingmuch> unlunc

[08:38] <nothingmuch> h

[08:38] <nothingmuch> delay

[08:38] <nothingmuch> okay:

[08:38] <castaway> that was quick

[08:38] <nothingmuch> in a wrapper: &?SUB means the wrapped

[08:38] <autrijus> bsb: has_ghc_package always succeeded

[08:38] <autrijus> bsb: you need a compile_ok

[08:38] <nothingmuch> &?WRAP means next in line

[08:38] <autrijus> to ensure it really has the libreadline

[08:38] <autrijus> not only the readline package (which is always there)

[08:39] <nothingmuch> @?WRAP means all below

[08:39] <nothingmuch> no, it means all

[08:39] <nothingmuch> beh, i dunno

[08:39] <nothingmuch> at the lowest level i'd like a sub to have @?WRAP and be able to access it all

[08:40] <nothingmuch> VSub becomes a linked list (optionally)

[08:40] <nothingmuch> wrap prepends an element, and returns a new closure

[08:40] <nothingmuch> unwrap splices an element, and returns a new closure

[08:40] <nothingmuch> okay, i think @?WRAP always refers to the top most wrap list

[08:40] <nothingmuch> is this making any sense?

[08:41] <jabbot> pugs - 2425 - * opaque value type, the first attempt a

[08:42] <nothingmuch> a wrapper should be able to search @?WRAP for &?SUB to get an idea of where it is in the wrap list

[08:42] <nothingmuch> and it should be able to say @?WRAP[0].unwrap(&?SUB) to remove itself

[08:42] <nothingmuch> someone please comment

[08:44] <nothingmuch> autrijus: i'd like a quick primer on the structure of data Env

[08:44] <bsb> if (has_ghc_package('readline') and try_compile("main = return ()", "-lreadline")) ??

[08:44] <nothingmuch> especially with dynamic/lexical scope differences

[08:45] <autrijus> bsb: better actually exercise the readline

[08:45] <autrijus> import System.Console.Readline

[08:45] <autrijus> main = readline "" >> return ()

[08:45] <autrijus> that will do

[08:46] <autrijus> bsb: in that case you can also add ' -DPUGS_HAVE_READLINE=1' to ghc_flags

[08:46] <autrijus> and disable the redundant check in util/config_h.pl

[08:46] <autrijus> nothingmuch: ok. the lexical pad is in envLexical

[08:46] <autrijus> nothingmuch: the global pad is in envGlobal

[08:47] <autrijus> the dynamic caller's env is at envCaller

[08:47] <nothingmuch> okayi see

[08:47] <nothingmuch> when entering a sub do you make a new env with envCaller out of it's lexical env?

[08:50] <autrijus> when entering a sub, we save the current env and use it as the new env's envCallse^WenvCaller;   

[08:51] <nothingmuch> is that done by enterLex?

[08:51] <nothingmuch> no

[08:51] <nothingmuch> that looks like the second part of it

[08:52] <autrijus> enterLex is just appending envLexical

[08:53] <nothingmuch> enterSub is a bit of a beast for me

[08:54] <nothingmuch> but not envCaller

[08:54] <nothingmuch> i see it preparing interesting things

[08:54] <nothingmuch> basically preparing dynamic scope behavior

[08:56] <autrijus> yeah

[08:56] <autrijus> it's done in Eval line 771

[08:56] <nothingmuch> oh i see

[08:57] <nothingmuch> after fixEnv a new lexical scope is made?

[08:57] <nothingmuch> or rather entered?

[08:57] <autrijus> yeah

[08:58] <nothingmuch> okay

[08:58] <nothingmuch> i think that the semantics of entering a wrapped sub are very very simple:

[08:58] <nothingmuch> that stays the same

[08:58] <nothingmuch> but:

[08:58] <nothingmuch> call

[08:58] <nothingmuch> right now it sets ($&SUB, @?WRAP_REMAINING) = @?WRAP_REMAINING

[08:59] <nothingmuch> and then &?SUB.goto

[08:59] <nothingmuch> @?WRAP_REMAINING = @?WRAP if it's not defined

[08:59] <nothingmuch> @?WRAP is a closure var of only the root of the wrap list

[08:59] <nothingmuch> that's it

[09:00] <nothingmuch> (pop (@?WRAP_REMAINING = @?WRAP_REMAINING)).goto;

[09:00] <nothingmuch> what remains is magical context carry over in void context

[09:01] <nothingmuch> but that shouldn't bee too difficult

[09:03] <autrijus> hm

[09:03] <autrijus> I wonder if subFun should be called subBody ;)

[09:03] <autrijus> will you be terribly mad if I change it to subBody?

[09:03] <nothingmuch> no

[09:03] <nothingmuch> =)

[09:04] <nothingmuch> take the sub you are wrapping

[09:04] <nothingmuch> make a closure without @?WRAP in it

[09:04] <nothingmuch> @?WRAP carryover looks like this:

[09:04] <nothingmuch> make a closure of your new wrapper

[09:04] <nothingmuch> put the old @?WRAP with itself prepended in it's lexical scope

[09:05] <nothingmuch> blammo

[09:05] <autrijus> looks sane.

[09:05] <nothingmuch> unwrap makes a closure of @?WRAP[1] with a new @?WRAP inside it

[09:05] <nothingmuch> with no arguments

[09:05] <nothingmuch> or finds the argument in @?WRAP

[09:05] <nothingmuch> and creates a closure of @?WRAP[0] with the filtered @?WRAP

[09:07] <nothingmuch> i like the simplicity of this behavior

[09:09] <autrijus> I'll brb.

[09:09] <nothingmuch> ciao

[09:11] <jabbot> pugs - 2426 - * Internal: rename subFun to subBody

[09:11] <jabbot> pugs - 2427 - readline probing

[09:13] <bsb> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html#v%3Acardinality

[09:14] <bsb> should I s/Set.cardinality/Set.size/ in Prim.hs?

[09:14] <bsb> cardinality - Obsolete equivalent of size.cardinality :: Set a -> Int

[09:15] <autrijus> bsb: go ahead

[09:16] <autrijus> theorbtwo: I added VOpaque

[09:17] <autrijus> theorbtwo: so you can eval into anything now as long as you declare an instance of Value for it

[09:20] <theorbtwo> Hold on a bit for my eyes to go unblurry and my mind to finish waking up.

[09:21] <autrijus> sure :)

[09:21] <jabbot> pugs - 2428 - s/Set.cardinality/Set.size/

[09:29] <castaway> .oO( wouldnt it be cool if one could just select a chunk of code in ones editor, and choose some option which meant "output debugging info for this bit" ?)

[09:31] <bsb> src/UnicodeC.o and src/UTF8.o survive make realclean, was that intended?

[09:31] <theorbtwo> .oO(We have a realclean?)

[09:32] <autrijus> bsb: probably not.

[09:32] <bsb> Could that explain my "make ghci" trouble?

[09:32] <theorbtwo> Oh!  Of course, for holding the opaque that is what (most?) objects are built of.

[09:33] <autrijus> right.

[09:34] <theorbtwo> Hm, does instance Typeable VOaque where typeOf (MkOpaque x) = typeOf x really say what you want it to?

[09:35] <theorbtwo> Is the type of MkOpaque "asdf" supposed to be the same as the type of "asdf".  (IE String.)

[09:36] <castaway> Opaque means see through, so it would make logical sense..

[09:37] <theorbtwo> No, transparent means see-through; opaque is the oppisite.

[09:37] <autrijus> right.

[09:37] * castaway checks dict again, and slaps self

[09:37] <autrijus> theorbtwo: I don't know and I don't know whether there's a better way

[09:40] <bsb> I'm off for tonight.  Bye

[09:41] <theorbtwo> G'night, bsb.

[09:41] *** chady is now known as chady_

[09:41] <jabbot> pugs - 2429 - add "src" to @srcdirs

[09:51] <jabbot> pugs - 2430 - Uncommented the 'BEGIN {...}'s of contro

[09:51] <jabbot> pugs - 2431 - * Added the usual SVN properties to t/.

[10:00] <theorbtwo> OK, caught up on the last 12 hours of IRC backlog.

[10:02] <theorbtwo> Oh!

[10:02] * theorbtwo just realized that the --version r\d+ thing won't work for people using svk instead of svn.

[10:08] <autrijus> indeed :)

[10:15] <theorbtwo> Hm, we ought to start haddocking.

[10:15] <castaway> haddocking

[10:15] <castaway> ?

[10:16] <theorbtwo> haddock is the haskell documentation framework.

[10:16] <theorbtwo> Vaugely like javadoc.

[10:16] <castaway> ah, cute

[10:16] <castaway> sounds like a good idea

[10:16] <theorbtwo> Really I don't want documentation so much as an index of types, but haddoc is the best way I know of to get it.

[10:17] <castaway> ,)

[10:18] <castaway> didnt you do a script that listed those already, or was that something else?

[10:18] <theorbtwo> No, that just shows dependencies.

[10:18] <theorbtwo> The graph was already plenty crowded just showing that much.

[10:18] <castaway> not that one, a while back

[10:19] <castaway> a grep of Prim.hs combined with something ?

[10:19] <theorbtwo> Oh, that shows perl-visible primitives.

[10:19] <gaal> i think i'm missing something basic about parsec: i have a trace at the beginning of a rule, then one later on in the same rule. as a file is being parsed, i see the secong trace emittted several times.. are parsec rules not regular functions? eg is a failure really just a yield?

[10:19] <theorbtwo> Not haskell types.

[10:19] <castaway> ah, Ok

[10:20] * castaway reists asking "whats parsec?"

[10:21] <theorbtwo> Funky haskell parser library.

[10:21] <gaal> theorbtwo: check out my exuberant ctags hack

[10:21] <gaal> it doesn't do everything you want yet

[10:21] <gaal> but it's a start.

[10:21] <castaway> for parsing haskell, or other things?

[10:22] <gaal> because exctags knows what kind of identifier it's tagging

[10:22] <theorbtwo> (Funky because it's just a library, it doesn't create a new language with embedded haskell like, for example, P::RD.)

[10:22] <gaal> castaway, for parsing whatever.

[10:22] <theorbtwo> (Well, funky for other reasons as well, but that's a big one.)

[10:22] <theorbtwo> But it parses the haskell itself?

[10:22] <mauke> writing something like parsec (i.e. a parser monad) yourself isn't all that hard

[10:23] <gaal> theorbtwo: the exctags haskell mode? not really, right now it just uses regexps :)

[10:23] <theorbtwo> Right.

[10:23] <gaal> a copout really, but as i said, it's a start.

[10:23] <theorbtwo> I'd rather get haddock to do the heavy lifting, and possibly munge it's /output/ into ctags format if I wanted them that way.

[10:24] <theorbtwo> (Which I don't know if I do.)

[10:24] <gaal> well, why not.

[10:24] <autrijus> bbiab

[10:24] <castaway> ctags ?

[10:24] <theorbtwo> Haddock seems to produce quite nice HTML.

[10:24] <gaal> castaway: exctags also produces etags output :)

[10:25] <autrijus> svn.openfoundry.org/openafp/Makefile has a "make docs", btw.

[10:25] <autrijus> feel free to add it to our makefile.pl

[10:25] <theorbtwo> I don't want to start tackling it until I'm finished gutting AST.hs into Types.hs.

[10:25] <autrijus> k. :)

[10:25] <autrijus> &

[10:26] * castaway has a feeling some of this is emacs related ,)

[10:26] <theorbtwo> Very good.

[10:32] <nothingmuch> ok, back from lunch

[10:32] <nothingmuch> anyone know how where a lexical scope is snapshoted into a closure?

[10:48] <castaway> ooh, an answer to my compiling-par-on hp question.. wow

[11:01] <jabbot> pugs - 2432 - Updated mandel.p5 to output the fractal 

[11:06] <Juerd> nothingmuch?

[11:14] <nothingmuch> Juerd?

[11:16] <mj> http://test.wikidev.net/Pugs_tests?action=history    r2431 added

[11:20] <Juerd> 10:37 < nothingmuch> Juerd?

[11:20] <Juerd> 13:09 < Juerd> nothingmuch?

[11:20] <Juerd> 13:17 < nothingmuch> Juerd?

[11:20] <Juerd> I guess it's my turn again

[11:20] <Juerd> nothingmuch?

[11:20] <nothingmuch> yes!

[11:21] <Juerd> I don't like this game. I'm going to the office now.

[11:21] <nothingmuch> i was wondering about the semantics of wrapping as closures

[11:21] <nothingmuch> but then autrijus helped me figure it out

[11:21] <nothingmuch> have fun at the office

[11:29] <mj> please, my tutorial_gen is still waiting for "for @a -> $v is rw { $v = 10; }" ... statements/for.t   23

[11:30] <nothingmuch> mj you want that implemented?

[11:33] <nothingmuch> autrijus: when you're back I need some help

[11:33] <mj> yes, please ... or reimplemented ... when i have written it, "is rw" was ok

[11:34] <nothingmuch> =/

[11:35] <nothingmuch> hmm

[11:35] <mj> for %conf<index>.values -> $val is rw {    ... http://wiki.kn.vutbr.cz/mj/attach/pugs/fool/ctest.p6

[11:36] <castaway> is "is rw" compulsory there? (seems like overkill)

[11:36] <nothingmuch> castaway: afaik it is

[11:36] <castaway> why?

[11:36] <nothingmuch> uhhh

[11:36] <nothingmuch> like in subs

[11:37] <castaway> Oh.. thats to ensure you really want to change the actual element? (its aliased I assume, like in p5?)

[11:37] <castaway> "like in subs" tells me nothing btw, I havent been paying that much attention :)

[11:37] * broquaint thinks it odd one needs to declare aliases as rw ...

[11:37] <nothingmuch> well, yes

[11:38] <nothingmuch> ah

[11:38] <nothingmuch> you have to declare it to really want that to be this way

[11:38] <nothingmuch> or you can say 'is constant'

[11:38] <nothingmuch> hmm

[11:38] * nothingmuch doesn't know where for is defined

[11:38] <castaway> bro, why odd?

[11:39] <nothingmuch> ah

[11:39] <nothingmuch> here it is

[11:39] <castaway> It seems to be as a deterrent for people that (in p5) generally change their vars in a for-loop, and get all confused when the original array changes

[11:39] <nothingmuch> hmm

[11:40] <castaway> (change contents of the loop var, that is)

[11:40] <nothingmuch> it seems like it applies values normally

[11:40] <nothingmuch> s/values/subs/

[11:40] <castaway> ?

[11:40] <nothingmuch> it makes a sub out of the loop body

[11:40] * broquaint & phone

[11:41] <nothingmuch> then it just splits the parameters into chunks as big as the sub's arity

[11:41] <theorbtwo> All blocks are closures.

[11:41] <broquaint> Surely one wnats is copy rather than is rw?

[11:41] <nothingmuch> and does doApply on the sub with the chunk of the params

[11:41] <nothingmuch> broquaint: the default is 'is constant'

[11:41] <nothingmuch> it's the most common

[11:41] <castaway> bro, I would assume copy is the default?

[11:41] <theorbtwo> If you want %conf<index>.values to change as a result of your for loop, you want "is rw".

[11:42] <theorbtwo> Copy is not the default, is ro is.

[11:42] <castaway> nm, can you say that in english and not perl6/haskellese? :)

[11:42] <castaway> s/copy/value/

[11:42] <nothingmuch> sorry, it's haskellese

[11:42] <theorbtwo> for @array -> $var {$var=1} will die.

[11:42] <nothingmuch> basically since every block is a closure

[11:42] <nothingmuch> it also accepts subs

[11:42] <theorbtwo> for @array -> $var is copy {$var=1} is a null-op.

[11:42] <broquaint> is constant is the default? That sounds odd too :/

[11:43] <nothingmuch> so the for loop is basically a loop that splitces for (@array) the @array into the number of pieces that the body wants

[11:43] <theorbtwo> for @array -> $var is rw {$var=1} is makes @array full of ones.

[11:43] <castaway> why odd, bro?

[11:44] <castaway> (although, maybe it is.. you should get either a writeable var (is rw), or a copy.. a non-writeable alias seems to make little sense)

[11:44] <nothingmuch> and calls $loop_body.(@some_params);

[11:44] <nothingmuch> think of an alias as a copy of the container

[11:44] <nothingmuch> with some restrictions

[11:45] <nothingmuch> and you can think of 'is constant' as 'is constant copy' 

[11:45] <nothingmuch> if aliases that aren't writable don't make sense ;-)

[11:45] <nothingmuch> so anyway, do we have 'is rw' on subs?

[11:46] <castaway> umm, but is constant implies that I cant do, for example, s/// on the loop variable

[11:46] <nothingmuch> right, you can't

[11:46] <theorbtwo> That's correct.

[11:46] <nothingmuch> you want is rw, or in a map is copy

[11:47] <castaway> ah, but I dont want rw, because that would change the value in the original array, yes?

[11:47] <nothingmuch> btw, can we do map -> $var, $var2 (@list) ?

[11:47] <nothingmuch> sorry... corrected: map -> $var, $var2 {... } (@list) ?

[11:47] <nothingmuch> so you want is copy

[11:47] <castaway> which for doesnt have, you just claimed :)

[11:47] <nothingmuch> I DID NO SUCH THING

[11:47] <nothingmuch> oops

[11:47] <castaway> ,)

[11:47] <nothingmuch> tee hee

[11:48] <castaway> sorry, theorbtwo said:

[11:48] <nothingmuch> caps lock snuck in, didn't mean to sound like an arse

[11:48] <castaway> for @array -> $var is copy {$var=1} is a null-op

[11:48] <castaway> no worries

[11:48] <nothingmuch> meaning that it doesn't change the array

[11:48] <nothingmuch> not that it does nothing at all... =)

[11:48] <castaway> oh, cos $var isnt used otherwise, ok, sorry, misread

[11:48] <nothingmuch> appearently we have is rw in subs

[11:48] <theorbtwo> Well, it's in void context there, so it really does nothing.

[11:48] <castaway> bro is correct tho, defaulting to constant seems odd

[11:48] <castaway> one would hope so

[11:49] <nothingmuch> see t/var/is_rw.t

[11:49] <nothingmuch> i wonder if you can do it to anonymous subs

[11:49] * castaway ponders how she usually uses for loops

[11:49] <nothingmuch> castaway: many times i do '

[11:49] <nothingmuch> for (@list) { my $var = $_; }

[11:50] <nothingmuch> and then put a big fat comment saying "this is a copy! don't change this behavior"

[11:50] <nothingmuch> not many times

[11:50] <nothingmuch> well, not many times

[11:50] <nothingmuch> most of the time if i'm mutating the value it's because i want is rw

[11:50] <castaway> I'm not sure I ever have :)

[11:50] <nothingmuch> maybe this is good reasoning: is constant is harder to remember to ask for

[11:51] <theorbtwo> Right; "is copy" makes that behavior more clear -- it lets you change your index var(s) in the scope of the body without making the changes leak.

[11:51] <castaway> umm, what I dont get, is what use is "is constant" there at all?

[11:51] <theorbtwo> It's both fast and safe.

[11:51] <castaway> safe from?

[11:51] <castaway> I dont see its point.

[11:51] <nothingmuch> many people assume that for loops give you is copy and not is rw in p5

[11:52] <nothingmuch> that causes some problems

[11:52] <theorbtwo> Fast, because it does not imply a copy is being made, and safe, because you cannot change your loop var and have it leak.

[11:52] <nothingmuch> but is rw is much more useful

[11:52] <nothingmuch> since it's both dangerous and useful, it should be easy to get,

[11:52] <nothingmuch> but perhaps not the default

[11:52] <theorbtwo> I prefer to mutate my lists with @list = map {} @list;

[11:52] <theorbtwo> It reads much clearer for me.

[11:52] <castaway> right, so default to whats normally  assumed?

[11:53] <theorbtwo> "is constant"

[11:53] <theorbtwo> Er, misread.

[11:53] <theorbtwo> "Yes."

[11:53] <nothingmuch> castaway: but the default that is normally assumed is silly

[11:53] <nothingmuch> 'is copy' is normally useless

[11:53] <nothingmuch> and slow

[11:53] <castaway> I dunno, maybe Im odd, but I never use for-loops to change things, I'd use map/grep there

[11:53] <nothingmuch> i use for loops to change in place

[11:53] <nothingmuch> $_++ for (@list);

[11:53] <nothingmuch> @list = map { $_ + 1 } @list;

[11:54] <theorbtwo> @list .= map {++$_}

[11:54] <nothingmuch> i think the first conveys my meaning better

[11:54] <wolverian> map $_++, @list; :)

[11:54] <castaway> how would that translate to p6? (since it seemed the braces for the anon-sub are required)

[11:54] <nothingmuch> @list>>++;

[11:54] <theorbtwo> Oh, right, nm.

[11:54] <mj> for @a {} is same as for @a -> $_ is rw {}

[11:54] <wolverian> castaway: which?

[11:54] <castaway> nothingmuch, whether its silly or not.. surely its better to go with expectations..

[11:55] <castaway> $_++ for (@list); == in p6 ?

[11:55] <wolverian> yes.

[11:55] <nothingmuch> castaway: i dunno. I prefer is constant because it gives me safety but doesn't take away much

[11:55] <nothingmuch> anyway, the reason i preferred the first is that i feel i'm changing the elements, not the list

[11:55] <nothingmuch> but that's just me

[11:55] <nothingmuch> that's p5 actually, to me,

[11:55] <autrijus> theorbtwo: can you hold AST.hs refactor a bit?

[11:55] <wolverian> the 'for' there is in the statemenet modifier category, so the parser knows how to do it.

[11:55] <nothingmuch> in p6 i would do '@list>>++'

[11:55] <wolverian> statement, rather.

[11:55] <nothingmuch> autrijus: help help help!

[11:55] <theorbtwo> autrijus: gladly.

[11:55] <autrijus> theorbtwo: there may be large conflict going your way

[11:55] <nothingmuch> i am getting nowhere

[11:56] <castaway> Well, in IMhO, people assuming bad defaults in p5, are going to continue to be confused in p6, just for another reason

[11:56] <autrijus> nothingmuch: sorry, tied to $work right now

[11:56] <autrijus> nothingmuch: but I did move all our variables into STM.

[11:56] <autrijus> ;)

[11:56] <autrijus> will commit soon

[11:56] <nothingmuch> autrijus++

[11:56] <castaway> wolv, eh? yes what?

[11:56] <nothingmuch> can you really quickly point me to where closures are created?

[11:56] <wolverian> castaway: yes, that is in p6.

[11:56] <autrijus> no idea if it make things really slow or not

[11:56] <autrijus> nothingmuch: they are created by the "sub" Syn

[11:56] <wolverian> castaway: (the statement-form for loop. the particular usage there is a bit p5-esque.)

[11:56] <castaway> you mean its the same?

[11:56] <wolverian> yes.

[11:56] <castaway> ah

[11:56] <nothingmuch> thanks

[11:57] <castaway> with no "is rw" ??

[11:57] <nothingmuch> when does unionPads happen?

[11:57] <wolverian> if you don't have an explicit signature, $_ is rw is the default

[11:57] <castaway> argh!

[11:57] <autrijus> nothingmuch: unionPads is only done to introduce some extra &?SUB etc

[11:57] <castaway> Its all a plot against readable code!

[11:57] <nothingmuch> so how are pads walked?

[11:58] <nothingmuch> is it a union of maps?

[11:58] <wolverian> castaway: @foo».++; # this is more p6-esque, anyway

[11:58] * castaway cant even read that :)

[11:58] <theorbtwo> wolverian: Are you sure is rw is the defualt?

[11:58] <wolverian> hmm, the . there is wrong, I guess.

[11:58] <autrijus> nothingmuch: a pad is just a map

[11:58] <autrijus> that's all

[11:58] <nothingmuch> does it contain all the variables?

[11:58] <theorbtwo> Right, no dot.

[11:58] <wolverian> theorbtwo: when there is no signature. yes, I think I read so, and mj says as much.

[11:59] <nothingmuch> { my $foo { my $bar } } ; # inner pad has foo and bar?

[11:59] <autrijus> yes.

[11:59] <nothingmuch> okay thanks

[11:59] <autrijus> np

[11:59] <nothingmuch> autrijus++

[11:59] <nothingmuch> mj: anon subs can also use is rw

[11:59] <nothingmuch> so i will try to find out why the for syn is not respecting that

[12:00] <autrijus> huge change is checked in as r2433

[12:00] <autrijus> I'm interested to learn if it makes smoke time significantly slower

[12:00] <autrijus> (because STM carries extra journaling)

[12:00] <nothingmuch> autrijus: i'll benchmark

[12:00] <autrijus> if it is much slower, I will contemplate rollback.

[12:01] <nothingmuch> shouldn't they only journal if atomic is in effect somewhere?

[12:01] * castaway wonders how printable the Synopses and Apoc-whatsits are

[12:01] <jabbot> pugs - 2433 - * STMification: All our IORefs are now T

[12:01] <jabbot> pugs - 2434 - check that anon subs can do 'is rw'

[12:01] <nothingmuch> castaway: don't bother with the apocalypses

[12:01] <gaal> at one point i had #line "almost working" but at 100% slowdown

[12:02] <nothingmuch> the syns are printable

[12:02] <castaway> nm, but afaik, one should look there if something is not found in a synopsis ?

[12:02] <nothingmuch> not really, they are more like manic brainstorms

[12:02] <nothingmuch> i have not yet needed to look deeply in any of them

[12:02] <castaway> I didnt find them all that unreadable ,)

[12:02] <nothingmuch> they're pretty readable,

[12:03] <nothingmuch> but i've always searched

[12:03] <nothingmuch> before STM: 152.630u 8.770s 2:59.23 90.0%   0+0k 0+0io 556825pf+0w

[12:08] * nothingmuch wonders if perhaps 'map Val these' in for's doApply is making them non is rw

[12:12] <nothingmuch> after STM: 156.800u 8.210s 3:02.52 90.4%   0+0k 0+0io 560511pf+0w

[12:12] <nothingmuch> 2 seconds of real time lost

[12:12] <nothingmuch> 4 seconds of user time

[12:12] <theorbtwo> Sounds pretty negligable.

[12:12] <nothingmuch> probably the fact that i'm on NFS is more of an issue

[12:12] <nothingmuch> ,

[12:12] <castaway> what're you timing, all the tests?

[12:12] <nothingmuch> yep

[12:12] <nothingmuch> 'make test'

[12:12] <castaway> ah, ok then

[12:13] <nothingmuch> page faults also seem fine

[12:13] <nothingmuch> autrijus: timing results back

[12:13] * nothingmuch is very happy

[12:32] * castaway busys the printer

[12:33] <theorbtwo> Printing the syns?

[12:33] <castaway> just a couple

[12:41] <nothingmuch> it's either a string or a number

[12:41] * nothingmuch contemplates a 'uuid' builtin

[12:41] <nothingmuch> and it's different each time around

[12:41] <nothingmuch> would save many people a lot of trouble

[12:42] <nothingmuch> it could also be optimized

[12:42] <nothingmuch> for hash lookups or whatever

[12:42] <nothingmuch> since assumptions about the key space and the data can be made

[12:43] <theorbtwo> I don't see any purticular reason to make it a builtin.

[12:44] <nothingmuch> i see only one valid reason: so that it's not redone

[12:45] <Juerd> Is it redtwo?

[12:45] <autrijus> greetings.

[12:45] <Juerd> Hello

[12:45] <nothingmuch> autrijus: no diff with STM

[12:45] <autrijus> nothingmuch: Data.Unique has this thing.

[12:45] <autrijus> envID uses that

[12:45] <autrijus> nothingmuch: good. I've changed Hash to be STM.

[12:45] <autrijus> (it as IO)

[12:45] <autrijus> (it was IO)

[12:46] <theorbtwo> IO, or IORef?

[12:46] <autrijus> IO

[12:46] <autrijus> Data.HashTable

[12:46] <nothingmuch> autrijus: comitted?

[12:46] <nothingmuch> i'll have to test it when I'm home

[12:46] <autrijus> nothingmuch: yes, committed as r2438

[12:47] <autrijus> now the next logical thing to do is

[12:47] <autrijus> -type Eval x = ContT Val (ReaderT Env IO) x

[12:47] <autrijus> +type Eval x = ContT Val (ReaderT Env STM) x

[12:47] <autrijus> after that we can have our atomically{} builtin.

[12:47] <nothingmuch> "atomic" expr = atomic { block <- subFoo expr; doApply block }  ?

[12:48] <theorbtwo> autrijus: Don't worry about blocking me; I'm switching to haddocking.

[12:48] <autrijus> theorbtwo: ok.

[12:48] * nothingmuch has to go home... ciao!

[12:48] <autrijus> nothingmuch: actually, if we are in STM monad, everything is atomic by default

[12:48] <nothingmuch> everything?

[12:48] <nothingmuch> oh!

[12:48] <nothingmuch> oh wow

[12:48] <autrijus> "I'm atomic... by default!"

[12:48] <autrijus> swiss army nuke

[12:49] <nothingmuch> so haskell errors will undo automatically?

[12:49] <autrijus> we can do that, yes

[12:49] <autrijus> by using a newtype Eval

[12:49] <nothingmuch> what implications does that have on async { } ?

[12:49] <theorbtwo> (Which requires some changes to the build system so we can get ghc to render the post-cpp haskell files.)

[12:49] <nothingmuch> crap, i have to go

[12:49] <nothingmuch> ciao!

[12:49] <autrijus> ciao

[12:49] <nothingmuch> i think i can hack in wrap later tonight 

[12:50] <broquaint> STM?

[12:51] <theorbtwo> somthing Transactional Memory

[12:51] <jabbot> pugs - 2435 - Memory game v0.2

[12:51] <jabbot> pugs - 2436 - first part of wrapping test

[12:51] <jabbot> pugs - 2437 - * remove unused DynamicLoader

[12:51] <jabbot> pugs - 2438 - * Replace Data.HashTable into STM Map

[12:52] <autrijus> software transactional memory

[12:52] <broquaint> Cool, thanks. Sounds leet.

[12:52] <autrijus> broquaint: read this:

[12:53] <autrijus>     http://homepages.inf.ed.ac.uk/wadler/linksetaps/slides/peyton-jones.ppt

[12:53] <autrijus> it's very very leet.

[12:53] <broquaint> Ooh, Peyton-Jones - it's gotta be good!

[12:54] <broquaint> Does anything implement it?

[12:54] <broquaint> Apart from Pugs.

[12:54] <autrijus> broquaint: C#, Java, GHC, Sun Fortress

[12:54] <castaway> Its haskell thats implemented it, not Pugs

[12:55] <autrijus> apparently catching on rapidly

[12:55] * boogie checked in memory game v0.2: http://perl6.hu/cgi-bin/index.cgi

[12:55] <autrijus> but perl5 doesn't have it. sucks

[12:55] <autrijus> boogie: ooh

[12:55] <broquaint> Sounds like all the rage.

[12:55] <boogie> autrijus: just small improvements

[12:55] <broquaint> If only some could right a module to implement it (where's TheDamian when you need his mad scientist skillz?) ...

[12:56] <autrijus> broquaint: it's, uhm, a bit more involved than that :)

[12:56] <broquaint> s/some could right/someone could write/

[12:56] <autrijus> maybe sky or liz can do that

[12:56] <broquaint> I don't want excuses, I want results!

[12:56] <autrijus> ithreads /= my forte

[12:56] <broquaint> Threads in perl = mad, bad and dangerous to know

[12:57] <autrijus> and very slow to boot.

[12:57] <autrijus> but, amazingly, is usabl

[12:57] <autrijus> e

[12:57] <broquaint> Maybe if we re-implement Perl 5 in Haskell ...

[12:58] <broquaint> ... we'll have wasted and good chunk of our lives.

[12:58] <Jonathan_> Or target it at Parrot, which should do threading much better. I hope. :)

[12:58] <broquaint> s/and/a/ # decaf tea--

[12:59] <broquaint> It will! It must! Or it's Davy Jones' locker for us all!

[12:59] <Limbic_Region> seen stevan

[12:59] <jabbot> Limbic_Region: stevan was seen 7 hours 44 minutes 40 seconds ago

[13:01] <broquaint> Ooh, transactional memory, me likee ...

[13:03] * broquaint decides to finish "The Awkward Squad" before STM

[13:06] *** irc.freenode.net sets mode: +n
 
[13:12] * castaway has made fire!

[13:12] <castaway> (well, ok, made this stupid perl4ish perl5 program "work" again)

[13:14] <broquaint> Now convert it to perl6.

[13:14] * castaway falls over dead

[13:16] * theorbtwo gives castaway mouth-to-mouth.

[13:17] <castaway> :)

[13:18] <castaway> I was about to give you a list of the files concerned and their sizes.. but damned if I can make "ls" do "just" that

[13:18] <castaway> whatever, in long format:

[13:18] <castaway> -rw-r--r--   1 jer      osa         1636 Apr 27 15:45 Configuration.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        32963 Apr 27 15:45 checkComponentsMisSpoc.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        33196 Apr 27 15:45 checkComponentsShell.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        42925 Apr 27 15:45 checkMisEnv.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        11825 Apr 27 15:45 defineMessages.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        35574 Apr 27 15:45 defineMisc.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        18862 Apr 27 15:45 defineResultMisSpoc.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        17576 Apr 27 15:45 defineResultShell.pm

[13:18] <broquaint> ls -S ? I think recent fancy linuces support it.

[13:18] <castaway> -rw-r--r--   1 jer      osa        22013 Apr 27 15:45 mis_checkall.pm

[13:18] <castaway> -rw-r--r--   1 jer      osa        16581 Apr 27 15:45 mis_spoc.pm

[13:18] <castaway> -r--r--r--   1 jer      osa       179902 Apr 28 15:14 utilSubs.pm

[13:18] <castaway> (so I'd probably be here until christmas)

[13:19] <broquaint> Time to refactor!

[13:19] <wolverian> broquaint: that just sorts by size

[13:19] <broquaint> Ah, thanks, wolverian. Don't have linux at hand :/

[13:19] <castaway> nope, -S is sort.. and -s is block size

[13:19] * broquaint & # food

[13:19] <castaway> anyway, that was on AIX 4.3 ,)

[13:19] <broquaint> ls -hs (-h for human?) # now eating ... really

[13:20] <wolverian> yes

[13:20] <castaway> total 616K

[13:20] <castaway> 4.0K Configuration.pm

[13:20] <castaway>  36K checkComponentsMisSpoc.pm

[13:20] <castaway>  36K checkComponentsShell.pm

[13:20] <castaway>  44K checkMisEnv.pm

[13:20] <castaway>  12K defineMessages.pm

[13:20] <castaway>  36K defineMisc.pm

[13:20] <castaway>  20K defineResultMisSpoc.pm

[13:20] <castaway>  20K defineResultShell.pm

[13:20] <castaway>  24K mis_checkall.pm

[13:20] <castaway>  20K mis_spoc.pm

[13:20] <wolverian> spam!

[13:20] <castaway> 180K utilSubs.pm

[13:20] <castaway> 184K utilSubs.pm~

[13:20] <castaway> mounted-home-dirs++

[13:21] <castaway> ok I'm done now :)

[13:21] <jabbot> pugs - 2439 - See thread "is rw basically a null-op on

[13:29] <Juerd> Does anyone have logs of this channel? If so, can I get a (gzipped) copy?

[13:29] <machack666> Juerd: http://colabti.de/irclogger//irclogger_log/perl6

[13:29] <Limbic_Region> Juerd - can't you just download from the logger?

[13:30] <Juerd> Thanks

[13:30] <Juerd> Limbic_Region: That requires knowing there is such a thing :)

[13:30] <Limbic_Region> FWIW - the link is on the pugs home page http://pugscode.org

[13:30] <Limbic_Region> along with a few other useful links too

[13:31] <machack666> anyone there who knows about the pugs internals?

[13:32] <Limbic_Region> there or here?

[13:32] <machack666> never mind...found what I needed in the logs

[13:38] * theorbtwo grrrs at make

[13:38] <theorbtwo> .hs.hpp : $ghc $threaded $ghc_flags -E \$< -o \$@

[13:38] <theorbtwo> Why does that rule not trigger on make src/Pugs/Help.hpp

[13:41] * nothingmuch returns with a dramatic effect

[13:41] <nothingmuch> hola jhorwitz 

[13:41] <jhorwitz> hola!

[13:41] <Limbic_Region> nothingmuch - did you see stevan WRT last tests?

[13:42] <nothingmuch> Limbic_Region: haven't talked to him since

[13:42] <Limbic_Region> k

[13:44] <stevan> Limbic_Region: morning

[13:44] <stevan> hey all

[13:44] <nothingmuch> hola

[13:46] <stevan> theorbtwo: are you starting to document the haskell source?

[13:49] <theorbtwo> Well, I'm starting by trying to get haddock to run from our source.

[13:49] <theorbtwo> Then possibly start documenting.

[13:50] <stevan> theorbtwo: I was thinking that I would like to do that to help get my head around Haskell

[13:51] <stevan> I actually hacked it a little already by putting some POD into multi-line Haskell comments

[13:51] <stevan> but Haddock sonds like a much better idea

[13:52] <theorbtwo> The problem I'm having at the moment is that haddock can't natively deal with ifdefs.

[13:52] <Arathorn> has anyone got a recent smoke url handy?

[13:52] <Arathorn> (the topic is b0rked)

[13:52] <theorbtwo> It needs it post-preprocessed.

[13:53] <nothingmuch> Arathorn: http://pugs.kwiki.org/?SmokedPugs

[13:53] <stevan> ahhh,.. no more make optimized?

[13:55] <Arathorn> nothingmuch: thankee

[13:55] <nothingmuch> =)

[14:05] <boogie> Anybody can tell me if is it the right behaviour that the following code not changes $variable?

[14:05] <boogie> given $variable { s:perl5/what/to/; }

[14:07] <theorbtwo> I think it shouldn't change it, but should error, but from an earlier discussion today, perhaps it should modify $variable.

[14:08] <theorbtwo> It depends on if $variable is copy, is rw, or is constant in that scope.

[14:08] <theorbtwo> Rather, if $_ is.

[14:08] <boogie> I mean: my $variable='what'; given $variable { s:perl5/what/to/; }

[14:09] <Jonathan_> stevan: I can switch my smoke to do "make optimized" if that'd help.

[14:09] <stevan> Jonathan_: I just tried make optimized and it didnt work (no target for optimized)

[14:10] <Jonathan_> Oh, sorry; I thought you meant it was there and no tinders were doing it.

[14:10] * stevan just realized he misspelled optimized

[14:10] <Jonathan_> Ah. :)

[14:10] * stevan takes another gulp of coffee and tries to wake up

[14:10] <stevan> Jonathan_: I think make optimized is implied by make smoke

[14:12] <stevan> theorbtwo: a question about embedding haskell if you have a moment

[14:12] <theorbtwo> Shoot.

[14:15] <theorbtwo> Sorry, gaim segfaulted on me.

[14:16] <stevan> theorbtwo: I was wondering if it would be possible to move the File::Spec::cwd code into ext/File-Spec by embedding the haskell?

[14:16] <stevan> or am I viewing it all wrong

[14:16] <theorbtwo> It should be possible (but means that File::Spec won't work without hs-plugins).

[14:16] <stevan> ok

[14:17] <stevan> so in theory I might be able to use it like Inline?

[14:17] <theorbtwo> In essence, yes.

[14:17] <stevan> sub perl6_function (Int $x) { eval_haskell("some crazy haskell code to do something to the int") }

[14:17] <theorbtwo> Having one in the core would be nice too, so it gets at least some testing.

[14:18] <stevan> would it work like that?

[14:18] <stevan> is there tests?

[14:18] <theorbtwo> Well, eval_haskell("some crazy haskell code to do something to the int $x") -- you have to interoperlate in any arguments.

[14:18] <stevan> ok

[14:18] <theorbtwo> For eval_haskell, yes.

[14:18] <theorbtwo> t/unspecced/eval_haskell.

[14:18] <theorbtwo> Better tests are very welcome.

[14:18] * stevan contemplates a Term::Readline which wraps System.Readline (or whatever the haskell lib is called)

[14:19] <theorbtwo> Right now I'd be very interested in any problems that I can actually solve.

[14:19] <theorbtwo> It's been that sort of week.

[14:19] <Arathorn> has anyone thought about the ==> and <== ops?

[14:20] <stevan> theorbtwo: if you are itching for something to do, maybe try moving the File::Spec::cwd code?

[14:20] <stevan> it might help me get the idea :)

[14:20] <theorbtwo> Hm, I'm not sure I like the idea of breaking Test.pm in the non-hs-plugins case.

[14:21] <theorbtwo> Oh, it wouldn't.

[14:22] <stevan> no it wouldnt 

[14:22] <stevan> only a few things use File::Spec

[14:22] <stevan> hangman, and a few other examples

[14:26] <theorbtwo> Sounds like a good idea then.

[14:31] <stevan> theorbtwo++

[14:35] <castaway> allo!

[14:35] <theorbtwo> Hmm, only problem is the monadic nature of the op.

[14:36] <stevan> which op? File::Spec::cwd? or eval_haskell?

[14:36] <theorbtwo> File::Spec::cwd

[14:37] <theorbtwo> getCurrentDirectory :: IO String, so it needs to be run inside a monad, and it rather breaks the rules for using unsafePerformIO safely.

[14:37] * castaway wants to go "ha!"

[14:38] <castaway> remember earlier we were discussing for @list -> $fred is rw {} ?

[14:38] * stevan nods as if he understands what theorbtwo is talking about

[14:38] <theorbtwo> Right, love.

[14:39] <castaway> -> means pointy sub, and "is rw" means trait, yes?

[14:39] <theorbtwo> stevan: getCurrentDirectory doesn't always return the same output for the same input.

[14:39] <theorbtwo> Correct.

[14:39] <stevan> ah

[14:39] <theorbtwo> (That is, it takes no input, and returns something that isn't always the same.)

[14:39] <castaway> then let me point you to S06, "Pointy subs" : ".. and a pointy sub may not be given traits"

[14:39] <stevan> very un-Haskell-ish

[14:40] <stevan> theorbtwo: and that is why you wrap it in a monad??

[14:40] <theorbtwo> Exactly.

[14:40] <stevan> and eval_haskell does not like monads??

[14:41] * castaway sniffs

[14:42] <theorbtwo> Well, eval_haskell requires that the thingy being run inside return a String.

[14:42] <stevan> and not IO String

[14:43] <theorbtwo> Exactly.

[14:43] <stevan> can we cast it?

[14:44] <theorbtwo> That's what unsafePerformIO does, but it's not... well... safe.

[14:44] <stevan> bah! life is dangerous!

[14:44] <stevan> whats a little unsafeIO between langauges :)

[14:45] <castaway> s/safe/pure/

[14:45] <stevan> so is it possible, just not advised? or is it not possible

[14:45] <theorbtwo> It is possible, it just might end up returning the same thing before and after you cd around.

[14:46] <stevan> how so?

[14:46] <stevan> clog in the monad?

[14:46] * stevan has limited understanding of monads, so please be gentle ;)

[14:47] <theorbtwo> Anything not in a monad is fair game to do pretty much any optimization you can think of on, including caching results.

[14:47] <stevan> so once we take it out of the monad, we are potentially in trouble ?

[14:47] <theorbtwo> Exactly.

[14:48] <theorbtwo> The correct solution is to do what File::Spec::cwd currently does -- always keep it in a monad, either Eval or IO.

[14:48] <stevan> is there anyway to force things? eval 'eval_haskell(...)'?

[14:49] <stevan> and we cannot keep it in the monad if we move it becuase?

[14:49] <theorbtwo> In any case, what I'm wondering now is a lot more down-to-earth then that -- both unsafePerformIO and getCurrentDirectory aren't imported, and I haven't left any way to specify that they should be.

[14:50] <stevan> hmmm

[14:50] <castaway> moo!

[14:52] <Limbic_Region> stevan I am about to head off to a marathon meeting but was wondering if you had done any of the last tests we had talked about - if so where?

[14:52] <stevan> t/statements/last|next.t

[14:52] <stevan> Limbic_Region: very primative, I have been sitting on them for a few days hoping to get the time

[14:53] <stevan> Limbic_Region: then i finally decided it was better to submit them to the group in hopes someone else might find the time :)

[14:53] <Limbic_Region> ok - will take a look when/if I get some time

[14:53] <stevan> Limbic_Region: sounds good

[14:54] <stevan> Limbic_Region: how'd the house closing go?

[14:54] * Limbic_Region is rather perturbed at recent corporate FW changes

[14:54] <Limbic_Region> great - less than 1 hr start to finish

[14:54] <stevan> dontcha hate signing over that much $$ :)

[14:54] <Limbic_Region> well, considering the first house I bought (for my mother) total cost was about 10% of this one - YEP

[14:56] <Limbic_Region> been thinking about junctions a bit lately - I really think scalar context shouldn't preclude saving away values for future retrieval as would a boolean context

[14:57] <Limbic_Region> or rather, I think junctions should make finding all the characters one string has in common with another string possible and easy 

[14:57] <stevan> Limbic_Region: that is a cool idea

[14:58] <stevan> I always saw them more from the boolean point of view myself

[14:58] <Limbic_Region> right - until you start saying things like I want all the items from this list that match any of the items from that list

[14:58] <Limbic_Region> you can see all the other way they would be of value 

[14:58] <Limbic_Region> anyways

[14:59] * Limbic_Region meeting &

[14:59] <stevan> enjoy :)

[15:11] <autrijus> rehi.

[15:11] <jabbot> pugs - 2440 - * move the readline probing to Makefile.

[15:12] * autrijus tried to make Eval a data type and failed miserably

[15:13] <theorbtwo> A newtype, you mean?

[15:14] <autrijus> a data type.

[15:14] <autrijus> data Eval x = EvalIO (ContT Val (ReaderT Env IO) x) | EvalSTM (ContT Val (ReaderT Env STM) x) deriving (Typeable)

[15:14] <autrijus> it's essential to happen to get atomic{} working

[15:14] <theorbtwo> Ah.

[15:14] <autrijus> if you say 

[15:15] <autrijus> atomic { say "Hello" }

[15:15] <autrijus> then pugs will throw out a catchable exception.

[15:15] <autrijus> which is, I maintain, the Right Thing.

[15:15] <theorbtwo> Makes sense.

[15:15] <autrijus> we do that b

[15:15] <autrijus> by

[15:15] <autrijus> instance MonadIO Eval where

[15:16] <autrijus>     liftIO io = EvalIO (liftIO io)

[15:16] <autrijus> and by disallowing EvalSTM >>= EvalIO

[15:16] <autrijus> er

[15:16] <autrijus> I mean disallowing EvalIO >>= EvalSTM

[15:16] <autrijus> the other way is fine

[15:16] <autrijus> so whenever we see EvalIO >>= EvalSTM

[15:17] <autrijus> we trigger fail""

[15:17] <autrijus> which is shiftT $ return (VError ...)

[15:17] <autrijus> which i sthen catchable.

[15:17] <theorbtwo> Sounds like a cool plan.

[15:17] <autrijus> =)

[15:17] <theorbtwo> Get tangled up in dependencies?

[15:17] <autrijus> yeah.

[15:18] <autrijus> the only way out I think is to remove all the default code 

[15:18] <autrijus> in Class.*

[15:18] <autrijus> I'm doing just that

[15:18] <theorbtwo> I wonder if I should put up my dependency grapher somewhere.

[15:18] <autrijus> that'd help

[15:19] <theorbtwo> It's highly unpolished, but working -- to produce dot files.

[15:19] <theorbtwo> The dot files are then impossible to actually get something useful out of.

[15:20] <autrijus> heh.

[15:21] <theorbtwo> It's all very tangled.

[15:23] <theorbtwo> perlbot: nopaste?

[15:23] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[15:24] <pasteling> "theorbtwo" at 84.245.186.105 pasted "higraph" (52 lines, 1.5K) at http://sial.org/pbot/9733

[15:29] <castaway> hey autrijus

[15:34] <autrijus> yo

[15:35] <castaway> did you read my claim about for -> $var is rw, just now?

[15:35] <castaway> ie that pointy subs arent supposed to have traits ?

[15:35] <castaway> James is arguing that the trait then applies to the $var, which makes no sense to me..

[15:38] <stevan> nothingmuch: ping

[15:38] <stevan> hey autrijus :)

[15:38] <nothingmuch> hola

[15:38] <nothingmuch> sorry stevan, my network died

[15:44] <castaway> oh damn.. I think I get it.. (badly written docs)--

[15:45] <theorbtwo> castaway: http://www.nntp.perl.org/group/perl.perl6.language/20674

[15:58] <elmex> is timely destruction really not used much?

[16:02] <autrijus> yay.

[16:02] <autrijus> I finall won against the dependency monster

[16:03] <autrijus> I had to use this super ugly ninjatsu weapon that is #include ;)

[16:04] <elmex> hm

[16:04] <elmex> autrijus: what do you think, is timely destruction really that rare used?

[16:04] <obra> autrijus: I've had two people in the past 24 hours ask me how to pronounce autrijus

[16:04] <autrijus> obra: autrijus.org/autrijus.mp3

[16:04] <obra> perhaps http://autrijus.org/autrijus.mp3 should be in the pugs faq?

[16:04] <autrijus> eh.

[16:04] * obra grins

[16:05] <autrijus> feel free to add it to my wikipedia page ;)

[16:05] <obra> *snerk* 

[16:05] <ninereasons> I love that it sounds almost like "outrageous"

[16:05] <stevan> auh-tree-jus

[16:06] <obra> They decided not to delete it? neat

[16:06] <autrijus> yeah. apparently a week or so ago MJD went thru the same VfD

[16:09] *** [1]metaperl_ is now known as _metaperl

[16:10] <elmex> warnocked?

[16:12] <autrijus> hm?

[16:14] <Arathorn> did matt fowles silently devolve responsibility for p6*-summarizing back to piers cawley?

[16:14] <stevan> autrijus: i have some questions about src/Pugs/Types/* if you have some time

[16:14] <stevan> Arathorn: they are splitting it

[16:15] <stevan> peirs, then matt, then peirs, then matt

[16:15] <Arathorn> ah, interleaving - gotcha

[16:15] <Arathorn> funky :)

[16:15] <stevan> zip(@piers, @matt)

[16:15] <Arathorn> or 􏿽xA5 or whatever :)

[16:18] <stevan> gather { for zip(@piers, @matt) -> $summary { take $summary; sleep 604800; }}

[16:18] <stevan> (i think)

[16:18] <autrijus> stevan: I'm annihilating them

[16:19] <autrijus> so whatever questions you have, will no longer apply :)

[16:19] <stevan> autrijus: LOL

[16:19] <stevan> ok

[16:19] <stevan> why?

[16:19] <autrijus> difficult to answer.

[16:19] <stevan> autrijus: ok, nevermind then

[16:20] <autrijus> "due to limitations of GHC's mutual module recursion"

[16:20] <stevan> autrijus: I wanted to start documenting some haskell to help me learn it

[16:20] <stevan> autrijus: any good place to start?

[16:21] <autrijus> stevan: sure! start with Eval.hs?

[16:22] <stevan> autrijus: ok

[16:22] <stevan> should I try doing Haddock ? or POD within multi-line comments?

[16:22] <autrijus> try haddock

[16:22] <stevan> ok

[16:29] * Limbic_Region hopes he didn't sound like he was complaining about junctions on p6.l

[16:30] <revdiablo> Limbic_Region: it didn't seem that way when I read it.

[16:30] <Limbic_Region> autrijus - should functions like defined() work on $_ if no $var is specified?

[16:31] <Limbic_Region> for instance my @matches = grep { defined } @list;

[16:31] <gaal> L~R, many do: see the bottom of Prim.hs and look for Str=$_

[16:32] <gaal> ?Str=$_, rather.

[16:33] <Limbic_Region> ok, so the next question is that if it doesn't - is that by design or oversight

[16:34] <Limbic_Region> cause I really expected my @matches = grep { defined } @list; # to work

[16:35] <autrijus> Limbic_Region: feel free to fix.

[16:35] <gaal> i don't know. s29 is the spec for most of these. if it's not there, you could try asking rod adams

[16:35] <autrijus> defined() is not there.

[16:35] <autrijus> please send patch to rod

[16:36] <gaal> i wonder why defined doesn't take $_ in p5

[16:36] <gaal> (i think it doesn't?)

[16:36] <gaal> oh, it does

[16:36] <autrijus> O the glorious typechecker

[16:36] <nothingmuch> hoi!

[16:36] <autrijus> Be thou my guardian and my guide

[16:36] <autrijus> Be thou my vision

[16:37] <autrijus> Bind the variables together, O lord

[16:37] * autrijus finally eliminated AST.hs-boot!

[16:37] <Limbic_Region> yeah autrijus

[16:37] <autrijus> theorbtwo: we are now free to do whatever type refactoring!

[16:37] <autrijus> as a bonus, I expecte performance to increase even more.

[16:37] <nothingmuch> autrijus: does hash/stm hinder performance?

[16:38] <autrijus> nothingmuch: I don't know, hadn't tested

[16:38] <gaal> O dark mysterious parsec

[16:38] <autrijus> nothingmuch: run a smoke after I checkin?

[16:38] <nothingmuch> my ssh tunnel is not reincarnating

[16:38] <autrijus> to time it that is

[16:38] <autrijus> aw.

[16:38] <nothingmuch> so i can't compare

[16:38] <autrijus> k.

[16:38] <gaal> Art thy named for thy unfathomable lengths

[16:38] <nothingmuch> but i can do it on eris

[16:38] <nothingmuch> i'll time now

[16:38] <nothingmuch> and time later

[16:38] <nothingmuch> good enough?

[16:38] <gaal> thy imponderable distances

[16:39] <gaal> thy silences?

[16:39] <autrijus> nothingmuch: sure. I will do that same :)

[16:39] <autrijus> it's in as r2441.

[16:40] <nothingmuch> okay, compiling and testing 2440 and then 2441

[16:40] <autrijus> cool.

[16:41] <gaal> autrijus, got some time to look at my #line attempts? it works except for where it breaks :)

[16:41] <autrijus> gaal: sure. url?

[16:41] <pasteling> "gaal" at 192.115.25.249 pasted "#line attempts" (31 lines, 1.2K) at http://sial.org/pbot/9738

[16:41] <jabbot> pugs - 2441 - * AST.hs-boot elimianted!

[16:42] <gaal> that's the code. following is a sample file for which this works:

[16:42] <pasteling> "gaal" at 192.115.25.249 pasted "works here" (10 lines, 217B) at http://sial.org/pbot/9739

[16:43] <gaal> notes: 1. i know i'm doing something wrong aroung "ld <- try $ do" because fail "" from there leaves the function;

[16:44] <autrijus> duration went from 196 to 171 here.

[16:44] <gaal> 2. this breaks with e.g. t/statements/last.t - with very weird debug prints, e.g. reported line numbers that go up to line 72 - much more than the length of that file.

[16:45] <nothingmuch> it got faster?

[16:45] <nothingmuch> mine is still compiling

[16:45] <autrijus> (before and after the STM+AST.hs-boot) change 

[16:45] <autrijus> yeah, it got much faster.

[16:45] <nothingmuch> =)

[16:45] <autrijus> gaal: ok, will look.

[16:45] <nothingmuch> in that case we can say that it's because STM and not because of AST.hs-boot

[16:45] <nothingmuch> and thus claim that atomicity improves performance ;-)

[16:45] <autrijus> that'd be lying ;)

[16:46] <gaal> so, first, i realize my "try" there is incorrect, but what i'm trying to do there is clean up after lines that *look* like they're going to be #line directives, but turn out not to parse as such

[16:46] <nothingmuch> don't tell anyone =)

[16:47] <autrijus> you do realized we are on a public logged channel :)

[16:47] <Limbic_Region> gaal - I was just about to start working on last.t and I noticed your note - something I should be concerned about?

[16:47] <gaal> by clean up i mean just treat them as comments, skip to the end of the line. i have to do this inside ruleLineDirective because my parsing there consumes input, so the regular comment rule in ruleComment won't be tried.

[16:48] <nothingmuch> sorry

[16:48] <nothingmuch> there, now that wasn't logged.

[16:48] <autrijus> ...

[16:48] <gaal> L~R, no, i think this is all in my code :)

[16:48] <gaal> I was just picking on that test as an example.

[16:48] <nothingmuch> compile.... sooooo.... sloooooowwww

[16:49] <nothingmuch> can ghc compile two modules in parallel somehow?

[16:49] <Limbic_Region> oh - so last <label> isn't currently defined/implemented right - what is the proper way to mark a test as skip/todo/foo ?

[16:50] <nothingmuch> Limbic_Region: is(1, 2, "one is two", :todo);

[16:50] <gaal> L~R, try to wrap the whole test in eval, so it only passes when it deserves to

[16:50] <gaal> if you have a hard parsefail, comment out the lines and add a note. see t/README

[16:51] <nothingmuch> you could also do:

[16:51] <nothingmuch> eval_is("perl code", $expected, "foo", :todo);

[16:51] <nothingmuch> that will report the error too, for added goodness

[16:51] <nothingmuch> there is lots of example code

[16:52] <gaal> but remember, L~R, that if you do that you can't $expect 0. :)

[16:52] <Limbic_Region> ok, and eval_is() is fine to add as a planned test right?

[16:52] <gaal> sure!

[16:53] <gaal> except for the 0 caveat, and for hard parsefails, it does most of the work.

[16:53] <nothingmuch> Limbic_Region: sure

[16:54] <nothingmuch> why can't you expect 0?

[16:54] <gaal> because is(undef, 0) passes

[16:54] <gaal> and thus so will is_eval("die", 0)

[16:54] <nothingmuch> if the eval dies then it dies

[16:54] <nothingmuch> otoh: is(eval '0', 0, "caveat")?

[16:54] <nothingmuch> eval_is('die', 0, "shouldn't pass");

[16:54] <nothingmuch> eval_is checks that there was an error

[16:54] <gaal> walla?

[16:55] <nothingmuch> i wrote it, i should know

[16:55] <gaal> cool, good job then.

[16:55] <nothingmuch> that's actually why i wrote it =)

[16:55] <gaal> so it's like p5's lives_and

[16:56] <gaal> nothingmuch++; # apis of least surprise

[16:56] <gaal> though when we first talked about this, i think i asked you to document it. :-P

[16:56] <nothingmuch> crap

[16:57] <nothingmuch> something changed

[16:57] <gaal> you don't love me anymore!

[16:57] <nothingmuch> there

[16:58] <nothingmuch> $! began being false

[16:58] <nothingmuch> so i made it check for def

[16:59] <nothingmuch> perlbot: nopaste

[16:59] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[16:59] <pasteling> "nothingmuch" at 212.143.91.217 pasted "eval_is" (33 lines, 856B) at http://sial.org/pbot/9740

[16:59] *** Aankh|Clone is now known as Aankhen``

[17:00] <Limbic_Region> nothingmuch - I need some help with the eval_is() test

[17:00] <nothingmuch> okay

[17:01] <Limbic_Region> basically what I want to do is define a variable, define a label, write a for loop, first statement is to last <lable>, second should assign to variable though should never be reached - the test should verify that it is not set

[17:01] <jabbot> pugs - 2442 - fix eval_is and eval_ok

[17:02] <nothingmuch> right

[17:02] * gaal makes some yerba mate & # brb

[17:03] <nothingmuch> eval_is('my $var = 0; for (1..2){ last; $var++ }; $var', 0, "var was not incremeted because loop exited");

[17:03] <nothingmuch> orr if your loop is going to be longer than you want to fit in a string:

[17:03] <nothingmuch> my $var = 0;

[17:03] <Limbic_Region> wait - that's good enough

[17:03] <nothingmuch> eval 'for (....) { ...ijalktjlaktj }';

[17:03] <nothingmuch> is($var, 0, "blah");

[17:03] <nothingmuch> otoh if it actually parses you may want to say

[17:03] <Limbic_Region> I didn't understand the last $var part being the returned value from the eval

[17:04] <nothingmuch> try { for (...) { ... } };

[17:04] <nothingmuch> that's just like in p5

[17:04] <nothingmuch> the whole eval is an rvalue

[17:06] <Limbic_Region> so eval_is('my $var=0; DONE: for (1..2) { last DONE; $var  ;} $var', 0, "var is 0 because last before increment");

[17:07] <nothingmuch> yep

[17:07] <nothingmuch> although if you're testing that

[17:07] <nothingmuch> nest two loops

[17:08] <nothingmuch> in another test

[17:08] <nothingmuch> (it's good to see some tests starting to pass if you develop, helps you assess which way you are progressing)

[17:09] <Limbic_Region> nothingmuch - was already augmenting stevan's tests with multiple loops, plain jane last, and last label - just didn't know how to do the last one

[17:10] <nothingmuch> so there's a test for 'OUTER: for (1..2) { INNER: for (1..2) { last OUTER } }' ?

[17:11] <Limbic_Region> s/there's/there's going to be/

[17:11] <Limbic_Region> I haven't finished yet

[17:11] <nothingmuch> ah, ok

[17:11] <nothingmuch> that's what I meant

[17:11] <Limbic_Region> yep yep

[17:11] <nothingmuch> see also a test i wrote on block level closures

[17:11] <gaal> http://forum2.org/gaal/pugs/smoke-msys.html r2441

[17:11] <nothingmuch> err, whatever they're called

[17:12] <nothingmuch> t/statements/control_blocks.t t/statements/control_blocks.t 

[17:20] <revdiablo> I have some simple recursion tests I wrote. I assume they should go into t/subroutines/recurse.t? the subs are named horribly right now, should I just check them in and perhaps someone else can think of better names?

[17:20] <nothingmuch> revdiablo: you can do that

[17:20] <nothingmuch> and commit if they don't come within 2-3 minutes

[17:20] <nothingmuch> you can also nopaste

[17:20] <nothingmuch> wait for comments

[17:20] <gaal> yes :) if you like, you can leave a comment describing what kinda thing you have in mind

[17:20] <nothingmuch> whichever you prefer

[17:21] <nothingmuch> bass is tempting

[17:22] <revdiablo> I guess I'll nopaste first

[17:23] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Do these look reasonable" (84 lines, 1.5K) at http://sial.org/pbot/9742

[17:23] <Limbic_Region> well, other than there should be 7 tests instead of 6

[17:24] * Limbic_Region is unable to test them ATM

[17:24] <pasteling> "revdiablo" at 24.75.156.86 pasted "a few recursion tests. could shorter/easier sub names. any suggestions?" (62 lines, 1.9K) at http://sial.org/pbot/9744

[17:25] <gaal> L~R, looks good to me

[17:25] <gaal> usually tests say "kwid" and not "pod" though.

[17:26] <Limbic_Region> gaal - blame stevan

[17:26] <Limbic_Region> I am only augmenting his first 3 tests

[17:27] <Limbic_Region> ok - should :todo work - or is that only for the harness?

[17:27] <gaal> revidiablo - you can, if you like, use one function only, and move the behavioral params to sub args.

[17:27] <gaal> not sure that makes things better though.

[17:28] <Limbic_Region> btw - the test found a bug so that's a good thing right?

[17:28] <gaal> :todo works - how it is interpreted depends on who is running it.

[17:28] <gaal> it's a TAP thing; appends # TODO to the test.

[17:28] <gaal> to the test description that is.

[17:29] <Limbic_Region> well, I ran it as Pugs last.t

[17:29] <Limbic_Region> and it bombed out saying that :todo was undefined

[17:29] <gaal> it used to be spelled :todo(1) recently - maybe you're using an old verison of Test.pm?

[17:30] <gaal> set your PERL6LIB explicitly to avoid that

[17:30] <Limbic_Region> I just copied/pasted from svn 

[17:30] <Limbic_Region> since I am using a binary version of Pugs by Johnathan

[17:30] * Limbic_Region has limited capabilities from work

[17:30] <gaal> what is your Test.pm?

[17:31] <Limbic_Region> from 2442

[17:31] <gaal> and you're sure you'e running that one and not one form a previosu make install?

[17:31] <Limbic_Region> 0.0.5

[17:31] * Limbic_Region didn't make Pugs

[17:32] <Limbic_Region> I am using a binary distribution

[17:32] <Limbic_Region> I went to svn, copied/pasted Test.pm directly from svn

[17:32] <gaal> okay.. what happens when you try to run, eg, t/syntax/symbol_table.t ?

[17:33] <Limbic_Region> just a sec

[17:33] <gaal> that's just a random other test that uses :todo

[17:33] <Limbic_Region> btw - the binary distro doesn't come with the tests so I have to copy/paste each one 

[17:36] <Limbic_Region> changing :todo to :todo(1) appears to be working

[17:37] <gaal> hmmm, maybe the fix was in fact in pugs itself, not Test.pm; and your build is a little old?

[17:37] <gaal> r2406 fixed that.

[17:38] <gaal> no, sorry. r2406 just s///ed the tests.

[17:38] <gaal> i don't know where :todo started working.

[17:39] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Can someone check this in as t/statements/last.t" (84 lines, 1.5K) at http://sial.org/pbot/9745

[17:39] <mj> r2403 vs. r2440 ...  http://test.wikidev.net/Pugs_tests_full?title=Pugs_tests_full&diff=0&oldid=782

[17:40] <Limbic_Region> gaal - I can't checkin from work - could you be so kind?

[17:40] <gaal> sure, one sec.

[17:40] <Limbic_Region> btw - it exposes a bug

[17:41] <Limbic_Region> last in nested loops doesn't work

[17:41] <Limbic_Region> s/work/work correctly/

[17:41] <gaal> cool :)

[17:41] <Limbic_Region> it jumps out of all loops not just the current one

[17:42] <Limbic_Region> going to go work on the next tests next

[17:42] <machack666> is there a tags module that works with haskell?

[17:42] <Limbic_Region> oh yeah, all of next is todo

[17:43] <machack666> n/m...just googled for hasktags

[17:45] <gaal> machack666: there's also a exctags patch if hasktags don't wokr for you.

[17:45] <gaal> r2443, thanks L~R!

[17:46] <machack666> hmm...hasktags doesn't like living on HFS+

[17:46] <gaal> machak666, can you compile exctags? i'll give you the patch, sec.

[17:47] <machack666> I'll have to d/l it ... etags is what came with my system

[17:47] <gaal> http://www.livejournal.com/users/gaal/161104.html # against exuberant ctags 5.5.4

[17:48] * Limbic_Region notes that he hasn't eaten yet and will tackle the next tests when he returns

[17:48] * Limbic_Region food &

[17:48] <gaal> oh, and you'll have to fudge the newlines in the mac makefile, sorry :) i just noticed i'd copied the visual representation of a mac newline.

[17:48] <machack666> is it just a perl module, or am I looking for a source tree for a binary?

[17:49] <gaal> it's a c project

[17:49] <gaal> if you were on linux i'd just send you my binary.

[17:50] <gaal> hey, i can send you my tags if you like! :)

[17:50] <machack666> OS X, (un-)fortunately.  :D

[17:50] <gaal> vim or emacs style?

[17:50] <machack666> emacs

[17:50] <gaal> sec

[17:51] <jabbot> pugs - 2443 - add tests, expose bug (Limbig~Region)

[17:53] <gaal> machack666: http://forum2.org/gaal/pugs/TAGS.gz

[17:53] <gaal> gunzip it and drop it in your source root.

[17:53] <machack666> thanks

[17:53] <gaal> sure

[17:59] <machack666> how would you get a handle on the active closure?  I'm trying to add closure traits and I believe that they are all contained within the declaring block.  In order to add those traits though, I need to know which VCode block I'm adding to.

[17:59] <machack666> also, is the global scope just a VCode as well?

[18:00] <machack666> That would mean that we wouldn't need special case code for BEGIN {} and END {} blocks at the package level

[18:00] <machack666> they could just be handled in the same way as ordinary blocks

[18:18] <Limbic_Region> stevan ping

[18:19] <Limbic_Region> hmmm - I am wondering if I should convert the next.t tests to is_eval() like I did in last.t since next isn't implemented at all yet?

[18:22] <jabbot> pugs - 2444 - msg for require failed (not same as not 

[18:22] <jabbot> pugs - 2445 - tests to check the return values for som

[18:25] * theorbtwo wonders if there is a good way to make a eval_haskell('code' :imports<IO>) work.

[18:28] <Limbic_Region> does 2 < $foo < 4 work yet?

[18:28] <machack666> pugs -e 'say "yes" if 2<3<4'

[18:28] <machack666> yes

[18:29] <machack666> pugs -e 'say "yes" if 2<6<4'

[18:29] <machack666> <nothing>

[18:29] <Limbic_Region> yeah, I did the TIAS approach right after asking

[18:29] <machack666> TIAS?

[18:30] <revdiablo> try it and see

[18:30] <machack666> ah

[18:35] <Corion> How long does a Linux fsck disk scan of a 40GB disk usually take? I just had to reboot a box, and it doesn't respond to pings yet ...

[18:35] <Corion> (let's assume a standard, cheapo IDE disk)

[18:36] <obra> was it dirty?

[18:36] <obra> has it been more than 15 minutes?

[18:38] <Corion> obra: Not yet - I started the reboot about ten minutes ago. The box didn't respond (except to pings) and all ports were closed.

[18:38] <Corion> So yes, it likely is dirty, as I rebooted the box from the rescue console and not from within the box :)

[18:38] <obra> nothing's wrong yet ;)

[18:39] <Corion> obra: But I'm nervous :)

[18:39] <obra> sure

[18:40] <autrijus> rod says he will be dismayed if autothreading actually use threads.

[18:40] <autrijus> I wonder why not ;)

[18:40] * autrijus ponders dismaying rod just for the fun of it

[18:41] <Arathorn> what would it use instead? coroutine-style concurrency?

[18:41] <autrijus> STM.

[18:41] <autrijus> (and lightweight threads)

[18:41] <autrijus> i.e. not ithreads.

[18:42] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Can someone check this in as t/statements/next.t" (84 lines, 1.6K) at http://sial.org/pbot/9748

[18:42] <Limbic_Region> autrijus - one of my tests for last exposed a bug :-)

[18:42] <autrijus> Limbic_Region: ooh

[18:42] <machack666> autrijus: I'm working on the closure traits and it looks like some of the changes I need to make are in Monads.hs -- enterBlock and some others

[18:42] <autrijus> please someone check it in then

[18:42] * autrijus is journaling

[18:42] <autrijus> machack666: that sounds correct.

[18:42] <Limbic_Region> already done btw

[18:42] <autrijus> machack666: please hack away.

[18:43] <Limbic_Region> last in nested loops jumps out of all of them, not just inner

[18:43] <machack666> how do I pull my subTraits from the VCode object

[18:43] * machack666 does not know haskell, but is doing his best to fake it

[18:43] <Limbic_Region> I modified the next.t to include all the same tests as last.t and put them in eval_is because next in for loops is still todo

[18:43] <autrijus> machack666: subTraits vsub

[18:43] <autrijus> machack666: when you see

[18:44] <autrijus> data Foo = MkFoo { field :: Type }

[18:44] <autrijus> the "field" thing is of type

[18:44] <autrijus> field :: Foo -> Type

[18:44] <autrijus> i.e. built in accessor

[18:44] <autrijus> and you can use it as builtin updater too

[18:44] <autrijus> foo { field = newFieldValue }

[18:44] <autrijus> and even as pattern matcher

[18:44] * Limbic_Region would appreciate someone checking in http://sial.org/pbot/9748 for him even though he will be home in a couple hours

[18:45] <autrijus> func foo@MkFoo{ field = varName } = ... varName ...

[18:45] <machack666> I've got that set up with traits as a Pad

[18:45] <machack666> i.e., subTraits = !Pad

[18:45] <machack666> I'm not sure how to write/read from the pad, or to retrieve the pad to do so in the block execution context

[18:45] <autrijus> Limbic_Region: done

[18:45] <autrijus> you can just say

[18:45] <autrijus> subTraits vsub

[18:45] <autrijus> to get a Pad

[18:46] <autrijus> where vsub is a VCode

[18:46] <Limbic_Region> thanks - though I think there is a mistake

[18:46] <autrijus> Limbic_Region: oh?

[18:47] <Limbic_Region> copy/paste error is() should be eval_is()

[18:47] <Limbic_Region> let me fix 

[18:48] <nothingmuch> anybody got a list of int'l registrars?

[18:49] <machack666> so my idea is to just use the array functions internal to perl to store the various trait blocks

[18:49] <machack666> i.e. the equivalent of unshift @traits[ENTER], {};

[18:49] <machack666> I also need to store some sort of state for traits which are conditionaly executed -- FIRST

[18:49] <machack666> ok, I think I see

[18:51] <Limbic_Region> grrrr

[18:51] <jabbot> pugs - 2446 - * next.t, from Limbic_Region

[18:53] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "I can't figure out what is wrong with this (if anything)" (83 lines, 1.6K) at http://sial.org/pbot/9749

[18:53] <Limbic_Region> the next.t that got checked in is definately wrong, but I am not sure the latest paste is right either - this eval_is stuff for todo items make me wonder

[18:57] <Limbic_Region> ok - I think it must be right but it is a failed parse - which is to be expected because labels aren't implemented yet

[18:58] <Limbic_Region> so, at someone's convenience (I will tonight if no one else can now) check in http://sial.org/pbot/9749 as t/statements/next.t

[19:01] <jabbot> pugs - 2447 - delete a garbage file

[19:01] <jabbot> pugs - 2448 - ** update from L~R on next.t

[19:03] <Limbic_Region> ok - so now I just need to figure out how to make defined() look at $_ if $var isn't specified

[19:04] <Limbic_Region> well, I have a lot to figure out but that's next on the list ;-)

[19:05] <autrijus> Limbic_Region: just fix the PRim.hs

[19:05] <autrijus> and fix its prototype to be ?=$_

[19:06] <Limbic_Region> that seemed too easy

[19:06] * Limbic_Region was thinking there had to be more to it 

[19:12] <Limbic_Region> ok - so there are only two lines in Prim.hs that I think may be applicable "op1 "defined" = op1Cast (VBool . defined)" and "\\n   Bool      pre     defined (Any)\" of those two, I think only the second one needs to be modified - to "\\n   Bool      pre     defined (?Any=$_)\"  

[19:12] <Limbic_Region> does that sound right?

[19:15] <machack666> I don't know for sure, but would you make an op0 defined which calls the op1 variant with the $_ as the topic? </out of ass>

[19:16] <Limbic_Region> well, I will stick to what I know for now

[19:16] <Limbic_Region> plenty of time to learn

[19:16] <Limbic_Region> and it isn't a big deal since my @matches = grep { defined $_ } @list; is only 2 strokes (3 if you count the space)

[19:17] <machack666> does the implicit block form of grep work?  i.e., "grep &defined, @list"

[19:18] * Limbic_Region doesn't think so

[19:18] <Limbic_Region> or rather, I don't think it is supposed to work

[19:18] <machack666> deprecated in p6?

[19:18] * Limbic_Region hasn't comitted the bible to memory yet 

[19:19] <Limbic_Region> no - not supported

[19:19] <Limbic_Region> but I could be wrong - either way it isn't deprecated - either it is supported or it isn't

[19:19] <PerlJam> surely it must be supported in some way.

[19:20] <PerlJam> { ... } is a coderef just as &foo would be.

[19:21] <Limbic_Region> I REALLY wish I had been paying attention to p6.l as long as I paid attention to p6.i

[19:23] <machack666> in enterBlock, is action a VCode ?

[19:23] <autrijus> grep &defined, @line;  # is just fine

[19:23] <autrijus> grep defined, @line; # bad

[19:24] <autrijus> machack666: no, it's a "Eval Val"

[19:24] <Limbic_Region> what about grep defined(), @line;

[19:24] <autrijus> machack666: feel free to add types to it

[19:24] <autrijus> you can do it by

[19:24] <autrijus> make ghci

[19:24] <autrijus> :m Pugs.Monads

[19:24] <autrijus> :t enterBlock

[19:24] <autrijus> that will tell you its type

[19:24] <autrijus> which you can then add to the line before enterBlock

[19:24] <autrijus> Limbic_Region: still bad

[19:25] <machack666> autrijus: so I'm declaring an explicit type signature?

[19:25] <autrijus> machack666: yeah

[19:25] <autrijus> just to enhance readability

[19:25] <autrijus> I should do that more

[19:25] <machack666> so, how would I get the VCode for the block being executed?

[19:26] <machack666> (sorry for all the stupid questions...)

[19:26] <Limbic_Region> ok - &defined is only 1 stroke over - though I will see try and understand enough to not just guess WRT Prim.hs

[19:26] <autrijus> machack666: no, please ask them

[19:26] <autrijus> machack666: you can get it by readling &?BLOCK perhaps

[19:27] <autrijus> but I really need to sleep

[19:27] <machack666> and is there an exitBlock or some equivalent to trigger the traits on leaving?

[19:27] <autrijus> see you in 9 hours or so :)

[19:27] <autrijus> machack666: no, it's all done monadically

[19:27] <Limbic_Region> good sleep

[19:27] <machack666> ok autrijus -- thanks for your help

[19:27] <autrijus> machack666: so there's no explicit calls

[19:27] <autrijus> atomically powered journal up

[19:27] <autrijus> g'nite!

[19:27] <autrijus> &

[19:34] <Limbic_Region> autochomp is default behavior in p6 right?

[19:34] <misc> Limbic_Region: no, according to doc

[19:35] <Limbic_Region> hmmm - I must be drinking punch instead of koolaid

[19:35] <machack666> you can specify it as an attribute for handles, though

[19:35] <Limbic_Region> machack666 - got an example?

[19:36] <machack666> I think it's just $STDIN is autochomp ... or something

[19:36] <machack666> or is chomped

[19:36] * Limbic_Region will look around for it

[19:37] <machack666> $ARGS is chomped;

[19:38] <machack666> from our very own motd example;

[19:38] <machack666> # my @list = =$fh is chomped;

[19:38] <machack666> (not currently working, though)

[19:39] <Limbic_Region> ok - here is what I am looking to do, for simple questions at the Monastery - add both a p5 and a p6 solution

[19:39] <Limbic_Region> much like what Randal did way back when

[19:40] <Limbic_Region> here was the first one I was going to take a stab at http://www.perlmonks.org/index.pl?node_id=449639

[19:40] <machack666> is it supposed to be working p6, or just soon-to-be-working p6?

[19:41] <Limbic_Region> so anyone that has the current know-how, I welcome you to add a p6 solution.  For now, I better eat my wheaties (RTFM more)

[19:41] <Limbic_Region> machack666 - my intention is to be "if the language were already finished" solutions

[19:41] <machack666> I take it this is the p5 soultion?

[19:41] <Limbic_Region> it would be nice if also worked today - but not a requirement

[19:41] <Limbic_Region> right - I posted that a short while back

[19:47] <machack666> perlbot, paste?

[19:47] <perlbot> Paste your code and #perl will be able to view it: http://sial.org/pbot/perl http://dragon.cbi.tamucc.edu:8080 http://erxz.com/pb

[19:48] <machack666> Limbic_Region: here's a first attempt

[19:49] <Limbic_Region> ?

[19:49] <machack666> I made up the open semantics because I'm too lazy to lok them up

[19:49] <machack666> http://sial.org/pbot/9752

[19:49] <machack666> (I thought the paste bot submitted the link to the channel)

[19:50] <theorbtwo> It does, if you tell it to.

[19:50] <machack666> ah

[19:50] <Limbic_Region> it does, but you have to select the channel from the drop down

[19:50] <machack666> someone in #perl is very confused

[19:51] <machack666> perlbot pointed me to the wrong channel :)

[19:51] <Limbic_Region> heh

[19:51] <machack666> who admins perlbot

[19:51] <Limbic_Region> chris62vw

[19:51] <machack666> we should change it so it thinks it's on #perl6

[19:51] <Limbic_Region> it is a multi-channel bot

[19:51] <Limbic_Region> wouldn't work

[19:51] <Limbic_Region> perlbot nopaste

[19:51] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[19:52] <Limbic_Region> if you had asked for the right thing, you wouldn't have gone astray machack666

[19:52] <machack666> picky picky computers...

[19:52] <machack666> always doing what I say, not what I mean

[19:52] <Limbic_Region> do you have an acct at the Monastery machack666 ?

[19:53] <machack666> not under this nick, if at all

[19:53] <Limbic_Region> I will likely revisit this tonight or tomorrow - once I have a chance to verify stuff

[19:53] * Limbic_Region just wants to give credit where credit is due

[19:54] <machack666> I should have one shortly

[19:54] <machack666> it autofilled in my email addy for perlmonks, so I must have signed up before...

[19:54] <Limbic_Region> machack666 - a great way to improve your p6 skills as well as p6 advocacy would be answering simple questions there with both p5 and p6 answers

[19:55] <Limbic_Region> I intend to do so from now on (when I can anyway)

[19:55] <Corion> Limbic_Region: You're luring folks into the hivethink of PM! :-))

[19:55] <Limbic_Region> Corion - hey, I was just trying to get hardburn to spend more time here

[19:55] <Limbic_Region> it works both ways you know

[19:55] <Corion> Limbic_Region: :))

[19:57] <machack666> ok, I've shaved my head and I'm now wearing robes.

[19:58] <Limbic_Region> welcome machack666

[19:59] <machack666> thanks

[20:00] * Limbic_Region is going to need to send a patch for Perl6::Bible

[20:01] <machack666> hey, which twigil is compile-time and which one is runtime?

[20:01] <Corion> $* is compile time and $? is runtime. Or so I think ($?CALLER)

[20:01] <Corion> Hmmm. No, $* is global I think (%*ENV)

[20:01] <Corion> I'm confused

[20:02] <machack666> surely there's a mnenomic

[20:03] <machack666> compiling is done once, so it's '?', while the runtime value could have many options over time '*'

[20:03] <Limbic_Region> Perl6::Bible is ingy's deal right?

[20:03] <Limbic_Region> seen ingy?

[20:03] <jabbot> Limbic_Region: ingy was seen 1 days 1 hours 42 minutes 52 seconds ago

[20:03] <ingy_> hola

[20:03] <machack666> S02 to the rescue...

[20:03] <ingy_> Limbic_Region: are there updates to release?

[20:04] * ingy_ checks

[20:04] <Limbic_Region> no, just wanted to run something by you before sending a patch

[20:04] <machack666> $? is compile-time, while $* is runtime

[20:04] <ingy_> ok

[20:04] <Limbic_Region> Perl6::Bible invokes perldoc but it doesn't allow you to pass display options - such as -t 

[20:05] <Limbic_Region> which makes it look wonky for me

[20:05] <ingy_> ok

[20:05] <Limbic_Region> so the question is, how would you like the interface to be and I will code the interface to work

[20:06] <ingy_> oh thanks

[20:06] <Limbic_Region> p6bible -o "perldoc display options" ?

[20:06] <Limbic_Region> where they get passed in raw and let perldoc blow up if appropriate?

[20:07] <ingy_> sounds really good actually

[20:07] <Limbic_Region> ok - will send you a patch tonight or tomorrow

[20:07] <ingy_> great

[20:08] <Limbic_Region> too close to hometime for me to do it now - I have a tendency to forget the time and make my wife unhappy because I am not home on time

[20:17] <Limbic_Region> Jonathan_ - are you the same Jonathan as http://www.jwcs.net/~jonathan/perl6/ ?

[20:17] <Jonathan_> Yes.

[20:18] <Limbic_Region> ok - can I offer a suggestion?

[20:18] <Jonathan_> And I think we talked once or twice on Parrot related stuff a while back too...before the RSI invaded and I had to drop doing stuff.

[20:18] <Jonathan_> Yeah, for sure.

[20:18] <Limbic_Region> in your binary builds, you have @INC pointing to your F drive

[20:19] <Jonathan_> Hmmm...

[20:19] <Limbic_Region> but you don't actually include the libraries 

[20:19] <Jonathan_> That sucks.

[20:19] <Limbic_Region> I was going to use subst F: to get around it

[20:19] <Jonathan_> Where is the default @INC stashed?

[20:19] <Limbic_Region> but since the modules aren't part of the build it didn't matter

[20:20] <Limbic_Region> dunno - my suggestion was going to be a workaround

[20:21] <Limbic_Region> I am not all that familiar with building Pugs (I have about 2 days under my belt)

[20:21] <Jonathan_> OK, I have made it so the "ext" folder containing the modules will be put into the build.

[20:21] <Jonathan_> I should chase down this @INC issue too.

[20:21] <Limbic_Region> I was going to suggest including the lib directories in the tar ball with a readme.txt on how to use subst to simulate an F drive

[20:23] <Limbic_Region> in particular - I couldn't use Test.pm which was a bad thing since I was writing tests today

[20:23] <Limbic_Region> but kudos for nightly binary builds - I wouldn't be able to do Pugs at work sanely without them

[20:25] <Jonathan_> You're welcome, happy they're useful.

[20:26] <Jonathan_> I'll do a re-build in just a moment so you can download one with the modules...let me have a quick scout around to see if I can get @INC to do something more sane first.

[20:26] <Limbic_Region> ok - that way I can give you the subst command if modifying @INC is going to be a PITA

[20:28] <Limbic_Region> is it ready for download yet?

[20:29] <Jonathan_> No, still looking for this @INC thing...can you give me the contents of @INC that you're seeing please?

[20:30] <Jonathan_> I'll do the new build now, in case this @INC thing takes a while. Will take a few mins to build and upload.

[20:30] <Limbic_Region> sure 

[20:31] <Limbic_Region> F:\Perl6\lib; F:\Perl6\lib; F:\Perl6\site\lib; F:\Perl6\site\lib; .

[20:31] <Limbic_Region> yes, the first two are repeated

[20:31] <Limbic_Region> luckily . is in the path, which made copy/pasting Test.pm fix my immediate problem

[20:32] <Jonathan_> It'd be a lot nicer if it said C:\ instead...

[20:32] * Jonathan_ ponders extreme hackage to make that so.

[20:33] * Limbic_Region guesses someone groking subst is too much to ask for

[20:33] <Limbic_Region> well - I need to go RSN so unless it is close I will talk to you about it tomorrow?

[20:33] <Jonathan_> The build is almost there.

[20:33] <Limbic_Region> and by "someone" - I mean target audience

[20:34] <Corion_> Meh. No smoke tests because the webserver is down :(

[20:34] <Corion_> (my webserver that is)

[20:34] * Limbic_Region saw that too Corion_

[20:34] *** Corion_ is now known as Corion

[20:36] <Jonathan_> Limbic_Region: It's there.

[20:36] <Limbic_Region> downloading now

[20:37] <Jonathan_> Ah, it's doing a fresh smoke too. :)

[20:37] <Limbic_Region> Jonathan_ - I still don't see a Test.pm in the zip file???

[20:38] <Limbic_Region> and I really do have to go now

[20:38] <Jonathan_> Somewhere in ext/Test.

[20:38] <gaal> L~R, what's not working with subst?

[20:39] <Limbic_Region> gaal - nothing - the problem is the libraries themselves aren't part of the zip file

[20:39] <Limbic_Region> Jonathan_ - they aren't there

[20:39] <gaal> ext/Test/lib/Test.pm

[20:39] <Jonathan_> Yeah, I see it in the ZIP file.

[20:39] <Limbic_Region> hrrrmm

[20:39] <Jonathan_> Do you not?

[20:40] <Limbic_Region> no

[20:40] <Limbic_Region> downloaded as http://www.jwcs.net/~jonathan/perl6/pugs-win32.zip right?

[20:41] <Jonathan_> Yeah.

[20:41] <Jonathan_> I just downloaded it now to confirm.

[20:41] <Jonathan_> Do you have the ext folder in there?

[20:41] * Limbic_Region is downloading again

[20:42] <Limbic_Region> nope

[20:42] * Limbic_Region will try from home and let you know

[20:42] * Limbic_Region is really late now

[20:47] * Jonathan_ looks bewildered, trying to fathom why ext is visible to him and not LR. :S

[20:55] * PerlJam idly wonders when the pge rewrite will make it to the pugs people

[20:56] <mugwump> pge?

[20:56] <PerlJam> Perl Grammar Engine

[20:56] <PerlJam> The guts that makes the rule syntax work.

[20:57] <mugwump> is that a new Perl6::Rules?

[20:57] <PerlJam> not exactly.

[20:58] <PerlJam> You can think of it that way I guess.  PGE will parse perl6 rules.

[20:59] <obra> mugwump: this is patrick's work

[21:01] <mugwump> it was just the term "re"-write, implying there was a more mature implementation than I thought.  Does PGE plug into/called from parrot?

[21:02] <PerlJam> oh, there is (well, almost is)  Pm is rewriting PGE in parrot and it will include the latest semantics from the cabal

[21:02] <PerlJam> (the big thing is hashing out captures)

[21:03] <PerlJam> He said earlier today that he was almost finished, but then I saw a couple of messages that implied the implementation was giving him headaches so it may be a few more days

[21:04] <mugwump> famous last words

[21:06] <obra> PerlJam: where'd today's update coming from?

[21:06] <PerlJam> obra: Oh, I've been talking to him on another channel

[21:06] <Odin-> PerlJam: I think they formally renamed it Parrot Grammar Engine.

[21:06] <PerlJam> Odin-: perhaps.  I haven't kept up.

[21:15] <Limbic_Region> Jonathan_ - from home ext/ is in the zip file

[21:15] <Limbic_Region> my guess is that the new web proxy installed last weekend is also caching

[21:15] <Limbic_Region> and dumb

[21:16] <Limbic_Region> you there Jonathan_  ??

[21:18] <Jonathan_> I'm here, just in and out a bit.

[21:19] <Limbic_Region> ok - so it is a tad bit more complicated then I thought

[21:19] <Limbic_Region> one I am not sure we should work around

[21:19] <Limbic_Region> perhaps we should bring it up as a discussion point

[21:20] <Limbic_Region> for instance - with my built-from-scratch version of Pugs

[21:20] <Limbic_Region> C:\GHC\pugs>pugs t\statements\for.t

[21:20] <Limbic_Region> Can't locate Test.pm in @INC (@INC contains: C:\Perl6\lib C:\Perl6\lib .........

[21:20] <autrijus> you want to either install pugs

[21:21] <autrijus> or say pugs -Iext/Test/lib

[21:21] <autrijus> or add things to PERL6LIB

[21:22] <Limbic_Region> autrijus - we are trying to fix the binary build Jonathan_ does nightly

[21:22] <Limbic_Region> and aren't you supposed to be sleeping?

[21:22] <Limbic_Region> IOW - fix pugs so it "just works" for people not wanting/willing/able to build it themselves

[21:22] <Limbic_Region> s/pugs/binary build of pugs/

[21:22] <autrijus> but I woke up and conquered the Eval monad

[21:23] * Shillo edges away from Autrijus :)

[21:23] * Limbic_Region hates/loves when that happens

[21:23] <autrijus> now we have much better error reporting

[21:23] <autrijus> and soon STM/IO mixing, and atomic{}

[21:23] <autrijus> and many more.

[21:23] <Jonathan_> Limbic_Region: Yup, something that just works is my aim.

[21:25] <Limbic_Region> so it might be as simple as customizing the Makefile before compiling

[21:25] <Limbic_Region> but I haven't investigated

[21:25] <Jonathan_> I think I shouldn't be including ext, but rather doing an nmake install and putting lib in place instead.

[21:25] <Limbic_Region> or that too

[21:25] <Limbic_Region> ok - so I have done my job and pointed out the problem

[21:25] <Limbic_Region> if you need/want me to help/test - let me know

[21:26] <Limbic_Region> I am going to work on the patch to Perl6::Bible for ingy

[21:27] <Jonathan_> Thanks for the report, I'm working on it.

[21:27] <ingy_> Limbic_Region: thanks

[21:28] <ingy_> If you get it done in next 3 hours, I'll release it instantly

[21:28] <autrijus> I want `p6bible -f`

[21:28] <ingy_> I now have IRT

[21:28] <ingy_> Instant Release Technology

[21:28] <Limbic_Region> ingy - shouldn't take that long

[21:28] <Limbic_Region> and what do you want -f to do autrijus

[21:29] <Limbic_Region> I can do it at the same time if not too difficult

[21:29] <autrijus> Limbic_Region: what perldoc -f does.

[21:29] <Limbic_Region> k

[21:29] <autrijus> i.e. save me a grep

[21:29] <ingy_> hrm, that seems involved

[21:29] <autrijus> i.e. display the paragraph and synopsis name that contains that substring

[21:29] <ingy_> what is your grep?

[21:29] <ingy_> isn't that -q

[21:29] <ingy_> -f function

[21:30] <autrijus> -q searches for faq only

[21:30] <autrijus> but sure, I can use -q

[21:30] <autrijus> and -f only searches in s29

[21:30] <Shillo> Hmm, I get 13 fails in t/builtins/math/abs.t... is this expected?

[21:31] <ingy_> --madprops option extolls the wonders of Autrijus Tang

[21:31] <autrijus> Shillo: no, it's broken by Corion a while ago iirc

[21:32] <Limbic_Region> by "ok" - I didn't mean I would include it, was just confirming I understood what you wanted

[21:33] <Shillo> t/data_types/hash_ref DIED. FAILED tests 23-26 <-- how about this?

[21:33] <Limbic_Region> though my perldoc --help doesn't have a -f option (only -F)?

[21:34] <Limbic_Region> oh wait

[21:34] <Limbic_Region> nevermind

[21:34] <Limbic_Region> perldoc [options] -f BuiltinFunction

[21:34] <Limbic_Region> that is more involved so doubtful in the next 3 hrs for the instant release

[21:40] <Corion_> autrijus: No, I don't think I broke abs.t, but I'll investigate :)

[21:41] <autrijus> Corion_: oh, ok. maybe it was not you :)

[21:41] <Corion_> I think what broke it was some weird defaulting change

[21:41] <autrijus> ah. ok.

[21:41] <Corion_> (but I don't see where it happened, as the defaulting seems to take place via the parsing declaration at the end of Prim.hs)

[21:46] <autrijus> yeah. I'd like to investigate

[21:46] <autrijus> but sleeping sounds better now

[21:46] <Corion_> autrijus: Yes! :)

[21:46] <autrijus> r2449 is in -- huge, huge internal change

[21:46] <Corion_> It is even time for me to sleep, so you should really!

[21:46] <autrijus> we are now five stories high on the monadic lego

[21:47] <autrijus> (with EvalT)

[21:47] <Corion_> I look forward to STM stuff! STM is something that BrowserUK on Perlmonks really will like

[21:49] <clkao> autrijus-ska! when can i rewrite svk in perl6?

[21:49] <autrijus> I think     async { atomic { $x = $y * 10; $y = $x * 10 } };  is really killer feature

[21:49] <Jonathan_> Limbic_Region: Check out the latest build when you get chance, it seems if you extract that to a folder it will "just work". :)

[21:49] <Corion_> clkao: I would wait until objects are in, but much of the building blocks (except db_file) are there already ;)

[21:49] <Corion_> autrijus: Sleep!

[21:49] <clkao> io layers?

[21:49] <autrijus> clkao: sure, just eval_haskell("import Darcs")

[21:50] * autrijus waves &

[21:50] * clkao kills autrijus

[21:50] <Corion_> clkao: I don't know about IO layers - sockets and file IO are there, but not even binary file IO I fear ;)

[21:50] <clkao> layered IO i meant

[21:51] <Corion_> clkao: No, I guess not ...

[21:51] <jabbot> pugs - 2449 - * Eval monad is now a EvalT transformer 

[21:53] * Shillo runs tests again. Just for the heck of it. :)

[21:53] <Corion_> Heh. somebody broke the build. I won't name any names :)

[21:54] <Shillo> src/Pugs/AST.hs:767:20:... yep.

[21:54] <Shillo> Just found it out. :)

[21:54] <Corion_> Shillo: Shhhhh. No names. Let him sleep :)

[21:57] * Corion_ goes to bed as well

[21:57] <Shillo> My lips are sealed. :)

[21:58] <Limbic_Region> Jonathan_ - will do

[21:58] <Limbic_Region> almost finished with the Perl6::Bible mods

[21:59] * Jonathan_ has just discovered he is out of chocolate! This calls for a late night adventure to the vending machine...brb

[22:04] <autrijus> er. sorry.

[22:04] * autrijus unbreaks the build

[22:05] <autrijus> &

[22:07] <autrijus> Shillo: build is unbreaken :)

[22:07] <autrijus> run the test again?

[22:07] <Limbic_Region> ingy_ - it was quick/dirty so you might want to review it before applying

[22:07] <Limbic_Region> perlbot nopaste

[22:07] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[22:07] <autrijus> really really &

[22:07] <Shillo> autrijus: Checking svn-diffs...

[22:08] <Limbic_Region> hmmm - probably should email instead

[22:08] <ingy_> Limbic_Region: nopaste  is fine

[22:10] <Shillo> Built... running tests...

[22:10] <Shillo> Hmm, is there anything I should've passed to make or to perl Makefile.PL to make this run faster?

[22:10] <Shillo> (I built with all defaults)

[22:10] <pasteling> "Limbic_Region" at 69.250.48.119 pasted "-t -u -m -T perldoc display support for Perl6::Bible (minimally tested)" (25 lines, 818B) at http://sial.org/pbot/9754

[22:11] <Limbic_Region> ingy_ I still have to clear my screen to get it to look write in Cygwin

[22:11] *** ingy_ is now known as ingy

[22:11] <jabbot> pugs - 2450 - * unbreak the build.

[22:12] <ingy> Limbic_Region: I don't follow you. 

[22:13] <ingy> Limbic_Region: fyi, my mail server is down at the moment

[22:13] *** broquaint__ is now known as broquaint

[22:15] <Limbic_Region> Jonathan_ ping

[22:16] <Limbic_Region> ingy - I mean that cygwin is fubar 

[22:16] <Limbic_Region> but it is less fubar with the patch

[22:18] * Limbic_Region isn't make much sense is he ingy

[22:19] <Limbic_Region> well - I think the patch is good I think it is my environment/pager that is fubar 

[22:22] <Limbic_Region> ok - need to go spend some time with Jean

[22:22] <Limbic_Region> TTFN all

[22:22] <mugwump> ingy: have you had change to review/comment the tests/code in svn.kwiki.org Perldoc project?

[22:23] <mugwump> s/comment/comment on/ ;)

[22:23] <Shillo> Failed 19/232 test scripts, 91.81% okay. 62/4631 subtests failed, 98.66% okay.

[22:24] <Shillo> Now I wish I noted the earlier results. Ah well.

[22:28] <Shillo> Going to sleep, as well. G'night!

[22:30] <ingy> mugwump: no. probably this weekend

[22:31] <mugwump> great, I'll try to be around on my Sunday

[22:38] <pasteling> "revdiablo" at 24.75.156.86 pasted "another few tests. thinking about adding them to builtins/my.t ... any objections?" (28 lines, 787B) at http://sial.org/pbot/9757

[22:41] <revdiablo> or should I just be committing things like this as I find them?

[22:42] <mugwump> nice test.  that belongs with the loop tests I think.

[22:44] <revdiablo> statements/loop.t?

[22:44] <revdiablo> wait, that's all for the 'loop' construct

[22:47] <mugwump> well, your test specifically tests that loop closures are localised properly between iterations

[22:50] <revdiablo> isn't 'my' responsible for doing that?

[22:53] <mugwump> it's a matter of scope

[22:54] <mugwump> the other test (which I added to t/subroutines/sub_ref.t for you just before you were given the account) tested that `my' works with anonymous closures

[22:55] <mugwump> both great tests, but subtly test the rules differently.

[22:55] <revdiablo> yeah, true. I wonder if these are related.

[22:56] <revdiablo> well I'm just not sure where to put this latest one... I don't know how the tests are organized, I'm just looking for placess I think might be appropriate :)

[22:56] <mugwump> tests organized?  this is anarchy!  :)

[22:56] <revdiablo> haha

[22:56] <revdiablo> some organization appears to be emerging from the chaos

[22:57] <mugwump> perhaps t/subroutines/loopscope.p6 for that one?

[22:57] <mugwump> s/p6/t

[22:57] <revdiablo> that makes sense to me

[23:01] <jabbot> pugs - 2451 - * |= ^= &= for junctions now works

[23:01] <jabbot> pugs - 2452 - * make tic-tac-toe even more perl6ish.

[23:11] <jabbot> pugs - 2453 - tests to check the scoping of variables 

[23:30] <TreyHarris> general haskell q: if i wanted to implement an analogue to List::Util::reduce, I'd have to write two functions, one that returned a list of xs (and would be called recursively), and one that returned an x (that would be called once), right?

[23:57] <_metaperl> TreyHarris, that sounds right, but ask on #haskell

