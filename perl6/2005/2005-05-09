[00:00] <mugwump> however, that should not actually work because it's breaking the "types=compile time" rule

[00:00] <stevan> how hard would it be to hack some kind of bless?

[00:01] <stevan> I imagine namespaces are non-trivial

[00:02] <stevan> multi sub foo (My::Class $self:)

[00:02] <stevan> although if types=compile time then how would that work with inheritance?

[00:03] <stevan> I didnt think Perl would do that much code analysis

[00:06] <mugwump> not if you don't want it to it won't

[00:07] <mugwump> but but inheritance is a simple case, it still works with 'compile time' classes, no matter how hazy that concept

[00:07] <stevan> ok

[00:08] <stevan> so would a bless, which creates a magic type which can be checked with MMD work for this?

[00:09] <mugwump> I'm thinking a sub-type would be a nice way to do this, see t/oo/subtypes.t

[00:09] <mugwump> and abstract the Instance Hack into a Hack::Instance module

[00:09] <stevan> mugwump: ok

[00:10] <stevan> oooh subtypes remind me of Ada

[00:12] <stevan> ok, I am going to set up the directories in svn

[00:22] <mugwump> nopaste?

[00:23] <mugwump> bah, using svn instead :)

[00:23] <stevan> mugwump: I just committed ext/Perl-MetaModel

[00:23] <stevan> and associated file

[00:23] <mugwump> cool

[00:24] <jabbot> pugs - 2859 - adding skeleton for Perl-MetaClass

[00:29] <mugwump> ok, just put some code in Hack::Instances

[00:29] <mugwump> don't know if it works :)

[00:30] * mugwump oo's at that uber-pink bot announcer

[00:30] <obra> svnbot6++ pretty

[00:30] <autrijus> we have Rules support.

[00:31] <autrijus> r2859.

[00:31] <autrijus> er, r2861, I mean.

[00:31] * obra blinks

[00:31] <obra> autrijus++

[00:32] <autrijus> pmichaud++ # doing all the real work

[00:32] <autrijus> I just glued it, that's all

[00:32] <stevan> autrijus: Pugs is asking for $ENV{PARROT_PATH}, is that the source, or the binary?

[00:32] <autrijus> sourcc

[00:32] <autrijus> source

[00:33] <stevan> ok

[00:33] * stevan crosses his fingers and trys again

[00:34] <jabbot> pugs - 2860 - Idea of using sub-types to classify obje

[00:34] <jabbot> pugs - 2861 - * real, honest-to-eris, Perl 6 Rules sup

[00:34] <stevan> jabbot: you're too slow :P

[00:34] <jabbot> stevan: Does it please you to believe I am too slow :P?

[00:35] <stevan> jabbot: are you jealous of ingo's svnbot?

[00:35] <jabbot> stevan: What are your feelings now?

[00:36] <stevan> :) Pugs.Embed.Parrot compiled without issue

[00:44] <stevan> autrijus: are we doing a release today/tonight/in-the-next-24-hours?

[00:45] <mugwump> on a Monday?

[00:45] <stevan> sunday still for me

[00:47] <stevan> mugwump: Hack::Instances looks cool, we just need subtypes :)

[00:47] <mugwump> oh, I thought we had them, given the state of t/oo/subtypes.t

[00:48] <stevan> mugwump: I dont think we have them

[00:48] <mugwump> those tests are still failing, then?

[00:48] <stevan> they are all TODO

[00:48] * mugwump re-builds pugs to check

[00:48] <mugwump> oh

[00:49] <mugwump> so they are.

[00:49] <stevan> no matter what, I think we will need some new features to accomplish this

[00:49] <autrijus> stevan: I don't know really... I _think_ in the next 24 hours, if you can do changelog meanwhile

[00:49] <stevan> autrijus: I will start on it

[00:51] <autrijus> danke

[00:53] <stevan> :)

[00:54] <Juerd> huh?

[00:54] <Juerd> whoa

[00:54] <Juerd> autrijus++

[00:54] <Juerd> A

[00:54] <Juerd> whoa

[00:54] <Juerd> autrijus++

[00:55] <Juerd> autrijus++

[00:55] <Juerd> (stupid Terminal.app can't handle rapid loop { up; enter; })

[00:55] <Juerd> And of course

[00:56] <Juerd> pmichaud++

[00:56] <Juerd> Tomorrow I'll try and convert my script-that-generates-a-64-kilobyte-regex-and-then-scans-/usr/share/dict/words-with-it-script

[00:56] <Juerd> s/-script//

[00:57] <Juerd> I converted it to Ruby already, but its regex engine wouldn't even accept the long regex

[00:57] <Juerd> So that comparison failed completely.

[00:59] <obra> heh

[00:59] <Juerd> D  src/pge

[00:59] <Juerd> svn: Failed to add directory 'src/pge': object of the same name already exists

[00:59] <Juerd> heh.

[01:01] <autrijus> hm?

[01:01] <Juerd> Apparently, it doesn't really delete it

[01:02] <Juerd> The solution is obviously rm -rf src/pge and then svn up again

[01:02] <Juerd> Perhaps that's a useful note in your journal

[01:02] <clkao> or use svk

[01:02] <Juerd> I'm using svn 1.1.3

[01:03] <Juerd> clkao: Company policy is to not run perl script :)

[01:03] <clkao> oh, rewrite it to perl6 then

[01:03] <Juerd> Perl6 ~~ Perl

[01:03] * Juerd has no real good reason for not using svk

[01:04] <Juerd> Good night!

[01:09] <autrijus> nite

[01:14] <jabbot> pugs - 2862 - Test for Hack::Instances

[01:14] <jabbot> pugs - 2863 - minor syntax fixes for Perl-MetaClass

[01:24] <mugwump> blast, my pugs-commit auto-mailer sends out svk property differences for commits I make :-}

[01:34] <jabbot> pugs - 2864 - Combine sub-type tests into t/data_types

[01:51] <meppl> gute nacht

[01:53] <stevan> autrijus: ChangeLog has been commited. As always, take a look and make sure I got it right

[01:54] <jabbot> pugs - 2865 - Alter make_instance API to accept object

[01:54] <jabbot> pugs - 2866 - Add test for MMD on tuples

[01:54] <jabbot> pugs - 2867 - adding changelog details from svn log

[01:54] <jabbot> pugs - 2868 - adding ChangeLog for 6.2.3

[01:54] <stevan> good night all, I will be back in ~10 hours

[01:54] * mugwump waves

[01:55] <stevan> mugwump: I will read my Haskell book some more too, so as to better grok Class.hs

[01:55] <mugwump> considering I hardly know Haskell and wrote it, that shouldn't really be necessary ;)

[01:56] <mugwump> but go ahead by all means :))

[02:25] <jabbot> pugs - 2869 - Add mkType hack for instances ... still 

[02:33] * mugwump & # meeting

[03:11] <Khisanth> two bots for one repo? :)

[03:26] *** TreyHarr1s is now known as TreyHarris

[03:31] <autrijus> pmichaud: hey

[03:33] <autrijus> pmichaud: you mind if I commit the Hs patch to compilers/pge for you to experiment with, and see if we can refactor it away?

[03:33] <autrijus> pmichaud: btw, eval_parrot, require_parrot are all support in Pugs now, even built without libparrot :)

[03:33] <autrijus> pmichaud: and full rx// support via the patched PGE is supported, too, with or without libparrot.

[03:35] <pmichaud> hey, autrijus

[03:35] <pmichaud> did you get my email?

[03:35] <autrijus> yes

[03:35] <pmichaud> okay

[03:36] <pmichaud> sure, no problem with committing -- we'll see about refactoring it a bit later then

[03:36] <autrijus> Pugs now bundles a PGE.pbc

[03:36] <pmichaud> It basically just adds the dump_hs method, yes?

[03:36] <autrijus> just so that people with old (like, 0.2.0) version of parrot

[03:36] <autrijus> can still use latest PGE features

[03:36] <autrijus> yup

[03:37] <pmichaud> yeah, we can put it in for now, but perhaps we should put big disclaimers around it that it may get taken out

[03:37] <autrijus> sure. let me do that

[03:40] <autrijus> done as r8016

[03:41] <autrijus> it also adds a convenience "match" method that matches and dumps

[03:41] <autrijus> just so I can call it as a sub that returns a string

[03:41] <autrijus> sub match (Str $x, Str $pattern) returns Str

[03:42] <pmichaud> ah, I see

[03:42] <pmichaud> makes sense

[03:42] <pmichaud> I'm trying to decide how I want to add closures into PGE

[03:43] <autrijus> *nod*

[03:44] <pmichaud> I'm fairly sure I'm just going to do a count-the-braces thing to extract the code, but I'm not sure how/when I want to pass it to the compiler

[03:46] * pmichaud does a parrot rebuild to check things out

[03:46] <pmichaud> any suggestions for building the perl 6 expression parser?

[03:47] <pmichaud> (i.e., the one that isn't in Haskell :)

[03:48] <autrijus> maybe writing a parsec->rules compiler

[03:49] <pmichaud> perhaps, but I'd be worried about the code maintainability

[03:49] <autrijus> once we have a working rules we can refactor and tidy up

[03:50] <autrijus> but of course you can start with the Perl6.grammar too

[03:50] <pmichaud> well, I tend to design bottom-up, so I'll want to be doing rules for the basic tokens

[03:50] <pmichaud> then the tricky part becomes parsing out expressions and doing the operator precedence parser

[03:51] <pmichaud> after that it's all pretty straightforward

[03:51] <autrijus> right... so you want to write the prec parser in imc?

[03:51] <autrijus> or in p6 and let pugs compile it to imc?

[03:51] <pmichaud> hadn't decided yet

[03:51] <pmichaud> to get one working I'd go either way at this point

[03:51] <pmichaud> I can translate from one to the other fairly easily :)

[03:52] <autrijus> cool :)

[03:52] <autrijus> by hand, I gather :)

[03:52] * autrijus wonders if a imc->perl6 compiler is useful

[03:52] <autrijus> probably yes

[03:52] <autrijus> "disassemble"

[03:53] <pmichaud> at this level it seems to be pretty easy to work in either language

[03:53] <autrijus> in that case, imc would probably be a faster choice

[03:54] <autrijus> in term of runtime speed

[03:55] <pmichaud> ahhh, dump_hs just outputs offsets?

[03:56] <autrijus> right.

[03:56] <ingy> hi Shachaf 

[03:56] <autrijus> because you have the original string

[03:56] <autrijus> there's no need to use other information

[03:56] <pmichaud> what happens for nested captures?

[03:56] <ingy> autrijus: meet Shachaf, son of oren :)

[03:56] <autrijus> greetings Shachaf-san.

[03:56] <obra> heh

[03:56] <autrijus> pmichaud: like perl5

[03:56] <ingy> er

[03:56] <autrijus> counts the pos of left (

[03:57] <autrijus> pmichaud: by-name captures needs another dump format

[03:57] <pmichaud> hmmmm

[03:57] <ingy> Shachaf lives near Seattle but is originally from .il

[03:57] <ingy> I'm trying to make a pugs hacker of him

[03:58] <pmichaud> quantified captures are likely to pose some difficulties

[03:59] <autrijus> ingy: cool

[03:59] <autrijus> pmichaud: oh, and you got my mail that /()/ is broken?

[03:59] <pmichaud>  /()/ isn't a valid rule, and I don't have good error handling in place yet

[04:00] <pmichaud> so, yes :)

[04:00] <autrijus> it isn't a valid rule?

[04:00] <pmichaud> nope.  See S05 and A05. 

[04:00] <autrijus> oh. <null>

[04:00] <pmichaud> right

[04:00] <revdiablo> my brother is having a problem with an svk sync, getting "can't decode commit message as ascii" then "try --encoding"... anybody have any ideas?

[04:00] <pmichaud> I haven't defined <null> yet

[04:00] <autrijus> Name 'null' not found

[04:00] <autrijus> k

[04:00] <pmichaud> and normally one would want <?null> anyway

[04:01] <pmichaud> unless we *really* need to capture the nulls  :-)

[04:01] <pmichaud> although <null> may end up being special and non-capturing by default

[04:01] <autrijus> so there's <?subrule> support?

[04:01] <autrijus> eek, exceptions

[04:01] <pmichaud> no, there's no <?subrule> yet

[04:01] <autrijus> k

[04:01] <pmichaud> but it won't be hard to implement

[04:01] <autrijus> but, yes, nested captures is a problem

[04:01] <pmichaud> actually, I might just do that now

[04:01] <autrijus> as p5 doesn't have that

[04:02] <autrijus> so ideally, in

[04:02] <pmichaud> well, aliases will pose some difficulty for you too :)

[04:02] <autrijus> 123 ~~ /(.)*/

[04:02] <autrijus> we want

[04:04] <autrijus> Match [Match (0, 3), Nested [Match (0, 1), Match (0, 2), Match (0, 3)]]

[04:04] <autrijus> or some such

[04:04] <autrijus> what are aliases?

[04:05] <autrijus> er, I meant (1,2) and (2,3) of course

[04:05] <pmichaud>     rx/  H $7:=(.) llo (.) /

[04:05] <pmichaud> captures into $7 and $8 instead of $1 and $2

[04:05] <autrijus> how does pge handle that?

[04:05] <pmichaud> in what sense of "handle" ?  ;-)

[04:05] <autrijus> in the Match obj

[04:06] <autrijus> does it "remember" its supposed position?

[04:06] <pmichaud> it puts the elements in @capt[7] and @capt[8]

[04:06] <pmichaud> er, 6 and 7

[04:06] <autrijus> that's fine then

[04:06] <pmichaud> but entries 0...5 are undef

[04:06] <autrijus> I can deal

[04:06] <autrijus> k

[04:07] <pmichaud> hey, tell ya what

[04:07] <pmichaud> rather than have just one PGE.pbc, how about a PGE.pbc and a PGE-hs.pbc ?

[04:07] <autrijus> maybe all we need is a .perl method on the PerlArray.pmc :)

[04:07] <pmichaud> both can be created  by the makefile

[04:07] <autrijus> that is fine by me

[04:08] <autrijus> but I need to doze a bit

[04:08] <pmichaud> understandable :-)

[04:08] <mugwump> autrijus: did you see `mkType'?  I'm wondering if there's a way I can make a two-argument version that hangs the new type off the named type

[04:08] <autrijus> "hangs"?

[04:08] <mugwump> eg, mkType "Instance", "Hash"

[04:08] <autrijus> .isa?

[04:08] <mugwump> Makes a type "Instance" as if it was defined in initTree in Context.hs

[04:09] <autrijus> sure, and that's why we need to refactor Context.hs

[04:09] <autrijus> to use not a Tree

[04:09] <autrijus> but a full Graph

[04:09] <mugwump> sure

[04:09] <autrijus> as in Data.Graph.Inductive

[04:09] <autrijus> I can look into that after 6.2.3

[04:09] <mugwump> ok.  I'll continue with the namespace-clobbering version then

[04:09] <autrijus> k

[04:11] <pmichaud> well, break/rest time for me as well, plus I need to chart my next steps to writing the parser :)

[04:12] <pmichaud> I'll be back online tomorrow, unless I wake up extra early somehow

[04:13] <mugwump> Still, tree typing would be more than sufficient for the metamodel

[04:13] <mugwump> So, I'll be using "Str" instead as the "magic" type for all classes, but with methods that hint at the type like clsAssocs

[04:25] <mugwump> *** Error: No compatible subroutine found: "&exists": NonTerm

[04:25] <mugwump> :-/

[04:33] <autrijus> mugwump: huh?

[04:33] <autrijus> are you using

[04:33] <autrijus> %hash.exists<str> ?

[04:33] <autrijus> that is illegal

[04:33] <autrijus> it's like saying

[04:33] <mugwump> Oh, I was trying to use %hash.exists() and it wasn't working for some reason

[04:33] <autrijus> %hash.exists()<str>

[04:34] <autrijus> you want to say

[04:34] <autrijus> %hash.exists('str')

[04:34] <autrijus> instead

[04:34] <mugwump> my PERL6LIB fooled me too, which didn't help

[05:43] * mugwump & # wellington.pm.org meeting, home, etc

[06:41] <ingy> mugwump: ping

[06:57] <gaal|work> mugwump: ping also

[06:57] <gaal|work> ingy, hi

[07:01] <ingy> hi gaal|work 

[07:01] <gaal|work> thanks for the notice :)

[07:01] <ingy> the notice?

[07:01] <gaal|work> about the yaml thing

[07:02] <ingy> sure, thanks for the report

[07:04] <gaal|work> shouldn't mugwump's instance hack use a globally rising counter as part of the id?

[07:05] <gaal|work> rand isn't very safe

[07:05] <gaal|work> of course a global coutner isn't thread-safe

[07:05] <ingy> &

[07:09] <gaal|work> &

[07:23] *** chady_ is now known as chady

[08:08] <bsb> Hi scook0, could you look over some haddock for me?

[08:15] <scook0> bsb: sure

[08:15] <scook0> what have you got?

[11:26] *** chady is now known as chady_

[13:49] <Limbic_Region> greetings and salutations all

[13:52] <elmex> ;)

[13:52] <elmex> :(

[13:53] * Limbic_Region forgot today was "Emoticon Discovery Day"

[14:17] <stevan> Limbic_Region: hey there

[14:21] * PerlJam reads about the new capture semantics

[14:23] * Limbic_Region is S-O-R-E 

[14:23] <Limbic_Region> moving--

[14:23] <stevan> Limbic_Region: ouch, I know what you mean

[14:23] <stevan> I helped my friend move out a of a 3rd floor walkup in Queens a few weeks ago

[14:24] <pernod> Does anyone know what has happened to http://wagner.elixus.org/~autrijus/darcs/ ?

[14:25] <pernod> ( http://wagner.elixus.org/~autrijus/darcs/pugs, even)

[14:25] <Limbic_Region> stevan - where are you geographically?

[14:25] <stevan> Limbic_Region: Connecticut

[14:26] <Limbic_Region> anywhere near Dan?

[14:26] <stevan> Dan is in Hartford I think right?

[14:27] <Limbic_Region> IIRC about 45 minutes away

[14:27] <stevan> hmm

[14:27] <stevan> I may be very close then, since I am about 45 min away from hartford as well

[14:27] <stevan> I am on the shoreline, a little east of New Haven

[14:30] <Limbic_Region> I was at a wedding thing there last summer and was supposed to get together but time ran short

[14:30] <autrijus> pernod: darcs is currently offline.

[14:30] <autrijus> pernod: it will be restored at darcs.pugscode.org 

[14:32] <autrijus> wagner as a whole is currently offline

[14:42] <stevan> mugwump: ping?

[14:45] <cognominal> I see @Larry all over the place, should'not that be @*Larry :)

[14:46] <pmichaud> Oh, I suppose that there could be some scopes where @Larry != @*Larry  :-)

[14:46] <autrijus> lol :)

[14:46] <autrijus> pmichaud: hey, is

[14:46] <autrijus> (xx)?

[14:46] <autrijus> the same as

[14:46] <autrijus> (xx)*

[14:47] <autrijus> when the code has no xx ?

[14:47] <pmichaud> no

[14:47] <autrijus> I mean, the str has no xx in it

[14:47] <cognominal> but some lexically scoped @Larry will cause confusion some day

[14:47] <autrijus> i.e. are both kind of matchfails the same?

[14:47] <PerlJam> cognominal: that day could be today :)

[14:47] <pmichaud> nope, (xx)?  is a single match object, (xx)* is an (empty) array of match objects

[14:48] <autrijus> so ? is not the same as {0,1} ?

[14:48] <pmichaud> the only quantifiers that produce arrays are *, +, and **{...}

[14:48] <pmichaud> ? is the same in the sense that it "matches zero or one times", but it's not the same as **{0..1}

[14:48] <autrijus> ok.

[14:48] <autrijus> but the dump is the same in demo.pir

[14:48] <autrijus> $/: < @ 0> 1

[14:48] <autrijus> both are that

[14:49] <autrijus> so, (xx)? will produce a matchfail

[14:49] <pmichaud> yeah, I haven't got '?' entirely working for captures yet

[14:49] <cognominal> btw, waht is the correct way to test identity instead of the pseudo code:  @Larry != @*Larry

[14:49] <autrijus> inside that $/[0]

[14:49] <autrijus> and (xx)* will produce a matchok

[14:49] <autrijus> inside that $/[0] ?

[14:49] <autrijus> I find it hard to understand

[14:49] <autrijus> i.e. if you test for $/[0]

[14:49] <autrijus> for truth

[14:49] <autrijus> will (xx)? fail and (xx)* succeed?

[14:49] <PerlJam> cognominal: @Larry =:= @*Larry  # you mean this?

[14:50] <autrijus> if the scope has no @Larry

[14:50] <cognominal> PerlJam: probably

[14:50] <pmichaud> no, both would fail

[14:50] <autrijus> it fallbacks to @*Larry

[14:50] <autrijus> pmichaud: so how exactly is the match obj tree different?

[14:50] <pmichaud> $/[0] is a single match object

[14:50] <pmichaud> with (xx)?

[14:50] <pmichaud> and $/[0] is an array with (xx)*

[14:51] <autrijus> sure, I understand when they succeed

[14:51] <autrijus> with (xx)*

[14:51] <autrijus> $/[0] will not be a Match obj

[14:51] <autrijus> but an Array obj

[14:51] <autrijus> is that the gist of it?

[14:52] <autrijus> or is it still a Match obj?

[14:52] <PerlJam> autrijus: (xx)* generates an Array of Match always is my understanding.

[14:53] <autrijus> so $/[0].does(Match) is false?

[14:53] <autrijus> $1 is no longer a Match?

[14:53] <pmichaud> it's an array of match

[14:54] <pmichaud> (sorry, phone call took me away for a sec)

[14:54] <pmichaud> (xx)? always produces a single match object

[14:54] <pmichaud> that match object may succeed or fail, but it's always there

[14:54] <osfameron> which is pretty cool

[14:54] <pmichaud> (xx)* produces an array of match objects

[14:54] <autrijus> ok. so if I test both for boolean

[14:54] <pmichaud> that array may be empty

[14:54] <autrijus> (xx)? fails because the match boolifies to false

[14:54] <pmichaud> right

[14:54] <autrijus> (xx)* fails because empty array numifies to 0, then boolifies to false

[14:55] <pmichaud> exactly

[14:55] <autrijus> danke.

[14:55] <autrijus> I'll implement it right away.

[14:55] <PerlJam> autrijus++

[14:55] <pmichaud> and again, I'm not sure if '?' is working in captures in PGE yet -- haven't tested that.  With all of the funny things going on, I'm happy that captures "work" for just about any interpretation of the word :)

[14:57] <autrijus> pmichaud: you know there's 7000 p6rule tests in pugs tree we can activate at any moment :)

[14:57] <pmichaud> I'll be glad to see them activated!

[14:57] <autrijus> cool

[14:57] <autrijus> then when they fails miserably we can split the blame :)

[14:58] <pmichaud> who gets the blame for the successes?  ;-)

[14:58] <autrijus> no one notices successes ;)

[14:58] <pmichaud> at this point I'm not counting failures, just successes :)

[14:58] <PerlJam> pm: ask "svn blame" it'll tell you  :)

[14:58] <autrijus> PerlJam: you mean "svn praise" of course

[14:58] <autrijus> (they are aliases)

[14:59] <iblech> autrijus: FYI, pugs -we 'say "abc" ~~ /abc/' segfaults for me (Linux, GHC 6.4, newest and fresh Parrot and Pugs)

[14:59] <PerlJam> autrijus: however you want to look at it  ;)

[15:00] <PerlJam> that [ (\w+) ]**{3..7}  would generate an array in $/[0] is still bizarre to me.

[15:00] <pmichaud> pj: what should it do?

[15:00] <autrijus> iblech: try r2887

[15:01] <autrijus> iblech: also try without embed parrot

[15:01] <pmichaud> it turns out to be totally correct

[15:01] <autrijus> (rm src/Pugs/Embed/Parrot.hs and .o if you want to try taht)

[15:01] <iblech> autrijus: ok

[15:01] <pmichaud> and no, it wasn't that way in Damian's original proposal -- I had to come up with examples as to why it should work that way

[15:01] <autrijus> pmichaud++ # code!

[15:01] <PerlJam> I don't have an answer to that yet, but it seems to me that you lose some of the advantages of the "static" nature of how to determine if you're going to get an Array of Match or a Match

[15:02] <autrijus> but a match can always act as an array, no?

[15:02] <pmichaud> pj:   / [ (\w+) ]**{0..7} /     you can tell it's an array because it's in a quantified subpattern

[15:02] <pmichaud> statically

[15:03] <pmichaud> pj: here's the alternative

[15:03] <PerlJam> It's another end-weight problem given that the ]**{...} may be a far lexical distance from the () that's bracketed within the []

[15:03] <iblech> autrijus: Still segfaults with PUGS_EMBED=parrot, will try w/o Parrot embedding now

[15:03] <autrijus> iblech: fbsd works here

[15:03] <pmichaud> pj:   consider    m:w / mv <file>+ /

[15:04] <pmichaud> how do we get spaces between each pair of <file> invocations?

[15:04] <pmichaud> i.e., with the :w ?

[15:04] <pmichaud> Well, we can do:

[15:04] <pmichaud> m:w / mv ( <file> )+ /

[15:04] <jhorwitz> autrijus: see leo's changes for linking w/ parrot?

[15:04] <pmichaud> but that gets kinda ugly, and we're building lots of extra capture objects as a result

[15:04] <autrijus> jhorwitz: I already synced with him in #parrot

[15:05] <jhorwitz> excellent

[15:05] <pmichaud> pj:  so, the obvious thing to do is     m:w / mv [ <file> ]+ /   and have the '+' distribute to its inner captures

[15:05] <pmichaud> it then becomes the same process for subpattern captures

[15:06] <pmichaud> m:w / mv [ (\w+) ]+ /   captures an array of space-separated names into $1

[15:06] <PerlJam> pm: sure, I understand the reasons *for* such a feature.  That doesn't mean I'm completely comfortable with it yet.  In my mind, it's another one of those features we'll have to implement and use before we really know what we should have done (or if what we did was the right thing)

[15:06] <pmichaud> Well, I fairly well convinced myself that the other way isn't at all useful

[15:07] <iblech> autrijus: W/o embedded Parrot: "pugs: user error (Cannot parse PGE: Just (PGE_Match 0 3 [] [])"

[15:07] <pmichaud> Believe me, I got approval from Damian/Larry *before* implementing it in PGE :-)

[15:08] <autrijus> iblech: I'm pretty sure you have an old PGE.pbc

[15:08] <autrijus> [not|autrijus]~/work/pugs/src/pge$ md5 PGE.pbc

[15:08] <autrijus> MD5 (PGE.pbc) = 203a20bb817cb3d9c2a35520ce468363

[15:08] <iblech> autrijus: same here

[15:09] <autrijus> do you have pugs installed? try uninstall it

[15:09] <autrijus> or install again

[15:09] <autrijus> also try

[15:09] <autrijus> [not|autrijus]~/work/pugs/src/pge$ parrot run_pge.pbc xx x

[15:09] <autrijus> PGE_Match 0 1 [] []

[15:09] <autrijus> the "Just" is an old pbc

[15:10] <gaal|work> misc_:ping

[15:10] <PerlJam> make

[15:10] <PerlJam> oops

[15:10] <iblech> autrijus: Gives "Just (PGE_Match 0 1 [] [])" here.

[15:10] <iblech> autrijus: I'll try uninstalling Parrot and Pugs, then rebuilding Parrot, then rebuilding Pugs

[15:13] <autrijus> iblech: weird.

[15:13] <autrijus> I have this eerie feeling

[15:13] <autrijus> maybe it's loading the wrong .pbc file.

[15:14] <misc_> gaal|work: pong

[15:14] <autrijus> fixing.

[15:15] <iblech> Indeed. Having rebuilt and reinstalled Parrot, I just built Pugs (with PUGS_EMBED=parrot). Running "parrot src/pge/run_pge.pbc xx x" gives again the Just (...) thing.

[15:16] <autrijus> ok. fixing

[15:18] <autrijus> fixed. committing

[15:19] <autrijus> committed. r2889

[15:19] <autrijus> try again?

[15:21] <pmichaud> autrijus -- need me to make a similar change in the parrot trunk?

[15:21] <autrijus> pmichaud: did so already

[15:21] <autrijus> as for -Hs.pbc

[15:21] <autrijus> no

[15:21] <pmichaud> yeah, I meant for -Hs.pbc

[15:21] <pmichaud> with it automatically created via make

[15:22] <autrijus> well, if you do that, I'd need to link against config_null.o

[15:22] <autrijus> because otherwise the -Hs.pbc in parrot tree will clash with the one in pugs tree

[15:22] <pmichaud> okay, I'll let you handle it then :-)

[15:22] <iblech> Strange. pugs still segfaults, and "parrot src/pge/run_pge.pbc xx x" dies with "Parrot VM: Can't locate PGE-Hs.pbc, code 2.". Should I make clean?

[15:22] <autrijus> I'll see what I can do :)

[15:22] <autrijus> iblech: there is no PGE-Hs.pbc in your dir?

[15:23] <autrijus> try cd into src/pge/ first

[15:23] <autrijus> then run parrot there

[15:23] <PerlJam> iblech: segfaults out-of-the-box or when you do something specific?

[15:23] <iblech> Ok. After the cd, the command work fine (outputs "PGE_Match 0 1 [] []")

[15:23] <iblech> PerlJam: Segfaults when I do "pugs -we 'say "abc" ~~ /abc/'"

[15:24] <autrijus> iblech: what about external?

[15:24] <PerlJam> My freshly built pugs says:  pugs: user error (*** Running external 'parrot' failed:

[15:24] <PerlJam> etc.

[15:25] <autrijus> PerlJam: your parrot is not in PATH

[15:25] <autrijus> I think.

[15:25] <PerlJam> it is.

[15:25] <autrijus> what's the err msg?

[15:26] <PerlJam> PackFile_unpack: Bytecode not valid for this interpreter: version mismatch

[15:26] <PerlJam> Parrot VM: Can't unpack packfile run_pge.pbc.

[15:26] <PerlJam> main: Packfile loading failed

[15:26] <autrijus> oh wow wtf. :-/

[15:26] <autrijus> 0.2.0?

[15:26] <autrijus> pbc interop is broken in just one day?

[15:26] <PerlJam> oh duh!  I have and older parrot in my path

[15:27] <autrijus> oh ;)

[15:27] <pmichaud> gotta keep up, pj :-)

[15:28] <PerlJam> no, I just need to not leave old parrot builds lying around

[15:28] <iblech> autrijus: Works with external Parrot.

[15:28] <autrijus> iblech: I have no idea then, unable to reproduce here.

[15:28] * PerlJam does the "make clean" chant 

[15:28] <autrijus> iblech: however fork() is fast in linus

[15:28] <autrijus> er linux

[15:29] <autrijus> so external parrot is probably good enough

[15:29] <autrijus> pmichaud: hey. do you like $1.1 or not?

[15:30] <iblech> :) -- Will rm -rf pugs and parrot and see if it works then, it's probably only some weird temporary bug depending on the phase of the moon :)

[15:30] <pmichaud> autrijus: I just wrote a message to p6l indicating I'd prefer we not add that

[15:30] <pmichaud> or, at least, not yet

[15:30] <autrijus> $1.1 is probably just people who want to count from 1 as base can keep doing that.

[15:31] <autrijus> which imho is a win -- but maybe a small win

[15:31] <pmichaud> yeah, but I wonder about things like   $1.$x.1 and $1[0].1 and the like... 

[15:31] <autrijus> well no, of course it must be literal

[15:31] <autrijus> I'll leave it to @Larry then

[15:37] <iblech> autrijus: Ok, wiped Parrot and Pugs completely, installed both again, pugs still segfaults (if PUGS_EMBED=parrot)

[15:37] <autrijus> iblech: :-/

[15:37] <autrijus> I'll probably refactor so it doesn't use unsafePerformIO anymore

[15:38] <PerlJam> maybe I'm hypersensitive to these things but Damian's capturing semantics document reads like it has a lot of special cases.  I wonder if we've just moved our foolish inconsistencies from perl-the-language into the subset known as rules?

[15:40] <pmichaud> pj: I think it's just the way the document is written

[15:40] <autrijus> 7 "except"s

[15:41] <autrijus> that's a pretty high rate :)

[15:41] <pmichaud> well, many of those are actually flag-related

[15:41] <pmichaud> well, at least two of them are

[15:41] <autrijus> I just see one :)

[15:41] <autrijus> (:g and :x)

[15:42] <pmichaud> oh, you're right

[15:42] <pmichaud> I misread

[15:42] <autrijus> :)

[15:42] <pmichaud> well, two of them are "except C<?> and C<??>" -- I actually wrote my version to avoid that

[15:42] <autrijus> does PGE handle :g

[15:42] <autrijus> or does it properly belong in the upper (pugs) layer?

[15:42] <pmichaud> Damian says that any quantifier except ? and ?? produce an array of matches; I write that +, *, and **{} produce arrays of matches

[15:43] <autrijus> whilst :g may be handled quite easily, I wonder how :exhaustive works

[15:43] <pmichaud> :g will probably be handled above pugs

[15:43] <autrijus> ok, that's what I'm doing currently

[15:43] <autrijus> just want to avoid duplication of work

[15:43] <pmichaud> sorry, I meant "above PGE"

[15:43] <autrijus> nod

[15:44] <pmichaud> :exhaustive is going to be done by repeatedly calling the match objects "next" method and getting the next match

[15:44] <pmichaud> and then junctioning the results appropriately

[15:44] <PerlJam> pmichaud: and :all  ?  :-)

[15:45] <gaal|work> http://forum2.org/gaal/pugs/smoke-cygwin.html r2668 btw

[15:45] <gaal|work> 2670 actuall

[15:45] <gaal|work> y

[15:45] <pmichaud> pj:  ":all" ?

[15:46] <PerlJam> Perhaps it's called :any  The one  that matches every possible match 

[15:46] <pmichaud> I think that's :exhaustive

[15:46] <PerlJam> oh I thought that was something different

[15:47] <autrijus> there's :ov

[15:47] <PerlJam> :ov for :overlay?

[15:47] <pmichaud> :overlap

[15:47] <PerlJam> ah, that's the one I was thinking of!

[15:47] <PerlJam> (after checking S05)

[15:48] <pmichaud> it's still just repeated calls to the match object

[15:49] <PerlJam> yeah, I guess it's just :ex from the first char, then :ex from the second, and so forth until done

[15:49] <pmichaud> right, and PGE supports being able to anchor matches from specific offsets

[15:49] <pmichaud> (it has to in order to support subrules)

[15:51] <PerlJam> It's a good thing pugs is around and implementing all of this stuff.  Looking over the synopses I see all sorts of things that I've forgotten.

[15:53] <autrijus> :)

[15:55] *** Sniper{PaLa} is now known as Snip`

[15:56] <autrijus> won't the same thing happen?

[15:56] <autrijus> er, wrong window.

[16:08] <iblech> http://m19s28.vlinux.de/iblech/pugs/smoke.html -- Linux, 4787 ok, 72 failed, 901 todo, 13 skipped and 2 unexpectedly succeeded

[16:14] <stevan> mugwump: ping?

[16:15] *** misc_ is now known as misc

[16:32] <pmichaud> okay, time to write a shift-reduce parser with operator precedence :)

[16:33] <wolverian> isn't that kind of reinventing the wheel? 

[16:33] <pmichaud> do we have one in parrot?

[16:34] <Corion> Oooo - r2891 gets one more program to compile and thus two more unexpected successes :)

[16:34] <wolverian> I don't know. isn't there on on CCAN? :/

[16:34] <wolverian> s,on,one,

[16:34] * Corion runs a second smoke to confirm ;)

[16:34] <wolverian> (assuming you were going to write it in C.. okay, I'm just being silly.)

[16:34] <pmichaud> :-)

[16:34] <pmichaud> no, it's in parrot :)

[16:35] <wolverian> ah, okay. can't you write it in perl6 then? :)

[16:35] <pmichaud> probably, but at the moment I'm more comfortable doing it in PIR.  Besides, it won't be hard to write

[16:35] <pmichaud> just a day or two (depending on interruptions)

[16:37] <wolverian> ah, okay. :)

[16:37] <pmichaud> well, off I go.  back later

[16:38] <wolverian> cheers. have fun.

[17:20] <crysflame> hello notice

[17:20] <Corion> r2897 - http://datenzoo.de/pugs/win2k.html - 4781 ok, 78 failed

[17:26] <Juerd> I personally think we should drop the entire Net:: prefix

[17:26] <Juerd> Almost everything is concentrated around it nowadays

[17:26] <Juerd> WWW::, HTTP::, CGI:: all already escaped

[17:27] <Juerd> And IO::Socket::INET isn't in Net:: either

[17:27] <Juerd> Nor are P::C::S::*

[17:27] <Corion> P::C::S ?

[17:27] <Corion> Poe

[17:27] <Corion> Ugh.

[17:27] <Juerd> And it's time for "cute" names again. Project names

[17:27] <Juerd> IRC::Something

[17:27] <Corion> Pugs should not get POE

[17:27] <Juerd> So that there can be multiple IRC modules, of which none is preferred just because of the name.

[17:27] <Juerd> Corion: Agreed.

[17:28] <Corion> Juerd: "cute" project names are useless as you can't search on them unless you already know what you are searching for

[17:28] <Juerd> Corion: IRC::Blah

[17:28] <Corion> Juerd: Yeah, that would work

[17:28] <Juerd> Corion: Rather than Net::IRC, as there can be only ONE OF EACH NAME

[17:28] <Corion> Yeah

[17:28] <Juerd> And too generic names should thus be forbidden

[17:28] <Corion> "discouraged" :)

[17:28] <Juerd> Do you know how many people want to use DBIx::Simple for their module and then find out it's taken?

[17:28] <Corion> Juerd: You're a mean person! :)

[17:29] <Juerd> And do you have any idea how surprised I was to find it wasn't already when I made mine?

[17:29] <Corion> Hmmm. pugs: user error (Cannot find the parrot executable in PATH) (for t/undef.t)

[17:29] <Juerd> (And do you know how stupid in hindsight I think the name was?)

[17:29] <Corion> ... it's true, but why does Pugs even try?

[17:29] <Corion> Juerd: You're not alone - I also have a ::Simple module ...

[17:29] <Juerd> Also, why the hell do people all recommend the horribly coded CGI.pm?

[17:30] <Juerd> Because the namespace is taken and no other module, no matter how well it was crafted, can ever take over!

[17:30] <PerlJam> Juerd: so ... do you think that there should be some sort of community peer-review before a module gets an "official" name and place on CPAN?

[17:30] <Juerd> PerlJam: Not exactly

[17:31] <Juerd> PerlJam: But yes, in order to get a generic name, I think peer review is needed. A place on CPAN should be available for all code in existence

[17:31] <misc> wouldn't it be more efficient to change CGI.pm code ?

[17:31] <Juerd> But perhaps (probably!) we should start prefixing PAUSE ids

[17:31] <Corion> misc: Nobody will ever touch CGI.pm again :)

[17:31] <Juerd> misc: Nah, its interface is wrong as well as its internals

[17:31] <obra> Juerd: you're read larry's suggestions about module naming for perl6?

[17:31] <Juerd> misc: Providing backwards compatibility means doing the same stupid things

[17:32] <obra> and versioning, etc.

[17:32] <Juerd> obra: No?

[17:32] <obra> Juerd: what's a _good_ CGI module this year.

[17:32] <misc> call it CGI-ng, and that's it ?

[17:32] <obra> oh. there's an apocalypse.

[17:32] <obra> before recommending a cpan overhaul, it's worth a read

[17:32] <Corion> I just saw the four horsemen ride outside of the window

[17:32] <Juerd> Then I read it.

[17:32] <Juerd> But I can't remember it.

[17:32] * Juerd has all apocalypses printed out eve

[17:32] <Juerd> n

[17:32] * obra nods

[17:33] <PerlJam> obra: Are you referring to the Module-version-author thingy?

[17:34] <obra> yes. but pay attention to the fact that author is author+namespace

[17:34] <Juerd> Oh, but that's entirely the wrong way around, hierarchy-wise.

[17:34] <obra> so there could be CPAN but also peer-review-pan

[17:34] <PerlJam> obra: indeed.

[17:34] <obra> Juerd: think of it as a triple, not a hierarchy

[17:34] <Juerd>     class Dog-1.2.1-cpan:JRANDOM;

[17:35] <Juerd>     class CPAN::JRandom::Dog-1.2.1

[17:35] <Juerd> I think it's important that it is actually part of the namespace itself

[17:35] <obra> www.cpan.org

[17:35] <obra> org.cpan.www

[17:35] <Juerd> Because you will want to load two.

[17:35] <iblech> r2900! :)

[17:35] <Juerd> BUT

[17:35] <PerlJam> If everyone decides that CGI-0.1-Juerd is the best CGI module ever, how does it get the generic CGI name?  Or does it?

[17:36] <obra> there are no more generic names.

[17:36] * obra suspects you'll end up being able to order your namespace search path

[17:36] <PerlJam> Then I can only see problems with few good solutions.

[17:36] <Juerd> PerlJam: Well, there's "use approved;"

[17:36] <Juerd> PerlJam: That adds aliases

[17:36] <Juerd> (dreaming on)

[17:37] <Juerd> I don't like the triple idea AT ALL

[17:37] <Juerd> Well, I like the version part.

[17:37] <Juerd> And the namespace part

[17:38] <obra> once I went back and read about how larry actually designed it all, I decided I liked it quite a bit

[17:38] <Juerd> But there simply shouldn't be two Net::IRCs, and there shouldn't be a single one without consensus

[17:38] <Juerd> I hated it the first time, I still do

[17:38] <Juerd> I just had forgotton about it

[17:38] <obra> yes, but that's a matter of policy, not of technical enforcement

[17:39] <obra> note also that what happens if Net::IRC goes through a major API change?

[17:39] <obra> the new scheme can cope easily

[17:39] <obra> the old cpan scheme can not

[17:39] <Juerd> Ah well, more cute names then.

[17:39] <obra> and API versioning is isomorphic to independent authorship

[17:39] <Juerd> It's the only possible solution.

[17:39] <Juerd> Top-level cuteness, I mean

[17:39] <PerlJam> obra: Except that "use CGI" becomes almost meaningless.

[17:40] <elmex> Net::IRC is ugly

[17:40] <Juerd> PerlJam: "use something that happens to be called CGI and let's hope it matches the interface I'll be assuming"

[17:40] <PerlJam> Juerd: exactly

[17:40] <osfameron> ick

[17:40] <Juerd> The cute or author part must really be part of the namespace.

[17:41] <Juerd> The version can live outside

[17:41] <Juerd> (But TBH, I wouldn't mind it being part too, with aliasing for the versionless one. I've so often wanted to load two versions of the same module)

[17:41] <Corion> Author is a bad idea, because authors change

[17:42] <Corion> so "cute" names are all that remains ...

[17:42] <Juerd> Corion: Then cute name.

[17:42] <PerlJam> Corion: but the version will change with the author

[17:42] <Corion> PerlJam: But I don't want to update all my scripts just because the author changed

[17:42] <integral> What about when authors change their names?

[17:42] <elmex> ./pugs -BParrot -e 'my ($i,$b); loop ($i = 0; $i < 1000; $i++) { $b += 3.37 } say $b'

[17:42] <Juerd> integral: That doesn't happen, period :)

[17:43] <integral> hmm, iirc japhy wanted to change his CPAN id

[17:43] <iblech> BTW -- is (for example) my $h = { say => {...} } valid, i.e. does it autoquote say? (because r2898 broke Net::IRC, because now there's ".to")

[17:43] <PerlJam> integral: to "japhy"?

[17:43] <integral> PerlJam: yeah

[17:44] <Juerd> "Patrick++ for designing a nicely designed PGE API!

[17:44] <Juerd> "

[17:44] <integral> DNA fingerprints?

[17:44] <Corion> Not everybody has the foresight to have his CPAN id the same as his primary nick :)

[17:44] <Juerd> I agree

[17:44] <PerlJam> integral: He should be happen with the name that his parents gave him!  ;-)

[17:44] <Juerd> But "nicely designing a nicely designed ..." would be funnier

[17:45] <integral> plus how do you type names which are in Chinese?

[17:45] <Corion> pugs -e "delete %*ENV<FOO>" # whoops

[17:45] <Corion> romanji 4 life, dawg!

[17:45] <obra> right. but "use CGI/CPAN" has meaning

[17:46] <Corion> Can somebody check if Pugs spins in an endless loop for them too? Especially on nonWin32 systems

[17:47] <Corion> Does svnbot6 evaluate Perl6 code already? Then I could take it for a spin :)

[17:47] <mj41> PUGS_EMBED=parrot. How I can fix "undefined reference" when linking?

[17:48] <Corion> BTW, it doesn't matter if the environment variable exists or not - pugs -e "delete %*ENV<PATH>" # spins as well

[17:48] <PerlJam> integral: that's where the ability to use regular expressions as part of the module name come in.  "use ThreeGorges-1.2-/\C[FUMANCHU]/"

[17:48] <iblech> autrijus: P5 regexes do not capture correctly

[17:49] * integral cringes

[17:49] <iblech> autrijus: Try my $a = "a b c"; $a ~~ rx:P5/^(.) (.) (.)$/; and output $1, $2, and $3

[17:49] <Corion> iblech: Commit a test for it ? :))

[17:50] <iblech> Corion: t/rules/perl5.t :)

[17:50] <iblech> (fails badly)

[17:51] <Corion> worksforme:

[17:51] <Corion> pugs -e "my$a = 'a b c'; $a ~~ rx:P5/^(.) (.) (.)$/; say for ($1,$2,$3)"

[17:51] <Corion> (win32 shell syntax)

[17:51] <Corion> outputs: a\nb\nc

[17:51] <Corion> \n

[17:51] <iblech> newest svn revision?

[17:51] <Corion> r2899

[17:52] * Corion starts a fresh smoke

[17:52] <PerlJam> Corion: I think that's broken anyway (the output you saw)

[17:52] <Corion> PerlJam: Why?

[17:52] <PerlJam> Because it should match  <any><space><any><space><any> if it's a perl 5 RE

[17:52] <PerlJam> blah, ignore me

[17:53] <PerlJam> eating + thinking just isn't working for me right now.

[17:53] <Juerd> Still?

[17:53] <PerlJam> (I saw 'a b c' but my brain was obviously thinking 'abc'

[17:53] <PerlJam> )

[17:53] <Juerd> Practice some more

[17:54] <PerlJam> Juerd: I have practiced many times, the outcome is always the same--a thinko

[17:54] <PerlJam> (oddly enough my ability to eat is never affected ;-)

[17:55] * PerlJam finishes off the last of the left-over fajitas, bbq-baked-potatoes and spanish rice.

[17:58] <iblech> Corion: r2901 (or r2900) gives me: "Failed 1/1 test scripts, 0.00% okay. 195/880 subtests failed, 77.84% okay." when I manually harness t/rules/perl5.t

[17:59] <Corion> iblech: Ow. :) rLatest is Just compiling, so I can check soonish :)

[18:00] <iblech> (make unoptimized)++

[18:01] <Corion> iblech: Yeah - I only notice that after I've been already waiting 3 minutes, and then figure I could just wait until it's done ;)

[18:03] <Corion> iblech: # Looks like you failed 195 tests of 880

[18:03] <Corion> So I confirm, r2901 RE support is broken ;)

[18:03] <autrijus> ...and r2902 is fixed.

[18:03] <Corion> autrijus++ :)

[18:04] <putter> hmm, rules...  would it be useful to have the Perl6::Rules test cases ported?

[18:04] <iblech> autrijus++ # fast!

[18:04] <PerlJam> putter: yes (didn't someonen do that already?)

[18:04] <Corion> autrijus: Do you have any explanation on why pugs -e "delete %*ENV<FOO>" # spins in an endless loop?

[18:04] <Corion> putter: Go for it!

[18:04] <autrijus> Corion: because delete as a macro is not implemented

[18:04] <pjcj> Ha!  I wondered whether Damain knew that his draft zero would be implemented before he got to draft one.

[18:05] <Corion> autrijus: "as a macro" ?

[18:05] <putter> PerlJam: grep'ed pugs for "rule" and didnt see much...?

[18:05] <pjcj> autrijus++ # again

[18:05] <autrijus> Corion: $ENV.delete('FOO') # normal form

[18:05] <PerlJam> pjcj: I bet he did.

[18:05] <autrijus> the way you write it needs a macro

[18:05] <Corion> autrijus: Aaah - will try that one instead then!

[18:05] <autrijus> and we don't yet have real macro

[18:05] <autrijus> I guess we can do it at parser level

[18:05] <autrijus> but will be ~messy

[18:06] <Corion> autrijus: %*ENV.delete('FOO') # should work too, right?

[18:06] <autrijus> yes.

[18:06] <Corion> autrijus: The test is for %*ENV, not for funky hash syntax, so I don't care if my code is ugly :)

[18:06] <autrijus> ok :)

[18:07] <iblech> Corion: yes, and %ENV.delete("FOO") (w/o the "*"), too, as $... falls back to $*... if needed

[18:07] <autrijus> putter: there's a rule test in t/rules/Disabled

[18:08] <Corion> Yay. And suddenly, two more tests can be promoted from skip() to is() :)

[18:08] <autrijus> putter: however I have no idea if it's still uptodate or not

[18:09] <Corion> Oh. And I think I should somehow mark getEnv() and my faked setEnv(), so that the sequence getEnv('X'), setEnv('X'), getEnv('X') -- actually works and returns the new value.

[18:10] <Corion> autrijus: How do we handle backpropagation into the GHC runtime library? I have a half-working setEnv for Win32, which GHC doesn't have (yet) ...

[18:10] <Corion> ... do we wait for them to pick it up?

[18:10] <putter> ah, so there are two sources of tests.  p5's re_tests, and p5's Perl6::Rules t/.  The latter is much smaller, but exercises a few more p6 features (though it is still far from feature complete).

[18:11] <putter> the former (p5's re_tests) is the thing in Disabled.

[18:11] <autrijus> Corion: you can submit to ghc mailing list

[18:11] <Corion> autrijus: Ah - I'll look into that when I get it working :)

[18:14] <Limbic_Region> autrijus - so I found 3 bugs (all in t/pugsbugs) when writing Config::Tiny

[18:14] <Limbic_Region> I think porting existing p5 code is a good thing ;-)

[18:15] <autrijus> Limbic_Region++

[18:15] * Limbic_Region would like to have more of this elusive thing called free time though

[18:15] * Limbic_Region has given up trying to keep his karma neutral btw so upvote me all you want :P

[18:15] <gaal_> http://forum2.org/gaal/pugs/smoke-cygwin.html

[18:20] <putter> I'm thinking of doing Perl6::Rules first.  40ish test files, 5000+ cases.  http://search.cpan.org/src/DCONWAY/Perl6-Rules-0.03/t/

[18:27] <stevan> jabbot: seem mugwump

[18:27] <jabbot> stevan: Tell me more about that.

[18:27] <stevan> jabbot: seen mugwump

[18:27] <jabbot> stevan: mugwump was seen 13 hours 53 minutes 4 seconds ago

[18:29] <putter> Test organization esthetics question: Perl6::Rules has 40ish test files.  These could become pugs t/rules files, and thus the initial organization of t/rules.  Or they could be glomed together to keep the t/rules namespace clear for subsequent work.  Most of the files are tiny, with a couple of big unicode test files.  The small ones atleast could be glomed together.

[18:31] <putter> Unless there is objection/disinclination, I'm inclined to keep the files separate.

[18:33] <meppl> guten abend

[18:36] <stevan> putter: my suggestion is to do t/rules/perl6_rules/ and keep the test files seperate

[18:36] <stevan> we can always merge them together or move them around later (svn++)

[18:39] <putter> stevan: good idea. tnx.

[19:03] <Corion> Hmmm. Where do I get liftIO from ?

[19:04] <Corion> (looks like I'll need it in Compat.hs :( )

[19:08] <autrijus> pmichaud: $x.$j.2 is $x[$j][2] of course... no?

[19:09] <pmichaud> autrijus:   well, if  $1.1  refers to $/[0][0], then...

[19:09] <Corion> Ewww. This is the first time I used =<< on intuition, and it seems to do what I think it does ... Weird

[19:09] <autrijus> pmichaud: it's just a shorthand of array notation, no?

[19:09] <autrijus> Corion: you'll get used to it

[19:09] <Corion> autrijus: I don't know. I hope Perl6 flies before that ;)

[19:09] <autrijus> pmichaud: would probably need to use $1.0 for that.

[19:09] <autrijus> I may be completely offbase though

[19:10] <pmichaud> autrijus:  I'm (again) just asking questions -- I'm not advocating a particular interpretation.  Actually, my (weakly held) position is that we don't want to do this just yet

[19:10] <Corion> BTW, I'm using the Wide variants of the Win32 API, in the spirit of Pugs using Unicode in all places ...

[19:11] <pmichaud> autrijus:  but it just seems weird that we'd use  $1 as an alias for $/[0] but have $2.2.1  as an alias for $/[1][2][1]

[19:11] <pmichaud> If we're going to use . notation for subscripts, it seems to me our subpattern captures should be $0, $1, $2, ...

[19:11] <autrijus> the $1 is a legacy :-/

[19:12] <autrijus> but you can write

[19:12] <autrijus> $/.0.0.0

[19:12] <pmichaud> when it comes to p6l, I like to simply point out the ramifications of decisions and let others decide what the answer should be

[19:12] <autrijus> not sure if it helps (prolly not)

[19:12] <autrijus> nod

[19:12] <pmichaud> and yes, $/.0.0.0 is not bad at all

[19:12] <pmichaud> I kinda like that

[19:13] <autrijus> but I need to sleep.

[19:13] <autrijus> see ya :) &

[19:13] * autrijus waves

[19:13] <pmichaud> later!  great work on the pugs+rules stuff.  I guess we can now say that "Pugs rules".  :-)

[19:23] <putter> pmichaud: do these perl6_rules-isms look plausible?  tnx.  $0<foo> $0{'@?chars'}  ($0.keys == 1)  @$0  %$0  $0<foo><bar>[3]

[19:24] <PerlJam> pm: what did you mean by "multiple @LOAD pragmas in a single compilation unit aren't well defined"?  (from PGE.pir)

[19:24] <PerlJam> putter: what's $0 ?

[19:25] <pmichaud> putter:  do you mean if we used $0, $1, ... for subpattern matches, or something else for $0?

[19:25] <pmichaud> pj:  If you load a .pir file that has multiple subs marked as @LOAD, it's not clear that all of them get executed, or the order in which they may be executed

[19:26] <PerlJam> pm: I thought that @LOAD subs are analogous to BEGIN blocks.  They're loaded as soon as fully parsed and in the order that parrot sees them.

[19:26] <putter> Hmm.  Looks like $0 has been renamed to $/.  So that should be $/ rather than $0.  Sorry.

[19:26] <pmichaud> pj: well, I thought that too, but there were a couple of platforms where it wasn't working

[19:27] <pmichaud> pj: originally I had @LOAD subs in each of the PGE/*.pir files, but when they were combined into one via .include not all of the subs were being executed (on some platforms)

[19:27] <pmichaud> putter:  $/<foo>  is okay, it's anything captured by the <foo> subrule

[19:28] <PerlJam> pm: do you know which platforms?

[19:28] <pmichaud> $/{'@?chars'}   would be anything captured by a <@?chars> rule (this could probably only be done via a $<@?chars>:= alias )

[19:29] <pmichaud> I dunno what @$0 and %$0 would be, but @{$0} and %{$0} are okay.

[19:29] <pmichaud> sorry, @{$/} and %{$/}

[19:30] <pmichaud> $/<foo><bar>[3]   is the 4th subpattern capture of the <bar> subrule inside of the <foo> subrule of the last match

[19:31] <pmichaud> pj: no, I don't remember exactly which platforms -- whatever "particle" on #parrot was using.  Windows/cygwin, methinks

[19:31] <putter> pmichaud: sounds good.  thanks.

[19:32] <putter> pmichaud: re @?chars, a test is:  ok("  a b\tc" ~~ rx/@?chars:=( \s+ \S+ )+/, 'Named simple array capture');

[19:34] <pmichaud> pj: but I know that leo said that it needed to be specced out further and better defined and implemented

[19:34] <pmichaud> putter:  ohhhh, that

[19:34] <pmichaud> putter:  just a sec, I need to review the spec

[19:35] <pmichaud> what's that ? after the @ ?

[19:36] <PerlJam> I thought $?vars were for asking compile-time questions 

[19:37] <putter> pmichaud: "Magical lexically scoped values live in variables with a C<?> secondary sigil." - sNN

[19:38] <pmichaud> ah, that captures into @?chars in the current lexical scope then.  It doesn't appear in the match object

[19:38] <putter> Why it's used in the tests...???  I'm finding a number of p6 obselecences.

[19:39] <PerlJam> putter: Welcome to the wonderful world of language evolution!  :-)

[19:39] <pmichaud> probably because the capture syntax and semantics were totally redefined a couple of months ago, and whoever wrote the tests was working from the outdated A05 and S05 specs

[19:39] <pmichaud> well, not totally redefined, but substantially redefined

[19:40] <pmichaud> but I hadn't ever seen anything like @?chars

[19:40] * putter sighs.

[19:40] <pmichaud> heh

[19:40] <pmichaud> Apparently I hurt larry (latest message to p6l)

[19:41] <pmichaud> I have to switch machines -- bbiab

[19:41] <PerlJam> pmichaud: Careful, he might make you put on the language-designer hat and go sit in a corner for a while.

[19:42] <pmichaud> pj:  you're right, I'd best be careful here.  :-)

[19:42] <pmichaud> back in a sec

[19:57] <Limbic_Region> pmichaud ping

[19:57] <pmichaud> pong

[19:58] <Limbic_Region> I haven't been following p6.internals for sometime and perl6.compiler at all

[19:58] <Limbic_Region> I was suprised (but happy) about the recent move of PGE to PIR

[19:58] <Limbic_Region> what is the SDL of PGE in a nutshell

[19:59] <pmichaud> ...sdl?

[19:59] <Limbic_Region> system development lifecycle

[19:59] <Limbic_Region> road map IOW

[19:59] <pmichaud> oh.  Well, I wanted to get PGE far enough along that we could reasonably be building and testing the p6 grammar

[19:59] <pmichaud> that's basically done now

[20:00] <PerlJam> pmichaud: you've implemented subrules?

[20:00] <pmichaud> pj: sure, you haven't been watching the announcements either, I guess?  ;-)

[20:00] <PerlJam> no, not really.  :)

[20:00] <pmichaud> subrules, aliases, <ws>, \b, \B, all work

[20:01] <Corion> Yay ;)

[20:02] <pmichaud> http://www.nntp.perl.org/group/perl.perl6.compiler/685

[20:02] <pmichaud> oh, wait, wrong message

[20:02] <Limbic_Region> so is there anything that needs to be refactored or some sketchy spots awaiting further specifications?

[20:02] <pmichaud> http://www.nntp.perl.org/group/perl.perl6.compiler/710

[20:04] <pmichaud> l_r:  I don't think there's any real sketchy spots

[20:04] <pmichaud> at the moment PGE has three parts -- a parser, an optimizer, a (PIR) code generator

[20:04] <pmichaud> the parser is pretty rudimentary -- it's a good candidate for being rewritten when we have p6 far enough along to do that

[20:05] <pmichaud> the code generator is also straightforward if a little convoluted.  The best thing that can happen there is performance improvements

[20:05] <pmichaud> same for the optimizer -- being able to adjust the rule expression tree

[20:06] <pmichaud> i.e.,  the optimizer could look for things such as    .....  and convert them to the equivalent of   .**{5}    which is much faster

[20:06] <pmichaud> we don't completely have a handle on character classes yet 

[20:06] <putter> mmm, rule expression tree...  putter looks forward to Grammer::Transform.

[20:07] <pmichaud> well, the parser just converts a rule expression into an expression tree

[20:08] <pmichaud> then it's a fairly simple matter to walk the expression tree to generate the code for each component of the tree

[20:09] <pmichaud> each expression "node" is an object; the class identifies the type of expression (e.g., group, dot, literal string, alt rule, etc), each object also carries attributes that identifies its quantifications and linkages to subexpressions

[20:13] * putter looks forward to never again having to manually convert a grammar.  $g2 = Grammar::Transform::to('right recursive','syntax variant bison')($g1).

[20:14] <putter> or something vaguely like that.  p6 grammars should now be expressive enough that even if one cant actually run them on p6 (eg, left recursive?), they might serve as a lingua franca.

[20:16] <pmichaud> yes, I expect that p6 grammars and PGE may become a new standard for specifying grammars.  It's a bit more flexible than BNF

[20:19] <PerlJam> I've long expected that perl6 will become the new standard for specifying grammars the only problem that stands in the way is  "Hey, that's great ... if only it wasn't perl"  :)

[20:19] <pmichaud> it's not perl :)

[20:19] <pmichaud> it's PGE

[20:20] <pmichaud> it's Parrot

[20:21] <PerlJam> That's tantamount to saying it's perl  :)

[20:21] <pmichaud> with the exception of closures and external aliases, PGE could be run from any language that runs on parrot

[20:21] <pmichaud> and we could even get closures to work in other languages

[20:22] <Corion> Good night!

[20:23] <putter> pmichaud: are there any rule tests in the parrot source aside from parrot/t/library/pge.t and the 3 files in t/p6rules/ ?

[20:24] * putter tries to avoid duplicate/non-useful work.

[20:30] <pmichaud> putter: no, there's not many rule tests.  That's the biggest thing that PGE needs at the moment

[20:31] <putter> pmichaud: ok.  I'll continue... puttering.

[20:33] <pmichaud> excellent

[20:36] <PerlJam> pm: read the first sentence to Larry's latest post on p6l  :-)

[20:36] <pmichaud> pj: just a sec

[20:38] <pmichaud> yeah, it'll be interesting to see if we switch from 1-based to 0-based vars.  PGE's already set up so I can easily make that switch if need be :-)

[20:38] <pmichaud> I wonder how loudly I'd be shouted down if I suggested that match objects deserve their own sigil?  :-) :-) :-)

[20:39] <PerlJam> Um ... are there any characters left that could be used as a sigil?

[20:39] <PerlJam> (excluding unicode of course)

[20:39] <pmichaud> there's the full unicode range :)

[20:40] <PerlJam> I wouldn't mind if they had a twigil of ~ though.

[20:40] <cognominal> hum, what is the meaning of => in Haskell?

[20:40] <pmichaud> yeah, I was just thinking that

[20:41] <PerlJam> cognominal: I think it's something like "is typed" but I haven't looked at haskell in a while.

[20:41] <integral> *cough*if we binned % and @ you could use those...

[20:42] <pmichaud> anyway, this is why I leave such things to the language designers.  Back to my engine

[20:42] <PerlJam> integral: not gonna happen in "standard perl 6" 

[20:42] <integral> pity :-)

[20:43] <cognominal> autrijus was not supposed to release a second apocryph, btw? not that he is not busy. but I want to be sure I did not miss anything

[20:43] <PerlJam> cognominal: from http://www.haskell.org/tutorial/classes.html:  (==)                    :: (Eq a) => a -> a -> Bool

[20:44] <PerlJam> This should be read, "For every type a that is an instance of the class Eq, == has type a->a->Bool".

[20:45] <cognominal> thx perljam

[21:13] <xinming> anyone here can give me a url where to find the grammer details for perl6?

[21:13] <mugwump> What exactly are you after?

[21:14] <PerlJam> xinming: http://svn.perl.org/perl6/grammar

[21:14] <xinming> hmm... In fact, something which is about the differences between perl 5 and perl 6

[21:14] <xinming> thanks

[21:15] <PerlJam> xinming: oh ... You want A05 

[21:15] <mugwump> Hmm, that Grammar seems rather ... incomplete ;)

[21:15] <PerlJam> http://dev.perl.org/perl6/doc/design/apo/A05.html

[21:15] <PerlJam> mugwump: you've got to start somewhere

[21:16] <Corion> Nobody seems to have noticed that I (possibly) broke the build, so I can sleep well :)

[21:17] <xinming> I ever heard that the first rc of perl6 might be out this year, maybe in Sep,or Oct...

[21:18] <integral> sssh, don't jinx it ;-)

[21:18] <PerlJam> xinming: the first *alpha* release might be out then

[21:18] <PerlJam> xinming: Though I guess that we have all the pieces in place now to do a full bootstrapping so it could happen sooner if we're lucky.

[21:19] <mugwump> in a sense, the closest we've got to anything resembling a full grammar specification is the src/Pugs/Parser.hs and friends

[21:20] <integral> ah, yes, corion did break the build =)

[21:20] <PerlJam> mugwump: I want a way to autoconvert between src/Pugs/Parser.hs and Grammar.Perl6  :-)

[21:20] <PerlJam> mugwump: then we're quite a bit closer to realizing a real perl6

[21:21] <mugwump> that could work, yes.  dumping Perl 6 code from the Haskell sources would sure be a fast way to get to the self-hosting stage

[21:22] <mugwump> I believe the introspection capabilities are there to do it, but it's getting into the realms of super-voodoo Haskell :)

[21:24] <mugwump> anyway.  stevan, I see your extra work on Perl6::MetaClass... nice

[21:26] *** khisanth_ is now known as Khisanth

[21:38] <integral> err, when I edit src/Pugs/Types/Hash.hs,  ghc doesn't recompile it :-/

[21:39] <integral> hmm, and Pugs.Types.Hash isn't mentioned in the list of modules :-/

[21:40] <integral> ah, Pugs.AST #includes it, fscking up ghc --make's dependencies.  *grr*

[21:40] <elmex> ./pugs -BParrot -e 'my ($i,$b); loop ($i = 0; $i < 1000; $i++) { $b += 3.37 } say $b'

[21:42] * integral crosses his fingers

[21:42] <integral> yay, it typechecks

[21:48] * integral unbreaks the build :-)

[22:15] <integral> hmm, the UTF-8 isn't making its way to irc (the chars should be a ∀ and ∃, contrarespectively))

[22:17] <mugwump> It got mangled by my svn commit mailer too

[22:17] <mugwump> "Change ?\226?\136?\131 to ?\226?\136?\128 ..."

[22:17] <mugwump> looks nice in the diff output though

[22:19] <integral> it's very nice having those chars in the source :-)   Much nicer than having to use LaTeX or something

[22:44] <stevan> mugwump: ping

[22:44] <mugwump> hi

[22:44] <stevan> hey

[22:45] <stevan> did you see my comments in the MetaClass source?

[22:45] <mugwump> yes, I'm just "replying" to them

[22:45] <stevan> BTW - what exactly is this "theory" stuff? set theory? category theory? or just plain meta-class stuff? 

[22:46] * stevan was a fine art painting major, they didnt even offer math as an elective at my school :)

[22:47] <mugwump> I'm stating rules using maths operators because they are succinct and pretty

[22:47] <stevan> ok

[22:50] <mugwump> note that these MetaClasses are not really intended to represent user classes... they are one level removed from that

[22:50] <stevan> yes

[22:50] <mugwump> cool

[22:50] <stevan> I considered using 'Class' and 'Roles' as examples, but I thought that might confuse the test

[22:51] <mugwump> this is why I was using "Class" and "Role" in the examples rather than "Foo", "Foo::Bar" etc

[22:51] <stevan> whoops, that I shouldnt have changed

[22:51] <mugwump> np

[22:52] <mugwump> the first real test case for the code is to get a set of classes suitable for implementing duck typing ... ie, like docs/class/ducktyping.png

[22:55] <mugwump> The Perl::MetaAssoc class represents one half of a relationship ... eg a UML relationship line/arrow on that diagram is a Perl::MetaAssoc on each end and the link between them is the "Pair"

[22:55] <stevan> I am not sure I understand where the .png would be represented with Perl::MetaClass

[22:55] <mugwump> Each box is a MetaClass

[22:55] <stevan> however I am reading the kwid right now

[22:55] <stevan> hmm, ok

[22:56] <stevan> maybe it would help to understand what would be good names for the test t/10_MetaClass.t

[22:57] <stevan> for instance do you see Roles as subclasses of Class?

[22:57] <stevan> or vice-versa?

[22:57] <mugwump> A Class is a sub-class of a role

[22:58] <stevan> ok

[22:58] <stevan> and  Role isa?

[22:59] <mugwump> well, a role (and a module) are also both packages

[22:59] <stevan> ok

[22:59] <stevan> and a package isa? Metaclass? are we at the base of the tree?

[23:00] <mugwump> nothing in the Class Model can be a Class Meta-Model object

[23:00] <stevan> ok

[23:00] <iheartcanada> perl6 is out?

[23:00] <mugwump> (they are represented by Class Meta-Model objects, of course, so in a sense they *are* Meta-Model objects, but they don't link to them)

[23:01] <iheartcanada> 6.2.2 <-?

[23:01] <obra> iheartcanada: yes. it's done. 

[23:01] <iheartcanada> obra: you guys are messing with me right?

[23:01] <stevan> iheartcanada: been done for a long time now,... where you been?

[23:01] <iheartcanada> wow

[23:01] <mugwump> iheartcanada: we're still very pre-alpha, but it's moving quickly.  objects for instance are still in the works

[23:01] <iheartcanada> i thought it's in development

[23:01] <stevan> iheartcanada: it is in dev, very active develeopment

[23:02] <stevan> see autrijus's journal over the past 3 months for detailed info :)

[23:02] <iheartcanada> *nod*

[23:02] <iheartcanada> i just use it to make the occational webpage

[23:02] <iheartcanada> but i'd love to use perl6 if it's stable enough and supported by mod_perl

[23:03] <mugwump> well, my guess is it will probably be at least a year before Perl 6 is ready for wide scale use

[23:03] <iheartcanada> i look forward it that day :)

[23:03] <iheartcanada> *yawn*

[23:03] <iheartcanada> back to worrrk

[23:03] <mugwump> you're probably better off for now making sure you're getting in line with what others are doing with Perl 5

[23:04] <mugwump> eg, templating systems, frameworks, etc

[23:04] <iheartcanada> *nod*

[23:04] <mugwump> the skills will be transferrable

[23:04] <iheartcanada> sweet

[23:07] <mugwump> stevan: so, part of the challenge of implementing that duck typing model is to bridge the roles based and class based inheritance.

[23:08] <stevan> ok

[23:09] <mugwump> so, we've got a method which is defined by its method signature

[23:09] <mugwump> ie, its name, its parameters and return values (which are all types)

[23:10] <mugwump> (er, the name is a symbol :))

[23:10] <mugwump> a role is simply a group of these method signatures

[23:10] <mugwump> This is the core of duck typing.  Properties are considered incidental

[23:14] <stevan> mugwump: don't roles have properties as well?

[23:15] <mugwump> you can of course use properties in role declarations

[23:15] <mugwump> and implementations

[23:15] <mugwump> those properties are being tacked onto the object/class that "does" the role

[23:16] <stevan> ok

[23:16] <stevan> yeah I did a perl5 implementation of Traits, which didnt use it, they did not allow properties though

[23:16] <stevan> only methods

[23:17] <mugwump> sure.  These things are a little harder in P5 :)

[23:17] <stevan> yup

[23:18] <mugwump> As far as I can see, all a trait is is a property(as in characteristic, not data member) of something in the Class model

[23:21] <stevan> mugwump: so I am going to change the names in 10_MetaClass.t to be Package , Role, Class, etc

[23:21] <stevan> now that I have a better understanding of that

[23:22] <mugwump> sure, change the names if you like, but don't worry about making them "complete"

[23:22] <mugwump> the complete classes that describe the Perl 6 class model, we will want to put in modules :)

[23:22] <stevan> yes

[23:23] <stevan> what namespace should that be

[23:23] <mugwump> Perl6::Class?

[23:23] <mugwump> etc?

[23:23] <stevan> :)

[23:23] <stevan> sounds good to me

[23:24] <mugwump> having said that, they don't actually exist in a namespace per se, they're just data objects

[23:24] <stevan> yeah

[23:24] <stevan> I looked at that part of Pugs/Class.hs, but I am ignoring it right now until I get my head around the rest

[23:24] <mugwump> so maybe the 'main' Perl::MetaModel namespace

[23:25] <stevan> Perl::ObjectModel?

[23:25] <mugwump> Perl::FoundationClasses?

[23:25] * mugwump revolts at his own suggestion

[23:25] <stevan> LOL

[23:30] <stevan> ok commiting the better example names

[23:43] <Shillo> Hullo, all. :)

[23:48] <cognominal> what is a ! in haskell

[23:49] <stevan> mugwump: any thoughts on next steps? or am I proceeding the right direction

[23:52] <mugwump> the next steps would be making basic Role/Class/Property/etc Perl::MetaClass objects

[23:52] <stevan> mugwump: I think I need to flesh out some corners first

[23:52] <mugwump> I'm about to update MetaAssoc, hopefully that will shed some more light

[23:52] <mugwump> sure

[23:52] <stevan> ok

[23:52] <stevan> like Properties, where are we storing the visibility?

[23:54] <mugwump> on the metamodel, it doesn't really matter that much, we don't care all that much.

[23:55] <mugwump> er, sorry to repeat myself in the same sentence

[23:55] <mugwump> in the haskell it was written as the properties collection was a map from the label of the property to the visibility and the actual property definition, ie the visibility isn't a characteristic of the property, but more its definition.

[23:56] <mugwump> however that's somewhat obstruese

[23:56] <Shillo> cognominal: I'm still Haskell-newbie, but I think it's a strictness marker.

[23:56] <Shillo> cognominal: Says that when you evaluate constructor, all its components much be initialised strictly.

[23:56] <Shillo> (i.e. non-lazily)

[23:57] <stevan> mugwump: so maybe putting it in the MetaProperty makes sense?

[23:57] <mugwump> er, abstruse :)

[23:57] <mugwump> yes, that is fine

[23:57] <cognominal> Shillo: so I can ignore it at first reading :)

[23:57] <stevan> ok I will hack that in

[23:57] <Shillo> cognominal: Yep. Mostly it's performance thing.

[23:59] * Shillo heads to sleep. Laters. :)

