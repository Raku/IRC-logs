[00:01] * putter notes in the interest of full disclosure that he's been avoiding getting a cpan id since, well, their inception, so it's unlikely to occur rsn. :/

[00:05] <theorbtwo> Putter: Why avoid it?

[00:10] <putter> the authorship/responsibility model is, I won't say broken, how about incompatible with some patterns of use.  there is no mechanism to create something, and then say "here, this exists, maintain it collectively if you wish, but I, the original author am completely out of it".

[00:16] <wilx> Hmm...

[00:16] <wilx> True.

[00:17] <wilx> XML::RSS could use that model.

[00:19] <wilx> The original author hasn't touched it for quite some time even though it has many reported bugs. And there is no way how to push users' fixes into it, so everybody is left to maintain his/her own local version.

[00:20] <putter> yes.  and I have patched versions of long broken cpan modules on my web site, but they are on the web site rather than cpan for exactly the same reason that the original has been long broken.

[00:24] <putter> perhaps if there were a concept of collective authors, a committee owning some package, so abandoned packages could be taken over by the committee, with say a policy of "if you send a working patch, we will get to it before too many months have passed".

[00:24] <wilx> Yeah.

[00:36] <putter> good night all &

[00:50] <f0rth__> t[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[

[03:25] <svnbot6> r6318 | fglock++ | * perl5/ Value - added boxed type: List 

[03:25] <svnbot6> r6318 | fglock++ |   (lazy, non-lazy, infinite); tests

[03:30] <fglock_> It would be nice to have a minimal Perl6->Perl5 compiler in order to run perl6-Test::More

[04:11] <autrijus> oooh

[04:11] <svnbot6> r6319 | Stevan++ | Perl6::MetaModel 2.0 - 

[04:11] <svnbot6> r6319 | Stevan++ | * chaos.pl is largely complete now, it is all the

[04:11] <svnbot6> r6319 | Stevan++ |   basic elements needed to construct the meta-model

[04:11] <svnbot6> r6319 | Stevan++ | * gnosis.pl is also largely complete from here we 

[04:11] <svnbot6> r6319 | Stevan++ |   can construct the $::Class as an instance of itself

[04:11] <svnbot6> r6319 | Stevan++ | * many tests written as well, +90% coverage on all 

[04:11] <autrijus> shiny new rt.openfoundry.org is online

[04:11] <svnbot6> r6319 | Stevan++ |   aspects of the code which are currently utilized

[04:11] <autrijus> gugod++

[04:11] <svnbot6> r6319 | Stevan++ |   (some things are not used by the model)

[04:12] <autrijus> tcliou++

[04:12] <autrijus> LCamel++

[04:12] <obra> 'evening

[04:13] <autrijus> obra: hi

[04:14] <obra> How's it going?

[04:14] <autrijus> just woke up

[04:37] <Aankhen``> Heh.

[04:38] <Aankhen``> nothingmuch got to the P::V thread before I did.

[06:06] <QtPlatypus> Has anyone seen http://cog.cognitivity.com/perl6/ it seems full of inaccurate infomation.

[06:18] <svnbot6> r6320 | Stevan++ | Perl6::MetaModel 2.0 -

[06:18] <svnbot6> r6320 | Stevan++ | * metamorph is done except for attributes

[06:18] <svnbot6> r6320 | Stevan++ |     - many new tests for this code

[06:18] <svnbot6> r6320 | Stevan++ | * added the original version of the mini-meta-model

[06:18] <svnbot6> r6320 | Stevan++ |   that this code was based upon, mostly it is just

[06:18] <svnbot6> r6320 | Stevan++ |   here as reference

[06:34] <Khisanth> QtPlatypus: well the copyright is 2002

[06:34] <svnbot6> r6321 | putter++ | Gets PIL-Run again able to 'say 3', now with -CPerl5.

[06:48] <putter> fglock_: ping?

[06:50] <nothingmuch> morning

[06:52] <xinming> lol. here is at noon. :-)

[06:52] <xinming> nothingmuch: good afternoon maybe. ;-)

[06:52] <nothingmuch> xinming: somewhere it's morning, so i usually say "morning", i like that word best

[06:53] <nothingmuch> sometimes i may say "evening", and almost never "good localtime"

[06:53] <nothingmuch> but i'm well aware that my time zone is a minority

[06:53] <putter> nothingmuch: morning.  here too almost - soo time to sleep.  woobling smoke ran :), but p6 t/rules still all red :(

[06:53] <nothingmuch> also, since most hackers' sleep cycles are completely screwed up, it doesn't really matter what you say

[06:53] <nothingmuch> putter: i'll look into it when I get back from work, or around my lunch hour or something

[06:54] <putter> np.  thanks.

[06:54] <putter> good second-moon-rising.

[06:54] <nothingmuch> putter: sleep well!

[07:00] <xinming> Ok, Now, Would anyone help me finish the job I haven't done yesterday?

[07:00] <putter> thanks. :)

[07:00] <xinming> I didn't write a test for pugs.

[07:00] <xinming> I wish to finish it. As at least, I learnt svn a bit. ;-)

[07:05] <xinming> ?eval bool::true < 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval bool::true > 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval bool::false > 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval bool::true > 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval bool::false > 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval true( 100 ) > 1

[07:05] <evalbot6> bool::false 

[07:05] <xinming> ?eval true( 100 ) == 1

[07:05] <evalbot6> bool::true 

[07:06] <xinming> ?eval true( 100 ) < 5

[07:06] <evalbot6> bool::true 

[07:06] <xinming> ?eval bool::true < 5

[07:06] <evalbot6> bool::true 

[07:06] <putter> btw, there is a p6 article on slashdot.

[07:06] <xinming> ?eval 3 < 1 < 5

[07:06] <evalbot6> bool::false 

[07:07] <xinming> putter: please give me the url 

[07:07] <xinming> ?eval bool::true < 5

[07:07] <evalbot6> bool::true 

[07:07] <xinming> ?eval bool::false < 5

[07:07] <evalbot6> bool::true 

[07:08] <putter> http://books.slashdot.org/article.pl?sid=05/08/16/0511217&mode=nocomment&tid=145&tid=6

[07:10] <putter> fglock_: re	"It would be nice to have a minimal Perl6->Perl5 compiler in order to run perl6-Test::More", perl5/PIL-Run is now attempting to use Perl6-Value. :)  command line in perl5/PIL-Run/TODO.  cheers.

[07:11] <svnbot6> r6322 | putter++ | Beginning of PIL-Run migration to Perl6-Value and Perl6-MetaModel.  So it's broken again.  'say 3' on crude_repl.pl (the full command is in TODO) currently fails with Value/MetaModel errors.

[07:12] <putter>  fglock_++ for saying "it would be nice to have" :)

[07:12] <putter> end of day for me.

[07:13] <putter> good night all &

[07:19] <putter> xinming: oh, sorry, missed your request.  copy an existing test .t file, replace the description and body with your new test(s), adjust the test count.  ./pugs -Iblib6/lib t/mumble.t  will run your new test.  svn add t/mumble.t;  ./util/add-svn-props.sh t/mumble.t; svn diff; svn ci -m"your log entry"

[07:20] <putter> oh, you may still have to run  make test , just until the first tests start running, for ./pugs -Iblib6/lib t/mumble.t to work.

[07:21] <putter> questions?

[07:21] <xinming> putter: hm, thanks, no questions, But just something to do for now. ;-)

[07:22] <putter> ok.  svn co http://svn.openfoundry.org/pugs/  if you dont already have it of course.

[07:22] <putter> good night.

[08:41] *** kgftr|ko1obi is now known as kgftr|konobi

[10:35] <xinming> anyone here in debian?

[10:58] *** Aankh|Clone is now known as Aankhen``

[11:10] <autrijus> rehi :)

[11:10] <autrijus> xinming: tried haskell-unsafe yet?

[11:13] <xinming> autrijus: hmm, to be honest, I tried. Yesterday, I tried to install ghc6 in debian and upgrade my system into unstable. and the problem is out. It still said it's version GHC 6.2.x.y.z...

[11:14] <xinming> autrijus: So, I try to compile my self. using the version 6.4.1.{time}

[11:14] <xinming> and it said, can't find the openal lib... ouch...

[11:14] <xinming> hmm, but now, i installed the ghc6.4. might work for now. thanks for your attention. ;-)

[11:14] <autrijus> cool :)

[11:17] <xinming> by the way, how much ram did you get for your computer?

[11:17] <xinming> autrijus: 512M or 1G?

[11:20] <autrijus> xinming: 768m

[11:21] <xinming> maybe that's just enough for compiling haskell. 

[11:21] <xinming> I got 512M ram, But still swaping heavily.

[11:24] <autrijus> nod

[11:33] <xinming> by the way, How to remove the pugs I ever installed from CPAN?

[11:37] <xinming> go supper. bbl

[11:41] *** oussama is now known as foxmjay

[11:42] *** wilx` is now known as wilx

[11:49] <xinming> ?eval class T { my $.a = 1; }; my T $o .= new; $o.a();

[11:49] <evalbot6> Error: No compatible subroutine found: "&a" 

[11:49] <xinming> ?eval class T { has $.a; }; my T $o .= new; $o.a();

[11:49] <evalbot6> \undef 

[11:50] <xinming> hmm, the accessor function should be generated... wether declared by my or has

[11:53] <xinming> by the way, when might the hyper operator supported be added?

[11:53] * nothingmuch needs a cloaking device

[11:53] <nothingmuch> i've worked for around 2 hours today, including context switches

[11:53] <nothingmuch> the rest was also work

[11:54] <nothingmuch> but the "please come help" variety

[11:54] <nothingmuch> or "Can you explain this to me", or "*knock* *knock* [on window] - please open the door, the intercom isn't working"

[11:58] <xinming> iblechbot: seen iblechbot 

[11:58] <jabbot> xinming: I havn't seen iblechbot, xinming

[11:58] <xinming> iblechbot: seen iblech

[11:58] <jabbot> xinming: iblech was seen 12 hours 28 minutes 11 seconds ago

[11:59] <xinming> jabbot: seen xinming

[11:59] <jabbot> xinming: xinming was seen 19 seconds ago

[13:00] <xinming> anyone here free?

[13:00] <xinming> need some help.

[13:01] <theorbtwo> xinming: In general, don't bother asking to ask -- just ask.

[13:07] <xinming> theorbtwo: Could you please guide me step by step to write a test?

[13:08] <kolibrie> xinming: a whole test file, or a single test within a file?

[13:08] <xinming> someone "putter" ever taught me. But not so clear, as I didn't do write the test that time, No ghc and pugs installed. hm, Now I will to try

[13:08] <xinming> whole test file

[13:09] <xinming> #!/usr/bin/pugs

[13:09] <xinming> use v6;

[13:09] <xinming> use Test;

[13:09] <xinming> plan 1;

[13:09] <xinming> I know these are the lines for "header" :-)

[13:09] <kolibrie> start by finding another test file, and copy it, then delete out all the stuff at the bottom

[13:09] <theorbtwo> Right.  Now, what is it you are trying to test?

[13:09] <xinming> theorbtwo: Yeap.

[13:11] <xinming> class T

[13:11] <xinming> {

[13:11] <xinming>         method a

[13:11] <xinming>         {

[13:11] <xinming>                 'test a';

[13:11] <xinming>         }

[13:11] <xinming> }

[13:11] <xinming> my T $o .= new;

[13:11] <xinming> $o.a();

[13:11] <xinming> a $o:;

[13:11] <xinming> a $o;

[13:11] <xinming> these are the contents for the test.

[13:11] <xinming> hmm, which one ever fixed.

[13:12] <xinming> But, the test file hadn't been written

[13:12] <kolibrie> so then you need to decide which values need to be the same and test with 'is'

[13:13] <theorbtwo> OK, put that all in the text file, after the "plan 1" line.

[13:13] <kolibrie> is($actual, $expected, $description);

[13:13] <xinming> theorbtwo: I've down that.

[13:13] <xinming> kolibrie: hold on please.

[13:13] <theorbtwo> Now, put an ok("Still alive after new"); after that my T $o .= new;

[13:14] <theorbtwo> Change those calls to a to read is($o.a(), 'test a', 'dot call'), etc.

[13:14] <theorbtwo> It's is(<thing being tested>, <what it should return>, <name of test>).

[13:14] <theorbtwo> Then fix the plan line to give the right number of tests -- four, by my count.

[13:18] <xinming> !/usr/bin/pugs

[13:18] <xinming> use v6;

[13:18] <xinming> use Test;

[13:18] <xinming> plan 4;

[13:18] <xinming> class T

[13:18] <xinming> {

[13:18] <xinming>         method a

[13:18] <xinming>         {

[13:18] <xinming>                 'test';

[13:18] <xinming>         }

[13:18] <xinming> }

[13:18] <xinming> my T $o .= new;

[13:18] <xinming> ok( "Still alive after new" );

[13:18] <xinming> is( $o.a(), 'test', "The original method call form" );

[13:18] <xinming> is( a $o:, 'test', "The indirect object notation call with arguments" );

[13:18] <xinming> is( (a $o), 'test', "The indirect object notation call without arguments" );

[13:18] <xinming> then, This is the right form, thanks. ;-)

[13:19] <fglock> putter: ping timed out :)

[13:20] <kolibrie> xinming: now you should be able to run the test: ./pugs testfile.t

[13:21] <xinming> kolibrie: yeap

[13:22] <kolibrie> xinming: you may also want to add notes as to where the syntax is documented

[13:22] <theorbtwo> Looks good to me too.

[13:22] <theorbtwo> (I'd add some newlines.)

[13:22] <kolibrie> see t/operators/binding.t for an example

[13:22] <kolibrie> and t/README

[13:37] *** wilx` is now known as wilx

[13:46] <xinming> so, anyone here would check my "homework" if I did right?

[13:46] <xinming> ;-)

[13:46] <svnbot6> r6323 | yiyihu++ | Add test for class method indirect notation.

[13:47] <fglock> re bool::true and bool::false - A12 says they are subtypes of Int - should stringify to 1 and 0 then?

[13:48] <xinming> fglock: I think they are.

[13:49] <autrijus> er no

[13:49] <autrijus> they are subtypes of bit

[13:49] <autrijus> not Int.

[13:49] <autrijus> and they, like, perl5, stringify to '1' and '' respectively -- at least for this week 

[13:50] <fglock> oops - bit, sorry

[13:51] <fglock> which means they are unboxed

[13:51] <autrijus> aye.

[13:53] * theorbtwo wonders...

[13:53] <theorbtwo> The only time I stringify true and false is when doing quick and dirty debugging prints.

[13:53] <theorbtwo> Is that true of other people too?

[13:53] <fglock> if I pointed a Ref to a Scalar, the Ref would point to the cell or to the Scalar? (what happens if the Scalar is rebind)

[13:54] <kolibrie> xinming: in the kwid, the link should be L<S12/"Method"> # explanation here

[13:54] <fglock> theorbtwo: I wished false stringified to 0

[13:54] <theorbtwo> So do I.

[13:55] <fglock> so I could see it while debugging

[13:55] <kolibrie> xinming: or at least not have double angle brackets (<)

[13:55] <theorbtwo> Nothing showing up tends to be confusing, and gives an undef-in-concat warning.

[13:56] <fglock> theorbtwo: false is an empty string - not undef (I believe)

[13:56] <kolibrie> xinming: or maybe I'm just confused

[13:57] <xinming> kolibrie: hmm, I read the t/README And follow the example ;-)

[13:58] <fglock> ?eval my $x=5; my $y=\$x; my $z=4; $x:=$z; say $x; say $y;

[13:58] <evalbot6> 4 5 bool::true 

[13:58] <kolibrie> xinming: I see the example you followed - never saw that syntax before three minutes ago

[13:58] <xinming> kolibrie: :-)

[13:59] <fglock> so Ref refers to the cell? or \$x was dereferenced?

[14:00] <theorbtwo> ?eval my $x=5; my $y=\$x; my $z=4; $x:=$z; [$x, $y];

[14:00] <evalbot6> [4, 5] 

[14:00] <autrijus> fglock: Ref refers to the container.

[14:00] <autrijus> fglock: the current semantic, namely deref even in scalar context, is wrong.

[14:00] <autrijus> s/semantic/pugs implementation/

[14:01] <theorbtwo> Oh, autrijus:

[14:01] <theorbtwo> ?eval 1 ~~ bool::true

[14:01] <evalbot6> bool::true 

[14:01] <theorbtwo> ?eval 3 ~~ bool::true

[14:01] <evalbot6> bool::false 

[14:01] <theorbtwo> Bug or feature?

[14:02] <svnbot6> r6324 | autrijus++ | * make the use of ::SELF and ::CLASS explicit in Perl6::Value to

[14:02] <svnbot6> r6324 | autrijus++ |   pass use strict.

[14:02] <fglock> "bit" has bool context (maybe)

[14:05] <fglock> thanks autrijus

[14:05] <xinming> ?eval (1, 4, 66) >>+<< (1,2,3)

[14:05] <evalbot6> (2, 6, 69) 

[14:05] <xinming> ?eval (1, 4, 66) >>-<< 1;

[14:05] <evalbot6> (0, 3, 65) 

[14:20] <autrijus> woot, I repaired crude_repl!

[14:21] <autrijus> theorbtwo: I think it's feature

[14:21] <autrijus> theorbtwo: since both end stringify

[14:21] <autrijus> theorbtwo: but smartmatch against an enum is iirc not specced. I may be wrong

[14:24] <dada> ?eval ?3 ~~ bool::true

[14:24] <evalbot6> bool::true 

[14:25] <dada> ?eval ~bool::true

[14:25] <evalbot6> '1' 

[14:28] <svnbot6> r6325 | autrijus++ | * crude_repl: `say 1+1` works properly.

[14:29] <autrijus> actually, "say((say 1+1) + (say 1+1))" works too

[14:29] <autrijus> fill in some of pugs/perl5/PIL-Run/lib/PIL/Run/PrimP5.pm

[14:29] <autrijus> and we'll have an exciting perl6-compiled-to-perl5 runtime

[14:30] <fglock> cool

[14:31] <autrijus> fglock++ stevan++ putter++ # did all the hard work :D

[14:32] <fglock> "substr" is a Str method, or a primitive, or both (boxed/unboxed versions of the same thing)?

[14:34] <autrijus> substr is a multisub that can take str or Str.

[14:34] <svnbot6> r6326 | fglock++ | * perl5/ Value - bool::true is unboxed, stringifies as "bit"

[14:34] <fglock> so I don't have to implement it in the Sub class

[14:35] <fglock> Sub => Str

[14:35] <autrijus> no, you don't

[14:35] <autrijus> the idea of multis is exactly that we can add method-like things outside classes

[14:35] <autrijus> and hopefully escaping the OO hell

[14:36] <fglock> how about map, grep? if I can remove these things from Value.pm, then it's done :)

[14:36] <xinming> class C1 { has $.a; has $:b; }; my C1 $o .= new; is( $o.a(), undef, "testing the value for public accessor declared by has" );

[14:36] <xinming> hmm, how should I write the test for test the "non exist accessor" $o.b() ?

[14:36] <autrijus> fglock: map and grep are multis too

[14:36] <autrijus> xinming: fails_ok

[14:37] <xinming> autrijus: by the way, It seems that if I use perldoc Test

[14:37] <xinming> I can get the Test module correctly.

[14:37] <autrijus> xinming: that's perl5 Test :)

[14:37] <xinming> the document are wrong totally.

[14:37] <autrijus> not the p6 one

[14:38] <xinming> autrijus: I knew that.

[14:38] <autrijus> yeah, we need perldoc6 ;)

[14:38] <autrijus> or p6doc

[14:39] <xinming> No compatible subroutine found: "&fails_ok"

[14:39] <autrijus> er, dies_ok

[14:40] <xinming> ....

[14:41] <fglock> so the only real problem in Value.pm is to clean up the "Ref auto-deref" hack

[14:42] <fglock> which needs AUTOLOAD I think

[14:47] <xinming> if the feature hasn't been finished yet, How can I write the test for it?

[14:47] <xinming> hmm, I mean the feature hasn't been supported.

[14:47] <xinming> just like 

[14:48] <xinming> ?eval class C1 { has $.a = 1;};

[14:48] <evalbot6> Error:  unexpected "=" expecting trait, "handles", ";" or "}" 

[14:49] * autrijus ponders visiting .jp to work with sasada-san

[14:51] * xinming is hungry for the answer ~~~

[14:51] <autrijus> oh

[14:51] <autrijus> sorry

[14:51] <autrijus> ?eval eval 'class C1 { has $.a = 1;};'

[14:51] <evalbot6> undef 

[14:51] <autrijus> ?eval eval 'class C1 { has $.a = 1;}; 1'

[14:51] <evalbot6> undef 

[14:51] <autrijus> and then you can test ok()

[14:52] <autrijus> see t/README

[14:52] <xinming> I've read it, But the problem is.

[14:53] <xinming> after the eval_ok, I can't get the class name

[14:53] <autrijus> so put that in eval too

[14:54] <xinming> oh,ok, I understand

[14:57] <autrijus> hm, I can't find a copy of YARV 0.3.0. sigh

[15:06] <svnbot6> r6327 | fglock++ | * perl5/ 'List' clean up - removed 'multisub' methods

[15:08] <xinming> ?eval class C { my $.a; }; $.a = 1;

[15:08] <evalbot6> Error: Undeclared variable: "$?SELF" 

[15:08] <xinming> oops

[15:08] <xinming> ?eval class C { my $.a; }; my C $o .=new ; $o.a();

[15:08] <evalbot6> Error: No compatible subroutine found: "&a" 

[15:09] <autrijus> xinming: yes, another todo bug

[15:10] <xinming> I am still considering. If I need to write several classes for testing the attribute or a big class. :-)

[15:10] <xinming> Now, The attribute.t is almost done.

[15:10] <autrijus> xinming++

[15:10] <xinming> but a bit ugly maybe. :-)

[15:10] <xinming> I will.

[15:18] <svnbot6> r6325 | autrijus++ | * crude_repl: `say 1+1` works properly.

[15:18] <svnbot6> r6326 | fglock++ | * perl5/ Value - bool::true is unboxed, stringifies as "bit"

[15:18] <svnbot6> r6327 | fglock++ | * perl5/ 'List' clean up - removed 'multisub' methods

[15:23] <svnbot6> r6328 | yiyihu++ | Attribute test added. But for now, Just test the auto generated accessor.

[15:23] <svnbot6> r6329 | fglock++ | * perl5/ Value - updated TODO, docs, tests

[15:27] <xinming> by the way, is there any editor now can highlight perl 6 syntax? :-)

[15:27] <theorbtwo> There's a vi syntax file in scripts, IIRC.

[15:27] <xinming> It's a pain to use emacs without syntax highlighting.

[15:27] <theorbtwo> Yeah, my perl syntax hilighting got broken somehow, and it's a big PITA.

[15:31] <autrijus> ?eval my $a = $a / 2 * BEGIN { $a = 10 };

[15:31] <evalbot6> pugs: *** Undeclared variable: "$a"     at <eval> line 1, column 26-34 

[15:31] <autrijus> hm, broken.

[15:32] <autrijus> ?eval my $a; $a = $a / 2 * BEGIN { $a = 10 };

[15:32] <evalbot6> \50 

[15:32] <autrijus> good.

[15:35] <xinming> autrijus: can the test file use if or for such blocks?

[15:35] <autrijus> sure

[15:36] <xinming> autrijus: Ok,then, I will shorten my test file. I just thought, We have to use the minimal grammer in perl.

[15:37] <autrijus> no, it's okay to use other features :)

[16:02] <leo_> autrijus: thanks for your comments on p6i

[16:02] <autrijus> hey leo :)

[16:02] <leo_> hey autrijus 

[16:03] <autrijus> sorry, the $a was out of scope in my example

[16:03] <autrijus> but the basic idea is the same as with p5

[16:03] <autrijus> ?eval say { my $a; $a /= 2; BEGIN { $a = 10 }; $a }

[16:03] <evalbot6> <SubBlock(<anon>)> bool::true 

[16:03] <leo_> I thought so :-)

[16:03] <autrijus> ?eval say do { my $a; $a /= 2; BEGIN { $a = 10 }; $a }

[16:03] <evalbot6> Error: Undeclared variable: "$a" 

[16:03] <autrijus> heh

[16:03] <autrijus> ?eval my $a; $a /= 2; BEGIN { $a = 10 }; say $a

[16:03] <evalbot6> 5 bool::true 

[16:03] <autrijus> better.

[16:04] <leo_> yep

[16:04] <autrijus> the main thing I'm trying to ask is how BEGIN can remember its lexical context

[16:04] <autrijus> my $a { my $b; BEGIN { $a = { say $b++ } } };

[16:05] <leo_> hmm

[16:05] <svnbot6> r6330 | iblech++ | * Usual svn props.

[16:05] <svnbot6> r6330 | iblech++ | * PIL2JS: JSAN integration.

[16:05] <svnbot6> r6330 | iblech++ |   "use jsan:Number.Roman <to_roman>; say to_roman 42" works.

[16:05] <svnbot6> r6330 | iblech++ |   * PIL2JS.js: .arity works on functions returned by native JS functions now.

[16:05] <svnbot6> r6330 | iblech++ |   * Prelude::JS::JSAN: Added comments and

[16:05] <svnbot6> r6330 | iblech++ |     &PIL2JS::Internals::use_jsan_module_noimp.

[16:05] <svnbot6> r6330 | iblech++ |   * See the updated README for info about how the integration works and a small

[16:05] <svnbot6> r6330 | iblech++ |     usage example.

[16:06] <Aankhen``> O_O

[16:06] <autrijus> iblech++

[16:07] <autrijus> leo_: currently the compiler is maintaining a runtime environment itself too

[16:07] <autrijus> in pugs

[16:07] <autrijus> which is distinct from the target runtime

[16:08] <autrijus> so you may cross-compile to, say, PIR, but the compiler itself is running in perl5

[16:11] <leo_> bbl - feeding dogs

[16:11] <autrijus> now I need to make "use perl5:DBI" work in crude repl :)

[16:19] <xinming> ?eval class X { has $:x; method init_x { $:x = 100 }; method get_x { $:x };}; X.new.get_x;

[16:19] <evalbot6> \undef 

[16:20] <xinming> ?eval class X { has $:x; method init_x { $:x = 100 }; method get_x { .init_x(); $:x };}; X.new.get_x;

[16:20] <evalbot6> \100 

[16:28] * fglock moves attention to crude_repl.pl - will try lazy lists

[16:28] <leo_> autrijus: the question is probably how dynamic the lexical context is

[16:31] * fglock thinks %h=1..Inf should be a lazy hash

[16:32] <autrijus> fglock: I can't think of many uses of a lazy hash.

[16:32] <autrijus> a lazy hash is called a function.

[16:33] <autrijus> leo_: if it helps, every 'my' declaration can only occur once in a closure

[16:33] <autrijus> with the same name, that is

[16:33] <autrijus> and they are hoisted to the top

[16:34] <autrijus> but still, BEGIN need to remember that.

[16:34] <leo_> so it seems that the scheme I've described in the mail should work

[16:35] * fglock TODO: find uses for lazy hash

[16:35] <autrijus> fglock: a lazy hash is really what a function is... :)

[16:36] <theorbtwo> Well, a unary function.

[16:36] <autrijus> er, a hash can be shaped with  multikey

[16:37] <fglock> so why not? you can use a lazy hash wherever you use a function

[16:37] <autrijus> fglock: well, a lazy hash is the & sigil

[16:37] <autrijus> and a strict hash is the % sigil

[16:38] <theorbtwo> G'point, autrijus, forgot about that.

[16:40] <fglock> where "tie" is going to be implemented? (Value/Scalar.pm ?)

[16:40] <fglock> I mean Container/Scalar.pm

[16:40] <fglock> hi stevan

[16:40] <stevan> hey fglock 

[16:41] <fglock> stevan: is it possible to AUTOLOAD methods in MetaModel 1 ?

[16:41] <stevan> fglock: not right now

[16:41] <stevan> but I think it could be made to do so

[16:42] <fglock> maybe using Perl5 AUTOLOAD, and then creating methods using the metamodel

[16:43] <fglock> I'm trying to find out how to dispatch method calls from Ref to the referred object

[16:43] <stevan> fglock: I think if WALKMETH were to check for an 'AUTOLOAD' method

[16:44] <spinclad> seem to me a lazy hash would be a memoized function

[16:44] <stevan> and to always use that by default

[16:44] <stevan> this would produce the desired result

[16:46] <fglock> stevan: do you mind if I try to implement a basic AUTOLOAD?

[16:46] <stevan> fglock: I am testing something right now

[16:47] <fglock> cool

[16:47] <stevan> however, always feel free to hack into the metamodel 

[16:47] <stevan> my code is your code :)

[16:47] <fglock> :)

[16:48] <stevan> fglock: I am going to try to make the Metamodel 2.0 be mostly backwards compatible  

[16:48] <stevan> however, it will have proper class object, so that will be one big change 

[16:49] *** Maddingue__ is now known as Maddingue

[16:55] <fglock> crude_repl.pl 'say 1' - got "Odd number of elements in hash assignment at ../Perl6-MetaModel/lib/Perl6/Object.pm line 36"

[16:59] <autrijus> fglock: hm, weird I fixed that

[17:00] <svnbot6> r6331 | putter++ | hack.pod: Added editing advice: perl6.vim, and perl-mode works better than cperl-mode.

[17:00] <fglock> I'll do an update

[17:01] <fglock> works - thanks!

[17:01] <autrijus> fglock: tie is a scalar method yes.

[17:02] <fglock> autrijus: it stores an object ref in the container, and then dispatch fetch, store, etc to it?

[17:03] <autrijus> yes.

[17:03] <autrijus> (it's rather in the cell level)

[17:04] <autrijus> because you only get that with a "is Tieable" cell

[17:04] <autrijus> and you can rebind tieableness away

[17:04] <autrijus> again look at the picture :)

[17:06] <svnbot6> r6332 | autrijus++ | * shut off uninitialized warnings in numifying values

[17:09] <fglock> (looking at the picture) the Scalar id is a cell thing - I must correct this

[17:10] <fglock> each Array/Hash element have it's own cell? which means I can do ' $a[10] := $x '

[17:12] <autrijus> yup

[17:12] <autrijus> each Array element is essentially its own scalar container.

[17:13] <autrijus> that's specced quite clearly

[17:15] <autrijus> ooh, new exists($a) semantics.  (testing whether a container is currently bound to a cell)

[17:20] <svnbot6> r6333 | putter++ | PIL-Run minor fixes.

[17:20] <svnbot6> r6333 | putter++ | crude_repl.pl: debug and return values now print correctly.

[17:20] <svnbot6> r6333 | putter++ | TODO: updated invocation example.  autrijus++

[17:21] <svnbot6> r6333 | putter++ | PrimP5.pm: minor refactoring.

[17:21] <svnbot6> r6334 | putter++ | PIL-Run/TODO: Update, removing obsolete items.

[17:21] <putter> hi folks.

[17:21] <Aankhen``> Hiya.

[17:21] <fglock> hi putter

[17:21] <fglock> cells are tieable by default?

[17:22] <fglock> and mutable

[17:22] <stevan> fglock: do you need AUTOLOAD for class methods? or just instance methods?

[17:22] <fglock> stevan: only instance methods

[17:23] <stevan> fglock: good, because it is problematic for class methods

[17:24] <xinming> ?eval my $classref = class { has $.x; has $.y; };

[17:24] <evalbot6> Error: No compatible subroutine found: "&class" 

[17:24] <xinming> :-S

[17:25] <xinming> hmm, will this be allowed in perl 6?

[17:25] <autrijus> fglock: no, nontieable by default

[17:25] <autrijus> fglock: and mutable by default

[17:25] <autrijus> the immutable cells are typically constructed via

[17:25] <autrijus> promotion from values

[17:25] <autrijus> my $x := 3;

[17:28] <fglock> values have cells? what if I tied an Array - does it have a base cell that will be tied? sorry for the confusion

[17:28] <svnbot6> r6335 | putter++ | Delete obsolete throwaway perl5/PIL-Run/lib/PIL/Run/Type/Num.pm and Str.pm.

[17:31] <xinming> ?eval (has)

[17:31] <evalbot6> Error: No compatible subroutine found: "&has" 

[17:31] <xinming> ?eval qw(has)

[17:31] <evalbot6> 'has' 

[17:32] <xinming> ?eval (my)

[17:32] <evalbot6> Error: No compatible subroutine found: "&my" 

[17:32] <xinming> ?eval (my $a)

[17:32] <evalbot6> Error: Undeclared variable: "$a" 

[17:37] <autrijus> fglock: an array cell holds pointers to a number of scalar containers

[17:37] <autrijus> fglock: and optionally a tied object.

[17:46] <autrijus> iblech: 'sub foo' hoisting is OK'ed by larry

[17:46] <stevan> fglock: r6337 has full AUTOLOAD support 

[17:46] <autrijus> it's looking better and better :)

[17:46] <svnbot6> r6336 | putter++ | ApiX.pm: p6_to_X no longer take or return multiple values.  'say 1 + 2' now works.

[17:46] <svnbot6> r6337 | Stevan++ | Perl6::MetaModel 1.0 -

[17:46] <svnbot6> r6337 | Stevan++ | * AUTOLOAD implemented for fglock++

[17:46] <svnbot6> r6337 | Stevan++ |    - added test file for this

[17:46] <stevan> fglock: it works, for the most part, like perl 5 AUTOLOAD

[17:47] <stevan> except you have to call AUTOLOAD($self) to get the method label

[17:47] <autrijus> that means we can do away with the need for native runtime supprot for strange foo like

[17:47] <autrijus> (?$a = 3) := foo()

[17:47] <autrijus> which is strange foo indeed

[17:47] <fglock> thanks stevan!

[17:47] <stevan> fglock: no problem :)

[17:49] <stevan> fglock: see the t/14_AUTOLOAD.t file for examples

[17:49] * stevan goes back to $work

[17:50] <fglock> team work++

[17:52] <xinming> autrijus: is for allowed in eval_ok?

[17:52] <svnbot6> r6338 | fglock++ | * perl5/ Scalar - cell .id, half-baked tie interface 

[17:52] <svnbot6> r6339 | putter++ | STATUS: tweak Rules section.

[17:52] *** wilx` is now known as wilx

[18:01] <svnbot6> r6340 | putter++ | EvalX.pm: Added PStmt.  'say 3;say 4' works.

[18:03] <fglock> stevan++ I've got Ref working with AUTOLOAD

[18:06] <autrijus> xinming: sure, but avoid eval_ok if you can

[18:07] <autrijus> xinming: lives_ok {} 

[18:07] <autrijus> xinming: ok

[18:07] <autrijus> ok(eval'')

[18:07] <autrijus> is both better

[18:07] <autrijus> because eval_ok can't see 'my' variables

[18:11] <xinming> autrijus: hmm, Are you free for now?

[18:11] <xinming> hmm, maybe not, I will try myself,

[18:11] <xinming> bbl.

[18:12] <svnbot6> r6341 | fglock++ | * perl5/ Value - Ref uses AUTOLOAD to auto-dereference

[18:16] <autrijus> sorry, I was distracted by accidentally stumbing upon www.my-ebooks.net

[18:26] <xinming> ?eval eval 'class C { has $:b; method { $:b }; }; my C $o .= new;

[18:26] <evalbot6> Error:  unexpected "'" expecting block construct, ":", "\\", "$!", "$/", "$", "'", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[18:26] <svnbot6> r6342 | putter++ | crude_repl.pl: Improved repl commands.

[18:26] <svnbot6> r6342 | putter++ | Prim5.pm: Added infix:<~>.   :l ../../t/01-sanity/01-tap.t  now works.

[18:26] <svnbot6> r6343 | fglock++ | * perl5/ Scalar - uses AUTOLOAD to auto-dereference

[18:26] <xinming> ?eval eval 'class C { has $:b; method get_b { $:b }; }; my C $o .= new;

[18:26] <evalbot6> Error:  unexpected "'" expecting block construct, ":", "\\", "$!", "$/", "$", "'", term postfix, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[18:26] <xinming> ?eval eval 'class C { has $:b; method get_b { $:b }; }' my C $o .= new;

[18:26] <Aankhen``> Whoa... OpenFoundr looks different.

[18:26] <evalbot6> Error:  unexpected "m" expecting operator, ":", ",", term postfix, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

[18:27] <Aankhen``> OpenFoundry, even.

[18:27] <xinming> ?eval eval 'class C { has $:b; method get_b { $:b }; }'; my C $o .= new;

[18:27] <evalbot6> \C.new(); 

[18:29] <putter> Aankhen``: yes.  improved vcs browsing.

[18:29] <Aankhen``> It looks unfinished...

[18:30] <xinming> ?eval eval 'class C { has $:b = 100; method get_b { $:b }; }'; my C $o .= new;

[18:30] <evalbot6> \C.new(); 

[18:30] <xinming> ?eval eval 'class C { has $:b = 100; method get_b { $:b }; }'; my C $o .= new; $o.get_b;

[18:30] <evalbot6> Error: No compatible subroutine found: "&get_b" 

[18:31] <putter> unfinished?

[18:31] <xinming> ?eval eval 'class C { has $:b = 100; has $.a := $:b; method get_b { $:b }; }'; my C $o .= new; $o.get_b;

[18:31] <evalbot6> Error: No compatible subroutine found: "&get_b" 

[18:31] <Aankhen``> Yes.

[18:31] <Aankhen``> Header looks fine... "Summary, Tracker, Wiki [...]" looks fine... rest of it is styled in such a way that it looks unstyled.

[18:32] <xinming> ?eval class C { has $:b = 100; has $.a := $:b; method get_b { $:b }; }; my C $o .= new; $o.get_b;

[18:32] <evalbot6> Error:  unexpected "=" expecting trait, "handles", ";" or "}" 

[18:38] <xinming> ?eval my $str = "123"; "hello $str".say;

[18:38] <evalbot6> hello 123 bool::true 

[18:38] <xinming> ?eval my $str = "123"; "hello $str1".say;

[18:38] <evalbot6> Error: Undeclared variable: "$str1" 

[18:38] <xinming> ?eval my $str = "123"; "hello {$str}1".say;

[18:38] <evalbot6> hello 1231 bool::true 

[18:39] <xinming> ?eval my $str = "123"; eval {"hello {$str}1".say};

[18:39] <evalbot6> 'SubBlock(<anon>)' 

[18:39] <xinming> ?eval my $str = "123"; eval qq,"hello {$str}1".say,;

[18:39] <evalbot6> hello 1231 bool::true 

[18:40] <putter> Aankhen``: I suspect that's the style... ;-)

[18:41] * Aankhen`` makes low noises of dissent.

[18:42] <autrijus> seen on #ruby-lang:

[18:42] <jabbot> autrijus: I havn't seen on, autrijus

[18:42] <autrijus> <autrijus> "perl6 is complete not when there's nothing to take away, but when there's nothing left to add"

[18:45] <putter> Aankhen``: :)

[18:45] <svnbot6> r6344 | fglock++ | * perl5/ Scalar .id and .tie pass all tests

[18:47] <putter> "Perfection is reached, either when there is no longer anything to add, or when there is no longer anything left to take away." (E. Aint-Xupery)  http://www.vendian.org/mncharity/TemporaryURL/misdesign/work.html  ;-)

[18:48] <putter> err, hmm, top page is http://www.vendian.org/mncharity/dir2/misdesign/  

[18:50] <fglock> what's the docs/AES for auto-dereferencing?

[18:50] <svnbot6> r6345 | fglock++ | * perl5/ Scalar - shorten TODO list :)

[18:50] <autrijus> fglock: search p6l for hackathon notes

[18:51] <autrijus> fglock: it's S02 I think...

[18:51] <autrijus> it just says scalar ref to array and hash container need to autoderef

[18:51] <autrijus> scalar-to-scalar remains unspecced for the longest time

[18:51] <autrijus> then at hackathon larry agreed to zeroderef -- i.e. no deref for scalar refs -- for now.

[18:57] <fglock> 'Lazy' is a 'type' of 'Array'? (ie. the same class)

[18:57] <svnbot6> r6346 | fglock++ | * perl5/ Value - Ref - only Hash and Array autoderef

[18:58] <fglock> or a type of List?

[18:58] <Aankhen``> G'night.

[18:59] <xinming> ?eval my $.t = 1; $.t;

[18:59] <evalbot6> Error: Undeclared variable: "$?SELF" 

[18:59] <fglock> good night Aankhen

[18:59] <fglock> ``

[18:59] <xinming> hmm, Is it a bug or it should be a special case?

[18:59] <xinming> the variable name with a '.' at the beginning.

[18:59] <xinming> Aankhen``: Good night.

[19:00] <fglock> ?eval my $?SELF; my $.t = 1; $.t;

[19:00] <evalbot6> \undef 

[19:03] <putter> hmm, let's see, how does one assign an arbitrary value to an existing Perl6::Value::Int...

[19:03] <fglock> putter: you can't assign to Int

[19:03] <fglock> you have to use 'Scalar'

[19:04] <fglock> Int is just an object oriented number, like '3'

[19:05] <autrijus> mmm http://flgr.0x42.net/ruby.js/

[19:05] <autrijus> (ruby prelude in js)

[19:05] <putter> hmm.  but Int has increment and decrement methods... shouldnt they be... oh, they are aren't mutators.  ok.

[19:06] <fglock> $scalar++ calls 3++

[19:06] <stevan> thats it,.. ruby is just too cool,.. I'm switching

[19:07] <fglock> this should have been implemented as a multisub

[19:07] <autrijus> stevan: it's just the runtime, there's no compiler

[19:08] <autrijus> but may be of interest :)

[19:08] <autrijus> xinming: "my $.x" outside class is definitely not allowed

[19:09] <putter> re ruby.js, oooo, neat!   unfortunately last time I checked, there was no ruby equivalent of pypy, ie, a rewrite of the ruby C core in ruby.

[19:09] <autrijus> there's one early effort based on RACC

[19:09] <autrijus> but it didn't really take off.

[19:09] <autrijus> but now with YARV, it's much easier

[19:09] <autrijus> since there's a VM instruction set

[19:10] <putter> and ripper is slowly maturing, so one can use that until one has a parser.

[19:10] <autrijus> however YARV is still quite early -- but already runs miniruby -- which is already better than parrot/perl :)

[19:10] <putter> ;)

[19:11] <autrijus> but the Pneuma and Theos is on our side!

[19:11] <stevan> and Chaos!!!!

[19:11] <autrijus> (a #ruby-lang folk just bought that shirt, claiming it's the geekest shirt ever)

[19:11] <putter> lol

[19:12] <stevan> I think they might be right :)

[19:12] <autrijus> beating even this:

[19:12] <autrijus> http://www.spreadshirt.com/shop.php?op=article&ac=details&article_id=729738#top

[19:12] <stevan> however, we can surely top it

[19:12] <meppl> :D

[19:13] <stevan> http://www.spreadshirt.com/shop.php?op=article&ac=details&article_id=752302#top

[19:13] <stevan> now that is geeky

[19:13] <stevan> McCarthy rules!

[19:13] <autrijus> yeah, that got mentioned too

[19:13] * xinming found painful to understand perl 6. T_T

[19:13] <autrijus> but still pneuma beats it all

[19:13] <stevan> I think i like it in silver better : http://www.spreadshirt.com/shop.php?op=article&ac=details&article_id=752288#top

[19:13] <stevan> autrijus: we need to do a metamodel 2.0 with chaos involved

[19:14] <autrijus> stevan: sure!

[19:14] <autrijus> xinming: it gets better the more you get used to it :)

[19:14] <Odin-> Isn't that kinda like physical pain?

[19:15] <autrijus> I don't know. I never got used to physical pain

[19:16] <stevan> hmm,.. should I get autrijus magnets (http://www.cafepress.com/autrijus.28686100) or buttons (http://www.cafepress.com/autrijus.28686099)

[19:17] * fglock trying to find out what does 'returns Lazy' mean

[19:18] * Odin- has heard that eventually endorphine response drowns out the pain...

[19:18] <Odin-> Meaning that something that's actually very hurtful can start feeling good...

[19:18] <PerlJam> fglock: I think that Lazy is a List that isn't all there yet.  Or it's there but only on demand.

[19:19] <fglock> PerlJam: but List is lazy by default, so it just means 'List'?

[19:22] <autrijus> damnit, my hd just failed on me

[19:22] * autrijus starts the long painful process of dd

[19:22] <obra> Again?

[19:22] <autrijus> yeah.

[19:23] <autrijus> there's something about my usage pattern that makes hard disks unhappy.

[19:23] <autrijus> I wonder why.

[19:24] <obra> I wonder if it's the frequent spinning whilst walking.

[19:25] <obra> how often do you drop it?

[19:25] <fglock> ok found it in S06 - List=(Lazy|Eager), but Lazy is the default. Lazy and Eager are type names.

[19:30] <fglock> re S06: Traits are roles stored in the cell?

[19:30] <autrijus> obra: very often

[19:30] <autrijus> like, twice a day

[19:31] <autrijus> usually on some semisoft surface though

[19:33] * putter thinks autrijus needs a milspec laptop...

[19:33] <stevan> Panasonic used to make a ultralight ruggedized laptop

[19:34] <stevan> I used to drool over it on www.dynamism.com

[19:34] <stevan> not sure if they still make it though

[19:36] <obra> stevan: the toughbooks. they still do

[19:36] <putter> I wonder if you can boot of a card, and then just use a solid-state or tiny-drive card?

[19:36] <stevan> http://catalog2.panasonic.com/webapp/wcs/stores/servlet/ModelList?storeId=11201&catalogId=13051&catGroupId=12871

[19:37] <obra> autrijus: perhaps you want a lenovo with a gravity sensor

[19:37] <putter> http://www.panasonic.com/business/toughbook/home.asp

[19:37] <stevan> hey autrijus, they even have outdoor readable screens,.. so you can go outside :)

[19:37] * fglock reimplements tieable scalars

[19:40] <autrijus> yow

[19:40] <autrijus> completely died

[19:40] <autrijus> I shouldn't run that dd

[19:40] <autrijus> :-((

[19:41] * xinming found someone has implemented the attribute test.

[19:47] <autrijus> oh well

[19:47] <autrijus> I'll see what I can tomorrow to salvage at least my ~/.svk/local

[19:47] <fglock> my $x does Tieable; my $y := $x; tie $y, $o --> is this an error? $y is not tieable

[19:47] <autrijus> local branches are no good when hard disk fails

[19:47] <autrijus> fglock: "my $x is Tieable"

[19:47] <autrijus> "does" is for classes

[19:48] <autrijus> fglock: tieableness is on the cell

[19:48] <autrijus> fglock: the := points $y to the same cell

[19:48] <autrijus> so tie suceeds

[19:49] <autrijus> it's consistent with the perl5 *y = *x semantics

[19:49] <autrijus> I think.

[19:50] <fglock> I'm trying to find out how to make 'my $x is Scalar is Tieable' to set the scalar cell to tieable

[19:50] <autrijus> it should probably use a Cell::Tieable or something 

[19:50] <autrijus> sorry I can't be of much help; my mind is reeling from the sudden shock :)

[19:50] <autrijus> I think sleep is for the best

[19:50] * autrijus waves &

[19:50] <xinming> autrijus: Good night

[19:51] <fglock> time zones-- it's 17:00 here

[19:52] <xinming> It 03:52 Aug 19 here. ;-)

[19:52] <Odin-> 19:52 GMT

[19:52] <svnbot6> r6347 | yiyihu++ | There is already a attributes test in t/oo/attributes, I will learn more and improve that one instead of reinventing the wheel.

[19:52] <xinming> Maybe It's the same as autrijus'

[19:53] <xinming> subversion is an amazing software. :-)

[19:55] <Odin-> Aha! You are a dangerous subversive!

[19:55] <xinming> ...

[19:55] <Odin-> What? You use subversion! :p

[19:55] <xinming> well, don't say that please. You can say I am a newbie rather than subversive.

[19:56] * Odin- is being silly, it should be noted.

[19:58] <putter> Good night autrijus.  Sorry for the loss.

[20:00] <fglock> re metamodel: how can I make an object instance to do/be a role?

[20:02] <xinming> fglock: I thnk the grammar will be role this_role { is that_class }; class that_class { bla; bla; };

[20:04] <fglock> xinming: I can make a 'Class' do a Role, but what I need is that an 'Object' do a role - I don't know if that's possible

[20:06] <xinming> fglock: sorry, I didnt read the question carefully. :-S

[20:06] <fglock> this is actually a 'mixin' - I'll look by this name

[20:11] * putter tries to remember how to do interpolated symbol names in p5...  my $x; my $name = 'x'; print $::($name);  nope, err... 

[20:26] <xinming> putter: do you mean this?

[20:26] <xinming> our $x = "string"; my $name = "x"; $$name = "haha"; print $x;

[20:28] <xinming> ?eval our $x = "string"; my $name = "x"; $$name = "haha"; print $x;

[20:28] <evalbot6> stringbool::true 

[20:28] <xinming> ?eval our $x = "string"; my $name = "x"; $$name = "haha"; $x.say;

[20:28] <evalbot6> string bool::true 

[20:29] <xinming> not work in perl 6

[20:30] <xinming> I think I should say pugs. :-)

[20:36] <putter> xinming: yes!  thank you. :)

[20:41] <Khisanth> did that change to $()?

[20:42] <xinming> symbolic reference won't work with the variable declared by "my".

[20:43] <fglock> ?eval my $n=1; say ::($n)

[20:43] <evalbot6> 1 bool::true 

[20:43] <fglock> :)

[20:44] <xinming> ?eval my $n=3; say ::($n)

[20:44] <evalbot6> 3 bool::true 

[20:44] <fglock> ?eval my $n=4; say ::($n)

[20:44] <evalbot6> 4 bool::true 

[20:44] <xinming> ?eval our $x = "string"; my $name = "x"; $::($name) = "haha"; $x.say;

[20:44] <evalbot6> haha bool::true 

[20:44] <xinming> :-)

[20:45] <xinming> I like haha, better than giggle.

[20:53] <xinming> ?eval my $x = "string"; my $name = "x"; $::($name) = "haha"; $x.say;

[20:53] <evalbot6> haha bool::true 

[20:53] <xinming> ?eval my $x = "string"; my $x = "test"; my $name = "x"; $::($name) = "haha"; $x.say;

[20:53] <evalbot6> haha bool::true 

[20:54] <xinming> ?eval my $x = "string"; my $x = "test"; my $name = "x"; $::($name) = "haha"; $OUTER::x.say;

[20:54] <evalbot6> (no output)

[20:54] <xinming> How to access the first $x? or It's dead.

[20:55] <fglock> ?eval my $x = "string"; { my $x = "test"; my $name = "x"; $::($name) = "haha"; $OUTER::x.say; }

[20:55] <evalbot6> string bool::true 

[21:00] <xinming> ?eval 25_6

[21:00] <evalbot6> 256 

[21:02] <putter> iblech: ping?

[21:04] <xinming> ?eval sub tmp { :key .("value of pair");

[21:04] <evalbot6> Error:  unexpected end of input expecting end of input, ";", statements or "}" 

[21:04] <svnbot6> r6348 | putter++ | PIL-Run variables are now Scalar.  t/01-sanity/02-counter.t passes.

[21:05] <xinming> ?eval sub tmp { :key("value of pair");

[21:05] <evalbot6> Error:  unexpected end of input expecting end of input, ";", statements or "}" 

[21:05] <xinming> ?eval sub tmp { :key("value of pair")};

[21:05] <evalbot6> undef 

[21:05] <xinming> ?eval sub tmp { :key("value of pair") }; tmp();

[21:05] <evalbot6> ('key' => 'value of pair') 

[21:06] <fglock> putter++

[21:09] <xinming> ?eval %hash<Mon Tue Wed Thu Fri Sat Sun> = 1..7;

[21:09] <evalbot6> Error: Undeclared variable: "%hash" 

[21:10] <xinming> ?eval my %hash<Mon Tue Wed Thu Fri Sat Sun> = 1..7;

[21:10] <evalbot6> Error:  unexpected "<" expecting word character, "::", trait, "=", ".=", ":=", "::=", ";" or end of input 

[21:11] <fglock> putter - "my $i=1; say $i.str" gives "Method not found: .apply"

[21:11] *** wilx` is now known as wilx

[21:14] <putter> fglock: method invocation!?!  ha!  there are no objects.  there are no methods.  the Subs are even Subs yet.  ;-)

[21:15] <putter> (well, I suppose Int et al has sucked in Objects, but the rest is true:)

[21:15] <fglock> If $i is Scalar, then $i->str works at the perl level, no problem

[21:16] <fglock> you already have objects!

[21:17] <putter> yes, but '$i.str' in 'say $i.str'  is a method invocation.  which the runtime knows nothing about as yet.

[21:18] <putter> and Sub is still the old non-metamodel stub.  and we dont have Macros, so && and || dont work.

[21:19] <putter> hmm, I'm currently puzzling over Macros.  Does the MM have Macro?

[21:20] <xinming> why the "=~" is renamed to "~~" please?

[21:20] <fglock> no. I think macros are expanded at compile-time 

[21:23] * putter suspects a rigid compile-time vs run-time split will cause much pain.

[21:23] <xinming> anyone here would help? :-S

[21:24] <xinming> tell me why the =~ operator is renamed to ~~, in synopsis, It doesn't tell you much.

[21:24] <xinming> ?eval (3,8,2,9,3,8) >>-<< (1, 2, 3);

[21:24] <evalbot6> (2, 6, -1, 9, 3, 8) 

[21:26] <fglock> xinming - don't know

[21:27] <xinming> thanks anyway. ;-)

[21:27] <theorbtwo> Because it's a lot more then just =~ now.

[21:28] <theorbtwo> And it's symmetric.

[21:29] <PerlJam> It's also really confusing if you happen to read the Exegeses now as E03 has ~~ as an xor operator ;)

[21:30] <xinming> my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x, @y ) -> $a, $b { "$a~$b".say };

[21:30] <xinming> ?eval my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x, @y ) -> $a, $b { "$a~$b".say };

[21:30] <evalbot6> 1~10 2~20 3~30 undef 

[21:30] <putter> fglock: even though most macros are expanded at compile-time, (1) compile-time in perl has stuff running (2) macros participate in namespaces (packages) and scoping, (3) some macros (eg, regex ones) need to be available at runtime.  So I think the MM has to include macros.

[21:30] <xinming> ?eval my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x, @y ) -> $a, $b { $a~$b.say };

[21:30] <evalbot6> 10 20 30 undef 

[21:30] <xinming> ?eval my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x, @y ) -> $a, $b { ($a~$b).say };

[21:30] <evalbot6> 110 220 330 undef 

[21:31] <xinming> hmm, I am sorry for trying the evals here, But the pugs readline doesn't seem to work very well for long terms.

[21:33] <fglock> xinming: for long expressions, you can type in a text editor and execute using 'pugs filename'

[21:34] <fglock> putter: macros should be available inside $str.eval, which is compile+run time

[21:35] <coral> did anyone identify what in evalbot was breaking any().pick?

[21:36] <xinming> geoffb: hmm, In fact, What I mean, is the expressions not too long, And not too short. :-)

[21:36] <xinming> fglock: hmm, In fact, What I mean, is the expressions not too long, And not too short. :-)

[21:36] <xinming> typo. :-)

[21:38] <fglock> coral: don't know about that - but autrijus made some fixes today

[21:40] <fglock> I guess I can't implement Scalar 'tieable' without traits. I'm going to work on the other container types.

[21:51] <xinming> ?eval my $x; my $x;

[21:51] <evalbot6> undef 

[21:51] <Aankhen``> "Morning".

[21:51] <xinming> Aankhen``: morning. ;-)

[21:51] <xinming> my $x; my $x; is a bug. hmm, Did anyone write the test for this?

[21:51] <Aankhen``> 3:20 AM is a rather indecent time to be up.

[21:52] <xinming> :-), here is 05:53

[21:55] <xinming> ?eval my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x, @y ) -> $a, $b { ($a~$b).say };

[21:55] <evalbot6> 110 220 330 undef 

[21:55] <xinming> ?eval my @x = ( 1, 2, 3 ); my @y = (10, 20, 30); for zip( @x; @y ) -> $a, $b { ($a~$b).say };

[21:55] <evalbot6> Error:  unexpected "f" expecting ";", statements or end of input reserved word 

[21:56] <xinming> another bug. :-)

[21:57] <Khisanth> what is the ; suppose to do there?

[21:57] <xinming> hmm, maybe not the bug. just a typo in synopsis.

[21:58] <xinming> Khisanth: hmm, Maybe a typo in synopsis

[21:58] <Khisanth> don't think so

[21:58] <xinming> see S04

[21:58] <xinming> Khisanth: and see S03

[22:02] <Khisanth> xinming: S09 actually :)

[22:04] <xinming> Khisanth: that's for multi dimension array. not for zip operator I think

[22:05] <Khisanth> () is a bracket thingy:)

[22:05] <xinming> ?eval given 1 { when 1 { 'number'.say }; when "1" { 'string'.say } };

[22:05] <evalbot6> number bool::true 

[22:05] <xinming> ?eval given 1 { when "1" { 'number'.say }; when "1" { 'string'.say } };

[22:05] <evalbot6> number bool::true 

[22:06] <xinming> ?eval given "1" { when 1 { 'number'.say }; when "1" { 'string'.say } };

[22:06] <evalbot6> number bool::true 

[22:06] <xinming> ?eval given "1" { when "1" { 'number'.say }; when 1 { 'string'.say } };

[22:06] <evalbot6> number bool::true 

[22:06] <xinming> ?eval given 1 { when "1" { 'number'.say }; when 1 { 'string'.say } };

[22:06] <evalbot6> number bool::true 

[22:09] * Aankhen`` leaves.

[22:09] <Aankhen``> Bye guys.

[22:09] <Aankhen``> I shall miss all the scintillating and way-too-intelligent-for-me conversations in this channel. :-)

[22:10] <Aankhen``> But oh well, I'll be back on the 28th.

[22:10] <Aankhen``> Ciao.

[22:15] <putter> Bye Aankhen``!

[22:15] <putter> Look forward to your return.

[22:15] <xinming> putter: 

[22:15] <xinming> putter: could you please tell me how to do the match exactly in the above example?

[22:16] <xinming> ?eval given 1 { when 1 { 'number'.say }; when "1" { 'string'.say } };

[22:16] <evalbot6> number bool::true 

[22:16] <xinming> ?eval given "1" { when 1 { 'number'.say }; when "1" { 'string'.say } };

[22:16] <evalbot6> number bool::true 

[22:21] <putter> xinming: sorry, i'm late and scrambling to get out the door.

[22:21] <putter> bye all

[22:21] <putter> the approach currently taken by EvalX needs to be altered.  talk later.

[22:21] <xinming> putter: bye.

[22:40] <xinming> ?eval given "1" { when 1 { 'number'.say }; when all(( $_.ref eq "Str", "1")) { 'string'.say } };

[22:40] <evalbot6> number bool::true 

[23:07] <Khisanth> ?eval given "1" { when "1" { 'string'.say }; when 1 { 'number'.say } };

[23:07] <evalbot6> string bool::true 

[23:07] <Khisanth> ?eval "1" ~~ 1

[23:07] <evalbot6> bool::true 

[23:22] <coral> what

[23:22] <coral> er, hi purple

[23:22] <coral> ?eval any(3,1,1,1,1,1,1).pick

[23:22] <evalbot6> 3 

[23:22] <coral> ?eval any(3,1,1,1,1,1,1).pick

[23:22] <evalbot6> 3 

[23:22] <coral> ?eval any(3,1,1,1,1,1,1).pick

[23:22] <evalbot6> 3 

[23:23] <coral> hmm, i think it's still not fixed in evalbot

[23:23] <coral> autrijus did say that the bug was evalbot-specific

[23:23] <wilx> What does .pick do?

[23:23] <Khisanth> which revision is it running anyway?

[23:23] <coral> collapses the quantum eigenstate

[23:23] <coral> (in different words)

[23:23] <coral> ?eval (3|4).pick

[23:23] <evalbot6> 3 

[23:23] <coral> sometimes that would return 4

[23:24] <coral> ?version

[23:24] <coral> not sure how to make evalbot evidence its version

[23:24] <Khisanth> one of those globals but I don't know the name

[23:25] <Khisanth> ?eval map { (3|4).pick } 1..10

[23:25] <evalbot6> (3, 4, 4, 3, 3, 4, 4, 3, 4, 3) 

[23:25] <Khisanth> hmm

[23:25] <Khisanth> so what is up with the 3 and the 1's?

[23:30] <theorbtwo> ?eval scalar(any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> 1 

[23:30] <theorbtwo> ?eval scalar(any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> 1 

[23:30] <theorbtwo> ?eval scalar(any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> 1 

[23:30] <theorbtwo> ?eval join ', ', (any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> '3' 

[23:30] <theorbtwo> ?eval join ', ', (any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> '3' 

[23:30] <theorbtwo> ?eval join ', ', (any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> '1' 

[23:30] <theorbtwo> ?eval join ', ', (any(3,1,1,1,1,1,1).pick)

[23:30] <evalbot6> '3' 

[23:31] <theorbtwo> ?eval my @res; for (0..10) push @res, (any(3,1,1,1,1,1,1).pick); @res

[23:31] <evalbot6> Error: Pattern match failure in do expression at src/Pugs/Eval.hs:383:4-12 

[23:31] <theorbtwo> ?eval my @res; for (0..10) {push @res, (any(3,1,1,1,1,1,1).pick)}; @res;

[23:31] <evalbot6> [3, 1, 1, 3, 3, 3, 3, 1, 3, 1, 3] 

[23:31] <theorbtwo> This seems a bit unlikely.

