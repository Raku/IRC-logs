[00:01] <TimToady> "no smoking" is English, "yes smoking" is not

[00:03] <timotimo> TimToady: was "streem i gather" a joke on gather/take and stream-oriented programming?

[00:03] <TimToady> no

[00:04] <TimToady> or if so, it was subconscious :)

[00:05] *** aborazmeh joined
[00:05] *** aborazmeh left
[00:05] *** aborazmeh joined
[00:05] <lizmat> "use smoking" could be English, but is most likely not  :-)

[00:06] <lizmat> too bad "ok" is taken by Test.pm

[00:14] *** bin_005 joined
[00:17] *** BenGoldberg joined
[00:24] <dalek> rakudo/glr: 7d85cf9 | TimToady++ | src/core/Hash.pm:

[00:24] <dalek> rakudo/glr: Revert "Fix Hash.perl creating code that throws an error when EVALing"

[00:24] <dalek> rakudo/glr: 

[00:24] <dalek> rakudo/glr: This reverts commit 979d2d41b9b0882983ae16952eab7c35542ddc76.

[00:24] <dalek> rakudo/glr: 

[00:24] <dalek> rakudo/glr: ${ } parses fine as long as you're actually producing a hash literal.

[00:24] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7d85cf95af

[00:24] <TimToady> m: my $a = {}; $a.perl.say; {}.perl.say; EVAL '${}';

[00:24] <GLRelia> rakudo-moar d6049e: OUTPUT«{}.item␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${}; in Perl 6 please use $()␤at EVAL_0:1␤------> 3${}7⏏5<EOL>␤»

[00:24] <camelia> rakudo-moar 28faf1: OUTPUT«{}␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${}; in Perl 6 please use $()␤at EVAL_0:1␤------> 3${}7⏏5<EOL>␤»

[00:24] <TimToady> m: my $a = {}; $a.perl.say; {}.perl.say; EVAL '${ :foo }';

[00:24] <GLRelia> rakudo-moar d6049e: OUTPUT«{}.item␤{}␤»

[00:24] <camelia> rakudo-moar 28faf1: OUTPUT«{}␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${ :foo }; in Perl 6 please use $( :foo )␤at EVAL_0:1␤------> 3${ :foo }7⏏5<EOL>␤»

[00:24] <TimToady> m: my $a = {}; $a.perl.say; {}.perl.say; EVAL '${ foo => 42 }';

[00:24] <GLRelia> rakudo-moar d6049e: OUTPUT«{}.item␤{}␤»

[00:24] <camelia> rakudo-moar 28faf1: OUTPUT«{}␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${ foo => 42 }; in Perl 6 please use $( foo => 42 )␤at EVAL_0:1␤------> 3${ foo => 42 }7⏏5<EOL>␤»

[00:28] <TimToady> we just need to handle the degenerate case

[00:29] <dalek> rakudo/glr: 769c5b3 | TimToady++ | src/Perl6/Grammar.nqp:

[00:29] <dalek> rakudo/glr: handle degenerate case of empty ${}

[00:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/769c5b364b

[00:31] <dalek> roast/glr: 82d5a9e | skids++ | S02-types/subset.t:

[00:31] <dalek> roast/glr: Use an equally valid implementation of one test.

[00:31] <dalek> roast/glr: 

[00:31] <dalek> roast/glr: What GLR broke here will definitely be addressed,

[00:31] <dalek> roast/glr: and isn't related to the tested functionality.  So,

[00:31] <dalek> roast/glr: tweak the test in the interest of reducing noise.

[00:31] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/82d5a9e13f

[00:31] *** pmurias left
[00:37] *** aborazmeh left
[00:39] *** lizmat left
[00:52] <skids> m: my \a = (); a.perl.say; my $a = (); $a.perl.say; # TimToady: I take that to mean this behavior is staying?

[00:52] <GLRelia> rakudo-moar 769c5b: OUTPUT«()␤$()␤»

[00:52] <camelia> rakudo-moar 28faf1: OUTPUT«()␤$( )␤»

[00:57] <dalek> rakudo-star-daily: ed5ee22 | coke++ | log/ (9 files):

[00:57] <dalek> rakudo-star-daily: today (automated commit)

[00:57] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ed5ee22bb6

[01:00] *** aborazmeh joined
[01:00] *** aborazmeh left
[01:00] *** aborazmeh joined
[01:05] <dalek> roast/glr: b7dfe8c | skids++ | S06-currying/ (2 files):

[01:05] <dalek> roast/glr: Adjust tests to GLR flattenning behavior

[01:05] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b7dfe8c99e

[01:13] *** lizmat joined
[01:17] *** rurban joined
[01:18] <lizmat> .tell FROGGS I'm curious as to why you applied 9f581101ad to glr, when I reverted it later in nom

[01:18] <yoleaux> lizmat: I'll pass your message to FROGGS.

[01:26] <skids> m: say ((1,2) xx 2).perl;

[01:26] <GLRelia> rakudo-moar 769c5b: OUTPUT«((1, 2), (1, 2)).iterator␤»

[01:26] <camelia> rakudo-moar 28faf1: OUTPUT«((1, 2), (1, 2))␤»

[01:26] *** aborazmeh left
[01:27] <skids> m: my @a = (1,2) xx 2; say @a.perl;

[01:27] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$(1, 2), $(1, 2)]␤»

[01:27] <camelia> rakudo-moar 28faf1: OUTPUT«[1, 2, 1, 2]<>␤»

[01:27] <skids> m: my @a := (1,2) xx 2; say @a.perl;

[01:27] <GLRelia> rakudo-moar 769c5b: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Seq'␤  in block <unit> at /tmp/JYE4DjeRwL:1␤␤»

[01:27] <camelia> rakudo-moar 28faf1: OUTPUT«((1, 2), (1, 2))␤»

[01:30] <lizmat> jnthn TimToady : re http://irclog.perlgeek.de/perl6/2015-08-21#i_11094101 , it seems to me that "is rw" is used for the side-effect of creating a list

[01:31] <lizmat> maybe we should have an "is list" at least now as an alias, to indicate we just want a list?

[01:33] <skids> lizmat: Array, actually.

[01:35] <lizmat> ab6tract++  # for spotting error of my ways in http://irclog.perlgeek.de/perl6/2015-08-21#i_11094316

[01:36] <lizmat> skids: no, List, as per jnthn description at http://irclog.perlgeek.de/perl6/2015-08-13#i_11051703

[01:37] <skids> Oh, right you are.

[01:39] <skids> Is it possible to write-protect uncontainerized things in a List?

[01:39] <lizmat> I'd like to get ack to the first arg rule

[01:40] <lizmat> in my view: my @a = (1,2,3)   # [$(1,2,3)]

[01:40] <lizmat> my @a = |(1,2,3)   # [1,2,3]

[01:40] <lizmat> my @a = 1,2,3  # syntactic sugar for |(1,2,3)

[01:41] <lizmat> so, a () or [] would *never* flatten automagically

[01:41] <skids> I think array assignment is still "always flattens"?

[01:41] <lizmat> if you need it flattened, prefix | is your friend

[01:41] <lizmat> m: my @a = (1,2,3),(4,5)  # no it is not when there's more than 1 arg

[01:41] <GLRelia> rakudo-moar 769c5b: ( no output )

[01:41] <camelia> rakudo-moar 28faf1: ( no output )

[01:41] <lizmat> m: my @a = (1,2,3),(4,5); say @a.perl  # no it is not when there's more than 1 arg

[01:41] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$(1, 2, 3), $(4, 5)]␤»

[01:41] <camelia> rakudo-moar 28faf1: OUTPUT«[1, 2, 3, 4, 5]<>␤»

[01:42] <lizmat> m: my @a = (1,2,3); say @a.perl  # it currently *is* if there's only 1 arg, which I find confusing

[01:42] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2, 3]␤»

[01:42] <camelia> rakudo-moar 28faf1: OUTPUT«[1, 2, 3]<>␤»

[01:42] <skids> Hrm.  I can't keep track then.  I thought that was one of the more constant GLR things.

[01:44] <lizmat> you mean, not flattening?

[01:44] <lizmat> well, 1 exception was made: the 1 arg rule

[01:44] <ShimmerFairy> m: my @matrix = [1,2],[3,4]; my @row = @matrix[0]; say @row.perl

[01:44] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$[1, 2]]␤»

[01:44] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2]]<>␤»

[01:44] <skids> No that array assingment was one of the remaining automatic flattenning areas.

[01:44] *** ilbot3 left
[01:45] <ShimmerFairy> I feel like GLRelia should've returned  [1, 2]  , unless that somehow doesn't count for the 1-arg rule

[01:45] <lizmat> m: my @matrix = [1,2],[3,4]; my @row = |@matrix[0]; say @row.perl

[01:45] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2]␤»

[01:45] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/iCu3QpFWkN␤Arg-flattening | is only valid in an argument list␤at /tmp/iCu3QpFWkN:1␤------> 3my @matrix = [1,2],[3,4]; my @row = |7⏏5@matrix[0]; say @row.perl␤»

[01:45] <lizmat> ShimmerFairy: well, that's were the confusion comes in

[01:45] <lizmat> (or a bug)

[01:46] <lizmat> Perl 6 has done its best to hide the fact that we can have references 

[01:46] <lizmat> I think this is one case we need to rethink, and make things consistent

[01:46] *** ilbot3 joined
[01:47] <lizmat> so anything () or [] should be considered a reference in the P5 sense, and needs to be flattened explicitely if you need it flattened

[01:47] <ShimmerFairy> lizmat: my guess is that that's a bug with array subscripting not acting as 1-arg, at least in some cases

[01:47] <lizmat> m: my @matrix = [1,2],[3,4]; my @row = @matrix[0,1]; say @row.perl

[01:47] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$[1, 2], $[3, 4]]␤»

[01:47] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2], [3, 4]]<>␤»

[01:47] <lizmat> ShimmerFairy: ^^^ does that make sense?

[01:48] <lizmat> m: my @matrix = [1,2],[3,4]; my @i = ^2; my @row = @matrix[@i]; say @row.perl

[01:48] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$[1, 2], $[3, 4]]␤»

[01:48] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2], [3, 4]]<>␤»

[01:48] <lizmat> m: my @matrix = [1,2],[3,4]; my @i = ^1; my @row = @matrix[@i]; say @row.perl  # should this flatten ?

[01:48] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$[1, 2]]␤»

[01:48] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2]]<>␤»

[01:48] <ShimmerFairy> lizmat: I want to say yes, because the subscript is returning multiple things

[01:48] <ShimmerFairy> m: my @a = [1,2,3,4]; say @a.perl

[01:48] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2, 3, 4]␤»

[01:48] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2, 3, 4]]<>␤»

[01:49] <ShimmerFairy> ^ GLR is more DWIM in that regard, btw

[01:49] <lizmat> ShimmerFairy: why would you do it that way?  why not my @a = 1,2,3,4?

[01:50] <ShimmerFairy> lizmat: because it's somewhat natural to encase a list in brackets. I found the "leave off the brackets" requirement in those places in Perl 6 was somewhat unnatural and took getting used to.

[01:52] <skids> Yes I think it's been "we want this to work because it would be too surprising if it didn't"

[01:52] <ShimmerFairy> So I think @matrix[0] not assigning how I expected is simply a bug, under 1-arg rule

[01:52] <skids> Anyway if https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9#file-glr-p6-L66 still holds, and I'm guessing it does, it is correct.

[01:55] <skids> I think that matrix[0] thing is because @matrix[0] is a 1-element list, gets iterated, and the $[1,2] assigned to the first slot.

[01:56] <lizmat> from a teaching point of view, I think it's hard to explain the difference between @a[1], @a[1,2] and @a[@i]

[01:56] <lizmat> especially if @i only has 1 element

[01:56] <ShimmerFairy> m: my @m = [1,2],[3,4]; say @m[0].perl;

[01:56] <GLRelia> rakudo-moar 769c5b: OUTPUT«$[1, 2]␤»

[01:56] <camelia> rakudo-moar 28faf1: OUTPUT«[1, 2]␤»

[01:56] <ShimmerFairy> m: my @m = [1,2],[3,4]; say @m[0].WHAT;

[01:56] <GLRelia> rakudo-moar 769c5b: OUTPUT«(Array)␤»

[01:56] <camelia> rakudo-moar 28faf1: OUTPUT«(Array)␤»

[01:57] <skids> I actually think the single item rule is logical, and was swayed by TimToady's framing of it.

[01:58] <ShimmerFairy> I don't think it'd be too hard to explain that @a[$x] behaves differently if it returns one thing or multiple (kinda like singular/plural in languages, perhaps)

[02:01] <skids> But I think the interaction with MMD is a bit of a wart:

[02:01] <skids> m: multi sub a (*@a) { "slurpy".say }; multi sub a ($a) { "one".say }; a(1); a(1,);

[02:01] <GLRelia> rakudo-moar 769c5b: OUTPUT«one␤one␤»

[02:01] <camelia> rakudo-moar 28faf1: OUTPUT«one␤one␤»

[02:01] <skids> when: my @a = [1,2],; @a.perl.say;

[02:02] <skids> m: my @a = [1,2],; @a.perl.say;

[02:02] <GLRelia> rakudo-moar 769c5b: OUTPUT«[$[1, 2]]␤»

[02:02] <camelia> rakudo-moar 28faf1: OUTPUT«[[1, 2]]<>␤»

[02:03] <lizmat> so, for the record: I'm not against breaking my @a = 1,2,3

[02:03] <skids> It would be a really tiny wart if the whole thing didn't need so much explaining in the first place.

[02:03] <lizmat> well, I think if we say () and [] do not flatten unless prefixed with |

[02:03] <lizmat> that's a simple rule

[02:04] <ShimmerFairy> that extra comma feels wrong to me in both examples.  .oO(didn't we get rid of Parcel?)

[02:04] <skids> I think the idea was that $ is the flattening-proofer.

[02:04] <skids> (or .item)

[02:06] <skids> Well, I could write 1,Slip() if it makes you happier :-)

[02:09] <lizmat> with my proposal, you wouldn't need an extra comma ever  :-)

[02:11] <ShimmerFairy> m: my @a = [[1,2]]; say @a.perl

[02:11] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2]␤»

[02:11] <camelia> rakudo-moar 28faf1: OUTPUT«[[[1, 2]]]<>␤»

[02:11] *** lizmat left
[02:12] <ShimmerFairy> I wasn't expecting it to flatten that much there

[02:14] <skids> Well, it is logically consistent at least.

[02:14] *** lizmat joined
[02:15] <ShimmerFairy> how so?

[02:16] <skids> The array constructor sees an iterable, unwraps it, then the assignment sees an iterable, and unwraps it.

[02:16] <ShimmerFairy> m: my @a = [[[1,2]]]; say @a.perl

[02:16] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2]␤»

[02:16] <camelia> rakudo-moar 28faf1: OUTPUT«[[[[1, 2]]]]<>␤»

[02:16] <skids> Where with [1,2], the outermost iterable absorbs the unwrap.

[02:18] <ShimmerFairy> I think @a = [[1,2]] not assigning [1,2] as one thing to @a is an error

[02:19] <skids> I don't think it is under the current GLR design.

[02:21] <skids> .oO(interesting duality: the $ that vaporizes to call methods directly on its contents is the very thing that stands rigid in the face of lists)

[02:24] *** noganex joined
[02:27] *** rurban left
[02:27] *** noganex_ left
[02:30] <skids> Well, it's consistent with the behavior of $$$$a :-)

[02:34] *** mjgardner left
[02:34] <lizmat> .tell ab6tract re http://irclog.perlgeek.de/perl6/2015-08-21#i_11096207 , .uniq looks like the Unix uniq command, but that actually works like .squish

[02:34] <yoleaux> lizmat: I'll pass your message to ab6tract.

[02:35] <lizmat> .tell abstract when that was pointed out, TimToady decided to rename .uniq to .unique to mark its difference from the uniq program

[02:35] <yoleaux> lizmat: I'll pass your message to abstract.

[02:35] <raiph> lizmat: what are the *downsides* to 1,2 is sugar for |(1,2) and (1,2) and [1,2] do not flatten unless prefixed with | ?

[02:36] <raiph> (cuz it sure sounds nice and simple)

[02:37] <lizmat> I cannot think of any apart from needing to change people's minds

[02:38] <lizmat> but I think *the* time to do is *now* during the GLR

[02:38] <lizmat> because many people will need to get used to GLR related stuff anyway in the coming weeks

[02:39] <raiph> lizmat: has it been proposed before and discussed by TimToady?

[02:39] <lizmat> perhaps, but then we didn't have prefix | to flatten

[02:40] <ShimmerFairy> If we tossed the one-arg rule, then 'for' would no longer be implemented simply as a map, for example

[02:41] <raiph> m: my @a = 1,2; for |@a { .say }

[02:41] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤2␤»

[02:41] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/daiIjBncDK␤Arg-flattening | is only valid in an argument list␤at /tmp/daiIjBncDK:1␤------> 3my @a = 1,2; for |7⏏5@a { .say }␤»

[02:43] <lizmat> fwiw, I couldlive with for |@a {}

[02:43] <lizmat> it makes the intent *very* clear

[02:43] <ShimmerFairy> But that wouldn't change the fact that for would have to go back to its uglier implementation

[02:43] <raiph> m: my @a = 1,[2]; for @a { .++.say }; for |@a { .++.say }; for @a,@a { .++.say }; for |@a,@a { .++.say }; for |@a,|@a { .++.say };

[02:43] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at /tmp/z1fISVTSQy:1␤␤»

[02:43] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/aGPnm7rpxe:1␤------> 3my @a = 1,[2]; for @a { .++.say }; for |7⏏5@a { .++.say }; for @a,@a { .++.say }; f␤Arg-flattening | is only valid in an argument list␤at /t…»

[02:44] <raiph> m: my @a = 1,[2]; for @a { .say }; for |@a { .say }; for @a,@a { .say }; for |@a,@a { .say }; for |@a,|@a { .say };

[02:44] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤2␤1␤2␤1 2␤1 2␤1␤2␤1 2␤1␤2␤1␤2␤»

[02:44] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/8790VmgV_7:1␤------> 3my @a = 1,[2]; for @a { .say }; for |7⏏5@a { .say }; for @a,@a { .say }; for |@a␤Arg-flattening | is only valid in an argument list␤at /tmp/…»

[02:46] <ShimmerFairy> Getting rid of the one-arg rule would introduce a lot of unwarranted noise, and make some things (e.g. C<for>) harder to implement, all for the sake of a particular opinion on "consistency"

[02:48] <lizmat> ShimmerFairy: could you give examples of unwarranted noise?  I'm open to be swayed and change my opinion :-)

[02:49] <ShimmerFairy> lizmat: everywhere you've typed | instead of single-arg is a place where I don't want to be forced to type it :)

[02:50] <ShimmerFairy> lizmat: I think of the Slip-ifying operator as a way of saying "this is part of the same list", e.g.  1,2,|@a,4  ("@a is part of this list, not an independent element")

[02:50] <ShimmerFairy> So requiring it for singular arguments feels silly

[02:51] <lizmat> ??

[02:51] <lizmat> ah, you mean for |@a

[02:52] <lizmat> well, I could also see "for @a {" as syntactic sugar for "for |@a {"

[02:52] <ShimmerFairy> basically, I vastly prefer the single arg rule over requiring Slip as a singular argument :)

[02:52] <lizmat> m: my @a  = 1,2,3; for @a, @a { .perl.say }

[02:52] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2, 3]␤[1, 2, 3]␤»

[02:52] <camelia> rakudo-moar 28faf1: OUTPUT«1␤2␤3␤1␤2␤3␤»

[02:52] <ShimmerFairy> lizmat: as I understand it, that's how it is in the non-glr 'for' already, and that's something jnthn and co. want to not have anymore.

[02:54] <lizmat> perhaps foreach @a,@a could be syntactic sugar for for |(@a,@a) 

[02:56] <skids> m: my @a = 1,2; say (|(@a,@a)).perl;

[02:56] <GLRelia> rakudo-moar 769c5b: OUTPUT«([1, 2], [1, 2])␤»

[02:56] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bA9MQc2d62␤Arg-flattening | is only valid in an argument list␤at /tmp/bA9MQc2d62:1␤------> 3my @a = 1,2; say (|7⏏5(@a,@a)).perl;␤»

[02:56] *** BenGoldberg left
[02:57] <lizmat> my @a = 1,2; say (|@a,|@a).perl

[02:58] <lizmat> m: my @a = 1,2; say (|@a,|@a).perl

[02:58] <GLRelia> rakudo-moar 769c5b: OUTPUT«(1, 2, 1, 2)␤»

[02:58] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/y4Hl0VwGja:1␤------> 3my @a = 1,2; say (|7⏏5@a,|@a).perl␤Arg-flattening | is only valid in an argument list␤at /tmp/y4Hl0VwGja:1␤------> 3my @a = 1,2; say (|@a…»

[02:58] <raiph> ShimmerFairy: If you prefer seeing something as independent, a singular thing, when given as a singular argument to a for, then why do you want it flattened?

[02:58] <lizmat> m: my @a = 1,2; say (|@a xx 3).perl

[02:58] <GLRelia> rakudo-moar 769c5b: OUTPUT«(1, 2, 1, 2, 1, 2).iterator␤»

[02:58] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/sc_ZzFl9OG␤Arg-flattening | is only valid in an argument list␤at /tmp/sc_ZzFl9OG:1␤------> 3my @a = 1,2; say (|7⏏5@a xx 3).perl␤»

[02:58] <ShimmerFairy> raiph: because if I say  for @a { }  , then obviously I want to loop over the elements of @a

[02:58] <lizmat> hmmm..

[02:58] <lizmat> m: my @a = 1,2; say (@a xx 3).perl

[02:58] <GLRelia> rakudo-moar 769c5b: OUTPUT«([1, 2], [1, 2], [1, 2]).iterator␤»

[02:58] <camelia> rakudo-moar 28faf1: OUTPUT«(1, 2, 1, 2, 1, 2)␤»

[02:59] <ShimmerFairy> raiph: like I said, I vastly prefer single-arg over requiring a bunch of extra | symbols :)

[02:59] <raiph> Earlier, you said, that in a list, you prefer that @a is an independent single thing unless you prefix it with |

[03:00] <ShimmerFairy> raiph: that's different from single-arg though

[03:00] <raiph> You say it is, and so it is, but I don't say it is, and so that vanishes :)

[03:01] <ShimmerFairy> for @a { single arg applies, loops +@a times }    for 1, @a { single arg doesn't, loops twice }    simple :)

[03:01] <raiph> Don't mind me too much though. I'm just admiring the view from lizmat's proposal. :)

[03:01] *** pierrot joined
[03:01] <skids> m: my @a = 1,2; say (|«(@a,@a)).perl;

[03:01] <GLRelia> rakudo-moar 769c5b: OUTPUT«␤The 'gimme' method was an internal method used by rakudo before the Great␤List Refactor.  The fact that you are seeing this message, means that you␤have code that was using that unsupported rakudo internal API.␤␤Please refactor this code using t…»

[03:01] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5y9MAonGeL␤Arg-flattening | is only valid in an argument list␤at /tmp/5y9MAonGeL:1␤------> 3my @a = 1,2; say (|7⏏5«(@a,@a)).perl;␤»

[03:02] <raiph> for @a { no special rule }    for 1, @a { no special rule }    for |@ { no special rule }       even simpler :)

[03:03] <ShimmerFairy> Well, I'm firmly in "single-arg" territory (as I understand most others are), and there's nothing you can really do to sway me :)  I find extra never-before-needed Slip coercions to be unnecessary for the sake of so-called "consistency"

[03:04] * ShimmerFairy has found recently that the "consistency" argument is pretty much always a terrible one, since everyone has a different idea on what that is

[03:05] <raiph> Indeed. I've consistently held that view since I didn't. But my argument is the consistency argument.

[03:05] <raiph> :)

[03:05] <raiph> er, s/is/isn't/

[03:06] <lizmat> lunch&

[03:06] *** lizmat left
[03:07] <ShimmerFairy> I personally much prefer the fact that  @a = [1,2,3]  DWIMs now, and that  for STUFF { }  is now literally just  STUFF.map: { }  (instead of jumping through hoops to pretend it is)

[03:08] *** amurf joined
[03:09] <raiph> m: my @a = |[1,2]; @a.elems.say

[03:09] <GLRelia> rakudo-moar 769c5b: OUTPUT«2␤»

[03:09] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Gv0ZaJ1dvJ␤Arg-flattening | is only valid in an argument list␤at /tmp/Gv0ZaJ1dvJ:1␤------> 3my @a = |7⏏5[1,2]; @a.elems.say␤»

[03:09] <raiph> m: my @a = [1,2]; @a.elems.say

[03:09] <GLRelia> rakudo-moar 769c5b: OUTPUT«2␤»

[03:09] <camelia> rakudo-moar 28faf1: OUTPUT«1␤»

[03:10] <raiph> m: my @a = 1,2; @a.elems.say

[03:10] <GLRelia> rakudo-moar 769c5b: OUTPUT«2␤»

[03:10] <camelia> rakudo-moar 28faf1: OUTPUT«2␤»

[03:10] <ShimmerFairy> raiph: Another tiny thing: you can still use | on single things if you want to under single-arg, but can't still use single-arg under required |  :P

[03:10] <raiph> ShimmerFairy: when you say "now", do you mean camelia or GLRelia?

[03:11] <ShimmerFairy> GLRelia ("now" design-wise, not main-branch-wise ☺)

[03:11] *** CQ_ joined
[03:12] <raiph> ShimmerFairy: would you be willing to call how things currently are on GLRelia

[03:12] <raiph> now?

[03:12] <ShimmerFairy> ?

[03:13] *** amurf left
[03:13] <raiph> ShimmerFairy: nvm

[03:13] *** CQ left
[03:14] *** CQ_ is now known as CQ

[03:14] <smls_> the single-arg rule doesn't change anything about  @a = [1,2,3]  now that [] no longer produces a containerized array, does it?

[03:15] <raiph> ShimmerFairy: under a "required | for flattened single args" rule, you can still use single args -- you just omit the "otherwise required" | :)

[03:15] <ShimmerFairy> smls_: I think it does, but admittedly I'm not sure

[03:16] <ShimmerFairy> I've made my point about single-arg by this point, so I don't think there's much worth in me talking more on it :)  I think I'll let the language designers have their turn, when they're next here.

[03:17] <smls_> @a = $[1,2,3]   is affected by the single-arg rule though. (And I'm not sure I would call that a victory for DWIM'iness.)

[03:18] <smls_> After all, $() is meant to explicitly say "treat this as a single item", yet here it is basically ignored.

[03:18] *** aborazmeh joined
[03:18] *** aborazmeh left
[03:18] *** aborazmeh joined
[03:21] <smls_> (Not arguing for repealing the single-arg rule; I don't really have a full picture of what DWIMs it gains and looses, so I'll trust TimToady & co. on it.)

[03:29] <raiph> m: my @a = 1,2; my @b = [3,4]; my @c = $[5,6]; for @a,@b,@c { .perl.say }

[03:29] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2]␤[3, 4]␤[$[5, 6]]␤»

[03:29] <camelia> rakudo-moar 28faf1: OUTPUT«1␤2␤[3, 4]␤Any␤Any␤»

[03:31] <dalek> roast/glr: c8ba40a | skids++ | S15-nfg/long-uni.t:

[03:31] <dalek> roast/glr: Update initializer to GLR behavior of xx

[03:31] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c8ba40ad15

[03:31] <raiph> m: my @a = (1,2); @a.perl.say

[03:31] <GLRelia> rakudo-moar 769c5b: OUTPUT«[1, 2]␤»

[03:31] <camelia> rakudo-moar 28faf1: OUTPUT«[1, 2]<>␤»

[03:32] <raiph> m: my @a = (1,2); @a.elems.say

[03:32] <GLRelia> rakudo-moar 769c5b: OUTPUT«2␤»

[03:32] <camelia> rakudo-moar 28faf1: OUTPUT«2␤»

[03:32] *** smls_ left
[03:34] <raiph> m: say (1,2).WHAT

[03:34] <GLRelia> rakudo-moar 769c5b: OUTPUT«(List)␤»

[03:34] <camelia> rakudo-moar 28faf1: OUTPUT«(Parcel)␤»

[04:13] *** lizmat joined
[04:20] *** kaare_ joined
[04:35] * lizmat drops a pin

[04:35] <raiph> m: my @jan = 1..31; my @feb = 1..29; for @jan,@feb { .elems.say }; for $@jan { .elems.say }

[04:35] <GLRelia> rakudo-moar 769c5b: OUTPUT«31␤29␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:35] <camelia> rakudo-moar 28faf1: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤31␤»

[04:36] <lizmat> that looks like a bug  :-)

[04:37] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for @jan.item { .elems.say }

[04:37] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:37] <camelia> rakudo-moar 28faf1: OUTPUT«31␤»

[04:38] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for [@jan] { .elems.say }

[04:38] <camelia> rakudo-moar 28faf1: OUTPUT«31␤»

[04:38] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:38] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for $[@jan] { .elems.say }

[04:38] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:38] <camelia> rakudo-moar 28faf1: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[04:40] <raiph> m: my @jan = 1..31; my @feb = 1..29; for [@jan] { .elems.say }

[04:40] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:40] <camelia> rakudo-moar 28faf1: OUTPUT«31␤»

[04:41] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for @jan[] { .elems.say }

[04:41] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:41] <camelia> rakudo-moar 28faf1: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:41] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for @jan[*] { .elems.say }

[04:41] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:41] <camelia> rakudo-moar 28faf1: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:41] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for [@jan[*]] { .elems.say }

[04:41] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:41] <camelia> rakudo-moar 28faf1: OUTPUT«31␤»

[04:42] <raiph> m: my $jan = 1..31; my $feb = 1..29; for $jan { .elems.say }

[04:42] <GLRelia> rakudo-moar 769c5b: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[04:42] <camelia> rakudo-moar 28faf1: OUTPUT«31␤»

[04:46] *** khw left
[04:56] *** azawawi joined
[04:56] <azawawi> hi

[04:56] <yoleaux> 12 Aug 2015 12:49Z <hoelzro> azawawi: I just wanted to share my experience on the matter.  Pod6 is a bit more complex than Pod, so adding support to GH could be somewhat difficult.  Not that you shouldn't try, of course =) For now I've been generating my README.md via Pod::To::Markdown

[04:57] *** azawawi left
[04:57] *** rangerprice left
[04:58] *** amurf joined
[05:02] *** amurf left
[05:11] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for @jan, { .elems.say }

[05:11] <camelia> rakudo-moar 28faf1: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/nCtWMFIfN_:1␤------> 3y @feb = 1..29; for @jan, { .elems.say }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/nCtWMFIfN_:1␤------> 3y @feb = 1..29…»

[05:11] <GLRelia> rakudo-moar 769c5b: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/ZLF3C6i_vk:1␤------> 3y @feb = 1..29; for @jan, { .elems.say }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/ZLF3C6i_vk:1␤------> 3y @feb = 1..29…»

[05:12] <lizmat> m: my @jan = 1..31; my @feb = 1..29; for (@jan,) { .elems.say }

[05:12] <GLRelia> rakudo-moar 769c5b: OUTPUT«31␤»

[05:12] <camelia> rakudo-moar 28faf1: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[05:12] *** lizmat left
[05:19] <dalek> roast/glr: e502eaf | skids++ | S05-modifier/counted.t:

[05:19] <dalek> roast/glr: Adjust dubious tests, per RT#125815 and due to GLRification

[05:19] <dalek> roast/glr: 

[05:19] <dalek> roast/glr: When I GLRified :nth and :x I made a couple changes to behavior

[05:19] <dalek> roast/glr: (sorry).  They were justified: the original code intended to

[05:19] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125815

[05:19] <dalek> roast/glr: die on :nth(-1) but for some reason did not (RT#125815). Now it does.

[05:19] <dalek> roast/glr: 

[05:19] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125815

[05:19] <dalek> roast/glr: Also, the * handling was applying 0-based semantics to a 1-based

[05:19] <dalek> roast/glr: value, so that was fixed.  Added a skipped test for a lone * which

[05:19] <dalek> roast/glr: is NYI on both nom and GLR.

[05:19] <dalek> roast/glr: 

[05:19] <dalek> roast/glr: Left a failing test that found one thing broken during

[05:19] <dalek> roast/glr: GLRification (s:0x// for some reason still substs.)

[05:19] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/e502eaf9cb

[05:19] *** lizmat joined
[05:20] <lizmat> jnthn about to begin Parallelism, Concurrency and Asynchrony in Perl 6  !   :-)

[05:27] <Woodi> any url in internet space for this talk ?

[05:30] <lizmat> haven't been able to determine that on the YAPC::Asia site... it's all Japanese to me  :-(

[05:33] <skids> lizmat++ very strange bug.

[05:35] <JimmyZ> https://pbs.twimg.com/media/CM-nWpKUYAQ4q1U.jpg:large # get ready to party

[05:37] *** llfourn joined
[05:38] <Woodi> oO(Is it organic? Hmm, butterflies-free would be not totally right on that one ;) )

[05:39] *** xinming left
[05:40] <lizmat> afaik, it's grapes  :-)

[05:41] *** xinming joined
[05:45] <dalek> nqp: cb4f525 | ShimmerFairy++ | src/NQP/ (2 files):

[05:45] <dalek> nqp: Enable use of $¢ in nqp

[05:45] <dalek> nqp: 

[05:45] <dalek> nqp: I'm personally still amazed it was this simple to do :) .

[05:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cb4f52508d

[06:07] *** cschwenz joined
[06:16] <dalek> rakudo/nom: edffe05 | ShimmerFairy++ | src/Perl6/ (2 files):

[06:16] <dalek> rakudo/nom: Enable use of $¢ in grammars

[06:16] <dalek> rakudo/nom: 

[06:16] <dalek> rakudo/nom: Unfortunately only works inside regex/token/rules, bare regexes (like

[06:16] <dalek> rakudo/nom: $foo ~~ /bar/) don't get the right $¢ . I've tried everything to fix

[06:16] <dalek> rakudo/nom: this, but the solution is apparently not going to be that simple.

[06:16] <dalek> rakudo/nom: 

[06:16] <dalek> rakudo/nom:     my token foo {AB {say $¢.pos} C}; "ABC" ~~ /<&foo>/; # says '2'

[06:16] <dalek> rakudo/nom:     "ABC" ~~ /AB {say $¢.pos} C/;                        # says 'Nil'

[06:16] <dalek> rakudo/nom: 

[06:16] <dalek> rakudo/nom: Closest I got was manually removing $¢ from $past in regex_coderef after

[06:16] <dalek> rakudo/nom: qbuildsub (and since qbuildsub will put a $¢ in there if you don't,

[06:16] <dalek> rakudo/nom: better to put one in there you could more reliably remove afterward),

[06:16] <dalek> rakudo/nom: but then eval'd regexes, e.g. EVAL('$foo ~~ /bar/'), complain about not

[06:16] <dalek> rakudo/nom: being able to resolve lexical $¢ .

[06:16] <dalek> rakudo/nom: 

[06:16] <dalek> rakudo/nom: The best I can guess is that the bare regexes pass a clean slate for the

[06:16] <dalek> rakudo/nom: $block arg of 'regex_coderef', instead of the popped lexpad

[06:16] <dalek> rakudo/nom: rule/token/regex gives, but I don't know how exactly that affects

[06:16] <dalek> rakudo/nom: things, much less how to fix the issue based on that (if it's the source

[06:16] <dalek> rakudo/nom: of the problems).

[06:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/edffe05088

[06:17] <cschwenz> Are the file test operators in Perl6 effectively the same as Perl 5's?  That is, I notice there is $path.d, $path.f, and $path.l .  Is there $path.p, $path.S, $path.b, $path.c, and $path.t as well?

[06:18] <dalek> roast/glr: 389b92a | skids++ | S05-modifier/counted-match.t:

[06:18] <dalek> roast/glr: More test corrections as per commit e502eaf9

[06:18] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/389b92a69c

[06:19] <ShimmerFairy> cschwenz: We have rwxoRWXOeszfdlLpSbcugk , according to http://design.perl6.org/S32/IO.html#File_test_methods

[06:19] <ShimmerFairy> cschwenz: although they are explicitly not "operators" anymore, but rather methods :)

[06:21] <cschwenz> sorry, was a bit loose with my terms.  was asking because http://docs.perl6.org/type/IO::Path#File_Test_operators only documents a subset of what Perl6 actually has.

[06:23] <skids> IO docs are probably behind as the newio branch is unmerged and has been rather neglected, except by lizmat++

[06:24] <ShimmerFairy> cschwenz: no worries, I just wanted to make sure you were aware of the fact they aren't operators in P6 :)

[06:24] *** lizmat left
[06:25] <cschwenz> :-)

[06:25] <ShimmerFairy> (by the way, if anyone knows what the issue with $¢ in bare regexes is, _please_ let me know. It works in NQP, so I'd love to know what P6 is doing to complicate things :P)

[06:26] <Woodi> skids: maybe you know what is a scope or plan for newio branch ? or maybe it is "make what synopses say" ?

[06:26] *** bin_005 left
[06:26] <skids> I don't know much, except that IIRC there is also a newio branch in the design docs repo.

[06:27] <ShimmerFairy> Is there any draft work on what newio covers? I don't think I ever heard what it was about overall. (But improving a part of P6 is something I'm always up for, so I'm interested ☺)

[06:28] <skids> lizmat merges nom into a branch occasionally, but has expressed that it is a chore and inaction on it is a bummer.

[06:28] *** bin_005 joined
[06:30] <Woodi> btw. what is 'nom' ?? it was a "rewrite is here" once but I have no idea what it is in 2014/2015 :)

[06:30] <FROGGS> .tell lizmat Ups, I just realized that it makes tests pass, that's why... and I havn't seen the revert, even not in the history of the affected file

[06:30] <yoleaux> 01:18Z <lizmat> FROGGS: I'm curious as to why you applied 9f581101ad to glr, when I reverted it later in nom

[06:30] <yoleaux> FROGGS: I'll pass your message to lizmat.

[06:30] <skids> Woodi: it is the branch from which releases have been cut up until now.

[06:31] <skids> It was a major improvement back when it was made (New Object Model).  Now there is glr, which is another giant refactor, but is not ready for releases to be cut from quite yet.

[06:32] <Woodi> so it is like "sid" in Debian ? :) current unstable or main dev branch ? 

[06:32] <dalek> roast/glr: b0a61c7 | (David Warring [email@hidden.address] | integration/advent2009-day21.t:

[06:32] <dalek> roast/glr: added flat() to advent2009-day21.t

[06:32] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b0a61c7782

[06:35] <skids> Woodi: nom is about halfway between "stable/testing", and glr is more like "sid".

[06:36] <skids> Or well, maybe nom is sid and glr is "volatile" :-)

[06:39] <skids> Oh well, I guess volatile was less unstable than unstable.

[06:43] <Woodi> skids: it is good to know which names are "stable" part of infrastructure :)

[06:44] <skids> there are certainly a lot of branches :-)

[06:45] <ShimmerFairy> Of course, now that I have $¢ as a shorthand for $/.CURSOR, I'm wondering what it would be like to have ¢<subrule> instead of $<subrule>.CURSOR  :P

[06:46] <skids> Doesn't Cursor already have keys for another purpose?

[06:48] <ShimmerFairy> m: "ABC" ~~ /$<subrule>=[AB] {say $/.CURSOR<subrule>}/

[06:48] <GLRelia> rakudo-moar 769c5b: OUTPUT«postcircumfix:<{ }> not defined for type Cursor␤  in block <unit> at /tmp/4rnMPnVwHs:1␤␤Actually thrown at:␤  in block <unit> at /tmp/4rnMPnVwHs:1␤␤»

[06:48] <camelia> rakudo-moar 28faf1: OUTPUT«postcircumfix:<{ }> not defined for type Cursor␤  in block <unit> at /tmp/Chfdq5KL53:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Chfdq5KL53:1␤␤»

[06:48] <ShimmerFairy> skids: apparently the key postcircumfix isn't even defined, so I guess not?

[06:52] <ShimmerFairy> skids: anyway, my imagining was that ¢<subrule> would coerce to "capture/cursor context" in the same way that @<subrule> lets you loop over all the <subrule> captures in $/

[06:56] <ShimmerFairy> It's funny, but it wasn't until I started working on this pod parser (and particularly my own custom grammar error reporter) that I've come to realize how Cursors are just as important as Matches. So now the idea of a ¢ sigil for captures (or at least, cursors) seems a bit more useful to me, for example :)

[07:01] *** rindolf joined
[07:01] <skids> Yeah Cursor has been hiding in obscurity for all but the elite wizards for too long :-)

[07:03] <ShimmerFairy> skids: I personally think the CURSOR/MATCH flipping you can do is pretty neat, and shows off how their two sides of the same coin :)

[07:03] <ShimmerFairy> *they're

[07:04] <dalek> rakudo/glr: bd5cfcb | (Stefan Seifert)++ | src/core/Range.pm:

[07:04] <dalek> rakudo/glr: Fix off-by-one error in general Range iterator

[07:04] <dalek> rakudo/glr: 

[07:04] <dalek> rakudo/glr: We always skipped the first element.

[07:04] <dalek> rakudo/glr: Noticed by dwarring++

[07:04] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/bd5cfcb0f2

[07:05] <nine> 148/1047 spec test files failing. That off-by-one there was the reason why my Range iterator implementation did not have more impact yesterday :)

[07:05] <yoleaux> 21 Aug 2015 21:46Z <laben> nine: good that there is a plan forward for that, i guessed it would be something like that :)

[07:07] <ShimmerFairy> nine++ # how many more times we gotta do this before you're ten ? :)

[07:11] <FROGGS> nine: I'll probably will have a lot of sparetime from today lunchtime to Tuesday afternoon... hopefully we can get the number of failing test files down to a minimum :o)

[07:12] <skids> I knocked off two or three tonight, and brought a couple more down to only a test or two failing.

[07:12] <ShimmerFairy> .oO(A non-nonzero minimum, one would hope :P)

[07:12] <nine> FROGGS: that sounds great!

[07:13] <nine> skids++

[07:13] *** rindolf left
[07:13] <skids> (probably they are included in that last count though)

[07:15] <skids> I suspect a good number hinge on List ~~ List.

[07:16] <skids> But that's just a hunch.

[07:17] <CQ> where is the list of failing tests?

[07:18] <FROGGS> CQ: here is one wich is off by one: https://gist.github.com/FROGGS/87ab95fab488b9e70f94

[07:18] *** rurban joined
[07:22] <skids> easy fix for someone with a bit: grep/first/etc sub forms need their slurpies lol-ed.

[07:23] <skids> Must sleep now.

[07:23] *** skids left
[07:28] <ShimmerFairy> Am I right in thinking of worries/sorrows/panics as such?: "worry" -> like 'warn', just notes potential difficulties, "sorrow" -> like 'fail', will cause parser to fail but execution can go on for some time, "panic" -> like 'die', immediate end to the parser

[07:29] *** aborazmeh left
[07:30] *** aborazmeh joined
[07:30] *** aborazmeh left
[07:30] *** aborazmeh joined
[07:37] *** lizmat joined
[07:42] *** lizmat left
[07:44] *** lizmat joined
[07:47] <dalek> rakudo/glr: a20db8f | (Stefan Seifert)++ | src/core/Range.pm:

[07:47] <dalek> rakudo/glr: Fix another off-by-one error in general Range iterator

[07:47] <dalek> rakudo/glr: 

[07:47] <dalek> rakudo/glr: 1.9 .. 3.5 should produce 1.9, 2.9. We missed the latter because we compared

[07:47] <dalek> rakudo/glr: with <= 2.5. So instead of calculating an end point, just use $!excludes-max

[07:47] <dalek> rakudo/glr: to decide whether to use < or <= for comparison.

[07:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a20db8fc28

[07:47] *** rindolf joined
[07:48] <nine> The only remaining range.t failures are because @a[^5] really does @a[(^5).Int]. I wonder where the code for array subscript with multiple values actually is...

[07:51] <nine> Ah, in array_slice.pm

[07:54] <dalek> rakudo/glr: 40079e8 | lizmat++ | src/core/Cool.pm:

[07:54] <dalek> rakudo/glr: nqp::unbox_i should really check for bigints

[07:54] <dalek> rakudo/glr: 

[07:54] <dalek> rakudo/glr: This reverts commit 9f581101adea819486c9e77117db2309f792bb47.

[07:54] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/40079e8672

[07:55] <lizmat> nine: that's a nest of snakes...  :-)

[07:55] <yoleaux> 06:30Z <FROGGS> lizmat: Ups, I just realized that it makes tests pass, that's why... and I havn't seen the revert, even not in the history of the affected file

[07:55] <lizmat> the Range handling in array_slice

[07:56] <nine> lizmat: it feels like a multi dispatch error

[07:58] <JimmyZ> what does  unbox_i return if it is  bigint?

[07:58] <nine> m: my @a = 1,2,3; my $b = [1,2]; say @a[$b];

[07:58] <GLRelia> rakudo-moar 40079e: OUTPUT«3␤»

[07:58] <camelia> rakudo-moar edffe0: OUTPUT«3␤»

[07:59] *** darutoko joined
[07:59] <JimmyZ> m: my @a = 1,2,3; say @a[1,2]

[07:59] <GLRelia> rakudo-moar 40079e: OUTPUT«2 3␤»

[07:59] <camelia> rakudo-moar edffe0: OUTPUT«2 3␤»

[07:59] <nine> m: my @a = 1,2,3; my @b = [1,2]; say @a[@b];

[07:59] <GLRelia> rakudo-moar 40079e: OUTPUT«2 3␤»

[07:59] <camelia> rakudo-moar edffe0: OUTPUT«3␤»

[07:59] <nine> m: my @a = 1,2,3; my @b = 1,2; say @a[@b];

[07:59] <GLRelia> rakudo-moar 40079e: OUTPUT«2 3␤»

[07:59] <camelia> rakudo-moar edffe0: OUTPUT«2 3␤»

[08:00] <lizmat> m: my $a = 2**65; use nqp; say nqp::unbox_i($a)

[08:00] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[08:00] <GLRelia> rakudo-moar 40079e: OUTPUT«0␤»

[08:03] *** virtualsue joined
[08:05] *** domidumont joined
[08:05] <lizmat> JimmyZ: the idea is that nqp::unbox_i should throw an exception when trying to unbox a bigint when it cannot fit into a native

[08:07] <lizmat> that fixes a whole class of gigo RT's

[08:09] *** domidumont left
[08:09] <nine> But would also make every code dealing with ints slow :/

[08:10] *** domidumont joined
[08:13] <nine> Oh, it's only slicing a Range that's still broken. Slicing Lists with Ranges works as advertised

[08:14] <lizmat> nine: if it's done in C, it wouldn't

[08:14] <ShimmerFairy> would it really though? Couldn't you just check the number of limbs for "too big" ?

[08:15] *** espadrine joined
[08:15] <ShimmerFairy> And if limbs aren't divisible into an integral number of native ints, you would then just have to check the "maybe limb" for its value if it's the most significant limb, no?

[08:15] <lizmat> nine: what ShimmerFairy said

[08:17] <lizmat> m: my @a = ^Inf; say @a[3..*]  # this should probably be catchable

[08:18] <GLRelia> rakudo-moar 40079e: OUTPUT«(timeout)»

[08:18] <camelia> rakudo-moar edffe0: OUTPUT«(timeout)»

[08:19] *** xinming left
[08:22] *** xinming joined
[08:22] <nine> lizmat: I doubt it

[08:23] <nine> lizmat: we replaced infinite with is-lazy. But lazyness does not always equal infinity (think .lines).

[08:23] <lizmat> ah, good point

[08:23] <lizmat> you're right

[08:26] <nine> m: (1..5)[1, 2]

[08:26] <GLRelia> rakudo-moar 40079e: ( no output )

[08:26] <camelia> rakudo-moar edffe0: ( no output )

[08:26] <nine> m: say (1..5)[1, 2]

[08:26] <GLRelia> rakudo-moar 40079e: OUTPUT«2 3␤»

[08:26] <camelia> rakudo-moar edffe0: OUTPUT«2 3␤»

[08:28] <dalek> rakudo/glr: a52518d | (Stefan Seifert)++ | src/core/Range.pm:

[08:28] <dalek> rakudo/glr: Implement EXISTS-POS for Range

[08:28] <dalek> rakudo/glr: 

[08:28] <dalek> rakudo/glr: Fixes (1..10)[^5] giving only one result instead of 5.

[08:28] <dalek> rakudo/glr: Reason was that the POSITIONS implementation filters positions by EXISTS-POS

[08:28] <dalek> rakudo/glr: result. We inherited that from Any which always returns False.

[08:28] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a52518db85

[08:28] <nine> range.t passes now :)

[08:29] *** KCL_ joined
[08:29] <nine> 146 to go :)

[08:30] <lizmat> nine++

[08:32] *** KCL left
[08:34] *** aborazmeh left
[08:36] *** amurf joined
[08:37] <jdv79> how come we have perl6 wine but not beer or soda or some other consumable?

[08:39] <lizmat> because the wind is from the town of Perl

[08:39] <lizmat> and there are no breweries there ?

[08:39] <lizmat> *wine

[08:40] <nine> Fun fact: doing a simple s/Parcel/List/g on parcel.t makes it pass all but 3 tests. I'm inclined to commit that :)

[08:40] <jdv79> oh, right.  the town.  cool.

[08:40] <nine> And rename to list.t

[08:40] <lizmat> nine: please do!

[08:40] *** amurf left
[08:40] <lizmat> don't forget t/spectest.data

[08:40] <lizmat> :-)

[08:41] <dalek> roast/glr: df22323 | (Stefan Seifert)++ | S02-types/ (2 files):

[08:41] <dalek> roast/glr: s/Parcel/List/g to reappropriate Parcel's tests for List

[08:41] <dalek> roast/glr: 

[08:41] <dalek> roast/glr: Parcel is gone, List took its place. There may be a couple usefull tests still

[08:41] <dalek> roast/glr: in S02-types/parcel.t, so just change it into a list.t

[08:41] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/df2232315a

[08:42] <dalek> rakudo/glr: 2ebfe4d | (Stefan Seifert)++ | t/spectest.data:

[08:42] <dalek> rakudo/glr: parcel.t is now list.t

[08:42] <dalek> rakudo/glr: 

[08:42] <dalek> rakudo/glr: Thanks to lizmat++ for the reminder!

[08:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2ebfe4d3b4

[08:43] <jdv79> whatsup with having both META.info and META6.json?

[08:43] <nine> m: my @a = {:a(1), :b(2)}; say @a.perl; # this worries me still. I'm not sure the single arg rule should extend to Hashes, even when they are Iterable

[08:43] <GLRelia> rakudo-moar a52518: OUTPUT«[:a(1), :b(2)]␤»

[08:43] <camelia> rakudo-moar edffe0: OUTPUT«[{:a(1), :b(2)}]<>␤»

[08:45] <nine> .tell jnthn should the single arg rule really extend to Hashes just because they do Iterable? my @a = {:a(1), :b(2)}; gives [:a(1), :b(2)] and the same happens for sub calls

[08:45] <yoleaux> nine: I'll pass your message to jnthn.

[08:52] *** bin_005 left
[08:53] <nine> No I really can't live with Hashes flattening like that. I can't imagine any user expecting that.

[08:55] <lizmat> m: my @a = ^10; for $@a { .say }   # this worries me more

[08:55] <camelia> rakudo-moar edffe0: OUTPUT«0 1 2 3 4 5 6 7 8 9␤»

[08:55] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[08:56] <lizmat> m: my @a = ^10; for $@a { .WHAT.say } 

[08:56] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤(Int)␤»

[08:56] <camelia> rakudo-moar edffe0: OUTPUT«(Array)␤»

[08:56] <nine> lizmat: why would you use for with a single item and a single iteration?

[09:00] *** lizmat left
[09:00] <nine> lizmat: I got cought countless times trying to iterate over an array ref with foreach in Perl 5. I've never written a for with just one iteration in mind. The single arg rule does make sense. Especially considering for foo() { } when foo() returns an array. It should not matter if that array has become itemized on the way. The intent is clearly to iterate over the array.

[09:03] <ShimmerFairy> nine: I wonder if there could be a "Iterable but not Associative" rule, or some other way to indicate objects that _can_ be iterated, but usually aren't, for things like @a = {one => "hash"}

[09:04] <nine> ShimmerFairy: yes, that's what I'm thinking. I'd create a role like IterableList does Iterable and change the single arg rule to apply to IterableList instead of Iterable.

[09:04] <nine> That would be a trivial fix. I'd just like to have some confirmation from people more involved with the language design :)

[09:05] <ShimmerFairy> PrimarilyIterable and either SecondarilyIterable or PrimarilyRandomAccess ? :P

[09:06] <ShimmerFairy> nine: actually,  for %hash { }  would expect to iterate the hash, so I'm not sure the change is that simple

[09:06] <nine> Well, for could still stick to Iterable. Of course that somewhat muddles the semantics again :/

[09:06] <nine> So, I'm out. Off to spend a couple hours in this: http://segelflieger-linz.at/static/1/7/8/113/image/D-KFMF.jpg :)

[09:07] <ShimmerFairy> also, remember that  for $one-item { }  should probably be written as  given $one-item { }  , esp. considering  $one-item.map()  makes no sense :)

[09:08] *** domidumont left
[09:09] *** domidumont joined
[09:12] *** rurban_ joined
[09:21] <jdv79> m: sub foo ($a? where * ~~ /<[a..z]>/) {}; foo()

[09:21] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«Use of uninitialized value of type Any in string context  in whatevercode  at /tmp/PYjq9MXNlx:1␤Use of uninitialized value of type Any in string context  in whatevercode  at /tmp/PYjq9MXNlx:1␤Constraint type check failed for parameter '$a'␤  in sub f…»

[09:21] <camelia> rakudo-moar edffe0: OUTPUT«Use of uninitialized value of type Any in string context  in whatevercode  at /tmp/NGonuB8KKq:1␤Use of uninitialized value of type Any in string context  in whatevercode  at /tmp/NGonuB8KKq:1␤Constraint type check failed for parameter '$a'␤  in sub f…»

[09:21] <jdv79> what is a better way?

[09:21] *** domidumont left
[09:22] <jdv79> i thought the thunk would only fire if the arg was passed

[09:22] <jdv79> since its optional

[09:23] <moritz> it also validates the default value (which is Any)

[09:23] <moritz> so you can write  $a? where { $a === Any || $a ~~ ... }

[09:24] <jdv79> i can see that it does ^H

[09:24] <jdv79> is there a good reason?

[09:24] *** RabidGravy joined
[09:25] <jdv79> it seems more verbose than a perl

[09:25] <jdv79> -ish thing

[09:26] *** rurban left
[09:30] *** leont joined
[09:41] *** rurban joined
[09:41] <jdv79> who do i talk to about cpan?

[09:42] <jdv79> i just tried to upload a p6 dist and it failed

[09:42] <ShimmerFairy> It's not all set up as of yet, as far as I know.

[09:42] <jdv79> because that p5 dist already exists

[09:42] <jdv79> liz said a META6.json would differentiate it 

[09:42] <jdv79> either i did it wrong or it does not

[09:44] <ShimmerFairy> That's the plan, but like I said I don't think it's all been set up yet (and in any case, there aren't any tools that could get a P6 module from CPAN properly atm)

[09:47] <jdv79> .tell lizmat what gives?:  https://gist.github.com/anonymous/83b0780b59c40e77184e

[09:47] <yoleaux> jdv79: I'll pass your message to lizmat.

[09:48] *** lizmat joined
[09:51] <jdv79> ShimmerFairy: well, I'd think getting a dist on cpan would be a pre-req to pulling it off:)

[10:01] <lizmat> jdv79: I guess we only tried it with distributions that are not registered

[10:01] <yoleaux> 09:47Z <jdv79> lizmat: what gives?:  https://gist.github.com/anonymous/83b0780b59c40e77184e

[10:02] <moritz> m: my @a = ('o', "k 3 - print with multiple parameters\n"); print @a

[10:02] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«o k 3 - print with multiple parameters␤»

[10:02] <camelia> rakudo-moar edffe0: OUTPUT«ok 3 - print with multiple parameters␤»

[10:02] *** cschwenz left
[10:02] <moritz> is that expected?

[10:03] <lizmat> did you expect newlines between them?

[10:03] <lizmat> ah, the space

[10:03] <lizmat> hmmm....

[10:03] <moritz> lizmat: no, a test (S16-io/print.t) doesn't expect the space

[10:03] <lizmat> no that is not expected...

[10:03] <ShimmerFairy> moritz: for 'say' it's been that way forever, not sure about print

[10:04] <lizmat> print shouldn't put anything inbetween

[10:04] <moritz> ShimmerFairy: well, say uses .gist on its argument

[10:04] <lizmat> m: my @a = ('o', "k 3 - print with multiple parameters\n"); print @a.Str

[10:04] <camelia> rakudo-moar edffe0: OUTPUT«o k 3 - print with multiple parameters␤»

[10:04] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«o k 3 - print with multiple parameters␤»

[10:04] <jdv79> its not registered is it?

[10:04] <jdv79> its just conflicting

[10:04] <moritz> lizmat: ah, print is implemented as two multis, (\x) and (*@args is rw)

[10:04] <jdv79> how do we get that addressed?

[10:05] <lizmat> I hope to see Andreas next week at the SPW

[10:05] <moritz> lizmat: I guess it dispatches to the \x candidate, which calls .Str

[10:05] <lizmat> m: my @a = ('o', "k 3 - print with multiple parameters\n"); print |@a

[10:05] <GLRelia> rakudo-moar 2ebfe4: OUTPUT«ok 3 - print with multiple parameters␤»

[10:05] <camelia> rakudo-moar edffe0: OUTPUT«ok 3 - print with multiple parameters␤»

[10:06] <ShimmerFairy> lizmat: btw, would PAUSE know that Perl 6 allows conflicting names on upload? (That is, does it consider author and version to disambiguate.) Admittedly I don't know under what conditions CPAN complains about duplicate packages :)

[10:06] <moritz> ShimmerFairy: I guess you have to ask FROGGS, who implemented p6 part of PAUSE

[10:06] <ShimmerFairy> ok :)

[10:07] <jdv79> FROGGS: ^ ?

[10:07] <lizmat> ShimmerFairy: CPAN is basically a dropbox

[10:07] <jdv79> author is in the dir strcut already and v is in the filename

[10:08] <lizmat> it doesn't care about anything that an author uploads, except that a file with name A can only be uploaded once

[10:08] <jdv79> *structure

[10:08] <ShimmerFairy> lizmat: and that's because of P5's module name limitations, if I'm not mistaken?

[10:08] <moritz> ah, it's only the indexer that cares about duplicates

[10:08] <leont> Yes

[10:08] <lizmat> it's the P5 module list that people often mistake for CPAN

[10:08] <ShimmerFairy> oh, so a P6 module shouldn't be touching the existing P5 indexer in the first place then?

[10:09] <leont> The module list has been deprecated, it's just the index now

[10:09] <lizmat> the long name of a module on CPAN includes the author and version already

[10:09] <leont> lizmat: s/module/distribution/

[10:09] <lizmat> leont: whatever, it's a P5 specific thing

[10:10] <lizmat> :-)

[10:10] <ShimmerFairy> lizmat: so IIUC, it's the P5 module indexer that complains on duplicate names, and a P6 module thus shouldn't be considered by that indexer in the first place. Right?

[10:11] <moritz> right.

[10:11] <lizmat> right

[10:11] <ShimmerFairy> alright :)

[10:12] <jdv79> i guess need a p6 indexer implemented and pause updated

[10:12] <jdv79> sounds like FROGGS is best setup to do taht

[10:12] <jdv79> if he's avail

[10:12] <FROGGS> ShimmerFairy: it does

[10:13] <FROGGS> ShimmerFairy: p5's PAUSE upload thingy only considers package name and a version that must be greater than the one before

[10:13] <leont> Yeah, I made that point a few days ago

[10:13] <ShimmerFairy> So I guess jdv79's problem is that the upload program he used didn't send it to the P6 indexer for whatever reason, if my guesses are correct?

[10:13] <FROGGS> ShimmerFairy: the p6's upload thingy does not care, but just registers all it gets

[10:14] <jdv79> i used hte http upload form at pause

[10:14] <FROGGS> jdv79: and the dist contained a META6.json?

[10:14] <ShimmerFairy> make sense, considering our :auth and :ver adverbs on modules take care of duplications :)

[10:14] <jdv79> yes

[10:14] <jdv79> see above 

[10:15] <jdv79> https://gist.github.com/anonymous/83b0780b59c40e77184e

[10:16] <ShimmerFairy> oh, could it be the META.info that's also in there, perhaps?

[10:16] <jdv79> i think panda need that, no?

[10:17] <jdv79> i just copied that to META6.json - maybe that's wrong?

[10:17] *** Ven joined
[10:18] <jdv79> is it possible to set a ro attr created in one role from another

[10:18] <moritz> jdv79: I hope not

[10:18] <FROGGS> jdv79: it might be possible that the basename of the file is checked before the p6 guessing happens

[10:19] <jdv79> moritz: why not?  if they are composed into the same class seems plausible.

[10:20] <jdv79> FROGGS: huh?  the fs layout of a p6 dist is different?  is that what you mean?

[10:20] <FROGGS> jdv79: no

[10:21] <FROGGS> jdv79: "Duplicate entry 'J/JD/JDV/Data-Selector-1.00.tar.gz' for key 'PRIMARY'" this implies you uploaded that tarball as a p5 dist already

[10:21] <ShimmerFairy> jdv79: I think he means it's possible that the P5 indexer checks for duplicates before the "Is it P5 or P6?" part happens

[10:21] <jdv79> yes, that's part of the point.

[10:21] <moritz> jdv79: IMHO attributes should be private to a role, and stay that way; otherwise they aren't composable (in the CS lingo sense, not in the Perl 6 role composition sense)

[10:21] <jdv79> a p5 and p6 dist of the "same name" should work

[10:21] <FROGGS> jdv79: so, rename the tarball and upload again I'd say

[10:22] <ShimmerFairy> FROGGS: would there be no way to make the P6 check happen beforehand, in the future?

[10:22] <jdv79> that defeats the entire purpose

[10:22] <jdv79> no

[10:22] <FROGGS> ShimmerFairy: look at the code of PAUSE :o)

[10:22] <jdv79> the check for p5/p6 needs to be moved up front then

[10:22] <ShimmerFairy> oh, it's somewhere to view? I'll look :)

[10:24] <jdv79> moritz: hmm, ok.  i have a role that does shared construction

[10:24] <jdv79> maybe i'll move it to a base class

[10:24] <FROGGS> look: https://github.com/andk/pause/blob/master/lib/PAUSE/mldistwatch.pm#L327

[10:24] <jdv79> it was neat that it worked mostly though

[10:24] <jdv79> shame not 100%

[10:25] <FROGGS> also this: https://github.com/andk/pause/blob/master/lib/PAUSE/dist.pm#L196

[10:26] <jdv79> hmm

[10:28] <FROGGS> I'm not saying it is impossible to move the check upfront, I just say it is not easy

[10:29] <ShimmerFairy> FROGGS: interesting that mail_summary is precluded for 6 (IIUC from the PAUSE help page that would be the immediate confirmation and/or subsequent indexing email?)

[10:30] <leont> pause isn't easy in general, it is one of the oldest perl programs in critical use

[10:30] <ShimmerFairy> FROGGS: could name duplication cause an issue like this to pop up for people who've never uploaded a P5 module before?

[10:31] <FROGGS> ShimmerFairy: if you reupload the same named tarball with only the content changed... most likely

[10:32] <ShimmerFairy> It would be really nice if P6 packages were diverted before any P5-specific components got started :/

[10:32] <FROGGS> leont: critical as in not more than a dozen uploads a day, right?

[10:32] <FROGGS> ShimmerFairy: that's hard given that huge spaghetti codebase

[10:33] <leont> critical as in "if it falls on its mouth we're actually having problems"

[10:33] <ShimmerFairy> But very important too

[10:33] <FROGGS> ShimmerFairy: and it is nearly impossible to test changes locally

[10:33] <jdv79> well.  regardless it needs to be changed

[10:33] <jdv79> :)  put bluntly

[10:33] <FROGGS> :o)

[10:33] <jdv79> i'll peek later

[10:33] <jdv79> but the cleaning lady is kicking me out of my room atm

[10:34] <dalek> rakudo/glr: 5c0c7bc | moritz++ | src/core/io_operators.pm:

[10:34] <dalek> rakudo/glr: Remove print(\x) multi candidate

[10:34] <dalek> rakudo/glr: 

[10:34] <dalek> rakudo/glr: fixes S16-io/print.t, which otherwise fails due to extra spaces from print(@a)

[10:34] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5c0c7bcfe0

[10:34] <ShimmerFairy> FROGGS: I can see the code's hard, since it's difficult to read (though that's not much with my P5 lack-of-knowledge :P), but regardless I think it's incredibly important to keep P6 modules away from irrelevant (P5-only) parts of PAUSE/CPAN

[10:35] <FROGGS> ShimmerFairy: I see you point, and I did my best to do that

[10:35] <ShimmerFairy> FROGGS++ for getting CPAN and PAUSE to work with P6 modules in the first place, anyway :)

[10:37] <FROGGS> thanks :o)

[10:37] <FROGGS> lizmat: does t/spec/S32-str/index.t (unbox_i and bigints) still fail on nom? or did you find a better fix when reverting? (https://github.com/rakudo/rakudo/commit/40079e8672087486b864c25f3a38c7b767ae3906)

[10:39] <FROGGS> m: use nqp; say nqp::unbox_i(-1e35)

[10:39] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/XlrU63D3i2:1␤␤»

[10:39] <camelia> rakudo-moar edffe0: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/uTri95xy3Y:1␤␤»

[10:40] <FROGGS> m: use nqp; say nqp::index(nqp::unbox_s("foo"), nqp::unbox_s("o"), nqp::unbox_i(-1e35))

[10:40] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/Mf96kjqT3a:1␤␤»

[10:40] <camelia> rakudo-moar edffe0: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/FS_wGfOXDf:1␤␤»

[10:41] <ShimmerFairy> m: say (-1e35).WHAT

[10:41] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«(Num)␤»

[10:41] <camelia> rakudo-moar edffe0: OUTPUT«(Num)␤»

[10:41] <ShimmerFairy> m: use nqp; say nqp::unbox_i(-1e35.Int)

[10:41] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«0␤»

[10:41] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[10:41] <JimmyZ> m: my @a = 'o', 'k'; say @a;

[10:41] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«o k␤»

[10:41] <camelia> rakudo-moar edffe0: OUTPUT«o k␤»

[10:42] <JimmyZ> m: my @a = 'o', 'k'; print @a;

[10:42] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«ok»

[10:42] <camelia> rakudo-moar edffe0: OUTPUT«ok»

[10:42] <dalek> roast/glr: 78cff17 | moritz++ | S03-metaops/reduce.t:

[10:42] <dalek> roast/glr: Fix three subtests in reduce.t

[10:42] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/78cff1778d

[10:43] <JimmyZ> moritz: so we need to remove the say/note version too? about \x :)

[10:43] <FROGGS> m: use nqp; my int $i = nqp::index(nqp::unbox_s("foo"), nqp::unbox_s("o"), nqp::unbox_i(-1e35)); say $i < 0 ?? Nil !! $i

[10:43] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/PZ1RMTE9cF:1␤␤»

[10:43] <camelia> rakudo-moar edffe0: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/TCcLNACb_w:1␤␤»

[10:43] <moritz> JimmyZ: dunno; haven't investigated it yet

[10:45] <ShimmerFairy> FROGGS: you need to convert that -1e35 to an Int first :)

[10:46] <FROGGS> m: use nqp; my int $i = nqp::index(nqp::unbox_s("foo"), nqp::unbox_s("o"), nqp::unbox_i((-1e35).Int)); say $i < 0 ?? Nil !! $i

[10:46] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«1␤»

[10:46] <camelia> rakudo-moar edffe0: OUTPUT«1␤»

[10:46] <FROGGS> okay...

[10:46] <FROGGS> m: use nqp; say nqp::unbox_i((-1e35).Int)

[10:46] <GLRelia> rakudo-moar 5c0c7b: OUTPUT«0␤»

[10:46] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[10:46] <FROGGS> okay...

[10:47] <FROGGS> so the rakudopatch that catched that in Cool.index got reverted but there is no fix yet available...

[10:47] <FROGGS> let's take a look at moarvm

[10:52] <dalek> rakudo/glr: 7ccbe0d | moritz++ | src/core/Seq.pm:

[10:52] <dalek> rakudo/glr: Give Seq an "invert" method

[10:52] <dalek> rakudo/glr: 

[10:52] <dalek> rakudo/glr: there is no generic method in Any, so Seq needs one for %h.pairs.invert

[10:52] <dalek> rakudo/glr: to work

[10:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7ccbe0d18b

[10:52] <dalek> roast/glr: 9431004 | moritz++ | S02-types/pair.t:

[10:52] <dalek> roast/glr: don't rely on .perl in pair.t

[10:52] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/943100464f

[10:53] <moritz> another test file down

[10:58] <dalek> roast/glr: c2f2973 | (Jimmy Zhuo)++ | S16-io/ (2 files):

[10:58] <dalek> roast/glr: fixed a test in say.t, and a new test note.t

[10:58] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c2f2973dd6

[10:59] <dalek> roast/glr: 217b1af | moritz++ | S02-types/baghash.t:

[10:59] <dalek> roast/glr: No need for .tree in baghash.t

[10:59] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/217b1af33d

[10:59] <dalek> roast/glr: b143d8a | moritz++ | S02-types/baghash.t:

[10:59] <dalek> roast/glr: Fix some incorrect assumptions in baghash.t

[10:59] <dalek> roast/glr: 

[10:59] <dalek> roast/glr: there are more to fix in this file, but not by me.

[10:59] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b143d8a5c1

[11:00] <moritz> JimmyZ: uhm, note.t doesn't work like that

[11:00] <moritz> JimmyZ: you can't just write TAP output to STDERR

[11:00] <JimmyZ> how can I fixed it?

[11:00] <moritz> JimmyZ: it might accidentally work in our configuration of the test harness, but please don't rely on it

[11:01] <moritz> JimmyZ: you could add $*ERR = $*OUT or so

[11:01] *** Ven left
[11:02] <JimmyZ> add $*ERR = $*OUT?

[11:02] *** AlexDaniel joined
[11:04] <leont> Writing to $*ERR from tests is generally a mistake IMO

[11:05] <dalek> roast/glr: 2fed439 | (Jimmy Zhuo)++ | S16-io/note.t:

[11:05] <dalek> roast/glr: fixed note

[11:05] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/2fed43911b

[11:12] *** rindolf left
[11:20] *** bin_005 joined
[11:34] <dalek> roast/glr: 38a5b8c | (Jimmy Zhuo)++ | S16-io/note.t:

[11:34] <dalek> roast/glr: fixed comment

[11:34] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/38a5b8cf97

[11:38] *** FROGGS_ joined
[11:40] <cognominal> I am working on huffmanizing nqp. My first result is a neo pragma to avoid the noisy op calls nqp::op() and write them as op(). That means writing fun() as &fun().  And now, that &fun() is taken.  my $fun = ... ; $fun() to call a fun on a var. Musical chairs!  https://github.com/cognominal/nqp/tree/neo

[11:41] <cognominal> I am working on more exciting things like an slang to generate QAST trees but I am not quit there yet.

[11:42] *** FROGGS left
[11:43] <cognominal> * not quite there.

[11:51] *** brrt joined
[12:08] *** Ven joined
[12:10] *** TEttinger left
[12:12] *** Ven left
[12:12] *** Ven joined
[12:13] <grondilu> m: sub neg($a is copy) { $a[$_] *= -1 for ^@$a; return $a; }; my $a = [^4]; neg($a); say $a;

[12:13] <yoleaux> 26 Jul 2015 14:43Z <azawawi> grondilu: ELI5 => https://github.com/azawawi/perl6-atom-electron/blob/master/bin/electron_bridge_launcher

[12:13] <camelia> rakudo-moar edffe0: OUTPUT«0 -1 -2 -3␤»

[12:13] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«0 -1 -2 -3␤»

[12:13] <yoleaux> 15 Aug 2015 16:41Z <laben> grondilu: the sha256 function hangs in test sha.t of your Digest module, can you check it please?

[12:13] *** amurf joined
[12:14] *** ShimmerFairy left
[12:14] *** Ven left
[12:17] *** amurf left
[12:21] <FROGGS_> hmmm...

[12:21] <FROGGS_> Cannot turn 101 bit wide bigint into 64 bit integer

[12:21] <FROGGS_>   in block <unit> at t/spec/S02-types/declare.rakudo.moar:116

[12:21] *** FROGGS_ is now known as FROGGS

[12:24] *** laben joined
[12:24] <brrt> no

[12:24] <brrt> that'd be weird

[12:24] <laben> hello p6'ers!

[12:26] *** ShimmerFairy joined
[12:29] <grondilu> m: (grep &is-prime, 2 .. *)[^64];

[12:29] <GLRelia> rakudo-moar 7ccbe0: ( no output )

[12:29] <grondilu> m: say (grep &is-prime, 2 .. *)[^64];

[12:29] <grondilu> ^that used to work, didn't it?

[12:29] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«(timeout)»

[12:29] <camelia> rakudo-moar edffe0: OUTPUT«(timeout)»

[12:30] <grondilu> m: say (grep &is-prime, 2 .. 1000)[^64];

[12:30] <camelia> rakudo-moar edffe0: OUTPUT«2 3␤»

[12:30] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«2 3␤»

[12:30] <grondilu> ???

[12:30] <grondilu> wtf

[12:30] <grondilu> m say 5.si-prime

[12:30] <grondilu> m say 5.is-prime

[12:30] <grondilu> m: say 5.is-prime

[12:30] <camelia> rakudo-moar edffe0: OUTPUT«True␤»

[12:30] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«True␤»

[12:30] <laben> m: (2..1000).grep(*.is-prime).say

[12:30] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 3…»

[12:30] <camelia> rakudo-moar edffe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 3…»

[12:31] <grondilu> m: say (grep &is-prime, (2 .. *))[^64];

[12:31] <laben> m: (2..1000).grep(*.is-prime)[^64].say

[12:31] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«(timeout)»

[12:31] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:31] <camelia> rakudo-moar edffe0: OUTPUT«(timeout)»

[12:31] <camelia> rakudo-moar edffe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:32] <laben> something happened to sub form of grep?

[12:32] <grondilu> m: (2..*).grep(*.is-prime)[^64].say

[12:32] <camelia> rakudo-moar edffe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:32] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:32] <ShimmerFairy> I think is-prime in sub form is stopping after the first false

[12:32] <grondilu> laben: that's probably the reason for sha256 hanging

[12:32] <moritz> m: say (grep &is-prime, 2 .. *)[64];

[12:33] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«(timeout)»

[12:33] <camelia> rakudo-moar edffe0: OUTPUT«(timeout)»

[12:33] <moritz> oh

[12:33] <moritz> the sub sub form of is-prime takes two arguments

[12:33] <moritz> the second optional is the number of tries

[12:33] <laben> m: (grep {*.is-prime}, 2..*)[^64]

[12:33] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MIixpRSJsn␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at /tmp/MIixpRSJsn:1␤------> 3(grep {*.is-p…»

[12:33] <grondilu> ok

[12:33] <laben> m: (grep *.is-prime, 2..*)[^64]

[12:33] <camelia> rakudo-moar edffe0: ( no output )

[12:33] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EYQtn4KZFS␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at /tmp/EYQtn4KZFS:1␤------> 3(grep {*.is-p…»

[12:33] <GLRelia> rakudo-moar 7ccbe0: ( no output )

[12:33] <laben> m: (grep *.is-prime, 2..*)[^64].say

[12:33] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:33] <camelia> rakudo-moar edffe0: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311␤»

[12:34] <moritz> m: say (grep {is-prime $_}, 2 .. *)[64];

[12:34] <camelia> rakudo-moar edffe0: OUTPUT«313␤»

[12:34] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«313␤»

[12:34] <laben> m: (grep *.is-prime, 2..*)[64].say

[12:34] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«313␤»

[12:34] <camelia> rakudo-moar edffe0: OUTPUT«313␤»

[12:34] <moritz> and grep is clever enough to pass two arguments to it

[12:34] <laben> why does *.is-prime work but not &is-prime?

[12:35] <moritz> laben: because &is-prime takes an optional argument

[12:35] <moritz> laben: and so grep passes two arguments at a time to it

[12:35] <moritz> whereas *.is-prime is a callable that only takes one argument

[12:36] <laben> moritz: docs.perl6 needs to be checked on this, i think it's not correct

[12:36] <laben> moritz: the docs i mean

[12:37] <laben> btw, glr messes up the svg module badly

[12:37] <laben> i'm trying to fix it

[12:37] <moritz> laben: the docs do mention the optional second argument

[12:38] <laben> moritz: the docs use the Int:D: param even on the sub form, i agree on the second arg

[12:38] <dalek> doc: f451b09 | moritz++ | lib/Type/Int.pod:

[12:38] <dalek> doc: Correct &is-prime signature

[12:38] <dalek> doc: review: https://github.com/perl6/doc/commit/f451b094c6

[12:38] <moritz> laben: aye :-)

[12:39] <laben> that was fast :)

[12:40] <laben> welp, did you notice that in is-prime routine page the search box does not appear? why is that?

[12:40] <grondilu> lol I've just pushed the *.is-prime in lib-digest.  If &is-prime changed it was for nothing I guess, but nevermind.

[12:41] <moritz> grondilu: &is-prime isn't changed, just the docs

[12:41] <grondilu> oh yeah

[12:41] <moritz> (and it was grep that was change recently to be smart enough to work with multiple args at once)

[12:42] <moritz> laben: it randomly doesn't appear for me on some pages, including the front page

[12:42] <ShimmerFairy> I got the is-prime sub from the search box on the front page

[12:42] <laben> that's strange, i get it on the front page

[12:45] <moritz> laben: I've opened https://github.com/perl6/doc/issues/117

[12:45] <moritz> ShimmerFairy: it's about the search box itself not always showing up

[12:45] <ShimmerFairy> ah

[12:46] <ShimmerFairy> moritz: I see a search box on  http://docs.perl6.org/routine/is-prime

[12:46] <ShimmerFairy> moritz: however, I did once notice it took a while to show up, if that helps any

[12:46] <moritz> firebug says ReferenceError: jQuery is not defined

[12:47] <moritz> and the same for s/jQuery/$/

[12:48] <laben> what's strange is that it is in the HTML at least for the front page

[12:48] <laben> ShimmerFairy: i waited some mins but it still did not appear for is-prime page

[12:48] <moritz> please follow the GH issue for more debugging :-)

[12:49] <laben> let me try with another browser

[12:49] <moritz> it's not the browser's fault

[12:49] <brrt> cdn dead?

[12:51] <moritz> please read the GH issue :-)

[12:51] *** telex left
[12:51] <laben> moritz: this is lol... trying to refresh page with Ctrl+F5 makes it appear sometimes and then disappear the next reload. but i agree it's probably beacuse of async

[12:51] <moritz> I'm adding debug information there, and don't want to repeat here all over

[12:52] *** telex joined
[12:55] <Zoffix> I'll fix it

[12:57] <dalek> doc: 6c72b35 | moritz++ | template/search_template.js:

[12:57] <dalek> doc: Avoid Javascript error

[12:57] <dalek> doc: 

[12:57] <dalek> doc: search.js / search_template.js uses jquery for running JS when the

[12:57] <dalek> doc: document is ready, but cannot use jQuery for that, because jQuery is lazily

[12:57] <dalek> doc: loaded, and thus might not be available yet (#117)

[12:57] <dalek> doc: review: https://github.com/perl6/doc/commit/6c72b35694

[12:57] <moritz> Zoffix: feel free to improve on that

[12:57] <moritz> my JS fu isn't all that strong

[12:57] <moritz> another option would be to load it from the footer, and don't include the async stuff

[12:58] <Zoffix> moritz, my version was going to get rid of async and move the <script> into the footer, but if your fix works, then all the power to it :)

[12:58] *** brrt left
[13:03] <moritz> Zoffix: we'll know after the rebuild finishes :-)

[13:05] *** virtualsue_ joined
[13:05] <Zoffix> :)

[13:05] *** virtualsue_ left
[13:06] *** llfourn_ joined
[13:06] *** virtualsue_ joined
[13:06] *** virtualsue left
[13:06] *** virtualsue_ is now known as virtualsue

[13:07] <moritz> http://caniuse.com/#feat=domcontentloaded looks like I picked the wrong event

[13:07] <moritz> "JavaScript event that fires when the DOM is loaded, but before all page assets are loaded (CSS, images, etc.)."

[13:07] *** cwDYKARN joined
[13:08] *** llfourn left
[13:08] <moritz> that means it could still be before the related scripts are loaded

[13:08] <Zoffix> Yeah, reading the answer here too: http://stackoverflow.com/questions/9237044/async-loaded-scripts-with-domcontentloaded-or-load-event-handlers-not-being-call

[13:09] <moritz> Zoffix: then please implement your solution instead :-)

[13:09] <Zoffix> Sure

[13:10] <dalek> doc: 11e098f | (Zoffix Znet)++ | template/ (3 files):

[13:10] <dalek> doc: Do not use async to load scripts that depend on one another (Fixes #117)

[13:10] <dalek> doc: review: https://github.com/perl6/doc/commit/11e098f59d

[13:12] *** rindolf joined
[13:12] <laben> same old javascript+DOM interactions and not-so-good async facilities :( i can only hope they will fix this kind of problems with WebAsm

[13:17] <moritz> Zoffix: https://www.webkit.org/blog/1395/running-scripts-in-webkit/ defer seems to be a nice option

[13:20] <Zoffix> moritz, are we still supporting IE<=9?  I found this: https://github.com/h5bp/lazyweb-requests/issues/42

[13:21] *** brrt joined
[13:22] <moritz> Zoffix: dunno; I don't care that much anymore

[13:28] <rindolf> Zoffix: hi, sup?

[13:28] *** rurban left
[13:28] <dalek> doc: 94175a6 | (Zoffix Znet)++ | html/css/style.css:

[13:28] <dalek> doc: Prevent overflown and unscrollable code samples on small-width screens

[13:28] <dalek> doc: review: https://github.com/perl6/doc/commit/94175a6c69

[13:28] <Zoffix> rindolf, hey. Getting ready to go to work

[13:29] <rindolf> Zoffix: ah, I see.

[13:29] <jnthn> I can haz messagez???

[13:29] <yoleaux> 08:45Z <nine> jnthn: should the single arg rule really extend to Hashes just because they do Iterable? my @a = {:a(1), :b(2)}; gives [:a(1), :b(2)] and the same happens for sub calls

[13:29] *** rurban joined
[13:30] *** brrt left
[13:30] *** bin_005 left
[13:30] <jnthn> .tell nine Good question. It feels a little odd may have to defer to TimToady++ on that one.

[13:30] <yoleaux> jnthn: I'll pass your message to nine.

[13:32] <jnthn> I see lots of discussion in backlog on one-arg rule. I think "for X { Y }" being a direct mapping to "X.map({ Y })" is a non-negotiable.

[13:33] <jnthn> I'd also like to strongly discourage trying to add complexity to solve particular cases. That's how we got ourselves into the previous list models we're trying to do better than.

[13:33] <ShimmerFairy> I suggested a way to distinguish things that _could_ be iterated versus things that are _usually_ iterated for those cases (e.g. hashes _can_ be iterated, but the more common access method is random access and they're usually sorted in some way, so it's not very usual)

[13:34] <ShimmerFairy> On the other hand, perhaps being able to turn a hash into a list with @a = %b could be a neat trick for... something :>

[13:35] <laben> jnthn: i think we can agree that the current way the Seq gets consumed multiple times (wrongly) by dwimmy hypers is just an implementation artifact and not the intention, right?

[13:36] <jnthn> laben: Sounds like a bug in how hypers are implemented

[13:36] <jnthn> @a.map(...) >>+<< @b.map(...) should totally work :)

[13:36] <laben> jnthn: me and nine were in accord, but i wanted confirmation from design POV

[13:37] <jnthn> I think for efficiency reasons we'll only be able to tell you that the lists were of unequal length *after* doing most of the work.

[13:37] <JimmyZ> jnthn: lizmat said we may want *@args is list instead of *@args is rw 

[13:37] <jnthn> JimmyZ: I can see the motivation, but I'm not sure adding another trait to learn makes things much better, tbh.

[13:38] <jnthn> If anything, we should call it whatever the trait for \x is ("is parcel"?) because that is the actual semantics.

[13:39] <jnthn> I bet the \x trait is going to get renamed to something other than "is parcel" though :)

[13:40] <ShimmerFairy> is too-good-for-sigils :P

[13:40] <jnthn> :D

[13:40] <JimmyZ> well, is rw make list confused me

[13:40] <jnthn> JimmyZ: It makes some kind of sense if you think about it :)

[13:40] <JimmyZ> :)

[13:41] <jnthn> JimmyZ: The point isn't what type it makes but the semantics you get (that is, you can assign to the originally passed continer)

[13:41] <jnthn> But yeah, I agree the semantics are more sigilless than rw, and can see we may wish to address that.

[13:41] <JimmyZ> well, it is not DWIMish :P

[13:42] <FROGGS> jnthn: I am working at a fix for "foo".index("o", <very large number>), and in one of lizmat++'s patches she mentions that unbox_i should take care of numbers that are greater than 64 bits...

[13:42] *** philh joined
[13:42] <laben> btw, could we separate the use-cases of is? it's a bit strange that it is used for deriving classes and applying traits when we have a separate keyword for composing roles

[13:42] <jnthn> FROGGS: Yeah, I think that was the better direction to go

[13:42] <FROGGS> jnthn: however, that would disallow 'my int $foo = <very big number>'

[13:42] <philh> Hi, having trouble with subclassing Mix.

[13:42] <jnthn> laben: We've had that discussion plenty of times, long story short "no" :)

[13:43] <philh> p6: class Mix2 is Mix {}; Mix2.new-from-pairs(1 => 2)

[13:43] <GLRelia> rakudo-moar 7ccbe0: ( no output )

[13:43] <camelia> rakudo-moar edffe0: ( no output )

[13:43] <laben> jnthn: ok, did not know. why is that, ooc?

[13:43] <ShimmerFairy> FROGGS: serves you right for trying to stuff a big number in a native type, in my opinion :P

[13:43] <philh> Uh, maybe I don't know how to use the bots. When I run that, `Method 'BUILD' not found for invocant of class 'Mix2'`

[13:43] <jnthn> FROGGS: I think the point is to disallow that ;)

[13:43] <FROGGS> jnthn: disallowing overflows?

[13:44] <FROGGS> jnthn: then this should be good enough me thinks: https://gist.github.com/FROGGS/6edb1240b98f881688d6

[13:44] <jnthn> FROGGS: Well, disallowing them at the point of unboxing a big integer at lesat, yes

[13:44] <FROGGS> $ perl6 -e 'my int $a = 10000000000000000000000000000000000000000'

[13:44] <FROGGS> Cannot turn 133 bit wide bigint into 64 bit integer

[13:44] <jnthn> FROGGS: Pleaes use unbox rather than turn

[13:44] <FROGGS> k

[13:44] <jnthn> (for consistency with other errors)

[13:44] <FROGGS> and perhaps s/64 bit/machine sized/

[13:44] <FROGGS> or native sized

[13:45] <jnthn> laben: It's rarely confusing in reality 'cus classes nearly always have an uppercase letter at the start and traits don't.

[13:45] <FROGGS> or just native

[13:45] <jnthn> FROGGS: I could go with native

[13:45] <FROGGS> yeah

[13:45] <ShimmerFairy> FROGGS: my only potential concern is if there are any places in the core code that use unbox_i on bigints where you wouldn't expect them, i.e. things that from an external POV go BigInt->BigInt and don't imply native int manipulation

[13:45] <jnthn> FROGGS: That also helps it match the "cannot unbox" errors

[13:46] <FROGGS> ShimmerFairy: yes, we potentially need to catch some of those, like in Cool.index

[13:46] <jnthn> ShimmerFairy: I think all the math ops on bigints work in terms of those

[13:47] <jnthn> philh: I *think* there was a bug in some recentish versions of Rakudo that bust subclassing of things like Mix; the bot runs the latest version which apparently has a fix for the issue.

[13:47] <ShimmerFairy> jnthn: I would hope, but just in case Int.something-mathy implemented itself in terms of native ints for speed, or something :)

[13:47] <jnthn> If we do have that case then we should probably know about it and fix it :)

[13:48] *** vendethiel joined
[13:48] <JimmyZ> jnthn: btw, I am waiting for you slides :{

[13:48] <jnthn> oh yeah, I did a talk... :)

[13:48] <philh> jnthn: Oh, okay. I'll try another version. To check, it's rakudo I need to fiddle with, not nqp or moarvm?

[13:48] <jnthn> I think it was the most exhausted/jetlagged I've ever been while giving a presentation.

[13:48] <FROGGS> philh: you often need to upgrade all three

[13:49] <jnthn> philh: It surely would have been a Rakudo-level fix but...what FROGGS said.

[13:49] <philh> I was planning to try downgrading to avoid that :p

[13:52] <FROGGS> jnthn: I could imagine that we might want: my int16 = <some Int>.int16, so it is explicit

[13:55] <moritz> Zoffix++ # search box now shows up reliably

[13:55] <Zoffix> \o/

[13:55] *** rurban_ left
[13:57] <jnthn> http://jnthn.net/papers/2015-yapcasia-concurrency.pdf # slides

[13:58] * JimmyZ opens it

[14:01] *** xfix joined
[14:01] *** xfix left
[14:01] *** xfix joined
[14:01] <philh> So downgrading just rakudo didn't work. I upgraded moar to master, but nqp at master doesn't like moar at master?

[14:02] <ShimmerFairy> what's the error you get?

[14:03] <moritz> m: say <a b c>.map(&uc).race

[14:03] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«HyperSeq.new␤»

[14:03] <camelia> rakudo-moar edffe0: OUTPUT«Method 'race' not found for invocant of class 'List'␤  in block <unit> at /tmp/wD8MpBibPa:1␤␤»

[14:03] <moritz> m: say <a b c>.map(&uc).race.list

[14:03] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«␤»

[14:03] <camelia> rakudo-moar edffe0: OUTPUT«Method 'race' not found for invocant of class 'List'␤  in block <unit> at /tmp/81rsJIGl_5:1␤␤»

[14:03] <philh> "Found /usr/bin/moar version 2015.07, which is too old."

[14:04] <moritz> philh: sounds like you're using the wrong moarvm binary

[14:04] <philh> Oh

[14:04] <ShimmerFairy> did you provide the right --prefix to nqp's configure after installing moarvm

[14:04] <moritz> philh: how did you build MoarVM?

[14:04] <philh> Yes, I did make install but /usr/bin/moar is a few hours old

[14:04] <moritz> you can build nqp with --gen-moar=master to automatically set the right installaton prefix

[14:04] <nine> jnthn: yes, HYPER needs a bit of a refactoring. I got the tests to pass, but the implementation is still quite listy and not iteratorish enough. Already started on that.

[14:04] <yoleaux> 13:30Z <jnthn> nine: Good question. It feels a little odd may have to defer to TimToady++ on that one.

[14:04] <philh> `perl Configure.pl --prefix /usr && make && sudo make install`

[14:05] <jnthn> nine: Cool

[14:05] <jnthn> nine: I'll hopefully be able to be more useful to glr things again soonish :)

[14:05] <ShimmerFairy> philh: moarvm by default installs locally in the repo (and _not_ in /usr/local, the usual default), if you don't supply moar's configure a --prefix to install to

[14:06] <philh> I gave the prefix to both nqp and moar

[14:06] <nine> jnthn: will be a bit of a challenge to get rid of the .elems calls. We won't be able to bail out due to wrong usage in all cases that we do now.

[14:06] *** pochi_ joined
[14:06] <jnthn> nine: Oh?

[14:06] <ShimmerFairy> ah

[14:06] <jnthn> nine: I thought we'd be able to bail out but later

[14:06] <philh> rm /usr/bin/moar and then sudo make install again seems to fix it, I guess I should do a distclean to clear out everything?

[14:07] <nine> jnthn: later yes

[14:07] <jnthn> nine: That's fine by me

[14:07] <nine> jnthn: we currently do it before even starting the work which is nice but not something we can keep up

[14:07] <jnthn> nine: Agree, optimizing for people who misuse something is probably wrong :)

[14:08] *** avalenn_ joined
[14:08] *** skids joined
[14:08] <nine> jnthn: refactoring it to be really iterator based will be a precursor to making it auto thread. I'd be quite tempted to try the latter, too :)

[14:08] *** llfourn joined
[14:08] <jnthn> nine: OK, but note I only did .race, not really .hyper ;)

[14:08] <nine> But that's probably better done once glr has safely landed.

[14:08] *** rurban left
[14:08] <jnthn> nine: So it'll idsorder results

[14:08] <jnthn> nine: Yeah, that was my plan :)

[14:08] <ShimmerFairy> philh: you can also supply the --backend=moar option to nqp and rakudo, which is something I always do but wasn't aware you could leave out :)

[14:08] <nine> That will give us a chance to clean up the fallout before inflicting new pain :)

[14:09] <nine> But once you start thinking about an iterator based implementation, the places where you can plug in the auto threading become quite obvious :)

[14:09] <grondilu> m: sub neg($a is copy) { $a[0] *= -1; return $a; }; my $a = [1]; neg($a); say $a;

[14:09] <camelia> rakudo-moar edffe0: OUTPUT«-1␤»

[14:09] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«-1␤»

[14:09] <ShimmerFairy> oh, that reminds me of something I need to take care of :)

[14:10] <grondilu> ^ I get the logic but still it's a bit disturbing

[14:10] *** pecastro_ joined
[14:10] *** Shozan joined
[14:11] *** Util_ joined
[14:11] *** JimmyZ left
[14:11] *** SHODAN left
[14:11] *** rindolf left
[14:11] *** llfourn_ left
[14:11] *** pecastro left
[14:11] *** tadzik left
[14:11] *** coffee` left
[14:11] *** Util left
[14:11] *** pochi left
[14:11] <grondilu> m: say [].clone

[14:11] <camelia> rakudo-moar edffe0: OUTPUT«␤»

[14:11] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«␤»

[14:11] *** kanl left
[14:11] *** pecastro_ is now known as pecastro

[14:11] <grondilu> maybe there could be a "$param is clone"

[14:11] *** xnrand joined
[14:12] *** kanl joined
[14:12] *** rindolf joined
[14:12] <nine> .tell TimToady should the single arg rule really extend to Hashes just because they do Iterable? my @a = {:a(1), :b(2)}; gives [:a(1), :b(2)] and the same happens for sub calls. for %hash {...} and %hash.map iterating over the pairs does asolutely make sense, but when passing a hash to a sub or method, one really expects it to stay a hash.

[14:12] <yoleaux> nine: I'll pass your message to TimToady.

[14:14] <nine> jnthn: like I said yesterday: you having a look at some roast tests would be most useful. We mere mortals are just too unsure about the new semantics :) Fixing the implementation to pass the tests is doable.

[14:15] *** [Sno] left
[14:17] <nine> jnthn: also the missing plan for a LoL replacement is becoming a blocker more and more.

[14:18] <jnthn> nine: Yeah; at latest we'll resolve that at the upcoming hackathon in Olten.

[14:18] *** rindolf left
[14:18] <nine> Should be one of very few remaining issues by then :)

[14:19] *** rindolf joined
[14:19] <moritz> when is Olten?

[14:19] <nine> Wednesday

[14:20] <moritz> nine: then I'm not quite so optimisting

[14:20] <moritz> modulo spelling :-)

[14:20] <nine> Well I am an optimist :)

[14:20] *** JimmyZ joined
[14:20] <moritz> 100+ test files are a lot to investigate and clean up

[14:21] <moritz> m: roundrobin()

[14:21] <GLRelia> rakudo-moar 7ccbe0: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/OhDsqGudfA:1␤␤»

[14:21] <camelia> rakudo-moar edffe0: ( no output )

[14:31] *** brrt joined
[14:32] <jdv79> jnthn: cool slides.  i didn't (don't) get what react is all about.

[14:32] <jdv79> otherwise very nice

[14:33] <jnthn> jdv79: It's a slightly smarter supply { ... }.tap.wait

[14:33] <jnthn> jdv79: Mostly useful for writing the "main event loop" of a program.

[14:34] <jnthn> (When you don't plan to produce any results, and want to block until all whenever's get done or there's an unhandled exception)

[14:34] <jdv79> ah

[14:35] <jnthn> I could see that if I didn't add it I'd spend ages explaining some boring boilerplate again and again :)

[14:36] <moritz> jnthn++ # slides

[14:37] *** tadzik joined
[14:40] <dalek> rakudo/glr: 46b97a9 | moritz++ | src/core/List.pm:

[14:40] <dalek> rakudo/glr: Basic, iterator-based implementation of roundrobin

[14:40] <dalek> rakudo/glr: 

[14:40] <dalek> rakudo/glr: passes all but one test, and is probably horribly inefficient

[14:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/46b97a9fbc

[14:42] <jnthn> Time for another attempt at resting.

[14:42] * jnthn is not looking forward to the 12 hour flight tomorrow, but will be glad to be back in the timezone his body seems determined to stick in...

[14:42] <jnthn> 'niht

[14:42] <jnthn> *night

[14:43] <moritz> good night, jnthn 

[14:43] <ShimmerFairy> ♞ jnthn o/

[14:47] <moritz> m: say (my % = <a b c d>.sort).perl

[14:47] <GLRelia> rakudo-moar 46b97a: OUTPUT«{:a("b"), :c("d")}␤»

[14:47] <camelia> rakudo-moar edffe0: OUTPUT«{:a("b"), :c("d")}<>␤»

[14:48] <moritz> m: say (my % = <a b c >.map( { $_, uc }).perl

[14:48] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JCsqvweGx0␤Unsupported use of bare "uc"; in Perl 6 please use .uc if you meant $_, or use an explicit invocant or argument␤at /tmp/JCsqvweGx0:1␤------> 3say (my % = <a b c >.map( { $_, uc7⏏5 }).perl␤»

[14:48] <GLRelia> rakudo-moar 46b97a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/OXG_g0Bhsw␤Unsupported use of bare "uc"; in Perl 6 please use .uc if you meant $_, or use an explicit invocant or argument␤at /tmp/OXG_g0Bhsw:1␤------> 3say (my % = <a b c >.map( { $_, uc7⏏5 }).perl␤»

[14:48] <moritz> m: say (my % = <a b c >.map( { $_, .uc }).perl

[14:48] <GLRelia> rakudo-moar 46b97a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/r49vEhA1kg␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/r49vEhA1kg:1␤------> 3 (my % = <a b c >.map( { $_, .uc }).perl7⏏5<EOL>␤    expecting any of:␤ …»

[14:48] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/puFHAWe_8p␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/puFHAWe_8p:1␤------> 3 (my % = <a b c >.map( { $_, .uc }).perl7⏏5<EOL>␤    expecting any of:␤ …»

[14:48] <moritz> m: say (my % = <a b c >.map( { $_, .uc }) ).perl

[14:48] <GLRelia> rakudo-moar 46b97a: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/tIIoDCGjU1:1␤␤»

[14:48] <camelia> rakudo-moar edffe0: OUTPUT«{:a("A"), :b("B"), :c("C")}<>␤»

[14:48] <moritz> it seems that doesn't flatten sublists anymore

[14:48] <moritz> is that intended?

[14:49] <laben> m: say (my % = <a b c >.map( { $_ => .uc }) ).perl

[14:49] <GLRelia> rakudo-moar 46b97a: OUTPUT«{:a("A"), :b("B"), :c("C")}␤»

[14:49] <camelia> rakudo-moar edffe0: OUTPUT«{:a("A"), :b("B"), :c("C")}<>␤»

[14:49] <moritz> that's t/spec/S32-list/map_function_return_values.t

[14:51] <ShimmerFairy> m: say <a b c >.map: {$_, .uc}

[14:51] <GLRelia> rakudo-moar 46b97a: OUTPUT«a A b B c C␤»

[14:51] <camelia> rakudo-moar edffe0: OUTPUT«a A b B c C␤»

[14:51] <ShimmerFairy> m: say <a b c >.map({$_, .uc}).perl

[14:51] <GLRelia> rakudo-moar 46b97a: OUTPUT«(("a", "A"), ("b", "B"), ("c", "C")).iterator␤»

[14:51] <camelia> rakudo-moar edffe0: OUTPUT«(("a", "A"), ("b", "B"), ("c", "C"))␤»

[14:52] <ShimmerFairy> m: say (my % = |<a b c >.map( { $_, .uc }) ).perl

[14:52] <GLRelia> rakudo-moar 46b97a: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/5isUFu8RUb:1␤␤»

[14:52] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/wrwSlkJhW5␤Arg-flattening | is only valid in an argument list␤at /tmp/wrwSlkJhW5:1␤------> 3say (my % = |7⏏5<a b c >.map( { $_, .uc }) ).perl␤»

[14:52] <laben> m: dd my % = <a b c>

[14:52] <GLRelia> rakudo-moar 46b97a: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/ITwEg1N8Be:1␤␤»

[14:52] <camelia> rakudo-moar edffe0: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/dWXxxBy2Sc:1␤␤»

[14:52] <laben> m: dd my % = <a b c d>

[14:52] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {:a("b"), :c("d")}␤»

[14:52] <camelia> rakudo-moar edffe0: OUTPUT«% = {:a("b"), :c("d")}<>␤»

[14:53] <dalek> nqp: 77ddfb5 | ShimmerFairy++ | / (3 files):

[14:53] <dalek> nqp: Actually install the default 'nqp'

[14:53] <dalek> nqp: 

[14:53] <dalek> nqp: Now when you run 'make install', you'll install 'nqp' along with 'nqp-m'

[14:53] <dalek> nqp: and/or 'nqp-j' into the appropriate BIN_DIR.

[14:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/77ddfb53bf

[14:53] <laben> m: dd my % = 1..4

[14:53] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1" => 2, "3" => 4}<>␤»

[14:53] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1" => 2, "3" => 4}␤»

[14:54] <laben> m: dd my % = (1..4).map({($_, .succ)})

[14:54] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => $(2, 3), "3 4" => $(4, 5)}␤»

[14:54] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}<>␤»

[14:54] <laben> m: dd my % = (1..4).map({[$_, .succ]})

[14:54] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => $[2, 3], "3 4" => $[4, 5]}␤»

[14:54] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1 2" => [2, 3], "3 4" => [4, 5]}<>␤»

[14:55] <laben> m: dd my % = (1..4).map({$($_, .succ)})

[14:55] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => $(2, 3), "3 4" => $(4, 5)}␤»

[14:55] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1 2" => $(2, 3), "3 4" => $(4, 5)}<>␤»

[14:55] <laben> i think it's better to rely on the => op after all

[14:57] <moritz> that doesn't quite help me when deciding whether to change EnumMap.STORE or the test

[14:58] <ShimmerFairy> I think of the "all commas" way of constructing hashes is more a convenience than anything else, so I'd prefer => where possible.

[14:58] *** rurban joined
[14:59] <laben> moritz: if you can find a way to elegantly flatten all the Seq produced by map in a list, you can still have that

[15:00] <ShimmerFairy> moritz: unless the test is specifically after testing the , version of mapping those things, I'd say change the test to use =>

[15:00] <laben> m: dd my % = ((1..4).map({($_, .succ)})).flat

[15:00] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}<>␤»

[15:00] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}␤»

[15:00] <moritz> m: say (my % = <a b c >.map( { ($_, .uc).slip }) ).perl

[15:00] <camelia> rakudo-moar edffe0: OUTPUT«Method 'slip' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/DBo7b7CvKq:1␤␤»

[15:00] <GLRelia> rakudo-moar 46b97a: OUTPUT«Method 'slip' not found for invocant of class 'List'␤  in block <unit> at /tmp/JWNmEDKf3d:1␤␤»

[15:00] <laben> there are a bit too many parenthesis for my tastes

[15:00] <moritz> m: say (my % = <a b c >.map( { ($_, .uc).Slip }) ).perl

[15:00] <GLRelia> rakudo-moar 46b97a: OUTPUT«{:a("A"), :b("B"), :c("C")}␤»

[15:00] <camelia> rakudo-moar edffe0: OUTPUT«Method 'Slip' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/_ybRuXQqUQ:1␤␤»

[15:00] <moritz> ShimmerFairy: that seems to be what the test is about, though

[15:01] <laben> m: dd my % = (1..4).map({($_, .succ).flat})

[15:01] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}<>␤»

[15:01] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => (2, 3).iterator, "3 4" => (4, 5).iterator}␤»

[15:01] <laben> m: dd my % = (1..4).map({slip($_, .succ)})

[15:01] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}␤»

[15:01] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HmP80gOjQ8␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[15:01] <laben> m: dd my % = slip (1..4).map({$_, .succ})

[15:01] <GLRelia> rakudo-moar 46b97a: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/4uOCu1o2uU:1␤␤»

[15:01] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tIOu0SHOof␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[15:01] <laben> m: dd my % = flat (1..4).map({$_, .succ})

[15:01] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}␤»

[15:01] <camelia> rakudo-moar edffe0: OUTPUT«% = {"1" => 2, "2" => 3, "3" => 4, "4" => 5}<>␤»

[15:02] <laben> m: dd my % = |(1..4).map({$_, .succ})

[15:02] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => $(2, 3), "3 4" => $(4, 5)}␤»

[15:02] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ie2_CDJo0o␤Arg-flattening | is only valid in an argument list␤at /tmp/ie2_CDJo0o:1␤------> 3dd my % = |7⏏5(1..4).map({$_, .succ})␤»

[15:02] <ShimmerFairy> moritz: I think you'll have to change the test to Slip-ify (either .Slip or prefix:<|>), since I can easily imagine wanting a .map like that to not flatten (which would be hard if it's already flattened)

[15:03] <laben> m: dd my % = (1..4).map({$_, .succ}).Slip

[15:03] <ShimmerFairy> moritz: the alternative would be that pair construction accepts a list of tuples, but I don't think that's useful considering you can do a list of Pairs by that point :)

[15:03] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {"1 2" => $(2, 3), "3 4" => $(4, 5)}␤»

[15:03] <camelia> rakudo-moar edffe0: OUTPUT«Method 'Slip' not found for invocant of class 'List'␤  in block <unit> at /tmp/YIYcXLF2LG:1␤␤»

[15:03] <ShimmerFairy> er, 2-tuples to be precise :)

[15:03] <laben> m: dd my % = (1..4).map({$_, .succ})>>=>

[15:03] <GLRelia> rakudo-moar 46b97a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/f02ljR9jsJ␤Malformed postfix␤at /tmp/f02ljR9jsJ:1␤------> 3dd my % = (1..4).map({$_, .succ})>>7⏏5=>␤    expecting any of:␤        postfix␤»

[15:03] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/D4e9KyJfOw␤Malformed postfix␤at /tmp/D4e9KyJfOw:1␤------> 3dd my % = (1..4).map({$_, .succ})>>7⏏5=>␤    expecting any of:␤        postfix␤»

[15:05] <jdv79> so, i have a ro attr in a role and i want to write it from a subclass of the consuming class

[15:05] <jdv79> should that work?

[15:06] <moritz> m: my $x = 'a b'; say <<C $x>>.perl

[15:06] <camelia> rakudo-moar edffe0: OUTPUT«("C", ("a", "b"))␤»

[15:06] <GLRelia> rakudo-moar 46b97a: OUTPUT«("C", ("a", "b"))␤»

[15:07] <jdv79> or, in other words - in what ways can a ro attr be written?

[15:07] <moritz> from within the class by a method

[15:07] <jdv79> the attr is in a role though

[15:08] <moritz> then the role must offer a method to write to the attribute

[15:09] <ShimmerFairy> We don't have anything in the way of 'protected' attributes (as they're known in C++), if that's what you're after.

[15:09] <moritz> it's very easy: if a subclass should get access to something, that something must be public

[15:09] <moritz> otherwise you'd force everyone who wants access to that someting to subclass

[15:09] <moritz> and that's a very bad motivation for subclassing

[15:10] <nine> moritz: looking at your roundrobin implementation, I can't quite see why it should be inefficient :)

[15:10] <jdv79> it technically is public, its just ro

[15:11] <moritz> nine: because it builds the array of iterators anew each iteration

[15:11] <ShimmerFairy> moritz: the one use-case I've seen for protected attributes/methods is with logging functions, e.g. a base class offers logging functionality for while it's operating, and wants to open that to subclasses, but not beyond that.

[15:12] <moritz> ShimmerFairy: and that's stupid; why would a subclass be more qualified, than, say, a class that extends the logger by delegation?

[15:13] <nine> m: m: say (my % = |<a b c >.map( { Slip.new($_, .uc) }) ).perl

[15:13] <GLRelia> rakudo-moar 46b97a: OUTPUT«{:a("A"), :b("B"), :c("C")}␤»

[15:13] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/mJ4lKhZGyF:1␤------> 3m: say (my % = |7⏏5<a b c >.map( { Slip.new($_, .uc) }) ).p␤Undeclared name:␤    Slip used at line 1␤␤␤»

[15:13] <ShimmerFairy> I don't follow, sorry

[15:14] <moritz> ShimmerFairy: what makes the subclass so special? why allow access to a subclass?

[15:14] <laben> m: dd my % = |<a b c >.map( { Slip.new($_, .uc) })

[15:14] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {:a("A"), :b("B"), :c("C")}␤»

[15:14] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/sgktloEFwz:1␤------> 3dd my % = |7⏏5<a b c >.map( { Slip.new($_, .uc) })␤Undeclared name:␤    Slip used at line 1␤␤␤»

[15:14] <moritz> ShimmerFairy: as opposed to a user that delegates to the logger?

[15:14] <laben> m: dd my % = |<a b c >.map( { slip($_, .uc) })

[15:14] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {:a("A"), :b("B"), :c("C")}␤»

[15:14] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5===␤Arg-flattening | is only valid in an argument list␤at /tmp/g5xVRcxQg1:1␤------> 3dd my % = |7⏏5<a b c >.map( { slip($_, .uc) })␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤␤»

[15:14] <ShimmerFairy> I don't follow the "a class that extends the logger by delegation" part

[15:14] <laben> m: dd my % = <a b c >.map( { slip($_, .uc) })

[15:14] <GLRelia> rakudo-moar 46b97a: OUTPUT«% = {:a("A"), :b("B"), :c("C")}␤»

[15:14] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/d974ySrYbv␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[15:15] <moritz> ShimmerFairy: are you familiar with delegation?

[15:15] <ShimmerFairy> nope

[15:15] <moritz> ShimmerFairy: basically that's having the logger stored in an attribute, and forward method calls to it

[15:15] *** khw joined
[15:15] <moritz> (or at least some fo the method calls)

[15:16] <laben> ShimmerFairy: search for keyword "handles" in the synopses

[15:16] <moritz> https://en.wikipedia.org/wiki/Delegation_%28programming%29

[15:16] <ShimmerFairy> moritz: ah. I have done that before in C++ (it was the better solution because I had to implement a logger class on its own and pass it around)

[15:18] <ShimmerFairy> moritz: the idea, as I understand it, is that the logger functions are of no use to the outside world, only the class and anything extending its functionality.

[15:18] <nine> ShimmerFairy: logging is actually the classic example of extra functionality that should _not_ be in a class (unless its a Logger class of course)

[15:18] <moritz> a more pragmatic approach is: if you have a "protected" method, it's already part of the public API (because subclasses can use it), so it must be documented, tested, stability criteria apply etc.

[15:18] <moritz> so you can just make it public

[15:18] <moritz> ShimmerFairy: but delegation can also be used to extend funcitionality

[15:19] <moritz> ShimmerFairy: so protected attributes force the one who wants to extend the class into an inheritance pattern, even if delegation would be preferable

[15:19] <ShimmerFairy> As a contrived example, imagine a class DFARegex that logs as it works, and an NFARegex that inherits DFARegex and needs to log as well. Letting the outside world access the logger would be inappropriate, since the logging is specifically for what the engines are doing

[15:20] <jdv79> i'll just leave it as is rw and as later in context

[15:20] <jdv79> its not a big deal - this instance i mean

[15:20] <jdv79> *ask

[15:20] <jdv79> seems kinda lame but i don't think i get the whole argument

[15:21] <ShimmerFairy> moritz: with your "no protecteds" method, those logging functions would be exposed to anyone, anywhere. While it's acceptable to just document "don't use unless inheriting the class or delegating to it", a lot of times it'd be nice if you can enforce the limited usability

[15:21] <moritz> ShimmerFairy: but what would be so bad if others used the logger?

[15:22] <moritz> ShimmerFairy: after all, there might be legitimate use cases for determining which logger the current object uses, if several are in use throughout the application

[15:22] <ShimmerFairy> moritz: I can't imagine a scenario where it's harmful off-hand, but the point is that it's not _useful_ either.

[15:24] <jdv79> i simply wanted to dissuade someone from replacing a sub-object instance contained in an attr because it may be subclass dependent

[15:25] *** skids left
[15:26] <moritz> nine, jnthn, lizmat, TimToady: I've created https://github.com/perl6/glr-test-failures-annotated where I added some information about test failures that I have triaged, but not fixed

[15:26] <moritz> and I plan to add more

[15:26] <moritz> hopefully it's helpful to somebody; if not, we can scrap the whole thing again

[15:30] *** cschwenz joined
[15:31] *** rurban left
[15:32] *** cschwenz left
[15:33] <nine> moritz++ # this would have saved quite a bit of duplicated work already

[15:37] *** carlin joined
[15:42] <dalek> rakudo/glr: b9a76ce | (Stefan Seifert)++ | src/core/Mixy.pm:

[15:42] <dalek> rakudo/glr: Fix "expected 'Positional' but got 'Seq'" in Mix.roll

[15:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b9a76ce389

[15:43] *** mjgardner joined
[15:44] <jdv79> the pause code brings back memories of $work spaghetti nightmares

[15:44] *** ZoffixWork joined
[15:51] *** amurf joined
[15:55] *** amurf left
[15:58] <nine> Why does deepmap process the input twice? I can understand doing it in an unexpected order but why twice?

[15:59] <jdv79> its staggered

[15:59] <ShimmerFairy> nine: that's the hyper thing, right? It goes through the list twice because it goes every other

[15:59] <jdv79> odds evens

[16:00] <jdv79> shuffling shenanigans ^H

[16:00] <nine> oooh...ok

[16:00] <jdv79> backwards and unzipped; or somemthing

[16:00] <nine> But that's not a functional requirement, isn't it?

[16:00] <ShimmerFairy> IIRC, it's *-1, *-3, *-5,... and then *-2, *-4, ...

[16:00] <jdv79> nope

[16:01] <nine> good :) Then I can just take the sequential-map code and adjust it

[16:01] <jdv79> afaik thats just the "don't rely on this order of exec" impl details

[16:01] <ShimmerFairy> nine: not really, it's just there to simulate the fact that you can't trust hyper to process things in a consistent order (side-effects and such)

[16:01] <jdv79> ShimmerFairy: did you try to understand the pause code

[16:01] <jdv79> i wouldn't recommend it for sanity's sake

[16:01] <ShimmerFairy> jdv79: not really, I barely understand P5 :P

[16:02] <jdv79> i understand p5 and i'm losing it

[16:04] <jdv79> this is the kind of code that p5 haters love to point at

[16:05] *** lsm-desktop left
[16:05] *** lucasb joined
[16:05] <ShimmerFairy> I would imagine there have been a few rewrite attempts over the years, considering its age and tangled nature :)

[16:07] <mst> people have been slowly refactoring it and switching stuff out for modules

[16:07] <mst> but bear in mind it's lived a loooong time

[16:07] <jdv79> no idea.  i never cared about it until now.

[16:07] <jdv79> yeah, super example of legacy

[16:08] <mst> and it's very solid code that isn't actually -that- hard to change

[16:08] <mst> the big problem is that a lot of things that look like bugs turn out to be required for crazy stuff people uploaded to cpan

[16:09] *** vendethiel left
[16:09] <moritz> m: class A { has @.a = <a b c>; method x { say $.x.VAR } }; A.new.x

[16:09] <camelia> rakudo-moar edffe0: OUTPUT«Memory allocation failed; could not allocate 120192 bytes␤»

[16:09] <GLRelia> rakudo-moar b9a76c: OUTPUT«Memory allocation failed; could not allocate 63360 bytes␤»

[16:09] <jdv79> i think the "liberal in what you accept" principle can be taken too far

[16:09] <ShimmerFairy> mst: yeah, I figured a rewrite of CPAN/PAUSE would better work out in a "modular" sense. That is, providing drop-in replacements for things one component at a time

[16:10] <jdv79> ShimmerFairy: if you've ever tried to rewrite a real legacy app then you get it

[16:10] <jdv79> its the stuff of pure nightmares

[16:10] <moritz> aye

[16:11] <jdv79> a fascinating subject though - one we have much to learn about

[16:11] <jdv79> i hope;)

[16:12] <mst> ShimmerFairy: it's been in slow progress for years; if you want to help, I suggest becoming a member of the perl5 toolchain team first

[16:12] <mst> otherwise you're going to fall down the various rabbit holes we've already explored

[16:12] <jdv79> mst: this all came about earlier today when i found a bug in the p pause support

[16:12] <mst> extracting the perl6 side into a module so you guys can help maintain that would seem very logical

[16:13] <jdv79> FROGGS pointed us at the pause repo and i'm trying to figure out how to fix the issue

[16:13] <mst> and not require quite so much understanding of the original stuff

[16:13] <ShimmerFairy> mst: my "help" would be to reinvent things as Perl 6, because I'm almost prideful of being one of the few P6ers who see P6 from a non-P5 viewpoint :P

[16:13] <jdv79> its about sequencing

[16:13] <mst> ShimmerFairy: rewriting the code in a different programming language is not help.

[16:13] <ShimmerFairy> .oO(Why learn P5 when P6 satisfies all my current needs already?)

[16:13] <jdv79> its not detecting p6 and thus avoiding the p5 parts 

[16:13] <ShimmerFairy> mst: hence the "help" in quotes :)

[16:13] <mst> ShimmerFairy: yes, that's why we wouldn't want you to replace working code with perl6 :)

[16:14] <nine> jdv79: I only skimmed the backlog, but isn't the issue simply that a file with the exact same name already exists?

[16:14] <jdv79> no

[16:14] <jdv79> that's "supported"

[16:15] <mst> ShimmerFairy: actually, I think seeing perl6 from a non-perl5 viewpoint is the only way

[16:15] *** coffee` joined
[16:15] <ShimmerFairy> mst: if there were some way to call Perl 6 code from Perl 5 (I faintly recall hearing about something like that), then a P6-written module to handle P6 modules would be kinda neat, perhaps :)

[16:15] <jdv79> having Dist-1.00.tgz for p5 and p6 is supported because the p6 dist should be shoved under a Perl6 dir

[16:15] <mst> ShimmerFairy: perl6 is a terrible 'perl5 replacement'. it's not at all a bad language in its own right.

[16:15] <mst> (one can say similar things about lisps, too)

[16:15] <mst> (and I like lisps, too :)

[16:16] <jdv79> right now its trying to index the p6 dist before it knows its a p6 dist.  it should see a p6 dist, not do any p5 steps, and probably hit up a p6 indexer

[16:16] <ShimmerFairy> all that shifting of @_ still looks like something out of assembler or equivalently low-level :P

[16:16] <philh> p6: { a=>2, b=>3 }.kv.perl

[16:16] <GLRelia> rakudo-moar b9a76c: ( no output )

[16:16] <camelia> rakudo-moar edffe0: ( no output )

[16:16] <mst> ShimmerFairy: strawman

[16:17] <philh> p6: { a=>2, b=>3 }.Mix.kv.perl

[16:17] <GLRelia> rakudo-moar b9a76c: ( no output )

[16:17] <camelia> rakudo-moar edffe0: ( no output )

[16:17] <jdv79> p5 is fine.  pause just has a minor bug.

[16:17] * mst almost never uses shift on @_

[16:17] <jdv79> its just a major codebase:)

[16:17] <nine> ShimmerFairy: there is Inline::Perl6 (of course) for calling Perl 6 code from Perl 5

[16:17] <philh> p6: say { a=>2, b=>3 }.kv.perl

[16:17] <GLRelia> rakudo-moar b9a76c: OUTPUT«("a", 2, "b", 3).iterator␤»

[16:17] <camelia> rakudo-moar edffe0: OUTPUT«("a", 2, "b", 3)␤»

[16:17] <philh> p6: say { a=>2, b=>3 }.Mix.kv.perl

[16:17] <GLRelia> rakudo-moar b9a76c: OUTPUT«(("a", 2), ("b", 3)).iterator␤»

[16:17] <camelia> rakudo-moar edffe0: OUTPUT«(("a", 2), ("b", 3))␤»

[16:18] <philh> Should Mix.kv be doing that?

[16:18] <mst> ShimmerFairy: the sort of arrogant unresearched hostility towards perl5 that you tend to display is something that, some years ago, was one of the things that fed significant fighting between the two communites that was incredibly counterproductive

[16:18] <mst> ShimmerFairy: masak and I spent quite some time arranging to kill it

[16:18] <mst> ShimmerFairy: please don't let your youthful excitement accidentally resurrect the drama beast. it was a particularly ugly and stupid drama beast, and the world was not bettered by its presence :)

[16:19] *** dwarring left
[16:19] <mst> ShimmerFairy: http://strangelyconsistent.org/blog/how-perl-6-could-kill-us-all

[16:21] <ShimmerFairy> mst: sorry for not being clear; I'm not attacking shifting of @_, I just think it looks amusing coming from P6's signatures. I actually like the low-level-ish feel it gives.

[16:21] *** [Sno] joined
[16:22] <mst> there's a number of ways to get perl6-ish signatures in perl5 if you want them

[16:22] <mst> "all is fair if you pre-declare" is one of the things the two communities definitely have in common

[16:22] <ShimmerFairy> mst: And sorry for railing against CPAN for a while the other day, I was way too rusty on how things were planned out last time :) . I'm actually excited by the idea of being able to move o'er to CPAN eventually.

[16:23] <mst> it's fine, I killfiled you until today when I finally managed to not be annoyed about it ;)

[16:23] <mst> (because I was annoyed at you-and-all-historical-yous-I've-encountered, which really wasn't fair to you, if you see what I mean)

[16:25] <ShimmerFairy> mst: I get it. And I admit that my initial reactions to things I'm not wholly positive of tend to take some time to filter into something more rational :P

[16:26] <mst> ok, so, that makes you rather more self aware than most of the people I'm categorising as 'historical yous', and thereby faster to get yourself out of the trap

[16:27] <dalek> doc: c150897 | (Zoffix Znet)++ | / (20 files):

[16:27] <dalek> doc: Update jQuery and jQuery UI to bring in new methods for Autocomplete

[16:27] <dalek> doc: review: https://github.com/perl6/doc/commit/c15089708b

[16:27] <mst> ShimmerFairy++ # self debugging system

[16:27] <ShimmerFairy> It's a pattern I've noticed in my history, and one I hope to handle better in the future. :)

[16:27] <ZoffixWork> Hopefully that push won't explode things, but it adds a method to Autocomplete plugin that I'll use to fix https://github.com/perl6/doc/issues/84

[16:27] *** brrt left
[16:27] *** pmurias joined
[16:28] <dalek> nqp/js: d36f571 | (Pawel Murias)++ | src/vm/js/ (2 files):

[16:28] <dalek> nqp/js: Pass test 45-smartmatch.

[16:28] <dalek> nqp/js: 

[16:28] <dalek> nqp/js: Implement subrule with a block as the first argument.

[16:28] <dalek> nqp/js: (We need to check if it's how it's supposed to be implemented).

[16:28] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/d36f571868

[16:28] <dalek> nqp/js: 8e9e394 | (Pawel Murias)++ | src/vm/js/ (2 files):

[16:28] <dalek> nqp/js: Pass test 80.

[16:28] <dalek> nqp/js: 

[16:28] <dalek> nqp/js: Fix bug.

[16:28] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/8e9e394fa4

[16:28] <dalek> nqp/js: df70364 | (Pawel Murias)++ | / (2 files):

[16:28] <dalek> nqp/js: Implement and test cloning of arrays.

[16:28] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/df70364b62

[16:30] <ShimmerFairy> mst: I think my perception of P5 is like my perception of C (where I use C++): I can certainly edit minor things in C, and I would not be opposed to learning how to code C to a deeper extent, but C++ suits my needs just fine, so I'm not particularly interested in C for myself.

[16:31] <mst> ShimmerFairy: interestingly, if you flip that on its head, that's much how I feel currently

[16:31] <mst> (I like C and perl5, and am not that bothered about C++ or perl6)

[16:31] <mst> with the one exception of OMG WANT THE GRAMMAR ENGINE

[16:31] <mst> which will result in me using Inline::Perl6 :)

[16:32] <flussence> .oO( I was kinda negative-knee-jerky about the idea of moving to CPAN... but that was more an aversion to Yet Another Website Signup in general than anything wrong with CPAN itself. And I'd definitely prefer it to a github monoculture as of late. )

[16:32] <mst> flussence: "pick your SPOF, pick your poison"

[16:32] <ShimmerFairy> mst: yes, I've toyed with the idea of a "libp6regex" for C++ before, because C++ is my other primary language of choice and _god_ do I not want to touch another regex syntax/engine if I can help it :)

[16:34] <flussence> mst: the best thing about git is how easy it makes the 1-2-3 backup rule (1 offsite, 2 physical formats, 3 copies)

[16:35] <flussence> and... doesn't p5 have Marpa? I'm surprised you guys could be all excited about grammars when there's that.

[16:35] <nine> mst: considering that you were the reason I wrote Inline::Perl6, I'm eagerly awaiting you using it do do awesome things ;)

[16:36] <mst> nine: somebody sprayed all my yaks with regain.

[16:36] <mst> I'm eagerly awaiting being able to do that ;)

[16:42] * leont hapilly uses Perl 5, Perl6, C and C++, not sure what that says about me :-p

[16:43] <leont> happily

[16:43] <moritz> m: my @a = <a b c>; my $x = 0; $x++ for flat 0, @a; say $x

[16:43] <GLRelia> rakudo-moar b9a76c: OUTPUT«4␤»

[16:43] <camelia> rakudo-moar edffe0: OUTPUT«4␤»

[16:43] <japhb> leont: Oh excellent!  Can you put some of that happiness to use finishing Perl 6's C++ support?  ;-)

[16:43] *** cbk1090 joined
[16:43] <moritz> m: my $a = <a b c>; my $x = 0; $x++ for flat 0, $a; say $x

[16:43] <GLRelia> rakudo-moar b9a76c: OUTPUT«2␤»

[16:43] <camelia> rakudo-moar edffe0: OUTPUT«2␤»

[16:44] <leont> japhb: there are too many problems I can see with that, take a more naive person! :-p

[16:44] <japhb> leont: DANG!  :-D

[16:44] <cbk1090> morning #perl6

[16:45] <japhb> leont: You should know, BTW, that there is a branch that mostly-works.  It's just not been finished off and merged.

[16:45] <mst> leont: it says you're the programming equivalent of Jack Harkness :D

[16:45] <dalek> roast/glr: ecc7a5f | moritz++ | S12-methods/accessors.t:

[16:45] <dalek> roast/glr: GLR-ify S12-methods/accessors.t

[16:45] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/ecc7a5fb46

[16:45] <leont> Do I get to have that fancy coat of him with that? ;-)

[16:46] <japhb> .tell jnthn It's looking now like the limiting factor for the awesomeness of your parallelism/asynchrony/concurrency talks is *the length of the talk*.  I think we need to get you longer speaking slots.  ;-)

[16:46] <yoleaux> japhb: I'll pass your message to jnthn.

[16:47] <japhb> mst: Good C++ bindings would indeed immortalize him.

[16:47] <pmurias> mst: re terrible 'perl 5 replacement', I'm a bit afraid people will assume the upcoming 1.0 Perl 6 release means it's the "ready for Perl 5 replacement date"

[16:47] <jdv79> mst: the grammars are pretty sweet

[16:47] <japhb> Everybody talk to mst at once about different things!

[16:47] <jdv79> i tried to use damian's thing - but its kinda lame

[16:48] <japhb> jdv79: Not sure I've ever heard those two clauses in the same sentence before

[16:48] <jdv79> esp since the ver of p5 at the time broke part of it

[16:48] <moritz> are typed arrays implemented post-GLR?

[16:49] <japhb> I thought someone had put in native arrays in glr, but perhaps I was merely dreaming

[16:49] <moritz> japhb: native != typed

[16:49] <jdv79> Regexp::Grammars

[16:49] <moritz> japhb: I mean, native implies typed, but the more general typed arrays aren't native

[16:49] <japhb> moritz: I knew that, and meant the former bit.

[16:50] <cbk1090> Is it better to use a Grammar or a regex to find a pattern like ( A123-45678).  I have a Grammar for it, but it seams to only find the first occurrence.  I need to pull the example numbers out of a file that may contain many of them among other text. Also has .parsefile() changed in its functionally? I seem to have been able to do this a few months ago..? 

[16:50] <moritz> m: my $foo = [[0]]; $foo[0][0]++

[16:50] <GLRelia> rakudo-moar b9a76c: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/A3q91NZ0l_:1␤␤»

[16:50] <camelia> rakudo-moar edffe0: ( no output )

[16:51] <moritz> m: my $foo = [[0]]; say $foo[0][0].perl

[16:51] <GLRelia> rakudo-moar b9a76c: OUTPUT«0␤»

[16:51] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[16:51] <moritz> m: my $foo = [[0]]; say $foo[0].^name

[16:51] <GLRelia> rakudo-moar b9a76c: OUTPUT«Int␤»

[16:51] <camelia> rakudo-moar edffe0: OUTPUT«Array␤»

[16:51] <moritz> m: my $foo = [[0]]; say $foo.^name

[16:51] <GLRelia> rakudo-moar b9a76c: OUTPUT«Array␤»

[16:51] <camelia> rakudo-moar edffe0: OUTPUT«Array␤»

[16:51] <moritz> m: my $foo = [0]; say $foo.^name

[16:51] <GLRelia> rakudo-moar b9a76c: OUTPUT«Array␤»

[16:51] <camelia> rakudo-moar edffe0: OUTPUT«Array␤»

[16:52] <moritz> m: my $foo = [[0]]; say $foo.perl

[16:52] <GLRelia> rakudo-moar b9a76c: OUTPUT«$[0]␤»

[16:52] <camelia> rakudo-moar edffe0: OUTPUT«[[0]]␤»

[16:52] <moritz> m: my $foo = [$[0]]; say $foo[0][0].perl

[16:52] <GLRelia> rakudo-moar b9a76c: OUTPUT«0␤»

[16:52] <camelia> rakudo-moar edffe0: OUTPUT«Any␤»

[16:52] <moritz> m: my $foo = [$[0]]; $foo[0][0]++

[16:52] <camelia> rakudo-moar edffe0: ( no output )

[16:52] <GLRelia> rakudo-moar b9a76c: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/3E6SSEl2U6:1␤␤»

[16:52] <mst> pmurias: I still think we should've ditched the 5 -and- the 6 and given 'em both a name of the form 'X perl' for some X chosen by reach community, but ... eh

[16:53] <mst> at this stage that'd probably cause more confusion than anything else anyway

[16:54] <moritz> m: my $foo = [$[0]]; say $foo.perl; say $foo[0].perl; say $foo[0][0].perl

[16:54] <camelia> rakudo-moar edffe0: OUTPUT«[Any]␤Any␤Any␤»

[16:54] <GLRelia> rakudo-moar b9a76c: OUTPUT«$[0]␤0␤0␤»

[16:55] <moritz> m: my $foo = $[$[0]]; say $foo.perl; say $foo[0].perl; say $foo[0][0].perl

[16:55] <GLRelia> rakudo-moar b9a76c: OUTPUT«$[0]␤0␤0␤»

[16:55] <camelia> rakudo-moar edffe0: OUTPUT«Indexing requires an instance, tried to do: $[ (Any) ]␤  in block <unit> at /tmp/4ZDypm8Kwt:1␤␤»

[16:55] <moritz> wtf?

[16:55] <moritz> how do I make a double-array in GLR?

[16:55] <moritz> like [[0]] in p5 or nom?

[16:57] *** mstorti joined
[16:57] <ShimmerFairy> m: my $foo = [[0],]; say $foo.perl;

[16:57] <GLRelia> rakudo-moar b9a76c: OUTPUT«$[$[0]]␤»

[16:57] <camelia> rakudo-moar edffe0: OUTPUT«[[0]]␤»

[16:59] <FROGGS> moritz++ # https://github.com/perl6/glr-test-failures-annotated/blob/master/test-failures.txt

[16:59] <FROGGS> moritz: I thought about starting that yesterday

[17:01] <mst> japhb: medicore C++ bindings would immortalize him

[17:01] <jdv79> is there a way to get panda to use git over ssh instead of git:?

[17:01] <mst> japhb: really good ones would integrate with the GC properly

[17:01] <jdv79> i'm port blocked on git:

[17:02] <flussence> jdv79: it just uses whatever the META.json says to use atm, which isn't great. I've been putting https:// in all of mine for that reason but I can't do much for the rest of the ecosystem...

[17:02] <jdv79> oh:(

[17:02] <mst> you're ... git cloning ... to install packages?

[17:02] *** mstorti left
[17:03] <jdv79> welcome to "not cpan"?

[17:03] <mst> *eep*

[17:03] <ZoffixWork> :)

[17:03] <jdv79> that's why...pause:)

[17:03] <ShimmerFairy> mst: that's how panda works atm, and there's no real sense of "releasing" modules, at least not for me

[17:03] <jdv79> after dinner though ^H

[17:03] <flussence> or more specifically, welcome to "our entire infrastructure is sitting on github" :)

[17:03] <flussence> (it's scary)

[17:04] <mst> shareclouding

[17:04] <jdv79> its neat that it works

[17:04] <mst> I'm not sure 'neat' is quite the word I'd use

[17:04] <jdv79> but uh, maybe time for something more

[17:04] <ShimmerFairy> And yes, the panda system feels ad-hoc and temporary to me too :P

[17:04] <jdv79> haha 

[17:04] <mst> much like having sex down a nine foot metal pipe, while it's theoretically possible and certainly proves -something- about the participants abilities, it won't be comfortable, it isn't clever, and it wasn't designed for that

[17:05] <jdv79> c'mon.  these guys needed to start somewhere

[17:05] <jdv79> it works!

[17:05] <dalek> doc: d7719ae | (Zoffix Znet)++ | / (2 files):

[17:05] <dalek> doc: Show a "Not Found" message when nothing is found (Closes #84)

[17:05] <dalek> doc: review: https://github.com/perl6/doc/commit/d7719ae863

[17:06] <moritz> m: my @array; @array[42;23] = 17; say @array.perl;

[17:06] <GLRelia> rakudo-moar b9a76c: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <unit> at /tmp/LMujPWikPq:1␤␤»

[17:06] <camelia> rakudo-moar edffe0: OUTPUT«[Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, [Any, Any, Any, Any, Any, Any, Any, Any, Any,…»

[17:07] <moritz> m: my @array; @array[42;23] = 17;

[17:07] <GLRelia> rakudo-moar b9a76c: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <unit> at /tmp/ITCXgSim8o:1␤␤»

[17:07] <camelia> rakudo-moar edffe0: ( no output )

[17:08] <mst> jdv79: oh, yes, I'm very glad they did -something-

[17:08] <mst> I can call something 100% better than nothing while still side-eyeing it :)

[17:13] <jdv79> just fyi this little git config gem works around it - url.ssh://git@github.com/.insteadof=git://github.com/

[17:13] <leont> I think I mentioned before, p6 release toolchain is in need of more sysadmins

[17:13] <jdv79> git++ # as usual

[17:14] <flussence> jdv79++ # rtfm'ing for us all

[17:14] <leont> s/release/install/ # clarity

[17:15] <moritz> m: say (1+*).^name

[17:15] <GLRelia> rakudo-moar b9a76c: OUTPUT«WhateverCode.new␤»

[17:15] <camelia> rakudo-moar edffe0: OUTPUT«WhateverCode.new␤»

[17:16] <dalek> rakudo/glr: acd1af9 | skids++ | src/core/Str.pm:

[17:16] <dalek> rakudo/glr: Handle :0x and :nth(*) correctly and always return Positional

[17:16] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/acd1af99d1

[17:16] <dalek> rakudo/glr: c4742a6 | moritz++ | src/core/Str.pm:

[17:16] <dalek> rakudo/glr: Merge pull request #510 from skids/glr2

[17:16] <dalek> rakudo/glr: 

[17:16] <dalek> rakudo/glr: Handle :0x and :nth(*) correctly and always return Positional

[17:16] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c4742a6aaa

[17:16] * geekosaur is just figuring this stuff out...

[17:19] <dalek> rakudo/glr: 5b902d4 | moritz++ | src/Perl6/Metamodel/MultipleInheritance.nqp:

[17:19] <dalek> rakudo/glr: Do not produce empty parent lists in .^parents(:tree)

[17:19] <dalek> rakudo/glr: 

[17:19] <dalek> rakudo/glr: still seems to be a bit off

[17:19] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5b902d41aa

[17:21] *** cschwenz joined
[17:27] *** Shozan is now known as SHODAN

[17:31] <nine> moritz: I remember doing typed Hash iterators and native array iterators

[17:36] *** zakharyas joined
[17:36] *** xinming_ joined
[17:39] <nine> TypedArray is missing a "new" method. Commented out with # XXX GLR

[17:39] *** xinming left
[17:45] *** ZoffixWork left
[17:48] *** llfourn left
[17:49] <nine> what....does .* do?

[17:51] <cschwenz> p6: for <r w x o R W X O e s z f d l L p S b c u g k> -> $test { try { say "    $test = ", "/".IO.all: $test; }; };

[17:51] <GLRelia> rakudo-moar 5b902d: OUTPUT«    r = True␤    w = False␤    x = True␤    e = True␤    s = False␤    z = False␤    f = False␤    d = True␤    l = False␤»

[17:51] <camelia> rakudo-moar edffe0: OUTPUT«    r = True␤    w = False␤    x = True␤    e = True␤    s = False␤    z = False␤    f = False␤    d = True␤    l = False␤»

[17:51] <cschwenz> Any idea on when <o R W X O L p S b c u g k> will be implemented?  (They currently throw an "Unknown test ..." error.)

[17:53] <lizmat> cschwenz: when there is VM support for them

[17:54] <cschwenz> so what is needed in MoarVM to support them?

[17:55] <leont> Probably most are a SMOP, but most also aren't a high priority

[17:56] *** domidumont joined
[17:57] <leont> RWX are a bit of an anti-pattern anyway

[17:57] <cschwenz> and is there a work-around for determining if something on disk isn't what the Perl6 test method is saying it is?  (my use-case is perl6 is saying something is a directory when it is in fact one of <p S b c>.)

[17:58] <lizmat> that feels like a bug, fwiw

[17:58] <leont> Yes

[17:58] <cschwenz> hmm

[17:58] <leont> -d should return the correct thing

[17:58] <cschwenz> what should it do then?

[17:59] <leont> d = "is this a directory", so if it's true on a non-dir (I thik you're suggesting that) then that's a bug

[18:00] <cschwenz> ah, okay.  will try to get a minimal case which exhibits the behavior then.  :-)

[18:00] <leont> What is L supposed to do?

[18:01] <cschwenz> From http://design.perl6.org/S32/IO.html#File_test_methods  " L  Actual path of symbolic link (readlink)     Str"

[18:01] <lizmat> that may have just been implemented in the newio branch, and not in nom

[18:02] <lizmat> too tired now to check...  :-)

[18:02] <lizmat> good night, #perl6!

[18:02] <leont> Ah, I see

[18:02] <dalek> rakudo/glr: ed32f95 | moritz++ | src/Perl6/Metamodel/MultipleInheritance.nqp:

[18:02] <dalek> rakudo/glr: Fix .^parents

[18:02] <dalek> rakudo/glr: 

[18:02] <dalek> rakudo/glr: it used to double arrays, which somehow got undone by HLLization (?)

[18:02] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ed32f95dc1

[18:02] <cschwenz> goodnight lizmat!

[18:02] <leont> I'm missing t in that list

[18:02] <lizmat> t is waiting for VM support

[18:02] <lizmat> really afk&

[18:04] <nine> moritz++ # sounds like some hardcore debugging

[18:04] <moritz> nine: not really

[18:04] <nine> moritz++ # anyway

[18:05] <dalek> roast/glr: 46c94bb | moritz++ | S12-methods/defer-next.t:

[18:05] <dalek> roast/glr: Fix defer-next.t

[18:05] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/46c94bbb7e

[18:06] *** domidumont left
[18:07] <FROGGS> hmmm, I don't know what I should do with "foo".index("o", $pos) where $pos is bigger than 64 bits...

[18:07] <FROGGS> it throws now, but that is probably wrong... it should potentially work with bigints

[18:07] <FROGGS> maybe it should fail with >64bits not supported or so

[18:08] <moritz> FROGGS: are there any systems that support strings with > 2**64 chars?

[18:08] <FROGGS> I have no idea

[18:09] <FROGGS> but a good point

[18:10] <nine> There aren't

[18:10] *** zakharyas left
[18:10] <nine> That would be 16 exabytes

[18:11] <nine> 16 exabytes ought to be enough for anyone

[18:12] <FROGGS> nine: "64kB should be enough"... I heard that before :P

[18:12] <nine> Dear people of the distant future: I will probably still think this is a good decision for this time.

[18:13] <moritz> dear people in the  future: if you want Perl 6 to support strings with more than 16 Exabyte, please give us 128bit processes

[18:14] <laben> yeah and at least 512 terabyte of RAM

[18:14] <nine> Send them back using your nearest time machine :)

[18:14] <laben> how would you even mmap such a string?

[18:14] * nine waits for....something to happen

[18:15] <moritz> nine: if somebody planne to contact you via time machine, you wouldn't need to wait :-)

[18:16] <nine> moritz: well the IRC log is only accurate to the minute :)

[18:16] <nine> But it's over already :/

[18:17] <laben> they gave up since you asked for vm support written in actual C11, while they probably program now in C2**32

[18:20] <dalek> rakudo/glr: d161fb4 | (Stefan Seifert)++ | src/core/Mu.pm:

[18:20] <dalek> rakudo/glr: Fix dispatch:<.*> failing with "This type does not support elems"

[18:20] <dalek> rakudo/glr: 

[18:20] <dalek> rakudo/glr: No idea why returning an Array would not be ok.

[18:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d161fb4903

[18:20] <dalek> rakudo/glr: a519305 | (Stefan Seifert)++ | src/core/metaops.pm:

[18:20] <dalek> rakudo/glr: New deepmap implementation based on sequential-map

[18:20] <dalek> rakudo/glr: 

[18:20] <dalek> rakudo/glr: Does not actually deepmap for now but is enough to fix parallel-dispatch.t

[18:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a5193055bf

[18:20] *** bin_005 joined
[18:21] <nine> That's a bit unsettling: I can't find a test that actually needs deepmap to go deep :/

[18:25] <dalek> ecosystem: e99e6b8 | Carlin++ | META.list:

[18:25] <dalek> ecosystem: add FastCGI::NativeCall::PSGI

[18:25] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e99e6b8b40

[18:29] *** rurban_ joined
[18:46] <japhb> nine: 64 bits for an index into a chunk of data is not enough for everyone, even now.  However, I am certain that the Rakudo we release for 6.Christmas does not need to handle that edge case at this time.  :-)

[18:49] <laben> japhb: ooc, what is an use case where they have a chunk of data bigger than 2**64 bytes?

[18:50] <nine> We're even talking about full blown NFG strings here ;)

[18:50] *** rurban joined
[18:51] <laben> ok then, 2**64 unicode chars?

[18:52] *** virtualsue left
[18:55] *** lucasb left
[18:56] <dalek> rakudo/glr: 0ca6b57 | (Stefan Seifert)++ | src/core/metaops.pm:

[18:56] <dalek> rakudo/glr: Make deepmap actually recursive

[18:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0ca6b57f58

[18:56] <nine> This ^^^ may need another look later on. I'm not sure if replacing all lists in a nested structure by iterators really is the way to go.

[18:57] <nine> But we're at 143/1047 spec test files failing now :)

[18:57] <FROGGS> uhh, nice :o)

[18:57] <nine> And that was the last usage of gimme in the core! Now I'll never have to find out what it actually did :)

[18:58] <FROGGS> *g*

[18:58] <moritz> nine: gimme($n) tried to reify $n elements, and returned the number of actually reified elements

[18:59] <moritz> I have a weird thing here

[18:59] <nine> moritz: but that's not everything, since I've seen it called with some named arg

[18:59] <moritz> dispatch:<.*> gathers the result values in an array variable, @results

[18:59] <moritz> and then calls infix:<,>(|@results) to produce a List

[19:00] <moritz> and if @results is empty, it dies with "this type does not support elems"

[19:00] <nine> moritz: not any more, I already fixed that

[19:00] <moritz> ooh

[19:00] <nine> :)

[19:00] <nine> See the clog at 20:20 :)

[19:01] *** domidumont joined
[19:01] <moritz> nine: any idea why it died that way?

[19:02] <nine> infix:<,> was called because it used to be the Parcel constructor, so the reason for using it went away. It failed because it passed something to nqp::elems that was no nqp::list

[19:03] <nine> I replaced it by creating a List and re-used the array's $!reified. A very cheap way :)

[19:03] <moritz> aye

[19:03] <moritz> nine++

[19:05] <nine> Now t/spec/S15-nfg/many-threads.t is a weird one. It doesn't actually involve threading problems. await is called with @promises as argument. @promises is a plain old array, yet somehow the await() multi dispatch candidate is run

[19:05] *** espadrine left
[19:05] <moritz> that's weird

[19:05] <moritz> I think I've seen that before

[19:06] <moritz> though in the context of &map'ing over a multi, or so

[19:06] *** virtualsue joined
[19:06] <nine> oh yes, it does actually call the right multi candidate which again calls await

[19:07] <moritz> ah yes

[19:07] <moritz> that's because .map() picks the zero-arity candidate

[19:08] <moritz> iterating zero elements at a time

[19:08] <moritz> changing that to await($_) for @awaitables;  should fix it

[19:08] <moritz> though maybe .map also wants a patch

[19:08] *** emilbarton joined
[19:08] <moritz> (maybe needs a 'do' in front to actually return the value)

[19:09] <emilbarton> hi anybody

[19:09] <moritz> or .map({ await($_) })

[19:09] <moritz> hi emilbarton 

[19:09] <FROGGS> hi emilbarton 

[19:09] <laben> m: dd (1..3)>>.succ

[19:09] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«(2, 3, 4).iterator␤»

[19:09] <camelia> rakudo-moar edffe0: OUTPUT«(2, 3, 4)␤»

[19:09] <nine> moritz: ok, one step further, but now I get a This Seq has already been iterated error

[19:10] <emilbarton> Id' like to test the p6 language once and for all, and I'd like to have a shell. How would you do that?

[19:10] <laben> m: ((1..3)>>.succ).WHAT.say

[19:10] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«(Seq)␤»

[19:10] <camelia> rakudo-moar edffe0: OUTPUT«(Parcel)␤»

[19:10] <moritz> emilbarton: rakudo comes with a basic REPL, but it's not very advanced

[19:11] <laben> nine: why do hypers return Seq now? didn't we say that they're eager and cunsume it right away producing a list?

[19:11] <emilbarton> Is there a readable source code for it that I could reuse with Term::Readline if possible?

[19:11] <flussence> .oO( if someone needs .index to handle strings longer than the number of atoms between here and the moon, they can afford the manpower to send in a patch for it like IBM did for p5 EBCDIC recently. YAGNI )

[19:12] <emilbarton> moritz: ?

[19:12] <moritz> emilbarton: I might have misunderstood your question

[19:13] <laben> m: (1..3)>>.succ >>~~<<(2..4)

[19:13] <emilbarton> Ok, i wasn't clear, I've been using a home made perl shell for years, and Id' like to do the same with perl6

[19:13] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/x7pZ3IkMfX:1␤␤»

[19:13] <camelia> rakudo-moar edffe0: ( no output )

[19:14] <emilbarton> moritz

[19:14] <laben> m: $(1..3)>>.succ >>~~<<$(2..4)

[19:14] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/Fq0naLxpVQ:1␤␤»

[19:14] <camelia> rakudo-moar edffe0: ( no output )

[19:14] <laben> m: 1..3>>.succ >>~~<<2..4

[19:14] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/l_YJTPtGqF:1␤␤»

[19:14] <camelia> rakudo-moar edffe0: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/c4GRrss1hy:1␤␤»

[19:14] <laben> m: (1..3>>.succ) >>~~<<2..4

[19:14] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/fTguQuQvgp:1␤␤»

[19:14] <camelia> rakudo-moar edffe0: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/ncwDMyp_7a:1␤␤»

[19:15] <laben> m: ((1..3)>>.succ) >>~~<< (2..4)

[19:15] <camelia> rakudo-moar edffe0: ( no output )

[19:15] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/wnhg75a460:1␤␤»

[19:15] <nine> laben: who is the "we" who said this?

[19:18] *** sqirrel joined
[19:18] <dalek> roast/glr: 6f497bd | moritz++ | S02-types/array.t:

[19:18] <dalek> roast/glr: Fix some tests in array.t

[19:18] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/6f497bde71

[19:18] <dalek> roast/glr: 4468aa5 | moritz++ | S17-supply/map.t:

[19:18] <dalek> roast/glr: Fix S17-supply/map.t

[19:18] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/4468aa5263

[19:19] <laben> nine: http://irclog.perlgeek.de/perl6/2015-08-21#i_11094478

[19:19] <laben> i just need to know if it's intended or not

[19:20] <dalek> rakudo/glr: 5c509b1 | (Stefan Seifert)++ | src/core/asyncops.pm:

[19:20] <dalek> rakudo/glr: Fix await @ps failing with "Must specify a Promise or Channel to await on"

[19:20] <dalek> rakudo/glr: 

[19:20] <dalek> rakudo/glr: 21:07 < moritz> that's because .map() picks the zero-arity candidate

[19:20] <dalek> rakudo/glr: 21:08 < moritz> iterating zero elements at a time

[19:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5c509b101b

[19:20] *** dwarring joined
[19:23] <dalek> roast/glr: 7c1bd67 | moritz++ | S17-supply/min.t:

[19:23] <dalek> roast/glr: Add .Slip around ranges in S17-supply/min.t

[19:23] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/7c1bd673b6

[19:24] *** virtualsue left
[19:26] <nine> laben: the specs say that hyper is a variant of eager, yes. I'm actually not sure if this is really a good idea, because it makes hypers useless for setting up pipelines.

[19:26] <FROGGS> m: use Test; is ({ try { eager map    { die }, 1,2,3 }; 42 }()), 42, "die in map";

[19:26] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Died␤  in block  at /tmp/PX_jgOWACn:1␤  in block <unit> at /tmp/PX_jgOWACn:1␤␤»

[19:26] <camelia> rakudo-moar edffe0: OUTPUT«ok 1 - die in map␤»

[19:26] <FROGGS> m: use Test; is ({ try { eager grep   { die }, 1,2,3 }; 42 }()), 42, "die in grep";

[19:26] <GLRelia> rakudo-moar 0ca6b5: OUTPUT«Died␤  in block  at /tmp/OFIHUeKkaV:1␤  in block <unit> at /tmp/OFIHUeKkaV:1␤␤»

[19:26] <camelia> rakudo-moar edffe0: OUTPUT«ok 1 - die in grep␤»

[19:27] <moritz> seems eager isn't eager enough?

[19:27] <laben> but then you need to combine lazy with auto-threading, isn't that a mess to get the right result order?

[19:28] *** sqirrel left
[19:28] <nine> laben: that's....an interesting thought

[19:28] <moritz> well, if you use autothreading, you can't rely on laziness at the same time

[19:30] <nine> I think, I have to spend some more time with HYPER

[19:31] <moritz> m: multi a() { 0 }; multi a($) { 1 }; say map &a, 'x'

[19:31] <GLRelia> rakudo-moar 5c509b: OUTPUT«0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...␤»

[19:31] <camelia> rakudo-moar edffe0: OUTPUT«1␤»

[19:31] <moritz> ok, I'll try to fix that :-)

[19:32] <nine> moritz: thanks! I wouldn't know how.

[19:33] <moritz> nine: one line, I hope :-)

[19:33] <moritz> $count = 1 if $count == 0 && &block.arity >= 1

[19:36] <moritz> m: multi a() { 0 }; multi a($) { 1 }; say &a.arity

[19:36] <GLRelia> rakudo-moar 5c509b: OUTPUT«0␤»

[19:36] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[19:36] <moritz> m: multi a() { 0 }; multi a($) { 1 }; say &a.count

[19:36] <GLRelia> rakudo-moar 5c509b: OUTPUT«Inf␤»

[19:36] <camelia> rakudo-moar edffe0: OUTPUT«Inf␤»

[19:36] <moritz> ups.

[19:37] <dalek> roast/glr: 08eeb00 | (David Warring [email@hidden.address] | integration/advent2010-day (2 files):

[19:37] <dalek> roast/glr: GLR tweaks to advent 2010 days 08 & 11

[19:37] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/08eeb0004a

[19:39] *** domidumont left
[19:40] <nine> We're down to 138!

[19:40] <nine> 138/1047 spec test files failing

[19:41] <jdv79> insne

[19:41] <jdv79> *insane

[19:41] *** kaare_ left
[19:42] * dwarring moritz++ for tes failure list - https://github.com/perl6/glr-test-failures-annotated/blob/master/test-failures.txt

[19:45] *** llfourn joined
[19:49] *** llfourn left
[19:50] *** CQ left
[19:50] <raydiak> hello #perl6

[19:51] <FROGGS> hi raydiak 

[19:51] <raydiak> hi FROGGS, how's it going?

[19:51] <FROGGS> raydiak: quite good :o)

[19:52] <raydiak> glad to hear it :)

[19:53] <raydiak> how's the GLR going?  any end to the semantic changes in sight yet?

[19:54] <raydiak> I'm assuming some of my modules have some bitrot, but wasn't sure if I should address them yet or just wait until after the GLR when I'll have to go through and fix a bunch of stuff anyway

[19:55] *** mjgardner left
[19:55] <laben> i've been testing around with the existent ecosystem to see the impact of glr and try to fix it. can you tell me which are your modules?

[19:56] <raydiak> App::Pray, Image::PNG::Portable, Math::Symbolic...still thinking...

[19:57] *** mjgardner joined
[19:57] <raydiak> but I think some of them may have had breakages not related to glr, I've been away a while

[19:57] <laben> got a github?

[19:57] <emilbarton> moritz: say "hi" 

[19:58] <emilbarton> moritz: perl6 Argument list too long

[19:58] <raydiak> yes raydiak on github

[19:58] <emilbarton> moritz: perl6: Success

[19:58] <emilbarton> is it normal?

[19:58] <raydiak> oh Git::PurePerl is another one I at least started

[19:59] <raydiak> some of them don't have tests other than 'use'ing the module, sadly

[19:59] <raydiak> oh!  can't forget Inline::Lua too...

[20:01] <raydiak> and Math::ThreeD; I think that's all of them on the ecosystem

[20:02] <laben> first one: Math::Symbolic builds and test fine on recent (may not be latest) nom, but fails building Grammar.pm6 on glr with this error "Cannot assign to an immutable value"

[20:02] <laben> i can investigate for you if you want

[20:05] *** pmurias left
[20:05] <raydiak> if you feel like it, I'm certainly not turning away the help :)  but my question was more about how close the glr semantics are to being done, so I can plan my time appropriately, since I'm not very aware of what's happening with it (the glr or even rakudo in general) right now

[20:06] <laben> semantics should be fine unless you make (heavy) usage of hyper ops

[20:07] <laben> if you dont find them fine it should be a bug or a misuse under the new assumptions

[20:09] <emilbarton> I'm sorry to insist but it seems my usage or installation of perl6 lacks something, could you help me start with the perl6 interpreter?

[20:10] <raydiak> do we have the glr changes in any kind of document to get myself up to speed without re-reading the syns and scouring for the differences?

[20:10] <dalek> roast/glr: 59b6d26 | (David Warring [email@hidden.address] | integration/advent2012-day0 (2 files):

[20:10] <dalek> roast/glr: GLR tweaks to advent 2012 days 03 & 09

[20:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/59b6d268ce

[20:11] <laben> the famous jnthn Github gist is the most recent doc, i dont think much work has been done for now on perl6/docs for now regarding glr

[20:13] *** fame joined
[20:13] <raydiak> url of jnthn++'s gist?

[20:13] *** fame left
[20:14] *** fame joined
[20:14] *** fame left
[20:14] <laben> should be this one https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[20:15] <raydiak> great, thanks for the info laben++ :)

[20:16] <nine> emilbarton: details would help, like how you installed rakudo and what error messages you get

[20:16] <raydiak> emilbarton: what specifically is going wrong?

[20:16] <raydiak> heh

[20:17] *** xfix left
[20:17] <emilbarton> as I said if I type "say 'hi'" I get Arg list too long ; Success

[20:17] <emilbarton> I've rarely been told hi this way

[20:17] <FROGGS> emilbarton: what is your 'perl6 --version'?

[20:18] <emilbarton> FROGGS: Arg list too long ; Success with that much delay

[20:19] <nine> emilbarton: what shell are you using?

[20:19] <emilbarton> bash

[20:19] <FROGGS> O.o

[20:20] <FROGGS> emilbarton: that does not even sound like a perl6

[20:20] <FROGGS> emilbarton: where do you got it from?

[20:20] <emilbarton> it's rakudo /opt/rakudobrew/bin/perl6

[20:20] <emilbarton> git, recently

[20:20] <laben> raydiak: i suspect your Math::Symbolic code might be a little too much for me

[20:21] <raydiak> laben: me too :P  that one needs heavy revision bordering on a rewrite

[20:21] <FROGGS> emilbarton: can you open that file in an editor, and paste it into a gist?

[20:21] <nine> Or paste it in here, it should just be 2 lines

[20:21] <FROGGS> (/opt/rakudobrew/bin/perl6 should be a shell script)

[20:22] <laben> raydiak: what i can tell for now is that it seems the Op hook up that you do to transform e.g. .inverse in a sub does not work and stays a Str

[20:22] * raydiak goes to remind himself what all that looked like

[20:23] *** darutoko left
[20:23] <dalek> rakudo/glr: 185fc07 | (Stefan Seifert)++ | src/core/metaops.pm:

[20:23] <dalek> rakudo/glr: Fix Seq already iterated issues with hyper ops

[20:23] <dalek> rakudo/glr: 

[20:23] <dalek> rakudo/glr: Have deepmap always return a List as the spec still requires. This should fix

[20:23] <dalek> rakudo/glr: several issues with already iterated Seq.

[20:23] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/185fc0752c

[20:24] <nine> laben: ^^^

[20:24] *** mjgardner left
[20:25] <laben> nine: rebuilding right now, exactly what should this fix?

[20:28] <nine> Odd "This Seq has already been iterated" messages involving code using hyper ops

[20:29] <emilbarton> FROGGS: maybe I have moved the rakudobrew dir after installation...

[20:29] *** KCL joined
[20:29] <FROGGS> ohh

[20:29] <FROGGS> emilbarton: it is not relocatable yet :o)

[20:30] <laben> m: (1..3)>>.succ >>~~<<(2..4)

[20:30] <GLRelia> rakudo-moar 185fc0: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/t9em5h3dUI:1␤␤»

[20:30] <camelia> rakudo-moar edffe0: ( no output )

[20:31] <emilbarton> it's bizarre while I was talking to you my rakudobrew disappeared

[20:32] *** KCL_ left
[20:33] <emilbarton> no man we are not alone

[20:34] <nine> laben: oh, that's something else

[20:35] <laben> nine: sorry i sent the wrong test command while i was testing elsewhere

[20:36] <nine> laben: but I may have a fix for that already...just running spec tests

[20:36] <laben> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b>>.pred

[20:36] <GLRelia> rakudo-moar 185fc0: OUTPUT«True True True␤»

[20:36] <camelia> rakudo-moar edffe0: OUTPUT«True True True␤»

[20:37] <raydiak> laben: ah I see where you meant in math::symbolic...looks like more concequences of poorly-considered design though; one of the parts I really needed to do when I left off on that one was a better API, so there shouldn't even really be strings in there

[20:37] <laben> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b.map(*.pred)

[20:37] <GLRelia> rakudo-moar 185fc0: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/KinKP0_HyS:1␤␤»

[20:37] <camelia> rakudo-moar edffe0: OUTPUT«True True True␤»

[20:37] <laben> nine: works as expected, nine++

[20:37] <FROGGS> sure?

[20:38] <nine> I don't think so

[20:38] <laben> well, afaicu

[20:38] <laben> no, i meant the eager-ness of the single hyper, not the impl od the dwimmy one

[20:38] <laben> s/od/of

[20:39] <nine> To be precise: I fixed >>

[20:39] <laben> nine: yeah, that was the one i was referring to. since it doesnt makes Seq anymore, it doesnt have problems even if iterated twice

[20:40] <masak> m: say [[0]] # doesn't create a nested array post-GLR?

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«0␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«0␤»

[20:40] <laben> m: dd http://en.wikipedia.org/wiki/Special:Search?go=Go&search=0

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QjkCVQa60u␤Confused␤at /tmp/QjkCVQa60u:1␤------> 3dd http:7⏏5//en.wikipedia.org/wiki/Special:Search?g␤    expecting any of:␤        colon pair␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/beOEc0xXFl␤Confused␤at /tmp/beOEc0xXFl:1␤------> 3dd http:7⏏5//en.wikipedia.org/wiki/Special:Search?g␤    expecting any of:␤        colon pair␤»

[20:40] <masak> hm, how do I...?

[20:40] <laben> m: dd [ [0] ]

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«[0]␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«$ = [[0]]␤»

[20:40] <laben> m: dd [ $[0] ]

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«[0]␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«$ = [Any]␤»

[20:40] <masak> thank you.

[20:40] <laben> m: dd $[ [0] ]

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«$[0]␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«$v = Any␤»

[20:40] <laben> m: dd $[ $[0] ]

[20:40] <GLRelia> rakudo-moar 185fc0: OUTPUT«$[0]␤»

[20:40] <camelia> rakudo-moar edffe0: OUTPUT«Indexing requires an instance, tried to do: $[ (Any) ]␤  in block <unit> at /tmp/QAuEht7C6C:1␤␤»

[20:41] <laben> m: dd [(0)]

[20:41] <GLRelia> rakudo-moar 185fc0: OUTPUT«[0]␤»

[20:41] <camelia> rakudo-moar edffe0: OUTPUT«$ = [0]␤»

[20:41] <laben> m: dd [([0])]

[20:41] <camelia> rakudo-moar edffe0: OUTPUT«$ = [[0]]␤»

[20:41] <GLRelia> rakudo-moar 185fc0: OUTPUT«[0]␤»

[20:41] <laben> oh well

[20:42] <rindolf> Zoffix: here?

[20:42] <laben> raydiak: actually i started fixing that code, but it seems there are various issues. if you say you're going to rewrite it anyway, i'm skipping to another module

[20:43] <dalek> rakudo/glr: 7f8a196 | (Stefan Seifert)++ | src/core/metaops.pm:

[20:43] <dalek> rakudo/glr: Fix HYPER(\&op, \left, \right) on Ranges

[20:43] <dalek> rakudo/glr: 

[20:43] <dalek> rakudo/glr: Fixes Method 'is-lazy' not found for invocant of class 'Range' when

[20:43] <dalek> rakudo/glr: tyring to do: (1..3)>>.succ >>~~<<(2..4)

[20:43] <dalek> rakudo/glr: 

[20:43] <dalek> rakudo/glr: Thanks to laben++ for reporting

[20:43] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7f8a196f66

[20:43] *** geekosaur left
[20:44] <raydiak> laben: yeah I got too enthusiastic about that one :)  it turned into a mess I'll have to untangle in more profound ways

[20:44] *** rurban left
[20:44] *** llfourn joined
[20:45] <raydiak> don't even think about git::pureperl, it's not even done being converted from p5

[20:45] <raydiak> just did enough that it'll clone small repos

[20:45] *** geekosaur joined
[20:46] <laben> m: (1..3)>>.succ >>~~<<(2..4)

[20:46] <GLRelia> rakudo-moar 185fc0: OUTPUT«Method 'is-lazy' not found for invocant of class 'Range'␤  in block <unit> at /tmp/8HSM1y0sdM:1␤␤»

[20:46] <camelia> rakudo-moar edffe0: ( no output )

[20:46] <laben> is GLRelia not updated?

[20:46] <laben> lemme rebuild myself

[20:47] <laben> s/rebuild/rebuild it/ # damn english

[20:48] *** llfourn left
[20:50] <laben> raydiak: no problems on Git::PurePerl, one of its deps (digest) it's actually messed up on glr and i cant even touch it (dont understand that golfed code)

[20:51] <raydiak> laben: App::Pray (which also depends on Image::PNG::Portable) is probably my first concern, and is one of the more readable ones

[20:51] <raydiak> as long as compress::zlib is working on glr, which i::p::p requires

[20:51] <laben> raydiak: yea, i'm starting from the deps, it's quite a long way there

[20:53] <emilbarton> what's the difference between rakudobrew and rakudo?

[20:53] *** telex left
[20:54] *** telex joined
[20:54] <dalek> roast/glr: b50b3f9 | (David Warring [email@hidden.address] | integration/advent2012-day13.t:

[20:54] <dalek> roast/glr: GLR tweaks for advent2012-day13.t

[20:54] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b50b3f9b9f

[20:54] <raydiak> emilbarton: rakudobrew is a tool for automatically building and installing rakudo from source, instead of doing each step by hand

[20:54] <emilbarton> ok

[20:54] <laben> m: dd ((1..3)>>.succ) >>~~<< (2..4)

[20:54] <GLRelia> rakudo-moar 7f8a19: OUTPUT«(Bool::True, Bool::True, Bool::True)␤»

[20:54] <camelia> rakudo-moar edffe0: OUTPUT«(Bool::True, Bool::True, Bool::True)␤»

[20:55] <laben> nine++ # It Works!

[20:55] <laben> m: dd 1..3>>.succ >>~~<< 2..4

[20:55] <GLRelia> rakudo-moar 7f8a19: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/3nc3FUWQ4x:1␤␤»

[20:55] <camelia> rakudo-moar edffe0: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 3 elements␤  in block <unit> at /tmp/Ep3R4bT9lD:1␤␤»

[20:55] <laben> m: dd (1..3)>>.succ >>~~<< 2..4

[20:55] <GLRelia> rakudo-moar 7f8a19: OUTPUT«(Bool::True, Bool::True, Bool::True)␤»

[20:55] <camelia> rakudo-moar edffe0: OUTPUT«(Bool::True, Bool::True, Bool::True)␤»

[20:59] *** rindolf left
[20:59] <raydiak> laben: an easier one might be inline::lua which has no module deps, if nativecall works and you have lua 5.1 or luajit installed

[21:00] *** rindolf joined
[21:01] <laben> raydiak: actually i just rebootstrapped panda so i was going for compress::zlib::raw

[21:01] <raydiak> cool

[21:01] <laben> but i can do that too

[21:01] <raydiak> inline::lua doesn't even build on non-glr rakudo it appears, so...

[21:03] *** bin_005 left
[21:03] *** bin_005 joined
[21:04] <emilbarton> already better, now can you just tell me if there is a module that would allow me to launch a shell session like Term::Readline?

[21:04] <masak> 'night, #perl6

[21:05] <laben> raydiak: compress::zlib and ::raw seem fine for now

[21:05] <raydiak> good night masak

[21:06] <raydiak> laben: cool :)

[21:07] <laben> raydiak: confirmed for String::CRC32 and Image::PNG::Portable too, now checking App::Ray

[21:08] <raydiak> unfortunately I think png might be one of the ones with nearly no test coverage, so those problems might not show up until Pray reveals them

[21:09] <laben> pray build and tests fine, trying to run it tells me this error "Width and/or height must be specified"

[21:09] <laben> in sub render at lib/Pray.pm6:19

[21:10] <raydiak> try like pray --width=32 examples/scene-07.json or so iirc

[21:10] *** vendethiel joined
[21:10] <laben> Cannot modify an immutable Int   in method rotate at lib/Pray/Geometry/Matrix3D.pm6:66

[21:11] <raydiak> hm another one of those

[21:11] * vendethiel waves

[21:11] <raydiak> \o vendethiel 

[21:13] <laben> raydiak: it seems i forgot to remind myself and you that multidim array syntax is not functional for now

[21:14] <laben> indeed it was that, dunno how to help you there for now

[21:14] <raydiak> laben: like lol?

[21:14] <laben> exactly

[21:14] *** zakharyas joined
[21:14] <raydiak> it's just nested arrays, don't think I used any lol in pray

[21:17] <raydiak> m: [[1,2,3],[4,5,6],[7,8,9]].perl.say

[21:17] <GLRelia> rakudo-moar 7f8a19: OUTPUT«[$[1, 2, 3], $[4, 5, 6], $[7, 8, 9]]␤»

[21:17] <camelia> rakudo-moar edffe0: OUTPUT«[[1, 2, 3], [4, 5, 6], [7, 8, 9]]␤»

[21:17] <raydiak> like that...appears to work

[21:18] <jdv79> i think i may have the beginning of a fix for pause

[21:18] <jdv79> scary

[21:18] <laben> it probably depends on how you built that, consider now there is much less auto-flattening

[21:18] <laben> i'll try to go deeper

[21:19] <jdv79> are we below 100 failing tests yet?

[21:19] <nine> 137

[21:20] <jdv79> does one have to rebuild nqp/moar since a few days ago?

[21:20] <jdv79> or is rakudo enough

[21:21] <nine> nqp is unchanged

[21:22] <laben> raydiak: there are indeed flattening troubles, i fixed it. now i get another error, i'll see how far i can get, then publish a gist for you to study

[21:23] <rindolf> jdv79: hi, sup?

[21:23] <raydiak> laben: nice, tyvm for all the time you're taking :)

[21:24] <emilbarton> Ok now that everything is ok I can say good bye, and thank you!

[21:24] *** emilbarton left
[21:24] <jdv79> rindolf: not much.  you?

[21:25] <jdv79> trying to fix pause for p6 on one hand

[21:25] <rindolf> jdv79: I removed #perl from my autojoin list.

[21:25] <jdv79> fantastic;  why?

[21:25] <rindolf> jdv79: and came up with a new humour bit.

[21:25] <rindolf> jdv79: what's fantastic?

[21:26] <jdv79> your autojoin change

[21:26] *** zakharyas left
[21:26] <rindolf> jdv79: what's so great about it?

[21:26] <jdv79> i was hoping you'd tell me

[21:26] <rindolf> jdv79: I have my reasons.

[21:27] <jdv79> ok

[21:27] <rindolf> jdv79: I can tell you them in private.

[21:27] <jdv79> that's ok 

[21:27] <jdv79> going to spw?

[21:27] <rindolf> jdv79: what's that?

[21:27] <rindolf> Spanish Perl Workshop?

[21:28] <rindolf> swiss PW?

[21:28] <jdv79> swiss

[21:28] <jdv79> next week

[21:28] <dalek> roast/glr: 1a710c0 | (David Warring [email@hidden.address] | integration/advent2012-day14.t:

[21:28] <dalek> roast/glr: GLR tweak for advent2012-day14.t

[21:28] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/1a710c0b41

[21:28] * sjn thinks the Swiss Perl Workshop should be called chpw :)

[21:29] <jdv79> i think that's the longest git user name i've ever seen

[21:31] <rindolf> jdv79: I don't have plans to go there.

[21:32] <jdv79> hmm, i must be running the spectests - my leg is starting to burn

[21:32] <jdv79> geez

[21:44] *** rangerprice joined
[21:47] <laben> raydiak: i'm a bit in a pinch after this https://gist.github.com/anonymous/8bee82105f07e7613197, you'll need to check it out yourself.

[21:47] <laben> raydiak: i get Start argument to substr out of range. Is: 647, should be in 0..629; use *647 if you want to index relative to the end   in method update_preview at lib/Pray/Output.pm6:191

[21:49] <raydiak> laben: hm...yeah I'll build the glr branch and see how it goes...thanks again, this is a good start

[21:51] <laben> raydiak: good luck, i'm goning to bed now, it's a bit late here

[21:51] <laben> good night|work #perl6

[21:52] *** laben left
[21:57] <jdv79> what does () mean now?

[22:00] <jdv79> m: use Test; is (if 0 { 42 }), (), "if evaluates to () when no block chosen" # a todo test

[22:00] <GLRelia> rakudo-moar 7f8a19: OUTPUT«ok 1 - if evaluates to () when no block chosen␤»

[22:00] <camelia> rakudo-moar edffe0: OUTPUT«not ok 1 - if evaluates to () when no block chosen␤␤# Failed test 'if evaluates to () when no block chosen'␤# at /tmp/XXDuEqBZNB line 1␤# expected: ''␤#      got: (Empty)␤»

[22:01] <jdv79> guessing that's cool under glr

[22:10] *** Timbus left
[22:11] *** AlexDani` joined
[22:13] *** AlexDaniel left
[22:15] *** rurban_ left
[22:15] <rangerprice> Hi

[22:22] *** rindolf left
[22:23] *** vendethiel left
[22:27] *** maddingue joined
[22:39] *** vendethiel joined
[22:43] *** coffee` left
[22:43] *** coffee` joined
[22:45] *** llfourn joined
[22:49] *** llfourn left
[22:58] *** TEttinger joined
[22:59] *** cschwenz left
[23:00] *** yqt joined
[23:02] *** mjgardner joined
[23:03] *** RabidGravy left
[23:14] *** leont left
[23:43] *** mjgardner left
[23:47] *** mjgardner joined
[23:48] *** vendethiel left
