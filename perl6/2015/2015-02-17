[00:03] *** TgMts_ joined
[00:05] *** skids joined
[00:05] *** TgMts left
[00:07] <raydiak> hi again #perl6

[00:07] <timotimo> hello raydiak 

[00:08] <timotimo> i haven't had the opportunity to play with your assuming implementation

[00:08] <raydiak> to correct something slightly beside the point which I said earlier, slicing it wouldn't flatten, it's the grepping over it that flattens it

[00:11] <timotimo> brr. how do i generate a link for review/request for comment with the "new" wordpress editor?

[00:12] *** davercc joined
[00:12] <timotimo> https://p6weekly.wordpress.com/?p=409&shareadraft=54e28775e03e7

[00:12] <timotimo> kind of feels like i'm missing at least one thing

[00:13] <raydiak> (but since I need the indices, it's all beside the point anyway...mainly I'm wishing there was a way to pre-bind args to CURRIED() into the holes so there isn't a loop in it, as the design docs imply it should work that way)

[00:13] <timotimo> mhm

[00:14] *** TgMts_ left
[00:15] *** TgMts joined
[00:18] <timotimo> i should mention the idea collection for GSoC

[00:20] <timotimo> annoyingly, the things from the google docs text have not been put into the wiki yet

[00:26] <timotimo> https://p6weekly.wordpress.com/?p=409&shareadraft=54e28a912d02b

[00:35] <timotimo> well, i just went ahead and published the post

[00:37] <raydiak> looks good; timotimo++ 

[00:43] *** kurahaupo1 joined
[00:44] *** echowuhao left
[00:53] *** Hor|zon joined
[00:58] *** Hor|zon left
[00:58] <masak> 'night, #perl6

[00:58] * raydiak suspects his problem is not solvable without EVAL, language design changes, or maybe some sorta nqp:: stuff

[00:59] <raydiak> good night masak 

[01:03] *** Alina-malina joined
[01:03] *** Alina-malina left
[01:03] *** Alina-malina joined
[01:07] *** yeahnoob joined
[01:09] <raydiak> well, or maybe encapsulation-breaking metafiddlyness with .set_value() and so forth, though even that seems to fail where it gets a BOOTSTRAPATTR instead of an Attribute, which I assume circles back to nqp::stuff I don't know well

[01:10] *** TgMts left
[01:11] *** TgMts joined
[01:17] *** coffee` left
[01:17] *** MilkmanDan left
[01:18] *** kurahaupo1 left
[01:27] *** adu joined
[01:39] *** MilkmanDan joined
[01:43] <skids> r: Buf.new(256, -1).say; say Buf ~~ buf8; say Buf ~~ Buf[uint8]; # Do I misremember?  ISTR punned Buf[] used to know it was Buf[uint8]?

[01:43] <camelia> rakudo-{parrot,moar} d99fe0: OUTPUT«Buf:0x<00 ff>␤False␤False␤»

[01:46] *** kurahaupo1 joined
[01:49] <timotimo> m: say Buf.new.of

[01:49] <camelia> rakudo-moar d99fe0: OUTPUT«(uint8)␤»

[01:58] *** chenryn joined
[02:04] *** TgMts left
[02:06] *** TgMts joined
[02:10] *** Peter_R left
[02:10] *** zacts left
[02:12] *** Peter_R joined
[02:12] * ruoso got the first half of the Grammar::EBNF done, it can parse grammars, now I just need to implement the actions to generate a Perl 6 grammar on the fly...

[02:13] <ruoso> https://github.com/ruoso/Grammar-EBNF

[02:14] *** kurahaupo1 left
[02:15] <raydiak> r: say buf8 ~~ Buf; say Buf[uint8] ~~ Buf; # skids 

[02:15] <camelia> rakudo-{parrot,moar} d99fe0: OUTPUT«True␤True␤»

[02:18] <raydiak> ooh nice ruoso++

[02:18] <ruoso> raydiak: thanks..

[02:19] <ruoso> I'm kind of failing to find how to add a new syntax to the language

[02:19] <ruoso> I want to allow something like: ebnf-gramma { ... }

[02:19] <ruoso> minus the typo

[02:20] *** Akagi201_ left
[02:20] <raydiak> like a slang?

[02:20] *** Mouq joined
[02:21] <ruoso> yeah

[02:22] *** TgMts left
[02:24] * raydiak is looking at other slangs to see how they work

[02:25] * ruoso wonder if https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6 is a valid example

[02:25] <raydiak> precisely the one I was just looking at :)

[02:27] <raydiak> do you have something you've already tried which doesn't work?

[02:28] <ruoso> I am trying to mimick the slang-sql right now... but I was hoping to find some doc instead of just blindly copy-n-pasting

[02:28] *** ggoebel111111114 left
[02:28] *** TgMts joined
[02:30] <raydiak> I am not sure if we have good docs for that atm; don't know if it's an entirely 'stable' part of the spec yet

[02:30] <skids> radiak: Yeah, it works that way of course. but It should work the way I originally posted, I think.

[02:31] <raydiak> skids: I thought it was Narrower ~~ Wider

[02:31] <skids> They should be the same exact class.

[02:32] *** TgMts left
[02:33] <skids> Erm, well, role.

[02:33] <skids> m: role A[$f = 1] { }; say A[1] ~~ A[]; # I would expect this would work as well

[02:33] <camelia> rakudo-moar d99fe0: OUTPUT«False␤»

[02:33] <raydiak> skids: but different parameterization...e.g. Array[Int] ~~ Array[Str] is False, no?

[02:34] <skids> Yes, but with a default it isn't different parameterization.

[02:34] <raydiak> ah right, I see what you meant :)

[02:34] *** telex left
[02:34] *** Mouq left
[02:36] *** telex joined
[02:36] *** TgMts joined
[02:38] *** kurahaupo1 joined
[02:39] *** ggoebel111111114 joined
[02:39] *** TgMts left
[02:43] *** Hor|zon joined
[02:45] *** ilbot3 left
[02:46] <raydiak> skids: but then how would we refer to the role generically regardless of parameterization when that's what you're trying to say?  e.g. buf16 ~~ Buf 

[02:47] <raydiak> maybe Buf[*] or something?

[02:47] *** Hor|zon left
[02:48] *** ilbot3 joined
[02:50] <raydiak> m: buf8 ~~ Buf[*] # apparently that already works

[02:50] <camelia> rakudo-moar d99fe0: ( no output )

[02:50] <raydiak> m: say buf8 ~~ Buf[*] 

[02:50] <camelia> rakudo-moar d99fe0: OUTPUT«True␤»

[02:56] *** TgMts joined
[02:57] <skids> Hrm.  I wonder what that does.

[02:59] <raydiak> it seems to do the same as Buf's current meaning, until...

[02:59] <raydiak> m: say Buf[*].new

[02:59] <camelia> rakudo-moar d99fe0: OUTPUT«Buf[Whatever]:0x<>␤»

[03:00] *** Mouq joined
[03:00] *** TgMts left
[03:01] * raydiak guessed someone put it there having already thought about this problem

[03:03] <skids> OK, maybe "Buf ~~ buf8" should be False as is. but "Buf.new ~~ buf8" should be True.  Because instantiation has to choose parameterization.

[03:04] <raydiak> definitely agree there

[03:04] *** noganex joined
[03:04] <raydiak> m: Buf.new.WHAT # so this should be "Buf[uint8]" too I guess

[03:04] <camelia> rakudo-moar d99fe0: ( no output )

[03:04] <raydiak> m: say Buf.new.WHAT # gah

[03:04] <camelia> rakudo-moar d99fe0: OUTPUT«(Buf)␤»

[03:05] <skids> I would say so.

[03:06] <raydiak> can't think of any reason an object should remember whether it was paramterized via default or not

[03:07] *** noganex_ left
[03:07] <skids> Also having Buf.new.WHAT be seen as Buf[uint8] avoids a YAPAE.

[03:11] <raydiak> or replaces it...how painful is (Buf ~~ Buf.new) === False ?

[03:12] <raydiak> well, that probably doesn't do what I thought for a moment anyway :)

[03:12] <skids> What are the smartmatch rules for class/role ~~ object?

[03:12] <raydiak> m: say Str ~~ Str.new

[03:12] <camelia> rakudo-moar d99fe0: OUTPUT«False␤»

[03:13] <raydiak> m: say Array ~~ Array.new

[03:13] <camelia> rakudo-moar d99fe0: OUTPUT«use of uninitialized value of type Array in numeric context  in block <unit> at /tmp/ht1iJJLmP2:1␤␤True␤»

[03:13] <raydiak> m: say Bool ~~ Bool.new

[03:13] <camelia> rakudo-moar d99fe0: OUTPUT«False␤»

[03:13] <raydiak> dunno :)

[03:13] <skids> I'm trying to think if there's a way to cause trouble with 'role A [...] { }; class B does A[...] { }; role A[...] { }'

[03:14] <skids> (Which actually I am productively using a construct like that)

[03:16] <ruoso> hmmm... I did manage to define the slang, but if I try to delegate the parsing to a separate grammar, it fails with No such method 'OTHERGRAMMAR' for invocant of type 'Perl6::Grammar+{Grammar::EBNF::Slang}'

[03:16] <raydiak> skids: what does it do? be able to refer to B from inside the 2nd A?

[03:17] <raydiak> ruoso: can you gist it?

[03:19] <ruoso> https://github.com/ruoso/Grammar-EBNF/blob/master/lib/Grammar/EBNF.pm

[03:19] <skids> raydiak: Yes, exactly: https://github.com/skids/perl6sum/blob/master/lib/Sum/Tiger.pm6#L489

[03:28] <raydiak> ruoso: I've cloned; what's the easiest way to reproduce it?

[03:29] <ruoso> perl6 -Ilib t/004_slang.t

[03:29] <ruoso> If I replace the foreign-grammar rule with literals, it works

[03:31] * raydiak doesn't see that rule

[03:32] <ruoso> which rule?

[03:32] <raydiak> maybe I don't know what you mean by "foreign-grammar rule"

[03:32] <ruoso> I mean <Grammar::EBNF::MetaSyntax::TOP> in the Slang role

[03:33] *** BenGoldberg left
[03:33] *** BenGoldberg joined
[03:33] <Mouq> ruoso: I came across that a few weeks ago. Let me see if I remember how to fix it

[03:33] <raydiak> ah I see

[03:33] <ruoso> Mouq: thanks...

[03:35] <Mouq> Oh! yes. Use something like <EBNF=.FOREIGN_LANG: 'Grammar::EBNF::MetaSyntax', 'TOP'>

[03:37] * ruoso tries it

[03:38] <Mouq> ruoso: Sorry slangs are still a pain to work with. I want to make them first class at some point; they're essentially still a hack :P

[03:38] <ruoso> closer... but now I get Cannot find method '!cursor_init'

[03:42] <Mouq> Hm :/ I can't quite figure out how that would happen

[03:44] <ruoso> oh, looking at the code, may be related to the %*LANG hash

[03:44] * ruoso tries to register the custom lang in there

[03:44] <Mouq> Oh duh. you're absolutely correct

[03:45] <Mouq> This is what I'm going off of, btw (a little messy): https://gist.github.com/Mouq/bdddda34e4e0c5569b35

[03:47] <ruoso> yeah... that did work

[03:47] <Mouq> \o/

[03:49] <ruoso> cool, now I just need to use the MOP to translate the Grammar::EBNF into a regular Perl 6 grammar

[03:53] <Mouq> ruoso: You don't necessarily need to use the MOP to do that

[03:54] *** echowuhao joined
[03:54] <Mouq> ruoso: Potentially, you could construct it the same way regexes are constructed in Perl 6/NQP, ( Particularly, for building the rules: https://github.com/perl6/nqp/blob/master/src/QRegex/P6Regex/Actions.nqp )

[03:55] <Mouq> ruoso: Although I don't know if that's what you're interested in/what your goals are

[03:56] <Mouq> m: use QAST:from<NQP>;

[03:56] <camelia> rakudo-moar d99fe0: ( no output )

[03:59] *** davercc left
[04:02] <ruoso> Mouq: I'm not sure, it's probably easier to build them with the MOP instead of using macro-like behavior

[04:04] <ruoso> EBNF is a fairly simple language after all

[04:16] <dalek> rakudo-star-daily: 4a6dc1b | coke++ | log/ (14 files):

[04:16] <dalek> rakudo-star-daily: today (automated commit)

[04:16] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/4a6dc1b77f

[04:23] <Mouq> ruoso: Sure

[04:30] *** Mouq left
[04:31] *** Hor|zon joined
[04:36] *** Hor|zon left
[04:56] *** chenryn left
[05:03] *** kurahaupo1 left
[05:14] <b2gills> m: say 5.base(10,4); say 5.0.base(10,4); say 5e0.base(10,4)

[05:14] <camelia> rakudo-moar d99fe0: OUTPUT«5.0000␤5␤5␤»

[05:14] <dalek> rakudo/nom: 39d7c52 | coke++ | src/core/Numeric.pm:

[05:14] <dalek> rakudo/nom: Remove parrot ifdef fossils

[05:14] <dalek> rakudo/nom: 

[05:14] <dalek> rakudo/nom: Document the ones we can't remove

[05:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39d7c52bb5

[05:17] *** echowuhao left
[05:31] *** chenryn joined
[05:43] *** BenGoldberg left
[05:47] <[Coke]> .ask pmichaud do you have a list of tickets that will/should be addressed by the list work?

[05:47] <yoleaux> [Coke]: I'll pass your message to pmichaud.

[05:48] <[Coke]> .ask masak would you say RT #118407 and RT #115626 are dups?

[05:48] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=118407

[05:48] <yoleaux> [Coke]: I'll pass your message to masak.

[05:49] <[Coke]> ^^ synopsebot bug, only picked one?

[05:50] <[Coke]> r: use MONKEY_TYPING; augment slang Regex { token numish { } };

[05:50] <camelia> rakudo-{parrot,moar} d99fe0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Null regex not allowed␤at /tmp/tmpfile:1␤------> [32mG; augment slang Regex { token numish { [33m⏏[31m} };[0m␤»

[05:56] *** [Sno] left
[06:03] <dalek> roast: d8290e4 | coke++ | S32-exceptions/misc.t:

[06:03] <dalek> roast: Add test for RT #119293

[06:03] <dalek> roast: review: https://github.com/perl6/roast/commit/d8290e4c8a

[06:03] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119293

[06:04] <dalek> rakudo/nom: 8621d8e | coke++ | src/Perl6/Grammar.nqp:

[06:04] <dalek> rakudo/nom: RT #119293 - treat $] as an obsolete 5var.

[06:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8621d8ea79

[06:04] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119293

[06:07] *** raiph left
[06:08] *** raiph joined
[06:09] <[Coke]> r: &&::{}[];;

[06:09] <camelia> rakudo-parrot d99fe0: OUTPUT«===SORRY!===␤QRPA: index out of bounds␤»

[06:09] <camelia> ..rakudo-moar d99fe0: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[06:13] <nwc10> what should the error message be? What does that syntax mean? RT #119999 doesn't give me any clues

[06:13] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119999

[06:14] *** uvb left
[06:14] *** Mouq joined
[06:19] <[Coke]> it's one of the class of tickets that doesn't describe the desired behavior, but points out that that existing behavior generates an internal error that shouldn't be exposed.

[06:19] *** bjz joined
[06:19] <[Coke]> r: say $*PERL<version>

[06:19] <camelia> rakudo-moar d99fe0: OUTPUT«postcircumfix:<{ }> not defined for type Perl␤  in method gist at src/gen/m-CORE.setting:14785␤  in sub say at src/gen/m-CORE.setting:17542␤  in block <unit> at /tmp/tmpfile:1␤␤»

[06:19] <camelia> ..rakudo-parrot d99fe0: OUTPUT«postcircumfix:<{ }> not defined for type Perl␤  in method gist at gen/parrot/CORE.setting:14728␤  in method gist at gen/parrot/CORE.setting:1177␤  in sub say at gen/parrot/CORE.setting:17454␤  in sub say at gen/parrot/CORE.setting:17450␤  in bl…»

[06:19] *** Mouq left
[06:19] <[Coke]> ^^ that really shouldn't explode, should it?

[06:20] *** Hor|zon joined
[06:20] <[Coke]> (wondering why Perl has to be a class, and not a Hash.

[06:21] <[Coke]> also, that's blocking RT #79294

[06:21] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=79294

[06:24] *** yeahnoob left
[06:24] *** ggoebel111111114 left
[06:25] *** Hor|zon left
[06:26] *** grondilu left
[06:27] <dalek> roast: b49fcef | coke++ | / (11 files):

[06:27] <dalek> roast: use RT #XXXX where possible

[06:27] <dalek> roast: review: https://github.com/perl6/roast/commit/b49fcef85e

[06:28] *** bjz left
[06:32] *** kaleem joined
[06:37] *** spider-mario left
[06:43] *** ggoebel111111114 joined
[06:45] <dalek> nqp: 7ebbcb0 | raydiak++ | src/vm/parrot/6model/reprs/CArray.c:

[06:45] <dalek> nqp: Zero-fill CArrays on Parrot

[06:45] <dalek> nqp: 

[06:45] <dalek> nqp: Parrot version of ead76229 (JVM) and

[06:45] <dalek> nqp: https://github.com/MoarVM/MoarVM/commit/83c68df8950ada3827796580f6f21ee42899b9b1

[06:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7ebbcb0a14

[06:47] <dalek> roast: da05371 | coke++ | integration/weird-errors.t:

[06:47] <dalek> roast: Add test for RT #123570

[06:47] <dalek> roast: review: https://github.com/perl6/roast/commit/da053718b1

[06:47] <dalek> roast: eaa2708 | coke++ | integration/weird-errors.t:

[06:47] <dalek> roast: unfudge passing test

[06:47] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123570

[06:47] <dalek> roast: review: https://github.com/perl6/roast/commit/eaa27081fd

[06:51] *** FROGGS_ left
[06:55] *** bjz joined
[07:03] <dalek> roast: 8314042 | coke++ | S05-capture/dot.t:

[07:03] <dalek> roast: Add test for RT #77570

[07:03] <dalek> roast: review: https://github.com/perl6/roast/commit/8314042445

[07:03] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77570

[07:07] <jnthn> morning, #perl6

[07:07] <yoleaux> 16 Feb 2015 15:35Z <lizmat> jnthn: on MoarVM, delete_f does not return any value, this makes nqp::unlink flaky afaics.  Is there a reason for that ?

[07:07] <yoleaux> 16 Feb 2015 19:22Z <lizmat> jnthn: wrt PIO role name, maybe it should be RIO  (as in Rakudo Io Object)

[07:07] *** diana_olhovik_ joined
[07:11] <jnthn> .tell lizmat It seems that it contains a lot of common things you can do on an IO handle (e.g. basic I/O things), so I wonder a little if a name more like IO::General or IO::ReadWrite or something might be fitting...

[07:11] <yoleaux> jnthn: I'll pass your message to lizmat.

[07:12] <jnthn> .tell lizmat I notice seek/tell ended up in that role, but iiuc sockets also do the role; maybe that wnats pulling out into an IO::Seekable?

[07:12] <yoleaux> jnthn: I'll pass your message to lizmat.

[07:20] <dalek> rakudo/nom: 4078230 | jnthn++ | docs/ChangeLog:

[07:20] <dalek> rakudo/nom: Some ChangeLog additions.

[07:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40782308e5

[07:20] *** vendethiel- left
[07:22] *** gfldex joined
[07:23] *** kaare__ joined
[07:23] *** kaare_ left
[07:25] <dalek> rakudo/nom: 1dcc74e | jnthn++ | docs/ChangeLog:

[07:25] <dalek> rakudo/nom: One more ChangeLog note.

[07:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1dcc74efdf

[07:25] <jnthn> Nice ChangeLog this month! :)

[07:27] <arnsholt> jnthn: Do you have a plan for how shaped arrays will interact with 6model things?

[07:28] <arnsholt> (Been mulling over embedded structs/arrays stuff recently)

[07:28] <jnthn> arnsholt: I'm not sure I'd call it a plan yet, but kinda

[07:28] <jnthn> arnsholt: I'm by this point fairly sure we're going to want a different REPR for them than we use for normal arrays.

[07:29] <jnthn> arnsholt: Because "this thing can't change its size" is *really* useful to know for optimization purposes.

[07:29] *** FROGGS joined
[07:31] <raydiak> jnthn++: https://github.com/rakudo/rakudo/blob/nom/docs/ChangeLog#L36

[07:31] <FROGGS> o/

[07:32] <raydiak> \o

[07:32] <jnthn> raydiak: uh, wat? :)

[07:32] <jnthn> How on earhtr did I... :)

[07:32] <FROGGS> is that a pasto?

[07:32] <raydiak> jnthn: stray "BEGIN time"

[07:32] <jnthn> Yeah :)

[07:32] * jnthn goes to make another cuppa... :)

[07:33] <dalek> rakudo/nom: 5bb1942 | jnthn++ | docs/ChangeLog:

[07:33] <dalek> rakudo/nom: Remove stray text; raydiak++.

[07:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5bb19423b6

[07:33] <raydiak> hope I didn't derail your train of thought :)

[07:34] <FROGGS> jnthn: that precomp bug you fixed is *the* precomp bug we hit regularly, right?

[07:34] <FROGGS> like, on the jvm for URI?

[07:34] *** [Sno] joined
[07:34] <jnthn> FROGGS: I don't know that it is...

[07:35] <jnthn> FROGGS: I do know that at least one person besides me ran into it while working on CORE.setting

[07:35] <FROGGS> ahh

[07:35] <FROGGS> the bug I talk about also involved our scoped subs I think

[07:36] <jnthn> Yeah, there's more pre-comp bugs in my future, I'm sure... 

[07:37] <FROGGS> jnthn: are you okay with that? https://docs.google.com/document/d/120zZBQ27glXUn0vbkQPMK3mNTMo2GtMFv8lqiMca6ls/edit

[07:37] <FROGGS> jnthn: I put your name in there

[07:38] <FROGGS> .tell brrt Please look at that (I put you in there): https://docs.google.com/document/d/120zZBQ27glXUn0vbkQPMK3mNTMo2GtMFv8lqiMca6ls/edit

[07:38] <yoleaux> FROGGS: I'll pass your message to brrt.

[07:38] <arnsholt> jnthn: Yeah, that sounds like it makes sense

[07:38] <FROGGS> hi arnsholt 

[07:38] <arnsholt> Oh, hi there!

[07:38] <arnsholt> FROGGS++ # All of the upvotes for moving NativeCall to the Rakudo repo =)

[07:38] <FROGGS> *g*

[07:39] <jnthn> FROGGS: Yes, it's fine with me :)

[07:39] <FROGGS> and it was a very good thing, for the reason I found/solved bugs in nqp-p's vmarray handling and string passing to foreign functions

[07:40] <FROGGS> there are two issues left: 1) only on jvm on osx the libraries for the nativecall tests are not found, perhaps because CWD is not in the lib search path

[07:41] <jnthn> Hm, I wonder why we didn't see that issue when the things were in the nativecall repo?

[07:41] *** rindolf joined
[07:41] <FROGGS> 2) on the jvm seems to exist a output buffering issue... the printed lines of say() appear sometimes after the lines printed by the called C test functions

[07:41] <arnsholt> Yeah, that's odd

[07:41] *** Rounin joined
[07:41] <FROGGS> so, say() does not flush I guess

[07:42] <FROGGS> jnthn: because nobody looks at tester reports because the site is too slow?

[07:42] <FROGGS> (and not many use parrot / jvm anyway)

[07:42] <FROGGS> (or osx for that matter :P)

[07:43] *** _mg_ joined
[07:43] <jnthn> FROGGS: Oh, it's only JVM + OSX?

[07:44] <FROGGS> for the lib loading problem, yes

[07:44] <jnthn> OK, then I can see how we mighta missed it.

[07:48] *** zakharyas joined
[07:49] *** _mg_ left
[07:54] *** _mg_ joined
[07:59] *** gfldex left
[08:05] *** prime- left
[08:06] *** Ven joined
[08:08] *** rindolf left
[08:09] *** prime joined
[08:09] *** _mg_ left
[08:09] *** Hor|zon joined
[08:10] *** darutoko joined
[08:13] *** larion left
[08:14] *** Hor|zon left
[08:15] *** _mg_ joined
[08:16] *** sqirrel__ joined
[08:21] *** fhelmberger joined
[08:21] *** _mg_ left
[08:26] *** kaare__ is now known as kaare_

[08:28] *** pierrot left
[08:28] *** pierrot joined
[08:28] <[Tux]> \o/ nice! https://github.com/perlpilot/perl6-docs/blob/master/intro/p6-regex-intro.pod

[08:30] *** diana_olhovik_ left
[08:30] *** NABB907 joined
[08:32] *** raiph left
[08:33] *** wicope joined
[08:36] *** pierrot left
[08:37] <moritz> bonus points for integrating that into doc.perl6.org

[08:38] *** rurban joined
[08:39] * [Tux] struggles with converting perl5 «$foo =~ s{^"(.*)"$}{$1};» as «$foo ~~ s{^ '"' (.*) '"' $} = $_;» doesn't seem to do what I thought it would do

[08:40] <[Tux]> hmm, maybe it does

[08:43] *** abraxxa joined
[08:43] *** mrf left
[08:44] <moritz> [Tux]: ~~ is a topicalizer, that is, it sets $_ on the right-hand side

[08:44] <moritz> [Tux]: so be careful with $_ on the RHS of a ~~

[08:44] <[Tux]> should I use $1 instead?

[08:44] <jnthn> Probably want = $0

[08:45] * [Tux] realized this must be about the 10th time he forgot to count form 0 D'uH!!!

[08:45] <jnthn> :)

[08:45] <jnthn> If it helps, $0 compiles into $/[0], $1 into $/[1], etc.

[08:45] <moritz> old habits do die hard

[08:45] <jnthn> So it's just shortcut for an array access :)

[08:45] *** mrf joined
[08:46] <jnthn> Knowing that's how it works in Perl 6 doesn't prevent muscle memory, sadly...

[08:47] *** pierrot joined
[08:53] *** ggoebel111111114 left
[08:57] <masak> mornin', #perl6

[08:57] <yoleaux> 05:48Z <[Coke]> masak: would you say RT #118407 and RT #115626 are dups?

[08:57] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=118407

[08:58] <jnthn> o/ masak

[08:58] *** alini joined
[08:59] <masak> [Coke]: no.

[08:59] *** rurban1 joined
[08:59] *** Hor|zon joined
[09:00] <masak> [Coke]: one used to be a Null PMC access; the other used to be a segmentation fault. I've not known those to be dups.

[09:00] <masak> in my opinion, though, both should be resolved, as there is no NPMCA anymore, and no segfault.

[09:08] <tadzik> regarding yesterday's I Am Groot: http://imgur.com/VnPtOU8

[09:14] *** _mg_ joined
[09:15] *** adu left
[09:20] *** dakkar joined
[09:23] *** kjs_ joined
[09:28] *** larion joined
[09:37] <moritz> glibc <-> libc, groot <-> root

[09:39] *** _mg_ left
[09:52] *** wicope left
[09:52] *** pecastro joined
[09:52] *** wicope joined
[09:55] *** espadrine_ joined
[10:06] *** zakharyas left
[10:07] *** zakharyas joined
[10:11] *** virtualsue joined
[10:13] *** _mg_ joined
[10:18] *** rindolf joined
[10:18] *** coffee` joined
[10:34] *** sqirrel__ left
[10:36] *** _mg_ left
[10:49] *** TgMts joined
[10:53] *** Ven left
[11:04] *** Ven joined
[11:31] *** chenryn left
[11:32] *** chenryn joined
[11:37] *** chenryn left
[11:38] *** sqirrel__ joined
[11:47] *** hanekomu joined
[11:47] *** rindolf left
[11:49] *** hanekomu left
[11:50] * masak .oO( what a glib comparison )

[11:54] *** hanekomu joined
[11:54] *** hanekomu left
[11:55] *** donaldh joined
[11:59] *** hanekomu joined
[12:03] <FROGGS> timotimo++ # weekly

[12:13] *** sqirrel__ left
[12:14] *** rurban1 left
[12:22] *** kjs_ left
[12:25] <moritz> timotimo++

[12:29] <lizmat> .tell [Coke] accessing members of an object as a Hash is very P5, isn't it?   What.s wrong with $*PERL.version ??

[12:29] <yoleaux> 07:11Z <jnthn> lizmat: It seems that it contains a lot of common things you can do on an IO handle (e.g. basic I/O things), so I wonder a little if a name more like IO::General or IO::ReadWrite or something might be fitting...

[12:29] <yoleaux> lizmat: I'll pass your message to [Coke].

[12:29] <yoleaux> 07:12Z <jnthn> lizmat: I notice seek/tell ended up in that role, but iiuc sockets also do the role; maybe that wnats pulling out into an IO::Seekable?

[12:29] *** telex left
[12:30] *** telex joined
[12:30] *** alini left
[12:33] *** rurban1 joined
[12:34] *** bjz left
[12:35] *** bjz joined
[12:38] *** skids left
[12:39] *** alini joined
[12:39] *** xfix joined
[12:41] *** pochi left
[12:41] *** pochi joined
[12:42] <dalek> doc: b412b25 | paultcochrane++ | lib/Language/quoting.pod:

[12:42] <dalek> doc: Minor corrections to heredoc docs

[12:42] <dalek> doc: review: https://github.com/perl6/doc/commit/b412b25cb8

[12:43] *** xfix left
[12:46] *** xfix joined
[12:46] *** ggoebel111111114 joined
[12:49] *** TgMts left
[12:49] *** xfix left
[12:51] *** grondilu joined
[12:52] <moritz> [ptc]++

[12:58] <grondilu> m: say my long $ = 0;

[12:58] <camelia> rakudo-moar 5bb194: OUTPUT«[31m===[0mSORRY![31m===[0m␤Type 'long' is not declared␤at /tmp/nX0YFBT3N2:1␤------> [32msay my long[33m⏏[31m $ = 0;[0m␤Malformed my␤at /tmp/nX0YFBT3N2:1␤------> [32msay my [33m⏏[31mlong $ = 0;[0m␤␤»

[12:58] *** rurban1 left
[12:59] * grondilu is confused by the last P6weekly mentioning a new "long" type.

[12:59] <jnthn> grondilu: It's part of NativeCall and maybe called clong...

[13:00] <El_Che> grondilu: haven't you heard? p6 is the new c++15 standard ;)

[13:01] <lizmat> m: use NativeCall; my long $a = 42; say $a

[13:01] <camelia> rakudo-moar 5bb194: OUTPUT«42␤»

[13:01] <[ptc]> moritz: ach, they were just small changes...

[13:01] <lizmat> grondilu: ^^^

[13:01] <grondilu> ok, thanks

[13:04] <lizmat> almost forgot: timotimo++ for P6W  :-)

[13:05] <[ptc]> agreed!  timotimo++ # weekly

[13:06] <grondilu> I used to follow progress of the three main implementations from an automatically generated webpage of some sort but I lost the link.  Anyone knows what I'm talking about?

[13:06] <tadzik> feature matrix?

[13:06] <grondilu> not quite

[13:06] <[ptc]> timotimo: btw, "ptc" is fine; you don't need to use the ugly "paultcochrane" thingy

[13:07] <grondilu> it was displaying a % of the passing specs or something.

[13:07] *** kaleem_ joined
[13:07] <grondilu> it was all the rage when MoarVM overtook parrot and the JVM for instance.

[13:08] *** kaleem left
[13:11] <moritz> grondilu: https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv this one?

[13:12] <moritz> [Coke]: the perl6_pass_rates link on https://github.com/coke/perl6-roast-data is broken

[13:13] <lizmat> hmmm.... t/spec/S03-operators/misc.t fails on parrot using make, but runs ok with perl6-p

[13:13] <lizmat> same for t/spec/S03-sequence/arity-2-or-more.t

[13:14] <lizmat> they seem to segfault when run under harness

[13:14] <lizmat> afk for a few hours&

[13:14] <moritz> the arity-2-or-more.t could be related to the recent #?if parrot removals

[13:14] <grondilu> moritz: yes, that's it, thanks :)

[13:15] *** _mg_ joined
[13:15] <grondilu> will the js backend join this list or is it too soon?

[13:16] <moritz> grondilu: we aren't at rakudo-js yet; nqp-js first

[13:16] <moritz> pmurias++ and hoelzro++ are working on it

[13:17] *** xfix joined
[13:18] <sergot> hi \o

[13:19] <Ven> timotimo++

[13:19] *** kjs_ joined
[13:30] *** rindolf joined
[13:33] *** TgMts joined
[13:45] *** _mg_ left
[13:52] <Peter_R> Just read on reddit that MoarVM uses a GIL for threading, in particular access to arrays

[13:52] <Peter_R> Is there any truth in that?

[13:56] <FROGGS> I know that there is no GIL, but I cannot give a more detailed answer I fear

[13:56] <moritz> Peter_R: do you have a link to the reddit discussion?

[13:56] <tadzik> http://www.reddit.com/r/perl6/comments/2w3asu/suspending_rakudo_support_for_parrot/ here

[13:57] <Peter_R> tadzik, ta

[13:57] *** sqirrel joined
[13:58] <FROGGS> quote from rurban: "Why are people leaving python and perl5? Because of the GIL, bad multi-core support. parrot has no GIL, perl6 on moarvm has."

[14:00] <rurban> It's not exactly a GIL, it's worse, It's like mysql table-locking

[14:00] <moritz> is it? how? where?

[14:00] <FROGGS> rurban: prove that Parrot's threading support is better

[14:01] <moritz> also, table-level locking is much better than global locking of all database instances (what GIL would be)

[14:03] <moritz> also iirc most of the moarvm data structures are actually lockfree

[14:03] <FROGGS> rurban: lexical access is only possible from the main thread in parrot, which means that most of what we'd like to do in theads would need to happen in the main thread, how do we utilize more than one core at all?

[14:04] * grondilu can't find GIL in S99

[14:04] <FROGGS> rurban: I tried that and failed back then, and there was no support from #parrot whatsoever

[14:05] <tadzik> grondilu: global interpreter lock

[14:05] <grondilu> I'll add it to S99

[14:05] <tadzik> grondilu++

[14:06] <rurban> There's no need to prove that the parrot threading model is better. perl6 continously failed to understand that, published desastrous slandering nonsense and came up with the moarvm threading model by themselves. Ask the author, he is here

[14:07] <moritz> rurban: that's just ridiculous. There are people in here who tried to get parrot threads to work with rakudo, and failed

[14:07] <FROGGS> rurban: I tried to understand and I asked questions, and I got back nothing

[14:07] <moritz> rurban: so, there is need of a prove.

[14:07] <rurban> moritz: in parrot all datastructures are lock-free, just the scheduler needs some fine-grained locks

[14:08] <rurban> I answered all questions at #parrot

[14:08] <moritz> rurban: so the problem of accessing lexicals from other threads has long been solved?

[14:08] <dalek> specs: dbee059 | (L. Grondin)++ | S99-glossary.pod:

[14:08] <dalek> specs: adding GIL

[14:08] <dalek> specs: review: https://github.com/perl6/specs/commit/dbee059164

[14:08] *** sqirrel left
[14:08] <rurban> sure. perl6 has its wrong implementation of lexvars, parrot lexvar pmc work okay threaded

[14:09] <moritz> rurban: but rakudo has a different implementation for lexicals because the semantics that parrot offered didn't work for Perl 6

[14:09] <moritz> rurban: has that also been resolved in parrot?

[14:09] <FROGGS> rurban: your only input was "LGTM" - https://github.com/parrot/parrot/issues/889

[14:10] <FROGGS> rurban: you did not even attempt to answer my questions

[14:10] *** brrt joined
[14:10] <rurban> you are talking about nqp and 6model issues

[14:11] <rurban> I know of no parrot problem in this regard. I even provided you with new enum_Cl;ass constants to get run-time access to the dynaloaded types

[14:11] <FROGGS> rurban: no, I am talking about how we could make use of parrot's threading model, so that we actually use more than one core

[14:12] <rurban> that's described in the threading doc and is used in the examples. the author is also here

[14:12] <FROGGS> rurban: so why didn't you answer my question back then?

[14:12] <FROGGS> I did read the docs

[14:12] <FROGGS> and I did not find answers to the problems I tried to solve

[14:12] *** ggoebel111111114 left
[14:13] <FROGGS> and you did *not* answer questions on irc... http://irclog.perlgeek.de/parrot/2013-08-03

[14:14] <FROGGS> in fact I still don't know how to do a non blocking lexical lookup

[14:15] <FROGGS> (I am just talking about looking up variables, and subroutine to do some computation, I'm not even talking about writing to a lexical)

[14:17] *** ggoebel111111114 joined
[14:17] <rurban> check if the type is a Proxy, follow the proxy then, if not read it directly. if you need to write to a proxy, schedule a writer task

[14:18] <brrt> *ahem* after all this time, i've learned that the offset-argument is used to *store* the offset

[14:18] <yoleaux> 07:38Z <FROGGS> brrt: Please look at that (I put you in there): https://docs.google.com/document/d/120zZBQ27glXUn0vbkQPMK3mNTMo2GtMFv8lqiMca6ls/edit

[14:18] <brrt> froggs, thank

[14:18] <brrt> s

[14:18] <brrt> (the offset argument to sendfile, that is)

[14:19] <brrt> oh, i can elaborate on that

[14:19] <FROGGS> rurban: I'll add that to the ticket

[14:20] <brrt> we have two things to do on the moarvm jit

[14:20] <brrt> a: better code generation

[14:20] <brrt> b: jit-only optimisations

[14:20] *** camelia left
[14:20] <moritz> c: world domination!

[14:21] <brrt> under a is everything related to what i've come to call the 'expression compiler', load/store reification, and in general making moar-jit a 'real' compiler

[14:21] <brrt> (i volunteer for that)

[14:21] *** camelia joined
[14:21] <brrt> under b are a number of things relating to stuff you can only do at jit time

[14:22] *** skids joined
[14:22] <brrt> such as: nativecall optimizations (inlining, i suppose)

[14:22] <FROGGS> rurban: IIRC the lexical lookup *was* blocking... you say this is not the case anymore? lexical lookup will happily run in any worker thread?

[14:22] <brrt> but also: small-bigint-optimization

[14:22] <brrt> repr op devirtualisation

[14:22] <FROGGS> brrt: can you update the doc?

[14:22] <camelia> b : OUTPUT«Can't chdir to '/home/camelia/rakudo/': No such file or directory at lib/EvalbotExecuter.pm line 166.␤       EvalbotExecuter::_auto_execute(HASH(0x1e6c2c8), "jit-only optimisations", GLOB(0xd250790), "/tmp/mIqBAGJb6t", "b") called at lib/EvalbotExecuter.pm line 114␤   Evalbot…»

[14:22] *** ChanServ sets mode: +v camelia

[14:23] <brrt> and last but not least, simd ops for tight loops on integers

[14:23] <brrt> yes, will do

[14:23] <FROGGS> you can put that better in words than I could :o)

[14:24] <rurban> FROGGS: every data access is lock-free, just not wait-free

[14:24] <moritz> it's a long time since somebody last triggered a 'b:' in camelia :-)

[14:25] <tadzik> :D

[14:25] <brrt> rurban, i think honestly that this is only true under a rather narrow definition of locks

[14:25] <brrt> consider that locks are themselves implemented using queues :-)

[14:25] <skids> .oO(What would having int128/uint128 buy us, future-proofing-wise)

[14:26] <brrt> s/are implemnted using/may be backed by/

[14:26] <[Coke]> moritz: (broken link) so it is. Problem, though: I'm trying to escape the _'s which will turn it into an underline; tried indenting by 4, but that leaves the link unlinked. Any suggestions on how to fix it?

[14:26] <yoleaux> 12:29Z <lizmat> [Coke]: accessing members of an object as a Hash is very P5, isn't it?   What.s wrong with $*PERL.version ??

[14:26] <brrt> skids - maybe SIMD suport?

[14:26] <rurban> it's practically lock-free. theoritically not, as the scheduler needs to lock other threads interfering. still thousand times better then moar

[14:26] <FROGGS> brrt: well, what I want is to do thing concurrently... so that a computation that usually takes 20s will takes less than <10s when run on four cores... I don't feel like I get there with rurbans help

[14:27] <FROGGS> rurban: no, because my test with lexical lookups used exactly 100% of a single core, wich is pointless

[14:27] <brrt> as in, with an int128 type you can conceivably write a simd-type computation

[14:28] <brrt> well... i am not going to claim i know everything there is to know about moarvm's threading :-)

[14:28] <FROGGS> rurban: you need to keep in mind that subroutines (infixes etc) are also lexicals

[14:28] <skids> brrt: Maybe.  The only place I have found it lacking so far is in the size field of the padding in some checksum algs.

[14:28] <brrt> but from what i do know it uses libuv which uses os threads which may use multiple cores

[14:28] <brrt> but ... what about the 'unix answer' - forking?

[14:29] <arnsholt> If you fork, you need to set up communication to share data over

[14:29] <rurban> FROGGS: I have no idea about the nqp and perl6 compilers. you still need to implement concurrency there

[14:29] <arnsholt> (Assuming you can't do it shared-nothing)

[14:29] <brrt> which you also need to do if you use threading, just differently

[14:30] <FROGGS> but anyway, I won't touch parrot's threads this year anyway... not that I get encouraged by any party to work on that at all

[14:30] <rurban> Well, you killed parrot hereby, so you lost the concurrency game anyway

[14:31] <brrt> rurban - for what it's worth, i do see the point of parrots type of concurrency; it is easier to see how it works out with a completely mutable world

[14:31] <FROGGS> rurban: I have not killed anything

[14:31] <rurban> but you already killed it it before Austin, with the same non-understanding. it was already over then

[14:31] <rurban> not you, diakopter and pmichaud

[14:35] <moritz> I see we aren't in the "do we still want parrot?" phase, but in the "who killed parrot?" phase

[14:35] <FROGGS> rurban: if you talk about MoarVM, the decision to do that proved to a very good one

[14:35] <FROGGS> it proved to be the fastest and more feature rich backend

[14:36] <moritz> I mean, a healthy project would just go and say "we'll find other users"

[14:36] <brrt> it is really a shame that the whole parrot story became so divisive

[14:36] <FROGGS> and I think it is unfair that I get shouted at "you!" when I always speak pro parrot and when I make promises to support it and work on ports to it

[14:37] * moritz hugs FROGGS 

[14:37] *** adu joined
[14:38] <rurban> FROGGS: nothing against you. "You" meant perl6 here

[14:38] * rurban hugs FROGGS also

[14:39] <moritz> that's a convenient person to blame, that perl6

[14:39] <donaldh> For what its worth, I tried working on parrot and tried contributing. The experience sucked for me. I haven't contributed a line of code to MoarVM. I actively enjoy contributing to the JVM backend of nqp.

[14:39] <yoleaux> 2 Feb 2015 18:36Z <[Coke]> donaldh: - if you can help me get a perl 6 eclipse plugin working, I can start implementing work build stuff in perl6. would be super nice.

[14:39] <FROGGS> rurban: a hug now does not help my with my problems when I tried to get a proof a concept working for threads... you need to support your users if you need to keep them

[14:39] <brrt> i'm hesitant about adding myself as a potential student for JIT projects, it might discourage others?

[14:39] <tadzik> brrt: why would it?

[14:39] *** Mouq joined
[14:40] <tadzik> oh, as a candidate for a particular project?

[14:40] <rurban> It's just sad that perl6 will have no concurrency advantage over other languages then. erlang and clojure being the only realistic, fast option, or Go with copying messages.

[14:40] <brrt> yes

[14:40] *** kaleem_ left
[14:40] <tadzik> well, it might discourage people from applying for the same project as you, yes :)

[14:42] <brrt> right

[14:42] <rurban> FROOGS: sorry, I cannot help with nqp

[14:42] <brrt> ok, i'm going to rewrite 2) to be a bit more broad

[14:42] * FROGGS gives up

[14:46] <Ven> Go has worse concurrency stuff that some stuff in the 90s

[14:46] <btyler> and yet is wildly popular and finding usages all over the place :)

[14:46] <FROGGS> marketing

[14:47] *** rurban1 joined
[14:47] <FROGGS> when Samsung would announce a new programming language they had a few thousand hackers for free

[14:48] *** raiph joined
[14:48] <btyler> yeah, maybe. I like to think google hasn't infiltrated my brain so heavily that it is generating the sense of fun and enjoyment I have when writing ssh daemons in go :)

[14:48] <btyler> but very possible I wouldn't have even tried it without the google backing

[14:51] * Mouq is very excited to see Rust stabilizing, though he still hasn't been able to fully grok lifetimes

[14:51] <moritz> I think go has a good compromise between not-too-bad or even good concurrency and familiarity

[14:51] <btyler> I only mean to say to Ven -- try not to dismiss things that people like just because better things came before. go is hitting it big for a reason that I don't think is entirely due to google's marketing power

[14:52] <Ven> btyler: I'm always too provocative in my one-liner statements

[14:52] <moritz> yes, erlang may have better concurrency support, but it has unfamiliar syntax, unfamiliar vocabulary, and an unfamiliar programming model

[14:52] <btyler> those dang one-liners and their lack of nuance

[14:52] <FROGGS> Ven: because lax is enabled by default? :o)

[14:52] <Ven> *g*

[14:53] <btyler> it's worth noting that a lot of the early go publicity consisted of rob pike basically giving lessons on concurrent programming, incidentally using go

[14:53] <Ven> I tried to do some go. But "interface{}" everywhere made me go mad. I can't program without abstractions, and I strictly refuse to use `void*` in 2015 (unless it gets me fired from my school)

[14:53] <psch> \o

[14:54] <psch> https://gist.github.com/peschwa/4fe16e5c5aa2e5b8370c # found this will adjusting the .trans and tr/// PR

[14:54] <Ven> There's so many things I think are *WRONG* in Go I just get annoyed instantly. It just irks me somehow. 

[14:54] <psch> getlexcaller through a multi method seems to not work correctly is the gist of the gist

[14:55] <Ven> It's like when everybody was hyping node's event model and stuff. It felt wrong. If you think about it, really, there's nothing that ought to generate such hype about it

[14:55] <psch> unless there's something else i didn't think of or don't know :)

[14:55] <Ven> btyler: Everytime I discuss Go with some friends of mine about its drawbacks and pitfalls, they just say "well it doesn't seem to be an issue for guys like robe pike" and that's incredibly annoying

[14:56] <btyler> Ven: except that there was an http server implementation on the front page in 6 lines

[14:56] <btyler> (re node)

[14:56] <brrt> Ven - you may have annoying friends

[14:56] <Ven> btyler: it was using a (core) library

[14:56] <brrt> or possibly, you may be annoying your friends

[14:56] <btyler> and that is incredibly compelling if what you know is python and django and php

[14:56] <tadzik> one does not implement http server in 6 lines unless you just import a readymade module for it

[14:56] <Ven> it's easier in php. I don't think that's compelling

[14:57] <tadzik> http server in python, following that logic is just python -m SimpleHTTPServer, done

[14:57] <btyler> I humbly posit that the fact that it uses a library matters essentially not at all

[14:57] <brrt> what tadzik said :-)

[14:57] <Ven> ^

[14:57] <btyler> it comes with the platform, it counts enough as core

[14:57] <Ven> if I'm allowed to use libraries, I can probably serve you a static page in 6 lines as well ;-)

[14:57] <Ven> in c++*

[14:57] <moritz> system('apachectl', 'start')

[14:58] <Ven> :D

[14:58] <btyler> again, I'm not saying it makes sense

[14:58] <brrt> but... the other hand is that channels really are a pretty good (as in, understandable and effective) way to concurrency

[14:58] <btyler> but node was wildly successful in reaching a huge audience

[14:58] <Ven> moritz: http://tinyhack.com/2014/03/12/implementing-a-web-server-in-a-single-printf-call/

[14:58] <btyler> and writing it off as hype-driven tech is missing some lessons in how to get people excited about your work

[14:59] <muraiki> yeah, I just read an article about the new bbc website. they evaluated using node, clojure, and scala... they went with node, one of the reasons being something like "everyone has to know js anyways, so there's less context switching"

[14:59] <btyler> ditto go

[14:59] <brrt> what bugs me about node is that people were given a way to create callback-based network services in javascript, and what they did was build websites for gullible VCs

[15:01] *** TgMts left
[15:01] <brrt> (also, conceptually i think supplies and promiser are quite close to go's channels)

[15:02] <Mouq> .oO( while [ 1 ]; do; echo My Page | nc -l 3000; done )

[15:02] <Ven> btyler: I've been doing node for, maybe 4 years now? I *would* feel much more confident writing it off as a hipster tech than go :)

[15:03] <brrt> you know what is hipster tech?

[15:03] <brrt> the whole gulp / grunt / sass / whatever BS that has to run *before* node can even run

[15:04] <Ven> *g*

[15:05] <brrt> all problems in CS can be solved by another layer of indirection; too bad somebody didn't realise that 'restarting a web server when a file changes' isn't really a typical CS problem

[15:05] * brrt goes back to doing useful stuff

[15:06] <btyler> what I'm getting at is there needs to be some wariness about falling into smug lisp weenie-ism. writing off major recent examples of successful language adoption as crappy tech is a great way to wind up wondering why nobody is using your cool thing

[15:06] <Ven> btyler: I prefer my concurrency tools in haskell and racket a thousand times more than those in go, really. I don't think there's any revolution. the papers about this kind of primitives are from the 80s or 90s, and got implemented in obscure languages but didn't take off at that time

[15:06] <btyler> anyways, apologies, back to productivity

[15:06] *** donaldh left
[15:07] <Ven> brrt

[15:08] <Ven> whoops.

[15:08] <brrt> yes? :-)

[15:08] <Ven> brrt++: proceed :P

[15:08] <Ven> btyler: well, we can certainly use that to prepare our success in the programming languages world

[15:10] <muraiki> btyler: I've tried arguing the same thing in this channel before, to a similarly lukewarm reception :)

[15:10] <Ven> btyler: I'm just saying my experience in go has been *very* unpleasant because I always felt cornered by the language. It has this java feeling to it. "there's only one way to write it"

[15:12] <btyler> by design, to great and warm reception by the loads of python programmers who try it out :) gofmt is a major -bonus- to many people using go

[15:14] <Ven> btyler: clang-format is pretty good, also :P. I agree about the "gofmt", but that was a bit beyond my point

[15:14] <Ven> I just don't feel, errrr, creative? maybe an overuse of that word

[15:15] <Ven> I'm probably not in the correct mindset, though... But when I start writing something, I'm like "this could be abstracted neatly here" but nope, this can't happen in this language

[15:15] <brrt> that's interesting

[15:15] <brrt> some people view abstraction as a tool. others view it as an essential prerequisite for self-expression

[15:16] <Ven> It's like in java. I feel like I have to go through so much to get my point across

[15:16] <brrt> FROGGS: i'm done, by the way

[15:16] <FROGGS> brrt++

[15:16] *** FROGGS left
[15:16] <Ven> I'm strongly convinced "factories" wouldn't have been so big in java if the language had had lambdas before. which it really should've

[15:18] <brrt> runtime makes very little distinction between those

[15:20] <Ven> brrt: I feel strongly about "abstraction", but there's a bit difference between a monad and a beansingletonfactoryfactory.

[15:21] <skids> Tht's not real Java without the word "Enterprise" in every identifier

[15:22] <brrt> :-)

[15:22] * brrt afk

[15:22] *** brrt left
[15:22] <Ven> (a "factory" is a bad kind of abstraction, in this case :P)

[15:24] <lizmat> .tell [Coke] reverting 39d7c52bb5db8b fixes failing tests for me on parrot

[15:24] <yoleaux> lizmat: I'll pass your message to [Coke].

[15:25] <moritz> ah, we can remove all of them after the release anyway

[15:27] *** grondilu left
[15:28] <masak> I've never quite seen the point of factories.

[15:30] <moritz> std: :10<1*2**-64>

[15:30] <camelia> std f9b7f55: OUTPUT«[31m===[0mSORRY![31m===[0m␤Base is missing ** exponent part at /tmp/6DYP7PNPam line 1:␤------> [32m:10<1*2[33m⏏[31m**-64>[0m␤Malformed radix number at /tmp/6DYP7PNPam line 1:␤------> [32m:10<1*2**[33m⏏[31m-64>[0m␤    expecting any of:␤…»

[15:31] <moritz> masak: that's where your iphone was made :-)

[15:31] *** Rounin left
[15:31] <moritz> masak: also, have you seen that HPMoR Chapter 105 is out?

[15:32] <skids> So, how far is rakudo from running on NaCL?  JOOC.

[15:32] <PerlJam> 105?  The last one I remember reading was 102

[15:32] <PerlJam> good morning btw

[15:32] <moritz> skids: it mostly runs on silicone, I believe :-)

[15:38] <dalek> rakudo/nom: 7970ff8 | lizmat++ | src/core/Numeric.pm:

[15:38] <dalek> rakudo/nom: Revert "Remove parrot ifdef fossils"

[15:38] <dalek> rakudo/nom: 

[15:38] <dalek> rakudo/nom: It's breaking some tests on parrot.  Keep these until at least after 2015.02

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7970ff84ac

[15:39] <skids> moritz: Well, that would make for some pretty introspectable breast implants I guess.

[15:40] <hoelzro> o/ #perl6

[15:40] *** spider-mario joined
[15:41] <hoelzro> m: try { !!! ; CATCH { default { say $_.WHAT } } }

[15:41] <camelia> rakudo-moar 5bb194: OUTPUT«(X::AdHoc)␤»

[15:42] <hoelzro> should .../???/!!! fail/warn/die with a special type of exception? something like X::Stub or something?

[15:43] <moritz> yes, could be a subclass of X::AdHoc

[15:43] <moritz> though of the argument is an Exception already, that should be thrown instead

[15:43] <[Coke]> lizmat: I tested all those on OS X before committing, spectested everything, even split up the unfudging so I could track down the ones with the various issues that were documented in the commit. unfortunate.\

[15:43] <yoleaux> 15:24Z <lizmat> [Coke]: reverting 39d7c52bb5db8b fixes failing tests for me on parrot

[15:43] *** davido__ left
[15:44] <lizmat> [Coke]: fwiw, the failures *only* exist when the test run under a harness, like with "make"

[15:44] <[Coke]> Not saying you should re-commit it, but I'm just sad. :|

[15:44] <[Coke]> lizmat: I ran the tests with 'make spectest' each time.

[15:44] <lizmat> running them in the nude, like with perl6-p, they pass

[15:44] <[Coke]> (did the full suite after removing each one.)

[15:44] <lizmat> I just want to make sure we have a clean relase

[15:44] <lizmat> *release rather

[15:45] <[Coke]> yup, I get it. just sad. :)

[15:45] *** davido__ joined
[15:45] <lizmat> sorry, but when I'm wearing the release manager's hat, I need to be ruthless  :-)

[15:45] <moritz> lizmat++

[15:45] <moritz> [Coke]++ for removing it in the first place

[15:46] <moritz> [Coke]: and we'll get rid of it again soon after the release anyway

[15:47] <hoelzro> moritz: should I open a PR against the spec to add that?

[15:47] *** Ven left
[15:48] <moritz> hoelzro: IMHO that's something that can be prototyped in rakudo first

[15:49] <hoelzro> moritz: oh, ok

[15:49] <hoelzro> I'll prototype it there, then

[15:59] <dalek> rakudo/newio: d99fe0b | FROGGS++ | lib/NativeCall.pm:

[15:59] <dalek> rakudo/newio: pass an absolute libname for on jvm/osx

[15:59] <dalek> rakudo/newio: 

[15:59] <dalek> rakudo/newio: The library loader will not look in CWD for libs, but will instead pre-/append stuff and tries

[15:59] <dalek> rakudo/newio: to look it up in system dirs.

[15:59] *** dalek left
[15:59] <lizmat> sorry falek

[15:59] <lizmat> *dalek

[16:00] *** dalek joined
[16:00] *** ChanServ sets mode: +v dalek

[16:01] *** gfldex joined
[16:08] *** FROGGS[tab] joined
[16:10] *** Ven joined
[16:12] *** hanekomu left
[16:23] *** TgMts joined
[16:28] *** kaleem joined
[16:28] <FROGGS[tab]> can somebody with perl6-j on osx pass -Djna.library.path=/path/of/rakudo/ to the jvm runner an run a test from t/04/nativecall?

[16:29] <FROGGS[tab]> I have no osx box so I cant test :o(

[16:29] <lizmat> FROGGS[tab]: will try

[16:29] <FROGGS[tab]> ohh, thank you

[16:30] <lizmat> path of rakudo  what do you mean by that ?

[16:30] <FROGGS[tab]> the build dir

[16:30] <lizmat> the install dir?  or the current dir?

[16:30] <FROGGS[tab]> where the .dylibs end up being

[16:30] <FROGGS[tab]> cwd

[16:30] <lizmat> ok, so as an absolute path, not just "." then

[16:31] <FROGGS[tab]> dunno

[16:31] <lizmat> hehe

[16:31] <FROGGS[tab]> probably abs path

[16:31] <FROGGS[tab]> that's the safe bet at least

[16:34] <lizmat> with "runner", you mean the script that is called perl6-j, right ?

[16:34] <FROGGS[tab]> aye

[16:35] <lizmat> and a rebuild is not necessary, right ?

[16:35] <FROGGS[tab]> right

[16:35] <lizmat> no change

[16:35] <FROGGS[tab]> gah

[16:36] <lizmat> but specifying a wrong dir, doesn't give any errors

[16:36] <lizmat> so I'm not sure

[16:36] <FROGGS[tab]> can you paste your runner and the output of the test run?

[16:38] <lizmat> ok, I may have patched the wrong runner ?

[16:38] <FROGGS[tab]> depends on which you are using :o)

[16:39] *** aoeuhtns joined
[16:39] <FROGGS[tab]> when you run it without ./ you have to patch the installed one

[16:40] *** alini left
[16:41] *** echowuhao joined
[16:41] <lizmat> https://gist.github.com/lizmat/87b2db1a6d058dc8c21e

[16:43] *** kaleem left
[16:43] <FROGGS[tab]> well, that really looks like you have patched the wrong runner

[16:44] <FROGGS[tab]> can you patch the installed one?

[16:45] <hoelzro> I seem to remember talk of a CI system for Perl 6 modules; did anything ever come of that?

[16:45] <hoelzro> would the community find value in such a system?

[16:46] <hoelzro> I was thinking that building something like http://rust-ci.org/ wouldn't be too hard

[16:46] <FROGGS[tab]> I think so

[16:46] <hoelzro> and it would be a good motivation to get a Mojolicious port working =)

[16:46] <lizmat> FROGGS[tab]: why do you think I patched the wrong one?  your extra param is at the end

[16:46] <lizmat> I even added an echo before to make sure it was the right one

[16:47] <lizmat> and it showed

[16:47] <FROGGS[tab]> ohh, I expected a linewrap and did not spot the end of the line

[16:47] <dalek> rakudo/newio: b95f6de | lizmat++ | src/core/IO.pm:

[16:47] <dalek> rakudo/newio: Fix glitch in MAKE-ABSOLUTE-PATH

[16:47] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/b95f6de3c4

[16:47] <dalek> rakudo/newio: f17f88b | lizmat++ | src/core/IO.pm:

[16:47] <dalek> rakudo/newio: Fix regression in MAKE-CLEAN-PARTS

[16:47] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/f17f88b554

[16:48] <lizmat> the runner is basicallly a single line, didn't want to change that  :-)

[16:49] <FROGGS[tab]> lizmat, can you remove the "./" and the ".dylib" from that test file?

[16:51] <lizmat> there's no .dylib in the test file ??

[16:52] <FROGGS[tab]> true

[16:52] <FROGGS[tab]> ohh, tht

[16:52] <FROGGS[tab]> that happens in NativeCall.pm

[16:53] <FROGGS[tab]> gah, I ned an osx box -.-

[16:53] <FROGGS[tab]> need*

[16:59] *** echowuhao left
[17:02] *** larion left
[17:10] <masak> m: my declared $ = 0

[17:10] <camelia> rakudo-moar 7970ff: OUTPUT«[31m===[0mSORRY![31m===[0m␤Type 'declared' is not declared␤at /tmp/N7rg2Ntw9D:1␤------> [32mmy declared[33m⏏[31m $ = 0[0m␤Malformed my␤at /tmp/N7rg2Ntw9D:1␤------> [32mmy [33m⏏[31mdeclared $ = 0[0m␤␤»

[17:10] <masak> lies! :P

[17:10] <masak> m: my not-declared $ = 0

[17:10] <camelia> rakudo-moar 7970ff: OUTPUT«[31m===[0mSORRY![31m===[0m␤Type 'not-declared' is not declared␤at /tmp/ewyg1onhB3:1␤------> [32mmy not-declared[33m⏏[31m $ = 0[0m␤Malformed my␤at /tmp/ewyg1onhB3:1␤------> [32mmy [33m⏏[31mnot-declared $ = 0[0m␤␤»

[17:11] * masak stares down the compiler

[17:11] <masak> moritz: ch105 is out. I read it at 02:10 local time.

[17:11] <TimToady> The computer strikes --(MORE)--

[17:11] <arnsholt> Use-mention, my old nemesis, we meet again!

[17:11] <masak> moritz: not as good as ch104, but still good.

[17:11] <TimToady> You lose 13 hit points

[17:12] <masak> arnsholt: "Use-mention", my old nemesis, we meet again! :P

[17:12] <timotimo> maybe we should try to match the parts of the error message that the user can change against the parts that are static in the exception object and if there's significant match-up we'll add "(haha, i see what you did there)" somewhere

[17:12] <arnsholt> masak: Le sigh. English really needs a vocative case =D

[17:12] *** diana_olhovik_ joined
[17:12] <masak> arnsholt: O mouse!

[17:15] <masak> rurban: you should charge money for your "Parrot threads are better" routine.

[17:16] *** Kristien joined
[17:17] <Kristien> hi

[17:20] <[Coke]> I don't think the discussion about parrot threads is really helping anything at this point, folks.

[17:20] <masak> Kristien: oh hai

[17:23] <timotimo> i'd like a few voices on the "enormous bootstrapping stage written in nqp" comment rurban made in the reddit comment thread here: https://www.reddit.com/r/perl6/comments/2w3asu/suspending_rakudo_support_for_parrot/

[17:26] <[Coke]> timotimo: I'm not sure it'll do anything other than create smoke.

[17:26] <timotimo> rurban: i don't think i really understand this about the proxies in parrot that are used for threading: at what point does the "owning" thread check if there are any outstanding accesses to objects it owns?

[17:27] <timotimo> AFK for a bit

[17:27] <flussence> I think the best possible response to any perl6 thread chromatic's involved in is stony silence.

[17:29] <arnsholt> flussence: Agreed

[17:30] <itz> flussence++

[17:36] <masak> some part of me is sad that we lost chromatic. he sure seems to have spare time he could've spent contributing.

[17:37] <itz> I know of at least one "anti-sixer" who returned to the fold in the last year :)

[17:38] <lizmat> itz someone we know ?

[17:38] * masak .oO( iz it someone we know? ) :P

[17:39] <itz> well I spoke to $certain_person last FOSDEM and he was quite negative about 6 and he spoke on it this one :)

[17:40] <lizmat> seriously: I know from personal experience what it means to have your project, on which you spent a good part of your life, go down the drain into oblivion

[17:40] <lizmat> it hurts, *every* time

[17:43] <itz> . o O ( sorry $certain-person )

[17:44] *** Kristien left
[17:46] *** kjs_ left
[17:46] *** xfix left
[17:48] *** Ven left
[17:49] *** Ven joined
[17:50] *** rurban left
[17:50] *** Ven left
[17:51] *** fhelmberger left
[17:52] *** Rounin joined
[17:52] *** perl6_newbee joined
[17:53] *** virtualsue left
[17:54] <perl6_newbee> hi all

[17:54] <perl6_newbee> can someone explain how to create a module with just sub exported?

[17:55] <tadzik> sure

[17:55] <tadzik> can I point you to an example?

[17:55] <perl6_newbee> off course

[17:55] *** xfix joined
[17:55] <tadzik> https://github.com/tadzik/perl6-Term-ANSIColor/blob/master/lib/Term/ANSIColor.pm#L38 this is probably the easiest one I have :)

[17:56] <tadzik> or maybe https://github.com/tadzik/Text-T9/blob/master/lib/Text/T9.pm

[17:56] <tadzik> this one is even smaller

[17:56] *** TgMts left
[17:56] <tadzik> basically: have a file that says 'module your-module-name;" on top, and then have a sub foo() is export {}

[17:56] <perl6_newbee> cool thx tadzik

[17:56] <tadzik> you're welcome :)

[17:57] <perl6_newbee> gread. I love Perl6 :-)

[17:57] <perl6_newbee> great

[17:57] <perl6_newbee> thx

[17:58] <perl6_newbee> and it just works ^^

[17:59] <perl6_newbee> However, is there a change to get a Perl6 module for COmmand Line Argument parsing like Getopt::Long?

[17:59] <tadzik> yes, that's built-in these days

[17:59] <tadzik> let me find something for you

[18:00] <tadzik> https://perl6advent.wordpress.com/2010/12/02/day-2-interacting-with-the-command-line-with-main-subs/ there's some

[18:00] <perl6_newbee> hmm, the sub MAIN(...) handling is handy, but I think it is not so powerfull like Getopt::Long, is it?

[18:00] <tadzik> any particular thing you're missing?

[18:01] *** dakkar left
[18:01] <TimToady> m: / \  /

[18:01] <camelia> rakudo-moar 7970ff: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/OEzxNtSLvy␤No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes (' ') or use a backslashed form like \x20␤at /tmp/OEzxNtSLvy:1␤------> [32…»

[18:02] <TimToady> japhb: ^^^  you're wrong on the internet :)

[18:02] <perl6_newbee> hmm. not at the moment. If you say its comparable with Getopt::Long, then I am fine with it

[18:03] <tadzik> I'm not a poweruser of Getopt::Long, but I never found myself missing some feature in MAIN

[18:03] <tadzik> oh, except one thing, actually

[18:03] <tadzik> https://github.com/tadzik/panda/blob/master/bin/panda#L14 this

[18:04] <dalek> rakudo/newio: 1c3d562 | lizmat++ | src/core/ (2 files):

[18:04] <dalek> rakudo/newio: Move TRANSPOSE(-ONE) to more suitable place

[18:04] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/1c3d562e21

[18:04] <tadzik> by default flags can only come before positional arguments

[18:09] <perl6_newbee> sorry, what does Line 15 do? its grep all strings starting without '-', then greps all string with a '-' and stores them in args array.

[18:09] <perl6_newbee> time to start the perl6 REPL :-)

[18:09] <tadzik> perl6_newbee: it moves all the words starting with - before the ones that don't :)

[18:10] <timotimo> right, the "," operator there can be thought of as "list concatenation"

[18:10] <perl6_newbee> ah I see

[18:10] <perl6_newbee> clever

[18:10] <tadzik> hoelzro, hoelzro, wanna see a sailfish app? :)

[18:10] <timotimo> so switches never have arguments to them, tadzik?

[18:10] <tadzik> oh, you don't use it anymore, nvm :)

[18:10] <tadzik> timotimo: heh, apparently :D

[18:11] <tadzik> or there are undiscovered bugs

[18:11] <timotimo> :)

[18:11] <tadzik> multi MAIN ('smoke', :$exclude = 'panda')

[18:11] <tadzik> the latter

[18:11] <tadzik> good catch

[18:12] <b2gills> I still don't understand the reason switches had to be the first arguments

[18:13] <tadzik> me neither

[18:13] <timotimo> <3

[18:13] <masak> that makes three of us.

[18:14] <timotimo> i have that same HUH, too

[18:14] <tadzik> timotimo: it makes me think that I should make a module that does it right, so no one else has to make that mistake again

[18:14] <timotimo> yeah

[18:14] <tadzik> or we can just fix the spec :P

[18:14] <tadzik> after hearing the rationale

[18:14] <timotimo> here's another module i want to write, btw: offering a TUI that consists of a line for input and the rest of the screen is output from the program

[18:15] <timotimo> so that you can asynchronously push messages to the screen and still have proper line-editing input for the user

[18:15] *** espadrine_ left
[18:15] *** grettir joined
[18:16] <perl6_newbee> ok, its a bit off toppic now, but i will stick with MAIN. THX tadzik

[18:17] *** perl6_newbee left
[18:18] *** kjs_ joined
[18:21] *** Ven joined
[18:25] *** Kristien joined
[18:33] *** khisanth__ is now known as Khisanth

[18:33] *** FROGGS joined
[18:34] *** wicope left
[18:35] *** _mg_ joined
[18:38] *** wicope joined
[18:39] <flussence> timotimo: that road leads to madness and window managers...

[18:39] *** rurban joined
[18:43] <dalek> rakudo/newio: 6a0b40d | lizmat++ | src/core/Str.pm:

[18:43] <dalek> rakudo/newio: Make Str.trans("f","t") 2x as fast

[18:43] <dalek> rakudo/newio: 

[18:43] <dalek> rakudo/newio: By repurposing the internal TRANSPOSE-ONE helper sub

[18:43] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/6a0b40dfe8

[18:43] *** Peter_R left
[18:45] *** Peter_R joined
[18:47] *** kjs_ left
[18:50] *** larion joined
[18:51] <tadzik> flussence: nah, we can quit whenever we can! :P

[18:53] *** Ven left
[18:53] <dalek> rakudo/nom: 3ab11b4 | lizmat++ | src/core/Str.pm:

[18:53] <dalek> rakudo/nom: Backport TRANSPOSE(-ONE) from newio branch

[18:53] <dalek> rakudo/nom: 

[18:53] <dalek> rakudo/nom: We probably want the generic speed increases in 2015.02 already

[18:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ab11b49dc

[18:57] <masak> you know what would be hilarious? a bot that activated when dalek gets flood-booted, and prints out the rest of the commit message :P

[18:58] <sergot> :D

[18:59] <dalek> rakudo/nom: 0f73e0f | lizmat++ | src/core/Str.pm:

[18:59] <dalek> rakudo/nom: Make Str.trans("f","t") 2x as fast

[18:59] <dalek> rakudo/nom: 

[18:59] <dalek> rakudo/nom: By repurposing the internal TRANSPOSE-ONE helper sub

[18:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f73e0f9bb

[18:59] <tadzik> :D

[18:59] <tadzik> lizmat+

[18:59] <tadzik> lizmat++

[19:00] <timotimo> m)

[19:00] <hoelzro> tadzik: sure!

[19:00] <timotimo> lizmat++

[19:06] <Kristien> Thanks to tadzik I want tzatziki.

[19:06] <timotimo> :D

[19:06] <tadzik> :D

[19:08] <nwc10> what's up with slowhub?

[19:09] <nwc10> it hasn't been slowhub for ages

[19:09] <tadzik> seems to work for me

[19:09] <nwc10> OK, maybe it's "my" machine...

[19:09] <tadzik> or your network region 

[19:10] <masak> or your region of the galaxy

[19:10] <nwc10> timeouts randomly about 20% of the time

[19:10] <nwc10> yes, might be my part of the galaxy

[19:10] <timotimo> status.github.com seems fine

[19:10] *** telex left
[19:10] <dalek> rakudo/cpp: 0ec61df | FROGGS++ | / (3 files):

[19:10] <dalek> rakudo/cpp: start adding C++ support to NativeCall

[19:10] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/0ec61df51e

[19:11] <Kristien> timotimo: it doesn't here

[19:11] *** rindolf left
[19:12] *** telex joined
[19:13] *** sqirrel joined
[19:13] *** virtualsue joined
[19:13] <timotimo> oh? maybe i'm not interpreting the data right, then

[19:14] <Kristien> http://i.imgur.com/EJO1su3.png

[19:14] <timotimo> huh?

[19:14] <timotimo> i don't get anything like that

[19:14] <timotimo> even after reloading afresh

[19:14] <Kristien> Me neither. I'm just kidding.

[19:14] *** zakharyas left
[19:14] <nwc10> nor do I

[19:14] <timotimo> ooooh

[19:15] <timotimo> you got me there %)

[19:15] <PerlJam> Kristien: way to be disruptive!  :)

[19:16] <nine_> Would have been easy to find out if they used proper time stamps instead of "user friendly" relative time

[19:16] <timotimo> hehe.

[19:17] <timotimo> well, you can hover your mouse over it

[19:17] <timotimo> and see the exact timestamp

[19:17] <Kristien> relative user-friendly timestamps? pfft, ruby hipsters

[19:17] <dalek> rakudo/cpp: a29d33f | FROGGS++ | t/04-nativecall/11-cpp.t:

[19:17] <dalek> rakudo/cpp: fix path to C++ test library source

[19:17] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/a29d33f653

[19:19] <timotimo> rurban: i'm sure i'm not interpreting what you wrote correctly; parrots runloop currently has to start a whole new interpreter for each method?

[19:19] <timotimo> the whole paragraph kind of stumps me, to be honest

[19:19] <nine_> We had to add the same crap to our intranet. So a customer calls and has a question about an invoice dated July 13th and the poor accountant had to hover her mouse over a long list of invoices dated "4 months ago" to find the one. Good thing we added a hidden setting (just for me and the test suite) to get the old behavior.

[19:19] <FROGGS> nine_: *g*

[19:20] <FROGGS> human friendly done wrong

[19:20] <nine_> Yes it was our web designers who petitioned for that "feature".

[19:21] <timotimo> <3

[19:21] *** colomon left
[19:23] <FROGGS> I also put in a feature like that two weeks ago...

[19:23] <FROGGS> it is for our technicians and it only shows "n hours ago" in case it is less than 8 hours ago

[19:23] <FROGGS> everything else is displayed as timestamps

[19:24] <jdv79> jira does the same thing - prints vague time string and hover gets the exact

[19:24] <jdv79> works great on mobile or touch device i imagine

[19:24] <b2gills> Something like that is fine if you are only going to visually scan it

[19:25] <jdv79> i would at least like a user option to flip it

[19:25] <jdv79> i need the exact time almost always

[19:25] <jdv79> usually trying to triage what just went wrong and i need to compare the time with some other source of change

[19:30] *** abraxxa left
[19:31] <muraiki> "within the last fortnight"

[19:35] *** colomon joined
[19:35] <nine_> OTOH I love KDE's fuzzy clock ;) Especially when it tells me that it's "Almost noon" at 9:30 :)

[19:38] <timotimo> :D

[19:39] <tadzik> haha, an optimist clock. "It's almost 17:00!"

[19:41] <moritz> hobbit clock, "time to eat!"

[19:42] *** Ugator joined
[19:43] <moritz> fwiw p-spectest here fails S19-command-line/repl.t

[19:43] <moritz> Badplan, you planned 1 test but ran 0

[19:43] * masak .oO( nanananananana -- Badplan! )

[19:44] <moritz> itz: http://pl6anet.org/ doesn't seem to have picked up http://pmthium.com/2015/02/suspending-rakudo-parrot/

[19:51] <dalek> star: 28cb7b1 | moritz++ | / (4 files):

[19:51] <dalek> star: Remove NativeCall

[19:51] <dalek> star: 

[19:51] <dalek> star: starting from 2015.02, it ships with rakudo itself

[19:51] <dalek> star: review: https://github.com/rakudo/star/commit/28cb7b1c38

[19:52] <flussence> I like how `dmesg -H` shows timestamps - it's the same as what FROGGS described, but scaled down an order of magnitude.

[19:53] *** _mg_ left
[19:54] *** grondilu joined
[19:54] <grondilu> FROGGS++ work on C++ NativeCall

[19:56] <hoelzro> FROGGS++

[19:56] <flussence> FROGGS++

[19:56] <FROGGS> O.o

[19:57] <itz> odd http://pmthium.com/category/perl6/feed/ doesn't have the posting

[19:57] <flussence> (if that ends up being as straightforward as the C bindings, we may have a "killer feature")

[19:57] <dalek> rakudo/nom: 9bf52eb | lizmat++ | src/core/Str.pm:

[19:57] <dalek> rakudo/nom: Make Str.subst(Str,Str,:global) about 12x faster

[19:57] <dalek> rakudo/nom: 

[19:57] <dalek> rakudo/nom: By using the TRANSPOSE helper sub

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9bf52ebc11

[19:57] *** _mg_ joined
[19:58] <lizmat> not sure if that affects s:g/// as well

[19:58] <nwc10> itz: might be an implementation bug/artefact. IIRC he psoted it, then pulled it, and then reposted it some days later. I think on the same URL. That might confuse the feed thingy

[19:58] <masak> oh, I had missed that.

[19:58] <masak> why was it pulled?

[19:59] <Kristien> one problem I always have with FFIs is using types defined in C

[19:59] <Kristien> like off_t

[19:59] <FROGGS> masak: he wanted to talk to #parrot first

[19:59] <Kristien> they're not well-defined so you have to include the headers in which they are defined in order to use them

[19:59] <Kristien> but FFIs typically don't allow you to do that

[20:00] <hahainternet> they don't?

[20:00] <Kristien> can you include a C header in Perl 6?

[20:00] <masak> FROGGS: he did. he posted a gist draft at #parrot first.

[20:00] <FROGGS> Kristien: this will look like: my native off_t is repr("P6int") is Int is ctype("off_t") { };

[20:01] <hahainternet> Kristien: i've no idea, but i am doing so in golang

[20:01] <itz> nwc10: I think its on another RSS feed not the perl6 specific one

[20:01] <hahainternet> that's because it creates its own c

[20:01] <Kristien> yes Go allows it

[20:01] <FROGGS> Kristien: though, atm the VM must be aware of all of these ctypes in beforehand

[20:01] <hahainternet> there's no reason p6 can't

[20:01] <Kristien> but Haskell doesn't, and neither do Python and Ruby for as far as I know

[20:01] <Kristien> FROGGS: OK

[20:01] <nwc10> http://irclog.perlgeek.de/perl6/2015-02-04#i_10060971 - 19:17

[20:01] <itz> ah its there now

[20:01] <nwc10> http://irclog.perlgeek.de/parrot/2015-02-04#i_10061006 - 19:22

[20:02] <Kristien> One could possible implement it with libclang though that's quite heavyweight and requires the headers to be available on the machine of the user.

[20:02] <itz> moritz: fixed

[20:03] *** [Sno] left
[20:03] *** vendethiel joined
[20:06] * [Coke] is bummed that yapc is again too early to take the family.

[20:06] <masak> yapc::eu?

[20:06] <[Coke]> there were about 2 years (a long time ago) when it was after the kids got of school for the summer.

[20:06] <[Coke]> NA

[20:07] <moritz> YAPC Not Available :-)

[20:10] <nine_> masak: thanks to you I now have the Batman theme playing up and down in my head

[20:10] *** Rounin left
[20:13] <hahainternet> nine_: which theme?

[20:14] <hahainternet> if it's not from the 70s and grey, it's nothing

[20:14] <moritz> hahainternet: please no cultural elitism

[20:14] <hahainternet> moritz: :D

[20:15] <hahainternet> now i can't stop the spinning transition chime from playing in my head

[20:18] <nine_> moritz: the one with the occational POW! :0

[20:24] <dalek> rakudo/nom: c81abe2 | FROGGS++ | lib/NativeCall.pm:

[20:24] <dalek> rakudo/nom: fix lib loading for NativeCall on JVM on OSX

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c81abe2fa9

[20:24] <FROGGS> lizmat: ^^

[20:24] <FROGGS> -.-

[20:25] <lizmat> FROGGS will check right away

[20:26] *** darutoko left
[20:26] <dalek> rakudo/newio: 3ab11b4 | lizmat++ | src/core/Str.pm:

[20:26] <dalek> rakudo/newio: Backport TRANSPOSE(-ONE) from newio branch

[20:26] <dalek> rakudo/newio: 

[20:26] <dalek> rakudo/newio: We probably want the generic speed increases in 2015.02 already

[20:26] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/3ab11b49dc

[20:26] <dalek> rakudo/newio: 0f73e0f | lizmat++ | src/core/Str.pm:

[20:26] <dalek> rakudo/newio: Make Str.trans("f","t") 2x as fast

[20:26] <dalek> rakudo/newio: 

[20:26] <dalek> rakudo/newio: By repurposing the internal TRANSPOSE-ONE helper sub

[20:26] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/0f73e0f9bb

[20:26] <dalek> rakudo/newio: 9bf52eb | lizmat++ | src/core/Str.pm:

[20:26] <dalek> rakudo/newio: Make Str.subst(Str,Str,:global) about 12x faster

[20:26] <dalek> rakudo/newio: 

[20:26] <dalek> rakudo/newio: By using the TRANSPOSE helper sub

[20:26] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/9bf52ebc11

[20:26] <dalek> rakudo/newio: c386f34 | lizmat++ | src/core/Str.pm:

[20:26] <dalek> rakudo/newio: Merge branch 'nom' into newio

[20:26] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/c386f3449d

[20:26] *** kjs_ joined
[20:27] <moritz> ok, weird things are weird. It looks like perl6-p REPL prints the 

[20:27] <moritz> prints the '>' to STDERR

[20:28] <moritz> whereas ./perl6-m >/dev/null hangs and doesn't react to Ctrl+C or Ctrl+Z

[20:28] *** abraxxa joined
[20:28] *** abraxxa left
[20:29] <lizmat> FROGGS: much better now, but got things like:

[20:29] <lizmat>   Parse errors: Tests out of sequence.  Found (2) but expected (1)

[20:29] <lizmat>                 Bad plan.  You planned 3 tests but ran 1.

[20:30] <lizmat> :-(

[20:30] <FROGGS> lizmat: aye

[20:30] <lizmat> which would be the other problem

[20:30] <FROGGS> I just wanted to say, there is a buffering problem when we say() from P6 and printf() from C

[20:30] <FROGGS> but, I got that too, I'll will either provide a fix or a workaround

[20:30] *** bjz left
[20:31] <FROGGS> I mean, that's not an error with nativecall

[20:31] <lizmat> indeed

[20:31] <FROGGS> and it only happens when you run `make j-test`

[20:31] <FROGGS> prove etc does not have this kind of issue

[20:31] <FROGGS> ohh, I perhaps know why it happens...

[20:32] <FROGGS> we merge stdin and stdout in t/harness

[20:32] <lizmat> confirmed that all NativeCall tests run fine by themselves

[20:32] <lizmat> FROGGS++

[20:33] <FROGGS> and that bloody KERNEL/DISTRO thingy! >.<

[20:33] <FROGGS> I guess I'll memorize the distinction now :o)

[20:34] *** FROGGS[tab] left
[20:34] <lizmat> aha!

[20:34] <lizmat> ok

[20:35] <lizmat> maybe needs backporting to the Zavolaj repo ?

[20:35] <FROGGS> lizmat: that got cleared

[20:35] <lizmat> ok  :-)

[20:35] <lizmat> problem solved :-)

[20:35] <FROGGS> :o)

[20:35] <FROGGS> there is no going back :P

[20:35] <FROGGS> and the future is bright

[20:36] <moritz> FROGGS: though next time that you make such a change, please either do it in a branch, or shortly after a release (not before one)

[20:36] <lizmat> :-)

[20:37] <FROGGS> moritz: well, it was in a branch

[20:38] *** sqirrel left
[20:38] <FROGGS> the problem is, the issues/mails about: "halp, I cannot build NativeCall or Inline::C" increased

[20:38] <FROGGS> and keeping that for another month is also not good

[20:38] <FROGGS> and, this way the issues for parrot and jvm got solved (issues that perhaps nobody was aware of, but still)

[20:39] <moritz> a non-nom branch

[20:39] <FROGGS> okay, we did know about the parrot problem... (we even had messages in the star announcement)

[20:43] <FROGGS> moritz: ohh, I did not put it in a branch... true

[20:43] <FROGGS> I mixed up with the other do branches I messed with :o)

[20:43] <FROGGS> (longer and cpp)

[20:49] <Mouq> Do we want NativeCall tests to be in Roast?

[20:49] *** virtualsue_ joined
[20:50] *** virtualsue left
[20:50] <[Coke]> depends on if they're spec or just a really really handle rakudo thing.

[20:50] <[Coke]> *handy

[20:51] <rjbs> ?

[20:51] <rjbs> oops, ww

[20:51] <timotimo> there's a design document that covers NativeCall

[20:51] <lizmat> Mouq: no, because they are implementation specific to rakudo

[20:51] <timotimo> but it's more or less a description of what NativeCall does

[20:51] <FROGGS> lizmat: the api is not rakudo specific

[20:52] <FROGGS> the is native trait is even in the setting, not in rakudo, mind

[20:52] <lizmat> FROGGS: I can't fine "is native" in core setting ?

[20:53] *** virtualsue joined
[20:53] <FROGGS> ohh, wait, is nativesize is in there

[20:53] <lizmat> yeah, but not "is native"

[20:54] *** virtualsue_ left
[20:55] <FROGGS> yeah... that needs the Native role the NativeCall module provides

[20:56] *** _mg_ left
[20:57] <arnsholt> If we want NativeCall to be part of the core language, we need to include tests for it in Roast

[20:57] <arnsholt> (Not likely to happen for 6.0 in my estimation)

[20:57] <arnsholt> The problem is figuring out NativeCall tests that can actually go in roast

[20:58] <arnsholt> ATM, we're dependent on being able to compile libs with test functions, which in turn relies on Rakudo (and even backend) specific stuff to get the right commandline to compile stuff

[20:59] <FROGGS> yes, does roast require a C compiler in future for everyone? I hope not

[20:59] <lizmat> arnsholt: there are tests, but in "make test"

[20:59] <lizmat> that's good enough for me for 6.0

[20:59] <FROGGS> so, let's keep it the way we have it now, until we have a strong reason to etst it

[21:00] <FROGGS> change it*

[21:00] * moritz eats freshly caramelized chestnuts

[21:01] <Kristien> When I read "chestnuts" I imagined something very weird.

[21:02] *** kjs_ left
[21:03] <arnsholt> FROGGS: Exactly. And making tests to test eveything using only C stdlib doesn't sound fun

[21:03] <FROGGS> aye

[21:03] <grondilu> there are other possibilities than stdlib

[21:03] *** kjs_ joined
[21:08] <nine_> Discussion about Perl 6's infix ^^ operator and short circuiting: http://lwn.net/Articles/633648/

[21:11] <grondilu> wth I totally did not know about this one.

[21:11] <TimToady> infix:<^^> is really one()

[21:12] <TimToady> if you want parity, you can always use ?^ instead

[21:12] *** kjs_ left
[21:14] <grondilu> m: say .WHAT given 1 ^^ 2

[21:14] <camelia> rakudo-moar 9bf52e: OUTPUT«Nil␤»

[21:14] <grondilu> it does not return a junction though.

[21:14] *** kjs_ joined
[21:14] <grondilu> m: say .WHAT given one(1, 2)

[21:14] <camelia> rakudo-moar 9bf52e: OUTPUT«(Junction)␤»

[21:14] <TimToady> oh, I guess that's infix:<^>, duh

[21:14] <grondilu> m: say .WHAT given 1 ^ 2

[21:14] <camelia> rakudo-moar 9bf52e: OUTPUT«(Junction)␤»

[21:14] <TimToady> still, it's "one" semantics, not parity

[21:14] <Mouq> m: 1 ^^ 1 ^^ say "oops"

[21:14] <camelia> rakudo-moar 9bf52e: ( no output )

[21:14] <Mouq> m: 1 ^ 1 ^ say "oops"

[21:14] <camelia> rakudo-moar 9bf52e: OUTPUT«oops␤»

[21:15] <Mouq> m: 1 ?^ 1 ?^ say "oops"

[21:15] <camelia> rakudo-moar 9bf52e: OUTPUT«oops␤»

[21:15] <moritz> people link to doc.perl6.org \o/

[21:15] <grondilu> makes sense since junction operators are one character long.

[21:15] <arnsholt> grondilu: What other options do you have in mind?

[21:15] <Mouq> m: 1 xor 1 xor say "oops"

[21:15] <camelia> rakudo-moar 9bf52e: ( no output )

[21:15] <TimToady> xor is just low precedence ^^

[21:15] <grondilu> arnsholt: don't know.  gmp, ssl, X11...

[21:16] <Kristien> If you put a block of Perl 6 code in a regex can you detect whether it is backtracking?

[21:16] <arnsholt> grondilu: One word: Windows. =)

[21:16] <FROGGS> grondilu: on wind... yeah

[21:16] <grondilu> yeah I forgot about that indeed.

[21:16] * grondilu tends to forget not everyone uses *nix

[21:16] <TimToady> Kristien: blocks are only executed on forward, but you can tell if you revisit a spot going forward

[21:17] *** [Sno] joined
[21:17] <Kristien> Ah right.

[21:17] <arnsholt> The existence of jnthn keeps me honest in that regard =)

[21:17] <Kristien> Sounds a little cumbersome though.

[21:17] <Kristien> e.g. when parsing context-sensitive grammars

[21:17] <FROGGS> grondilu: and the good and important thing about nativecall is: it just works even on that forgotten platform :o)

[21:18] <TimToady> if you want to remember something, it should be stored in the cursor, and then it automatically goes away when the cursor is discarded; therefore throwing things away explicitly is a code smell

[21:19] <Kristien> Oh cool.

[21:19] *** rjbs left
[21:19] <skids> m: role A { my @a := Any }; class B does A { } # LTA error

[21:19] <camelia> rakudo-moar 9bf52e: OUTPUT«===SORRY!===␤Could not instantiate role 'A':␤Type check failed in binding; expected 'Positional' but got 'Any'␤»

[21:20] <skids> Oh, that's different.  Still not TA

[21:20] *** coffee` left
[21:20] <skids> (As no line number)

[21:21] <grondilu> nativecall might be an extremely useful module in the future.  Has it been considered to put it in the core?

[21:21] <lizmat> grondilu: it is now

[21:21] <TimToady> it's already been decided to do that

[21:21] <grondilu> I mean in a way we don't have to write 'use NativeCall;'

[21:21] <lizmat> you just have to activate it, with "use NativeCall"

[21:21] <Kristien> lol

[21:21] <lizmat> ah, hmmm....

[21:22] <TimToady> we might get some relief on that, if it makes sense

[21:22] <TimToady> especially if we introduce some kind of 'use native "mylib";' notation

[21:22] * Mouq votes for keeping the use; it's a case where I definitely want to know if there's external dependencies upfront

[21:23] <Mouq> TimToady: In that case, then I'd be fine with core

[21:23] <grondilu> TimToady: what about something like:  use <mylib>, :C  ?

[21:23] <grondilu> (I mean sending :C as an option to "use")

[21:23] <FROGGS> that looks sad

[21:23] <TimToady> it does :)

[21:24] <grondilu> yeah but that could be generalized to other languages

[21:24] <FROGGS> we have :from<C> for that perhaps

[21:24] <arnsholt> I'm not sure how we'd implement 'use native "mylib"' though

[21:24] <FROGGS> arnsholt: me neither

[21:24] <grondilu> oh, yeah, that works too

[21:24] <arnsholt> Getting the list of symbols isn't completely impossible, but figuring out the signatures is a different matter

[21:25] <grondilu> we may require headers

[21:25] <TimToady> was merely suggesting to factor out the 'is native "mylib"' that is just boilerplate

[21:25] <arnsholt> Oh, right!

[21:25] <arnsholt> That's a lot less impossible, yeah!

[21:25] <TimToady> you guys keep sayin' how impressive the interface is, and I keep seeing all this violation of DRY

[21:25] <FROGGS> TimToady: how do I declare a native sub and a regular sub then, when I leave off the trait?

[21:26] <grondilu> DRY?

[21:26] <FROGGS> do I get a new keyword?

[21:26] <moritz> grondilu: Don't Repeat Yourself

[21:26] <FROGGS> you can't say that again

[21:27] <moritz> my &n = curry_native('sqlite3'); n sub foo() { ... }

[21:27] <geekosaur> heh

[21:27] <TimToady> possibly it's a different declarator, or possibly it scopes somehow over the declarations it's meant to allow

[21:27] *** kjs_ left
[21:28] <Mouq> Could it just be that "is native "mylib"" does 'BEGIN $*NATIVE_LIB = "mylib"' and then subs with the "is native" trait and no arguments to it are assumed to be of $*NATIVE_LIB?

[21:28] <grondilu> having to redeclare in Perl 6 is annoying anyway.

[21:28] <FROGGS> Mouq: that's only half awesome :o)

[21:28] <TimToady> well, it'd be an improvement

[21:28] <moritz> grondilu: I think it's awesome, it lets you 'git grep' for the Perl 6 symbols

[21:29] <grondilu> translating the C header to a Perl declaration is a job for a machine, not a human.

[21:29] <FROGGS> and you never just call into C, you always have to abstract a little 

[21:30] <moritz> grondilu: I have no qualms with generated declarations, as long as there *are* declarations

[21:30] <TimToady> when a C api gives you a string pointer and a length, you really, really want to combine those into a Str or Buf

[21:31] *** Ugator left
[21:31] <TimToady> same for arrays

[21:31] <TimToady> C's pointer/array confusion is one of the all-time great language design botches

[21:31] <dalek> rakudo/nom: 9add92b | lizmat++ | docs/ChangeLog:

[21:31] <dalek> rakudo/nom: Add Str.subst being 12x as fast

[21:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9add92b8d7

[21:31] <grondilu> on the other hand, I can understand that the Perl declaration must exist somewhere otherwise it's not easy to infer the perl interface from the C one.

[21:31] <FROGGS> *g*

[21:33] <grondilu> wow 12x improvement on a method as important as Str.subst is quite something.

[21:34] <FROGGS> aye

[21:34] <FROGGS> lizmat++

[21:38] *** xfix left
[21:38] <grondilu> still, being able to use a library of a library from an other language (mainly C) in the same manner as we use a module in Perl 6 would be great.  Having the C header being automatically translated in NativeCall Perl 6 declarations would nice, but it'd be even nicer if it was all mostly transparent. 

[21:38] <lizmat> grondilu: alas, it does not affect s:g///

[21:38] <lizmat> for that I need to mingle subst-mutate

[21:38] <grondilu> ok

[21:38] <lizmat> and a way to indicate that it's called in sink context

[21:39] <lizmat> m: my $a = "foof"; say $a ~~ s:g/f/bar/; say $a

[21:39] <camelia> rakudo-moar c81abe: OUTPUT«｢f｣ ｢f｣␤baroobar␤»

[21:39] <lizmat> so we can do it without creating match objects

[21:39] <arnsholt> TimToady: Yeah, that's really annoying. But I don't think we're able to abstract that away in an FFI API, as I suspect it's basically halting-problem complete to figure out when pointer+int is "one" argument and when it isn't

[21:39] <lizmat> grondilu: that would probably be an Optimizer.nqp job

[21:40] <arnsholt> The FFI plumbing has to expose it as it is, and then it's up to the wrapper author to provide a better API to the users of the library

[21:40] <lizmat> to find any calls to subst-mutate, and check for :g and sink context, then pass an extra named to subst-mutate

[21:40] <dalek> roast: deaf607 | usev6++ | S03-operators/misc.t:

[21:40] <dalek> roast: Add test for RT #122654

[21:40] <dalek> roast: review: https://github.com/perl6/roast/commit/deaf607dfb

[21:40] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122654

[21:40] * grondilu notices that importing from an other language is already specced in S11

[21:40] <lizmat> for which we could then do a separate multi

[21:41] <lizmat> PSA: do we have a suggestion for a release name ??

[21:41] *** diana_olhovik_ left
[21:42] <lizmat> PSA: possibly a very good one, as it will be the last that many parrot users will see for a long time?

[21:42] <grondilu> in S11 there is a mention of 'use somemodule:from<perl5>'.  Is the idea supposed to be limited to perl or can we imagine 'use somelib:from<C>;'?

[21:42] <lizmat> grondilu: should be expandable

[21:42] <lizmat> main problem atm is that it requires meddling with nqp code

[21:42] <lizmat> I *really* like to see that lifted to P6 level

[21:43] <lizmat> so that it can be modularized / pandaized

[21:43] *** rurban left
[21:43] <lizmat> on that note, I'm going to make it an early night for a change

[21:43] <grondilu> I would have expected the main problem to be the generation of the P6 declaration from the headers, but you surely know better so ok

[21:43] <lizmat> sleep&

[21:44] <moritz> lizmat: maybe use a city as release name where parrots are observed in the wild?

[21:45] *** rurban1 left
[21:46] <skids> lizmat: "prolonged squawk"? Or something else from the python sketch I guess.

[21:46] <Kristien> I teach parrots to swear in Dutch.

[21:47] <moritz> skids: our release names are names of perlmonger groups, so usually city names

[21:51] <skids> Well, the only geographic reference in the skit is "pining for the fjords"

[21:52] *** gfldex left
[21:55] * masak .oO( NorwegianBlue.pm )

[21:56] *** rjbs joined
[21:56] *** rjbs left
[21:56] *** rjbs joined
[21:59] <FROGGS> ohh dear

[22:00] <skids> .oO(Unless there's a city homonymous with "Praline")

[22:00] *** Kristien left
[22:03] *** kjs_ joined
[22:05] *** FROGGS_ joined
[22:06] *** Sqirrel_ left
[22:07] *** FROGGS_ left
[22:07] *** skids left
[22:07] <dalek> doc: fac770f | moritz++ | lib/ (2 files):

[22:07] <dalek> doc: grammars: document action methods

[22:07] <dalek> doc: review: https://github.com/perl6/doc/commit/fac770fe4c

[22:08] *** FROGGS left
[22:08] <moritz> beware of typos in the patch above; either my fingers are too tired, or my keyboard has started eating/withholding keystrokes

[22:10] <masak> nine_: wow, so much disinformation in that lwn thread.

[22:10] <masak> ("Perl doesn't know Booleans as a data type", "how can anyone possibly short-circuit xor?")

[22:11] <jercos> ...how *do* you short-circuit xor?

[22:12] <masak> maybe http://doc.perl6.org/language/operators#infix_%5E%5E should have an extra caveat snapping people out of their assumption about how infix:<^^> behaves.

[22:13] <masak> something like "Note that the semantics of this operator may not be what you assume: infix:<^^> flips to truthy after finding the first true value, and then flips to Nil *forever* after the second, no matter how many more truthy values there are."

[22:13] *** kjs_ left
[22:13] <masak> jercos: I believe that also answers your question.

[22:14] <jercos> Yes it does.

[22:14] <masak> as well as a lot of confusion in that lwn thread.

[22:14] <jercos> The answer is "when you have more than two values", because it actually is exclusive or, not boolean parity.

[22:14] <masak> right.

[22:15] <jercos> Which is clever and useful, but probably unintuitive for a great many people.

[22:15] <masak> it does make sense, insofar as the actual behavior is the one that's harder to emulate in some other way. (but still often useful.)

[22:15] <masak> right.

[22:15] <jercos> Oh well, can't make an omlette without breaking a few basic boolean assumptions

[22:16] <masak> I confess to not understanding why it returns `Nil`, not `False`.

[22:16] <masak> but I remember there being discussions (and some back-and-forth) on the matter.

[22:16] <moritz> masak: patch doc.perl6.org?

[22:17] <jercos> That seems to match the pattern of returning the first true value rather than just `True`

[22:17] <masak> moritz: on it.

[22:17] <moritz> ++masak

[22:18] <jercos> Or rather, returning *the* true value.

[22:18] *** betterwo1ld left
[22:18] <masak> oh, right. Pod.

[22:18] *** betterworld joined
[22:18] * masak decides to not be fancy with formatting :)

[22:18] <grondilu> m: say 0 || 0

[22:18] <camelia> rakudo-moar c81abe: OUTPUT«0␤»

[22:19] <grondilu> ^ that does not return "Nil"

[22:19] <jercos> m: say 0 ^^ False

[22:19] <camelia> rakudo-moar c81abe: OUTPUT«False␤»

[22:19] <jercos> m: say True ^^ True

[22:19] <camelia> rakudo-moar c81abe: OUTPUT«Nil␤»

[22:20] <jercos> So I guess it passes through the last value if none match, but Nil if too many match.

[22:20] <grondilu> &<^^> does not always use one of his argument for its return value.  It sometimes needs to make one.  Thus it should return a true Boolean constant.

[22:21] <grondilu> imho

[22:21] <dalek> doc: e64be53 | masak++ | lib/Language/operators.pod:

[22:21] <dalek> doc: Insert caveat about infix:<^^>

[22:21] <dalek> doc: 

[22:21] <dalek> doc: Feel free to sharpen the wording further.

[22:21] <dalek> doc: review: https://github.com/perl6/doc/commit/e64be5312f

[22:21] <masak> what dalek said.

[22:22] <grondilu> (on the other hand &<||> also needs to make a return value sometimes, so dunno)

[22:22] <grondilu> there seems to be an inconsistency here anyway.

[22:23] <masak> grondilu: whentimes?

[22:23] <jercos> When does || make a value?

[22:23] <masak> both &[&&] and &[||] are monoidal operations, with obvious units (True and False, respectively)

[22:23] <grondilu> oh sorry

[22:23] <masak> &[^^] is not so clear-cut.

[22:23] <jercos> so like...

[22:23] <jercos> m: say [||] ()

[22:23] <camelia> rakudo-moar c81abe: OUTPUT«False␤»

[22:23] <masak> m: say [^^

[22:23] <camelia> rakudo-moar c81abe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/63toQ4cksr␤Preceding context expects a term, but found infix ^^ instead␤at /tmp/63toQ4cksr:1␤------> [32msay [^^[33m⏏[31m<EOL>[0m␤»

[22:24] <masak> m: say [^^]()

[22:24] <camelia> rakudo-moar c81abe: OUTPUT«False␤»

[22:24] <masak> makes sense, I guess.

[22:24] <grondilu> I thought it had to create a False when returning False, but I was dead wrong.

[22:24] <masak> but if that one can be False, I don't really see why the too-many case can't be, too.

[22:24] <jercos> Well, it does pass specific information about the reason it's false through.

[22:25] <masak> pfeh.

[22:25] <jercos> But then it seems like there should be another boolean-false value to indicate a generated falsehood, rather than re-using Nil

[22:25] <masak> that sounds like a three-valued logic trap to me. 

[22:25] <jercos> yeh, true, false, and FILE_NOT_FOUND

[22:25] *** Kristien joined
[22:26] <masak> "we must pass along extra information about *why* it failed!" -- no. ask a more specific question.

[22:26] <jercos> Yeah I'm starting to feel like Nil might even be Wrong.

[22:27] <masak> if that's *really* important (and I don't think it is), then something like `False but "you can't handle the Truth!"` could work instead of Nil.

[22:35] * grondilu wonders how to write &[^^](*@a) and thinks of multi &infix:<^^>(*@a) { my $a = shift @a; $a && none(@a) or &infix:<^^>(@a) }

[22:41] *** kjs_ joined
[22:43] * grondilu realizes that's wrong

[22:43] <flussence> m: unless fail('oh noes') -> $why { say $why }

[22:43] <camelia> rakudo-moar 9add92: OUTPUT«Unhandled exception: oh noes␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:14862  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:sink…»

[22:43] <flussence> m: unless fail('oh noes') -> $why { say $why.perl }

[22:43] <camelia> rakudo-moar 9add92: OUTPUT«Unhandled exception: oh noes␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:14862  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:sink…»

[22:44] <flussence> I thought failures behaved themselves in a boolean context...

[22:44] <grondilu> .oO( multi &infix:<^^>(*@a) { my $a = shift @a; $a && none(@a) or !$a && &infix:<^^>(@a) }

[22:44] <grondilu> )

[22:48] <Kristien> funfact: sqrt in C is an impure function

[22:48] <grondilu> why?

[22:48] <flussence> it causes an fpu context switch as a side effect

[22:49] <Kristien> errno

[22:49] <Kristien> :P

[22:49] * masak wasn't aware that C had the concept of "pure function"

[22:49] <Kristien> the concept is language-agnostic

[22:49] <grondilu> that why it's a concept :)

[22:50] <Kristien> Plottwist: errno actually means "err, no" as in "err, no you're not gonna get the answer."

[22:52] <grondilu> so flussence's answer is not the correct one?

[22:52] <flussence> depends if you have an fpu or not

[22:54] <Kristien> Is MoarVM embeddable?

[22:54] <Kristien> or Rakudo. I still don't know the difference.

[22:55] <Kristien> and NQP is incredibly abstract to me

[22:57] <hoelzro> Kristien: I don't see why not

[22:57] <hoelzro> I think that's how nine_ did Inline::Perl6

[22:57] <hoelzro> I just think there's no real documentation on how to do it

[22:58] <Kristien> NQP is "a lightweight Perl 6-like environment" but I don't understand what an environment is.

[22:59] <Kristien> hoelzro: neat

[22:59] <hoelzro> so, NQP is a Perl 6 like language

[22:59] <hoelzro> it's "not quite" Perl 6

[22:59] <hoelzro> it's enough Perl 6 to implement Perl 6

[23:00] <hoelzro> if you wanted to embed Rakudo, you could embed MoarVM, and tell it where to find the bytecode for NQP and Rakudo

[23:00] *** tardisx joined
[23:02] <Kristien> OK.

[23:04] *** kjs_ left
[23:06] *** grondilu left
[23:07] *** wicope left
[23:07] <Mouq> Kristien: So, as I understand, MoarVM is written in C, NQP is... it's complicated, but there's an implementation of it in C on MoarVM, and Rakudo is written in NQP

[23:09] <vendethiel> somehow :P

[23:09] <Mouq> NQP is bootstrapping, so once you have an implementation on a backend, you can use the NQP implementation of NQP thereon, so NQP development is actually mostly in NQP

[23:09] <vendethiel> nqp's grammar is written in perl6 yo

[23:10] <Mouq> vendethiel: Not quite :P

[23:10] <vendethiel> then C's grammar ?

[23:11] <vendethiel> .oO( parse ALL the languages, I guess )

[23:11] *** virtualsue left
[23:12] <Mouq> IDK how adding a new backend works, since we use an existing backend so that we DON'T have to re-write NQP in another language from the ground-up, but I don't know how that process works

[23:12] <Mouq> s/language/vm|backend|whatever

[23:14] <Mouq> I could be wrong about a lot of this, though

[23:14] <masak> general question to #perl6: so, Qtrees represent the program source text on an appropriate level. macros are special in that they let you author one (source) Qtree but the compiler generates another (target) Qtree for the program to run. when we introspect Qtrees (for example, inside of macros), what should we expect to see: source Qtrees or target Qtrees? discuss.

[23:15] <masak> (I don't know the answer. genuinely curious to know people's opinions and reasons.)

[23:15] <Kristien> I am more confused than ever.

[23:15] <vendethiel> target

[23:15] <vendethiel> if I want to debug stuff, I need to know what the compiler sees

[23:15] <masak> vendethiel: that was my preferred default, too.

[23:16] <masak> vendethiel: I just don't feel I have a theoretical basis for that preference. :)

[23:16] <timotimo> ... today has been a bit more draining than the usual day ...

[23:16] <vendethiel> masak: I think we're at the "usability" door here: )

[23:16] <Mouq> Kristien: Well, none of what I said is actually important in using Perl 6, so feel free to disregard :P

[23:17] <flussence> would it make things overly complicated to make that situation depend on when you introspect them?

[23:17] <masak> vendethiel: we're most certainly at the "usability" door.

[23:18] <Kristien> I don't see any advantages over stack based VM vs register based VM other than that stack based bytecode tends to be smaller.

[23:18] <Mouq> masak: when does the difference arise?

[23:18] <Kristien> Stack-based code is harder to generate, harder to analyse and harder to interpret.

[23:19] <masak> Mouq: ok, say I have a `macro foo($x)`. I call it in code: `foo(42)`. the source Qtree is that very call. the target Qtree is whatever the macro generates/returns.

[23:19] <Mouq> hugme hug timotimo 

[23:19] * hugme hugs timotimo

[23:19] <timotimo> ^- i know this, having put some time into generating jvm bytecode from rakudo/nqp

[23:19] <masak> Mouq: the difference arises when a (macro) user introspects the Qtree that we already have in a program: does she see macro calls, or their results?

[23:20] * flussence is trying to think of relevant prior art in web languages, but they don't have any concept of "running while compiling" that isn't document.write... bleh

[23:21] <Mouq> Well, isn't the theoretical basis being that it's what the Qtree is at that point? It seems like there would be a different stage at which the user could get the source Qtree

[23:22] <Kristien> bye

[23:22] <masak> the source Qtree sort of only exists to get passed into the macro.

[23:22] *** Kristien left
[23:22] <Mouq> o/ Kristien!

[23:22] <masak> it's possible to link it up with the target Qtree, I guess, so that an intersted introspector could get at it.

[23:22] <masak> but maybe that's unnecessary, or memory-leak-y, or something.

[23:23] <masak> could get horrible in the case of recursive macros.

[23:23] <Mouq> m: foo 1, 2; macro foo ($, $) {}

[23:23] <camelia> rakudo-moar 9add92: ( no output )

[23:23] <masak> don't do that.

[23:23] <masak> there's an RT ticket about it not dying a horrible death, like it should.

[23:23] *** BenGoldberg joined
[23:24] *** kst` joined
[23:24] <Mouq> masak: Why should it? I mean, I'm personally surprised it works at all

[23:24] <masak> it shouldn't.

[23:25] <Mouq> m: foo my $a, 2; macro foo ($x, $y) { quasi { {{{$a}}} = {{{$y}}} } }

[23:25] <camelia> rakudo-moar 9add92: OUTPUT«Type check failed in unquote evaluation; expected 'AST' but got 'Any'␤  in method evaluate_unquotes at src/gen/m-CORE.setting:17912␤  in method incarnate at src/gen/m-CORE.setting:17903␤  in macro foo at /tmp/nvQJTdCLP8:1␤  in block <unit> at /tmp/…»

[23:25] <Mouq> Ah

[23:25] <masak> Mouq: https://rt.perl.org/Ticket/Display.html?id=123419

[23:26] *** kst` left
[23:26] <Mouq> m: foo my $a, 2; BEGIN macro foo ($x, $y) { quasi { {{{$a}}} = {{{$y}}} } }

[23:26] <camelia> rakudo-moar 9add92: OUTPUT«===SORRY!===␤Unknown QAST node type NQPMu␤»

[23:27] <masak> doesn't help.

[23:27] <Mouq> masak: So no mutually recursive macros then? :P

[23:27] <masak> macros are *called* at BEGIN time.

[23:27] <masak> correct, no mutually recursive macros.

[23:28] <masak> no self-recursive macros either, at least not in the obvious way.

[23:28] <masak> m: macro bob() { bob() }; say "alive"

[23:28] <camelia> rakudo-moar 9add92: OUTPUT«alive␤»

[23:28] <Mouq> They are? My understanding was BEGIN == parse, CHECK == actions. Am I wrong there?

[23:28] <masak> hrm.

[23:28] <masak> Mouq: BEGIN == parse, for sure.

[23:28] <Mouq> m: macro bob() { bob() }; bob

[23:28] <camelia> rakudo-moar 9add92: OUTPUT«Memory allocation failed; could not allocate 154272 bytes␤»

[23:28] <Mouq> Heh

[23:28] <masak> not so sure about CHECK == actions. more like "end of compunit".

[23:29] <masak> oh, right. call the macro. thanks.

[23:41] *** skids joined
[23:47] *** mohij left
