[00:00] *** spider-mario left
[00:01] <timotimo> https://gist.github.com/timo/a26ef6942bfed92e4d8e - JSON, ladies and gentlemen!!

[00:01] *** bjz left
[00:02] <RabidGravy> boom

[00:04] <timotimo> https://i.imgur.com/kEyoHtz.png

[00:05] <timotimo> i've spent about 2 hours on making the text in the entries column monospaced and right-aligned :)

[00:05] <timotimo> i'm not a smart man

[00:05] *** FROGGS joined
[00:06] *** RabidGravy left
[00:14] *** telex left
[00:16] *** telex joined
[00:19] *** yqt left
[00:24] *** FROGGS left
[00:28] *** FROGGS joined
[00:31] *** tokuhirom joined
[00:35] <timotimo> does javascript have something like an infix "defor" operator?

[00:36] *** tokuhirom left
[00:36] <timotimo> seems like i can use || for this

[00:38] *** kjs_ joined
[00:55] *** kjs_ left
[01:00] <ugexe> "replace this Array is copy logic" - the missing uppercase r is more distracting than the strange error message itself

[01:02] *** FROGGS left
[01:11] <dalek> rakudo/nom: d192f1c | lizmat++ | src/core/List.pm:

[01:11] <dalek> rakudo/nom: Make xx quite a bit faster

[01:11] <dalek> rakudo/nom: 

[01:11] <dalek> rakudo/nom: - 42 xx 100      # no change, was already optimized

[01:11] <dalek> rakudo/nom: - rand xx 100    # about 3.5x as fast

[01:11] <dalek> rakudo/nom: - 42 xx *        # about 5x as fast

[01:11] <dalek> rakudo/nom: - rand xx *      # about 1.5x as fast

[01:11] <dalek> rakudo/nom: 

[01:11] <dalek> rakudo/nom: The fixed lenghts xx completely build the list in memory.  For large

[01:11] <dalek> rakudo/nom: values, that may not be such a good idea.  On the other hand, you would

[01:11] <dalek> rakudo/nom: probably use a * in those cases anyway.  Should this turn out to be a

[01:11] <dalek> rakudo/nom: problem, then maybe we can switch to an iterator type approach if N > X.

[01:11] <dalek> rakudo/nom: Of course, in the "push-all" case, there would be only a performance

[01:11] <dalek> rakudo/nom: degredation, so I'm not so sure about such an aproach anyway.  The

[01:11] <dalek> rakudo/nom: * cases are implemented now as proper Iterators.

[01:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d192f1c29a

[01:12] <lizmat> japhb timotimo : spectest clean and implemented in "your" pov  :-)

[01:12] <lizmat> and on that thought, I wish #perl6! good night

[01:16] *** FROGGS joined
[01:19] <dalek> doc: 37b1f83 | (Carl Hayter)++ | doc/Type/Junction.pod:

[01:19] <dalek> doc: missing > on a C<> breaks formatting

[01:19] <dalek> doc: review: https://github.com/perl6/doc/commit/37b1f835e4

[01:22] <timotimo> lizmat: thank you for your consideration! though i'm not 100% comfortable with the necessary compromise in semantics we had to make :(

[01:24] *** zakharyas joined
[01:27] *** aborazmeh joined
[01:27] *** aborazmeh left
[01:27] *** aborazmeh joined
[01:35] *** bpmedley left
[01:36] *** lolisa left
[01:42] *** edehont left
[01:45] *** leont joined
[01:47] <dalek> nqp: 2480f74 | timotimo++ | src/vm/moar/ (2 files):

[01:47] <dalek> nqp: handle the possibility of elided fields in profile data

[01:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2480f74985

[01:47] <dalek> nqp: 875ce69 | timotimo++ | src/vm/moar/profiler/template.html:

[01:47] <dalek> nqp: we don't need no trailing spaces

[01:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/875ce69cc7

[01:48] *** TimToady left
[01:48] <timotimo> ^- updating NQP is fine even without updating moarvm. updating only moarvm will result in non-functioning profiler html apps

[01:49] *** FROGGS left
[01:54] *** xinming left
[01:55] *** xinming joined
[01:57] *** TimToady joined
[01:57] *** colomon joined
[02:01] <psch> fwiw, i'm +1 for AlexDaniel++'s qx changes.  i'd like &out as replacement for &runout and :shout as replacement for :x on q//

[02:01] <AlexDaniel> yaay!

[02:02] <AlexDaniel> psch: but still, why there must be a quoting adverb for that?

[02:03] <psch> bartolin: there's at least one spectest that exhibits the Mu.new spam you described.  it's probably the same that made you bring this up, though...

[02:04] <psch> AlexDaniel: definitely hysterical raisins.  it's quite embedded in the Perfectly Eclectic Rubish Lister that makes our preferred language

[02:04] <AlexDaniel> psch: uhh…

[02:05] <psch> AlexDaniel: i'll readily admit that there's at least a lot of not-wanting-to-alienate-people-that-know-it behind my reasoning, and finding a different reason would take me some time

[02:06] <psch> AlexDaniel: basically, "it's in perl5 and i'd dislike ripping it out just because, if anything just offer a long and cumbersome alternative that seems to do the same"

[02:06] <psch> s/anything/nothing else/

[02:06] <AlexDaniel> psch: I think that it is good. It gives a chance to think about other alternatives, like &run

[02:06] <psch> AlexDaniel: right, that's the exact opposite of an answer to the same question, motivated by a very different point of origin

[02:07] <psch> AlexDaniel: mind, i'm not saying you're wrong, i'm just saying that we might benefit from keeping something-like-qx around.  although i do admit this is probably a negligable (sp?) benefit

[02:08] <AlexDaniel> psch: thanks for your feedback

[02:08] <psch> bartolin: on the upside, the r-j build is broken until someone figures out how to split CORE across multiple files and still load it properly, so i think it's fair to let it sit

[02:10] <psch> AlexDaniel: no problem, as i said, i agree with everything except "remove the option to hang your rope with an appropiately dehuffmanized QX alternative"

[02:10] <psch> i really like qshout because it looks somewhat scary :P

[02:11] <psch> as in, shouting in general is somewhat unsafe, because it alerts lots of people you might not want alerted etc.  it seems fitting

[02:11] <psch> and, well, removing it seems contra TIMTOWTDI

[02:12] <AlexDaniel> psch: actually, this whole story started from me asking about an equivalent to ShellQuote in perl6. Most likely other people moving from perl5 world will attempt to do the same, which is not what we want…

[02:13] <AlexDaniel> the deprecation message says "use 'runout' or 'shellout' instead", which is perfect

[02:13] <AlexDaniel> if runout is changed to “out”, then it is even better

[02:14] <AlexDaniel> psch: so if someone is used to hang his rope here, I don't think that it is a bad idea to say “hey, there is a different place to do that. By the way, here is a safe alternative”

[02:15] <psch> hm, yeah, i suppose i'm too attached to the idea of having an extension to quoting syntax that does something forky

[02:15] <AlexDaniel> psch: and you are not the only one :)

[02:15] <psch> i mean, linguistically it sorta makes sense.  we're changing language from the one we're in to the one we come from

[02:16] <psch> (that's of course operating from "i like terminals" perspective)

[02:16] <psch> and Q is about changing languages

[02:16] <psch> so there it fits

[02:17] <AlexDaniel> but the output does not equal to the input, does it make sense?

[02:17] <psch> that *might* depend on whether the chinese room is sapient or not...

[02:18] <masak> did someone say Q?

[02:18] <AlexDaniel> I mean, you don't get a shell-adapted version of your string, what you get is completely different

[02:18] <AlexDaniel> so to me it sounds like a function, not a quoting construct…

[02:18] <psch> masak: only if you have a remote-controlled car to spare :)

[02:18] <AlexDaniel> but perhaps there are different ways to look at it

[02:19] <psch> AlexDaniel: &map doesn't care if the mapper you write exhibits what you mean either

[02:19] *** mike` joined
[02:19] <psch> (although Cool breaks the obvious example i had in mind...)

[02:20] <psch> maybe that's reason enough to demand a sh-ish grammar for qx//, though

[02:21] * Ben_Goldberg wonders whether a module which monkey patches Str and adds a .shellout or .qx, etc, would be sensible.

[02:21] <psch> as in, the mapper supplied to &map still works according to the current language, but arguments to qx don't work according to what they are understood by

[02:21] <psch> i think that convinces me, actually

[02:22] <psch> if we want a shell-execution adverb to Q it should interpret the thus quoted string as the shell would

[02:22] <AlexDaniel> I agree

[02:22] <psch> what exactly that means is probably up for debate, though

[02:23] <Ben_Goldberg> And the other thing up for debate is, "which shell", because not all of us are on *nix

[02:24] <AlexDaniel> Ben_Goldberg: I'd say “perl6” shell! I mean, it would be great if it could autoquote variables…

[02:24] <psch> masak: for your last blog post, i was thinking "grok time" for the "check but not CHECK time" you were writing about

[02:24] <psch> masak: that's pretty much a gut reaction though, and might have occured to you already...

[02:25] <AlexDaniel> Ben_Goldberg: it sounds weird, but it would be super cool if the shell quoting was inverted somehow

[02:25] <AlexDaniel> that is, everything is quoted, but you have to “unquote” it explicitly if you want it to break

[02:25] <AlexDaniel> but that's not what shells do, so I don't know…

[02:25] <timotimo> i missed the 0hr game jam :|

[02:26] <Ben_Goldberg> Sounds like lisp's "`" operator, with "," to unquote things.

[02:27] *** uberbaud joined
[02:30] <masak> psch: thanks for the suggestion. :)

[02:30] <masak> psch: "grok" is not half-bad. I won't commit on it just yet, though. need to use these abstractions a bit more first.

[02:33] *** tokuhirom joined
[02:33] <Ben_Goldberg> Here's another interesting way of abstracting processes: https://metacpan.org/pod/IO::Pipeline

[02:35] *** tokuhiro_ joined
[02:37] *** tokuhirom left
[02:38] *** lizmat_ joined
[02:39] *** tokuhiro_ left
[02:40] *** zakharyas left
[02:41] <psch> masak: yeah, it's hanging a bit between the "understand how to use fittingly" and "internalize to the point of automation" meanings 'grok' has, but as i said, it's mostly a gut reaction - the other one was "get", but that's too overloaded, albeit a bit more common

[02:41] <AlexDaniel> Ben_Goldberg: interesting. I'm not sure if there is any need for that though

[02:42] *** lizmat left
[02:42] <AlexDaniel> Ben_Goldberg: For example, run(…, :out).out is very useful in that sense

[02:42] <psch> and it probably should be "'getting it' time" then anyway, which is probably worse...

[02:43] <masak> psch: I keep reaching for a meaning a bit like "contextize", i.e. "endow with a surrounding context". because that captures it quite well.

[02:46] *** ilbot3 left
[02:47] <psch> masak: a bit of thesaurus clicking brought me "merge time", which seems quite good

[02:48] *** ilbot3 joined
[02:48] <psch> masak: although there might be a bit of lack of clarity on my end, i'm not sure whether it's the time where we know how to handle the quasi or where we know how to insert it

[02:48] *** O47m341 joined
[02:48] <psch> ...at least i think there's a difference there

[02:49] * psch might need to re-read the blog post in the morrow

[02:49] *** SuzieQueue left
[02:49] *** BenGoldberg joined
[02:50] <psch> i'll think about that, i suppose

[02:50] <psch> and about the jvm stuff too, probably

[02:50] <psch> i have a hunch that 007 could help me explore concepts with that, but that might be horribly misguided :P

[02:50] <psch> anyway, g'night o/

[02:51] *** Ben_Goldberg left
[02:52] <AlexDaniel> BenGoldberg: like this: run('some', 'command', :out).out.lines ==> grep { … } ==> map { … } ==> grep { … };

[02:53] <AlexDaniel> BenGoldberg: as far as I know it wont build an efficient pipeline right now, but perhaps it would in the future?

[02:53] <AlexDaniel> .lines is also not lazy

[02:54] <AlexDaniel> BenGoldberg: but syntactically it is the same thing, isn't it?

[03:04] <BenGoldberg> Pretty close.

[03:06] <BenGoldberg> Anyway, goodnight.  Sleep is calling me.

[03:06] *** BenGoldberg left
[03:09] *** AlexDaniel left
[03:20] <dalek> specs/newio: f5e1f86 | labster++ | S32-setting-library/Temporal.pod:

[03:20] <dalek> specs/newio: Mention RFC 3339 in DateTime (which is what we currently accept), proleptic Gregorian Calendar

[03:20] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/f5e1f862c3

[03:20] <labster> wait, I was on newio?  *sigh*

[03:21] <dalek> specs: 34443f6 | labster++ | S32-setting-library/Temporal.pod:

[03:21] <dalek> specs: Mention RFC 3339 in DateTime (which is what we currently accept), proleptic Gregorian Calendar

[03:21] <dalek> specs: review: https://github.com/perl6/specs/commit/34443f6b19

[03:21] *** aristotle joined
[03:21] <aristotle> https://apple.stackexchange.com/questions/209635/what-functionality-do-marks-offer-in-the-el-capitan-terminal

[03:21] <labster> I really need to change my prompt to mention to the box name

[03:22] <aristotle> might be of interest to anyone here using a Mac

[03:22] *** aristotle left
[03:24] <labster> the aristotelian method: infodump and sign off channel :)

[03:38] *** leont left
[03:50] <dalek> rakudo-star-daily: 581381d | coke++ | log/ (8 files):

[03:50] <dalek> rakudo-star-daily: today (automated commit)

[03:50] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/581381d8f0

[03:50] <dalek> perl6-roast-data: d1cc57b | coke++ | / (9 files):

[03:50] <dalek> perl6-roast-data: today (automated commit)

[03:50] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d1cc57bd1b

[03:57] *** FROGGS joined
[04:00] <masak> psch: we know how to handle the quasi by the time we evaluate it. identical in spirit to when you have a string "OH HAI, $person" -- you know what the string will be exactly when you reach that expression and $person is in scope and has a certain value.

[04:02] <masak> psch: this happens before the quasi gets spliced into mainline code somewhere. the weird-and-wonderful bit is that the mainline code is a *different* context than where the quasi was evaluated, but the code from the quasi "remembers" where it was evaluated, kind of in analogy to closure semantics

[04:03] <masak> concretely, if there's a $foo variable in the Qtree from the quasi, then variable lookup will go looking in the quasi's context, not in the mainline's.

[04:06] <masak> I'm digging into exactly these details right now in 007. it's tricky to get right -- or, rather, I suspect it's one of those "easy once you know how" skills.

[04:14] *** khw left
[04:14] *** raiph left
[04:29] *** bjz_ left
[04:34] *** tokuhirom joined
[04:39] *** tokuhirom left
[04:41] *** kid51 left
[04:44] *** baest left
[04:44] *** baest joined
[04:45] *** z8 left
[04:51] *** tokuhiro_ joined
[04:56] *** tokuhiro_ left
[04:56] *** labster left
[04:58] *** labster joined
[04:59] *** skids joined
[05:00] *** mike` left
[05:05] *** z8 joined
[05:06] *** acrussell joined
[05:09] *** z448 joined
[05:11] *** z8 left
[05:20] *** kmel joined
[05:29] *** bjz joined
[05:34] *** kmel left
[05:40] *** kaare_ joined
[05:43] *** dayangkun joined
[05:43] *** bjz left
[05:51] *** dayangkun left
[05:51] *** ggoebel left
[05:51] *** Thigh joined
[05:53] *** bjz joined
[05:56] *** Thigh left
[05:59] *** bjz left
[06:01] *** bjz joined
[06:11] *** Zoffix joined
[06:21] *** z448 left
[06:24] *** rurban joined
[06:31] *** uberbaud left
[06:34] *** skids left
[06:36] *** tokuhirom joined
[06:36] *** _dolmen_ joined
[06:40] *** tokuhirom left
[07:02] *** aborazmeh left
[07:05] *** abaugher left
[07:06] *** abaugher joined
[07:22] *** ribasushi left
[07:30] *** rindolf joined
[07:31] *** ribasushi joined
[07:36] *** azawawi joined
[07:37] <azawawi> m-star: require MIME::Base64; say MIME::Base64.encode('foo');

[07:37] *** tokuhirom joined
[07:37] <azawawi> star-m: require MIME::Base64; say MIME::Base64.encode('foo');

[07:37] <camelia> star-m 2015.09: OUTPUT«Could not find symbol '&Base64'␤  in block <unit> at /tmp/1hgCtm7lUH:1␤␤Actually thrown at:␤  in block <unit> at /tmp/1hgCtm7lUH:1␤␤»

[07:37] <azawawi> m: require MIME::Base64; say MIME::Base64.encode('foo');

[07:37] <camelia> rakudo-moar cd7766: OUTPUT«Could not find MIME::Base64 in any of:␤  file#/home/camelia/.perl6/2015.10-14-gcd77669/lib␤  inst#/home/camelia/.perl6/2015.10-14-gcd77669␤  file#/home/camelia/rakudo-inst-1/share/perl6/lib␤  file#/home/camelia/rakudo-inst-1/share/perl6/vendor/lib…»

[07:38] <azawawi> hi #perl6

[07:41] <rindolf> azawawi: hi! What's new?

[07:41] <rindolf> azawawi: how's the weather there?

[07:41] *** sunnavy left
[07:42] *** tokuhirom left
[07:42] <azawawi> rindolf: dusty lol

[07:42] *** sunnavy joined
[07:42] <rindolf> azawawi: ah. :-(.

[07:42] <rindolf> azawawi: here it's raining.

[07:42] <azawawi> rindolf: cool

[07:42] <azawawi> rindolf: hopefully it will rain here also :)

[07:43] <rindolf> azawawi: yes.

[07:43] <azawawi> rindolf: what are you working on these days?

[07:44] <rindolf> azawawi: I'm working on Mageia Linux, Project Euler, various CPAN distributions, Freecell Solver - stuff like that.

[07:45] <azawawi> rindolf: im actually reading more code for implementing more selenium drivers in Perl 6. 

[07:45] <rindolf> azawawi: ah.

[07:45] <azawawi> rindolf: so far the python version seemed to be the most well written along with the Perl 5 version :)

[07:46] <azawawi> rindolf: the ruby bindings to selenium code is like OOP for the sake of OOP

[07:46] <azawawi> rindolf: https://github.com/azawawi/perl6-selenium-webdriver/

[07:47] <azawawi> rindolf: im now working on the firefox driver after finishing the json wire webdriver protocol with phantomjs/ghostdriver

[07:47] <rindolf> azawawi: Rakudo is still very slow from my experience with it.

[07:47] <rindolf> It's frustrating.

[07:47] <azawawi> rindolf: i know :)

[07:47] <azawawi> rindolf: i was working on some code that day and then wrote back a Perl script to do the same... and i was like... Perl 6 is so slow :)

[07:48] <azawawi> rindolf: startup time is cutting back on my developer productivitiy as far as i noticed. but it is normal at this stage.

[07:48] <rindolf> azawawi: bye! I'm going to rest.

[07:48] <masak> lizmat_: haha -- I know I'm brain damaged by CT when I read your http://irclog.perlgeek.de/perl6/2015-10-24#i_11429273 and my mind goes "category of weird errors! what the heck would you take the morphisms to be!?" :P

[07:48] <azawawi> rindolf: enjoy :)

[07:49] <azawawi> rindolf: bye

[07:49] * masak .oO( from the category of things I don't expect many others to find amusing )

[07:49] <azawawi> masak: hi there

[07:49] <masak> aloahoy

[07:51] <azawawi> masak: so what's recommended self.xyz or $.xyz?

[07:51] *** zacts left
[07:52] <masak> azawawi: I think consensus is "don't do $.xyz unless there's a good reason". but people might draw the line for that differently.

[07:52] <masak> some say "don't do it unless $!xyz actually is an attribute"

[07:53] <masak> others say "it's OK as long as $.xyz acts like an accessor in practice"

[07:53] <azawawi> masak: from my experience (so far) $.xyz has troubles when using in BUILD(...)

[07:53] <ShimmerFairy> I've taken a liking to $.xyz as a way of saying "I expect subclasses to give me this attribute-ish as something different than I would have", particularly in string interpolation stuff :)

[07:53] <masak> azawawi: well, in BUILD I wouldn't use anything with a '.', because the object is not fully constructed.

[07:54] <masak> azawawi: calling (non-sub)methods on a not-fully-constructed object is suspect, design-wise.

[07:54] <masak> ShimmerFairy: yes, string interpolation is a temptation to mis-/over-use the $.xyz syntax :)

[07:55] *** petercommand left
[07:55] <azawawi> masak: i think we need to draw a diagram for newbies to explain the whole object construction thing in Perl 6

[07:55] <azawawi> masak: the sequence, what's allowed, what's not... that is

[07:55] <masak> agreed.

[07:55] <ShimmerFairy> masak: well, it came in handy in places like   class MyErrorBase { method gist() { "Error: $.message " } method message() { "boring default" } }    :)

[07:56] <masak> though moritz++ already has at least one nice post about that

[07:56] <azawawi> coming from a Java background, i was like why did we complicate that :)

[07:56] <masak> azawawi: the complications are in Java as well, believe me.

[07:56] <azawawi> masak: well I use everyday :)

[07:56] <masak> azawawi: I had a bug in a piece of code with exactly what we're talking about, not one month ago.

[07:56] <azawawi> masak: s/use/use it/

[07:56] <ShimmerFairy> masak: as a way of saying "There a thing called 'message' that's more-or-less an attribute, and I want whatever the class wants me to get as a 'message'"

[07:57] <masak> azawawi: Java's .new is like a combined Perl 6's .new/.BUILD

[07:57] *** sunnavy left
[07:57] <masak> ShimmerFairy: aye. in that case, I would say that .message is "sufficiently accessor-like"

[07:58] <masak> ShimmerFairy: what I mean is that some people might object to, say, calling $.activate on a method .activate that had side effects

[07:59] <ShimmerFairy> masak: yeah, that seems a bit weird to me :) . As far as I'm concerned, if you think of the method call as really an attribute-like thing that you want subclasses to override, that's what you use.

[07:59] *** sunnavy joined
[08:00] *** z8 joined
[08:04] <azawawi> :)

[08:06] *** _dolmen_ left
[08:08] *** firstdayonthejob joined
[08:09] *** rurban left
[08:17] <masak> ShimmerFairy: I guess I think of it from the (Eiffel) perspective of queries vs commands.

[08:19] *** domidumont joined
[08:24] *** ecocode joined
[08:31] *** petercommand joined
[08:37] *** z448 joined
[08:38] *** tokuhirom joined
[08:39] *** vendethiel joined
[08:40] *** z8 left
[08:41] *** [particle] joined
[08:42] *** tokuhirom left
[08:42] *** [particle]1 left
[08:42] *** darutoko joined
[08:44] <dalek> rakudo/curli: 5e45f99 | (Stefan Seifert)++ | src/core/CompUnitRepo/Locally.pm:

[08:44] <dalek> rakudo/curli: Make CompUnit::Repository::need actually load the found module

[08:44] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/5e45f99153

[09:00] *** z448 left
[09:27] <vendethiel> m: class A { has $!a; method BUILD(:$!a!) {}}; A.new

[09:27] <camelia> rakudo-moar cd7766: OUTPUT«Required named parameter 'a' not passed␤  in method BUILD at /tmp/IFt3iKzHsz:1␤  in block <unit> at /tmp/IFt3iKzHsz:1␤␤»

[09:27] *** bjz left
[09:27] <vendethiel> "bang-fence"

[09:30] *** edehont joined
[09:34] *** bjz joined
[09:34] *** vendethiel left
[09:37] <[Tux]> test             50000    37.623    37.508

[09:37] <[Tux]> test-t           50000    38.952    38.837

[09:41] *** kjs_ joined
[09:45] *** kjs_ left
[09:46] *** RabidGravy joined
[09:58] *** tokuhiro_ joined
[10:07] *** pmurias joined
[10:15] <RabidGravy> whassup?

[10:19] *** ifim left
[10:20] *** azawawi left
[10:23] <dalek> rakudo/curli: d751433 | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[10:23] <dalek> rakudo/curli: Replace use of @*INC by $*REPO for loading modules.

[10:23] <dalek> rakudo/curli: 

[10:23] <dalek> rakudo/curli: CompUnitRepo.load_module now creates a CompUnit::DependencySpecification and

[10:23] <dalek> rakudo/curli: $*REPO.need for loading modules.

[10:23] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/d751433356

[10:26] *** virtualsue joined
[10:27] *** tokuhirom joined
[10:36] *** tokuhirom left
[10:39] *** tokuhiro_ left
[10:44] <skaji> { temp %*ENV<FOO> = "1" }; { temp %*ENV<BAR> = "1"; run "ls" }

[10:44] <skaji> the above code exits with "Cannot unbox a type object"

[10:44] *** void1 joined
[10:45] <skaji> is this expected?

[10:45] <moritz> no; looks like a bug

[10:46] <skaji> OK, I will raise a RT ticket. Thanks.

[10:47] <skaji> (note: { temp %*ENV; %*ENV<FOO> = "1" }; { temp %*ENV; %*ENV<BAR> = "1"; run "ls" } is works)

[10:49] *** tokuhiro_ joined
[10:49] *** tokuhiro_ left
[10:50] *** tokuhiro_ joined
[10:57] *** azawawi joined
[10:57] <azawawi> hi

[10:57] <azawawi> is there any p6 module to deal with unzipping an archive?

[10:57] *** TEttinger left
[10:58] <moritz> azawawi: I'm not aware of one

[10:58] <azawawi> moritz: thx

[10:59] <moritz> though with 400+ modules in the running, it's easy to lose overview :-)

[10:59] *** Actualeyes joined
[11:01] *** cognominal left
[11:04] <itz_stmuk> its the most wanted

[11:04] <itz_stmuk> ^ in the most wanted

[11:04] *** spider-mario joined
[11:04] *** Actualeyes left
[11:05] <RabidGravy> nice little hack for someone on a Sunday afternoon

[11:08] <RabidGravy> azawawi, it is possible that Compress::Zlib might be persuaded to do it depending on the version of zip used

[11:10] *** virtualsue left
[11:10] * azawawi checks

[11:13] *** Alina-malina left
[11:14] <azawawi> RabidGravy: Compress::Zlib is too low level (i.e. stream)

[11:15] <RabidGravy> then it seems you found something to do this afternoon ;-)

[11:15] <azawawi> finally it is raining :)

[11:15] <azawawi> rindolf: yes!

[11:16] <rindolf> azawawi: awesome!

[11:16] <azawawi> RabidGravy: yup but i need to focus on firefox/webdriver thing first :)

[11:18] <azawawi> RabidGravy: thx for the info though. I was not aware of the Compress:: namespace in modules.perl6.org

[11:27] *** bpmedley joined
[11:29] *** Actualeyes joined
[11:30] <lizmat_> .botsnack

[11:30] <yoleaux> :D

[11:30] <synbot6> om nom nom

[11:30] <tadzik> :D

[11:31] <lizmat_> need to appease the bots!

[11:31] *** lizmat_ is now known as lizmat

[11:31] <lizmat> .botsnack

[11:31] <yoleaux> :D

[11:31] <synbot6> om nom nom

[11:32] *** cognominal joined
[11:33] *** tokuhirom joined
[11:36] *** AlexDaniel joined
[11:37] *** Begi1114 joined
[11:37] *** tokuhirom left
[11:41] <azawawi> m: %*ENV<FOOBAR> = 1; my $p = Proc::Async.new("foobar"); $p.start;

[11:41] <camelia> rakudo-moar cd7766: OUTPUT«Proc::Async is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:1␤  in method new at src/RESTRICTED.setting:32␤  in block <unit> at /tmp/V2PGgqJTb9:1␤␤»

[11:42] <azawawi> i found a possible mini bug in Proc::Async

[11:42] <azawawi> "This type cannot unbox to a native string" when you use %*ENV<FOOBAR> = 1

[11:43] <azawawi> it took me a while to figure out what happened lol

[11:44] <skaji> %*ENV<FOOBAR> = 1.Str;

[11:46] <AlexDaniel> actually, the problem is not with Proc::Async

[11:46] <AlexDaniel> it seems like everything is affected

[11:46] <AlexDaniel> %*ENV<FOOBAR> = 1; run("echo");

[11:46] <AlexDaniel> %*ENV<FOOBAR> = 1; qx/echo/;

[11:46] <AlexDaniel> same error everywhere

[11:47] <azawawi> i see

[11:47] <AlexDaniel> azawawi: will you report that or should I do it?

[11:48] <azawawi> please report it. im busy writing code for automating firefox :)

[11:48] <azawawi> AlexDaniel: thx

[11:48] <AlexDaniel> ok

[11:49] <RabidGravy> azawawi, AlexDaniel I think skaji just reported this about an hour ago

[11:50] <RabidGravy> they may or may not have RT'd

[11:50] *** pecastro joined
[11:50] <AlexDaniel> RabidGravy: indeed!

[11:50] <RabidGravy> yeah https://rt.perl.org/Ticket/Display.html?id=126447

[11:52] *** pecastro_ left
[11:53] <lizmat> FWIW, looking at that now

[11:54] <lizmat> note that if you say = "1", it works ok

[11:54] <RabidGravy> lizmat++ 

[11:55] <AlexDaniel> lizmat: but the bug report does not make any sense to me, actually

[11:55] <AlexDaniel> lizmat: there it is written as "1"

[11:55] *** virtualsue joined
[11:55] <azawawi> so after looking at selenium language bindings (python,rb,...) i found really something

[11:56] <bartolin> lizmat: looks like there is also RT #125953 about the same problem

[11:56] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125953

[11:56] <azawawi> bad logic/code does propagate to language ports in the end :)

[11:56] <lizmat> well, I took azawawi's line, and that failed for me, and didn't with "1"

[11:56] *** lucasb_ joined
[11:56] <lizmat> so #126447 may be a different issue altogether

[11:56] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126447

[11:57] <lizmat> yeah, it's really #125953 I'm looking at

[11:57] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125953

[11:57] <bartolin> lizmat++

[11:58] <pmurias> azawawi: you mean bugs get ported over to language ports?

[11:58] *** ggoebel joined
[11:59] <azawawi> pmurias: yup bad logic that is

[11:59] <azawawi> pmurias: and over-designed feature sets

[11:59] *** rupert160 joined
[12:00] *** rupert160 left
[12:01] <RabidGravy> azawawi, there are shit developers out there?  who knew? ;-)

[12:02] <azawawi> pmurias: to explain, to automate firefox you need to create a temporary profile folder for it, unzip the extension which acts as web driver (http/json) and then communicate with it directly.

[12:03] <azawawi> pmurias: in selenium code it is like 3 different classes which you jump back and forth to understand code lol

[12:04] *** AlexDani` joined
[12:04] *** Actualeyes left
[12:05] *** AlexDaniel left
[12:06] <RabidGravy> on a complete un-related is iit a design decision to not allow type constraints on "our" variables or basically a NYI or something else?

[12:11] *** virtualsue left
[12:14] *** bjz_ joined
[12:15] *** bjz left
[12:15] *** kid51 joined
[12:16] *** Actualeyes joined
[12:19] <lizmat> RabidGravy: I think it was an implementation decision

[12:20] <AlexDani`> weird. I've never thought about it

[12:22] *** diana_olhovik_ joined
[12:24] <dalek> roast: a5831ca | usev6++ | S32-exceptions/misc.t:

[12:24] <dalek> roast: Add test for RT #125780

[12:24] <dalek> roast: review: https://github.com/perl6/roast/commit/a5831ca942

[12:24] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125780

[12:31] *** AlexDani` is now known as AlexDaniel

[12:32] *** pmurias left
[12:35] <AlexDaniel> m: our Str $foo

[12:35] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/s9dl8D4LAm␤Cannot put a type constraint on an 'our'-scoped variable␤at /tmp/s9dl8D4LAm:1␤------> 3our Str $foo7⏏5<EOL>␤    expecting any of:␤        constraint␤»

[12:36] <AlexDaniel> expecting any of: constraint?

[12:36] *** Axord joined
[12:39] <lizmat> yeah, LTA error message

[12:43] *** leont joined
[12:45] <lucasb_> m: say so False S& False

[12:45] <camelia> rakudo-moar cd7766: OUTPUT«True␤»

[12:45] <lucasb_> ^^ This little one still here. Maybe few people use the 'S' metaop

[12:46] <AlexDaniel> m: 'x' <= 25

[12:46] <camelia> rakudo-moar cd7766: OUTPUT«WARNINGS:␤Useless use of "<=" in expression "'x' <= 25" in sink context (line 1)␤Earlier failures:␤ Cannot convert string to number: base-10 number must begin with valid digits or '.' in '7⏏5x' (indicated by 7⏏)␤  in block <unit> at /tmp/W…»

[12:48] <lizmat> RabidGravy AlexDaniel skaji spectesting fix

[12:48] <AlexDaniel> hm, it cuts it, but the “Final error:” is “Cannot call Real(Failure: ); none of these signatures match: (Mu:U \v: *%_)”

[12:49] *** ^elyse^ joined
[12:52] <leont> Does anyone have an idea of how expensive the gradual type is?

[12:53] *** ^elyse^ left
[12:53] <lizmat> leont: if you don't specify a type, all type checking is done against Any

[12:54] <lizmat> so: type checking is done *always*

[12:54] <lizmat> already

[12:54] <leont> Ah, ok

[12:54] <lizmat> it's just checking against Any if you don't specify anything more strict

[12:55] <AlexDaniel> well, this sounded like there's no difference if you specify a type or not

[12:55] <lizmat> indeed, there is no execution speed difference

[12:55] *** Alina-malina joined
[12:56] <AlexDaniel> but in reality it should be faster if you do, since then there's no need to mess with type checks and stuff

[12:56] *** El_Che_ is now known as El_Che

[12:56] <lizmat> well, if you're using simple types...  I mean, if you specify a type that has a where in it, it *will* be slower because it needs to execute that code

[12:56] <lizmat> typechecks are done on C-code, *very* low level

[12:56] <lizmat> *in

[12:57] <AlexDaniel> in fact, even if you don't specify the type, it seems like it will do that automatically… at least that's what I understood from jnthn talks

[12:57] <AlexDaniel> with a drawback that it might have to deoptimize it in the future

[12:57] <lizmat> yes, it will be of type Any

[12:58] <AlexDaniel> lizmat: well, on what level?

[12:58] <lizmat> AlexDaniel: deopt why ?

[12:58] <leont> Then I'll keep my types, and may add a few more

[12:59] <leont> (and try to not add too many subsets

[12:59] <AlexDaniel> lizmat: well, if your code always gets a Str in runtime, then it makes sense to optimize it for Str. Just to get the instruction count lower

[13:00] <AlexDaniel> lizmat: if then all of sudden it gets something else, then you have to rewind that…

[13:00] <AlexDaniel> I could be wrong, but that's how I understood it

[13:00] <lizmat> ah, yes

[13:02] <leont> Do return types on subs/methods help in avoiding those checks?

[13:03] <AlexDaniel> leont: I'd say yes, but it's hard to measure how much you actually win in terms of wallclock time

[13:03] <AlexDaniel> leont: so if I were you I would not care about this. What I would care about is the self-documenting code

[13:04] <AlexDaniel> leont: if the types are specified everywhere, arguably it is easier to read

[13:04] <AlexDaniel> though I don't say that you always should do that

[13:06] <lucasb_> r: say ('abc' x 2 ~ '1234').substr(4)

[13:06] <camelia> rakudo-jvm cd7766: ( no output )

[13:06] <camelia> ..rakudo-moar cd7766: OUTPUT«bcabc1␤»

[13:06] <lucasb_> j: say ('abc' x 2 ~ '1234').substr(4)

[13:06] <camelia> rakudo-jvm cd7766: OUTPUT«bc1234␤»

[13:06] <leont> Given how much C++ I've been doing lately, adding the types feels fairly natural to me ;-)

[13:07] <lucasb_> don't know why rakudo-jvm had no output in the first eval

[13:07] <AlexDaniel> well, what if we try it again?

[13:07] <AlexDaniel> r: say ('abc' x 2 ~ '1234').substr(4)

[13:07] <camelia> rakudo-moar cd7766: OUTPUT«bcabc1␤»

[13:07] <camelia> ..rakudo-jvm cd7766: OUTPUT«bc1234␤»

[13:07] <AlexDaniel> r: say ('abc' x 2 ~ '1234').substr(4)

[13:07] <camelia> rakudo-moar cd7766: OUTPUT«bcabc1␤»

[13:07] <camelia> ..rakudo-jvm cd7766: OUTPUT«bc1234␤»

[13:08] <AlexDaniel> r: say ('abc' x 2 ~ '1234').substr(4)

[13:08] <camelia> rakudo-jvm cd7766: OUTPUT«bc1234␤»

[13:08] <camelia> ..rakudo-moar cd7766: OUTPUT«bcabc1␤»

[13:08] <AlexDaniel> go figure

[13:08] <lizmat> oh, wow

[13:09] <lizmat> looks to me jvmis correct

[13:09] <lucasb_> indeed. this is an old one

[13:10] <leont> How heavy is compiling rakudo-jvm compared to rakudo-moar?

[13:10] <AlexDaniel> leont: by heavy you mean?

[13:10] <lizmat> takes about 4x as long on my machine

[13:10] <leont> Memory-wise mainly

[13:10] <ShimmerFairy> lizmat: how so? I have a hard time seeing why moar isn't the correct one

[13:10] <leont> But CPU is also useful to know

[13:11] <moritz> last I tried, I needed about 3GB RAM

[13:11] <lucasb_> ShimmerFairy: It looks like a off-by-one error, but I think moar is wrong, don't you?

[13:11] <ShimmerFairy> lucasb_: no?

[13:11] <AlexDaniel> ShimmerFairy: please explain…

[13:11] <ShimmerFairy> r: say 'abcabc1234'.substr(4)

[13:11] <camelia> rakudo-{moar,jvm} cd7766: OUTPUT«bc1234␤»

[13:12] <ShimmerFairy> must've miscounted in my head the first time :)

[13:12] <AlexDaniel> ShimmerFairy: by the way, thanks for your comment

[13:13] <lizmat> r: say (('abc' x 2) ~ '1234').substr(4)

[13:13] <camelia> rakudo-moar cd7766: OUTPUT«bcabc1␤»

[13:13] <camelia> ..rakudo-jvm cd7766: OUTPUT«bc1234␤»

[13:13] *** parsonsNose joined
[13:14] <awwaiid> AlexDaniel: well... specifying types everywhere, IMO, is a double edged sword. Working with haskell code I see few things I don't care for. One is that by not allowing type inference you end up having to edit lots of code if you change a type. Another is that instead of having like $name they have Name $n, and then in the body use one-letter variable names with the excuse that you can look up to see the type of the variable.

[13:14] <parsonsNose> why is `perl6 -e 'my ($x,$y,$i) = (0,1,1); while ($i < 1000000) {$y += $x ; $x = $y - $x ; $i += 1 } ; say $y;'` using up 6GB of RAM before plateauing?

[13:15] <ShimmerFairy> AlexDaniel: you're welcome. I hope I was better able to describe how I view :x in a long comment as opposed to short IRC statements :)

[13:15] <moritz> parsonsNose: looks like a bug to me

[13:15] <moritz> parsonsNose: some weird conditions not triggering a GC run

[13:15] <parsonsNose> *sad face* this is on rakudobrew moar

[13:16] <AlexDaniel> ShimmerFairy: well, I still completely disagree, but it's good to have different opinions :)

[13:16] <moritz> parsonsNose: care to submit that via email to [email@hidden.address]
[13:16] <parsonsNose> Sure thing

[13:17] <AlexDaniel> wow, it is so hungry for ram

[13:21] *** loren joined
[13:22] <AlexDaniel> my: my $x = 0; my $y = 1; for 1..1000000 { $y += $x; $x = $y - $x; }; say $y;

[13:22] <AlexDaniel> whoops, I meant m:

[13:22] <AlexDaniel> but it does not matter, what I wanted to say is that it eats the whole memory too

[13:23] *** domidumont left
[13:24] *** ggoebel left
[13:25] <AlexDaniel> parsonsNose: how many digits are there in the final result?

[13:25] <parsonsNose> something like 20k... I'll check

[13:27] <loren> m: my $x = 1; if ($x = 0) { say "invoke me"; };  $x = 2; if ($x = 0) & ($x = 1) { say $x; }

[13:27] <camelia> rakudo-moar cd7766: OUTPUT«1␤»

[13:28] <loren> why the second if condtion '($x = 1)' be calculated

[13:29] <azawawi> https://github.com/azawawi/perl6-selenium-webdriver/blob/master/poc/test_firefox.p6  # POC: Automating firefox process through Perl 6 selenium webdriver :)

[13:29] <parsonsNose> 208k

[13:29] <moritz> loren: are you realizing you're not using comparison (==) but assignment (=) ?

[13:29] <parsonsNose> (took a while)

[13:29] <loren> that's not point

[13:29] <lucasb_> well, 1 is true

[13:29] <AlexDaniel> I thought that this would help: $y += $x; $x -= $y; $x *= -1; but no

[13:29] <lucasb_> 0 is not

[13:30] <moritz> loren: the problem is that you're reading and writing from a variable in the same statement with no sequence point

[13:30] <moritz> loren: both assignments return $x (the, variable, not its value)

[13:30] <loren> m: my $x = 1; if ($x = 0) { say "invoke me"; };  $x = 2; if ( 0 ) & ($x = 1) { say $x; }

[13:30] <camelia> rakudo-moar cd7766: ( no output )

[13:30] *** ggoebel joined
[13:30] *** raiph joined
[13:30] <moritz> loren: so both expressions return $x (which evaluates to 1), and & is not short-circuiting

[13:31] <ShimmerFairy> loren: did you mean && perchance?

[13:31] <ShimmerFairy> (a single & makes a Junction)

[13:31] <moritz> loren: your statement is equivalent to  do { $x = 1; $x & $x }

[13:31] <parsonsNose> Bug report sent, anyway. Feel like the original code should've worked. For comparison, scala uses about 300MB with equivalent code

[13:31] <loren> OK, moritz i know it .

[13:32] <loren> I will take some look '&&'

[13:34] <awwaiid> azawawi: that's pretty awesome!

[13:34] <loren> I just sae '&' operator , ignored '&&'

[13:35] *** tokuhirom joined
[13:36] *** mayuresh joined
[13:39] *** mayuresh left
[13:39] *** tokuhirom left
[13:43] *** ngie joined
[13:48] *** FROGGS_ joined
[13:52] *** FROGGS left
[13:54] <masak> loren: heh. most of the time you'll want '&&', I think.

[13:55] *** ^elyse^ joined
[13:55] *** void1 left
[13:56] <loren> Em, yes, '&&' is my wanted. thks, masak  

[13:57] <loren> The '&' will hang up my program..

[13:57] *** BenGoldberg joined
[13:57] <masak> almost never the desired behavior :P

[13:58] *** diana_olhovik_ left
[13:58] <moritz> did I ever tell you folks that three weeks ago, I was very happy about a segfault?

[13:59] <moritz> story time :-)

[13:59] <moritz> so, at $work, we have a huge OTRS (ticket system) installation

[13:59] * masak listens

[13:59] * llfourn puts headphones on

[14:00] <moritz> and to be able to reproduce some bug in our testing environment, we copied the prod database to the test env

[14:00] <moritz> and since permissions aren't as restrictive in test (more people have root), we have a job that deletes sensitive data (HR, security stuff, invoices, ...)

[14:01] <moritz> and $cow-orker accidentally enabled that job in prod instead of test

[14:01] * llfourn hopes the story doesn't end with "and then we realised we have no backup..."

[14:01] <moritz> and luckily, that job segfaulted

[14:01] <moritz> ... after deleting about 10k tickets, instead of deleting 30k tickets

[14:01] *** Actualeyes left
[14:01] <lizmat> *phew*

[14:02] <masak> urgh

[14:02] <moritz> so, hence I was glad about a segfault :-)

[14:02] <masak> kind of two wrongs making a right, though

[14:02] <moritz> but we noticed that only after ~5 hours

[14:02] <moritz> so, restoring the last backup wasn't really an option

[14:02] <azawawi> awwaiid: thx

[14:03] <bartolin> . o O ( so the story ends with "and now our backups run faster" )

[14:03] <moritz> we ended up using the last backup in a separate database

[14:03] * azawawi home &

[14:03] <parsonsNose> still, you had those 10k records in test, right, since you didn't run the job there?

[14:03] <parsonsNose> :D

[14:03] <moritz> and removed the DEETE statements from the mysql replication logs

[14:03] *** ollej joined
[14:03] <moritz> then ran the replication logs in that database copy

[14:04] <moritz> and then wrote a script that copies the deleted rows from the backup database to prod

[14:04] <lizmat> sounds familiar in a way  :-)

[14:04] <llfourn> what caused the deleting job to segfault? was it a script or some db native thingo....

[14:04] <moritz> parsonsNose: we had, but we also had 5 hours of people going wild in the test database. Because all is fair in test, right? :-)

[14:05] *** azawawi left
[14:05] <moritz> llfourn: I haven't yet debugged why it segfaulted :-)

[14:05] *** ollej left
[14:05] <llfourn> was it perl?

[14:06] <moritz> llfourn: yes

[14:06] *** Begi1114 left
[14:07] <moritz> llfourn: but with lots of XS under the hood (DBI, EV, mod_perl, ...)

[14:07] <llfourn> ahhh well that's what saved you

[14:08] <moritz> still it was 2.5 work days to get it all back

[14:08] <lizmat> moritz: with a PP version, it wouldn't have sagfaulted, but it would have been slower

[14:08] <masak> moritz: what do you feel you learned from the episode? :)

[14:09] <moritz> lizmat: pure perl mod_perl?

[14:09] <lizmat> np, PP DBI   :)

[14:10] <lizmat> *no

[14:10] <moritz> masak: that backups and replication logs can save your behind. That it sucks to be the one to have pressed the wrong button (luckily, wasn't me). That it shouldn't be so easy to press the wrong button, but sometimes it's hard to make it harder.

[14:11] <masak> aye

[14:11] *** Begi1114 joined
[14:12] <moritz> masak: but maybe most importantly that it helped imensly to not do the recovery alone

[14:14] *** lichtkind joined
[14:14] *** Actualeyes joined
[14:16] *** ngie left
[14:17] *** BenGoldberg left
[14:18] *** BenGoldberg joined
[14:18] *** BenGoldberg left
[14:19] *** BenGoldberg joined
[14:20] *** BenGoldberg left
[14:20] *** BenGoldberg joined
[14:21] <dalek> rakudo/nom: 0c775c9 | lizmat++ | / (4 files):

[14:21] <dalek> rakudo/nom: Wean slicing away from CLONE-HASH-DECONTAINERIZED

[14:21] <dalek> rakudo/nom: 

[14:21] <dalek> rakudo/nom: This might have a beneficial effect on slicing with adverbs, but alas

[14:21] <dalek> rakudo/nom: this appears to be within noise levels  :-(

[14:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0c775c956a

[14:21] *** BenGoldberg left
[14:21] *** BenGoldberg joined
[14:23] <masak> moritz: yeah, I can imagine.

[14:23] *** dayangkun joined
[14:24] *** khw joined
[14:30] <dalek> rakudo/nom: b0b2489 | lizmat++ | src/core/control.pm:

[14:30] <dalek> rakudo/nom: Fix #126447 and #125953 (and possibly more)

[14:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b0b2489a2c

[14:30] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126447

[14:31] *** zakharyas joined
[14:34] *** dayangkun left
[14:34] *** cosine joined
[14:39] *** rurban joined
[14:39] *** andreoss joined
[14:44] *** zakharyas left
[14:44] <gfldex> is the last statement in the following still valid? http://rosettacode.org/wiki/Unicode_strings#Perl_6

[14:46] <lizmat> I think the "specced not entirely implemented" can be removed

[14:46] *** intrigue is now known as heisenberg

[14:47] <lizmat> the rest seems still applicable to me

[14:49] <cosine> Hello everyone...

[14:49] <cosine> Is there some way to automatically convert built-in types to custom classes?

[14:49] <cosine> Like this: http://pastebin.com/Jk168sHC

[14:50] <gfldex> cosine: you would use a multi for do-a-b-c

[14:51] <cosine> So I have to define a multi for each type then?

[14:51] <cosine> Int, Str, etc.

[14:53] <gfldex> or you replace method do-? with a multi

[14:53] *** ollej joined
[14:53] <cosine> Hmm, how do you mean?

[14:54] <cosine> Should I write it like this? http://pastebin.com/RhPQhh7F

[14:54] <lizmat> cycling&

[14:54] *** rurban left
[14:55] <gfldex> Perl 6 does not provide automatic type casts like C++ does, so you have to do it by hand and redefine your problem.

[14:55] <gfldex> I tend to find myself doing the latter quite often.

[14:56] <cosine> Okay... I mainly just want to do it for convenience in a few places anyway, so it's not really a problem to just call .new manually.

[14:57] <cosine> Thanks for the help

[14:57] *** rurban joined
[15:06] *** tokuhiro_ left
[15:06] <masak> greetings, cosine. welcome :)

[15:06] <masak> 'night, #perl6

[15:07] <pink_mist> sleep well masak

[15:07] *** AlexDaniel left
[15:09] <skaji> lizmat: I reported #126447. Thank you for your quick fix. It now works, but a warning is emitted.

[15:09] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126447

[15:09] <skaji> $ perl6 -e '{ temp %*ENV<FOO> = "1" }; { temp %*ENV<BAR> = "1"; run "ls" }'

[15:09] <skaji> Use of uninitialized value %ENV of type Any in string context

[15:09] <skaji> Any of .^name, .perl, .gist, or .say can stringify undefined things,

[15:09] <skaji> if needed.  in block  at -e:1

[15:09] <skaji> Applications  System   bin    etc net  sbin var

[15:12] *** rurban left
[15:13] *** edehont left
[15:16] *** xfix joined
[15:17] *** cosine left
[15:18] *** weihan joined
[15:23] *** telex left
[15:24] *** telex joined
[15:29] <ugexe> looks like <foo> isn't getting removed when it leaves the scope

[15:29] *** edehont joined
[15:32] <ugexe> m: { temp %*ENV<FOO> = 1; }; say %*ENV.perl

[15:32] <camelia> rakudo-moar cd7766: OUTPUT«{:FOO(Any), :HOME("/home/camelia"), :LANG("POSIX"), :LC_CTYPE("en_US.UTF-8"), :LOGNAME("camelia"), :MANPATH("/home/camelia/perl5/perlbrew/perls/perl-5.20.1/man:"), :PATH("/home/camelia/perl5/perlbrew/bin:/home/camelia/perl5/perlbrew/perls/perl-5.20.1/bin:/…»

[15:34] *** anaeem1_ joined
[15:35] *** anaeem1_ left
[15:36] *** tokuhirom joined
[15:37] <moritz> m: { temp %*ENV<FOO> = 1; }; say %*ENV.keys.sort.perl

[15:37] <camelia> rakudo-moar cd7766: OUTPUT«("FOO", "HOME", "LANG", "LC_CTYPE", "LOGNAME", "MANPATH", "PATH", "PERL5LIB", "PERLBREW_BASHRC_VERSION", "PERLBREW_HOME", "PERLBREW_MANPATH", "PERLBREW_PATH", "PERLBREW_PERL", "PERLBREW_ROOT", "PERLBREW_VERSION", "PWD", "RAKUDO_NO_DEPRECATIONS", "SHELL", "…»

[15:41] *** tokuhirom left
[15:42] *** liztormato joined
[15:42] *** liztormato left
[15:43] *** liztormato joined
[15:43] *** liztormato left
[15:47] *** xenowoolfy joined
[15:47] *** xenowoolfy left
[15:47] *** xenowoolfy joined
[15:48] *** nightfrog joined
[15:49] *** xenowoolfy left
[15:51] *** parsonsNose left
[15:51] *** lizmat_ joined
[15:53] <lizmat_> skaji: will look at the warnings when I'm back home 

[15:56] *** lizmat_ left
[15:56] *** liztormato joined
[16:03] *** edehont left
[16:06] *** tokuhiro_ joined
[16:07] *** domidumont joined
[16:10] *** ^elyse^ left
[16:11] *** tokuhiro_ left
[16:13] <xinming> Hi, Just curious about the question yesterday.

[16:13] <xinming> my $str = "xx";  %h<<$str>>;    and  %h<<xx>>    behaves differently.

[16:13] <xinming> Is this intentional?

[16:14] <liztormato> Different how?

[16:15] <xinming> m: my %h = 1, 'a', 2, 'b'; %h<<1>>.WHAT.say; my $var = 1; %h<<$var>>.WHAT.say;

[16:15] <camelia> rakudo-moar cd7766: OUTPUT«(Str)␤(List)␤»

[16:16] *** leont left
[16:16] <xinming> liztormato: Did you see? One returns the value of the key, the other returns a List

[16:19] <liztormato> $var could expand to multiple values, that's why it returns a List

[16:19] <liztormato> A bare str can not 

[16:21] <RabidGravy> aye, it's use {} unless you actually *want* that behaviour

[16:26] *** weihan left
[16:26] <RabidGravy> after all you know when you are typing the program whether it is a string literal or a variable

[16:32] *** xfix left
[16:35] *** ^elyse^ joined
[16:37] <[Coke]> messages?

[16:38] *** edehont joined
[16:39] *** slobo left
[16:39] <liztormato>     o/ edehont

[16:39] <edehont> \o/

[16:40] <edehont> Lurking and learning...

[16:41] <liztormato> ;-). Welcome!

[16:46] *** liztorma_ joined
[16:48] *** liztormato left
[16:49] *** diana_olhovik_ joined
[16:50] *** liztorma_ left
[16:50] *** llfourn left
[16:52] *** patrickz joined
[16:54] <patrickz> Hey! How would I go about accessing a perl5 package variable using Inline::Perl5?

[16:54] <yoleaux> 9 Oct 2015 11:18Z <jdv79> patrickz: yes.  i'd like to try to get cpants support though since that's more mature

[16:54] <yoleaux> 9 Oct 2015 11:19Z <jdv79> patrickz: less work for all:)

[16:54] <yoleaux> 9 Oct 2015 11:20Z <jdv79> patrickz: oh, seems cpants and cpantesters aren't the same thing.  I mean the latter.

[16:55] *** ^elyse^ left
[16:56] *** Mark- joined
[16:56] *** Mark- left
[16:56] *** virtualsue joined
[17:00] <RabidGravy> patrickz, it's something like:   use Foo :from<perl5>

[17:00] <RabidGravy> (I've never used it so that could be wrong)

[17:01] <RabidGravy> infact the synopsis here has it https://github.com/niner/Inline-Perl5/

[17:01] <RabidGravy> sorry I may have mis-read what you asked

[17:02] <RabidGravy> "package variable"

[17:02] <dalek> roast: e58cb30 | usev6++ | S02-magicals/env.t:

[17:02] <dalek> roast: Add test for RT #125953

[17:02] <dalek> roast: review: https://github.com/perl6/roast/commit/e58cb30a90

[17:02] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125953

[17:05] <Zoffix> patrickz, have you tried just the normal way?   use DBI:from<Perl5>;  say $DBI::Foo::Bar::Baz::Var;

[17:05] <yoleaux> 24 Oct 2015 14:46Z <Ven> Zoffix: tell me when I can start treating https://github.com/adambard/learnxinyminutes-docs/issues/1390

[17:06] <patrickz> Haven't tried yet. Thought I'd ask first. But will try and report. :-)

[17:07] <Zoffix> .tell Ven RE learnxiny: any time :) I finished with the docs and submitted my PR (#1434), which got merged. The ones that aren't crossed out are still open. And I don't know a suitable answer :)

[17:07] <yoleaux> Zoffix: I'll pass your message to Ven.

[17:07] <Zoffix> .botsnack

[17:07] <yoleaux> :D

[17:07] <synbot6> om nom nom

[17:14] *** blackcat_ joined
[17:16] *** diana_olhovik_ left
[17:16] *** loren left
[17:18] *** kmel joined
[17:23] *** BenGoldberg left
[17:23] *** BenGoldberg joined
[17:26] *** colomon left
[17:26] *** colomon joined
[17:33] *** pmurias joined
[17:35] *** BenGoldberg left
[17:35] *** BenGoldberg joined
[17:36] *** BenGoldberg left
[17:36] *** BenGoldberg joined
[17:36] <timotimo> hello everybody

[17:37] <timotimo> i know why the problem happens with the eating all the memory thing parsonsNose encountered

[17:37] <RabidGravy> hello

[17:37] <timotimo> allocating big bignums doesn't put pressure on the GC at all, because only the header of the bignum object lives in GC'd memory

[17:37] <timotimo> and those are small; the actual number itself gets malloc'd directly

[17:37] <RabidGravy> ew

[17:37] <pmurias> people seem to be complaining about q:x being a foot gun, should q:w:x {...} be the safer version?

[17:38] <timotimo> so the GC will happily fill up its nursery of 4 megabytes with these tiny objects that all have a few megabytes of non-gc-managed memory backing them

[17:38] <timotimo> in the past i've already added a pressure thingie for strings to the GC; that could be generalized to also handle bigints

[17:39] <timotimo> perhaps there's also a reason to do the same for Blob-like objects, i.e. everything repr'd VMArray

[17:39] <timotimo> but the way bigint ops work is much more prone to memory ballooning than Blobs etc

[17:40] <timotimo> because basically every operation on a bigint will do a copy, whereas you'd be accessing positionals inside a Blob or slices much more often

[17:44] *** heisenberg is now known as intrigue

[17:44] <lizmat> m: { temp %*ENV<FOO> }; ~%*ENV<FOO>   # golfed problem skaji reported

[17:44] <camelia> rakudo-moar cd7766: OUTPUT«WARNINGS:␤Useless use of "~" in expression "~%*ENV<FOO>" in sink context (line 1)␤Use of uninitialized value %ENV of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/Y…»

[17:45] <lizmat> the problem is really that temp %h<FOO> removes the value, but not the key

[17:45] <timotimo> i didn't even know temp could do such a thing yet ...

[17:46] *** Actualeyes left
[17:46] <lizmat> m: { let %*ENV<FOO> }; ~%*ENV<FOO>   # same for let

[17:46] <camelia> rakudo-moar cd7766: OUTPUT«WARNINGS:␤Useless use of "~" in expression "~%*ENV<FOO>" in sink context (line 1)␤Use of uninitialized value %ENV of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at /tmp/s…»

[17:47] *** edehont left
[17:48] *** yqt joined
[17:48] <lizmat> timotimo: I guess World.setup_let_or_temp needs some extra magic to handle hashes

[17:48] <lizmat> which is really outside of my comfort zone

[17:49] <timotimo> as it is outside mine

[17:50] <timotimo> i'm up to the first spectest run for the new "for ^foo -> loop" optimization to take advantage of nine's recent refactoring

[17:50] *** rurban joined
[17:50] <timotimo> but it's on my laptop, and that is curently in my bag, and i have to do other stuff before i can head out

[17:53] *** diana_olhovik joined
[17:53] *** Begi1114 left
[17:54] <nine> patrickz: there's no way to access Perl 5 package variables from Perl 6 directly. It's on my TODO list. In the mean time, you can help yourself with small getter/setter functions in Perl 5. Those can be called from Perl 6.

[17:56] <patrickz> nine: ok. Thus no $DBI::errstr for now.

[17:58] <Zoffix> There is Perl 6's DBIish :)

[17:58] <patrickz> nine: Inline::Perl5 is totally awesome btw.

[17:58] *** inokenty left
[17:59] <nine> patrickz: thanks :)

[17:59] <patrickz> Zoffix: True. I'm refactoring a Perl5 code base and thought I'd go the way of least resistance. Thus Inline::Perl5 for all stuff that's not yet polished in perl6. Thus DBI instead of DBIish

[18:00] <Zoffix> :)

[18:03] <lucasb_> m: my %h = a=>1; { temp %h<b> = 1 }; say %h

[18:03] <camelia> rakudo-moar cd7766: OUTPUT«a => 1, b => (Any)␤»

[18:03] <lucasb_> m: my @a = 1,2,3; { temp @a[5] = 42 }; say @a

[18:03] <camelia> rakudo-moar cd7766: OUTPUT«[1 2 3 (Any) (Any) (Any)]␤»

[18:03] <lucasb_> ^^ the same thing for arrays, too, right?

[18:05] *** inokenty joined
[18:06] <lucasb_> another thing is that 'temp' doesn't work with slices %h<a b c> = ... or @a[0,1,2] = ...; should it work?

[18:07] *** BenGoldberg left
[18:07] *** BenGoldberg joined
[18:08] *** ^elyse^ joined
[18:08] *** BenGoldberg left
[18:09] *** BenGoldberg joined
[18:09] *** ^elyse^ left
[18:11] <lizmat> lucasb_: temp at this moment only works for scalar values

[18:12] *** BenGoldberg left
[18:13] *** BenGoldberg joined
[18:14] <xinming> m: my %h = 1, 'a', 2, 'b'; %h<<"1 2">>.WHAT.say; my $var = "1 2"; %h<<$var>>.WHAT.say;

[18:14] <camelia> rakudo-moar cd7766: OUTPUT«(Any)␤(List)␤»

[18:14] <xinming> m: my %h = 1, 'a', 2, 'b'; %h<<"1 2">>.WHAT.say; my $var = "1 2"; %h<<$var>>.WHAT.say; %h<<$var>>.perl.say;

[18:14] <camelia> rakudo-moar cd7766: OUTPUT«(Any)␤(List)␤("a", "b")␤»

[18:14] <psch> m: my %h = 1, 'a', 2, 'b'; %h<<1 2>>.WHAT.say; my $var = "1 2"; %h<<$var>>.WHAT.say;

[18:14] <camelia> rakudo-moar cd7766: OUTPUT«(List)␤(List)␤»

[18:15] <xinming> Yes, But I'm still a bit confused

[18:15] <psch> m: say <<"1 2>>.perl; say <<1 2>>.perl

[18:15] <camelia> rakudo-moar cd7766: OUTPUT«5===SORRY!5=== Error while compiling /tmp/_qk5RAvrrE␤Unable to parse expression in double quotes; couldn't find final '"' ␤at /tmp/_qk5RAvrrE:1␤------> 3say <<"1 2>>.perl; say <<1 2>>.perl7⏏5<EOL>␤    expecting any of:␤        argument …»

[18:15] <xinming> I mean on the $list thing

[18:15] <psch> m: say <<"1 2">>.perl; say <<1 2>>.perl

[18:15] <camelia> rakudo-moar cd7766: OUTPUT«"1 2"␤(IntStr.new(1, "1"), IntStr.new(2, "2"))␤»

[18:15] <xinming> <<"1 2">>.perl.say;

[18:15] <lizmat> my %h = 1, 'a', 2, 'b'; %h<<1 2>>.WHAT.say; my $var = "1 2"; %h<<"$var">>.WHAT.say;

[18:15] <xinming> m: <<"1 2">>.perl.say;

[18:15] <camelia> rakudo-moar cd7766: OUTPUT«"1 2"␤»

[18:15] <lizmat> m: my %h = 1, 'a', 2, 'b'; %h<<1 2>>.WHAT.say; my $var = "1 2"; %h<<"$var">>.WHAT.say;

[18:15] <camelia> rakudo-moar cd7766: OUTPUT«(List)␤(Any)␤»

[18:16] <xinming> It's still confusing to me.

[18:16] <xinming> I'll give up anyway, Go on with other parts of perl6, Thanks

[18:17] * timotimo has never used the << >> slices before

[18:17] <lucasb_> I think <<...>> should have been called shellwords. :)

[18:17] *** BenGoldberg left
[18:17] <moritz> %hshellwords(...) # doesn't read so well :-)

[18:17] *** BenGoldberg joined
[18:18] *** BenGoldberg left
[18:19] *** BenGoldberg joined
[18:20] *** yqt left
[18:30] *** xfix joined
[18:34] *** kmel left
[18:34] *** AlexDaniel joined
[18:36] <lucasb_> so... there is this secondary prompt "*" in the REPL now?

[18:36] <lucasb_> first one is ">". if you type a blank line, then it is "*"

[18:37] <lucasb_> if you type any arbitrary expression in the "*" prompt, it doesn't give any error!

[18:41] <AlexDaniel> pmurias: no, q:w:x is not safer

[18:42] <AlexDaniel> not even close…

[18:43] *** BenGoldberg left
[18:43] *** BenGoldberg joined
[18:44] <AlexDaniel> pmurias: actually, it seems like :w will split the output returned by the shell

[18:44] <AlexDaniel> pmurias: but even if it didn't, there is no easy way to pass arguments to shell

[18:44] *** Ben_Goldberg joined
[18:45] *** BenGoldberg left
[18:45] <AlexDaniel> pmurias: that is, you pass a string, not something else. What you probably want is “run”, which actually accepts arguments

[18:45] *** Ben_Goldberg left
[18:46] *** Ben_Goldberg joined
[18:46] *** kanishka joined
[18:46] <RabidGravy> I actually think there needs to be a "Working with external programs" page in the docs

[18:46] *** diana_olhovik left
[18:46] *** Ben_Goldberg left
[18:47] *** kanishka left
[18:47] <RabidGravy> that way we can inculcate good practice in people from the start rather them gleaning possibly insecure practice from other sources

[18:47] *** Ben_Goldberg joined
[18:47] <AlexDaniel> RabidGravy: I haven't submitted a pull request to the docs yet, but actually I'm hoping that :x will just go…

[18:48] <AlexDaniel> so that I don't have to explain how nothing will make :x safer

[18:48] <RabidGravy> I'm talking irrespective of any other change

[18:49] <dalek> rakudo/nom: cfb7d87 | lizmat++ | / (2 files):

[18:49] <dalek> rakudo/nom: Make single key slices with 1 adverb 15% faster

[18:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cfb7d876c0

[18:49] <AlexDaniel> RabidGravy: well, sure, but it has to be reworked after the change, so…

[18:50] <RabidGravy> er, only very slightly

[18:50] *** Ben_Goldberg left
[18:51] *** Ben_Goldberg joined
[18:51] <RabidGravy> the point being if one was to document the best practice as it currently stands it may not even mention the ':x'

[18:53] <AlexDaniel> RabidGravy: indeed

[18:56] <lizmat> commute to Amsterdam for EuroOSCON Mon/Tue/Wed &

[18:56] *** lizmat left
[18:57] <timotimo> oh, cool

[19:00] *** Ben_Goldberg left
[19:02] *** yqt joined
[19:05] <RabidGravy> I may commute to the other side of the sofa for fun

[19:11] *** zengargoyle joined
[19:12] *** blackcat_ left
[19:14] <zengargoyle> i have a weird problem,  using Channel and earliest, seems like 'more' creates a closure that never goes away.

[19:14] <zengargoyle> https://gist.github.com/zengargoyle/5324c93684d6f5a376a3

[19:14] <zengargoyle> ^ minimal test

[19:14] <zengargoyle> or i might be doing something completely wrong...

[19:14] *** softmoth joined
[19:15] *** rurban left
[19:18] *** andreoss left
[19:22] <pmurias> AlexDaniel: banning interpolation would make :x safe

[19:22] *** tokuhiro_ joined
[19:22] <pmurias> AlexDaniel: or are there other serious problems with :x besides shell injection?

[19:23] <AlexDaniel> pmurias: I agree, but why keep :x at all then?

[19:24] <pmurias> it can be usefull in short quick and dirty scripts

[19:25] <AlexDaniel> pmurias: what's wrong with “shell()”?

[19:25] <pmurias> it doesn't return the result of the command

[19:25] <AlexDaniel> pmurias: what's wrong with “shellout()”?

[19:26] *** tokuhiro_ left
[19:26] <pmurias> shouldn't it be shell-out?

[19:28] <AlexDaniel> pmurias: good question, actually. However, if it is shellout or shell-out, is it less convenient than qx// in “quick and dirty” scripts?

[19:29] <pmurias> isn't it qq:x and q:x instead of qx?

[19:30] <pmurias> ah, the colon is optional

[19:30] <AlexDaniel> you can use qx and qqx without colons, just like with everything else

[19:30] <pmurias> AlexDaniel: actually qx is safe as it doesn't interpolate

[19:30] *** domidumont left
[19:30] <AlexDaniel> internally the function is called QX :)

[19:32] <AlexDaniel> pmurias: still not safer than run though. For example, if someone attempts to use an ENV variable inside of it, then he can forget to quote it. One might argue that it's outside of the Perl6 scope, but I think that it's not enough to declare it safe.

[19:33] *** TEttinger joined
[19:33] <AlexDaniel> pmurias: also, there's a good article: http://julialang.org/blog/2012/03/shelling-out-sucks/

[19:33] <AlexDaniel> it kinda mentions all of the other problems with shells

[19:34] <AlexDaniel> in other words, you should still prefer “run” even for dirty cases…

[19:35] <AlexDaniel> but if you don't want to, OK, TIMTOWTDI, “shell” and “shellout”!

[19:35] <pmurias> it seems to be a tradeoff between convenience and avoid shell injection

[19:35] <pmurias> I don't think I'm qualified to make a choice

[19:35] <AlexDaniel> pmurias: you did not answer my question though

[19:36] <AlexDaniel> pmurias: I don't understand how qx// is less convenient than shellout()

[19:36] <pmurias> you mean more convenient?

[19:36] <AlexDaniel> whoops, yes, of course

[19:36] <pmurias> it's shorter

[19:37] <AlexDaniel> and that's it?

[19:37] <pmurias> I think that's all

[19:37] <pmurias> it's qx/.../ vs shell-out(q/.../)

[19:38] *** rurban joined
[19:38] <RabidGravy> frankly if it were me I would remove any thing that used the shell completely unless you presented a certificate signed by two responsible adults

[19:38] <AlexDaniel> Ok, well, that's the whole point. “run” should be shorter than anything that uses the shell. Other than that, you are free to use shell if you dare to type it…

[19:40] <AlexDaniel> RabidGravy: I kinda agree, but at the same time I know that people want to play around when adults are far away :)

[19:42] <pmurias> imagine qq:sql {select * from table where column = $value;} # jk

[19:42] <RabidGravy> part of the problem viz Perl 6 vs Perl 5 in this regard is the absense of "source tracking" aka tainting

[19:44] <AlexDaniel> pmurias: I thought we already have sql grammar thingy

[19:45] *** vendethiel joined
[19:45] <AlexDaniel> Also, I see no point to have a quoting adverb that cannot be combined with other adverbs in real life

[19:47] <pmurias> having a shell-like grammar for quick scripts would be a fun and safer way of doing things

[19:52] <AlexDaniel> pmurias: if you don't forget to quote your variables, the yes, perhaps

[19:52] <AlexDaniel> pmurias: also I had an idea that perl6 shell grammar should autoquote stuff by default

[19:53] <RabidGravy> http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_10  there you go ;-)

[19:53] <AlexDaniel> I don't know if that's a good idea, but perhaps better than nothing

[19:56] <pmurias> AlexDaniel: the shell-like grammar should avoid calling the shell entirely

[19:57] <AlexDaniel> pmurias: yes but if I type “rm $foo”, what is going to happen?

[19:57] *** geraud joined
[19:57] <pmurias> the file name contained in $foo should be removed

[19:57] <AlexDaniel> what if $foo = 'world hello'

[19:58] <AlexDaniel> in normal shells two files will be deleted

[19:59] <b2gills> «rm "$foo"»

[20:00] <moritz> ... as long as $foo doesn't contain "

[20:00] <AlexDaniel> b2gills: yes, I've mentioned that in my pull request. However, it means that you should never forget to quote your variables (people always forget to do that in bash, so why would they do it better in perl6?), it also means that you should only use run()

[20:00] <AlexDaniel> moritz: run(«rm "$foo"»); # are you sure?

[20:01] <b2gills> I think that since you don't have to have ｢use IPC::Run｣ to get ｢run｣ that the :x can go into a deep hole

[20:01] *** cognominal left
[20:01] <b2gills> m: my $foo = 'world hello'; dd «rm "$foo"»

[20:01] <camelia> rakudo-moar cd7766: OUTPUT«List $var = $("rm", "world hello")␤»

[20:02] <AlexDaniel> m: my $foo = 'world "hello'; dd «rm "$foo"»

[20:02] <camelia> rakudo-moar cd7766: OUTPUT«List $var = $("rm", "world \"hello")␤»

[20:02] <AlexDaniel> safe!

[20:02] <AlexDaniel> uhm, safe!*

[20:03] <AlexDaniel> * – unless you pass that into shell(), but it's going to complain about too many args I think

[20:04] <AlexDaniel> “This type cannot unbox to a native string”

[20:04] <AlexDaniel> what!

[20:08] <RabidGravy> ship it!

[20:08] <RabidGravy> ;-)

[20:12] <b2gills> m: say Int.^roles; say Int.^roles(:transitive)

[20:12] <camelia> rakudo-moar cd7766: OUTPUT«((Real))␤Cannot find method 'roles'␤  in any roles at gen/moar/m-Metamodel.nqp:2894␤  in block <unit> at /tmp/O0DtY7MkpV:1␤␤»

[20:13] <RabidGravy> OooOOOoooh

[20:15] *** espadrine_ joined
[20:15] *** darutoko left
[20:22] * timotimo is about to run a before-spectest to verify his for-optimization-patch is sane

[20:23] *** raiph left
[20:24] <timotimo> ooooh, dinner is served!

[20:24] <Zoffix> :(

[20:24] * Zoffix is hungry now

[20:25] <vendethiel> o/

[20:25] <vendethiel> Zoffix: thanks for your answers

[20:25] <vendethiel> (i've seen the PR go through, obviously)

[20:26] <Zoffix> np

[20:27] <AlexDaniel> .tell lizmat shell(«echo "world hello"»); # I wonder if this problem is associated with other “cannot unbox to a native string” problems.

[20:27] <yoleaux> AlexDaniel: I'll pass your message to lizmat.

[20:27] *** CurtisOvidPoe joined
[20:27] <AlexDaniel> .tell lizmat not that it should work, but the error message is awful

[20:27] <yoleaux> AlexDaniel: I'll pass your message to lizmat.

[20:30] <CurtisOvidPoe> When I call await on a list of promises, I always seem to get the output in the same order. https://gist.github.com/Ovid/92ba0af93988f2c6e560

[20:30] <CurtisOvidPoe> (It’s also not much faster than procedural)

[20:31] <b2gills> of course you would get them in order, you are asking for them in order

[20:34] *** ChoHag joined
[20:34] *** tokuhirom joined
[20:34] <CurtisOvidPoe> I guess that makes sense. I should look at it as more async if I’m less worried about the order. Still getting used to the Perl 6 way of handling this :)

[20:35] <labster> Are we still trying to stop consenting adults from using shells?

[20:35] *** virtualsue left
[20:36] <vendethiel> CurtisOvidPoe: there are certain constructions that will explicitly discard order of operation/order of resulting set (hyper, race) if you want that, btw

[20:36] <vendethiel> i don't think they're any faster right now, though :)

[20:36] *** kaare_ left
[20:38] <moritz> vendethiel: hyper still preserves result order; only race doesn't

[20:38] <vendethiel> moritz: hence my "order of operation/order of resulting set" :)

[20:38] <vendethiel> i should've used / between "hyper" and "race" though, you're right

[20:38] <moritz> vendethiel: ah, didn't grok that

[20:38] *** tokuhirom left
[20:39] <b2gills> ｢eager @promises.race.map: *.result.say｣

[20:40] <CurtisOvidPoe> Is there some way I can inject Promise.anyof into that last line to get the results as soon as they occur or do I need to rewrite it?

[20:41] <CurtisOvidPoe> (I tried using b2gills’ last line and they’re still in order)

[20:41] <b2gills> I think you want .then

[20:41] <CurtisOvidPoe> So clearly I’m missing something here :)

[20:41] <mrf> Does anyone knwo what had caused Grammar::Debugger to throw: http://pastebin.com/Dc1iv2Tf

[20:41] <CurtisOvidPoe> b2gills: I want .then where?

[20:41] <b2gills> They are still in the same order because the batch size is bigger than 4

[20:42] <b2gills> @promise>>.then>>.say

[20:42] <b2gills> @promise>>.then(*.say)

[20:42] <moritz> @promise>>.then(&say)

[20:42] <mrf> m-star: use Grammar::Debugger; grammar G { rule TOP { .* } }; G.parse('foo');

[20:42] <zengargoyle> while @promises { my $got = await Promise::anyof(@promises); @promises.=map(?!*); }

[20:43] <moritz> don't we have 'earliest' for that?

[20:43] <moritz> or something like that

[20:43] <moritz> or winner? no, I think winner is gone again

[20:43] <zengargoyle> yes i think, but i'm having a problem with that

[20:43] <zengargoyle> https://gist.github.com/zengargoyle/5324c93684d6f5a376a3#file-earliest-more-p6-L22

[20:43] <b2gills> @promise».then(*.result.say)

[20:43] <CurtisOvidPoe> OK, we’re getting into weird “Perl has scary punctuation” territory for some of those. Still trying to avoid that.

[20:44] <CurtisOvidPoe> b2gills: that last line prints 13 and exists. It’s fast, though :)

[20:45] <moritz> CurtisOvidPoe: you can do the .then(...) where you construct the promises

[20:45] <moritz> CurtisOvidPoe: which probably causes less weird punctuation

[20:45] *** espadrine_ left
[20:45] <CurtisOvidPoe> OK. I’m tired and it doesn’t seem quite as easy as I thought. I think I’ll skip that for tomorrow’s talk.

[20:45] <CurtisOvidPoe> My apologies.

[20:45] <b2gills> add a ｢sleep 10｣ or so

[20:46] <zengargoyle> oops, think that map was meant to be grep

[20:46] *** uruwi joined
[20:46] <zengargoyle> it's removing the kept/broken promise from  @promises

[20:47] <RabidGravy> moritz, earliest appears to only work for Channels

[20:48] *** vendethiel left
[20:48] <RabidGravy> (though I thought it work with Promises too)

[20:51] *** vendethiel joined
[20:55] <zengargoyle> @promises = @promises.grep(*.status ~~ Promise::Planned)

[20:56] <vendethiel> zengargoyle: can't you do that with .grep(!*)?

[20:56] <zengargoyle> un-special remove kept/broken promises.   CurtisOvidPoe didn't like the special-ness. :)

[20:57] <zengargoyle> i thought maybe there were .kept .broken .planned methods but docs don't mention them.

[20:57] <vendethiel> I think jnthn's talk used .grep(!*), also

[20:57] <zengargoyle> yeah, that's my half-remembered source

[20:58] <vendethiel> > @working .= grep({ !$_ });

[20:58] <vendethiel> m: (!*)(True).say

[20:58] <camelia> rakudo-moar cd7766: OUTPUT«False␤»

[20:58] <moritz> *.not

[20:58] <CurtisOvidPoe> zengargoyle: the docs mention them on Promises: http://design.perl6.org/S17.html#Promises (Or did I misunderstand what you were referring to?)

[20:58] <zengargoyle> the Promise::anyof returns the matched promise's .result and not the promise itself.

[20:58] <vendethiel> yeah, or {!$_} -- just fine

[20:59] <zengargoyle> i was going by http://doc.perl6.org/type/Promise

[21:00] <zengargoyle> the doc pages usually avoid the things that are in synopses that got dropped/changed or not implementd yet.  but may also leave things out i guess.

[21:00] <vendethiel> .tell jnthn on your blog, http://jnthn.net/papers/2008-fpw-rakudo-slides.pdf is broken

[21:00] <yoleaux> vendethiel: I'll pass your message to jnthn.

[21:01] <CurtisOvidPoe> Heading to bed. Night all!

[21:01] *** CurtisOvidPoe left
[21:03] <vendethiel> also, the >>.then seems to be pretty useless for me, if then is asynchronous, .map(*.then) should do the same. The order of the calls to same most probably doesn't matter..

[21:04] <vendethiel> s/for me/to me/ # englishing?

[21:09] *** Peter_R left
[21:09] <zengargoyle> m: <a aa aaa>>>.comb>>.elems

[21:09] <camelia> rakudo-moar cd7766: ( no output )

[21:09] <zengargoyle> m: say <a aa aaa>>>.comb>>.elems

[21:09] <camelia> rakudo-moar cd7766: OUTPUT«(1 2 3)␤»

[21:10] <zengargoyle> m: say <a aa aaa>.map(*.comb.map(*.elems))

[21:10] <camelia> rakudo-moar cd7766: OUTPUT«((1) (1 1) (1 1 1))␤»

[21:10] <zengargoyle> m: say <a aa aaa>.map(*.comb.elems)

[21:10] <camelia> rakudo-moar cd7766: OUTPUT«(1 2 3)␤»

[21:11] <vendethiel> zengargoyle: >> is one level only, afaik

[21:11] <vendethiel> m: say (1, 2, 3)>>.succ.perl;

[21:11] <camelia> rakudo-moar cd7766: OUTPUT«(2, 3, 4)␤»

[21:11] *** Peter_R joined
[21:12] <zengargoyle> i tend to favor >> over map sometimes when doing fancy things down deep in a structure over nested map.  failing to come up with a good simple example though.

[21:15] *** labster left
[21:16] <dalek> rakudo/curli: 4fad898 | (Stefan Seifert)++ | lib/lib.pm6:

[21:16] <dalek> rakudo/curli: Have use lib change $*REPO instead of @*INC

[21:16] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/4fad8988d9

[21:16] <mrf> Does anyone have any ideas regarding the cause of https://github.com/jnthn/grammar-debugger/issues/22 ? 

[21:17] <mrf> Grammar::Debugger seems unable to install on the version of Rakudo I have 'gcfb7d87' but camelias version of Star seems fine.

[21:21] *** lucasb_ left
[21:23] <RabidGravy> mrf, can confirm it works on a rakudo of about a wek ago

[21:23] <RabidGravy> week

[21:24] <ugexe> i think it had something to do with a somewhat recent commit about LHS smart matching

[21:25] <ugexe> https://github.com/rakudo/rakudo/commit/5d83db3d01b3ae1b7ee623178163a5ba04ee7ce8 ?

[21:26] <RabidGravy> I'll look on the morning if I can understand the code

[21:27] <mrf> RabidGravy++ ugexe++ thanks. That certainly looks like a viable source of the issue.

[21:27] *** bjz_ left
[21:29] <RabidGravy> I vaguely recall someone mentioning this the other day

[21:29] <vendethiel> yeah, seems like that disabled 

[21:29] <vendethiel> m: say Mu.new ~~ /foo/; # ?

[21:29] <camelia> rakudo-moar cd7766: OUTPUT«X::Multi::NoMatch exception produced no message␤  in block <unit> at /tmp/bjqKRdkZzN:1␤␤»

[21:29] <ugexe> needs a Mu:D smiley sig FROGGS_ ?

[21:31] * mrf adds learning method sig syntax to TODO list

[21:33] *** jstimpfle joined
[21:34] *** zakharyas joined
[21:40] *** lichtkind_ joined
[21:43] <itz_stmuk> mrf: there is a pull request to fix Grammar::Debugger

[21:43] <itz_stmuk> FROGGS fixed it in https://github.com/jnthn/grammar-debugger/pull/21

[21:46] <mrf> itz_stmuk: awesome thanks. I will see if I can install the version in that branch directly

[21:47] *** xfix left
[21:47] <RabidGravy> erk, wish I hadn't looked at that code

[21:49] <mrf> I don't even pretend to understand what is going on there.

[21:51] <mrf> heh that was easier than I expected.

[21:51] <RabidGravy> it's the multiple returns thhat are freaking me out

[21:52] <mrf> I have a more fundimental problem in actually understanding the signatures

[21:53] <AlexDaniel> RabidGravy: well, it is pretty much idiomatic perl5

[21:53] *** tokuhiro_ joined
[21:53] <AlexDaniel> RabidGravy: so I'm used to it

[21:53] <mrf> RabidGravy: Ah you meant the Patch?

[21:54] <RabidGravy> AlexDaniel, not idiomatic in my milieu

[21:55] <AlexDaniel> RabidGravy: http://www.perlmonks.org/?node_id=864019

[21:56] *** Begi1114 joined
[21:57] *** zakharyas left
[21:57] *** tokuhiro_ left
[21:57] <RabidGravy> I'm not quite sure that perlmonks proves anything

[21:58] <AlexDaniel> RabidGravy: no-no there's nothing to prove

[21:58] <RabidGravy> certainly against how *I* think about software design

[21:59] <mrf> I this issue multiple return values. rather than multiple return statements

[22:00] <RabidGravy> I spent a lot of the nineties working with very grumpy cobol programmers

[22:02] <mrf> RabidGravy: Having done some cobol I am sure that Grumpy is the normal state of being.

[22:03] *** ecocode left
[22:03] <mrf> hmm do I stay up and watch the Panthers game and work on these grammar tests some more or go to bed and do it tomorrow?

[22:04] <mrf> ugexe: wheen you were doing the grammar for URIs did you have the same sense of "This is nuts" that I do now.

[22:04] <RabidGravy> watch the game, drink beer and fiddle with code

[22:04] <mrf> RabidGravy: you make a convincing argument.

[22:05] *** ecocode joined
[22:06] <mrf> ugexe: also did you catch my comment a few days ago regarding using fully qualified namespaces in the HTTP gramars to avoid differning rule clashes?

[22:06] *** Zoffix left
[22:08] *** edehont joined
[22:14] *** TEttinger left
[22:16] *** Begi1114 left
[22:24] *** ghur joined
[22:26] *** lizmat joined
[22:26] <dalek> rakudo/nom: 360edeb | lizmat++ | / (4 files):

[22:26] <dalek> rakudo/nom: Make single key slices with 1 adverb 5% faster still

[22:26] <dalek> rakudo/nom: 

[22:26] <dalek> rakudo/nom: This basically reverts cfb7d876c0fe69c9a and does that logic inside

[22:26] <dalek> rakudo/nom: of each of the postcircumfix [] and {} candidates themselves.  This

[22:26] <dalek> rakudo/nom: saves on setting up parameters to SLICE_ONE_LIST/HASH

[22:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/360edeb408

[22:29] *** raiph joined
[22:30] <lizmat> messages

[22:30] <yoleaux> 20:27Z <AlexDaniel> lizmat: shell(«echo "world hello"»); # I wonder if this problem is associated with other “cannot unbox to a native string” problems.

[22:30] <yoleaux> 20:27Z <AlexDaniel> lizmat: not that it should work, but the error message is awful

[22:30] *** mayuresh joined
[22:30] <mayuresh> hello. :)

[22:30] <lizmat> mayuresh o/

[22:30] <mayuresh> :)

[22:30] <mayuresh> lizmat o/

[22:30] <lizmat> CurtisOvidPoe: re http://irclog.perlgeek.de/perl6/2015-10-25#i_11431620 , I was thinking

[22:31] <lizmat> would this syntax make sense:   while await @promises -> $promise {  # execute code when promise was kept }

[22:32] <mayuresh> there's something i need to share with you all publicly; "i am getting drawn towards another open source project and hence probably, i won't be able to work on that perl6 execution environment i have been so harking about for a while now".

[22:32] <mayuresh> out there to it's going to be a tough run, perhaps even tougher because i'll be working on compiler tech instead of interpreters.

[22:33] <mayuresh> but, there's a very high chance that i might effect a major change for the good of that open source project.

[22:33] <b2gills> mayuresh: you are free to come and go as you like, good look on whatever endeavor you choose

[22:33] <b2gills> s/look/luck/

[22:33] <mayuresh> :)

[22:34] <mayuresh> thanks b2gills. :)

[22:34] <lizmat> mayuresh: more power to you doing good things for open source!

[22:34] <mayuresh> thanks lizmat. :)

[22:35] <mayuresh> i am sorry mr. wall, and i thank you for the detailed responses to my queries.

[22:35] *** tokuhirom joined
[22:35] *** firstdayonthejob left
[22:35] <lizmat> on behalf of TimToady , you're very welcome!

[22:35] <mayuresh> hope perl6 (rakudo + moarvm) turns out to be greater than perl5.

[22:36] <mayuresh> gotta go now, need to catch up on some sleep, it's already 0400 hours out here, day begins shortly.

[22:36] *** mayuresh left
[22:37] *** firstdayonthejob joined
[22:37] <mrf> Is anyone able to explain the rational behind why rules have :sigspace but tokens don't

[22:38] <mst> RabidGravy: hm, multiple returns are totally normal to me

[22:38] *** rindolf left
[22:38] <mst> RabidGravy: ok, I mean, in a lot of my code it'd be one return and a bunch of die()s, but still

[22:40] *** tokuhirom left
[22:40] <RabidGravy> for me it's a sign a routine is too big but hey

[22:42] <b2gills> I use multiple exit points in shorter routines rather than longer routines, but I see your point.

[22:44] *** lsm-desktop left
[22:47] *** _dolmen_ joined
[22:48] *** patrickz left
[22:53] *** lichtkind_ left
[22:54] *** lichtkind left
[22:55] *** vendethiel left
[22:57] <mst> RabidGravy: er, multiple guard clauses in verification code are pretty common

[22:58] *** _dolmen_ left
[23:07] *** leont joined
[23:09] *** tokuhiro_ joined
[23:11] <dalek> rakudo/nom: c938b10 | lizmat++ | src/core/asyncops.pm:

[23:11] <dalek> rakudo/nom: Introducing the awaiterator

[23:11] <dalek> rakudo/nom: 

[23:11] <dalek> rakudo/nom: This now lets you process the result of a number of promises as they

[23:11] <dalek> rakudo/nom: become available.  For example:

[23:11] <dalek> rakudo/nom: 

[23:11] <dalek> rakudo/nom:   .print for awaiterator(^10 .map: { start { sleep rand; $_ } })

[23:11] <dalek> rakudo/nom:   6513729840

[23:11] <dalek> rakudo/nom: 

[23:11] <dalek> rakudo/nom: Inspired by CurtisOvidPoe's question earlier today.  Still subject to

[23:11] <dalek> rakudo/nom: bikeshedding / removal / other reasons why this is not a good idea

[23:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c938b10f9e

[23:13] *** tokuhiro_ left
[23:13] *** BenGoldberg joined
[23:17] <lizmat> .tell CurtisOvidPoe maybe the awaiterator is something for you ?

[23:17] <yoleaux> lizmat: I'll pass your message to CurtisOvidPoe.

[23:18] <Juerd> Love the awaiterator :)

[23:27] <edehont> Love the term bikeshedding as well :-)

[23:28] <mst> the destructive modification of @!todo in the elsif block really squicks me out

[23:28] *** ecocode left
[23:29] <lizmat> mst: why ?

[23:29] <lizmat> otherwise you would need 2 iterations

[23:29] *** rurban left
[23:29] <lizmat> one to grep all the ones that are done, then all the ones that need doing

[23:29] <lizmat> and in between things may change  

[23:30] <mst> no you wouldn't

[23:30] <lizmat> please enlighten me  :-)

[23:31] <mst> re-assigning @!todo seems ok, it's the '@!todo.shift' that makes me gibber

[23:31] <mst> seems like it'd work just the same as a foreach and be clearer too?

[23:32] <lizmat> yeah, but then I don't clean up @!todo: remove the ones that are ready

[23:32] <mst> yes you do

[23:32] <mst> you're assigning @!todo = @next anyway

[23:32] <mst> line 38

[23:33] <mst> @!todo is getting replaced entirely at the end of the loop

[23:33] <lizmat> yes, that's the next batch of todo's

[23:33] <mst> so mutating it during the loop isn't, so far as I can tell, relevant to the end result

[23:33] <lizmat> ah, ok, *now* I see your point

[23:33] <lizmat> ok, agree

[23:34] <lizmat> but a for would be another iterator...  hmmm... lemme do some benchmarks

[23:35] <zengargoyle> how about using classify on the promise list?

[23:35] <mst> if it turns out to be a useful micro-optimisation, I'd be totally ok with a comment saying that and leaving the code as is

[23:35] <zengargoyle> which i just suggested on CurtisOvidPoe's gist

[23:36] <lizmat> no, the for is faster

[23:36] <mst> awesome

[23:36] <mst> always nice when the prettier code is the fast version too :D

[23:37] <lizmat> mst++  # indeed!

[23:38] * lizmat looks up CurtisOvidPoe's gist

[23:40] <dalek> rakudo/nom: c017f78 | lizmat++ | src/core/asyncops.pm:

[23:40] <dalek> rakudo/nom: Make it simpler and faster, mst++

[23:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c017f7852b

[23:44] <zengargoyle> lizmat: can you maybe take a quick look and tell me why this little bit of test code doesn't work?  https://gist.github.com/zengargoyle/5324c93684d6f5a376a3

[23:44] *** firstdayonthejob left
[23:47] *** spider-mario left
[23:47] <lizmat> zengargoyle: looks to me the channel is almost immediately closed

[23:48] <zengargoyle> i don't think that matters, the longer code it comes from the channel isn't closed.

[23:48] <lizmat> so you're opening a Channel, sending 1 value on it, closing it and then looping until you get the value, right ?

[23:49] <zengargoyle> the second time the more * is hit, it's holding onto to old variables like the { code here ... } part didn't change.

[23:51] <zengargoyle> yes, but the second time through the for loop, the more still has the last $num/$value from the first time through the loop.

[23:51] *** dayangkun joined
[23:52] <zengargoyle> more still thinks $num and $value are 1 when they should both be 2

[23:53] <lizmat> indeed

[23:55] *** mordo joined
[23:55] <mst> lizmat: the only thing that's bugging me now is that you're iterating the entire set of todos every time and I wonder if short-circuiting might be better, but, er, dunno

[23:55] <lizmat> fwiw, the values are also wrong in the done block

[23:56] *** pmurias left
[23:56] <lizmat> the list of todo's is getting shorter every time pull-one is called (and there were no promises done yet)

[23:58] <lizmat> zengargoyle: feels like a scoping issue that should be rakudobugged

[23:58] <RabidGravy> right, bed time for rabid ;-) Play nicely

[23:58] <lizmat> gnight RabidGravy 

[23:59] <mrf> RabidGravy: Night. And thanks for the help earlier

[23:59] <zengargoyle> that's my take on it, but i'm new to the concurrent stuff and wanted second opinions :)

[23:59] <zengargoyle> i might just be doing it totally wrong.

