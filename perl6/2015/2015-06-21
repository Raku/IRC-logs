[00:01] *** yeltzooo joined
[00:04] *** Spot__ joined
[00:07] *** avuserow joined
[00:09] *** BenGoldberg joined
[00:10] *** fernando___ joined
[00:10] *** BenGoldberg_ joined
[00:11] *** Ben_Goldberg left
[00:13] *** BenGoldberg left
[00:20] *** sjn_phone_ left
[00:21] *** cognominal_ left
[00:24] *** psch joined
[00:27] *** nine joined
[00:30] *** [ptc]_ joined
[00:30] *** Spot___ joined
[00:30] *** bin_005_n joined
[00:31] *** raiph joined
[00:31] *** clkao_ joined
[00:32] *** ggherdov_ joined
[00:32] *** stevemc_ joined
[00:34] *** arnsholt joined
[00:34] *** zoosha joined
[00:36] *** Bucciarati_ joined
[00:36] *** psch_ left
[00:36] *** ggherdov left
[00:36] *** fernando___ left
[00:36] *** Spot__ left
[00:36] *** Al-Caveman left
[00:36] *** Khisanth left
[00:36] *** zoosha_ left
[00:36] *** ugexe left
[00:36] *** Bucciarati left
[00:36] *** steve_mc left
[00:36] *** skarn left
[00:36] *** Obbi left
[00:36] *** clkao left
[00:36] *** yogan left
[00:36] *** mephinet left
[00:36] *** arnsholt_ left
[00:36] *** hoelzro left
[00:36] *** [ptc] left
[00:36] *** nine_ left
[00:36] *** integral left
[00:36] *** pochi_ left
[00:36] *** bin_005 left
[00:36] *** flussence left
[00:36] *** Juerd left
[00:36] *** pochi joined
[00:36] *** [ptc]_ is now known as [ptc]

[00:38] *** Spot___ is now known as Spot__

[00:41] *** clkao_ is now known as clkao

[00:41] *** AlexDaniel is now known as 17WAB4TD9

[00:41] *** integral joined
[00:41] *** AlexDaniel joined
[00:41] *** hoelzro joined
[00:41] *** mephinet joined
[00:41] *** yogan joined
[00:41] *** fernando___ joined
[00:41] *** Khisanth joined
[00:41] *** flussenc1 joined
[00:41] *** Juerd joined
[00:41] *** Obbi joined
[00:42] *** fernando___ left
[00:42] *** fernando___ joined
[00:42] *** mephinet left
[00:42] *** mephinet joined
[00:42] *** raiph left
[00:43] *** Khisanth is now known as Guest11680

[00:44] *** perlpilot joined
[00:44] *** pmichaud_ joined
[00:44] *** krakan_ joined
[00:44] *** breinbaa1 joined
[00:44] *** orevdiabl joined
[00:44] *** jdv79_ joined
[00:44] *** leedo joined
[00:44] *** rudi_s_ joined
[00:45] *** Gothmog_1 joined
[00:45] *** smash_ joined
[00:45] *** nwc10_ joined
[00:45] *** grondilu joined
[00:45] *** rhr_ joined
[00:46] *** bobkare_ joined
[00:47] *** ugexe joined
[00:48] *** skarn joined
[00:49] *** tony-o_ joined
[00:50] *** gfldex_ left
[00:52] *** ggherdov_ is now known as ggherdov

[00:55] *** Al-Caveman joined
[00:55] *** silug_ joined
[00:55] *** profan left
[00:55] *** smash left
[00:55] *** PerlJam left
[00:55] *** pmichaud left
[00:55] *** silug left
[00:55] *** [Tux] left
[00:55] *** breinbaas left
[00:55] *** rhr left
[00:55] *** leedo_ left
[00:55] *** rudi_s left
[00:55] *** Gothmog_ left
[00:55] *** b2gills left
[00:55] *** Gothmog_1 is now known as Gothmog_

[00:55] *** jdv79 left
[00:55] *** [Tux] joined
[00:57] *** aborazmeh joined
[00:57] *** aborazmeh left
[00:57] *** aborazmeh joined
[00:57] *** 17WAB4TD9 left
[00:57] *** nwc10 left
[00:57] *** b2gills joined
[00:59] *** bobkare left
[00:59] *** bobkare_ is now known as bobkare

[01:00] *** kurahaupo joined
[01:16] *** kurahaupo left
[01:27] *** stevemc_ left
[01:46] *** Guest11680 left
[01:49] *** Khisanth joined
[02:09] *** yqt left
[02:15] *** aborazmeh left
[02:16] *** noganex_ joined
[02:20] *** noganex left
[02:36] *** Sqirrel left
[02:37] *** flussenc1 left
[02:37] *** flussence joined
[02:38] *** rmgk_ joined
[02:38] *** rmgk is now known as Guest33299

[02:38] *** rmgk_ is now known as rmgk

[02:42] *** Guest33299 left
[02:51] *** davido___ joined
[02:52] *** davido__ left
[03:08] *** CQ_ joined
[03:09] *** dj_goku joined
[03:11] *** CQ left
[03:11] *** CQ_ is now known as CQ

[03:14] *** dayangkun joined
[03:16] *** nys left
[03:30] *** kaare__ joined
[03:31] *** kaare__ is now known as kaare_

[03:51] *** tinyblak joined
[04:11] *** isBEKaml joined
[04:11] *** isBEKaml left
[04:17] *** dayangkun left
[04:24] *** bin_005_n left
[04:26] *** bin_005 joined
[04:30] *** rindolf joined
[04:31] *** bin_005_j joined
[04:32] *** bin_005 left
[04:42] *** bin_005_j left
[05:19] *** rindolf left
[05:23] *** skids joined
[05:30] *** spintronic left
[05:30] *** spintronic joined
[05:46] *** Psyche^ joined
[05:47] *** nwc10_ is now known as nwc10

[05:50] *** Psyche^_ left
[05:52] *** araujo joined
[05:57] *** aborazmeh joined
[05:57] *** aborazmeh left
[05:57] *** aborazmeh joined
[06:13] *** danaj joined
[06:15] *** BenGoldberg_ left
[06:31] <xinming> m:  loop (my $c = 0; $c < 3; $c++) { "hello".say; }     loop (my $c; $c < 3; $c++) { "test".say }

[06:31] <camelia> rakudo-moar be122a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/I8wd83MWbU␤Strange text after block (missing semicolon or comma?)␤at /tmp/I8wd83MWbU:1␤------> 3y $c = 0; $c < 3; $c++) { "hello".say; }7⏏5     loop (my $c; $c < 3; $c++) { "test"␤»

[06:31] <xinming> m:  loop (my $c = 0; $c < 3; $c++) { "hello".say; };     loop (my $c; $c < 3; $c++) { "test".say }

[06:31] <camelia> rakudo-moar be122a: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $c␤    at /tmp/zQGmzLFw0W:1␤    ------> 3 $c++) { "hello".say; };     loop (my $c7⏏5; $c < 3; $c++) { "test".say }␤hello␤hello␤hello␤»

[06:31] *** aborazmeh left
[06:32] <xinming> Is this a bug?  I mean, shouldn't the $c be visible within the loop only, instead of the whole block.

[06:32] <xinming> m:  loop ($c = 0; $c < 3; $c++) { "hello".say; };

[06:32] <camelia> rakudo-moar be122a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/AwVZMTxKem␤Variable '$c' is not declared␤at /tmp/AwVZMTxKem:1␤------> 3loop (7⏏5$c = 0; $c < 3; $c++) { "hello".say; };␤»

[06:32] <xinming> In synopsis, We have  the example without needing to decalre the $c, But that doesn't seem to work.

[06:33] *** aborazmeh joined
[06:33] *** aborazmeh left
[06:33] *** aborazmeh joined
[06:34] *** muethos joined
[06:45] <bartolin> xinming: we had that as a bug report the other day: RT #125434. it was rejected, because the current behaviour is expected. basically the lexical scope of $c in your example is the outer block. the bug report has a link to S04 which explains the details.

[06:45] <bartolin> https://rt.perl.org/Ticket/Display.html?id=125434

[06:46] <bartolin> xinming: you could also take a look at this discussion: http://irclog.perlgeek.de/perl6/2015-06-19#i_10774643

[06:48] <bartolin> m: loop (my $c = 0; $c < 3; $c++) { "hello".say; }; loop ($c = 0; $c < 3; $c++) { "test".say }

[06:48] <camelia> rakudo-moar be122a: OUTPUT«hello␤hello␤hello␤test␤test␤test␤»

[06:52] *** jasonmay1 is now known as jasonmay

[06:52] <xinming> bartolin: Ok, Thanks.

[06:52] <bartolin> your welcome

[06:53] <xinming> another question, Is it possible to extract the "method" (not sub) and return that method as a code?

[06:54] <bartolin> sorry, I don't know that

[06:55] <xinming> because something like  &self.method_name   result an error

[07:03] *** bin_005 joined
[07:17] *** muethos left
[07:34] <skids> m: Int.^find_method("abs").perl.say

[07:34] <camelia> rakudo-moar be122a: OUTPUT«method abs (Int:D $: *%_) { #`(Method|57858136) ... }␤»

[07:38] <skids> xinming: spec on the above comes with a caveat -- it is in S12, but I don't know if the hyphenation-versus-underscores reform will get into the MOP related functions or not.

[07:44] *** skids left
[07:50] *** aborazmeh left
[07:53] *** azawawi joined
[07:53] <azawawi> hi

[07:54] <azawawi> I am trying the script in https://github.com/MoarVM/MoarVM/issues/149

[07:54] <azawawi> 2015.06 fixed the 100% CPU behavior but now a CTRL-C does not cause any exit from die

[07:55] <azawawi> am i doing the wrong way or is there a new way to exit a script from a signal?

[07:56] *** mr-foobar joined
[07:58] *** telex left
[08:00] *** telex joined
[08:09] *** aborazmeh joined
[08:09] *** aborazmeh left
[08:09] *** aborazmeh joined
[08:11] *** azawawi left
[08:12] *** darutoko joined
[08:19] *** uncleyear left
[08:21] *** breinbaa1 left
[08:23] *** breinbaas joined
[08:23] *** breinbaas left
[08:24] *** breinbaas joined
[08:24] *** salva joined
[08:26] *** RabidGravy joined
[08:34] <dalek> rakudo/nom: 55498e2 | usev6++ | src/Perl6/Metamodel/MethodContainer.nqp:

[08:34] <dalek> rakudo/nom: Fix JVM build (avoid NullPointerException)

[08:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/55498e2c8c

[08:34] <dalek> rakudo/nom: 06e4e9a | lizmat++ | src/Perl6/Metamodel/MethodContainer.nqp:

[08:34] <dalek> rakudo/nom: Merge pull request #444 from usev6/jvm_build

[08:34] <dalek> rakudo/nom: 

[08:34] <dalek> rakudo/nom: Fix JVM build (avoid NullPointerException)

[08:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/06e4e9a5fe

[08:55] *** gfldex joined
[09:08] *** rindolf joined
[09:10] *** uncleyear joined
[09:10] <bartolin> star-m: BEGIN my %c; multi foo ($a where %c{$a}:exists) { say "cached " ~ %c{$a} }; multi foo ($a) { %c{$a} = $a; say $a }; for 1..10 { my $n = (1..10).pick; foo($n) }

[09:10] <camelia> star-m 2015.03: OUTPUT«5␤1␤cached 5␤6␤cached 6␤8␤4␤cached 4␤cached 6␤3␤»

[09:10] <bartolin> m: BEGIN my %c; multi foo ($a where %c{$a}:exists) { say "cached " ~ %c{$a} }; multi foo ($a) { %c{$a} = $a; say $a }; for 1..10 { my $n = (1..10).pick; foo($n) }

[09:10] <camelia> rakudo-moar 06e4e9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/2I7owAarne␤Invalid typename 'exists' in parameter declaration.␤at /tmp/2I7owAarne:1␤------> 3my %c; multi foo ($a where %c{$a}:exists7⏏5) { say "cached " ~ %c{$a} }; multi foo ␤»

[09:11] <bartolin> that looks like a fallout of jnthn's EXPR preclim fix

[09:12] <bartolin> the example is (adjusted) from integration/advent2012-day04.t, which we only execute as stresstest

[09:18] <bartolin> if it's expected to work I would rakudobug it and add a new test to roast (which is not marked as 'stress')

[09:20] *** tinyblak left
[09:21] <masak> good antenoon, #perl6

[09:22] <masak> bartolin: why `BEGIN my %c` and not just `my %c` -- what's the semantic difference between those two?

[09:23] <moritz> \o

[09:23] * masak is cursed these days with knowing a little too much about scoping rules

[09:23] *** muethos joined
[09:24] <moritz> mostly off-topic question: can somebody recommend literature on how to implement workflow systems in business applications?

[09:24] <masak> m: my %c; sub foo($a where %c{$a}:exists) {}

[09:24] <camelia> rakudo-moar 06e4e9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ZUwJ2FZQXc␤Invalid typename 'exists' in parameter declaration.␤at /tmp/ZUwJ2FZQXc:1␤------> 3my %c; sub foo($a where %c{$a}:exists7⏏5) {}␤»

[09:24] <bartolin> masak: hmm, I took that from the failing example roast

[09:25] <masak> bartolin: consider whether it's useless there too ;)

[09:25] <bartolin> masak: yeah, I'm considering it right now ;-)

[09:25] <moritz>  m: my %c; sub foo($a where  { %c{$a}:exists }) {}

[09:25] <camelia> rakudo-moar 06e4e9: ( no output )

[09:25] *** domidumont joined
[09:28] <masak> m: my %c; sub foo($a where (%c{$a}:exists) ) {}

[09:28] <camelia> rakudo-moar 06e4e9: ( no output )

[09:29] *** domidumont left
[09:30] *** domidumont joined
[09:42] *** muethos left
[09:45] *** aborazmeh left
[09:45] * masak wonders if "Perl 6 regex syntax" shouldn't be its own item in the list in http://c2.com/cgi/wiki?AlternativesToRegularExpressions

[09:49] *** spider-mario joined
[09:50] *** muethos joined
[09:55] *** setty1_ left
[10:01] <RabidGravy> Unless anyone can explain it, I'm calling this a bug:

[10:01] <RabidGravy> m: my enum Bar <A B C>; say B.value; say B.can("value")

[10:01] <camelia> rakudo-moar 06e4e9: OUTPUT«1␤Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/9JfnjneQzw:1␤␤»

[10:02] *** domidumont left
[10:03] *** brrt joined
[10:04] <lizmat> looks like bug, please report  :-)

[10:05] <dalek> roast: 0d91ae9 | usev6++ | integration/error-reporting.t:

[10:05] <dalek> roast: Add test for RT #123684

[10:05] <dalek> roast: review: https://github.com/perl6/roast/commit/0d91ae985b

[10:09] *** domidumont joined
[10:10] <xinming> What is the best way to loop over an array with   idx => $value    pair?

[10:11] <masak> m: my @array = foo => 1, bar => 2; for @array -> Pair (:$key, :$value) { say "$key ~~> $value" }

[10:11] <camelia> rakudo-moar 06e4e9: OUTPUT«foo ~~> 1␤bar ~~> 2␤»

[10:11] <masak> xinming: like that?

[10:11] <masak> the `Pair` is optional

[10:12] <masak> m: my @array = foo => 1, bar => 2; for @array -> (:$key, :$value) { say "$key ~~> $value" }

[10:12] <camelia> rakudo-moar 06e4e9: OUTPUT«foo ~~> 1␤bar ~~> 2␤»

[10:12] <masak> mostly there to show what's going on (unpacking).

[10:12] <xinming> masak: I mean something like   my @array = 'a' .. 'z';  for @array -> ($idx, $val) { ... }

[10:13] <xinming> I know we can use something like loop

[10:13] <xinming> loop (my $cnt = 0; $cnt < @array.elemns; $cnt++) {  my $val = @array[$cnt]; ... }

[10:14] *** AlexDaniel left
[10:14] *** AlexDaniel joined
[10:14] <masak> m: my @array = "a".."d"; for @array.pairs -> (:$key, :$value) { say "$key ~~> $value" }

[10:14] <camelia> rakudo-moar 06e4e9: OUTPUT«0 ~~> a␤1 ~~> b␤2 ~~> c␤3 ~~> d␤»

[10:14] <masak> that's how it'd do it, I think.

[10:14] <masak> m: my @array = "a".."d"; for @array.kv -> $key, $value { say "$key ~~> $value" }

[10:14] <camelia> rakudo-moar 06e4e9: OUTPUT«0 ~~> a␤1 ~~> b␤2 ~~> c␤3 ~~> d␤»

[10:14] <masak> also works.

[10:15] <masak> and is maybe even a bit more idiomatic, come to think of it.

[10:15] <masak> whoever decided that .kv should work on arrays: karma to you.

[10:15] <masak> probably TimToady++ :)

[10:16] <xinming> bbl.

[10:16] <xinming> I was thinking, What does (:key mean 

[10:16] <xinming> does  (:$key, :$value)

[10:16] <xinming> pointy sub

[10:16] <xinming> signature

[10:16] <xinming> I think I understand now

[10:17] <dalek> gtk-simple: dc8f299 | smls++ | lib/GTK/Simple.pm6:

[10:17] <dalek> gtk-simple: Set the main window title properly, instead of abusing argv[0]

[10:17] <dalek> gtk-simple: 

[10:17] <dalek> gtk-simple: gtk_init()'s argv parameter is meant to be hooked up to the program's

[10:17] <dalek> gtk-simple: command-line argument list, with the first arg being the program name

[10:17] <dalek> gtk-simple: itself. GTK uses this first arg as the default title for the main window,

[10:17] <dalek> gtk-simple: but strips all but the last path component so that running a GTK app as

[10:17] <dalek> gtk-simple: "/usr/bin/myapp --foo" uses "myapp" as the default title. This mechanism

[10:17] <dalek> gtk-simple: is thus unsuitable for implementing the :title adverb which is supposed to

[10:17] <dalek> gtk-simple: be able to set arbitrary titles:

[10:17] <dalek> gtk-simple:     GTK::Simple::App(title => "Enable / Disable")

[10:17] <dalek> gtk-simple: 

[10:17] <dalek> gtk-simple: This patch passes the program name as argv[0] like GTK expects, and then

[10:17] <dalek> gtk-simple: explicitly sets the main window title using gtk_window_set_title() if the

[10:17] <dalek> gtk-simple: :title adverb is specified.

[10:17] <dalek> gtk-simple: 

[10:17] <dalek> gtk-simple: This fixes #2

[10:17] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/dc8f299f84

[10:17] <xinming> pair return a  pair, with key => $key,

[10:18] <dalek> roast: 4d4c6a6 | usev6++ | integration/ (2 files):

[10:18] <dalek> roast: Move test for RT #123684 to integration/weird-errors.t

[10:18] <dalek> roast: review: https://github.com/perl6/roast/commit/4d4c6a6d9a

[10:18] <RabidGravy> lizmat, in as #125445 - I'll work around for the time being

[10:20] *** TEttinger joined
[10:21] *** tinyblak joined
[10:21] <TEttinger> is there an explanation somewhere of what ops are available? the rubyish example uses: my $hash := QAST::Op.new( :op<hash> );

[10:22] <TEttinger> and then pushes individual expressions onto that, but I have no idea what kind of expression it needs to make a usable hash

[10:22] <TEttinger> key-value pairs?

[10:22] <TEttinger> any pairs?

[10:22] <TEttinger> unpacked items, there just need to be an even number of them?

[10:22] <brrt> TEttinger: ehm, not sure, but we do have an oplist for MoarVM

[10:23] <brrt> and we auto-generate a node-types list for MAST from that

[10:23] <brrt> as far as nqp hashes goes

[10:23] *** muethos left
[10:24] <brrt> i believe you can do: $m := nqp::hash(); nqp::setkey($foo, $bar); 

[10:24] <brrt> but tbh i don''t use that often so wouldn't know

[10:24] <TEttinger> hm

[10:24] <TEttinger> I do wonder what :op<hash> even does

[10:25] <brrt> i'm fairly sure it creates a hash

[10:25] <TEttinger> oh, now you're just making things up :P

[10:26] <brrt> :-P

[10:26] *** tinyblak left
[10:26] <brrt> no, really

[10:27] <jnthn> :op<hash> (and thus nqp::hash) wants key, value, key, value... 

[10:27] <masak> m: my $foo = method { say "OH HAI {self}!" }; 42.$foo

[10:27] <camelia> rakudo-moar 06e4e9: OUTPUT«OH HAI 42!␤»

[10:30] <TEttinger> thanks brrt++, jnthn++

[10:31] <brrt> yw :-)

[10:40] *** RabidGravy left
[10:41] *** salva left
[10:44] *** xfix joined
[10:52] <dalek> rakudo/nom: 89e97f1 | lizmat++ | src/ (3 files):

[10:52] <dalek> rakudo/nom: Deprecate $*(PROGRAM|EXECUTABLE)_NAME

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/89e97f1caa

[10:53] *** rindolf left
[10:53] <dalek> roast: faddde7 | lizmat++ | S02-magicals/progname.t:

[10:53] <dalek> roast: Handle $*PROGRAM_NAME deprecation

[10:53] <dalek> roast: review: https://github.com/perl6/roast/commit/faddde73ec

[10:54] *** FROGGS[mobile] left
[10:55] <dalek> rakudo/nom: 6b1ffd6 | lizmat++ | docs/ChangeLog:

[10:55] <dalek> rakudo/nom: Mention $*(PROGRAM|EXECUTABLE)_NAME deprecation

[10:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b1ffd6391

[10:57] <lizmat> m: my $foo = -> $a { say "OH HAI $a!" }; 42.$foo

[10:57] <camelia> rakudo-moar 06e4e9: OUTPUT«OH HAI 42!␤»

[10:58] <dalek> roast: 5a73e11 | usev6++ | integration/advent2012-day04.t:

[10:58] <dalek> roast: Remove useless 'BEGIN', masak++

[10:58] <dalek> roast: review: https://github.com/perl6/roast/commit/5a73e114c1

[11:00] *** brrt left
[11:03] *** hahainte1net is now known as hahainternet

[11:13] <dalek> roast: f449c23 | lizmat++ | S02-types/deprecations.t:

[11:13] <dalek> roast: Test for $*(PROGRAM|EXECUTABLE)_NAME deprecation

[11:13] <dalek> roast: review: https://github.com/perl6/roast/commit/f449c23398

[11:16] <dalek> specs: fe8d383 | lizmat++ | S28-special-names.pod:

[11:16] <dalek> specs: Deprecate $*PROGRAM_NAME -> $*PROGRAM-NAME

[11:16] <dalek> specs: review: https://github.com/perl6/specs/commit/fe8d38304e

[11:23] *** lue joined
[11:23] *** ShimmerFairy left
[11:27] *** lue is now known as ShimmerFairy

[11:33] <TEttinger> so the NQP postcircumfix operators such as [ ] , and { } , they're implemented with something close to...    make QAST::Var.new( :scope('positional'), $<EXPR>.ast );

[11:34] <TEttinger> why don't they have any reference or something to the array or hash that's being indexed?

[11:36] <moritz> :scope('positional') ? I don't think I've seen that

[11:36] <moritz> in NQP, [] turns into nqp::atpos

[11:36] <TEttinger> it's only used in the postcircumfix [ ] as far as I can tell

[11:36] <moritz> in Perl 6, to a call to postcircumfix:<[ ]>()

[11:37] <vendethiel-> moritz: which in turn uses .AT-POS, right?

[11:37] *** colomon joined
[11:37] <TEttinger> https://github.com/perl6/nqp/blob/master/src/NQP/Actions.nqp#L1572

[11:37] <jnthn> :scope('positional') is mostly a little convenience, so we can use QAST::VarWithFallback

[11:38] <jnthn> As to "where's the array", it's unshifted higher up

[11:38] <jnthn> That's how method calls are compiled too; compile the call with args, and something higher up i the tree unshifts the invocant.

[11:39] <jnthn> Mostly falls out of the Perl 6-y view (reflected in its grammar) that [...] is just an interesting kind of postfix.

[11:39] <TEttinger> but what's higher up than postcircumfix<[ ]>   ?

[11:39] <TEttinger> I don't really get a lot of this yet

[11:39] <jnthn> I suspect that's called by postfixish, which is probably called by termish

[11:40] <TEttinger> it's starting to fall into place though

[11:40] <moritz> vendethiel-: right

[11:41] <TEttinger> really, I just want to implement named functions nth and get, but not operators for accessing those things, because it would be weird with lisp syntax

[11:41] <jnthn> ah no, I may be wrong...I think it may be EXPR (the operator precedence thing) that does the unshift in question

[11:41] <TEttinger> oh, that actually would make sense

[11:42] *** MueThoS joined
[11:43] *** rindolf joined
[11:43] *** itz__ joined
[11:44] *** cognominal joined
[11:44] *** MueThoS left
[11:45] *** itz_ left
[12:10] <masak> as much as I like TFD, I also feel mentally offloaded if I make a TODO-list to pick the next test from all the time.

[12:10] <masak> I wish I understood better why that is :)

[12:13] *** Zhtwn joined
[12:15] <Zhtwn> p6: my @foo = my $bar = 42, "str"; say $bar.perl

[12:15] <camelia> rakudo-moar 6b1ffd: OUTPUT«42␤»

[12:15] <Zhtwn> p6: my ( @baz, $quux ); @baz = $quux = 42, "str"; say $quux.perl

[12:15] <camelia> rakudo-moar 6b1ffd: OUTPUT«$(42, "str")␤»

[12:16] <Zhtwn> trying examples from Variables doc -- why does the "my" change the value in the assignment?

[12:17] <masak> I don't think it should.

[12:17] <Zhtwn> yeah, it surprised me a bit

[12:20] <moritz> m: my ( @baz, $quux ); @baz = ($quux = 42), "str"; say $quux.perl

[12:20] <camelia> rakudo-moar 6b1ffd: OUTPUT«42␤»

[12:21] <moritz> just a question of precedence

[12:21] <jnthn> Indeed; we don't parse the "=" in a "my $x = 42" as an infix, but rather as an initializer

[12:22] <masak> right, but shouldn't the `=` in `$quux = 42` have item assignment precedence?

[12:22] <masak> which is tighter than comma

[12:22] <masak> doesn't `=` essentially sit on two different prec levels?

[12:23] <masak> even without `my` or equivalent?

[12:23] <Zhtwn> that's the point being made in the Variables doc with this example: "Note that item assignment has tighter precedence than list assignment and also tighter than the comma."

[12:24] <masak> right.

[12:26] *** domidumont left
[12:26] <jnthn> Yes, = get be item assignment or list assignment prec level, determined by some rules

[12:26] <vendethiel-> masak: "=" for @ having a different precedence level using my has always been "surprising"

[12:26] <vendethiel-> it's certainly DWIMM

[12:26] <vendethiel-> it's certainly DWIMmy*

[12:29] <jnthn> If I had to guess what's going on, it's about the region of code (the dynamic scope of the parser, more concretely) that the decision is considering

[12:29] <jnthn> And with the my/initializer form it's more restricted

[12:29] <jnthn> (as in, analyzed at the level of the "my ... ="

[12:34] <Zhtwn> ah. tricky example to use in the Vars doc, then, I'd say.

[12:35] <Zhtwn> should I expand the doc to include the precedence trickiness? or should this example just be removed?

[12:38] <Zhtwn> or is this behavior that may change? I'd add a note about that, then

[12:44] *** Ven joined
[12:46] <vendethiel-> m: multi foo(Int) { say "hi"; }; EVAL "multi foo(Str) { say 'bai'; };"; my $a = "hey"; foo($a);

[12:46] <camelia> rakudo-moar 6b1ffd: OUTPUT«bai␤5===SORRY!5=== Error while compiling EVAL_0␤Missing block␤at EVAL_0:1␤------> 3multi foo(Str)7⏏5 True;␤    expecting any of:␤        new name to be defined␤»

[12:46] *** larion joined
[12:47] <vendethiel-> m: multi foo(Int) { say "hi"; }; EVAL "multi foo(Str) \{ say 'bai'; };"; my $a = "hey"; foo($a);

[12:47] <camelia> rakudo-moar 6b1ffd: OUTPUT«Cannot call foo(Str); none of these signatures match:␤    (Int)␤  in block <unit> at /tmp/a_tSwiYJqD:1␤␤»

[12:47] <masak> vendethiel-: nice try :)

[12:47] <vendethiel-> m: multi foo(Int) { say "hi"; }; EVAL "multi foo(Str) \{ say 'bai'; };"; my $a = True ?? "hey" !! 5; foo($a);

[12:47] <camelia> rakudo-moar 6b1ffd: OUTPUT«Cannot call foo(Str); none of these signatures match:␤    (Int)␤  in block <unit> at /tmp/iirEc5XhAZ:1␤␤»

[12:47] <masak> vendethiel-: but multi dispatch *is* rooted in static things.

[12:47] *** Ven left
[12:47] <vendethiel-> *g*

[12:48] <masak> vendethiel-: and EVAL has its own lexical scope, out of which you cannot lift a new multi declaration.

[12:48] *** Ven joined
[12:48] <masak> there's some nice thinking gone into that.

[12:48] <masak> or, put differently

[12:48] <vendethiel-> m: our multi foo(Int) { say "hi"; }; EVAL "our multi foo(Str) \{ say 'bai'; };"; say "alive"; my $a = True ?? "hey" !! 5; foo($a);

[12:48] <camelia> rakudo-moar 6b1ffd: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jh9fXLyQcf␤Cannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead␤at /tmp/jh9fXLyQcf:1␤------> 3our multi foo(Int) { say "hi"; }7⏏5; EVAL "our multi foo(Str) \{…»

[12:48] <masak> LONG LIVE LEXICAL SCOPING

[12:48] <Ven> hehe

[12:52] *** smls joined
[12:53] <smls> Zhtwn, masak, jnthn: I reported #125416 a few days ago about that item assignment bug (or WAT)

[12:53] *** BenGoldberg_ joined
[12:55] <jnthn> Not convinced it's a bug, or at least I'd like to see one of (a) a case where the design docs suggest we're doing it wrong, or (b) evidence STD is getting a different answer in the parse than Rakudo

[12:56] <smls> jnthn: What about the test cases in the bug report?

[12:56] <smls> Don't you think it's weird to parse   1, my $x = 2, 3   as item assignment but   Int(1), my $x = 2, 3    as list assignment?

[12:57] <smls> Also, shouldn't a   my $x  LHS always parse the = with tighter precedence than comma?

[12:58] *** bin_005 left
[12:58] <jnthn> Something looks odd in that example, at lesat.

[12:58] <jnthn> Though it's probably also explainable

[12:58] <jnthn> ah..hmm

[12:59] <jnthn> There is a discrepancy with STD

[12:59] <jnthn> That may explain it

[13:00] <jnthn> token declarator re-declares it

[13:01] * jnthn adds that to see if it changes things

[13:01] *** tinita_ is now known as tinita

[13:02] <jnthn> aha, yes

[13:02] <jnthn> That un-WATs the ticket case

[13:02] *** tinyblak joined
[13:02] *** flussenc1 joined
[13:02] *** pmichaud joined
[13:02] <jnthn> I thought we already had that...odd

[13:02] *** Psyche^_ joined
[13:02] *** integral_ joined
[13:02] *** integral_ left
[13:02] *** integral_ joined
[13:03] *** smls left
[13:03] <jnthn> Lemme see what this does to spectest...

[13:03] *** darutoko- joined
[13:03] *** Gothmog_1 joined
[13:04] *** rudi_s joined
[13:05] *** Juerd_ joined
[13:05] *** hoelzro_ joined
[13:05] *** Obbi_ joined
[13:05] *** uncleyea1 joined
[13:06] <jnthn> m: use Test; sub x(*@x) { +@x }; is x(1.Int, my $x = 2, 3), 3;

[13:06] <camelia> rakudo-moar 6b1ffd: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/KZowN4b7Yf line 1␤# expected: '3'␤#      got: '2'␤»

[13:07] *** fernando____ joined
[13:07] *** fernando____ left
[13:07] *** fernando____ joined
[13:07] *** smash joined
[13:07] *** skarn_ joined
[13:08] *** uncleyear left
[13:08] *** darutoko left
[13:08] *** Psyche^ left
[13:08] *** flussence left
[13:08] *** skarn left
[13:08] *** ugexe left
[13:08] *** smash_ left
[13:08] *** Gothmog_ left
[13:08] *** rudi_s_ left
[13:08] *** pmichaud_ left
[13:08] *** integral left
[13:08] *** hoelzro left
[13:08] *** mephinet left
[13:08] *** yogan left
[13:08] *** fernando___ left
[13:08] *** Juerd left
[13:08] *** Obbi left
[13:08] *** Gothmog_1 is now known as Gothmog_

[13:08] *** Juerd_ is now known as Juerd

[13:09] *** kaare_ left
[13:10] *** smls joined
[13:11] <bartolin> m: sub foo ($w) { }; foo :w(3) # trying to set positional parameter via named argument

[13:11] <camelia> rakudo-moar 6b1ffd: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub foo at /tmp/olcVBPAaVu:1␤  in block <unit> at /tmp/olcVBPAaVu:1␤␤»

[13:12] <bartolin> ^^ I was unable to find an open ticket for this. it seems like it has worked in the past ...

[13:12] *** mephinet joined
[13:13] <Ven> bartolin: I think that was deprecated/removed quite some time ago...

[13:13] *** yogan joined
[13:13] *** uncleyea1 is now known as uncleyear

[13:13] <dalek> rakudo/nom: 8276cee | jnthn++ | src/Perl6/Grammar.nqp:

[13:13] <dalek> rakudo/nom: Fix assignment precedence analysis leak.

[13:13] <dalek> rakudo/nom: 

[13:13] <dalek> rakudo/nom: Per STD, we should have a fresh $*LEFTSIGIL per declarator. Fixes

[13:13] <dalek> rakudo/nom: RT #125416.

[13:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8276cee542

[13:13] *** uncleyear left
[13:13] *** uncleyear joined
[13:13] <bartolin> Ven: Oh! It looks there are some fudged tests which rely on it.

[13:14] <dalek> roast: a1edc2d | jnthn++ | S03-operators/assign.t:

[13:14] <dalek> roast: Test to cover RT #125416.

[13:14] <dalek> roast: review: https://github.com/perl6/roast/commit/a1edc2dd5b

[13:14] <jnthn> bartolin, Ven: Yeah, that feature went away.

[13:15] <smls> jnthn: Another case:   @foo = $bar = 5, 10;   parses both = as list assignments, but   my @foo = $bar = 5, 10;   parses the 2nd one as item assignment

[13:16] *** ugexex joined
[13:16] *** fernando____ is now known as fernando___

[13:16] <bartolin> Ven, jnthn: thanks a lot. it looks like it's still mentioned in S06 ...

[13:16] <smls> S03 suggests that the determinaing factor for = precedence is "whether the left side is a list or a scalar destination"

[13:16] <bartolin> anyway, I'll adjust those tests, then

[13:17] <jnthn> smls: I don't *think* that difference is out of line with how the standard grammar does it...

[13:17] <smls> so if it identified $bar as the destination, shouldn't it automatically use item assignment?

[13:18] *** ilbelkyr_ joined
[13:18] *** amurf_ joined
[13:18] *** ilbelkyr left
[13:18] *** ilbelkyr_ is now known as ilbelkyr

[13:19] <smls> OTOH if it considered the whole of   (@foo = $bar)   as the destination, as in    (@foo = $bar) = 5, 10;   then it should do list assignment, but in that case $bar should not be filled at all

[13:19] *** ribasushi left
[13:19] <jnthn> smls: We only get a fresh $*LEFTSIGIL per call to EXPR or declarator

[13:20] *** amurf left
[13:20] *** petercommand left
[13:20] <smls> Well, I'm arguing more from spec and DWIM here

[13:20] *** jasonmay left
[13:20] *** cosimo_ left
[13:20] *** Blub\0 left
[13:20] *** captain-adequate left
[13:20] *** xinming left
[13:20] *** ponbiki left
[13:21] *** moritz left
[13:21] *** Possum left
[13:21] *** agentzh left
[13:21] <jnthn> s/spec/design docs/

[13:21] *** pecastro left
[13:21] *** lestrrat left
[13:21] *** bartolin left
[13:21] <smls> right

[13:21] <smls> though STD is not infallible either, is it? :P

[13:22] *** petercommand joined
[13:22] <jnthn> Certainly not, as I've discovered recently

[13:22] <smls> It just seems strange (and not supported by the design docs) to identify a  $foo  as the destination, but then parse the RHS like list assignment.

[13:22] *** ponbiki joined
[13:22] *** captain-adequate joined
[13:22] *** cosimo joined
[13:22] *** bartolin joined
[13:22] *** jasonmay joined
[13:22] <jnthn> The mechanism isn't really about identifying destination, is the thing.

[13:22] *** ponbiki is now known as Guest84975

[13:22] *** Possum joined
[13:22] *** xinming joined
[13:22] *** pecastro joined
[13:23] <jnthn> It's about "does $*LEFTSIGIL end up containing '$'"

[13:23] <jnthn> The one I just fixed was because we failed to have a fresh one of those per declarator.

[13:23] <jnthn> We do have one per EXPR.

[13:23] *** Blub\0 joined
[13:25] <jnthn> iiuc, @foo = $bar = 5, 10; sees an @ first, sets that into $*LEFTSIGIL for the current EXPR, and then the $ from bar never updates it

[13:26] *** aborazmeh joined
[13:26] *** aborazmeh left
[13:26] *** aborazmeh joined
[13:26] *** ribasushi joined
[13:26] *** smls left
[13:27] <jnthn> But in "@foo = my $bar = 5, 10;" we get $*LEFTSIGIL set for unconditionally by the "my" declarator. The bug I just fixed was that token declarator was missing a fresh declaration of $*LEFTSIGIL

[13:27] *** smls joined
[13:27] *** smls left
[13:27] <jnthn> So anyway, that's why we get things the way we do, as far as I can tell

[13:28] *** smls joined
[13:28] *** moritz joined
[13:28] *** agentzh joined
[13:28] *** agentzh left
[13:28] *** agentzh joined
[13:29] *** lestrrat joined
[13:29] <smls> TimToady will know more :)

[13:29] <jnthn> Aye

[13:29] <jnthn> Anyway, now I understand why what's happening is happening, and after going through STD I think it must get the same answers.

[13:30] *** aborazmeh left
[13:31] <jnthn> I don't have any idea right now (a) if it's desirable to handle this differently, 'cus it'll almost certainly mean complicating the rules, and (b) how I'd make such a change to try it out

[13:31] <jnthn> Right now the rule is "first sigil we encounter in an expression or in a declarator decides it"

[13:32] <jnthn> Which is easy enough to explain and remember.

[13:32] <jnthn> And will DWIM in enough cases.

[13:33] <Zhtwn> ...for programmers that think like parsers... ;-)

[13:33] <smls> well, it's easy enough to remember when you think about expressions from a STD/Rakudo grammar perspective

[13:33] <jnthn> Zhtwn: Those who don't will probably not write such complex expressions :P

[13:34] *** xfix left
[13:34] <jnthn> Heck, I do know about parsers and I'd tend not subject folks reading my code to such things. :P

[13:35] <Zhtwn> jnthn: true. That's a good argument for removing this example from the Variables doc, eh?

[13:35] <Zhtwn> or maybe putting a "it's neat, but be careful" warning?

[13:36] <jnthn> Zhtwn: I think it's worth the docs containing an example of where you might get caught out

[13:36] <Zhtwn> ok, I'll get on that

[13:36] <jnthn> I think the "decided by first sigil seen in an expression or declarator" isn't a bad summary.

[13:36] <smls> jnthn: Well, the testcase from my bugreport was golfed down from a GTK::Simple program where I had something like    set_contents( ..Label.new(), my $box = ..Box.new( ...  ), ...)   

[13:36] <jnthn> If illustrated with examples

[13:36] <jnthn> smls: Yeah, that one should be dealt with now

[13:37] <smls> ok

[13:37] <jnthn> That was due to us not declaring a fresh $*LEFTSIGIL per declarator.

[13:38] <jnthn> So the postfix in the previous thingy before the , wrongly influenced the decision.

[13:39] *** Zhtwn left
[13:39] <smls> but without the "my" it would still influence it?

[13:39] <jnthn> smls: Indeed

[13:40] <jnthn> Or at least, so far as I can follow the intent of STD

[13:40] <jnthn> I think at this point, though, will have to defer to TimToady++.

[13:41] <jnthn> It's possible I'm missing something, but it seems doing anything different here would be a non-trivial change....

[13:41] <dalek> roast: a9f6adf | usev6++ | S06-signature/named-parameters.t:

[13:41] <dalek> roast: Adjust tests which tried to set

[13:41] <dalek> roast: positional parameters via named arguments.

[13:41] <dalek> roast: 

[13:41] <dalek> roast: That feature is no more.

[13:41] <dalek> roast: review: https://github.com/perl6/roast/commit/a9f6adf01a

[13:42] *** nys joined
[13:47] <moritz> http://martinfowler.com/articles/enterpriseREST.html "Some people, when confronted with a problem, think "I know, I'll use versioning." Now they have 2.1.0 problems." :-)

[13:50] *** smls left
[13:51] *** petercommand left
[13:51] *** petercommand joined
[13:52] *** RabidGravy joined
[13:52] *** zakharyas joined
[14:01] *** smls joined
[14:02] <smls> japhb: ping

[14:02] *** tinyblak left
[14:03] <RabidGravy> boom!

[14:07] *** muethos joined
[14:08] <dalek> specs: f01cb30 | usev6++ | S06-routines.pod:

[14:08] <dalek> specs: [S06] remove fossil

[14:08] <dalek> specs: 

[14:08] <dalek> specs: this complements 25eb879f36: we no longer map named

[14:08] <dalek> specs: arguments to positional parameters.

[14:08] <dalek> specs: review: https://github.com/perl6/specs/commit/f01cb3091e

[14:09] <bartolin> ^^ could someone please look at that commit and check if it's sane?

[14:10] <xinming> How do we compile the perl6 code to moarvm byte code please?

[14:10] <xinming> Just curious on how the they are built.

[14:11] <moritz> in stages

[14:12] <moritz> parse it, AST, MAST, bytecode

[14:14] <xinming> I'm reading the compiler-overview.pod

[14:15] <xinming> I just try to compile a simple perl6 script myself, to see what how they are built.

[14:15] *** kaare_ joined
[14:17] *** isBEKaml joined
[14:18] *** Humbedooh joined
[14:18] *** silug_ left
[14:21] *** cognominal left
[14:21] <moritz> --target=ast might be instructive

[14:21] <moritz> ./perl6-m --target=ast -e 'my $x = 42; say $x'

[14:22] <moritz> then --target=mast

[14:22] <geekosaur> I think the question is not so much stages as just how one generates the bytecode normally?

[14:24] <xinming> geekosaur: Both.

[14:24] <xinming> :-)

[14:24] <xinming> I also want to see the parsing result for each stage.

[14:25] <moritz> nqp/src/vm/moar/QAST/QASTCompilerMAST.nqp for the MAST->bytecode step, I believe

[14:25] <moritz> lots of grunt work

[14:25] <moritz> ah wait, that's QAST -> MAST

[14:26] <ugexex> Perl6::Grammar.parse($source-code, :actions(Perl6::ACtions.new()).ast.say ?

[14:26] <moritz> ugexex: no, perl6-m --target=ast $programfile

[14:26] *** JimmyZ_ joined
[14:27] <moritz> you need a bit more work

[14:27] <moritz> set a Perl6::World instance in $*W, for example

[14:32] *** silug_ joined
[14:33] <ugexex> ah

[14:33] <ugexex> m:  m: use nqp; use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; my $*LINEPOSCACHE; my $x = Perl6::Grammar.parse("say 1;", :actions(Perl6::Actions.new())); say $x.ast.^name;

[14:33] <camelia> rakudo-moar 8276ce: OUTPUT«QAST::CompUnit␤»

[14:33] *** tinyblak joined
[14:34] <ugexex> m:  m: use nqp; use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; my $*LINEPOSCACHE; my $x = Perl6::Grammar.parse("say 1;", :actions(Perl6::Actions.new())); say $x.ast.dump;

[14:34] <camelia> rakudo-moar 8276ce: OUTPUT«- QAST::CompUnit␤  - QAST::Block say 1;␤    - QAST::Var(local __args__ :decl(param))␤    - QAST::Stmts ␤    - QAST::Op(call)␤      - QAST::Block␤        - QAST::Stmts ␤          - QAST::Var(lexical $! :decl(contvar))␤          - QAST::Var(l…»

[14:35] *** Ven left
[14:37] <xinming> Is there an easy way to dump to moarvm bytecode?

[14:38] *** tinyblak left
[14:39] <jnthn> If you get a MoarVM bytecode file with "--target=mbc --output=foo.moarvm", then you can "moar --dump foo.moarvm"

[14:40] <xinming> I saw that using panda will generate the .moarvm files for pm files.

[14:40] <ugexex> panda is literally doing what moritz posted, except --target=mbc

[14:42] <ugexex> just add a --output="somefile.moarvm" 

[14:42] <xinming> Cannot dump this object; no dump method

[14:42] <xinming> I got that error

[14:43] <xinming> with command perl6-m --target=mbc  -e 'my $x = 42; say $x'  --output=hahahaha.moarvm

[14:44] <ugexex> perl6-m --target=mbc --output="what.moarvm"  -e 'my $x = 42; say $x'

[14:44] *** ugexex is now known as ugexe

[14:46] *** JimmyZ_ left
[14:46] *** JimmyZ_ joined
[14:46] <xinming> Ok, got it.

[14:46] <xinming> thanks

[14:48] <moritz> options after the -e are passed to the perl6 programm in -e, and aren't interpreted by the compiler

[14:49] *** _mg_ joined
[14:49] <xinming> Ok, Thanks, I didn't realize that.

[14:51] <mst> moritz: what

[14:51] <mst> that should require a -- first :(

[14:53] <xinming> Unhandled exception: While looking for 'ModuleLoader.moarvm': no such file or directory      When I try to call full-cleanup or run the dumped .moarvm file, I'll get that error.

[14:54] <xinming> mst: Glad to see you are here.  Do you have a plan to create Catalyst6 for perl6? :-)

[14:56] <mst> xinming: highly unlikely, my first perl6 project is probably going to be carton-for-panda

[14:57] <mst> and that's mostly because I want access to the grammar engine

[14:57] <mst> the rest of the language doesn't scratch any itches I currently have

[14:58] <mst> mostly because with Moo(se) perl5's stolen the thing I liked the best :D

[14:58] <TEttinger> mst: are you the shadowcat mst person who implemented wat for perl?

[14:59] <TEttinger> wat's an interesting thing

[14:59] <mst> yes, I am

[14:59] <mst> I like operative lisps

[14:59] <TEttinger> I'm having a fun time learning perl 6 at the same time I implement a lisp in perl 6

[15:00] <xinming> Moose is great, After I get used to Moose, It made me feel really natural to use the OO in perl6.

[15:00] <mst> but I've ended up with an operative prolog derivative instead

[15:00] <TEttinger> I don't really understand the stuff that makes f-exprs special though

[15:00] <TEttinger> I don't exactly know what fexprs really are yet

[15:01] <TEttinger> I attempted to read the kernel spec, did not help too much :)

[15:01] <mst> the way the wat prologue builds things with vau might help

[15:02] <mst> have you done any macro heavy lisp previously?

[15:02] <TEttinger> oh god no

[15:02] <mst> ...

[15:02] <TEttinger> although the first macro I wrote was a macro writing macro in clojure

[15:02] <mst> you shouldn't be scared of that, macros are half the fun

[15:02] <mst> exprs are an even more general case

[15:03] <mst> an unhygienic macro is merely a restricted fexpr

[15:03] <TEttinger> yeah I mean, I've implemented macroexpansion in my lisp before it used perl6 as a toolchain (before, I did a lot more on my own and generated really weird looking lua)

[15:04] <mst> I found Wat really useful for prototyping the DX solver (my prolog derivative)

[15:04] <mst> but the production implementation is in highly-functional Moo code

[15:05] <mst> I may re-introduce wat-style stuff later though

[15:05] <TEttinger> so are fexprs a compile-time thing like macros? can they be either compile-time or run-time?

[15:06] <mst> fexpr eliminate the distinction.

[15:06] <TEttinger> would it be worth it for me to try to implement macros in my lisp by using fexprs?

[15:07] <TEttinger> hm

[15:07] <mst> uh, there's some performance disadvantages of a naive fexpr based implementation

[15:07] <mst> they're not actually difficult to fix though

[15:08] <TEttinger> yeah, and I would need to expand any compile-time stuff when I hand off the runtime-only QAST to the backend as if it is a perl 6 QAST

[15:08] <mst> fexprs are a runtime construct

[15:08] <TEttinger> (I'm using the same toolchain as perl6, which means producing an AST of only runtime stuff)

[15:08] <TEttinger> ok

[15:09] <mst> baaasically, in an fexprs based system, a macro is an fexpr that only uses the local environment at the end, to apply a predictable transform of the source sexprs into expanded sexprs

[15:09] <TEttinger> so I'm guessing fexprs get around the old problem that shows up at least in clojure, where you can't pass the value of a macro at runtime, like passing `and` as an argument to `reduce` ?

[15:10] <mst> the way you optimise fexprs is to cache that

[15:10] <mst> macro expansion in a normal lisp is effectively 'expanding macro-like fexprs eagerly in a compilation pass'

[15:10] *** zakharyas left
[15:11] <mst> and, yes, fexprs pass as arguments fine, though in -most- cases you probably didn't want to do that

[15:13] *** _mg_ left
[15:13] <nine> Oh how I like this :) > perl6 -Ilib -e 'use Data::Dumper:from<Perl5>; class MyDumper is Data::Dumper { }; my $dumper = MyDumper.new([1]); say $dumper.Dump();'

[15:13] <nine> $VAR1 = 1;

[15:13] <mst> :D

[15:14] <TEttinger> nice

[15:14] * mst hopes one day somebody will use that to do 'use DX::Endjinn:from<Perl5>;' :)

[15:14] <nine> 68 lines of patch so one doesn't need Perl5Parent anymore for subclassing Perl 5 classes in Perl 6 :)

[15:14] *** muethos left
[15:14] <mst> possibly me, depending

[15:14] *** _mg_ joined
[15:14] <TEttinger> magical, nine.

[15:14] <mst> nine: yay

[15:15] <mst> nine: wonder if you could write a MooseX::Rakudo or something to do the converse

[15:15] <mst> nine: I guess MooseX::InsideOut plus MooseX::NonMoose might Just Work, actually

[15:16] <nine> The only problem I see is, that I actually do not have much content for a talk about this anymore. All you need to know is: "install Inline::Perl5, then use Foo:from<Perl5>;". Then there's not much difference anymore between using a Perl 5 or a Perl 6 module.

[15:16] <mst> *snrk*

[15:17] <mst> nine: do a talk on writing resultset classes in perl6 :)

[15:17] <TimToady> jnthn: just have a moment, haven't really backlogged yet, but it occurs to me that the correct way to run the precedence limiter is to base it off of the left vs right associativity of the prec level in question, whether it includes the level itself or not

[15:17] <yoleaux> 20 Jun 2015 10:16Z <jnthn> TimToady: While that helps the colon pair case, we run into problems with pairs, as in "my $a = 'foo' => 'bar'", because those are %item_assignment too. Also chained assignments to declarators seem to go wrong (e.g. my $a = $b = 2).

[15:17] <yoleaux> 20 Jun 2015 10:58Z <jnthn> TimToady: I ended up doing https://github.com/rakudo/rakudo/commit/9ed8577888 which I suspect you'll want to review; as far as I can tell, STD is wrong for ages on these things and we never noticed.

[15:17] * TimToady notest that = and => are right associative, so should Just Work if we do that

[15:17] <TimToady> *notes

[15:17] <nine> mst: I probably will do an example on that, yes. Seems like the most common use case for having Perl 6 code inlined in a Perl 5 module.

[15:18] * mst is really looking forward to playing with reversible parsers

[15:19] * mst looks sadly at the pile of preceding yaks

[15:19] <JimmyZ_> use mojo:from<perl5>; then we have a productive web framework for perl6 now.

[15:19] <JimmyZ_> 😊

[15:19] <mst> huh

[15:19] <mst> xinming: actually, I might port Web::Simple for a laugh

[15:19] <nine> JimmyZ_: please give it a try :)

[15:20] <BenGoldberg_> So, should we now do 'use DBI:from<Perl5>' instead of DBIish?

[15:20] *** BenGoldberg_ is now known as BenGoldberg

[15:20] <mst> that doesn't seem like a question with an answer.

[15:22] *** domidumont joined
[15:23] <nine> BenGoldberg: if DBIish's limitations prevent you from using Perl 6 for something useful, please use DBI:from<Perl5>. Worst case for Perl 6 is that your application is a good testcase for an updated DBIish

[15:25] *** kaare_ left
[15:25] *** kaare_ joined
[15:28] <nine> BenGoldberg: or better yet, do use DBIx::Class:from<Perl5>. There are not many reasons for using plain DBI ;)

[15:31] <smls> TimToady: Did the GLR design that you and pmichaud were discussing, reach a conclusion? Or is it on hold again?

[15:31] <BenGoldberg> Good point, although what I was actually thinking of was that there (presently) are more perl5 database driver backends than perl6 ones...

[15:33] *** tinyblak joined
[15:35] <BenGoldberg> Maybe the sensible thing would be to add a fallback, within DBIish, so that if someone tries to connect to a database type it's unaware of, it will try to load the appropriate perl5 DBD::<whatever> module, and give back an appropriately wrapped instance.

[15:37] <BenGoldberg> So if a user wants to use an oracle database, for example, they don't have to think about whether or not there is a 'real' perl6 binding for it (yet), DBIish will "just" work.

[15:37] <mst> BenGoldberg: well volunteered :D

[15:55] *** spider-mario left
[15:57] *** tinyblak left
[16:09] <xinming> m: class A { method t (Int @a, Int @b) { @a.perl.say; @b.perl.say; } }    A.new.t((1,2), (2,3));

[16:10] <camelia> rakudo-moar 8276ce: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xUoqKCBeYI␤Strange text after block (missing semicolon or comma?)␤at /tmp/xUoqKCBeYI:1␤------> 3 Int @b) { @a.perl.say; @b.perl.say; } }7⏏5    A.new.t((1,2), (2,3));␤    expecting any of:␤      …»

[16:10] <xinming> m: class A { method t (Int @a, Int @b) { @a.perl.say; @b.perl.say; } };    A.new.t((1,2), (2,3));

[16:10] <camelia> rakudo-moar 8276ce: OUTPUT«Type check failed in binding @a; expected 'Positional[Int]' but got 'Parcel'␤  in method t at /tmp/xc0Ylze_fj:1␤  in block <unit> at /tmp/xc0Ylze_fj:1␤␤»

[16:10] <xinming> Good, How do we pass an "array" to specified array please?

[16:11] <xinming> I tried with ((1,2), (2,3))    

[16:11] <xinming> also with ([1,2], [2,3])

[16:11] <xinming> neither worked.

[16:12] <moritz> that's jsut Arrays, not Array[Int]

[16:12] <xinming> Yes, But two arrays in arg won't, work, right?

[16:13] <moritz> m: m: class A { method t (Int @a, Int @b) { @a.perl.say;  b.perl.say; } }; A.new.t(Array[Int].new(1, 2), Array[Int].new(3))

[16:13] <camelia> rakudo-moar 8276ce: OUTPUT«5===SORRY!5=== Error while compiling /tmp/FWI81QxPQW␤Undeclared routine:␤    b used at line 1␤␤»

[16:13] <moritz> m: m: class A { method t (Int @a, Int @b) { @a.perl.say;  @b.perl.say; } }; A.new.t(Array[Int].new(1, 2), Array[Int].new(3))

[16:13] <camelia> rakudo-moar 8276ce: OUTPUT«Array[Int].new(1, 2)␤Array[Int].new(3)␤»

[16:13] *** tinyblak joined
[16:13] <xinming> Thanks, though, a bit confused.

[16:13] *** tinyblak left
[16:14] <xinming> will Array[Int](@old_array)  work?

[16:14] <xinming> Let me try

[16:14] <xinming> worked.

[16:15] <xinming> m: class A { method t (Int @a, Int @b) { @a.perl.say; @b.perl.say; } };    A.new.t(Array[Int](1,2), Array[Int](2,3));

[16:15] <camelia> rakudo-moar 8276ce: OUTPUT«Array[Int].new(1, 2)␤Array[Int].new(2, 3)␤»

[16:15] <xinming> Thanks

[16:16] *** tinyblak joined
[16:17] *** uncleyea1 joined
[16:19] *** uncleyear left
[16:20] <moritz> m: class A { method t (Int @a, Int @b) { @a.perl.say; @b.perl.say; } }; A.new.t( (my Int @ = 1, 2, 3), (my Int @ = 4, 5, 6));

[16:20] <camelia> rakudo-moar 8276ce: OUTPUT«Array[Int].new(1, 2, 3)␤Array[Int].new(4, 5, 6)␤»

[16:24] *** molaf joined
[16:26] *** Bucciarati_ is now known as Bucciarati

[16:28] <smls> Is there someone besides japhb who understands perl6-bench?

[16:28] <smls> I want to test a new benchmark I added in a local git clone

[16:28] <smls> preferably, using the r-m and p5 already installed in my system

[16:29] <smls> But whatever I tell ./bench, either tries to download and build dozens of compiler/version combinations, or does seemingly nothing at all.

[16:31] *** isBEKaml left
[16:33] *** Ven joined
[16:34] *** cognominal joined
[16:47] *** zakharyas joined
[16:47] <xinming> m: class X { has $.val; }; class T { has X @.array; method init () { for @!array.kv -> $k, $v { @!array[$k].val($k); }; @!array.perl.say; } };  my @x = (1..5).map: { X.new }; T.new(array => @x).init;

[16:47] <camelia> rakudo-moar 8276ce: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method init at /tmp/PDZvRQUUKF:1␤  in block <unit> at /tmp/PDZvRQUUKF:1␤␤»

[16:47] <xinming> Is this a bug?

[16:48] *** molaf left
[16:48] <xinming> the @!array[$k].val($k) thing.

[16:48] *** molaf joined
[16:48] <xinming> I tried to make $.val is rw. But still the error.

[16:49] <moritz> don't name classes X, because it hides the X:: namespace in which most exceptions live

[16:49] <moritz> maybe you get a wrongly reported error that way

[16:50] <xinming> m: class YY { has $.val; }; class T { has YY @.array; method init () { for @!array.kv -> $k, $v { @!array[$k].val($k); }; @!array.perl.say; } };  my @x = (1..5).map: { YY.new }; T.new(array => @x).init;

[16:50] <camelia> rakudo-moar 8276ce: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method init at /tmp/SgebKf8LsW:1␤  in block <unit> at /tmp/SgebKf8LsW:1␤␤»

[16:50] <xinming> moritz: Thanks, Will remember that.

[16:50] <xinming> Here, the problem is, it seems the public accessor doesn't allow support write.

[16:51] <moritz> @!array[$k].val = $k

[16:51] <xinming> Even if I added   is rw   after has $.val

[16:51] <xinming> Ok, so, It only generates reader, not writer.

[16:51] <xinming> Thanks

[16:51] <moritz> no, it generates a writer

[16:52] <moritz> but you use it as an lvalue, not by passing in the new value

[16:52] <moritz> m: class A { has $.x is rw }; my $a = A.new; $a.x = 42; say $a.x

[16:52] <camelia> rakudo-moar 8276ce: OUTPUT«42␤»

[16:53] <xinming> moritz: The writer is differnt from the lvalue, writer can be over writtered by subclass.

[16:53] <moritz> xinming: if you say so; but calling an rw method only a reader is also misleading

[16:54] <xinming> If we make it a lvalue, do we have to make a writer method to modifiy the value before storing it? or, we can still update the value before it is updated.

[16:55] *** uncleyea1 is now known as uncleyear

[16:55] *** uncleyear left
[16:55] *** uncleyear joined
[16:55] <xinming> The idea of reader writer thing are from moose. I'll learn to use the perl6 way

[16:58] *** zakharyas left
[17:01] *** yqt joined
[17:01] *** GHAAIQ55 joined
[17:02] *** xfix joined
[17:03] <smls> "writer can be over writtered by subclass" -- so can an rw accessor, can't it?

[17:03] <ugexe> sounds like you want a Proxy

[17:04] <smls> yeah

[17:17] *** Ven left
[17:19] <smls> m: class A { has $.a = 4 }; class B is A { method a { Proxy.new(FETCH => -> $ { self.A::a / 2 }, STORE => -> $, \val { self.A::a = val } ) } }; my $b = B.new; dd $b.a; dd $b.a = 5; dd $b

[17:19] <camelia> rakudo-moar 8276ce: OUTPUT«2.0␤Cannot modify an immutable Int␤  in block <unit> at /tmp/w5HqoR0bFx:1␤␤»

[17:19] <smls> I can't make it work. :(

[17:20] <xinming> smls: You need  is rw.

[17:20] <smls> d'oh

[17:20] <xinming> $.a is rw

[17:20] <smls> m: class A { has $.a is rw = 4 }; class B is A { method a { Proxy.new(FETCH => -> $ { self.A::a / 2 }, STORE => -> $, \val { self.A::a = val * 10 } ) } }; my $b = B.new; dd $b.a; dd $b.a = 5; dd $b

[17:20] <camelia> rakudo-moar 8276ce: OUTPUT«2.0␤25.0␤$b = B.new(a => 50)␤»

[17:21] <smls> it's a lot to write though.

[17:21] <bartolin> m: say Int.^methods(:tree)  # is this NYI or a fossil?

[17:21] <camelia> rakudo-moar 8276ce: OUTPUT«Unexpected named parameter 'tree' passed␤  in any methods at src/gen/m-Metamodel.nqp:467␤  in block <unit> at /tmp/SCiXhCqJrV:1␤␤»

[17:21] <bartolin> m: say Int.^methods(:private)  # is this NYI or a fossil?

[17:21] <camelia> rakudo-moar 8276ce: OUTPUT«Unexpected named parameter 'private' passed␤  in any methods at src/gen/m-Metamodel.nqp:467␤  in block <unit> at /tmp/xWtgQSRxT9:1␤␤»

[17:22] *** khisanth_ joined
[17:23] *** Khisanth left
[17:23] <dalek> perl6-roast-data: c6a75bf | coke++ | / (9 files):

[17:23] <dalek> perl6-roast-data: today (automated commit)

[17:23] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c6a75bf2d3

[17:28] <moritz> bartolin: :tree only exists for parents, iirc

[17:29] <moritz> bartolin: and .^methods(:private) is instead .^private_method_table (but doesn't include superclasses)

[17:30] <xinming> How do we get methods names for a type?

[17:30] <xinming> .^methods returns soemthing unreadable for human

[17:30] <xinming> ignore me, I'm using something like .^methods.perl.say

[17:30] <xinming> I should use .^methods.say

[17:30] <smls> m: .say for Str.^methods>>.name

[17:30] <camelia> rakudo-moar 8276ce: OUTPUT«BUILD␤Int␤Num␤chomp␤chop␤pred␤succ␤match␤ords␤samecase␤samespace␤trim-leading␤trim-trailing␤trim␤encode␤NFC␤NFD␤NFKC␤NFKD␤wordcase␤trans␤indent␤path␤codes␤chars␤uc␤lc␤tc␤tclc␤flip␤ord␤WHY␤WHIC…»

[17:30] <FROGGS> m: say Any.^methods».name

[17:30] <camelia> rakudo-moar 8276ce: OUTPUT«invoke exists_key EXISTS-KEY delete_key DELETE-KEY delete_pos DELETE-POS list flat eager hash Hash Parcel List elems end keys kv values pairs antipairs invert pairup squish rotor reverse sort reduce combinations permutations unique uniq pick roll classify …»

[17:30] <moritz> .^methods>>.name

[17:30] <bartolin> moritz: both (:tree and :private) are still mentioned in S12 as selector parameters for ^methods

[17:31] <bartolin> moritz: could be removed there?

[17:31] *** khisanth_ left
[17:31] *** khisanth_ joined
[17:33] <xinming> I think I'd vote for a method name to return the max index value in an array.

[17:34] *** tinyblak left
[17:34] <xinming> We have max already. :-)

[17:34] *** tinyblak joined
[17:34] <smls> you mean .end ?

[17:35] <xinming> smls: Nope, the max index for with the value

[17:36] <xinming> (1,5,3).max  will return 5

[17:36] <xinming> I'd hope a method to return the 1 means the second item

[17:36] <xinming> But it's easy to be implemented anyway

[17:38] *** jack_rabbit left
[17:39] <smls> m: my @a = 1, 5, 3; say @a.keys.max({ @a[$_] })

[17:39] <camelia> rakudo-moar 8276ce: OUTPUT«1␤»

[17:41] <smls> Maybe .max should accept :key and :kv adverbs, like .[]

[17:42] <smls> .first-index and .grep-index could also be deprecated in favor of  .first(... , :k)  and  .grep(... , :k)

[17:42] *** mj41 joined
[17:42] *** Ben_Goldberg joined
[17:43] <smls> alternative there could be a  .max-index  method, but the name is LTS as it sounds like it might do what .end does

[17:43] <ugexe> one returns indices, one returns items

[17:43] <smls> LTA

[17:44] <smls> ugexe: Yeah, and an adverb could control that too

[17:44] <ugexe> no argument there. just pointing out they dont do quite the same thing

[17:44] *** skids joined
[17:45] *** khisanth_ left
[17:45] *** BenGoldberg left
[17:45] <smls> like  @foo[4]  @foo[4]:k  @foo[4]:kv

[17:45] *** khisanth_ joined
[17:48] *** telex left
[17:50] *** telex joined
[17:52] <mj41> m: https://gist.github.com/mj41/922a64d233779ceaa17e

[17:52] <camelia> rakudo-moar 8276ce: OUTPUT«No compiler available for language 'perl5'␤  in any  at /home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.setting.moarvm:1␤  in any  at /home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.setting.moarvm:1␤  in any load_module at src/gen/m-ModuleL…»

[17:53] <mj41> m: https://gist.github.com/mj41/922a64d233779ceaa17e

[17:53] <camelia> rakudo-moar 8276ce: OUTPUT«0␤42␤No compiler available for language 'BestLang'␤  in block <unit> at /tmp/35gXR9KIum:17␤␤»

[17:55] <mj41> hi, any idea why 'multi sub EVAL' doesn't work here?

[17:55] *** Zhtwn joined
[17:56] <japhb> smls: pong

[17:56] *** rindolf left
[17:57] <smls> japhb: trying to figure out perl6-bench

[17:57] <smls> how can i test a mini-benchmark on only the latest r-m an perl5?

[17:58] <smls> I tried:  ./bench setup; ./bench extract rakudo-moar/nom perl5/v5.22.0; ./bench build rakudo-moar/nom perl5/v5.22.0; ./bench time rakudo-moar/nom perl5/v5.22.0

[17:58] <mj41> perl5 works ( defined here https://github.com/rakudo/rakudo/blob/nom/src/core/control.pm#L168 ) but my BestLang doesn't

[17:58] <smls> but the timings/ directory tree does not contain any files, just empty folders

[17:59] <ugexe> mj41: when you turn it into a multi you need to look at where it dispatches. i imagine 'question', a string, matches a different EVAL better than the one you expect

[18:00] <mj41> ugexe: yes, but multi is the same as for 'perl5' ... and 'perl5' works ok

[18:00] *** profan joined
[18:01] <ugexe> its also using a proto

[18:01] *** araujo left
[18:04] <japhb> smls: Did the previous stages work?  Meaning, do you see built components/, and are there perl and perl6 binaries in their respective build trees?

[18:05] *** JimmyZ_ left
[18:05] *** tinyblak left
[18:05] <smls> japhb: ah, looks like the perl6 binary is not there (the perl one is, though)

[18:06] <japhb> smls: Sounds like something broke in that build.  :-(

[18:07] <jnthn> mj41: It seems that the candidate for EVAL-ing Perl 6 code will swallow anything :(

[18:07] <japhb> smls: Oh, also, there are a few people who have worked on perl6-bench over the years.  timotimo++ probably the most.

[18:10] <jnthn> mj41: Testing a patch for that now

[18:16] <timotimo> o/

[18:17] *** beastd joined
[18:19] <japhb> nine: Just wanted to let you know that your Inline::* work is very appreciated.  Recently got Perl 6 calling Python calling Perl 6 in order to make a Python framework that insisted on being the "outer" entry point (and calling *exit* instead of just returning up the stack when the innermost code returned) happy.

[18:19] <smls> japhb: This time, 'build' worked, and I now have components/rakudo-moar/nom/perl6 and components/perl5/v5.22.0/perl executables

[18:19] <mj41> jnthn++  

[18:19] <smls> however,  ./bench time  still doesn't seem to do anything

[18:19] <japhb> nine: And I hope to add two more layers (C++ and another Python), so we'll see how deep I can stack the turtles.  :-)

[18:20] <japhb> smls: Is there a components/rakudo-moar/nom/install/bin/perl6 ?

[18:20] <smls> yes

[18:20] <masak> japhb++ # living the Parrot multi-lang dream

[18:20] <japhb> Hmmm.  Do you have the Perl 5 requisites listed in the README?

[18:21] <japhb> masak: Couldn't do it without nine++, arnsholt++, FROGGS++, hoelzro++, jnthn++, etc.  (all the nativecall'ing heroes)

[18:22] <xinming> For now, .perl method will hang on recursive lists. Anyway to avoid that?

[18:22] <japhb> xinming: Does .DUMP work?

[18:22] <xinming> Also, Is there weak object idea in perl6?

[18:22] <xinming> Let me try

[18:22] <xinming> good, thanks, that worked.

[18:23] *** yqt left
[18:23] <timotimo> smls: just checking; you're giving "./bench time" a list of compiler versions you have, yes?

[18:23] <smls> yes

[18:23] <japhb> xinming: Yeah, .DUMP spends more effort trying to deal with unusual data structures ... we haven't really armored .perl yet.

[18:24] <japhb> smls: Did you answer my question about Perl 5 requisites?  I don't see the answer, but I may have missed it.

[18:24] <timotimo> it could be that bench is hit by a recent GLR-related change?

[18:24] <japhb> timotimo: Oh.  Crap.

[18:24] <japhb> Yeah, that would painfully make sense, actually.

[18:24] <timotimo> i must test this hypothesis

[18:24] <japhb> Please

[18:24] <smls> japhb: Still checking. Looks I have a problem with P5's DateTime module

[18:24] <timotimo> i still have some errands to do and commuting, though

[18:25] <timotimo> BBIAB

[18:25] <japhb> smls: Yeah, that would do it too.

[18:26] <Zhtwn> I'm still trying to grok when item assignment is used vs list assignment. Not quite there yet.

[18:26] <Zhtwn> jnthn said it's decided based on the first sigil seen in expression or declarator

[18:26] <smls> o.O   "[1]    25765 segmentation fault (core dumped)  perl -e 'use DateTime'"

[18:26] <Zhtwn> p6: my @foo = my $bar = 5, 10; say $bar; # list contest

[18:26] <camelia> rakudo-moar 8276ce: OUTPUT«5␤»

[18:27] <japhb> smls: Woah.  You've got some issues on that box.

[18:27] <smls> That's with a distro-packaged perl-datetime :/

[18:27] <japhb> smls: Is it a distro-packaged perl?

[18:27] <Zhtwn> p6: my ( @foo, $bar) ; @foo = $bar = 5, 10; say $bar; # got list context

[18:27] <camelia> rakudo-moar 8276ce: OUTPUT«5 10␤»

[18:27] <smls> yes

[18:28] *** spider-mario joined
[18:28] <japhb> smls: What does `type perl` say (assuming you use bash)?

[18:28] <smls> well, except of course the new one built in components/

[18:28] <smls> also, how come ./bench does not rpint any errors

[18:28] <smls> "perl is /usr/bin/perl"

[18:29] <Zhtwn> p6: my $bar; my @foo = $bar = 5, 10; say $bar; # expected list; got item?

[18:29] <camelia> rakudo-moar 8276ce: OUTPUT«5␤»

[18:29] <japhb> smls: components/ builds are *only* used as timeable compilers, not to run bench, timeall, or analyze

[18:29] *** yqt joined
[18:29] <japhb> smls: OK, I'm suspecting that something is really unhappy on your box.

[18:30] *** vendethiel- left
[18:30] <japhb> smls: timeall captures errors and segfaults and such from compilers it is timing into the timing file.  But to be frank I never expected timeall *itself* to segfault.  Because, WTF.

[18:31] *** vendethiel joined
[18:31] * smls is doing a full package upgrade

[18:33] *** khisanth_ left
[18:33] *** khisanth_ joined
[18:33] <jnthn> mj41: Ah, my first attempt at a patch wasn't good enough, apparently

[18:34] <[Coke]> is there a way to make panda install from a local copy of a module?

[18:34] *** khisanth_ is now known as Guest64394

[18:36] <timotimo> [Coke]: of course; panda install .

[18:36] <timotimo> japhb: so it's likely that we're running into a problem with perl5 rather than perl6 for perl6-bench?

[18:38] <japhb> timotimo: Given that he segfaults trying to load DateTime in perl5, yes.

[18:38] <timotimo> mhm

[18:38] <japhb> Still, I'm not confident that bench is GLR-safe

[18:39] *** Guest64394 left
[18:39] *** Khisanth joined
[18:39] <japhb> It's had a history of being sensitive to changes in eagerness, end-of-block loop behavior, and so on.

[18:40] <japhb> Because I tried to write it relatively idiomatically, and the idioms kept changing.

[18:45] <[Coke]> timotimo: ok. how do I enforce that for subdeps?

[18:45] <[Coke]> er, just deps, really.

[18:46] <[Coke]> I realized it doesn't matter anyway, since I'm already dealing with submodules elsewhere. no worries.

[18:46] <masak> really? "penguin" is now a Unicode character?

[18:46] * [Coke] is trying to get the daily runs to also run the Inline::Perl5 tests.

[18:46] <masak> the Unicode consortium will go to history as "they had a good run, but they really didn't know when to stop"

[18:46] <timotimo> [Coke]: i suppose you'll just have to enumerate them on the commandline?

[18:47] <[Coke]> timotimo: yah, more trouble than it's worth, I guess. danke.

[18:47] <timotimo> YW

[18:47] <timotimo> i suppose something could be thought up

[18:48] <[Coke]> be nice if I had a way to make a local, mini modules mirror.

[18:52] <Zhtwn> p6: my $bar; my @foo = $bar = 5, 10; say $bar

[18:52] <camelia> rakudo-moar 8276ce: OUTPUT«5␤»

[18:52] *** molaf left
[18:52] <geekosaur> do they think them up or do apple and microsoft hand them lists of things they want?

[18:52] <geekosaur> (re unicode)

[18:52] <masak> well, *someone* handed them a penguin.

[18:52] <flussenc1> .u camel

[18:52] <yoleaux> U+1F42A DROMEDARY CAMEL [So] (🐪)

[18:52] <yoleaux> U+1F42B BACTRIAN CAMEL [So] (🐫)

[18:53] *** flussenc1 is now known as flussence

[18:53] <masak> very important distinction, Unicode!

[18:53] *** molaf joined
[18:53] <Zhtwn> jnthn: if item/list assignment is decided by first sigil in expression or declarator, shouldn't the "my @foo" have made the "$bar =" be list assignment? what am I missing?

[18:53] <Zhtwn> p6: my $bar; my @foo = $bar = 5, 10; say $bar

[18:53] <camelia> rakudo-moar 8276ce: OUTPUT«5␤»

[18:54] <geekosaur> penguins are popular/"iconic" at least in the US (cf. several recent animated movies)

[18:54] <Zhtwn> p6: my ( @foo, $bar ); @foo = $bar = 5, 10; say $bar;

[18:54] <camelia> rakudo-moar 8276ce: OUTPUT«5 10␤»

[18:55] <flussence> .oO( maybe they should've taken the approach they used for flags [country-code alphabet intended to display flags using font ligatures], and used it for animals too... )

[18:56] <bartolin> .tell FROGGS would you agree that RT #125129 can be merged into RT #78676 (as a duplicate)?

[18:56] <yoleaux> bartolin: I'll pass your message to FROGGS.

[18:56] <flussence> .oO( I'd probably have an easier time memorising the latin species names than numeric codepoints anyhow... )

[18:57] <FROGGS> bartolin: yes

[18:57] <yoleaux> 18:56Z <bartolin> FROGGS: would you agree that RT #125129 can be merged into RT #78676 (as a duplicate)?

[18:57] <bartolin> great, will do that ...

[18:59] <jnthn> Zhtwn: That "$bar = 5" is an expression

[18:59] <jnthn> (Parsed as the initializer to the declaration)

[19:00] *** mj41 left
[19:00] <Zhtwn> ah. but if there's no declarator, then the relevant expression is "@foo = $bar =", yes?

[19:01] *** mj41 joined
[19:01] <jnthn> yes

[19:01] <Zhtwn> Thanks - I'm seeing it now.

[19:01] <jnthn> mj41: spectesting updated version of my patch, which will hopefully nail it

[19:01] <jnthn> (also doing 5 other things at the same time afk :-))

[19:05] *** tinyblak joined
[19:08] *** Alina-malina left
[19:08] *** Alina-malina joined
[19:10] *** tinyblak left
[19:15] *** zakharyas joined
[19:23] *** Guest58780 joined
[19:24] *** lolisa joined
[19:26] <Zhtwn> Okay, I think I've got the item/list assignment details documented: https://github.com/perl6/doc/pull/95 -- comments?

[19:28] <masak> Zhtwn++

[19:29] <masak> I had no idea the rule was that complicated. but it's explained well.

[19:29] <smls> I don't think "first sigil seen" is very accurate

[19:29] <smls> m: say (my $x) = 2, 4, 6; dd $x

[19:29] <camelia> rakudo-moar 8276ce: OUTPUT«2 4 6␤$x = $(2, 4, 6)␤»

[19:31] <Zhtwn> ugh. You're right. It's not the sigil, it's the context? The parens give a list context even without a sigil, yes?

[19:32] <smls> I'm not sure of this stuff anymore, either

[19:33] <smls> m: (my $x,) = 2, 4, 6; dd $x

[19:33] <camelia> rakudo-moar 8276ce: OUTPUT«$x = 2␤»

[19:33] *** domidumont left
[19:35] <Zhtwn> m: my $x; ($x,) = 2, 4, 6; dd $x

[19:35] <camelia> rakudo-moar 8276ce: OUTPUT«$x = 2␤»

[19:36] <Zhtwn> m: my $x; ($x) = 2, 4, 6; dd $x

[19:36] <camelia> rakudo-moar 8276ce: OUTPUT«$x = $(2, 4, 6)␤»

[19:36] <smls> I guess those are both list assignments

[19:37] <masak> doesn't S03 explain the rule somewhere?

[19:37] <smls> but in the first, the RHS list is slurped into the LHS list "$x,"m so $x gets onlt the first item

[19:37] <jnthn> Inside a (...) you have a new EXPR, which is opaque to the analysis.

[19:40] <Zhtwn> I haven't been able to find a clear explanation of this in S03, fwiw

[19:41] <Zhtwn> looks like the rule is "first context seen in the expression or declarator" -- gotta define "first context", then

[19:43] <jnthn> Zhtwn: Yes, the mechanism is actually relatively simple when expressed as code in the grammar, it's just finding a way to translate that. :)

[19:44] *** Khisanth left
[19:44] <nine> japhb: thanks for telling me :)

[19:45] <japhb> nine++  # Thank you very much for writing it.  :-)

[19:48] *** Khisanth joined
[19:50] *** kurahaupo joined
[19:52] *** darutoko- left
[19:55] *** Ben_Goldberg left
[19:56] *** beastd left
[19:57] *** Ben_Goldberg joined
[19:58] *** vendethiel left
[19:59] *** bin_005 joined
[20:04] *** vendethiel joined
[20:07] *** Khisanth left
[20:13] <Zhtwn> okay, updated the PR with better details on how the context is determined for item/list assignment

[20:14] <Zhtwn> same PR: https://github.com/perl6/doc/pull/95

[20:18] <labster> m: my $x = "num", 42; say $x.perl

[20:18] <camelia> rakudo-moar 8276ce: OUTPUT«WARNINGS:␤Useless use of "," in expression "my $x = \"num\", 42" in sink context (line 1)␤"num"␤»

[20:19] *** uncleyear left
[20:20] *** uncleyear joined
[20:20] *** xfix left
[20:23] <dalek> perl6-bench: b4fd74e | smls++ | lib/Bench/ (2 files):

[20:23] <dalek> perl6-bench: Add 'unit' keyword to make deprecation warning go away

[20:23] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/b4fd74e346

[20:23] <dalek> perl6-bench: 2648ccb | smls++ | / (3 files):

[20:23] <dalek> perl6-bench: Add 'rc-perfect-shuffle' benchmark

[20:23] <dalek> perl6-bench: 

[20:23] <dalek> perl6-bench: ...based on the "Perfect Shuffle" task on RosettaCode.

[20:23] <dalek> perl6-bench: With Perl 5 and Perl 6 implementation; NQP still missing.

[20:23] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/2648ccb1c8

[20:23] <dalek> perl6-bench: 710b94d | japhb++ | / (5 files):

[20:23] <dalek> perl6-bench: Merge pull request #24 from smls/master

[20:23] <dalek> perl6-bench: 

[20:23] <dalek> perl6-bench: Add rc-perfect-shuffle benchmark and add 'unit' keywords to get rid of deprecation warnings.

[20:23] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/710b94d72f

[20:24] *** Khisanth joined
[20:27] *** sftp_ joined
[20:29] *** Khisanth left
[20:30] *** sftp left
[20:30] *** sftp_ is now known as sftp

[20:31] <cognominal> I just proposed https://github.com/rakudo/rakudo/pull/445 for a better warning on code stringification

[20:32] <flussence> feature request: can we make Bufs a bit more string-like (and useful)? They seem neglected, maybe because nothing in the core really uses them. I threw some ideas up at https://github.com/flussence/p6-misc/blob/e2f8008/buf-stuff.p6

[20:37] <smls> japhb: How can I generate the HTML/JS graph for a benchmark?

[20:38] *** Khisanth joined
[20:47] *** Khisanth left
[20:47] *** BenGoldberg_ joined
[20:49] <japhb> smls: ./bench --style=html_plot compare <builds>

[20:49] <smls> thanks

[20:49] *** Khisanth joined
[20:50] *** Ben_Goldberg left
[21:03] <dalek> doc: c110826 | (Noel Maddy)++ | lib/Language/variables.pod:

[21:03] <dalek> doc: Clarify item vs list assignment in Variables

[21:03] <dalek> doc: 

[21:03] <dalek> doc: The context used to determine whether item or list assignment used is

[21:03] <dalek> doc: a bit tricky. Added detailed explanation and examples.

[21:03] <dalek> doc: review: https://github.com/perl6/doc/commit/c11082637d

[21:03] <dalek> doc: e46780a | (Noel Maddy)++ | lib/Language/variables.pod:

[21:03] <dalek> doc: more clarification on item/list assignment

[21:03] <dalek> doc: 

[21:03] <dalek> doc: It's the overall expression / declarator context that determines the

[21:03] <dalek> doc: type of assignment used, not simply the first sigil seen.

[21:03] <dalek> doc: 

[21:03] <dalek> doc: Update with more examples to show how context is determined.

[21:03] <dalek> doc: review: https://github.com/perl6/doc/commit/e46780aac1

[21:03] <dalek> doc: 7fa81a3 | moritz++ | lib/Language/variables.pod:

[21:03] <dalek> doc: Merge pull request #95 from Zhtwn/assignment-precedence

[21:03] <dalek> doc: 

[21:03] <dalek> doc: Clarify item vs list assignment in Variables

[21:03] <dalek> doc: review: https://github.com/perl6/doc/commit/7fa81a33d1

[21:04] *** Khisanth left
[21:05] *** Khisanth joined
[21:13] <timotimo> maybe i'll continue looking at the binding lowerer now

[21:14] *** BenGoldberg_ left
[21:15] *** BenGoldberg_ joined
[21:16] *** FROGGS_ joined
[21:17] *** RabidGravy left
[21:18] <mj41> jnthn: vďaka a dobrú noc (díky a dobrou noc) 

[21:20] <jnthn> Oh, I forgot to push the patch!

[21:20] <dalek> rakudo/nom: c4ccf90 | jnthn++ | src/core/control.pm:

[21:20] <dalek> rakudo/nom: Make overriding EVAL to provide languages work.

[21:20] <dalek> rakudo/nom: 

[21:20] <dalek> rakudo/nom: This factoring means we now look in the compiler registry, then for

[21:20] <dalek> rakudo/nom: a multi candidate. Before, in theory you could write a multi, but in

[21:20] <dalek> rakudo/nom: practice we never dispatched to it.

[21:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4ccf90684

[21:20] *** FROGGS left
[21:20] <jnthn> mj41: Prosím! A dobrou noc o/

[21:20] <[ptc]> does anyone know how often proto.json is updated on the modules.p6.org site?

[21:21] *** Khisanth left
[21:24] *** raiph joined
[21:27] *** zakharyas left
[21:27] <mj41> jnthn: funguje to! děkuji.

[21:28] <timotimo> jnthn: in the binder lowerer we're hllizing things that come in; should i put the type capturing logic after that or before it? my intuition says it's gotta be after, so that the type actually matches up even if things got hllized 

[21:28] *** mj41 left
[21:34] *** _mg_ left
[21:34] *** Khisanth joined
[21:37] *** kaare_ left
[21:38] <jnthn> timotimo: yes, after

[21:39] <timotimo> doing a spectest run right now

[21:42] *** Khisanth left
[21:43] <timotimo> had to pull in between to get some more fixes

[21:49] <timotimo> https://gist.github.com/timo/e578fe92a918cea41f07 this is my patch currently, and it seems to survive the spec tests very successfully

[21:52] <masak> 'night, #perl6

[21:53] <jnthn> 'night, masak

[21:53] * jnthn figures he should also rest... o/

[21:53] <dalek> rakudo/nom: a927a5a | timotimo++ | src/Perl6/Actions.nqp:

[21:53] <dalek> rakudo/nom: allow binder lowering if type captures exist

[21:53] <dalek> rakudo/nom: 

[21:53] <dalek> rakudo/nom: this happens quite often for roles, as they bind

[21:53] <dalek> rakudo/nom: ::?CLASS and $?CLASS for their methods when they are

[21:53] <dalek> rakudo/nom: composed.

[21:53] <dalek> rakudo/nom: 

[21:53] <dalek> rakudo/nom: I saw 55 cases of binder lowering being prevented by

[21:53] <dalek> rakudo/nom: the existence of type captures across CORE.setting.

[21:53] *** Khisanth joined
[21:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a927a5a2c7

[21:53] <timotimo> gnite jnthn!

[21:55] <dalek> rakudo/nom: 62cdc29 | (Stéphane Payrard)++ | src/core/Code.pm:

[21:55] <dalek> rakudo/nom: Warning now gives the exact  Code descendant class

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/62cdc291fd

[21:55] <dalek> rakudo/nom: b95a226 | lizmat++ | src/core/Code.pm:

[21:55] <dalek> rakudo/nom: Merge pull request #445 from cognominal/patch-2

[21:55] <dalek> rakudo/nom: 

[21:55] <dalek> rakudo/nom: Warning now gives the exact  Code descendant class

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b95a226427

[21:58] *** Khisanth left
[22:05] *** DrForr left
[22:05] *** DrForr joined
[22:06] *** Zhtwn left
[22:06] <vendethiel> cognominal++ timotimo++ jnthn++

[22:08] *** smls left
[22:09] <timotimo> huh?

[22:10] *** khisanth_ joined
[22:12] <cognominal> thx lizmat++

[22:15] *** khisanth_ left
[22:17] *** lsm-desktop left
[22:17] *** khisanth_ joined
[22:24] *** khisanth_ left
[22:24] *** bin_005 left
[22:24] *** khisanth_ joined
[22:28] *** lsm-desktop joined
[22:29] *** khisanth_ left
[22:29] *** khisanth_ joined
[22:34] *** kurahaupo left
[22:40] *** khisanth_ left
[22:42] *** khisanth_ joined
[22:47] *** khisanth_ left
[22:50] *** khisanth_ joined
[22:51] *** raiph left
[22:52] *** raiph joined
[22:55] *** khisanth_ left
[22:58] *** khisanth_ joined
[23:03] *** khisanth_ left
[23:05] *** khisanth_ joined
[23:19] *** khisanth_ is now known as Khisanth

[23:25] *** bakedb joined
[23:49] *** laouji joined
