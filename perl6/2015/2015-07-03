[00:01] <TimToady> well, the exact semantics might change a bit, to more like, returns the first defined value, or Empty

[00:05] <dha> Oh. Ok, Will not patch. :-)

[00:06] *** japhb left
[00:06] *** japhb joined
[00:10] *** Akagi201 left
[00:13] *** Akagi201 joined
[00:17] *** dha left
[00:17] *** Akagi201 left
[00:21] *** vendethiel left
[00:22] *** khw joined
[00:25] *** ShimmerFairy left
[00:26] *** vendethiel joined
[00:27] *** gfldex left
[00:37] *** ShimmerFairy joined
[00:43] <ugexe> finally got this installing modules on windows. but for how long...

[00:45] *** laouji joined
[00:48] *** vendethiel left
[00:49] <ugexe> installs panda to a further stage than panda itself, but it stills fail testing

[00:56] *** dayangkun joined
[01:11] *** rmgk left
[01:13] *** rmgk joined
[01:18] *** BenGoldberg joined
[01:18] *** araujo left
[01:21] *** araujo joined
[01:26] *** yqt left
[01:38] *** skids joined
[01:38] *** AlexDani` left
[01:42] *** tinyblak joined
[01:44] *** yeahnoob joined
[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[02:13] *** nys left
[02:19] *** aborazmeh joined
[02:19] *** aborazmeh left
[02:19] *** aborazmeh joined
[02:20] *** raiph left
[02:22] *** jack_rabbit joined
[02:28] *** vendethiel joined
[02:29] *** jack_rabbit left
[02:36] *** Akagi201 joined
[02:37] *** Dee22 joined
[02:40] *** VinceDee left
[02:44] *** Akagi201_ joined
[02:47] *** Akagi201 left
[02:52] <dalek> rakudo/nom: 63de9a1 | TimToady++ | src/Perl6/Grammar.nqp:

[02:52] <dalek> rakudo/nom: catch obvious misuse of ^100.method

[02:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63de9a14a5

[02:53] *** noganex joined
[02:55] *** noganex_ left
[02:56] *** aborazmeh left
[03:11] *** kaare_ joined
[03:19] <TimToady> m: say ^100.pick

[03:19] <camelia> rakudo-moar a32c1d: OUTPUT«0..^100␤»

[03:19] *** vendethiel left
[03:21] <TimToady> m: say ^100.pick

[03:21] <camelia> rakudo-moar 63de9a: OUTPUT«Potential difficulties:␤    Precedence of ^ is looser than method; please parenthesize␤    at /tmp/db2BxGAzgx:1␤    ------> 3say ^1007⏏5.pick␤Use of Nil in numeric context  in block <unit> at /tmp/db2BxGAzgx:1␤0..^0␤»

[03:28] *** vendethiel joined
[03:34] <dalek> rakudo/nom: 852340f | TimToady++ | src/Perl6/Grammar.nqp:

[03:34] <dalek> rakudo/nom: oops, warning shouldn't move cursor position

[03:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/852340f236

[03:45] <lizmat> good *, #perl6! 

[03:50] *** vendethiel left
[03:50] <kanl> m: my %a = a => *; my %b = %a.invert; %b.say;

[03:50] <camelia> rakudo-moar 63de9a: OUTPUT«Whatever<140359990650704> => a␤»

[03:51] <kanl> m: my %a = a => *, b => *; my %b; %b.push: %a.invert; %b.say;

[03:51] <lizmat> kanl: this is unexpected why ?

[03:51] <camelia> rakudo-moar 63de9a: OUTPUT«␤»

[03:52] <lizmat> ah... hmmm...

[03:52] <kanl> m: my %a = a => <1>, b => <1 2>; my %b; %b.push: %a.invert; %b.say;

[03:52] <camelia> rakudo-moar 852340: OUTPUT«1 => a b, 2 => b␤»

[03:53] <kanl> lizmat: so i was expecting Whatever => a b

[03:56] *** vendethiel joined
[03:57] <lizmat> to really get Whatever as the key value, you should use a typed hash, aka 'my %b{Any}'

[03:57] <lizmat> otherwise you'll get a stringification of Whatever as the key

[03:57] <lizmat> however, that doesn't solve the problem

[03:57] <lizmat> brb

[04:04] <lizmat> m: my %h{Any}; %h{Whatever} = "a"; say %h.perl   # golfed down problem

[04:04] <camelia> rakudo-moar 852340: OUTPUT«Hash[Any,Any].new()␤»

[04:08] <lizmat> m: my %h = a => 42, b => 666; %h{*} = 43,667; say %h.perl   # {*} means all keys in the hash

[04:08] <camelia> rakudo-moar 852340: OUTPUT«{:a(43), :b(667)}<>␤»

[04:09] <lizmat> now, since the order of the keys is random, assignment as such would be rather roulette like

[04:11] <lizmat> kanl: so I'm afraid this is a case of DIHWIDT

[04:12] <lizmat> since the roulette nature of assigning to {*}, one could wonder whether this should be allowed at all or not

[04:16] <kanl> lizmat: thanks! so i should not be considered a bug then? though i'd still prefer it does what i meant :p

[04:16] <kanl> ^it

[04:17] <lizmat> well, but that's just it: it currently *is* doing what is meant

[04:17] *** gfldex joined
[04:17] <lizmat> it's just not doing what *you* meant  :-)

[04:18] <lizmat> m: my %h = a => 42, b => 666; say %h{*}   # slice all keys

[04:18] <camelia> rakudo-moar 852340: OUTPUT«42 666␤»

[04:19] <lizmat> m: my %h = a => 42, b => 666; say %h{*} = pi; say %h

[04:19] <camelia> rakudo-moar 852340: OUTPUT«3.14159265358979 (Any)␤a => 3.14159265358979, b => (Any)␤»

[04:22] <dalek> rakudo/nom: bccd76d | lizmat++ | src/core/hash_slice.pm:

[04:22] <dalek> rakudo/nom: Don't allow assignment to %h{*}

[04:22] <dalek> rakudo/nom: 

[04:22] <dalek> rakudo/nom: Since the order of the keys as given by {*} is non-deterministic,

[04:22] <dalek> rakudo/nom: it is rather roulette-like trying to use them as a list to assign

[04:22] <dalek> rakudo/nom: to.  To avoid confusion, it is probably better to not allow this

[04:22] <dalek> rakudo/nom: at all.  Or perhaps a warning should be in order instead.

[04:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bccd76dfa8

[04:23] <kanl> fair enough, i'll try and digest it. lizmat++

[04:23] <lizmat> kanl: why are you using Whatever as a value anyway?

[04:24] <lizmat> m: my %a = a => <*>, b => <*>; my %b; %b.push: %a.invert; %b.say;   # perhaps confusing, perhaps what you need ?

[04:24] <camelia> rakudo-moar 852340: OUTPUT«* => a b␤»

[04:25] <lizmat> aka, use the string '*' instead of the type *

[04:26] <kanl> lizmat: it would work for me, only if the * means Whatever when used as a hash key.

[04:26] <kanl> i'll try it

[04:27] <lizmat> no, it won't mean Whatever in that case

[04:27] <lizmat> it will just look like Whatever

[04:27] <kanl> close enough, i can just check it as a special case, i guess :)

[04:29] <lizmat> still feels like an X Y issue here, though

[04:29] <lizmat> what are you trying to achieve with Whatever as a key value ?

[04:31] <kanl> getting all the keys in an hash from time to time. i'm trying to write a system monitoring too with functions like FALLBACK( $name, *%index ), with name being DF, IOSTAT, etc. and %index being Capacity => </ /foo /bar>, Iuse => *, etc. etc. long story :)

[04:32] <kanl> i can gist you the code if you'd like, but it probably just adds too much noise :p

[04:32] <lizmat> m: my %h = a => 42, b => 666; say %h{}'

[04:32] <camelia> rakudo-moar 852340: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VOjTXlGIw8␤Strange text after block (missing semicolon or comma?)␤at /tmp/VOjTXlGIw8:1␤------> 3my %h = a => 42, b => 666; say %h{}7⏏5'␤    expecting any of:␤        infix␤        infix stoppe…»

[04:32] <lizmat> m: my %h = a => 42, b => 666; say %h{}

[04:32] <camelia> rakudo-moar 852340: OUTPUT«a => 42, b => 666␤»

[04:32] <lizmat> m: my %h = a => 42, b => 666; say %h{%h.keys}

[04:32] <camelia> rakudo-moar 852340: OUTPUT«42 666␤»

[04:32] <lizmat> m: my %h = a => 42, b => 666; say %h{}:k

[04:32] <camelia> rakudo-moar 852340: OUTPUT«a b␤»

[04:33] <lizmat> m: my %h = a => 42, b => 666; say %h{}:v

[04:33] <camelia> rakudo-moar 852340: OUTPUT«Unexpected named parameter 'v' passed␤  in block <unit> at /tmp/ZODGmkMsyH:1␤␤»

[04:33] <lizmat> hmmm... that is surprising

[04:33] <kanl> but yeah, for now <*> would work for me, and i'd just check for it as a special case :)

[04:33] <lizmat> okidoki

[04:34] *** Akagi201_ left
[04:34] <kanl> i'm sure this is one of those dumb yahoo + not enough doc problem :)

[04:37] <lizmat> well, actually, you pointed out a glitch in the matrix, afaiac

[04:37] <lizmat> for typed hashes, what does %h{*} mean?

[04:37] <lizmat> does it indicate all of the keys, or does it just take Whatever as its key?

[04:41] *** vendethiel left
[04:42] *** laouji left
[04:42] *** laouji joined
[04:47] <kanl> m: say 'FOO' if < 1 1 30 1 1 1 3 1 1 -1 0 1 0 1 25 2 1 1 >.none > 20;

[04:47] <camelia> rakudo-moar 852340: ( no output )

[04:47] *** laouji left
[04:52] <lizmat> those are strings, not numbers

[04:53] <kanl> right. and it looks right, i think.

[04:54] <lizmat> m: say < 1 1 30 1 1 1 3 1 1 -1 0 1 0 1 25 2 1 1 >.none.Int > 20

[04:54] <camelia> rakudo-moar bccd76: OUTPUT«none(False, False, True, False, False, False, False, False, False, False, False, False, False, False, True, False, False, False)␤»

[04:55] <lizmat> m: say "FOO" if < 1 1 30 1 1 1 3 1 1 -1 0 1 0 1 25 2 1 1 >.none.Int > 20

[04:55] <camelia> rakudo-moar bccd76: ( no output )

[04:55] <kanl> was just trying to see if it typecasts to Int or not

[04:55] <lizmat> it doesn't, you need to do that yourself

[04:55] <kanl> oh..

[04:56] <kanl> but i'm getting the expected behavior, no? ( no output )

[04:57] <lizmat> ah, I see where you're getting at now

[04:59] <kanl> apologies for any confusion i might've caused :p

[04:59] <lizmat> nonono, you're teaching me something  :-)

[04:59] <lizmat> I guess using the > on the junction, automatically does force the string to be numerically interpreted

[05:00] <lizmat> so indeed, you don't need to do the .Int yourself

[05:00] <TimToady> yes, it does

[05:01] <TimToady> m: say ^100.pick

[05:01] <camelia> rakudo-moar bccd76: OUTPUT«Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at /tmp/XqFgxBcxPR:1␤    ------> 3say ^1007⏏5.pick␤0..^100␤»

[05:03] *** khw left
[05:05] *** BenGoldberg left
[05:10] <dalek> rakudo/nom: 2904f3a | lizmat++ | src/core/hash_slice.pm:

[05:10] <dalek> rakudo/nom: Add :v candidates for %h{*} and %h{}

[05:10] <dalek> rakudo/nom: 

[05:10] <dalek> rakudo/nom: Not sure why they were missing before

[05:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2904f3ace9

[05:16] <lizmat> m: say ^100.Int

[05:16] <camelia> rakudo-moar bccd76: OUTPUT«Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at /tmp/K92pr9lSrV:1␤    ------> 3say ^1007⏏5.Int␤0..^100␤»

[05:17] *** laouji joined
[05:17] <lizmat> m: say ^"100".Int

[05:17] <camelia> rakudo-moar bccd76: OUTPUT«0..^100␤»

[05:20] <TimToady> it's only trying to recognize the most common case; it doesn't even look for ^$foo.method, since .method might well be a normal way to produce an integer on whatever $foo contains

[05:22] <skids> m: sub f (::T $a) { my T $b; { T.WHICH.say; $b.WHICH.say } }; f(1);

[05:22] <camelia> rakudo-moar bccd76: OUTPUT«Int␤Int␤»

[05:22] <skids> m: sub f (::T $a) { { my T $b; T.WHICH.say; $b.WHICH.say } }; f(1);

[05:22] <camelia> rakudo-moar bccd76: OUTPUT«Int␤Method 'WHICH' not found for invocant of class 'T'␤  in sub f at /tmp/BRvz9zBD_p:1␤  in block <unit> at /tmp/BRvz9zBD_p:1␤␤»

[05:22] <skids> This underlying bug caused the elide-type code to break:

[05:22] <skids> m: :(::T $a, T $b).perl.say

[05:22] <camelia> rakudo-moar bccd76: OUTPUT«Method 'WHICH' not found for invocant of class 'T'␤  in block <unit> at /tmp/WOh7wT2yZO:1␤␤»

[05:23] *** coffee` left
[05:23] * skids tries to find an RT

[05:28] * lizmat catches some more sleep

[05:33] *** vendethiel joined
[05:35] *** Akagi201 joined
[05:37] *** coffee` joined
[05:40] *** telex left
[05:42] *** telex joined
[05:42] *** Akagi201 left
[05:46] *** Psyche^ joined
[05:46] *** Akagi201 joined
[05:48] *** skids1 joined
[05:50] *** Psyche^_ left
[05:50] *** skids left
[05:52] *** g4 joined
[05:52] *** g4 left
[05:52] *** g4 joined
[05:54] *** Gruber joined
[05:55] * skids1 submits RT#125537

[05:57] *** _mg_ joined
[05:58] *** _mg_ left
[05:59] *** _mg_ joined
[06:02] <kanl> my $s = '[foo:bar]'; $s.= subst: /'[' (\w+) ':' (\w+) ']'/, "baz.$0-$1"; ( $/, $0, $1, $s )>>.say;

[06:03] *** diana_olhovik_ joined
[06:04] <skids1> m: my $s = '[foo:bar]'; $s.= subst: /'[' (\w+) ':' (\w+) ']'/, "baz.$0-$1"; ( $/, $0, $1, $s )>>.say;

[06:04] <camelia> rakudo-moar 2904f3: OUTPUT«Use of Nil in string context  in block <unit> at /tmp/D9SoMUZWyc:1␤Use of Nil in string context  in block <unit> at /tmp/D9SoMUZWyc:1␤baz.-␤｢foo｣␤｢bar｣␤｢[foo:bar]｣␤ 0 => ｢foo｣␤ 1 => ｢bar｣␤»

[06:07] <kanl> skids: thanks.

[06:07] <kanl> m: my $s = '[foo:bar]'; $s.= subst: /'[' (\w+) ':' (\w+) ']'/, "baz.$0-$1"; $s.say;

[06:07] <camelia> rakudo-moar 2904f3: OUTPUT«Use of Nil in string context  in block <unit> at /tmp/eLzq5gebaI:1␤Use of Nil in string context  in block <unit> at /tmp/eLzq5gebaI:1␤baz.-␤»

[06:09] <kanl> hmm.. not getting why it's not replacing.

[06:13] <skids1> m: my $s = "[foo:bar]"; $s .= subst: /"[" (\w+) ":" (\w+) "]"/, { "baz." ~ $_[0] ~ "-" ~ $_[1] }; ( $/, $0, $1, $s )>>.say;

[06:13] <camelia> rakudo-moar 2904f3: OUTPUT«baz.foo-bar␤｢foo｣␤｢bar｣␤｢[foo:bar]｣␤ 0 => ｢foo｣␤ 1 => ｢bar｣␤»

[06:13] <skids1> The match is passed to the second argument as an argument, not put in $/.

[06:14] <skids1> (not totally sure it should not be in $/ as well)

[06:17] <kanl> skids1: thank you.

[06:17] <[Tux]> I know, I know, work in prgress, but today I see additionall slowdown. just FYI

[06:17] <[Tux]> test             50000    44.229    44.140

[06:17] <[Tux]> test-t           50000    42.542    42.454

[06:28] *** RabidGravy joined
[06:31] *** [Sno] left
[06:44] <RabidGravy> morning!

[06:53] *** domidumont joined
[06:57] *** domidumont left
[06:57] *** kanl left
[06:58] *** domidumont joined
[06:59] *** rurban joined
[07:03] *** kanl joined
[07:06] <kanl> m: sub foo( *%h ) { %h.say }; foo( a => 1 ); foo( 'a%' => 1 );

[07:06] <camelia> rakudo-moar 2904f3: OUTPUT«a => 1␤Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/Nr_YC7kyJj:1␤  in block <unit> at /tmp/Nr_YC7kyJj:1␤␤»

[07:08] <kanl> m: sub foo( *%h ) { %h.say }; foo( a => 1 ); foo( | hash 'a%' => 1 );

[07:08] <camelia> rakudo-moar 2904f3: OUTPUT«a => 1␤a% => 1␤»

[07:08] * kanl pulls hair

[07:09] <moritz> m: sub foo( *%h ) { %h.say }; foo( a => 1 ); foo( |{'a%' => 1} );

[07:09] <camelia> rakudo-moar 2904f3: OUTPUT«a => 1␤a% => 1␤»

[07:10] *** Woodi joined
[07:10] *** cdc_ joined
[07:10] *** dams_ joined
[07:10] <kanl> why wouldn't "naked" 'a%' => 1 work like a => 1?

[07:10] *** garu_ joined
[07:10] *** rvchangue_ joined
[07:11] *** cdc left
[07:11] *** dams left
[07:11] *** rmgk left
[07:11] *** salv0 left
[07:11] *** rvchangue_ is now known as rvchangue

[07:11] *** salv00 joined
[07:11] *** rmgk joined
[07:12] *** pRiVi joined
[07:12] <moritz> kanl: because pairs with quoted LHS don't count as named arguments

[07:12] <kanl> to an unsophiscated user like me, the intuitive thing is, either both work, or both fail.

[07:13] <moritz> m: sub f(*@pos, *%named) { say "pos: @pos.perl(); named: %named.perl()" }; f a => 1; f 'a' => 1;

[07:13] <camelia> rakudo-moar 2904f3: OUTPUT«pos: []<>; named: {:a(1)}<>␤pos: [:a(1)]<>; named: {}<>␤»

[07:15] *** Akagi201 left
[07:16] *** rurban left
[07:16] <kanl> i can appreciate the explanation, but (to rant) do not love the subtle differences in various things.

[07:18] *** [Sno] joined
[07:20] *** darutoko joined
[07:21] *** rurban joined
[07:23] <moritz> kanl: how would you all passing of literal Pairs to named parameters?

[07:23] <moritz> s/all/allow/

[07:28] *** phdphil left
[07:30] *** amurf left
[07:31] *** rurban1 joined
[07:33] *** rurban left
[07:35] *** zakharyas joined
[07:36] *** Woodi left
[07:36] *** Woodi joined
[07:48] *** laouji left
[07:51] *** fxbrain joined
[07:51] *** laouji joined
[07:53] *** laouji left
[07:53] *** laouji joined
[07:56] *** skids1 left
[07:56] *** rindolf joined
[08:10] *** yeahnoob left
[08:22] *** laouji left
[08:22] *** rurban joined
[08:22] <masak> morning, #perl6

[08:23] <masak> or, um, antenoon.

[08:23] <BooK> sssh, don't wake the americans

[08:24] *** laouji joined
[08:24] <ShimmerFairy> masak: I've got a truly horrendous script that counts the partitions in the 2D version of hexslide, I'll put it up in a little bit :)

[08:24] <masak> ShimmerFairy: I played around with some ideas yesterday too. it looked promising, but nothing conclusive.

[08:25] <ShimmerFairy> masak: The most annoying thing about hexslide I've found is that I don't have the mathematical knowledge to formally prove the conjectures I have, so nothing is 100% certain for me.

[08:25] <masak> ShimmerFairy: we could discuss it over privmsg if you want.

[08:26] <ShimmerFairy> Perhaps :)

[08:29] <BooK> http://doc.perl6.org/routine.html # how is this generated? I'd be willing to add html anchors so one could link to a specific routine directly (at least the ones with an alphabetical name)

[08:35] <masak> BooK: think it's this one: https://github.com/perl6/doc/blob/master/htmlify.p6

[08:37] <BooK> masak: cool, will have a look

[08:37] <BooK> I'm also recording my travel into the perl 6 realm

[08:37] *** rurban1 left
[08:38] <masak> \o/

[08:41] <BooK> can any unicode character be used to define operators?

[08:42] <DrForr> Nope.

[08:42] <ShimmerFairy> masak: here is the horrid code: https://github.com/lue/hexslide

[08:42] <DrForr> The first exception is any combining character, which IMO is a real bummer, and sort of contravenes Unicode Tech Note #25.

[08:43] *** Akagi201 joined
[08:44] <DrForr> They're treated as part of the identifier, not as a standalone character. Which is fine for most cases, such as umlauts, cedilla and diaresis.

[08:44] <masak> ShimmerFairy: kudos on the README

[08:44] <DrForr> But IMO anything with an IsMath property shouldnt' appear in an identifier.

[08:44] <BooK> DrForr: is the charactestics of what can be used documented somewhere?

[08:45] <masak> ShimmerFairy: "It's recommended that you keep all row/column names unique" -- no, it's necessary to keep all row/column names unique :) don't make the problem harder than it already is :)

[08:45] *** darutoko- joined
[08:45] <DrForr> Not to my knowledge, but I haven't investigated the relevant docs.

[08:46] <ShimmerFairy> masak: considering how the regex works, you _could_ get away with non-unique names, but you really, _really_ shouldn't :) (it matches characters from the name specification part, so as long as the second through last characters of a piece contain one unique name, the regex could maybe figure out what you were going for)

[08:48] <ShimmerFairy> masak: Also, just noticed an error in the conjecture in the README, in case you spot it too (fixed it)

[08:48] *** darutoko left
[08:51] <RabidGravy> in a case where I want to do something like "method do-something { ... start { self.do-something-else } }" is it best to get the self as an argument instead?

[08:52] <masak> ShimmerFairy: in fact, I would be even more boring than you currently are in your format.

[08:52] <RabidGravy> i.e "method do-something(Thing $self:) { ... start { $self.do-something-else } }" ?

[08:52] <masak> ShimmerFairy: I'd specify rows and columns like this: "ABCD\n123\n"

[08:52] <BooK> still experimenting.

[08:53] <masak> ShimmerFairy: or maybe even leave that out, and have the program assign those names.

[08:53] <BooK>  find / | perl6 -e 'run( <rev>, :out, :!chomp ).out.lines.say' # why does this only give me the first 100 lines and '...' at the end?

[08:53] <ShimmerFairy> masak: yeah, the reason why I did it visually was so I didn't have to spend so much time trying to visualize rows and columns mentally :)

[08:54] <ShimmerFairy> masak: and letting you specify your own names somehow seemed the easier route to me :)

[08:54] <masak> ShimmerFairy: your conjecture at the bottom is trivially true. but it's an "if", not an "if and only if", so it's not that interesting.

[08:55] <masak> ShimmerFairy: it's not the easier route. if you want to have a board to look at, allow `#` comments in the format instead. :)

[08:55] <BooK> find / | perl6 -e '.say for run( <rev>, :out ).out.lines' # DWIM, i.e. prints all lines, without hanging

[08:55] <ShimmerFairy> masak: well, my current idea of dividers are that they are spots that will always be taken by a piece, so there's no way to clear them. I'd be interested in getting a counterexample

[08:56] *** espadrine joined
[08:56] <masak> oh, I see.

[08:56] <RabidGravy> BooK, I think it's something to do with the .gist on the List

[08:56] <masak> that seems tricky to define somehow. but maybe it can be done.

[08:56] <RabidGravy> you can also do .... list>>.say

[08:57] <ShimmerFairy> (also, the ease in specifying names was in not having to spend time figuring out One True Naming System for things in general)

[08:57] <RabidGravy> lines rather

[08:57] <RabidGravy> .. lines>>.say

[08:58] <ShimmerFairy> masak: my code recursively finds dividers (starting with fake dividers surrounding the board) from all the pieces until no new dividers show up. It basically moves pieces to the extremes they can go to, and takes the overlap as dividers.

[08:58] <masak> I think I just figured out why I don't like the .say method form most of the time.

[08:58] <masak> because it puts the important thing too far to the right in the statement. it should be up front, at the left.

[08:58] <masak> which I guess is why I'm fine with `.say;` in loops and stuff

[08:59] <masak> so it's not so much the .say method as a method I don't like, it's syntactically mis-balancing the statement.

[08:59] <ShimmerFairy> masak: with a special case before that recursive search for "intra-groove" dividers (caused by things like  <>.<>  creating vertical groove dividers .X.X. )

[08:59] <BooK> RabidGravy: yup, my first use of »

[08:59] <ShimmerFairy> I usually use .say when I'm typing the line and I realize I forgot to put "say" in front :P

[08:59] <BooK> now how do I silence the standard error

[08:59] <RabidGravy> grooviness, special bonus points and stuff if you use »

[09:00] <BooK> meh, the error I see is not from rev, it's from find

[09:00] <BooK> so perl can't do anything about it

[09:00] <RabidGravy> Boo! bad find bad! bad!

[09:01] <masak> ShimmerFairy: that doesn't sound like a way to end up with a readable program.

[09:01] <ShimmerFairy> masak: check my script, and you'll see that's so far true :P

[09:01] <masak> (doing something because you forgot something)

[09:02] <RabidGravy> » is one of the few unicode operators I use as I can remember how to type it

[09:02] <ShimmerFairy> oh, talking about .say :)

[09:03] <ShimmerFairy> masak: Usually for one-liners, as in  perl6 -e '... @a.sort.grep({stuff}). .oO(oh hey I forgot to put a say in front, I'll just tack it on the end instead of cursoring back to the beginning) .say'

[09:04] <masak> ok, fair enough. it's a question of scale. script vs application.

[09:04] <masak> still, I have little sympathy for that line of reasoning, because *I don't forget to put `say` at the beginning*. :P

[09:04] <masak> I don't really see how that would happen. :)

[09:05] <dalek> book: d3296e5 | PerlJam++ | src/preface.pod:

[09:05] <dalek> book: Update section on obtaining Rakudo

[09:05] <dalek> book: review: https://github.com/perl6/book/commit/d3296e52a7

[09:05] <dalek> book: fa18755 | PerlJam++ | src/regexes.pod:

[09:05] <dalek> book: Add a little more explanatory text

[09:05] <dalek> book: review: https://github.com/perl6/book/commit/fa18755861

[09:05] <masak> (cue someone digging up a place in the backlog where masak feeds camelia something without a `say` at the beginning...)

[09:05] <dalek> book: ad5d765 | PerlJam++ | src/regexes.pod:

[09:05] <dalek> book: a few other minor edits

[09:05] <dalek> book: review: https://github.com/perl6/book/commit/ad5d76581f

[09:05] <dalek> book: 54fc3fa | PerlJam++ | src/basics.pod:

[09:05] <dalek> book: Some wording updates

[09:05] <dalek> book: review: https://github.com/perl6/book/commit/54fc3fa1ed

[09:05] <BooK> I need to find a way to ignore dalek highlighting me

[09:05] <ShimmerFairy> masak: it happens :) I have a hard time dealing with 2D arrays even! (So when I rewrite the script I shared to make it readable, it'll _definitely_ feature enough code where I don't constantly have to make sure I got the rows and columns right)

[09:06] <masak> I don't really see what's so hard about 2D arrays.

[09:06] <BooK> fooling around with infinite streams, I get "Malformed UTF-8" errors

[09:06] <masak> m: my @board = [1, 2], [3, 4]; say @board[1][0]

[09:06] <camelia> rakudo-moar 2904f3: OUTPUT«3␤»

[09:06] <masak> voilà, 2D array

[09:06] <BooK> I'm surprised :bin does not help

[09:07] <masak> BooK: me too.

[09:07] <BooK> oooh I need to set :enc

[09:07] <masak> even for :bin ?

[09:07] <BooK> looks like

[09:08] <ShimmerFairy> masak: the problem is my brain doesn't automatically know how to interpret @board[1][0] ; not in the same way I automatically know what @board[2] means.

[09:09] <BooK> http://doc.perl6.org/type/IO%3A%3AHandle#Encoding_options # reading this, it feels like :bin and :enc are mutually exclusive

[09:09] <ShimmerFairy> It's just something weird about my brain, not too big a deal. It just means I'd ideally label which one is the row number and which one is the column number :)

[09:09] <masak> ShimmerFairy: seems more like a mental barrier (fixable with conditioning) than a language problem :)

[09:10] <masak> ShimmerFairy: write a sub so that you can pos(@board, :$row, :$column) :)

[09:10] <ShimmerFairy> BooK: well, considerings encodings are about text files, not binary ones...

[09:10] <masak> ShimmerFairy: then it's hard to go wrong :)

[09:10] <RabidGravy> BooK, well if you supply :bin it totally ignores any :enc so yes

[09:11] <ShimmerFairy> masak: of course, I'm not blaming the language at all, it's definitely a conceptual issue of some kind :)  (the reason why I fought through it with the listparse.p6 script, instead of defining convenience functions, was in an interest to get something working as fast as possible)

[09:11] <jnthn> Make sure to use .read/.write with a binary file

[09:11] <BooK> find / -type f | xargs cat | perl6 -e 'run( <cut -b 1-8>, :out, :bin ).out.lines».say' # then why does this die with Malformed UTF-8 in block <unit> ?

[09:11] <BooK> jnthn: ooh, say expects text ?

[09:12] <jnthn> BooK: More immediately, .lines returns a List of Str

[09:12] <BooK> i see

[09:12] <jnthn> Str being at Unicode grapheme level. .read/.write work in terms of Buf, which is the byte level thing.

[09:13] <BooK> "A file opened with :bin may still be processed line-by-line, but IO will be in terms of Buf rather than Str types."

[09:14] <ShimmerFairy> masak: it's also precisely why I have a visual name specifier for the boards. I think I did consider supporting comments, but I didn't want to go through the trouble of adding that in for a "simple text file" :)

[09:14] <BooK> so how do I iterate on the Buf?

[09:15] <masak> ShimmerFairy: don't make the problem more difficult to solve than it already is. there's essential complexity, and then there's complexity you add on top of that.

[09:16] <jnthn> BooK: Just put it in list context somehow

[09:16] <jnthn> m: for @('abc'.encode('utf-8')) { .say }

[09:16] <camelia> rakudo-moar 2904f3: OUTPUT«97␤98␤99␤»

[09:17] <ShimmerFairy> masak: for sure, the script as it stands is the result of going for whatever seemed faster to do at the moment (whether or not it actually was). I'll get to reworking it soon for readability and general sanity :)

[09:18] *** amurf joined
[09:19] <BooK> jnthn: I have run( <cut -b 1-8>, :out, :bin ).out

[09:19] <BooK> so I guess I need to .read($bytes) from it

[09:20] <jnthn> BooK: I guess so; I'm a bit behind on the latest IO bits, I'm afraid..

[09:21] <BooK> can't yet figure out a way to get a stream of Buf of size $bytes from that

[09:21] <BooK> which I'll then be able to ».write($*OUT) I guess

[09:22] <jnthn> gather { while $handle.read(256) -> $buf { take $buf } } # or so

[09:23] *** amurf left
[09:25] <kanl> moritz: i don't know. while i appreciate named parameters, i do miss being able to 'slurp' in k => v pairs via @_, without caring whether the lhs is quoted or not, like in p5. e.g. my %named = @_;

[09:26] <RabidGravy> I'm guessing that it's the content of  "binary" files that is shagging it up

[09:27] <RabidGravy> e.g. find . -type f -name '*.pm' | xargs cat | perl6 -e 'run( <cut -b 1-8>, :out ).out.lines».say'  works fine

[09:27] <BooK> RabidGravy: yes it is

[09:31] *** TEttinger left
[09:31] <RabidGravy> On a completely unrelated note regarding tutorials etc has anyone mentioned https://www.livecoding.tv/ ?

[09:32] <BooK> can't find the doc for gather/take in doc.perl6.org

[09:33] <kanl> moritz: but thanks for the demonstration. i guess i can just easily do { %named.push: @pos }

[09:35] <RabidGravy> BooK, I think take is only documented in http://docs.perl6.org/routine/take

[09:36] <RabidGravy> gather nowhere as far as I can tell, this probably should be remedied

[09:38] <BooK> although I have a hard time getting this oneliner running, I really like that Perl6 does not let you get away with the ambiguity of a chunk of bytes being used as a string and the other way around

[09:39] <BooK> this is annoying, but I'm sure this prevents a lot of bugs that are more annoying

[09:40] <RabidGravy> yeah, it definitely stops you from getting shagged up multibyte characters being rendered as ascii 

[09:44] *** bin_005 joined
[09:53] *** brrt joined
[10:00] *** ggoebel2 left
[10:10] *** wolf_work joined
[10:13] *** domidumont left
[10:14] *** domidumont joined
[10:15] *** rurban1 joined
[10:17] *** fxbrain left
[10:17] *** Woodi left
[10:21] *** rurban1 left
[10:21] *** darutoko joined
[10:21] *** bjz joined
[10:23] *** darutoko- left
[10:24] *** Woodi joined
[10:27] *** aborazmeh joined
[10:27] *** aborazmeh left
[10:27] *** aborazmeh joined
[10:32] *** Akagi201 left
[10:34] *** kanl left
[10:40] *** RabidGravy left
[10:40] *** virtualsue joined
[10:54] *** Dee22 left
[10:56] *** yqt joined
[11:01] *** aborazmeh left
[11:04] *** bin_005 left
[11:06] *** rurban1 joined
[11:08] *** amurf joined
[11:12] *** amurf left
[11:17] <BooK> ok, so I only have annoting questions

[11:17] <BooK> annoying

[11:17] *** cognominal joined
[11:17] *** cschwenz joined
[11:18] <masak> shoot

[11:18] <BooK> like, how do I portably set the locale+encoding for a program I'll call with run()

[11:20] <moritz> locale through %*ENV, I guess

[11:20] <moritz> and encoding with :enc

[11:20] <masak> moritz++ beat me to it :)

[11:21] <moritz> portable? locales aren't portable

[11:21] * masak .oO( you can't just pick France up and carry it to Egypt! )

[11:21] <BooK> they aren't ?

[11:21] <moritz> I don't think so

[11:21] <BooK> indeed the key word was "portably"

[11:22] <BooK> like, does windows respect it?

[11:23] <moritz> I'm not aware of a windows locale mechanism, except system (or maybe user)-wide

[11:23] <moritz> I don't see how Perl 6 could change that for existing windows programs

[11:23] <BooK> oh well, I guess I have to know how to tell the program I'm run()ing which encodibg to expect from me, and which I expect from it

[11:24] <BooK> I was somehow hoping some combination of LC_ALL to magically fix the issue for me :-)

[11:24] <BooK> obviously, I'm a dreaming optimistic

[11:24] *** laouji left
[11:32] *** rurban1 left
[11:32] <lizmat> re http://irclog.perlgeek.de/perl6/2015-07-03#i_10843541 : I would like to reiterate my stance that we should disambiguate :a(42) and a => 42 notation

[11:33] *** Akagi201 joined
[11:33] <lizmat> into :a(42) *always* being a named parameter, and a => 42 *always* being a Pair constructor

[11:33] <lizmat> foo( :a(42) ) would this always be a named parameter

[11:34] <lizmat> foo( a => 42 ) would always be a positional Pair

[11:34] <lizmat> </rant>

[11:35] <sjn> in what way are those two different? (I'd assume that a named parameter _is_ a pair)

[11:36] <jnthn> They're the same today

[11:36] <jnthn> The discontinuity is in "a" => 42

[11:36] <jnthn> Where the LHS is not an auto-quoted literal

[11:36] <jnthn> One immediate reason is that efficient compilation of named parameters comes a lot more difficult when you don't know the names at compile time.

[11:37] *** Akagi201 left
[11:38] <masak> I think we can shove the discontinuity around, but there will always be one, and it will always chafe a bit.

[11:39] <masak> the reward of putting the discontinuity in a better place should be weighed against the breakage to the ecosystem the move will inevitably cause.

[11:39] <ShimmerFairy> It would be nice if there were a clearer distinction between Pairs and named arguments, methinks

[11:39] <moritz> there is.

[11:39] <masak> what moritz said.

[11:39] <moritz> oh, "clear*er*"

[11:39] * sjn wonders about the circumstances around not knowing names at compile-time

[11:39] <jnthn> sjn: |($key => $value) works

[11:40] <jnthn> And looks like more effort, and probably costs at least 10 times as much

[11:40] <ShimmerFairy> masak: I guess I'm misunderstanding the problem then. Isn't the issue that a => 42 is treated the same as :a(42)

[11:40] <jnthn> ShimmerFairy: I don't consider that an issue

[11:40] <sjn> jnthn: right.

[11:40] <jnthn> Anyway, I think I'm just going to shoot this down with "no, too late"

[11:41] <jnthn> I'm not interested in revisiting such fundemental things now.

[11:41] <ShimmerFairy> or "please try again in 6.1" :P

[11:41] *** brrt left
[11:41] <jnthn> And I don't particularly dislike the way it is now anyway.

[11:41] *** dayangkun left
[11:41] <jnthn> I think foo => ... looks nicer than :foo(...) in a lot of cases too

[11:42] <masak> I agree with "too late".

[11:42] <timotimo> you can still slang it

[11:42] <masak> I use both forms, and I never encounter any bugs due to confusion. it's a matter of learning the (simple) rules.

[11:42] <masak> timotimo: yes, and that. thanks.

[11:42] *** laouji joined
[11:42] <timotimo> :)

[11:43] <nine> lizmat: FWIW I'd miss => for named arguments because it makes lining up vertically easy. Also because I'm just so used to it from Perl 5 :) However I do think that the difference between a => 42 and 'a' => 42 is one of the few warts that got added with Perl 6.

[11:44] <ShimmerFairy> The only named parameter issue I run into is implict *%_ :)

[11:44] <ShimmerFairy> *implicit

[11:44] <timotimo> hehe

[11:44] <jnthn> The implicit *%_ is one thing I'd like to see addressed pre-6.0, yes

[11:44] <lizmat> I think it is a wart on the same scale as sigil variance in Perl 5 is

[11:44] <timotimo> oh wow

[11:45] <timotimo> that's a harsh wart

[11:45] <lizmat> like, a hell to teach newbies

[11:45] <masak> then you write a slang where that wart is gone.

[11:45] <masak> and you promote it at conferences, telling people why.

[11:45] <lizmat> but, having had a "too late" from both jnthn and masak, I will not bring this up again

[11:46] <lizmat> I will reserve the right to say "I told you so" in the future  :-)

[11:46] <nine> It's absolutely surprising and non-obvious

[11:46] <masak> lizmat: I do that a lot :P

[11:46] <ShimmerFairy> I do want to point that, for me at least, :a(42) and a => 42 seem like different things, at least to me (one is "when I want to give a named parameter", one is "when I want a pair"), so I can see possible issues with Perl 6 not holding the same views

[11:47] <masak> has someone said harsh words about the use of parens, too? like (a => 42)?

[11:47] <timotimo> i value being able to use :a(42)and a => 42 interchangably for named parameters

[11:48] <masak> m: sub foo(*@poses, *%nameds) { say +@poses, "; ", +@nameds }; foo( a => 42 ); foo( (a => 42) )

[11:48] <camelia> rakudo-moar 2904f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/t_OJ32oBBq␤Variable '@nameds' is not declared. Did you mean '%nameds'?␤at /tmp/t_OJ32oBBq:1␤------> 3@poses, *%nameds) { say +@poses, "; ", +7⏏5@nameds }; foo( a => 42 ); foo( (a => 42␤»

[11:48] <masak> m: sub foo(*@poses, *%nameds) { say +@poses, "; ", +%nameds }; foo( a => 42 ); foo( (a => 42) )

[11:48] <camelia> rakudo-moar 2904f3: OUTPUT«0; 1␤1; 0␤»

[11:48] <masak> I think I was a little upset first time I saw that.

[11:48] <ShimmerFairy> timotimo: I don't disagree, I'm simply stating that they _feel_ like different things; => looks Pair-like and :() looks parameter-like

[11:48] <masak> because Perl also believes that "parentheses are only for grouping"

[11:49] <timotimo> masak: the pair gets to be its own group :)

[11:49] <masak> ShimmerFairy: but... named parameters are implemented as pairs, and that implementation is exposed/sold pretty heavily to the user. (through slurpies and flattening, etc)

[11:49] <masak> ShimmerFairy: saying that they look like one another is missing that it's a feature, not a bug.

[11:50] <ShimmerFairy> masak: I understand that (and it's pretty nice, I think), but I can't pretend that I don't see the two syntaxes in a lightly different way from each other.

[11:50] <masak> ShimmerFairy: ...aaaand again the problem that needs fixing is inside your mind, not outside it ;)

[11:52] <ShimmerFairy> masak: basically, even though  %h = :a(1), :b(2)  is perfectly fine, it looks really weird to me (but foo(a => 1) doesn't really look weird. Huh.)

[11:52] * masak .oO( Perl 6: "it's easy to use if you just learn this simple rule" -- ShimmerFairy: "but it doesn't work when I use this different rule!" )

[11:53] *** yqt left
[11:53] <masak> I'm one of your "get off my lawn" types, even though I joined somewhere around 2005. I remember a time before we had the :a(42) syntax.

[11:53] <masak> so your only choice was a => 42

[11:54] <masak> so I guess I always think of the former as convenient sugar for the latter

[11:54] <masak> and *boy* is it convenient!

[11:54] <masak> not only :$a, but also things like :$^a and :$!a

[11:54] <ShimmerFairy> And :42a is even more convenient! :)

[11:54] <masak> ShimmerFairy-- # you deserve that one :)

[11:55] <masak> I don't take away karma lightly :>

[11:55] <ShimmerFairy> aw :<

[11:55] <masak> :42a syntax has *exactly* one use, in my world: :2nd et al

[11:55] <jnthn> m: :100ways-to-annoy-masak

[11:55] <camelia> rakudo-moar 2904f3: ( no output )

[11:55] <jnthn> :)

[11:56] <lizmat> ShimmerFairy++   # need to compensate

[11:56] <masak> jnthn-- # don't get to do this often :)

[11:56] <masak> the colon syntax for named args is so convenient that it has affected the way I name variables before a call.

[11:56] <jnthn> :D

[11:57] <lizmat> masak: my only argument is that it should be used for named args exclusively

[11:57] <masak> I'm more likely to name a callee argument variable after a parameter, because of the colon syntax.

[11:57] <masak> lizmat: I guess what I'm saying is I don't see it that way, because I was present when it was introduced as sugar.

[11:57] <masak> lizmat: to me, a => 42 is the "real" way to write a named arg

[11:58] <masak> lizmat: and I'm lucky enough to *also* get to write it as :a(42) or :$a or :$.a because Perl 6 is awesome

[11:58] <masak> some day I might cook up a slang that allows me to write :$<a>, by the way :)

[11:58] <ShimmerFairy> m: say DateTime.new(:1year); # tell me this doesn't look cool, masak :P

[11:58] <camelia> rakudo-moar 2904f3: OUTPUT«0001-01-01T00:00:00Z␤»

[11:58] <masak> ShimmerFairy: you... have a point.

[11:59] <masak> ok! two uses! but that's *it*! :P

[11:59] <ShimmerFairy> (too bad you can't do :2years , since there's no :$years)

[11:59] *** rindolf left
[11:59] <ShimmerFairy> .oO(use Slang::PluralNamedArgsSometimes;)

[12:00] *** jantore joined
[12:01] <masak> ShimmerFairy: in fact, the .later and .earlier methods on Date/DateTime do support :years

[12:01] *** rindolf joined
[12:01] <ShimmerFairy> Interestingly:

[12:01] <ShimmerFairy> m: say DateTime.new(:1month);

[12:01] <camelia> rakudo-moar 2904f3: OUTPUT«Must provide arguments to DateTime.new()␤  in block <unit> at /tmp/7IgHuCh4M1:1␤␤»

[12:01] <ShimmerFairy> DateTime's constructor complains if you don't have :year , but the error message doesn't tell you that at all.

[12:02] <masak> ShimmerFairy: nice find. please submit a rakudobug and/or make a patch :)

[12:02] <masak> ShimmerFairy++ ++ShimmerFairy

[12:06] <ShimmerFairy> Looks like a simple fix (just have to change the error message; should I spectest a change regardless, in the interest of paranoia?)

[12:06] <moritz> yes please

[12:06] <moritz> paranoia++

[12:07] <ShimmerFairy> That's what I thought. "It's just a simple string!" (but you never know...) :)

[12:12] <ShimmerFairy> I'm assuming TEST_JOBS is the only parallelization feature?

[12:12] <timotimo> yeah

[12:12] <timotimo> er ... for what exactly?

[12:12] * ShimmerFairy will be doing a before and after spectest, just so she's absolutely sure

[12:12] <moritz> and you can build with 'make -j' or 'make -j4'

[12:13] <ShimmerFairy> timotimo: for testing a change I'll be making

[12:13] <ShimmerFairy> moritz: Ah, forgot to specify I was talking about testing parallelization

[12:14] <timotimo> building with -j* sadly doesn't help very much

[12:14] <ShimmerFairy> not for rakudo, at least :(

[12:15] <masak> does someone want to reply to Tom's latest p6u email?

[12:15] <moritz> it does do the 'git pull' in roast in parallel with the build

[12:15] <moritz> which helps on slow networks

[12:15] <masak> looks pretty easy -- he doesn't seem aware that 0 boolifies to False.

[12:16] <moritz> aye

[12:16] <moritz> masak: seems like you want to answer :-)

[12:16] <masak> I can do that.

[12:16] <ShimmerFairy> Heh, my network incidentally is being slow atm, thanks to ~certain people~.

[12:16] <masak> main reason I was checking is that there's some lag on p6u so many people tend to give the same answer

[12:16] <lizmat> masak: maybe also mention .starts-with("#")

[12:18] *** cschwenz left
[12:19] *** raiph joined
[12:20] <masak> lizmat: oops, sent without seeing the above.

[12:21] <masak> lizmat: feel free to add that in a separate reply ;)

[12:21] <lizmat> will do

[12:21] <masak> (my email was about everything else)

[12:27] <BooK> I like using :a for a => True

[12:27] <timotimo> me, too

[12:27] <timotimo> and of course the :$foo form is a very nice thing indeed

[12:28] <ShimmerFairy> masak: good thing "0" doesn't boolify to False anymore, though :)  (...right?)

[12:28] <lizmat> mail sent

[12:29] <timotimo> right, ShimmerFairy 

[12:29] <moritz> m: say ?'0'

[12:29] <camelia> rakudo-moar 2904f3: OUTPUT«True␤»

[12:29] <lizmat> m: say +'0'

[12:29] <camelia> rakudo-moar 2904f3: OUTPUT«0␤»

[12:29] <lizmat> m: say +?'0'

[12:29] <camelia> rakudo-moar 2904f3: OUTPUT«1␤»

[12:29] <lizmat> :-)

[12:29] <jnthn> m: say ?+'0'

[12:29] <camelia> rakudo-moar 2904f3: OUTPUT«False␤»

[12:29] <timotimo> m: say say ?+~?'0'

[12:29] <camelia> rakudo-moar 2904f3: OUTPUT«False␤True␤»

[12:30] <timotimo> er

[12:30] <timotimo> %)

[12:30] <timotimo> m: say ?~?'0'

[12:30] <camelia> rakudo-moar 2904f3: OUTPUT«True␤»

[12:30] <lizmat> .oO( stop stop stop!  this is getting way too silly! )

[12:30] <ShimmerFairy> m: my @a = 1,2,3; say +^@a;  # always a weird typo to leave unnoticed

[12:30] <camelia> rakudo-moar 2904f3: OUTPUT«-4␤»

[12:31] *** Akagi201 joined
[12:31] <timotimo> ouch, that's mean :)

[12:31] *** Akagi201_ joined
[12:32] <ShimmerFairy> In case it's not obvious, it's supposed to be ^+@a  . There have been a couple of times where I wondered why there was this unwanted negative number for an index inside a  for +^@a { ... }

[12:33] <timotimo> took me a few seconds

[12:34] <timotimo> i don't do bitwise ops often in p6

[12:34] <ShimmerFairy> Yeah, I think prefix:<+^> is particularly uncommon, at least in my experience.

[12:35] *** shlomif joined
[12:35] *** rindolf left
[12:35] *** shlomif is now known as rindolf

[12:35] <ShimmerFairy> By the way, what about the bitwise string ops? Do they no longer work on Stringy types, because S03 itself says it indicates a design error? :)

[12:35] *** Akagi201 left
[12:36] <timotimo> welllll~

[12:36] <timotimo> stringy things are NFG now ..

[12:36] <timotimo> so how does that work :D

[12:36] <timotimo> oh, obviously we also need stringy set ops that go grapheme-wise and act on combining characters

[12:37] <ShimmerFairy> "hello" ~& "world" :carefully

[12:37] *** rurban1 joined
[12:37] <jnthn> data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAJzAfQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqD

[12:37] <BooK> timotimo: is :$foo an indirection?

[12:38] <ShimmerFairy> timotimo: I'm of the opinion that the bitwise string ops should have never been defined for anything more than buffers. (Have you see that S32::Stringy I wrote a looong time ago and have shared a few times recently, by any chance?)

[12:38] <timotimo> BooK: no, it's short for foo => $foo

[12:38] <jnthn> The hell did I just paste...

[12:38] <timotimo> ShimmerFairy: i think i saw it

[12:38] <timotimo> jnthn: it's a small image, possibly an icon?

[12:38] <BooK> oh, nice

[12:38] <ShimmerFairy> jnthn: Base64 data of an image. Because.

[12:38] <jnthn> epic fail

[12:38] <BooK> depends on an image of what it is...

[12:39] <jnthn> It was supposed to be a meme :P

[12:39] <ShimmerFairy> could be worse; could've been a moderately-sized image :P (or, your client wouldn't've cut off the data)

[12:39] <jnthn> Apparently instead of giving me a link to an image, it gave me a data: protocol URL with the whole image :P

[12:39] <BooK>  so undecidably safe for work

[12:40] <jnthn> Not at all, it was one about bitwise ops :P

[12:40] <timotimo> i'm not entirely sure if that's the picture you pasted or my browser telling me the data is broken

[12:40] <timotimo> because it looks like an icon for a broken image %)

[12:40] <jnthn> heh

[12:40] * jnthn goes back to writing code :)

[12:40] <ShimmerFairy> timotimo: the pasted stuff looks suspiciously like it ends at the cutoff length for IRC messages

[12:41] <BooK> jnthn: I just realized we've known each other for about ten years...

[12:41] <timotimo> ah, of course

[12:41] <ShimmerFairy> By the way, what kind of Uniform Resource Locator doesn't locate the resource, but just gives it to you instead? :P

[12:42] <timotimo> the one for content-addressed storage :)

[12:42] <BooK> chartreuse and fishnet, what a welcome in the perl community ;-)

[12:43] <jnthn> BooK: Yes, YAPC::EU 2005 was my first YAPC and second Perl event :)

[12:43] <jnthn> And what fun it was :)

[12:44] <jnthn> BooK++ # one of the folks who made me feel very welcome in the Perl community

[12:44] <ShimmerFairy> fail "Must provide arguments to DateTime.new()";  <-- should "DateTime" be instead "{self.^name}", or is that thinking ahead too much? (Derived classes and so on) :P

[12:45] *** woolfy joined
[12:47] * lizmat welcomes woolfy

[12:48] <jnthn> woolfy! \o/

[12:48] <masak> ShimmerFairy: "0" ? why would "0" boolify to false? that's insane. that'd be like the strings "nul", "zero" and "zilch" also boolifying to false :P

[12:48] <woolfy> hey jnthn

[12:49] <masak> woolfy! \o/

[12:49] <ShimmerFairy> m: say ?"The Earth is flat.";  # this is clearly a bug, masak

[12:49] <camelia> rakudo-moar 2904f3: OUTPUT«True␤»

[12:50] <masak> ShimmerFairy: well, I certainly welcome you submitting a patch to fix that one!

[12:51] <masak> ShimmerFairy: don't just solve special cases, though. you have to come up with a general solution.

[12:51] <jnthn> Just implement it by delegating to Rule 1...

[12:52] <ShimmerFairy> sub prefix:<?>(Str:D $a) { Wikipedia::query($a) || StackOverflow::query($a) || ... }

[12:52] <woolfy> hey masak

[12:53] <woolfy> (just passing by, showing #perl6 to a friend)(byebye)

[12:53] *** woolfy left
[12:54] <dalek> nqp/multidim: b296e1b | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[12:54] <dalek> nqp/multidim: Map multi-dim array ops on MoarVM.

[12:54] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/b296e1b806

[12:54] <dalek> nqp/multidim: 8deb3b8 | jnthn++ | t/moar/02-multidim.t:

[12:54] <dalek> nqp/multidim: Tests for VMArray supporting new multi-dim ops.

[12:54] <dalek> nqp/multidim: 

[12:54] <dalek> nqp/multidim: Only run on MoarVM for now. This checks that existing dynamic arrays

[12:54] <dalek> nqp/multidim: will play nice with the new multi-dim access APIs, which may ease

[12:54] <dalek> nqp/multidim: some code-gen (but mostly checks the ops are basically functional).

[12:54] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/8deb3b8887

[13:00] <dalek> nqp/multidim: 287814e | jnthn++ | docs/6model/repr-compose-protocol.markdown:

[13:00] <dalek> nqp/multidim: Extend REPR array compose protocol for dimensions.

[13:00] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/287814e9bb

[13:00] *** lucasb joined
[13:01] <lucasb> good friday to everyone

[13:01] <jnthn> .oO( he said crossly )

[13:04] <japhb> Just had to share this, as it cracked me up ... got a cold email from a recruiter today that begins "We’ve analyzed your open source contributions in Github, and we identified you as a potential good fit for a position as Software Developer at Booking.com."  You mean, I wrote some Perl?

[13:05] <timotimo> %)

[13:05] <ShimmerFairy> japhb: got that too, seemed spammy

[13:07] * lizmat didn't get that  :-(    :-)

[13:08] <japhb> lizmat: Clearly you're nto qualified to work at Booking!  ;-)

[13:08] * ShimmerFairy tries to imagine what :-( ... :-) would mean :P

[13:08] <lizmat> yeah, not enough commits on github  :-)

[13:08] <japhb> ShimmerFairy: The :-( was tongue in cheeck, methinks

[13:09] <japhb> Man, my connection from brain to fingers is a little broken today

[13:09] <ShimmerFairy> japhb: I meant as a language construct :P (see how it's a matching pair?)

[13:09] <rurban1> we get a lot of excellent and qualified devs with no single github commit

[13:09] <lizmat> that would qualify me  :-)

[13:10] <japhb> ShimmerFairy: I would think :-( and )-: would be the matching pair ... or (-: and :-) for the more positive

[13:11] <masak> what's the idiomatic way to call a MAIN multi from another?

[13:11] <ShimmerFairy> The only change I got in the spectest was a different Wstat for t/spec/S17-lowlevel/lock.rakudo.moar  , but I imagine that's not surprising

[13:11] <japhb> Emotion markers!  "This is sad code ... and this is happy code!"

[13:11] <japhb> masak: nextsame?

[13:11] <lizmat> masak: samewith(...)

[13:11] <tadzik> samwich()

[13:11] * japhb goes to look in bench, I'm pretty sure I did that

[13:12] <ShimmerFairy> masak: shell("$*PROGRAM-NAME ...") ?    :P

[13:12] <japhb> Oh interesting, I just directly call MAIN with the appropriate args.

[13:12] * masak tries samewith

[13:13] * japhb wonders if that was once a backwards compat hack or something ... I've forgotten why I did it that way now.

[13:13] <masak> ooh, interesting. that fails, with "Could not find 'self'"!

[13:13] <lizmat> ah, of course

[13:13] <masak> of course?

[13:13] <lizmat> samewith is for methods...

[13:13] <masak> m: multi MAIN() { samewith('foo') }; multi MAIN('foo') { "foo'd you!" }

[13:13] <camelia> rakudo-moar 2904f3: OUTPUT«Could not find 'self'␤  in sub MAIN at /tmp/b9x1yueixg:1␤  in block <unit> at /tmp/b9x1yueixg:1␤␤»

[13:14] <masak> how is samewith for methods?

[13:14] *** brrt joined
[13:14] <japhb> m: multi MAIN() { nextwith('foo') }; multi MAIN('foo') { "foo'd you!" }

[13:14] <camelia> rakudo-moar 2904f3: ( no output )

[13:14] <ShimmerFairy> Wouldn't it be nextwith/callwith ?

[13:14] <japhb> m: multi MAIN() { nextwith('foo') }; multi MAIN('foo') { say "foo'd you!" }

[13:14] <camelia> rakudo-moar 2904f3: ( no output )

[13:14] <japhb> What ...?

[13:15] <masak> japhb: I think `nextwith` uses the original list of candidates...

[13:15] <japhb> m: multi MAIN() { callwith('foo') }; multi MAIN('foo') { say "foo'd you!" }

[13:15] <camelia> rakudo-moar 2904f3: ( no output )

[13:15] <japhb> OK, that explains why I did it the old fashioned way, then.

[13:15] <dalek> rakudo/nom: 7b9145f | ShimmerFairy++ | src/core/Temporal.pm:

[13:15] <dalek> rakudo/nom: Improved error message for missing :year in DateTime.new()

[13:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7b9145f08f

[13:17] *** xfix joined
[13:17] *** xfix left
[13:17] *** xfix joined
[13:18] *** _mg_ left
[13:23] <masak> jnthn: are we just unlucky with nextwith/samewith/callwith above, or is something broken, or have we misunderstood their purpose altogether?

[13:23] <masak> does &?ROUTINE refer to a single candidate, or to all of them?

[13:24] <jnthn> masak: nextwith/callwith iterate the existing candidate list

[13:24] <jnthn> masak: If you supply incompatible arguments, that's your problem

[13:25] <jnthn> samewith...I don't know, I think lizmat++ added that and I think it re-dispatches

[13:25] <jnthn> But I don't see why it coudln't handle subs too

[13:25] <jnthn> I mean, callwith etc does

[13:25] <masak> right. I was surprised about "only for methods".

[13:25] <masak> oh, well.

[13:25] <lizmat> fwiw, it was one of my first implementations

[13:25] <jnthn> I don't immediately see why we can't liberalize it to all routines

[13:25] <lizmat> and I actually eradicated it from the core itself because of the overhead involved

[13:25] <masak> it's not like MAIN is going to be refactored to have another name :) might as well write `MAIN` :)

[13:26] <masak> lizmat: mind if I submit a rakudobug for it not working with subs?

[13:26] <lizmat> I don't  :-)

[13:26] * masak submits rakudobug

[13:34] <masak> obviously, `samesame` is missing from the set we currently spec/implement ;)

[13:35] <timotimo> m: samesame

[13:35] <camelia> rakudo-moar 2904f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bl347FUvYd␤Undeclared routine:␤    samesame used at line 1. Did you mean 'callsame', 'samecase'?␤␤»

[13:36] <masak> jnthn: S12:954

[13:36] <synbot6> Link: http://design.perl6.org/S12.html#line_954

[13:36] <masak>     nextwith(1,2,3);    # redispatch with a new set of arguments (no return)

[13:36] <masak>     samewith(1,2,3);    # same dispatcher with new arguments (no return)

[13:36] <jnthn> masak: Uhh...

[13:36] <masak> jnthn: makes it sound like it's `nextsame` the gets a new candidate list and `samewith` that keeps l'old one

[13:36] <jnthn> Whoa

[13:36] <jnthn> When did that happen?

[13:37] <masak> nextwith*

[13:37] <masak> so in that case, I'd expect `nextwith` to have worked with MAIN...

[13:37] <jnthn> I think next is the right name though; I mean, you're doing "next" on the candidate list...

[13:37] <jnthn> I think S12 is out of line.

[13:37] <masak> no idea

[13:37] <masak> just reporting a discrepancy

[13:37] <masak> I find that redispatching on the *same* candidate list as the first time is almost never what I want to do anyway.

[13:38] <masak> in fact, I find I don't think naturally in terms of candidate lists when I code. I just think in terms of subs/methods with the same name but different signatures.

[13:38] <jnthn> Remember that delegating to a base class is the most common use of these.

[13:38] <masak> that is true.

[13:38] *** RabidGravy joined
[13:39] <masak> yeah, I can see that use case making sense.

[13:39] <masak> and that doesn't translate well to my MAIN case.

[13:39] <masak> answer from question before: &?ROUTINE refers to a single multi, not to all the multis.

[13:40] <masak> (as one might expect)

[13:40] <jnthn> Oh, I expect it to refer to the leixcally enclosing routine

[13:40] <masak> right.

[13:40] <jnthn> &?ROUTINE.dispatcher # gets you the proto

[13:40] *** _mg_ joined
[13:40] <masak> I'd rather write `MAIN` :P

[13:40] <gtodd> withnext withsame  :)

[13:40] <jnthn> Me too :P

[13:42] *** mr-foobar left
[13:43] *** mr-foobar joined
[13:45] *** telex left
[13:46] *** telex joined
[13:58] <hoelzro> morning #perl6

[13:58] *** abraxxa left
[14:00] <hoelzro> I found some behavior using heredocs, and I'm not really sure what the right thing to do is

[14:00] <hoelzro> https://gist.github.com/hoelzro/3b1ff9951908c9ce5aa4

[14:00] <hoelzro> it's concerning how leading whitespace removal is handled when one has an embedded newline via \n in a heredoc

[14:02] *** g4 left
[14:03] <timotimo> oh, interesting

[14:03] <timotimo> i hadn't considered newlines that are escaped inside heredocs like that when i wrote the new dedenting code

[14:06] <hoelzro> timotimo: I hadn't considered it either until I was converting code that used a single non-heredoc line and came across that =/

[14:06] <hoelzro> I would file a ticket, but I don't even know if that's a bug.  I don't even know what I expect it should do!

[14:07] <timotimo> the latter part is the hard part

[14:08] <hoelzro> indeed

[14:09] <lucasb> Is there a way to dedent the heredoc literal text before expanding newline escape sequences?

[14:09] <hoelzro> TimToady may have to weigh in

[14:11] <timotimo> at the point the dedent code gets a hold of it, the information of literal \n and escaped \n is no longer available ;(

[14:11] <masak> I'm... not sure I feel that's a bug...

[14:11] <timotimo> in theory, the heredoc parser could emit the "required" number of spaces before a \n when it sees one

[14:11] <timotimo> that would get rid of the warning

[14:11] <hoelzro> masak: "not sure" is the thing with me too =/

[14:12] <masak> what I see is a string with a newline with no spaces after it, which is fewer than the four spaces required.

[14:12] <masak> that would normally qualify for the warning we see.

[14:12] <masak> I can understand the argument that this \n newline is not part of the heredoc's actual newlines, but...

[14:12] <timotimo> hehe

[14:13] <masak> ...I'm also not ready to tear up compiler internals just to fix this one.

[14:13] <masak> but let's see if TimToady has some nice insight about it.

[14:14] <colomon> why would you want to embed a \n in a heredoc?

[14:14] <masak> it's kind of related to (but not the same as) http://strangelyconsistent.org/blog/here-be-heredocs under the heading "Indentation, revisited"

[14:14] <masak> colomon: that's a good, but separate question :)

[14:14] <masak> we're exploring "what happens when you do?"

[14:14] <masak> I don't believe it should be illegal.

[14:14] <hoelzro> colomon, masak: there's no good reason, I just found it interesting

[14:15] <masak> it is interesting.

[14:15] <hoelzro> I was converting a long single double quoted string with multiple embedded newlines into a heredoc while refactoring a program

[14:15] <masak> I mean, from the user's point of view, a \n in a heredoc isn't the same as a hard newline in a heredoc.

[14:15] <hoelzro> right

[14:15] *** laouji left
[14:16] <colomon> what happens if you embed a string with a newline in it?  I actually do that quite a bit in my (mostly p5) scripts

[14:16] <masak> and the "Indentation, revisited" section chronicles when we decided (sort or) that only hard newlines should be indented (not newlines in interpolated strings)

[14:16] <masak> colomon: read the blog post I linked.

[14:16] <masak> colomon: there was a debate at some point.

[14:16] <hoelzro> colomon: *that* is a really good question

[14:16] <RabidGravy> hoelzro, you're interested in tutorial stuff have you seen https://www.livecoding.tv/ ?

[14:16] <masak> hoelzro: yes, but it's been *resolved*.

[14:16] <masak> hoelzro: read the post :)

[14:17] <hoelzro> masak: working on it =)

[14:17] <jnthn> I seem to remember I did it one way in the original herdocs impl in Rakudo, and something was off and got changed (probably what masak++ is referencing)

[14:17] <masak> yes.

[14:17] <hoelzro> RabidGravy: I did, but I don't know if I'm brave enough to do it live =S

[14:17] <jnthn> I think I spliced in all the bits and then de-dented or something

[14:17] <timotimo> that's right

[14:17] <masak> yes.

[14:17] <hoelzro> what's on YT is the result of lots of preperation, re-takes, and edits

[14:17] <masak> which was surprising to users.

[14:18] <timotimo> hoelzro: how long did it take you for just the recording phase?

[14:18] <masak> timotimo++ implemented the less surprising behavior for indentation.

[14:18] <hoelzro> timotimo: I just had to do two takes, so I think 20-30m?

[14:18] <jnthn> *nod*

[14:18] <jnthn> Yeah, the examples were pretty convincing.

[14:18] <hoelzro> the live RT fixing took me a lot more takes, about 1h, iirc

[14:19] <timotimo> <3

[14:19] <masak> jnthn: not at first... it's one of the few times when I as a user supplied what I felt was a clear bug, and you as a compiler implementor gave a response equivalent to "orka!" :P

[14:19] <masak> jnthn: but that's all Yeti under the bridge. it works as expected now. :)

[14:21] *** khw joined
[14:22] <dalek> rakudo/nom: 9efa091 | lizmat++ | src/core/Backtrace.pm:

[14:22] <dalek> rakudo/nom: Fix error in Backtrace generation, skids++

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9efa091aa9

[14:22] <dalek> rakudo/nom: add2827 | lizmat++ | src/core/array_slice.pm:

[14:22] <dalek> rakudo/nom: Make [*]:v and []:v slices slightly faster

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/add2827039

[14:24] <jnthn> masak: Yes, well, being a compiler writer is one of those tasks where most interactions you have with users are when something doesn't work, 'cus when it does work they've little reason to come to you. And I can be pretty darn human about that sometimes. :)

[14:24] <masak> jnthn: nod. completely understandable.

[14:24] <jnthn> VM writer is even more like that, 'cus mostly folks only get concious of the VM when it says SIGSEGV or panics :P

[14:25] <jnthn> (And yes, I do enjoy working on these things; it's just the nature of working on any infrastructural thing. You're building the stuff that people use to build the exciting shiny stuff, largely. :))

[14:26] <colomon> masak: believe it or not, indented heredocs was one of my main “must have p6 now!!!!” features back in 2004.

[14:27] <colomon> my $work scripts that generate C++ code use heredocs A LOT.

[14:27] <colomon> and the fact that they cannot be indented has very serious effects on the readability of said code.

[14:27] <hoelzro> colomon: hah, that's *exactly* what I was working on

[14:28] <colomon> (err, the perl part, not the c++ part)

[14:28] <hoelzro> C++ generating code

[14:29] <colomon> yes, generating C++ with Perl is one of my main tricks of my $work code

[14:31] <gtodd> colomon:  hehe

[14:32] <timotimo> i had python code that generated c++ code some time ago

[14:32] <masak> jnthn: also worth pointing out that the "torment the implementor" counter-argument is always worth hearing out, even in the cases where we eventually decides to go ahead and make the implementation difficult

[14:33] <masak> colomon: as seen in that blog post, I was a latecomer to being enthusiastic in that way. but I'm all on board now.

[14:34] <RabidGravy> I think for any given pairwise combination of languages I know I've written code in one to generate code in the other

[14:34] <colomon> masak: April of this year?  Yeah, you were a decade behind me.  :)

[14:36] <hoelzro> masak: nice post

[14:37] <gtodd> colomon: so you have a large installed base of commercial production code written in written in perl6

[14:37] *** tinyblak_ joined
[14:38] <gtodd> colomon: written in (written in perl6)

[14:38] <colomon> gtodd: no

[14:38] <colomon> well, guess it depends on what you mean.

[14:38] <gtodd> :-D I'm trying to be irrational here

[14:38] <colomon> I ship C++ source code.  My customers never seen the Perl frame that makes much of it.

[14:39] <hoelzro> it's 4th of July weekend here in the US, so I'll probably not be online much for the rest of the weekend.  later #perl6!

[14:39] <DrForr> Have fun, frighten the wits out of some dogs for me!

[14:40] <colomon> gtodd: also, I’m a pretty conservative coder, so generally the p5 is only changed to p6 when I need to make significant changes in a script.

[14:40] <colomon> gtodd: so probably 75% of it is still p5, even though it would be vastly better in p6.

[14:41] *** tinyblak left
[14:42] *** _mg_ left
[14:43] <colomon> life’s too short to change working code unnecessarily. 

[14:44] <lucasb> I think heredoc whitespace handling should happen very early in the compilation, before things like "\n\n\n $interpolvar { some-huge-text() } etc." gets evaluated. As a user, I think that is what I would expect.

[14:44] <lucasb> But I understand it must be very hard to hook this things into the lexer/parser. There is that rule of knowing at which language one is at a time, so idk if it is possible to process the heredoc before other things.

[14:45] *** gtodd left
[14:46] *** amurf joined
[14:50] *** amurf left
[14:51] <lizmat> I just found some inconsistencies in the use of Whatever slices:

[14:51] <lizmat> m: my @a = ^10; my $b = Whatever; say @a[*]; say @a[$b]

[14:51] <camelia> rakudo-moar 7b9145: OUTPUT«0 1 2 3 4 5 6 7 8 9␤Indexing requires an instance, tried to do: @a[ (Whatever) ]␤  in block <unit> at /tmp/p3vLdfQCe2:1␤␤»

[14:51] <lizmat> m: my %a = ^10; my $b = Whatever; say %a{*}; say %a{$b}

[14:51] <camelia> rakudo-moar 7b9145: OUTPUT«9 7 5 1 3␤9 7 5 1 3␤»

[14:52] *** noganex left
[14:52] <lizmat> so I wonder whether the Whatever slice should be a syntax feature

[14:52] <lizmat> aka, only allowing a literal * to trigger it

[14:52] <lizmat> or whether a Whatever slice should be value driven (as it is now in the hash case)

[14:53] <jnthn> m: say (*).perl

[14:53] <camelia> rakudo-moar add282: OUTPUT«WhateverCode.new␤»

[14:53] <lizmat> in any case, I think the behaviour should be independent of whether it is on an array or on a hash

[14:53] <jnthn> aww

[14:53] <jnthn> m: my $a = *; say $a.perl

[14:53] <camelia> rakudo-moar add282: OUTPUT«*␤»

[14:53] <jnthn> lizmat: Note that * is an instance of Whatever, not just Whatever the type object.

[14:54] <lizmat> m: my $a = *; say $a.defined

[14:54] <camelia> rakudo-moar add282: OUTPUT«True␤»

[14:54] <jnthn> m: my @a = ^10; my $b = Whatever.new; say @a[*]; say @a[$b]

[14:54] <camelia> rakudo-moar add282: OUTPUT«0 1 2 3 4 5 6 7 8 9␤0 1 2 3 4 5 6 7 8 9␤»

[14:55] <lizmat> jnthn: good point

[14:55] <ugexe> m: say [*]

[14:55] <camelia> rakudo-moar add282: OUTPUT«1␤»

[14:55] *** AlexDani` joined
[14:55] <timotimo> m: say [Whatever]

[14:55] <camelia> rakudo-moar add282: OUTPUT«(Whatever)␤»

[14:56] *** noganex joined
[14:56] <ugexe> m: say [*, 2]

[14:56] <camelia> rakudo-moar add282: OUTPUT«* 2␤»

[14:59] <dalek> nqp/multidim: e719094 | jnthn++ | t/moar/02-multidim.t:

[14:59] <dalek> nqp/multidim: Tests for setting up MultiDimArray REPR.

[14:59] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/e719094048

[14:59] *** [Sno] left
[15:02] *** skids joined
[15:03] *** vendethiel left
[15:03] <ugexe> Version needs some Whatever love too it looks like

[15:03] <ugexe> m: say Version.new(*); say Version.new('*')

[15:03] <camelia> rakudo-moar add282: OUTPUT«vWhatever.140438490100392␤v*␤»

[15:05] <lizmat> m: say Version.new(i)   # eek

[15:05] <camelia> rakudo-moar add282: OUTPUT«v0.1.i␤»

[15:06] <timotimo> m: say Version.new("a", "b", "c")

[15:06] <camelia> rakudo-moar add282: OUTPUT«Default constructor for 'Version' only takes named arguments␤  in block <unit> at /tmp/Ua3ZhRrmE_:1␤␤»

[15:06] <timotimo> m: say Version.new("abc")

[15:06] <camelia> rakudo-moar add282: OUTPUT«vabc␤»

[15:06] <timotimo> tee hee

[15:07] *** diana_olhovik_ left
[15:07] *** RabidGravy left
[15:09] <ugexe> m: say Version.new('0.01') cmp Version.new('0.1'); # there is also stuff like this, but with the way versions are i would probably blame the author of the changing version scheme

[15:09] <camelia> rakudo-moar add282: OUTPUT«Same␤»

[15:09] *** vendethiel joined
[15:09] <skids> masak: actually :34x :45y :3width works really well in SVG code.  FWIW.

[15:10] <ugexe> i implemented a better ACCEPTS for Version but its sloppy string chopping 

[15:12] *** domidumont left
[15:13] <timotimo> m: say (:4.5m)

[15:13] <camelia> rakudo-moar add282: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JLOuU19_qZ␤Malformed radix number␤at /tmp/JLOuU19_qZ:1␤------> 3say (:47⏏5.5m)␤    expecting any of:␤        number in radix notation␤»

[15:13] <timotimo> do we want that to work? :P

[15:13] <timotimo> .o( masak says NNNNNOOOOOOoooooo! )

[15:17] *** rurban1 left
[15:19] *** rurban left
[15:20] *** RabidGravy joined
[15:24] *** SmokeMachine_ joined
[15:24] *** rurban joined
[15:26] *** Sqirrel left
[15:28] *** Sqirrel joined
[15:31] *** vendethiel left
[15:33] *** berekuk joined
[15:34] *** vendethiel joined
[15:37] *** jack_rabbit joined
[15:42] *** zakharyas left
[15:43] <lucasb> To me, Whatever is just a special value like Nil. Why is it needed more than one instance of it? Why is it needed instances of it at all, since you can treat a typeobject as a value, just like Nil?

[15:43] <lucasb> If Nil === Nil.new, so why not have Whatever === Whatever.new === * === $var-holding-whatever? This way, constructs that work if one kind, would work with all 4 representations the same way.

[15:49] *** jack_rabbit left
[15:49] <lucasb> m: say (* + 2)(3)

[15:49] <camelia> rakudo-moar add282: OUTPUT«5␤»

[15:49] <lucasb> m: say { $^a + 2 }(3)

[15:49] <camelia> rakudo-moar add282: OUTPUT«5␤»

[15:49] <lucasb> What are the differences between these two? After a WhateverCode is constructed, it as special as a normal subroutine/block with arguments, right? Why differentiate then?

[15:50] <masak> colomon: heh, I got convinced quite some time ago :)

[15:50] <masak> skids: no, that still qualifies as a "bad use" to me. "34 x" and "3 width" don't sound good when read out loud. "2nd" and "2 years" do.

[15:51] <skids> masak: I try never to read anything XMLish out load though. :-)

[15:58] <skids> masak: When "reading out load" X,Y coordinates, like longitude, latitude, the number is often read first.

[16:01] *** Akagi201_ left
[16:07] <dalek> nqp/multidim: 42bece2 | jnthn++ | t/moar/02-multidim.t:

[16:07] <dalek> nqp/multidim: Test set/introspect dimensions of multi-dim array.

[16:07] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/42bece2b89

[16:14] <masak> skids: well, not liking how :3x looks is subjective. but I don't like how it looks.

[16:14] <skids> :-) it is a bit of a weird feature

[16:15] <timotimo> :3x looks like a cat with a bow tie

[16:15] <timotimo> so of course i like how it looks :)

[16:16] <TimToady> :3D  <- happy cow

[16:16] * masak .oO( "in 2015, we realized where the language was heading, and just renamed it LOLCAT 6..." )

[16:17] <masak> or LOLCOW 6

[16:17] <timotimo> COWCODE

[16:18] <jnthn> .oO( "the top type was also renamed to Moo" )

[16:18] * skids wishes someone with too much time on their hands would leverage locales for humorous purposes.

[16:18] <timotimo> LC_MESSAGES="angry"

[16:19] <skids> LC_MESSAGE="pirate"

[16:19] *** berekuk left
[16:20] <skids> or lolcat, or comicbookguyfromthesimpsons

[16:20] <geekosaur> https://github.com/crawl/crawl/blob/master/crawl-ref/source/lang-fake.cc :p

[16:21] <TimToady> but you have to specify which kind of pirate, fr.pirate, es.pirate, en.pirate...

[16:21] <geekosaur> although less so than it used to be, since it's filters now instead of pretending to be actual languages

[16:21] *** uncleyear left
[16:23] *** uncleyear joined
[16:23] *** tinyblak_ left
[16:24] <skids> .oO(is t/spec/S24-testing/line-numbers.t failing for anyone else or is that my new code)

[16:24] *** _mg_ joined
[16:25] <geekosaur> I'll be spectesting a just-finished pull-and-build in a couple minutes...

[16:26] *** VinceDee joined
[16:29] <geekosaur> (and then see if I can figure out a prototype for that \sigil warning from list discussion)

[16:30] <skids> \sigil warning?

[16:31] <skids> (which list?)

[16:32] <geekosaur> p6u but I don't see it in the archive yet. subject "Passing a hash to a subroutine: best method?"

[16:33] <geekosaur> oh, archive direct page lands in june, whoops :)

[16:33] *** _mg_ left
[16:33] <geekosaur> http://www.nntp.perl.org/group/perl.perl6.users/2015/07/msg2148.html

[16:34] *** amurf joined
[16:35] <skids> Ah.

[16:39] *** amurf left
[16:39] *** brrt left
[16:41] *** vendethiel left
[16:42] *** tinyblak joined
[16:42] <geekosaur> t/spec/S24-testing/line-numbers.t                           (Wstat: 65280 Tests: 0 Failed: 0)

[16:42] <geekosaur> think that'd be a "yes" :)

[16:43] <skids> That is probably also what is breaking panda install Inline::Perl5

[16:44] <nine> skids: that's broken?

[16:44] <skids> Maybe the new run() stuff.

[16:44] <skids> nine: via a submodule

[16:45] <skids> erm, dependency

[16:48] *** rurban left
[16:51] <masak> geekosaur: I don't think %() is the opposite of \

[16:51] <timotimo> http://t.h8.lv/early_deaths_percentage.html - i'd be interested to learn if anybody makes sense of the "early deaths" numbers that can be found where the Allocations are

[16:51] <geekosaur> no, it's not

[16:51] <timotimo> jnthn: also for you -^

[16:51] <skids> nine: File::Directory::Tree fails its test suite in much the same way as t/spec/S24-testing/line-numbers.t

[16:52] <geekosaur> but if you're an experienced perl5 programmer, it *looks* like \%foo / %$foo

[16:52] <geekosaur> (the former making a ref and the latter dereferencing it)

[16:52] <geekosaur> (and the generalized form of the latter being %{expr}

[16:53] <geekosaur> )

[16:53] *** vendethiel joined
[16:53] <timotimo> 90.5% early deaths for Scalar objects seems good

[16:54] <jnthn> The IntAttrRef survival rate is...curious

[16:54] <timotimo> "109.73% early deaths" ... that's curious :S

[16:55] <timotimo> i must be dividing by the wrong value

[16:55] <DrForr> It done kilt 'em *good*.

[16:55] <skids> I think I might be ready to unleash the new .assuming I've been working on.  Needs https://github.com/rakudo/rakudo/pull/454 first though.

[16:55] <timotimo> what are all those numbers %)

[16:56] <skids> .oO(zombie scalars oh noes)

[17:01] <timotimo> i don't get it :)

[17:02] *** diana_olhovik_ joined
[17:02] *** Akagi201 joined
[17:03] <DrForr> I for one welcome our new weakly typed overlords.

[17:03] <dalek> nqp/multidim: 4219437 | jnthn++ | t/moar/02-multidim.t:

[17:03] <dalek> nqp/multidim: Tests for atposnd/bindposnd for multi-dim array.

[17:03] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/4219437721

[17:04] <jnthn> I don't always program in 30C+, but when I do I write lots of tests...

[17:04] <timotimo> i've apparently forgotten to build another hash to accumulate some data differently

[17:04] <jnthn> dinner &

[17:06] <timotimo> damn, i misinterpreted ... i think

[17:08] <timotimo> the html app for the profiler is kinda hard to grok

[17:08] <timotimo> i have a need for a nap, i think

[17:09] *** xfix left
[17:13] *** Akagi201 left
[17:28] *** domidumont joined
[17:37] <lucasb> so, there was some change recently about run external programs?

[17:37] <lucasb> maybe that's why S24-testing/line-numbers.t is failing

[17:37] <skids> FROGGS++ did some IO related stuff.

[17:37] <lucasb> It tries to match qqx[$cmd] ~~ /.../

[17:38] <lucasb> but since qqx failed, well, it dies. or so I think

[17:41] <geekosaur> hm, so on the assumption that most intended captures are \(...) I added a warning to the other case; I should figure out how to only warn about it once, though.

[17:44] <geekosaur> ...and guess I need to be more specific, since \key won't be a p5-ism (but *is* in the setting)

[17:46] <TimToady> and please be sure to include the recommendation to parenthesize if you really mean it

[17:48] <ugexe> lucasb: it fails because it tries to use a non-existant directory

[17:48] <lucasb> ugexe: if we are talking about the same dir, it exists here on my end

[17:49] <lucasb> I added a "...; true" to the line $cmd = "$*EXECUTABLE $full-path 2>&1; true";

[17:49] *** yqt joined
[17:49] <lucasb> so that the command always returns success

[17:49] *** spider-mario joined
[17:49] <lucasb> What is a cleaner way of running a program you expect to fail, but just want the output? My work-around is silly, but it worked :)

[17:49] <ugexe> ah so it works, its just the wrong exit code?

[17:49] <geekosaur> yes, I will add that (esp. since I was looking at one such to make sure I was doing the right thing :)

[17:50] <ugexe> btw, "true" is an exitcode of 0

[17:50] <geekosaur> right now I'm testing with the first cut, just to get some idea of whether it's a sane text

[17:50] <geekosaur> *test

[17:51] <lucasb> yeah, exitcode of 0 is success, right? :)

[17:51] <geekosaur> you hope :)

[17:52] <TimToady> .tell pmichaud I'm going to assume that, if you're prototyping the new efficient underpinnings as a module, I can safely work on removing most flatteners from the API, so we have more time to work out the programmer-visible gotchas (or in other words, Break All The Things sooner rather than later)

[17:52] <yoleaux> TimToady: I'll pass your message to pmichaud.

[17:53] *** yqt left
[17:54] <ugexe> QX inherits stderr already

[17:55] <lucasb> does it joins stdout and stderr in the same output? idk, I was just taking a look at why the code was failing

[17:56] <lucasb> s/join/merge/

[17:56] <ugexe> its supposed to i think. or give you 2 streams

[17:56] <ugexe> but right now that doesnt work

[17:57] <geekosaur> heh, I think this might be my first submission since I derailed the original smartmatching in 2007 or thenabouts :)   (still spectesting to validate it)

[17:57] <ugexe> there is also a bug where if you try to call .status before you .close on the stderr/stdout, then it will give a bad exitcode even though the command will have executed successfully

[17:57] <ugexe> seems that whatever reads the pipe buffer fails to close the stream for some reason and waits forever

[18:00] <ugexe> you are right though. its busted.

[18:02] *** espadrine left
[18:05] *** nys joined
[18:07] <TimToady> re \n in heredocs, the dedent should be happening before \n interpolation, just as it happens before $I-contain-a-newline interpolation

[18:09] <TimToady> so re http://irclog.perlgeek.de/perl6/2015-07-03#i_10845432 I'd call it a bug

[18:10] *** yqt joined
[18:11] *** Akagi201 joined
[18:14] <TimToady> recall that dedent is only for the purposes of establishing a false margin on the literal text, so from the user's perspective it really needs to happen before any kind of string processing

[18:16] <TimToady> I can think of several ways to fix it

[18:17] <TimToady> one is to treat \n interpolation more like $newline interpolation

[18:17] *** Akagi201 left
[18:17] *** nowan left
[18:17] <TimToady> another is to substitute a sentinel character for \n inside heredoc parsing, and only dedent after the sentinel (and replace the sentinel with a real \n)

[18:20] * geekosaur got one unexpected fail, checking if that's because spectest is now ahead of his source or if it's related to his change

[18:21] <TimToady> if it's t/spec/S24-testing/line-numbers.t, that's been failing for a while

[18:21] <geekosaur> no, that one was why I said "unexpected fail" :)

[18:21] *** [Sno] joined
[18:22] *** bjz_ joined
[18:22] *** Sqirrel left
[18:22] *** Sqirrel joined
[18:23] <TimToady> well, there are still some flappers

[18:23] *** bjz left
[18:28] <geekosaur> looks like it was a flap indeed, no error this time around

[18:30] *** zakharyas joined
[18:32] *** _mg_ joined
[18:36] *** tinyblak left
[18:36] *** zakharyas left
[18:36] <AlexDani`> Hm, I remember there was a way to group some of the regexes in a grammar, so that using <thatgroupname> will result in using one of the regexes of that group, OR SOMETHING, I don't really remember what was that thing. Maybe there was no such thing at all and I made it up. Does anybody know what I'm talking about?

[18:39] <jnthn> protoregexes?

[18:39] <ugexe> proto token scheme {*}; token scheme:sym<http> { <sym> }; token scheme:sym<https> { <sym> }

[18:40] *** noganex left
[18:41] <AlexDani`> yea!

[18:41] <AlexDani`> thanks

[18:41] *** tinyblak joined
[18:41] *** noganex joined
[18:46] *** noganex_ joined
[18:46] *** noganex left
[18:52] <AlexDani`> Is it possible to negate a regex? Like match a thing that is NOT something. Or 'after' and 'before' are the only ways to do that?

[18:52] <masak> AlexDani`: !~~

[18:53] <AlexDani`> masak: um, but in a grammar?

[18:53] <geekosaur> I should redo my repo as a github fork so I can pull-request...

[18:53] <jnthn> Note that for <before <foo>> and <!before <foo>> can be expressed as <?foo> and <!foo> respectively

[18:54] <AlexDani`> oh, so it is just <!foo>

[18:54] <jnthn> Yeah. Note that it's still a zero-width assertion

[18:54] <AlexDani`> oh

[18:54] <jnthn> If you have a rule that matches a single char then you can use it as if it was a char class

[18:54] * masak submits TimToady-approved heredoc n de-indentation rakudobug

[18:54] <jnthn> <-foo>

[18:55] <AlexDani`> jnthn: this actually makes sense. Thanks

[18:55] <jnthn> So <-alpha> means nything non-alphabetic.

[18:55] <jnthn> darn my any key isn't working...

[18:56] *** tinyblak left
[18:56] <AlexDani`> jnthn: although I wonder why that single char limitation exists. Theoretically it can work with any fixed-width regex, no?

[18:57] <jnthn> AlexDani`: Yeah but...how do we know the width? :)

[18:58] <jnthn> You can always write <!foo> .**4 if it were 4 wide, for example

[18:58] <AlexDani`> jnthn: I don't know, but I remember seeing something like that in perl5

[18:58] <skids> m: my multi bar ($) { }; my sub foo () { my $q := bar($q); }; foo();

[18:58] <camelia> rakudo-moar add282: OUTPUT«(signal SEGV)»

[18:58] <AlexDani`> like "sorry, this regex is not fixed-width, I cannot do lookaround with this+

[18:58] <AlexDani`> "

[19:00] *** VinceDee left
[19:01] <skids> ah, RT#125371 maybe

[19:01] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125371

[19:02] *** nowan joined
[19:02] <skids> I'll tack it on there as a potentially-related.

[19:03] * timotimo answerized Tom on p6u

[19:06] <dalek> nqp/early_death_percentage: 3268d38 | timotimo++ | src/vm/moar/profiler/template.html:

[19:06] <dalek> nqp/early_death_percentage: profiler template changes for "early death percentage"

[19:06] <dalek> nqp/early_death_percentage: 

[19:06] <dalek> nqp/early_death_percentage: currently sometimes displays values above 100%

[19:06] <dalek> nqp/early_death_percentage: review: https://github.com/perl6/nqp/commit/3268d38e67

[19:07] *** bin_005 joined
[19:07] *** nowan left
[19:16] <lucasb> Would you agree if I said these contextualizers @(...), %(...) play *two* roles? They serve both to "dereference" an itemized aggregate and also as an aggregate constructor. I think I don't like they having both roles.

[19:21] <masak> in timotimo++'s recent posting to p6u, is there something *theoretically* standing in the way of the typechecker going "hm, I have this constant `[1, 2, 3]` which will never work against the constraint `Int @bar`, but it *would* if I instantiated the array as an Array[Int]... so let's quietly do that behind the scenes" ...?

[19:22] <masak> (I suspect it's possible but a bad idea, just like a lot of silent "fixing up" of failure conditions are a bad idea)

[19:23] <timotimo> if you do it for constants only, you'll confuse the user when they extract that constant into a variable, i suppose

[19:23] *** Begi joined
[19:24] <masak> ...yeah.

[19:24] <timotimo> i could see "here's a unified patch to fix that problem", though :P :P

[19:24] <masak> right, it's like putting a patch on a leak, only to discover that the user is now dismayed by a bunch of leaks further out.

[19:24] <masak> such a unified patch would need to do a lot of code flow analysis.

[19:25] <masak> if I'm understanding you correctly, that is

[19:27] <jnthn> I'm not sure "let's quietly do this O(n) operation on a potentially infinite thing BEHIND THE SCENES" is a great idea. ;)

[19:27] *** nowan joined
[19:28] <TimToady> lucasb: yes, but with the GLR we're de-emphasizing itemization to the point where it will be less of an issue

[19:28] <jnthn> More generally, though, I don't get why people choose to opt in to stricter typing, then complain when they have to make some effort to follow the very rules they chose for themselves.

[19:28] <timotimo> :)

[19:29] <Begi> Jonathan, I'd like tell you THANKS for your talks !

[19:30] <jnthn> Begi: Welcome. I'm looking forward to the next round this summer :)

[19:30] <TimToady> we might have some sugar on the caller end that says "please coerce the rest of this list to the nominal type we bind to"

[19:31] <lucasb> TimToady: thanks!

[19:31] *** nowan left
[19:32] <TimToady> also, @() and %() are coercers, not obligate constructors

[19:32] <masak> nice long de-indentation bug summary here: https://rt.perl.org/Ticket/Display.html?id=125543

[19:32] <TimToady> whereas [] and {} are obligate constructors/composers

[19:33] <TimToady> but your question does relate to a fundamental issue we have to nail down with the GLR, which is detangle the two meanings of .list, which has the same 2-function problem

[19:33] <lucasb> If @() and %() don't get an itemized aggregate of the right type as their first and only argument, they work (more or less) like constructors: @(1,2,3), %{a=>1,b=>2}

[19:34] <jnthn> lucasb: @(1,2,3) is just syntax sugar for (1,2,3).list, and % for .hash

[19:34] <jnthn> And 1,2,3 in Perl 6 is a first-class thing that can be coerced

[19:35] <TimToady> I consider .list to be the real amibiguity, because we use it to iterate things, as well as to coerce to list

[19:35] <TimToady> and those are really two different things

[19:36] *** domidumont left
[19:37] <lucasb> After the GLR, the [] vs []<> and {} vs {}<> will still exist?

[19:37] <TimToady> no

[19:37] <TimToady> [] and {} will no longer itemize

[19:37] <TimToady> nor will [] flatten inside

[19:38] *** VinceDee joined
[19:39] <TimToady> we might or might not need a p5flat primitive to flatten the () without flattening []/{}

[19:39] <TimToady> but we don't know if anyone will really want that distinction, post-GLR, other than making it work more like p5

[19:40] <TimToady> or some more general .tree-like method that can choose what to flatten and what not to

[19:40] <lucasb> I may have not understood: post-GLR, my @a = [1,2],[3,4] will be [1,2,3,4] ?

[19:40] <TimToady> no

[19:40] <lucasb> Oh, good :)

[19:40] <TimToady> the outer comma causes you to have two top-level elemens

[19:41] <TimToady> basically one of those spots where we say, just take the top node and iterate it

[19:41] <TimToady> so my @a = [1,2] iterates teh top Array, while my @a = [1,2],[3,4] iterates the top List

[19:42] <TimToady> much like for does currently

[19:42] <TimToady> m: for (1,2) { .say }

[19:42] <camelia> rakudo-moar add282: OUTPUT«1␤2␤»

[19:42] <TimToady> m: for (1,2),(3,4) { .say }

[19:42] <camelia> rakudo-moar add282: OUTPUT«1 2␤3 4␤»

[19:42] <TimToady> [] will work the same after we de-itemize it

[19:43] <TimToady> m: for (1,2), { .say }

[19:43] <camelia> rakudo-moar add282: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/4hPVQnKJPu:1␤------> 3for (1,2), { .say }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/4hPVQnKJPu:1␤------> 3for (1,2), { .say }7⏏5<EOL>␤␤»

[19:43] <TimToady> m: for (1,2),Empty { .say }

[19:43] <camelia> rakudo-moar add282: OUTPUT«1 2␤»

[19:43] <TimToady> m: for ((1,2),) { .say }

[19:43] <camelia> rakudo-moar add282: OUTPUT«1 2␤»

[19:44] <TimToady> m: for $(1,2) { .say }

[19:44] <camelia> rakudo-moar add282: OUTPUT«1 2␤»

[19:44] <TimToady> three workarounds if you don't want the outer parens to be ignored

[19:48] <lucasb> It made things clear, thanks

[19:48] *** nnms left
[19:48] *** domidumont joined
[19:49] <dalek> nqp/multidim: caee034 | jnthn++ | t/moar/02-multidim.t:

[19:49] <dalek> nqp/multidim: Test for 3D native packed int array.

[19:49] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/caee034c46

[19:52] <masak> the THIRD DIMENSION

[19:56] *** nowan joined
[19:56] *** mr-foobar left
[19:56] *** darutoko left
[19:59] *** raiph left
[19:59] *** Akagi201 joined
[20:04] *** domidumont left
[20:06] *** Akagi201 left
[20:06] <ugexe> pr sent to allow setting cwd of proc::async proccess via await $proc.start(CWD => "/some/other/path"); instead of always using $*CWD

[20:07] <RabidGravy> works for me

[20:08] <ugexe> keeps one from having to do the chdir shuffle if you have to send relative file paths as an argument to whatever you want to run

[20:11] *** _mg_ left
[20:11] *** amurf joined
[20:12] <dalek> rakudo/nom: d67674b | (Nick Logan)++ | src/core/Proc/Async.pm:

[20:12] <dalek> rakudo/nom: allow Proc to be started in any directory

[20:12] <dalek> rakudo/nom: 

[20:12] <dalek> rakudo/nom: Allows the use of relative file path arguments to `$!path` to work.

[20:12] <dalek> rakudo/nom: 

[20:12] <dalek> rakudo/nom: This allows avoiding CWD related boilerplate like:

[20:12] <dalek> rakudo/nom: 

[20:12] <dalek> rakudo/nom:     my $cwd-bak = $*CWD;

[20:12] <dalek> rakudo/nom:     chdir("/home/foo");

[20:12] <dalek> rakudo/nom:     # execute some process that expects CWD to be /home/foo

[20:12] <dalek> rakudo/nom:     chdir($cwd-bak);

[20:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d67674bf51

[20:12] <dalek> rakudo/nom: c28ad62 | lizmat++ | src/core/Proc/Async.pm:

[20:12] <dalek> rakudo/nom: Merge pull request #459 from ugexe/patch-7

[20:12] <dalek> rakudo/nom: 

[20:12] <dalek> rakudo/nom: allow Proc::Async to be started in any directory

[20:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c28ad62c91

[20:15] * jnthn wonders a little about the uppercase parameter name...

[20:15] <geekosaur> probably shouldn't be, although I can see why

[20:16] <ugexe> its used in IO that way which is why. not a good reason i admit, but i didnt really think about it :)

[20:16] *** amurf left
[20:18] <lizmat> m: my $q := $q.foo

[20:18] <camelia> rakudo-moar add282: OUTPUT«Cannot call method 'foo' on a null object␤  in block <unit> at /tmp/VohBd_wlEv:1␤␤»

[20:19] <lizmat> I wonder whether we should allow binding a new variable to itself, whether that id directly or not

[20:19] <lizmat> m: my $q := $q

[20:19] <camelia> rakudo-moar add282: ( no output )

[20:19] <lizmat> m: my $q is default(42) := $q

[20:19] <camelia> rakudo-moar add282: ( no output )

[20:19] <lizmat> m: my $q is default(42) := $q; say $q

[20:19] <camelia> rakudo-moar add282: OUTPUT«(signal SEGV)»

[20:19] <lizmat> m: my $q := $q; say $q

[20:19] <camelia> rakudo-moar add282: OUTPUT«(signal SEGV)»

[20:19] <geekosaur> somehow I had a feeling that was going to happen

[20:20] <lizmat> I know it's a matter of DIHWIDT

[20:20] <TimToady> no, it's a matter of nobody's implemented stringifying recursive structures yet

[20:21] <jnthn> That one is because we optimize such lexicals into locals, and there's some mishandling of nullness there

[20:21] <jnthn> I've known the issue for a while, but it didn't reach top of the list yet, not least 'cus it's always a NULL it hits rather than an exploitable... 

[20:22] <jnthn> Will make srue to deal with it ahead of the .birthday release.

[20:22] <TimToady> m: my $q := $q; say $q.DEFINITE

[20:22] <camelia> rakudo-moar add282: OUTPUT«False␤»

[20:23] <TimToady> m: my $q := $q; say $q.WHAT

[20:23] <camelia> rakudo-moar add282: OUTPUT«(signal SEGV)»

[20:24] <lizmat> m: my $q := $q; $q.gist   # don't think the SEGV is because of the stringification

[20:24] <camelia> rakudo-moar add282: OUTPUT«Cannot call method 'gist' on a null object␤  in block <unit> at /tmp/DHb7uZHQak:1␤␤»

[20:25] <TimToady> nod

[20:25] <dalek> rakudo/nom: 1d82c95 | usev6++ | src/core/Mu.pm:

[20:25] <dalek> rakudo/nom: Prevent calling .clone with new attributes affect the original

[20:25] <dalek> rakudo/nom: 

[20:25] <dalek> rakudo/nom: fixes RT #118559

[20:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1d82c95b56

[20:25] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118559

[20:25] <dalek> rakudo/nom: 362c456 | lizmat++ | src/core/Mu.pm:

[20:25] <dalek> rakudo/nom: Merge pull request #448 from usev6/rt118559

[20:25] <dalek> rakudo/nom: 

[20:25] <dalek> rakudo/nom: Prevent calling .clone with new attributes affect the original

[20:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/362c456a5b

[20:28] *** Begi left
[20:31] <dalek> nqp/multidim: d3dbc81 | jnthn++ | t/moar/02-multidim.t:

[20:31] <dalek> nqp/multidim: Test we can't do dimension-changing ops.

[20:31] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/d3dbc81316

[20:31] <dalek> nqp/multidim: 37bf89d | jnthn++ | t/moar/02-multidim.t:

[20:31] <dalek> nqp/multidim: Fix thinkos in tests.

[20:31] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/37bf89da63

[20:31] <dalek> nqp/multidim: 1092020 | jnthn++ | t/moar/02-multidim.t:

[20:31] <dalek> nqp/multidim: Tests for atpos/bindpos ops on MultiDimArray.

[20:31] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/1092020ccc

[20:31] <ugexe> it seems a similar cwd parameter will work for Proc.pm's new spawn/shell/run commands. time for more tests

[20:33] *** espadrine joined
[20:33] *** mr-foobar joined
[20:42] <ugexe> if i were to submit a similar pr for that, should i use 'cwd' or 'CWD'?

[20:46] <TimToady> cwd seems fine to me

[20:47] <dalek> nqp/multidim: 4b77efd | jnthn++ | t/moar/02-multidim.t:

[20:47] <dalek> nqp/multidim: Another few thinko fixes.

[20:47] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/4b77efd565

[20:47] <dalek> nqp/multidim: fac0b5c | jnthn++ | t/moar/02-multidim.t:

[20:47] <dalek> nqp/multidim: Test elems/setelems ops on MultiDimArray REPR.

[20:47] <dalek> nqp/multidim: review: https://github.com/perl6/nqp/commit/fac0b5c7f8

[20:51] <ugexe> i see the light now. with a sig of ($CWD = $*CWD), it never saves the user anything as calling func(:$*CWD) is redundant. But in IO:: modules its binding to attributes and whatnot

[20:57] *** diana_olhovik_ left
[20:58] *** lucasb left
[21:03] <moritz> m: sub f(Int() @a) { say @a.join }; f [1, 2, 3]

[21:03] <camelia> rakudo-moar 362c45: OUTPUT«Type check failed in binding @a; expected 'Positional[Any]' but got 'Array'␤  in sub f at /tmp/VU1E0y65N3:1␤  in block <unit> at /tmp/VU1E0y65N3:1␤␤»

[21:03] <moritz> m: sub f(Int(Mu) @a) { say @a.join }; f [1, 2, 3]

[21:03] <camelia> rakudo-moar 362c45: OUTPUT«Type check failed in binding @a; expected 'Positional[Mu]' but got 'Array'␤  in sub f at /tmp/YnUpt5_ljK:1␤  in block <unit> at /tmp/YnUpt5_ljK:1␤␤»

[21:03] *** bin_005 left
[21:05] <moritz> m: my Int @a = 1, 2, 3; say @a

[21:05] <camelia> rakudo-moar 362c45: OUTPUT«1 2 3␤»

[21:06] <dalek> roast: d466fc7 | usev6++ | S32-array/push.t:

[21:06] <dalek> roast: Add test for RT #112660

[21:06] <dalek> roast: review: https://github.com/perl6/roast/commit/d466fc79bb

[21:06] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=112660

[21:07] *** TimToady left
[21:09] *** TimToady joined
[21:11] <timotimo> moritz: that'd just parameterize the "wanted" type with a coercive type, not coerce on assignment. but cute idea anyway

[21:13] <dalek> roast: e84a51c | usev6++ | S32-array/push.t:

[21:13] <dalek> roast: Adjust test to make description clearer

[21:13] <dalek> roast: review: https://github.com/perl6/roast/commit/e84a51c10e

[21:15] * moritz just wrote a longish rant to p6u about typed arrays

[21:16] *** TEttinger joined
[21:16] <timotimo> uh oh

[21:20] *** Sqirrel left
[21:21] *** nowan left
[21:21] *** bin_005 joined
[21:22] <masak> moritz++ # good rant :)

[21:22] <masak> moritz++ # "yours ranting"

[21:23] <geekosaur> rantiloquent

[21:24] *** nowan joined
[21:25] <skids> m: https://gist.github.com/skids/d1552470ba7c4ca6d3

[21:25] <camelia> rakudo-moar 362c45: OUTPUT«gist not found»

[21:29] *** rindolf left
[21:30] <skids> (That gist is what I found irksome about Cursor)

[21:41] *** VinceDee left
[21:48] *** Akagi201 joined
[21:50] *** rurban joined
[21:51] <timotimo> it's a 404, though

[21:54] *** Akagi201 left
[21:55] <skids> Oh, I thought camelia was just not doing gists still.  What did I... oh https://gist.github.com/skids/d1552470ba7c4ca6d318 selection fail.

[21:58] *** awwaiid left
[21:58] <jnthn> 'night, #perl6

[21:59] <timotimo> gnite jnthn 

[21:59] *** kaare_ left
[21:59] <RabidGravy> erp

[21:59] <timotimo> and plane well tomorrow :)

[21:59] <jnthn> Thanks! :)

[21:59] <jnthn> o/

[22:01] *** awwaiid joined
[22:01] *** amurf joined
[22:01] <timotimo> it won't be terribly hot on the plane at least :)

[22:06] *** amurf left
[22:16] *** spider-mario left
[22:16] *** telex left
[22:17] <masak> 'night, #perl6

[22:18] *** telex joined
[22:28] *** espadrine left
[22:34] *** Akagi201 joined
[22:39] *** colomon left
[22:42] <dalek> rakudo/nom: 0c88527 | lizmat++ | src/core/Mu.pm:

[22:42] <dalek> rakudo/nom: Fix .clone issues a bit better

[22:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0c88527472

[22:43] *** vendethiel left
[22:44] <dalek> roast: fa49fa9 | lizmat++ | S12-attributes/ (2 files):

[22:44] <dalek> roast: Unfudge now passing .clone test, fixes #118559

[22:44] <dalek> roast: review: https://github.com/perl6/roast/commit/fa49fa9374

[22:44] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118559

[22:46] * lizmat calls it a day as well

[22:46] <lizmat> so good night, #perl6!

[22:47] <skids> o/

[22:48] *** vendethiel joined
[22:50] *** rurban left
[23:02] <skids> https://github.com/skids/rakudo/tree/assuming_alpha buildable snapshot of my current .assuming work if anyone wants to play with it.  Everything of consequence is in src/core/Block.pm

[23:13] *** BenGoldberg joined
[23:13] *** newbie joined
[23:13] *** yqt left
[23:13] *** newbie left
[23:14] <dalek> DBIish/pg-config: 7e5eff5 | lembark++ | .gitignore:

[23:14] <dalek> DBIish/pg-config: ignore editor cruft

[23:14] <dalek> DBIish/pg-config: review: https://github.com/perl6/DBIish/commit/7e5eff5ce9

[23:14] <dalek> DBIish/pg-config: 9b7f194 | lembark++ | t/ (4 files):

[23:14] <dalek> DBIish/pg-config: use PG environment variables to configure connection; update POD to avoid user having to pre-create hardwired database and user

[23:14] <dalek> DBIish/pg-config: review: https://github.com/perl6/DBIish/commit/9b7f194676

[23:14] *** dj_goku joined
[23:16] *** RabidGravy left
[23:17] <japhb> skids: What are you changing about .assuming?

[23:18] <skids> japhb: https://github.com/skids/rakudo/commit/975e9892d2c597a0083f47041debf78856e2e240

[23:20] <skids> And it all started by trying to fix one simple RT :-)

[23:23] *** bin_005 left
[23:23] *** bin_005_j joined
[23:30] *** rvchangue left
[23:30] *** rvchangue joined
[23:31] *** avalenn left
[23:31] *** steve_mc left
[23:31] <japhb> skids: Ah, interesting!

[23:32] *** avalenn joined
[23:32] *** Ben_Goldberg joined
[23:33] *** BenGoldberg left
[23:33] <skids> Eventually will have to figure out whether macros or some sort of MOP are the best approach to ridding it of EVAL.

[23:34] *** steve_mc joined
[23:45] *** virtualsue left
[23:45] *** virtualsue joined
[23:50] *** amurf joined
[23:54] *** amurf left
