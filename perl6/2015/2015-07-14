[00:12] *** tinyblak joined
[00:17] <ugexe> wise to remember that use lib with a relative directory is a free ticket to test failures, as you shouldnt expect the test to take place from a specific CWD

[00:18] *** mohij_ joined
[00:20] <skids> Testing almost always does happen with CWD set to the package root, and almost all packages presume it does when they look for test data files.  It's the de-fact standard and I don't see where the entire ecosystem is going to adjust if some tool decides it wants to do otherwise.

[00:21] <skids> In fact, it's an invitation to failure NOT to do it, as you are more likely to find stale copies of your lib in the install path.

[00:24] <ugexe> its makes any kind of parallelization stupid if you have to watch what CWD you are in at all times

[00:25] <ugexe> if you just invoke your tests with -I or PERL6LIB then a relative path is fine, as the user can control the path

[00:25] <skids> But not all users do that, and that still leaves the issue of where to find data files.

[00:27] <ugexe> whats wrong with $?FILE.IO.dirname.child('data') or wahtever

[00:27] <skids> what's wrong with "use lib $?FILE.IO.dirname('lib')"?

[00:27] <ugexe> you cant use a variable inside a use statement?

[00:28] <skids> Well, maybe we should fix that instead.

[00:28] <skids> Anyway I don't think the larger community is going to sacrific the convenience for the sake a parallelization.

[00:29] *** DarthGandalf left
[00:30] <skids> Better if any tool that wants to run outside the package root make sur it is in a directory with no './lib' present, then problem solved.

[00:30] *** DarthGandalf joined
[00:30] <dalek> rakudo-star-daily: a783cb9 | coke++ | log/ (9 files):

[00:30] <dalek> rakudo-star-daily: today (automated commit)

[00:30] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/a783cb9fc9

[00:30] <dalek> perl6-roast-data: be291aa | coke++ | / (8 files):

[00:30] <dalek> perl6-roast-data: today (automated commit)

[00:30] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/be291aa042

[00:30] <ugexe> precompiled code doesnt have to go in lib or any specific directory

[00:41] <skids> Anyway, use lib "{$?FILE.IO.parent.dirname ~ '/lib'}" does in fact work.

[00:43] <skids> (not that I advise using it.)

[00:59] *** pullphinger joined
[01:00] *** VinceDee joined
[01:06] *** muraiki joined
[01:09] *** BenGoldberg joined
[01:10] *** yeahnoob joined
[01:13] <ugexe> glad to see variable interpolation works in use lib now, sweet. but i wouldnt say the larger community holds a strong opinion on having to be in CWD, and as far as ive always experienced in perl5 you would be encouraged to do it the nearly the same way if reuse is an expectation: use lib $FindBin::Bin/../lib

[01:14] <skids> It's just more convenient for the more hands-on users if they can cd there and not have to use -l/PERL6LIb to run tests.

[01:15] <skids> If you use "use lib './lib'" the only time that blows up is if the user is in another directory with a ./lib with modules with your same name.

[01:15] <skids> While automatic test tools can be coded to avoid that.

[01:15] <skids> So it makes more sense to just put in "use lib './lib'"

[01:16] <ugexe> you dont have to have a /lib. your tests would just fail when they cant find any of the modules

[01:16] *** rmgk_ joined
[01:16] *** rmgk_ is now known as rmgk

[01:17] <skids> If you are running outside the package and running its test, it does not matter if there is a "use lib './lib'" in the test file.  You have to supply the path if you choose to do that.

[01:18] *** muraiki left
[01:18] <skids> The only time it matters is if you try to run version A of the package while your CWD is in version B.

[01:18] <ugexe> ah, i was speaking exclusively

[01:22] <ugexe> i guess i just see it as your average user isnt cding into the project directory themselves and testing anything. they want to run 'install' and be done with it. and ive never felt it was too much for a developer familiar with his enviroment to add a -l or just code his use'es approrpriately

[01:22] <raiph> .ask jnthn I'd love to be able to show off Grammar::Generative... https://github.com/jnthn/grammar-generative/issues/1#issuecomment-121105324

[01:22] <yoleaux> raiph: I'll pass your message to jnthn.

[01:22] <skids> Well, personally I enjoy the convenience of not have to type it, and I'm a developer.

[01:23] <skids> (kinda)

[01:23] <ugexe> do you enjoy it more than all the users who just want to install a module and not have to deal with wierd failures?

[01:24] <ugexe> that is what i am more concerned with

[01:24] <skids> What weird failures?  When will they happen?

[01:25] <ugexe> when panda loses its CWD context through any number of ways

[01:25] *** vendethiel joined
[01:26] <skids> If panda is running tests on the package without caring about its CWD, it is using PERL6LIB, so the presence of a "use lib" in your test files does not matter to it.

[01:26] <raydiak> raiph++ thanks for keeping that issue alive

[01:27] *** kurahaupo joined
[01:27] <ugexe> thats not how it works

[01:29] <skids> I've had 0 problems and had "use lib './lib'" in my test files for years now.  I fail to see any likely scenario where it would cause issues.

[01:29] <raiph> raydiak: I wasn't aware of it. But I have what I consider a perfect use case for GG. I got excited, wrote the grammar first, and then...

[01:29] <ugexe> maybe i just run a lot of tests

[01:30] <kurahaupo> skids: what's the point of "./" there?

[01:30] <skids> I don't think there are many packages with as many tests as Sum.

[01:30] <ugexe> i dont think anyone runs more p6 tests than me

[01:31] <skids> kurahaupo: so if you are in the package's directory you can just run "perl6 t/foo.t"

[01:31] <skids> I just haven't seen an example of an actual problem.

[01:31] *** tinyblak left
[01:31] <kurahaupo> skids: no, that's what "use 'lib'" is for; I'm asking why you inserted the apparently superfluous "./" there

[01:32] <skids> kurahaupo: it's self-documetary.

[01:32] <kurahaupo> or is it not superfluous and actually does something?

[01:33] <raydiak> raiph: I had started writing a shoddy version of something like it before someone pointed it out to me...sadly it hasn't worked for quite a while, it seems 

[01:34] <kurahaupo> skids: putting "use lib blah blah" at the top level is fine. Putting it inside lib files is fraught, because it then depends on what order they're loaded. (I've seen some truly nightmarish systems with multiple levels of overrides of lib files based on putting the same name in different directories...)

[01:34] <skids> kurahaupo: I only use it in t files.

[01:35] <kurahaupo> skids: which are top level, so that's fine

[01:35] <skids> That's all I've been arguing for.

[01:35] *** tinyblak joined
[01:36] <kurahaupo> skids: but what happens when you run cd ~ ; perl6 /path/to/test/perl/t/foo

[01:36] <skids> You have to set a PERL6LIB if you want to find the mods.  Just like if the "use lib" was not there.

[01:37] <kurahaupo> skids: ok, but what about cd /path/to/live/perl ; PERL6LIB=/path/to/test/perl perl6 /path/to/test/perl/t/foo

[01:38] <kurahaupo> skids: is that "use 'lib'" going to override PERL6LIB ?

[01:39] <skids> Dunno, haven't tried actually.  But why would you have a stale copy of my mod in /path/to/live/perl/lib ?  And if you do, you should know what you are doing.

[01:42] <skids> Yes, the "use lib" goes before PERL6LIB so it will be used.

[01:43] <raiph> raydiak: As I hint in the GH issue, GG looks eminently debuggable via jnthn's debugger by someone who knows what an $ast.rxtype is.

[01:46] *** dayangkun joined
[01:47] *** dayangkun left
[01:49] <ugexe> so what happens when you want it to test against the blib instead

[01:50] *** lsm-desktop joined
[01:50] <ugexe> it would get the /lib version first, no?

[01:50] <skids> Don't be in someplace that has someting you don't want to test in "./lib"?

[01:50] <skids> (doctor that hurts...)

[01:51] <ugexe> dont test the precompiled modules. got it

[01:51] <skids> What?

[01:51] *** dayangkun joined
[01:52] <ugexe> how do you test against the blib/, the precompiled modules, if your tests are including 'lib' no matter what

[01:52] <skids> What "blib"?

[01:55] <ugexe> well, taking only panda into consideration, its the directory where your precompiled output goes

[01:56] <skids> Right but the moduleloader finds precomps based on their compiled filename in the database, not by fs search.

[01:56] <ugexe> you can test before installing it

[01:57] <skids> I'm not following the implication.

[01:57] <ugexe> its not in the database anywhere until you install it

[01:57] *** dj_goku joined
[01:58] <ugexe> hence prove having a -b/--blib flag

[01:58] <ugexe> (for when you dont want to test -l)

[01:59] <raydiak> raiph: I had thought about trying to track it down myself, but it's way over my head as-is, temporarily have a day job so lacking solid blocks of time for diving in the deep end like that

[02:00] *** colomon joined
[02:00] *** atroxaper joined
[02:03] <ugexe> and fwiw, it does infact do a fs search for the precomp modules during CompUnitRepo::Local::Installation.install($path)

[02:03] <ugexe> or rather, expects you to hand them over 

[02:04] <ugexe> and iterates over those

[02:04] *** atroxaper left
[02:04] <raiph> raydiak: Sure. I'm poking at it a bit. My first guess is it's some rejig of QAST structure, perhaps a Stmt/Stmts thing. I'll update the issue if I find anything interesting.

[02:06] <raiph> how does one search the commit messages of commits to a repo on GH?

[02:06] *** aborazmeh joined
[02:06] *** aborazmeh left
[02:06] *** aborazmeh joined
[02:06] <raydiak> raiph: exciting :)  good luck!

[02:08] <skids> Well, all I know is I have "use lib './lib'" in there and panda has no problem failing on compile-only bugs when installing.

[02:10] <skids> *precomp-only

[02:11] <skids> but perhaps it would be prudent to add 'blib' to the use lib statement.

[02:12] *** noganex joined
[02:21] <ugexe> if you assume it will always be precompiled to blib. if you use CompUnit.precomp directly it goes in /lib next to your source code

[02:21] <ugexe> in otherwords, you shouldnt expect it to be in any specific spot

[02:24] <ugexe> i have no problem with blib being assumed though. it just doesnt seem to be set in stone anywhere as of yet

[02:27] <skids> All I expect is this: a) automated utilities will deal with it rather than making everyone else at large type -llib  all the time B) people cding into the package and doing things will be abe to just perl6 t/test and C) anyone doing anythin unusual enough to have problems because of it should be prepared for unusual things.

[02:34] <ugexe> i dont think typing -l is asking much of a developer vs user's ease of use, and even more so for the ability for any user to distinguish which lib he wants to test

[02:35] <ugexe> or, just writing your tests in such a way that it doesnt matter what directory they are invoked from

[02:36] <ugexe> dont even get me started on windows

[02:37] <skids> Asking developers to repeatedly do that versus just coding it once into utilities is a no-brainer for the letter IMO.

[02:38] <skids> *latter

[02:38] <ugexe> asking developers not to be able to diferentiate between lib and blib is more insane

[02:39] <skids> I dunno I never used a blib myself.  FWIW it seems panda installs both source and mbc in blib/lib and then runs from inside blib.  I think.

[02:42] <skids> I think working with precomps is a rarer activity than working on source.

[02:42] <skids> If they are going that deep they know how to work around it.

[02:42] *** VinceDee left
[02:43] <ugexe> if you expect your users to do all the extras so the developer doesnt have to, sure

[02:44] <skids> When is a user going to have problems?

[02:44] <ugexe> with?

[02:45] <skids> (I don't mean to be argumentative, btw I'm just trying to understand the supposed issues so I can weigh the decision of what to do.)

[02:46] <skids> What extras are the users supposedly doing?

[02:46] <ugexe> you are asking the user to do whatever is required to fix the test so it can be tested against blib

[02:47] <skids> I would call that a developer, no a user.  A user is more likely to cd into the directory, say "hey these are test files let me perl6 them" and then say "hey why is it still behaving like the old package I used  to have installed"

[02:48] <ugexe> thats the type of person i expect to know better

[02:48] <skids> I don't.

[02:48] <ugexe> i expect a user to just do install essentially

[02:48] <ugexe> most cpanm users do not do cpanm look, cpanm test, cpanm install

[02:49] <skids> right, so, as long as the utilities work around it they never see a problem.

[02:49] <ugexe> but they cant work around a test with use lib '../whatever' other than being in $*CWD

[02:50] <ugexe> so if any of your dependencies or your module it self does a chdir and fails to return, you just end up with errors that wont immediately make sense

[02:50] <skids> Sure they can.  Don't be in the package directory and -lblib.

[02:51] <skids> well -l/path/to/package/blib

[02:51] <ugexe> heres the panda scenario that kept happening over smoke testing: indir 'whatever' { <tests some threaded code that crashes without exiting this block properly> } <now im in the wrong directory>

[02:52] <ugexe> (indir is expected to return to its original directory at the end)

[02:53] <skids> panda should probably stay in the same dir, then, and use explicit paths.

[02:53] <kanl> b2gills: good to know, tyvm!

[02:55] *** BenGoldberg left
[02:55] <ugexe> then panda would have to download the repo over top of whatever directory you are in

[02:55] <skids> No just stay in .panda_work

[02:57] <ugexe> if you have dependencies you have to jump between those at least

[02:58] <skids> just build them al in their own directory while never leaving .panda_work and add lots of search paths.

[02:59] <ugexe> ive already overcome all of these problems myself, but other tooling hasnt

[03:00] <ugexe> the solution is generally spawnning new processes. so it has a rather big drawback of being slow. it would be nice to not have to invoke a new p6 interpreter for each tests to get the neccesary CWD protections from modules gone haywire

[03:01] <skids> Yeah well changing CWD in module code is cheezy IMO.

[03:03] *** kaare_ joined
[03:14] *** colomon left
[03:16] *** telex joined
[03:26] *** colomon joined
[03:43] <ugexe> it may best be solved if/when { temp $*CWD = $&FILE.dirname; } does all the magic and makes it trivial for the user or the developer to work around expectations in an elegant manner

[03:43] *** colomon left
[03:45] *** lizmat joined
[03:45] <ugexe> including whatever heisenbugs are able to break the usual implementations of that without using `temp`

[03:46] <tony-o> i think trying to keep track of 20 search paths for spawning a process is a little more convoluted than just temporarily changing cwd to spawn a process in the directory it should be in originally - then youre hacking prove and whatever else is needed to be in the module root dir

[03:47] *** tinyblak left
[03:50] <tony-o> all the hooks, evwrything else kind of makes the assumption that youre in the root module dir

[03:52] <skids> Well, anyway so far I've settled on 'use lib <blib/lib lib>' and using $?FILE to find data files since they will probably not be ripped out of t/ for any reason.  I think that will be least-average-surprise.

[03:58] <ugexe> use lib IO::Path.new-from-absolute-path("lib".IO.absolute(CWD => $&FILE.dirname).IO.resolve).child('MANIFEST').slurp andthen %(from-json($_)).<provides>>>.values>>.abspath; # this might be safest

[04:00] <skids> I'll parse that tomorrow after sleep :-)

[04:00] <skids> Thanks a lot for the discussion.

[04:00] *** kurahaupo left
[04:06] <ugexe> sure. ive taken up enough chat log for one day myself

[04:10] *** TEttinger joined
[04:18] *** skids left
[04:21] *** AlexDaniel joined
[04:23] <AlexDaniel> how can I create a new sub from a macro?

[04:24] <AlexDaniel> m: macro FOO { quasi { sub Bar { say 'woohooo'}; }; }; FOO; Bar();

[04:24] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PGtnDGc7Nt␤Undeclared name:␤    Bar used at line 1. Did you mean 'Bag'?␤␤»

[04:24] *** vendethiel left
[04:24] <AlexDaniel> it might be a scoping problem?

[04:25] *** vendethiel joined
[04:27] *** atroxaper joined
[04:27] *** atroxaper left
[04:27] *** atroxaper joined
[04:40] <AlexDaniel> m: macro FOO { "sub Bar { say 'woohooo'}" }; FOO; Bar();

[04:40] <camelia> rakudo-moar 533d1a: OUTPUT«woohooo␤===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[04:41] <AlexDaniel> too few positionals? huh?

[04:41] <AlexDaniel> where?

[04:44] <ugexe> m: "sub Bar { say 'woohooo'}"

[04:44] <camelia> rakudo-moar 533d1a: OUTPUT«woohooo␤»

[04:46] <ugexe> $string = "sub Bar" ~ do { say 'woohoo' }

[04:47] *** kurahaupo joined
[04:47] <AlexDaniel> ugexe: what's that? :)

[04:48] <ugexe> the { and } in your double quoted string executes the code inside

[04:48] <AlexDaniel> oooooh

[04:49] <AlexDaniel> m: macro FOO { ‘sub Bar { say 'woohooo'}’ }; FOO; Bar();

[04:49] <camelia> rakudo-moar 533d1a: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[04:49] <AlexDaniel> nope, still don't get it

[04:50] <AlexDaniel> ugexe: that's not the case in single quotes?

[04:51] <ShimmerFairy> m: macro foo { 1 }; foo;

[04:51] <camelia> rakudo-moar 533d1a: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[04:51] <ShimmerFairy> m: macro foo { quasi { 1 } }; foo;

[04:51] <camelia> rakudo-moar 533d1a: ( no output )

[04:51] <ugexe> nope. "" interpolates

[04:52] <AlexDaniel> ugexe: but then I don't get it at all

[04:52] <ugexe> yeah i dont see anything wrong with your syntax after you changed it

[04:53] <ShimmerFairy> Perl6 macros aren't string-based, so I don't know what you're hoping to accomplish there :)

[04:53] <AlexDaniel> ShimmerFairy: not really?

[04:53] <AlexDaniel> "Macros may return either a string to be reparsed, or a syntax tree that needs no further parsing. The textual form is handy, but the syntax tree form is generally preferred because it allows the parser and debugger to give better error messages."

[04:54] <AlexDaniel> from http://design.perl6.org/S06.html#Macros

[04:55] <AlexDaniel> but yeah, I don't want to return a string. How can I create a sub?

[04:57] <ShimmerFairy> The portion you quoted hasn't been touched since 2008. I'd be extremely surprised if that "string to be reparsed" is still considered a part of macros.

[04:59] <AlexDaniel> m: macro FOO { 'say 1' }; FOO;

[04:59] <camelia> rakudo-moar 533d1a: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[04:59] <AlexDaniel> hm

[04:59] <ShimmerFairy> m: macro FOO { quasi { sub Bar { say "woohooo"}; } }; FOO()()

[04:59] <camelia> rakudo-moar 533d1a: OUTPUT«woohooo␤»

[04:59] <ShimmerFairy> Of course, that's probably not what you're after :P

[05:00] <AlexDaniel> ShimmerFairy: nope.

[05:01] <ShimmerFairy> m: macro FOO { quasi { sub Bar { say "woohooo"}; } }; our &Bar = FOO(); Bar  # you could use 'anon sub' or '->' instead of 'sub Bar' in this case

[05:01] <camelia> rakudo-moar 533d1a: OUTPUT«woohooo␤»

[05:01] <ShimmerFairy> I'm not familiar enough with macros to know how to make it work properly, or if it's a bug that the way you're trying isn't working.

[05:03] <AlexDaniel> ShimmerFairy: all this trickery does not help, I need multiple dispatch to work in the end

[05:05] <AlexDaniel> unless there are tricks to make that work...

[05:26] *** AlexDaniel left
[05:29] *** kurahaupo left
[05:35] *** ][Sno][ is now known as [Sno]

[05:50] *** vendethiel left
[05:55] *** davido___ joined
[05:57] *** vendethiel joined
[06:12] <dalek> star: 6571779 | FROGGS++ | tools/star/release-guide.pod:

[06:12] <dalek> star: state that I did the 2015.06 release

[06:12] <dalek> star: review: https://github.com/rakudo/star/commit/6571779257

[06:17] *** FROGGS joined
[06:21] *** vendethiel left
[06:24] *** dayangkun left
[06:29] <JimmyZ>  FROGGS:      2013.03         moritz

[06:29] <JimmyZ> +    2013.06         FROGGS

[06:29] <JimmyZ> FROGGS: it is 2015 now :)

[06:29] <JimmyZ> moritz: ^^

[06:33] <FROGGS> ewww

[06:35] <dalek> star: 40e2bfd | FROGGS++ | tools/star/release-guide.pod:

[06:35] <dalek> star: fix typo in release year, JimmyZ++

[06:35] <dalek> star: review: https://github.com/rakudo/star/commit/40e2bfdb92

[06:35] *** abraxxa joined
[06:44] *** rindolf joined
[06:45] *** diana_olhovik joined
[06:47] *** zakharyas joined
[06:47] <moritz> it is?

[06:48] <moritz> maybe that's why nobody's paying my invoices

[06:48] <FROGGS> :P

[06:48] * FROGGS has to do that on his own too :o(

[06:48] <FROGGS> I want self-paying invoices!

[06:49] *** zostay joined
[06:52] *** verzz joined
[06:53] <moritz> don't need to be self-paying; it's enough if somebody else reliably pays them

[06:54] *** tinyblak joined
[07:04] *** diana_olhovik left
[07:04] <FROGGS> true

[07:10] *** vendethiel joined
[07:11] *** darutoko joined
[07:13] *** kurahaupo joined
[07:19] *** aborazmeh left
[07:23] *** FROGGS left
[07:29] *** RabidGravy joined
[07:33] *** vendethiel left
[07:38] *** FROGGS joined
[07:39] *** vendethiel joined
[07:39] *** tinyblak_ joined
[07:43] *** tinyblak left
[07:45] *** espadrine joined
[07:48] *** amurf left
[07:55] *** g4 joined
[07:55] *** g4 left
[07:55] *** g4 joined
[08:00] *** vendethiel left
[08:06] *** virtualsue joined
[08:09] *** dakkar joined
[08:09] *** vendethiel joined
[08:10] *** coffee` joined
[08:12] *** atroxaper left
[08:12] *** ely-se joined
[08:12] <ely-se> Hello, Perl!

[08:22] <DrForr> Marnin'.

[08:24] *** spider-mario joined
[08:25] <ely-se> Why is MVM register-based instead of stack-based?

[08:25] *** aborazmeh joined
[08:25] *** aborazmeh left
[08:25] *** aborazmeh joined
[08:26] <moritz> ely-se: because it's easier to generate code for register-based machines

[08:26] <moritz> and in terms of performance, both are about the same

[08:27] <ely-se> In my experience generating code for such machines is more difficult.

[08:28] <ely-se> However I can imagine generating machine code _from_ them is easier.

[08:29] *** yeahnoob left
[08:29] * jnthn wrote much of the QAST to JVM and QAST to MoarVM code-gen, and the MoarVM one was easier for me, at least :)

[08:29] <yoleaux> 01:22Z <raiph> jnthn: I'd love to be able to show off Grammar::Generative... https://github.com/jnthn/grammar-generative/issues/1#issuecomment-121105324

[08:29] <ely-se> though maybe it depends on the source language

[08:29] <ely-se> with order of evaluation and such

[08:29] <jnthn> *nod*

[08:30] <ely-se> I'm currently implementing a stack-based VM in JavaScript.

[08:30] *** Woodi joined
[08:32] *** vendethiel left
[08:32] *** samgwise joined
[08:36] *** vendethiel joined
[08:39] <ely-se> it can already execute hello world xd

[08:40] <samgwise> Hi #perl6 :)

[08:40] <kanl> m: my %h = a => 1; %h<b> = %h.values; %h.say;

[08:40] <samgwise> I've been trying to compile from source on win 7 without success :(

[08:40] <camelia> rakudo-moar 533d1a: OUTPUT«(timeout)»

[08:41] <samgwise> I'm using VS 2015 RC and I run into a failure at stirngs/unicode.c

[08:42] <samgwise> the compiler is complaining that it's encountered fatal error c1026: parser stack overflow

[08:43] <moritz> samgwise: sounds like a bug in the compiler

[08:43] <ely-se> MSVC is well known for being buggy.

[08:43] <samgwise> I've used the same 2015.06 source and built it on a windows 8 laptop useing the VS 15 RC any ideas?

[08:43] *** dayangkun joined
[08:43] <jnthn> samgwise: It seems it's an MSVC compiler bug that didn't exist in any previous version of MSVC :(

[08:44] <jnthn> So "use an older version of MSVC" is the only known workaround at the moment.

[08:46] *** atroxaper joined
[08:46] <samgwise> OK, thanks, I'll give that a shot :)

[08:46] <moritz> please report the bug to microsoft.

[08:46] <samgwise> Good idea too :)

[08:46] <moritz> (if MS makes that possible, that is)

[08:47] <samgwise> I'll find out I guess.

[08:47] <ely-se> moritz: yeah it does

[08:47] <ely-se> here's my favourite bug report: https://connect.microsoft.com/VisualStudio/feedbackdetail/view/915771/please-hog-all-my-ram

[08:48] <FROGGS> samgwise: I know it works with MSVC 2010 and 2012

[08:50] <samgwise> Thanks FROGGS

[08:52] *** bjz joined
[08:52] *** verzz left
[08:53] <DrForr> And the status tells you the rest you need to know: Closed as Won't Fix.

[08:53] <TEttinger> samgwise: I had the same issue btw, 2013 worked fine

[08:53] *** bin_005 joined
[08:53] <TEttinger> (2013 community)

[08:55] <RabidGravy> question of self-doubt here, if I had a method that may return either a Buf or a [ CArray[uint8], Int] depending on some named parameter it would be better to make it a multi irrespective of the return type taking part in the multi?

[08:57] <moritz> the return type doesn't take part in multi dispatch

[08:57] <moritz> so you must distinguish it on the named param

[08:57] <moritz> and yes, a multi would be fine for that

[08:58] <RabidGravy> yes, I knew all that, it was a "style question" (would it be better to make a multi or make the return Positional to handle both cases ;)

[09:00] *** ely-se left
[09:00] <RabidGravy> so "sub foo(:$raw?) returns Positional vs multi foo() returns Buf ... multi foo(:$raw!) returns Array"

[09:00] *** yeahnoob joined
[09:00] *** bin_005_d joined
[09:01] <jnthn> RabidGravy: For me it'd depend on how different the implementations of the two were

[09:02] <RabidGravy> to be honest the 'raw' case simply omits the copying the CArray into the Buf

[09:02] *** bin_005 left
[09:05] *** kurahaupo left
[09:07] *** spider-mario left
[09:09] *** spider-mario joined
[09:10] <RabidGravy> already got four multis "foo(Array, Array), foo(Array), foo(CArray, CArray, Int), foo(CArray, Int)" so doubling them for each of the five cases (foo-short, foo-int, foo-long, foo-float and foo-double) for a total of eighty methods might be over-kill ;-)

[09:12] <moritz> RabidGravy: ok, then I'd probably not do it as more multis

[09:12] <moritz> or find a way to generate them :-)

[09:13] <RabidGravy> :-)

[09:14] <FROGGS> TimToady: do you want to get the indirect object syntax in place before September?

[09:14] <moritz> don't we already have indirect object syntax?

[09:14] <RabidGravy> being able to multi on shaped arrays would help somewhat

[09:15] <jnthn> m: say is-prime: 42

[09:15] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/A_wiO51C81␤Calling is-prime() will never work with proto signature ($, $?)␤at /tmp/A_wiO51C81:1␤------> 3say 7⏏5is-prime: 42␤»

[09:15] <jnthn> Hm, what was the syntax again... :)

[09:15] <moritz> std: say is-prime: 42

[09:15] <camelia> std 28329a7: OUTPUT«ok 00:00 137m␤»

[09:16] <jnthn> oh, so that *is* the syntax

[09:16] <jnthn> I too thought we did it

[09:16] <jnthn> m: is-prime: 42

[09:16] <camelia> rakudo-moar 533d1a: ( no output )

[09:16] <jnthn> Oh...it only works at statement level?

[09:16] <moritz> m: say(is-prime: 42)

[09:16] <camelia> rakudo-moar 533d1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MoSxfcoiz4␤Calling is-prime() will never work with proto signature ($, $?)␤at /tmp/MoSxfcoiz4:1␤------> 3say(7⏏5is-prime: 42)␤»

[09:20] <FROGGS> jnthn: implementing &?BLOCK.leave is hard :/

[09:20] <FROGGS> jnthn: and I've not pushed yet my latest changes

[09:21] <jnthn> FROGGS: Yeah, I'd been pondering how to do that

[09:22] <jnthn> (no, I don't have a great answer yet)

[09:23] <FROGGS> leave() works now, as well as Label.leave which worked yesterday already

[09:24] *** vendethiel left
[09:24] <FROGGS> Label.leave works because we use nqp::handle(..., 'RETURN', {...}) there

[09:26] <jnthn> I'd rather we didn't steal RETURN for that...

[09:26] <jnthn> But maybe we can make LEAVE control exceptions also check the code object of the current block against the "label"...

[09:26] <jnthn> So if you put &?BLOCK in the label it just works out

[09:27] <FROGGS> hmmm

[09:28] <FROGGS> surely we can use LEAVE instead

[09:28] <jnthn> Yes, let's add LEAVE

[09:28] <FROGGS> and yeah, I understand what you said

[09:28] <jnthn> I think RETURN eventually wants to work through control exceptions too, not the magical lexotic mechanism we have today

[09:30] *** araujo joined
[09:33] *** vendethiel joined
[09:36] *** amurf joined
[09:40] *** yeahnoob left
[09:41] *** amurf left
[09:42] *** verzz joined
[09:50] *** bjz left
[09:55] *** samgwise left
[09:58] <kanl> is Set no longer extendable?

[09:58] <kanl> m: class Foo is Set { method foo( $foo ) { self{$foo} = True; self } }; my $f = Foo.new.foo: 'a'; $f.say;

[09:58] <camelia> rakudo-moar 533d1a: OUTPUT«Method 'BUILD' not found for invocant of class 'Foo'␤  in block <unit> at /tmp/75lUH25_wJ:1␤␤»

[09:59] *** verzz left
[10:00] <kanl> what (else) is an immutable hash-like container to extend then?

[10:00] *** bjz joined
[10:10] <nine> [TuxCM]: I couldn't reproduce my random test failures on my desktop at home, so I nuked my install directory on my work laptop and now they are gone here, too.

[10:11] *** xfix joined
[10:12] *** g4 left
[10:14] *** g4 joined
[10:16] *** domidumont joined
[10:16] <kanl> question rephrased, how do i extend Hash and make it immutable?

[10:17] *** xfix left
[10:17] *** domidumont left
[10:17] <jnthn> kanl: I think it's a bug that you can't inherit from Set.

[10:17] *** domidumont joined
[10:18] <kanl> jnthn, i'd suspect so. i remember seeing an example of Set being extended somewhere before.

[10:18] <[TuxCM]> nine, were you able to reproduce the failures with an *installed* I::P5?

[10:19] <kanl> jnthn: is there any way to realized my 2nd question though?

[10:19] <nine> [TuxCM]: spoke too early :( Just took very long for the first failure to occur

[10:19] <kanl> i.e. to extend a Hash/List and the like and make it immutable?

[10:19] <jnthn> kanl: Well, you could use EnumMap, which Hash extends

[10:20] <jnthn> kanl: Which doesn't put values in Scalar containers

[10:20] <kanl> jnthn: thank you! i'll investigate.

[10:21] <kanl> oh, and i'll open a bug on Set not extendable.

[10:27] <kanl> is it by designed that this can't/shouldn't be done?

[10:27] <kanl> my %h = a => 1; %h<b> = %h.values; %h<b>.say;

[10:27] <kanl> the equivalent of which is legal in p5

[10:31] <jnthn> It isn't legal Perl 6?

[10:31] <RabidGravy> there's bug in there somewhere

[10:31] <jnthn> m: my %h = a => 1; %h<b> = %h.values; %h<b>.say;

[10:32] <camelia> rakudo-moar 533d1a: OUTPUT«(timeout)»

[10:32] <jnthn> m: my %h = a => 1; %h<b> = eager %h.values; %h<b>.say;

[10:32] <camelia> rakudo-moar 533d1a: OUTPUT«1␤»

[10:32] <jnthn> ah

[10:32] <RabidGravy> just sits there consuming increasing amounts of memory

[10:34] <RabidGravy> I guess it would coredump when it ran out of memory

[10:36] <kanl> so can the compiler advise in time before that happens?

[10:36] <jnthn> How can it know?

[10:36] <kanl> i thought not

[10:36] <jnthn> But I think maybe it's a bug that the "eager" is needed there

[10:37] <jnthn> But I'm not sure.

[10:38] <RabidGravy> or = @ = if you don't like typing eager ;-)

[10:40] <RabidGravy> right, rebboot

[10:41] *** RabidGravy left
[10:42] *** xfix joined
[10:42] *** xfix left
[10:42] *** xfix joined
[10:50] *** atroxaper left
[10:50] *** dayangkun left
[10:56] *** Ven joined
[11:01] <cognominal> When I juggle with too many balls in Perl 6, I am often confused about which particular ball I dropped and start making false assumption :(       Probably a case of searching dropped keys under streetlights to use another metaphor.

[11:04] <moritz> cognominal: juggling more than one ball is the real problem

[11:04] <kanl> is Parcel "final"?

[11:04] <kanl> class Foo is Parcel { method foo { self = ( 1, 2, 3 ) } }; my $f = Foo.new.foo;

[11:04] <kanl> m: class Foo is Parcel { method foo { self = ( 1, 2, 3 ) } }; my $f = Foo.new.foo;

[11:04] <camelia> rakudo-moar 533d1a: OUTPUT«Method 'foo' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/9CjbhH4lpG:1␤␤»

[11:05] *** ely-se joined
[11:07] <FROGGS> jnthn: instead of adding leave method to Block I can also just add it to Code, right?

[11:07] *** pullphinger left
[11:08] <jnthn> FROGGS: I'd put it on Block

[11:08] <FROGGS> k

[11:08] <jnthn> FROGGS: We use Code for thunks

[11:08] <FROGGS> we then need it in Sub and Routine too...

[11:08] <FROGGS> but I'll care about that later

[11:08] <jnthn> m: say Routine.^mro; say Sub.^mro

[11:08] <camelia> rakudo-moar 533d1a: OUTPUT«(Routine) (Block) (Code) (Any) (Mu)␤(Sub) (Routine) (Block) (Code) (Any) (Mu)␤»

[11:08] <FROGGS> ohh

[11:09] <jnthn> :)

[11:09] <FROGGS> :D

[11:09] <jnthn> Code = thing we can invoke, Block = Code + lexical scope

[11:09] <jnthn> Routine = Block + maybe multi-dispatch

[11:09] <jnthn> :)

[11:09] <FROGGS> yeah, that knowledge is in my head somewhere already :o)

[11:10] <ely-se> is there an article on how to choose between arrays, lists and parcels?

[11:10] <jnthn> I dunno if we had it that way in the very early days, I think at some point I remember figuring out it was the right factoring.

[11:10] <FROGGS> jnthn: I don't know the early days... my first contact was back in 2012

[11:10] <FROGGS> so, I'm a n00b after all

[11:11] <jnthn> I think my first Rakudo commit was around December 2007 and I didn't have a darn clue what I was doing :)

[11:12] <FROGGS> jnthn: but you improved, slightly :P

[11:12] <jnthn> pmichaud++ had made a pretty sane design overall

[11:12] *** ely-se left
[11:13] <jnthn> So it was quite learnable :)

[11:13] *** domidumont left
[11:13] <jnthn> I mean, in hindsight there was a bunch of things the design was never going to cope with, but we had to run with it for a while to see that.

[11:14] <FROGGS> sure

[11:14] *** atroxaper joined
[11:14] <FROGGS> you need a working base, and way to try and change things while you learn how things are meant to work

[11:14] <jnthn> The architecture we have today really is derived from the "nom" (new object model) time

[11:15] <jnthn> Yeah, I think a lot of the time in software we too quickly try to build "the thing" and don't allow ourselves the space we need to learn the problem.

[11:16] <jnthn> And when I came to Perl 6 it was like "arrgh this project is taking AGES" so there was a real pressure to deliver The Thing.

[11:17] <jnthn> In hindsight, my first couple of years here were really about learning various ways to not build a Perl 6 implementation...and unlearning various assumptions from compiler classes at uni, I guess. :)

[11:18] <FROGGS> jnthn: I try to teach the students here at work what the first step/milestone contain, and in what way it should allow evolution and what level of emplexity it should not contain

[11:18] <FROGGS> complexity*

[11:18] *** atroxaper left
[11:18] <FROGGS> they often try to tackle the hard bits, which are often enough just minor details

[11:19] <jnthn> Tackling unknowns early is good generally, but it's actually sometimes hard to know where the hard problems lie

[11:20] <jnthn> It took a while for me to realize how deep the whole "OK, so we're going to compile to bytecode *AND* have BEGIN time" problem actually goes.

[11:20] *** atroxaper joined
[11:21] <jnthn> And how to square that with meta-programming, optimization, etc.

[11:22] <FROGGS> about tackling unknowns - tackling these early just because they seem hard when they are just a 'nice to have' is just wasting time IMO

[11:22] <jnthn> Oh, you have to know if they're actually your core problem before spending time on them.

[11:22] <FROGGS> getting the framework right, in a way to be able to involve in several ways ist a good approach to me

[11:22] <jnthn> If you know they're a "nice to have" then yeah, sure, it's a waste of time.

[11:23] <FROGGS> and I'm happy that I was able to do that for the last two big projects I did/do

[11:23] <jnthn> *nod*

[11:24] *** bin_005_d left
[11:24] *** brrt joined
[11:24] <brrt> \o

[11:25] <brrt> FROGGS++ 

[11:25] <FROGGS> hmm?

[11:25] <FROGGS> what have I done?

[11:25] <brrt> on the LEAVE thingies :-)

[11:25] <FROGGS> ahh :o)

[11:25] <brrt> yesterday I guess

[11:25] <brrt> :-)

[11:25] <brrt> anyway

[11:26] *** amurf joined
[11:26] <FROGGS> brrt: I'm still working on it, searching for the right approach

[11:26] <FROGGS> jnthn: is leave() meant to return from that spot?

[11:26] <FROGGS> or are statements after leave() meant to get executed?

[11:27] <jnthn> FROGGS: It has immediate effect

[11:27] *** ely-se joined
[11:27] <ely-se> ah

[11:27] <ely-se> readying both http://doc.perl6.org/language/variables and http://doc.perl6.org/language/containers helps a lot

[11:27] <jnthn> my $x = -> { my $y = &?BLOCK; sub foo() { $y.leave(42); say 'not here' }; foo(); say 'nor here'; }; $x()

[11:28] <jnthn> FROGGS: Hopefully ^^ clears it up a bit

[11:28] <jnthn> Uh, and if I made it 'say $x()' then it should give 42

[11:29] <FROGGS> jnthn: so the other say()s are not executed?

[11:29] <FROGGS> then I got it right

[11:29] <ely-se> though it says .map and .grep flatten

[11:29] <ely-se> is that still the case?

[11:29] <jnthn> FROGGS: Correct

[11:30] <jnthn> ely-se: They shouldn't these days

[11:30] <ely-se> nice

[11:30] <jnthn> m: ((1, 2), (3, 4)).map(*.say)

[11:30] <camelia> rakudo-moar 533d1a: OUTPUT«1 2␤3 4␤»

[11:30] <jnthn> m: ((1, 2), (3, 4)).grep(*.say)

[11:30] <camelia> rakudo-moar 533d1a: OUTPUT«1 2␤3 4␤»

[11:30] *** amurf left
[11:31] <FROGGS> ely-se: a method call usually sees the elements of the container if was called on

[11:31] <FROGGS> maybe that was meant

[11:32] <ely-se> m: [[1, 2], [3, 4]].map(*.say)

[11:32] <camelia> rakudo-moar 533d1a: OUTPUT«1 2␤3 4␤»

[11:32] <ely-se> m: 1.map(*.say)

[11:32] <camelia> rakudo-moar 533d1a: OUTPUT«1␤»

[11:33] <ely-se> dangerous

[11:33] *** aborazmeh left
[11:34] <jnthn> It's pretty well established that an item will behave like a 1-element list if put in a list-y context.

[11:34] <Woodi> hallo #perl6 :)

[11:35] <ely-se> jnthn: how does it know which map too call?

[11:35] <ely-se> Does it first look at the methods of Int, and if it can't find it, it looks at the methods of List?

[11:35] <moritz> there's an Any.map

[11:35] <jnthn> ely-se: No, Int ~~ Any and Any has a map method that does self.list.map

[11:35] <ely-se> oh I see

[11:36] <ely-se> not listed on http://doc.perl6.org/type/Any though

[11:36] <moritz> feel free to correct that

[11:36] <Woodi> [Coke]: about grants: for Perl6 part I would say: finished modules, finsihed modules, finished modules. even if that modules would be micro-grants and -Ofun optimized :)

[11:37] <Woodi> [Coke]: but IMO whole Perl community have problems with GUIs...

[11:38] *** iH2O joined
[11:39] *** iH2O left
[11:43] * moritz just avoids them

[11:44] <ely-se> I think we should never ship 1.0.

[11:45] *** pecastro_ joined
[11:45] <ely-se> Doing so would means having to care about backwards compatibility, rendering the language worse over time.

[11:45] <moritz> the notion is tempting.

[11:46] * moritz will resist

[11:46] <ShimmerFairy> I agree. If we ship Perl 1.0 , terrible confusion would result :P

[11:47] <ely-se> Guido once asked the audience who used Python 2, then he asked who used Python 3. In the end there were still people who hadn't raised their hands yet so the only conclusion was that they were still using Python 1. :D

[11:48] <moritz> or perl :-)

[11:48] <ely-se> :O

[11:48] *** skids joined
[11:49] <moritz> (or myabe TCL)

[11:49] <ely-se> I wanted to write a bug tracker in Tcl recently

[11:50] <FROGGS> jnthn: is &?BLOCK identical to frame->code_ref or is this instead $!do from Code?

[11:50] <moritz> ely-se: why?

[11:50] <ely-se> YouTrack wasn't sufficient and JIRA is cluttered. But then I realised that writing bug trackers is incredibly boring :)

[11:51] <ely-se> also I wanted to learn Tcl

[11:52] * moritz finds Jira not well-suited for bug tracking

[11:52] <moritz> jirs is good for Agil project management

[11:52] <moritz> *jira

[11:52] <moritz> which isn't quite the same

[11:52] <jnthn> FROGGS: $!do is frame->code_ref

[11:52] <FROGGS> jnthn: thanks :o)

[11:52] <jnthn> FROGGS: &?BLOCK is the code object, so more like frame->code_ref->body.code_object or whatever we call it

[11:53] <FROGGS> ahh

[11:54] *** ely-se left
[11:55] *** tinyblak_ left
[11:55] *** colomon joined
[11:58] *** TEttinger left
[12:00] *** atroxaper left
[12:01] <kanl> gurus, why is EnumMap inheritable while Parcel is not?

[12:01] *** skids left
[12:01] <kanl> i'm guess immutability isn't a concern here?

[12:10] <nine> FROGGS: https://github.com/FROGGS/p6-Slang-Tuxic/commit/ab0b98a754976f4c2f859da7146811cfeb8c6f8b is the reason for [TuxCM]'s "Merging GLOBAL symbols failed: duplicate definition of symbol HLL" error

[12:12] <FROGGS> :o(

[12:24] *** brrt left
[12:26] *** brrt joined
[12:35] <[TuxCM]> ouch

[12:53] *** telex left
[12:54] *** lucasb joined
[12:54] *** telex joined
[12:55] *** gfldex joined
[12:55] *** tinyblak joined
[12:57] <FROGGS> m: say 0x7f2449eaeaa0 - 0x7f244a0824a0

[12:57] <camelia> rakudo-moar 533d1a: OUTPUT«-1915392␤»

[12:58] <jnthn> Memory addresses? :)

[12:58] <FROGGS> aye

[12:58] *** domidumont joined
[12:59] <FROGGS> nqp::getattr(nqp::decont(&?BLOCK), Code, "\$!do")) is not equal to nqp::getattr(nqp::decont(self), Code, "\$!do")) in Block.leave

[13:00] *** tinyblak left
[13:01] *** atroxaper joined
[13:05] *** atroxaper left
[13:06] <FROGGS> err, that's actually wrong

[13:08] <FROGGS> the thrown label (via self!$!do) in C is identical to &?BLOCK!$!do, but I don't see any fitting frame->code_ref 

[13:11] *** LLamaRider joined
[13:11] *** LLamaRider left
[13:12] *** oetiker left
[13:13] *** oetiker joined
[13:18] *** colomon left
[13:20] *** colomon joined
[13:22] *** colomon left
[13:23] *** dolmen joined
[13:37] *** JimmyZ__ joined
[13:38] *** khw joined
[13:41] <PerlJam> FROGGS++ (star msi)

[14:01] *** RabidGravy joined
[14:11] *** rindolf left
[14:12] *** vendethiel left
[14:14] *** vendethiel joined
[14:21] *** dj_goku left
[14:21] *** dj_goku_ joined
[14:25] *** nowan joined
[14:36] *** bjz left
[14:37] *** vendethiel left
[14:39] *** vendethiel joined
[14:41] *** brrt left
[14:41] <dalek> rakudo/nom: b6fae27 | lizmat++ | src/core/ (3 files):

[14:41] <dalek> rakudo/nom: Make Set and friends subclassable

[14:41] <dalek> rakudo/nom: 

[14:41] <dalek> rakudo/nom: Fixes at least one part of #125611

[14:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6fae27ece

[14:41] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125611

[14:43] *** bjz joined
[14:47] <hoelzro> good morning, #perl6

[14:49] <jnthn> o/ hoelzro 

[14:49] <hoelzro> o/ jnthn 

[14:51] <masak> good aft^Wmorning, #perl6

[14:52] <moritz> good UGT morning, masak

[14:52] <masak> yep. UGT. that's what I meant.

[14:55] <RabidGravy> managed to procure a Raspberry Pi 2, I may now be able to start testing again on that

[14:55] <hoelzro> greetings masak 

[14:55] <jnthn> .oO( unspeakable get-up time )

[14:57] <DrForr> Indeed, unspeakable :)

[14:58] <dalek> rakudo/nom: dd3bcc4 | lizmat++ | src/core/ (3 files):

[14:58] <dalek> rakudo/nom: Make attempt changing Set/Bag/Mix throw

[14:58] <dalek> rakudo/nom: 

[14:58] <dalek> rakudo/nom: Somehow the code example in #125611 would eat the failure of assigning

[14:58] <dalek> rakudo/nom: to a Set silently.  It does no longer with this change.

[14:58] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125611

[14:58] <masak> actually, I got up at 05:24... just been traveling all day.

[14:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd3bcc46cc

[14:59] <jnthn> masak: Unspeakable indeed :P

[15:00] <lizmat> good *, #perl6

[15:00] *** zakharyas left
[15:01] *** khw left
[15:01] <masak> jnthn: :P

[15:02] *** zakharyas joined
[15:02] <jnthn> o/ lizmat 

[15:03] <lizmat> fixing bugs before 8am still feels a bit jetlagged, but otherwise I seem to be doing ok now  :-)

[15:03] *** amurf joined
[15:04] <jnthn> lizmat: Hope current location is either cooler or aircon'd :)

[15:05] *** FROGGS left
[15:05] <lizmat> airco'd, although, temp outside is still bearable as well

[15:05] <jnthn> :)

[15:05] <jnthn> Current location is...Portland?

[15:07] <lizmat> indeed

[15:08] *** amurf left
[15:10] <lizmat> breakfast&

[15:13] *** captain-adequate joined
[15:13] *** jaffa4 joined
[15:13] *** aborazmeh joined
[15:13] *** aborazmeh left
[15:13] *** aborazmeh joined
[15:13] <jaffa4> Hi all

[15:13] <jaffa4> I get this Missing or wrong version of dependency 'src/gen/m-CORE.setting' (from 'lib/File/Find.pm')

[15:13] <vendethiel> o/

[15:14] *** skids joined
[15:15] *** tinyblak joined
[15:19] <itz> jaffa4: probably bits left over from an earlier build .. maybe easiest to start again

[15:19] <timotimo> i'm quite late to the party, but the indirect object syntax is about putting the : after the object the method is invoked on

[15:20] <timotimo> m: say is-prime 42:;

[15:20] <camelia> rakudo-moar 533d1a: OUTPUT«False␤»

[15:20] <jaffa4> `itz: What should I delete?

[15:21] <jnthn> timotimo: oh, duh!

[15:21] <jnthn> I shoulda had more coffee

[15:21] <jnthn> timotimo++

[15:22] <timotimo> :3

[15:26] *** dolmen left
[15:29] *** brrt joined
[15:29] *** g4 left
[15:31] *** zakharyas left
[15:32] *** aborazmeh left
[15:46] <TimToady> m: say $*OUT: 42

[15:46] <camelia> rakudo-moar dd3bcc: OUTPUT«42␤»

[15:46] <TimToady> makes more sense for things with arguments

[15:48] * vendethiel doesn't really like that what's before the colon changes its meaning

[15:48] *** Ven left
[15:49] <TimToady> well, don't use it on big things

[15:50] <TimToady> there are other places in the language that change meaning retroactively

[15:50] *** tinyblak left
[15:50] <TimToady> a => 42

[15:50] <TimToady> $x = stuff

[15:51] *** tinyblak joined
[15:52] <TimToady> and in the case of $*OUT: we're just treating it as a special comma that says the first arg is the invocant, corresponding to the : in a signature

[15:52] <TimToady> which is also retroactive, now that I think of it :)

[15:52] <TimToady> m: say($*OUT: 42)

[15:52] <camelia> rakudo-moar dd3bcc: OUTPUT«42␤»

[15:53] <TimToady> actually matches the declaration more closely than $*OUT.say: 42

[15:54] <TimToady> operators are doing retractive stuff all the time via precedence too

[15:55] <TimToady> *retroactive

[15:56] *** tinyblak left
[15:58] <TimToady> but I think all these things fall into the category of intentional genericity, which I consider to be okay, especially if the amibuities are resolved locally and quickly

[15:58] <TimToady> *ambig, grr

[15:58] <vendethiel> TimToady: I didn't mean that

[15:58] * TimToady obviously waiting for of coffee to brew

[15:58] <TimToady> *his coffee

[15:58] <vendethiel> I meant "foo A.b: 5;" vs "foo (A.b): 5;"

[15:59] <TimToady> that should parse to foo (A.b: 5)

[15:59] <TimToady> if it doesn't, it's a bug

[16:00] <vendethiel> both?

[16:00] <vendethiel> I think the spec indicates the opposite

[16:00] <TimToady> "nearest" is what it says, iirc

[16:00] <vendethiel> I remember arguing with timotimo++ on the train about that, actually...

[16:01] <TimToady> m: my @a; say @a.push: 42; say @a

[16:01] <camelia> rakudo-moar dd3bcc: OUTPUT«42␤42␤»

[16:02] <TimToady> S12:519

[16:02] <synbot6> Link: http://design.perl6.org/S12.html#line_519

[16:03] * vendethiel was looking at S02

[16:04] *** JimmyZ__ left
[16:06] <TimToady> well, S02 is a bit confused about the difference between "term" and "token"

[16:07] <TimToady> m: my @a; say push @a[]: 42; say @a

[16:07] <camelia> rakudo-moar dd3bcc: OUTPUT«42␤42␤»

[16:07] <TimToady> one term is fine, even if it has multiple tokens as @a[] does

[16:08] <TimToady> but that's really no more violence to the previous term than assignment turning an rvalue into an lvalue

[16:13] <cognominal> m:   my token ws { '#' };  say 'a#' ~~  m:s/ a  $ /;    # TimToady, shoud m:s// pick the lexical ws?   adapted from  yesterday discussion http://irclog.perlgeek.de/perl6/2015-07-13#i_10885672

[16:13] <camelia> rakudo-moar dd3bcc: OUTPUT«False␤»

[16:14] <DrForr> .tell masak sub eval($a,$op,$c,@exc) &'{ $a &,$op $c or &@,@exc }

[16:14] <yoleaux> DrForr: I'll pass your message to masak.

[16:14] <cognominal> m:   my token ws { '#' };  say 'a#' ~~  m/ a <ws>  $ /;    

[16:14] <camelia> rakudo-moar dd3bcc: OUTPUT«｢a#｣␤ ws => ｢#｣␤»

[16:14] <dalek> rakudo/glrish: e1e0692 | TimToady++ | src/core/Array.pm:

[16:14] <dalek> rakudo/glrish: GLR emulation

[16:14] <dalek> rakudo/glrish: 

[16:14] <dalek> rakudo/glrish: [] doesn't itemize

[16:14] <dalek> rakudo/glrish: [] doesn't flatten

[16:15] * TimToady killerfied dalek

[16:15] *** dalek joined
[16:15] *** ChanServ sets mode: +v dalek

[16:15] <cognominal> glrish is such a gorish name

[16:15] <TimToady> that's my branch that tries out some glr-like changes at a high level

[16:16] <TimToady> it compiles, but Test won't import symbols for some reason

[16:16] <TimToady> also, [] still flattens itself prematurely, I think

[16:17] <TimToady> (the [] doesn't flatten note above means inside the [])

[16:19] <TimToady> that is, [1,2,(3,4)] is a 3 element array in glrish

[16:20] <TimToady> [1,2,[3,4]] should also be a 3 element array, but the inner [] autoflattens prematurely, I think

[16:20] <TimToady> lemme double check that...

[16:20] <TimToady> > p -e 'say [1,2,[3,4]].elems'

[16:20] <TimToady> 4

[16:20] <TimToady> yeah

[16:21] <TimToady> but something low-level is forcing that, and I haven't figured out how to turn it off yet

[16:22] <cognominal> TimToady++ for working on GLR design.

[16:23] <TimToady> well, glrish has to go through contortions to try to emulate glr because it's fighting the old low-level semantics in various spots

[16:23] *** ely-se joined
[16:23] <jaffa4> TimToady:  what do you modify?

[16:23] <TimToady> these things should actually be much simpler when the lower level is fixed

[16:24] <TimToady> well, various things

[16:24] <TimToady> jaffa4: are you asking about the GLR design itself, or the glrish implementation?

[16:24] *** salv0 joined
[16:25] <jaffa4> CLR

[16:25] <ely-se> the girlish implementation

[16:25] <jaffa4> GLR

[16:26] <jaffa4> genelised LR

[16:26] <TimToady> Great List Refactor

[16:27] <DrForr> *NNNNooobody* inspects the GLRish implementation, in fact those who *do* inspect it... I'll come in again.

[16:27] <PerlJam> DrForr++

[16:28] <TimToady> jaffa4: there's a gist from pmichaud++ summarizing the current redesign ideas, which I seem to have misplaced...

[16:29] *** tinyblak joined
[16:30] <TimToady> https://github.com/perl6/specs/blob/84ff4f37ea2eccc70427f23484c8c1338619f2c9/S07-glr-draft.pod

[16:30] <DrForr> Just slipped out ;)

[16:30] <geekosaur> that's what happens when you inspect it?

[16:30] <geekosaur> :p

[16:30] <mst> to implement GLR, one must first sit ... in the comfy chair

[16:30] <TimToady> because it wasn't a gist, it was a new S07 :)

[16:30] <TimToady> Not GLRcup!

[16:31] *** yqt joined
[16:36] *** jeffreykegler joined
[16:36] *** tinyblak left
[16:37] *** tinyblak joined
[16:37] *** atroxaper joined
[16:38] * PerlJam worries a little that post-GLR  for ^10 { ... }   will need to look more like  for @(^10) { ... }

[16:38] <jeffreykegler> TimToady: many years ago I mailed you a copy of Eco's _Search for a Perfect Language_

[16:39] <jeffreykegler> It was when I was moving, and I was culling my book collection, and I thought, "you know, book rate is cheap and this does seem like Larry's kind of book"

[16:40] <jeffreykegler> I mailed it care of ORA and I never did find out if it got to you.

[16:41] *** tinyblak left
[16:41] *** atroxaper left
[16:42] <jeffreykegler> I just noticed you mention it in the Linux Voice interview, so apparently I guessed right.

[16:45] *** abraxxa left
[16:46] <TimToady> yes, one of my favorite books

[16:47] <TimToady> and a good antidote to anyone who thinks "Similar things should look similar" is more important than "Similar things should look different."  :)

[16:47] *** Khisanth left
[16:48] <TimToady> PerlJam: why would you need to do that?  for and map will iterate any single iterable, as long as there's no extra comma

[16:48] *** ely-se left
[16:49] <PerlJam> TimToady: yeah, I was just re-reading S07-glr-draft and noticed what I'd missed before.

[16:50] <TimToady> one of the underpinnings of the GLR redesign is that we distinguish iterators that throw away values from lists that don't, so @() would tend to keep values around unnecessarily in that case

[16:50] <PerlJam> so:   for ^10 { ... } # 10 iterations.      for ^10, 7 { ... }  # 2 iterations.

[16:50] <TimToady> historically we've confused lazy lists with iterators, and we're trying to unconfuse them

[16:50] *** Khisanth joined
[16:50] <TimToady> yes, that's the current plan

[16:51] <TimToady> currently, ranges and arrays autoflatten themselves, so the latter is busted, by GLR standards

[16:52] <TimToady> m: .say for ^10, 7

[16:52] <camelia> rakudo-moar dd3bcc: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤7␤»

[16:52] <TimToady> m: .say for (^10), 7

[16:52] <camelia> rakudo-moar dd3bcc: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤7␤»

[16:52] <TimToady> m: .say for $(^10), 7

[16:52] <camelia> rakudo-moar dd3bcc: OUTPUT«0..^10␤7␤»

[16:52] <TimToady> should act more like that, only without the cat...er...the scalar

[16:53] <TimToady> m: .say for [^10]<>, 7

[16:53] <camelia> rakudo-moar dd3bcc: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤7␤»

[16:54] <TimToady> as you can see, unitemized Array also autoflattens, unlike ()

[16:54] <TimToady> m: .say for (0,1,2,3), 7

[16:54] <camelia> rakudo-moar dd3bcc: OUTPUT«0 1 2 3␤7␤»

[16:54] <TimToady> should work more like that

[16:55] <PerlJam> And these tests https://gist.github.com/perlpilot/091488db934dd4b3d9da would need less $()  which would jibe with how I tried to write them originally

[16:57] <jeffreykegler> TimToady: so you did get it, or had you known of it earlier?

[16:57] *** brrt left
[17:01] <TimToady> I think it was probably the one you sent, but my brane has replasticized itself a few too many times to say for sure...

[17:02] *** dakkar left
[17:05] <TimToady> One of these days I'm gonna replasticize my brain, only to discover that I melted the old without solidifying the new...

[17:08] *** jeffreykegler left
[17:12] *** diana_olhovik joined
[17:17] *** domidumont left
[17:29] <jaffa4> How do I refer to an attribute of a class?

[17:30] <vendethiel> jaffa4: $a.b? $.b inside the class?

[17:30] <masak> jaffa4: could you be more specific? what problem are you trying to solve?

[17:30] <yoleaux> 16:14Z <DrForr> masak: sub eval($a,$op,$c,@exc) &'{ $a &,$op $c or &@,@exc }

[17:30] <jaffa4> self.options = %options;

[17:31] <masak> m: class C { has %.options }; my $c = C.new(:options(foo => 1, bar => 2)); say $c.options.perl

[17:31] <camelia> rakudo-moar dd3bcc: OUTPUT«{:bar(2), :foo(1)}<>␤»

[17:31] <jaffa4> options passed in , I would like to set class variable with the same name

[17:31] <masak> jaffa4: does the above eval answer your question?

[17:31] <masak> your term "class variable" confuses me currently. so maybe I'm missing your point.

[17:32] <jaffa4> has...

[17:32] *** virtualsue left
[17:32] *** mr-foobar joined
[17:32] <lucasb> jaffa4: %!options = ...

[17:33] <jaffa4> yes, that is it lucasb

[17:34] <dalek> perl6-roast-data: 21db85d | coke++ | / (8 files):

[17:34] <dalek> perl6-roast-data: today (automated commit)

[17:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/21db85d6ad

[17:34] <masak> `%.options = ...` also works. the `!` variant assigns directly to the attribute slot; the `.` variant goes via an (overridable) rw accessor

[17:40] <DrForr> masak: ^^ was a notion I had for relatively limited lisp-style macros.

[17:41] <masak> DrForr: in the backlog? what should I grep for?

[17:42] <DrForr> .tell masak sub eval($a,$op,$c,@exc) &`{ $a &,$op $c or &@,@exec }

[17:42] <yoleaux> DrForr: I'll pass your message to masak.

[17:42] <DrForr> Gah, forgot about the tell bit there.

[17:42] <masak> that's ok, I'm right here :P

[17:42] <yoleaux> 17:42Z <DrForr> masak: sub eval($a,$op,$c,@exc) &`{ $a &,$op $c or &@,@exec }

[17:42] <masak> gah, should've said "computer, messages." :P

[17:43] <masak> DrForr: I don't understand your example. it looks like something that could be understandable, given context.

[17:44] <b2gills> m: say is-prime 42:

[17:44] <camelia> rakudo-moar dd3bcc: OUTPUT«False␤»

[17:45] <lucasb> oh, something like: &` == quasiquote, &, == unquote, &@, == unquote-splice ? interesting :)

[17:45] <DrForr> From the inside out, &,$foo - &, acts as ,value would from Lisp, which is to say substituting the value of the expression into the surrounding code.

[17:45] <DrForr> lucasb: Yep. I was thinking that $`,$, and $& are now free, then realized that & is sort of free...

[17:46] <masak> oh, that makes sense.

[17:46] <masak> I hear what you're saying, and it's good to know we *could* end up with something like that... :)

[17:47] <masak> ...but I think we'll end up with something that's less of a carbon copy of Lisp's macro syntax and more something that fits Perl 6 well.

[17:47] <DrForr> It's limited to be sure, but at least it follows 'least surprise' for one group of hackers who know of macros.

[17:47] <masak> or s/think/hope/, rather

[17:47] <DrForr> Yeah, I know it's not the most ambitious, but I thought it might be a good starting point.

[17:48] <jaffa4> m : my @a= 1,2,3,4;  say @a[1..2];

[17:49] <jaffa4> m: my @a= 1,2,3,4;  say @a[1..2];

[17:49] <camelia> rakudo-moar dd3bcc: OUTPUT«2 3␤»

[17:49] *** virtualsue joined
[17:49] <masak> DrForr: I want you to know that I've taken in what you've proposed above. still in the middle of discovering/weighing a lot of factors. we'll see where we land.

[17:50] <jaffa4> m: my @a= 1,2,3,4;  say @a[1..];

[17:50] <camelia> rakudo-moar dd3bcc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/c_GOlBSery␤Please use ..* for indefinite range␤at /tmp/c_GOlBSery:1␤------> 3my @a= 1,2,3,4;  say @a[1..7⏏5];␤»

[17:50] <masak> wow, we even have an error message for that bit of obsolete Perl 6.

[17:50] <masak> jaffa4: where did you find that? in an old book?

[17:50] <masak> or an outdated web page?

[17:50] <jaffa4> just guessing

[17:50] <masak> heh

[17:51] <masak> jaffa4: it used to be that way.

[17:51] <DrForr> It's not a serious proposal by any means, I just felt that the & markers would be mnemonic and cue you in to the fact that there's function manipulation going on.

[17:51] <masak> oh, wait.

[17:51] <masak> no, it used to be 1..2 for finite things, and 1... for infinite things

[17:51] <masak> DrForr: oh, that's why you chose them. I was wondering.

[17:51] <jaffa4> m: my @a= 1,2,3,4;  say @a[1...];

[17:51] <camelia> rakudo-moar dd3bcc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Itwlviq6R2␤Missing required term after infix␤at /tmp/Itwlviq6R2:1␤------> 3my @a= 1,2,3,4;  say @a[1...7⏏5];␤    expecting any of:␤        prefix␤        term␤»

[17:52] <TimToady> yes, we never allowed .. to confuse term vs operator expections

[17:52] <TimToady> except perhaps briefly in pugs

[17:53] <TimToady> *tations

[17:53] <PerlJam> DrForr: In a way, it's too bad Perl makes such heavy use of symbology; it leaves fewer unambiguous symbols for macros :)

[17:54] <TimToady> .oO(Nobody inquisites the Glrish expections...)

[17:54] <TimToady> someone should go back in a time machine and expand ASCII

[17:54] <DrForr> Well, #{ and #} have already gone away... :)

[17:55] <TimToady> were they ever here?

[17:56] <TimToady> .oO(Long, long ago, this galaxy was far away...)

[17:56] <jaffa4> How do I make a slice until the end of array?

[17:56] <ShimmerFairy> I still like `...` as an alternative to {{{...}}}

[17:57] <PerlJam> ShimmerFairy: too "invisible"

[17:57] <TimToady> we need the grammatical category, so at best that would only be the default for nouns

[17:57] <DrForr> o/' And I thought me and Quai-gon Jinn / could talk the Federation in / To maybe cutting them a little slack o/

[17:58] <ShimmerFairy> TimToady: what if someone already went back to expand ASCII, and the best they could do was Unicode? :P

[17:58] <jaffa4> m: my @a= 1,2,3,4;  say @a[1.*.];

[17:58] <camelia> rakudo-moar dd3bcc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ozxYnX0eUa␤Confused␤at /tmp/ozxYnX0eUa:1␤------> 3my @a= 1,2,3,4;  say @a[1.*7⏏5.];␤»

[17:58] <jaffa4> m: my @a= 1,2,3,4;  say @a[1..*];

[17:58] <camelia> rakudo-moar dd3bcc: OUTPUT«2 3 4␤»

[17:58] <masak> m: my @a = 1, 2, 3, 4; say @a[1..*]

[17:58] <camelia> rakudo-moar dd3bcc: OUTPUT«2 3 4␤»

[17:59] <masak> jaffa4++ beat me to it ;)

[17:59] <PerlJam> ShimmerFairy: then we need to jump time lines to get to the one where they do better than unicode.

[17:59] <ShimmerFairy> Funny, I recall ..* blowing up in array slices...

[17:59] <TimToady> as lvalues maybe

[18:00] <DrForr> "A long long time ago, in a galaxy far, far away, a struggling filmmaker said 'I *will* create a character named Kit Fisto'"

[18:00] <masak> ShimmerFairy: it's "more correct" to write `..*-1`, of course

[18:00] <masak> ShimmerFairy: but the range auto-truncates, so both work

[18:01] <ShimmerFairy> masak: I still remember ..* causing an error once, hopefully my memory isn't wrong here :P

[18:01] <masak> isn't it weird that both Perl 5 and Perl 6 are 0-based from the beginning of the array, but 1-based from the end? :)

[18:01] <masak> ShimmerFairy: I don't recall it giving an error.

[18:01] <TimToady> masak: you're not thinking pythonically there :)

[18:01] <ShimmerFairy> Or maybe I'm confusing slices with simple indexing...

[18:01] *** araujo left
[18:01] <PerlJam> ShimmerFairy: it caused an error before the advent of Whatever  ;)

[18:03] *** araujo joined
[18:05] *** _sri joined
[18:17] <[Coke]> DrForr: I just saw that weird al song in concert this weekend. *dreamy sigh*

[18:18] <DrForr> I saw him in concert in '10 when he did his first European tour in a'dam.

[18:19] <[Coke]> Great entertainer, loved it.

[18:19] *** VinceDee joined
[18:22] *** nebuchad` joined
[18:24] *** nebuchad` is now known as nebuchadnezzar

[18:25] *** hoelzro_ joined
[18:25] *** danstone1 joined
[18:25] *** btyler_ joined
[18:25] *** telex left
[18:26] *** telex joined
[18:26] *** integral joined
[18:26] *** integral left
[18:26] *** integral joined
[18:26] *** telex left
[18:28] *** telex joined
[18:30] *** dalek left
[18:30] *** RabidGravy left
[18:30] *** synbot6 left
[18:30] *** hoelzro_trying_w left
[18:30] *** flussence left
[18:30] *** ugexe left
[18:30] *** integral_ left
[18:30] *** maettu left
[18:32] *** rindolf joined
[18:32] *** dalek joined
[18:32] *** ChanServ sets mode: +v dalek

[18:36] <lucasb> About these classes that can't be subclassed like Set, isn't the problem the fact they have an explicit .new constructor that calls nqp::create(self).BUILD(...) ? Shouldn't these classes let Mu.new do this job? There are more classes that are like these, just grep the source for this build idiom.

[18:37] <lucasb> m: class S is Set { submethod BUILD {} }; say S.new

[18:37] <camelia> rakudo-moar dd3bcc: OUTPUT«Type check failed for return value; expected 'Setty' but got 'Any'␤  in block <unit> at /tmp/o8xo_p97Gf:1␤␤»

[18:37] *** spider-mario left
[18:37] <jnthn> lucasb: That's most probably the issue, yes

[18:38] <jnthn> Cheating is OK, but if it breaks inheritance the cheating should be done as a submethod too...

[18:38] *** spider-mario joined
[18:40] <moritz> moritz@pat:~/p6/rakudo$ git grep 'method BUILD' src/core/|grep -v submethod|wc -l

[18:40] <moritz> 8

[18:41] * moritz tries a simple s/method/submethod/ for BUILD in Set

[18:41] <moritz> and spectests, no less :-)

[18:41] *** Hor|zon joined
[18:43] * TimToady thinks the implementation of Sets is overcomplicated anyway

[18:47] <lizmat> moritz: eh, I just changed the submethod to method to fix subclassing Set ???

[18:48] <jnthn> It's the cheating new that I meant may want to be a submethod...

[18:48] <lizmat> ah...

[18:49] <jnthn> But perhaps best is to avoid cheating.

[18:49] <jnthn> :)

[18:50] <lizmat> well, but then the subclass would need to do nqp magic anyway to set %!elems ?

[18:50] <lizmat> TimToady: care to elaborate on the "overcomplicated" bit ?

[18:51] <lizmat> afair, part of the complication was because of the requirement that a Set should be a valid key in a Set

[18:51] <lizmat> aka, be kept as an object, not as a stringification

[18:51] <TimToady> that's just object hash

[18:51] <TimToady> doesn't need to map to a pair

[18:51] <TimToady> mapping to a pair, as I understand it, is an optimization to make .pairs faster

[18:52] <TimToady> and I think that's probably a false economy, if so

[18:52] <lizmat> have you looked at object hash implementation?  I mean, *that* looks like overcomplicated

[18:52] <jnthn> I suspect it's 'cus our guts don't understand objects hashes properly yet.

[18:52] <lizmat> keeping an internal has both for key as well as value ?

[18:52] <lizmat> *has

[18:52] <lizmat> *hash

[18:52] <jnthn> You're making a write has of typing that... :P

[18:52] <jnthn> But yeah, the object hash approach is no better, and memory wise perhaps worse.

[18:53] <jnthn> Performance wise possibly worse too.

[18:53] <lizmat> eh, my point exactly  :-)

[18:53] <TimToady> well, isn't that because we're really slow on .WHICH still?

[18:53] <TimToady> we should fix that

[18:54] <lizmat> having object hashes in the VM would solve most of this

[18:54] <jnthn> TimToady: .WHICH is slow 'cus it has to construct a string, which in turn is because the VM level doesn't yet support object hashes.

[18:55] <jnthn> And what lizmat++ said, and yes, I agree we *should* fix it, but because the current workarounds, well, work around, it never hit high enough on the priority list yet.

[18:55] * TimToady thinks bypassing object hashes is a premature optimization

[18:55] <TimToady> sure, just sayin' :)

[18:55] <japhb> jnthn: I used to understand why Parrot-specific code in Rakudo was different from the non-Parrot code (different object model details and such), but why are there so many differences still from jvm v. moarvm, when the different code paths appear to be simple transforms of each other?  src/core/Mu.pm:416-426 is an example of this.

[18:55] <jnthn> TimToady: You mean implementing Set in terms of object hashes?

[18:55] <jnthn> japhb: Economics.

[18:56] <lizmat> fwiw, object hashes did not work in core settings at the moment Sets/Bags/Mixes were implemented

[18:56] <TimToady> jnthn: yes, I think object hashes are the natural fit to sets/bags

[18:56] <japhb> jnthn: *blink* *blink*  Wait, what?

[18:56] <lizmat> this was pre-parameterize functionality in core

[18:56] <TimToady> lizmat: sure, not quibbling with the history :)

[18:57] *** tadzik joined
[18:57] <TimToady> just saying we may have got to a bit of a false minimum on current set/bag simplicity

[18:57] <lizmat> fwiw, I think the approach taken with Sets/Bags/Mixes are a natural fit or object hashes

[18:57] <lizmat> until we have object hashes in the VM

[18:57] <lizmat> *for

[18:57] <jnthn> japhb: They paper over inconsistencies that take effort to fix, probably need somebody like me to make a design call, and the interest rate on the technical debt is low enough that it's not a useful use of anyone's time to deal with at the moment.

[18:58] <jnthn> If somebody wants to patch them, sure, I'll take the patches. :)

[18:58] <jnthn> They're just not hugely painful.

[18:58] <japhb> jnthn: Oh.  Is there any list of what those inconsistencies *are*, so someone who wants to go hacking doesn't unnecessarily break jvm?

[18:59] <jnthn> japhb: No, but if I wanted one I'd grep for "#?if jvm" :)

[18:59] <japhb> :-P

[19:00] <japhb> Well, I guess I'm trying to understand what actually makes those two chunks of code materially different from a VM point of view.

[19:00] <japhb> (As an example.)

[19:00] <japhb> It looks a bit chicken-wavey.

[19:01] <jnthn> I suspect indecision on if nqp::clone should decont or not

[19:01] <dalek> rakudo/nom: ccb41d8 | moritz++ | src/core/Set.pm:

[19:01] <dalek> rakudo/nom: Change Set.BUILD to be a submethod

[19:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ccb41d81b8

[19:01] <jnthn> Though...that may not entirley explain it either.

[19:02] <jnthn> The JVM one may well be losing the typedness of a container also

[19:02] *** bin_005 joined
[19:03] *** muraiki joined
[19:03] <lizmat> japhb: the JVM version was the original version of the code

[19:04] <lizmat> the MoarVM version was an improved version that fixed a bug, but which broke on the JVM

[19:05] <lizmat> moritz: why are you only partiallly reverting b6fae27eceb094d5739f94 ?

[19:06] <lizmat> moritzL and BTW, I'm pretty sure that #125611 is now broken again

[19:06] <moritz> lizmat: sorry, I thought subclassing Set was broken because BUILD was not a submethod

[19:06] <lizmat> it was broken because it *was* (afaik)

[19:06] <moritz> lizmat: if it's meant to be overridable, it shouldn't be called BUILD

[19:07] <moritz> lizmat: and fwiw, no spectest broke due to my patch

[19:07] <moritz> m: class S is Set { }; say S.new

[19:07] <camelia> rakudo-moar dd3bcc: OUTPUT«S.new()␤»

[19:07] <jnthn> If we want to do cheating construction, maybe we should be declaring a private method to do it.

[19:07] <moritz> jnthn: it's not so easy, because the role must call the one from the class it's mixed into

[19:07] <jnthn> ah...

[19:07] <japhb> lizmat, jnthn: OK, thank you for the explanation on that ('#?if jvm' in method clone).

[19:07] <lizmat> moritz: no spectest broke due to my change either

[19:08] <dalek> rakudo/nom: ab137b7 | moritz++ | src/core/Set.pm:

[19:08] <dalek> rakudo/nom: Revert "Change Set.BUILD to be a submethod"

[19:08] <dalek> rakudo/nom: 

[19:08] <dalek> rakudo/nom: This reverts commit ccb41d81b8534ddfc89b67261f8d328efdb56505.

[19:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ab137b7498

[19:08] *** flussence joined
[19:08] <moritz> lizmat: ok, my approach would be to rename BUILD to INIT or so, so that we don't break the assumption that BUILD is a submethod

[19:08] *** flussence left
[19:09] *** flussence joined
[19:10] <japhb> My *original* question was: What guarantees is 'method clone' suppose to supply?  As far as I understand the code, it looks like "clone the top level of attributes (both private and public), make sure the *containers* for the attributes are cloned, not just the contents, and allow override of values for public attributes".  Is that the true intent?

[19:10] <lizmat> moritz: well, there's about 16 files in core that call .BUILD inside .new themselves

[19:10] <moritz> lizmat: and they all shouldn't be using BUILD

[19:10] *** flussence left
[19:10] <moritz> lizmat: I know the early ones are left over from before we had submethods

[19:10] <lizmat> well, then we should go in and change that

[19:11] *** flussence joined
[19:11] * moritz tries

[19:11] * lizmat goes sightseeing&

[19:11] <moritz> m: say Set.new('a', 'b')

[19:11] <camelia> rakudo-moar dd3bcc: OUTPUT«set(a, b)␤»

[19:12] <lucasb> lizmat++, moritz++: thanks for taking a look at this; and sorry for starting this confusion :)

[19:12] <jnthn> japhb: Yes, but I think we need to be smarter on what "container" means perhaps

[19:17] <jaffa4> Is it possible to have an object id of nqp object?

[19:18] <masak> japhb: dunno if this helps, but my perspective on `.clone` is slightly different: $o.clone(|%new-attrs) == $o.new(|%o-attrs, |%new-attrs)

[19:18] <masak> jaffa4: what are you trying to accomplish?

[19:19] <jaffa4> to make it a key of a hash

[19:19] <jnthn> my %h{Mu}; # now you can store objects as keys

[19:19] <masak> jnthn++

[19:19] <jaffa4> It seems to crash

[19:19] <masak> golf'd or it didn't happen

[19:19] <jnthn> m: my %xy{Mu};

[19:19] <camelia> rakudo-moar dd3bcc: ( no output )

[19:20] <jnthn> Looks OK to me

[19:20] <moritz> lucasb: you didn't start the confusion, you just uncovered it

[19:20] <jnthn> m: class x { }; class y { }; my %h{Mu}; %h{x.new, y.new} = 'problem' xx 2; say %h.perl

[19:20] <camelia> rakudo-moar dd3bcc: OUTPUT«Hash[Any,Mu].new(x.new => "problem", y.new => "problem")␤»

[19:21] <jnthn> Note the keys there are objects, not strings.

[19:22] <moritz> m: my %xy{Mu}; %xy{1&2} = 3; say %xy.perl

[19:22] <camelia> rakudo-moar ccb41d: OUTPUT«Hash[Any,Mu].new(1 => 3, 2 => 3)␤»

[19:22] <moritz> bug

[19:23] <jnthn> hah...I wonder if the postcircumfix sub is to blame...

[19:24] * masak submits rakudobug

[19:25] <jnthn> masak++

[19:25] <jaffa4> here it is https://gist.github.com/jaffa4/fc077b6ba4b62781b836

[19:25] <masak> think of it this way: I'm not so much increasing the RT ticket count, as keeping down the number of discovered but unreported bugs :P

[19:26] <masak> jaffa4: that's... relatively golfed, actually. kudos.

[19:26] *** atroxaper joined
[19:27] <masak> jaffa4: from a quick scan, that looks like it should survive.

[19:27] <masak> jaffa4: a stylistic tip is to use `:exists`, not `.KEY-EXISTS`

[19:27] <masak> (but that likely won't fix your crash)

[19:28] <jaffa4> and sometimes walking through the tree leads to infinite loop

[19:28] <jaffa4> Is that likely, jnthn?

[19:28] <jnthn> it'd have to be %visited_objects.KEY-EXISTS($tree)

[19:28] <jnthn> japhb: It's not strictly a tree

[19:28] <jnthn> oops

[19:29] <jnthn> jaffa4: ^^

[19:29] <jnthn> A QAST::BVal can reference a QAST::Block elsewhere for example

[19:29] <masak> jaffa4: if you are walking the tree, you need to handle loops yourself.

[19:29] <jnthn> And some things share sub-trees

[19:29] <masak> jaffa4: basically like Data::Dumper does.

[19:29] <jaffa4> So loops are logical, to be expected?

[19:29] <masak> jaffa4: yes.

[19:30] <jnthn> NQP objects don't have a .WHICH, though, so dunno how putting them in a Perl 6 object hash will work out...

[19:30] <jaffa4> I just need to get a unique id out of them

[19:30] <jnthn> jaffa4: It depends exactly what you traverse. 

[19:30] <jaffa4> Is there any?

[19:30] <jnthn> nqp::objectid(...) may cut it

[19:30] *** atroxaper left
[19:30] <masak> jnthn: people are bound to want to put foreign-language objects in Perl 6 hashes, though...

[19:31] *** kaare_ left
[19:31] <jnthn> masak: Yeah, but making Perl 6 things work with Perl 6 things is apparently providing us with quite enough work at the moment ;)

[19:31] <jnthn> We can do better overall on NQP/Perl 6 interop

[19:33] <masak> might prove an interesting guiding example for any-lang/Perl 6 interop :)

[19:34] * masak .oO( "why doesn't this interop work?" -- "well, you just hit one of the 'not quite' parts..." )

[19:34] <jnthn> :P

[19:35] <jnthn> nine++ seems to be doing a very nice job on Perl 5 and Python interop :)

[19:35] <masak> ooh! oooooh! has anyone made Perl 5 interop *with Python* *through Perl 6* yet?

[19:35] <masak> that's a lightning talk all on its own!

[19:36] <masak> jnthn++ # I read your sentence wrong first, which gave me the idea :P

[19:40] <jaffa4> jnthn: I am reading The use of nqp::operations has been deprecated for non-CORE code.

[19:41] <jaffa4> What is not portable about it?

[19:41] <jnthn> jaffa4: It's specific to Rakudo

[19:42] <jnthn> jaffa4: And even in Rakudo we don't commit to any back-compat

[19:42] <jnthn> (Though a lot of things are highly unlikely to change.)

[19:43] <jnthn> (And to the degree NQP is intended as a compiler construction toolkit, we may well commit a little more strongly at some point in the future.

[19:43] <jnthn> )

[19:45] <tadzik> masak: I think nine already did a talk that did that :)

[19:45] <tadzik> maybe even on FOSDEM

[19:45] <tadzik> I vaguealy remember seeing it

[19:46] <masak> oh! nine++

[19:49] *** [TuxCM] joined
[19:49] *** vytas joined
[19:49] *** maettu joined
[19:49] *** Foxcool joined
[19:49] *** RabidGravy joined
[19:49] *** ggoebel joined
[19:52] *** Spot__ joined
[19:52] *** timotimo joined
[19:52] *** yogan joined
[19:52] *** retupmoca joined
[19:52] *** hoelzro_trying_w joined
[19:52] *** ugexe joined
[19:55] *** zostay left
[19:55] *** zostay joined
[19:56] *** diana_olhovik left
[19:56] *** isacloud joined
[20:04] <dalek> rakudo/nom: fbdc745 | moritz++ | src/core/Set (2 files):

[20:04] <dalek> rakudo/nom: Improve Set construction

[20:04] <dalek> rakudo/nom: 

[20:04] <dalek> rakudo/nom: make Setty.BUILD a submethod, remove Set.BUILD.

[20:04] <dalek> rakudo/nom: This way, Set is still subclassable, and the assumption that BUILD

[20:04] <dalek> rakudo/nom: is a submethod still holds.

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fbdc74569e

[20:04] *** ggherdov joined
[20:04] <dalek> roast: bb2d247 | moritz++ | S02-types/set.t:

[20:04] <dalek> roast: RT #125611: basic test for Set subclassability

[20:04] <dalek> roast: review: https://github.com/perl6/roast/commit/bb2d247c77

[20:05] *** domidumont joined
[20:10] *** zakharyas joined
[20:11] *** muraiki left
[20:11] *** araujo left
[20:14] *** lucasb left
[20:16] <dalek> roast: f94e52b | moritz++ | S02-types/bag.t:

[20:16] <dalek> roast: RT #125611: Test subclassability of Bag

[20:16] <dalek> roast: review: https://github.com/perl6/roast/commit/f94e52b478

[20:17] <dalek> rakudo/nom: 8957fc5 | moritz++ | src/core/Baggy.pm:

[20:17] <dalek> rakudo/nom: Uncheat in Bag constructor

[20:17] <dalek> rakudo/nom: 

[20:17] <dalek> rakudo/nom: this preserves subclassability, and makes BUILD a submethod again

[20:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8957fc56f6

[20:18] *** araujo joined
[20:23] *** bougyman joined
[20:23] <bougyman> getting an error with panda install Test::Star that's pretty obvious: "# Connect failed with error DBD::mysql connection failed: Access denied for user 'testuser'@'localhost' (using password: YES)

[20:23] <bougyman> "

[20:23] <bougyman> is there a particular password it wants?

[20:23] *** araujo left
[20:24] <moritz> bougyman: yes; see t/25-mysql-comon.t for the configuration

[20:24] *** darutoko left
[20:24] <moritz> bougyman: though it should skip the tests if the connection fails

[20:24] *** domidumont left
[20:25] <bougyman> moritz: it doesn't skip them

[20:25] <bougyman> thanks. had to find where it buried that in ~/.rakudobrew

[20:26] <bougyman> first I had to install sqlite and mysqlite devel (already had pg)

[20:26] <bougyman> then had to start mariadb, create testuser. now it looks like he needs privs granted.

[20:27] <moritz> bougyman: please nopaste the output you get

[20:27] <moritz> (from before you created the user)

[20:28] *** araujo joined
[20:30] *** jaffa4 left
[20:32] <bougyman> moritz: https://gist.github.com/bougyman/1831a4fa9a7705486ce0

[20:32] <bougyman> that was before I even installed mysql/sqlite -devel packages

[20:32] <bougyman> you want it from after, too?

[20:32] *** zakharyas left
[20:33] <moritz> bougyman: no thanks, that's fine

[20:33] <bougyman> um, hrm.

[20:33] <bougyman> I put the output post-install of the -devel libs in a comment and gh marked it up, heh.

[20:33] <moritz> bougyman: actually, most of these tests still pass

[20:33] <bougyman> yes, but DBIish does not install.

[20:34] <dalek> DBIish: da430bf | moritz++ | t/99-common.pl6:

[20:34] <dalek> DBIish: Avoid superstious use of capture

[20:34] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/da430bfc62

[20:35] * moritz can't spell

[20:36] *** xfix left
[20:38] <dalek> DBIish: 250acbb | moritz++ | t/35-Pg-common.t:

[20:38] <dalek> DBIish: Fix skipping of Pg tests

[20:38] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/250acbbdb1

[20:45] <vendethiel> m: subset File of Str where .IO.e; "a" ~~ File;

[20:45] <camelia> rakudo-moar fbdc74: ( no output )

[20:45] <vendethiel> m: subset File of Str where .IO.e; say "a" ~~ File;

[20:45] <camelia> rakudo-moar fbdc74: OUTPUT«False␤»

[20:45] <vendethiel> m: "a".IO.WHAT.perl.say

[20:45] <camelia> rakudo-moar fbdc74: OUTPUT«IO::Path␤»

[20:46] <vendethiel> a subset of a type weighs more in MMD than the parent type, correct?

[20:46] <moritz> bougyman: should be fixed now

[20:46] <moritz> vendethiel: right

[20:46] <bougyman> just pull or just run panda again?

[20:47] <bougyman> doing panda install Task::Star, atm.

[20:47] <moritz> bougyman: should be fine

[20:47] *** AlexDaniel joined
[20:47] <bougyman> it didn't do any git updates

[20:47] <bougyman> and failed again.

[20:47] <bougyman> I think I need to update the git manually

[20:47] <bougyman> yep, that did it.

[20:48] <bougyman> thanks a lot

[20:48] <vendethiel> m: slurp "a";

[20:48] <camelia> rakudo-moar fbdc74: OUTPUT«Failed to open file /home/camelia/a: no such file or directory␤  in block <unit> at /tmp/n6PmzSw3EH:1␤␤»

[20:48] <vendethiel> ^ seems dangerous? 

[20:49] <vendethiel> m: subset File of Str where .IO.e; sub read(File $f) { say slurp $f; }

[20:49] <camelia> rakudo-moar fbdc74: ( no output )

[20:49] <vendethiel> ^ outside from race conditions (if someone deletes the file while we're entering the sub), this is exception-free, right? (if we do enter the sub)

[20:49] <moritz> vendethiel: you could still get a "permission denied"

[20:50] *** TEttinger joined
[20:50] <jnthn> vendethiel: Just 'cus the file exists I guess doesn't automatically mean you'll be able to read it

[20:50] <moritz> or it could be not UTF-8 (which slurp assumes by default)

[20:50] <jnthn> Or that

[20:50] <vendethiel> right. :P I'll put '"almost" exception free' there

[20:50] <moritz> :-)

[20:51] <jnthn> If you know races are possible, then "forgiveness is better than permission" is generally good advice though :)

[20:51] <vendethiel>     say slurp $f; # (almost) exception-free (forget about race conditions, permissions, encoding, ...)

[20:51] <vendethiel> ^ I'll leave it at that :D.

[20:51] <jnthn> There's no race there :)

[20:51] <vendethiel> jnthn: well, I'm demonstrating the "File $f" subset thingie, so there could be

[20:51] <jnthn> It's a race if you ask if you can, then do, and the answer can change between asking and doing.

[20:52] <jnthn> vendethiel: Ah, then yes, there can be one with that :)

[20:54] <AlexDaniel> Hi! I've already asked this question 15 hours ago but maybe it was not crowdy enough. I'm trying to create a sub using a macro. Here are my attempts:

[20:54] <AlexDaniel> m: macro FOO { quasi { sub Bar { say 'woohooo'}; }; }; FOO; Bar();

[20:54] <camelia> rakudo-moar 8957fc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3T9nS7fCPC␤Undeclared name:␤    Bar used at line 1. Did you mean 'Bag'?␤␤»

[20:54] <AlexDaniel> and another one trying to return a string:

[20:54] <AlexDaniel> m: macro FOO { ‘sub Bar { say 'woohooo'}’ }; FOO; Bar();

[20:54] <camelia> rakudo-moar 8957fc: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[20:54] <masak> the error message could be better.

[20:54] <masak> but returning strings from macros is NYI.

[20:55] <AlexDaniel> masak: ok, now it makes sense

[20:55] <masak> and will be until that kind of macros gets a champion.

[20:55] <AlexDaniel> because it should be possible according to the spec but does not work at all

[20:55] * masak is the AST kind of macro champion

[20:55] <vendethiel> m: macro FOO { ‘sub Bar { say 'woohooo'}’ }; FOO; 

[20:55] <camelia> rakudo-moar 8957fc: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[20:55] <AlexDaniel> masak: ok, my champion, how can I create a sub?

[20:55] <vendethiel> okay, yes :).

[20:55] <vendethiel> AlexDaniel: can't

[20:56] <AlexDaniel> ummm.. why..?

[20:56] <masak> lately I've been wondering if macros oughtn't be *un*hygienic by default. so that people can create their bloody subs.

[20:56] <AlexDaniel> because I really want to :)

[20:56] <masak> it seems a common enough use case.

[20:56] <masak> and hygiene (according to "Let Over Lambda") isn't a panacea anyway.

[20:56] <masak> will write a blog post about this at some point.

[20:57] <PerlJam> masak: iterative hygiene should work well :)

[20:57] <masak> if by that you mean "hygiene should be opt-in", then we are in agreement.

[20:58] <PerlJam> yeah

[20:58] <masak> I'm starting to think that, yes.

[20:59] <masak> "hygiene on by default" *sounds* good, and I've always assumed it's the way it should be in Perl 6. but now I'm not so sure.

[20:59] <masak> people's Least Surprise actually seems to be unhygiene.

[20:59] <PerlJam> indeed.

[20:59] <PerlJam> well ... that's least surprise until it surprises someone

[20:59] <masak> something like `quasi { sub {{{$ident}}} { ... } }`

[21:00] <vendethiel> masak: it's always such a fight between CL and scheme-like

[21:01] <vendethiel> masak: http://www.reddit.com/r/lisp/comments/3actsc/let_over_lambda/

[21:01] <masak> vendethiel: yeah, I got that feeling too.

[21:01] <masak> so I guess the question is: is Perl 6 more like CL, or like Scheme? :P

[21:01] <PerlJam> Maybe we should have 2 macro mechanisms

[21:01] <masak> oh, I'm counting something like 4 so far.

[21:02] <masak> but I'm still designing/prototyping.

[21:02] <vendethiel> masak: read https://groups.google.com/forum/#!topic/plt-scheme/5cMVPkGsueo :)

[21:02] * masak reads, and saves URLs for later

[21:03] <AlexDaniel> masak: 4?

[21:04] <vendethiel> masak: passing identifiers is another solution ;-)

[21:05] <masak> AlexDaniel: thereabouts.

[21:05] <vendethiel> macro F(\id) {}; F(my &id);

[21:05] <masak> AlexDaniel: and I didn't count the textual macros, because I don't count textual macros.

[21:06] *** danstone1 is now known as danstoner

[21:14] *** atroxaper joined
[21:15] * [Coke] wonders why people want to create subs from macros instead of via MOP.

[21:15] <vendethiel> [Coke]: subs, not methods

[21:15] <masak> MOP is for the object system.

[21:15] <[Coke]> ok, rephrasing:

[21:15] * [Coke] wonders why people want to create subs from macros instead of methods via MOP. :)

[21:16] <masak> [Coke]: but you're right -- there is often an overlap between macros and MOP. I want to learn more about how we can make those two co-exist peacefully.

[21:16] <jnthn> I already showed how to write a module that generates subs on import.

[21:16] <[Coke]> if it has to be subs, EVAL seems like the evil of choice that works today.

[21:16] <[Coke]> jnthn++

[21:17] <jnthn> It's somewhere in http://jnthn.net/papers/2015-fosdem-static-dynamic.pdf

[21:17] <jnthn> No EVAL required :)

[21:17] <PerlJam> EVAL is the poor-man's macro system

[21:18] <masak> EVAL is to structured code building as textual macros are to macros.

[21:19] <masak> neither composes very well.

[21:19] *** atroxaper left
[21:21] * [Coke] reads the dynamic sub export trick again. very nice.

[21:24] *** rindolf left
[21:26] <masak> "Like training wheels on a bicycle, hygiene systems are for the most part toys that should be discarded after even a modest level of skill has been acquired." -- Let Over Lambda, quoted in https://groups.google.com/forum/#!topic/plt-scheme/5cMVPkGsueo

[21:30] <PerlJam> because the experienced programmer always knows what they are doing, right?

[21:31] <jnthn> Sure. Programming!

[21:31] <vendethiel> if only :)

[21:32] *** spider-mario left
[21:35] *** RabidGravy left
[21:36] <masak> well, if there's anything that shouldn't necessarily come with safeties turned on to the max, it's macros.

[21:37] <masak> their job is basically to cause interesting changes.

[21:39] <AlexDaniel> yea, like create subs...

[21:39] <masak> aye.

[21:40] <masak> the way the spec stands right now, you're expected to install the sub in the COMPILING:: namespace.

[21:40] <PerlJam> you also don't want the safeties completely absent such that the intrepid programmer slices off an virtual appendage on first use without realizing how or why

[21:41] <jnthn> "stick it in COMPILING::" sounds quite reasonable to me.

[21:41] <jnthn> Heck, if we could even make basic cases of sub generation work without any quasi stuff by using COMPILING, if I understand it right :)

[21:43] <masak> I... think it still needs to go in the quasi...

[21:44] <masak> each macro invocation needs to create a completely new sub. not just a new clone of an existing sub.

[21:44] <jnthn> Why?

[21:45] <masak> maybe not in the general case. but often you want to name the sub with `sub {{{$ident}}} { ... }`

[21:45] <jnthn> True 

[21:45] <jnthn> But that only counts for introspection :)

[21:46] <jnthn> You can install it in COMPILING under a name of your choice.

[21:49] <masak> also true.

[21:50] <masak> but... you can access COMPILING:: from outside the quasi?

[21:50] <masak> I clearly need to understand more about COMPILING::

[21:50] <masak> since the quasi runs at a completely different phase, I had just assumed that it was the one with a COMPILING:: namespace, but not its outside.

[21:54] <jnthn> Ah

[21:54] <jnthn> I'd thought it was reachable in a BEGIN too

[21:57] <masak> if it's reachable in a BEGIN, it probably is in a macro.

[21:57] <masak> this sounds like something we've talked about before :)

[21:58] * masak checks the spec

[21:58] <masak> Within code that is being run during the compile, such as C<BEGIN> blocks,

[21:58] <masak> or macro bodies, or constant initializers, the compiler variables must be

[21:58] <masak> referred to as (for instance) C<< COMPILING::<$?LINE> >> if the bare

[21:58] <masak> C<$?LINE> would be taken to be the value during the compilation of the

[21:58] <masak> currently running code rather than the eventual code of the user's

[21:58] <masak> compilation unit.

[21:58] <masak> that's from S02.

[21:59] <vendethiel> jnthn: "we" (and that means masak and me, I guess?) are wondering a bit about MOP / macros implications

[21:59] <masak> For instance, within a macro body C<$?LINE> is the line

[21:59] <masak> within the macro body, but C<< COMPILING::<$?LINE> >> is the line where the

[21:59] <masak> macro was invoked.

[21:59] <masak> so, that's pretty clear. COMPILING:: works outside of a quasi.

[22:02] <jnthn> vendethiel: That's a bit too general for me to answer ;)

[22:02] <vendethiel> jnthn: well, it'd be a long discussion to have

[22:02] <masak> one I look forward to having

[22:02] <vendethiel> (and TimToady weighing in that one would be great as well, I guess)

[22:02] <masak> need more data, though

[22:02] <vendethiel> the snake is biting its tail!

[22:04] <jnthn> :)

[22:04] <jnthn> I'm too tired to do it now.

[22:04] <vendethiel> Yeah, I guessed as much

[22:05] <masak> me too.

[22:05] <masak> 'night, #perl6

[22:08] *** flussence left
[22:08] *** flussence joined
[22:14] <jnthn> sleep &

[22:15] <AlexDaniel> jnthn: running sleep in the background?

[22:15] <AlexDaniel> not sure if this is going to work

[22:24] *** bin_005 left
[22:26] *** espadrine left
[22:28] *** salv0 left
[22:29] *** hoelzro_ is now known as hoelzro

[22:53] *** pat_js joined
[23:02] *** Ven joined
[23:18] *** amurf joined
[23:25] <TimToady> lolihazinterviewed http://www.linuxvoice.com/interview-larry-wall/

[23:33] *** pyro- joined
[23:40] *** virtualsue left
[23:43] *** ribasushi joined
[23:47] *** laouji joined
[23:49] *** cognominal joined
[23:56] *** bjz left
[23:57] *** bjz joined
[23:58] <skids> m: try fail "foo"; my $f = $!.backtrace; say ($f.Str ~ "//") for ^5; # what i'm trying to hunt down at present

[23:58] <camelia> rakudo-moar 8957fc: OUTPUT«  in block <unit> at /tmp/oQq6YqFse4:1␤//␤  in any command_eval at src/Perl6/Compiler.nqp:1␤//␤  in any MAIN at src/gen/m-main.nqp:39␤  in any <mainline> at src/gen/m-main.nqp:35␤  in any <main> at /home/camelia/rakudo-inst-2/share/perl6/runtim…»

