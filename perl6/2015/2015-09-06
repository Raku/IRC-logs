[00:14] *** Peter_R left
[00:32] *** yqt left
[00:32] *** vendethiel- left
[00:33] *** rangerprice joined
[00:33] <rangerprice> Hi everyone

[00:36] *** colomon joined
[00:39] *** colomon left
[00:39] *** colomon joined
[00:50] *** n0tjack joined
[00:50] *** BenGoldberg joined
[00:54] *** n0tjack left
[01:16] *** aborazmeh left
[01:18] *** colomon left
[01:19] *** colomon joined
[01:22] *** gfldex left
[01:25] *** abaugher left
[01:26] *** abaugher joined
[01:37] *** aborazmeh joined
[01:37] *** aborazmeh left
[01:37] *** aborazmeh joined
[02:06] *** noganex_ joined
[02:09] *** noganex left
[02:30] <colomon> m: say List ~~ Positional

[02:30] <camelia> rakudo-moar e6f360: OUTPUT«True␤»

[02:36] *** laouji joined
[02:36] <ShimmerFairy> .tell jnthn I put japhb's code in val(), with minimum modification to make it work properly, and got marginal improvements (null program startup decreased by about .01s, profiling sorting line shows it went down ≈1.2s). It's of course better (so I'll keep it in ☺), but val()'s implementation seems to be a non-issue now

[02:36] <yoleaux> ShimmerFairy: I'll pass your message to jnthn.

[02:39] <ShimmerFairy> .tell jnthn I suspect having a version of val() in World.nqp, or perhaps even in NQP itself, for strings with compile_time_values would be the most helpful, considering how many constant strings in quotewords there are in CORE and such :)

[02:39] <yoleaux> ShimmerFairy: I'll pass your message to jnthn.

[02:46] *** Sqirrel left
[02:54] *** n0tjack joined
[02:58] *** ggoebel left
[02:59] *** n0tjack left
[03:01] *** skids joined
[03:02] *** ggoebel joined
[03:03] *** ggoebel2 joined
[03:05] *** Sqirrel joined
[03:06] *** ggoebel left
[03:10] *** aborazmeh left
[03:11] *** laouji left
[03:12] *** laouji joined
[03:15] *** ifim left
[03:16] *** laouji left
[03:16] *** laouji_ joined
[03:40] *** n0tjack joined
[03:47] *** lolisa joined
[03:52] *** AlexDaniel left
[04:01] *** orbusbak joined
[04:02] *** gfldex joined
[04:02] *** orbusbak left
[04:02] *** orbusbak joined
[04:05] *** orbus left
[04:08] *** skids left
[04:21] *** laouji_ left
[04:26] *** laouji joined
[04:30] *** MadcapJake joined
[04:33] *** n0tjack left
[04:36] * jdv79 has never used :right

[04:40] *** BenGoldberg left
[04:41] *** khw left
[04:46] <dalek> roast/allomorphs: 27cc5ac | ShimmerFairy++ | S32-str/numeric.t:

[04:46] <dalek> roast/allomorphs: Improve testing functions in S32-str/numeric.t

[04:46] <dalek> roast/allomorphs: 

[04:46] <dalek> roast/allomorphs: The failure check now prints a .perl of the string it was given, so that

[04:46] <dalek> roast/allomorphs: the output makes sense (changing it from  Q[+-3/-2]  to  Q[+"-3/-2"] ,

[04:46] <dalek> roast/allomorphs: for example). The success check now uses 'is' instead of the weird use

[04:46] <dalek> roast/allomorphs: of 'ok' shown before, since 'is' works just fine.

[04:46] <dalek> roast/allomorphs: review: https://github.com/perl6/roast/commit/27cc5ac12d

[04:47] <MadcapJake> in Supply's `done` method, why does it call the result of `$t.done()` https://github.com/rakudo/rakudo/blob/nom/src/core/Supply.pm#L74

[04:50] <dalek> rakudo/allomorphs: 7d56f92 | ShimmerFairy++ | src/core/ (2 files):

[04:50] <dalek> rakudo/allomorphs: Reinstate the string-to-number code by japhb++

[04:50] <dalek> rakudo/allomorphs: 

[04:50] <dalek> rakudo/allomorphs: It's a bit faster than my version, and it was the original

[04:50] <dalek> rakudo/allomorphs: implementation, so in it goes, in preference of me wasting time trying

[04:50] <dalek> rakudo/allomorphs: to optimize my version further (since such optimizations at this point

[04:50] <dalek> rakudo/allomorphs: would've been of the trickier, more subtle variety).

[04:50] <dalek> rakudo/allomorphs: 

[04:50] <dalek> rakudo/allomorphs: The biggest functional change to it, aside from making it work in val(),

[04:50] <dalek> rakudo/allomorphs: was disallowing 'Infi' and 'NaNi' as valid numbers. Other test failures

[04:50] <dalek> rakudo/allomorphs: as a result of this code concern things like if Rat fractions should

[04:50] <dalek> rakudo/allomorphs: allow negative denominators, so it's been left untouched for now.

[04:50] <dalek> rakudo/allomorphs: 

[04:50] <dalek> rakudo/allomorphs: Unfortunately, it seems that the particular implementation of val() is

[04:50] <dalek> rakudo/allomorphs: not the cause for the perceived slowdown anymore, so this replacement

[04:50] <dalek> rakudo/allomorphs: doesn't offer much improvement. The cause is likely the existence of a

[04:50] <dalek> rakudo/allomorphs: bunch of val() calls on quotewords in CORE existing now. Handling val()

[04:50] <dalek> rakudo/allomorphs: calls at compile time where possible might offer the best improvement at

[04:50] <dalek> rakudo/allomorphs: this point.

[04:50] <dalek> rakudo/allomorphs: review: https://github.com/rakudo/rakudo/commit/7d56f92208

[04:58] *** dustinm` left
[05:03] *** dustinm` joined
[05:14] *** Sqirrel_ joined
[05:14] *** Sqirrel left
[05:14] *** rangerprice left
[05:24] *** laouji left
[05:28] <moritz> ShimmerFairy: marking the val(|) proto as 'is pure' might help to promote some calls to compile time

[05:29] <ShimmerFairy> moritz: oh, what does 'pure' mean?

[05:31] <ShimmerFairy> nvm, found the doc :)

[05:40] <moritz> for the record, it means "can be constant-folded"

[05:44] <MadcapJake> anyone able to answer my question above? Just trying to understand why Supply's done method calls the result of `$t.done()`? I thought `done` was jut a supplied callback?

[05:46] <MadcapJake> is it because `$l` could be a Lock?

[05:48] <MadcapJake> no, that couldn't be it because `&.done` is just a callback, it's not something handled internally.

[05:53] *** kaare_ joined
[06:01] *** perl6_newbee joined
[06:06] <MadcapJake> It seems like both `done` and `emit` invoke themselves before proceding (emit procedes by invoking again with `msg` and done procedes by invoking if not nil). Is that accurate?   I don't quite understand why that's necessary.

[06:15] <moritz> I thought 'done' invoked the 'done' callback of the tap(s)

[06:24] *** laouji joined
[06:25] <MadcapJake> yeah it does, i just am trying to follow the code: `for self.tappers -> $t {my $l = $t.done(); $l() if $l;}`

[06:26] <MadcapJake> what does the `$l() if $l` mean? I don't follow why that's necessary.

[06:29] *** laouji left
[06:31] *** xfix joined
[06:33] *** laouji joined
[06:39] *** lolisa left
[06:40] *** RabidGravy joined
[06:45] *** CIAvash joined
[06:46] *** rurban joined
[06:47] <RabidGravy> marning!

[06:59] <ShimmerFairy> moritz: hm, adding a 'proto sub val(|) is pure {*}' seems to have made things worse. I'll try adding 'is pure' to just the single-value multi, though. (It does seem to have done stuff, at least, seeing as the optimize stage goes up about 10s with the addition ☺)

[07:04] *** CIAvash left
[07:05] *** CIAvash joined
[07:11] *** TEttinger left
[07:12] *** TEttinger joined
[07:13] *** darutoko joined
[07:13] *** CIAvash_ joined
[07:13] *** CIAvash_ left
[07:15] *** CIAvash left
[07:20] *** ab5tract_ joined
[07:21] <ab5tract_> .tell MadcapJake that's because the return value of $tap.done() is the callback itself

[07:21] <yoleaux> ab5tract_: I'll pass your message to MadcapJake.

[07:22] <ab5tract_> m:  class Hap { has &.done }; my $f = Hap.new( done => { say "here we go"; 42 } ); my $b = $f.done(); $b.WHAT.say; $b().say

[07:22] <camelia> rakudo-moar e6f360: OUTPUT«(Block)␤here we go␤42␤»

[07:22] <ab5tract_> .tell MadcapJake try this example:  `class Hap { has &.done }; my $f = Hap.new( done => { say "here we go"; 42 } ); my $b = $f.done(); $b.WHAT.say; $b().say`

[07:22] <yoleaux> ab5tract_: I'll pass your message to MadcapJake.

[07:25] <ab5tract_> .tell MadcapJake contrast that with replacing `my $b = $f.done()` with `my $b = &($f.done)()`. So the reason it is written this way is because the second option would be run time error if the tap did not define a done block

[07:25] <yoleaux> ab5tract_: I'll pass your message to MadcapJake.

[07:25] <ab5tract_> *be a

[07:26] *** rurban left
[07:29] *** n0tjack joined
[07:34] *** n0tjack left
[07:38] *** lizmat left
[07:51] *** vendethiel joined
[07:55] <nine> Good morning #perl6!

[07:57] <ab5tract_> morning, nine!

[07:57] <nine> I've just slept for 10 1/2 hours...this feels strange ;)

[08:00] <ab5tract_> :)

[08:05] <ab5tract_> nine: so does the GMR (Great Map Refactor?) plan to address the points raised by http://postcircumfix.com/2015-08-29-untangling-the-perl-6-hashpair-type-hierarchy

[08:06] <dalek> roast/gmr: 434b189 | (Stefan Seifert)++ | S (3 files):

[08:06] <dalek> roast/gmr: Rename EnumMap to Map

[08:06] <dalek> roast/gmr: review: https://github.com/perl6/roast/commit/434b18970a

[08:06] <dalek> roast/gmr: a2d3e62 | (Stefan Seifert)++ | S (7 files):

[08:06] <dalek> roast/gmr: Merge Enum into Pair

[08:06] <dalek> roast/gmr: 

[08:06] <dalek> roast/gmr: This should reduce the confusion around enum, Enum an Enumeration.

[08:06] <dalek> roast/gmr: Pair now implements shallow immutability like List. Pairs themselves are

[08:06] <dalek> roast/gmr: immutable, but containers used as values can be assigned to.

[08:06] <dalek> roast/gmr: review: https://github.com/perl6/roast/commit/a2d3e628ce

[08:07] <nine> ab5tract_: that blog post is exactly what I'm implementing

[08:07] <nine> though half of it seems obsolete, as for example Hashes don't do Positional

[08:08] <ab5tract_> indeed

[08:09] <nine> Note that it has not been decided, if we really want those changes. I'm just implementing them to see how much work it would be and what problems may arise. So far I like what I've seen.

[08:10] <ab5tract_> An exploratory branch :)

[08:11] <ab5tract_> A Map for a potential voyage! (*baddum ching*)

[08:11] * ab5tract_ wanders to breakfast

[08:13] *** SamuraiJack joined
[08:14] *** pmurias joined
[08:14] <pmurias> in which branch does the post glr rakudo live?

[08:15] *** lizmat joined
[08:17] <ShimmerFairy> pmurias: nom

[08:18] <lizmat> commuting&

[08:18] *** lizmat left
[08:19] *** rurban joined
[08:29] *** cognominal joined
[08:31] *** ab5tract_ left
[08:34] <ambs> we can't make perl6 a little more intelligent? "min 1..*" takes forever to compute.

[08:39] <RabidGravy> yes

[08:39] <RabidGravy> m: multi sub min(Range $a) { $a.bounds[0] }; say min(1..*)

[08:39] <camelia> rakudo-moar e6f360: OUTPUT«1␤»

[08:40] <ambs> not really... then   min 10..5 would not work :-)

[08:41] <ambs> it I understood it correctly

[08:41] <ambs> s/it/if/

[08:41] <RabidGravy> ah yes

[08:41] <ambs> but yeah, not something relevant right now

[08:41] <ambs> was just messing around with ranges and lazyness.

[08:42] <ShimmerFairy> Yeah, if rakudo knew how to determine if a range was all-ascending or all-descending, then there are some nice shortcuts that could be implemented :)

[08:42] <RabidGravy> m: multi sub min(Range $a) { min($a.bounds) }; say min(1..*); say min(10..5)'

[08:42] <camelia> rakudo-moar e6f360: OUTPUT«5===SORRY!5=== Error while compiling /tmp/qnrLbWOIpJ␤Two terms in a row␤at /tmp/qnrLbWOIpJ:1␤------> 3bounds) }; say min(1..*); say min(10..5)7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»

[08:43] *** ab5tract_ joined
[08:43] <RabidGravy> m: multi sub min(Range $a) { min($a.bounds) }; say min(1..*); say min(10..5);'

[08:43] <camelia> rakudo-moar e6f360: OUTPUT«5===SORRY!5=== Error while compiling /tmp/R2GRDS_HsY␤Unable to parse expression in single quotes; couldn't find final "'" ␤at /tmp/R2GRDS_HsY:1␤------> 3unds) }; say min(1..*); say min(10..5);'7⏏5<EOL>␤    expecting any of:␤        sing…»

[08:43] <ambs> RabidGravy: I see what you are trying to do there :-)

[08:43] <RabidGravy> m: multi sub min(Range $a) { min($a.bounds) }; say min(1..*); say min(10..5)

[08:43] <camelia> rakudo-moar e6f360: OUTPUT«Cannot call min(Parcel); none of these signatures match:␤    (Range $a)␤  in sub min at /tmp/xFCWE2y0tQ:1␤  in block <unit> at /tmp/xFCWE2y0tQ:1␤␤»

[08:43] <RabidGravy> or something like that

[08:46] *** [TuxCM] joined
[08:49] *** ab5tract_ left
[08:53] *** camelia left
[08:53] *** camelia joined
[08:53] *** laouji left
[08:53] <nine> m: say (1,2).WHAT

[08:54] *** ChanServ sets mode: +v camelia

[08:54] <camelia> rakudo-moar e6f360: OUTPUT«(Parcel)␤»

[08:55] <vendethiel> camelia is pre-merge, IIRC

[08:55] <nine> Yeah, trying to figure out how to fix that

[08:56] *** laouji joined
[08:58] *** laouji left
[09:00] *** [TuxCM] left
[09:01] <jdv79> grondilu: i would help if i understood Digest better.  there's a bunch of syntax i'm not familiar with in there.

[09:01] *** laouji joined
[09:02] <RabidGravy> right, off to the "White Isle" in a bit, see you all in two weeks.  Don't break anything I wouldn't and play nicely

[09:02] *** TEttinger left
[09:02] <nine> Have fun :)

[09:03] *** laouji left
[09:03] <RabidGravy> always do :)

[09:03] <RabidGravy> byeee

[09:03] *** RabidGravy left
[09:03] *** laouji joined
[09:06] *** ndo joined
[09:09] *** Ven joined
[09:09] <pmurias> the post glr semantics are described in S07-glr-draft.pod?

[09:10] <nine> More or less. That document is not up to date.

[09:10] <pmurias> S07-lists.pod is pre-glr?

[09:11] *** telex left
[09:11] <nine> I don't think anyone has updated the specs yet.

[09:12] <pmurias> that sucks badly :(

[09:12] *** telex joined
[09:14] <nine> m: say (1,2).WHAT

[09:14] <camelia> rakudo-moar 13f829: OUTPUT«(List)␤»

[09:14] <nine> \o/

[09:14] <vendethiel> \o/

[09:14] <nine> I disabled build of the jvm backend for now.

[09:23] *** laouji left
[09:27] *** laouji joined
[09:36] *** mprelude joined
[09:44] *** Ven left
[09:44] <nine> m: (:a(1) :b(2)).perl.say

[09:44] <camelia> rakudo-moar 13f829: OUTPUT«(:a(1), :b(2))␤»

[09:46] *** rmgk_ joined
[09:46] *** rmgk left
[09:46] *** rmgk_ is now known as rmgk

[09:51] *** perl6_newbee left
[09:56] *** n0tjack joined
[09:58] <ShimmerFairy> nine: I was thinking, could you and/or other people familiar with GLR put up a gist or something with bullet points on what's changed with having GLR (or at least the important bits of GLR), so it's easier for someone interested in updating the specs to do so?

[10:01] *** n0tjack left
[10:02] <ShimmerFairy> (I ask because I'm possibly interested in helping update S07 and related, but I'm not nearly familiar enough with GLR to write specs on it yet. A gist-like thing would just speed up that familiarization for someone like me ☺)

[10:03] *** cschwenz joined
[10:05] *** leont joined
[10:05] <leont> How can I interpret a string as hex?

[10:05] <vendethiel> m: say :16("CAFE"); # what was it?

[10:05] <camelia> rakudo-moar 13f829: OUTPUT«51966␤»

[10:06] <ShimmerFairy> Yeah, also available as :16<CAFE> or :16[12, 10, 15, 14]  :)   (though :16() will let you handle variables)

[10:08] <vendethiel> m: my @a = 12, 10, 15, 14; say :16[|@a];

[10:08] <camelia> rakudo-moar 13f829: OUTPUT«51966␤»

[10:08] <vendethiel> *g*

[10:21] *** AlexDaniel joined
[10:21] <hahainternet> i'm not exactly likely to be helping out with GLR but i would appreciate the same as ShimmerFairy, a nice summary somewhere when someone has time

[10:30] *** SamuraiJack left
[10:34] <leont> Interestingly, :16("0o10") == 8

[10:35] <leont> Is that intended or a bug?

[10:37] *** colomon left
[10:37] <ShimmerFairy> intended, :16() only sets a default radix, which can be overridden by the string

[10:40] *** dayangkun left
[10:42] *** cschwenz1 joined
[10:44] *** cschwenz2 joined
[10:45] *** cschwenz left
[10:46] *** cschwenz1 left
[10:54] <cdc> ShimmerFairy: don't you think :16("0o10") should be rejected?  For instance, in the follozing scenario: $input = prompt("Enter hex"); $checked-input = :16($intput)"

[10:55] *** spider-mario joined
[10:55] <ShimmerFairy> cdc: nope, the idea is that the string knows what it wants better than the surrounding conversion function.

[10:55] <ShimmerFairy> It's been that way forever, so it's not my design decision in the first place :) . Nevertheless I agree with it.

[10:56] *** kaare_ left
[10:56] <ShimmerFairy> If you _really_ wanted to enforce hex, easiest way would be  :16("0x" ~ $input)  , which will die if the string ends up being "0x0o10"

[10:57] <hahainternet> you'd want to do some sanitation on the input regardless

[10:57] <hahainternet> because 'z'

[10:57] <hahainternet> i'm half and half

[10:57] <hahainternet> it would be nice to know there were ways to be strict about formatting built in

[11:04] *** colomon joined
[11:05] <cdc> well, I understand your point, but :16("0o10") == 8 looks so weird to me.

[11:07] *** cschwenz2 left
[11:08] <hahainternet> cdc: it does, but if you gave that octal a variable name it would make much more sense

[11:15] *** colomon left
[11:17] *** colomon joined
[11:18] <MadcapJake> m: class Hap { has &.done }; my $f = Hap.new( done => { say "here we go"; 42 } ); my $b = $f.done(); my $c = $f.done; my $d = &($f.done); say $b === $c && $c === $d;

[11:18] <yoleaux> 07:21Z <ab5tract_> MadcapJake: that's because the return value of $tap.done() is the callback itself

[11:18] <yoleaux> 07:22Z <ab5tract_> MadcapJake: try this example:  `class Hap { has &.done }; my $f = Hap.new( done => { say "here we go"; 42 } ); my $b = $f.done(); $b.WHAT.say; $b().say`

[11:18] <camelia> rakudo-moar 13f829: OUTPUT«True␤»

[11:18] <yoleaux> 07:25Z <ab5tract_> MadcapJake: contrast that with replacing `my $b = $f.done()` with `my $b = &($f.done)()`. So the reason it is written this way is because the second option would be run time error if the tap did not define a done block

[11:19] *** colomon left
[11:21] *** colomon joined
[11:26] *** ndo left
[11:33] <MadcapJake> ab5tract: so in the case of assigning a method to a variable, there's no difference between `$f.done()` and `$f.done`? Both will just assign the variable to the given block.  Is that correct?

[11:37] <ShimmerFairy> both .done() and .done call a method

[11:37] <MadcapJake> but if you do `my $b = $f.done` you don't call it, you just assign the block to $b

[11:37] <ShimmerFairy> m: class C { method M { 42 } }; my $b = C.M; say $b.perl

[11:37] <camelia> rakudo-moar 13f829: OUTPUT«42␤»

[11:38] <MadcapJake> m: class C { method M { 42 } }; my $b = C.M; say $b.WHAT.say

[11:38] <camelia> rakudo-moar 13f829: OUTPUT«(Int)␤True␤»

[11:38] <ShimmerFairy> m: class C { method M { -> $a { say $a } } }; my $b = C.M; say $b.perl

[11:38] <camelia> rakudo-moar 13f829: OUTPUT«-> $a { #`(Block|71367056) ... }␤»

[11:39] *** laouji left
[11:39] *** laouji joined
[11:39] <ShimmerFairy> m: class C { has $.done }; my $obj = C.new(done => 42); say $obj.done.perl

[11:39] <camelia> rakudo-moar 13f829: OUTPUT«42␤»

[11:39] <MadcapJake> wait, what about when it's like this

[11:39] <ShimmerFairy> m: class C { has $.done }; my $obj = C.new(done => { 42 }); say $obj.done.perl

[11:39] <camelia> rakudo-moar 13f829: OUTPUT«-> ;; $_? is parcel { #`(Block|55982096) ... }␤»

[11:39] <MadcapJake> yeah like that :P

[11:39] <timotimo> that's how

[11:40] <ShimmerFairy> when the "done" attribute is assigned a block, then calling the method returns that block :)

[11:40] <ShimmerFairy> (the  has $.done  declaration creates 'method done' for you)

[11:40] <MadcapJake> so it's not really a method, it's just a block? is that what i'm getting confused about?

[11:40] <MadcapJake> ohhhhh

[11:40] <timotimo> it's a method tthat returns a block

[11:40] <timotimo> you'd call it an attribute instead of a method, probably

[11:41] <MadcapJake> so when you instantiate the class, you're passing what the `done` method will return?

[11:41] <timotimo> right, though of course the code in the class may re-assign to $!done or implement "method done" itself in a different way if it likes to

[11:42] <ShimmerFairy> yeah, the  'done => { 42 }'  part sets the value of the $!done attribute. The main difference between 'has $!done' and 'has $.done' is that you'll get a  method done { $!done }  made for you

[11:43] *** laouji left
[11:43] *** laouji joined
[11:43] <MadcapJake> ok! I get it now! :)  I was thinking that `has $.done` was just creating an empty "field". But really the `.` twigil means it's actually building an accessor/gette

[11:44] <timotimo> that's right

[11:44] <MadcapJake> awesome! Thanks so much for the explanation!

[11:44] <timotimo> and if the . twigil gets combined with "is rw", the accessor will also allow assignment

[11:45] <ShimmerFairy> MadcapJake: note that when you _use_ the attribute in your class' methods, $!foo is the actual variable, and $.foo is treated like $(self.foo)

[11:45] <MadcapJake> ok cool, i read about `is rw` but it wasn't really making sense until now xD

[11:48] *** laouji left
[11:48] *** laouji joined
[11:48] <MadcapJake> ShimmerFairy: but `$!foo` would only be available inside the class body, right?

[11:48] <ShimmerFairy> yes

[11:49] <ShimmerFairy> Use $!foo whenever you want to modify or otherwise use the attribute directly. $.foo is nice for letting subclasses define their own 'method foo' and getting that used

[11:52] <timotimo> and $!foo is namespaced to the current class, so if you want to access a superclass' attribute "$!foo", you'll have to go a different way

[11:53] <ShimmerFairy> m: class C { has $.bar; method foo { "This is a $.bar" } }; class D is C { method bar { "derived class" } }; say C.new(bar => 42).foo;  say D.foo

[11:53] <camelia> rakudo-moar 13f829: OUTPUT«This is a 42␤This is a derived class␤»

[11:53] <ShimmerFairy> ^ example of what I was talking about with using $.foo

[12:07] <MadcapJake> cool! Thanks ShimmerFairy & timotimo! It all fits now that I understand that darn twigil xD

[12:14] *** kaare_ joined
[12:16] *** CQ joined
[12:18] *** leont left
[12:20] *** lizmat joined
[12:20] *** laouji left
[12:20] * lizmat waves from 2500m up on the Sierra Nevada

[12:23] *** mprelude left
[12:23] *** n0tjack joined
[12:28] *** n0tjack left
[12:29] <FROGGS> .tell japhb I'm unable to merge C++ support in rakudo until it got ported to jvm... and I cannot port it as long as the jvm build is broken

[12:29] <yoleaux> FROGGS: I'll pass your message to japhb.

[12:30] <FROGGS> TimToady / jnthn: I intend to bisect the setting this evening (by commenting stuff out), until the jvm build succeeds... if one of you have better ideas, please let me know

[12:40] *** Loren joined
[12:41] <lizmat> .tell TimToady looks like brokenness of Vampire-number/vampire-number.pl6 is also a @a := Seq issue

[12:41] <yoleaux> lizmat: I'll pass your message to TimToady.

[12:45] *** lizmat left
[12:45] <[Tux]> o/

[12:49] *** rindolf joined
[12:49] <_itz> m: say (1,2).WHAT

[12:49] <camelia> rakudo-moar 13f829: OUTPUT«(List)␤»

[12:49] <_itz> is jvm fixed?

[12:50] <TimToady> nach nicht

[12:50] <yoleaux> 12:41Z <lizmat> TimToady: looks like brokenness of Vampire-number/vampire-number.pl6 is also a @a := Seq issue

[12:51] <moritz> but that's a current rakudo

[12:51] <moritz> on camelia

[12:53] *** xfix left
[12:54] * timotimo is still a bit sad about the re-naming of the Cheese Shop to PyPI

[12:54] <ShimmerFairy> moritz: JVM build has been disabled on camelia for the time being

[12:56] <moritz> :sadface:

[12:58] *** FROGGS left
[13:26] *** cognominal left
[13:30] *** colomon left
[13:31] *** rurban left
[13:32] *** aborazmeh joined
[13:32] *** aborazmeh left
[13:32] *** aborazmeh joined
[13:37] *** AlexDaniel left
[13:39] *** vendethiel left
[13:40] *** AlexDaniel joined
[13:41] *** laouji joined
[13:48] *** skids joined
[13:55] *** khw joined
[13:56] *** vendethiel joined
[13:57] *** FROGGS[mobile] left
[13:57] *** FROGGS[mobile] joined
[14:03] *** lichtkind joined
[14:03] <lichtkind> cheers i saw parcel is gone

[14:04] <lichtkind> where can i read mor on that?

[14:05] *** aborazmeh left
[14:05] <nine> FROGGS[mobile]: do you have any idea, why after adding a multi method new($key, Mu \value) to Pair.pm I still get a "Default constructor for 'Pair' only takes named arguments" but only for this weird :a(1) b(2) case (without comma)

[14:06] <nine> FROGGS[mobile]: I also removed $key.named('key'); and $value.named('value'); from make_pair in Actions.nqp

[14:12] *** Sqirrel_ left
[14:13] <nine> lichtkind: it's not yet documented

[14:14] <lichtkind> nad whats main idea, that list can contain named vals ?

[14:14] <nine> ?

[14:17] <lichtkind> the amin idea between parcels was that they are not decided if they become list or hashes

[14:18] <lichtkind> what makes them dispensable

[14:21] <masak> m: sub s($x) { $x ?? $x < 0 ?? -1 !! 1 !! 0 }; say s($_) for -42, 0, 42, NaN

[14:21] <camelia> rakudo-moar 13f829: OUTPUT«-1␤0␤1␤1␤»

[14:22] <masak> m: sub s($x) { $x / abs $x }; say s($_) for -42, 0, 42, NaN

[14:22] <camelia> rakudo-moar 13f829: OUTPUT«-1␤Attempt to divide by zero using div␤  in block <unit> at /tmp/h1bOsgu6S9:1␤␤Actually thrown at:␤  in block <unit> at /tmp/h1bOsgu6S9:1␤␤»

[14:22] <masak> (some wrong implementations of the 'sign' function I've found on Github so far)

[14:23] <masak> m: sub s($x is copy) { !($x = +$x) ? $x : $x > 0 ? 1 : -1 }; say s($_) for -42, 0, 42, NaN

[14:23] <camelia> rakudo-moar 13f829: OUTPUT«5===SORRY!5=== Error while compiling /tmp/as7bLcyhYe␤Unsupported use of ? and : for the ternary conditional operator; in Perl 6 please use ?? and !!␤at /tmp/as7bLcyhYe:1␤------> 3sub s($x is copy) { !($x = +$x) ?7⏏5 $x : $x > 0 ? 1 : -1 }; s…»

[14:24] <masak> m: sub s($x is copy) { !($x = +$x) ?? $x !! $x > 0 ?? 1 !! -1 }; say s($_) for -42, 0, 42, NaN

[14:24] <camelia> rakudo-moar 13f829: OUTPUT«-1␤0␤1␤-1␤»

[14:24] *** cognominal joined
[14:24] <nine> lichtkind: you mean Captures

[14:25] <lichtkind> im pretty sure i mean parcel but i will recheck

[14:25] <masak> m: sub s($x) { if $x > 0 { return 1 }; return -1 }; say s($_) for -42, 0, 42, NaN

[14:25] <camelia> rakudo-moar 13f829: OUTPUT«-1␤-1␤1␤-1␤»

[14:26] <masak> I'm thinking of writing a blog post follow-up about how virtually everybody who tries to implement/polyfill Math.sign is also too inexperienced to get it right.

[14:27] <masak> but now that I'm looking around, I'm not sure I'll be able to research it enough without becoming too depressed about what I find.

[14:27] <masak> m: sub s($x) { $x < 0 ?? -1 !! 1 }; return -1 }; say s($_) for -42, 0, 42, NaN

[14:27] <camelia> rakudo-moar 13f829: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QwvRM1MH6W␤Unexpected closing bracket␤at /tmp/QwvRM1MH6W:1␤------> 3 s($x) { $x < 0 ?? -1 !! 1 }; return -1 7⏏5}; say s($_) for -42, 0, 42, NaN␤»

[14:27] <masak> m: sub s($x) { $x < 0 ?? -1 !! 1 }; say s($_) for -42, 0, 42, NaN

[14:27] <camelia> rakudo-moar 13f829: OUTPUT«-1␤1␤1␤1␤»

[14:28] <lichtkind> nine: your right but i thought it was the other way around for long time

[14:28] <masak> there's definitely a blog post's worth in there, though.

[14:29] <mst> lichtkind: I always suspected you were a little bit backwards

[14:29] <mst> (sorry :)

[14:29] <lichtkind> sometimes i am

[14:29] <_itz> lichtkind++ # good .es art gallery tips :)

[14:30] <lichtkind> thanks

[14:30] <lichtkind> yes leaving granada tomorrow

[14:30] <ShimmerFairy> m: sub sign($n) { $n ?? $n / $n.abs !! 0 }; say (-42, 0, 42, NaN)».&sign  # masak: this is my version :)

[14:30] <camelia> rakudo-moar 13f829: OUTPUT«(-1 0 1 NaN)␤»

[14:31] *** Begi joined
[14:33] <Begi> Hey #perl6 ! I'm new to Perl6. I've code a little Reverse Polish notation calculator. Can you tell me what can I improve ? https://gist.github.com/Emeric54/b94d607aca841df8f2d8

[14:34] <Juerd> Begi: That's nice!

[14:35] <Juerd> In general, in any programming language, I think things become harder to read if you have many nested constructs and high indentation levels. It's a good reason to refactor things into subroutines.

[14:36] <Juerd> That'll force you to think about how to share values. Explicit passing and returning is widely considered as the best solution, followed by hiding state in objects.

[14:36] <Juerd> But for code this small it might be overkill :)

[14:37] <Juerd> I'm not sure if "defined +$w" makes sense

[14:37] <vendethiel> Juerd: that's to make sure .Int returned an Int :)

[14:37] <vendethiel> (at least that's what I'm guessing)

[14:37] <Juerd> vendethiel: I don't understand. There's no .Int in the code.

[14:38] <vendethiel> Juerd: there's a +

[14:38] <vendethiel> m: say +"foo"

[14:38] <camelia> rakudo-moar 13f829: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏foo' (indicated by ⏏)␤  in block <unit> at /tmp/7VAhJ9Nxx4:1␤␤Actually thrown at:␤  in block <unit> at /tmp/7VAhJ9Nxx4:1␤␤»

[14:38] <vendethiel> m: say defined +"foo"

[14:38] <camelia> rakudo-moar 13f829: OUTPUT«False␤»

[14:38] <vendethiel> the defined "traps" the failure :)

[14:38] <Begi> Yes, I started with a subroutine, but I deleted it because the code was very small.

[14:40] <Juerd> Oh wow, so +"foo" evaluates to an unthrown exception?

[14:40] <Juerd> Which is then thrown if you use it where you can't?!

[14:40] <vendethiel> Juerd: +"foo" evaluates to a Failure

[14:40] <Juerd> I think I read about this, but this is the first time I understand it...

[14:41] <Juerd> (I think)

[14:41] <vendethiel> m: say (+"foo").WHAT.perl

[14:41] <camelia> rakudo-moar 13f829: OUTPUT«Failure␤»

[14:41] <vendethiel> m: say (+"foo").Bool

[14:41] <camelia> rakudo-moar 13f829: OUTPUT«False␤»

[14:41] <Juerd> m: sub bar ($f :D) { }; bar(+"foo")

[14:41] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[14:42] <Juerd> Slightly LTA.

[14:42] <Juerd> Which object?!

[14:42] <vendethiel> whoops. :-)

[14:42] <vendethiel> m: sub bar($f :D) {}; bar(1);

[14:42] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[14:42] <vendethiel> m: sub bar($f:D) {}; bar(1);

[14:42] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[14:43] <vendethiel> Juerd: you can't :D something that's not a type btw

[14:43] <vendethiel> m: sub bar($f:D) {};

[14:43] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[14:43] <vendethiel> Juerd: Any:D would work, fwiw

[14:44] <masak> I just realized that NaN boolifies to True in Perl 6. have we ever thought about whether it should...?

[14:44] <masak> (data point so far: it boolifies to false in JavaScript)

[14:45] * vendethiel has no idea, since he never writes code that takes NaN into account

[14:46] *** raiph left
[14:46] <nine> GLRR semantics in a gist: https://gist.github.com/niner/d5f825c07ce1f7a6f7bb

[14:47] <masak> in a way, NaN (being a kind of numeric failure) feels falsy.

[14:47] *** Begi left
[14:47] <nine> At least what came to mind right now

[14:47] *** skids left
[14:48] *** laouji left
[14:48] <ShimmerFairy> masak: I think the issue is that "not a number" is far too general for an easy answer

[14:49] <nine> ShimmerFairy: https://gist.github.com/niner/d5f825c07ce1f7a6f7bb

[14:49] <ShimmerFairy> thanks :)

[14:49] <nine> I'll be happy to add clarifications and answer questions that this will raise.

[14:50] <ShimmerFairy> Ah, so the $ protection was added then? Seems like the sanest option, considering how many problems not having something like it was causing :)

[14:52] <nine> Added jnthn++'s clarifications about slurpies

[14:52] <masak> ShimmerFairy: well, many languages do answer it by allowing NaN to be coerced, implicitly or explicitly, to a boolean value.

[14:52] <masak> ShimmerFairy: I agree it's not an easy question. but there's certainly prior art.

[14:52] <ShimmerFairy> masak: what I mean is the question of "is NaN truthy or falsy?"

[14:52] <masak> and I'm wondering if there's any language out there besides Perl 6 that boolifies NaN to True.

[14:53] <ShimmerFairy> nine: shouldn't 'is rw' be the one that leads to Array, if Lists are immutable?

[14:53] *** raiph joined
[14:53] <masak> hm, Perl 5 does too, it seems.

[14:53] <masak> $ perl -Mstrict -wE 'say !! +"NaN"'

[14:53] <masak> 1

[14:54] <Loren> m: say (+"fgg").perl

[14:54] <camelia> rakudo-moar 13f829: OUTPUT«Failure.new(exception => X::Str::Numeric.new(source => "fgg", pos => 0, reason => "base-10 number must begin with valid digits or '.'"), backtrace => Backtrace.new)␤»

[14:54] <ShimmerFairy> masak: from a purely bit-pattern perspective, NaN does have some on bits :P

[14:55] *** dakkar joined
[14:56] <dakkar> why does IO::Path cache the "exists" bit?

[14:57] <dakkar> my $f = '/tmp/thing'.IO; $f.spurt('something'); say $f.e; # prints False

[14:57] <nine> ShimmerFairy: well the "is rw" allows you to assign to @foo. It doesn't say anything about @foo itself. But other than having slowly come to terms with this, I share your confusion.

[14:57] *** bbkr joined
[14:59] <ShimmerFairy> nine: Another possibility is perhaps "use Array for *@, since we've flattened already and might as well enforce scalar containers, and use List for **@ , since we're keeping structure and shouldn't enforce containerization on any part of it"

[14:59] <nine> Well there's still lizmat++'s proposal to have **@arr expose the single arg semantics we use for all builtins.

[15:00] <bbkr> Hi. I've published new blog post of how to deal with asynchronous parallel nested documents processing (and don't get crazy). Enjoy: http://blogs.perl.org/users/pawel_bbkr_pabian/2015/09/asynchronous-parallel-and-dead-my-perl-6-daily-bread.html !

[15:00] <ShimmerFairy> nine: how would you enforce single-arg rule like the "for" keyword, currently?

[15:02] <nine> ShimmerFairy: oh it's easy. It just involves some nqp...

[15:03] <ShimmerFairy> nine: is that because of GLRR? I recall that being default earlier

[15:03] <ShimmerFairy> (that is, I remember that you couldn't get rid of single-arg earlier on)

[15:06] *** lichtkind left
[15:07] <nine> The canonical way seems to be having a multi candidate that takes a \value and one for **@values. Then first one does an istype(Iterable) && !iscont check on value

[15:10] <ShimmerFairy> It'd be nice if that were easier to do :)    .oO(***@i-want-single-arg  :P)

[15:14] *** bbkr left
[15:15] *** n0tjack joined
[15:17] <grondilu> m: constant foo = grep * % 2, 1 .. *; say foo[1]; say foo[1];

[15:17] <camelia> rakudo-moar 13f829: OUTPUT«3␤3␤»

[15:18] <grondilu> m: constant primes = grep *.is-prime, 2 .. *; say (map 2 * *, primes)[^3]; say (map 3 * *, primes)[^3];

[15:18] <camelia> rakudo-moar 13f829: OUTPUT«(4 6 10)␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/mNp30ZydZT:1␤␤»

[15:18] <grondilu> m: constant @primes = grep *.is-prime, 2 .. *; say (map 2 * *, @primes)[^3]; say (map 3 * *, @primes)[^3];

[15:18] <camelia> rakudo-moar 13f829: OUTPUT«(4 6 10)␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/kUDir4ylC_:1␤␤»

[15:18] <grondilu> m: my @primes = grep *.is-prime, 2 .. *; say (map 2 * *, @primes)[^3]; say (map 3 * *, @primes)[^3];

[15:18] <camelia> rakudo-moar 13f829: OUTPUT«(4 6 10)␤(6 9 15)␤»

[15:19] *** perl6_newbee joined
[15:19] *** n0tjack left
[15:21] *** dakkar left
[15:24] <FROGGS[mobile]> nine: perhaps look of the ast what :a(1) :b(2) produces, to be able to reproduce it with other Perl 6 code

[15:25] <FROGGS[mobile]> nine: if nothing helps I can look into it in about three hours

[15:26] <cdc> bbkr: I think you wouldn't exhaust the thread pool if you move the start block after the recursive call, ie. "start { sleep 1 # here the chapter itself is processed }"

[15:27] <FROGGS[mobile]> nine: though I plan to spend the night fighting the JVM breakage

[15:28] <cdc> .tell bbkr: http://irclog.perlgeek.de/perl6/2015-09-06#i_11176345

[15:28] <yoleaux> cdc: What kind of a name is "bbkr:"?!

[15:28] <cdc> .tell bbkr http://irclog.perlgeek.de/perl6/2015-09-06#i_11176345

[15:28] <yoleaux> cdc: I'll pass your message to bbkr.

[15:35] *** bbkr joined
[15:40] *** lolisa joined
[15:44] <bbkr> cdc: yes, but this is suboptimal solution. It was my first attempt to fix: https://gist.github.com/bbkr/b27aca2d1a2654de7640/24deaaedb3b681a3b0c5201712f9604ae6adc894#file-readme-txt-L127

[15:44] <yoleaux> 15:28Z <cdc> bbkr: http://irclog.perlgeek.de/perl6/2015-09-06#i_11176345

[15:44] <[Tux]> GLR:

[15:44] <[Tux]> test             50000    54.743    54.658

[15:44] <[Tux]> test-t           50000    54.748    54.664

[15:44] <timotimo> that's more than it used to be, huh? :(

[15:45] <bbkr> I've even explained why it won't give full speedup, but whole post became too big so I got this solution removed.

[15:45] <[Tux]> yes, but I have been able to test GLR just *once* before

[15:45] * [Tux] is building nom just now to compare

[15:45] <timotimo> OK

[15:47] <masak> ShimmerFairy: the correct answer, if such a thing existed, would of course be "Not a Boolean" :P

[15:48] <timotimo> NaB, eh?

[15:49] *** spider-mario left
[15:50] <timotimo> hm

[15:50] <[Tux]> have glr and nom been merged? I now get the same errors in nom as I get in glr

[15:50] <timotimo> the problem i may be seeing is an eliminated-by-optimizer block has survived and that causes some trouble

[15:50] <timotimo> or something

[15:50] <timotimo> glr is now in nom, yes

[15:52] <cdc> bbkr: oh, I see.

[15:55] <masak> found a regression.

[15:55] <masak> m: sub foo { sub bar($) { "OH HAI" }; bar 5 }; say foo

[15:55] <camelia> rakudo-moar 13f829: OUTPUT«OH HAI␤»

[15:55] <masak> m: sub foo { bar 5; sub bar($) { "OH HAI" } }; say foo

[15:55] <camelia> rakudo-moar 13f829: OUTPUT«sub bar ($) { #`(Sub|71849184) ... }␤»

[15:55] * masak submits rakudobug

[15:57] <masak> I think this is unusual enough that it hasn't been discovered yet in the spectests or ecosystem.

[15:57] <masak> but we should probably have a spectest for it :)

[15:59] <masak> anyway, behold! https://gist.github.com/masak/b9371625ad85cfe0faba -- fizzbuzz without conditionals in Perl 6 :)

[15:59] <masak> (forked from a Clojure version)

[16:04] <garu> masak++

[16:05] <timotimo> masak: so ... what is the bug?

[16:06] <vendethiel> masak: you can also cheat and use && - || instead of ?? - !! :P

[16:06] <timotimo> pah

[16:07] <timotimo> but then you have a conditional on the LHS of &&

[16:07] <vendethiel> m: say True && 1 || 0;

[16:07] <camelia> rakudo-moar 13f829: OUTPUT«1␤»

[16:07] <vendethiel> timotimo: ?

[16:08] <masak> timotimo: the bug is that the sub is not called if it's post-declared.

[16:08] <masak> m: sub foo { bar 5; sub bar($) { "OH HAI" } }; say foo

[16:08] <camelia> rakudo-moar 13f829: OUTPUT«sub bar ($) { #`(Sub|64738528) ... }␤»

[16:08] <masak> ^ that's wrong.

[16:08] <vendethiel> masak: it is called, you're just not "say"ing in it

[16:08] <masak> no, look again.

[16:08] <vendethiel> m: sub foo { bar 5; sub bar($) { say "OH HAI" } }; say foo

[16:08] <camelia> rakudo-moar 13f829: OUTPUT«OH HAI␤sub bar ($) { #`(Sub|50845312) ... }␤»

[16:09] <masak> oh, argh.

[16:09] <vendethiel> masak: the say is after the return. what's returned is the last expr - the sub

[16:09] <masak> yes, I'm wrong. ignore me. :)

[16:09] * masak goes to reject the ticket

[16:09] <timotimo> :)

[16:10] <masak> m: sub foo { return bar 5; sub bar($) { "OH HAI" } }; say foo

[16:10] <camelia> rakudo-moar 13f829: OUTPUT«OH HAI␤»

[16:10] <masak> that's what I meant.

[16:10] <timotimo> good that it works :)

[16:13] <timotimo> i'm pretty sure we rely on calling postdeclared subs in core, actually

[16:13] <mst> masak: cute

[16:14] <masak> mst: yes, one of those "ooh, I wish I had thought of that" ideas

[16:15] <masak> of course, both multis and infix:<5> could be said to be conditional-ish in nature

[16:15] <masak> infix:<%> *

[16:15] <masak> typing with 8mo in lap :)

[16:16] <timotimo> i think there's some oversharing of QAST::Var objects going on somewhere in rakudo and that's what messes up the optimizer :|

[16:16] <mst> masak: felt very erlang-ish

[16:21] <TimToady> I'm okay with NaN being !.so, and I think I'm even fine with it being !.defined, as long as it stays .DEFINITE

[16:22] *** rangerprice joined
[16:24] * timotimo builds an evil hack (maybe?) into QAST::Var.new that records the line number and file name where it was called and outputs that into the qast dump

[16:24] *** Loren left
[16:25] <masak> TimToady: me too... I think. would be interested to know if anything (spectests, ecosystem) currently relies on NaN being truthy.

[16:25] <TimToady> in particular, I suspect NaN should be considered failure for KEEP/UNDO

[16:26] <masak> mst: I've learned to reach more and more often for that kind of locally-defined multis as a replacement for given/when inside a routine.

[16:26] <masak> mst: it also works great for visitor/traversal algorithms.

[16:26] <rangerprice> HI everyone !!

[16:27] <masak> TimToady: yes, makes sense.

[16:27] <masak> rangerprice: hi!

[16:27] * TimToady isn't everyone...

[16:27] <mst> masak: hrm, why do you prefer it to given/when ?

[16:27] <mst> I assumed you were just avoiding given/when to demonstrate the conditional-free-ness

[16:27] <TimToady> extensible

[16:27] <timotimo> hm. but how ...

[16:28] <rangerprice> It is possible to "convert" perl package to C library ?

[16:30] <timotimo> probably not the way you expect it to

[16:31] <rangerprice> Or just possible to create a wrapper for perl library ?

[16:31] <rangerprice> perl package *

[16:31] <timotimo> so you want to be able to call/trigger functions in a perl library from C code?

[16:32] <TimToady> it is certainly possible, but likely not a priority before Christmas

[16:32] <timotimo> it'll take quite a bit of roundabout work, i expect

[16:33] <TimToady> moarvm needs a better embedding interface first

[16:33] <rangerprice> yes Timo

[16:33] <FROGGS[mobile]> well, you can load CU's already AFAIK

[16:35] <rangerprice> Many people think that perl is dead, and this people go across Python instead....

[16:35] <rangerprice> The French community of Perl don't exist

[16:35] <timotimo> in order to run things, you first need an interpreter. if you want to run subs triggered "from outside", you'll likely need a bit of setup work to do that call properly

[16:36] <timotimo> and then getting things back to C

[16:39] <timotimo> for now, it may be easier to do things with RPC

[16:39] <timotimo> or IPC, as it were

[16:42] <ugexe> people thing every language is dead

[16:42] <ugexe> think

[16:45] <TimToady> .oO(every language thinks people are dead)

[16:46] <timotimo> if there are no speakers, then who made me?

[16:46] *** Peter_R joined
[16:46] <TimToady> Speaker for the Dead?

[16:46] <timotimo> i have that book on a shelf at home and i meant to read it, but i didn't get around to it yet

[16:47] <ugexe> 911, perl6 thinks im dead

[16:50] <rangerprice> ahahhahahaaaa

[16:51] *** CQ left
[16:51] *** lichtkind joined
[16:55] *** vendethiel left
[16:56] *** vendethiel joined
[16:57] <ugexe> when precompile is integrated into CompUnit's install process, how will someone test their module against the precompiled code without installing it?

[16:57] *** MadcapJake left
[17:00] <ugexe> such as code that precompiles without error (either correctly or incorrectly) but doesn't work properly when using the precompiled version

[17:02] <ugexe> or would it be such that everything that is loaded would get precompiled, such that `prove -e "perl6 -Ilib" t/` *would* be testing the precompiled version

[17:02] *** lolisa left
[17:04] *** perl6_newbee left
[17:06] *** BenGoldberg joined
[17:16] *** FROGGS joined
[17:18] *** lichtkind left
[17:26] *** rangerprice left
[17:32] <cognominal> I did not know I belonged to a dead community. Mongueurs are moribund, maybe.

[17:33] <timotimo> mortgueurs

[17:34] <cognominal> on a de la morgue, mais on n'y va pas.

[17:35] <cognominal> double entendre on morgue :)

[17:38] *** rangerprice joined
[17:42] *** khw left
[17:43] *** rurban joined
[17:46] *** rangerprice left
[17:51] *** xfix joined
[17:54] <vendethiel> cognominal: there's more than one community... or something..

[17:56] *** espadrine joined
[17:58] *** Sqirrel joined
[18:02] *** lichtkind joined
[18:02] <_itz> the GLRR gist is mostly a statement of future work rather how things are now?

[18:02] <cognominal> I msg-ed him that #perlfr on freenode is dead and gave him correct pointers.

[18:06] <jdv79> _itz: what?  the thing nine gisted is the difference between nom before and now.  before meaning a few days ago i think

[18:07] <jdv79> also, is GLRR a thing?  or are you talking about the GLR.

[18:07] <vendethiel> cognominal: it's sad it is, btw :(. I'm too lazy to setup irc again on this comp...

[18:08] <masak> cognominal: double entendre being fr:"morgue" == en:"mortuary" | en:"haugtiness" ?

[18:08] <cognominal> masak: yup

[18:08] <masak> \o/

[18:08] <masak> frog dissection: successful.

[18:08] * vendethiel nods and whispers "baguette"

[18:08] *** spider-mario joined
[18:09] <masak> vendethiel: I have a natural dislike of baguetter methods.

[18:09] <vendethiel> don't you dare insult the baguette :-).

[18:09] <_itz> I'm confused by " just assign the Seq to an @array variable." .. when I try to do that with File::Find its still a seq

[18:09] <vendethiel> _itz: using := or =? you should use =

[18:09] * masak .oO( do not taunt the baguette )

[18:09] <_itz> using :

[18:09] <_itz> errr

[18:10] <_itz> '=' I mean not ':='

[18:11] <vendethiel> m: my @lines = lines; say @lines.WHAT

[18:11] <camelia> rakudo-moar 13f829: OUTPUT«(Array)␤»

[18:11] <vendethiel> m: say lines.WHAT

[18:11] <camelia> rakudo-moar 13f829: OUTPUT«(Seq)␤»

[18:11] <vendethiel> _itz: seems to work here

[18:12] <_itz> > use File::Find; my @files = find( :dir("."), :type('file')); warn @files.WHAT

[18:12] <_itz> Use of uninitialized value <element> of type Array in string context  in block <unit> at <unknown file>:1

[18:14] <_itz> maybe its just File::Find (although the tests pass)

[18:16] <vendethiel> I'd think so

[18:16] <FROGGS> o/

[18:16] <vendethiel> \o

[18:17] <timotimo> o

[18:20] <_itz> m: use File::Find

[18:20] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Could not find File::Find in any of:␤  file#/home/camelia/.perl6/2015.07.1-745-g13f829c/lib␤  inst#/home/camelia/.perl6/2015.07.1-745-g13f829c␤  file#/home/camelia/rakudo-inst-2/share/perl6/lib␤  file#/home/camelia/rakudo-inst-2/shar…»

[18:20] <masak> mst: sometimes given/when (or just whens) would work just as well. but multis are nicer for the recursive case I mentioned. they can also define operators, which is sometimes very useful.

[18:20] *** yqt joined
[18:21] <mst> masak: oooh, yeah, recursive I hadn't thought off

[18:21] <mst> because at that point you're going to need to wrap the given in a sub otherwise

[18:22] <FROGGS> nine: did you get any further wrt Hash.new or what it was?

[18:24] *** lichtkind left
[18:24] *** rangerprice joined
[18:25] <masak> mst: I'd say the nice thing is often that the multis end up in a very small scope, and so it feels... hm, economic? the opposite of wasteful, in terms of polluting scopes.

[18:25] <mst> eah

[18:25] <mst> *yeah

[18:33] *** rurban left
[18:41] *** beastd joined
[18:43] <raiph> m: macro it { $_ }; say it # masak, what am I doing wrong?

[18:43] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[18:46] *** n0tjack joined
[18:47] <masak> raiph: several things, though that's not a helpful error message.

[18:47] <masak> this is what I think you wanted:

[18:47] <masak> m: macro it { quasi { $_ } }; $_ = 5; say it

[18:47] <camelia> rakudo-moar 13f829: OUTPUT«Bytecode validation error at offset 12, instruction 3:␤lexical operand index 3 out of range 0.. 1␤  in block <unit> at /tmp/BtRYrrt0J0:1␤␤»

[18:47] <masak> whee

[18:47] <masak> :/

[18:48] <masak> this actually works, and is what you ought to probably do anyway:

[18:48] <masak> m: sub it { $CALLER::_ }; $_ = 5; say it

[18:48] <camelia> rakudo-moar 13f829: OUTPUT«5␤»

[18:49] <masak> but note that by doing something like this, you hose optimizability.

[18:49] <raiph> \m: sub it { $CALLER::_ }; $_ = 5; given 1 { given 2 { say it } }

[18:49] <raiph> m: sub it { $CALLER::_ }; $_ = 5; given 1 { given 2 { say it } }

[18:49] <camelia> rakudo-moar 13f829: OUTPUT«2␤»

[18:50] *** lichtkind joined
[18:51] <raiph> masak: thanks; I was thinking the right macro would be just a compile time alias and avoid hosing opt

[18:51] <masak> raiph: you've given me something to think about. I'm not sure what I would *want* $_ in a quasi block would do.

[18:51] <masak> raiph: yes, in some universes I'm sure it'd do what you wanted, and then you're right, it would avoid hosing.

[18:51] *** n0tjack left
[18:52] <raiph> i've been thinking i'd one day be able to do that for about 15 years :)

[18:52] <masak> raiph: the troubles you were experiencing when trying are a special case of the much more general rule: macros are not as straightforward as people think. ;)

[18:52] <masak> I'm painfully aware that textual macros would help you here in a jiffy.

[18:52] <vendethiel> .oO( the general rule is that things are not generalizable )

[18:52] <masak> but then again, so would synthetic Qtrees, probably. so there is that.

[18:54] <masak> m: macro it { quasi { $COMPILING::_ } }; $_ = 5; say it

[18:54] <camelia> rakudo-moar 13f829: OUTPUT«(Any)␤»

[18:54] <masak> at some point, that might also work.

[18:54] <vendethiel> I don't get why a plain quasi { $_ } doesn't work, btw. uses the macro's $_?

[18:56] <masak> yes, I believe so.

[18:56] <vendethiel> the error message is.. interesting :-)

[18:56] <masak> more to the point, macros are supposed to return a Qtree/AST.

[18:56] <masak> and $_ doesn't necessarily contain one.

[18:57] <vendethiel> m: my $a; macro f { quasi { $a } }; say f; $a = 5; say f;

[18:57] <camelia> rakudo-moar 13f829: OUTPUT«(Mu)␤(Mu)␤»

[18:58] <masak> that used to work, I think.

[18:58] <masak> at least there were concrete plans to add the scope fudging that would make that work.

[19:01] *** lichtkind_ joined
[19:01] *** lichtkind left
[19:01] *** lichtkind_ is now known as lichtkind

[19:01] <raiph> masak: thanks :)

[19:03] <masak> no, thank *you*.

[19:05] <raiph> masak: :)

[19:05] <raiph> While I look forward to using macros after christmas I have a (hopefully) much simpler thing I'm hoping for before then

[19:05] <raiph> Namely making a pure text alias for $_, $/ and $!

[19:06] <raiph> As part of a one-liner slang that works well on twitter

[19:06] <raiph> To be used along with idioms like:

[19:07] <raiph> m: my \array =@= 1,2,3; array[2] = 9; say array

[19:07] <camelia> rakudo-moar 13f829: OUTPUT«[1 2 9]␤»

[19:07] * grondilu is confused by =@=

[19:08] <nine> FROGGS: Pair.new. Unfortunately not

[19:08] <raiph> because that avoids the problem of twitter turning, say, @foo into a link to user @foo

[19:08] <nine> FROGGS: the AST is different, but I don't see how that could result in the error

[19:08] <raiph> grondilu: same as = @ =

[19:09] <grondilu> oh ok

[19:09] <grondilu> doesn't that make is static though?

[19:09] <grondilu> *it

[19:10] <timotimo> ohai grondilu 

[19:10] <grondilu> hello

[19:10] <nine> FROGGS: AST of :a(1), :b(2) which is working: https://gist.github.com/niner/64a4d6868ce1179dbe52 AST of :a(1) :b(2) which is failing: https://gist.github.com/niner/8b72965085167e70c8c4

[19:10] <grondilu> m: sub f { my \a = @ = rand xx 2; } say f(); say f()

[19:10] <camelia> rakudo-moar 13f829: OUTPUT«5===SORRY!5=== Error while compiling /tmp/krYtYvcv07␤Strange text after block (missing semicolon or comma?)␤at /tmp/krYtYvcv07:1␤------> 3sub f { my \a = @ = rand xx 2; }7⏏5 say f(); say f()␤    expecting any of:␤        infix␤       …»

[19:10] <grondilu> m: sub f { my \a = @ = rand xx 2; }; say f(); say f()

[19:10] <camelia> rakudo-moar 13f829: OUTPUT«[0.422296211330265 0.443838759020408]␤[0.722972848828959 0.882823727019912]␤»

[19:11] *** rurban joined
[19:11] <grondilu> well apparently not

[19:11] <grondilu> m: sub f { @ = rand xx 2; }; say f(); say f()

[19:11] <camelia> rakudo-moar 13f829: OUTPUT«[0.150346546436024 0.864600056747442]␤[0.81724423436766 0.547183014182375]␤»

[19:11] <timotimo> nine: i've implemented "hunting" additional colonpairs for argument lists at some point in the past

[19:11] <grondilu> m: sub f { state @ = rand; }; say f(); say f()

[19:11] <camelia> rakudo-moar 13f829: OUTPUT«[0.128851429252551]␤[0.128851429252551]␤»

[19:11] <timotimo> nine: what exactly is the problem? what is :a(1) :b(2) supposed to do?

[19:13] <FROGGS> m: say Pair.new('a', 1, a => 1)

[19:13] <camelia> rakudo-moar 13f829: OUTPUT«Too many positionals passed; expected 1 argument but got 3␤  in block <unit> at /tmp/W09EKfqBEF:1␤␤»

[19:13] <FROGGS> m: say Pair.new('a', 1, b => 2) # nine: I think that is what happens...

[19:13] <camelia> rakudo-moar 13f829: OUTPUT«Too many positionals passed; expected 1 argument but got 3␤  in block <unit> at /tmp/OAQev6U942:1␤␤»

[19:14] <FROGGS> nine: here: https://gist.github.com/niner/8b72965085167e70c8c4#file-gistfile1-txt-L47-L60

[19:14] <nine> timotimo: I have a branch where I merged Pair and Enum. Pair got a new multi new($key, Mu \value) candidate. I removed the $key.named('key'); $value.named('value') from make_pair in Actions.nqp. Everything works except for chained pairs like :a(1) :b(2)

[19:15] <FROGGS> m: say (:a(1) :b(2)).perl

[19:15] <camelia> rakudo-moar 13f829: OUTPUT«(:a(1), :b(2))␤»

[19:15] <FROGGS> m: say (:a(1), :b(2)).perl

[19:15] <camelia> rakudo-moar 13f829: OUTPUT«(:a(1), :b(2))␤»

[19:15] <FROGGS> nine: so I just need to build rakudo/gmr?

[19:15] <timotimo> huh, that's kinda weird

[19:15] <timotimo> why does that work in the first pace

[19:15] <timotimo> place

[19:16] <nine> The error message is: "Default constructor for 'Pair' only takes named arguments" though it certainly has a multi new that does

[19:16] <nine> FROGGS: yes

[19:16] <nine> timotimo: I think the syntax is used for use Foo:ver<1>:from<nqp>

[19:16] <FROGGS> nine: no, that's just a longname

[19:17] <timotimo> you should be able to see that by just trying use Foo:ver<1>:from<nqp> and see what kind of error it gives

[19:17] <nine> FROGGS: but this triggers the bug in a spec test: use t::spec::packages::S11-modules::Foo :others;

[19:18] <FROGGS> nine: well, that's not a longname :o)

[19:18] <nine> Anyway it really seems to be supported syntax. The question is just, why it doesn't work?

[19:18] <timotimo> and perhaps a debug print that says everything that was taken from there

[19:18] <timotimo> right, that's a pair argument for the export sub in Foo

[19:19] <FROGGS> $ perl6 -e 'say (:a(1) :b(2)).perl'

[19:19] <FROGGS> Default constructor for 'Pair' only takes named arguments

[19:20] <nine> I'm absolutely baffled. I added debug statements to the actions and both Pairs are constructed by make_pair and everything looks just the same

[19:20] <timotimo> interesting how the 2 is added to the call that's supposed to build the first pair

[19:20] <timotimo> oh

[19:20] <nine> Yes, this QAST::SpecialArg thing I don't understand

[19:20] <timotimo> of course

[19:20] <nine> ?

[19:20] <timotimo> it's a named

[19:20] <timotimo> the pair constructor for :a(1) gets :b(2) passed as a named parameter

[19:20] <nine> oh

[19:21] <FROGGS> aye

[19:22] <nine> So a *%args on my "new" candidate should help?

[19:22] <timotimo> the dumping of that may want to be better

[19:22] <FROGGS> nine: I think so

[19:22] <timotimo> yes, but it might be better if we can get rid of the thing passing it in the first place

[19:23] <nine> But it doesn't :(

[19:23] <timotimo> what do the candidates look like for the new method?

[19:23] <nine> Changed it to  multi method new($key, Mu \value, *%args) { ... } but still get the same message

[19:24] <nine> timotimo: https://github.com/rakudo/rakudo/blob/gmr/src/core/Pair.pm

[19:24] <FROGGS> nine: https://gist.github.com/FROGGS/5c502310bf7d5424246f

[19:25] <timotimo> nine: can you print out the actual candidates for Pair.^can('new') or something?

[19:25] <timotimo> m: .perl.say for Pair.^can('new')

[19:25] <camelia> rakudo-moar 13f829: OUTPUT«method new (Enum $: :$key, Mu :$value, *%_) { #`(Method|36542608) ... }␤method new (Mu $: |) { #`(Method|35024240) ... }␤»

[19:25] <timotimo> .o( this could actually use nqp::getcodelocation to print out file name and line number, too )

[19:26] <nine> perl6 -e '.perl.say for Pair.^can("new")'

[19:26] <nine> method new (Mu $: |) { #`(Method|37891016) ... }

[19:26] <nine> method new (Mu $: |) { #`(Method|36357328) ... }

[19:26] <nine> ???

[19:28] <timotimo> huh, i thought we had a method to get the code location

[19:29] <timotimo> m: use nqp; nqp::getcodelocation(nqp::getattr($_, '$!do', Code)) for Pair.^can('new')

[19:29] <camelia> rakudo-moar 13f829: OUTPUT«Cannot unbox a type object␤  in block <unit> at /tmp/bO6zLDFJ4J:1␤␤»

[19:29] <timotimo> ... how do i do that again ...

[19:30] <lichtkind> allright becasue parcel reform i will update my p6 datastructures slides 

[19:30] <timotimo> m: use nqp; nqp::getcodelocation(nqp::getattr(nqp::decont($_), '$!do', Code)) for Pair.^can('new')

[19:30] <camelia> rakudo-moar 13f829: OUTPUT«Cannot unbox a type object␤  in block <unit> at /tmp/9D4trzNSB0:1␤␤»

[19:30] <timotimo> huh?

[19:31] <timotimo> m: my &meth = Pair.^can('new'); say &meth.WHAT

[19:31] <camelia> rakudo-moar 13f829: OUTPUT«Type check failed in assignment to '&meth'; expected 'Callable' but got 'List'␤  in block <unit> at /tmp/J56xDSnnCZ:1␤␤»

[19:31] <timotimo> er, yeah

[19:31] <timotimo> m: my &meth = Pair.^can('new')[0]; say &meth.WHAT

[19:31] <camelia> rakudo-moar 13f829: OUTPUT«(Method)␤»

[19:32] <timotimo> m: my &meth = Pair.^can('new')[0]; say nqp::getattr(&meth, '$!do', Code);

[19:32] <camelia> rakudo-moar 13f829: OUTPUT«Cannot unbox a type object␤  in block <unit> at /tmp/HIkV4nFbkP:1␤␤»

[19:33] <timotimo> oh

[19:33] <timotimo> obvious.

[19:34] <timotimo> m: my &meth = Pair.^can('new')[0]; say nqp::getattr(&meth, Code, '$!do');

[19:34] <camelia> rakudo-moar 13f829: OUTPUT«P6opaque: no such attribute '$!do'␤  in block <unit> at /tmp/fX6KxaP3eZ:1␤␤»

[19:34] <timotimo> m: my &meth = Pair.^can('new')[0]; say nqp::getattr(nqp::decont(&meth), Code, '$!do');

[19:34] <camelia> rakudo-moar 13f829: OUTPUT«new␤»

[19:34] <timotimo> m: my &meth = Pair.^can('new')[0]; say nqp::getcodelocation(nqp::getattr(nqp::decont(&meth), Code, '$!do'));

[19:34] <camelia> rakudo-moar 13f829: OUTPUT«file => src/gen/m-CORE.setting, line => 13978␤»

[19:34] <timotimo> nine: ^- this ought to help you

[19:35] <timotimo> nine: also, a newer nqp will give you less spammy QAST::Var in your qast dumps

[19:39] <nine> timotimo: that gives me the location of roto method new(|) { * } :-/

[19:40] <timotimo> ah

[19:40] <timotimo> then you want its .candidates

[19:40] <timotimo> or something similarly named

[19:41] *** mprelude joined
[19:42] <nine> perl6 -e 'say Pair.^can("new")[0].candidates.perl'

[19:42] <nine> (method new (Mu $: *%) { #`(Method|50799664) ... }, method new (Mu $: $, *@, *%_) { #`(Method|50799816) ... }, method new (Pair $: Mu $key, Mu \value, *%_) { #`(Method|52335464) ... }, method new (Pair $: :$key, Mu :$value, *%_) { #`(Method|52335616) ... })

[19:43] <nine> perl6 -e 'say Pair.^can("new")[1].candidates.perl'                                                                

[19:43] <nine> (method new (Mu $: *%) { #`(Method|51762224) ... }, method new (Mu $: $, *@, *%_) { #`(Method|51762376) ... })

[19:43] <timotimo> huh, wait a second

[19:43] <timotimo> methods already have *% installed in their signatures anyway

[19:44] <timotimo> so adding *% wouldn't help anyway, because it's a no-op

[19:44] <nine> yep

[19:44] <timotimo> hm

[19:45] <timotimo> "Pair $:" ?

[19:45] <timotimo> can you introduce a new proto method new to Pair, so that other multi candidates from superclasses will get shut out?

[19:47] <FROGGS> nine: I'm spectesting this now: https://gist.github.com/FROGGS/e0a5b6ec63afef9817ae

[19:48] <timotimo> didn't nine remove that very intentionally?

[19:48] <nine> FROGGS: that reverts the change I made

[19:48] <FROGGS> die he?

[19:48] <timotimo> he did

[19:49] <FROGGS> but.... that makes the example work

[19:49] <nine> I need the positional candidate to avoid itemizing the value.

[19:49] <FROGGS> I see

[19:50] <FROGGS> then we need to fix hunt_loose_adverbs_in_arglist()

[19:51] <timotimo> i wrote that ...

[19:51] <nine> But in what way is it broken in the first place?

[19:51] *** beastd left
[19:52] <FROGGS> it should put additional adverbs in a ,-list, but it does not remove the adverbs from the first Pair

[19:52] <FROGGS> and that's the issue here

[19:52] <nine> That and the dispatch problem

[19:53] *** xfix left
[19:58] <nine> timotimo: adding the proto method new gives me: Cannot call new(Pair: Str, Int); none of these signatures match: (Pair $: $key, Mu \value, *%_) (Pair $: :$key, Mu :$value, *%_)

[19:58] <nine> Which may actually be the cause

[20:00] <FROGGS> m: say (Str, Int) ~~ :(Any, Mu)

[20:00] <camelia> rakudo-moar 13f829: OUTPUT«True␤»

[20:00] *** zakharyas joined
[20:01] *** laouji joined
[20:02] *** rarara joined
[20:03] *** Ven joined
[20:03] <Ven> m: sub bar (|args = \(1,2,3)) {...}

[20:03] <camelia> rakudo-moar 13f829: OUTPUT«===SORRY!===␤At Frame 2, Instruction 4, op 'param_sp' has invalid number (3) of operands; needs 2.␤»

[20:04] <FROGGS> ohh, nice one

[20:04] <Ven> FROGGS: https://github.com/MoarVM/MoarVM/issues/145

[20:05] <FROGGS> ohh, old one :/

[20:07] *** darutoko left
[20:10] *** Ven left
[20:12] <japhb> Good *, #perl6

[20:12] <yoleaux> 4 Sep 2015 19:40Z <FROGGS> japhb: I merged C++ stuff in moar, but have to port it to jvm before I can merge the rakudo/cpp3 branch... hopefully this happens this weekend

[20:12] <yoleaux> 12:29Z <FROGGS> japhb: I'm unable to merge C++ support in rakudo until it got ported to jvm... and I cannot port it as long as the jvm build is broken

[20:13] <japhb> FROGGS: Oooh, ouch!

[20:13] <japhb> I've been AFK for a couple days ... what's the current state of the JVM build?

[20:13] <nine> still broken

[20:15] <FROGGS> aye

[20:15] *** TEttinger joined
[20:15] <FROGGS> and I had no luck yet in hunting it down... or gaining more information

[20:18] *** ShimmerFairy left
[20:19] * TimToady is trying it without the 3 instances of statement_control:<with> to see if that makes a difference

[20:20] *** mr-foobar left
[20:21] *** TEttinger left
[20:21] *** TEttinger joined
[20:22] *** mr-foobar joined
[20:24] <TimToady> nope, doesn't help

[20:24] <TimToady> 'with' is exonerated

[20:26] *** virtualsue joined
[20:30] *** telex left
[20:30] <nine> It gets weirder and wirder. If I remove the candidate with the named arguments and make the new($key, Mu \value) a method instead of a multi method, I get a Too few positionals passed; expected 3 arguments but got 2

[20:31] <nine> Which 3 arguments can a method new($key, Mu \value) expect?

[20:31] <FROGGS> invocant + two args

[20:32] *** ShimmerFairy joined
[20:32] <nine> How can the invocant be missing in a method call?

[20:32] *** telex joined
[20:33] <nine> The first param of the callmethod op in make_pair is: QAST::Var.new( :name('Pair'), :scope('lexical') ),

[20:34] *** leont joined
[20:35] *** laouji left
[20:35] *** laouji joined
[20:35] <FROGGS> nine: and you are sure this is about Pair.new and not something else earlier or later?

[20:36] <nine> I'm testing perl6 -e '(:a(1) :b(2))' # There is not much earlier or later. And perl6 -e '(:a(1))' works

[20:39] <nine> The --ll-exception backtrace supports that

[20:39] *** nowan left
[20:40] <nine> Could it be that there's no Pair in lexical scope at the caller's location?

[20:41] <FROGGS> nine: perl6 -e 'say Pair' # will tell you

[20:41] *** nowan joined
[20:44] <nine> (Pair)

[20:46] <FROGGS> ohh, in (:a(1) :b(2)) the first thing results in two positionals, and in the second in one positional and one named

[20:47] <nine> Aah, that explains it. I'm just testing making value optional

[20:47] <nine> And indeed that fixes it!

[20:47] <nine> So the error is indeed in the hunt_loose_adverbs_in_arglist() thing

[20:48] *** n0tjack joined
[20:50] <nine> Thanks for the help!

[20:50] <nine> Very much appreciated

[20:51] <FROGGS> I am working on patch currently

[20:51] *** CQ joined
[20:52] *** n0tjack left
[20:53] *** CQ left
[20:53] <FROGGS> nine: this makes it work for me: https://gist.github.com/FROGGS/63d711782223d28adf5d

[20:54] <FROGGS> nine: I dunno how safe it is to assume that the value is a QAST::Want... but maybe it will help you getting further at least

[20:56] <nine> FROGGS: I'll give it a try tomorrow. Really have to go to bed now.

[20:57] *** virtualsue left
[20:57] *** virtualsue joined
[20:57] <FROGGS> nine: me too, gnight

[20:59] *** rindolf left
[21:00] *** rindolf joined
[21:07] <_itz> m: my @foos = q|foo|; warn @foos.WHAT

[21:07] <camelia> rakudo-moar 13f829: OUTPUT«Use of uninitialized value <element> of type Array in string context  in block <unit> at /tmp/z9EB5QwaFT:1␤Warning: something's wrong  in block <unit> at /tmp/z9EB5QwaFT:1␤»

[21:08] *** virtualsue left
[21:08] *** virtualsue_ joined
[21:08] *** virtualsue_ is now known as virtualsue

[21:08] <_itz> m: my @foos = q|foo|; dd @foos

[21:08] <camelia> rakudo-moar 13f829: OUTPUT«@foos = ["foo"]␤»

[21:09] *** virtualsue left
[21:09] *** virtualsue joined
[21:11] <TimToady> m: say (1,2,4 ... *).is-lazy

[21:11] <camelia> rakudo-moar 13f829: OUTPUT«False␤»

[21:11] <TimToady> that seems wrong

[21:12] <TimToady> m: say (1 .. *).is-lazy

[21:12] <camelia> rakudo-moar 13f829: OUTPUT«True␤»

[21:14] <_itz> m: my @foos = q|foo|; say @foos.WHAT

[21:14] <camelia> rakudo-moar 13f829: OUTPUT«(Array)␤»

[21:17] *** FROGGS[mobile] left
[21:20] *** TEttinger left
[21:21] *** virtualsue left
[21:21] *** kaare_ left
[21:21] *** virtualsue joined
[21:22] *** virtualsue left
[21:22] *** virtualsue_ joined
[21:22] *** virtualsue_ left
[21:23] *** rindolf left
[21:31] *** FROGGS left
[21:35] <masak> TimToady: feel free to submit a rakudobug. I'm a bit tied up right now.

[21:42] *** lichtkind left
[21:43] <rarara> m: say (1,2,4 .. *).is-lazy

[21:43] <camelia> rakudo-moar 13f829: OUTPUT«False␤»

[21:43] *** vendethiel left
[21:45] *** pmurias left
[21:46] *** zakharyas left
[21:46] <dalek> rakudo/nom: 5e1b082 | TimToady++ | src/core/operators.pm:

[21:46] <dalek> rakudo/nom: ...* wasn't marked .is-lazy

[21:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5e1b082921

[21:47] <masak> ...or that.

[21:48] <TimToady> not sure about rarara++'s example though

[21:48] <TimToady> that sort of is a push-until-lazy example

[21:49] <ugexe> m: my @a = ((1,2),(3,4)); my @b = @a.flatmap({ $_ }); say @b.perl

[21:49] <camelia> rakudo-moar 13f829: OUTPUT«[(1, 2), (3, 4)]␤»

[21:49] <ugexe> star: my @a = ((1,2),(3,4)); my @b = @a.flatmap({ $_ }); say @b.perl

[21:49] <camelia> star-m 2015.03: OUTPUT«Array.new(1, 2, 3, 4)␤»

[21:49] <ugexe> is the current behavior what is expected?

[21:51] <ugexe> or should i not use flatmap

[21:53] <TimToady> looks broken to me

[21:54] <TimToady> or maybe it's itemizing in that case

[21:54] <TimToady> m: my \a = ((1,2),(3,4)); my @b = a.flatmap({ $_ }); say @b.perl

[21:54] <camelia> rakudo-moar 13f829: OUTPUT«[1, 2, 3, 4]␤»

[21:55] <TimToady> yeah, Array itemizes, which protects from flattening

[21:55] <TimToady> .flatmap is really only for lists

[21:56] <TimToady> m: say (((1,2,3),4,5),6).flatmap.perl

[21:56] <camelia> rakudo-moar 13f829: OUTPUT«Cannot call flatmap(List: ); none of these signatures match:␤    ($: &block, :$label, *%_)␤  in block <unit> at /tmp/JBKX7fqASb:1␤␤»

[21:56] <TimToady> hmm

[21:57] <TimToady> anyway, looks like it was supposed to be deprecated

[21:57] <TimToady> m: say (((1,2,3),4,5),6).flat.map.perl

[21:57] <camelia> rakudo-moar 13f829: OUTPUT«Cannot call map(Seq: ); none of these signatures match:␤    (\SELF: &block, :$label, :$item, *%_)␤    (HyperIterable:D $: &block, :$label, *%_)␤  in block <unit> at /tmp/tRzwuVlxo0:1␤␤»

[21:58] <TimToady> m: say (((1,2,3),4,5),6).flatmap(*+1).perl

[21:58] <camelia> rakudo-moar 13f829: OUTPUT«(4, 7).Seq␤»

[21:58] <TimToady> m: say (((1,2,3),4,5),6).flat.map(*+1).perl

[21:58] <camelia> rakudo-moar 13f829: OUTPUT«(2, 3, 4, 5, 6, 7).Seq␤»

[21:58] <TimToady> and it has the wrong definition of flat anyway...

[21:59] *** rurban1 joined
[22:00] *** rurban left
[22:01] <TimToady> actually, looks like it flattens after the map

[22:01] <TimToady> it's obviously confusing, so I'd avoid it

[22:02] <rangerprice> Where i can learn how to create an interpreter for a language ? 

[22:03] *** [Sno] left
[22:07] <Ulti> rangerprice a language thats already well defined and old or a language you are creating?

[22:11] <rangerprice> Ulti: both

[22:11] *** [Sno] joined
[22:11] <timotimo> it's a language that rangerprince is creating, but he's been creating it for 30 years now so it's already well defined

[22:13] *** espadrine left
[22:14] <rangerprice> hehehe

[22:14] <timotimo> how come panda doesn't have the glr branch merged to master yet?

[22:15] <rangerprice> https://www.youtube.com/watch?v=KMU0tzLwhbE

[22:15] *** laouji left
[22:20] <masak> rangerprice: it's hard to answer your "Where i can..." question without knowing what experience you already have. but as a general suggestion, I would go looking for source code for existing interpreters, and read and learn.

[22:20] <masak> rangerprice: as someone said, an interpreter is just a switch statement in a loop :)

[22:21] *** TEttinger joined
[22:22] <rangerprice> masak: i'm just a developer, so i have any experience on designing a programming language but i'm very interested

[22:22] <TimToady> masak: *everything* is just a switch statement in a loop :P

[22:24] <rangerprice> I have a question to Perl 6 developers

[22:24] <rangerprice> Why they don't remove the "my" keyword ?! This keyword should be removed from Perl, because by default, every variable should be local.

[22:25] *** lichtkind joined
[22:26] <BenGoldberg> rangerprice, How would you denote when a variable comes into and goes out of scope?

[22:26] <masak> rangerprice: it's nice to have the "my" there.

[22:26] <masak> rangerprice: if variables just appear when you assign to them (like in Python and Ruby), there is a risk of typos and thinkos.

[22:27] *** colomon joined
[22:27] <masak> rangerprice: I'm in the same situation re experience/interest. in the past few months, I've been building a toy language called 007. (and before you ask, yes it has an interpreter.)

[22:27] <timotimo> coffeescript people have had problems with lack of a "my"-equivalent

[22:28] <masak> rangerprice: you might want to take a look. http://masak.github.io/007/

[22:28] <timotimo> and python people, too, with their "nonlocal" shenanigans

[22:29] <masak> I think history will show quite clearly that lexical scoping is very nice, and that explicitly declaring your lexical variables is worth it.

[22:29] <masak> it's interesting how many languages are fighting against that current, though.

[22:29] <timotimo> masak: NoMy programming languages

[22:30] * TimToady -> zzz &

[22:30] <timotimo> it's rather clearly not what you want, but people keep pushing it, because it's new and hip

[22:30] <timotimo> and FREEDOM!

[22:30] <timotimo> and we need the flexibility for our ridiculously short turn-arounds and our amazing agility

[22:30] <rangerprice> BenGoldberg, i think that the "my" keyword should be implicitly use when declaring a variable. For example: when the interpreter see "$banana= 55", it should see "my $banana = 55"

[22:30] <timotimo> schemas and defined variables only slow us down!

[22:31] <timotimo> m: my $a = 10; my $a = $a + 5; say my $a;

[22:31] <camelia> rakudo-moar 5e1b08: OUTPUT«5===SORRY!5===␤Cannot use variable $a in declaration to initialize itself␤at /tmp/hVAEM4Exh_:1␤------> 3my $a = 10; my $a = $7⏏5a + 5; say my $a;␤    expecting any of:␤        term␤Other potential difficulties:␤    Redeclaration of …»

[22:31] <timotimo> like that? :)

[22:32] <timotimo> and when someone declares a variable that's named the same as yours in some outer scope, you'll suddenly get unexpected sharing of values

[22:32] <timotimo> like $i for a loop :P

[22:32] <masak> rangerprice: I think the "implicitly" idea is popular but bad.

[22:33] <masak> rangerprice: that's why I said it leads to typos and thinkos not being caught by the compiler.

[22:33] <timotimo> rangerprice: and how do you put type restrictions?

[22:33] <masak> rangerprice: that's incidentally also why I was happy to make -e strict by default in a commit last week ;)

[22:34] <rangerprice> Everyone is clever in 2015, so its for me a lot of work to prefix my variable with the "my" keyword :(

[22:34] <timotimo> you know, you can write a slang for that

[22:35] <rangerprice> but i can't write anything, i'm too clever for that

[22:35] * TimToady is glad he's already gone to bed...

[22:35] <timotimo> i don't understand what you mean with "clever"

[22:36] <rangerprice> lazy * excuse me for my mistake

[22:37] <masak> what a diligent mistake :P

[22:37] *** rarara left
[22:38] <masak> rangerprice: there is laziness that doesn't matter much, and there is laziness that comes back to bite you, introduces bugs, and degrades the reliability of the program

[22:38] <masak> rangerprice: skipping "my" in a language is of the latter type

[22:38] <masak> rangerprice: I don't see it as a cost -- I see it as a *check* that the compiler can do for me

[22:39] <masak> rangerprice: typically, I forgot the "my" because I didn't think clearly about the declaration of the variable. the compiler helpfully notifies me of this.

[22:39] <rangerprice> oh yes

[22:40] <masak> more generally, a thing I've come to notice more and more are that many mature features come in two halves: a declaration, and a use (though they are not always called that)

[22:41] <masak> think of functions vs function calls, classes vs the creation/use of classes, variable declarations vs their use

[22:41] <masak> from that perspective, being able to drop the declaration of a variable ought to sound warning bells -- where did the declaration part of this feature go?

[22:42] <masak> the answer (in my view) is that the user chose to skip it, and that makes it harder for the compiler to check that the program does what it should

[22:42] <masak> or, put differently, the *convenience* of skipping "my" is *unhealthy*, especially for bigger programs

[22:43] <masak> you don't have to agree with me -- but this is my experience :)

[22:43] <rangerprice> I agree with you

[22:44] <rangerprice> Where i can find the source code of 007 language ?

[22:44] <masak> https://github.com/masak/007

[22:45] <rangerprice> Thanks !

[22:46] <masak> de nada. enjoy!

[22:46] <jdv79> i found another "perl" beer in rome.  Perlenbacher.

[22:47] <rangerprice> oh god

[22:47] <jdv79> ?

[22:48] <masak> rangerprice: if you want to see where the interpreter is, check out https://github.com/masak/007/blob/master/lib/_007/Runtime.pm#L28 and then the .run and .eval methods in https://github.com/masak/007/blob/master/lib/_007/Q.pm

[22:48] *** TEttinger left
[22:49] <jdv79> not bad.  relatively malty like a "strong" pils.

[22:49] <masak> jdv79: a lager?

[22:49] <masak> or an actual pils?

[22:50] *** TEttinger joined
[22:50] <jdv79> well. i'm not sure.  that's what it tasteslike.

[22:50] <masak> jdv79: was it this one? http://www.ratebeer.com/beer/lidl-perlenbacher-premium-pils--bier/60765/

[22:50] *** TEttinger left
[22:51] <jdv79> no

[22:51] <masak> ok :)

[22:51] <jdv79> http://www.ratebeer.com/beer/lidl-perlenbacher-strong/299380/

[22:51] *** cognominal left
[22:51] <jdv79> which jibes with the taste

[22:52] <jdv79> "imperial pils";  whatever that means

[22:52] <jdv79> :)

[22:53] *** TEttinger joined
[22:56] <masak> heh :)

[22:57] *** TEttinger left
[22:57] <masak> yeah, it's not getting stellar reviews...

[22:57] <masak> 'night, #perl6

[22:58] <jdv79> yeah, its "ok".  nothing special except the name

[22:58] <jdv79> later

[23:03] <jdv79> though, it doesn't deserve a score that low.

[23:05] *** lichtkind left
[23:14] *** AlexDaniel left
[23:21] *** TEttinger joined
[23:34] *** Alina-malina left
[23:36] *** leont left
[23:48] *** yqt left
[23:55] *** aborazmeh joined
[23:55] *** aborazmeh left
[23:55] *** aborazmeh joined
