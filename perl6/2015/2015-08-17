[00:05] *** Possum joined
[00:09] *** aborazmeh joined
[00:09] *** aborazmeh left
[00:09] *** aborazmeh joined
[00:14] *** lizmat left
[00:14] *** awwaiid left
[00:14] *** lizmat joined
[00:18] <[Coke]> m: my @a = "foo"; my @b = @a.reverse; use Test; isa-ok(@b, Iterable).say

[00:18] <camelia> rakudo-moar f185e0: OUTPUT«ok 1 - The object is-a 'Iterable'␤True␤»

[00:18] <[Coke]> (there's a glr change)

[00:31] <ShimmerFairy> psch: we have floating point if you use :16 -> :16<4*16**2> (if I understand 'p' to raise to a power of 16)

[00:32] <ShimmerFairy> And you can't use a radix point outside of :16<> because it can be ambiguous, e.g. 0xFA.CE  (did you mean a fractional 0xCE/0x100, or a method call .CE ?)

[00:35] <psch> ShimmerFairy: my reading re: the java format was a bit shallow, the format is e.g. 0x123.456p0F

[00:36] <psch> ShimmerFairy: i don't see why we couldn't have the fractional decimal point for hex lits, if we can have it for dec lits

[00:36] <psch> ShimmerFairy: the parser state should be similarly unambiguous, if i'm not missing something 

[00:37] <psch> oh wait

[00:37] <psch> i do see it

[00:37] <psch> we can't have methods that starts with a digit

[00:37] <psch> but do have methods that starts with <[ABCDEabcde]>

[00:38] <psch> "For example: 0x123.456 should be evaluated as 1*16*16 + 2*16 + 3 + 4/16 + 5/16/16 + 6/16/16. " from http://www.herongyang.com/Java/Primitive-Type-Literal-Format-for-Floating-Point.html for java again

[00:39] <psch> i don't think we need fractional literals for hex (or oct or bin), in any case

[00:41] <psch> m: say <0o1/0o2>;

[00:41] <camelia> rakudo-moar f185e0: OUTPUT«Attempt to divide by zero using div␤  in block <unit> at /tmp/vYk24LVPvc:1␤␤Actually thrown at:␤  in block <unit> at /tmp/vYk24LVPvc:1␤␤»

[00:41] <psch> nqp-m: say(~+"0o1")

[00:41] <camelia> nqp-moarvm: OUTPUT«0␤»

[00:41] <psch> that's the actual bug i've been looking at

[00:41] <psch> j: say <0x01/0x02> # reported with this example

[00:41] <camelia> rakudo-jvm f185e0: OUTPUT«Attempt to divide by zero using div␤  in block <unit> at /tmp/Cpk4_3Mg2a:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Cpk4_3Mg2a:1␤␤»

[00:42] <psch> and i'm thinking we're doing wrong in letting the backends handle that conversion

[00:42] <psch> which is what i'm about to write into the ticket because i'm obviously getting a bit tired :)

[00:43] <ShimmerFairy> psch: if there's something in the spec showing that (I'm sure there is), then that's just a bug in Rat literals for P6 :)

[00:45] <psch> i think the bug is actually "we don't have &val yet" 

[00:45] <ShimmerFairy> Not really, since <1/2> is just a literal Rat, and I know there's a parsing rule for it

[00:45] <ShimmerFairy> m: say <1/2>; say <1/2>.WHAT

[00:45] <camelia> rakudo-moar f185e0: OUTPUT«0.5␤(Rat)␤»

[00:47] <psch> right, but the parsing of nu and de relies on backends knowing the rakudo Int(Str) conversion rules

[00:47] <ShimmerFairy> A quick look tells me there's nothing in the spec to suggest <0x1/0x2> should work, surprisingly

[00:49] <psch> hm

[00:50] <ShimmerFairy> Although the parser is set up to allow it :)

[00:51] <psch> std: <0x1/0x2>

[00:51] <camelia> std 28329a7: OUTPUT«ok 00:00 134m␤»

[00:51] <psch> std: < 0x1/0x2 >

[00:51] <camelia> std 28329a7: OUTPUT«ok 00:00 134m␤»

[00:52] <ShimmerFairy> In reality it should be taking the ast of $<nu> and $<de>, not making its own constants out of numifying the matched strings

[00:54] <psch> the bit with space next to the angle brackets is the one that could use val(), as i just read in S02...

[00:57] <psch> i have to say i'm a bit stumped what exactly to understand under "constant folding"

[00:57] <psch> ...oh

[00:57] <psch> thanks google

[00:58] <psch> i'll go to bed :)

[00:59] <psch> i'll try passing the AST when i find some more time, and i added this last bit of discussion to the ticket as well, g'night o/

[01:00] <ShimmerFairy> psch: ♞ o/  I worked on numeric-literal-related code recently, so there's a chance I'll add tests and fix it in the meantime :)

[01:04] *** laouji joined
[01:09] *** oetiker left
[01:19] *** oetiker joined
[01:21] <TimToady> okay, shinkansen tickets acquired for 京都 --> 東京.

[01:21] <yoleaux> 16 Aug 2015 18:14Z <laben> TimToady: i would like to ask you what do you think of restricting (multi) methods definitions of a class with the (multi/proto) methods signature of composited roles

[01:41] <ShimmerFairy> Well, my original question was about requirements, not restrictions :)

[01:42] <ShimmerFairy> m: role R { method M($a, $b) {...} }; class C does R { method M($c) { say $c } }; C.M(42)

[01:42] <camelia> rakudo-moar f185e0: OUTPUT«42␤»

[01:42] <ShimmerFairy> If that's considered a bug in stubbed role methods, then I don't see how requiring specific multi method sigs would be much more effort :)

[01:43] <lizmat> .oO( biting the bullet from Kyoto To Tokyo: an anagramic journey )

[01:45] <ShimmerFairy> lizmat: did you implement the $? restriction?

[01:46] <lizmat> I think so

[01:46] <lizmat> m: my constant $?FOO = 42

[01:46] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VFeGxVNqlx␤Cannot use ? twigil on 'my' constant because it is reserved␤at /tmp/VFeGxVNqlx:1␤------> 3my constant $?FOO = 427⏏5<EOL>␤»

[01:46] <lizmat> m: my $?FOO = 42

[01:46] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lHYeppDipe␤Cannot use ? twigil on 'my' variable because it is reserved␤at /tmp/lHYeppDipe:1␤------> 3my $?FOO7⏏5 = 42␤»

[01:46] *** llfourn joined
[01:46] <ShimmerFairy> m: constant $?TABSTOP = 3; say $?TABSTOP;

[01:46] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Z8v3rnnX7i␤Cannot use ? twigil on '' constant because it is reserved␤at /tmp/Z8v3rnnX7i:1␤------> 3constant $?TABSTOP = 37⏏5; say $?TABSTOP;␤»

[01:47] <lizmat> ShimmerFairy: is tat wat you meant ?

[01:47] <lizmat> *that

[01:47] <ShimmerFairy> ^ that's spec'd to work (setting TABSTOP at compile-time). Either that's a bug in the impl, or it should be $*TABSTOP now.

[01:47] <lizmat> well, good point

[01:48] <ShimmerFairy> From S02:  All C<$?> variables are considered constants, and may not be modified after being compiled in.  The user is also allowed to define or (redefine) such constants:

[01:48] <ShimmerFairy> the following code sample being    constant $?TABSTOP = 4

[01:48] <lizmat> it was such that { my constant $?TABSTOP = 42; say $?TABSTOP } would say 8 (because it would have gotten constant folded)

[01:49] <lizmat> so it wasn't working as specced to begin with

[01:51] *** llfourn left
[01:51] <ShimmerFairy> So, should $?TABSTOP be $*TABSTOP (since you're supposed to be able to change it), or would it be better if $? were made to work more to spec?

[01:54] <ShimmerFairy> I would suggest going more to spec, but then again I'm not sure about people being able to change things like $?LINE or %?META

[01:55] <lizmat> I would like jnthn and TimToady's opinion on that

[01:56] <ShimmerFairy> $?TABSTOP is admittedly the odd one out of $? vars, since it's designed to be user-set :)

[01:56] <lizmat> yeahj...

[01:56] <lizmat> so maybe it *should* be $*TABSTOP

[01:56] <ShimmerFairy> If you are able to set $? at compile-time, I think I would prefer if you had to set them in BEGIN {} phasers, or something else to explicitly say "at compile time"

[01:56] <lizmat> actually, thinking about this more: $? guarantees immutability

[01:57] <lizmat> well, 'my constant' means compile time to me

[01:58] <ShimmerFairy> Interesting, I don't think of the 'constant' keyword as inherently compile-time, though I see why :)

[01:58] <lizmat> otoh, 'my constant $foo = $a + $b' may not fit that bill

[01:58] <lizmat> m: my $a = 42; my $b; my constant $foo = $a + $b

[01:58] <camelia> rakudo-moar f185e0: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/QKgfj3Bdtm:1␤Use of uninitialized value of type Any in numeric context  in block  at /tmp/QKgfj3Bdtm:1␤»

[01:58] <lizmat> m: my $a = 42; my $b; my constant $foo = $a + $b; say $foo

[01:58] <camelia> rakudo-moar f185e0: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/w9Q0j3yFw1:1␤Use of uninitialized value of type Any in numeric context  in block  at /tmp/w9Q0j3yFw1:1␤0␤»

[01:59] <lizmat> m: my $a = BEGIN 42; my $b; my constant $foo = $a + $b; say $foo

[01:59] <camelia> rakudo-moar f185e0: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/QQGKV0xCAE:1␤Use of uninitialized value of type Any in numeric context  in block  at /tmp/QQGKV0xCAE:1␤0␤»

[01:59] <ShimmerFairy> m: my $a = 42; my $b = 21; my constant $foo = $a + $b; say $foo;

[01:59] <camelia> rakudo-moar f185e0: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/ZiS5cxx64H:1␤Use of uninitialized value of type Any in numeric context  in block  at /tmp/ZiS5cxx64H:1␤0␤»

[01:59] <lizmat> m: BEGIN my $a = 42; my $b; my constant $foo = $a + $b; say $foo

[01:59] <camelia> rakudo-moar f185e0: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/pO5ShfxLf8:1␤42␤»

[01:59] <ShimmerFairy> m: BEGIN my $a = 42; BEGIN my $b = 21; my constant $foo = $a + $b; say $foo

[02:00] <camelia> rakudo-moar f185e0: OUTPUT«63␤»

[02:00] <ShimmerFairy> Again, it makes sense to me while 'constant' is compile-time, it just didn't occur to me immediately :)

[02:02] <ShimmerFairy> Yeah, the more I think about it, the more $?TABSTOP seems to be spec'd to act like a $* variable. I can't think of a reason it needs to be a compile-time value off-hand

[02:03] *** geekosaur left
[02:05] <lizmat> yeah, actually deprecating $?TABSTOP in favour of $*TABSTOP now

[02:05] *** geekosaur joined
[02:06] <ShimmerFairy> cool :)

[02:26] *** aindilis left
[02:29] *** aindilis joined
[02:29] *** aindilis left
[02:30] *** aindilis joined
[02:30] *** noganex_ joined
[02:30] <lizmat> am having second thoughts...

[02:31] <lizmat> after reading the spec again

[02:31] <lizmat> would like the feedback of TimToady and jnthn about taking this further

[02:31] *** aindilis left
[02:31] <lizmat> feels like forbidding it, like I did, is the bug, *not* the way it was specced

[02:32] *** aindilis joined
[02:32] <lizmat> so before I start changing this, the spec should be changed  :-)

[02:32] <ShimmerFairy> lizmat: fair enough, though I still see TABSTOP as as *-y variable :)

[02:33] *** noganex left
[02:33] <ShimmerFairy> lizmat: Like I said, I'm not sure if I want people to be able to modify $?LINE and such, so I'm tempted to say that they're read-only compiler constants.

[02:33] <lizmat> well, there are good reasons to be able to modify $?LINE

[02:35] <lizmat> e.g. if you want to filter out the pod of a source file, but still want to retain the line numbers

[02:36] <ShimmerFairy> Yeah, I can see that. And depending on how $?LINE works (I don't know), you could also set it to various ridiculous values as a form of finding the source of an issue :P

[02:36] *** geekosaur left
[02:37] <ShimmerFairy> lizmat: could there be a way to reset $? values, aside from lexical scoping? First thing that comes to mind is  constant $?LINE = $?CORE::LINE  or something.

[02:37] *** geekosaur joined
[02:39] <ShimmerFairy> (It's something that would be helpful if an inner scope wanted to be sure it had the compiler's value for a $? constant, for example)

[02:39] <lizmat> the way World.add_constant works, is that it builds a compile time cache of values, and generates a Wval for it

[02:40] *** cibs_ joined
[02:41] <ShimmerFairy> Ah, so I'm guessing the compiler (at least currently) doesn't preserve its would-be-default values for $? things?

[02:43] *** cibs left
[02:43] <ShimmerFairy> m: say "ABC".match(/abc/, :i);    say "ABC".match(/:i abc/)

[02:43] <camelia> rakudo-moar f185e0: OUTPUT«Nil␤｢ABC｣␤»

[02:43] <ShimmerFairy> Huh, I wonder if those two should be equivalent

[02:45] <dalek> rakudo/glr: b9000b8 | skids++ | src/core/Str.pm:

[02:45] <dalek> rakudo/glr: Reimplement :x and :nth regex modifiers on match, thus fixing comb

[02:45] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b9000b82d1

[02:45] <dalek> rakudo/glr: 88e439c | lizmat++ | src/core/Str.pm:

[02:45] <dalek> rakudo/glr: Merge pull request #498 from skids/glr

[02:45] <dalek> rakudo/glr: 

[02:45] <dalek> rakudo/glr: Reimplement :x and :nth regex modifiers on match, thus fixing comb

[02:45] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/88e439c2b2

[02:45] *** cibs joined
[02:46] <lizmat> ShimmerFairy: :$i is not a named param of Str.match

[02:47] <ShimmerFairy> lizmat: yeah, I was looking at subst-mutate and thought "hey, I see :ii here, but I didn't see :i in match. I wonder..." :)

[02:47] <lizmat> perhaps an oversight, not sure

[02:48] <ShimmerFairy> lizmat: My guess is that adverbs that can go in the regex (that is, /:i abc/ or /ab :r c/) aren't handled by .match

[02:48] <lizmat> yeah, but that could still be a WAT for many?

[02:49] <ShimmerFairy> I don't know if it should or not. (I'm writing a new version of S32::Str, as part of trying to improve strings and such in P6, so I'm bound to run into design stuff ☺)

[02:49] *** cibs_ left
[02:50] <ShimmerFairy> On the one hand, adverbs that can go inside are probably best left to handle stuff inside, without .match overriding behavior. On the other hand, you would think anything that can go m:HERE// could be passed to .match

[02:52] <lizmat> m: my @a; @a.push: [1,2,3]; say @a.elems

[02:52] <camelia> rakudo-moar f185e0: OUTPUT«1␤»

[02:52] <lizmat> so, GLR is supposed to be less flattening

[02:52] <lizmat> $ 6 'my @a; @a.push: [1,2,3]; say @a.elems'

[02:52] <lizmat> 3

[02:52] <lizmat> I would argue it is flattening more... at least in this case...

[02:53] <ShimmerFairy> for .push, that pretty clearly should be like in pre-GLR (pushing an Array into an Array)

[02:53] <lizmat> m: sub a(*@a) { say @a.elems }; a [1,2,3]   # underlying difference

[02:53] <camelia> rakudo-moar f185e0: OUTPUT«1␤»

[02:53] <lizmat> $

[02:53] <lizmat> $ 6 'sub a(*@a) { say @a.elems }; a [1,2,3]'

[02:53] <lizmat> 3

[02:54] <lizmat> so a slurpy will flatten no matter what ?

[02:54] <ShimmerFairy> @a = [1,2,3]  or    @a = [1,2],[3,4]; @b = @a[0]     are interesting and possibly related. (should @a in the first one be [1,2,3] or [[1,2,3]], should @b be [1,2] or [[1,2]])

[02:57] <lizmat> m: sub a(*@a) { say @a.elems }; a (1,2,3)

[02:57] <camelia> rakudo-moar f185e0: OUTPUT«3␤»

[02:58] <skids> Well, :i is one of the adverbs that an implementation may require to be known at compile time, FWIW.

[02:58] <ShimmerFairy> m: my $a = "a :i b"; say "aB" ~~ /<$a>/

[02:58] <camelia> rakudo-moar f185e0: OUTPUT«｢aB｣␤»

[02:58] <lizmat> hmmm..   so now that () is a List, and Array is a mutable List

[02:59] <lizmat> I guess from that follows that [1,2,3] will flatten in the face of s slurpy

[02:59] <ShimmerFairy> skids: ^ so that example shouldn't work, or shouldn't be expected to?

[02:59] <lizmat> m: say Array.^mro

[02:59] <camelia> rakudo-moar f185e0: OUTPUT«(Array) (List) (Iterable) (Cool) (Any) (Mu)␤»

[02:59] <skids> It's optional for an implementation.

[03:00] <ShimmerFairy> rakudo seems to show it's not impossible :) (and besides, an optional feature is new to me in P6, might as well require it)

[03:00] * ShimmerFairy afk for a bit

[03:00] <skids> Well, depending on what "known at compile time" means to the implementation.

[03:01] <skids> The spec language is An implementation may require

[03:01] <skids> that their value is known at compile time, and give a compile-time error

[03:01] <skids> message if that is not the case.

[03:02] *** kaare_ joined
[03:03] <skids> One could argue that "compile time" for /<$a>/ is formally defined as when the clone is made.

[03:03] <skids> (or something)

[03:14] <skids> But with .match you may have an rx from another compunit, and so cannot compile it in.

[03:15] <lizmat> sightseeing&

[03:16] *** ShimmerFairy left
[03:27] *** aborazmeh left
[03:28] *** ShimmerFairy joined
[03:29] *** cognominal left
[03:33] <ShimmerFairy> m: my $a = (0..1).pick; say "ABC" ~~ m:i($a)/abc/

[03:33] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/WTvFeq097u␤Adverb i value must be known at compile time␤at /tmp/WTvFeq097u:1␤------> 3y $a = (0..1).pick; say "ABC" ~~ m:i($a)7⏏5/abc/␤»

[03:33] <ShimmerFairy> huh

[03:34] <ShimmerFairy> Well, considering non-deterministic parsing is explicitly possible, I don't see why the :i adverb and others like it have to be compile-time

[03:36] <ShimmerFairy> m: my $a = "a {(":i","").pick} b"; say "aB" ~~ /<$a>/

[03:36] <camelia> rakudo-moar f185e0: OUTPUT«Nil␤»

[03:36] <ShimmerFairy> m: my $a = "a {(":i","").pick} b"; say "aB" ~~ /<$a>/

[03:36] <camelia> rakudo-moar f185e0: OUTPUT«｢aB｣␤»

[03:36] <ShimmerFairy> seems to me rakudo complaining about :i($a) is perhaps unnecessary, considering the other randomized ways I've been able to introduce the :i adverb :)

[03:40] *** cognominal joined
[03:43] <skids> Whenever you use <$a> you're performing something akin to an EVAL, and that's got its own compile time.  But if you have an rx from another file, there's no way to add :i o it -- it does not come with source code.

[03:47] *** llfourn joined
[03:52] *** skids left
[03:52] <ShimmerFairy> skids: The way I see it, either we lift the compile-time restriction on :i and friends (since I still don't see how it's ~so impossible~ otherwise), or we disallow using them as m:i//, and force them in m/:i/ , so that the distinction between types of adverbs is clear.

[03:52] *** llfourn left
[03:53] *** ChoHag joined
[03:55] *** Norelec joined
[04:08] <masak> morning, #perl6

[04:08] <yoleaux> 12 Aug 2015 08:42Z <laben> masak: could you please accept the two PR for masak/ufo? it would make my life much easier, thanks :)

[04:09] <ShimmerFairy> o/ masak

[04:10] <masak> laben: merged.

[04:14] <masak> I gather I have some catching-up to do.

[04:14] *** khw left
[04:16] *** skids joined
[04:16] *** llfourn joined
[04:17] *** inokenty left
[04:18] <skids> I don't see how whether soething goes inside or outside the // has a bearing on whether it is compile-time-only.

[04:18] *** aborazmeh joined
[04:18] *** aborazmeh left
[04:18] *** aborazmeh joined
[04:18] *** mr-foobar left
[04:19] <skids> NM, I see that is the distinction in fact, rereading the specs.

[04:20] <skids> But I don't think removing m:i does anyone any good.

[04:20] <ShimmerFairy> skids: the issue is that not _everything_ that goes m:HERE// can be given as .match(:HERE), so if there's no way to make, say, .match(:i) work, I'd rather we had a more easily-understood usage of adverbs.

[04:21] <masak> the technical problem is, I think, that the :i gets compiled into the regex.

[04:21] <masak> (sorry if this is stating the obvious. I was backlogging what was on my screen.)

[04:22] <skids> Well, I don't see the need for consistency there.

[04:22] <skids> And m:i// is something P5 users are going to want.

[04:22] <ShimmerFairy> I've never really had a good understanding of which adverbs can and can't go inside the regex, so perhaps forcing the ones that get compiled into the regex to be, well, in the regex would help others there :)

[04:22] <masak> I do think there's some kind of difference between, say, :i and :g

[04:22] <ShimmerFairy> skids: I think P5 users really want m//i though :P

[04:23] <masak> :i talks about how to perform the string matching itself. :g only talks about how many times, which is a lot more external.

[04:24] <ShimmerFairy> I just think it's very unfortunate that someone can use m:g:i// (for example), then discover the match method and then see that  .match(//, :g, :i)  doesn't work as expected.

[04:25] <skids> I think people are more likely to do .match(rx:i//) anyway.

[04:25] <ChoHag> :i determines what is matched with, :g what is matched against.

[04:25] <ShimmerFairy> (and then you have to learn that you either need to do rx:i// or /:i / for the method form. Oh, but don't try rx:g// or /:g /)

[04:25] <masak> ChoHag: yes, that's what I wanted to express.

[04:25] <masak> ChoHag: kind of a client-server distinction, almost.

[04:26] <ShimmerFairy> skids: I don't think so. I've never used rx myself, and whenever I see someone use it my first reaction is "that's not P6 enough", because of how much I don't see it :)

[04:26] <ChoHag> Or: :i affects what the regex is, :g how to use it.

[04:27] <ShimmerFairy> I don't disagree with the difference between :i adverbs and :g adverbs, just that if the difference cannot be reconciled enough to allow .match(..., :i), then I'd like it if they didn't act like it for the m// form either

[04:27] *** shmibs_ is now known as shmibs

[04:27] <ShimmerFairy> (in other words, since :i affects the regex itself, it should be inside the regex)

[04:28] <masak> ShimmerFairy: I.. don't see how making things more inconvenient just for the sake of consistency is a good idea.

[04:28] <skids> Well, we'll have to agree to disagree.

[04:28] <masak> ShimmerFairy: m:i// in my mind is identical to m/ :i /

[04:28] <ShimmerFairy> masak: yeah, I realize it wouldn't be a good move (I'd prefer making .match(:i) work if for consistency) :)

[04:29] <ShimmerFairy> masak: then why shouldn't .match(/:i/) be identical to .match(//, :i) ? :P

[04:29] <masak> ShimmerFairy: I would advise that at this point, you spend tuits on preparing a patch (in a branch or a PR) making things better in the way you envision.

[04:30] <masak> ShimmerFairy: because the adverbs to a regex are different than the adverbs to a .match?

[04:30] <masak> ShimmerFairy: seems pretty obvious to me.

[04:30] <ShimmerFairy> masak: sure, but the distinction is muddled when it comes to adverbs m:HERE//

[04:30] <masak> well, I don't.

[04:30] <masak> think so*

[04:31] <ShimmerFairy> Like I said, I've never had a clear understanding of what adverbs can go inside and which ones must go outside, and I surely can't/won't be the only one.

[04:32] <ShimmerFairy> I just think it's supremely unfortunate that adverbs that can go m:HERE// can't automatically go .match(//, :HERE)

[04:32] <ChoHag> Isn't m/.../ just a fancy way of saying match(compile-rx('...'))?

[04:32] <masak> ShimmerFairy: I suspect you'll learn a lot about it in preparing the patch :)

[04:32] <masak> ChoHag: I think so, yes.

[04:33] <masak> ChoHag: and compile-rx('...') can be written /.../, unless you accidentally boolify the /.../

[04:33] <ChoHag> So adverbs m:HERE// affect match() and compile-rx(), the latter of which may ignore them if they don't make sense in its context?

[04:33] <ShimmerFairy> masak: yeah, I'd likely want to make the fix myself sometime. :)  If we were still in the early days, I'd seriously suggest disallowing m:i//, and only allowing m/:i /, so that the distinction between kinds of adverbs was clear

[04:34] <ChoHag> So are there any adverbs which must be m/:HERE/ but can't be m:HERE//?

[04:34] *** BenGoldberg left
[04:34] <skids> Well, .match(//,:i) might be doable as a macro :-)

[04:34] *** inokenty joined
[04:35] <ShimmerFairy> ChoHag: more an issue for  m:HERE// not always possible rx:HERE//

[04:35] <ChoHag> rx// being the 'compile-rx' part?

[04:36] <ShimmerFairy> (some adverbs like :g can't be applied to the regex, so rx:HERE// or /:HERE / will complain)

[04:37] <ShimmerFairy> My issues stems from the fact that e.g. m:i/<stuff>/ is an alternate form of m/:i <stuff>/, but .match(/<stuff>/, :i) doesn't do the same.

[04:38] <skids> Really that adverb slot on match is there for |%thistime use.

[04:40] <skids> There's no other reason to even have it.

[04:40] <ShimmerFairy> which adverb slot?

[04:40] <skids> The whole reason for accepting adverbs on .match at all.

[04:41] <ShimmerFairy> skids: but if you got rid of that, how can .match be passed :g ?

[04:41] <skids> It wouldn't.  But it's not a necessary method to even have.

[04:42] <skids> (unless you want |%thistime type stuff)

[04:42] <masak> ShimmerFairy: from my point of view, disallowing m:i// is weird because it's just a convenient shorthand for m/ :i /

[04:42] <ShimmerFairy> I would very much disagree. How else would you match a generic  my Regex $rx  ?

[04:42] <ShimmerFairy> (disagree to skids)

[04:42] <skids> "string" ~~ $rx

[04:43] <ShimmerFairy> Sure, there's m:g/<$rx>/ , but that has got to be inefficient

[04:44] <ShimmerFairy> masak: yeah, like I said I wouldn't seriously suggest it by now :)  My issue lies more with letting .match accept more adverbs that can show up m:HERE// , if feasible :)

[04:45] *** cognominal left
[04:48] <skids> Well, if we want to support "is parsed" on method arglists maybe someday.

[04:50] <skids> but then you would need to know the invocant type at compile time.

[04:54] <skids> (and it still would not work on $rx)

[04:56] <ShimmerFairy> Well, .match and friends certainly won't be going away, they're useful alternatives to topicalizing the string you want to match :)  (and, for me, .trans makes infinitely more sense as a method than whatever tr/// syntax is like)

[04:56] <skids> I don't want .match to go away, it's a useful convenience.

[04:58] <skids>  just don't see the big deal when theres the recourse of .match(rx:i//, :g)

[04:59] <ShimmerFairy> skids: of course, I'm just saying that I'd like it if stuff that goes m:HERE// could always go .match(//, :HERE)    :)

[04:59] <skids> I know you've said it several times already :-)

[05:01] <ShimmerFairy> If things like :i can't be reasonably supported in .match, then I'd be fine. I'd just appreciate a bit more of a straightforward conversion from m// to .match if possible :)

[05:03] <ShimmerFairy> And if support is not possible, then warnings/errors in .match for impossible adverbs would be nice :)  (in fact, that might be a reasonable thing to implement now, regardless)

[05:05] <skids> BTW, when $rx is of Regex there's no real reason for /<$rx>/ to be especially inefficient, it's when $rx is Str that chews things up.

[05:06] <skids> I don't think there will be much support for hacking off m:i//

[05:13] <skids> m: my Regex $r = rx/Ab/; { say $_ ~~ m:i/<$r>/ } for "Ab", "ab";  # because the :i is lexical to the rx.

[05:13] <camelia> rakudo-moar f185e0: OUTPUT«｢Ab｣␤False␤»

[05:16] *** Norelec left
[05:17] *** [Sno] left
[05:19] <ShimmerFairy> skids: on the one hand that's surprising, since in that example I kinda expected :i to persist through subrule calls (like it were setting state), but I can immediately see why regex rules need control over their operating conditions :)

[05:21] <skids> Anyway, I have dieseled on way past my bedtime.

[05:22] *** skids left
[05:25] <ShimmerFairy> masak: btw, I think the most interesting to happen since you were last here was the beginning of rakudo/glr :)

[05:28] *** baest_ is now known as baest

[05:53] <Sgeo> Does information only go from regex -> action, or can there be action -> back to same regex communication?

[05:54] <ShimmerFairy> I think dynamic variables may allow communication the other way

[05:55] <Sgeo> I think I'd need to see an example

[05:56] *** diana_olhovik joined
[05:57] <Sgeo> Hmm I think the way Racket does dynamic variables is interesting: http://docs.racket-lang.org/guide/parameterize.html

[05:58] <Sgeo> A dynamic variable cell, so to speak, gets stored in a lexically scoped variable, so functions that refer to it always refer to the correct cell, rather than it being name based

[05:58] <Sgeo> So less of a risk of false positives as described https://perl6advent.wordpress.com/2012/12/20/day-20-dynamic-variables-and-dsl-y-things/#comment-2054

[05:58] <Sgeo> "(i.e. someone else declares a dynamical with the same name, causing the inner sub to think it’s in the outer when it isn’t). But this risk is inherent in this use of dynamicals, not in the error munging."

[05:59] <ShimmerFairy> m: grammar G { token TOP { :my $*A = 1; <subrule> [<?{$*A}> <subrule>||b] }; token subrule { a } }; class C { method subrule($/) { $*A = 0 } }; say G.parse("aa", :actions(C)); say G.parse("ab", :actions(C))

[05:59] <camelia> rakudo-moar f185e0: OUTPUT«(Any)␤｢ab｣␤ subrule => ｢a｣␤»

[06:03] <Sgeo> I don't think I understand enough to actually process that, but the gist of it is a regex defines a dynamic variable, then the action gets run in the dynamic scope of that regex and so can set that same dynamic variable, then the regex proceeds to continue to use it?

[06:04] <ShimmerFairy> yep

[06:05] <ShimmerFairy> It's the dynamic equivalent of  my $a = 42; { $a = 5 }; say $a  (says 5)

[06:09] *** rurban joined
[06:11] <arnsholt> my $*a

[06:12] <arnsholt> m: sub foo { my $*a; bar; say $*a }; sub bar { $*a = 5 }; foo # Should do the trick

[06:12] <camelia> rakudo-moar f185e0: OUTPUT«5␤»

[06:12] *** jack_rabbit_ joined
[06:12] *** telex left
[06:13] <arnsholt> Sgeo: There's a fair number of examples of that pattern in the NQP and Rakudo grammars

[06:13] <arnsholt> That's NQP code, so slightly different in that it uses := instead of = and such, but the pattern is the same

[06:14] *** jack_rabbit_ left
[06:14] *** telex joined
[06:14] *** rurban_ joined
[06:16] <ShimmerFairy> Yeah, the NQP and Rakudo grammars show the real utility of dynamic variables :) (because those declared variables are local to their declaration (so, they aren't global vars), but can be accessed by subrules and their associated action methods)

[06:17] <Sgeo> I kind of want to make a unit that consists of a grammer+action, composable ala monadic parsing

[06:17] <Sgeo> Which is mostly my main point of reference

[06:17] <Sgeo> But I should learn more about grammars and actions first

[06:21] <raydiak> I was always confused by the extensive use of dynamics in rakudo...isn't it bad practice to be passing stuff around "invisibly" in the dynamic scope instead of directly as arguments?  seems like the same design smell you get from over-using globals

[06:22] <ShimmerFairy> you can't really call action methods from the grammar, unless you were willing to do it for every rule yourself (AFAIK)

[06:24] <ShimmerFairy> and also, arguments means you have to be conscious of everything a subrule/action method wants all the time, which would add a lot of noise to language grammars. (A lot of scalar dynvars are just "if I exist" type things, which would at best be replaced with nameds)

[06:26] *** laben joined
[06:26] <raydiak> I was given to understand that the usual way to pass data to the action was via the Match object (which also feels weird to me), but could just be an artifact of my usual confusion :)

[06:26] <laben> hello p6'ers

[06:26] <raydiak> \o

[06:26] <ShimmerFairy> Finally, the main problem with globals, as I understand, is when they pollute the space of used variable names and make all kinds of code fragile. In a contained space I don't think they're so bad (and even end up being one of the nicest solutions). So even if dynvars are global-like in some cases, in the contained space of a grammar it's quite alright by me :)

[06:28] <laben> masak: thanks for updating ufo, i really appreciate that. btw, if you are interested, i got a patch to fix Text::Markdown breakage

[06:28] <raydiak> thanks ShimmerFairy, I at least have a better grasp on the reasoning now

[06:30] <masak> laben: I'm interested.

[06:30] <masak> laben: though I'm also working on a brand new lineage of Text::Markdown.

[06:31] <ShimmerFairy> raydiak: it took me a while to really understand dynamic vars, but once I understood what they did and everything, they suddenly become really useful where you need them :)

[06:31] <laben> masak: here it is, https://gist.github.com/ac0b788fac4e35f178be

[06:32] <ShimmerFairy> raydiak: another example of "constrained globals" I can think of would be 'static' variables in C and C++ (where they're limited to the current translation unit). Static globals are more convenient than insistently passing things around as args in some cases, I'd imagine :)

[06:36] <raydiak> sure

[06:37] <raydiak> I guess I'm just recalling how much harder it made it to read and learn those parts of rakudo's internals

[06:38] <ShimmerFairy> raydiak: like I said, it took me a long time to understand what dynamic scoping was, so for some time I had some trouble understanding why the * twigil was necessary (since for all I could tell they were practically the same as $normal vars (they aren't))  :)

[06:39] *** hurricane left
[06:42] <raydiak> I have, or at least feel like I have, a pretty decent understaind of their semantics...but until you know what $*W actually *is*, it's clear as mud, and the way I'd usually try to figure that out is by looking at where it's declared, but that can be very far removed from where it is being used

[06:42] <raydiak> is that a problem unique to dynamics?  no, not really...they just kinda make it worse

[06:48] *** virtualsue joined
[06:48] <raydiak> anyway, I'm certainly not advocating for a change...just educating myself :)  it definitely does save some typing

[06:50] *** espadrine joined
[06:51] <raydiak> also nice that we have the * twigil so dynamics don't trample ordinary vars, and the reader gets a warning that something unusual is going on even if they don't know what it means

[06:52] *** zakharyas joined
[06:56] *** RabidGravy joined
[06:56] *** virtualsue left
[06:59] <raydiak> well I just dropped in to chat for a minute since I don't have the time I used to...I still miss you, #perl6!  g'night \o

[07:01] <ShimmerFairy> ♞ raydiak o/

[07:01] <ShimmerFairy> raydiak: and yes, I agree that it's nice to have a visual indicator of something special. Even when I thought they were "basically just lexicals", I knew there had to be _something_ different about them I wasn't getting :)

[07:06] *** rindolf joined
[07:06] *** domidumont joined
[07:07] *** cognominal joined
[07:08] <masak> I find a nice way to think of *-twigil variables is that instead of a certain lexical scope, they are tied to a *process*.

[07:09] <masak> like, when I traverse a nested data structure, there might be several subs/methods involved to traverse it, each with its own lexical scope.

[07:09] <masak> but if I want to share data between those, a contextual will do that for me.

[07:10] <masak> it can always be replaced by painstakingly passing the same data in as parameters... but somehow those parameters tend to feel "secondary" or "auxiliary" to the call.

[07:11] *** domidumont left
[07:11] <ShimmerFairy> Now that I think about it, I wonder if my typical use of a $level parameter in a recursive function (for debugging and such) could be nicely done as a dynvar :)

[07:11] *** domidumont joined
[07:12] <ShimmerFairy> masak: whenever parameters are being passed around purely for the sake of keeping things local, I tend to think of that as a bit of a design smell (and inconvenient). I think Perl 6's dynvars let you avoid having to jump immediately to global variables in that situation.

[07:14] <ShimmerFairy> I think the fact that they're also known as "contextual" variables reveals what their purpose is: to be an easy way of providing the appropriate context for things during execution.

[07:16] *** brrt joined
[07:19] *** baest left
[07:19] *** baest joined
[07:22] *** [Sno] joined
[07:34] *** FROGGS joined
[07:49] <masak> all that is correct, but note that dynvars/contextuals also introduce a potential contamination risk from third-party routines (such as callbacks) in the call chain.

[07:50] <masak> either accidental or malicious/deliberately hacky.

[07:52] <ShimmerFairy> I suppose in that case you would want to save the important values in some local vars before using a callback, and then restore them if necessary.

[07:52] *** AlexDaniel joined
[07:54] <masak> yes, but any such manual handling defeats the original savings of having a contextual in the first place.

[07:54] <masak> also, it's suddenly something you have to remember to do.

[07:54] *** rindolf left
[07:56] <ShimmerFairy> Yeah, I think some nice way of isolating a callback would be nice.   .oO(  sub foo(&callback is quarantined) { ... }  )

[07:56] <masak> easier just to "assume that third-party doesn't know about the contextuals" (security through obscurity) or "implicitly trust third party" (this mistake doesn't have a name, but it can definitely bite you)

[07:56] <masak> m: sub traverse($root) { my $*level = 0; handle($root) }; sub handle($node) { say "handling node at level $*level"; $*level++; handle($_) for @$node; $*level-- }; traverse [ [[], []], [] ]

[07:56] <camelia> rakudo-moar f185e0: OUTPUT«handling node at level 0␤handling node at level 1␤handling node at level 2␤handling node at level 2␤handling node at level 1␤»

[07:57] <ShimmerFairy> Certainly would be something for S23 to cover, methinks :)

[07:58] *** abraxxa joined
[07:58] <masak> m: sub traverse($root, &*cb) { my $*level = 0; handle($root) }; sub handle($node) { &*cb($node); $*level++; handle($_) for @$node; $*level-- }; traverse [ [[], []], [] ], sub ($node) { say "handling node at level $*level" }

[07:58] <camelia> rakudo-moar f185e0: OUTPUT«handling node at level 0␤handling node at level 1␤handling node at level 2␤handling node at level 2␤handling node at level 1␤»

[07:59] <masak> m: sub traverse($root, &*cb) { my $*level = 0; handle($root) }; sub handle($node) { &*cb($node); $*level++; handle($_) for @$node; $*level-- }; traverse [ [[], []], [] ], sub ($node) { say "handling node at level $*level"; $*level = 47 }

[07:59] <camelia> rakudo-moar f185e0: OUTPUT«handling node at level 0␤handling node at level 48␤handling node at level 48␤handling node at level 47␤handling node at level 46␤»

[08:00] <masak> silly example, but shows the possibility.

[08:06] *** aborazmeh left
[08:07] <masak> I can see two solutions. one is to namespace your contextuals.

[08:08] *** notch left
[08:08] <TimToady> setting $*TABSTOP makes no sense for something that has to be known at compile time to handle heredocs

[08:09] * RabidGravy sends mail to p5p for the first time in about a year

[08:09] <masak> m: sub traverse($root, &*Traversal::cb) { my $*Traversal::level = 0; handle($root) }; sub handle($node) { &*Traversal::cb($node); $*Traversal::level++; handle($_) for @$node; $*Traversal::level-- }; traverse [ [[], []], [] ], sub ($node) { say "handling node at level $*Traversal::level" }

[08:09] <camelia> rakudo-moar f185e0: OUTPUT«Dynamic variable $*level not found␤  in sub traverse at /tmp/0plceBjwdu:1␤  in block <unit> at /tmp/0plceBjwdu:1␤␤Actually thrown at:␤  in any  at src/gen/m-Metamodel.nqp:2867␤  in sub traverse at /tmp/0plceBjwdu:1␤  in block <unit> at /tmp/0…»

[08:09] <TimToady> and I see no reason to forbid setting $?LINE or $?FILE either, since a preprocessor might well want to set those

[08:09] <masak> it seems to parse just fine, but then it doesn't work at runtime. and it doesn't preserve the namespace in the error message either.

[08:09] *** domidumont left
[08:10] <TimToady> we just got soaked to the skin in a cloudburst here in Kyoto, -Ofun :)

[08:10] <masak> TimToady: would `$?LINE = 42;` and `BEGIN { $?LINE = 42 }` both work but behave differently?

[08:11] <TimToady> the latter would be scoped to the BEGIN

[08:11] <masak> why? I'm not declaring it.

[08:11] <TimToady> well, except they should really be declared constant

[08:11] <TimToady> or my constant

[08:11] <masak> ok.

[08:11] <ShimmerFairy> yeah, the spec example shows  constant $?TABSTOP = 4

[08:11] *** espadrine left
[08:12] <masak> the other solution I could think of to get safe, encapsulated dynamicals: symbols, a la Lisp and ES6.

[08:12] <TimToady> well, that was before we decided to treat constants like other typish things

[08:12] <masak> I think we're likely-ish to end up with symbols anyway, due to macros...

[08:12] <ShimmerFairy> So $? vars should be compile-time assignable, instead of changing the usefully modifiable ones to $* :)

[08:12] <masak> std: constant FOO = 5

[08:12] <camelia> std 28329a7: OUTPUT«ok 00:00 135m␤»

[08:13] <TimToady> std: constant $?LINE = 42

[08:13] <camelia> std 28329a7: OUTPUT«ok 00:00 136m␤»

[08:13] <laben> m: role R { method M($a, $b) {...} }; class C does R { method M($c) { say $c } }; C.M(42)

[08:13] <camelia> rakudo-moar f185e0: OUTPUT«42␤»

[08:14] <ShimmerFairy> masak: my understanding of macros nowadays is that (in one sense) they're meant to eliminate repetitious syntax, like how functions eliminate repetitious execution. Is that a correct view?

[08:14] <masak> ShimmerFairy: yes, I like that view.

[08:14] * ShimmerFairy really hopes Perl 6 macros will eventually let her finally understand exactly what good macros are for :)

[08:14] <masak> ShimmerFairy: it's not the whole story, but it's a fair part of it.

[08:14] <laben> ShimmerFairy: the problem here is that role composition is after class methods definitions and during composition it checks if a method with that name is installed

[08:14] *** domidumont joined
[08:14] <masak> macros provide syntactic relief.

[08:15] <laben> ShimmerFairy: since it's already there, it just skips to the next

[08:15] <masak> laben: arguably, since they are both onlys, some kind of signature mismatch should be flagged up.

[08:15] <ShimmerFairy> masak: that view comes from using "lexical" macros in C++ because I didn't want to copy-and-paste a wall of text that was just slightly-changing syntax each time

[08:16] <laben> masak: i agree, it would be useful, but what you say is not specced nor implemented

[08:17] <ShimmerFairy> The original question comes from me wanting to stub multi methods in a role so that those specific multis are required, just like stubbed only methods require their implementation.

[08:17] <masak> laben: that is correct.

[08:17] <masak> laben: and "contextual contamination" is so far only a hypothetical worry.

[08:17] <laben> masak: now yesterday i was wondering if it's interesting/useful to spec and implement

[08:18] <laben> masak: what do you mean by "contextual contamination"?

[08:19] <ShimmerFairy> (I get the feeling that macros in any language are where the language says "we can't by-default implement what you want, you have to do it now")

[08:19] <masak> laben: Text::Markdown patch applied. thank you.

[08:19] <ShimmerFairy> Ideally the RoleToClassApplier would check signatures when it comes to stubbed things, and implement the support for multi method stubbing too, perhaps

[08:20] <masak> laben: I mean the thing I just demonstrated above, with the callback.

[08:21] <ShimmerFairy> m: role R { method M($a, $b) { } }; class C does R { method M($c) { } }; say C.M(1,2)  # this is almost certainly wrong

[08:21] <camelia> rakudo-moar f185e0: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in method M at /tmp/rzC29XHd8E:1␤  in block <unit> at /tmp/rzC29XHd8E:1␤␤»

[08:21] <ShimmerFairy> m: class C { method M($a, $b) { }; method M($c) { } }; say C.M(1,2)

[08:22] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/9j7Kqzzv8t␤Package 'C' already has a method 'M' (did you mean to declare a multi-method?)␤at /tmp/9j7Kqzzv8t:1␤»

[08:22] <ShimmerFairy> I'm starting to get the feeling that the RoleToClass applier (and perhaps RoleToRole too) need some improvements :)

[08:26] <laben> ShimmerFairy: as i was saying, no checking of signatures is done for either the only case or the multi case. just the name is checked when composing a role, which is done after a class is defined. since you define the method in the class, it finds the method ans skips to the next

[08:27] <laben> ShimmerFairy: maybe this part should be considered NYI instead of vaguely not specced

[08:27] <ShimmerFairy> yeah, RoleToClass seems to be avoiding handling dispatcher-stuff (at least for multis), so it seems it tries to deal with as little as possible. That's clearly not sufficient, though :)

[08:28] <laben> ShimmerFairy: the trouble consists basically in the amount of code you would need to check signatures there

[08:29] <laben> ShimmerFairy: the code in Signature that does that in BOOTSTRAP is *ginourmous*

[08:29] <laben> it would be much easier if we could reuse somethign from there

[08:30] <laben> there's even an ad hoc implementation of toposort

[08:30] <ShimmerFairy> laben: do you mean Routine? (where I looked at find_best_dispatchee last night)

[08:30] <laben> ShimmerFairy: yeah right, it's not signature

[08:31] *** inokenty left
[08:31] <ShimmerFairy> laben: if we were interested in code reuse, then I'm fairly confident it would have to go Metamodel -> BOOTSTRAP, I'm not sure code can be called the other way :)  (could be wrong, though)

[08:32] <laben> ShimmerFairy: sorry, can you explain a bit more? i'm a noob at this, just started yesterday

[08:32] <laben> you mean BOOSTRAP includes Metamodel?

[08:33] <ShimmerFairy> I don't know if the Metamodel stuff would ever be able to access things defined in BOOTSTRAP, so the code to be reused would have to live in Metamodel and be called by BOOTSTRAP, not the other way.

[08:34] <ShimmerFairy> laben: the metamodel defines how Perl 6 objects work underneath, while BOOTSTRAP makes Perl 6 objects as much as is necessary for the earliest stages of the compiler

[08:34] <laben> ShimmerFairy: we dont need to call it in BOOTSTRAP, but in Metamodel

[08:34] <laben> suppose we add a method to Routine which compares signatures

[08:35] <laben> we just need to call it in RoleToClass composer to make that feature work

[08:35] <laben> maybe it could stay in Signature, but alas, that's not the problem

[08:37] <laben> it's that the code to compare compatibility and narrowedness (?) between signatures is splat inside analize_dispatch, find_best_dispatchee and !sort_dispatchees_internal (not sure of last name)

[08:37] <ShimmerFairy> I think the biggest hurdle in comparison is that 'eqv' is too strict, and ~~ is too permissive:

[08:37] <ShimmerFairy> m: sub foo($a, $b) { }; sub bar($c, $d) { }; say &foo.signature eqv &bar.signature; # too strict

[08:37] <camelia> rakudo-moar f185e0: OUTPUT«False␤»

[08:37] <ShimmerFairy> m: sub foo($a, $b) { }; sub bar($c, $d?) { }; say &foo.signature ~~ &bar.signature; # too permissive

[08:37] <camelia> rakudo-moar f185e0: OUTPUT«True␤»

[08:38] <laben> m: sub foo($a, $b) { }; sub bar($c, $d?, $e?) { }; say &foo.signature ~~ &bar.signature;

[08:38] <camelia> rakudo-moar f185e0: OUTPUT«True␤»

[08:38] <laben> can we even use smartmatch inside RoleToClass.nqp?

[08:39] <ShimmerFairy> I don't think we need all the multi dispatcher code anyway; in this case we want exact signature matches, not the best, which is likely easier to go for :)

[08:39] *** bjz joined
[08:40] <ShimmerFairy> wow, I suspect ~~ isn't defined for Signatures at all.

[08:40] <laben> m: sub rolesub(Int $a, Int $b) {}; sub classsub($a, $b) {}; say &rolesub.signature ~~ &bar.signature;

[08:40] <camelia> rakudo-moar f185e0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HQ_4JLQ5rf␤Undeclared routine:␤    &bar used at line 1. Did you mean '&bag'?␤␤»

[08:40] <laben> m: sub rolesub(Int $a, Int $b) {}; sub classsub($a, $b) {}; say &rolesub.signature ~~ &classsub.signature;

[08:40] <camelia> rakudo-moar f185e0: OUTPUT«True␤»

[08:41] *** darutoko joined
[08:41] <laben> ShimmerFairy: i dont think we must go for exact, but for equal-narrow or narrower

[08:41] <ShimmerFairy> oh, it is, it's just really, really permissive I think

[08:42] <laben> ShimmerFairy: consider a role method with ($a, $b) and the role class with (Int $a, Int $b)

[08:42] <ShimmerFairy> For stubbed methods at least, you want to be sure you're implementing the right thing.  method foo(Int $a) { }  might cover some cases of  method foo(Num $a) { ... } , but not all of them

[08:42] <ShimmerFairy> And in the inverse, the non-stubbed would be covering too much

[08:44] <laben> but what if the class doing the implementation is not interested in the other Num-but-not-Int cases?

[08:49] <ShimmerFairy> too bad, the point of an interface is to guarantee behavior. If an interface guarantees you can use Num arguments with something, the class doing the interface has to use them.

[08:50] <ShimmerFairy> You can't implement half of a standard and still claim you're standards-compliant, after all :)

[08:50] <laben> mh, ok, i guess it sound reasonable

[08:51] <TimToady> m: sub foo($a, $b) { }; sub bar($c, $d?, $e?) { }; say &foo.signature ~~ &bar.signature && &bar.signature ~~ &foo.signature

[08:51] <camelia> rakudo-moar f185e0: OUTPUT«False␤»

[08:51] <laben> ~~ not commutative?

[08:51] <ShimmerFairy> nope

[08:51] <laben> how is it even done?

[08:51] <ShimmerFairy> laben: LHS ~~ RHS  is sugar for  RHS.ACCEPTS(LHS)

[08:52] <ShimmerFairy> (or more accurately { $_ = LHS; RHS.ACCEPTS($_) } )

[08:52] <ShimmerFairy> In the example I gave, the class could always check if the Num args can't be considered Ints, and die on that for whatever reason, but I don't think the language should let you get away with that without extra work :)

[08:56] <ShimmerFairy> In my mind, roles should generally consist of "replaceable" (non-stubbed) and "required" (stubbed) methods. In either case, only providing the same signature would be sufficient to replace or implement the method, since exact signature is the closest you can get to the doing class/role promising the right behavior.

[08:58] <ShimmerFairy> In a sense, you could probably think of non-stubbed role methods as stubbed roles with a default value, à la parameters with a default. I wonder if that's a sufficiently useful viewpoint.

[08:58] *** cibs_ joined
[08:59] <laben> that is with only methods. with multis, if a role has method(Num, Num), i should be able to define a class with method(Int,Int) and method(Num,Num) to cover the rest

[09:00] *** espadrine joined
[09:00] <laben> btw if i understand correctly, even if a role defines a only method, in a class i can always force it to be multi by defining a proto

[09:01] <ShimmerFairy> laben: that's the nice thing about theoretical multi stubs, to me: it says "I need at least these, but you can of course do more"  :)

[09:02] *** cibs left
[09:03] <ShimmerFairy> The only place I see the "exact signature" demand being impossible to meet off-hand would be 'where' constraints; I personally would be fine with trusting the overriding method to be using an equivalent where clause, instead of trying to analyze code :)

[09:05] <ShimmerFairy> (and if an interface role wanted to ensure that those where constraints are exact, they should be using reusable subset types or equivalent anyway)

[09:05] <laben> let's leave alone the forcing multi-ness stuff for now. we cant accept only strictly equal for multi methods as you could be leaving out intended behaviour from the class

[09:08] <laben> let's say the role has method(Num, Num) and class has method(Int, Int), method(Num, Num) and method(Str, Str). iiuc, the Str one is to be rejected (possibly warning at compile time), but the Num and Int ones are to be accepted

[09:09] <ShimmerFairy> if you're talking multi methods, then in my idea the (Num, Num) multi is required to satisfy the interface requirements, and the others are allowed as extra

[09:10] <ShimmerFairy> laben: when I'm talking about stubbed methods and such, I'm talking about them as requirements, not restrictions :)

[09:14] <ShimmerFairy> e.g. role R { method A { ... }; method B { ... }; method C { A() + B() } }  needs A and B to be implemented so that C can do something useful. By no means does role R limit what methods a class can have, it only requires certain things upon saying you want to do the role.

[09:17] <laben> m: role R { method m($a, $b) {*} }; class C does R { }; C.m(1,2)

[09:17] <camelia> rakudo-moar f185e0: ( no output )

[09:18] <laben> m: role R { method m($a, $b) {...} }; class C does R { }; C.m(1,2)

[09:18] <camelia> rakudo-moar f185e0: OUTPUT«===SORRY!===␤Method 'm' must be implemented by C because it is required by a role␤»

[09:21] <laben> ShimmerFairy: basically in my example, you would accept even the Str one, but error out if there was no Num one, right?

[09:21] <ShimmerFairy> yes

[09:22] <ShimmerFairy> In a world of only 'only' methods, you're allow to declare more 'only' methods past the ones the role requires by stubbing them

[09:22] <ShimmerFairy> When you start considering 'multi' methods, I think it's logical that you're allowed to declare more multis on a name past the multis the role requires :)

[09:23] *** pragma- joined
[09:23] <pragma-> Why is CATCH uppercased?  try { ... } CATCH { ... }

[09:24] <laben> isnt CATCH a phaser instead of a keyword?

[09:24] <pragma-> er, try { ...  CATCH { ... } }  # even more unothordox

[09:25] <arnsholt> Yup. It's a phaser like BEGIN and END

[09:25] <pragma-> I don't know if I can move from Perl5 to Perl6... it's all so weird and different and seemingly wonky at times.

[09:26] <ShimmerFairy> pragma-: It's a phaser, whose names are traditionally uppercased. Phasers are blocks of code executed at specific times. The CATCH phaser, for example, executes when an exception occurs.

[09:26] <laben> pragma-: let me tell you that i dont know if i can move from Python to Perl5... it's all so weird and different and seemingly wonky at times.

[09:27] <jnthn> Note that, as a block trait, CATCH can go in any block, not just try.

[09:27] <yoleaux> 16 Aug 2015 14:35Z <lizmat> jnthn: could you look at the sanity of https://github.com/rakudo/rakudo/commit/9c5d5da13f ?  :-)

[09:27] <yoleaux> 16 Aug 2015 15:15Z <lizmat> jnthn: would it be possible to stick in a flag in the opcode loop that would cause an immediate abort (with stacktrace) if set?  then we could set that from e.g. signal(SIGINT).tap{...} and have a control-C cause a stacktrace on where it is stuck in a loop

[09:27] <yoleaux> 16 Aug 2015 15:20Z <lizmat> jnthn: I notice you're using anonymous classes to build iterators.  With SupplyOperations you chose to use named classes.  Is there a particular reason for either, or is this a case of progressing insight?

[09:28] <ShimmerFairy> pragma-: another particularly nice example of phasers is using the BEGIN phaser in calculating how long something takes:

[09:28] <brrt> lizmat: that would be a huge, fascinating pain for the JIT

[09:28] <ShimmerFairy> m: for ^1000 { $_ * $_ }; say now - BEGIN { now }

[09:28] <camelia> rakudo-moar f185e0: OUTPUT«0.01463968␤»

[09:29] <brrt> .tell lizmat an immediate abort flag would be a huge pain for JIT compilation

[09:29] <yoleaux> brrt: I'll pass your message to lizmat.

[09:29] <JimmyZ> I guess just ctrl+c and use MVM_dump_backstrace(tc) is OK  ?

[09:29] <JimmyZ> in GDB 

[09:33] <JimmyZ> I meant MVM_dump_backtrace(tc) 

[09:33] <jnthn> .tell lizmat Re 9c5d5da1, I'm not sure if that deserves an extra entry in the interator API or not; after all, you could just do push-all and pass an object that, when you call .push on it, increments a counter... 

[09:33] <yoleaux> jnthn: I'll pass your message to lizmat.

[09:37] <jnthn> .tell lizmat It really hinges on if there are more use cases than Seq.elems really

[09:37] <yoleaux> jnthn: I'll pass your message to lizmat.

[09:37] *** dayangkun left
[09:45] <RabidGravy> Hmm, if I'm over-riding add_method in some MOP shenanigans, I need to do similar to add_multi_method as well I guess

[09:46] *** FROGGS_ joined
[09:49] *** FROGGS left
[09:54] *** brrt left
[10:03] *** laouji left
[10:04] *** nowan left
[10:06] *** rindolf joined
[10:06] *** lviatlantis joined
[10:07] *** nowan joined
[10:07] *** |Tux| left
[10:09] *** lviatlantis left
[10:12] *** laouji joined
[10:13] *** |Tux| joined
[10:33] *** TEttinger left
[10:49] *** rurban left
[10:50] *** RabidGravy left
[10:50] *** inokenty joined
[10:51] *** LonelyGM joined
[10:52] *** laouji left
[10:52] *** LonelyGM left
[10:52] *** LonelyGM joined
[10:52] *** LonelyGM left
[10:52] *** LonelyGM joined
[10:53] *** laouji joined
[10:54] *** LonelyGM left
[10:55] *** mls_ is now known as mls

[10:57] *** rurban_ left
[10:58] *** virtualsue joined
[11:10] *** rurban_ joined
[11:11] *** rurban joined
[11:17] *** RabidGravy joined
[11:26] <lizmat> computer, messages!

[11:26] <yoleaux> 09:29Z <brrt> lizmat: an immediate abort flag would be a huge pain for JIT compilation

[11:26] <yoleaux> 09:33Z <jnthn> lizmat: Re 9c5d5da1, I'm not sure if that deserves an extra entry in the interator API or not; after all, you could just do push-all and pass an object that, when you call .push on it, increments a counter...

[11:26] <yoleaux> 09:37Z <jnthn> lizmat: It really hinges on if there are more use cases than Seq.elems really

[11:26] <lizmat> brrt jnthn: what I want to achieve, is a way from a signal tap to have all threads abort with a stack trace

[11:27] <lizmat> if there's another way to do that, then yes!  :-)

[11:28] <tadzik> :)

[11:30] <jnthn> lizmat: You really need VM co-operation for such things.

[11:30] <jnthn> And it's not quite trivial :)

[11:30] <jnthn> But certainly do-able

[11:30] <lizmat> yeah, I figured, hence my suggestion  :-)

[11:31] <jnthn> On Moar, signals are received by a dedicated event loop thread that is never tied up with code execution.

[11:32] <jnthn> Provided there's a free thread pool thread, it can then have a signal handler run there

[11:32] <jnthn> (And most hangs won't tie up the whole thread pool, and even if we have *that* issue we can create a 1-thread pool that is simply dedicated to this handler)

[11:32] <jnthn> All that we can do already

[11:33] <jnthn> So the only really interesting missing piece is a way to ask for stack traces for all running threads.

[11:33] *** andreoss joined
[11:34] <lizmat> :-)

[11:34] <lizmat> confess(:all)

[11:35] *** dayangkun joined
[11:37] <jnthn> That'll take a little care to implement 'cus I can imagine a few different data races already if you do it the naive way :)

[11:38] *** Ven joined
[11:39] *** dayangkun left
[11:40] *** awwaiid joined
[11:46] *** inokenty left
[11:53] *** Ven left
[11:55] *** bioexpress joined
[12:00] <bioexpress> Hi, could the unexpected behavior described in http://stackoverflow.com/questions/31958891/perl6-getc-in-raw-mode be due to a bug in `getc`?

[12:01] *** Ven joined
[12:04] <JimmyZ> bioexpress: It'd be nice to file a bug to RT

[12:06] *** bioexpress left
[12:07] *** bioexpress joined
[12:08] *** bioexpress left
[12:11] *** domidumont left
[12:12] *** domidumont joined
[12:21] <tadzik> hmm, closing github issues has an icon that looks like I rejected the report

[12:21] <tadzik> (https://github.com/tadzik/panda/issues/195)

[12:22] <tadzik> very weird

[12:22] <DrForr> It's marked as 'closed' in the interface which is all that really matters :)

[12:22] *** abraxxa left
[12:23] *** abraxxa joined
[12:25] *** domidumont left
[12:26] *** rurban left
[12:26] *** laouji left
[12:27] <tadzik> yeah, but I saw the red screaming icon and thought "oh, now it looks like it's not being fixed at all"

[12:28] *** mr-foobar joined
[12:28] *** domidumont joined
[12:30] *** brrt joined
[12:33] *** rurban joined
[12:34] <tadzik> hoelzro: ping

[12:34] <tadzik> hoelzro: remind me to talk to you about 26bc9022e470ac2d18396b3ce8e5e3dc45a23b5e :)

[12:35] *** luiz_lha joined
[12:35] <brrt> yeah, what jnthn said was basically my intuition too. quite a few runtime already provide this, btw

[12:36] <brrt> e.g go

[12:36] <brrt> java

[12:39] <[Coke]> reminder, if you're going to the swiss perl workshop, put your name on this list: http://act.perl-workshop.ch/spw2015/wiki?node=HackathonAttendees

[12:44] <DrForr> Hrm, I'll be in Switzerland for a few hours :)

[12:45] <hoelzro> tadzik: pong

[12:45] <hoelzro> also, good morning #perl6

[12:45] <DrForr> Just before YAPC::EU? That would ordinarily be great timing for me...

[12:48] *** smls joined
[12:50] <laben> what will be the focus of this hackaton? glr, general bugfixing, ecosystem population effort?

[12:51] *** andreoss left
[12:51] <tadzik> hoelzro: so, I gave Panda a CONTRIBUTING.md in the meantime, but tl;dr: don't bother with backwards compat, just tag a previous panda release with a last rakudo release that doesn't have the required feature :)

[12:51] *** zakharyas left
[12:51] *** zakharyas joined
[12:52] <hoelzro> tadzik: ah, thanks for the heads-up!

[12:53] <tadzik> thanks for the patches!

[12:53] <tadzik> I'm happy every time I look at my code only to realize that it's not just my code anymore :)

[12:55] *** Ven left
[12:56] <jdv79> lizmat: did you do "japan's steepest funicular"?

[12:57] *** llfourn left
[12:59] <[Coke]> m: say so multi pass {}

[12:59] <camelia> rakudo-moar f185e0: OUTPUT«True␤»

[13:00] <hoelzro> =)

[13:00] *** llfourn joined
[13:00] <nine> laben: all of the above? ;)

[13:03] <laben> nine: i take it glr will not be a branch for much longer, right?

[13:07] <[Coke]> laben: I think there's a chance it will land in time for the august compiler release. I think it'll be in by september for sure.

[13:09] <laben> cool, i will need to get up to speed to the behaviour changes quite fast, it seems :)

[13:09] <smls> A 6.0beta in September (as planned by TimToady in January) is probably unrealistric then?

[13:10] <jnthn> I'd like glr in the August release, but the August release doesn't have to be on the X thursday before the Y Tuesday of whatever the rule is.

[13:10] <smls> To be fair, in January it was also planned that the GLR would be finished by April... :P

[13:10] <[Coke]> jnthn: right, that's just historical reasons.

[13:11] <nine> I'd like to see the glr merged in time for the hackathon, but that may be a bit optimistic :)

[13:12] <jnthn> Well, it depends what our merge criteria are, doesn't it? :)

[13:12] <[Coke]> we already know there will be downstream breakage, so I imagine that lightens our requirements slightly.

[13:12] <nine> My module works, I dont see any obstacles to a merge ;)

[13:13] <laben> nine: arent there something like 10 days? a bit too short of a time, unless our core devs can churn out miracles XD

[13:13] *** rmgk_ joined
[13:13] *** rmgk is now known as Guest82090

[13:13] *** Guest82090 left
[13:13] *** rmgk_ is now known as rmgk

[13:13] <jnthn> nine: If we could add "panda works" to the list, that'd be fairly serious amunition to the "go for it"

[13:13] <[Coke]> ... they are in the habit of doing so, yes.

[13:14] <jnthn> Anyway, I'll probably look for ecosystem indicators over spectest indicators, because if Inline::Perl5 can run with 270 spectest files having breakage, well... :)

[13:14] <nine> jnthn: well I wanted to have a look at the meta ops anyway, since that seems to be the first blocker for panda :)

[13:14] <jnthn> nine: Yeah, they are the Next Big Thing really

[13:15] <nine> jnthn: I think Inline::Perl5 works mostly because I just didn't know enough advanced Perl6 features when writing it ;)

[13:15] <tony-o> lol

[13:15] <tadzik> I can work on panda-glr later today probably

[13:15] <tadzik> gotta run now though &

[13:16] <jnthn> nine: That's probably why it performs OK too :P

[13:18] <_itz_> that  "Method gimme not found..." error is that due to that method just not existing in rakudo-glr anymore or is there a deeper reason?

[13:19] <JimmyZ> Not existing anymore

[13:19] <tony-o> no deprecation warnings?

[13:19] <_itz_> so at some point that method gets added rather than the method being replaced by something else?

[13:22] <jnthn> That method isn't coming back

[13:22] <jnthn> It was never intended as public API anyway

[13:22] <jnthn> So no deprecation note

[13:24] * jnthn bbl &

[13:25] *** virtualsue_ joined
[13:26] <jdv79> so the last spectest breakages are the worst?

[13:27] *** virtualsue_ left
[13:28] <tony-o> so judgemental

[13:30] *** virtualsue_ joined
[13:31] <nine> jdv79: we already fixed all the hangs. I would consider those the worst ;)

[13:32] <jdv79> so /s/worst/hardest/ is more what i meant

[13:34] <nine> Well I'm definitely not looking for easiest fixes when picking the next target. Don't know about the others

[13:36] <ShimmerFairy> I think the order tends to go from most general to most specific functionality for these sorts of things :)

[13:38] *** lizmat left
[13:38] *** lizmat_ joined
[13:39] <nine> Or just in order of failing spec tests

[13:42] *** lizmat_ is now known as lizmat

[13:44] <RabidGravy> anyone got any hints as to why the add_multi_method doesn't quite work as expected here:

[13:44] <RabidGravy> m: https://gist.github.com/jonathanstowe/7bba0a218023b9caa5b9

[13:44] <camelia> rakudo-moar f185e0: OUTPUT«adding bar with bar␤adding multi zub with zub␤adding multi zub with zub␤adding zub with zub␤bar!␤Method 'zub' not found for invocant of class 'Foo'␤  in block <unit> at /tmp/Y_adFKuyQk:32␤␤»

[13:45] *** Ven joined
[13:46] <Ven> .tell Sgeo wrt http://irclog.perlgeek.de/perl6/2015-08-17#i_11067252 - I like clojure's namespaced dynamics, what do you think?

[13:46] <yoleaux> Ven: I'll pass your message to Sgeo.

[13:48] <dalek> rakudo/nom: 22c8517 | lizmat++ | t/01-sanity/55-use-trace.t:

[13:48] <dalek> rakudo/nom: Fix test now we don't have an extra NL anymore

[13:48] <dalek> rakudo/nom: 

[13:48] <dalek> rakudo/nom: Which I think FROGGS fixed recently

[13:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/22c8517b47

[13:49] <laben> interesting, you can even point camelia to a gist!

[13:49] <dalek> rakudo/nom: bbcda84 | lizmat++ | t/01-sanity/55-use-trace.t:

[13:49] <dalek> rakudo/nom: Make sure it also works on CRLF systems

[13:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bbcda845be

[13:49] <laben> RabidGravy: what is class Test that is inherited by Foo in your gist?

[13:50] <RabidGravy> laben, it isn't it's a trait

[13:50] <laben> RabidGravy: oops you're right, and it's even right there

[13:51] <RabidGravy> this is part of the reason why I was asking about alternative trait words the other day because it is a little confusing :)

[13:52] *** skids joined
[13:53] <_itz_> is there a GLR bot?

[13:53] <RabidGravy> but the weird thing there is that it works for add_method but not add_multi_method

[13:54] <laben> RabidGravy: did you check the proto auto generation or try to add it manually?

[13:55] *** Ven left
[13:57] <RabidGravy> if I add a proto method zub(|) { * } there it only installs one of the multis

[13:58] *** pmurias joined
[14:00] <nine> _itz_: we can have one as soon as someone tells me how to set it up

[14:03] <ShimmerFairy> We just need someone with access to add a glr: target for camelia :)

[14:03] <nine> I'd rather spen my time implementing glr than figuring out how to set up the bot

[14:03] <nine> I do have access

[14:03] <_itz_> nine: that's probably a better use of time TBH

[14:05] *** khw joined
[14:05] <_itz_> I could probably fire up a quick unofficial one

[14:06] <_itz_> in fact I shall look now

[14:06] <ShimmerFairy> nine: here's its code, with instructions in the README: https://github.com/perl6/evalbot

[14:07] <pyrimidine> _itz_: was gonna say moritz set up the bot but ShimmerFairy beat me to it :)

[14:07] <ugexe> zef works on glr. its glr branch almost works on both nom and glr, and by later today it should

[14:07] <_itz_> oh cool

[14:08] <pyrimidine> was panda working w/ glr?  only problem I had w/bioperl6 was File::Temp

[14:08] <pyrimidine> tried testing using panda but it seemed broken as well

[14:09] *** Ven joined
[14:09] <_itz_> I tried ufo but the for [\~] <1 2 3> {.say} construct is broken

[14:11] <ugexe> does json::tiny work on glr yet? i figured that would be the big stopper there

[14:11] <masak> m: .say for [\~] <1 2 3>

[14:11] <camelia> rakudo-moar f185e0: OUTPUT«1␤12␤123␤»

[14:11] <masak> _itz_: don't look borken to me

[14:11] <_itz_> I mean on GLR

[14:11] <masak> oh

[14:11] * masak should backlog more :)

[14:11] <_itz_> > for [\~] <1 2 3> {.say}

[14:11] <_itz_> Method 'gimme' not found for invocant of class 'Array'

[14:11] <_itz_> I prolly wasn't clear :)

[14:12] <masak> I just finished backlogging p6u. I think we should fix .perl before Christmas.

[14:13] <ShimmerFairy> What's wrong with .perl?

[14:13] *** brrt left
[14:14] <masak> m: my $a = []; $a.push($a); say $a.perl

[14:14] <masak> that's what's wrong with .perl

[14:14] <_itz_> it hangs on many structures

[14:14] <camelia> rakudo-moar f185e0: OUTPUT«(timeout)»

[14:14] <masak> we can't both say "yeah, so Data::Dumper is *built in*, whoa"

[14:14] <masak> and have simple cycles fail.

[14:15] <masak> now, it's trivial to detect and name cyclical references. I've written code like that in the past weeks.

[14:15] <masak> the bigger challenge is to decide how the .perl output should look in such cases.

[14:15] <masak> I don't recall ever hearing a good solution to that.

[14:16] <ShimmerFairy> masak: well, in GLR circular structures are generally discouraged. (IIRC they hang when created, and aren't likely do otherwise)

[14:16] <masak> it needs to be something that, when EVAL'd, yields something that's eqv to the original structure

[14:17] <masak> ShimmerFairy: I don't know what that means, but that's either wrong on the face of it or it needs to change.

[14:17] <ShimmerFairy> stuff like  my @a = 1, @a;  or  @a = @a, @a  , for example

[14:17] <masak> in particular, this problem won't go away just because we say "GLR discourages that"

[14:17] <masak> ShimmerFairy: that's different.

[14:18] <arnsholt> masak: For a second I misparsed that as "That's what's wrong with Perl" =)

[14:18] <masak> arnsholt: :P

[14:19] <arnsholt> Kind of surprised to see you with that kind of negativity, yeah =)

[14:20] <ShimmerFairy> masak: I don't think so, in all those cases you're trying to put the variable inside itself :)

[14:20] <masak> arnsholt: it started in 2008. I wanted to /join #python, but I mistyped. haven't been able to /leave since. :P

[14:20] <arnsholt> =D

[14:21] <masak> ShimmerFairy: I am not good at arguing from the viewpoint of GLR, because I haven't internalized it yet. but in *this* universe, `@a = @a, @a` doesn't create any cycles.

[14:21] *** GLRelia joined
[14:21] <masak> ShimmerFairy: it just evaluates the contents of @a, twice, and stuffs the resulting list back into @a

[14:21] <tadzik> mystyped, right. Just admit it, you saw "NO LOL" and ran away :P

[14:21] <masak> m: my @a = 1, 2, 3; @a = @a, @a; say @a.perl

[14:21] *** GLRelia left
[14:21] <camelia> rakudo-moar f185e0: OUTPUT«[1, 2, 3, 1, 2, 3]<>␤»

[14:21] <masak> ShimmerFairy: like that.

[14:22] <masak> tadzik: NO PROJECT EULER

[14:22] <tadzik> "hello #python, I have a project euler ta... oh, lol, nvm"

[14:22] <ShimmerFairy> masak: all I know is that there was discussion of how @a = @a, @a is silly and of course it's gonna loop, and how TimToady mentioned that  @a = 1, @a  could possibly create an infinite list of 1s  :P

[14:22] <masak> man, it's like the #python channel removed my two major joys in life. a good laugh, and math problems.

[14:23] <laben> ShimmerFairy: i think they referred to @a as a lazy (infinite in non-GLR) list

[14:23] <ShimmerFairy> I've never been to #python, and now it sounds like I don't want to :P

[14:23] <masak> ShimmerFairy: fair enough. even if that's the new semantics, it doesn't mean self-references *go away* post-GLR. if anything, it sounds like they'll be easier to create :P

[14:24] <arnsholt> masak: No fun allowed! You must realize that programming is serious business! =p

[14:24] <masak> ShimmerFairy: you'll be fine on #python, just as long as you don't laugh out loud, or mention 18th-century mathematicians.

[14:24] <ShimmerFairy> masak: sure, but it's also easier to hang on them (rather than only at .perl) :P

[14:24] <masak> arnsholt: there's only one way to do it, and it's joyless, goddammit!

[14:25] <masak> ShimmerFairy: so let's get back to .perl? :)

[14:25] <ShimmerFairy> masak: you should see the question on what the .perl of a Seq is :)  (since a Seq goes through its values once and only once. IIUC the solution is for Seq to clone itself and burn through the clone in making the output string)

[14:26] <masak> sounds fair to me.

[14:26] * laben fades away in the shadow while GLR takes over the world

[14:26] <smls> ➜  ~  perl -e 'use Data::Dump; my @a; @a = (1, \@a); dd @a;'

[14:26] <smls> do {

[14:26] <smls>   my $a = 1;

[14:26] <smls>   my $b = [$a, 'fix'];

[14:26] <smls>   $b->[1] = $b;

[14:27] <smls>   ($a, $b);

[14:27] <smls> }

[14:27] <smls> ^^ masak

[14:27] <smls> though yeah, not exactly pretty.

[14:27] <masak> "pretty" is bonus.

[14:27] <ShimmerFairy> I really want to get to fixing the Pod parser in rakudo, I can't be the only one who finds confusing and messy to try and follow. I just discovered a fun bug where =item1 -> Pod::Item{:level("1")}<> , but =item -> Pod::Item . Welp.

[14:27] <masak> I'd settle for "doesn't hang" and "reproduces the right data structure"

[14:28] <masak> smls: anyway, smls++ for the constructive contribution.

[14:28] <masak> I guess the next question is "what in that bit can't we do?"

[14:28] <masak> ShimmerFairy: the Pos parser certainly needs some more love, yes.

[14:29] <jnthn> .oO( Piece of s... parser??? )

[14:30] <masak> Pod*

[14:30] <ShimmerFairy> masak: after fixing Pod::To::HTML so that it did multi-level lists correctly (but didn't know the =item1/=item thing), I wanted to add ordered list support, but the Pod parser is tangled/compressed enough that making initial # lead to a :numbered config would be more interesting than it should be.

[14:30] <flussence> that bit was written back in the day when rakudo took hours to build and minutes to start up... I can see why it wasn't fully completed :)

[14:31] *** virtualsue_ left
[14:32] <smls> ShimmerFairy: Since we have  =table  blocks for nice ASCII tables, why not  =list  blocks for nice ASCII lists (akin to markdown)?

[14:32] <ShimmerFairy> Yeah, some time soon I want to just start a new branch and toss the existing Pod parser, in favor of something more comprehensible :)

[14:33] <masak> might be a good idea to get the Pod parser to work correctly outside of Rakudo first, and then put it back into the big praser.

[14:33] <masak> I tend to like to work that way (though admittedly with outside/inside core setting rather than the parser)

[14:33] <pmurias> masak: re project euler I would assume that if I was working through project euler having people spoil problems on #perl6 would be pretty annoying

[14:33] <ShimmerFairy> smls: I actually like that idea. Seems sensible for structures beyond paragraphs to have an abbreviated syntax thing

[14:34] <masak> pmurias: yes, that might actually be the reason that ended up in the #python /topic

[14:34] <ShimmerFairy> masak: at 90s of parsing per run of CORE, I'm definitely not going to start off in rakudo/src :P

[14:34] <dalek> nqp/js: 7682c9f | (Pawel Murias)++ | src/vm/js/nqp-runtime/runtime.js:

[14:34] <dalek> nqp/js: When we don't know how to convert to ints/number call Int/Num

[14:34] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/7682c9f3c7

[14:34] <dalek> nqp/js: 53a034a | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[14:34] <dalek> nqp/js: Implement the cclass regex type

[14:34] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/53a034adeb

[14:34] <smls> ShimmerFairy: Also, do you know if parsing formatting codes inside table cells is gonna be supported? I missed it several times while writing p6doc and other stuff.

[14:34] <masak> pmurias: still, it feels like such a difference in attitude somehow.

[14:34] *** mr-foobar left
[14:35] <masak> smls: is it permitted by S26?

[14:35] <ShimmerFairy> smls: I looked at that code once, wanting to support it, and the issue is that you'd have to do Perl6::Grammar.parse($para, :rule<the_right_rule>) for them, or re-implement the grammar.

[14:35] <ShimmerFairy> masak: table cells are implicit C<=para>s, according to spec

[14:36] <pmurias> masak: #perl6 seems to be a much smaller channel so we can get away with tolerating much more things

[14:36] <masak> jnthn: re https://gist.github.com/jnthn/a56fd4a22e7c43080078 -- if you grep for `= whenever`, I think I would like that case to have to be written `= do whenever`.

[14:36] *** mr-foobar joined
[14:36] <masak> jnthn: in analogy with other loop constructs, like `for` and `given`.

[14:36] <ShimmerFairy> The only sane way (I think) would be for the table parsing to happen in the parser (and not in Pod.nqp), but that would involve fun.

[14:37] <masak> pmurias: yes, but why would tolerating "lol" be something that scales badly?

[14:38] <masak> (note: I long ago made the observation that people who enter the channel and have a high "lol" density in their speech, generally don't stick around long. I don't know what to make of that, lol)

[14:38] <laben> ShimmerFairy: if you have recently commited to Pod::To::HTML, could you check the failures in t/04-lists.t? it fails all 3 subtests

[14:38] <ShimmerFairy> masak: it's a damn shame I purged all my old repos recently, resurrecting my old old old SUPERNOVA now won't look like a resurrection in the git history :<

[14:39] <ShimmerFairy> laben: I noticed that, and it's the earlier issue I mentioned, the fact that =item doesn't set the :level adverb. For some reason. o_e

[14:39] *** GLRelia joined
[14:40] <_itz_> m: say 2+2

[14:40] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«4␤»

[14:40] <camelia> rakudo-moar bbcda8: OUTPUT«4␤»

[14:40] <_itz_> m: for [\~] <1 2 3> {.say}

[14:40] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Method 'gimme' not found for invocant of class 'Array'␤  in block <unit> at /tmp/9YsYo9yvsL:1␤␤»

[14:40] <camelia> rakudo-moar bbcda8: OUTPUT«1␤12␤123␤»

[14:40] <_itz_> OK GLRelia isn't currently updated via cron and is a stop gap

[14:41] <laben> m: my @a = [1, 2]; @a.push: @a; @a.say;

[14:41] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«1 2 1 2␤»

[14:41] <camelia> rakudo-moar bbcda8: OUTPUT«1 2 1 2␤»

[14:41] <laben> m: my @a = [1, 2]; @a.push: [3,4]; @a.say;

[14:41] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«1 2 3 4␤»

[14:41] <camelia> rakudo-moar bbcda8: OUTPUT«1 2 3 4␤»

[14:41] <RabidGravy> _itz_++ # JFDI

[14:41] <masak> _itz_++

[14:42] <masak> now we have to rename the nom branch, "cam", though :P

[14:42] <laben> m: my @a = [1, @a]; @a.say;

[14:42] <Woodi_> hi #perl6 :)

[14:42] <camelia> rakudo-moar bbcda8: OUTPUT«1␤»

[14:42] <laben> _itz_: sorry ;P

[14:42] <Woodi_> m: my @a = [0,0,0]; say "1Hi!" if so @a[0]; say "2Hi!" if so @a[1]; say "3Hi!" if so @a[2];

[14:42] <camelia> rakudo-moar bbcda8: OUTPUT«1Hi!␤»

[14:42] <Woodi_> is it ok ?

[14:42] <ShimmerFairy> masak: the other day jnthn mentioned the possibility that "glr" becomes "master", and "new object model" finally gets retired for the fact that the OM isn't so N :P

[14:42] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«(timeout)»

[14:42] <GLRelia> rakudo-moar GLR 20150817ish: ( no output )

[14:43] <masak> ShimmerFairy: ah.

[14:44] <ShimmerFairy> masak: it was a joking suggestion, I don't think it'd happen (unless glr really does become such a big overhaul of the codebase, maybe)

[14:44] <masak> ShimmerFairy: I'd hate to be the one to mention that that's what happened in the b -> ng/nom transition, and it hurt quite a lot.

[14:44] <masak> it hurt quite a lot because the branches had essentially diverged, and nom, even though it was clearly superior, wasn't up to feature-parity with b.

[14:44] <dalek> rakudo/nom: af61bb2 | lizmat++ | src/Perl6/Actions.nqp:

[14:44] <dalek> rakudo/nom: Allow my constant $?FOO again

[14:44] <dalek> rakudo/nom: 

[14:44] <dalek> rakudo/nom: As per http://irclog.perlgeek.de/perl6/2015-08-17#i_11067616

[14:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af61bb2c1d

[14:45] *** sjn_phone_ joined
[14:45] *** sjn_phone_ left
[14:45] <jnthn> masak: Given we're "only" re-working lists in glr, I don't think that's so likely to be an issue

[14:45] <ShimmerFairy> masak: yeah, I've had some flashback to back when nom was featureless (one of the repos I purged even mentioned "doesn't work on nom yet" in part of the README). Kinda surreal considering where nom is now :)

[14:46] *** colomon left
[14:46] <lizmat> alas, the above juste exposes the brokennes of this;

[14:46] <lizmat> $ 6 'my constant $?FILE = "huh"; say $?FILE'

[14:46] <lizmat> -e

[14:46] <jnthn> lizmat: *sigh* yes, the correct answer is "OK, eventually we'd like that to work, for now we're better of NOT allowing declaring $?FILE to avoid the confusion" 

[14:47] <lizmat> but: do you want that for any $?FOO or just for the $?ONES that are in the core ?

[14:47] <masak> maybe allow it, but parsefail with a NYI message?

[14:48] <jnthn> I don't know that's worth the code complexity...

[14:49] *** sjn_phone_ joined
[14:49] <jnthn> I'd rather just say "no" for now and worry about it after 6.christmas.

[14:50] <masak> oki

[14:50] <jnthn> It's easy to make stuff work that was a parse/compile fail in the future

[14:50] <ShimmerFairy> It would most directly affect $?TABSTOP, I think, since a couple things in Perl 6 use that, and you're supposed to be able to set it yourself.

[14:50] <jnthn> Anything we're not usre about should resort to that.

[14:52] <tadzik> nom: [&&] <a> >>~~<< <a b>

[14:52] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 2 elements␤  in block <unit> at /tmp/tmpfile:1␤␤»

[14:52] <camelia> rakudo-moar bbcda8: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length␤left: 1 elements, right: 2 elements␤  in block <unit> at /tmp/tmpfile:1␤␤»

[14:52] <lizmat> $ 6 'my constant $?FILE = "huh"'

[14:52] <lizmat> ===SORRY!=== Error while compiling -e

[14:52] <lizmat> Cannot use ? twigil on 'my' constant because we cannot make it work properly yet

[14:52] <lizmat> at -e:1

[14:52] <tadzik> ohh, GLRelia <3

[14:52] <lizmat> ^^^ better ?

[14:53] <dalek> rakudo/nom: 82ea784 | lizmat++ | src/Perl6/Actions.nqp:

[14:53] <dalek> rakudo/nom: Do NOT allow my constant $?FOO again

[14:53] <dalek> rakudo/nom: 

[14:53] <dalek> rakudo/nom: As discussed at: http://irclog.perlgeek.de/perl6/2015-08-17#i_11069370

[14:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/82ea784b94

[14:53] <jnthn> lizmat: *sigh* for fucks sake

[14:53] <jnthn> &

[14:55] *** darutoko left
[14:56] <tadzik> hah

[14:58] <masak> "I think I speak for everyone here when I say, we just cannot make it work properly yet" :P

[14:58] <tadzik> nom: [&&] ['5'] >>~~<< <5>

[14:58] <camelia> rakudo-moar bbcda8: ( no output )

[14:58] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Seq'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[14:58] <tadzik> different, but breakage

[14:58] <tadzik> this makes File::Find fail tests, is it intentional?

[14:59] <laben> ShimmerFairy: about that role methods requirements, if the role implements the method, but the class has alredy defined one (with possibly a different signature), should we error out or what?

[14:59] <tadzik> locally I get Lists on either side of non-dwimmy hyperop of infix:<~~> are not of the same length

[14:59] *** darutoko joined
[14:59] <tadzik> (because locally they are)

[14:59] <tadzik> well, not

[14:59] <tadzik> but one is [] and other is ()

[14:59] <masak> m: [5] >>~~<< <5>

[14:59] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Seq'␤  in block <unit> at /tmp/lZAWsAOfPO:1␤␤»

[14:59] <camelia> rakudo-moar bbcda8: ( no output )

[14:59] <masak> slightly simpler.

[14:59] <tadzik> Array and List

[14:59] <ShimmerFairy> laben: role R { method M($a) { stuff } }; class C does R { method M($b, $c) { stuff } } ? yeah, that'd be like declaring two 'only' methods with the same name in the class body

[15:00] <tadzik> which one is Seq? :f

[15:00] <tadzik> m: <5>.WHAT

[15:00] <camelia> rakudo-moar bbcda8: ( no output )

[15:00] <GLRelia> rakudo-moar GLR 20150817ish: ( no output )

[15:00] <tadzik> m: say <5>.WHAT

[15:00] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«(Str)␤»

[15:00] <camelia> rakudo-moar bbcda8: OUTPUT«(Str)␤»

[15:00] <nine> masak: the GLR equivalent is: my @a = 1, 2, 3; @a = flat @a, @a; say @a.perl

[15:00] <tadzik> nom: [&&] ['5', '6'] >>~~<< <5 6>

[15:00] <camelia> rakudo-moar bbcda8: ( no output )

[15:00] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Method 'gimme' not found for invocant of class 'Array'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[15:01] <dalek> rakudo/nom: f58a726 | lizmat++ | src/Perl6/Actions.nqp:

[15:01] <dalek> rakudo/nom: Make 'my constant $?FOO' a NYI

[15:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f58a726e86

[15:01] <nine> m: my @a = 1, 2, 3; @a = flat @a, @a; say @a.perl

[15:01] <camelia> rakudo-moar bbcda8: OUTPUT«[1, 2, 3, 1, 2, 3]<>␤»

[15:01] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«[1, 2, 3, 1, 2, 3]␤»

[15:01] <tadzik> (╯°д°）╯︵ɹןb

[15:02] <ShimmerFairy> tadzik: the issue is that nothing should be calling 'gimme', in that last one

[15:02] <tadzik> it still spurts different errors from the ones I get locally :)

[15:02] <ShimmerFairy> m: [5].list >>~~<< <5>

[15:02] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Seq'␤  in block <unit> at /tmp/Cff6nT_0og:1␤␤»

[15:02] <camelia> rakudo-moar bbcda8: ( no output )

[15:02] <tadzik> I only hope that they have a common root cause

[15:02] <ShimmerFairy> m: [5].list >>~~<< <5>.list

[15:02] <camelia> rakudo-moar bbcda8: ( no output )

[15:02] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Method 'gimme' not found for invocant of class 'Array'␤  in block <unit> at /tmp/cjPK0N8fSI:1␤␤»

[15:05] <laben> ShimmerFairy: so you mean, if the class already has the method, check if its sig matches or die out "Contract not respected"?

[15:05] *** luiz_lha left
[15:06] <ShimmerFairy> laben: no, because the role provides an implementation, the class doesn't have to provide anything for that method name. The role's methods will become part of the class' methods in composition, so if you have conflicting only methods, it's the usual conflict

[15:07] <laben> m: role R{method m($a){...}};class C{method m($a,$b){}}; C.m(1,2)

[15:07] <camelia> rakudo-moar bbcda8: ( no output )

[15:07] <GLRelia> rakudo-moar GLR 20150817ish: ( no output )

[15:07] *** diana_olhovik left
[15:07] <laben> m: role R{method m($a){...}};class C{method m($a,$b){}}; C.m(1)

[15:07] <camelia> rakudo-moar bbcda8: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/FKzMCksAk6:1␤  in block <unit> at /tmp/FKzMCksAk6:1␤␤»

[15:07] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/_6ZGoeU6ca:1␤  in block <unit> at /tmp/_6ZGoeU6ca:1␤␤»

[15:07] <ShimmerFairy> m: class C { method foo($a) { }; method foo($b, $c) { } }  # composing a role with a conflicting implemented method would do this

[15:07] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ZrWnwxOT_n␤Package 'C' already has a method 'foo' (did you mean to declare a multi-method?)␤at /tmp/ZrWnwxOT_n:1␤»

[15:07] <camelia> rakudo-moar bbcda8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4M7v7YDInk␤Package 'C' already has a method 'foo' (did you mean to declare a multi-method?)␤at /tmp/4M7v7YDInk:1␤»

[15:08] <laben> m: role R{method m($a){say "ROLE"}};class C{method m($a,$b){say "CLASS"}}; C.m(1,2)

[15:08] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«CLASS␤»

[15:08] <camelia> rakudo-moar bbcda8: OUTPUT«CLASS␤»

[15:08] <laben> m: role R{method m($a){say "ROLE"}};class C{method m($a,$b){say "CLASS"}}; C.m(1)

[15:08] <camelia> rakudo-moar bbcda8: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/fox_hIjq3Z:1␤  in block <unit> at /tmp/fox_hIjq3Z:1␤␤»

[15:08] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/4zWBWApVVd:1␤  in block <unit> at /tmp/4zWBWApVVd:1␤␤»

[15:08] *** bioexpress joined
[15:08] <laben> ShimmerFairy: it does not conflict, it just gets skipped althogether while composing

[15:09] <ShimmerFairy> laben: you forgot to 'does R' :)

[15:09] *** bioexpress left
[15:09] <laben> oops

[15:09] <laben> m: role R{method m($a){...}};class C does R{method m($a,$b){}}; C.m(1)

[15:09] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/nspatc18YJ:1␤  in block <unit> at /tmp/nspatc18YJ:1␤␤»

[15:09] <camelia> rakudo-moar bbcda8: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/d5XPfd_GdF:1␤  in block <unit> at /tmp/d5XPfd_GdF:1␤␤»

[15:09] <laben> m: role R{method m($a){...}};class C does R{method m($a,$b){}}; C.m(1,2)

[15:09] <GLRelia> rakudo-moar GLR 20150817ish: ( no output )

[15:09] <camelia> rakudo-moar bbcda8: ( no output )

[15:09] <laben> m: role R{method m($a){say "ROLE"}};class C does R{method m($a,$b){say "CLASS"}}; C.m(1)

[15:09] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/RzWgXIXo0v:1␤  in block <unit> at /tmp/RzWgXIXo0v:1␤␤»

[15:09] <camelia> rakudo-moar bbcda8: OUTPUT«Too few positionals passed; expected 3 arguments but got 2␤  in method m at /tmp/jBoryEh_X7:1␤  in block <unit> at /tmp/jBoryEh_X7:1␤␤»

[15:10] <laben> m: role R{method m($a){say "ROLE"}};class C does R{method m($a,$b){say "CLASS"}}; C.m(1,2)

[15:10] <camelia> rakudo-moar bbcda8: OUTPUT«CLASS␤»

[15:10] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«CLASS␤»

[15:10] <ShimmerFairy> And that's where I say the current implementation is lacking. The RoleToClassApplier currently only considers method name, not signatures, when considering overriding a role method.

[15:12] <laben> correct result would be to error out "required signature not matching" in both cases, iiuc?

[15:13] *** brrt joined
[15:13] <ShimmerFairy> laben: no, in that case it would be a simple method name conflict, like so:

[15:13] <ShimmerFairy> m: class C { method foo($a) { }; method foo($b, $c) { } }

[15:13] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g_R7unvJGR␤Package 'C' already has a method 'foo' (did you mean to declare a multi-method?)␤at /tmp/g_R7unvJGR:1␤»

[15:13] <camelia> rakudo-moar bbcda8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/700Nyg6PYM␤Package 'C' already has a method 'foo' (did you mean to declare a multi-method?)␤at /tmp/700Nyg6PYM:1␤»

[15:14] <laben> but doesnt that happen at parse time instead of at compose time?

[15:15] <laben> i mean, while defining the class?

[15:16] <ShimmerFairy> Well, the error wouldn't have to be the exact same one, but the issue in this case is more one of trying to define the same name twice with different signatures when they aren't "multi"s :)

[15:17] *** Ven left
[15:18] <laben> turns out i'm wrong and that error happens inside add_method, which is totally our territory during composition

[15:19] * [Coke] drowns in bot output.

[15:20] <laben> it would be enough to call add_method anyway and let that error out when it find a conflict, but this way wouldnt tell the class writer he overwrote the role method, mh

[15:22] *** Ven joined
[15:22] <ShimmerFairy> laben: this is certainly an interesting topic. I think it'd help if I wrote out a gist demonstrating my thoughts on the matter tomorrow :)

[15:24] *** Ven left
[15:26] *** leont joined
[15:27] <RabidGravy> speaking of which I have concluded that wrapping all the methods in a class is better done in compose when all the multis have been resolved

[15:28] *** brrt left
[15:29] <laben> RabidGravy: multis dont get resolved, just added to dispatch list so that MMD can then decide later on

[15:30] <RabidGravy> well that's what I meant really

[15:32] <RabidGravy> for my purposes is it's only necessary to wrap the proto  so it's easiest to do it after the real compose

[15:32] <dalek> rakudo/nom: 5ca1bcc | ShimmerFairy++ | src/Perl6/Pod.nqp:

[15:32] <dalek> rakudo/nom: Make sure =item blocks act like =item1

[15:32] <dalek> rakudo/nom: 

[15:32] <dalek> rakudo/nom: This means attaching the info that it's at level 1 to the Pod::Item

[15:32] <dalek> rakudo/nom: object.

[15:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ca1bccc6a

[15:35] <RabidGravy> and the side benefit of doing it at that point is that the methods from roles get wrapped :)

[15:35] <dalek> roast: b4780f5 | ShimmerFairy++ | S26-documentation/06-lists.t:

[15:35] <dalek> roast: Fix pod test that was backwards.

[15:35] <dalek> roast: review: https://github.com/perl6/roast/commit/b4780f54d3

[15:37] *** FROGGS_ is now known as FROGGS

[15:37] <FROGGS> o/

[15:37] <RabidGravy> Boom!

[15:37] *** zakharyas left
[15:38] <lizmat> FROGGS o/

[15:41] <hoelzro> o/ FROGGS 

[15:41] <hoelzro> ShimmerFairy++ # POD work

[15:41] *** Ven joined
[15:42] *** rindolf left
[15:42] <ShimmerFairy> I'll try to start working on a replacement parser tomorrow, it's about time :)  And in the process I'll get to surprisingly resurrect the old SUPERNOVA name :3

[15:43] *** telex left
[15:44] *** telex joined
[15:45] <hoelzro> ShimmerFairy: you're writing a new POD parser?

[15:46] <ShimmerFairy> hoelzro: I will, because the one currently in rakudo is not good. I find it incredibly and needlessly difficult to comprehend. It looks like someone tried to compress the parsing as cleverly as possible, as opposed to something more readable.

[15:46] *** sjn_phone_ left
[15:46] <smls> ShimmerFairy: For parsing tables, would it help to implement that rule in Perl 6 (rather than the regex lang)?

[15:47] <smls> gobble a complete table block, split it, call the normal para rule for each cell.

[15:47] <ShimmerFairy> And I'll be writing it outside of CORE at first, so I don't have to wait 90s for each change I want to test :)

[15:47] <smls> (provided Perl 6 rules are properly supported by now.)

[15:47] <Ven> m: say q|a|

[15:47] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«a␤»

[15:47] <camelia> rakudo-moar f58a72: OUTPUT«a␤»

[15:47] *** sjn_phone_ joined
[15:48] <hoelzro> ShimmerFairy++

[15:48] * geekosaur keeps trying to read GLRelia as GHRelin >.>

[15:48] <ShimmerFairy> smls: The problem (as I see it) is that it _doesn't_ use the regex lang to parse the table, and pawns it off on a Pod.nqp method. I don't know if you can access the grammar at that point, or how much of a headache it would be if you had to invoke a second copy with .parse

[15:49] <smls> isn't the idea of "rules as methods" that you can mix regex and Perl 6 methods that call each other within a single .parse?

[15:50] <Ven> I have a case where `@foo.map(&git-list);` isn't the same as `for @foo { git-list($_) }`. (literally "@foo"). any idea what might be going on?

[15:50] <ShimmerFairy> smls: Yeah, I'd be surprised if it had to be another .parse, but I'm not familiar with the interaction (and besides, calling back into the grammar from the actions side feels like you're doing something wrong to me)

[15:51] <Ven> the code is here: https://github.com/vendethiel/deepgitstatus/blob/master/deepgitstatus#L25 I just moved the `$dir.dir.grep(Dir)` to `@foo` in my local code

[15:51] <smls> ShimmerFairy: No, I don't mean an action method. I mean a Perl 6 method inside the grammar.

[15:52] *** sjn_phone_ left
[15:52] <hoelzro> ShimmerFairy: are you talking about the POD parsing that happens in Perl6::Grammar?

[15:52] <ShimmerFairy> hoelzro: yes, that one (not aware of any other place) :)

[15:53] <ShimmerFairy> smls: Of course, several of Perl6::Grammar's rules are actually called 'method's specifically because they do more code-like things than regex-like things :)

[15:53] *** rurban_ left
[15:53] *** sjn_phone_ joined
[15:53] <ShimmerFairy> And, as a personal matter, I prefer leaving the parsing to the Grammar when at all feasible, so I don't like that the table parsing happens over in Pod.nqp

[15:54] *** domidumont left
[15:54] <hoelzro> ShimmerFairy: let me know if you would like some help with that; I dug into that stuff this time last year for the S26 stuff

[15:54] <hoelzro> there are some nasty hacks that I myself added =/

[15:54] <ShimmerFairy> (As an example of this, look at the $<ohradix> capture I added to the Grammar a couple days ago. That was me moving some action-side string munching to the grammar  ☺)

[15:54] *** Loren joined
[15:55] <ShimmerFairy> hoelzro: Thanks. I'll be starting off on a clean slate away from the rakudo code, so I'll probably run into issues when it comes time to moving the code into rakudo

[15:55] *** abraxxa left
[15:56] <hoelzro> sounds good =)

[15:56] <laben> Ven: sorry i cant get deep into your code, but afaik .dir doesnt guarantee much order-ness

[15:56] <ShimmerFairy> hoelzro: And don't worry, that fix I added to rakudo just now kinda felt like a quick hack to me, specifically because I plan on replacing it sometime soon :P

[15:56] <hoelzro> please post updates on your branch as you're working; I'm very intrigued

[15:57] <ShimmerFairy> hoelzro: well, it'll be separate repo, that's how removed from CORE it'll be at the start (though I'll try to remember to use := everywhere :P)

[15:57] *** sjn_phone_ left
[15:57] *** MilkmanDan joined
[15:58] <ShimmerFairy> I'll make sure the stuff that has to change between in-rakudo and out-of-rakudo will be easy to substitute :)

[15:58] <smls> m: say (grammar { token TOP { <a> }; method a { self.ident } }).parse("aaa");

[15:58] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«｢aaa｣␤ a => ｢aaa｣␤»

[15:58] <camelia> rakudo-moar 5ca1bc: OUTPUT«｢aaa｣␤ a => ｢aaa｣␤»

[15:58] <smls> \o/

[15:58] <smls> "methods in grammars" works even without NQP, it seems

[15:59] <ShimmerFairy> smls: NQP's grammars are one of the few areas that are less "not quite" and more "exactly" :)

[16:00] <smls> I see.

[16:00] <ShimmerFairy> (so grammars are fortunately easily transferable between nqp and p6. Actions, however...)

[16:00] <Ven> laben: it has no impact on my code.

[16:00] <ShimmerFairy> smls: and it's specifically because NQP's regexes have to be good enough to parse Perl 6, so wouldn't you know it has to be just like it's specified in Perl 6? :P

[16:01] *** MadcapJake joined
[16:02] <RabidGravy> speaking of which where do the $~MAIN and so forth get defined?

[16:03] <ShimmerFairy> RabidGravy: as of now? Nowhere, really.

[16:03] <ShimmerFairy> m: say $~MAIN

[16:03] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Slang.new(:grammar(Perl6::Grammar), :actions(Perl6::Actions))␤»

[16:03] <camelia> rakudo-moar 5ca1bc: OUTPUT«Slang.new(:grammar(Perl6::Grammar), :actions(Perl6::Actions))␤»

[16:03] <ShimmerFairy> welp, guess I haven't been keeping up to speed with slangs :P

[16:03] <RabidGravy> yeah, where does that happen

[16:04] <Ven> deep in the compiler, probably?

[16:04] *** grondilu joined
[16:05] <ShimmerFairy> RabidGravy: seems to be generated on-the-fly in make_variable_from_parts in Actions.nqp

[16:07] <ShimmerFairy> smls: I'll definitely keep =list in mind. I was toying with that name being used to group =items (like <ul></ul> and so on), but I do like the idea of specifying "ASCII" lists with them.

[16:09] <dalek> rakudo/glr: ff60b61 | (Stefan Seifert)++ | src/core/metaops.pm:

[16:09] <dalek> rakudo/glr: GLRify METAOP_REDUCE_LEFT(\op, \triangle)

[16:09] <dalek> rakudo/glr: 

[16:09] <dalek> rakudo/glr: Fixes Shell::Command

[16:09] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ff60b617d5

[16:10] *** Loren left
[16:12] <hoelzro> ShimmerFairy: just make sure to post a link to the repo if you want so some of us can follow along =)

[16:12] <ShimmerFairy> hoelzro: but of course :)

[16:13] <nine> 269/1047 test files failing

[16:13] <ShimmerFairy> (though I have a habit of working on a repo for at least a little bit before going public; I won't push to github as soon as I add a README :P)

[16:14] <hoelzro> fair enough

[16:14] <ShimmerFairy> good ♘, #perl6 o/

[16:14] *** brrt joined
[16:14] <lizmat> good night, ShimmerFairy 

[16:14] *** rindolf joined
[16:14] * lizmat calls it a night as well

[16:14] <hoelzro> o/ you two

[16:15] * JimmyZ too :)

[16:39] *** yqt joined
[16:46] *** inokenty joined
[16:50] <dalek> perl6-most-wanted: c4d4050 | (Steve Mynott)++ | most-wanted/modules.md:

[16:50] <dalek> perl6-most-wanted: AE256 handled in openssl, adding other cyphers fairly easy

[16:50] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/c4d40503d4

[16:54] <dalek> rakudo/glr: 0868b9f | (Stefan Seifert)++ | src/core/metaops.pm:

[16:54] <dalek> rakudo/glr: GLRify METAOP_ZIP

[16:54] <dalek> rakudo/glr: 

[16:54] <dalek> rakudo/glr: We can now use iterators instead of copying the input lists.

[16:54] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0868b9fa9a

[16:54] <nine> 267/1047 test files failing

[16:57] <Ven> nine++

[16:59] <skids> Ooh, how's panda fairing after that I wonder.

[16:59] <nine> m: for [\~] <1 2 3> {.say}

[16:59] <GLRelia> rakudo-moar GLR 20150817ish: OUTPUT«Method 'gimme' not found for invocant of class 'Array'␤  in block <unit> at /tmp/FYmZHpfFpY:1␤␤»

[16:59] <camelia> rakudo-moar 5ca1bc: OUTPUT«1␤12␤123␤»

[17:00] <nine> _itz_: GLRelia is hopelessly out of date :)

[17:01] <nine> skids: panda is two fails further. Now crashing due to @params is rw being a List and thus immutable.

[17:01] <_itz_> hmmm maybe I should try and add a cron

[17:03] *** Loren joined
[17:04] <geekosaur> every 5 minutes? :)

[17:06] <_itz_> I'm not sure that would keep up with nine :)

[17:06] <smls> just do a loop; once compilation is finished, compile again... :P

[17:08] *** ilogger2 joined
[17:08] *** ChanServ sets mode: +v ilogger2

[17:08] <smls> btw, I wonder if the zip version of https://gist.github.com/smls/a1f6033c142202bddc4d will run at reasonable performance post-GLR.

[17:09] <nine> smls: only benchmarks can tell

[17:09] <nine> smls: it should already be a bit faster, I'd guess

[17:09] <smls> pre-GLR: 810 sec for the naive zip-based version, 19 sec with a 'loop' using native int counter...

[17:09] <smls> ;)

[17:10] <nine> Oh it's now super fast........at printing Range iterator NYI

[17:11] <smls> heh

[17:13] <Ven> [@a, @b][0].push: 1 will DWIM later, right? (admittedly, that's a pretty weird way to write that...)

[17:14] <nine> m: my @a; my @b; [@a, @b][0].push: 1; say @a.perl; say @b.perl;

[17:14] <camelia> rakudo-moar 5ca1bc: OUTPUT«[]<>␤[]<>␤»

[17:14] <GLRelia> rakudo-moar 0868b9: OUTPUT«[1]␤[]␤»

[17:14] <nine> I'd say yes :)

[17:14] <smls> m: my @a = 1, 3; my @b = 2, 4; (@a, @b)[0].push: 5; dd @a

[17:14] <GLRelia> rakudo-moar 0868b9: OUTPUT«@a = [1, 3, 5]␤»

[17:14] <camelia> rakudo-moar 5ca1bc: OUTPUT«@a = [1, 3, 5]<>␤»

[17:15] <smls> ^^ works with Parcel already, pre-GLR

[17:15] <nine> Parcel? Parcel! Who the fuck is Parcel?!

[17:16] <smls> :P

[17:16] <Ven> smls: I didn't even think about that, haha. Thanks :).

[17:17] <smls> though *technically* that's not pre-GLR, since making postcircumfix on parcels non-flattening, was one of the early changes made a few months ago in preparation for the GLR I believe.

[17:17] <smls> anyway, yes, let's forget about Parcel now...

[17:38] *** __blackcat joined
[17:40] *** lizmat joined
[17:42] *** domidumont joined
[17:43] <nine> Ah rakudo guts, where clear names make documentation unnecessary. Like "p6bindattrinvres"

[17:44] <nine> A sentence that will extend the Google results for this word by 16 %.

[17:49] <DrForr> n/ick qrstuvwxyz

[17:51] <skids> Though the "Parcel" name was very nicely punny.

[17:54] <jnthn> nine: bind the attribute, give me the invocant as the result (instead of the bound value as is the default) :)

[17:54] <nine> jnthn: oh thanks!

[17:54] <jnthn> It's right there in the name! ;)

[17:54] <nine> And now that's documented in Google :)

[17:55] <nine> m: my @a; @a[0] := 1;

[17:55] <camelia> rakudo-moar 5ca1bc: ( no output )

[17:55] <GLRelia> rakudo-moar 0868b9: OUTPUT«This type does not support positional operations␤  in block <unit> at /tmp/OxJChAPymI:1␤␤»

[17:55] <nine> jnthn: ^^^ that's what I currently try to fix

[17:55] <jnthn> nine: I'll bet BIND-POS doesn't called that self!ensure-allocated thingy

[17:55] <jnthn> *call

[17:56] *** spider-mario joined
[17:57] <nine> Ah, stupid me. I could have thought of that.

[17:57] <ugexe> is there an obvious way to do the following that would result in the same structure for nom and glr?

[17:57] <ugexe> m: my @r = eager gather for 1,2,3,4 { my %x; %x{$_} = $_; take %x }; say @r.perl

[17:57] <camelia> rakudo-moar 5ca1bc: OUTPUT«["1" => 1, "2" => 2, "3" => 3, "4" => 4]<>␤»

[17:57] <GLRelia> rakudo-moar 0868b9: OUTPUT«[${"1" => 1}, ${"2" => 2}, ${"3" => 3}, ${"4" => 4}]␤»

[17:57] *** n0tjack joined
[17:58] *** n0tjack left
[17:58] <dalek> rakudo/glr: 15719e0 | (Stefan Seifert)++ | src/core/Array.pm:

[17:58] <dalek> rakudo/glr: Fix binding slots of not yet allocated arrays.

[17:58] <dalek> rakudo/glr: 

[17:58] <dalek> rakudo/glr: Fixes my @a; @a[0] := 1;

[17:58] <dalek> rakudo/glr: Thanks to jnthn++ for reminding me of the obvious!

[17:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/15719e0719

[17:58] <ugexe> i want the glr version, just trying to shim something as to not maintain 2 forks

[17:58] <jnthn> Apparently last week's intense GLR hacking combined with afk issues has exhausted me. :/

[17:59] * jnthn will be flying to Japan tomorrow

[18:00] <jnthn> Hopefully I'll rest well after the flight, and be back in decent shape again...

[18:00] <nine> 263/1047 test files failing

[18:00] <[Coke]> jnthn: conserve health!

[18:00] *** rurban_ joined
[18:00] <jnthn> Anyway, apologies for how testy I've been here the last few days. It's my extreme tiredness/stress failure mode. :(

[18:01] <jnthn> [Coke]: Yes, am trying :)

[18:02] * skids honestly hadn't noticed any testiness.

[18:03] *** __blackcat left
[18:04] <nine> m: my @a = 1, 2, 3; my @b = @a X=> "foo"; say @b.perl;

[18:04] <camelia> rakudo-moar 5ca1bc: OUTPUT«[1 => "foo", 2 => "foo", 3 => "foo"]<>␤»

[18:04] <GLRelia> rakudo-moar 0868b9: OUTPUT«Method 'gimme' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/0f_2VYpJaL:1␤␤»

[18:05] <nine> m: my @a = 1, 2, 3; my @b = flat @a X=> "foo"; say @b.perl;

[18:05] <camelia> rakudo-moar 5ca1bc: OUTPUT«[1 => "foo", 2 => "foo", 3 => "foo"]<>␤»

[18:05] <GLRelia> rakudo-moar 0868b9: OUTPUT«Method 'gimme' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/J2YOqJwSoS:1␤␤»

[18:05] <nine> _itz_: already out of date again :)

[18:05] <jnthn> I suspect X meta-op will need a going through

[18:05] <nine> jnthn: already done ;)

[18:05] <jnthn> Oh :)

[18:05] <jnthn> nine++

[18:05] <jnthn> Did you re-work it in terms of iterators, ooc?

[18:05] <nine> jnthn: but flat @a X=> 'foo' gives me a "This Seq has already been iterated, and its values consumed" now

[18:05] <nine> jnthn: yes

[18:06] <nine> jnthn: though I guess the comment is no longer true: "my \elem = lol[$i]; # can't use mapping here, mustn't flatten"

[18:06] <nine> jnthn: so there may be more possibility for optimization

[18:06] <jnthn> Indeed, now we can do it

[18:06] <jnthn> Right

[18:07] <jnthn> The stack trace of the second attempt to consume is often telling enough

[18:08] <jnthn> If not then you could always do some hack in method iterator in Seq that makes a Backtrace and stashes it away, then can report it the second time

[18:08] * jnthn hopes that made some sense :)

[18:08] <skids> Failure should stash backtraces now.

[18:10] <jnthn> Maybe I should write a Seq::UsageDebugger module at some point to help hunt such things :)

[18:11] <nine> It's in Iterator.flat called by pull-one of the Iterator returned by Iterator.flat()

[18:14] *** colomon joined
[18:14] <nine> s/Iterator/Iterable/g

[18:18] <jnthn> 'fraid I don't have any immediate guesses

[18:19] *** bin_005 joined
[18:19] *** zakharyas joined
[18:19] <nine> Well I guess that just happens when you fix code where you only really understand half of it ;)

[18:22] <nine> I'm already very proud that when I started fixing METAOP_REDUCE_LEFT(\op, \triangle), I wrote code that's very similar to yours, before I discovered, that you already did METAOP_REDUCE_LEFT(\op) and I could use that as a template :)

[18:24] <jnthn> :)

[18:24] <jnthn> I'm happy the iterator design is such that it led both of us to a similar solution :)

[18:25] <jnthn> time for noms &

[18:25] <nine> Yes, it's really straight forward to use

[18:26] *** sjn_phone_ joined
[18:38] *** lizmat left
[18:49] *** sjn_phone_ left
[18:52] *** diana_olhovik joined
[18:55] <nine> jnthn: I should just have gone ahead and refactored the lol loop as well. It's the (elem,).flat.item thingy that returns a Seq. And that Seq gets iterated over too often.

[18:56] <nine> m: <1 2>.flat.item.perl.say;

[18:56] <GLRelia> rakudo-moar 15719e: OUTPUT«Seq.new␤»

[18:56] <camelia> rakudo-moar 5ca1bc: OUTPUT«$("1", "2")␤»

[18:56] *** yqt joined
[18:58] <jnthn> nine: The .item is extremely superstitious now too

[18:58] <jnthn> nine: I think that can just be (elem,) :)

[18:59] *** zakharyas left
[18:59] <nine> m: my \elem = <1 2>; (elem,).flat.list.item.perl.say; (elem,).perl.say;

[18:59] <GLRelia> rakudo-moar 15719e: OUTPUT«$("1", "2")␤(("1", "2"))␤»

[18:59] <camelia> rakudo-moar 5ca1bc: OUTPUT«$("1", "2")␤(("1", "2"),)␤»

[18:59] <jnthn> And yeah, folks expecting .flat to return a list also will be "interesting" :)

[19:00] <nine> I don't even know what this code is supposed to do: if nqp::iscont(elem) { (elem,).list.item } else { (elem,).flat.list.item }

[19:00] *** lizmat joined
[19:02] <jnthn> "If it's a Scalar, always treat it as a 1-item list, otherwise treat it as a flattened list

[19:02] <jnthn> "

[19:03] <jnthn> Didn't I refactor that bit in the one you're using as a "template" too? :)

[19:03] <nine> Oh yes, that's the Iterable type check now

[19:03] <jnthn> Right :)

[19:03] <nine> Ok, I can work with that :)

[19:05] <nine> And again highly obscur code gets replaced by very straight forward one. I like that :)

[19:08] <FROGGS> nice, I implemented an exception that is raised when the initializer of a variable declaration contains said variable, and I find bugs in the setting :o)

[19:09] <smls> FROGGS: I thought that was allowed?

[19:09] <FROGGS> m: sub foo { my %ENV := $%ENV; }; foo

[19:09] <GLRelia> rakudo-moar 15719e: OUTPUT«Cannot call method 'item' on a null object␤  in sub foo at /tmp/aB9okfvRRE:1␤  in block <unit> at /tmp/aB9okfvRRE:1␤␤»

[19:09] <camelia> rakudo-moar 5ca1bc: OUTPUT«Cannot call method 'item' on a null object␤  in sub foo at /tmp/Fgum6bhO5P:1␤  in block <unit> at /tmp/Fgum6bhO5P:1␤␤»

[19:10] <FROGGS> $ perl6-m -e 'm: sub foo { my %ENV := $%ENV; }; foo'

[19:10] <FROGGS> ===SORRY!=== Error while compiling -e

[19:10] <FROGGS> Cannot use variable %ENV to initialize itself

[19:11] <FROGGS> smls: if it survives a spectest I'll push and you can try to break it :o)

[19:13] <dalek> rakudo/nom: 45644ed | FROGGS++ | src/core/IO/Spec/ (2 files):

[19:13] <dalek> rakudo/nom: fix indentation

[19:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45644ed97b

[19:14] <dalek> rakudo/nom: ccfb5fb | FROGGS++ | src/core/IO/Spec/Cygwin.pm:

[19:14] <dalek> rakudo/nom: fix typo about %*ENV in IO::Spec::Cygwin.tmpdir

[19:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ccfb5fbe8f

[19:14] <skids> dammit why do I keep typing "Interable"

[19:16] <FROGGS> that's.... iteresting

[19:18] <skids> m: Iterable but 1;

[19:18] <camelia> rakudo-moar 5ca1bc: ( no output )

[19:18] <GLRelia> rakudo-moar 15719e: OUTPUT«Method 'iterator' must be implemented by Iterable because it is required by a role␤  in any compose_method_table at src/gen/m-Metamodel.nqp:2664␤  in any apply at src/gen/m-Metamodel.nqp:2674␤  in any compose at src/gen/m-Metamodel.nqp:2810␤  in an…»

[19:19] <skids> Oh, right.  It's a role.

[19:20] <timotimo> on a very long drive and having a bad headache... no weekly from me tonight

[19:20] <FROGGS> timotimo: :o/

[19:21] *** brrt joined
[19:23] *** domidumont left
[19:25] *** llfourn joined
[19:30] *** llfourn left
[19:31] <dalek> rakudo/glr: 19fad47 | (Stefan Seifert)++ | src/core/List.pm:

[19:31] <dalek> rakudo/glr: Fix some forms of infix:<X>

[19:31] <dalek> rakudo/glr: 

[19:31] <dalek> rakudo/glr: We can now check for Iterable to differentiate between listy things and scalars.

[19:31] <dalek> rakudo/glr: the gather {}.list is necessary to avoid iterating over the same Seq multiple

[19:31] <dalek> rakudo/glr: times, e.g. when actually trying to assign the result of X to an @array.

[19:31] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/19fad47934

[19:32] <dalek> rakudo/glr: 5543e5f | (Stefan Seifert)++ | src/core/metaops.pm:

[19:32] <dalek> rakudo/glr: GLRify METAOP_CROSS

[19:32] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5543e5fbc6

[19:36] <dalek> rakudo/glr: 117b998 | (Stefan Seifert)++ | src/core/List.pm:

[19:36] <dalek> rakudo/glr: Fix infix:<X> for 3 dimensions

[19:36] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/117b99843d

[19:39] <nine> I fear the gather {}.list fix is responsible for 1..* X* 1..* hanging :/

[19:40] <FROGGS> there might be more than one way to fix things

[19:43] <nine> At times like this I wish I actually new what I was doing :/ I don't even have an idea what 1..* X* 1..* is supposed to mean.

[19:44] <_itz_> m: my @a; @a[0] := 1;

[19:44] <GLRelia> rakudo-moar 117b99: ( no output )

[19:44] <camelia> rakudo-moar 5ca1bc: ( no output )

[19:44] <colomon> nine: it’s just a silly complicated way of writing 1…*, isn’t it?

[19:45] <[Coke]> m: my @a = 1..* X* 1..*; say @a[0..4];

[19:45] <GLRelia> rakudo-moar 117b99: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8…»

[19:45] <camelia> rakudo-moar 5ca1bc: OUTPUT«(timeout)»

[19:45] <nine> Wait, WHAT?

[19:45] <colomon> like I said…. ;)

[19:45] <FROGGS> nine: it cross-multiplies two infinite lists

[19:46] <nine> Why is GLRelia giving uns the result while nom is hanging?!

[19:46] <[Coke]> m: constant @a := 1..* X* 1..*; say @a[4];

[19:46] <GLRelia> rakudo-moar 117b99: OUTPUT«Nil␤»

[19:46] <camelia> rakudo-moar 5ca1bc: OUTPUT«5␤»

[19:46] <skids> https://gist.github.com/skids/ccb89f60bb57b95e0e01  # Now I feel like I need a shower

[19:46] <[Coke]> the bind probably helps there.

[19:47] <colomon> is one of those rakudo-moar’s a GLR build?

[19:47] *** xinming joined
[19:47] <FROGGS> colomon: GLRelia, aye

[19:47] <geekosaur> GLRelia's hash matches the most recent glr commit

[19:47] <skids> itz's iz

[19:47] <colomon> how do you tell which output it is?

[19:48] <FROGGS> colomon: look at the botname

[19:48] <colomon> oh!

[19:48] <FROGGS> :o)

[19:48] * colomon is not observant

[19:48] * leont is surprised by that output too

[19:48] <FROGGS> m: constant @a := (1..* X* 1..*).flat; say @a[4];

[19:48] <GLRelia> rakudo-moar 117b99: OUTPUT«5␤»

[19:48] <camelia> rakudo-moar 5ca1bc: OUTPUT«5␤»

[19:48] <jnthn> skids: It's nice for debugging, but too costly really to have as the default.

[19:49] <skids> Oh yeah, I know.

[19:49] <FROGGS> that was needed since a few months

[19:49] <jnthn> skids: But nice :)

[19:49] <skids> I just had to see if it would work at all.

[19:52] *** yqt left
[19:53] <nine> m: my @a = 1..* X* 1..*; say @a[0..4];

[19:53] <GLRelia> rakudo-moar 117b99: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8…»

[19:53] <FROGGS> nine: the first dimension already is infinite

[19:53] <nine> Isn't this output actually wrong?

[19:53] <camelia> rakudo-moar ccfb5f: OUTPUT«(timeout)»

[19:53] <FROGGS> no, it is correct

[19:54] <[Coke]> m: constant @a := 1..* X* 1..*; say @a[0][4];

[19:54] <GLRelia> rakudo-moar 117b99: OUTPUT«5␤»

[19:54] <camelia> rakudo-moar ccfb5f: OUTPUT«Index out of range. Is: 4, should be in 0..0␤  in block <unit> at /tmp/Wbi_RRvpMJ:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Wbi_RRvpMJ:1␤␤»

[19:55] <nine> Shouldn't it return something like 1 1 2 2?

[19:55] <nine> Oh, no, that would be 1..* X 1..*

[19:57] <dalek> rakudo/nom: 3754356 | FROGGS++ | src/ (2 files):

[19:57] <dalek> rakudo/nom: forbid to put variable in initializer of its declaration

[19:57] <dalek> rakudo/nom: 

[19:57] <dalek> rakudo/nom: This fixes RT #125371. Variables in initializers in subsequent blocks are allowed though.

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3754356d8e

[19:57] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125371

[19:57] <FROGGS> smls: ^^

[19:58] *** lsm-desktop joined
[19:58] <nine> (1..* X* 1..*)[0..4] should give 1 4 9 16 25 if you ask me

[19:58] <nine> m: (1..10 X* 1..10)[0..4].perl

[19:58] <GLRelia> rakudo-moar 117b99: ( no output )

[19:58] <camelia> rakudo-moar ccfb5f: ( no output )

[19:58] <nine> m: (1..10 X* 1..10)[0..4].perl.say

[19:58] <GLRelia> rakudo-moar 117b99: OUTPUT«(1, 2, 3, 4, 5)␤»

[19:58] <camelia> rakudo-moar ccfb5f: OUTPUT«(1, 2, 3, 4, 5)␤»

[19:59] <colomon> nine: that’s Z* you’re thinking of

[19:59] <[Coke]> FROGGS: didn't timtoady just say he wanted my @a = 1, @a to work?

[19:59] <colomon> but I don’t see why [0..4] is apparently infinite instead of 5 long?

[19:59] <colomon> m

[19:59] <[Coke]> colomon: because the first thing is an infinite list.

[20:00] <colomon> you mean [0] is an infinite list?

[20:00] <FROGGS> [Coke]: would is the reason to allow that?

[20:00] <[Coke]> (and then the second thing would also be an infinite list..)

[20:00] <FROGGS> [Coke]: my @a = 1, @a is probably like my @a = 1, ()

[20:00] <[Coke]> The desire was that it be more like 1, 1, 1, ... IIRC.

[20:00] <FROGGS> or... no, perhaps like my @a = 1

[20:01] <[Coke]> doesn't work yet, but was proposed by TimToady - hard to search for in the logs.

[20:01] <nine> So this test can actually never work: is (1..* X* 1..*)[^3], (1, 2, 3), 'cross handles lazy lists';

[20:01] <nine> Am I right?

[20:01] <[Coke]> nine: well, before, you probably got a flat list.

[20:01] <FROGGS> [Coke]: I'll go ahead and drop him a note... would just be two commits to revert

[20:01] <[Coke]> post glr, looks like you get N lists...

[20:02] <smls> FROGGS: Self-reference can make sense in cases like     my %a = foo => 42, bar => sub { say %a<foo> }

[20:02] <FROGGS> smls: that will continue to work, as the commit comment states

[20:03] <nine> [Coke]: if I get N lists, that's my fault, since I'm the one who tries implement METAOP_CROSS in glr

[20:03] <[Coke]> nine: I have no idea what the right answer is there. :)

[20:03] <smls> ah, that's what you mean by 'subsequent blocks'

[20:03] <FROGGS> aye

[20:03] <nine> [Coke]: neither have I *g* That's what makes implementing this so hard ;)

[20:04] <skids> Well if the answer is that it should be flat, just returning N Slips should work, right?

[20:04] <colomon> m: my @a = 1..* X* 1..*; say @a[0][0..4];

[20:04] <GLRelia> rakudo-moar 117b99: OUTPUT«1 2 3 4 5␤»

[20:05] <camelia> rakudo-moar ccfb5f: OUTPUT«(timeout)»

[20:08] <AlexDaniel> GLRelia :)))

[20:09] <FROGGS> GameLiaRrrr!

[20:13] <smls> FROGGS: The popular   my Type $x .= new;  idiom still works though, right?

[20:14] <FROGGS> smls: yes, since the exception is about the $x

[20:15] <FROGGS> so you cannot use the name when it is not yet initialized... at least that's the idea

[20:16] <smls> So you couldn't write it as    my Type $x = $x.new;    anymore, right? (Not that I think anyone did that.)

[20:17] <dalek> roast: cddf3a2 | FROGGS++ | S (4 files):

[20:17] <dalek> roast: RT #125371, catch variable use in its own initializer

[20:17] <dalek> roast: review: https://github.com/perl6/roast/commit/cddf3a26a4

[20:17] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125371

[20:18] <smls> Though it makes it a little harder to explain why .= new works.

[20:18] <FROGGS> smls: you are right in all charges

[20:21] <FROGGS> TimToady: I changed the handling of "my $a = $a", if you don't like it revert rakudo/3754356d8e and roast/cddf3a26a4

[20:22] <FROGGS> m: my Int $x = $x.new; # smls

[20:22] <GLRelia> rakudo-moar 117b99: ( no output )

[20:22] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/J0MRojclBk␤Cannot use variable $x in declaration to initialize itself␤at /tmp/J0MRojclBk:1␤------> 3my Int $x = $7⏏5x.new; # smls␤    expecting any of:␤        term␤»

[20:22] <FROGGS> m: my Int $x .= new;

[20:22] <GLRelia> rakudo-moar 117b99: ( no output )

[20:22] <camelia> rakudo-moar 375435: ( no output )

[20:22] *** smls joined
[20:23] <FROGGS> m: my Buf $x = $x.new(42); say $x

[20:23] <GLRelia> rakudo-moar 117b99: OUTPUT«Buf:0x<2a>␤»

[20:23] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nS7dwXX72V␤Cannot use variable $x in declaration to initialize itself␤at /tmp/nS7dwXX72V:1␤------> 3my Buf $x = $7⏏5x.new(42); say $x␤    expecting any of:␤        term␤»

[20:24] *** [Sno] joined
[20:25] <Ulti> `gotty -w perl6 --setting=RESTRICTED` using https://github.com/yudai/gotty is fun

[20:25] <FROGGS> we could potentially tweak it so methods calls would turn off that exception, but I like simple rules

[20:25] *** rurban_ left
[20:26] *** llfourn joined
[20:27] *** cognominal joined
[20:27] <smls> The previous rule (variable is initialized to the appropriate type object before executing the initializer) was also simple enough. Though I understand the desire for extra safety that may help to spot typos/thinkos.

[20:28] *** rurban_ joined
[20:28] <smls> I guess it could always be re-allowed once someone finds a good use for it... :P

[20:30] *** llfourn left
[20:31] *** captain-adequate joined
[20:31] *** Averna joined
[20:32] *** bin_005 left
[20:33] *** espadrine joined
[20:33] <FROGGS> problem was this simple thing:

[20:33] <FROGGS> m: say my $a = $a

[20:33] <GLRelia> rakudo-moar 117b99: OUTPUT«(Any)␤»

[20:33] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NNghgCgL0A␤Cannot use variable $a in declaration to initialize itself␤at /tmp/NNghgCgL0A:1␤------> 3say my $a = $7⏏5a␤    expecting any of:␤        term␤»

[20:33] <FROGGS> m: my $a = $a; say $a

[20:33] <GLRelia> rakudo-moar 117b99: OUTPUT«(Any)␤»

[20:33] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/uBiBWohdeL␤Cannot use variable $a in declaration to initialize itself␤at /tmp/uBiBWohdeL:1␤------> 3my $a = $7⏏5a; say $a␤    expecting any of:␤        term␤»

[20:33] *** bin_005 joined
[20:34] <FROGGS> err

[20:34] <FROGGS> m: my $a := $a; say $a

[20:34] <GLRelia> rakudo-moar 117b99: OUTPUT«(signal SEGV)»

[20:34] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/7ZFOXxu8Vf␤Cannot use variable $a in declaration to initialize itself␤at /tmp/7ZFOXxu8Vf:1␤------> 3my $a := $7⏏5a; say $a␤    expecting any of:␤        term␤»

[20:34] <FROGGS> this

[20:36] <jnthn> We should really fix the SEGV down in the VM too, though I know about why that one happens...

[20:39] <jnthn> Time to rest up ahead of tomorrow's long trip...

[20:39] <jnthn> 'night, #perl6

[20:39] <nine> m: (1, 2, 3 X** 2, 4).perl.say

[20:39] <GLRelia> rakudo-moar 117b99: OUTPUT«((1, 1, 4, 16, 9, 81))␤»

[20:39] <camelia> rakudo-moar 375435: OUTPUT«(1, 1, 4, 16, 9, 81)␤»

[20:42] *** virtualsue joined
[20:42] *** breinbaas joined
[20:46] *** espadrine left
[20:47] <nine> Oh, when I just return gather { ... } instead of $policy(gather { ... }) with $policy being &list, the infinit list case works! And so do the other use cases I understand. Just 4 spec tests failing.

[20:49] *** virtualsue left
[20:50] *** virtualsue joined
[20:53] <dalek> rakudo/glr: bf657a1 | (Stefan Seifert)++ | src/core/metaops.pm:

[20:53] <dalek> rakudo/glr: Fix "This Seq has already been iterated" on METAOP_CROSS results

[20:53] <dalek> rakudo/glr: 

[20:53] <dalek> rakudo/glr: Frankly, I don't know why, but without wrapping the results in the &list call

[20:53] <dalek> rakudo/glr: many more tests pass and neither infinite loops nor "This Seq has already

[20:53] <dalek> rakudo/glr: been iterated" messages occur.

[20:53] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/bf657a1f5d

[20:56] * TimToady woke up at 5 this morning, but maybe that means he can actually backlog a little...

[20:57] <nine> And the remaining spec test failures may actually be due to desired semantics changes

[20:58] <nine> m: (1,2 X ( <a b> X "x")).perl.say

[20:58] <GLRelia> rakudo-moar bf657a: OUTPUT«(((1, (("a", "x"), ("b", "x"))), (2, (("a", "x"), ("b", "x")))))␤»

[20:58] <camelia> rakudo-moar 375435: OUTPUT«((1, "a"), (1, "x"), (1, "b"), (1, "x"), (2, "a"), (2, "x"), (2, "b"), (2, "x"))␤»

[20:59] <nine> m: (1,2 X ( <a b> X "x").flat).perl.say

[20:59] <camelia> rakudo-moar 375435: OUTPUT«((1, "a"), (1, "x"), (1, "b"), (1, "x"), (2, "a"), (2, "x"), (2, "b"), (2, "x"))␤»

[20:59] <GLRelia> rakudo-moar bf657a: OUTPUT«(((1, "a"), (1, "x"), (1, "b"), (1, "x"), (2, "a"), (2, "x"), (2, "b"), (2, "x")))␤»

[20:59] <TimToady> we may end up with some metaops to help with flattening on X and Z and such

[21:00] <TimToady> maybe one for flattening args, and maybe another for slipping the result

[21:01] <TimToady> so like |X might slip the result, and _X or X_ might flatten the args

[21:01] <TimToady> or F, or whatever the bikeshed colors itself

[21:02] <AlexDaniel> m: say split(';', "a;b;c", :all).perl;

[21:02] <GLRelia> rakudo-moar bf657a: OUTPUT«Seq.new␤»

[21:02] <camelia> rakudo-moar 375435: OUTPUT«(("a", ";"), ("b", ";"), "c")␤»

[21:02] <AlexDaniel> hmmm

[21:02] <TimToady> arguably could be ("c",Nil) for the final

[21:03] <AlexDaniel> it really should be

[21:03] <dalek> roast/glr: 1ac5df1 | (Stefan Seifert)++ | S03-metaops/cross.t:

[21:03] <dalek> roast/glr: Adopt GLR semantics in S03-metaops/cross.t

[21:03] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/1ac5df177f

[21:03] <nine> PLEASE if you have any love at all for Perl 6 review this patch ^^^

[21:03] <vendethiel> nine: wouldn't "$policy(...)" be kinda hard to optimize anywya?

[21:04] <vendethiel> nine: why is it "flat @()" and not "flat ()"?

[21:04] <nine> vendethiel: I don't even know what it's for. I removed it and all spec tests for cross pass. And two more spec test files.

[21:04] <vendethiel> nine: I gather it used to be for flattening

[21:04] *** bin_005 left
[21:04] <vendethiel> m: say @(1, 2, (3, (4,))).elems; say (1, 2, (3, (4,))).elems

[21:04] <camelia> rakudo-moar 375435: OUTPUT«3␤3␤»

[21:04] <GLRelia> rakudo-moar bf657a: OUTPUT«3␤3␤»

[21:04] <vendethiel> nope!

[21:05] <nine> vendethiel: indeed, flat is enough, no need for @()

[21:05] <vendethiel> m: say (1..3 X 'a'..'b') #is that itemized for some reason? hence the need for @()

[21:05] <camelia> rakudo-moar 375435: OUTPUT«1 a 1 b 2 a 2 b 3 a 3 b␤»

[21:05] <GLRelia> rakudo-moar bf657a: OUTPUT«1 a 1 b 2 a 2 b 3 a 3 b␤»

[21:05] <TimToady> yes list infixes are tighter than list prefixes

[21:05] <vendethiel> m: say (1..3 X 'a'..'b').perl

[21:05] <GLRelia> rakudo-moar bf657a: OUTPUT«Seq.new␤»

[21:05] <camelia> rakudo-moar 375435: OUTPUT«(1, "a", 1, "b", 2, "a", 2, "b", 3, "a", 3, "b")␤»

[21:06] <dalek> roast/glr: c97a3a5 | (Stefan Seifert)++ | S03-metaops/cross.t:

[21:06] <dalek> roast/glr: Remove no longer needed @() in S03-metaops/cross.t

[21:06] <dalek> roast/glr: 

[21:06] <dalek> roast/glr: Thanks to vendethiel++ for pointing that out

[21:06] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c97a3a5b1b

[21:06] <TimToady> m: say (1..3 X 'a'..'b').gist

[21:06] <camelia> rakudo-moar 375435: OUTPUT«1 a 1 b 2 a 2 b 3 a 3 b␤»

[21:06] <GLRelia> rakudo-moar bf657a: OUTPUT«1 a 1 b 2 a 2 b 3 a 3 b␤»

[21:06] <vendethiel> nine: well, the commit goes way back: https://github.com/perl6/roast/commit/c876d65a785e6950c118b6bca6155d3d61d3e7db might've been cargo culting

[21:07] <TimToady> I think gist should be glrized a bit to show some parens

[21:08] <TimToady> either that, or .perl needs a mod/variant that forces eval of the front of a list

[21:09] <TimToady> currently .gist and .perl are tuned for non-glr flattening

[21:09] <nine> Ok, I'm going to remove all the $policy code from X and Meta X. I don't understand it and it seems to be hurting more than helping and if something is missing afterwards, we can maybe find a better solution anyway.

[21:10] <AlexDaniel> m: $_.perl.say for split(';', "aa;bb;cc", :all);

[21:10] <GLRelia> rakudo-moar bf657a: OUTPUT«("aa", ";")␤("bb", ";")␤"cc"␤»

[21:10] <camelia> rakudo-moar 375435: OUTPUT«("aa", ";")␤("bb", ";")␤"cc"␤»

[21:10] <AlexDaniel> m: $_[0].say for split(';', "aa;bb;cc", :all);

[21:10] <GLRelia> rakudo-moar bf657a: OUTPUT«aa␤bb␤cc␤»

[21:10] <camelia> rakudo-moar 375435: OUTPUT«aa␤bb␤cc␤»

[21:10] <AlexDaniel> wow

[21:10] <AlexDaniel> so [0] does nothing in this case

[21:11] <AlexDaniel> I've never thought about it

[21:11] <AlexDaniel> m: say 'test'[0][0][0][0];

[21:11] <GLRelia> rakudo-moar bf657a: OUTPUT«test␤»

[21:11] <camelia> rakudo-moar 375435: OUTPUT«test␤»

[21:12] <vendethiel> nine: nice!

[21:12] <vendethiel> TimToady: I read the backlog a bit, but I'm not sure I read the answer to this question: do you want "my @a = 1, @a" to be (1, 1, 1 ...) (à la haskell)?

[21:13] *** virtualsue left
[21:14] *** bin_005 joined
[21:14] <TimToady> not sure it makes sense with 'my' due to assignment semantic, but would certainly be nice if 'constant' could be self referential

[21:14] <dalek> rakudo-star-daily: d5ed494 | coke++ | log/MoarVM- (4 files):

[21:14] <dalek> rakudo-star-daily: today (automated commit)

[21:14] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d5ed4941ed

[21:14] <TimToady> and we might intuit a lazy if we see the same symbol on the left and right

[21:15] <TimToady> haskell obviously never needs to have explicit lazy, since everything already is...

[21:17] <dalek> rakudo/glr: 44cb3de | (Stefan Seifert)++ | src/core/ (2 files):

[21:17] <dalek> rakudo/glr: Remove dubious $policy from X and Meta-X.

[21:17] <dalek> rakudo/glr: 

[21:17] <dalek> rakudo/glr: It seems to be hurting more than helping and if something is missing afterwards,

[21:17] <dalek> rakudo/glr: we can maybe find a better solution anyway

[21:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/44cb3de1a5

[21:17] <nine> 261/1047 spec test files failing in glr

[21:17] <nine> The only test failing in cross.t now is not ok 27 - [] does not flatten

[21:18] <nine> is ([1,2] X~ <a b>), '1 2a 1 2b', '[] does not flatten';

[21:19] *** araujo joined
[21:19] <AlexDaniel> TimToady: half way through reporting it I'm realizing that ("c", Nil) is not really better

[21:20] <TimToady> okay, was just an idle thought

[21:21] <nine> jnthn: is ([1,2] X~ <a b>), '1 2a 1 2b', '[] does not flatten'; cannot work with the nqp::istype(elem, Iterable) distinction between item and list because no matter how much you itemize [1,2], it will stay Iterable and thus be iterated over.

[21:21] <ugexe> ===> Install OK for: XML # xml already works glr

[21:21] <vendethiel> nine: I think jnthn has gone to sleep

[21:21] <nine> .tell jnthn is ([1,2] X~ <a b>), '1 2a 1 2b', '[] does not flatten'; cannot work with the nqp::istype(elem, Iterable) distinction between item and list because no matter how much you itemize [1,2], it will stay Iterable and thus be iterated over.

[21:21] <yoleaux> nine: I'll pass your message to jnthn.

[21:21] <nine> vendethiel: thanks

[21:22] * nine should do the same

[21:22] <TimToady> right, by the one-arg rule

[21:22] <AlexDaniel> if you shove Nil there, then any code that is using delimiters should always check for Nil. But without Nil, you can sometimes just forget about it (e.g. iterate over every even element or something)

[21:22] *** virtualsue joined
[21:22] <AlexDaniel> I could be wrong but that's not a problem for me, at least

[21:23] <TimToady> well, probably is bound to an optional at some point, so can be missing

[21:24] <nine> TimToady: so, should I just remove the test as bogus?

[21:24] <TimToady> or put $[1,2] there

[21:24] <nine> TimToady: that doesn't help with the current implementation, because $[1,2] is still iterable.

[21:24] <TimToady> ah, right

[21:25] <nine> TimToady: and nqp::istype(elem, Iterable) is the way jnthn++ showed me how to do it

[21:25] <TimToady> so it'd have to be ([1,2],) or so

[21:25] <TimToady> we probably need a prefix form of that

[21:25] <nine> ([1,2],) would give the desired result

[21:25] <TimToady> not sure prefix:<,> would be a good idea though

[21:26] *** vike joined
[21:27] <smls> isn't that what &list does?

[21:27] <TimToady> m: say @$[1,2] X~ <a b>

[21:27] <GLRelia> rakudo-moar 44cb3d: OUTPUT«1a 1b 2a 2b␤»

[21:27] <camelia> rakudo-moar 375435: OUTPUT«Use of Nil in string context  in block <unit> at /tmp/PQSmh1z8P4:1␤Use of Nil in string context  in block <unit> at /tmp/PQSmh1z8P4:1␤Use of Nil in string context  in block <unit> at /tmp/PQSmh1z8P4:1␤Use of Nil in string context  in block <unit> at …»

[21:27] <dalek> roast/glr: 3ad246c | (Stefan Seifert)++ | S03-metaops/cross.t:

[21:27] <dalek> roast/glr: Fix remaining S03-metaops/cross.t test

[21:27] <dalek> roast/glr: 

[21:27] <dalek> roast/glr: According to the one-arg rule, [1,2] passed to meta-X has to flatten.

[21:27] <dalek> roast/glr: Have to use ([1,2],) to avoid that.

[21:27] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/3ad246c3c3

[21:27] <nine> Now only 260/1047 spec test files failing :)

[21:28] *** rurban_ left
[21:28] *** vike left
[21:29] *** brrt left
[21:31] *** Averna left
[21:32] *** Averna joined
[21:36] <pyrimidine> nine++ # glr fixes

[21:39] *** MadcapJake joined
[21:39] *** bin_005 left
[21:40] *** virtualsue_ joined
[21:42] *** bin_005 joined
[21:42] *** virtualsue left
[21:42] *** virtualsue_ is now known as virtualsue

[21:44] *** yqt joined
[21:48] *** diana_olhovik left
[21:51] *** MadcapJake left
[21:52] *** bin_005 left
[22:13] *** TEttinger joined
[22:17] *** bbkr joined
[22:17] *** breinbaas left
[22:18] *** skids joined
[22:19] *** MadcapJake joined
[22:22] *** Zoffix joined
[22:26] *** Woodi joined
[22:26] <smls> Looks like Pod::To::HTML fails a test on nom. Can anyone confirm?

[22:26] <bbkr> I was processing nested data structures in parallel and I encountered interesting deadlock. Here is the gist: https://gist.github.com/bbkr/78e048b94f9fb622e3a6 . Basically it is recursive "do await for { start { } }" construct. It works fine for small data structures, but if it wants to spawn more Promises at the same time than available threads this code never ends. Is my approach faulty or is it Rakudo bug?

[22:27] *** llfourn joined
[22:30] *** telex joined
[22:31] *** llfourn left
[22:31] *** smls_ joined
[22:32] *** smls left
[22:35] *** Averna left
[22:38] <smls_> bbkr: I think that's to be expected with a thread pool scheduler

[22:38] <smls_> not sure though

[22:39] *** smls_ is now known as smls

[22:41] *** virtualsue left
[23:01] <skids> m: my $a = (1,).iterator; while $a.pull-one -> $it { say join " ", $it.WHICH, IterationEnd.WHICH, ($it.WHICH =:= IterationEnd.WHICH) ; last if $++ == 1; }

[23:01] <GLRelia> rakudo-moar 44cb3d: OUTPUT«Int|1 Mu|39768080 False␤Mu|39768080 Mu|39768080 False␤»

[23:01] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DkOLOdv2uD␤Undeclared name:␤    IterationEnd used at line 1␤␤»

[23:02] <skids> Ah, binding.

[23:02] *** captain-adequate left
[23:05] <skids> m: my $a = (1,).iterator; while $a.pull-one -> $it { say join " ", $it.WHICH, IterationEnd.WHICH, ($it =:= IterationEnd) ; last if $++ == 1; }

[23:05] <GLRelia> rakudo-moar 44cb3d: OUTPUT«Int|1 Mu|52600704 False␤Mu|52600704 Mu|52600704 False␤»

[23:05] <camelia> rakudo-moar 375435: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nSv1WVu7BU␤Undeclared name:␤    IterationEnd used at line 1␤␤»

[23:06] <skids> Aha.  -e you bastard.

[23:06] <skids> That's what I thought from the start.

[23:12] <bbkr> smls: I think I understand this Promise deadlock now. Promises are created for first and second level of recursion in parallel. And when first level manage to create 16 of them there is no free thread to process promises on second level required by first level.

[23:12] *** yqt left
[23:16] <bbkr> smls: but I still don't know what is the best pattern for parallel recursive processing. gotta dig through the smarter "no pictures of cats here" part of the internet

[23:19] * timotimo has reached home safely

[23:25] *** spider-mario left
[23:27] <japhb> smls: Please consider turning https://gist.github.com/smls/a1f6033c142202bddc4d into benchmarks in https://github.com/japhb/perl6-bench

[23:28] <japhb> smls: This would probably give me good incentive to implement easier comparison of results between related tests.

[23:28] <timotimo> i would like that feature

[23:29] <japhb> Yeah, you've been wanting that for quite a while.  It's just never quite risen enough in priority.

[23:30] <smls> bbkr: Sounds about right. Not sure about the best solution. Maybe you can factor out the recursion and feed a flat list to the loop that calls 'start'?

[23:31] <smls> japhb: I alrerady did, back in June... :P  It's the rc-perfect-shuffle benchmark.

[23:31] <smls> japhb: Or did you mean having multiple benchmarks for the different variants?

[23:31] <timotimo> japhb: right; no worries, though

[23:32] <japhb> smls: Yes, that (multiple benchmarks for different variants).  Right now there's no easy way to templatize variants (if this gets to be a major demand, I would consider it), so they need to be created as multiple separate tests.

[23:38] <timotimo> i'm going to bed now.

[23:40] <dalek> perl6-examples: fc16c64 | (Flavio Poletti)++ | categories/euler/prob025-polettix.pl:

[23:40] <dalek> perl6-examples: bigints are now available... yay!

[23:40] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/fc16c647d8

[23:58] *** aborazmeh joined
[23:58] *** aborazmeh left
[23:58] *** aborazmeh joined
