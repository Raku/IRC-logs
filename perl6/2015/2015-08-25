[00:00] <dalek> ecosystem: f5886bd | tony-o++ | META.list:

[00:00] <dalek> ecosystem: adding json::faster 

[00:00] <dalek> ecosystem: 

[00:00] <dalek> ecosystem: provides a significantly faster `to-json` method

[00:00] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f5886bd568

[00:04] <ShimmerFairy> cbk1090: by the way, the  /<!URL> ./  part can be written as  /<-URL>/  . I just didn't write it that way since I wasn't quite sure of <-rule>'s behavior when I wrote that example :)

[00:05] <cbk1090> ShimmerFairy, ok I don't think <!URL> works because the program just hangs...? I'll try the other way..

[00:05] *** raiph joined
[00:06] <ugexe> use Grammar::Tracer; (needs to be installed) and you will get a nice output of what the grammar is doing 

[00:07] <cbk1090> ShimmerFairy, That was it!  Thanks mucho!

[00:07] <cbk1090> ugexe, Ok I'll try that soon.

[00:07] <ShimmerFairy> cbk1090: considering the <-URL> version worked, did you forget the dot after <!URL> ?

[00:08] <tony-o> grammar::tracer is amazing for debugging grammars

[00:08] <ShimmerFairy> cbk1090: important to note that you get Grammar::Tracer via  panda install Grammar::Debugger  , assuming you use panda of course :)

[00:09] <cbk1090> yes I'll use panda. But why is it important to do it like that not not just install by hand?

[00:10] <ugexe> he means the name of the distribution is actually Grammar::Debugger (which contains Grammar::Tracer)

[00:10] <cbk1090> Oh

[00:11] <ShimmerFairy> yeah, panda doesn't know how to find packages based on a module you want, which I'd be surprised if it never did.

[00:12] <ugexe> soon im hoping to see like $cpan-or-ecosystem.candidates(whatever)

[00:13] <ShimmerFairy> ugexe: by the way, whoever "he" is, he apparently meant the same thing with his suggestion that I did with my suggestion :P

[00:15] <tony-o> ShimmerFairy: there isn't a gender associated with 'he' in some parts of the us, we just refer to people that way if we don't know 

[00:16] <tony-o> a group of people is 'you guys' even if there are women or whatever

[00:16] <ShimmerFairy> tony-o: I'm well aware of English being male-default, and don't mind it, I just wanted to offer a correction in any case :)

[00:17] <tony-o> it'd probably be more helpful if you wanted ugexe to refer to as some other pronoun

[00:18] * ShimmerFairy personally uses singular 'they', over-corrective grammarians be damned, so she doesn't confer a default gender on someone

[00:19] <ShimmerFairy> tony-o: true, I just wanted to be a bit nicer/more subtle about it than "hey, I'm a 'she'", though it of course is more direct :)

[00:20] <TimToady> ShimmerFairy: but singular 'they' is so newfangled, why, it wasn't introduced till like the 16th century!

[00:21] <tony-o> personally, i'm a 12/13th century kind of guy

[00:21] <TimToady> My Hobby: following prescriptive grammarians around and catching them using singular 'they' without realizing it

[00:21] <tony-o> mongols win

[00:21] <ShimmerFairy> TimToady: precisely why I think the grammarians are over-corrective :P . I also think it's perfectly to end sentences in prepositions, since that's a valid position for any word to be in. And if those infinitives would rather not be split, they need to surely be a one word construct.

[00:22] <ShimmerFairy> *perfectly fine

[00:23] <tony-o> i follow TimToady around and just call everything 'they'

[00:23] <ShimmerFairy> TimToady: it's interesting that we have precedent for taking a plural into the singular (which is why I used "themself" like "yourself", despite wikipedia claiming "themself" is relatively less standard than the other parts of singular they)

[00:23] * skids feels validated about using 'they' most of the time.

[00:24] <TimToady> if anyone doesn't, they should feel ashamed

[00:24] <ShimmerFairy> TimToady: I honestly wouldn't be surprised if someday in the future the royal 'we' (or I guess "corporate 'we'" in modern context) got the same treatment, and it became the singular 1st person pronoun as well :)

[00:24] <tony-o> TimToady: nice

[00:25] <TimToady> then there's the editorial 'we' that means 'you' :)

[00:25] <tony-o> i call that one the managerial 'we'

[00:25] <ugexe> you are missing out on the interesting world of ebonics

[00:25] <tony-o> 'we' need to do this work, meaning 'i need you to get this work done'

[00:26] <ShimmerFairy> TimToady: My other real prediction for English's future is that someday we'll forget the / in "and/or", and then we'll finally have a word for inclusive or: "andor".

[00:26] <TimToady> well, but the manager is planning to take credit :)

[00:26] <tony-o> if you have a bad manager, yea

[00:26] *** laouji joined
[00:27] <cbk1090> So I keep getting "Type check failed in binding $filename; expected 'Cool' but got 'IO::Handle' "

[00:27] <cbk1090> when I try and do this: my $match = url::Grammar.parsefile($fh);

[00:27] <ShimmerFairy> .oO("we need to do the work" means "you" to the employees and "I" to the superiors :P)

[00:27] <ugexe> a filename, not a file handle

[00:28] <ShimmerFairy> Although I don't think it'd be a bad idea for .parsefile to accept a file handle, now that it's come up.

[00:28] <cbk1090> here is how I open the file: $fh = open( 'inputFile.dat', :r); 

[00:28] <ugexe> it would be nice if the error mentioned Str(Cool) or somehow mentioned Str instead of cool

[00:29] <tony-o> cbk1090: pass url::Grammar.parsefil('inputFile.dat')

[00:29] <tony-o> but spell everything correctly

[00:29] <cbk1090> tony-o, ok....

[00:29] <ShimmerFairy> ugexe: maybe  "expected 'Cool' (that will be converted to 'Str')" ?  (maybe adding "via .Str" after 'Str')

[00:32] <ugexe> that would make some things more clear to the fresh meat i think

[00:32] <skids> "Expected to convert Cool to Str, but got a... " maybe?

[00:34] <TimToady> .tell laben >>op<< is intended primarily for finite, equal-sized arrays/matrices/vectors; there's little point in duplicating Z's behavior here

[00:34] <yoleaux> TimToady: I'll pass your message to laben.

[00:35] <ShimmerFairy> ugexe: like mentioned above, I think we could stand to have messages that weren't so insistent on being terse (once I make my Pod parser public, which'll hopefully be soon, I think I have a couple of nice examples)

[00:37] <skids> I just tend to avoid parens when possible in those, unless it's just around a very short visual pill.

[00:37] <ShimmerFairy> m: sub foo(Int ::INTEGER $a, INTEGER(Cool) $b) { say "OK!" }; foo(1, "2"); # something I noticed a while back. A bug, I would hope

[00:37] <GLRelia> rakudo-moar d7ab32: OUTPUT«Method 'INTEGER' not found for invocant of class 'Str'␤  in sub foo at /tmp/ekIbB4ek0A:1␤  in block <unit> at /tmp/ekIbB4ek0A:1␤␤»

[00:37] <camelia> rakudo-moar f7cfe9: OUTPUT«Method 'INTEGER' not found for invocant of class 'Str'␤  in sub foo at /tmp/Z1H6Vn1mhO:1␤  in block <unit> at /tmp/Z1H6Vn1mhO:1␤␤»

[00:39] <skids> I think when I noticed that jnthn said something like "damn I was hoping nobody would try that" and it would be a while before that worked.

[00:39] *** laouji left
[00:40] *** laouji joined
[00:40] <ShimmerFairy> skids: I can see why that'd be a pain, considering the implementation is Cool.INTEGER atm :)

[00:40] <ShimmerFairy> m: sub foo(Int ::INTEGER $a) { say "5".INTEGER }; foo(1);

[00:40] <GLRelia> rakudo-moar d7ab32: OUTPUT«Method 'INTEGER' not found for invocant of class 'Str'␤  in sub foo at /tmp/DBMmLHklY9:1␤  in block <unit> at /tmp/DBMmLHklY9:1␤␤»

[00:40] <camelia> rakudo-moar f7cfe9: OUTPUT«Method 'INTEGER' not found for invocant of class 'Str'␤  in sub foo at /tmp/3yIOY999bj:1␤  in block <unit> at /tmp/3yIOY999bj:1␤␤»

[00:41] <ShimmerFairy> m: sub foo(Int ::INTEGER $a) { say INTEGER.new("5") }; foo(1);

[00:41] <GLRelia> rakudo-moar d7ab32: OUTPUT«This type cannot unbox to a native integer␤  in sub foo at /tmp/vufdctKWaR:1␤  in block <unit> at /tmp/vufdctKWaR:1␤␤»

[00:41] <camelia> rakudo-moar f7cfe9: OUTPUT«This type cannot unbox to a native integer␤  in sub foo at /tmp/qTgCm1vGa7:1␤  in block <unit> at /tmp/qTgCm1vGa7:1␤␤»

[00:42] *** laouji left
[00:42] *** laouji joined
[00:43] *** rurban joined
[00:43] <ShimmerFairy> m: sub foo(Int ::INTEGER $a) { say "2"."{INTEGER.^name}"() }; foo(1)

[00:43] <GLRelia> rakudo-moar d7ab32: OUTPUT«2␤»

[00:43] <camelia> rakudo-moar f7cfe9: OUTPUT«2␤»

[00:43] <ShimmerFairy> ^ skids: well, there's one (terrible) way to do it :P

[00:49] <ShimmerFairy> m: sub foo(Int ::INTEGER $a) { say "2".$(INTEGER.WHAT) }; foo(1)  # slightly less bad

[00:49] <GLRelia> rakudo-moar d7ab32: OUTPUT«2␤»

[00:49] <camelia> rakudo-moar f7cfe9: OUTPUT«2␤»

[00:51] *** adu joined
[00:53] *** llfourn joined
[00:57] *** adu left
[00:58] *** llfourn left
[01:00] *** aborazmeh joined
[01:00] *** aborazmeh left
[01:00] *** aborazmeh joined
[01:10] *** rangerprice joined
[01:10] <rangerprice> Hi

[01:10] <Zoffix> \o

[01:14] *** amurf left
[01:22] *** Peter_R left
[01:37] *** dayangkun joined
[01:43] *** rurban left
[01:56] *** aborazmeh left
[01:59] *** adu joined
[01:59] <dalek> ecosystem: d5a2d88 | retupmoca++ | META.list:

[01:59] <dalek> ecosystem: Steal Text::Markdown name from masak.

[01:59] <dalek> ecosystem: 

[01:59] <dalek> ecosystem: As per IRC Logs 2015-05-28. This is somewhat delayed, so please revert if this

[01:59] <dalek> ecosystem: is now unneeded.

[01:59] <dalek> ecosystem: 

[01:59] <dalek> ecosystem: While not yet a 100% implementation, this module implements more Markdown than

[01:59] <dalek> ecosystem: the current one.

[01:59] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/d5a2d88015

[01:59] *** llfourn joined
[02:00] <adu> raydiak: hey

[02:04] *** raiph left
[02:09] *** raiph joined
[02:16] *** vendethiel joined
[02:21] *** noganex_ joined
[02:23] *** noganex left
[02:24] *** rangerprice left
[02:32] <raydiak> \o adu 

[02:32] <adu> o/

[02:32] <adu> how goes?

[02:33] <raydiak> not bad...working more than anything else lately...you?

[02:34] *** khw joined
[02:36] <adu> yeah, same

[02:38] <labster> that sounds suspiciously similar to my life

[02:41] <raydiak> seems to be a common situation :)

[02:45] *** dwarring joined
[02:52] *** yqt left
[02:52] <dalek> roast/glr: 4626a7d | (David Warring [email@hidden.address] | integration/advent2012-day (2 files):

[02:52] <dalek> roast/glr: GLR flattening in 2010 advent days 10 & 21

[02:52] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/4626a7d8dd

[02:54] * dwarring  ^^ s/2010/2012/

[02:54] *** mohij_ joined
[02:58] *** mohij left
[03:02] *** kaare_ joined
[03:16] *** raiph left
[03:19] *** raiph joined
[03:21] *** rangerprice joined
[03:23] *** adu left
[03:24] *** yeahnoob joined
[03:36] *** vendethiel left
[03:46] *** laouji left
[04:01] <dalek> roast/glr: 57cb607 | (David Warring [email@hidden.address] | integration/99problems-01-to-10.t:

[04:01] <dalek> roast/glr: GLRify 99problems-01-to-10.t

[04:01] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/57cb6070eb

[04:05] *** aborazmeh joined
[04:05] *** aborazmeh left
[04:05] *** aborazmeh joined
[04:05] *** telex left
[04:06] *** telex joined
[04:10] *** davercc joined
[04:14] *** rangerprice left
[04:17] *** AlexDaniel left
[04:41] <dalek> roast/glr: 698541c | (David Warring [email@hidden.address] | integration/99problems-11-to-20.t:

[04:41] <dalek> roast/glr: GLRify 99problems-11-to-20.t

[04:41] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/698541c07f

[04:44] *** diana_olhovik joined
[04:46] *** khw left
[04:52] *** laouji joined
[04:54] *** skids left
[05:06] *** espadrine joined
[05:14] *** araujo_ left
[05:18] *** diana_olhovik left
[05:19] *** laouji left
[05:19] *** laouji joined
[05:20] *** araujo joined
[05:20] *** araujo left
[05:29] *** cbk1090 left
[05:35] *** araujo joined
[05:35] *** araujo left
[05:56] <moritz> \o

[05:56] <moritz> m: sink map { .say }, 1..4

[05:56] <GLRelia> rakudo-moar d7ab32: ( no output )

[05:56] <camelia> rakudo-moar f7cfe9: OUTPUT«1␤2␤3␤4␤»

[05:59] *** rurban joined
[06:07] *** diana_olhovik_ joined
[06:11] *** brrt joined
[06:12] *** xzenfar joined
[06:13] *** ggherdov left
[06:14] *** colomon left
[06:18] *** CQ2 joined
[06:22] *** ggherdov joined
[06:27] <moritz> m: say (map { .say }, 1..4).^name

[06:27] <GLRelia> rakudo-moar d7ab32: OUTPUT«Seq␤»

[06:27] <camelia> rakudo-moar f7cfe9: OUTPUT«List␤»

[06:27] <moritz> m: say (map { .say }, 1..4).sink

[06:27] <GLRelia> rakudo-moar d7ab32: OUTPUT«1␤2␤3␤4␤Nil␤»

[06:27] <camelia> rakudo-moar f7cfe9: OUTPUT«1␤2␤3␤4␤Nil␤»

[06:27] <moritz> huh, sink statement prefix doesn't call .sink anymore?

[06:28] *** xfix joined
[06:28] <moritz> huh, sink calls .eager

[06:28] <moritz> and eager isn't eager

[06:29] *** salva joined
[06:34] <moritz> ... and changing it to calling .sink makes session compilation loop/nhang

[06:36] <masak> morning, #perl6

[06:37] <moritz> good morning, masak

[06:41] *** zakharyas joined
[06:44] <nine> dwarring++ # plowing through those advent spec tests

[06:45] <nine> moritz: I think we have enough evidence now that we need to make .eager really eager

[06:46] <dalek> rakudo/glr: d747af1 | (Stefan Seifert)++ | src/core/native_array.pm:

[06:46] <dalek> rakudo/glr: Make array.new behave like Array.new WRT flattening of args

[06:46] <dalek> rakudo/glr: 

[06:46] <dalek> rakudo/glr: 22:30 < nine> jnthn: array.new takes *@values while Array.new takes **@values.

[06:46] <dalek> rakudo/glr:               Which one is right?

[06:46] <dalek> rakudo/glr: 22:30 < jnthn> **

[06:46] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d747af1b33

[06:47] *** jkva joined
[06:49] *** [Tux] left
[06:49] *** [Tux] joined
[06:50] *** araujo joined
[06:51] *** araujo left
[06:52] *** araujo joined
[06:52] *** araujo left
[06:52] *** araujo joined
[06:52] *** araujo left
[06:57] *** domidumont joined
[07:01] *** domidumont left
[07:01] *** domidumont joined
[07:04] *** [Sno] left
[07:06] *** [Sno] joined
[07:07] *** abraxxa joined
[07:07] *** Ven joined
[07:10] *** laben joined
[07:10] <laben> hello p6'ers

[07:10] <yoleaux> 00:34Z <TimToady> laben: >>op<< is intended primarily for finite, equal-sized arrays/matrices/vectors; there's little point in duplicating Z's behavior here

[07:15] <moritz> nine: http://hack.p6c.org/~moritz/0001-Make-eager-actually-eager-not-just-a-promise-to-be-e.patch is my current attempt

[07:17] <moritz> nine: the test that regresses is  my @res = (one X @two)[^20], which dies with "this Seq has already been iterated"

[07:19] <dalek> book: 7998e63 | (Steve Mynott)++ | src/classes-and-objects.pod:

[07:19] <dalek> book: fix minor typos

[07:19] <dalek> book: review: https://github.com/perl6/book/commit/7998e63bec

[07:19] <dalek> book: a5f3c17 | moritz++ | src/classes-and-objects.pod:

[07:19] <dalek> book: Merge pull request #84 from stmuk/master

[07:19] <dalek> book: 

[07:19] <dalek> book: fix minor typos

[07:19] <dalek> book: review: https://github.com/perl6/book/commit/a5f3c17f2d

[07:23] *** darutoko joined
[07:28] *** mr-foobar left
[07:28] <masak> I think https://www.webkit.org/blog/3846/ will be of interest to some here; especially the bit about compilers at the end.

[07:29] *** araujo joined
[07:30] <nine> moritz: I cannot reproduce an error there? Tried my @one = 1, 2; my @two = 1, 2; my @res = (@one X @two)[^20]; say @res.perl; and I get [$(1, 1), $(1, 2), $(2, 1), $(2, 2)] with your patch applied

[07:30] *** araujo left
[07:31] <moritz> nine: one is a Seq in that test, not an array

[07:31] <moritz> nine: just run t/spec/S02-types/lazy-lists.t with my patch applied

[07:35] <nine> moritz: I wonder if it's really your patch's fault or METAOP_CROSS'

[07:37] <nine> err... infix:<X> of course

[07:38] <moritz> huh

[07:39] <moritz> infix:<X>(|lol) { begins with   if lol.hash { ... }

[07:39] <moritz> it tries to coerce its argument list to hash?

[07:39] <nine> lol is a Capture, isn't it?

[07:40] <nine> It's just looking for adverbs, though I didn't know you could adverb infix operators

[07:40] <moritz> oh, right

[07:40] <moritz> you can, they just go after the right arg, or something like

[07:41] <moritz> m: say 1 + 4:weird

[07:41] <GLRelia> rakudo-moar d747af: OUTPUT«Unexpected named parameter 'weird' passed␤  in block <unit> at /tmp/0BgAUq7RmU:1␤␤»

[07:41] <camelia> rakudo-moar f7cfe9: OUTPUT«Unexpected named parameter 'weird' passed␤  in block <unit> at /tmp/73GMn2FhHb:1␤␤»

[07:46] <nine> infix:<X> is not changed much from the implementation in nom. It even uses .elems which I see as a bad sign.

[07:46] <moritz> and it uses eager, fwiw

[07:48] <nine> And it was one of the first things I worked at. I really didn't know what I was doing back then :)

[07:52] <masak> I've heard lots of people say such a thing over the years :)

[07:53] <masak> yes, infix:<X> should be at least partly lazy.

[07:53] <moritz> infix:<X> should ba lazy in the first argument

[07:53] <masak> right

[07:54] <masak> m: constant ll := gather { say "lazy"; take 1; say "so lazy"; take 2 }; say "OH HAI"; say ll[0]

[07:54] <GLRelia> rakudo-moar d747af: OUTPUT«OH HAI␤lazy␤1␤»

[07:54] <camelia> rakudo-moar f7cfe9: OUTPUT«OH HAI␤lazy␤1␤»

[07:54] <nine> And it should collect the other argument's values in IterationBuffers unless it _knows_ that it can access them multiple times

[07:54] <masak> m: constant ll := gather { say "lazy"; take 1; say "so lazy"; take 2 }; say "OH HAI"; say ll X <a b c>

[07:54] <GLRelia> rakudo-moar d747af: OUTPUT«OH HAI␤lazy␤so lazy␤1 a 1 b 1 c 2 a 2 b 2 c␤»

[07:54] <camelia> rakudo-moar f7cfe9: OUTPUT«OH HAI␤lazy␤so lazy␤1 a 1 b 1 c 2 a 2 b 2 c␤»

[07:55] <moritz> m: my \seq = <a b c>.sort; say seq X 1, 2

[07:55] <GLRelia> rakudo-moar d747af: OUTPUT«a 1 a 2 b 1 b 2 c 1 c 2␤»

[07:55] <camelia> rakudo-moar f7cfe9: OUTPUT«a 1 a 2 b 1 b 2 c 1 c 2␤»

[07:56] *** lizmat joined
[07:57] *** cgfbee left
[08:01] *** araujo joined
[08:01] *** araujo left
[08:01] *** araujo joined
[08:01] * Ven waves at #perl6 – o/

[08:02] *** RabidGravy joined
[08:05] <masak> \o

[08:08] <lizmat> good *, #perl6 from Home

[08:08] <yoleaux> 24 Aug 2015 09:30Z <jnthn> lizmat: I'd be tempted ot say that emit NEVER tries to iterate anything and just emits what it's given verbatim :)

[08:09] <lizmat> m: my @a; sub a(\a) { @a.push(a) }; a 1..10; say @a.perl   # how do we fix this ?

[08:09] <camelia> rakudo-moar f7cfe9: OUTPUT«[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<>␤»

[08:09] <GLRelia> rakudo-moar d747af: OUTPUT«[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[08:09] <lizmat> fwiw, I expected to see [1..10] there

[08:12] *** cgfbee joined
[08:16] <moritz> lizmat: maybe https://github.com/rakudo/rakudo/pull/512 fixe it?

[08:17] <lizmat> perhaps, but I'd like to see jnthn's opinion on that PR first

[08:17] <lizmat> I mean, this is one of the WAT's of the one argument rule

[08:17] <lizmat> m: my @a; sub a(\a) { @a.push(a) }; a (1..10,); say @a.perl  # does this fix?

[08:17] <camelia> rakudo-moar f7cfe9: OUTPUT«[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<>␤»

[08:17] <GLRelia> rakudo-moar d747af: OUTPUT«[1..10]␤»

[08:18] <lizmat> so yes, that does fix it, but it transfers responsibility to the user, not to the lib writer

[08:19] <lizmat> I mean, a sig like (\a) can't get much untouchable than that, still it is touched by the rule

[08:20] <moritz> it is?

[08:20] <lizmat> I don't see how I can write sub a in such a way that "NEVER tries to iterate anything and just emits what it's given verbatim"

[08:20] <moritz> m: sub f(\a) { say a.perl }; f 1..3

[08:20] <GLRelia> rakudo-moar d747af: OUTPUT«1..3␤»

[08:20] <camelia> rakudo-moar f7cfe9: OUTPUT«1..3␤»

[08:20] <moritz> doesn't seem touched.

[08:20] *** rurban left
[08:21] <moritz> sub identity(\thing) { thing }

[08:21] <moritz> never tries to iterate anything

[08:22] <moritz> well, might need 'is rw' to be a try identity

[08:23] <lizmat> \a is rw ?

[08:23] <moritz> sub identity(\thing) is rw { thing }

[08:23] <lizmat> isn't that like double ?

[08:23] <lizmat> ah

[08:23] *** jkva left
[08:24] <lizmat> hmmm...

[08:25] *** jkva joined
[08:25] *** sno joined
[08:26] *** [Sno] left
[08:27] <moritz> ok, creeping; returning a Seq in a map block causes it to be iterated

[08:27] <moritz> m: my @seqs = map { <a b c>.sort }, 1, 2; .say for @seqs[0]

[08:27] <GLRelia> rakudo-moar d747af: OUTPUT«a␤b␤c␤»

[08:27] <camelia> rakudo-moar f7cfe9: OUTPUT«a␤»

[08:27] <moritz> or not?

[08:27] <moritz> now I'm confused

[08:28] <moritz> m: say <a b c>.sort.^name

[08:28] <camelia> rakudo-moar f7cfe9: OUTPUT«Parcel␤»

[08:28] <GLRelia> rakudo-moar d747af: OUTPUT«Seq␤»

[08:28] *** rurban joined
[08:29] *** dakkar joined
[08:29] *** KCL_ joined
[08:31] <moritz> oh, not if it's itmized

[08:31] <moritz> m: my \s = map { $_ }, 1, 2, 3; say s.^name; .say for (map { s }, 1)[0]

[08:31] <GLRelia> rakudo-moar d747af: OUTPUT«Seq␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/IimJ7dpyxr:1␤␤»

[08:31] <camelia> rakudo-moar f7cfe9: OUTPUT«List␤1␤»

[08:31] <moritz> m: my \s = map { $_ }, 1, 2, 3; say s.^name; .say for (map { s.item }, 1)[0]

[08:31] <GLRelia> rakudo-moar d747af: OUTPUT«Seq␤1␤2␤3␤»

[08:31] <camelia> rakudo-moar f7cfe9: OUTPUT«List␤1 2 3␤»

[08:32] <moritz> is that intentional?

[08:32] *** KCL left
[08:32] <moritz> I thought only a Slip would do that

[08:32] <lizmat> moritz: consider me confused...

[08:32] <lizmat> but that can very well be attributed to jet lag and lack of sleep in general

[08:33] <lizmat> if not age  :-)

[08:33] *** |Tux| joined
[08:33] <moritz> lizmat: confused by the current behavior? Or confused by what I said?

[08:33] <moritz> lizmat: or by the push thingy?

[08:33] <masak> lizmat! \o/

[08:34] <masak> welcome back to Europe :)

[08:34] <lizmat> moritz: by the push thing

[08:34] <lizmat> masak o/

[08:34] <lizmat> yeah, much better weather here  :-)

[08:34] <lizmat> .oO( until we hid Grenada )

[08:34] <moritz> lizmat: I think you were confused about where the Range is flattened out into a list; it's not by the parameter binding, but by @array.push

[08:34] <lizmat> *hit

[08:34] <lizmat> yeah, I get that now

[08:35] <lizmat> but in the case of emit not being able to emit a Range, there I still don't see where the iteration happens

[08:35] <moritz> which emit?

[08:35] <lizmat> I mean, emit is basically:

[08:35] * moritz lacks context

[08:36] <masak> "hit Granada" sounds exceptionally painful.

[08:36] <lizmat>     method emit(Supply:D: \msg) { if self.tappers -> \tappers { .emit().(msg) for tappers }

[08:36] <lizmat> nothing iterating there, afaics

[08:37] <lizmat> aaaaahhhhh  the plot thickens... (I think)

[08:37] <lizmat> lemme check some things

[08:37] <laben> lizmat: if the tappers got *@a signature, it's flattened/iterated, no?

[08:38] <lizmat> yeah, but that's not about the values being emitted, that's just about which taps to serve

[08:39] <laben> m: sub foo(*@m) { for ^@m {.say}}; foo(1..10)

[08:39] <GLRelia> rakudo-moar d747af: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[08:39] <camelia> rakudo-moar f7cfe9: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[08:39] <laben> m: sub foo(**@m) { for ^@m {.say}}; foo(1..10)

[08:39] <GLRelia> rakudo-moar d747af: OUTPUT«0␤»

[08:39] <camelia> rakudo-moar f7cfe9: OUTPUT«0␤»

[08:40] <moritz> m: sub foo(**@m) { for @m {.say}}; foo(1..10)

[08:40] <GLRelia> rakudo-moar d747af: OUTPUT«1..10␤»

[08:40] <camelia> rakudo-moar f7cfe9: OUTPUT«1..10␤»

[08:43] <moritz> m: sub foo(**@m) { say @m.elems }; foo(1..10)

[08:43] <GLRelia> rakudo-moar d747af: OUTPUT«1␤»

[08:43] <camelia> rakudo-moar f7cfe9: OUTPUT«1␤»

[08:44] <dalek> rakudo/glr: 48791be | moritz++ | src/core/ (3 files):

[08:44] <dalek> rakudo/glr: Make eager actually eager, not just a promise to be eager later on

[08:44] <dalek> rakudo/glr: 

[08:44] <dalek> rakudo/glr: also both List.eager and Seq.eager return a List now.

[08:44] <dalek> rakudo/glr: This causes a regression in S02-types/lazy-lists.t, but makes

[08:44] <dalek> rakudo/glr: "try { eager map { die }, 1 }" work.

[08:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/48791beedd

[08:44] <dalek> rakudo/glr: 90d45ed | moritz++ | src/core/List.pm:

[08:44] <dalek> rakudo/glr: More idiomatic use of eager

[08:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/90d45ed487

[08:44] <dalek> rakudo/glr: 508d223 | moritz++ | src/core/List.pm:

[08:44] <dalek> rakudo/glr: Fix infix:<X> with Seq as first argument

[08:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/508d223398

[08:44] <dalek> rakudo/glr: ab408b1 | moritz++ | src/core/Seq.pm:

[08:44] <dalek> rakudo/glr: add Seq.is-ready for debugging purposes

[08:44] <dalek> rakudo/glr: 

[08:44] <dalek> rakudo/glr: it returns False if this Seq has already been iterated

[08:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ab408b1084

[08:48] <laben> mybe a better name would be already-consumed or is-done or is-produced...

[08:49] <lizmat> .oO( dog in the pot )

[08:51] <masak> laben: .spent

[08:52] <masak> aw, it's only morning, and I already used up my bikeshedding token... :P

[08:52] <laben> yeah or even better is-spent

[08:53] <masak> only if there are other 'is-' methods already on that object. I think hyphens have a very high design cost.

[08:53] <masak> that ain't really motivated just to prepend a redundant 'is'

[08:53] <lizmat> .oO( postfix a ? :-)

[08:53] <masak> and then slap a Ruby 8.0 on the box, and ship it!

[08:54] <masak> if someone creates a slang where you can add a `?` to the end of function and method names, please call it Slang::Riddler :P

[08:54] <laben> masak: rejected. hyphens are very cool and much better than doing CamelCase or under_case or strangeCase. or maybe it's Lisp speaking to me...

[08:55] *** krunen joined
[08:55] <masak> I only had one bikeshedding token, so...

[08:55] <laben> masak: the sky is the limit .u upwards arrow

[08:55] <laben> .u upwards arrow

[08:55] <yoleaux> U+034E COMBINING UPWARDS ARROW BELOW [Mn] (◌͎)

[08:56] <yoleaux> U+2191 UPWARDS ARROW [Sm] (↑)

[08:57] *** jkva left
[08:57] <masak> .u 2250

[08:57] <yoleaux> U+2250 APPROACHES THE LIMIT [Sm] (≐)

[08:57] *** colomon joined
[08:57] <masak> .u limitation

[08:57] <yoleaux> U+4DFB HEXAGRAM FOR LIMITATION [So] (䷻)

[08:58] *** jkva joined
[09:02] <dalek> roast/glr: 06d424d | lizmat++ | packages/Test/Tap.pm:

[09:02] <dalek> roast/glr: Make sure we don't iterate when checking emissions

[09:02] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/06d424d521

[09:02] *** espadrine left
[09:03] <lizmat> this does *not* fix the problem, fwiw

[09:03] *** FROGGS_ joined
[09:03] <moritz> fwiw Seq already as an is-lazy method

[09:03] <lizmat> .oO( didn't know moritz was French )

[09:03] <TimToady> e

[09:04] *** rindolf joined
[09:04] *** FROGGS left
[09:08] *** colomon left
[09:08] <Ven> masak: someone (FROGGS++) already created such a slang. I think you elected to give someone a book for that then..

[09:09] <Ven> masak: https://github.com/FROGGS/p6-Slang-Piersing

[09:12] <masak> oh right, that's what Piersing does

[09:14] <masak> slangs as they stand today -- it's both fantastic that they exist and have the reach they do, but there's also the feeling that they could be much nicer/more consistent, somehow

[09:14] <masak> I like the look of <[?!]>?

[09:14] <masak> :)

[09:14] <JimmyZ> selang ....

[09:14] <masak> it occurs twice in https://github.com/FROGGS/p6-Slang-Piersing/blob/master/lib/Slang/Piersing.pm

[09:15] <masak> clearly an opportunity was missed in factoring it into <hunh>?

[09:15] <JimmyZ> masak: you may know what selang means  in chinese  :P

[09:16] <masak> :)

[09:16] <DrForr> Dangerously close to interrobang :)

[09:16] *** yeahnoob left
[09:16] <masak> JimmyZ: seems to mean https://en.wikipedia.org/wiki/Satyr

[09:17] <JimmyZ> masak: yeah

[09:19] *** Ven left
[09:21] *** FROGGS_ is now known as FROGGS

[09:22] <FROGGS> masak: clearly the way we implement slangs today is just a bad cheat

[09:24] *** colomon joined
[09:26] *** espadrine joined
[09:29] <masak> FROGGS: will we meet in the next two weeks? maybe we can talk about it in person.

[09:29] *** colomon left
[09:30] <_itz> the .ch act site /. ed?

[09:30] <_itz> or my browser crashed

[09:32] <masak> _itz: http://act.perl-workshop.ch/spw2015/ works here.

[09:34] *** colomon joined
[09:35] <_itz> act never likes me :/

[09:35] *** colomon left
[09:37] *** virtualsue joined
[09:48] *** jkva left
[09:50] <masak> is it fair to say that the new Slip() thing represents Perl 5's (auto-)flattening, but that it's now opt-in in many situations?

[09:50] *** brrt left
[09:50] <masak> trying to understand GLR a bit here.

[09:50] *** jkva joined
[09:51] <sergot> hi #perl6 \o

[09:53] *** colomon joined
[09:54] <nine> masak: yes, it is.

[09:55] <nine> masak: There's flat and | to flatten from the outside and Slip() to flatten from the inside.

[09:56] <TimToady> well, I'd say it's more like P5's use of @{} to deref a scalar

[09:58] *** trnh joined
[09:59] <nine> moritz: FWIW I think we should get rid of the my @l = do for loop in infix:<X> (and others that are similiarly structured), as the flattening problem doesn't exist anymore anyway. A plain map would n

[09:59] <nine> moritz: FWIW I think we should get rid of the my @l = do for loop in infix:<X> (and others that are similiarly structured), as the flattening problem doesn't exist anymore anyway. A plain map would do nicely.

[10:01] <virtualsue> "your online payment has been approved"  but i didn't make one o-O

[10:02] <jdv79> virtualsue: ditto.  hope they take cash at the door.

[10:03] <nine> And since I'm at spewing wisdom: I think we can simply replace LoL by an actual List of Lists as in 1,2;2,3 becomes ((1, 2), (2, 3))

[10:03] <virtualsue> yeah. i don't think i'll be able to effect a bank transfer particularly easily

[10:03] *** anaeem1 joined
[10:04] <_itz> I'd feel sorry for the Nigerian Perl Workshop organisers should there ever be one

[10:04] <moritz> nine: yes, I suspected that much; will actually try now

[10:04] *** aborazmeh left
[10:05] *** colomon left
[10:05] <ShimmerFairy> nine: naw, that's crazy talk! .oO(It should be an Array of Lists, obviously, to proudly show off that we have a new list design that has just two main list types)

[10:05] <moritz> nine: ah, but we need the index inside anyway, because the left-most arg isn't part of the Infinity consideration

[10:07] <nine> moritz: I still think a plain map would be easier to reason about. But that could just be my limited experience with Perl 6 speaking.

[10:08] <jdv79> would it be a bad idea to allow multiple doc langs?

[10:08] <jdv79> if people like markdown why not allow that - that's the sorta vague idea i had.

[10:09] <moritz> jdv79: and here I thought you meant documentation in different natural languages

[10:10] <jdv79> i was just thinking about ShimmerFairy's latest blog post about fixing up pod6.  but isn't that just another re-invention that may not be necessary?

[10:10] <ShimmerFairy> jdv79: not really, it's just fixing up what's already there

[10:11] <nine> moritz: also don't we have loop phasers now for skipping the first iteration?

[10:13] <jdv79> but i can mix p5 and p6 and python.  why not pod6 and markdown and whatever other doc format?  just a random thought.

[10:14] <ShimmerFairy> jdv79: you can subvert the Pod parser with a DOC INIT (there's a theoretical example in S26) if you really insisted on your own doc format :)

[10:15] <ShimmerFairy> As well any documentation format (like Doxygen IIRC) that can integrate with existing languages' comment syntax and such, of course.

[10:16] <jdv79> nice

[10:16] <ShimmerFairy> (Also, I personally think Pod should get its own spot on the language braid, which would mean that it can be accessed through something like $~POD and modified like any other component of the language)

[10:17] <jdv79> my motivation was just laking people learn less.  learn p6 - fine.  but don't want to learn pod6 - use whatever you already know.

[10:17] <jdv79> *making

[10:18] <ShimmerFairy> Well, I don't think Pod6 is asking anything much more from people wanting to learn Perl 6, but in any case that's what slangs are for, modifying the language where you just can't agree with it :)

[10:18] <lizmat> wow, bare startup in GLR now at 93 milliseconds for me  :-)

[10:19] <jdv79> its def a weak argument of a use case but at least its possible

[10:20] *** Ven joined
[10:20] <jdv79> lizmat: what is bare startup to you?

[10:21] <lizmat> perl6 -e ''

[10:21] <nine> It's 74ms here :)

[10:21] <lizmat> nine: then you have a faster machine then I do  (or a superior OS :-)

[10:22] <ShimmerFairy> The biggest change I'm imagining for Pod6 at the moment is to have #= be the only declarator syntax, since I find having both leading and trailing declarator comments to be confusing and not very useful. (I'd have #= be the leading style, since I think doc comments generally work better there. Use of '=' despite conflicting with existing syntax just because = looks like a Pod thing)

[10:22] <jdv79> i see nom at ~115ms and glr at ~ 20ms here

[10:22] <nine> Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz

[10:22] <nine> 20ms!?

[10:22] <jdv79> pretty sweet but wonder exactly what caused that diff

[10:23] <jdv79> oh, hold on.  errored.

[10:23] <TimToady> leading comments don't work well on things like parameters

[10:23] <Ven> ShimmerFairy: if you do that, please notice me so I can change my talk from #| to #=

[10:24] <jdv79> oh that's less interesting.  102ms on glr

[10:24] <ShimmerFairy> Ven: I will, but I really don't like conflicting with existing syntax anyway :)

[10:25] <lizmat> nine: i7 2.8 Ghz here, so it must be a superior OS  :-)

[10:25] <lizmat> or perhaps a faster disk (SSD in my case)

[10:25] <ShimmerFairy> TimToady: my thinking was that documenting at the parameter level is a level of detail that's already best served by having detailed documentation elsewhere, as opposed to inline.

[10:25] <nine> lizmat: or just a difference in measurement. I just use time perl6 -e '' and look at the "real" line

[10:26] <nine> lizmat: the importent part is: we're becoming fast :)

[10:26] <lizmat> nine: that's what I do

[10:26] <lizmat> yes...

[10:26] <ShimmerFairy> TimToady: I think my biggest gripe with the two styles is that it's a bit too unrestricted for my tastes (e.g. can have multiple leading or trailing on something, can have both on one thing), and that the existing spellings are not at all indicative of what kind of declarator comment they are.

[10:28] <TimToady> I am -1 to that change because the point of | is to make a false left margin, visually, while the purpose of = is to tie the left thing to the right thing

[10:29] <nine> Ah, as I feared. If we replace LoL by a real List of Lists, it's kinda hard to write a multi candidate for sub postcircumfix:<[ ]>

[10:29] <nine> But maybe we can make LoL a role instead?

[10:29] <ShimmerFairy> I see, though that isn't clear to me without that explanation :) . And there's an argument the #= could be the leading comment because it looks like a pod directive, so it makes sense to start of something with that

[10:29] <TimToady> nine: yes, that's what we said some time ago, but maybe subscripts can bet special

[10:29] <TimToady> *be

[10:30] <TimToady> ShimmerFairy: then it would be visually confusing if it's on the left, I suspect

[10:30] <ShimmerFairy> To me, #^ and #$ would more clearly illustrate the leading/trailing distinction, but of course those look like regex-y comments, rather than Pod comments :)

[10:31] <nine> If we use a List.new does LoL, we can use that for multi dispatch and otherwise don't have to worry about LoL anywhere.

[10:32] <TimToady> the parser could notice your subscript has a ; in it, and dispatch to, say postcircumfix:<[ ;]> instad

[10:33] <TimToady> I think that would be simplest

[10:33] <nine> Then we couldn't do: my $position = (1;1;2); say @multidim[|$position];

[10:33] <_itz> .tell [ptc] examples.perl6.org appears to have stopped updating

[10:33] <yoleaux> _itz: I'll pass your message to [ptc].

[10:34] *** brrt joined
[10:35] <TimToady> @multidim[|$position;] maybe

[10:36] <TimToady> or [|$position] is always assumed to be multi

[10:37] <nine> That would very probably hurt the overwhelming majority of single dim array access performance wise.

[10:43] <TimToady> only if you use |, otherwise it goes directly to the [] insted of the [ ;] function

[10:44] <YuviPanda> Wrote my first (and very small!) perl6 module!

[10:44] <YuviPanda> needs some more cleanup and docs and maybe tests...

[10:44] <TimToady> or we actually implement the originally specced || vs |

[10:44] <TimToady> YuviPanda++

[10:46] <YuviPanda> (https://github.com/yuvipanda/perl6-Ident-Client)

[10:46] <TimToady> but certainly we have proof that the LoL approach works, and I suppose the extra type doesn't hurt performance all that much

[10:49] *** dayangkun left
[10:51] <YuviPanda> so the DESTROY in https://github.com/yuvipanda/perl6-Ident-Client/blob/master/lib/Ident/Client.pm6

[10:51] <YuviPanda> can I expect that to be called consistently enough to leave the closing of the socket to it?

[10:51] <nine> YuviPanda: better not

[10:52] <YuviPanda> so it's mostly 'best effort'?

[10:52] <YuviPanda> what's the reccomended way to deal with these things?

[10:52] <YuviPanda> have an explicit .close() method?

[10:54] <nine> yes

[10:55] <YuviPanda> ok

[10:55] <YuviPanda> so what kind of things can you rely on DESTROY for?

[10:59] <moritz> you can rely on the fact that Perl 6 will call it if it's under memory pressure

[10:59] *** vendethiel joined
[11:00] *** TEttinger left
[11:00] <YuviPanda> hmm right

[11:01] <YuviPanda> so how do I do something like python's 'with'

[11:02] <moritz> there are LEAVE phasers (though the caller's responsiblity)

[11:03] <moritz> given open($filename, :w) { LEAVE .close; # do stuff here }

[11:04] <YuviPanda> aaah, nice

[11:04] <YuviPanda> cool

[11:04] <jdv79> there's no way to get attr defaults before BUILD is completed, right?

[11:10] *** vytas joined
[11:16] <TimToady> my $handle will leave { .close } = open($filename, :w);   # another way

[11:16] *** Ven left
[11:16] <laben> jdv79: what do you mean? you can pass args to new which will pass them to BUILD

[11:17] *** ab6tract joined
[11:17] *** colomon joined
[11:18] <ab6tract> TimToady: that's quite interesting indeed! are all phasers exposed via 'will' ?

[11:18] <yoleaux> 21 Aug 2015 21:34Z <RabidGravy> ab6tract: the touchstone of any language is whether you can write great software in it not whether the language is perfect. It's going to be great

[11:18] <yoleaux> 21 Aug 2015 21:45Z <raiph> ab6tract: I share your passion to get things right. If I upset you, that was the opposite of my intent and I apologize.

[11:18] <yoleaux> 22 Aug 2015 02:34Z <lizmat> ab6tract: re http://irclog.perlgeek.de/perl6/2015-08-21#i_11096207 , .uniq looks like the Unix uniq command, but that actually works like .squish

[11:18] *** Ven joined
[11:19] <lizmat> afk for a few hours&

[11:20] *** trnh left
[11:20] <ab6tract> p6doc -f will: No documentation found for a routine named 'will'

[11:20] <ab6tract> ;(

[11:21] <oha> ab5tract, it will

[11:22] <ab6tract> .tell raiph Not to worry, mate. I just had to run, and am always bothered by a "then fix it" response to a (relatively) major language design discussion

[11:22] <yoleaux> ab6tract: I'll pass your message to raiph.

[11:23] <ab6tract> lizmat: re: .uniq ... it's a shame that only a naming conflict with a crypti-nomic unix command can lead to de-crypto-nomification of a p6 routine :(

[11:25] *** vendethiel left
[11:25] <ab6tract> laben: if I understood jdv79 correctly, it was about the default values that were specified by the class. `has $!var = 'foo' `

[11:27] <TimToady> m: say "Before"; { my $x will enter { say "Entered!" } = 42; }; say "After"

[11:27] <GLRelia> rakudo-moar ab408b: OUTPUT«Before␤Entered!␤After␤»

[11:27] <camelia> rakudo-moar f7cfe9: OUTPUT«Before␤Entered!␤After␤»

[11:28] <TimToady> ab6tract: pretty much, except for maybe CATCH and CONTROL

[11:29] <moritz> m: my $x will leave { "say $x" }; $x = 5

[11:29] <GLRelia> rakudo-moar ab408b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/sxu5Y0Z4Ys␤Variable '$x' is not declared␤at /tmp/sxu5Y0Z4Ys:1␤------> 3my $x will leave { "say 7⏏5$x" }; $x = 5␤»

[11:29] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HBm06yJTOm␤Variable '$x' is not declared␤at /tmp/HBm06yJTOm:1␤------> 3my $x will leave { "say 7⏏5$x" }; $x = 5␤»

[11:29] <moritz> huh?

[11:30] <moritz> that looks wrong

[11:30] <masak> looks like a bug to me.

[11:30] <masak> $x is declared at that point.

[11:30] <ab6tract> TimToady: that's pretty neat :)   .. though I wonder if this is one of those things that could have maybe been implemented adverbially but couldn't be due to the era of P6 when it was introduced?

[11:30] <masak> moritz: want me to rakudobug it?

[11:31] <moritz> masak: yes please

[11:32] * masak does

[11:33] <laben> ab6tract: i dont understand what he was trying to do. do you mean trying to access the attr inside BUILD expecting it to have the default value?

[11:34] <masak> m: my $x will enter { say $x } = 2

[11:34] <GLRelia> rakudo-moar ab408b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/WAJGS0aaQC␤Variable '$x' is not declared␤at /tmp/WAJGS0aaQC:1␤------> 3my $x will enter { say 7⏏5$x } = 2␤»

[11:34] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/qLbm4QEvKz␤Variable '$x' is not declared␤at /tmp/qLbm4QEvKz:1␤------> 3my $x will enter { say 7⏏5$x } = 2␤»

[11:35] <ab6tract> laben: I can't speak for what they wanted it for, but I took it as "can I introspect the default value within BUILD"

[11:36] <laben> then why would you think the attr has been initialised before BUILD?

[11:38] <ab6tract> laben: what do you mean? first, this was not my question. second, I don't think that. but if attr's arrived in BUILD with the default value already installed, you could introspect that default value

[11:41] <laben> sorry, the "you" was not referring to you specifically but generically like 'why would a person <etc>'. about the attr, if the default is not installed within BUILD, there's no other place, or is there?

[11:42] <ab6tract> laben: you can set a default via the attribute definition without bothering with a build

[11:43] *** RabidGravy left
[11:43] <ab6tract> m: class T { has $.s = "silly string" }; my $t = T.new; say $t.s

[11:43] <camelia> rakudo-moar f7cfe9: OUTPUT«silly string␤»

[11:43] <GLRelia> rakudo-moar ab408b: OUTPUT«silly string␤»

[11:43] <laben> yes, but if you do write the BUILD, there's no auto default. or am i wrong?

[11:43] <_itz> is print buffered? I ask since I get different results with print "A"; sleep 2; print "B";

[11:43] <_itz> on perl5 and perl6?

[11:44] <ab6tract> m: class T { has $.s = "silly string"; submethod BUILD { }  }; my $t = T.new; say $t.s

[11:44] <GLRelia> rakudo-moar ab408b: OUTPUT«silly string␤»

[11:44] <camelia> rakudo-moar f7cfe9: OUTPUT«silly string␤»

[11:44] <ab6tract> m: class T { has $.s = "silly string"; submethod BUILD { $!s = "not so silly now are you"; }  }; my $t = T.new; say $t.s

[11:44] <camelia> rakudo-moar f7cfe9: OUTPUT«not so silly now are you␤»

[11:44] <GLRelia> rakudo-moar ab408b: OUTPUT«not so silly now are you␤»

[11:45] <ab6tract> If I dig for a use case for introspecting defaults, it would relate to roles

[11:45] <laben> m: class T { has $.s = "silly string"; submethod BUILD { say $!s; }  }; my $t = T.new; say $t.s

[11:45] <camelia> rakudo-moar f7cfe9: OUTPUT«(Any)␤(Any)␤»

[11:45] <GLRelia> rakudo-moar ab408b: OUTPUT«(Any)␤(Any)␤»

[11:45] <laben> m: class T { has $.s = "silly string"; submethod BUILD { say $.s; }  }; my $t = T.new; say $t.s

[11:45] <GLRelia> rakudo-moar ab408b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/u_4XqAbDye␤Virtual call $.s may not be used on partially constructed objects␤at /tmp/u_4XqAbDye:1␤------> 3silly string"; submethod BUILD { say $.s7⏏5; }  }; my $t = T.new; say $t.s␤    expecting …»

[11:45] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MxiIxuau9H␤Virtual call $.s may not be used on partially constructed objects␤at /tmp/MxiIxuau9H:1␤------> 3silly string"; submethod BUILD { say $.s7⏏5; }  }; my $t = T.new; say $t.s␤    expecting …»

[11:46] <laben> m: class T { has $.s = "silly string"; submethod BUILD { say $!s; $!s = "after"; }  }; my $t = T.new; say $t.s

[11:46] <GLRelia> rakudo-moar ab408b: OUTPUT«(Any)␤after␤»

[11:46] <camelia> rakudo-moar f7cfe9: OUTPUT«(Any)␤after␤»

[11:46] <laben> ok, so this was what jdv79 was asking...

[11:46] <ab6tract> it looks like if you poke at the attribute, it won't take the default anymore. but just having a BUILD does not by itself remove the default

[11:47] <ab6tract> m: class T { has $.s = "silly string"; has $.v; submethod BUILD { $!v = "goo" }  }; my $t = T.new; say $t.s

[11:47] <GLRelia> rakudo-moar ab408b: OUTPUT«silly string␤»

[11:47] <camelia> rakudo-moar f7cfe9: OUTPUT«silly string␤»

[11:47] <laben> still, why would it not take the default if i don't reassign to it?

[11:49] <ab6tract> laben: I have no idea why poking at the attribute would do that. only others could say whether it's a bug though

[11:50] <laben> will try to check it out, hope it's not the jit

[11:51] <ab6tract> well, I do have an idea, and it relates to the poking causing some level of defined-ness/containerization that results in the skipping of the default assingment

[11:52] *** rurban left
[11:53] <nine> _itz: STDOUT is buffered by default on Perl 5

[11:53] <_itz> but not on perl6?

[11:53] <nine> _itz: try perl -e 'STDOUT->autoflush(1); print "A"; sleep 2; print "B";'

[11:53] <nine> _itz: seems like there's no buffering in Perl 6, yes.

[11:54] <_itz> ah thanks

[11:54] <nine> _itz: though I wouldn't depend on it. Probably just an implementation artifact :)

[11:54] <_itz> open has :autoflush in perl6

[11:55] <_itz> I guess buffering is just NYI

[11:57] <moritz> IO is still very immature

[12:01] *** larion joined
[12:01] *** cognominal left
[12:02] <nine> I wonder why we haven't seen any mention of GLR benchmarks yet since jnthn's initial one.

[12:03] *** pmurias joined
[12:04] *** AlexDaniel joined
[12:16] *** Ven left
[12:16] <_itz> lies, damm lies and benchmarks :)

[12:18] *** cognominal joined
[12:19] <masak> I'd be interested in some benchmarks.

[12:19] <masak> I think the reason we haven't seen any might be something mundane like, it takes effort to produce them.

[12:19] <nine> Or like panda still not working...

[12:20] <masak> it isn't? :/

[12:22] *** virtualsue left
[12:23] *** Ven joined
[12:23] <dalek> rakudo/glr: b1fa1c2 | (Stefan Seifert)++ | src/core/Mu.pm:

[12:23] <dalek> rakudo/glr: Fix "Method 'is-lazy' not found" regression in META_CROSS

[12:23] <dalek> rakudo/glr: 

[12:23] <dalek> rakudo/glr: Commit 7bc1a99ad91deb8888ab5a51adc909ea1d26ce1a replaced calls to

[12:23] <dalek> rakudo/glr: .infinite by the new .is-lazy. META_CROSS may call .is-lazy now on

[12:23] <dalek> rakudo/glr: simple scalars like Int. Mu provided a method infinite for such cases.

[12:23] <dalek> rakudo/glr: Replace that by a method is-lazy that defaults to False.

[12:23] <dalek> rakudo/glr: 

[12:23] <dalek> rakudo/glr: Thus the migration from infinite to is-lazy is complete.

[12:23] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b1fa1c2942

[12:23] <nine> masak: I think laben has done much work on that but it's not yet merged.

[12:24] *** virtualsue joined
[12:24] *** virtualsue left
[12:25] *** virtualsue joined
[12:25] <masak> ok

[12:25] *** rurban joined
[12:27] <laben> masak: i did publish the PR (https://github.com/tadzik/panda/pull/202), panda works fine with those and yes i do use bootstrap

[12:27] <laben> i would like some feedback on other machines

[12:28] <masak> oh, panda is broken *on GLR*. I see.

[12:34] <nine> laben: I left a couple of comments on your commits in the panda pull request

[12:35] *** virtualsue left
[12:37] *** cognominal left
[12:37] <nine> m: sub foo() { my $a = 1; my $b = 2; :$b, :$a}; say foo.perl; my (:$a, :$b) = foo; say $a, $b;

[12:37] <GLRelia> rakudo-moar b1fa1c: OUTPUT«(:b(2), :a(1))␤b => 2a => 1␤»

[12:37] <camelia> rakudo-moar f7cfe9: OUTPUT«(:b(2), :a(1))␤b => 2a => 1␤»

[12:37] <nine> m: sub foo() { my $a = 1; my $b = 2; :$b, :$a}; say foo.perl; my (:$a, :$b) := foo; say $a, $b;

[12:37] <camelia> rakudo-moar f7cfe9: OUTPUT«(:b(2), :a(1))␤12␤»

[12:37] <GLRelia> rakudo-moar b1fa1c: OUTPUT«(:b(2), :a(1))␤Too many positionals passed; expected 0 arguments but got 2␤  in block <unit> at /tmp/sDRvZ1axk3:1␤␤»

[12:38] <nine> Sucks that we lost this magic. I wonder if we can get it back?

[12:39] <masak> why do I have a sense that there's probably just a `flat` missing somewhere?

[12:41] <nine> Hmm...the error comes from bind_cap_to_sig which indicates that perl6 is still trying to do the right thing. It's just failing.

[12:43] <laben> nine: about https://github.com/laben/panda/commit/d97fcd5597efa9d435ce9a00807c22c1b83ca9d1 if it's not slip, it would leave the empty list inside. i understood this was an intended change

[12:44] <nine> laben: but you flatten that empty list both in the @deps.push: line and the other place where you call get-deps

[12:45] <nine> laben: so, yes, a Slip is a safe choice to return but not strictly necessary. Since you need a workaround for nom there, I'd just leave it out.

[12:46] *** virtualsue joined
[12:47] *** FROGGS left
[12:56] *** anaeem1 left
[13:02] *** FROGGS joined
[13:03] <nine> laben: oh and I just remembered: Empty is an empty Slip

[13:03] <laben> m: dd Empty

[13:03] <GLRelia> rakudo-moar b1fa1c: OUTPUT«()␤»

[13:03] <camelia> rakudo-moar f7cfe9: OUTPUT«Empty␤»

[13:03] <nine> m: sub a { return Empty; }; my @a = a; say @a.perl;

[13:03] <GLRelia> rakudo-moar b1fa1c: OUTPUT«[]␤»

[13:03] <camelia> rakudo-moar f7cfe9: OUTPUT«[]<>␤»

[13:03] <nine> works on nom and glr :)

[13:05] <laben> pushed commit fixing run-and-gather, let's see if i can change the commit with Slip, else i add another to change again and return Empty

[13:08] <nine> m: sub foo() { my $a = 1; my $b = 2; \(:$b, :$a)}; my (:$a, :$b) := foo; say $a, $b;

[13:08] <GLRelia> rakudo-moar b1fa1c: OUTPUT«12␤»

[13:08] <camelia> rakudo-moar f7cfe9: OUTPUT«12␤»

[13:08] <nine> laben: maybe we fix the capture binding problem this way^^^?

[13:09] <nine> m: sub foo() { my $a = 1; my $b = 2; \(:$b, :$a)}; my ($a, $b) = foo; say $a, $b;

[13:09] <GLRelia> rakudo-moar b1fa1c: OUTPUT«\(:a(1), :b(2))(Any)␤»

[13:09] <camelia> rakudo-moar f7cfe9: OUTPUT«\(:a(1), :b(2))(Any)␤»

[13:09] <nine> m: sub foo() { my $a = 1; my $b = 2; :$b, :$a}; my ($a, $b) = foo; say $a, $b;

[13:09] <GLRelia> rakudo-moar b1fa1c: OUTPUT«b => 2a => 1␤»

[13:09] <camelia> rakudo-moar f7cfe9: OUTPUT«b => 2a => 1␤»

[13:09] <laben> nine: you prefer the capture to the list return?

[13:11] *** skids joined
[13:11] <nine> With the capture we only have to change run-and-gather-output instead of both its callers.

[13:11] <nebuchadnezzar> The Slip type is really fun in french, because it's the french word for https://en.wiktionary.org/wiki/briefs

[13:11] <nebuchadnezzar> héhé

[13:12] <nine> nebuchadnezzar: same in German

[13:12] <nine> Well we even had a type called LoL, so what do you expect? ;)

[13:12] <laben> a type called Dota

[13:13] <laben> nine: mh, yeah, seems good, now i only need to understand how to clean up the PR commits

[13:13] <nine> git rebase -i origin/glr

[13:14] *** rmgk is now known as Guest7040

[13:14] *** rmgk_ joined
[13:14] *** Guest7040 left
[13:14] *** rmgk_ is now known as rmgk

[13:14] <nebuchadnezzar> nine: sure, but when I read “Empty is an empty Slip”, I read “Empty is an empty brief”, which sounds strange ;-)

[13:14] <nine> re-order the commits so the fixups are right after the commits they change and change the "pick" to "fixup" to merge those commits

[13:15] <colomon> nebuchadnezzar: in English (American English?) a slip is also a kind of woman’s underwear.

[13:16] <ab6tract> nebuchadnezzar: in English, it refers more to an 'under dress' type of underwear. the dress under the dress

[13:16] <ab6tract> colomon: jinx ;)

[13:17] <ab6tract> and you are probably right, I bet it is an American English thinq

[13:19] <timotimo> tony-o: i'd be interested to see if json-faster could be made even faster still by pushing bits of string into an array and then joining it at the end

[13:19] <colomon> ab6tract: I don’t know that, I just know I’m American and my wife occasionally wears a slip.  :)

[13:19] *** virtualsue left
[13:21] <ab6tract> colomon: :)

[13:21] <nine> timotimo: use an IterationBuffer instead of an array

[13:28] <timotimo> right, i forgot we have a nqp::-less nqp::list now :)

[13:28] <skids> lizmat: Without any protection by itemization, the way to iter-proof .push($_) is .push(($_,)).  Dispatch cannot tell the difference between $_ and $_, at the top level.

[13:28] <skids> (apparently)

[13:30] <skids> PR#512 is semi-rhetorical BTW: it is indeed the right way to do first-arg-rule-does-not-check-itemization, but also show that the fallout from that is a bit harsh.

[13:30] <skids> (when we deflatten sub map that is another bit of craziness)

[13:33] *** diana_olhovik_ left
[13:34] *** telex left
[13:34] *** jkva left
[13:36] *** telex joined
[13:37] *** Ven left
[13:38] <laben> nine: i think i made a mess, i cant push anymore to my branch which means i will have to make a new PR with the squashed commits. is it alright?

[13:40] <skids> Actually.  Now that I think of it, how does [[],] even work.

[13:42] *** FROGGS left
[13:44] *** brrt left
[13:45] <skids> Hah.  Array.STORE checks containerization.  So if we fix that, there will be *no* way to create [[]].  I think the idea that $ does not protect against first-arg-rule is going to crash and burn.

[13:46] <skids> Unless dispatch learns the difference between foo and foo,

[13:47] <skids> So we have two ways forward and someone has to choose which.

[13:50] *** jkva joined
[13:51] <ShimmerFairy> $ can't protect against single-arg unless you want stuff like ($@a).map to break :)

[13:51] <ShimmerFairy> m: my @a = 1,2,3; say ($@a).map: * + 1

[13:51] <camelia> rakudo-moar f7cfe9: OUTPUT«2 3 4␤»

[13:51] <GLRelia> rakudo-moar b1fa1c: OUTPUT«2 3 4␤»

[13:53] <skids> Why would that be "broken", you'd write it as @a.map or (@a).map if you wanted to descend into @a.

[13:55] <skids> (A third alternative is to never use multi foo (\item), always just only foo (**values) and then check values[0] for iterator and for !values.EXIST-POS(1) -- **everywhere**)

[13:56] <pflanze> Does Perl6 attempt to use common interfaces for things like hash maps, sequences, collections? Where should I look to get to learn about them?

[13:57] <ShimmerFairy> m: sub foo { 1,2,3,5 }; my $result = foo; say $result.map: * * 2  # more realistic example

[13:57] <GLRelia> rakudo-moar b1fa1c: OUTPUT«2 4 6 10␤»

[13:57] <camelia> rakudo-moar f7cfe9: OUTPUT«2 4 6 10␤»

[13:57] <timotimo> we have at least AT-POS and AT-KEY as well as BIND-POS and BIND-KEY

[13:57] <skids> pflanze: doc.perl6.org would probably be a good start, but it is incomplete in places, so the final recourse is the Perl6 design docs.

[13:58] <timotimo> i'd say the final recourse would be the contents of src/core ;)

[13:58] <pflanze> ok.

[13:58] <pflanze> Are there any attempts at porting such interfaces to Perl5?

[13:59] <skids> ShimmerFairy: what would you expect that to do if $ protected against single-arg-rule?

[13:59] <skids> pflanze: Moose and Moo do some of that, IIRC.

[13:59] <timotimo> hm, porting in what way?

[13:59] <pflanze> Since I'm currently coding in Perl5 (also, functional perl5), and am interested in using some.

[14:00] <pflanze> timotimo, tie doesn't cut it for arrays, hashes in a purely functional context. Also, there's no API for (lazy) sequences.

[14:00] <timotimo> ah

[14:00] <pflanze> So, I'm looking for how I should go about it.

[14:00] <skids> (And nine++ has done some work on running P6 from inside P5 IIRC)

[14:00] * timotimo has actually no clue about perl5

[14:00] <timotimo> right, we have Inline::P6 for p5 and Inline::P5 for p6

[14:01] <ShimmerFairy> skids: I'd expect it to return just 8 ($list.elems * 2), since $ protection would either have to consistently apply to Scalar containers, or else cause some ungodly mess of special rules

[14:01] <ShimmerFairy> m: sub foo { 1,2,3,5 }; my $result = foo; for $result { say $_ * 2 }

[14:01] <camelia> rakudo-moar f7cfe9: OUTPUT«8␤»

[14:01] <GLRelia> rakudo-moar b1fa1c: OUTPUT«2␤4␤6␤10␤»

[14:01] <ShimmerFairy> skids: ^^^ camelia's current behavior in for loop form is what we're trying to _avoid_, not perpetuate :)

[14:02] <skids> ShimmerFairy: No, because you invoked method map on $foo, $ does not protect against method invocation, of course.

[14:02] <skids> If you wanted 8 you have to say $$foo.map:

[14:02] *** yqt joined
[14:03] <skids> The method invocation eats the $.

[14:04] <skids> (because you don't even have a list to apply a $ to until you have used it)

[14:04] <nine> laben: try push -f to push to your branch

[14:05] *** diana_olhovik_ joined
[14:05] <nine> laben: with git rebase -i you changed commits and git prevents you from pushing changed commits by default as it will hurt others who work on the same branch. A -f is the right thing in your case however.

[14:07] <skids> (or actually precedence may require $($foo.map: ...))

[14:07] *** xzenfar left
[14:08] *** TimToady joined
[14:08] <nine> m: sub foo { 1,2,3,5 }; my $result = foo; for $result, { say $_ * 2 }

[14:08] <GLRelia> rakudo-moar b1fa1c: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/lyF7Vf5QYJ:1␤------> 3esult = foo; for $result, { say $_ * 2 }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/lyF7Vf5QYJ:1␤------> 3esult = foo; f…»

[14:08] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/fm7cDdLwqi:1␤------> 3esult = foo; for $result, { say $_ * 2 }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/fm7cDdLwqi:1␤------> 3esult = foo; f…»

[14:08] <nine> m: sub foo { 1,2,3,5 }; my $result = foo; for ($result,) { say $_ * 2 }

[14:08] <GLRelia> rakudo-moar b1fa1c: OUTPUT«8␤»

[14:08] <camelia> rakudo-moar f7cfe9: OUTPUT«8␤»

[14:08] *** FROGGS joined
[14:09] <nine> skids: if you really want for to run only one iteration, you have to give it a list of size 1

[14:09] <laben> nine++ incredible stuff, it did work and github updated https://github.com/tadzik/panda/pull/202. dunno why it erased the old commits and comments

[14:09] <FROGGS> masak: I'll be in Olten but not at the YAPC

[14:09] <skids> nine: if we fix Array.STORE, it will be impossible to construct such a list.

[14:09] <ShimmerFairy> As far as I understand, the single-arg rule exists to fix some big issues in pre-GLR design, so it's almost certainly not going anywhere :)

[14:10] *** laouji left
[14:10] <nine> laben: git rebase -i replaced the old commits. It did entirely new commits with your new changes. Those new commits have new hashes since the commit hash identifies the whole content of your whole repo in exactly the state where you committed. Since github identifies commits by hash (as makes sense) the comments are still on the old commits.

[14:11] <nine> skids: in what way does STORE need fixing? I may have missed some discussion there.

[14:11] <PerlJam> good $localtime all

[14:11] <ShimmerFairy> skids: if you really wanted  for $@a { }  to do what you want, that should really be written as  given @a { }  , assuming [@a,] and such ever does become impossible.

[14:12] *** TimToady left
[14:12] <skids> ShimmerFairy: I'm not saying it should be going anywhere.  I'm saying as we fully implement, one of two things has to start working: either $ has to protect against it, or foo(thing,) has to MMD to foo(**@values) over foo(\value).  If neither of thise two things happen, it will get ugly.

[14:12] <nine> laben: the old commits with comments are still there btw.: https://github.com/laben/panda/commit/f578a30eed0cf9d745dac0eef2f4cb679bc5e7ff They are just no longer contained in your branch (and thus pull request)

[14:12] <skids> nine: STORE checks containerization, so it allows $ to protect against signle arg rule.

[14:13] *** TimToady joined
[14:13] <laben> nine++ sensei, while fixing glr, teaches me git and github. thanks!

[14:14] <pmurias> pflanze: why doesn't tie cut if for arrays, hashes?

[14:14] <CQ2> with all the helping he's doing, you have to watch out that nine++ doesn't lead to an integer overflow...

[14:15] *** Ven joined
[14:15] *** khw joined
[14:15] <skids> m: my @a; @a.STORE($[1,2]); @a.perl.say

[14:15] <GLRelia> rakudo-moar b1fa1c: OUTPUT«[$[1, 2]]␤»

[14:15] <camelia> rakudo-moar f7cfe9: OUTPUT«[Any, Any]<>␤»

[14:19] <nine> m: my @a; @a.STORE($[1,2]); my @b; @b.STORE(([1,2],)); say @a.perl; say @b.perl;

[14:19] <GLRelia> rakudo-moar b1fa1c: OUTPUT«[$[1, 2]]␤[$[1, 2]]␤»

[14:19] <camelia> rakudo-moar f7cfe9: OUTPUT«[Any, Any]<>␤[[1, 2]]<>␤»

[14:19] <nine> skids: ^^^ two ways to achieve the same. So we may take away the itemization one?

[14:20] <skids> Only if you want to see ((thing,)) everywhere.

[14:21] <hoelzro> good morning #perl6!

[14:21] <timotimo> heyo hoelzro 

[14:21] <skids> Like to make [[[]]] you would have to write: [([([],),)]

[14:21] <pflanze> pmurias, tie assumes that it's used in an eagerly evaluating world that's mutable; taking the list of elements or keys of a hash claims the only enumeration context a hash has to offer, for example.

[14:21] <skids> And that assumes there is not a reason to break (thing,)

[14:22] <ShimmerFairy> m: my @a; @a.push(a=>1); @a.push((b=>2)); say @a.perl; # not like there aren't other reasons to need (()) already :P

[14:22] <GLRelia> rakudo-moar b1fa1c: OUTPUT«[:b(2)]␤»

[14:22] <camelia> rakudo-moar f7cfe9: OUTPUT«[:b(2)]<>␤»

[14:22] <pmurias> hoelzro: hi

[14:22] <hoelzro> ahoy timotimo, pmurias!

[14:23] <skids> push is actually broken without PR512, in thesame way as STORE.  JFWIW.

[14:24] <skids> *[([([],)],)] above.

[14:25] <nine> skids: just how often do you need to create lists containing a single listy item?

[14:26] <nine> The occasional trailing comma is the price we're paying for sane and consistent semantics.

[14:26] <skids> nine: I would ecourage you to look at what I had to do in PR512 just to fix push/unshift internally.

[14:27] <skids> And it is more than just an occasional trailing comma it is a set of parens around a trailing comma.

[14:28] <nine> But still occasional I'd guess.

[14:29] * PerlJam figures out that he's totally confused.

[14:30] <skids> ShimmeryFairy: FWIW, push currently does allow $ to override the single element rule and: 

[14:30] <skids> m: my $a = (2,3,4); my @b = 1; (@b.push: $a.map: { $_ }).perl.say;

[14:30] <camelia> rakudo-moar f7cfe9: OUTPUT«[1, 2, 3, 4]<>␤»

[14:30] <GLRelia> rakudo-moar b1fa1c: OUTPUT«[1, 2, 3, 4]␤»

[14:30] <tony-o> timotimo: i'll give that a shot, interesting to know that it would work more quickly that way for sure

[14:30] <tony-o> timotimo: re: json::faster

[14:30] <timotimo> would you accept merging json::faster's to-json into json::fast?

[14:31] <timotimo> or do you think that's a bad idea as JSON::Fast isn't fully featured yet?

[14:31] <ShimmerFairy> I don't think there are many cases where you want to treat a list as a singular item _and_ you have just one list you wish to treat as such, instead of a list of them.

[14:31] <skids> Again, see my PR.

[14:32] <skids> push $@a onto a list of arrays is a rather common idiom.

[14:33] <nine> Sounds like a good topic for Olden

[14:33] <nine> Olten

[14:34] <ShimmerFairy> If nothing else, I think there was talk of reintroducing a LoL type to solve some other issues, which could probably give a good solution to this issue as well :)

[14:35] <ugexe> agree with skids. i was using something like $glr = @($work,) unless $work.list.[0].isa(Pair)

[14:36] <skids> It isn't immediately obvious to me how an LoL type would help, but might be to more veteran folks.

[14:38] <pflanze> Will anyone interested in functional programming on Perl(6) be in Olten this week? I'm pondering going there (I'm the author of the yet-to-be announced http://functional-perl.org project).

[14:38] *** colomon left
[14:38] <masak> pflanze: I am interested in functional programming, and I'm going to be there.

[14:38] <nine> The discussions about the new list semantics have been going on for a year. Maybe even longer. I haven't been here before that. I just fear that we will not come up with something better than GLR is already. You can't win every battle.

[14:38] *** RabidGravy joined
[14:38] <masak> pflanze: I've been trying to understand category theory for the past 1.5 .. 2 years, if that helps :)

[14:42] <skids> nine: GLR "isn't" yet though because there are so many cheats still in the codebase.  I don't think the full ramifications of the current guidance have begun to be discovered.

[14:45] <nine> skids: will you be in Olten?

[14:45] <skids> Also I don't want to give the impression that I have a strong inclination towards $ protecting from single-arg-rule, I'm just leaning that way mildly.

[14:45] <skids> nine: I pretty much remain without the same 50 mile radius always.

[14:45] <skids> *within

[14:45] * skids hates travel.

[14:46] * [Coke] waves from the bus to NYC.

[14:46] <Ven> pflanze: I certainly consider myself interested as well!

[14:47] <pflanze> Ven, ok, I'm looking into being there on Friday till ~22:00.

[14:47] * Ven just wrote a one-liner to find recursive calls in a c codebase

[14:47] <pflanze> Unless I'd still get a slot in the program, then maybe another day.

[14:48] <Ven> fwiw, I'd certainly appreciate something smaller than $*ARGFILES.filename :P.

[14:49] <Ven> (I guess some module could do that, and then I could alias 6l = perl6 -MSixLiner ...)

[14:49] * moritz finds it appropriately huffmanized

[14:49] * PerlJam finds it totally weird that Ven and moritz said what he was thinking

[14:49] <pflanze> Ven, masak: Hm, to prevent misunderstandings, I'm not experienced in Perl6. I've written the functional-perl.org for Perl5 till now, but looking into lerning what Perl6 people are doing in this area.

[14:50] <PerlJam> Though in my imagination, the SixLiner module could be autoloaded for command line execution

[14:50] <pflanze> So what I can do is present what I have in Perl5, and learn what Perl6 people think about it or what they know.

[14:50] *** jkva left
[14:50] <Ven> moritz: for regular scripts, surely. for my one-liners, no :)

[14:54] *** xinming_ left
[14:54] *** xinming joined
[14:56] <Ven> pflanze: seems good

[15:01] * ab6tract waves at [Coke] 

[15:03] <masak> pflanze: out of curiosity, have you read http://www.amazon.com/Higher-Order-Perl-Transforming-Programs/dp/1558607013/ ?

[15:03] *** brrt joined
[15:03] <pmurias> any ideas how to test nqp::getstderr in nqp?

[15:03] <pflanze> masak, Yes, a long time ago

[15:04] <moritz> project idea: HOP code examples ported to Perl 6

[15:05] <masak> yeah, that'd be nice

[15:05] <timotimo> pmurias: only thing i can think of is either capturing the output or checking the underlying fileno

[15:06] <masak> pflanze: I also seem to recall eiro++ did something a bit like this.

[15:06] <pflanze> masak, what my project goes further than the book (IIRC) is that it's meant for real-world use, and hence cares about memory deallocation, and for proper modularity.

[15:06] <pflanze> masak, what it comes short in comparison is that there's no parsing libraries or such yet (which the book has, IIRC).

[15:08] *** diana_olhovik_ left
[15:08] <pflanze> (I mention the book on the project home page, and will have to reread it when time permits.)

[15:12] <pmurias> timotimo: capturing the output seems better, as I'm not sure the fileno is the same on windows etc.

[15:12] <timotimo> oh

[15:14] <masak> pflanze: I found what eiro has done: https://github.com/eiro/p5-perlude/blob/master/lib/Perlude.pod

[15:14] <masak> pflanze: maybe you two can combine your efforts somehow?

[15:14] <dalek> rakudo/glr: 1bf053a | (Stefan Seifert)++ | src/core/Mu.pm:

[15:14] <dalek> rakudo/glr: Remove now obsolete XXX GLR comment

[15:14] <dalek> rakudo/glr: 

[15:14] <dalek> rakudo/glr: method infinite has not survived.

[15:14] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1bf053aca1

[15:18] <pflanze> masak, thanks for the link. I'll contact him.

[15:28] <ab6tract> Ven: care to share that one liner? :)

[15:28] * YuviPanda is new here

[15:28] <YuviPanda> where can I learn about the 'GLR'?

[15:28] <YuviPanda> and what it means?

[15:28] <Ven> ab6tract: oh, it's the dumbest possible. perl6 -ne 'BEGIN { my $f }; if /:i ^(<[a..z]>+) "("/ { say $*ARGFILES.filename ~ ":" ~ $0; $f = $0; } elsif $_ eq "}" { $f = "" } elsif $f && $_ ~~ /$f/ { say $f ~ ": " ~ $_ }' *.c

[15:29] <masak> YuviPanda: welcome!

[15:30] <YuviPanda> hello!

[15:30] <masak> YuviPanda: briefly, it's a big refactor before release later this year.

[15:30] <YuviPanda> ah. can I ask what it is refactoring?

[15:30] <masak> YuviPanda: some things about lists and how they work that need to change, mostly to make them more performant.

[15:30] <YuviPanda> (as background, I shared a car ride with sjn from CAMP and spent a hour and something talking about perl6, and now I've been learning the language / writing small things in it)

[15:30] <masak> YuviPanda: this post has some detail: http://pmthium.com/2014/10/apw2014/

[15:30] <YuviPanda> masak: ah, I see. so no non-performance user facing features

[15:30] * YuviPanda clicks

[15:31] <masak> YuviPanda: yes, but there are some syntactic changes too. definitely things the user will see sometimes.

[15:32] <AlexDaniel> Hmm, I feel adventurous

[15:33] <FROGGS> m: use Test; is 'a b c d'.subst(/\w/, 'x', :nth(0)), 'a b c d', '.subst and :nth(0)'

[15:33] <camelia> rakudo-moar f7cfe9: OUTPUT«ok 1 - .subst and :nth(0)␤»

[15:33] <GLRelia> rakudo-moar 1bf053: OUTPUT«Attempt to retrieve before :1st match -- :nth(0)␤  in block <unit> at /tmp/8Ear49WCOz:1␤␤Actually thrown at:␤  in block <unit> at /tmp/8Ear49WCOz:1␤␤»

[15:35] <FROGGS> m: use Test; is 'a b c d'.subst(/\w/, 'x', :nth(5)), 'a b c d', '.subst and :nth(5)'

[15:35] <camelia> rakudo-moar f7cfe9: OUTPUT«ok 1 - .subst and :nth(5)␤»

[15:35] <GLRelia> rakudo-moar 1bf053: OUTPUT«ok 1 - .subst and :nth(5)␤»

[15:36] *** Ven left
[15:36] <tony-o> timotimo: i wouldn't mind merging the two (Fast - Faster), mine does less type checking iirc.  it only doesn't quote Rat | Int 

[15:37] <tony-o> timotimo: i don't plan on doing a from-json because the built-in is about as fast as any pp6 i'd do, i was considering a nativecall solution for both but, honestly, how fast does json parsing need to be *right now*

[15:38] <timotimo> it doesn't quote rat | int?

[15:39] <timotimo> we already have a nativecall json parser

[15:41] *** mr-foobar joined
[15:41] <skids> FROGGS: See S05-modifier/counted-match.t I didn't realize there was a duplicate test.

[15:42] <FROGGS> hmmm

[15:43] <skids> It should fail, per the RT, unless we think somehow the behavior is useful.

[15:43] <skids> (versus :nth(-1), why would one fail and not the other)

[15:44] <FROGGS> std: say 'a b c d'.subst(/\w/, 'x', :nth(5))

[15:44] *** GLRelia left
[15:44] <camelia> std 28329a7: OUTPUT«ok 00:00 144m␤»

[15:44] <FROGGS> hmpf

[15:45] <FROGGS> std: say 'a b c d'.subst(/\w/, 'x', :nth(0))

[15:45] <camelia> std 28329a7: OUTPUT«ok 00:00 144m␤»

[15:45] <FROGGS> std: say 'a b c d'.subst(/\w/, 'x', :nth(-1))

[15:45] <camelia> std 28329a7: OUTPUT«ok 00:00 144m␤»

[15:45] <sjn> YuviPanda: hey, nice to see you here! :)

[15:45] <FROGGS> gah, perhaps std does not care

[15:45] <timotimo> probably

[15:45] <YuviPanda> sjn: hey! :)

[15:46] *** GLRelia joined
[15:46] <sjn> have you found anything interesting yet? :)

[15:46] *** virtualsue joined
[15:46] <GLRelia> std : OUTPUT«Can't chdir to '/home/steve/std/snap': No such file or directory at lib/EvalbotExecuter.pm line 171.␤      EvalbotExecuter::_auto_execute(HASH(0x253d638), "say 'a b c d'.subst(/\\w/, 'x', :nth(5))", GLOB(0x28fd6d0), "/tmp/mDV37SKL1g", "std") called at lib/EvalbotExecuter.p…»

[15:46] <tony-o> timotimo: correct, if the value is a Rat or Int then it just outputs the number

[15:46] * sjn wonders if he over-sold perl6 on that car ride :)

[15:46] <timotimo> is that a problem?

[15:46] <tony-o> i doubt it, i haven't run into it with projects.json or various other json things i tried

[15:47] * sjn _did_ manage to bore a quarter of the passengers into sleep <_<

[15:47] <tony-o> i just noticed that ::fast (iirc, it could have been a different json generator)  was checking a bunch of different types

[15:48] <FROGGS> hmmm, the design docs do not tell...

[15:52] <ab6tract> sjn: Unfortunately I know that feeling

[15:52] <skids> FROGGS: The way I read the design docs when I reimplemented that was :nth(3,0,-1,2,4) would trim to (3,4) but there's nothing about just nth(-1) or nth(0), however the existing code was trying to throw on those so I just fixed it to actually do so.

[15:53] <ab6tract> But as long as one person is interested, it's hard for me to stop talking about it ;)

[15:54] <YuviPanda> sjn: yeah, I wrote a small module

[15:54] <FROGGS> skids: and are the values 0,-1,2 ignored as per design docs?

[15:54] <YuviPanda> sjn: heh, she was just super tired and had had about 2h of sleep that night :D

[15:54] <YuviPanda> sjn: I've found grammars *super* fun

[15:54] <FROGGS> m: say 'a b c d'.subst(/\w/, 'x', :nth(3,0,-1,2,4))

[15:54] <camelia> rakudo-moar f7cfe9: OUTPUT«a b c d␤»

[15:54] <GLRelia> rakudo-moar 1bf053: OUTPUT«a b x x␤»

[15:54] <skids> It says sequences must be monotonic, and if they aren't the nonmonotonic values will be ignored.

[15:54] <YuviPanda> since I used to hate writing any form of string manipulation code

[15:54] <YuviPanda> sjn: https://github.com/yuvipanda/perl6-Ident-Client

[15:54] <FROGGS> skids: are, seems to work fine

[15:55] *** zakharyas left
[15:55] <timotimo> JSON::Fast is just a 1:1 copy of JSON::Tiny for the json generator parts

[15:55] * skids lunch already?  OK then.

[15:56] <YuviPanda> sjn: so slowly poking around and enjoying the language as a pure fun thing :)

[15:58] <dalek> roast/glr: f76ca69 | FROGGS++ | S05-substitution/subst.t:

[15:58] <dalek> roast/glr: apply nth(0) fix from S05-modifier/counted-match.t, skids++

[15:58] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/f76ca697b3

[15:59] <[Coke]> colomon has a process on hack that's been running for 4.5h and consuming3 cpus.

[16:00] <[Coke]> also has 4 processes that all seem to be running with the same smoker.json parameter.

[16:01] <[Coke]> the other 3 are all up to an hour.

[16:02] *** muraiki joined
[16:02] <[Coke]> .seen colomon

[16:02] <yoleaux> I saw colomon 13:19Z in #perl6: <colomon> ab6tract: I don’t know that, I just know I’m American and my wife occasionally wears a slip.  :)

[16:08] <dalek> rakudo/glr: 2ffd6ab | FROGGS++ | src/core/Str.pm:

[16:08] <dalek> rakudo/glr: fix Str.samespace

[16:08] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2ffd6ab55e

[16:13] *** larion left
[16:17] *** Gardner left
[16:18] *** dwarring left
[16:22] *** Gardner joined
[16:24] <[Tux]> does panda install on glr yet?

[16:24] <timotimo> there's a pullrequest that makes it work

[16:29] *** ab6tract left
[16:30] <sjn> YuviPanda: yeah, grammars rock :D

[16:31] <YuviPanda> sjn: yeah, totally. multimethods and what appears to me to be forms of contract programming also sound great :)

[16:31] <sjn> YuviPanda: have you found MAIN yet? :)

[16:31] <YuviPanda> sjn: oh yah :)

[16:31] <YuviPanda> that was really nice surprise too

[16:32] * sjn loves that stuff

[16:32] *** Ven joined
[16:34] <sjn> I still point people to a talk jnthn had in Oslo quite a few years back, about how you can start with a simple one-liner, and graduate it to a command line script using MAIN and grammars and later turn it into a serious all enterprisey OO-buzzwordy program

[16:34] * sjn tries to find it again

[16:35] <sjn> it may be getting old now though, but I still think it should be all valid

[16:36] <sjn> http://www.nuug.no/aktiviteter/20100914-little-tools-large-apps/ # in Norwegian, but the important bits are in English

[16:36] *** Ven left
[16:37] <sjn> (please ignore the guy at the start of the video )

[16:37] <sjn> :)

[16:41] *** yqt left
[16:42] <laben> nine: thanks for merging my panda PR! i just noticed.

[16:43] *** brrt left
[16:44] <AlexDaniel> nine is so awesome lately

[16:47] *** anaeem1 joined
[16:51] <masak> nine has always been awesome.

[16:51] <masak> "hey, I wrote my first Perl 6 program! it implements Inline::Perl5!" :D

[16:52] <PerlJam> nine++ 

[16:56] *** abraxxa left
[17:03] *** CQ2 left
[17:03] *** anaeem1__ joined
[17:06] *** anaeem1 left
[17:08] *** Ven joined
[17:19] *** dakkar left
[17:19] *** espadrine left
[17:29] <jdv79> how many ++'s does it take until he's ten?

[17:30] <jdv79> nein++ # as an american in germany at the moment that's amusing for some reason. sorry.

[17:30] *** Ven left
[17:31] * lizmat is reminded of a German guy who had only seen "Monty Python and the Holy Grail" dubbed in German

[17:32] <lizmat> then, when he finally saw the movie in English, was surprised to hear it was *not* "The Knights Who Say Never" but "...Say Ni!"

[17:33] <timotimo> tee hee

[17:41] *** Peter_R joined
[17:48] *** brrt joined
[17:48] *** ab6tract joined
[17:56] *** nowan left
[17:59] *** nowan joined
[18:02] *** llfourn left
[18:09] *** nowan left
[18:10] *** nowan joined
[18:11] *** domidumont left
[18:14] *** darutoko- joined
[18:15] <muraiki> if I want to kill the parent process from the callback provided to .act (sorry if I'm using the wrong terminology), what should I do? I guess exit() just exits the thread the .act is running in? sorry, I'm pretty new to this

[18:15] <muraiki> basically I only want to act once :)

[18:16] *** anaeem1_ joined
[18:17] *** anaeem1__ left
[18:17] *** brrt left
[18:17] *** darutoko left
[18:21] <AlexDaniel> m: sub foo('test') { say 'ok' }; foo('test');

[18:21] <GLRelia> rakudo-moar 2ffd6a: OUTPUT«ok␤»

[18:21] <camelia> rakudo-moar f7cfe9: OUTPUT«ok␤»

[18:21] *** ribasushi joined
[18:21] <AlexDaniel> makes me want to try

[18:21] <AlexDaniel> m: my 'hello' $test

[18:21] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8fFgIGLCA6␤Malformed my␤at /tmp/8fFgIGLCA6:1␤------> 3my7⏏5 'hello' $test␤»

[18:21] <GLRelia> rakudo-moar 2ffd6a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6pJglZ0rl8␤Malformed my␤at /tmp/6pJglZ0rl8:1␤------> 3my7⏏5 'hello' $test␤»

[18:23] <AlexDaniel> m: my Str where 'hello' $test;

[18:23] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5===␤Type 'Str' is not declared. Did you mean 'str'?␤at /tmp/1hszJKLnIJ:1␤------> 3my Str 7⏏5where 'hello' $test;␤Malformed my␤at /tmp/1hszJKLnIJ:1␤------> 3my Str 7⏏5where 'hello' $test;␤␤»

[18:23] <GLRelia> rakudo-moar 2ffd6a: OUTPUT«5===SORRY!5===␤Type 'Str' is not declared. Did you mean 'str'?␤at /tmp/hOAUR4_3gt:1␤------> 3my Str 7⏏5where 'hello' $test;␤Malformed my␤at /tmp/hOAUR4_3gt:1␤------> 3my Str 7⏏5where 'hello' $test;␤␤»

[18:23] <AlexDaniel> type Str is not declared? Hmm?

[18:24] <FROGGS> O.o

[18:24] <AlexDaniel> m: my str where 'hello' $test;

[18:24] <camelia> rakudo-moar f7cfe9: OUTPUT«5===SORRY!5===␤Type 'str' is not declared. Did you mean 'Str'?␤at /tmp/eflb_uvwk1:1␤------> 3my str 7⏏5where 'hello' $test;␤Malformed my␤at /tmp/eflb_uvwk1:1␤------> 3my str 7⏏5where 'hello' $test;␤␤»

[18:24] <GLRelia> rakudo-moar 2ffd6a: OUTPUT«5===SORRY!5===␤Type 'str' is not declared. Did you mean 'Str'?␤at /tmp/tnplEesp_X:1␤------> 3my str 7⏏5where 'hello' $test;␤Malformed my␤at /tmp/tnplEesp_X:1␤------> 3my str 7⏏5where 'hello' $test;␤␤»

[18:24] <AlexDaniel> what is going on here… I don't really understand

[18:24] <AlexDaniel> I thought that this code was valid?

[18:26] <FROGGS> m: my Str $test where 'hello';

[18:26] <camelia> rakudo-moar f7cfe9: ( no output )

[18:26] <GLRelia> rakudo-moar 2ffd6a: ( no output )

[18:26] <AlexDaniel> ooooooohhh

[18:26] <AlexDaniel> right

[18:26] <FROGGS> still... can you rakudobug that as a misleading error message?

[18:26] <AlexDaniel> FROGGS: of course!

[18:27] <FROGGS> AlexDaniel++

[18:32] <dalek> roast/glr: 857c7c2 | (Stefan Seifert)++ | S03-metaops/zip.t:

[18:32] <dalek> roast/glr: Replace usage of internal "munch" method in zip.t

[18:32] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/857c7c2b5a

[18:32] <dalek> roast/glr: 5e181ff | (Stefan Seifert)++ | S03-metaops/zip.t:

[18:32] <dalek> roast/glr: Adapt zip.t tests to new (non-)flattening semantics

[18:32] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/5e181fff2c

[18:32] <MilkmanDan> http://devopsreactions.tumblr.com/post/62048692029/converting-old-perl-scripts-to-puppet-manifests

[18:32] <dalek> rakudo/glr: 42c2d81 | (Stefan Seifert)++ | src/core/List.pm:

[18:32] <dalek> rakudo/glr: Fix "Method 'iterator' not found" in infix:<Z>

[18:32] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/42c2d8151c

[18:32] <dalek> rakudo/glr: 27cb277 | (Stefan Seifert)++ | src/core/metaops.pm:

[18:32] <dalek> rakudo/glr: Fix "Too many positionals passed" in METAOP_ZIP

[18:32] <dalek> rakudo/glr: 

[18:32] <dalek> rakudo/glr: The METAOP_REDUCE_* reducers expect only a single iterable while plain ops

[18:32] <dalek> rakudo/glr: require arguments passed separately.

[18:32] <dalek> rakudo/glr: Have to reify the mapped iterators to a List to avoid "This Seq has already

[18:32] <dalek> rakudo/glr: been iterated" errors.

[18:32] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/27cb2772e2

[18:33] *** dha joined
[18:35] *** dha left
[18:36] *** dha joined
[18:38] *** larion joined
[18:41] <dalek> roast/glr: 21d17ec | (Stefan Seifert)++ | S32-container/zip.t:

[18:41] <dalek> roast/glr: Fix remaining infix:<Z> tests

[18:41] <dalek> roast/glr: 

[18:41] <dalek> roast/glr: Need to explicitly flatten those ranges

[18:41] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/21d17ece39

[18:43] <AlexDaniel> m: my Str $test where 'test'; $test = 25;

[18:43] <camelia> rakudo-moar f7cfe9: OUTPUT«Type check failed in assignment to '$test'; expected '<anon>' but got 'Int'␤  in block <unit> at /tmp/309lVbuFOs:1␤␤»

[18:43] <GLRelia> rakudo-moar 27cb27: OUTPUT«Type check failed in assignment to '$test'; expected '<anon>' but got 'Int'␤  in block <unit> at /tmp/abKlIJY5S7:1␤␤»

[18:43] <AlexDaniel> expected '<anon>'?

[18:44] *** larion left
[18:45] *** diana_olhovik joined
[18:46] *** yqt joined
[18:50] *** vendethiel joined
[18:53] <dalek> roast/does-ok: e960b57 | (David Warring)++ | / (4 files):

[18:53] <dalek> roast/does-ok: utilize does-ok test assertion

[18:53] <dalek> roast/does-ok: review: https://github.com/perl6/roast/commit/e960b57767

[18:54] <AlexDaniel> can anybody delete this latest RT?

[18:54] <AlexDaniel> Looks like a virus: https://www.virustotal.com/en/file/b57d12cf848ba644babdc21c991096f79e2a45cafa28d1c5fef91f74c0ce046d/analysis/1440528830/

[18:55] <nine> Why is my %h = bag <a b o p a p o o>; not allowed to work? (it does currently, thereby failing a spec test)

[18:57] <FROGGS> nine: I am spectesting a fix for t/spec/S05-substitution/subst.rakudo.moar now btw

[18:58] <FROGGS> nine: dunno why it is not meant to work...

[18:59] *** dwarring joined
[18:59] *** anaeem1 joined
[18:59] <AlexDaniel> someone just did, thanks

[19:00] *** anaeem1_ left
[19:00] <FROGGS> I marked a ticket a spam which a subject Resume or so

[19:00] <dalek> roast/glr: d2a3cfc | (Stefan Seifert)++ | S02-types/range.t:

[19:00] <dalek> roast/glr: Range.pick and .roll are expected to return a Seq per GLR

[19:00] <dalek> roast/glr: 

[19:00] <dalek> roast/glr: We return a Seq now to avoid unnecessary copying and storing in cases where we

[19:00] <dalek> roast/glr: just iterate over the results once.

[19:00] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/d2a3cfcb7b

[19:01] <nine> That was really LHF ^^^ :)

[19:01] <FROGGS> nice :o)

[19:01] <nine> Should be at 104 now :)

[19:02] <AlexDaniel> wasn't it 80 already?

[19:02] <nine> That would have been nice...

[19:04] <AlexDaniel> huh what, was it my dream?

[19:04] <muraiki> ok, so it turns out what was happening is that inside of the tap callback I was calling exit $return_code, where $return_code was the result of a call to run(). if run succeeds it returns 0, but if it fails it returns some kind of object, which was causing exit to not actually exit

[19:05] <AlexDaniel> I remember staring at IRC window and seeing that it is just 80 now…

[19:05] *** sno left
[19:05] <muraiki> I thought I read somewhere that run() should always return the return code, so maybe those docs were out of date

[19:06] <dalek> roast/glr: c94cd06 | (Stefan Seifert)++ | S03-junctions/boolean-context.t:

[19:06] <dalek> roast/glr: Fix "Too few positionals passed" in S03-junctions/boolean-context.t

[19:06] <dalek> roast/glr: 

[19:06] <dalek> roast/glr: We no longer auto-flatten results of meta ops, need to unpack manually

[19:06] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/c94cd06281

[19:06] <nine> FROGGS: do you think this ok? ^^^

[19:07] *** [Sno] joined
[19:08] <FROGGS> nine: yes, I think so

[19:08] <nine> :) 103

[19:10] <nine> FWIW there still seems to be plenty of LHF in roast.

[19:10] <FROGGS> damn, my patch for subst makes one fail and two hang :(

[19:13] *** telex left
[19:14] *** telex joined
[19:16] *** [Sno] left
[19:17] <nine> FROGGS: are those hanger passing before your patch or did you just uncover the hangs?

[19:19] *** [Sno] joined
[19:20] <FROGGS> they were passing

[19:21] <jdv79> AlexDaniel: maybe the bare startup times are what you are thinging about

[19:22] <jdv79> what does it mean to be thinging ^H?

[19:23] <AlexDaniel> I doubt it. It is way more realistic to think that I'm from the future

[19:23] <jdv79> how is it there?

[19:24] <AlexDaniel> not too different

[19:24] <AlexDaniel> 80 spec test is about… two days from now?

[19:24] <AlexDaniel> s

[19:27] *** [Sno] left
[19:28] *** [Sno] joined
[19:29] *** yqt left
[19:29] *** mvuets joined
[19:29] * hoelzro prepares to head to ORD

[19:30] <hoelzro> see (many of) you in Olten!

[19:31] *** larion joined
[19:34] <laben> i'm trying to construct the best oneliner to accomplish a cool thing, i'm up to here "([1,1],[2,2],[3,3],[4,4]).map({[+] $_}) Z<=> (2, *+2...*)" but i dont know how to make that map better. anyone got a better idea?

[19:35] *** ab6tract left
[19:37] *** yqt joined
[19:38] *** anaeem1 left
[19:39] <timotimo> yay!

[19:39] <timotimo> hoelzro: looking forward to it :)

[19:39] <timotimo> have a good flight!

[19:41] <skids> laben: what needs to be better about the map?

[19:42] *** diana_olhovik left
[19:44] <timotimo> it needs to become the best map that has ever mapped

[19:45] <skids> well, if you knowthe arity is 2 then:

[19:46] <skids> m: say (flat [1,1],[2,2],[3,3],[4,4]).map(*+*) Z<=> (2, *+2...*)

[19:46] <camelia> rakudo-moar f7cfe9: OUTPUT«More Same␤»

[19:46] <GLRelia> rakudo-moar 27cb27: OUTPUT«Same Same Same Same␤»

[19:46] <timotimo> how are you? same same.

[19:49] *** diana_olhovik_ joined
[19:56] <dalek> perl6-roast-data: a3398ed | coke++ | / (8 files):

[19:56] <dalek> perl6-roast-data: today (automated commit)

[19:56] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/a3398edfcf

[19:57] *** brrt joined
[19:57] <laben> i wanted to do it with Whatever but cannot, i thought there could be a way. arity=2 is only the example here, in reality it differs for probably every array

[19:58] *** llfourn joined
[20:01] * [Coke] waves from JFK. Slowly making his way to Olten. :)

[20:01] *** cdc_ joined
[20:02] <cdc_> m: say ([1,1],[2,2],[3,3],[4,4]).map({[+] |$_}) Z<=> (2, *+2...*)

[20:02] <GLRelia> rakudo-moar 27cb27: OUTPUT«Same Same Same Same␤»

[20:02] <camelia> rakudo-moar f7cfe9: OUTPUT«Same Same Same Same␤»

[20:03] *** llfourn left
[20:04] *** darutoko- left
[20:06] *** xfix left
[20:07] *** diana_olhovik_ left
[20:07] *** diana_olhovik_ joined
[20:11] <masak> [Coke]: oh, you'll be in Olten? excellent!

[20:11] <masak> correct me if I'm wrong, but I don't believe we've met.

[20:13] <dha> I, sadly, will not be in Olten. :-(

[20:13] *** kaare_ left
[20:19] *** diana_olhovik_ left
[20:19] <timotimo> masak: i'll be in olten, too, and we haven't met yet, either :)

[20:20] *** diana_olhovik_ joined
[20:21] <[Coke]> masak:  no, we have not. I think you missed the one .eu thing I went to.

[20:21] *** rangerprice joined
[20:23] <pflanze> Is there any currying/uncurrying infrastructure in Perl6?

[20:24] <moritz> pflanze: you can automatically curry most operators by passing a * as argument

[20:24] <moritz> m: say map * + 2, 1..5

[20:24] <GLRelia> rakudo-moar 27cb27: OUTPUT«3 4 5 6 7␤»

[20:24] <camelia> rakudo-moar f7cfe9: OUTPUT«3 4 5 6 7␤»

[20:24] <jnthn> Alternatively, you may be looking for .assuming

[20:24] <jnthn> oooh, I have no messages :)

[20:26] <pflanze> Ok, interesting. What about uncurrying?

[20:27] *** laben left
[20:27] <moritz> what's uncurrying?

[20:27] * pink_mist imagines a .unassuming

[20:27] <pflanze> The inverse of currying: take a function that takes 1 argument then returns another function that takes 1 argument, and make that into a fuc

[20:27] <pflanze> function that takes 2 arguments.

[20:27] *** diana_olhovik_ left
[20:28] <pflanze> That's the simplest case, trivially written as a function:

[20:28] <pflanze> sub curry { my ($f)=@_; sub { my($a,$b)=@_; $f->($a)->($b) }} # Perl5 syntax

[20:28] <pflanze> erch.

[20:29] <pflanze> sub uncurry { my ($f)=@_; sub { my($a,$b)=@_; $f->($a)->($b) }} # Perl5 syntax

[20:29] <moritz> so, just function chaining?

[20:29] *** KCL joined
[20:29] <pflanze> But it gets more interesting if you want to combine function layers that take another number of arguments than 1.

[20:29] <rangerprice> Oh

[20:30] <pflanze> Hm, function chaining sounds like you mean compose.

[20:30] *** diana_olhovik_ joined
[20:31] *** rurban left
[20:32] *** KCL_ left
[20:33] <pflanze> Example: fun  ($x) { fix fun($self, $y) { $y > 0 ? $x * &$self($y-1) } }  # Perl5 with Function::Parameters

[20:34] <_itz> does anyone know where the "

[20:34] <_itz> Pre-Hackathon Dinner

[20:34] <_itz> " is?

[20:34] <pflanze>  # and `fix` defined to be the fixpoint combinator; it binds $self to a function representing the second function with just the $y argument.

[20:34] <_itz> . o O ( damm line breaks )

[20:35] <pflanze> moritz, so, this function now takes first $x then a start value for $y, then recurses till $y reaches 0 and returns a result.

[20:35] <pflanze> moritz, so now I want to represent it to the user as a function that takes $x and the start value for $y directly, without needing to chain the calls.

[20:36] <pflanze> i.e.:  fun original  ($x) { fix fun($self, $y) { $y > 0 ? $x * &$self($y-1) } }   original(10)->(20)

[20:36] <pflanze> *pleasant= uncurry *original;   pleasant(10,20) 

[20:39] <jnthn> _itz: I got the impression it may be at the venue, given folks are being pointed in that direction

[20:40] *** lizmat left
[20:41] <_itz> ok thanks

[20:42] <jnthn> Time for some much needed rest

[20:42] <jnthn> &

[20:50] <pflanze> moritz, here's what I've included in my project for Perl5 currently (definition, and example usage): https://github.com/pflanze/functional-perl/blob/master/lib/FP/uncurry.pm https://github.com/pflanze/functional-perl/blob/df4355ef1418505b352c41632d22696ee3fd3f6d/examples/gen-csv

[20:51] <timotimo> good rest, jnthn

[20:51] <pflanze> Perl5's need to have a subroutine declaration kind of spoils it; perhaps adding syntax is the right thing to do some time. So I was wondering how Perl6 would cope with this.

[20:53] <dalek> perl6-roast-data: 4e55de8 | coke++ | / (2 files):

[20:53] <dalek> perl6-roast-data: another glr run for today

[20:53] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/4e55de8b37

[20:54] <[Coke]> anyone else arriving in Zurich early Wednesday?

[20:54] <[Coke]> I am happy to wait a bit to ride a train with someone. (if not, I'll just head out to olten asap)

[20:56] *** Peter_R left
[20:57] *** llfourn joined
[20:57] <timotimo> vendethiel: do you already know when you'll take the train back to your home? if you're leaving the SPW via train at all

[20:58] <timotimo> i'd like to take the same train again, like we did after APW

[20:58] <vendethiel> timbunce: yes!

[20:59] <vendethiel> oops. sorry timbunce++. I meant timotimo++

[20:59] <[Coke]> ~~

[21:02] *** rindolf left
[21:02] *** llfourn left
[21:04] <virtualsue> we're arriving in zurich around 15:30

[21:05] <skids> pflanze: I think what you are looking for is simply closures.

[21:05] <pflanze> skids, those are all using closures.

[21:05] <pflanze> Not sure what you would mean.

[21:06] <pflanze> (Have closures changed in Perl6, new syntax or so?)

[21:07] <vendethiel> pflanze: fwiw, a good way to do it is just by allowing the curried version to take any number of arguments

[21:08] <pflanze> vendethiel, you mean auto-currying, if enough arguments have been passed, call the next level, until reaching the last?

[21:08] <vendethiel> pflanze: yes

[21:08] <pflanze> I'm not sold on this, as (1) it's got runtime overhead *and* would be difficult for a compiler to optimize away, (2) it hides what's going on more than the explicit version.

[21:09] <vendethiel> pflanze: https://gist.github.com/jnthn/9772688

[21:09] <vendethiel> that's an example

[21:09] <muraiki> is "say" thread-safe? or if I have multiple says going on in multiple .tap, could they end up mixing up in the console?

[21:10] <skids> m: my &f = -> &g { -> &h { -> $x { g(h($x)) } } }; &f(&abs)(&sin)(pi*3/2).say;

[21:10] <camelia> rakudo-moar f7cfe9: OUTPUT«1␤»

[21:10] <GLRelia> rakudo-moar 27cb27: OUTPUT«1␤»

[21:10] <skids> ^^pflanze

[21:11] <ugexe> no, if you have multipl threads doing say/print they certainly dont lock

[21:11] <ugexe> you can do it yourself though

[21:12] <pflanze> skids, hm, I don't know enough Perl6 to parse this. It looks like you're making a curried function, then calling it in the unchanged curried fashion (no uncurrying going on).

[21:12] <vendethiel> pflanze: -> &a {}; is an anonymous function that takes a hof "&f"

[21:12] <muraiki> ugexe: thanks

[21:12] <vendethiel> pflanze: and some-fn(&foo); passes the foo function to some-fn

[21:13] <pflanze> vendethiel, you mean &a (lexical variable a that's a function)?

[21:13] <vendethiel> pflanze: yes

[21:13] <vendethiel> m: sub p { say "hey hey"; }; sub call(&fn) { fn(); }; call(&p);

[21:13] <camelia> rakudo-moar f7cfe9: OUTPUT«hey hey␤»

[21:13] <GLRelia> rakudo-moar 27cb27: OUTPUT«hey hey␤»

[21:13] <pflanze> I was guessing right, then.

[21:14] <ugexe> muraiki: here is a messy as hell example https://github.com/ugexe/zef/blob/master/lib/Zef/CLI/StatusBar.pm6#L54

[21:15] <muraiki> ugexe: wow, thanks so much!

[21:15] <pflanze> skids, now my &ff= uncurry &f; &ff(&abs, &sin, pi*3/2)

[21:16] <pflanze> skids, actually, since this is merging 3 levels, my &ff= uncurry_1_1_1 &f; &ff(&abs, &sin, pi*3/2) 

[21:16] <pflanze> or  my &ff= uncurry uncurry &f; &ff(&abs, &sin, pi*3/2) 

[21:16] <pflanze> oh, the latter is actually wrong.

[21:17] <vendethiel> m: sub uncurry(&f) { -> $a, $b { f($a, $b); } }; my $add = -> $x { -> $y { $x + $y }; }; my $u-add = uncurry $add; say $u-add(1, 2);

[21:17] <camelia> rakudo-moar f7cfe9: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/j6iAQkvUoQ:1␤␤»

[21:17] <GLRelia> rakudo-moar 27cb27: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/iIGr9210cB:1␤␤»

[21:17] <vendethiel> whoops.

[21:17] <vendethiel> m: sub uncurry(&f) { -> $a, $b { f($a)($b); } }; my $add = -> $x { -> $y { $x + $y }; }; my $u-add = uncurry $add; say $u-add(1, 2);

[21:17] <camelia> rakudo-moar f7cfe9: OUTPUT«3␤»

[21:17] <GLRelia> rakudo-moar 27cb27: OUTPUT«3␤»

[21:18] <pflanze> vendethiel, yep. So that's what I have (see link I provided above); I'm covering the non-standard cases manually by exporting functions with names such as uncurry_1_2 etc.

[21:19] <pflanze> Seems Perl6 might be more regular with regards to syntax (Perl5 expects a declaration which it uses syntactically at compile time), which will help.

[21:19] <ugexe> is $a = $b = 0 an atomic assignment?

[21:20] <skids> pflanze: OIC. No, when you curry something it compiles.  You might be able to get similar results by using wrap, but it is an inefficient way to go about things.

[21:20] <pflanze> skids, what I'm talking about is the uglyness on https://github.com/pflanze/functional-perl/blob/df4355ef1418505b352c41632d22696ee3fd3f6d/examples/gen-csv

[21:21] <pflanze> where I need to "sub exps; *exps = "...

[21:21] <pflanze> Perl5 needs the "sub exps;" or it won't know that exps exists further down in the code and compile it differently.

[21:22] <pflanze> (compile exps as a method call instead)

[21:22] *** Peter_R joined
[21:22] <pflanze> I'm hoping Perl6 is saner.

[21:22] <vendethiel> :)

[21:24] <masak> 'night, #perl6

[21:24] <vendethiel> \o, masak

[21:24] <masak> why does my brain see "\o, masak" and go, "aha, it's the vocative". bad brain, bad!

[21:24] <masak> :P

[21:25] <masak> anywee, night \o #perl6

[21:26] <skids> pflaze: as far as declaring subs you can initialize a &a during declaration.

[21:26] <skids> m: my &f = &abs; f(-1).say # works fine.

[21:26] <camelia> rakudo-moar f7cfe9: OUTPUT«1␤»

[21:26] <GLRelia> rakudo-moar 27cb27: OUTPUT«1␤»

[21:28] <skids> As far as "uncurrying" you'd probably want to implement that as some sort of slang.  I personally could only see it being useful for converting strict FP code into procedural multiargs during a conversion -- otherwise why not define the prototype where people can see it instead of obfuscating it?

[21:28] <pflanze> Good. Looks like there's no difference (syntactically) between lexical and package variables in Perl6.

[21:29] <skids> pflanze: depends on what you declare them as -- there's also "our" and "is export"

[21:29] <pflanze> multiargs and FP are orthogonal.

[21:30] <skids> Depends on who you ask :-)

[21:30] <pflanze> Even Haskell has them.

[21:30] <pflanze> It's just that in Haskell the curried form is the default.

[21:31] *** muraiki left
[21:31] <pflanze> It makes some sense to have dynamically typed languages default to the uncurried form as it helps debugging.

[21:32] <vendethiel> pflanze: well, haskell doesn't need 0-args function because it's lazy :)

[21:32] <vendethiel> we're not nearly as lazy...

[21:32] <pflanze> ML has solved this with the unit value ("()") when curried.

[21:33] <vendethiel> pflanze: and ocaml added back all kind of issues with label and optional parameters :P

[21:34] <pflanze> (strip "when curried"; "when it's the last argument a function needs" is more correct.) 

[21:34] <skids> At any rate the "uncurry" construct either has to have functions carry around details about their innards that are normally thrown away, or be satisfied with being a simple wrapper that evals level by level and uses introspection to fugure out what it got at each level.

[21:35] <pflanze> You'll always encounter it in cases where an inner function recurses one of the inner levels.

[21:35] <pflanze> And takes as start an argument passed from outside.

[21:35] <pflanze> Then it's natural to leave it curried; and uncurry it outside for convenience.

[21:36] <pflanze> Doesn't need to be purely functional; just recursive.

[21:37] *** yqt left
[21:37] <pflanze> I'm sure "slang" sounds good, if that means, a module offers it. 

[21:37] <timotimo> modules can offer slangs, aye

[21:37] <skids> It's a rather deep form of language tinkering, even deeper than macros.

[21:38] <pflanze> I'll be happy to provide that module :) (when time comes)

[21:40] <pflanze> (The only thing concerning the outside of such a module is that compilers that can infer the types can optimize between curried and uncurried representation;

[21:40] <skids> pflanze: I think the more understandable approach to the recursive thing  under Perl6 would be to use multidispatch to seed the start value.

[21:41] <pflanze> GHC definitely does it. So, there would be room for a module-provided optimization pass, too, or so.)

[21:42] <pflanze> skids, you can also wrap it directly,  my &ff= ->&g,&h,&x { my &f= .... }

[21:42] <skids> anyway I should have left a long time ago.

[21:42] <pflanze> uncurry is just an abstraction for that pattern (i.e. takes away the need for you typing it out).

[21:43] <skids> .oO(write-once)

[21:43] *** skids left
[21:46] *** diana_olhovik_ left
[21:57] *** TimToady left
[21:58] *** mohij_ left
[22:06] *** TimToady joined
[22:09] <jercos> m: IO::Socket::Unix

[22:09] <camelia> rakudo-moar f7cfe9: OUTPUT«Could not find symbol '&Unix'␤  in block <unit> at /tmp/9XTnthmePP:1␤␤Actually thrown at:␤  in block <unit> at /tmp/9XTnthmePP:1␤␤»

[22:09] <GLRelia> rakudo-moar 27cb27: OUTPUT«Could not find symbol '&Unix'␤  in block <unit> at /tmp/YrQwEPHtRM:1␤␤Actually thrown at:␤  in block <unit> at /tmp/YrQwEPHtRM:1␤␤»

[22:10] <jdv79> the pause fix requires some schema changes.  i guess pause can be down for a few minutes.

[22:10] <jdv79> if it happens...

[22:17] *** mvuets left
[22:23] <jercos> so... are Unix sockets planned in any perl 6 version? 'cause I mean, e.g., nqp::socket() doesn't even take a family. If berkeley sockets were fully exposed I could maybe see writing up IO::Socket::Unix, but I don't think I have the time commitment to put towards changing nqp...

[22:24] <jercos> S32 mentions IO::Socket::Unix, and... that's about it as far as I can see

[22:26] <brrt> jercos: these things are planned, yes, but there are two 'challenges'

[22:26] <brrt> one is that we want this to work on multiple backends, namely jvm and moarvm

[22:27] * pmurias can write the nqp ops for js

[22:28] <pmurias> I could even try to write them for the java backend

[22:28] <jercos> yeah, I don't think there's a clean way to access Unix sockets from JVM without JNI... or JS for that matter >.>

[22:28] <brrt> moarvm, as far as i can see, would require some hackery iwth libuv

[22:28] <jercos> Parrot's socket API seems to be berkeley enough for it to work, but I haven't looked into that.

[22:29] <pmurias> jercos: for the io stuff in js I just target node.js

[22:30] <AlexDaniel> m: my $p1 = start { say "1:{foo()}" }; my $p2 = start { say "2:{foo()}" }; say "3:{foo()}"; await $p1, $p2; say foo(); sub foo() is cached { sleep rand * 2; rand }

[22:30] <GLRelia> rakudo-moar 27cb27: OUTPUT«3:0.497086709580827␤1:0.344976470869383␤2:0.446260711123365␤0.446260711123365␤»

[22:30] <camelia> rakudo-moar f7cfe9: OUTPUT«3:0.809124497460455␤2:0.381401760822368␤1:0.816585751269165␤0.816585751269165␤»

[22:30] <pmurias> obviously the browser can't open unix sockets

[22:30] <AlexDaniel> so it is always the last execution

[22:30] <AlexDaniel> interesting

[22:31] <jercos> TIL node.js has Unix sockets. neato. :)

[22:37] *** RabidGravy left
[22:38] *** virtualsue left
[22:41] *** TimToady left
[22:42] *** TimToady joined
[22:44] *** vendethiel left
[22:47] *** freeze left
[22:49] *** freeze joined
[22:54] *** freeze left
[22:55] *** freeze joined
[22:57] *** TimToady left
[22:58] *** llfourn joined
[23:03] *** llfourn left
[23:04] *** TimToady joined
[23:05] *** brrt left
[23:14] *** skids joined
[23:29] *** pierrot joined
[23:31] *** ribasushi left
[23:33] *** nebuchad` joined
[23:35] *** ribasushi joined
[23:50] *** TimToady left
[23:52] *** pmurias left
[23:53] *** TimToady joined
[23:58] *** TimToady left
