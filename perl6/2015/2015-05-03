[00:04] <dalek> roast: 6f1e2f1 | coke++ | S03-operators/assign-is-not-binding.t:

[00:04] <dalek> roast: Remove hard skip for test that is passing

[00:04] <dalek> roast: review: https://github.com/perl6/roast/commit/6f1e2f1e9b

[00:05] *** vendethiel joined
[00:09] <[Coke]> I thought we removed all the parrot fudges. Do we want those gone?

[00:09] *** erdic joined
[00:10] <[Coke]> there are 98 instances left.

[00:11] *** raiph left
[00:13] *** raiph joined
[00:14] <[Coke]> I'll get a patch ready if the concensus is to get rid of them

[00:14] *** tinyblak joined
[00:19] *** atweiden joined
[00:19] *** tinyblak left
[00:22] *** cognominal left
[00:28] *** vendethiel left
[00:34] *** airdisa left
[00:50] * [Coke] finds AnyChar in the spec.

[00:50] <[Coke]> sorry, the syn

[00:52] <[Coke]> jnthn: Is this still a thing to be implemented or does this predate NFG? the spec test for this (S29-type/declarations.t) dates from 2008.

[01:02] <[Coke]> t/spec/S12-construction/destruction.t seems like a flawed test.

[01:02] *** BenGoldberg left
[01:02] *** BenGoldberg joined
[01:06] <[Coke]> m: say $*OS

[01:06] <camelia> rakudo-moar 56cae1: OUTPUT«opensuse␤Saw 1 call to deprecated code during execution.␤================================================================================␤$*OS called at:␤  /tmp/sPM0lwLhez, line 1␤Deprecated since v2014.9, will be removed with release v2015.9!␤…»

[01:07] <[Coke]> m: say $*OSVER

[01:07] <camelia> rakudo-moar 56cae1: OUTPUT«13.2.Harlequin␤Saw 1 call to deprecated code during execution.␤================================================================================␤$*OSVER called at:␤  /tmp/MI4Mrn9Rf7, line 1␤Deprecated since v2014.9, will be removed with release v2…»

[01:09] <[Coke]> I'm pulling the trigger on the rakudo.parrot removal; won't mind if someone reverts it.

[01:09] <dalek> roast: 506ffcd | coke++ | / (44 files):

[01:09] <dalek> roast: Remove rakudo.parrot fudges

[01:09] <dalek> roast: 

[01:09] <dalek> roast: Will have to refudge once parrot support returns regardless.

[01:09] <dalek> roast: review: https://github.com/perl6/roast/commit/506ffcd2ad

[01:09] <dalek> roast: 4f132bf | coke++ | S02-magicals/perlver.t:

[01:09] <dalek> roast: Remove file with gone or going vars.

[01:09] <dalek> roast: 

[01:09] <dalek> roast: Rakudo wasn't running this file anyway

[01:09] <dalek> roast: review: https://github.com/perl6/roast/commit/4f132bf021

[01:12] <[Coke]> m: say %=pod

[01:12] <camelia> rakudo-moar 56cae1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/T8o3SZ6YeX␤Variable '%=pod' is not declared. Did you mean '$=pod'?␤at /tmp/T8o3SZ6YeX:1␤------> 3say %=pod7⏏5<EOL>␤    expecting any of:␤        postfix␤»

[01:12] <[Coke]> m: say $=pod

[01:12] <camelia> rakudo-moar 56cae1: OUTPUT«␤»

[01:14] <tadzik> ruoso: I see you're solving some of the problems I did; if I were to build a module to help generate grammars from code, would you be interested in that?

[01:14] <yoleaux> 1 May 2015 05:09Z <skids> tadzik: I sent you a pull request to Grammar::BNF that adds ABNF (popular in modern RFCs)

[01:14] <tadzik> oh! Awesome!

[01:14] <tadzik> xBNF looks like a trendy thing these days :)

[01:15] <skids> Also I am currently adapting ruoso++'s slang code to Grammar::BNF

[01:15] <skids> Almost done.

[01:15] <tadzik> cool :)

[01:16] <dalek> specs: 13f1284 | coke++ | S28-special-names.pod:

[01:16] <dalek> specs: Track an old change to this var name.

[01:16] <dalek> specs: review: https://github.com/perl6/specs/commit/13f1284086

[01:16] <tadzik> I promise to look at your PR tomorrow, now I'm between drunk and sleepy :)

[01:17] <skids> Never a good place to be when attempting to code, but otherwise a fine state of mind :-)

[01:18] <tadzik> well, one of my milestones on GSoC few years back was done under such circumstances

[01:18] <dalek> roast: c3083de | coke++ | S02-literals/pod.t:

[01:18] <dalek> roast: Track %=pod -> $=pod change...

[01:18] <dalek> roast: 

[01:18] <dalek> roast: ... but rakudo still can't run this test

[01:18] <dalek> roast: review: https://github.com/perl6/roast/commit/c3083ded8b

[01:18] <tadzik> a comfy chair, a fireplace and a few cans of Żubr beer

[01:18] <tadzik> woke up next morning with code working and tests passing

[01:18] <tadzik> *shrug*, commit, push, I still don't know how I solved it

[01:19] <skids> :-)

[01:20] <skids> It will be interesting to bench some generated RFC grammars against ugexe++'s pure-perl versions.

[01:20] <[Coke]> jnthn: you just added S04-statements/when.t a little while ago; that exception doesn't exist yet. Do we need a ticket to track ?

[01:21] <tadzik> skids: I glanced over your PR, do you have some tuits to put some sort of real-world grammar into the test suite?

[01:22] <tadzik> one thing that amused me a lot is when I put the BNF grammar from wikipedia into my tests and thus proved it incorrect :)

[01:22] *** Ven joined
[01:22] * [Coke] adds some train-based commits.

[01:23] <tadzik> . o O ( TRAIN RAIN )

[01:23] <skids> tadzik: probably tomorrow or over the course of the next week.  I do want to eventually get to doing HTTP header parsing.

[01:35] *** Ven left
[01:36] <skids> tadzik: I PRd the slang support just now.

[01:37] *** tinyblak joined
[01:40] <skids> tadzik: RFC grammars are often full of "here's the BNF/ABNF but SHOULD tolerate this on input and MAY tolerate this but only when you are acting in the proxy role" so yeah, fun stuff.  There will definitely need to be subgrammars wrapped around for such things.  Good thing grammars are subclassable.

[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:58] *** bjz joined
[02:01] *** xinyuan_ joined
[02:02] *** Ven joined
[02:02] *** BenGoldberg left
[02:06] *** vendethiel joined
[02:10] *** Ven left
[02:19] *** BenGoldberg joined
[02:20] *** noganex_ joined
[02:23] *** noganex left
[02:24] *** rmgk_ joined
[02:24] *** rmgk left
[02:24] *** rmgk_ is now known as rmgk

[02:27] *** vendethiel left
[02:29] *** gfldex left
[02:32] *** alini left
[02:45] *** mattp|spurs is now known as mattp

[03:08] *** vendethiel joined
[03:10] *** konsolebox left
[03:10] *** konsolebox joined
[03:12] *** konsolebox left
[03:13] *** konsolebox joined
[03:22] *** mr-foobar left
[03:34] *** ssqq joined
[03:35] <ssqq> p6: grammar A { token sym { <.ident> }; token id { <sym> }; }

[03:35] <camelia> rakudo-moar 56cae1: OUTPUT«===SORRY!===␤Substring length (-3) cannot be negative␤»

[03:35] <geekosaur> o.O

[03:37] <ssqq> p6: grammar B { token add-char { < $ @ % > }; token id { <+ alpha add-char> }; }

[03:37] <camelia> rakudo-moar 56cae1: ( no output )

[03:39] <ssqq> p6: grammar B { token add-char { < $ @ % > }; token TOP { <+ alpha add-char> }; }; B.subparse('$');

[03:39] <camelia> rakudo-moar 56cae1: OUTPUT«Method 'char' not found for invocant of class 'B'␤  in regex TOP at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[03:39] <ShimmerFairy> IIRC <sym> is for rule names like  token id:sym<stuff>  , and then <sym> would match  stuff  .

[03:40] <ssqq> ShimmerFairy: I see, name conflict.

[03:45] <ssqq> token name like 'a-b' could not use `<+ token-name>`

[03:45] *** fhelmberger joined
[03:46] *** Sqirrel left
[03:49] *** raiph left
[03:50] *** tinyblak left
[03:50] *** fhelmberger left
[03:50] *** tinyblak joined
[03:51] *** ssqq left
[03:54] *** tinyblak left
[04:04] *** xinyuan_ left
[04:12] *** BenGoldberg left
[04:12] *** tinyblak joined
[04:12] *** Sqirrel joined
[04:14] *** vendethiel left
[04:29] *** larks_ left
[04:39] *** atweiden left
[04:40] <TimToady> greetings from Furnace Creek, Death Valley, where today it only got up to 108℉

[04:41] <TimToady> m: say (108-32) * 5/9

[04:41] <camelia> rakudo-moar 56cae1: OUTPUT«42.222222␤»

[04:41] <TimToady> so 42℃ or so

[04:49] <timotimo> i wouldn't mind if camelia learned to reduce the number of ============= in a deprecation note so that we'll see what should be used instead right here in the channel

[04:49] * timotimo heads back to bed

[04:49] <Timbus_> 42C.. yeesh. i hope you found shade..

[04:49] <Timbus_> always walk through the shadows in the valley of death.

[04:51] *** ggoebel left
[05:01] <flussence> it's 6°C here! Colder than it's been for any day all winter.

[05:26] <jdv79> of course i get home and no wifi issues - only at the hackathon.  figures.

[05:38] *** jack_rabbit joined
[05:39] *** rindolf joined
[05:40] *** alini joined
[05:45] *** Patterner joined
[05:47] *** jack_rabbit left
[05:50] *** Psyche^ left
[05:52] *** laouji joined
[06:09] <moritz> timotimo: or pastebin the untruncated output, and supply a short URL to the pastebin

[06:16] *** konsolebox left
[06:25] *** domidumont joined
[06:27] *** skids left
[06:30] *** domidumont left
[06:31] *** domidumont joined
[06:37] *** camel___________ joined
[06:40] *** laouji left
[06:41] *** laouji joined
[06:42] *** risou is now known as risou_awy

[06:42] *** risou_awy is now known as risou

[06:45] *** laouji left
[07:01] *** konsolebox joined
[07:04] *** rindolf left
[07:09] *** konsolebox left
[07:09] *** araujo left
[07:15] *** araujo joined
[07:16] *** diana_olhovik_ joined
[07:23] *** rindolf joined
[07:24] *** laouji joined
[07:26] *** [TuxCM] left
[07:27] *** espadrine joined
[07:42] *** mr-foobar joined
[07:44] *** Alina-malina left
[07:46] *** fhelmberger joined
[07:47] *** darutoko joined
[07:48] <lizmat> good *, #perl6!

[07:48] <lizmat> m: say gethostname()

[07:48] <camelia> rakudo-moar 56cae1: OUTPUT«ns1␤»

[07:50] *** fhelmberger left
[07:51] *** Foxcool_ joined
[07:51] *** camel___________ left
[07:54] *** domidumont left
[08:04] *** konsolebox joined
[08:07] *** rindolf left
[08:15] *** Alina-malina joined
[08:19] *** telex left
[08:20] *** telex joined
[08:21] *** Ven joined
[08:22] *** Ven left
[08:26] *** baest_ joined
[08:28] *** baest left
[08:36] *** diana_olhovik_ left
[08:38] <dalek> rakudo/nom: 065219c | lizmat++ | src/core/Deprecations.pm:

[08:38] <dalek> rakudo/nom: Make deprecation more camelia friendly, timotimo++

[08:38] <dalek> rakudo/nom: 

[08:38] <dalek> rakudo/nom: Also mention RC-0 as a cutoff time for deprecations.

[08:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/065219c925

[08:39] *** virtualsue joined
[08:43] *** mj41 joined
[08:45] *** diana_olhovik_ joined
[08:49] <lizmat> m: say $*OS

[08:49] <camelia> rakudo-moar 56cae1: OUTPUT«opensuse␤Saw 1 call to deprecated code during execution.␤================================================================================␤$*OS called at:␤  /tmp/zdwQ_nB72L, line 1␤Deprecated since v2014.9, will be removed with release v2015.9!␤…»

[08:53] *** cygx joined
[08:54] <cygx> o/

[08:55] <cygx> found a precompilation bug: https://gist.github.com/cygx/73df9343bb97208b0534

[08:55] <cygx> BEGIN $*KERNEL in a module closes $*OUT oO

[08:56] <cygx> same with $*DISTRO, but eg not $*VM

[08:56] <lizmat> cygx: please rakudobug

[08:57] <lizmat> that seems like something jnthn can sink his teeth into  :-)

[08:57] <lizmat> excellent golf!

[09:13] *** Rounin joined
[09:34] *** Ven joined
[09:35] <lizmat> m: say $*OS

[09:35] <camelia> rakudo-moar 065219: OUTPUT«opensuse␤Saw 1 call to deprecated code during execution.␤$*OS called at:␤  /tmp/SyplJEvmNi, line 1␤Deprecated since v2014.9, will be removed with release v2015.9!␤Please use $*DISTRO.name instead.␤»

[09:36] <lizmat> timotimo: ^^

[09:36] *** Ven left
[09:48] *** Akagi201_ left
[09:49] *** Akagi201 joined
[09:49] *** RabidGravy joined
[09:50] *** Akagi201_ joined
[09:53] *** Akagi201 left
[10:03] <[Tux]> m: say $*OS.VERSION

[10:03] <camelia> rakudo-moar 065219: OUTPUT«Method 'VERSION' not found for invocant of class 'Obsolete'␤  in block <unit> at /tmp/HVhLQhUiyw:1␤␤»

[10:03] <[Tux]> m: say $*OS.version

[10:03] <camelia> rakudo-moar 065219: OUTPUT«Method 'version' not found for invocant of class 'Obsolete'␤  in block <unit> at /tmp/D6bRPvTsQT:1␤␤»

[10:05] <lizmat> m: say $*DISTRO.name.version

[10:05] <camelia> rakudo-moar 065219: OUTPUT«Method 'version' not found for invocant of class 'Str'␤  in block <unit> at /tmp/uf4Thvy8bP:1␤␤»

[10:05] <lizmat> m: say $*DISTRO.version

[10:05] <camelia> rakudo-moar 065219: OUTPUT«v13.2.Harlequin␤»

[10:05] <lizmat> m: say $*OSVER

[10:05] <camelia> rakudo-moar 065219: OUTPUT«13.2.Harlequin␤Saw 1 call to deprecated code during execution.␤$*OSVER called at:␤  /tmp/3OBGsMVa8m, line 1␤Deprecated since v2014.9, will be removed with release v2015.9!␤Please use $*DISTRO.version instead.␤»

[10:05] <[Tux]> m: $*DISTRO.^methods».name.say

[10:05] <camelia> rakudo-moar 065219: OUTPUT«BUILD Str gist <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon>␤»

[10:06] *** laouji left
[10:08] <[Tux]> m: $*DISTRO.perl.say

[10:08] <camelia> rakudo-moar 065219: OUTPUT«Distro.new(release => "13.2", is-win => Bool::False, path-sep => ":", name => "opensuse", auth => "https://opensuse.org/", version => Version.new('13.2.Harlequin'), signature => Blob, desc => "2015-05-03T12:08:11+0200")␤»

[10:08] * [Tux] thinks release and version are swapped

[10:08] <[Tux]> Harlequin is a nickname for this release, not for the version

[10:08] <lizmat> m: say $*DISTRO.release

[10:09] <camelia> rakudo-moar 065219: OUTPUT«13.2␤»

[10:09] <[Tux]> the version is 13.2, the release is 13.2 (Harlequin)

[10:09] *** gfldex joined
[10:10] <lizmat> m: say /etc/os-release'.IO.lines

[10:10] <camelia> rakudo-moar 065219: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bp_qoAICPg␤Two terms in a row␤at /tmp/bp_qoAICPg:1␤------> 3say /etc/7⏏5os-release'.IO.lines␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end…»

[10:10] <lizmat> m: say '/etc/os-release'.IO.lines

[10:10] <camelia> rakudo-moar 065219: OUTPUT«NAME=openSUSE VERSION="13.2 (Harlequin)" VERSION_ID="13.2" PRETTY_NAME="openSUSE 13.2 (Harlequin) (x86_64)" ID=opensuse ANSI_COLOR="0;32" CPE_NAME="cpe:/o:opensuse:opensuse:13.2" BUG_REPORT_URL="https://bugs.opensuse.org" HOME_URL="https://opensuse.org/" I…»

[10:10] <lizmat> [Tux]: so what should be where in your opinion

[10:10] <[Tux]> VERSION_ID => version

[10:11] <[Tux]> PRETTY_NAME => release

[10:11] <lizmat> is PRETTY_NAME portable ?

[10:11] <[Tux]> one sec

[10:12] <[Tux]> https://github.com/abeltje/Test-Smoke/tree/master/lib/Test/Smoke/SysInfo and below

[10:12] <[Tux]> test cases are in t/etc

[10:12] <[Tux]> that is what we use for Test::Smoke identification

[10:13] <[Tux]> https://github.com/abeltje/Test-Smoke/tree/master/t/etc <= a collection of what OS's gather in dist-info related files

[10:14] <[Tux]> For Linux, even (very) old versions, use this code in perl5: https://github.com/abeltje/Test-Smoke/blob/master/lib/Test/Smoke/SysInfo/Linux.pm#L62

[10:15] <lizmat> ok, that seems like some nice LHF for someone else  :)

[10:15] * lizmat working on is lazy

[10:16] <[Tux]> https://github.com/abeltje/Test-Smoke/blob/Belin2015_Aftermath/lib/Test/Smoke/SysInfo/Linux.pm#L62 <=  that one is more up-to-date

[10:16] <[Tux]> (some distro's have levels of os-release files)

[10:17] <lizmat> Belin2015 ?  not Berlin2015 ?

[10:17] <[Tux]> https://github.com/abeltje/Test-Smoke/commit/4443c5dec314eb5ee41814ab81c35be520867f4a

[10:17] *** bjz left
[10:17] <[Tux]> I did not create that branch name :)

[10:18] *** bjz joined
[10:19] <[Tux]> lizmat, /me is willing to help out there if someone would want me to

[10:19] <lizmat> PR's welcome!

[10:19] <[Tux]> I think that t/etc folder will give you a whealth of info

[10:19] <jnthn> o/

[10:20] <lizmat> jnthn /o

[10:20] <[Tux]> and if anyone has an OS that is not yet listed, I'd be very interested in getting the required info files

[10:21] <lizmat> jnthn: work on "is lazy" so far

[10:21] <[Tux]> just execute t/etc/get-lsb.pl

[10:21] <lizmat> https://gist.github.com/lizmat/11ac7b63a2faa074d20e

[10:21] <jnthn> wtf, we suddenly have 1,300 tickets in RT?!

[10:22] <lizmat> jnthn: trying to adapt the buildplan to shove an empty initiializer in there, however I can't get it empty enough 

[10:22] <lizmat>                 my $default := nqp::can($_,'lazy')

[10:22] <lizmat>                   ?? -> $self, $attr { $type }

[10:22] <lizmat>                   !! $_.build;

[10:23] <lizmat> jnthn: I'm out of ideas atm

[10:23] <lizmat> Cannot invoke this object (REPR: Null, cs = 0)  :-(

[10:25] <lizmat> seems it lost !build_closure :-(

[10:27] <lizmat> jnthn: wrt to #RT tickets, they weren't added last night, something else changed ?

[10:29] <jnthn> lizmat: Maybe this is a better way: https://gist.github.com/anonymous/08896f0615a976d6caa1

[10:30] <lizmat> ok, testing that

[10:30] <jnthn> It looks different from setting a default, which is probably good :)

[10:32] <lizmat> hehe...

[10:32] *** game0 joined
[10:32] <lizmat> I just found there's a "will build" trait ?

[10:32] *** game0 left
[10:33] <jnthn> That may we what has $.foo = ... desugars to...

[10:33] <jnthn> *may be

[10:33] <lizmat> ah, ok

[10:36] <lizmat> yeah, that works and *is* much simpler

[10:36] <jnthn> :)

[10:37] <lizmat> althought the:

[10:37] <lizmat> $attr.package.^method_table{$attr.name.substr(2)}.wrap(-> \self {

[10:37] <lizmat>                 callsame() // $attr.set_value(self, $block())

[10:37] <lizmat>             });

[10:37] <lizmat> feels a bit like a rabbit out of a hat  :-)

[10:37] <[Tux]> lizmat, where is the code for DISTRO (in case I would find tuits to come up with suggestions)

[10:37] <lizmat> src/core/Distro.pm

[10:37] <[Tux]> takk

[10:37] <jnthn> lizmat: If you take it apart it's not so bad.

[10:37] <lizmat> $attr.name.substr(2)   # pretty magic to me

[10:38] <jnthn> m: class A { has $.foo }; say A.^attributes[0].name

[10:38] <camelia> rakudo-moar 065219: OUTPUT«$!foo␤»

[10:38] <jnthn> m: class A { has $.foo }; say A.^attributes[0].name.substr(2)

[10:38] <camelia> rakudo-moar 065219: OUTPUT«foo␤»

[10:38] <jnthn> :)

[10:38] <jnthn> Basically, given the variable name, compute the accessor name 

[10:38] <lizmat> m: m: class A { has $.foo }; say A.^attributes[0].name.substr(0,2)

[10:38] <camelia> rakudo-moar 065219: OUTPUT«$!␤»

[10:38] <lizmat> ah, ok

[10:39] <lizmat> duh

[10:40] <lizmat> well, I learned a lot about buildplans and such  :-)

[10:43] <jnthn> All the RTs are 'cus somebody but all the Rakudo fudge'd spectests into RT tickets

[10:43] <lizmat> wow

[10:43] <lizmat> didn't see anything on the ml  

[10:43] <jnthn> Once I get over the initial shock, it's probably worth it, in so far as having 1,300 RTs will piss me off enough to start processing them. :P

[10:44] <jnthn> Which we really should do ahead of 6.0

[10:45] *** mj41 left
[10:45] <RabidGravy> having looked at a few bits of that however, the associated PR to roast may have been based on an out of date clone

[10:53] *** virtualsue left
[10:55] <RabidGravy> also, it would appear that there is stuff in S03-magicals/ that would probably be better in S28-named-variables/ as KERNEL DISTRO etc aren't mentioned in S03

[10:55] <lizmat> RabidGravy: it's probably for hysterical raisins that they're in there

[10:56] <RabidGravy> er S02

[10:57] <dalek> rakudo/nom: bdc66e7 | lizmat++ | src/core/traits.pm:

[10:57] <dalek> rakudo/nom: Introduce Attribute will lazy initializer, jnthn++

[10:57] <dalek> rakudo/nom: 

[10:57] <dalek> rakudo/nom: Inspired by rjbs++, this will actually first wrap the Attribute composer,

[10:57] <dalek> rakudo/nom: and in there, wrap the accessor with code that will call the indicated

[10:57] <dalek> rakudo/nom: block once to set the value, then call the original accessor again.

[10:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bdc66e79da

[10:57] <lizmat> jnthn: I replaced the // with a once block, otherwise if the block returned a type object, it would be called again and again

[10:59] <lizmat> .tell rjbs "has $.fh will lazy { $file.IO.open }"  at your service  :-)

[10:59] <yoleaux> lizmat: I'll pass your message to rjbs.

[11:00] *** ggoebel joined
[11:00] <jnthn> lizmat: That's...screw it up over instances, no?

[11:00] <lizmat> ah, hmmm... lemme check

[11:01] <lizmat> grrrr

[11:01] <lizmat> you're right

[11:01] <lizmat> (sorry Grrrr)

[11:07] *** laouji joined
[11:12] *** laouji left
[11:13] <cygx> another precompilation bug, this time not golfed: https://gist.github.com/cygx/5dbbea302e0f536615c5

[11:17] *** Foxcool_ left
[11:19] *** Foxcool joined
[11:30] <dalek> rakudo/nom: fd90eb6 | lizmat++ | src/core/traits.pm:

[11:30] <dalek> rakudo/nom: Call lazy code until we have a defined value

[11:30] <dalek> rakudo/nom: 

[11:30] <dalek> rakudo/nom: Tried to fix this by introducing an "$!initialized" attribute in the role,

[11:30] <dalek> rakudo/nom: but couldn't get that to work, some weird scoping / capturing issues.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd90eb68fa

[11:37] *** airdisa joined
[11:42] *** alini left
[11:47] *** cognominal joined
[11:52] <dalek> rakudo/nom: c72d670 | lizmat++ | src/core/traits.pm:

[11:52] <dalek> rakudo/nom: Fix message on Attribute will foo

[11:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c72d67051d

[11:53] <ab5tract_> lizmat: cool patches :D

[11:53] <dalek> roast: 1f384ba | lizmat++ | S12-attributes/instance.t:

[11:53] <dalek> roast: Add some "will lazy" and "is/will foo" tests

[11:53] <dalek> roast: review: https://github.com/perl6/roast/commit/1f384ba197

[11:54] <lizmat> ab5tract_: those were really jnthn++'s work, /me is just a minion  :-)

[11:57] *** spider-mario joined
[12:04] *** RabidGravy left
[12:07] *** kaare_ left
[12:10] <rjbs> lizmat: I look forward to seeing how it got implemented.

[12:10] <yoleaux> 10:59Z <lizmat> rjbs: "has $.fh will lazy { $file.IO.open }"  at your service  :-)

[12:11] <rjbs> lizmat++ jnthn++ # thanks, I think this i a big deal

[12:11] <lizmat> rjbs: https://github.com/rakudo/rakudo/commit/bdc66e79da and https://github.com/rakudo/rakudo/commit/fd90eb68fa

[12:11] <rjbs> vielen Dank, I'll read this after breakfast; the women of the house have declared we will go get crêpes now

[12:12] <lizmat> hmmm.... crêpes  ....  good choice

[12:15] *** eli-se joined
[12:16] *** eli-se left
[12:16] * lizmat hopes FROGGS is doing ok

[12:22] *** tinyblak_ joined
[12:23] *** eli-se joined
[12:24] *** laouji joined
[12:24] *** tinyblak left
[12:26] <cygx> jnthn: I'm unable to figure out https://gist.github.com/cygx/5dbbea302e0f536615c5

[12:27] <cygx> jnthn: after compilation, Pointer[type] dies (where type is a CStruct)

[12:28] *** vendethiel joined
[12:32] *** eli-se left
[12:33] * [Coke] begins to backlog...

[12:33] *** szabgab joined
[12:33] <dalek> roast: 71ea556 | lizmat++ | S02-lexical-conventions/begin_end_pod.t:

[12:33] <dalek> roast: Actually test what we say we're testing

[12:33] <dalek> roast: review: https://github.com/perl6/roast/commit/71ea556232

[12:36] <szabgab> hello there

[12:36] <szabgab> this might not be a good time to chat here, but at least I leave this info here

[12:36] <[Coke]> so, the person who opened all the tickets took something I said at the hackathon and ran as far as they could with it without actually checking with me before they pulled the trigger on anything. I expected maybe ONE more ticket when I woke up this morning. Looks like there is a lot of cleanup to do, I think he opened a ticket for each fudge directive, not for each bug.

[12:37] <[Coke]> so, I'm going to apply his fudge patch (if not already done) and then start consolidating tickets and fudge markers.

[12:38] <szabgab> I am helping the YAPC::EU organizers with some PR  (not Pull Request) and I've noticed there are only 3 talks about Perl 6   http://act.yapc.eu/ye2015/talks/tag/perl6

[12:39] <szabgab> (though I only see the accepted talks) It would be great to see some more Perl 6 talks submitted

[12:39] <jnthn> szabgab: I plan to be there, just didn't submit yet.

[12:39] <jnthn> (It's on my todo list.)

[12:39] <szabgab> Also the organizer would like to know if you would like to organize a Hackathon

[12:39] <lizmat> I'm also planning to be there, just not planning to do a presentation

[12:40] <szabgab> jnthn: great, push it please

[12:40] *** araujo left
[12:41] <[Coke]> is dnmfarrell on IRC?

[12:43] *** araujo joined
[12:45] *** araujo left
[12:46] *** araujo joined
[12:46] <[Tux]> class A { has B $.b is rw; has Str $.s is rw; }; class B { has A @.a; }

[12:46] <szabgab> oh and as I am usually not on IRC, could you just encourage each other to submit talks, please?

[12:47] <[Tux]> that is impossible, as B is not defined by the time A is compiled and vice versa

[12:47] <moritz> [Coke]: http://irclog.perlgeek.de/perl6/search/?nick=dnmfarrell&q= yes 

[12:47] <[Tux]> can I force A.b to be of type B later?

[12:47] *** araujo left
[12:47] <[Tux]> or in another way

[12:47] <szabgab> Oh and if someone would like to run a Perl 6 course, there are still rooms for that too

[12:48] *** araujo joined
[12:48] *** szabgab left
[12:48] <jnthn> [Tux]: Stub B first

[12:48] <jnthn> class B { ... }

[12:48] *** araujo left
[12:48] <lizmat> m: class B { ... }; class A { has B $.b is rw; has Str $.s is rw; }; class B { has A @.a; }

[12:48] <camelia> rakudo-moar c72d67: ( no output )

[12:49] *** araujo joined
[12:49] <lizmat> m: cclass A { has B $.b is rw; has Str $.s is rw; }; class B { has A @.a; }

[12:49] <camelia> rakudo-moar c72d67: OUTPUT«5===SORRY!5===␤Type 'B' is not declared␤at /tmp/ZWPzlD_g0v:1␤------> 3cclass A { has B7⏏5 $.b is rw; has Str $.s is rw; }; class ␤Malformed has␤at /tmp/ZWPzlD_g0v:1␤------> 3cclass A { has7⏏5 B $.b is rw; has Str $.s is rw; }; cl…»

[12:49] <lizmat> m: class A { has B $.b is rw; has Str $.s is rw; }; class B { has A @.a; }

[12:49] <camelia> rakudo-moar c72d67: OUTPUT«5===SORRY!5===␤Type 'B' is not declared␤at /tmp/x4sT0uG0ji:1␤------> 3class A { has B7⏏5 $.b is rw; has Str $.s is rw; }; class ␤Malformed has␤at /tmp/x4sT0uG0ji:1␤------> 3class A { has7⏏5 B $.b is rw; has Str $.s is rw; }; clas…»

[12:49] <[Tux]> jnthn, that works. thanks

[12:50] * [Tux] has entangled himself into the swamp of callbacks

[12:53] <[Coke]> anyway, thanks everyone for not freaking out. I'll get RT cleaned up as soon as possible so that we get the benefit of the new tickets, but not the duplication.

[12:53] <jnthn> [Coke]++

[12:54] *** domidumont joined
[12:54] <jnthn> [Coke]: Just looking at some of the titles, I can see that some of them rely on out-dated spec.

[12:54] <jnthn> [Coke]: Or possibly the design docs need changes :)

[12:54] <jnthn> Like the AnyChar thing you mentioned before.

[12:55] <[Coke]> there's so much stuff that needs review, yes.

[12:55] <[Coke]> I wish we had a branch of RT we could have done this in. :)

[12:55] <jnthn> I suspect some merging will help

[12:55] <jnthn> e.g. there's a load of ':: NYI'

[12:56] <[Coke]> Aye. I just saw "int NYI", even.

[12:56] <jnthn> int is I :)

[12:56] <[Coke]> and it's clearly one ticket per fudge, so the total will probably drop by a hundred or so just there.

[12:57] * [Coke] creates an RT view that shows just tickets opened by our new ticketmaniac. :)

[12:58] *** rurban joined
[12:58] *** diana_olhovik_ left
[13:00] <dalek> roast: d5c53cf | jnthn++ | S32-hash/delete-adverb.t:

[13:00] <dalek> roast: Fix tests sensitive to hash ordering.

[13:00] <dalek> roast: review: https://github.com/perl6/roast/commit/d5c53cf61c

[13:03] *** alini joined
[13:03] *** RabidGravy joined
[13:04] <RabidGravy> afternoon

[13:04] <dalek> roast: c8953f2 | jnthn++ | S05-capture/caps.t:

[13:04] <dalek> roast: Fix another test sensitive to hash ordering.

[13:04] <dalek> roast: 

[13:04] <dalek> roast: Also these are fudged on JVM; maybe they will work now they aren't so

[13:04] <dalek> roast: sensitive?

[13:04] <dalek> roast: review: https://github.com/perl6/roast/commit/c8953f2008

[13:07] <lizmat> jnthn: confirmed that S05-capture/caps.t: can be unfudged for jvm

[13:07] <jnthn> lizmat: Cool; wanna do it, or shall I?

[13:07] <lizmat> I'll do it

[13:07] <jnthn> I *think* that we now have clean spectest with MoarVM HEAD

[13:07] <jnthn> As in, those two were all that needed fixing.

[13:08] <jnthn> I get one other fail but I think it's 'cus I don't have your lazy patch.

[13:08] <jnthn> yes, it was :)

[13:09] <dalek> roast: 4099cad | lizmat++ | S05-capture/caps.t:

[13:09] <dalek> roast: Unfudge passing tests on JVM

[13:09] <dalek> roast: 

[13:09] <dalek> roast: Turns out the testing was relying on hash key order, jnthn++ for noticing

[13:09] <dalek> roast: review: https://github.com/perl6/roast/commit/4099cad277

[13:09] <lizmat> yeah, tests for the will lazy patch are already in roast

[13:10] <jnthn> I wasn't expecting it to go into CORE.setting, but I guess we're a good way from a relesae if anybody comes up with a reason not to do it like that.

[13:11] <dalek> roast: a219848 | moritz++ | / (82 files):

[13:11] <dalek> roast: Remove # chars from fudge messages

[13:11] <dalek> roast: 

[13:11] <dalek> roast: they do not play too well with TODO messages in TAP

[13:11] <dalek> roast: review: https://github.com/perl6/roast/commit/a21984810b

[13:11] <lizmat> fwiw, I think it's a *very* usefult faeature

[13:11] <lizmat> moritz o/

[13:18] <[Coke]> gah.

[13:18] <[Coke]> moritz: I think the right answer there is to fix the tap output.

[13:19] <[Coke]> esp. given the effort I had put into having a standard way of writing RT #...

[13:19] *** araujo left
[13:20] <arnsholt> Doesn't TAP let you say \# for hashes in the output?

[13:21] *** Gothmog_ left
[13:22] *** Gothmog_ joined
[13:22] <moritz> arnsholt: no idea

[13:22] <moritz> [Coke]: that's unfortunate

[13:22] <moritz> [Coke]: how would you fix the TAP output?

[13:23] <[Coke]> Digging now. I swear I've already solved this for partcl.

[13:25] <[Coke]> yes, looks like \# is what I did there.

[13:25] <[Coke]> Trying to find a spec of some kind to back it up. I'm curious what was breaking with things the way they were, though.

[13:26] *** rurban left
[13:26] <[Coke]> we could s/#/SOMETHING ELSE/g, also

[13:27] <dalek> roast: 8b6048b | moritz++ | / (82 files):

[13:27] <dalek> roast: Revert "Remove # chars from fudge messages"

[13:27] <dalek> roast: 

[13:27] <dalek> roast: This reverts commit a21984810bb4f073291818e6526d9d024c339b98.

[13:27] <dalek> roast: 

[13:27] <dalek> roast: I'll try to fix the todo and todo functions in rakudo's Test.pm

[13:27] <dalek> roast: instead.

[13:27] <dalek> roast: review: https://github.com/perl6/roast/commit/8b6048b455

[13:33] *** rurban joined
[13:33] *** rindolf joined
[13:34] *** tinyblak_ left
[13:34] *** nbdsp joined
[13:34] <[Tux]> What is a more perl6 way to write "for ($r.fields) -> $f { @!fields.push: $f; }"

[13:35] <[Tux]> $r.fields>> ...

[13:36] <lizmat> @!fields.push: @$r.fields

[13:36] <lizmat> ??

[13:37] <[Tux]> Brrr:

[13:37] <[Tux]> # expected: (Failure)

[13:37] <[Tux]> #      got: (Failure)

[13:38] <lizmat> .oO( not all Failures are alike :-)

[13:38] <[Tux]> Cannot understand @!fields in this context

[13:38] <[Tux]> on your suggestion

[13:39] *** kaare_ joined
[13:39] <lizmat> that's what you were pushing on in your example ?

[13:39] <[Tux]> https://gist.github.com/Tux/12387de2febd2eda1efc

[13:40] <[Tux]> the commented-out line works as expected

[13:40] *** mj41 joined
[13:41] <[Coke]> I'm trying to keep the giant list of new tickets managed so we can coordinate with the incoming pull request. Please ping me before closing/merging whatever those new tickets.

[13:42] <lizmat> [Tux]: perhaps a Slang::Tuxic artefact ?

[13:42] <[Tux]> ENOFROGGS

[13:43] *** hobbs left
[13:43] <lizmat> yeah, I noticed as well...  offline for ~ 3 days already  :-)

[13:45] *** hobbs joined
[13:45] <[Tux]> so, "is(something-returning-failure, Failure, "Fail");" won't fly, but neither does "like(failing-thing, Failure, "FAIL");"

[13:45] <[Tux]> what to use there?

[13:46] <moritz> isa_ok

[13:46] <[Tux]> \o/ :) thanks

[13:46] <moritz> m: sub f { fail 'foo' }; use Test; plan 1; isa_ok f(), Failure, 'stuff'

[13:46] <camelia> rakudo-moar c72d67: OUTPUT«1..1␤ok 1 - stuff␤»

[13:47] <moritz> or do a throws_ok { use fatal; your test here }, X::The::Exception::Type::You::Except

[13:47] <moritz> *Expect

[13:47] *** rurban left
[13:49] <[Coke]> m: my int $a = 2; use Test; isa-ok(2,int);

[13:49] <camelia> rakudo-moar c72d67: OUTPUT«not ok 1 - The object is-a 'int'␤␤# Failed test 'The object is-a 'int''␤# at /tmp/Ir5MYciBud line 1␤# Actual type: Int␤»

[13:50] <lizmat> yeah, known issue

[13:50] <[Coke]> is there an RT?

[13:50] <lizmat> natives int pretends to be an Int 

[13:50] <lizmat> not sure

[13:51] <[Coke]> ok. 124461 for now. let me know if you find another one, I'll merge it.

[13:52] <ab5tract_> [Tux]: does it work when you explicitly do @($r.fields)

[13:52] <moritz> m: sub f(Mu $a, Mu $b) { say $a.isa($b) }; f 1, int

[13:52] <camelia> rakudo-moar c72d67: OUTPUT«False␤»

[13:52] <lizmat> moritz: you mean throws_like ?

[13:52] <moritz> m: say 4.isa(int)

[13:52] <camelia> rakudo-moar c72d67: OUTPUT«False␤»

[13:52] <moritz> lizmat: erm, yes

[13:52] <moritz> m: say 4.^isa(int)

[13:52] <camelia> rakudo-moar c72d67: OUTPUT«0␤»

[13:52] <moritz> m: say 4 ~~ int

[13:52] <camelia> rakudo-moar c72d67: OUTPUT«False␤»

[13:52] <moritz> m: say nqp::istype(4, int)

[13:52] <camelia> rakudo-moar c72d67: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[13:52] <moritz> m: use nqp; say nqp::istype(4, int)

[13:53] <camelia> rakudo-moar c72d67: OUTPUT«0␤»

[13:53] <jnthn> isa-ok(2,int) won't ever work out

[13:53] <[Tux]> m: class C { method hash { { :A(1), :B(2) }}}; my $c = C.new;$c<A>.say

[13:53] <camelia> rakudo-moar c72d67: OUTPUT«postcircumfix:<{ }> not defined for type C␤  in block <unit> at /tmp/aVQDg9Dhni:1␤␤»

[13:53] <[Tux]> why?

[13:53] <jnthn> .isa is an object operation

[13:53] *** rurban joined
[13:53] <jnthn> And so by the time it sees the thing it's been boxed to an Int object

[13:54] <[Coke]> m: my num $a = 2; use Test; isa-ok(2,num);

[13:54] <camelia> rakudo-moar c72d67: OUTPUT«This type cannot unbox to a native number␤  in block <unit> at /tmp/skYIovXdgi:1␤␤»

[13:54] <[Tux]> ab5tract_, no, :(

[13:54] <[Coke]> would you say that's the same issue? 

[13:55] <jnthn> [Coke]: ok(2, num) ain't going to work either

[13:55] <[Coke]> jnthn: ah. Excellent. I can rewrite the test file to do>

[13:55] <jnthn> [Coke]: 2 isn't a Num though, so you can't assign it to a num native

[13:55] <moritz> [Coke]: no

[13:55] <moritz> [Coke]: that's correct, though the error message coudl be better

[13:55] <jnthn> m: my num $a = 2e0;

[13:55] <camelia> rakudo-moar c72d67: ( no output )

[13:55] <[Coke]> m: my int $a = 3; is($a.WHAT, int); use Test;

[13:55] <camelia> rakudo-moar c72d67: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/zDqr2pyog4 line 1␤# expected: (int)␤#      got: (Int)␤»

[13:55] *** vendethiel left
[13:56] <jnthn> .WHAT is *also* an object-y operation...

[13:56] <dalek> rakudo/nom: 6a20f05 | moritz++ | lib/Test.pm:

[13:56] <dalek> rakudo/nom: Test.pm: Escape # in todo() output

[13:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a20f0530e

[13:56] <[Coke]> m: my int $a = 3; say $a ~~int;

[13:56] <camelia> rakudo-moar c72d67: OUTPUT«False␤»

[13:56] <[Coke]> ok. How can we write the test? ;)

[13:57] <jnthn> What is the goal of the test?

[13:57] *** vendethiel joined
[13:58] *** tinyblak joined
[13:58] <[Tux]> I thought giving a class a hash method implicitly gave it postcircumfix:<{ }>

[13:58] <lizmat> no, you need to add AT-KEY and friends

[13:59] *** diana_olhovik_ joined
[13:59] <lizmat> m: class A { method AT-KEY($a) { say "foo for $a" } }; A.new<zip>

[13:59] <camelia> rakudo-moar c72d67: OUTPUT«foo for zip␤»

[13:59] <jnthn> [Coke]: If it's to check a variable declared is int is really native, you could try sticking a huge value (only storable as a big Int) into an int, and seeing it doesn't round-trip...

[14:00] <dalek> nqp: 8437c84 | jnthn++ | tools/build/MOAR_REVISION:

[14:00] <dalek> nqp: Get a MoarVM with hash size reduction, opts.

[14:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8437c847d0

[14:02] <dalek> rakudo/nom: 20e3646 | jnthn++ | tools/build/NQP_REVISION:

[14:02] <dalek> rakudo/nom: Get MoarVM with hash improvements.

[14:02] <dalek> rakudo/nom: 

[14:02] <dalek> rakudo/nom: Hashes on r-m now uses (on 64-bit platforms) 8 bytes less per hash,

[14:02] <dalek> rakudo/nom: plus 16 bytes less per hash entry.

[14:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/20e3646b1d

[14:03] *** mohij joined
[14:03] *** konsolebox left
[14:04] <dalek> rakudo/nom: 86b1b2b | lizmat++ | src/Perl6/Actions.nqp:

[14:04] <dalek> rakudo/nom: Make nqp::ops warning a bit more camelia friendly

[14:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/86b1b2b43a

[14:06] *** konsolebox joined
[14:08] *** rindolf left
[14:13] * jnthn away for a bit

[14:16] <lizmat> jnthn: spectest clean for me, not noticing any speadup just yet though

[14:17] <[Tux]> AAAAHRG! after these commits, no more panda. no more panda => no more Slang::Tucic, not Slang::Tuxic no development :(

[14:17] <[Tux]> $ panda install Slang::Tuxic

[14:17] <[Tux]> ===SORRY!===

[14:17] <[Tux]> No candidate found for 'panda'.

[14:18] *** rindolf joined
[14:21] *** rurban left
[14:22] <lizmat> hmmm... I'm getting Missing or wrong version of dependency 'src/gen/m-CORE.setting' (from 'lib/File/Find.pm') on bootstrap

[14:22] <lizmat> even on a fresh panda clone

[14:23] <lizmat> [Tux] so the rebootstrap.pl worked for you?

[14:23] *** nbdsp left
[14:24] *** ir2ivps4 joined
[14:25] *** pmqs joined
[14:32] <[Tux]> no idea. I typed "make" :)

[14:33] *** rurban joined
[14:41] *** laouji left
[14:45] *** airdisa left
[14:45] *** cygx left
[14:49] *** airdisa joined
[14:52] *** airdisa left
[14:52] *** cognominal left
[14:52] *** diana_olhovik_ left
[15:00] <[Tux]> t/common.t ..... ok

[15:00] <[Tux]> # Failed test 'dependencies 1'

[15:00] <[Tux]> # at t/ecosystem.t line 32

[15:00] <[Tux]> # expected: 'some'

[15:00] <[Tux]> #      got: 'else'

[15:01] *** rurban left
[15:01] *** BenGoldberg joined
[15:01] *** rurban joined
[15:02] *** BenGoldberg left
[15:04] *** BenGoldberg joined
[15:07] *** domidumont left
[15:07] *** konsolebox left
[15:12] <lizmat> down to 2 failing spectest files for my new lazy @*INC work  *phew*

[15:21] <[Tux]> without panda I am lost :(

[15:24] *** skids joined
[15:30] <jepeway> m: use Test; my Int $i = 0; isa-ok $i, Str, 'crazy, magic stringification works in my slang'; # not that I can author such a slang, mind you

[15:30] <camelia> rakudo-moar 86b1b2: OUTPUT«not ok 1 - crazy, magic stringification works in my slang␤␤# Failed test 'crazy, magic stringification works in my slang'␤# at /tmp/Ri1kRfnK9S line 1␤# Actual type: Int␤»

[15:31] <jepeway> (& greets, #perl6, btb)

[15:31] * nine waves from his new home

[15:31] <yoleaux> 1 May 2015 10:46Z <lizmat> nine: would it be possible for me to get an Inline::Perl5 commit bit ?

[15:31] * lizmat waves back

[15:31] <nine> lizmat: if you tell me how I can give you one

[15:32] <lizmat> I have *no* idea  :-)

[15:32] <jepeway> o/

[15:32] <lizmat> moritz might be able to explain?

[15:32] <nine> lizmat: you're lizmat on github?

[15:32] <nine> lizmat: I think I found it

[15:32] <jepeway> I'm a tad disappointed that diag output doesn't mention the expected type.

[15:33] <lizmat> yeah, that's me  :-)

[15:33] <nine> lizmat: then you have one now :)

[15:33] <lizmat> cool lemme check

[15:33] <skids> (backlogging) So... does masak still hold the record for opening RT tickets? :-)

[15:33] <jepeway> Seems like it should, whenever the default is overridden.

[15:33] <dalek> Inline-Perl5: a52fd1b | lizmat++ | lib/Inline/Perl5.pm6:

[15:33] <dalek> Inline-Perl5: Workaround for "is nodal" breakage, quester++

[15:33] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/a52fd1b464

[15:34] <lizmat> now we only need panda to work again

[15:35] <nine> I think I won't backlog this time. Was offline for almost three days. I hope there'll be a weekly tomorrow :)

[15:36] <jepeway> 'cause the default method mentions the expected type, y'see.

[15:36] <lizmat> nine: I hope so too

[15:36] <jepeway> s/method/message/

[15:37] <lizmat> nine: we just got a new and shiny Moar with many optimisations

[15:37] <lizmat> something you probably want to check Inliine::Perl5 against  :-)

[15:40] <nine> lizmat: on it :)

[15:42] *** jack_rabbit joined
[15:43] *** zakharyas joined
[15:47] *** hobbs left
[15:47] *** fhelmberger joined
[15:47] *** rurban left
[15:50] <timotimo> could panda rely on hash ordering in that test? 

[15:50] <timotimo> welcome back, nine 

[15:51] <timotimo> glad to hear your move has succeeded 

[15:51] *** hobbs joined
[15:52] *** fhelmberger left
[16:01] *** diana_olhovik_ joined
[16:05] *** jack_rabbit left
[16:06] <[Coke]> m: my bit $a;

[16:06] <camelia> rakudo-moar 86b1b2: OUTPUT«===SORRY!===␤Invalid int size for local/lexical␤»

[16:07] *** jack_rabbit joined
[16:09] *** rurban joined
[16:09] <[Coke]> is lowercase junction ever going to be a thing?

[16:09] <lizmat> [Coke] my bit $a is really NYI afaik

[16:10] <[Coke]> yah, just a weird error messages. leaving that ticket alone.

[16:11] <lizmat> afk for some dinner&

[16:14] <[Coke]> m: my int $a; $a = 2**100;

[16:14] <camelia> rakudo-moar 86b1b2: ( no output )

[16:14] <[Coke]> in the repl that dies with qast not found.

[16:14] <[Coke]> m: my int $a; $a = 2**100.say;

[16:14] <camelia> rakudo-moar 86b1b2: OUTPUT«100␤»

[16:14] <[Coke]> m: my int $a; $a = 2**100; $a.say;

[16:14] <camelia> rakudo-moar 86b1b2: OUTPUT«0␤»

[16:15] <[Coke]> is that the right overflow check? that it's still 0?

[16:15] <TimToady> .oO(native junctions are, like, diodes and transistors, right?)

[16:15] <moritz> m: my int $a; $a = 1 + 2**100; $a.say

[16:15] <camelia> rakudo-moar 86b1b2: OUTPUT«1␤»

[16:16] <moritz> [Coke]: it's simply that powers of two tend to overflow to 0

[16:16] <[Coke]> TimToady: yah, it didn't make any sense to me either; but there's a test for it.

[16:16] <[Coke]> moritz: well, it's a more valid test than what we have, I guess.

[16:23] *** pmqs left
[16:23] <jnthn> I think the lowercase junction thingy can go away.

[16:24] <jnthn> As for bit: I added it recently-ish, initially for my bit @vector

[16:24] <jnthn> (Which ain't done yet, but at least in progress...)

[16:24] <TimToady> "will lazy" ain't Engrish

[16:25] <jnthn> hah, I knew you'd have some comment :P

[16:25] <jnthn> "will lazily" maybe :P

[16:26] *** baest_ is now known as baest

[16:26] <TimToady> most of the other 'wills' are designed to be verbs, but what's a good verb for doing something later?

[16:27] <sjn> postpone?

[16:27] <geekosaur> defer?

[16:27] <geekosaur> ...suppose not. hm

[16:27] <geekosaur> procrastinate :p

[16:28] <TimToady> otoh, the "later" is already implicit in 'will'

[16:28] <TimToady> so 'will init' or so isn't so bad

[16:28] <jnthn> 'will be' :)

[16:28] <TimToady> * will be, will be...

[16:29] <TimToady> will get, will start

[16:29] <TimToady> don't want init

[16:29] <sjn> will do :-P

[16:29] <TimToady> start is available again these days, since START went away

[16:31] <nwc10> were weeklies running at the time START went away - I forget why START was able to go away - is there a summary online I can read?

[16:31] <nwc10> (I realise that the direct answer to "why did START go away?" might be quite a few lines of repeated typing)

[16:32] <jnthn> It didn't really fit the phaser "happens at a weird time" thing, since it happened at that point in the code, just once. So we called it "once" instead.

[16:33] <nwc10> aha.

[16:33] <nwc10> that answer was shorter than I expected.

[16:33] <nwc10> so, a "once" phaser fires once, at the first time execution reaches that point?

[16:36] <jnthn> Well, it's not really a phaser, just sugar for something involving a state variable

[16:36] <masak> good evening, #perl6

[16:36] <vendethiel> \o, masak!

[16:36] <jnthn> a wild masak appears!

[16:37] * masak <-- actually quite tame

[16:38] <vendethiel> .oO( that's what all the wild ones say! )

[16:38] <masak> well, at least the articulate ones.

[16:39] <masak> tadzik: so excited to see what you'll do with https://github.com/tadzik/synopsebot/pull/6 ! :D

[16:40] * masak backlogs, wildly

[16:42] <masak> I just want to say that it's heartening to see so much activity on the channel lately.

[16:42] <masak> it feels to me that with all the work being applied on rakudo itself, on the test suites, and on the docs, we might actually end up somewhere nice for Christmas.

[16:42] <masak> <3

[16:43] <vendethiel> it's not friday, but /hug to everyone indeed :-)

[16:43] <masak> m: say Date.new # and it's *this* Christmas! :D

[16:43] <camelia> rakudo-moar 86b1b2: OUTPUT«2015-12-24␤»

[16:43] *** risou is now known as risou_awy

[16:43] *** risou_awy is now known as risou

[16:44] *** risou is now known as risou_awy

[16:44] *** risou_awy is now known as risou

[16:46] <arnsholt> masak: Regarding PARSING_IGNORED in your patch up there, wouldn't something like "regex piece { <info> | . }" do the trick?

[16:47] <masak> hmm :)

[16:47] * masak tries

[16:47] <arnsholt> I think LTM should DTRT in that case

[16:47] <masak> let's say that works -- what's the easiest way to "amend" a pull request?

[16:48] <vendethiel> git push :P

[16:48] <RabidGravy> :)

[16:48] <masak> ah -- to the source branch of the PR?

[16:48] <moritz> yes

[16:48] <vendethiel> yes

[16:48] <moritz> you can even force-push there

[16:48] <masak> and does Github DTRT with `git push -f`?

[16:49] <masak> :)

[16:49] <vendethiel> yes

[16:49] <masak> goodie.

[16:49] <masak> vendethiel++ moritz++

[16:49] <moritz> masak: it even shows comments on replaced patches as such

[16:50] <masak> it works \o/

[16:50] * masak pushes --force

[16:50] <timotimo> jnthn: do we already have an idea why Proc::Async is racy? is that a mvm-level problem or an nqp/rakudo-level one? if you can point me at something, i could probably try to figure it out

[16:54] <TimToady> https://gist.github.com/anonymous/16e85e7c3e1b95ce1577 is a test for Proc::Async written by a craigslist cohort

[16:55] <TimToady> discusson at http://irclog.perlgeek.de/perl6/2015-03-31#i_10370872

[16:55] <masak> tadzik: new and improved! https://github.com/tadzik/synopsebot/pull/6 :)

[16:56] <masak> (pro tip: a `git push --force` *will* update the pull request. it does not update the OP comment, so if you're expecting that to change, you will be momentarily confused, at least until you start comparing SHA-1s.)

[16:56] <timotimo> i'll have a look with that valgrind tool that checks for race conditions and stuff

[16:56] <jnthn> timotimo: I suspect there's problems at a couple of levels; I was pondering spending some time tomorrow on that.

[16:56] <timotimo> helgrind*

[16:57] <timotimo> i bet you wouldn't mind if i fixed it before you :P

[16:57] <jnthn> timotimo: Helgrind is rather noisy :)

[16:57] <jnthn> True, but I think it's "them" not "it"

[16:57] <timotimo> but if it's hard, i may not want to spend any time on it :P

[16:57] <timotimo> oh my

[16:57] <jnthn> And at least some of it is our code-gen, I fear.

[16:57] <timotimo> oh?

[16:57] <jnthn> For example, our phaser handling isn't thread safe.

[16:57] <timotimo> that surprises me a bit

[16:57] <timotimo> oh, this is about helgrind noise, not proc::async problems?

[16:57] <jnthn> In fact, it's not really recursion safe.

[16:59] <jnthn> timotimo: Until a few days ago we had a bug related to the way we compile blocks inside thunks, which also could have caused thready issues.

[16:59] <timotimo> mhm

[16:59] <timotimo> well, i'll have a look

[16:59] <jnthn> *nod*

[16:59] <jnthn> There's two tools in valgrind; helgrind and drd

[16:59] <timotimo> i may want to try "porting" Proc::Async to nqp so that i'll get much less output?

[17:00] <jnthn> Not sure how much that'll help

[17:00] <jnthn> I mean, it's not until you kick off a process or two that threads get created

[17:00] * masak .oO( the brave warriors go to valgrind; the craven ones get sent to helgrind )

[17:00] <timotimo> i suppose that's fair, but in nqp land the code gen is much simpler and there's much less stuff actually running all in all

[17:01] <jnthn> .oO( callgrind me maybe )

[17:02] * TimToady wonders if 'nodal' needs to be split into array nodal vs hash nodal, such that AT-POS gets one, and AT-KEY gets the other

[17:02] <TimToady> shower &

[17:03] <masak> jnthn: I challenge you to use that as aslide title at some point :P

[17:05] <nine> This is the reason for panda's test failure:

[17:05] <nine> m: my @a = 1, 2, 3; my @b; say @a; say [(@a (|) @b).list.flat]

[17:05] <camelia> rakudo-moar 86b1b2: OUTPUT«1 2 3␤3 1 2␤»

[17:06] <nine> https://github.com/tadzik/panda/blob/master/lib/Panda/Ecosystem.pm#L50

[17:07] <jnthn> Sets are unordered, so relying on ordering would be a badass umption.

[17:07] <jnthn> m: my @a = 1, 2, 3; my @b; say @a; say (@a (|) @b).WHAT

[17:07] <camelia> rakudo-moar 86b1b2: OUTPUT«1 2 3␤(Set)␤»

[17:07] <timotimo> food time first :)

[17:07] <jnthn> However, our hashes until recently maintained insertion order.

[17:08] <jnthn> But only on Moar

[17:08] <timotimo> is someone looking at the panda problem already, btw?

[17:08] <jnthn> So this may also explain the panda bustage on JVM too...

[17:08] <jnthn> Which has never had the "oops we keep order" issue

[17:09] *** mj41 left
[17:11] <masak> TimToady: my immediate reaction is -- if there's no overwhelming reason to distinguish those, then the API will be a lot simpler with them undistinguished.

[17:11] <jnthn> nine: Do you know if it's a bad test, or wrong code?

[17:11] <nine> timotimo: https://github.com/tadzik/panda/blob/master/lib/Panda/Ecosystem.pm#L50

[17:11] <nine> jnthn: unfortunately, I don't know if the order of dependencies is meaningful

[17:11] <masak> not dependencies of a given module, no.

[17:12] <masak> at least not as far as I know.

[17:12] <jnthn> yeah

[17:12] <jnthn> Taht'd be my guess too but I don't know for sure

[17:15] *** liztormato joined
[17:15] <jnthn> Hm, on Windows testing File::Find fails, alas

[17:16] <liztormato> has $.a will do { ... }.  # like it for the similarity with do { ... }

[17:18] <masak> liztormato: hm, what's the semantics of that?

[17:18] <masak> liztormato: ISTR `will do` is the way to attach a routine body to a routine, or sump'n.

[17:19] <liztormato> Alternate name for "will lazy"

[17:22] * masak continues backlogging, confused

[17:23] <jnthn> masak: See my gist from earlier today where I sketched a "will lazy" trait in response to a question on channel

[17:23] *** liztormato left
[17:23] *** domidumont joined
[17:24] *** liztormato joined
[17:24] <masak> nodnod

[17:25] <masak> it will all make sense at the end of the rainb^Wbacklog

[17:26] <masak> liztormato: does the fix at http://irclog.perlgeek.de/perl6/2015-05-02#i_10537026 suggest that we have insufficient spectest coverage for the List.roll(Inf) case?

[17:26] <liztormato> Yes

[17:26] * masak .oO( make sure this call does not run forever )

[17:27] <jnthn> .oO( They see me .roll-in', they failin' )

[17:32] <masak> [backlog] should lazy default attributes be part of http://doc.perl6.org/language/classtut ? did someone file an issue about this?

[17:32] <masak> s/default attributes/attribute defaults/

[17:32] <jnthn> masak: Once we decide what we're callin' the trait

[17:32] <TimToady> I guess they can always use .duckmap if they wish to distinguish .[] from .{}

[17:33] <masak> I think it's orthogonal to that, no? lazy attribute defaults already exist in Perl 6 and work in Rakudo.

[17:33] <masak> m: class C { has $.x = "OH HAI" }; say C.new(:x(42)).x; say C.new.x

[17:33] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤OH HAI␤»

[17:33] <masak> jnthn: that ^

[17:33] <jnthn> Oh...

[17:34] <liztormato> Thats at object build time

[17:35] *** virtualsue joined
[17:35] <TimToady> anyway, if we're going to encourage people to write 'method AT-KEY' and such, they also need 'is nodal'

[17:36] * TimToady needs to commute to the city of Lost Wages...

[17:36] <TimToady> afk till evening &

[17:37] <masak> liztormato: yes. rjbs was asking about that, and didn't find the answer in http://doc.perl6.org/language/classtut

[17:37] * masak submits an issue

[17:38] <liztormato> To be clear: has $.a = 42 is not lazy but run at build time

[17:38] <masak> oh! yes, you are right. those two are not the same.

[17:39] <masak> which totally motivates having a way to do the lazy thing, too.

[17:39] <masak> tbh, I'd be fine with `has $.x is lazy = "OH HAI";`

[17:39] <liztormato> Otoh, why isn't lazy the default?

[17:40] <masak> because that'd be surprising.

[17:42] *** virtualsue left
[17:45] <masak> oh, now I hit the point http://irclog.perlgeek.de/perl6/2015-05-02#i_10537636 where jnthn++ suggest doing `is lazy` as a module.

[17:45] <masak> +1

[17:45] <masak> if people want it badly enough, that's the way to prototype it and then eventually core it :)

[17:45] *** virtualsue joined
[17:46] <masak> [backlog] by the way, speaking of http://irclog.perlgeek.de/perl6/2015-05-02#i_10537654 -- is it reasonable to expect `has $.x = !!!` to actually end up emitting a "nice" error message saying something about $.x not being supplied?

[17:47] <masak> because that... would be... *swoon*

[17:47] <liztormato> Let's prototype it in a module ;-)

[17:48] *** diana_olhovik_ left
[17:49] <jnthn> Probably do-able with a little cunning ;)

[17:49] <jnthn> dinner &

[17:51] <liztormato> masak: what made me put will lazy in the core, is that it is apperemtly a standard feature of Moose

[17:51] <RabidGravy> it is

[17:52] <mst> it isn't

[17:52] <mst> Moose has lazy_build, which is not simple lazy

[17:52] <mst> well, 'lazy => 1' exists

[17:52] <mst> which I guess is equivalent to a trait

[17:52] <mst> the Moo/MooseX::AttributeShortcuts version is much nicer

[17:52] <RabidGravy> didn't lazy_build go away?

[17:52] <mst> has thing => (is => 'lazy', builder => sub { ... });

[17:53] <mst> no, it's still there, just not really recommended

[17:53] <mst> largely because I designed it for a very specific case in a web metaframework and then somebody added it to Moose core without thinking about it

[17:53] <mst> hence when I did Moo, I designed a sensible version and supported that

[17:56] <mst> liztormato: I would prototype outside but want it to be cored later

[17:56] <mst> pretty much all of my attributes these days are either ro+required or lazy w/a builder method

[17:57] <mst> because, well, mutable state is the enemy :)

[17:57] <masak> liztormato: putting `will lazy` in core might be a nice thing -- but it doesn't stand out as obviously so.

[17:57] <masak> liztormato: I would be more convinced if there was a known second use case besides lazy attributes :)

[17:57] *** Isp-sec joined
[17:58] <timotimo> hey, hold on, this only just started existing today! ;)

[17:58] <timotimo> oh

[17:58] <timotimo> (backlogged)

[17:59] <liztormato> Can't think about another use case just yet

[18:00] <liztormato> But the current implementation uses rakudo internals specific code, so it's tied pretty tightly to the core

[18:01] <liztormato> Specifically Attribute.compose

[18:02] *** vendethiel left
[18:04] <liztormato> Cycling again&

[18:04] *** liztormato left
[18:04] *** vendethiel joined
[18:08] *** diana_olhovik_ joined
[18:09] <RabidGravy> lazy might concievably enable initializing with the result of a method (i.e. no "may not be used on partially constructed objects" if tryin that now)

[18:12] <RabidGravy> (of course you can do that right now with a similarly named method as the attribute)

[18:14] *** mohij left
[18:18] *** iv left
[18:19] <moritz> since the RHS of an attribute initializer is already a thunk (code object), it would make sense to use it as initializer for lazy attributes too

[18:29] *** zakharyas left
[18:29] <mst> one thing that Moo does that's a very useful affordance is that

[18:29] <mst> has foo => (is => 'lazy', builder => sub { ... });

[18:30] <mst> installs that sub as _build_foo and then calls it by name

[18:30] <mst> so you can method modifier or replace it in subclasses, roles etc.

[18:38] *** alini left
[18:39] <RabidGravy> which is nice

[18:41] <RabidGravy> always a pain having to manually install the builders if you are creating them in e.g. an attribute trait

[18:41] *** aindilis left
[18:46] *** aindilis joined
[18:48] <masak> RabidGravy: sounds a lot like the `builder` thing mst++ just metnioned.

[18:48] <RabidGravy> yes

[18:49] <masak> RabidGravy: with the little I've used Moose, I feel there's good use for both `lazy` and `builder`.

[18:49] *** spider-mario left
[18:49] <RabidGravy> but if you had lazy you could do:

[18:50] <RabidGravy> $.a is lazy = $.get_a;

[18:50] <RabidGravy> for instance

[18:50] <RabidGravy> or is it

[18:51] <RabidGravy> has $.a is lazy with bulder { ..... }

[18:52] *** telex left
[18:54] *** telex joined
[18:54] <RabidGravy> which would be quite good fun

[18:54] <jdv79> p6 is now taking from Moose?  dizzying.

[18:55] <jdv79> seems kind of warped and/or incestuous

[18:56] <RabidGravy> it's more that it's quite a common pattern and Moose has a good extent example

[18:56] <RabidGravy> extant rather

[18:57] *** mohij joined
[18:58] <jdv79> i'm all for it except i find the p6 stuff tends to be more well thought out than the likes of Moose in terms of holistics.

[18:59] <masak> that's what I'm after here too.

[18:59] <masak> TimToady++ has said that a feature is seldom there for just one reason.

[18:59] * jdv79 is a heavy Moose user - disclaimer

[19:00] *** vendethiel- joined
[19:01] *** vendethiel left
[19:03] <masak> TimToady: dangit, now I see anapests everywhere! :P http://www.salon.com/2015/04/30/i_secretly_lived_in_my_office_for_500_days/

[19:10] *** rindolf left
[19:11] *** spider-mario joined
[19:14] *** FROGGS[mobile] joined
[19:14] <FROGGS[mobile]> Hi #perl6

[19:15] <lizmat> FROGGS[mobile] o/

[19:15] <FROGGS[mobile]> lizmat: I'm fine :o)

[19:15] <masak> \o

[19:15] <lizmat> good to hear!

[19:17] <FROGGS[mobile]> just had to build a fence and doors for a friend, and today was birthday party for $son

[19:18] <FROGGS[mobile]> and now every bit of my body is acking, and tomorrow is train ride to the GPW in Dresden

[19:18] <lizmat> ah, they come in groups, those birthdays  :-)

[19:19] <lizmat> won't be at the GPW  :-(

[19:19] <FROGGS[mobile]> no, it is a belated Party :o)

[19:19] <FROGGS[mobile]> yeah :/

[19:19] <lizmat> are you aware at least some train drivers in Germany will be on strike soon ?

[19:19] <FROGGS[mobile]> it will be just lichtkind and me afaik

[19:19] *** zeleiadi joined
[19:20] <FROGGS[mobile]> yes, from Tue to Mon

[19:20] <lizmat> hence your travel tomorrow  :-)

[19:20] <FROGGS[mobile]> and we attempt to get back on Sat ó.ò

[19:20] * nwc10 is not aware of this.

[19:20] <nwc10> but is now

[19:20] <nwc10> bother?

[19:21] <FROGGS[mobile]> there will be some trains, so I dont care much

[19:22] <FROGGS[mobile]> there is always some sort of SCHIENENERSATZVERKEHRRR!!!

[19:22] <FROGGS[mobile]> :o)

[19:22] <rurban> there's a big car from frankfurt

[19:22] *** zakharyas joined
[19:23] <rurban> do you need to come from Berlin?

[19:24] <rurban> What I heard they'll start their strike on Tuesday - Wednesday

[19:24] <masak> 1.3k tickets in RT!? http://irclog.perlgeek.de/perl6/2015-05-03#i_10538762 -- wow, that snuck up on me as well!

[19:24] <masak> but having a lot of tickets filed on you just means that you're popular.

[19:24] <masak> (and buggy) :P

[19:26] <jnthn> .tell lizmat Attribute isn't Rakudo-specific; think S12 mentions it

[19:26] <yoleaux> jnthn: I'll pass your message to lizmat.

[19:26] <masak> was gonna say.

[19:26] <lizmat> jnthn: true, but Attribute.compose *is*, afaik

[19:26] <yoleaux> 19:26Z <jnthn> lizmat: Attribute isn't Rakudo-specific; think S12 mentions it

[19:26] <masak> that's probably more an oversight than anything...

[19:26] <lizmat> at least until we have a COMPOSE phaser

[19:27] <masak> anyway, what feels weird to me is coupling `will do` (or whatever it ends up being called) to attributes only.

[19:27] <masak> that feels somehow underpowered.

[19:28] <lizmat> well, others are for variables only: will leave, will end, etc

[19:28] <jnthn> lizmat: It falls into the same category of much of the rest of the MOP, I think.

[19:28] <masak> oh, there actually are a lot of new RT tickets. that explains it.

[19:29] <FROGGS[mobile]> rurban: I have three kids with me, a car is no option I fear

[19:29] <nwc10> FROGGS[mobile]: it might be that I simply can't make it. We're supposed to be on the sleeper overnight on Tuesday. I don't think we have any viable way to make a sane alternative plan.

[19:29] <FROGGS[mobile]> yeah :o(

[19:29] <masak> lizmat: I didn't get the impression the others are for variables only.

[19:30] <lizmat> I'm not sure what "will leave" means for an attribute

[19:30] <masak> lizmat: I've seen no example of it, but I would expect being able to put `will end` on a routine, for example.

[19:30] <lizmat> m: { my $a will leave say "bye" = 42; say $a }

[19:30] <camelia> rakudo-moar 86b1b2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0od20F5qIb␤Missing block␤at /tmp/0od20F5qIb:1␤------> 3{ my $a will leave7⏏5 say "bye" = 42; say $a }␤    expecting any of:␤        parameterized block␤»

[19:30] <lizmat> m: { my $a will leave { say "bye" } = 42; say $a }

[19:30] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤bye␤»

[19:31] <lizmat> m: { my $a will end { say "bye" } = 42; say $a }

[19:31] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤»

[19:31] <rurban> FROGGS[mobile]: 3 kids? Wife also? there are 2 more wifes there.

[19:31] <lizmat> hmmm... guess something's not bothering exeucting the END block?

[19:32] <masak> that looks reportable.

[19:32] <FROGGS[mobile]> rurban: aye, and nice :o)

[19:32] <masak> anyway, I look forward to `is lazy` provided by a module :)

[19:33] <rurban> We have a very nice rooftop terrace in the venue with cafe and perfect overview. kids can stay there

[19:33] *** domidumont left
[19:34] <FROGGS[mobile]> cool... and they want to visit the zoo I think 

[19:34] *** tinyblak left
[19:34] <FROGGS[mobile]> but we don't have a concrete Plan yet

[19:35] * raydiak tried a 'is lazy' module w/the metamodel, but you can't get at the default closure w/out nqp; also tried a version that used a Proxy, but ran into some other problem

[19:36] <lizmat> masak: don't bother, it's NYI

[19:36] <raydiak> .tell adu https://github.com/andydude/p6-c-parser/issues/4

[19:36] <yoleaux> raydiak: I'll pass your message to adu.

[19:36] <lizmat> "for some reason exceptions are caught and not rethrown" as a comment in the code

[19:36] <jnthn> raydiak: There's a .build method on Attribute

[19:37] <raydiak> jnthn: part of the issue was it's a BOOTSTRAPATTR or whatever it's called

[19:38] <lizmat> jnthn: regarding END/INIT phasers: to what Block should I attach those ?

[19:38] <jnthn> lizmat: They don't go on blocks...

[19:38] <lizmat> can I get from a PseudoStash to the associated Block ?

[19:38] <lizmat> ah that would explain

[19:38] <jnthn> I think there's an add_phaser method in World iirc

[19:38] * lizmat looks deeper

[19:39] <lizmat> ah, then the problem is: how to get at World in the trait_mod

[19:39] <jnthn> raydiak: Those only show up in a handful of internal things, not in user code...

[19:39] <jnthn> lizmat: $*W :P

[19:39] <lizmat> aha... hmm...

[19:40] <raydiak> jnthn: not sure what I was doing, but it was in my own class; playing with it again now using your .build hint, I'll see how far I get

[19:41] <FROGGS[mobile]> lizmat: you can access $*W because traits are called from the actions directly, and dynamic variables "leak"

[19:41] <lizmat> aha, that make sense  :-)

[19:42] <jnthn> .oO( it's a leakture, not a bug... :) )

[19:42] <RabidGravy> :)

[19:43] <FROGGS[mobile]> that's also why Slang::Tuxic can just access %*LANG in EXPORT

[19:45] * lizmat looks deeper$ 6 ' { my $a will end { say "bye" } = 42 }'

[19:45] <lizmat> ===SORRY!===

[19:45] <lizmat> Object of type Block in QAST::WVal, but not in SC

[19:45] <lizmat> jnthn: ^^

[19:45] <lizmat> suggestions ?

[19:45] <lizmat> code in trait: $*W.add_phaser($v.slash, 'END', $block)

[19:46] <jnthn> $*W.add_object($block); before it, mebbe

[19:46] <FROGGS[mobile]> $*W.add_object($bl...

[19:46] <lizmat> testing

[19:46] <FROGGS[mobile]> phone typing ducks

[19:47] <lizmat> suckd you mean :-)

[19:47] <FROGGS[mobile]> yeah, that :D

[19:48] *** zeleiadi left
[19:48] *** spider-mario left
[19:49] <rurban> Wasn't there a plan to support unicode ops also? like → ⇒ ⇔ ≠ ≤ ≥ ÷ I added this now to our perl5: https://github.com/rurban/perl/commits/unicode-parse

[19:52] <sjn> rurban: you can already make your own unicode operators in Perl 6

[19:52] *** spider-mario joined
[19:52] <raydiak> m: sub trait_mod:<is> (Attribute $a, :$lazy!) { say $a.build.perl }; class Foo { has $.foo is lazy = rand } # is this because the trait is parsed before the default?

[19:52] <camelia> rakudo-moar 86b1b2: OUTPUT«Mu␤»

[19:53] <lizmat> sjn: we have them for set operations, why not for "normal" math ops as well ?

[19:53] <sjn> sure :)

[19:53] <jnthn> lizmat: It's just a module away ;P

[19:53] <jnthn> raydiak: Yeah, you'd need to do something at compose time, as in the lazy thing I wrote

[19:54] <lizmat> by that logic, we should get rod of unicode set operators and put them in the ecosystem

[19:54] <lizmat> *rid

[19:54] <lizmat> sooner rather than later

[19:54] <DrForr> Or resort to trigraphs :)

[19:55] <raydiak> jnthn: thanks, will read, haven't backlogged...last tried this a week or two ago

[19:55] *** mohij left
[19:55] <FROGGS[mobile]> gnight

[19:55] *** FROGGS[mobile] left
[19:56] *** mohij joined
[19:57] *** yqt joined
[20:00] * raydiak backlogs, sees people working on it, goes and does something else :)

[20:01] *** espadrine left
[20:07] *** mohij left
[20:09] *** Rounin left
[20:10] <dalek> rakudo/nom: cfdf0a3 | lizmat++ | src/core/Variable.pm:

[20:10] <dalek> rakudo/nom: my $a will end { say "byebye" } now works

[20:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cfdf0a3cbf

[20:11] <timotimo> is that for when a variable leaves its scope?

[20:12] <lizmat> no, that's "will leave"

[20:12] <lizmat> this is when we end the process

[20:12] <vendethiel-> lizmat++

[20:12] <lizmat> m: { my $a will end { say "bye" } = 42; say $a } END say "byebye"

[20:12] <camelia> rakudo-moar 86b1b2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/W246ywT3ty␤Strange text after block (missing semicolon or comma?)␤at /tmp/W246ywT3ty:1␤------> 3$a will end { say "bye" } = 42; say $a }7⏏5 END say "byebye"␤    expecting any of:␤        infix…»

[20:12] <lizmat> m: { my $a will end { say "bye" } = 42; say $a }; END say "byebye"

[20:12] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤byebye␤»

[20:13] <lizmat> $ 6 '{ my $a will end { say "bye" } = 42; say $a }; END say "byebye"'

[20:13] <lizmat> 42

[20:13] <lizmat> byebye

[20:13] <lizmat> bye

[20:13] <vendethiel-> Since we lost the "nested phaser" a few days/weeks ago, this "will" thing will most definitely save us :-)

[20:13] <timotimo> hum?

[20:14] <vendethiel-> mean ENTER { my Lock $l .= new; LEAVE { $l.free } }; <- this used to work but doesn't anymore, right?

[20:15] <lizmat> there is no Lock.free ?

[20:15] <vendethiel-> that's just an exemple of nested phaser.

[20:16] <vendethiel-> (about lexical scope etc)

[20:17] <lizmat> ah, but you don't have to have a scope on a phaser

[20:17] <lizmat> m: { ENTER my $a = 42; LEAVE say $a }

[20:17] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤»

[20:18] <vendethiel-> yeah, but in this case, it might be "cleaner" to leave the Lock untouchable from outside the phaser :-)

[20:18] <lizmat> m: { ENTER { my $a = 42; LEAVE say $a } }

[20:18] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤»

[20:18] <lizmat> m: { ENTER { my $a = 42; LEAVE say $a }; LEAVE say "bye" }

[20:18] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤bye␤»

[20:18] <lizmat> not the same thing

[20:19] <vendethiel-> great. then I'm not sure what I was confusing that with, or which part of the (I think) p6weekly I misread..

[20:20] *** diana_olhovik_ left
[20:20] <timotimo> if it's from the weekly, it's more likely i explained something poorly than you reading it wrong ;)

[20:21] <masak> vendethiel-: I submitted the LEAVE-inside-ENTER thing not working as an RT ticket, but jnthn rejected it on arguably good grounds.

[20:21] <masak> vendethiel-: (thrust of the argument was "it's not spec")

[20:21] <vendethiel-> aaah, that's probably that then, masak. timotimo++: nope, don't believe that. get some karma instead

[20:21] <masak> I could find you the RT ticket if you're interested.

[20:22] <vendethiel-> if it's not too much time, I am indeed

[20:22] <ugexe> m: role r1 { has $!rv; submethod BUILD(:$!rv = 1) { say $!rv }; }; role r2 does r1 { has $!rv2; submethod BUILD(:$!rv2 = 2) { say $!rv2 }; }; my $x = "xx"; $x does r2; # is there another way to access self at build time?

[20:22] <camelia> rakudo-moar 86b1b2: OUTPUT«Package 'r2' already has a Submethod 'BUILD' (did you mean to declare a multi-method?)␤  in any add_method at src/gen/m-Metamodel.nqp:434␤  in any apply at src/gen/m-Metamodel.nqp:1729␤  in any compose at src/gen/m-Metamodel.nqp:1882␤  in any speci…»

[20:23] <skids> ugexe: by abusing attribute default values.

[20:23] <dalek> rakudo/nom: 13dc82f | lizmat++ | src/core/Variable.pm:

[20:23] <dalek> rakudo/nom: Some code esthetics

[20:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/13dc82f0bd

[20:23] <vendethiel-> haha, I love how "will begin" is implemented :-)

[20:23] *** spider-mario left
[20:23] *** darutoko left
[20:24] <masak> vendethiel-: https://rt.perl.org/Ticket/Display.html?id=123894

[20:24] <vendethiel-> thanks masak

[20:24] <masak> (I remembered slightly wrongly, because it wasn't those two phasers. but I think the reply still holds up for your case.)

[20:26] <jnthn> masak: Note that { LEAVE say now - ENTER now; sleep 1; } should work out, and is different from { LEAVE { say now - ENTER now } }

[20:26] <vendethiel-> m: my $a = 0 will next { $a++ }; while $a < 50 { say $a }; #let's reinvent C!

[20:26] <camelia> rakudo-moar 86b1b2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CIkcORPWd8␤Two terms in a row␤at /tmp/CIkcORPWd8:1␤------> 3my $a = 07⏏5 will next { $a++ }; while $a < 50 { say␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤ …»

[20:26] <vendethiel-> m: my $a will next { $a++ } = 0; while $a < 10 { say $a }; #let's reinvent C!

[20:26] <camelia> rakudo-moar 86b1b2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4H9dQ63DFV␤Variable '$a' is not declared␤at /tmp/4H9dQ63DFV:1␤------> 3my $a will next { $a++7⏏5 } = 0; while $a < 10 { say $a }; #let's␤    expecting any of:␤        postfix␤»

[20:26] <masak> jnthn: *nod*

[20:27] <jnthn> masak: Rakudo seems ot get the distinctiong right too

[20:27] <masak> nice.

[20:27] <jnthn> masak: Sadly, ENTER doesn't work as an rvalue yet

[20:27] <jnthn> That's one of the tickets open in my browser for a couple of days to look at

[20:27] <jnthn> But I ended up working on making our hashes use a bunch less memory instead :)

[20:28] <lizmat> jnthn: given a &block, how do I get to set $_ inside that block

[20:28] <lizmat> that's one of the missing features of will foo { ... } atm

[20:28] <jnthn> lizmat: Depends exactly how it's compiled

[20:29] <jnthn> lizmat: If with implicit, then passing it as an argument when invoking the block should work.

[20:29] <lizmat> it enters as a $block in a trait_mod

[20:29] <jnthn> m: my $a = { say $_ }; $a(42)

[20:29] <camelia> rakudo-moar 86b1b2: OUTPUT«42␤»

[20:30] <lizmat> ah, ok...

[20:30] <lizmat> hmmm...

[20:30] <jnthn> You can try that. If it doesn't work, we may be able to tweak how will foo { ... } blocks parse...

[20:31] *** spider-mario joined
[20:34] <lizmat> $ 6 'my $a will leave { .say } = 42'

[20:34] <lizmat> Too many positionals passed; expected 0 arguments but got 1

[20:34] <lizmat> I guess we need to look at that then

[20:36] <jnthn> rule trait_mod:sym<will>    { <sym> [ <identifier> || <.panic: 'Invalid name'>] <pblock> }

[20:36] <jnthn> Try making it <pblock(1)> at the end

[20:36] *** Foxcool left
[20:37] *** Foxcool joined
[20:38] <lizmat> will do

[20:38] *** vendethiel- is now known as vendethiel

[20:42] <lizmat> $ 6 'my $a will leave { .say }; $a = 42'

[20:42] <lizmat> (Any)

[20:42] <lizmat> yeah, it gets the original value of the var

[20:43] <lizmat> $v.block.add_phaser('LEAVE', { $block($v.var) } );   # too naive

[20:43] <jnthn> Very much so :)

[20:44] <jnthn> I guess in $v you have the variable's name

[20:44] <lizmat> the Variable object

[20:44] <jnthn> Right, but somehow you can get to the name of the symbol

[20:44] <lizmat> multi sub trait_mod:<will>(Variable:D $v, $block, :$leave! ) {

[20:45] <lizmat> yeah, that would be $v.name

[20:45] *** Foxcool left
[20:46] <jnthn> Hm, this is all rather related to the thread safety issues we have with phasers. But for now, for leave/enter at least, we know the caller of the trait is the relevant frame

[20:46] <jnthn> So could try something like nqp::atkey(nqp::ctxcaller(nqp::ctx()), $v.name) or so

[20:46] <jnthn> Which is a cheaper spelling of CALLER::{$v.name} I guess

[20:47] <lizmat> will play with that

[20:47] *** Foxcool joined
[20:49] *** mohij joined
[20:50] <lizmat> $ 6 'my Int $a will leave { .say }; $a = 42'

[20:50] <lizmat> Lexical with name '$a' does not exist in this frame

[20:50] <lizmat> guess I need to move a few more frames ?

[20:51] <jnthn> oh...argh

[20:51] <jnthn> hm, wait, show me le patch

[20:52] <lizmat> $v.block.add_phaser('LEAVE', { $block(nqp::atkey(nqp::ctxcaller(nqp::ctx()), $v.name)) } );

[20:52] <jnthn> yeah, then you're talking about the trait's caller

[20:52] <jnthn> Oh now, you wrapped it

[20:52] <jnthn> Hmm

[20:52] <jnthn> *no

[20:53] <lizmat> again, being naive there  :-)

[20:53] <jnthn> Yeah, but the wrapping is what I thought you'd forgot

[20:53] <jnthn> But it looks right

[20:53] <jnthn> Does --optimize=off help?

[20:54] <lizmat> $ perl6 --optimize=off -e 'my Int $a will leave { .say }; $a = 42'

[20:54] <lizmat> Lexical with name '$a' does not exist in this frame

[20:54] <lizmat> nah

[20:54] <jnthn> Suspected not.

[20:54] *** Foxcool left
[20:54] <jnthn> Ohhh

[20:55] <jnthn> The LEAVE thing is processed by something not called directly

[20:55] <jnthn> So yes, you do need an extra level

[20:55] <lizmat> yeah, trying that now

[20:55] <lizmat> what is the equivalent of CALLER::CALLER:: ?

[20:55] <jnthn> Search for leave_handler or block_exit_handler or so in BOOTSTRAP.nqp for an idea

[20:55] <jnthn> Just call nqp::callerctx another time :)

[20:57] <ugexe> m: my $a = [1,2,3]; my $b = [4,5]; my $c = []; my $d = [$a (|) $b (|) $c]; say $d; # the ordering here seems to be causing pandas current test failure. is it a bug with set or should panda change what it expects order wise?

[20:57] <camelia> rakudo-moar 13dc82: OUTPUT«set(5, 4, 3, 1, 2)␤»

[20:57] <lizmat> it shouldn't

[20:58] <jnthn> Panda shouldn't expect order there

[20:58] <lizmat> sets are basically a restricted hash and  therefore the order is not fixed (anymore)

[20:58] <lizmat> $ 6 'my Int $a will leave { .say }; $a = 42'

[20:58] <lizmat> 42

[20:58] <lizmat> yeah!

[20:58] <jnthn> Well, it never was on JVM< and Panda has had JVM issues recently too

[20:58] <jnthn> lizmat: yay :)

[20:59] *** egrep left
[20:59] *** egrep joined
[21:01] <lizmat> $ 6 'my Int $a will enter { $_ = 42 }; say $a'

[21:01] <lizmat> 42

[21:01] <lizmat> aren't KEEP / UNDO / FIRST / NEXT / LAST the same really ?

[21:01] *** TimToady left
[21:02] <masak> the latter three may only occur in loops.

[21:02] <jnthn> We won't get it to work on the last 3 I doubt

[21:02] <lizmat> yeah, but from the view of scopes, they would be the same, no?

[21:02] <lizmat> ok

[21:02] <jnthn> But KEEP/UNDO are viable with the same technique

[21:02] <jnthn> As they're just conditioned leaves

[21:02] <lizmat> I'll try KEEP / UNDO  :-)

[21:03] <masak> yeah, KEEP/UNDO are subsets of LEAVE

[21:08] *** Foxcool joined
[21:10] <lizmat> ugexe: merged your PR

[21:10] <ugexe> thanks

[21:12] <lizmat> $ 6 'my Int $a will undo { .say }; $a = 42; fail'

[21:12] <lizmat> 42

[21:12] <lizmat> :-)

[21:13] <dalek> rakudo-star-daily: 9f3195c | coke++ | log/ (2 files):

[21:13] <dalek> rakudo-star-daily: today (automated commit)

[21:13] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/9f3195cbde

[21:13] <dalek> perl6-roast-data: 7eb6578 | coke++ | / (9 files):

[21:13] <dalek> perl6-roast-data: today (automated commit)

[21:13] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/7eb6578bf5

[21:13] <masak> 'night, #perl6

[21:14] *** zakharyas left
[21:14] <lizmat> good night. masak

[21:15] <RabidGravy> yep panda worky again

[21:15] *** dolmen joined
[21:17] <lizmat> looks like FIRST is like ENTER

[21:17] <lizmat> $ 6 'for ^2 { my Int $a will first { $_ = 42 }; say $a }'

[21:17] <lizmat> 42

[21:17] <lizmat> (Int)

[21:21] <RabidGravy> nice :-)

[21:22] *** vendethiel left
[21:22] <dalek> roast: 87e6d13 | coke++ | S02-types/declare.t:

[21:22] <dalek> roast: RT #124461 - replace flawed test

[21:22] <dalek> roast: review: https://github.com/perl6/roast/commit/87e6d13287

[21:22] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=124461

[21:25] *** cognominal joined
[21:26] <[Coke]> can someone demonstrate a "num" overflow that doesn't happen on Num ?

[21:26] *** RabidGravy left
[21:28] *** vendethiel joined
[21:30] <[Coke]> m: say Num.max; say num.max;

[21:30] <camelia> rakudo-moar 13dc82: OUTPUT«Cannot call max(Num: ); none of these signatures match:␤    (Any:D: *%_)␤    (Any:D: Any $by, *%_)␤  in block <unit> at /tmp/x_Li2GKtJH:1␤␤»

[21:31] <[Coke]> m: say num.max;

[21:31] <camelia> rakudo-moar 13dc82: OUTPUT«Cannot call max(num: ); none of these signatures match:␤    (Any:D: *%_)␤    (Any:D: Any $by, *%_)␤  in block <unit> at /tmp/618_W1lICG:1␤␤»

[21:31] <lizmat> m: say num.Range.max

[21:31] <camelia> rakudo-moar 13dc82: OUTPUT«Inf␤»

[21:31] <[Coke]> (locally that says -Inf)

[21:31] <lizmat> m: say int.Range.max

[21:31] <camelia> rakudo-moar 13dc82: OUTPUT«9223372036854775807␤»

[21:31] <lizmat> m: say int8.Range.max

[21:31] <camelia> rakudo-moar 13dc82: OUTPUT«127␤»

[21:32] <lizmat> m: say bit.Range.max

[21:32] <camelia> rakudo-moar 13dc82: OUTPUT«Inf␤»

[21:32] <lizmat> yuck

[21:32] *** bjz left
[21:33] <lizmat> m: say int1.Range.max

[21:33] <camelia> rakudo-moar 13dc82: OUTPUT«0␤»

[21:33] <lizmat> m: say int1.Range

[21:33] <camelia> rakudo-moar 13dc82: OUTPUT«-1..0␤»

[21:33] <lizmat> m: say uint1.Range

[21:33] <camelia> rakudo-moar 13dc82: OUTPUT«0..1␤»

[21:34] *** TimToady joined
[21:34] <dalek> roast: 45e6d35 | coke++ | S02-types/declare.t:

[21:34] <dalek> roast: RT #124461 - explicitly check that type boxed.

[21:34] <dalek> roast: review: https://github.com/perl6/roast/commit/45e6d35372

[21:34] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=124461

[21:36] <dalek> roast: 70231d3 | coke++ | S02-types/declare.t:

[21:36] <dalek> roast: RT #124467 - native junctions are no more

[21:36] <dalek> roast: review: https://github.com/perl6/roast/commit/70231d3409

[21:36] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=124467

[21:41] <dalek> rakudo/nom: 87b1eea | lizmat++ | src/ (2 files):

[21:41] <dalek> rakudo/nom: Variable will foo &block cleanup

[21:41] <dalek> rakudo/nom: 

[21:41] <dalek> rakudo/nom: - will init/post/compose will now throw NYI instead of silently doing nothing

[21:41] <dalek> rakudo/nom: - will enter/leave/keep/undo/first/pre will now set $_ correctly

[21:41] <dalek> rakudo/nom: 

[21:41] <dalek> rakudo/nom: jnthn++ for support and suggestions!

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/87b1eea71e

[21:44] <timotimo> can we just write multiple "will" in a row without problems?

[21:45] <lizmat> yes:

[21:45] <lizmat> $ 6 'my $a will enter { $_ = "1".IO.open } will leave { .close }; say $a.lines'

[21:45] <lizmat> %*ENV<RAKUDO_VERBOSE_STACKFRAME>=1; sub a { die }; a

[21:46] <lizmat> the 2nd line is what is in file "1"  :-)

[21:46] <[Coke]> down to 1292 tickets.

[21:46] <lizmat> looking at this, I wonder whether will phasers such as "enter" shouldn't write their result to $_ automagically

[21:47] <[Coke]> uuuugh.

[21:47] <lizmat> seems this NY hackathon created more work than it solved :-)

[21:48] *** dolmen left
[21:49] *** vendethiel left
[21:50] <timotimo> they do what now?

[21:50] <timotimo> write their result to $_?

[21:50] <timotimo> is that only for will phasers or also for block phasers?

[21:50] <lizmat> nono, the variable is available as $_ inside the scope

[21:50] <[Coke]> lizmat: little bit, yah.

[21:50] <timotimo> ah

[21:51] <timotimo> so you could my $a will enter { .=lc }; OSLT?

[21:51] <lizmat> my $a will enter { "1".IO.open } will leave { .close }   # feels more natural

[21:52] <lizmat> my $a will enter { .=lc } = "FOO"; say $a   # na, the initialization happens *after* the enter block is executed

[21:54] <lizmat> so I guess the use of "will enter" is limited anyway

[21:54] <timotimo> now to look at the racyness of Proc::Async

[21:54] *** spider-mario left
[21:54] <timotimo> how hard is it gonna be anyway ... ~_~

[21:55] *** spider-mario joined
[21:57] <jnthn> [Coke]: num and Num can store the same value range

[21:57] <jnthn> [Coke]: Though I had an idea for testing the decl is effective: write a multi x(num) { 1 }, multi x (Num) { 2 }, and then make sure calling it on a variable decalred as a num calls #1

[21:58] *** virtualsue left
[21:59] <timotimo> oh wow. these valgrind thread error detector tools are *really* noisy

[21:59] <timotimo> ==30166== ERROR SUMMARY: 2464 errors from 104 contexts (suppressed: 4531 from 77)

[21:59] <timotimo> probably not going to go through all of these tonight

[22:00] * lizmat wishes #perl6 a good night!

[22:00] <jnthn> o/ lizmat 

[22:00] <timotimo> gnite lizmat 

[22:01] <jnthn> timotimo: Yeah, well we deliberately race on things like the call count used for specialization.

[22:01] <timotimo> it seems like the DRD thinks our frame invocation is racy ... could be it just doesn't understand the libatomicops thing we use there?

[22:01] <timotimo> ==30166== Conflicting load by thread 2 at 0x09d0fca0 size 8

[22:02] <timotimo> ==30166==    at 0x4D874DD: AO_compare_and_swap_full (x86.h:142)

[22:02] <jnthn> That's also possible

[22:02] <timotimo> it might have an option for this kind of thing

[22:02] *** Foxcool left
[22:02] <jnthn> I've not had time to dig deeply into its analysis model yet

[22:04] <timotimo> The macros DRD_IGNORE_VAR(x), ANNOTATE_TRACE_MEMORY(&x) and the corresponding client request VG_USERREQ__DRD_START_SUPPRESSION. Some applications contain intentional races. There exist e.g. applications where the same value is assigned to a shared variable from two different threads. It may be more convenient to suppress such races than to solve these. This client request allows to suppress such races.

[22:04] <timotimo> there's also ANNOTATE_BENIGN_RACE_SIZED and ANNOTATE_BENIGN_RACE_STATIC

[22:05] <ugexe> is there a way with phasers to access self to do something like: class XX { has $.var is rw;  END { say "var = $.var" }; }; my $q = XX.new(var => 1);

[22:06] <jnthn> ugexe: No, because the phaser is not once per instance.

[22:07] <jnthn> ugexe: I'd maintain a list of instances and then have the phaser to over them

[22:07] <jnthn> *go over them

[22:11] <timotimo> jnthn: how do you feel about adding client requests all over moarvm's code base?

[22:11] <jnthn> timotimo: I generally dislike clutter.

[22:12] <timotimo> fair enough

[22:12] <jnthn> Is there not a supressions file approach like in valgrind?

[22:12] <jnthn> uh, valgrind memcheck I mean

[22:12] <timotimo> i haven't read up on that yet

[22:12] <jnthn> k

[22:16] <timotimo> suppression file lines start with what the suppression is called and then what tools it applies to 

[22:16] <timotimo> it seems like the method itself is tool-independent, or tool-agnostic or something like that

[22:18] <dalek> roast: 5f6d6a6 | coke++ | S02-types/declare.t:

[22:18] <dalek> roast: RT #124461 add another verification for num

[22:18] <dalek> roast: 

[22:18] <dalek> roast: Hard to distinguish between between num/Num

[22:18] <dalek> roast: 

[22:18] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=124461

[22:18] <dalek> roast: jnthn++

[22:18] <dalek> roast: review: https://github.com/perl6/roast/commit/5f6d6a61be

[22:19] <timotimo> jnthn: what about teaching the valgrinds about how the fixed size allocator works so that we'll be pointed to the place where a chunk of it gets "allocated", rather than where a page is added

[22:20] <jnthn> timotimo: I usually just switch the FSA into debug mode if I want that so far.

[22:20] <timotimo> helgrind seems to report writes to any place inside a page as conflicting

[22:20] <jnthn> timotimo: Where it degenerates to using malloc for all

[22:20] <jnthn> Ah

[22:20] <timotimo> ah, neato

[22:20] <timotimo> there's a -D for that?

[22:20] <jnthn> you just tweak an 0 to a 1 at the top of fixedsizealloc.c

[22:20] <jnthn> But feel free to make something more convenient

[22:20] <timotimo> OK

[22:21] <timotimo> maybe later

[22:22] *** kaare_ left
[22:28] *** rurban left
[22:31] <timotimo> so one of the races seems to be spesh possibly dropping in a spesh candidate while other threads could be invoking the frame

[22:32] <timotimo> i think we race that intentionally?

[22:34] <jnthn> I think we do something to protect the installation of 'em too

[22:34] <timotimo> huh ... interesting. reentrantmutex_lock (a read) is apparently conflicting with initialize_mutex (a write)

[22:34] <timotimo> there are interesting things to see in here

[22:34] <timotimo> but the chances that i'll figure out what's wrong with the Proc::Async implementation with this tool are ... slim

[22:40] *** mohij left
[22:46] *** risou is now known as risou_awy

[22:46] *** risou_awy is now known as risou

[22:49] <timotimo> the gen2 seems to trip up helgrind, too

[22:53] *** rarara joined
[22:54] <timotimo> Address 0x9ea49f0 is 9,824 bytes inside a block of size 12,288 alloc'd - this is all so useless :(

[23:05] <rjbs> perl6 has --doc to show program docs and -M which has to resolve a module, but I don't see a way to get module docs.  Am I missing something?

[23:05] <timotimo> oh, that's a good point

[23:09] *** yqt left
[23:12] *** vendethiel joined
[23:23] *** spider-mario left
[23:28] *** Isp-sec left
[23:34] *** gfldex left
[23:34] *** vendethiel left
[23:51] <rjbs> m: my %h; %h<a> = 1; %h.perl

[23:51] <camelia> rakudo-moar 87b1ee: ( no output )

[23:51] <rjbs> m: my %h; %h<a> = 1; say %h.perl

[23:51] <camelia> rakudo-moar 87b1ee: OUTPUT«{:a(1)}<>␤»

[23:51] <rjbs> What's the trailing <> mean?

[23:56] <timotimo> "decont"

[23:56] *** mule joined
[23:56] *** mule left
[23:57] <timotimo> i'm hoping to find something in valgrind that'd let us annotate a traceback that includes MVM_interp_run with the moar bytecode traceback

[23:59] <rjbs> I see that "decont" has already been complained about recently, so I will be mostly quiet.

