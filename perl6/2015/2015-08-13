[00:01] *** tinyblak joined
[00:03] <leont> Bummer, "Proto regex body must be {*} ", was doing something cute there

[00:16] *** spider-mario left
[00:23] <Sgeo> m: { .say }.parameters

[00:23] <camelia> rakudo-moar 98df93: OUTPUT«Method 'parameters' not found for invocant of class 'Block'␤  in block <unit> at /tmp/7CU4OVcJop:1␤␤»

[00:23] <skids> m: { .say }.signature.parameters

[00:23] <camelia> rakudo-moar 98df93: OUTPUT«Method 'parameters' not found for invocant of class 'Signature'␤  in block <unit> at /tmp/YZYMJYliUC:1␤␤»

[00:23] <Sgeo> m: say { .say }.signature

[00:23] <camelia> rakudo-moar 98df93: OUTPUT«(;; $_? is parcel)␤»

[00:24] <Sgeo> m: say { &say }.signature

[00:24] <camelia> rakudo-moar 98df93: OUTPUT«(;; $_? is parcel)␤»

[00:24] <Sgeo> ?

[00:24] <skids> m: &say.signature.parameters

[00:24] <Sgeo> The second shouldn't take an argument but the first should, I thought

[00:24] <camelia> rakudo-moar 98df93: OUTPUT«Method 'parameters' not found for invocant of class 'Signature'␤  in block <unit> at /tmp/pNRJm6ppiG:1␤␤»

[00:24] <Sgeo> But those look the same

[00:24] <skids> m: &say.signature.say

[00:24] <camelia> rakudo-moar 98df93: OUTPUT«(|)␤»

[00:25] <Sgeo> m: say { 5 }.signature

[00:25] <camelia> rakudo-moar 98df93: OUTPUT«(;; $_? is parcel)␤»

[00:25] <skids> you got it.

[00:25] <Sgeo> m: say { $^a + 1 }.signature

[00:25] <camelia> rakudo-moar 98df93: OUTPUT«($a)␤»

[00:25] <Sgeo> m: say { $_ + 1 }.signature

[00:25] <camelia> rakudo-moar 98df93: OUTPUT«(;; $_? is parcel)␤»

[00:25] <Sgeo> ??? I thought that that is always a closure with an explic $_

[00:27] *** laouji joined
[00:27] <skids> It is a closure so... ?

[00:27] <skids> You mean why isn't $_ mandatory?

[00:28] <skids> m: { $_ + 1 }().say;

[00:28] <camelia> rakudo-moar 98df93: OUTPUT«Use of uninitialized value of type Any in numeric context  in block  at /tmp/m83eJ2UWXV:1␤1␤»

[00:29] <skids> Maybe just because $_ is dwimmy.

[00:30] <Sgeo> m: $_ = 5; { .say }(6);

[00:30] <camelia> rakudo-moar 98df93: OUTPUT«6␤»

[00:31] <Sgeo> Dealt with an API that would, if the item I was asking for did not meet some criteria, would give me a random item (i.e. not the one that was asked for) which did... but it wasn't what was looked for, an error would be much saner

[00:32] <Sgeo> So, that just put me in mind of being a bit DWIMy and guessing wrong what I meant

[00:39] *** laouji left
[00:39] *** laouji joined
[00:43] *** llfourn joined
[00:44] <dalek> roast: aeb52e4 | hoelzro++ | S26-documentation/why- (3 files):

[00:44] <dalek> roast: Test that you can declaratively document Block objects

[00:44] <dalek> roast: review: https://github.com/perl6/roast/commit/aeb52e432d

[00:44] <dalek> rakudo/nom: 83e91a5 | hoelzro++ | src/ (4 files):

[00:44] <dalek> rakudo/nom: Lift Routine's $!why behavior up to Block

[00:44] <dalek> rakudo/nom: 

[00:44] <dalek> rakudo/nom: There's no reason that Blocks shouldn't be able to be doc'd.  The

[00:44] <dalek> rakudo/nom: inspiration for this was creating a little Bailador application:

[00:44] *** dalek left
[00:45] *** dalek joined
[00:45] *** ChanServ sets mode: +v dalek

[00:48] *** llfourn left
[00:50] <hoelzro> ...did I kill dalek?

[00:50] <hoelzro> oh my

[00:51] *** hobbs left
[00:51] <geekosaur> dalek killed itself in overzealousness :)

[00:51] *** hobbs joined
[00:56] *** kst` joined
[00:57] *** kst left
[01:23] <ShimmerFairy> hey yoleaux, tell me what I know :)

[01:23] <yoleaux> 12 Aug 2015 15:29Z <TimToady> ShimmerFairy: re http://irclog.perlgeek.de/perl6/2015-08-12#i_11042225 the problem with nqp::defined is that it treats Failure.new as defined, and 'with' needs to treat those as undefined

[01:25] <ShimmerFairy> .tell TimToady yeah, that's completely understandable. I could see a possible nqp::p6with[out] and such for the version that Perl 6 expects, but I wouldn't worry about it unless/until people _really_ want to use nqp::with[out] in non-P6 contexts.

[01:25] <yoleaux> ShimmerFairy: I'll pass your message to TimToady.

[01:26] *** beastd left
[01:37] *** leont left
[01:37] <dalek> rakudo-star-daily: 60fc0f2 | coke++ | log/MoarVM- (5 files):

[01:37] <dalek> rakudo-star-daily: today (automated commit)

[01:37] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/60fc0f2af6

[01:38] *** dayangkun joined
[01:44] *** aristotle left
[01:59] *** llfourn joined
[02:01] *** telex left
[02:02] *** telex joined
[02:03] *** llfourn left
[02:05] *** tinyblak left
[02:11] *** llfourn joined
[02:19] <japhb> What's the idiom to pass a slurpy list of pairs without them being interpreted as named arguments?

[02:22] <ShimmerFairy> m: sub foo(*@a, *%b) { say @a.perl }; foo(:some(1), :thing(2)); foo((:some(1), :thing(2))); my %h = :1some, :2thing; foo(@%h)

[02:22] <camelia> rakudo-moar 98df93: OUTPUT«[]<>␤[:some(1), :thing(2)]<>␤[:some(1), :thing(2)]<>␤»

[02:23] <ShimmerFairy> japhb: basically, either wrap each named in parens, or use a list of pairs (I used a list-ified Hash there), or make sure your keys aren't literal identifiers :)

[02:23] <TimToady> m: my @a; push @a <== :a, :!b; say @a

[02:23] <yoleaux> 01:25Z <ShimmerFairy> TimToady: yeah, that's completely understandable. I could see a possible nqp::p6with[out] and such for the version that Perl 6 expects, but I wouldn't worry about it unless/until people _really_ want to use nqp::with[out] in non-P6 contexts.

[02:23] <camelia> rakudo-moar 98df93: OUTPUT«a => True b => False␤»

[02:23] <ShimmerFairy> m: sub foo(*@a, *%b) { say @a.perl }; foo(some => 1, "thing" => 2)

[02:23] <camelia> rakudo-moar 98df93: OUTPUT«[:thing(2)]<>␤»

[02:24] <japhb> Oh hmm, just quoting the keys may be workable

[02:24] <japhb> Assigning to a hash first doesn't work because I need to care about order

[02:25] <japhb> Will the extra level of parentheses trick survive GLR?

[02:25] <TimToady> no

[02:25] <TimToady> well, if you use *, I guess it would

[02:26] <TimToady> but <== is clearer, methinks

[02:26] <ShimmerFairy> TimToady: by the way, I don't know if you saw me say so before, but I like the :> idea for disambiguating between nameds and pairs (however, I also think it's probably too late to try that :< )

[02:26] <japhb> TimToady: So if I declare 'sub foo(*@pairs) {...}' then 'foo((a => 1, b => 2))' should do it?

[02:26] <TimToady> should work

[02:27] <TimToady> dinner (in Seattle) &

[02:27] <japhb> TimToady: Oh yeah, I missed your <== example the first time.

[02:27] <japhb> That may actually work even better

[02:29] <ShimmerFairy> japhb: just keep in mind that you have to use <== , or else you run into the same problem all over again :P

[02:29] *** BenGoldberg joined
[02:30] *** arch_vader joined
[02:32] <japhb> nodnod

[02:35] *** noganex_ joined
[02:35] *** arch_vader left
[02:37] *** noganex left
[02:43] *** cognominal left
[02:44] *** cognominal joined
[02:46] *** TEttinger left
[02:47] *** TEttinger joined
[02:52] *** mr-foobar left
[03:00] *** cognominal left
[03:00] *** dwarring left
[03:06] *** tinyblak joined
[03:06] *** bin_005 joined
[03:06] *** bin_005 left
[03:06] <flussence> I just wrote «use lib $*PROGRAM-NAME.IO.parent.child('lib');» in a script, and I can't help feeling there's an obvious and pretty way to say it I'm missing...

[03:07] <flussence> well, s/PROGRAM-NAME.IO/PROGRAM/ is a start...

[03:11] *** tinyblak left
[03:19] <ugexe> depends. anything for a test file and you shouldnt expect any code to be in any specific location

[03:19] <ugexe> anything but a test file^

[03:20] <ugexe> tests dont get installed. but scripts in say bin/ do

[03:20] <ugexe> and CURL.install does not put anything in a /lib folder

[03:23] <flussence> it's a standalone script with a lib/ in the same directory

[03:23] <ugexe> use lib 'lib

[03:23] <ugexe> '

[03:23] *** khw left
[03:24] <flussence> I tried that, but then it doesn't work unless $*CWD eq $*PROGRAM.parent...

[03:24] <PerlJam> ugexe: but that's lib relative to $*CWD, not the location of the program.

[03:25] *** llfourn left
[03:27] <ugexe> thats why panda and zef have to change the cwd to work with a bunch of stuff in the ecosystem

[03:27] <ugexe> personally i dont like 'use lib "lib"', in such cases i use -I or PERL6LIB

[03:30] <flussence> m: say 'use lib $*PROGRAM.parent.child("lib")'.chars cmp 'use FindBin qw($Bin); use lib "$Bin/lib"'.chars

[03:30] <camelia> rakudo-moar 98df93: OUTPUT«Less␤»

[03:30] <PerlJam> win!

[03:30] <flussence> no reason for me to complain then :)

[03:31] <flussence> (would be nice if I could do "IO.sibling", but it's short enough I don't really care at this point)

[03:31] <PerlJam> spec it  :)

[03:33] <flussence> I'll go through some of the other p6 code I have floating around and see if there's enough there to make it interesting... but I'll leave it for tomorrow, kinda late here :)

[03:35] <ugexe> IO.sibling++

[03:38] * PerlJam now half expects to wake up tomorrow and notice that lizmat specced and implemented IO.sibling

[03:39] <ugexe> hehe, i might have to monkey-patch it in the mean time. a good idea 

[03:50] * PerlJam sleep &

[03:53] *** mr-foobar joined
[04:05] *** geraud left
[04:14] *** llfourn joined
[04:22] *** BenGoldberg left
[04:35] *** mr-foobar left
[04:39] *** mr-foobar joined
[04:45] *** hello_ joined
[04:45] *** xinming_ joined
[04:48] *** xinming left
[04:54] *** cognominal joined
[04:55] *** jkva joined
[04:56] *** hello_ left
[04:58] *** aborazmeh joined
[04:58] *** aborazmeh left
[04:58] *** aborazmeh joined
[05:12] *** lizmat joined
[05:12] * lizmat waves from Tokyo

[05:13] *** freeze left
[05:17] <dalek> rakudo/glr: b2ec073 | (Jimmy Zhuo)++ | src/core/io_operators.pm:

[05:17] <dalek> rakudo/glr: keep args of note/say same as print

[05:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b2ec07396a

[05:17] <dalek> rakudo/glr: e93d48e | lizmat++ | src/core/io_operators.pm:

[05:17] <dalek> rakudo/glr: Merge pull request #490 from zhuomingliang/patch-1

[05:17] <dalek> rakudo/glr: 

[05:17] <dalek> rakudo/glr: keep args of note/say same as print

[05:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e93d48eee2

[05:26] *** freeze joined
[05:30] *** rurban joined
[05:50] *** mr-foobar left
[06:01] *** rurban_ joined
[06:02] *** ShimmerFairy left
[06:05] *** diana_olhovik joined
[06:14] *** kurahaupo joined
[06:16] *** ShimmerFairy joined
[06:22] <Sgeo> m: say Mu.new

[06:22] <camelia> rakudo-moar 98df93: OUTPUT«Mu.new␤»

[06:39] *** aborazmeh left
[06:39] *** kurahaupo left
[06:43] <skids> .tell jnthn tried my hand at GLR Array.unshift(**@) in PR#491 (sorry about the /msg, too tired)

[06:43] <yoleaux> skids: I'll pass your message to jnthn.

[06:46] *** espadrine joined
[06:49] *** zakharyas joined
[06:56] *** breinbaas joined
[06:58] *** FROGGS joined
[06:58] *** kurahaupo joined
[07:00] <FROGGS> o/

[07:16] *** RabidGravy joined
[07:24] *** ingy left
[07:24] <[Tux]> o/

[07:24] <dalek> rakudo/glr: 6d8768f | (Stefan Seifert)++ | src/core/Any-iterable-methods.pm:

[07:24] <dalek> rakudo/glr: Give implementing map with .count > 1 a try

[07:24] <dalek> rakudo/glr: 

[07:24] <dalek> rakudo/glr: We don't handle trailing elements correctly yet, but simple cases like

[07:24] <dalek> rakudo/glr: for flat ([1, 2], [3, 4], [5]) -> $a, $b { say "$a $b"; } work again

[07:24] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6d8768fb63

[07:24] *** ingy joined
[07:26] *** frew joined
[07:32] *** llfourn left
[07:33] *** virtualsue joined
[07:34] *** virtualsue left
[07:34] *** fxer joined
[07:34] *** skids left
[07:35] *** virtualsue joined
[07:35] *** virtualsue left
[07:36] *** virtualsue joined
[07:36] <[Tux]> Inline::Perl5

[07:36] <[Tux]>         *fetch stage failed for LibraryMake: Failed cloning git repository 'git://github.com/retupmoca/P6-LibraryMake.git'

[07:37] <DrForr> It's still on the site and active.

[07:38] <DrForr> Which does bring up an interesting point, however. Should we be backing up build-chain tools in case someone pulls them off github, at least until 6PAN or whatever gets decided on is ready?

[07:39] <DrForr> Granted, the odds are ridiculously low at this stage, but it's a thought.

[07:41] *** xinming_ left
[07:41] *** kst` left
[07:41] *** baest left
[07:41] *** rmgk left
[07:41] *** amurf left
[07:41] *** camelia left
[07:41] *** eternaleye left
[07:41] *** pierrot left
[07:41] *** ponbiki left
[07:41] *** oha left
[07:41] *** Ulti left
[07:41] *** SHODAN left
[07:41] *** [Coke] left
[07:41] *** Util left
[07:41] *** agentzh left
[07:41] *** shmibs left
[07:41] *** bloonix left
[07:41] *** bcode left
[07:41] *** garu left
[07:41] *** sjn left
[07:41] *** ruoso left
[07:42] *** tinyblak joined
[07:42] *** xinming_ joined
[07:42] *** kst` joined
[07:42] *** baest joined
[07:42] *** rmgk joined
[07:42] *** amurf joined
[07:42] *** [Coke] joined
[07:42] *** camelia joined
[07:42] *** eternaleye joined
[07:42] *** pierrot joined
[07:42] *** ponbiki joined
[07:42] *** oha joined
[07:42] *** Ulti joined
[07:42] *** SHODAN joined
[07:42] *** Util joined
[07:42] *** agentzh joined
[07:42] *** shmibs joined
[07:42] *** bloonix joined
[07:42] *** bcode joined
[07:42] *** garu joined
[07:42] *** sjn joined
[07:42] *** ruoso joined
[07:42] *** card.freenode.net sets mode: +v camelia

[07:44] *** amurf_ joined
[07:44] *** tinyblak_ joined
[07:44] *** bcode left
[07:44] *** baest_ joined
[07:45] *** shmibs_ joined
[07:45] *** pierrot_ joined
[07:45] *** Ulti left
[07:45] *** [Coke] left
[07:45] *** Util left
[07:45] *** shmibs left
[07:45] *** bloonix left
[07:45] *** garu left
[07:45] *** ruoso left
[07:46] *** tinyblak left
[07:46] *** kst`` joined
[07:46] *** xinming_ left
[07:46] *** kst` left
[07:46] *** baest left
[07:46] *** rmgk left
[07:46] *** amurf left
[07:46] *** camelia left
[07:46] *** eternaleye left
[07:46] *** pierrot left
[07:46] *** ponbiki left
[07:46] *** oha left
[07:46] *** SHODAN left
[07:46] *** agentzh left
[07:46] *** sjn left
[07:47] *** bloonix joined
[07:47] *** Ulti joined
[07:47] *** ruoso joined
[07:47] *** [Coke] joined
[07:47] *** Util joined
[07:47] *** sjn joined
[07:47] *** ponbiki joined
[07:48] *** bcode joined
[07:48] *** xinming joined
[07:48] *** ponbiki is now known as Guest92786

[07:48] *** SHODAN joined
[07:50] *** rmgk joined
[07:51] *** eternaleye joined
[07:52] *** garu joined
[07:54] *** agentzh joined
[07:54] *** agentzh left
[07:54] *** agentzh joined
[07:57] *** dakkar joined
[07:57] *** virtualsue left
[07:59] *** [Sno] left
[08:00] *** oha joined
[08:00] *** virtualsue joined
[08:01] *** danaj left
[08:01] *** virtualsue left
[08:01] *** danaj joined
[08:02] *** virtualsue joined
[08:03] *** TEttinger left
[08:04] *** [TuxCM] joined
[08:05] *** TEttinger joined
[08:07] *** camelia joined
[08:09] *** ChanServ sets mode: +v camelia

[08:10] *** SamuraiJack joined
[08:12] *** virtualsue left
[08:16] *** virtualsue joined
[08:17] *** [TuxCM] left
[08:17] *** tinyblak_ left
[08:20] *** a_2067_1010 joined
[08:20] *** a_2067_1010 left
[08:22] *** llfourn joined
[08:36] <RabidGravy> Boom!

[08:38] *** darutoko joined
[08:39] <nine> It's so quiet in here that even the Boom doesn't raise the average much

[08:39] <DrForr> No boom today, boom tomorrow.

[08:41] *** rindolf joined
[08:42] <nine> There's always a boom tomorrow.

[08:42] <DrForr> nine++

[08:43] <nine> DrForr++

[08:44] * jnthn yawns

[08:44] <yoleaux> 06:43Z <skids> jnthn: tried my hand at GLR Array.unshift(**@) in PR#491 (sorry about the /msg, too tired)

[08:44] *** tinyblak joined
[08:45] <JimmyZ> jnthn: any idea why https://github.com/rakudo/rakudo/commit/b527b31a602086dbb1c47b2ccbaa57807d8a1203 increases core setting size by 2.4M ?

[08:47] <jnthn> Because it declares an operator not in Grammar.nqp, meaning we save another serialized copy of the whole set of NFAs

[08:47] <jnthn> Declaring it in Grammar.nqp should help

[08:48] <jnthn> If so, feel free to send a patch :)

[08:48] *** espadrine left
[08:49] <ShimmerFairy> jnthn: shouldn't that be spelled "nandthen" anyway? :P

[08:50] <JimmyZ> I managed compiling core setting eating all the memory and got killed either by add 'trait_mod:<is>(&infix:<notandthen>, :prec($loose_and));' or change it to my &infix<notandthen> := -> *@a'  ..

[08:51] <jnthn> Well, the latter is certainly a bad idea.

[08:51] *** brrt joined
[08:51] <brrt> \o

[08:51] <JimmyZ> trait_mod:<is>(&infix:<notandthen>, :prec($loose_and)); is added to src/core/precedence.pm

[08:51] <JimmyZ> and then eats all the memory ..

[08:52] <_itz> . o O ( is nine++ ten?)

[08:52] <ShimmerFairy> did you add 'notandthen' to Grammar.nqp too?

[08:52] <JimmyZ> like this token infix:sym<notandthen> { <sym> >> <O('%loose_and, :assoc<list>')> } ?

[08:53] *** TEttinger left
[08:54] <ShimmerFairy> Looks like that should be correct.

[08:56] *** fxer left
[08:57] <jnthn> aye, think so

[08:57] <nine> jnthn: I tend to run into expected Positional but got Seq errors in handle-exception. I guess fixing this would make development much easier, but I don't know enough about the design. I don't know if the problem is that it is passed a Seq or that it can't handle the Seq.

[08:58] <nine> In both cases I wouldn't know how to fix it :/ I'd guess that I'd have to do that in the Binder, but I'm really out of my depths there.

[08:58] <jnthn> nine: We're meant to do .list and bind the result of that...

[08:58] <jnthn> nine: And I thought I'd written the code to do it; I'll have a look why it's not working

[08:59] <nine> Ok, I could try how far I get with that knowledge, but only in the evening.

[09:00] *** breinbaas left
[09:00] *** notch_ joined
[09:04] <JimmyZ> pushed : https://github.com/rakudo/rakudo/pull/492

[09:07] <jnthn> .tell skids Left some comments on the PR

[09:07] <yoleaux> jnthn: I'll pass your message to skids.

[09:12] <jnthn> wtf, the final bunch of sanity tests SEGV for me now in glr

[09:16] *** leont joined
[09:20] <jnthn> ohh...interesting

[09:20] *** ecocode joined
[09:23] *** bin_005 joined
[09:23] *** hurricane joined
[09:25] * jnthn patched a Moar bug that was probably to blame for the odd time we SEGV'd instead of reporting a wrong pre-comp'd version of a library

[09:25] *** espadrine joined
[09:25] <leont> Sounds familiar

[09:26] <dalek> rakudo/glr: 7d55b06 | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[09:26] <dalek> rakudo/glr: Fix bug in Iterable lookup.

[09:26] <dalek> rakudo/glr: 

[09:26] <dalek> rakudo/glr: The compiler did warn, but I somehow missed it.

[09:26] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7d55b069fa

[09:28] *** SamuraiJack left
[09:31] *** ChoHag joined
[09:39] <nine> jnthn: /bin/sh: line 1: 11974 Segmentation fault      /home/nine/install/rakudo/install/bin/nqp-m tools/build/gen-cat.nqp moar src/Perl6/Actions.nqp > src/gen/m-Perl6-Actions.nqp

[09:39] <nine> jnthn: running make again seems to succeed though

[09:39] *** brrt left
[09:43] *** [TuxCM] joined
[09:44] <jnthn> nine: There's not much I can debug with that... :)

[09:45] <jnthn> If you manage to get it reproducable or get a stack trace, would be interesting to see

[09:45] *** FROGGS_ joined
[09:46] *** virtualsue left
[09:47] *** virtualsue joined
[09:48] <ShimmerFairy> m: say :45<0x1F> # should this fail?

[09:48] <camelia> rakudo-moar 98df93: OUTPUT«5===SORRY!5=== Error while compiling /tmp/FflOueSG1c␤Radix 45 out of range (allowed: 2..36)␤at /tmp/FflOueSG1c:1␤------> 3say :45<0x1F>7⏏5 # should this fail?␤»

[09:48] *** FROGGS left
[09:49] <ShimmerFairy> On the one hand, 45 is not a valid radix for that. On the other, it has an overriding '0x' prefix in it. The spec doesn't seem to say anything about it.

[09:49] <jnthn> m: say :45[0x1F]

[09:49] <camelia> rakudo-moar 98df93: OUTPUT«31␤»

[09:49] <jnthn> You have to use that syntax in this case I believe

[09:50] <ShimmerFairy> m: say :45[0xFF]

[09:50] <camelia> rakudo-moar 98df93: OUTPUT«255␤»

[09:51] <ShimmerFairy> huh, wasn't aware of that use of :radix[] . Seems odd though, considering [] is _supposed_ to contain a list of place values in the chosen radix

[09:51] <nine> jnthn: did not happen again. Was the first time I compiled glr on this machine, so that may have been the reason

[09:53] <ShimmerFairy> m: say :16[16]

[09:53] <camelia> rakudo-moar 98df93: OUTPUT«16␤»

[09:54] <ShimmerFairy> I think that actually works just by accident. There should be an upper limit on numbers in the [] form, AIUI

[09:54] <jnthn> nine: Oddness

[09:56] <ShimmerFairy> S02:3329  looks like a rakudobug (I'll submit if necessary and keep it in mind as I hack around in the radix-related stuff)

[09:56] <dalek> rakudo/glr: b3c3c78 | jnthn++ | src/core/Array.pm:

[09:56] <dalek> rakudo/glr: Give push and unshift "single item" semantics.

[09:56] <dalek> rakudo/glr: 

[09:56] <dalek> rakudo/glr: To patch array assignment, [...], etc.

[09:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b3c3c784c4

[09:57] <ShimmerFairy> (since there was no link generated by the bot, a quote: "All numbers representing digits must be less than the radix, or an error will result ")

[10:01] *** kurahaupo left
[10:02] <ShimmerFairy> As for :45<0x1F> , I think for now at least I'll err on the side of not letting you get away with a bad radix sometimes :)

[10:07] <dalek> rakudo/glr: 34a5fce | jnthn++ | src/core/Junction.pm:

[10:07] <dalek> rakudo/glr: Fix various Junction issues.

[10:07] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/34a5fce581

[10:08] <jnthn> With that, we're down to 3 failing sanity tests.

[10:09] *** RabidGravy left
[10:13] <jnthn> nine: btw, about the typecheck failed in binding thing: the failover in signatures *is* working fine, it seems

[10:13] <jnthn> nine: The problem is that my @a := @foo.map(...); is no longer legal

[10:13] <jnthn> (Which won't be changing)

[10:14] <sergot> hi #perl6 o/

[10:16] *** [Sno] joined
[10:16] <ShimmerFairy> jnthn: will that affect nqp::bindpos too? That bug in deepmap I fixed a few days ago involved certain returning .map'd things otherwise untouched, which ended up misbehaving when only bound to stuff (or assigned to sigil-less variables).

[10:19] <jnthn> nqp::bindpos works at a rather lower level

[10:20] <ShimmerFairy> Not surprising :) . The issue was with the .map'd thing not being reified properly, which I found when assigning the return value fixed it, but binding didn't. So I kinda lumped 'bindpos' in the nqp::while loops with the stuff that didn't affect those return values.

[10:21] <dalek> rakudo/glr: 6c652b2 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[10:21] <dalek> rakudo/glr: Re-instate slurpy support in slow-path binder.

[10:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6c652b2f3d

[10:21] <dalek> rakudo/glr: 35c2687 | jnthn++ | src/Perl6/World.nqp:

[10:21] <dalek> rakudo/glr: Update for List storage change.

[10:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/35c2687007

[10:24] *** cognominal left
[10:26] <dalek> rakudo/glr: 9710965 | jnthn++ | src/core/EnumMap.pm:

[10:26] <dalek> rakudo/glr: EnumMap now should implement .Int and .Numeric.

[10:26] <dalek> rakudo/glr: 

[10:26] <dalek> rakudo/glr: They're not longer provided by Iterable (and nor should they be).

[10:26] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9710965431

[10:26] <jnthn> 99-test-basic.t passes

[10:27] <jnthn> That just uses 54-use-lib.t with issues

[10:28] *** spider-mario joined
[10:30] <JimmyZ> Is it hard to change EnumaMap to Map? if not, I could do it 

[10:31] *** tinyblak left
[10:31] <jnthn> Don't know if we agreed on that yet (or at least, not sure TimToady++ approved)

[10:31] <jnthn> But let's keep the churn down for now

[10:32] <JimmyZ> ok :)

[10:32] *** [TuxCM] left
[10:34] *** sjn_phone joined
[10:37] <dalek> rakudo/glr: 9b02d49 | jnthn++ | src/Perl6/World.nqp:

[10:37] <dalek> rakudo/glr: Properly fix arglist.

[10:37] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9b02d49565

[10:39] *** brrt joined
[10:41] <dalek> rakudo/glr: 038e0e2 | jnthn++ | lib/Test.pm:

[10:41] <dalek> rakudo/glr: [...] doesn't itemize now, so need item here.

[10:41] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/038e0e2760

[10:41] <jnthn> I *think* that gets us clean on the sanity tests.

[10:41] *** virtualsue left
[10:42] *** virtualsue joined
[10:44] <brrt> \o/

[10:44] <brrt> time for cake!

[10:45] *** rurban_ left
[10:45] *** sjn_phone_ joined
[10:45] *** sjn_phone left
[10:45] <DrForr> But the cake is a lie :(

[10:49] *** sjn_phone_ left
[10:52] *** sjn_phone_ joined
[10:52] <|Tux|> jnthn++

[10:55] <brrt> time for beer, in that case :-)

[10:56] <DrForr> Indeed.

[10:56] <DrForr> Speaking of which I'm a touch upset that I'm headed to the Chartreuse distillery *after* YAPC::EU.

[10:56] <jnthn> We make it 2 spectests until we hit a failing one...

[10:57] <jnthn> Well, it's at least 3 now 'cus I just at least sufficiently unbusted sequences

[10:58] <dalek> rakudo/glr: 07c76a1 | jnthn++ | src/core/operators.pm:

[10:58] <dalek> rakudo/glr: Unbust SEQUENCE post-GLR.

[10:58] <dalek> rakudo/glr: 

[10:58] <dalek> rakudo/glr: Or at least, unbust it enough that the first spectest example that

[10:58] <dalek> rakudo/glr: uses it passes. Main changes: :infinite flag gone, .list does not

[10:58] <dalek> rakudo/glr: imply flattening, List is now immutable so can't .push to it.

[10:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/07c76a1bd1

[10:59] <ShimmerFairy> Wow, I just realized that fixing roast for GLR is going to be quite big (as is the specs, though likely not as much).

[11:00] <jnthn> Yup, now we're up to the first 4 passing :)

[11:00] <jdv79> woohoo!

[11:00] <jnthn> ShimmerFairy: Yeah, it will... :)

[11:01] <jnthn> ShimmerFairy: I don't worry so much over design docs; that'll just be updating them to be in line with what we decide in the implementation ;)

[11:01] <ShimmerFairy> jnthn: well, I need to get more familiar with GLR, but I wouldn't mind helping out on the tests when I can :)  (in a roast/glr branch, of course)

[11:02] <jnthn> ShimmerFairy: Please do :)

[11:03] <ShimmerFairy> jnthn: I certainly would hate to see you left with going over hundreds (thousands?) of test files :)

[11:03] <jnthn> It's not thousands

[11:03] <jnthn> :)

[11:03] <jnthn> But yeah, hundreds

[11:04] <ShimmerFairy> $ find -name *.t | wc -l

[11:04] <ShimmerFairy> 1158

[11:04] <ShimmerFairy> jnthn: it's thousands, surprisingly O_o

[11:04] <ShimmerFairy> (though that's counting all .t files, not excluding stresstest ones and so on)

[11:05] <jnthn> Oh wow

[11:05] <jnthn> It's grown :)

[11:05] * jnthn wonders if reduction meta-ops should flatten their input

[11:05] <jnthn> I guess not

[11:08] <jnthn> Um, when does a meta-op actually get called with multiple args?

[11:08] <brrt> i'm ambivalent on the whole flattening thing

[11:08] <ShimmerFairy> jnthn: uhm... chaining/list ops with a metaop??

[11:08] <brrt> it's *really* useful if you know how to use it in perl5

[11:09] <jnthn> ShimmerFairy: Example?

[11:09] <jnthn> Oh, I shoulda been clear 

[11:09] <jnthn> A *reduce* meta-op

[11:09] <ShimmerFairy> jnthn: I don't have an example, I was just throwing out a possibility.

[11:09] <jnthn> [+] 1,2,3 # passes a List of 3 values

[11:09] <jnthn> [+](1,2,3) # passes a List of 3 values

[11:09] <jnthn> I can't see how you'd end up in it otherwise

[11:10] <jnthn> And reduce is really, really the kinda thing that wants to work on an Iterable not a list

[11:10] <ShimmerFairy> jnthn: what if you tried things like .assuming on the reduction?

[11:10] <jnthn> ShimmerFairy: I'm after normal use cases :P

[11:11] <jnthn> Thing is

[11:11] <jnthn> If we don't make it work on Iterable then

[11:11] <jnthn> [+] @things.map({ blah })

[11:11] <jnthn> Would have to build up a list of things that the map produces

[11:11] <jnthn> Only for us to shift off it again

[11:11] <jnthn> Which is just wasteful

[11:13] <ShimmerFairy> jnthn: I'm guessing that the "takes multiple values" is just a result of what reduce does _conceptually_: place its operator between things. So you'd likely think of it as  reduction(@a[0], @a[1], @a[2], ...)

[11:14] *** lizmat left
[11:14] *** lizmat joined
[11:15] *** laouji left
[11:16] <jnthn> ShimmerFairy: I think the reality may be that it was done so you get a separate list so you can .shift off it

[11:17] <jnthn> ShimmerFairy: Because there wasn't really a "consume a thing at a time" iterator API

[11:17] <ShimmerFairy> jnthn: maybe git blame will tell you; it's certainly been interesting to go back when I spot weird extraneous stuff, and see what the deal was :)

[11:18] *** dayangkun left
[11:18] <ShimmerFairy> (if only commandline git had a "view file at this commit" feature, I didn't find one when looking)

[11:18] *** lizmat left
[11:18] <huf> isnt that git show rev:file ?

[11:18] <huf> there's *something*

[11:19] <jnthn> yeah, that's the one

[11:19] <ShimmerFairy> huf: perhaps, I'm not that skilled in git, or searching through the help docs (manpages) for stuff :)

[11:19] <huf> http://stackoverflow.com/questions/2071288/equivalent-in-git-of-hg-cat-or-svn-cat

[11:22] *** lizmat joined
[11:25] *** telex left
[11:26] *** telex joined
[11:31] *** tinyblak joined
[11:38] *** rurban left
[11:38] *** rurban joined
[11:40] <dalek> rakudo/glr: 8ff2f5e | jnthn++ | src/ (2 files):

[11:40] <dalek> rakudo/glr: Begin fixing up reductions.

[11:40] <dalek> rakudo/glr: 

[11:40] <dalek> rakudo/glr: Make the code-gen respect the "single item" rule we're using in many

[11:40] <dalek> rakudo/glr: places, and re-implement left-assoc reduce to work this way. Note that

[11:40] <dalek> rakudo/glr: it uses the iterator API directly and should be a good bit faster than

[11:40] <dalek> rakudo/glr: what came before, which shuffled things in and out of a temporary

[11:40] <dalek> rakudo/glr: intermediate list.

[11:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/8ff2f5e300

[11:41] <jnthn> Still need to fix up the other METAOP_REDUCE_* subs

[11:42] *** tinyblak left
[11:45] <jnthn> lunch

[11:49] <nine> jnthn: I saw a segfault again. But again it vanished when I re-ran make :/

[11:51] <brrt> perl5 question! what's the easy way to count the number of items in a hash

[11:52] <DrForr> keys %h

[11:52] <nine> in scalar context

[11:53] <DrForr> Though I guess that actually depends upon the definition of 'items' :)

[11:53] <brrt> ... ok, that will do

[11:53] *** bin_005 left
[11:57] <lizmat> $ perl -E 'my %h = (a => 1, b => 2); say 0+%h'

[11:57] <lizmat> 2

[11:57] <lizmat> the 0 is necessary

[12:06] * virtualsue has always favoured "scalar(keys %hash)"

[12:07] * brrt is doing just that

[12:07] <brrt> lizmat: if you use warnings on that it'll complain

[12:07] <virtualsue> yep

[12:07] <brrt> it'll work, but complain

[12:08] <lizmat> it's been a while  :-)

[12:08] <virtualsue> :-)

[12:08] <brrt> yeah, i'm doing quite a bit of perl5 for all the preprocessor stuff

[12:08] * lizmat is getting hungry, but is confused as to whether she's ready for breakfast, lunch or dinner

[12:09] <brrt> it has already  been lunchtime here

[12:09] <virtualsue> i used to spend a lot of time with people who called lunch 'dinner' which just confuses things even more

[12:13] <nine> I usually have breakfast around noon ;)

[12:14] *** virtualsue left
[12:14] <brrt> english had these weird rules wherein dinner refers to the main meal of the day, and supper to a mean in the evning, or the other way arround

[12:14] <brrt> *has

[12:17] *** tinyblak joined
[12:21] *** virtualsue joined
[12:23] <lizmat> dinner&    # figured it out

[12:28] <brrt> :-)

[12:29] <JimmyZ> anyone could merge #492 pr?

[12:31] <colomon> brrt: Are there actually proper rules for that?  My impression (as a native American English speaker) has always been that it those distinctions were mostly local custom at best.

[12:32] <brrt> stack exchange says this: http://english.stackexchange.com/questions/22446/lunch-vs-dinner-vs-supper-times-and-meanings

[12:33] <brrt> local customs seem to be the guide, yes

[12:33] <dalek> rakudo/nom: b3d4139 | (Jimmy Zhuo)++ | src/ (2 files):

[12:33] <dalek> rakudo/nom: declare notandthen in grammar too

[12:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b3d41396f0

[12:33] <dalek> rakudo/nom: 141eeab | peschwa++ | src/ (2 files):

[12:33] <dalek> rakudo/nom: Merge pull request #492 from zhuomingliang/nom

[12:33] <dalek> rakudo/nom: 

[12:33] <dalek> rakudo/nom: Merged #492.

[12:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/141eeab710

[12:33] <psch> hi #perl6 o/

[12:34] <dalek> specs: 3febe4c | (Kamil Kułaga)++ | S03-operators.pod:

[12:34] <dalek> specs: Added nothenthen

[12:34] <dalek> specs: 

[12:34] <dalek> specs: Because of https://github.com/rakudo/rakudo/pull/492

[12:34] <dalek> specs: review: https://github.com/perl6/specs/commit/3febe4c97c

[12:38] <JimmyZ> thank you all

[12:43] *** bobkare left
[12:44] <maettu> http://blogs.perl.org/users/swiss_perl_workshop/2015/08/asdf.html 

[12:44] <maettu> if you know a Perl 6 newbie, or other interested folk

[12:51] *** bobkare joined
[12:52] <virtualsue> maettu++

[12:52] <dalek> rakudo/glr: cb2320f | (Stefan Seifert)++ | src/core/IO/Spec/Unix.pm:

[12:52] <dalek> rakudo/glr: Fix IO::Spec::Unix::canonpath producing "foo bar" instead of "foo/bar"

[12:52] <dalek> rakudo/glr: 

[12:52] <dalek> rakudo/glr: Parentheses no longer flatten Positionals automatically in GLR.

[12:52] <dalek> rakudo/glr: Use explicit flat instead.

[12:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/cb2320f900

[12:53] <nine> jnthn: with this ^^^ and a little workaround in lib/lib.pm6 most of the NativeCall tests pass :)

[12:54] *** arch_vader joined
[12:54] <jnthn> nine: wow :)

[12:55] <nine> First Inline::Perl5 tests start passing!

[12:55] <nine> The lib/lib.pm6 workaronund is for NYI unshift with multiple values

[12:56] <jnthn> Ah, ok

[12:56] <dalek> rakudo/glr: 306ff11 | jnthn++ | src/core/Backtrace.pm:

[12:56] <dalek> rakudo/glr: Cannot index a Seq.

[12:56] <dalek> rakudo/glr: 

[12:56] <dalek> rakudo/glr: At least, not yet anyway.

[12:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/306ff11d49

[12:56] <jnthn> hm, now a couple of the early spectests block on sort. Guess I'll go fix that.

[13:00] *** arch_vader left
[13:02] *** arch_vader joined
[13:02] <dalek> rakudo/glr: d2de5d6 | (Stefan Seifert)++ | src/core/Array.pm:

[13:02] <dalek> rakudo/glr: Implement unshift-list

[13:02] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d2de5d6542

[13:02] <nine> jnthn: ^^^ workaround no longer needed :)

[13:03] <nine> Only failing 09-nativecast.t and 16-rt125408.t now

[13:05] <jnthn> o.O

[13:05] <jnthn> Wow

[13:06] <nine> 09-nativecast.t is expected: '1 2 3' got: 'Seq<140093199907520>' for is $carray[0..2], (1, 2, 3)

[13:06] *** sjn_phone_ left
[13:07] *** sjn_phone_ joined
[13:07] <nine> jnthn: is flat($carray[0..2]), (1, 2, 3) makes the test pass, but I don't know if the test or the implementation is faulty

[13:07] *** sjn_phone_ left
[13:08] *** sjn_phone joined
[13:08] <arch_vader> Hi! i want to contribute to Perl 6. How do I get started?

[13:09] *** mr-foobar joined
[13:09] <jnthn> nine: I'm rather dubious flat should be needed there, at first glance

[13:09] <JimmyZ> arch_vader: http://rakudo.org/how-to-help/ hope this helps

[13:10] *** sjn_phone left
[13:10] *** sjn_phone_ joined
[13:11] <arch_vader> JimmyZ: Thanks! How do I get myself involved in the community?

[13:12] *** rmgk_ joined
[13:12] *** rmgk left
[13:12] *** rmgk_ is now known as rmgk

[13:13] <nine> arch_vader: I guess the easiest way is to stay on this channel and talk to people about Perl 6 :)

[13:14] *** sjn_phone_ left
[13:15] *** sjn_phone_ joined
[13:16] <JimmyZ> arch_vader: what nine said, or http://blogs.perl.org/users/swiss_perl_workshop/2015/08/asdf.html

[13:19] *** sjn_phone_ left
[13:19] *** arch_vader left
[13:19] *** sjn_phone joined
[13:23] *** RabidGravy joined
[13:23] *** sjn_phone left
[13:23] *** sjn_phone_ joined
[13:23] *** sjn_phone_ left
[13:24] *** sjn_phone_ joined
[13:24] *** sjn_phone_ left
[13:25] *** sjn_phone_ joined
[13:25] *** sjn_phone_ left
[13:25] <dalek> rakudo/glr: 2f42915 | jnthn++ | src/core/Any-iterable-methods.pm:

[13:25] <dalek> rakudo/glr: Get sort working again after GLR refactor.

[13:25] <dalek> rakudo/glr: 

[13:25] <dalek> rakudo/glr: Should be a decent bit more efficient too, though we can still do

[13:25] <dalek> rakudo/glr: better.

[13:25] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2f4291587b

[13:25] *** sjn_phone joined
[13:28] * [Coke] tries to avoid a 9 hour layover in dusseldorf, and may have to cancel and rebook to make this happen. travel is fun! ;)

[13:28] <jnthn> 9 hour layover = urgh

[13:31] *** arch_vader joined
[13:31] <maettu> better than a 9 hour hangover

[13:34] *** arch_vad1r joined
[13:34] *** tinyblak left
[13:35] <arch_vader> JimmyZ: nine: Do I have to know previous versions of Perl to understand Perl 6?

[13:35] <nine> arch_vader: not at all

[13:36] <nine> arch_vader: there are quite a few people here who don't know Perl 5.

[13:36] *** tinyblak joined
[13:37] <arch_vader> nine: I want to start coding with Perl 6. Where should i begin?

[13:39] <JimmyZ> arch_vader: http://perl6.org/getting-started/

[13:40] <DrForr> Just compare the cost to a cheapo hotel room, and if the hotel is less expensive, may as well go for it :)

[13:40] <dalek> rakudo/glr: a58bcae | jnthn++ | src/core/Seq.pm:

[13:40] <dalek> rakudo/glr: Various missing methods on Seq.

[13:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a58bcae242

[13:40] <dalek> rakudo/glr: 7d0f1bd | jnthn++ | src/core/List.pm:

[13:40] <dalek> rakudo/glr: Cope with joining holey lists.

[13:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7d0f1bd767

[13:44] <dalek> rakudo/glr: e33977f | jnthn++ | src/core/EnumMap.pm:

[13:44] <dalek> rakudo/glr: Missing Str method in EnumMap.

[13:44] <dalek> rakudo/glr: 

[13:44] <dalek> rakudo/glr: Originally provided by Iterable, oddly enough.

[13:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e33977f5d4

[13:45] *** brrt left
[13:46] <arch_vader> JimmyZ: nine: Thanks a lot :) I think I can get started right away.

[13:46] <nine> arch_vader: and most important: have fun! :)

[13:47] *** sjn_phone left
[13:47] <arch_vader> nine: I will :)

[13:47] *** sjn_phone joined
[13:51] <jnthn> Wowser... Compiling '\1' in the glr branch manages to not only hang, but also allocates memory at a rate of 300 MB / sec. :)

[13:51] *** sjn_phone left
[13:51] *** sjn_phone_ joined
[13:53] *** sjn_phone joined
[13:53] *** sjn_phone_ left
[13:54] *** abaugher joined
[13:54] <nine> jnthn: oh is that what I see in a couple of spectest files?

[13:55] <abaugher> Hi all, thought I should introduce myself. I've been using Perl 6 about a month, blogging about it at http://blogs.perl.org/users/aaron_baugher/

[13:55] *** muraiki joined
[13:55] <nine> abaugher: nice to meet you :)

[13:56] <jnthn> nine: Probably

[13:56] <jnthn> nine: I'm working on hunting it down

[13:56] <nine> jnthn: great :)

[13:56] <nine> spectesting is much more fun if you don't have to kill processes all the time ;)

[13:57] *** sjn_phone left
[13:57] *** sjn_phone joined
[13:57] <abaugher> nine: Thanks, nice to meet you too.

[13:58] *** amurf_ left
[13:58] *** amurf joined
[13:59] *** arch_vader left
[13:59] <jnthn> nine: Yeah, in my last run it launched two of them (parallel spectest) and even if you've plenty of RAM to hand, 500 megs a second vanishing chews it quick :)

[13:59] *** sjn_phone left
[13:59] *** sjn_phone_ joined
[14:00] *** arch_vad1r left
[14:01] *** espadrine left
[14:03] <DrForr> Zowie. The P5-6 converter is currently at 25200 files and going, after a few little tweaks.

[14:03] <nine> abaugher: so you've been enjoying your journey into Perl 6 land so far?

[14:05] <abaugher> nine: Yeah, quite a bit.  It's very different in some ways, but I like it.

[14:07] *** sjn_phone_ left
[14:07] *** sjn_phone joined
[14:12] *** perlpilot joined
[14:13] <ugexe> reading/understanding the art of multiprocessor programming has been much easier after having been exposed to the higher level threading stuff in perl6

[14:13] *** perlpilot left
[14:17] *** skids joined
[14:17] *** sjn_phone left
[14:17] <jnthn> nine: Think I found it :)

[14:19] <nine> jnthn: nice :)

[14:20] <dalek> rakudo/glr: ab337c0 | jnthn++ | src/core/List.pm:

[14:20] <dalek> rakudo/glr: Re-implement List.reverse.

[14:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ab337c0a30

[14:27] *** espadrine_ joined
[14:28] *** virtualsue left
[14:29] <nine> Now that's a somewhat mundane reason :)

[14:31] <skids> jnthn: OK, looks like unshift got a different implementation.  Should I bother submitting a PR to remove the "unshift to infonite" tests, or are we keeping them for now?

[14:31] <yoleaux> 09:07Z <jnthn> skids: Left some comments on the PR

[14:32] <dalek> rakudo/glr: 5012b16 | jnthn++ | src/core/Range.pm:

[14:32] <dalek> rakudo/glr: Iteration of 1..* ranges.

[14:32] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5012b16fc5

[14:33] *** khw joined
[14:33] *** tinyblak left
[14:33] <jnthn> skids: I think they can go away

[14:33] <jnthn> Doesn't make sense to me

[14:33] *** jkva left
[14:34] <jnthn> Feels like symmetry for the sake ofit

[14:34] <skids> Or just someone cut and pasted push :-)

[14:36] <jnthn> Or that ;)

[14:36] *** lucasb joined
[14:36] <nine> jnthn: 408/1032 test files fail. We're well past half of them passing :)

[14:37] <jnthn> o.O

[14:37] <jnthn> Not Bad.

[14:37] <dalek> perl6-roast-data: d2738ce | coke++ | / (9 files):

[14:37] <dalek> perl6-roast-data: today (automated commit)

[14:37] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d2738ceeca

[14:38] <skids> Is enough working for a camelia directive?

[14:41] <nine> I'd say definitely.

[14:41] <nine> Question is: how can one set up a branch in camelia?

[14:46] <jnthn> I think it's time to create a glr branch in spectest

[14:46] <jnthn> For one 'cus we need to start s/Parcel/List/ in the tests

[14:47] <skids> Oh, it looks like the slurpy unshift cnadidate didn't get done, just (@a).  Too much to be pulling off while at $DAYJOB through.

[14:47] <skids> Man I can't type yet today.

[14:49] <lucasb> I have seen "**@a" parameters around. What does it mean in GLR, since LoL seems to be gone?

[14:50] <jnthn> lucasb: A List that has one element per argument slurped

[14:54] <lucasb> jnthn: thanks

[14:54] <jnthn> (while *@foo still flattens)

[14:54] <jnthn> Oh, and

[14:54] <pyrimidine> .seen Ulti

[14:54] <yoleaux> I saw Ulti 29 Jul 2015 08:36Z in #perl6: <Ulti> lizmat++

[14:55] <jnthn> *@foo # array, flattens any incoming args

[14:55] <jnthn> **@foo # array, doesn't flatten

[14:55] <jnthn> *@foo is rw # list, flattens any incoming args

[14:55] <jnthn> **@foo is rw # list, doesn't flatten

[14:56] <lucasb> with 'is rw' it's a list and without it it's a array?

[14:57] *** sjn_phone joined
[14:57] <dalek> rakudo/glr: 113fc42 | jnthn++ | src/Perl6/ (2 files):

[14:57] <dalek> rakudo/glr: Fix optional array parameters.

[14:57] <dalek> rakudo/glr: 

[14:57] <dalek> rakudo/glr: Happily, the code gets a good bit simpler for these.

[14:57] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/113fc428c7

[14:57] <dalek> rakudo/glr: 55850a3 | jnthn++ | src/core/Any-iterable-methods.pm:

[14:57] <dalek> rakudo/glr: Start improving multi-arg-closure map.

[14:57] <dalek> rakudo/glr: 

[14:57] <dalek> rakudo/glr: But really needs more significant improvements yet.

[14:57] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/55850a3593

[14:57] <jnthn> lucasb: correct

[14:57] <jnthn> lucasb: Meaning that you can assign to any Scalar containers that were passed.

[14:59] <lucasb> ok, your explanation made it clearer to me, thanks

[15:03] <leont> Interesting, I guess I should use ** then

[15:05] *** sjn_phone left
[15:05] *** sjn_phone joined
[15:07] <jnthn> Wait, what, roast already has a glr branch?

[15:08] <jnthn> hm, it does too

[15:09] <nine> just found that out, too

[15:09] <nine> December 30th 2014

[15:09] <jnthn> Darn it, that branch has a load of merge conflicts

[15:10] <jnthn> I can't be arsed.

[15:10] <jnthn> I'll push it as glr-backup

[15:10] <jnthn> And push mine as glr

[15:10] <nine> It's just 3 commits

[15:10] <jnthn> Yeah. Somebody else can rescue them :)

[15:11] *** diana_olhovik left
[15:11] <dalek> roast/glr: dfcb18c | jnthn++ | / (19 files):

[15:11] <dalek> roast/glr: First round of Parcel removal from spectests.

[15:11] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/dfcb18c383

[15:11] <nine> I'm not sure if it's even worth it. 250 lines of diff, mostly about Parcel -> List

[15:12] <JimmyZ> and with another test

[15:13] <dalek> Heuristic branch merge: pushed 27 commits to rakudo/glr by jnthn

[15:13] <jnthn> I just merged latest nom into glr in Rakudo also

[15:13] <jnthn> So that the test branch and the nom branch have a consistent base, to avoid confusion.

[15:13] *** sjn_phone left
[15:14] <jnthn> (e.g. we aren't investigating failures because we missed commits from nom)

[15:14] <nine> No conflicts? I'm almost disappointed :)

[15:14] <ShimmerFairy> nine: I think people are knowingly leaving the pre-GLR list stuff alone :P

[15:14] <nine> ShimmerFairy: then they are wise :)

[15:15] <jnthn> nine: No, though an nqp::p6parcel got introduced, which I just commented out for now

[15:15] *** sjn_phone joined
[15:16] * lizmat can fix that

[15:16] <lizmat> (as I was the one introducing that)

[15:17] <jnthn> lizmat++

[15:18] * jnthn is mostly leaving things that feel LHF-ier by this point :)

[15:18] <jnthn> by the way, the Test::Util is-run now works again as of one of my recent patches

[15:18] <jnthn> More recent than nine++ did a spectest run

[15:18] *** [Sno] left
[15:18] <jnthn> So we'll have won back more test files through that

[15:19] *** [Sno] joined
[15:19] <dalek> rakudo/glr: 04fac5d | jnthn++ | src/core/Any-iterable-methods.pm:

[15:19] <dalek> rakudo/glr: Restore for @a -> { } giving an exception.

[15:19] <dalek> rakudo/glr: 

[15:19] <dalek> rakudo/glr: Fixes hang in dollar-underscore.t.

[15:19] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/04fac5d93b

[15:19] <nine> Does 'flat' flatten one level or deeply?

[15:20] <jnthn> It flattens non-itemized Iterables deeply

[15:20] <lizmat> so a Parcel is now a List, right ?

[15:20] <lizmat> so a sub called RETURN-PARCEL should probable be called RETURN-LIST now?

[15:21] *** virtualsue joined
[15:21] <jnthn> lizmat: Yeah, Parcel went away

[15:22] <jnthn> lizmat: And List is now somewhat like Parcel was and somewhat like List was :)

[15:22] <nine> 18/29 Inline::Perl5 test files pass with a simple tweak :)

[15:29] <dalek> rakudo/glr: 4d066dd | lizmat++ | src/core/Mu.pm:

[15:29] <dalek> rakudo/glr: Fix Mu.return, add Mu.return-rw for completeness

[15:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/4d066dd2ba

[15:32] <Ulti> pyrimidine I'm here what's up

[15:33] <dalek> rakudo/glr: 0488743 | jnthn++ | src/core/ (2 files):

[15:33] <dalek> rakudo/glr: Missing fmt methods.

[15:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0488743b86

[15:34] *** zakharyas left
[15:34] *** ecocode left
[15:35] *** ecocode joined
[15:35] <nine> perl6 -e 'sub test(*@args) { say @args.perl }; my %h = a => 1; test(%h);' gives me [:a(1)]

[15:35] <dalek> rakudo/glr: 6eee58c | lizmat++ | src/core/ (2 files):

[15:35] <dalek> rakudo/glr: Eradicate parcel from the group memory a bit

[15:35] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6eee58c54a

[15:36] <nine> jnthn: is [:a(1)] correct there?

[15:37] <dalek> roast/glr: 598b287 | jnthn++ | S (14 files):

[15:37] <dalek> roast/glr: Remove remaining easy mentions of Parcel.

[15:37] <dalek> roast/glr: 

[15:37] <dalek> roast/glr: All the others need a bit more attention.

[15:37] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/598b2874ac

[15:37] <jnthn> Yes, because a Hash is Iterable

[15:37] <lizmat> Looks like it flattened the hash into a list of pairs ?

[15:37] <jnthn> Correct

[15:38] <jnthn> m: sub test(*@args) { say @args.perl }; my %h = a => 1; test(%h);

[15:38] <camelia> rakudo-moar 98df93: OUTPUT«[:a(1)]<>␤»

[15:38] <jnthn> Same as today, fwiw 

[15:38] <lizmat> m: sub test(*@args) { say @args.perl }; my %h = a => 1, b => 2; test(%h)

[15:38] <camelia> rakudo-moar 98df93: OUTPUT«[:a(1), :b(2)]<>␤»

[15:38] <lizmat> yup

[15:39] <lizmat> :-)

[15:40] *** leont left
[15:40] <nine> m: sub test(*@args) { say @args.perl }; test({a => 1});

[15:40] <camelia> rakudo-moar 98df93: OUTPUT«[{:a(1)}]<>␤»

[15:40] <dalek> perl6-examples: 2374aa7 | paultcochrane++ | t/000-check-dependencies.t:

[15:40] <dalek> perl6-examples: Add File::Temp to required dependencies

[15:40] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/2374aa777f

[15:40] <dalek> perl6-examples: 6ee0141 | paultcochrane++ | lib/Pod/Htmlify.pm6:

[15:40] <dalek> perl6-examples: Use Text::VimColour only if it is available

[15:40] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/6ee01417c5

[15:40] <nine> Ah, there's the difference.

[15:40] <nine> test({a => 1}); gives me [{:a(1)}] on nom, but [:a(1)] on glr

[15:41] <jnthn> Yeah; [...] and {...} no longer implicitly .item

[15:41] <TimToady> yes, {} will flatten in a flattening context

[15:41] <TimToady> you'll note it doesn't put the <> anymore either

[15:41] * jnthn wonders how many files with issues we're down to by now... :)

[15:41] <lizmat> m: ({a => 42}).perl.say

[15:41] <camelia> rakudo-moar 98df93: OUTPUT«{:a(42)}␤»

[15:42] <lizmat> m: (my %h = a => 42).perl.say

[15:42] <camelia> rakudo-moar 98df93: OUTPUT«{:a(42)}<>␤»

[15:42] <lizmat> hmmm...

[15:42] <TimToady> (in glr)

[15:42] <nine> jnthn: running spectests

[15:42] <jnthn> S02-types/bool.t is the first test that hangs now

[15:42] <TimToady> (for arrays, haven't fixed hashes yet)

[15:42] <jnthn> nine: \o/

[15:43] <lizmat> jnthn: I think I can have a look at the bool hang

[15:43] <jnthn> lizmat: If you like :)

[15:43] * jnthn isn't short of other tests to look at :)

[15:44] <lizmat> Bool.pick(*) hangs

[15:44] <jnthn> Aha

[15:44] <pyrimidine> Ulti: just seeing whether you went to ISMB and /or BOSC

[15:44] <jnthn> But it jsut delegates to List.pick

[15:45] <jnthn> Which is commented out

[15:45] <lizmat> <a b>.pick(*) hangs

[15:45] <jnthn> Yeah, I see why

[15:45] <jnthn> Any.pick does self.list.pick

[15:45] <jnthn> But List.pick is not re-implemented after GLR 

[15:45] <nine> I wonder if it's better to debug test failures or to just hunt down GLR comments in the source.

[15:46] <jnthn> nine: I personally tend to prefer the first in so far as I then have a test case to see if I fixed things right :)

[15:46] *** virtualsue left
[15:46] <nine> jnthn: oh that's a good argument

[15:46] <lizmat> if List.pick doesn't exit, it reverts to Any.pick

[15:46] <jnthn> lizmat: Right, so it's an infinite recursion :)

[15:46] <jnthn> It keeps calling the same method again and again

[15:46] <lizmat> yup

[15:47] <nine> Infinite recursions tend to use quite a lot of memory

[15:47] <dalek> rakudo/glr: a9d5292 | TimToady++ | src/core/Hash.pm:

[15:47] <dalek> rakudo/glr: fix Hash.perl to emit {...} or ${...}

[15:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a9d5292feb

[15:47] <jnthn> And given calls on Moar are quite fast, soon you've got 3 gigabytes of stack frames :P

[15:47] <nine> The solution is obvious: we have to slow down MoarVM!

[15:47] <jnthn> m: ${ a => 1 }

[15:47] <camelia> rakudo-moar 98df93: OUTPUT«5===SORRY!5=== Error while compiling /tmp/AiMZqVc5jS␤Unsupported use of ${ a => 1 }; in Perl 6 please use $( a => 1 )␤at /tmp/AiMZqVc5jS:1␤------> 3${ a => 1 }7⏏5<EOL>␤»

[15:47] <jnthn> m: $[ 1, 2 ]

[15:47] <camelia> rakudo-moar 98df93: ( no output )

[15:47] <TimToady> that doesn't parse yet

[15:47] <jnthn> yeah :)

[15:48] <jnthn> I noticed that earlier today :)

[15:48] <TimToady> the $[] is a no-brainer; the ${} has to decide if it's a P5ism

[15:48] <TimToady> probably just detect it inside quotes, outside it's the itemized hash

[15:50] <TimToady> otoh, if we just ignore the P5ism, it'll usually get an Odd number of elements error

[15:51] <lizmat> jnthn: does gather / take work already ?

[15:51] <jnthn> lizmat: Very much so :)

[15:52] <jnthn> lizmat: I've got local patches that put back the no-arg .pick and .lazy so it'll at least be a dispatch failure now :)

[15:52] <nine> 352/1034 failing

[15:52] *** raiph joined
[15:52] <jnthn> m: 352/1034

[15:52] <camelia> rakudo-moar 98df93: ( no output )

[15:52] <jnthn> m: say 352/1034

[15:52] <camelia> rakudo-moar 98df93: OUTPUT«0.340426␤»

[15:52] *** cognominal joined
[15:52] <jnthn> That's a nice drop at least :)

[15:53] <ShimmerFairy> TimToady: if anything, it should probably be a P5ism worry (not a sorry), and go on being an itemized hash (keep in mind this comes from someone who has no need for the compiler telling her she accidentally did a P5-ism when she doesn't know any ☺)

[15:53] <dalek> rakudo/glr: f04771c | jnthn++ | src/core/List.pm:

[15:53] <dalek> rakudo/glr: Add back simple pick/roll in List.

[15:53] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f04771cbc6

[15:53] <lizmat> jnthn: looking forward to those patches: hope I can use them as inspiration to fix the rest

[15:53] <lizmat> thanks!

[15:54] *** diana_olhovik joined
[15:54] <jnthn> lizmat: Yeah, that was my cunning plan ;)

[15:55] <jnthn> TimToady: About the .infinite method, I'm wondering if we want to replace it with .lazy

[15:55] <jnthn> TimToady: Except uh

[15:55] <jnthn> TimToady: duh, that's a coercer :)

[15:56] <lizmat> jnthn: if $!todo.DEFINITE { ...   feels like a boilerplate that is going to be needed a lot

[15:56] <jnthn> lizmat: Yeah, we can factor that out to a private method.

[15:56] <jnthn> lizmat: The fail itself can't move

[15:56] <lizmat> oh?

[15:57] <jnthn> lizmat: fail is a form of return, if you put it in a private method then you no longer end up returning :)

[15:57] <jnthn> TimToady: But more general question: should we provide a way to introspect if things are "lazy"?

[15:58] <lizmat> yeah, got that: I was more thinking along either returning .elems or a Failure

[15:58] <lizmat> and then to something like

[15:58] <dalek> perl6-examples: 05086f7 | paultcochrane++ | .travis.yml:

[15:58] <dalek> perl6-examples: Don't install Text::VimColour as part of Travis build

[15:58] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/05086f7400

[15:58] <lizmat> .fail without self|private-method()

[16:00] <jnthn> lizmat: moment, trying a patch

[16:00] <dalek> perl6-examples: f7c8f63 | paultcochrane++ | .travis.yml:

[16:00] <dalek> perl6-examples: Use container-based builds on Travis

[16:00] <dalek> perl6-examples: 

[16:00] <dalek> perl6-examples: These are supposed to be faster than the legacy infrastructure.  We don't

[16:00] <dalek> perl6-examples: need sudo, so this is a good thing to do.

[16:00] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/f7c8f63ef2

[16:01] <dalek> rakudo/glr: a4cd69f | jnthn++ | src/core/List.pm:

[16:01] <dalek> rakudo/glr: Factor out some boilerplate in List.

[16:01] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a4cd69f995

[16:02] <jnthn> lizmat: There we are, that should make things neater :)

[16:03] <TimToady> jnthn: well, introspection is smelly, but optimizers have do smelly things

[16:04] <jnthn> TimToady: It's actual not for optimization at all

[16:04] <jnthn> TimToady: It's that things want to refuse to work on lazy things rather than nomming all the memory/CPU

[16:04] <jnthn> TimToady: The optimization stuff is all within the iterator pipeline

[16:08] <jnthn> TimToady: I think with so many things returning Seq, we're going to run into a lot of issues with folks wanting to do things like if %fail.keys[0] { ... }

[16:08] <jnthn> TimToady: I'm wondering if we do want to make indexing delegating to the .list on such a thing...I'm reluctant, but it's perhaps too surprising if not

[16:10] <jnthn> (You have to write %fail.keys.list[0] at this point)

[16:10] <jnthn> The alternative is the monotonic thing you mentioned before

[16:11] <jnthn> But that means more postcircumfix:<[ ]> candidates

[16:12] <jnthn> So maybe we're better of just memoizing the Seq and indexing that, and we can provide something else for picking out indices that match a pattern

[16:13] <jnthn> In a "streaming" way

[16:15] <lizmat> jnthn: wouldn't "is-lazy" have a use for ecosystem modules as well ?

[16:16] <jnthn> lizmat: That's what I was asking. I just...read code we had that used .infinite and hated it.

[16:16] <jnthn> lizmat: The slicing used it and it was a horrobile slow mess.

[16:17] <lizmat> jnthn: completely and utterly agree  :-)

[16:17] <jnthn> lizmat: I disocvered @a[1..2] went 8 levels of iterators deep o.O

[16:17] <jnthn> Re-worked it a good bit by now :)

[16:18] <lizmat> jnthn: yeah, I know...   my previous attempts at reducing that, always broke some obscure spec tests  :-(

[16:18] <jnthn> Anyway, don't object to an is-lazy or similar, just noting that I've seen .infinite be mis-used as much as well-used :)

[16:18] <jnthn> lizmat: Look how many mine have broken :D

[16:18] <lizmat> yeah.. it's not fair!  :-)

[16:18] <jnthn> Anyways, I need to be afk for a little :)

[16:19] <jnthn> bbl

[16:23] *** pmurias joined
[16:23] <pmurias> hi

[16:25] <Ulti> pyrimidine: yeah I went to ISMB it was really good

[16:31] <JimmyZ> .tell jnthn looks like merging nom into glr loosed some commits, at least my one.

[16:31] <yoleaux> JimmyZ: I'll pass your message to jnthn.

[16:33] <lizmat> JimmyZ: lose commits in glr, or in nom?

[16:39] <psch> 83e91a58 breaks the r-j build, with "java.lang.RuntimeException: Cannot access a reference attribute as a native attribute"

[16:39] <psch> that's as much as git bisect could tell me, i'm at a loss for the why though

[16:40] <lizmat> hmmm... fixing List.pick now hangs in the optimizer while building  :-(

[16:41] *** khw left
[16:42] *** coffee` left
[16:42] *** coffee` joined
[16:44] <psch> the commit in question moves $!why and the set_docee code from Routine to Block

[16:44] *** ecocode left
[16:44] <JimmyZ> lizmat: in glr

[16:44] <psch> but the RTE comes from Attribute.inlined

[16:45] <lizmat> the one that I merged ?

[16:45] <JimmyZ> the other one 

[16:45] <JimmyZ> #492

[16:46] *** diana_olhovik left
[16:48] <JimmyZ> hmm, I think it did not get merged

[16:49] <lizmat> github says it did

[16:49] <lizmat> but it was for nom?

[16:49] <lizmat> so maybe that was post jnthn's merge of nom?

[16:51] <psch> i think jnthn didn't have his local glr up to date

[16:51] <psch> err

[16:51] <psch> *local nom

[16:51] <psch> but that's assuming much :)

[16:52] <dalek> rakudo/glr: b3d4139 | (Jimmy Zhuo)++ | src/ (2 files):

[16:52] <dalek> rakudo/glr: declare notandthen in grammar too

[16:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b3d41396f0

[16:52] <dalek> rakudo/glr: 141eeab | peschwa++ | src/ (2 files):

[16:52] <dalek> rakudo/glr: Merge pull request #492 from zhuomingliang/nom

[16:52] <dalek> rakudo/glr: 

[16:52] <dalek> rakudo/glr: Merged #492.

[16:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/141eeab710

[16:52] <dalek> rakudo/glr: 3043568 | lizmat++ | src/ (2 files):

[16:52] <dalek> rakudo/glr: Merge branch 'nom' into glr

[16:52] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3043568e71

[16:52] <lizmat> yup  :-)

[16:53] <JimmyZ> good night :)

[16:55] <lizmat> JimmyZ: good night!

[16:56] <lizmat> m: Bool.roll(*).[^10].elems   # so this is verboten from now on?

[16:56] <camelia> rakudo-moar 98df93: ( no output )

[16:56] <lizmat> m: say Bool.roll(*).[^10].elems   # so this is verboten from now on?

[16:56] <camelia> rakudo-moar 98df93: OUTPUT«10␤»

[16:56] *** pierrot_ is now known as pierrot

[16:56] <lizmat> $ 6 'Bool.roll(*).[^10].elems'

[16:56] <lizmat> Cannot index a Seq; coerce it to a list or assign it to an array first

[16:56] *** dakkar left
[16:58] <lizmat> feels to me this is an idiom that many veteran Perl 6 user appreciate

[16:58] *** pmurias left
[16:59] <dalek> rakudo/glr: 3534431 | lizmat++ | src/core/List.pm:

[16:59] <dalek> rakudo/glr: Initial stab at unbreaking List.pick/roll

[16:59] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/353443195e

[17:00] <nine> lizmat: I think that's what jnthn was pondering in http://irclog.perlgeek.de/perl6/2015-08-13#i_11052197

[17:01] *** xinming left
[17:01] *** domidumont joined
[17:03] *** sjn_phone left
[17:04] <dalek> rakudo/glr: eb9277c | TimToady++ | src/Perl6/ (2 files):

[17:04] <dalek> rakudo/glr: parse $[1,2,3] and ${ a => 42 }

[17:04] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/eb9277c422

[17:05] <lizmat> m: my @a = (1..Inf)   # hangs on glr

[17:05] <camelia> rakudo-moar 98df93: ( no output )

[17:05] <lizmat> m: my @a = 1..Inf   # also hangs on glr

[17:05] <camelia> rakudo-moar 98df93: ( no output )

[17:06] <dalek> rakudo/glr: 64c3661 | (Stefan Seifert)++ | src/core/Any-iterable-methods.pm:

[17:06] <dalek> rakudo/glr: Fix %h.sort(*.key) returning a list of keys only

[17:06] <dalek> rakudo/glr: 

[17:06] <dalek> rakudo/glr: Method sort was missing the transformation back to the original iteration

[17:06] <dalek> rakudo/glr: values.

[17:06] <dalek> rakudo/glr: This naive fix iterates twice. May be faster to replace the push-until-lazy

[17:06] <dalek> rakudo/glr: by a hand coded loop to avoid this.

[17:06] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/64c36615ee

[17:06] *** jkva joined
[17:06] <TimToady> presumably the Inf isn't marking it lazy

[17:06] <nine> jnthn: ^^^ not the most elegant fix, but it works

[17:07] * lizmat tries to get some sleep again

[17:21] *** _itz_ joined
[17:23] *** virtualsue joined
[17:23] *** jkva left
[17:23] *** _itz left
[17:25] *** diana_olhovik_ joined
[17:29] *** kurahaupo joined
[17:32] *** kurahaupo left
[17:34] *** [TuxCM] joined
[17:35] *** lucasb left
[17:37] *** sjn_phone joined
[17:41] *** cognominal left
[17:41] *** jjido joined
[17:41] *** rurban left
[17:56] *** llfourn left
[18:05] <dalek> rakudo/glr: f8956ce | (Stefan Seifert)++ | src/core/Exception.pm:

[18:05] <dalek> rakudo/glr: Bring back "Undeclared routine" messages

[18:05] <dalek> rakudo/glr: 

[18:05] <dalek> rakudo/glr: Suggestions still broken however.

[18:05] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f8956ce069

[18:07] *** espadrine_ left
[18:11] *** llfourn joined
[18:11] *** lizmat_ joined
[18:14] *** lizmat left
[18:16] *** llfourn left
[18:22] <hoelzro> m: #|(comment) class C { ... }; #|(another) class C{}; say(C.WHY)

[18:22] <camelia> rakudo-moar 98df93: OUTPUT«another␤»

[18:22] <FROGGS_> I think I finally know why RT #125729 happens...

[18:22] *** FROGGS_ is now known as FROGGS

[18:23] <hoelzro> how should declarative comments work with forward decls?  should that test above print a warning, or somehow reconcile the two declarative comments?

[18:23] <FROGGS> when we use NQPHLL with an export sub, we see symbols from Perl6::Grammar.... and then we export these to userland, which clash with the NQPHLL there

[18:25] <FROGGS> hoelzro: how about 'Too late to attach comment, a previous statement already attached one.' for the second attempt

[18:25] <hoelzro> FROGGS: that would be consistent with how is repr works with forward decls

[18:26] <FROGGS> ohh, nice :o)

[18:26] <FROGGS> then I like it even more :o)

[18:26] <jnthn> FROGGS: Oddness; aren't they the same NQPHLL symbols, and if so how come they come out as identical and instead report a conflict?

[18:26] <yoleaux> 16:31Z <JimmyZ> jnthn: looks like merging nom into glr loosed some commits, at least my one.

[18:26] <jnthn> You can't lose commits with git... :P

[18:27] <jnthn> But yeah, I merged something just behind latest.

[18:27] <jnthn> Prolly thought origin/nom and typed nom.

[18:27] <nine> jnthn: any idea why https://github.com/rakudo/rakudo/commit/f8956ce069#diff-69f510e10ab6ee1e164e5d37eb0cc00aR773 happens?

[18:27] <FROGGS> jnthn: it reports a conflict, since both HLL's arnt identical for some reason

[18:28] <jnthn> FROGGS: Yes, the "some reason" is what's confusing me :)

[18:28] <FROGGS> jnthn: there nqp::where's are not the same

[18:28] <FROGGS> their*

[18:29] <FROGGS> first we merge NQPMatch and NQPCursorRole just fine, and then explode for HLL

[18:29] <jnthn> o.O

[18:30] <FROGGS> and the only reason for that might be the fact that we use HLL::Grammar etc in Perl6::Grammar

[18:31] <FROGGS> I first thought me might want to force another context (like the one the sub EXPORT is lexically in), but that would render slangs rather useless

[18:31] <FROGGS> Or.... I am talking rubbish here :o)

[18:31] <jnthn> nine: Can't spot why, no

[18:31] <jnthn> FROGGS: One other thought

[18:32] <jnthn> FROGGS: We do go to some effort to merge symbol tables in ModuleLoader

[18:32] <jnthn> FROGGS: Though...not sure that'd be to blame either

[18:32] <jnthn> FROGGS: Are the types identical?

[18:32] <jnthn> Uh, that was unclear

[18:32] <FROGGS> hehe

[18:32] <jnthn> Do they have the same meta-object?

[18:33] <FROGGS> their HOW?

[18:33] <jnthn> yeah

[18:33] <dalek> rakudo/glr: 1fb43e9 | jnthn++ | src/core/Range.pm:

[18:33] <dalek> rakudo/glr: Fix 'my @a = 1..*;' hang reported by lizmat++.

[18:33] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1fb43e981f

[18:34] <jnthn> nine: Are you looking deeper at it, or should I?

[18:35] <nine> jnthn: I've run out of ideas when I pushed that commit. All my debugging foo told me that it's an ordinary List containing an ordinary Str and everything works just fine when I run the same code outside the Exception handling

[18:36] <jnthn> nine: OK, will put on my todo list

[18:36] <nine> jnthn: thanks

[18:36] <nine> At least we got the exception message back. That already helped me.

[18:37] <jnthn> The sort patch is close but you can't safely call as-iterable(iter).iterator twice reliably

[18:37] <nine> darn

[18:37] <jnthn> Will fix

[18:37] <nine> so replace the push-until-lazy by a loop?

[18:37] *** rindolf left
[18:39] *** mr-foobar left
[18:40] *** telex left
[18:40] *** cognominal joined
[18:41] <FROGGS> jnthn: their HOW.name is also HLL

[18:41] <jnthn> FROGGS: .HOW.HOW.name

[18:41] <jnthn> FROGGS: I'm wondering if we somehow ended up with one coerced to a Perl 6 PackageHOW or so

[18:41] <FROGGS> HOWly HOW

[18:42] <jnthn> ;)

[18:42] *** telex joined
[18:43] <FROGGS> jnthn: both are KnowHOW :/

[18:44] <nine> jnthn: what do we need TypedHash::pair and friends for? Can't we just remove them to use EnumMap's implementations? Seems to work in a first test and I don't know why iterators are affected by the type restriction.

[18:47] *** sjn_phone left
[18:47] *** sjn_phone joined
[18:47] <jnthn> nine: I think it's needed for object hashes

[18:49] <dalek> rakudo/glr: e417fef | jnthn++ | src/core/Any-iterable-methods.pm:

[18:49] <dalek> rakudo/glr: Fix sort to not iterate source twice.

[18:49] <dalek> rakudo/glr: 

[18:49] <dalek> rakudo/glr: This would die if it was a Seq.

[18:49] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e417fef19f

[18:51] *** sjn_phone left
[18:52] <nine> m: say classify * % 2 == 0, 1, 2, 3, 4, 5, 6;

[18:52] <camelia> rakudo-moar 98df93: OUTPUT«False => 1 3 5, True => 2 4 6␤»

[18:53] <nine> jnthn: what's an object hash? :)

[18:55] <FROGGS> ohh, HLL itself is just a stub package...

[18:55] <jnthn> nine: A hash whose keys are objects, not strings

[18:55] <jnthn> my %h{Any}

[18:57] *** notch_ left
[18:57] <nine> Ah, ok, I think I understand TypedHash's code now.

[18:59] <tadzik> perl6 docs are so happy

[19:00] <tadzik> returns Proc:D

[19:00] <tadzik> :D

[19:00] <nine> So I guess pairs would have to iterate over $!keys and fetch the corresponding value via AT-KEY

[19:00] <tadzik> "it returns Proc. LOL"

[19:00] <tadzik> it keeps being funny

[19:00] <jnthn> nine: I think we did something like that in the HashIter before, yeah

[19:00] <jnthn> nine: Could check HashIter in nom for inspiration... :)

[19:00] <nine> jnthn: on it :0

[19:01] <jnthn> OK

[19:01] * jnthn is working on splice

[19:03] <jnthn> Which apparenlty sort of worked on lazy things for weird not really right reasons o.O

[19:06] * [Coke] fixes his crazy layover problems and gets a nonstop flight for cheaper. Travel is crazy. :P

[19:07] *** jjido left
[19:07] *** Begi joined
[19:07] <Begi> m: my @a = 0..*; say infinite(@a);

[19:07] <camelia> rakudo-moar 98df93: OUTPUT«5===SORRY!5=== Error while compiling /tmp/XCVMpqBrH7␤Undeclared routine:␤    infinite used at line 1␤␤»

[19:08] *** sjn_phone joined
[19:08] *** Begi left
[19:11] <dalek> rakudo/glr: 3d5bb6a | jnthn++ | src/core/Array.pm:

[19:11] <dalek> rakudo/glr: Get splice working again.

[19:11] <dalek> rakudo/glr: 

[19:11] <dalek> rakudo/glr: I don't really understand how the previous implementation got laziness

[19:11] <dalek> rakudo/glr: rightish at all, but this should handle things better.

[19:11] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3d5bb6a3f7

[19:11] *** sjn_phone left
[19:13] *** sjn_phone joined
[19:14] <jnthn> wtf

[19:14] <jnthn> is( (1...Inf).elems, Inf, "elems" );

[19:14] <jnthn> No way is that going to work.

[19:14] <jnthn> Just...no.

[19:15] <FROGGS> :o)

[19:15] <[Coke]> m: say (1...Inf).elems

[19:15] <camelia> rakudo-moar 98df93: OUTPUT«Inf␤»

[19:16] <jnthn> I'm morbidly curious what trickery happened to make it "work" in nom...

[19:16] <nine> Yes, we can run the Infinite loop in finite time ;)

[19:16] <geekosaur> presumably checked for Inf being an endpoint

[19:16] <[Coke]> presumably checking the endpoint to see if it's Inf.

[19:16] * [Coke] is too slow.

[19:17] <jnthn> m: say (1...Inf).WHAT

[19:17] <camelia> rakudo-moar 98df93: OUTPUT«(List)␤»

[19:17] <jnthn> But it was a gatheriter embedded in a list...

[19:17] <geekosaur> which of ocuese only works if explicitly specified like that

[19:17] <[Coke]> m: say (1,2, * * *...*).elems

[19:17] <camelia> rakudo-moar 98df93: OUTPUT«Inf␤»

[19:17] <jnthn>         # Get as many elements as we can.  If gimme stops before

[19:17] <jnthn>         # reaching the end of the list, assume the list is infinite.

[19:17] <jnthn>         my $n := self.gimme(*);

[19:17] <jnthn>         nqp::defined($!nextiter) ?? Inf !! $n

[19:18] <[Coke]> m: say (1,2, * * *...* > 10**100).elems

[19:18] <camelia> rakudo-moar 98df93: OUTPUT«15␤»

[19:18] <[Coke]> m: say (1,2, * * *...* < 10**100).elems

[19:18] <camelia> rakudo-moar 98df93: OUTPUT«1␤»

[19:18] * [Coke] doesn't know, but won't be sad to lose that.

[19:18] <jnthn> heh

[19:18] <jnthn> And a few lines of code above:

[19:18] <jnthn> multi method Int(List:D:)     { self.elems }

[19:19] <jnthn> In today's example of "you think that's cute today"...

[19:20] <jnthn> So yeah, I could easily re-create it

[19:20] <jnthn> But

[19:20] *** sjn_phone left
[19:20] *** sjn_phone joined
[19:20] <jnthn> my @a = lazy 1..5; say @a.elems; # This'll be Inf too :)

[19:20] <jnthn> So let's not

[19:21] <FROGGS> .elems should probably throw when the list is known to be infinite

[19:21] *** Guest92786 is now known as ponbiki

[19:21] <jnthn> We *never* know it to be infinite, only that it's lazy and so may not terminate

[19:21] <jnthn> That's why I've been tyring to get us away from the whole "infinite" language.

[19:21] *** domidumont left
[19:22] <jnthn> "Is this thing known to demand to be lazily evaluated" is what we can reliably know

[19:22] <FROGGS> but elems is always eager, no?

[19:23] <jnthn> Right, today it really will try to evaluate the lot

[19:23] <jnthn> We can make .elems throw on something that demands lazy evaluation.

[19:23] <jnthn> I guess .eager.elems would be the escape hatch

[19:24] <FROGGS> ohh, sounds good

[19:24] *** sjn_phone left
[19:24] *** sjn_phone joined
[19:25] *** sjn_phone left
[19:25] *** sjn_phone joined
[19:26] *** bin_005 joined
[19:28] *** xinming joined
[19:29] <dalek> rakudo/glr: a6d22a7 | (Stefan Seifert)++ | src/core/Hash.pm:

[19:29] <dalek> rakudo/glr: Implement TypedHash::pairs

[19:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a6d22a7ac3

[19:29] <dalek> rakudo/glr: 60397f8 | (Stefan Seifert)++ | src/core/Hash.pm:

[19:29] <dalek> rakudo/glr: Bring back classify-list

[19:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/60397f84c2

[19:32] <jnthn> \o/

[19:33] <dalek> Inline-Perl5/glr: 8691707 | (Stefan Seifert)++ | / (4 files):

[19:34] <dalek> Inline-Perl5/glr: Adjust to the post GLR world

[19:34] <dalek> Inline-Perl5/glr: review: https://github.com/niner/Inline-Perl5/commit/8691707eae

[19:34] <dalek> Inline-Perl5/glr: fde9468 | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[19:34] <dalek> Inline-Perl5/glr: Seem to need a sink() on Perl5Parent now as well

[19:34] <dalek> Inline-Perl5/glr: review: https://github.com/niner/Inline-Perl5/commit/fde9468a95

[19:34] <nine> The only failing test in Inline::Perl5 is the one requiring File::Temp :)

[19:34] *** beastd joined
[19:34] *** espadrine_ joined
[19:34] <nine> jnthn: if you deem my pairs implementation sane, I can have a look at the other iterators

[19:35] *** sjn_phone left
[19:36] <jnthn> nine: It's wrong, for a subtle reason

[19:36] <jnthn> A class is not a closure

[19:37] <jnthn> So the references in the class to $storage and $class won't work out

[19:37] <jnthn> (If you were to iterate two typed hashes at the same time, for example)

[19:38] <jnthn> So they need to be declared in the iterator class

[19:38] <nine> Darn again

[19:38] <jnthn> And set in its new

[19:38] <jnthn> Other than that, it looks good

[19:40] <nine> Can I just use hash.WHAT there instead of $class?

[19:40] <nine> Or is there another way to get to the role's $?CLASS?

[19:42] <jnthn> I'd pass it in, otherwise one day somebody does a mixin to a typed hash and then sends us a bug report...

[19:43] <nine> Ah man, I'm just too stupid. Of course I can control the caller of my constructor.

[19:49] *** Begi joined
[19:49] <dalek> rakudo/glr: 4cfb0ff | jnthn++ | src/core/List.pm:

[19:49] <dalek> rakudo/glr: Get infix:<X> back in shape.

[19:49] <dalek> rakudo/glr: 

[19:49] <dalek> rakudo/glr: Also made it work on iterables, so it can potentially use less memory.

[19:49] <dalek> rakudo/glr: Can probably further simplify it now that there's less flattening.

[19:49] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/4cfb0ff75a

[19:51] <Begi> m: my @a = 1, 2, 3; say @a.infinite; #Should return False ?

[19:51] <camelia> rakudo-moar 98df93: OUTPUT«False␤»

[19:52] <Begi> Oups, I haven't use the updated version. Sorry

[19:54] *** [TuxCM] left
[19:58] *** virtualsue left
[19:59] *** yqt joined
[19:59] <FROGGS> jnthn: since HLL's HOW is a KnowHOW, it is a stub, right? like Perl6::Metamodel::PackageHOW is a stub?

[19:59] <jnthn> FROGGS: Yes

[19:59] <jnthn> That's the idea

[19:59] <FROGGS> k

[20:00] <FROGGS> then I have an idea

[20:00] <dalek> rakudo/glr: bd5fbb4 | jnthn++ | src/core/Range.pm:

[20:00] <dalek> rakudo/glr: Toss code slowly being moved into iterator.

[20:00] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/bd5fbb4117

[20:00] <dalek> rakudo/glr: 55f2deb | jnthn++ | src/core/Range.pm:

[20:00] <dalek> rakudo/glr: Add missing Range.Str.

[20:00] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/55f2deba88

[20:02] *** zakharyas joined
[20:03] <FROGGS> yay, simple fix is simple :o)

[20:06] *** kaare_ left
[20:06] <dalek> rakudo/glr: 098932b | jnthn++ | src/core/List.pm:

[20:06] <dalek> rakudo/glr: Make .elems on a lazy list fail.

[20:06] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/098932b969

[20:06] <dalek> rakudo/glr: 4c09814 | jnthn++ | src/core/ (8 files):

[20:06] <dalek> rakudo/glr: s/X::Cannot::Infinite/X::Cannot::Lazy/

[20:06] <dalek> rakudo/glr: 

[20:06] <dalek> rakudo/glr: To get the language straightened out. Tweak the actual message too.

[20:06] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/4c09814432

[20:07] <dalek> roast/glr: e2692a8 | jnthn++ | S (3 files):

[20:07] <dalek> roast/glr: Chase X::Cannot::Infinite -> X::Cannot::Lazy.

[20:07] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/e2692a8ff8

[20:07] <jnthn> FROGGS: \o/

[20:12] *** llfourn joined
[20:14] <dalek> rakudo/nom: b89ff06 | FROGGS++ | / (2 files):

[20:14] <dalek> rakudo/nom: care about nqp stubs in global merging, fixes RT #125729

[20:14] <dalek> rakudo/nom: 

[20:14] <dalek> rakudo/nom: When we merge global symbols when importing from other compilation units, we go ahead

[20:14] <dalek> rakudo/nom: when we detect that the to be imported symbol and the already imported symbols are

[20:14] <dalek> rakudo/nom: just stubs. We did take care about these stubs coming from Perl 6 land, now we also

[20:14] <dalek> rakudo/nom: take care of stubs coming from NQP.

[20:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b89ff06533

[20:15] *** Begi left
[20:17] <dalek> rakudo/glr: 74a9c35 | (Stefan Seifert)++ | src/core/Hash.pm:

[20:17] <dalek> rakudo/glr: Fix TypedHash.pairs problems noted by jnthn++

[20:17] <dalek> rakudo/glr: 

[20:17] <dalek> rakudo/glr: jnthn> A class is not a closure

[20:17] <dalek> rakudo/glr: jnthn> So the references in the class to $storage and $class won't work out

[20:17] <dalek> rakudo/glr: jnthn> (If you were to iterate two typed hashes at the same time, for example)

[20:17] <dalek> rakudo/glr: jnthn> So they need to be declared in the iterator class

[20:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/74a9c35574

[20:17] <nine> jnthn: better? ^^^

[20:17] *** llfourn left
[20:18] *** bin_005 left
[20:19] <jnthn> nine: Looks so...I presume it works? :)

[20:19] <jnthn> But it does at least look correct :)

[20:19] <nine> jnthn: enough to get Inline::Perl5's tests going

[20:19] <jnthn> cool

[20:20] *** diana_olhovik_ left
[20:22] *** yqt left
[20:26] <RabidGravy> should I be running the tests of my modules that exercise Array -> CArray -> Array on this stuff or is it premature?

[20:26] <nine> RabidGravy: Inline::Perl5 already works, so I'd just go for it

[20:28] <dalek> rakudo/glr: 95934a0 | jnthn++ | src/core/Seq.pm:

[20:28] <dalek> rakudo/glr: Workaround for various gather/take bugs.

[20:28] <dalek> rakudo/glr: 

[20:28] <dalek> rakudo/glr: This in theory shouldn't be needed, and in practice is needed. The

[20:28] <dalek> rakudo/glr: reason probably lies deep in the bowels of code-gen, or deep in the

[20:28] <dalek> rakudo/glr: bowels of the interaction between the handler stack and continuations.

[20:28] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/95934a0f74

[20:29] <jnthn> nine: Are you going to do the typed hash kv iterator, ooc?

[20:30] <jnthn> The last test in S02-names-vars/signature.t blocks on that :)

[20:31] <dalek> rakudo/glr: feac38e | (Stefan Seifert)++ | src/core/Hash.pm:

[20:31] <dalek> rakudo/glr: Implement TypedHash.keys

[20:31] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/feac38e218

[20:31] <nine> jnthn: this an answer? ^^^

[20:32] <jnthn> Well, it shows the trajectory is right, even if not the position... :)

[20:32] <nine> I'm going in the order S09-hashes/objecthash.t requires

[20:32] <jnthn> aha, ok :)

[20:33] <jnthn> m: my @a; @a[2] = 42; say @a[0]:exists;

[20:33] <camelia> rakudo-moar 98df93: OUTPUT«False␤»

[20:34] <nine> Ok, but I really see no need for a values iterator. The one from EnumMap should do just fine.

[20:34] <jnthn> m: my @a; @a[2] = 42; say @a.grep({ say nqp::iscont($_) });

[20:34] <camelia> rakudo-moar 98df93: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[20:34] <jnthn> m: use nqp; my @a; @a[2] = 42; say @a.grep({ say nqp::iscont($_) });

[20:34] <camelia> rakudo-moar 98df93: OUTPUT«0␤0␤1␤(Any) (Any) 42␤»

[20:34] <jnthn> nine: +1

[20:35] <dalek> rakudo/glr: d733134 | (Stefan Seifert)++ | src/core/Hash.pm:

[20:35] <dalek> rakudo/glr: Inherit the TypedHash.values iterator from EnumMap

[20:35] <dalek> rakudo/glr: 

[20:35] <dalek> rakudo/glr: There's no difference between EnumMap/Hash and TypedHash for .values

[20:35] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d733134396

[20:39] <dalek> rakudo/glr: 24f0757 | jnthn++ | src/core/List.pm:

[20:39] <dalek> rakudo/glr: Fix iterating arrays with holes.

[20:39] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/24f0757c30

[20:40] *** yqt joined
[20:42] <nine> t/spec/S02-names-vars/signature.t ............................. ok

[20:42] *** bin_005 joined
[20:42] <FROGGS> nine++ I guess

[20:43] <dalek> rakudo/glr: 2d98c62 | (Stefan Seifert)++ | src/core/Hash.pm:

[20:43] <dalek> rakudo/glr: Implement TypedHash.kv

[20:43] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2d98c62390

[20:43] <dalek> roast/glr: 8103ae4 | jnthn++ | S02-types/array_extending.t:

[20:43] <dalek> roast/glr: This needs a flat.

[20:43] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/8103ae4519

[20:43] <dalek> roast/glr: ff190ce | jnthn++ | S02-types/array_ref.t:

[20:43] <dalek> roast/glr: Correct test for new flattening semantics.

[20:43] <dalek> roast/glr: 

[20:43] <dalek> roast/glr: Add a flat, and fix [[1]] which runs into the single value rule.

[20:43] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/ff190ce115

[20:43] <jnthn> nine++

[20:43] <nine> This is pure fun :)

[20:45] <nine> Alas I better join my girlfriend on the terrace and start winding down.

[20:46] <dalek> roast/glr: bb63a50 | jnthn++ | S02-types/assigning-refs.t:

[20:46] <dalek> roast/glr: More fixes for flattening/single arg rule.

[20:46] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/bb63a50336

[20:46] <jnthn> :)

[20:46] <jnthn> nine: Thanks for the commits!

[20:46] * jnthn is finding GLR much more fun now others are helping with it :)

[20:47] *** ssqq joined
[20:47] <tadzik> oh, it's like nom all over again :)

[20:48] <FROGGS> or like getting moar parse/run the setting :o)

[20:49] <ssqq> p6: 'a' ~~ / \w && <!alpha> /

[20:49] <camelia> rakudo-moar 98df93: ( no output )

[20:49] <nine> But probably with quicker progress :)

[20:51] <dalek> roast/glr: f7e41c5 | (Stefan Seifert)++ | S09-hashes/objecthash.t:

[20:51] <dalek> roast/glr: .list needed before indexing Seq

[20:51] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/f7e41c5b75

[20:51] <nine> With that ^^^ t/spec/S09-hashes/objecthash.rakudo.moar ...................... ok

[20:51] <nine> And now I'm really off :)

[20:52] <ssqq> if matched sth but need remove some rule, How to use it? / <match-rule> && <!remove_rule> / could not work

[20:52] *** llfourn joined
[20:54] *** zakharyas left
[20:55] <ssqq> token name { \w+ }; token reserved { < if when > }; say('if' ~~ / <name> && <!reserved> /).Str

[20:55] <ssqq> p6: token name { \w+ }; token reserved { < if when > }; say('if' ~~ / <name> && <!reserved> /).Str

[20:55] <camelia> rakudo-moar 98df93: OUTPUT«Potential difficulties:␤    Useless declaration of a has-scoped method in mainline (did you mean 'my token name'?)␤    at /tmp/tmpfile:1␤    ------> 3token 7⏏5name { \w+ }; token reserved { < if when␤    Useless declaration of a has-scoped me…»

[20:56] <jnthn> ssqq: If you use && the second thing has to match as many chars as the first

[20:56] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('if' ~~ / <name> && <!reserved> /).Str

[20:56] <camelia> rakudo-moar 98df93: OUTPUT«Nil␤»

[20:56] <jnthn> YOu just one <!reserved> <name>

[20:56] <jnthn> s/one/want/

[20:56] <jnthn> (! implies zero-width assertion)

[20:56] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('if' ~~ / <!reserved> && <name> /).Str

[20:56] <camelia> rakudo-moar 98df93: OUTPUT«Nil␤»

[20:57] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('if' ~~ / <name> /).Str

[20:57] <camelia> rakudo-moar 98df93: OUTPUT«｢if｣␤ name => ｢if｣␤»

[20:57] <hoelzro> jnthn: is the recommended way to help just to spectest on glr and see what's breaking?

[20:57] <jnthn> hoelzro: yes

[20:57] *** llfourn left
[20:57] <hoelzro> alright, that makes that easy =)

[20:57] <dalek> rakudo/glr: 6d3c8e0 | jnthn++ | src/core/Array.pm:

[20:57] <dalek> rakudo/glr: Re-instate BIND-POS in Array.

[20:57] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6d3c8e0c6e

[20:57] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('unless' ~~ / <!reserved> && <name> /).Str

[20:57] <camelia> rakudo-moar 98df93: OUTPUT«Nil␤»

[20:58] <jnthn> ssqq: You don't need &&

[20:58] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('unless' ~~ / <!reserved> <name> /).Str

[20:58] <camelia> rakudo-moar 98df93: OUTPUT«｢unless｣␤ name => ｢unless｣␤»

[20:58] *** kst`` is now known as kst

[20:59] *** skids left
[20:59] <jnthn> hoelzro: You may want to set ulimits and stuff; there's still the odd hang roaming around, and some of them have allocated memory at a wild rate. :)

[20:59] <ssqq> jnthn: what use of &&? I could not think what use of it

[20:59] <hoelzro> thanks for the warning!

[21:00] <jnthn> ssqq: When you want to check that a second thing matches exactly the same set of things as the first.

[21:00] <ssqq> p6: my token name { \w+ }; my token reserved { < if when > }; say('unless' ~~ / \w+ && <name> /).Str

[21:00] <camelia> rakudo-moar 98df93: OUTPUT«｢unless｣␤ name => ｢unless｣␤»

[21:00] <jnthn> ssqq: And it matters that they match the same number of chars

[21:01] *** darutoko left
[21:01] <ssqq> jnthn: thanks a lots

[21:02] <jnthn> Welcome :)

[21:03] <jnthn> hoelzro: The bag/set/mix and their hashy forms may not be overly bad to attack

[21:03] *** bin_005 left
[21:04] <jnthn> hoelzro: But pick what you feel like :)

[21:04] *** ssqq left
[21:05] <hoelzro> will do =)

[21:05] <dalek> rakudo/glr: 051c59d | jnthn++ | src/core/Array.pm:

[21:05] <dalek> rakudo/glr: Re-instate Array's DELETE-POS.

[21:05] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/051c59d9d9

[21:07] *** espadrine_ left
[21:09] <FROGGS> if $simple.rxtype eq 'literal' && $simple.rxtype ne 'ignorecase' && !$qast.negate { <--- that either does not make much sense or I am very sleepy

[21:10] *** Ice_Strike joined
[21:10] *** Ice_Strike left
[21:11] <FROGGS> probably a copy&pasto

[21:14] <jnthn> FROGGS: I'd bet the second rxtype should be subtype

[21:14] *** bin_005 joined
[21:14] <FROGGS> aye

[21:16] <FROGGS> and btw I think we need ops like nqp::uc_i and nqp::lc_i that work on ords

[21:17] *** ChoHag left
[21:17] <FROGGS> and perhaps make Regex.subtype a bitmask

[21:18] <dalek> roast/glr: a90201d | jnthn++ | S32-list/ (2 files):

[21:18] <dalek> roast/glr: Update to compare same type.

[21:18] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/a90201d303

[21:18] <jnthn> The trouble is, one code point doesn't always upper/lower case to one codepoint

[21:19] <FROGGS> hmmm

[21:22] <jnthn> I think we're meant to do ignorecase in terms of case folding though, not lc

[21:23] <FROGGS> I'm not sure I understand that

[21:23] <dalek> rakudo/glr: ec45d1a | jnthn++ | src/core/List.pm:

[21:23] <dalek> rakudo/glr: Try to get combinations/permutations working.

[21:23] <dalek> rakudo/glr: 

[21:23] <dalek> rakudo/glr: They don't quite seem to do the right thing, alas.

[21:23] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ec45d1ab9a

[21:23] <jnthn> Unicode defines uppercase, lowercase, titlecaae, and foldcase

[21:24] <FROGGS> foldcase...

[21:24] <FROGGS> I'll need to read more about that

[21:24] <FROGGS> ...tomorrowish

[21:24] <FROGGS> for now I am happy to pass along the information about ignorance to the NFA... :o)

[21:26] <jnthn> :)

[21:26] <jnthn> Yeah, I think I've done enough for today also

[21:27] <jnthn> Time to let the US and Asian shifts take over :)

[21:27] <FROGGS> *g*

[21:27] <FROGGS> gnight

[21:27] <jnthn> ooh, not to forget Australasia..

[21:27] <jnthn> :)

[21:27] <jnthn> 'night

[21:28] <hoelzro> Australasia: good album

[21:28] *** jjido joined
[21:28] <hoelzro> good night jnthn, FROGGS 

[21:36] *** muraiki left
[21:39] *** TEttinger joined
[21:43] <RabidGravy> erp

[21:46] <timotimo> o/

[21:51] *** yqt left
[21:54] *** smls joined
[21:56] <RabidGravy> 80 days of binge programming I think I may be getting a headache

[21:57] <colomon> This call only converts base-2 strings to numbers; value 01000001 is of type Int+{orig-string[Str]}, so cannot be converted!

[21:58] <colomon> hmmm

[21:58] <timotimo> now, if panda would work ... :)

[21:59] <timotimo> so someone's doing .WHAT === Int rather than ~~ Int?

[21:59] <smls> http://i.imgur.com/xd3FKqH.png  -- I continued tweaking the perl6.org mockup I started a few months ago. Made the big backgrounds less dark (based on feedback), and added shading, contours, and texturing. What do you think?

[22:01] <timotimo> i like the way it's going, but i'd prefer the texturing to be more subtle

[22:03] <smls> maybe

[22:06] <timotimo> neato, my animated_blocks.p6 now runs unmodified on glr

[22:06] <tadzik> smls: ooh, I like it

[22:08] <timotimo> http://t.h8.lv/p6bench/profile_animated_blocks_glr.html

[22:08] <RabidGravy> smls, purty.  Not partularly a fan of plum but it works ;-)

[22:08] *** beastd left
[22:09] <timotimo> ^- a happy-ning lack of reify and gimme calls

[22:09] <timotimo> very annoyingly, the number of gen2 roots for the gc keeps increasing

[22:10] <timotimo> i didn't want to check, but i assume it'll grow without bound :(

[22:20] *** bin_005 left
[22:22] *** zgrep joined
[22:26] <dalek> rakudo-star-daily: dee4f3c | coke++ | log/MoarVM- (5 files):

[22:26] <dalek> rakudo-star-daily: today (automated commit)

[22:26] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/dee4f3c8f9

[22:29] *** jferrero left
[22:32] *** smls_ joined
[22:32] *** smls left
[22:35] *** jferrero joined
[22:39] *** spider-mario left
[22:44] *** jjido left
[22:54] *** llfourn joined
[22:54] *** Psyche^ joined
[22:58] *** llfourn left
[22:58] *** Psyche^_ left
[22:59] <RabidGravy> bed I think

[23:00] *** skids joined
[23:04] *** RabidGravy left
[23:13] *** coffee` left
[23:28] *** ggoebel left
[23:49] *** smls_ left
