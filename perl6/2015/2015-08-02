[00:01] *** HoppingMadMan joined
[00:04] *** shinobi-cl_ joined
[00:04] <shinobi-cl_> Hi all...

[00:04] <smls_> Hi

[00:04] *** smls_ is now known as smls

[00:05] <shinobi-cl_> how can i create an array filled with the same value over and over? example, an array with 100 Int with value zero

[00:05] *** HoppingMadMan left
[00:05] <smls> my @a = 0 xx 100; say @a.perl

[00:05] <smls> m: my @a = 0 xx 100; say @a.perl

[00:05] <camelia> rakudo-moar d8fa56: OUTPUT¬´[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ‚Ä¶¬ª

[00:06] *** HoppingMadMan joined
[00:06] <shinobi-cl_> r: my @a = Nil xx 10; say @a.perl;

[00:06] <camelia> rakudo-{moar,jvm} d8fa56: OUTPUT¬´[Any, Any, Any, Any, Any, Any, Any, Any, Any, Any]<>‚ê§¬ª

[00:07] <smls> Note, however, that the expression on the left-hand-side of the xx operator is reevaluated each time

[00:07] <shinobi-cl_> Thanks smls!

[00:07] <smls> m: say rand xx 10;

[00:07] <BenGoldberg> m: say my @a = 0 x 100;

[00:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000‚ê§¬ª

[00:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´0.468089031244085 0.309870672209813 0.890902802842534 0.772970687409833 0.507221045662271 0.783112132530793 0.889978764459187 0.452996015354152 0.15961362780056 0.23165113780065‚ê§¬ª

[00:07] <BenGoldberg> m: say my @a = (0,)0 x 100;

[00:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/Pd0seky9LJ‚ê§Two terms in a row‚ê§at /tmp/Pd0seky9LJ:1‚ê§------> 3say my @a = (0,)7‚èè050 x 100;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§ ‚Ä¶¬ª

[00:07] <smls> so if its a non-constant expression, you may want to store it in a variable first and then do   $x xx 100

[00:08] <BenGoldberg> m: say my @a = (0,) x 100;

[00:08] <camelia> rakudo-moar d8fa56: OUTPUT¬´0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000‚ê§¬ª

[00:08] <BenGoldberg> Does [x] now only do string repetition?

[00:08] <smls> yes

[00:08] <smls> x always does string repetition; xx always does list repetition

[00:09] *** HoppingMadMan left
[00:10] <BenGoldberg> Is there a convenient and efficient way to do list repetition without repeatedly evaluating the lhs?

[00:10] <timotimo> if the lhs is compile-time constant or simple, it won't thunk

[00:10] <timotimo> or something like that

[00:10] <timotimo> what i mean is we have something in place in the hopes of making it smarter

[00:12] <BenGoldberg> m: say my @a = do { my $x = rand; $x xx 10 };

[00:12] <camelia> rakudo-moar d8fa56: OUTPUT¬´0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229 0.945652991137229‚ê§¬ª

[00:13] <BenGoldberg> m: say my @a = do { my \x = rand; x xx 5 };

[00:13] <camelia> rakudo-moar d8fa56: OUTPUT¬´0.0193072417998126 0.0193072417998126 0.0193072417998126 0.0193072417998126 0.0193072417998126‚ê§¬ª

[00:14] <smls> you can always define a    sub rep ($value, $n) { $value xx $n }

[00:15] <BenGoldberg> m: sub infix::<xxx>(\value, \n) { value xx n }; say rand xxx 4;

[00:15] <camelia> rakudo-moar d8fa56: OUTPUT¬´===SORRY!===‚ê§Name infix:: ends with '::' and cannot be used as a sub declaration‚ê§¬ª

[00:15] <BenGoldberg> m: sub infix<xxx>(\value, \n) { value xx n }; say rand xxx 4;

[00:15] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/N2VWU5of82‚ê§Missing block‚ê§at /tmp/N2VWU5of82:1‚ê§------> 3sub infix7‚èè5<xxx>(\value, \n) { value xx n }; say ra‚ê§    expecting any of:‚ê§        new name to be defined‚ê§¬ª

[00:15] <smls> timotimo (since you're here): Does this look like a sane thing to do? :

[00:15] <smls> subset StrOrArrayOfStr where Str | (Array & {.all ~~ Str});

[00:16] <smls> BenGoldberg: infix:<xxx> needs a colon :)

[00:17] <BenGoldberg> m: sub infix:<xxx>(\value, \n) { value xx n }; say rand xxx 4;

[00:17] <camelia> rakudo-moar d8fa56: OUTPUT¬´0.661307514012933 0.661307514012933 0.661307514012933 0.661307514012933‚ê§¬ª

[00:17] <BenGoldberg> m: sub infix:<xxx>(\value, \n) { value xx n }; say (rand, rand) xxx 4;

[00:17] <camelia> rakudo-moar d8fa56: OUTPUT¬´0.373813721034791 0.287736870594361 0.373813721034791 0.287736870594361 0.373813721034791 0.287736870594361 0.373813721034791 0.287736870594361‚ê§¬ª

[00:17] <BenGoldberg> \o/

[00:18] *** census left
[00:21] <timotimo> sorry, very distracted

[00:21] <smls> np

[00:23] <timotimo> seems like it'd be very tough on the performance, but it should work

[00:23] *** cognominal joined
[00:29] <smls> Iterable is a class rather than a role? Interesting.

[00:30] <TimToady> all bets are off after GLR

[00:31] <timotimo> every time you check, it'll return a different result what kind of thing it is

[00:31] <timotimo> "oh no, today iterable is a package again ... what should i do?!"

[00:32] <smls> .oO( class Foo does-or-is-or-whatever Iterable )

[00:32] *** vendethiel left
[00:33] <timotimo> does-or-is-or-trusts-or-augments ...

[00:33] *** ShimmerFairy left
[00:36] <TimToady> we might not even have an Iterable type

[00:36] <timotimo> we'll have a perl6 and a perl6-iterable instead

[00:37] * TimToady has flashbacks to incr-tcl

[00:37] <timotimo> increase the tclness of your system by 1 every time this gets executed

[00:38] <smls> TimToady: I expected Iterable to be a tag role to advertise "I have multiple elements and I implement .iterator, .list, keys & co to iterate them"

[00:39] <smls> like Positional is a tag role to advertise "I have multiple elementd and I implement .AT-KET, .ASSING-KEY, etc. to index them"

[00:39] <TimToady> we might well keep the type name, but we'll see what jnthn++ comes up with

[00:40] *** fling joined
[00:41] <timotimo> Iterobubble

[00:47] *** ShimmerFairy joined
[00:53] *** skids joined
[01:03] *** cognominal left
[01:10] *** vendethiel joined
[01:22] *** rmgk_ joined
[01:22] *** rmgk is now known as Guest74991

[01:22] *** Guest74991 left
[01:22] *** rmgk_ is now known as rmgk

[01:24] *** shinobi-cl_ left
[01:35] *** mr-foobar left
[01:36] *** mr-foobar joined
[01:36] *** Hor|zon joined
[01:37] *** raiph left
[01:39] <timotimo> who wants to write szabgab to improve his line use lib callframe(0).file.IO.dirname ~ '/lib';

[01:39] *** gfldex left
[01:41] *** Hor|zon left
[01:44] *** smls left
[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:51] *** llfourn joined
[01:51] *** HoppingMadMan joined
[01:56] *** llfourn left
[01:57] <timotimo> hm, $?FILE may be bad if the module's installed, no?

[02:00] *** ShimmerFairy left
[02:01] <skids> ugexe suggested this after a long discussion: http://irclog.perlgeek.de/perl6/2015-07-14#i_10891237

[02:06] <timotimo> but doesn't andthen not properly set $_?

[02:11] *** cognominal joined
[02:13] *** ShimmerFairy joined
[02:21] <skids> timotimo: Dunno, I haven't tried to use it yet.

[02:23] *** mr-foobar left
[02:24] *** mr-foobar joined
[02:25] *** vendethiel left
[02:26] <skids> https://gist.github.com/skids/c4a548c8e829cd4dd480 # Hopefully a useful resource for both sides of the "implicit *%_" debate

[02:45] *** mr-foobar left
[02:47] *** noganex_ joined
[02:49] *** noganex left
[03:00] *** Sgeo joined
[03:01] *** yqt left
[03:08] *** dj_goku_ left
[03:23] <ShimmerFairy> skids++  spotted just one typo: "wright a wrapper class"

[03:25] <skids> fixed.  thanks.  I have a buidin named "wright" at work so that polluted my muscle memory :-)

[03:25] <ShimmerFairy> skids: the only argument I think doesn't have any validity is the pro-*%_'s "But Perl 5 did it like this!". That's an argument that wouldn't work against a lot of P6's changes, and anyone who doesn't know P5 (such as myself) won't put much faith in the tradition argument wrt P6 :)

[03:25] <skids> *building

[03:26] <ShimmerFairy> skids: in reality, implicit *%_ doesn't affect my life so much that it'll upset me that it's around. I'm more bothered that it's a wildly inconsistent feature in the face of subs and the other kind of parameters, positionals.

[03:27] <ShimmerFairy> (The fact that it's under the heading "Interface Consistency" is hilarious.)

[03:29] *** laouji joined
[03:29] <skids> I'd be less averse to changing it if the change came with a promise that most docs showing how to do OO stuff included *%_ in examples so it felt "endorsed" to use it.

[03:31] <ShimmerFairy> Sure, I'm fine with encouraging the use of something that'll make your classes (allegedly) more robust. I just think it's a weird and unintuitive default :)

[03:33] <ShimmerFairy> skids: Freedom #2 sounds reasonable, however I could argue against it. Rapid prototyping is one thing, being allowed to be sloppy is another. After all, there's a reason 'strict' and 'warnings' are on by default in P6 :P

[03:36] *** dmitri joined
[03:37] *** Hor|zon joined
[03:38] <skids> I haven't felt chafed by the existing strictures and thankfully "my" is huffmanized.  Though lately the idea that Failures should complain when GCd has been irking me.

[03:38] <ShimmerFairy> m: class C { method mypush { say %_.perl } }; C.mypush(1=>2)  # huh, I wasn't expecting this

[03:38] <camelia> rakudo-moar d8fa56: OUTPUT¬´Too many positionals passed; expected 1 argument but got 2‚ê§  in method mypush at /tmp/yK1XFU8qt4:1‚ê§  in block <unit> at /tmp/yK1XFU8qt4:1‚ê§‚ê§¬ª

[03:38] <ShimmerFairy> m: class C { method mypush() { say %_.perl } }; C.mypush(a=>2)

[03:38] <camelia> rakudo-moar d8fa56: OUTPUT¬´{:a(2)}<>‚ê§¬ª

[03:39] <skids> and:

[03:39] <skids> m: class C { method mypush() { say %_.perl } }; C.mypush("a"=>2)

[03:39] <camelia> rakudo-moar d8fa56: OUTPUT¬´Too many positionals passed; expected 1 argument but got 2‚ê§  in method mypush at /tmp/u11N0uZ0wT:1‚ê§  in block <unit> at /tmp/u11N0uZ0wT:1‚ê§‚ê§¬ª

[03:40] <ShimmerFairy> _that's_ what I was expecting (my second line).  (And a good demo of why Pairs and nameds shouldn't be conflated in syntax; hell, I got confused by it just now, and I've been using P6 for years!)

[03:41] <skids> Though the first line is debatably a bug since "1" is a valid string.

[03:41] *** Hor|zon left
[03:41] <ShimmerFairy> m: my %hash; %hash.push(a=>42); say %hash.perl; # this is my bigger gripe concerning nameds; removal of *%_ would only make it a non-silent fail

[03:41] <camelia> rakudo-moar d8fa56: OUTPUT¬´{}<>‚ê§¬ª

[03:42] <dalek> ecosystem: 96747e1 | (Sterling Hanenkamp)++ | META.list:

[03:42] <dalek> ecosystem: Adding IO::Glob to the Perl6 ecosystem

[03:42] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/96747e1f37

[03:42] <ShimmerFairy> skids: but you can't do  sub foo(:$1)  as a named, so ~clearly~ it's always a positional Pair param.

[03:43] <skids> Ok I'll buy that.

[03:44] <skids> The fact that a => 1 works is also a P5 legacy thing.

[03:45] <ShimmerFairy> skids: I'm personally with lizmat in thinking that the conflation of named parameters and Pairs is a terrible mistake on P6's part.

[03:46] <skids> I've rarely wanted to use pairs as items personally.

[03:46] <ShimmerFairy> sure, there are at least a few legacy P5 things. Doesn't mean that's a solid argument though :P (I think it'd be nice if it quoted the right side too, but maybe that's just me).

[03:48] <ShimmerFairy> skids: At the very least though, there should be a way to uniquely refer to nameds xor Pairs syntactically.

[03:49] <skids> Pair.new?

[03:49] <skids> I don't really view an itemized Pair as a thing useful enough to deserve special syntax.

[03:50] <ShimmerFairy> Pair.new doesn't do anything, surprisingly

[03:50] <skids> m: Pair.new(:key<a>,:value<b>).say

[03:50] <camelia> rakudo-moar d8fa56: OUTPUT¬´a => b‚ê§¬ª

[03:51] <ShimmerFairy> o_o

[03:51] <skids> I wouldn't be opposed to Pair having a positional .new multi, personally.

[03:52] <zostay> i'm in favor of eliminating implicit *%_ because it would greatly simplify ArrayHash and Hash::MultiValue... working out all the little fiddly bits and dealing with that always being implied has been a major pain

[03:52] <ShimmerFairy> That's a horrendous way to have a unique Pair, esp. when you have syntax that _should_ do it already (as it is, you have to hope the key in a fat-arrow Pair isn't an ident literal)

[03:52] *** llfourn joined
[03:52] <zostay> i don't really understand why *%_ keeps on existing with an explicit signature when *@_ goes away

[03:53] <skids> Well, from my perspective the syntax is there for parameters and Pairs are just hitchiking/an implementation detail leaking through.

[03:53] <ShimmerFairy> skids: and even then, there may be an unambiguous way to specify a Pair, but there still isn't any such thing for nameds.

[03:53] <zostay> seems like if i'm being explicit, i should need to add my own *%_ if i want it still

[03:53] <zostay> my 2¬¢

[03:55] <skids> I thought colonpair was unambiguously a named in an arglist?

[03:56] *** llfourn left
[03:57] <dmitri> Survey: what is the extension you use for Perl 6 scripts: .p6, .pl6, .pl, none at all, or something else?

[03:57] <skids> pm6 personally ut few others do.

[03:58] <dmitri> I am adding Perl 6 support to ctags and it's important to it (that's the normal way to determine language)

[03:58] <dmitri> well, .pm6 is a module

[03:58] <dmitri> .pm is also used by Perl 6 modules

[03:59] <skids> Yeah I stopped making that distinction years ago even for Perl 5 stuff.

[03:59] *** lue joined
[03:59] *** ShimmerFairy left
[03:59] *** lue is now known as ShimmerFairy

[04:00] <ShimmerFairy> I personally use .p6 for scripts, .pm6 for modules

[04:00] <skids> Because if it is really a module it should be ensconsed in a /lib/ somewhere not in a likely-to-be cwd.

[04:00] <ShimmerFairy> (and think it's a terrible missed opportunity that rakudo's core uses .pm :P)

[04:00] <skids> Yeah that bothers me.

[04:00] <dmitri> ShimmerFairy: Yes -- I had to add "tasting" code for the .pm files -- is it Perl 5 or Pelr 6?

[04:01] <ShimmerFairy> skids: I think colonpairs work out as always nameds in arglists just by virtue of only allowing a legal variable name as the key in them

[04:02] <skids> I think that's not an accident though.

[04:02] <ShimmerFairy> m: my %h = :a(42); say %h.perl

[04:02] <camelia> rakudo-moar d8fa56: OUTPUT¬´{:a(42)}<>‚ê§¬ª

[04:02] <ShimmerFairy> ^ in reality it's not an unambiguous syntax for nameds

[04:03] <ShimmerFairy> dmitri: One of the specs (S01?) and maybe somewhere on docs.perl6.org describes various features distinguishing 5 and 6 --- 'use v6' (or v5), the presence of a 'unit module/class/etc.' statement, and so on.

[04:04] * skids updates gist to add a sentence about interaction of Pair vs named with *%_.

[04:05] <dmitri> ShimmerFairy: yes, but 

[04:05] <dmitri> "use v6" is not followed by most of Perl 6 code I've looked at

[04:05] <dmitri> (even though, admittedly, it's not much)

[04:06] <skids> ShimmerFairy: no not in an assignment it isn't.

[04:06] <ShimmerFairy> dmitri: I personally always 'use v6' to make sure nobody dares mistake my code for the other Perl :P . If there's a lack of people using it, my guess would be because we've only had one (evolving) version of Perl 6 so far.

[04:07] <ShimmerFairy> skids: ? I don't quite follow

[04:07] <ShimmerFairy> dmitiri: I imagine in lots of cases there won't be an easy way to detect between P6 and P5 files, just like C++ .h files :(

[04:09] <dmitri> ShimmerFairy: I think it's not that bad, actually, at least if we assume that .pm is either Perl 5 or Perl 6 *module*

[04:09] <ShimmerFairy> yeah, and .pl either P5 or P6 script :)

[04:09] <skids> ShimmerFairy: The right side of = is not exactly an arglist, it is its own thing.

[04:10] *** beastd left
[04:10] <dmitri> The .pl case is obviously harder

[04:10] <ShimmerFairy> skids: sure, but I'm talking about ambiguity of syntax across the language. I can't immediately think of another case like => vs. :() in the language.

[04:11] <dmitri> I think I'll just pretend that .pl is always Perl 5

[04:12] <ShimmerFairy> dmitri: I think that's a good choice, all things considered (just like, to use the same comparison, assuming .h is C by default ‚ò∫)

[04:15] *** isBEKaml joined
[04:16] *** Calibellus joined
[04:17] <skids> Well, I guess it hasn't bothered me because I learned => as "there in case you can't let go of P5 habits" and I've rarely ever used it.

[04:18] <skids> Which is odd because I'm horrible at losing habits.

[04:18] <ShimmerFairy> among other issues, consider that you're allowed to substitute colonpairs for fat arrow in arglists, but not in adverbs. (Not that I advocate allowing fatarrow for adverbs, it's just another minor inconsistency)

[04:19] <ShimmerFairy> skids: Well, for me => is a Pair-y syntax, and :() is a named-y syntax. It frustrates me that the two concepts have been conflated just because nameds can kinda be treated as Pair-like maybe.

[04:24] <ShimmerFairy> The only other conflation I can think of right now is that of { } for either hashes or code blocks, and that's really an issue for the parser (whereas what I'm complaining about is an issue for the humans writing code)

[04:25] *** bin_005_x joined
[04:25] *** khw left
[04:26] *** bin_005 left
[04:34] *** laouji left
[04:34] *** laouji joined
[04:39] *** laouji left
[04:40] *** laouji joined
[04:43] *** isBEKaml left
[04:44] *** isBEKaml joined
[04:47] *** isBEKaml left
[04:52] <dmitri> ShimmerFairy: https://github.com/dtikhonov/ctags/blob/basic-perl6-impl/main/parse.c#L44

[04:56] *** skids left
[04:56] *** cognominal left
[05:06] *** llfourn joined
[05:08] *** xinming_ left
[05:14] *** davido__ left
[05:15] *** Calibellus left
[05:16] *** davido__ joined
[05:17] *** cognominal joined
[05:19] <cognominal> \o #perl6

[05:20] <cognominal> I am attempting to provide a minimal example for QAST::ParamTypeCheck. I am doing it wrong. Can someone help?  https://gist.github.com/cognominal/efa78cd052e6b9ef7268

[05:20] *** llfourn left
[05:21] *** dmitri left
[05:34] *** laouji left
[05:38] *** Hor|zon joined
[05:41] <Sgeo> Wait, what's *%_?

[05:42] <Sgeo> Almost thinking it's 'allow arbitrary named arguments and ignore them' because in other languages _ would mean unused variable

[05:42] <Sgeo> But $_ has special meaning, and @_ did in Perl5

[05:42] *** laouji joined
[05:42] *** Hor|zon left
[05:45] *** BenGoldberg left
[05:46] *** ChoHag joined
[05:47] <ChoHag> How do you provide values to the attributes of an inherited class?

[05:57] *** pierrot left
[05:59] *** llfourn joined
[06:08] *** pierrot joined
[06:20] *** laouji left
[06:26] *** aindilis joined
[06:27] *** aindilis` joined
[06:35] *** brrt joined
[06:35] *** darutoko joined
[06:38] *** llfourn left
[06:39] *** Hor|zon joined
[06:40] <FROGGS> Sgeo: *%_ is 'slurp any additional named argument'

[06:40] <Sgeo> And do what with it? Ignore it?

[06:40] <FROGGS> [...]'into an anonymous hash'

[06:40] <FROGGS> m: sub foo(*%_) { say %_ }; foo :a(42)

[06:40] <camelia> rakudo-moar d8fa56: OUTPUT¬´a => 42‚ê§¬ª

[06:41] <FROGGS> Sgeo: you can access %_, but usually that idiom is used to ignore them

[06:41] <Sgeo> Ah

[06:43] <jdv79> its just bikeshedding but who came up with this IETF::RFC_Grammar namespace?

[06:43] <jdv79> just seems odd to use _ instead of just :: and RFC is unambiguous so why IETF...

[06:44] *** Hor|zon left
[06:45] <jdv79> is the top level Grammar name not a good idea?

[06:45] <jdv79> seems not - things exist already

[07:08] *** RabidGravy joined
[07:33] *** azawawi joined
[07:39] <azawawi> hi

[07:40] *** Hor|zon joined
[07:40] <azawawi> japhb: ping

[07:41] *** aindilis left
[07:41] *** aindilis` left
[07:42] *** aindilis joined
[07:44] *** Hor|zon left
[07:47] <azawawi> .tell japhb re your discussion with timotimo++ about Electron. It is basically chrome + nodejs + API which we are accessing via JSON::RPC. We're setting up a nodejs jsonrpc server and using it via JSON::RPC and wrapping all into lovely p6 classes :)

[07:47] <yoleaux> azawawi: I'll pass your message to japhb.

[07:48] <azawawi> .tell japhb examples are found here https://github.com/azawawi/perl6-atom-electron/tree/master/examples

[07:48] <yoleaux> azawawi: I'll pass your message to japhb.

[07:52] *** pmurias joined
[07:53] *** rurban joined
[07:57] *** TEttinger left
[07:59] <pmurias> hi

[08:01] *** virtualsue joined
[08:02] *** HoppingMadMan left
[08:12] <brrt> hi pmurias

[08:17] <cognominal> hum, there was many typos in my code. No wonder it did not work.

[08:18] *** diana_olhovik joined
[08:27] *** xfix joined
[08:28] *** rurban left
[08:29] <jdv79> m: class Foo:::Bar {} # a bug in the error?

[08:29] <camelia> rakudo-moar d8fa56: OUTPUT¬´===SORRY!===‚ê§Name Foo:::Bar ends with '::' and cannot be used as a package name‚ê§¬ª

[08:33] *** rurban joined
[08:33] *** rurban left
[08:34] *** llfourn joined
[08:38] *** llfourn left
[08:54] <jdv79> is there a way to combine a rule and a lit for purposes of match/backtrack?

[09:00] <jdv79> nm.  ?? seems good enogh.

[09:05] *** rurban joined
[09:08] *** rurban left
[09:23] *** dsm joined
[09:27] <jdv79> nice when a seemingly simple rfc is itself confused

[09:27] <jdv79> :(

[09:27] *** rindolf joined
[09:34] *** llfourn joined
[09:35] *** telex left
[09:36] *** telex joined
[09:39] *** llfourn left
[09:41] *** Hor|zon joined
[09:43] <jdv79> m: class A { has $.a; }; my $s = 'a'; A.new.$s; # how does one do that?

[09:43] <camelia> rakudo-moar d8fa56: OUTPUT¬´Cannot find method 'postcircumfix:<( )>'‚ê§  in block <unit> at /tmp/iyCAhJXeDF:1‚ê§‚ê§¬ª

[09:45] *** Hor|zon left
[09:46] <psch> m: class A { has $.a = "foo"; }; my $s = 'a'; say A.new."$s"(); 

[09:46] <camelia> rakudo-moar d8fa56: OUTPUT¬´foo‚ê§¬ª

[09:46] <jdv79> doh!

[09:46] <jdv79> thanks

[09:47] <jdv79> was just a little taken aback that $o.perl kicks out a constructor call that may not be valid

[09:48] <jdv79> i was attempting to dome testing but in aggregate.  wonder how to do that now.

[09:48] *** virtualsue_ joined
[09:49] *** virtualsue left
[09:49] *** virtualsue_ is now known as virtualsue

[09:52] <nine> S06 says the want function is gone and I should "return an object instead that responds accordingly to the various contextual methods". But only the "sink" method seems to ever be called. "my $item =" and "my @list =" just assign without calling any methods. So how is this really supposed to work?

[09:53] <pmurias> as far as I know you can't emulate the old context stuff

[09:54] <pmurias> the object you return should just behave like both a scalar/list instead of having a conditional in the function

[09:55] <pmurias> do I guess correctly you want that for the p5 interop?

[09:55] <nine> pmurias: yes

[09:56] <pmurias> I think specific the context manually when calling the method/sub is the only way

[09:56] *** xfix left
[09:56] <psch> i'd guess you have to kind wrap what wantarray does

[09:56] <pmurias> * specifying

[09:56] <psch> i.e. tell perl6 if perl5 would return true or false for wantarray in that spot

[09:57] * psch .oO( that's what pmurias++ says i guess )

[09:57] <pmurias> that's the opposite

[09:58] <psch> ...it is?  better hurry with the coffee, me :)

[09:58] <pmurias> when calling a p5 method we would need something like foo(:context<scalar>, 1, 2,3)

[09:58] <pmurias> s/method/sub/

[09:58] <nine> But in essence, what S06 says is just plain wrong?

[10:00] <psch> nine: S06 talks about contextual methods, i'm not sure assignment is one of those

[10:00] <psch> m: class A { method list { 1,2,3 }; method item { 6 } }; .say for A.new; say A.new

[10:00] <camelia> rakudo-moar d8fa56: OUTPUT¬´A.new‚ê§A.new‚ê§¬ª

[10:00] <pmurias> it tells you what to do if you want context specific behaviour

[10:01] <nine> pmurias: I want context specific behaviour and I did what it told me, but it just doesn't work that way as we can see in psch++'s example

[10:01] <psch> yeah, that got me too just now

[10:01] <nine> m: class A { method sink { say "sink!"; } }; A.new

[10:01] <camelia> rakudo-moar d8fa56: OUTPUT¬´sink!‚ê§¬ª

[10:01] <nine> Only sink ever gets called

[10:02] <psch> m: class A { method list { 1,2,3 }; method item { 6 }; method sink { "sunk" } }; .say for A.new; say A.new

[10:02] <camelia> rakudo-moar d8fa56: OUTPUT¬´A.new‚ê§A.new‚ê§¬ª

[10:02] *** araujo left
[10:02] <psch> m: class A { method list { 1,2,3 }; method item { 6 }; method sink { "sunk" } }; my @a = A.new; my $a = A.new; say @a ~ "|" ~ $a

[10:02] <camelia> rakudo-moar d8fa56: OUTPUT¬´A<140404705145096>|A<140404705147544>‚ê§¬ª

[10:02] <psch> that's .gist

[10:02] <psch> ?

[10:02] <psch> ah no .Str

[10:03] <psch> m: class A { method list { 1,2,3 }; method item { 6 }; method sink { "sunk" }; method Str { }; my @a = A.new; my $a = A.new; say @a; say $a

[10:03] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/wdKvX1Yv2q‚ê§Missing block‚ê§at /tmp/wdKvX1Yv2q:1‚ê§------> 3a = A.new; my $a = A.new; say @a; say $a7‚èè5<EOL>‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚Ä¶¬ª

[10:03] <psch> m: class A { method list { 1,2,3 }; method item { 6 }; method sink { "sunk" }; }; my @a = A.new; my $a = A.new; say @a; say $a

[10:03] <camelia> rakudo-moar d8fa56: OUTPUT¬´A.new‚ê§A.new‚ê§¬ª

[10:03] <ShimmerFairy> m: class C { method list { 1,2,3 } }; say @(C)

[10:03] <camelia> rakudo-moar d8fa56: OUTPUT¬´1 2 3‚ê§¬ª

[10:03] <psch> i'm really missing something there

[10:03] <pmurias> nine: re plain wrong, the old behaviour is gone and not emulatable and what we now have is something different

[10:05] <ShimmerFairy> m: class C { method list { 1,2,3 }; method item { 6 } }; my $a = C.new; say $a.perl; say @$a.perl; say $$a.perl;

[10:05] <camelia> rakudo-moar d8fa56: OUTPUT¬´C.new‚ê§(1, 2, 3)‚ê§6‚ê§¬ª

[10:05] <nine> pmurias: but it tells me that an object can respond accordingly to various contextual methods, when there seems to only be "sink" which is a single method.

[10:06] <ShimmerFairy> nine, psch: list and item do get called when requested, just perhaps not in all the places you expect :)

[10:06] <psch> ShimmerFairy: yeah, the "contextual" bit is missleading in S06 in my opinion

[10:06] <pmurias> nine: it's a conjencture

[10:06] <psch> ShimmerFairy: but maybe that's my understanding, i'd want .list when iterating...

[10:06] <pmurias> nine: and even if it worked it would be really bad to use that for p5 interop

[10:06] <psch> s/ und/ misund/

[10:07] <ShimmerFairy> m: my $a = Array.new(1,2,3); say $a.perl; say $_ for $a; say $_ for @$a

[10:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/Cm3aVKYMXg‚ê§Bogus postfix‚ê§at /tmp/Cm3aVKYMXg:1‚ê§------> 3y $a.perl; say $_ for $a; say $_ for @$a7‚èè5‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§¬ª

[10:07] <ShimmerFairy> m: my $a = Array.new(1,2,3); say $a.perl; say $_ for $a; say $_ for @$a

[10:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´[1, 2, 3]‚ê§1 2 3‚ê§1‚ê§2‚ê§3‚ê§¬ª

[10:07] <ShimmerFairy> psch: ^^^ doesn't iterate $a in this case either, without explicitly list-ifying it

[10:07] <pmurias> nine: because in p5 we know the context at sub call time and in p6 we only know that at return value use time

[10:08] <psch> ShimmerFairy: yeah, and that's actually fine.  looking at it from wantarray, we had context information in perl5 on the LHS, but now we need it on the RHS

[10:08] <nine> pmurias: hence the idea to lazily execute the function once the context is clear

[10:08] <psch> because the assignment itself doesn't look at the LHS anymore

[10:08] <pmurias> nine: seems horrible to me

[10:09] <nine> pmurias: if there are better ideas, I'd be happy to hear them :)

[10:10] <pmurias> assume a context (scalar?) and allow the caller to override with a named argument?

[10:10] <pmurias> "foo(1,2,3)" and "foo(:list, 1, 2, 3)"

[10:11] <pmurias> nine: slightly less terse but much less likely to explode

[10:12] <nine> pmurias: the use case I have is a context sensitive P5 method (from DBIx::Class) that's being delegated to by a fallback in a P6 subclass of the P5 ResultSet and the original caller being in P5 code. So we have P5 -> P6 -> P5 and I need to propagate the context through this P6 code somehow.

[10:13] <nine> pmurias: I love your idea for the case when P6 code just invokes a P5 method and knows what it needs. Unfortunately in my case the layer between P5 and P6 (the "->" in P5 -> P6) doesn't know that the P6 code will just delegate to a P5 method.

[10:13] <pmurias> $context = v5::wantarray(); :context($context)

[10:14] <pmurias> $context = v5::wantarray(); $foo.bar(:context($context), ...)

[10:14] <nine> That may end up passing a :context argument to some P6 method that wouldn't know what to do with it. Or worse that has exactly such a named argument but for a different purpose.

[10:16] <pmurias> the second -> doesn't know that we are propagating context?

[10:16] <nine> Worse: I translate all named arguments to positional arguments when calling into P5 code, so we can still do $p5obj->foo(foo => 'bar');

[10:18] <nine> pmurias: yes, the second -> would be where I need the context information. But I'd have to be sure we're just delegating and that we need to propagate. Otherwise we'd propagate the context to completely unrelated calls.

[10:19] *** rurban joined
[10:20] *** rurban left
[10:20] <pmurias> having to manually setting the context propagation doesn't seem like a heavy price to me

[10:20] <pmurias> s/setting/set/

[10:20] <nine> pmurias: manually where?

[10:20] *** rurban joined
[10:21] <pmurias> P5 -> (fetch the context here, using something like $context = v5::wantarray) P6 (set the context using something like :context($context) here) -> P5

[10:23] <nine> The P6 code would have to know that it is called by P5 code directly.

[10:23] <pmurias> yes

[10:23] <pmurias> I don't think there is a way to that otherwise

[10:24] <pmurias> lazily executing function sounds like something that would cause needless debugging on the users

[10:25] <nine> So I need to check my callframe in the fallback method

[10:26] *** rurban left
[10:27] <pmurias> fallback method?

[10:28] *** spider-mario joined
[10:28] <[TuxCM]> so, "," has higher precedence than ?? !! ?

[10:28] <[TuxCM]> m: my $a = 1; my @b = $a == 1 ?? 1, 2, 3 !! 4, 5, 6

[10:28] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/z984s0_Ssr‚ê§Precedence of , is too loose to use inside ?? !!; please parenthesize‚ê§at /tmp/z984s0_Ssr:1‚ê§------> 3my $a = 1; my @b = $a == 1 ?? 17‚èè5, 2, 3 !! 4, 5, 6‚ê§    expecting any of:‚ê§        i‚Ä¶¬ª

[10:28] <[TuxCM]> the message is clear, but I am still surprised

[10:29] *** llfourn joined
[10:29] *** vendethiel joined
[10:31] <nine> pmurias: the fallback method in Inline::Perl5::Perl5Parent that's delegating to the P5 method

[10:31] <ShimmerFairy> [TuxCM]: it's actually saying that , has a lower precedence

[10:32] <[TuxCM]> if it had, it would not be ambiguous

[10:33] <[TuxCM]> FWIW, I have no problem using parens here

[10:34] <ShimmerFairy> [TuxCM]: lower precedence means the commas get their arguments _after_ ?? !! ; i.e. the parser would read it as  (1 ?? 1), 2, (3 !! 4), 5, 6  . Which makes no sense, thus the error.

[10:36] *** leont joined
[10:39] *** cognominal left
[10:54] *** brrt left
[10:56] *** llfourn left
[11:05] *** rindolf left
[11:13] <[TuxCM]> what discriminates a Block from a Callable?

[11:13] <[TuxCM]> how do I dynamically pass a Callable?

[11:16] <nine> [TuxCM]: a block is Callable

[11:16] <psch> Block does Callable

[11:16] <nine> or rather does Callable AFAIK

[11:16] <psch> the latter is a role, yes

[11:16] *** Psyche^_ joined
[11:17] <psch> well, Block is Code, Code does Callable

[11:18] *** azawawi left
[11:19] <[TuxCM]> can I combine "things" in a when?

[11:19] <[TuxCM]> given ($x.WHAT) { when Routine|Sub|Block|Callable|code { ... }

[11:19] <moritz> yes

[11:19] <[TuxCM]> Code

[11:20] <moritz> though note that Callable immplies all of the others

[11:20] <moritz> m: for Routine, Sub, Block, Code -> $t { say $t ~~ Callable }

[11:20] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§True‚ê§True‚ê§True‚ê§¬ª

[11:20] <psch> Sub <: Routine <: Block <: Code i think?

[11:20] *** Psyche^ left
[11:20] <psch> might be wrong order on the first two

[11:22] <moritz> http://doc.perl6.org/type/Callable has a nice type graph

[11:24] <[TuxCM]> given ($in.WHAT) { when Callable { @foo = gather while $in() -> $x { take $x }; }

[11:24] <[TuxCM]> ok for Sub, but fail for Block

[11:24] <[TuxCM]> what am I missing there?

[11:27] *** Hor|zon joined
[11:28] <[TuxCM]> Found it: my block had a return

[11:30] <moritz> [TuxCM]: fwiw  given $in { when Callable { ... } }

[11:30] *** llfourn joined
[11:30] <moritz> [TuxCM]: should work the same way

[11:31] <moritz> (of course, only if you other when clauses also work with the object itself, not just the type)

[11:31] <[TuxCM]> thanks, /me checks

[11:31] *** Hor|zon left
[11:35] <moritz> m: sub f { state $x = 10; $x-- }; my @a = gather while f() -> $x { take $x }

[11:35] <camelia> rakudo-moar d8fa56: ( no output )

[11:35] <moritz> m: sub f { state $x = 10; $x-- }; my @a = gather while f() -> $x { take $x }; say @a

[11:35] <camelia> rakudo-moar d8fa56: OUTPUT¬´10 9 8 7 6 5 4 3 2 1‚ê§¬ª

[11:37] <nine> Seems like callframe won't give me the caller, while &?CALLER::ROUTINE doesn't work in FALLBACK methods :/

[11:47] *** gfldex joined
[11:47] *** Peter_R left
[11:52] <timotimo> oh, because the caller of the fallback method is in the meta object protocol implementation, ib et

[11:54] *** leont left
[11:55] <nine> timotimo: that's not a real problem. Problem is jnthn broke &?CALLER::CALLER::ROUTINE :/ It always returns the FALLBACK regardless of how many CALLER:: I stuff in there. It did work on Tuesday's rakudo.

[11:57] *** Peter_R joined
[11:58] *** smls joined
[11:59] <nine> m: role Marker { }; sub foo { say &?CALLER::ROUTINE ~~ Marker; }; my $test = sub { foo(); }; $test(); $test does Marker; $test();

[11:59] <camelia> rakudo-moar d8fa56: OUTPUT¬´False‚ê§False‚ê§¬ª

[12:00] <timotimo> http://blogs.perl.org/users/aaron_baugher/2015/08/getting-started.html ‚Üê cool

[12:00] <timotimo> oh, that's bad :|

[12:01] <smls> .tell dmitri For .pm files, you can assume it's Perl 5 by default, and only Perl 6 if the first non-comment line starts with one of:    use v6    unit    module   class

[12:01] <yoleaux> smls: I'll pass your message to dmitri.

[12:06] *** rindolf joined
[12:08] <ChoHag> How do you initialise the values of a superclass other than by stuffing them in the new() call?

[12:09] <nine> .tell jnthn your commit 56ae33ea0a5ac3d54a5fef2aa15eab34f9e9594b broke &?CALLER::ROUTINE: role Marker { }; sub foo { say &?CALLER::ROUTINE ~~ Marker; }; my $test = sub { foo(); }; $test(); $test does Marker; $test();

[12:09] <yoleaux> nine: I'll pass your message to jnthn.

[12:11] <smls> ChoHag: With `nextwith` I think

[12:12] <ChoHag> And BUILD is no good because the superclass' attribute is required but the subclass' BUILD is called last.

[12:13] <nine> ChoHag: I guess, you'd need to write your own "new"

[12:18] *** mohij joined
[12:19] *** araujo_ joined
[12:19] *** araujo_ left
[12:21] *** census joined
[12:27] *** spidermario joined
[12:28] *** spider-mario left
[12:28] *** spidermario is now known as spider-mario

[12:45] *** beastd joined
[12:48] *** mohij left
[12:56] *** mohij joined
[13:12] *** spider-mario left
[13:24] *** virtualsue left
[13:28] *** Hor|zon joined
[13:33] *** Hor|zon left
[13:35] *** xinming joined
[13:35] *** virtualsue joined
[13:35] *** virtualsue left
[13:36] *** virtualsue joined
[13:40] *** khw joined
[13:41] *** mohij left
[13:47] *** bin_005_x left
[13:54] *** FROGGS_ joined
[13:57] *** FROGGS left
[13:59] *** mr_ron joined
[14:05] *** virtualsue left
[14:13] <smls> m: my @a = 5, 10, 15; @a[1]:delete; dd @a, +@a;

[14:13] <camelia> rakudo-moar d8fa56: OUTPUT¬´@a = [5, Any, 15]<>‚ê§3‚ê§¬ª

[14:13] <smls> ^^ so delete no longer actually creates "arrays with holes"?

[14:14] <smls> (Not that I'm complaining, I always considered that feature a mistake.)

[14:15] <smls> m: my @array = 5, 10, 15; @array[2]:delete; dd @array, +@array

[14:15] <camelia> rakudo-moar d8fa56: OUTPUT¬´@array = [5, 10]<>‚ê§2‚ê§¬ª

[14:15] <smls> looks like it can cut off elements from the end though

[14:16] * smls would still prefer :delete being replaced by a :remove with splice semantics.

[14:31] *** skids joined
[14:31] <nine> m: use nqp; role Marker { }; sub foo { say nqp::getcodeobj(nqp::ctxcode(nqp::ctxcaller(nqp::ctx))) ~~ Marker; }; my $test = sub { foo(); }; $test does Marker; $test();

[14:31] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§¬ª

[14:31] <nine> What a workaround :)

[14:32] *** haroldwu joined
[14:32] <nine> .tell jnthn I can workaround missing &?CALLER::ROUTINE with nqp::getcodeobj(nqp::ctxcode(nqp::ctxcaller(nqp::ctx)))

[14:32] <yoleaux> nine: I'll pass your message to jnthn.

[14:39] *** BenGoldberg joined
[14:39] *** virtualsue joined
[14:43] *** laouji joined
[14:44] <timotimo> m: my @a = 5, 10, 15; @a[1]:delete; dd @a, +@a; say @a[1]:exists;

[14:44] <camelia> rakudo-moar d8fa56: OUTPUT¬´@a = [5, Any, 15]<>‚ê§3‚ê§False‚ê§¬ª

[14:44] <timotimo> ^- it makes an array with a hole, smls 

[14:45] <smls> So it's just that .elems doesn't know about holes?

[14:46] <smls> (nor does .perl, because it won't round-trip there, will it)

[14:46] <smls> (yet more evidence that holes are a mis-feature...)

[14:47] <smls> (and deprecated/shunned in Perl 5 for good reason.)

[14:48] <timotimo> i suppose we don't want .elems to go through and count the holes

[14:51] *** laouji left
[14:51] <timotimo> what's problematic about having a hole?

[14:51] <psch> @a[*-1]:delete not leaving a hole at the edge is weird to me

[14:51] <psch> i mean, i kinda see why a hole at the edge doesn't really make sense, but that feels like stretching the metaphor a bit too far

[14:54] <smls> "what's problematic" -- the fact that, as .elems and .perl show, it does cause an overall consistent design to fall into place.

[14:54] <smls> and the fact that it blocks the more useful splice-based :delete/:remove adverb from being added

[14:54] <timotimo> that sentence makes no sense to me

[14:55] <smls> Well, .perl is supposed to round-trip, isn't it? with holes it doesn't, and there's no declarative way to specify holes which .perl could use.

[14:55] *** raiph joined
[14:56] <smls> And .elems matching the number of elements that :exists would not be an unreasonable expectation w.r.t. consistency. But again, holes make that unfeasible.

[14:56] <timotimo> m: my @a = 5, 10, 15; @a[1]:delete; say @a.perl

[14:56] <camelia> rakudo-moar d8fa56: OUTPUT¬´[5, Any, 15]<>‚ê§¬ª

[14:56] <timotimo> m: say ([5, Nil, 15]<>).perl

[14:56] <camelia> rakudo-moar d8fa56: OUTPUT¬´[5, Any, 15]<>‚ê§¬ª

[14:56] <timotimo> m: say ([5, Nil, 15]<>)[1]:exists

[14:56] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§¬ª

[14:56] <timotimo> interesting.

[14:56] <psch> m: my @a = 5, 10, 15; @a[1]:delete; my @b = EVAL @a.perl; say @b.perl; say @a[1] === @b[1]

[14:56] <camelia> rakudo-moar d8fa56: OUTPUT¬´[5, Any, 15]<>‚ê§True‚ê§¬ª

[14:57] <psch> m: my @a = 5, 10, 15; @a[1]:delete; my @b = EVAL @a.perl; say @b.perl; say @a[1]:exists; say @b[1]:exists

[14:57] <camelia> rakudo-moar d8fa56: OUTPUT¬´[5, Any, 15]<>‚ê§False‚ê§True‚ê§¬ª

[14:57] <psch> m: my @a = 0, Any, Nil; say +@a

[14:57] <camelia> rakudo-moar d8fa56: OUTPUT¬´3‚ê§¬ª

[14:58] <psch> m: my @a = 0, Any, Nil; say +@a; @a[2]:delete; say @a[2]

[14:58] <camelia> rakudo-moar d8fa56: OUTPUT¬´3‚ê§(Any)‚ê§¬ª

[14:58] <timotimo> m: my @a = 5, 10, 15; @a[1] = Nil; say @a[1]:exists

[14:58] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§¬ª

[14:58] <timotimo> m: my @a = 5, 10, 15; @a[1] = Nil; say @a.perl

[14:58] <camelia> rakudo-moar d8fa56: OUTPUT¬´[5, Any, 15]<>‚ê§¬ª

[14:58] <timotimo> i thought assigning Nil to a slot in the array would set its :exists no False

[14:59] <smls> from perldoc (http://perldoc.perl.org/functions/delete.html): "WARNING: Calling delete on array values is strongly discouraged. The notion of deleting or checking the existence of Perl array elements is not conceptually coherent, and can lead to surprising behavior."

[14:59] <psch> m: my @a = 0, 1, 2; @a[1] = nqp::null(); say @a[1]:exists

[14:59] <camelia> rakudo-moar d8fa56: OUTPUT¬´===============================================================================‚ê§The use of nqp::operations has been deprecated for non-CORE code.  Please‚ê§change your code to not use these non-portable functions.  If you really want‚ê§to keep using nqp:‚Ä¶¬ª

[14:59] <psch> m: use NQP; my @a = 0, 1, 2; @a[1] = nqp::null(); say @a[1]:exists

[14:59] <camelia> rakudo-moar d8fa56: OUTPUT¬´===SORRY!===‚ê§Could not find NQP in any of:‚ê§  file#/home/camelia/.perl6/2015.07.1-51-gd8fa568/lib‚ê§  inst#/home/camelia/.perl6/2015.07.1-51-gd8fa568‚ê§  file#/home/camelia/rakudo-inst-2/share/perl6/lib‚ê§  file#/home/camelia/rakudo-inst-2/share/perl6/v‚Ä¶¬ª

[14:59] <smls> This seems like one of the features which Perl 6 carried over from old Perl 5 versions, and never got the memo that the Perl 5 community found out that they were a mistake.

[14:59] <psch> eh, how was that pragma..?

[15:00] <psch> m: use nqp; my @a = 0, 1, 2; @a[1] = nqp::null(); say @a[1]:exists

[15:00] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§¬ª

[15:02] *** kaare_ joined
[15:02] <psch> anyway, DELETE-POS binds with nqp::null

[15:02] <psch> m: my @a = ^3; @a[1] := Nil; say @a[1]:exists

[15:02] <camelia> rakudo-moar d8fa56: OUTPUT¬´True‚ê§¬ª

[15:03] <psch> so i don't get it :)

[15:04] <psch> m: use nqp; say nqp::isnull(Nil)

[15:04] <camelia> rakudo-moar d8fa56: OUTPUT¬´0‚ê§¬ª

[15:04] <psch> m: use nqp; say nqp::isnull(nqp::null())

[15:04] <camelia> rakudo-moar d8fa56: OUTPUT¬´1‚ê§¬ª

[15:04] <psch> List.pm defines EXISTS-POS with an nqp::isnull, like that

[15:05] <psch> and DELETE-POS binds nqp::null

[15:05] <psch> assigning Nil doesn't assign nqp::null

[15:06] <psch> m: use nqp; my @a = 1,2; @a[0]:delete; say nqp::isnull(@a[0])

[15:06] <camelia> rakudo-moar d8fa56: OUTPUT¬´0‚ê§¬ª

[15:06] <psch> m: use nqp; my @a = 1,2; @a[0]:delete; say nqp::isnull(@a[0]); say @a[0]:exists

[15:06] <camelia> rakudo-moar d8fa56: OUTPUT¬´0‚ê§False‚ê§¬ª

[15:06] <psch> ...but AT-POS hllizes?

[15:07] <psch> does that fall into the GLR? :)

[15:09] *** mohij joined
[15:13] <timotimo> if there's a hole, you'll get something that can autovivify, no?

[15:15] <jdv79> hmm, so how to d the p6 equiv of a p5 if ( my $lex = 42 {lex here } no lex here?

[15:16] <timotimo> those parens are unbalanced

[15:16] <psch> m: -> my $a = 0 { say $a }; try { say $a }

[15:16] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/9URYq93zcM‚ê§Invalid typename 'my' in parameter declaration.‚ê§at /tmp/9URYq93zcM:1‚ê§------> 3-> my7‚èè5 $a = 0 { say $a }; try { say $a }‚ê§¬ª

[15:16] <psch> m: -> $a = 0 { say $a }; try { say $a }

[15:16] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/9kqswJDpWb‚ê§Variable '$a' is not declared‚ê§at /tmp/9kqswJDpWb:1‚ê§------> 3-> $a = 0 { say $a }; try { say 7‚èè5$a }‚ê§¬ª

[15:17] <timotimo> a missing lexical is a compile-time error

[15:17] <jdv79> hmm, so how to d the p6 equiv of a p5 if ( my $lex = 42 ){lex here } no lex here?

[15:17] <jdv79> super laggy here 

[15:17] <timotimo> you can indirectly access it via ::('$a')

[15:17] <psch> m: -> $a = 0 { say $a }; try { say ::('$a') }

[15:17] <camelia> rakudo-moar d8fa56: ( no output )

[15:17] <moritz> jdv79: if 42 -> { $lex 7 ... }

[15:17] <timotimo> m: if 42 -> $lex { say $lex }; try { say ::('$lex') }

[15:17] <camelia> rakudo-moar d8fa56: OUTPUT¬´42‚ê§¬ª

[15:17] <psch> oh that way around

[15:17] <psch> i did remember the pointy block... 

[15:17] <timotimo> hehe

[15:20] <jdv79> thanks

[15:21] *** llfourn left
[15:26] *** lizmat joined
[15:27] *** cognominal joined
[15:28] <jdv79> are types and subsets lexical?

[15:28] <timotimo> m: { subset Test } my Test $a

[15:28] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/76syBQMgH9‚ê§Strange text after block (missing semicolon or comma?)‚ê§at /tmp/76syBQMgH9:1‚ê§------> 3{ subset Test }7‚èè5 my Test $a‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§      ‚Ä¶¬ª

[15:28] <timotimo> m: { subset Test }; my Test $a

[15:28] <camelia> rakudo-moar d8fa56: ( no output )

[15:28] <timotimo> m: subset Test; my Test $a

[15:28] <camelia> rakudo-moar d8fa56: ( no output )

[15:28] <timotimo> seems to be our-scoped

[15:29] *** Hor|zon joined
[15:29] *** llfourn joined
[15:31] <jdv79> o

[15:32] <timotimo> that's only by default, of course

[15:32] <timotimo> m: { my subset Test }; my Test $a

[15:32] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5===‚ê§Type 'Test' is not declared‚ê§at /tmp/DOdn1UjlR_:1‚ê§------> 3{ my subset Test }; my Test7‚èè5 $a‚ê§Malformed my‚ê§at /tmp/DOdn1UjlR_:1‚ê§------> 3{ my subset Test }; my7‚èè5 Test $a‚ê§‚ê§¬ª

[15:33] *** Hor|zon left
[15:37] <moritz> types and constants are our-scoped by default, yes

[15:43] *** beastd|2 joined
[15:45] *** beastd left
[15:46] <jdv79> i would like to have an attr that i can set and get in both list and item context

[15:46] <jdv79> not sure how to do taht in p6

[15:47] <moritz> jdv79: example?

[15:48] <smls> When subscripting an array or hash with :k, :v or :kv, any non-existent keys are silently skipped (whereas without a subscripting adverb, they cause an undefined value at the corresponding place in the output). Is this by design?

[15:48] <jdv79> a path attr, $.path.[2] = 'foo', $.path = "foo/bar/", $.path.list, $path.item

[15:49] <moritz> create a Path class that's indexable, and return a Proxy attribute which does something different in STORE

[15:50] <jdv79> any examples?

[15:50] <jdv79> the proxy docs and tests i saw were scant

[15:50] <smls> m: my %x = a=>1, c=>3; dd %x<a b c>; dd %x<a b c>:v   # example for undefined elements being silently skipped

[15:50] <camelia> rakudo-moar d8fa56: OUTPUT¬´(1, Any, 3)‚ê§(1, 3)‚ê§¬ª

[15:58] <dalek> roast: b60e0a8 | lizmat++ | S32-list/ (3 files):

[15:58] <dalek> roast: Test for Index rather than Int

[15:58] <dalek> roast: review: https://github.com/perl6/roast/commit/b60e0a8681

[16:00] <lizmat> smls: yes that is by design

[16:00] <smls> ok

[16:00] <lizmat> m: my %x = a=>1, c=>3; dd %x<a b c>; dd %x<a b c>:!v  # don't skip undefined elements

[16:00] <camelia> rakudo-moar d8fa56: OUTPUT¬´(1, Any, 3)‚ê§(1, Any, 3)‚ê§¬ª

[16:01] <lizmat> smls: not the !v

[16:01] <smls> interesting.

[16:01] <lizmat> *note

[16:01] <smls> This is not in the design docs, is it?

[16:01] <lizmat> yes, it is...

[16:02] <smls> oh, it's in S02 rather than S09

[16:02] <smls> thanks

[16:03] <itz> I seem to be able to create instances of roles directly with .new which I wouldn't have expected

[16:06] <lizmat> itz: that's called punning

[16:07] <lizmat> punning a role into a class

[16:07] <lizmat> m: role A { }; say A.new.WHAT

[16:07] <camelia> rakudo-moar d8fa56: OUTPUT¬´(A)‚ê§¬ª

[16:07] <lizmat> an anonymous class is created in which the role is imported

[16:09] <itz> ah thanks .. it was quite convenient but just surprised me

[16:09] <moritz> m: role A { }; say A == A, A === A.new.WHAT

[16:09] <camelia> rakudo-moar d8fa56: OUTPUT¬´Use of uninitialized value of type A in numeric context  in any  at src/gen/m-Metamodel.nqp:1677‚ê§Use of uninitialized value of type A in numeric context  in any  at src/gen/m-Metamodel.nqp:1677‚ê§TrueTrue‚ê§¬ª

[16:09] <moritz> m: role A { }; say A === A, A === A.new.WHAT

[16:09] <camelia> rakudo-moar d8fa56: OUTPUT¬´TrueTrue‚ê§¬ª

[16:10] <moritz> oh, I guess doing === always gets the punned class, never the role

[16:10] <moritz> m: role A { }; say A.HOW.^name; say A.new.WHAT.HOW.^name

[16:10] <camelia> rakudo-moar d8fa56: OUTPUT¬´Perl6::Metamodel::ParametricRoleGroupHOW‚ê§Perl6::Metamodel::ClassHOW‚ê§¬ª

[16:14] *** vendethiel left
[16:21] *** spider-mario joined
[16:28] *** perturbation joined
[16:30] *** Hor|zon joined
[16:34] *** vendethiel joined
[16:35] *** Hor|zon left
[16:39] *** brrt joined
[16:47] <jdv79> gist redispatches to perl for defined - weird;  why not just gist recursively?

[16:47] *** araujo joined
[16:47] *** araujo left
[16:47] *** araujo joined
[16:48] <lizmat> jdv79: context?

[16:51] *** brrt left
[16:52] *** raiph left
[16:52] <jdv79> just reading docs for say

[16:53] <jdv79> i mean gist

[16:54] <raydiak> jdv79: that's just the default provided by Mu...another way to say "if there isn't a (more specific) .gist defined, fall back to .perl"

[16:54] *** mr-foobar joined
[16:54] <lizmat> multi method gist(Mu:D:) { self.perl }   # what raydiak said

[16:56] <jdv79> i defined a gist and it didn't take

[16:56] <jdv79> idk

[16:57] <lizmat> m: class A { method gist { "foo" } }; say A

[16:57] <camelia> rakudo-moar d8fa56: OUTPUT¬´foo‚ê§¬ª

[16:58] *** pmurias left
[17:02] *** lizmat left
[17:06] *** raiph joined
[17:13] *** llfourn left
[17:40] *** HoppingMadMan joined
[17:51] <jdv79> why doesn't a proxy behave well with say?

[17:55] * skids wonders at the rationale behind checking if a runtime exception's backtrace is_runtime

[17:56] <skids> Well, only one way to find out.  Recompile without the check and see what explodes.

[17:58] <jdv79> what's wrong with this?: https://gist.github.com/anonymous/634aa3faecd763e77966

[18:01] <skids> jdv79: wrong self, I think.

[18:02] <skids> I did make that work once...

[18:06] <smls> jdv79: You can do   FETCH => -> ($) { $!a }   I think, instead of using anon methods

[18:06] * itz googles "perl6 punning" and discovers a PPT about how the .sk have opium for Xmas dinner

[18:06] <smls> jdv79: Or, do  my $a := $!a;  and then refer to $a in the Proxy

[18:08] * skids thinks the whole Proxy thing looks like it was designed in a hurry and never proofread.

[18:09] <jdv79> nothing i try works

[18:09] <jdv79> now i get: No such private method 'a' for invocant of type 'A'

[18:09] <jdv79> i feel like this should be easier

[18:11] <skids> m: https://gist.github.com/skids/322c06d96ea46a2ce67c

[18:11] <camelia> rakudo-moar d8fa56: OUTPUT¬´gist not found¬ª

[18:11] <skids> really?

[18:11] <smls> jdv79: With   my $a := $!a;   it works for me

[18:12] <smls> skids: That used to work

[18:12] *** davido__ left
[18:12] <skids> jdv79: The above gist WFM.  You get to put the indetation back in :-)

[18:13] *** davido__ joined
[18:14] *** virtualsue left
[18:14] <jdv79> yeah, yours have $self

[18:15] <jdv79> i don't get what the errors i was getting were

[18:15] <jdv79> but at least something works - thanks

[18:15] <skids> np

[18:16] <dalek> Inline-Perl5: 03bba94 | (Stefan Seifert)++ | / (4 files):

[18:16] <dalek> Inline-Perl5: Pass through scalar context when delegating to P5 base object

[18:16] <dalek> Inline-Perl5: 

[18:16] <dalek> Inline-Perl5: We now support calling Perl 5 methods in scalar context even when the

[18:16] <dalek> Inline-Perl5: Perl 5 module is partially written in Perl 6 using v6-inline:

[18:16] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/03bba94660

[18:18] <jdv79> let me guess, obj attr sets on construction don't go through accessors?

[18:19] *** census left
[18:21] <smls> yes

[18:22] <jdv79> does Moose do that ?

[18:22] <jdv79> i know Rose::Object does

[18:23] *** HoppingMadMan left
[18:24] *** beastd|2 left
[18:25] *** raiph left
[18:26] *** raiph joined
[18:27] *** mr_ron left
[18:27] *** mr_ron joined
[18:30] *** mr_ron left
[18:31] *** Hor|zon joined
[18:35] *** Hor|zon left
[18:40] <Sgeo> When would someone use a sigilless variable?

[18:40] <Sgeo> And what's the point of sigils exactly?

[18:40] <skids> They are noun markers.

[18:41] <jdv79> i think they are "contextualless" or something

[18:41] <moritz> Sgeo: sigils enforce context; sigilless variables are good when you don't want that (mostly to pass something through unchanged)

[18:41] <skids> And some of the docs about sigilless variables are a bit treacherous because they are not as simple as that.

[18:42] <skids> for example:

[18:42] <skids> m: my \a = 1; a = 3

[18:42] <camelia> rakudo-moar d8fa56: OUTPUT¬´Cannot modify an immutable Int‚ê§  in block <unit> at /tmp/vE4HPi1Fgi:1‚ê§‚ê§¬ª

[18:42] <skids> m: my \a = 1; a := 3

[18:42] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/Lt7Ht6h65q‚ê§Cannot use bind operator with this left-hand side‚ê§at /tmp/Lt7Ht6h65q:1‚ê§------> 3my \a = 1; a := 37‚èè5<EOL>‚ê§¬ª

[18:43] <skids> Where you actually use them is in special parameters like captures.

[18:44] <moritz> fwiw http://doc.perl6.org/language/variables#Sigilless_variables makes it quite clear that you can only assign them once

[18:45] <Sgeo> m: my \a = 1; \a := 3

[18:45] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/NdcY7Aa7t3‚ê§Cannot use bind operator with this left-hand side‚ê§at /tmp/NdcY7Aa7t3:1‚ê§------> 3my \a = 1; \a := 37‚èè5<EOL>‚ê§¬ª

[18:45] <skids> mortiz: Yeah I think I've saw some adventish stuff that threw them around casually, is all.

[18:45] <Sgeo> m: my \a = 1; my \a := 3

[18:45] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/4OiknKNW07‚ê§Redeclaration of symbol a‚ê§at /tmp/4OiknKNW07:1‚ê§------> 3my \a = 1; my \a := 37‚èè5<EOL>‚ê§¬ª

[18:46] <Sgeo> Can't rebind them by any means :/

[18:46] *** espadrine joined
[18:46] <timotimo> m: my \a = 1; my $b; a := $b;

[18:46] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/B2gTo_u7lQ‚ê§Cannot use bind operator with this left-hand side‚ê§at /tmp/B2gTo_u7lQ:1‚ê§------> 3my \a = 1; my $b; a := $b7‚èè5;‚ê§¬ª

[18:46] <timotimo> mhm

[18:46] <skids> They are also commonly used in e.g. "my constant e"

[18:47] <skids> And I guess the core uses them a lot to avoid making lots of multis.

[18:49] <dalek> doc: 41c9e4b | moritz++ | lib/Language/variables.pod:

[18:49] <dalek> doc: Mention that sigilless vars do not enforce context

[18:49] <dalek> doc: review: https://github.com/perl6/doc/commit/41c9e4bc27

[18:49] <moritz> skids: avoiding both multis and containers

[18:50] <skids> OK, well, if the is-runtime backtrace check is still protecting anything explody, no spectest has been written for it.

[18:50] *** spider-mario left
[18:50] <skids> I should probably check jvm though.

[18:52] *** spider-mario joined
[18:56] *** BooK joined
[18:56] *** dagurval joined
[18:56] *** rudi_s joined
[18:56] *** [ptc] joined
[18:56] *** StavroMueller joined
[18:56] *** broquaint joined
[18:56] *** timbunce joined
[18:57] *** go|dfish joined
[19:10] *** llfourn joined
[19:10] *** virtualsue joined
[19:10] *** lizmat joined
[19:10] *** charsbar__ left
[19:10] *** f3ew joined
[19:10] *** jordman joined
[19:10] *** SHODAN joined
[19:10] *** Ulti joined
[19:11] *** bobkare joined
[19:11] *** ingy joined
[19:11] *** raydiak joined
[19:11] *** charsbar__ joined
[19:11] *** oha joined
[19:11] *** xxx joined
[19:11] *** tadzik joined
[19:14] *** llfourn left
[19:16] *** ponbiki joined
[19:16] *** ponbiki is now known as Guest44551

[19:24] *** HoppingMadMan joined
[19:29] <ChoHag> m: class BloodyThing { has Int $.whatsit = 42; submethod BUILD (:$!whatsit) { say "Hi!" } }.new

[19:29] <camelia> rakudo-moar d8fa56: OUTPUT¬´Type check failed in assignment to '$!whatsit'; expected 'Int' but got 'Any'‚ê§  in submethod BUILD at /tmp/M1EPynx_Oh:1‚ê§  in block <unit> at /tmp/M1EPynx_Oh:1‚ê§‚ê§¬ª

[19:31] <lizmat> ChoHag: if you're using your own BUILD, the default setting doesn't work

[19:31] <lizmat> m: class BloodyThing { has Int $.whatsit; submethod BUILD (:$!whatsit = 42) { say "Hi!" } }.new

[19:31] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§¬ª

[19:31] <lizmat> m: class BloodyThing { has Int $.whatsit; submethod BUILD (:$!whatsit = 42) { say "Hi!" } }.new.perl.say

[19:31] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§BloodyThing.new(whatsit => 42)‚ê§¬ª

[19:32] <ChoHag> The spec suggests otherwise.

[19:32] <ChoHag> "Whether you write your own BUILD or not, at the end of the BUILD, any default attribute values are implicitly copied into any attributes that haven't otherwise been initialized."

[19:34] <lizmat> well, yes, perhaps the spec needs changing  :-)

[19:34] <ChoHag> Or perhaps BUILD needs changing.

[19:34] <lizmat> I'm just telling how it is now  :-)

[19:35] <lizmat> perhaps.... TimToady might want to chime in on this

[19:35] <ChoHag> BUILD/new contains lots of magic. If you want to change any of it, no matter in how minor a way, you need to reproduce *all* of the rest of it.

[19:35] <skids> m: class BloodyThing { has Int whatsit = 42; submethod BUILD () { say "Hi!" } }.new

[19:35] <camelia> rakudo-moar d8fa56: OUTPUT¬´5===SORRY!5=== Error while compiling /tmp/Wi9lEpLX26‚ê§Malformed has (did you mean to declare a sigilless \whatsit or $whatsit?)‚ê§at /tmp/Wi9lEpLX26:1‚ê§------> 3class BloodyThing { has Int whatsit7‚èè5 = 42; submethod BUILD () { say "Hi!" } ‚ê§¬ª

[19:36] <skids> erm.. darn howd that paste wrong.

[19:36] <skids> m: class BloodyThing { has Int $.whatsit = 42; submethod BUILD () { say "Hi!" } }.new # The  mere presense of :$whatsit sets it to any.

[19:36] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§¬ª

[19:37] <skids> *:$!whatsit.

[19:38] <skids> Also, read RT#125437 before you beat your head against a wall.

[19:38] <ChoHag> Seems to me there should be three interfaces - Inflexible magic; Partially-customisable magic; DIY magic - instead it seems the magic is entirely on or off.

[19:39] <ChoHag> At the least it could warn that my attribute's default values (and other ignored magic) is wasted.

[19:40] <ChoHag> If this was making me beat my head against a wall, there'd be neither wall nor head.

[19:40] <skids> (Give the above RT I would not expect the behavior is necessarily representative of what "should happen.")

[19:40] <lizmat> +1 on warning on not using the default value with custom BUILD

[19:40] <ChoHag> Computers these days elicit little more than a sigh from me, no matter what they do.

[19:41] <lizmat> +1 on doing the same on "is required" and having your own BUILD

[19:42] <ChoHag> And while you're at it, very strong words saying that BUILD turns off the various construction magics and that they need replicating.

[19:43] <ChoHag> The spec just says, almost en passant, about needing to include settable arguments in BUILD's signature.

[19:44] *** HoppingMadMan left
[19:45] <ChoHag> rt.perl.org: "The workaround is to change your full name"

[19:45] <ChoHag> I think that about sums up how I feel about the modern internet.

[19:46] <ChoHag> That and the fact that rt.perl.org doesn't have a search or even a go to button.

[19:46] *** telex left
[19:46] <ChoHag> Because who'd want to do either of *those* weird things?

[19:47] *** Hor|zon joined
[19:47] <skids> https://rt.perl.org/Public/Bug/Display.html?id=125437 # since the bots seem to be on vacation

[19:47] <mst> lizmat: hrm, we've found a lot of use from BUILD in M* stuff with attribute initialization happening normally first

[19:48] <lizmat> mst: well, if you do your own BUILD, it's just as easy to add defaults, as I shown above

[19:48] *** telex joined
[19:48] <lizmat> now, with "is required", that's a different issue

[19:49] <skids> m: class BloodyThing { has Int $.whatsit = 42; submethod BUILD () { say "Hi!" } }.new.perl.say

[19:49] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§BloodyThing.new(whatsit => 42)‚ê§¬ª

[19:49] <ChoHag> s/add/duplicate/

[19:51] <lizmat> m: class BloodyThing { has Int $.whatsit; submethod BUILD (:$!whatsit!) { say "Hi!" } }.new

[19:51] <camelia> rakudo-moar d8fa56: OUTPUT¬´Required named parameter 'whatsit' not passed‚ê§  in submethod BUILD at /tmp/Xw27tZhPLx:1‚ê§  in block <unit> at /tmp/Xw27tZhPLx:1‚ê§‚ê§¬ª

[19:51] <mst> lizmat: so you just need to move the default somewhere else

[19:51] <mst> lizmat: and the proposed warning should tell people to do that

[19:52] *** Hor|zon left
[19:53] <skids> m: class BloodyThing { has $.whatsit = 42.say; submethod BUILD () { say "Hi!" } }.new

[19:53] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§42‚ê§¬ª

[19:54] *** HoppingMadMan joined
[19:55] <lizmat> skids: interesting ...

[19:55] <skids> m: class BloodyThing { has $.whatsit = 42.say; submethod BUILD (:$whatsit) { say "Hi!"; $!whatsit = 43 } }.new.perl.say

[19:55] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§BloodyThing.new(whatsit => 43)‚ê§¬ª

[19:56] *** ShimmerFairy left
[19:56] <skids> So if you want your default applied, just don't set $!foo

[19:57] <skids> m: class BloodyThing { has $.whatsit = 42.say; submethod BUILD (:$whatsit) { say "Hi!"; } }.new.perl.say

[19:57] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§42‚ê§BloodyThing.new(whatsit => Bool::True)‚ê§¬ª

[19:58] <lizmat> skids++

[19:58] *** ggoebel left
[20:00] <skids> As to whether an unset :$!foo should set the attribute to Any, that could be intentional, or could be the bug in the RT.

[20:00] <skids> I'm guessing that behavior will not go away though even after the bug is fixed.

[20:02] <ChoHag> m: class BloodyThing { has Int $.whatsit = 42; submethod BUILD (:$whatsit) { say "Hi!" } }.new(whatsit=>7).perl.say

[20:02] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§BloodyThing.new(whatsit => 42)‚ê§¬ª

[20:02] *** ggoebel joined
[20:03] <skids> You do have to do the assign.

[20:03] <lizmat> ChoHag: BUILD is just receiving a named param that you're not doing anything with

[20:03] <ChoHag> Yes.

[20:03] <lizmat> m: class BloodyThing { has Int $.whatsit = 42; submethod BUILD (:$!whatsit) { say "Hi!" } }.new(whatsit=>7).perl.say

[20:03] <camelia> rakudo-moar d8fa56: OUTPUT¬´Hi!‚ê§BloodyThing.new(whatsit => 7)‚ê§¬ª

[20:03] <ChoHag> So that's more magic down the shitter.

[20:04] <lizmat> well, one could argue that a warning should be issued at compile time when a parameter with a name is not being used in the sub/method

[20:04] <lizmat> m: sub a($) { }   # don't warn

[20:04] <camelia> rakudo-moar d8fa56: ( no output )

[20:05] <lizmat> m: sub a($a) { }   # $a not used in sub a

[20:05] <camelia> rakudo-moar d8fa56: ( no output )

[20:05] <skids> No, I would not like that.

[20:05] <ChoHag> Is there any particular reason why bypassing the attribute's default in a custom BUILD is advantageous?

[20:06] <timotimo> maybe if you have a multi submethod BUILD

[20:07] <skids> lizmat: (Because often you want functions that throw away parameters.)

[20:07] <lizmat> then just don't name the parameters

[20:08] <lizmat> m: sub a($) {}

[20:08] <camelia> rakudo-moar d8fa56: ( no output )

[20:08] <skids> Then you have to write a comment saying what this thing is you threw away.

[20:09] *** ShimmerFairy joined
[20:10] *** llfourn joined
[20:10] <ChoHag> Regardless of absurd notions of purity, if an attribute has a default, and an attribute is being set by virtue of being a named parameter during customised object construction, unless a parameter in the signature overrides its attribute's default with its own that the attribute's default default be the default.

[20:12] <ChoHag> That there's no default supplied in the signature obviously makes it "right" that in that case the variable doesn't have a default value, but it makes even less sense for an attribute's default value to be ignored.

[20:14] *** llfourn left
[20:15] <skids> Maybe $!-twiggled params should default to their current value in general.

[20:15] <ChoHag> Either has $.foo = "thing" should imply '= "thing"' in 'sub BUILD (:$!thing)', or a qualifier could/should be applied to drag in the default default, along the lines of 'sub BUILD (:$!thing with attribute-default)'

[20:16] <ChoHag> Personally I think 'with attribute-default' should be assumed (ie. the first option), but that probably makes overriding a default to nothing difficult.

[20:17] <ChoHag> And now I need to sleep, so I don't get to see the ensuing discussion, if any...

[20:17] <skids> Or like I said, maybe :(:$!foo) would cause $!foo to remain untouched if it was not provided, in which case it would get the default unless you otherwise frobbed it.

[20:18] <ChoHag> That's both options combined, which seems very perl-lik.

[20:19] <skids> The one thing that is missing though is the ability to see what the "has" default is from inside BUILD.

[20:19] *** ChoHag left
[20:19] <skids> But there may be laziness reasons why you should not be able to do that.

[20:26] *** diana_olhovik left
[20:32] * skids adds this conversation to RT#125437 since it is likely when this code will next be touched

[20:32] *** darutoko left
[20:32] <skids> ChoHag++, lizmat++

[20:41] *** araujo left
[20:41] *** araujo joined
[21:05] *** kaare_ left
[21:07] * lizmat wishes #perl6! a good night!

[21:09] <skids> o/

[21:12] *** jjido joined
[21:12] *** lizmat left
[21:25] *** rindolf left
[21:34] *** dustinm` joined
[21:48] *** Hor|zon joined
[21:52] *** Hor|zon left
[21:54] *** TEttinger joined
[21:56] <dalek> nqp/jvm-force-gc: 3fec6e0 | hoelzro++ | src/vm/jvm/ (2 files):

[21:56] <dalek> nqp/jvm-force-gc: Create mapping and implementation for force_gc on JVM

[21:56] <dalek> nqp/jvm-force-gc: review: https://github.com/perl6/nqp/commit/3fec6e073b

[21:56] <dalek> nqp/jvm-force-gc: a317d34 | hoelzro++ | src/vm/jvm/stage0/ (10 files):

[21:56] <dalek> nqp/jvm-force-gc: Re-bootstrap JVM files for force_gc

[21:56] <dalek> nqp/jvm-force-gc: review: https://github.com/perl6/nqp/commit/a317d34a6d

[21:56] <dalek> nqp/jvm-force-gc: 426ca43 | hoelzro++ | src/vm/jvm/HLL/Backend.nqp:

[21:56] <dalek> nqp/jvm-force-gc: Add force_gc implementation for JVM backend

[21:56] <dalek> nqp/jvm-force-gc: review: https://github.com/perl6/nqp/commit/426ca43c74

[22:11] *** llfourn joined
[22:15] *** yqt joined
[22:15] *** BenGoldberg left
[22:15] *** BenGoldberg joined
[22:15] *** llfourn left
[22:16] *** BenGoldberg left
[22:16] *** BenGoldberg joined
[22:21] *** BenGoldberg left
[22:29] *** virtualsue left
[22:31] *** smls left
[22:31] *** smls joined
[22:33] *** diakopter joined
[22:34] <dalek> doc: b82c2cf | smls++ | lib/Language/subscripting.pod:

[22:34] <dalek> doc: Add the /language/subscripting document

[22:34] <dalek> doc: 

[22:34] <dalek> doc: Some sections still need filling in. I've added POD comments to

[22:34] <dalek> doc: guide further work on it.

[22:34] <dalek> doc: review: https://github.com/perl6/doc/commit/b82c2cf2c2

[22:35] *** leont joined
[22:39] <smls> ^^ review welcome.

[22:39] *** smls left
[22:44] *** Zoffix joined
[23:01] *** espadrine left
[23:19] *** raiph left
[23:24] *** cognominal left
[23:28] *** jjido left
[23:35] *** mohij left
[23:35] *** raiph joined
[23:43] *** jjido joined
[23:47] *** RabidGravy left
[23:49] *** Hor|zon joined
[23:49] *** spider-mario left
[23:53] *** Hor|zon left
[23:55] *** jjido left
[23:56] *** cognominal joined
[23:58] *** vendethiel left
[23:59] *** nys joined
