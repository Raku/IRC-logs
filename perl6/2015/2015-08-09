[00:03] <raiph> m: sub foo(Int $x) { say $x; }; my Str $f = "Hi!"; foo $f;

[00:03] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/y6gFxJE7Ac␤Calling foo(Str) will never work with declared signature (Int $x)␤at /tmp/y6gFxJE7Ac:1␤------> 3Int $x) { say $x; }; my Str $f = "Hi!"; 7⏏5foo $f;␤»

[00:03] <raiph> Sgeo: ^^

[00:04] <Sgeo> Ah

[00:05] <raiph> m: sub foo(Int $x) { say $x; }; foo "bar";

[00:05] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ugkiamRWwN␤Calling foo(str) will never work with declared signature (Int $x)␤at /tmp/ugkiamRWwN:1␤------> 3sub foo(Int $x) { say $x; }; 7⏏5foo "bar";␤»

[00:09] *** Peter_R joined
[00:34] *** jjido left
[00:34] *** shinobi-cl left
[00:44] <japhb> m: my Str $f = 12;

[00:44] <camelia> rakudo-moar a32c14: OUTPUT«Type check failed in assignment to '$f'; expected 'Str' but got 'Int'␤  in block <unit> at /tmp/nX6o8GshRQ:1␤␤»

[00:44] <japhb> m: say "Boo!"; my Str $f = 12;

[00:44] <camelia> rakudo-moar a32c14: OUTPUT«Boo!␤Type check failed in assignment to '$f'; expected 'Str' but got 'Int'␤  in block <unit> at /tmp/4enJ6sMDI7:1␤␤»

[00:44] <japhb> Oh interesting, I thought we had that one at compile time already.

[00:45] <japhb> m: say "Boo!"; my Str $f := 12;

[00:45] <camelia> rakudo-moar a32c14: OUTPUT«Boo!␤Type check failed in binding; expected 'Str' but got 'Int'␤  in block <unit> at /tmp/AXkyhR1m8b:1␤␤»

[00:45] <japhb> m: say "Boo!"; my Str $f ::= 12;

[00:45] <camelia> rakudo-moar a32c14: OUTPUT«Boo!␤Type check failed in binding; expected 'Str' but got 'Int'␤  in block <unit> at /tmp/_5Apymdzvo:1␤␤»

[00:45] <japhb> Huh

[01:03] <japhb> Well, after combining a few minutes a week for several weeks, I can happily report: Experiment at putting "plain OO" sugar on top of CQS + event sourcing: SUCCESS.

[01:06] <diakopter> Run command wrote to STDERR: install/bin/perl6 --optimize=3 -e 0

[01:06] <diakopter> Compiler rakudo-moar is failing for test zero, continuing to next compiler/test.

[01:10] <japhb> diakopter: If you cd into the build tree for rakudo-moar/nom (or rakudo-moar/glr or whatever), and run that exact command, what happens?

[01:10] <diakopter> well I gotta fixup my path in a new terminal

[01:11] <japhb> No!

[01:11] <japhb> just open a new terminal, cd to .../perl6-bench/components/rakudo-moar/nom/ and run the command it printed.

[01:11] <japhb> ('install/bin/perl6 --optimize=3 -e 0')

[01:13] <diakopter> oh

[01:13] <diakopter> WARNINGS:

[01:13] <diakopter> Useless use of constant integer 0 in sink context (line 1)

[01:14] <diakopter> "Useless use"; I love it

[01:16] <japhb> So yeah, not a whole lot I can do about that.

[01:16] <japhb> Actually: If we still agree that -e should disable strict, shouldn't it disable warnings and deprecations as well?

[01:21] <geekosaur> that's an infamous perl5 warning too :)

[01:21] <geekosaur> (well, void context instead of sink, but "useless use...")

[01:22] <ShimmerFairy> There's no warnings pragama implemented yet, afaik, so there's nothing for it to disable :)

[01:22] <ShimmerFairy> deprecations would count under warnings. I always thought that perhaps the warning pragma took options, like  'no warnings :deprecations' for instance

[01:35] *** njmurphy joined
[01:43] *** njmurphy left
[01:46] *** leont left
[01:46] *** aborazmeh joined
[01:46] *** aborazmeh left
[01:46] *** aborazmeh joined
[01:53] *** llfourn joined
[01:55] *** colomon left
[01:56] *** colomon joined
[01:57] *** llfourn left
[02:00] *** colomon left
[02:09] *** mr-foobar left
[02:12] *** colomon joined
[02:12] *** gfldex left
[02:17] *** colomon left
[02:17] *** colomon joined
[02:18] *** mr-foobar joined
[02:18] *** cognominal joined
[02:19] *** ggoebel joined
[02:19] *** BenGoldberg joined
[02:21] <skids> m: sub foo (Any:D $x) { say $x; }; my Failure $f = Failure.new; foo($f); # Is actually a successful call (Failure.new is DEFINITE), it is the "say $x" that explodes.

[02:21] <camelia> rakudo-moar a32c14: OUTPUT«Failed␤␤Actually thrown at:␤  in sub foo at /tmp/0Zhjo1PNgf:1␤  in block <unit> at /tmp/0Zhjo1PNgf:1␤␤»

[02:21] <skids> Sgeo: ^^

[02:22] <Sgeo> m: sub foo (none(Failure) $x) { say $x; }; my Failure $f = Failure.new; foo($f);

[02:22] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cHkW23YfPe␤Invalid typename 'none' in parameter declaration.␤at /tmp/cHkW23YfPe:1␤------> 3sub foo (none7⏏5(Failure) $x) { say $x; }; my Failure $f␤»

[02:22] <Sgeo> I thought junctions were allowed as types?

[02:22] <TimToady> no, use a where

[02:23] <Sgeo> Does where use implicit ~~ or just call a closure?

[02:23] <Sgeo> m: sub foo (Any:D $x where {$_ !~~ Failure}) { say $x; }; my Failure $f = Failure.new; foo($f);

[02:23] <camelia> rakudo-moar a32c14: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/05SdFsxKXe:1␤  in block <unit> at /tmp/05SdFsxKXe:1␤␤»

[02:23] <skids> m: sub foo (Any:D $x) { say $x; }; my Failure $f = Failure.new; $f.defined; foo($f); # Also get this to work first before playing with the more explody variety.

[02:23] <camelia> rakudo-moar a32c14: OUTPUT«Failed␤␤»

[02:24] <TimToady> it's a smartmatch

[02:24] <Sgeo> So what's the more concise way to write what I wrote?

[02:24] <Sgeo> m: sub foo (Any:D $x where none(Failure)) { say $x; }; my Failure $f = Failure.new; foo($f);

[02:24] <camelia> rakudo-moar a32c14: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/nqIXvgXbMu:1␤  in block <unit> at /tmp/nqIXvgXbMu:1␤␤»

[02:34] *** cognominal left
[02:37] <skids> Well, you could avoid DRY with:

[02:37] <skids> m: subset Pedantic of Any where { $_ !~~ Failure and $_.defined }; sub foo(Pedantic $x) { 42.say }; my Failure $f = Failure.new; foo($f);

[02:37] <camelia> rakudo-moar a32c14: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/a0ZBaw7QQB:1␤  in block <unit> at /tmp/a0ZBaw7QQB:1␤␤»

[02:38] *** cognominal joined
[02:40] *** noganex_ joined
[02:42] *** noganex left
[02:44] <skids> Or if you prefer to see the actual failures instead of typecheck failures:

[02:44] <skids> m: subset Pedantic of Any where { ($_ ~~ Failure and $_.throw) and $_.defined }; sub foo(Pedantic $x) { 42.say }; my Failure $f = Failure.new; foo($f);

[02:44] <camelia> rakudo-moar a32c14: OUTPUT«Failed␤␤Actually thrown at:␤  in any  at src/gen/m-Metamodel.nqp:2867␤  in block <unit> at /tmp/i7QDD9UxyC:1␤␤»

[02:53] *** mjgardner joined
[02:56] *** cognominal left
[03:12] *** nys left
[03:25] *** llfourn joined
[03:29] *** mjgardner left
[03:32] *** mr-foobar left
[03:33] *** llfourn left
[03:40] *** mr-foobar joined
[04:11] <dalek> roast: d54ea63 | skids++ | S09-hashes/objecthash.t:

[04:11] <dalek> roast: Add tests for RT#118031 which might be closeable.

[04:11] <dalek> roast: review: https://github.com/perl6/roast/commit/d54ea63829

[04:13] <Sgeo> Subsets just put me in mind of pattern matching, is there a way for a subset to return a value to be bound into a variable at use?

[04:18] <skids> What, like an identity value?

[04:19] <raiph> m: subset PositiveInt of Int where +*; my PositiveInt $foo = 42; say $foo

[04:19] <camelia> rakudo-moar a32c14: OUTPUT«42␤»

[04:20] <raiph> m: subset PositiveInt of Int where +*; my PositiveInt $foo = -1; say $foo

[04:20] <camelia> rakudo-moar a32c14: OUTPUT«-1␤»

[04:21] <skids> m: say so +(-1)

[04:21] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[04:21] <raiph> m: subset PositiveInt of Int where * > 0; my PositiveInt $foo = 0; say $foo

[04:21] <camelia> rakudo-moar a32c14: OUTPUT«Type check failed in assignment to '$foo'; expected 'PositiveInt' but got 'Int'␤  in block <unit> at /tmp/SzsYPZ3q7S:1␤␤»

[04:22] <raiph> Sgeo: I don't think I understood your comment...

[04:23] *** llfourn joined
[04:24] <Sgeo> Meh I'm overreaching I think

[04:24] <Sgeo> Although... in a given/when, can the thing given to when return a value that could then be used by the block?

[04:24] <Sgeo> I'm assuming not since that's not how ~~ works

[04:26] <Sgeo> Can ACCEPTS return a non-boolean, and what, exactly, happens if it does?

[04:26] <raiph> m: subset PositiveInt of Int where * > 0; given 0 { say "nay" when not PositiveInt }; given 1 { say "yay" when PositiveInt };

[04:26] <camelia> rakudo-moar a32c14: OUTPUT«nay␤yay␤»

[04:27] <raiph> m: subset PositiveInt of Int where * > 0; given 1 { say "nay" when not PositiveInt }; given 0 { say "yay" when PositiveInt };

[04:27] <camelia> rakudo-moar a32c14: OUTPUT«nay␤»

[04:28] <Sgeo> m: subset PositiveInt of Int where * > 0; say PositiveInt.WHAT

[04:28] <camelia> rakudo-moar a32c14: OUTPUT«(PositiveInt)␤»

[04:28] <Sgeo> So you can smartmatch on subsets?

[04:31] <raiph> m: subset PositiveInt of Int where * > 0; for -1,0,1 { say $_, $_ ~~ PositiveInt }

[04:31] <camelia> rakudo-moar a32c14: OUTPUT«-1False␤0False␤1True␤»

[04:33] <raiph> subsets are just a (sub) type

[04:40] <raiph> m: subset PositiveInt of Int where * > 0; given 1 { say "nay" when none(PositiveInt) }

[04:40] <camelia> rakudo-moar a32c14: ( no output )

[04:44] <raiph> goodnight #perl6

[04:44] *** raiph left
[04:45] <skids> Well, there's always:

[04:45] <skids> m: given 1 { when $f = Int { $_.say; $f.say } }

[04:45] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/SZfk7XX7k6␤Variable '$f' is not declared␤at /tmp/SZfk7XX7k6:1␤------> 3given 1 { when 7⏏5$f = Int { $_.say; $f.say } }␤»

[04:46] <skids> hrm

[04:46] <skids> oh.

[04:47] <skids> m: given 1 { my $f; when $f = Int { $_.say; $f.say } }

[04:47] <camelia> rakudo-moar a32c14: OUTPUT«1␤(Int)␤»

[04:49] *** llfourn left
[04:50] *** ChoHag joined
[04:50] <ChoHag> Does a function with a signature still have access to the signature as a whole in a single variable?

[04:52] *** rilly joined
[04:52] <ChoHag> No. Does a function with a signature still have access to the *capture/argument list* as a whole in a single variable?

[04:54] *** rilly is now known as rilly42

[04:54] <skids> ChoHag: if you want that, use a capture in the sig:

[04:54] *** xinming_ joined
[04:55] <skids> m: my sub a (|c ($a, $b)) { c.perl.say }; a(1,2);

[04:55] <camelia> rakudo-moar a32c14: OUTPUT«\(1, 2)␤»

[04:55] *** aborazmeh left
[04:57] *** xinming left
[04:58] <ChoHag> Thanks that's got it.

[05:23] <Sgeo> m: my sub a (|c ($a, $b)) { c.perl.say }; my $foo = 10; a(1,2, $foo);

[05:23] <camelia> rakudo-moar a32c14: OUTPUT«Too many positionals passed; expected 2 arguments but got 3 in sub-signature of parameter c␤  in sub a at /tmp/AjGMD1zJ2v:1␤  in block <unit> at /tmp/AjGMD1zJ2v:1␤␤»

[05:23] <Sgeo> m: my sub a (|c ($a, $b, $c)) { c.perl.say }; my $foo = 10; a(1,2, $foo);

[05:23] <camelia> rakudo-moar a32c14: OUTPUT«\(1, 2, 10)␤»

[05:23] *** llfourn joined
[05:23] <Sgeo> m: my sub a (|c ($a, $b, $c is rw)) { c.perl.say }; my $foo = 10; a(1,2, $foo);

[05:23] <camelia> rakudo-moar a32c14: OUTPUT«\(1, 2, 10)␤»

[05:24] <Sgeo> oops, c and $c are different variables right?

[05:28] *** kaare__ joined
[05:34] <ChoHag> m: sub foo (Str @things) { @things.perl.say }; my Str @thongs = <a b c d>; foo(@thongs);

[05:34] <camelia> rakudo-moar a32c14: OUTPUT«Array[Str].new("a", "b", "c", "d")␤»

[05:34] <ChoHag> m: sub foo (Str @things) { @things.perl.say }; my Str @thongs = <a b c d>; foo(@thongs[2..*]);

[05:34] <camelia> rakudo-moar a32c14: OUTPUT«Type check failed in binding @things; expected 'Positional[Str]' but got 'Parcel'␤  in sub foo at /tmp/Pt1jiBUXlx:1␤  in block <unit> at /tmp/Pt1jiBUXlx:1␤␤»

[05:35] <ChoHag> Why can't I pass an array slice? Does the ongoing GLR affect this?

[05:38] <rilly42> m: sub foo (Str @things) { @things.perl.say }; my Str @thongs = <a b c d>; foo(@thongs[2..*] but Positional[Str]);

[05:38] <camelia> rakudo-moar a32c14: OUTPUT«("c", "d")␤»

[05:39] <ChoHag> So that answers question 3 - what's an effective workaround?

[05:40] <ChoHag> But is this really desired behaviour?

[05:43] <dalek> roast: 00a9f8a | skids++ | S06-currying/misc.t:

[05:43] <dalek> roast: Add test for RT#123938 which may be closeable

[05:43] <dalek> roast: review: https://github.com/perl6/roast/commit/00a9f8ac02

[05:46] <skids> Well ISTR Parcel is not long for this earth, so something will likely change there.

[05:46] *** jjido joined
[05:47] *** elohmrow joined
[05:48] *** elohmrow left
[05:49] <ShimmerFairy> Sgeo: from earlier, ~~ can return a non-boolean value; the most often instance of this is  "string" ~~ /regex/ :)

[05:50] <Sgeo> And what do when etc. do with this value?

[05:50] <ShimmerFairy> coerce to boolean

[05:50] *** elohmrow joined
[05:51] <Sgeo> There's no way for when's block to access the value itself?

[05:53] <ShimmerFairy> You can access the value passed to 'given' as $_ , but the result of the comparison isn't available AFAIK (and fwiw, I've never heard anyone need it inside 'when' blocks)

[05:56] <ChoHag> Really? You wouldn't want the Match object inside the when?

[05:56] *** cognominal joined
[05:57] <ChoHag> Sgeo: Docs suggest there's a $/ -- regex match. Does that have what you want?

[05:57] *** cognominal left
[05:57] <ChoHag> http://doc.perl6.org/language/variables#Pre-defined_lexical_variables

[05:57] <Sgeo> ChoHag, that's only useful for regexes though, what if I have my own thing that has an ACCEPTS that returns a useful non-bool?

[05:58] <ShimmerFairy> ah yes, forgot about $/ . Latest regex match is put there

[05:58] <ChoHag> But back on the "isn't available", it seems odd that it wouldn't be and odder to suggest it doesn't need to be.

[06:01] *** aborazmeh joined
[06:01] *** aborazmeh left
[06:01] *** aborazmeh joined
[06:02] <ShimmerFairy> I can't think of a place where implicit smartmatching is done and the result of that implicit smartmatch is put somewhere for the user to mess with.

[06:02] <Sgeo> I can think of equivalents in other languages

[06:04] <awwaiid> panda broken? :( . Just tried to upgrade via rakudobrew to moar-2015.07.2, and then rakudobrew build-panda, but panda is mad at me

[06:04] <ChoHag> How do you break out of a loop?

[06:04] <ShimmerFairy> off-hand I can only think of implicit smartmatching happening in when blocks and flipflop ops, and neither of those expose the result of that smartmatch anywhere. I should also point out that ACCEPTS most often does return a boolean, so most often you already know what the value is.

[06:05] <ShimmerFairy> ChoHag: 'last' comes to mind to stop a loop and move on. There are also loop labels, but I'm not very familiar with them.

[06:09] <Sgeo> So, in Haskell with pattern synonyms, this

[06:09] <Sgeo> pattern Head x <- x:xs

[06:10] <Sgeo> Defines a pattern that will match on a list with at least one element (that's what x:xs is, a list with x as the first element and xs as the rest)

[06:10] <Sgeo> So you can write a function like foo (Head x) and then in the body x, the head, will be available

[06:10] <jdv79> could you call perl6 and go opposites wrt to complexity at least in terms of modern langs?

[06:11] <jdv79> or rather, the two extremes

[06:11] <Sgeo> At least Perl 6 doesn't pretend to be statically typed in a useful way. I mean, er

[06:17] <jdv79> Sgeo: have you used go?

[06:17] <Sgeo> I know a bit about it, haven't tried it myself

[06:17] <Sgeo> Let me know when it has generics >.>

[06:17] <jdv79> i just read and watched some conf talks on it...  haven't got beyond toy examples yet.

[06:24] *** jjido left
[06:24] <skids> Sgeo: there seem to be some not-yet-implemented plans for given $capture { when * -> $sig, $sig2 { ... } } to defer binding tests to the when clause's block, which can be pointy/signatured.

[06:25] <skids> Thus giving you access to any of the vars you decide to name

[06:28] <awwaiid> hm. well I installed panda a few more times and now it works.

[06:34] *** xinming_ left
[06:34] *** skids left
[06:34] *** bin_005 joined
[06:34] *** bin_005 left
[06:38] *** bin_005 joined
[06:40] <awwaiid> mmmm nevermind. still broken.

[06:41] <jdv79> maybe try rebooting:)

[06:41] <awwaiid> hehe

[06:43] *** aborazmeh left
[06:43] *** FROGGS joined
[06:48] <awwaiid> jdv79: "rebooting" worked -- aka rakudobrew nuke

[06:50] <ChoHag> The three R's are just as valid outside Windows.

[06:50] <ChoHag> Restart, Reboot, Reinstall.

[07:04] *** rurban joined
[07:11] *** xinming joined
[07:16] *** rindolf joined
[07:17] *** bin_005 left
[07:18] *** bin_005 joined
[07:19] *** darutoko joined
[07:39] *** elohmrow left
[07:44] <jdv79> nice

[07:45] <jdv79> i've resorted to rm -rf'ing and recloning all the time:(

[07:46] <jdv79> well, i recently just keep pristine repos around and cp -r them instead since cloning can take a lot of time

[07:50] <jdv79> well, not exactly but something like that

[07:54] *** espadrine joined
[07:58] <ShimmerFairy> I usually use  git clean -dfx  to clear a repo of any untracked files, and  git reset --hard  to undo any changes I've yet to commit

[08:00] *** TEttinger left
[08:05] <timotimo> in the (not so?) far future, impressionable newbies will be told to "run git -xdf in your / directory" rather than "rm -rf --no-preserve-root /"

[08:08] <jdv79> hmm, i didn't noticed the x option.  i think that's why i sidelined git clean.  nice.  i'll try that next time.

[08:20] *** brrt joined
[08:23] <dalek> roast: 319fcbf | lizmat++ | S04-statements/with.t:

[08:23] <dalek> roast: Remove with/without modifier tests

[08:23] <dalek> roast: 

[08:23] <dalek> roast: They are tested elsewhere

[08:23] <dalek> roast: review: https://github.com/perl6/roast/commit/319fcbfbfb

[08:27] *** llfourn left
[08:27] <brrt> good morning

[08:29] *** mr-foobar left
[08:29] <jdv79> good aft ^H

[08:30] <Sgeo>     (-> Any $x { @e.push: $x }).($j);

[08:30] *** mr-foobar joined
[08:30] <Sgeo> What is the . between the block and arglist fr?

[08:30] <Sgeo> for

[08:36] <brrt> invocation, i think :-)

[08:36] <brrt> the block is the object, circumfix<()> the method

[08:39] <jdv79> iirc in special situations the . can be left out like {} [] ()

[08:39] <lizmat> m: say (Int,Str,"a").map: { next unless $_; $_ }   # works

[08:39] <camelia> rakudo-moar a32c14: OUTPUT«a␤»

[08:39] <lizmat> m: say (Int,Str,"a").map: { next without $_; $_ }   # does not work (yet)

[08:39] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pIRikiEiyH␤Undeclared routine:␤    without used at line 1␤␤»

[08:40] <lizmat> and I wonder whether it shouldn't be possible to reduce the latter to just "next without"  :-)

[08:40] *** haroldwu left
[08:41] <timotimo> "try again, this time without $_"

[08:41] <lizmat> also: maybe this should be fixed by just adding a sub "without" ?

[08:41] <lizmat> m: sub without(\a) { !a.defined }; say (Int,Str,"a").map: { next without $_; $_ } 

[08:41] <camelia> rakudo-moar a32c14: OUTPUT«Cannot call next(Bool); none of these signatures match:␤    ()␤    (Label:D \x)␤  in block <unit> at /tmp/Lt25e46xHX:1␤␤»

[08:42] *** haroldwu joined
[08:42] <lizmat> hmmmm....

[08:42] <lizmat> perhaps not  :-)

[08:43] *** bin_005 left
[08:45] *** bin_005 joined
[08:48] *** BenGoldberg left
[08:51] <Sgeo> m: (1..10).pick(*)

[08:51] <camelia> rakudo-moar a32c14: ( no output )

[08:51] <Sgeo> m: say (1..10).pick(*)

[08:51] <camelia> rakudo-moar a32c14: OUTPUT«1 10 8 6 5 4 3 9 2 7␤»

[08:52] <Sgeo> m: say (1..10).pick(*-1)

[08:52] <camelia> rakudo-moar a32c14: OUTPUT«Cannot call pick(Int: Int, Int, Int, Int, Int, Int, Int, Int, Int, WhateverCode); none of these signatures match:␤    (Range $: *%_)␤    (Range $: Whatever, *%_)␤    (Range $: Cool $n, *%_)␤  in block <unit> at /tmp/43RR90lY07:1␤␤»

[08:52] <Sgeo> Why do all of them have slurpy params?

[08:53] <Sgeo> m: say (1..10).pick("3")

[08:53] <camelia> rakudo-moar a32c14: OUTPUT«9 8 10␤»

[08:53] <Sgeo> Why is this ... why?

[08:53] <Sgeo> Because Perl 5 did it that way?

[08:53] *** jkva joined
[08:54] <timotimo> pick takes a Cool and calls .Int on it

[08:54] <timotimo> coercive parameter

[08:55] *** mr-foobar left
[08:57] <ShimmerFairy> Sgeo: those *%_ are known as "implicit *%_", they appear on all methods so that unrecognized named params can be passed to other multi candidates upon use of nextsame/callsame. Because it somehow makes things more resilient? (I am not a fan of it.)

[08:57] <timotimo> oh, that's what sgeo referred to

[08:57] *** mr-foobar joined
[08:57] <Sgeo> timotimo, the first question referred to what ShimmerFairy said, the second/third referred to what you answered

[08:59] <ShimmerFairy> timotimo: Incidentally I just realized the halfway solution would be to introduce implicit *%_ on only multi methods, and exclude them from 'only' methods, however difficult that may be to implement :) (unless my understanding of *same is off and they can call the same name from inherited classes, which would be surprising to me)

[09:02] *** gfldex joined
[09:02] *** isBEKaml joined
[09:04] <timotimo> thing is, you can introduce a method as a multi method in a derived class, but still want to "nextsame"

[09:08] <ShimmerFairy> timotimo: on the subject of that nqp::while bug: when I copied the deepmap function from to play around with it, I found that adding a simple ($rpa[$i]), line after each loop's nqp::bindpos call makes it work. So apparently the loop needs to reference the list position it just bound, now?

[09:08] <timotimo> ... wtf? :(

[09:08] <timotimo> anyway, i'll be on a drive for about 7 hours in about an hour

[09:08] <timotimo> oh god, i'm running a bit late

[09:08] <timotimo> still need to finish packing

[09:08] <timotimo> see ya!

[09:10] <ShimmerFairy> timotimo: see ya! This is definitely a perplexing bug, hopefully I can figure more examples showing it off.

[09:10] <timotimo> have you looked at the patch itself at all? maybe there's something very bogus i put in there and i was just too blind (or too up-close) to see it?

[09:11] *** jkva left
[09:12] <ShimmerFairy> I looked at git log -p for quite a while. I couldn't figure out any simple changes that affected anything. (The only simple thing I didn't change was putting back the thing that returns a value, because I get the feeling I'd need to undo the rest of the changes to make that work :/ )

[09:13] <ShimmerFairy> timotimo: my best guess is that the registers played with on MoarVM by nqp::while were relied on by some other parts of the VM-based machinery. Which is a very broad and unhelpful guess.

[09:14] <ShimmerFairy> timotimo: anyway, have a good drive regardless! :)

[09:15] *** jkva joined
[09:17] <timotimo> i probably just ought to look at the spesh dump and the obvious problem will smack me in the face

[09:18] <ShimmerFairy> if spesh is an optimizer thing (been a while since I heard it), I could easily see the lack of return value allowing the optimizer to accidentally remove something.

[09:18] * ShimmerFairy is briefly reminded of the 'volatile' keyword in C++ :)

[09:19] <timotimo> wellllll, if the code-gen knows something wants a/the return value, it'll generate an object register and set it to null (i think?)

[09:19] <timotimo> otherwise it'll set the resulting piece of code to have a VOID return value

[09:20] <timotimo> you should have a look at spesh, it's cool. set MVM_SPESH_LOG=foo.txt and you'll get the before and after bytecode of frames in the spesh-generated SSA form

[09:21] <ShimmerFairy> timotimo: you got rid of  push_op(@loop_il, 'set', $res_reg, @comp_ops[0].result_reg);  (which seems like it could be the source of issues, but I'm not sure if it works without paying attention to the requested object type like the before code), and some IMM_ARG stuff I assume is irrelevant now.

[09:21] <ShimmerFairy> I'll be sure to look at spesh output, then :)

[09:21] <timotimo> just in general :)

[09:22] <timotimo> there's a tool in moarvm/tools called "graph_spesh" that'll generate a graphviz graph for a single frame you've copy-pasted in

[09:22] <ShimmerFairy> timotimo: for the record, I could've just reverted the commit (and in a more production-driven setting, probably would have), but I'm just too interested in figuring out _what_ the problem is :P

[09:23] <timotimo> i'm glad to hear you're not working on it because i've been begging for help, but because you're enjoying it, too :)

[09:25] <ShimmerFairy> The fact that something so innocuous as » was broken is interesting, and after looking a bit into it, it's _really_ perplexing :)

[09:25] <timotimo> but be careful: going too deep into the backendy things may lead you to become a moarvm dev :P

[09:26] <nine> One does not simply walk into MoarVM.

[09:26] <ShimmerFairy> m: ((97,), (102,))».chrs.say # welp, could be related to strings too then?

[09:26] <camelia> rakudo-moar a32c14: OUTPUT«a f␤»

[09:26] <timotimo> what if we used a catapult to bring the bytecode right into the underlying hardware?

[09:27] <timotimo> m: ("a", "b")>>.ords.say

[09:27] <camelia> rakudo-moar a32c14: OUTPUT« ␤»

[09:28] <timotimo> m: ("abc", "bcd")>>.ords.say

[09:28] <camelia> rakudo-moar a32c14: OUTPUT« ␤»

[09:28] <timotimo> well, to be fair

[09:28] <timotimo> if the thing ords returns is a bit different, it'll work out

[09:28] <timotimo> have you seen my golfs yesterday? (or was that the day before?)

[09:28] <timotimo> where i tried to emulate different kinds of .ords?

[09:28] <ShimmerFairy> I'm having trouble getting it to find MAST::Ops :/

[09:28] <timotimo> i had to specifically put in a (^5).map or something

[09:28] <ShimmerFairy> I'm not sure I did.

[09:29] <timotimo> you may have to run update_ops.p6?

[09:29] <timotimo> the MAST::Ops.pm6 may be missing from the git repository or something

[09:29] <timotimo> *mumble mumble*

[09:29] *** rurban left
[09:29] <ShimmerFairy> maybe, there _is_ an Ops.p6 file in there, which I guess doesn't count as a module file.

[09:30] * timotimo disappears for a bit

[09:30] *** RabidGravy joined
[09:30] <Sgeo> m: say Array.WHENCE

[09:30] <camelia> rakudo-moar a32c14: OUTPUT«Method 'WHENCE' not found for invocant of class 'Array'␤  in block <unit> at /tmp/eph7ktf7FA:1␤␤»

[09:31] *** rurban_ joined
[09:31] *** rurban joined
[09:36] *** isBEKaml left
[09:38] *** cognominal joined
[09:45] *** diana_olhovik_ joined
[09:53] *** brrt left
[10:00] *** jjido joined
[10:01] *** jjido left
[10:11] *** araujo left
[10:14] *** araujo joined
[10:23] *** BenGoldberg joined
[10:23] *** llfourn joined
[10:24] *** leont joined
[10:25] *** araujo left
[10:27] *** llfourn left
[10:30] *** FROGGS left
[10:32] *** araujo joined
[10:34] *** telex left
[10:35] *** llfourn joined
[10:36] *** telex joined
[10:37] *** rurban left
[10:43] *** isBEKaml joined
[10:44] <timotimo> WHENCE is something a scalar can have

[10:45] <timotimo> ... waiting for the transporter to arrive so we can put our stuff in (and i can drive it a part of the way)

[10:45] <jnthn> afternoon, #perl6 o/

[10:45] <nwc10> good UGT heresy, jnthn

[10:46] <timotimo> ohai jnthn 

[10:46] <timotimo> how are you on this fine sunday?

[10:46] <jnthn> Not too bad

[10:47] <jnthn> At least it's not as insanely hot today as it was yesterday...

[10:48] *** bin_005_d joined
[10:49] *** bin_005 left
[10:53] <nine> It's not?

[10:54] <jnthn> nine: Not here :)

[10:54] <jnthn> Yesterday here hit 40C. Today it's not meant to get too far over 30C

[10:56] <isBEKaml> jnthn: I always wonder why people say "It's not meant to be this hot" or "It's not meant to go over 30C today" esp. when talking about the capricious weather ;-)

[10:58] <nine> 40C?! "insane" is a good word for that :) Where is this insane "here" if I may ask?

[10:58] <jnthn> nine: Prague

[10:58] <jnthn> nine: I...don't think this is particularly normal weather for here.

[10:59] <nine> That's just 200km north east of here.

[11:01] *** smls joined
[11:04] <nine> Ok, having compiled a perl and installed hundreds of modules for the third time, I can conclude, that my refcounting error simply does not occur on a perl built with debugging options enabled

[11:05] <jnthn> Does not occur, or is hidden by?

[11:05] * jnthn has a had a lot of incidences of "bug vanishes under the debugger", simply 'cus memory ends up organized differently

[11:06] <nine> Probably the latter. Though ironically those debug options are there to actually make those bugs more visible.

[11:07] <jnthn> Yeah, sadly that doesn't always work out as well as hoped. I've had SEGVs re-appear by disabling the debug malloc library that adds in some extra checks to catch bugs...

[11:08] <nine> The good news is: the 17000 tests of our production codebase pass, even when I extend a central DBIX::Class resultset's class using Inline::Perl6 :)

[11:09] <nine> With the debug options enabled, the somewhat reproducable "Attempt to free unreferenced scalar: SV 0x1d6051f0 during global destruction" messages seem to get replaced by extremely rare segfaults that vanish when run under gdb

[11:10] <smls> jnthn: Post-GLR, does .[] still flatten its arguments? Do X and Z still flatten their arguments?

[11:10] <smls> In pmichaud's design, those were outstanding questions I believe.

[11:11] <jnthn> nine: The OSX debug malloc has a malloc_history command where you can feed it a memory address and it'll tell you the "history" of its allocations/frees.

[11:11] <smls> Also, (1, 2, 4, 8 ... *)[10] will have to be written as (1, 2, 4, 8 ... *).list[10], right? (Just making sure I understand correctly.)

[11:12] <jnthn> nine: Dunno if there's a similar feature on whatever platform you're devloping on (if it's not OSX... :))

[11:12] <jnthn> smls: The sequence one is easy to answer: yes, you'll need the .list there

[11:12] <nine> jnthn: I'm bearded and long haired. I have to use Linux :)

[11:15] <jnthn> smls: I didn't do .[] and X/Z in the work so far. I don't think I can see a reason for X and Z to .flat their arguments.

[11:16] <smls> ok

[11:16] <jnthn> smls: As for .[...] I'd be inclined to take the same route as with [...] and array assignment

[11:16] <smls> right

[11:16] <jnthn> .[@a] # slice based on things in @a, like today

[11:16] <jnthn> .[1, 2, 3] # also as today

[11:17] <nine> New debugging strategy: adding a warn $self in every place where I create an object that is going to be passed to Perl 6 code and use my terminal's Find to match the unreferenced scalar's address to constructed object's ones. Now I finally know _which_ object's refcount is wrong :)

[11:17] <smls> though from a practical POV, it's less useful to befine a nested list as .[] arg only to have sublists interpreted as their lengths

[11:17] <jnthn> .[$@a] # also as today

[11:17] <smls> .[1, 2, 5..8, 10]  # in this case, flattening would be more DWIMMy

[11:18] <jnthn> It would, but we'll pay for it on every single slice. Do we want that?

[11:19] <smls> Does flattening *have* to be expensive?

[11:19] <smls> Isn't it supposed to be lazy?

[11:19] <jnthn> How would laziness help here when we need all the values?

[11:19] <jnthn> It's not that it's expensive per se, but it's not free either.

[11:19] <smls> well, maybe lazy is not the right word her

[11:20] <smls> I meant, doesn't have to really affect lists that are already flat

[11:20] <jnthn> Well, .flat on an Array returns identity

[11:20] <jnthn> uh

[11:20] <jnthn> No, it doesn't

[11:20] <jnthn> It returns a Seq with a normal iterator for the array

[11:20] <jnthn> But it knows it doesn't have to do any work.

[11:21] <jnthn> Aside from iterate through the things.

[11:21] <jnthn> Anyway, if you can show me globs of real world code that do .[1, 2, 5..8, 10] I'll probably be more intrested.

[11:21] <jnthn> I don't care much for "it'll DWIM on this hypothetical example"

[11:22] <smls> ignoring the actual inner workings and only looking at the *effective* behavior,   for @elems { when Positional { .length } ... }    and   for @elems { when Positional { #.[iterate sublist] } ... }   would be expected to have the same performance on already-flat lists, no?

[11:23] <jnthn> You're confusing Positional with Iterable

[11:23] <jnthn> But sure, they would, except you actually have to do the loop

[11:23] <jnthn> And the check

[11:26] <smls> wouldn't you have to do it regardless?

[11:26] <smls> In any case, I suppose having to write   .[flat 1, 2, 5..8, 10]  or  .[1, 2, |(5..8), 10]  wouldn't be so bad either.

[11:26] <jnthn> Yes, that's what I'd prefer.

[11:27] <jnthn> I just don't recall seeing things like this often enough in real world code to think it's worth pessimizing everything for.

[11:34] * jnthn notes we're fast converging on a design where the only "magical" flattening happens through slip, and everywhere else you ask for it (with taking a slurpy *@foo counts as asking for it)

[11:36] <smls> On that note, what built-ins will "magically" use Slip?

[11:37] <smls> Will .map({ .foo, .bar }) automatically return a Slip to make the result list flat?

[11:37] <dalek> Inline-Perl5: db25ccf | (Stefan Seifert)++ | p5helper.c:

[11:37] <dalek> Inline-Perl5: Fix one source of "Attempt to free unreferenced scalar during global destruction"

[11:37] <dalek> Inline-Perl5: 

[11:37] <dalek> Inline-Perl5: This was just left over code from before the inheritance re-design.

[11:37] <dalek> Inline-Perl5: No need to create a new reference to bless the object. We can just bless

[11:37] <dalek> Inline-Perl5: the reference we were passed.

[11:37] <dalek> Inline-Perl5: 

[11:37] <dalek> Inline-Perl5: The "unreferenced scalar" error came, because we used newRV_noinc to

[11:37] <dalek> Inline-Perl5: create the reference and then never increased or decreased the refcount

[11:37] <dalek> Inline-Perl5: afterwards. Without an SvREFCNT_dec, perl never gets a chance to free

[11:37] <dalek> Inline-Perl5: the SV and rightfully complains about that when it finds it during

[11:37] <dalek> Inline-Perl5: shutdown.

[11:37] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/db25ccfef3

[11:37] *** fxer joined
[11:37] <jnthn> smls: Nothing magically makes a slip

[11:37] <smls> ok

[11:37] <jnthn> smls: They just magically interpolate it

[11:38] <jnthn> smls: So map is aware that it should check values coming back for it

[11:39] <jnthn> smls: Since it's type based, we'll also (later) be able to elide the check for map blocks that declare a return type.

[11:39] <jnthn> .map(-> $x --> Int { ... }) # Slip impossible

[11:39] <smls> neat

[11:45] <dalek> rakudo/glr: fc933f7 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[11:45] <dalek> rakudo/glr: Also stub Slip in the BOOTSTRAP.

[11:45] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/fc933f70f7

[11:45] <dalek> rakudo/glr: b8355fe | jnthn++ | src/core/core_prologue.pm:

[11:45] <dalek> rakudo/glr: Stub Iterable, set up Empty constant.

[11:45] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b8355fe887

[11:45] <smls> jnthn: Will .grep on a Seq return a new Seq, or a List that remembers all values?

[11:47] *** bin_005_d left
[11:47] <smls> "map/grep/etc., gather/take, and ... (and likely more) all return a Seq."  ok, never mind then :P

[11:47] <jnthn> smls: A new Seq

[11:48] <jnthn> And if you .grep a HyperSeq you get back a HyperSeq

[11:48] <smls> So that's a break from the current semantics of having map/grep always return the same type (currently Parcel)?

[11:49] <smls> Will you extend that to things like native arrays so that  .map/.grep  will return a new native array?

[11:52] *** Aurelie joined
[11:53] <jnthn> .map and .grep will always return a Seq

[11:53] <smls> btw, yay for   "for loop over gather/take ==> was 5.86534547805786s, now 0.880507230758667s".

[11:54] <jnthn> *unless* you already did .hyper() and opted into parallel processing, in which case you'll get a HyperSeq

[11:54] <smls> ok

[11:55] <jnthn> Basically, most operations (map, grep, etc.) take you into a "pipeline mode". .hyper and .race take you into a "parallel pipeline mode".

[11:56] <jnthn> And you get out of it with an array assignment, coercion, or an operation that is some form of reduction.

[11:57] <jnthn> .eager is the only thing I'm aware of that keeps you in pipeline mode, but also introduces intermediate memory of values

[11:57] <jnthn> (And it only does that if it has to)

[11:58] <smls> So .eager does not immediately iterate its invocant, but only marks it to be iterated eagerly once iterating starts?

[11:59] <jnthn> Yeah

[11:59] <smls> ok

[11:59] <jnthn> I thought about whether that was right

[12:00] <jnthn> The thing that kinda forced it was that I realized that making it that way made it possible to make "my @a = eager @b.map(...);" cost pretty much what it would without the eager if the eager was equivalent to just evaluating up to the first lazy thing.

[12:00] <jnthn> That is, in that case I can avoid the intermediate buffer

[12:01] <smls> right

[12:03] <smls> Will there be a way to get the nth value of a sequence, without having to store all n-1 prior values in memory?

[12:04] <smls> Thinking about things like    constant @primes = grep, *.is-prime, 1..*;  say "The hundreth prime is @primes[99];

[12:05] *** [Sno] joined
[12:05] *** ][Sno][ left
[12:05] <smls> If it has to be written as @primes.list[99] it will store everything, right?

[12:05] *** isBEKaml left
[12:05] <jnthn> Actually that will be a compile-time error, 'cus Seq isn't Positional

[12:05] <jnthn> So the bind to the @primes symbol will fail

[12:06] <jnthn> Unless we decide that such a constant declaration will be a place we call .list for you

[12:06] <jnthn> Which we may need to do given constant %h = a => 1, b => 2; can only work if we call .hash for you.

[12:06] <smls> Ah. So no more   my @fib := 1, 1, *+* ... *;    either.

[12:07] <jnthn> Right, that'll have to be ::= or, you know, just = :)

[12:07] *** brrt joined
[12:11] <smls> What would ::= turn it into, a List?

[12:12] <jnthn> yes

[12:15] <dalek> rakudo/glr: 6e7f804 | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[12:15] <dalek> rakudo/glr: Fix silly thinkos in tweak to p6recontrv op.

[12:15] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6e7f804c7e

[12:21] <jnthn> lunch; bbiab

[12:23] *** kaare__ left
[12:27] *** nys joined
[12:27] *** fxer left
[12:29] *** jkva left
[12:43] *** azawawi joined
[12:43] <azawawi> hi

[12:44] *** brrt left
[12:44] <azawawi> what's perl 6 syntax for MyModule->my_sub?

[12:44] *** xinming left
[12:44] *** xinming joined
[12:45] <RabidGravy> you mean "module Foo { our sub bar() { } };  Foo::bar();" ?

[12:45] <azawawi> cool thx

[12:46] <RabidGravy> the "our" is important there

[12:50] *** Aurelie left
[13:02] *** fxer joined
[13:07] *** leont left
[13:11] <azawawi> m: module Foo { our sub foo() { say "Foo called"; } }; say Foo::<foo>.defined;

[13:11] <camelia> rakudo-moar a32c14: OUTPUT«False␤»

[13:12] *** rmgk_ joined
[13:12] *** rmgk left
[13:12] *** rmgk_ is now known as rmgk

[13:12] <smls> m: module Foo { our sub foo() { say "Foo called"; } }; say Foo::<&foo>.defined

[13:12] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[13:12] <smls> need a & to refer to subroutines as nouns

[13:13] <smls> According to the design docs, &Foo::<foo> should also work I think, but doesn't in Rakudo.

[13:14] <azawawi> it is confusing from an OOP Java background :)

[13:14] <azawawi> why could we simply say Foo.meta<foo>.defined...

[13:15] <smls> what would be the benefit of that?

[13:15] <smls> Perl 6 has sigil while languages like Java don't; that's just something one has to get used to.

[13:16] <smls> *sigils

[13:17] <azawawi> so & is an operator or a sigil for module/sub reference?

[13:17] <smls> it is a sigil for referring to the function object of a subroutine

[13:18] <smls> because a bare subroutine name *calls* it.

[13:18] <smls> m: say &lc;

[13:18] <camelia> rakudo-moar a32c14: OUTPUT«sub lc (Cool $s) { #`(Sub|54401328) ... }␤»

[13:19] *** skids joined
[13:19] <smls> m: say rand; say &rand;   #clearer example

[13:19] <camelia> rakudo-moar a32c14: OUTPUT«0.746277711735317␤sub rand ( --> Num) { #`(Sub|50532104) ... }␤»

[13:23] <azawawi> smls: thanks for the explanation

[13:25] *** jkva joined
[13:29] *** jkva left
[13:30] * jnthn wonders how two non-OO languages features can be confusing from any OOP background... :-)

[13:32] <jnthn> The closet Perl 6 equivalent to a Java static method is a Perl 6 method that happens to not access any attributes.

[13:32] <jnthn> (Except Perl 6 ones are virtual)

[13:38] <nine> azawawi: the equivalent to MyModule->my_sub is MyModule.my_sub. Or rather MyModule.my_method, since a sub that's called with -> really is (used as) a method in Perl 5.

[13:44] *** rilly42 left
[13:49] *** lolisa joined
[13:50] <azawawi> jnthn: true but remember JavaClass.staticMethod is way simpler to remember than MyP6Module::our_sub :)

[13:51] <azawawi> jnthn: s/remember/remember that/

[13:52] *** aborazmeh joined
[13:52] *** aborazmeh left
[13:52] *** aborazmeh joined
[13:52] <azawawi> File::HomeDir->my_home is a bit more elegant than File::HomeDir::my_home. Please note the extra :: namespace noise at the end

[13:54] <RabidGravy> azawawi, if the my_home doesn't need to use any attributes of an instance then it can be a method

[13:56] <RabidGravy> so e.g

[13:57] <RabidGravy> m: class Foo { method bar() { say "bar" } }; Foo.bar

[13:57] <camelia> rakudo-moar a32c14: OUTPUT«bar␤»

[13:57] <azawawi> RabidGravy: i switch between production java, javascript and experimental perl 6 script every day... so yeah confusion does happen :)

[13:57] *** kaare__ joined
[13:57] <RabidGravy> :)

[13:58] <RabidGravy> as soon as you add an attribute it goes wrong

[13:59] <azawawi> RabidGravy: my main worry is that future p6 programmers will use classes instead of modules because of the syntax

[13:59] <RabidGravy> m: class Foo { has $!thing = "bar"; method bar() { say $!thing; } }; Foo.bar

[13:59] <camelia> rakudo-moar a32c14: OUTPUT«Cannot look up attributes in a type object␤  in method bar at /tmp/4Yx9fUWC0t:1␤  in block <unit> at /tmp/4Yx9fUWC0t:1␤␤»

[14:00] <azawawi> m: class Foo { my $thing = "bar"; method bar() { say $thing; } }; Foo.bar

[14:00] <camelia> rakudo-moar a32c14: OUTPUT«bar␤»

[14:00] <azawawi> so my is afterall a static shared modifier :)

[14:01] <ShimmerFairy> I don't think Foo::bar is as bad as you're making it out to be, honestly.

[14:01] <nine> azawawi: there's still EXPORT for modules providing subs

[14:01] <azawawi> nine: i know :)

[14:06] <dalek> roast: 2b1c2dc | skids++ | S04-phasers/begin.t:

[14:06] <dalek> roast: Add (fudged) test for RT#123777

[14:06] <dalek> roast: review: https://github.com/perl6/roast/commit/2b1c2dcb8b

[14:13] *** rurban_ left
[14:14] *** aborazmeh left
[14:15] <dalek> roast: afea75d | skids++ | S04-phasers/begin.t:

[14:15] <dalek> roast: Add (fudged) test for RT#123776

[14:15] <dalek> roast: review: https://github.com/perl6/roast/commit/afea75d769

[14:17] <dalek> rakudo/glr: 9f00b92 | jnthn++ | / (6 files):

[14:17] <dalek> rakudo/glr: Toss various *Iter classes.

[14:17] <dalek> rakudo/glr: 

[14:17] <dalek> rakudo/glr: They're being replaced as part of GLR, and are no longer top-level

[14:17] <dalek> rakudo/glr: visible types.

[14:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9f00b920fb

[14:17] <dalek> rakudo/glr: c4ad536 | jnthn++ | / (4 files):

[14:17] <dalek> rakudo/glr: Toss Parcel and LoL (go away in GLR).

[14:17] <dalek> rakudo/glr: 

[14:17] <dalek> rakudo/glr: We still need to resolve what type a semilist produces, but it may not

[14:17] <dalek> rakudo/glr: end up being called LoL, and certainly won't end up the same on the

[14:17] <dalek> rakudo/glr: inside.

[14:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c4ad5362d9

[14:21] <smls> .oO( MultiList )

[14:22] *** colomon left
[14:22] <jnthn> Given it doesn't have to be lazy on the first level and doesn't have to support assignment, and it's really an implementation type, I think a little bit about whether it wants to be one of those low-level types (based on VMArray)

[14:23] <jnthn> So far I think that **@foo will just be a List like *@foo

[14:23] <jnthn> The latter just binds an iterator that flattens the incoming things

[14:30] <dalek> roast: a7118a8 | skids++ | S14-roles/basic.t:

[14:30] <dalek> roast: Add test for RT#120646 which is closeable now

[14:30] <dalek> roast: review: https://github.com/perl6/roast/commit/a7118a85c0

[14:30] <ShimmerFairy> jnthn: the only thing I can think of where a multi-dim array would be useful would be with shaped multi-dim variables, e.g. my @foo[3;2];  I'm not sure how that would look if it was just a List of Lists, for example. (Put another way, I don't know how similar List of Lists would be to std::vector<std::vector<...>> in terms of being not-so-structured :P)

[14:30] *** azawawi left
[14:31] <jnthn> sivoais: To be clear, I'm discussing what the type of the "3;2" is

[14:31] <jnthn> oops

[14:31] <jnthn> ShimmerFairy: ^^

[14:33] *** araujo left
[14:33] <ShimmerFairy> ah

[14:34] *** rurban joined
[14:36] <ShimmerFairy> For 3;2 specifically, offhand I only see those happening in [] subscripts and as a convenient way of writing out multi-dim lists (that is, @list = (1,2;3,4;5,6) ), so maybe a low-level type for the cases where it's not just convenience syntax would be appropriate.

[14:36] *** maettu joined
[14:37] <skids> Well, we'll know after we implement Keccak I guess. :)

[14:37] <ShimmerFairy> the only place such a low-level type would crop up would then be in custom definitions of [] subscripting, I think.

[14:38] <jnthn> To be clear what I mean by "low level", I don't mean it behaves extremely weirdly

[14:38] <jnthn> Just that you can't mix in to it, and if you inherit from it you can't add attributes.

[14:38] <ShimmerFairy> something akin to the native types then, if I understand correctly?

[14:39] <jnthn> Pretty much

[14:39] <jnthn> native arrays and bufs behave the same way, fwiw

[14:41] <ShimmerFairy> I can't think of enough cases for a multidim array that can't be handled by putting Positionals inside Positionals to justify the "prominence" of a higher-level type :)

[14:41] <dalek> rakudo/glr: 378fcdd | jnthn++ | / (3 files):

[14:41] <dalek> rakudo/glr: Add IterationBuffer to CORE.setting.

[14:41] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/378fcddfe0

[14:41] <dalek> rakudo/glr: e7293c5 | jnthn++ | / (9 files):

[14:41] <dalek> rakudo/glr: Add GLR iterator/iterable bits to CORE.setting.

[14:41] <dalek> rakudo/glr: 

[14:41] <dalek> rakudo/glr: This replaces Iterable and Iterator (swapping around their order in

[14:41] <dalek> rakudo/glr: the build) with the versions from the intial GLR exploration. It also

[14:41] <dalek> rakudo/glr: brings in a number of related types that are part of the iteration

[14:41] <dalek> rakudo/glr: API.

[14:41] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e7293c51e1

[14:42] <jnthn> ShimmerFairy: It's primarily a dispatch question as to why ; can't just produce List, fwiw.

[14:42] <jnthn> postcircumfix:<[ ]> needs to distinguish @a[1,2,3

[14:42] <jnthn> postcircumfix:<[ ]> needs to distinguish @a[1,2,3] from @a[1;2;3]

[14:42] <smls> ShimmerFairy:  Having LoL as a separate type allows things like   postcircumfix []   and   prefix |   to dispatch based on type.

[14:43] <smls> Maybe user-defined things will want dto do the same

[14:43] <ShimmerFairy> smls: yeah, I acknowledged that already :)

[14:44] *** khw joined
[14:44] <smls> it might not necessarily be custom implementations on [] though

[14:44] <ShimmerFairy> jnthn: heh, I can't think of another way to handle that aside from a distinct type. (maybe with a really ugly 'where' clause. _maybe_.)

[14:45] <smls> people miught find other places where a similar distinction is needed

[14:45] <smls> in custom APIs

[14:45] <jnthn> It pretty much has to be a type distinction

[14:45] <ShimmerFairy> jnthn: just ooc, would this multidim type be n-dimensional, or is it just, say, 2-dimensional?

[14:45] <jnthn> Most of our interesting optimizations hang off type distinctions.

[14:46] <jnthn> ShimmerFairy: It's not anything dimensional really

[14:46] <jnthn> ShimmerFairy: It's the thing you (primarily) use to talk about accessing something that *is* multi-dimensional

[14:46] <jnthn> ShimmerFairy: And its number of elements will typically match the number of dimensions the target you're indixing into has

[14:47] <jnthn> my @a[3;3]; @a[0;0] = 42; # @a is 2-dimensional, so 0;0 has two elements

[14:47] <jnthn> Well, "so" is a bit misleading, but... )

[14:48] <ShimmerFairy> So it's more like a wrapper, then? If so, then I understand :)

[14:48] <jnthn> It's a thingy that holds the indexes you want to apply to the different dimensions.

[14:49] <ShimmerFairy> Yeah, it's not a new array implementation, just a description of an array that's more interesting than the usual 1-dimensional varieties, as I understand it. :)

[14:51] <jnthn> Yeah, data strucutre wise it's terribly boring. We only care for the type distinction.

[14:52] *** lucasb joined
[14:52] *** diana_olhovik_ left
[14:52] <smls> jnthn: pre-GLR, LoL is also being used for other things that describing indices though.

[14:53] <smls> For example, .tree returns a LoL

[14:53] <ShimmerFairy> .oO( sub postcircumfix:<[ ]>(MultiDimIndices $a) { ... } )

[14:53] <lucasb> omg, GLR is Getting LoL Removed?

[14:54] <smls> jnthn: And .tree is needed pre-GLR to work around excessive flattening when dealing with things like metaops, e.g.   @a X (@b Z @c).tree.list

[14:54] <timotimo> NO LOL

[14:54] <ShimmerFairy> smls: I think think those uses of LoL would just be Lists of Lists now :P

[14:55] <jnthn> You can all still work on project euler though :P

[14:55] <smls> ShimmerFairy: yeah, looks like it.

[14:55] <jnthn> smls: Right, I don't think we'll need .tree anything like so often

[14:56] <jnthn> smls: And maybe it'll want to be more about itemizing

[14:57] <ShimmerFairy> I wasn't aware of .tree , much less its use to prevent excessive flattening. On the one hand I wonder where I could've used it, but on the other I'm glad that soon I won't have to find out :)

[14:57] *** isBEKaml joined
[14:57] <smls> jnthn: yeah

[14:58] <smls> jnthn: Though it  .tree   is just a shortcut for  .map(*.item)  maybe it's not needed at all... :P

[14:58] <jnthn> smls: There's also that, yes. :)

[14:59] *** Zoffix_ is now known as Zoffix

[14:59] *** llfourn left
[15:01] <dalek> rakudo/glr: 9236d43 | jnthn++ | / (6 files):

[15:01] <dalek> rakudo/glr: Bring in Seq and HyperSeq from initial GLR work.

[15:01] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9236d43216

[15:01] <maettu> 2.5 weeks until P6 hackathon @perl-workshop.ch :-) 

[15:02] <jnthn> \o/

[15:04] <dalek> roast: b3831d1 | skids++ | S32-str/comb.t:

[15:04] <dalek> roast: Add (fudged) tests for RT#123760 which could perhaps be tagged LHF

[15:04] <dalek> roast: review: https://github.com/perl6/roast/commit/b3831d1341

[15:05] <ChoHag> Oh is GLR working its way into core now?

[15:06] *** maettu2 joined
[15:06] *** maettu2 left
[15:07] <skids> ChoHag: jnthn++ is working it in in a branch

[15:07] <ChoHag> Nifty.

[15:07] *** maettu left
[15:07] *** colomon joined
[15:08] *** rurban left
[15:09] *** maettu joined
[15:17] *** pmurias joined
[15:24] <dalek> roast: 1e0f7ad | skids++ | S12-coercion/coercion-types.t:

[15:24] <dalek> roast: Mention both RT#123770 and RT#124839.  These tickets should be merged.

[15:24] <dalek> roast: review: https://github.com/perl6/roast/commit/1e0f7ad8ea

[15:26] <jnthn> Any idea why minmax is taking **@args rather than *@args like min and max?

[15:28] * jnthn just tosses the **

[15:28] <jnthn> The tests'll tell me

[15:31] <RabidGravy> that's the spirit

[15:35] <arnsholt> I do that all the time. Refactor some thing, and then just give the tests a whack to see what falls out =)

[15:36] <nine> That's what tests are for ;)

[15:39] *** colomon left
[15:42] <dalek> rakudo/glr: 1e0eb3c | jnthn++ | src/core/Any.pm:

[15:42] <dalek> rakudo/glr: Toss reference to MapIter.

[15:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1e0eb3cbe1

[15:42] <dalek> rakudo/glr: 6f887c7 | jnthn++ | src/core/Mu.pm:

[15:42] <dalek> rakudo/glr: Add GLR note about Mu.infinite.

[15:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6f887c71f9

[15:42] <dalek> rakudo/glr: c01a6ba | jnthn++ | src/core/Any.pm:

[15:42] <dalek> rakudo/glr: Clean up list/hash coercion-y methods.

[15:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c01a6ba221

[15:42] <dalek> roast: df84392 | skids++ | S32-scalar/perl.t:

[15:42] <dalek> roast: Add test for RT#123741 which can likely be closed

[15:42] <dalek> roast: review: https://github.com/perl6/roast/commit/df84392d05

[15:43] *** llfourn joined
[15:47] <dalek> rakudo/glr: e8423e0 | jnthn++ | src/core/Any.pm:

[15:47] <dalek> rakudo/glr: () will make a List, so ().list is just () now.

[15:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/e8423e09b6

[15:47] <dalek> rakudo/glr: b98bc5f | jnthn++ | src/core/Any.pm:

[15:47] <dalek> rakudo/glr: Fix double-coercion thinko.

[15:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b98bc5f756

[15:47] <dalek> rakudo/glr: 23eb297 | jnthn++ | src/core/Any.pm:

[15:47] <dalek> rakudo/glr: Toss .lol and comment out .tree for now.

[15:47] <dalek> rakudo/glr: 

[15:47] <dalek> rakudo/glr: And leave GLR note on tree as something needing resolving.

[15:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/23eb2973a5

[15:48] <nine> YES YES YES! I got it :)

[15:48] <dalek> Inline-Perl5: f018d4b | (Stefan Seifert)++ | p5helper.c:

[15:48] <dalek> Inline-Perl5: Fix "Attempt to free unreferenced scalar during global destruction"

[15:48] <dalek> Inline-Perl5: 

[15:48] <dalek> Inline-Perl5: Arguments to Perl 6 methods or callables are passed as array reference.

[15:48] <dalek> Inline-Perl5: We created the array, and created a reference to this array to pass it

[15:48] <dalek> Inline-Perl5: on to Perl 6 code. After the call we decreased the refcount of the array

[15:48] <dalek> Inline-Perl5: instead of this reference.

[15:48] <dalek> Inline-Perl5: 

[15:48] <dalek> Inline-Perl5: The reference then got leaked and would be collected by perl during

[15:48] <dalek> Inline-Perl5: global deconstruction. The reference's dtor would then try to decrease

[15:48] <dalek> Inline-Perl5: the refcount of the array it was referencing which already was

[15:48] <dalek> Inline-Perl5: destroyed.

[15:48] <dalek> Inline-Perl5: 

[15:48] <dalek> Inline-Perl5: This is what Perl was detecting and the source of the error.

[15:48] <dalek> Inline-Perl5: Fixed by decreasing the refcount of the reference instead of the array.

[15:48] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/f018d4bbc2

[15:49] <jnthn> nine++ 

[15:49] <nine> I'm so glad we're getting rid of refcounting in Perl 6. This is horrible :)

[15:50] <dalek> rakudo/glr: 751f6bf | jnthn++ | src/core/Any.pm:

[15:50] <dalek> rakudo/glr: Fix minmax inconsistency with everything else.

[15:50] <dalek> rakudo/glr: 

[15:50] <dalek> rakudo/glr: Also toss commented out code left with no reason.

[15:50] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/751f6bf0b2

[15:52] *** diana_olhovik_ joined
[16:01] *** Begi joined
[16:02] <Begi> my @a = 0..*; my @a = 0...*; Is there a difference ?

[16:07] <mst> nine: I like timely destruction :)

[16:08] <leedo> Begi: one causes a segfault? :P https://gist.github.com/leedo/8abb6d227e8d843b259f

[16:09] <jnthn> Odd, I'd have expected it to run out of memory rather than SEGV.

[16:09] <leedo> jnthn: i think it is an issue with the repl, does'nt happen with perl6 -e

[16:09] <jnthn> But yeah, .. makes a Range object, and 0...* makes an infinite sequence, and asking for the minimum thing in an infinitely long thing isn't going to go too well...

[16:10] <nine> mst: yes, it certainly has its uses. But no way it can be worth the pain. Every time I come back to the refcount topic, I need a day to start making progress, because one has to keep all the intricacy of the API in ones head at the same time to get it right. And I find my way around perl's source code quite well because the docs only tell you have of what you need to know.

[16:12] <dalek> Inline-Perl5: 265bcdb | (Stefan Seifert)++ | / (4 files):

[16:12] <dalek> Inline-Perl5: Fix isa(P5::subclass) of a P5::subclass of a P6 extended P5 class

[16:12] <dalek> Inline-Perl5: 

[16:12] <dalek> Inline-Perl5: Take a Perl 5 class.

[16:12] <dalek> Inline-Perl5: Extend it using v6-inline and v6::extend in the constructor.

[16:12] <dalek> Inline-Perl5: Create a Perl 5 subclass of this construct.

[16:12] <dalek> Inline-Perl5: 

[16:12] <dalek> Inline-Perl5: With this patch, objects created by the constructor pass an

[16:12] <dalek> Inline-Perl5: ->isa(MySubclass) check.

[16:12] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/265bcdb454

[16:12] <jnthn> Time for a break; maybe more GLR later, if not then got all day on it tomorrow.

[16:14] <RabidGravy> with one of callwith/nextwith/callsame/nextsame in a method can you supply a different invocant somehow?

[16:25] *** fxer left
[16:25] *** isBEKaml left
[16:35] *** rurban joined
[16:43] *** Begi left
[16:46] *** firefish5000 joined
[16:47] *** pat_js joined
[17:08] <skids> RabidGravy: you want to use the current multi/inheritence dispatch candidate state from one object on another?  That sounds dangerous.

[17:09] <RabidGravy> it's in a wrap

[17:09] <RabidGravy> the hack I am doing *is* dangerous

[17:10] <RabidGravy> :)

[17:11] <skids> Are they at least of the same class?  I don't have a solution, just intrigued how the heck you got that deep in the thicket.

[17:11] <RabidGravy> yeah

[17:12] <skids> Sort of like when you encounter a rusted car wreck in the middle of the woods and wonder how the heck it got in there in the first place :-)

[17:13] <RabidGravy> specifically I'd like to arrange a class such that if the method gets called on the type object then the wrapper arranges that it gets called on a singleton instance

[17:16] *** lolisa left
[17:18] <RabidGravy> obviously one could design a class such that is was only class methods and keep state in my variables or so, but I'm curious to see if a class could be made that works both ways

[17:21] <RabidGravy> just a doodle in my internal pattern book ;-)

[17:22] *** brrt joined
[17:23] *** domidumont joined
[17:25] <jnthn> RabidGravy: I'd probably solve that just with a custom meta-class that overrides add_method to wrap the thing up and compose to automatically add some Singleton role like role Singleton { method get-instance() { state $instance = self.new } } or so

[17:26] <jnthn> so add_method would be like callwith($name, -> \obj, |c { obj.DEFINITE ?? $meth(obj, |c) !! $meth($obj.get-instance, |c) } or so

[17:26] *** firefish5000 left
[17:29] <RabidGravy> ahah!

[17:33] <brrt> good *

[17:34] <RabidGravy> jnthn, hadn't quite grokked callwith before that moment

[17:35] <skids> m: my $a = "1"; my $b = "2"; $b [R~]= $a; $b.say # yay I finally got to use R

[17:35] <camelia> rakudo-moar a32c14: OUTPUT«12␤»

[17:38] *** raiph joined
[17:38] *** rangerprice joined
[17:44] <RabidGravy> jnthn,  where I was going was something more like:

[17:44] <RabidGravy> m: https://gist.github.com/jonathanstowe/13f5361cf6ce74776f48

[17:44] <camelia> rakudo-moar a32c14: OUTPUT«this one␤»

[17:45] <RabidGravy> which appears to work

[17:46] *** llfourn left
[17:47] <jnthn> RabidGravy: ah, that also works nicely, at the cost of having the label all the single methods

[17:52] *** pmurias left
[17:52] <jnthn> (Which isn't a problem if only some should do it.)

[17:54] *** rurban left
[18:06] <nwc10> jnthn: you expect origin/glr to fail (no ASAN explosion, just a regular fail) in the setting build?

[18:07] <nwc10> Stage parse      : Error while constructing error object:Could not locate compile-time value for symbol X::Parameter::InvalidType

[18:07] <nwc10> Error while compiling, type X::Parameter::InvalidType

[18:07] <nwc10>   suggestions: (unstringifiable object)  typename: LoL at line 3733, near " \\keys, *%"

[18:07] <nwc10>    at gen/moar/stage2/NQPHLL.nqp:516  (/home/nicholas/Sandpit/moar-san/share/nqp

[18:07] <nwc10> oops ... /lib/NQPHLL.moarvm:panic:105)

[18:07] <nwc10> etc

[18:10] <RabidGravy> BOOM! BOOM! FILL THE ROOM!

[18:10] <rangerprice> Hello i'm a cheezburger

[18:10] <rangerprice> eat me if you can

[18:14] <RabidGravy> nah you're fine I already ate

[18:22] <jnthn> nwc10: Yeah, it's going to be explodey for a while

[18:23] <jnthn> nwc10: There's no good way to do it in non-break-the-build steps (unless you take one huge step :))

[18:23] *** jjido joined
[18:26] *** zakharyas joined
[18:29] *** yqt joined
[18:33] <dalek> rakudo-star-daily: dae7da0 | coke++ | log/MoarVM- (5 files):

[18:33] <dalek> rakudo-star-daily: today (automated commit)

[18:33] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/dae7da04d2

[18:33] <dalek> perl6-roast-data: 2408b3e | coke++ | / (9 files):

[18:33] <dalek> perl6-roast-data: today (automated commit)

[18:33] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/2408b3e0ec

[18:33] <dalek> perl6-roast-data: 34411fa | coke++ | / (9 files):

[18:33] <dalek> perl6-roast-data: today (automated commit)

[18:33] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/34411face8

[18:40] <[Coke]> (swiss perl workshop hackathon) - I'm only a maybe at this point.

[18:43] <japhb> [Coke]: Sadly, I'm at *best* a 20% maybe right now.  :-(

[18:45] *** rindolf left
[18:45] *** jjido left
[18:46] *** jjido joined
[18:49] <brrt> wow, many cool :-o https://developer.nvidia.com/devbox

[18:54] *** shinobi-cl joined
[18:57] <shinobi-cl> r: class C1 { has @!odds; has @!data; submethod BUILD(:@!data*) { @!odds = gather for (@data) -> $v {  take $v if ($v div 2 == 0) } }; method new (@new-data) { return new(data=>@new-data); } };

[18:57] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> 3dds; has @!data; submethod BUILD(:@!data7⏏5*) { @!odds = gather for (@data) -> $v {␤»

[18:59] <shinobi-cl> r: class C1 { has @!odds; has @!data; submethod BUILD(:@!data) { @!odds = gather for (@data) -> $v {  take $v if ($v div 2 == 0) } }; method new (@new-data) { return new(data=>@new-data); } };

[18:59] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Variable '@data' is not declared. Did you mean '@!data'?␤at /tmp/tmpfile:1␤------> 3d BUILD(:@!data) { @!odds = gather for (7⏏5@data) -> $v {  take $v if ($v div 2 == ␤»

[18:59] <shinobi-cl> r: class C1 { has @!odds; has @!data; submethod BUILD(:@!data) { @!odds = gather for (@!data) -> $v {  take $v if ($v div 2 == 0) } }; method new (@new-data) { return new(data=>@new-data); } };

[18:59] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Undeclared routine:␤    new used at line 1 (in Perl 6 please use method call syntax instead)␤␤»

[19:00] <shinobi-cl> r: class C1 { has @!odds; has @!data; submethod BUILD(:@!data) { @!odds = gather for (@!data) -> $v {  take $v if ($v div 2 == 0) } } method new (@new-data) { return C1.new(data=>@new-data) } };

[19:00] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Strange text after block (missing semicolon or comma?)␤at /tmp/tmpfile:1␤------> 3 -> $v {  take $v if ($v div 2 == 0) } }7⏏5 method new (@new-data) { return C1.new(␤    expecting an…»

[19:00] <shinobi-cl> r: class C1 { has @!odds; has @!data; submethod BUILD(:@!data) { @!odds = gather for (@!data) -> $v {  take $v if ($v div 2 == 0) } }; method new (@new-data) { return C1.new(data=>@new-data) } };

[19:00] <dalek> roast: 22ee35b | skids++ | / (2 files):

[19:00] <dalek> roast: Teach Test::Compile to chain compunits; add fudged tests for RT#123679

[19:00] <dalek> roast: review: https://github.com/perl6/roast/commit/22ee35b791

[19:00] <camelia> rakudo-{moar,jvm} a32c14: ( no output )

[19:01] *** [Coke] left
[19:01] *** [Coke] joined
[19:11] <smls> jnthn: In src/core/Seq.pm of the glr branch, you have a role called PositionalBindFailover but refer to it as MemoizeAsPositional in the preceeding comment (I think).

[19:13] <smls> Also, if this is gonna be public API, shouldn't that role have a cuter name such as Listy? :P

[19:16] *** BenGoldberg left
[19:25] <dalek> roast: 4df4e7b | skids++ | S32-scalar/perl.t:

[19:25] <dalek> roast: Add a 'use lib' needed when running make spectest

[19:25] <dalek> roast: review: https://github.com/perl6/roast/commit/4df4e7b4f6

[19:27] *** lucasb left
[19:38] <jnthn> I suspect MemoizeAsList is closer, but its role in binding is hinted better by the other name...

[19:38] <jnthn> No, it shouldn't have a cute name at all

[19:38] <jnthn> Generally, all the things with short cute names are the ones we expect people to use in normal programs.

[19:39] <jnthn> If you are using this role you've probably implemented something like a library that runs list operations off on the GPU and want the pipeline to behave like Seq and HyperSeq do.

[19:39] <jnthn> Or something similarly unusual.

[19:40] <timotimo> hopefully that will not be too unusual

[19:40] <timotimo> though I don't quite see how you could get at the code for things in the pipeline to translate to GPU instructions

[19:42] *** llfourn joined
[19:46] *** llfourn left
[19:47] *** jkva joined
[19:48] *** espadrine left
[19:51] *** ChoHag left
[19:52] *** telex left
[19:54] *** telex joined
[19:57] <jnthn> Back tomorrow :) o/

[20:00] *** cognominal left
[20:01] *** gnosti joined
[20:04] *** BenGoldberg joined
[20:08] <gnosti> Hi, I uploaded rakudobrew, then run 'rakudobrew moar', then 'rakudobrew panda'. The latter fails with http://pasted.co/1a6f9a5f Any suggestions? I'd like to experiment with NativeCall.

[20:08] *** nys left
[20:08] <gnosti> s/uploaded/updated/

[20:14] *** rurban joined
[20:16] *** BenGoldberg left
[20:22] *** zakharyas left
[20:22] *** cognominal joined
[20:23] *** darutoko left
[20:24] <RabidGravy> ghosti, that's odd. it looks like it's using a way old version of rakudo

[20:24] *** brrt left
[20:24] <RabidGravy> but it's "rakudobrew build-panda"

[20:24] <smls> Don't you have to write it "rakudobrew build-panda"? Rather than "rakudobrew panda"

[20:26] <smls> oh, RabidGravy beat me to it

[20:26] <smls> :P

[20:26] <RabidGravy> :)

[20:28] <RabidGravy> to be fair I'm probably just typing faster

[20:28] <smls> that's quite possible.

[20:29] <smls> I'm not a fast typer, and my keyboard could use a replacement...

[20:31] <RabidGravy> I've been doing it so long that I wave my hands in front of the keyboard and words come out, sometimes they even make sense

[20:31] <gnosti> Right, the second command was 'rakudobrew build-panda', and I can't understand why 'rakudobrew moar' would end up with a rakudo from a year ago. Several git 'up to date' messages appeared. I suppose I can blast everything away and try again.

[20:31] <RabidGravy> I also have a lighty up keyboard which clearly helps

[20:33] <RabidGravy> gnosti, it's "rakudobrew build moar && rakudobrew build-panda" for the avoidance of any doubt

[20:34] <RabidGravy> if you have a particularly old "rakudobrew" it may also be a "rakudobrew self-upgrade" first in the unlikely possibility it's sufficientlly old it's getting the wrong branch

[20:36] *** diana_olhovik_ left
[20:38] <gnosti> RabidGravy, "rakudobrew self-upgrade" says already up-to-date.

[20:41] <RabidGravy> got me beat then, right in the middle of something I want to finish tonight otherwise I would look in more depth

[20:42] *** llfourn joined
[20:43] <timotimo> worst case, a rakudobrew nuke might help

[20:45] * gnosti sees a problem that moar-nom was left in "detached head" state with last commit in 2014. Checking out 'nom' and repeating "rakudobrew moar"

[20:46] *** cognominal left
[20:46] *** llfourn left
[20:48] *** TEttinger joined
[20:49] <gnosti> Thanks timotimo, I'll nuke, rinse and repeat.

[20:49] <RabidGravy> but you'll love the NativeCall stuff when you're done ;-)

[20:54] *** shinobi-cl left
[20:59] *** domidumont left
[21:02] *** rurban left
[21:02] <dalek> roast: 66a1ea8 | skids++ | S06-signature/caller-param.t:

[21:02] <dalek> roast: Reap merged ticket numbers, and mention RT#123660

[21:02] <dalek> roast: review: https://github.com/perl6/roast/commit/66a1ea8cb1

[21:03] *** jkva left
[21:06] *** nwc10 left
[21:06] <gnosti> Thanks all, the build process went fine this time :)

[21:07] <RabidGravy> yay!

[21:08] <timotimo> cool

[21:08] <timotimo> enjoy the fruit of our collective labours!

[21:09] <RabidGravy> remember ther's stll 25,600 modules to be finished before christmas ;-)

[21:14] <lizmat> m: $::

[21:14] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[21:17] <bartolin_> lizmat: AFAIU there are a few tickets related to that error: RT #125659, RT #113042, RT #115326, RT #119999, RT #120252

[21:18] <lizmat> yeah, I think I've found a way around this....

[21:18] <bartolin_> lizmat++

[21:18] <lizmat> I mean, it should just die on a malformed longname, no?

[21:18] <lizmat> 6 '$::'

[21:18] <lizmat> ===SORRY!===

[21:18] <lizmat> No named components found in longname

[21:18] <lizmat> something like this, no?

[21:18] <bartolin_> I was looking at it and wasn't sure about that.

[21:19] <bartolin_> std: $::

[21:19] <camelia> std 28329a7: OUTPUT«ok 00:00 134m␤»

[21:19] <bartolin_> lizmat: std parses that the same way as a single $

[21:19] *** ShimmerFairy left
[21:25] <dalek> roast: ed79556 | skids++ | S09-typed-arrays/arrays.t:

[21:25] <dalek> roast: Add test for RT#122440/RT#124079

[21:25] <dalek> roast: review: https://github.com/perl6/roast/commit/ed79556c47

[21:25] <bartolin_> m: my $foo = 42; say $::("foo")

[21:25] <camelia> rakudo-moar a32c14: OUTPUT«No such symbol '$::foo'␤  in block <unit> at /tmp/MakaEiqUtF:1␤␤Actually thrown at:␤  in block <unit> at /tmp/MakaEiqUtF:1␤␤»

[21:26] <bartolin_> that one is differen locally:

[21:26] <bartolin_> m 'my $foo = 42; say $::("foo")'

[21:26] <bartolin_> 42

[21:27] <bartolin_> m: my $foo = 42; say $::<foo>  # shouldn't that be the same as $::("foo")

[21:27] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[21:27] *** pat_js left
[21:29] <lizmat> $ 6 '$::'

[21:29] <lizmat> ===SORRY!=== Error while compiling -e

[21:29] <lizmat> Variable '$' is not declared

[21:29] <lizmat> is that a more acceptable error?

[21:30] <smls> bartolin_: RT #123903 too

[21:30] <RabidGravy> phew got in the commit, for 76 days ;-)

[21:31] <bartolin_> smls++ (I missed that one)

[21:32] *** ShimmerFairy joined
[21:34] <bartolin_> lizmat: what do you get with your patch for '$::<foo>'?

[21:35] <lizmat> $ 6 '$::<foo>'

[21:35] <lizmat> ===SORRY!=== Error while compiling -e

[21:35] <lizmat> Variable '$' is not declared

[21:35] <lizmat> so I guess, even though the spectest is clean, this is not the right way

[21:35] <bartolin_> looking at STG

[21:36] <bartolin_> oops

[21:36] <bartolin_> looking at STD.pm6 it seems to be more sophisticated than Grammar.nqp with regard to 'token variable': https://github.com/perl6/std/blob/master/STD.pm6#L2444

[21:36] <RabidGravy> I'd just like to thank perl 6 for making this kind of refactpr so easy: https://github.com/jonathanstowe/Audio-Convert-Samplerate/commit/66596e915944a1477be6b02bdee40ba65bb1bea8

[21:37] *** fxer joined
[21:40] <lizmat> m: $::<foo>

[21:40] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[21:41] <dalek> rakudo/nom: 68f20f4 | lizmat++ | src/Perl6/World.nqp:

[21:41] <dalek> rakudo/nom: Attempt at fixing #125772 and friends

[21:41] <dalek> rakudo/nom: 

[21:41] <dalek> rakudo/nom: This merely replaces one type of LTA error by another hopefully less

[21:41] <dalek> rakudo/nom: LTA error.  This feels like a bandaid and is probably not the right way

[21:41] <dalek> rakudo/nom: to do this.  But I hope it will put people on track for this one.

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68f20f4c11

[21:41] *** FatalNIX left
[21:41] *** FatalNIX joined
[21:42] <lizmat> I'll look at this again tomorrow when I'm not as tired

[21:42] <bartolin_> lizmat++

[21:43] <RabidGravy> shouldn't "less LTA" be "slightly more awesome"?

[21:44] <dalek> roast: db772bd | skids++ | S03-smartmatch/array-array.t:

[21:44] <dalek> roast: Add (fudged) tests for RT#123144

[21:44] <dalek> roast: review: https://github.com/perl6/roast/commit/db772bd121

[21:45] <RabidGravy> or possibly "slightly nearer to awesome"

[21:45] <RabidGravy> :)

[21:46] <gnosti> timotimo, it all looks very tasty ;)

[21:46] <bartolin_> btw $:: and friends seemed to blow up in 'method variable_components' in src/Perl6/World.nqp, called from src/Perl6/Actions.nqp, line 1866

[21:48] <bartolin_> oh, that's where lizmat++ changed the code. nevermind

[21:49] * bartolin_ should sleep now

[21:53] <RabidGravy> over-rated

[21:59] *** jkva joined
[22:04] *** jkva left
[22:05] *** mjgardner joined
[22:31] *** smls left
[22:31] *** smls joined
[22:31] *** smls left
[22:34] *** jjido left
[22:40] <dalek> roast: 0d72d2b | skids++ | S04-statements/if.t:

[22:40] <dalek> roast: Add tests for RT#105872 (the while case needs one after GLR)

[22:40] <dalek> roast: review: https://github.com/perl6/roast/commit/0d72d2b5a7

[22:42] *** mjgardner left
[22:43] *** llfourn joined
[22:44] *** mjgardner joined
[22:48] *** llfourn left
[22:48] *** perturbation joined
[23:02] *** yqt left
[23:05] *** cognominal joined
[23:06] *** tinyblak joined
[23:06] *** perturbation left
[23:19] <dalek> roast: f97295c | skids++ | S04-statements/for.t:

[23:19] <dalek> roast: mention RT #118705

[23:19] <dalek> roast: review: https://github.com/perl6/roast/commit/f97295c738

[23:26] <RabidGravy> m: say (^2**8).pick(10).map({ ($_/2**8)*(2**32)})

[23:26] <camelia> rakudo-moar a32c14: OUTPUT«1493172224 201326592 2734686208 1157627904 1056964608 1375731712 536870912 2046820352 1711276032 1996488704␤»

[23:30] <RabidGravy> given a bunch of values describing a physical dimension expressed as 8 bit values is that the best way to comvert the scale to 32 bit values

[23:30] *** Peter_R left
[23:33] <dalek> rakudo-star-daily: d8e3e32 | coke++ | log/MoarVM- (5 files):

[23:33] <dalek> rakudo-star-daily: today (automated commit)

[23:33] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d8e3e32451

[23:35] <skids> RabidGravy: depends.  You might want dithering. :-)

[23:36] <RabidGravy> don't admit to understanding those things around me ;-)

[23:36] <RabidGravy> you might get roped in

[23:37] <RabidGravy> but for dumb that's right yeah?

[23:37] <skids> But buf32.new[@values X+< 24] might work.

[23:41] <skids> (You're really leaning on strength reduction by the compiler with the multiplications and divisions)

[23:44] *** dayangkun joined
[23:45] <RabidGravy> my actual interest in this is emulating the Oto Machines Biscuit in software

[23:51] <skids> Don't bother going down to 8 bit for that, just mask off the lower bits at the depth you want to work with.

[23:51] <skids> What will be hard s replicating the input and output analogue filters.

[23:59] <RabidGravy> does that work for emulating an 8 bit dac from some arbitrary bitwidth input ?

