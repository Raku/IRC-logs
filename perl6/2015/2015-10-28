[00:01] *** rurban joined
[00:04] *** boggard joined
[00:04] *** Alina-malina left
[00:08] *** skids joined
[00:18] *** chenryn joined
[00:21] *** chenryn left
[00:21] <[Coke]> r: say (:::[])

[00:21] <camelia> rakudo-moar f55867: OUTPUT«===SORRY!===␤MVMArray: Index out of bounds␤»

[00:21] <camelia> ..rakudo-jvm f55867: OUTPUT«===SORRY!===␤VMArray: Index out of bounds␤»

[00:24] *** aindilis joined
[00:26] *** chenryn joined
[00:27] <[Coke]> anyone know who Pieter Zeemanweg is?

[00:31] <[Coke]> r: say ::::::::::::::[]

[00:31] <camelia> rakudo-{moar,jvm} f55867: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Name component may not be null␤at /tmp/tmpfile:1␤------> 3say ::7⏏5::::::::::::[]␤»

[00:36] *** telex joined
[00:41] *** dpk joined
[00:42] *** raiph joined
[00:46] *** tokuhirom joined
[00:51] *** tokuhirom left
[00:51] *** aborazmeh joined
[00:51] *** aborazmeh left
[00:51] *** aborazmeh joined
[00:51] *** colomon joined
[00:53] *** ParsonsNose joined
[00:53] <ParsonsNose> Perl6 just got me laid

[00:53] <ParsonsNose> Just sayin'

[00:57] *** rurban left
[00:57] <tadzik> congratulations

[00:58] *** yeahnoob joined
[01:00] *** aborazmeh left
[01:05] <ParsonsNose> Now to disband this username...

[01:05] <ParsonsNose> And stop lying

[01:05] *** ParsonsNose left
[01:07] *** ParsonsNose joined
[01:07] *** AndyDee joined
[01:09] *** chenryn left
[01:10] <ParsonsNose> I've heard that perl6 does graphemes correctly. So... If I did one of those classic evil multi-tiered cthulu letters, would it count as one per 'what we all think of as letter'?

[01:10] <ParsonsNose> Wow... My app didn't disguise me. I shoot myself.

[01:17] *** Juerd joined
[01:18] *** Actualeyes joined
[01:19] *** aborazmeh joined
[01:19] *** aborazmeh left
[01:19] *** aborazmeh joined
[01:40] *** Zoffix joined
[01:46] <dalek> rakudo-star-daily: d8b838d | coke++ | log/ (9 files):

[01:46] <dalek> rakudo-star-daily: today (automated commit)

[01:46] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d8b838d3fc

[01:46] <dalek> perl6-roast-data: e23f313 | coke++ | / (9 files):

[01:46] <dalek> perl6-roast-data: today (automated commit)

[01:46] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e23f313050

[01:51] *** rangerprice left
[01:51] *** ShimmerFairy joined
[01:53] *** SHODAN joined
[02:13] *** cognominal joined
[02:14] *** kid51 left
[02:16] *** chenryn joined
[02:16] <dalek> rakudo/nom: 1fd9e8d | coke++ | src/Perl6/World.nqp:

[02:16] <dalek> rakudo/nom: Avoid internal compiler error for RT #115326

[02:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1fd9e8d689

[02:16] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=115326

[02:18] <[Coke]> RT: 1025

[02:19] *** ParsonsNose left
[02:20] *** raiph left
[02:20] *** dayangkun_ joined
[02:25] *** dj_goku joined
[02:33] *** tokuhirom joined
[02:42] *** Actualeyes left
[02:52] *** Oatmeal joined
[02:52] <awwaiid> Is there an IO String like thing?

[02:54] <TimToady> see http://modules.perl6.org/

[02:54] <awwaiid> oh, found IO::String

[02:55] <awwaiid> TimToady++ # pushing me in the pond to catch some fish

[02:59] *** BenGoldberg left
[03:00] *** Ben_Goldberg joined
[03:01] <Ben_Goldberg> m: sub bozosort ( @a is copy ) { until ([<=] @a) -> { my ($a, $b) = @a.keys.pick(2); @a[$a, $b] = @a[$b, $a] }; @a }; say bozosort( (1..5).pick(*) ); 

[03:01] <camelia> rakudo-moar 1fd9e8: OUTPUT«[1 2 3 4 5]␤»

[03:01] <Ben_Goldberg> m: sub bozosort ( @a is copy ) { until ([<=] @a) -> { my ($a, $b) = @a.keys.pick(2); @a[$a, $b] = @a[$b, $a] }; @a }; say bozosort( (1..6).pick(*) ); 

[03:01] <camelia> rakudo-moar 1fd9e8: OUTPUT«[1 2 3 4 5 6]␤»

[03:03] <Ben_Goldberg> m: sub bozosort ( @a is copy ) { until ([le] @a) -> { my ($a, $b) = @a.keys.pick(2); @a[$a, $b] = @a[$b, $a] }; @a }; say bozosort( 'Just another bozo'.comb ); 

[03:04] <camelia> rakudo-moar 1fd9e8: OUTPUT«(timeout)»

[03:15] *** Ben_Goldberg left
[03:20] *** kaare_ joined
[03:56] *** llfourn joined
[04:01] *** rindolf joined
[04:02] *** xenu joined
[04:18] <dalek> ecosystem: 8561f3b | ugexe++ | META.list:

[04:18] <dalek> ecosystem: Net::HTTP https://github.com/ugexe/Perl6-Net--HTTP

[04:18] <dalek> ecosystem: 

[04:18] <dalek> ecosystem: yet another http client, now with connection caching/keep-alive

[04:18] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8561f3b3a4

[04:30] *** xpen joined
[04:48] *** rindolf left
[04:58] *** Actualeyes joined
[05:15] *** cognominal left
[05:26] *** yeahnoob left
[05:26] *** chenryn left
[05:34] *** abraxxa joined
[05:38] *** abraxxa left
[05:44] <dalek> roast: 825dea9 | usev6++ | S03-operators/repeat.t:

[05:44] <dalek> roast: Unfudge test for rakudo.jvm (RT #123830)

[05:44] <dalek> roast: review: https://github.com/perl6/roast/commit/825dea97c1

[05:44] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123830

[05:52] *** abraxxa joined
[05:56] *** skids left
[06:00] *** crux joined
[06:04] *** cgfbee left
[06:09] *** davido_ joined
[06:11] *** cgfbee joined
[06:12] *** Ch0c0late joined
[06:17] *** mayuresh joined
[06:25] *** dayangkun_ left
[06:26] *** dayangkun joined
[06:28] *** abraxxa left
[06:30] *** chenryn joined
[06:31] *** mayuresh left
[06:37] *** bjz joined
[06:41] *** bjz_ joined
[06:41] *** bjz left
[06:44] *** dayangkun left
[06:48] *** bjz joined
[06:50] *** bjz_ left
[06:58] *** ChoHag joined
[07:06] *** dayangkun joined
[07:07] *** dayangkun left
[07:07] <[Tux]> test             50000    39.079    38.959

[07:07] <[Tux]> test-t           50000    38.440    38.321

[07:08] *** dayangkun joined
[07:13] *** bjz_ joined
[07:13] *** davido_ left
[07:15] *** bjz left
[07:16] *** dayangkun left
[07:18] *** FROGGS joined
[07:25] <El_Che> what's the header for [Tux]'s tests?

[07:25] <dalek> roast: 8e47b67 | usev6++ | S02-literals/string-interpolation.t:

[07:25] <dalek> roast: Add test for RT #120449

[07:25] <dalek> roast: review: https://github.com/perl6/roast/commit/8e47b673be

[07:25] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=120449

[07:27] *** leont joined
[07:31] <moritz> \o

[07:35] *** [Sno] joined
[07:36] *** abraxxa joined
[07:39] *** domidumont joined
[07:39] <[Tux]> El_Che, you mean what the columns mean?

[07:44] *** domidumont left
[07:45] *** mr-foobar joined
[07:45] <El_Che> [Tux]: yes

[07:45] *** RabidGravy joined
[07:46] <[Tux]> Text::CSV performance test: test is a reference script (no extra funtionality), test-t is full-featured

[07:46] <[Tux]> 50000 is the number of fields parsed: 10_000 lines with 5 fields each

[07:47] *** leont left
[07:47] <[Tux]> next column is the time in seconds used to do the job

[07:47] <pink_mist> so the full-featured script is faster than the one with no extra functionality? 0_o

[07:48] <[Tux]> http://tux.nl/Talks/CSV6/speed4.html

[07:49] <[Tux]> pink_mist, the reference script has only been changed to work under GLR

[07:49] <[Tux]> the other script has been changed a lot more

[07:49] <[Tux]> so yes, that makes sense

[07:49] *** rurban joined
[07:53] *** domidumont joined
[07:54] *** domidumont left
[07:56] <El_Che> [Tux]: thx!

[07:57] <[Tux]> I am open to other optimisations :)

[07:57] *** Actualeyes left
[07:58] *** darutoko joined
[08:00] *** g5 joined
[08:04] <El_Che> [Tux]: having trouble understanding the graph. X is time, Y is time (seconds to run test-t). Ok. So with what scenario correpond the 4 graphs?

[08:05] <[Tux]> first graph is full range, the other three zoom in on a smaller speed range

[08:05] <[Tux]> the red parts do not fir the range

[08:06] <[Tux]> only vertical zooming, not horizontal zooming

[08:06] <El_Che> [Tux]: I see

[08:07] <El_Che> your module is a good candidate for speed testing

[08:07] <[Tux]> more like the canary in the coalmine

[08:09] *** azawawi joined
[08:09] <El_Che> p5 text::cvs_xs is pretty fast

[08:09] <azawawi> hi

[08:09] <El_Che> hi azawawi 

[08:09] <azawawi> El_Che: :)

[08:10] <El_Che> [Tux]: I was impressed after some superficial native call exploring. What's your experience coming from an XS background?

[08:10] * azawawi is working on his unzip.p6 script (see https://github.com/azawawi/scripts/blob/master/unzip.p6)

[08:11] <[Tux]> for the same task, Text::CSV_XS takes 0.017 seconds: http://tux.nl/Talks/CSV6/speed3.html

[08:11] <azawawi> and the p6 version?

[08:11] <[Tux]> 39 seconds

[08:12] <[Tux]> perl6 + Inline::Perl5 + Text::CSV_XS = 16 seconds

[08:12] <dalek> doc/teodozjan-patch-1: 8b0e97e | (Kamil Kułaga)++ | doc/Language/classtut.pod:

[08:12] <azawawi> cool

[08:12] <dalek> doc/teodozjan-patch-1: Comment about new method to not confuse new users

[08:12] <dalek> doc/teodozjan-patch-1: 

[08:12] <dalek> doc/teodozjan-patch-1: Due to first example contains custom `new` it may give impression that writing `new` is something that programmer want to do. Maybe it would be good to mark it as non standard behavior and say that probably want to write build method?

[08:12] <dalek> doc/teodozjan-patch-1: review: https://github.com/perl6/doc/commit/8b0e97ec43

[08:12] <El_Che> auth

[08:12] <El_Che> c

[08:13] *** g5 left
[08:16] *** mr-fooba_ joined
[08:16] *** mr-foobar left
[08:20] *** mr-fooba_ left
[08:21] *** mr-foobar joined
[08:27] *** ely-se joined
[08:27] *** pdcawley joined
[08:33] *** FROGGS left
[08:45] <dalek> nqp: e301575 | (Pawel Murias)++ | src/vm/js/bin/run_tests.pl:

[08:46] <dalek> nqp: [js] Run passing test 29 on run tests.

[08:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e301575797

[08:46] <dalek> nqp: fc91b03 | (Pawel Murias)++ | src/vm/js/nqp-runtime/bootstrap.js:

[08:46] <dalek> nqp: [js] Fix bug.

[08:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fc91b032ea

[08:46] <dalek> nqp: 4467abe | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[08:46] *** pmurias joined
[08:46] <dalek> nqp: [js] Fix bug.

[08:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4467abeccf

[08:46] <dalek> nqp: 11d9d69 | (Pawel Murias)++ | src/vm/js/ (2 files):

[08:46] <dalek> nqp: [js] We now pass test 43. Update make js-test.

[08:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/11d9d69149

[08:49] *** virtualsue joined
[08:56] *** Alina-malina joined
[09:02] <RabidGravy> just has a cold call on my moobile of someone trying to sell me design and marketing services for my domain jeezus-knievel.com 

[09:02] <RabidGravy> he struggled to stay on his script shall we say

[09:10] *** mr-foobar left
[09:10] *** ely-se left
[09:11] <azawawi> https://github.com/azawawi/scripts/blob/master/unzip.p6   # Proof of concept using Compress::Zlib worked on one file member :)

[09:11] * azawawi starts working on File::Zip

[09:11] <RabidGravy> azawawi++ # go! go! go!

[09:13] <El_Che> azawawi: what's the scope?

[09:13] <azawawi> File::Zip.unzip(file-name => 'test.zip'); File::Zip.unzip(string => 'some zipped file content'); File::Zip.files 

[09:13] <azawawi> El_Che: deflate for now and uncompressed methods

[09:14] <azawawi> El_Che: any ideas?

[09:14] <El_Che> looking at compress zlib now

[09:14] <El_Che> native call to zlib?

[09:14] <azawawi> documentation should be better for uncompress... spent like 1 hour debugging it lol

[09:15] <azawawi> that module is great but needs more examples

[09:16] <El_Che> so by now, perl6 should have more libs than golang :)

[09:18] <RabidGravy> At some point I want to add deflate/compress transfer encoding support to HTTP::UserAgent at some point so I'm glad someone is picking the bits out of this stuff first ;-)

[09:19] <RabidGravy> El_Che, 419 modules as of this moment

[09:19] *** dayangkun joined
[09:19] *** ely-se joined
[09:19] <El_Che> RabidGravy: impressive

[09:20] <RabidGravy> I imagine at any given moment that some small percentage of them don't actually work but hey ;-)

[09:21] <azawawi> RabidGravy: more tests => more working modules

[09:28] *** rarara_ joined
[09:29] <rarara_> Hello, is it possible to expand the automatic "Usage:" output of "sub MAIN" with extra informations?

[09:29] *** Psyche^ joined
[09:30] <jnthn> morning, #perl6

[09:33] <dalek> ecosystem: 56dd4f1 | azawawi++ | META.list:

[09:33] <dalek> ecosystem: Add File::Zip

[09:33] <dalek> ecosystem: 

[09:33] <dalek> ecosystem: Perl 6 interface to the Zip File format

[09:33] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/56dd4f1018

[09:36] *** spider-mario joined
[09:37] *** ely-se left
[09:40] *** chenryn left
[09:41] *** chenryn joined
[09:41] *** espadrine joined
[09:41] *** ely-se joined
[09:41] *** kjs_ joined
[09:42] <moritz> rarara_: I think if you add pod comments to your MAIN sub, they appear in the usage message

[09:42] <moritz> rarara_: example: https://github.com/tadzik/panda/blob/master/bin/panda#L13

[09:44] *** dayangkun left
[09:45] *** dayangkun joined
[09:46] *** dayangkun left
[09:47] <rarara_> moritz this is a great idea; would be cool to have it as flexible as possible

[09:48] <jnthn> rarara_: Well, for ultimate flexibility you get to write your own USAGE sub, iirc :)

[09:48] *** dayangkun joined
[09:48] <moritz> rarara_: on the one hand, yes. On the other hand, there are limits to what a signature-based command line parser can do

[09:49] <rarara_> Yes, right: this is a compromize between fast coding and ultimate flexibility

[09:52] <dalek> roast: cb2965a | jnthn++ | S06-multi/positional-vs-named.t:

[09:52] <dalek> roast: Test codifying multi + optional named semantics.

[09:52] <dalek> roast: 

[09:52] <dalek> roast: Covers the ruling on RT #119929.

[09:52] <dalek> roast: review: https://github.com/perl6/roast/commit/cb2965ab82

[09:52] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=119929

[09:53] <RabidGravy> azawawi, re tests, yep :) That's why the Travis CI thing is good

[09:53] <RabidGravy> every once in a while I select a module that appears to be failing and try to fix it

[09:54] *** dayangkun left
[09:55] *** dayangkun joined
[09:55] <jnthn> xmas-- :)

[09:56] * jnthn at last slept decently and should probably seize the opportunity to work on one of the less easy xmas RTs today... :)

[09:59] * jnthn picks RT #125927

[09:59] *** Actualeyes joined
[10:02] *** dayangkun left
[10:03] *** dayangkun joined
[10:04] <rarara_> Is there a way to get the number of consumed elements of a Seq?

[10:04] *** FROGGS joined
[10:04] *** kjs_ is now known as kjs

[10:04] <rarara_> I kind of feels like ".elems" should work this way

[10:04] <rarara_> otherwisi it is just plain useless

[10:05] <jnthn> .elems just counts the number of things that'd be produced

[10:06] <jnthn> It's useful for things like @foo.split('bar').elems for example

[10:06] *** kjs left
[10:07] <rarara_> jhthn I suspect that what [email@hidden.address] is doing is actually produce the things and then count them, isn't?

[10:08] <jnthn> rarara_: I don't know; the iterator API is actually powerful enough to let us do better

[10:08] <jnthn> Whether we are or not, I don't know without looking at the code :)

[10:08] <rarara_> no worry

[10:08] <jnthn> Feels like an opt lizmat++ mighta already got to, though :)

[10:09] <jnthn> .grep(...).elems is another quite common one

[10:10] <rarara_> I feel like after doing .grep, you might want to know how many iteration you took

[10:10] <rarara_> even just for debugging purposes

[10:10] <rarara_> let you want to know how % of things get grepped: how can you do it now?

[10:12] *** Begi1115 joined
[10:13] <rarara_> https://gist.github.com/anonymous/a8c2b8324da798a4cef7

[10:13] <rarara_> what is wrong in this?

[10:13] <rarara_> thanks

[10:20] *** FROGGS left
[10:20] <jnthn> rarara_: Golfing it...

[10:21] <jnthn> rarara_: I don't think anything is wrong in your code; I think start is at least somewhat to blame

[10:21] *** tm joined
[10:21] <rarara_> thank you, a workaround is to add eager after astart

[10:21] <jnthn> m: say await start "d\te\tf".chomp.split("\t");

[10:21] <camelia> rakudo-moar 1fd9e8: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/qaPKYuiRCa:1␤␤»

[10:21] <jnthn> It golfs to that.

[10:22] <jnthn> m: say (start "d\te\tf".chomp.split("\t")).result;

[10:22] <camelia> rakudo-moar 1fd9e8: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/YjlL4kgdyH:1␤␤»

[10:22] <jnthn> And further to that

[10:22] <jnthn> m: say (start (1,2,3).Seq).result;

[10:22] <camelia> rakudo-moar 1fd9e8: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/S30nON1Gzg:1␤␤»

[10:22] <jnthn> And even that.

[10:22] *** FROGGS joined
[10:22] <jnthn> RT'able, anyways

[10:23] <rarara_> ok, I can write the mail

[10:24] * jnthn builds a possible fix

[10:24] *** dakkar joined
[10:25] <jnthn> Yeah, seems to do it

[10:26] <jnthn> Oh, seems it maybe already was RT'd

[10:26] <jnthn> RT #122715

[10:26] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=122715

[10:27] *** dayangkun left
[10:27] *** Ch0c0late left
[10:27] <jnthn> Though the tests are off

[10:27] <rarara_> with eager it works now

[10:28] <jnthn> Yeah. With commit I'll make soon your original woulda been fine too

[10:28] <rarara_> ah ok, it is the same

[10:28] <jnthn> I'm going to add the golf of yours as an additional test case.

[10:28] *** chenryn left
[10:28] <rarara_> sure!

[10:29] <jnthn> Did you file antoher RT?

[10:29] *** Actualeyes left
[10:29] <jnthn> Or did I catch the dupe in time? :)

[10:30] <rarara_> nono, I was just about to copy your golf

[10:30] <rarara_> :)

[10:31] <jnthn> OK, don't worry about filing it. :)

[10:32] <jnthn> It's another case of that one I linked above.

[10:34] <azawawi> re http://doc.perl6.org/routine/seek, is there constants that we can import from somewhere?

[10:34] <azawawi> constants for $whence parameter that is

[10:36] <jnthn> m: my @outer = 0..3; say await start { @outer.map: *+1 }

[10:36] <camelia> rakudo-moar 1fd9e8: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/of9ygj1KeG:1␤␤»

[10:38] <rarara_> Maybe eager should be added automagically by start in that case

[10:38] <rarara_> but it would not work for infinite lists

[10:40] <jnthn> rarara_: Well, ^^ works locally, so no eager needed :)

[10:41] *** rindolf joined
[10:42] *** ely-se left
[10:43] <dalek> rakudo/nom: 3c17701 | jnthn++ | src/core/Promise.pm:

[10:43] <dalek> rakudo/nom: Keeping a Promise must not sink the kept value.

[10:43] <dalek> rakudo/nom: 

[10:43] <dalek> rakudo/nom: Otherwise, a Seq handed back from a Promise will end up being

[10:43] <dalek> rakudo/nom: consumed at the point of keeping the Promise, and thus the result

[10:43] <dalek> rakudo/nom: will be useless.

[10:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3c17701597

[10:44] *** CIAvash joined
[10:44] <dalek> roast: 98fd1d1 | jnthn++ | S17-promise/start.t:

[10:44] <dalek> roast: Fix and unfudge RT #122715 tests; add one more.

[10:44] <dalek> roast: review: https://github.com/perl6/roast/commit/98fd1d1392

[10:44] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=122715

[10:47] *** tokuhirom left
[10:47] <jnthn> The RT has a small write-up on the exact semantics also :)

[10:47] <RabidGravy> azawawi, no but there is a comment in the code to make an enum, I was going to do it at one point but can't remember what stopped me

[10:47] <jnthn> rarara_++

[10:48] *** Actualeyes joined
[10:49] *** brrt joined
[10:49] * jnthn gets back to his graphemes :)

[10:51] *** tokuhirom joined
[10:52] <moritz> "the grapheme and me"

[10:56] *** zakharyas joined
[10:57] <azawawi> is there a way in Perl 6 to unpack("L L L") into an object in one line? :)

[10:57] *** weihan_ joined
[10:58] *** chenryn joined
[10:59] *** Oatmeal left
[11:01] <dalek> rakudo/bool_enum: 660d0e1 | (Stefan Seifert)++ | src/ (3 files):

[11:01] <dalek> rakudo/bool_enum: Turn Bool into a proper enum

[11:01] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/660d0e1153

[11:01] <dalek> rakudo/bool_enum: 313ed64 | (Stefan Seifert)++ | src/core/operators.pm:

[11:01] <dalek> rakudo/bool_enum: Fix SEQUENCE not expecting Bool ~~ Real to be true

[11:01] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/313ed64097

[11:01] <dalek> rakudo/bool_enum: 6c57f31 | (Stefan Seifert)++ | src/Perl6/Metamodel/EnumHOW.nqp:

[11:01] <dalek> rakudo/bool_enum: Make Bool augmentable

[11:01] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/6c57f3157b

[11:01] <dalek> rakudo/bool_enum: 080f3ce | (Stefan Seifert)++ | src/Perl6/Metamodel/EnumHOW.nqp:

[11:01] <dalek> rakudo/bool_enum: Fix type check for binding parameters

[11:01] <dalek> rakudo/bool_enum: 

[11:01] <dalek> rakudo/bool_enum: EnumHOW just needed an is_composed method like many other HOWs.

[11:01] <dalek> rakudo/bool_enum: Fixes regression in t/spec/S06-signature/optional.t

[11:01] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/080f3ce7ed

[11:01] <dalek> rakudo/bool_enum: ff92838 | (Stefan Seifert)++ | src/Perl6/Metamodel/ (2 files):

[11:01] <dalek> rakudo/bool_enum: Allow for mixing into enums.

[11:01] <dalek> rakudo/bool_enum: 

[11:01] <dalek> rakudo/bool_enum: Fixes Bool but role {} and t/spec/S14-roles/mixin.t regressions

[11:01] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/ff92838548

[11:02] <nine> jnthn: oops, seems like I just pushed an outdated bool_enum branch. Will have to correct that in the evening, when I'm on my desktop at home again.

[11:02] <RabidGravy> azawawi, you mean something like : class M { has Int $!one; has Int $!two; has $!three };   my M $m = M.unpack-from-buf($buf); ?

[11:03] <nine> jnthn: just in case you planned to have a look at it

[11:03] <RabidGravy> then no, not currently but I am working on something like that on the back burner

[11:03] <RabidGravy> can't remember how far I got

[11:04] *** Oatmeal joined
[11:04] <azawawi> Cool thanks

[11:04] * pink_mist suggestes "s/n/ /g" there, now all your code is in one line :P

[11:04] <pink_mist> *suggests

[11:05] <RabidGravy> basically annotate the attributes with a "picture trait" which contains the unpack pattern and then provide a constructor which will pick the bits out of the Bug

[11:05] <RabidGravy> Buf

[11:05] <RabidGravy> need it for a couple of things I'm slowly working on

[11:06] <RabidGravy> let me look to see how far I got

[11:10] *** azawawi left
[11:12] <RabidGravy> of course it would help if I could remember what I had called it

[11:15] <itz_stmuk> is a rakudo star intended for niceville?

[11:16] <rarara_> m: say do for $*IN.lines -> $line {$line.say}

[11:16] <camelia> rakudo-moar 1fd9e8: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall␤Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll;␤Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí␤I mo dhiaidh bhí gleanntáin ghlas’ G…»

[11:16] <rarara_> m: map $*IN.lines: -> $line {$line.say}

[11:16] <camelia> rakudo-moar 1fd9e8: OUTPUT«Cannot call Numeric(Block: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/m2G_AhFh_N:1␤␤»

[11:16] <rarara_> makes sense

[11:17] * itz_stmuk likes how the http://rakudo.org/rt/easy link displays no tickets

[11:17] <rarara_> but I am wondering what is the use of map? Autoparalleization?

[11:21] <RabidGravy> that case probably not a good use:

[11:21] <RabidGravy> m: $*IN.lines.map( {"> $_".say })

[11:21] <camelia> rakudo-moar 1fd9e8: OUTPUT«> Céad slán ag sléibhte maorga Chontae Dhún na nGall␤> Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll;␤> Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí␤> I mo dhiaidh bhí gleanntáin gh…»

[11:23] <RabidGravy> obviously, say there is stupid as there are better ways of doing it

[11:23] *** rurban left
[11:26] <jnthn> rarara_: map is useful when you want to turn one list into another by applying some mapping

[11:26] <jnthn> m: $*IN.lines.map(*.uc).say

[11:26] <camelia> rakudo-moar 3c1770: OUTPUT«(CÉAD SLÁN AG SLÉIBHTE MAORGA CHONTAE DHÚN NA NGALL AGUS DHÁ CHÉAD SLÁN AG AN EIREAGAL ARD INA STUA OS CIONN CAOR IS COLL; NUAIR A GHLUAIS MISE THART LE LOCH DHÚN LÚICH’ GO CIÚIN SA GHLEANN INA LUÍ I MO DHIAIDH BHÍ GLEANNTÁIN GHLAS’ GHAOTH…»

[11:27] <RabidGravy> aye

[11:28] <RabidGravy> .tell azawawi I may have temporarily mislaid that code, I'll find it eventually

[11:28] <yoleaux> RabidGravy: I'll pass your message to azawawi.

[11:28] <mrf> jnthn: is there an easy way of doing a hyper map on a list? 1..10.>>map(#some expensive iterator)?

[11:29] <jnthn> Is .hyper.map(...) not easy enough? :)

[11:29] <mrf> ah. I wasn't aware I could do .hyper on things. Though I needed to do >>

[11:30] <jnthn> Note that .hyper and .race need to come before the operations that will be affected by them

[11:30] *** andreoss joined
[11:30] <jnthn> It actually gives you back a HyperSeq, which then can dispatch to parallel implementations of things

[11:30] <jnthn> It's also a little under-implemented (as in, there's loose ends to tie up)

[11:31] <mrf> ok

[11:32] <jnthn> It is clever enough to realize that .hyper.map(...).grep(...).map(...) should batch things up and do the map/grep/map sequence on one thread for a given batch. 

[11:32] <jnthn> (For good CPU cache properties)

[11:32] <mrf> what is the syntaxt for calling that on a seq.

[11:32] <jnthn> .hyper is defined on any Iterable

[11:32] <jnthn> (And Seq is Iterable)

[11:32] <mrf> doing 1..10.hyper.map doesn't seem to be valid? 

[11:33] <ilmari> m: (1..10).hyper.map(*.say)

[11:33] <camelia> rakudo-moar 3c1770: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[11:33] *** brrt left
[11:33] <mrf> but then again I am still having trouble with the varous iterable stuff and flattening

[11:33] <jnthn> Precedence :)

[11:33] <ilmari> m: (1..10).race.map(*.say)

[11:33] <camelia> rakudo-moar 3c1770: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[11:33] <jnthn> Ah, ilmari was faster :)

[11:33] <jnthn> 10 items will likely go into the same batch :)

[11:33] <mrf> Ahh I have to do *.say in the map not .say

[11:34] <jnthn> Yeah but...doing side-effects in a map block that you're using with .race/.hyper is asking for trouble :)

[11:34] <jnthn> m: (1..10).race(batch => 2).map(*.say)

[11:34] <camelia> rakudo-moar 3c1770: OUTPUT«1␤2␤3␤5␤4␤6␤7␤8␤9␤10␤»

[11:34] <jnthn> m: (1..10).race(batch => 2).map(*.say)

[11:34] <camelia> rakudo-moar 3c1770: OUTPUT«3␤4␤5␤6␤7␤8␤1␤2␤9␤10␤»

[11:35] <jnthn> :)

[11:36] <mrf> Yeah. I was exploring the example that itz_stmuk gave regarding loop speed differences in p6 vs p5 and was curious if more difference was seen using new options in p6 than were potentially lost over speed issues in p6

[11:37] <mrf> it was a simple enough example I though I could hyper map it rather than for loop. It turned out for me to be non trivial.

[11:38] <mrf> jnthn: ilmari: thank you both

[11:46] *** ely-se joined
[11:48] *** kjs_ joined
[11:52] <dalek> doc: 82a8e05 | (Steve Mynott)++ | doc/Language/5to6-perlvar.pod:

[11:52] <dalek> doc: update version string

[11:52] <dalek> doc: review: https://github.com/perl6/doc/commit/82a8e05c53

[11:52] <dalek> doc: c95dba0 | (Steve Mynott)++ | doc/ (3 files):

[11:52] <dalek> doc: correct minor typos

[11:52] <dalek> doc: review: https://github.com/perl6/doc/commit/c95dba0a8e

[11:53] *** kjs_ left
[11:55] *** kjs_ joined
[12:00] *** xpen left
[12:01] *** xpen joined
[12:01] *** azawawi joined
[12:01] <azawawi> hi

[12:01] <yoleaux> 11:28Z <RabidGravy> azawawi: I may have temporarily mislaid that code, I'll find it eventually

[12:01] *** xpen left
[12:03] <azawawi> https://github.com/azawawi/perl6-file-zip/blob/master/examples/test.p6  # listing files in a ZIP files now works :)

[12:03] <azawawi> s/ZIP file/ZIP archive/

[12:05] <jnthn> azawawi++

[12:05] * jnthn is enjoying watching the ecosystem grow :)

[12:05] *** rurban joined
[12:07] <azawawi> jnthn: :)

[12:10] *** lucasb_ joined
[12:12] <RabidGravy> is .set_rw supposed to have an effect on the behavour of a Code or is it just a mutator on some attribute that is used elsewhere (or is there a way I can make a non-rw Code object rw on the fly?)

[12:13] <RabidGravy> not a biggie as I can deal with it otherwise, just yuck code

[12:14] *** chenryn left
[12:15] <RabidGravy> i.e.

[12:15] <RabidGravy> m: my $A; my $s = sub () { $A }; $s.set_rw; say $s.rw; $s() = 1

[12:15] <camelia> rakudo-moar 3c1770: OUTPUT«True␤Cannot modify an immutable Any␤  in block <unit> at /tmp/7XjQgdvj6a:1␤␤»

[12:18] <dalek> roast: 2080809 | jnthn++ | S15-nfg/grapheme-break-test-gen.p6:

[12:18] <dalek> roast: Add script to generate grapheme break tests.

[12:18] <dalek> roast: 

[12:18] <dalek> roast: Translates GraphemeBreakTest.txt from the Unicode Character Database

[12:18] <dalek> roast: into Perl 6 tests (for now, just for the .char counts).

[12:18] <dalek> roast: review: https://github.com/perl6/roast/commit/2080809233

[12:18] <dalek> roast: bd7c065 | jnthn++ | S15-nfg/grapheme-break.t:

[12:18] <dalek> roast: Add generated grapheme break tests.

[12:18] <dalek> roast: 

[12:18] <dalek> roast: Rakudo on Moar currently fails 83 tests of 402; these capture the

[12:18] <dalek> roast: cases where the current NFG algorithm is insufficient.

[12:18] <dalek> roast: review: https://github.com/perl6/roast/commit/bd7c065ef3

[12:18] <jnthn> RabidGravy: That's far too late

[12:18] <jnthn> RabidGravy: It can only affect code-gen if you do it at BEGIN time and before the block is "composed"

[12:18] <jnthn> RabidGravy: So doing it in a block trait is probably fine, for example.

[12:20] <RabidGravy> ah, so in a "method trait" it should work?  Let's see

[12:21] <azawawi> hmmm unzip for all archive is now working... benchmarking :)

[12:24] <azawawi> real	0m21.838s user  for Perl 6, 0m0.049s for unzip :)

[12:25] <RabidGravy> It's always good to have room for improvement

[12:25] <RabidGravy> ;-)

[12:25] <azawawi> 35 folders/files archive

[12:25] <dalek> specs: e1a1afe | (Steve Mynott)++ | S06-routines.pod:

[12:25] <dalek> specs: minor typo fix

[12:25] <dalek> specs: review: https://github.com/perl6/specs/commit/e1a1afee5a

[12:25] <azawawi> but it is cool to see how much more readable code is in Perl 6

[12:26] <RabidGravy> if nothing else the lack of boiler plate around getting and checking arguments is a massive win

[12:31] <azawawi> now that i was able to unzip the firefox webdriver extension archive, i can dump the need of the external unzip command in the firefox webdriver :)

[12:32] *** darutoko left
[12:32] <timotimo> azawawi: is "unzip" the one implemented in C, or a pure perl5 implementation?

[12:32] <RabidGravy> jnthn, ah what was confusing me was that "nextsame" doesn't have the rw-ey-ness but "callsame" does

[12:32] <azawawi> timotimo: the one with debian that is in c

[12:32] <timotimo> OK

[12:33] <timotimo> that's probably not easy to beat :)

[12:34] <timotimo> especially as our nativecall implementation is yet to get a little rewrite for jittability

[12:34] <RabidGravy> yeah, you could probably improve by making a C wrapper that does as much as possible in C code, but the marshalling of the bastarding great arrays is still going to be costly

[12:35] <timotimo> we can directly access C arrays from perl6

[12:35] <azawawi> Sometimes being able to finish your task without installing external dependencies is more important than speed 

[12:35] <azawawi> one less dependency to worry about :)

[12:35] <azawawi> and makes your code more portable

[12:35] <RabidGravy> timotimo, sure but if you want to do something with them later you have to copy them

[12:35] <timotimo> hm?

[12:36] <timotimo> if it's an array of ints, for example, you can just use their values as native ints and end up only copying registers around

[12:37] <RabidGravy> yeah, but they CArray don't have an iterator, .elems or anything else a Array doth

[12:37] *** CIAvash left
[12:38] <RabidGravy> or has something changed since I last looked

[12:38] <timotimo> probably not

[12:38] <timotimo> there's still not a great way to differentiate a C array that we want to be able to grow with realloc vs one we've been passed from C space where we can set its size to anything we want

[12:39] *** brrt joined
[12:40] <RabidGravy> sure, bearing in mind that in the Audio::* modules it's all about the bastarding great CArrays 

[12:41] <timotimo> mhm

[12:42] *** sufrostico joined
[12:42] <RabidGravy> :)

[12:42] <timotimo> you might be in the perfect position to suggest better API around this :)

[12:44] <RabidGravy> I've been thinking about "special constructors" for Array and Blob which do stuff at the lowest possible level do reduce the cost of the Perl level copying of elements

[12:44] <moritz> fwiw I'd love a kind of wrapper around a CArray that you can tell its length, and then use much more naturally in Perl 6

[12:44] <moritz> but when you pass it to a native sub, it unwraps automatically

[12:47] <RabidGravy> even  something like "Array[Int].new(CArray $a, Int $elems)" would be a win TBH

[12:48] *** telex left
[12:49] <azawawi> worked like a charm for Selenium::WebDriver::Firefox... File::Zip rocks :)

[12:50] *** telex joined
[12:50] <RabidGravy> azawawi++ # nice one

[12:51] *** ely-se left
[12:51] <azawawi> :)

[12:53] <azawawi> btw im using the atom editor for all this work... one cool thing i noticed in it is that you could open a file which inside an archive.... but you cannot modify it unfortunately...

[12:54] *** ely-se joined
[12:56] <timotimo> azawawi: i'd suggest ""signature              = " ~ $signature.fmt("%08x") over the printf version

[12:57] <timotimo> isn't buf.unpack("A*") the same as buf.decode("ascii")?

[12:57] <timotimo> m: Buf.new(22, 23, 24).decode("ascii").say

[12:57] <camelia> rakudo-moar 3c1770: OUTPUT«^W␤»

[12:57] <timotimo> m: Buf.new(0x22, 0x23, 0x24).decode("ascii").say

[12:57] <camelia> rakudo-moar 3c1770: OUTPUT«"#$␤»

[12:57] *** aborazmeh left
[12:58] * ShimmerFairy still thinks unpack and pack shouldn't exist in Perl 6 until we know how P6 should be doing binary parsing, fwiw

[13:00] <timotimo> azawawi: how about a --profile of File::Zip unpacking something?

[13:01] <azawawi> timotimo: sure but there is still debugging code... i will do it :)

[13:02] <timotimo> hm, there's a bare .decode in EndOfCentralDirectoryHeader for the comment thing

[13:02] *** xpen joined
[13:02] <timotimo> might want to be .decode("ascii") perhaps?

[13:04] *** ely-se left
[13:05] <RabidGravy> ShimmerFairy, I'll leave the MIDI module to you then ;-p

[13:05] <ShimmerFairy> ?

[13:06] <dalek> nqp: ee00ba0 | (Pawel Murias)++ | src/vm/js/nqp-runtime/reprs.js:

[13:06] <dalek> nqp: [js] Remove some dead and/or commented out code.

[13:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ee00ba0b36

[13:06] <dalek> nqp: ca02098 | (Pawel Murias)++ | src/vm/js/nqp-runtime/reprs.js:

[13:06] <dalek> nqp: [js] Serialize and compose autoviv info for P6opaque.

[13:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca02098401

[13:06] *** xpen left
[13:07] <RabidGravy> well out of .pack/.unpack and working software or nothing I'll take pack/unpack

[13:08] <ShimmerFairy> I still don't follow. Are you suggesting that a MIDI thing would be ~utterly impossible~ without a Perl 5-ish pack and unpack?

[13:08] <RabidGravy> and if some better idea for "binary parsing" comes along then they can be relegated as "low level" features but for now

[13:09] <RabidGravy> I'm not saying it would be impossible, but for a large variety of packed binary formats one would have to invent something strangely like unpack

[13:10] <ShimmerFairy> I'd rather have nothing than a sloppily thrown-together subset of Perl 5 features someone decided to support. I've never seen any evidence that the current impl. was part of a carefully considered "how do we do binary parsing?" decision

[13:12] <ShimmerFairy> AFAICT, the current implementation is just a Perl 5 relic that shouldn't be there. It's like seeing someone define $^O somewhere in the rakudo code to me :P

[13:13] <RabidGravy> I'm sure everyone will be delighted to receive your proposal for something better, but in the meantime I want to write software

[13:13] <ShimmerFairy> m: say pack("A", "☃"); # not to mention that not supporting unicode for something that's purported to handle strings on a codepoint basis (so says the docs) is just unacceptable

[13:13] <camelia> rakudo-moar 3c1770: OUTPUT«non-ASCII character '☃' while processing an 'A' template in pack␤  in block <unit> at /tmp/szFEvk2Y6a:1␤␤»

[13:14] <ShimmerFairy> RabidGravy: for the record I did share what I had written so far about my thoughts on binary grammars some time ago, I guess it just didn't catch anyone's interest :)

[13:14] *** kjs_ left
[13:14] <brrt> ShimmerFairy: i do have some interest

[13:15] <ShimmerFairy> brrt:  https://gist.github.com/ShimmerFairy/72a25f87939aab077158    (I stopped at the point where I would've written about the  <?pos(42)>  equivalent and other offset-related things)

[13:18] *** ely-se joined
[13:21] *** raiph joined
[13:21] <FROGGS> ShimmerFairy: there is a decision about how pack/unpack should work btw

[13:21] <ShimmerFairy> And I admit that some of the syntax choices I made in that gist are quite strange, but hopefully the underlying concepts still look reasonable :P

[13:21] <ShimmerFairy> FROGGS: Really? I haven't seen it. (Certainly is missing from the synopses)

[13:21] <FROGGS> ShimmerFairy: and that's not like how pack/unpack is implemented right now

[13:22] * brrt is reading

[13:22] <azawawi> ShimmerFairy: unpack is at least working for me to implement actual software in Perl 6 :)

[13:22] <FROGGS> ShimmerFairy: TimToady said that he wants it to be like we do it for NaticeCall... you declare a structure (like a CStruct), and unpack the data using that structure

[13:23] <RabidGravy> FROGGS, fwiw that's *exactly* how I would like it to work

[13:23] <FROGGS> that will work when we have sized arrays and stuff in attribute slots in CStructs or classes in general

[13:24] <ShimmerFairy> FROGGS: I like that, though I hope it's not referred to in terms of CStructs exactly, of course :)

[13:24] <FROGGS> dunno

[13:24] <RabidGravy> in the meantime I was working on something that did similar but at a higher level which I appear to have lost

[13:24] <FROGGS> but using CStructs might be the first usable implementation

[13:24] <ShimmerFairy> (precisely, I hope it's not actually _called_ "CStruct" when I'm not working in Nativecall-land)

[13:26] <ShimmerFairy> FROGGS: my real concern, fwiw, is P6 being forced to support the ad-hoc P5-era notation currently in place if it's still there by Christmas. ("Yes, you _could_ use some of the P5 stuff, but you really should instead-- oh, they're gone already" :P )

[13:27] <FROGGS> yeah

[13:28] <brrt> the thing is that not every binary format maps neatly to structures

[13:28] <brrt> in fact, anything with variable-length fields doesn't neatly map

[13:28] <FROGGS> brrt: aye

[13:28] <ShimmerFairy> and it's the reason why I'd like to have pack/unpack ripped out now before Perl 6 is officially released and stability is suddenly a lot more important.

[13:28] <brrt> and in that sense, a 'binary grammar' seems a viable idea

[13:29] <pmurias> having something that is bidirectional would be great

[13:29] <brrt> if we rip it out, and not have something comparable by christmas, is that a large problem?

[13:29] <RabidGravy> yes

[13:29] <ShimmerFairy> that's not to say that the existing pack/unpack can't be launched right into a module, it just shouldn't be in core :)

[13:29] <brrt> what about a moon on a stick pmurias :-P

[13:29] <RabidGravy> I have three modules that use them already

[13:30] <brrt> (grammars aren't bidirectional).

[13:30] <ShimmerFairy> pmurias: I think that's where having some kind of support for "serialization" comes in handy :)

[13:31] <brrt> moving pack/unpack to a module seems like a *very* sane idea to /me

[13:31] <brrt> makes everybody get what they want

[13:31] <diakopter> El_Che: I guess you're kidding, since godoc.org indexes 96,000 packages for golang

[13:32] * RabidGravy looks at the code

[13:32] <RabidGravy> I'd be relaxed if pack/unpack went in a module right away

[13:33] <RabidGravy> the code does nothing fancy with nqp and seems eminently improvable

[13:33] *** darutoko joined
[13:34] <RabidGravy> perhaps as an augment on Blob for least surprise

[13:34] <pmurias> brrt: I'm pretty sure having bidirectional binary serialization isn't something new

[13:35] <lucasb_> https://gist.github.com/smls/bc5d0fb42f199574e339  <-- another relevant gist about binary parsing

[13:35] <ShimmerFairy> I think module-space would also let pack/unpack avoid the spectre of "but should this pack directive from P5 be supported in core?", because it's a module and can do what it want :)

[13:35] <RabidGravy> gwan admit it, you'd still complain about it

[13:36] <RabidGravy> ;-)

[13:36] <FROGGS> ShimmerFairy: +1

[13:36] <diakopter> gwan?

[13:36] <RabidGravy> "go on"

[13:36] <RabidGravy> in sarf lahnun

[13:36] <ShimmerFairy> RabidGravy: nah, if it's a module then I can not use it all I want :P

[13:36] <diakopter> that was a good show

[13:37] <RabidGravy> :)

[13:38] <ShimmerFairy> My current suspicion is that binary stuff wants binary grammars for parsing the more complex binary data types, Nativecall-like structures for the simpler stuff, and maybe even those said structures being a part of the actions side of binary grammars.

[13:39] <flussence> one gripe I have with pack is that it embeds a second-class language (along with sprintf)... and it's like that outside perl too. I lack any ideas to make it better though :(

[13:39] <azawawi> timotimo: done ... thanks for the code review :)

[13:40] <ShimmerFairy> lucasb_: one thing to note on that gist is that the :bytes adverb in regexes comes from an older era of thinking on strings, and a binary regex would (in my mind) be separate from textual regexes in the first place :)

[13:40] <rarara_> m: my $lista = do for ("a~b","c~d").Seq -> $l { $l.split("~"); }; for |$lista -> $el ($first, $second) { say $first }

[13:40] <camelia> rakudo-moar 3c1770: OUTPUT«Too few positionals passed; expected 2 arguments but got 0 in sub-signature of parameter $el␤  in block <unit> at /tmp/tLohMiQGgu:1␤␤»

[13:40] <flussence> .oO( I guess one place that handles binary data in the language well is... C )

[13:40] <rarara_> m: my $lista = do for ("a~b","c~d").Seq -> $l { eager $l.split("~"); }; for |$lista -> $el ($first, $second) { say $first }

[13:40] <camelia> rakudo-moar 3c1770: OUTPUT«a␤c␤»

[13:41] <ShimmerFairy> flussence: the one thing about sprintf is that it's the best at i18n (when it supports explicit arg indices). I'm not sure how you could accomplish it more easily with, say, C++'s streams

[13:42] <timotimo> azawawi: you're welcome :)

[13:42] <rarara_> So Seq doesn't destructure

[13:42] <PerlJam> good * #perl6

[13:42] <timotimo> azawawi: also, you seem to be starting to search for a 4 byte long string at the last byte of the file

[13:43] <timotimo> maybe you want to start earlier

[13:43] <rarara_> wouldn't be nice that it would?

[13:43] <azawawi> timotimo: that's the eocd.. it is at the end lol

[13:43] <RabidGravy> I do have small desire to expose the sprintf grammar as $~Sprintf or so for some nefariety

[13:43] <azawawi> timotimo: but maybe i need to quit earlier for non-zip files

[13:43] <timotimo> azawawi: well, you're not going to find a 4-byte-long string at file-length - 1

[13:44] <azawawi> timotimo: yup :)

[13:44] <timotimo> that's what i mean

[13:44] * azawawi is looking at the profile

[13:44] <flussence> ShimmerFairy: agreed there. I think ICU has something fancier... but then you'd be using ICU. *shudder*

[13:44] <El_Che> diakopter: I was tongue in cheek paraphrasing Ovid (I thought he was in the channel): https://twitter.com/OvidPerl/status/658915941112270848

[13:46] <ShimmerFairy> flussence: P6 has %1$s and such, if I remember the syntax :) . Why don't you like ICU, ooc? I don't want to use it because, even though I can use an iterator to do operate on graphemes NFG-style, I don't like that I have to use an iterator. I'd much rather write my own C++ unicode library :P

[13:46] *** skids joined
[13:48] <azawawi> timotimo: https://raw.githubusercontent.com/azawawi/scripts/master/profile-1446039746.44693.html

[13:48] <jnthn> 'cus writing Unicode libraries is fun! :P

[13:48] <flussence> ICU's like using a bucket-wheel excavator to dig a garden bed :)

[13:49] <RabidGravy> is there any method trait out there that is known to cause other applied traits problems?

[13:49] <timotimo> azawawi: holy F'ing what? 89% time spent in infix:<~> ?!?

[13:49] <ShimmerFairy> jnthn: I may or may not be working on a small collection of P6 files to extract info from the UCD, so I may or may not be able to agree with that sentiment. :P

[13:50] <brrt> pmurias: it isn't new, no. but it is quite different from parsing arbitrary binary formats :-)

[13:50] <ShimmerFairy> flussence: from what little I saw of ICU when trying it out, it's set up more for someone who always wants to get down to the finest points of Unicode. I much prefer a more P6 style where things Just Work™ by default :)

[13:51] <zengargoyle> how do people test a modules un-exported functions?

[13:51] <jnthn> ShimmerFairy: I'm working on fixing the NFG stuff Right Now :)

[13:51] <jnthn> ShimmerFairy: It's not too crazy, but... :)

[13:51] *** n0tjack joined
[13:51] <ShimmerFairy> (e.g. have a string type for NFG level, instead of having to setup a long-named iterator to get at graphemes)

[13:52] <timotimo> azawawi: could you send over the output of MVM_SPESH_LOG=unzip_speshlog.txt ? (might want to compress that one before sending)

[13:52] <timotimo> AFK for a little bit

[13:52] <RabidGravy> zengargoyle, assuming they aren't "our" subs, by testing the code that uses them

[13:52] <RabidGravy> if they aren't used then what are they doing there ;-)

[13:53] *** _mg_ joined
[13:53] <ShimmerFairy> jnthn: heh, it's kinda funny that Perl 6 tends to have things that I want when using C++ :P . I'd like to write a P6 regex engine someday (instead of using inferior syntaxes), and of course that depends on a nice P6-inspired unicode library :)

[13:53] <zengargoyle> well, they're used internally and there may be many of them and they may be indidually testable but have no need to be exported to the end user.

[13:54] <RabidGravy> so yeah, it's test the things that use them *or*  inject methods via a role for instance that can exercise them directly

[13:55] <ShimmerFairy> zengargoyle: have you tried perhaps accessing them as Module_Name::sub_name(), if it's an "our" sub?

[13:56] <RabidGravy> zengargoyle, the latter has the advantage of being able to test behaviour that might not occur in the way they are being used in your methods

[13:56] <zengargoyle> well, what i settled on for the momemnt is doing 'is export(:FOR-TESTING)' like and using that in tests.

[13:56] <RabidGravy> normal methods

[13:56] <RabidGravy> which works too, but special code to enable testing always feels icky

[13:57] <zengargoyle> but it seems smelly to export something only so you can actually test it

[13:57] *** tokuhirom left
[13:57] <RabidGravy> yeah

[13:57] <zengargoyle> yeah...

[13:57] <RabidGravy> the role idea would work

[13:57] <RabidGravy> so e.g.

[13:57] <azawawi> timotimo: it is 7 seconds without inflate(...) and 21 seconds with inflate

[13:57] <zengargoyle> and yeah, can mess with using 'our' but that seems a bit wonky as well.

[13:57] <flussence> zengargoyle: could extend the module with another one that exports the subs...

[13:58] <ShimmerFairy> That's actually how I'd do it, probably. "All is fair if you predeclare [wanting access to functions normally only needed in testing]" and all that :P

[13:59] <RabidGravy> m: class F { sub wazz() { say "foo" };};  role Testy {  method test-wazz() { wazz() }};  my $f = F.new; $f does Testy; $f.test-wazz  

[13:59] <camelia> rakudo-moar 3c1770: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nYnVXvKy1c␤Undeclared routine:␤    wazz used at line 1␤␤»

[13:59] <zengargoyle> didn't occur to me that a module could be extended like a class.

[13:59] <azawawi> timotimo: i bet it is https://github.com/retupmoca/P6-Compress-Zlib/blob/master/lib/Compress/Zlib.pm6#L95 :)

[13:59] <RabidGravy> okay that's a shit idea

[14:00] * zengargoyle still a bit fuzzy on module vs class vs old perl 5 package and namespaces and such

[14:01] * azawawi home &

[14:01] <n0tjack> zengargoyle: the solution is just to write a big long unmodular script with a bunch of functions 

[14:01] *** rurban left
[14:01] <zengargoyle> heh, other thought was a sub MAIN('test') and calling that as a subtest from a .t file. :)

[14:02] *** cygx joined
[14:02] <cygx> o/

[14:03] <cygx> m: my @a; say @a[^3] = 1..*; .say for @a

[14:03] <camelia> rakudo-moar 3c1770: OUTPUT«()␤»

[14:03] <cygx> m: my @a; say @a[flat ^3] = 1..*; .say for @a

[14:03] <camelia> rakudo-moar 3c1770: OUTPUT«(1 2 3)␤1␤2␤3␤»

[14:03] <cygx> ^- bug or feature?

[14:03] <ShimmerFairy> zengargoyle: another option is to have an exported  sub test-internal  that runs tests on the internal subs. Still a tiny bit leaky, but at least you're just exposing a test function :)

[14:03] <diakopter> anyone have a link to a recent perl6-bench output run?

[14:03] <RabidGravy> m: module F { sub wazz() { say "foo" };};  module  F {  our sub test-wazz() { wazz() }};  F::test-wazz()

[14:03] <camelia> rakudo-moar 3c1770: OUTPUT«5===SORRY!5=== Error while compiling /tmp/V4B5zfSOrq␤Redeclaration of symbol F␤at /tmp/V4B5zfSOrq:1␤------> 3{ sub wazz() { say "foo" };};  module  F7⏏5 {  our sub test-wazz() { wazz() }};  F:␤    expecting any of:␤        generic role␤»

[14:04] <RabidGravy> I'll hit the right thing at some point

[14:05] *** azawawi left
[14:06] <pmurias> brrt: it's different from parsing arbitrary ones, most of the binary formats are intended to be machine readable so they don't contain as much crazy stuff as the text things grammars parse

[14:07] <brrt> yeah, i know. i'm just... sceptical it should be a primary goal

[14:07] <pmurias> brrt: for the crazy bits it should be possible to provide both a hand written serializer/deserializer

[14:08] *** xpen joined
[14:08] <brrt> uhuh

[14:08] *** softmoth joined
[14:08] *** kjs_ joined
[14:09] <jnthn> zengargoyle: I don't know the answer, but it is on the xmas list of thigns to review: https://rt.perl.org/Ticket/Display.html?id=124316

[14:09] <zengargoyle> i guess i'd like a way to violate scoping during the 'create the module' phase, but keep things nice and locked away once it's compiled and stuffed into a repo somewhere.

[14:10] <n0tjack> m: say $4; # why is this valid syntax, what does it mean?

[14:10] <camelia> rakudo-moar 3c1770: OUTPUT«Nil␤»

[14:11] <pmurias> brrt: for things like the moar variable length integer encoding I would find it acceptable to have to write imperative serialize/deserialize methods

[14:11] *** ely-se left
[14:11] * zengargoyle doesn't grok jnthn's link.

[14:12] <n0tjack> what does $4 mean?

[14:12] <jnthn> zengargoyle: oh, sorry!

[14:12] <n0tjack> m: say $(4+5);

[14:12] <camelia> rakudo-moar 3c1770: OUTPUT«9␤»

[14:12] <jnthn> cygx: I mean https://rt.perl.org/Ticket/Display.html?id=124316 for the answer to your question :)

[14:12] <zengargoyle> :)

[14:12] * jnthn should learn to read :)

[14:13] <RabidGravy> reading's over-rated

[14:13] <n0tjack> m: say $.WHAT;

[14:13] <camelia> rakudo-moar 3c1770: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DGeOnvIUsZ␤Variable $.WHAT used where no 'self' is available␤at /tmp/DGeOnvIUsZ:1␤------> 3say $.WHAT7⏏5;␤    expecting any of:␤        argument list␤        term␤»

[14:14] <flussence> n0tjack: «perl6 --target=ast -e '$4'» might explain

[14:14] *** _mg_ left
[14:14] *** xpen left
[14:15] <n0tjack> flussence: that's a neat switch I didn't know about. but I'm not familiar enough with P6's grammar to make sense of that QAST

[14:15] <n0tjack> this seems relevant QAST::Var(local __args__ :decl(param))

[14:15] <ShimmerFairy> m: "abcde" ~~ /(a) (b) (c) (d) (e)/; say $4

[14:15] <camelia> rakudo-moar 3c1770: OUTPUT«｢e｣␤»

[14:15] <ShimmerFairy> n0tjack: it's just a shorthand for accessing numbered captures in a regex match :)

[14:15] <n0tjack> oh, it's sugar for $/[4]

[14:16] <n0tjack> it's the normal (in a p5 sense) $4

[14:16] <cygx> jnthn: so it's on The List of Things to Fix Before Christmas

[14:16] <cygx> good

[14:16] <n0tjack> ShimmerFairy: thanks

[14:16] <ShimmerFairy> n0tjack: except zero-indexed, where (IIRC) P5 is 1-indexed

[14:16] <flussence> that's the "&postcircumfix:<[ ]>, lexical $/, Int" part at the bottom

[14:16] *** virtualsue left
[14:16] *** andreoss left
[14:17] <n0tjack> flussence: thanks, learning to read the AST will def. help me come up to speed with p6

[14:17] <flussence> it doesn't always make sense but it's useful when it does

[14:17] <RabidGravy> ShimmerFairy, yeah 'cause $0 is something else in P5 (which it got from the unix shell)

[14:18] <n0tjack> and what is $ in  $(4+5)  ?

[14:18] <brrt> pmurias: yes... ish. some of these varint things are really standard

[14:18] <flussence> n0tjack: item context

[14:19] <ShimmerFairy> itemization, e.g.  $@list  or $(Foo.I-return-something-that's-not-guaranteed-an-item)

[14:19] <n0tjack> thanks flussence, ShimmerFairy 

[14:19] <brrt> on the other hand, you can always fall back to just reading the bytes out of a Buf[uint8]

[14:20] <timotimo> retupmoca: hey, would you be interested in optimizing Compress::Zlib a little bit? https://github.com/retupmoca/P6-Compress-Zlib/blob/master/lib/Compress/Zlib.pm6#L95 - these calls to infix:<~> are hella expensive

[14:21] <timotimo> retupmoca: so maybe it should build a list of bufs and join them at the end ... if we even have a join candidate for bufs?

[14:22] *** bjz_ left
[14:23] *** ely-se joined
[14:24] <timotimo> retupmoca: from the implementation of infix:<~>, it seems like it's the typical problem where the beginning of the string - the part that keeps growing - gets copied over and over again

[14:25] <timotimo> i would be interested to know how many chunks inflate spits out for the files azawawi's inflating

[14:26] <timotimo> in total, there's 3155 calls to infix:<~>, and inflate is called 27 times

[14:26] <timotimo> m: say "so the average file has { 3155 / 27 } chunks"

[14:26] <camelia> rakudo-moar 3c1770: OUTPUT«so the average file has 116.851852 chunks␤»

[14:27] <timotimo> so the first ~1024 bytes get copied 115 times, the second 114 times, the third 113 times etc etc

[14:27] <RabidGravy> nasty

[14:27] <retupmoca> oh, that's not nice

[14:28] <timotimo> :)

[14:28] <timotimo> at least the bottleneck was easy to spot!

[14:28] <retupmoca> would [~] on a list be better if Buf.join doesn't exist?

[14:28] <timotimo> yes

[14:28] <timotimo> no

[14:28] <timotimo> it wouldn't, i'm afraid

[14:28] * jnthn wonders how ~ on Bufs works also

[14:28] <retupmoca> eh, that's what I suspected

[14:28] <jnthn> Like, does it loop and push, or does it use splice

[14:28] <timotimo> no, it uses loop and bindpos/atpos

[14:28] <jnthn> eek

[14:28] <timotimo> two loops

[14:28] <jnthn> nqp::splice would be way faster

[14:29] <diakopter> <- oops?

[14:29] <jnthn> Not ideal, but.. :)

[14:30] <n0tjack> m: say ~1e6;

[14:30] <camelia> rakudo-moar 3c1770: OUTPUT«1000000␤»

[14:31] <n0tjack> m: say ~1e66;

[14:31] <camelia> rakudo-moar 3c1770: OUTPUT«1e+66␤»

[14:31] <n0tjack> wonder where the cutover is

[14:31] <n0tjack> oh, maybe at the integer boundary

[14:31] <n0tjack> m: say ~((2**64)-1);

[14:31] <camelia> rakudo-moar 3c1770: OUTPUT«18446744073709551615␤»

[14:31] <n0tjack> m: say ~((2**64));

[14:31] <camelia> rakudo-moar 3c1770: OUTPUT«18446744073709551616␤»

[14:31] <timotimo> subbuf also uses a loop and bindpos/atpos, so could also use splice instead

[14:32] <RabidGravy> make all things faster!

[14:33] <timotimo> now about six people in here know exactly what to do about this; who is going to actually write the patch? :)

[14:34] <RabidGravy> m: say (^6).pick

[14:34] <camelia> rakudo-moar 3c1770: OUTPUT«0␤»

[14:34] <timotimo> whoaaa, what are the odds!

[14:35] <RabidGravy> WE HAVE A WINNER!

[14:35] * zengargoyle is not a number

[14:35] * zengargoyle is a free man

[14:35] <timotimo> ahahahahahahahahahaha

[14:35] <tadzik> :D

[14:36] <tadzik> *guitars*

[14:36] <timotimo> *drums*

[14:36] <diakopter> tadzik: XD

[14:36] <RabidGravy> *mad thing that makes a sound like a leprechaun being tortured*

[14:36] * tadzik doesn't actually remember if guitars come in first

[14:37] * tadzik also doesn't know where this quote actually comes from and blindly attributes it to Iron Maiden

[14:37] <timotimo> iron maiden got it from the TV Show "The Prisoner"

[14:37] <timotimo> that's also the name of the song, IIrC

[14:37] <tadzik> quite appropriate, yes

[14:37] <timotimo> i only saw a little bit of The Prisoner. i did not quite understand it

[14:38] <zengargoyle> who are you?  the new number 2. who is number 1? you are number 6. i am not a number, im a free man.

[14:38] <gfldex> RabidGravy: you may be interested in this merchandice http://www.grand-illusions.com/acatalog/Non_Transitive_Dice_-_Set_1.html

[14:38] <timotimo> we want information. information. information!

[14:38] <RabidGravy> I've got the whole bunch of them on DVD and I still don't completely understand it 

[14:38] <tadzik> m: say "we want" ~ "information, " xx 3

[14:38] <camelia> rakudo-moar 3c1770: OUTPUT«we wantinformation,  information,  information, ␤»

[14:39] <tadzik> yeah, drums come in first

[14:39] * tadzik hands over his nerd badge

[14:39] <itz_stmuk> m: macro a { 'foo' }; say a

[14:39] <camelia> rakudo-moar 3c1770: OUTPUT«===SORRY!===␤Too few positionals passed; expected 3 arguments but got 2␤»

[14:39] <retupmoca> timotimo: https://github.com/retupmoca/P6-Compress-Zlib/commit/a2e3f0476973dc08e377900f346a6fa519fb5299

[14:39] *** chenryn joined
[14:39] <RabidGravy> gfldex, :)

[14:39] <itz_stmuk> never watch the last episode of The Prisoner

[14:40] <tadzik> it breaks the 4th wall and makes yourself a prisoner?

[14:40] <pmurias> jnthn: sometimes when compiling larger files with nqp-js (cross-compiling), parts of the output (JavaScript) go missing 

[14:40] <pmurias> jnthn: how should I debug such an error?

[14:40] <itz_stmuk> its like Matrix 2 and 3 .. only far far worse

[14:40] <timotimo> retupmoca: is that a lot better?

[14:40] *** sufrostico left
[14:41] <timotimo> i don't really know how good buf.list is

[14:41] <retupmoca> idk, I didn't benchmark it

[14:41] <retupmoca> I just killed the '~'

[14:41] <RabidGravy> itz_stmuk, possiblly what you are looking for was

[14:41] <RabidGravy> m: macro a { quasi { "foo" } }; say a

[14:41] <camelia> rakudo-moar 3c1770: OUTPUT«foo␤»

[14:41] <timotimo> itz_stmuk: which episode is the one with the trial? where the jumpy guy comes out and bounces all around, annoying everybody?

[14:41] <jnthn> pmurias: "Go missing"? o.O

[14:42] <retupmoca> but it's a VMArray, so I expect .list to be decent

[14:42] <jnthn> pmurias: Well-formed bits, or just random bits?

[14:42] *** rindolf left
[14:42] <itz_stmuk> timotimo: I think there is a computer in it but I blanked most of it

[14:42] <itz_stmuk> I've not watched for ages

[14:43] <pmurias> jnthn: Parts of code that should be joined by a nqp::join just disappear

[14:44] <itz_stmuk> RabidGravy: I was testing the error message for that macro which isn't as doc'd

[14:44] <timotimo> fair enough :)

[14:44] <timotimo> retupmoca: it still passes tests, though?

[14:44] <RabidGravy> ah right

[14:45] <timotimo> seems like you only have ::Raw in travis-ci

[14:46] *** Oatmeal left
[14:47] <retupmoca> yeah, it passed tests on my local machine

[14:47] <retupmoca> and also it's in travis-ci now

[14:47] <timotimo> good & good :)

[14:48] <timotimo> Compress::Zlib now handles Big Data™

[14:52] <jnthn> pmurias: No idea...I'd probably try to produce an isolated test case

[14:52] <retupmoca> I'm not sure who was running the profile for Compress::Zlib before, but I'd be interested to see how the new version compares

[14:54] <masak> greetings, #perl6

[14:54] <masak> m: sub m() { return -> { return "foo" } }; say m()()

[14:54] <camelia> rakudo-moar 3c1770: OUTPUT«Attempt to return outside of any Routine␤  in block <unit> at /tmp/FGmtrjjjyW:1␤␤»

[14:54] <masak> I claim there's no returning outside of any Routine going on here, so it's not a good error message.

[14:54] <masak> thoughts?

[14:55] <masak> I mean, those `return`s are clearly inside a Routine...

[14:55] <brrt> rakudo doesn't think so

[14:55] *** rindolf joined
[14:55] <gfldex> both returns should return from m. So your m can return twice.

[14:55] <masak> does Rakudo not believe in lexical returns?

[14:56] <brrt> m: sub m() { -> { return "foo"; } }; say m().perl;

[14:56] <camelia> rakudo-moar 3c1770: OUTPUT«->  { #`(Block|59615944) ... }␤»

[14:56] <timotimo> retupmoca: it was azeawawi; he's currently commuting towards home IIUC

[14:56] <brrt> m: sub m() { -> { return "foo" } }; say m()();

[14:56] <camelia> rakudo-moar 3c1770: OUTPUT«Attempt to return outside of any Routine␤  in block <unit> at /tmp/RYbK44r_8s:1␤␤»

[14:56] <timotimo> or does "home &" mean that his bus reached his destination?

[14:56] <brrt> the returned thing is clearly a closure

[14:56] <masak> yes, it is. I agree.

[14:56] <brrt> but rakudo thinks it is a block

[14:56] <jnthn> m: sub m() { return -> { return "foo" } }; sub n() { say m()() }; n()

[14:56] <camelia> rakudo-moar 3c1770: OUTPUT«Attempt to return outside of any Routine␤  in block <unit> at /tmp/FeOOSQqU8b:1␤␤»

[14:56] <masak> nor it's inside even more routines :P

[14:57] <masak> now*

[14:57] <diakopter> neither

[14:57] <jnthn> That clearly shows it's lexical, otherwise it might accientally work

[14:57] <brrt> routinings

[14:57] <jnthn> "work" :)

[14:57] <jnthn> m: return

[14:57] <camelia> rakudo-moar 3c1770: ( no output )

[14:57] <masak> jnthn: ok, so it's just the error message that's confused.

[14:57] <jnthn> Yeah

[14:57] <jnthn> Feel free to patch the error message if you've a better one.

[14:57] *** tokuhirom joined
[14:57] <masak> m: macro m { quasi { return } }; sub foo { say "A"; m(); say "B" }; foo()

[14:57] <camelia> rakudo-moar 3c1770: OUTPUT«A␤Attempt to return outside of any Routine␤  in any  at /tmp/unLtwpEl6E:1␤  in sub foo at /tmp/unLtwpEl6E:1␤  in block <unit> at /tmp/unLtwpEl6E:1␤␤»

[14:58] <gfldex> if you add any more features rakudo might become self-aware

[14:58] * masak grins, madly

[14:58] *** n0tjack left
[14:58] <masak> that's actually completely the expected *behavior*

[14:58] <dalek> rakudo/nom: 1f81099 | (Vladimir Lettiev)++ | tools/build/Makefile-Moar.in:

[14:58] <dalek> rakudo/nom: fixed linking order

[14:58] <dalek> rakudo/nom: 

[14:58] <dalek> rakudo/nom: With gnu linker option --as-needed (default in most linux distros) -lmoar

[14:58] <dalek> rakudo/nom: discarded if object files that use it is not behind it

[14:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f8109904c

[14:58] <dalek> rakudo/nom: f699831 | FROGGS++ | tools/build/Makefile-Moar.in:

[14:58] <dalek> rakudo/nom: Merge pull request #564 from vlet/fix

[14:58] <dalek> rakudo/nom: 

[14:58] <dalek> rakudo/nom: fixed linking order

[14:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f6998312ca

[14:58] <masak> but the error message needs work.

[14:58] <masak> (007 gets that one wrong right now)

[14:58] *** n0tjack joined
[14:59] <masak> jnthn++ # was probably responsible for making returns so lexical :)

[14:59] *** khw joined
[14:59] <diakopter> m: sub m() { BEGIN return -> { -> { BEGIN return "foo" } } }; sub n() { say m()()() }; n()

[14:59] <camelia> rakudo-moar 3c1770: OUTPUT«foo␤»

[15:00] <gfldex> i believe to have found a nasty bug with http://rosettacode.org/wiki/Ordered_words#Perl_6

[15:00] <masak> m: macro m { quasi { &COMPILING::return() } }; sub foo { say "A"; m(); say "B" }; foo()

[15:00] <camelia> rakudo-moar 3c1770: OUTPUT«A␤Cannot find method 'Any'␤  in any  at /tmp/8e4ts_lHpz:1␤  in sub foo at /tmp/8e4ts_lHpz:1␤  in block <unit> at /tmp/8e4ts_lHpz:1␤␤»

[15:00] <masak> NYI, I guess

[15:00] <masak> someone should tell the macro guy to hurry up

[15:00] <gfldex> if i run  that one locally it returnes 3 words where it should return 16

[15:00] <diakopter> masak: ^ look I fixed it

[15:00] <RabidGravy> when I first started actually writing Perl 6 I was fascinated by the idea of macros, but I haven't actually encountered something where I would sensibly use one

[15:00] <gfldex> the perl5 version works as expectd

[15:00] <gfldex> if i sullpy it with a shorter word list it starts to work

[15:00] <masak> diakopter: you are truly helpful

[15:00] <lucasb_> wait, what? A plain 'return' outside subs not giving a warning is wrong, isn't it?

[15:00] *** chenryn left
[15:01] <diakopter> masak: I know

[15:01] <masak> lucasb_: define "outside".

[15:01] <masak> m: return

[15:01] <camelia> rakudo-moar 3c1770: ( no output )

[15:01] <gfldex> the culprit seams to be 'grep { [le] .comb }' but only for long lists

[15:01] <diakopter> what even does BEGIN return mean

[15:01] <masak> lucasb_: I mean, that's clearly wrong, IMO.

[15:01] <gfldex> would be nice if someone could confirm that

[15:01] <lucasb_> masak: ^^ ok, it's wrong to me too :)

[15:02] <masak> diakopter: it means return, but really really early :P

[15:02] <diakopter> TO WHERE

[15:02] <masak> Kansas.

[15:02] <lucasb_> m: if 1 { say 'a'; return; say 'b' }; say 'c'

[15:02] <camelia> rakudo-moar 3c1770: OUTPUT«a␤»

[15:02] <lucasb_> m: while 1 { say 'a'; return; say 'b' }; say 'c'

[15:02] <camelia> rakudo-moar 3c1770: OUTPUT«a␤»

[15:02] *** tokuhirom left
[15:03] <masak> jnthn: I think "Routine already returned" or "Routine cannot return twice" is what I would expect to see.

[15:03] <masak> jnthn: the "return outside of any Routine" message is fine when things are *lexically* outside of Routines.

[15:05] <diakopter> m: say say say say -> { BEGIN return BEGIN return BEGIN return say return 333 }()

[15:05] <camelia> rakudo-moar 3c1770: OUTPUT«333␤True␤True␤True␤»

[15:05] *** brrt left
[15:05] <tadzik> （　° ー°）

[15:05] <diakopter> too few TRUEs

[15:06] <lucasb_> diakopter: the standard placeholder number is 2*333 :)

[15:06] <diakopter> m: 2**333

[15:06] <camelia> rakudo-moar 3c1770: OUTPUT«WARNINGS:␤Useless use of "**" in expression "2**333" in sink context (line 1)␤»

[15:06] <pink_mist> 668 The Neighbour of the Beast

[15:07] <diakopter> m: say 2**333

[15:07] <camelia> rakudo-moar 3c1770: OUTPUT«17498005798264095394980017816940970922825355447145699491406164851279623993595007385788105416184430592␤»

[15:07] <diakopter> m: say 2**2**333

[15:07] <camelia> rakudo-moar 3c1770: OUTPUT«0␤»

[15:07] <masak> 'night, #perl6

[15:07] <diakopter> wait what

[15:07] <tadzik> g'nite

[15:07] *** CIAvash joined
[15:08] <diakopter> how is that zero

[15:08] <diakopter> p: say 2**2**333

[15:08] <diakopter> rp: say 2**2**333

[15:09] <diakopter> n: say 2**2**333

[15:09] <camelia> niecza v24-109-g48a8de3: OUTPUT«sh: mono: command not found␤»

[15:09] <FROGGS> diakopter: it overflows somewhere

[15:09] <timotimo> gnite masak 

[15:09] * diakopter panics

[15:09] <timotimo> diakopter: we have a bug in there

[15:09] <FROGGS> (it's already tickited)

[15:10] <timotimo> is nobody else working on the splice patch for infix:<~>(Buf, Buf) and subbuf? otherwise, i'll start on it

[15:10] <jnthn> timotimo: Not me :)

[15:10] <diakopter> m: say 2**333333333

[15:10] <FROGGS> me neither :o)

[15:10] <PerlJam> anyone know right off where S/// is described in the specs?

[15:10] <camelia> rakudo-moar 3c1770: OUTPUT«(timeout)»

[15:11] <lucasb_> PerlJam: has it ever got written down? I had to hunt the irclogs and changelogs to learn about it

[15:11] <PerlJam> lucasb_: good question.  I dunno

[15:12] <flussence> there's only mention of an S metaop there...

[15:12] <FROGGS> PerlJam: there you go :o)  https://github.com/perl6/roast/commit/e82eb2dfb134e7acd30df99fa77298e05b5f05ae

[15:12] <lucasb_> just reminding that the S metaop is broken :)

[15:12] <diakopter> it is?

[15:12] <FROGGS> how so?

[15:12] <lucasb_> m: say so False S& False

[15:12] <camelia> rakudo-moar 3c1770: OUTPUT«True␤»

[15:13] <PerlJam> I'm interested in what the return value of   "foo" ~~ S/a//;  should be

[15:13] <FROGGS> PerlJam: "foo"

[15:13] <PerlJam> I would expect it to be "foo", but currently that's not the case

[15:13] <FROGGS> O.o

[15:13] <FROGGS> m: say "foo" ~~ S/a//

[15:13] <camelia> rakudo-moar 3c1770: OUTPUT«Potential difficulties:␤    Smartmatch with S/// can never succeed because the subsequent string match will fail␤    at /tmp/j5jD2MNZhi:1␤    ------> 3say "foo" ~~ S/a//7⏏5<EOL>␤False␤»

[15:14] <diakopter> heh

[15:14] <FROGGS> m: $_ = "foo"; say S/a//

[15:14] <camelia> rakudo-moar 3c1770: OUTPUT«Nil␤»

[15:14] <FROGGS> hmmmm

[15:15] <PerlJam> well, since at least 2 of us agree on what it should be, I'll take the current behavior as a bug

[15:15] *** pmurias_ joined
[15:16] <FROGGS> IMO this:  $_ = "foo"; say S/a//  should translate more or less directly to: say "foo".subst(rx/a/, '')

[15:17] <flussence> m: say S[a] = '' given 'foo'

[15:17] <camelia> rakudo-moar 3c1770: OUTPUT«Nil␤»

[15:17] <flussence> m: say s[a] = '' given 'foo'

[15:17] <camelia> rakudo-moar 3c1770: OUTPUT«Nil␤»

[15:17] <flussence> m: say 'foo' ~~ s/a//

[15:17] <camelia> rakudo-moar 3c1770: OUTPUT«False␤»

[15:18] <FROGGS> the smartmatch there returns the matched string

[15:18] <FROGGS> err, the match

[15:18] <flussence> m: say $/ given ('foo' ~~ s/a//)

[15:18] <camelia> rakudo-moar 3c1770: OUTPUT«Nil␤»

[15:18] <flussence> oh I see

[15:18] *** pmurias left
[15:18] <diakopter> m: $_ = "foo"; S/o/f/; say $_; s/o/f/; say $_

[15:18] <camelia> rakudo-moar 3c1770: OUTPUT«foo␤ffo␤»

[15:19] <diakopter> hrm

[15:25] <PerlJam> m: $_ = "a b\nc\td"; say Ss/b c d/x y z/; 

[15:25] <camelia> rakudo-moar f69983: OUTPUT«a x␤y        z␤»

[15:25] <PerlJam> m: $_ = "a b\nc\td"; say SS/b c d/x y z/; 

[15:25] <camelia> rakudo-moar f69983: OUTPUT«5===SORRY!5=== Error while compiling /tmp/J6kGAuDlRq␤Missing required term after infix␤at /tmp/J6kGAuDlRq:1␤------> 3$_ = "a b\nc\td"; say SS/b c d/x y z/7⏏5;␤    expecting any of:␤        prefix␤        term␤»

[15:26] *** rogu317 joined
[15:28] *** sufrostico joined
[15:28] <timotimo> oh, we can't make subbuf use splice - or at least not just a single splice - because splice would begin at the beginning of the "source" array

[15:29] *** CIAvash left
[15:31] *** pollei joined
[15:33] *** rurban joined
[15:34] *** rogu317 left
[15:35] *** zakharyas left
[15:35] <dalek> roast: 64f19c9 | (Steve Mynott)++ | S32-io/IO-Socket-INET.pl:

[15:35] <dalek> roast: constants have worked for a while so use them

[15:35] <dalek> roast: review: https://github.com/perl6/roast/commit/64f19c933a

[15:36] <pink_mist> .pl not .p6?

[15:37] *** cygx left
[15:38] *** ely-se left
[15:40] <lucasb_> m: $_ = 'foo'; say S/a//

[15:40] <camelia> rakudo-moar f69983: OUTPUT«Nil␤»

[15:40] <lucasb_> star: $_ = 'foo'; say S/a//

[15:40] <camelia> star-m 2015.09: OUTPUT«foo␤»

[15:40] <lucasb_> ^^ worked in star? Is a regression?

[15:41] <lucasb_> in star, 'foo' ~~ S/// is a smartmatch too

[15:43] <FROGGS> lucasb_: "worked" probably means that the behaviour was different

[15:43] <n0tjack> m: $_ = 'whatevs'; say s[s]='z';

[15:43] <camelia> rakudo-moar f69983: OUTPUT«｢s｣␤»

[15:43] <FROGGS> lucasb_: TimToady decided that the old behaviour was not correct, and I agree

[15:44] <lucasb_> FROGGS: oh, ok. sorry for the noise

[15:44] <FROGGS> np :o)

[15:44] <FROGGS> bbl &

[15:44] *** FROGGS left
[15:46] *** weihan_ left
[15:47] <n0tjack> m: $_ = 'whatevs'; say S[s]='z';

[15:47] <camelia> rakudo-moar f69983: OUTPUT«whatevz␤»

[15:47] <n0tjack> hee hee

[15:47] *** mayuresh joined
[15:48] <n0tjack> I honestly cannot wait for the first IOP6C

[15:48] <mayuresh> hello :)

[15:48] <n0tjack> heyo

[15:48] <mayuresh> n0tjack, what the iop6c?

[15:48] <mayuresh> some kind-a conference for perl6?

[15:48] <n0tjack> international obfuscated p6 contest

[15:48] <mayuresh> whoa ... :)

[15:48] <n0tjack> I mean look at that ^ ... that's /normal/ p6.

[15:49] *** rurban left
[15:50] <gfldex> m: say ++$; say ++$; say $+=2 for 1..10

[15:50] <camelia> rakudo-moar f69983: OUTPUT«1␤1␤2␤4␤6␤8␤10␤12␤14␤16␤18␤20␤»

[15:51] <n0tjack> m: say $+=2 for 1..3;

[15:51] <timotimo> jnthn: using splice instead of the two loops makes time perl6 -e 'my $res = Buf.new; loop (my int $i = 0; $i < 10_000; $i++) { $res ~= Buf.new(0, 9, 9, 9, 9, 9, 9, 9, 9, 1) };' a little bit more than 2x faster

[15:51] <camelia> rakudo-moar f69983: OUTPUT«2␤4␤6␤»

[15:51] <n0tjack> why does that start at 2?

[15:51] <n0tjack> it should start at 3

[15:51] <n0tjack> assuming $+= ... is the same as $_ += ... is the same as $_ = $_ + ...

[15:52] <gfldex> it starts at 0 before the first $ = $ + 2

[15:52] <n0tjack> oh but it's not, it's ignoring $_

[15:52] <gfldex> $ aint $_

[15:52] <n0tjack> what is $ as a variable then?

[15:53] <n0tjack> m: say $;

[15:53] <camelia> rakudo-moar f69983: OUTPUT«(Any)␤»

[15:53] <jnthn> timotimo: Improvement :)

[15:53] <n0tjack> m: $ += 99;

[15:53] <camelia> rakudo-moar f69983: ( no output )

[15:53] <n0tjack> m: $ += 99 say $;

[15:53] <camelia> rakudo-moar f69983: OUTPUT«5===SORRY!5=== Error while compiling /tmp/aj9Li73EYo␤Two terms in a row␤at /tmp/aj9Li73EYo:1␤------> 3$ += 997⏏5 say $;␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤ …»

[15:53] <n0tjack> m: $ += 99; say $;

[15:53] <camelia> rakudo-moar f69983: OUTPUT«(Any)␤»

[15:54] <gfldex> n0tjack: it's a (a!) anonymouse state variable

[15:54] <timotimo> jnthn: do you think we'd want a bigger version of splice with an extra argument that'd let us splice a from another offset than 0 in the source array

[15:54] <gfldex> n0tjack: see http://design.perl6.org/S02.html#Names

[15:55] <n0tjack> gfldex: you realize I'm going to use these powers for evil, right?

[15:55] <gfldex> n0tjack: i expect you to! 

[15:55] <timotimo> jnthn: actually, it seems to scale better

[15:55] *** mayuresh left
[15:55] <jnthn> timotimo: I've been pondering a general memcpy op

[15:56] <gfldex> n0tjack: the devil is in the detail 'say $++; say $++' are actually two independent variables, that happen to have no name

[15:56] <timotimo> at 20_000 it's 14s vs 41s, but at 10_000 it's only 3.9s vs 10.9s

[15:56] <timotimo> jnthn: me, too

[15:56] <n0tjack> gfldex: it's reset every statement?

[15:56] <n0tjack> no, then the accumulator thing you did wouldn't work...

[15:56] <timotimo> i wonder if we have any tests about infix:<~> between Bufs of different int sizes

[15:56] <gfldex> n0tjack: yes. I could not resist to add this to http://rosettacode.org/wiki/Variables#Perl_6

[15:57] <n0tjack> m: say $++ for 1..3; for 1..3 { say $++; }

[15:57] <camelia> rakudo-moar f69983: OUTPUT«0␤1␤2␤0␤1␤2␤»

[15:57] *** jdv79 joined
[15:57] <dalek> rakudo/nom: a333147 | timotimo++ | src/core/Buf.pm:

[15:57] <dalek> rakudo/nom: infix:<~> on Buf can use nqp::splice for better speed

[15:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a333147db7

[16:01] * itz_stmuk wonders if IO::Socket::INET::PIO::PF_INET etc. should be available to programmers 

[16:01] <n0tjack> gfldex: ha! before reading that, I hadn't realized subset notation worked on normal variable declarations too.

[16:02] *** adu joined
[16:02] <gfldex> rosettacode is full of wisdom :)

[16:02] <n0tjack> m: my \naked = <n u d e>; say naked.WHAT; say naked[2];

[16:02] <camelia> rakudo-moar f69983: OUTPUT«(List)␤d␤»

[16:02] <n0tjack> is naked a scalar (reference) to an array there, or a proper @-like array?

[16:02] *** crux left
[16:02] *** mbrock joined
[16:03] *** rurban joined
[16:03] <jnthn> n0tjack: Proper @-like

[16:03] <jnthn> n0tjack: Without sigil means "don't impose any context"

[16:04] <n0tjack> what do you mean by "don't impose context"? if naked is @-like, then the compiler surely noticed <n u d e> is an array and (from context) decided naked's true sigil is @?

[16:05] <gfldex> m: loop (;$++ < 4;){ loop (;$++ < 3;) { say $++ } } # this may or may not be a bug

[16:05] <camelia> rakudo-moar f69983: OUTPUT«0␤1␤2␤»

[16:06] <jnthn> m: my @a = 1; my \a = 1; say @a.perl; way a.perl

[16:06] <camelia> rakudo-moar f69983: OUTPUT«5===SORRY!5=== Error while compiling /tmp/B4mJzGKvf9␤Undeclared routine:␤    way used at line 1. Did you mean 'say'?␤␤»

[16:06] <jnthn> m: my @a = 1; my \a = 1; say @a.perl; say a.perl

[16:06] <camelia> rakudo-moar f69983: OUTPUT«[1]␤1␤»

[16:06] <jnthn> n0tjack: Assigning to something wiht an @ sigil is storing into an array

[16:07] <jnthn> And note that

[16:07] <psch> gfldex: not sure where you see a bug there

[16:07] <n0tjack> jnthn: so \whatever creates the minimal possible container for the referent?

[16:07] <jnthn> m: my @a = <n u d e>; say @a.WHAT

[16:07] <camelia> rakudo-moar f69983: OUTPUT«(Array)␤»

[16:07] <jnthn> m: my \a = <n u d e>; say a.WHAT

[16:07] <camelia> rakudo-moar f69983: OUTPUT«(List)␤»

[16:07] <jnthn> n0tjack: It creates *no* container

[16:07] <gfldex> psch: all 3 $s should be different state variables, as it stands there are only 2

[16:07] <psch> m: my $outer-state = 0; my $inner-state = 0; loop (;$outer-state++ < 4;) { loop (;$inner-state++ < 3;) { say $++ } }

[16:07] <camelia> rakudo-moar f69983: OUTPUT«0␤1␤2␤»

[16:08] <psch> gfldex: ^^^ that should clear it up

[16:08] <jnthn> n0tjack: It's just a direct reference stored in the lexical scope (which may in turn even be optimized down to a VM-legel register if nothing closes over it)

[16:08] <psch> gfldex: there is three, but the inner loop state isn't reset

[16:08] <n0tjack> ah, so a sigily-variable has the powers of both its sigil and its type, but a bare-variable only has the powers of its type?

[16:08] <jnthn> *level

[16:08] <gfldex> psch: i stand corrected and confused

[16:08] <jnthn> n0tjack: Something like that, yes :)

[16:08] <psch> gfldex: state maintains it's state across reentry and all those things

[16:09] <psch> gfldex: so the inner loop starts at 0 once, and never restarts

[16:09] <gfldex> psch: that makes sense and $++ even more ebil!

[16:09] <n0tjack> m: say \foo = my $bar = 'baz';

[16:09] <camelia> rakudo-moar f69983: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bUfsIH75Rh␤Preceding context expects a term, but found infix = instead␤at /tmp/bUfsIH75Rh:1␤------> 3say \foo =7⏏5 my $bar = 'baz';␤»

[16:10] * gfldex .oO( Stranger: I know Perl 6! Me: Good, explain { loop (;say $++ < 4;){ loop (;say $++ < 3;) { say $++ } }  }.

[16:10] <n0tjack> gfldex: He would have to be a very strange Stranger indeed to ask that question in the first place

[16:11] <n0tjack> oops, commute that pun.

[16:12] <dalek> rakudo/bool_enum: 49c8f9b | (Stefan Seifert)++ | src/ (3 files):

[16:12] <dalek> rakudo/bool_enum: Turn Bool into a proper enum

[16:12] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/49c8f9b49f

[16:12] <dalek> rakudo/bool_enum: 8b0d845 | (Stefan Seifert)++ | src/core/operators.pm:

[16:12] <dalek> rakudo/bool_enum: Fix SEQUENCE not expecting Bool ~~ Real to be true

[16:12] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/8b0d8455a7

[16:12] <dalek> rakudo/bool_enum: 25fc19b | (Stefan Seifert)++ | src/Perl6/Metamodel/EnumHOW.nqp:

[16:12] <dalek> rakudo/bool_enum: Fix type check for binding parameters

[16:12] <dalek> rakudo/bool_enum: 

[16:12] <dalek> rakudo/bool_enum: EnumHOW just needed an is_composed method like many other HOWs.

[16:12] <dalek> rakudo/bool_enum: Fixes regression in t/spec/S06-signature/optional.t

[16:12] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/25fc19bf1b

[16:12] <dalek> rakudo/bool_enum: 0102ca6 | (Stefan Seifert)++ | src/ (2 files):

[16:12] <dalek> rakudo/bool_enum: Bool improvements

[16:12] <dalek> rakudo/bool_enum: review: https://github.com/rakudo/rakudo/commit/0102ca6291

[16:15] <gfldex> is there any real and sensible usecase for anonymouse state variables?

[16:16] *** kjs_ left
[16:16] <psch> m: class Singleton { my $self; method new() { if !$++ { $self = self.bless } else { $self } } }; my $s = Singleton.new; my $ss = Singleton.new; say $s === $ss

[16:16] <camelia> rakudo-moar f69983: OUTPUT«True␤»

[16:16] <psch> heh

[16:16] <TimToady> nope, we're all gonna use Turing machines cuz everything else can be reduce to them

[16:16] <timotimo> m: class Test { submethod BUILD { say $++ } }; Test.new(); Test.new(); Test.new()

[16:16] <camelia> rakudo-moar f69983: OUTPUT«0␤1␤2␤»

[16:17] * TimToady does not recall deciding that failing S/// should return Nil, and suspects it was just an accident of reimplementation

[16:18] <diakopter> m: my \Colossus = my \Turing = return

[16:18] <camelia> rakudo-moar f69983: ( no output )

[16:19] *** FROGGS joined
[16:19] <n0tjack> m: constant \Does-this-work = do {42}; say Does-this-work;

[16:19] <camelia> rakudo-moar f69983: OUTPUT«42␤»

[16:25] <gfldex> m: my $a = $; my $b = $++ // 2; my $c = ++$ // 2; dd $a, $b, $c;

[16:25] <camelia> rakudo-moar a33314: OUTPUT«Any $var = Any␤Int $var = 0␤Int $var = 1␤»

[16:25] <gfldex> m: my $a = $ // 2; my $b = $++ // 2; my $c = ++$ // 2; dd $a, $b, $c;

[16:25] <camelia> rakudo-moar a33314: OUTPUT«Int $var = 2␤Int $var = 0␤Int $var = 1␤»

[16:26] <gfldex> why is b's $ turned into Int before the increment happend?

[16:27] <dalek> ecosystem: 6411446 | RabidGravy++ | META.list:

[16:27] <dalek> ecosystem: Add Object::Permission

[16:27] <dalek> ecosystem: 

[16:27] <dalek> ecosystem: https://github.com/jonathanstowe/Object-Permission

[16:27] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/6411446f63

[16:27] <psch> gfldex: because postfix:<++> returns something

[16:28] <psch> m: sub postfix:<plusplus>($a is rw) { my $b = $a; $a += 1; $b } # post increment as it's written, minus containering

[16:28] <camelia> rakudo-moar a33314: ( no output )

[16:29] <lucasb_> Doesn't it make sense if both s/// and S/// return a match object when success and Nil otherwise? Now, there should be a shortcut for both s/// and S/// to return the string (modified or not), otherwise the programmer would need 2 statements: one to change and the other get the actual string content

[16:29] <lucasb_> *to get

[16:29] <psch> gfldex: actually, that was the wrong candidate i looked at :)

[16:29] <psch> gfldex: multi postfix:<++>(Mu:U $a is rw) { $a = 1; 0 } # the right one

[16:29] <RabidGravy> possibily the most fundamentally pointless and crack induced thing I have made yet

[16:30] <diakopter> RabidGravy: crack is bad

[16:30] <itz_stmuk> RabidGravy: not XAP then ;)

[16:31] <RabidGravy> itz_stmuk, I was thinking of porting it, I actually have the source code here ;-)

[16:31] *** Begi1115 left
[16:31] <n0tjack> m: say @[1];

[16:31] <camelia> rakudo-moar a33314: OUTPUT«[1]␤»

[16:31] <n0tjack> m: say +@;

[16:31] <camelia> rakudo-moar a33314: OUTPUT«0␤»

[16:32] <itz_stmuk> :)

[16:32] <n0tjack> m: say %{'made-up'};

[16:32] <camelia> rakudo-moar a33314: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HKc0n167bN␤Unsupported use of %{'made-up'}; in Perl 6 please use %('made-up')␤at /tmp/HKc0n167bN:1␤------> 3say %{'made-up'}7⏏5;␤»

[16:32] <n0tjack> m: say @[*-1];

[16:32] <camelia> rakudo-moar a33314: OUTPUT«[WhateverCode.new]␤»

[16:33] <n0tjack> oh, I see, @ isn't an anonymous array variable, it's a contextifier

[16:35] <gfldex> n0tjack: not the sigil itself but @ followed by any bracket

[16:36] <psch> m: sub f($a) { say (@ .push($a)).perl }; f 1; f 2; f 3

[16:36] <camelia> rakudo-moar a33314: OUTPUT«[1]␤[1, 2]␤[1, 2, 3]␤»

[16:37] <n0tjack> gfldex: how does that relate to the use of bracketless @ for typecasting, as in sub(Int @foo) {...}; foo(my Int @ = [1,2,3,4]);  ?

[16:37] <psch> i'm really starting to like the space-lenient method call infix

[16:38] <gfldex> n0tjack: in that case i understand it to be some anonymouse state array

[16:38] <psch> in "my Int @", @ is clearly not a state-scoped, but my-scoped

[16:39] <psch> +variable

[16:39] *** adu left
[16:39] *** cschwenz joined
[16:39] <gfldex> it's a mind-field!

[16:39] <n0tjack> heh

[16:39] *** cschwenz left
[16:39] <lucasb_> when p6 have a Cat object, it will run after the anonymouse variables

[16:39] <n0tjack> lucasb_: going to be hard to catch him though

[16:39] <psch> lucasb_: and eye the Rats suspicuously :)

[16:40] *** raiph left
[16:40] <itz_stmuk> the cat would like the FatRats

[16:42] <n0tjack> m: say @[Inf];

[16:42] <camelia> rakudo-moar a33314: OUTPUT«[Inf]␤»

[16:42] <n0tjack> heh

[16:42] <gfldex> m: sub foo (@a) { dd @a }; foo((state Int @) = [1,2]); foo((state @) = [1,2]);

[16:42] <camelia> rakudo-moar a33314: OUTPUT«Array[Int] $var = Array[Int].new(1, 2)␤Array $var = $[1, 2]␤»

[16:43] <n0tjack> m: (constant @) = [1,2,3];

[16:43] <camelia> rakudo-moar a33314: OUTPUT«5===SORRY!5=== Error while compiling /tmp/zlKM508FvG␤Missing initializer on constant declaration␤at /tmp/zlKM508FvG:1␤------> 3(constant @7⏏5) = [1,2,3];␤»

[16:43] <n0tjack> eh, worth a shot.

[16:43] <TimToady> lucasb_: I don't understand why you want to make the match vs string decision separate from the s/// vs S/// notation, when the whole point of S/// is to return the string instead of the match

[16:45] <gfldex> m: $.VAR.name.say;

[16:45] <camelia> rakudo-moar a33314: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NMgZcz_BGo␤Variable $.VAR used where no 'self' is available␤at /tmp/NMgZcz_BGo:1␤------> 3$.VAR7⏏5.name.say;␤    expecting any of:␤        term␤»

[16:45] <lucasb_> TimToady: I'm trying to clarify my thoughts in a example, just a second :)

[16:45] <gfldex> m: $ .VAR.name.say; # not very introspective that fellow

[16:45] <camelia> rakudo-moar a33314: OUTPUT«===SORRY!===␤Method call must either supply a name or have a child node that evaluates to the name␤»

[16:47] <psch> r: A: { for 1 { for 1 { last A } } }

[16:47] <camelia> rakudo-jvm a33314: ( no output )

[16:47] <camelia> ..rakudo-moar a33314: OUTPUT«control exception without handler␤  in block  at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[16:47] <psch> i wonder where moar gets its handler there

[16:48] <psch> NQP doesn't install one via Grammar or Actions

[16:48] <psch> nqp-m: A: { for [1] { for [1] { last A } } }

[16:48] <camelia> nqp-moarvm: OUTPUT«No exception handler located for last_label␤   at gen/moar/stage2/NQPHLL.nqp:1416  (/home/camelia/rakudo-inst-2/share/nqp/lib/NQPHLL.moarvm::20)␤ from <unknown>:1  (/home/camelia/rakudo-inst-2/share/nqp/lib/NQPHLL.moarvm::23)␤ from <unknown>:1  (<ephemeral f…»

[16:48] <psch> ah

[16:48] <psch> hm

[16:48] <psch> that at least shows i'm right with not seeing it on an nqp level :)

[16:50] <psch> jnthn: should that work on nqp level?  'cause at the moment it looks to me like fixing it there is the easier way to fix the r-j bug

[16:50] *** abraxxa left
[16:59] *** tokuhirom joined
[17:02] <lucasb_> TimToady: ok, I was confused, nevermind. So a failed S/// should really return the original string, not Nil, right? I just thought it could be convenient to get a match object with .subst or S/// if the user ever needs it, or get a string from .subst-mutate and s/// if the user wants it, instead of the match object. But I understand, they are different operations.

[17:04] *** tokuhirom left
[17:04] * TimToady is never confused, except when he is.

[17:06] <dalek> rakudo/nom: f5276ca | TimToady++ | src/core/Failure.pm:

[17:06] <dalek> rakudo/nom: handled failures are still failures

[17:06] <dalek> rakudo/nom: 

[17:06] <dalek> rakudo/nom: so don't be quite so quick to coerce them to 0 or ''

[17:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5276ca2ba

[17:06] <dalek> rakudo/nom: ad08a1d | TimToady++ | src/core/Failure.pm:

[17:06] <dalek> rakudo/nom: Failure should also not return useful integer

[17:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad08a1d719

[17:19] *** rangerprice joined
[17:19] <jnthn> psch: Don't think labeled loops were implemented in NQP, no

[17:21] <n0tjack> m: goto comefrom;

[17:21] <camelia> rakudo-moar a33314: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LMZMQwBqk5␤Undeclared routine:␤    comefrom used at line 1␤␤»

[17:21] *** sufrostico left
[17:21] <rangerprice> hi guyz !

[17:22] <dalek> roast: 79e6d16 | TimToady++ | S05-substitution/subst.t:

[17:22] <dalek> roast: non-matching S/// should return original string

[17:22] <dalek> roast: review: https://github.com/perl6/roast/commit/79e6d1669c

[17:29] <psch> m: A: for 1 { for 1 { last A }; CONTROL { default { .perl.say } } } # oh boy

[17:29] <camelia> rakudo-moar ad08a1: OUTPUT«(signal SEGV)»

[17:29] <psch> that seems to confirm that mvm is cheating somehow with it's control handlers..? :S

[17:29] <psch> j: A: for 1 { for 1 { last A }; CONTROL { default { .perl.say } } } 

[17:29] <camelia> rakudo-jvm ad08a1: OUTPUT«X::AdHoc.new(payload => "Died")␤»

[17:29] <zengargoyle> m: sub a(:$count){$count} %eg = 1 => ( count => 1 ), 2 => ( count => 2; say a(%eg<1>)

[17:29] <camelia> rakudo-moar ad08a1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/uUtpkvbgq8␤Preceding context expects a term, but found infix = instead␤at /tmp/uUtpkvbgq8:1␤------> 3sub a(:$count){$count} %eg =7⏏5 1 => ( count => 1 ), 2 => ( count => 2;␤»

[17:29] <RabidGravy> segfault no good

[17:29] <zengargoyle> m: sub a(:$count){$count} my %eg = 1 => ( count => 1 ), 2 => ( count => 2; say a(%eg<1>)

[17:29] <camelia> rakudo-moar ad08a1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jkWJ_yH0ZL␤Strange text after block (missing semicolon or comma?)␤at /tmp/jkWJ_yH0ZL:1␤------> 3sub a(:$count){$count}7⏏5 my %eg = 1 => ( count => 1 ), 2 => ( co␤    expecting any of:␤        in…»

[17:30] <zengargoyle> m: sub a(:$count){$count} my %eg = 1 => ( count => 1 ), 2 => ( count => 2 ); say a(%eg<1>);

[17:30] <camelia> rakudo-moar ad08a1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xknOHfw4GE␤Strange text after block (missing semicolon or comma?)␤at /tmp/xknOHfw4GE:1␤------> 3sub a(:$count){$count}7⏏5 my %eg = 1 => ( count => 1 ), 2 => ( co␤    expecting any of:␤        in…»

[17:30] <zengargoyle> m: sub a(:$count){$count}; my %eg = 1 => ( count => 1 ), 2 => ( count => 2 ); say a(%eg<1>);

[17:30] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub a at /tmp/iCar9EaOtk:1␤  in block <unit> at /tmp/iCar9EaOtk:1␤␤»

[17:31] <zengargoyle> m: sub a(:$count){$count}; my %eg = 1 => ( count => 1 ), 2 => ( count => 2 ); say a(|%eg<1>);

[17:31] <camelia> rakudo-moar ad08a1: OUTPUT«1␤»

[17:31] *** llfourn left
[17:32] <zengargoyle> m: sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(|%eg<1>);

[17:32] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub a at /tmp/P0lP6pbZ_8:1␤  in block <unit> at /tmp/P0lP6pbZ_8:1␤␤»

[17:33] <zengargoyle> m: sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(||%eg<1>);

[17:33] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub a at /tmp/C1qzw38FGo:1␤  in block <unit> at /tmp/C1qzw38FGo:1␤␤»

[17:33] <zengargoyle> m: sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(|(%eg<1>.flat));

[17:33] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub a at /tmp/1L1k72M6yt:1␤  in block <unit> at /tmp/1L1k72M6yt:1␤␤»

[17:33] <zengargoyle> m: sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(|%eg<1>);

[17:33] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub a at /tmp/ptBwoyFzwp:1␤  in block <unit> at /tmp/ptBwoyFzwp:1␤␤»

[17:33] <moritz> : sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(|%eg<1>.hash);

[17:33] <moritz> m: sub a(:$count,:$len){$count*$len}; my %eg = 1 => ( count => 1, len => 2 ), 2 => ( count => 2, len => 2 ); say a(|%eg<1>.hash);

[17:33] <camelia> rakudo-moar ad08a1: OUTPUT«2␤»

[17:34] <zengargoyle> ah

[17:34] <moritz> zengargoyle: | on a list produces positional elements, | on a hash or pair produces named

[17:34] <zengargoyle> thanks

[17:38] *** ^elyse^ joined
[17:39] *** ^elyse^ left
[17:39] *** sufrostico joined
[17:41] *** Actualeyes left
[17:41] *** MadcapJake joined
[17:43] <n0tjack> m: my Int $i where * > 0; $i = 3; $i = 1; $i = -99;

[17:43] <camelia> rakudo-moar ad08a1: OUTPUT«Type check failed in assignment to $i; expected <anon> but got Int␤  in block <unit> at /tmp/UPKiZyfGz9:1␤␤»

[17:44] *** CIAvash joined
[17:44] <dalek> doc: e135e36 | (Steve Mynott)++ | doc/Language/5to6 (2 files):

[17:44] <dalek> doc: rename Perl 5 to Perl 6 Translation to 5to6-nutshell GH #158

[17:44] <dalek> doc: review: https://github.com/perl6/doc/commit/e135e36927

[17:44] <dalek> doc: cd52552 | (Steve Mynott)++ | doc/ (8 files):

[17:44] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[17:44] <dalek> doc: review: https://github.com/perl6/doc/commit/cd52552aa4

[17:44] <FROGGS> n0tjack: LTA for sure

[17:45] <MadcapJake> trying to submit an exercise for exercism's perl6 exercises and I can't figure out how to use modules.  The first exercise `Bob` , I'm getting `could not find Bob in any of:`

[17:45] <MadcapJake> and I have this at the top of `bob.pm6`: `unit module Bob;`

[17:45] <n0tjack> FROGGS: I think it's amazing that you can have anonymous conditional types at all!

[17:46] <n0tjack> FROGGS: before, I thought the where-clause was just a feature of function signatures.

[17:46] <FROGGS> MadcapJake: you'd have to perl6 -I. -e 'use bob'

[17:46] <MadcapJake> what do those flags mean?

[17:47] *** Oatmeal joined
[17:47] <n0tjack> MadcapJake: -I. means "include the current directory (.) in the `classpath`".

[17:47] <n0tjack> MadcapJake: The -e means "execute this string as if it were a script" aka (e)val.

[17:48] <n0tjack> IOW, just make sure when you invoke perl, the Bob module is on your module search path.

[17:48] <psch> (and preferably decide whether you want to call the module bob or Bob, and use the same in the filename *and* module declaration)

[17:49] <MadcapJake> the test file has this: `my $module = %*ENV{'EXERCISM'} ?? 'Example' !! 'Bob'; \n EVAL("use $module");

[17:49] <MadcapJake> is that what you're talking about?

[17:50] <psch> MadcapJake: if it runs "use Bob" and you have bob.pm, it won't fit it even if bob.pm is in the libpath

[17:50] <psch> s/fit/find/

[17:50] <n0tjack> MadcapJake: that question comes after the first: are either Example or Bob or both on your search path?

[17:50] <MadcapJake> yeah that's what i'm seeing, why is that?

[17:51] <MadcapJake> well if I use `-I.` it still doesn't find it

[17:51] <psch> MadcapJake: because "use Bob;" looks for Bob.pm, not bob.pm

[17:51] <pink_mist> because Bob is not bob?

[17:51] <MadcapJake> ohhh, the filename

[17:51] <n0tjack> Bob prefers Robert.

[17:51] <MadcapJake> lol

[17:55] <dalek> roast: af3bcda | TimToady++ | S05-substitution/subst.t:

[17:55] <dalek> roast: add rt annotation

[17:55] <dalek> roast: review: https://github.com/perl6/roast/commit/af3bcdabc8

[17:56] *** sufrostico left
[17:57] *** mbrock left
[17:57] *** azawawi joined
[17:57] <azawawi> hi

[17:57] <azawawi> retupmoca: ping

[17:58] *** pmurias_ left
[18:00] *** dakkar left
[18:00] <retupmoca> azawawi: pong

[18:00] *** ambs joined
[18:01] <azawawi> retupmoca: re latest patch, it made performance worse unfortunately...

[18:01] *** AndyDee left
[18:02] <azawawi> retupmoca: see https://github.com/azawawi/perl6-file-zip/blob/master/examples/test.p6

[18:02] <retupmoca> huh

[18:02] <retupmoca> I didn't expect that

[18:03] <azawawi> retupmoca: this is my home machine (amd fx-8150) which is slower than my work machine in single core performance (i7 2600)

[18:03] <azawawi> retupmoca: this machine is better in I/O though it has an SSD

[18:04] *** kjs_ joined
[18:06] <azawawi> retupmoca: with latest patch, real	0m46.618s

[18:07] <azawawi> retupmoca: when reverted to 40b310a, i get real	0m16.582s

[18:07] <retupmoca> oh, that's a lot worse

[18:08] *** mayuresh joined
[18:08] <azawawi> let me calculate avg file size

[18:09] <mayuresh> hello :)

[18:10] <azawawi> retupmoca: ~20k avg file size

[18:11] *** xpen joined
[18:12] *** dha joined
[18:13] *** mayuresh left
[18:14] <azawawi> retupmoca: buffer is 1K, increased it to 8K, got it down to 11 secs :)

[18:14] <azawawi> retupmoca: more than 8K is minimal performance gain

[18:15] *** leont joined
[18:16] *** xpen left
[18:16] <psch> well, the bit that segfaults on moar above is another 5 test file FAILs on j-spectest that i'd say need more than just a jvm-specific fix

[18:17] <azawawi> retupmoca: my guess is that .list has a hidden cost attached to it

[18:18] <psch> the "expected Positional but got Seq" might be related to the workaround for anon subs disappearing in sink context...

[18:18] <azawawi> retupmoca: to my surprise, ~ is rather fast :)

[18:18] <psch> which is something i looked at for quite a bit already but didn't make any headway with :/

[18:18] <psch> r: sub f { sub { "foo" } }; f()()

[18:18] <MadcapJake> line 16 of `bob.t` reads: `ok Bob.can('hey'), 'Class Bob has hey() method';` gives me this error: `Too many positionals passed; expected 2 arguments but got 3 in block <unit> at bob.t:16`  Why would there be possible arguments in this situation?

[18:18] <camelia> rakudo-jvm ad08a1: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/tmpfile:1␤␤»

[18:18] <camelia> ..rakudo-moar ad08a1: ( no output )

[18:18] <jnthn> azawawi: If you're on latest Rakudo, that's maybe 'cus timotimo++ patched it to be 2x faster earlier today :)

[18:19] <retupmoca> azawawi: it looks like both .subbuf and .list do a slow-copy (not using splice), plus we do another when we call the buf8.new

[18:19] <retupmoca> azawawi: I just pushed another version - can you let me know if it's any faster this time?

[18:19] <MadcapJake> my `hey` method is just ` method hey ($input) { ... }`

[18:19] <psch> m: use Test; class Bob { method hey { } }; ok Bob.can('hey'), "Bob can hey"

[18:19] <camelia> rakudo-moar ad08a1: OUTPUT«ok 1 - Bob can hey␤»

[18:19] <retupmoca> (the only potentially slow bit is the list slice now)

[18:20] <psch> m: use Test; class Bob { method hey($) { } }; ok Bob.can('hey'), "Bob can hey"

[18:20] <camelia> rakudo-moar ad08a1: OUTPUT«ok 1 - Bob can hey␤»

[18:20] <MadcapJake> so why's mine failing :P

[18:20] <psch> MadcapJake: no idea, i'd need more context :)

[18:21] <azawawi> retupmoca: still running lol

[18:22] <MadcapJake> https://gist.github.com/MadcapJake/a4584ed1048783680d17

[18:23] <MadcapJake> there's both files and I'm running `perl6 -I. bob.t` in the cmdline

[18:23] <azawawi> retupmoca: this version is way too slow

[18:24] <psch> m: use Test; module Bob { class Bob { method hey { } } }; ok Bob.can('hey'), "Bob can hey"

[18:24] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/4NSWec4bCM:1␤␤»

[18:24] <psch> MadcapJake: you're declaring a class Bob inside a module Bob

[18:24] <psch> MadcapJake: so, Bob::Bob

[18:24] <psch> m: module Bob { class Bob { method hey { } } }; say Bob.can('hey');

[18:24] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/2DRgjI2wwR:1␤␤»

[18:24] <retupmoca> azawawi: right. I'm going to revert back to the original, and tonight I'll set up a proper test and figure out how to stick 2 bufs together quickly

[18:24] <MadcapJake> ohh, well the test file makes it seem like i needed to do it as a class method instead of a su

[18:24] <MadcapJake> sub*

[18:25] <psch> MadcapJake: it does, but you can declare a class as a package in perl 6

[18:25] <FROGGS> m: module Bob { class Bob { method hey { } } }; say Bob.^can('hey');

[18:25] <camelia> rakudo-moar ad08a1: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/tWOW2_cyM2:1␤␤»

[18:25] <azawawi> retupmoca: am i using the API in a correct way https://github.com/azawawi/perl6-file-zip/blob/master/lib/File/Zip.pm6#L93 ?

[18:25] <psch> MadcapJake: as in, that's actually what happens when a file contains a "class" statement in the outermost scope

[18:25] *** ambs left
[18:25] <MadcapJake> so the outermost scope becomes a class?

[18:26] <azawawi> retupmoca: im feeding it the compressed stream as a whole

[18:26] <retupmoca> azawawi: yeah, that should be fine

[18:26] <azawawi> retupmoca: real	3m30.320s ....

[18:27] *** ambs joined
[18:27] <azawawi> retupmoca: so basically your test script is https://github.com/azawawi/perl6-file-zip/blob/master/examples/test.p6

[18:27] <azawawi> retupmoca: the webdriver.xpi file size is like 600K

[18:27] <MadcapJake> i'm not sure i understand what I need to do, I tried removing the class dec and changing the `hey` method to a sub with `is export`, but still getting the same exact error

[18:28] <psch> MadcapJake: that's because Bob is still a package, not a class

[18:28] <MadcapJake> so how do i make it a class?

[18:28] <psch> (or module)

[18:28] <psch> MadcapJake: just remove the "unit module Bob;" at the top

[18:28] <psch> and possibly the "is export"

[18:28] <MadcapJake> oh :P confusing

[18:28] <psch> not sure about the latter, but i'm pretty sure you don't need it

[18:28] <psch> MadcapJake: yeah, a bit

[18:28] <psch> MadcapJake: in my mind, modules and classes are both packages

[18:29] <azawawi> jnthn: 2015.10-51-gad08a1d is the perl6 im using

[18:29] <psch> MadcapJake: a package is one of those things that you talk about with ::, e.g. Friends::Alice

[18:29] <psch> MadcapJake: and any level in such a package can be a module or a class

[18:29] <psch> m: class A { class B { } }; A::B.new.perl.say

[18:29] <camelia> rakudo-moar ad08a1: OUTPUT«B.new␤»

[18:29] <MadcapJake> but they're different in Perl6 right?

[18:30] <timotimo> azawawi: did you get a speed improvement in the version with ~ by upgrading your rakudo?

[18:30] <psch> m: module A { class B { } }; A::B.new.perl.say

[18:30] <camelia> rakudo-moar ad08a1: OUTPUT«B.new␤»

[18:30] *** kjs_ left
[18:30] <psch> MadcapJake: under the hood, yes, but not really from the outside

[18:30] <azawawi> brb let me access my $work machine... and test :)

[18:30] <psch> MadcapJake: which is why i think the error you got is definitely LTA

[18:30] <TimToady> packages are really very much like packages in P5, except we don't put anything into them by default

[18:30] <psch> MadcapJake: also of note is that my definition of package and module isn't quite synopses-conform

[18:31] <psch> the synopses talk about module and package as synonyms, which i don't

[18:31] <psch> (at least during my last reading, not sure if that changed)

[18:31] <psch> so maybe i shouldn't have explained it like that because it might be confusing down the line :S

[18:31] <MadcapJake> TimToady: I've never used P5 so that's probably why this is a bit confusing for me

[18:32] *** sufrostico joined
[18:32] <psch> FROGGS: does the NPE for sub f { sub { } } seem approachable to you?  'cause i don't seem to get it figured out

[18:33] <TimToady> packages are simply a hierarchical system of named global namespaces

[18:33] <FROGGS> psch: the what?

[18:33] <psch> j: sub f { sub { "foo" } }; f()()

[18:33] *** ambs left
[18:33] <camelia> rakudo-jvm ad08a1: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/ggXpHEOfsY:1␤␤»

[18:33] <FROGGS> ahh, that one

[18:33] <psch> FROGGS: ISTR that you and jnthn pointed me at compile_all_the_stmts

[18:34] <psch> FROGGS: and i tried adapting the moar logic, which got hella confusing because of differences in stack handling and such

[18:34] *** azawawi_ joined
[18:34] <FROGGS> psch: yes, jnthn said something about a sinking feeling...

[18:34] *** azawawi left
[18:34] <psch> FROGGS: fwiw, there is differences between the backends, but i'm unsure in how far those differences are architectural

[18:35] <MadcapJake> so you would use `unit module <module_name>` when you wanted a higher level modjule containing sub-packages?

[18:35] <psch> MadcapJake: "module" and "package" both give you a class-less namespace

[18:36] <psch> MadcapJake: they can also straight up export subs (or even methods)

[18:36] <TimToady> having subpackages comes automatically with any kind of package

[18:36] *** xfix joined
[18:36] <MadcapJake> the module page in the docs never really explains when to us e`unit module` or what it is really

[18:36] <TimToady> modules have extra stuff for exporting

[18:36] <TimToady> classes have extra stuff for, er, classing...

[18:37] <MadcapJake> oh so they're similar albeit one is export-focused while the other is inheritance-focused, you could say?

[18:37] <TimToady> to the first approximation, modules are for providing a set of functions, while classes are for providing a set of methods

[18:37] <TimToady> and packages don't care about supplying anything except global name lookups

[18:38] <TimToady> but a class can also export, and any of them can supply global names

[18:39] <TimToady> so it's just various degrees of specialization; a grammar is a more specialized class

[18:39] <MadcapJake> so classes can provide all the exportational goodness of a module but you need to explicility specifiy it?

[18:39] <n0tjack> Is package ⊃ module ⊃ class ⊃ grammar on the right rack?

[18:39] <TimToady> it should work the same as a module, just add 'is export'

[18:40] *** espadrine left
[18:40] <TimToady> n0tjack: and roles fit in there somewhere too, but of course it doesn't have to be linear

[18:40] <n0tjack> TimToady: except when using a class, you must either instantiate it or call static methods, no?

[18:40] <TimToady> you can export functions too

[18:41] <FROGGS> nqp-j: sub f { sub { "foo" } }; f()()

[18:41] <camelia> nqp-jvm: OUTPUT«(signal ABRT)#␤# There is insufficient memory for the Java Runtime Environment to continue.␤# pthread_getattr_np␤# An error report file with more information is saved as:␤# /tmp/jvm-5288/hs_error.log␤»

[18:41] <TimToady> you can probably change any module definition to declare it with 'class' and it'd still work as a module

[18:41] <n0tjack> TimToady: so from an importer's perspective the difference between   class Foo is export {}   and  unit module Foo  is in the former you have to either use Foo.bar or my $f = Foo.new(); $f.bar  whereas in the latter you can just say  bar()  with no rigamarole?

[18:42] *** ambs joined
[18:42] <TimToady> Foo.bar is never going to call a function

[18:42] *** sufrostico left
[18:42] <n0tjack> sorry, Foo.bar() and $f.bar()

[18:43] <TimToady> Foo.bar() is never going to call a function

[18:43] <n0tjack> no?

[18:43] <TimToady> we keep them entirely distinct, when it comes to dispatchers

[18:43] <TimToady> and bar() will never call a method

[18:44] <TimToady> bar() only calls things in the current lexical scope (including things that were imported)

[18:44] <FROGGS> psch: funnily, that works: nqp-j -e 'sub f() { sub i() { "foo" } }; say(f()())'

[18:44] <TimToady> Foo.bar only calls things that are registered as methods in the metaclass object

[18:44] <n0tjack> TimToady: I'm trying to picture how a class could export a function (not method) which could be invoked by an importer without mentioning Foo in some way

[18:45] <TimToady> just declare it as a sub instead of as a method, and export it, just as you would in a module

[18:45] <n0tjack> I see.

[18:45] *** raiph joined
[18:45] <n0tjack> Feels weird that classes are allowed to export unclassy things.

[18:45] *** rurban left
[18:47] *** rurban joined
[18:48] <TimToady> m: class Foo { sub bar () is export { say "HERE" } }; import Foo; bar()

[18:48] <camelia> rakudo-moar ad08a1: OUTPUT«HERE␤»

[18:48] <n0tjack> wow, that's going to kill me when I forget actual class methods are spelled "method" and not "sub"

[18:49] <FROGGS> heh

[18:50] <TimToady> n0tjack: Perl 6 is mostly not about telling people what they can't do.  As with the color wheel of light, we try to make things additive rather than subtractive.

[18:51] *** tokuhirom joined
[18:51] * n0tjack zens out for a moment

[18:55] *** tokuhirom left
[18:56] <n0tjack> the prospect of having to learn git (YAVCS) is harshing my zen

[18:57] <RabidGravy> YOU'RE HARSHING MY MELLOW MAN!

[18:58] <n0tjack> I feel like mellow is an underappreciated noun

[18:59] <RabidGravy> oh wait, nah it's not too much of a problem, I was a bit of a git-resister a few years back but really it's just another vcs but with a distinction between local and remote

[19:01] <jdv79> encino?

[19:01] <jdv79> blast from the past

[19:03] *** rurban left
[19:03] *** virtualsue joined
[19:03] <flussence> no need to learn another VCS, just forget all the old ones and use git's frontend to them instead :)

[19:03] *** rurban joined
[19:03] <azawawi_> jnthn: confirmed with the timotimo++ performance fix and revert to old ~ buffer in Compress::Zlib, im seeing a drop from ~20 sec to ~12 secs

[19:03] <psch> FROGGS: that's weird :/

[19:03] <psch> FROGGS: oh, no, it isn't

[19:03] <azawawi_> retupmoca: also with increasing the buffer size from 1K to 8K, 12 seconds becomes 8 seconds :)

[19:04] <psch> j: sub f { sub g { "foo" } }; f()()

[19:04] <camelia> rakudo-jvm ad08a1: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/Y84AtXxDFZ:1␤␤»

[19:04] <psch> wait, it is

[19:04] <psch> what

[19:04] <psch> i thought that worked

[19:04] <psch> FROGGS: turns out it *is* weird :P

[19:04] <n0tjack> bbl &

[19:04] <psch> FROGGS: i had thought i had maintained that it's the anon sub that gets swallowed, but apparently is any non-cont sub

[19:05] <psch> j: sub f { my & = sub g { "foo" } }; f()()

[19:05] <camelia> rakudo-jvm ad08a1: ( no output )

[19:05] <psch> s/maintained/figured out/

[19:06] <FROGGS> I'm trying to get behind it...

[19:06] <TimToady> j: sub f { sub g { "foo" } }; f().WHAT.say

[19:06] <camelia> rakudo-jvm ad08a1: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/502V0csSne:1␤␤»

[19:06] <retupmoca> timotimo, azawawi_: https://github.com/retupmoca/P6-Compress-Zlib/commit/1120829c9c1251370ffaded3e002970ae16bbfe1 seems to speed it up 5x (using rakudo before the ~ patch)

[19:06] <TimToady> it's not just .()

[19:06] <retupmoca> azawawi_: yeah, I know, but I wanted to get this part sorted first

[19:06] <FROGGS> psch / TimToady: it is an old standing bug...

[19:07] <FROGGS> psch / TimToady: remember that we had some "#?if jvm\n my $ = ...\n#?endif" in the setting before GLR? it is most likely the same issue

[19:08] <TimToady> nod

[19:08] <MadcapJake> is there a quick way to check if a list is empty or do I just compare length to 0?

[19:08] <TimToady> a list is false if it's empty

[19:08] <TimToady> no comparison necessary

[19:09] <timotimo> azawawi_: aaw, not even 2x faster :(

[19:09] *** n0tjack left
[19:09] <TimToady> m: say ().so; say (0).so

[19:09] <camelia> rakudo-moar ad08a1: OUTPUT«False␤False␤»

[19:09] <FROGGS> MadcapJake: if @empty-list { } <--- it wont make it in the if's body

[19:09] <TimToady> m: say ().so; say (0,).so

[19:09] <camelia> rakudo-moar ad08a1: OUTPUT«False␤True␤»

[19:09] <MadcapJake> m: my $s = "4?"; $s.comb(/<:L>/).defined

[19:09] <camelia> rakudo-moar ad08a1: ( no output )

[19:09] <FROGGS> m: my $s = "4?"; say $s.comb(/<:L>/).defined

[19:09] <camelia> rakudo-moar ad08a1: OUTPUT«True␤»

[19:09] <azawawi_> timotimo: again im testing on different CPU platforms :)

[19:09] <FROGGS> m: my $s = "4?"; say $s.comb(/<:L>/)

[19:09] <camelia> rakudo-moar ad08a1: OUTPUT«()␤»

[19:09] <FROGGS> m: my $s = "4?"; say $s.comb(/<:L>/).so

[19:09] <camelia> rakudo-moar ad08a1: OUTPUT«False␤»

[19:09] <MadcapJake> what is the `so` method?

[19:10] <FROGGS> MadcapJake: a list is defined, but false if it is empty

[19:10] <azawawi_> timotimo: AMD FX-xxxx is known for slow single core performance

[19:10] <timotimo> azawawi_: i meant the 20sec to 12sec thing you said; i thought that's on a single box?

[19:10] <FROGGS> MadcapJake: like asking for a Bool

[19:10] <TimToady> MadcapJake: the opposite of .not

[19:10] <timotimo> azawawi_: even if that processor is slow, the factor should be the same, no?

[19:10] <MadcapJake> oh ok cool, thanks!

[19:10] <FROGGS> MadcapJake: like in English, so?

[19:10] <azawawi_> timotimo: SSD on the slower machine. go figure :)

[19:11] *** sufrostico joined
[19:11] <MadcapJake> never heard it like that, maybe it's my generation but `so` is usually just for when you didn't bring your homework to class and you just didn't care :P

[19:12] * flussence has a SSD in a netbook and spinning rust on desktop. Great for noise levels but not much else...

[19:13] *** rangerprice left
[19:13] *** espadrine joined
[19:14] <psch> FROGGS: those #if jvm bits are still around

[19:15] *** sufrosti1o joined
[19:15] <psch> FROGGS: core/metaops.pm

[19:15] *** _dolmen_ joined
[19:15] <PerlJam> MadcapJake: "make it so"  :)

[19:15] <psch> FROGGS: it's exactly this kind of issue, METAOP_REDUCE_* returns a sub

[19:15] <MadcapJake> or the valley girls saying "soooo true!" xD

[19:16] <PerlJam> MadcapJake: "That care is *so* blue"

[19:16] <PerlJam> s/care/car/

[19:16] *** rarara__ joined
[19:16] * psch plays A7 F7 G7 C7

[19:16] <MadcapJake> so really is a bizarre word if you think about it too much :S

[19:16] <psch> well, Amin7 probably

[19:16] <psch> or a7, depending on your notational preferences

[19:16] <azawawi_> timotimo: to be clear that benchmark was done on the same machine that i use @ work so yes 20 -> 12 after building a new rakudo

[19:16] <rarara__> Is there in Perl 6 an easy way to transpose a list of list ?

[19:16] <retupmoca> azawawi_: I just bumped the buffer up to 8k in my repo as well

[19:17] <retupmoca> azawawi_: hopefully it's now "fast-ish"

[19:17] <MadcapJake> if you're on exercism: give me some tips! http://exercism.io/submissions/4bbfaf53485e488aaed0a4b49e6b41a9

[19:17] <retupmoca> (my simplestic test went from ~38 seconds to ~2 seconds with both changes)

[19:18] <azawawi_> timotimo: and that's perfectly normal, i still didnt optimize I/O operations when writing files and recreating folders

[19:18] <dha> I'm in favor of not making the case of the note significant, so I'd go with Amin7

[19:18] *** boggard left
[19:18] <azawawi_> retupmoca: cool.. thanks :)

[19:19] <rarara__> something like ((A B C) (D E F) (G H I)) -> ((A D G) (B E H) (C F I)) ??

[19:19] <MadcapJake> looking at other implementations, I should've used `~~` xD

[19:19] <azawawi_> retupmoca: now down to 10 seconds on AMD machine :)

[19:19] <PerlJam> rarara__: See http://rosettacode.org/wiki/Matrix_transposition#Perl_6 for some ideas :)

[19:20] <azawawi_> retupmoca++, timotimo++, jnthn++

[19:21] * azawawi_ sleepy &

[19:21] <azawawi_> good night everyone

[19:21] <PerlJam> azawawi_: g'night! 

[19:22] *** AlexDaniel joined
[19:22] <RabidGravy> the problem with Perl 6 is that it *MAKES* me write things like "for $!handle.lines.map({Group.new(line => $_) }).sort({$^a.gid})", it's like demonic posession

[19:23] <lucasb_> m: say [Z] (<A B C>,<D E F>,<G H I>)

[19:23] <camelia> rakudo-moar ad08a1: OUTPUT«((A D G) (B E H) (C F I))␤»

[19:23] <PerlJam> at least it's concise possession

[19:23] <lucasb_> rarara__: ^^ rosettacode didn't had this example

[19:23] <rarara__> Yep

[19:23] <PerlJam> lucasb_: add it! :)

[19:23] <rarara__> I was just figuring out :D

[19:23] <rarara__> m: my $g=(("A","B","C"), ("D", "E", "F"), ("G", "H", "I")); say [Z] $g;

[19:23] <camelia> rakudo-moar ad08a1: OUTPUT«((A D G) (B E H) (C F I))␤»

[19:24] <rarara__> much better than rosettacode

[19:25] <dha> RabidGravy - you say that like it's a *bad* thing.

[19:25] <TimToady> we should probably require @$g there

[19:25] *** azawawi_ left
[19:25] <RabidGravy> dha, >:)

[19:27] <RabidGravy> and if I make "$!handle handles <lines>" then I can lose a few chars so it fits nicely in 80 chars with some space

[19:28] *** bjz joined
[19:28] <psch> that's actually interesting

[19:28] <psch> i mean, the chainy stuff

[19:28] <psch> as in, java gets flak for imposing similar programming style

[19:28] <psch> i guess it comes down to huffmanization

[19:29] <RabidGravy> I don't think I feel imposed upon to do that, it just seems natural to my poor brane

[19:31] <psch> oh, right.  i guess "i *can* write it like that" instead of "i either write it like that or add a bunch of variables for each call" is the better argument as for why it seems fine

[19:31] *** ollej joined
[19:31] *** ollej left
[19:31] *** ollej joined
[19:32] <RabidGravy> I'd never have done "for  (sort { $a.gid <=> $b.gid } map { Group->new(line => $_ } <HANDLE>)" in P5

[19:33] *** bjz left
[19:33] *** kjs_ joined
[19:33] <RabidGravy> or whatever

[19:33] <psch> those seperately parsed block forms in perl5 looks so wrong to me by now

[19:33] <timotimo> i would have really hoped for a much better improvement in run times for azawawi's unzip task :(

[19:34] <psch> but yes, i agree that in p5 that's probably considered somewhat bad

[19:35] <RabidGravy> I know people who would commonly write stuff like that

[19:35] <RabidGravy> I'd probably abstract it with further layers of methods myself

[19:36] * geekosaur would write that but put each chunk on its own line

[19:36] <retupmoca> timotimo: yeah, me too

[19:36] <geekosaur> sort BLOCK \n map BLOCK [\n if EXPR is long enough] EXPR

[19:36] <retupmoca> but at least we killed one bottleneck in Compress::Zlib

[19:36] <retupmoca> or improved at least

[19:39] <lucasb_> gfldex++  # added it to rosettacode :)

[19:40] *** kjs_ left
[19:42] *** Hor|zon joined
[19:47] *** Hor|zon left
[19:48] <timotimo> maybe someone wants to have a closer look at Buf.list to make it better?

[19:48] <retupmoca> well, I'm not even using Buf.list anymore

[19:48] <retupmoca> I'm just directly calling nqp::splice

[19:51] *** _dolmen_ left
[19:52] *** Hor|zon joined
[19:54] *** bjz joined
[19:55] *** vendethiel joined
[20:00] *** bjz_ joined
[20:00] *** bjz left
[20:06] *** CIAvash left
[20:07] <timotimo> right, but if it's so costly, perhaps it'll benefit someone in the future

[20:08] *** raiph left
[20:09] *** raiph joined
[20:12] *** bjz_ left
[20:12] *** xpen joined
[20:13] *** bjz joined
[20:14] *** colomon left
[20:18] *** xpen left
[20:20] *** kjs_ joined
[20:22] *** darutoko left
[20:23] *** kjs_ left
[20:24] <gfldex> m: sub foo(@a is copy, :$flag){ say @a }; my @a = 1,2; (&foo.assuming(:flag))(@a);

[20:24] <camelia> rakudo-moar ad08a1: OUTPUT«replace this Array is copy logic␤  in sub __PRIMED_ANON at EVAL_2:2␤  in sub __PRIMED_ANON at EVAL_2:1␤  in block <unit> at /tmp/GhmXZoyt9p:1␤␤»

[20:24] <nine> timotimo: Buf.list definitely looks like it can be improved

[20:24] <gfldex> is that LTA, gfldex-bug or rakudobug?

[20:26] <nine> timotimo: also it returns an Array instead of a List which is something I really don't like.

[20:27] *** pdcawley left
[20:29] *** Oatmeal left
[20:31] *** Oatmeal joined
[20:34] *** colomon joined
[20:34] *** s_kilk joined
[20:34] *** rurban left
[20:34] <FROGGS> gfldex: that's a GLR leftover... a todo for us

[20:35] <FROGGS> psch: compiling on jvm is sooo damn sloooow :/

[20:37] *** rurban joined
[20:38] <psch> FROGGS: yes, i know :l

[20:39] <psch> FROGGS: i guess donaldh++'s suggestion of serializing annotations might help

[20:39] <psch> FROGGS: but well, no idea how that'd look

[20:39] <FROGGS> hmmm, me neither

[20:39] <FROGGS> I seem to lack imagination when it comes to jvm related stuff

[20:40] <leont> FROGGS: I'm doing exactly the same right now :-/

[20:40] <yoleaux> 27 Oct 2015 19:24Z <FROGGS> leont: is there anything wrong with my patch here? https://github.com/rakudo/rakudo/commit/6063886343

[20:41] <FROGGS> I currently try to port the logic of compile_all_the_stmts from moar to jvm... without much luck so far, but we'll see

[20:41] <FROGGS> hmpf, SOE again

[20:41] <leont> No idea, can't really open firefox with perl6-j compiling, that'd be too much for my laptop surely

[20:43] *** lizmat joined
[20:43] <lizmat> good *, #perl6!

[20:43] <psch> FROGGS: i mostly got ArrayIndexOutOfBoundsExceptions when i tried, which leaks from deep in objectweb.asm

[20:43] *** [Sno] left
[20:44] <psch> FROGGS: i'm slightly annoyed they'd leak that and not wrap it somewhat meaningful...

[20:45] <FROGGS> leont: yes, thunderbird and firefox shut down here too :o)

[20:45] <FROGGS> leont: that patch just removes an exit(0) in Test.pm in an END block, which I think was a thinko in the first place

[20:46] <leont> Test::Builder sets the exit value to min($failed, 254)

[20:46] <leont> I'm not sure you can do that in Perl 6 without actually exiting

[20:47] *** geraud joined
[20:48] <FROGGS> leont: we do an exit(min($failed, 254)) conditionally, yes

[20:48] <FROGGS> the exit(0) was in an all-is-fine else branch

[20:49] <rarara__> Is there a way for plugging in C function which return a List in an efficient way?

[20:49] <leont> in p5, you can set $? in and END block, and it will be used when perl is exited, even when other code runts after it (unless that also sets $? obviously)

[20:49] <FROGGS> rarara_: efficient? in most cases we need to copy that returned list to create something more high level...

[20:49] *** adu joined
[20:50] <FROGGS> leont: we don't have that feature...

[20:50] <rarara__> C doesn't have lists. What I mean is to create it in C, ike you do it in XS

[20:50] <leont> exit(0) if all is fine sounds not very useful at first sight

[20:50] <rarara__> so that you can do the cycles in C

[20:50] <FROGGS> leont: okay, that's good enough for me :o)

[20:51] <FROGGS> rarara_: you can do stuff in C using Inline::C or NativeCall, and return stuff from C

[20:51] * leont wants to give Test.pm some love when the harness is done. It's rather primitive for my tastes.

[20:51] <FROGGS> hmmm, primitive is sometime worth a lot

[20:51] <leont> In particular, it's very hard to test itself, because it's outputting text instead of having abstractions in the back

[20:52] <FROGGS> not necessarily here though

[20:52] *** adu left
[20:52] <FROGGS> ahh, yes

[20:52] <rarara__> FROGGS: with which data structure would you return a list of char* from C, for example? That would be converted in a list of string

[20:52] <leont> Also, it's not very composible. The Test::Builder ecosystem proved how useful that can be, even if it the architecture proves to be limiting nowadays

[20:52] <FROGGS> rarara_: you can return a CArray[uint8]

[20:53] <FROGGS> leont: I'm lacking experience there

[20:53] *** tokuhirom joined
[20:54] <leont> The idea is that you can build lots of tests modules that can be used together

[20:54] <leont> For example Test::Deep, Test::Exception and Test::Class

[20:55] <rarara__> FROGGS is CArray a C type?

[20:55] <leont> Or Test::Differences, which is one of my favorites (will actually diff in case of a mismatch)

[20:55] *** samb1 joined
[20:55] <FROGGS> rarara_: it maps directory to the memory which is potentially managed by C, so yes

[20:56] <leont> Also, we kind of want extended diagnostics, but there are pretty much still in development in TAP-land :-/

[20:56] <FROGGS> leont: yes, I've used Test::Difference in the past

[20:57] *** tokuhirom left
[20:58] <leont> Also, being able to output something other than TAP may be useful in some environments.

[20:58] *** dha left
[20:58] <leont> I'm wondering what a testing slang would look like. Haven't thought out that idea yet though.

[20:58] <FROGGS> yes, also true

[20:59] <flussence> I've tried writing a module that does TAPv13, but it got kinda held up by the fact those diagnostics are YAML and the YAML module is seriously broken

[21:00] * leont is working on a YAML module for exactly this reason

[21:00] <flussence> and I saw recently TAPv14 may have been started on, so I dunno if my code's much use

[21:01] <leont> The TAP process is awfully slow :-/

[21:01] *** rurban left
[21:02] <RabidGravy> I wrote a YAML parser in c# once, utter cack but it worked

[21:03] <rarara__> so char * is CArray[int8]

[21:03] <rarara__> what about char ** ?

[21:03] <rarara__> CArray[CArray[int8]]

[21:04] <leont> I wrote on for p6, and it's reasonably close to being conformant, though edge-cases in YAML are always plenty

[21:04] <rarara__> then you would still have to loop over the whole external CArray, no?

[21:04] <FROGGS> you can also have e.g. Pointer[CArray[uint8]]

[21:05] <lizmat> rarara__: re http://irclog.perlgeek.de/perl6/2015-10-28#i_11443994 , .elems calls Iterator.count-only

[21:05] <lizmat> which may be optimized, but if not, will indeed generate the entire Seq first

[21:05] <FROGGS> rarara_: you have to access the array if you want to access the array... or maybe I misunderstand your question?

[21:06] <rarara__> would be nice to have access to an equivalent to nqp::p6box_s from C-code, no?

[21:06] <rarara__> lizmat thanks

[21:06] <lizmat> rarara_: re number of values seen, a simple counter within the callable would do that for you

[21:06] <rarara__> lizmat yea!

[21:07] <lizmat> I don't think it's wise to let all grep's suffer in performance for that feature

[21:07] <lizmat> my int $seen; foo.grep: { $seen++; actual check }

[21:08] <FROGGS> rarara_: you can also return a Str from C, then it will be turned into a proper Perl 6 string

[21:08] <jdv79> why can't a type object be does'ed?

[21:08] <FROGGS> rarara_: though it must be encodable properly of course

[21:09] <FROGGS> jdv79: you can

[21:09] <jdv79> i was looking for a poorman's way of marking a type object

[21:09] <FROGGS> jdv79: that's how you do roles

[21:09] <FROGGS> ohh, be does'ed

[21:09] <rarara__> lizmat: I am figthing problems with Str.split

[21:09] <FROGGS> like, class Foo { }; Foo does Bar; ?

[21:09] <flussence> m: say ?(Int but False)

[21:09] <camelia> rakudo-moar ad08a1: OUTPUT«False␤»

[21:10] <flussence> m: say ?(Int but True)

[21:10] <camelia> rakudo-moar ad08a1: OUTPUT«True␤»

[21:10] <lizmat> rarara__: what iw the problem ?

[21:10] <flussence> m: say ?+(Int but True)

[21:10] <camelia> rakudo-moar ad08a1: OUTPUT«Use of uninitialized value of type Int+{<anon|69543024>} in numeric context  in block <unit> at /tmp/ye2VPULbUv:1␤False␤»

[21:11] <jdv79> m: my $a = Any; role Foo {}; $a does Foo

[21:11] <camelia> rakudo-moar ad08a1: OUTPUT«Cannot use 'does' operator with a type object.␤  in block <unit> at /tmp/4Zf64jDaOA:1␤␤»

[21:12] <jdv79> is there way to "mark" a type obj without altering it significantly?

[21:12] <rarara__> lizmat: now that I reason of it, there is no problem with the iterator. Indeed you can add a counter in yourself.

[21:12] <FROGGS> m: my $a = Any; role Foo {}; $a = $a but Foo; say $a

[21:12] <camelia> rakudo-moar ad08a1: OUTPUT«(Any+{Foo})␤»

[21:12] <moritz> jdv79: my Mu %marks; %marks{Int} = True

[21:12] <rarara__> lizmat: it is the performance which is bad, and I dubt it is optimizable at all

[21:13] <lizmat> the performance of grep or split ?

[21:13] <rarara__> split

[21:13] <moritz> there, I just marked the Int type object without permanent damage :-)

[21:13] <lizmat> ah, yeah, I was just looking at it

[21:13] <jdv79> moritz: thnaks ^H

[21:13] <jdv79> forgot about but

[21:13] <jdv79> FROGGS: thanks

[21:13] <leont> Finally, the CORE.setting is compiled :-D

[21:13] <lizmat> rarara__: I assume you're splitting on a string, right ?

[21:13] <lizmat> not on a regex?

[21:13] *** colomon left
[21:13] <rarara__> Right, in fact a "\t", but I checked the code and it is seems pretty good

[21:13] <leont> Took "only" 50 minutes -_-

[21:14] <FROGGS> leont: ewww

[21:14] <FROGGS> leont: Celeron with 466MHz?

[21:14] *** CJKinni joined
[21:14] <lucasb_> FROGGS: omg, I had a celeron in the past

[21:14] <lizmat> rarara__: I think I can speed up that case significantly

[21:15] <FROGGS> lucasb_: I had a dual cpu mainboard with said cpu :o)

[21:15] <rarara__> that would be great

[21:15] *** skids left
[21:15] <leont> Awesome. It seems perl6-j doesn't define signal handling -_-

[21:15] <FROGGS> aye

[21:16] <leont> Not sure how to work around this cleanly :-/

[21:16] <leont> jobs

[21:17] <rarara__> FROGGS: the problem I see with the need of p6box_6 C api, is not that of returning a Str from C. It is the one of creating a whole List of strings and avoiding a Perl loop

[21:17] <rarara__> This problem is general

[21:18] <FROGGS> rarara_: you can also return a CArray[Str], and there would not be a Perl loop™

[21:18] *** lucasb_ left
[21:18] <FROGGS> rarara_: because it happens in MoarVM

[21:19] *** raiph left
[21:19] <rarara__> FROGGS thank you, seems great

[21:19] <FROGGS> psch: still no luck :o(

[21:21] *** telex left
[21:21] *** raiph joined
[21:22] <FROGGS> .tell psch That's my patch that does not help anything: https://gist.github.com/FROGGS/6f11befd8ca37b91fb4d

[21:22] <yoleaux> FROGGS: I'll pass your message to psch.

[21:22] *** telex joined
[21:23] <psch> FROGGS: that looks close-ish to what i tried, from a first glance

[21:23] <yoleaux> 21:22Z <FROGGS> psch: That's my patch that does not help anything: https://gist.github.com/FROGGS/6f11befd8ca37b91fb4d

[21:23] <FROGGS> k

[21:23] <psch> FROGGS: to me this strongly hints at "we're not quite looking at the right spot", fwiw

[21:23] <FROGGS> yeah

[21:24] <psch> FROGGS: as in, the differences in compile_all_the_stmts is architectural and *needs* to be there

[21:24] <psch> FROGGS: the scary bit is the remaining questions, which is "why does it happen"... :P

[21:24] <[Coke]> psch: use Bob on bob.pm will work on some filesystems.

[21:24] <FROGGS> [Coke]: unless we enforce otherwise

[21:24] <psch> i don't know if we can..?

[21:25] <FROGGS> [Coke]: but it is usually not a good idea to be sloppy in that regard

[21:25] <psch> but yes, i know that CI filesystems exist

[21:26] <FROGGS> we can potentially check the filename we got back and bail out

[21:28] <leont> Awesome, after all this effort it completely refuses to run my harness in any sensible way :-s

[21:28] <dalek> rakudo/nom: 07f186d | (Stefan Seifert)++ | src/core/Buf.pm:

[21:28] <dalek> rakudo/nom: Speedup Blob.list and Buf.list by 26x

[21:28] <dalek> rakudo/nom: 

[21:28] <dalek> rakudo/nom: Pushing directly into a List's $!reified buffer instead of going through

[21:28] <dalek> rakudo/nom: Array's ASSIGN-POS to avoid the overhead.

[21:28] <dalek> rakudo/nom: .list now also returns a List instead of an Array

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07f186deeb

[21:28] *** rindolf left
[21:29] <lizmat> nine++ :)

[21:29] <FROGGS> leont: perl6-j only passes about 32% of the spectests, mind

[21:29] <FROGGS> 26x??

[21:29] <FROGGS> nine++

[21:30] <leont> It seems it doesn't do run() :-/

[21:30] <nine> Sometimes I kinda miss the GLR time :) The path was so clear then

[21:30] <jdv79> so i got it to work but its pretty gross

[21:30] <leont> Or at least not output redirection on run()

[21:31] <jdv79> $.obj.set-once-attr = $obj.set-once-attr but Attribute::SetOnce::IsSet # to set the attr but have it remain "unset" or something:)

[21:31] <nine> I also tried making Blob.list O(1) which should work because Lists and Blobs are both immutable and a List's $!reified buffer is a VMArray just like Blob is. Unfortunately those native types get in a way because List uses for example nqp::atpos while Blob uses nqp::atpos_i

[21:32] <jdv79> hopefully that can be cleaned up with a better design someday

[21:32] *** colomon joined
[21:34] *** ^elyse^ joined
[21:35] *** xfix left
[21:36] <dalek> roast: a254a27 | usev6++ | S04-declarations/my.t:

[21:36] <dalek> roast: Add test for RT #121807

[21:36] <dalek> roast: review: https://github.com/perl6/roast/commit/a254a271ba

[21:36] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=121807

[21:37] *** rurban joined
[21:39] <Hotkeys> welp

[21:39] <Hotkeys> tried to install Task::Star

[21:39] <Hotkeys> Template::Mustache failed the tests

[21:39] <Hotkeys> Why not install all the other modules after that panda

[21:39] <Hotkeys> Why stop

[21:40] <FROGGS> these are just dependencies of Task::Star

[21:40] *** kmel joined
[21:40] <FROGGS> and panda does not know that you can live without Task::Star itself, but with most if its deps

[21:41] <Hotkeys> Ah

[21:42] *** TEttinger joined
[21:43] <FROGGS> dunno if the --force option would change anything here

[21:45] *** zakharyas joined
[21:46] <Hotkeys> I amrunning it with --notests

[21:46] <Hotkeys> probably not a great idea

[21:46] <Hotkeys> but I'll deal with the consequences

[21:46] *** f33r3x1 joined
[21:48] *** rarara__ left
[21:49] *** kjs_ joined
[21:50] *** rarara__ joined
[21:50] <Hotkeys> it still got angry

[21:50] <Hotkeys> different reason this time

[21:53] *** sufrostico left
[21:53] *** sufrosti1o left
[21:54] *** Ven joined
[21:56] *** Ven left
[21:59] *** Alina-malina left
[21:59] <dalek> ecosystem: 808d856 | RabidGravy++ | META.list:

[21:59] <dalek> ecosystem: Add Unix::Groups

[21:59] <dalek> ecosystem: 

[21:59] <dalek> ecosystem: https://github.com/jonathanstowe/Unix-Groups

[21:59] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/808d8566b2

[21:59] *** s_kilk left
[22:01] *** Ven joined
[22:03] *** sufrostico joined
[22:03] *** Alina-malina joined
[22:04] *** kmel left
[22:05] *** [Sno] joined
[22:06] *** zakharyas left
[22:10] *** virtualsue left
[22:10] <RabidGravy> Well that's so dumb I could have had a five year old make it, but I couldn't wait until I found one

[22:11] <Hotkeys> Anyone have any idea what's going on here http://pastebin.com/UqQWwPX4

[22:11] <Hotkeys> I'm on windows 10 if that helps

[22:11] <Hotkeys> this is with panda & rakudo installed via rakudobrew

[22:11] <jdv79> a 5 yo that knows perl6?

[22:12] <jdv79> seems rarer than a you

[22:13] *** FROGGS left
[22:14] *** ^elyse^ left
[22:15] *** Oatmeal left
[22:16] <raiph> HotKeys: mebbe https://github.com/MoarVM/MoarVM/commit/808b772e66 and cousins?

[22:17] <Hotkeys> mebbe

[22:18] <Hotkeys> so should I just wait a little built and rebuild and try again

[22:19] *** kjs_ left
[22:21] <Hotkeys> stupid hexchat is refusing to let me just click that link

[22:22] <Hotkeys> had to copy and paste it

[22:22] <Hotkeys> so much work 

[22:22] <Hotkeys> (/s)

[22:24] *** kjs_ joined
[22:25] *** Ven left
[22:26] *** Oatmeal joined
[22:27] *** bjz left
[22:28] <RabidGravy> 101 distinct authors in the ecosystem now, looking good

[22:32] <Hotkeys> I need to contribute so I can be #102

[22:33] <RabidGravy> better hurry up as it's definitely accelerating

[22:34] <Hotkeys> I have no idea what to contribute

[22:34] <Hotkeys> I am but a babby

[22:34] <Hotkeys> to perl6

[22:40] <raiph> HotKeys: also see http://irclog.perlgeek.de/moarvm/2015-10-28#i_11446544 -- mebbe pop on #moarvm and ask jnthn if your issue is related to his work?

[22:41] *** _dolmen_ joined
[22:41] <Hotkeys> will do

[22:41] <Hotkeys> thanks

[22:43] *** bacek joined
[22:43] <bacek> aloha

[22:43] <Hotkeys> what up

[22:44] <dalek> perl6-most-wanted: e82d954 | RabidGravy++ | most-wanted/modules.md:

[22:44] <dalek> perl6-most-wanted: Add a couple more WIPs

[22:44] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/e82d954f38

[22:44] <bacek> p6: say 3;

[22:44] <camelia> rakudo-moar 07f186: OUTPUT«3␤»

[22:44] <RabidGravy> Hotkeys, if you're looking for ideas then there's a load of things there ^ (the ones with WIP are being worked on)

[22:46] <psch> m: say ++$ + [*] $++ + ($++ + ($++ ** $++) xx (++$ + ++$))

[22:46] <camelia> rakudo-moar 07f186: OUTPUT«3␤»

[22:46] <psch> whoo line noise \o/

[22:47] <RabidGravy> the horror

[22:47] *** kaare_ left
[22:48] <RabidGravy> y'see the obfu in Perl 6 is even more bonkers than Perl 6 as there are more operators ;-)

[22:48] <psch> yes, Perl 6 obfu is worse than Perl 6 obfu

[22:48] <RabidGravy> than Perl 5

[22:48] <psch> :D

[22:51] <psch> RabidGravy: actually, i think this one works almost the same in perl5, you'd just have to use $| instead of $

[22:52] <psch> at least if i remember $| correctly

[22:52] <psch> oh, and use x instead of xx

[22:52] <leont> $| has a meaning, but you can abuse most magical variables for such a purpose

[22:52] <psch> err, and [*] is obviously not there

[22:52] <psch> so i guess that's the one "more operator[...]"

[22:57] <RabidGravy> so when the least strong beer in the house is "Gothic Imperial Stout" you just know it's going to go pear-shaped

[22:58] * psch is cheap

[22:58] <psch> https://d9gkwhfwam31p.cloudfront.net/0017012/2143310_lightbox.png is my current beverage

[22:58] <psch> but hey, it's obvious what the ABV is at least

[22:59] <psch> leont: other magicals also share the "can't increment beyond 1" of $|?

[23:00] <psch> leont: i expect at least $[ to not work there

[23:02] *** skids joined
[23:02] <Hotkeys> I've been thinking about brewing a mead

[23:03] <Hotkeys> although I've never had mead

[23:03] <Hotkeys> how bad of an idea is that

[23:03] <Hotkeys> mead just seems really easy to make 

[23:03] <Hotkeys> takes a long time

[23:03] <Hotkeys> but not much work

[23:04] <RabidGravy> I've got some weird Polish mead somewhere in the house, it scares me

[23:04] <Hotkeys> it's basically honey, water, yeast, and then stuff for flavor if you want

[23:04] <Hotkeys> stick it all in a carboy 

[23:04] <Hotkeys> wait a month or so

[23:04] <Hotkeys> move it to another container

[23:05] <Hotkeys> age to preference

[23:05] <Hotkeys> drink

[23:06] *** f33r3x1 left
[23:07] <RabidGravy> I haven't the patience for home brewing

[23:08] <RabidGravy> I made wine while I was at college thirty odd years ago, but we ran out of booze and started drinking it before it was ready

[23:08] <Hotkeys> lol

[23:08] <Hotkeys> i've heard mead is hard to drink before 6 months and is best after a year or more

[23:09] <RabidGravy> these were in the days before you could get booze any time you want

[23:10] <Hotkeys> I wasn't even alive thirty odd years ago lol

[23:11] <leont> Yeah, mead is much better if you're patient

[23:11] *** ChoHag left
[23:12] <leont> Given good honey, you don't need stuff for flavor, really, but good honey can be disappointingly expensive

[23:12] <RabidGravy> or get your own bees

[23:12] <leont> That helps, though it still matters where you put them

[23:12] <RabidGravy> and a good garden

[23:13] <Hotkeys> I kind of want to try making an acerglyn mead

[23:13] *** ChoHag joined
[23:13] <Hotkeys> (mead w maplesyrup)

[23:13] <RabidGravy> we've been growing lavender, the bees love that (we don't keep bees but there are lots of them around here)

[23:13] <Hotkeys> to be patriotic and all

[23:16] *** raiph left
[23:17] *** CJKinni_ joined
[23:20] *** sufrostico left
[23:21] *** CJKinni left
[23:21] *** BenGoldberg joined
[23:34] *** kjs_ left
[23:35] *** vendethiel left
[23:40] *** MadcapJake left
[23:41] *** rarara_ left
[23:44] <zengargoyle> http://doc.perl6.org/type/Int  .lsb and .msb seem to be a bit confused / confusing

[23:45] <zengargoyle> both cound from the right, and it's last/first 1 in the binary number. correct?

[23:46] <zengargoyle> *count

[23:46] *** rarara__ left
[23:49] <RabidGravy> dunno

[23:51] <TEttinger> do right and left mean anything in binary?

[23:51] <TEttinger> it's just least significant and most significant

[23:52] <TEttinger> the explanation makes sense

[23:52] <Hotkeys> it seems like they just return the position of the least and mostsignificant bits

[23:52] <TEttinger> err, the demo code

[23:52] <Hotkeys> as lsb and msb imply

[23:53] <Hotkeys> yeah the demo code does

[23:53] <Hotkeys> the explanations given seem a bit wonky though

[23:54] <zengargoyle> .lsb Otherwise returns the zero-based index from the right of the first 1 in the binary representation of the number.

[23:54] <zengargoyle> it's the last 1 in the binary representation

[23:54] <zengargoyle> .msb Otherwise returns the zero-based index from the left of the first 1 in the binary representation of the number.

[23:54] <Hotkeys> not a fan of the terms first and last

[23:54] <zengargoyle> the index is from the right just like .lsb

[23:55] <Hotkeys> lsb gives you the (zero-based) position, from the right, of the least significant bit

[23:55] <Hotkeys> msb does the same for the most significant

[23:55] <Hotkeys> as shown by demo code

[23:55] <Hotkeys> those explanations are bad

[23:55] <Hotkeys> in the doc

[23:56] <Hotkeys> it seems like whoever wrote them was trying to avoid the terms most and least significant

[23:56] <Hotkeys> but did so poorly

[23:57] *** n0tjack joined
[23:58] *** Celelibi joined
[23:58] <zengargoyle> i'd fix it, but i'm not sure of the desired terminology, so just pointing it out. :)

[23:58] <Hotkeys> yeah I'm not sure how to word it well either

[23:58] <Hotkeys> as long as one looks at the demo code they should understand it :p

