[00:00] *** lizmat left
[00:16] *** llfourn joined
[00:20] *** llfourn left
[00:21] *** tinyblak left
[00:26] *** laouji joined
[00:31] *** tinyblak joined
[00:39] *** laouji left
[00:40] *** laouji joined
[00:40] *** laouji left
[00:48] *** araujo_ joined
[00:50] *** laouji joined
[00:50] *** araujo left
[00:55] *** khisanth_ is now known as Khisanth

[01:03] <pmichaud> GLR-related challenge (a problem that once I know the solution will help with GLR design):

[01:03] <pmichaud> Write a function that given an array @a, lazily produces a list in the form (0, Write a Perl 6 function that given an array @a, lazily produces a list in the form (0, @a[0,0], 1, @a[1,1], 2, @a[2,2], 3, @a[3,3], ... ).

[01:03] <pmichaud> (in standard Perl 6)

[01:03] *** lizmat joined
[01:04] <pmichaud> you can assume that while/until/etc. loops are able to lazily return lists of elements

[01:04] <grondilu> you sure you wrote that right?

[01:04] <pmichaud> which part are you unsure of?  ;-)

[01:05] <grondilu> it's not some recursive thing is it?

[01:05] <pmichaud> no, it should be iterative

[01:05] <pmichaud> (at least I'm thinking it should be iterative)

[01:05] <pmichaud> it's a question of syntax and composition more than anything else.

[01:05] <grondilu> but I'm confused about the part "(0, Write"

[01:06] <pmichaud> oh

[01:06] <pmichaud> yeah, copy/paste error

[01:06] <pmichaud> fixing

[01:06] <pmichaud> Write a Perl 6 function that given an array @a, lazily produces a list in the form (0, @a[0,0], 1, @a[1,1], 2, @a[2,2], 3, @a[3,3], ... ).

[01:06] <pmichaud> *there*

[01:07] <grondilu> does not look so hard

[01:07] <pmichaud> it has a couple of gotchas :)

[01:07] <grondilu> oh it must flatten, right?

[01:07] <pmichaud> no, no flattening

[01:08] <pmichaud> the equivalent output would be   (0, (@a[0], @a[0]), 1, (@a[1], @a[1]), 2, (@a[2], @a[2]), ... )

[01:09] <grondilu> sub (@a) { gather for ^Inf -> $n { take $n, @a[$n, $n].item } } # is that too naice?

[01:09] <grondilu> *naive

[01:09] *** telex left
[01:09] <pmichaud> grondilu: #1.  It's itemizing the slices

[01:10] <pmichaud> (which my output doesn't have)

[01:10] *** telex joined
[01:11] <pmichaud> the list that sub is producing is actually    ((0, [@a[0], @a[0]]), (1, [@a[1], @a[1]]), ... )

[01:11] <grondilu> fine

[01:11] <grondilu> well then just double the takes

[01:11] <grondilu> sub (@a) { gather for ^Inf -> $n { take $n; take @a[$n, $n].item } }

[01:12] <grondilu> or

[01:12] <grondilu> sub (@a) { gather for ^Inf -> $n { take $n; take @a[$n, $n] } }

[01:12] *** araujo_ left
[01:12] <grondilu> no?

[01:12] <pmichaud> thinking

[01:12] <pmichaud> that seems plausible, yes.

[01:12] <grondilu> m: (sub (@a) { gather for ^Inf -> $n { take $n; take @a[$n, $n] } })( my @ = "a".."z" )

[01:13] <camelia> rakudo-moar 80f8ef: OUTPUT«(timeout)»

[01:13] <grondilu> m: say (sub (@a) { gather for 0..* -> $n { take $n; take @a[$n, $n] } })( my @ = "a".."z" )

[01:13] <camelia> rakudo-moar 80f8ef: OUTPUT«0 a a 1 b b 2 c c 3 d d 4 e e 5 f f 6 g g 7 h h 8 i i 9 j j 10 k k 11 l l 12 m m 13 n n 14 o o 15 p p 16 q q 17 r r 18 s s 19 t t 20 u u 21 v v 22 w w 23 x x 24 y y 25 z z 26 (Any) (Any) 27 (Any) (Any) 28 (Any) (Any) 29 (Any) (Any) 30 (Any) (Any) 31 (Any) …»

[01:14] <grondilu> m: say (sub (@a) { gather for ^@a -> $n { take $n; take @a[$n, $n] } })( my @ = "a".."z" )

[01:14] <camelia> rakudo-moar 80f8ef: OUTPUT«0 a a 1 b b 2 c c 3 d d 4 e e 5 f f 6 g g 7 h h 8 i i 9 j j 10 k k 11 l l 12 m m 13 n n 14 o o 15 p p 16 q q 17 r r 18 s s 19 t t 20 u u 21 v v 22 w w 23 x x 24 y y 25 z z␤»

[01:14] <pmichaud> I'd need to see the .perl

[01:14] <grondilu> m: say (sub (@a) { gather for ^@a -> $n { take $n; take @a[$n, $n] } })( my @ = "a".."z" ).perl

[01:14] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, ("a", "a"), 1, ("b", "b"), 2, ("c", "c"), 3, ("d", "d"), 4, ("e", "e"), 5, ("f", "f"), 6, ("g", "g"), 7, ("h", "h"), 8, ("i", "i"), 9, ("j", "j"), 10, ("k", "k"), 11, ("l", "l"), 12, ("m", "m"), 13, ("n", "n"), 14, ("o", "o"), 15, ("p", "p"), 16, ("q",…»

[01:14] *** AlexDaniel joined
[01:14] <pmichaud> and it would *really* be better if this is done without gather/take.  Either that or we'll have to really fix gather/take.

[01:14] <grondilu> ah that's the hard part then.  Doing lazy lists without gather/take is tricky.

[01:15] <pmichaud> I did say you can assume that while/until is able to lazily return lists of elements

[01:15] <pmichaud> (as designed in S04)

[01:16] <grondilu> m: say (sub (@a) { for ^@a -> $n {  $n, @a[$n, $n] } })( my @ = "a".."z" ).perl

[01:16] <camelia> rakudo-moar 80f8ef: OUTPUT«Nil␤»

[01:16] <pmichaud> actually, let me relax the problem a bit, then.  Take laziness out as a requirement.

[01:16] <grondilu> m: say (sub (@a) { do for ^@a -> $n {  $n, @a[$n, $n] } })( my @ = "a".."z" ).perl

[01:16] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, ("a", "a")), (1, ("b", "b")), (2, ("c", "c")), (3, ("d", "d")), (4, ("e", "e")), (5, ("f", "f")), (6, ("g", "g")), (7, ("h", "h")), (8, ("i", "i")), (9, ("j", "j")), (10, ("k", "k")), (11, ("l", "l")), (12, ("m", "m")), (13, ("n", "n")), (14, ("o", "o…»

[01:16] <pmichaud> i.e., it's okay to do it eagerly.

[01:16] <pmichaud> so, I'll reformulate the problem a bit.

[01:17] <grondilu> m: say (sub (@a) { ( $++, @a[$++,$++] for ^@a ) })( my @ = "a".."z" ).perl

[01:17] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, ("a", "a")), (1, ("b", "b")), (2, ("c", "c")), (3, ("d", "d")), (4, ("e", "e")), (5, ("f", "f")), (6, ("g", "g")), (7, ("h", "h")), (8, ("i", "i")), (9, ("j", "j")), (10, ("k", "k")), (11, ("l", "l")), (12, ("m", "m")), (13, ("n", "n")), (14, ("o", "o…»

[01:18] <pmichaud> Q2: Write a Perl 6 function that takes an array as a parameter @a and produces a list in the form  (0, @a[0,0], 1, @a[1,1], 2, @a[2,2], 3, @a[3,3], ... ).  Avoid us

[01:18] <pmichaud> ing gather/take.

[01:19] <grondilu> m: say (sub (@a) { ^Inf Z (@a Z @a) })( my @ = "a".."z" ).perl

[01:19] *** silug left
[01:19] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, "a"), (1, "a"), (2, "b"), (3, "b"), (4, "c"), (5, "c"), (6, "d"), (7, "d"), (8, "e"), (9, "e"), (10, "f"), (11, "f"), (12, "g"), (13, "g"), (14, "h"), (15, "h"), (16, "i"), (17, "i"), (18, "j"), (19, "j"), (20, "k"), (21, "k"), (22, "l"), (23, "l"), (…»

[01:19] <pmichaud> You can assume that the list-producing qualities of while and until (as described in S04) are available.

[01:20] <Util> m: sub pm (@a) { @a.keys.map({ $_, item(@a[$_, $_]) }) }; say [my @ = pm(["A".."D"])].perl;

[01:20] <camelia> rakudo-moar 80f8ef: OUTPUT«[0; "A", "A"; 1; "B", "B"; 2; "C", "C"; 3; "D", "D"]␤»

[01:20] <Util> What is the significance of the semi-colons in the output?

[01:21] <pmichaud> it's showing that you have lists-of-lists  (i.e., a LoL object).

[01:21] <grondilu> m: say (sub (@a) { ( flat $++, @a[$++,$++] for ^@a ) })( my @ = "a".."z" ).perl

[01:21] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e", 5, "f", "f", 6, "g", "g", 7, "h", "h", 8, "i", "i", 9, "j", "j", 10, "k", "k", 11, "l", "l", 12, "m", "m", 13, "n", "n", 14, "o", "o", 15, "p", "p", 16, "q", "q", 17, "r", "r", 18, "s", "s",…»

[01:21] <grondilu> m: say (sub (@a) { ( flat $++, @a[$++,$++].item for ^@a ) })( my @ = "a".."z" ).perl

[01:21] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, $("a", "a"), 1, $("b", "b"), 2, $("c", "c"), 3, $("d", "d"), 4, $("e", "e"), 5, $("f", "f"), 6, $("g", "g"), 7, $("h", "h"), 8, $("i", "i"), 9, $("j", "j"), 10, $("k", "k"), 11, $("l", "l"), 12, $("m", "m"), 13, $("n", "n"), 14, $("o", "o"), 15, $("p",…»

[01:22] <grondilu> what about that?

[01:22] <grondilu> m: say (sub (@a) { ( flat $++, (@a[$++,$++]) for ^@a ) })( my @ = "a".."z" ).perl

[01:22] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e", 5, "f", "f", 6, "g", "g", 7, "h", "h", 8, "i", "i", 9, "j", "j", 10, "k", "k", 11, "l", "l", 12, "m", "m", 13, "n", "n", 14, "o", "o", 15, "p", "p", 16, "q", "q", 17, "r", "r", 18, "s", "s",…»

[01:22] <pmichaud> the inner parcels have been itemized, so no

[01:22] <grondilu> m: say (sub (@a) { ( flat $++, (@a[$++,$++],) for ^@a ) })( my @ = "a".."z" ).perl

[01:22] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e", 5, "f", "f", 6, "g", "g", 7, "h", "h", 8, "i", "i", 9, "j", "j", 10, "k", "k", 11, "l", "l", 12, "m", "m", 13, "n", "n", 14, "o", "o", 15, "p", "p", 16, "q", "q", 17, "r", "r", 18, "s", "s",…»

[01:23] <grondilu> m: say (sub (@a) { ( flat $++, (@a[$++,$++],Nil) for ^@a ) })( my @ = "a".."z" ).perl

[01:23] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, "a", "a", Nil, 1, "b", "b", Nil, 2, "c", "c", Nil, 3, "d", "d", Nil, 4, "e", "e", Nil, 5, "f", "f", Nil, 6, "g", "g", Nil, 7, "h", "h", Nil, 8, "i", "i", Nil, 9, "j", "j", Nil, 10, "k", "k", Nil, 11, "l", "l", Nil, 12, "m", "m", Nil, 13, "n", "n", Nil,…»

[01:24] <grondilu> m: say (my @ = ^10)[4,5]

[01:24] <camelia> rakudo-moar 80f8ef: OUTPUT«4 5␤»

[01:24] <grondilu> m: say (my @ = ^10)[4,5].perl

[01:24] <camelia> rakudo-moar 80f8ef: OUTPUT«(4, 5)␤»

[01:24] <grondilu> (just checking what a splice looks like with perl)

[01:24] <grondilu> m: say ("foo", (my @ = ^10)[4,5]).perl

[01:24] <camelia> rakudo-moar 80f8ef: OUTPUT«("foo", (4, 5))␤»

[01:24] <grondilu> i c

[01:25] <lizmat> ( pmichaud has temporarily left the room )

[01:25] *** araujo_ joined
[01:25] <pmichaud> I'm in a different room :)

[01:25] <grondilu> m: say (sub (@a) { ( flat $++, @a[$++,$++][] for ^@a ) })( my @ = "a".."z" ).perl

[01:25] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e", 5, "f", "f", 6, "g", "g", 7, "h", "h", 8, "i", "i", 9, "j", "j", 10, "k", "k", 11, "l", "l", 12, "m", "m", 13, "n", "n", 14, "o", "o", 15, "p", "p", 16, "q", "q", 17, "r", "r", 18, "s", "s",…»

[01:26] <grondilu> m: say (sub (@a) { ( @a[$++,$++] for ^@a ) })( my @ = "a".."z" ).perl

[01:26] <camelia> rakudo-moar 80f8ef: OUTPUT«(("a", "a"), ("b", "b"), ("c", "c"), ("d", "d"), ("e", "e"), ("f", "f"), ("g", "g"), ("h", "h"), ("i", "i"), ("j", "j"), ("k", "k"), ("l", "l"), ("m", "m"), ("n", "n"), ("o", "o"), ("p", "p"), ("q", "q"), ("r", "r"), ("s", "s"), ("t", "t"), ("u", "u"), ("v…»

[01:26] <grondilu> m: say (sub (@a) { ^Inf Z ( @a[$++,$++] for ^@a ) })( my @ = "a".."z" ).perl

[01:26] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, "a"), (1, "a"), (2, "b"), (3, "b"), (4, "c"), (5, "c"), (6, "d"), (7, "d"), (8, "e"), (9, "e"), (10, "f"), (11, "f"), (12, "g"), (13, "g"), (14, "h"), (15, "h"), (16, "i"), (17, "i"), (18, "j"), (19, "j"), (20, "k"), (21, "k"), (22, "l"), (23, "l"), (…»

[01:27] <grondilu> m: say (sub (@a) { ^Inf Z, ( @a[$++,$++] for ^@a ) })( my @ = "a".."e" ).perl

[01:27] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, "a"), (1, "a"), (2, "b"), (3, "b"), (4, "c"), (5, "c"), (6, "d"), (7, "d"), (8, "e"), (9, "e"))␤»

[01:27] *** araujo_ left
[01:27] <grondilu> Z flattens the RHS apparently

[01:28] *** araujo_ joined
[01:28] *** cognominal joined
[01:28] <grondilu> wait

[01:28] <grondilu> m: say List.^methods

[01:28] <camelia> rakudo-moar 80f8ef: OUTPUT«new to from fmt flat list lol flattens Capture Parcel Supply eager elems gimme iterator munch pick pop shift plan roll reverse rotate splice sort uniq unique squish rotor REIFY FLATTENABLE_LIST FLATTENABLE_HASH reduce sink STORE_AT_POS combinations permuta…»

[01:29] *** cognominal left
[01:29] <grondilu> m: say (my @ = ^10).^methods

[01:29] <camelia> rakudo-moar 80f8ef: OUTPUT«new BIND-POS DELETE-POS flattens name of default dynamic REIFY STORE Method+{<anon>}.new Method+{<anon>}.new perl ACCEPTS elems iterator pick plan sort uniq unique Method+{<anon>}.new infinite fmt list flattens gimme sink STORE_AT_POS Method+{<anon>}.new M…»

[01:29] <pmichaud> also, Z uses gather/take internally I suspect, so it's not legal.  :)

[01:29] <grondilu> m: say (my @ = ^10).kv

[01:29] <camelia> rakudo-moar 80f8ef: OUTPUT«0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9␤»

[01:29] <grondilu> m: say (sub (@a) { ( @a[$++,$++] for ^@a ).kv })( my @ = "a".."e" ).perl

[01:29] <camelia> rakudo-moar 80f8ef: OUTPUT«(0, ("a", "a"), 1, ("b", "b"), 2, ("c", "c"), 3, ("d", "d"), 4, ("e", "e"))␤»

[01:30] <grondilu> what about that?

[01:30] *** araujo_ left
[01:30] <grondilu> maybe using .kv is cheating?

[01:31] <pmichaud> kv is using gather/take also.

[01:31] *** araujo_ joined
[01:33] <grondilu> well if the list is not lazy, we can push in a variable, right?

[01:33] *** silug joined
[01:33] <grondilu> m: say (sub (@a) { my @b; push @b, $++, @a[$++, $++] for ^@a })( my @ = "a".."e" ).perl

[01:33] <camelia> rakudo-moar 80f8ef: OUTPUT«Nil␤»

[01:34] <grondilu> m: say (sub (@a) { my @b; push @b, $++, @a[$++, $++] for ^@a; return @b })( my @ = "a".."e" ).perl

[01:34] <camelia> rakudo-moar 80f8ef: OUTPUT«[0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e"]<>␤»

[01:34] <grondilu> m: say (sub (@a) { my @b; push @b, $++, (@a[$++, $++]) for ^@a; return @b })( my @ = "a".."e" ).perl

[01:34] <camelia> rakudo-moar 80f8ef: OUTPUT«[0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e"]<>␤»

[01:34] <grondilu> oh

[01:35] <grondilu> m: say (sub (@a) { my @b; for ^@a { push @b, $_; push @b, @a[$_, $_] }; return @b })( my @ = "a".."e" ).perl

[01:35] <camelia> rakudo-moar 80f8ef: OUTPUT«[0, "a", "a", 1, "b", "b", 2, "c", "c", 3, "d", "d", 4, "e", "e"]<>␤»

[01:35] <grondilu> push flattens ?!

[01:36] <lizmat> push takes a slurpy, which flattens, no?

[01:37] <grondilu> m: say (sub (@a) { my @b; for ^@a { @b[2*$_] = $_; @b[2*$_+1] = (@a[$_, $_]) }; return @b })( my @ = "a".."e" ).perl

[01:37] <camelia> rakudo-moar 80f8ef: OUTPUT«[0; "a", "a"; 1; "b", "b"; 2; "c", "c"; 3; "d", "d"; 4; "e", "e"]<>␤»

[01:38] <grondilu> semicolons again :/

[01:38] <grondilu> m: say (sub (@a) { my $b; for ^@a { $b[2*$_] = $_; $b[2*$_+1] = (@a[$_, $_]) }; return $b })( my @ = "a".."e" ).perl

[01:38] <camelia> rakudo-moar 80f8ef: OUTPUT«[0; "a", "a"; 1; "b", "b"; 2; "c", "c"; 3; "d", "d"; 4; "e", "e"]␤»

[01:40] <pmichaud> I have to get ready for my session -- bbl 

[01:40] <pmichaud> will backlog later

[01:42] *** BenGoldberg joined
[01:42] <grondilu> m: say (sub (@a) { ( $++, @a[$++, $++]) xx * }; return @b })( my @ = "a".."e" ).perl

[01:42] <camelia> rakudo-moar 80f8ef: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ceoJACQ167␤Variable '@b' is not declared␤at /tmp/ceoJACQ167:1␤------> 3) { ( $++, @a[$++, $++]) xx * }; return 7⏏5@b })( my @ = "a".."e" ).perl␤»

[01:42] <grondilu> m: say (sub (@a) { ( $++, @a[$++, $++]) xx * })( my @ = "a".."e" ).perl

[01:42] <camelia> rakudo-moar 80f8ef: OUTPUT«(ListIter.new,)␤»

[01:42] <grondilu> m: say $++ xx 5

[01:42] <camelia> rakudo-moar 80f8ef: OUTPUT«0 1 2 3 4␤»

[01:42] <grondilu> m: say (sub (@a) { ( $++, @a[$++, $++]) xx * })( my @ = "a".."e" )[^10].perl

[01:42] <camelia> rakudo-moar 80f8ef: OUTPUT«((0, ("a", "a")), (1, ("b", "b")), (2, ("c", "c")), (3, ("d", "d")), (4, ("e", "e")), (5, (Any, Any)), (6, (Any, Any)), (7, (Any, Any)), (8, (Any, Any)), (9, (Any, Any)))␤»

[01:43] <grondilu> m: say (sub (@a) { |( $++, @a[$++, $++]) xx * })( my @ = "a".."e" )[^10].perl

[01:43] <camelia> rakudo-moar 80f8ef: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ilV2BgSHoT␤Arg-flattening | is only valid in an argument list␤at /tmp/ilV2BgSHoT:1␤------> 3say (sub (@a) { |7⏏5( $++, @a[$++, $++]) xx * })( my @ = "a"␤»

[01:43] <grondilu> well that's hard

[01:50] *** araujo__ joined
[01:53] *** ssqq joined
[01:53] *** araujo_ left
[01:55] *** SevenWolf joined
[02:07] *** llfourn joined
[02:08] *** dayangkun joined
[02:09] *** laouji left
[02:09] *** laouji joined
[02:09] *** dayangkun left
[02:10] *** dayangkun joined
[02:11] <AlexDaniel> method antipair() returns Pair:D # - what does this smiley means?

[02:13] *** ssqq left
[02:15] *** yqt left
[02:23] *** Petit_Dejeuner left
[02:29] *** noganex joined
[02:32] *** noganex_ left
[02:34] <b2gills> It means it returns a defined Pair object

[02:35] *** rmgk left
[02:35] *** rmgk_ joined
[02:35] *** rmgk_ is now known as rmgk

[02:41] <AlexDaniel> b2gills: thanks

[02:53] <lizmat> m: my $a := $a; say $a   # jackpot!

[02:53] <camelia> rakudo-moar 80f8ef: OUTPUT«(signal SEGV)»

[02:53] <lizmat> can someone rakudobug this ?

[02:54] <awwaiid> Hello!

[02:55] <lizmat> ok, I lost my pair programmer, I'll do it myself  :-)

[02:55] <lizmat> awwaiid o/

[02:56] <awwaiid> I'm having great fun using matplotlib.pyplot Inline::Python; I created a simple wrapper, https://gist.github.com/awwaiid/ef3f0abcfa96e34977b4

[02:57] <awwaiid> ... and now I don't want to keep adding methods. What witches brew can we stir up today?!

[02:57] <awwaiid> a nice evil autoload type thing would do

[02:58] <awwaiid> if this was a Class, I could inherit from it and be done; alas this is a collection of defs in a module

[02:59] <lizmat> there's 'method FALLBACK'

[02:59] * awwaiid googles

[03:00] *** thezip joined
[03:00] <lizmat> http://design.perl6.org/S12.html#FALLBACK_methods

[03:01] <awwaiid> lizmat: OMG that worked

[03:01] <awwaiid> lizmat++ # Rock!

[03:01] <lizmat> :)

[03:03] *** kurahaupo1 joined
[03:03] <awwaiid> I updated the gist with the new version

[03:08] <awwaiid> I'm slurping data out of git which has github PRs; using that to estimate PR lifetime (time delta from first commit to PR merge). I was previously dumping that as a CSV and plotting in libreoffice -- but no longer!

[03:08] <awwaiid> so awesome

[03:10] <lizmat> :-)

[03:10] <lizmat> m: my $a := $a; say $a.Str

[03:10] <camelia> rakudo-moar 80f8ef: OUTPUT«Cannot call method 'Str' on a null object␤  in block <unit> at /tmp/bu5hgP8_WK:1␤␤»

[03:11] *** bin_005 joined
[03:13] *** tinyblak left
[03:13] *** tinyblak joined
[03:14] <awwaiid> update https://gist.github.com/awwaiid/ef3f0abcfa96e34977b4 to have the full example -- simple wrapper lib, script for slurping git, and an example result chart png

[03:15] <awwaiid> Great way to end the day. Bedtime!

[03:19] *** silug left
[03:26] <lizmat> good night, awwaiid 

[03:26] *** kaare_ joined
[03:30] <thezip> lizmat, thanks for your help in pmichaud's presentation tonight

[03:31] <lizmat> yw  !

[03:32] *** silug joined
[03:33] *** skids joined
[03:39] *** jack_rabbit left
[03:41] *** laouji left
[03:46] *** thezip left
[03:50] *** bin_005 left
[03:50] *** BenGoldberg left
[03:51] <dalek> rakudo/nom: 1372f77 | lizmat++ | src/core/Pair.pm:

[03:51] <dalek> rakudo/nom: Make sure that Pair<doesnotexist> returns Any

[03:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1372f77003

[03:52] <lizmat> rather than Mu  spotted at the YAPC::NA Perl 6 intro course

[03:54] <zostay> is there a better way to say: subtype IntOrPositional of Mu where any(Int, Positional) ?

[03:57] *** vendethiel joined
[03:58] *** AlexDaniel left
[04:12] <lizmat> zostay: don't know offhand

[04:15] <zostay> or using valid syntax (:-p): subset IntOrPositional of Mu where Int|Positional;

[04:15] <zostay> was just thinking returns Int|Positional would be handy

[04:17] *** davido_ left
[04:18] *** davido_ joined
[04:21] <lizmat> yes, but that will probably not happen before this year's Christmas

[04:21] <lizmat> m: sub a returns Bool { fail }; a

[04:21] <camelia> rakudo-moar 1372f7: OUTPUT«Earlier failure:␤ ␤  in block <unit> at /tmp/H579fGZYP9:1␤␤Final error:␤ Type check failed for return value; expected 'Bool' but got 'Failure'␤  in any return_error at src/vm/moar/Perl6/Ops.nqp:639␤  in sub a at /tmp/H579fGZYP9:1␤  in block…»

[04:22] <lizmat> m: sub a returns Bool|Failure { fail }; a

[04:22] <camelia> rakudo-moar 1372f7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6FKCwO2RKZ␤Missing block␤at /tmp/6FKCwO2RKZ:1␤------> 3sub a returns Bool7⏏5|Failure { fail }; a␤    expecting any of:␤        new name to be defined␤»

[04:23] <zostay> np ^_^

[04:28] *** laouji joined
[04:39] *** kurahaupo1 is now known as kurahaupo

[04:39] *** jack_rabbit joined
[04:43] *** TimToady left
[04:45] *** TimToady joined
[04:46] *** quester joined
[04:50] *** dagurval joined
[04:56] *** diana_olhovik_ joined
[05:34] *** diana_olhovik_ left
[05:38] *** jack_rabbit left
[05:42] *** vendethiel left
[05:44] *** lizmat left
[05:46] *** Psyche^ joined
[05:48] *** xinming left
[05:50] *** Patterner left
[06:00] *** xinming joined
[06:05] *** llfourn left
[06:08] *** vendethiel joined
[06:10] *** diana_olhovik joined
[06:15] *** kurahaupo left
[06:18] *** quester left
[06:21] *** FROGGS joined
[06:25] *** Sqirrel left
[06:25] *** Sqirrel joined
[06:26] *** tinyblak left
[06:26] *** tinyblak joined
[06:27] *** yeahnoob joined
[06:27] *** RabidGravy joined
[06:31] *** tinyblak left
[06:33] *** rindolf joined
[06:34] *** lizmat joined
[06:35] *** domidumont joined
[06:37] *** vendethiel left
[06:37] *** domidumont left
[06:38] *** domidumont joined
[06:38] *** bjz joined
[06:39] *** bjz left
[06:39] <lizmat> m: say say 2**4294967296   # seems we got a 64bit int power problem

[06:39] <camelia> rakudo-moar 1372f7: OUTPUT«0␤True␤»

[06:40] *** vendethiel joined
[06:40] <lizmat> m: say 2**4294967295   # this will probably timeout

[06:40] <camelia> rakudo-moar 1372f7: OUTPUT«(timeout)»

[06:42] *** bbkr_ joined
[06:42] *** bbkr left
[06:44] <lizmat> m: use nqp; say nqp::pow_I(2,4294967296,Num,Int)   # basically wrong at NQP level

[06:44] <camelia> rakudo-moar 1372f7: OUTPUT«0␤»

[06:44] <lizmat> m: use nqp; say nqp::pow_I(2,4294967295,Num,Int)   # basically wrong at NQP level

[06:44] <camelia> rakudo-moar 1372f7: OUTPUT«(timeout)»

[06:45] *** tinyblak joined
[06:50] *** yeahnoob left
[06:57] *** bjz joined
[06:57] *** gfldex joined
[07:05] *** _mg_ joined
[07:10] *** bjz left
[07:17] *** cognominal joined
[07:25] *** ely-se joined
[07:25] <ely-se> hi

[07:26] *** FROGGS left
[07:29] <ely-se> I had this idea of adding "alias Larry=clang" to my zshrc so I could say "Larry -Wall"

[07:29] <ely-se> probably a bad and old joke :(

[07:31] *** ely-se left
[07:31] *** llfourn joined
[07:33] *** Ven joined
[07:36] *** ely-se joined
[07:41] *** g4 joined
[07:41] *** g4 left
[07:41] *** g4 joined
[07:46] *** SevenWolf left
[07:53] *** ely-se left
[07:53] *** [Sno] left
[07:53] *** [Sno] joined
[07:55] *** Ven left
[07:55] *** Ven_ joined
[07:56] <Mouq> m: say sub (@a){my $i = 0; do while $i <= @a { say ($++ %% 2) ?? $i++ !! @a[$i - 1, $i - 1] }}(my @ = "a".."e" )[^10].perl # not sure what's wrong here

[07:56] <camelia> rakudo-moar 1372f7: OUTPUT«0␤a a␤1␤b b␤2␤c c␤3␤d d␤4␤e e␤5␤(Bool::False,)␤»

[07:56] <Mouq> (while always seems to return (Bool::False,)

[07:57] <Mouq> (also I know that's not a perfect solution, but it's close

[07:57] <Mouq> )

[08:04] <Mouq> Oh hey

[08:04] <RabidGravy> is there anyway I can tell whether the perl is 32 or 64 bit?  

[08:04] <RabidGravy> nothing stands out in $*VM

[08:04] <Mouq> m: https://gist.github.com/Mouq/50660c17d7cd617f8537

[08:04] <camelia> rakudo-moar 1372f7: OUTPUT«((Bool::True, 0), (Bool::False, 0), (Bool::True, 1), (Bool::False, 1), (Bool::True, 2), (Bool::False, 2), (Bool::True, 3), (Bool::False, 3), (Bool::True, 4), (Bool::False, 4))␤(0, ("a", "a"), 1, ("b", "b"), 2, ("c", "c"), 3, ("d", "d"), 4, ("e", "e"))␤»

[08:04] <Mouq> Err

[08:04] *** amurf left
[08:05] <RabidGravy> cool

[08:05] <Mouq> m: https://gist.github.com/Mouq/50660c17d7cd617f8537

[08:05] <camelia> rakudo-moar 1372f7: OUTPUT«(0, ("a", "a"), 1, ("b", "b"), 2, ("c", "c"), 3, ("d", "d"), 4, ("e", "e"))␤»

[08:05] <Mouq> Yayy

[08:05] *** abraxxa joined
[08:08] <Mouq> RabidGravy: Wish I could answer your question, but I have no idea

[08:11] <[ptc]> tadzik: ping

[08:11] *** spider-mario left
[08:12] *** darutoko joined
[08:13] <pmichaud> Mouq++  # that's helpful, thanks

[08:14] <Mouq> Cleaned up the gist a little as well, but no p

[08:14] <Mouq> (It's lazy! :D)

[08:15] <pmichaud> that helps me formulate my next Q.  :)

[08:15] <Mouq> Bring it on ;)

[08:15] <jnthn> morning, #perl6

[08:15] <pmichaud> jnthn: o/

[08:15] <Mouq> o/

[08:15] <pmichaud> jnthn: the Perl 6 tutorial was a huge hit tonight at yapc::na

[08:16] <nwc10> we're hoping for a neverending September, but in a good way? :-)

[08:16] <pmichaud> definitely over 30 attendees, most of whom stayed 3.5 hours or more

[08:17] <Ven_> wow :-)

[08:17] <pmichaud> without a break.

[08:18] <jnthn> pmichaud: Wow o.O

[08:18] <jnthn> pmichaud: Did you fix some of the bugs? ;)

[08:18] <pmichaud> jnthn: some, but missed some

[08:18] *** bjz joined
[08:18] <pmichaud> and we ran into some other oddities that we'll likely investigate at hackathon on thu

[08:18] <jnthn> OK; Swiss Perl Workshop are interested in having it, so please share your fixes ;)

[08:18] <pmichaud> Will do.

[08:18] <jnthn> (At a point that's convenient.)

[08:18] <pmichaud> I'll send back the src file

[08:19] <jnthn> Cool, thanks.

[08:19] <pmichaud> I also have a few suggestions for content reordering, etc.

[08:19] <jnthn> OK. I was fairly careful to avoid forward dependencies in the material, but everything is vulnerable to forward dependencies in curiosity... :-)

[08:20] <jnthn> Would be good to make it less so, though. :)

[08:20] <pmichaud> the use of the whatever-star in the given/when statement was a major one

[08:20] <pmichaud> since it's not introduced prior to that

[08:21] <jnthn> Hm

[08:21] <pmichaud> getting from given topicalizer to whatever star seemed to be way too big a leap

[08:22] <pmichaud> most people leapt to "oh, * is an alias for $_"

[08:22] <pmichaud> anyway, I'll come up with a list of places we got hung up

[08:23] <jnthn> Hm, I don't remember that being problematic, though I suspect I did a "lies to children" :)

[08:23] <jnthn> But yeah, if people actually want to dig into *why* it works, it's a big leap :)

[08:23] <pmichaud> yeah, we had a lot of *why*

[08:23] <pmichaud> and "how"

[08:24] <pmichaud> I quickly did a whatever segue at that point, though, and people were very pleased to learn about whatever.

[08:24] <jnthn> *nod*

[08:24] <pmichaud> it might help to cover   @a[*-1]  earlier in subscripting

[08:24] <jnthn> I guess you could re-write it as $_ in the given/when example

[08:24] <pmichaud> that at least introduces whatever, without the obvious $_ reference

[08:24] <pmichaud> then when we get to   * < 10   they have the notion of "oh, whatever"

[08:25] <pmichaud> er * < 0... whatever.

[08:25] <jnthn> That could also work, yes.

[08:26] <jnthn> If you'll also be at Swiss Perl Workshop I'm also open to co-hosting it. :-)

[08:27] <pmichaud> I'm still uncertain about swiss pw, but the odds are going up drastically with each passing day.  :)

[08:27] <pmichaud> okay, time for my next GLR-related coding challenge....

[08:27] *** abraxxa left
[08:27] <pmichaud> Q3:  Each of the standard looping constructs (for, while, until) has the ability to create a list.  At present I only know how to get them to return a list with the same number or values as the number of iterations.  Is there a way to get a loop that produces more than one value for some or all of its iterations?

[08:27] * diegok wants 3.5h of Perl 6 tutorial at YAPC::EU

[08:28] <pmichaud> one of the things that worked really well here is that the tutorial was scheduled as an evening activity...

[08:28] <pmichaud> i.e., it was at the same time as YAPC::NA's traditional "game night"

[08:28] *** abraxxa joined
[08:28] <pmichaud> so, it didn't clobber any other talks or events, it could be open-ended as to ending time

[08:29] <pmichaud> i.e., we ran it more like an extended BoF than a tutorial or scheduled talk

[08:29] *** tinyblak left
[08:29] <jnthn> diegok: Should be do-able

[08:30] <[Tux]> RT#124191 is fixed \o/

[08:30] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124191

[08:30] <jnthn> pmichaud: "redo"?

[08:30] <diegok> jnthn: good!, should I start asking for space? 

[08:30] <jnthn> diegok: You're one of the organizers, iiuc?

[08:30] *** FROGGS joined
[08:30] <diegok> jnthn: yup, I'm helping the Granada folks

[08:31] <pmichaud> jnthn: well, I'm really asking if there's a way to get more than one value out of each block invocation

[08:31] <pmichaud> and have them concatenate into a list

[08:31] <jnthn> diegok: Cool. Anyway, I'm fine with doing it.

[08:31] <jnthn> pmichaud: Not as far as I'm aware; all kinds of "multiple return vlaue" in Perl 6 really mean "return a Parcel"

[08:32] <jnthn> pmichaud: And we decided we want to do away with flattening of those in most contexts

[08:32] <jnthn> pmichaud: So it'd take an explicit .flat somewhere on the resulting list

[08:32] <pmichaud> right.  and I'm thinking we need _something_ that allows us to iteratively build a list but where some iterations add more elements to the list than one

[08:32] <jnthn> gather/take... :)

[08:32] <pmichaud> using an explicit .flat on the resulting list over flattens

[08:33] <diegok> jnthn: ok, I'll send it to the orgas list and I'll come back to you!, thank you!. 

[08:33] <jnthn> pmichaud: True. and I guess you want a more efficient thing than gather/take

[08:33] <jnthn> pmichaud: Trouble is we want to avoid introducing checks all over the place

[08:34] <pmichaud> We need either a more efficient thing than gather/take, or we need a far faster gather/take.

[08:34] <Mouq> m: my $s = 0; say do for ^10 -> $i { LEAVE { say "redo" and redo if $s++ < $i+2 }; $i } # alas

[08:34] <camelia> rakudo-moar 1372f7: OUTPUT«redo␤redo␤0 1 2 3 4 5 6 7 8 9␤»

[08:34] <skids> pmichaud: maybe something with catching/resuming an exception that occurs at just the right time?

[08:34] <pmichaud> skids:  catching/resuming exception is basically gather-take kind of slowness

[08:34] <jnthn> skids: The catch/resume of the exception is, at least once we support batching, the main slow in gather/take.

[08:34] <jnthn> Today it shares that cost with "take a continuation"

[08:34] <jnthn> But if we get to batch we can avoid that.

[08:35] <jnthn> But there'll still be the catch/resume cost. We can cheapen that but it's never going to be free.

[08:35] <pmichaud> essentially I feel like we're missing a list primitive

[08:35] <skids> Yeah I wasn't suggesting it as a "way to" but the only way I could see something like that happenning.

[08:35] <skids> (with existing constructs)

[08:36] <jnthn> pmichaud: I guess "how do we write kv" is an immediate motivator?

[08:36] <pmichaud> jnthn: you'd be right.

[08:36] <[Tux]> if I re-enable the test I excluded for RT#124191, I now get a core dump after 11834 tests :(

[08:36] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124191

[08:37] <[Tux]>  /pro/3gl/CPAN/rakudobrew/bin/perl6: line 2:  6958 Segmentation fault      PATH=/pro/3gl/CPAN/rakudobrew/moar-nom/install/bin:$PATH perl6 "$@"

[08:37] *** Ven_ left
[08:38] <pmichaud> basically,  is   .map(&block)  constrained to producing lists that have the same number of elements as the number of invocations of &block ?

[08:40] <Mouq> pmichaud: No, it can have less :P

[08:40] <skids> Another way to look at it is is there a way to invoke block more than once per element (and then the block could alternate what it actually does)

[08:40] <FROGGS> m: say (^10).map({$_ == 3 ?? Empty !! $_}) # not constraint

[08:41] <camelia> rakudo-moar 1372f7: OUTPUT«0 1 2 4 5 6 7 8 9␤»

[08:41] <pmichaud> having the block alternate what it does is definitely not the approach I'm looking for

[08:41] <FROGGS> but it cannot have more in the way it is implemented right now

[08:41] *** tinyblak joined
[08:41] <pmichaud> I'm more interested in the case of more-than-one-element per iteration

[08:41] <pmichaud> I know about the zero case

[08:41] <skids> (or invoke multiple blocks)

[08:42] <FROGGS> what if 'return 1, 2' would return two things, and 'return (1, 2)' would return one?

[08:42] <FROGGS> I mean, would that bite us somewhere?

[08:43] <FROGGS> m: say (^10).map({$_ == 3 ?? 1, 2 !! $_})

[08:43] <camelia> rakudo-moar 1372f7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xxFam3ekAp␤Precedence of , is too loose to use inside ?? !!; please parenthesize␤at /tmp/xxFam3ekAp:1␤------> 3say (^10).map({$_ == 3 ?? 17⏏5, 2 !! $_})␤    expecting any of:␤        infix␤   …»

[08:43] <Mouq> m: say sub mapcombin(@a, $f, $g) { (^(2*@a)).map({$_ %% 2 , ($_/2).floor}).map(->[$s,$i]{$s ?? @a[$i]  ~~ $f !! @a[$i] ~~ $g})}(^10, *+1, */2)

[08:43] <camelia> rakudo-moar 1372f7: OUTPUT«1 0 2 0.5 3 1 4 1.5 5 2 6 2.5 7 3 8 3.5 9 4 10 4.5␤»

[08:43] <Mouq> m: say sub mapcombin(@a, $f, $g) { (^(2*@a)).map({$_ %% 2 , ($_/2).floor}).map(->[$s,$i]{$s ?? @a[$i]  ~~ $f !! @a[$i] ~~ $g})}(^10, *+1, */2).perl

[08:43] <camelia> rakudo-moar 1372f7: OUTPUT«(1, 0.0, 2, 0.5, 3, 1.0, 4, 1.5, 5, 2.0, 6, 2.5, 7, 3.0, 8, 3.5, 9, 4.0, 10, 4.5)␤»

[08:44] <FROGGS> m: say (^10).map({$_ == 3 ?? leave 1, 2 !! $_}) # would that be the way to produce more output values?

[08:44] <camelia> rakudo-moar 1372f7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0Um8Fy_r3m␤Undeclared routine:␤    leave used at line 1␤␤»

[08:44] <jnthn> FROGGS: Trouble is that you'd then have to say "well, what is the type that is returned", and you'd get into "is a block-final (1, 2) different from 1, 2" and so on...which wil be...tricky

[08:44] <pmichaud> FROGGS: we don't have any notion of "return two things" in Perl 6.

[08:45] <FROGGS> jnthn: we already have List, Array and Parcel... just make one of them flatten :P

[08:46] <pmichaud> I would not be opposed to having a list-y type that always immediately flattens.

[08:46] <FROGGS> jnthn: though, in '@a = 1, 2' the LHS decides about the flattening, right?

[08:46] <jnthn> FROGGS: yes

[08:46] <FROGGS> :/

[08:46] <jnthn> pmichaud: We were trying to get rid of List/Parcel, but type would be the right slot to hang things off...

[08:47] <pmichaud> At the moment I'm still expecting Parcel to go away.  &infix:<,> becomes a List constructor

[08:47] <pmichaud> but if we had a type that immediately flattened when placed in a list, that would be... useful.

[08:48] <FROGGS> (1, 2) == List which does not flatten on its own; 1, 2 == List that will

[08:48] <pmichaud> FROGGS: parens are grouping only

[08:48] <FROGGS> would be ncie if we had a way oto see the results of these thoughts within minutes :o)

[08:49] <pmichaud> if I have a type that immediately flattens, then I could have something like     { ... ; Flat.new($a, @b) }

[08:49] <FROGGS> pmichaud: yes, but somehow two literal lists have to produce two different types

[08:50] <FROGGS> :{ } creates object hashes... maybe |( ) creates flattened lists?

[08:50] <pmichaud> then   (1..10).map( { Flat.new($a, @b) }   would be able to give me the   ($a, @b, $a, @b, $a, @b, ...) sort of List I'm looking for

[08:50] <FROGGS> though, the syntax bit might not be so important right now

[08:50] *** bin_005 joined
[08:50] <pmichaud> FROGGS: the syntax is actually hugely important to me right now

[08:50] <FROGGS> ohh, okay

[08:50] <pmichaud> part of my struggle is that p6 has never had a feature to do this sort of thing, and I think we need one.

[08:51] <FROGGS> I tend to think about syntax just being sugar for the semantics

[08:51] <pmichaud> every time I start to work on fixing Lists I run into "we don't have a way to do this seemingly common thing"

[08:51] *** laouji left
[08:51] <pmichaud> (this problem predates GLR)

[08:51] <[ptc]> .tell tadzik could you review https://github.com/tadzik/rakudobrew/pull/42 when you get time please?  It allows matching Rakudo/panda versions to be installed on Travis

[08:51] <yoleaux> [ptc]: I'll pass your message to tadzik.

[08:52] <skids> Extend "proceed" to take a value, maybe?

[08:53] <jnthn> |(...) already has a meaning, so we can't really steal that

[08:53] <jnthn> s/so/and/

[08:54] * jnthn agrees with Pm's analysis that we could do with this

[08:54] *** zengargoyle left
[08:55] <FROGGS> jnthn: sad, it would be the obvious syntax :lo)

[08:55] <FROGGS> :o)*

[08:55] <jnthn> I don't have a good syntax suggestion short of trying to pick a word like interpolate(1, 2)

[08:55] <pmichaud> many of the problems we've had with Z and xx and Z, and ...   come down to "we don't have a way to concatenate lists.

[08:56] *** zengargoyle joined
[08:57] *** yeahnoob joined
[08:58] <pmichaud> at this point I'd even consider something like a   infix:<~,>  or infix:<,~>  operator  :-)

[08:59] *** espadrine joined
[08:59] <[ptc]> hoelzro, ugexe: I've added docs about building Perl 6 on Travis: https://github.com/paultcochrane/docs-travis-ci-com/commit/613042c076f299ec80b7b309f4fa9e9104b0dce0

[08:59] *** laouji joined
[09:00] *** skids left
[09:00] <moritz> pmichaud: fwiw I've also suggested to have a list concatenation operator

[09:00] <[ptc]> hoelzro, ugexe: could you please review before I submit the pull request?  Thanks in advance!

[09:00] *** xinming left
[09:01] <pmichaud> alternatively, I'd be happy with the notion that

[09:01] *** xinming joined
[09:01] <pmichaud> (1..5).map( { 1,2 } )      produces   (1, 2, 1, 2, 1, 2, 1, 2, 1, 2)

[09:01] <pmichaud> and if you want the groups, you do

[09:01] <jnthn> [Tux]: Where do I find the code to reproduce that?

[09:02] <FROGGS> what about (,) ?

[09:02] <FROGGS> 1, 2 (,) 3, 4

[09:02] <FROGGS> like the set ops

[09:02] <pmichaud> (1..5).map( { ((1,2),) }        producing   ((1,2), (1,2), (1,2), (1,2), (1,2))

[09:02] <jnthn> pmichaud: What type will 1,2 produce?

[09:02] <pmichaud> jnthn: List.

[09:03] <pmichaud> (1,2) produces a List

[09:03] <FROGGS> the flattenable List?

[09:03] <pmichaud> ((1,2),)  produces a List containing a single List element

[09:03] <jnthn> pmichaud: (1..5).map({ my @ = 1, 2 }) # result?

[09:03] <pmichaud> jnthn: (1, 2, 1, 2, 1, 2, 1, 2, 1, 2)

[09:03] <FROGGS> aye, that's what the @-sigil should do

[09:04] <FROGGS> that's why we have sigils after all, no?

[09:04] <pmichaud> I'm just speculatin' here to try to move towards an answer.

[09:04] <jnthn> But I thought a lot of this is what we were getting rid of in the GLR...

[09:04] <FROGGS> ohh

[09:04] *** laouji left
[09:04] <pmichaud> jnthn: getting rid of what, exactly ?

[09:05] <jnthn> pmichaud: A lot of the places that things magically flatten.

[09:05] <jnthn> So there's a small number of them (slurpies, array assignment, [...]) to remember.

[09:05] <pmichaud> this flattening isn't "magical", though.

[09:05] <FROGGS> jnthn: this would return five Arrays, no? (1..5).map({ my @ = 1, 2 })

[09:05] <FROGGS> so the result would be ([1,2], [1,2], [1,2], [1,2], [1,2])

[09:06] <pmichaud> or, it's "flattening" only because we don't have a way of saying "a map iteration that adds multiple elements to the resulting List"

[09:06] <jnthn> FROGGS: No, mor elike ((1, 2), (1, 2), ...)

[09:06] <FROGGS> err, [1, 2]<>

[09:06] <FROGGS> yeah

[09:06] <jnthn> Or what you said :)

[09:06] <pmichaud> I publicly said tonight that I totally hate the [...]<> notation.  :)

[09:07] <jnthn> pmichaud: I don't think you're alone in that :P

[09:07] <pmichaud> To me it's a huge design smell.

[09:07] <jnthn> *nod*

[09:07] <moritz> "box with a beak"

[09:07] <FROGGS> *nod*

[09:07] <pmichaud> I'm wondering if  [...]  and {...} should produce flattenable array/hash

[09:08] <pmichaud> the fact that they're itemized is a little bit of a holdover from p5

[09:08] <pmichaud> and I'm not sure that meaning has a lot of purpose in a post-GLR world.

[09:08] <moritz> I'd like to be able to create nested arrays with  my @a = [1, 2], [3, 4]

[09:08] <FROGGS> or with my @a = (1, 2), (3, 4)

[09:08] <pmichaud> moritz: would it be.... what FROGGS said

[09:09] <moritz> what would ( , ) construct?

[09:09] <jnthn> That...surprises me. I'd thought Array assignment would flatten non-itemized things...

[09:09] <moritz> a List? Array? Parcel?

[09:10] <pmichaud> I asked TimToady yesterday what flattens, and he said  "only slurpies and .flat"

[09:10] <pmichaud> (or 'flat()')

[09:10] <pmichaud> he didn't mention list assignment as flattening.  Perhaps that was an oversight.

[09:10] <jnthn> Perhaps.

[09:10] <pmichaud> moritz:  there's no  ( , )

[09:10] <jnthn> I'd had his list plus list assignment and [...]

[09:10] <moritz> because if (1, 2) doesn't construct an Array, @a = (1, 2), (3, 4); @a[0][0] = 5 will fail

[09:10] <jnthn> (the inside of [...])

[09:11] <pmichaud> moritz:  I only see &infix:<,> syntactically

[09:11] <pmichaud> moritz:  thinking, but you may be correct.

[09:11] <moritz> pmichaud: ok, what would  my @a = (1, 2), (3, 4); say @a[0].^name  output?

[09:11] <pmichaud> Still,    my @a = [1,2], [3,4];  can work to construct arrays even if  [...]  doesn't itemize.

[09:12] <moritz> if that works, +1

[09:12] <pmichaud> basically @a gets two values, each of which are Arrays

[09:12] *** bbkr joined
[09:12] <pmichaud> itemization isn't needed for that

[09:12] <pmichaud> because the act of putting the array into @a[0] and @a[1]  produces itemization

[09:13] <pmichaud> (since @a[0] and @a[1] are scalar containers)

[09:13] <pmichaud> then @a.perl  could just be   "[ ... ]"  without the ugly <> at the edn.

[09:13] *** laouji joined
[09:13] <pmichaud> *end

[09:14] <jnthn> pmichaud: That could well work

[09:14] *** bbkr_ left
[09:14] <pmichaud> since flattening is no longer default-ish,  I suspect we no longer need circumfix [ ] and { } to itemize.

[09:14] <jnthn> means flat [1,2,3], [4,5,6] would have to become flat $[1,2,3], $[4,5,6] ?

[09:14] <pmichaud> jnthn: yes.

[09:14] <jnthn> OK.

[09:15] <pmichaud> although

[09:15] <pmichaud> flat [[1,2,3], [4,5,6]]  wouldn't :-)

[09:16] <pmichaud> indeed, one could expensively itemize anything by just putting it in square brackets.  :)

[09:16] <pmichaud> (and then I guess index to get it back out... but you get the point)

[09:17] <pmichaud> I think I'd be _really_ happy if   [1,2,3]   was exactly the same as  Array.new(1,2,3)   and   my @ = 1,2,3

[09:17] <pmichaud> and same for  the hash constructor

[09:17] <jnthn> It's certainly attractive. :-)

[09:17] *** laouji left
[09:18] <pmichaud> I can't think of a post-GLR instance where we need to have  [1,2,3]  be the same as Array.new(1.2.3).item

[09:18] <nwc10> and also "Quicker, easier, more seductive"?

[09:18] <nwc10> (ie, are there downsides of this?)

[09:18] <pmichaud> nwc10: it makes things simpler and much faster on the implementation side.

[09:19] <nwc10> which is a down side, if the goal is to torture implementors

[09:19] <nwc10> are there down sides for users? :-)

[09:19] <pmichaud> nwc10: I'm trying to think of some... but I've not commonly used [...] or { ... } in my p6 programs so I can't be sure.

[09:20] <pmichaud> surprisingly, having this behavior also means that

[09:20] <pmichaud> my @a = [1,2,3]    # works

[09:21] <pmichaud> my @a = [1,2,3]    # @a has three elements

[09:21] <pmichaud> my @a = [1,2,3],[4,5,6]   # @a has two Array elements

[09:21] <pmichaud> my @a = [1,2,3],    # @a has one Array element

[09:22] <pmichaud> similarly,   my %h = { foo => 'bar' };   # hash assignment

[09:23] <moritz> my @a = [1,2,3] vs my @a = [1,2,3],[4,5,6] looks like a design smell to me

[09:23] <moritz> (one of them flattening, the other not)

[09:23] <pmichaud> it has nothing to do with flattening

[09:23] <moritz> whatever it has to do with, I'd to be the one to document that

[09:23] <pmichaud> it has to do with the first being an Array, and the second being a List of Array

[09:24] <pmichaud> it's the same principle we have now,  where   (1) is an Int but (1,) is a Parcel.

[09:24] <moritz> "to write nested data structures, you can write things like my @a = [1,2,3],[4,5,6]; beware that it only works if you at least two pairs of braces"

[09:24] <pmichaud> it's the comma that does it

[09:24] <pmichaud> not the pairs of braces.

[09:25] <pmichaud> my @a = [1,2,3],4    # @a has two elements

[09:25] <moritz> still a design smell

[09:25] <pmichaud> we have that design smell no matter what

[09:25] <arnsholt> Python does more or less exactly the same thing, FWIW

[09:25] <pmichaud> my @a = (1,2,3)  # how many elements does @a get?

[09:25] <arnsholt> "1," is a single-element tuple, "1" is just the number

[09:25] <moritz> (not saying that the Parcel case right now is any better, but at least the parcel gets flattened away in many cases)

[09:26] <pmichaud> does it?

[09:26] <pmichaud> not any more.  We're getting rid of flattening.

[09:26] <moritz> assignment to array variables still flattens it away

[09:26] <moritz> m: my @a = (1, ); say @a[0].^name

[09:26] <camelia> rakudo-moar 1372f7: OUTPUT«Int␤»

[09:26] <pmichaud> okay, TimToady didn't mention that (as I noted, perhaps an oversight)

[09:27] <pmichaud> m:  my @a = ((1,),1);  say @a[0].WHAT

[09:27] <camelia> rakudo-moar 1372f7: OUTPUT«(Int)␤»

[09:27] <pmichaud> m: say ((1,),1).[0].WHAT

[09:27] <camelia> rakudo-moar 1372f7: OUTPUT«(Parcel)␤»

[09:28] <pmichaud> m:  say ((1,2,3),4).elems

[09:28] <camelia> rakudo-moar 1372f7: OUTPUT«2␤»

[09:29] *** laouji joined
[09:29] <pmichaud> m:  say (my @ = ((1,2,3),4)).elems

[09:29] <camelia> rakudo-moar 1372f7: OUTPUT«4␤»

[09:29] <pmichaud> the whole bit of   list assignment flattens but nowhere else does  feels more smelly to me

[09:30] <pmichaud> and more smelly still if array assignment flattens and list assignment doesn't

[09:30] *** laouji left
[09:31] <pmichaud> m:   say [(1,2),3].elems;  say ((1,2),3).elems

[09:31] <camelia> rakudo-moar 1372f7: OUTPUT«3␤2␤»

[09:32] <jnthn> I'd hope [...] and my @ = ... would have the same flattening semantics.

[09:32] <jnthn> (for the ...)

[09:32] <pmichaud> exactly

[09:33] <pmichaud> and I'm thinking I want "no flattening"

[09:33] <pmichaud> but even here, what are the flattening semantics of   @a = ...   versus   (@a, @b) = ...    ?

[09:33] <pmichaud> or  ($a, $b) = ...   ?

[09:34] *** laouji joined
[09:35] <pmichaud> I mean,   do we ahve the case that   @a = ...    flattens the rhs while   ($a, $b) = ...   doesn't?

[09:35] <pmichaud> if we say that both flatten, then list assignment flattens but constructing a list doesn't ?

[09:35] *** laouji left
[09:36] * moritz is at the point where he wants to get rid of all implict flattening, and have a separate list concatenation operator for when you need flatten

[09:37] <pmichaud> at the moment I really like the notion that  [...]  doesn't itemize.

[09:37] <pmichaud> I can't see where it poses a particular problem.

[09:37] <moritz> and maybe a flattening meta operator, so that you can say  @lista FZ @listb  instead of flat(@lista Z @listb)

[09:38] *** laouji joined
[09:38] <Mouq> What's the biggest difference between […] and (…) then? Mutability?

[09:38] <pmichaud> one constructs an Array

[09:38] <pmichaud> OTOH!!!

[09:39] <Mouq> Right, my question was more like, what's the difference between Array and List

[09:39] <Mouq> or differences

[09:39] <pmichaud> Array elements are all Scalars

[09:39] <moritz> so you can always assign to Array elements

[09:39] <pmichaud> i.e., everything put into an array is itemized

[09:39] <moritz> m: my @a = List.new(1, 2, 3); @a[0] = 5;

[09:39] <camelia> rakudo-moar 1372f7: ( no output )

[09:39] <moritz> m: my @a := List.new(1, 2, 3); @a[0] = 5;

[09:39] <camelia> rakudo-moar 1372f7: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/vZFZm2V3tn:1␤␤»

[09:39] <Mouq> heh

[09:39] <pmichaud> OTOH!!! (again).... if we don't flatten list/array assignment, then    my @a = 1..10;   doesn't work.

[09:39] <moritz> m: my @a := Array.new(1, 2, 3); @a[0] = 5; say @a

[09:39] <camelia> rakudo-moar 1372f7: OUTPUT«5 2 3␤»

[09:40] <Mouq> k, thanks :)

[09:40] *** yeahnoob left
[09:41] <pmichaud> still, I think that flattening is separate from   [...]  being itemized.

[09:41] <moritz> then what's the point of itemizing at all?

[09:42] <FROGGS> can't we allow this?  my @a = |1..10;

[09:42] <pmichaud> sorry, I should say   "flattening of list assignment" is separate from "[...] being itemized"

[09:42] <Mouq> FROGGS: Precedence

[09:42] *** laouji left
[09:42] <pmichaud> FROGGS: we can allow that, but it's got the totally wrong default.

[09:43] <pmichaud> my @a = 1..10;   ought to dwim

[09:43] *** brrt joined
[09:43] <FROGGS> k

[09:43] * FROGGS agrees

[09:44] *** zakharyas joined
[09:44] <pmichaud> moritz: note that when needed, we can still itemize with  prefix-$

[09:44] <pmichaud> i.e., if we needed a non-flattening array, then   $[...]  is always at hand.

[09:44] <pmichaud> and that seems much better to me than   having  [...]<>   which means  "deitemize the itemized array"

[09:45] <pmichaud> also I'd like to note that "flattening" is a little overloaded here... because traditionally we've used "flattening" to do nesting, when in most cases we just need/want one level of flattening.

[09:45] *** laouji joined
[09:46] <moritz> FWIW I'd be fine with 'my @a = 1..10' not DWIMing, if that's the price we pay for a very simple model where it's trivial to explain how to flatten and how not, and that works 100% of all times

[09:46] *** laouji left
[09:46] *** laouji joined
[09:48] <pmichaud> i.e.,   sometimes we want to be able to "flatten"    (1, (2, 3..7)) to become  (1, 2, 3..7) and not   (1, 2, 3, 4, 5, 6 7) 

[09:48] *** FROGGS left
[09:49] <pmichaud> as an example of where we already have the "flattening" smell now:

[09:49] <pmichaud> m:  for (1,2,3) { .say }

[09:49] <camelia> rakudo-moar 1372f7: OUTPUT«1␤2␤3␤»

[09:49] <pmichaud> m:  for (1,2,3), { .say }

[09:49] <camelia> rakudo-moar 1372f7: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/yqAtdgcsfh:1␤------> 3for (1,2,3), { .say }7⏏5<EOL>␤Missing block (apparently taken by expression)␤at /tmp/yqAtdgcsfh:1␤------> 3for (1,2,3), { .say }7⏏5<EOL>…»

[09:49] <pmichaud> m:  for ((1,2,3),) { .say }

[09:49] <camelia> rakudo-moar 1372f7: OUTPUT«1 2 3␤»

[09:49] <pmichaud> m:  for (1,2,3),(4,5,6) { .say }

[09:49] <camelia> rakudo-moar 1372f7: OUTPUT«1 2 3␤4 5 6␤»

[09:51] <pmichaud> afaic, once the decision was made to not flatten parcels by default, that completely changes the implications for itemization.

[09:52] <El_Che> is there a test smoke like tooling/infra for perl 6 implementations (not modules). I only found https://perl6advent.wordpress.com/2013/12/13/day-13-roasting-rakudo-star/ and https://github.com/coke/perl6-roast-data. I am not sure how to set up a useful smoking setup similar like the ones I run for perl5 (or if it's needed/useful)

[09:52] <pmichaud> anyway, it's almost 04h00 here and I had better get some sleep

[09:53] <jnthn> :)

[09:53] <jnthn> Sleep well, pmichaud++

[09:53] *** amurf joined
[09:57] <pmichaud> before I go, I think I should summarize a bit of what I'm toying with / looking for

[09:57] <pmichaud> I'd like to separate our notion of "flattening" into "shallow flat" and "deep flat"

[09:57] *** amurf left
[09:58] <pmichaud> so, with   my @odd = 1, 3, 5;  my @even = 2, 4, 6;

[09:59] <pmichaud> a shallow flat of   (1, (2, (@odd, @even)))   would result in   (1, 2, ((1, 3, 5), (2, 4, 6)))

[09:59] <pmichaud> while a deep flat of  (1, (2, (@odd, @even))) would result in  (1, 2, 1, 3, 5, 2, 4, 6)

[10:00] <pmichaud> i.e., that most of the places we need automatic flattening really only need to be doing it at one level deep

[10:00] *** coffee` left
[10:00] <pmichaud> (slurpy params perhaps being the exception to that.)

[10:01] <Mouq> my @a = 1...10 would still DWIM, yes?

[10:01] <pmichaud> yes

[10:02] <pmichaud> because a shallow flat or deep flat of a range expands it

[10:03] *** coffee` joined
[10:03] <pmichaud> anyway, that's what I'm toying with and the sort of answer that keeps popping up.

[10:04] <pmichaud> but the whole notion of itemizing, scalar containers, and even LoL came from a need to suppress the automatic flattening behavior of Parcels.

[10:04] <pmichaud> Now that Parcels no longer flatten by default, many of the consequences that led to itemization and LoL no longer apply.

[10:05] <pmichaud> more to the point, now that infix:<,> will be creating a List instead of a Parcel, many of the consequences....

[10:05] <pmichaud> anyway, sleep time for sure now

[10:05] <pmichaud> bbl

[10:06] <Mouq> sleep well pmichaud++

[10:07] *** laouji left
[10:07] *** brrt left
[10:07] *** coffee` left
[10:08] <Mouq> m: say (1, 2, ((1, 3, 5), (2, 4, 6))).deepmap({$_}).perl

[10:08] <camelia> rakudo-moar 1372f7: OUTPUT«(1, 2, 1, 3, 5, 2, 4, 6)␤»

[10:09] *** laouji joined
[10:10] <|Tux|> jnthn, https://github.com/Tux/Text-CSV_XS - edit t/55_combi.t and remove the '#' in line 46

[10:10] <|Tux|> that '#' was put there when 124191 came into focus

[10:11] <|Tux|> https://github.com/Tux/CSV of course. the other is perl5

[10:11] <Mouq> A thought, if flattening is split: flat could just be shallow flat and deep flat could be the default case of a bikeshedded version of deepmap

[10:11] *** coffee` joined
[10:11] *** Ven joined
[10:12] <|Tux|> I'll try to create a shortened version

[10:12] <Mouq> m: say (1, 2, ((1, 3, 5), $(2, 4, 6))).deepmap({$_}).perl

[10:12] <camelia> rakudo-moar 1372f7: OUTPUT«(1, 2, 1, 3, 5, $(2, 4, 6))␤»

[10:17] <|Tux|> 124191 is definitely fixed

[10:18] <sergot> wut, what is deepmap?

[10:18] <moritz> it descends into arrays/hashes

[10:20] <moritz> m: say (1, 2, ((1, 3, 5), $(2, 4, 6))).deepmap(* * 3).perl

[10:20] <camelia> rakudo-moar 1372f7: OUTPUT«(3, 6, 3, 9, 15, 9)␤»

[10:21] <jnthn> |Tux|: Good; it took some doing. :)

[10:21] * jnthn is currently working on RT #124318, which is also mysterious

[10:22] <Mouq> I'm a little surprised it doesn't retain structure, honestly. I think there's a function that does

[10:22] * |Tux| tries to make reproducing the segfault a bit smaller

[10:22] <Mouq> m: say ((1, 2, ((1, 3, 5), $(2, 4, 6))) »*» 3).perl

[10:22] <camelia> rakudo-moar 1372f7: OUTPUT«(3, 6, ((3, 9, 15), $(6, 12, 18)))␤»

[10:23] *** araujo__ left
[10:23] *** araujo joined
[10:23] *** araujo left
[10:23] *** araujo joined
[10:27] *** _mg_ left
[10:35] *** bowtie joined
[10:35] *** telex left
[10:35] *** bowtie is now known as Guest85966

[10:36] *** telex joined
[10:38] <|Tux|> jnthn, https://gist.github.com/Tux/08b2083d9eaff31d8bc6

[10:38] <|Tux|> that makes the segfault go away. It must be a hint :)

[10:41] <|Tux|> FWIW it doesn't matter if the match is correct or not

[10:41] *** dayangkun left
[10:43] *** bin_005 left
[10:46] <dalek> nqp: bf329da | jnthn++ | tools/build/MOAR_REVISION:

[10:46] <dalek> nqp: Bump MOAR_REVISION for new frame return API.

[10:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bf329da9d1

[10:46] *** AlexDaniel joined
[10:50] <dalek> rakudo/nom: 24c39ea | jnthn++ | / (2 files):

[10:50] <dalek> rakudo/nom: Don't run exit handlers on fake frames.

[10:50] <dalek> rakudo/nom: 

[10:50] <dalek> rakudo/nom: When we are seeing if a multi can pass the bind check, we create a

[10:50] <dalek> rakudo/nom: frame to hold lexicals used in the binding checking. This frame is

[10:50] <dalek> rakudo/nom: never actually entered and not fully set up, however. If the block in

[10:50] <dalek> rakudo/nom: question had exit handlers, we would end up looking at uninitialized

[10:50] <dalek> rakudo/nom: memory in trying to run them, which led to all kinds of oddness when

[10:50] <dalek> rakudo/nom: a frame with exit handlers (LEAVE, temp, etc.) had a signature with

[10:50] <dalek> rakudo/nom: where constraints. Fixes RT #124318.

[10:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24c39eab2b

[10:50] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124318

[10:51] <jnthn> Turns out it wasn't an optimization bug at all like the ticket suggested, and Valgrind whined if you got rid of the loop

[10:51] <jnthn> *even if

[10:54] <arnsholt> jnthn: A QAST/HLL::Grammar question: Is there a mechanism for an infix:sym<foo> that wants to create a QAST::Op.new(:op<not>, QAST::Op.new(:op<foo>, $lhs, $rhs))?

[10:55] <arnsholt> If the infix makes a negated foo as its AST, the arguments end up as arguments to the not, not the foo =(

[10:55] <jnthn> arnsholt: Not really; we tend to handle such things in Rakudo using a custom EXPR

[10:55] <jnthn> arnsholt: EXPR action method, I mean

[10:56] *** tinyblak left
[10:56] <arnsholt> Yeah, that's what I thought. Cheers!

[10:57] <dalek> roast: aceeb7c | jnthn++ | integration/weird-errors.t:

[10:57] <dalek> roast: Untodo test for RT #123686 & RT #124318.

[10:57] <dalek> roast: review: https://github.com/perl6/roast/commit/aceeb7c274

[10:57] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123686

[10:59] *** llfourn left
[11:01] *** llfourn joined
[11:10] <|Tux|> jnthn, no more segfault, but the tests start failing halfway when using ~~

[11:11] *** Sqirrel left
[11:11] *** zakharyas left
[11:15] <|Tux|>         is (%state{1001}, "INI - separator is equal to quote- or escape sequence", "Illegal combo 1001");

[11:15] <|Tux|>         %state{1001} ~~ m{"separator is equal to"} or die %state{1001};

[11:15] <|Tux|> if I comment out the second line, all is well. If I have that ~~ in there, it dies

[11:15] <|Tux|> INI - separator is equal to quote- or escape sequence

[11:15] <|Tux|>   in sub combi at t/55_combi.t:48

[11:16] <|Tux|> and the content is correct! so the ~~ fails

[11:17] <|Tux|> The 258'th ~~ fails

[11:23] <timotimo> o/

[11:25] *** smls joined
[11:25] <smls> o/

[11:25] <smls> In case someone else finds it useful:

[11:25] <smls> https://addons.mozilla.org/en-US/firefox/addon/perl-6-synopses/

[11:25] <smls> https://addons.mozilla.org/en-US/firefox/addon/perl-6-doc/

[11:26] <smls> Only does a simple google site search

[11:26] <smls> but the advantage is that you can assign a shortcut to it in firefox

[11:27] <smls> So if you addign the "p6" search shortcut to the p6 doc addon, you can simply type "p6 substr" [ENTER] in the address bar to search it.

[11:27] <smls> *assign

[11:30] <sergot> thanks moritz++

[11:30] *** llfourn left
[11:31] *** mr-foobar left
[11:32] *** mr-foobar joined
[11:32] <|Tux|> jnthn, or whoever liker to dig into *weird* failures:

[11:32] <|Tux|> https://gist.github.com/Tux/e85a53243c7bab63858d

[11:33] <|Tux|> adding that warn line makes the die line pass

[11:33] <|Tux|> remove the warn line and it dies the 258'th time that match is done

[11:38] *** FROGGS joined
[11:38] <masak> did someone say weird failures? :P

[11:41] <jnthn> masak: golf plz :P

[11:42] *** amurf joined
[11:43] *** llfourn joined
[11:43] *** _mg_ joined
[11:47] *** amurf left
[11:50] *** Ven left
[11:56] *** tinyblak joined
[12:01] *** Ven joined
[12:02] *** Sqirrel joined
[12:02] *** Ven left
[12:02] *** domidumont left
[12:18] *** Sqirrel left
[12:23] *** domidumont joined
[12:30] <jnthn> |Tux|: Got the SEGV reproduced locally

[12:30] <smls> Inside a grammar, can I get at the filename of the file passed to Grammar.parsefile ?

[12:30] *** silug left
[12:30] <jnthn> No, we don't keep it around anywhere

[12:30] <smls> so I can include it in an error message

[12:31] <jnthn> You could easily method parsefile($*FILENAME) { nextsame() } though

[12:31] <jnthn> And then it's available in $*FILENAME

[12:32] <jnthn> (or whatever name you prefer)

[12:32] <smls> interesting

[12:32] <smls> I guess I could also simply have  { die "invalid line '$/'" }  inside the grammar, and then have a CATCH {} in the scope where I call MyGrammar.parsefile to add the filename anddie for real

[12:32] <smls> right?

[12:33] <timotimo> jnthn: and this is where we're actually happy that keyword arguments get silently accepted by methods! :)

[12:33] <jnthn> smls: Yes, that's also possible

[12:34] <jnthn> |Tux|: Seems it's something weird this time though...even if I disable dynamic opt it fails 392 tests.

[12:36] *** Ven joined
[12:36] <smls> m: (grammar {token TOP { {fail "ooops"} }}).parse("aaa") // say "Failed"

[12:36] <camelia> rakudo-moar 24c39e: OUTPUT«Failed␤»

[12:36] <smls> looks like it even workswith fail :)

[12:37] <smls> although then I can't get at the failure message anymore, right?

[12:37] <timotimo> in that case you can use "orelse"

[12:38] <timotimo> m: (grammar {token TOP { {fail "ooops"} }}).parse("aaa") // say "Failed: $_"

[12:38] <camelia> rakudo-moar 24c39e: OUTPUT«Use of uninitialized value $_ of type Any in string context  in block <unit> at /tmp/7Xa09UnFCM:1␤Failed: ␤»

[12:38] <timotimo> m: (grammar {token TOP { {fail "ooops"} }}).parse("aaa") orelse say "Failed: $_"

[12:38] <camelia> rakudo-moar 24c39e: OUTPUT«Use of uninitialized value $_ of type Any in string context  in block <unit> at /tmp/Uh4G_hHE56:1␤Failed: ␤»

[12:38] <timotimo> m: (grammar {token TOP { {fail "ooops"} }}).parse("aaa") orelse say "Failed: $!"

[12:38] <camelia> rakudo-moar 24c39e: OUTPUT«Use of Nil in string context  in block <unit> at /tmp/x87a9Bbqdd:1␤Failed: ␤»

[12:38] <timotimo> except not

[12:38] <jnthn> uh, I don't think fail will work out too well deep in the grammar though

[12:38] <smls> ok

[12:42] <jnthn> |Tux|: When I say the string in question, it comes out as "INI - separator is equal to quote- or escape sequence", which doesn't match the regex m{"sep_char is equal to"}

[12:43] *** Ven left
[12:44] <jnthn> |Tux|: Making the line 'ok (%state{1001} ~~ m{"separator is equal to"}, "Illegal combo 1001");' passes all the tests

[12:45] *** silug joined
[12:46] <dalek> rakudo-star-daily: 989da10 | coke++ | log/ (2 files):

[12:46] <dalek> rakudo-star-daily: today (automated commit)

[12:46] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/989da10e83

[12:47] <jnthn> |Tux|: Ah, but then when I swtich dynopt back on again I see issues.

[12:47] <RabidGravy> does NativeCall have a way of checking whether a shared library exists without creating a binding and trying to use it?

[12:48] <timotimo> i'd also like something to exist that sets up native subs "up front"

[12:49] <jnthn> RabidGravy: Not that I'm aware of

[12:49] <timotimo> but there's still more or less a rewrite of the "internals" of NativeCall on the horizon

[12:50] <smls> sigspace is driving me crazy: http://i.imgur.com/SVb2A3q.png

[12:52] <jnthn> Well, I suspect a lot will stay the same, it's mostly that we need to do something to let us JIT native calls in a good way

[12:52] <arnsholt> smls: What does the comment rule look like?

[12:52] <smls> token comment { '//' .*? $$ }

[12:53] <smls> token ws { \h* }

[12:53] <RabidGravy> jnthn, would it possible then for it to throw different exceptions for "Cannot locate symbol" and "Cannot locate native library" ?

[12:54] <jnthn> smls: I see no "rule" there?

[12:54] <arnsholt> smls: That shouldn't trigger ws at all, though. token doesn't give sigspace

[12:54] <jnthn> RabidGravy: Hm, they don't already?

[12:54] <smls> right, the comment was a rule

[12:54] <smls> TOP too

[12:54] <smls> change them to tokens currently to regain sanity :P

[12:54] <arnsholt> But The rule you want is probably along the lines of "token comment { '//' \N* }"

[12:54] <RabidGravy> well in the sense they have a different message, but both are X::AdHoc

[12:55] <jnthn> I was gonna say, why does comment even want to be a rule there

[12:55] <jnthn> RabidGravy: ah, you wnat different types...

[12:55] <jnthn> RabidGravy: Reasonable request; should be do-able

[12:56] <FROGGS> El_Che: I'd like to see that we submit spectest reports to testers.perl6.org fwiw

[13:00] <RabidGravy> jnthn, yeah so I can do something like nicely

[13:00] <RabidGravy> m: use NativeCall; sub foo() is native('libxndfile') { * }; try { foo(); CATCH { default { say $_.perl; } } }

[13:00] <camelia> rakudo-moar 24c39e: OUTPUT«X::AdHoc.new(payload => "Cannot locate native library 'libxndfile.so': libxndfile.so: cannot open shared object file: No such file or directory")␤»

[13:02] *** domidumont left
[13:03] *** domidumont joined
[13:11] *** brrt joined
[13:12] <hoelzro> [ptc]: so far looks good, but I'm concerned about the testing script.  Shouldn't we use panda-test instead?

[13:12] <hoelzro> since some things have a Build.pm that does some custom things?

[13:15] *** yqt joined
[13:16] *** g4 left
[13:18] *** skids joined
[13:18] *** dayangkun joined
[13:19] *** dayangkun left
[13:19] *** xinming left
[13:19] *** dayangkun joined
[13:19] <hoelzro> is anyone here going to the Swiss Perl Workshop in August?

[13:20] <jnthn> hoelzro: yes

[13:20] <hoelzro> \o/

[13:20] <FROGGS> hoelzro: yes

[13:20] <hoelzro> \o/

[13:20] <FROGGS> :D

[13:20] *** xinming joined
[13:20] <hoelzro> with the hackathon happening, I figured as much

[13:21] <jnthn> |Tux|: So far I've managed to golf it to something not involving Text::CSV :)

[13:21] *** ZoffixWork joined
[13:21] <hoelzro> I'm buying my flight right now

[13:22] *** laouji left
[13:22] <ZoffixWork> FYI: http://modules.perl6.org/ doesn't have anything listed on it. Failing list generation? I don't see any commits made from the time when I know it was definitely behaving fine, so I'm assuming it's not the code that's the problem.

[13:23] <masak> hoelzro: yes

[13:23] <ZoffixWork> Is it possible for it to choke on invalid JSON in META.info? 'cause I spotted an extra comma in perl6-ANTLR4, which was recently added to the ecosystem.

[13:23] <hoelzro> more \o/

[13:24] <itz>  http://modules.perl6.org/ is fairly minimal JSON :)

[13:24] <itz> oops

[13:24] <masak> ZoffixWork: if it's possible for it to choke, then we should probably put a `try` statement somewhere...

[13:24] <itz>  http://modules.perl6.org/proto.json

[13:24] * ZoffixWork checks the code

[13:25] <ZoffixWork> OK, false alarm. It works now :)

[13:25] <ZoffixWork> I guess I came to the site right in the process of it generating the updated list or something :P

[13:25] *** Ven joined
[13:26] <itz> maybe it should generate a new json file and mv it atomically when complete

[13:26] <El_Che> FROGGS: I was preparing an sparc x86 vm for perl5 smoke testing and I was curious how perl6 implementation would run on "exotic" setups. However, I haven't find much to setup such environment 

[13:27] <FROGGS> El_Che: yeah, we have to do that soonish I think

[13:28] <El_Che> If I may step on some toes while giving kudos for the results, I found test smoke for perl5 a real pita to setup

[13:28] <El_Che> (writing the config file felt like assembler)

[13:29] <ZoffixWork> It's only 158KB. I doubt my initial guess about generating new files is correct. Oh well, works now.

[13:30] * ZoffixWork makes motions of sweeping stuff under the rug

[13:31] <El_Che> (for the record: once setup the smoke works fine on autopilot)

[13:38] <llfourn> How do you do the use MyDynamicExporter 'some_method'; some_method(); -- patern that is used a lot in perl5?

[13:39] <llfourn> where the arguments to import() end up being created via *$dyanimc_name = sub { } 

[13:40] <llfourn> or *{"${caller}::dynamic_name}"} = sub {} rather 

[13:40] <llfourn> I guess I have to get caller in same way come to think of it..

[13:42] *** cdc is now known as cdc_le_co-corse

[13:44] *** cdc_le_co-corse is now known as cdc

[13:46] <jnthn> you write an EXPORT sub in the module that receives the arguments and returns a hash of symbols to install

[13:47] <llfourn> ahh is that what this is about: &EXPORT sub did not return an EnumMap

[13:47] <llfourn> awesome thanks

[13:47] *** ab6tract joined
[13:48] <ab6tract> o/ #perl6

[13:49] <ab6tract> I've been backlogging and felt compelled to say that anything like having a trailing comma change the semantics of list creation would be a horrible thing to do to anyone

[13:49] <brrt> y

[13:49] <brrt> why

[13:50] <brrt> a trailing comma may easily change the semantics of an english sentence,

[13:50] <ab6tract> because it is the classic 'change a tiny detail in a Perl script  and have everything change'

[13:50] <ab6tract> scenario

[13:50] <brrt> well, we operate in a field where tiny details change everything

[13:51] <brrt> did not know the argument for changing the semantics, just arguing that it can be reasonable

[13:51] *** tinyblak left
[13:51] *** tinyblak joined
[13:54] <ab6tract> brrt: trailing commas are a classic perl-ism

[13:54] <ab6tract> to have @a = [1,2,3] be different than @a = [1,2,3], 

[13:54] <ab6tract> ... what can I say, it's the kind of choice that would drive many away from considering the language

[13:54] <ab6tract> including me, depending on how the rest of the GLR settles

[13:57] *** _mg_ left
[13:57] <smls> ooh, interesting backlog

[13:58] <smls> "no longer need circumfix [ ] and { } to itemize"  does indeed sound interesting

[13:58] <smls> but I don;t see how it would have those consequences that pmichaud lists (and ab6tract complains about)

[13:58] <smls> "my @a = [1,2,3],[4,5,6]   # @a has two Array elements"

[13:59] *** JimmyZ_ joined
[13:59] <smls> ^^since list assignment has flattening *@slurpy semantics for the RHS, that would actually be 6 elements, no?

[13:59] <smls> also,  "my @a = [1,2,3]"  and  "my @a = [1,2,3],"  would still be the same, as both would get flattened by the slurpy

[14:00] <ab6tract> smls: IIUC, pmichaud++ was basing that off of TimToady omitting/forgetting 'list assignment' in his list of flatteners

[14:00] <RabidGravy> m: my $f = Sub.new(); say $f

[14:00] <camelia> rakudo-moar 24c39e: OUTPUT«(signal SEGV)»

[14:00] <RabidGravy> m: my $f = Sub.new(); # is fine

[14:00] <camelia> rakudo-moar 24c39e: ( no output )

[14:00] <smls> I hope it's just forgetting :P

[14:01] <ab6tract> me too

[14:02] *** Ven left
[14:04] <ab6tract> brrt: wrt tiny changes big impact, that is not a very good argument against making sure that those tiny changes are explicit, loud, unignorable

[14:04] <ab6tract> With great expressitivity comes greater responsibility

[14:05] <itz> y $f

[14:05] <itz> oops

[14:05] <itz> https://github.com/perl6/modules.perl6.org/pull/9 

[14:06] <ab6tract> And ignoring our own languages' reputation for obscure corner cases will surely doom us

[14:07] <itz> ^^ that should fix the modules.perl6.org issue just seen

[14:08] <dalek> modules.perl6.org: ab616e1 | (Steve Mynott)++ | web/lib/P6Project.pm:

[14:08] <dalek> modules.perl6.org: make write_file atomic so partial or empty files are never in place

[14:08] <dalek> modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/ab616e172f

[14:08] <dalek> modules.perl6.org: 542e334 | ab5tract++ | web/lib/P6Project.pm:

[14:08] <dalek> modules.perl6.org: Merge pull request #9 from stmuk/stmuk

[14:08] <dalek> modules.perl6.org: 

[14:08] <dalek> modules.perl6.org: make write_file atomic so partial or empty files are never in place as probably happened  http://irclog.perlgeek.de/perl6/2015-06-10#i_10729972

[14:08] <dalek> modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/542e334334

[14:11] <RabidGravy> just rt'd that segv as #125376

[14:11] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125376

[14:14] * smls is also confused about pmichaud statement that "flat [[1,2,3], [4,5,6]]  wouldn't" have to be rewritten if [] were non-itemizing. Will flat no longer be recursive?

[14:15] <[ptc]> hoelzro: haven't heard of panda-test before, will have to look into it

[14:16] <[ptc]> hoelzro: I'm thinking that things are going to change a bit after people start using Travis for Perl 6 projects

[14:17] <[ptc]> hoelzro: I had `make test` in the build script beforehand and was thinking while writing the docs: hmm, don't think everyone's likely to do that :-)

[14:18] <[ptc]> hoelzro: was also wondering about using `ufo` to generate a Makefile like EUMM does, but haven't yet been able to get ufo to work on my system...

[14:19] <RabidGravy> is there another way of creating a named sub with a name chosen at run-time that doing an EVAL?

[14:20] <hoelzro> [ptc]: yeah, I think that using the tools that panda ships is the way to go (for now)

[14:21] *** dayangkun left
[14:23] *** Ven joined
[14:25] <llfourn> RabidGravy: You can make a sub like my $foo = sub {...}; $foo.set_name('foo');

[14:26] <llfourn> that won't declare the symbol in the current lexical scope though

[14:27] <llfourn> methods you can do with $obj.add_method

[14:27] <llfourn> I'm still in the process of figuring these things out

[14:29] <llfourn> m: my &Foo = sub { say "win" }; Foo();

[14:29] <camelia> rakudo-moar 24c39e: OUTPUT«win␤»

[14:29] <llfourn> oh that works ^^ :D

[14:30] *** Ven left
[14:32] *** andreoss joined
[14:35] <moritz> m: my $name = 'thing'; my $sub = anon sub ::($name) () { say 'win' }; $sub(); say $sub.name

[14:35] <camelia> rakudo-moar 24c39e: OUTPUT«===SORRY!===␤Name ::($name) is not compile-time known, and can not serve as a sub declaration␤»

[14:35] <psch> m: sub f($name, &code) { &OUTER::('&' ~ $name) = &code }; f("foo", sub { say "bar" }); foo # similarly forbidden

[14:35] <camelia> rakudo-moar 24c39e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/evaTssJ8Wc␤Undeclared routine:␤    foo used at line 1␤␤»

[14:35] <moritz> too bad :/

[14:35] <psch> ISTR jnthn was against something like that because of opts..?

[14:35] <moritz> psch: also if you use &OUTER::, it already has one &, so you don't need '&' ~ $name

[14:36] <psch> oh, right

[14:36] <psch> well, doesn't make it work :)

[14:36] <moritz> yes, you can't add to lexpads at run time

[14:36] <moritz> which is great, because it means we can use numbers instead of names for lexpad entries in compiled code

[14:37] <RabidGravy> I'm going with the EVAL for the time being

[14:37] <moritz> also it allows us to catch undeclared names at compile time (which is a much bigger reason)

[14:39] *** Ven joined
[14:40] <lizmat> m: say $*KERNEL.bits   # http://irclog.perlgeek.de/perl6/2015-06-10#i_10728514   RabidGravy

[14:40] <camelia> rakudo-moar 24c39e: OUTPUT«64␤»

[14:41] <RabidGravy> lizmat++ # perfect

[14:42] <RabidGravy> I had actually seen that but instantly forgotten clearly

[14:43] <psch> i remember the opt reason was actually about binding

[14:43] <psch> e.g. «sub f { ... }; &(

[14:43] <[Coke]> hoelzro: (SPW) possibly.

[14:43] <psch> e.g. «sub f { ... }; &('f') := sub { #`[ do things ] }

[14:43] <psch> »

[14:43] <psch> it might be workable for stubs, but sets bad expectations

[14:44] <psch> and for actual subs it breaks at least inlining, i suppose

[14:44] <hoelzro> [Coke]: cool

[14:44] <psch> (plus the missing ::, too)

[14:45] *** Ven left
[14:47] *** msouth joined
[14:47] *** cognominal left
[14:48] *** Ven joined
[14:48] <psch> "java.lang.RuntimeException: Unknown container config rakudo_scalar"

[14:48] <psch> humm

[14:49] <psch> that points me at lack of understanding of CUs

[14:50] <pmichaud> (trailing comma)  we already have the case that a trailing comma changes the meaning of things

[14:50] <pmichaud> (1,)  versus (1) has been a part of Perl 6 for a long time.

[14:52] *** MilkmanDan left
[14:53] *** Ven left
[14:53] <msouth> Is it a known thing that this:  my $a=11; my $b:=$a; $b=12; say $b.WHAT  gives (Mu) in the REPL in version 2015.03 ?

[14:54] <jnthn> I know I fixed something related to binding and the REPL and it was probably more recent than that.

[14:54] <msouth> ok

[14:55] <psch> #122914 was close on april 20th, jnthn++

[14:55] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=122914

[14:55] <msouth> I have some pastebin'd reproductions:  http://paste.scsys.co.uk/487896 http://paste.scsys.co.uk/487897 http://paste.scsys.co.uk/487898

[14:55] <msouth> if that's useful for a regression test or whatever

[14:55] <pmichaud> unfortunately, 2015-03 is the latest .msi we have available and several people were using that at last night's tutorial

[14:55] <jnthn> pmichaud: Ah

[14:55] <msouth> yeah I got mine from homebrew on OS X

[14:56] *** MilkmanDan joined
[14:56] <pmichaud> so that particular part of the tutorial failed for quite a few people

[14:57] *** tinyblak left
[14:57] *** tinyblak joined
[14:57] <ab6tract> pmichaud: still not very convincing. that's bothered me before, and I just assumed it would be cleaned up in GLR

[14:57] <ab6tract> I guess I've just been piling "don't like this about lists, must be going away" into a specific bucket

[14:58] <pmichaud> ab6tract: sadly it often doesn't work that way.

[14:58] <pmichaud> that said, trailing commas are currently quite rare, and I don't think my trailing comma example from last night would end up being a common thing either.

[14:59] <pmichaud> we've seen over and over that most people's natural expectation of

[14:59] <pmichaud> my @a = [1,2,3];   

[14:59] <pmichaud> is that @a ends up with three elements.  I mean, it looks like an array assignment

[14:59] <tadzik> computer, messages

[14:59] <yoleaux> 08:51Z <[ptc]> tadzik: could you review https://github.com/tadzik/rakudobrew/pull/42 when you get time please?  It allows matching Rakudo/panda versions to be installed on Travis

[14:59] <ab6tract> true

[15:01] <ab6tract> however, it seems like "[ ]" is always an item is a much easier rule to remember

[15:01] <ab6tract> than "[ ]" is only an item in list context

[15:02] <ab6tract> that sounds like the howling of zombie camels

[15:02] <pmichaud> the whole notion of "[ ] is always an item" came out of the need for a way to suppress flattening in the majority of contexts

[15:02] <pmichaud> because flattening was so much a default part of perl 6 behavior

[15:02] <tadzik> [ptc]: done, thanks a lot!

[15:02] <pmichaud> that's no longer true.  flattening is now the exception, not the rule.

[15:02] *** lizmat left
[15:03] *** brrt left
[15:03] <pmichaud> Prior to 2010, we didn't have a notion of "item context"

[15:03] <|Tux|> jnthn++; # I was not paying attention due to $work activities

[15:03] <|Tux|> sorry to keep throwing these more complicated bugs at you

[15:03] <pmichaud> at least not one that manifested itself the way it does now

[15:03] <jnthn> |Tux|: Well, I'd rather have them now than later...

[15:03] <pmichaud> perhaps an example is good here:

[15:04] <pmichaud>     for  [1,2,3], (4,5,6) { .say }      # how many iterations?

[15:04] <jnthn> |Tux|: I've got it down to a script that doesn't involve any modules now, and to a specific optimization; unfortunately it's a very widely applied one that's probably going on wrong info, so it's still going to take some hunting.

[15:05] <|Tux|> good luck hunting

[15:06] <|Tux|> I found it *very* strange that adding the same match made all tests pass

[15:06] *** lizmat joined
[15:07] <jnthn> |Tux|: Yeah; in the end I got it down to https://gist.github.com/jnthn/cff4c17fcc6d7bd2ece3 but even trying to remove one of the remaining conditionals makes the bug go away.

[15:07] *** Ven joined
[15:08] <|Tux|> O, wow, that is golfed down indeed!

[15:08] *** Ven left
[15:09] <grondilu> m: for False, True -> $b { .say }

[15:09] <camelia> rakudo-moar 24c39e: OUTPUT«(Any)␤(Any)␤»

[15:09] <grondilu> m: for False, True -> $b { say $b }

[15:09] <camelia> rakudo-moar 24c39e: OUTPUT«False␤True␤»

[15:09] * grondilu was wondering if the parens were necessary in https://gist.github.com/jnthn/cff4c17fcc6d7bd2ece3

[15:12] <[ptc]> tadzik: sweet!  Thank you!

[15:19] *** msouth left
[15:19] <ab6tract> pmichaud: well, if you keep [] stable as item-always

[15:19] <ab6tract> then the answer is quite clear

[15:19] <pmichaud> is it?

[15:19] *** tinyblak left
[15:19] <ab6tract> yes, it is a single item

[15:20] <pmichaud>     for  [1,2,3], (4,5,6) { .say }      # how many iterations?

[15:20] <ab6tract> it's only when you start switching behaviors based on context that things get terrible

[15:20] *** tinyblak joined
[15:20] <TimToady> well, for doesn't flatten, so that would stay 2 iterations in any case

[15:20] <pmichaud> right... so what's the difference between the [] and the () here ?

[15:20] *** amurf joined
[15:20] <TimToady> as I understand the proposal without actually backlogging, [] just makes an Array, instead of a List

[15:20] <ab6tract> apparently nothing, except some future mugs hitting future walls

[15:21] <TimToady> much like :{} makes Hash[Any,Any] rather than Hash[Any]

[15:21] <pmichaud> TimToady: the proposal is that [] produces an Array, not an itemized array

[15:21] <TimToady> yes, I got that

[15:21] <TimToady> I'm saying that would be all the difference there is

[15:21] <TimToady> O(Array/List)

[15:21] <TimToady> s/O//

[15:22] <TimToady> it's still meaningful, but only in creating assignable elems

[15:23] <pmichaud> somehow I'm not really following this answer.  :-/

[15:24] <TimToady> my $a1 := [1,2,3]; $a1[2] = 'works'; my $a2 := (1,2,3); $a2[2] = 'fails'

[15:24] <jnthn> Did TimToady just mean that [...] creates something with assignable elems (Array) and ...,... creates a List which doesn't?

[15:24] <pmichaud> jnthn: okay, that helps clarify part of it :)

[15:25] *** amurf left
[15:25] <TimToady> but your proposal as I understand it would be to strip the Scalar from around Array

[15:25] <TimToady> when you make a [] one

[15:25] <pmichaud> "not strip the scalar", but rather "don't add one"

[15:25] <pmichaud> er

[15:25] <pmichaud> not "strip the scalar", rather "don't add one"

[15:26] <TimToady> well, sure, I meant "strip" metaphorically

[15:26] <pmichaud> just making sure  :)

[15:26] *** diana_olhovik left
[15:26] <pmichaud> yes, I'm proposing that  []  simply be an Array constructor, not an itemized-Array constructor.

[15:26] *** msouth joined
[15:26] <pmichaud> s/proposing/exploring/ may be better

[15:27] <pmichaud> and same for {...}  as a Hash constructor

[15:27] <dalek> ecosystem: 7b56c97 | RabidGravy++ | META.list:

[15:27] <dalek> ecosystem: Add LibraryCheck to ecosystem

[15:27] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/7b56c97e47

[15:28] <RabidGravy> filthy hack but someone had to do it

[15:28] <TimToady> but we'd probably have to make my @a = [],[]...oh, that's where you're proposing a shallow flatten?

[15:28] <pmichaud> right

[15:28] <TimToady> hafta think about that

[15:28] <pmichaud> it's just now awkward to talk about "item context" when the only place that does flattening is array assignment and slurpies

[15:28] <pmichaud> I noticed this very quickly in last night's tutorial

[15:29] <TimToady> nodnod

[15:29] <pmichaud> since parcels no longer flatten

[15:29] <hoelzro> is open('-', :r) re-opening standard input spec'd behavior, or a Rakudo-specific detail? the only mention I see of it behaving this way in the spec is in command line processing

[15:29] *** spintronic joined
[15:30] *** dwarring left
[15:30] <TimToady> I think I wouldn't call it "shallow flattening"

[15:30] <pmichaud> hoelzro:  using '-' to represent standard input is pretty standard , so I'm guessing it's designed behavior

[15:30] <pmichaud> I agree, I don't like the name "shallow flattening"

[15:30] <hoelzro> pmichaud: for a command tool, that makes sense, but for the open() function?

[15:30] <pmichaud> I just needed a placeholder to talk about interpolation that isn't a deep interpolation

[15:30] <TimToady> in the proposed "for $array {}" I'd rather think of it as "for takes one argument which is coerced to give an iterator"

[15:30] <hoelzro> granted, not a lot of people have files named '-', but those reasons

[15:31] <TimToady> so "my @array = $array" could be the same story

[15:31] <pmichaud> TimToady: hmmm.

[15:32] <TimToady> it's one argument, which might have commas in it, but if not, the single item is iterted

[15:32] <TimToady> *rat

[15:33] <TimToady> so "for $a,$b" iterates twice, guaranteed

[15:33] <pmichaud> even under that way of thinking about it, it doesn't seem that [] needs to be an itemized array

[15:33] <TimToady> but "for $something {}" depends on the elems of $something

[15:33] <pmichaud> a bare array works just the same

[15:34] <TimToady> I wasn't proposing that [] be itemized

[15:34] <pmichaud> okay

[15:34] <TimToady> I'm exploring :)

[15:34] <pmichaud> here in Perl 6 land we've gotten so used to thinking about "item context" that now it's odd to go back to perhaps not needing it :)

[15:35] <pmichaud> s/item context/itemized values/

[15:35] <TimToady> so "for 42 {}" still listifies to a single elem

[15:36] <pmichaud> I still tend to think of that as being the same as    (42).map({})

[15:36] <pmichaud> but it amounts to the same thing... the automatic treating of scalars like lists in response to list-y methods

[15:36] <skids> As long as we can say "look for a top-level comma, if it ain't there, behavior is different" the single-item case is at least explainable IMO.

[15:37] <pmichaud> I don't like the "behavior is different" part of that phrasing.  I'm not seeing a difference in behavior.

[15:37] *** tinyblak left
[15:37] <TimToady> it's consistently "ask the top-level thing for its list"

[15:37] *** tinyblak joined
[15:37] <TimToady> just when there's commas, the top-level thing is already a list

[15:38] <skids> Well, you don't see it because you aren't looking at [],[] as "two []s" and "[]" as "one []", naively.

[15:38] <pmichaud> [],[] is a list of two arrays

[15:38] <pmichaud> [] is a single array

[15:38] <skids> Yes you know that, newbies it is "two []s"

[15:38] <TimToady> just like @foo,@br

[15:38] <pmichaud> if I iterate a list of two arrays, I get two iterations

[15:38] <pmichaud> if i iterate a single array, I get iterations for each element of the array

[15:39] <pmichaud> or, phrased another way

[15:39] <pmichaud> if I iterate a list of two arrays, I get two iterations.  if I iterate an array of $n elements, I get $n iterations

[15:39] <pmichaud> it's not "difference in behavior" at all.

[15:40] <TimToady> I do suspect there's more gotchas from teh viewpoint of a P5 programmer though

[15:41] <pmichaud> maybe.  I'm not yet convinced of that.

[15:41] <pmichaud> If we treat prefix-$ as being the "don't interpolate" thingy, p5'ers might be okay with that

[15:41] *** tinyblak_ joined
[15:42] <pmichaud> because it looks a lot like an arrayref

[15:42] <TimToady> it does fit on a deep level with the referential simplification that the context determines the deref

[15:42] <pmichaud> my @a = $[1,2,3];   #  @a has one element

[15:42] <TimToady> so 'for' is just another kind of .[] thingy

[15:42] <pmichaud> my @a = [1,2,3];   # @a has three elements

[15:43] <pmichaud> or put another way, perhaps at this point we're going to have gotchas from P5 viewpoint no matter what we do

[15:43] <TimToady> well, but if you do that to [], you have to do it to $ either, so going back to using $ for pseudo-itemization is a problem

[15:43] <TimToady> s/either/too/

[15:43] <TimToady> seems to me

[15:44] <pmichaud> well, mainly because you're thinking of    my @a = $s;   iterates $s

[15:44] <TimToady> maybe $ could still imply Scalar, I dunno

[15:44] <pmichaud> I hadn't looked at it that way.

[15:44] <pmichaud> I was still thinking that   my @a = $s;    would give @a a single element, even if $s is iterable

[15:45] *** tinyblak left
[15:45] <TimToady> but you were asking for 'for $s' to iterate the other day, which is the same thing

[15:45] <pmichaud> not really

[15:45] <pmichaud> for me,  'for $s'  is like $s.map

[15:46] <pmichaud> and in that case, the item/scalarness doesn't apply.

[15:46] <TimToady> well, if you dig deep enough, list assignment is also mapping input values into individual assignments

[15:47] <TimToady> though not perhaps with an explicit .map

[15:48] <pmichaud> yeah, the idea of list assignment being map-like or for-like hadn't crossed my mind

[15:48] <pmichaud> there is historical basis for list assignment being iteration-y, though... I just hadn't ever made a connection.

[15:48] <pmichaud> not sure a connection should be made :)

[15:51] <pmichaud> now I'm curious about the meaning of something like    (@a, @b) = @b, @a

[15:52] *** daxim joined
[15:52] *** tinybla__ joined
[15:53] *** tinyblak_ left
[15:54] <pmichaud> and we do need to deal with / consider the flattening behavior of .[ ]  as well

[15:54] *** lizmat left
[15:54] <pmichaud> it's analogue-ish to the [ ]   array constructor, I suspect

[15:55] <daxim> what's the equivalent of naked readline/implicit open on stdin?  https://encrypted.google.com/search?q=site:docs.perl6.org+stdin gives me no results

[15:55] <hoelzro> daxim: get or lines

[15:56] <smls> Would it be so bad to have to use $ to construct an AoA?   @a = $[1, 3], $[2, 4]

[15:56] <smls> i.e. make [] non-itemizing, but keep list assignment as it is

[15:56] <smls> and keep flattening recursive

[15:57] <pmichaud> smls:  My first thought was "yes, that'd be so bad", but my subsequent thoughts are "well... maybe not so bad"  :)

[15:57] <smls> s/construct/assign to a @ variable/

[15:58] <pmichaud> my brane is hurting a bit, I'll make my way down to the conference venue now

[15:58] <daxim> there's a difference

[15:58] <daxim> both   perl -E'print scalar readline' < foo   and     perl -E'print scalar readline' foo      work

[15:59] <smls> oh, I guess   @a = [[1, 3], [2, 4]]   would also still work because the outer [] constructs an array (thereby itemizing the inner ones) before assignment

[15:59] <daxim> but     perl6 -e'say $*IN.get' foo    hangs

[15:59] <daxim> only the redirect version works

[16:00] <pmichaud> smls:  correct

[16:00] <pmichaud> smls:  as opposed to   ([1,3], [2,4])   which wouldn't itemize the inner arrays

[16:00] <smls> yeah

[16:00] <ab6tract> pmichaud: I can commiserate with the hurt in your brain :)

[16:01] <ZoffixWork> I checked the code and it just logs the error and proceeds to the next module. There's no chocking :) RE: [09:24:33] <masak> ZoffixWork: if it's possible for it to choke, then we should probably put a `try` statement somewhere...

[16:01] <ab6tract> fwiw, I still haven't seem something that doesn't look like some form of sharp object to the eye

[16:02] <pmichaud> $Pm.torment(<GLR>)

[16:02] <ab6tract> but then again, we are talking about contexts.... I guess it's an immutable property of the topic :(

[16:03] <ab6tract> anyway, out for now

[16:03] <jnthn> daxim: It's waiting for input; the foo there won't magically go to STDIN. If I typed something and hit enter it will say it. Maybe you're looking for $*ARGFILES

[16:03] <ab6tract> have fun, #perl6!

[16:03] <ZoffixWork> \o

[16:03] *** ab6tract left
[16:04] <daxim> why is the magic gone? :(

[16:05] *** FROGGS left
[16:06] <TimToady> $*IN.get is <STDIN>, not <>

[16:07] <TimToady> that's why the "IN"

[16:07] *** diana_olhovik joined
[16:07] *** yqt left
[16:11] <TimToady> daxim: so if you want the magic, just do this: perl6 -e 'say get' foo

[16:11] <TimToady> get will behave like <>

[16:12] <TimToady> or use lines for all of them

[16:12] <moritz> (but hopefully without the security implications of <>)

[16:12] <daxim> ah, so get is a function, too, not just a method

[16:12] *** domidumont left
[16:12] <daxim> I'm glad the magic is not gone after all, that makes porting much easier

[16:13] *** uncleyear left
[16:13] *** uncleyear joined
[16:13] <TimToady> m: say get

[16:13] <camelia> rakudo-moar 24c39e: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall␤»

[16:14] <moritz> m: say $*ARGS.get

[16:14] <camelia> rakudo-moar 24c39e: OUTPUT«Dynamic variable $*ARGS not found␤  in block <unit> at /tmp/baPSkM5wxe:1␤␤»

[16:14] <moritz> uhm, what's that thing called...

[16:14] <daxim> jnthn said $*ARGFILES

[16:14] <moritz> ah, right

[16:15] <pmichaud> as to why   "@a = $scalar" might not iterate $scalar whereas  "for $scalar" does, part of the difference to me may come down to the former being list prefix precedence, whereas the latter doesn't seem to have that precedence.

[16:16] <dalek> ecosystem: f39c42c | (Jeffrey Goff)++ | META.list:

[16:16] <dalek> ecosystem: Add ANTLR4, Marpa

[16:16] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f39c42cec3

[16:17] <daxim> how do I get a complete list of those built-in functions, then?  http://docs.perl6.org/routine-sub.html does not list `get`

[16:17] <DrForr> The pull request didn't seem to do the trick yesterday. And Marpa is very much raw.

[16:18] *** uncleyear left
[16:18] <ZoffixWork> DrForr, ANTLR got a JSON error in its meta so it's not indexing. I sent you a pull to fix it

[16:19] *** uncleyear joined
[16:19] *** lizmat joined
[16:23] *** spider-mario joined
[16:23] *** tinybla__ left
[16:24] *** yqt joined
[16:24] <DrForr> Yeah, I just saw that this morning. Merged, I also added Marpa in the update.

[16:24] <RabidGravy> daxim, right now it's look in the source then add the missing functions to the docs ;-)

[16:25] *** tinyblak joined
[16:27] <PerlJam> DrForr: the README for Marpa is a little confusing  ;)

[16:27] <DrForr> Sigh, fixing.

[16:28] <JimmyZ_> somebody wrote a parser for core setting to search subs and signature

[16:28] <JimmyZ_> it is in a gists, iirc

[16:28] *** silug left
[16:28] <PerlJam> no worries.   I just tuned in and saw Marpa in Perl6 context and wondered what, exactly, that meant.   I can read the source in lieu of the README  :)

[16:29] <DrForr> I haven't even managed to get the library compiled, but I'll get it work.

[16:29] *** tinyblak_ joined
[16:30] *** mj41 joined
[16:31] *** ZoffixWork left
[16:32] *** tinyblak left
[16:33] <skids> WRT the "how do we implement .kv-ish things question" I think that whatever happens to flattening, it would also be good to have a procedural "take"-like (but strictly lexical and efficient) construct so you can to "loop { calc; takeish-thing; calc; takeish-thing; }" rather than "loop { calc; store-calc; calc; stored-calc, calc; }"

[16:33] *** tinyblak joined
[16:33] <skids> Being lexical it could do label stuff.

[16:34] <TimToady> what's the matter with just using gather/take?

[16:35] <dalek> rakudo/nom: 14458a9 | lizmat++ | src/core/Str.pm:

[16:35] <dalek> rakudo/nom: Add some camels and beer mugs

[16:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14458a9026

[16:35] *** tinyblak left
[16:36] *** tinyblak_ left
[16:36] *** tinyblak joined
[16:36] <skids> TimToady: "It will never be efficient" is my understanding.

[16:36] <skids> Plus, nesting and breaking the nesting.

[16:36] <TimToady> that's horse pucky

[16:37] <TimToady> (the efficiency)

[16:37] *** mj41 left
[16:37] <TimToady> part of the GLR is making gather/take fast

[16:37] <DrForr> README updated, though it's still very much a work in progress.

[16:39] <DrForr> I haven't even gotten the library to compile locally, and the API will probably change when I get back from YAPC.

[16:39] <skids> TimToady: I'm mostly referring to http://irclog.perlgeek.de/perl6/2015-06-10#i_10728696

[16:40] *** tinyblak left
[16:41] <TimToady> a gather/take in eager context will be able to negotiate an implementation with no context switching

[16:44] <PerlJam> (Travis Chase)++ combining Perl + Testing + Legos

[16:46] <DrForr> I missed a talk with LEGO? :(

[16:47] <PerlJam> yeah, he should have put that in the title IMHO

[16:47] <PerlJam> (I just stumbled upon his talk looking through the live streams)

[16:47] <DrForr> Yes, an improved draw. I'll have to check it out on stream.

[16:49] *** tinyblak joined
[16:50] <RabidGravy> If anyone is interested, Test::is doesn't work properly with enums

[16:51] <timotimo> probably because enums stringify to EnumName::ValueName?

[16:51] <timotimo> and "is" somewhat explicitly does string comparison

[16:52] <RabidGravy> yeah that's basically it

[16:52] <timotimo> though if you want to compare to an enum, why doesn't the thing you're comparing return an enum instance, too?

[16:52] <RabidGravy> m: enum Foo(:Bar(2));  say Bar eq 2;

[16:52] <camelia> rakudo-moar 14458a: OUTPUT«False␤»

[16:54] <RabidGravy> timotimo, because I don't know how to make the corresponding thing from an int

[16:54] <timotimo> m: enum Foo <Bar Baz Quux>; say Foo(2);

[16:54] <camelia> rakudo-moar 14458a: OUTPUT«Quux␤»

[16:55] <RabidGravy> ah-ha! 

[16:55] <RabidGravy> I tried just about every other thing 

[16:55] <timotimo> wow :)

[16:55] <PerlJam> RabidGravy: next time, just ask timotimo ;)

[16:55] <timotimo> Type($value) is "coercion syntax" in general

[16:57] <colomon> hmmm, port to p6?  http://www.retro11.de/ouxr/211bsd/usr/src/games/warp/warp.c.html

[16:59] <andreoss> i've just tried git clone this link 

[17:02] <andreoss> >You may copy the warp kit in whole or in part as long as you don't try to

[17:02] <andreoss> make money off it, or pretend that you wrote it.

[17:02] <andreoss> it's not free software

[17:05] <timotimo> can this game be built easily on a modern linux system?

[17:06] <ab5tract> TimToady: it is great to hear some optimism about gather/take

[17:06] <colomon> andreoss: with enough work I think we can contact the author.  ;)

[17:07] <timotimo> it would be quite surprising if the game could compile without any digging for older library versions

[17:08] <ab5tract> It's an awesome construct

[17:08] <timotimo> it very much is

[17:08] <timotimo> i like it a whole lot more than python's "yield"

[17:09] <colomon> woah, like half of the game is command line processing.

[17:09] <timotimo> i don't think warp.c is all there is to that game :D

[17:09] <colomon> oh, right.

[17:09] <timotimo> :D

[17:09] <timotimo> i made the same mistake as you

[17:09] <colomon> indeed, http://www.retro11.de/ouxr/211bsd/usr/src/games/warp/

[17:10] <itz> http://www.retro11.de/ouxr/211bsd/usr/src/games/warp/warp.c.html

[17:10] <itz> oops

[17:10] <itz> https://github.com/RetroBSD/retrobsd/tree/master/src/games/warp

[17:11] <colomon> itz++

[17:11] <ab5tract> timotimo: does 'yield' have control flow implications?

[17:12] <ab5tract> in Python, I mean

[17:13] <pmichaud> stevan's talk:  Q: "How many of you know what a mop is?"

[17:13] <timotimo> what do you mean?

[17:13] <timotimo> yield does the typical coroutine thing

[17:13] <pmichaud> . o O (  If you understand what a mop is, you don't understand what a mop is  )   # :-)

[17:14] <timotimo> if we do modernize warp, we should get it included in the typical bsdgames packages

[17:15] *** Possum left
[17:17] <skids> lua's "yield" has a slight advantage over "take" in that it allows bidirectional coroutine communications (but you can hack that together in Perl6 with an extra lazy list).

[17:18] <andreoss> itz: it's not the original code i guess, some kind of mips port

[17:21] <ab5tract> timotimo: nevermind, I was misremembering the behavior of 'yield' in Ruby

[17:21] <timotimo> skids: we have take-rw which allows the "receiving" end to change values previously take'd before returning control to the gathering code

[17:21] <arnsholt> I'm getting an error when building NQP head using MoarVM HEAD: "MoarVM op 'neverrepossess' is unknown as a core or extension op"

[17:21] <arnsholt> Anyone seen this before?

[17:21] <ab5tract> for some reason I had the impression that it behaved like a return statement, which would only allow one

[17:22] <timotimo> arnsholt: could be you've got an older version of MoarVM in your path that Configure is picking up?

[17:22] <ab5tract> timotimo: that's eff-ing brilliant

[17:22] <timotimo> i think it's hacky and sort of weird, but that's just me :)

[17:23] <skids> timotimo: that does the trick, too.  Good point.

[17:23] *** FROGGS joined
[17:24] <andreoss> it even compiles 

[17:24] <ab5tract> timotimo: a :with(Code &a) adverb might be cool 

[17:24] <timotimo> i'd rather people just use threads that block on each other

[17:25] <timotimo> where would you put that adverb?

[17:25] *** JimmyZ_ left
[17:26] <ab5tract> gather :with($transform) 

[17:26] <timotimo> i think you'll have to give me a bit more than that :)

[17:26] <ab5tract> Well, I might just be wildly interpreting 'bidirectional coroutine communications'

[17:27] <ab5tract> and am still learning the adverbial syntax

[17:27] <timotimo> i just don't understand when you expect that transform to be called and with what

[17:27] <dalek> rakudo/nom: c6925b2 | (Steve Mynott)++ | tools/build/create-moar-runner.pl:

[17:27] <dalek> rakudo/nom: correct minor typo and grammar

[17:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c6925b2f84

[17:27] <dalek> rakudo/nom: 4f36870 | FROGGS++ | tools/build/create-moar-runner.pl:

[17:27] <dalek> rakudo/nom: Merge pull request #437 from stmuk/stmuk

[17:27] <dalek> rakudo/nom: 

[17:27] <dalek> rakudo/nom: correct minor typo and grammar

[17:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f36870b89

[17:28] *** Possum joined
[17:29] <FROGGS> rjbs++ and TimToady++ # chatter

[17:30] <rjbs> :)

[17:30] <smls> TimToady: The reason why space is forbidden before postfixes, is to avoid ambiguity with infixes, right?

[17:30] <smls> In that case, wouldn't it be feasible to make an exception for method calls, and solve the ambiguity by instead fobidding people from defining infix operators that look like ".foo" ?

[17:30] *** captain-adequate left
[17:31] <smls> I thought I would get used to the  .foo(...)\  unspace syntax for multi-line method chains, but it still bothers me a little every time I write it.

[17:31] <ab5tract> timotimo: I was imagining that $transform would be called with the taken values as args at the end of each iteration

[17:31] <lizmat> FWIW, smls++

[17:31] <ab5tract> within the scope of wherever gathering is happening

[17:31] <timotimo> ab5tract: that looks like you just want to use .map on the lazy list and give that to whoever is interested

[17:32] <ab5tract> indeed

[17:32] <dalek> perl6-roast-data: 24af6fd | coke++ | / (8 files):

[17:32] <dalek> perl6-roast-data: today (automated commit)

[17:32] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/24af6fdf4e

[17:33] <pmichaud> I really want the "unspace" question listed as a FAQ  on faq.perl6.org

[17:34] <pmichaud> also, oddly there's no link to faq.perl6.org from the perl6.org home page  

[17:34] <ab5tract> Not very useful after all :)

[17:34] <smls> Ideally, faq.perl6.org would be merged into doc.perl6.org IMO

[17:34] * ab5tract is used to being lazy, less used to the code being as lazy as he is

[17:34] <smls> separated into multiple pages grouped by topic, like perldoc's FAQs

[17:35] <ab5tract> timotimo: thinking in adverbs has me asking the question though, why we use the *-rw idiom rather than a :rw one

[17:36] <timotimo> too many adverbs are a design smell

[17:36] <andreoss> smls: how about p6doc faq?

[17:37] *** tinyblak left
[17:38] *** abraxxa left
[17:38] <ab5tract> timotimo: I get the feeling you speak from deep, perhaps painful, experience

[17:38] *** espadrine left
[17:38] <ab5tract> It sounds reasonable, regardless

[17:39] <timotimo> haha

[17:39] <timotimo> no, not really

[17:40] *** SevenWolf joined
[17:43] <dalek> faq: d6e9dbf | pmichaud++ | answers.md:

[17:44] <dalek> faq: Stub in a FAQ for unspace and method calls.

[17:44] <dalek> faq: review: https://github.com/perl6/faq/commit/d6e9dbf7bd

[17:44] <pmichaud> note that's just the Q without the A.

[17:44] <colomon> my recollection is there was a general feeling that we were too gung ho about adverbs in the early days of p6, and have come to the conclusion they’re best used sparingly.  

[17:45] <ab5tract> pmichaud: Note that there is likely useful A's for some things in http://doc.perl6.org/language/traps

[17:46] <pmichaud> my recollection differs a bit.  For a very long time, we didn't have a good way to parse adverbs, so we tended to avoid them.

[17:46] <ab5tract> which I think has fallen into an unfortunate naming scheme. 'gotchas' might be less forboding

[17:46] <pmichaud> I'm totally fine with migrating faq.perl6.org into doc.perl6.org... it's just not my focus at the moment :)

[17:47] *** lizmat left
[17:47] <pmichaud> basically, I'm thinking we might want to come up with the standard answers for the frequently bikeshedded topics  :)

[17:47] <ab5tract> pmichaud: On the contrary, I was more considering the live scenario you are in right now, offering a resource which fields some known areas of confusion

[17:47] <pmichaud> ab5tract: yeah, I'm reading it now

[17:47] <pmichaud> (plus I'm half listening to stevan++'s talk )

[17:48] <pmichaud> actually, perhaps I should create a "bikeshedded answers" section of faq.perl6.org  :)

[17:52] *** telex left
[17:54] * PerlJam presumes that TimToady told Stevan an easier/better way to get at the bits of data tacked onto a package.

[17:54] *** telex joined
[17:55] <smls> pmichaud: Will your quest to make @( ) / .list unnecessary in many places, also extend to making things like .tree less necessary?

[17:56] <smls> e.g. this does not DWIM currently:  @a X (@b Z @c)

[17:56] <smls> to make it do the "natural" thing, we have to write:  @a X (@b Z @c).tree.list

[17:56] <smls> ...which is quite ugly.

[17:56] *** lizmat joined
[17:57] <smls> if the GLR would make that go away too, I'd be happy :)

[17:57] <FROGGS> btw, I'd also like to see an implicit unspace before the method call dot

[17:59] <PerlJam> smls: @a X [@b Z @c]  is quite close to what you want  :)

[17:59] <lizmat> m: my $a = 42; say $a .Str   # only when we would get a TTIAR

[17:59] <camelia> rakudo-moar 4f3687: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YnBCRQfLrk␤Two terms in a row␤at /tmp/YnBCRQfLrk:1␤------> 3my $a = 42; say $a7⏏5 .Str   # only when we would get a TTIAR␤    expecting any of:␤        infix␤        infix stopper␤        po…»

[17:59] <smls> it gets me a very different output

[18:00] <lizmat> so basically turn a TTIAR in which the 2nd term starts with "." into something useful

[18:00] <arnsholt> timotimo: Looks like you were sort of right. I had --with-moar but no --prefix, which made it try to use nqp/install/bin/moar even though I told it to use some other moar

[18:01] *** rindolf left
[18:01] <FROGGS> lizmat: Slang::Tuxic does it and it seems there are no false positives there

[18:02] <timotimo> arnsholt: ah, right

[18:03] <lizmat> FROGGS: but that's not the only thing that Slang::Tuxic does, is it ?

[18:03] *** andreoss left
[18:03] <timotimo> one problem with .foo with space in front is that ".foo" is already shorthand for "$_.foo"

[18:03] <FROGGS> lizmat: correct, but it is one of the sane things it does :o)

[18:04] <FROGGS> timotimo: it is still nice to line-up long method.method.method calls

[18:04] <timotimo> yes

[18:04] <lizmat> timotimo: yes, and it can stay that way

[18:05] <timotimo> i mean if we allowed .foo without a \ on the line before that

[18:05] <lizmat> because then it is the first term

[18:05] <lizmat> m: .say for ^5   # would continue to work

[18:05] <camelia> rakudo-moar 4f3687: OUTPUT«0␤1␤2␤3␤4␤»

[18:06] <timotimo> i was thinking of the potential version of .foo where we're allowed to put whitespace and newline between $foo and .bar

[18:06] <RabidGravy> had gone name blind when Test.pm was kebabed https://github.com/rakudo/rakudo/pull/438

[18:06] <arnsholt> FROGGS: From my understanding, it's precisely that kind of helpful parsing rules that makes parsing Perl 5 the horror that it is

[18:06] <FROGGS> timotimo: right, .say will continue to work

[18:07] <timotimo> of course

[18:07] <raydiak> if I did "say sub {}␤.defined" would that be "say(sub {}); $_.defined" or "say(sub {}.defined)"?

[18:07] <timotimo> i just mean it can confuse people

[18:07] <FROGGS> arnsholt: yes, but you want to have nicely readable code, right?

[18:07] <timotimo> the way we currently have it is good, IMO

[18:08] <smls> raydiak: the former

[18:08] <smls> }␤  is a statement terminator

[18:08] <smls> allowing space befor .method would not change that

[18:09] <raydiak> got it

[18:09] *** rindolf joined
[18:11] <RabidGravy> boo! is_approx isn't approximate enough

[18:12] <RabidGravy> ;-)

[18:13] <lizmat> RabidGravy: please fix!  soon!  :-)

[18:14] *** domidumont joined
[18:14] <lizmat> that one was specifically *not* kebab-cased to allow for a better version

[18:14] <lizmat> named "is-approx"

[18:14] <RabidGravy> ah okay

[18:16] <RabidGravy> I only noticed because ffmpeg can't make a WAV file of exactly 1 second - for some reason it insists on some multiple of 1024 frames

[18:17] * ab5tract suddenly imagines libav bindings

[18:17] <RabidGravy> I finally got around to libsoundfile

[18:18] <ab5tract> RabidGravy++ :D

[18:18] <RabidGravy> er, libsndfile - libsoundfile is different

[18:19] <ab5tract> I think I parsed it properly anyway

[18:21] <awwaiid> Is there a "binding.pry" type thing in rakudo, so I can do like "start a REPL here"?

[18:22] <awwaiid> (I might have asked this before, but can't remember)

[18:25] *** yqt left
[18:30] *** bin_005 joined
[18:31] <daxim> p6: my $i = -1; #`{ computed last field } say <q w e r t>[$i..2]

[18:31] <camelia> rakudo-moar 4f3687: OUTPUT«Index out of range. Is: -1, should be in 0..Inf␤  in block <unit> at /tmp/tmpfile:1␤␤»

[18:32] <daxim> why does accessing indexes from the right end not work anymore?

[18:33] <FROGGS> daxim: you have to indicate that you really want to do it

[18:33] <masak> are you sure that ever worked?

[18:33] <arnsholt> It's never been supposed to work

[18:33] <arnsholt> AFAIK

[18:33] <masak> right.

[18:33] <FROGGS> p6: my $i = -1; #`{ computed last field } say <q w e r t>[*$i..2]

[18:33] <camelia> rakudo-moar 4f3687: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> 3 computed last field } say <q w e r t>[*7⏏5$i..2]␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤    …»

[18:34] <FROGGS> err

[18:34] <FROGGS> p6: my $i = -1; #`{ computed last field } say <q w e r t>[(* + $i)..2]

[18:34] <camelia> rakudo-moar 4f3687: OUTPUT«␤»

[18:34] <FROGGS> p6: my $i = -1; #`{ computed last field } say <q w e r t>[0..*]

[18:34] <camelia> rakudo-moar 4f3687: OUTPUT«q w e r t␤»

[18:35] <FROGGS> p6: my $i = -1; #`{ computed last field } say <q w e r t>[0..(*-1)]

[18:35] <camelia> rakudo-moar 4f3687: OUTPUT«q w e r t␤»

[18:35] <FROGGS> p6: my $i = -1; #`{ computed last field } say <q w e r t>[(*-1)]

[18:35] <camelia> rakudo-moar 4f3687: OUTPUT«t␤»

[18:35] <FROGGS> hmmm

[18:35] <FROGGS> I thought it would mean .elems here

[18:35] <[Coke]> https://gist.github.com/coke/f852b3728e459867f622 # of lines per author in rakudo blame.

[18:36] <[Coke]> m: say 706/27668 # surprised i'm this high.

[18:36] <camelia> rakudo-moar 4f3687: OUTPUT«0.025517␤»

[18:36] <FROGGS> I am twice as much to blame than TimToady? O.o

[18:36] <[Coke]> I alwso see some people are in there under 2 or more addresses.

[18:37] <FROGGS> yeah

[18:37] <FROGGS> [Coke]: is that for rakudo?

[18:37] <FROGGS> ahh yes

[18:38] <FROGGS> you mentioned it :D

[18:39] <daxim> FROGGS, masak:  perl -e'my $i = -1; print for (qw"q w e r t")[$i..2]'  # expected result, want to "wrap around"

[18:43] <[Coke]> maybe I can edge past perljam. :)

[18:46] <tony-o_> jnthn: is there a mechanism in nativecall to call perl6 functions?

[18:47] *** lizmat left
[18:48] <FROGGS> tony-o_: as a callback?

[18:48] <tony-o_> yea

[18:48] <tony-o_> similar to a callback

[18:48] <FROGGS> http://doc.perl6.org/language/nativecall#Function_arguments

[18:49] <tony-o_> FROGGS: tyvm

[18:49] <FROGGS> tony-o_: yw

[18:49] <raydiak> m: print qw"q w e r t".rotate(-1)[^4] # for lack of a concise way to wrap the indices, you could wrap the list around instead...

[18:49] <camelia> rakudo-moar 4f3687: OUTPUT«tqwe»

[18:51] <tony-o_> FROGGS: on the C side, do i end up calling 'callback(<whatever>)' to run the perl6 side sub/method ?

[18:52] <daxim> thanks, raydiak 

[18:52] <FROGGS> tony-o_: I think so

[18:54] <raydiak> daxim: you're welcome :)

[18:55] <daxim> when I dump something with $foo.perl.say, it shows up as $( ………something……… )

[18:55] <daxim> what's that?

[18:56] <daxim> gives me hard jquery flashbacks :/

[18:56] <vendethiel> daxim: itemization

[18:56] <vendethiel> m: for $(1, 2, 3) { say .perl; }

[18:56] <camelia> rakudo-moar 4f3687: OUTPUT«$(1, 2, 3)␤»

[18:56] <vendethiel> m: for $(1, 2, 3), 2, 3 { say .perl; }

[18:57] <camelia> rakudo-moar 4f3687: OUTPUT«$(1, 2, 3)␤2␤3␤»

[18:58] <daxim> .WHAT says the type is List, what does itemization mean then?

[18:58] *** amurf joined
[18:58] <timotimo> [Coke]: it seems like i'll have to be doing some core setting contributions :3

[19:03] *** uncleyear left
[19:03] *** uncleyear joined
[19:03] *** amurf left
[19:07] *** nys joined
[19:10] *** yqt joined
[19:14] <timotimo> [Coke]: can you give me a list of what file has the least timo-lines in it? :)

[19:16] <[Coke]> I leave that as an exercise to the reader.

[19:19] <vendethiel> Util++ #nice talk

[19:22] <hoelzro> what's the policy for accessing globaly things (eg. $*ARGFILES) from separate threads? "play with fire and you're going to get burned", or do we try to protect people from themselves?

[19:22] *** domidumont left
[19:25] *** smls left
[19:25] <DrForr> OpenCV actually looks like a fun library to play with.

[19:27] <hoelzro> DrForr: OpenCV is one of the libraries I have on my "write a Perl 6 binding for this" list

[19:27] *** pullphinger joined
[19:27] *** pullphinger left
[19:28] *** pullphinger joined
[19:28] <DrForr> The API is almost all C++, it looks like.

[19:29] <hoelzro> yes, but I think that they at least have extern "C" symbols you can link to for C support

[19:29] *** Peter_R joined
[19:30] <DrForr> waltman's talk got me thinking :)

[19:31] <Util> vendethiel: Thanks!

[19:33] *** avalenn left
[19:36] <DrForr> Building opencv takes quite a while.

[19:36] *** avalenn joined
[19:37] <vendethiel> "Michael Michaud - "How (not) to create a language specification for Perl 6‎" uh.

[19:38] <jnthn> ...who? :)

[19:40] <Util> http://www.yapcna.org/yn2015/talk/6274

[19:40] <Util> By Patrick Michaud (‎Pm‎) from DFW.pm 

[19:40] <Util> How (not) to create a language specification for Perl 6

[19:40] <vendethiel> (my titme was from youtube)

[19:41] <jnthn> .oO( How (not) to type "Patrick" )

[19:41] <vendethiel> s/me/le/

[19:41] <Util> Ah

[19:42] <colomon> Is pmichaud talking now?

[19:44] <colomon> Have him streaming on my iPad, yes!

[19:46] <colomon> seems like they’re doing a really nice job of it, too.  (knock on wood)

[19:47] <masak> if we ever clone pmichaud, I move that we name the clone "Michael Michaud" :D

[19:47] * PerlJam watches pmichaud's talk too

[19:47] <masak> with the nick "mmichaud", of course

[19:48] <flussence> heh, xhtml2 would've been a better example there - the browsers went off and invented html5 outside the w3c instead :)

[19:49] <PerlJam> masak: Patrick A Michaud (who spoke at YAPC::NA 2013) should speak at more conferences concurrently with Patrick R. Michaud too

[19:49] <RabidGravy> I while back someone suggested of taking a CArray and putting its contents into a Buf but buggered if I can remember how

[19:50] *** molaf joined
[19:50] <masak> PerlJam: I wonder if there's both a Michael A and a Michael R. too?

[19:50] <RabidGravy> a way of taking

[19:51] <PerlJam> I think pmichaud's brother is named Michael ... I don't remember.

[19:51] *** lizmat joined
[19:53] *** diana_olhovik left
[19:56] *** lizmat_ joined
[19:56] *** lizmat left
[19:58] *** FROGGS left
[19:58] <ab5tract> pmichaud: FWIW, It only took a few hours for me to (mostly) drop my issues with `$a` vs `$a,`

[19:58] <ab5tract> erm `[]` and `[],`

[19:58] <ab5tract> though it essentially boils down to the same thing

[19:59] *** mohij joined
[19:59] <ab5tract> `,` is an infix constructor (or is it a coercion?) to List

[20:00] <ab5tract> So it's not about "list context" in any way like my day-to-day work with Perl 5 would lead me to understand it

[20:02] <ab5tract> Put another way, the 'rule' of `,` is sufficiently simple to offset that essential frustration that elicited my earlier reaction

[20:13] *** darutoko left
[20:14] *** dwarring joined
[20:16] *** colomon left
[20:18] <dalek> rakudo/nom: 88e1464 | lizmat++ | src/core/Perl.pm:

[20:18] <dalek> rakudo/nom: Make this version Perl 6 A

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88e1464142

[20:19] <[Coke]> Do we have any buyin on that version numbering scheme? last I heard it was undecided.

[20:19] <masak> the "Patrick A Michaud" suddenly makes a lot more sense... :P

[20:20] <[Coke]> want to make sure we have buyin before it goes out in a monthly, is all.

[20:20] <masak> agreed.

[20:20] <masak> last I heard it was undecided, but there's also no alternative that will please everybody.

[20:20] <PerlJam> masak: except that this one is Patrick R Michaud  

[20:21] * jnthn is guessing lizmat's commit came after some discussion at YAPC::NA :)

[20:21] <lizmat_> I guess the buyin is that pmichaud just mentioned the lettering scheme for the version of the *language*

[20:21] *** lizmat_ is now known as lizmat

[20:21] <jnthn> ah :)

[20:22] <lizmat> and I hated the vunknown pretty badly  :-)

[20:22] *** msouth left
[20:22] <nwc10> .u  

[20:22] <yoleaux> U+2006 SIX-PER-EM SPACE [Zs] ( )

[20:22] <lizmat> m: say $*PERL.version

[20:22] <camelia> rakudo-moar 4f3687: OUTPUT«vunknown␤»

[20:22] <nwc10> there, that's got a "SIX" in it. That will do nicely.

[20:23] <nwc10> everyone can fill in their own preference. No nasty prescribed design :-

[20:23] <nwc10> )

[20:23] <masak> no alternative will please everybody, but "vunknown" is likely to satisfy no-one :P

[20:24] <PerlJam> lizmat: so ... how does one specify that version in code?   use v6.A ?

[20:24] <lizmat> in code, one would specify a version of the *compiler* I would think ?

[20:24] <PerlJam> lizmat: no, I want to say my code assumes this version of the language.

[20:24] <jnthn> m: v6a

[20:24] <camelia> rakudo-moar 4f3687: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IHetXE0eAq␤Undeclared routine:␤    v6a used at line 1␤␤»

[20:25] <jnthn> m: v6.a

[20:25] <camelia> rakudo-moar 4f3687: OUTPUT«Method 'a' not found for invocant of class 'Version'␤  in block <unit> at /tmp/6ioYvjpcsY:1␤␤»

[20:25] <jnthn> aw :)

[20:25] <itz> can't we have String::Koremutake strings based on git sha hashes for versions? :)

[20:27] *** ShimmerFairy left
[20:27] *** bin_005_j joined
[20:28] *** bin_005 left
[20:28] <dalek> rakudo/nom: 2b2a1a1 | lizmat++ | src/core/Perl.pm:

[20:28] <dalek> rakudo/nom: Got corrected by TimToady++, it's Advent, not A

[20:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b2a1a18ea

[20:28] <PerlJam> nice!

[20:29] <lizmat> and please forgive me if consensus turns out this is wrong  :-)

[20:29] <lizmat> $ 6 'say $*PERL.version'

[20:29] <lizmat> v6.Advent

[20:29] <flussence> I'm trying to get a silly idea to work: making "is cached" use a typed %cache if possible, instead of calling .gist every time

[20:29] <lizmat> flussence: that would call .WHICH everytime

[20:29] <flussence> still in the "trying to get it to build at all" phase, though :)

[20:29] <lizmat> which *could* be better, I agree

[20:30] <[Coke]> cached can't use gist, can it, since that loses info?

[20:30] <lizmat> current is cached implementation is pretty naive in that respect

[20:30] <lizmat> more like a proof of concept and nice for demonstrations  :-)

[20:31] <flussence> my current line of thinking is: if there's only one param and it ~~ Cool, it's probably safe to use directly as a hash key

[20:31] *** sjn joined
[20:32] <masak> std: say v6.Advent

[20:32] <camelia> std 28329a7: OUTPUT«ok 00:00 135m␤»

[20:33] *** colomon joined
[20:34] *** mohij left
[20:34] <masak> std: say v6.Ekke.Ekke.Ekke.Ptangya.Zoooooooom.Boing.Ni

[20:34] <camelia> std 28329a7: OUTPUT«ok 00:00 135m␤»

[20:34] *** mohij joined
[20:37] *** pecastro left
[20:39] *** espadrine joined
[20:39] *** ShimmerFairy joined
[20:39] *** rindolf left
[20:42] *** mohij left
[20:43] *** rurban joined
[20:43] *** rurban left
[20:43] <flussence> ooh, 5.22 has a grapheme thingy

[20:46] <lizmat> sorta, yes, for .combing  :-)

[20:46] <lizmat> wonder how that would work for the cases that jnthn had in his lightning talk

[20:46] <flussence> I'm liking these other things going on :)

[20:48] *** rurban joined
[20:48] <jnthn> Time for some rest...and will be offline in the morning traveling to London. o/

[20:49] <lizmat> good night jnthn  and safe travelling!

[20:49] <PerlJam> flussence: yeah ... too bad this perl (5) didn't exist years ago already

[20:50] <spintronic> will PDL traits be implemented in Perl6?

[20:50] <spintronic> it's from Synopsis 9

[20:50] <PerlJam> spintronic: eventually (probably)

[20:51] <spintronic> ^_^

[20:51] * lizmat hopes danaj will get with something soon  :-)

[20:53] *** pullphinger left
[21:05] *** sivoais left
[21:06] *** sivoais joined
[21:07] *** skids left
[21:15] *** Ven joined
[21:16] *** colomon left
[21:16] <[Coke]> maybe not by christmas.

[21:17] <[Coke]> (pdl traits, that is)

[21:21] *** lizmat left
[21:25] <timotimo> shaped arrays are on the roadmap

[21:26] <PerlJam> yeah, but pdls are more holy-grail-ish than just shaped arrays

[21:28] *** rurban left
[21:31] *** rurban joined
[21:36] *** molaf left
[21:37] *** hoelzro_trying_w joined
[21:37] <timotimo> well, to be fair

[21:37] <timotimo> when we say "we have routines", we also mean something more "holy-grail-ish" than just routines

[21:37] *** colomon joined
[21:39] <RabidGravy> *** Error in `/home/jonathan/.rakudobrew/moar-nom/install/bin/moar': corrupted double-linked list: 0x00000000040ae1a0 ***

[21:39] <RabidGravy> that's not good is it

[21:40] <DrForr> I've gotten quite a few of those when playing with readline.

[21:43] <zostay> i've been doing some deep thinking about PSGI for Perl 6 and i've come up with a proposal for a Perl 6 version of the PSGI standard

[21:43] <zostay> if you're interested: https://github.com/zostay/P6SGI

[21:46] *** lizmat joined
[21:47] <ab5tract> zostay++

[21:49] *** yqt left
[21:51] *** rurban left
[21:53] <timotimo> zostay: i think you meant "where {  when ... {" instead of "where { where ... {" in the Application section

[21:54] *** rurban joined
[21:55] *** SevenWolf left
[21:57] *** kaare_ left
[21:57] <lizmat> m: gather { take fail }

[21:57] <camelia> rakudo-moar 2b2a1a: OUTPUT«Unhandled exception: Could not find symbol '&Return'␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:16775  (/home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.set…»

[21:59] *** Ven left
[22:01] *** SevenWolf joined
[22:02] *** yqt joined
[22:03] <dalek> rakudo/nom: 975bcc3 | lizmat++ | src/core/control.pm:

[22:03] <dalek> rakudo/nom: Make gather { take fail } a proper failure

[22:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/975bcc3424

[22:03] <lizmat> $ 6 'gather { take fail }'

[22:03] <lizmat> Unhandled exception: Attempt to return outside of any Routine

[22:04] *** Foxcool left
[22:07] *** Foxcool joined
[22:07] <pmichaud> good afternoon, #perl6

[22:07] *** Foxcool left
[22:08] *** Foxcool joined
[22:08] <lizmat> pmichaud o/

[22:08] <pmichaud> some current GLR thinking, from lunchtime:

[22:09] <pmichaud>    [ ... ]   becomes an array composer without itemization

[22:09] <pmichaud>    [ ... ]   imposes a flattening context on the values inside it

[22:10] *** frew joined
[22:10] <pmichaud>    gather/take will need to become very efficient

[22:11] <frew> I think --prefix is broken in Configure.pl when you use --gen-moar

[22:11] <frew> is there a better place to say this?

[22:11] <pmichaud>     we still don't know of a way to have a loop (e.g. 'map') that returns a list with more elements than there were iterations in the loop

[22:11] <pmichaud> frew: this is good, also [email@hidden.address]
[22:11] <frew> ok; I'll leave it at that for now then

[22:12] <pmichaud>    (map returning more elements -- not being able to do that feels like an arbitrary limitation)

[22:13] <TimToady> quietfanatic++ suggested that Empty was a degenerate case of a more general list inserter

[22:15] <frew> details: https://gist.github.com/frioux/7922db83735d1a5984f8

[22:15] <dalek> rakudo/nom: 9b25d80 | lizmat++ | src/core/Compiler.pm:

[22:15] <dalek> rakudo/nom: Remove deprecations that are 1 year old now

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9b25d8082c

[22:15] <frew> I don't think there's an obvious solution other than a better error

[22:15] <frew> or .deb's :)

[22:15] <timotimo> frew: do you have write access to /opt as the user that executes that?

[22:15] <frew> no

[22:15] <frew> that's the problem

[22:16] <timotimo> that explains it

[22:16] <frew> but I don't like to compile as root?

[22:16] <timotimo> right

[22:16] <timotimo> this is not about "--prefix is broken", this is "our --prefix behaves very differently from how you'd expect it to"

[22:16] <frew> sure

[22:16] <timotimo> which essentially boils down to "our --prefix is broken"

[22:16] <frew> lol

[22:17] <frew> I mean, it's arguably the subtle --gen-moar (and I bet --gen-nqp) behaviour

[22:17] <timotimo> right; those also contain the "make install" step

[22:17] <frew> I figured that

[22:18] <timotimo> we've been told before that it's very not cool to be installing during Configure.pl

[22:18] <frew> ok

[22:18] <timotimo> even compiling during Configure.pl isn't very neat

[22:18] <frew> right

[22:18] <frew> I mean

[22:18] <frew> I get it

[22:18] <frew> and really, the solution is to have nqp and moar installed by a package I think

[22:18] <timotimo> yeah

[22:18] <frew> but bootstrapping; I get it.

[22:18] * frew googles ppa rakudo

[22:19] <slavik> is it possible and is there any documentation on meta-object programming in perl6? I am wondering if it's possible to create a class at run time.

[22:19] <timotimo> it is very possible

[22:20] <lizmat> ClassHOW.new ?

[22:20] <lizmat> m: Int.^HOW.say

[22:20] <camelia> rakudo-moar 975bcc: OUTPUT«5===SORRY!5=== Error while compiling /tmp/vgde32XoO2␤Cannot use .^ on a non-identifier method call␤at /tmp/vgde32XoO2:1␤------> 3Int.^HOW7⏏5.say␤    expecting any of:␤        method arguments␤»

[22:20] <lizmat> m: Int.HOW.say

[22:20] <camelia> rakudo-moar 975bcc: OUTPUT«Perl6::Metamodel::ClassHOW.new␤»

[22:20] *** bin_005_j left
[22:20] <timotimo> https://github.com/timo/ADT/blob/master/lib/ADT.pm6#L55 here's one example library that does it

[22:21] <zostay> timotimo: thx... corrected

[22:21] <slavik> timotimo: ty

[22:21] <pmichaud> quietfanatic++ # general list inserter

[22:21] <timotimo> yw

[22:22] <pmichaud> a general list inserter feels.... elegant.

[22:23] <timotimo> perhaps this is what we've always wanted parcel to be?

[22:23] <timotimo> or maybe at one point

[22:23] <lizmat> but isn't that what [ ... ] is ?

[22:23] <timotimo> we'll call it Syringe :P

[22:23] <pmichaud> [ ... ] is (to be) an array composer

[22:23] <RabidGravy> is there any way of making a CArray of a certain length? other than looping and assigning each element?

[22:24] <timotimo> i think if you just assign the 100th element it'll become 100 elements big

[22:24] <RabidGravy> ooh let's try that

[22:25] <lizmat> .map: { |[ ... ] } ?   # did not backlog yet

[22:26] <RabidGravy> timotimo, yep that appears to work

[22:29] <pmichaud> I kind of like the idea of |[...]  and |(...)  being used for this, yes.

[22:29] <dalek> roast: 43ad905 | lizmat++ | S02-types/deprecations.t:

[22:29] <dalek> roast: Remove tests for $*PERL deprecations

[22:29] <dalek> roast: review: https://github.com/perl6/roast/commit/43ad905fa6

[22:31] <timotimo> the Weekly is in quite some peril tonight; the cat is very adorable and cuddly at the moment

[22:32] <lizmat> timotimo: are you sure it's not a squirrel ?   :-)

[22:32] <timotimo> hehe

[22:32] <timotimo> i'm the squirrel, if anything

[22:32] <lizmat> ah. Confuse-A-Cat Ltd.  :-)

[22:32] <timotimo> hm?

[22:34] <lizmat> https://www.youtube.com/watch?v=B2Je1CEPkUM

[22:34] <pmichaud> "Perl 6 is geyserware"

[22:34] <pmichaud> labster++

[22:35] *** amurf joined
[22:36] <frew> how do I do this in perl6?    s/[^[:ascii:]]//g;

[22:36] * frew is alrady porting stuff

[22:36] <frew> or where can I find out?

[22:36] <lizmat> s:g to start with

[22:37] <frew> s:g/foo/bar/ ?

[22:37] <RabidGravy> boo! this Audio::Sndfile is taking 15s to load a 1 second file

[22:37] <pmichaud> m: my $_ = 'hello';   s:g/l/L/;  .say

[22:37] <camelia> rakudo-moar 975bcc: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/SwuYea3EDX:1␤    ------> 3my $_7⏏5 = 'hello';   s:g/l/L/;  .say␤heLLo␤»

[22:37] <pmichaud> m: $_ = 'hello';   s:g/l/L/;  .say

[22:37] <camelia> rakudo-moar 975bcc: OUTPUT«heLLo␤»

[22:38] <lizmat> RabidGravy: is it precomped ?

[22:38] <RabidGravy> no, not yet

[22:39] <frew> hm

[22:39] <lizmat> I guess the source is 10K lines + ?

[22:39] <RabidGravy> I've only just made it  not crash

[22:40] <lizmat> ah, actually loading a file, not just loading the module

[22:40] <frew> hmm

[22:40] <lizmat> forget what I said

[22:40] *** amurf left
[22:40] <frew> Method 'subst-mutate' not found for invocant of class 'Any'

[22:40] <TimToady> m: say "föo".subst(/ <-ascii> /, '', :g)

[22:40] <camelia> rakudo-moar 975bcc: OUTPUT«Method 'ascii' not found for invocant of class 'Cursor'␤  in block <unit> at /tmp/EB0ld3Rn6W:1␤␤»

[22:41] <RabidGravy> no, load a 53200 byte WAV file into a buffer

[22:41] <TimToady> m: say "föo".subst(/ <-[\0..\x7f]> /, '', :g)

[22:41] <camelia> rakudo-moar 975bcc: OUTPUT«fo␤»

[22:41] <TimToady> m: say "föo".encode('ASCII')

[22:41] <camelia> rakudo-moar 975bcc: OUTPUT«Blob[uint8]:0x<66 3f 6f>␤»

[22:42] *** rurban left
[22:42] <TimToady> m: say "föo".encode('ASCII').decode

[22:42] <camelia> rakudo-moar 975bcc: OUTPUT«f?o␤»

[22:42] <frew> trying to port this: https://github.com/frioux/dotfiles/blob/master/bin/ascii-ify

[22:47] <RabidGravy> say $*IN.slurp.subst(/ <-ascii> /, '', :g);

[22:47] <RabidGravy> would do it

[22:48] *** jack_rabbit joined
[22:49] *** rurban joined
[22:49] <timotimo> lizmat: monty python is nice :)

[22:50] <timotimo> lizmat: i only recently watched Fawlty Towers with friends

[22:50] <frew> RabidGravy: well I'd rather continue to stream the IO

[22:51] <frew> huh, well when I do $_ = $_.subst(/ <-ascii> /, '', :g) I get Bogus postfix?

[22:51] <RabidGravy> say $_.subst(/ <-ascii> /, '', :g) for $*IN.lines;

[22:52] <frew> I'm doing more than the subst

[22:52] *** rurban left
[22:52] <frew> but yeah I'll do that

[22:52] <frew> Method 'ascii' not found for invocant of class 'Cursor'

[22:53] <TimToady> m: say "föo".subst(/ <-[\0..\x7f]> /, '', :g)

[22:53] <camelia> rakudo-moar 9b25d8: OUTPUT«fo␤»

[22:53] <frew> TimToady: thanks

[22:53] <frew> so is that a missing feature?

[22:54] <TimToady> I dunno, not sure I want to encourage people to asciify :)

[22:55] <frew> it's just a little toy script for the most part 

[22:55] <frew> seemed like it should be easy to convert

[22:55] <timotimo> hm, doesn't trans also support this kind of thing

[22:56] <timotimo> m: my $r = r/foo/; say $r

[22:56] <camelia> rakudo-moar 9b25d8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yHcp5G8L7e␤Missing required term after infix␤at /tmp/yHcp5G8L7e:1␤------> 3my $r = r/foo/7⏏5; say $r␤    expecting any of:␤        prefix␤        term␤»

[22:56] <timotimo> m: my $r = rx/foo/; say $r

[22:56] <camelia> rakudo-moar 9b25d8: OUTPUT«rx/foo/␤»

[22:56] <timotimo> m: my $r = regex { foo }; say $r

[22:56] <camelia> rakudo-moar 9b25d8: OUTPUT«{ foo }␤»

[22:56] <timotimo> hoelzro: should we also be saving the declarator into the regex source in this case

[22:57] *** skids joined
[22:58] <hoelzro> timotimo: ah, good point

[22:59] *** RabidGravy left
[22:59] <timotimo> the weekly is useful for this kind of thing :)

[23:00] *** BooK left
[23:00] *** rurban joined
[23:01] *** BooK joined
[23:01] *** amurf joined
[23:01] *** quietfanatic joined
[23:02] <quietfanatic> For the record, a general list inserter class was not what I was thinking of

[23:02] <quietfanatic> but I guess I'm glad to have accidentally inspired a good idea.

[23:03] <quietfanatic> if it is good, we don't know yet. :)

[23:03] <hoelzro> timotimo: could you ticket that up?

[23:04] <dalek> rakudo/nom: a6d2edc | lizmat++ | src/core/Code.pm:

[23:04] <dalek> rakudo/nom: Make sure we don't create Code objects willy nilly

[23:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a6d2edc644

[23:13] <timotimo> rakudo ticket or rt?

[23:14] <lizmat> it's preventing #125376

[23:14] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125376

[23:24] *** cognominal joined
[23:29] <hoelzro> timotimo: RT, please

[23:34] *** bjz left
[23:34] <timotimo> it's #125383

[23:34] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125383

[23:37] *** bjz joined
[23:38] *** bjz left
[23:41] *** gfldex left
[23:48] <lizmat> yapc::na shutting down&

[23:48] *** lizmat left
[23:51] *** quietfanatic left
[23:58] *** espadrine left
