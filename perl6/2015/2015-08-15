[00:11] *** tinyblak joined
[00:21] *** Peter_R left
[00:45] *** tadzik left
[00:45] *** tadzik joined
[00:48] *** llfourn joined
[00:53] *** llfourn left
[01:00] *** llfourn joined
[01:00] *** skids joined
[01:00] *** skids left
[01:00] *** skids joined
[01:03] *** cognominal joined
[01:04] *** llfourn left
[01:06] <timotimo> it seems like "use trace" damages something in this script

[01:06] <timotimo> so i'll try to golf a little test

[01:12] *** BenGoldberg joined
[01:35] *** dj_goku left
[01:38] <timotimo> ah, seems to be glr-only

[01:38] <timotimo> so i'll gist it rather than rakudobugging it

[01:40] <timotimo> https://gist.github.com/timo/0b64637e8b7bda922bea

[01:42] <dha> So, out of curiosity, where would be the best place to look for info on the GLR?

[01:43] <timotimo> the gist jnthn worked inside of at the beginning has a whole lot of comments and also some short test cases at the bottom

[01:44] *** AlexDaniel joined
[01:45] <dha> Ah. And where's that?

[01:46] <timotimo> gimme a sec

[01:46] <timotimo> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[01:47] <dha> Thanks.

[01:47] <timotimo> yw

[01:48] <AlexDaniel> m: say 2 ** 268435456;

[01:48] <camelia> rakudo-moar ab73b0: OUTPUT«(timeout)»

[01:48] <AlexDaniel> oh really

[01:48] <timotimo> does that surprise you? :)

[01:49] <AlexDaniel> it does

[01:49] <AlexDaniel> because

[01:49] <AlexDaniel> m: say 2 ** 99999999999999999999999999999999999

[01:49] <camelia> rakudo-moar ab73b0: OUTPUT«0␤»

[01:49] <timotimo> interesting

[01:49] <timotimo> could be something libtommath does

[01:49] <AlexDaniel> the interesting part that 268435456 prints 0 on my pc

[01:49] <AlexDaniel> but I'm on 32-bit, I guess

[01:50] <ShimmerFairy> timotimo: I found an issue the other day where nqp::pow_n return Inf, and then I did nqp::mul_n(0, Inf) -> NaN :P

[01:50] <timotimo> poor you; rakudo-m isn't so hot on 32bit

[01:50] <AlexDaniel> why that?

[01:51] <timotimo> no jit

[01:51] <AlexDaniel> besides the lack of JIT?

[01:51] <AlexDaniel> ok, well, it is not so bad without JIT

[01:51] <timotimo> all our integer registers are 64bit, too

[01:51] <AlexDaniel> I care about startup time more

[01:51] <timotimo> not 100% sure how x86_32 performance gets hit by using 64 bit numbers all over the place

[01:52] <AlexDaniel> I tell you, it's OK

[01:52] <timotimo> OK

[01:52] <timotimo> i don't mean to bother you

[01:52] <timotimo> i'd also say we may have a bit of a lack of testing for 32bit platforms, but i don't know that for sure

[01:55] <AlexDaniel> .oO(“how to find a bug in rakudo? Well, just take a huge number and put it into any function. Do you see any bugs? No? Increase the number!”)

[01:56] <dha> TEST TO FAILURE!

[01:57] <AlexDaniel> exactly

[01:57] <AlexDaniel> well, that's how I found this one: https://rt.perl.org/Public/Bug/Display.html?id=125784

[01:57] <AlexDaniel> although it is about really small numbers

[01:58] <AlexDaniel> so it should be “increase the number of digits”

[02:00] *** telex left
[02:02] *** telex joined
[02:02] <AlexDaniel> It also feels like regression

[02:03] <AlexDaniel> what was the command to run something on older versions?

[02:03] <ugexe> fetch, precompile, and test working on a glr branch with some help from json::tiny where json::pretty doesnt work yet. install/smoke tomorrow

[02:03] <AlexDaniel> I feel like we will get something different if we try the same code on 3-month old rakudo

[02:03] <ugexe> from json::fast rather

[02:04] <timotimo> star: say "hi"

[02:04] <camelia> star-m 2015.03: OUTPUT«hi␤»

[02:04] <timotimo> this is a bit older

[02:04] <AlexDaniel> star: say 2 ** 99999999999999999999999999999999999

[02:04] <camelia> star-m 2015.03: OUTPUT«0␤»

[02:04] <AlexDaniel> okay, whatever

[02:05] <AlexDaniel> I was just stupid enough not to try that earlier

[02:05] <AlexDaniel> it was probably the first thing that I ever tried running in perl6

[02:06] <AlexDaniel> with a smaller amount of digits, of course…

[02:08] <ugexe> you could find some 3 month old commit and do `rakudobrew build moar 34afwhatever` if youre feeling frisky

[02:08] <AlexDaniel> no-no, 2015.03 is good enough

[02:08] <AlexDaniel> thanks

[02:10] *** abaugher left
[02:12] <AlexDaniel> m: say 'x' if;

[02:12] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'if'␤at /tmp/ix2__2_iKj:1␤------> 3say 'x' if7⏏5;␤Whitespace required after keyword 'if'␤at /tmp/ix2__2_iKj:1␤------> 3say 'x' if7⏏5;␤Whitespace required after keyword 'if'␤at…»

[02:12] <AlexDaniel> m: say 1 if ;

[02:12] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3E2OrviEss␤Missing semicolon␤at /tmp/3E2OrviEss:1␤------> 3say 1 if 7⏏5;␤»

[02:12] <AlexDaniel> m: say 1 with ;

[02:12] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cP049uzzzc␤Confused␤at /tmp/cP049uzzzc:1␤------> 3say 1 with 7⏏5;␤»

[02:13] <AlexDaniel> I wonder why the errors are so different

[02:14] <ShimmerFairy> "Missing semicolon" is interesting, and "Confused" isn't helpful. In both cases I think a "missing conditional" message would be nicer.

[02:14] <AlexDaniel> sure, but I think that I already submitted the if thing a few weeks ago

[02:15] *** MadcapJake left
[02:15] <AlexDaniel> I mean, opened a ticket about it

[02:29] <ShimmerFairy> The  if;  thing is because immediately after that keyword the parser checks for whitespace (which is required to avoid issues with doing, say,  if(cond)  ), so that for me is an expected error.

[02:29] <AlexDaniel> with(cond) ?

[02:30] <AlexDaniel> m: with(1) { say 42 }

[02:30] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NSTfLdeQlZ␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/NSTfLdeQlZ:1␤------> 3with(1)7⏏5 { say 42 }␤    expecting any of:␤        infix␤  …»

[02:30] <AlexDaniel> what?

[02:31] <ShimmerFairy> m: if(1) { say 42 }

[02:31] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5===␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens␤at /tmp/mo_ocs6Nzp:1␤------> 3if7⏏5(1) { say 42 }␤Unexpected block in infix position (two terms in a row)␤at /tmp/mo_ocs6Nzp:1␤-----…»

[02:31] <ShimmerFairy> m: unless(1) { say 42 }

[02:31] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5===␤Word 'unless' interpreted as 'unless()' function call; please use whitespace instead of parens␤at /tmp/WptPdxZ9Ua:1␤------> 3unless7⏏5(1) { say 42 }␤Unexpected block in infix position (two terms in a row)␤at /tmp/WptPdxZ9…»

[02:31] <ShimmerFairy> m: without(1) { say 42 }

[02:31] <camelia> rakudo-moar ab73b0: OUTPUT«5===SORRY!5=== Error while compiling /tmp/7JkqB4q4vp␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/7JkqB4q4vp:1␤------> 3without(1)7⏏5 { say 42 }␤    expecting any of:␤        infix…»

[02:31] <AlexDaniel> well-well…

[02:31] <ShimmerFairy> Looks like with/without are missing some () checks :)

[02:33] *** noganex_ joined
[02:36] *** noganex left
[02:39] *** dha left
[02:46] <AlexDaniel> m: say '../../../../../../../../../../../../test'.IO.dir

[02:46] <camelia> rakudo-moar ab73b0: OUTPUT«Failed to get the directory contents of '/home/camelia/../../../../../../../../../../../../test': chdir failed: Unknown system error␤  in any  at /home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.setting.moarvm:1␤  in block <unit> at /tmp/gmjoxJFInQ…»

[02:47] <AlexDaniel> oh

[02:47] <AlexDaniel> it does not even need that sort of trickery

[02:48] <AlexDaniel> m: say 'test'.IO.dir

[02:48] <camelia> rakudo-moar ab73b0: OUTPUT«Failed to get the directory contents of '/home/camelia/test': chdir failed: Unknown system error␤  in any  at /home/camelia/rakudo-inst-1/share/perl6/runtime/CORE.setting.moarvm:1␤  in block <unit> at /tmp/YAVrapeOSz:1␤␤Actually thrown at:␤  in b…»

[02:48] <AlexDaniel> is that trace LTA or not?

[02:49] <ShimmerFairy> well, camelia runs under RESTRICTED if I recall correctly, so IO-ish stuff can't really be tested on camelia.

[02:51] <AlexDaniel> well, I get the same thing on my machine

[02:53] <AlexDaniel> haha, here is a fun one

[02:53] <AlexDaniel> m: say ('a' x 970).IO.open;

[02:53] <camelia> rakudo-moar ab73b0: OUTPUT«Failed to open file /home/camelia/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa…»

[02:53] <AlexDaniel> well, it is not visible here

[02:54] <AlexDaniel> but really it says “name too l”

[02:54] <AlexDaniel> should be “long”, but it does not fit

[02:54] <AlexDaniel> so if we go even further…

[02:54] <AlexDaniel> m: say ('a' x 1000).IO.open;

[02:54] <camelia> rakudo-moar ab73b0: OUTPUT«Failed to open file /home/camelia/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa…»

[02:54] <ShimmerFairy> I get a malformed UTF-8 error :)

[02:54] <AlexDaniel> yea

[02:55] <AlexDaniel> surprisingly, camelia has no problem with that

[02:55] <AlexDaniel> m: say ('a' x 10000).IO.open;

[02:55] <camelia> rakudo-moar ab73b0: OUTPUT«Malformed UTF-8 at line 1 col 1033␤  in block <unit> at /tmp/8ss2h3ctqB:1␤␤»

[02:55] <AlexDaniel> oh ok, it always needs more digits

[02:58] *** aborazmeh joined
[02:58] *** aborazmeh left
[02:58] *** aborazmeh joined
[03:01] *** llfourn joined
[03:01] <AlexDaniel> interesting how it is col 1033 on camelia, but col 1029 on my pc

[03:01] <AlexDaniel> same code

[03:01] <AlexDaniel> aaah

[03:01] <AlexDaniel> different path!!

[03:01] <AlexDaniel> ok, obvious

[03:05] *** llfourn left
[03:06] <AlexDaniel> m: say 'foo foo foo'.subst(/foo/, "bar", :nth(Inf));

[03:06] <camelia> rakudo-moar ab73b0: OUTPUT«Cannot coerce Inf or NaN to an Int␤  in block <unit> at /tmp/jO66bXi3eN:1␤␤Actually thrown at:␤  in block <unit> at /tmp/jO66bXi3eN:1␤␤»

[03:07] <AlexDaniel> cannot coerce Inf or NaN, yeah. What about -Inf?

[03:07] <AlexDaniel> m: say 'foo foo foo'.subst(/foo/, "bar", :nth(-Inf));

[03:07] <camelia> rakudo-moar ab73b0: OUTPUT«foo foo foo␤»

[03:07] <AlexDaniel> is it a bug?

[03:15] *** aborazmeh left
[03:17] <BenGoldberg> m: (-Inf).Int.say

[03:17] <camelia> rakudo-moar ab73b0: OUTPUT«Cannot coerce Inf or NaN to an Int␤  in block <unit> at /tmp/m4c2HYJg9f:1␤␤Actually thrown at:␤  in block <unit> at /tmp/m4c2HYJg9f:1␤␤»

[03:17] <ShimmerFairy> Inf and NaN have never really worked as Ints.

[03:18] <AlexDaniel> BenGoldberg: ok, but why -Inf works?

[03:18] <BenGoldberg> m: my $minf = -Inf; 'foo foo foo'.subst(/foo/, "bar", :nth($minf)).say;

[03:18] <camelia> rakudo-moar ab73b0: OUTPUT«foo foo foo␤»

[03:19] <BenGoldberg> I would guess that subst is testing whether the arg is less than zero, and if so, not coercing to Int.

[03:19] <AlexDaniel> hmmmm that actually makes sense

[03:20] <AlexDaniel> not a bug then

[03:20] <AlexDaniel> m: say ''.succ.succ.succ.succ;

[03:20] <camelia> rakudo-moar ab73b0: OUTPUT«␤»

[03:20] <AlexDaniel> I'm not sure that this one is correct

[03:21] <BenGoldberg> m: ''.pred.say

[03:21] <camelia> rakudo-moar ab73b0: OUTPUT«Decrement out of range␤  in block <unit> at /tmp/kN7mqD7hDm:1␤␤Actually thrown at:␤  in block <unit> at /tmp/kN7mqD7hDm:1␤␤»

[03:21] <AlexDaniel> but I can't say that it is incorrect…

[03:21] <AlexDaniel> I'm a bit worried that it might cause infinite loops

[03:21] <ShimmerFairy> m: 'foo foo foo'.subst(/foo/, "bar", :nth(-2)).say;

[03:21] <camelia> rakudo-moar ab73b0: OUTPUT«foo foo foo␤»

[03:21] <AlexDaniel> since some code can expect that a string will be changing

[03:22] <BenGoldberg> m: my $i = i; 'foo foo foo'.subst(/foo/, "bar", :nth($i)).say;

[03:22] <camelia> rakudo-moar ab73b0: OUTPUT«Earlier failures:␤ Can not convert 0+1i to Real: imaginary part not zero␤  in block <unit> at /tmp/hMtcNLxfpk:1␤␤Final error:␤ Cannot call Real(Failure: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/hMtcNLxfp…»

[03:22] <AlexDaniel> ha! That's a good one

[03:22] <AlexDaniel> I've not tried that anywhere

[03:24] <BenGoldberg> . o O (please replace the (0+i)th occurance of /foo/ with "bar" --> totally funny)

[03:25] *** cognominal left
[03:25] <AlexDaniel> and I bet that there is a function somewhere that will actually attempt to do something like that

[03:28] <PerlJam> weird

[03:29] <PerlJam> :nth($negative_number) should die

[03:31] <AlexDaniel> m: say "x".indent: 9999999999999999999999999999999999999999999999

[03:31] <camelia> rakudo-moar ab73b0: OUTPUT«repeat count > 1073741824 arbitrarily unsupported...␤  in block <unit> at /tmp/DyvYVeDRDt:1␤␤»

[03:31] <AlexDaniel> oooh, riight! Let's add more digits!!!

[03:31] <ShimmerFairy> PerlJam: yeah, I saw a check for it in Str.match , but I guess it's not getting caught?

[03:31] <AlexDaniel> m: say "x".indent: 9999999999999999999999999999999999999999999999999999999999999999999999999;

[03:31] <camelia> rakudo-moar ab73b0: OUTPUT«repeat count (-1) cannot be negative␤  in block <unit> at /tmp/Tt_fkQcA_f:1␤␤»

[03:32] *** gfldex left
[03:36] <AlexDaniel> m: say 'xx'.chop(10)

[03:36] <camelia> rakudo-moar ab73b0: OUTPUT«␤»

[03:36] <AlexDaniel> m: say 'xx'.chop(9999999999999999999999999999999999999999999999999999999);

[03:36] <camelia> rakudo-moar ab73b0: OUTPUT«xx␤»

[03:41] <PerlJam> AlexDaniel: are you rakudobugging these if they're not already?

[03:42] <AlexDaniel> PerlJam: most of it 

[03:43] <PerlJam> AlexDaniel++

[03:43] <AlexDaniel> PerlJam: I did not report :nth that should actually die, should I do that?

[03:43] <PerlJam> probably

[03:44] <AlexDaniel> PerlJam: can you point me to the relevant source code?

[03:44] <PerlJam> For what exactly?

[03:44] <AlexDaniel> the check for negative numbers in subst

[03:46] <PerlJam> src/core/Str.pm line 606 is where the check is that should catch it IMHO

[03:46] <PerlJam> (though it's slightly erroneous in that the conditional is checking for < 1, but the fialure says "negative match".  It forgets about 0)

[03:47] *** lizmat joined
[03:47] <ShimmerFairy> PerlJam: then it should talk about only allowing positive values :P

[03:47] <AlexDaniel> PerlJam: thanks

[03:48] <ShimmerFairy> (since :0th doesn't mean anything with the :st/:nd/:rd/:th adverbs)

[03:51] *** kaare_ left
[03:53] *** tinyblak left
[03:53] *** BenGoldberg left
[03:55] *** inokenty left
[04:06] *** aborazmeh joined
[04:06] *** aborazmeh left
[04:06] *** aborazmeh joined
[04:10] <AlexDaniel> m: say chr 999999999999999999999999999;

[04:10] <camelia> rakudo-moar ab73b0: OUTPUT«chr codepoint cannot be negative␤  in block <unit> at /tmp/TVBVh1Yy8e:1␤␤»

[04:17] <labster> AlexDaniel: quit finding integer overflow errors, you're making us look bad :P

[04:17] <AlexDaniel> I'm making us look good

[04:18] <AlexDaniel> I bet that today or tomorrow someone will pick these tickets

[04:18] <labster> Yeah, they're pretty obvious.  And great test candidates.

[04:19] <AlexDaniel> I keep thinking though

[04:19] <AlexDaniel> WHY AM I THE FIRST ONE TO TRY ALL THAT STUFF?

[04:19] <AlexDaniel> but yeah, it happens :)

[04:19] <labster> :T in signatures is dead right, and :U refers to a type object (not undefined) now?

[04:20] <AlexDaniel> no idea

[04:20] <labster> You're the first one to to try it because the domain of a programming language is huge, and we're just trying to get correct stuff to work right.

[04:21] <ShimmerFairy> labster: yeah, :U and :D have had a type object/object instance distinction for a long time now

[04:22] <ShimmerFairy> labster: the only spec'd difference was that Int:U would accept Failures and Int:T wouldn't, but the Failure type (at least nowadays) would never pass an 'Int' constraint regardless of the smiley. Which meant :T was NYI and redundant.

[04:23] <AlexDaniel> m: say Inf.base(16);

[04:23] <camelia> rakudo-moar ab73b0: OUTPUT«Type check failed in assignment to '$int_part'; expected 'Int' but got 'Failure'␤  in block <unit> at /tmp/6tEXSrGnv0:1␤␤»

[04:24] <labster> Oh good, RT#114442 is closable.  "<jnthn> I'm hoping if I ignore the spec change enough it may change back :P" jnthn++

[04:24] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=114442

[04:24] <AlexDaniel> that's the weirdest error message

[04:25] <AlexDaniel> expected Int but got Failure :D

[04:25] <AlexDaniel> sounds like Inf is a Failure

[04:27] <labster> Yeah, it's erroring in an assignment which you're not doing... LTA error for sure.

[04:27] <AlexDaniel> yup

[04:29] <labster> m: my Int $int_part = (Inf).Int;

[04:29] <camelia> rakudo-moar ab73b0: OUTPUT«Type check failed in assignment to '$int_part'; expected 'Int' but got 'Failure'␤  in block <unit> at /tmp/smW6yhbeTR:1␤␤»

[04:34] <labster> What should that return, anyway?  Failure or Inf?

[04:35] <AlexDaniel> valid hex number or failure

[04:35] <AlexDaniel> Inf does not sound like a hex number

[04:35] <ShimmerFairy> labster: Inf and NaN have been an interesting thorn in our numerics for a long time

[04:36] <ShimmerFairy> labster: for now at least, Failure is the better choice.

[04:36] <labster> Inf is a decimal number, isn't it?

[04:36] <ShimmerFairy> m: say Inf.WHAT; say NaN.WHAT

[04:36] <camelia> rakudo-moar ab73b0: OUTPUT«(Num)␤(Num)␤»

[04:37] <ShimmerFairy> They're (Num)s, but since Int !~~ Num, they can't be used with Ints.

[04:37] <ShimmerFairy> And you can't coerce them to Ints either, since there's nothing Int-y to coerce them to.

[04:38] <labster> m: 1.05.base(16).say

[04:39] <ShimmerFairy> m: 1.05.base(16).say

[04:39] <camelia> rakudo-moar ab73b0: OUTPUT«1.0CCCCD␤»

[04:39] <AlexDaniel> huh?

[04:39] <ShimmerFairy> labster accidentally typed an italic formatting code in front of the m:

[04:40] <labster> well, accidentally copied.

[04:41] <AlexDaniel> m: say 9e-99.base(10).say

[04:41] <camelia> rakudo-moar ab73b0: OUTPUT«0.00000000␤True␤»

[04:42] <AlexDaniel> oops

[04:42] <AlexDaniel> but yea, it is a little bit weird

[04:44] *** aborazmeh left
[04:44] <labster> m: 9e-99.base(10, 100).say

[04:44] <camelia> rakudo-moar ab73b0: OUTPUT«0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090␤»

[04:49] <AlexDaniel> m: say 255.base(16, -100);

[04:49] <camelia> rakudo-moar ab73b0: OUTPUT«FF.␤»

[04:49] <AlexDaniel> From the docs: “The optional $digits argument asks for that many digits of fraction (which may not be negative).”

[04:50] <AlexDaniel> m: say 255.base(16, 99999999999999999999999999999999999999999999999999999999999999999999999999999);

[04:50] <camelia> rakudo-moar ab73b0: OUTPUT«repeat count (-1) cannot be negative␤  in block <unit> at /tmp/XnmR6Ud6gb:1␤␤»

[04:51] *** khw left
[05:01] <AlexDaniel> ok, enough for today

[05:02] *** llfourn joined
[05:06] *** llfourn left
[05:06] *** cognominal joined
[05:06] <labster> AlexDaniel's 9-9-9 plan for Perl 6.

[05:07] *** baest joined
[05:07] <AlexDaniel> 1999--14035828--4570789517646521952 plan

[05:09] *** baest_ left
[05:16] <AlexDaniel> m: say <a b c d e>.roll(-999999999999999999999999999999999999999999999999999999).perl;

[05:16] <camelia> rakudo-moar ab73b0: OUTPUT«(timeout)»

[05:16] <AlexDaniel> m: say <a b c d e>.roll(-999999999999999999999999999999999999999999999999999999999999999999999999999999).perl;

[05:16] <camelia> rakudo-moar ab73b0: OUTPUT«("c",)␤»

[05:24] <lizmat> m: use nqp; say nqp::unbox_i(-99999999999999999999999999999999999999999999999999999999999999999)   # the underlying issue to all these tickets

[05:24] <camelia> rakudo-moar ab73b0: OUTPUT«1␤»

[05:24] <lizmat> if we get nqp::unbox_i to complain about this in a sensible way, all of these tickets can be closed

[05:28] <AlexDaniel> sounds very promising

[05:28] <AlexDaniel> good night

[05:32] *** breinbaas left
[05:36] *** rurban joined
[05:40] *** jack_rabbit joined
[05:44] *** dayangkun joined
[05:53] *** AlexDaniel left
[06:04] *** domidumont joined
[06:09] *** domidumont left
[06:09] *** domidumont joined
[06:10] <dalek> rakudo/glr: 1c63a75 | PerlJam++ | src/core/List.pm:

[06:10] <dalek> rakudo/glr: Utilize is-lazy

[06:10] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1c63a75804

[06:10] <dalek> rakudo/glr: 2ba1973 | PerlJam++ | src/core/List.pm:

[06:10] <dalek> rakudo/glr: Make List.rotate work again

[06:10] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2ba1973584

[06:26] *** tinyblak joined
[06:29] *** RabidGravy joined
[06:33] *** bin_005 left
[06:33] <RabidGravy> marning!

[06:37] *** cognominal left
[06:46] *** skids left
[06:49] *** skids joined
[06:50] *** skids left
[07:01] *** rurban left
[07:03] *** llfourn joined
[07:06] *** brrt joined
[07:08] *** llfourn left
[07:15] *** rurban joined
[07:16] *** virtualsue joined
[07:16] *** rurban_ joined
[07:20] *** TEttinger left
[07:21] *** rindolf joined
[07:25] <brrt> good morning again

[07:27] <RabidGravy> erp

[07:34] *** breinbaas joined
[07:51] <[Tux]> test             50000    44.301    44.209

[07:51] <[Tux]> test-t           50000    43.254    43.163

[07:52] * [Tux] did not expect any speedup with all tuits flowing into GLR

[07:53] <[Tux]> hmm, that could be read both ways. it actually is slower than yesterday

[08:00] <RabidGravy> :)

[08:09] <_itz_> I did see a slight apparent speed up with a script just using scalars on glr branch (maybe 1 s off a ~12s test)

[08:10] <_itz_> maybe because less code is running with sections commented out however

[08:11] *** rindolf left
[08:15] *** darutoko joined
[08:50] <nine> |Tux|: have you tried it on the GLR?

[08:52] <_itz_> ^ clarification to above - I meant commented out sections in rakudo not my simple script

[08:52] <nine> |Tux|: since Inline::Perl5 already works (at least its glr branch), maybe your test will too :)

[09:03] * RabidGravy adds a paragraph to a README to get over the Saturday commit hump ;-)

[09:04] *** llfourn joined
[09:08] *** llfourn left
[09:12] *** rurban left
[09:23] *** RabidGravy left
[09:23] *** rurban_ left
[09:36] <[Tux]> rakudobrew build glr?

[09:36] <[Tux]> and for the timeing, I do not need/use Inline::Perl5

[09:38] <jdv79> [Tux]: where are your tests?

[09:41] *** itz joined
[09:41] *** itz left
[09:43] *** dayangkun left
[09:45] *** FROGGS_ joined
[09:48] *** FROGGS left
[09:58] *** espadrine joined
[09:59] *** rindolf joined
[10:01] *** domidumont left
[10:05] <jnthn> "Oh look, if I give a function a stupid value something stupid happens!" <loads of checks added> "Hey, why is Rakudo slow???"

[10:06] <jnthn> I suspect putting the check in unbox_i will be the cheapest place, though, since it already has the fast-path for smaller values, so it's only when there's something stored in a real bigint that you need to do the extra checking.

[10:08] *** llfourn joined
[10:11] *** brrt left
[10:12] *** llfourn left
[10:13] *** llfourn joined
[10:14] <jdv79> whats the alternative to hardening the surfaces?

[10:15] <jnthn> jdv79: "Garbage In, Garbage Out"? :)

[10:15] <jnthn> I'm all for good errors and checks on things people run into

[10:15] <jdv79> so p6bwill be like C?

[10:15] <jdv79> haha

[10:15] <ShimmerFairy> jnthn: it would be sufficient to check if the number of the limbs is greater than can be stored, wouldn't it? (at least on moar)

[10:15] <jnthn> But if you find a string of things and say "How come nobody noticed this in years?" it's because you're observing something that doesn't actually happen.

[10:16] <jnthn> In normal code.

[10:16] <jdv79> ok

[10:16] *** tinyblak left
[10:17] <jdv79> more like hasnt happened yet:)

[10:22] *** orafu left
[10:22] <nine> Well chances of the examples happening in real world code are rather slimm I'd guess

[10:23] <jnthn> nine: Yes, my feeling exactly

[10:23] <ShimmerFairy> I think bigint -> int overflow is worth protecting against, but in general I agree with the principle of "Well, what were you expecting would happen?" :)

[10:23] <jdv79> yeah.  seems all minor.

[10:23] <ShimmerFairy> (aka GIGO)

[10:24] <jnthn> ShimmerFairy: Yeah, I think we can protect against that, but I don't want to see extra checks scattered through all the functions in question.

[10:26] <jdv79> any clue as to when real world code can try the glrized rakudo?

[10:26] <nine> depends on the code

[10:26] <ShimmerFairy> jnthn: of course not. I for example only put in a check against against overflow-related issues when  nqp::mul_n(0, nqp::pow_n($base, $exp))  could result in 0 * Inf -> NaN .

[10:28] <jdv79> ok

[10:28] *** tinyblak joined
[10:29] <dalek> rakudo/glr: ad13342 | jnthn++ | src/core/Seq.pm:

[10:29] <dalek> rakudo/glr: AT-POS and EXISTS-POS on Seq delegate to .list.

[10:29] <dalek> rakudo/glr: 

[10:29] <dalek> rakudo/glr: We may tighten the exact semantics of this at some point, but for now

[10:29] <dalek> rakudo/glr: this is close enough. Makes it so you can do things like .words[1],

[10:29] <dalek> rakudo/glr: which is hugely common. Note that obtaining the memoized list counts

[10:29] <dalek> rakudo/glr: as doing the one-shot iteration of the Seq.

[10:29] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ad13342dac

[10:29] *** breinbaas left
[10:29] <jnthn> ShimmerFairy: On the ** one, the deep problem is that both Moar and JVM's bigint library can only cope with a 32-bit (or maybe 64-bit) exponent

[10:30] <jnthn> Probably because you can't ever have enough memory to store anything other than 1 ** [huge huge thing] :)

[10:31] <jnthn> m: say (2 ** 10000).chars

[10:31] <camelia> rakudo-moar ab73b0: OUTPUT«3011␤»

[10:31] <jnthn> m: say (2 ** 100000).chars

[10:31] <camelia> rakudo-moar ab73b0: OUTPUT«30103␤»

[10:31] <jnthn> m: say (2 ** 1000000000).chars

[10:31] *** pmurias joined
[10:31] <dalek> nqp/js: 43700ac | (Pawel Murias)++ | src/vm/js/ (3 files):

[10:31] <dalek> nqp/js: Implement nqp::knowhow()

[10:31] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/43700ace11

[10:31] <dalek> nqp/js: eaf6114 | (Pawel Murias)++ | src/vm/js/nqp-runtime/bootstrap.js:

[10:31] <dalek> nqp/js: Add a new_type method to knowhows

[10:31] *** dalek left
[10:31] <camelia> rakudo-moar ab73b0: OUTPUT«(timeout)»

[10:31] <jnthn> Well, maybe that one was a little ambitious :)

[10:32] <jnthn> m: say (2 ** 10000000).chars

[10:32] *** dalek joined
[10:32] *** ChanServ sets mode: +v dalek

[10:32] <camelia> rakudo-moar ab73b0: OUTPUT«(timeout)»

[10:32] <jnthn> Even that one :)

[10:33] <jnthn> m: say <0x01/0x03> / (0x01/0x03) == 1

[10:33] <camelia> rakudo-moar ab73b0: OUTPUT«True␤»

[10:33] <jnthn> How on earth has glr busted *that*... 

[10:34] <jnthn> m: say <0x01/0x03>; say (0x01/0x03);

[10:34] <camelia> rakudo-moar ab73b0: OUTPUT«0.333333␤0.333333␤»

[10:34] <jnthn> Hm, it's the first one that fails

[10:35] <jnthn> m: say <0x01/0x03>.nude

[10:35] <camelia> rakudo-moar ab73b0: OUTPUT«1 3␤»

[10:35] <pmurias> jnthn: re checking for stupid values, having them cause weird things to happen silently makes debugging harder

[10:38] <timotimo> error: cowardly refusing to allocate 5tb of nulled memory to store the result of this operation"

[10:40] <ShimmerFairy> jnthn: sure, I don't blame the implementation for saying "eh, it's practically infinity, right?", I just had to correct for the fact that 0 * anything should for sanity always return 0 (esp. when you can't write 'Inf' in a numeric literal :P)

[10:47] <nine> Huh? I though I fixed the hangs in S03-operators/assign.t?

[10:48] <dalek> rakudo/glr: 295e65d | jnthn++ | src/core/List.pm:

[10:48] <dalek> rakudo/glr: Remove XXX GLR comments on completed things.

[10:48] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/295e65d2af

[10:51] <nine> Oh, I'm in the wrong roast branch on this machine

[10:52] <nine> jdv79: oh, real world code may benefit immensely from having panda work again before testing.

[10:53] <jnthn> nine: Is all Inline::Perl5 working again on glr? :)

[10:53] <nine> jnthn: well, excluding one test file that's failing because I can't install File::Temp, yes :)

[10:55] <jnthn> Nice :)

[10:55] <jnthn> I don't see how the failure in numeric.t that I have is related to glr at all

[10:55] <jnthn> But I see that test is marked as bust on JVM too

[10:55] <jnthn> And I'm wondering if it works on some platforms only

[10:56] <jnthn> 'cus now I think about it, I had a Windows failure in numeric.t for a while

[10:56] <nine> Maybe the glr just uncovered the fail on moar?

[10:56] <jnthn> No, I think it just confused me into spending time hunting a bug that was only there on some platforms, including mine :)

[10:57] <nine> jnthn: both t/spec/S02-literals/numeric.t and t/spec/S32-str/numeric.rakudo.moar pass for me on glr

[10:59] <jnthn> nine: OK, then it's not glr at all, but a platform-o :)

[11:09] <nine> That's...intriguing. Str.trans hangs in $!first_substitution //= @!substitutions[0]; in LSM::next_substitution

[11:10] <jnthn> Curious...

[11:10] <nine> @!substitutions[0] seems to be a Pair, just like it should

[11:11] <nine> Oh, no. It doesn't hang there, it's just that warn $!first_substitution afterwards would hang. Smells like another self referencing data structure.

[11:12] *** gfldex joined
[11:15] <dalek> rakudo/glr: 8fe549c | jnthn++ | src/core/Array.pm:

[11:15] <dalek> rakudo/glr: Mostly re-instate typed Array support.

[11:15] <dalek> rakudo/glr: 

[11:15] <dalek> rakudo/glr: Toss no-longer-needed specialized AT-POS along the way.

[11:15] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/8fe549c943

[11:15] <dalek> rakudo/glr: 6ae42ca | jnthn++ | src/Perl6/Actions.nqp:

[11:15] <dalek> rakudo/glr: Make <0x01/0x03> work reliably across platforms.

[11:15] <dalek> rakudo/glr: 

[11:15] <dalek> rakudo/glr: Fixes it on Windows, and probably on JVM too.

[11:15] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6ae42cad58

[11:16] <nine> Oh, yes, there's our little self referencer: @to = @to, $padding xx @from - @to;

[11:17] <jnthn> Odd

[11:18] <jnthn> huh

[11:18] <ShimmerFairy> So if you wanted to do something silly like  @a = @a, @a  , would you have to call clone on the assigned @a vars in GLR? (and could @a = @b suffer from similar problems?)

[11:18] <nine> @to = flat @to, $padding xx $from - @to; works better

[11:19] <jnthn> Darn, the @a = 1, @a; case wasn't covered in my tests in glr.p6

[11:19] <jnthn> @a = @a was, along with @a = @a.map(...)

[11:20] <jnthn> nine: I think the flat is actually needed there also

[11:20] *** dayangkun joined
[11:22] <jnthn> The reason taht kind of things worked before now is exactly because we flattened automatically there

[11:22] <jnthn> I think it's quite clear that option isn't available to us

[11:22] <jnthn> (implicitly, I mean)

[11:22] <jnthn> Oh, it's worse

[11:23] <jnthn> TimToady even was thinking about @a = 1, @a; or similar being a way to get an array of all 1s

[11:23] <jnthn> That won't work at least without adding a slip for lazy somewhere, I suspect

[11:23] <ShimmerFairy> could a self-referential assignment be detected, and possibly be made lazy?

[11:24] <jnthn> But yeah, with that working in mind I even explicitly made sure you get into circular references there

[11:24] <dalek> rakudo/glr: 940c99b | (Stefan Seifert)++ | src/core/Str.pm:

[11:24] <dalek> rakudo/glr: Fix hang in Str.trans caused by self referencing array

[11:24] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/940c99bb44

[11:25] <ShimmerFairy> or perhaps not all self-referential assignments, but at least the ones that make for a circular list (i.e. @a = foo, bar, ..., @a)

[11:25] <jnthn> ShimmerFairy: It guess that one could be detected in STORE

[11:25] <jnthn> I'm not sure that lazy fixes it

[11:26] <jnthn> And further, @a = 1, @a; magically becoming @a = 1, lazy @a; suddenly gives you an @a that is lazy, so you could no longer push to it, for example

[11:27] <ShimmerFairy> Hm, now that I'm thinking about it, maybe an ability to make circular lists would be helpful for things like 1 xx Inf (unless Seq already takes care of that)

[11:27] <nine> Huh? There's suddenly a hang in S02-types/array-shapes.rakudo.moar

[11:27] <nine> That wasn't there before

[11:27] <nine> May be because of the new typed array support

[11:28] <nine> l

[11:28] <jnthn> maybe, yes

[11:29] <jnthn> It was crashing before I think

[11:29] <jnthn> urgh, I think the next blocker I really need to take on is the for %h.kv -> $k, $v { ... } bustage

[11:30] <jnthn> On @a = 1, @a; maybe it should just be an error

[11:31] <jnthn> "Probable unintended assignment of array into an element of itself; consider using |@a or flat"

[11:32] * TimToady and company now in Kyoto

[11:32] <jnthn> \o/

[11:32] <jnthn> TimToady: Hope the journey was fine :)

[11:32] <TimToady> kinda bumpy from SEA to YVR, but otherwise uneventful

[11:33] <nine> jnthn: this is what hangs: use Test; my int @arr = 1, 2, 3; is @arr, <1 2 3>;

[11:33] <jnthn> nine: ah

[11:33] <jnthn> nine: Half of native array code is still commented out, I think :)

[11:33] <nine> looks like :)

[11:34] <nine> So, afk now. Weekend at my parents'.

[11:34] <jnthn> Have fun

[11:35] <jnthn> nine++ # glr hacking

[11:42] <dalek> rakudo/glr: b5dc2c5 | jnthn++ | src/core/Array.pm:

[11:42] <dalek> rakudo/glr: Fix my @a = $thing (used to bind by accident).

[11:42] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b5dc2c593f

[11:43] *** beastd left
[11:45] *** isBEKaml joined
[11:53] <jnthn> Damn, the meta-ops are going to need a good looking at

[11:54] <jnthn> They went out of their way to work against the previous list implementation, leaving a good bit to untangle

[11:54] <isBEKaml> jnthn: the GLR?

[11:54] <jnthn> aye

[11:54] <[Tux]> jdv https://github.com/Tux/CSV

[11:54] <[Tux]> jdv79, https://github.com/Tux/CSV

[11:54] <[Tux]> make time

[11:55] <isBEKaml> jnthn: Oh.. weren't they caught by tests?

[11:55] <jnthn> isBEKaml: Very caught by the tests

[11:55] *** dayangkun left
[11:55] <jnthn> (glr branch has 200 failing test files or so at present)

[11:56] * isBEKaml doesn't know if we should be relieved or worried 

[11:57] *** cognominal joined
[11:58] <jnthn> Relieved that it's not more.

[11:59] <isBEKaml> jnthn++ # keepin' it real

[12:01] <ShimmerFairy> I think people not working on glr should only really be concerned about the tests if we were failing more than existed :P

[12:02] *** tinyblak left
[12:12] *** dalek left
[12:13] *** dalek joined
[12:13] *** ChanServ sets mode: +v dalek

[12:17] *** dalek left
[12:17] *** dalek joined
[12:17] *** ChanServ sets mode: +v dalek

[12:18] <isBEKaml> ShimmerFairy: fair enough :-)

[12:27] <dalek> rakudo/glr: 3526378 | jnthn++ | src/core/Any-iterable-methods.pm:

[12:27] <dalek> rakudo/glr: Fix map with > 1 arg closure.

[12:27] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/3526378723

[12:27] <jnthn> That should unbust another good number of things :)

[12:29] <jnthn> Going to lunch, relax, etc. &

[12:31] <jdv79> [Tux]: ah.  its Text::CSV. cool.

[12:37] *** dalek left
[12:38] *** dalek joined
[12:38] *** ChanServ sets mode: +v dalek

[12:38] <dalek> rakudo-star-daily: a6da8d3 | coke++ | log/MoarVM- (4 files):

[12:38] <dalek> rakudo-star-daily: today (automated commit)

[12:38] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/a6da8d3436

[12:38] <dalek> perl6-roast-data: 65970cd | coke++ | / (8 files):

[12:38] <dalek> perl6-roast-data: today (automated commit)

[12:38] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/65970cd46c

[12:42] *** [Sno] joined
[12:49] *** dalek left
[12:50] *** dalek joined
[12:50] *** ChanServ sets mode: +v dalek

[12:56] *** AlexDaniel joined
[12:57] *** cognominal left
[13:00] <AlexDaniel> jnthn: well, feel free to close some of these tickets

[13:00] <AlexDaniel> however, number ** hugenumber = 0 is a math problem…

[13:01] <[Coke]> my connection to p6c keeps dropping. wonder how to diagnose that.

[13:02] <AlexDaniel> and a couple of others are LTAs anyway, because you cannot say that the argument was negative when it actually wasn't

[13:02] *** tinyblak joined
[13:02] <AlexDaniel> at least it should mention possible overflow

[13:06] *** cognominal joined
[13:08] *** tinyblak left
[13:12] *** rmgk left
[13:13] *** rmgk joined
[13:15] *** isBEKaml_ joined
[13:16] *** mr_ron joined
[13:17] *** tinyblak joined
[13:18] *** isBEKaml left
[13:20] *** smls joined
[13:20] <nine> jnthn: thanks for fixing up my sequential-map implementation :)

[13:21] *** isBEKaml_ is now known as isBEKaml

[13:21] <nine> [Tux]: looks like there's still too much brokenness to get CSV benchmark results. But I'm sure we'll be getting there soon :)

[13:21] *** espadrine left
[13:23] <[Coke]> (seriously, I've been disconnected like 20 times and can only type a few characters each time before I get kicked. it took me 4 disconnects to type this line. *:( AIGH FIVE

[13:26] *** mr_ron left
[13:29] <timotimo> [Coke]: argh!

[13:30] <timotimo> [Coke]: did you try ssh -v or -vv or -vvv or -vvvv or -vvvvv or -vvvvvv or -vvvvvvv or -vvvvvvvv?

[13:30] <timotimo> m: .print for "-" >>~>> ("v" x 1..*) >>~>> ' or '

[13:30] <camelia> rakudo-moar ab73b0: OUTPUT«List on right side of hyperop of infix:<~> is known to be infinite␤  in block <unit> at /tmp/XvT_yP5e5d:1␤␤»

[13:31] <timotimo> oh, of course

[13:31] <timotimo> m: .print for "-" >>~>> ("v" x 1..50) >>~>> ' or '

[13:31] <camelia> rakudo-moar ab73b0: OUTPUT«Cannot find method 'Range'␤  in block <unit> at /tmp/FFO2zc4qGD:1␤␤»

[13:31] <timotimo> m: .print for "-" >>~>> ("v" Zx 1..50) >>~>> ' or '

[13:31] <camelia> rakudo-moar ab73b0: OUTPUT«-v or »

[13:31] <timotimo> m: .print for "-" >>~>> ("v" Zx @(1..50)) >>~>> ' or '

[13:31] <camelia> rakudo-moar ab73b0: OUTPUT«-v or »

[13:31] <[Coke]> timotimo: -v gives lots of diagnostics on connect, but not on disconnect.

[13:31] <timotimo> derp

[13:31] <[Coke]> might be due to screen formatting wonkery

[13:31] <timotimo> m: .print for "-" >>~>> ("v" Xx 1..50) >>~>> ' or '

[13:31] <camelia> rakudo-moar ab73b0: OUTPUT«Lists on either side of non-dwimmy hyperop of infix:<~> are not of the same length␤left: 1 elements, right: 50 elements␤  in block <unit> at /tmp/oQjiUAbI8D:1␤␤»

[13:31] <timotimo> m: .print for "-" <<~>> ("v" Xx 1..50) <<~>> ' or '

[13:31] <camelia> rakudo-moar ab73b0: OUTPUT«-v or -vv or -vvv or -vvvv or -vvvvv or -vvvvvv or -vvvvvvv or -vvvvvvvv or -vvvvvvvvv or -vvvvvvvvvv or -vvvvvvvvvvv or -vvvvvvvvvvvv or -vvvvvvvvvvvvv or -vvvvvvvvvvvvvv or -vvvvvvvvvvvvvvv or -vvvvvvvvvvvvvvvv or -vvvvvvvvvvvvvvvvv or -vvvvvvvvvvvvvvvvv…»

[13:32] <timotimo> that took me longer than i would have deemed appropriate for a perl6 "core developer" :S

[13:32] <[Coke]> also, login seems to be taking longer and longer on hack.

[13:35] *** aborazmeh joined
[13:35] *** aborazmeh left
[13:35] *** aborazmeh joined
[13:36] <bartolin_> [Coke]: I had no problems logging in to hack just now

[13:36] <timotimo> i can connect and log in very quickly to hack, as well

[13:37] <[Coke]> Probably my local wifi.

[13:37] <timotimo> d'oh

[13:37] <lizmat> .tell jnthn if nqp::unbox_i gets some overflow test/exception, I can remove as well some of the tests in functions I added recently

[13:37] <yoleaux> lizmat: I'll pass your message to jnthn.

[13:37] <timotimo> maybe we want to install the bad-connection-resistant ssh thingie

[13:37] <timotimo> what was it called? mosh?

[13:39] <bartolin_> [Coke]: I don't see something unusual in sshd logs as well. so probably no problem on hack

[13:42] <[Coke]> heh. you are the second person to mention mosh in relation to my issue here. :)

[13:43] <timotimo> the thing about mosh is it needs cooperation from the server admins :|

[13:47] <AlexDaniel> lizmat: good point

[13:50] <bartolin_> timotimo: hmm, I could connect to hack with mosh just fine. (have never used it before)

[13:51] <timotimo> uh, huh?

[13:52] <timotimo> perhaps mosh falls back to regular ssh if the server doesn't provide it? or perhaps it's installed on hack

[13:52] <bartolin_> yeah, it's installed.

[13:52] <timotimo> coool

[13:53] <bartolin_> moritz++

[13:53] *** Peter_R joined
[13:57] *** laben joined
[13:57] <laben> hello p6'ers!

[13:58] <timotimo> ohai laben 

[13:59] <timotimo> are you at all related to gaben?

[13:59] <laben> you mean Gabe Newell? i wish! i would ask him a preview of HL3

[14:00] <timotimo> hehe

[14:02] <laben> so, i tracked down a build failure in 2 modules to an issue between precompilation and delegations, are you interested?

[14:02] <timotimo> me? oof

[14:02] <timotimo> how tight is the golf?

[14:03] <isBEKaml> In other news, pugs seems to be back! https://github.com/perl6/Pugs.hs/pull/30

[14:04] <isBEKaml> Sorry if you guys already know this

[14:04] <laben> timotimo: you personally interested? sweet, i'm making a gist right now!

[14:05] <timotimo> ugh

[14:05] *** telex left
[14:05] <timotimo> precompilation is really tough

[14:05] <timotimo> my mood is kind of down in the dumps right now, not sure i'll be able to be productive at all

[14:06] *** telex joined
[14:07] <laben> here it is: https://gist.github.com/anonymous/f7d4c489df5fc5eecda3

[14:08] <laben> from what i gathered myself, the issue is that delegate of delegate works fine when not precompiled, but crashes when precompiling FILE C.pm6

[14:08] <timotimo> you know gist has multi-file support? :P

[14:08] <laben> timotimo: sorry, did not know

[14:09] *** MadcapJake joined
[14:11] <timotimo> no worries :)

[14:12] <laben> want me to create a new multi file gist?

[14:12] <timotimo> no need

[14:13] <timotimo> also, you can edit the gist and add files after the first submit

[14:13] <dalek> nqp: 52b7ced | ShimmerFairy++ | src/HLL/Grammar.nqp:

[14:13] <dalek> nqp: Add support for Unicode hexints, octints, and binints.

[14:13] <dalek> nqp: 

[14:13] <dalek> nqp: This removes the range checks for octal and binary numbers, but as a

[14:13] <dalek> nqp: bonus Perl 6 will now report a number like 0o78 as "'78' is not a valid

[14:13] <dalek> nqp: number", instead of previously saying "Confused". The underlying radix

[14:13] <dalek> nqp: conversion functions properly check digits against the radix anyway

[14:13] <dalek> nqp: (which is how the "not a valid number" error now pops up).

[14:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/52b7ced5f5

[14:13] <dalek> nqp: 4e374ec | ShimmerFairy++ | src/HLL/Grammar.nqp:

[14:13] <dalek> nqp: Merge branch 'uninum'

[14:13] <dalek> nqp: 

[14:13] <dalek> nqp: Enable Unicode numeral support in NQP.

[14:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4e374ecc33

[14:13] <dalek> nqp: 733bf22 | ShimmerFairy++ | tools/build/MOAR_REVISION:

[14:13] <dalek> nqp: Bump MOAR_REVISION

[14:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/733bf22368

[14:13] <lizmat> .tell FROGGS re #125796, it looks like EOF is not set in the same way for an IO::Handle coming from open or from run :out

[14:13] <yoleaux> lizmat: I'll pass your message to FROGGS.

[14:13] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125796

[14:13] <dalek> rakudo/nom: 2a9ab2b | ShimmerFairy++ | t/spectest.data:

[14:13] <dalek> rakudo/nom: Add S15-literals tests to spectest.data

[14:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2a9ab2b79d

[14:13] <dalek> rakudo/nom: 0217016 | ShimmerFairy++ | src/Perl6/Grammar.nqp:

[14:13] <dalek> rakudo/nom: Add Unicode support to :radix[] style numbers.

[14:13] *** dalek left
[14:14] *** dalek joined
[14:14] *** ChanServ sets mode: +v dalek

[14:17] <timotimo> laben: do you have the commandline invocation you're using to show this error?

[14:17] <timotimo> perl6 --target=mbc --outfile=B.moarvm B.pm6  # like this?

[14:17] <lizmat> ShimmerFairy: does that mean an NQP_REVISION bump is immiment?

[14:17] <laben> yea but remember '_i.'

[14:17] <laben> -I. i meant

[14:17] <lizmat> *imminent

[14:18] <ShimmerFairy> lizmat: there was one, dalek just gave out before it could show it

[14:18] <timotimo> ah, --output

[14:18] <lizmat> ah, ok

[14:18] * lizmat pulls and rebuilds

[14:18] <timotimo> laben: When pre-compiling a module, its dependencies must be pre-compiled first.

[14:18] <timotimo> is this the error you're seeing?

[14:18] *** khw joined
[14:19] <laben> timotimo: ofc not, fisrt you precompile B.pm6

[14:19] <laben> then when precompileing C.pm6 you get "Cannot invoke object..."

[14:20] <timotimo> i'm failing here.

[14:20] <dalek> roast: 9717b4f | ShimmerFairy++ | S15-literals/numbers.t:

[14:20] <dalek> roast: Unfudge Unicode numbers tests for moar

[14:20] <dalek> roast: review: https://github.com/perl6/roast/commit/9717b4f299

[14:20] <laben> timotimo: better now? https://gist.github.com/anonymous/89624af3959c7fb86c62

[14:21] *** aborazmeh left
[14:21] <timotimo> i tried perl6 --target=mbc --output=B.moarvm B.pm6  and then  perl6 -I. --target=mbc --output=C.moarvm C.pm6

[14:23] <laben> did it work? i get an error precompiling C.pm6, saying "SORRY   Cannot invoke this object (REPR: Null, cs = 0)"

[14:23] <timotimo> no

[14:23] <timotimo> Please pre-compile /tmp/laben_gist/B.pm6

[14:24] <laben> timotimo: ofc before i precompile B.pm6, that gives me no error

[14:24] <laben> timotimo: btw i confirmed that not precompiling, everything works fine

[14:24] <timotimo> wait, you mean you don't precompile B?

[14:25] <laben> timotimo: no, i do precompile B then C, it's C which gives me error

[14:26] <timotimo> i can precompile B, then run C without problems

[14:27] <laben> timotimo: if you want i can gist the --ll-exception output, maybe it's more useful for you: https://gist.github.com/anonymous/35df72696ef1aa6d79a8

[14:27] <ugexe> sounds like he is using old precompiled code

[14:27] <laben> no, i rm'ed it every time

[14:27] <timotimo> but i just deleted the .moarvm file

[14:28] <timotimo> ugexe means me

[14:28] <laben> C needs to be precomp'ed since it's a module which i then call from code

[14:29] <laben> it's somewhat golfed down from Flower and Template6

[14:29] <laben> i can confirm that if i dont precompile, everything works

[14:29] *** isBEKaml left
[14:30] <laben> that's why i thought it to be a precomp bug

[14:30] <timotimo> right

[14:30] <timotimo> i'm just apparently incompetent when it comes to precompiling modules

[14:31] <laben> i use $ perl6 -I. --target=mbc --output=B.pm6.moarvm B.pm6

[14:31] <ugexe> sometimes such problems can be solved by putting say, class A, in A.pm6. not the ideal solution, but sometimes you dont care

[14:31] <laben> ugexe: it was originally like that, doesn't change anything

[14:31] <timotimo> that's what i did, too :(

[14:32] <laben> it is skipped if i put everything in C.pm6

[14:32] <laben> but while it's possible with golfed code, it is not with real code

[14:33] <ugexe> what do you see when you do RAKUDO_MODULE_DEBUG=1 perl6 whatever

[14:33] <ugexe> that might show you if the module is at least being loaded

[14:35] <laben> https://gist.github.com/anonymous/c4823f4c34688fbf2f19

[14:36] <ugexe> ah i missed the --ll-exception bit. 

[14:36] <laben> ugexe: i put it in anyway

[14:38] <ugexe> are you looking for a workaround, or trying to figure out why 

[14:39] <laben> figure out why and fix it, seem quite the bug

[14:39] <laben> unfortunately i was not able to debug the issue easily

[14:39] <laben> dont know much of the internals

[14:40] <ugexe> indeed. i used to get similar bugs using roles applied at runtime (to do the same thing) but they went away

[14:40] <dalek> rakudo/glr: 2a9ab2b | ShimmerFairy++ | t/spectest.data:

[14:40] <dalek> rakudo/glr: Add S15-literals tests to spectest.data

[14:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/2a9ab2b79d

[14:40] <dalek> rakudo/glr: 0217016 | ShimmerFairy++ | src/Perl6/Grammar.nqp:

[14:40] <dalek> rakudo/glr: Add Unicode support to :radix[] style numbers.

[14:40] *** dalek left
[14:40] <laben> that is also why i gave up the direct debug approach and went with the reproduce the issue with reduced code way

[14:41] *** dalek joined
[14:41] *** ChanServ sets mode: +v dalek

[14:41] <ugexe> the internals are much easier to work on than you may think. in fact they must be if i have looked at it

[14:41] <laben> ugexe: maybe but now i am faced with precomp and i dont even know where to start

[14:42] <ugexe> thats where i started too i think. my first thing was adding a bunch of debug statements in ModuleLoader.nqp or something

[14:43] <ugexe> that was before RAKUDO_MODULE_DEBUG but still

[14:43] <lizmat> FWIW, I just merged nom into glr again: spectest failures now: https://gist.github.com/lizmat/33cf14b669293742c319

[14:43] <lizmat> there are still about 10 test-files that are hanging

[14:47] <ugexe> timotimo: an alternative to the pr for json_fast is adding JSON::Tiny to test-depends

[14:47] *** skids joined
[14:50] <dalek> nqp/js: f97b5e9 | (Pawel Murias)++ | src/vm/js/ (2 files):

[14:50] <dalek> nqp/js: Pass test 72.

[14:50] <dalek> nqp/js: 

[14:50] <dalek> nqp/js: Set WHAT on STables when creating type objects.

[14:50] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/f97b5e96ce

[14:51] <skids> Oh yay typed arrays unlock a lot in GLR.

[14:53] <skids> I was playing with them last night but got hung up on the mystery of why $!descriptor isn't set during the call to STORE in Array[Int].new

[14:53] <timotimo> ugexe: i didn't even see that pull request!

[14:54] <lizmat> $ 6 'my $a = "foo bar baz".words; say $a[2,1,0]; say $a[2,1,0]'

[14:54] <lizmat> baz bar foo

[14:54] *** tinyblak left
[14:54] <lizmat> feels to me the second one should fail because of fetching the iterator for the second time ?

[14:55] <skids> Isn't the assignment supposed to memoize?

[14:56] <dalek> roast/glr: 4fabc1e | hoelzro++ | S26-documentation/why- (3 files):

[14:56] <dalek> roast/glr: Fix S26 WHY tests for GLR

[14:56] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/4fabc1edb1

[14:56] <timotimo> without glr i also get the error laben sees

[14:58] <hoelzro> morning #perl6

[14:58] <ugexe> i havent noticed any precompiling problems specific to glr yet

[15:00] <ugexe> would there be much of any difference between a FatPacked p5 module vs a custom CURLI?

[15:01] <lizmat> in the future there would be, I think, because of things like %?RESOURCES

[15:02] <lizmat> the FatPacked module wouldn't have that, I would tihnk

[15:02] *** [TuxCM] joined
[15:02] * lizmat is too tired to get into the zone and decides to call it a day

[15:03] <jnthn> Please don't merge nom into glr

[15:03] <yoleaux> 13:37Z <lizmat> jnthn: if nqp::unbox_i gets some overflow test/exception, I can remove as well some of the tests in functions I added recently

[15:03] <rjbs> you think you're tired?  my brain just decided that "The zone" meant "the zone of alienation"

[15:03] <jnthn> Until we're about done

[15:03] <jnthn> Otherwise we have to keep merging spectest branch too

[15:03] <lizmat> jnthn: ok, will refrain from now on

[15:03] <jnthn> lizmat: It's the AT-POS that memoizes

[15:03] <timotimo> did anybody try json_fast with glr yet?

[15:03] <jnthn> lizmat: Otherwise .[0, 1] would fail also :)

[15:04] <lizmat> yeah, was wondering about that

[15:04] <ugexe> timotimo: yes

[15:04] <jnthn> lizmat: Though I did that mostly as the expedient thing...

[15:04] <jnthn> We could of course try to do something cleverer...

[15:04] <ugexe> 1 failure in test 2, but is fixed by doing [{}] to [{},] in a string, and test 4 hangs

[15:04] <lizmat> I think we would be best served with a specific postcircumfix [] handler for Seq

[15:04] <ugexe> BUT from-json works on META files (package managers)

[15:05] <ugexe> the core from-json in glr does not

[15:05] <timotimo> neato. did you compare speeds?

[15:05] <ugexe> nothing to compare it to. i think its the only one that works in glr right now

[15:05] <lizmat> jnthn:

[15:05] <lizmat> $ 6 '"words".IO.lines.elems.say'

[15:05] <lizmat> 235886

[15:05] <lizmat> real	0m1.870s

[15:05] <jnthn> lizmat: We could go that way also, but it's maybe not going to be too easy to write

[15:05] <timotimo> you could compare it to pre-glr ;)

[15:05] <lizmat> $ 6 '"words".IO.lines(:eager).elems.say'

[15:05] <lizmat> 235886

[15:05] <lizmat> real	0m0.851s

[15:06] <lizmat> so how would we get the .elems force the :eager in .lines ?

[15:06] <jnthn> How do those compare to nom? :)

[15:06] <jnthn> We don't do it that way

[15:06] <jnthn> We toss the :eager candidates

[15:07] <lizmat> lemme compare nom

[15:07] *** brrt joined
[15:07] <jnthn> And change things to use more appropriate constructs :)

[15:07] <ugexe> true... i have one to-json that is particularly slow

[15:07] <ugexe> that would be a good benchmark

[15:07] <jnthn> For example, we have lazy loops now, not to mention you can just implement the iterator API directly if you really have Need For Speed.

[15:08] <skids> $ ./perl6-m -e 'Array[Int].new(1,"a").say' # GLR (the $!descriptor mystery remains)

[15:08] <skids> 1 a

[15:08] <lizmat> jnthn: well, I'm not seeing that yet  :-(

[15:09] <lizmat> then again, I'm pretty tired

[15:09] <skids> I spent like an hour trying to figure out what actually initializes $!descriptor and still can't :-)

[15:09] <lizmat> jnthn: I just merged nom, should I merge master in roast as well to get them in sync ?

[15:09] <lizmat> (and then stop merging?  :-)

[15:09] <jnthn> lizmat: Yeah, please

[15:10] *** TEttinger joined
[15:10] <jnthn> skids: Compiler guts

[15:10] <dalek> roast/glr: 17d9681 | usev6++ | S02-types/range.t:

[15:10] <dalek> roast/glr: Make test for RT #125791 pass on JVM

[15:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/17d9681a22

[15:10] <dalek> roast/glr: bbe6a8c | FROGGS++ | S04-declarations/implicit-parameter.t:

[15:10] <dalek> roast/glr: add tests for RT #125767, { .sqrt => .sqrt }

[15:10] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125791

[15:10] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125767

[15:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/bbe6a8c2c9

[15:10] <dalek> roast/glr: 9717b4f | ShimmerFairy++ | S15-literals/numbers.t:

[15:10] <dalek> roast/glr: Unfudge Unicode numbers tests for moar

[15:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/9717b4f299

[15:10] <dalek> roast/glr: 40d5917 | lizmat++ | S (3 files):

[15:10] <dalek> roast/glr: Merge branch 'master' into glr

[15:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/40d591717f

[15:10] <jnthn> skids: But note the typed array new is still commented out

[15:10] *** [TuxCM] left
[15:11] <lizmat> nom with words counr: 0.952s / 2.764s

[15:12] <lizmat> on glr it's now 0.851s / 1.870s

[15:13] <jnthn> Nice. Improvement before we even changed words/lines to take advantage of GLR things. :)

[15:13] <lizmat> yup

[15:13] <lizmat> even the eager one  :-)

[15:13] <jnthn> At the point I'd like to focus on getting things working again, and then we can go optimizing. :)

[15:14] <lizmat> ok

[15:14] *** zakharyas joined
[15:14] <jnthn> But I suspect we can squeeze a good bit more out on that benchmark :)

[15:14] <lizmat> so, you were serious about just tossing the :eager candidates...  the code in there is basically no god in the GLR ?

[15:14] <lizmat> *good

[15:15] <jnthn> lizmat: Well, you don't have to immediately toss it, but basically the new iterator API has a mechanism for conveying (transitively) "we want all the things"

[15:15] *** [TuxCM] joined
[15:15] <jnthn> my @a = $foo.words; # conveys exactly that

[15:16] <lizmat> ok, so lines returns a Seq, the .elems on it says "give me all"

[15:16] <jnthn> Right

[15:16] <jnthn> So at that point it knows it can go faster

[15:16] * lizmat needs to look at iterators more at some point

[15:16] *** [TuxCM] left
[15:16] *** xinming joined
[15:16] <lizmat> ok, gotcha

[15:16] <jnthn> Additionally, in:

[15:16] <jnthn> my @a = $foo.words;

[15:17] <jnthn> It actually works such that it passes the slot array of @a down the iterator chain

[15:17] <jnthn> So .words doesn't have to produce a bunch of things to store into the array

[15:17] <jnthn> Instead, the things in produces can be shoved (via creating a Scalar container) directly into place.

[15:18] <jnthn> Which gets rid of a good bunch of copying we've done in the past.

[15:18] <lizmat> that is a good thing  :-)

[15:19] <jnthn> src/core/Iterator.pm has the API and explanations of the different parts, btw

[15:19] <jnthn> So it's a good place to start reading

[15:21] <lizmat> in any case, it's good to see glr bare startup is around 100 msecs again, wheres nom is at 112 msecs

[15:22] <jnthn> yeah, I thought we'd shaved a bit off there too :)

[15:26] *** MilkmanDan left
[15:26] *** MilkmanDan joined
[15:26] <jnthn> bbl &

[15:31] *** rurban joined
[15:57] *** raiph joined
[16:01] <AlexDaniel> m: my @a = 1, 5, -7, 2; say @a.sin;

[16:01] <camelia> rakudo-moar 44e3b4: OUTPUT«-0.756802495307928␤»

[16:01] <AlexDaniel> this is so Cool!

[16:03] <AlexDaniel> not sure why would anybody need that though

[16:04] <cognominal> what the sin of an array is supposed to mean?

[16:04] <laben> probably the array of sin of each element

[16:05] <laben> a la MAtlab

[16:05] <AlexDaniel> I kinda like the way it works now

[16:06] <AlexDaniel> just because of the consistency

[16:06] <laben> m: my @a = 1, 5, -7, 2; say @a.map(&sin)

[16:06] <camelia> rakudo-moar 44e3b4: OUTPUT«0.841470984807897 -0.958924274663138 -0.656986598718789 0.909297426825682␤»

[16:06] <laben> wait where did your result ocme from?

[16:06] <laben> come*

[16:07] <laben> -0.75 isnt in any of these

[16:07] <cognominal> say 4.sin

[16:07] <cognominal> m: say 4.sin

[16:07] <camelia> rakudo-moar 44e3b4: OUTPUT«-0.756802495307928␤»

[16:07] <laben> ah it took the sin of elems

[16:07] <AlexDaniel> sure

[16:08] <cognominal> does not make any sense to me

[16:08] <timotimo> huh?

[16:08] <laben> coerced @a to Num then did sin?

[16:08] <timotimo> oh

[16:09] <timotimo> right, that's what it does

[16:09] <laben> seems a bit strange though, i agree

[16:09] <cognominal> yes, this is what Perl 6 is supposed to do but I would expect something different in that case.

[16:10] <AlexDaniel> cognominal: like?

[16:10] <laben> will List inherit from Cool after glr?

[16:10] <cognominal> like returning an array of sin as said earlier.

[16:11] <laben> i would prefer if it gave me warning or error and required .map(&sin) to do that, but maybe that's too strict

[16:11] <AlexDaniel> to save 4 characters because of map: ?

[16:11] <AlexDaniel> map is short and explicit, so I don't see any problem

[16:12] <AlexDaniel> you might say that there is more than one way to do it, yeah, there is more than one way to break consistency, I guess

[16:12] <cognominal> say (1, 5, -7, 5)>>.sin;

[16:12] <cognominal> m: say (1, 5, -7, 5)>>.sin;

[16:12] <camelia> rakudo-moar 44e3b4: OUTPUT«0.841470984807897 -0.958924274663138 -0.656986598718789 -0.958924274663138␤»

[16:12] <AlexDaniel> but if that is done, then every method from Cool should be overriden

[16:12] <ugexe> you lose order

[16:13] <AlexDaniel> ugexe: order?

[16:13] <cognominal> indeed

[16:13] <ugexe> m: my @a = 1,2,3; @a>>.say

[16:13] <camelia> rakudo-moar 44e3b4: OUTPUT«3␤1␤2␤»

[16:14] <AlexDaniel> ugexe: I thought that it is free to execute it in any order as long as the resulted list is composed in the original order

[16:14] <laben> AlexDaniel: if you need order, use .map

[16:14] <AlexDaniel> ugexe: your example is not equivalent

[16:14] <laben> m: my @a = 1,2,3; @a.map(&say);

[16:14] <camelia> rakudo-moar 44e3b4: OUTPUT«1␤2␤3␤»

[16:14] <AlexDaniel> ugexe: because say is part of the execution

[16:16] <ugexe> afaik >> forces the results to *not* be in order so that people wont assume thats what it does

[16:16] <AlexDaniel> m: say (1, 2, 3, 4, 5, 6)>>.sin;

[16:16] <camelia> rakudo-moar 44e3b4: OUTPUT«0.841470984807897 0.909297426825682 0.141120008059867 -0.756802495307928 -0.958924274663138 -0.279415498198926␤»

[16:16] <AlexDaniel> m: say (1, 2, 3, 4, 5, 6).map(&sin)

[16:16] <camelia> rakudo-moar 44e3b4: OUTPUT«0.841470984807897 0.909297426825682 0.141120008059867 -0.756802495307928 -0.958924274663138 -0.279415498198926␤»

[16:16] <AlexDaniel> what forcing are you talking about?

[16:17] <AlexDaniel> the resulted list is still in order

[16:17] <AlexDaniel> I don't get it

[16:17] <laben> m: my @a=1,2,3; say @a>>.++

[16:17] <camelia> rakudo-moar 44e3b4: OUTPUT«1 2 3␤»

[16:18] <laben> m: my @a=1,2,3; say @a>>+=1

[16:18] <camelia> rakudo-moar 44e3b4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8HFDg8uznl␤Malformed postfix␤at /tmp/8HFDg8uznl:1␤------> 3my @a=1,2,3; say @a>>7⏏5+=1␤    expecting any of:␤        postfix␤»

[16:18] <laben> m: my @a=1,2,3; say @a>>{*++}

[16:18] <camelia> rakudo-moar 44e3b4: OUTPUT«postcircumfix:<{ }> not defined for type Int␤  in block <unit> at /tmp/hwoVv4jb8d:1␤␤Actually thrown at:␤  in block <unit> at /tmp/hwoVv4jb8d:1␤␤»

[16:18] <laben> m: my @a=1,2,3; say @a>>{*+=1}

[16:18] <camelia> rakudo-moar 44e3b4: OUTPUT«postcircumfix:<{ }> not defined for type Int␤  in block <unit> at /tmp/Sqrfz0GpJ0:1␤␤Actually thrown at:␤  in block <unit> at /tmp/Sqrfz0GpJ0:1␤␤»

[16:18] <laben> m: my @a=1,2,3; say @a.map(&++);

[16:18] <camelia> rakudo-moar 44e3b4: OUTPUT«Type check failed in assignment to '&'; expected 'Callable' but got 'Int'␤  in block <unit> at /tmp/V_8jh4fbp1:1␤␤»

[16:19] <laben> m: my @a=1,2,3; say @a.map({.++})

[16:19] <camelia> rakudo-moar 44e3b4: OUTPUT«1 2 3␤»

[16:19] <laben> m: my @a=1,2,3; say @a.map({*+=1})

[16:19] <camelia> rakudo-moar 44e3b4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EjmWxxi82f␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at /tmp/EjmWxxi82f:1␤------> 3my @a=1,2,3; …»

[16:20] <laben> m: my @a=1,2,3; say @a.map(*+=1)

[16:20] <camelia> rakudo-moar 44e3b4: OUTPUT«2 3 4␤»

[16:20] <laben> m: my @a=1,2,3; say @a>>*+=1

[16:20] <camelia> rakudo-moar 44e3b4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/U5w3dkqVqJ␤Malformed postfix␤at /tmp/U5w3dkqVqJ:1␤------> 3my @a=1,2,3; say @a>>7⏏5*+=1␤    expecting any of:␤        postfix␤»

[16:20] <laben> m: my @a=1,2,3; say @a>>({*+=1})

[16:20] <camelia> rakudo-moar 44e3b4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/qcnfmKXKPD␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at /tmp/qcnfmKXKPD:1␤------> 3my @a=1,2,3; …»

[16:20] <laben> m: my @a=1,2,3; say @a>>(*+=1)

[16:20] <camelia> rakudo-moar 44e3b4: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/QK3LX4b8Ne:1␤␤»

[16:20] <laben> ok i give up, im not gonna use >>

[16:21] <AlexDaniel> So, can anybody confirm my thoughts about >> ?

[16:21] <AlexDaniel> or maybe I'm wrong

[16:24] <laben> m: my @a=1.1,2.2,3.3,4.4,5.5; say @a>>.floor

[16:24] <camelia> rakudo-moar 44e3b4: OUTPUT«1 2 3 4 5␤»

[16:24] <laben> m: my @a=1.1,2.2,3.3,4.4,5.5; @a>>.floor.say

[16:24] <camelia> rakudo-moar 44e3b4: OUTPUT«1 2 3 4 5␤»

[16:24] <skids> Hrm.  The hang (as opposed to expected NYI failure) in S02-types/array-shapes is an infinite recursion between array.list and Any.join.

[16:24] <laben> AlexDaniel: i dont know enough to tell you, sorry

[16:24] *** brrt left
[16:25] <skids> But removing array's .list method does not fix it even though it does not seem to inherit from List.

[16:25] <skids> And yet, Array inherits from List, and Array.list ~~ Array, but it does not ae the problem.

[16:26] <laben> skids: doesnt .list come from Any?

[16:26] <skids> List has a method .list

[16:26] <skids> (In GLR)

[16:27] <laben> ah you speak of glr, sorry man, im not that brave yet

[16:29] <skids> OIC.  List has its own .join too.

[16:30] <skids> Thought I was going crazy.

[16:31] <jnthn> The key thing about @a>>.foo is that it gives you back the results ordered relative to the inputs, but it may call .foo on multiple threads and so any side-effects may execute out of order or in parallel.

[16:31] <jnthn> Generally, you should not use >>.foo if foo has side-effects

[16:33] *** rurban left
[16:41] *** TEttinger left
[16:41] <laben> .tell grondilu the sha256 function hangs in test sha.t of your Digest module, can you check it please?

[16:41] <yoleaux> laben: I'll pass your message to grondilu.

[16:56] *** pmurias left
[17:00] <japhb> *yawn*

[17:00] <japhb> Good morning, #perl6

[17:01] * japhb has been up for a while, but just now feeling like hacking

[17:08] *** domidumont joined
[17:08] *** domidumont left
[17:08] <jnthn> o/ japhb 

[17:09] *** domidumont joined
[17:16] *** domidumont1 joined
[17:16] *** zakharyas left
[17:17] <dalek> rakudo/glr: 1ee1808 | hoelzro++ | src/core/Pod.pm:

[17:17] <dalek> rakudo/glr: Flatten Pod::Block contents array

[17:17] <dalek> rakudo/glr: 

[17:17] <dalek> rakudo/glr: Due to new GLR changes, the contents attribute is handed an Array that

[17:17] <dalek> rakudo/glr: doesn't want to flatten.

[17:17] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1ee18086dd

[17:18] <hoelzro> could someone close to the GLR changes check out that commit I just made, and verify that it makes sense?

[17:18] <hoelzro> I finally was able to fix a bunch of POD tests, but the way I managed it feels LTA

[17:19] *** domidumont left
[17:20] <cognominal> c'est vrai qu'avec l'Europe, on est passé au niveau méta et avec Tafta au méta secret.

[17:20] <cognominal> wrong channel

[17:22] <laben> hoelzro: i dont know about glr, but couldn't you do @!contents.map(&flat)?

[17:23] <hoelzro> laben: that might work! I think what's bothering me about it is all of the explicit flattening

[17:23] <laben> hoelzro: other way is to make sure the callers flatten it themselves...

[17:23] <hoelzro> yeah, I was trying to make that work; I don't know if I couldn't because GLR is WIP, or because I was doing something wrong

[17:26] <laben> is there documentation to learn (part of) the internals of Rakudo?

[17:27] <hoelzro> laben: https://github.com/edumentab/rakudo-and-nqp-internals-course

[17:28] <laben> hoelzro: thanks! a ton of things to read

[17:28] <hoelzro> I also gave a talk at (Chicago.pm&Milwaukee.pm) about it: https://docs.google.com/presentation/d/1JVJfNlCQL7crJytbKsdlf7Jw4c4dMScjogHLkZuOwcs/edit#slide=id.p

[17:29] <hoelzro> that's more things I've learned while working on it, though

[17:36] <laben> turns out pandoc has quite the heavy deps, would be a dream to have it in p6...

[17:38] <skids> m: sub b (*@a) { }; sub a (*@a) { b(|@a); }; my $b = Failure.new("foo"); a(1,$b,3); # throws the failure on GLR, should it?

[17:38] <camelia> rakudo-moar 44e3b4: ( no output )

[17:44] *** rurban joined
[17:45] <skids> m: sub a (*@a) { }; my @a = (1,Failure.new("foo"),3); a(|@a); # golf

[17:45] <camelia> rakudo-moar 44e3b4: ( no output )

[17:57] <jnthn> hoelzro: My first resort would probably be to fix the thing passing @!contents rather than trying to fix it up there

[17:58] <hoelzro> jnthn: makes sense; what I'm seeing passed in is something like [$[Pod::Block::Para, Pod::Block::Para]], and I couldn't seem to figure out how to flatten that in NQP land

[17:58] <hoelzro> any pointers?

[17:59] <jnthn> hoelzro: Do you know where the NQP code doing the pushing is?

[18:00] <hoelzro> jnthn: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Pod.nqp#L34

[18:00] <jnthn> Hm, I wonder what serialize_array does... :)

[18:01] <hoelzro> yeah, that seems to make an itemized Array

[18:01] <hoelzro> and I couldn't figure out how to get it to flatten

[18:01] <jnthn> Well, arrays are by definition itemized...

[18:02] <hoelzro> I thought that with GLR they aren't anymore? or they just flatten now, unless made with $[...]

[18:03] <jnthn> An Array is (always has been) a bunch of Scalars

[18:04] <jnthn> Hm, I can't see where on earth the extra itemization is going on though

[18:04] <hoelzro> ok, so I'm not (entirely) crazy then =)

[18:04] <hoelzro> I think it's happening in Array.new somehow

[18:05] <hoelzro> that's my guess

[18:05] <jnthn> Yeah, I can't manage to create an isolated example, alas

[18:06] <hoelzro> I think it has something to do with the way that the $<pod_content> match has an AST that is also a serialized array?

[18:07] <jnthn> Oh...I was assuming we pushed that twice

[18:07] <jnthn> That is, that @children.push($_.ast); was running twice

[18:08] <jnthn> If it's running once and you've a nested array then...yeah, that'll be some fun

[18:08] <nine> skids++ # investigating roast/glr hangs

[18:08] <jnthn> 'cus Array.new(@a, @b) now gets you an Array of two things

[18:10] <nine> Should we revert the extra .list calls in roast, now that Seq supports AT-POS?

[18:11] <jnthn> nine: Can do, yes

[18:11] * jnthn away for a bit

[18:13] *** rurban left
[18:14] <skids> nine: well, my PR only takes care of the one new one.  The S03 assignment one I think nobody figured out exactly how GLR-only-fudging should be handled.

[18:14] *** zakharyas joined
[18:15] <nine> 279/1036 test files failing in roast/glr

[18:15] <laben> hoelzro: your talk was super interesting and educative, i had to rewatch some parts twice to understand what you were doing. btw congrats for your typing speed and skillz, makes me seem so sloppy

[18:15] <skids> BTW maybe consider having the GLR rakudo "make spectest" pull from glr roast branch for now?

[18:15] <hoelzro> oh, thank you laben!

[18:15] <hoelzro> jnthn: yeah, that's what I'm observing =/

[18:16] *** rurban joined
[18:17] <dalek> roast/glr: 59bc6a6 | hoelzro++ | S26-documentation/why- (3 files):

[18:17] <dalek> roast/glr: Revert "Fix S26 WHY tests for GLR"

[18:17] <dalek> roast/glr: 

[18:17] <dalek> roast/glr: This reverts commit 4fabc1edb14e2b75f4d88c2882f526f33903649b.

[18:17] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/59bc6a661d

[18:17] <nine> skids: yes, I put the one into S03/assign.t. I don't think we really need GLR-only-fudging. Just fudging and mentioning the GL should be enough. I just wanted to get rid of the hang. I left it there because it may happen that we declare the case hopeless like we did with xx=

[18:18] <nine> S-26/why* pass for me :0

[18:19] <nine> :)

[18:19] <hoelzro> nine: I probably should've edited that message =)

[18:20] <nine> hoelzro: well you could have mentioned, that we do actually support the previous code now. But not many people will notice the commits anyway ;)

[18:20] <hoelzro> right, I thought about that...after I pushed =/

[18:24] *** rurban left
[18:26] *** RabidGravy joined
[18:26] <hoelzro> is there a way to iterate over a P6 array in NQP? I'm thinking maybe I should explicitly flatten $_.ast in Pod.nqp

[18:27] *** kernel joined
[18:27] *** kernel is now known as Guest6532

[18:30] *** Guest94770 left
[18:36] <AlexDaniel> m: loop my $i=0; $i < 25; $i++ { say 'hello' }

[18:36] <camelia> rakudo-moar 44e3b4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/rRzc1UgSR9␤Missing block␤at /tmp/rRzc1UgSR9:1␤------> 3loop7⏏5 my $i=0; $i < 25; $i++ { say 'hello' }␤    expecting any of:␤        scoped block␤»

[18:36] *** bin_005 joined
[18:41] *** MadcapJake left
[18:45] *** jack_rabbit left
[18:45] <skids> Is Array.STORE eager for any deep semantic reason?  I'm wondering if we couldn't just put things on $!todo and make $!todo.reification-target vivify itself (and $!reified if needed) when unset.

[18:47] <skids> Oh, maybe for compile-time typechecks?

[18:48] *** FROGGS_ is now known as FROGGS

[18:50] <FROGGS> good evening dear sir or madam

[18:50] <yoleaux> 14:13Z <lizmat> FROGGS: re #125796, it looks like EOF is not set in the same way for an IO::Handle coming from open or from run :out

[18:50] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125796

[18:51] <hoelzro> ahoy FROGGS 

[18:54] *** llfourn left
[18:55] *** xinming left
[19:00] *** mr_ron joined
[19:02] * skids wonders if .plan should just ignore laziness/infinity entirely and just keep adding to a bunch of Slips in $!todo, and if they are unreachable, ohwelltoobad.

[19:10] *** diana_olhovik joined
[19:13] *** kaare_ joined
[19:21] <dalek> rakudo/glr: 6d76d88 | hoelzro++ | src/core/Pod.pm:

[19:21] <dalek> rakudo/glr: Revert "Flatten Pod::Block contents array"

[19:21] <dalek> rakudo/glr: 

[19:21] <dalek> rakudo/glr: This reverts commit 1ee18086dd11a807b8940c242a6e7c0842b5c356.

[19:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6d76d881ec

[19:21] <dalek> rakudo/glr: 919ef9d | hoelzro++ | src/Perl6/Pod.nqp:

[19:21] <dalek> rakudo/glr: Manually unpack POD childrens' content when creating parent

[19:21] <dalek> rakudo/glr: 

[19:21] <dalek> rakudo/glr: A fresh look on what I tried to fix in 1ee18086dd11a807b8940c242a6e7c0842b5c356.

[19:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/919ef9db37

[19:21] <hoelzro> ok, that *should* be better

[19:21] <hoelzro> and it doesn't break table tests!

[19:25] *** rurban joined
[19:26] *** domidumont1 left
[19:31] *** yqt joined
[19:33] <FROGGS> since I was quite inactive... is the glr branch faster than nom in some cases?

[19:33] <laben> [17:12] <lizmat> nom with words counr: 0.952s / 2.764s

[19:33] <laben> [17:13] <lizmat> on glr it's now 0.851s / 1.870s

[19:34] <FROGGS> ohh, that sounds like something

[19:35] <laben> jnthn said that's only the beginning, no work was done specifically to make this faster

[19:35] <FROGGS> yes yes, that is how I know how development works

[19:36] <laben> i was trying to instill hope for more speed :/

[19:36] <FROGGS> more speed will come

[19:36] <laben> and startup was a lil faster too

[19:37] * DrForr briefly pokes his nse in - I understand the breakage I found was fixed.

[19:37] <DrForr> *nose

[19:41] <dalek> rakudo/nom: 383db01 | FROGGS++ | src/core/IO/Pipe.pm:

[19:41] <dalek> rakudo/nom: implement IO::Pipe.lines in terms of repeated .get

[19:41] <dalek> rakudo/nom: 

[19:41] <dalek> rakudo/nom: This solves RT #125796. There is no EOF when read lines from a subprocess, so we cannot

[19:41] <dalek> rakudo/nom: cheat here and have to call .get repeatedly.

[19:41] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125796

[19:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/383db0117e

[19:44] <hoelzro> FROGGS++

[19:46] <dalek> roast: 3a8ec6e | FROGGS++ | S32-io/pipe.t:

[19:46] <dalek> roast: add test for RT #125796, IO::Pipe.lines

[19:46] <dalek> roast: review: https://github.com/perl6/roast/commit/3a8ec6eac6

[19:46] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125796

[19:46] *** bin_005_g joined
[19:47] *** bin_005 left
[19:47] <FROGGS> hoelzro: can you comment here? http://blogs.perl.org/users/aaron_baugher/2015/08/mystery-line-in-proc-input-in-perl-6.html

[19:47] <hoelzro> sure can!

[19:48] <FROGGS> hoelzro++

[19:49] <dalek> perl6-examples: 321e5fd | paultcochrane++ | lib/Pod/Htmlify.pm6:

[19:49] <dalek> perl6-examples: Instantiate Text::VimColour correctly if installed

[19:49] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/321e5fde7a

[19:51] <hoelzro> done

[19:51] <FROGGS> nice :o)

[19:52] <FROGGS> m: for ^2 { NEXT .say }

[19:52] <camelia> rakudo-moar 44e3b4: OUTPUT«Cannot call method 'say' on a null object␤  in block <unit> at /tmp/pwZz_LeAce:1␤␤»

[19:53] *** AlexDaniel left
[19:58] *** AlexDaniel joined
[20:19] *** darutoko left
[20:24] *** camelia left
[20:26] *** camelia joined
[20:27] *** ChanServ sets mode: +v camelia

[20:34] *** kaare_ left
[20:37] *** diana_olhovik left
[20:51] *** llfourn joined
[20:55] *** llfourn left
[21:04] *** bin_005_g left
[21:04] *** bin_005_g_c joined
[21:06] *** zakharyas left
[21:08] *** rindolf left
[21:19] *** laben left
[21:20] <skids> m: my $a = Array[Int].new(1,2,3); $a[0] := 1; $a[0] = 3; $a.say; # wondering the disposition of the GLR design to this... does Array really "ensure" containers?

[21:20] <camelia> rakudo-moar 383db0: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/xNHzEBdctM:1␤␤»

[21:20] <skids> Or just that *assignment* means "new container"

[21:28] <dalek> perl6-examples: b2f5c43 | paultcochrane++ | categories/euler/prob008-duff2.pl:

[21:28] <dalek> perl6-examples: Improve list markup for prob008-duff2

[21:28] <dalek> perl6-examples: 

[21:28] <dalek> perl6-examples: For some reason the S26 numbered item syntax doesn't work yet, however at

[21:28] <dalek> perl6-examples: present fixing the original numbered list to use a pod6 list is a bit of an

[21:28] <dalek> perl6-examples: improvement.

[21:28] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/b2f5c43e7e

[21:28] <smls> skids: I think the whole point of the "binding to an array/hash element" feature is to replace the container that would be normally there.

[21:29] <smls> if you replace it with an immutable value rather than another container, you can obviously not assign to it... :P

[21:29] <skids> Right so you should be able to bind an "Int $a" into an Array[Int] but not a 3.

[21:30] <smls> I guess that's a case of DIHWIDT...

[21:32] <skids> Well, I'm not sure it's that simple... optimizers having to throw container checks in everywhere is probably not pretty.

[21:35] * skids wonders how much breaks if he "fixes" that.

[21:40] <dalek> rakudo-star-daily: d15f796 | coke++ | log/MoarVM- (5 files):

[21:40] <dalek> rakudo-star-daily: today (automated commit)

[21:40] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d15f7961c5

[21:40] <dalek> perl6-roast-data: dca9dac | coke++ | / (9 files):

[21:40] <dalek> perl6-roast-data: today (automated commit)

[21:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/dca9daccfc

[21:48] <[Coke]> can't build Resurrected pugs on hack - no cabal.

[21:51] *** llfourn joined
[21:55] *** llfourn left
[21:59] *** ecocode joined
[22:06] *** TEttinger joined
[22:15] *** BenGoldberg joined
[22:15] *** mr_ron left
[22:16] *** RabidGravy left
[22:31] *** smls left
[22:37] *** Peter_R left
[22:43] *** yqt left
[22:49] *** telex left
[22:50] *** telex joined
[22:52] *** Peter_R joined
[22:53] <ugexe> FROGGS: maybe i won't need to soon, but right now i use the following with lines: $proc.out.lines(:!eager, :close);

[22:56] <ugexe> i can easily change my code, just wanted to point it out in case it was actually important

[23:10] *** ecocode left
[23:13] *** virtualsue left
[23:16] *** cognominal left
[23:19] *** rurban left
[23:41] *** BenGoldberg left
[23:42] *** BenGoldberg joined
[23:52] *** llfourn joined
[23:52] *** inokenty joined
[23:56] *** llfourn left
