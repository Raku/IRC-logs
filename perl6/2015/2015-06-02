[00:00] *** vendethiel joined
[00:03] <timotimo> it's kind of amazing that none of the ~5k gc runs that happen during masaks send-more-money-subs is a full collection

[00:03] <timotimo> and i'm not 100% sure that's really a good thing

[00:07] <timotimo> hm. the collection time or the number of gen2 roots doesn't decrease after a full gc, so it doesn't seem so bad

[00:07] <timotimo> (i reduced the threshold for a full gc run to be triggered way down and made it to a single full collection)

[00:08] <timotimo> hmm. it might be sort of interesting to have the profiler also measure what objects get promoted to gen2

[00:14] *** gfldex left
[00:19] *** laouji joined
[00:20] <tadzik> Indeed

[00:23] *** vendethiel left
[00:25] *** davido_ left
[00:27] *** davido_ joined
[00:28] *** larion left
[00:29] <timotimo> there's an object that gets added to the gen2 roots that seems ... garbled

[00:30] <timotimo> https://gist.github.com/timo/b3948e713e46d7923e39

[00:30] <timotimo> its flags are "IS_STABLE" and "SECOND_GEN"

[00:31] <timotimo> oh, an STABLE looks different from an object of course

[00:34] <timotimo> the vast majority of things being added to the gen2 roots are MVMCode objects

[00:35] <timotimo> at least during startup; when running the send-more-money-subs, more and more MVMCode get added, but also P6Opaque, VMArray, and a few VMHashes 

[00:35] <timotimo> i wonder if these MVMCode objects come just from taking closures?

[00:36] <jdv79> are a bunch of closures necessary?  i haven't looked at that code.

[00:39] *** laouji left
[00:39] *** laouji joined
[00:43] *** JustThisGuy joined
[00:44] *** laouji left
[00:45] <JustThisGuy> Hi all! What's the convention for posting code to ask a question about?

[00:45] <raydiak> JustThisGuy: if it's more than a line, a github gist is common, or whatever pastebin you prefer

[00:46] *** laouji joined
[00:46] <JustThisGuy> OK, thanks. I'll be back in a few...

[00:46] <raydiak> you're welcome

[00:52] <JustThisGuy> OK, Here's the code: http://pastebin.com/raw.php?i=wm2jLWW3

[00:53] <JustThisGuy> When I run it through the REPL: my $gdbm = DBM::GDBM.new('foo', 0, 0o666); $gdbm.store('foo', 'bar');

[00:53] <JustThisGuy> I get: Cannot modify an immutable Str in method store at /development/perl6/DBM-GDBM/lib/DBM/GDBM.pm6:66 in block <unit> at <unknown file>:1 in any <unit-outer> at <unknown file>:1

[00:54] <JustThisGuy> I saw in Arne Skjærholt's talk here: https://www.youtube.com/watch?v=ZPuU_jTnJCs&t=17m25s

[00:55] <JustThisGuy> That value structs are not yet implemented. Is that what I'm running into, or am I doing something dumb? (entirely possible since this is day 4 of using Perl 6)

[00:58] *** BenGoldberg joined
[00:58] <JustThisGuy> Oh, I should probably mention that DBM::GDBM.new actually creates the gdbm file 'foo', and it appears to be valid, but empty, as expected.

[01:00] <raydiak> hm...well, line 66 doesn't match the paste and idk much about DBM, but I'd try changing the 'is rw's in store's signature to 'is copy' instead, since you're passing literal strings in instead of mutable containers

[01:01] <JustThisGuy> Yeah, sorry, I hacked out a bunch of commented out junk. The line is: my datum $key_datum     = datum.new(dptr => $key, dsize => $key.chars);

[01:02] <JustThisGuy> I'll give that a try...

[01:02] <JustThisGuy> Thanks!

[01:03] <JustThisGuy> Still got the same error.

[01:05] <timotimo> if you .store('foo', 'bar') you're passing in constant strings, and if you somehow assign to them, that'll go boom. but i don't really see where that'd happen

[01:06] <JustThisGuy> Yeah, that's what's confusing me.

[01:06] <timotimo> you tried "is copy" like raydiak suggested?

[01:06] <JustThisGuy> Yes, I get the same error.

[01:06] <timotimo> you restarted the repl properly, too?

[01:07] <raydiak> yeah I don't see what on that line is trying to change a string, either...

[01:07] <timotimo> if you run perl6 with --ll-exception, the stack trace will also contain internal methods

[01:07] <JustThisGuy> Yes, I did restart it. Just did it again to make sure. :)

[01:07] <timotimo> that could help figure out where things are going wrong

[01:07] *** zhanggong joined
[01:08] <JustThisGuy> Hmmm... I did this: PERL6LIB=. perl6 --ll-exception -M DBM::GDBM

[01:08] <JustThisGuy> and still got the same error with no extra info.

[01:09] <timotimo> that should have helped

[01:09] <timotimo> can you try 'use DBM::GDBM' instead of -M?

[01:09] <JustThisGuy> Sure...

[01:10] <JustThisGuy> Same result.

[01:10] <timotimo> :o

[01:11] <timotimo> hm, we do read from PERL6LIB, right? could you put a say statement into the mainline of the module so we can see if the right file is being used?

[01:11] <JustThisGuy> Sure...

[01:11] <timotimo> i'm not really on top of my debugging game; it's 3am, i should probably try sleeping instead

[01:12] <JustThisGuy> Yeah, I got my "Foo!!!" as soon as I typed in use DBM::GDBM;

[01:12] <JustThisGuy> So it's definitely the right file.

[01:12] <timotimo> OK, good

[01:13] <JustThisGuy> LOL, don't let me keep you up timotimo. :)

[01:13] <timotimo> "is copy" is the only thing you changed?

[01:13] <JustThisGuy> Yes, except for the say line I just added.

[01:15] <JustThisGuy> I know this is probably bleeding edge stuff, and that combined with the fact that I don't know what I'm doing could be the problem. :)

[01:15] <JustThisGuy> Is there anywhere more persistent I can post this question?

[01:16] <timotimo> we have [email@hidden.address]
[01:16] <timotimo> fwiw, the nativecall stuff and CStruct classes have been around for a long time

[01:16] <JustThisGuy> OK, I'll give that a try. Thanks timotimo!

[01:16] <timotimo> but being able to mark parameters to "is native" subs to be "is rw" is rather new

[01:16] <JustThisGuy> Oh, that's good to know.

[01:17] <timotimo> hm, so, where do i get libgdbm.so.3

[01:17] <timotimo> yum yum ...

[01:18] <JustThisGuy> I'm running Linux Mint 17, and the package is called libgdbm3.

[01:19] <timotimo> oh, i have .4

[01:19] <timotimo> i can get compat-gdbm

[01:19] <timotimo> Error: compat-gdbm-devel conflicts with gdbm-devel-1.11-4.fc21.x86_64

[01:19] <JustThisGuy> Yeah, that's one thing I was wondering about is how to handle versioned .so files.

[01:21] <timotimo> oh, that's funny!

[01:21] <JustThisGuy> What's that?

[01:22] <timotimo> this comes from a BUILD method

[01:23] <JustThisGuy> I haven't learned about BUILD methods yet, so I don't get the joke. :)

[01:24] <timotimo> the funny thing was i first thought it was something completely unrelated

[01:24] <JustThisGuy> Oh, gotcha.

[01:24] <timotimo> creating the first datum in the store method blows up

[01:25] <raydiak> m: use NativeCall; class Foo is repr('CStruct') { has Str $.str }; Foo.new: :str<foo>   # golf

[01:25] <camelia> rakudo-moar c2a57e: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/Ft7xb6JrS3:1␤␤»

[01:25] <timotimo> well, that's convenient

[01:25] <timotimo> who broke that! :P

[01:26] <JustThisGuy> Not me! I don't know enough to be dangerous yet. :)

[01:26] <timotimo> well, this worked once

[01:27] <JustThisGuy> Oh cool! So there's hope!

[01:27] <timotimo> star: use NativeCall; class Foo is repr('CStruct') { has Str $.str }; Foo.new: :str<foo>

[01:27] <camelia> star-m 2015.03: OUTPUT«Cannot modify an immutable Str␤  in block  at src/gen/m-CORE.setting:1009␤  in method BUILDALL at src/gen/m-CORE.setting:992␤  in method bless at src/gen/m-CORE.setting:981␤  in method new at src/gen/m-CORE.setting:967␤  in block <unit> at /tmp/PJaYJ…»

[01:27] <timotimo> ... huh?!

[01:27] <timotimo> we never had working Str inside CStruct?

[01:28] <timotimo> that seems unlikely

[01:35] *** fernando___ left
[01:35] *** ggherdov left
[01:36] *** preyalone left
[01:37] *** zhanggong left
[01:39] <timotimo> OK, sleep time now

[01:39] <timotimo> o/

[01:39] <JustThisGuy> OK, thanks for the help timotimo!

[01:40] *** fernando___ joined
[01:41] <JustThisGuy> Oh, and thanks to you too raydiak!

[01:42] *** JustThisGuy left
[01:47] *** ggherdov joined
[01:48] <dalek> rakudo/nom: c79bcc5 | hoelzro++ | src/ (3 files):

[01:48] <dalek> rakudo/nom: Save Regex source for .gist/.perl

[01:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c79bcc5698

[01:53] *** preyalone joined
[01:54] *** Sqirrel left
[02:15] *** Akagi201 joined
[02:16] *** SevenWolf joined
[02:21] *** vendethiel joined
[02:24] *** yqt left
[02:29] *** rba_ left
[02:29] *** rba__ joined
[02:31] *** DarthGandalf left
[02:32] *** DarthGandalf joined
[02:35] *** rmgk is now known as Guest2154

[02:35] *** rmgk_ joined
[02:35] *** Guest2154 left
[02:35] *** rmgk_ is now known as rmgk

[02:40] *** noganex joined
[02:43] *** vendethiel left
[02:43] *** noganex_ left
[02:48] *** zj joined
[02:58] *** rba__ left
[02:58] *** rba_ joined
[03:12] *** bin_005_u_j joined
[03:13] *** telex left
[03:14] *** telex joined
[03:21] *** davido_ left
[03:22] *** davido_ joined
[03:36] *** Sqirrel joined
[03:40] *** [particle] left
[03:40] *** [particle] joined
[03:45] *** zj left
[03:53] *** bin_005_u_j left
[03:55] *** koo6 left
[03:56] *** BenGoldberg left
[04:00] <moritz> hoelzro: how much does that increase rakudo setting compilation and baseline memory consumption?

[04:12] <hoelzro> moritz: I tried loading Perl5::Grammar (the largest I could find) into a rakudo with and without the patch; the difference was negligible (a few hundred KB)

[04:13] *** zhanggong joined
[04:13] <hoelzro> which is suspicious, to say the least

[04:15] * hoelzro sleeps

[04:16] *** census left
[04:18] <moritz> hoelzro: good night

[04:19] <moritz> wow, perl 5.22 has hex float literals

[04:21] *** zhanggong left
[04:30] *** laouji left
[04:47] *** laouji joined
[04:57] *** amurf joined
[05:47] *** domidumont joined
[05:51] *** domidumont left
[05:52] *** domidumont joined
[05:56] *** kaare_ joined
[05:57] *** rba_ left
[06:00] *** diana_olhovik_ joined
[06:01] *** kurahaupo1 joined
[06:21] *** skids left
[06:22] *** domidumont left
[06:23] *** espadrine joined
[06:26] *** _mg_ joined
[06:27] *** mr-foobar left
[06:40] *** quester joined
[06:50] *** amurf left
[06:50] *** mr-foobar joined
[06:52] *** lizmat joined
[06:53] *** colomon left
[06:56] *** FROGGS joined
[07:01] *** Ven joined
[07:02] *** SevenWolf left
[07:05] *** rba_ joined
[07:06] *** zakharyas joined
[07:10] *** mtj_ left
[07:11] *** mtj_ joined
[07:13] <masak> morning, #perl6

[07:13] <FROGGS> morning

[07:13] <masak> m: say 0x5.8 # do we have hex float literals?

[07:13] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ymEl0W5u7c␤Confused␤at /tmp/ymEl0W5u7c:1␤------> 3say 0x5.7⏏058 # do we have hex float literals?␤    expecting any of:␤        dotty method or postfix␤»

[07:13] <masak> nnnnope.

[07:14] <FROGGS> m: say pi.fmt('%#x')

[07:14] <camelia> rakudo-moar c2a57e: OUTPUT«0x3␤»

[07:14] <FROGGS> fair enuff

[07:15] <masak> "engineer's pi" :P

[07:16] <nwc10> test

[07:16] <FROGGS> :D

[07:16] <FROGGS> ok 1 - test

[07:16] <nwc10> er, nah.

[07:16] <nwc10> the joke is

[07:16] <nwc10> "what's pi?"

[07:16] <nwc10> er.

[07:16] <nwc10> correctin

[07:16] <nwc10> "what's the value of pi?"

[07:17] <FROGGS> hehe

[07:17] <nwc10> mathemetician: well, it's Pi, isn't it

[07:17] <nwc10> physicist: 3.1, within experimental error

[07:17] <nwc10> engineer: allowing for a small safety factor - 18

[07:18] <FROGGS> engineers++

[07:20] *** jack_rabbit joined
[07:21] <moritz> nah, the pysiciist says pi = 3.1 +- 0.05

[07:21] <moritz> s/ii/i/

[07:21] *** RabidGravy joined
[07:21] <moritz> "I'm 69% confident that pi is in range [3.05, 3.15]"

[07:21] <FROGGS> and I know what jnthn++ would say :o)

[07:22] <nwc10> moritz: I think you're actually right, but the joke was never told to me that way.

[07:22] <nwc10> and your way actually works better.

[07:22] *** rba_ left
[07:23] * nwc10 goes back to "break all the things" at work.

[07:23] <nwc10> (this isn't the plan. It's very much what I'm trying *not* to do)

[07:23] * moritz happens to have studied physics, a long time ago

[07:28] <lizmat> good *, #perl6!

[07:28] * lizmat realizes she did dabble in physics a longer time ago  :-)

[07:29] <FROGGS> morning lizmat 

[07:32] *** jack_rabbit left
[07:32] <lizmat> FROGGS o/

[07:43] *** cognominal joined
[07:46] <lizmat> timotimo++  # P6W

[07:47] *** rindolf joined
[07:50] <moritz> timotimo++ # indeed

[07:50] <moritz> another change we had last week was the new front page layout for http://design.perl6.org/, and that the pod6 files are now automatically turned to HTML too

[07:51] <DrForr> Oh, I've just been using module.perl.org for that.

[07:53] *** FROGGS left
[08:02] <dalek> rakudo/nom: 2cc3afe | lizmat++ | src/core/Regex.pm:

[08:02] <dalek> rakudo/nom: Fix calling Regex.gist/perl on a type object

[08:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2cc3afe985

[08:05] <tadzik> What's the dillema, isn't Pi half Tau? :)

[08:06] *** FROGGS joined
[08:06] <moritz> DrForr: using module.perl.org for what?

[08:07] <FROGGS> yay! a p6w

[08:09] <DrForr> reading synopses. Someone posted it as a link, or I tyop'ed it a while back.

[08:09] *** darutoko joined
[08:10] <FROGGS> timotimo: btw, -3 and friends show up often in match results... does it make sense to adjust the int cache?

[08:11] <dalek> Heuristic branch merge: pushed 23 commits to rakudo/newio by lizmat

[08:11] *** colomon joined
[08:13] *** espadrine left
[08:15] <FROGGS> domm++ # "[...] And as of 2015-06-02T10:00:00 I'm using Perl6 in production"

[08:18] <tadzik> Where's that from?

[08:19] <masak> his blog post?

[08:20] <masak> http://domm.plix.at/perl/2015_05_a_very_simple_perl6_script.html

[08:20] <masak> yep :)

[08:20] <tadzik> Oh, I didn't notice it in there

[08:21] <masak> also very encouraging: "My plan for the next months: Port a few more of my various helper scripts and tools to Perl6!"

[08:21] <moritz> seems to be a later update, since the blog post was written in May

[08:22] <masak> domm should hang around here, so that we can help him more! :)

[08:23] <tadzik> He seems fairly self-sufficient, thanks to error messages :)

[08:23] <masak> well, yes and no.

[08:23] <moritz> MAIN did help

[08:23] <masak> note that he got help from both FROGGS++ and smls++ along the way.

[08:24] <tadzik> Ah :)

[08:24] *** spider-mario left
[08:26] *** spider-mario joined
[08:26] *** torbjorn left
[08:27] <RabidGravy> is there any particular reason there isn't a 'mode' to go along with 'chmod' in IO::Path or is it just no-one got to doing it yet?

[08:27] <dalek> specs: 2cd06fd | (Stéphane Payrard)++ | S99-glossary.pod:

[08:27] <dalek> specs: S99:  added P6W, spotted in #perl6. Fixed a typo

[08:27] <dalek> specs: review: https://github.com/perl6/specs/commit/2cd06fd900

[08:28] <FROGGS> RabidGravy: is that something portable?

[08:29] <RabidGravy> well all the bits appear to be there in nqp - so if nqp::stat is portable it would be

[08:30] *** fhelmberger joined
[08:30] <FROGGS> RabidGravy: how would the result of calling .mode look like?

[08:30] <RabidGravy> a number

[08:31] <FROGGS> like 0777?

[08:31] <RabidGravy> yeah

[08:31] <FROGGS> err, 0o777

[08:31] <FROGGS> RabidGravy: and on windows?

[08:33] <RabidGravy> who knows, I don't want to go look in the uv code to go that far

[08:34] *** espadrine joined
[08:34] *** laouji left
[08:35] <FROGGS> I just think that squeezing things into unix-isms is not always the best thing we can do

[08:36] <FROGGS> that's why I like the .IO.e and .IO.x methods... these tell properly what is going on

[08:36] <lizmat> afk&

[08:36] <tadzik> +1

[08:36] <RabidGravy> sure but there is already chmod

[08:38] <FROGGS> true

[08:38] *** cschwenz joined
[08:39] *** colomon left
[08:40] <RabidGravy> and, except for the most simple cases, chmod isn't very useful without knowing what the mode of the file already was

[08:44] <moritz> RabidGravy: I disagree; when deploying files, you usually want them to have specifically defined permissions after the deploy, indepently of how the copying mod()ed them before

[08:44] *** laouji joined
[08:45] *** gfldex joined
[08:46] <RabidGravy> you're not always deploying files though

[08:47] *** larion joined
[08:51] *** spider-mario left
[08:51] *** aborazmeh joined
[08:51] *** aborazmeh left
[08:51] *** aborazmeh joined
[08:51] *** mr-foobar left
[08:56] <FROGGS> hmmm, I'm also under the impression that I usually want to e.g. +rwx a file, no matter what the flags are currently...

[08:56] *** mr-foobar joined
[08:57] <RabidGravy> yeah, in the case I am looking at the moment I want to ugo+x a file keeping the other permissions

[08:58] <RabidGravy> so if it was 0o644 it becomes 0o755 etc

[09:05] *** itz_ joined
[09:06] <RabidGravy> now I'm curious as to what uv_fs_stat returns for mode on non-Unix like systems, but I can't be arsed to get the Windows laptop, install a compiler, swear at it a lot and see

[09:06] *** xfix joined
[09:06] *** xfix left
[09:06] *** xfix joined
[09:08] *** Ven left
[09:10] <itz_> which windows compiler is needed? is there a free one?

[09:12] <moritz> iirc there is a visual studio "Free as in beer" version

[09:12] <FROGGS> itz: visual studio 2012 express will do

[09:13] <FROGGS> RabidGravy: I can test stuff on windows for you

[09:15] *** Akagi201 left
[09:15] *** larion left
[09:22] *** mephinet joined
[09:25] *** bin_005 joined
[09:25] *** xfix left
[09:38] *** bin_005 left
[09:39] *** quester left
[09:40] <RabidGravy> FROGGS, I was just curious as to what nqp::p6box_i(nqp::stat(nqp::unbox_s("somefilepath"), nqp::const::STAT_PLATFORM_MODE)) would return on windows

[09:41] <FROGGS> let's see

[09:43] <itz_> why does the recent win * disable jit?

[09:43] <FROGGS> C:\MoarVM>perl6-m -e "use nqp; say nqp::p6box_i(nqp::stat(nqp::unbox_s('VERSION'), nqp::const::STAT_PLATFORM_MODE))"

[09:43] <FROGGS> 33206

[09:43] <FROGGS> RabidGravy: ^^

[09:43] <FROGGS> itz: it is only disabled on 32bit systems

[09:43] <itz_> ah

[09:44] <FROGGS> or even more correct: it was never implemented for other than 64bit systems

[09:46] <FROGGS> m: given 42 { .fmt('%#d').say; .fmt('%#x').say; .fmt('%#o').say } # there should be '0o52', right?

[09:46] <camelia> rakudo-moar c2a57e: OUTPUT«42␤0x2a␤052␤»

[09:47] <RabidGravy> FROGGS, which is exactly what it returns on Linux  for rw-rw-rw

[09:47] <FROGGS> bbiab # lunch

[09:47] *** koo6 joined
[09:49] *** AlexDaniel joined
[09:51] *** bin_005 joined
[09:51] *** _mg_ left
[09:52] <RabidGravy> (libuv people)++ # got that thing down

[09:55] *** achauvin left
[09:58] *** colomon joined
[09:58] *** achauvin joined
[10:01] *** kurahaupo1 left
[10:04] <RabidGravy> I'm going to think about it in the pub for a bit, but I think that there should be an IO::Path.mode and it should return some abstraction like an IO::Path::Mode

[10:05] <RabidGravy> and that it should be a multi which will accept one and do chmod as appropriate

[10:06] <RabidGravy> right, off out pet shop --> supermarket --> pub

[10:11] *** RabidGravy left
[10:15] *** brrt joined
[10:20] *** brrt left
[10:22] *** amurf joined
[10:27] *** amurf left
[10:28] *** zengargoyle left
[10:29] *** cschwenz left
[10:37] *** aborazmeh left
[10:37] *** rindolf left
[10:40] *** lizmat left
[10:42] *** Sqirrel left
[10:51] *** Sqirrel joined
[10:51] *** bin_005 left
[10:52] *** lizmat joined
[10:53] *** zengargoyle joined
[10:57] *** salva left
[10:59] *** cognominal left
[11:01] *** koo6 left
[11:03] *** salva joined
[11:04] <masak> m: say :16<a0.8>

[11:04] <camelia> rakudo-moar c2a57e: OUTPUT«160.5␤»

[11:04] *** larion joined
[11:04] <masak> oh. that's how you do non-int hex numbers in Perl 6. fair enough.

[11:05] <masak> maybe `0xa0.8` should suggest that syntax, though?

[11:05] <masak> m: say 0xa0.8

[11:05] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tRD4pNOsNE␤Confused␤at /tmp/tRD4pNOsNE:1␤------> 3say 0xa0.7⏏058␤    expecting any of:␤        dotty method or postfix␤»

[11:05] <masak> it's a little too unprepared for that (hexa)decimal point :)

[11:08] *** Ven joined
[11:16] *** _mg_ joined
[11:22] *** bbkr_ joined
[11:23] *** smls joined
[11:25] <smls> Why is there an ASSIGN-KEY, even though AT-KEY already returns an rw container suitable for assigning?

[11:26] <masak> I think ASSIGN-KEY is deprecated.

[11:27] <smls> well, it's used though.

[11:27] <masak> hm, no. I read that wrong.

[11:27] <masak> it's the lower-case version that's deprecated.

[11:28] <smls> ah, found some relevant discussion: http://irclog.perlgeek.de/perl6/2015-03-13#i_10275156

[11:30] <smls> seems it's just for optimization purposes.

[11:34] *** vendethiel joined
[11:44] <smls> m: my $x := Proxy.new(:FETCH(-> $ { say "fetch"; 42 }), :STORE(-> $, \val { say "store {val}" })); $x++; say $x

[11:44] <camelia> rakudo-moar c2a57e: OUTPUT«fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤store 43␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤42␤»

[11:44] <smls> ^^ how come Perl 6 is so fetch happy? :P

[11:44] *** Ven left
[11:44] <masak> m: my $x := Proxy.new(:FETCH(-> $ { say "fetch"; 42 }), :STORE(-> $, \val { say "store {val}" })); say $x

[11:44] <camelia> rakudo-moar c2a57e: OUTPUT«fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤42␤»

[11:45] <masak> m: my $x := Proxy.new(:FETCH(-> $ { say "fetch"; 42 }), :STORE(-> $, \val { say "store {val}" })); 5

[11:45] <camelia> rakudo-moar c2a57e: ( no output )

[11:46] <masak> smls: I guess the short answer is "because a bunch of things inside how `say` is implemented don't cache the value"

[11:46] <masak> ditto postfix:<++>

[11:56] <Woodi> hallo today :)

[11:56] <smls> Hello

[11:57] <Woodi> so, Intel bought Altera, FPGA company... reprogrammable/general-purpose CPUs soon ? :)

[11:58] *** vendethiel left
[12:00] <Woodi> but about Perl6 vs Debian... I remember some discusion that including some libraries (with patches) makes MoarVM impossible to unclude in Debian...

[12:00] <Woodi> s/some_u/i/

[12:01] <Woodi> no idea how to deal with that...

[12:02] *** larion left
[12:08] *** vendethiel joined
[12:10] *** rmgk left
[12:11] *** muraiki joined
[12:11] *** rindolf joined
[12:12] *** rmgk joined
[12:18] <dalek> rakudo-star-daily: f5ca1c1 | coke++ | log/ (2 files):

[12:18] <dalek> rakudo-star-daily: today (automated commit)

[12:18] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/f5ca1c197a

[12:22] *** smash joined
[12:27] <smls> Didn't we have something like a ONCE phaser?

[12:27] <smls> i.e. like INIT, but executed when it is first reached by the control flow.

[12:27] <smls> Or was that just speculation?

[12:30] <grondilu> m: for ^10 { once say "ok" }

[12:30] <camelia> rakudo-moar c2a57e: OUTPUT«ok␤»

[12:30] *** kjs_ joined
[12:30] *** vendethiel left
[12:30] <smls> ah

[12:31] <grondilu> interestingly:

[12:31] <grondilu> m: once say "ok" for ^10

[12:31] <camelia> rakudo-moar c2a57e: OUTPUT«ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤»

[12:31] *** larion joined
[12:31] * grondilu is not sure this is a bug or not

[12:32] <smls> maybe phaser-like statement prefixes simply have looser precedence than the 'for' statement suffix?

[12:32] <grondilu> m: INIT say "ok" for ^10

[12:32] <camelia> rakudo-moar c2a57e: OUTPUT«ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤ok␤»

[12:32] <grondilu> seems so

[12:35] *** kjs_ left
[12:36] <masak> yes, they do.

[12:36] <masak> you should read it as `once (say "ok" for ^10)`

[12:36] <masak> this is what characterizes statement prefixes.

[12:37] <masak> m: (once say "ok") for ^10

[12:37] <camelia> rakudo-moar c2a57e: ( no output )

[12:37] <masak> m: { once say "ok" } for ^10

[12:37] <camelia> rakudo-moar c2a57e: OUTPUT«ok␤»

[12:37] * masak wonders why that first one didn't work

[12:37] <smls> m: start 42+1

[12:37] <camelia> rakudo-moar c2a57e: OUTPUT«Type check failed in binding &code; expected 'Callable' but got 'Int'␤  in block <unit> at /tmp/XdO4zTrDGk:1␤␤»

[12:37] <FROGGS> Woodi: there already is a moarvm package for debian in a review queue (with hundreds of other packages)... so there should be no issue

[12:38] <smls> S04:1390 suggests start is one of these statement prefixes too, but it doesn't seem to be in Rakudo.

[12:38] <synbot6> Link: http://design.perl6.org/S04.html#line_1390

[12:38] <masak> smls: please submit that as a rakudobug

[12:38] <FROGGS> Woodi: and we support linking against packaged libtommath and other libs, so they dont have to use our patched versions

[12:38] <smls> well, maybe I'm misinterpreting the design docs?

[12:39] <smls> it's not super explicit about it.

[12:40] <masak> "They parse the same as phasers" and `try` already working that way both seem to point to your conclusion.

[12:40] <masak> also, it makes sense to me that `start` would take a blorst.

[12:42] *** RabidGravy joined
[12:44] *** Ven joined
[12:44] *** brrt joined
[12:44] <RabidGravy> boom

[12:45] *** dalek left
[12:46] *** dalek joined
[12:46] *** ChanServ sets mode: +v dalek

[13:01] *** smls left
[13:05] * itz_ feels stupid for not trying the "hub" command line utility earlier

[13:05] <brrt> what is the hub command line utility

[13:06] <itz_> https://hub.github.com/

[13:06] <masak> https://hub.github.com/

[13:06] *** Akagi201 joined
[13:06] <itz_> snap! 

[13:06] <masak> sorry, lag :)

[13:06] *** Akagi201 left
[13:07] *** Akagi201 joined
[13:09] <RabidGravy> that's quite cool

[13:10] *** flaviusb left
[13:12] *** mr-fooba_ joined
[13:13] *** mr-foobar left
[13:14] *** justSomeone joined
[13:19] *** justSomeone left
[13:24] *** stux|RC-only left
[13:25] *** stux|RC-only joined
[13:26] *** RabidGravy left
[13:30] *** RabidGravy joined
[13:31] *** muraiki left
[13:31] *** Tux__ is now known as |Tux|

[13:33] *** muraiki joined
[13:38] <arnsholt> Wow. Return of vengeance of the Python object model

[13:38] <arnsholt> Because looking things up via the type hierarchy would be too easy: https://gist.github.com/arnsholt/a753bdbb8faf430a105b

[13:43] * masak .oO( Venceance of the Python object model II )

[13:43] <arnsholt> Yeah

[13:44] <arnsholt> That was an odd one

[13:44] <arnsholt> I thought instance creation was relatively simple, but turns out it isn't

[13:45] <masak> waitwait

[13:46] <masak> the more I look, the less surprised I am

[13:46] <arnsholt> Oh, wait

[13:46] <arnsholt> I derped, didn't i?

[13:46] <arnsholt> Accidentally the inheritance >.<

[13:46] <masak> the list of argument passed to `D(...)` has to match the __init__

[13:46] <masak> in your first snippet, it doesn't.

[13:47] *** espadrine_ joined
[13:47] <arnsholt> If I add the inheritance (which is what I was supposed to be testing!) it works as expected

[13:47] <masak> \o/

[13:47] <arnsholt> I just happened to be a marroon

[13:47] <masak> Python is less surprising than you started to fear! :P

[13:49] <arnsholt> Oh. Except having an __init__ but not a __new__ actually has to do something like installing a __new__ for you

[13:49] <arnsholt> Since "class C: def __init__(self, a, b, c): pass; C()" doesn't complain about too many arguments

[13:50] <arnsholt> Hmm.

[13:50] <Woodi> FROGGS: I didn't know that. so probably around January 2016 things will look better :)

[13:51] *** espadrine left
[13:51] *** laouji left
[13:51] <FROGGS> Woodi: hopefully before that point :o)

[13:51] <FROGGS> we need more testers

[13:51] <masak> got linked to this SEND + MORE = MONEY post in Factor: http://re-factor.blogspot.se/2015/06/send-more-money.html

[13:51] *** brrt left
[13:51] <masak> "backtrack vocabulary". interesting.

[13:51] <masak> Factor is interesting.

[13:54] *** virtualsue joined
[13:54] *** araujo left
[13:57] *** Akagi201 left
[13:59] <lizmat> commute to Amsterdam.pm&

[13:59] *** lizmat left
[14:00] *** araujo joined
[14:00] *** amurf joined
[14:00] *** Akagi201 joined
[14:01] *** araujo left
[14:02] <masak> just saw a really good point being made on Reddit:

[14:02] <itz_> resolve stage failed for IO::Socket::SSL: Dependency OpenSSL is not present in the module ecosystem"

[14:02] <masak> Perl isn't dying, or legacy, or passé. the correct term is "established".

[14:03] <itz_> what is the status of https support in web client libs?

[14:03] <masak> itz_: I know it works, and I know sergot was working on it a few summers ago.

[14:05] *** amurf left
[14:06] *** Ven left
[14:06] <masak> also just noticed: even though I covered November 22 three times in my November blog posts, none of them (strangely) mentions the JFK assassination.

[14:07] <PerlJam> masak: at least you're strangely consistent!  :)

[14:08] <itz_> hmmm OpenSSL isn't in the eco system but the tests pass

[14:10] <masak> PerlJam: serve, smash :P

[14:15] *** ][Sno][ left
[14:16] *** ][Sno][ joined
[14:16] <moritz> ... hulk.

[14:17] *** telex left
[14:18] *** telex joined
[14:18] *** salv0 joined
[14:20] *** FROGGS left
[14:21] *** salv0 left
[14:34] *** gfldex left
[14:44] <itz_> error:1408F119:SSL routines:SSL3_GET_RECORD:decryption failed or bad record mac

[14:49] *** araujo joined
[14:49] *** araujo left
[14:50] <masak> itz_: maybe someone better at SSL can help you with only that little information. I can't. :/

[14:51] <itz_> it seems to resemble an existing problem https://github.com/sergot/openssl/issues/1 

[15:04] <arnsholt> masak: In case you wondered, I found an exegetic comment about the __new__/__init__ behaviour in the CPython sources =)

[15:04] <arnsholt> Confusion cleared =D

[15:06] <itz_> m: use IO::Socket::SSL; my $sock = IO::Socket::SSL.new(:host<p6weekly.wordpress.com>, :port(443)

[15:06] <camelia> rakudo-moar c2a57e: OUTPUT«===SORRY!===␤Could not find IO::Socket::SSL in any of:␤  file#/home/camelia/.perl6/2015.05-29-gc2a57ec/lib␤  inst#/home/camelia/.perl6/2015.05-29-gc2a57ec␤  file#/home/camelia/rakudo-inst-2/share/perl6/lib␤  file#/home/camelia/rakudo-inst-2/share…»

[15:07] <masak> arnsholt: nice :)

[15:07] <masak> arnsholt: are you able to summarize it for us interested-but-lazy onlookers?

[15:09] <moritz> speaking of python, OO, and confused...

[15:09] <moritz> in  def __init__(self, stuff):\n super().__init__(stuff)

[15:09] * masak .oO( pythoonfused )

[15:09] <moritz> where/how does super() get its reference to self?

[15:10] <RabidGravy> magic

[15:10] <arnsholt> moritz: It's the Zen of Python! Implicit is better than explicit!

[15:10] <arnsholt> (Or something along those lines ;)

[15:10] <masak> :P

[15:10] <masak> "magic" is the explanation I recall too, yes.

[15:10] <arnsholt> But what RabidGravy said, more or less

[15:11] <masak> arnsholt: by the way -- I didn't mention before -- as a Python 2 user I've trained myself to always inherit from object, so I don't end up with the old (non-)MOP.

[15:11] <arnsholt> Basically a zero-arg call to a function named super() will magically get two arguments: the first argument passed (and looked up in the actually bound arguments, *not* by name!) and __class__

[15:12] <arnsholt> Yeah, I recently learned about old-style classes when trying to figure out why my descriptors weren't called

[15:13] <arnsholt> masak: Exegesis: https://github.com/python/cpython/blob/master/Objects/typeobject.c#L3341-L3377

[15:13] <masak> I just tried on the Python REPL.

[15:13] <masak> apparently it's `super(D)` (for your class D)

[15:13] <masak> and the object you get back is a <type 'super'>, that is, a special magic object

[15:14] <arnsholt> Basically, object.__new__ compares cls.{__new__,__init__} to object.{__new__,__init__} and only complains in some cases

[15:14] <arnsholt> Oh, in this case Python 3 and Python 2 are different

[15:14] <arnsholt> Python 3 has a magical zero-arg super(), but Python 2 doesn't

[15:14] <masak> aha.

[15:15] <arnsholt> Because reasons, presumably

[15:15] <masak> where does Python 3 get "the current class" from?

[15:15] <arnsholt> It's implicitly inserted, of course! =)

[15:16] <masak> but you can also provide it explicitly?

[15:16] <arnsholt> If your function mentions super() or a variable __class__ you automatically get a variable __class__ (containing the current class, obv)

[15:16] <arnsholt> Yeah, there's a two-arg form of super too

[15:17] <arnsholt> "__class__ is an implicit closure reference created by the compiler if any methods in a class body refer to either __class__ or super. "

[15:17] <RabidGravy> the bunch of __name__ things is what upsets me most about python

[15:17] <masak> I used to not like them.

[15:18] <masak> but then I realized they're basically equivalent to Perl's "pipes sticking out".

[15:18] <masak> it's just that Perl likes symbols, like $. and $/

[15:18] <masak> and Python really likes underscores

[15:19] *** andreoss joined
[15:20] <RabidGravy> this is true

[15:20] *** larion left
[15:27] *** diana_olhovik_ left
[15:27] *** g4 left
[15:30] <geekosaur> hm, I'd have compared them to uppercase

[15:30] <geekosaur> they tend to be the magic names invoked automatically by various things

[15:30] *** zakharyas left
[15:31] <masak> that's also a nice comparison

[15:31] <masak> except Perl 6 uppercases all kinds of things, like EVAL :P

[15:32] <arnsholt> Yeah, they're not too bad. And descriptors are really neat

[15:32] <masak> Python's attribute access feels very close to JavaScript's. but for some reason I like Python's better.

[15:33] <masak> probably mostly because Python gets the "bound method" waterbed wrinkle very right.

[15:33] <masak> JavaScript, Perl 5 and Perl 6 all fail at that, all in different ways.

[15:39] <rjbs> descriptors?

[15:40] <rjbs> Oh yes!

[15:40] <rjbs> I had forgotten all about those, gosh.

[15:40] <arnsholt> Yeah the whole method thing confused me a lot until I got it

[15:41] *** smls joined
[15:41] <moritz> it just seems weird that calling a method is accessing an attribute + calling it, but then there's magic (descriptors) to make the attribute access itself call a method

[15:45] *** salva left
[15:46] <PerlJam> masak: please blog on the subject and include (possibly rebut) moritz's observation   :-)

[15:47] *** _mg_ left
[15:48] <moritz> so I kinda find Perl 6's approach moar intuitive: expose both methods and attributes as methods (to the outside of the class, at least)

[15:48] <andreoss> what can i use to make Match.perl be more readble? it doesn't even show matches themself, only positions that match 

[15:48] <TimToady> does it actually store anything in the object corresponding to the "attribute"?

[15:48] *** eternaleye left
[15:48] <moritz> andreoss: you can use Match.gist instead

[15:49] <moritz> andreoss: .perl is meant to be machine(perl)-redable, not necessarily human readable

[15:49] <andreoss> oh. thanks

[15:51] <TimToady> to me, it seems that python is using class attributes as a proxy for meta attributes, and I find class attributes generally smelly, compared to a clean .HOW separation

[15:52] *** araujo joined
[15:55] <masak> PerlJam: yes, I've been wanting to blog about method binding. not least because I want to udnerstand it better.

[15:55] <masak> Ruby is worth mentioning there, too.

[15:57] *** eternaleye joined
[16:08] *** garu_ joined
[16:09] *** diana_olhovik_ joined
[16:11] <smls> m: say ("a1", "b2")>>.subst(/\d/, {$/ + 1})

[16:11] <camelia> rakudo-moar c2a57e: OUTPUT«Use of Nil in numeric context  in block  at /tmp/zBtCpmKoGh:1␤Use of Nil in numeric context  in block  at /tmp/zBtCpmKoGh:1␤a1 b1␤»

[16:12] <smls> ^^ why is $/ undefined here?

[16:13] <smls> m: say ("a1", "b2").map({ .subst(/\d/, {$/ + 1}) })   # here too

[16:13] <camelia> rakudo-moar c2a57e: OUTPUT«Use of Nil in numeric context  in block  at /tmp/NY8r0uP7y2:1␤Use of Nil in numeric context  in block  at /tmp/NY8r0uP7y2:1␤a1 b1␤»

[16:13] <smls> m: say "a1".subst(/\d/, {$/ + 1})   # whereas this works

[16:13] <camelia> rakudo-moar c2a57e: OUTPUT«a2␤»

[16:13] <PerlJam> m: say ("a1", "b2")>>.subst(/\d/, -> $/ {$/ + 1})  # btw

[16:13] <camelia> rakudo-moar c2a57e: OUTPUT«a2 b3␤»

[16:14] <smls> rakudo bug?

[16:15] <PerlJam> There's something on the tip of my brain about that behavior but it's not forming a coherent thought.

[16:27] <timotimo> we can't just make the block have a $/ defined in it without some really black magic

[16:27] <timotimo> not as long as .subst is a regular method

[16:28] <timotimo> we could invent a syntax for "a block that takes $/ as its parameter", though :P

[16:28] <timotimo> or perhaps give $/ the same behavior as $_ for implicit signatures or something

[16:29] <smls> or give s/// a non-mutating form (like s///g in Perl 5) so we do't need .subst

[16:29] <smls> I meant, s///r in P5

[16:29] <TimToady> adding to the implicit closure signature sounds like a really great way to slow everything down

[16:30] <timotimo> i wasn't serious about my ideas - though i kind of hoped someone would take them and run with it to reach a better idea

[16:32] *** skids joined
[16:33] *** espadrine_ is now known as espadrine

[16:42] <smls> my $b = $a =~ s/-(\w+)-/_$1_/r;                     # Perl 5

[16:42] <smls> my $b = $a.subst(/'-'(\w+)'-'/, -> $/ { "_$0_" });  # Perl 6

[16:42] <smls> I can't be the only one who's unhappy with how the Perl 6 version is so much harder to write and read?

[16:43] <timotimo> yeah, it's not that good, really

[16:43] *** spider-mario joined
[16:46] <TimToady> m: my $a = "-xyz-"; (my $b = $a) ~~ s[ '-' (\w+) '-'] = "_$0_"; say $b

[16:46] <camelia> rakudo-moar c2a57e: OUTPUT«_xyz_␤»

[16:46] <hoelzro> this is a neat feature: http://package.elm-lang.org/#reliable-versioning

[16:46] <tony-o_> smls: you can just use the p5 regex

[16:46] <hoelzro> namely the "elm-package diff evancz/elm-html 1.0.0 1.1.0" part

[16:47] <smls> TimToady: less messy, but still more difficult to read.

[16:47] <smls> Why not just:

[16:47] <smls> 1) Make `~~ s///` non-mutating by default - just like chomp() & friends have been made non-mutating by default.

[16:47] <smls> 2) Let `~~= s///` be its mutating form - just like $x.=chomp; can be used to mutate.

[16:47] <tony-o_> personally i was irritated and frustrated by the regex change, i find it a lot easier to read and debug now that ive used them

[16:49] <tony-o_> and used them fairly extensively

[16:49] <smls> tony-o_: I'm not talking about the changes to the regex language itself (which I generally like), but rather the behavior and API of the s/// form and .subst method.

[16:49] *** stanrifkin joined
[16:49] *** leont joined
[16:49] <leont> Who wrote http://iinteractive.com/notebook/2015/06/02/rakudobrew.html?

[16:49] <TimToady> that would be terribly confusing to P5ers

[16:49] <smls> more than chomp?

[16:50] *** rindolf left
[16:50] *** itz_ left
[16:50] <stanrifkin> my $n = @ARGS[0]; does not work somehow. Is @ARGV is @ARGS now or not?

[16:50] <leont> The result of that script is wrong in a rather embarrassing way. I suspect the MetaCPAN query is all wrong. The results are probably for "dists with most uploaded releases", not "most upvoted dists".

[16:50] <tony-o_> @*ARG

[16:50] <TimToady> @*ARGS

[16:50] <PerlJam> stanrifkin: @*ARGS

[16:51] <TimToady> ARGHS!!! :)

[16:52] <japhb> m: say +'0xa0.8'  # masak: Str.Numeric FTW yet again.  ;-)

[16:52] <camelia> rakudo-moar c2a57e: OUTPUT«160.5␤»

[16:52] <timotimo> japhb: and we wonder why we're slow :P

[16:53] <stanrifkin> TimToady: good to memorize :)

[16:53] <japhb> timotimo: Because I didn't write the main parser? >;-)

[16:53] <timotimo> you're going to rewrite the regex engine? :)

[16:53] <timotimo> or just replace the perl6 parser with a custom-built one? :D

[16:54] <japhb> timotimo:  I think you would have to buy me out of my current $dayjob before I'd consider that one.  :-)

[16:54] *** llfourn left
[16:54] <TimToady> m: say %*ENV

[16:54] <camelia> rakudo-moar c2a57e: OUTPUT«HOME => /home/camelia, LANG => POSIX, LC_CTYPE => en_US.UTF-8, LOGNAME => camelia, MANPATH => /home/camelia/perl5/perlbrew/perls/perl-5.20.1/man:, PATH => /home/camelia/perl5/perlbrew/bin:/home/camelia/perl5/perlbrew/perls/perl-5.20.1/bin:/usr/local/sbin:/…»

[16:54] <TimToady> stanrifkin: ^^ likewise ENV

[16:54] <timotimo> hehehe.

[16:55] <timotimo> leont: i wonder where the "get icu to have unicode on parrot" comes from, as we've suspended parrot support for a while

[16:55] <rjbs> I have no joke, I just like pronouncing @*ARGS as "stargs".

[16:56] <timotimo> huh, the person who wrote that article is on 2014.10?

[16:56] <stanrifkin> is there a perl6doc?

[16:57] <timotimo> "p6doc" exists

[16:57] <timotimo> it gets you the same stuff that you can find on doc.perl6.org

[16:59] <DrForr> perl6 --doc path/to/filename.pm # as well.

[17:01] *** fhelmberger left
[17:03] <skids> DrForr: if you can find a Filename.pm anymore. :-/

[17:07] <dalek> perl6-roast-data: 98754c3 | coke++ | / (8 files):

[17:07] <dalek> perl6-roast-data: today (automated commit)

[17:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/98754c3f6b

[17:08] <[ptc]> um, why isn't modules.perl6.org not showing any modules?

[17:08] <timotimo> damn

[17:09] *** diana_olhovik_ left
[17:09] *** gfldex joined
[17:11] *** inokenty left
[17:12] *** vendethiel joined
[17:14] <skids> Hmmm... Maybe perl6-doc -Mmy::mod could be taught to find the lib/my/mod.pm(6).

[17:14] *** llfourn joined
[17:15] <stanrifkin> skids: i didn't found a package in the repository (debian jessie)

[17:16] <stanrifkin> skids: but doc.perl6.org seems to be fine - not quite complete...

[17:17] <stanrifkin> do you prefer *.p6 as filenames?

[17:17] <skids> stanrifkin: if you are using debian packages for rakudo, they are severely out of date by now.

[17:18] <skids> personally I use .pm6 but most folks just use .pm.

[17:18] <stanrifkin> skids: 2014 07 it says

[17:18] *** Possum left
[17:18] <skids> Yeah that will be very old, because lots of things are happening rather quickly these days.

[17:19] <stanrifkin> skids: it is only for playing around

[17:20] *** andreoss left
[17:20] <skids> OK.  But it is pretty easy to build a fresh one, see 'https://github.com/tadzik/rakudobrew'

[17:21] <TimToady> m: say ("a1", "b2").map(sub ($src) { $src.subst(/\d/, {$/ + 1}) })

[17:21] <camelia> rakudo-moar c2a57e: OUTPUT«a2 b3␤»

[17:21] <TimToady> it would appear that .subst only sets $/ correctly when called directly from a Routine, not from a Block

[17:22] <TimToady> (because a Block doesn't have it's own $/)

[17:22] *** Woodi left
[17:23] *** gfldex left
[17:28] <TimToady> so the Block is relying on some $/ in its dynamic scope that perhaps should not be relied upon

[17:30] <[ptc]> timotimo: it seems that modules.perl6.org is back again

[17:30] <timotimo> strange

[17:30] <timotimo> i believe someone has the logs for that

[17:30] <timotimo> maybe it's on hack?

[17:31] <smls> TimToady: The non-mutating s///r form that has been added to Perl 5.14 in 2013, has actually become quite popular in the P5 world. So when it comes to their ability to handle non-mutating s///, P5ers might just surprise you.

[17:31] <smls> I'll shut up about it now, but please think about it.

[17:32] <TimToady> I've been thinking about it for months...

[17:35] <TimToady> one of the reasons I changed s and m and such to be overridable, in fact, so we could experiment with new "kinda reserved" quoting forms

[17:35] *** FROGGS joined
[17:35] <TimToady> but :r is taken, and I consider /r to be an ugly hack in P5

[17:35] *** vendethiel left
[17:35] <TimToady> so we need some other way

[17:36] <FROGGS> o/

[17:36] *** jferrero left
[17:36] *** jferrero joined
[17:36] *** _mg_ joined
[17:38] *** amurf joined
[17:41] *** espadrine left
[17:43] *** amurf left
[17:43] <TimToady> thing is, ~~ doesn't work at all with forms of s/// that return the new value, and can't be made to work without some of the more dubious bits of the OKness proposal

[17:44] <TimToady> otoh, methods can't be quoters

[17:44] *** Woodi joined
[17:44] *** diana_olhovik_ joined
[17:44] <TimToady> unless we define a method-like macro in the WHAT category, so we could have $old.S/foo/bar/ or so

[17:44] <TimToady> but that has its own issues

[17:47] <TimToady> or force people to write (r/foo/bar/ given $old), which is also ugly

[17:48] *** jferrero left
[17:48] *** jferrero joined
[17:48] *** jferrero left
[17:48] *** jferrero joined
[17:48] *** vendethiel joined
[17:51] *** domidumont joined
[17:52] *** llfourn left
[17:52] <TimToady> we could also make r/// a special form that ~~ recognizes and disables the ACCEPTS logic for

[17:52] <TimToady> it's not that we haven't thought about this, it's that all solutions are distasteful...

[17:53] <hoelzro> timotimo++ # p6weekly, robe and wizard hat reference

[17:53] <timotimo> :)

[17:53] <hoelzro> rjbs: have you found any more bugs in Buf.push?

[17:54] <rjbs> Hm.  I feel like there was a second one, let me check.

[17:54] <rjbs> Oh, I'd told you about it. Happened with buf.push(1 xx 2)

[17:54] <hoelzro> I fixed $b.push: 1 xx 1

[17:55] <rjbs> I'm afraid I've done zero p6 since then.

[17:55] <rjbs> good to hear that was fixed, though!  I'll rebuild my p6 sometime soon

[17:55] <hoelzro> =)

[17:55] <hoelzro> should I leave that ticket open until you've had a chance to look at it?

[17:56] <rjbs> Nah, if you say it's fixed, I believe you.  And my time for this in the future is not reliable enough to lean bugs against yet.

[17:57] <hoelzro> alright

[18:02] *** muraiki left
[18:03] <masak> japhb: huh! so `0xa0.8` is a misparse, but both `:16<a0.8>` and `+"0xa0.8"` DWIM? odd.

[18:06] <TimToady> there's a fundamental difficulty you're not seeing here

[18:06] <TimToady> what is 0xa0.deadbeefmethod?  

[18:07] <TimToady> what is 0xa0.add?  

[18:08] *** domidumont left
[18:09] <TimToady> better to put the discontinuity between 0x and :16 than between .8 and .a

[18:10] *** gfldex joined
[18:11] *** vendethiel left
[18:12] <PerlJam> btw, is there really a use-case for hexadecimal numbers with a fractional part or are we just maintaining consistency with the other radixes?

[18:13] <TimToady> sure, there are use cases, but they're not terribly common

[18:14] <japhb> I would reinforce TimToady's assessment.

[18:15] <japhb> (And FWIW, I already recognized the 0xa0.add problem.  It was just too good an opportunity to pass up a little Str.Numeric bragging.  ;-)

[18:15] <PerlJam> call me doubting Thomas, but does anyone have an actual example use-case?

[18:15] <TimToady> japhb: I was pointing out the difficulty to masak...

[18:15] <japhb> PerlJam: Have seen it used, don't remember where.  Exactly once.

[18:16] *** bin_005 joined
[18:16] <japhb> TimToady: I figured it was intended for both of us, but I lounge corrected.

[18:16] <TimToady> there are some floating point formats that are (perhaps) better expressed in hex

[18:16] <japhb> Certainly it's useful for fixed point.

[18:17] <japhb> Come to think of it, that may be where I saw it -- some code that did fixed point math for graphics work on old hardware.

[18:17] <TimToady> speaking of which, I'd still like someone to take a crack at Rat[Int,10000] and such

[18:17] <TimToady> where a constant second arg to Rat makes a fixed-point type

[18:18] *** fhelmberger joined
[18:18] <TimToady> just to see if that's the right way to think about it :)

[18:19] <moritz> what would Rat[Int,2].new(1) + Rat[Int, 3].new(2) do?

[18:19] *** fhelmberger left
[18:19] *** smash left
[18:20] <TimToady> presumably the correct thing

[18:20] <PerlJam> moritz: a gcd at least :)

[18:21] <TimToady> but yeah, I see the conceptual difficulty there

[18:21] <TimToady> so maybe Fix[Int,2] instead

[18:22] <TimToady> probably bad to overload Rat for that

[18:22] * TimToady has too many things in his brane today to think clearly about any of 'em...

[18:23] *** yqt joined
[18:23] <skids> Swapping out a fully mutable REPR for one that compactly stores just mutable fields and leaves other fields fixed will probably be an important design pattern going forward.  It has use cases in IPv4 route caches for example.

[18:23] * rjbs has successfully switched to rakudobrew.

[18:23] <masak> 0xa0.add is a good point. I like things the way they are :)

[18:24] <rjbs> hoelzro++ https://github.com/rjbs/ZMachine-Whiz/commit/67c28bfe20da9e1839c83c8d0a056448f20e83bc

[18:28] <skids> (The type calculus problem with parameterized types is going to be contentious with different use cases wanting different behaviors.)

[18:29] *** kjlk joined
[18:30] *** rrrr joined
[18:30] <rrrr> help

[18:30] <rrrr> hello

[18:30] <rrrr> whois

[18:30] <sjn> hello, rrrr 

[18:30] *** kjlk left
[18:30] *** rrrr left
[18:31] <skids> You'd still have "what would Fix[Int,2].new(1) + Fix[Int, 3].new(2) do?"

[18:33] <colomon> skids: my first thought is that would be illegal

[18:33] <colomon> skids: make it easy to change from Fix[Int, 2] to Fix[Int, 3] (and vice versa) and then make the user explicitly request which one she wants

[18:33] <PerlJam> yeah, what colomon said

[18:34] <skids> Well, then how do you get a Fi[Int,6] results from that if that is what you want (or in the Rat case, what if you wanted a vanilla Rat)?

[18:35] <colomon> Maybe I’m misunderstanding what Fix[Int, 2] would be?  is it a Rat with fixed denominator 2, or a decimal number with two places after the decimal point?

[18:35] <colomon> but explicit conversions all around works for my taste.  :)

[18:36] <skids> Denominator == 2 I would think.

[18:38] <masak> if you know the denominator is 2, why don't you just ignore it and store the numerator in an Int? :P

[18:38] <stanrifkin> skids: so installed 2015 03 via rakudobrew - seems to be faster 

[18:38] <masak> this question goes doubly if all you can do is add/subtract Fix instances of the same denominator

[18:39] <stanrifkin> i looked up some perl6 examples and wonder whats the use of  "use v6;" pragma?

[18:39] <masak> stanrifkin: mostly to identify the code as Perl 6 code.

[18:39] <masak> stanrifkin: as opposed to, say, Perl 5 or Perl 4 code.

[18:40] <PerlJam> or some other language  :)

[18:40] <skids> So that would look something like: my Fix[Int,2] $a .= new(1); my Fix[Int,3] $b .= new(2); my $c = Fix[Int, $a.den gcd $b.gcd]($a + $b) which a lot of folks would be asking "how do I elide that mess"?

[18:40] <masak> wha'? there are other languages? :P

[18:40] <colomon> skids: the correct answer is if you want that, you want a Rat

[18:40] <stanrifkin> masak: ah - i understand - useful error message when executed via perl5

[18:40] <masak> skids: also, it's starting to sound more and more like good ol' Rat.

[18:41] <skids> colomon: not if you have millions of them in a compact array, you don't.

[18:41] <masak> colomon: but if you *don't* want that -- if you want a fixed denominator of 2 -- why can't you just use Int?

[18:42] <colomon> skids: no no no.  if you want to treat Fix like that, you have to store the denominator in each FIx.  There’s no space savings.

[18:42] <colomon> masak: Using Fix is conceptually cleaner, that’s all.

[18:42] <PerlJam> masak: so that you don't need to keep dividing by 2 for intermediate calculations to come out right ?

[18:42] <skids> e.g. Fix[int32,5]

[18:43] <skids> colomon: then it's pretty much useless for a lot of purposes.

[18:43] <TimToady> skids: that's kind of a silly argument, if it's pretty much useful for the rest of the purposes :P

[18:44] *** [TuxCM] joined
[18:44] *** lizmat joined
[18:44] <skids> Well, then you end up with people wanting yet another thing for the stuff it is useless for.

[18:44] <PerlJam> We already have that though.

[18:45] <skids> Then, you end up needing to convert between Fix and that other thing.  borders have to be drawn to compartmentalize -- i'm not sure if this is the right place to draw one but...

[18:45] <masak> well, more than one of you seem to be feeling an overwhelming need for this feature. I don't. :)

[18:47] <masak> if I wanted to express thousandths of a cent, I'd not reach for Fix[Int, 100_000], I'd reach for Int. if I wanted PerlJam's auto-dividing by 2 behavior, I'd wrap an Int in a dedicated value class.

[18:47] <colomon> skids: if your goal is compactness, then masak’s take that you should just be storing an int is almost certainly right

[18:47] * colomon doesn’t think Fix should be in core, but it should be a pretty easy module to write

[18:47] <masak> I'm not wildly against this feature. I'm just arguing against it, because doing so seems very easy. :)

[18:48] *** Woodi left
[18:48] <masak> (and there might be a good reason for that)

[18:48] <colomon> skids: the whole thing with Fix[whatever, N] is that it’s a class, with all the per-element overhead that implies.

[18:49] <colomon> (or a parameterized role, but that’s stil going to have all that overhead)

[18:49] <skids> So then you want a class that stores an int.  And knows a classwide deminonator.  And does math with different classes with different denomiators.  And why not make Fix do that in the first place, rather than a slightly enhanced Rat where *.denom == 4;

[18:49] <PerlJam> masak:  IF you had Fix, you wouldn't need to wrap an Int in a dedicated value class  ;)

[18:49] *** leont left
[18:49] <masak> PerlJam: it's not like it's hard.

[18:50] <masak> PerlJam: besides, I might still want to use my own class, because then I could give it a better name.

[18:50] <masak> which makes Fix[Int, 100_000] the worst of both worlds.

[18:50] <masak> bad name, non-compact storage.

[18:50] <skids> I just don't see the point in Rat[Int,N] or Fix[Int,N] if it does not much more than constraint enforcement.

[18:50] <colomon> skids: because what you’re asking for is going to have all the inefficiency of Rat if not worse, without giving you any tangible benefit I can see?

[18:51] * PerlJam feels like we're each a little angel or demon on TimToady's shoulders wrt this feature.

[18:52] <skids> What would Fix[Int,N] actually *do* other than generate compile time errors?

[18:52] <TimToady> allow two of them to add up by directly adding the underlying integers

[18:53] <TimToady> just like an accounting system that runs everything in ¢

[18:54] <skids> But if the den is stored per-instance, al hat saves you is a comparison op of the denominator.

[18:54] * colomon wants to note that may imply you can multiply a Fix[Int,N] by an Int but not by a Fix[Int,N]

[18:54] <TimToady> fixed point $ and ¢ is just Fix[Int,100]

[18:54] <TimToady> skids: it isn't

[18:54] <skids> That's what colomon and I are arguing about.

[18:54] <TimToady> it's implicit in the type, not stored

[18:54] <PerlJam> What would Fix[Str, "hi"] do?   (What are the limits to the parameters?  Could we have  Fix[Complex, 3i]  ?

[18:54] *** _mg_ left
[18:55] <colomon> skids: but what TimToady’s saying only works if Fix[Int,N] is limited to one N (or at least, a few Ns)

[18:55] <colomon> well, that’s not quite right

[18:55] <skids> Aren't classes relatively cheap?

[18:56] <colomon> they’re not cheap enough you want to potentially create a new one every time you do a basic math operation

[18:57] <TimToady> they're closed under addition, so it only gets complicated for multiplication, which can return a different type

[18:57] <TimToady> you don't use 'em for normal math, but for accounting, and such

[18:57] <colomon> TimToady: skids was proposed that a Fix[Int,2] + a Fix[Int,3] should be a Fix[Int,6], in which case they’re not closed under addition

[18:57] <TimToady> or as memory saving when nearly all your numbers have the same denominatory

[18:58] <TimToady> no, that's just a Rat for the intermediate

[18:58] <TimToady> Fix is more of a storage type

[18:58] <colomon> TimToady: I think masak is right that if efficiency is an issue, you just want ints

[18:58] <skids> colomon: Not neccesarily advocating that specifically.

[18:59] <masak> the last time we tried to create a real/numeric type with limited math ops (Instant), we regretted it.

[18:59] <skids> If you "just have ints" you'll need to do book-keeping of what the denomiator is.  That jo does not just dissappear. So people will want to wrap it in OO.

[19:00] <masak> I probably would. but I'd prefer to do it myself.

[19:00] <masak> and that way, I could make it a compact class.

[19:01] * skids decides he truly hates singly sprung chiclet keyboards.

[19:03] <jercos> most chiclet keyboards are pretty terrible

[19:03] <colomon> masak: that’s a good point, actually.  I think Fix might be more useful if it wasn’t Real

[19:03] <skids> .oO(Maybe best though to see what ends up being created for such jobs post-6.0 by the user base before designing such a feature)

[19:03] <masak> ...that was not my point... :/

[19:04] <masak> I see no overwhelming rush towards this feature. less so if we make it "not Real"...

[19:05] * colomon wants to reiterate he does not think it should be in core.

[19:06] <masak> then we are in more agreement. trying it in a module sounds fine.

[19:06] <masak> then the rest of us don't have to take the parse-time hit :)

[19:06] *** vendethiel joined
[19:06] <PerlJam> unless and until TimToady cogitates on it and decides otherwise ;)

[19:07] <TimToady> another way to look at it is that Int is really just a Fix with an implicit denominator of 1 :)

[19:07] <masak> which means that we already have this type. it's called Int.

[19:08] <skids> FWIW I can see where the use case of just simple strict type checking + easy coercion(:round/:floor/:ceil) would be desired as well.

[19:09] <masak> if someone was seriously implementing cents in a bank, I bet they'd want to do it with a dedicated class anyway. they'd probably have some needs that went beyond the ordinary numeric type.

[19:10] <skids> In general though it might be good to have at least one example of the storage-compact-subtype OO pattern implemented pre-6.0 so there's an example for users to draw from.

[19:10] <masak> what I think we should work towards is to make it really easy for devs to define their own Numeric (or Real, or other) types and have them blend in naturally with the rest of the numeric type system.

[19:11] *** stanrifkin left
[19:11] <skids> masak: and I would add arrays-of-said-types to that.

[19:11] <masak> *nod*

[19:11] *** rindolf joined
[19:13] *** atweiden joined
[19:14] *** fhelmberger joined
[19:15] *** Peter_R joined
[19:22] *** rindolf left
[19:22] *** fhelmberger left
[19:23] *** Possum joined
[19:27] *** amurf joined
[19:29] *** vendethiel left
[19:32] *** amurf left
[19:36] *** llfourn joined
[19:40] *** llfourn left
[19:43] *** rba_ joined
[19:45] *** zakharyas joined
[19:51] <flussence> .oO( why is @*ARGS an @, but $*ARGFILES isn't? )

[19:51] <timotimo> it's a single thing that pretends to be "all the files you specified"

[19:53] <flussence> it makes sense because it's an object with magic methods, but that difference has tripped me up a few times... (and it doesn't suggest a typo correction either)

[19:54] <masak> it probably should.

[19:55] <geekosaur> more principled version of <> ?

[19:55] <geekosaur> (from p5)

[19:55] <masak> aye.

[19:58] <japhb> skids: Why are you worrying about the cost of the denominator?  You'd have one copy of the denominator per unique denominator, and one copy of the numerator per instance.  If you avoid an explosion of denominators, that's not much of a cost.

[20:00] <japhb> I wrote a fair amount of money math, and I did it with premultiplied fixed point (AKA integers where it was understood that they represented millicents or so).  It would have been nice to have something that prevented me from accidentally multiplying two premultiplied numbers (a * N and B * N) and getting (a * b * N**2) because I forgot to divide once by the denominator ....

[20:00] <japhb> But I agree with Masak's point that what's really desired is an ability to create new math types and have them integrate with the existing numeric types and ops sanely.

[20:01] <japhb> (Without deoptimizing everything)

[20:01] *** brrt joined
[20:02] <masak> well, the discussion is already trending towards generalizing past Real types. I'm just suggesting we generalize it even further, and allow people to comfortably extend the numeric type system at will.

[20:03] *** atweiden left
[20:06] <lizmat> FWIW, I think that the functionality of $*ARGFILES should be generalized to a IO::Handle set, as it were

[20:08] *** AlexDaniel left
[20:10] *** vendethiel joined
[20:20] *** Sqirrel left
[20:24] <skids> japhb: That was to colomon who was arguing that you would still have one denominator stored per instance (rather than dynamically creating new Fix[Int,N] when needed for new N)

[20:24] <dalek> nqp: 07a9dc1 | FROGGS++ | tools/build/MOAR_REVISION:

[20:24] <dalek> nqp: bump moar (win build fix and nativecall fix)

[20:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/07a9dc105e

[20:24] *** [particle] left
[20:25] <dalek> rakudo/nom: a2305eb | FROGGS++ | tools/build/NQP_REVISION:

[20:25] <dalek> rakudo/nom: bump nqp/moar (win build fix and nativecall fix)

[20:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a2305eb5ed

[20:25] *** Sqirrel joined
[20:28] <timotimo> m: use NativeCall; class Foo is repr('CStruct') { has str $.str }; Foo.new: :str<foo>;

[20:28] <camelia> rakudo-moar c2a57e: OUTPUT«CStruct: invalid native binding to object attribute␤  in block <unit> at /tmp/rMG74BzOEH:1␤␤»

[20:28] <timotimo> m: use NativeCall; class Foo is repr('CStruct') { has Str $.str }; Foo.new: :str<foo>;

[20:28] <camelia> rakudo-moar c2a57e: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/RnaOXXeEiR:1␤␤»

[20:29] <timotimo> well, at least it wasn't that.

[20:29] <rjbs> So, I'm sitting over here in p5 country and bemoaning our lack of submethods, even in Moose.  So of course now I'm reading about submethods in doc.perl6.org

[20:29] <masak> \o/

[20:30] <masak> it's funny, I don't even think of submethods as all that special.

[20:30] <rjbs> I'm trying to find out how roles and submethods combine.

[20:30] <masak> but they're nice, I guess :)

[20:30] *** SevenWolf joined
[20:30] <RabidGravy> rjbs, doesn't Moose bluff it with BUILD?

[20:30] <rjbs> So, they're not something I need often.  99.9% of the time, it's for BUILD, but Moose has some problems around that.

[20:30] <rjbs> RabidGravy: It does, but sometimes the bluff breaks down.

[20:30] <masak> m: role R { submethod foo { say "OH HAI" } }; class C1 does R {}; class C2 is C2 {}; C1.new.foo; C2.new.foo

[20:30] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/he90gdHyGC␤'C2' cannot inherit from itself.␤at /tmp/he90gdHyGC:1␤»

[20:30] <rjbs> Like, you want BUILD in roles.

[20:31] <masak> m: role R { submethod foo { say "OH HAI" } }; class C1 does R {}; class C2 is C1 {}; C1.new.foo; C2.new.foo

[20:31] <camelia> rakudo-moar c2a57e: OUTPUT«OH HAI␤Method 'foo' not found for invocant of class 'C2'␤  in block <unit> at /tmp/tCVw4X8pfD:1␤␤»

[20:31] <lizmat> commute home&

[20:31] <masak> rjbs: does that answer your question?

[20:31] <masak> lizmat: safe trip!

[20:31] *** lizmat left
[20:31] <rjbs> But that doesn't work well ( http://rjbs.manxome.org/rubric/entry/1864 ) so in Moonpig, we use this StubBuild hack, but that has problems if you ever use inheritence.  Moonpig, basically doesn't, but...

[20:31] *** vendethiel left
[20:32] <rjbs> masak: Not quite, but I think I can research my own answer.  But maybe I'll ask you and you can tell me if you Just Know, first.

[20:32] <FROGGS> http://doc.perl6.org/language/objects#Submethods

[20:32] <masak> rjbs: sure thing.

[20:33] <rjbs> In Moose, I make R1 and R2.  Both of them have a submethod for M.  C1 consumes R1+R2.  C2 extends C1.  C1 and C2 also have submethods for M.   When C2->M is called, I expect all four routines to run exactly once.

[20:33] <rjbs> FROGGS: Yeah, I saw that, but it was pretty general.

[20:33] <FROGGS> *nod*

[20:34] <rjbs> I think I should just write the p6...

[20:34] <FROGGS> all four routines?

[20:34] <FROGGS> that's not what I'd expect

[20:34] <masak> rjbs: that doesn't sound like the way roles and submethods work...

[20:34] <jnthn> It may be more useful than the way they currently work, however...

[20:34] <yoleaux> 28 May 2015 02:02Z <japhb> jnthn: Congratulations!  Where are you getting married?  (Given your propensity to travel, I'm not ruling any countries out.  :-)

[20:34] <masak> rjbs: (a) roles allow methods to be *hidden* by methods in the class

[20:35] <jnthn> The trouble of coures being that roles avoid ordering issues, but you have to pick an order to run a bunch of things in.

[20:35] <masak> rjbs: (b) when you do, the method in the class completely supersedes the method in the role. if you want to call the method in the role, you have to do so explicitly, with `self.R::method()`

[20:36] <rjbs> I don't even know how to compose multiple roles at once.  I tried:  class C1 with R1, R2 { }

[20:36] *** atweiden joined
[20:36] <masak> rjbs: it's `does`

[20:36] <rjbs> masak: Yeah, I'd expect that for methods, but submethods maybe not.

[20:36] <rjbs> masak: Thanks, my bad

[20:36] <FROGGS> m: role R1 { }; role R2 { }; class Foo does R1 does R2 { }

[20:36] <camelia> rakudo-moar c2a57e: ( no output )

[20:36] <RabidGravy> does Foo does Bar

[20:37] <masak> rjbs: and I think you have to repeat it, what FROGGS ditd

[20:37] <rjbs> Yup, that worked.

[20:37] *** [TuxCM] left
[20:37] <FROGGS> m: role R1 { method bar { say 'R1' } }; role R2 { method bar { say 'R2' } }; class Foo does R1 does R2 { }; Foo.bar

[20:37] <camelia> rakudo-moar c2a57e: OUTPUT«===SORRY!===␤Method 'bar' must be resolved by class Foo because it exists in multiple roles (R2, R1)␤»

[20:37] <rjbs> I think it's totally okay that class methods replace role methods.  For submethods, I'm less sure...

[20:37] <FROGGS> m: role R1 { method bar { say 'R1' } }; role R2 { method bar { say 'R2' } }; class Foo does R1 does R2 { method bar { say 'Foo' } }; Foo.bar

[20:37] <camelia> rakudo-moar c2a57e: OUTPUT«Foo␤»

[20:37] <rjbs> to solve this problem in Moose, I wrote MooseX::ComposedBehavior, which is pretty darn hairy stuff

[20:38] <rjbs> m: use v6; role R1 { submethod M { say "R1" } }; role R2 { submethod M { say "R2" } }; class C1 does R1 does R2 { submethod M { say "C1" } } ; C1.new.M();

[20:38] <camelia> rakudo-moar c2a57e: OUTPUT«C1␤»

[20:38] <RabidGravy> isn't what rjbs talking about a sort of hyper operator + submethod thing?

[20:38] <FROGGS> submethods are not inherited anyway, no?

[20:38] <tony-o_> overwatch can now pull in changes from its upstream repo on an interval 

[20:38] <tony-o_> oops

[20:39] <rjbs> FROGGS: my understanding of submethods was that a call to S would implicitly call all submethods S on the class hierarchy

[20:39] <rjbs> so I wondered how roles fit in

[20:39] <rjbs> here is a related question:  does p6 have advice?

[20:39] <FROGGS> what's that?

[20:39] <timotimo> a call to a submethod will not call all submethods of the same name

[20:39] *** darutoko left
[20:40] <timotimo> but we do have something like .*foo and .+foo that will call multiple candidates of the same name across the class hierarchy

[20:40] <rjbs> FROGGS: you specify a hunk of code to run when some named code is run;  like "whenever someone calls method M, run this code before; or wrap the call in this code"

[20:40] <rjbs> FROGGS: https://en.wikipedia.org/wiki/Advice_(programming)

[20:40] <FROGGS> rjbs: we can wrap routines

[20:40] <rjbs> in moose, "method modifiers"

[20:41] <FROGGS> http://doc.perl6.org/routine/wrap#class_Routine

[20:41] <rjbs> Okay.   Let me suggest, too, that the Submethods docs in language/objects is not great, because instead of demonstrating submethods, it demonstrates BUILD, which means the call is implicit.

[20:42] <rjbs> and seeing the call might help make "how to use the submethod" clearer

[20:42] <rjbs> timotimo: Okay.  Is one meant to use those +/* forms for calling submethods?

[20:42] <FROGGS> yeah

[20:42] <FROGGS> (about the docs)

[20:43] <timotimo> i'm not sure you can call submethods with that

[20:43] <rjbs> Okay, how *do* I use submethods?  (I can go look at roast...)

[20:43] <timotimo> i think the question should be "when do i use submethods" instead

[20:43] <masak> agreed.

[20:44] <masak> you use them for "infrastructural behavior" (which mostly means BUILD and DESTROY) that isn't meant to inherit.

[20:44] <FROGGS> btw, it only seems to work with methods and only for inherited classes, not roles you do

[20:44] <timotimo> the reason why BUILD is usually a submethod is because BUILDALL will go through all submethods BUILD for a class' given hierarchy

[20:44] <rjbs> Okay, so let's stick to BUILD for now, then.

[20:44] <rjbs> because it's the real problem case.

[20:44] <timotimo> and since it's often used for private attributes, those wouldn't be reachable from a derived class

[20:45] <rjbs> Imagine that I write a role for HasDatabase.

[20:45] <rjbs> I want the database to be initialized at instantiation time, which is something I might normally do in BUILD.

[20:45] <rjbs> but if roles' submethods are not visited, then this seems less than ideal

[20:46] <rjbs> masak: when you say "isn't meant to inherit" I think you mean "isn't mean to be replaced by subclasses"; am I right or wrong?

[20:46] <tony-o_> m: role A { method b {...}; }; class C does A { method b { say "hi"; } }; GLOBAL::.values.map({.WHICH.say});

[20:46] <camelia> rakudo-moar c2a57e: OUTPUT«Unhandled exception: Method 'b' must be implemented by A because it is required by a role␤   at <unknown>:1  (/home/camelia/rakudo-inst-2/share/nqp/lib/Perl6/Metamodel.moarvm:compose_method_table:4294967295)␤ from src/gen/m-Metamodel.nqp:2616  (/home/c…»

[20:46] <masak> rjbs: no, not what I mean.

[20:46] <rjbs> masak: sorry; could you elaborate?

[20:46] <masak> rjbs: you declare it in Base, you can call it on $base, but you can't call it on $derived (which inherits)

[20:47] <tony-o_> hm

[20:47] <masak> rjbs: mentally, I have it as "methods as far as invocation goes, subs as far as inheritance goes".

[20:47] <rjbs> Okay.  I think I am having a realization here.

[20:47] <rjbs> I believe I totally misunderstood submethods. :-)

[20:47] <timotimo> i think so, too ;)

[20:48] <timotimo> but that's a good point to start from for understanding stuff

[20:48] <rjbs> My understanding was that everything you said was true, but that submethods were *implicitly composed*.

[20:48] <masak> rjbs: again, I think your best shot at what you want to do is `self.SomeRole::BUILD()` from your class's BUILD submethod.

[20:48] <rjbs> because, after all, BUILD is the common submethod, which we always see called in what seems to be a composed form

[20:48] <timotimo> ah

[20:48] <masak> rjbs: jnthn said "maybe they should be".

[20:48] <timotimo> i can see where that confusion may come from

[20:49] <timotimo> but yeah, BUILDALL is responsible for that behavior

[20:49] * rjbs reads BUILDALL

[20:49] <masak> at first blush, I think I'd prefer calling a role's submethod to be explicit, as above.

[20:49] <FROGGS> m: use v6; role R1 { submethod BUILD { say "R1" } }; class C1 does R1 { submethod BUILD { self.R1::BUILD(); say "C1" } } ; C1.new

[20:49] <camelia> rakudo-moar c2a57e: OUTPUT«Cannot invoke this object (REPR: P6opaque, cs = 0)␤  in submethod BUILD at /tmp/rxfdjvY0bH:1␤  in block <unit> at /tmp/rxfdjvY0bH:1␤␤»

[20:49] <FROGGS> is that wrong?

[20:49] <masak> you compose the role, you call the submethods you need.

[20:49] <rjbs> I'm gonna have to learn me some more nqp someday soon.

[20:50] <atweiden> i'm trying to instantiate a class based on a string `.perl` datadump of said class

[20:50] <atweiden> how to add a new method to type Str?

[20:50] <FROGGS> atweiden: you can augment it

[20:51] <rjbs> So, back to MooseX::ComposedBehavior.  What this made useful was that I could write (say) a "all-called" declarator and then add, anywhere in set of related roles/classes, "all-called foo => sub { ... }" and get them all called in a semi-deterministic order.

[20:51] <tony-o_> atweiden: you can monkey-type it

[20:51] <FROGGS> m: use MONKEY-TYPING; augment class Str { method foo { 'say bar' } }; "42".foo

[20:51] <camelia> rakudo-moar c2a57e: ( no output )

[20:51] <tony-o_> m: augment class Str { method atweiden { "sup".say; } }; "hello world".atweiden;

[20:51] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Ro8MvsZ1Yo␤augment not allowed without 'use MONKEY-TYPING'␤at /tmp/Ro8MvsZ1Yo:1␤------> 3augment class Str7⏏5 { method atweiden { "sup".say; } }; "he␤    expecting any of:␤        generic role␤»

[20:51] <tony-o_> m: use MONKEY-TYPING; augment class Str { method atweiden { "sup".say; } }; "hello world".atweiden;

[20:51] <camelia> rakudo-moar c2a57e: OUTPUT«sup␤»

[20:51] <tony-o_> FROGGS: beat me

[20:52] <FROGGS> ups, I put the quotes wrong :o)

[20:53] <skids> atweiden: if it is for coerce purposes, though, then I believe that is where the global COERCE multisub has been proposed to avoid the need to monkey type.  Not sure how far along that is towards implementation.

[20:53] <rjbs> FROGGS++  You pointed me at those docs, and I read them before and read them when you pointed at them, and STILL misapprehended things!  Oy!

[20:53] <FROGGS> m: say $*PERL.compiler.build-date # ups

[20:53] <camelia> rakudo-moar c2a57e: OUTPUT«2015-05-26T15:13:26Z␤»

[20:54] <FROGGS> :o)

[20:57] <masak> m: $*PERL.compiler.build-date.Date

[20:57] <camelia> rakudo-moar c2a57e: ( no output )

[20:57] <masak> m: say $*PERL.compiler.build-date.Date

[20:57] <camelia> rakudo-moar c2a57e: OUTPUT«2015-05-26␤»

[20:57] <masak> m: say Date.new - $*PERL.compiler.build-date.Date

[20:57] <camelia> rakudo-moar c2a57e: OUTPUT«212␤»

[20:57] <masak> ...and counting!

[20:57] <atweiden> coerce seems promising

[20:58] <FROGGS> yes, but somehow camelia got stuck

[20:58] <masak> think it was the revert.

[20:58] <rjbs> Using advice in Moose is /incredibly/ powerful.  Example use:  you have an HTTP::Client with send_request method.  You can add "before" advice that lots the request about to be sent and other "before" advice that does other logging if the target host matches some pattern.

[20:59] <FROGGS> masak: it stopped one commit before mine: https://github.com/rakudo/rakudo/commits/b9f993b86acf0f1ca3108d1b799ca35c21e726c7

[20:59] <rjbs> How might I accomplish this in p6?

[20:59] <rjbs> or, if not "accomplish this" then "solve this kind of problem" :)

[20:59] <FROGGS> rjbs: just .wrap it

[21:00] <rjbs> but where?  can I wrap it on an instance?  or only when the method is called on a subclass?

[21:00] * rjbs test...

[21:00] <masak> m: class C { method foo { say "OH HAI" } }; class D is C {}; say D.can("foo")[0]

[21:00] <camelia> rakudo-moar c2a57e: OUTPUT«foo␤»

[21:00] <FROGGS> m: sub foo { say 'in foo' }; &foo.wrap({ say 'before'; callsame; say 'after'; 'ret' }); say foo

[21:00] <camelia> rakudo-moar c2a57e: OUTPUT«before␤in foo␤after␤ret␤»

[21:00] <masak> m: class C { method foo { say "OH HAI" } }; class D is C {}; say D.can("foo")[0].wrap(-> { say "wrapped!"; callsame })

[21:00] <camelia> rakudo-moar c2a57e: OUTPUT«WrapHandle.new␤»

[21:00] <masak> m: class C { method foo { say "OH HAI" } }; class D is C {}; D.can("foo")[0].wrap(-> { say "wrapped!"; callsame }); D.foo

[21:00] <camelia> rakudo-moar c2a57e: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/kwt2O7IMVA:1␤␤»

[21:01] * jnthn showed how to write a module that added before/after modifier things

[21:01] <jnthn> In some talk

[21:01] <masak> hm.

[21:01] <jnthn> I hoped somebody would pick it up and actually write the module and polish it :P

[21:01] <rjbs> jnthn: I'll go read all your talks, one minute... :)

[21:01] <jnthn> rjbs: I don't exactly reemember which one :P

[21:01] <timotimo> jnthn: we've figured out your "routine" and we're not falling for it any more! ;P

[21:01] <jnthn> My point was more "it's possible"

[21:01] <jnthn> And "it doesn't need to be baked into the language"

[21:01] <rjbs> jnthn: I figured it would be possible, for sure.  Just wondering how one does it.  Or whether there's some other behavior to make it unneeded.

[21:02] <rjbs> jnthn: Sure, I know it doesn't need to be first class, but I don't know how to go about baking it myself.  The behavior of .wrap on an inherited method wasn't clear from docs.

[21:02] * rjbs reads the code that masak ran above...

[21:03] <jnthn> http://jnthn.net/papers/2012-gpw-meta-programming.pdf probably has it

[21:03] <FROGGS> m: class C { method foo { say "OH HAI" } }; C.can("foo")[0].wrap({ say "wrapped!"; callsame }); C.foo

[21:03] <camelia> rakudo-moar c2a57e: OUTPUT«wrapped!␤OH HAI␤»

[21:03] <FROGGS> m: class C { method foo { say "OH HAI" } }; class D is C {}; D.can("foo")[0].wrap({ say "wrapped!"; callsame }); D.foo

[21:03] <camelia> rakudo-moar c2a57e: OUTPUT«wrapped!␤OH HAI␤»

[21:04] <tony-o_> m: GLOBAL::.values.map({ .WHO.values.say; });

[21:04] <camelia> rakudo-moar c2a57e: ( no output )

[21:04] <tony-o_> m: use Test; GLOBAL::.values.map({ .WHO.values.say; });

[21:04] <camelia> rakudo-moar c2a57e: OUTPUT«sub todo_output () { #`(Sub|62003552) ... } (EXPORT) sub failure_output () { #`(Sub|62003704) ... } sub output () { #`(Sub|62003856) ... }␤»

[21:04] <tony-o_> m: use Test; GLOBAL::.values.map({ .WHO.say; });

[21:04] <camelia> rakudo-moar c2a57e: OUTPUT«&failure_output => sub failure_output () { #`(Sub|54971088) ... }, &output => sub output () { #`(Sub|54971240) ... }, &todo_output => sub todo_output () { #`(Sub|54971392) ... }, EXPORT => (EXPORT)␤»

[21:05] *** pierrot left
[21:05] *** pierrot joined
[21:05] *** bin_005 left
[21:06] <FROGGS> gnight #perl6

[21:06] <tony-o_> later FROGGS 

[21:06] *** FROGGS left
[21:06] *** bin_005 joined
[21:07] <rjbs> m: class C1 { method M { say "C1.M" } }; class C2 is C1 { }; C2.can("M")[0].wrap({ say "C2.M" }); C1.new.M; C2.new.M;

[21:07] <camelia> rakudo-moar c2a57e: OUTPUT«C2.M␤C2.M␤»

[21:07] <rjbs> So, there's the problem.  When you "wrap" the method from C2 which was inherited from C1, you affect C1.  

[21:08] <atweiden> ty FROGGS, will try monkey typing

[21:09] <jnthn> rjbs: .wrap is defined as in-place; a MOP module would clone the thing from the base class and wrap the clone

[21:09] <masak> so it seems there's a need for such a module.

[21:09] <jnthn> Just as we clone dispatchers so as to ensure we don't end up with multi candidates leaking into the wrong places

[21:10] <jnthn> masak: Agree. :)

[21:10] <rjbs> masak: I think so.  I started to imagine just generating my own wrapper, but then realized I'd have to learn how to deal with the signature capture, at least.

[21:10] <jnthn> And with Perl 6's flexibility, you can do it in a mdoule rather neatly

[21:11] <rjbs> Okay, better get back to p5 land now to finish dayjob task, then onto the bus!

[21:11] <rjbs> Thanks very much, I learned things.

[21:11] <masak> Perl 6's the language in which you can build the language you've always wanted. :)

[21:11] <rjbs> :)

[21:12] <masak> we're starting to actually see this, which makes me happy.

[21:13] <smls> I made something for fun: https://github.com/smls/undef/blob/master/scripts/term-livehash.p6 :P

[21:13] <smls> try it out (if you're on Linux)

[21:15] <smls> (or any system that has `tput` and a terminal that understands control codes)

[21:16] <masak> smls: cool!

[21:16] <tony-o_> smls++

[21:17] *** raiph joined
[21:18] <smls> btw, this is one use-case where having a built-in ordered hash type would have been useful ;)

[21:18] <rjbs> I'm gonna re-leave this URL here because it recapitulates a lot of what I was talking about: http://rjbs.manxome.org/rubric/entry/1864

[21:18] <rjbs> & bus time

[21:18] <masak> smls: oh, I'm all for build-in ordered hashes. it's spec and everything :)

[21:18] *** kaare_ left
[21:18] * masak likes approving of something, for once

[21:19] <grondilu> off topic: HP's discover live right now http://livestream.com/accounts/4166917/events/4043666/player_pop_out?lsa_type=LS_EVENT_PAGE&lsa_referrer=

[21:19] <grondilu> (they'll probably talk about their Machine)

[21:20] <masak> grondilu: link doesn't work. redirects to main page.

[21:20] <grondilu> ah sorry

[21:21] <RabidGravy> orso far today I have added four things to my TODO and cleared none off

[21:21] <grondilu> it's very corporate, boring speech though.  I kind of regret having linked it.  Only go if you're very curious about these stuff.

[21:21] <masak> RabidGravy: at least you got them onto the TODO list! pat yourself on the back ;)

[21:21] <RabidGravy> :)

[21:22] <RabidGravy> and I did remix one drum loop for Laica but that kind of sprung on me

[21:26] *** telex left
[21:27] *** diana_olhovik_ left
[21:27] *** beastd joined
[21:28] *** telex joined
[21:39] <smls> masak: Where do the design docs talk about ordered hashes? I can't find it.

[21:41] <masak> S09, I'm sure.

[21:41] <masak> let me find it for you.

[21:41] *** zakharyas left
[21:41] *** Peter_R left
[21:42] <masak> S09:1202

[21:42] <synbot6> Link: http://design.perl6.org/S09.html#line_1202

[21:44] <smls> isn't "autosorting" different from "remembers the order in which keys were added" though?

[21:45] <masak> oh, huh. I've always read that as meaning "insertion-order hashes". but it probably doesn't.

[21:45] <masak> it's probably more aking to Java's TreeSet than Java's LinkedHashSet.

[21:45] <masak> akin*

[21:46] <PerlJam> masak: the ISAM comment should have given it away (unless you also imagined a monotonically increasing key that was used for "sorting" but nothing else)

[21:46] <masak> *nod*

[21:47] <masak> anyway, even though I read that section wrong, the possibility of autosorted hashes also opens up the possibility of insertion-order hashes.

[21:47] <masak> they're "the same" kind of extension.

[21:47] <PerlJam> aye

[21:47] <masak> and I've always read Perl 6 as promising that (eventually) we'll be able to use the % sigil even for exotic things like that.

[21:48] <masak> though you might have to declare it in some slightly unusual way, like `my %h := OrderedHash.new;`

[21:49] <masak> (this might be my favorite reason for binding existing in the language, by the way)

[21:49] <jnthn> my %h is OrderedHash; # should work too, once we get it impl'd, I think

[21:49] <masak> ah, yes. even nicer.

[21:51] <jnthn> And nicest: sleep! :) 

[21:51] <jnthn> 'night, all

[21:52] <masak> sleep++

[21:52] <masak> 'night, jnthn

[21:57] *** brrt left
[22:02] *** vendethiel joined
[22:06] *** spider-mario left
[22:07] *** spider-mario joined
[22:08] *** clkao left
[22:08] <atweiden> started using monkey-typing, but writing a grammar to deconstruct the output of `MyClass.perl` just seems wrong

[22:09] <atweiden> $/.perl is:

[22:09] <atweiden> Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "Nightscape.new(entity => Hash[Nightscape::Entity,Str].new(\"EntityFoo\" => Nightscape::Entity.new(inventory => Hash[Int,Str].new(\"boxes\" => 100))))", to => 145, from => 0)

[22:09] <atweiden> is there any way i could directly insert the output of Nightscape.new ... `my Nightscape $nightscape = <HERE>` ?

[22:09] <atweiden> maybe with a macro?

[22:09] *** gfldex left
[22:09] <masak> atweiden: almost sounds like you want EVAL.

[22:14] <atweiden> masak: ty a million times

[22:15] <tony-o_> m: sub p { }; say p.HOW ~~ Metamodel::ClassHOW;

[22:15] <camelia> rakudo-moar c2a57e: OUTPUT«True␤»

[22:15] <tony-o_> is that right?

[22:15] <tony-o_> m: sub p { }; say p.HOW ~~ Metamodel::PackageHOW;

[22:15] <camelia> rakudo-moar c2a57e: OUTPUT«False␤»

[22:15] <masak> atweiden: let me know if it works out alright.

[22:15] <tony-o_> m: sub p { }; say p.HOW ~~ Metamodel::ModuleHOW;

[22:15] <camelia> rakudo-moar c2a57e: OUTPUT«False␤»

[22:15] <masak> atweiden: in the fullness of time, you're also supposed to be able to build and EVAL ASTs.

[22:17] <masak> 'night, #perl6

[22:22] <atweiden> masak: oh yes, it's working. never would've found that without #perl6

[22:24] *** AlexDaniel joined
[22:26] *** vendethiel left
[22:27] *** skids left
[22:27] *** virtualsue left
[22:36] *** bobkare left
[22:37] *** llfourn joined
[22:41] *** llfourn left
[22:42] *** bin_005 left
[22:43] *** bin_005 joined
[22:44] *** bobkare joined
[22:49] *** clkao joined
[22:58] *** RabidGravy left
[22:59] *** bin_005 left
[23:02] *** Spot__ joined
[23:05] *** amurf joined
[23:07] *** skids joined
[23:09] *** amurf left
[23:15] *** SevenWolf left
[23:15] *** [particle] joined
[23:15] *** SevenWolf joined
[23:16] *** amurf joined
[23:19] *** raiph left
[23:43] <dalek> roast: d018c54 | hoelzro++ | S26-documentation/block- (2 files):

[23:43] <dalek> roast: Fudge role method WHY tests

[23:43] <dalek> roast: review: https://github.com/perl6/roast/commit/d018c54b8f

[23:44] <dalek> rakudo/nom: e3d18ee | hoelzro++ | t/spectest.data:

[23:44] <dalek> rakudo/nom: Run block-leading and block-trailing S26 tests once again

[23:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e3d18ee96f

[23:47] *** smash joined
[23:52] *** Akagi201 left
[23:55] *** bobkare left
[23:56] *** bobkare joined
