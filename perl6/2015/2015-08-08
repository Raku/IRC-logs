[00:00] * ShimmerFairy wonders if the better solution to this kind of issue would be to have a built-in mechanism to 'link' different spellings of an operator, e.g.  multi sub infix:<⊂> is texas("(<)") { ... }  or  multi sub infix:«⊂ (<)»

[00:08] <Sgeo> Will there eventually be guidelines on fail vs die?

[00:10] <Sgeo> Also I'm curious why the ternary operator is ?? !! instead of PErl5 and everyone else's ? :

[00:10] <ShimmerFairy> I would hope so :) . At first guess I'd say that 'fail' is for when you want something kinda similar to NaN for floating point, and 'die' is for more "traditional" exception handling mechanism. (I'm not too well-versed in exception handling in P6 though)

[00:12] <ShimmerFairy> Sgeo: I guess there might be parsing reasons for it, but additionally I think ?? !! does a better job of communicating what the following bit of code does (_especially_ !! when compared to : )

[00:19] <TimToady> we didn't want to waste two perfectly good ascii characters for a single construct, and the doubling fits in better with other thunky operators like || and &&

[00:19] <TimToady> an invocant colon would be formally ambigous with the : as well

[00:20] <ShimmerFairy> I figured the colon was the parsing issue (since everybody wants it) :P

[00:20] <ShimmerFairy> Also, there's no chance of your prefix:<?> being misinterpreted due to extra whitespace :)

[00:23] <dalek> doc: 64b148b | ShimmerFairy++ | lib/Language/operators.pod:

[00:23] <dalek> doc: Document the flipflop operators

[00:23] <dalek> doc: 

[00:23] <dalek> doc: I wasn't sure as to the level of detail desired on the operator page, so

[00:23] <dalek> doc: hopefully it's not too much or too little for these eight operators.

[00:23] <dalek> doc: These operators feel like they could benefit from an(other,) independent

[00:23] <dalek> doc: page explaining things in a bit more detail anyway.

[00:23] <dalek> doc: review: https://github.com/perl6/doc/commit/64b148b894

[00:26] <ShimmerFairy> TimToady: do you have any thoughts on some sort of "synonym" mechanism for unicode & texas versions of operators? On the one hand I feel it would be a better way of defining them, but on the other hand I get the sneaking suspicion there are some nasty dragons in that idea :)

[00:30] <TimToady> well, personally, I think the main ones should be Unicode, and the Texas ones aliases, but that's not really addressing your question

[00:33] <Sgeo> B<"=begin code" ff "=end code">

[00:33] <ShimmerFairy> TimToady: that's what I think too, since I want to define unicode multis instead of texas, but I can already see other people preferring the texas versions and wanting to define multis on that.

[00:33] <Sgeo> What is that B< >, and how does it relate to string comparison?

[00:33] <ShimmerFairy> Sgeo: it gets rendered as boldface when processed (see the :allow<B V> on the code block, which allows use of B<> and V<> formatting codes)

[00:34] <Sgeo> I guess ff is smartmatching on the strings, and the V<=> isn't really there/

[00:34] <ShimmerFairy> The V<=> is to prevent accidental parsing of the =begin code and =end code directives by the Pod parser. (the =end code is the more concerning one)

[00:34] <Sgeo> There was a djkistra thing promoting including start but not stop conditions

[00:35] <Sgeo> But at least Perl6 seems consistent with ^ markers

[00:35] <ShimmerFairy> Crap, I knew I forgot something; using Whatever on the RHS :)

[00:35] <Sgeo> Seems saner than .. vs ... or whatever

[00:35] <ShimmerFairy> "start" ff *  has no stop condition

[00:35] *** mjgardner joined
[00:37] <Sgeo> If closures were used, would a library-based ff be possible?

[00:39] <ShimmerFairy> Maybe, I only just learned about flipflop the other day because I finally wanted to know what they did (so looked at P5 stuff), and then decided to write docs for P6 :)

[00:39] <ShimmerFairy> (I'm also not sure what "library-based" means, exactly)

[00:39] *** llfourn joined
[00:40] *** cognominal left
[00:40] <Sgeo> AS in defining it as an infix operator without special compiler knowledge of it

[00:43] <ShimmerFairy> Sgeo: ah. The issue is that flipflop keeps a global state per instance of it in code, so a "pure P6" version would end up taking up some global space, for sure (don't know if macros would change that). You'd also have to keep track of instances of the op, which is aaagh :)

[00:44] *** llfourn left
[00:44] <timotimo> the op could just desugar to implementation(state $, LHS, RHS) or something

[00:44] <Sgeo> Per instance in code? I was thinking maybe it was scoped the way state is (which I'm not sure I fully grasp either)

[00:44] <timotimo> then the perl6 implementation will do the rest for you

[00:44] <timotimo> it gets instantiated when a clone happens

[00:45] <ShimmerFairy> Sgeo: in P5 it persists across sub calls (say), so the "isolated" version involves returning a sub that does the flipflop. I haven't tested that in P6, but AFAIK it likely works out the same.

[00:45] <timotimo> m: for 1, 2, 3 -> $o { for <a b c> -> $i { state $outer = $o; say "$o $i $outer" } }

[00:45] <camelia> rakudo-moar 1a3f1a: OUTPUT«1 a 1␤1 b 1␤1 c 1␤2 a 2␤2 b 2␤2 c 2␤3 a 3␤3 b 3␤3 c 3␤»

[00:45] <timotimo> er, that's not so amazing

[00:45] <timotimo> m: for 1, 2, 3 -> $o { for <a b c> -> $i { state $outer; $outer ~= "$o$i"; say "$o $i $outer" } }

[00:45] <camelia> rakudo-moar 1a3f1a: OUTPUT«1 a 1a␤1 b 1a1b␤1 c 1a1b1c␤2 a 2a␤2 b 2a2b␤2 c 2a2b2c␤3 a 3a␤3 b 3a3b␤3 c 3a3b3c␤»

[00:46] <timotimo> there the outer for loop causes the inner block to get cloned and a new state var "happens"

[00:47] <timotimo> m: say (state $; $ ~= "a") xx 10

[00:47] <camelia> rakudo-moar 1a3f1a: OUTPUT«(Any) a (Any) aa (Any) aaa (Any) aaaa (Any) aaaaa (Any) aaaaaa (Any) aaaaaaa (Any) aaaaaaaa (Any) aaaaaaaaa (Any) aaaaaaaaaa␤»

[00:47] <ShimmerFairy> m: sub foo(@a) { for @a { say $_ if /C/ ff * } }; my @list = <A B C D E>; foo(@list); foo(@list);  # huh, my limited understanding of QAST led me to believe this would behave like in P5.

[00:47] <camelia> rakudo-moar 1a3f1a: OUTPUT«C␤D␤E␤C␤D␤E␤»

[00:47] <ShimmerFairy> I believe P5 would've printed the entire list on the second call.

[00:50] <dalek> doc: aa0d2ea | ShimmerFairy++ | lib/Language/operators.pod:

[00:50] <dalek> doc: Forgot to mention * as the right arg of flipflop.

[00:50] <dalek> doc: 

[00:50] <dalek> doc: $a ff * (or any of the other flipflop ops) means that there is no stop

[00:50] <dalek> doc: condition. Once $a matches, the flipflop is always successful.

[00:50] <dalek> doc: review: https://github.com/perl6/doc/commit/aa0d2eaaf4

[00:51] *** gfldex left
[00:52] <Sgeo> What happens if you want to test the same expression against being true? Is there a &id that could be used for both sides of the flip flop?

[00:52] <Sgeo> I guess something like .Bool ff .Bool?

[00:54] <skids> FWIW fail is indeed supposed to be a NaNish thing.  The "use fatal" directive cannot muck with you if you use it that way because it scopes lexicially.  However, at some point we turned on warnings for GCed failures, I think maybe just as a temporary leak detector, and until they get turned off again it is hard to use it as intended.

[00:55] <ShimmerFairy> m: say $_ if /C/ ff /C/ for <A B C D E>

[00:55] <camelia> rakudo-moar 1a3f1a: OUTPUT«C␤»

[00:55] <ShimmerFairy> m: say $_ if /C/ fff /C/ for <A B C D E>

[00:55] <camelia> rakudo-moar 1a3f1a: OUTPUT«C␤D␤E␤»

[00:55] <ShimmerFairy> Sgeo: depends on if you're using ff or fff ^^^

[00:57] <b2gills> Putting the same condition on both sides of a ff is kind of pointless, as you can just test against the conditional, now on fff it can make a certain amount of sense.

[00:58] <Sgeo> How about .Bool ff .Bool.not

[00:59] <Sgeo> :m 5.Mu

[00:59] <Sgeo> m: say 5.Mu

[00:59] <camelia> rakudo-moar 1a3f1a: OUTPUT«Method 'Mu' not found for invocant of class 'Int'␤  in block <unit> at /tmp/DSbmwnlRBZ:1␤␤»

[00:59] <b2gills> m: say ($++, $ ~= "a") xx 10 # every unnamed scalar is it's own state value

[00:59] <camelia> rakudo-moar 1a3f1a: OUTPUT«0 a 1 aa 2 aaa 3 aaaa 4 aaaaa 5 aaaaaa 6 aaaaaaa 7 aaaaaaaa 8 aaaaaaaaa 9 aaaaaaaaaa␤»

[01:02] <b2gills> .Bool ff .Bool.not would match all of the trueish values, and one additional one, which could be handy, now .Bool ff^ .Bool.not would be the same as just .Bool

[01:04] <ShimmerFairy> I'm open to a P6-based version (the less "special" operators, the better, imo). But I suspect there's a very good reason it hasn't been done yet, so I'd speak with our resident compiler experts about it beforehand :)

[01:05] <timotimo> thank you for the reminder, b2gills 

[01:09] *** atta joined
[01:09] *** atta left
[01:15] *** yqt left
[01:24] *** rmgk_ joined
[01:24] *** rmgk is now known as Guest59037

[01:24] *** Guest59037 left
[01:24] *** rmgk_ is now known as rmgk

[01:31] *** colomon left
[01:34] *** colomon joined
[01:38] <Sgeo> So, True and False on RHS of smartmatch gives True and False, so you can use normal expressions on RHS of smartmatch and the result will be what's expected. But I can imagine someone using a truthy or falsey expression on the RHS of a smartmatch (e.g. the conditions of ff) and the smartmatch causing it to mean something other than what's expected

[01:38] *** skids left
[01:39] <Sgeo> e.g. @foo.elems ff @bar.elems doesn't check for @foo's nonemptiness as the condition of flip-flopping, but the smartmatch of that number against $_

[01:39] <Sgeo> And I can easily see someone making that mistake

[01:40] <ShimmerFairy> That's a problem that would also come up in when $x { } blocks, fwiw

[01:44] <Sgeo> Hmm that makes it more obvious and is more likely to occur, yeah

[01:44] <ShimmerFairy> That's indeed going to be a potential issue in place with implicit ~~ matching, but not one that's solved besides "it's not gonna coerce to boolean here". (For things like ff and when, for instance, using something other than smartmatch would ruin the ability to use regexes)

[01:45] <Sgeo> Maybe it could be considered a problem with smartmatch itself?

[01:45] <Sgeo> I don't know what the fix is though

[01:45] *** tommi left
[01:47] <ShimmerFairy> Well, smartmatch is specifically supposed to be most permissive ("most human", if you will) form of equivalence in Perl 6. ~~ also takes its left arg as the $_ for the right arg, which is why it's used with regexes.

[01:47] <ShimmerFairy> But if you're like me and you typically read  $a ~~ /regex/  with no thought about the fact that /regex/ matches against $_, it feels like there could/should be a separate "regex match" operator :)

[01:48] <Sgeo> I thought m/regex/ matches against $_ ?

[01:49] <ShimmerFairy> m: for <A B C> { say /C/ ?? "OK!" !! "nope" };  for <A B C> { say /C/ }

[01:49] <camelia> rakudo-moar 1a3f1a: OUTPUT«nope␤nope␤OK!␤/C/␤/C/␤/C/␤»

[01:49] <ShimmerFairy> m: for <A B C> { say m/C/ ?? "OK!" !! "nope" };  for <A B C> { say m/C/ }

[01:49] <camelia> rakudo-moar 1a3f1a: OUTPUT«nope␤nope␤OK!␤Nil␤Nil␤｢C｣␤»

[01:49] *** gfldex joined
[01:49] <ShimmerFairy> Not in all the places m// matches, but /.../ still does match against $_ .

[01:50] <ShimmerFairy> (I don't know if that  say /C/  is a bug)

[01:50] <Sgeo> That's... confusing

[01:52] <ShimmerFairy> While I'm not a fan of the implicit matching against $_ for regex literals, it does get used. I would like to see a specific "regex equality" operator, since I think the very permissive ~~ is an unfortunate only operator option for regex testing, but I don't feel too strongly about it.

[01:53] <ShimmerFairy> .oO( multi sub infix:</==/> ...  say $string /==/ /regex/;  :P )

[01:54] <Sgeo> Do we really need both $_ + 1 and { $_ + 1 } to match on the RHS? That is, why not just the latter, and drop the implicit setting of $_, which could still allow regex literals to match

[01:55] <Sgeo> It occurs to me that this probably does not help the situation that much

[01:55] <ShimmerFairy> I fear it's far too ingrained at this point to sanely deprecate that if it was decided for :(   Also, remember that  $left ~~ $right  desugars to  $right.ACCEPTS($_) , where $_ is set to $left

[01:56] <ShimmerFairy> Sgeo: ~However~, there was recently talk that, in order to make ~~ chain like it's supposed to, the chaining version of ~~ wouldn't topicalize (set $_).

[01:58] *** colomon left
[01:58] *** colomon joined
[02:08] *** aborazmeh joined
[02:08] *** aborazmeh left
[02:08] *** aborazmeh joined
[02:11] <b2gills> m: say /c/.ACCEPTS('c')

[02:11] <camelia> rakudo-moar 1a3f1a: OUTPUT«｢c｣␤»

[02:11] <Sgeo> $_ ~~ $_ could be pretty interesting

[02:13] <timotimo> unless someone figures out how my latest commit to nqp breaks deepmap when combined with things returning whatever .map creates (as can be tested with ("a", "b")>>.ords returning an empty list), it may be a good idea to revert that nqp commit :|

[02:15] <ShimmerFairy> timotimo: on a cursory glance, I see :op('while') in Optimizer.nqp:1499 and World.nqp:2011 , if those spots could be helpful to investigate.

[02:16] <ShimmerFairy> also in Actions.nqp:1226

[02:20] *** skids joined
[02:23] <ShimmerFairy> timotimo: looking at the diff for your nqp commit, the only thing that jumps out at me is the use of =:= . It's not necessarily wrong (I wouldn't know), but the fact that you don't see it all that often makes me wonder if === or something isn't the better operator.

[02:27] *** camelia left
[02:27] <ShimmerFairy> meh, apparently camelia didn't like me trying nqp:

[02:28] <ShimmerFairy> timotimo: is there some reason you weren't able to do nqp::defined($res_reg) instead of setting it to and testing for MAST::VOID in the unless statement?

[02:28] *** camelia joined
[02:29] *** AlexDaniel left
[02:29] *** ChanServ sets mode: +v camelia

[02:36] <Sgeo> Can Perl6 regexes do HTML?

[02:36] * Sgeo looks around for Cthulhu

[02:36] <ugexe> seems like one of the latest nqp commits has introduced a precomp bug where it cant find &Symbol of SomeModule::Symbol when it could before

[02:38] <ShimmerFairy> Sgeo: sure, just last night I found myself discussing parsing XML :) (I wrote an XML 1.1 parser not too long ago)

[02:38] *** mjgardner left
[02:38] <Sgeo> And how do P6 regexes compare with Haskell parsec?

[02:38] <Sgeo> Can I do the sort of thing with parsec where a value obtained by parsing controls the next regex to be run?

[02:40] *** noganex joined
[02:40] *** llfourn joined
[02:41] <ShimmerFairy> m: say "0foo" ~~ /<digit> [ <?{+$<digit> == 0}> foo | <?{+$<digit> == 1}> bar ]/  # Sgeo: like this?

[02:41] <camelia> rakudo-moar 1a3f1a: OUTPUT«｢0foo｣␤ digit => ｢0｣␤»

[02:42] <ShimmerFairy> I've written conditionals in regexes using <?{}> and <!{}> before :)

[02:43] *** noganex_ left
[02:45] *** llfourn left
[02:45] <ShimmerFairy> Sgeo: here's an example:  https://github.com/lue/synopsis-generator/blob/master/lib/SynGen/Blinks.pm6  here I used a dynamic variable to track whether I was inside a <> or a «» construct, and then tested that variable in <?{}> assertions in subrules where I needed to know.

[02:46] <ShimmerFairy> (I need to get to working on that repo again soon, btw, but the example is still valid)

[02:49] <Sgeo> I don't know anywhere near enough about P6 regexes

[02:50] *** bayprogrammer joined
[02:52] <ShimmerFairy> Sgeo: that's fine. <?{}> is a successful zero-width match if the code inside the {} evaluates to True, and <!{}> is successful if the code is False. Like other zero-width matches you use them as a kind of 'prerequisite' for the rest of the regex (confined within brackets and such of course)

[02:54] <Sgeo> Could I, in theory, parse a piece of text, get a regex out of it, then use that regex to parse the next section? Possibly with an action also determined by the results of parsing/actioning the previous text?

[02:56] <ShimmerFairy> m: my $strx = "a*b"; say "b" ~~ /<$strx>/

[02:56] <camelia> rakudo-moar 1a3f1a: OUTPUT«｢b｣␤»

[02:56] <Sgeo> I guess I was hoping that one regex could do it

[02:56] <ShimmerFairy> You can construct a regex in a string and then use it like that, for example.

[02:56] <Sgeo> Or... I'm not sure. I just want monadic parsing

[02:57] <ShimmerFairy> I have no knowledge of monads, much less monadic parsing, so I couldn't help with that I'm afraid :(  However, I've found P6 grammars to be quite powerful nonetheless (it's used to parse Perl 6, after all ☺)

[02:58] *** bayprogrammer left
[02:58] *** bayprogrammer joined
[02:59] *** bayprogrammer left
[03:00] *** mjgardner joined
[03:00] *** bayprogrammer joined
[03:00] <Sgeo> foo = do { a <- someParser; b <- a; return b} defines a parser foo. a is the result of parsing with someParser, and b is the result of, in tern, processing a. The result of the parser is b

[03:00] <Sgeo> s/processing/parsing with/

[03:01] <Sgeo> This doesn't happen as foo is defined, but rather, each time that foo is used as a parser, and foo itself can be used to build larger parsers similarly

[03:03] <ShimmerFairy> Sgeo: in terms of parsers returning parsers (or regexes returning regexes, in a sense), it's certainly possible, but it would be interesting. :)  nqp's src/QRegex directory comes to mind as an example of what is ultimately regexes parsing regexes.

[03:04] <Sgeo> Doesn't necessarily have to be reading regexes in, just resulting in a regex value

[03:04] <Sgeo> Not entirely sure whether a monadic parser would in P6 terms be just a regex or regex+action

[03:05] <Sgeo> And then using that resulting value as the next thing (or not necessarily immediately, but being able to later on) to run as regex

[03:05] <Sgeo> All contained in its own little unit

[03:05] <ShimmerFairy> If you're more concerned with building a grammar out of smaller parts, that's easily accomplished with subrules and inheritance (IIRC Perl6 grammars implicitly inherit from some "base" grammar, but I can't be certain)

[03:06] <Sgeo> I don't know if this is equivalent, but I think it might be: Can Perl6 regexes be used to parse context-sensitive grammars?

[03:08] <ShimmerFairy> as long as the grammar has some way of knowing the context, it can. The grammar for Perl6 has a _lot_ of dynamic ($*STUFF) variables for carrying information down into called subrules and even into action methods.

[03:08] *** mjgardner left
[03:10] <ShimmerFairy> Sgeo: I think monadic parsing is certainly possible in Perl 6, but without knowing it too well I can't say how difficult it would be. I suspect there's definitely room for something like  use Monadic::Parser;  to ease things :)

[03:10] <b2gills> m: say 'abcasdf' ~~ / (.) (.*) $0 /

[03:10] <camelia> rakudo-moar 1a3f1a: OUTPUT«｢abca｣␤ 0 => ｢a｣␤ 1 => ｢bc｣␤»

[03:10] *** shinobi-cl joined
[03:12] *** gfldex left
[03:12] <shinobi-cl> Hi all... is there a way to enable iteration in a class of mine? something like a interface with first, index, next, prev methods? 

[03:12] <dalek> rakudo/nom: 66d946e | TimToady++ | src/Perl6/Actions.nqp:

[03:12] <dalek> rakudo/nom: hook up new with/without opcodes

[03:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/66d946e9a7

[03:12] <dalek> rakudo/nom: c70e5e1 | TimToady++ | tools/build/NQP_REVISION:

[03:12] <dalek> rakudo/nom: bump NQP for new with/without ops

[03:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c70e5e1935

[03:13] <dalek> nqp: 4de65a5 | TimToady++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[03:13] <dalek> nqp: implement with/without ops

[03:13] <dalek> nqp: 

[03:13] <dalek> nqp: These are just like if/unless except they test for .defined, but

[03:13] <dalek> nqp: still pass the original object to the block.

[03:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4de65a56d6

[03:13] <ShimmerFairy> Sgeo: note that there are some features related to using previously-seen parts, like <~~>, that aren't yet implemented.

[03:14] <b2gills> shinobi-cl: jnthn is currently working on the design of that

[03:15] <b2gills> I think that the Perl 6 grammar ( the grammar used to parse Perl 6 ) is at least a context sensitive grammar ( as far as I know )

[03:16] <ShimmerFairy> m: say "foodbard" ~~ / (foo|bar) d <~~0> d /;  # this would, if implemented, match the whole string, whereas neither $0 nor <$0> would do so in the place of <~~0>

[03:16] <camelia> rakudo-moar 1a3f1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/c5a46f_UT4␤Sorry, ~~ regex assertion with a capture is not yet implemented␤at /tmp/c5a46f_UT4:1␤------> 3say "foodbard" ~~ / (foo|bar) d <~~07⏏5> d /;  # this would, if implemented, ma␤»

[03:17] *** travis-ci joined
[03:17] <travis-ci> Rakudo build failed. TimToady 'bump NQP for new with/without ops'

[03:17] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/74663462 https://github.com/rakudo/rakudo/compare/1a3f1a2d6900...c70e5e1935b4

[03:17] *** travis-ci left
[03:17] <shinobi-cl> b2gills: cool!!

[03:21] <b2gills> Perl 6 steals ideas from everywhere, and removes the artificial limitations ( even when it isn't immediately obvious that it was an artificial limitation )

[03:22] *** nys left
[03:24] <Sgeo> IIUC, a function can take a closure that takes a closure etc can specify the type of all of these somehow?

[03:24] <Sgeo> When it does so, how accurate is the error message if an incorrectly typed thing is given?

[03:25] <Sgeo> Like, if the type of a function is Int --> Str, it's the caller's fault if it's given a non-Int, and the function's fault if it returns a non-Str. And things get more complicated at higher-order etc

[03:34] <b2gills> m: my sub example ( &b where \() ~~ &b.signature ){ say b }; example ->{ 'hello' }

[03:34] <camelia> rakudo-moar 1a3f1a: OUTPUT«hello␤»

[03:34] <b2gills> m: my sub example ( &b where \() ~~ &b.signature ){ say b }; example -> $ { 'hello' }

[03:34] <camelia> rakudo-moar 1a3f1a: OUTPUT«Constraint type check failed for parameter '&b'␤  in sub example at /tmp/43r0dIUCLO:1␤  in block <unit> at /tmp/43r0dIUCLO:1␤␤»

[03:35] <b2gills> There is probably a better way of writing it

[03:35] *** bayprogrammer left
[03:35] <Sgeo> Suppose a Parser[Foo] is a thing that, among other things, when given an Str, can try to get a Foo out. If Parser is monadic, then there exists a function join such that you can take a Parser[Parser[Foo]] and turn it into a Parser[Foo]

[03:35] <Sgeo> (And a few laws about that function join)

[03:36] <geekosaur> next up, Par6ec

[03:36] <Sgeo> So it takes a parser that results in a parser that results in Foo, and gives a parser that can just give back Foo

[03:42] <ShimmerFairy> timotimo: looking at deepmap, it appears that the nqp::while's it uses are 1) conditional, and 2) use an nqp::stmts after the condition. Do you know if nodemap and Range.reify are broken too? (they both have nqp::while loops with nqp::stmts)

[03:43] *** raiph left
[03:59] <shinobi-cl> r: my @re = (rx/4/, rx/6/); my @d = (1,12,34,44,46,66,65,90); @re ~~ @q;

[03:59] <camelia> rakudo-{moar,jvm} c70e5e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Variable '@q' is not declared␤at /tmp/tmpfile:1␤------> 3y @d = (1,12,34,44,46,66,65,90); @re ~~ 7⏏5@q;␤»

[04:00] <shinobi-cl> r: my @re = (rx/4/, rx/6/); my @d = (1,12,34,44,46,66,65,90); @re ~~ @d;

[04:00] <camelia> rakudo-{moar,jvm} c70e5e: ( no output )

[04:00] *** raiph joined
[04:01] *** raiph left
[04:01] <Sgeo> What's the difference between m and r?

[04:01] *** raiph joined
[04:02] *** raiph left
[04:03] *** raiph joined
[04:05] *** raiph left
[04:07] *** raiph joined
[04:08] *** raiph left
[04:09] *** bin_005 left
[04:09] *** raiph joined
[04:09] *** bin_005 joined
[04:10] *** raiph left
[04:11] *** raiph joined
[04:17] *** raiph left
[04:18] *** raiph joined
[04:19] <dalek> roast: 41defae | skids++ | S32-str/encode.t:

[04:19] <dalek> roast: Add tests for RT#107204

[04:19] <dalek> roast: 

[04:19] <dalek> roast: Also adjust comments for autogenned RTs that can be merged

[04:19] <dalek> roast: review: https://github.com/perl6/roast/commit/41defae663

[04:19] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=107204

[04:29] *** llfourn joined
[04:34] *** shinobi-cl left
[04:44] *** raiph left
[04:44] *** raiph joined
[04:50] *** Sgeo left
[04:51] *** Sgeo joined
[05:08] <b2gills> Sgeo: m: uses the MoarVM backend j: uses the JVM backend r: uses both

[05:17] <Sgeo> Ah

[05:21] <ugexe> this new precomp bug is quite frustrating. RAKUDO_MODULE_DEBUG shows the module XXX::Request as having been loaded, but then fails because it cant find the symbol &Request. Source code works fine, and precomp worked fine a couple days ago. 

[05:21] <ugexe> precompiled code worked fine^

[05:34] *** skids left
[05:42] *** aborazmeh left
[05:46] *** DrForr joined
[05:47] *** diana_olhovik joined
[05:47] *** sivoais joined
[05:54] *** sivoais left
[05:56] *** sivoais joined
[05:58] *** llfourn_ joined
[05:58] *** preyalone left
[05:58] *** llfourn left
[05:58] *** preyalone joined
[06:02] *** geekosaur left
[06:04] *** dsm left
[06:04] *** eam left
[06:05] *** eam joined
[06:05] *** dsm joined
[06:06] <TimToady> m: with "abc".index("a") { say $^pos }

[06:06] <camelia> rakudo-moar c70e5e: OUTPUT«0␤»

[06:06] *** diakopter left
[06:07] *** diakopter joined
[06:10] *** telex left
[06:12] *** brrt joined
[06:12] *** telex joined
[06:12] <jdv79> ugexe: i also hit an error like that

[06:12] <jdv79> quite fun indeed

[06:14] *** geekosaur joined
[06:14] <Sgeo> with?

[06:15] <Sgeo> Function application as a function?

[06:15] <TimToady> more like "success" in logic programming

[06:15] <Sgeo> Where are docs?

[06:15] <TimToady> aren't any yet

[06:15] <Sgeo> Where is definition?

[06:15] <TimToady> not even any tests yet :)

[06:17] <TimToady> but these are all related to 'andthen', which does have some documentation

[06:17] <jdv79> at my last job i would automatically fail a code review if it had no tests

[06:17] <jdv79> i didn't get many code reviews

[06:17] <TimToady> m: "abc".index("a") andthen .say

[06:17] <camelia> rakudo-moar c70e5e: OUTPUT«0␤»

[06:18] <Sgeo> Is with like an if defined -> $blah sort of thing?

[06:18] <TimToady> yes

[06:20] <TimToady> m: .say with "abc".index("a")

[06:20] <camelia> rakudo-moar c70e5e: OUTPUT«0␤»

[06:20] <TimToady> works as a statement modifier too

[06:20] <Sgeo> Do custom statement modifiers exist?

[06:20] <jdv79> we can finally put the whole Pos/Index thing behind us!

[06:20] <TimToady> not yet

[06:21] <TimToady> there's a syntax category, so the macro system should eventually allow targeting that slot

[06:21] <Sgeo> m: say "abc".index("a").WHAT

[06:21] <camelia> rakudo-moar c70e5e: OUTPUT«(Int)␤»

[06:21] <Sgeo> m: say (my $a).VAR.WHAT

[06:21] <camelia> rakudo-moar c70e5e: OUTPUT«(Scalar)␤»

[06:21] <TimToady> m: .say with .index("a") for 'aaa' ... 'zzz'

[06:21] <camelia> rakudo-moar c70e5e: OUTPUT«Method 'index' not found for invocant of class 'Any'␤  in block <unit> at /tmp/LWoL6CisSP:1␤␤»

[06:22] <TimToady> hmm, looks like a bug

[06:22] <Sgeo> m: say (my $a).VAR

[06:22] <camelia> rakudo-moar c70e5e: OUTPUT«Any␤»

[06:22] <Sgeo> m: say (my $a).VAR.perl

[06:22] <camelia> rakudo-moar c70e5e: OUTPUT«Any.new␤»

[06:22] * Sgeo should stop spamming

[06:27] <TimToady> m: (.say with .index("a")) for 'aaa' ... 'zzz'

[06:27] <camelia> rakudo-moar c70e5e: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤…»

[06:27] <TimToady> m: (.say with .index("a")) for 'baa' ... 'zzz'

[06:27] <camelia> rakudo-moar c70e5e: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤…»

[06:27] <TimToady> oughta work without the parens though

[06:35] *** xfix joined
[06:47] *** llfourn_ left
[06:57] *** rurban joined
[07:05] *** danaj left
[07:10] *** RabidGravy joined
[07:20] <RabidGravy> marning

[07:30] <Sgeo> m: print 5.&infix:<~>;

[07:30] <camelia> rakudo-moar c70e5e: OUTPUT«5»

[07:30] <Sgeo> m: print 5.&infix:<~>.perl

[07:30] <camelia> rakudo-moar c70e5e: OUTPUT«"5"»

[07:31] <Sgeo> That's almost certainly not the obvious way to do it

[07:48] *** darutoko joined
[07:50] *** xfix left
[07:51] *** brrt left
[08:14] *** brrt joined
[08:28] *** danaj joined
[08:41] *** brrt left
[08:44] *** TEttinger left
[08:44] *** llfourn joined
[08:44] *** rurban left
[08:48] *** llfourn left
[09:01] <dalek> Inline-Perl5: ffa10fe | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[09:01] <dalek> Inline-Perl5: Fix can on Perl6::Object:: packages

[09:01] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/ffa10fee34

[09:01] <dalek> Inline-Perl5: 9a6bc58 | (Stefan Seifert)++ | / (5 files):

[09:01] <dalek> Inline-Perl5: Better fake inheritance from P5 classes by P6 classes

[09:01] *** dalek left
[09:01] *** dalek joined
[09:01] *** ChanServ sets mode: +v dalek

[09:01] <nine> I'll never understand why dalek sometimes can print a screen full and at other times get kicked after just 5 lines

[09:05] <RabidGravy> different servers?

[09:07] *** diana_olhovik left
[09:07] *** xfix joined
[09:08] *** diana_olhovik joined
[09:16] *** diana_olhovik left
[09:20] *** cognominal joined
[09:24] *** woolfy joined
[09:25] *** coffee` left
[09:25] *** coffee` joined
[09:26] <woolfy> Perl 6 Hackathon at Swiss Perl Workshop is going to be great: http://act.perl-workshop.ch/spw2015/wiki?node=HackathonAttendees

[09:26] *** woolfy left
[09:29] *** cognominal left
[09:30] *** cognominal joined
[09:40] *** gfldex joined
[09:42] *** rurban joined
[09:44] *** llfourn joined
[09:45] *** diana_olhovik joined
[09:48] *** llfourn left
[10:12] <dalek> perl6-most-wanted: bd6ca64 | (Bradley Andersen)++ | most-wanted/modules.md:

[10:12] <dalek> perl6-most-wanted: adding info on p6 Math::Trig

[10:12] <dalek> perl6-most-wanted: 

[10:12] <dalek> perl6-most-wanted: work to begin next week, unless you know of someone else already doing it

[10:12] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/bd6ca64979

[10:12] <dalek> perl6-most-wanted: 4df6961 | lizmat++ | most-wanted/modules.md:

[10:12] <dalek> perl6-most-wanted: Merge pull request #5 from elohmrow/patch-1

[10:12] <dalek> perl6-most-wanted: 

[10:12] <dalek> perl6-most-wanted: adding info on p6 Math::Trig

[10:12] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/4df6961958

[10:13] *** diana_olhovik left
[10:14] <sergot> AlexDaniel: thanks!

[10:18] <RabidGravy> which reminds me

[10:20] *** Alina-malina joined
[10:25] <dalek> rakudo/nom: 16e5d29 | sergot++ | src/core/Exception.pm:

[10:25] <dalek> rakudo/nom: fix X::Dynamic::Postdeclaration exception message #125733

[10:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16e5d295dc

[10:25] <dalek> rakudo/nom: d3eb00a | lizmat++ | src/core/Exception.pm:

[10:25] <dalek> rakudo/nom: Merge pull request #488 from sergot/exception-msg-fix

[10:25] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125733

[10:25] <dalek> rakudo/nom: 

[10:25] <dalek> rakudo/nom: fix X::Dynamic::Postdeclaration exception message #125733

[10:25] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125733

[10:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d3eb00a020

[10:27] <dalek> perl6-most-wanted: 78b07e3 | RabidGravy++ | most-wanted/modules.md:

[10:27] <dalek> perl6-most-wanted: Added Log::Syslog::Native and Term::Cap as WIP

[10:27] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/78b07e3cc3

[10:38] *** xfix left
[10:42] *** rindolf joined
[10:44] *** brrt joined
[10:44] *** rurban left
[10:48] <dalek> roast: f8b1530 | lizmat++ | S04-statements/with.t:

[10:48] <dalek> roast: Add some more with/orwith/without tests

[10:48] <dalek> roast: review: https://github.com/perl6/roast/commit/f8b15308dc

[10:49] *** rurban joined
[10:50] <dalek> rakudo/nom: a32c146 | lizmat++ | t/spectest.data:

[10:50] <dalek> rakudo/nom: Add with/without/orwith tests to spectest

[10:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a32c14627e

[10:51] *** isBEKaml joined
[10:55] *** brrt left
[11:02] *** RabidGravy left
[11:07] *** Averna joined
[11:21] <dalek> rakudo/nom: 42e19ee | lizmat++ | src/core/ (4 files):

[11:21] <dalek> rakudo/nom: Fix spectest errors caused by Index changes

[11:21] <dalek> rakudo/nom: 

[11:21] <dalek> rakudo/nom: This is actually mostly a revert of 391bdb1dc3a6962a049992dba , but using

[11:21] <dalek> rakudo/nom: new with/without functionality where appropriate

[11:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42e19ee5be

[11:24] *** diana_olhovik joined
[11:31] *** rurban left
[11:43] *** isBEKaml left
[11:45] *** llfourn joined
[11:49] *** llfourn left
[11:57] *** diana_olhovik left
[11:58] *** leont joined
[12:00] <leont> I'm trying to debug a grammar, how can I say get the string in front of the current position?

[12:01] <timotimo> leont: why don't you install Debugger::UI::Commandline and perl6-debug-m your script? :)

[12:01] <timotimo> m: "hello how are you?" ~~ / \w { say $/.CURSOR.prematch; } '?' /

[12:01] <camelia> rakudo-moar a32c14: OUTPUT«Method 'prematch' not found for invocant of class 'Cursor'␤  in block <unit> at /tmp/G0V1kzQo9X:1␤␤»

[12:01] <timotimo> m: "hello how are you?" ~~ / \w { say $/.CURSOR.pos; } '?' /

[12:01] <camelia> rakudo-moar a32c14: OUTPUT«1␤2␤3␤4␤5␤7␤8␤9␤11␤12␤13␤15␤16␤17␤»

[12:02] <timotimo> m: "hello how are you?" ~~ / \w { say $/.orig.substr(0, $/.CURSOR.pos - 1); } '?' /

[12:02] <camelia> rakudo-moar a32c14: OUTPUT«␤h␤he␤hel␤hell␤hello ␤hello h␤hello ho␤hello how ␤hello how a␤hello how ar␤hello how are ␤hello how are y␤hello how are yo␤»

[12:02] <leont> Ah, now I understand, I forgot about .orig

[12:02] <timotimo> useful, no? :)

[12:03] <timotimo> i'm glad to hear you're working on perl6 stuff again

[12:03] <timotimo> will i see you at the SPW?

[12:04] <leont> I'm on vacation that week, so no

[12:05] <timotimo> oh, ok

[12:07] * leont is trying to write a YAML::Tiny, but the significant whitespace is a mess to parse

[12:08] <timotimo> ah

[12:08] <timotimo> i take it you saw the grammar that does significant whitespace and turns it into "suites" for you?

[12:08] *** avalenn joined
[12:10] <leont> I didn't

[12:14] *** pmurias joined
[12:14] <timotimo> oh

[12:14] <timotimo> sorry i took it, then

[12:14] <timotimo> you can have it back :)

[12:26] *** rmgk left
[12:27] *** cognominal left
[12:32] <leont> Match seems to fail at the very end, don't grok why :-/

[12:36] *** brrt joined
[12:38] <timotimo> probably want to match \n, but not $

[12:38] <timotimo> and then $ comes without a \n in front and boom

[12:38] <nine> lizmat++ # writing tests is greatly appreciated :)

[12:39] <leont> Ha, found it! %% didn't DWIM apparently

[12:39] <nine> computers-- # always so picky about everyting

[12:40] <timotimo> oh

[12:40] <timotimo> %% allows the thing after %% to appear at the end once, to

[12:40] <timotimo> too*

[12:40] *** Averna left
[12:41] <leont> Yeah, but replacing it by % seems to make things parse, probably because I was using it inside a token

[12:41] <timotimo> ah, yeah

[12:41] <timotimo> if you :r, it'll try matching and not be able to backtrack

[12:41] <timotimo> to be honest, i don't really grok backtracking and ratcheting too well

[12:43] <leont> Obvious in hindsight, not so obvious when stuck in it

[12:43] <timotimo> very yes

[12:43] <timotimo> hence: perl6-debug-m :)

[12:44] <timotimo> have you seen that yet?

[12:45] <timotimo> it'll give you really pretty output for regex matching

[12:54] <leont> s not meaning the same as in gdb was confusing though

[12:59] <leont> Is there a way to make the line-editing work in the debugger? (I already installed Linenoise)

[13:03] <timotimo> oh, hmm

[13:03] <timotimo> it probably wants to be modified so that it uses linenoise, too

[13:03] <timotimo> until then, rlwrap is your friend

[13:04] <timotimo>  gotta go

[13:05] *** RabidGravy joined
[13:16] *** cognominal joined
[13:16] *** Sqirrel left
[13:18] *** cognominal left
[13:31] *** cognominal joined
[13:37] *** nys joined
[13:38] <leont> ingy: not sure if I should call my module YAML::Tiny or YAMLish (given I'm not intending to write a complete implementation), opinions?

[13:40] <Zoffix_> leont, YAMLish

[13:41] <RabidGravy> SortaKinda::YAML

[13:41] <Zoffix_> leont, hm, there's YAML::Tiny in P5 that does exactly what you're planning. I think for consistency for any converts it'd be good choice. YAMLish sounds cooler though and is easier to write :)

[13:44] <JimmyZ> YAML::ish ...

[13:46] *** llfourn joined
[13:51] *** llfourn left
[14:12] <pmurias> YAML::Kindof

[14:13] <pmurias> YAML::ish++ 

[14:15] *** telex left
[14:15] *** telex joined
[14:21] <ugexe> YAYAML

[14:23] *** telex left
[14:24] <flussence> YAMeh :)

[14:24] *** telex joined
[14:26] <ugexe> ooo. the precomp bug that suddenly reared itself in the last 2 days out of nowhere is not present on r-j

[14:28] <lizmat> ugexe: could you test again after my latest fix, aka 42e19ee5be55d7e3d4d472 ?

[14:28] <lizmat> I have a feeling they're related

[14:29] * lizmat starts off a JVM build and test

[14:31] <ugexe> i tried, no go :(

[14:45] <dalek> Inline-Perl5: 73cae34 | (Stefan Seifert)++ | / (3 files):

[14:45] <dalek> Inline-Perl5: Full support for 'can' on P6 subclasses of P5 classes

[14:45] <dalek> Inline-Perl5: 

[14:45] <dalek> Inline-Perl5: We now support $object->can('bar') and $class->can('bar') and return

[14:45] <dalek> Inline-Perl5: methods found in the Perl 6 subclass or the Perl 5 parent as code

[14:45] <dalek> Inline-Perl5: reference.

[14:45] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/73cae34fa5

[14:46] <nine> Now there's only one nasty reference count problem between me and an epic demo at YAPC :)

[14:51] *** lucasb joined
[14:52] *** colomon left
[14:52] *** colomon joined
[14:58] *** skids joined
[14:59] <ugexe> i take that back, jvm fails as well, but not under as many circumstances. if i do `perl6 -Iblib/lib t/Module-Some-Reqest.t` i get the same "Cannot find symol &Request". However, `-Iblib/lib -Ilib` is what was really passing on JVM for me. The thing is, on MoarVM `-Iblib/lib -Ilib`  and `-Iblib` both give me the cannot find symbol error

[15:00] <ugexe> s/and `-Iblib`/and `-Ilib`/

[15:01] <ugexe> so maybe unrelated, but it would seem that the JVM will load the source of it cant find the precompiled version and moar isnt?

[15:04] <nine> No, MoarVM should do the same

[15:10] <ugexe> i know what it should do, im referring to a recent precomp bug

[15:11] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 (GLR gist) now contains early work on .race() (this is also most of the work for .hyper()) that actually uses multiple CPU cores.

[15:12] <jnthn> I've not done any optimization yet, and it's certainly not smart enough to make good guesses about batch size and degree, but here's the results from the first little benchmark I did: https://gist.github.com/jnthn/03e2082ca5ed20ff8d44

[15:13] *** bin_005_g joined
[15:14] *** bin_005 left
[15:14] <nine> jnthn: wow, looks quite promising :)

[15:20] * jnthn bbl

[15:27] <lizmat> hmmm...  JVM doesn't build for me at all

[15:28] * lizmat nukes install and tries again

[15:36] <b2gills> jnthn: GLRHyperWorkBuffer.swap doesn't use the variable $new-input, why is it there?

[15:36] *** davido___ joined
[15:38] *** davido__ left
[15:43] <lizmat> alas, no go: this is the gist: https://gist.github.com/lizmat/d8f40d3b445b4db54031

[15:43] *** brrt left
[15:45] *** kaare__ left
[15:47] *** llfourn joined
[15:51] *** llfourn left
[15:57] *** brrt joined
[15:59] <RabidGravy> jnthn, the problem is I'm somewhat osborned by the greatness that is coming ;-)

[16:00] <raiph> Am I nuts? What about adverbs / named args being syntactically distinguished from pairs; adverbs applying to the closest non adverb non value on their immediate left; with/without becomes if :D, if :U?

[16:02] <TimToady> :D measures .DEFINITE, not .defined

[16:02] <TimToady> m: say Failure.new.DEFINITE

[16:02] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[16:02] <TimToady> m: say Failure.new.defined

[16:02] <camelia> rakudo-moar a32c14: OUTPUT«False␤»

[16:03] <raiph> if :d ... ?

[16:03] <TimToady> and you can't put adverbs right after an infix, or they'll be taken as a term

[16:05] <TimToady> 'with' also has a different topicalization policy from 'if'

[16:05] <skids> m: if 1 :D { } # already parses as an adverb

[16:05] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4hsoyfIRrX␤You can't adverb that␤at /tmp/4hsoyfIRrX:1␤------> 3if 1 :D7⏏5 { } # already parses as an adverb␤    expecting any of:␤        pair value␤»

[16:05] <geekosaur> heh

[16:05] <TimToady> because it's at an infix position

[16:05] <RabidGravy> CRACK PARTY!

[16:08] <raiph> <TimToady> 'with' also has a different topicalization policy from 'if' <-- Well, I was (insanely?) imagining allowing adverbs to be applied to keywords and doing things like altering topicalization

[16:09] <TimToady> I think anything as violent as that really deserves a different keyword

[16:10] <TimToady> otherwise logic programming is gonna be all full of colons

[16:11] <nine> I guess we already have enough of those :)

[16:11] *** brrt left
[16:15] *** raiph left
[16:19] *** AlexDaniel joined
[16:19] <zostay> is it possible to create your own trait_mod verb's, e.g., trait_mod:<must>?

[16:22] <colomon> zostay: http://design.perl6.org/S14.html#Traits

[16:22] <leont> Of couse it's possible, it's perl 6 ;-)

[16:23] <zostay> that's what i thought, but it's not working, so i must be doing it wrong then... just making sure it wasn't one of those things that "yes, but it doesn't work yet"

[16:24] <RabidGravy> my understanding is that rakudo doesn't allow it yet

[16:26] <zostay> adding another <is> has worked in my playing around in the past, but adding a new one like <must> isn't and adding a new <will> variant is not working for me either

[16:26] <colomon> hmmm… it does look like it’s enumerating all the possibilities in the grammar.  :\

[16:26] <RabidGravy> yes

[16:28] <zostay> most of the time, i hunt around src/* in rakudo and try to emulate what's there to see if it works before i ask questions here ;)

[16:28] <colomon> zostay: good plan

[16:30] <zostay> experimenting with adding some optional traits to the P6SGI spec to be used by apps and middleware to allow a variety of interfaces to be automatically adapted into the standard interface

[16:32] *** raiph joined
[16:33] <zostay> defining is trait isn't working now for me

[16:33] <raiph> TimToady: Have I misunderstood "with"? I thought it changed the condition test, not topicalization

[16:35] *** mjgardner joined
[16:36] <raydiak> good morning #perl6

[16:39] <raiph> hi raydiak

[16:42] <b2gills> ` with $a { .say } ` is similar to ` given $a { if .defined { .say } } `

[16:45] <TimToady> except I haven't managed to implement that degree of topicalization yet, having tried for hours...

[16:46] <TimToady> so currently you still have to say with $a -> $_ { .say }

[16:46] <TimToady> or use the modifier form, which does topicalize already

[16:46] <TimToady> m: .say with 42

[16:46] <camelia> rakudo-moar a32c14: OUTPUT«42␤»

[16:47] <TimToady> m: .say with Nil

[16:47] <camelia> rakudo-moar a32c14: ( no output )

[16:47] <TimToady> m: say (42 with Nil)

[16:47] <camelia> rakudo-moar a32c14: OUTPUT«(Any)␤»

[16:47] <TimToady> there's a bug I just found, should be returning Empty (soon to be Slip)

[16:51] *** bin_005_g_k joined
[16:51] <lucasb> m: my @a; with @a { say 'yes' }

[16:51] <camelia> rakudo-moar a32c14: OUTPUT«yes␤»

[16:51] <lucasb> m: my @a; say 'yes' with @a

[16:51] <camelia> rakudo-moar a32c14: ( no output )

[16:51] *** bin_005_g left
[16:53] *** eam left
[16:56] *** brrt joined
[17:01] <TimToady> m: my @a; say @a.defined

[17:01] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[17:01] <TimToady> hmm

[17:02] <dalek> roast: b630ee3 | skids++ | S02-types/nil.t:

[17:02] <dalek> roast: Add test for RT#118717 which can probably be closed

[17:02] <dalek> roast: review: https://github.com/perl6/roast/commit/b630ee303f

[17:02] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118717

[17:05] <Sgeo> Ok shouldn't it be one or the other (the say 'yes' with @a vs with @a { say 'yes' } )?

[17:05] *** eam joined
[17:06] <Sgeo> TimToady, if it's a closure, why does it need to topicalize to be able to use .say? Shouldn't the mere use of a $_ reliant form turn it into... or do you need a literal $_ for that?

[17:07] <TimToady> neither of those are good enough for 'if' blocks, and we're piggybacking on that implementation

[17:07] <TimToady> (so that we can intermix if/with clauses)

[17:08] <Sgeo> Ah

[17:08] <Sgeo> m: { .say }.WHAT

[17:08] <camelia> rakudo-moar a32c14: ( no output )

[17:08] <Sgeo> m: say { .say }.WHAT

[17:08] <camelia> rakudo-moar a32c14: OUTPUT«(Block)␤»

[17:08] <Sgeo> m: { .say }(5)

[17:08] <camelia> rakudo-moar a32c14: OUTPUT«5␤»

[17:09] <TimToady> but the if/else implementation really doesn't want to force topicalization like given/when does; at least, I've tried 20 or 30 ways to do it already, and there's always some method it can't find because the types of blocks expected are too different

[17:10] <TimToady> one of these days I'll have to actually understand what's going on rather than just cargo-culting code from other spots...

[17:10] <TimToady> well, I can write a test for it, even if it's failing currently

[17:12] <TimToady> and copying stuff in from the implementations of given or for just gives the opcode generator heartburn

[17:13] <TimToady> I'm sure jnthn++ could hook it up in 15 minutes, but he actually knows what he's doing :)

[17:20] <jnthn> b2gills: Thanks for noticing, it shoulda been what I assign to $!input. :) This is why I need to write more than one test case. :)

[17:21] *** ChoHag joined
[17:21] <ChoHag> Can I have a signature with two (or more but they're irrelevant) arguments where one argument's default is the value of the other (required) argument?

[17:22] <jnthn> On people asking about custom traits and noting they are enumerated in the grammar: yes, because different traits parse different things after them. And it's not clear there's on sane default (though we could I guess pick "same parse as <is>"). So it's probably in slang teritory...

[17:23] <ChoHag> Never mind. The obvious answer is correct, I just missed the $.

[17:23] *** kaare__ joined
[17:24] <rjbs> Who is "elohmrow"?

[17:25] <lucasb> it's 'wormhole' backwards :)

[17:26] <rjbs> He reported a p6 bug in a p5 library.  /me just closes with a note.

[17:28] <nine> rjbs: a p6 bug in a p5 library?

[17:29] <rjbs> https://github.com/pvande/Template-Mustache/issues/20

[17:30] <nine> Oops :) Probably meant https://github.com/softmoth/p6-Template-Mustache/

[17:30] * rjbs adds that.

[17:35] <tadzik> hehe, history's happening

[17:37] <Sgeo> So wrong repo, not someone trying to run P5 code on P6?

[17:37] <nine> yep

[17:37] *** zakharyas joined
[17:38] <dalek> roast: f00b2ca | skids++ | S14-roles/stubs.t:

[17:38] <dalek> roast: Add (fudged) tests for RT#124393

[17:38] <dalek> roast: review: https://github.com/perl6/roast/commit/f00b2ca48f

[17:38] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124393

[17:40] *** pmurias left
[17:44] *** mjgardner left
[17:47] *** mjgardner joined
[17:48] *** llfourn joined
[17:53] *** llfourn left
[17:53] *** rmgk joined
[17:56] <nine> So I just spent 3 hours installing a perl with all debugging options enabled and hundreds of CPAN modules to debug my refcount problem. And with this, I cannot repro the error anymore :(

[18:08] <dalek> roast: a56dd50 | skids++ | S06-routine-modifiers/proxy.t:

[18:08] <dalek> roast: Add (fudged) tests for RT#124341

[18:08] <dalek> roast: review: https://github.com/perl6/roast/commit/a56dd50ac7

[18:08] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124341

[18:10] *** rindolf left
[18:20] *** brrt left
[18:27] *** kernel joined
[18:27] *** kernel is now known as Guest94770

[18:29] *** Guest37893 left
[18:38] <dalek> specs: 614b6f3 | TimToady++ | S04-control.pod:

[18:38] <dalek> specs: doc with/without

[18:38] <dalek> specs: review: https://github.com/perl6/specs/commit/614b6f36e1

[18:38] *** kaare__ left
[18:49] *** zakharyas left
[18:49] *** cognominal left
[18:54] *** mjgardner left
[19:00] <dalek> rakudo/nom: 68c01f4 | TimToady++ | t/spectest.data:

[19:00] <dalek> rakudo/nom: add test files for with/without modifiers

[19:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68c01f41f6

[19:00] <dalek> rakudo/nom: b527b31 | TimToady++ | src/ (2 files):

[19:00] <dalek> rakudo/nom: without is different from orelse

[19:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b527b31a60

[19:00] <dalek> roast: 8a752ca | TimToady++ | S04-statement-modifiers/with (2 files):

[19:00] <dalek> roast: Add test files for with/without modifiers

[19:00] <dalek> roast: review: https://github.com/perl6/roast/commit/8a752ca375

[19:00] <dalek> roast: 86a4c3e | TimToady++ | S03-operators/andthen.t:

[19:00] <dalek> roast: andthen returns Empty on failure

[19:00] <dalek> roast: review: https://github.com/perl6/roast/commit/86a4c3e5a0

[19:03] <timotimo> jnthn: i wonder why the time for :degree(1) and :degree(2) is exactly the same

[19:03] <timotimo> other than that: way cool!

[19:06] <ChoHag> How do you say 'Array of <foo>' in a Signature?

[19:07] <ChoHag> Type check failed binding @foo: expected 'Positional[Array[Str]]' but got 'Array'

[19:09] <TimToady> the @ already implies Positional, you just say 'foo @foo'

[19:10] <jnthn> timotimo: oh...because I mis-copied

[19:10] <ChoHag> Type check failed binding @foo: expected 'Positional[Str]' but got 'Array'

[19:10] <jnthn> timotimo: Thankfully still had them in scroll back in my console. Fixed gist.

[19:11] <ChoHag> FWIW, the value passed in is the result of a Str.split()

[19:11] <TimToady> ChoHag: it won't coerce the elements for you; you either have to create an Array[Str] or leave off the type declaration in the sgi

[19:11] <TimToady> you can't have strict typing and lax typing at the same time :)

[19:12] <TimToady> *sig

[19:13] <ChoHag> Ah it's happy if the split is passed into a my Str @foo rather than just @foo.

[19:13] <ChoHag> s/just @foo/just my @foo/

[19:14] <dalek> roast: e7f5bb7 | skids++ | / (2 files):

[19:14] <dalek> roast: Add (fudged) test for RT#124324

[19:14] <dalek> roast: 

[19:14] <dalek> roast: Also, silence nqp warnings from inside evals in Test::Compile

[19:14] <dalek> roast: review: https://github.com/perl6/roast/commit/e7f5bb7c56

[19:14] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124324

[19:14] <timotimo> jnthn: ah, yes, much better :)

[19:14] <ChoHag> Seems like it's something that hangs on compile vs. run time.

[19:14] <timotimo> i'm glad

[19:14] <jnthn> :)

[19:14] <jnthn> So, guess I better write a few more tests...

[19:15] <jnthn> Though tbh I'm happy the overall design/API is sane

[19:21] <leont> My code is returning a Parcel when I really want an Array or some such, what's the clean way to get it?

[19:21] <leont> (other than wait for GLR to finish, I suppose)

[19:22] <leont> Putting it in a [􏿽x85] seems a bit odd

[19:23] *** synbot6 left
[19:23] <jnthn> Does .Array work as a coercion?

[19:24] <jnthn> Or just assign the result into an array?

[19:26] <Sgeo> I feel like I should wait for GLR to finish before attempting to understand more of Perl 6

[19:26] <leont> .Array seems to flatten, which wasn't what I wanted

[19:26] <leont> [ <expression> ] it is, I suppose

[19:27] <TimToady> that flattens too

[19:27] <TimToady> (pre GLR)

[19:27] *** kaare__ joined
[19:27] <jnthn> Well, on the inside yes...

[19:27] <TimToady> oh, is okay if he was referring to the outside then

[19:28] <leont> expression is something like @<foo>􏿽xBB.ast, calling .Array on that does surprising (to me) things 

[19:29] <TimToady> jnthn: the basic problem I'm having with 'with' control blocks is that the if/elsif/else machinery assumes all over that it's dealing with Block, while the usual ways of turning a block into a topicalized block seem to make it not a Block anymore

[19:29] <skids> Well, especially of @<foo> is undefined :-)

[19:29] <skids> *if

[19:30] <tadzik> Sgeo: well, to be fair, there's a lot more to understand aside of lists :)

[19:30] *** cognominal joined
[19:32] <TimToady> jnthn: but obviously an explicit -> $_ {...} block works, so obviously I just haven't achieved the correct incantation yet to make it look like that

[19:35] *** AlexDaniel left
[19:35] <jnthn> TimToady: Can you arrange for it to do <xblock(1)> when it's a with, not just <xblock>?

[19:39] *** cognominal left
[19:40] <TimToady> thanks, I'll whack at it some more, hopefully not another several hours :)

[19:40] <Sgeo> Will GLR affect the weird way map works?

[19:40] <jnthn> TimToady: Fingers crossed that nails it

[19:41] <Sgeo> Where map can apparently be called with @foo or $a, $b, and @foo just sort of ...flattens into the argument list as though |@foo was used

[19:41] <jnthn> Sgeo: You're going to have to be more specific about what you think is weird.

[19:42] <jnthn> Generally, though, less flattening happens by default in the GLR

[19:42] <jnthn> There's very few places it does

[19:42] *** zakharyas joined
[19:43] <Sgeo> So do I wait for GLR to try to understand it?

[19:43] <jnthn> I'd say so, given it's (a) soon, and (b) easier to understand

[19:44] <jnthn> Though I can't promise easier to agree with :P

[19:45] <Sgeo> ok, ty

[19:49] *** llfourn joined
[19:54] *** llfourn left
[19:57] <ChoHag> What's the type object of a type object?

[19:57] <b2gills> Really there are quite a few different axis of differentiation for Lists ( eager(hyper|race|sequential) ... lazy(includes infinite) , flattening|non-flattening , itemizing|non-itemizing ) 

[19:58] <jnthn> ChoHag: identity

[19:58] <skids> b2gills: And "santa-clause's" :-)

[19:59] <ChoHag> I mean what can I put in a signature which will accept 'a type object'?

[19:59] * leont isn't sure he completely understands itemizing, it it's not related to non-flattening

[19:59] <skids> :U

[19:59] <b2gills> Mu:U or Any:U

[19:59] <ChoHag> Or ideally 'an object of type X or a type object'.

[20:00] <skids> That would be "X"

[20:00] <skids> Where only an object would be "X:D"

[20:00] <skids> But you should not name you class X :-)

[20:00] <b2gills> m: say test ( Mu:U ::T $a ){ my T $b = $a }; test 5

[20:00] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KSrDXDjyrC␤Confused␤at /tmp/KSrDXDjyrC:1␤------> 3say test ( Mu:U :7⏏5:T $a ){ my T $b = $a }; test 5␤    expecting any of:␤        colon pair␤»

[20:01] <skids> m: say test ( ::T Mu:U $a ){ my T $b = $a }; test 5

[20:01] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[20:02] <skids> hrm, anyway, captures come first.

[20:02] <ChoHag> Whitespace is an interesting choice of seperator.

[20:02] <geekosaur> m: test(::T:U $a) {my T $b = $a}

[20:02] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[20:02] <geekosaur> m: test(::T:U $a) {my ::T $b = $a}

[20:02] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[20:02] <geekosaur> bah

[20:02] <ChoHag> What#s the significance of the preceeding :: in '(::Foo Mu:U $thing)'?

[20:02] <b2gills> m: sub test ( ::T Mu $a ){ my T $b = $a; say $a; say T.^name }; test 5

[20:02] <camelia> rakudo-moar a32c14: OUTPUT«5␤Int␤»

[20:03] <skids> ChoHag: it is supposed to give you an alias to the passed type of the arument.

[20:03] <TimToady> you can put Mu:U there

[20:03] <ChoHag> m: class Foo { }; sub bar (::Foo Mu:U $thing) { say "Barring $thing" }; bar(Foo.new); bar(Int)

[20:03] <camelia> rakudo-moar a32c14: OUTPUT«Parameter '$thing' requires a type object of type Foo, but an object instance was passed␤  in sub bar at /tmp/3hM6jFmGi8:1␤  in block <unit> at /tmp/3hM6jFmGi8:1␤␤»

[20:03] <b2gills> m: class Foo { }; sub bar (::Foo Mu:U $thing) { say "Barring $thing" }; bar(Foo);

[20:03] <ChoHag> Interesting. That works with a more complete 'Foo'

[20:03] <camelia> rakudo-moar a32c14: OUTPUT«Use of uninitialized value $thing of type Foo in string context  in sub bar at /tmp/33ctf8Y3bx:1␤Barring ␤»

[20:04] <jnthn> TimToady: Are there any areas you think we should explore more in the GLR gist before starting on a "get it into Rakudo" branch?

[20:05] <b2gills> jnthn: I would say that you would be the best person to decide that

[20:06] <skids> .oO(native array interaction?)

[20:07] <skids> Or maybe that "just works"

[20:08] <jnthn> skids: I think that's a case of "I get to simplify the current code" :)

[20:09] <jnthn> I'm not too worried about that bit, anyway; it doesn't have any unknowns.

[20:09] <jnthn> b2gills: Sure, but I can have blind spots :)

[20:09] <b2gills> I know I pointed one out earlier

[20:10] <jnthn> Fixed in latest: https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[20:10] <jnthn> b2gills: Plus a test that actually exercises that code path.

[20:11] <b2gills> The only kind of exercise a programmer wants

[20:11] <jnthn> I'm not going to do hyper for now because it's basically just paying attention to the sequence number that's already there, so not really critical path

[20:12] <TimToady> I can't think of anything offhand

[20:13] <TimToady> is there a way we can put an "emulate old stuff in the scope of this env-var"?

[20:13] <TimToady> that might aid in people porting things bit by bit

[20:13] <ChoHag> Something's not quite right.

[20:13] <TimToady> s/env-var/dyn-var/

[20:14] <jnthn> TimToady: I...don't easily see a way.

[20:14] <jnthn> TimToady: And the old/new really don't play nice together.

[20:14] <TimToady> yeah, it didn't work out well for glrish

[20:14] <ChoHag> I want to pass a variable into a function so that a calculated variable can be ~~'d against it. The variable will either be a specific object or an object type, possibly of a type which the specific object isn't.

[20:14] <TimToady> so maybe it's bite-the-bullet time

[20:15] <jnthn> Like, every time I mentioned a bit of the previous implementation by accident, I got pretty dramatic explosions.

[20:15] <jnthn> Or totally useless results.

[20:15] <ChoHag> It seemed to work until the object type included a ::, so (::Foo::Bar Mu:U :$check) didn't work, though until I included the 'or an object type' check, (Foo::Bar :$check) did.

[20:16] <TimToady> well, I'll be around till Wed, then off to(ward) Japan, so maybe better is sooner

[20:16] <jnthn> *nod*

[20:16] * jnthn is flying on the 18th

[20:16] <TimToady> 12th to Seattle, 14th to Kyoto

[20:17] <jnthn> Ah, and some sight-seeing in Kyoto ahead of the conf? :)

[20:17] <TimToady> taking Heidi & Andy

[20:17] <b2gills> ChoHag: the ::Foo notation creates an alias to the type object of the type of $check

[20:17] <ChoHag> I'm too drunk to understand that.

[20:18] <jnthn> Nice :)

[20:18] * jnthn enjoyed kyoto

[20:19] <b2gills> ChoHag: (::Foo $check) is similar to `my \Foo = $check.WHAT`

[20:22] <b2gills> ChoHag: so (::Foo Mu:U $check) is actually rather pointless as `Foo =:= $check` because $check is required to be just a type object because of the :U

[20:23] <ChoHag> How do you create a type check in a signature which is an either/or theb?

[20:23] <ChoHag> then

[20:24] <jnthn> TimToady: Not having what ;-lists produce worked out will likely be the earliest blocker.

[20:24] <jnthn> (for now, LoL is going away)

[20:24] *** darutoko left
[20:25] <skids> Will ==> and <== even be needed post-GLR, or a stricter lazy?

[20:26] <jnthn> I'm not sure about those yet

[20:26] <jnthn> I have...many hazy ideas...for them

[20:26] *** plicease left
[20:27] *** plicease joined
[20:30] <b2gills> m: class Foo { }; sub bar (::Foo $thing) { say "Barring $thing is of type { Foo.^name }" }; bar(Foo.new);

[20:30] <camelia> rakudo-moar a32c14: OUTPUT«Barring Foo<140296743866032> is of type Foo␤»

[20:30] <b2gills> m: class Foo { }; sub bar (::Bar $thing) { say "Barring $thing is of type { Bar.^name }" }; bar(Foo.new);

[20:30] <camelia> rakudo-moar a32c14: OUTPUT«Barring Foo<140621048503984> is of type Foo␤»

[20:31] <ChoHag> I have to go.

[20:31] <ChoHag> That looks a little weird and I'll try to understand it in the morning.

[20:31] <ChoHag> Thanks for playing.

[20:32] *** ChoHag left
[20:47] <dalek> rakudo/glr: 63a8a38 | jnthn++ | src/vm/moar/ (2 files):

[20:47] <dalek> rakudo/glr: Toss some C VM extensions not needed post-GLR.

[20:47] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/63a8a384db

[20:48] <jnthn> (Note: don't expect GLR to even get through build, let alone work, for a while.)

[20:52] *** lucasb left
[20:54] *** zakharyas left
[20:58] <dalek> rakudo/glr: 10efc4c | jnthn++ | src/Perl6/World.nqp:

[20:58] <dalek> rakudo/glr: Replace an nqp::p6parcel with a die for now.

[20:58] <dalek> rakudo/glr: 

[20:58] <dalek> rakudo/glr: This gets things building through to BOOTSTRAP.

[20:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/10efc4c7a6

[20:58] <dalek> rakudo/glr: b2f1242 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[20:58] <dalek> rakudo/glr: Comment out and die on things that'll need fixes.

[20:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b2f1242f45

[20:58] <dalek> rakudo/glr: b98dec9 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[20:58] <dalek> rakudo/glr: Toss various types going away in GLR.

[20:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b98dec985d

[21:03] <dalek> rakudo/glr: 1a2a617 | jnthn++ | src/Perl6/World.nqp:

[21:03] <dalek> rakudo/glr: Comment convention consistency correction.

[21:03] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1a2a617643

[21:03] <dalek> rakudo/glr: 346e276 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:03] <dalek> rakudo/glr: Update List and Array definition in BOOTSTRAP.

[21:03] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/346e276b0f

[21:05] <jnthn> Well, that's the bull grabbed by the horns...

[21:06] <jnthn> Enough for today...

[21:06] <RabidGravy> :)

[21:10] *** bin_005_g_k left
[21:13] <leont> What's the (rough) timescale for the glr merge?

[21:15] <timotimo> m.

[21:15] <timotimo> a week perhaps?

[21:15] <timotimo> hmm. that seems unoptimistic

[21:17] <jnthn> Ask again in another day or two, when I've got a better feel for now hard it's going to be.

[21:25] <skids> Ooh.  We get to see blow-by-blow GLR now :-)

[21:27] *** kaare__ left
[21:29] *** espadrine left
[21:35] <TimToady> hopefully this will be the most disruptive change between now and Christmas :)

[21:36] * jnthn imagines so

[21:36] <jnthn> I don't see any competitors. :)

[21:37] <jnthn> 'night, #perl6 o/

[21:37] <nine> Good night jnthn 

[21:40] <lizmat> good night, jnthn

[21:41] <ShimmerFairy> TimToady: last night I happened to stumble on an old bug report on :U , and figured out that technically there was no bug :) (since the spec mentions DEFINITE, not defined). It however got me thinking about the utility of :T. It's NYI, and until that bug report I always saw :U as the type object constraint (since core seems to think so).

[21:41] <ShimmerFairy> (the bug in question: https://rt.perl.org/Ticket/Display.html?id=114442 )

[21:49] <ShimmerFairy> In fact, the spec suggests that :T is just :U but without allowing Failure objects, but AIUI you can't pass Failure objects to an Int-constrained parameter (for example) regardless of the smiley, so there seems to be no difference between :T and :U anymore.

[21:50] *** jjido joined
[21:50] *** llfourn joined
[21:55] *** llfourn left
[22:01] *** pippo joined
[22:01] <pippo> o/ #perl6

[22:02] <pippo> I have installed Linenoise but unable to have command history or tab completion in the repl. How can I debug this?

[22:02] <Sgeo> m: -> Int $x { say $x }(Failure.new);

[22:02] <camelia> rakudo-moar a32c14: OUTPUT«Earlier failure:␤ Failed␤␤Final error:␤ Type check failed in binding $x; expected 'Int' but got 'Failure'␤  in block <unit> at /tmp/0m5sgEGBtZ:1␤␤»

[22:03] <Sgeo> m: sub (--> Int) { fail "Oops!" if True; 5 }();

[22:03] <camelia> rakudo-moar a32c14: OUTPUT«Oops!␤  in sub  at /tmp/s7KMKfVLxl:1␤  in block <unit> at /tmp/s7KMKfVLxl:1␤␤Actually thrown at:␤  in block <unit> at /tmp/s7KMKfVLxl:1␤␤»

[22:04] <Sgeo> SHouldn't that not have compiled since the sub is capable of throwing a Failure but claims to return an Int?

[22:06] *** TEttinger joined
[22:09] <geekosaur> Failure has never worked that way and I'm not sure it retains any usefulness in a Perl 6 context if you require that it be represented in the result type

[22:09] <geekosaur> and I don't think Perl 6 has ever claimed to be Haskell

[22:10] <geekosaur> ...come to think of it, even Haskell lets you do that; see `error'

[22:11] <geekosaur> Failure is not so much a distinct type, as a special value that inhabits every type

[22:14] <Sgeo> Haskell doesn't really let you detect it though

[22:15] <pippo> good night #perl6

[22:15] *** pippo left
[22:15] <Sgeo> But I'm a bit more scared about type objects in that context, I don't see the difference between that and Java null

[22:16] <timotimo> a null in java is just "null"

[22:16] <timotimo> a type object is still of the right type

[22:21] <geekosaur> Haskell also doesn't have an object hierarchy wherein a Failure could be seen as a distinct out-of-band value provided by Mu...

[22:22] <geekosaur> ...and as someone who's seen more than enough Java code that declares it throws any possible exception rather than try to handle declaring exceptions the way that was intended, I am not sure you gain anything by adding such to another lnaguage (and indeed, pretty much nobody else has bothered after seeing how it turned out in Java)

[22:26] <raiph> Sgeo: Am I right that, in Haskell, if you write code that acknowledges the possibility of a Nothing value then that code must explicitly specify what to do with the Nothing possibility?

[22:28] <Sgeo> raiph, yes, although it can be as simple as giving up. And you can't not acknowledge the possibility of a Nothing value

[22:28] <Sgeo> fromJust is maligned because it's the way to deal with Nothing by dying, and the error message isn't so great at pinpointing the right location in code

[22:29] <Sgeo> geekosaur, what about Rust?

[22:29] <Sgeo> fromMaybe with error is a bit better I think

[22:30] <Sgeo> raiph, you can write code that uses Maybes monadically such that Nothing is automatically handled by having the whole thing be Nothing

[22:30] <raiph> Sgeo: I think Perl 6 works the same way in that regard.

[22:31] <raiph> Sgeo: or I should say: equivalently in that regard afaics

[22:33] <Sgeo> I don't think I dislike the Failure concept or anything, was just surprised when I saw it being strict about the types in one way but not the other

[22:33] <raiph> Sgeo: Aiui, in Perl 6 you can choos to not acknowledge Nothing, but if you try to use such a value you'll get a run-time exception

[22:34] <Sgeo> raiph, so a closer equivalent to Haskell would be if you had to do a check or at least a method like .value to get the value out if there's a possibility of failure

[22:35] <raiph> Sgeo: Fwiw I'm still confused about the Failure concept and that's why I'm having fun talking with you about it :)

[22:35] <geekosaur> isn't part of this so that some pragma could cause the Failure to reify as an actual value (e.g. 0 for a number, '' for a string) á la Perl 5?

[22:36] <Sgeo> For what it's worth, I see the fail function as doing something similar to Rust... in Rust, there's a try!() macro that looks at a Result<> and either gives the value if it's Ok or causes the function to return if it's Err, defined https://doc.rust-lang.org/std/macro.try!.html

[22:37] <Sgeo> I do wish it was either one or the other, it seems weird to have two things to do if there's a problem, and the caller needs to know which is in use if it wants to handle it

[22:37] <raiph> geeokosaur: yes, aiui Perl 6 Failures approximate to alap runtime handling of Nothings by default, leaving any number of ways to choose to tighten things up

[22:37] <Sgeo> (I mean, either pervasive fail for erroring or pervasive die, not both)

[22:38] <timotimo> i'm not entirely sure why rakudo doesn't put a :D onto a method's invocant parameter as soon as it sees a '$!' sigiled variable be used

[22:38] <timotimo> hm. perhaps because it could be inside a try { ... }

[22:40] *** shinobi-cl joined
[22:41] <ShimmerFairy> timotimo: there are some pragmas in S12 that are meant to control default smileys

[22:41] <raiph> Sgeo: I think the idea is that a coder writes "die" if they mean to force an end of the process containing the "die", and "fail" if they wish to explicitly leave it up to the caller.

[22:41] <ShimmerFairy> timotimo: > In standard Perl 6, C<Int> is generally assumed to mean C<Int:_>, except for invocants, where the default is C<Int:D>.

[22:42] <Sgeo> But die's and other exceptions are catchable... or is it like Rust where even though they might be catchable it should still be death?

[22:42] <ShimmerFairy> timotimo: except for method new, where the invocant is :T instead of :D (but :T is NYI, and as I mentioned it doesn't seem to be useful anymore, so that should perhaps be :U ?)

[22:43] <timotimo> of course, new must have :T

[22:43] <Sgeo> So I can call an ordinary function with method syntax, can I call an actual method with an arbitrary invocant using function syntax?

[22:43] <timotimo> but it also won't use $! sigiled vars :)

[22:43] <raiph> Sgeo: aiui dies are catchable (undying) and fails are fatalizable

[22:43] <timotimo> Sgeo: in order to get the method object, you have to go through .^find_method

[22:44] <ShimmerFairy> timotimo: I personally think :T is of limited use (unless someone can point out a difference between :T and :U that isn't the seemingly-outdated ":U but without Failure objects")

[22:44] <Sgeo> m: say Bool.^find_method("ACCEPTS")

[22:44] <camelia> rakudo-moar a32c14: OUTPUT«ACCEPTS␤»

[22:44] <ShimmerFairy> My personal recommendation is to remove and replace mentions of :T in the spec, and see how much doesn't happen :P

[22:48] <shinobi-cl> Hi all!

[22:48] <shinobi-cl> r: my Str @s =<Hello World>; my @rx = map({rx/$_/}, @s); say @rx.perl; 

[22:48] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«[rx/$_/, rx/$_/]<>␤»

[22:48] <shinobi-cl> r: my Str @s =<Hello World>; my @rx = map({rx/^$_$$/}, @s); say @rx.perl; 

[22:48] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«[rx/^$_$$/, rx/^$_$$/]<>␤»

[22:49] <raiph> m: (my method m ($self:) { say $self })(5) # Sgeo

[22:49] <camelia> rakudo-moar a32c14: OUTPUT«5␤»

[22:49] <raiph> hi shinobi-cl

[22:50] <japhb> TimToady: Unless I'm misunderstanding, it appears the with-orwith-else example you added to S04 suffers from copy pasta in the index() arguments

[22:50] <ShimmerFairy> timotimo: there's absolutely no mention of :T in roast or rakudo, not even so much as an NYI. I've concluded that :T is unnecessary, that :U/:D should be the type object/"value object"(?) distinction, and if necessary changes made to :U/:D to better fit that.

[22:51] <raiph> m: my &foo = my method m ($self:) { say $self }; foo(5) # Sgeo

[22:51] <camelia> rakudo-moar a32c14: OUTPUT«5␤»

[22:51] <dalek> specs: 584047e | TimToady++ | S04-control.pod:

[22:51] <dalek> specs: copy pasta noticed by japhb++

[22:51] <dalek> specs: review: https://github.com/perl6/specs/commit/584047e29e

[22:51] <Sgeo> raiph, cool

[22:51] <timotimo> i has to go to a sleep :S

[22:52] <raiph> goodnight timotimo

[22:52] <ShimmerFairy> If you check S12/Class methods, you can even see that the spec refers to :U as being for type objects vs. instances! :)  (granted, it was written in 2014, but still...)

[22:52] <Sgeo> ShimmerFairy, it almost seems like type objects are sometimes used in context as a failing type anyway (see .index())

[22:52] <ShimmerFairy> ♞ timotimo o/

[22:52] <timotimo> and tomorrow will probably be a mostly timoless day :(

[22:52] <ShimmerFairy> timotimo: quick thing; figure out that nqp::while bug to some extent?

[22:52] <Sgeo> m: say Nil == Nil.WHAT

[22:52] <camelia> rakudo-moar a32c14: OUTPUT«Use of Nil in numeric context  in block <unit> at /tmp/fesM14PLKT:1␤Use of Nil in numeric context  in block <unit> at /tmp/fesM14PLKT:1␤True␤»

[22:53] <Sgeo> m: say Nil =:= Nil.WHAT

[22:53] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[22:53] <TimToady> m: say "abc".index('z').WHAT

[22:53] <camelia> rakudo-moar a32c14: OUTPUT«Nil␤»

[22:54] <timotimo> but you'll cope, i'm sure

[22:54] <ShimmerFairy> Sgeo: yeah, the only distinction between :T and :U in the spec is that :T doesn't accept Failure types, but like I said that doesn't appear to be allowed with any smiley (including the default :_ )

[22:54] <Sgeo> They don't accept Failure types dynamically but do accept them statically?

[22:55] <Sgeo> Do I have that correct?

[22:55] <ShimmerFairy> As far as I understand, Failures are supposed to be like NaN, but for everything (instead of just floating-point)

[22:55] <ShimmerFairy> (and I don't understand very far ☺)

[22:56] <Sgeo> m: sub foo (Any:D $x) { say $x; }; my Failure $f = Failure.new; foo($f);

[22:56] <camelia> rakudo-moar a32c14: OUTPUT«Failed␤␤Actually thrown at:␤  in sub foo at /tmp/yVOTsBBR2R:1␤  in block <unit> at /tmp/yVOTsBBR2R:1␤␤»

[22:56] <Sgeo> m: sub foo (Any:D $x) { say $x; }; my Mu $f = Mu.new; foo($f);

[22:56] <camelia> rakudo-moar a32c14: OUTPUT«X::TypeCheck::Binding exception produced no message␤  in sub foo at /tmp/NgBaKksto8:1␤  in block <unit> at /tmp/NgBaKksto8:1␤␤»

[22:57] <Sgeo> I guess first is dynamic second static, but it might be tricky to see that?

[22:57] <Sgeo> m: sub foo (Any $x) { say $x; }; my Mu $f = Mu.new; foo($f);

[22:57] <camelia> rakudo-moar a32c14: OUTPUT«X::TypeCheck::Binding exception produced no message␤  in sub foo at /tmp/8wp9SLycWR:1␤  in block <unit> at /tmp/8wp9SLycWR:1␤␤»

[22:58] <ShimmerFairy> TimToady: is there still a place for :T that's not been explored (my understanding of :U/:D came from looking at src/core, which taught me that :U is for type object, :D is for instances, though that may not be quite to spec), or would it be safe to remove it from the spec?

[22:59] <TimToady> we can remove it

[23:05] *** ggoebel left
[23:06] <raiph> Sgeo: aiui, all "compile time" messages start with the word SORRY.

[23:06] <ShimmerFairy> Or "Potential difficulties" :)

[23:07] <dalek> specs: 68eb8a2 | ShimmerFairy++ | S (2 files):

[23:07] <dalek> specs: Remove :T smiley from specs

[23:07] <dalek> specs: 

[23:07] <dalek> specs: The :U smiley has taken the place of :T over the years, and the only

[23:07] <dalek> specs: difference specified between them (where :U accepts Failures but :T does

[23:07] <dalek> specs: not) doesn't appear to make sense anymore. Now :U is spec'd to mean type

[23:07] <dalek> specs: objects, and :D means instances.

[23:07] <dalek> specs: 

[23:07] <dalek> specs: The only potentially significant change for rakudo is the change from :T

[23:07] <dalek> specs: to :U as the default smiley for method new's invocant, but depending on

[23:07] <dalek> specs: existing implementation may already be how it works.

[23:07] <dalek> specs: review: https://github.com/perl6/specs/commit/68eb8a29be

[23:07] <shinobi-cl> r: my Str @s =<Hello to the World>; my @t = <Hello Mars - the red planet>; my @rx = map({rx/^$_$$/}, @s); my @results = @s.flatmap( { @t.grep($_) } ); say @results.perl 

[23:07] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«["Hello", "the"]<>␤»

[23:07] <raiph> ShimmerFairy++ # friendly warning that I forgot something :)

[23:07] <shinobi-cl> r: my Str @s =<Hello to the World>; my @t = <Hello Mars - the red planet>; my @rx = map({rx/^$_$$/}, @s); my @results = @s.flatmap( { @t.grep($_) } ); say @results.perl; say @rx.perl;

[23:07] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«["Hello", "the"]<>␤[rx/^$_$$/, rx/^$_$$/, rx/^$_$$/, rx/^$_$$/]<>␤»

[23:08] <shinobi-cl> so, all the elements on @rx has /^$_$$ /

[23:08] <ShimmerFairy> raiph: well, "potential difficulties" are for worries, SORRY! is for sorrows (and worries we end up being sorry for), as far as I understand src/Perl6/ :)

[23:08] <ShimmerFairy> .oO("Potential difficulties: forgot one kind of compile-time message.")

[23:08] <shinobi-cl> r: my Str @s =<Hello to the World>; my @t = <Hello Mars - the red planet>; my @rx = map({rx/^$_$$/}, @s); my @results = @s.flatmap( { rx/^$_$$/ ); say @results.perl; say @rx.perl;

[23:08] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> 3; my @results = @s.flatmap( { rx/^$_$$/ 7⏏5); say @results.perl; say @rx.perl;␤    expecting any of:␤        statement end␤        statem…»

[23:09] <shinobi-cl> r: my Str @s =<Hello to the World>; my @t = <Hello Mars - the red planet>; my @rx = map({rx/^$_$$/}, @s); my @results = @s.flatmap( { rx/^$_$$/ } ); say @results.perl; say @rx; 

[23:09] <camelia> rakudo-{moar,jvm} a32c14: OUTPUT«[rx/^$_$$/, rx/^$_$$/, rx/^$_$$/, rx/^$_$$/]<>␤rx/^$_$$/ rx/^$_$$/ rx/^$_$$/ rx/^$_$$/␤»

[23:11] <raiph> .oO ( presumably sorries can not be reduced to mere worries but worries may (one day) be promotable in a scope to sorries )

[23:11] <ShimmerFairy> raiph: 'use fatal' is a quick way to make rakudo sorry for any worries :) (might as well be 'use Werror' :P)

[23:12] <geekosaur> .oO { use mere-annoyance; }

[23:14] <raiph> ShimmerFairy: nice

[23:16] * ShimmerFairy loves that <.cry_sorrows> is a method that appears in the Perl 6 grammar :P

[23:17] *** virtualsue joined
[23:17] <ShimmerFairy> raiph: I was working out some tests the yesterday (need to get back to them), and before I figured out a way to test something without another eval- test, I wrote it so that a redeclaration warning was success, using 'use fatal' and eval-dies-ok :)

[23:18] * raiph loves to be around folk who love that cry_sorrows is a method in core

[23:18] <raiph> ShimmerFairy: :)

[23:19] <ShimmerFairy> raiph: I love cry_sorrows because at the same time you'd never expect to see that in code (much less typically-"serious business" compiler code), and yet it makes perfect sense :P

[23:19] <raiph> .oO ( let's not mention out loud that cry_sorrows isn't cry-sorrows ... )

[23:19] *** RabidGravy left
[23:20] <ShimmerFairy> I'd be fine with that, less so if it were a yelling kebab :)

[23:20] <raiph> :)

[23:22] <japhb> Is there a (clean, idiomatic) way to specify that you only want to pass an argument if it is defined (or definite, either will do for this case)?

[23:23] <japhb> The use case is for a middle-layer method with an optional argument, that wants to pass that argument on to the lower layer iff it was specifically supplied by the upper layer caller, because if not, the lower layer's defaults should kick in.

[23:24] * japhb wonders if there is something like :?$foo

[23:25] <ShimmerFairy> japhb:  with $optional { lower($args, $optional) } else { lower($args) } ?

[23:25] *** telex left
[23:26] *** telex joined
[23:26] <TimToady> lower($args, |($_ with $optional)) maybe

[23:26] <TimToady> lower($args, |($optional // Empty)) maybe

[23:26] <ShimmerFairy> I was think a 'with' modifier in the arglist, but wasn't sure if that would/could work.

[23:27] <diakopter> oy

[23:27] <japhb> ShimmerFairy: Yeah, I'm doing something similar to what you did, but was hoping for something a little more in the DRY spirit

[23:27] <raiph> diakopter: yo

[23:27] <japhb> TimToady: Oooh, that may well work.

[23:28] <ShimmerFairy> yeah, one of TimToady's suggestions should work

[23:28] <japhb> What would be the equivalent for a named arg?

[23:28] <japhb> o/ diakopter 

[23:29] <ShimmerFairy> m: sub foo(:$bar) { say $bar }; foo(); foo(:bar(5)); foo( |(:bar(42)) )

[23:29] <camelia> rakudo-moar a32c14: OUTPUT«(Any)␤5␤42␤»

[23:29] <raiph> m: sub foo (:$foo = 42) { say $foo }; foo |(Empty)

[23:29] <camelia> rakudo-moar a32c14: OUTPUT«42␤»

[23:32] *** virtualsue left
[23:34] <japhb> m: sub lower(:$bar = 12) { say $bar }; sub middle (:$bar) { lower(|(:$bar with $bar)) }; middle(); middle(42); 

[23:34] <camelia> rakudo-moar a32c14: OUTPUT«12␤Too many positionals passed; expected 0 arguments but got 1␤  in sub middle at /tmp/GUGLLucSxd:1␤  in block <unit> at /tmp/GUGLLucSxd:1␤␤»

[23:34] <japhb> m: sub lower(:$bar = 12) { say $bar }; sub middle (:$bar) { lower(|(:$bar with $bar)) }; middle(); middle(:bar(42)); 

[23:34] <camelia> rakudo-moar a32c14: OUTPUT«12␤42␤»

[23:35] <japhb> Still a little WET, but way better than my original

[23:45] <ShimmerFairy> japhb: you could use $_ in that with, but I think :bar($_) would be more characters in this case :P

[23:50] <Sgeo> m: Hopefully this, is totally! garbage meaningless comile time syntax

[23:50] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/zvuYUtl2yz␤Negation metaoperator not followed by valid infix␤at /tmp/zvuYUtl2yz:1␤------> 3Hopefully this, is totally!7⏏5 garbage meaningless comile time syntax␤    expecting any of:␤        inf…»

[23:50] <Sgeo> Huh. So that message before wasn't compile time?

[23:51] *** llfourn joined
[23:52] <geekosaur> if it doesn't start with "===SORRY!=== Error while compiling ", it's not compile time

[23:53] <Sgeo> m: sub foo(Int $x) { say $x; }; my $f = "Hi!"; foo $f;

[23:53] <camelia> rakudo-moar a32c14: OUTPUT«Type check failed in binding $x; expected 'Int' but got 'Str'␤  in sub foo at /tmp/ishCuGoXZI:1␤  in block <unit> at /tmp/ishCuGoXZI:1␤␤»

[23:53] <Sgeo> So what can trigger static type checking?

[23:53] <geekosaur> not sure static type checking is much implemented currently?

[23:53] * japhb goes to run his updated code and realizes he needs a new Rakudo to use 'with'  :-)

[23:53] <geekosaur> it's intended at some point

[23:54] <japhb> m: sub foo(Int $n) { say $n * $n }; foo(9); foo("bar");

[23:54] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/GpJe7qnN7O␤Calling foo(str) will never work with declared signature (Int $n)␤at /tmp/GpJe7qnN7O:1␤------> 3ub foo(Int $n) { say $n * $n }; foo(9); 7⏏5foo("bar");␤»

[23:54] <japhb> Sgeo: ^^

[23:54] <Sgeo> So just with literals right now?

[23:55] <japhb> Sgeo: In Rakudo, static type checking is a side effect of the optimizer trying to do type proofs and failing.

[23:55] <japhb> So in Rakudo, you currently only get it for things the optimizer understands.

[23:56] <japhb> This is not intrinsic to the language, nor necessarily the future of Rakudo.

[23:56] <Sgeo> Ah

[23:56] *** llfourn left
[23:56] <japhb> It's just the way it currently works.

[23:57] <japhb> Sgeo: Actually, that's not quite true, as it's a subset of the stuff Rakudo gets right.

[23:58] <japhb> You will also get it for assignment to typed scalars, where the RHS is guaranteed not to match the scalar's type constraint.

[23:59] <japhb> And of course at runtime there's a lot of type checking.

