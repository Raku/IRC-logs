[00:03] *** SquireOfGothos joined
[00:04] *** dmitri joined
[00:05] *** jjido left
[00:08] <Sgeo> Will someone eventually accidentally do something like @foo[$_-1] ?

[00:08] <Sgeo> (Where {} around tha expression would presumably make it work)

[00:09] <Sgeo> (The $_-1 I mean)

[00:09] <Sgeo> I think I'd like $_ more if it was more like $^a

[00:09] <Sgeo> I saw a Perl5 vs Perl6 comparison thing, did $a have special meaning in P5?

[00:10] <dmitri> Sgeo, yes $a is special

[00:10] <yoleaux> 2 Aug 2015 12:01Z <smls> dmitri: For .pm files, you can assume it's Perl 5 by default, and only Perl 6 if the first non-comment line starts with one of:    use v6    unit    module   class

[00:10] <geekosaur> $a and $b are magic, yes

[00:10] <Sgeo> dmitri, what does it do?

[00:11] <geekosaur> they're always package variables, predeclared, because sort puts the items passed to the comparison function in $a and $b

[00:11] <geekosaur> not as parameters

[00:11] <dmitri> Sgeo, what geekosaur said

[00:11] <geekosaur> (an optimization going way back in perl history()

[00:11] *** gfldex_ is now known as gfldex

[00:11] <dmitri> yoleaux: That's not always the case, though.  I added a special taster to ctags that can figure this out.

[00:11] <geekosaur> basically perl did not build a stack frame for the comparison function, so no way to pass parameters normally

[00:12] <dmitri> Speaking of ctags, it now supports Perl 6

[00:12] <geekosaur> that should have been directed to smls, not the bot :)

[00:12] <dmitri> heh

[00:12] <geekosaur> ...maybe via .tell

[00:12] <dmitri> smls: That's not always the case, though.  I added a special taster to ctags that can figure this out.

[00:13] <Juerd> geekosaur: They're not always package variables. In fact, if you do "my $a;", and then use sort { ... $a ... }, it's not accessing the package variable $a, but the lexical one, and the sorting doesn't do what you want. A warning is emitted.

[00:13] <geekosaur> yeh

[00:13] <geekosaur> it's ugly

[00:13] <Juerd> It's not as ugly as it could have been :)

[00:13] <geekosaur> (it also predates my variables, so not surprising that things misbehave in that case)

[00:14] *** SquireOfGothos left
[00:14] * geekosaur reminded of the bad old days with local. yeurccccchhh

[00:15] <Juerd> It's more like there's an implicit "our ($a, $b);" at the beginning of your file.

[00:15] *** cognominal left
[00:15] <Juerd> geekosaur: local is *great* for what it does, not so much for being a lexical-ish thing.

[00:16] <dmitri> a few years ago I was writing lots of shell scripts

[00:16] <dmitri> I grew to love dynamic scoping

[00:16] <geekosaur> yes, but in perl 3 local was all we had!

[00:17] <Juerd> dmitri: In Perl 6, dynamic scoping is done with "temp".

[00:17] <dmitri> perl 3...  is perl 6 twice as good? :)

[00:17] <Sgeo> I thought dynamic was done with $* ?

[00:18] <Juerd> Hm, I guess two different things are both called dynamic scoping in my head.

[00:18] <geekosaur> which part is dynamic? :)

[00:19] <Juerd> m: my $foo = "foo"; { temp $foo = "bar"; $foo.say; }; $foo.say

[00:19] <camelia> rakudo-moar 720090: OUTPUT«bar␤foo␤»

[00:20] <Juerd> m: my $*foo = "foo"; { $*foo = "bar"; $foo.say; }; $foo.say

[00:20] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KnpcPCZYzX␤Variable '$foo' is not declared. Did you mean '$*foo'?␤at /tmp/KnpcPCZYzX:1␤------> 3my $*foo = "foo"; { $*foo = "bar"; 7⏏5$foo.say; }; $foo.say␤»

[00:20] <Juerd> m: my $*foo = "foo"; { $*foo = "bar"; $*foo.say; }; $*foo.say

[00:20] <camelia> rakudo-moar 720090: OUTPUT«bar␤bar␤»

[00:20] <Juerd> m: my $*foo = "foo"; { my $*foo = "bar"; $*foo.say; }; $*foo.say

[00:20] <camelia> rakudo-moar 720090: OUTPUT«bar␤foo␤»

[00:20] <ShimmerFairy> Juerd: unless I'm mistaken, in Perl 6 "dynamic scoping" refers to scoping according the the chain of callers (instead of outers), and has nothing to do with 'temp' :)

[00:20] <Juerd> m: my $*foo = "foo"; sub x { $*foo.say }; { my $*foo = "bar"; x; }; x;

[00:20] <camelia> rakudo-moar 720090: OUTPUT«bar␤foo␤»

[00:21] <geekosaur> yes, they're two different kinds of "dynamic"

[00:21] <Juerd> m: my $foo = "foo"; sub x { $foo.say }; { temp $foo = "bar"; x; }; x;

[00:21] <camelia> rakudo-moar 720090: OUTPUT«bar␤foo␤»

[00:21] <Juerd> These features can be used to achieve the same effect. I don't know when you'd pick which.

[00:22] <ShimmerFairy> m: sub x { $*foo.say }; { my $*foo = "bar"; x; }

[00:22] <camelia> rakudo-moar 720090: OUTPUT«bar␤»

[00:22] <ShimmerFairy> m: sub x { $foo.say }; { temp $foo = "bar"; x; }

[00:22] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EZ3JiPqnjL␤Variable '$foo' is not declared␤at /tmp/EZ3JiPqnjL:1␤------> 3sub x { 7⏏5$foo.say }; { temp $foo = "bar"; x; }␤»

[00:23] <geekosaur> I feel like $* is for control structures and temp is for automatic saving and restoring of values

[00:23] <ShimmerFairy> Juerd: ^ that's a situation where you need $* vars

[00:23] <Juerd> Jargon is definitely an issue here: in Perl 5, "dynamic scope" is associated with "local", and in Perl 6, "temp" is documented to be like Perl 5 "local", but "dynamic scope" is something else.

[00:23] <ShimmerFairy> (I see the 'temp' keyword for "temporary" things more than dynamic scoping ☺)

[00:24] <Juerd> Through Perl 5, "temp" is also associated with the term "dynamic scope".

[00:25] <ShimmerFairy> Juerd: $* vars show up in regexes a lot in my experience, and I believe it's precisely because of the way they can quickly nest in complex ways; it lets you carry info through sub-rules, instead of through inner scopes like lexicals.

[00:25] <ShimmerFairy> (keep in mind I could be wrong, I'm not too well-versed in dynamic variables. This is just what I've picked up over the years.)

[00:26] <Juerd> A shared lexical with use of temp would do the same thing. Only it requires a code layout that has everything in the same file.

[00:27] <Juerd> But you could use a global thing and temp, and then I don't really see much difference between the two anymore.

[00:27] <ShimmerFairy> IIRC dynvars also carry into the action methods called by the grammar, which is really nice.

[00:27] <Juerd> I know nothing about grammars yet.

[00:27] <Juerd> Or, more precisely: s/yet/anymore/

[00:28] *** shinobi-cl joined
[00:28] <shinobi-cl> hi all...

[00:28] <Juerd> Hello ShimmerFairy 

[00:28] <Juerd> Argh, shi<tab> :(

[00:28] <Juerd> Sorry, ShimmerFairy and shinobi-cl 

[00:28] <Juerd> Hello shinobi-cl 

[00:28] <shinobi-cl> Hi Juerd

[00:28] <shinobi-cl> is there a way to pass a regex as a parameter to a sub?

[00:29] <Juerd> Yes.

[00:29] <Juerd> m: sub foo ($re) { $re.perl.say }; foo(/bar/);

[00:29] <camelia> rakudo-moar 720090: OUTPUT«/bar/␤»

[00:29] <ShimmerFairy> Juerd: admittedly, there's also something nice about how $*SPECIAL_INFO looks for information you pass down through calls :3

[00:30] * Juerd should really spend a week, maybe more, relearning Perl 6

[00:31] <Juerd> I've learned Perl 6 too early and haven't kept up.

[00:32] <Juerd> Wrote hypothetical Perl 6 code in 2002, never wrote anything more than a oneliner with real Perl 6.

[00:33] <Juerd> Still should try how much of http://www.perlmonks.org/?node_id=179755 would work in real life. I expect a lot of rewriting to be necessary.

[00:38] <ShimmerFairy> Juerd: first, there was a time when P6 regexes still looked P5-ish!? O_o (the (?: ... ) is what I noticed). And second, I happen to have an XML 1.1 parser in P6 I wrote not too long ago, I could gist it if you were interested. :)

[00:39] <skids> Well, similar stuff wored well enough for the Grammar::BNF package and ruoso's (not ecosystem yet) Grammar::EBNF package.

[00:39] <skids> *worked

[00:41] * skids should make sure BNF is still working

[00:41] <shinobi-cl> r: my @a = <1 2 3 4 45 6>; sub regx(Regex $search) { @a.match($search); }; my $x = rx/4.*/; say regx($x);

[00:41] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«｢4 45 6｣␤»

[00:42] <shinobi-cl> i love perl6

[00:43] <shinobi-cl> r: my @a = <1 2 3 4 45 6>; sub regx(Regex $search) { @a.match($search); }; my $x = "4.*"; say regx($x);

[00:43] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«Type check failed in binding $search; expected 'Regex' but got 'Str'␤  in sub regx at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[00:43] <shinobi-cl> r: my @a = <1 2 3 4 45 6>; sub regx(Str $search) { @a.match($search); }; my $x = "4.*"; say regx($x);

[00:43] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«Nil␤»

[00:43] <shinobi-cl> r: my @a = <1 2 3 4 45 6>; sub regx(Str $search) { @a.match($search); }; my $x = "4"; say regx($x);

[00:43] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«｢4｣␤»

[00:44] <ShimmerFairy> .tell jnthn I'm curious on your thoughts on the Stringy and Unicodey roles as mentioned in S15, I'd like to see them fleshed out finally :)  (I have this S32::Str potential rewrite from some while ago featuring the two roles, if it helps: https://gist.github.com/lue/9941658 )

[00:44] <yoleaux> ShimmerFairy: I'll pass your message to jnthn.

[00:44] *** mjgardner joined
[00:45] <Juerd> ShimmerFairy: No, (?:...) has not existed in Perl 6 regexes as far as I know. That part is Perl 5 :)

[00:46] <geekosaur> not spelled that way

[00:46] <ShimmerFairy> Juerd: I didn't know P5 had rule foo { } back then, then :)

[00:46] <geekosaur> but afaik it was always [] in p6

[00:46] <Juerd> ShimmerFairy: What I meant was, I wrote Perl 5 code in Perl 6.

[00:47] <Juerd> ShimmerFairy: That's the kind of mistakes one makes if there's no parser to tell you you're way off.

[00:47] <ShimmerFairy> Juerd: ah, so that (?: ) in "rule xml :i {" was a mistake in typing? I understand :)

[00:47] <Juerd> ShimmerFairy: Note that the *generated* P6 does have [] instead of (?:...)

[00:47] <ShimmerFairy> (though there's always :P5 ... :P)

[00:48] *** laouji joined
[00:48] <Juerd> ShimmerFairy: Also note that in the second part of the code that does (?:) in Perl 6, I did fix it... So at some point I must have known that it was wrong.

[00:48] <ShimmerFairy> Juerd: interestingly, the (?: ) only appear in your singleton alternation; the <foo>bar</foo> alternation uses [] :)

[00:49] <Juerd> That

[00:49] <geekosaur> habits are hard to break?

[00:49] <Juerd> Now... should I edit a post from 2002 or leave it be...

[00:49] <ShimmerFairy> esp. in 2002 with no P6 implementation, I'd guess :)

[00:49] <ShimmerFairy> Juerd: depends on how obvious it is that it comes from 2002 and the land of no implementation.

[00:49] <Juerd> ShimmerFairy: Pretty obvious.

[00:51] <ShimmerFairy> Juerd: so I think at most you'd want to add a note at the top that says something like "UPDATE (someday 2015): Just pointing out that this post comes from long before there was even an implementation. Left as-is for historical interest." :)

[00:53] <ShimmerFairy> Juerd: one more thing, about the <!after>s in your code, and your mention that they should be <!before>s: for PITarget, as an example, I specified    token PITarget { <!before :i XML> <Name> }

[00:54] <ShimmerFairy> (I do recall there were parts of the EBNF grammar I couldn't quite grok, so there were a couple spots where I just went with my best guess. An EBNF converter would do better than me in those spots, I'd imagine :P)

[00:55] *** kst joined
[00:55] <Juerd> I remember that PITarget is weird because the EBNF and the description disagree. The EBNF treats the letters individually, whereas the description only mentioned XML and xml.

[00:56] <Juerd> ShimmerFairy: Rewriting things as <!before ...> is really hard, though.

[00:57] <Juerd> Perhaps Perl 6 just needs something like EBNF's - operator.

[00:57] <ShimmerFairy> yeah, :i XML was simply a shorter way of writing something like <[Xx]> <[Mm]> <[Ll]> (so I went with the grammar's description)

[00:57] <Juerd> - is used in two completely different ways in EBNF by the way

[00:58] <Juerd> foo - bar sometimes means that foo shouldn't match bar anywhere in it, whereas in other occasions it's anchored to whatever foo matched.

[00:59] <ShimmerFairy> Juerd: I couldn't understand the  <foo>* - (<foo>* <bar> <foo>)  stuff, looking at the spec again.

[00:59] *** yqt left
[00:59] <ShimmerFairy> (oops, <foo>* for the last one too)

[00:59] <Juerd> That's the version with implicit anchoring

[01:00] <Juerd> So it allows any number of <foo>, where none of the <foo> is <bar>.

[01:00] <Juerd> It's unclear whether this should fail the entire subrule, or just stop whenever bar is encountered.

[01:01] <Juerd> Off to bed. Good localtime!

[01:01] <ShimmerFairy> CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)    for instance I turned into    token CharData { [<!before "]]>"> <-[<&]>]* }

[01:01] <ShimmerFairy> ♞ Juerd o/

[01:03] <ShimmerFairy> looking at those "implicit anchoring" things, it seems to me like it's just a way of saying "stop when you see this", and not a case for failure (unless you can/want to let backtracking handle that stuff)

[01:03] <ShimmerFairy> So I think I was right in using <!before> like I showed above :)

[01:04] <Juerd> Please put whitespace inside of []. Makes it much easier to read, especially in this case :)

[01:04] <Juerd> I think you're right too.

[01:05] <Juerd> afk!

[01:05] <ShimmerFairy> Juerd: sure, I think most of my rules are more readable than that btw :)

[01:15] <skids> m: ("a","b")>>.chars.say; ("a","b")>>.ords.say

[01:15] <camelia> rakudo-moar 720090: OUTPUT«1 1␤97 98␤»

[01:15] <skids> hrm, that's broken locally.

[01:16] <TimToady> broken how?

[01:16] <skids> The second one gives an empty list.

[01:17] <b2gills> m: my \if = "hello"; say '', if if if;

[01:17] <camelia> rakudo-moar 720090: OUTPUT«hello␤»

[01:17] <b2gills> m: my \if = "hello"; say if if if;

[01:17] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EEuUJAePmt␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/EEuUJAePmt:1␤------> 3my \if = "hello"; say7⏏5 if if if;␤»

[01:17] <skids> (or, ((), ()) to be exact)

[01:18] <skids> I only have one very unrelated mod in my codebase...

[01:19] <TimToady> m: my \if = "hello"; say (if) if if;

[01:19] <camelia> rakudo-moar 720090: OUTPUT«hello␤»

[01:20] <TimToady> the check for bare say is looking for terminators there, and 'if' is a terminator

[01:20] <TimToady> (as are any statement modifiers)

[01:20] <b2gills> You mean it looks like the terminator of the same name

[01:20] <TimToady> right

[01:21] <TimToady> just as if you'd said say;

[01:21] <TimToady> m: my \if = "hello"; say for if if;

[01:21] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/kct0GkcdLN␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/kct0GkcdLN:1␤------> 3my \if = "hello"; say7⏏5 for if if;␤»

[01:24] * skids tries to find the more detailed thing like $*PERL

[01:24] *** rmgk_ joined
[01:24] *** rmgk left
[01:24] *** rmgk_ is now known as rmgk

[01:28] *** mjgardner left
[01:28] <skids> Oh hah.  $*PERL.gist--;

[01:30] <geekosaur> you wanted .perl?

[01:31] <skids> yeah it hid itself from me.

[01:31] <geekosaur> just one of those things you have to remember, .gist is often a short version

[01:31] <skids> yeah.

[01:32] <geekosaur> (not surprising to me given what "gist" means...)

[01:32] *** mjgardner joined
[01:33] * skids wonders why my version has dots and camelias doesn't (7200905 versus 6.c.3.d.63.b)

[01:33] <skids> OK my moar is newer.

[01:35] <skids> Heh.  $*PERL.Str is even shorter than .gist.

[01:36] <geekosaur> ...and after you said that, I was expecting just "6" or "6.0"

[01:36] <b2gills> m: say ~$*PERL

[01:36] <camelia> rakudo-moar 720090: OUTPUT«Perl 6␤»

[01:38] <TimToady> it puts dots in where there are letters, 7200905 has no letters

[01:40] <zostay> so, i've updated the P6SGI spec to v0.2.Draft, includes a number of typo fixes and small errors

[01:41] <zostay> i've made the major change of requiring Promise to be used in all cases... this, however, does break all existing implementations of PSGI-like servers and apps in Perl 6

[01:42] <zostay> i have not yet addressed the Channel versus Supply bit yet

[01:42] <zostay> that will require a bit more thought and research.... i'm leaning toward Supply's but they are so flexible it is difficult to see a clear way to a solution

[01:44] *** ButterBalls joined
[01:44] <ButterBalls> dSo.

[01:45] <ButterBalls> So....

[01:45] <ButterBalls> Perl6 can run in a different languages interpreter when compiled...?

[01:45] <ButterBalls> IE: .net, JVM, Dalvik

[01:45] <skids> JVM yes, not the others yet.  Well mono if you count older neicza.

[01:46] <ButterBalls> So perl6 threw away the crappy interpreter that 5 had in favour of a well built one by Oracle?

[01:47] <ButterBalls> Does this mean multithreading wont suck anymore?

[01:47] <skids> Yes it is a ground-up rewrite.  And multithreading is a top priority.

[01:48] <ButterBalls> I just learned perl5 last year.

[01:48] <ButterBalls> I do want to talk about the implications this will have.

[01:49] <ButterBalls> By using the JVM the userbase will be much bigger but when that happens malicious programs are wrote in these languages. Perl6 wont be an exception thanks to it's amazing file API's

[01:49] <ButterBalls> O

[01:49] <ButterBalls> I

[01:49] <ButterBalls> I'm just trying to understand why the JVM?

[01:49] <gfldex> because jnthn++ had experience with that vm

[01:50] <skids> Neither has Perl 5 been an exception to that, considering it used to e te primary language holding evrything together.

[01:50] <ButterBalls> >so is a loose precedence operator that coerces to Bool. The logical opposite of not, it returns a Bool with a preserved boolean value instead of the opposite one.

[01:50] <gfldex> he seams to like moarvm better now tho

[01:50] <ButterBalls> I am in love.

[01:50] <ButterBalls> my god.

[01:51] <ButterBalls> Perl6 has some great choices but I don't agree with all of them.

[01:51] <geekosaur> I would imagine that given jvm support, clr support would not be that difficult (famous last words...)

[01:51] <skids> .oO(OK so my issue is not the moarvm version... maye NQP.)

[01:52] <ButterBalls> geekosaur, I would imagine that Dalvik and it's RT library would be used just like Java's

[01:52] <ButterBalls> Imagine it.

[01:52] <ButterBalls> Perl6 on Android.

[01:52] <ButterBalls> No extra interpreter needed.

[01:52] <ButterBalls> I must ask the important question now. Does perl6 support perl5 regex's?

[01:53] <skids> Through an adverb on rx//, yes.

[01:54] <skids> m: say "aa" ~~ m:P5/a(?:a)/

[01:54] <camelia> rakudo-moar 720090: OUTPUT«｢aa｣␤»

[01:54] <ButterBalls> Forgot to add, will perl5 scripts work fine in perl6?

[01:55] <skids> Some of them, using Inline::Perl5

[01:55] <b2gills> You may be able to write a small program that will work in both, Perl 5 and Perl 6 but it won't be worth it

[01:56] <ButterBalls> It would.

[01:56] <ButterBalls> I normally do my development in Java.

[01:56] <ButterBalls> Write once, deploy everywhere.

[01:56] <ButterBalls> (I never tie to system dependant behaviours)

[01:56] <b2gills> The differences between Perl 5 and Perl 6 are about as different as the difference between C and D

[01:57] <b2gills> *C++ and D

[01:57] <ButterBalls> M: say "hi"

[01:57] <ButterBalls> blargh

[01:57] <ButterBalls> why

[01:57] <b2gills> lowercase m

[01:57] <ButterBalls> Why name it perl then?

[01:57] <ButterBalls> Why not something like Perl2

[01:57] <gfldex> because it stole not just the name from perl 5

[01:57] <ButterBalls> m: say "hi"

[01:57] <camelia> rakudo-moar 720090: OUTPUT«hi␤»

[01:58] <ButterBalls> m: while(so 2/1==2){say ""}

[01:58] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/v24oNmvJHW␤Undeclared routine:␤    while used at line 1␤␤»

[01:58] <shinobi-cl> r: say ((1, 2, 3, 4, 5, 6) ~ (1, 2, 33, 4, 5, 6)) ?? "true" !! "false";

[01:58] <ButterBalls> I was wondering if that would work

[01:58] <gfldex> and when Perl 6 was first discussed it was much closer to Perl 5 then to Perl 6

[01:58] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«true␤»

[01:59] <ButterBalls> What's the point of perl6 if perl5 will continue to be mantained 

[01:59] <ButterBalls> Why not just split off into an entire new version of perl.

[01:59] <b2gills> What's the point when FORTRAN already exists?

[01:59] <ButterBalls> Different purposes

[01:59] <shinobi-cl> r: say ((1, 2, 3, 4, 5, 6) ~~ (1, 2, 33, 4, 5, 6)) ?? "true" !! "false";

[01:59] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«false␤»

[01:59] <gfldex> what's the point of c++ if c is continued to be maintained?

[02:00] <ButterBalls> r say @_; | y

[02:00] <ButterBalls> gfldex, different purposes

[02:00] <skids> ButterBalls: Perl "6" is an entriely new "version" of perl :-)

[02:00] <gfldex> exactly

[02:00] <ButterBalls> r: say @_; | y

[02:00] <camelia> rakudo-{moar,jvm} 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Cannot use placeholder parameter @_ in the mainline␤at /tmp/tmpfile:1␤------> 3say @_7⏏5; | y␤»

[02:00] <ButterBalls> do things like @_ behave like before?

[02:00] <TimToady> sometimes

[02:01] <b2gills> m: sub p5example { say @_ }; p5example 'hello'

[02:01] <camelia> rakudo-moar 720090: OUTPUT«hello␤»

[02:01] <skids> ButterBalls: since you know Perl 5, you may want to start here: http://doc.perl6.org/language/5to6

[02:01] <gfldex> the sane Perl 5 oddities tend to work in Perl 6

[02:02] <ButterBalls> So I assume I have access to the entire JVM RT.jar?

[02:02] <b2gills> m: say (<a b> Xx ^9).perl

[02:02] <camelia> rakudo-moar 720090: OUTPUT«("", "a", "aa", "aaa", "aaaa", "aaaaa", "aaaaaa", "aaaaaaa", "aaaaaaaa", "", "b", "bb", "bbb", "bbbb", "bbbbb", "bbbbbb", "bbbbbbb", "bbbbbbbb")␤»

[02:03] <skids> ButterBalls: I'm not sure where JVM interop is at, implementation-wise.

[02:03] <ButterBalls> "

[02:03] <ButterBalls> Space is required immediately after keywords"

[02:03] <ButterBalls> no.

[02:03] <ButterBalls> just no.

[02:03] <skids> Yep.

[02:03] <ButterBalls> no.

[02:03] <TimToady> there are reasons

[02:03] <ButterBalls> I will write an entire cleaning tool to avoid that.

[02:03] <TimToady> having to do with extensibility

[02:04] <ButterBalls> I will write a tool to prep code so it's valid just to NOT have to add that space.

[02:04] <ButterBalls> my god.

[02:04] <TimToady> that's just silly

[02:04] <TimToady> it's more readable with the space, you're just not used to it

[02:04] <ButterBalls> I am coming from java

[02:04] <TimToady> you can leave out the parens

[02:04] <ButterBalls> while(true) is more common than while (true)

[02:04] <TimToady> while true is more better

[02:05] <ButterBalls> I find the parens help

[02:05] *** dayangkun joined
[02:05] <ButterBalls> (readability wise)

[02:05] <TimToady> not really, if you linebreak nicely

[02:05] <skids> Well, "loop" is better than "while True" :-)

[02:05] <ButterBalls> "$ Scalar

[02:05] <ButterBalls> The $ sigil is now always used with "item" variables (e.g. $name), and no longer for array indexing and Hash indexing. That is, you will still use $x[1] and $x{"foo"}, but you use them on $x, not @x or %x."

[02:06] <ButterBalls> Whoever chose that deserves a pizza.

[02:06] <ButterBalls> $x[<pointer] is something that I love.

[02:06] * TimToady can't eat pizza...

[02:07] <b2gills> That was a **very** early decision from what I've read

[02:07] <ButterBalls> I'm trying to understand "&"

[02:07] <ButterBalls> so $x = &funcname

[02:07] <TimToady> it's now just a noun marker

[02:07] <ButterBalls> Just typing $x will trigger &funcnanme?

[02:07] <b2gills> & is used the same way you would use it in Perl 5 ( for the most part )

[02:07] <skids> Butterballs: no, $x()

[02:08] <b2gills> $x would be a reference to the subroutine ( in Perl 5 speak )

[02:08] <TimToady> just as &foo will not call, but &foo() will

[02:08] <ButterBalls> skids, So I can dynamically assign $x to functions by going $x = &func to call $x() to trigger &func

[02:08] <skids> Yes.

[02:08] <ButterBalls> So $x(params) is valid?

[02:08] <TimToady> sure

[02:08] <TimToady> except we usually call those args

[02:08] <ButterBalls> I am loving perl6

[02:08] <TimToady> and reserve params for the formals

[02:08] <b2gills> m: for &[+], &[-]

[02:08] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/eDUefNJa7P␤Missing block␤at /tmp/eDUefNJa7P:1␤------> 3for &[+], &[-]7⏏5<EOL>␤    expecting any of:␤        block or pointy block␤»

[02:09] <ButterBalls> These little changes make the language much easier to work with

[02:09] <skids> m: my $x = { $_ .say }; $x("hi"); $x = { 42.say }; $x();

[02:09] <camelia> rakudo-moar 720090: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Ceb07PZysG␤Two terms in a row␤at /tmp/Ceb07PZysG:1␤------> 3my $x = { $_7⏏5 .say }; $x("hi"); $x = { 42.say }; $x()␤    expecting any of:␤        infix␤        infix stopper␤        statemen…»

[02:09] <shinobi-cl> how can i generate a list starting with 1, then 4, then 7,...up to 64?

[02:09] <TimToady> m: say 1,4,7...64

[02:09] <camelia> rakudo-moar 720090: OUTPUT«1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64␤»

[02:09] <b2gills> m: for &[+], &[-], &[*] -> &func { say func 4,5 }

[02:09] <camelia> rakudo-moar 720090: OUTPUT«9␤-1␤20␤»

[02:09] <ButterBalls> Perl6 is about concistency isn't it?

[02:09] <gfldex> m: my @a.push(sub {42},sub {43}, sub {44}); say @a>>.();

[02:09] <camelia> rakudo-moar 720090: OUTPUT«42 43 44␤»

[02:10] <skids> m: my $x = { $_.say }; $x("hi"); $x = { 42.say }; $x();

[02:10] <camelia> rakudo-moar 720090: OUTPUT«hi␤42␤»

[02:10] <shinobi-cl> i see.. I was using " .. " :(  Thanks!

[02:10] <skids> ButterBalls: It is "strangely consistent" :-)

[02:10] <TimToady> ButterBalls: there's certainly more consistency than P5

[02:11] <TimToady> but you can't be consistent in all dimensions at once

[02:11] <ButterBalls> so % allows you to call a object from a 2d @ by it's name?

[02:11] <ButterBalls> so @t["apple", "pear"] = qw("good", bad");

[02:11] <ButterBalls> %t["apple"] = "good"?

[02:11] <b2gills> %t{'apple'}

[02:12] <skids> No. @ is only for positionals.

[02:12] <ButterBalls> b2gills, sorry about syntax but the idea is right?

[02:12] <ButterBalls> skids, ok

[02:12] <TimToady> you can slice either arrays or hashes, and either can be multidimensional, but then you use ; instead of ,

[02:13] <ButterBalls> I'm still trying to understand some Syntax changes but it seems to be pretty straight forward

[02:13] <ButterBalls> How is performance?

[02:13] <ButterBalls> Especially for GUI

[02:13] <dalek> rakudo-star-daily: 9b3538e | coke++ | log/ (9 files):

[02:13] <dalek> rakudo-star-daily: today (automated commit)

[02:13] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/9b3538e79d

[02:13] <skids> Really it is the [ and { and ( that decide what happens, more than the $ @ or %

[02:14] <gfldex> performance heavily depends on what you do

[02:14] <ButterBalls> I'm thinking of porting a NES emulator to Perl6

[02:14] <ButterBalls> I want to see how feasble it is.

[02:14] <ButterBalls> (coming from Java)

[02:16] <b2gills> Considering a faithful NES implementation in C/C++ maxes out a modern processor, I wouldn't hold my breath

[02:17] <ButterBalls> b2gills, You think I'm going for perfect hardware accuracy?

[02:17] <ButterBalls> huehuehue

[02:19] <b2gills> In Perl 6 normal operators are subroutines, and subroutines are objects, it will require a smart implementation to make it fast enough for an emulator.

[02:19] <ButterBalls> But to be honest the issue with maxing out the CPU ois due to the overhead of the OS

[02:19] *** mjgardner left
[02:20] <b2gills> It has more to deal with implementing custom ASICs, and a whole other processor in software

[02:20] <ButterBalls> b2gills, I know

[02:20] <TimToady> we're getting faster, but we don't know how fast we'll get eventually

[02:20] <ButterBalls> The issue is timing.

[02:21] <b2gills> I just read an article about it

[02:21] <ButterBalls> I was implimenting a 6502  (the NES custom A02 one) on a Arduino Uno.

[02:21] <skids> Yeah "».ords" broke sometime after NQP 70f65eb.

[02:21] <ButterBalls> The issue was the lack of memory so paralell ram was going to be used.

[02:23] <ButterBalls> Implimeting a proccesor in software is quite simple. Implimenting it's timing isn't.

[02:23] <ButterBalls> Microsoft cheated though.

[02:24] <ButterBalls> FWIU: 360 on One uses a JIT interpreter that hooks every API call and remaps them to the local system API

[02:24] <ButterBalls> The issue though will be that the 360 was cell, not x86.

[02:24] <ButterBalls> Cell is known for it's math capabilities.

[02:25] <ButterBalls> Even to date the proccessor in the ps3 is stupidly fast at math thanks to the PPU's vs x86

[02:25] <ButterBalls> The issue is you can't really write a JIT in Perl

[02:26] *** shinobi-cl left
[02:26] <ButterBalls> b2gills, make sense?

[02:27] <ButterBalls> Instead of interpreting why not boil it down to instructions the host proccessor can simply interpret directly?

[02:27] <ButterBalls> Dolphin does it.

[02:27] <ButterBalls> RPCS3 (that's how you spell it IIRC) does it with PS3 games

[02:29] <b2gills> I'm currently watching TV

[02:30] <ButterBalls> heh

[02:30] <skids> ButterBalls: do you like working on JIT stuff?

[02:30] <ButterBalls> b2gills, TL;DR: JIT = Magic

[02:30] <b2gills> The cell processor did seem to be a very interesting design

[02:31] <ButterBalls> skids, personally no.

[02:31] <ButterBalls> Just studying

[02:32] <skids> Ah.  Well if you want to keep track of moarvm's for study purposes, follow brrt++

[02:32] <skids> http://brrt-to-the-future.blogspot.nl/2015/07/tiles-and-compiler-compilers.html

[02:32] <ButterBalls> I want Perl6 on Android.

[02:33] <ButterBalls> Ideally you shouldn't do a serial multiplication on bigger numbers but break them down to multiple cores to do in paralell

[02:34] <ButterBalls> Well not multiplications but certain pieces of math can be done in parallel much faster

[02:34] <skids> I don't know if dalvik will come first for Android or webassembly.  But for now the goal is at least a MoarVM (and maybe JVM) 6.0 RC by Christmas.

[02:34] <ButterBalls> For now I'll continue to develop with Perl5 and play with Perl6.

[02:35] <ButterBalls> I also use Java, and Python

[02:35] <b2gills> m: say [+] 1..10 # this could be done in parallel

[02:35] <camelia> rakudo-moar 720090: OUTPUT«55␤»

[02:35] <ButterBalls> WebAssembly should be ignored for now.

[02:35] <ButterBalls> It's still to early to call it standardized.

[02:37] <ButterBalls> Right now I'm not sure what to do.

[02:37] <Sgeo> I'm a bit of a language exploration addict, although I can't remember when I wrote anything real with any language :(

[02:37] <ButterBalls> Sgeo, I am a tinkerer.

[02:37] <ButterBalls> If it's wrote in Java I will shred it.

[02:37] <ButterBalls> I want to know what makes it tick.

[02:37] <Sgeo> But I rejected PErl5 but am fascinated by Perl6

[02:38] *** mr-foobar left
[02:38] *** gfldex left
[02:39] <ButterBalls> Perl6 on Debian is slow.

[02:39] <ButterBalls> painfully slow.

[02:39] <Sgeo> I wonder which lens usescases P6 can meet and which ones it might struggle with

[02:41] *** mr-foobar joined
[02:41] <TimToady> ButterBalls: there are several reasons for that, all of which we're hoping to fix in the next month or two

[02:41] *** noganex_ joined
[02:42] <TimToady> well, most of which, anyway

[02:43] <b2gills> Java was slow once too

[02:44] *** noganex left
[02:46] *** ButterBalls left
[02:48] *** ButterBalks joined
[02:49] <ButterBalks> Perl6 hung my computer.

[02:49] <ButterBalks>  /yaaaay/

[02:50] *** dayangkun left
[02:50] *** dayangkun_ joined
[02:50] <ButterBalks> yay

[02:53] <b2gills> I've done that before too

[02:55] <b2gills> It is very easy to create an infinite loop `[+] 0..Inf`

[02:56] *** ButterBalks left
[02:56] <skids> .tell timotimo NQP 808ce0fcb broke ("a","b")».ords for some reason.

[02:56] <yoleaux> skids: I'll pass your message to timotimo.

[03:05] *** kaare_ joined
[03:14] *** TimToady left
[03:16] *** TimToady joined
[03:38] *** pc2046 joined
[03:38] <pc2046> hello

[03:38] <skids> o/

[03:39] *** dayangkun_ left
[03:40] <flussence> .oO( it's funny when someone inadvertently reveals their PHP background, by complaining about any other language for not sharing its "unique" built in memory/runtime limits :)

[03:44] *** nys left
[03:45] *** dayangkun_ joined
[03:51] <b2gills> pc2046: Anything in particular you want to discuss?

[03:52] <TEttinger> pearl earrings

[03:52] <TEttinger> perl errings

[03:54] <b2gills> One reason its not spelled with the "a" is there was already a language called Pearl

[03:54] <TEttinger> heh

[03:54] <TEttinger> Praal

[03:55] <TEttinger> Purl, Pirl, Purrel

[03:57] <TEttinger> purr wouldn't be a bad name for a convenience library in perl. but I've been watching too much of these darn kitten cams http://livestream.com/tinykittens/tip

[03:58] <TEttinger> then again, that implies there's something that perl needs a convenience library for

[03:59] <pc2046> I have developed perl project for more than 10 years, one technique that I adopt is store all perl processes and components into database, evaluate them and parse the result to the main for display, I am not sure if perl 6 would affect my component based evaluation type of programming

[04:01] <pc2046> originally, I want to have central big business-core server/platform, that every perl projects can just reference to the correct version from the central server, either with assign version or upgrade version

[04:01] <pc2046> I think to store "pm" on every server is a quite old-fashioned

[04:05] <pc2046> say, old way is: use ABC::def;   new way could be just use 123.123.123.123::ABC::def {v=1,update_local=false};

[04:10] <skids> pc2046: you should probably be able to make a custom CompUnitRepo that uses your database.

[04:12] <pc2046> that is a very good idea

[04:12] <ugexe> thats cloudpan

[04:14] <skids> pc2046: http://design.perl6.org/S11.html and http://design.perl6.org/S22.html are the design docs for packaging.  More of S11 is actually implemented than S22 yet.

[04:18] <pc2046> Skids, your information is useful.

[04:39] *** skids left
[05:01] *** schmooster joined
[05:15] *** pc2046 left
[05:26] *** mr-foobar left
[05:33] *** xinming joined
[05:44] *** rurban joined
[05:53] *** diana_olhovik_ joined
[06:03] *** AlexDaniel left
[06:11] *** araujo joined
[06:11] *** araujo left
[06:11] *** araujo joined
[06:13] *** jjido joined
[06:23] *** oetiker left
[06:24] *** oetiker joined
[06:25] *** gfldex joined
[06:25] *** rurban_ joined
[06:27] *** llfourn joined
[06:41] *** rurban left
[06:42] *** rurban joined
[06:57] *** domidumont joined
[07:00] *** ShimmerFairy left
[07:01] *** domidumont left
[07:02] *** domidumont joined
[07:06] *** telex left
[07:07] *** jjido left
[07:07] *** FROGGS joined
[07:08] *** telex joined
[07:11] *** llfourn left
[07:13] *** ShimmerFairy joined
[07:17] *** darutoko joined
[07:19] *** yeahnoob joined
[07:21] *** labster left
[07:26] *** domidumont left
[07:33] *** mr-foobar joined
[07:44] *** mrf joined
[07:49] <dalek> rakudo/nom: 1c76b58 | TimToady++ | src/Perl6/Grammar.nqp:

[07:49] <dalek> rakudo/nom: Parse with/without as either control or modifier

[07:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c76b58e5d

[07:49] <dalek> rakudo/nom: b620a37 | TimToady++ | src/ (3 files):

[07:49] <dalek> rakudo/nom: implement with/without modifiers

[07:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b620a37837

[07:49] <dalek> rakudo/nom: 2623525 | TimToady++ | src/ (4 files):

[07:49] <dalek> rakudo/nom: get new orelse/andthen to do assignops

[07:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2623525178

[07:50] <TimToady> note that the statement control with/without are still just testing boolean

[07:51] <FROGGS> o/

[07:51] *** RabidGravy joined
[07:51] <TimToady> the statement modifiers are testing definedness, but still need to topicalize non-block expressions

[07:52] <TimToady> jobs for tomorrow...

[07:52] * TimToady --> sleep &

[07:53] *** yeahnoob left
[07:54] *** mr-foobar left
[08:04] <jdv79> nice

[08:10] *** llfourn joined
[08:11] *** rurban left
[08:14] *** rurban joined
[08:15] *** domidumont joined
[08:16] *** rindolf joined
[08:17] *** laouji left
[08:18] *** laouji joined
[08:21] *** domidumont left
[08:22] *** laouji left
[08:22] *** laouji joined
[08:24] <nwc10> top entry currently on http://planetpython.org/ is "Python 4 Kids"

[08:24] <nwc10> I misparsed that the first time.

[08:29] *** brrt joined
[08:38] <jnthn> Yes, that parses two ways... :)

[08:38] <yoleaux> 00:44Z <ShimmerFairy> jnthn: I'm curious on your thoughts on the Stringy and Unicodey roles as mentioned in S15, I'd like to see them fleshed out finally :)  (I have this S32::Str potential rewrite from some while ago featuring the two roles, if it helps: https://gist.github.com/lue/9941658 )

[08:41] <nwc10> jnthn: is it Friday?

[08:41] <nwc10> how about now?

[08:41] <nwc10> :-)

[08:41] <RabidGravy> it is now

[08:42] <nwc10> oh gosh, I'm almost halfway to POETS

[08:43] <jnthn> nwc10: Well, going to take on lazy/eager/hyper/race at least somewhat first.

[08:44] *** rurban left
[08:44] *** [Tux] joined
[08:45] *** rurban joined
[08:57] <RabidGravy> nwc10, or we could arbitrarily define beer o'clock as 12 and you're almost done ;-)

[08:57] <nwc10> that late? :-)

[08:57] *** espadrine left
[09:00] <jnthn> The term "known infinite" is now resting. Updated everywhere that matters in https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 to talk about an iterator considering itself lazy instead

[09:03] <sergot> oh hai #perl6 \0

[09:04] <jnthn> o/ sergot 

[09:08] <RabidGravy> erp

[09:13] *** Sqirrel left
[09:13] *** [Tux] left
[09:14] <jnthn> yay, my lazy impl worked first time

[09:14] <jnthn> Working out a nice really simple test case for lazy was fun

[09:14] <jnthn> Turns out that the best one is:

[09:14] <RabidGravy> nwc10, as a further inducement it's International Beer Day

[09:14] <jnthn> my @a = 1, 2;

[09:14] <jnthn> my @b = lazy @a;

[09:14] <jnthn> say @b[0]; # 1

[09:14] <jnthn> @a[1] = 42;

[09:14] <jnthn> say @b[1]; # 42

[09:15] <jnthn> Becuase lazy means we don't actually copy from @a until we really need to

[09:15] *** virtualsue joined
[09:15] *** Sqirrel joined
[09:15] <jnthn> Note that it's not binding, still assignment, so:

[09:15] <jnthn> @a[1] = 0;

[09:15] <jnthn> say @b[1]; # 42 still, 'cus the bondage is broken once the assignment gets done

[09:16] <jnthn> I...guess I can't wait to see what evil people actually do with these semantics :P

[09:16] <ShimmerFairy> jnthn: looks nice. I'd hope that in most cases it's not unobvious where 'lazy' things come up :)  (though I suppose there's always the possibility of forcing something to be eager if you're paranoid)

[09:16] <nine> jnthn: that's neat :)

[09:17] <jnthn> ShimmerFairy: The only things that default to lazy are all typically immutable in nature

[09:17] *** aborazmeh joined
[09:17] *** aborazmeh left
[09:17] *** aborazmeh joined
[09:17] <nine> jnthn: not in a strict sense. A file can be changed while one is iterating with lines()

[09:18] *** espadrine joined
[09:21] <jnthn> nine: "in nature" was my get-out clause for that :)

[09:22] <nine> I thought "typically" was ;)

[09:22] <jnthn> Always have backups!

[09:24] <ShimmerFairy> the prudent thing would of course be to do  shell("cp $file $file.mine"); for "$file.mine".lines { }    :P

[09:31] <jnthn> Darn it. I've an off-by-one somewhere...

[09:31] <jnthn> Doing @a[2] actually reifies 4 things, not 3...

[09:34] <jnthn> oh, it was an off-by-reified error...

[09:37] <nwc10> order 1 beer, get 2?

[09:39] <jnthn> Well, if you'd reified two beers first, you'd have ended up with 5 when asking for the third one... :)

[09:39] <jnthn> And I'm not sure "it's happy hour!" is going to fly in RT :P

[09:39] *** brrt left
[09:39] <jnthn> (It got fixed, working on eager now)

[09:40] *** pRiVi joined
[09:40] <dmitri> I am looking for an example of use of "package" keyword in Perl 6, but I cannot find it.

[09:41] <dmitri> Is there some code that says package Foo { ... }??

[09:41] <jnthn> dmitri: We don't tend to use "package" in Perl 6, but rather module/class/grammar

[09:42] <RabidGravy> however the BSON module does use it, I was looking at it yesterday

[09:42] <dmitri> jnthn: I realize that -- this is what the docs say.  However, it seems that it *can* be done.

[09:42] <dmitri> BSON?

[09:42] * dmitri looks

[09:43] <jnthn> dmitri: It can, but you'll not get various bits of conflict detection

[09:43] <jnthn> m: package Foo { }; package Foo { };

[09:43] <camelia> rakudo-moar 262352: ( no output )

[09:43] <jnthn> m: module Foo { }; module Foo { };

[09:43] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gCzZWGWKvb␤Redeclaration of symbol Foo␤at /tmp/gCzZWGWKvb:1␤------> 3module Foo { }; module Foo7⏏5 { };␤    expecting any of:␤        generic role␤»

[09:43] <RabidGravy> but in summary

[09:43] <dmitri> RabidGravy: thank you very much!

[09:43] <RabidGravy> m: package Foo { our $Bar = "hjs" }; say $Foo::Bar

[09:43] <camelia> rakudo-moar 262352: OUTPUT«hjs␤»

[09:45] <dmitri> The reason I am looking for it is that I missed this keyword in ctags parser of Perl 6 and I wanted some examples.  Now I have them.  This is good.

[09:45] <jnthn> Aha :)

[09:48] <RabidGravy> jnthn, isn't that "non-confliction" actually a reason to use it, so you can use it in more than one file for instance?

[09:48] <RabidGravy> though

[09:48] *** spider-mario joined
[09:48] <RabidGravy> m: package Foo { class Bar {} }; package Foo { class Bar {}}

[09:48] <camelia> rakudo-moar 262352: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol Bar␤»

[09:49] <RabidGravy> is a bit odd

[09:49] <jnthn> RabidGravy: Well, we use it for stubbing int he compiler too

[09:50] <jnthn> m: class A::B { }; class A { } # this works since A starts out as a package after the first decl

[09:50] <camelia> rakudo-moar 262352: ( no output )

[09:50] *** virtualsue left
[10:00] *** brrt joined
[10:00] *** virtualsue joined
[10:00] <nwc10> [ptc]: do you happen to know what the ticket price was for Pycon Europe? I can't find it online any more

[10:01] <nwc10> of course I can *now* :-)

[10:02] <nwc10> actually, that's On-Desk rate that I can find. I guess "Standard Rate" was a bit lower than "Personal: EUR 440 (for people enjoying Python from home)"

[10:03] <[ptc]> nwc10: I'll just go check, hang on a tick

[10:07] <[ptc]> nwc10: 255Euro was the normal price (i.e. not the On-Desk or Early Bird tickets)

[10:07] <[ptc]> nwc10: hth

[10:07] <brrt> what does 'On-Desk' refer to?

[10:08] <[ptc]> brrt: when one turns up to the conference without buying tickets online beforehand

[10:08] <brrt> ah, ok

[10:08] <brrt> but they're still pre-selling the tickets? weird...

[10:08] <[ptc]> no, the conference is over

[10:09] <brrt> oh, right :-)

[10:09] *** [Tux] joined
[10:09] <[ptc]> and they stopped selling normal tickets a couple of days before the conference

[10:09] <jnthn> Giving people a strong incentive to buy their ticket before they show up is rather helpful from an organizational perspective. :)

[10:11] <jdv79> is there any way to interp the type name on the LHS of .?

[10:11] <jdv79> my $c = "A"; $c.new kinda thing

[10:14] <jnthn> ::($c)

[10:14] <jnthn> Not just for LHS of .

[10:15] <jdv79> explains why i coudln't find it whtn looking at method calls docs

[10:15] <jdv79> :(

[10:15] <jdv79> thanks!

[10:16] * jnthn actually wrote a test for my $i = 0; my @a = lazy eager loop { last if $i == 5; $i++ }; 

[10:16] <nine> A lazy eager loop?

[10:16] <jnthn> Yeah.

[10:17] <nine> Where's the difference to my @a = lazy [ 0, 1, 2, 3, 4, 5 ];?

[10:17] *** eternaleye joined
[10:17] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 updated with lazy/eager

[10:18] <jnthn> nine: See the comment I wrote above the final test in gist linked above

[10:20] <nwc10> [ptc]: that was the normal business price? (I'm guessing that your work paid for you)

[10:20] *** danstoner joined
[10:21] *** Grrrr joined
[10:22] <nine> Aah...a lazily started eager loop so to speak

[10:22] <RabidGravy> lazy eager is "really likes the idea of doing it, but in reality can't be bothered"

[10:24] <jnthn> "I'm not going to do anything, unless you make me, and then I'll do EVERYTHING just to show you!"

[10:25] *** kaare_ left
[10:31] *** kaare__ joined
[10:31] <RabidGravy> :)

[10:31] <RabidGravy> sounds like me most of the time TBH

[10:31] <jnthn> Mostly I'm glad that the test I wrote did exactly what I expected without having to tweak anything

[10:31] <jnthn> Anyway, I'm happy we have a well-defined meaning of lazy/eager now. I don't know we've had that so clearly before.

[10:31] *** nwc10_ joined
[10:31] <jnthn> OK, hyper and race...these will be hard

[10:31] <jdv79> and awesome!

[10:31] <RabidGravy> m: use NativeCall; class Foo is repr('CStruct') { has CArray[num32] $.foo is rw; } say Foo.new(foo => CArray[num32].new); # is that simply NYI or intentional?

[10:31] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/J_QhMBhHEq␤Strange text after block (missing semicolon or comma?)␤at /tmp/J_QhMBhHEq:1␤------> 3uct') { has CArray[num32] $.foo is rw; }7⏏5 say Foo.new(foo => CArray[num32].new); ␤    expecting an…»

[10:31] <RabidGravy> m: use NativeCall; class Foo is repr('CStruct') { has CArray[num32] $.foo is rw; }; say Foo.new(foo => CArray[num32].new); # is that simply NYI or intentional?

[10:32] <camelia> rakudo-moar 262352: OUTPUT«Cannot modify an immutable NumTypedCArray[num32]␤  in block <unit> at /tmp/upJjqhtPuB:1␤␤»

[10:32] <RabidGravy> rather

[10:32] <jnthn> looks odd to me

[10:32] <RabidGravy> or, at option, a bug

[10:32] * jnthn afk for a bit to do design work on hyper/race

[10:32] *** rurban left
[10:40] <jdv79> lets say I want A.new to return a A::B obj - how?

[10:40] <jdv79> how best i mean

[10:40] <jdv79> in p5 i can just bless into A::B

[10:41] *** [TuxCM] left
[10:42] *** tommi joined
[10:45] *** Sqirrel left
[10:45] *** araujo left
[10:45] *** pyrimidine left
[10:45] *** Woodi_ left
[10:45] *** pecastro left
[10:45] *** ilbot3 left
[10:45] *** Khisanth left
[10:45] *** schmooster left
[10:45] *** silug_ left
[10:45] *** vytas left
[10:45] *** krunen left
[10:45] *** ingy left
[10:45] *** bobkare left
[10:45] *** f3ew left
[10:45] *** freeze left
[10:45] *** vike left
[10:45] *** aborazmeh left
[10:47] *** nwc10_ is now known as nwc10

[10:48] *** [Tux] left
[10:48] *** [Tux] joined
[10:49] *** Sqirrel joined
[10:49] *** araujo joined
[10:49] *** schmooster joined
[10:49] *** pyrimidine joined
[10:49] *** Woodi_ joined
[10:49] *** pecastro joined
[10:49] *** ilbot3 joined
[10:49] *** Khisanth joined
[10:49] *** silug_ joined
[10:49] *** vytas joined
[10:49] *** krunen joined
[10:49] *** ingy joined
[10:49] *** bobkare joined
[10:49] *** f3ew joined
[10:49] *** freeze joined
[10:49] *** vike joined
[10:49] *** krakan joined
[10:49] *** MilkmanDan joined
[10:49] *** felher joined
[10:49] *** slavik joined
[10:49] *** Guest90936 joined
[10:49] *** maddingue joined
[10:49] *** ab5tract_ joined
[10:49] *** mls joined
[10:51] *** hobbified left
[10:51] *** chansen_ left
[10:52] *** hobbs joined
[10:53] *** chansen_ joined
[10:57] *** freeze left
[10:59] *** freeze joined
[11:01] *** Sqirrel left
[11:01] <[ptc]> nwc10: no, that was the personal price

[11:02] <[ptc]> nwc10: I paid 340 for early bird business price, but since work didn't end up paying for me, I converted the ticket into a personal one

[11:02] <nwc10> ah OK thanks. that's doubly useful

[11:03] *** Sqirrel joined
[11:04] *** rurban joined
[11:05] *** danaj joined
[11:07] <jdv79> 'A::B' cannot inherit from 'A' because it is unknown - even with require?

[11:08] *** rurban_ left
[11:09] <jnthn> require is runtime, inheritnace is compile time

[11:11] <jdv79> no way around that?

[11:12] <jnthn> Use "use"?

[11:12] <jnthn> Do the require at BEGIN time?

[11:13] <jdv79> well, the use doesn't work cause its in A

[11:13] <jdv79> that's why i tried require

[11:13] <jnthn> However you slice it, though, the thing you're inheriting from has to be available to the compiler by the time it sees the "is A"

[11:16] <jdv79> hmm, i thought that sort of cycle would be handled well

[11:16] <jnthn> That Perl 6 does one pass parsing goes pretty deep.

[11:17] <jdv79> painfully

[11:17] <jdv79> hope it worth it

[11:17] <jdv79> *its

[11:18] <jnthn> Well, it tends to force you to think out your dependencies better.

[11:18] <itz> [ptc]: *cough* the cricket ;)

[11:18] <jdv79> except it forces architecture patterns but ok

[11:18] <jnthn> On hyper/race, my current thinking is that we're going to need some amount of "contaigous" behavior on it

[11:18] <jdv79> just not as perlish as i'm used to

[11:19] <jdv79> viral ?

[11:19] <jnthn> That is, once you opt in to hyper then things downstream of it will be too

[11:21] <jnthn> my $max = @climate-files.map(&parse).hyper().map(&normalize).grep(*.continent eq 'Europe').max(*.yearly-average);

[11:21] <ShimmerFairy> jnthn: if that's the case, would there be room for some sort of "I can wait" piece in the stream? (Like, say,  @list».foo.bar.baz.«wait-to-do-this )

[11:22] <jnthn> I think .hyper() and .race() cannot be quite like .eager()

[11:22] <jnthn> We want them to go deep so we can do pipeline-y things

[11:22] <jnthn> And also we want to be able to do parallel reduce (max, min, etc.) too

[11:24] <jnthn> Trouble is I don't like the visaul off-by-one I'm seeing too

[11:24] <jnthn> In that in the one I just wrote above, the hyper() would parallelize the thing that is to the left of it AND those to the right

[11:25] <jnthn> I'm wondering if that one should be written

[11:25] <jnthn> my $max = @climate-files.hyper().map(&parse).map(&normalize).grep(*.continent eq 'Europe').max(*.yearly-average);

[11:26] <jnthn> I think previously we might have imagined that

[11:26] <ShimmerFairy> jnthn: honestly, I thought that hyper() only affected everything after it. (would correlate with ». at least)

[11:27] <jnthn> hyper for @xs -> $x { } # just @xs.map({...}).hyper.sink

[11:27] <jnthn> But that we may want the compiler re-write to be

[11:27] <jnthn> hyper for @xs -> $x { } # just @xs.hyper().map({...}).sink

[11:27] <jnthn> ShimmerFairy: Yes, that would be your first guess reading the code, and I think we probably want to make that how it is

[11:28] <jnthn> It *is* a departure from earlier thinking, where hyper and race were just forms of eager

[11:28] <jnthn> The trouble with putting it on the end is it doesn't work out for things that leave the monad

[11:28] <jnthn> Like reduce

[11:28] <ShimmerFairy> I think it'd make more sense for .hyper and .race to say "from this point on, things run in parallel" (as though it were actually .hyper(stuff) instead of .hyper.stuff, in a sense)

[11:28] <jnthn> Yeah

[11:29] <jnthn> Until you call something that doesn't know how to play within the paradigm

[11:29] <jnthn> So basically .hyper() and .race() return a HyperSeq, and multi-dispatch picks parallel implementations of .map, etc.

[11:30] * JimmyZ thinks it is DWIM # about race/hyper contagious

[11:30] <jnthn> And that way it can pick a parallel implementation of .reduce too, for example

[11:30] <ShimmerFairy> jnthn: would this affect the fact that you sometimes end up with @list».foo».bar».baz , or would it just affect the use of .hyper ?

[11:31] <jnthn> ShimmerFairy: It depends what >>.foo is meant to return

[11:31] <jnthn> ShimmerFairy: If it can return a HyperSeq than we'll get the opportunity to pipeline.

[11:31] <jnthn> Which TimToady++ really wants

[11:32] <jnthn> (And me too!)

[11:32] <ShimmerFairy> Personally multiple ». has always felt a bit strange to me, and almost seems like it should be a sign of multidimensionality (that is, the example line I gave maybe sorta reads like  for @list { for $_.foo { for $_.bar { ... )

[11:32] <jnthn> Cache locality is everything.

[11:33] <jnthn> Well, with what we're discussing here, it becomes sugar for .hyper().deepmap(*.foo)

[11:33] <jnthn> Writing a parallel deepmap will be a headache-inducing...

[11:33] * ShimmerFairy wonders if HyperSeq would look a bit Junction-y in spots...

[11:34] <jnthn> No

[11:34] <jnthn> It'll be incredibly boring

[11:34] <jnthn> Like Seq is

[11:35] <[ptc]> itz: please remember that I'm a New Zealander ;-)

[11:36] <jnthn> (New Zealand)++ # beautiful scenery AND craft beer

[11:36] <ShimmerFairy> jnthn: Yeah, I suspected we wouldn't suddenly be introducing a new non-Any type at this point, I was just reminded of autothreading for some reason :)

[11:36] <[ptc]> itz: it's nice to see the Aussies lose for once :-)  They were too powerful a force in cricket for so long

[11:37] <[ptc]> jnthn: Summer Ale is *very* yummy

[11:37] <jnthn> Also, hyper whenever $supply -> $x { ... } really, really wants the $supply to be affected for a clean desugar

[11:37] <jnthn> So making hyper for work the way I suggested will make it be exactly the right operation on hyper whenever.

[11:38] <jnthn> I...guess hyper/race are statement prefixes...

[11:38] <jnthn> Only trouble is what hyper @foo.map(*.bar) means, which if it just calls .hyper on the end result will not be good.

[11:38] <[ptc]> itz: but 60/10 in one innings in test cricket is a whipping!  I believe only the Kiwis have played worse...

[11:39] <ShimmerFairy> I feel like hyper and race are more "deliberate" than eager/lazy. eager/lazy feel like something you'll naturally encounter often (and perhaps not always need to think about), while hyper/race feel like they'll only usually happen when you specifically ask for it.

[11:39] <jnthn> Oh, for sure... >>.foo is just a succinct way of asking for it :)

[11:40] <jnthn> Maybe for now we conservatively only support hyper/race statement prefixes on for and whenever...

[11:41] <jnthn> I think most people setting up pipelines will do it with the methods

[11:41] *** spider-mario left
[11:43] *** jferrero joined
[11:44] <ShimmerFairy> »» for race, obviously :P  (I did stumble upon an old specs revision today that mentioned »» as a possible deepmap-ing hyper)

[11:45] <jnthn> It's funny that hyper and race share almost exactly the same code until the end when you're about to hand back a buffer, and with hyper you have to check if it's the right sequence number :)

[11:45] <jnthn> Anyway, will ponder some more over lunch, but I think we're sorta converging on something workable.

[11:45] <jdv79> ha.  the OO hierarchy seems to work as i wanted.  i forgot to use the parent in the child:(

[11:46] <jnthn> jdv79: phew...so it's not as bad as you feared... :)

[11:46] <ShimmerFairy> jnthn: so, hyper is just .race(:who'sin1st) ? :P

[11:47] <jdv79> my assumption about the error being related to the deps was not 100% corret ^H

[11:47] *** laouji left
[11:47] <jdv79> jnthn: seems so.  nice.

[11:50] <brrt> jnthn: we want to do SIMD over hyper, don't we?

[11:51] *** [TuxCM] joined
[11:56] *** timotimo left
[12:02] *** Sqirrel left
[12:10] *** dayangkun_ left
[12:12] *** Sqirrel joined
[12:16] *** Sqirrel left
[12:21] *** Sqirrel joined
[12:22] <[Coke]> jnthn: typo of "Corret" in one place in the glr gist.

[12:25] *** TEttinger left
[12:28] *** timo joined
[12:28] *** timo is now known as Guest16283

[12:28] *** Guest16283 is now known as timotimo

[12:34] *** cognominal joined
[12:36] *** lucasb joined
[12:38] *** yqt joined
[12:47] <lucasb> m: multi f($,$,$,$,$,$) {}; f

[12:47] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nhKVACBKCS␤Calling f() will never work with any of these multi signatures:␤    ($,,,,,)␤at /tmp/nhKVACBKCS:1␤------> 3multi f($,$,$,$,$,$) {}; 7⏏5f␤»

[12:48] <lucasb> lost the anonymous scalars somewhere down the road

[12:48] *** pmurias joined
[12:48] *** dmitri left
[12:49] <pmurias> hi

[12:54] <tony-o> hi

[12:54] *** AlexDaniel joined
[12:55] <RabidGravy> erk

[12:55] <RabidGravy> Program received signal SIGSEGV, Segmentation fault.

[12:55] <RabidGravy> 0x00007ffff7b210c6 in MVM_frame_find_lexical_by_name () from /home/jonathan/.rakudobrew/moar-nom/install/lib/libmoar.so

[12:58] <itz> [ptc]: :)

[12:59] *** rurban left
[13:04] *** beastd left
[13:04] *** beastd joined
[13:11] *** zakharyas joined
[13:17] <sergot> can you see any LHFs in the RT?

[13:18] <sergot> I'm looking for an easy task to work on

[13:18] <sergot> are you aware of one?

[13:24] <lucasb> m: my \x = 1; x\ .say

[13:24] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/rktUk5i_V7␤Variable '&x' is not declared␤at /tmp/rktUk5i_V7:1␤------> 3my \x = 1; 7⏏5x\ .say␤»

[13:25] <lucasb> Unspaces doesn't mix with terms. this affects 'self\ .method' as well

[13:28] <lucasb> m: class C { method f { self.say } }; C.new.f

[13:28] <camelia> rakudo-moar 262352: OUTPUT«C.new␤»

[13:28] <lucasb> m: class C { method f { self\ .say } }; C.new.f

[13:28] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cDjU2HwYpT␤Variable '&self' is not declared␤at /tmp/cDjU2HwYpT:1␤------> 3class C { method f { 7⏏5self\ .say } }; C.new.f␤»

[13:31] *** andreoss joined
[13:34] *** yqt left
[13:35] <[Coke]> sergot: no tickets are tagged LHF at this time.

[13:35] <[Coke]> When I'm digging for stuff, I sometimes try the LTA errors - sometimes making them awesome enough is easy enough.

[13:36] <[Coke]> searching for things with Parrot in the title and seeing if they work ok on Moar or JVM...

[13:37] <[Coke]> m: my Int a

[13:37] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5===␤Type 'Int' is not declared. Did you mean 'int'?␤at /tmp/dzhAgkCmKQ:1␤------> 3my Int 7⏏5a␤Malformed my␤at /tmp/dzhAgkCmKQ:1␤------> 3my Int 7⏏5a␤␤»

[13:37] <[Coke]> m: my Int a;

[13:37] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/kTKug1Rgoj␤Malformed my (did you mean to declare a sigilless \a or $a?)␤at /tmp/kTKug1Rgoj:1␤------> 3my Int a7⏏5;␤»

[13:38] <[Coke]> ^^ RT #120831; ISTR jnthn fixed a bug like this recently that needed to allow for an end of file, not just an end of statement.

[13:38] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=120831

[13:38] <jnthn> sergot: https://rt.perl.org/Ticket/Display.html?id=125733 is an easy error message fix

[13:38] *** raiph joined
[13:38] *** skids joined
[13:39] <[Coke]> m: uniname("\0").say

[13:39] <camelia> rakudo-moar 262352: OUTPUT«NULL␤»

[13:43] *** rurban joined
[13:47] *** Sqirrel left
[13:49] *** Sqirrel joined
[13:52] *** mjgardner joined
[13:53] <tony-o> m: ''.^can('uniname').say;

[13:53] <camelia> rakudo-moar 262352: OUTPUT«uniname␤»

[13:54] <andreoss> m: "\1".uniname.say

[13:54] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/iXnbMrmjGC␤Unrecognized backslash sequence: '\1'␤at /tmp/iXnbMrmjGC:1␤------> 3"\7⏏051".uniname.say␤    expecting any of:␤        double quotes␤        term␤»

[13:54] <andreoss> m: "\0".uniname.say

[13:54] <camelia> rakudo-moar 262352: OUTPUT«NULL␤»

[13:54] *** brrt left
[13:54] <tony-o> m: '👩‍👩‍👦 '.uniname.say;

[13:54] <camelia> rakudo-moar 262352: OUTPUT«WOMAN␤»

[13:55] <andreoss> isn't \1 just 1?

[13:55] <tony-o> no

[13:55] <tony-o>  \1 is 'start of heading'

[13:56] <tony-o> '1' is \31 iirc

[13:56] <tony-o> x31 ..

[13:56] <timotimo> m: say "1".encode.perl.say

[13:56] <yoleaux> 02:56Z <skids> timotimo: NQP 808ce0fcb broke ("a","b")».ords for some reason.

[13:56] <camelia> rakudo-moar 262352: OUTPUT«utf8.new(49)␤True␤»

[13:56] <timotimo> :o

[13:56] <timotimo> oh crap, i broke something?

[13:56] <tony-o> x31 == 49 :-)

[13:56] <skids> Well, only for bleeding edge people.

[13:57] <tony-o> timotimo: it's bc of the 2 'say's

[13:57] <timotimo> no, i meant what skids showed me

[13:57] <tony-o> oh ^

[13:57] <timotimo> we obviously didn't have a test in roast that'd exercise this code path

[13:57] <tony-o> m: "\x31".uniname.say;

[13:57] <camelia> rakudo-moar 262352: OUTPUT«DIGIT ONE␤»

[13:58] <tony-o> m: "\x1".uniname.say;

[13:58] <camelia> rakudo-moar 262352: OUTPUT«START OF HEADING␤»

[13:58] <tony-o> andreoss ^^

[13:58] *** Sqirrel left
[13:58] <tony-o> m: "\xFE".uniname.say;

[13:58] <camelia> rakudo-moar 262352: OUTPUT«LATIN SMALL LETTER THORN␤»

[13:59] <skids> timotimo: as big as roast is, it still has holes :-)

[14:00] <tony-o> that isn't a nice thing to say about someone skids

[14:00] <skids> tony-o: sorry, roast :-)

[14:00] <timotimo> skids: can you give me a one-liner that shows ("a", "b")>>.ords breaking?

[14:00] <timotimo> m: say ('a', 'b')>>.ords

[14:00] <camelia> rakudo-moar 262352: OUTPUT«97 98␤»

[14:00] <timotimo> this is the expected output?

[14:00] <skids> Yes, camelia does not have that nqp yet.

[14:00] <timotimo> of course

[14:01] <skids> With it you get a blank line -- ((),()) actually.

[14:01] <timotimo> oh lord

[14:01] <timotimo> i'm about to have a built rakuod on this machine

[14:02] <skids> But only for ords.  And maybe some other thing.  But not for .chars at least.

[14:02] <timotimo> ... what? %)

[14:04] <skids> m: say ('a', 'b')>>.uninames

[14:04] <camelia> rakudo-moar 262352: OUTPUT«LATIN SMALL LETTER A LATIN SMALL LETTER B␤»

[14:05] <skids> Yeah, things that return lists are broken.

[14:05] <skids> So probably more a problem in ">>." than ".ords"

[14:09] <timotimo> mhm, likely

[14:11] <timotimo> ... there aren't even "while"s in there :\

[14:12] *** AlexDaniel left
[14:17] *** brrt joined
[14:20] <lucasb> what does 'rpa' stands for in the core? 'returned parcel' or something?

[14:22] *** FROGGS left
[14:22] <timotimo> nah

[14:22] <timotimo> something PMC Array

[14:23] <[Coke]> resizable

[14:23] <timotimo> ah, yeah

[14:23] <timotimo> from when we primarily used parrot as our backend

[14:23] <[Coke]> original parrot nomenclature.

[14:23] <[Coke]> PMC == "parrot magic cookie"

[14:23] <[Coke]> sort of an primitive VM object.

[14:23] <lucasb> oh, thanks timotimo and [Coke]!

[14:24] <Woodi_> hi #perl6 :)

[14:24] <timotimo> hello Woodi_ 

[14:27] <RabidGravy> and there I was thinking that a libsamplerate binding would be nice and easy

[14:27] <RabidGravy> hahahahaahahahahahahaha!

[14:27] <nine> Every time you break object encapsulation in Perl 5 code, an Inline::Perl5 developer's kitten dies... or so

[14:30] <Woodi_> jnthn: .hyper don't need to parallelize to the end, eg. .map().map().map()  2 first can work concurently but 3rd can use values from all places in the array. so before 3rd map() values on "one side" can be inserted into buffer and on the "other side" iterated sequentially

[14:32] <timotimo> how would the last .map be able to use values from everywhere?

[14:33] <Woodi_> also I wanted to say: "instruction pipeline is more valuable" in CPUs (.map() instructions can be put there and data can flow) but realy we want all cases :) static instructions in cache but also small "static" data with long .map() sequence...

[14:33] <Woodi_> timotimo: something needs to collect them :)

[14:33] *** AlexDaniel joined
[14:34] <timotimo> huh?

[14:34] <timotimo> but map works only with chunks of the thing on the LHS

[14:35] <Woodi_> is .map().map  like  my @b = @a.map(); my @c = @b.map(); ....  ?  

[14:35] <timotimo> kind of

[14:35] <timotimo> but more like my $in_between := @a.map(); my @result = $in_between.map()

[14:36] <timotimo> there's not really an assignment step in between when using .map().map()

[14:37] <Woodi_> yes, but if 3rd map wants to see all data then something must to bufer them. or programmer can use 2 lines of code... :) 

[14:37] <jnthn> Indeed

[14:37] <jnthn> .map doesn't return data

[14:37] <jnthn> .map returns something that knows how to provide data

[14:38] <Woodi_> details :)

[14:39] <jnthn> Details you don't know about, so you spout meaninglessly, yes...

[14:42] *** skids left
[14:45] <pmurias> nine: why does breaking object encapsulation cause trouble for Inline::Perl5?

[14:45] <timotimo> no need for a second line of code either, you can just map.map.eager.map to have the result of the first two maps eagerly evaluated and thus buffered

[14:45] *** xfix joined
[14:48] <jnthn> timotimo: Yeah, that works; I do wonder if we want a .sequential() or so that drops you back to sequential processing without having to buffer up everything though.

[14:48] <jnthn> This bit is really, really tricky to design and get right...

[14:48] <timotimo> i'm not sure i understand that?

[14:48] <timotimo> the first image that appears in my head is "turn non-cooperating code into gather/take"

[14:51] <nine> pmurias: because subclassing P5 classes in P6 is kind of a stunt that works surprisingly well...until someone from outside the base class tries to look at the object's internals

[14:54] <nine> pmurias: as if it wasn't already complicated enough. Perl 5 documentation tells you for example that an object is a blessed reference and it looks like that's true. But deep down it isn't. It's a reference to a blessed thingy. I was quite surprised when I found out that.

[14:54] <timotimo> jnthn: or do you mean some kind of mechanism to signal that only parts of a sequence are supposed to be eagerified?

[14:57] <jnthn> timotimo: eager blocks until the previous stage has produced everything

[14:58] *** skids joined
[14:58] *** telex left
[14:58] <jnthn> timotimo: If you still want to consume values as they become available from the parallel computation, but that you want to be sure you're on a single thread, then eager is kinda overkill

[14:58] <jnthn> .lazy works too, but that may be overkill in the other direction

[14:59] <timotimo> ah

[14:59] <jnthn> Also, the way this is turning out, .sequential() is probably going to be a one line method to provide... I bet TimToady'll want it called soemthing else though.

[15:00] <timotimo> so it'll give you something more like pipeline semantics, but on a single thread using batching instead of communicating threads or something

[15:00] <PerlJam> call it .seq and confuse everybody  ;)

[15:00] <timotimo> basically a moving buffer/window thingie that gets pushed along?

[15:00] *** telex joined
[15:01] <jnthn> PerlJam: heh, or call HyperSeq a Par :P

[15:03] *** Possum joined
[15:07] *** rurban_ joined
[15:07] <itz> m: class A { has $.foo; has $.foo};

[15:07] <camelia> rakudo-moar 262352: OUTPUT«===SORRY!===␤Package 'A' already has an attribute named '$!foo'␤»

[15:07] <nine> pmurias: or not! It's really the reference that's blessed. Looking at the code, it's just newSVrv's documentation that's clearly wrong. Sending a doc patch...

[15:08] <itz> shouldn't that be $.foo in the error or am I missing something?

[15:09] <jnthn> itz: Attributes are always called $!foo

[15:10] <jnthn> itz: The . just means "and also generate an accessor"

[15:10] <itz> ah

[15:10] <jdv79> complexity ftw

[15:11] * TimToady isn't awake yet, but that kinda sounds like what I was proposing to call "silo"

[15:12] *** vytas left
[15:12] <awwaiid> ICFP contest today! http://icfpcontest.org

[15:12] <awwaiid> GREAT place to show off a new language. Actually pretty much the perfect place.

[15:12] *** xfix left
[15:14] <jdv79> what does this silo do?

[15:14] *** vytas joined
[15:17] <nine> Wow, newSVrv's docs have been wrong since they were written in 1994

[15:17] *** diana_olhovik_ left
[15:19] *** captain-adequate joined
[15:19] <RabidGravy> something weird that someone may able to explain to me

[15:21] <pmurias> nine: when I create 2 references to the same hash, both change class when I call bless on one of them

[15:21] *** pierrot_ is now known as pierrot

[15:22] <nine> pmurias: oh yes, that's true. And is the reason, why my first attempt at implementing this failed back then.

[15:22] <RabidGravy> if I do something like  "class A is repr('CStruct') { has CArray[num32] $!foo; submethod BUILD() { $!foo := CArray[num32].new }}" and then pass that a new one of thiose to a native sub it segfaults trying to write the array

[15:23] <RabidGravy> but something like  "class A is repr('CStruct') { has CArray[num32] $!foo; submethod BUILD() { my $foo := CArray[num32].new; $!foo:= $foo }}"  works fine

[15:23] <RabidGravy> any clue as to why?

[15:24] <nine> pmurias: so what I wrote earlier is true after all. It's the thingy that's blessed, even if you have to pass the reference to sv_bless.

[15:28] <RabidGravy> yeah

[15:28] <RabidGravy> perl -e 'my $a = 1; bless \$a, "Foo";  print $a,", \$a'

[15:28] <RabidGravy> 1  Foo=SCALAR(0x1c676e0)

[15:30] *** pmurias left
[15:36] <dalek> ecosystem: 23c4882 | (Steve Mynott)++ | META.list:

[15:36] <dalek> ecosystem: add HTML::Restrict

[15:36] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/23c4882473

[15:48] <RabidGravy> Hmm libsamplerate produces 0.2% too few frames when doubling the samplerate

[15:53] *** Psyche^ joined
[15:58] *** Psyche^_ left
[15:59] *** cognominal left
[16:00] *** zakharyas left
[16:02] * RabidGravy resorts to 'ok ($out-frames-total / ($in-frames-total * 2)) <1, "got the expected total number of frames (approximately)";'

[16:04] *** Sqirrel joined
[16:17] *** brrt left
[16:21] *** nys joined
[16:25] <tony-o> who is stmuk ?

[16:27] <itz> me

[16:28] * timotimo didn't know that

[16:28] <tony-o> does that HTML::Restrict just filter out bad html tags, does it kill all the child nodes or place them in the parent?

[16:29] <itz> I think it might wrongly kill child nodes which I only noticed a few mins ago

[16:30] <tony-o> should have a :save-the-children flag 

[16:30] <itz> :)

[16:30] <tony-o> that way it's fun to say to other people

[16:33] *** rurban left
[16:35] <RabidGravy> or :geldof

[16:37] <tony-o> geldof ?

[16:37] <itz> UK charity figure 

[16:38] <tony-o> ah

[16:38] <itz> a bit like the vim editor

[16:39] <b2gills> m: 'a' ==> { .say }() # does it make sense to allow this to work without the parens

[16:39] <camelia> rakudo-moar 262352: OUTPUT«a␤»

[16:41] *** brrt joined
[16:41] *** rurban_ left
[16:44] <tony-o> m: 'a' ==> { .say; };

[16:44] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/wO8SKf8llE␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/wO8SKf8llE:1␤------> 3'a' ==> { .say; }7⏏5;␤»

[16:46] *** mr-foobar joined
[16:57] <sergot> jnthn: thanks! 

[17:00] <sergot> jnthn: I will start there then :)

[17:05] <TimToady> I don't think I like contagious hyper if it's user-visible, cuz it's adding another dimension to the ambiguity of dispatch, which was already bad enough with 'nodal' 

[17:06] <TimToady> in @a».foo.elems, is that .elems supposed to be the number of elements that came through from @a, or the number of elems from each return from .foo, or the number of hyper batches?

[17:06] <TimToady> if we want something contagous, it should have both a beginning and an end

[17:06] <TimToady> *gious

[17:07] <TimToady> much like we took the original placeholder proposal with its arcane scope rules, and said, "It's always just to the curlies"

[17:08] <jnthn> TimToady: Aside from any side-effects foo may do, it's exactly equivalent result wise to @a.deepmap(*.foo).elems

[17:08] <TimToady> so for now I think hyper should only be contagious to the next hyper

[17:09] *** eam joined
[17:09] <timotimo> how did my change to nqp::while break deepmap? :(

[17:10] <timotimo> the things i changed were - potentially - how passing the condition to the block will be handled, and what nqp::while returns

[17:10] <eam> I'm playing around with perl6 and I don't understand why perl6 -e'say ("a", "b" ...^ * gt "y").pick' prints one character "a".."y" like I'd expect, but if I say gt "z" I get two random letters

[17:10] <jnthn> TimToady: If you'd prefer @a>>.foo to mean @a.hyper().deepmap(*.foo).sequential() it's fine too

[17:10] <timotimo> the bodies of the nqp::while blocks in deepmap aren't blocks with arguments, so no argument passing needed, and the return value would just get sunk'd

[17:11] <TimToady> I just don't want it magically turning into @a.deepmap(*.foo.elems)

[17:11] *** havenwood joined
[17:11] <jnthn> Oh, that wasn't even slightly what I was suggesting

[17:11] <TimToady> okay, was probably misunderstanding something in the backlog then

[17:12] *** brrt left
[17:13] * timotimo double-checks it's actually that exact commit that breaks it

[17:14] <eam> nevermind, I figured it out - "za" is the first sequence gt "z"

[17:15] <eam> "yz" actually

[17:15] <timotimo> oh damn it, it *is* that commit

[17:15] <dalek> perl6-roast-data: e1a0985 | coke++ | / (9 files):

[17:15] <dalek> perl6-roast-data: today (automated commit)

[17:15] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e1a098522c

[17:15] *** domidumont joined
[17:17] <TimToady> jnthn: another more credible wrinkle is if you have ».foo.map: -> $a, $b {...} then you risk $a being at the end of one batch and $b at the beginning of another, so you can't pipeline batches quite independently

[17:17] <tony-o> what order does » operate on a list?

[17:18] <tony-o> is it doing a map reduce essentially?

[17:18] <TimToady> any order it likes, as long as it returns results in the original order

[17:18] <tony-o> ah okay, i was consistently getting the same order from it and was curious.  ty

[17:19] <TimToady> I think race is more like map-reduce

[17:19] <tony-o> m: ("a".."z")»{$_}.join.say;

[17:19] <camelia> rakudo-moar 262352: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[17:20] <timotimo> tony-o: we intentionally throw the items around, but it's deterministic sticc

[17:20] <timotimo> m: ("a".."z")>>.say

[17:20] <camelia> rakudo-moar 262352: OUTPUT«z␤x␤v␤t␤r␤p␤n␤l␤j␤h␤f␤d␤b␤y␤w␤u␤s␤q␤o␤m␤k␤i␤g␤e␤c␤a␤»

[17:20] <timotimo> m: ("a".."z")>>.say

[17:20] <camelia> rakudo-moar 262352: OUTPUT«z␤x␤v␤t␤r␤p␤n␤l␤j␤h␤f␤d␤b␤y␤w␤u␤s␤q␤o␤m␤k␤i␤g␤e␤c␤a␤»

[17:20] <tony-o> m: race (1..5) { $_; }

[17:20] <camelia> rakudo-moar 262352: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IfAgrj4FtL␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/IfAgrj4FtL:1␤------> 3race (1..5)7⏏5 { $_; }␤    expecting any of:␤        infix␤ …»

[17:20] <tony-o> timotimo: that's what i was experiencing ^ thanks for confirming

[17:21] <TimToady> race is NYI, barely :)

[17:21] <jnthn> TimToady: I'm just not going to attempt to parallelize maps where the block's arity ain't 1 for now

[17:21] <jnthn> TimToady: But yeah, there's no very easy way to handle that.

[17:22] *** mr_ron joined
[17:22] *** cognominal joined
[17:22] <jnthn> Whatever you do.

[17:23] <jnthn> I think what I've got will be flexible enough API wise to find a way to cope reasonably well.

[17:23] <jnthn> dinner; bbiab &

[17:24] <timotimo> perl6 -e 'say deepmap(-> $a { (1, 2).map(->$a {$a}) }, ("a", "b"))'  -  comes up empty

[17:24] <timotimo> perl6 -e 'say deepmap(-> $a { my @ = (1, 2) }, ("a", "b"))'

[17:24] <timotimo> 1 2 1 2

[17:24] <TimToady> on a slightly different subject, I know Fortress did a lot of work in list structures that could be split N ways easily, so I'm wondering how much of a bottleneck with left-to-right splitting of batches at the head of the pipeline...

[17:24] <havenwood> How to you limit to just the `foo(bar)` or `bar.foo` style? My googlefu is failing me.

[17:25] <havenwood> How do* you

[17:25] <timotimo> what do you mean?

[17:26] <RabidGravy> method or sub?

[17:26] <RabidGravy> sub or method

[17:26] <havenwood> I'd swear there was a way to do something like `strict OO`, my memory fails me.

[17:26] <TimToady> why would you want to do that?

[17:27] *** diana_olhovik joined
[17:27] *** andreoss left
[17:27] <mr_ron> Anyone know a p6 module with good examples of exception classes and handling?

[17:27] <TimToady> there are very good reasons for both early binding and late binding

[17:30] <havenwood> TimToady: I don't want to use it. Just recalled there being a way like `use oo;` but can't find it for the life of me.

[17:31] <havenwood> TimToady: Just playing around, mere curiosity.

[17:31] <TimToady> you're probably thinking of S12's use oo :closed :final;

[17:32] *** domidumont left
[17:32] <TimToady> but that's just knobs on OO, not a stricture

[17:33] *** diana_olhovik left
[17:39] *** coffee` joined
[17:41] *** llfourn left
[17:44] <TimToady> jnthn: on bikeshedding .sequential, some starting ideas: .reform .linear .serial .queue .fifo .hypo

[17:46] <TimToady> well, and .silo

[17:47] <TimToady> but maybe .seq is okay

[17:47] *** plicease joined
[17:48] <TimToady> .oO("Why are they calling string eq there?")

[17:48] * colomon just booked his plane tickets to Switzerand.

[17:51] *** Sqirrel left
[17:53] *** Sqirrel joined
[17:59] <jdv79> Your search - nodal site:perlcabal.org/syn/ - did not match any documents. :(

[18:11] *** espadrine left
[18:15] *** pRiVi is now known as Tisch_der_Sieger

[18:22] *** havenwood left
[18:27] *** [TuxCM] left
[18:33] *** espadrine joined
[18:37] <raiph> jdv79: 6 matches in http://design.perl6.org/S03.html

[18:41] <jdv79> i noticed that

[18:41] <jdv79> the google site search on design.perl6.org aint so hot

[18:42] <jdv79> yay for good ole grep

[18:56] *** [TuxCM] joined
[19:04] *** [TuxCM] left
[19:06] *** AlexDani` joined
[19:07] *** AlexDaniel left
[19:16] *** [TuxCM] joined
[19:25] <dalek> rakudo/nom: c048e75 | lizmat++ | src/core/Pair.pm:

[19:25] <dalek> rakudo/nom: Naively implement pair()

[19:25] <dalek> rakudo/nom: 

[19:25] <dalek> rakudo/nom: As discussed at http://irclog.perlgeek.de/perl6/2015-08-06#i_11014717 .

[19:25] <dalek> rakudo/nom: 

[19:25] <dalek> rakudo/nom: Please note that I don't think it's a good idea to also have a named

[19:25] <dalek> rakudo/nom: variant for this: if you want to use named parameters, please do Pair.new()

[19:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c048e7509d

[19:26] <lizmat> $ 6 'say pair(42,666)'

[19:26] <lizmat> 42 => 666

[19:26] <lizmat> please note I also see a use for pair() in those cases you want to be sure to pass a Positional Pair, rather than a named parameter

[19:26] <lizmat> aka   frobnicate( pair("a",42") )

[19:27] <lizmat> aka   frobnicate( pair("a",42) )   # rather  :-)

[19:28] <jnthn> TimToady: Any feeling in exception semantics for hyper/race?

[19:28] <jnthn> *on

[19:32] <TimToady> well, we'd like each dataflow to succeed or fail separately, so we don't blow up the rocket just because one sensor was bad

[19:33] <jnthn> That's fine if folks fail, but what if they die?

[19:33] <jnthn> Uh...that sounded more morbid than intended. :)

[19:35] *** mjgardner left
[19:35] <dalek> roast: 9940e5e | lizmat++ | S04-statements/if.t:

[19:35] <dalek> roast: Remove superstitious parens from if tests

[19:35] <dalek> roast: review: https://github.com/perl6/roast/commit/9940e5e001

[19:35] <TimToady> for now that's a DIHWIDT, I suspect; I don't recall that we've specced any kind of distributed try

[19:36] <jnthn> *nod*

[19:37] *** llfourn joined
[19:37] <jnthn> Well, I guess the more specific question I shoulda asked is: do we just throw the first exception we become aware of, or if we manage to get concurrent failure to we package them up into some kind of aggregate exception?

[19:38] <jnthn> In .Net they do the latter in the name of preventing information loss, but I've rarely seen that actually happen in the wild.

[19:38] <jnthn> And it makes exception handling harder, 'cus now your when blocks won't match

[19:38] <jnthn> So refactoring to parallel becomes more of a job.

[19:42] *** llfourn left
[19:42] <dalek> rakudo/nom: 1a3f1a2 | TimToady++ | src/ (2 files):

[19:42] <dalek> rakudo/nom: make andthen/orelse topicalizers

[19:42] <dalek> rakudo/nom: 

[19:42] <dalek> rakudo/nom: This also fixes the with/without statement modifiers to topicalize

[19:42] <dalek> rakudo/nom: correctly.

[19:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a3f1a2d69

[19:44] <dalek> specs: 8268851 | TimToady++ | S03-operators.pod:

[19:44] <dalek> specs: change orelse to topicalize to $_, not $!

[19:44] <dalek> specs: 

[19:44] <dalek> specs: (Also makes 'without' use $_ for its topic.)

[19:44] <dalek> specs: review: https://github.com/perl6/specs/commit/8268851eca

[19:44] <dalek> roast: 9ba702f | lizmat++ | S04-statements/with.t:

[19:44] <dalek> roast: Add basic "with" test (todo for now)

[19:44] <dalek> roast: review: https://github.com/perl6/roast/commit/9ba702f1fa

[19:45] * lizmat off for some MI:4

[19:45] * TimToady off for lunch

[19:50] *** diana_olhovik joined
[19:50] <AlexDani`> sergot: some time ago you asked for LHFs. Well, I don't mark my tickets as LHFs because most of the time I have no idea what the problem is, but at the same time I've never submitted anything that is extraordinarily hard

[19:50] *** AlexDani` is now known as AlekDaniel

[19:51] *** AlekDaniel is now known as AlexDaniel

[19:52] <AlexDaniel> sergot: so maybe filtering by [email@hidden.address] will give you a decent list of LHFs

[19:52] <yoleaux> 6 Aug 2015 05:00Z <skids> AlexDaniel: The message for "..." still has to be fixed; it is a separate issue ("..." implicity tries to "return" from the mainline code, not just sink a Failure)  What was fixed was there is no longer a different backtrace when a Failure is sunk in the last statement.

[19:52] <AlexDaniel> oh ok

[19:53] <AlexDaniel> and most of my tickets are just LTAs

[19:58] <AlexDaniel> m: .say for 1...NaN;

[19:58] <camelia> rakudo-moar c048e7: OUTPUT«(timeout)1␤0␤-1␤-2␤-3␤-4␤-5␤-6␤-7␤-8␤-9␤-10␤-11␤-12␤-13␤-14␤-15␤-16␤-17␤-18␤-19␤-20␤-21␤-22␤-23␤-24␤-25␤-26␤-27␤-28␤-29␤-30␤-31␤-32␤-33␤-34␤-35␤-36␤-37␤-38␤-39␤-40␤-41␤-4…»

[19:58] <AlexDaniel> mwahaha :)

[19:59] <AlexDaniel> m: .say for Inf..0

[19:59] <camelia> rakudo-moar c048e7: OUTPUT«(signal XFSZ)-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-9223372036854775808␤-922337203685…»

[20:02] *** [particle] left
[20:11] *** jjido joined
[20:12] *** jjido left
[20:13] *** rindolf left
[20:24] <TimToady> m: .say with 42; 42 andthen .say

[20:24] <camelia> rakudo-moar 1a3f1a: OUTPUT«42␤42␤»

[20:24] <TimToady> m: .say without Rat

[20:24] <camelia> rakudo-moar 1a3f1a: OUTPUT«(Rat)␤»

[20:24] <TimToady> m: .say with 0; .say with Nil

[20:24] <camelia> rakudo-moar 1a3f1a: OUTPUT«0␤»

[20:25] *** darutoko left
[20:25] <TimToady> m: with 0 { .say }  # now to make this work

[20:25] <camelia> rakudo-moar 1a3f1a: ( no output )

[20:37] *** llfourn joined
[20:41] *** llfourn left
[20:44] *** diana_olhovik left
[20:51] *** yqt joined
[20:54] <jdv79> is it possible to use a role to share a new and BUILD method amongst consuming classes?

[20:54] <jdv79> it seems to only partially work

[21:01] <TimToady> role BUILDs are not yet composed properly

[21:07] <skids> jdv79: the workaround has been to abuse the attribute default value initialization logic.

[21:10] *** skids left
[21:11] <jnthn> 'fraid I ain't gonna get the hyper/race all the way there today

[21:12] <jnthn> (Headache + bureaucratic distractions... :/)

[21:12] <jnthn> Think I'm close to a first working example though.

[21:12] <jnthn> So probably tomorrow.

[21:13] <TimToady> be better!

[21:13] <jnthn> Thanks!

[21:13] <jnthn> The headache's already gone, by now I'm just tired, and that's not a good state to juggle a lock and a pair of condvars :)

[21:15] <TimToady> m: say "jnthn++" without $*headache

[21:15] <camelia> rakudo-moar 1a3f1a: OUTPUT«jnthn++␤»

[21:16] <jnthn> ooh :)

[21:16] <jnthn> I see you left the bit involving hack on code-gen until the end. :)

[21:17] <TimToady> working on that bit now, yeah

[21:17] <TimToady> I can generate with and without opcodes, but they still behave like if/unless :)

[21:18] <TimToady> just need to figure out the bits where it evaluates the conditional so as to pass the original object but evaluate with .defined

[21:18] *** lucasb left
[21:18] * RabidGravy proselytises a CPAN author who was keen for me to check out his module to port it to Perl 6 ;-)

[21:18] <RabidGravy> first time I've actually been "spammed" about a module I think

[21:18] <jnthn> TimToady: I'll be you'll have an easier time doing it on Moar first

[21:19] <TimToady> also still need to force passing of the conditional

[21:19] <TimToady> well, that's what I'm doing

[21:19] <jnthn> TimToady: JVM is a stack machine which makes code-gen harder (unless you're at university writing a compiler for a tiny language, and then the stack machine looks wonderfully elegant to make code for :P)

[21:20] <jnthn> Yeah, we do stash the conditional away

[21:20] <TimToady> I see the bind, but I need to sneak in a defined after that

[21:21] <jnthn> right

[21:22] <jnthn> The two places you'll need to tweak are those near resolve_condition_op

[21:23] <jnthn> There's this:

[21:23] <jnthn> push_op(@ins, 'decont', $decont_reg, @comp_ops[0].result_reg);

[21:23] <jnthn> $decont_reg now holds the thing to test

[21:24] <jnthn> So if you just do a findmeth on that and then shove in a call, you can even write the result of the call back into the same register and leave the code the same

[21:24] <jnthn> Also, there's a conditional "@comp_ops[0].result_kind == $MVM_reg_obj"

[21:25] <TimToady> so that one is the evaluation, and is post-bind to the temp?

[21:25] <jnthn> Yes

[21:25] <jnthn> That one is literally at the point where we spit out the jump

[21:25] <TimToady> right

[21:25] <jnthn> We've already stashed the condition away by that point if we need it

[21:26] <jnthn> Anyway, earlier on you have:

[21:26] <jnthn> @comp_ops[0] := ...

[21:26] <jnthn> Twice

[21:26] <jnthn> I'd pass :want($MVM_reg_obj) to the two calls that assign to it

[21:26] <jnthn> That demands an object register

[21:26] <jnthn> Then you can delete the condition and its else branch that I mentioned a moment ago

[21:26] <jnthn> Because it's highly unlikely anyone will sensibly use with/without on a native type

[21:28] <TimToady> okay, maybe that's enough to ignite my brane

[21:28] <TimToady> it's got soggier these last few decades... :)

[21:29] <RabidGravy> boo!

[21:30] <RabidGravy> mind I've felt really stupid for the last week

[21:30] <RabidGravy> I kind of woke up again today

[21:32] * jnthn has had one of his better weeks this one for productivity

[21:32] <TimToady> fershure

[21:34] *** bin_005 joined
[21:35] * jnthn kinda wants to show off .hyper/.race and also supply/whenever at this YAPC::Asia talk :)

[21:35] <jnthn> *his

[21:37] * TimToady is probably gonna rewarm his fosdem talk, since that never got properly recorded

[21:37] * TimToady doesn't have the brane to write new talks right now anyway

[21:39] <jnthn> Well, I get to re-use the YAPC::Asia one at Swiss Perl Workshop :)

[21:40] <RabidGravy> jnthn, does the thing about not being able to bind a new CArray directly to an attribute in a CStruct and having to bind to a variable which is then bound to the attribute ring any bells?

[21:42] <jnthn> RabidGravy: No, I was pretty confused by that...

[21:43] <RabidGravy> well you can do it but it appears to mess the pointer up

[21:43] <ShimmerFairy> TimToady: what are the "new andthen/orelse" mentioned in one of your commits yesterday? (That is, what's different from how they have been before?)

[21:43] <jnthn> RabidGravy: FROGGS++ worked on that stuff much more recently than I have so may have an idea

[21:43] <RabidGravy> all weird

[21:45] <RabidGravy> the samplerate API is a bit special anyway, it gets a struct which contains both the input buffer and output buffer so quite niche

[21:48] <jnthn> OK, time to wander afk to rest

[21:48] <jnthn> Back tomorrow to juggle my condvars some more...

[21:48] <jnthn> o/

[21:48] <TimToady> \o

[21:49] <RabidGravy> juggle your stuff in private matey ;-)

[21:49] <TimToady> ShimmerFairy: they topicalize the for the RHS as specced

[21:49] <TimToady> m: 42 andthen .say

[21:49] <camelia> rakudo-moar 1a3f1a: OUTPUT«42␤»

[21:50] <TimToady> and the internals are reworked to support with/without statement modifiers also

[21:50] <ShimmerFairy> Ah, so you "just" implemented more of the spec on them then :)

[21:50] <TimToady> well, I also tweaked the spec :)

[21:52] <RabidGravy> if the spec don't fit tweak it

[22:05] * TimToady --> nap

[22:05] *** TEttinger joined
[22:05] *** telex left
[22:06] <dalek> rakudo-star-daily: 1b77bdd | coke++ | log/ (8 files):

[22:06] <dalek> rakudo-star-daily: today (automated commit)

[22:06] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/1b77bdd492

[22:06] *** telex joined
[22:12] <RabidGravy> boom!

[22:16] <dalek> rakudo-star-daily: 94d04df | coke++ | log/ (10 files):

[22:16] <dalek> rakudo-star-daily: archive parrot logs

[22:16] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/94d04df0ad

[22:29] *** virtualsue left
[22:36] *** Zoffix_ joined
[22:38] *** llfourn joined
[22:40] <Sgeo> fail reminds me a bit of Rust's try!(Err(...))

[22:41] *** Zoffix left
[22:41] *** ][Sno][ joined
[22:41] *** TimToady_ joined
[22:43] *** llfourn left
[22:43] *** mrf left
[22:49] *** nys left
[22:49] *** Grrrr left
[22:49] *** [Sno] left
[22:49] *** TimToady left
[22:49] *** Grrrr joined
[22:50] *** skids joined
[22:53] <RabidGravy> is it possible to parameterise a subset?

[22:58] <lizmat> RabidGravy: I have no idea

[22:58] <lizmat> looking at http://blogs.perl.org/users/aaron_baugher/2015/08/benchmarking-index-and-regex-in-perl-6.html

[22:59] <lizmat> I wonder whether we shouldn't have a .contains, which would just return Bool  ($i != -1)

[22:59] <lizmat> so we can skip the .defined in that benchmark

[23:00] *** nys joined
[23:06] * lizmat gets some sleep

[23:06] <RabidGravy> to be fair index is always going to be way faster than a regex

[23:13] <b2gills> I tested parsing with index and substr in Perl 5. It was faster for up to about 4 calls to index, after that the regex was faster.

[23:33] *** RabidGravy left
[23:36] *** TimToady_ is now known as TimToday

[23:36] *** TimToday is now known as TimToady

[23:37] *** mr_ron left
[23:46] *** average joined
[23:46] <average> https://gist.github.com/masak/66735ee4c40a5d5c2eee#file-01-cycles-p6-L73

[23:46] <average> wow, I like how this looks

[23:47] <average> lines 85,86,93  much <3

[23:47] <average> oh, line 76 too

[23:48] <average> i'm wondering how the \in and \cap are implemented or if they can be overriden

[23:49] <average> I suppose one should be able to implement them for specific cases because they can have faster ones in particular cases

[23:50] *** beastd left
[23:54] *** captain-adequate left
[23:55] <average> either way, much interesting stuff in the p6 blogosphere

[23:55] <average> 10x

[23:55] *** average left
[23:56] <ShimmerFairy> I was about to say: there's "texas" versions of all those unicode operators. Rakudo's source suggests that you should override the texas versions, since the unicode versions are explicitly 'only' subs, but that doesn't actually stop anything.

[23:56] <ShimmerFairy> m: class Foo { }; multi sub infix:<⊂>(Foo $a, Foo $b) { "OK!" }; say Foo ⊂ Foo; say Foo (<) Foo;

[23:56] <camelia> rakudo-moar 1a3f1a: OUTPUT«OK!␤False␤»

[23:57] <ShimmerFairy> supposedly, that infix:<⊂> is an 'only' sub and therefore shouldn't be overrideable.

[23:58] <ShimmerFairy> However, I personally would prefer overriding the unicode operators instead, so I don't mind :)

