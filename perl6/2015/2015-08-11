[00:01] <ShimmerFairy> Yeah, I'm not sure what's wrong.

[00:01] <ShimmerFairy> m: class C { multi method M($go) { say "X" }; multi method M(Int $go) { callsame; callsame; callsame; } }; C.M(1)

[00:01] <camelia> rakudo-moar a32c14: OUTPUT«X␤»

[00:04] <TimToady> looks like a bug to me

[00:05] <AlexDaniel> ok

[00:05] <AlexDaniel> I'm already submitting a ticket

[00:05] <smls> m: my $x = EnumMap.new("a", 1, "b", 2).list[0]; say $x; say $x.WHAT

[00:05] <camelia> rakudo-moar a32c14: OUTPUT«a => 1␤(Pair)␤»

[00:06] <smls> So EnumMap does not actually represent its entries as Enums as the design docs suggest?

[00:09] <AlexDaniel> m: sub foo { say 'X' }; &foo.wrap:{ callsame; callsame; nextsame; say 'y' }; foo;

[00:09] <camelia> rakudo-moar a32c14: OUTPUT«X␤y␤»

[00:09] <AlexDaniel> it is interesting how the code just keeps executing after nextsame :)

[00:10] <TimToady> it's almost as if callsame and nextsame were reversed

[00:10] <ShimmerFairy> m: sub foo { say 'X' }; &foo.wrap:{ nextsame; say 'y' }; foo;

[00:10] <camelia> rakudo-moar a32c14: OUTPUT«X␤»

[00:10] <TimToady> except that wouldn't work either

[00:10] <ShimmerFairy> AlexDaniel: it's actually because the 'callsame' is interpreted first

[00:11] <skids> https://gist.github.com/skids/edac2cebdab5c6bd7641 # apply against GLR to get accurate error messages, for those hacking on it.

[00:11] <ShimmerFairy> my guess is that multiple call/next* don't get used correctly.

[00:12] <ShimmerFairy> (almost like using one of those functions exhausts the candidate list, or somethin')

[00:12] <cognominal> A question about actions of match withing a <?before >. Please comment : https://gist.github.com/cognominal/9067d157b484fb7703c7

[00:16] *** llfourn joined
[00:20] *** llfourn left
[00:21] <smls> TimToady: That whole "hashy" part of the type hierarchy (EnumMap, Hash, PairMap, QuantHash & co) is kind of a mess.

[00:21] <smls> TimToady: The design doc in question (S32::Containers) feels muddled in and of itself (things like suggesting that Hash indirectly inherits from Positional); and Rakudo's interpretation of that spec seems scrappy and adds additional weirdness.

[00:22] <smls> Timtoady: Is there any chance some of those type names and their inheritance relationships can still be tweaked before 6.0?

[00:22] <smls> Would be a shame if the elegant and well-thought-out post-GLR set of listy classes, is accompanied by a jumbled set of hashy classes, in the big release.

[00:22] <ShimmerFairy> smls: I agree, when mapping out a plan for a tutorial series I'd like to write sometime, the Set/Bag/Mix stuff were given their own heading.

[00:23] <ShimmerFairy> .oO(the Grand Associative Rejiggering -- GAR)

[00:23] <smls> It would be very grand in terms of implementation effort neede, I think.

[00:23] *** laouji joined
[00:24] <smls> Some renaming and rearranging mostly, while pretty much keeping the classes' current functionality.

[00:24] <smls> s/would be/wouln't be/

[00:25] <ShimmerFairy> smls: I've gotten the feeling that the associative stuff beyond Hash is some special deeper area, with the only likely-seen part being the Set operators. Part of that is likely the fact that those associative types aren't used as much (at least in what I do), but I wonder how much is up to their current design.

[00:27] <skids> ahem.  ReHashing...

[00:27] <skids> :-)

[00:27] *** BenGoldberg joined
[00:28] <ShimmerFairy> I personally like that the R in GLR is slowly becoming whatever it can be :P (and I hope to help in making that the case)

[00:29] <AlexDaniel> yea, finally

[00:31] *** spider-mario left
[00:32] *** yqt left
[00:37] <TEttinger> Great List Rapoff

[00:38] <dalek> rakudo-star-daily: 2280a8f | coke++ | log/MoarVM- (5 files):

[00:38] <dalek> rakudo-star-daily: today (automated commit)

[00:38] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/2280a8f5cf

[00:38] <AlexDaniel> i

[00:39] <AlexDaniel> m: say index 'yy', 'y', -999999999999999999999999999999999999999999999999999999999999999;

[00:39] <camelia> rakudo-moar a32c14: OUTPUT«Nil␤»

[00:39] <AlexDaniel> m: say index 'yy', 'y', -9999999999999999999999999999999999999999999999999999999999999999;

[00:39] <camelia> rakudo-moar a32c14: OUTPUT«1␤»

[00:39] *** laouji left
[00:40] *** laouji joined
[00:40] *** captain-adequate left
[00:41] <smls> TimToady: I could dig into this stuff further and maybe come up with some form of RFC, but if there's no "political will" to change anything in that area anymore, I needn't bother.

[00:42] *** laouji left
[00:42] *** laouji joined
[00:45] <BenGoldberg> ShimmerFairy, GLR = (G)reat (L)ist whateve(R)

[00:50] *** TEttinger left
[00:51] <BenGoldberg> m: .say for index('yy', 'y', -1e34), index('yy', 'y', -1e35); 

[00:51] <camelia> rakudo-moar a32c14: OUTPUT«Nil␤0␤»

[00:52] <AlexDaniel> BenGoldberg: I've just submitted it: https://rt.perl.org/Public/Bug/Display.html?id=125784

[00:53] <AlexDaniel> but it would be great to know why does it happen

[00:53] <AlexDaniel> m: say split('', "a;b;c").perl;

[00:53] <camelia> rakudo-moar a32c14: OUTPUT«("", "a", ";", "b", ";", "c", "")␤»

[00:54] <AlexDaniel> empty strings?

[00:57] <ShimmerFairy> not sure if that's a bug or not, but if you're looking to split things into characters, you want .comb anyway.

[00:57] <AlexDaniel> I'm looking for a bug

[00:59] <AlexDaniel> .oO(maybe there is another function to do that)

[01:00] * smls added simple type graphs to https://github.com/perl6/doc/issues/116

[01:01] <AlexDaniel> m: say split(//, "a;b;c").perl;

[01:01] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jP3UgDZBS5␤Null regex not allowed␤at /tmp/jP3UgDZBS5:1␤------> 3say split(//7⏏5, "a;b;c").perl;␤»

[01:01] <BenGoldberg> On the one hand, the empty strings at the beginning and ending of the result do seem a bit odd.  On the other hand, the documentation for .split says that if the delimiter is a string, it will be searched for literally, and that empty chunks in the result will not be thrown away.

[01:02] <BenGoldberg> m: say "a;b;c".split(qx//).perl

[01:02] <camelia> rakudo-moar a32c14: OUTPUT«qx, qqx is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:1␤  in sub QX at src/RESTRICTED.setting:11␤  in block <unit> at /tmp/8gYvMdK1vh:1␤␤»

[01:02] <BenGoldberg> m: say "a;b;c".split(qr//).perl

[01:02] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/vAMtG95IEU␤Unsupported use of qr for regex quoting; in Perl 6 please use rx//␤at /tmp/vAMtG95IEU:1␤------> 3say "a;b;c".split(qr7⏏5//).perl␤»

[01:03] <BenGoldberg> m: say "a;b;c".split(rx//).perl; # stupid fingers.  They prefer to type perl5, even when they should know otherwise! ;)

[01:03] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/U14xx6T9CK␤Null regex not allowed␤at /tmp/U14xx6T9CK:1␤------> 3say "a;b;c".split(rx/7⏏5/).perl; # stupid fingers.  They prefer ␤»

[01:03] <smls> BenGoldberg: splitting into characters is what .comb is for

[01:04] <BenGoldberg> m: say "a;b;c".split(rx/. ** 0..0/).perl;

[01:04] <camelia> rakudo-moar a32c14: OUTPUT«("", "a", ";", "b", ";", "c", "")␤»

[01:06] <BenGoldberg> smls, This isn't python.  There *is* more than one way to do it.

[01:10] *** jkva joined
[01:13] <ShimmerFairy> For those null regexes, you wanted this, I believe:

[01:13] <ShimmerFairy> m: say "a;b;c".split(/<?>/)

[01:13] <camelia> rakudo-moar a32c14: OUTPUT« a ; b ; c ␤»

[01:13] <ShimmerFairy> m: say "a;b;c".split(/<?>/).perl

[01:13] <camelia> rakudo-moar a32c14: OUTPUT«("", "a", ";", "b", ";", "c", "")␤»

[01:14] <AlexDaniel> same empty strings

[01:14] *** jkva left
[01:14] <AlexDaniel> hm

[01:15] <ShimmerFairy> m: "a;b;c" ~~ m:g/<?>/; say $/».from

[01:15] <camelia> rakudo-moar a32c14: OUTPUT«0 1 2 3 4 5␤»

[01:16] *** smls left
[01:16] <ShimmerFairy> <?> (and '' as well) match every string position, so .split causes a split at each of those positions. For positions 0 and 5, that means one side is the empty string

[01:16] <ShimmerFairy> (keeping in mind that regex positions are _between_ characters, like a |-style typing cursor)

[01:20] <Juerd> m: say "a;b;c".split(/<after .><before .>/).perl  # silly

[01:20] <camelia> rakudo-moar a32c14: OUTPUT«("a", ";", "b", ";", "c")␤»

[01:20] <ShimmerFairy> Juerd: heh, that's shorter than my version :P

[01:20] <AlexDaniel> m: say split(';', 'a;b;c', :all).perl;

[01:20] <camelia> rakudo-moar a32c14: OUTPUT«(("a", ";"), ("b", ";"), "c")␤»

[01:20] <ShimmerFairy> m: say "a;b;c".split(/<!before ^> <?> <!before $>/).perl

[01:20] <AlexDaniel> list of lists?

[01:20] <camelia> rakudo-moar a32c14: OUTPUT«("a", ";", "b", ";", "c")␤»

[01:21] *** cognominal left
[01:21] <AlexDaniel> http://doc.perl6.org/routine/split#class_Cool has a different example

[01:21] <Juerd> m: say "a;b;c".split(/<?>/).grep({ .length }).perl

[01:21] <camelia> rakudo-moar a32c14: OUTPUT«Method 'length' not found for invocant of class 'Str'␤  in block <unit> at /tmp/dkIiW1euSp:1␤␤»

[01:22] <Juerd> m: say "a;b;c".split(/<?>/).grep({ .chars }).perl

[01:22] <camelia> rakudo-moar a32c14: OUTPUT«("a", ";", "b", ";", "c")␤»

[01:22] <Juerd> m: say "a;b;c".split(/<?>/).grep(*.chars).perl

[01:22] <ShimmerFairy> AlexDaniel: not sure if that's intended, but the way it is has a nice effect of giving you some information on what the split information is like

[01:22] <camelia> rakudo-moar a32c14: OUTPUT«("a", ";", "b", ";", "c")␤»

[01:22] <ShimmerFairy> m: say split(';', ';a;b;c;', :all).perl;

[01:22] <camelia> rakudo-moar a32c14: OUTPUT«(("", ";"), ("a", ";"), ("b", ";"), ("c", ";"), "")␤»

[01:23] <ShimmerFairy> the "cdr" of each list contains what you split on in front of the "car" of each list, if the last element is the empty string you know the string ended in a split-upon thing, and if the "car" of the first list is the empty string you know the string started in a split-upon thing

[01:23] <AlexDaniel> ShimmerFairy: every odd element is a delimiter anyway, isn't it?

[01:23] <ShimmerFairy> AlexDaniel: yes, especially once you flatten the list :)

[01:24] <AlexDaniel> anyway, the example is wrong

[01:24] <AlexDaniel> or the implementation is wrong

[01:25] <ShimmerFairy> that's certain :) . But like all list-related things, there's a weird feeling (at least for me) of waiting for the looming GLR to come in and change how things work.

[01:25] <AlexDaniel> uhhhh

[01:25] <AlexDaniel> ok, then it's time to get some sleep

[01:26] <ShimmerFairy> g'night, AlexDaniel o/

[01:26] <ShimmerFairy> To be clear, there's nothing wrong with fixing either .split or the documentation, but (again, at least for me) the GLR means anything list-related has some extra uncertainty around it for the time being.

[01:27] <AlexDaniel> that's ok, I wrote it down in my notes

[01:27] <AlexDaniel> I'll check it later

[01:49] *** llfourn joined
[01:51] *** pdcawley_ left
[01:52] *** millican joined
[01:56] *** millican left
[01:59] <dalek> rakudo/jvm-testing: 68623c9 | hoelzro++ | .travis.yml:

[01:59] <dalek> rakudo/jvm-testing: Test JVM backend on Travis

[01:59] <dalek> rakudo/jvm-testing: review: https://github.com/rakudo/rakudo/commit/68623c92d3

[02:04] <ShimmerFairy> Hm. When a string begins with a mark (category M) character, Perl 6's parser correctly parses that as a double-quote with a diacritic, for example. My question is, should delimiters be matched under :ignoremark (with the marks ignored perhaps then being picked up as being inside the delimited thing), should they be considered a distinct delimiter, or should they be left as they are?

[02:04] <ShimmerFairy> m: say q[̈hello[̈

[02:04] <camelia> rakudo-moar a32c14: OUTPUT«hello␤»

[02:04] <dalek> rakudo/jvm-testing: 7247fe2 | hoelzro++ | .travis.yml:

[02:04] <dalek> rakudo/jvm-testing: Temporarily remove branch restriction on Travis

[02:04] <dalek> rakudo/jvm-testing: review: https://github.com/rakudo/rakudo/commit/7247fe26ee

[02:05] *** TEttinger joined
[02:05] <ShimmerFairy> currently, something like a left bracket with an umlaut is seen as the kind of delimiter you have to repeat. The question is, should [̈hello]̈ work, which would require either :ignoremark or recognizing distinct "marked" delimiters, and if so should [̈̈hello] or [hello]̈ work too (which would only work with :ignoremark)?

[02:06] <ShimmerFairy> A related question is if that initial combining umlaut should be taken as part of a string, or not.

[02:07] <ShimmerFairy> m: say "@̈" ~~ /:ignoremark \@/    # important to note that :ignoremark doesn't work generally at the moment

[02:07] <camelia> rakudo-moar a32c14: OUTPUT«Nil␤»

[02:19] *** travis-ci joined
[02:19] <travis-ci> Rakudo build failed. Rob Hoelz 'Temporarily remove branch restriction on Travis'

[02:19] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/75019582 https://github.com/rakudo/rakudo/compare/68623c92d332...7247fe26ee11

[02:19] *** travis-ci left
[02:20] *** davido__ left
[02:22] *** davido__ joined
[02:22] *** aborazmeh joined
[02:22] *** aborazmeh left
[02:22] *** aborazmeh joined
[02:22] *** aborazmeh left
[02:23] *** dayangkun joined
[02:25] *** aborazmeh joined
[02:25] *** aborazmeh left
[02:25] *** aborazmeh joined
[02:28] <dalek> rakudo/nom: 68623c9 | hoelzro++ | .travis.yml:

[02:28] <dalek> rakudo/nom: Test JVM backend on Travis

[02:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68623c92d3

[02:33] *** labster joined
[02:37] *** noganex_ joined
[02:39] *** noganex left
[02:41] *** travis-ci joined
[02:41] <travis-ci> Rakudo build failed. Rob Hoelz 'Test JVM backend on Travis'

[02:41] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/75021291 https://github.com/rakudo/rakudo/compare/7a29f16cb224...68623c92d332

[02:41] *** travis-ci left
[02:48] *** AlexDaniel left
[02:54] <[Coke]> ignoremark is for the content, not the delimeter, I thought.

[02:57] <ShimmerFairy> [Coke]: well, I was talking for the Perl 6 parser, should it use ignoremark to match delimiters, or otherwise recognized Ps/Pe/Pi/Pf characters with marks as "marked" version of such, or neither.

[02:58] <ShimmerFairy> *recognize

[02:58] *** llfourn left
[03:05] <dalek> roast: 9df21c3 | ShimmerFairy++ | fudge:

[03:05] <dalek> roast: Fix 'eval' fudge to use EVAL() instead of eval()

[03:05] <dalek> roast: review: https://github.com/perl6/roast/commit/9df21c32e5

[03:05] <dalek> roast: 40ff238 | ShimmerFairy++ | S15-literals/ (2 files):

[03:05] <dalek> roast: Add tests for Unicode literals

[03:05] <dalek> roast: 

[03:05] <dalek> roast: This adds two new test files, one for identifiers and one for numbers.

[03:05] <dalek> roast: The numbers one is fudged for rakudo for now, but the identifiers one

[03:05] <dalek> roast: already passes for rakudo :) .

[03:05] <dalek> roast: review: https://github.com/perl6/roast/commit/40ff23822f

[03:09] *** bin_005_p joined
[03:11] *** jkva joined
[03:15] *** jkva left
[03:19] <skids> .tell jnthn https://gist.github.com/skids/edac2cebdab5c6bd7641 # did not get far -- but hey, actual error messages do help, right?

[03:19] <yoleaux> skids: I'll pass your message to jnthn.

[03:21] <[Coke]> I would argue it probably shouldn't match any marks on quoting chars

[03:21] <[Coke]> (delims)

[03:23] *** llfourn joined
[03:24] <ShimmerFairy> The minimum case would be an error that you started the contents with an M category character (that should definitely be the error if you start a variable name with an M category char, for example), I just wonder if there isn't a nicer solution than giving up so quickly.

[03:26] <ShimmerFairy> Since you can start a string with a mark by using \x or \c, at least for strings I don't think it's necessary to consider the mark as the first codepoint of content.

[03:30] <ShimmerFairy> I personally think it'd be neat to be able to use, say, umlauted braces for embedded comments and such, but it's certainly not the only solution :) .

[03:31] *** gfldex left
[03:41] *** bin_005_p left
[03:45] *** millican joined
[03:46] *** laouji left
[03:52] <ugexe> while its a good idea to travis test jvm, it probably does not help our image to have a prominent `build failing` badge due because of a secondary VM target

[03:55] <ugexe> i would suggest an allowed failure for JVM, as seen here: https://github.com/ugexe/zef/blob/master/.travis.yml#L8-L10

[04:05] *** leont left
[04:15] *** skids left
[04:30] *** davido___ joined
[04:32] *** davido__ left
[04:34] *** BenGoldberg left
[04:47] *** [Sno] left
[04:50] *** xinming_ joined
[04:51] *** laouji joined
[04:53] *** xinming left
[05:01] <TimToady> .tell jnthn maybe it's not either/or; perhaps Slip is a role that can be composed with Nil?

[05:01] <yoleaux> TimToady: I'll pass your message to jnthn.

[05:11] *** Possum left
[05:12] *** jkva joined
[05:16] *** jkva left
[05:26] *** millican left
[05:43] *** xinming_ left
[05:44] *** xinming joined
[05:55] *** rurban joined
[05:58] *** jkva joined
[05:58] *** diana_olhovik joined
[06:07] *** mr-foobar left
[06:10] *** mr-foobar joined
[06:13] *** Possum joined
[06:15] *** gfldex joined
[06:16] *** jjido joined
[06:21] *** [Sno] joined
[06:21] <[Tux]> test             50000    43.501    43.120

[06:21] <[Tux]> test-t           50000    42.463    42.082

[06:22] <[Tux]> HLL still unfixed

[06:32] *** kurahaupo left
[06:35] *** ecocode joined
[06:42] *** fxer joined
[06:43] *** TimToady left
[06:52] *** TimToady joined
[06:54] <Sgeo> m: say "a".index("b")

[06:54] <camelia> rakudo-moar a32c14: OUTPUT«Nil␤»

[06:55] <Sgeo> I'd ask why not redefine truthiness to be definedness, but False is defined and falsey and really, really needs to be both

[06:56] *** yeahnoob joined
[06:56] *** RabidGravy joined
[07:00] <RabidGravy> marning!

[07:00] <Sgeo> hi

[07:00] <Sgeo> I should be asleep

[07:01] *** baest_ joined
[07:02] *** baest left
[07:04] *** fxer left
[07:09] *** fxer joined
[07:11] *** SamuraiJack joined
[07:13] *** aborazmeh left
[07:16] *** mr-foobar left
[07:20] *** fxer left
[07:22] <RabidGravy> Boo! it appears the RT#125408 has come back (and the canary test does fail)

[07:24] *** zakharyas joined
[07:27] *** jjido left
[07:31] *** fxer joined
[07:33] *** mr-foobar joined
[07:36] *** fxer left
[07:41] *** araujo joined
[07:43] *** mr-foobar left
[07:44] <lizmat> smls: re http://irclog.perlgeek.de/perl6/2015-08-11#i_11036392 

[07:45] <lizmat> it should be noted that part of the "mess" regarding Hash and friends, is caused by the fact that no backend has an implementation of object hashes

[07:46] <lizmat> the spec assumes all hashes are object hashes, and the ones with Str are a special case of it

[07:46] <lizmat> in reality, it's the other way around: all hashes have Str for keys, object hashes needed to be bolted on to that

[07:46] <lizmat> personally, I don't think this is going to be fixable before Christmas

[07:47] <jnthn> lizmat: I don't think that's the "mess" he's refering to, fwiw. That's more an implementation detail.

[07:47] <yoleaux> 10 Aug 2015 23:18Z <b2gills> jnthn: Any.join should have an optional or default separator

[07:47] <yoleaux> 03:19Z <skids> jnthn: https://gist.github.com/skids/edac2cebdab5c6bd7641 # did not get far -- but hey, actual error messages do help, right?

[07:47] <yoleaux> 05:01Z <TimToady> jnthn: maybe it's not either/or; perhaps Slip is a role that can be composed with Nil?

[07:47] <jnthn> .tell TimToady Slip is just a subclass of List, and it really needs to be that way... I guess Nil could be a role maybe...

[07:48] <yoleaux> jnthn: I'll pass your message to TimToady.

[07:48] <jnthn> lizmat: I think it's more the EnumMap and PairMap types

[07:48] <jnthn> tbh I'd just rename EnumMap to Map

[07:48] <jnthn> There's nothing enum about it

[07:48] <lizmat> well, as I'm more familiar with QuantHash and anything below it, I agree it's a mess

[07:48] <lizmat> but it works :-)

[07:49] <jnthn> On the inside, or the outside?

[07:49] <ShimmerFairy> Yeah, it's specifically the fact that non-Hash Associative things in core are a bit more mysterious than most core types :)

[07:49] <ShimmerFairy> (to the average user)

[07:49] <lizmat> jnthn: on the inside

[07:49] <jnthn> lizmat: Right, I think smls is talking about on the outside.

[07:49] <jnthn> lizmat: I'm not too concerned about the insides wrt 6.christmas; insides we're free to fix down the line. :)

[07:50] <lizmat> indeed, that's why I'm not too worried either :-)

[07:50] <jnthn> I think the Set/Bag/Mix stuff at least got well thought out at some point

[07:50] <lizmat> yeah, but the implementation does not match the spec wrt to hierarchy

[07:50] <jnthn> But yeah, what is PairMap for is one good question, and why does EnumMap have the word Enum in it and why is an immutable Pair an Enum? :)

[07:51] <jnthn> It's really confusing because they have nothing to do with the enum keyword.

[07:51] <lizmat> well, I implemented PairMap because it hadn't been done yet and was reatively easy

[07:51] <ShimmerFairy> I think the Set/Bag/MixHash types would do better if 'Hash' were instead a more descriptive name for the fact that it's mutable. (But maybe it already is and it's my fault I'm not familiar enough with the word 'Hash' :P)

[07:52] <lizmat> SetMut BagMut MixMut  :-)

[07:52] <jnthn> ShimmerFairy: I think the quoting stuff's behavior is consistent with an NFG world view. I don't have any desire to make quote parsing more complex. In an NFG world you basically never see something of mark category unless you specifically write \c[COMBINING CUTE ABOVE] or whatever.

[07:53] <jnthn> Well, once you know %h is called a Hash (and you know it's mutable) then *Hash is pretty nicely indicative of "it's a Hash with some different semantics".

[07:54] *** rurban_ joined
[07:54] <jnthn> Hash is just from the computer science name for the data structure ("hash table")

[07:54] <ShimmerFairy> Fair enough on Hash, but approaching it from the angle of "I know what Set/Bag/Mix are, what are these *Hash versions?", it's a bit less obvious :)

[07:54] <jnthn> True, though we can document that, and it's predictable given its a productive suffix. :)

[07:55] <ShimmerFairy> (but I don't doubt that "I know what Hash is, what are these Set/Bag/MixHash things?" is an angle that leads to a more immediate understanding)

[07:56] <ShimmerFairy> jnthn: and on NFG, the non-ignoremark idea would mean somehow carrying the Ps/Pe/Pi/Pf info from the base codepoint through to the composed thing, which would be very tricky I imagine.

[07:57] <jnthn> ShimmerFairy: Is there any real reason it can't just stay as it is?

[07:57] <jnthn> ShimmerFairy: I don't see the problem at all. If you use one of a certain set of graphemes that have an opening/closing pair, you get the opener/closer semantics.

[07:57] <ShimmerFairy> jnthn: no, not really. I just thought it'd be neat if it didn't error out, but what not-an-error looks like is admittedly interesting.

[07:58] <jnthn> ShimmerFairy: If you use any other grapheme that's acceptable as a quoting character then you get the identical closer thing. If you put a mark on a [ it's a different grapheme.

[07:58] <JimmyZ> so I am not the only one who thinks why EnumMap has Enum :)

[08:01] <ShimmerFairy> Theoretically it would possibly look like /$<open>=(<C/ \" <:Mark>* />) ~ $<open> [stuff]/ to parse a double-quote with funny marks, for example (using those "grapheme exploders" in S15 that are a bit of small extra feature)

[08:01] <dalek> rakudo/nom: 14939e3 | lizmat++ | src/core/Cool.pm:

[08:01] <dalek> rakudo/nom: Handle out-of-bounds pos in index/rindex better

[08:01] <dalek> rakudo/nom: 

[08:01] <dalek> rakudo/nom: Fixes #125784

[08:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14939e39d2

[08:02] <ShimmerFairy> jnthn: I at least hope for descriptive "misplaced Mark character" message somewhere in the distant future, for things like  my $̈starts-with-umlaut  ; (where you accidentally gave perl6 a "dollar sign with umlaut" grapheme)

[08:04] <dalek> roast: 128708a | lizmat++ | S32-list/minmax.t:

[08:04] <dalek> roast: Fix number of tests to run

[08:04] <dalek> roast: review: https://github.com/perl6/roast/commit/128708af7f

[08:07] * ShimmerFairy wonders if the other Great Compiler Writers ever find themselves with unstaged changes across all three of MVM, nqp, and rakudo, or if she's just bad at git-ing properly :P

[08:09] *** rindolf joined
[08:09] <arnsholt> I haven't worked much on Moar, but a bunch of interlocking changes on both NQP and Rakudo, sure

[08:11] <dalek> Inline-Perl5: 85c5641 | (Stefan Seifert)++ | / (4 files):

[08:11] <dalek> Inline-Perl5: New sugar for v6::inline constructors

[08:11] <dalek> Inline-Perl5: 

[08:11] <dalek> Inline-Perl5: v6-inline got renamed to v6::inline, because perl does not support

[08:11] <dalek> Inline-Perl5: import lists with the v6-inline parse hack.

[08:11] <dalek> Inline-Perl5: 

[08:11] <dalek> Inline-Perl5: You can now use v6::inline constructors => [qw(create)]; to

[08:11] <dalek> Inline-Perl5: automatically get a constructor called "create" that wraps a method of

[08:11] <dalek> Inline-Perl5: the same name you inherited and sets everything up, so you get an object

[08:11] <dalek> Inline-Perl5: of the Perl 6 subclass v6::inline created.

[08:11] <dalek> Inline-Perl5: 

[08:11] <dalek> Inline-Perl5: For example in a DBIx::Class::Result class, you normally inherit

[08:11] <dalek> Inline-Perl5: constructors called "new" and "inflate_result". You can write your

[08:11] <dalek> Inline-Perl5: Result class in Perl 6 by adding:

[08:11] <dalek> Inline-Perl5: 

[08:11] <dalek> Inline-Perl5: use v6::inline constructors => [qw(new inflate_result)];

[08:11] <dalek> Inline-Perl5: method foo() { ... }

[08:11] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/85c56414d1

[08:11] <dalek> roast: e29df31 | lizmat++ | S32-str/ (2 files):

[08:11] <dalek> roast: Add tests for #125784

[08:11] <dalek> roast: review: https://github.com/perl6/roast/commit/e29df31538

[08:12] <ShimmerFairy> Yeah, I think need to go back, make some branches, and make some incremental commits before the size of the changes get too out of hand :)

[08:13] <ShimmerFairy> (It's funny to think "oh, I'll fix this problem!" and within two seconds you trace it down to the virtual machines :P)

[08:13] <RabidGravy> yeah, I find that frequent commits make merging upstream changes less fraught

[08:13] <lizmat> afk&

[08:15] *** bjz joined
[08:16] <ShimmerFairy> I think it'll help immensely with the fact that just what I've been doing tonight has really annoyed me in the part where I very frequently switch between three repos, and thus also makes me worry I'll forget what I've done :)

[08:17] * jnthn has a tab on his terminal for each, always consistently ordered :)

[08:17] *** g5 joined
[08:18] <ShimmerFairy> jnthn: I had to upgrade to two tabs dedicated to P6 work, so I could at least have one on MVM :)  (I've got 10 tabs total)

[08:18] *** dakkar joined
[08:19] *** travis-ci joined
[08:19] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Handle out-of-bounds pos in index/rindex better

[08:19] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/75049615 https://github.com/rakudo/rakudo/compare/68623c92d332...14939e39d245

[08:19] *** travis-ci left
[08:26] *** laouji left
[08:30] *** laouji joined
[08:46] *** bjz left
[08:51] *** brrt joined
[08:53] *** espadrine joined
[08:56] *** davido___ left
[08:58] *** davido___ joined
[09:01] *** telex left
[09:02] *** telex joined
[09:04] *** fling left
[09:04] *** jkva left
[09:10] *** fling joined
[09:14] <dalek> Inline-Perl5: 6b39211 | (Stefan Seifert)++ | lib/Inline/Perl5.pm6:

[09:14] <dalek> Inline-Perl5: Avoid creating circular inheritance hierarchies in v6::extend

[09:14] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/6b392113b4

[09:16] *** fling left
[09:17] *** fling joined
[09:20] *** jkva joined
[09:22] *** fling left
[09:22] *** fling joined
[09:28] *** smls joined
[09:30] *** itz is now known as _itz

[09:31] *** itz joined
[09:31] <itz> mornin'

[09:35] <smls> hi itz

[09:37] <RabidGravy> mornin itz

[09:49] *** brrt left
[09:54] *** yeahnoob left
[10:00] *** tinyblak left
[10:02] *** darutoko joined
[10:02] *** tinyblak joined
[10:04] *** |Tux| left
[10:07] *** leont joined
[10:08] <dalek> doc: f05cce9 | lizmat++ | lib/Type/Supply.pod:

[10:08] <dalek> doc: Document signal()

[10:08] <dalek> doc: review: https://github.com/perl6/doc/commit/f05cce98bd

[10:09] <smls> "is SuperClass", what's that?

[10:09] *** jkva left
[10:09] *** tinyblak left
[10:09] *** |Tux| joined
[10:10] <smls> in https://github.com/perl6/doc/blob/master/lib/Type/Supply.pod

[10:10] <smls> m: say SuperClass

[10:10] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/V6gzCkBc4M␤Undeclared name:␤    SuperClass used at line 1␤␤»

[10:11] *** jkva joined
[10:11] <jnthn> wtf is SuperClass?

[10:12] <jnthn> Like SuperMan, but it runs methods instead of flies?

[10:12] <smls> git blame's moritz

[10:13] <jnthn> :)

[10:13] <jnthn> I suspect it was a copy-pasto

[10:13] <smls> something like that

[10:13] <jnthn> Or a template fill-out failure

[10:13] <jnthn> I'd just remove it :)

[10:13] <smls> ok

[10:13] *** TimToady left
[10:15] *** jkva left
[10:15] *** TimToady joined
[10:15] <dalek> doc: 20e6c88 | smls++ | lib/Type/Supply.pod:

[10:15] <dalek> doc: remove left-over fragment from type page template

[10:15] <dalek> doc: review: https://github.com/perl6/doc/commit/20e6c882eb

[10:16] <smls> jnthn: You were right, it's part of the template at https://github.com/perl6/doc/blob/master/CONTRIBUTING.md

[10:17] <RabidGravy> lizmat, there appears to a few places in the Supply.pod where "elements" is used rather than "events" is that just accidental?

[10:18] <smls> I suppose events are the elements of a Supply?

[10:18] <smls> Though "events" is clearer

[10:19] *** jkva joined
[10:19] <RabidGravy> and used most of the way through the document, it's just the methods lizmat added the other day

[10:23] <jnthn> I wonder whether we'll want to call the things you get from working through a Seq "elements" or not.

[10:24] <smls> "values" always works

[10:24] <jnthn> Yeah :)

[10:24] <jnthn> For both

[10:24] *** rurban left
[10:24] <jnthn> Maybe we can use elements for talking about actual storage slots in a reified data structure, and values for things "on the move"

[10:24] <jnthn> Using values for Seq and Supply kinda emphasizes the duality

[10:25] *** baest_ left
[10:25] *** baest joined
[10:25] <ShimmerFairy> jnthn: have you figured out the Seq.perl question yet? My first though is something like  "{self.VAR.name}.list.Seq"  , depending on if you can convert to a Seq and if you can get the containing variable's name like that :P

[10:27] <dalek> doc: 0bcc5fb | RabidGravy++ | lib/Type/Supply.pod:

[10:27] <dalek> doc: change a few 'element' to 'event'

[10:27] <dalek> doc: review: https://github.com/perl6/doc/commit/0bcc5fb2dc

[10:27] <jnthn> ShimmerFairy: It's a tricky one. If somebody does @foo.map(*.bar).perl then they might like to see the results...

[10:27] <RabidGravy> I changed most of them

[10:27] <RabidGravy> changed one to 'items' as that made more sense in the context

[10:28] <jnthn> ShimmerFairy: We can always self.list.perl ~ '.Seq' maybe..

[10:28] <jnthn> ShimmerFairy: But then .perl'ing a Seq will deplete the iterator

[10:29] <ShimmerFairy> jnthn: as long as you can construct a Seq from a list, then Seq.perl might be one of the rare .perl methods (and those like it) that does more than simply construct a string, by constructing a string _and_ making itself seem as though it were untouched :)

[10:29] <jnthn> ShimmerFairy: So your efforts to debug could give you a problem

[10:29] <jnthn> Yeah, we'd have to maybe make a clone of the iterator...

[10:29] <smls> .gist can just do .list.gist, right?

[10:29] <jnthn> smls: Yeah

[10:29] <ShimmerFairy> jnthn: oh yeah, duh. The simpler solution would be to clone itself and deplete the clone :P

[10:31] <lizmat> RabidGravy: I asked yesterday already...

[10:31] <lizmat> what to call something generically that has been emitted to a Supply

[10:32] <lizmat> (please note that some of the verbage predates the use of "emit()")

[10:32] <RabidGravy> :) 

[10:32] *** spider-mario joined
[10:32] <jnthn> lizmat: Yeah. Today I really do wonder if we should just talk about values, flowing through the chain of supplies.

[10:32] <jnthn> lizmat: Or being pushed through, as opposed to a Seq where they're being pulled through :)

[10:33] *** jkva left
[10:33] <lizmat> "values" works for me

[10:34] <jnthn> Maybe it's 'cus I did the guts of both, but post-GLR the duality between Seq and Supply is a lot more obvious.

[10:34] *** Begi joined
[10:35] <Begi> In Perl5, we have system('command'); What can I use with Perl 6 ? 

[10:35] <ShimmerFairy> Maybe it's because I've been around Perl 6 too long, but I'm really trying to come up with a cute name for what Seqs return :P (not familiar enough with Supplys to try the same)

[10:36] <jnthn> ShimmerFairy: When you iterate them? Just values... :)

[10:36] <RabidGravy> it's conceptually a bit convoluted with Supply because emit can be thought of as creating an event and the value is passed to all the "event handlers"

[10:37] <tadzik> Begi: run() or shell()

[10:37] <smls> Begi:  run('prog', 'arg1', 'arg2')

[10:37] <smls> see http://doc.perl6.org/type/Proc

[10:37] <jnthn> RabidGravy: Do you think it's conceptually a bit convoluted that .map returns a value that is passed to the thing that wanted a value? :)

[10:37] <Begi> Ok, thanks !

[10:37] <tadzik> Begi: or http://doc.perl6.org/routine/shell :)

[10:38] <jnthn> RabidGravy: In both cases you're got code producing a value and some infrastructure making it end up in the right place...

[10:40] <RabidGravy> well yes but that's a generalisation

[10:40] <RabidGravy> :)

[10:41] <smls> jnthn: Is it just me, or does Channel start to look more like a low-level/special-purpose type now that Supply is really comming into its own?

[10:42] *** azawawi joined
[10:42] <azawawi> hi

[10:43] <jnthn> smls: Channels are more about moving data between threads, whereas supplies are more about coordinating flows of data that may originate on many threads, but want actor semantics over the pipeline

[10:44] <azawawi> any idea how to generate POD/markdown documentation on github repos? i.e. to provide inline documentation for module Foo

[10:44] *** RabidGravy left
[10:45] <ShimmerFairy> You can use Pod6 to document stuff, of course, but I don't think github does anything with it (I'm not sure if it does anything with POD5-formatted stuff, even)

[10:45] <azawawi> sort of like metacpan (e.g. https://metacpan.org/pod/distribution/Plack/script/plackup) but on github

[10:46] <azawawi> i think they now support P5 POD https://github.com/github/markup/blob/master/README.md#markups

[10:46] <ShimmerFairy> No, I'm sure github offers nothing like that, aside from however you format your README files :)

[10:48] <ShimmerFairy> (and other files purely in supported formatting styles, that is)

[10:48] <leont> Basically, they seem willing to support any format if you write the implementation

[10:49] *** bjz joined
[10:49] <ShimmerFairy> Pod6 would require either making github run Perl 6 (which might take some time yet), or for some brave soul to attempt writing a Pod6 formatter in some other language :)

[10:50] <lizmat> hmmm... maybe we should change Supply.batch(:elems) to Supply.batch(:nrofvalues) ?

[10:51] <leont> :by ?

[10:51] *** Begi1 joined
[10:52] *** Begi left
[10:52] *** jkva joined
[10:52] <leont> nrofvalues seems to big and isn't really a word

[10:52] <lizmat> eh, no, that's already used with sort and friends

[10:52] <lizmat> yeah, I know, that was just to get the brain cells of everybody reading going :-)

[10:52] <ShimmerFairy> lizmat: my first inclination would be :valno , but perhaps not in something beyond my personal projects :)

[10:52] <lizmat> I mean: :values is ambiguous as well

[10:52] *** rurban joined
[10:53] <jnthn> Well, given batch builds a list of things to emit that has that number of elems, elems is kinda fine.

[10:53] <ShimmerFairy> .oO(obviously it should be  Supply.batch(:#values)  )

[10:53] <jnthn> Provided you appreciate it's talking about the number of elems you'll have in the resulting list. :)

[10:53] <lizmat> yes, it is

[10:54] <jnthn> .batch(:5elems) # I want batches of 5 elements :)

[10:54] *** jkva_ joined
[10:54] <lizmat> that's how it works  :-)

[10:54] <jnthn> Right, I'm saying I think it works OK :)

[10:55] <ShimmerFairy> heh, totally forgot that :5values (for example) would suddenly make it not ambiguous :)

[10:56] *** jkva left
[10:58] *** tinyblak joined
[11:01] <smls> Does anyone know what the story behind the 'EnumMap' and 'Enum' class names is? (Seeing how they have nothing to do with the 'enum' keyword, right?)

[11:03] <azawawi> ShimmerFairy: found it :) https://github.com/github/markup/blob/master/lib/github/markups.rb#L46

[11:03] *** TEttinger left
[11:03] <azawawi> ShimmerFairy: we could add p6 support to github easily :)

[11:03] <azawawi> ShimmerFairy: s/p6/p6 pod/

[11:04] <ShimmerFairy> Not so simple, because P6 unlike P5 is not on every UNIX server on the planet (yet) :)

[11:04] <azawawi> damn 

[11:05] * azawawi looks up rakudo package @ debian

[11:05] <ShimmerFairy> so you'd either have to convince the people at github to install rakudo (so they can use Pod::To::HTML for P6 Pod), or write a Pod6 converter in some other language.

[11:05] <ShimmerFairy> (And honestly, P6's Pod::To::HTML needs some cleanup before I'd be willing to recommend a big site like github to use it)

[11:05] <lizmat> m: say (enum <a b c>).WHAT   # smls

[11:05] <camelia> rakudo-moar a32c14: OUTPUT«(EnumMap)␤»

[11:06] *** Begi1 left
[11:07] *** bjz left
[11:08] <azawawi> ShimmerFairy: true

[11:08] <smls> lizmat: Interesting. So it's just *named* enums that that loose all public connection to that type?

[11:08] <smls> m: enum A <a b c>; say A ~~ EnumMap; A.^mro;

[11:08] <camelia> rakudo-moar a32c14: OUTPUT«False␤»

[11:08] <smls> m: enum A <a b c>; say A ~~ EnumMap; say A.^mro;

[11:08] <camelia> rakudo-moar a32c14: OUTPUT«False␤(A) (Int) (Cool) (Any) (Mu)␤»

[11:09] <ShimmerFairy> The two main issues I have with Pod::To::HTML, to be clear, are 1) that embedded stylesheet (I don't think ::HTML should be embedding a default stylesheet, esp. with no way to turn it off), and 2) the handling of C<=item>s

[11:09] * azawawi wonders if Pod::To::HTML can generate old p5 pod

[11:10] <azawawi> Pod6::To::Pod

[11:10] <ShimmerFairy> Nope, if you want that you'd be looking for Pod::To::POD5 :)

[11:10] <smls> m: enum A <a b c>; say A.enums.WHAT

[11:10] <camelia> rakudo-moar a32c14: OUTPUT«(Hash)␤»

[11:11] <azawawi> ShimmerFairy: hmmm use Pod::To::Markdown  to generate github markdown files :)

[11:12] <ShimmerFairy> I'd rather not support the use of Markdown when we should be using the superior Pod6, though :P

[11:12] <azawawi> ShimmerFairy: frankly i dont see why (for simple cases) we need Pod6 instead of Markdown :)

[11:12] <azawawi> ShimmerFairy: you're typing less with markdown

[11:13] <ShimmerFairy> In reality I don't mind if you use markdown for stuff, I just find a bit disappointing that more Perl 6 stuff (especially the _core_ Perl 6 stuff) isn't using Pod6 :(

[11:13] <ShimmerFairy> *find it

[11:15] <dalek> doc: 214baa0 | lizmat++ | lib/Type/Supply.pod:

[11:15] <dalek> doc: Override previous changes

[11:15] <dalek> doc: review: https://github.com/perl6/doc/commit/214baa0b17

[11:16] <azawawi> ShimmerFairy: take this example https://github.com/sergot/http-useragent#infodoc. sergot++ is doing an excellent job to make his modules documented. Note the @L<line-number> links which can change when edits the files

[11:16] <azawawi> ShimmerFairy: s/edits/one edits/

[11:18] <ShimmerFairy> I don't see why you couldn't link to line numbers like that with Pod L<> codes

[11:19] *** dayangkun left
[11:21] <dalek> roast: 3f1a7a0 | lizmat++ | S17-supply/c (2 files):

[11:21] <dalek> roast: Fix typos

[11:21] <dalek> roast: review: https://github.com/perl6/roast/commit/3f1a7a0eab

[11:21] <azawawi> ShimmerFairy: he was trying to link to actually pod documentation which if it was a seperate .pod file then github would render it into a nice readable HTML document.

[11:21] <azawawi> ShimmerFairy: .pod or .markdown that is

[11:23] <azawawi> ShimmerFairy: s/to actually/to/    # sleepy a bit :)

[11:24] <azawawi> so what's the best practise inline pod, pod at the end of a module or pod seperated from code?

[11:24] <ShimmerFairy> I think after improvements to Pod::To::HTML and at best the September release, we might be able to convince github to be an early player in Perl 6's domination of computers everywhere, just like Perl 5 :)

[11:25] <ShimmerFairy> azawawi: I think the best procedure would be to put description with #|{} or #={} (forget which does which), and have more detailed info in a separate section.

[11:25] <azawawi> ShimmerFairy: do you have an actual example?

[11:25] <ShimmerFairy> If github doesn't want to a doxygen-like thing of processing code for documentation, that's not your fault :)

[11:26] <ShimmerFairy> azawawi: not off-hand, no

[11:26] <ShimmerFairy> I definitely feel like Pod6 has suffered from a lack of widespread usage :/

[11:26] <azawawi> ShimmerFairy: that's the thing that worries you in Pod::To::HTML https://github.com/perl6/Pod-To-HTML/blob/master/lib/Pod/To/HTML.pm#L106 ?

[11:27] <azawawi> simple to use and remember always works :)

[11:27] <ShimmerFairy> azawawi: yes, but that's simple to fix (someone just has to do it :P). The bigger issue is the fact that =item handling is broken (look at the source of any converted HTML with lists, you see the items wrapped in two <li><li>...</li></li> codes, IIRC)

[11:28] <smls> lizmat: Do you also know why EnumMap treats it's entries as Pair's, rather than Enum's as its name suggests? Whereas the Set, Bag and Mix *do* use Enum?

[11:28] <ShimmerFairy> And you want to use =item2 ? Forget about that making sense in the rendered HTML :P

[11:29] <lizmat> not sure, but Enums in Set/Bag/Mix are used because they're immutable

[11:29] <azawawi> ShimmerFairy: just looking at the code, we should have used a Template::Mojo or Template::Mustache and provided the API user a way to define his own templates, right?

[11:29] <ShimmerFairy> ? I don't think templates factor into this.

[11:30] <smls> lizmat: Couldn't one also make an immutable Pair by binding its .value to a non-container?

[11:30] <smls> After all, Pair is already immutable in the sense that EnumMap and Parcel are immutable - you can not add or remove keys.

[11:31] <azawawi> ShimmerFairy: if you're converting X into Y, Generator classes/templates make it easier a bit to override some behavior

[11:31] <smls> It's just that Pair itemizes its value by default

[11:31] <azawawi> ShimmerFairy: please take a look at this ugly hack https://github.com/github/markup/blob/master/lib/github/markups.rb#L47 to see what i mean

[11:31] <ShimmerFairy> Sure, but for Pod it's all about the Pod::To modules, and it's up to them to provide various module-specific options

[11:33] <lizmat> smls: the specifics escape me now, but it used to be possible to change an immutable Set/Bag/Mix when .pairs did not return Enums

[11:33] <smls> lizmat: Alternatively, would anything suffer if Pair behaved like enum does now (no forced itemization), and Hash.pairs just happens to return Pair's with an item container as value?

[11:33] <lizmat> not sure whether you can somehow do that with EnumMap now as well

[11:33] *** firefish5000 left
[11:33] <lizmat> smls: I have no idea

[11:34] *** tinyblak left
[11:37] <itz> what's the status of Native Shaped Arrays?

[11:37] <lizmat> not yet in shape

[11:38] <lizmat> but pretty native

[11:39] *** rurban left
[11:39] <itz> ha! nice summary! quite stealable for some slides

[11:44] *** bjz joined
[11:54] <dalek> doc: 92f44b4 | lizmat++ | lib/Type/Supply.pod:

[11:54] <dalek> doc: Another batch of Supply methods being documented

[11:54] <dalek> doc: review: https://github.com/perl6/doc/commit/92f44b404a

[11:58] *** azawawi left
[11:59] <jnthn> itz: I postponed the shaped stuff at Perl 6 level to post-GLR

[12:00] <jnthn> itz: However, the MoarVM and JVM backends now have support for compact storage of shaped native arrays

[12:00] <jnthn> itz: So the guts are prepared

[12:00] <itz> ok thanks

[12:01] <jnthn> But then I had to switch track and worry about the GLR

[12:02] <nine> I guess all in all GLR >> NSA

[12:03] <jnthn> Well, yeah, I kinda expected the GLR woulda been done by the time I reached shaped arrays

[12:05] *** brrt joined
[12:05] <jnthn> At some point FROGGS was like "jnthn can't do all 3 of NFG, GLR, and NSA". Apparently he can. :P

[12:05] <itz> I still parse GLR as looking like a railway name so switching tracks looks appropriate 

[12:05] <jnthn> :D

[12:05] <jnthn> Great List Railway

[12:08] <arnsholt> Speaking of NFG: For implementing it on JVM, I assume one necessary part of it is replacing most occurences of java.lang.String in NQP/JVM with our own NFGString (or whatever it ends up being called) and a bunch of NFG-related ops. Are there more major parts involved?

[12:09] <jnthn> arnsholt: Also implementing the NFG algorithm, but that's mostly just porting

[12:09] <jnthn> arnsholt: Question is if we have enough of the UCD available to us

[12:09] <jnthn> arnsholt: Certainly we lag behind on JVM in various areas of Unicode support 'cus we don't have all the info

[12:09] <jnthn> arnsholt: So it's worth asking if we want to ditch the JVM's existing normalization support and so on and just implement the whole stack like on MoarVM.

[12:10] <arnsholt> Yeah, that makes sense

[12:10] <jnthn> arnsholt: The lock-free-readable synthetic resolution Trie should port easily.

[12:10] <jnthn> ...wow, that was a lot of buzzwords :P

[12:12] <lizmat> afk until much later today&

[12:13] <brrt> see you

[12:15] *** leont left
[12:19] <ShimmerFairy> jnthn: where does Moar lag behind JVM on Unicode support? (At first glance I'd guess anything to do with the UniHan database)

[12:21] <jnthn> ShimmerFairy: Nowhere that the Perl 6 spectest suite exercises :D

[12:21] <jnthn> ShimmerFairy: I dunno if they get the SpecialCasing.txt stuff right on the JVM.

[12:22] * arnsholt makes an NQP issue for NFG on JVM

[12:22] <jnthn> ShimmerFairy: If so, JVM would be ahead of Moar there.

[12:22] <ShimmerFairy> ah yeah, I saw the XXXs in ucd2c.pl, those are other obvious possible areas :)

[12:22] <jnthn> Aye

[12:22] <jnthn> But I think we provide much broader access to the UCD on Moar.

[12:23] <ShimmerFairy> jnthn: It just surprised me that you said the JVM was ahead in spots; I was kinda under the impression that Moar was one of the more Unicode-supporting VMs out there :)

[12:24] *** leont joined
[12:24] <ShimmerFairy> jnthn: that's true. As a small example, the code I've added to Moar locally (to handle unicode numerals, if you're interested) would be slightly nicer if UPV_Nd wasn't a 'static' variable :)

[12:25] <jnthn> ShimmerFairy: No, I meant JVM is what's lagging behind :)

[12:25] <jnthn> Though I see now I was very confusing in how I wrote it.

[12:26] <ShimmerFairy> jnthn: ah, I thought you were referring to The JVM®, not the nqp implementation on it :)

[12:26] <jnthn> ShimmerFairy: To be clear: there's a bunch of Unicode tests in spectest that we pass on Moar, but not on JVM.

[12:26] <jnthn> And I don't just mean NFG ones.

[12:27] <ShimmerFairy> jnthn: basically I parsed "we lag behind on JVM" as "MVM lags behind compared to JVM" instead of "our nqp implementation is lacking on JVM"

[12:28] <leont> JVM's idea of Unicode is a bit disappointing (surrogates􏿽x85)

[12:28] <jnthn> ShimmerFairy: Yeah, I don't think I coulda worded it more ambiguously if I'd tried. Sorry.

[12:28] <ShimmerFairy> jnthn: I'd be interested in trying to add NFG support to nqp-j, but I'm scared there's a reason why even you hadn't got it working on there :)

[12:29] <DrForr> JVM hamstrung itself when it decided that Unicode codepoints fit in 16 bits.

[12:29] <jnthn> ShimmerFairy: Oh, the reason isn't technical, but project management.

[12:29] <ShimmerFairy> No worries about the parsing issue, if only English were one-pass parsed... :P

[12:29] <jnthn> ShimmerFairy: It's not critical path for 6.christmas.

[12:30] <jnthn> ShimmerFairy: I don't think it'd be too awful to get it working on JVM, just a lot of grunt work.

[12:30] <ShimmerFairy> DrForr: _Unicode_ hamstrung itself when it give UTF-16 (or was it UCS-2?) surrogate code points, instead of the extensible encoding system UTF-8 gives :)

[12:30] <leont> JSON has similar issues due to Javascript inheriting the "let's expose the 16-bit implementation" because \u only accepts 4 hexadecimals, so you have to encode the individual surrogate pairs of a higher plane character

[12:30] <ShimmerFairy> .oO(The Fight for U+110000!)

[12:31] <jnthn> MoarVM was prepared to eventually do NFG from the start, so it wasn't actually a pain to integrate it when the time came.

[12:31] <leont> ShimmerFairy: it doesn't help that the surrogates aren't at the end of the range, so UTF-16 is the only major encoding where character point sort isn't equal to binary-value sort

[12:31] <jnthn> (The VM already had separate "I want graphs" and "I want codes" iterators for over a year before the NFG work started)

[12:32] <ShimmerFairy> leont: I recall when I set up my local mediawiki thing and got to the database part, I specifically chose the option that didn't limit me to a pre-surrogates idea of Unicode :P

[12:32] <ShimmerFairy> m: say "Perl 6.\c[CHRISTMAS TREE]"

[12:32] <camelia> rakudo-moar a32c14: OUTPUT«Perl 6.🎄␤»

[12:35] <ShimmerFairy> jnthn: I'll see how familiar I can get with handling Unicode implementations, and if things go well I might be able to try NFG on nqp-j. jnthn++ for getting the hard work (NFG at all) done, but I'd still like to help how I can with the other Unicode-related stuff :)

[12:36] *** rurban_ left
[12:38] <jnthn> ++ShimmerFairy

[12:38] *** cognominal joined
[12:39] <ShimmerFairy> esp. the non-Str string types, they seem to be lacking at the moment. (The Buf-like nature they display as when you 'say' them was unexpected, but I think it's appropriate ☺)

[12:42] *** leont left
[12:42] <jnthn> Well, if you actually want to write the contents to an IO handle you .write($the-buf)

[12:44] *** cognominal_ joined
[12:45] *** cognominal left
[12:45] <smls> m: say Hash.HOW

[12:45] <camelia> rakudo-moar a32c14: OUTPUT«Method 'gist' not found for invocant of class 'Perl6::Metamodel::ClassHOW+{<anon>}'␤  in block <unit> at /tmp/xWOD9rjVJ2:1␤␤»

[12:46] <smls> ^^ is the +{<anon>} what makes typed Hashes work even though it's not a ParametricRoleGroupHOW ?

[12:47] <ShimmerFairy> As I recall Array and Hash implement their own ^parameterize method

[12:48] <jnthn> smls: Yeah, see the method ShimmerFairy just referred to

[12:49] *** ChoHag joined
[12:52] <smls> Why doesn't ClassHOW implement that method so custom collection types can use it?

[12:53] *** cibs_ joined
[12:53] <jnthn> smls: Why can't they today?

[12:54] <ShimmerFairy> I've also wondered why classes can't be parameterized (without implementing a metamodel method), but I also wonder if there's an interest in leaving that to just roles.

[12:54] <jnthn> smls: The parameterize method in Array doesn't contain any nqp::ops. It's normal Perl 6 code.

[12:55] <smls> ok

[12:55] <jnthn> ShimmerFairy: Roles and classes are rather radically different in how they're compiled.

[12:56] <ShimmerFairy> I would imagine :)

[12:56] <jnthn> A role is a template that you derive concrete things from.

[12:56] *** skids joined
[12:56] <jnthn> That's why you can't augment a role.

[12:56] *** jkva_ left
[12:56] <ShimmerFairy> Ah, so parameterization is more natural to roles, because they're by design abstract thingies.

[12:57] <jnthn> Yeah, parameterization and augmentation are rather incompatible.

[12:57] *** cibs left
[12:59] <jnthn> So basically, anybody who says classes not being parametric is arbitrary just hasn't thought hard enough about things. :P

[12:59] <smls> m: class A does Buf[uint8] {  }; class B is A;

[12:59] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤P6opaque: missing attribute protocol in compose␤»

[12:59] <smls> ^^ is this error due to something specific that Buf does, or is that not allowed in general?

[12:59] <ShimmerFairy> jnthn: I didn't think it was arbitrary, just that the reason was unknown to me :)

[12:59] <smls> i.e. composing a parametric role into a class

[13:00] <jnthn> m: class A does Buf[uint8] {  }; say 'ok'

[13:00] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤P6opaque: missing attribute protocol in compose␤»

[13:00] *** pecastro left
[13:00] <jnthn> m: class A does Buf[uint8] is repr('VMArray') {  }; say 'ok'

[13:00] <camelia> rakudo-moar a32c14: OUTPUT«ok␤»

[13:01] <smls> ah

[13:01] <smls> thanks

[13:01] <jnthn> Buf really wants a low-level array type

[13:01] <jnthn> It's specific to Blob/Buf

[13:01] *** cibs joined
[13:01] *** jkva joined
[13:04] <smls> jnthn: When you say "parameterization and augmentation are incompatible", is that just the run-time augmentation done with `augment`, or also the way classes are assembled at compile-time?

[13:05] *** cibs_ left
[13:06] <jnthn> smls: augment actually runs at compile time, but it may be a compile time other than that of the original compilation unit declaring the class.

[13:06] <jnthn> smls: The point is that when you concretize a role, that involves making copies of a bunch of things.

[13:08] <jnthn> (Which are then "filled in" in various ways)

[13:11] <smls> ok

[13:12] *** rmgk_ joined
[13:12] *** rmgk is now known as Guest77074

[13:12] *** Guest77074 left
[13:12] *** rmgk_ is now known as rmgk

[13:18] <smls> m: say Hash ~~ Cool; say Pair ~~ Cool;

[13:18] <camelia> rakudo-moar a32c14: OUTPUT«True␤False␤»

[13:18] <smls> ^^ Anyone know the reason behind this?

[13:25] *** RabidGravy joined
[13:26] *** tinyblak joined
[13:32] *** muraiki joined
[13:38] <RabidGravy> boom!

[13:43] *** khw joined
[14:04] *** brrt left
[14:07] *** laouji left
[14:08] <tony-o> m: say Pair.^mro

[14:08] <camelia> rakudo-moar a32c14: OUTPUT«(Pair) (Enum) (Any) (Mu)␤»

[14:08] <tony-o> m: say Hash.^mro

[14:08] <camelia> rakudo-moar a32c14: OUTPUT«(Hash) (EnumMap) (Iterable) (Cool) (Any) (Mu)␤»

[14:09] <tony-o> m: say Iterable.^mro

[14:09] <camelia> rakudo-moar a32c14: OUTPUT«(Iterable) (Any) (Mu)␤»

[14:09] <tony-o> smls: because Pair isn't an EnumMap

[14:10] <tony-o> or Cool

[14:10] <smls> I meant, the conceptual reason behind why Hash is Cool but Pair isn't.

[14:10] <smls> In particular, why Hash is Cool.

[14:12] <jnthn> Cool is really a strongly typed way of achieving weak typing.

[14:12] <smls> And I see the benefit of that when it comes to strings + number.

[14:12] <jnthn> It gets you operations that you can sensibly do provided you can coerce to a number and a string.

[14:12] <nine> That's so cool

[14:12] <jnthn> This is in part a hangover from Perl 5 doing so (and the fact that is convenient)

[14:12] *** Zoffix left
[14:13] <smls> m: say Cool.^methods.sort(*.name)

[14:13] <camelia> rakudo-moar a32c14: OUTPUT«EVAL IO Int Num Rat Real UInt abs acos acosec acosech acosh acotan acotanh asec asech asin asinh atan atan2 atanh ceiling chars chomp chop chr chrs cis codes comb conj cos cosec cosech cosh cotan cotanh ends-with exp flip floor fmt index indices lc lines l…»

[14:13] <jnthn> A possible reason Pair doesn't get to be Cool might be there was no Pair in Perl 5

[14:13] <smls> I don't think I'd want to call any of those on a Hash

[14:13] *** pecastro joined
[14:14] *** tinyblak left
[14:16] *** tinyblak joined
[14:16] <smls> jnthn: Well, you can't really call most of those routines on a hash in Perl 5 either, due to aggressive auto-flattening.

[14:17] <smls> Granted, you *can* use arithmetic ops on a hash in Perl 5 to treat it as its number of elements

[14:23] <smls> But with prefix:<+> making that very easy already in Perl 6, that seems like a weak justification to keep it in Cool (while other things that also have an .elemes, such as Set, aren't).

[14:23] *** brrt joined
[14:26] *** rindolf left
[14:31] *** brrt left
[14:33] <tadzik> wow, only 4 open PRs

[14:33] <tadzik> has everyone cancelled thirs? :o

[14:34] *** domidumont joined
[14:35] <RabidGravy> they get superceded, re-done. things get fixed :)

[14:36] <tadzik> so: why does testing stuff require Panda::DepTracker?

[14:38] <RabidGravy> it doesn't, but making the META.info via Panda::Bundler.bundle does

[14:40] <tadzik> right, I'm wondering why Panda::Tester needed changing

[14:40] <tadzik> hehe: https://github.com/tadzik/Typed-Subroutines/issues/4

[14:41] <hoelzro> good morning, #perl6!

[14:42] <tadzik> good morning hoelzro!

[14:42] <[Coke]> hoelzro: there was chat in backlog about perl6 syntax highlighting on github that you can probably weigh in on .

[14:43] <hoelzro> good morning tadzik, [Coke]!

[14:43] <hoelzro> thanks for the backlog tip

[14:43] * hoelzro looks

[14:43] *** domidumont left
[14:43] <itz> wasn't that about p6doc syntax parsing? github does perl6 syntax highlighting

[14:44] <RabidGravy> because, previously Panda::Bundler used to set $*EXECUTABLE to add the -MPanda::DepTracker, this don't work with Proc::Async, Pamda::Bundler collects the loaded ,modules for build, test and by extension run

[14:46] <tadzik> aha, I see

[14:48] <RabidGravy> passing the optional @deps leaves the door open for any future similar things

[14:48] <tadzik> I wonder if I wouldn't rather have something like $*EXECUTABLE_FLAGS that each Panda::SubTask-thingy has to remember to respect, but I won't hold your PR any longer :) It fixes things, that's the most important thing

[14:48] <RabidGravy> :)

[14:53] * itz wonders if 'Gravy is going to the London.pm Tech Meet on Thu what with b33r and perl 6 being there

[14:54] <RabidGravy> tadzik++ # cheers matey

[14:56] <hoelzro> ugexe: nice tip about allowing failures! how does that change the interaction with Travis? you still get a notification, but the build shows up as passing?

[14:58] <tadzik> hrm, anyone who'd rather not have META.list sorted by username?

[14:58] <tony-o> i'd rather have it by module name

[14:58] <tadzik> ah, then I can't do it with sort(1) though :(

[15:01] <dalek> ecosystem: 3e677ef | tadzik++ | META.list:

[15:01] <dalek> ecosystem: Transfer the ownership of File::HomeDir to azawawi++

[15:01] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/3e677ef41a

[15:03] *** jkva_ joined
[15:05] *** jkva left
[15:05] <hoelzro> [Coke]: were you talking about http://irclog.perlgeek.de/perl6/2015-08-11#i_11037871 ?

[15:06] <RabidGravy> itz, I'd hate to break my duck having not been to a London.pm tech meeting ever and all ;-)

[15:06] <[Coke]> I think so.

[15:06] <hoelzro> shoot, azawawi is no longer here =/

[15:08] <itz> RabidGravy: I could ecosystem squat perl6-Acme-XAP :P

[15:08] *** virtualsue joined
[15:10] <smls> In case anyone else is interested in the "general-purpose associative Perl 6 types" situation, I've made a chart giving an overview of the status quo: http://i.imgur.com/aUPdhVk.png

[15:11] <smls> I showed Iterable as a role rather than a class (because the GLR changes that), but otherwise it should match what current Rakudo does. (If not, please correct me.)

[15:12] *** abaugher joined
[15:13] <nine> Wow that's a nice chart! And it shows there to be no system behind this. At least none that I can see.

[15:13] <RabidGravy> itz, feel free :) You may have to write some workflow/state machine malarkey to get it to work though ;-)

[15:15] <RabidGravy> (which is on my todo list but fairly low down)

[15:21] <tony-o> smls++

[15:24] *** brrt joined
[15:27] *** diana_olhovik left
[15:27] *** g5 left
[15:34] *** zakharyas left
[15:48] <smls> m: my $x = 5..10; $x.bounds[1] = 8; dd $x

[15:48] <camelia> rakudo-moar a32c14: OUTPUT«$x = 5..8␤»

[15:48] <smls> ^^ Isn't Range supposed to be an immutable value type?

[15:50] *** rurban_ joined
[15:50] <smls> m: my $r = 5..10; my $s = set $(5..10), $r;   $r.bounds[1] = 8;   dd $s

[15:50] <camelia> rakudo-moar a32c14: OUTPUT«$s = set(5..8)␤»

[15:50] <smls> Looks like a bug.

[15:51] <jnthn> smls: Yeah, looks like one to me too

[15:51] *** rurban joined
[15:58] *** ecocode left
[16:16] *** brrt left
[16:17] *** jkva_ left
[16:19] *** xinming left
[16:20] *** xinming joined
[16:46] *** mr-foobar joined
[16:48] *** jkva joined
[16:51] *** telex left
[16:52] *** telex joined
[16:53] *** fxer joined
[16:55] *** itz left
[17:16] *** diana_olhovik joined
[17:19] *** jkva left
[17:30] *** dakkar left
[17:37] *** rindolf joined
[17:44] *** SamuraiJack left
[17:48] <colomon> m: my $r = 5..10; my $s = set $(5..10), $r;  say $s.perl

[17:48] <camelia> rakudo-moar a32c14: OUTPUT«set(5..10)␤»

[17:51] <smls> m: my $r = 5..10;   say $r === 5..10;  # this is how Set checks identity

[17:51] <camelia> rakudo-moar a32c14: OUTPUT«True␤»

[17:52] <smls> I submitted it as RT #125791 earlier, btw

[17:59] *** llfourn left
[18:02] *** jkva joined
[18:04] *** jjido joined
[18:07] *** tinyblak left
[18:41] *** espadrine left
[18:46] <dalek> doc: 3d461f4 | (Steve Mynott)++ | lib/Type/ (3 files):

[18:46] <dalek> doc: fix minor typos

[18:46] <dalek> doc: review: https://github.com/perl6/doc/commit/3d461f4c64

[18:52] *** domidumont joined
[18:54] <dalek> doc: 73ba4fd | (Steve Mynott)++ | lib/Type/IO/Socket (3 files):

[18:54] <dalek> doc: change various Socket .send to .print

[18:54] <dalek> doc: review: https://github.com/perl6/doc/commit/73ba4fdac3

[19:00] *** khw left
[19:00] *** khw joined
[19:03] *** raiph left
[19:07] *** colomon left
[19:07] *** colomon joined
[19:07] *** virtualsue left
[19:18] *** raiph joined
[19:23] *** yqt joined
[19:27] *** ChoHag left
[19:35] *** nowan left
[19:38] *** nowan joined
[19:54] *** jkva left
[19:56] *** llfourn joined
[19:58] <dalek> rakudo/nom: 7814349 | lizmat++ | src/core/Range.pm:

[19:58] <dalek> rakudo/nom: Make sure Range.bounds is ro, spotted by smls++

[19:58] <dalek> rakudo/nom: 

[19:58] <dalek> rakudo/nom: Fixes #125791

[19:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78143492b8

[20:00] *** llfourn left
[20:01] *** [Sno] left
[20:01] *** domidumont left
[20:03] <dalek> roast: d649801 | lizmat++ | S02-types/range.t:

[20:03] <dalek> roast: Add tests for #125791

[20:03] <dalek> roast: review: https://github.com/perl6/roast/commit/d649801acf

[20:10] *** yqt left
[20:12] *** bin_005 joined
[20:12] *** travis-ci joined
[20:12] <travis-ci> Rakudo build failed. Elizabeth Mattijsen 'Make sure Range.bounds is ro, spotted by smls++

[20:12] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/75151942 https://github.com/rakudo/rakudo/compare/14939e39d245...78143492b868

[20:12] *** travis-ci left
[20:13] <lizmat> is this going to happen for every commit now, until we fix the JVM build?

[20:22] <RabidGravy> or change the travis.yml to shut up about that build

[20:23] <smls> m: $h = EnumMap.new("a" => 5, "b" => 10); $h<b>++; say $h

[20:23] <camelia> rakudo-moar a32c14: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KE4SAN8HJ3␤Variable '$h' is not declared␤at /tmp/KE4SAN8HJ3:1␤------> 3<BOL>7⏏5$h = EnumMap.new("a" => 5, "b" => 10); $␤»

[20:23] <smls> m: my $h = EnumMap.new("a" => 5, "b" => 10); $h<b>++; say $h

[20:23] <camelia> rakudo-moar a32c14: OUTPUT«EnumMap.new(:a(5), :b(11))␤»

[20:23] <smls> my $h = PairMap.new("a" => 5, "b" => 10); $h<b>++; say $h

[20:23] <smls> m: my $h = PairMap.new("a" => 5, "b" => 10); $h<b>++; say $h

[20:23] <camelia> rakudo-moar a32c14: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <unit> at /tmp/J5NofPeBoI:1␤␤»

[20:24] <smls> So itemizing behavior of PairMap and EnumMap is *reversed* compared to what the design docs and p6doc claim?

[20:25] * smls will update the chart

[20:26] <smls> that makes the inheritance chain even weirder though.

[20:26] <ugexe> lizmat: https://github.com/rakudo/rakudo/pull/489

[20:26] *** breinbaas joined
[20:27] <dalek> rakudo/nom: fcf27ae | ugexe++ | .travis.yml:

[20:27] <dalek> rakudo/nom: allow failures on JVM

[20:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fcf27ae07e

[20:27] <dalek> rakudo/nom: c06f4bd | lizmat++ | .travis.yml:

[20:27] <dalek> rakudo/nom: Merge pull request #489 from ugexe/patch-15

[20:27] <dalek> rakudo/nom: 

[20:27] <dalek> rakudo/nom: allow failures on JVM

[20:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c06f4bdd9b

[20:27] <lizmat> ugexe++

[20:27] <lizmat> smls++  # exposing spaghetti

[20:28] <TimToady> smls: the original intent was that enums be immutable and pairs not

[20:28] <yoleaux> 07:47Z <jnthn> TimToady: Slip is just a subclass of List, and it really needs to be that way... I guess Nil could be a role maybe...

[20:30] <TimToady> so if the implementation has them backwards, let's please fix the implementation, not the docs

[20:30] <smls> What if both docs and implementation are backwards in their own way? :P

[20:32] <dalek> specs: b02fdfa | (Steve Mynott)++ | S (2 files):

[20:32] <dalek> specs: fix minor typos

[20:32] <dalek> specs: review: https://github.com/perl6/specs/commit/b02fdfafca

[20:32] <lizmat> m: (a => 42).WHAT.say   # should this be an Enum then ?

[20:32] <camelia> rakudo-moar a32c14: OUTPUT«(Pair)␤»

[20:32] *** rurban_ left
[20:33] <TimToady> no

[20:33] <TimToady> m: (a => my $x).WHAT.say

[20:33] <camelia> rakudo-moar a32c14: OUTPUT«(Pair)␤»

[20:33] <skids> ISTR EnumMap was moved for a quick fix allowing it to be initialized, with the (known to be wrong) side-effect of rw access, but then that never got followed up on maybe?

[20:33] <TimToady> note that pairs can be bound to rw parameters

[20:33] *** darutoko left
[20:33] <TimToady> and enums are meant to represent constants

[20:34] <lizmat> a => 42 looks pretty constant to me

[20:34] <TimToady> it contains a constant, sure

[20:34] <TimToady> but pairs are supposed to be more like Lisp cons cells

[20:34] <smls> Couldn't an immutable Pair (in the sense that Parcel, and post-GLR List, is immutable) fuilfil both tasks?

[20:35] *** rindolf left
[20:35] <TimToady> both which tasks?  you certainly can't bind something immutable to a rw parameter and then expect to write to it

[20:36] <TimToady> though one could argue it's immutable like a list, but can hold containers, I suppose

[20:36] <smls> be an immutable constant (hat is safe to use as Set key, for example), but still allow Hash.pairs and similar to be an rw interface

[20:36] <smls> m: my $s = 5; my $l = (4, $s, 6); $s++; say $l

[20:36] <camelia> rakudo-moar a32c14: OUTPUT«4 6 6␤»

[20:37] <smls> simply by having those use-cases that need it, exclicitly pass an item container as value, like ^^

[20:37] <smls> but not enforcing the item container by default

[20:37] <TimToady> might be sane, post-GLR-wise

[20:38] *** yqt joined
[20:39] <smls> then Enum would not be needed anymore

[20:39] <smls> and EnumMap could be renamed to Map, like jnthn++ suggested

[20:39] <smls> and things would already start to look much more friendly in that part of the type hierarchy... :P

[20:41] *** virtualsue joined
[20:44] <TimToady> m: my $p = pair((my $a),(my $b)); $a = 'a'; $b = 42; say $p

[20:44] <camelia> rakudo-moar a32c14: OUTPUT«(Any) => (Any)␤»

[20:44] <TimToady> but in that case, something is deconting that shouldn't

[20:45] <smls> all I know is that it works with pre-GLR Parcel, so surely it can be made to work with others... :P

[20:45] * TimToady --> oil change &

[20:50] *** jkva joined
[20:52] <lizmat> m: my $p = Pair.new(:key(my $a),:value(my $b)); $a = "a"; $b = 42; say $p  # the problem is with Pair.new, not necessarily with pair

[20:52] <camelia> rakudo-moar a32c14: OUTPUT«(Any) => (Any)␤»

[20:54] <smls> http://imgur.com/a/DL1BE  -- update 'associative' types chart, as well as a bonus chart for the 'positional' ones (just for context - those are perfectly fine IMO).

[20:55] *** colomon left
[20:56] *** llfourn joined
[20:57] * japhb catches up with skimming last couple day's worth of backlog

[20:57] *** jkva left
[20:57] <japhb> nine++  # Inline::Perl5, woot!

[20:57] <japhb> It sounds like you're getting closer and closer to "least surprise" for users

[20:57] <japhb> jnthn++  # GLR coding machine

[20:59] *** diana_olhovik left
[21:01] *** llfourn left
[21:03] *** jkva joined
[21:05] *** skids left
[21:05] <ugexe> anyone taken a crack at rakudo on win10 IoT yet?

[21:05] *** oetiker left
[21:06] *** kaare_ left
[21:09] *** jkva left
[21:10] <dalek> specs: 4b6a1fc | lizmat++ | S17-concurrency.pod:

[21:10] <dalek> specs: Kebab-case IO::Notification.watch_path

[21:10] <dalek> specs: 

[21:10] <dalek> specs: Also simplify .IO.watch example

[21:10] <dalek> specs: review: https://github.com/perl6/specs/commit/4b6a1fc316

[21:10] *** virtualsue left
[21:13] *** rurban left
[21:14] *** maettu left
[21:16] *** colomon joined
[21:18] *** diana_olhovik joined
[21:18] <dalek> doc: be54e6a | lizmat++ | lib/Type/Supply.pod:

[21:18] <dalek> doc: Document some more supply methods

[21:18] <dalek> doc: 

[21:18] <dalek> doc: and reorganize the methods in more or less logical groups

[21:18] <dalek> doc: review: https://github.com/perl6/doc/commit/be54e6a686

[21:23] *** diana_olhovik left
[21:24] *** TEttinger joined
[21:30] <dalek> roast: 29c7420 | lizmat++ | S17-supply/watch (2 files):

[21:30] <dalek> roast: Kebab-case watch_path, part 1

[21:30] <dalek> roast: review: https://github.com/perl6/roast/commit/29c74207cf

[21:30] *** raiph left
[21:31] <dalek> roast: d3c4f3b | lizmat++ | S17-supply/watch-path.t:

[21:31] <dalek> roast: Kebab-case watch_path, part 2

[21:31] <dalek> roast: review: https://github.com/perl6/roast/commit/d3c4f3b434

[21:31] *** raiph joined
[21:32] <ugexe> fwiw there is also $in_charge for the 2 ::Async modules

[21:32] *** breinbaas left
[21:33] <dalek> rakudo/nom: 19890c7 | lizmat++ | / (6 files):

[21:33] <dalek> rakudo/nom: Kebab-case IO::Notification.watch_path

[21:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/19890c7199

[21:34] <lizmat> ugexe: that's internal though, isn't it ?

[21:34] <lizmat> watch_path is outward facing

[21:35] <ugexe> yeah

[21:36] <lizmat> so I think I've documented all of Supply's methods now

[21:36] <lizmat> except classify / categorize

[21:36] <lizmat> I was looking at them, and I was thinking to myself: what idiot implemented *that*

[21:36] <lizmat> turns out, not only did I implement it, I also specced it  :-)

[21:37] <lizmat> anyways, I have my doubts about the implementation now, need to look deeper into it before documenting it and thereby exposing it better to the world

[21:38] *** [Sno] joined
[21:40] *** Zoffix joined
[21:45] <japhb> Your harshest critic: your own future self

[21:45] <RabidGravy> I think it kinda works as it is, document, get people using it and take recommendations :)

[21:47] <RabidGravy> a working less than perfect thing is better than a not working ideal thing in these cases :)

[21:48] <dalek> specs: e155c08 | lizmat++ | S17-concurrency.pod:

[21:48] <dalek> specs: Speculate about Supply.throttle($elems,$seconds)

[21:48] <dalek> specs: review: https://github.com/perl6/specs/commit/e155c08e01

[21:53] <RabidGravy> that one's begging for an "atleast"   relative, whereby the taps are called at minimum $secs apart however quickly new values are received

[21:54] <lizmat> are you suggesting treating taps differently?

[21:54] <lizmat> I mean, that not all taps on a given Supply are treated equally?  (as in see all values) ?

[21:55] <lizmat> re-reading: isn't that what Supply.batch does ?

[21:55] <RabidGravy> dunno

[21:57] <smls> RabidGravy: I think jnthn demoed something like that in one of his presentations; don't remember the method name though

[21:57] <lizmat> ah, start/migrate

[21:57] <lizmat> ?

[21:58] *** colomon left
[22:00] <lizmat> m: sub a(\:a) { }

[22:00] <camelia> rakudo-moar a32c14: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[22:00] <RabidGravy> er, no actually what I'm thinking is totally doable with throttle as described

[22:01] <RabidGravy> I'm just stupid is all

[22:02] *** jkva joined
[22:03] <lizmat> will be travelling for ~ 20 hours in about 12 hours from now

[22:03] <lizmat> will look at implementing it on the way

[22:04] <lizmat> for now, I'm going to get some sleep

[22:04] <lizmat> afk&

[22:07] *** jkva left
[22:08] <dalek> specs: 982edab | lizmat++ | S04-control.pod:

[22:08] <dalek> specs: Prevent some confusion re a b c

[22:08] <dalek> specs: review: https://github.com/perl6/specs/commit/982edab7a3

[22:08] *** [particle] joined
[22:08] *** oetiker joined
[22:10] <lizmat> really afk now

[22:15] *** Zoffix left
[22:22] *** Possum left
[22:22] *** Possum joined
[22:23] *** bin_005 left
[22:25] *** fxer left
[22:27] *** colomon joined
[22:30] *** jjido left
[22:31] *** smls_ joined
[22:32] *** smls left
[22:34] *** leont joined
[22:35] *** skids joined
[22:41] *** bjz left
[22:54] *** smls_ left
[22:54] *** Zoffix joined
[22:54] *** Psyche^_ joined
[22:57] *** llfourn joined
[22:59] *** Psyche^ left
[23:02] *** llfourn left
[23:07] *** spider-mario left
[23:09] <RabidGravy> boom! must do sleep. toodlepip

[23:13] * flussence notes out loud that "Stage parse" on nom has gotten significantly slower (around 20%) since about 2 weeks ago

[23:16] *** RabidGravy left
[23:27] *** Psyche^_ left
[23:27] *** Psyche^ joined
[23:28] *** yqt left
[23:28] *** simcop2387 left
[23:30] <flussence> ...and spectest shows a similarly large bump. I haven't been paying close attention to happenings lately though, maybe this is old news.

[23:31] *** jjido joined
[23:34] *** simcop2387 joined
[23:34] <dalek> rakudo-star-daily: c2c9b3c | coke++ | log/MoarVM- (4 files):

[23:34] <dalek> rakudo-star-daily: today (automated commit)

[23:34] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/c2c9b3c68c

[23:34] <dalek> perl6-roast-data: df8a889 | coke++ | / (9 files):

[23:34] <dalek> perl6-roast-data: today (automated commit)

[23:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/df8a88973c

[23:34] <skids> well, tests are growing in number.  Though IIRC someone did trim the timeouts in the async stuff.

[23:35] *** geekosaur left
[23:35] *** jjido left
[23:36] *** simcop2387 left
[23:38] *** geekosaur joined
[23:38] <flussence> I know I'm not being scientific here at all :) -- I did observe a downward trend over time even with thousands of new tests being added, but it's taken a sudden jump lately.

[23:40] <ShimmerFairy> Well, I did notice a very slight increase in startup time for perl6-m. Not that I have any measurements, but I figured that since I never notice startup differences, maybe it means something :)

[23:40] *** simcop2387 joined
[23:40] <ShimmerFairy> (I also haven't see Stage parse: go under 100s for a day or so now)

[23:40] <flussence> 72 here, it used to be about 56...

[23:42] <ShimmerFairy> The new average for me seems to be 104s, where before it was in the high 90s. (Certainly makes me want to start logging CORE's stagestats so I can be moar scientific about it ☺)

[23:48] *** Peter_R left
[23:48] *** telex left
[23:50] *** telex joined
