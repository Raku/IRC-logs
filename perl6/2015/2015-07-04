[00:19] *** Akagi201 left
[00:35] *** Obbi joined
[00:35] *** yogan joined
[00:45] *** steve_mc left
[00:56] *** Sqirrel joined
[01:01] *** patrick__ joined
[01:02] *** patrick__ is now known as caymanboy

[01:03] <caymanboy> Alvaro says hi

[01:03] <caymanboy> from the Cayman Islands

[01:04] <TimToady> howdy

[01:04] <caymanboy> waiting on Perl6 1.0

[01:04] <caymanboy> For Xmas

[01:04] * TimToady fondly remembers a miniature golf course there...

[01:05] <caymanboy> by Bamboo/Deckets on Seven Mile beach?

[01:05] <TimToady> don't remember the name, but it was kind of up on a little hill

[01:06] <TimToady> probably blew away in the hurricane

[01:06] <caymanboy> yes, I pass it almost everyday

[01:06] <caymanboy> nope still there

[01:06] <TimToady> cool, my wife will be glad to hear that

[01:06] <TimToady> gotta get back there someday, but not till after Xmas :)

[01:06] <caymanboy> bring her back.  its grown much since the hurricane

[01:07] <TimToady> I'll look forward to it

[01:08] <caymanboy> Bring her for the "Perl fans in Cayman" tour

[01:10] *** rmgk_ joined
[01:10] *** rmgk is now known as Guest99922

[01:10] *** Guest99922 left
[01:10] *** rmgk_ is now known as rmgk

[01:11] <caymanboy> Brink the wife to www.xqs.ky, rey have a perl6 burger

[01:11] <caymanboy> ^they

[01:19] *** virtualsue left
[01:20] <caymanboy> So could someone splain me is perl6 idenpendent of a vm?  I'm somwhat confused with the parrot vm and other vms

[01:22] <TimToady> yes, perl6 is defined by the test suite, so anything that passes the test suite is official Perl 6

[01:22] <TimToady> so, for instance, the rakudo compiler runs on either MoarVM or on JVM

[01:24] <TimToady> (doesn't run at the moment on parrot, because it was being too hard ot maintain, and we won't get done by Xmas if we try to use too many backends)

[01:28] <caymanboy> I thought at somepoint there was a rakudo implementation on the parrot vm.  for a while  thought parrot and perl6 were somewhat symbiotic

[01:29] *** gfldex left
[01:30] *** colomon joined
[01:31] <TimToady> the goals of the two projects diverged

[01:31] <caymanboy> Have not been keeping up as much as I should have.  been battling my python friends. 

[01:34] <caymanboy> is the xmas date still on the radar?

[01:35] <TimToady> yes, we're going to have some thing by this Christmas

[01:38] <caymanboy> as in 1.0? 

[01:38] <TimToady> well, a first official language test suite, whether it's called 1.0 or somethingelse

[01:39] <TimToady> and at least one implemention of it, on MoarVM (and maybe JVM)

[01:39] <TimToady> language versions being separate from compiler versions, y'see

[01:41] <caymanboy> yes, sort of

[01:44] *** ilbot3 left
[01:46] *** caymanboy left
[01:46] *** ilbot3 joined
[01:47] *** caymanboy joined
[01:53] <TimToady> dinner &

[01:54] <caymanboy> rum

[02:03] *** noganex joined
[02:07] *** beastd left
[02:07] *** noganex_ left
[02:08] *** caymanboy left
[02:14] *** raiph joined
[02:17] <AlexDani`> what's the difference between <somerule> and <.somerule> in grammars?

[02:17] <ugexe> <.somerule> doesnt get captured

[02:18] <ugexe> still matches

[02:18] *** kaare_ joined
[02:48] *** nys left
[03:00] *** kanl joined
[03:08] <AlexDani`> ugexe: yea, thanks!

[03:12] <AlexDani`> is there any way to skip some of the results from the match object but keep their insides? For example: regex cont { <in1> <in2> }, I want to have <in1> and <in2> in the match object but I don't really care about <cont> itself. Using <.cont> will not help because <in1> and <in2> will not be captured.

[03:27] *** amurf joined
[03:29] *** slavik left
[03:31] <raiph> AlexDani`: http://irclog.perlgeek.de/perl6/2015-04-29#i_10522960

[03:32] *** amurf left
[03:33] <raiph> AlexDani`: ^^ prolly worth a read but maybe not what you want

[03:34] <ugexe> i've been using Action classes to clean that type of thing up into a final data structure instead of trying to pass around a huge Match object

[03:34] *** jeyemhex joined
[03:35] *** jeyemhex left
[03:37] <ugexe> i know your pain though. i have stuff like: $http.<HTTP-message>.<header-field>.[1].<value>.<accept-value>.[0].<media-range>.<type>

[03:40] <AlexDani`> raiph: nice stuff anyway

[03:41] *** tjt263 joined
[03:44] *** tjt263 left
[03:47] <dalek> rakudo/nom: c17db6c | (Nick Logan)++ | src/core/Proc (2 files):

[03:47] <dalek> rakudo/nom: Proc.shell/run/spawn and QX :$cwd param

[03:47] <dalek> rakudo/nom: 

[03:47] <dalek> rakudo/nom: Allow setting :$cwd for Proc and Proc::Async.

[03:47] <dalek> rakudo/nom: Lowercase 'cwd' per suggestion.

[03:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c17db6ceb8

[03:47] <dalek> rakudo/nom: ec3605f | lizmat++ | src/core/Proc (2 files):

[03:47] <dalek> rakudo/nom: Merge pull request #460 from ugexe/proc-cwd

[03:47] <dalek> rakudo/nom: 

[03:47] <dalek> rakudo/nom: Proc.shell/run/spawn and QX :$cwd param

[03:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ec3605f3d6

[03:50] <AlexDani`> if I have a regex like: regex stuff { <start> <hardstuff> <end> } is there any way to give a hint to the parser to first find <end> and only then attempt to match <hardstuff> in between <start> and <end>? Basically I want to skip expensive parts by throwing away paths that are obviously wrong.

[03:55] <ugexe> <before hardstuff> or <after start> might work like that

[03:56] *** aborazmeh joined
[03:56] *** aborazmeh left
[03:56] *** aborazmeh joined
[03:57] <AlexDani`> ugexe: I've thought about before and after, but where do I write these to achieve that effect?

[03:58] <ugexe> m: my $x = "abc123"; say $x ~~ /<alpha> <before <digit>>/

[03:58] <camelia> rakudo-moar 0c8852: OUTPUT«｢c｣␤ alpha => ｢c｣␤ before => ｢｣␤»

[04:00] <AlexDani`> hm, and what's the difference between <before and <?before ?

[04:00] *** tinyblak joined
[04:02] <AlexDani`> ugexe: I'll try that, thanks

[04:03] <ugexe> never actually thought about that. i suppose its if you dont care to save the fact its an 'after' or 'before' type match

[04:03] <ugexe> there is also <!before and <!after

[04:12] *** AlexDani` is now known as AlexDaniel

[04:19] *** khw left
[04:21] *** AlexDaniel left
[04:21] <ugexe> so now we have: Proc.out, Proc::Async.stdout, and IO::Socket::Async.[chars|bytes]_supply :o

[04:22] *** aborazmeh left
[04:23] *** Ben_Goldberg left
[04:29] *** Peter_R joined
[04:46] <dalek> roast: f713932 | skids++ | / (2 files):

[04:46] <dalek> roast: Add Test::Idempotency package

[04:46] <dalek> roast: Add some tests for Signature .perl idempotency

[04:46] <dalek> roast: Fudge a few of said tests, RT needed (rakudo misorders subsig/default)

[04:46] <dalek> roast: Add a fudged test for :(:a(:b($a))).perl, RT needed

[04:46] <dalek> roast: review: https://github.com/perl6/roast/commit/f7139323a1

[05:02] *** raiph left
[05:07] *** raiph joined
[05:10] <dalek> roast: 9677e70 | skids++ | S06-signature/introspection.t:

[05:10] <dalek> roast: Remove spurious semicolon from last commit

[05:10] <dalek> roast: review: https://github.com/perl6/roast/commit/9677e70cf0

[05:12] *** vendethiel left
[05:25] *** vendethiel joined
[05:41] <kanl> m: if '[FOO:@]' ~~ /'[' (\w+) ':'? (<-[\]]>*) ']'/ { $0.say; $1.say; my $s = "foo.$0{ $1 ?? "-{ $1 eq '@' ?? 'bar' !! 'baz' }" !! '' }"; $s.say }

[05:41] <camelia> rakudo-moar ec3605: OUTPUT«｢FOO｣␤｢@｣␤Use of Nil in string context  in block  at /tmp/DVqVf9JNoE:1␤foo.␤»

[05:43] *** skids left
[05:44] *** tinyblak left
[05:45] *** tinyblak joined
[05:46] *** Psyche^_ joined
[05:46] *** vendethiel left
[05:47] <kanl> m: if '[FOO:@]' ~~ /'[' (\w+) ':'? (<-[\]]>*) ']'/ { $0.say; $1.say; my $s = "foo.$0-{ $1 ?? "-{ $1 eq '@' ?? 'bar' !! 'baz' }" !! '' }"; $s.say }

[05:47] <camelia> rakudo-moar ec3605: OUTPUT«｢FOO｣␤｢@｣␤foo.FOO--bar␤»

[05:47] <kanl> ok

[05:48] *** raiph left
[05:49] *** tinyblak left
[05:49] *** Psyche^ left
[06:03] *** tinyblak joined
[06:03] <kanl> gurus, if i were to do a global match and replace, and the replacement string needs to be determined by some computation on the match/capture. do i have to wrap .subst inside a loop of match, compute, replace? i suppose it'd make sense to have multi method subst(Str:D: $matcher, $pointy-sub, *%opts)

[06:05] <moritz> kanl: you can just call .subst(:g, $regex, $sub)

[06:06] <kanl> oh? nice! the docs did't say, so i didn't know :p thanks!!

[06:07] <kanl> wasn't sure about the interaction of $sub with $/

[06:08] <kanl> but now that i think about it, it makes sense.

[06:11] <kanl> m: my $s = 'poop'; $s.subst-mutate: /p/, -> $m { 'b' }, :g; $s.say

[06:11] <camelia> rakudo-moar ec3605: OUTPUT«boob␤»

[06:11] <ugexe> does this looks like it could fail to emit captured data if line 85 ($emitting = 0) is not reached before a separate thread with the final chunk of buffer reaches line 71 https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Socket/Async.pm#L65-L86 ? its a sort of hand-off between locks

[06:15] <ugexe> @buffer doesnt get cleared rather

[06:29] *** tinyblak_ joined
[06:33] *** tinyblak left
[06:40] *** Sqirrel left
[06:46] *** vendethiel joined
[06:47] *** rurban joined
[06:51] *** Sqirrel joined
[07:05] *** amurf joined
[07:09] *** amurf left
[07:12] *** espadrine joined
[07:27] *** vendethiel left
[07:29] *** vendethiel joined
[07:33] *** RabidGravy joined
[07:34] <RabidGravy> morning!

[07:35] <nwc10> morning

[07:41] <dalek> roast: 9d9b36a | lizmat++ | S32-hash/adverbs.t:

[07:41] <dalek> roast: Comprehensive testing of hash slicing with adverbs

[07:41] <dalek> roast: review: https://github.com/perl6/roast/commit/9d9b36a501

[07:43] <kanl> my @a = 1, 2, 3; say ( @a.all > 3 ).Bool; my @b; say ( @b.all > 3 ).Bool

[07:43] <kanl> m: my @a = 1, 2, 3; say ( @a.all > 3 ).Bool; my @b; say ( @b.all > 3 ).Bool

[07:43] <camelia> rakudo-moar ec3605: OUTPUT«False␤True␤»

[07:44] <moritz> m: say so all()

[07:44] <camelia> rakudo-moar ec3605: OUTPUT«True␤»

[07:45] <cdc_> Hello #perl6!  For information the "Make a donation" link from http://news.perlfoundation.org/2015/04/grant-proposal-perl-6-release.html is broken

[07:45] <kanl> moritz: why would "all of @b > 3" be true, when @b is empty?

[07:46] <dalek> rakudo/nom: 37b5793 | lizmat++ | t/spectest.data:

[07:46] <dalek> rakudo/nom: Make sure we run hash slicing adverbs tests

[07:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/37b579365a

[07:46] <cdc_> (but the one from http://www.perlfoundation.org/perl_6_core_development_fund is OK)

[07:46] <moritz> kanl: for the same reason that all() is True

[07:47] <moritz> the empty list/set/junction is the neutral element of junction composition

[07:47] <moritz> and so all(empty list) must be the neutral element of the 'all' / 'and' operation, which is True

[07:48] <moritz> or, phrased more simply: if you can't find a counter example, the result is True. You can't find a counter example in an empty list.

[07:49] <lizmat> cdc_: thanks for the report, I've forwarded it to someone at TPF...

[07:49] <kanl> i wanna say that it all makes perfect sense, but it still doesn't sit well with me, so i'd have to digest it a bit :)

[07:50] <kanl> thanks, moritz++

[07:51] *** vendethiel left
[07:52] <dalek> roast: 0d1ab4c | lizmat++ | S32-hash/adverbs.t:

[07:52] <dalek> roast: More correct test of bare zen slice

[07:52] <dalek> roast: review: https://github.com/perl6/roast/commit/0d1ab4c24d

[07:52] <cdc_> lizmat: another issue when creating an account from https://secure.donor.com/pf012/give -> [email@hidden.address] is invalid"

[07:53] <cdc_> I do confirm this is a valid address :)

[07:55] <lizmat> forwarded as well...

[07:55] <lizmat> afk for at least a few hours&

[07:55] <cdc_> lizmat: thanks!

[07:56] *** bin_005_j left
[07:56] <kanl> <riddle> if @b.all > 3 && @b.all < 3 && @b.all == 3, what's in @b? <answer> nothing!

[07:56] *** bin_005_j joined
[07:59] <kanl> though i still get the unsettling feeling as though it will spring out of some dark corner and bite me..

[08:01] *** darutoko joined
[08:02] <kanl> not sure if it's analogous, but it feels like the issue masak++ blogged, that if $n >= 0 is not true, $n is not necessarily negative :(

[08:05] *** rindolf joined
[08:06] <kanl> it makes natural sense with .none, but with .all, really not a lovable thing.

[08:09] *** vendethiel joined
[08:10] *** rindolf left
[08:31] *** vendethiel left
[08:33] *** diana_olhovik_ joined
[08:39] *** diana_olhovik_ left
[08:43] *** vendethiel joined
[08:50] *** haroldwu joined
[08:54] *** amurf joined
[08:59] *** amurf left
[09:09] *** spider-mario joined
[09:10] *** TEttinger left
[09:10] *** rurban left
[09:15] *** gfldex joined
[09:18] *** diana_olhovik_ joined
[09:24] *** diana_olhovik___ joined
[09:25] *** diana_olhovik_ left
[09:27] <masak> morning, #perl6

[09:27] <masak> kanl: is your complaint that any condition on the elements of an empty list is vacuously true?

[09:28] * masak .oO( "all elements of this list have been to the moon, and gotten a refund!" )

[09:29] * masak .oO( "all elements of this list are your personal Secret Santa, and they were also instrumental in planning 9/11" )

[09:30] * masak .oO( "all elements of this list will one day return in psychotic wrath to destroy the universe, plus-minus an apple" )

[09:31] <masak> well,

[09:31] <masak> (1) you're in good company. there are lots of dead Medieval logicians who would agree with you in a heartbeat. (they also had serious foundational problems because of this belief.)

[09:32] <masak> (2) if either of the statements above is false, you should be able to come up with a counterexample, namely an element that *hasn't* been to the moon etc. I invite you to do this.

[09:37] <nine> masak: the more you argue, the more I _want_ to find a flaw in your logic ;)

[09:37] <masak> nine: I invite you to do this :)

[09:37] * masak .oO( keep your friends close, keep your debating partners in infinite loops )

[09:38] <nine> Problem is, I'm firmly on your side ;)

[09:39] <masak> srsly though, sometimes "common sense" has to stand back for the progress of knowledge.

[09:40] <ShimmerFairy> "All elements of this list are not present in all other lists"

[09:40] * masak backlogs and notices that moritz already did the "counterexample" schtick

[09:40] <masak> moritz++

[09:40] <nine> Even common sense has to admit that if a list is built by putting all elements that satisfy a given condition into it, then all elements in this list must satisfy this condition.

[09:40] <nine> Now if the condition is impossible to satisfy, this still does not change the previous sentence.

[09:41] <masak> common sense feels confused!

[09:41] <ShimmerFairy> masak: It reminded me of  a -> b  , how if a is false then a -> b is always true. At first it makes no sense, but of course there's a logical explanation :P

[09:42] <masak> the logical explanation is just that, if 'a' is false, then as far as 'a -> b' is concerned, it's already done and doesn't need to care more.

[09:42] <masak> the same kind of "short-circuiting" thinking as with && and || in Perl 6.

[09:44] <masak> or, put differently, 'a -> b' isn't a statement about the trueness of 'a', it's a statement about the trueness of 'b' *in a world where 'a' is true*

[09:44] <masak> if we're not in that world, then we're done because the statement was clearly about some other world :)

[09:46] <ShimmerFairy> m: say False orelse True

[09:46] <camelia> rakudo-moar 37b579: OUTPUT«False␤»

[09:47] <ShimmerFairy> I'm sure that's not right, unless I misunderstand orelse

[09:49] <masak> you misunderstand orelse

[09:49] <masak> orelse distinguishes success from failure. False is a falsy value, but it's not failure

[09:50] <masak> you also have precedence wrong

[09:50] <masak> m: say (Mu orelse 42)

[09:50] <camelia> rakudo-moar 37b579: OUTPUT«42␤»

[09:50] <masak> m: say (False orelse 42)

[09:50] <camelia> rakudo-moar 37b579: OUTPUT«False␤»

[09:50] <masak> ShimmerFairy: you can read more about `orelse` in S03

[09:51] <masak> especially the thunkish semantics, which seems to me the big reason to use it

[09:52] <masak> hm, s/success from failure/defined from undefined/

[09:52] *** diana_olhovik___ left
[09:52] <masak> which makes me realize that orelse would be pretty well suited for error handling of .index

[09:54] <masak> m: my $s = "the quick brown fox"; for <brown red fox> -> $word { my $ix = $s.index($word) orelse say "Didn't find the word '$word'" and next; say "'$word' is at $ix" }

[09:54] <camelia> rakudo-moar 37b579: OUTPUT«'brown' is at 10␤Didn't find the word 'red'␤'fox' is at 16␤»

[09:55] <masak> m: my $s = "the quick brown fox"; for <brown red fox> -> $word { my $ix = $s.index($word) andthen say "'$word' is at $ix" }

[09:55] <camelia> rakudo-moar 37b579: OUTPUT«'brown' is at 10␤'fox' is at 16␤»

[09:55] <masak> m: my $s = "the quick brown fox"; for <brown red fox> -> $word { $s.index($word) andthen say "'$word' is at $_" }

[09:55] <camelia> rakudo-moar 37b579: OUTPUT«Use of uninitialized value $_ of type Any in string context  in code  at /tmp/16_jHckQl2:1␤'brown' is at ␤Use of uninitialized value $_ of type Any in string context  in code  at /tmp/16_jHckQl2:1␤'fox' is at ␤»

[09:55] <masak> apparently we don't bind $_ properly yet.

[09:55] * masak ponders submitting a rakudobug

[09:56] *** CIAvash joined
[09:57] <ShimmerFairy> m: sub infix:<→>($a, $b) { $a ?? ?$b !! True }; say $_[0], "→", $_[1], "=", $_[0]→$_[1] for ((True, False) X (True, False)) # I wonder how useful this would actually be in code

[09:57] <camelia> rakudo-moar 37b579: OUTPUT«True→True=True␤True→False=False␤False→True=True␤False→False=True␤»

[10:00] <masak> ShimmerFairy: I used it once, in http://strangelyconsistent.org/blog/boxes-and-pebbles

[10:02] <masak> sub infix:«⇒»($premise, $conclusion) { !$premise || $conclusion }

[10:02] <masak> we implement it in different ways, but those two ways have the same truth table :)

[10:02] *** baest_ joined
[10:03] <ShimmerFairy> masak: Yeah, I saw your version described somewhere, but I prefer the version that has a slightly easier to follow truth table :P

[10:03] * masak is reminded of how much he likes QuickCheck

[10:03] <masak> ShimmerFairy: matter of taste, I guess.

[10:03] <masak> "either the premise is false or the conclusion is true" reads very well to me. and that's implication.

[10:05] <ShimmerFairy> masak: There's something about  !! True  that looks funny to me :P (esp. when in context: "if true then stuff else true")

[10:05] *** telex left
[10:06] *** telex joined
[10:11] <masak> ShimmerFairy: any time you put True in a ternary ?? !!, you could have used || instead.

[10:11] <masak> ditto False, &&

[10:11] <ShimmerFairy> I can see that.

[10:15] <ShimmerFairy> I wrote down some thoughts I had on S23 (security), since it seems to me that's the one missing synopsis that's actually quite important: https://gist.github.com/lue/bdb5be0ab2ba78654a01

[10:15] <masak> in fact, that's a cute way to intoduce && and || semantics in a course; based on ?? !!

[10:15] <ShimmerFairy> I'm not well-versed in matters of security, so I expect most of what I wrote to appear nonsensical to someone who does :)

[10:18] <masak> ShimmerFairy: two comments:

[10:19] <masak> (a) the document starts out in a way that makes it seem that secutiry is not that important, and a thing that some people switch on in some cases. I think that's a dangerous attitude.

[10:19] <masak> (b) there seems to be a widespread confusion in the whole document between "security" and "tainting".

[10:20] <ShimmerFairy> With (b) , I considered an object's "security" and "taintedness" to be the same thing.

[10:21] <ShimmerFairy> And as to (a) , I did get a "use strict; use warnings;" feeling from how I organized it, but I did that because I don't want the security in Perl 6 to be intrusive, esp. this late into it.

[10:22] <ShimmerFairy> masak: I'm fully willing to admit that I know nothing about how to make something secure. I basically just read perlsec and went from there, so that there was some kind of starting point for S23.

[10:23] <masak> ok.

[10:23] <masak> well, ShimmerFairy++ for writing something. it's easier to iterate on things that exist :)

[10:24] <masak> security is a very wide topic. tainting is one aspect and one solution to it.

[10:24] <ShimmerFairy> It's certainly interesting trying to figure out how to add what is likely considered a fundamental part of the language when we're so close to a release, and there's so much existing code completely unaware of what you're trying to add :)

[10:25] <masak> it's also a topic where it doesn't pay to be flippant in the least. want your software to be secure? well, then you have to get *every* step right. get one of them wrong and you get hacked.

[10:26] <masak> tainting protects against some kinds of injection attacks. it's a pretty good tool for detecting the possibility of an injection attack.

[10:26] <masak> but it doesn't address all the other possible attack vectors at all.

[10:26] *** diana_olhovik joined
[10:26] <masak> and a document purporting to talk about "security" can't talk only about tainting.

[10:27] <ShimmerFairy> For tainting, I briefly considered having it be a ternary thing (secure, insecure, and indeterminate), but didn't go with that. However, I ended up having to a bit of contorting to fit within just two states.

[10:27] <ShimmerFairy> masak: Yes. There's a very good reason I didn't try to sell this as a draft S23 in the slightest :)

[10:29] <masak> :)

[10:29] <masak> ditching "indeterminate" sounds good.

[10:30] <masak> "tainted" tends to mean either "insecure" or "indeterminate"

[10:30] <masak> that is, the onus is on the programmer to guarantee safety

[10:30] <masak> r: class Conf { has @.boxes where { all(@$_) >= 0 } }; my $c = Conf.new(:boxes[ 2, 2, -1 ]); say $c.perl

[10:30] <camelia> rakudo-{moar,jvm} 37b579: OUTPUT«Type check failed in assignment to '@!boxes'; expected '<anon>' but got 'Int'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[10:31] <masak> r: class Conf { has @.boxes where { all(@$_) >= 0 } }; my $c = Conf.new(:boxes[ 2, 2, 0 ]); $c.boxes[2] = -1; say $c.perl

[10:31] <camelia> rakudo-{moar,jvm} 37b579: OUTPUT«Type check failed in assignment to '@!boxes'; expected '<anon>' but got 'Int'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[10:31] <masak> wow. I am impressed.

[10:31] <ShimmerFairy> Yeah, perlsec made it very clear that it was the programmer's fault if the tainting got messed up. (Also, note how I didn't keep around that weird "hash keys are always safe" thing from P5)

[10:31] <masak> except by the error message :)

[10:32] *** diana_olhovik left
[10:32] <masak> well, tainting can indicate the presence of an injection, but not prove its absence

[10:32] <ShimmerFairy> I think the error might be better written as "'-1' doesn't pass where constraint", or something to that effect

[10:35] <ShimmerFairy> I can see now that some of my problems with writing my notes probably came from misunderstanding tainting as secure/insecure , instead of the insecure/not yet insecure it actually is :)

[10:36] <masak> how do I answer the question "if I called a method on $obj (with these args), what class would it dispatch to?" in Perl 6? without actually making the call.

[10:37] <masak> ShimmerFairy: yes, and maybe even print the where constraint.

[10:37] <masak> m: subset Foo of Any where { $_ > 0 }; my Foo $n = -7

[10:37] <camelia> rakudo-moar 37b579: OUTPUT«Type check failed in assignment to '$n'; expected 'Foo' but got 'Int'␤  in block <unit> at /tmp/46wGj6yVeD:1␤␤»

[10:38] <masak> huh, I remember some error message actually printing the where constraint. apparently not that one.

[10:39] <ShimmerFairy> (I definitely envision RESTRICTED as a second level of security, basically "I see all your nifty security features, Perl 6, but I need more. It's reeeally important.")

[10:42] <masak> I think the document should be written from the point of view of "ok, you know that you might be hacked and that that would be really not good. so here's what we can do to help you avoid that."

[10:43] <masak> I mean, reference leakage in objects could be considered to be part of this.

[10:43] <masak> so could various types of information leakage, timing attacks, Denial of Service, etc

[10:43] <ShimmerFairy> Sure. And I bet there are potential attacks on the underlying system that might need to be considered, if appropriate.

[10:44] <masak> if you construct a regex from input, even if you do it safely without EVAL somehow, a crafty attacker could perhaps suppy you with an input that would create a regex that wouldn't finish before the heat death of the universe.

[10:44] <ShimmerFairy> (And for some reason, I'm really interested in seeing something done about /<?>+/ and similar)

[10:45] <ShimmerFairy> perhaps regexes need less-interpolating versions, like how strings have Q and :q

[10:45] <masak> m: say ("0" x 3 ~ "1").substr(2)

[10:45] <camelia> rakudo-moar 37b579: OUTPUT«00␤»

[10:45] <masak> :/

[10:46] * masak should look into that one

[10:47] <masak> https://rt.perl.org/Ticket/Display.html?id=123602, fwiw

[10:50] *** Alina-malina left
[10:53] <ShimmerFairy> m: say ("a" x 3 ~ "b").substr(2)  # just to confirm it's not _possibly_ something weird about "0" left over

[10:53] <camelia> rakudo-moar 37b579: OUTPUT«aa␤»

[10:57] *** rindolf joined
[10:58] <dalek> roast: 00ea8c8 | (Stefan Seifert)++ | S06-signature/definite-return.t:

[10:58] <dalek> roast: Fix typo in fudged test s/X::Adhoc/X::AdHoc/

[10:58] <dalek> roast: review: https://github.com/perl6/roast/commit/00ea8c80c6

[11:11] *** cognominal left
[11:11] <Woodi> hallo #perl6 :)

[11:14] <Woodi> pairs "constructors" like: a => 1  or :a(1) are very loudy when just:  a: 1  can be used... or { a:1, b:2 } form

[11:15] <Woodi> and such "enumerated" pairs could be put into perfect hashes (imutable)

[11:23] *** cognominal joined
[11:24] <nine> Woodi: the colon is already being used for something else

[11:32] *** bin_005_j left
[11:45] *** _mg_ joined
[11:50] *** grondilu joined
[11:53] *** vendethiel left
[11:55] <masak> yes, that's a label.

[11:55] *** Akagi201 joined
[11:55] *** AlexDaniel joined
[11:58] *** _mg_ left
[12:00] *** vendethiel joined
[12:00] *** Akagi201 left
[12:02] *** aristotle joined
[12:05] *** aristotle left
[12:06] *** RabidGravy left
[12:07] *** Alina-malina joined
[12:07] *** Alina-malina left
[12:09] *** RabidGravy joined
[12:12] <Woodi> it's not ^':' here...

[12:12] *** Alina-malina joined
[12:20] *** vendethiel left
[12:22] *** vendethiel joined
[12:24] <ShimmerFairy> m: say (([~] "0" xx 3) ~ 1).substr(2)

[12:24] <camelia> rakudo-moar 37b579: OUTPUT«00␤»

[12:24] <ShimmerFairy> masak: ^ it affects list repetition too, it seems

[12:26] <ShimmerFairy> (at least for strings)

[12:27] <ShimmerFairy> m: say (0 x 3 ~ 1).substr(2); say (([~] 0 xx 3) ~ 1).substr(2); # also potentially helpful

[12:27] <camelia> rakudo-moar 37b579: OUTPUT«00␤01␤»

[12:31] *** ggoebel joined
[12:32] *** amurf joined
[12:35] *** Akagi201 joined
[12:36] *** beastd joined
[12:36] *** nys joined
[12:37] *** amurf left
[12:44] *** Akagi201_ joined
[12:47] *** Akagi201 left
[12:49] *** _mg_ joined
[12:57] *** FROGGS joined
[12:58] *** raiph joined
[13:16] *** lucasb joined
[13:28] *** ggoebel left
[13:33] *** Ben_Goldberg joined
[13:34] <lucasb> m: my Int @a = 1,2,3; @a[1] = Nil; say @a.perl

[13:34] <camelia> rakudo-moar 37b579: OUTPUT«Array[Int].new(1, Int, 3)␤»

[13:34] <lucasb> m: my Int @a = 1,Nil,3; say @a.perl

[13:34] <camelia> rakudo-moar 37b579: OUTPUT«Type check failed in assignment to '@a'; expected 'Int' but got 'Any'␤  in block <unit> at /tmp/Y6ejD8dOL8:1␤␤»

[13:34] <lucasb> ^^ funny that one way works but not the other

[13:37] *** _mg_ left
[13:39] *** tinyblak joined
[13:40] *** tinybla__ joined
[13:40] *** tinyblak_ left
[13:41] <RabidGravy> yay! noise! It helps with streaming not to be sending one byte at a time

[13:43] *** tinyblak left
[13:49] <RabidGravy> so for reference it is actually quicker copying 4096 bytes of a 320k mp3 file to a CArray[uint8] than it is to stream it, which is fortunate ;-)

[14:01] *** noganex left
[14:04] *** noganex joined
[14:06] *** tadzik joined
[14:15] *** smls joined
[14:16] <awwaiid> Whatcya doin, RabidGravy?

[14:18] <smls> m: my @array; $x := @array[0]; $x = 0; @array[0] = 42; say $

[14:18] <camelia> rakudo-moar 37b579: OUTPUT«5===SORRY!5=== Error while compiling /tmp/vEGXaQOHnK␤Variable '$x' is not declared␤at /tmp/vEGXaQOHnK:1␤------> 3my @array; 7⏏5$x := @array[0]; $x = 0; @array[0] = 42;␤»

[14:18] <smls> m: my @array; my $x := @array[0]; $x = 0; @array[0] = 42; say $x

[14:18] <camelia> rakudo-moar 37b579: OUTPUT«42␤»

[14:18] <smls> m: my @array; my $x := @array[0]; @array[0] = 42; say $x

[14:18] <camelia> rakudo-moar 37b579: OUTPUT«(Any)␤»

[14:18] <smls> ^^ should that print 42 too?

[14:18] <RabidGravy> awwaiid, binding to libshout to stream audio to icecast

[14:21] <timotimo> cool :)

[14:23] <lucasb> m: my @a; my $x := @a[10]; $x = 1; say @a.elems

[14:23] <camelia> rakudo-moar 37b579: OUTPUT«11␤»

[14:23] <lucasb> ^^ This vivifies the elements in the array without touching it

[14:24] <lucasb> smls: In your second example, it didn't get vivified, right?

[14:25] <smls> looks like it

[14:27] <lucasb> m: say ('abc' x 2 ~ '1234').substr(3)

[14:27] <camelia> rakudo-moar 37b579: OUTPUT«abc1234␤»

[14:27] <lucasb> m: say ('abc' x 2 ~ '1234').substr(4)

[14:27] <camelia> rakudo-moar 37b579: OUTPUT«bcabc1␤»

[14:27] <lucasb> ^^ That bug is an "off by one"? :)

[14:28] *** _mg_ joined
[14:29] <lucasb> I said 'abc' x 2, but it is like 'abc' x 3

[14:31] <lucasb> It chops the number 1234 at 1 maybe because of the length of the original string

[14:33] <lucasb> j: say ('abc' x 2 ~ '1234').substr(4)

[14:33] <camelia> rakudo-jvm 37b579: OUTPUT«bc1234␤»

[14:33] <lucasb> Is it a moarvm thing then? Maybe about the implementation of nqp::x

[14:34] *** zakharyas joined
[14:36] *** _mg_ left
[14:47] <DrForr> .seen Util

[14:47] <yoleaux> I saw Util 17 Jun 2015 19:12Z in #perl6: <Util> smls: That is the GLR bug.  As for re-writing as [\*] 1, @primes, ... DOH!

[14:47] *** aborazmeh joined
[14:47] *** aborazmeh left
[14:47] *** aborazmeh joined
[15:01] *** BenGoldberg joined
[15:04] *** Ben_Goldberg left
[15:16] <timotimo> m: my @test; @test.unshift; say @test

[15:16] <camelia> rakudo-moar 37b579: OUTPUT«␤»

[15:16] <timotimo> m: my @test; @test.unshift; say @test.perl

[15:16] <camelia> rakudo-moar 37b579: OUTPUT«[]<>␤»

[15:16] <timotimo> should this throw an error?

[15:17] *** khw joined
[15:19] <smls> Perl 5 allowes it, but prints a "Useless use of unshift with no values" warning

[15:19] <AlexDaniel> is there any way to make the current rule not match? I mean, if I put { fail } it will jump out without matching anything at all, but I just want to say "ok, this regex is not going to match, just jump out of here but keep trying". Is it one of these : :: ::: backtracking controls?

[15:20] <smls> timotimo: I Perl 6 I guess it's a consequence of unshift's   (\a, *@elems)  signature

[15:21] <timotimo> but if it's \a, *@elems should make that work, shouldn't it?

[15:21] <timotimo> i mean: give an exception properly

[15:21] *** colomon left
[15:21] <smls> no, slurpies params also match the zero argument case

[15:22] <timotimo> yeah, but \a won.t

[15:22] <timotimo> oh, are you talking about the sub form?

[15:22] <smls> yeah

[15:24] *** aborazmeh left
[15:24] *** VinceDee joined
[15:25] <smls> AlexDaniel: <!>

[15:26] <AlexDaniel> smls: what's that?

[15:26] <smls> m: say "aaa" ~~ /aaa <!> | aa/

[15:26] <camelia> rakudo-moar 37b579: OUTPUT«｢aa｣␤»

[15:27] *** vendethiel left
[15:27] *** skids joined
[15:27] <AlexDaniel> smls: indeed, this works

[15:29] <AlexDaniel> smls: but it would be cool to know how this thing is called

[15:29] <AlexDaniel> smls: and whether there are docs for that or not

[15:30] <AlexDaniel> timotimo: by the way, it seems like it is a whole class of problems when calling stuff without parameters produces no errors

[15:30] <AlexDaniel> timotimo: I remember seeing several rts like this one

[15:31] *** vendethiel joined
[15:33] <smls> AlexDaniel: http://design.perl6.org/S05.html#line_2150

[15:33] <smls> It doesn't seem to be documented on doc.perl6.org yet.

[15:33] <timotimo> anything with slurpy-only params

[15:35] <smls> timotimo: Actually, Perl 5 only prints the warning when the argument is missing in the source code.

[15:35] *** BenGoldberg left
[15:35] <smls> If there's an array argument that just happens to be empty at run-time, there's no warning.

[15:36] <timotimo> ah, mhm

[15:36] <smls> I believe lizmat++ has previously put some thought into how we could handle such cases (argument required, but allowed to be empty) in Perl 6

[15:36] <timotimo> well, we can't really do that unless we already know at compile time that it's the right class etc etc

[15:36] <smls> not sure if anything came of it though

[15:37] <smls> right, for methods I guess it wouldn't be feasible

[15:38] <smls> but for subs it could be made to work, no?

[15:38] <timotimo> we can just put a check into these methods, but ... :(

[15:38] <timotimo> spesh could eliminate these checks

[15:39] <smls> I do think  @a.push(@b)  should work even if @b is empty

[15:39] <timotimo> but maybe it'd be better to have it in the signature directly somehow

[15:39] <smls> to avoid always having to check that case in user code

[15:39] <timotimo> you mean @a.push(|@b)

[15:39] <timotimo> @a.push(@b) wouldn't trigger the check for "no arguments passed"

[15:40] <smls> ah, you mean the check would kick in before flattening into the slurpy?

[15:40] <AlexDaniel> smls: https://rt.perl.org/Public/Bug/Display.html?id=125257

[15:40] <AlexDaniel> there is a comment by liz

[15:40] <timotimo> i think you're misunderstanding how *@a in a signature works

[15:41] <timotimo> m: sub test(*@a) { say @a.elems }; my @foo = 1, 2, 3, 4; test(@foo)

[15:41] <camelia> rakudo-moar 37b579: OUTPUT«4␤»

[15:41] <AlexDaniel> and a fix, actually

[15:41] <timotimo> .. huh?

[15:41] <timotimo> m: sub test(*@a) { say @a.elems }; my @foo = 1, 2, 3, 4; test(@foo, @foo)

[15:41] <camelia> rakudo-moar 37b579: OUTPUT«8␤»

[15:41] <timotimo> i didn't know that flattens

[15:43] *** eternaleye joined
[15:44] *** BenGoldberg joined
[15:45] <smls> slurpies and list assignment are the last remaining bastions of auto-flattening in Perl 6 :P

[15:46] <smls> and maybe the list assignment one will fall too, in the course of the GLR...

[15:47] <smls> m: sub test(**@a) { dd @a }; my @foo = 1, 2, 3, 4; test @foo, @foo;

[15:47] <camelia> rakudo-moar 37b579: OUTPUT«(1, 2, 3, 4; 1, 2, 3, 4)␤»

[15:47] <smls> ^^ though there's also ** slurpies

[15:47] <skids> slurpies are also special in that they can receive feeds (once feeds get up to snuff)

[15:49] <timotimo> i think that stumped me already

[15:50] <timotimo> the thing about *@a flattening @-passed things

[15:52] <AlexDaniel> smls: oh noes! <!> does not really work in my case, sorry for saying that it worked

[15:52] <AlexDaniel> wrong input file

[15:53] <AlexDaniel> smls: <!> just always fails to match, I, on the other hand, want to stop matching this rule completely

[15:54] *** vendethiel left
[15:54] <ugexe> <!.> ?

[15:54] <AlexDaniel> I have something like this: regex rule { <s>.*? [ < }

[15:54] <AlexDaniel> ooops

[15:55] <AlexDaniel> nvm that line

[15:56] <AlexDaniel> this: regex rule { <aaa> [ <bbb> || <stopTrying> <!> ] }

[15:56] <AlexDaniel> in other words, if you stumble upon <stopTrying> just eject from this regex

[15:56] <ugexe> <aaa> [<bbb> || { die }] hehe

[15:57] <nine> { return } ?

[15:58] <AlexDaniel> ugexe: I've already mentioned { fail } but if this part of the grammar did not match it does not really mean that the whole thing cannot match

[15:58] <skids> Should just have to return whatever a failure to match returns.

[15:59] <timotimo> you'd return a Cursor i believe

[16:00] <smls> AlexDaniel: what do you mean by "just eject from this regex"?

[16:00] <timotimo> make the current regex { ... } fail

[16:00] <timotimo> with <!> you can just make a branch fail

[16:00] <skids>  Nil

[16:00] <timotimo> if you have a | or ||, the rest still does backtracking

[16:01] <timotimo> skids: i don't think that's compatible in this place

[16:01] <ugexe> eh, does it still backtrack if <this> || <that> this matches before that?

[16:01] <timotimo> in that case it'll try the next piece of the branch. if there's a scan around (actually, before) that, it'll try the whole alteration again

[16:01] <timotimo> gotta go get groceries and stuff

[16:01] <skids> 'The method is expected to return a lazy list of new match state objects, or Nil if the match fails entirely.'  That is assuming there isn't GLR churn.

[16:02] <smls> regex rule { <aaa> <!before <stopTrying> > <bbb> }

[16:02] <smls> AlexDaniel: ^^ maybe refactor the regex like this?

[16:02] <timotimo> which method are you talking about?

[16:02] <skids> Search for that in S05

[16:03] <timotimo> does the "return" really travel up to the match method?

[16:03] <timotimo> or parse or whatever?

[16:03] <timotimo> oh

[16:03] <timotimo> i'm apparently mistaken :)

[16:03] <timotimo> okay :)

[16:03] <AlexDaniel> smls: no-no, because "some text here STOPTRYING some text here STOPTRYING", there is no guarantee that it will stop after the first occurance

[16:04] *** vendethiel joined
[16:04] <AlexDaniel> or hm...

[16:04] <AlexDaniel> I'm confused actually

[16:04] <ugexe> i dont see why it wouldnt stop

[16:04] <smls> I may not understand correctly what you want :P

[16:05] <ugexe> unless you are using a greedy operator somewhere

[16:05] <AlexDaniel> yeah, well, maybe I should come up with an example

[16:08] *** zakharyas left
[16:09] <skids> m: grammar foo { regex TOP { <foo> d || bd }; regex foo { a || b { return Nil } || c }; }; foo.parse("bd").say; # yeah return Nil doesn't work.

[16:09] <camelia> rakudo-moar 37b579: OUTPUT«Nil␤»

[16:09] <skids> Hmm.

[16:09] *** amurf joined
[16:09] <skids> m: grammar foo { regex TOP { <foo> d || bd }; regex foo { a || b { return Empty } || c }; }; foo.parse("bd").say; # It is returnin from the whole parse.

[16:09] <camelia> rakudo-moar 37b579: OUTPUT«Empty␤»

[16:10] <ugexe> figured. 

[16:10] <skids> I don't think it should.

[16:11] <ugexe> ive emitted values out of a parse when i needed to get values out

[16:11] <AlexDaniel> skids: while I'm coming up with an example, your code totally makes sense to me

[16:12] <AlexDaniel> skids: that's exactly what I want, if only it worked

[16:12] <ugexe> replace return Empty with an impossible to match token and it should do the same thing, no?

[16:13] <skids> m: grammar foo { regex TOP { <foo> d || bd }; regex foo { a || b { &?ROUTINE.leave } || c }; }; foo.parse("bd").say # Hrmf

[16:13] <camelia> rakudo-moar 37b579: OUTPUT«Regex.leave() not yet implemented. Sorry. ␤  in regex foo at /tmp/oS2Ph07dTO:1␤  in regex TOP at /tmp/oS2Ph07dTO:1␤  in block <unit> at /tmp/oS2Ph07dTO:1␤␤»

[16:14] <skids> ugexe: no.

[16:14] *** amurf left
[16:16] <nine> What's the ? in self.?message

[16:17] <skids> nine: "if the method exists" IIRC.

[16:17] <smls> I believe it means    self.^can("message") ?? self.message !! self

[16:17] <TimToady> we usually use <!> for the "never matches" assertion

[16:17] <masak> m: class C {}; C.new.?message; say "alive"

[16:17] <camelia> rakudo-moar 37b579: OUTPUT«alive␤»

[16:18] <TimToady> but methods in a grammar must always return cursors

[16:18] <ugexe> ?method() is like method() // Nil

[16:18] <masak> no, not really.

[16:18] <ugexe> so if its a false value it also returns false

[16:18] <smls> yay, TimToady is online, I can step back from giving (inferior) grammar advice now :P

[16:18] <skids> m: grammar foo { regex TOP { <foo> d || bd }; regex foo { a || b { return foo } || c }; }; foo.parse("bd").say

[16:18] <camelia> rakudo-moar 37b579: OUTPUT«(foo)␤»

[16:18] <TimToady> well, yer assumin' I'm awake

[16:19] <skids> m: grammar foo { regex TOP { <foo> d || bd }; regex foo { a || b { return self } || c }; }; foo.parse("bd").say

[16:19] <camelia> rakudo-moar 37b579: OUTPUT«foo.new␤»

[16:19] <masak> ugexe: .method() // Nil would still die if there's no .method()

[16:19] <nwc10> and caffeinated

[16:19] *** FROGGS left
[16:19] *** Sqirrel left
[16:19] *** uncleyea1 joined
[16:19] <ugexe> ah, true

[16:19] <masak> m: class C { method message(C:D:) { say "only an instance method" } }; C.?message; say "alive"

[16:19] <camelia> rakudo-moar 37b579: OUTPUT«Invocant requires a 'C' instance, but a type object was passed.  Did you forget a .new?␤  in method message at /tmp/MuAO2imCSt:1␤  in block <unit> at /tmp/MuAO2imCSt:1␤␤»

[16:20] <masak> m: class C { multi method message(C:D:) { say "only an instance method" } }; C.?message; say "alive"

[16:20] <camelia> rakudo-moar 37b579: OUTPUT«Cannot call message(C: ); none of these signatures match:␤    (C:D $: *%_)␤  in block <unit> at /tmp/Blgeb2qBAD:1␤␤»

[16:20] <masak> ...why does that last one fail?

[16:20] <masak> isn't the point of .?method to avoid dispatch failures? even multi dispatch failures?

[16:20] <TimToady> currently it's only "missing method"

[16:21] <masak> sheesh, I'm back from a nice afternoon errand for 3 minutes, and I find a rakudobug :P

[16:21] <TimToady> this was discussed last week or so

[16:21] <masak> TimToady: ok, so the above is actually correct behavior?

[16:21] *** uncleyear left
[16:21] <TimToady> it doesn't catch bind failures as it is currently implemented

[16:21] <masak> right, I see that.

[16:21] <masak> ...but do we want it to?

[16:21] <TimToady> that's more in the bailiwick of try currently

[16:22] * masak stands down bug alert

[16:22] <nine> Or the real question: why does calling a P5 function during stringification of the P5 $error object in a P6 die($error) screw up $error in a "Can't use anonymous symbol table for method lookup." kind of way?

[16:22] *** salv00 left
[16:23] <skids> m: grammar foo { regex TOP { <foo> d || bcd }; regex foo { a || bc <!> || b+c }; }; foo.parse("bcd").say # better test case ugexe++

[16:23] <camelia> rakudo-moar 37b579: OUTPUT«｢bcd｣␤ foo => ｢bc｣␤»

[16:23] <TimToady> we haven't decided if we want .? to do more yet; there's arguments on both sides, of which I am not awake enough to reproduce

[16:24] <smls> nine: Sounds like a P5 error message to me, not one from P6

[16:24] <nine> smls: it is

[16:24] *** tinybla__ left
[16:24] <nine> somehow the P5 object is just broken after the stringification

[16:25] <nine> But only if this stringification is done in the course of throwing the object with die() in P6

[16:26] <nine> This is the cause of S01-perl-5-integration/exception_handling.t failing btw.

[16:27] <AlexDaniel> So, here is the illustration of my problem: https://gist.github.com/AlexDaniel/5fde506394d862f23626

[16:27] <AlexDaniel> <!> does not help

[16:28] <AlexDaniel> in other words, 'special' should match ** anything ** unless XX is inside

[16:28] *** skids left
[16:28] <AlexDaniel> in this case 'special' should just fail, but the parsing should continue

[16:31] <smls> '**' (.*?) '**'  <?{ $0 !~~ /XX/ }>

[16:31] <smls> '**' [ <!before XX> . ]*? '**'

[16:31] <TimToady> that would need the NYI backtracking control to work, ::: <!>

[16:31] <AlexDaniel> TimToady: that's what I said initially

[16:32] <nine> AlexDaniel: now you have a good reason to implement backtracking control :)

[16:32] <TimToady> '**' ~ '**' [ <!before XX> . ]*?

[16:33] <AlexDaniel> nine: I don't think that I'm ready for this

[16:33] <ugexe> no one is going to try and sneak a XX+ % '**' in there?

[16:34] <TimToady> having looked at the current backtracking mechanism, I'm not sure I'm ready for it :)

[16:34] <nine> AlexDaniel: one truth I've learned so far: you're never ready. You just jump in and do it anyway :)

[16:35] * TimToady implemented ::: in STD, but STD uses a completely different backtracking mechanism

[16:35] <AlexDaniel> nine: yea, well. But that requires time

[16:35] <ugexe> kill them all and let the implementors sort them out

[16:38] <AlexDaniel> smls: your first line actually makes sense, but as far as I can see it runs in exponential time

[16:39] <AlexDaniel> correct me if I'm wrong

[16:39] <hoelzro> morning, #perl6!

[16:41] *** VinceDee left
[16:41] *** VinceDee joined
[16:42] <AlexDaniel> smls: ooooooooooooooooh

[16:42] <AlexDaniel> oooooooh

[16:44] <hoelzro> m: multi foo(int $n) { say 'here' } ; foo(3)

[16:44] <camelia> rakudo-moar 37b579: OUTPUT«Cannot call foo(Int); none of these signatures match:␤    (int $n)␤  in block <unit> at /tmp/nHJCaCYxb2:1␤␤»

[16:44] <AlexDaniel> I've tried this yesterday:     regex special { '**' [ . <!before XX> ]*? '**' }

[16:44] <hoelzro> should an int parameter never be considered for an Int literal when finding candidates?

[16:45] <AlexDaniel> but then figured out that it will fail on this string: 'test **XX test** test'

[16:45] <AlexDaniel> and somehow stopped exploring that

[16:45] <AlexDaniel> now, smls, you are a genius!

[16:45] <AlexDaniel> just put before before . and there you go

[16:46] <AlexDaniel> as far as I can see, this should work

[16:46] <ugexe> i was gonna say... this doesnt do what you think [ . <!before XX> ]*? 

[16:48] *** vendethiel left
[16:50] * TimToady wonders if it would be useful to have ! and - prefix shortcuts, so you could just say -'XX' to mean <!before XX> .

[16:51] <smls> TimToady: But maybe people would expect that to gobble 2 character

[16:51] <TimToady> and <-[x]> could be -x

[16:51] <arnsholt> Morpheus: I plugged my Occulus in again now that I have a new graphics card, and I have to say that after a little while, even the generous 120 degree viewing angle feels kind of tight and uncomfortable. I have no idea how Morpheus is going to get by with just 90.

[16:51] <arnsholt> Calling of Various Duties: Really not my thing. No comment.

[16:51] <arnsholt> Whoops.

[16:51] <arnsholt> Pasto >.<

[16:52] <AlexDaniel> just tested that in my original code, it works! Wooohooo

[16:54] <smls> m: say "** abc XX ** def **" ~~ /^ "**" (.*?) "**"  <?{ say $0; $0 !~~ /XX/ }>/

[16:54] <camelia> rakudo-moar 37b579: OUTPUT«｢ abc XX ｣␤｢ abc XX ** def ｣␤Nil␤»

[16:54] <ugexe> and we almost had him ready to implement backtracking features... darn

[16:54] <TimToady> hoelzro: seems like that could be a bit dwimmier, but we'd have to interrogate jnthn++ as to why it works the way it does

[16:55] <smls> AlexDaniel: I don't think the one with the explicit assertion ^^ would be exponential time, because it only checks the assertion after matching **

[16:55] <smls> however, it *would* needlessly try to match beyond the first **

[16:55] <hoelzro> TimToady: alright, I'll await his response then

[16:55] <smls> that's the problem with *?

[16:55] <smls> (if you're not careful with it)

[16:55] <smls> so yeah, forget that suggestion.

[16:56] <smls> Glad to hear the one with <!before> works.

[16:57] *** vendethiel joined
[16:58] <AlexDaniel> smls: oh, indeed, that's not exponential time

[17:02] *** uncleyea1 is now known as uncleyear

[17:02] *** uncleyear left
[17:02] *** uncleyear joined
[17:04] <TimToady> one might be able to speed up by matching <-[X*]>+ instead of .

[17:04] <TimToady> well, you'd still have to traverse a single X somehow too

[17:05] <TimToady> but the <!before> solution is not exponential, it just has a larger constant on the O(n)

[17:06] <AlexDaniel> TimToady: sure, I just thought that <?{ }> check will fire up every character, but that's not the case

[17:06] <smls> TimToady: regarding speed, do you think .trans will beat .match here after both are optimized? https://github.com/dnmfarrell/URI-Encode/issues/4

[17:09] <smls> Or am I correct in my assumption that something   <[\x00..\xff]>   in a regex becomes and efficient   0 < ord($current) < 255   check which an .trans won't be able to compete with?

[17:09] <smls> *something like

[17:09] <TimToady> hard to say, since the trans is depending on mutable arrays, and we don't really have a good mechanism for telling when one of those has changed

[17:11] *** zakharyas joined
[17:14] <TimToady> it also kinda depends on the frequency of the weird characters

[17:15] <smls> It does?

[17:15] <TimToady> especially since you're doing an expansion

[17:16] <TimToady> the subst is gonna be really good at skipping the N characters that don't change

[17:17] <smls> m: say "N = ", ("a".."z", "A".."Z", 0..9, "_", ".", "~", "-").flat.elems

[17:17] <camelia> rakudo-moar 37b579: OUTPUT«N = 66␤»

[17:17] <TimToady> whereas trans tends to look up every character, even the ones that don't change, and gluing together every char separately

[17:17] <TimToady> I mean N in a row

[17:17] <smls> ah

[17:18] <hoelzro> could someone have a look at https://github.com/perl6-community-modules/SmokeResults/pull/2? it adds a warnings category for modules, so people can see which distributions are currently emitting warnings, so we can fix them before those warnings become errors

[17:18] <TimToady> as a degenerate case, the subst just does one string copy if no escaping happens

[17:18] <smls> So is there any case where the .trans version might be faster?

[17:20] *** vendethiel left
[17:22] <TimToady> caching issues aside, it really depends on how smart .trans gets about skipping unchanging characters

[17:22] <TimToady> if it's trying to do LTM on a set of chars that is all length 1, that's kind of a waste of energy

[17:23] *** vimal2012 joined
[17:23] <smls> what could it do that would be smarter than what the regex version does?

[17:23] <TimToady> if it's doing one char at a time concatenation, that's gonna be way slow too

[17:24] <TimToady> well, precomputed results are a lookup rather than a .fmt, which could conceivably be faster

[17:24] <smls> one could replace the RHS part of the .subst with a hash lookup then :P

[17:25] <TimToady> indeed

[17:26] <TimToady> knowing the max replacement length lets you put an upper bound on how much result string you have to allocate, so you never have to copy partial results to a larger location

[17:26] <TimToady> if you're willing to trade wasted memory for speed

[17:26] <TimToady> (a trade P5 makes with some frequency)

[17:26] <smls> good point

[17:27] *** vendethiel joined
[17:27] <TimToady> that's assuming contiguous strings, of course; since we have a partial ropes implementation, that may not hold

[17:30] <smls> do you think future Rakudo will cheat and use mutatable strings internally wherever it can get away with it?

[17:31] *** vimal2012 left
[17:32] <TimToady> smls: doesn't help much when you're expanding in place; you might as well copy

[17:32] <smls> true

[17:33] <TimToady> for old-style tr/a..z/A..Z/, sure, we could cheat, given some static analysis

[17:33] <hoelzro> .seen colomon

[17:33] <yoleaux> I saw colomon 3 Jul 2015 14:43Z in #perl6: <colomon> life’s too short to change working code unnecessarily.

[17:33] *** zakharyas left
[17:33] <TimToady> of course, that should just be a tcuc() or so, to be unicodically correct

[17:34] <hoelzro> .tell colomon could you have a look at https://github.com/perl6-community-modules/SmokeResults/pull/2?

[17:34] <yoleaux> hoelzro: I'll pass your message to colomon.

[17:39] *** raiph left
[17:43] <hoelzro> are actions classes (as in what one provides to Grammar.parse) spec'd anywhere? I only see a brief mention of them in http://design.perl6.org/S05.html#line_4383

[17:45] <smls> hoelzro: http://design.perl6.org/S32/Rules.html#Grammar also mentions them

[17:46] <hoelzro> smls: true, but I don't know if what actions classes are/how they work are spec'd

[17:47] <TimToady> well, hasn't been much need for docs since they're drop-dead simple; it just calls the same method name that just got reduced

[17:47] <smls> "reduced"?

[17:48] *** Possum left
[17:48] <smls> oh, you're talking parser theory lingo

[17:48] <TimToady> successfully matched

[17:48] <hoelzro> I was thinking of the confusion of a new user reading the specs to learn, trying to figure out what an action class is without having to ask #perl6

[17:48] <hoelzro> maybe it's my failure in assuming people will be learning Perl 6 from the design docs

[17:49] <smls> they should read http://doc.perl6.org/language/grammars#Action_Objects then :)

[17:49] <TimToady> one can put { make } directly into the rule, but then you can have only one set of actions for a given grammar

[17:49] <TimToady> this gives the ability to bind different sets of actions to the same grammar, such as syntax highlighting

[17:50] <TimToady> or linting

[17:50] <smls> in theory

[17:51] <TimToady> smls: darn it, you're spoilig our rant :P

[17:51] <smls>  ;)

[17:52] *** domidumont joined
[17:53] <TimToady> one of the optimizations we'd like to attempt is to avoid doing the 2nd method dispatch every time

[17:55] <TimToady> one could imagine binding a particular set of actions to a grammar, such that there is just one method call that basically mutates the original rule into [ <originalrule> ] { make stuff }

[17:55] <TimToady> well, that wasn't good English, but something like that

[17:57] *** domidumont left
[17:57] <smls> might as well pass a hash instead of an object instance to .parse then :P

[17:58] *** domidumont joined
[17:59] *** amurf joined
[17:59] <hoelzro> should I not bothering spec'ing actions then?

[18:00] <TimToady> I don't see any problem with speccing it; the optimization would be relatively transparent, mehopes

[18:00] <TimToady> my researches last night indicate that it's trivially easy to make [] not itemize, it's relatively difficult to get list assignment not to flatten, and nearly impossible to keep [] from flattening itself before list assignment even gets ahold of it (given current nqp list semantics)

[18:01] *** _mg_ joined
[18:01] <hoelzro> TimToady: action methods still fire regardless of backtracking and lookahead, right?

[18:02] <hoelzro> the reason I'm thinking about this is that I ran into some (to me) odd behavior regarding action methods and a lookahead

[18:02] <TimToady> they fire whenever the rule in question returns; it's up to the action methods to attach info only to the cursor using 'make' to keep the bookkeeping straight

[18:02] <TimToady> any side effects outside of the current cursor can go haywire

[18:03] <hoelzro> ah ha

[18:04] <hoelzro> make sense() # to me

[18:04] *** amurf left
[18:05] *** domidumont1 joined
[18:08] *** domidumont left
[18:09] *** domidumont1 left
[18:12] *** smls_ joined
[18:12] *** smls left
[18:14] <dalek> Inline-Perl5: c8e0bc5 | (Stefan Seifert)++ | p5helper.c:

[18:14] <dalek> Inline-Perl5: Fix method calls on P5 exception objects

[18:14] <dalek> Inline-Perl5: 

[18:14] <dalek> Inline-Perl5: When we started supporting stringification of Perl 5 objects,

[18:14] <dalek> Inline-Perl5: S01-perl-5-integration/exception_handling.t started failing.

[18:14] <dalek> Inline-Perl5: 

[18:14] <dalek> Inline-Perl5: The reason is that the ERRSV pointer never changes. Instead, the SV it

[18:14] <dalek> Inline-Perl5: points to gets overwritten with the exception object. As a result, we

[18:14] <dalek> Inline-Perl5: cannot just wrap the ERRSV pointer in a Perl5Object, since this only

[18:14] <dalek> Inline-Perl5: works until Perl 5 resets $@. From that point on all method calls will

[18:14] <dalek> Inline-Perl5: fail.

[18:14] <dalek> Inline-Perl5: 

[18:14] <dalek> Inline-Perl5: Fixed by creating a copy of the SV before converting it to a Perl 6

[18:14] <dalek> Inline-Perl5: scalar.

[18:14] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/c8e0bc5546

[18:14] <nine> S01-perl-5-integration/exception_handling.t fixed :)

[18:14] <nine> And it was only a day's worth of work for a one line fix ;)

[18:15] <TimToady> \o/ /o\

[18:15] *** rurban joined
[18:15] <TimToady> nine++ anyway

[18:15] <TimToady> that's for the bug fix, and another nine++ for the perserverance

[18:20] <smls_> Is the return value of action methods used for anything?

[18:20] <TimToady> no

[18:20] <TimToady> just as the { make stuff } doesn't influence the return cursor of the rule

[18:21] <smls_> right

[18:26] *** domidumont joined
[18:30] <masak> m: sub foo(int $i) { say "OH HAI" }; foo(3)

[18:30] <camelia> rakudo-moar 37b579: OUTPUT«OH HAI␤»

[18:30] <masak> m: multi foo(int $i) { say "OH HAI" }; foo(3)

[18:30] <camelia> rakudo-moar 37b579: OUTPUT«Cannot call foo(Int); none of these signatures match:␤    (int $i)␤  in block <unit> at /tmp/QDBQhyo6N9:1␤␤»

[18:30] <masak> oh. hadn't realized that there's this difference before.

[18:30] <masak> I'm sure there's a good reason... :)

[18:31] <timotimo> huh

[18:31] <TimToady> m: multi foo(int(Int) $i) { say "OH HAI" }; foo(3)

[18:31] <camelia> rakudo-moar 37b579: OUTPUT«Method 'int' not found for invocant of class 'Int'␤  in sub foo at /tmp/9SkuqD30Vr:1␤  in block <unit> at /tmp/9SkuqD30Vr:1␤␤»

[18:31] <TimToady> heh

[18:31] <masak> something fishy there, 'tseems

[18:32] <masak> ooh, and int(Int) ought to work with both int and Int inputs...

[18:32] * vendethiel waves

[18:32] <masak> m: sub foo(int(Int) $i) { say $i }; my Int $x = 42; foo($x); my int $y = 43; foo($y)

[18:32] <camelia> rakudo-moar 37b579: OUTPUT«Method 'int' not found for invocant of class 'Int'␤  in sub foo at /tmp/xTvgusbUqw:1␤  in block <unit> at /tmp/xTvgusbUqw:1␤␤»

[18:33] <masak> hurh

[18:33] <smls_> masak: As I've mentioned before, coercion subs/methods are a kind of a mess right now in Rakudo, and probably need more design work too

[18:33] <masak> vendethiel: kon'nichiwa~~~

[18:34] <vendethiel> masak: hehehehe :)

[18:34] <masak> smls_: ok.

[18:34] <smls_> I just hope that lizmat/TimToady/etc will find the time to think about that stuff before 6.0

[18:35] *** domidumont left
[18:36] <masak> the most important thing is not to miss chances for improvement that are very hard or impossible after 6.0.0

[18:36] <masak> not everything has to be perfect by 6.0.0, but it should preferably be improvable :)

[18:36] <smls_> +1 to that

[18:37] <BenGoldberg> m: my int $x = 3;

[18:37] <camelia> rakudo-moar 37b579: ( no output )

[18:38] <BenGoldberg> m: my int $x = 3.int;

[18:38] <camelia> rakudo-moar 37b579: OUTPUT«Method 'int' not found for invocant of class 'Int'␤  in block <unit> at /tmp/neOo7nA6Xk:1␤␤»

[18:38] <BenGoldberg> m: my $three = 3; my int $x = $three;

[18:38] <camelia> rakudo-moar 37b579: ( no output )

[18:38] <BenGoldberg> m: my $three = 3; my int $x = $three; say $x;

[18:38] <camelia> rakudo-moar 37b579: OUTPUT«3␤»

[18:38] <BenGoldberg> m: my $three = 3; my int $x = $three; say $x.WHAT;

[18:38] <camelia> rakudo-moar 37b579: OUTPUT«(Int)␤»

[18:38] *** nys left
[18:43] <lucasb> m: multi f(int) { 'int' }; multi f(Int) { 'Int' }; say f(42)

[18:43] <camelia> rakudo-moar 37b579: OUTPUT«int␤»

[18:43] <lucasb> m: multi f(int) { say 'int' }; multi f(Int) { say 'Int' }; f(42)

[18:43] <camelia> rakudo-moar 37b579: OUTPUT«Int␤»

[18:43] *** spider-mario left
[18:44] <lucasb> My conclusion: don't "say" anything :)

[18:48] <dalek> specs: beb870d | hoelzro++ | S05-regex.pod:

[18:48] <dalek> specs: Spec action objects/methods

[18:48] <dalek> specs: review: https://github.com/perl6/specs/commit/beb870dbff

[18:48] <dalek> specs: e4f7917 | hoelzro++ | S99-glossary.pod:

[18:48] <dalek> specs: Link to action objects section in glossary

[18:48] <dalek> specs: review: https://github.com/perl6/specs/commit/e4f79178aa

[19:02] *** virtualsue joined
[19:12] <CIAvash> this eats up CPU and memory:

[19:12] <CIAvash> class A {}; class B {}; A.^find_method('new').wrap(B.^find_method('new')); A.new;

[19:24] <ugexe> does wrapping methods really work?

[19:27] <TimToady> wrapping in general only works if your wrapper invokes nextsame or callsame

[19:27] <CIAvash> m: class A {}; class B {}; A.^find_method('new').wrap(method {say 'hi'}); A.new;

[19:27] <camelia> rakudo-moar 37b579: OUTPUT«hi␤»

[19:27] <TimToady> you can't just wrap an arbitrary routine around another without it knowing when it should call the wrapped routine

[19:29] <TimToady> I'd also point out that A and B actually have the same new method

[19:30] <TimToady> m: class A {}; class B {}; A.^find_method('new').wrap(method {say 'hi'}); B.new;

[19:30] <camelia> rakudo-moar 37b579: OUTPUT«hi␤»

[19:30] <TimToady> see the B.new htere

[19:30] <TimToady> *th

[19:30] *** diana_olhovik joined
[19:30] <TimToady> you're actually wrapping the generic new method that comes from Mu, probably

[19:31] <CIAvash> my main issue was that the command was not stopped, when it was eating memory

[19:31] <TimToady> and since you're not calling into the actual new method, you've screwed up all object creation

[19:32] <TimToady> in this case, you've wrapped the new routine in itself

[19:33] <vendethiel> m: loop (;;) {}; #not stopped :P

[19:33] <camelia> rakudo-moar 37b579: OUTPUT«(timeout)»

[19:33] <CIAvash> :) yeah, didn't know both new methods are the same

[19:34] <TimToady> m: class A {}; class B {}; A.^find_method('new') === B.^find_method('new')

[19:34] <camelia> rakudo-moar 37b579: ( no output )

[19:34] <TimToady> m: class A {}; class B {}; say A.^find_method('new') === B.^find_method('new')

[19:34] <camelia> rakudo-moar 37b579: OUTPUT«True␤»

[19:34] <dalek> specs: 30aa605 | hoelzro++ | S99-glossary.pod:

[19:34] <dalek> specs: Document (camel|kebab|snake) case naming conventions

[19:34] <dalek> specs: review: https://github.com/perl6/specs/commit/30aa605bc9

[19:35] <TimToady> anyway, I think this comes out to a DIHWIDT

[19:35] *** atweiden joined
[19:38] *** spider-mario joined
[19:38] <CIAvash> yes, I was just playing with wrap when this happend

[19:39] *** rindolf left
[19:39] <TimToady> .oO(Power tools, power tools, it's my favorite thing to use...Hello, emergency?)

[19:39] <hoelzro> what's the idiom for making some sort of cleanup happen in a deterministic fashion? ex. try(...) in Java, using(...) in C#, with(...) in Python.  is it my $var will leave *.cleanup?

[19:40] <vendethiel> hoelzro: LEAVE?

[19:40] <vendethiel> or yes, will leave

[19:40] <TimToady> 'will leave' is a variant of LEAVE

[19:40] <hoelzro> vendethiel: alright, that's what I thought

[19:41] <TimToady> or if you only need to cleanup on failure, 'will undo'

[19:42] *** rurban left
[19:45] <hoelzro> .tell jnthn could you weigh in on http://irclog.perlgeek.de/perl6/2015-07-04#i_10848766 if you have some time?

[19:45] <yoleaux> hoelzro: I'll pass your message to jnthn.

[19:45] <hoelzro> I'd like to know if I should rakudobug that

[19:47] *** Begi joined
[19:50] *** _mg_ left
[19:54] *** bin_005 joined
[19:55] <lucasb> When a plain literal appears in the text like 42 or "abc", they are boxed (Int,Str) or native (int,str)?

[19:58] <TimToady> we'd like to get to the point where literals can be allomorphic wrt boxing

[19:58] <TimToady> well, some of us would, anyway :)

[20:00] <lucasb> In 'multi f(int) {...}; f(42)', if the block contains just a simple expression, then it works. If it has statements, then it acts as if the 'int' has been upgraded to an 'Int', and then the dispatch fails.

[20:00] <TimToady> but if you're using the distinction for multi-method dispatch, you can't simultaneously not use the distinction

[20:03] *** telex left
[20:04] *** telex joined
[20:04] *** CIAvash left
[20:13] *** darutoko left
[20:20] *** bin_005_z joined
[20:22] *** bin_005 left
[20:30] *** BenGoldberg left
[20:33] *** BenGoldberg joined
[20:36] *** ggoebel joined
[20:38] <smls_> if .WHAT boxes int -> Int, how can we introspect native types?

[20:38] <timotimo> nqp::objprimspec :)

[20:38] <timotimo> may have to decont, though

[20:38] <smls_> heh

[20:40] *** sivoais left
[20:42] *** mmap joined
[20:43] *** Begi left
[20:46] *** mmap left
[20:47] <timotimo> hmm

[20:47] <timotimo> how to best switch two @-sigiled vars around?

[20:48] <timotimo> oh, i got something that works; the problem i was seeing came from somewhere else entirely

[20:53] *** ggoebel left
[21:02] *** lucasb left
[21:02] <smls_> m: my @a = 1, 3; my @b = 2, 4; :(@a, @b) := @b, @a; dd @a, @b

[21:02] <camelia> rakudo-moar 37b579: OUTPUT«@b = [2, 4]<>␤@a = [1, 3]<>␤»

[21:02] <smls_> nice

[21:02] <smls_> though dd still prints the old names :P

[21:05] *** bin_005_z left
[21:05] *** bin_005_z joined
[21:08] *** sivoais joined
[21:11] *** Entonian joined
[21:13] <timotimo> :)

[21:14] <RabidGravy> tum ti tum

[21:17] *** Entonian left
[21:20] <timotimo> still no clue what in my script is leaking so much memory :(

[21:20] *** espadrine left
[21:21] *** BenGoldberg left
[21:28] <dalek> roast: cf2e631 | lizmat++ | S32-hash/adverbs.t:

[21:28] <dalek> roast: More comprehensive testing of hash slicing adverbs

[21:28] <dalek> roast: review: https://github.com/perl6/roast/commit/cf2e631f74

[21:32] *** diana_olhovik left
[21:36] *** amurf joined
[21:41] * masak realizes that he can define a mocked thing as a role with a parameter, so he can share state across that parameter

[21:41] *** amurf left
[21:41] <masak> really sweet way to write tests :>

[21:41] <masak> and one of the few cases of intentional/beneficial reference leakage

[21:41] *** Possum joined
[21:42] <timotimo> hah, kinda cute idea

[21:43] * smls_ doesn't get it

[21:44] <smls_> .oO( Maybe if masak were to write a blog about it... )

[21:44] <smls_> ;)

[21:44] <masak> ooh, now I came up with a cuter way to do it :>

[21:44] *** smls_ is now known as smls

[21:44] <masak> smls_: let me tell you real quickly, even though I now have a better way to do it.

[21:44] <masak> smls: so, in the implementation there is a class called Performer. it receives events by having the .perform(Event) method called on it.

[21:45] <masak> smls: in the tests I want to check that I got the right events.

[21:45] <masak> so I created a `role Mock::Performer[@events] { method perform($e) { @events.push($e) } }`

[21:46] <masak> and then in the tests I could just do `my $performer = Mock::Performer[my @events];` and then inject $performer into the system under test.

[21:46] <smls> why not  class Mock::Performer { has @events; ... }

[21:47] * timotimo not fond of "has $foo"

[21:47] <masak> that was my better idea :)

[21:47] <timotimo> without the dot or exclamation mark, that is

[21:48] <timotimo> masak: but then suddenly your Performer mock has a different API! :)

[21:48] <masak> I just need to put the test method on the mocked performer, too. then I can completely encapsulate @events

[21:48] <smls> timotimo: ah, right, I meant with dot

[21:48] <timotimo> mhm

[21:48] <masak> timotimo: that's not a problem, as long as it fulfills the contract of a Performer

[21:48] <timotimo> i know that you can do it without the ., but i forgot what it does in that case

[21:48] <masak> Liskov cuts but one way

[21:49] <masak> I also mock time in these test, which I always love doing. :>

[21:49] <timotimo> liskov's razor is commonly used for organ transplants

[21:49] <masak> $time.wait(5, minutes);

[21:57] * japhb is busy trying to put an r/w attribute proxy API in front of an event-sourced CQS engine, just to see what that looks like

[21:58] <masak> sounds... weird. :)

[21:58] <masak> one of the big points of CQS is that commands and queries carry more intent than just modifications to attributes.

[21:58] <japhb> Basically, get *almost* back to the original mutable OO API, while in fact underneath it's all event sourcing and domain processing and such.

[22:00] <masak> so a command can be .fix_address or .change_address and they would both modify an $!address attribute somewhere, but the commands would have very different intents.

[22:00] <timotimo> $time.wat(5, minutes)

[22:03] <japhb> masak: As I'm playing around with it, I'm seeing a couple things: 1) It works well for scalar-valued attributes; not so much for anything more complex.  2) It seems useful for the proxy to simply *add* the r/w scalar attribute API, not replace the underlying CQS methods.

[22:04] <masak> japhb: hm. makes sense, I think.

[22:04] <japhb> Anyway, mostly a matter of figuring out what a combined API even looks like, and if it ends up being useful in real code, as opposed to merely in theory.

[22:04] <masak> *nod*

[22:15] *** TEttinger joined
[22:17] *** spider-mario left
[22:40] <atweiden> deep copying Hash[Array[Objs]] is proving very difficult: http://ix.io/jtA

[22:41] <masak> 'night, #perl6

[22:43] <atweiden> is there any similar code to look at? docs are a bit sparse

[22:47] <smls> did you try   .deepmap(*.clone)  ?

[22:56] *** kaare_ left
[22:57] *** bakedb joined
[22:58] *** mrf_ left
[22:58] *** mrf joined
[22:58] *** garu_ left
[22:58] *** Ulti left
[22:58] *** Ulti joined
[22:58] *** garu joined
[22:59] <atweiden> smls: solved

[22:59] <atweiden> with deepmap!

[22:59] <atweiden> tyty

[23:00] *** smls left
[23:00] <RabidGravy> japhb, I made AccessorFacade for the simpple case on a native api

[23:10] *** rurban joined
[23:13] *** RabidGravy left
[23:14] *** zacts joined
[23:15] *** gfldex left
[23:35] *** Peter_R left
[23:37] *** bjz_ left
[23:40] *** atweiden left
