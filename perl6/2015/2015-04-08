[00:11] <tony-o> Let's write it in Larry 6

[00:16] *** tinyblak joined
[00:17] <skids> .oO(Wallrus)

[00:18] <TimToady> though, in fact, most programming languages were named after me :)

[00:20] <TimToady> and I was named after Abraham Lincoln!

[00:20] *** gfldex left
[00:21] <TimToady> .oO(I was named after Ada, and Ada was named after me...)

[00:22] *** aborazmeh joined
[00:22] *** aborazmeh left
[00:22] *** aborazmeh joined
[00:28] *** Ben_Goldberg joined
[00:28] *** andreoss left
[00:31] *** BenGoldberg left
[00:31] *** Ben_Goldberg is now known as BenGoldberg

[00:33] <BenGoldberg> TimToady, If you had a time machine, and went back in time and killed the person whom you were named after, who would you be?

[00:34] <BenGoldberg> Like, the grandfather paradox, but not necessarily getting rid of one's ancestor.

[00:37] <TimToady> but I'd have to kill everyone who was named before me

[00:50] *** laouji joined
[00:54] *** Hor|zon joined
[00:57] *** chenryn_ joined
[00:59] *** Hor|zon left
[01:05] *** aborazmeh left
[01:07] *** aborazmeh joined
[01:07] *** aborazmeh left
[01:07] *** aborazmeh joined
[01:17] <BenGoldberg> If perl6 had a Generalized Continued Fraction type, we could have 'exact' values for pi, and for square roots of rationals, etc.

[01:18] <BenGoldberg> And by exact, I mean, as many significant digits as the user chooses to ask for.

[01:18] *** Zoffix joined
[01:18] *** Zoffix left
[01:18] *** Zoffix joined
[01:27] *** chenryn_ left
[01:28] *** jackdan joined
[01:45] *** [particle] left
[02:00] *** isacloud left
[02:01] *** d4l3k_ joined
[02:01] *** dalek left
[02:01] *** pnu left
[02:02] *** [Tux] left
[02:02] *** geekosaur left
[02:02] *** d4l3k_ is now known as dalek

[02:02] *** ChanServ sets mode: +v dalek

[02:04] *** isacloud joined
[02:04] *** [Tux] joined
[02:04] *** pnu joined
[02:07] *** geekosaur joined
[02:09] *** noganex_ joined
[02:10] *** chenryn_ joined
[02:12] *** noganex left
[02:36] *** laouji left
[02:39] *** laouji joined
[02:43] *** Hor|zon joined
[02:48] *** Hor|zon left
[03:15] <dalek> nqp: 1fd8cde | TimToady++ | src/ (3 files):

[03:15] <dalek> nqp: optimize after of known length to before w/ offset

[03:15] <dalek> nqp: 

[03:15] <dalek> nqp: This saves allocating and flipping a million or so bytes in rakudo compilation

[03:15] <dalek> nqp: just for the occasional <?after '>'> and such.  In fact, all of the afters in

[03:15] <dalek> nqp: nqp and rakudo are of known length, though one of them is just <?after .>.

[03:15] <dalek> nqp: We handle both dot and character classes, as well as any embedded anchors.

[03:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1fd8cdea55

[03:19] <TimToady> not a huge win, maybe 1/20 second and a couple megs of memory, but still

[03:23] <japhb> TimToady: Win at what?  Compiling Rakudo?

[03:26] <TimToady> yes

[03:27] <TimToady> would be a bigger win if you use <after> on a gigastring

[03:27] *** kst joined
[03:28] <TimToady> if your data size dominates, it could nearly double the size of your image to use the old implementation

[03:29] *** raiph joined
[03:29] <TimToady> and you'll still get that behavior if your <after> is of variable width

[03:33] <TimToady> anyway, for compilation purposes, probably not work a separate nqp bump

[03:40] <skids> m: X::AdHoc.new(:payload<foo>).say;

[03:40] <camelia> rakudo-moar 260e3c: OUTPUT«foo␤␤Error while creating backtrace: Op 'backtrace' needs an exception object␤  in method new at src/gen/m-CORE.setting:13982␤  in method backtrace at src/gen/m-CORE.setting:14133␤  in code  at src/gen/m-CORE.setting:14143␤  in method gist at s…»

[03:42] *** laouji left
[03:57] *** telex left
[03:58] *** telex joined
[03:59] *** mr-foobar left
[04:01] *** mr-foobar joined
[04:06] *** kaare_ joined
[04:15] *** chenryn_ left
[04:19] *** raiph left
[04:19] *** [particle] joined
[04:23] *** aborazmeh left
[04:26] *** BenGoldberg left
[04:32] *** Hor|zon joined
[04:37] *** Hor|zon left
[04:38] *** skids left
[04:43] *** laouji joined
[04:47] *** laouji left
[04:47] *** chenryn_ joined
[04:48] *** aborazmeh joined
[04:48] *** aborazmeh left
[04:48] *** aborazmeh joined
[04:50] *** yeahnoob joined
[04:52] <moritz> good morning

[04:52] <raydiak> \o moritz 

[04:52] <moritz> PerlJam: please remember to 'git commit' your changes in /etc/ after adding a user on hack

[04:56] *** laouji joined
[05:11] *** mr-foobar left
[05:12] *** jackdan left
[05:16] *** laouji left
[05:17] *** laouji joined
[05:18] *** mr-foobar joined
[05:19] *** bartolin joined
[05:34] *** tinyblak left
[05:38] *** laouji left
[05:38] *** laouji joined
[05:41] <dalek> nqp: a997d3d | TimToady++ | src/ (3 files):

[05:41] <dalek> nqp: do sawcaps opt by making CAPS more representative

[05:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a997d3d06b

[05:45] *** Psyche^ joined
[05:48] *** mr-foobar left
[05:49] *** Patterner left
[06:17] *** kaare_ left
[06:18] *** tinyblak joined
[06:22] *** Hor|zon joined
[06:27] *** Hor|zon left
[06:30] *** slavik left
[06:32] <dalek> rakudo/nom: 14bb68b | TimToady++ | / (2 files):

[06:32] <dalek> rakudo/nom: bump NQP and do P6 level sawcaps opt as well

[06:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14bb68bf38

[06:37] <jnthn> morning, #perl6

[06:37] <yoleaux> 7 Apr 2015 18:13Z <_edwin> jnthn: I created a PR to fix RT #124204 (did not attempt to fix RT #124205 as by the comments of TimToady and masak the &with parameter of squish is not well-loved anyway). https://github.com/rakudo/rakudo/pull/400

[06:38] *** FROGGS joined
[06:40] <nine> TimToady: I'd rather we bump nqp and MoarVM as often as possible. Makes bisecting much easier cause after you're done with rakudo, you end up with a very small number of nqp/MoarVM commits that may be at fault.

[06:41] <FROGGS> morning

[06:42] <FROGGS> jnthn: do you have gdb or valgrind installed on windows?

[06:43] <nwc10> FROGGS: oh you optimist: http://valgrind.org/ -- summarised as */Linux */Android and */Darwin (for different values of *)

[06:43] <nwc10> but the other half of your "or" might be valid :-)

[06:44] <FROGGS> nwc10: yeah, I feared that... though at least gdb states it can build on Windows

[06:44] <FROGGS> though, I really expected a prebuild binary of gdb for windows

[06:44] *** Rounin joined
[06:44] *** slavik joined
[06:45] <nwc10> not sure, but gdb might only be capable of having one idea about C++, which would mean that you'd need one gdb build per C++ compiler (or at least, perl C++ ABI)

[06:46] <FROGGS> :S

[06:56] *** laouji left
[06:57] *** cdc joined
[07:00] *** _mg_ joined
[07:01] *** vendethiel joined
[07:03] <jnthn> FROGGS: no, I always use my Linux VM for those

[07:03] <jnthn> FROGGS: On Windows I always use the MSVC toolchain, including the VS debugger.

[07:04] <cdc> Hello #perl6

[07:06] <FROGGS> jnthn: okay, then I probably make it not to install perl6-gdb-m and perl6-valgrind-m

[07:06] <FROGGS> hi cdc

[07:06] <cdc> FROGGS o/

[07:06] <jnthn> FROGGS: No, that's probably not very useful on Windows :)

[07:06] <nwc10> it's not possible on all Linux even, let alone real OSes :-)

[07:08] <cdc> the wrapper scripts used for programs installed with Panda are not transparent enough.  For example: "panda install Kains; kains -h"

[07:08] <cdc> it returns this unexpected error: Error while processing "--h=True": unknown switch

[07:08] <cdc> for information, Kains has its own command-line parser (ie. not based on sub MAIN)

[07:10] <FROGGS> eww

[07:10] <FROGGS> cdc: I'll fix that

[07:10] <cdc> thanks!

[07:11] <cdc> FROGGS: I could fill a bug report if you wish.

[07:11] <FROGGS> cdc: yes, then I've got a ticket to close :o)

[07:12] <FROGGS> (and the information at hand)

[07:12] *** rindolf joined
[07:12] *** RabidGravy joined
[07:12] <cdc> FROGGS: in github/panda or rt/perl6?

[07:13] <FROGGS> cdc: RT, because creating the runners happen in rakudo itself

[07:13] <cdc> ok

[07:14] *** diana_olhovik joined
[07:15] <dalek> rakudo/nom: cef1aa3 | TimToady++ | src/core/LoL.pm:

[07:15] <dalek> rakudo/nom: work around jvm NPE on || by using // instead

[07:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cef1aa3aac

[07:16] <nwc10> NPE?

[07:16] <TimToady> null pointer exception

[07:16] <nwc10> at the Java level? (I guess SEGV is SEGV)

[07:17] *** larion left
[07:17] <TimToady> feel free to change it back and debug it at a lower level :)

[07:19] <cdc> to me "null pointer exception" is more precise than SEGV, since SEGV can be caused by pointers that are not NULL.

[07:19] *** virtualsue joined
[07:22] *** Hor|zon joined
[07:23] <cdc> FROGGS: RT#124262

[07:23] <FROGGS> cdc++

[07:27] *** Hor|zon left
[07:30] <dalek> rakudo/nom: 24806d0 | FROGGS++ | / (3 files):

[07:30] <dalek> rakudo/nom: create perl6-gdb-m and perl6-valgrind-m on non-Windows only

[07:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24806d05a2

[07:32] *** aborazmeh left
[07:33] <FROGGS> jnthn: this is how our bug reports might look like from now on: https://gist.github.com/FROGGS/fbddc9ab9bfa85ea6b48

[07:33] <FROGGS> ups

[07:34] <dalek> rakudo/nom: 192bf4b | FROGGS++ | tools/build/create-moar-runner.pl:

[07:34] <dalek> rakudo/nom: flick switch that was turned on for debugging

[07:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/192bf4b40a

[07:36] <dalek> rakudo/nom: 816dd64 | jnthn++ | src/ (2 files):

[07:36] <dalek> rakudo/nom: Catch 5. decimal error at EOF; typed exception.

[07:36] <dalek> rakudo/nom: 

[07:36] <dalek> rakudo/nom: Resolves and allows us to test RT #93988.

[07:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/816dd64ac2

[07:36] *** jack_rabbit left
[07:36] <jnthn> FROGGS++

[07:39] <dalek> roast: f97f8f3 | jnthn++ | S32-exceptions/misc.t:

[07:39] <dalek> roast: Test for RT #93988.

[07:39] <dalek> roast: review: https://github.com/perl6/roast/commit/f97f8f342e

[07:39] *** laouji joined
[07:40] *** rurban_ joined
[07:41] *** laouji left
[07:42] *** abraxxa joined
[07:54] *** laouji joined
[07:54] *** laouji left
[07:55] *** laouji joined
[07:57] <jnthn> FROGGS: I get on Windows when I make now:

[07:57] <jnthn>         C:\PERL64\BIN\perl.exe tools/build/create-moar-runner.pl "C:\consulting\MoarVM\install\bin\moar" perl6.moarvm perl6-gdb-m . "gdb" "C:\consulting\MoarVM\install\share\nqp\lib" .

[07:57] <jnthn> Can't return outside a subroutine at tools/build/create-moar-runner.pl line 13.

[07:57] <jnthn> if ($^O eq 'MSWin32') { return if $toolchain;

[07:57] *** darutoko joined
[07:57] <jnthn> Should htat be exit if ?

[07:58] <jnthn> Seems to help :)

[07:58] <jnthn> I get these warnings also, though:

[07:58] <jnthn>         C:\PERL64\BIN\perl.exe -MExtUtils::Command -e chmod 755 perl6-valgrind-m.bat

[07:58] <jnthn> Cannot chmod 755 perl6-valgrind-m.bat:No such file or directory at C:/Perl64/lib/ExtUtils/Command.pm line 274.

[07:59] <dalek> rakudo/nom: ee0086b | jnthn++ | tools/build/create-moar-runner.pl:

[07:59] <dalek> rakudo/nom: Fix a return that shoulda been exit.

[07:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ee0086bef3

[07:59] <jnthn> Pleae fix better if needed; this unbusts the Windows build :)

[07:59] *** Hor|zon joined
[08:01] *** chenryn_ left
[08:04] *** espadrine left
[08:04] *** virtualsue_ joined
[08:04] *** virtualsue left
[08:04] *** virtualsue_ is now known as virtualsue

[08:06] *** vendethiel left
[08:09] <dalek> rakudo/nom: 16ca41b | jnthn++ | src/Perl6/Grammar.nqp:

[08:09] <dalek> rakudo/nom: Detect undeclared stuff appearing in a BEGIN.

[08:09] <dalek> rakudo/nom: 

[08:09] <dalek> rakudo/nom: Previously we missed catching cases like BEGIN { unknown-thing() }

[08:09] <dalek> rakudo/nom: before going ahead and compiling the BEGIN block, leading to unhelpful

[08:09] <dalek> rakudo/nom: error messages at the BEGIN block's runtime.

[08:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16ca41b6f9

[08:09] <dalek> roast: fc28e69 | jnthn++ | S32-exceptions/misc.t:

[08:09] <dalek> roast: Test undeclared call made in a BEGIN.

[08:09] <dalek> roast: 

[08:09] <dalek> roast: Partially covers RT #81502 (as in, it covers the actual case, but not

[08:09] <dalek> roast: the general issue the ticket is about).

[08:09] <dalek> roast: review: https://github.com/perl6/roast/commit/fc28e69ec0

[08:10] *** laouji left
[08:10] *** laouji joined
[08:14] *** brrt joined
[08:14] *** nbdsp joined
[08:15] <jnthn> moritz: About?

[08:16] <timotimo> o/

[08:16] <FROGGS> hi timotimo 

[08:16] <jnthn> o/ timotimo 

[08:16] <FROGGS> jnthn: :S

[08:17] <jnthn> FROGGS: The chmod things aren't urgent as they're only warnings, not errors

[08:17] <jnthn> FROGGS: The error case I fixed.

[08:17] <jnthn> Well, maybe "fixed" :)

[08:17] *** sirdancealot left
[08:17] <FROGGS> I'll fix the warnings

[08:17] <jnthn> Thanks :)

[08:18] <jnthn> General question

[08:18] <FROGGS> jnthn: you fixed it correctly

[08:18] <jnthn> m: BEGIN { die 'oh noes' }

[08:18] <camelia> rakudo-moar 816dd6: OUTPUT«===SORRY!===␤oh noes␤»

[08:18] <jnthn> We do a crappy job of reporting these kinds of things at the moment

[08:18] <FROGGS> no line number? :/

[08:18] <jnthn> We mix an X::Comp into the exception

[08:18] <jnthn> Right, there's that, but also no stack trace.

[08:18] <jnthn> If you are doing something interesting inside of the BEGIN for example.

[08:19] <jnthn> But no line number is the worse bit

[08:19] <jnthn> Now, I fixed it kinda. :)

[08:19] <FROGGS> we'll see :o)

[08:19] <jnthn> There's something that takes a runtime error and mixes X::Comp into it

[08:20] <jnthn> But I'm wondering if a better design isn't to have a X::Comp::BeginTime or so that contains the runtime exception that occurred at BEGIN time.

[08:21] <jnthn> So we can more clearly say something like "An exception occured in code run at BEGIN time at line 42." and then the exception itself.

[08:21] <FROGGS> that sounds very good to me

[08:22] <jnthn> Yeah. moritz++ did a lot of the typed exceptions work so I'd kinda like to run it by him

[08:22] <FROGGS> yeah

[08:22] <moritz> jnthn: fwiw that was my idea from the start; the one thing it makes a bit harder to match against a specific exception type in tests

[08:22] <moritz> well

[08:22] <jnthn> moritz: Yeah, but we have a neat solution to that for X::Comp::Group

[08:22] <jnthn> moritz: And I wasn't going to re-wrap anything already X::Comp

[08:23] *** zakharyas joined
[08:23] <jnthn> Hm, or maybe I hsould

[08:23] <jnthn> Hmmmmm

[08:23] <nbdsp> Greetings! In documentation there is a short mention of static (or rather static-like) class members. But no examples of usage. If I declare a field inside a class declaration with 'my' instead of 'has', how it can be accessed outside of class declaration block?

[08:23] <jnthn> nbdsp: my $.foo; # creates an accessor method for it

[08:23] <moritz> jnthn: X::Comp and X::Comp::BeginTime sound like they should both be wrappers of the same kind

[08:24] <jnthn> moritz: X::Comp is the role done by all compile-time exceptions, which makes sense to me.

[08:24] <moritz> nbdsp: and feel free to improve the docs

[08:24] <jnthn> moritz: That is, all exceptions the compiler spits out.

[08:24] <moritz> jnthn: I'm not so sure anymore

[08:25] <moritz> jnthn: all the MOP errors can occur both at compile time and at run time

[08:25] <jnthn> moritz: Yeah, that's what I'm struggling on a little bit. How to make MOP errors come out "directly"

[08:25] <moritz> and the boundaries between what "the compiler" is is rather surprising if we exclude the MOP

[08:25] <jnthn> Right

[08:26] <jnthn> Maybe we want an X::MOP marker role on MOP exceptions.

[08:26] <moritz> but that doesn't really help with compile and/or runtime errors

[08:26] <jnthn> It can

[08:26] <jnthn> I think the issue we really have is a "making the error look right" one

[08:27] <jnthn> m: class A { method m() { }; method m() { } }

[08:27] <camelia> rakudo-moar ee0086: OUTPUT«5===SORRY!5=== Error while compiling /tmp/05yuTcwwhB␤Package 'A' already has a Method 'm' (did you mean to declare a multi-method?)␤at /tmp/05yuTcwwhB:1␤------> ␤»

[08:27] <RabidGravy> should some like:  "class Foo {};  my $fb = Metamodel::ClassHOW.new_type(name => 'Foo::Bar'); $fb.^add_parent(Foo); $fb.^compose;" work

[08:27] <moritz> I see the issue more as adding sufficient information

[08:27] <RabidGravy> it appears to "hang" here

[08:27] <FROGGS> m: class Foo {};  my $fb = Metamodel::ClassHOW.new_type(name => 'Foo::Bar'); $fb.^add_parent(Foo); $fb.^compose;

[08:27] <camelia> rakudo-moar ee0086: OUTPUT«(signal SEGV)»

[08:27] <FROGGS> uhh

[08:27] <jnthn> It should work, I think.

[08:28] <FROGGS> time for perl6-gdb-m :o)

[08:28] <RabidGravy> yeah, it spends a lot of time eating memory then maybe SEGV here

[08:28] <moritz> m: class Foo {};  my $fb := Metamodel::ClassHOW.new_type(name => 'Foo::Bar'); $fb.^add_parent(Foo); $fb.^compose;

[08:28] <camelia> rakudo-moar ee0086: ( no output )

[08:28] <jnthn> Huh, here at command line it worked out OK...

[08:28] <moritz> RabidGravy: binding to the rescue

[08:28] *** laouji_ joined
[08:28] <FROGGS> 0x00007ffff79995e5 in MVM_sc_get_collectable_sc (tc=<optimized out>, col=0x7ffff65f9e18) at src/6model/sc.h:69

[08:28] <FROGGS> 69	    return sc_idx > 0 ? tc->instance->all_scs[sc_idx]->sc : NULL;

[08:29] <FROGGS> :S

[08:29] <moritz> the MOP doesn't decontainerize stuff, because it must work for classes like Scalar too

[08:30] <moritz> so while it can't work with mere assignment, it shouldn't segfault either

[08:30] <jnthn> moritz: otoh, we're dealing with type objects, which don't decontainzerize...

[08:30] <FROGGS> jnthn: https://gist.github.com/FROGGS/a8ace85bfc0c31a2015f

[08:31] <jnthn> FROGGS: Weird...

[08:31] <FROGGS> camelia needs a github account, and then it could paste the gdb backtrace automatically when we see a segfault here

[08:31] <timotimo> you don't actually need a github account to upload gists

[08:32] *** laouji left
[08:32] <FROGGS> timotimo: but it is cooler to have one

[08:32] <jnthn> moritz: Back to the X::MOP thing though, I was pondering that we always wrap errors up in a X::Comp::BeginTime that are thrown by BEGIN/constant/the MOP

[08:32] * timotimo doesn't mind either way

[08:32] <jnthn> moritz: That way we get the compile-time location of the thing

[08:32] *** laouji_ left
[08:32] <nbdsp> When I declare 'my $foo;' and 'my $.foo' in a class block and in BUILD method assign '$foo = "bar";' How can I access the value of C::foo outside of class?

[08:33] <moritz> jnthn: then that functionality is duplicated between X::Comp and X::Comp::BeginTime

[08:33] <jnthn> moritz: But for those that are X::MOP marked, we don't include any kind of stack trace.

[08:33] <jnthn> moritz: X::Comp::BeginTime does X::Comp

[08:33] <moritz> jnthn: yes, sounds sane. +1

[08:33] <timotimo> nbdsp: is there a good reason for having the name defined twice? i'd actually expect that to compile-time-error

[08:33] <jnthn> class X::Comp::BeginTime does X::Comp { has $.exception } # or so

[08:33] <jnthn> nbdsp: C.foo

[08:34] <jnthn> m: class A { my $.foo = 42 }; say A.foo

[08:34] <camelia> rakudo-moar ee0086: OUTPUT«42␤»

[08:34] <FROGGS> jnthn: btw, the chmod warning is already gone since my last patch

[08:34] <jnthn> FROGGS: Oh, I didn't re-configure, bad me.

[08:35] <FROGGS> np :o)

[08:35] <jnthn> moritz: For the X::MOP bit, or X::Comp::BeginTime, or both? :)

[08:36] *** diana_olhovik left
[08:36] *** diana_olhovik joined
[08:36] <moritz> jnthn: both

[08:36] <jnthn> FROGGS: I confirm they're gone. :)

[08:36] <jnthn> FROGGS++

[08:36] <jnthn> moritz: OK, cool. I'll work on that. 

[08:37] <jnthn> This'll let us nail a couple more RTs :)

[08:38] <timotimo> https://gist.github.com/timo/697f1a390eada9add0d3 - i have this local patch in my rakudo

[08:38] <timotimo> ideas?

[08:38] <nbdsp> When declare 'my $.foo;' in class and in BUILD try "$.foo = "bar;" I get an error "Virtual call may not be used on partially constrtucted objects"

[08:38] *** dakkar joined
[08:39] <moritz> nbdsp: then use self.foo = bar

[08:39] <jnthn> Well, if you're inside the class you should just use $foo

[08:40] *** _mg_ left
[08:40] <jnthn> Just as you usually use $!foo in a BUILD even if it's declared has $.foo

[08:40] <timotimo> i have a chmod error for perl6-valgrind-m, too :(

[08:41] <JimmyZ> me too :)

[08:41] <jnthn> re-Configure :)

[08:41] <jnthn> It's super effective!

[08:42] <nbdsp> Thanks! It worked. Though using 'self' with static members is slightly confusing.

[08:42] <timotimo> i did re-configure, though

[08:42] <timotimo> all the parts

[08:43] *** diana_olhovik left
[08:44] <moritz> nbdsp: you can use ::?CLASS or the class name if you find that less confusing

[08:44] <FROGGS> timotimo: but you are on linux, you should have a perl6-valgrind-m

[08:45] <timotimo> i do

[08:45] *** larion joined
[08:45] *** laouji joined
[08:45] <timotimo> hum

[08:46] <nbdsp> moritz: yes, I already figured it (using CLASS.foo instead of self.foo in BUILD.) Thanks for helping!

[08:46] <timotimo> with moreinput, i can't just "say 'hi'" in the repl any more, as it asks for a ;

[08:46] <timotimo> i'm not sure if i like that ... but it's not that important

[08:46] <timotimo> can't have it both ways, i'm afraid

[08:47] <FROGGS> timotimo: I thought pressing enter twice would also work

[08:47] <timotimo> oh

[08:47] <timotimo> didn't try that

[08:48] <timotimo> would we want perl6-valgrind-m to tell moarvm to clean up all data on shutdown?

[08:51] <FROGGS> ohh, that's perhaps a good idea

[08:51] <timotimo> --full-cleanup

[08:51] *** nbdsp left
[08:55] *** pecastro joined
[08:55] *** _mg_ joined
[08:56] *** fhelmberger joined
[08:56] <timotimo> which --debug setting gives better debugging experience - like debug symbols, line numbers, better stack traces - but no speed penalties?

[08:57] <FROGGS> I use --debug=3, though I've never compared performance to other settings

[08:57] <timotimo> mhm

[08:57] *** Vlavv_ left
[08:59] <DrForr> Incidentally, https://github.com/drforr/perl6-readline # Very *very* minimalistic so far, though. Need to add proper docs and test suites before giving it any kind of official status.

[08:59] <dalek> rakudo/nom: f1cf715 | jnthn++ | src/core/Exception.pm:

[08:59] <dalek> rakudo/nom: Only include position pointer if we have $.pre.

[08:59] <dalek> rakudo/nom: 

[08:59] <dalek> rakudo/nom: Avoids spitting out compile-time errors with a "----->" followed by

[08:59] <dalek> rakudo/nom: nothing.

[08:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f1cf7158fa

[08:59] <dalek> rakudo/nom: 8337d80 | jnthn++ | src/core/Exception.pm:

[08:59] <dalek> rakudo/nom: Add an X::MOP; make an existing exception do it.

[08:59] <dalek> rakudo/nom: 

[08:59] <dalek> rakudo/nom: We'll use this to flag errors from the MOP that are to be displayed

[08:59] <dalek> rakudo/nom: verbatim, rather than as if they were unexpected due to some internal

[08:59] <dalek> rakudo/nom: MOP failure.

[08:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8337d80860

[09:02] *** chenryn_ joined
[09:03] *** espadrine joined
[09:05] <timotimo> FROGGS: would we want to support options to valgrind in perl6-valgrind-m? as it suggests "Rerun with --leak-check=full to see details of leaked memory" at the very end, for example

[09:05] <timotimo> or allowing -v

[09:05] <FROGGS> hmmm

[09:05] <FROGGS> how would we do that?

[09:06] <jnthn> env var may be the best way

[09:06] <timotimo> may be, yes

[09:06] <FROGGS> yeah

[09:06] <timotimo> and put a little explanation text at the very end

[09:06] <FROGGS> or top

[09:06] <FROGGS> where the description is

[09:07] <FROGGS> well

[09:07] <timotimo> do we have something simple to get the current width of the terminal?

[09:07] <FROGGS> there is a rosettacode sample that centers something...

[09:07] <FROGGS> was it the clock?

[09:08] <FROGGS> my ($rows,$cols) = qx/stty size/.words;

[09:08] <FROGGS> http://rosettacode.org/wiki/Draw_a_clock#Perl_6

[09:08] <DrForr> %ENV{'ROWS','COLS'} maybe?

[09:08] *** cschwenz joined
[09:09] <timotimo> DrForr: those are often pseudo-env-vars made by your shell

[09:09] *** Ven joined
[09:09] <FROGGS> yeah, I dont have them here

[09:09] <DrForr> right, and they're generally derived from a library like ncurses. I know some shells export them, some don't.

[09:09] <DrForr> Actually termcap, come to think of it?

[09:09] <timotimo> stty seems like a better approach

[09:10] *** kaare_ joined
[09:10] *** Vlavv_ joined
[09:10] <timotimo> i was about to suggest froggs uses it for the ==== and ---- in valgrind-m (and also gdb-m), but then there'd also have to be proper word breaking

[09:10] <timotimo> and that's a little can of worms :)

[09:10] *** laouji left
[09:10] <FROGGS> *g*

[09:11] <DrForr> There's always the TeX word breaking algorithm :)

[09:11] <timotimo> it's a Pretty Little Worms' Can

[09:11] <DrForr> (though it's probably tuned to American English and woefully out of date, thus contributing its own pile of worms.)

[09:12] *** laouji joined
[09:13] <tadzik> or The New Cool TeX Replacement

[09:14] <DrForr> Omega? Or Simon's?

[09:14] <tadzik> last time I checked, google reacted to "that new cool tex from fosdem", now it does not

[09:14] <tadzik> Simon's, yes

[09:14] <tadzik> scile? Stila?

[09:14] *** Sqirrel joined
[09:14] <DrForr> SILE.

[09:14] <tadzik> right, thanks

[09:15] <tadzik> http://www.sile-typesetter.org/

[09:15] <DrForr> Of course. It was "hot" for a few days after the FOSDEM talk, now it's old hat, who wants an "old" library? (bloody Internet time...)

[09:17] * timotimo can has watch that video

[09:21] *** chenryn_ left
[09:22] *** chenryn_ joined
[09:25] <timotimo> ... have to do your own slide scrolling next to the video

[09:25] <timotimo> can't use the video to see the slides

[09:25] <timotimo> can't even see a tiny piece of the slides on the video

[09:28] *** rurban_ left
[09:28] *** Ven left
[09:28] <jnthn> ah, improvement :)

[09:28] <jnthn> https://gist.github.com/jnthn/1bb97ea3820d5248d6ad

[09:29] <jnthn> Going through the MOP and typed-exceptioning things is gonna be a longer task, which I won't take on right now.

[09:29] <jnthn> So I think we gradually switch over to the new thing.

[09:29] <jnthn> Starting with BEGIN blocks.

[09:31] <moritz> jnthn: also, once you've committed some stuff, others can do some of the grunt work

[09:31] <jnthn> Right :)

[09:31] *** chenryn_ left
[09:35] <masak> good practically-noon, #perl6

[09:36] <timotimo> ohai, masak 

[09:36] <brrt> good anytime, masak

[09:38] <jnthn> o/ masak

[09:38] <timotimo> masaktime is always a good time

[09:38] <jnthn> .oO( Stop! masaktime! )

[09:39] <dalek> rakudo/nom: abed501 | jnthn++ | src/ (3 files):

[09:39] <dalek> rakudo/nom: Handle exceptions from BEGIN blocks better.

[09:39] <dalek> rakudo/nom: 

[09:39] <dalek> rakudo/nom: We now include details of where the BEGIN block was in the code, the

[09:39] <dalek> rakudo/nom: fact that the error occurred while evaluating a BEGIN block, and a

[09:39] <dalek> rakudo/nom: stack trace inside of the BEGIN block. The mechanism will also be

[09:39] <dalek> rakudo/nom: useful for improving errors from the MOP (which we'll not show the

[09:39] <dalek> rakudo/nom: stack trace for) and other things like constants.

[09:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abed501645

[09:39] <dalek> roast: 99b6ed7 | jnthn++ | S32-exceptions/misc.t:

[09:39] <dalek> roast: Second test to fully cover RT #81502.

[09:39] <dalek> roast: review: https://github.com/perl6/roast/commit/99b6ed7741

[09:39] *** yeahnoob left
[09:44] *** kaare_ left
[09:44] <arnsholt> tadzik: I am generally very sceptical of anything purporting to be a (La)TeX replacement, for the simple replacement that pretty much all of them miss the actual reason it's so damned hard to kill

[09:45] *** diana_olhovik joined
[09:45] <masak> s:2nd/replacement/reason/ ?

[09:45] <arnsholt> That reason being that TeX is actually a full (that is, Turing complete) programming language

[09:45] <tadzik> yeah, I'm having trubble parsing

[09:45] <arnsholt> Er, yeah

[09:45] <arnsholt> BrainUnderflowError

[09:46] <timotimo> this simon person has a voice that i find similar to mst's

[09:46] <jnthn> I think that's an affliction known as "British accent" :P

[09:47] <RabidGravy> :)

[09:47] <arnsholt> So treating (La)TeX as a markup language for documents isn't quite the right tack; it's a programming language, that happens to compile to viewable documents rather than binaries

[09:47] <timotimo> also a little bit of shouting

[09:47] <RabidGravy> mind you he's been in Japan for nearly ten years

[09:48] <FROGGS> arnsholt: you can hack Ruby in SILE

[09:49] <FROGGS> arnsholt: on the other hand the concept of SILE sounded very very right

[09:50] <moritz> IMHO a good approach is to allow programmable extensions, but make the boundary very clear what is markup and what is programming

[09:50] <FROGGS> arnsholt: you are also not going to position every single element on a web page using javascript, you are mostly using html primitives and javascript where HTML is not flexible enough

[09:51] <arnsholt> I must confess to really liking the way TeX works =)

[09:51] <FROGGS> arnsholt: I got that :o)

[09:51] <arnsholt> But remember that TeX is a programming language expressly made for the purpose of typesetting documents

[09:51] <FROGGS> though some things seem to be pretty hard in Tex

[09:51] <arnsholt> So the HTML/JS analogy isn't quite right

[09:52] <FROGGS> it is the closest analogy I have

[09:52] <FROGGS> and when you compare the inupt/output, it is a good analogy

[09:53] <FROGGS> the fact that TeX is more of a programming language might be TeX's fault, and not the best approach for that kind of task anyway

[09:53] <FROGGS> because, why the heck shall I *program* a document?

[09:54] <arnsholt> Because it turns out to be a relatively workable solution =)

[09:54] <tadzik> what I don't like about TeX is that it's super-powerful, but still not powerful enough to do some things independently

[09:54] <arnsholt> But remember, TeX is a very different programming language from both Turing machines and Lambda calculus

[09:54] <arnsholt> It's a string rewriting system

[09:54] <tadzik> so you end up with stuff like lilypond, which, if you want to embed in a TeX document, you have to compile it with lilypond first and then with tex

[09:55] <FROGGS> arnsholt: obviously not for right-to-left text or other example he has shown in Brussels

[09:55] <moritz> arnsholt: TCL

[09:55] <tadzik> same with bibtex, iirc

[09:55] <tadzik> so you end up with a full stack of compilers, and a full stuck user

[09:56] <arnsholt> Bibtex is horrible

[09:56] <timotimo> hah, simon actually mentions "perl 6" in a little joke

[09:56] <FROGGS> ideally it would be: input (text+images+properties) ==> template (with hooks into a programing language for rare cases) ==> document

[09:57] <arnsholt> Yeah, but the template tends to keep having these little logic snippets in it

[09:57] <arnsholt> Like "on a left-hand side do this, on a right-hand side to this slightly different thing"

[09:57] <FROGGS> arnsholt: yes, and they should be little :o)

[09:58] <arnsholt> Well, yeah. But they're not that rare

[09:58] <arnsholt> So you want it to be low-friction to insert them

[09:59] <arnsholt> And the fact that TeX is string-rewriting means that the syntax is stupidly extensible. See for example TikZ

[10:01] *** charsbar_ left
[10:01] * timotimo has TikZ'd before

[10:01] <timotimo> i even wrote a script that outputs TikZ

[10:01] <arnsholt> -10/10, would never TikZ again? =)

[10:01] <timotimo> no, it was fine

[10:01] *** charsbar_ joined
[10:01] <arnsholt> Ah, good. TikZ isn't without it's warts either

[10:02] <arnsholt> I suspect that TeX has found a very odd local maximum, TBH

[10:02] <moritz> and a very big one

[10:03] <moritz> you need to put *a lot* of effort into a solution to come out better than TeX

[10:03] <timotimo> most probably

[10:03] <arnsholt> Yeah. And it doesn't help that by this point there's something like 30 years of continued use of TeX that's not going away

[10:04] <tadzik> well, if we didn't try new things we'd still all be eating breastmilk :)

[10:05] <arnsholt> *giggle*

[10:05] <arnsholt> Yeah, I'm not against new things

[10:06] <arnsholt> And SILE really does look like it gets it. It's just so many purported replacements that seem to think that equation typesetting and pretty fonts are somehow the reason TeX has been around for so long

[10:06] <arnsholt> (Maybe I should just stop reading Hacker News =)

[10:09] <masak> wise words.

[10:11] *** pdcawley left
[10:11] <RabidGravy> should rw arguments work in native subs?  

[10:12] <timotimo> froggs has very recently been working on rw arguments to native subs for both MoarVM and JVM

[10:12] <FROGGS> RabidGravy: for native ints and nums, yes

[10:12] <timotimo> FROGGS++ # for native subs and rw arguments

[10:12] <FROGGS> :o)

[10:12] <masak> "native subs"?

[10:13] <FROGGS> masak: a sub where 'is native' is applied on

[10:13] <masak> ah -- connected to NativeCall, I presume.

[10:13] <timotimo> yes

[10:13] <timotimo> of course, well-written subs get to native speeds on MoarVM anyway :P :P

[10:14] <masak> :D

[10:14] <RabidGravy> but not e.g.    e.g.     " sub uname(Utsname $uts is rw --> Int) { ... } " where Utsname is  the appropriate repr('CStruct')

[10:15] <RabidGravy> with the "is native" in the appropriate place of course

[10:16] *** pdcawley joined
[10:17] <masak> m: sub foo(int $x is rw) { $x++ }; my int $y = 41; foo($y); say $y

[10:17] <camelia> rakudo-moar 8337d8: OUTPUT«42␤»

[10:17] <FROGGS> RabidGravy: what's the corresponding C function signature?

[10:17] <masak> incredible.

[10:17] <RabidGravy> int uname(struct utsname *name);

[10:18] <FROGGS> RabidGravy: then you don't need the 'is rw'

[10:18] <FROGGS> RabidGravy: CStructs are passed by pointer by default

[10:19] *** _mg_ left
[10:19] *** grondilu joined
[10:20] <grondilu> m: say join ",", 1 .. pi

[10:20] <camelia> rakudo-moar abed50: OUTPUT«1,2,3␤»

[10:21] <RabidGravy> "/home/jonathan/.rakudobrew/bin/perl6: line 2: 31790 Segmentation fault      (core dumped)"

[10:21] <FROGGS> RabidGravy: can you gist your code?

[10:21] <RabidGravy> https://gist.github.com/jonathanstowe/65123671ccc8b8322c33

[10:22] <RabidGravy> (was just doing it :)

[10:22] <FROGGS> lemme check

[10:23] <FROGGS> $ perl6 uname 

[10:23] <FROGGS> Utsname.new(sysname => Str, nodename => Str, release => Str, version => Str, machine => Str)

[10:23] <FROGGS> 0

[10:23] <FROGGS> RabidGravy: what's your compiler version?

[10:24] <RabidGravy> This is perl6 version 2015.03-175-gae68631 built on MoarVM version 2015.03-55-g0acf845

[10:24] *** lizmat joined
[10:25] <FROGGS> you should upgrade, though even when I can call uname($a), saying $a segfaults

[10:26] <FROGGS> MVM_nativecall_refresh is to blame

[10:30] *** Hor|zon left
[10:30] <FROGGS> I think you cannot have Str attributes there

[10:32] <RabidGravy> yeah, that's what I was thinking because they are e.g. " char sysname[_UTSNAME_SYSNAME_LENGTH];"  so it's actually an an array of fixed length of int8

[10:32] <FROGGS> that's not the problem

[10:32] <FROGGS> the problem is that C scribbles over our nice Perl 6 objects here I think

[10:34] <osfameron> is there a quickcheck like thing for Perl6?

[10:36] *** chenryn_ joined
[10:36] <tadzik> quickcheck?

[10:37] *** laouji left
[10:37] <dalek> rakudo/nom: b05c2cc | jnthn++ | src/Perl6/Actions.nqp:

[10:37] <dalek> rakudo/nom: Improve reporting of exceptions inside constants.

[10:37] <dalek> rakudo/nom: 

[10:37] <dalek> rakudo/nom: Previously they lacked line numbers and that the error happened while

[10:37] <dalek> rakudo/nom: evaluating a constant. Now both are in place. Fixes RT #123967.

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b05c2cc020

[10:37] <masak> osfameron: no, but there totally should be.

[10:37] <dalek> roast: 5069ad0 | jnthn++ | S32-exceptions/misc.t:

[10:37] <dalek> roast: Test for RT #123967.

[10:37] <dalek> roast: review: https://github.com/perl6/roast/commit/5069ad05f3

[10:37] <masak> osfameron: in one of my blog posts, I cobble together some simple stuff to pretend I have quickcheck.

[10:37] <masak> osfameron: http://strangelyconsistent.org/blog/boxes-and-pebbles

[10:38] <masak> heading "Proving stuff with QuickCheck"

[10:38] <arnsholt> tadzik: Quite possibly the coolest way of testing software ever

[10:38] <osfameron> masak: interesting, thanks

[10:38] <masak> yes, QuickCheck is the future.

[10:38] <osfameron> I wonder if it's worth porting drmciver's Hypothesis from Python

[10:39] <masak> osfameron: the thought occurred to me as well.

[10:39] <arnsholt> Bascially, you state theorems/properties that your function should obey, and the library randomly generates inputs and checks that the properties hold

[10:39] <masak> osfameron: if you end up designing such a port, send it by me and I'll give constructive comments.

[10:39] <osfameron> we could call it hypothe6 :-)

[10:39] <masak> osfameron: haha

[10:40] <arnsholt> For extra credit, you can also do minimisation of problematic inputs

[10:40] <osfameron> ah, does hypothesis not do that?

[10:40] <masak> I'm pretty sure it does.

[10:41] *** chenryn_ left
[10:41] <masak> arnsholt: I've also seen the theorems/properties stuff expressed as a "mini-model", capturing the relevant essence of the implementation. when they diverge, you haz a bug.

[10:41] <arnsholt> Yeah, that's a nice view as well

[10:41] <RabidGravy> FROGGS, so in summary something like this is unlikely to work for the time being

[10:43] <FROGGS> RabidGravy: I think it will work somehow, I just need to understand what we are doing wrong currently

[10:45] <RabidGravy> okay :) 

[10:59] <grondilu> m: say (1 .. pi)[]; # is the upper-limit supposed to be cast to Int?

[10:59] <camelia> rakudo-moar b05c2c: OUTPUT«1..3.14159265358979e0␤»

[10:59] <grondilu> m: say (1 .. pi).join(',')

[10:59] <camelia> rakudo-moar b05c2c: OUTPUT«1,2,3␤»

[11:00] * grondilu was reading http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications#Perl_6 and wondered if the .floor was needed in 2 .. x.sqrt.floor

[11:01] <masak> don't think so

[11:01] *** larion left
[11:03] <timotimo> ah

[11:03] *** larion joined
[11:04] <timotimo> yet another case where we really want flattened, sized arrays (or in this case strings) for nativecall

[11:07] *** Sqirrel left
[11:10] <psch> \o

[11:10] <psch> grondilu: http://design.perl6.org/S03.html#Range_and_RangeIter_semantics

[11:10] <psch> so 1 .. pi shouldn't truncate pi

[11:10] <psch> 2nd paragraph below the heading

[11:11] <dalek> modules.perl6.org: cd61df3 | (Cédric VINCENT)++ | web/lib/P6Project/Hosts/Github.pm:

[11:11] <dalek> modules.perl6.org: Add README.txt as valid README filename.

[11:11] <dalek> modules.perl6.org: review: https://github.com/perl6/modules.perl6.org/commit/cd61df3740

[11:12] * psch .oO( and ( 0.0 .. 4.0 ) (-) (0e0 .. pi ) is non-float Rats..? )

[11:14] *** kaare_ joined
[11:15] *** Sqirrel joined
[11:16] * lizmat wonders whether the Easter bunny has eaten all of the P6W tuits

[11:16] <yoleaux> 7 Apr 2015 13:33Z <FROGGS> lizmat: do we want to move .cleanup from IO::Path to IO::Pathy? currently panda stumbles over IO::Dir.cleanup not being there

[11:17] <lizmat> .tell FROGGS I'm not sure we want to keep cleanup, now that we have .resolve

[11:17] <yoleaux> lizmat: I'll pass your message to FROGGS.

[11:17] *** chenryn_ joined
[11:19] <timotimo> lizmat: sorry about p6w being so slow

[11:19] <jnthn> I thought the Easter bunny was supposed to bring *us* things to eat...

[11:19] <timotimo> i meant to do it yesterday, but it didn't work out so well :S

[11:20] <timotimo> the wordpress "experience" keeps getting worse and worse and worse

[11:20] <FROGGS> lizmat: good point

[11:20] <yoleaux> 11:17Z <lizmat> FROGGS: I'm not sure we want to keep cleanup, now that we have .resolve

[11:27] *** diana_olhovik left
[11:29] <FROGGS> m: say "foo/bar".IO.resolv

[11:29] <camelia> rakudo-moar b05c2c: OUTPUT«No such method 'resolv' for invocant of type 'IO::Path'␤  in block <unit> at /tmp/vSocdJWIbq:1␤␤»

[11:29] <FROGGS> m: say "foo/bar".IO.resolve

[11:29] <camelia> rakudo-moar b05c2c: OUTPUT«/home/camelia/foo/bar␤»

[11:29] <FROGGS> m: say "foo\\bar".IO.resolve

[11:29] <camelia> rakudo-moar b05c2c: OUTPUT«/home/camelia/foo\bar␤»

[11:29] <FROGGS> :/

[11:30] <FROGGS> lizmat: that's what panda used .cleanup for

[11:30] <FROGGS> to get something comparable

[11:31] <lizmat> well, in newio there are no backslashes   :-)

[11:31] <FROGGS> ahh :o)

[11:32] <FROGGS> I'll test that

[11:36] <cdc> lizmat: do you think it is worth adding a :recursive adverb to mkdir? (to get the same behavior as "mkdir -p")

[11:36] <jnthn> .ask TimToady at present, "eager" always assumes we should list-ify. I'm trying to figure out the right way to make try blorsts an eager context, but I can't just call eager at present as it'll listify all the things. Thoughts? :)

[11:36] <yoleaux> jnthn: I'll pass your message to TimToady.

[11:37] <lizmat> cdc: I like the functionality, but am not sure what the current stance is on adding adverbs to core functions

[11:37] <masak> cdc: :recursive doesn't sound like the right word for that functionality.

[11:37] <lizmat> so I'm not sure adding a :recursive adverb would be an acceptable way to go

[11:38] <lizmat> (or any other adverb, for that matter)

[11:38] <masak> maybe :create-parents

[11:38] <masak> lizmat: &subst is a core function and it has "adverbs"/named arguments like :g

[11:39] <FROGGS> open() also takes adverbs/nameds

[11:39] *** esaym153 left
[11:39] *** esaym153 joined
[11:39] <arnsholt> There's perhaps an opposite view: mkdir probably isn't what we want most of the time

[11:39] *** sirdancealot joined
[11:39] <lizmat> yes, but several times in the past when I suggested adding adverbs for functionality, it was frowned upon (at least in my experience)

[11:40] <lizmat> so now we have e.g. slurp and slurp-rest

[11:40] <FROGGS> I only know about :bin not being liked, because it changes the return type

[11:40] <arnsholt> Common Lisp has a function ensure-directories-exist(), which is perhaps what we'll want at the high level more frequently than mkdir

[11:40] <lizmat> instead of a :close adverb on slurp

[11:41] <masak> lizmat: it's a fine balance. .roll used to be a named argument on .pick

[11:41] <lizmat> indeed, and I'm not sure where that balance is atm

[11:41] <brrt> on the other hand

[11:41] <FROGGS> me neither

[11:41] <masak> there's no hard-and-fast rule

[11:41] <brrt> mkdir() can perfectly well be simple-and-dumb in core

[11:41] <masak> just design sensibilities

[11:42] *** esaym153 left
[11:42] <brrt> and we may have any number of make-sure-path-exists 'wrappers'

[11:42] <lizmat> clearly, I don't have the right sensibilities in that area

[11:42] <masak> lizmat: I wouldn't say that

[11:42] <brrt> just that this very difficult

[11:42] <masak> lizmat: you just make a lot of changes, and so of course many of them end up being challenged

[11:42] <brrt> because you want the right answer for all users

[11:43] <FROGGS> I guess one could say: if the functionality that can be chosen does not deserve its own routine, then it is a valid named param to the existing routine

[11:44] <FROGGS> brrt: and you never can please everyone :o)

[11:44] <brrt> right :-)

[11:44] <masak> there's also the balance between overstuffing core routines vs providing by the default behaviour that the user would otherwise have to implement on top of the core routines

[11:44] <FROGGS> I still get "shouted" at for what I did since 2013 for S11...

[11:44] <masak> :)

[11:45] * masak doesn't get shouted at much for macros, because it's so bloody hard to grok :P

[11:45] <FROGGS> :P

[11:45] <brrt> anyway, if i recall correctly python has os.makedirs() for the 'recursive' functionality and os.mkdir() for the simple functionality

[11:45] <brrt> personally...

[11:45] <brrt> i'd argue that these should be different because they can fail in different ways

[11:45] <lizmat> so you're saying I should grow a thicker skin?

[11:45] <masak> brrt: right.

[11:45] <masak> lizmat: no.

[11:45] <lizmat> I think that would be dangerous

[11:45] <FROGGS> mkdirs/mkpath/mkdir(:p)... they all sound good

[11:46] <masak> lizmat: saying you've placed yourself in a position where the things you build are subject to a lot of debate.

[11:46] <masak> (as opposed to someone who works exclusively in the module ecosystem, for example)

[11:46] <masak> I don't think a thick skin is a solution to anything.

[11:47] <lizmat> I agree with you on that  :-)

[11:47] * cdc likes when lizmat smiles

[11:47] <cdc> :-)

[11:47] <FROGGS> lizmat: and please do more butt kicking to get valuable reviews :S

[11:47] <masak> but something would be *wrong* with the process if the kinds of changes you make didn't sometimes get responses all over the map

[11:47] <masak> it's still up to all of us to keep stuff civil

[11:47] <brrt> also... if i can add a small thing to the adverb discussions

[11:48] <masak> and to remind each other of when we fail at that

[11:48] <brrt> where *i* would say that an adverb belonged is, for example, to modify edge-case behaviour

[11:48] <FROGGS> brrt: aye

[11:48] <brrt> mkdir("foo", :fail-silently-if-exists)

[11:48] <masak> right

[11:49] <lizmat> masak: which is why I moved away from the channel, because I had a hard time staying civil

[11:49] <FROGGS> then again, there is no hard line between edge-case-behaviour and too-different-functionality

[11:49] <brrt> nope

[11:49] <brrt> i agree on that

[11:49] <masak> lizmat: that has happened to me too.

[11:49] <jnthn> Arrrgh

[11:49] <brrt> :-o

[11:49] <masak> lizmat: I stayed away for a month once because I got hurt by something someone said.

[11:49] <FROGGS> ohh, that rude jnthn again :o)

[11:49] * jnthn is working on the "try +'foo'" stuff.

[11:50] <FROGGS> ohh, nice

[11:50] <masak> jnthn: "try+'foo'"?

[11:50] <FROGGS> masak: it does not get catched

[11:50] <jnthn> And wondering why on earth try { use fatal; +'foo' } didn't actually fatalize

[11:50] <jnthn> m: try +'foo'

[11:50] <camelia> rakudo-moar b05c2c: OUTPUT«Unhandled exception: Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏foo' (indicated by ⏏)␤   at <unknown>:1  (/home/camelia/rakudo-inst-2/share/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/…»

[11:50] <jnthn> Eventually discovered that the fail in Str.Numeric never gets called.

[11:51] <jnthn> Turns out we constant fold it to a Failure... D'oh. 

[11:51] <masak> haha

[11:51] <jnthn> That took a bit to figure out...

[11:51] <brrt> (masak, lizmat: this channel? I must have been lucky since i hardly ever see negativity here)

[11:52] <masak> brrt: I believe it was. the key is that things can hurt disproportionately more than they were meant to, and/or be understood in other ways they were meant to.

[11:53] <lizmat> so, what about Cool.has-substr?

[11:53] <lizmat> (commit 049020f3)

[11:53] <lizmat> it is not specced

[11:53] <lizmat> I like the functionality

[11:53] <lizmat> but I think the name is wrong

[11:53] * brrt nods about that

[11:53] <lizmat> has-substr-at

[11:53] <brrt> it should be can-haz-substr

[11:53] <lizmat> would maybe be better

[11:54] <masak> my first thought is "isn't that was .index does?"

[11:54] <lizmat> no, because it will  just return a boolean

[11:54] <brrt> m: "foo".has-substr("o")

[11:54] <camelia> rakudo-moar b05c2c: ( no output )

[11:54] <lizmat> and it will only check *at that position*

[11:54] <masak> oh, I see.

[11:54] <brrt>  m: "foo".has-substr("o") m: "foo".has-substr("o").say

[11:54] <camelia> rakudo-moar b05c2c: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Y1mobtbUy2␤Two terms in a row␤at /tmp/Y1mobtbUy2:1␤------> 3"foo".has-substr("o")7⏏5 m: "foo".has-substr("o").say␤    expecting any of:␤        infix␤        infix stopper␤        statement …»

[11:54] <brrt>  m: "foo".has-substr("o").say

[11:54] <camelia> rakudo-moar b05c2c: OUTPUT«False␤»

[11:55] <lizmat> m: m: "foo".has-substr("o",1).say

[11:55] <camelia> rakudo-moar b05c2c: OUTPUT«True␤»

[11:55] <masak> yeah, then .has-substr-at sounds like a good name

[11:55] <brrt>   m: "foo".has-substr("fo").say

[11:55] <camelia> rakudo-moar b05c2c: OUTPUT«True␤»

[11:55] <brrt> that is pretty much like starts-with

[11:55] <brrt> or substr-starts-with

[11:55] <lizmat> also, for the pos is 0 case

[11:55] <masak> but I also wouldn't mourn if this wasn't a core method at all, but the optimizer just generated nqp::eqat code under the hood when it could.

[11:55] <lizmat> brrt: I think it should be "starts-with"

[11:56] <brrt> but it is on Cool. (large languages are difficult to design)

[11:57] <flussence> I'd call that substr-eq

[11:58] <masak> that works, too

[12:00] <jnthn> substr-eq ain't bad...after all, it is an eq-esque operation...

[12:00] <lizmat> agree

[12:00] <lizmat> also for the pos = 0 case ?

[12:01] <masak> not sure it should have a default

[12:01] <masak> there doesn't seem to be anything special about 0 in this case

[12:01] <lizmat> well, it is used often to see if a string starts with something

[12:01] <lizmat> and I would assume, typically in hot code paths

[12:01] *** eli-se joined
[12:02] <lizmat> so I think there should be at least a candidate without position

[12:02] <brrt> call it strncmp :-P

[12:02] <lizmat> possibly with a different name

[12:02] <masak> .starts-with perhaps without a $pos parameter

[12:02] <lizmat> that would be my suggestion

[12:03] <tadzik> .substrang

[12:03] <lizmat> ??

[12:03] *** prasanna joined
[12:03] <masak> I'd still prefer a smart-enough optimizer to a proliferation of methods. but aside from that, I like .starts-with and .substr-eq

[12:04] <brrt> you'll have a proliferation of methods anyway :-)

[12:04] <masak> yeah, but for other reasons

[12:04] <masak> "it'll be bad anyway" is never a good argument to make it worse :)

[12:04] <brrt> right

[12:07] <timotimo> fwiw, i really like the "eqat" name

[12:07] *** prasanna left
[12:07] <timotimo> i've thought about generating eqat for /^foo/ or /foo$/ before, but the problem is figuring out when a full Match object isn't necessary, or alternatively building a "fake" one

[12:08] <masak> the trick with cheating is not getting caught

[12:08] <timotimo> very much so; i learned that during my time with perl6 :)

[12:08] <flussence> .oO( maybe we need a ?~~ operator )

[12:08] <timotimo> sadly, i'm beight caught out for not posting the weekly yet :P

[12:09] <masak> yeah, what's up with that :P

[12:09] <masak> we're gonna sit here and assume we're entitled to a blog post until you produce one! :P

[12:12] <jnthn> Turns out that making try blocks "use fatal" means all the "lives_ok" tests run under "use fatal"

[12:12] <jnthn> Which gives us a huge load of spectest failures.

[12:12] <timotimo> oh, whoops

[12:13] *** telex left
[12:13] <jnthn> So I can't exactly commit that.

[12:14] *** telex joined
[12:14] <jnthn> Well, I can, but not to nom

[12:14] <eli-se> I wish UPDATE were called ALTER RECORD and INSERT were called CREATE RECORD.

[12:15] <eli-se> And DELETE DROP RECORD.

[12:15] <timotimo> Imagine all the terabytes of transmitted data that have been saved by having the shorter names!!

[12:16] <tadzik> nothing compared to people sending pictures via email

[12:17] <timotimo> how many queries are done per day, how many pictures are sent via email per day?

[12:17] <tadzik> sshh

[12:18] <tadzik> but them bytes!

[12:19] <|Tux|> nothing compared to people sending html e-mails

[12:19] <yoleaux> 6 Apr 2015 18:24Z <nine_> |Tux|: FROGGS++ fixed the MoarVM regression that affected Inline::Perl5

[12:20] <timotimo> pictures sent over ssh!

[12:20] <brrt> pictures sent at all!

[12:20] <|Tux|> I do ssh -Y all the time

[12:20] <brrt> why not just text

[12:20] * psch .oO( ssh -Y | aalib )

[12:21] <masak> eli-se: but "RECORD" fails to convey that in many cases, one operates on several records at a time with those operations.

[12:21] <eli-se> RECORDS

[12:21] <eli-se> and an error if you operate on only one!

[12:22] <brrt> that is contrary to the set-nature of relational database tables

[12:22] <eli-se> unfortunately SQL works with bags not sets :(

[12:23] <masak> eli-se: I'm starting to really like the old names :)

[12:23] *** chenryn_ left
[12:23] <masak> I always took the bags-not-sets thing to be a performance tradeoff.

[12:23] <masak> that is, if you have nice primary keys, they're effectively sets.

[12:24] <eli-se> I find primary keys silly.

[12:24] <dalek> roast: 9699743 | jnthn++ | S04-statements/try.t:

[12:24] <dalek> roast: Add tests for RT #RT #123053; currently skipped.

[12:24] <dalek> roast: review: https://github.com/perl6/roast/commit/9699743de1

[12:24] <eli-se> they're semantically the same as UNIQUE NOT NULL except they have annoying invented edge-cases

[12:25] <masak> such as?

[12:26] *** diana_olhovik_ joined
[12:27] <timotimo> FROGGS: do you know if we have any way to lazily pull in the package database when starting up and there's no "use" statement in a user's code?

[12:28] <dalek> rakudo/nom: de4c3d8 | lizmat++ | src/core/Cool.pm:

[12:28] <dalek> rakudo/nom: An alternate way to do has-substr

[12:28] <dalek> rakudo/nom: 

[12:28] <dalek> rakudo/nom: - starts-with for checking strings at the start of a string

[12:28] <dalek> rakudo/nom: - substr-eq-at for checking strings anywhere in a string

[12:28] <dalek> rakudo/nom: 

[12:28] <dalek> rakudo/nom: Both use nqp::eqat underneath.

[12:28] <dalek> rakudo/nom: 

[12:28] <dalek> rakudo/nom: The Str:D: candidates are about 2x as fast as the Cool:D: candidates.  Since

[12:28] <dalek> rakudo/nom: these methods are really only intended for hot code paths (because the same

[12:28] <dalek> rakudo/nom: functionality can be achieved by just doing .substr eq "foo", but about 4x

[12:28] <dalek> rakudo/nom: times as slow), it seems valid to keep the separate candidates around.

[12:28] <dalek> rakudo/nom: 

[12:28] <dalek> rakudo/nom: This patch does *not* remove the has-substr implementation.  So either can

[12:28] <dalek> rakudo/nom: be reverted without touching anything else.

[12:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de4c3d8b36

[12:30] <dalek> rakudo/nom: a513ca7 | jnthn++ | src/Perl6/Optimizer.nqp:

[12:30] <dalek> rakudo/nom: "use fatal" when constant folding.

[12:30] <dalek> rakudo/nom: 

[12:30] <dalek> rakudo/nom: This prevents us from getting a Failure and constant-folding to that.

[12:30] <dalek> rakudo/nom: Stashing a Failure away is a bad idea since we might be in a "use

[12:30] <dalek> rakudo/nom: fatal" context, and cannot enforce that.

[12:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a513ca73ed

[12:30] <dalek> rakudo/nom: 993c659 | jnthn++ | src/Perl6/Actions.nqp:

[12:30] <dalek> rakudo/nom: Simplify "use fatal" implementation.

[12:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/993c659ce3

[12:31] <dalek> rakudo/try-does-use-fatal: a7b374d | jnthn++ | src/Perl6/Optimizer.nqp:

[12:31] <dalek> rakudo/try-does-use-fatal: "use fatal" when constant folding.

[12:31] <dalek> rakudo/try-does-use-fatal: 

[12:31] <dalek> rakudo/try-does-use-fatal: This prevents us from getting a Failure and constant-folding to that.

[12:31] <dalek> rakudo/try-does-use-fatal: Stashing a Failure away is a bad idea since we might be in a "use

[12:31] <dalek> rakudo/try-does-use-fatal: fatal" context, and cannot enforce that.

[12:31] <dalek> rakudo/try-does-use-fatal: review: https://github.com/rakudo/rakudo/commit/a7b374d795

[12:31] <dalek> rakudo/try-does-use-fatal: 3b45f6a | jnthn++ | src/Perl6/Actions.nqp:

[12:31] <dalek> rakudo/try-does-use-fatal: Simplify "use fatal" implementation.

[12:31] <dalek> rakudo/try-does-use-fatal: review: https://github.com/rakudo/rakudo/commit/3b45f6a6d2

[12:31] <dalek> rakudo/try-does-use-fatal: 722f81a | jnthn++ | src/Perl6/Actions.nqp:

[12:31] <dalek> rakudo/try-does-use-fatal: Make try do "use fatal", as per spec.

[12:31] <dalek> rakudo/try-does-use-fatal: 

[12:31] <dalek> rakudo/try-does-use-fatal: This makes various things fail more violently than they used to, so

[12:31] <dalek> rakudo/try-does-use-fatal: we get a bunch of spectest failures as a result. We use a dynvar for

[12:31] <dalek> rakudo/try-does-use-fatal: conveying if "use fatal" is in effect, which is consistent with S04's

[12:31] <dalek> rakudo/try-does-use-fatal: requirement that "The fail function responds to the caller's use fatal

[12:31] <dalek> rakudo/try-does-use-fatal: state. It either returns an unthrown exception, or throws..." Clearly

[12:31] <dalek> rakudo/try-does-use-fatal: this has to be caller in the transitive to be of any use. Placing this

[12:31] <dalek> rakudo/try-does-use-fatal: in a branch so we don't lose it.

[12:31] <dalek> rakudo/try-does-use-fatal: review: https://github.com/rakudo/rakudo/commit/722f81a108

[12:31] <jnthn> oops

[12:31] <jnthn> No matter...

[12:32] <jnthn> .tell TimToady Making "try" does "use fatal" has...quite some effects; the patch is in try-does-use-fatal if you're curious to look at the kinds of test failures that result.

[12:32] <yoleaux> jnthn: I'll pass your message to TimToady.

[12:34] *** risou is now known as risou_awy

[12:34] *** risou_awy is now known as risou

[12:34] *** virtualsue left
[12:37] *** bjz joined
[12:45] <tadzik> holy crap

[12:45] <tadzik> forestfire is now actually fluent in rakudo-moar

[12:45] <tadzik> when did that happen

[12:47] <dalek> rakudo/uni: 3c96069 | jnthn++ | / (2 files):

[12:47] <dalek> rakudo/uni: Start implementing Uni type and its subclasses.

[12:47] <dalek> rakudo/uni: review: https://github.com/rakudo/rakudo/commit/3c960695f3

[12:47] <brrt> what is the uni type

[12:47] <tadzik> and it's at about 20fps

[12:47] <brrt> unicode

[12:47] <jnthn> Code-point array, basically

[12:48] <jnthn> S15 describes it somewhat, and referenes a discussion about it.

[12:48] <tadzik> 50% of the time is spent in printing the thing, heh

[12:48] <jnthn> I'm working on it 'cus the path to NFG is getting NFC done, which also means getting NFD done...

[12:49] <jnthn> And with Uni and its subtypes I can use the Unicode conformance test suite to make sure I get NFC and NFD right.

[12:49] <timotimo> i published my weekly

[12:49] <flussence> timotimo++

[12:50] <timotimo> tadzik: what.

[12:50] <masak> tadzik: now all we need is someone making a "Forest Fire: the FPS" :)

[12:50] <timotimo> "Forest Fire: The 20 FPSs"

[12:50] <lizmat> timotimo++

[12:50] <tadzik> timotimo++

[12:50] <tadzik> timotimo: srsly!

[12:51] <masak> timotimo++

[12:51] <timotimo> huh?

[12:51] <timotimo> you silly people %)

[12:51] <tadzik> eat your karma

[12:51] <brrt> timotimo++

[12:51] <masak> we karma people, whether they like it or not!

[12:51] <tadzik> weekly has random smiley faces here

[12:51] <FROGGS> timotimo++

[12:51] <FROGGS> :P

[12:51] <tadzik> oh, it's because I had 150% zoom

[12:52] * FROGGS reads it now

[12:52] <tadzik> hey timotimo 

[12:52] <dalek> rakudo-star-daily: a1ed2b2 | coke++ | log/ (2 files):

[12:52] <dalek> rakudo-star-daily: today (automated commit)

[12:52] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/a1ed2b22d6

[12:52] <tadzik> the test file and the corresponding .c file are both the .t file

[12:53] <tadzik> ༼ つ ◕_◕ ༽つ TIMO PLS FIX

[12:53] <timotimo> damn

[12:53] <timotimo> that'? release critical!

[12:53] <tadzik> NOW PANIC

[12:54] <timotimo> done

[12:54] <timotimo> panic is over

[12:54] <tadzik> \o/

[12:54] <timotimo> that was a close one

[12:54] <masak> phew

[12:55] <tadzik> dodged a bullet

[12:55] * masak wipes a drop of sweat off his forehead

[12:55] *** lucasb joined
[12:56] <tadzik> http://i.imgur.com/9s390o4.gif

[12:56] <flussence> yow, that performance hit is real: perl6 -e 1 => 1.88user 0.10system 0:02.03elapsed

[12:56] <masak> :(

[12:56] <timotimo> holy hell

[12:56] *** diana_olhovik_ left
[12:56] <timotimo> that's even worse than here

[12:56] <timotimo> 0.53user 0.01system 0:00.55elapsed 99%CPU (0avgtext+0avgdata 90600maxresident)k

[12:56] <tadzik> perl6 -e1  0,41s user 0,07s system 99% cpu 0,485 total

[12:56] <flussence> that's on my weaksauce netbook though

[12:56] <tadzik> ....how good was it before? /o\

[12:57] <timotimo> it went down to about 0.19 for me

[12:57] <timotimo> elapsed, that is

[12:57] <tadzik> good times, when we have something like that to be sad about

[12:57] <flussence> I can live with it, I still remember what it was like in 2010...

[12:58] <tadzik> module idea: something that eats JSON, emits p6 code that produce the same data structure, so you can precompile the latter

[12:58] <awwaiid> why you slowing me down‽

[12:58] <tadzik> never gonna give you up, never gonna slow you down

[13:03] <lizmat> tadzik: why just JSON ?

[13:04] <tadzik> hmm

[13:04] <tadzik> any data structure, actually :)

[13:04] <masak> because JSON is the thing that is slowing us down.

[13:04] <FROGGS> tadzik: what's the difference between from-json and what you just proposed?

[13:04] <lizmat> yeah...  :-(

[13:04] <masak> and building a bigger solution than that is scope creep.

[13:04] <tadzik> FROGGS: that you only have to from-json once, and then you 'use' and have things fast

[13:05] <FROGGS> we already have a perl data structure that we are spitting down as JSON... we just need to .perl our data and precomp that

[13:05] <lizmat> well, fwiw, for S11 I always envisioned a precomped database, really, with some other data format for making changes, and surviving system updates

[13:05] <tadzik> masak: but still, the difference between 'give it a json string, get a module' and 'give it a data struct, get a module' is almost null

[13:05] <FROGGS> we just need to stop json here

[13:05] <lizmat> but for runtime, it would just load a precomped data structure, like tadzik described

[13:05] <tadzik> doit($json) vs doit(from-json $json)

[13:06] <tadzik> masak: then we can even not emit json at all

[13:06] <FROGGS> lizmat: jnthn proposed that we precomp a hash, and when the precomp file is outdated we fall back to the source of the hash

[13:06] <lizmat> fwiw, I found 6 places in the core that could use starts-with and substr-eq-at

[13:07] <masak> tadzik: yeah, that's a point

[13:07] *** larion left
[13:15] <dalek> doc: 5ad5573 | paultcochrane++ | lib/Type/Cool.pod:

[13:15] <dalek> doc: Correct docs for trim-trailing()

[13:15] <dalek> doc: review: https://github.com/perl6/doc/commit/5ad5573179

[13:15] <dalek> doc: e9d1351 | paultcochrane++ | / (7 files):

[13:15] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[13:15] <dalek> doc: review: https://github.com/perl6/doc/commit/e9d1351cbf

[13:19] <lizmat> FROGGS: have you considered generating EVALlable code and just EVAL slurp settings ?

[13:20] <lizmat> looking back at my initial S11 attempt of over 1 year ago, that was the way I was going then

[13:25] *** muraiki joined
[13:28] *** rmgk_ joined
[13:28] *** rmgk is now known as Guest22110

[13:28] *** Guest22110 left
[13:28] *** rmgk_ is now known as rmgk

[13:32] <dalek> Heuristic branch merge: pushed 17 commits to rakudo/newio by lizmat

[13:34] *** Ven joined
[13:35] <lucasb> Hello. Is starts-with staying? What about ends-with, so I can do $filename.ends-with('.txt')?

[13:35] <lucasb> I sketched a pseudocode for it. Wanna see?

[13:36] <lizmat> ends-with would be nice, I agree

[13:37] <lizmat> I've seen a few places in the core that could use that

[13:37] <masak> agreed.

[13:38] <lucasb> https://gist.github.com/lucasbuchala/979c267fc3ed64f61d1f

[13:39] *** chenryn_ joined
[13:39] <hoelzro> morning #perl6

[13:39] *** chenryn_ left
[13:40] *** chenryn_ joined
[13:41] <tadzik> hey hey hoelzro 

[13:41] <hoelzro> ahoy tadzik!

[13:41] *** Ven left
[13:42] *** larion joined
[13:42] <masak> ahoy hey hoelzro 

[13:42] *** chenryn_ left
[13:43] <hoelzro> hello masak!

[13:45] *** aborazmeh joined
[13:45] *** aborazmeh left
[13:45] *** aborazmeh joined
[13:46] <dalek> perl6-examples: e235774 | paultcochrane++ | README.md:

[13:46] <dalek> perl6-examples: Separate categories directories into own table/section

[13:46] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/e23577438d

[13:46] <dalek> perl6-examples: 1404c25 | paultcochrane++ | README.md:

[13:46] <dalek> perl6-examples: Mention 'make html' in the docs

[13:46] *** dalek left
[13:46] *** dalek joined
[13:46] *** ChanServ sets mode: +v dalek

[13:46] <PerlJam> dalek seems to have a weak constitution

[13:47] <tadzik> dump stat

[13:47] <masak> invested it all in charisma

[13:47] <[ptc]> maybe the limit for "Heuristic branch merge" should be set lower, such that the flood kick doesn't happen

[13:48] <masak> can we also change the message to something that doesn't sound wrong? :)

[13:48] <masak> also, is it actually impossible to find out whether commits were the consequence of a merge in Git?

[13:49] <masak> why is a heuristic needed in the first place?

[13:50] *** skids joined
[13:50] *** raiph joined
[13:51] <brrt> yes

[13:51] <brrt> masak - a merge commit has two parents

[13:51] <brrt> that makes it a... merge :-)

[13:51] <masak> I suspected something like that might be the case :P

[13:52] <brrt> lemmecheck

[13:52] <PerlJam> random question: how useful is dalek's output?

[13:52] <dalek> rakudo/nom: eb05181 | lizmat++ | src/core/Cool.pm:

[13:52] <dalek> rakudo/nom: Implement Cool.ends-with, inspired by lucasb++

[13:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb05181a5c

[13:53] <lizmat> the check for needle longer than string, wasn't needed as nqp::eqat handles that nicely already

[13:53] <masak> PerlJam: I like it. but it could probably get away with being one line per commit.

[13:53] <PerlJam> personally, I could live with just one line like ...  rakudo/nom: lizmat++ | https://github.com/rakudo/rakudo/commit/eb05181a5c

[13:53] <masak> PerlJam: yes, like that.

[13:54] <masak> PerlJam: maybe also the first line of the commit message.

[13:54] <[ptc]> +1 to the first line of the commit message

[13:54] <lizmat> yes, the first line is needed, if for other karma also  :-)

[13:54] <masak> clipped to 50 chars so people learn :P

[13:54] <[ptc]> heh :-)

[13:54] <PerlJam> aye, sounds good

[13:54] <masak> "make it so" :P

[13:54] <tadzik> frankly the "review" can go away :)

[13:54] <PerlJam> that would cut down the flood potential a bit

[13:54] <masak> yeah, I'm not even sure I need the github link.

[13:55] <tadzik> I like to click them

[13:55] <PerlJam> me too

[13:55] <masak> fair enough.

[13:55] <jnthn> The review link is really useful for me.

[13:55] <masak> ok, ok, leave it in :)

[13:55] <jnthn> I don't have a problem with the commit comment either really.

[13:55] <lizmat> fwiw, I would like to see a bot that would turn a commit ID into a github link as well

[13:55] <[ptc]> would there then be a way to bundle (say) 7+ commits into one line from dalek?

[13:56] <masak> lizmat: only if there were *no* false positives.

[13:56] <PerlJam> lizmat: what masak said

[13:56] <[ptc]> with maybe an improved message, for the case that it's not a merge?

[13:56] <lizmat> the bot could check the repo ?

[13:56] <masak> cache SHA-1s, more like.

[13:56] <lizmat> or a number of repo's ?

[13:56] <tadzik> sounds like a job for synopse<TAB><TAB>

[13:57] <masak> *sob*

[13:58] *** gtodd joined
[13:59] <masak> we miss you, synopsebot. get well soon.

[13:59] * brrt thinks we should have p6-bots

[13:59] *** chenryn_ joined
[14:01] <hoelzro> is anyone interested in reviewing my tab completion branch? I brought it up last week, but it seems like everyone was busy with their weekends

[14:03] *** nbdsp joined
[14:04] <brrt> have a link?

[14:04] <brrt> (by the way, i have refound my static-perl6 branch stuck on a netbook)

[14:04] <nwc10> what does your static-perl6 branch do?

[14:05] <PerlJam> hoelzro: what does the tab completion branch do exactly?

[14:05] <tadzik> ffff

[14:05] <tadzik> POE doesn't install for me on p6c

[14:05] <tadzik> I'll just rewrite the thing in Perl 6

[14:06] <PerlJam> tadzik++

[14:06] <nwc10> ﬀﬀ

[14:06] <nbdsp> Greetings, could someone give a direction to the documentation chapter which treates the topic about exceptions?

[14:06] <PerlJam> (though POE not installing is weird)

[14:06] <brrt> it tries to make a statically-linked executable of libmoar combined with the perl6.moarvm-file as a binary

[14:06] <nwc10> (ooh, that doesn't render very nicely for me)

[14:06] <tadzik> PerlJam: maybe I shouldn't have went for 5.20.2

[14:06] <tadzik> today at work I couldn't even install Reply on it

[14:06] <brrt> something like your patches on fakexecutables some time ago

[14:07] <brrt> i'm pretty much stuck at getting all dependencies to work, though

[14:07] <[ptc]> nbdsp: do you mean something like this: http://doc.perl6.org/type/Exception ?

[14:07] <psch> grml

[14:07] <psch> moreinput is hard 

[14:08] <[ptc]> nbdsp: you can get a lot of info if you just type 'X' into the search field on doc.perl6.org

[14:08] <masak> nbdsp: didn't find anything on doc.perl6.org, but here are two advent posts: https://perl6advent.wordpress.com/2011/12/15/day-15-something-exceptional/ https://perl6advent.wordpress.com/2012/12/12/exceptions/

[14:09] <masak> nbdsp: hope that helps. if it doesn't feel enough, please bring up remaining concerns here on #perl6 and we'll find a solution :)

[14:09] <[ptc]> nbdsp: ... or mention the need in an issue here: https://github.com/perl6/doc

[14:09] *** darutoko- joined
[14:10] <hoelzro> PerlJam: it adds tab completion to the rakudo REPL

[14:10] <hoelzro> so you can tab to see what classes/functions are available

[14:10] <masak> there's certainly room for a throwing-and-catching-exceptions tutorial on doc.perl6.org

[14:11] *** darutoko left
[14:11] <PerlJam> hoelzro: for anything?  in the setting?  in user code?

[14:12] <hoelzro> PerlJam: in the setting, or for anything the user loads

[14:12] <hoelzro> so if I 'use Test' from the REPL, it'll offer completions for ok, is, etc

[14:12] <nbdsp> ptc, masak: Thanks for the the links. It seems that general description of exceptions i documentation would be helpful for beginners.

[14:12] <hoelzro> it's still pretty rudimentary, but I feel it's good enough for a merge, and can be improved over time

[14:12] <PerlJam> o<TAB> is the same number of key strokes as "ok"  ;)

[14:12] <masak> m: die "oops" # ad-hoc exception

[14:12] <camelia> rakudo-moar 993c65: OUTPUT«oops␤  in block <unit> at /tmp/0IeSX_XSWO:1␤␤»

[14:13] *** Rounin left
[14:13] <hoelzro> PerlJam: fair point, but you know what I mean =)

[14:13] <masak> m: die X::IO.new(:os-error("Something unspecified went wrong")) # typed exception

[14:13] <camelia> rakudo-moar 993c65: OUTPUT«X::IO<140460797557760>␤  in block <unit> at /tmp/cKoC7QCQsa:1␤␤»

[14:14] <masak> hm.

[14:14] <RabidGravy> I don't suppose any of you is running Linux on a multi-core ARM?

[14:14] <PerlJam> hoelzro: anything special I need to know before I try to build it?

[14:14] <masak> m: die X::IO::DoesNotExist.new(:path("foo/bar"), :trying("zombie copy"))

[14:14] <camelia> rakudo-moar 993c65: OUTPUT«Failed to find 'foo/bar' while trying to do '.zombie copy'␤  in block <unit> at /tmp/BgTfZOotgc:1␤␤»

[14:14] <masak> nbdsp: ^^ that's the crash course :)

[14:15] <nbdsp> masak: thanks!

[14:15] <masak> m: { die X::IO::DoesNotExist.new(:path("foo/bar"), :trying("zombie copy")); CATCH { when X::IO { say "some kind of IO exception was caught!" } }

[14:15] <camelia> rakudo-moar 993c65: OUTPUT«5===SORRY!5=== Error while compiling /tmp/U485eTDrt_␤Missing block␤at /tmp/U485eTDrt_:1␤------> 3me kind of IO exception was caught!" } }7⏏5<EOL>␤»

[14:15] <masak> m: { die X::IO::DoesNotExist.new(:path("foo/bar"), :trying("zombie copy")); CATCH { when X::IO { say "some kind of IO exception was caught!" } } }

[14:15] <camelia> rakudo-moar 993c65: OUTPUT«some kind of IO exception was caught!␤»

[14:15] <masak> ...and that's on the exception-consuming side.

[14:15] <masak> a tutorial would likely be about the details of those evals.

[14:17] <nbdsp> I haven't found in documentation any mention that exceptions in Perl 6 are thrown with 'die' keyword.

[14:17] <masak> huh.

[14:17] <masak> though you can also do $myexception.throw

[14:17] <hoelzro> PerlJam: you need the correct branches of Moar and NQP, but if you do --gen-moar it will pick them up

[14:17] <lizmat> RabidGravy: I think nwc10 might have some pointers

[14:18] <hoelzro> you will also need to install Linenoise.pm from https://gtihub.com/hoelzro/p6-linenoise

[14:18] <hoelzro> in order for tab completion to actually work =)

[14:18] <hoelzro> the branch is probably in need of a substantial refresh, as it's been sitting around for 1-2 weeks

[14:19] <dalek> rakudo/nom: d6b1447 | lizmat++ | src/core/ (4 files):

[14:19] <dalek> rakudo/nom: Use starts|ends-with / substr-eq-at in core

[14:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d6b1447f18

[14:20] <RabidGravy> lizmat, I'm just looking for a /proc/cpuinfo from an ARM device which has more than one cpu core to test a p6 version of Linux::Cpuinfo :)

[14:20] <masak> lizmat++

[14:21] <nwc10> RabidGravy: most likely you want someone with a Raspberry Pi 2

[14:21] <nwc10> (other things exist, but I suspect that the Pi 2 is fairly soon going to be most numerous)

[14:21] <nwc10> I don't have one

[14:21] <nwc10> (this week)

[14:22] <lizmat> afk for a bit&

[14:22] *** chenryn_ left
[14:25] <RabidGravy> nwc10, yeah I don't have one :-\  There appears to be a bug in the single core arm6 kernel on the RPI v1 and some appliances whereby an erroneous newline iis inserted in the /proc/cpuinfo in the middle of the "record"

[14:27] <itz> qemu has ARM doesn't it?

[14:27] <[ptc]> masak: I believe the curlies around the C<die> examples are unnecessary, is that right?

[14:28] <masak> [ptc]: yes -- they were superstitious.

[14:29] <lucasb> m: my $x; my $x; say 'ok'

[14:29] <camelia> rakudo-moar eb0518: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/2xZjEvwO7o:1␤    ------> 3my $x; my $x7⏏5; say 'ok'␤ok␤»

[14:29] <masak> [ptc]: I've experienced trouble historically with CATCH-like constructs on the outermost level, and I didn't want to run into that while demo-ing stuff.

[14:29] <masak> it might well be fix'd already. if so, all the better.

[14:29] <lucasb> ^^ I think I don't like this being *just* potential...

[14:29] <masak> lucasb: you'd like that to be an error?

[14:30] <masak> lucasb: I disagree.

[14:30] <[ptc]> masak: ah, ok.  It sort of looked like a perl5 leftover, like how one catches "die"ing in tests

[14:30] <jnthn> masak: I'm pretty sure I fixed the CATCH at top level bug.

[14:30] <masak> neat.

[14:31] <lucasb> masak: So the code is ok, is this by design? Ok

[14:31] *** aborazmeh left
[14:32] *** raiph left
[14:32] *** brrt left
[14:33] <RabidGravy> itz, good call, let's see

[14:34] *** andreoss joined
[14:41] *** diana_olhovik_ joined
[14:45] <[ptc]> masak: how exactly should C<throw> be used?

[14:45] <[ptc]> I've seen one example in the specs where one can override the default behaviour of C<die>

[14:45] <[ptc]> however, how should one use C<throw> in a more "usual" situation?

[14:46] <[ptc]> possibly when one defines one's own exception functions?  e.g.:  sub barf(Exception $e) {$e.throw}  ?

[14:47] <skids> m: { X::AdHoc.new(:payload<foo>).throw; "OHAI".say; CATCH { when X::AdHoc { $_.resume } } }; "OBAI".say;

[14:47] <camelia> rakudo-moar eb0518: OUTPUT«OHAI␤OBAI␤»

[14:47] <skids> m: { X::AdHoc.new(:payload<foo>).throw; "OHAI".say; CATCH {  } }; "OBAI".say;

[14:47] <camelia> rakudo-moar eb0518: OUTPUT«foo␤  in block <unit> at /tmp/FbtB60dxVO:1␤␤»

[14:47] <skids> m: { X::AdHoc.new(:payload<foo>).throw; "OHAI".say; CATCH { when X::AdHoc { } } }; "OBAI".say;

[14:47] <camelia> rakudo-moar eb0518: OUTPUT«OBAI␤»

[14:48] <masak> lucasb: yes, declaring the same variable multiple times in a scope is a sign of potential difficulties; not a total show-stopper

[14:48] <skids> [ptc]: like that.

[14:50] <[ptc]> skids: thanks :-)  Am trying to understand so that I can re-explain it in the docs

[14:50] <skids> [ptc]: The smart-matching is magic, and important to explain.

[14:50] <skids> Also the results of the above are different for .fail

[14:50] <skids> (Because that's a failure wrapping an exception)

[14:51] <masak> [ptc]: I dunno -- I like `die` and I always use that and not `.throw`

[14:51] *** n0vacane joined
[14:51] <[ptc]> found mention of .fail in the docs, but the docs (and specs) are a bit thin on the subject

[14:51] <psch> die can take an Exception as well.  to me, die and .throw is a case of method form not being the same as sub form

[14:52] <psch> in contrast to fail and .fail, i think?

[14:52] <n0vacane> paging larry wall, paging larry wall

[14:52] *** molaf_ joined
[14:52] <[ptc]> walling larry page, walling larry page  :-P

[14:52] <masak> n0vacane: that's a novel way to enter the channel :)

[14:53] <n0vacane> i wanna talk to someone famous today

[14:53] <[ptc]> ok, I'll write up what I've understood so far, and hopefully someone will correct my mistakes :-)

[14:53] <PerlJam> n0vacane: you're talking to us!

[14:53] <masak> n0vacane: we don't have a Larry Wall in right now. would you be fine with an Elvis impersonator?

[14:54] <masak> we have several on standby

[14:54] <PerlJam> .oO( thank you very much 0

[14:54] *** nbdsp left
[14:55] *** molaf__ left
[14:55] <skids> [ptc]: I'll be publishing this as a mod when I've giot it tested, may help as example code to play with: https://gist.github.com/skids/cf9065039903df5047ac

[14:56] <masak> n0vacane: Abraham Lincoln impersonator? Sean Connery impersonator? Dumbo impersonator?

[14:56] <n0vacane> hmm

[14:56] <n0vacane> aristotle impersonator

[14:57] <masak> we have a pissed-off Plato, if that's OK.

[14:57] <masak> Aristotle++ is not here right now.

[14:57] <n0vacane> how about Caligula?

[14:57] <masak> we stopped taking in those.

[14:58] <n0vacane> Tiberius?

[14:58] *** eli-se left
[14:58] <PerlJam> Augustus

[14:59] <masak> no no, those are #python property. not #perl6

[14:59] <[ptc]> skids: thanks.  I'll have a look at it.  I'm just going to quickly write up something about exceptions for doc.perl6.org and then at least that hole is plugged a bit

[15:02] <andreoss> are keys of Bag returned in determenistic order?

[15:03] <masak> if they are, then that's implementation-dependent and nothing you should rely on

[15:05] *** Perl6_newbee joined
[15:06] <dalek> perl6.org: 2affc65 | (Zoffix Znet)++ | source/documentation/index.html:

[15:06] <dalek> perl6.org: Fixed typo

[15:06] <dalek> perl6.org: 

[15:06] <dalek> perl6.org: Plural form of synopsis works better

[15:06] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/2affc6526f

[15:10] <dalek> doc: 1e6d6f9 | (Zoffix Znet)++ | lib/Type/Mixy.pod:

[15:10] <dalek> doc: Fixed dead link

[15:10] <dalek> doc: 

[15:10] <dalek> doc: Resolves https://github.com/perl6/perl6.org/issues/15

[15:10] <dalek> doc: review: https://github.com/perl6/doc/commit/1e6d6f9cab

[15:12] *** tinyblak left
[15:12] * PerlJam just spent about 30 minutes changing his brain so that he could implement some code following the KISS principle 

[15:12] <PerlJam> It's sad that "simple" takes so long to work out some times

[15:13] *** rarararara joined
[15:13] *** fhelmberger left
[15:13] <masak> PerlJam: "I didn't have time to write a short letter, so I wrote a long one instead."

[15:14] <n0vacane> I said the same thing when I was changing the brakes on my truck a few months ago. Ended up having to replace all of the brake lines too and the front calipers

[15:15] <dalek> roast: 4317b37 | usev6++ | S24-testing/ (15 files):

[15:15] <dalek> roast: Test line numbers for failing tests

[15:15] <dalek> roast: review: https://github.com/perl6/roast/commit/4317b37e35

[15:15] <dalek> roast: e085231 | bartolin++ | S24-testing/ (15 files):

[15:15] <dalek> roast: Merge pull request #56 from usev6/line_numbers

[15:15] <dalek> roast: 

[15:15] <dalek> roast: Test line numbers for failing tests

[15:15] <dalek> roast: review: https://github.com/perl6/roast/commit/e0852317c0

[15:16] <masak> ^^ like there. that's a merge commit. which dalek failed to heuristically detect.

[15:17] <masak> I think what it means by the message is something like "Lots of commits detected. Maybe somebody merged them all in?"

[15:17] *** RabidGravy left
[15:21] <skids> m: sub f ($x) { X::AdHoc.new(:payload<foo>).throw; CATCH { return if $x; "OHAI".say } }; f(1); "HERE".say; f(0); "OBAI".say; # [ptc] correction it is not the smart-match that is magic, it is whether the thrown exception goas past the closing curly on the CATCH block.

[15:21] <camelia> rakudo-moar d6b144: OUTPUT«HERE␤OHAI␤foo␤  in sub f at /tmp/6tIiUt1dRx:1␤  in block <unit> at /tmp/6tIiUt1dRx:1␤␤»

[15:22] <skids> *goes

[15:22] <[ptc]> skids: :-)

[15:23] *** pullphinger joined
[15:23] <masak> it uses the same mechanism as `succeed` and `proceed` keywords in a `given` block.

[15:23] <masak> if you fall all the way through, it's assumed you haven't handled the exception. (and it gets re-thrown)

[15:24] *** andreoss left
[15:25] <hoelzro> are succeed and proceed impl'd yet?

[15:26] <psch> m: given 42 { when Int { proceed }; default { say "dunno?" } }

[15:26] <camelia> rakudo-moar d6b144: OUTPUT«dunno?␤»

[15:26] <masak> oh yes, long ago.

[15:26] <psch> m: given 42 { when Int { succeed }; default { say "dunno?" } }

[15:26] <camelia> rakudo-moar d6b144: ( no output )

[15:27] <[ptc]> m: given 42 { when Int { proceed }; when Str { say "string" }; default { say "default" }}

[15:27] <camelia> rakudo-moar d6b144: OUTPUT«default␤»

[15:28] <[ptc]> ok, I think understand that now; C<proceed> continues to the default, or other matching when clauses?

[15:28] <psch> m: given 42 { when Int { succeed; say "never this!" }; default { say "dunno?" } }

[15:28] <camelia> rakudo-moar d6b144: ( no output )

[15:29] *** RabidGravy joined
[15:31] <skids> m: given 42 { when Int { "Int".say; proceed }; when 42 { 42.say }; when 43 { 43.say }; default { "got change for an existential answer?".say } }

[15:31] <camelia> rakudo-moar d6b144: OUTPUT«Int␤42␤»

[15:34] *** pecastro left
[15:34] *** raiph joined
[15:34] <skids> m: given 42 { when Int { "Int".say; proceed }; when 43 { 43.say }; when 42 { 42.say }; default { "got change for an existential answer?".say } } #clearer

[15:34] <camelia> rakudo-moar d6b144: OUTPUT«Int␤42␤»

[15:36] <masak> I find a well-groomed `given` with `proceed` calls can be a thing of beauty.

[15:36] <[ptc]> should proceed/succeed be documented along with given/when, or is there another, more general, place one could mention them?

[15:36] <masak> I think I've written two of them over the years.

[15:36] <masak> [ptc]: no, that's a good place.

[15:37] <masak> [ptc]: even though the general context is "topicalizing blocks" (of which `for` and routines setting `$_` are also examples)

[15:37] *** lolisa joined
[15:38] <TimToady> jnthn: 'use fatal' should not be using a dynvar, I suspect

[15:38] <jnthn> TimToady: What should it be using?

[15:39] <masak> ah -- here: https://github.com/masak/crypt/blob/7e3b1be1384d5fedafa0f28d79ce1957b9a95718/crypt.pl#L869-L1165

[15:39] <masak> now that's a big `given` statement. but quite readable, IMHO.

[15:39] *** gfldex joined
[15:41] *** pecastro joined
[15:41] <[ptc]> so given/when should be documented under syntax probably, right?

[15:42] <masak> seems reasonable.

[15:42] <[ptc]> there doesn't seem to be a discussion on doc.perl6.org about such things like if, for, while etc...

[15:42] <[ptc]> ... just trying to work out where it makes the most sense to put some of this stuff :-)

[15:42] <TimToady> I suspect the only sane way to implement 'use fatal' is by rewrites on the caller end, not the callee end

[15:44] <TimToady> but dynvars go too deep; 'use fatal' is only supposed to impact calls from the given lexical scope

[15:46] *** larion left
[15:47] *** eli-se joined
[15:48] <jnthn> TimToady: OK, would be good to figure out what that rewrite is.

[15:49] <TimToady> it has to rewrite calls that are not otherwise checked, and add something like 'orelse $!.throw' assuming that orelse actually set $!, which I don't think it does yet

[15:50] <skids> [ptc]: The literals take a lot of space in syntax.pod and more might make it tl;dr.  Having a separate control.pod might make sense, especially since flow control is as much semantic as syntactic.

[15:51] <dalek> rakudo/nom: 730db2e | FROGGS++ | src/core/CompUnitRepo/Local/Installation.pm:

[15:51] <dalek> rakudo/nom: pass on args transparently in runners created by CUR::Installation

[15:51] <dalek> rakudo/nom: 

[15:51] <dalek> rakudo/nom: So a '-h' that we want topass along won't mutate into '--h=True'.

[15:51] <dalek> rakudo/nom: cdc++ for reporting.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/730db2ef81

[15:51] *** FROGGS left
[15:51] <jnthn> TimToady: Where "no otherwise checked" means "not in sink context", iiuc?

[15:51] <jnthn> *not

[15:52] <TimToady> s/sink/bool or is-defined/

[15:53] <TimToady> sink already throws

[15:53] <jnthn> Yes, that was my point: we don't need to do anything different for calls in sink context, and need to transform the rest.

[15:54] <jnthn> But...seems you want fancier pattern matching than that. :/

[15:54] *** FROGGS[mobile] joined
[15:54] <TimToady> if not already in || or // or or or orelse...

[15:54] <jnthn> And only those?

[15:55] <jnthn> Feels like "a list to remember" :)

[15:55] <TimToady> well, things that check bool or defined

[15:55] <TimToady> we don't want to rewrite someone's dothis() or die

[15:56] <jnthn> This is probably sufficient fun we'll need to do it as a separate pass over the constructed AST.

[15:57] <jnthn> At least that isolates the complexity in one place.

[15:57] <TimToady> but only on behalf of the guilty

[15:57] <TimToady> right

[15:57] <dalek> doc: ab324ed | paultcochrane++ | lib/Language/exceptions.pod:

[15:57] <dalek> doc: Add initial documentation of Exceptions

[15:57] <dalek> doc: review: https://github.com/perl6/doc/commit/ab324ed0a4

[15:57] <jnthn> OK, that's probably do-able without horrible amounts of pain.

[15:57] <[ptc]> skids: good point, was wondering that myself.

[15:58] <masak> jnthn: it skirts interestingly close to the kind of walker-macro transformations I was talking about the other day.

[15:59] <jnthn> masak: Challenge: figure out how "use fatal" could be written as a module :P

[16:00] <ugexe> whats a better way to call .dirname on a string and create the directory? i feel im doing something wrong by using .IO twice here: "/home/test".IO.dirname.IO.mkdir.try;

[16:01] * TimToady would like to make the default mode a bit smarter about failure too; currently when you can't bind because something is a failure, it sometimes just say Cannot call foo(1,2,Failure), when it should probably throw the exception like sink does, or at least incorporate it into the new message so they know where the Failure came from

[16:01] *** vendethiel joined
[16:10] <FROGGS[mobile]> ugexe: cant you just mkdir that literal string? 

[16:10] <ugexe> the string is for a file

[16:11] <ugexe> i want to create the files directory. i should have made it more explicit "/home/test.ext".IO.dirname.IO.mkdir

[16:11] <TimToady> jnthn: on the eager blorst, that'll probably fall out of the GLR, if a negotiator notices that the negotiatee isn't negotiating, it can probably assume it's an itemy thing that is implicity eager <waves hands>

[16:12] <ugexe> FROGGS[mobile]: but there is no such method 'mkdir' for invocant type 'Str'

[16:12] <TimToady> hopefully being a negotiation that can happen at compile time mostly

[16:13] *** mollison joined
[16:13] *** cschwenz left
[16:13] *** mollison is now known as Guest24622

[16:13] <TimToady> but even at runtime, probably a simple type check to see if the returned value is a negotiator or a "real" value

[16:15] <TimToady> we might need better words for negotiator/negotiatee

[16:15] <TimToady> too easy to confuse those

[16:15] * vendethiel backlogs on the new-io stuff, and is not sure at all

[16:17] * vendethiel thinks ":fail-silently-if-exists" looks common lispish, for some reason

[16:17] <jnthn> TimToady: OK, sounds at least plausible....

[16:18] <FROGGS[mobile]> ugexe there is a mkdir subroutine

[16:19] *** Guest24622 left
[16:20] <FROGGS[mobile]> vendethiel: that was just for illustration me thinks

[16:21] *** mr-foobar joined
[16:23] <abraxxa> nine: daxim verlangt nach dir

[16:23] * vendethiel 's surprised we didn't have a "starts-with" or "ends-with" yet :o)

[16:24] <vendethiel> I thought I saw it. well, lizmat++ then

[16:31] *** Ven joined
[16:36] *** lichtkind joined
[16:38] *** lolisa left
[16:44] *** diana_olhovik_ left
[16:47] *** noganex_ left
[16:50] *** abraxxa left
[16:53] *** Sqirrel left
[16:54] *** Sqirrel joined
[16:55] *** Perl6_newbee left
[16:58] *** _mg_ joined
[16:58] *** ggoebel joined
[17:00] <lucasb> The behavior of the REPL changed. Before, you could just type an expression and it was printed back to you. Now, you either terminate with semicolon or you fall into the continuation prompt. I don't know how a REPL for a semicolon-language must behave. Sure it must be hard to get things right.

[17:02] *** diana_olhovik_ joined
[17:03] <TimToady> would be nice if the 2nd return erased the * without advancing

[17:03] <psch> lucasb: yes, it is hard to get right.  a single statement will probably always require either a semicolon or two line breaks

[17:03] <psch> TimToady: i like that, i'll put it in my todo

[17:04] <lucasb> I appreciate your work on the REPL, psch++

[17:04] <TimToady> could make the prompt ; even, and then erase that or replace with a 'real' prompt if they type something else

[17:04] <psch> i think my stuckiness with moreinput currently hangs somewhere between EXPR and statement, the former of which is still somewhat scary

[17:05] <TimToady> or make the prompt ;? so they don't think the ; is mandatory at that spot

[17:06] <nine> For me the raison raison d'être for starts-with and ends-with is that it's just so much more readable than substr($subname,0, 6) eq '_block'

[17:06] *** skids left
[17:06] *** raiph left
[17:09] <lucasb> Is it feasible or desired to first try appending a ";" into the line just read, and if it looks like a complete statement, just exec it and print its result, otherwise, enter the continuation prompt?

[17:11] <psch> lucasb: not with one-pass parsing, afaik

[17:12] <lucasb> oh

[17:12] *** FROGGS joined
[17:15] *** raiph joined
[17:15] *** _mg_ left
[17:16] *** sorear left
[17:16] <lucasb> A second issue is this: if perl6 doesn't get a filename in the cmdline, then it automatically enters into REPL mode. But what about feeding a program from stdin? The interpreter could check isatty(STDIN) and if it was not, then read the program from stdin, otherwise, enter the REPL.

[17:16] <lucasb> If you try this: echo -e '1;\n2;\n3' | perl6

[17:17] <TimToady> m: say $*IN ~~ :t

[17:17] <camelia> rakudo-moar 730db2: OUTPUT«Cannot find method 'isatty': no method cache and no .^find_method␤  in method t at src/gen/m-CORE.setting:18039␤  in method ACCEPTS at src/gen/m-CORE.setting:11679␤  in block <unit> at /tmp/lFPfXUReZX:1␤␤»

[17:17] <lucasb> Then the 3 numbers are printed on output, just like cat(1)

[17:17] <TimToady> :t is supposed to know

[17:18] <TimToady> m: say $*IN.t

[17:18] <camelia> rakudo-moar 730db2: OUTPUT«Cannot find method 'isatty': no method cache and no .^find_method␤  in method t at src/gen/m-CORE.setting:18039␤  in block <unit> at /tmp/Stg_nTlQrW:1␤␤»

[17:19] <|Tux|> m: $*OUT.nl = ""

[17:19] <camelia> rakudo-moar 730db2: OUTPUT«Invalid string index: max -1, got 4294967295␤  in block  at src/gen/m-CORE.setting:17755␤  in block <unit> at /tmp/eY8zYjwA73:1␤␤»

[17:19] <|Tux|> wheather that will be supported or not, the error message is suboptimal

[17:19] <|Tux|> RT#123978

[17:19] <psch> lucasb: thanks for that test case, didn't occur to me to try non-outputting valid programs

[17:19] <TimToady> you don't do a REPL unless isatty

[17:21] <psch> TimToady: tests in repl.t are written with echo pipes currenlty

[17:21] <psch> TimToady: does that mean we want a Pty in core instead?

[17:21] <TimToady> you could have a switch to force REPL

[17:22] <psch> oh, okay

[17:23] *** dakkar left
[17:23] <psch> lucasb: explicit STDIN as argument prevents the cat-like behavior, fyi

[17:23] <psch> that is, -

[17:23] *** spider-mario joined
[17:23] <psch> not STDIN :)

[17:23] *** larion joined
[17:24] <lucasb> psch: Oh, you are right. Thanks, psch++

[17:24] *** spider-mario left
[17:28] <awwaiid> https://metacpan.org/pod/Devel::REPL::Plugin::MultiLine::PPI is a convenient way to do it in p5

[17:29] <timotimo> we don't have something very PPI-ish for perl6 yet

[17:30] <awwaiid> oh I thought that was built in somewhere. maybe in-process parsing is tied up with macro todo stuff?

[17:30] <TimToady> that's the new ast stuff that ++masak hasn't come up with yet :)

[17:32] <TimToady> we don't want to make the PPI "mistake" of using a separate compiler; we'd rather teach the actual compiler to take a documentary view when necessary

[17:32] <TimToady> we probably need an option to continue trying to parse after an error for that though

[17:33] <TimToady> probably with an attempt to resync on closing brackets

[17:34] <awwaiid> well the plugin just tries over and over each time someone gives another line

[17:34] <awwaiid> could just shell out to perl6 -c and get a pretty good emulation :)

[17:34] *** ribasushi left
[17:35] *** spider-mario joined
[17:35] <TimToady> interestingly, an incremental compiler that kept track of which areas changed and which didn't could probably do a much better job of error recovery: "I know the next function starts here already"

[17:36] <awwaiid> what do you mean by which areas changed?

[17:37] <TimToady> if you make a change inside one function, you certainly don't have to recompile anything before that function, and you probably don't have to recompile anything after, unless there's a BEGINish dependency

[17:37] <awwaiid> oh you mean like if you are in a workbook style editor with a live interpreter?

[17:38] <TimToady> so you basically compare the chunks of program you had last time with the chunks you have this time, and figure out which parts of the file changed, and which didn't, then just recompile the part that changed

[17:38] <TimToady> it can be done without an IDE too, if you're willing to match chunks of text like the "patch" program does to figure out if anything moved over

[17:39] <TimToady> well, up or down

[17:39] <TimToady> to the first approximation, you just compare chunks from the beginning and end of the file

[17:39] <TimToady> someone should write starts-with and ends-with routines :)

[17:40] <TimToady> to the extent that those pre-existing chunks can be mapped to pre-compiled AST, you don't have to repeat that compiling work

[17:43] <psch> i keep arriving here, via different paths: https://gist.github.com/peschwa/b8c6bd2802ea8ff8f158

[17:43] <psch> :/

[17:44] <psch> debug output suggests that the <statementlist(1)> in blockoid somehow breaks blockoid reaching the }

[17:45] <[Coke]> FROGGS[mobile]: re-opening 115626 - there's no test.

[17:45] * TimToady wonders why it shows the } on the same line

[17:45] <TimToady> in the error message

[17:45] <psch> TimToady: i think readlineintfh strips the \n

[17:46] *** rarararara left
[17:47] * TimToady goes back to blackogging

[17:47] <dalek> rakudo/nom: 8578022 | coke++ | t/spectest.data:

[17:47] <dalek> rakudo/nom: run new (passing) test file

[17:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85780221c2

[17:48] <FROGGS> [Coke]: I should add tests for invalid code?

[17:48] <FROGGS> [Coke]: my first thought was to reject it

[17:50] *** RabidGravy left
[17:51] <tony-o> timotimo: did you ever look at that IO::Socket::INET gist?

[17:52] <timotimo> i looked at it, had some complaints, realized my complaints were my fault because i didn't read closely enough ...

[17:52] <timotimo> it's kinda bad that it doesn't work, that gist ;(

[18:00] *** rurban_ joined
[18:01] <tony-o> so while it's not the cleanest code, it should work that way?

[18:01] <tony-o> i'm not way off base in thinking that, i guess is what i'm asking

[18:02] <timotimo> yeah, a socket should work regardless of what thread it's created in and used in

[18:02] <timotimo> well, IMO

[18:02] *** RabidGravy joined
[18:05] *** nbdsp joined
[18:06] *** kaare_ left
[18:07] *** coffee` left
[18:08] *** coffee` joined
[18:08] <nbdsp> Greetings! Could someone advise please how to correctly handle failures in BUILD submethod? With 'throw'? Or with 'fail'? Somehow else?

[18:08] *** Ven left
[18:09] <timotimo> throw should work best for your use case

[18:09] <TimToady> if you can't correctly build an object, that's pretty fatal

[18:10] *** sirdancealot left
[18:10] <nbdsp> timotimo: thanks!

[18:12] *** beastd joined
[18:13] <[Coke]> Perl 6: Civil War (coming in 2016)

[18:15] <nine> m: my $i = 0; multi sub foo(Int $foo where { say $i++ }) { }; foo(1);

[18:15] <camelia> rakudo-moar 730db2: OUTPUT«0␤1␤»

[18:16] <nine> ^^^ why is the where block executed twice?

[18:16] *** espadrine left
[18:16] <timotimo> don't rely on that, please

[18:17] *** telex left
[18:17] <nine> timotimo: I won't. I'm just wondering. That may be the cause for my nextsame fix not working.

[18:17] <tony-o> [Coke]: is this a game?

[18:18] *** telex joined
[18:19] <timotimo> oh, hum.

[18:19] *** zakharyas left
[18:19] <FROGGS> [Coke]: have you seen my questions?

[18:20] <timotimo> nine: i suggest printing a little backtrace inside the where block

[18:20] <timotimo> that'll give you a hint what calls the where block

[18:22] *** ribasushi joined
[18:23] *** nine left
[18:24] *** nine joined
[18:24] <[Coke]> we could get 1000 more passing tests if we could fudge or fix S26-documentation/block-leading.t S26-documentation/block-trailing.t and S17-procasync/kill.t

[18:25] <FROGGS> [Coke]: can you hear me?

[18:28] *** caymanboy joined
[18:29] <PerlJam> .oO( Hello? Is there anybody in there? Just nod if you can hear me. Is there anyone at home? )

[18:30] <nwc10> m: say "No-one here but us bots"

[18:30] <camelia> rakudo-moar 857802: OUTPUT«No-one here but us bots␤»

[18:30] <nwc10> r: say "No-one here but us bots"

[18:30] <camelia> rakudo-moar 857802: OUTPUT«No-one here but us bots␤»

[18:30] <camelia> ..rakudo-jvm 857802: OUTPUT«cannot connect to eval server: Connection refused␤»

[18:30] <TimToady> if this is a write-only channel, can I say anything I like now?

[18:30] <nwc10> people might believe you

[18:30] <nine> TimToady: yes, nobody will see what you write

[18:32] <TimToady> so if Larry Wall says something here, n0vacane won't see it?

[18:32] *** pullphinger left
[18:33] <eli-se> Larry Wall is a hero!

[18:33] *** pecastro left
[18:33] * PerlJam notes that Comfortably Numb was from an album entitled "The Wall"  ;)

[18:34] <eli-se> but not by Pearl Jam :(

[18:34] <timotimo> a here-o?

[18:35] <tony-o> Welcome to Larry Wall 6, the language of the future

[18:36] <nine> timotimo: https://gist.github.com/niner/1404ab7e119c05c0cbf0 two backtraces of the two calls.

[18:36] <timotimo> that looks like the fast-path binder and the slow-path binder, perhaps?

[18:36] <PerlJam> eli-se: I'm not quite sure how to take your emoticon ... are you sad because you think "The Wall" would have been better done by Pearl Jam?  Or because Pearl Jam should have released an album called "The Wall"?  Or that you really want to hear Comfotably Numb as sung by Pearl Jam?  or something else ? 

[18:37] <PerlJam> :)

[18:37] <eli-se> because your name isn't PerlFloyd

[18:38] <nine> timotimo: I'm a bit out of my depths here...

[18:38] <timotimo> me, too; i haven't touched that code yet

[18:38] *** skids joined
[18:40] *** _mg_ joined
[18:40] *** Ven joined
[18:40] <nbdsp> How to correctly throw exceptions with 'throw'? When I use  Exception.new(message => "Error.").throw; - that doesn't work.

[18:41] <itz> hmm does MoarVM actually build in -m32?

[18:41] <psch> nbdsp: message is a method

[18:42] <nbdsp> oh

[18:42] <psch> nbdsp: you probably want to subclass Exception with a meaningful name

[18:42] <nwc10> itz: I've been able to build MoarVM with -m32 on x86_64 (ie getting an i686 binary) and Power

[18:43] <dalek> rakudo/nom: 3ccf9bc | FROGGS++ | tools/build/Makefile-Moar.in:

[18:43] <dalek> rakudo/nom: correclty create valgrind runner as perl6-valgrind-m

[18:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ccf9bcf06

[18:43] <nbdsp> psch: thanks!

[18:44] <psch> m: class Bork is Exception { method message ($msg = "it") { "$msg happened!" } }; Bork.new.throw # fsvo meaningful

[18:44] <camelia> rakudo-moar 857802: OUTPUT«it happened!␤  in block <unit> at /tmp/NnhXXmEq61:1␤␤»

[18:44] <timotimo> um

[18:44] <timotimo> i'm not sure you'd ever want to give message a parameter?

[18:44] <psch> eh, that parameter to message is probably a bad idea :P

[18:45] <psch> timotimo: right, it occured to me a bit late

[18:45] *** braintwist left
[18:45] <psch> m: class Bork is Exception { has $.msg = "it"; method message () { "$.msg happened!" } }; Bork.new(:msg("something terrible")).throw # better

[18:45] <camelia> rakudo-moar 857802: OUTPUT«something terrible happened!␤  in block <unit> at /tmp/l76p2w9EUu:1␤␤»

[18:45] *** braintwist joined
[18:45] <timotimo> :)

[18:46] *** braintwist left
[18:46] <psch> nbdsp: please don't put a parameter onto message for an Exception subclass :)

[18:46] *** braintwist joined
[18:46] * psch .oO( except if you have a good reason, maybe, but you'll know then i guess? )

[18:46] *** braintwist is now known as kinslayer

[18:47] <nbdsp> psch: thanks for the example.

[18:48] *** raiph left
[18:49] <[Coke]> the test is to make sure it doesn't segfault.

[18:49] *** larion left
[18:49] <[Coke]> FROGGS: no, I just caught up to your question about your questions.

[18:50] <[Coke]> NO, I couldn't hear you. not until now.

[18:50] <FROGGS> okay, so any module name will do, as long as it can't be found

[18:50] <[Coke]> and now I'm caught up to realtime.

[18:50] <FROGGS> :o)

[18:52] *** zakharyas joined
[18:54] <dalek> rakudo/nom: 322d01b | FROGGS++ | src/Perl6/Grammar.nqp:

[18:54] <dalek> rakudo/nom: only care about {YOU_ARE_HERE} in settings, fixes RT #115372

[18:54] <dalek> rakudo/nom: 

[18:54] <dalek> rakudo/nom: In user code it is just a symbol (potentially a sub call) in a closure.

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/322d01b696

[18:54] <tony-o> m: try { CATCH { default { .say; } }; throw 'Sup'; };

[18:54] <camelia> rakudo-moar 857802: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8xOmFWPefA␤Undeclared routine:␤    throw used at line 1␤␤»

[18:54] <dalek> roast: 47b74d0 | FROGGS++ | S04-blocks-and-statements/pointy.t:

[18:54] <dalek> roast: fix and unfudge test for {YOU_ARE_HERE}, RT #115372

[18:54] <dalek> roast: review: https://github.com/perl6/roast/commit/47b74d04ea

[18:54] <tony-o> m: try { CATCH { default { .say; } }; die 'Sup'; };

[18:54] <camelia> rakudo-moar 857802: OUTPUT«Sup␤  in block <unit> at /tmp/H1n8brdayh:1␤␤»

[18:58] <masak> nine: I didn't see anyone answer your question "why is the block executing twice?" -- as far as I understand, first the candidate is *considered* during multi dispatch, and then the signature is actually *bound* as the call goes ahead.

[18:58] <itz> some weird failures with dyncall on OS X gcc 4.9 .. like its confused about arch

[18:59] * jnthn back

[19:02] <nwc10> when did anyone last (sucessfully or otherwise) build NQP on i686?

[19:03] <masak> is i686 just a 64-bit Intel platform? I built nqp on my laptop yesterday, I believe.

[19:03] <nwc10> no, 32 bits

[19:03] <masak> oh

[19:03] <flussence> today

[19:03] *** larion joined
[19:04] <nwc10> I can build just fine with 64 bit

[19:04] <nwc10> flussence: oh, odd. which parrot version?

[19:04] <flussence> oh, none.

[19:04] <masak> Parrot wasn't part of the original question :)

[19:04] <masak> nwc10: don't try to confuse us here! :P

[19:05] <nwc10> oh, bother.

[19:05] <nwc10> I fail

[19:05] <nwc10> maybe I should go to sleep

[19:05] <nwc10> OK, retry

[19:05] <nwc10> I *can* build NQP with parrot 7.2.0 on x86_^4

[19:05] <nwc10> x86_64

[19:06] <nwc10> I get null PMC error in the build on x86

[19:08] <dalek> roast: 21f93eb | FROGGS++ | S11-modules/require.t:

[19:08] <dalek> roast: check that `require "ENOTTHERE"` does not segfault, RT #115626

[19:08] <dalek> roast: review: https://github.com/perl6/roast/commit/21f93ebe3a

[19:08] *** larion left
[19:09] <nwc10>  /home/nick/Sandpit/parrot-g/bin/parrot -L. -X. --library=gen/parrot/stage1 gen/parrot/stage1/nqp.pbc \

[19:09] *** raiph joined
[19:09] <nwc10>             --target=pir --output=gen/parrot/stage2/nqp-mo.pir \            --setting=NULL gen/parrot/stage2/nqpmo.nqp

[19:09] <nwc10> Null PMC access in get_bool()

[19:09] <nwc10> current instr.: '' pc 32003 (gen/parrot/stage1/QRegex.pir:12392) (gen/parrot/stage1/QRegex.nqp:1797)

[19:10] <nwc10> Java-sized backtrace

[19:10] <FROGGS> m: sub YOU_ARE_HERE { say 42 }; my &if = -> {YOU_ARE_HERE}; (if) if if;

[19:10] <camelia> rakudo-moar 857802: OUTPUT«===SORRY!===␤Cannot find method 'push'␤»

[19:11] *** _mg_ left
[19:14] <FROGGS> bartolin: btw, in the gdb backtrace here: https://rt.perl.org/Ticket/Display.html?id=124255

[19:14] <FROGGS> bartolin: you can see that a NULL pointer (the string) is passed: MVM_string_flatten (tc=0x6026c0, s=0x0)

[19:19] <nwc10> odd. With a bit of coaxing I can build i686 on the x86_64 machine

[19:19] <nwc10> and it doesn't fail the build

[19:20] <FROGGS> and only nqp-p fails?

[19:20] <nwc10> I'm not quite sure what your question is

[19:20] <nwc10> I get an nqp-p

[19:20] <nwc10> it runs tests

[19:20] *** kaare_ joined
[19:21] <nwc10> t/nqp/59-nqpop.t ...................... Failed 6/126 subtests 

[19:21] <nwc10> just like an x86_64 nqp-p

[19:21] <FROGGS> but it fails to build stage2, at least that's what your paste shows me

[19:23] <FROGGS> jnthn: flattenropes at nqp/src/vm/moar/QAST/QASTRegexCompilerMAST.nqp:154 passes on a null string to the op which results in RT #124255

[19:24] <nwc10> FROGGS: that was on a genuine x86 machine

[19:24] <dalek> ecosystem: a57e510 | (Jonathan Stowe)++ | META.list:

[19:24] <dalek> ecosystem: add Linux::Cpuinfo to the ecosystem

[19:24] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/a57e51047c

[19:24] <dalek> ecosystem: 777c56b | FROGGS++ | META.list:

[19:24] <dalek> ecosystem: Merge pull request #42 from jonathanstowe/master

[19:24] <dalek> ecosystem: 

[19:24] <dalek> ecosystem: add Linux::Cpuinfo to the ecosystem

[19:24] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/777c56b28a

[19:25] <nwc10> the "it builds" is on an x86_64 machine, building with gcc\ -m32

[19:25] <nwc10> (and some hand holding to fix a couple of problems)

[19:25] *** rindolf left
[19:26] <nwc10> (parrot doesn't assume that anyone would do this and so has some x86_64 assembler enabled)

[19:32] <FROGGS> my 32bit ubuntu still builds stage1 ...

[19:33] <FROGGS> nwc10: I can reproduce it here

[19:33] <bartolin> FROGGS: aha, I see (at least the s=0x0 part).

[19:34] <FROGGS> bartolin: the question is of course why we are passing a null pointer around... but when you spot something like that, you can be almost certain that you collected enough information for a ticket

[19:35] <FROGGS> nwc10: seems like parrot is unhappy with the sawcaps patch

[19:37] <bartolin> FROGGS: btw, thanks for explaining how to provide a gdb backtrace (and providing debugging symbols for moar) the other day. I haven't tried the new perl6-gdb-m yet.

[19:37] <FROGGS> bartolin: you're welcome :o)

[19:44] <FROGGS> m: sub YOU_ARE_HERE { say 42 }; my &if = -> {YOU_ARE_HERE}; (if) if if;

[19:44] <camelia> rakudo-moar 322d01: OUTPUT«42␤42␤»

[19:44] <FROGGS> yay!

[19:45] <bartolin> \o/

[19:45] <psch> FROGGS: what's the difference between <?{ }> and <!!{ }>?

[19:46] <bartolin> it's nice to see a lot of fixed tickets

[19:46] <FROGGS> <!!{ }> is transparent to LTM

[19:47] <psch> oh

[19:47] <Ven> awww, no more free 24/7 heroku tier...

[19:48] <psch> FROGGS++ thanks

[19:55] *** raiph left
[19:56] <RabidGravy> boo! everytime I forget that json doesn't tolerate trailling commas, every single time

[19:57] <FROGGS> RabidGravy: just switch to JSON5 :o)

[19:58] <FROGGS> nwc10: I've got a patch btw

[20:05] *** itz left
[20:05] *** zakharyas1 joined
[20:05] *** itz joined
[20:05] *** zakharyas left
[20:07] <masak> .tell lizmat just did a little bit more reviewing of newio. I do not think .pred and .succ on paths makes much sense.

[20:07] <yoleaux> masak: I'll pass your message to lizmat.

[20:07] *** caymanboy left
[20:07] <masak> they make sense on Date, for example, because Date is an orderable type. paths can be alphabetically ordered, sure, but that ordering is not "inherent" the way it is for Date.

[20:08] <Ven> m: say "foo0.var".succ; # masak : this always made me feel uncomfortable

[20:08] <camelia> rakudo-moar 322d01: OUTPUT«foo1.var␤»

[20:08] <masak> Ven: that's a different thing. that's just Perl being Perl.

[20:08] <Ven> that's perl trying far too hard to guess what I want to do, imho :-)

[20:08] <masak> Ven: there's even a use case for that. something like "image1.jpg", "image2.jpg", etc

[20:09] <Ven> oh, I've read the specs, I know the use case. Still too much magic powder for me to swallow

[20:09] <masak> Ven: I agree it's potentially confusing/trying to do too much, but it's totally not what I was talking about here.

[20:09] <Ven> I just thought about it when you talked about path -- exacty because of the use case :)

[20:09] <masak> here I was talking about having "foo.jpg".IO in a variable $path, and then you do `$path++;` and now "gloop.txt".IO is in $path instead

[20:10] <masak> (because gloop.txt comes after foo.jpg in the alphabetical directory listing)

[20:11] <Ven> yeah, it's confusing the "iterator" part with the actual data from my pov

[20:11] <masak> oh, that too

[20:11] *** nbdsp left
[20:11] <Ven> .oO( it clearly should be =$path )

[20:11] <masak> I now notice from the patch that maybe lizmat did not put pred/succ in originally.

[20:15] <nwc10> FROGGS: sawcaps patch?

[20:15] <dalek> nqp: c6cfed4 | FROGGS++ | src/QRegex/Cursor.nqp:

[20:15] <dalek> nqp: unbreak build on Parrot with a 32bit OS, nwc10++

[20:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c6cfed41ea

[20:15] *** darutoko- left
[20:16] *** Foxcool left
[20:16] <FROGGS> nwc10: https://github.com/perl6/nqp/commit/a997d3d06b0a3c7bc19a9f58ddd3a6613c9d3159

[20:16] <FROGGS> TimToady: I hope that does not pessimize your optimization: https://github.com/perl6/nqp/commit/c6cfed41ea

[20:17] <nwc10> oh, from that TimToady dude? He's just trouble, he is.

[20:17] <FROGGS> no, he's just nuts :P

[20:17] *** colomon left
[20:21] * masak .oO( Wall nuts )

[20:21] <FROGGS> hehe

[20:24] *** sirdancealot joined
[20:24] *** Foxcool joined
[20:26] *** Rounin joined
[20:27] <nwc10> FROGGS: yes, now works on "my" machine

[20:27] *** espadrine joined
[20:30] *** Ven left
[20:30] *** ribasushi left
[20:33] *** Ven joined
[20:35] *** colomon joined
[20:37] *** zakharyas1 left
[20:37] <FROGGS> m: my num32 $s = 1e0; say $s # I wonder what is going on here

[20:37] <camelia> rakudo-moar 322d01: OUTPUT«0␤»

[20:37] <masak> reported?

[20:37] <nwc10> j: my num32 $s = 1e0; say $s

[20:37] <camelia> rakudo-jvm 322d01: OUTPUT«cannot connect to eval server: Connection refused␤»

[20:38] <nwc10> oh, pants

[20:38] <FROGGS> masak: not in that short form, but similar: https://rt.perl.org/Ticket/Display.html?id=124083

[20:38] <masak> ok

[20:40] *** mohij joined
[20:41] *** ribasushi joined
[20:44] <jnthn> Yes, the num32 stuff is in RT. Two tickets worth, even. 

[20:44] <FROGGS> ahh, it is the same as `my uint8 $a = 200`... the lexicals just do not know of the numsize/intsize

[20:53] <FROGGS> letting MVM_nativeref_{read,write}_reg_or_lex_n not care about num32 "fixes" it

[20:54] <dalek> roast: c41a4e4 | jnthn++ | S15-normalization/nfd- (10 files):

[20:54] <dalek> roast: Add Unicode NFD conformance tests.

[20:54] <dalek> roast: 

[20:54] <dalek> roast: Generated from NormalizationTests.txt in the Unicode database.

[20:54] <dalek> roast: review: https://github.com/perl6/roast/commit/c41a4e4189

[20:55] <FROGGS> what I said about numsize/insize is partial rubbish... what I remembered was signedness

[20:57] <ugexe> FROGGS: do you happen to know off hand how panda builds a module without including any version of the module currently installed? i understand it uses withp6lib/PERL6LIB, but how does it get the externel dependencies in there if its not using @*INC? 

[20:58] <[Coke]> it installs them first?

[20:58] <FROGGS> ugexe: it just puts the current working directory into @*INC[0]

[20:58] <ugexe> but its using a clean PERL6LIB

[20:58] <ugexe> ah

[20:59] *** diana_olhovik_ left
[21:01] <ugexe> i have compunit.precomp( :INC ) building properly except for external depends. im trying to avoid just tagging @*INC at the end of what im passing in

[21:02] <[Coke]> m: BEGIN {my $p = 'D:\m\p6\guiultimate\lib\\GUI\Upp.pm6'; say $p.subst(/(.+)\\.+$/,{$0});}

[21:02] <camelia> rakudo-moar 322d01: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KWskTFHocI␤An exception occurred while evaluating a BEGIN␤at /tmp/KWskTFHocI:1␤Exception details:␤  Type check failed in binding cds; expected 'Any' but got 'Mu'␤    in method APPLY-MATCHES at src/gen…»

[21:02] <[Coke]> m: {my $p = 'D:\m\p6\guiultimate\lib\\GUI\Upp.pm6'; say $p.subst(/(.+)\\.+$/,{$0});}

[21:02] <camelia> rakudo-moar 322d01: OUTPUT«D:\m\p6\guiultimate\lib\GUI␤»

[21:02] <[Coke]> ^^ RT #122789

[21:05] <[Coke]> m: my @a; BEGIN { @a = 1; }; say @a;

[21:05] <camelia> rakudo-moar 322d01: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/m-CORE.setting:10470␤  in method REIFY at src/gen/m-CORE.setting:10978␤  in method reify at src/gen/m-CORE.setting:9517␤  in block  at src/gen/m-CORE.setting:9542␤  in method reify at …»

[21:07] <[Coke]> pmichaud: do you have a list of RTs that will be impacted by the GLR? I'd like to get all those added to the release tracker ticket.

[21:08] <[Coke]> (or to a separate GLR tracker ticket)

[21:08] <dalek> roast: e6dc890 | jnthn++ | S15-normalization/test-gen.p6:

[21:08] <dalek> roast: Turn on generation of NFKD tests.

[21:08] <dalek> roast: review: https://github.com/perl6/roast/commit/e6dc8907f8

[21:08] <dalek> roast: 9216543 | jnthn++ | S15-normalization/nfkd- (10 files):

[21:08] <dalek> roast: Add Unicode NFKD conformance tests.

[21:08] <dalek> roast: 

[21:08] <dalek> roast: Generated from NormalizationTests.txt in the Unicode database.

[21:08] <dalek> roast: review: https://github.com/perl6/roast/commit/9216543a14

[21:09] *** skids left
[21:10] *** rurban_ left
[21:10] *** noganex joined
[21:11] *** raiph joined
[21:11] <FROGGS> [Coke]: look at https://github.com/perl6/specs/issues/70

[21:14] *** colomon left
[21:17] <[Coke]> thanks.

[21:18] *** eli-se left
[21:20] *** Ven left
[21:25] *** sirdancealot left
[21:28] <dalek> doc: fa50342 | paultcochrane++ | lib/Language/control.pod:

[21:28] <dalek> doc: Start documenting control flow statements

[21:28] <dalek> doc: review: https://github.com/perl6/doc/commit/fa50342f7d

[21:28] *** kaare_ left
[21:28] *** sirdancealot joined
[21:33] <lizmat> .botsnack

[21:33] <yoleaux> 20:07Z <masak> lizmat: just did a little bit more reviewing of newio. I do not think .pred and .succ on paths makes much sense.

[21:33] <yoleaux> :D

[21:34] <masak> it later turned out that .pred and .succ might be older than the newio branch.

[21:34] <masak> (but they're still a bad idea, IMO)

[21:34] <lizmat> well, .pred doesn't make much sense to me either, but .succ does, actually

[21:34] <masak> I don't think we should impose an ordering on paths.

[21:35] <jnthn> 'night, #perl6

[21:35] <masak> they don't have a natural ordering.

[21:35] *** colomon joined
[21:35] <lizmat> gnight jnthn 

[21:35] <masak> 'night, jnthn 

[21:35] <FROGGS> gnight jnthn 

[21:36] <lizmat> well, if we don't do .succ on IO, then people will get the basename, strip off the extension, do a .succ on it, then add the extension again

[21:37] <masak> m: say "image313.jpg".succ

[21:37] <camelia> rakudo-moar 322d01: OUTPUT«image314.jpg␤»

[21:37] <masak> you mean like that?

[21:39] <masak> I agree that $path.basename.succ.IO is longer than $path.succ, but I'd also argue that it's clearer.

[21:39] *** estrabd left
[21:39] <masak> and that the extra clarity here is beneficial, because paths do not have a natural ordering.

[21:39] *** lizmat_ joined
[21:39] <masak> anyway, that was the point I wanted to make. now I'm just repeating myself :)

[21:40] <lizmat_> (wifi hickup)

[21:40] *** lizmat left
[21:40] <FROGGS> so is .succ about getting to the next existing file or about "incrementing" the filename string-wise?

[21:41] <masak> I thought it was the former. lizmat made me see that it's maybe the latter.

[21:41] <lizmat_> it's intended to be the latter

[21:42] *** lizmat_ is now known as lizmat

[21:42] <masak> I don't think either semantics is beneficial, and the fact that it's not clear which one it is counts to me as another strike against .pred/.succ

[21:43] <lizmat> I agree on .pred, but see a use for .succ

[21:43] <masak> I think providing only .succ and not .pred is unheard of :)

[21:43] <masak> which in itself is not an error, of course, but it is... a design smell, perhaps.

[21:44] <masak> "you can increment, but you cannot decrement... for some reason"

[21:45] <RabidGravy> why does Str.succ know about the suffix at all?  surely that is going to surprise someone if the just have an arbitrary string which just appens to have a '.' in it

[21:46] *** raiph left
[21:46] <FROGGS> .tell jnthn why dont we use assign_X at all? this makes RT124083 pass and I wonder why we just do not use assign_X... https://gist.github.com/FROGGS/c98f455874e50d39ff75

[21:46] <yoleaux> FROGGS: I'll pass your message to jnthn.

[21:46] *** raiph joined
[21:47] *** lucasb left
[21:48] <FROGGS> m: say "You've.got.a.point.there.".succ

[21:48] <camelia> rakudo-moar 322d01: OUTPUT«You'vf.got.a.point.there.␤»

[21:48] <FROGGS> that's like increasing the major part of a Version literal...

[21:48] <labster> masak: IO::Path::More provides .next and .previous that actually look through the directories, but the original idea was that Cool.succ handled it correctly otherwise.

[21:48] <FROGGS> m: say v1.0.0.succ

[21:48] <camelia> rakudo-moar 322d01: OUTPUT«No such method 'succ' for invocant of type 'Version'␤  in block <unit> at /tmp/FNMbg3aK_V:1␤␤»

[21:48] <FROGGS> :o(

[21:48] *** muraiki left
[21:48] <masak> m: say (2/5).succ

[21:48] <camelia> rakudo-moar 322d01: OUTPUT«1.4␤»

[21:48] <masak> o.O

[21:49] <FROGGS> haha

[21:49] <masak> oh, + 1

[21:49] <labster> 2/5 + 1

[21:49] <FROGGS> ahh, of course

[21:49] <masak> m: (-Inf).succ

[21:49] <camelia> rakudo-moar 322d01: ( no output )

[21:49] <masak> m: say (-Inf).succ

[21:49] <camelia> rakudo-moar 322d01: OUTPUT«-Inf␤»

[21:49] *** sirdancealot left
[21:50] <FROGGS> well, you need a way to infiniloop, don't ya

[21:50] <lizmat> m: say Int.Range[10000]

[21:50] <camelia> rakudo-moar 322d01: OUTPUT«-Inf␤»

[21:50] <lizmat> m: say Int.Range[1000000]

[21:50] <camelia> rakudo-moar 322d01: OUTPUT«-Inf␤»

[21:50] *** koo5 joined
[21:50] <lizmat> :-)

[21:51] <labster> http://design.perl6.org/S03.html#Autoincrement_precedence  The first example is about how it works for file names.

[21:53] <masak> Perl 6 And The Compulsion To Add That Special Case Just In Case Someone Needs It

[21:54] <flussence> "I think providing only .succ and not .pred is unheard of" - wouldn't that be a forward-only iterator (where .succ is commonly spelled "->next")?

[21:54] <masak> flussence: sure, it'd *work*.

[21:54] <FROGGS> gnight mates

[21:54] *** FROGGS left
[21:54] <masak> but it'd be asymmetric and weird.

[21:55] <lizmat> .oO( a symmetric face would be weird )

[21:55] <labster> Indiana Jones and the Quest to Find the One Artifact Some Grad Student Maybe Needs for a Thesis

[21:55] * lizmat also goes to bed

[21:55] <masak> 'night

[21:55] <labster> good night

[21:55] <labster> Maybe I'll read through newio

[21:56] <flussence> weird, yes, also useful to allow though

[22:05] *** lichtkind left
[22:06] *** mohij left
[22:14] *** beastd left
[22:14] *** SevenWolf joined
[22:14] <masak> I think having a feature with questionable, debatable and poorly motivated semantics is not preferable to not having it.

[22:15] <masak> that's a terrible way of saying that. :)

[22:15] <masak> "...is worse than not having the feature."

[22:16] *** pdcawley left
[22:17] <masak> 'night, #perl6

[22:17] *** bjz left
[22:22] *** egrep left
[22:22] *** retupmoca left
[22:23] <dalek> tablets: 3d0c287 | (Zakariyya Mughal)++ | docs/tablet-4-operators.txt:

[22:23] <dalek> tablets: minor grammar fix

[22:23] <dalek> tablets: review: https://github.com/perl6/tablets/commit/3d0c287ff5

[22:23] <dalek> tablets: 4fb99d5 | (Jonathan Stowe)++ | docs/tablet-4-operators.txt:

[22:23] <dalek> tablets: Merge pull request #11 from zmughal/master

[22:23] <dalek> tablets: 

[22:23] <dalek> tablets: minor grammar fix

[22:23] <dalek> tablets: review: https://github.com/perl6/tablets/commit/4fb99d511f

[22:24] *** retupmoca joined
[22:26] *** SevenWolf left
[22:29] *** RabidGravy left
[22:33] *** Rounin left
[22:33] <flussence> theoretical purity is nice, but I also think asking someone who wants to write «$crypted-passwd = ($self-hashable .. *)[$work-factor]» to implement .pred is a little unfair :)

[22:34] <flussence> s/'..'/.../

[22:38] *** vendethiel left
[22:42] <TimToady> $start, &trapdoor-function ... *

[22:44] <tony-o> do websites really not allow passwords longer than 16 chars these days

[22:50] <flussence> m: my class H { has $.y = 5; method succ { H.new(y => $.y + 1) }; method pred { H.new(y => $.y - 1) }; method gist { $.y } }; say H.new ... *.y > 10; # Shouldn't this be increasing?

[22:50] <camelia> rakudo-moar 322d01: OUTPUT«Code object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/EzAWTu7XrF:1␤␤5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 -21 -22 -23 -24 -25 -26 -27 -28 -29 -30 -31 -32 -33 -34 -35 -…»

[22:51] <tony-o> m: say 1 ... 5;

[22:51] <camelia> rakudo-moar 322d01: OUTPUT«1 2 3 4 5␤»

[22:51] <tony-o> m: say 1 .. 5;

[22:51] <camelia> rakudo-moar 322d01: OUTPUT«1..5␤»

[22:56] <TimToady> looks like a bug to me; it's trying to determine the value of *.y > 10 and getting something that makes it decide to use .pred instead of .succ

[22:56] <tony-o> m: say  1 ... 5 > 3;

[22:56] <camelia> rakudo-moar 322d01: OUTPUT«1␤»

[22:57] <tony-o> m: say  (1 ... 5) > 3;

[22:57] <camelia> rakudo-moar 322d01: OUTPUT«True␤»

[22:57] <tony-o> weird

[22:58] <TimToady> m: my class H { has $.y = 5; method succ { H.new(y => $.y + 1) }; method pred { H.new(y => $.y - 1) }; method gist { " $.y " } }; .say for say H.new ... *.y > 10;

[22:58] <camelia> rakudo-moar 322d01: OUTPUT«Code object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/863RxqDXJP:1␤␤ 5   4   3   2   1   0   -1   -2   -3   -4   -5   -6   -7   -8   -9   -10   -11   -12   -13   -14   -15   -16   -17   -18   -19   -20   -21   -2…»

[22:58] <TimToady> m: my class H { has $.y = 5; method succ { H.new(y => $.y + 1) }; method pred { H.new(y => $.y - 1) }; method gist { " $.y " } }; say (*.y > 10).WHAT

[22:58] <camelia> rakudo-moar 322d01: OUTPUT«(WhateverCode)␤»

[22:59] <tony-o> lol

[22:59] <TimToady> m: my class H { has $.y = 5; method succ { H.new(y => $.y + 1) }; method pred { H.new(y => $.y - 1) }; method gist { " $.y " } }; say (*.y > 10) ~~ Callable

[22:59] <camelia> rakudo-moar 322d01: OUTPUT«True␤»

[22:59] *** eli-se joined
[22:59] <flussence> argh, I thought something looked odd - my terminal's not showing the unicode \n glyph today

[22:59] <TimToady> it shouldn't be trying to stringify *.y > 10

[22:59] <TimToady> m: my class H { has $.y = 5; method succ { H.new(y => $.y + 1) }; method pred { H.new(y => $.y - 1) }; method gist { " $.y " } }; .say for H.new ... *.y > 10;

[23:00] <camelia> rakudo-moar 322d01: OUTPUT«(timeout) 5 ␤Code object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/RjuY7VYG5O:1␤␤ 4 ␤ 3 ␤ 2 ␤ 1 ␤ 0 ␤ -1 ␤ -2 ␤ -3 ␤ -4 ␤ -5 ␤ -6 ␤ -7 ␤ -8 ␤ -9 ␤ -10 ␤ -11 ␤ -12 ␤ -13 ␤ -14…»

[23:02] <TimToady> m: my class H { has $.y = 5; method succ { say "SUCC"; H.new(y => $.y + 1) }; method pred { say "PRED"; H.new(y => $.y - 1) }; method gist { " $.y " } }; .say for H.new ... *.y > 10;

[23:02] <camelia> rakudo-moar 322d01: OUTPUT«(timeout) 5 ␤Code object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/mcJfnbMKfp:1␤␤PRED␤ 4 ␤PRED␤ 3 ␤PRED␤ 2 ␤PRED␤ 1 ␤PRED␤ 0 ␤PRED␤ -1 ␤PRED␤ -2 ␤PRED␤ -3 ␤PRED␤ -4 ␤PRED␤ …»

[23:05] *** Zoffix left
[23:06] *** gfldex left
[23:08] *** Sqirrel left
[23:09] *** Sqirrel joined
[23:09] *** skids joined
[23:10] <tony-o> what is * in that case ^

[23:11] *** adu joined
[23:15] *** atta left
[23:23] <tony-o> timotimo: should i open an RT (or whatever, and how do i do that?) for the IO::Socket::INET problem?

[23:27] <TimToady> it's just a Whatever turning into a WhateverCode

[23:29] *** atta joined
[23:29] *** grondilu left
[23:51] <TimToady> testing a fix for sequence bug of flussence++

[23:53] *** tinyblak joined
[23:56] <flussence> .oO( I came here to bikeshed, not to accomplish something! )

[23:56] <dalek> rakudo/nom: e81f470 | TimToady++ | src/core/operators.pm:

[23:56] <dalek> rakudo/nom: don't intuit seq succ/pred when endpoint is Code

[23:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e81f470eb7

[23:57] <dalek> roast: 0bc0df8 | TimToady++ | S03-sequence/nonnumeric.t:

[23:57] <dalek> roast: don't intuit seq succ/pred when endpoint is Code

[23:57] <dalek> roast: review: https://github.com/perl6/roast/commit/0bc0df8c1f

[23:58] *** camelia left
[23:59] *** camelia joined
