[00:04] *** n0tjack left
[00:09] *** n0tjack joined
[00:14] *** n0tjack left
[00:16] *** aborazmeh joined
[00:16] *** aborazmeh left
[00:16] *** aborazmeh joined
[00:34] *** BenGoldberg joined
[00:38] *** lichtkind left
[00:41] *** n0tjack joined
[00:46] *** n0tjack left
[01:06] *** kjs__ joined
[01:09] *** Peter_R left
[01:14] <dalek> roast: 69f3088 | TimToady++ | S04-declarations/constant.t:

[01:14] <dalek> roast: constant @x should cache and be Positional

[01:14] <dalek> roast: review: https://github.com/perl6/roast/commit/69f30882c0

[01:14] *** n0tjack joined
[01:14] <dalek> rakudo/nom: 296824d | TimToady++ | src/Perl6/Actions.nqp:

[01:14] <dalek> rakudo/nom: constant @ should cache Seq and be Positional

[01:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/296824d18f

[01:18] *** n0tjack left
[01:47] *** n0tjack joined
[01:51] *** n0tjack left
[02:02] *** kjs__ left
[02:10] *** TEttinger left
[02:20] *** n0tjack joined
[02:25] *** n0tjack left
[02:48] *** vendethiel joined
[02:52] *** n0tjack joined
[02:55] *** BenGoldberg left
[02:56] *** noganex_ joined
[02:57] *** n0tjack left
[02:59] *** noganex left
[03:12] <thou> m: sub x(:$foo) { note $foo.perl, ' is: ', @$foo ?? 1 !! 0 }; x();

[03:12] <camelia> rakudo-moar 296824: OUTPUT«Any is: 1␤»

[03:12] <thou> Is that intentional? It changed w/ glr merge, it appears.

[03:12] *** vendethiel left
[03:12] <thou> I.e., @$foo where $foo is Any used to be false.

[03:17] *** aborazmeh left
[03:17] <TimToady> Any should not be disappearing in list context, so I'd say the new behavior is correcter

[03:17] <TimToady> m: say so Any.list

[03:17] <camelia> rakudo-moar 296824: OUTPUT«True␤»

[03:18] <TimToady> m^Hstar: say so Any.list

[03:18] <TimToady> ^Hstar: say so Any.list

[03:19] <TimToady> er...

[03:21] <ShimmerFairy> There's a U+007F in front of your "star:"

[03:22] <TimToady> bizarre

[03:22] <TimToady> star: say so Any.List

[03:22] <camelia> star-m 2015.03: OUTPUT«False␤»

[03:22] <TimToady> star: say so Any.list

[03:22] <camelia> star-m 2015.03: OUTPUT«False␤»

[03:23] <TimToady> star: say so list Any

[03:23] <camelia> star-m 2015.03: OUTPUT«True␤»

[03:23] <TimToady> looks like star is inconsisten there

[03:25] *** n0tjack joined
[03:26] *** stimpi joined
[03:29] *** n0tjack left
[03:31] *** stimpi left
[03:37] *** aborazmeh joined
[03:37] *** aborazmeh left
[03:37] *** aborazmeh joined
[03:41] *** n0tjack joined
[03:46] *** n0tjack left
[03:50] <zostay> m: my @foo = 1,2,3; for @foo { .say; @foo.splice(0, 1) }

[03:50] <camelia> rakudo-moar 296824: OUTPUT«1␤3␤»

[03:51] <zostay> m: my @foo = 1,2,3; for @=@foo { .say; @foo.splice(0, 1) }

[03:51] <camelia> rakudo-moar 296824: OUTPUT«1␤2␤3␤»

[03:52] <thou> m: my $h = [$[$(%{:a<1>, :b<2>})]]; dd $h;  # How do I get [[{a=>1,b=>2}]] (Array of Array of Hash w/ 2 elems)?

[03:52] <camelia> rakudo-moar 296824: OUTPUT«Array $h = [[{:a(<1>), :b(<2>)},],]␤»

[03:53] <thou> huh, it worked!

[03:53] <thou> not on my perl6 cli

[03:55] <thou> nevermind, I'm confused, it's working right

[03:58] *** n0tjack joined
[04:02] *** n0tjack left
[04:08] <zostay> m: my %x = a => 1; my %y = b => 2; my %z = %x, %y; %z.perl.say;

[04:08] <camelia> rakudo-moar 296824: OUTPUT«{:a(1), :b(2)}␤»

[04:09] <zostay> m: my %x = a => 1; my %y = b => 2; my %z = flat %x, %y; %z.perl.say;

[04:09] <camelia> rakudo-moar 296824: OUTPUT«{:a(1), :b(2)}␤»

[04:11] <thou> If someone could help me with this little flattening problem, I would very much appreciate it:  https://pastee.org/snnjx

[04:11] <thou> I'm obviously confused about how lists work now.

[04:14] <zostay> you're not alone, thou, i don't quite get it either yet

[04:17] <thou> (This is a simplification of what's wrong with https://github.com/softmoth/p6-Template-Mustache/blob/master/lib/Template/Mustache.pm#L50

[04:18] <thou> I can't make hunk() { make @x.list }, because then it dies with This Seq has already been iterated, and its values consumed

[04:20] <ugexe> make @x.map(*.made)?

[04:23] <thou> I realize I pasted an unclear example, this is more obvious: https://pastee.org/f6eqh

[04:23] <thou> I'll try making inside hunk()

[04:24] <thou> Oh, right, that won't work, they're not match objs.  Method 'made' not found for invocant of class 'Str'

[04:25] *** rmgk_ joined
[04:25] *** rmgk left
[04:25] *** rmgk_ is now known as rmgk

[04:25] <TimToady> use .cache, not .list

[04:26] <thou> ok

[04:26] *** khw left
[04:30] <ugexe> my $hunks = ( ["  ", {:type("var"), :val("string")}, ], );

[04:30] *** n0tjack joined
[04:30] <ugexe> otherwise iterate over the list yourself

[04:34] <thou> It didn't make any difference. https://pastee.org/ch5e8

[04:34] <thou> ugexe: how do I iterate over the list?

[04:34] *** n0tjack left
[04:34] <ShimmerFairy> thou: if you don't need that extra comma after the inner list, don't put it there :)

[04:34] <thou> I can't make hunks () instead of [], can I?

[04:35] <thou> I can't do that

[04:35] <ShimmerFairy> why not?

[04:35] <thou> inside the grammar, passing up values via make

[04:35] <thou> See that most recent paste, maybe it'll be clear what I'm struggling with

[04:38] <thou> I tweaked hunk() to do "make @x.cache" instead of "make @x", but it still is giving me @mades = [["  ", {:type("var"), :val("string")}],]

[04:38] <thou> So that's the structure I have to work with, as far as I can see.

[04:39] <ShimmerFairy> Referring to the most recent paste, you'll either have to treat @mades like a list of list of hunks (assuming the innermost pieces are supposed to be individual $hunk things), or figure out how to not make @mades a list of list of hunks :)

[04:39] <thou> obviously in a more complicated document that top-level list could have more than one element, too

[04:39] <thou> so ... nested for loops is the only solution?

[04:39] <ShimmerFairy> thou: oh! try  make @x.Slip  instead of .cache

[04:40] <thou> ok

[04:40] <ShimmerFairy> m: say [1, [2, 3], 4]; say [1, [2, 3].Slip, 4];

[04:40] <camelia> rakudo-moar 296824: OUTPUT«[1 [2 3] 4]␤[1 2 3 4]␤»

[04:41] <zostay> what determines whether a given %hash object will flatten or not?

[04:41] <thou> Hey, .Slip seems to have worked!

[04:43] <ShimmerFairy> thou: .Slip is meant to let you "slip" lists into other lists, so whenever you want to do something like that, think of .Slip :)   Note that |[2, 3] is the same as Slip, I just wasn't sure if it would interfere with arg flattening with that 'make'

[04:43] <ShimmerFairy> m: say [1, [2, 3], 4]; say [1, |[2, 3], 4];

[04:43] <camelia> rakudo-moar 296824: OUTPUT«[1 [2 3] 4]␤[1 2 3 4]␤»

[04:43] <thou> I find Slip mentioned on index http://design.perl6.org/index_C.html but not on the resulting S07 page

[04:43] <thou> ok

[04:44] <ShimmerFairy> thou: @mades is supposed to be a totally-flat list of hunks, right? If not, then the .Slip solution will probably fail when you do want that [[],[]] structure

[04:45] <thou> yes, totally flat is good

[04:46] <thou> Are there docs anywhere?

[04:46] <thou> I saw an old glr doc from pmichaud from APW

[04:46] <ShimmerFairy> lemme see, I know S07 hasn't been changed yet, so that C Index is weird (possibly referring to the old 'draft' S07 instead?)

[04:47] <skids> There's S07-glr-draft.pod but that has not been updated to post-GLR either.

[04:48] <ShimmerFairy> thou: there's this starting gist, but there needs to be more docs on the subject: https://gist.github.com/niner/d5f825c07ce1f7a6f7bb

[04:48] <ShimmerFairy> If I knew more about GLR I would certainly do my best to add to docs.perl6.org and such. Perhaps I should start fiddling with GLR and becoming familiar with it then :P .

[04:48] <skids> I might be able to put some time in on docs on Sunday.

[04:49] <zostay> m: my %x = a => 1; my %y = b => 2; %x = %x, %y; dd %x;

[04:49] <camelia> rakudo-moar 296824: OUTPUT«Hash %x = {:b(2)}␤»

[04:49] <zostay> m: my %x = a => 1; my %y = b => 2; %x = flat %x, %y; dd %x;

[04:49] <camelia> rakudo-moar 296824: OUTPUT«Hash %x = {:a(1), :b(2)}␤»

[04:49] <zostay> what is going on there?

[04:50] <ShimmerFairy> Another way to think of the Slip type is that it says "this sequence of values isn't supposed to be a 'real' list, so as soon as it's in one just inline this sequence", perhaps

[04:50] <ShimmerFairy> m: my %x = a => 1; %x = %x; say %x.perl

[04:50] <camelia> rakudo-moar 296824: OUTPUT«{:a(1)}␤»

[04:51] <ShimmerFairy> m: my %x = a => 1; my %y = b => 2; %x = %x; say %x.perl

[04:51] <camelia> rakudo-moar 296824: OUTPUT«{:a(1)}␤»

[04:51] <ShimmerFairy> m: my %x = a => 1; my %y = b => 2; %x = %x, %y; say %x.perl

[04:51] <camelia> rakudo-moar 296824: OUTPUT«{:b(2)}␤»

[04:51] <ShimmerFairy> m: my %x = a => 1; my %y = b => 2; %x = (%x, %y); say %x.perl

[04:51] <camelia> rakudo-moar 296824: OUTPUT«{:b(2)}␤»

[04:51] <ShimmerFairy> huh. zostay: I'm not well-versed enough in GLR to say for sure, but that feels vaguely bug-ish to me.

[04:53] <zostay> that's a different problem than the one i'm trying to reproduce

[04:54] <zostay> actually, maybe it's not different... 

[04:54] <zostay> m: my %x = a => 1; my %y = b => 2; (%x, %y).perl

[04:54] <camelia> rakudo-moar 296824: ( no output )

[04:54] <zostay> m: my %x = a => 1; my %y = b => 2; (%x, %y).perl.say

[04:54] <camelia> rakudo-moar 296824: OUTPUT«({:a(1)}, {:b(2)})␤»

[04:55] <zostay> m: my %x = a => 1; my %y = b => 2; (flat %x, %y).perl.say

[04:55] <camelia> rakudo-moar 296824: OUTPUT«(:a(1), :b(2))␤»

[04:55] <zostay> plain %x, %y used to work pre-glr

[04:56] <zostay> so i guess hashes don't turn into lists anymore?

[05:00] <ShimmerFairy> Doesn't look like it.

[05:01] <ShimmerFairy> m: my @a = 1,2,3; my @b = 4,5,6; say (@a,@b).perl  # lists do this too, fwiw

[05:01] <camelia> rakudo-moar 296824: OUTPUT«([1, 2, 3], [4, 5, 6])␤»

[05:03] *** n0tjack joined
[05:04] <skids> m: my %x = a => 1; my %y = b => 2; [ %x ].perl.say; [ %x, %y ].perl.say; # Same rules.  Single arguments should flatten unless in a Scalar.

[05:04] <camelia> rakudo-moar 296824: OUTPUT«[:a(1)]␤[{:a(1)}, {:b(2)}]␤»

[05:08] *** n0tjack left
[05:08] <zostay> alright, 3 modules adjusted to GLR, 5 to go... but sleep comes first, g'night

[05:11] *** aborazmeh left
[05:11] *** AlexDaniel left
[05:16] <thou> m: my $h = {:hello<there>}; dd $h; $h = [ $h ]; dd $h;  # I guess this is correct?  (Have to use $h = [ $h, ] to get what I want)

[05:16] <camelia> rakudo-moar 296824: OUTPUT«Hash $h = {:hello("there")}␤Array $h = (my \Array_140423781368840 = [Array_140423781368840,])␤»

[05:16] <thou> Seems pretty odd to me

[05:24] <skids> thou: If there is no comma you have a single argument.  If a single argument is Iterable it gets flattened, but a Scalar containing an Iterable is not considered Iterable for this purpose.

[05:25] <skids> Assignment puts a Scalar inbetween the variable and the value assigned to it.

[05:25] <skids> Binding does not.

[05:25] <skids> so:

[05:25] <skids> my $h := {:hello<there>}; dd $h; $h = [ $h ]; dd $h;

[05:25] <skids> m: my $h := {:hello<there>}; dd $h; $h = [ $h ]; dd $h;

[05:25] <camelia> rakudo-moar 296824: OUTPUT«Hash % = {:hello("there")}␤Cannot assign to an immutable value␤  in block <unit> at /tmp/cBa9RucPj0:1␤␤»

[05:27] <skids> Erm, well, that does not work too well for self-reference but..

[05:27] <skids> m: my $h = {a=>1}; [ $h ].perl.say

[05:27] <camelia> rakudo-moar 296824: OUTPUT«[{:a(1)},]␤»

[05:27] <skids> m: my $h := {a=>1}; [ $h ].perl.say

[05:27] <camelia> rakudo-moar 296824: OUTPUT«[:a(1)]␤»

[05:28] <thou> ok

[05:30] <skids> m: my $h := {:hello<there>}; dd $h; $h = [ $h[] ]; dd $h;

[05:30] <camelia> rakudo-moar 296824: OUTPUT«Hash % = {:hello("there")}␤Cannot assign to an immutable value␤  in block <unit> at /tmp/Pwk5cKBf_z:1␤␤»

[05:30] <skids> m: my $h = {:hello<there>}; dd $h; $h = [ $h[] ]; dd $h;

[05:30] <camelia> rakudo-moar 296824: OUTPUT«Hash $h = {:hello("there")}␤Array $h = [:hello("there")]␤»

[05:31] *** vendethiel joined
[05:34] *** tokuhiro_ joined
[05:35] *** n0tjack joined
[05:37] <skids> thou: The way to think about it that makes sense is to look at it as if you only ever pass one argument -- if you say @a.push([1,2]) the one argument is [1,2].  If you use a comma at the top level and say @a.push(1,2) you are passing the one list (1,2).

[05:37] <thou> Tests pass with: https://github.com/softmoth/p6-Template-Mustache/commit/6dd93c2ee128c95623744595bf86a3de8354a08a

[05:38] *** TEttinger joined
[05:38] <skids> That one argument is always exploded into multiple arguments, unless it is protected by a Scalar.

[05:39] *** tokuhiro_ left
[05:40] *** n0tjack left
[05:56] *** vendethiel left
[06:05] <thou> m: my @a; my $f = 1; my $g = [2,3]; @a.push: |$f; dd @a; @a.push: |$g; dd @a;

[06:05] <camelia> rakudo-moar 296824: OUTPUT«Array @a = [1]␤Array @a = [1, 2, 3]␤»

[06:05] <thou> m: my @a; my $f = 1; my $g = [2,3]; @a.push: $f; dd @a; @a.push: $g; dd @a;

[06:05] <camelia> rakudo-moar 296824: OUTPUT«Array @a = [1]␤Array @a = [1, [2, 3]]␤»

[06:06] <thou> So, using | works to un-protect the argument, whether the scalar contains an array or not

[06:07] <thou> And .Slip kind of works like that when returning an array from a routine that I want to be exploded into the surrounding list

[06:08] *** n0tjack joined
[06:12] *** n0tjack left
[06:14] *** Ven joined
[06:22] *** bjz joined
[06:24] <skids> thou: yes.  Slip can also be used on the input side, but | is nicer a lot of the time.

[06:25] <skids> m: my @a = 1,2,3,4; @a[0,(1,2),3].perl.say; # when did that start happening?

[06:25] <camelia> rakudo-moar 296824: OUTPUT«(1, (2, 3), 4)␤»

[06:27] <skids> Its...kindof a nice alternative to flatenning there, I guess.  I'll have to sleep on it.

[06:33] <moritz> skids: GLRish

[06:34] *** xinming_ joined
[06:35] <ShimmerFairy> ooh, I didn't know slicing would mirror the structure of the slice in the output like that. Seems like a Cool Thing™ to me :)

[06:37] *** xinming left
[06:38] <skids> I'm optimistic it will turn out useful.

[06:39] <skids> m: my @a = 1,2,3,4; @a[0, (1,2) ,3] = "a" .. "d"; @a.perl.say;

[06:39] <camelia> rakudo-moar 296824: OUTPUT«["a", "b", Any, "c"]␤»

[06:40] <skids> m: my @a = 1,2,3,4; @a[0, (1,2) ,3] = "a",("b","c"),"d"; @a.perl.say;

[06:40] <timotimo> m: my Cool $foo = 10; say ddt $foo;

[06:40] <camelia> rakudo-moar 296824: OUTPUT«["a", "b", "c", "d"]␤»

[06:40] <camelia> rakudo-moar 296824: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Dq0iPG6cy_␤Undeclared routine:␤    ddt used at line 1. Did you mean 'dd'?␤␤»

[06:41] <timotimo> camelia isn't rebuilding again?

[06:41] *** Ven left
[06:41] *** n0tjack joined
[06:41] <skids> Unless that somehow magically falls out I'll have to see about making Seq's slice assign do that.

[06:45] *** n0tjack left
[06:54] *** xinming_ left
[06:54] *** xinming joined
[06:55] *** rurban joined
[07:00] *** lizmat left
[07:03] *** skids left
[07:13] *** n0tjack joined
[07:17] *** cognominal joined
[07:18] *** n0tjack left
[07:29] *** rindolf joined
[07:34] *** cschwenz joined
[07:34] *** domidumont joined
[07:35] <timotimo> m: my Cool $foo = 10; say dd $foo;

[07:35] <camelia> rakudo-moar 296824: OUTPUT«Int $foo = 10␤Nil␤»

[07:35] <timotimo> ^- i wonder if this will confuse people

[07:35] *** tokuhiro_ joined
[07:38] *** darutoko joined
[07:39] *** domidumont left
[07:39] *** domidumont joined
[07:39] *** rindolf left
[07:40] *** tokuhiro_ left
[07:42] <moritz> what about   $foo = #`(Int) 10  ?

[07:44] <Woodi> hi #perl6 :)

[07:44] <Woodi> I found this on HN:  https://matloff.wordpress.com/2014/05/21/r-beats-python-r-beats-julia-anyone-else-wanna-challenge-r/

[07:46] *** n0tjack joined
[07:48] <Woodi> some notes: speed in language matters and at the end you will descend to C anyway ;)  becouse PMC-like things and VMs are both superb and terrible. and you can't be faster then C and asm (and CPU), you can only not slow things too much :)

[07:49] <Woodi> domain knowledge matters; R is written by statisticians, for statisticians.

[07:49] <Woodi> It matters.</cite>

[07:49] <Woodi> but when all knowledge is used then you need ppls from other domains :)

[07:50] *** n0tjack left
[07:53] <Woodi> "clean and elegant" is mantra from Dijkstra probably, it is here for some decades... maybe we can improve it, eg. naive attempt: by adding cases-differentiation, eg. domain-notation is very usefull and not so clean for "outsiders". eg. rx'es are good !

[07:53] *** lizmat joined
[07:54] <lizmat> good *, #perl6, from the patch -p3 hackathon in Lyon, France

[07:54] <Woodi> hi lizmat-traveler :)

[07:54] <lizmat> Woodi o/

[07:56] <Woodi> multiprocessing matters; but it is more then just calculating, eg. planning work and preparing data in best shape is important

[07:57] *** xfix joined
[07:57] *** xfix left
[07:57] *** xfix joined
[07:57] <Woodi> and to me Perl looks like very good prototyping language, tool to work on borders of knowledge or behind :)

[08:04] *** pierrot left
[08:05] <Woodi> to be more/bit on #dev topic:  I just can't use grammars until I go full "tokens"... rules are totally messy for me. of course I just don't know how to use them and it's my fault but I think it falls into "LTA new user experience"

[08:05] *** Alina-malina joined
[08:07] *** thou left
[08:10] *** pierrot joined
[08:11] *** brrt joined
[08:14] <moritz> Woodi: I find grammars in general a rather advanced topic, which takes quite some time getting used to

[08:16] <moritz> and fwiw the trouble with rules is typically mixing explicit and implicit whitespace matching, and/or having <.ws> match significant whitespace

[08:19] *** n0tjack joined
[08:23] *** n0tjack left
[08:27] *** lizmat left
[08:27] *** lizmat_ joined
[08:27] *** pierrot left
[08:28] *** lizmat_ is now known as lizmat

[08:28] *** Averna joined
[08:31] <Woodi> moritz: my initial impression was "use rules and it will auto-magically resolve white spaces everywhere" and I realy would like to have thing like that :)

[08:32] *** domidumont left
[08:33] <moritz> Woodi: I can't speak for everybody, but at least I never marked it that way

[08:33] <Woodi> and if grammars are advertised as better rx'es then new users will came and immediatly want grammars...

[08:34] <Woodi> maybe grammars are somehow tied to computer language constructing process and I want something general...

[08:34] <ShimmerFairy> I've almost never used rules (only in limited cases, and even then I can't recall not going back to token and preferring to explicitly state all my <.ws>es). Being able to space out your regexes is too useful! :P

[08:36] <ShimmerFairy> And fwiw I still find it very unfortunate that 'rule' in P6 means both a generic "grammar-specific methods" and "one of three types of grammar-specific methods, along with 'regex' and 'token'". I haven't been able to come up with a good alternative for either definition though :/

[08:38] <Woodi> also I noticed currently "backtracing" concept is something like hammer falling on user... in v5 it just works...

[08:39] <moritz> Woodi: backtracking or back(stack) traces?

[08:40] <Woodi> I mean like in rx'es it looks things then backs and tries something other...

[08:40] <moritz> well, backtracking works the same in p5 and p6

[08:40] <moritz> except that p6 makes it far easier to switch it off

[08:40] *** xinming_ joined
[08:40] <eiro> hello everyone 

[08:41] <Woodi> I notices few times it wasn't so easy for users

[08:42] <moritz> \o eiro

[08:43] *** xinming left
[08:45] <ShimmerFairy> The only place I've noticed backtracking happening where I didn't want it (since I always use 'token's and generally don't make use of backtracking) is with multi token switching over to other multis when something fails. What I really want there is :: , but it's NYI :<

[08:45] <Woodi> also: what would be best way to add UDP to perl6 ?

[08:46] <moritz> Woodi: from the bottom up

[08:46] <Woodi> some Berkeley::Socket module ?

[08:47] <moritz> Woodi: take a look how libuv handles UDP, expose it to MoarVM, expose it to NQP, write a Perl 6 API for it

[08:48] *** cdc joined
[08:48] <moritz> for sending UDP packages, a simple function might be the best Perl 6 API

[08:48] <moritz> for receiving, maybe a Supply

[08:49] <Woodi> moritz: what about NativeCalls for unix syscalls ?

[08:49] <moritz> Woodi: that might work; but you asked for the best way :-)

[08:50] <Woodi> yes, some nice API would be best. but things like this susally ends in wanting some native api...

[08:51] <Woodi> but will check libuv...

[08:51] *** n0tjack joined
[08:52] <lizmat> https://gist.github.com/lizmat/bb02b2ca33be658a77d1   # kernel

[08:54] <masak> good antenoon, #perl6

[08:56] *** n0tjack left
[08:58] *** bbkr_ joined
[08:58] *** bbkr left
[08:59] *** Ven joined
[09:00] <Woodi> hallo masak 

[09:00] <Woodi> lizmat: you build some ORM ? :)

[09:01] *** FROGGS left
[09:02] <lizmat> no, it was in response to a question I got here at the patch -p3

[09:02] <lizmat> kernel just isn't online (yet)  but it was he who asked the question

[09:02] <lizmat> making an "is tracked" Attribute trait turned out to be more complicated than I hoped it would be

[09:02] <lizmat> :-(

[09:03] *** Guest1897 is now known as kernel

[09:03] <lizmat> kernel o/

[09:03] <kernel> lizmat: thank you :)

[09:03] *** kernel is now known as Guest30914

[09:05] <jdv79> lizmat: how hard?

[09:05] <jdv79> just curious

[09:05] <lizmat> we basically need the COMPOSE phaser to work

[09:06] <nine> .tell think of Seq as an iterator. You can iterate it and when it's empty, it's empty. There's no magic saving of the values for repeated access. That's the whole point because saving the iterated list in a for foo() { } was quite costly. Now if foo() returns a Seq, we waste neither time nor memory storing values that you will never access anymore. Simplest and recommended way to store them is by assigning to an array. Another way is to ask the Seq to create a cac

[09:06] <yoleaux> nine: I'll pass your message to think.

[09:07] <cdc> :)

[09:10] *** Woodi left
[09:13] <masak> lizmat: oh, how's patch -p3 ?

[09:18] <nine> .tell psch think of Seq as an iterator. You can iterate it and when it's empty, it's empty. There's no magic saving of the values for repeated access. That's the whole point because saving the iterated list in a for foo() { } was quite costly. Now if foo() returns a Seq, we waste neither time nor memory storing values that you will never access anymore. Simplest and recommended way to store them is by assigning to an array. Another way is to ask the Seq to create 

[09:18] <yoleaux> nine: I'll pass your message to psch.

[09:18] <lizmat> masak: about 12 people hacking away at p5 and p6 stuff

[09:18] <lizmat> some people interested in starting to write P6 (or already started, such as kernel )

[09:19] <dalek> roast: 56abe83 | usev6++ | S05-grammar/example.t:

[09:19] <dalek> roast: Fix syntax for fudging, introduced with 9c405159835

[09:19] <dalek> roast: 

[09:19] <dalek> roast: also skip tests which die currently.

[09:19] <dalek> roast: (Note: This test file is not in t/spectest.data.)

[09:19] <dalek> roast: review: https://github.com/perl6/roast/commit/56abe839bb

[09:21] *** mprelude joined
[09:24] *** n0tjack joined
[09:26] <moritz> nine: truncated after "ask the Seq to create"

[09:26] <moritz> I guess .cached is what you or psch are after

[09:27] <lizmat> .oO( not sure whether .cached is the right name for the method, wouldn't .reified be better ? )

[09:28] <moritz> lizmat: but it doesn't reify

[09:28] <lizmat> it doesn't ?

[09:28] <moritz> it caches a reference to a lazy List, which can later reify

[09:29] <moritz> so that you can ask the same Seq for a cached List several times

[09:29] *** thou joined
[09:29] *** n0tjack left
[09:30] <moritz> m: my $a := gather { for ^3 { take $_; .say } }; my $l1 = $a.cached; my $l2 = $a.cached; say 'reifying now...';  say $l2[1]

[09:30] <camelia> rakudo-moar 296824: OUTPUT«Method 'cached' not found for invocant of class 'Seq'␤  in block <unit> at /tmp/yueHat73Ft:1␤␤»

[09:31] <nine> .tell psch Another way is to ask the Seq to create a cache for you that you can repeatedly access.

[09:31] <yoleaux> nine: I'll pass your message to psch.

[09:32] <nine> FWIW I still think .list has been perfectly fine and we'd just had to remove .List.

[09:32] <moritz> huh, the .cached branch hasn't been merged yet?

[09:33] *** thou left
[09:33] <moritz> nine: or rename to list-uncached or so

[09:36] <ShimmerFairy> it's .cache, not .cached, IIRC

[09:37] *** tokuhiro_ joined
[09:37] <moritz> m: my $a := gather { for ^3 { take $_; .say } }; my $l1 = $a.cache; my $l2 = $a.cache; say 'reifying now...';  say $l2[1]

[09:37] <camelia> rakudo-moar 296824: OUTPUT«reifying now...␤0␤1␤»

[09:42] *** tokuhiro_ left
[09:43] *** bjz left
[09:43] <cdc> brrt++ # blog post

[09:44] <moritz> ShimmerFairy: thanks

[09:44] <ShimmerFairy> np :)

[09:45] <Ven> cdc: seems I missed it in the backlog?

[09:47] <cdc> Ven: http://brrt-to-the-future.blogspot.fr/2015/09/wrapping-up.html

[09:47] <Ven> cdc: ty :)

[09:48] <masak> speaking of backtracking, I'd like to see someone (maybe me) do an exploration of what's left to make the original ambition/dream of `temp` and `let` come true.

[09:49] *** ribasushi left
[09:49] *** Ven left
[09:49] <masak> notably, in things like recursive algorithms with backtracking and in grammars.

[09:49] *** bjz joined
[09:49] <masak> I feel there is untapped potential there where in the fullness of time we'd be able to write *very* nice code that integrated well with backtracking.

[09:50] *** ribasushi joined
[09:50] <cdc> masak: what is this "original ambition"?  Could you point me to an RFC/Syn/post/*?

[09:51] <psch> hi #perl6 o/

[09:51] <yoleaux> 09:18Z <nine> psch: think of Seq as an iterator. You can iterate it and when it's empty, it's empty. There's no magic saving of the values for repeated access. That's the whole point because saving the iterated list in a for foo() { } was quite costly. Now if foo() returns a Seq, we waste neither time nor memory storing values that you will never access anymore. Simplest and recommended way to store them is by assigning to an array. Another way

[09:51] <yoleaux>  is to ask the Seq to create

[09:51] <yoleaux> 09:31Z <nine> psch: Another way is to ask the Seq to create a cache for you that you can repeatedly access.

[09:52] <brrt> cdc thanks :-)

[09:53] * brrt lunch &

[09:53] <psch> nine: thanks for the explanation.  coupled with moritz' "reifying now" example above that removes this uneasy feeling of "something feels un-understood here..."

[09:54] <psch> .cache return where the Seq will store it's results unless it's already been iterated, because then it's too late anyway

[09:54] <[Tux]> ===(   14319;50  11812/?  27/?  0/? )===================================*** Error in `/pro/3gl/CPAN/rakudobrew/moa===(   14319;50  11812/?  27/?  0/? )===================================*** Error in `/pro/3gl/CPAN/rakudobrew/moa===(   14319;50  11812/?  27/?  0/? )===================================*** Error in `/pro/3gl/CPAN/rakudobrew/moar-nom/install/bin/moar': double free or corruption (out): 0x00007f642010f860 ***

[09:54] <[Tux]> t/90_csv.t ........ All 27 subtests passedr-nom/install/bin/moar': double free or corruption (out): 0x00007f642010f860 ***

[09:54] <[Tux]> t/90_csv.t ........ All 27 subtests passed

[09:54] <psch> (unless that's still slightly wrong, but it doesn't feel obviously wrong anymore... :) )

[09:54] *** brrt left
[09:55] *** kjs__ joined
[09:57] *** n0tjack joined
[09:58] *** bjz left
[10:01] *** brrt joined
[10:01] *** n0tjack left
[10:02] <nine> psch: if there's still any uncertainty at all, this should clear it up: has $!list; method cache() { $!list.DEFINITE ?? $!list !! ($!list := List.from-iterator(self.iterator)) }

[10:03] * BooK is writing his first Perl 6 module!

[10:03] <BooK> liz++ # nice to drink from a fountain of knowledge

[10:04] * lizmat does not feel milked at all  ;-)

[10:04] * BooK cops out # it can only get worse from here

[10:04] <nine> lizmat: you're clearly infinite ;)

[10:04] * jnthn notices he should probably get a move on with the S07 rewrite so there's an authoritative doc on how the list model now works :)

[10:04] <lizmat> jnthn++

[10:04] <jnthn> So folks can stop having a bad time with Seqs... :P

[10:05] *** bjz joined
[10:06] <jnthn> Of course, there's also that nasty data race we've uncovered in Moar to work on...

[10:06] <moritz> m: my @a = '', Any.new, ''; given @a { when :('', Any $x, '') { say $x.perl } }

[10:06] <camelia> rakudo-moar 296824: OUTPUT«5===SORRY!5=== Error while compiling /tmp/dd1aiJMxXA␤Variable '$x' is not declared␤at /tmp/dd1aiJMxXA:1␤------> 3given @a { when :('', Any $x, '') { say 7⏏5$x.perl } }␤»

[10:06] *** leont joined
[10:06] <moritz> I don't understand this error at all

[10:07] *** brrt left
[10:07] <moritz> doesn't the signature declare the variable $x?

[10:09] <cdc> m: my @a = '', Any.new, ''; given @a { when :('', Any $x, '') { say $_.[1].perl } }

[10:09] <camelia> rakudo-moar 296824: OUTPUT«Any.new␤»

[10:09] <moritz> cdc: I'm aware of the workaround

[10:10] <moritz> and if the signature doesn't declare the variable, shouldn't the mention in the signature already cause an error?

[10:11] <jnthn> moritz: Signatures only cause declarations in certain contexts

[10:11] <cdc> m: given :($x) { say .WHAT }

[10:11] <camelia> rakudo-moar 296824: OUTPUT«(Signature)␤»

[10:11] <jnthn> moritz: Signature literals is not one of them.

[10:11] <jnthn> I *think* S04 does specify a syntax for what you're trying to do

[10:12] <moritz> jnthn: but then shouldn't the mention of $x inside the signature already cause a parse error?

[10:13] <moritz> m: my @a = '', Any.new, ''; given @a { when :('', my $x, '') { say $x.perl } }

[10:13] <camelia> rakudo-moar 296824: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1E8SvZdo66␤Invalid typename 'my' in parameter declaration.␤at /tmp/1E8SvZdo66:1␤------> 3', Any.new, ''; given @a { when :('', my7⏏5 $x, '') { say $x.perl } }␤»

[10:13] <jnthn> moritz: No; a signature literal can be imagined as carving out its own little "scope"

[10:13] <moritz> jnthn: ok

[10:13] <jnthn> moritz: Because they lack one to do their declarations in

[10:13] *** rindolf joined
[10:14] <jnthn> Otherwise you couldn't write things like foo ~~ :($x, $y where $x > $y) as a signature literal

[10:14] <masak> jnthn: and so these nested things don't survive into, say, a `when` block?

[10:15] <masak> right, as shows above, duh.

[10:15] <masak> sometimes I feel that's a pity. :)

[10:15] <masak> shown*

[10:16] <jnthn> masak: I think it's right, especially when I'm pretty sure there is a way (that I forget what is) in S04 to do it

[10:16] <ShimmerFairy> IIUC, the signature matcher for when and the block have adjacent but unconnected scopes, so one isn't inside the other.

[10:17] <jnthn> Of course, now I look I can't find it

[10:18] <jnthn> bbiab

[10:22] <BooK> what's the Perl6 equivalent of File::Temp tempdir ?

[10:23] <tadzik> BooK: https://github.com/perlpilot/p6-File-Temp/blob/master/lib/File/Temp.pm#L37

[10:24] <psch> $ ./perl6 -e'say < 5 >.WHAT'

[10:24] <psch> (Str)

[10:24] <psch> m: say < 5 >.WHAT

[10:24] <camelia> rakudo-moar 296824: OUTPUT«(IntStr)␤»

[10:24] <psch> well, it's more approachable than whatever is up with cu_load :s

[10:26] *** bjz left
[10:28] *** bjz joined
[10:29] *** n0tjack joined
[10:31] *** domidumont joined
[10:31] <BooK> tadzik: thanks

[10:31] *** Adrian joined
[10:31] *** Adrian is now known as Guest25419

[10:32] *** TEttinger left
[10:32] <Guest25419> ?

[10:32] <tadzik> it's like Adrian is already taken :)

[10:32] <tadzik> Welcome

[10:32] <Guest25419> Hello.

[10:34] *** n0tjack left
[10:36] <ShimmerFairy> psch: < 5 >.WHAT works for me (latest nqp and rakudo)

[10:37] *** Averna left
[10:39] *** Averna joined
[10:40] <psch> ShimmerFairy: on jvm?

[10:40] <ShimmerFairy> oh, not jvm

[10:40] <psch> sorry, wasn't clear in my paste :)

[10:40] <psch> ShimmerFairy: fyi, it's erroring out via badNative, so something in P6Opaque can't copy with &val

[10:41] <psch> ShimmerFairy: i'm hoping that the underlying problem is something that cleans up a lot more, 'cause the spectest looks pretty bad

[10:41] <psch> s/copy/cope/

[10:47] *** Averna left
[10:48] *** vendethiel joined
[10:49] *** Guest25419 left
[10:54] <BooK> so, how do I spawn a process that spits huge output, and I want to read from it line by line, and possibly through out whatever's left

[10:54] <BooK> and not have to wait until it's completely done

[10:55] <lizmat> https://www.youtube.com/watch?v=RvCkvXvqi3U    # TimToady's talk on YAPC::EU

[10:56] <lizmat> use Proc::Async  :-)

[10:56] <moritz> or simply Proc

[10:56] <moritz> with run($command, :out)

[10:57] <moritz> http://doc.perl6.org/type/Proc

[10:57] <lizmat> would that make .out.lines lazy ?

[10:57] <leont> Proc::Async supplies tend to be buggy (though I haven't recompiled in a while, may be better now)

[10:57] <BooK> and that won't wait until the whole command has run?

[10:57] <moritz> leont: yes

[10:57] <moritz> erm, sorry

[10:57] <moritz> lizmat: yes, .out.lines is lazy

[10:57] <cognominal> lizmat++ # for the link

[10:57] <moritz> BooK: it doesn't wait; it just opens a process with a pipe

[10:57] <lizmat> cognominal: it was actually itz++ who posted it on London.pm

[10:57] <BooK> exactly what I want :-)

[10:58] <moritz> if it doesn't work out after, Proc::Async will help (though it's API is a bit more complicated)

[10:58] <lizmat> moritz: so why do we have Proc::Async then ??

[10:58] <lizmat> to have an interface with Promises and Supplies ?

[10:59] <lizmat> couldn't we fit that on to run() ?

[11:00] <lizmat> lunch&

[11:00] <leont> You need it to read from multiple streams at the same time, basically

[11:00] <leont> Proc.out is still synchronous

[11:02] *** n0tjack joined
[11:05] *** kjs__ left
[11:06] *** FROGGS joined
[11:06] *** telex left
[11:06] *** n0tjack left
[11:07] *** kjs__ joined
[11:08] *** telex joined
[11:11] *** kjs__ left
[11:12] *** vendethiel left
[11:14] <psch> hah

[11:14] <psch> 5,945            /* What follows is a bit of a hack, relying on the first field being the

[11:14] <psch> 5,946             * big integer. */

[11:14] <psch> that's a comment one line before the crash i'm seeing :) 

[11:15] <psch> i wonder if that's to blame

[11:16] <psch> well, the hint map says $!value sits in field_1...

[11:17] *** thou joined
[11:21] *** thou left
[11:21] *** rurban left
[11:27] <psch> hmm

[11:27] <psch> i'm not sure how to do this non-hacky

[11:29] <psch> the bug is that we have a code path that expects the bigint in the first field of the STable, but IntStr apparently doesn't

[11:29] *** rindolf left
[11:29] <psch> but every lookup for attributes we have needs a name, and i doubt that hardcoding '$!value' in the general-purpose bigint backend code is sane

[11:30] <psch> iterating over all fields and picking the first that type-fits probably works, but is still kind of messy...

[11:34] *** n0tjack joined
[11:34] *** rurban joined
[11:38] *** tokuhiro_ joined
[11:38] *** n0tjack left
[11:39] *** espadrine joined
[11:43] *** tokuhiro_ left
[12:01] <masak> .tell brrt in http://brrt-to-the-future.blogspot.fr/2015/09/wrapping-up.html there seems to be missing text around "I hereby promise that if any Oh". also, overnegation in "I will not maintain the illusion here that a register allocator is a nontrivial component" ?

[12:01] <yoleaux> masak: I'll pass your message to brrt.

[12:06] *** n0tjack joined
[12:10] *** n0tjack left
[12:12] *** cognominal left
[12:17] *** Peter_R joined
[12:18] *** lizmat left
[12:20] *** lizmat joined
[12:21] <[Tux]> test             50000    39.280    39.199

[12:21] <[Tux]> test-t           50000    39.186    39.105

[12:33] *** ab5tract_ joined
[12:33] <ab5tract_> [Tux]: that's faster than before, right?

[12:34] <ab5tract_> also: awesome to hear that the whole test suite passes!

[12:34] <[Tux]> a bit, just a bit (since last time)

[12:34] <[Tux]> I've been busy :)

[12:34] <ab5tract_> but vs pre-GLR?

[12:35] <ab5tract_> ISTR that it was in the 50+ seconds range

[12:35] <[Tux]> yeah, that's right

[12:35] *** xinming joined
[12:37] <[Tux]> http://tux.nl/Files/20150912143749.png

[12:38] *** n0tjack joined
[12:38] *** pmurias joined
[12:38] *** xinming_ left
[12:39] <[Tux]> https://gist.github.com/Tux/b3b1d9c63f49b65b4881

[12:40] *** xinming_ joined
[12:41] *** xinming left
[12:42] *** n0tjack left
[12:45] *** xinming joined
[12:45] *** xinming left
[12:46] <dalek> nqp/js-merge-wip: 8d8f09c | (Pawel Murias)++ | / (2 files):

[12:46] <dalek> nqp/js-merge-wip: Implement and test nqp::die_s.

[12:46] <dalek> nqp/js-merge-wip: review: https://github.com/perl6/nqp/commit/8d8f09ce1f

[12:46] <dalek> nqp/js-merge-wip: 41f82c6 | (Pawel Murias)++ | src/vm/js/ (2 files):

[12:46] <dalek> nqp/js-merge-wip: Implement nqp::exit.

[12:46] <dalek> nqp/js-merge-wip: review: https://github.com/perl6/nqp/commit/41f82c6288

[12:46] <ab5tract_> [Tux]: so, about 29% reduction from the worst numbers

[12:46] <[Tux]> yes

[12:47] *** xinming_ left
[12:47] <ab5tract_> now, how do we make it even faster? :)

[12:47] <[Tux]> but it still needs to get down to (way) below 36 (which was the fastest I ever measured)

[12:48] <ab5tract_> [Tux]: I guess I was hoping that the GLR would have a greater performance impact :(

[12:48] <[Tux]> note that there was GLR first and optimasation afterwards

[12:48] <[Tux]> jnthn++ for that

[12:49] <psch> i'm pretty sure there's still unrealized  optimizations enabled by the GLR

[12:49] <psch> it's a baseless hunch, though :)

[12:50] <dalek> doc: 21855f4 | moritz++ | lib/Type/Seq.pod:

[12:50] <dalek> doc: Initial Seq documentation

[12:50] <dalek> doc: review: https://github.com/perl6/doc/commit/21855f4468

[12:50] <dalek> doc: b0ebd7a | moritz++ | lib/Type/Seq.pod:

[12:50] <dalek> doc: Merge remote-tracking branch 'origin/glr'

[12:50] <dalek> doc: review: https://github.com/perl6/doc/commit/b0ebd7a6e3

[12:50] *** xinming joined
[12:50] *** Psyche^ joined
[12:53] *** Psyche^_ left
[12:53] *** pmurias left
[12:54] *** pmurias joined
[12:54] *** kjs__ joined
[12:54] <ab5tract_> moritz++

[12:55] *** dustinm` left
[12:55] *** xinming_ joined
[12:57] *** lizmat_ joined
[12:57] *** xinming left
[12:58] *** lizmat__ joined
[12:59] <dalek> doc: f6fb0ef | moritz++ | lib/Type/Seq.pod:

[12:59] <dalek> doc: Document some Seq methods

[12:59] <dalek> doc: review: https://github.com/perl6/doc/commit/f6fb0eff37

[12:59] *** lizmat left
[13:00] <moritz> m: say Seq eqv gather { take 1 }

[13:00] <camelia> rakudo-moar 296824: OUTPUT«Invocant requires an instance of type Seq, but a type object was passed.  Did you forget a .new?␤  in block <unit> at /tmp/kUtLXkAS0x:1␤␤»

[13:01] <dalek> rakudo/nom: be9c864 | moritz++ | src/core/Seq.pm:

[13:01] <dalek> rakudo/nom: eqv for two Seqs should only apply to two instances

[13:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be9c864c6e

[13:01] *** lizmat_ left
[13:03] <dalek> rakudo/nom: a3d86b6 | moritz++ | src/core/Seq.pm:

[13:03] <dalek> rakudo/nom: Make infix:<eqv> safer for subclasses of Seq

[13:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a3d86b6f64

[13:05] <lizmat__> sometimes I wonder whether we shouldn't have a :X to indicate exact class match  :-)

[13:05] *** araujo_ joined
[13:05] *** thou joined
[13:08] *** xfix_ joined
[13:08] *** khw joined
[13:08] *** araujo left
[13:09] *** xfix left
[13:09] *** bjz left
[13:09] <moritz> jnthn, TimToady: I think I'd like to move AT-POS and EXISTS-POS from Seq to PositionalBindFallover. Any objections?

[13:09] *** thou left
[13:10] <moritz> they rely only on .cache, not on Seq specifics, and it seems fitting because they implement positional access after all

[13:10] *** n0tjack joined
[13:14] *** dustinm` joined
[13:15] *** n0tjack left
[13:16] *** cognominal joined
[13:22] *** lizmat joined
[13:23] *** bjz joined
[13:24] *** travis-ci joined
[13:24] <travis-ci> Rakudo build failed. Moritz Lenz 'Make infix:<eqv> safer for subclasses of Seq'

[13:24] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/79989240 https://github.com/rakudo/rakudo/compare/be9c864c6e37...a3d86b6f647a

[13:24] *** travis-ci left
[13:24] *** lizmat__ left
[13:25] <jnthn> psch: The code-gen we're getting for the GLR impl isn't as good as it could be, nor is the dynopt, so there's plenty of room yet.

[13:26] <jnthn> psch: And GLR's epic wins so far are more about memory use than speed

[13:28] *** tokuhiro_ joined
[13:29] <ShimmerFairy> lizmat: we do have ::T available, for example  sub foo(Seq ::T $a, T $b) { ... }  , so you can at least ensure they're the same type :)    (seems like it could've been another possible way to do moritz's last commit)

[13:30] <moritz> ShimmerFairy: that still allows subtypes of T to be passed to $b

[13:30] *** xfix_ is now known as xfix

[13:30] <dalek> rakudo/nom: a0fcc1b | moritz++ | src/core/Seq.pm:

[13:30] <dalek> rakudo/nom: Fix typo

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a0fcc1ba3b

[13:30] <ShimmerFairy> Hm, I remember it DWIMming with role types, at least

[13:30] *** xfix is now known as Guest10684

[13:31] <ShimmerFairy> s/types/constraints/

[13:32] <dalek> doc: 78a7f2c | moritz++ | / (3 files):

[13:32] <dalek> doc: Document PositionalBindFailover

[13:32] <dalek> doc: 

[13:32] <dalek> doc: Also cleanup type-graph.txt a bit, and remove outdated class names

[13:32] <dalek> doc: from the Cool documentation

[13:32] <dalek> doc: review: https://github.com/perl6/doc/commit/78a7f2cd88

[13:33] *** tokuhiro_ left
[13:33] *** bjz left
[13:33] *** bjz joined
[13:38] <TimToady> moritz: offhand that doesn't make sense to my morningbrane; seems like the point of having those methods in Seq is for dispatching to Seq, not just binding

[13:40] <moritz> TimToady: wel, to me PositionalFailOver isn't just for the binder, but also for providing positional access / [] subscripting

[13:40] <moritz> TimToady: at least the name seems to imply that

[13:41] <moritz> oh wait, it has Bind in the name after all :-)

[13:42] <dalek> rakudo/nom: c89fb45 | moritz++ | src/core/Seq.pm:

[13:42] <dalek> rakudo/nom: Give PositionalBindFailover an "iterator" method stub

[13:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c89fb45773

[13:43] <BooK> are there any Perl6 badges ?

[13:43] *** rindolf joined
[13:43] *** n0tjack joined
[13:43] <BooK> my first day of actually programming in Perl6 and I found a corner case and the core needs fixing!

[13:43] <BooK> woohoo!

[13:44] <BooK> (lizmat is doing the fixing)

[13:44] <moritz> BooK: "certified by #perl6" is our only badge :-)

[13:44] <BooK> good enough for me :-)

[13:44] <TimToady> the Red Badge of Courage

[13:45] <maddingue> BooK wants a Pink Badge of Pride :3

[13:45] <BooK> better than a scarlet letter

[13:47] *** n0tjack left
[13:47] <psch> jnthn: so the actual big speed opts are mostly missing?  that's encouraging :)

[13:48] <jnthn> psch: Well, it's more like there's lots of small ones that'll add up

[13:48] *** bjz left
[13:48] <jnthn> psch: But it's worth noting that what I've actually done is worked out how to achieve the Perl 6 goals around lists/arrays with an extremely boring and well-trodden design that's been shown to be sufficiently optimizable by lots of other languages.

[13:51] <psch> jnthn: i see, thanks for the insight :)

[13:51] <dalek> doc: 8521852 | moritz++ | lib/Type/Seq.pod:

[13:51] <dalek> doc: Document Seq.from-loop

[13:51] <dalek> doc: review: https://github.com/perl6/doc/commit/8521852e60

[13:52] *** travis-ci joined
[13:52] <travis-ci> Rakudo build passed. Moritz Lenz 'Fix typo'

[13:52] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/79990986 https://github.com/rakudo/rakudo/compare/a3d86b6f647a...a0fcc1ba3b5c

[13:52] *** travis-ci left
[13:54] *** bjz joined
[13:54] <lizmat> m: sub a(Capture() $a) { dd $a }; a (42, 42)

[13:54] <camelia> rakudo-moar a0fcc1: OUTPUT«Capture $a = \(42, 42)␤»

[13:55] <lizmat> m: sub a(Capture() $a) { dd $a }; a (42)

[13:55] <camelia> rakudo-moar a0fcc1: OUTPUT«This representation (Null) does not support elems␤  in sub a at /tmp/QueBlFAMqd:1␤  in block <unit> at /tmp/QueBlFAMqd:1␤␤»

[13:55] <lizmat> m: sub a(Capture() $a) { dd $a }; a (42, a => 13)

[13:55] <camelia> rakudo-moar a0fcc1: OUTPUT«Capture $a = \(42, :a(13))␤»

[13:55] <lizmat> m: sub a(Capture() $a) { dd $a }; a (a => 13)

[13:55] <camelia> rakudo-moar a0fcc1: OUTPUT«This representation (Null) does not support elems␤  in sub a at /tmp/Q9Ab_kOxLe:1␤  in block <unit> at /tmp/Q9Ab_kOxLe:1␤␤»

[13:55] <lizmat> ^^^ fixing this one now

[13:57] <masak> BooK++ # Perl 6 user

[13:58] <raiph> .tell nine https://www.reddit.com/r/perl/comments/3k4r7t/larry_wall_presents_perl_6/cuwx9rh

[13:58] <yoleaux> raiph: I'll pass your message to nine.

[13:58] *** bjz left
[14:00] *** raiph left
[14:01] *** camelia left
[14:02] *** araujo_ left
[14:02] *** camelia joined
[14:04] *** ChanServ sets mode: +v camelia

[14:04] *** travis-ci joined
[14:04] <travis-ci> Rakudo build passed. Moritz Lenz 'Give PositionalBindFailover an "iterator" method stub'

[14:04] <travis-ci> https://travis-ci.org/rakudo/rakudo/builds/79991870 https://github.com/rakudo/rakudo/compare/a0fcc1ba3b5c...c89fb4577313

[14:04] *** travis-ci left
[14:04] *** lizmat_ joined
[14:05] *** araujo_ joined
[14:07] <TimToady> m: use nqp; my $h = { a => 42 }; say nqp::istype($h,Associative)

[14:07] <camelia> rakudo-moar a0fcc1: OUTPUT«1␤»

[14:07] *** lizmat left
[14:08] <TimToady> jnthn: ^^^ comes out true, but when I try to use the same test in nqp (to check type on 'constant %hash = stuff') it returns false

[14:08] <jnthn> TimToady: How're you getting hold of Associative?

[14:08] <TimToady> the line in question reads:

[14:08] <TimToady>             if !nqp::istype($value,Associative) {

[14:09] <jnthn> And where is this line?

[14:09] <jnthn> In Actions/World?

[14:09] <TimToady> Actions, type_declarator:sym<constant>

[14:09] <jnthn> If so you can't write it that way 

[14:09] <jnthn> Yeah

[14:09] <TimToady> why i asked :)

[14:09] *** FROGGS_ joined
[14:09] <jnthn> You need to be talking about the Associative type as seen by the program you're compiling

[14:10] <jnthn> $*W.find_symbol(['Associative'])

[14:10] *** araujo_ left
[14:10] <TimToady> thanks

[14:10] <jnthn> We try pretty hard to not have the compiler be confused about itself and the program it's compiling ;)

[14:11] <jnthn> (Essential in NQP since we are bootstrapped, and we try pretty hard in Rakudo too to keep that door open.)

[14:11] <psch> ShimmerFairy: why do RatStr and NumStr bind both typed values to self but IntStr uses nqp::add_I?

[14:11] <psch> ShimmerFairy: oh, there's a comment above..

[14:12] <psch> the trick makes it work not-right on jvm

[14:12] <psch> and to make it work i have to add significant lookup logic to Ops.getBI :/

[14:13] *** FROGGS left
[14:13] <jnthn> Yeah, I think we cheat pretty hard about that on the JVM...

[14:14] *** bjz joined
[14:14] <psch> jnthn: yeah, we do... "obj.get_attribute_native(tc, null, null, 0);" is the offending line...

[14:15] <psch> IntStr wants the get_attribute_native call on field_1 instead :/

[14:15] <psch> which means "look through all fields and see if one of them has a BigInteger as field", from the looks of it

[14:15] *** n0tjack joined
[14:16] <psch> 'cause resolveAttribute needs a name, in addition to a classHandle

[14:16] <jnthn> try { return obj.get_attribute_native(..., 0); } catch { return obj.get_attribute_native(..., 1); } # :P

[14:17] <psch> jnthn: but that doesn't work, cause we need field_0 of obj.field_1 :P

[14:17] <jnthn> oh...

[14:17] <ShimmerFairy> psch: I did try binding normally before, it just failed on trying to unbox bigints :)  if only there were somehow a way to push around bigint attributes without falling back to native ints along the line...

[14:18] <psch> ShimmerFairy: yeah, i had thought maybe we want bindattr_I... not sure if there's actual merrit to that idea, though

[14:18] <psch> ShimmerFairy: although the jvm BigInteger handling is somewhat lacking as well...

[14:19] <ShimmerFairy> when I brought that up, I heard that (unsurprisingly) the _I version would be quite a different beast than the other versions :)

[14:19] *** lizmat_ is now known as lizmat

[14:19] *** n0tjack left
[14:20] <psch> well, if it's been brought up before i'll save myself the effort of actually thoroughly thinking about it... :S

[14:24] <psch> i'll just go with the "check every field if it has a BigInteger as field_0" approach for now...

[14:24] *** araujo_ joined
[14:26] <psch> "interestingFields.get(hint).get(obj).field_0.getClass().equals(BigInteger.class)"

[14:26] <psch> oh java, never change <3

[14:27] *** araujo_ left
[14:28] <psch> ah, missing the casts of course

[14:28] *** araujo joined
[14:28] *** araujo left
[14:28] *** araujo joined
[14:28] <psch> well, just one in this case

[14:34] *** skids joined
[14:34] <smash> (perl6 propaganda) the new Portuguese Perl Programmers Association Website is generated (almost entirely) using Perl 6 -- http://perl.pt

[14:34] <Zoffix> 0.o

[14:34] <lizmat> m: (a => 42).Capture.perl.sey

[14:34] <camelia> rakudo-moar c89fb4: OUTPUT«This representation (Null) does not support elems␤  in block <unit> at /tmp/UHocnXwZoG:1␤␤»

[14:35] <lizmat> m: (a => 42,).Capture.perl.sey

[14:35] <camelia> rakudo-moar c89fb4: OUTPUT«Method 'sey' not found for invocant of class 'Str'␤  in block <unit> at /tmp/e0cd6NcfX8:1␤␤»

[14:35] <lizmat> m: (a => 42,).Capture.perl.say

[14:35] <camelia> rakudo-moar c89fb4: OUTPUT«\(:a(42))␤»

[14:35] <Zoffix> smash, that's really cool!

[14:35] <lizmat> m: my $p = (a => 42); $p.Capture.perl.say

[14:35] <camelia> rakudo-moar c89fb4: OUTPUT«This representation (Null) does not support elems␤  in block <unit> at /tmp/EuSQmYOQHZ:1␤␤»

[14:36] <jnthn> smash: Cool :)

[14:37] <jnthn> lizmat: Looks like Capture.perl wants a patch :)

[14:37] <lizmat> jnthn: I'm not sure, observe:

[14:37] <lizmat> m: (42,).Capture.perl.say

[14:37] <camelia> rakudo-moar c89fb4: OUTPUT«\(42)␤»

[14:37] <lizmat> m: (42).Capture.perl.say

[14:37] <camelia> rakudo-moar c89fb4: OUTPUT«This representation (Null) does not support elems␤  in block <unit> at /tmp/Zp5xWzJs3G:1␤␤»

[14:37] <lizmat> I would argue that would be the same thing, or not?

[14:38] <lizmat> m: 42.Capture.perl.say

[14:38] <camelia> rakudo-moar c89fb4: OUTPUT«This representation (Null) does not support elems␤  in block <unit> at /tmp/i1aiSS15G6:1␤␤»

[14:39] <lizmat> should that say Capture.new( :value(42) )   # as the spectest seems to suggest ?

[14:39] <lizmat> m: 42.Capture<value>.say

[14:39] <camelia> rakudo-moar c89fb4: OUTPUT«This type does not support associative operations␤  in block <unit> at /tmp/SH0QTfFcVS:1␤␤»

[14:39] <lizmat> m: (a => 42).Capture<a>.say

[14:39] <camelia> rakudo-moar c89fb4: OUTPUT«Nil␤»

[14:39] <lizmat> m: (a => 42).Capture<key>.say

[14:39] <camelia> rakudo-moar c89fb4: OUTPUT«a␤»

[14:39] <lizmat> m: (a => 42).Capture<value>.say  # does that make sense at all ?

[14:39] <camelia> rakudo-moar c89fb4: OUTPUT«42␤»

[14:40] <lizmat> m: (a => 42).Capture<key value>.say 

[14:40] <camelia> rakudo-moar c89fb4: OUTPUT«(a 42)␤»

[14:40] <lizmat> m: (a => 42,).Capture<key value>.say 

[14:40] <camelia> rakudo-moar c89fb4: OUTPUT«(Nil Nil)␤»

[14:41] <lizmat> a patch I work on, would:

[14:41] <lizmat> $ 6 '42.Capture.perl.say'

[14:41] <lizmat> \(42)

[14:42] <jnthn> lizmat: Coercion of a Pair to a Capture should produce key/value Associative values, yes

[14:42] <jnthn> lizmat: That's how unpacking of pairs works

[14:43] <jnthn> m: sub foo((:$key, :$value)) { say $key }; my $p = a => 42; foo($p)

[14:43] <camelia> rakudo-moar c89fb4: OUTPUT«a␤»

[14:43] *** lizmat left
[14:44] *** lizmat joined
[14:44] <skids> m: \(42).perl.say; # interesting that that worked when .Capture didn't

[14:44] <camelia> rakudo-moar c89fb4: OUTPUT«\(42)␤»

[14:44] <dalek> rakudo/nom: 8876f4d | TimToady++ | src/Perl6/Actions.nqp:

[14:44] <dalek> rakudo/nom: rudimentary typecheck on constant %h = ...

[14:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8876f4d420

[14:45] <lizmat> m: m: sub foo((:$a)) { say $key }; my $p = (a => 42,); foo($p)

[14:45] <camelia> rakudo-moar c89fb4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KsZP1PvsNV␤Variable '$key' is not declared␤at /tmp/KsZP1PvsNV:1␤------> 3m: sub foo((:$a)) { say 7⏏5$key }; my $p = (a => 42,); foo($p)␤»

[14:46] <lizmat> m: m: sub foo((:$a)) { say $a }; my $p = (a => 42,); foo($p)

[14:46] <camelia> rakudo-moar c89fb4: OUTPUT«42␤»

[14:46] <lizmat> I find the fact that a pair unpacks to key/value to be very weird

[14:46] <lizmat> it's exposing an implementation detail, I feel

[14:47] <lizmat> maybe the problem is really that (a => 42) gives a Pair, and (a => 42,) gives a List with a Pair

[14:47] *** n0tjack joined
[14:48] <jnthn> None of this is a problem.

[14:48] <lizmat> well, it was a WAT for me today, and other people here  :-)

[14:48] <jnthn> And .Capture *is* an implementation detail

[14:49] <jnthn> Sorry, but people are going to *have* to get used to trailing commas being significant.

[14:49] <jnthn> That's the trade-off we picked in the GLR

[14:49] <ShimmerFairy> I thought trailing commas were always significant (maybe not always in the same places, but still)

[14:50] <lizmat> ok, fair enough...

[14:50] *** kjs__ left
[14:50] <jnthn> (And yes, I'm working on an S07 that tries to get this stuff down coherently. :))

[14:50] <dalek> roast: 3a5cb6d | TimToady++ | S04-declarations/constant.t:

[14:50] <dalek> roast: check that constant %hash = "nonhash" dies

[14:50] <dalek> roast: review: https://github.com/perl6/roast/commit/3a5cb6d218

[14:52] *** n0tjack left
[14:53] *** thou joined
[14:54] <ShimmerFairy> Also, I have to ask: how exactly are Capture objects an implementation detail, when they're in the spec? My definition of implementation detail would include things like BOOTSTRAPATTR, or any of the nqp::ops.

[14:55] <moritz> ShimmerFairy: to me, they aren't (though maybe there are situations where they are)

[14:56] <jnthn> ShimmerFairy: "Implementation type" would probably have been better wording

[14:56] <jnthn> ShimmerFairy: More, something that has to be user-visible, but that you aren't that likely to use directly in normal programming

[14:56] <jnthn> IterationBuffer is another example; we need to exposed for folks who are implementing iterator-y things, but uusually you aren't doing that.

[14:57] <ShimmerFairy> Yeah, I suppose I think of problematic impl. details as being along the lines of "oops, now I've got an NQP object", when it comes to rakudo :)

[15:00] *** rurban left
[15:03] *** ab5tract_ left
[15:03] <psch> $ ./perl6-j -e'say val("5").WHAT'

[15:03] <psch> (IntStr)

[15:03] <psch> there we go :)

[15:04] <ShimmerFairy> \o/

[15:06] <dalek> nqp: 4796e92 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/P6Opaque.java:

[15:06] <dalek> nqp: Add an environment variable for dumping generated class files.

[15:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4796e9225b

[15:06] <dalek> nqp: ec6341f | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[15:06] <dalek> nqp: Fixed getBI code to support Rakudo allomorphs.

[15:06] <dalek> nqp: 

[15:06] <dalek> nqp: It's still somewhat of a hack, but at least it works again.

[15:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ec6341f71b

[15:08] <psch> ugh

[15:08] <psch> the first of those i had corrected...

[15:09] <dalek> nqp: 75281c2 | peschwa++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/P6Opaque.java:

[15:09] <dalek> nqp: Correct a syntax error.

[15:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/75281c2dd5

[15:17] *** lizmat_ joined
[15:18] *** lizmat left
[15:19] *** n0tjack joined
[15:24] *** n0tjack left
[15:25] <dalek> rakudo/nom: 7d3a87f | peschwa++ | tools/build/NQP_REVISION:

[15:25] <dalek> rakudo/nom: Bump NQP_REVISION to get allomorphs on jvm.

[15:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d3a87fa2b

[15:25] <psch> now: spectest \o/

[15:26] <jnthn> psch++

[15:28] <BooK> is there any perl6style documentation?

[15:28] <BooK> I can't decide on my own what a good style is, I need guidance!

[15:30] *** tokuhiro_ joined
[15:30] <moritz> BooK: we mostly follow perlstyle

[15:31] <psch> BooK: with CORE being greatly in p6 it's kind of its own style guide... ;)

[15:32] * ShimmerFairy is unfamiliar with perlstyle :P

[15:34] <cschwenz> on a freshly pulled and built perl6-m, has anyone else run into Digest::MD5 failing the testing stage?

[15:34] *** tokuhiro_ left
[15:34] *** n0tjack joined
[15:36] *** Guest10684 left
[15:36] *** xfix joined
[15:39] *** n0tjack left
[15:40] *** n0tjack joined
[15:41] <_itz> cschwenz: yes its still not GLR-friendly, I think someone was talking of fixing it in the last 24 hr or so but forget details

[15:43] <cschwenz> ah, thanks

[15:44] <ugexe> pretty sure that was fixed yesterday

[15:44] <cschwenz> hmm

[15:44] <cschwenz> https://github.com/cosimo/perl6-digest-md5/issues/11

[15:44] <cschwenz> that is what i'm running into

[15:44] <cschwenz> as of now

[15:45] <skids> https://gist.github.com/skids/050f108b753ab42a215f # A start on some post-GLR doccing.  Didn't want to commit and run, will check gist comments tonight.

[15:46] *** n0tjack left
[15:48] <ugexe> oh, `Digest` got fixed

[15:48] <ugexe> which has md5 as well

[15:49] <cschwenz> I ran into this because I'm building a completely clean install for post-GLR so I can shake out these sort of bugs.  :-P

[15:49] <lizmat_> cschwenz++  :-)

[15:50] <cschwenz> \o lizmat!  :-)

[15:51] <lizmat_> cschwenz o/  :-)

[15:52] *** n0tjack joined
[15:56] *** n0tjack left
[15:58] <skids> I have that test file in Sum as well, and only recall having to fix done/done-testing

[16:01] <dalek> rakudo/nom: 247a405 | TimToady++ | src/Perl6/Actions.nqp:

[16:01] <dalek> rakudo/nom: warn on useless use of hash composer in assignment

[16:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/247a405dd7

[16:02] <TimToady> m: constant %hash = 42

[16:02] <camelia> rakudo-moar 7d3a87: OUTPUT«5===SORRY!5=== Error while compiling /tmp/s4nYYfYj8X␤Type check failed in constant declaration of %hash; expected 'Associative' but got 'Int'␤at /tmp/s4nYYfYj8X:1␤------> 3constant %hash = 427⏏5<EOL>␤»

[16:03] <cschwenz> m: constant %hash = 42,;

[16:03] <camelia> rakudo-moar 7d3a87: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VHa8VbvnLR␤Type check failed in constant declaration of %hash; expected 'Associative' but got 'List'␤at /tmp/VHa8VbvnLR:1␤------> 3constant %hash = 42,7⏏5;␤    expecting any of:␤        prefix…»

[16:05] <TimToady> the = on constants is really binding

[16:05] <TimToady> or "definition" if I can work it out

[16:07] *** skids left
[16:09] <TimToady> m: constant things = (^5).grep(* % 2); say things>>.abs; say things>>.abs

[16:09] <camelia> rakudo-moar 7d3a87: OUTPUT«(1 3)␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/1eEXJLgR1o:1␤␤»

[16:09] <TimToady> m: constant @things = (^5).grep(* % 2); say @things>>.abs; say @things>>.abs

[16:09] <camelia> rakudo-moar 7d3a87: OUTPUT«(1 3)␤(1 3)␤»

[16:09] <jnthn> \o/

[16:09] <jnthn> TimToady++

[16:12] <cschwenz> jnthn or TimToady:  can you please explain what is going on differently between those two?

[16:12] <dalek> ecosystem: 8254523 | (Nuno Carvalho)++ | META.list:

[16:12] <dalek> ecosystem: Add new module

[16:12] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8254523a0f

[16:12] <dalek> ecosystem: 42807d1 | (Zoffix Znet)++ | META.list:

[16:12] <dalek> ecosystem: Merge pull request #56 from nunorc/master

[16:12] <dalek> ecosystem: 

[16:12] <dalek> ecosystem: Add new module: Pekyll

[16:12] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/42807d12d2

[16:12] *** ab5tract_ joined
[16:15] <jnthn> cschwenz: A Seq is a one-shot producer of values, but assigning it to an @-sigil'd thing (well, pseudo-assignment in this case) turns the Seq into a List, which you can iterate as many times as you want 'cus it remembers values.

[16:16] <cschwenz> ahh, thanks!  :-D 

[16:16] *** raiph joined
[16:16] <arnsholt> Does that mean that all lists are finite?

[16:17] *** bjz left
[16:17] <jnthn> arnsholt: No, a List can be lazy too

[16:17] *** bjz joined
[16:18] <cognominal> jnthn,  in what a Seq is different from what a Parcel was?

[16:18] <jnthn> cognominal: Everything.

[16:18] <cognominal> :)

[16:18] <jnthn> cognominal: I'll push an in-progress S07 shortly that tries to explain this stuff well, if a little boringly.

[16:18] <cognominal> ok, I am eager to read the new S07. jnthn++

[16:19] <thou> boring is good

[16:19] <jnthn> Well, it won't be all of it, but I've started with the most user-facing bits.

[16:19] <thou> tendentious is more fun, but boring works :-)

[16:20] *** lizmat_ left
[16:20] *** lizmat joined
[16:21] *** bjz left
[16:22] <thou> skids++ # Conventions and Idioms docs

[16:23] <psch> hm

[16:23] <psch> S17-supply/syntax.t hangs on jvm

[16:23] *** bjz joined
[16:23] <psch> ...but only via make spectest

[16:23] <FROGGS_> psch: how is the state in general?

[16:24] <psch> maybe TEST_JOBS=4 mucked it up...

[16:24] <ambs> quick question.....     %foo{a}{b}.push(%x);   @elems = %foo{a}{b};  # @elems seems to be a list of lists?

[16:24] *** n0tjack joined
[16:25] <psch> FROGGS_: pre the IntStr fix from a bit ago i had 84 files with some amount of failures

[16:25] <cognominal> a boring jnthn, that would be first. :)

[16:25] <cognominal> * a first

[16:26] <FROGGS_> psch: 84? that's not that bad...

[16:26] <FROGGS_> psch: does that mean that one can declare classes outside of the setting?

[16:26] <psch> FROGGS_: i'm on nom

[16:26] <FROGGS_> well, yes

[16:27] <psch> FROGGS_: it worked there since the nqp fix yesterday

[16:27] <FROGGS_> really?

[16:27] <psch> (or was that the day before yesterday..?)

[16:27] <FROGGS_> what about the nativecall tests?

[16:27] <psch> FROGGS_: yeah, NativeCall tests where broken

[16:27] <FROGGS_> and are still?

[16:27] <psch> still are i think, i haven't looked explicitely 

[16:27] <FROGGS_> k

[16:27] * ambs wonders if there is a perl6-help channel.

[16:27] <psch> i usually start at the top with spectest results... :)

[16:27] <FROGGS_> I thought that the nativecall tests and the class declarations are the same issue

[16:28] <psch> but ya, j-test is more important

[16:28] <FROGGS_> ambs: not yet

[16:28] <ambs> FROGGS_: ok, then will wait so someone has some time :)

[16:28] <FROGGS_> ambs: we'll open one when we have 5k regulars :o)

[16:28] <psch> FROGGS_: maybe, i don't know the NativeCall code well, if it depends on SC somehow it could be that's the reason...

[16:29] <psch> FROGGS_: though i hope not, 'cause *I* don't want to hunt this spooky SC-changing bug :P

[16:29] <FROGGS_> psch: I'll check that later :o)

[16:29] *** ab5tract_ left
[16:29] <FROGGS_> currently working on more fun things

[16:29] *** n0tjack left
[16:30] *** bjz left
[16:32] <thou> m: my %x = :x(1), :y(2), :z(3); my %foo; %foo<a><b>.push(%x); my @elems = %foo<a><b>; dd @elems;

[16:32] <camelia> rakudo-moar 247a40: OUTPUT«Array @elems = [[:x(1), :z(3), :y(2)],]␤»

[16:32] *** vendethiel joined
[16:33] *** ShimmerFairy left
[16:33] <ambs> thou: that seems ok

[16:33] <thou> yeah

[16:33] <ambs> btw, what the different between using {} or <> ?

[16:34] <psch> ambs: <> quotes

[16:34] <ambs> ok

[16:35] <psch> ...and interpolates

[16:35] <psch> m: my %h = '$foo' => 1, 'bar' => 2; my $foo = "bar"; say %h<$foo> ~ " " ~ %h{$foo}; # example serves better, i guess

[16:35] <camelia> rakudo-moar 247a40: OUTPUT«1 2␤»

[16:35] <psch> err

[16:35] <psch> what

[16:35] <psch> no it doesnt interpolate

[16:35] <psch> gosh

[16:36] * psch goes back to Java

[16:36] <psch> less complicated quoting ;P

[16:36] <ugexe> it makes space mark items instead of , as well

[16:36] <psch> ugexe: right!

[16:36] <ugexe> m: my %x = :x(1), :y(2), :z(3); my %foo; %foo<a><b>.push(%x); my @elems = %foo<a><b c>; dd @elems

[16:36] <camelia> rakudo-moar 247a40: OUTPUT«Array @elems = [[:x(1), :z(3), :y(2)], Any]␤»

[16:36] <ugexe> otherwise it would be {'b', 'c'}

[16:36] <psch> <> is qw{}

[16:36] *** bjz joined
[16:36] <psch> (not qqw, that *would* interpolate)

[16:37] <psch> m: say val("5")

[16:37] <camelia> rakudo-moar 247a40: OUTPUT«5␤»

[16:37] <psch> m: say val("5").WHAT

[16:37] <camelia> rakudo-moar 247a40: OUTPUT«(IntStr)␤»

[16:38] <thou> «» would interpolate

[16:38] <psch> thou: but that doesn't work as hash subscript i think?

[16:38] <thou> m: my %h = '$foo' => 1, 'bar' => 2; my $foo = "bar"; say %h<<$foo>> ~ " " ~ %h{$foo};

[16:38] <camelia> rakudo-moar 247a40: OUTPUT«2 2␤»

[16:38] <psch> ah it does

[16:39] *** ZoffixWork joined
[16:39] <thou> ^ for this simple case obviously it's better to just use {$foo} if that's what you're after :)

[16:40] <thou> ambs: feeling -help'd?

[16:41] <ambs> not really :) confused. let me paste some code.

[16:41] <ZoffixWork> Does anyone know what 'flussence' is known as on github now?

[16:41] *** kjs__ joined
[16:41] <psch> ZoffixWork: https://github.com/flussence seems to point to someone who could be our flussence..?

[16:41] *** bjz left
[16:42] <TimToady> m: my %hash = { a => 42 };

[16:42] <camelia> rakudo-moar 247a40: OUTPUT«Potential difficulties:␤    Useless use of hash composer on right side of hash assignment; did you mean := instead?␤    at /tmp/GxxnvrD0uG:1␤    ------> 3my %hash = { a => 42 }7⏏5;␤»

[16:42] <ZoffixWork> psch, oh, sorry. Not enough coffee :P

[16:44] <coffee`> sorry.

[16:44] <ZoffixWork> :D

[16:46] <Guest30914> :bu

[16:47] <Guest30914> oups, sorry

[16:47] <ambs> this is what I am trying to understand: http://paste.perldancer.org/dxp3Sv0ZwTJQ

[16:47] *** domidumont left
[16:47] *** ShimmerFairy joined
[16:48] <thou> ok

[16:50] <psch> ambs: the .push call assigns an Array to %other<foo><bar>, and that array doesn't get flattened into @list

[16:50] <thou> you can use @list :=

[16:51] <thou> or you can use @list = |%other…

[16:51] <psch> ambs: additionally, the "<>" in the output tells me you're running pre-GLR code, you might want to consider upgrading

[16:51] <ambs> psch: ok, this is what brew installed me :)

[16:51] <psch> ambs: when?

[16:51] <ambs> psch: week ago

[16:52] <raiph> ambs: what does perl6 -v say?

[16:52] <ambs> This is perl6 version 2015.07.2 built on MoarVM version 2015.07

[16:52] <ambs> but still didn't understand correctly that code behavior.

[16:52] <psch> ambs: glr was merged on the 4th at 15:17 UTC

[16:53] <psch> m: say $*KERNEL.build-date

[16:53] <camelia> rakudo-moar 247a40: OUTPUT«Method 'build-date' not found for invocant of class 'Kernel'␤  in block <unit> at /tmp/vmkpIzAcw1:1␤␤»

[16:53] <psch> m: say $*DISTRO.build-date

[16:53] <camelia> rakudo-moar 247a40: OUTPUT«Method 'build-date' not found for invocant of class 'Distro'␤  in block <unit> at /tmp/Y9dVbc4KjD:1␤␤»

[16:53] <psch> m: say $*PERL.build-date

[16:53] <camelia> rakudo-moar 247a40: OUTPUT«Method 'build-date' not found for invocant of class 'Perl'␤  in block <unit> at /tmp/44rRn0tVNR:1␤␤»

[16:53] <psch> m: say $*COMPILER.build-date

[16:53] <camelia> rakudo-moar 247a40: OUTPUT«Dynamic variable $*COMPILER not found␤  in block <unit> at /tmp/HR5pit7amv:1␤␤Actually thrown at:␤  in any  at src/gen/m-Metamodel.nqp:2869␤  in block <unit> at /tmp/HR5pit7amv:1␤␤»

[16:53] <psch> oh ffs

[16:53] * psch dinner &

[16:55] <dalek> specs: de53e4b | jnthn++ | S07-lists.pod:

[16:55] <dalek> specs: Initial work on an S07 re-write.

[16:55] <dalek> specs: 

[16:55] <dalek> specs: This is a work in progress, and I'll be filling out the rest in the

[16:55] <dalek> specs: coming days. It could do with some proof-reading; patches to fix any

[16:55] <dalek> specs: issues are welcome.

[16:55] <dalek> specs: review: https://github.com/perl6/specs/commit/de53e4be12

[16:56] <jnthn> Prolly gone for the rest of the day. Enjoy. :) o/

[16:57] <ambs> ok, fixed my code, it works. But still did not understand why it doesn't do what I mean :-)

[16:58] <raiph> ambs: the push arg doesn't flatten

[16:58] *** n0tjack joined
[16:58] <moritz> m: give <b a>.sort, 'c' { say .elems; say .flat.elems }

[16:58] <camelia> rakudo-moar 247a40: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EHenPDYKUe␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/EHenPDYKUe:1␤------> 3give <b a>.sort, 'c'7⏏5 { say .elems; say .flat.elems }␤    expe…»

[16:58] <moritz> m: given <b a>.sort, 'c' { say .elems; say .flat.elems }

[16:58] <camelia> rakudo-moar 247a40: OUTPUT«2␤3␤»

[17:00] <dalek> ecosystem: 8e5a58a | (Zoffix Znet)++ | META.list:

[17:00] <dalek> ecosystem: Update META.info to META6.json for several flussence's modules

[17:00] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8e5a58abec

[17:00] <ZoffixWork> If anyone's interested, I wrote a short Perl 5 script that checks every module link in the ecosystem for 404s, and loads up the META file to check for JSON errors: https://github.com/zoffixznet/p6-ecosystem-meta-checker

[17:00] <ZoffixWork> Found 6 errors! :) 4 404s and 2 JSON errors :)_

[17:01] <moritz> ZoffixWork: http://ecosystem-api.p6c.org/errors.json also reports json errors

[17:01] <thou> m: my $elem = [{ :age(7), :name(8) },]; my @x = $elem; my $y = $elem; my @z := $elem; dd @x; dd $y; dd @z;

[17:01] <camelia> rakudo-moar 247a40: OUTPUT«Array @x = [[{:age(7), :name(8)},],]␤Array $y = [{:age(7), :name(8)},]␤[{:age(7), :name(8)},]␤»

[17:01] <moritz> ZoffixWork: I've just submitted a pull request for tony-o/perl6-json-faster

[17:01] <ZoffixWork> Cool :)

[17:02] *** spider-mario joined
[17:02] *** n0tjack left
[17:03] <ambs> ok, with http://paste.perldancer.org/XoDeNm53WCCl I can understand it better.

[17:03] <ambs> basically, attribution in line 13 fills the first element of the array.

[17:03] <ZoffixWork> I've submitted a PR for the other one with the error

[17:03] <moritz> thanks ZoffixWork++

[17:05] <thou> ambs, you're expecting @list = $elem, when $elem contains an array, to flatten that into @list, but it doesn't. it's assigning $elem as @list[0]. You can bind @list to the array that $elem contains with @list := $elem. you can use $list, so that it is also a scalar that contains the array.

[17:05] <ambs> thou: how can I use $list as an array, btw?

[17:05] <moritz> @$list

[17:05] <ambs> ah, perl5!!! :-)

[17:06] <colomon> moritz: is that implicitly $list.list?

[17:06] <ambs> so, my @list = @(%other<foo><bar>); works as well, cool.

[17:06] <thou> m: my $elem = [{ :age(7), :name(8) },]; my @w = |$elem; dd @w;  # One other option

[17:06] <camelia> rakudo-moar 247a40: OUTPUT«Array @w = [{:age(7), :name(8)},]␤»

[17:06] *** ZoffixWork left
[17:06] <ambs> my version doesn't support | in attribution yet. bah

[17:06] <psch> star: my $elem = [{ :age(7), :name(8) },]; my @w = |$elem; dd @w; 

[17:06] <camelia> star-m 2015.03: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lmyOGm5ads␤Variable '&prefix:<|>' is not declared␤at /tmp/lmyOGm5ads:1␤------> 3lem = [{ :age(7), :name(8) },]; my @w = 7⏏5|$elem; dd @w;␤»

[17:07] <ambs> clearer now. than you all :-)

[17:08] <thou> thanks for the good question

[17:08] <ambs> ;)

[17:13] *** vendethiel left
[17:13] <dalek> doc: 60d0384 | moritz++ | lib/Type/Iterable.pod:

[17:13] <dalek> doc: Update Iterable documentation match post-GLR reality

[17:13] <dalek> doc: review: https://github.com/perl6/doc/commit/60d03845ad

[17:14] *** rangerprice joined
[17:14] <rangerprice> Hi everyone !

[17:14] <moritz> \o rangerprice 

[17:15] <rangerprice> I need to implement an embedded SSH server in Perl that will work on a RPI, is Dropbear SSH a good choice ?

[17:18] <psch> rangerprice: implement an existing SSH server?

[17:18] <ambs> who should I contact to ask a minor edit in this page? http://rakudo.org/how-to-get-rakudo/

[17:19] <rangerprice> psch: yes

[17:19] <dalek> specs: d1a7191 | lizmat++ | S07-lists.pod:

[17:19] <dalek> specs: Minor nit

[17:19] <dalek> specs: review: https://github.com/perl6/specs/commit/d1a719192a

[17:19] <psch> rangerprice: how does that work?  if the SSH server is already working the implementation is complete, isn't it?

[17:20] <ambs> ah, in fact, not relevant.

[17:20] <psch> rangerprice: i'm just asking because i don't understand the question, sorry if it sounds snarky or anything

[17:20] <lizmat> ambs: a PR will do the trick, I think

[17:20] <lizmat> patch -p3 shutting down

[17:20] <lizmat> it was very intensive and exhausting

[17:20] <psch> lizmat++

[17:20] <lizmat> but I think we all learned a lot today here :-)

[17:20] <rangerprice> psch: no, in fact i need to implement my own SSH server in a perl script

[17:21] <lizmat> dinner&

[17:21] *** lizmat left
[17:22] <ambs> it seems homebrew go for the latest tarball available in http://rakudo.org/downloads/star, so, natural the latest is from July!

[17:22] <psch> rangerprice: ah, i see.  in that case i'd suggest the corresponding RFC, which is RFC 4251 (and a few related ones like 4253)

[17:22] <psch> rangerprice: i'm not really one for implementing network protocols though, so take that as you will :)

[17:23] <thou> jnthn++ # Awesome S07-lists.pod update!

[17:23] <psch> ambs: we have rakudobrew ( https://github.com/tadzik/rakudobrew ) which gives you a few more choices re: backend and version for rakudo specifically

[17:23] <psch> ambs: i don't know how it integrates with homebrew though, if at all

[17:24] <rangerprice> okay thanks psch 

[17:24] <ambs> psch: itseems it doesn't, but yeah, using rakudobrew now.

[17:27] <rangerprice> psch: But, They have actually no existing perl module that allow to implement a ssh server easily ?

[17:27] <moritz> IMHO reimplementing SSH is a very bad idea if you can avoid it

[17:28] <moritz> it's very security relevant and hard to get right

[17:28] <moritz> what's the use case?

[17:28] <dalek> rakudo/nom: be13af9 | TimToady++ | src/Perl6/Actions.nqp:

[17:28] <dalek> rakudo/nom: @() contextualizer should use .cache, not .list

[17:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be13af9791

[17:29] <psch> rangerprice: that's what i was asking at the begining.  if you really have to *implement* it (as in, decide what happens with network packages), you should look at the RFC

[17:29] <psch> rangerprice: if you have an assignment that should do something with an ssh-connection, you probably want #perl, unless your teacher is extremely progressive :)

[17:30] <psch> (where "teacher" might also mean "boss", work assignments exists after all...)

[17:30] *** n0tjack joined
[17:35] *** n0tjack left
[17:40] <ambs> ok, souce rules: perl6 version 2015.07.1-856-g247a405 built on MoarVM version 2015.08-15-g4b427ed

[17:56] *** khw left
[17:57] *** lizmat joined
[17:57] *** kjs__ left
[18:02] *** n0tjack joined
[18:04] *** cschwenz left
[18:04] <TimToady> m: my $l = (list 1,2,4...16); say $l.WHAT

[18:04] <camelia> rakudo-moar be13af: OUTPUT«(List)␤»

[18:04] <TimToady> m: my $l = (list 1,2,4...16); say $l[0].WHAT

[18:04] <camelia> rakudo-moar be13af: OUTPUT«(Seq)␤»

[18:04] <TimToady> hmm...

[18:04] <TimToady> needs one-arging, I guess

[18:04] <TimToady> m: my $l = (list 1,2,4...16); say $l

[18:04] <camelia> rakudo-moar be13af: OUTPUT«((1 2 4 8 16))␤»

[18:05] <TimToady> note the double (())

[18:07] *** n0tjack left
[18:08] <dalek> specs: 70844c1 | lizmat++ | S07-lists.pod:

[18:08] <dalek> specs: Fix typo

[18:08] <dalek> specs: review: https://github.com/perl6/specs/commit/70844c1deb

[18:09] <dalek> specs: 829e71d | lizmat++ | S07-lists.pod:

[18:09] <dalek> specs: We *can* call .cache multiple times

[18:09] <dalek> specs: 

[18:09] <dalek> specs: It will just return the same lazy list.  The removed line seems to

[18:09] <dalek> specs: contradict that.

[18:09] <dalek> specs: review: https://github.com/perl6/specs/commit/829e71d8f2

[18:09] *** cschwenz joined
[18:09] <colomon> m: sub a(Iterable $a) { say $a.pull-one; }; a(1..10)

[18:09] <camelia> rakudo-moar be13af: OUTPUT«Method 'pull-one' not found for invocant of class 'Range'␤  in sub a at /tmp/HA2gxLIITQ:1␤  in block <unit> at /tmp/HA2gxLIITQ:1␤␤»

[18:10] <colomon> m: sub a(Iterable $a) { my $b = $a.iterator; say $b.pull-one; }; a(1..10)

[18:10] <camelia> rakudo-moar be13af: OUTPUT«1␤»

[18:11] <thou> lizmat: I was just going to tweak that to say "It is only .cache that may be called *more than* once"

[18:11] <thou> Which I believe is a clarification worth keeping?

[18:11] <lizmat> thou: go ahead  :-)

[18:11] <lizmat> it is better that way, indeed

[18:12] <dalek> specs: 354bef8 | (Tim Smith)++ | S07-lists.pod:

[18:12] <dalek> specs: Clarify calling .cache more than once

[18:12] <dalek> specs: review: https://github.com/perl6/specs/commit/354bef8e98

[18:15] <lizmat> really dinner&

[18:15] <colomon> anyone on channel understand how to detect IterationEnd?

[18:16] <colomon> $p =:= IterationEnd  from jnthn’s gist doesn’t seem to cut it.

[18:18] * colomon seems to recall having had this problem at SPW, too.

[18:19] <nine> colomon: that's exactly how you'd check

[18:19] <yoleaux> 13:58Z <raiph> nine: https://www.reddit.com/r/perl/comments/3k4r7t/larry_wall_presents_perl_6/cuwx9rh

[18:20] <nine> colomon: but you _have_ to use binding when pull-one to $p

[18:20] <colomon> nine: it really doesn’t seem to be working for me.

[18:20] <timotimo> .tell brrt what's "quite high-level talk, so I hereby promise that if any Oh, and I just " all about? %)

[18:20] <yoleaux> timotimo: I'll pass your message to brrt.

[18:20] <nine> I always use sigilless variables when dealing with those iterators

[18:20] <colomon> nine: yeah, I noticed that in some of the src/core — but some of src/core uses $

[18:21] <nine> The := is the important part.

[18:21] <colomon> oh!

[18:21] <nine> sigilless just forces me to use binding and makes it clear, that there's something special going on

[18:21] <colomon> nine++

[18:22] <colomon> nine: is sigilless always implicitly :=  ?

[18:22] <colomon> because I changed to sigilless but not explicitly binding and the code started working

[18:22] <nine> colomon: yes

[18:23] <colomon> nine++

[18:23] * colomon hopes he’ll remember that next time.  :)

[18:23] <nine> A sigilless variable is no container that can be assigned to, so it really binds regardless of the operator

[18:24] *** fling left
[18:27] <colomon> \o/

[18:30] *** fling joined
[18:33] * colomon has Math::ContinuedFractions not… working, but at least passing its limited tests again.  :)

[18:33] *** Alina-malina left
[18:33] <colomon> not that it ever really worked

[18:34] <cognominal> why the syntax does not impose the :=  for sigiless binding? If only for pedagogical purpose.

[18:35] *** Alina-malina joined
[18:35] *** n0tjack joined
[18:39] <nine> cognominal: I'd +1 that. I had to ask moritz++ if there was some difference

[18:40] <pmurias> any suggestion for a good book about neural networks?

[18:40] *** n0tjack left
[18:44] *** rurban joined
[18:49] <dalek> roast: a046d74 | TimToady++ | S03-operators/context-forcers.t:

[18:49] <dalek> roast: test new list/cache listops

[18:49] <dalek> roast: review: https://github.com/perl6/roast/commit/a046d74488

[18:49] <dalek> rakudo/nom: cdd0372 | TimToady++ | src/Perl6/Actions.nqp:

[18:49] <dalek> rakudo/nom: @$var contextualizer should use .cache, not .list

[18:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cdd0372df4

[18:49] <dalek> rakudo/nom: 10c7f18 | TimToady++ | src/core/List.pm:

[18:49] <dalek> rakudo/nom: use one-arg for list listop; add cache listop too

[18:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/10c7f1848f

[18:50] *** kjs__ joined
[18:51] <psch> m: say 97.base(2)

[18:51] <camelia> rakudo-moar be13af: OUTPUT«1100001␤»

[18:52] <TimToady> cognominal: well, the pseudo-assignments all make their own rules for what = means; we don't require := in constants either, and that's binding

[18:53] <cognominal> that could be construed as an argument for := in constants

[18:53] *** mohij joined
[18:55] <TimToady> well, it's not exactly binding there either, more definitional, I hope

[18:55] <cognominal> so we must live with = being vastly polysemic :)

[18:56] <psch> FROGGS_: i'm a bit confused about Ops.spawn()

[18:56] <mohij> @ugexe, tadzik: I did not intend to break backwards compatibility with rakudobrew. The new init thing is entirely optional and only required for the "shell" subcommand. I do wonder why travis broke. Is there some chance for me to see the output? I'd like to fix that. :-)

[18:56] <psch> FROGGS_: when capturing any of IN, OUT, ERR, there's no waiting for the thread that executes going on

[18:57] <psch> FROGGS_: i'm not sure that's why it always error, but it does... :)

[18:57] <FROGGS_> psch: I think it starts it is some cases immediately, so you can chain processes

[18:58] <FROGGS_> it in*

[18:58] <psch> FROGGS_: right, it starts immediately if we don't capture any of the STD*s

[18:59] <psch> FROGGS_: but it doesn't wait when it does capture them

[18:59] <psch> (according to Ops.java:1040-1064)

[18:59] <FROGGS_> hmmm

[19:00] <psch> fwiw:

[19:00] <psch> n$ ./perl6-j -e'say qx[echo hi]'

[19:00] <psch> Unable to execute 'echo hi'

[19:00] <psch> s/^n//

[19:00] <mohij> wrt Windows, that is not implemented yet. Sorry for breaking it for some of you guys. :( I will probably have more tuits on Monday evening to fix that.

[19:00] <FROGGS_> but that did work previously... I'm almost sure about that

[19:00] <psch> and "Unable to execute" comes from Proc.pm

[19:01] <psch> whenever we have a !0 exit code

[19:01] <dalek> specs: acc4605 | moritz++ | S07-lists.pod:

[19:01] <dalek> specs: S07: Fix small introspection details

[19:01] <dalek> specs: review: https://github.com/perl6/specs/commit/acc4605bad

[19:02] <psch> oh

[19:02] <psch> i think Proc.pm might be at fault here

[19:02] <psch> the line that's dying is from a190b23bf9d81d84670a36ad448280ec8941144e

[19:03] <psch> hm, but that's over a month old as well...

[19:03] *** darutoko left
[19:03] <dalek> roast: d14535b | TimToady++ | S32-scalar/undef.t:

[19:03] <dalek> roast: remove a couple of test fossils

[19:03] <dalek> roast: review: https://github.com/perl6/roast/commit/d14535b5d5

[19:07] *** kjs__ left
[19:08] <FROGGS_> psch: but that seems wrong

[19:08] <FROGGS_> psch: the condition to fail there should consider capturing etc

[19:08] <FROGGS_> psch: so that it doesnt fail() there when the program has not started yet

[19:08] *** n0tjack joined
[19:09] <psch> FROGGS_: yeah, the fail there is definitely over-eager

[19:09] <FROGGS_> aye

[19:10] <psch> FROGGS_: i'm thinking just removing the first &fail call in QX, not completely confident about it though

[19:11] <FROGGS_> hmmmm... test it?

[19:11] <FROGGS_> I've not enough brain atm to guess the consequences

[19:11] <psch> FROGGS_: well, it seems to work :P

[19:12] <psch> FROGGS_: i was just thinking that japhb probably had a reason to put it there in the first place, and i can't guess the reason

[19:12] <FROGGS_> psch: yes, the commit lacks some explanation

[19:13] *** n0tjack left
[19:13] <psch> without that line i don't get a spawn failure.  i'd guess that the first fail is some kind of relic that needn't be commit, and the .DEFINITE is what actually fixed the bug...

[19:13] <psch> (spawn failure for /bin/false that is)

[19:14] <psch> anyway, yeah, i'll just remove the line and test on moar once more as well, 'cause backend discrimination can only work against jvm currently, with christmas and all coming up... ;)

[19:22] <FROGGS_> :o)

[19:26] <masak> cognominal: I'm fine with `=` being polysemic, as long as the polysemy works towards Least Surprise.

[19:26] <masak> cognominal: for example, the `=` on a `has` means "at instantiation time". which I like.

[19:27] <masak> cognominal: the `=` on a parameter means "at siggie binding time". also nice.

[19:27] <masak> cognominal: the `=` on a constant means, "this ain't gonna change, so := it". not bad.

[19:29] <dalek> rakudo/nom: 509624b | peschwa++ | src/core/Proc.pm:

[19:29] <dalek> rakudo/nom: Don't &fail out of QX before at least looking for the retval.

[19:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/509624be5a

[19:30] <cognominal> my expectation was that = was setting/user-defined polysemy, not polysemy within the language. I just need to adjust my expectation that does not match the reality.

[19:31] * TimToady is in the process of extirpating the term "parcel" in favor of "raw" (or sometimes "list" in comments)

[19:32] <TimToady> any 'is parcel' will have to change to 'is raw'

[19:33] <dalek> doc: 9d78199 | moritz++ | lib/Type/Iterator.pod:

[19:33] <dalek> doc: Bring Iterator docs up to date

[19:33] <dalek> doc: review: https://github.com/perl6/doc/commit/9d78199f0f

[19:33] <moritz> .tell jnthn I've documented the Iterator/Iterable interface to the best of my knowledge in perl6/doc; feel free to steal anything you like for S07.

[19:33] <yoleaux> moritz: I'll pass your message to jnthn.

[19:36] <dalek> doc: 30634e9 | moritz++ | lib/Type/Iterator.pod:

[19:36] <dalek> doc: Forgot Iterator.push-all

[19:36] <dalek> doc: review: https://github.com/perl6/doc/commit/30634e9767

[19:36] <cognominal> TimToady, about extirpating parcels, there is a pull request.   https://github.com/rakudo/rakudo/pull/526

[19:36] *** nowan_ joined
[19:37] <dalek> rakudo/nom: e0fc14d | TimToady++ | src/ (13 files):

[19:37] <dalek> rakudo/nom: change 'parcel' to 'raw' or 'list', depending

[19:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e0fc14d37c

[19:37] <dalek> roast: 86326e8 | TimToady++ | / (19 files):

[19:37] <dalek> roast: change 'parcel' to 'raw' or 'list', depending

[19:37] <dalek> roast: 

[19:37] <dalek> roast: The trait is now 'is raw'.  The rest of the time it's just

[19:37] <dalek> roast: referring to lists.

[19:37] <dalek> roast: review: https://github.com/perl6/roast/commit/86326e8fc2

[19:38] *** nowan left
[19:39] *** nowan_ left
[19:41] *** n0tjack joined
[19:41] *** thundergnat joined
[19:41] <TimToady> cognominal: that's sort of sideways to my patch, dunno if it'll merge now

[19:42] <TimToady> but for sure we don't use \| parameters currently

[19:42] *** nowan joined
[19:43] <cognominal> TimToady, ok

[19:46] <ugexe> mohij: it seems the shim is not getting installed to ~/.rakudobrew/bin after doing 'rakudobrew build XXX', which before would happen if no shims were present / CURRENT was empty

[19:46] *** n0tjack left
[19:46] <mohij> ugexe: Ah, thanks for the hint. Sounds easy to fix.

[19:48] <psch> heh, the QX patch fixed more than one test file :)

[19:48] <thundergnat> m: sub h () { return }; if my @p = h() { say @p } # Bug or Spec? Should a bare return return Any? It didn't used to pre GLR. 

[19:48] <camelia> rakudo-moar e0fc14: OUTPUT«[(Any)]␤»

[19:48] * timotimo has returned from a day of socializing and festivities and has backlogged on irc and watched almost all of lw's yapc::eu keynote

[19:49] <thundergnat> star: sub h () { return }; if my @p = h() { say @p } 

[19:49] <camelia> star-m 2015.03: ( no output )

[19:49] <psch> the keynote is great, TimToady++

[19:51] *** n0tjack joined
[19:51] *** cognominal left
[19:51] <timotimo> finished. very good!

[19:52] <timotimo> i'm glad larry came back in the end after the hatless dude did all the talking for him

[19:52] *** kurahaupo_ joined
[19:53] <TimToady> whether I wear the hat usually depends on whether the lighting is high or low, and I rely on Glo to tell me which looks better

[19:54] <timotimo> :)

[19:54] <TimToady> in this case the lighting was high, so nobody coulda seen my face if I'd worn the hat

[19:56] <FROGGS_> a keynote? what keynote?

[19:56] <FROGGS_> is there a linky to a video?

[19:57] <psch> FROGGS_: https://www.youtube.com/watch?v=RvCkvXvqi3U

[19:57] <FROGGS_> ohh!

[19:57] <FROGGS_> psch: thank you!

[19:58] <psch> i'll admit, it made me a bit sentimental towards the end :S

[19:58] <FROGGS_> *g*

[19:58] <psch> probably partly because of tolkien, although the delivery definitely counts for something as well :)

[19:59] <FROGGS_> I've seen the talk at the fosdem, and was sad it wasnt recorded properly... so I am happy to watch it again :o)

[19:59] <dalek> doc: d56204f | moritz++ | lib/Type/ (2 files):

[19:59] <dalek> doc: Move pop,push,{un,}shift from List to Array

[19:59] <dalek> doc: review: https://github.com/perl6/doc/commit/d56204fbf3

[19:59] <TimToady> I think it was much better for having been rewritten twice this time

[20:01] *** n0tjack left
[20:06] <masak> what, Perl 6? :P

[20:06] <masak> *rimshot*

[20:08] *** n0tjack joined
[20:08] <moritz> m: say List.^mro

[20:08] <camelia> rakudo-moar e0fc14: OUTPUT«((List) (Cool) (Any) (Mu))␤»

[20:17] <dalek> doc: 994d37d | moritz++ | lib/ (13 files):

[20:17] <dalek> doc: Mostly get rid of Parcel

[20:17] <dalek> doc: review: https://github.com/perl6/doc/commit/994d37d481

[20:20] <dalek> doc: 8d6195d | moritz++ | lib/Type/Whatever.pod:

[20:20] <dalek> doc: s/Parcel/List/

[20:20] <dalek> doc: review: https://github.com/perl6/doc/commit/8d6195d810

[20:21] *** n0tjack left
[20:21] <mohij> ugexe: I think I have a fix. Currently testing. Do you think this was the reason for travis failing?

[20:22] *** cognominal joined
[20:22] <moritz> m: say ('a', <b c d e>.Slip, 'f')[2]

[20:22] <camelia> rakudo-moar e0fc14: OUTPUT«c␤»

[20:25] *** yqt joined
[20:39] *** n0tjack joined
[20:43] *** Skarsnik joined
[20:48] *** n0tjack left
[20:48] <dalek> nqp: 6df5fc4 | timotimo++ | src/vm/moar/HLL/Backend.nqp:

[20:48] <dalek> nqp: also write final pieces for json profiles

[20:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6df5fc4e0d

[20:51] *** xfix left
[20:53] *** n0tjack joined
[20:53] *** telex left
[20:54] <dalek> rakudo/nom: 8837b6f | TimToady++ | src/core/ (8 files):

[20:54] <dalek> rakudo/nom: s/rw/raw/ on slurpies

[20:54] <dalek> rakudo/nom: 

[20:54] <dalek> rakudo/nom: It doesn't make sense to call 'is rw' on slurpies, since 'rw' is supposed

[20:54] <dalek> rakudo/nom: to guarantee a valid lvalue.  These are now just 'is raw' (what used to

[20:54] <dalek> rakudo/nom: be 'is parcel'), which is more in line with what is wanted.  In other words,

[20:54] <dalek> rakudo/nom: whether the arg is an lvalue or not depends entirely on whether you passed one.

[20:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8837b6fe0a

[20:54] <dalek> rakudo/nom: a032e5b | TimToady++ | src/Perl6/ (2 files):

[20:54] <dalek> rakudo/nom: also rw -> raw in the binder, duh

[20:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a032e5b06e

[20:54] *** telex joined
[20:54] <dalek> roast: 8eaee5e | TimToady++ | S0 (3 files):

[20:54] <dalek> roast: change 'is rw' to 'is raw' on slurpies

[20:54] <dalek> roast: 

[20:54] <dalek> roast: 'is rw' will break when we decide to enforce lvaluehood.

[20:54] <dalek> roast: review: https://github.com/perl6/roast/commit/8eaee5e4dc

[20:59] <TimToady> at the moment it allows either rw or raw on slurpies, but I suppose we could sanely reject rw for now

[20:59] *** n0tjack left
[21:03] *** n0tjack joined
[21:06] *** kaare_ left
[21:09] *** n0tjack left
[21:09] *** Sgeo_ joined
[21:10] *** n0tjack joined
[21:11] *** Sgeo left
[21:13] *** leont left
[21:15] *** n0tjack left
[21:23] <dalek> nqp: c16481c | TimToady++ | src/HLL/ (2 files):

[21:23] <dalek> nqp: hack in perl methods so P6's eqv doesn't blow

[21:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c16481c6ee

[21:24] <dalek> rakudo/nom: 783c5ae | TimToady++ | tools/build/NQP_REVISION:

[21:24] <dalek> rakudo/nom: bump nqp rev to "fix" eqv

[21:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/783c5aeddd

[21:25] *** espadrine left
[21:25] *** mohij left
[21:26] <TimToady> that at least shuts up adverbs.t now

[21:28] *** Khisanth left
[21:31] *** n0tjack joined
[21:33] <mprelude> OK so... noob question... is there anything special I have to do to use a perl5 lib in perl6?

[21:33] <mprelude> or is it 100% back compatible

[21:33] <mprelude> ?

[21:33] *** Alina-malina left
[21:35] *** n0tjack left
[21:37] *** ab5tract_ joined
[21:37] *** Khisanth joined
[21:38] <FROGGS_> TimToady++ # that was a great talk

[21:39] *** spider-mario left
[21:39] <FROGGS_> mprelude: you need to use Inline::Perl5

[21:40] <FROGGS_> gnight companions

[21:42] *** ab5tract_ left
[21:44] *** BenGoldberg joined
[21:46] *** n0tjack joined
[21:48] <dalek> roast: b9c81f9 | TimToady++ | S02-literals/adverbs.t:

[21:48] <dalek> roast: unfudge passing todos

[21:48] <dalek> roast: review: https://github.com/perl6/roast/commit/b9c81f9dac

[21:48] <TimToady> nap 

[21:51] *** Skarsnik left
[21:54] *** thundergnat left
[21:56] *** n0tjack left
[21:57] *** n0tjack joined
[21:57] <psch> m: my ::foo $x, say $x

[21:57] <camelia> rakudo-moar 783c5a: OUTPUT«Method 'gist' not found for invocant of class 'foo'␤  in block <unit> at /tmp/Piq71761s2:1␤␤»

[21:58] <psch> ^^^ that gives a SOE on jvm...

[21:58] <psch> with the same new, new, bless, BUILDALL loop before arriving in EXCEPTION and dying

[21:59] <psch> (i'm honestly not even sure what the code is supposed to *mean*...)

[21:59] <_itz> whats "is raw"?

[22:00] <psch> _itz: the replacement for "is parcel"

[22:01] *** n0tjack left
[22:01] <psch> _itz: it's a trait for parameters, the short hand is \ iirc

[22:02] <psch> as in, sub f ($foo is raw) <=> sub f (\$foo)

[22:03] <psch> _itz: http://irclog.perlgeek.de/perl6/2015-09-08#i_11183857

[22:04] <_itz> thanks

[22:05] <psch> _itz: non-named parameters usually leave the sigil out, fwiw

[22:05] <psch> m: sub f(:\foo) { }

[22:05] <camelia> rakudo-moar 783c5a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PW3zcit8D6␤Malformed parameter␤at /tmp/PW3zcit8D6:1␤------> 3sub f(:7⏏5\foo) { }␤    expecting any of:␤        formal parameter␤        named parameter␤»

[22:05] <psch> std: sub f(:\foo) { }

[22:05] <camelia> std 28329a7: OUTPUT«ok 00:00 138m␤»

[22:05] <ugexe> timotimo: whats that json profile thing for?

[22:05] * psch goes to rakudobug that

[22:07] <psch> ugexe: the json generated by the profiler was apparently malformed and "the qt profiler" (i don't know which one..) choked on that

[22:07] <psch> (via #perl6-gaming)

[22:08] <ugexe> i see

[22:08] <psch> i'm guessing json and html output from the profiler aren't generated the same way, which could've prompted such a bug

[22:09] <psch> hrm, RT is slow :(

[22:10] <psch> gaah

[22:10] <psch> stupid java with its stupid inheritance

[22:11] <psch> i want to catch an explicit IllegalArgumentException, why is NumberFormatException even a subtype of that

[22:11] *** cognominal left
[22:13] *** n0tjack joined
[22:16] <psch> .tell FROGGS if you're looking for a great WAT try the following three things on jvm: 

[22:16] <yoleaux> psch: I'll pass your message to FROGGS.

[22:16] <psch> .tell FROGGS_ 1) assign a <> quoted list of the int literals from 0 to 250 to an array

[22:16] <yoleaux> psch: I'll pass your message to FROGGS_.

[22:17] <psch> .tell FROGGS_ 2) assign a <> quoted list of the int literals from 0 to 251 to an array

[22:17] <yoleaux> psch: I'll pass your message to FROGGS_.

[22:17] <psch> .tell FROGGS_ 3) assign a <> quoted list of the int literals from 0 to 252 to an array

[22:17] <yoleaux> psch: I'll pass your message to FROGGS_.

[22:18] <psch> .tell FROGGS_ just to be clear, that is "<0 1 2 3 ... 248 249 250>" all typed (or generated of course :) ) literally in the program code 

[22:18] <yoleaux> psch: I'll pass your message to FROGGS_.

[22:18] *** pmurias left
[22:18] <psch> (spoiler: jvm has a method argument limit of 255, which is causing a spec test failure in WHICH.t, because we have over 255 built-in types...)

[22:19] <psch> ugh

[22:19] <psch> i notice i should have either removed all _ or none of them :/

[22:19] *** coffee` left
[22:19] <psch> .tell FROGGS (the actual three things are .tell

[22:20] <psch> .tell FROGGS .tell'd to FROGGS_ )

[22:20] <psch> vOv

[22:20] * psch pokes yoleaux 

[22:20] *** cschwenz left
[22:22] <yoleaux> psch: I'll pass your message to FROGGS.

[22:22] <yoleaux> psch: I'll pass your message to FROGGS.

[22:24] *** TEttinger joined
[22:25] *** vendethiel joined
[22:28] <lizmat> mprelude: Inline::Perl5

[22:29] <lizmat> oops, looking at stale backlog  :-)

[22:35] *** n0tjack left
[22:45] *** rindolf left
[22:49] *** n0tjack joined
[22:49] <TimToady> .tell nine re http://irclog.perlgeek.de/perl6/2015-09-12#i_11206412 there were more than 200 instances of .list in the pre-cache era that didn't actually need to set up the cache but did so accidentally, so it's a good thing for performance that .list no longer does that

[22:49] <yoleaux> TimToady: I'll pass your message to nine.

[22:54] *** n0tjack left
[22:56] <masak> 'night, #perl6

[22:56] <TimToady> o/

[23:00] <TimToady> .tell jnthn the specced syntax you were looking for is 'when * -> $a, $b, *@c { ... }' but that's not implemented yet

[23:00] <yoleaux> TimToady: I'll pass your message to jnthn.

[23:03] *** yqt left
[23:15] *** lizmat left
[23:17] *** lizmat joined
[23:17] *** khw joined
[23:21] *** n0tjack joined
[23:24] *** rurban left
[23:30] *** aborazmeh joined
[23:30] *** aborazmeh left
[23:30] *** aborazmeh joined
[23:31] *** n0tjack left
[23:38] <ugexe> i've been getting a double memory free error about 50% of the time for this bit of code that never had that problem approximately a week ago: `my $d = buf8.new(data) andthen emit($_);` whereas if i split it into `my $d = buf8.new(data); emit($d)` it does not happen

[23:45] <psch> m: my $d = buf8.new(data) andthen emit($_);

[23:45] <camelia> rakudo-moar 783c5a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Oumk3dbQsB␤Undeclared routine:␤    data used at line 1␤␤»

[23:45] <psch> m: my $d = buf8.new(1, 2) andthen emit($_);

[23:45] <camelia> rakudo-moar 783c5a: ( no output )

[23:45] <psch> m: my $d = buf8.new(1, 2) andthen emit($_);

[23:45] <camelia> rakudo-moar 783c5a: ( no output )

[23:45] <psch> m: my $d = buf8.new(1, 2) andthen emit($_);

[23:45] <camelia> rakudo-moar 783c5a: ( no output )

[23:46] <psch> ugexe: i suppose rakudobug it with a stracktrace, and maybe ping jnthn 

[23:47] <psch> although he probably has enough on his TODO...

[23:54] *** n0tjack joined
[23:57] <ugexe> when i --ll-exception it just says Segmentation fault or nothing at all. some more inspection is leading me to think its the line *after*, LAST { done() }, and that somehow splitting that previously mentioned line prevents the bug from manifesting itself

[23:59] <ugexe> while $.recv(:bin) -> \data { my $d = buf8.new(data) andthen emit($_); LAST { done() }; } # removing the LAST and moving the done() to outside the loop seems to be the proper fix

[23:59] *** colomon left
[23:59] *** n0tjack left
