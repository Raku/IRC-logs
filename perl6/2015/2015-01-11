[00:04] <andreoss> raydiak: reported

[00:07] <raydiak> andreoss++

[00:08] *** raiph left
[00:13] <timotimo> Cannot find method 'value'

[00:13] <timotimo>    at src/Perl6/World.nqp:651  (blib/Perl6/World.moarvm:install_lexical_container:376)

[00:13] <timotimo> i wonder how i did that

[00:14] <timotimo> seems like my $_ = ... in a block did that

[00:15] <raydiak> m: for ^3 { my $_ = "foo"; .say }

[00:15] <camelia> rakudo-moar 8f447f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/qjZQlordFN:1␤    ------> [32mfor ^3 { my $_ [33m⏏[31m= "foo"; .say }[0m␤Cannot assign to an immutable value␤  in block <unit> at /tmp/qjZQlordFN:1␤␤»

[00:16] <raydiak> m: do { my $_ = "foo"; .say }

[00:16] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[00:16] <raydiak> m: do { my $_ }

[00:16] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[00:16] <raydiak> m: { my $_ }

[00:16] <camelia> rakudo-moar 8f447f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/zPA58pBXMj:1␤    ------> [32m{ my $_ [33m⏏[31m}[0m␤»

[00:16] <raydiak> m: -> { my $_ }

[00:17] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[00:17] <raydiak> m: { my $_ },

[00:17] <camelia> rakudo-moar 8f447f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/kAJiU0iva0:1␤    ------> [32m{ my $_ [33m⏏[31m},[0m␤»

[00:17] <raydiak> m: -> { my $/ }

[00:17] <camelia> rakudo-moar 8f447f: ( no output )

[00:17] *** kjs_ joined
[00:19] <raydiak> m: .say

[00:19] <camelia> rakudo-moar 8f447f: OUTPUT«Nil␤»

[00:22] *** adu left
[00:23] *** broski left
[00:25] <psch> m: { temp $_ = "foo" }

[00:25] <camelia> rakudo-moar 8f447f: ( no output )

[00:26] <psch> m: { my $_ = "foo" }

[00:26] <camelia> rakudo-moar 8f447f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/BFXaizliST:1␤    ------> [32m{ my $_ [33m⏏[31m= "foo" }[0m␤»

[00:29] *** leont joined
[00:33] <timotimo> Failed to open pipe: 12

[00:33] <timotimo> in QX

[00:33] <psch> timotimo: i hope you're also golfing and ticketing ;)

[00:34] <timotimo> no energy right now

[00:34] <timotimo> this is from a locally modified spesh_diff.p6

[00:34] <timotimo> but the changes shouldn't give me trouble ...

[00:34] <timotimo> i shall add some debug output

[00:43] *** colomon left
[00:44] *** ssutch left
[00:50] *** virtualsue left
[00:51] *** colomon joined
[00:51] *** Rounin joined
[00:54] <timotimo> cannot figure it out

[00:56] <geekosaur> ENOMEM...

[00:57] *** kjs_ left
[00:57] <timotimo> oh?

[00:57] <geekosaur> if that's an OS errno

[00:58] <geekosaur> but the only place I can think of that could generate that other than synthetically via malloc() is fork() in which case it means you're out of virtual memory

[00:59] <geekosaur> which seems moderately unlikely since it would be rather obvious from more than just p6

[01:02] *** andreoss left
[01:09] *** [Sno] left
[01:11] *** cognominal left
[01:14] *** BenGoldberg left
[01:23] *** adu joined
[01:23] *** adu left
[01:24] *** raiph joined
[01:28] *** BenGoldberg joined
[01:31] *** BenGoldberg left
[01:32] *** BenGoldberg joined
[01:40] *** Mso150 left
[01:41] *** Mso150 joined
[01:41] *** adu joined
[01:56] *** adu left
[02:20] *** leont left
[02:23] *** rmgk_ joined
[02:23] *** rmgk left
[02:23] *** rmgk_ is now known as rmgk

[02:27] *** kaare__ joined
[02:33] *** adu joined
[02:33] <adu> what's the difference between associative_bind and bindkey?

[02:36] <adu> and positional_get and atpos?

[02:46] *** colomon left
[02:48] <Timbus> associative_bind and positional_get appear to be NQP ops

[02:49] <Timbus> uh, or more like VM ops

[02:52] *** gfldex left
[02:54] *** colomon joined
[02:58] * vendethiel was confused for a moment

[03:02] * colomon is usually confused longer than that

[03:08] *** Mouq joined
[03:08] *** Mso150_i joined
[03:09] *** Mso150 left
[03:09] *** dj_goku_ joined
[03:10] *** dj_goku left
[03:18] *** jakesyl_insomnia left
[03:20] *** jakesyl_insomnia joined
[03:30] *** noganex joined
[03:30] *** amkrankruleuen left
[03:31] *** djruffkutz joined
[03:32] *** djruffkutz left
[03:33] *** noganex_ left
[03:39] *** dj_goku_ left
[03:41] <adu> what does SCWB mean?

[03:43] *** dj_goku joined
[03:43] *** dj_goku left
[03:43] *** dj_goku joined
[04:20] *** raiph left
[04:25] *** Mso150_i_q joined
[04:26] *** Mso150_i left
[04:26] *** skids left
[04:29] *** ggoebel111111112 left
[04:30] *** ggoebel111111112 joined
[04:40] *** skids joined
[04:46] *** dj_goku left
[04:49] *** dj_goku joined
[05:04] *** vendethiel left
[05:10] *** dj_goku left
[05:21] *** sirdancealot joined
[05:23] *** davido_ left
[05:24] *** dj_goku joined
[05:24] *** dj_goku left
[05:24] *** dj_goku joined
[05:24] *** davido_ joined
[05:44] *** KCL_ joined
[05:52] *** telex left
[05:54] *** Mouq left
[05:54] *** telex joined
[05:58] *** dj_goku_ joined
[05:58] *** dj_goku left
[05:59] *** xinming left
[06:00] *** xinming joined
[06:07] *** IllvilJa left
[06:09] *** BenGoldberg left
[06:09] *** IllvilJa joined
[06:09] *** skids left
[06:13] *** Mso150_i_q left
[06:18] *** skids joined
[07:46] *** xfix joined
[07:48] *** berekuk joined
[07:54] *** skids left
[08:01] *** berekuk left
[08:04] *** berekuk joined
[08:04] *** berekuk left
[08:10] *** darutoko joined
[08:13] *** novice666 joined
[08:18] <novice666> what is the mechanism of incrementing immutable variable $ in oneliner perl6 -ne '  say ++$  ' file.txt ?

[08:19] *** mr-foobar left
[08:25] <moritz> novice666: it's not immutable, it's just anonymous

[08:26] <moritz> but, uhm, does that even work?

[08:27] <moritz> seems it does

[08:27] *** lumimies left
[08:27] <moritz> it's weird, I'd have though you have to declare it first

[08:27] <moritz> --target=ast says it generates lexical $ANON_VAR__1

[08:27] <moritz> for the $

[08:28] <moritz> novice666: does that answer your question?

[08:28] *** mr-foobar joined
[08:30] *** ugexe left
[08:31] *** ugexe joined
[08:36] <JimmyZ> m: $; my $b;

[08:36] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[08:36] <JimmyZ> m: my $; my $b;

[08:36] <camelia> rakudo-moar 8f447f: ( no output )

[08:39] *** virtualsue joined
[08:49] <adu> do you see anything wrong with this? http://pastie.org/9825136

[08:51] <moritz> adu: that's Perl 6 code (not NQP), right?

[08:51] <moritz> well, the indentation of the 'make' line is off

[08:51] <JimmyZ> @<pointer>?

[08:52] <JimmyZ> you mean @$<pointer>?

[08:52] <moritz> m: 'ab' ~~ /$<a>=(.)+/; .say for @<a>

[08:52] <camelia> rakudo-moar 8f447f: OUTPUT«｢a｣␤｢b｣␤»

[08:53] <moritz> JimmyZ: @<pointer> is a valid shortcut

[08:53] <adu> moritz: yes

[08:53] <JimmyZ> ah, I didn't know it ..

[08:53] <adu> JimmyZ: I don't know if that's what I mean

[08:53] <adu> I've never seen @$ before

[08:55] <JimmyZ> m: my $@a = [ 3, 5]; say %@a;

[08:55] <camelia> rakudo-moar 8f447f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/sQkFxNVcBf␤Cannot declare a variable by indirect name (use a hash instead?)␤at /tmp/sQkFxNVcBf:1␤------> [32mmy $[33m⏏[31m@a = [ 3, 5]; say %@a;[0m␤»

[08:55] <JimmyZ> m: my @a =  3, 5; say %@a;

[08:55] <camelia> rakudo-moar 8f447f: OUTPUT«3 => 5␤»

[08:56] <moritz> adu: ah, one thing that's wrong is that the recursion into $ast doesn't seem to terminate anywhere

[08:56] <adu> moritz: so the behaviour I'm seeing is that if I have a pointer ("char * s"), then it runs forever, but if I dont ("char c"), then it parses pretty quick

[08:57] <moritz> adu: but it would be much easier to help if you'd tell us why you suspect something might be wrong

[08:58] <moritz> yes, the recursion into $ast would explain that

[08:58] <adu> but it's not recursion

[08:58] <adu> it's a completely different ast

[08:58] <moritz> $ast = -> $type, $init { $ast($pointer($type), $init) }

[08:59] <moritz> there are two occurences of $ast here. They refer to the same object.

[08:59] <adu> maybe if I do 2 of them $ast2 = -> ... {}; $ast = $ast2?

[08:59] <moritz> Thus, recursion

[09:00] <moritz> yes, you need a separate lexical for it to work as a closure

[09:00] <adu> I thought {} did that?

[09:00] <moritz> {} creates a block and thus a scope

[09:01] <moritz> but not a new lexical

[09:01] <moritz> 'my' does that

[09:02] <adu> how do I accomplish this?

[09:03] <adu> maybe I could call make instead?

[09:05] <moritz> my $wrapped = $ast; $ast = -> $type, $init { $wrapped($pointer($type), $init) }

[09:06] <moritz> adu: but are you sure all of those need to be callables? they aren't as nicely debuggable as other data structures

[09:07] <adu> if you can find a better at to pass info from one end of the grammar to the other end, I'm all ears

[09:08] <moritz> well, make() already gives you that capability

[09:08] <adu> ok, but can I call make multiple times?

[09:08] <moritz> well, the last one will take effect

[09:09] <moritz> fwiw I'm not talking just about this one action sub

[09:09] <moritz> erm, method

[09:09] <moritz> I wonder why you seem to passing callables as code objects everywhere

[09:09] <moritz> want multiple values? make() an array

[09:09] <adu> s/at/way/

[09:10] <adu> ok, but an array of [a, b, c] will still have to be turned into a(b(c(x))) at some point

[09:10] <moritz> why? why must a, b and c be callables?

[09:11] <adu> moritz: the alternative is to find a way to insert the current declaration specifiers in the parameterized types encountered later on

[09:12] <moritz> why not simply a class Pointer { has $.pointee } or something like that?

[09:12] <adu> because the fact that it's a pointer, and the type of the pointee are in two separate locations of the grammar

[09:13] <moritz> I don't see the problem

[09:13] <moritz> Pointer.new(pointee => $other.ast)

[09:13] <adu> $.pointee comes from $<declaration-specifiers>, which doesn't know about pointers, and $<pointer> doesn't know about the other

[09:14] <moritz> adu: I think I'd have to see the whole source code to be able to discuss this properly

[09:14] <adu> moritz: I would love to do that, but both pieces of information are not available until $<declaration>

[09:14] <adu> https://github.com/andydude/p6-c-parser/blob/master/lib/C/Parser/StdC11Parser.pm6

[09:14] <adu> so that's the grammar

[09:15] *** jack_rabbit left
[09:16] <adu> I have 2 action classes, CASTActions, and DROXActions, and both action classes have a similar issue, but I kind of gave up on CAST for right now, so I am currently trying out the function/block/lambda idea with DROXActions

[09:19] * moritz can't find any DROXActions

[09:20] <adu> https://github.com/andydude/droxtools/blob/master/c2drox-perl6/lib/C/DROXActions.pm6

[09:20] <adu> it's in a different repo because it has nothing to do with general C parsing

[09:22] *** molaf__ joined
[09:22] <adu> moritz: the CAST is very OOP, iirc it does have a Pointer class as you described

[09:26] *** molaf_ left
[09:28] <adu> but if the function/block/lambda idea works, I'd like to do the same thing with CASTActions

[09:35] *** denis_boyun_ joined
[09:36] <adu> I was actually discussing this with raydiak a couple days ago

[09:37] <adu> I was saying that I wanted 2 ASTs, one that represents syntax, and one that represents symantics

[09:37] <adu> and raydiak said that I should have one AST and do the transformations in the actions

[09:39] <moritz> or simply add another transformation stage for syntax tree -> sematnic tree

[09:40] <adu> is that easy?

[09:40] <masak> bzzt. guten antenoon, #perl6.

[09:40] <adu> hi masak

[09:41] <masak> what does it mean for an AST to "represent semantics"?

[09:42] <moritz> it becomes an Abstract Semantic Tree :-)

[09:42] <masak> well, that clears that up...

[09:42] *** mr-foobar left
[09:43] <adu> masak: well, the issue is with C declarations. they are generally of the form: <declaration-specifier>+ [[<declarator> ['=' <initializer>]?]* % ',']

[09:44] <adu> the declaration-specifiers form a complete type.

[09:45] <adu> but the declarators can be of the form myArray[2][3][4] or myFunc(double, double) or myArrayFunc(double)[3] or myFuncArray[3](double), etc.

[09:45] <masak> with you so far.

[09:46] <masak> sounds like a kind of expression parsing, if you ask me.

[09:46] <adu> the "complete type" for the entire declaration must combine information from the declaration-specifiers with information about whether or not it's an array, function, pointer etc from later in the grammar

[09:46] <moritz> wait

[09:47] <moritz> what piece of information exactly comes from later in the grammer?

[09:47] <adu> moritz: -> $type { Pointer.new(pointee => $type) }

[09:47] <adu> the $type comes from the declaration-specifiers

[09:48] <moritz> adu: in terms of syntax, please

[09:48] <moritz> myArrayFunc(double)[3]

[09:48] <moritz> which piece of information about that comes from later in the grammer?

[09:48] <moritz> *grammar

[09:49] <adu> moritz: myArrayFunc comes from direct-declarator-first:sym<identifier>

[09:50] <adu> moritz: (double) comes from direct-declarator-rest:sym<p-parameter-type-list>

[09:50] <adu> moritz: and [3] comes from direct-declarator-rest:sym<b-assignment-expression>

[09:50] <moritz> adu: but when you are at the point where the whole string 'myArrayFunc(double)[3]' has been parsed, you have all the ASTs for all of those tokens already

[09:51] <adu> moritz: yes, but you don't have the return type of the function!

[09:52] <moritz> adu: because the function can be post-declared?

[09:52] <adu> my point is that <declarator> has all the information it needs to build any AST, except for what is in <declaration-specifiers>

[09:52] <adu> all of the information should be available to <declaration>

[09:52] <adu> but I don't know how to combine it

[09:52] <moritz> not for a syntax tree

[09:53] <moritz> a syntax tree shouldn't encompass information that comes later on

[09:53] <adu> so declarator has (Name, PartialType), and declaration has (Type)

[09:53] <moritz> so you seem to need a separate pass that first builds a symbol table, and then resolves forward-references

[09:53] <adu> and I want the AST to have name and type as fields

[09:54] <moritz> that's not an AST anymore

[09:54] <moritz> AST = Abstract *Syntax* Tree

[09:54] <adu> so I should have a single AST that represents syntax

[09:54] <adu> not semantics

[09:55] <moritz> now we can start to argue whether type information that's not obviosu from syntax is still syntactic

[09:55] <moritz> but from a practical POV, you just need another pass

[09:56] <moritz> whethere you build a separate tree, or simply add some more information later on is pretty much up to you

[09:56] <adu> so, how do I do that? pass an array of actions to parse() ?

[09:56] <moritz> no. Simply traverse the tree you build

[09:56] <moritz> if that tree has a somewhat regular structure, that's trivial

[09:56] <adu> that's a lot of if statements

[09:57] <moritz> do that after you called .parse

[09:57] <moritz> not necessarily

[09:57] <moritz> first of all, mulltis can help a lot

[09:57] <moritz> or methods on the varios types that make up your AST

[09:57] <adu> oh, right, I can match on the types

[09:58] <moritz> finally, you should make the AST somewhat uniform

[09:58] <moritz> your users (including yourself) will thank you for it

[09:59] *** gfldex joined
[09:59] <adu> so by uniform, do you mean simple?

[10:00] <adu> like QAST has Stmt

[10:00] <adu> but CAST has several classes of statements

[10:00] <moritz> the QAST tree conists only of QAST::Node subtypes (except for leaves)

[10:00] <moritz> which makes it very easy to check if something is a branch of a leaf

[10:01] <moritz> also there's a uniform API for accessing QAST children

[10:02] <moritz> so if you want to do a complete tree traversal, you basically just have to do (paraphrased)  multi visit(QAST::Node $n) { vist($_) for $n.list }; multi visit(Any) { # do nothing, leaf node }

[10:02] <adu> wow

[10:03] <moritz> so if our AST is OO-y, it helps to give those classes a common API, via a superclass or role

[10:03] <adu> is it ok if I subclass QAST to make CAST?

[10:03] <moritz> don't do that

[10:03] <moritz> first, QAST is NQP-defined

[10:03] <moritz> which can lead to oddities if you subclass it in Perl 6

[10:03] <adu> ok

[10:04] <moritz> second, you don't want to support all the operations that QAST::Node does, so there's not much point

[10:04] <moritz> role CAST { has @.children handles <list> }

[10:05] <moritz> not so complicated, really :-)

[10:05] <adu> I've never seen "handles" before

[10:05] <moritz> it's for delegation

[10:06] <moritz> it just forwards the method 'list' to attribute @.children

[10:06] <moritz> role CAST { has @.children; method list { @.children.list } } # equivalent

[10:07] <adu> ok

[10:08] <masak> ab5tract: you didn't offend me. I agree with you that Perl 6 should not be considered immature.

[10:09] <adu> can you pass extra parameters to methods in the actions even if the grammar doesn't have those actions?

[10:09] <masak> ab5tract: Perl 6 faces a rather high bar of success, because it is a second system, and the first system is widely deployed.

[10:09] <masak> ab5tract: thus, it needs to be not just better, but (a) *significantly* better, and (b) not significantly worse.

[10:10] <masak> as to (a), I feel Perl 6 has some points of pride now. I've felt that since sometime one-two years ago.

[10:11] <masak> as to (b), the keywords are "performance" and "stability". we can still improve there, and we should.

[10:11] <masak> if I sounded offended, it was probably more that I typed while scowling at seeing yet another projection of intricate facts down to a one-dimensional ("mature"/"immature") metric.

[10:12] <moritz> adu: not really. But you can have attributes in action objects that carry additional information

[10:12] <adu> oh like $<x> = y

[10:12] <moritz> oh, captures

[10:12] <moritz> those come in via $/

[10:12] <adu> hmm, is that not what you meant?

[10:12] <moritz> no, but maybe it's what you meant :-)

[10:13] <moritz> you were asking the question

[10:13] <adu> I was also wondering if I could subclass an action class

[10:13] <moritz> sure

[10:14] <moritz> actions are in no way special

[10:14] <adu> how do I call a superclass's method with the same name?

[10:15] <moritz> the typical way is the callwith/callsame/nextwith/nextsame dispatchers

[10:16] <moritz> or you can explicitly call self.YourSuperClass::methodname(args)

[10:17] <masak> did anyone have any opinion about whether http://irclog.perlgeek.de/perl6/2015-01-10#i_9914995 exposes a bug about enum values exported from many places?

[10:17] <adu> interesting

[10:17] <moritz> masak: exportation is currently scoped to compunits

[10:18] <moritz> masak: you can consider that a bug or a feature

[10:18] <masak> moritz: that seems orthogonal to what I was asking.

[10:18] <moritz> masak: no

[10:18] <moritz> masak: let me explain :-)

[10:19] <moritz> ... or maybe not

[10:19] <masak> moritz: my question, more exactly, is this: if two modules export two different enum values B, should that value be considered "poisoned" in the importing scope?

[10:19] <masak> (rather than fail due to a double import, as it does now)

[10:19] <moritz> m: module M1 { enum A is export <B C> }; module M2 { enum X is export <B Z> };

[10:19] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤A symbol 'B' has already been exported␤»

[10:19] <moritz> masak: it doesn't fail as a double import

[10:19] <masak> innerestin'

[10:19] <moritz> masak: it fails as a double *export*

[10:20] <masak> then I see what you mean. I think.

[10:20] <moritz> masak: and that's because exportation is scoped to the compunit

[10:20] <masak> yeah, that's not the behavior I wanted to evoke.

[10:20] <masak> hold on.

[10:20] * masak splits the stuff into files

[10:20] *** denis_boyun_ left
[10:20] <moritz> and we have no posining for exports

[10:20] <masak> only enum values, IIUC.

[10:21] *** spider-mario joined
[10:21] *** denis_boyun joined
[10:23] <masak> here: https://gist.github.com/masak/406d687c3e4e0684c013

[10:23] *** denis_boyun___ joined
[10:23] <masak> by my reading of S12, this should work, but then you're not allowed to refer to just `B`; you have to say `X::B` or `Y::B`.

[10:24] <masak> (and if you also import a `sub B { ... }` from somewhere, it takes precedence and "un-poisons" the slot for itself)

[10:24] <moritz> that takes slot &B

[10:25] *** denis_boyun left
[10:26] <masak> no doubt -- but I'm talking about what happens when you write `B` in code after that.

[10:26] <masak> if the sub has been imported, that's a call to `B`.

[10:26] <moritz> that should resolve to &B, yes

[10:26] <masak> to `&B`, sorry.

[10:27] * moritz skims S12

[10:27] <masak> but if it hasn't, then it's still a compile-time error, because it's not clear if you're referring to `X::B` or `Y::B`.

[10:29] *** virtualsue_ joined
[10:29] <moritz> Since there is an enum C<OK>, the function C<OK> may only be

[10:29] <moritz> called using parentheses, never in list operator form.

[10:29] *** virtualsue left
[10:29] *** virtualsue_ is now known as virtualsue

[10:29] <moritz> so you'd be able to call B() when the B slot is poisoned, but not just 'B args', iiuc

[10:30] <moritz> ah yes

[10:30] <timotimo> .tell japhb now the log is filled with lines of Run command exited with exit status 1: install/bin/perl6 --optimize=3 /home/timo/oldhome/timo/perl6/bench/perl6/rc-forest-fire 16 16 inf

[10:30] <yoleaux> timotimo: I'll pass your message to japhb.

[10:30] <moritz> "If there is

[10:30] <moritz> a collision on two enum values that cancels them both, the function

[10:30] <moritz> still may only be called with parentheses, since the enum key

[10:30] <moritz> is "poisoned"."

[10:30] <masak> right.

[10:31] <masak> that's the only reference to the concept of poisoning I've found.

[10:31] <masak> it mentions the effect in passing, but it's pretty clear about it.

[10:31] * masak submits rakudobug

[10:31] <moritz> masak: S12 doesn't talk about in which circumstances poisoning, so I'd assume it happens everywhere

[10:31] <moritz> so, also in importation/exportation

[10:31] <masak> moritz: ah, you mean between any two imported symbols?

[10:31] <masak> moritz: that's very possible.

[10:31] <moritz> masak: no

[10:32] <masak> moritz: but enum values are a bit special in that they're essentially short-form aliases for their real unambiguous names.

[10:32] <moritz> masak: I mean between two imported enum items vs. two declared-here enum items

[10:32] <masak> moritz: like, `True` is short for `Bool::True`.

[10:32] <moritz> yes

[10:32] <masak> moritz: oh, that's entirely possible, yes.

[10:32] <masak> moritz: though I could equally well argue that the declared-here enum value takes precedence...

[10:32] <moritz> with "everywhere" I meant "at declaration and at {ex,im}portation"

[10:37] <masak> declaring something feels like much more of a "conscious act" than importation.

[10:37] <masak> like, you might not know you're importing a `B`, but you definitely know you're declaring one!

[10:40] *** lumimies joined
[10:40] *** IllvilJa left
[10:42] *** IllvilJa joined
[10:42] *** denis_boyun___ left
[10:43] *** denis_boyun_ joined
[10:45] *** denis_boyun_ left
[10:46] *** denis_boyun_ joined
[10:47] *** mvuets joined
[10:49] *** virtualsue left
[10:53] * masak finally watches TimToady++'s APW keynote

[10:59] <El_Che> TimToady: The Fosdem Language track schedule is online: https://fosdem.org/2015/schedule/track/languages/

[11:00] <El_Che> You'll be closing the track. Sunday 13-13:50

[11:00] <El_Che> A good time and position

[11:01] <masak> \o/

[11:01] <El_Che> ah nice, there is an other perl talk just before

[11:01] * masak .oO( Perl 6: a last language )

[11:01] <El_Che> (which I didn't know noting about)

[11:01] <El_Che> https://fosdem.org/2015/schedule/event/design_and_implementation_of_a_perl_number_theory_module/

[11:02] <El_Che> so the dev room and larry's talk don't collide

[11:02] <El_Che> great

[11:05] *** rindolf joined
[11:31] *** adu left
[11:33] *** rurban joined
[11:35] *** mr-foobar joined
[12:04] *** Alina-malina left
[12:05] *** Alina-malina joined
[12:07] <lizmat> good *, #perl6

[12:07] <lizmat> m: $;1   # trying to do a "useless use of variable" warning but not finding the line number

[12:07] <camelia> rakudo-moar 8f447f: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[12:08] <lizmat> it would seem that .orig is not being set in the case of an unnamed variable

[12:08] <lizmat> does anybody have any clue where that would need to be set ?

[12:09] <dalek> rakudo/nom: 7ad8639 | lizmat++ | src/Perl6/Optimizer.nqp:

[12:09] <dalek> rakudo/nom: Improve 'Useless use' warning for unnamed vars

[12:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ad8639bfc

[12:09] <lizmat> ^^^ does not fix the problem, will just produce a better warning when the problem is fixed

[12:12] <FROGGS_> I'd leave the word 'variable' in the warnings

[12:12] <masak> lizmat+ # there's another '+' waiting for you ;)

[12:12] <lizmat> :-)

[12:12] <FROGGS_> *g*

[12:13] <lizmat> m: class A { has $!a; method a { $!a; 42 } }   # why no warning here, FROGGS_ masak ?

[12:14] <camelia> rakudo-moar 8f447f: ( no output )

[12:14] *** konsolebox joined
[12:14] <lizmat> I think showing the sigil with the name, implies variable, no?

[12:15] <lizmat> are there contexts where parameters should give that warning?

[12:15] <FROGGS_> std: sub foo($a) { }; foo(42)

[12:15] <camelia> std f9b7f55: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/pOnBFaMNSA line 1:␤------> [32msub foo([33m⏏[31m$a) { }; foo(42)[0m␤ok 00:01 139m␤»

[12:15] <FROGGS_> sort of

[12:16] <lizmat> std: $;1

[12:16] <camelia> std f9b7f55: OUTPUT«ok 00:00 135m␤»

[12:16] <lizmat> std: $b;1

[12:16] <camelia> std f9b7f55: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $b is not predeclared at /tmp/UOGOkK6nT5 line 1:␤------> [32m<BOL>[33m⏏[31m$b;1[0m␤Check failed␤FAILED 00:00 135m␤»

[12:16] <lizmat> std: my $b;$b;1

[12:16] <camelia> std f9b7f55: OUTPUT«ok 00:00 135m␤»

[12:16] <lizmat> hmm... we seem to be more strict than std  :-)

[12:17] <dalek> rakudo/nom: 09c5420 | lizmat++ | src/Perl6/Optimizer.nqp:

[12:17] <dalek> rakudo/nom: Add variable

[12:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/09c5420123

[12:18] <dalek> rakudo/newio: 76afb6c | peschwa++ | src/vm/jvm/runtime/org/perl6/rakudo/RakudoJavaInterop.java:

[12:18] <dalek> rakudo/newio: Static classes won't have a constructor; honor that.

[12:18] <dalek> rakudo/newio: 

[12:18] <dalek> rakudo/newio: This commit fixes generation of constructor dispatch to not generate any

[12:18] <dalek> rakudo/newio: dispatch code if we don't have constructors in the first place.

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/76afb6c58c

[12:18] <dalek> rakudo/newio: 28429ec | peschwa++ | / (2 files):

[12:18] <dalek> rakudo/newio: Correct marshalling of listy types to Java.

[12:18] <dalek> rakudo/newio: 

[12:18] <dalek> rakudo/newio: raiph++ for pointing me at this.

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/28429ec898

[12:18] <dalek> rakudo/newio: 8f447f8 | FROGGS++ | / (2 files):

[12:18] <dalek> rakudo/newio: Merge pull request #350 from peschwa/jvminterop

[12:18] <dalek> rakudo/newio: 

[12:18] <dalek> rakudo/newio: More JVM-Interop improvements

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/8f447f89cf

[12:18] <dalek> rakudo/newio: 7ad8639 | lizmat++ | src/Perl6/Optimizer.nqp:

[12:18] <dalek> rakudo/newio: Improve 'Useless use' warning for unnamed vars

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/7ad8639bfc

[12:18] <dalek> rakudo/newio: 09c5420 | lizmat++ | src/Perl6/Optimizer.nqp:

[12:18] <dalek> rakudo/newio: Add variable

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/09c5420123

[12:18] <dalek> rakudo/newio: 5c5a060 | lizmat++ | / (3 files):

[12:18] <dalek> rakudo/newio: Merge branch 'nom' into newio

[12:18] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/5c5a060989

[12:19] <dalek> specs/newio: 48af140 | TimToady++ | S02-bits.pod:

[12:19] <dalek> specs/newio: Mention unspace disallowed in regex (except \#)

[12:19] <dalek> specs/newio: 

[12:19] <dalek> specs/newio: The current engine disallows unspace in regexex as too ambiguous.

[12:19] <dalek> specs/newio: This is fine for actual whitespace, but is counterintuitive when people

[12:19] <dalek> specs/newio: try to backslash the # character.  So \# is now specifically allowed

[12:19] <dalek> specs/newio: to match a literal # character.

[12:19] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/48af140e23

[12:19] <dalek> specs/newio: 518438a | (Stéphane Payrard)++ | S99-glossary.pod:

[12:19] <dalek> specs/newio: laziness and other entries

[12:19] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/518438a93f

[12:19] <dalek> specs/newio: 1eee389 | lizmat++ | S (2 files):

[12:19] <dalek> specs/newio: Merge branch 'master' into newio

[12:19] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/1eee389051

[12:23] *** rurban left
[12:25] *** ggoebel111111112 left
[12:30] *** leont joined
[12:30] *** kjs_ joined
[12:35] *** Alina-malina left
[12:37] *** ggoebel111111112 joined
[12:41] <dalek> rakudo/nom: 58ae622 | lizmat++ | / (4 files):

[12:41] <dalek> rakudo/nom: Remove unneeded stub

[12:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/58ae6222bc

[12:41] <FROGGS_> lizmat: all warnings/exceptions talk about "variable $foo"... and I'd not imply anything, a newby that does not know the idea of sigils well might be more confused than needed

[12:45] <masak> lizmat: re parameters: I used to gnash my teeth at Niecza warning about all kinds of unused paramters.

[12:45] <masak> lizmat: it's my perogative as a programmer to name a parameter in my routine, and then not use it.

[12:46] <masak> lizmat: in some way, that's a kind of documentation too (and may happen easily, especially with multis), and it happens *often* as one goes through quick refactor cycles.

[12:46] <masak> it feels silly to warn about it.

[12:46] <FROGGS_> well, I could imaging to only warn about that in a pedantic mode

[12:46] <masak> IntelliJ IDEA strikes the perfect balance here, if you ask me.

[12:46] <FROGGS_> because, that's what it is

[12:47] <masak> it colors unused declarations grey.

[12:47] <masak> that way, people who don't care just blissfully tune it out, easily.

[12:47] <masak> and people who do care pick up on it, and handle it when they feel like it.

[12:48] <masak> ...I don't quite know how to express this yet, but a lot of things that we think crudely of as "warnings" and "errors" right now will distribute themselves over the next 20 years or so into slightly different buckets all having to do with different levels of notifications inside an IDE like IntelliJ.

[12:48] <arnsholt> And sometimes an API requires you to include a parameter you don't actually need

[12:49] <masak> the notion of an "abstract interpreter" constantly checking your code while you write it is just too good not to win.

[12:49] *** rurban joined
[12:49] <arnsholt> CL lets you say "nevermind that this variable is unused"

[12:49] <masak> arnsholt: yes, but that argument is weaker in Perl 6, since you can always make a positional anonymous.

[12:49] <arnsholt> Troo

[12:50] *** vendethiel joined
[12:54] <dalek> rakudo/nom: 574192c | ab5tract++ | src/core/set_operators.pm:

[12:54] <dalek> rakudo/nom: on our way to first class hashes

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/574192c4c3

[12:54] <dalek> rakudo/nom: a5a1832 | ab5tract++ | src/core/set_operators.pm:

[12:54] <dalek> rakudo/nom: baggy handling of ops now takes mixes into account

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a5a18326a1

[12:54] <dalek> rakudo/nom: 671bbcc | ab5tract++ | src/core/set_operators.pm:

[12:54] <dalek> rakudo/nom: the mix/bag ops should convert arguments to Bag in cases where no Mix is present

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/671bbccfec

[12:54] <dalek> rakudo/nom: 3f625fb | ab5tract++ | t/spectest.data:

[12:54] <dalek> rakudo/nom: Add the mix test to the spectest list

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3f625fb92e

[12:54] <dalek> rakudo/nom: f7bf2fb | ab5tract++ | src/core/set_operators.pm:

[12:54] <dalek> rakudo/nom: Implement a few performance enhancements as suggested by lizmat

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7bf2fba02

[12:54] <dalek> rakudo/nom: bcea51a | ab5tract++ | src/core/set_operators.pm:

[12:54] <dalek> rakudo/nom: While in the vein of performance, remove some junctions

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bcea51a614

[12:54] <dalek> rakudo/nom: 13d9afe | lizmat++ | / (2 files):

[12:54] <dalek> rakudo/nom: Merge pull request #351 from ab5tract/555/quanthash_ops

[12:54] <dalek> rakudo/nom: 

[12:54] <dalek> rakudo/nom: Get Mixes working properly with the QuantHash ops

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/13d9afe095

[12:58] <FROGGS_> masak: would a trait be an option?

[12:58] <FROGGS_> 'is unused'

[12:58] *** Alina-malina joined
[12:58] <FROGGS_> is good for documentation too

[12:59] <masak> FROGGS_: my point is, to me it doesn't feel like the user should have to defend her declaration of something unused *at all*.

[12:59] <masak> I've never felt helped by such a warning. only annoyed.

[13:03] <masak> more broadly, I am against, and will keep being against, any error or warning that assumes the programmer is a beginner rather than a power user.

[13:03] <masak> that's ultimately why I have a beef with `say;` being erroneous, too.

[13:03] <masak> it would be darn useful for it not to be!

[13:04] <lizmat> .tell ab5tract seems t/spec/S03-operators/mix.t is missing from roast ?

[13:04] <yoleaux> lizmat: I'll pass your message to ab5tract.

[13:05] <lizmat> m: say()   # 2 extra characters to show that you really mean it

[13:05] <camelia> rakudo-moar 8f447f: OUTPUT«␤»

[13:06] <lizmat> possibly, the error should mention the use of a heredoc

[13:12] <lizmat> .tell ab5tract also, some Set/Bag interaction with (-) seems wrong: say (<a b c>.Set (-) <a b>.Bag).perl  ->  ("c"=>1).Bag

[13:12] <yoleaux> lizmat: I'll pass your message to ab5tract.

[13:15] *** brrt joined
[13:15] *** sirdancealot left
[13:22] *** sirdancealot joined
[13:25] *** fwilson left
[13:26] *** yeahnoob joined
[13:26] *** yeahnoob left
[13:27] *** yeahnoob joined
[13:27] *** yeahnoob left
[13:28] *** yeahnoob joined
[13:28] *** yeahnoob left
[13:28] *** n0den1te joined
[13:29] *** yeahnoob joined
[13:29] *** yeahnoob left
[13:29] *** yeahnoob joined
[13:30] *** yeahnoob left
[13:30] *** yeahnoob joined
[13:30] *** yeahnoob left
[13:31] *** yeahnoob joined
[13:31] *** yeahnoob left
[13:32] *** yeahnoob joined
[13:32] *** [Sno] joined
[13:35] <dalek> rakudo/nom: 2aef1f7 | lizmat++ | src/core/set_operators.pm:

[13:35] <dalek> rakudo/nom: Make (<+) and (>+) 2x faster in worst case

[13:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2aef1f75e2

[13:39] *** yeahnoob left
[13:40] <FROGGS_> masak: I agree with you about 'say;'

[13:41] <moritz> \o

[13:41] <masak> well, the pattern is the same in both cases: the warning or error is "this *could* be wrong, so I won't allow you to do that"

[13:41] <masak> when there are perfectly legitimate cases for an experienced user to do that thing.

[13:41] <FROGGS_> hi moritz 

[13:42] <n0den1te> m: say; 3;

[13:42] <camelia> rakudo-moar 13d9af: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/sL_TNzIL0W␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/sL_TNzIL0W:1␤------> [32msay[33m⏏[31m; 3;[0m␤    ex…»

[13:42] <FROGGS_> masak: but '$foo is unused' also makes perfectly sense... imagine you read a foreign code you have to maintain

[13:43] <FROGGS_> unused params always raise the question if this was intentional or just forgotten to take into account

[13:44] *** kjs_ left
[13:44] <masak> FROGGS_: the compiler shouldn't second-guess the programmer!

[13:45] <FROGGS_> no, but maintainable code is important

[13:45] *** denis_boyun_ left
[13:46] <masak> FROGGS_: I don't see the structural difference between "this `say;` *might* be you being confused and meaning `.say;`, so I'm not going to allow you to write that" and "this parameter is undeclared and I don't know if you are aware, so I'm going to warn about that by default"

[13:46] <n0den1te> masak: nor should the programmer second guess the compiler *shudder*

[13:46] <FROGGS_> so when you stub a signature, implement the routine partly and accidently pass your tests is bad... hints are nice in that regard

[13:46] *** denis_boyun joined
[13:46] <masak> no, they are not nice.

[13:47] <FROGGS_> I do like hints if I can satisfy them in either way... see, that's why I *love* clang

[13:47] <masak> if I wanted suggestions for where my code declares unused things which might point to structural deficiencies, I'd use a linter.

[13:47] *** kjs_ joined
[13:48] <masak> I don't like warnings that punish me for writing the easiest possible code to accomplish something.

[13:48] <masak> if I have to sprinkle the code with "#OK" comments to quiet the compiler, I feel like the compiler's errand-boy.

[13:50] <FROGGS_> these #OK comments are weird anyway

[13:51] *** fwilson joined
[13:53] <FROGGS_> anyway, my motivations for an 'is unused' traits are 1) self documenting code, especially if others read it, 2) tell the compiler what you are up to, which leads to 3) silence that bloody warnings and possible optimizations

[13:53] <masak> I feel you are misguided, since those warnings shouldn't happen in the first place.

[13:53] <FROGGS_> not 'silence optimization' of course :o)

[13:54] <FROGGS_> masak: that's your opinion :o)

[13:54] <masak> yes, it is!

[13:54] * masak starts a campaign: "Don't Bother Me While I Program" (DBMWIP)

[13:54] <FROGGS_> I welcome this warning, since I rarely (never) add params I don't use

[13:54] <masak> if the compiler emits a warning *just because it can*, then the compiler should shut up.

[13:54] <masak> FROGGS_: that's a narrow-minded view of what happens during programming.

[13:55] <masak> when I code, I copy-paste stuff. I change it on the fly. I compiler half-finished things to see if they work.

[13:55] *** yeahnoob joined
[13:55] <n0den1te> FROGGS_: what masak is saying is, "Don't baby-glove programmers"

[13:55] <FROGGS_> no, it helps me to do my job

[13:55] *** yeahnoob left
[13:55] <masak> in a lot of transition states, there will be unused parameters and variables.

[13:55] *** brrt left
[13:55] <masak> the compiler flagging them up as something I should care about is a bloody annoyance.

[13:55] *** yeahnoob joined
[13:55] <FROGGS_> I welcome every warning that results in a: "right, I still need to do that part"

[13:56] <masak> if I wanted that information, I'd ask for it.

[13:56] <FROGGS_> how do you ask for it?

[13:56] *** yeahnoob left
[13:56] <n0den1te> turn on warnings? 

[13:56] <masak> FROGGS_: those are low-level tasks, not something that should show up during every compile.

[13:56] <masak> FROGGS_: that's why it's more like linting.

[13:56] *** denis_boyun___ joined
[13:56] *** yeahnoob joined
[13:56] *** [Sno] left
[13:56] <masak> I can have a *valid* program with some unused parameters.

[13:57] *** yeahnoob left
[13:57] *** raiph joined
[13:57] <masak> I want to know about things that are wrong, not TODO-list things.

[13:57] *** yeahnoob joined
[13:57] <FROGGS_> I like todo-list things, because I usually work on several places at once, and that helps me keeping track

[13:57] *** yeahnoob left
[13:57] *** denis_boyun left
[13:58] <masak> I cannot help that you like this useless warning. there are plenty of other ways for you to remember that you have unused parameters, though. ways that wouldn't bother me while I code.

[13:58] *** n0den1te left
[13:58] <FROGGS_> masak: you can have valid programs in many different ways, shall we silence everything that could be caused just because the program is not done yet?

[13:59] <masak> FROGGS_: you're twisting my argument.

[13:59] *** yeahnoob joined
[13:59] *** yeahnoob left
[13:59] <FROGGS_> no, I am just using your argument for other bits that match it as well :o)

[14:00] *** yeahnoob joined
[14:00] <masak> just so we don't have to strawman each other, here are some warnings I like:

[14:00] <FROGGS_> so, I don't mind if I get extra warnings while I am about to add things and recompile... the compiler should take the program as if it was done

[14:00] <masak> "redeclaration of variable in scope" -- fine, that was probably a thinko on my part.

[14:01] <vendethiel> FROGGS_: in C/C++, what I see most of the time is `void foo(Type /*paramname*/)`

[14:01] <masak> "use of undefined value" -- this (runtime) warning I always pay attention to, immediately.

[14:03] <masak> various deprecation warnings -- nice. and, usually, lizmat++

[14:05] <masak> FROGGS_: for every time I commit, I might have compiled my program ~100 times. if I get warnings about unused parameters even 10 of those times, that's a whole lot of noise in my compile output for something I don't really care to know.

[14:05] <vendethiel> .oO( let's not follow go there... )

[14:06] <vendethiel> (go errors for every unused import, and even variables I think)

[14:07] *** jluis joined
[14:09] <masak> vendethiel: I think it was Go's "error on unused import" that made me start to think about these things more clearly.

[14:09] <masak> more precisely, there are some possible problematic things that can happen in transitions and during refactors, that I *just don't care* to be errored/warned about.

[14:13] <[Tux]> WTF

[14:13] <[Tux]> 6 my int $i = 0; $i--;

[14:14] <[Tux]> m: my int $i = 0; $i--;

[14:14] <camelia> rakudo-moar 13d9af: OUTPUT«Cannot assign to an immutable value␤  in sub postfix:<--> at src/gen/m-CORE.setting:4980␤  in block <unit> at /tmp/dmsr5BPDZQ:1␤␤»

[14:14] <masak> today's autopun spotting: https://twitter.com/davidcoverdale/status/554168073574686722

[14:16] <[Tux]> m: my int $i = 0; $i = $i - 1;

[14:16] <camelia> rakudo-moar 13d9af: ( no output )

[14:16] *** brrt joined
[14:17] <masak> [Tux]: there's wide agreement that that should work, but it's difficult to implement. here's (I think) why: usually the $value gets replaced by $value.pred and then put back into the variable's container. but natives have no containers, only the value itself.

[14:17] <[Tux]> I'll go with $i - 1 for now

[14:18] * [Tux] tries to implement all the CSV options, so we at least will be able to SHOW that it works

[14:20] <moritz> http://smoke.perl6.org/report is now up and running

[14:20] <moritz> thanks to colomon++ and a wee bit of infrastructure by me

[14:21] <masak> \o/

[14:21] <masak> the only kind of smoke I like!

[14:22] *** brrt left
[14:22] <masak> why is the author of 007 listed as "Unknown"?

[14:23] <moritz> masak: did you specify it in META.info?

[14:23] *** BenGoldberg joined
[14:24] <masak> good question. I didn't write the META.info :)

[14:24] <masak> seems to be in there, though: https://github.com/masak/007/blob/master/META.info#L4

[14:26] <moritz> huh

[14:26] <moritz> http://smoke.perl6.org/project/007 reports it

[14:26] <moritz> (which takes it from ecosystem-api.p6c.org)

[14:29] <moritz> https://github.com/colomon/SmokeResults/blob/master/lib/SmokeResults.pm#L130 this is where the 'Unknown' comes from

[14:29] <moritz> https://github.com/colomon/SmokeResults/blob/master/lib/SmokeResults.pm#L201 ummm

[14:34] *** ab5tract joined
[14:35] <ab5tract> hi lizmat 

[14:35] <yoleaux> 13:04Z <lizmat> ab5tract: seems t/spec/S03-operators/mix.t is missing from roast ?

[14:35] <yoleaux> 13:12Z <lizmat> ab5tract: also, some Set/Bag interaction with (-) seems wrong: say (<a b c>.Set (-) <a b>.Bag).perl  ->  ("c"=>1).Bag

[14:35] <ab5tract> https://github.com/perl6/roast/pull/52/files

[14:36] <ab5tract> both addressed in this PR

[14:36] <ab5tract> for the record, i do not see any sane way to allow LoL semantics for (-) if it is expected to return a Set in the case that a Set is provided first

[14:41] <ab5tract> another set related PR (which TimToady has expressed support for) would explicitly make the set semantics to always promote its arguments to the most complex present

[14:50] <ab5tract> lizmat: for reference -- https://github.com/rakudo/rakudo/pull/335

[14:50] *** brrt joined
[14:52] <ab5tract> masak: glad to hear i didn't offend :)

[14:55] *** _4d47 joined
[14:56] <ab5tract> moritz: FWIW, it is strongly recommended by the Dancer devs to only use Dancer2

[14:57] <ab5tract> (i noticed that SmokeResults is a Dancer 1 app)

[14:59] <moritz> ab5tract: patches welcome :-)

[14:59] <ab5tract> :)

[14:59] <ab5tract> maybe later

[14:59] <moritz> (I didn't develop that app, just patched it a bit here and there)

[14:59] <moritz> ab5tract: and ask colomon++ first, he'll be the one accepting or rejecting patches

[15:00] <ab5tract> sounds like a plan

[15:00] <ab5tract> moritz: not sure if you want to merge that roast PR or wait for lizmat

[15:00] *** Alina-malina left
[15:01] <moritz> ab5tract: I'm not firm at all in the mix/bag department, so I'd like to leave the decisions to those who know it better

[15:02] <ab5tract> fair enough :)

[15:02] *** berekuk joined
[15:03] * ab5tract feels good to have a patch in core :D

[15:03] <El_Che> as long your patch doesn't results in core files :)

[15:03] *** skids joined
[15:05] *** zakharyas joined
[15:06] *** frew left
[15:06] *** sirdancealot left
[15:06] *** sirdancealot joined
[15:07] <ab5tract> okay, now onto the airplane back to Amsterdam

[15:07] *** sirdancealot left
[15:08] <ab5tract> .tell lizmat check out https://github.com/perl6/roast/pull/52/files for the mix.t .. and checkout out https://github.com/rakudo/rakudo/pull/335 for what i think about `Set (-) Bag ~~ Set` ;)

[15:08] <yoleaux> ab5tract: I'll pass your message to lizmat.

[15:09] <masak> a new blog post about Second Systems: http://www.anton-pirker.at/the-big-rewrite-war-story/ -- HN discussion: https://news.ycombinator.com/item?id=8869608

[15:10] *** ab5tract left
[15:11] *** FROGGS__ joined
[15:11] *** FROGGS_ left
[15:11] *** yeahnoob left
[15:14] *** kjs_ left
[15:15] *** sirdancealot joined
[15:17] <moritz> https://github.com/rakudo/rakudo/pull/324 # some more opinions (preferably from rakudo developers) would be very welcome

[15:17] *** denis_boyun___ left
[15:19] *** broski joined
[15:19] <broski> brah

[15:19] <broski> m: "Bruh".say

[15:19] <camelia> rakudo-moar 2aef1f: OUTPUT«Bruh␤»

[15:21] <psch> moritz: http://irclog.perlgeek.de/perl6/2014-10-05#i_9458502 # the NULL was originally jnthn++'s idea, but i might still have implemented it less-than-sensible 

[15:21] <psch> moritz: that's a data point, not really a justification... :)

[15:24] *** KCL_ left
[15:25] *** mvuets left
[15:30] *** Rounin left
[15:35] <moritz> m: class broski { method brah { say 'Bruh' } }; broski.brah # could not resist :-)

[15:35] <camelia> rakudo-moar 2aef1f: OUTPUT«Bruh␤»

[15:36] <moritz> psch: if jnthn++ endorses the whole idea (and the implementation), I'd like to see some tests for the command line parser

[15:36] <moritz> psch: but I won't ask you to write any before we're confident that it'll be merged at all

[15:38] <psch> moritz: S19-command-line-optins has a few tests, but we could probably use more

[15:38] <moritz> psch: those are only very basic, and only for rakudo's interpretation of built-in options, not for the general mechanism

[15:39] <psch> 04-negation.t seems rather mechanism-oriented to me

[15:40] <psch> although the message for the first one seems to be wrong, it's help and not stagestats

[15:40] <moritz> psch: maybe I should rephrase

[15:41] <psch> moritz: the parser should probably be tested in isolation though, i think that's what you mean

[15:41] <moritz> psch: the tests in roast are integration tests. But the command line parser is isolated enough to warrant unit tests, IMHO

[15:41] <moritz> yes

[15:42] <moritz> psch: one more piece of small-scale feedback: why does the new class inherit from HLL::CommandLine::Parser? what functionality does it reuse?

[15:43] <dalek> roast: 926a7fa | ab5tract++ | S0 (2 files):

[15:43] <dalek> roast: something like mixes working

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/926a7fac80

[15:43] <dalek> roast: e9b66c3 | ab5tract++ | S03-operators/mix.t:

[15:43] <dalek> roast: getting closer:

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/e9b66c3213

[15:43] <dalek> roast: 8646069 | ab5tract++ | S03-operators/ (2 files):

[15:43] <dalek> roast: a bit closer every day

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/86460693b6

[15:43] <dalek> roast: 1090421 | ab5tract++ | S03-operators/set.t:

[15:43] <dalek> roast: I do not see a way around returning Bag, nor do I see a reason why the order of the subtraction should determine it's type (really this needs to be consistent, as already discussed in my PR for sane promotion of set types)

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/1090421d02

[15:43] <dalek> roast: 6df4ae1 | ab5tract++ | S03-operators/mix.t:

[15:43] <dalek> roast: Mixes now have first class support in the operators

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/6df4ae1697

[15:43] <dalek> roast: 50c7fb6 | lizmat++ | S0 (4 files):

[15:43] <dalek> roast: Merge pull request #52 from ab5tract/555/quanthashy_ops

[15:43] <dalek> roast: 

[15:43] <dalek> roast: Add a mix.t test

[15:43] <dalek> roast: review: https://github.com/perl6/roast/commit/50c7fb6fc5

[15:44] *** virtualsue joined
[15:44] <psch> moritz: iirc the inheritance was for polymorphism reason - less reuse of features but fitting into the same spot

[15:44] <psch> moritz: i'd have to dig to see if i misthought that though

[15:45] <moritz> psch: since the code that uses the CLI parser doesn't have any type constraints, there's no need for inheritance to achieve polymorphism

[15:45] <moritz> (and if it were using type constraints, it would be better to constrain to a common interface role)

[15:48] <brrt> spectest has set/bag confusion

[15:48] <psch> moritz: true.  apparently the inheritance isn't neccessary.  it might be an artifact from trying to extend the current mechanism in HLL::CommandLine::Parser to handle delimited options from before i decided to implement it via a grammar

[15:55] <psch> moritz: removing the inheritance fails with missing method 'stop-after-first-arg'

[15:56] <psch> moritz: i think that means the interface role should be implemented... :)

[15:56] <psch> moritz: i'll have a closer look again during next week, don't really have time right now.  i'm fairly sure i can clean it up at least a bit

[15:57] <brrt> SO3-operators/set.t

[16:00] *** scsix joined
[16:05] *** jluis left
[16:05] *** berekuk left
[16:06] <novice666> m: ++$++

[16:06] <camelia> rakudo-moar 2aef1f: OUTPUT«Cannot assign to an immutable value␤  in sub postfix:<++> at src/gen/m-CORE.setting:4975␤  in block <unit> at /tmp/AXtqwobfez:1␤␤»

[16:06] <dalek> specs/newio: c1656c4 | lizmat++ | S16-io.pod:

[16:06] <dalek> specs/newio: Some elaboration about classes

[16:06] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/c1656c4665

[16:07] <lizmat> brrt: set/bag confusion noted, but I'm not sure what the right answer is there (anymore)

[16:07] <yoleaux> 15:08Z <ab5tract> lizmat: check out https://github.com/perl6/roast/pull/52/files for the mix.t .. and checkout out https://github.com/rakudo/rakudo/pull/335 for what i think about `Set (-) Bag ~~ Set` ;)

[16:07] <novice666> moritz: ++$++ OUTPUT«Cannot assign to an immutable value␤ 

[16:07] <lizmat> brrt:  my feeling is that we should keep as much information as possible

[16:09] *** Sir_Ragnarok left
[16:12] *** berekuk joined
[16:18] *** Sir_Ragnarok joined
[16:18] *** raiph left
[16:18] *** broski left
[16:20] *** denis_boyun_ joined
[16:22] <moritz> novice666: $++ returns a value, not a variable

[16:22] <moritz> novice666: so you can't prefix-++ it anymore

[16:23] *** berekuk left
[16:24] <moritz> psch: well, as I said before, wait with cleanup before you've got a general approval; otherwise it's sunk effort

[16:25] <psch> moritz: right, i'll do it like that :)

[16:31] <dalek> rakudo/newio: f3a420f | lizmat++ | src/core/io_operators.pm:

[16:31] <dalek> rakudo/newio: dir(...., :absolute) is no more

[16:31] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/f3a420f36f

[16:35] <colomon> moritz: just moved SmokeResults to perl6-community-modules

[16:37] <moritz> colomon++

[16:37] <moritz> colomon: did you see my email about where to sync the results to?

[16:41] <lumimies> moritz: So why does that error mention postfix:<++>?

[16:41] <moritz> m: (++$)++

[16:41] <camelia> rakudo-moar 2aef1f: OUTPUT«Cannot assign to an immutable value␤  in sub postfix:<++> at src/gen/m-CORE.setting:4975␤  in block <unit> at /tmp/PcNrC5qUma:1␤␤»

[16:42] <moritz> m: ++($++)

[16:42] <camelia> rakudo-moar 2aef1f: OUTPUT«Cannot assign to an immutable value␤  in sub prefix:<++> at src/gen/m-CORE.setting:4967␤  in block <unit> at /tmp/epVjkDbOBB:1␤␤»

[16:42] <moritz> lumimies: seems neither returns a container

[16:42] <lumimies> moritz: I thought ++$ would

[16:45] <lizmat> $ perl -e '++$a++'    # syntax error at -e line 1, near "$a++"   in P5, maybe we need that in P6 as well ?

[16:45] <moritz> lumimies: I thought so too, but it doesn't

[16:45] *** Alina-malina joined
[16:48] *** berekuk joined
[16:51] *** kaare__ left
[16:53] *** telex left
[16:54] *** telex joined
[16:59] *** mayuresh joined
[17:00] <mayuresh> p6: say 3;

[17:00] <yoleaux> 6 Dec 2014 18:28Z <psch> mayuresh: https://github.com/BizarreCake/Arane is the previous project i mentioned.  it's written in C++11 though, not C89

[17:00] <camelia> rakudo-{parrot,moar} 2aef1f: OUTPUT«3␤»

[17:00] <dalek> rakudo/newio: a20bee0 | lizmat++ | src/core/ (9 files):

[17:00] <dalek> rakudo/newio: Match end of FILETEST to case of -x file tests

[17:00] <dalek> rakudo/newio: 

[17:00] <dalek> rakudo/newio: To easier allow extension to uppercase -x file tests

[17:00] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/a20bee0d35

[17:01] <mayuresh> cool :)

[17:01] *** zakharyas left
[17:01] <mayuresh> psch: it's worth it, don't stop, do complete it :)

[17:02] <mayuresh> i am going to be working on p6 interpreter because;

[17:02] <mayuresh> 1. it's a rite of passage for my cs education

[17:02] <masak> lizmat: the table at the top of S03 has the "Autoincrement" level as being non-associative, which would mean that `++$a++` is indeed a syntax error.

[17:02] <mayuresh> 2. i really admire mr. wall's work

[17:03] <mayuresh> okay, ubuntu just installed updates, needs to restart my computer!

[17:04] <mayuresh> dang, also time for me to hit bed.

[17:04] <masak> mayuresh: if you want inspiration for an interpreter of a language a little bit like Perl 6 -- but much smaller -- do check out http://masak.github.io/007/

[17:04] <mayuresh> thanks psch :)

[17:05] <mayuresh> masak: i have been told to write a scheme r4rs interpreter first

[17:05] <mayuresh> then go for any language of my choice

[17:05] <mayuresh> chose perl6. :)

[17:05] *** frew joined
[17:05] <psch> mayuresh: that's not my project

[17:05] <mayuresh> psch: oh, sorry

[17:05] <mayuresh> you just pointed it out to me! thanks. :)

[17:06] <mayuresh> alrighty, see you all later.

[17:06] *** mayuresh left
[17:07] <dalek> rakudo/newio: 5cce0e9 | lizmat++ | src/core/IOU.pm:

[17:07] <dalek> rakudo/newio: Make error reporting more sturdy, jnthn++

[17:07] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/5cce0e90c1

[17:09] <colomon> moritz: saw it but hadn't yet fully grasped that I needed to do something to make it work.  moritz++

[17:10] *** slavik1 left
[17:10] *** araujo left
[17:11] *** araujo joined
[17:11] *** molaf__ left
[17:19] <dalek> rakudo/newio: 94bd202 | lizmat++ | src/core/io_operators.pm:

[17:19] <dalek> rakudo/newio: Make single mkdir($path,$mode?) return Bool again

[17:19] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/94bd202662

[17:25] <lizmat> .tell jnthn looks like nqp::mkdir on moar doesn't fail if the actual mkdir fails, it does on parrot and jvm

[17:25] <yoleaux> lizmat: I'll pass your message to jnthn.

[17:25] *** slavik joined
[17:34] <b2gills> `int` is defined as being the largest integer that runs at full speed. Which means it can be 64-bit on a 32-bit machine ( the Pentium processor may be an example ) or even 32-bit on a 64-bit machine ( I doubt there were any in general use, if indeed they exist at all ).

[17:42] *** denis_boyun_ left
[17:46] <lizmat> .tell jnthn or perhaps I'm not understanding fail() correctly  :-(

[17:46] <yoleaux> lizmat: I'll pass your message to jnthn.

[17:49] <geekosaur> I think there were some transitional 32/64 RISC architectures, all of course pretty much dead

[17:59] * colomon is getting completely lost in a maze of p6c.org machines and accounts

[17:59] <colomon> moritz++

[18:03] *** zakharyas joined
[18:13] *** FROGGS_ joined
[18:16] *** Sqirrel left
[18:17] *** FROGGS__ left
[18:18] <b2gills> I think there should be a native type that is defined as being the same size as a far pointer. ( most processors now have the same size for far pointers and near pointers )

[18:24] *** mvuets joined
[18:24] *** Ugator joined
[18:30] <b2gills> There are near-pointers, far pointers, maximum full speed integers, bus-width, and architecture. There is not necessarily any correlation among them. The Maximum full speed integers is most likely the same as the largest of the rest of the set, but it can also be smaller. ( It is always the same as at least one of the others I think )

[18:31] *** zakharyas left
[18:32] <dalek> rakudo/nom: 319c9c3 | lizmat++ | src/core/Str.pm:

[18:32] <dalek> rakudo/nom: Make Str.Bool between 2.5x and 4x as fast

[18:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/319c9c355f

[18:37] <colomon> moritz: I updated the authors file and now it's completely borked.  I'm more than a little bit puzzled by this.

[18:37] <colomon> moritz: I'm trying out running a smoke test on hack.p6c.org at this very moment.

[18:39] <b2gills> x64 processors start out in 16-bit mode which has 16-bit near pointers, and 32-bit far pointers. To get to 32-bit mode you have to do a 32-bit jump ( typically to the next instruction ). At that point both pointer types are 32-bits, but allows 64-bit integer math. I'm not sure how you get to 64-bit mode but I think it's a similar operation. At that point the pointers and max integer math are all 64-bit. ( I may have been confused about somet

[18:41] <b2gills> At any rate 64-bit mode is the only mode in x86 processors where near pointers, far pointers, and the largest full-speed integer size are all the same.

[18:41] <timotimo> cool, lizmat 

[18:44] *** brrt left
[18:45] *** scsix left
[18:45] <b2gills> ( except for some 32-bit processors which didn't have native 64-bit integers. I think the 80286 was an example )

[18:53] *** dj_goku_ left
[18:54] <flussence> .oO( why didn't 64-bit use 32-bit near pointers? We could've avoided that x32 thing entirely... )

[19:02] *** dj_goku joined
[19:04] *** rindolf left
[19:14] *** raiph joined
[19:14] *** Alina-malina left
[19:17] *** xfix left
[19:18] *** berekuk left
[19:21] *** kjs_ joined
[19:24] <b2gills> Because 32-bit and 64-bit x86 processors use virtual addressing, all programs have access to what they "think" is all of the memory of the computer ( possibly to even more memory than is actually installed with page swapping ). There is little point to have different near pointers and far pointers when two pages that seem to be far apart, may in fact be right next to each other in RAM. It also probably simplified the logic in the processor f

[19:26] <b2gills> Also since 32-bit had the same size for near and far pointers, it makes little sense for AMD to have added that to 64-bit mode.

[19:28] *** Sqirrel joined
[19:30] *** konsolebox left
[19:37] *** kjs_ left
[19:40] *** jakesyl_insomnia left
[19:42] *** jakesyl_insomnia joined
[19:42] <moritz>  

[19:43] *** [Sno] joined
[19:47] *** sirdancealot left
[19:52] *** kaare__ joined
[20:02] *** FROGGS_ left
[20:02] <dalek> roast: c8e2a0c | usev6++ | S12-enums/misc.t:

[20:02] <dalek> roast: Add test for RT #123114

[20:02] <dalek> roast: review: https://github.com/perl6/roast/commit/c8e2a0c051

[20:02] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123114

[20:02] *** FROGGS_ joined
[20:07] *** Mouq joined
[20:15] *** darutoko left
[20:21] <masak> b2gills: in what situations would it be useful to have a native Perl 6 type the size of a far pointer?

[20:39] *** denis_boyun_ joined
[20:48] *** spider-mario left
[20:49] *** raiph left
[20:50] *** spider-mario joined
[20:54] *** kurahaupo1 joined
[20:56] *** brrt joined
[20:58] <avuserow_> Hi all. Is there any way to get logs for a module's test failures on smoke.perl6.org?

[20:59] *** mvuets left
[20:59] <avuserow_> I'm trying to get Compress::Snappy to passing, and I'm not able to reproduce the failure locally, so I wonder if its C library isn't installed

[21:03] *** kurahaupo1 is now known as kurahaupo

[21:03] *** [Sno] left
[21:03] <brrt> lizmat - seems mkdir fails for me (linux)

[21:03] <FROGGS_> avuserow_: you'd have to ask colomon

[21:03] *** [Sno] joined
[21:05] *** virtualsue left
[21:06] *** raiph joined
[21:09] *** kjs_ joined
[21:11] <b2gills> Masak: for NativeCall on 32-bit x86 processors where `int` should be a 64-bit type

[21:12] <masak> oh, nativecall.

[21:12] <masak> that makes sense.

[21:13] *** kjs_ left
[21:15] <arnsholt> ATM int is int64_t on all platforms, IIRC

[21:15] *** broski joined
[21:18] <brrt> b2gills - i'd argue if possible against a lot of effort for 32 bit x86 

[21:21] *** kjs_ joined
[21:22] *** raiph left
[21:31] *** raiph joined
[21:32] *** kjs_ left
[21:33] *** raiph left
[21:38] <ugexe> is 'or' supposed to be required to be on the same line as a closing bracket? try { say 1 } or die; says undeclared routine 'or' if there is a line break before the 'or'

[21:40] <lizmat> ugexe: I guess that's a consequence of the fact that a closing curly brace at the end of the line signifies end of statement

[21:40] <vendethiel> no, that's why we have semicolons

[21:40] <vendethiel> mmh

[21:40] *** kurahaupo left
[21:41] <FROGGS_> lizmat is right

[21:41] <FROGGS_> m: my $h = { a => 42 }␤say $h

[21:41] <camelia> rakudo-moar 319c9c: OUTPUT«a => 42␤»

[21:41] <lizmat> m: try { say 1 }; or die   # same error

[21:41] <camelia> rakudo-moar 319c9c: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/TAQhWubnjA␤Undeclared routine:␤    or used at line 1. Did you mean 'on'?␤␤»

[21:42] <FROGGS_> m: try { say 1 }\␤or die

[21:42] <camelia> rakudo-moar 319c9c: OUTPUT«1␤»

[21:42] <dalek> rakudo/nom: 98b23d6 | lizmat++ | src/core/Str.pm:

[21:42] <dalek> rakudo/nom: Make smartmatch on Str about 40% faster

[21:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/98b23d6208

[21:42] <FROGGS_> you can unspace it though if you want

[21:43] <ugexe> aha cool

[21:44] <FROGGS_> m: try { say 1 } \␤or die # I'd probably put another space there... I do like whitespace :o)

[21:44] <camelia> rakudo-moar 319c9c: OUTPUT«1␤»

[21:44] <b2gills> brrt: You're assuming that's the only architecture that we may want to support where the pointer size is something other than the largest full speed integer (`int`)

[21:45] <broski> i have some questions, may sound total noobe but I'm curious

[21:45] <brrt> no, i'm assuming that if we want to get 6.0 out the door, supporting umpteen different architectures while everybody's running x64 may be a distraction :-)

[21:46] <brrt> although the fact that we're talking about it is a pretty good sign

[21:46] <brrt> b2gills ^

[21:46] <brrt> broski: fire away :-)

[21:46] <broski> :D

[21:46] <timotimo> heyo brrt

[21:46] <brrt> \o timotimo

[21:46] <broski> brrt: wondering, why are there choices for different backends

[21:46] <brrt> you on #moarvm? could you possibly comment on the repr op devirt issues

[21:47] <brrt> that's a good question broski :-)

[21:47] <brrt> basically we distinguish between perl6-the-language and perl6-the-compiler

[21:47] <FROGGS_> broski: rakudo started with only one backend (Parrot), but the goal was to support several, like the JVM to get a foot in that market

[21:48] <brrt> and there have been many compilers

[21:48] <timotimo> today i've been wondering, idly, about how to build stuff like "first we look for this constant string that we know follows after a known-length regex, and then we skip back a bit and match the other stuff in the regex"

[21:48] *** Alina-malina joined
[21:48] <FROGGS_> broski: and when Parrot still was too slow and now sign of major improvements were seen, MoarVM was started to please rakudo's needs

[21:49] <brrt> basically, each backend has a different stability / feature profile

[21:49] <broski> i see

[21:49] <Mouq> timotimo: I was also wondering last week if there was an opt we could do, where if we see /…foo$/ we could just skip to the end of the string

[21:50] <FROGGS_> broski: you could watch this: https://www.youtube.com/watch?v=XgPh5Li3k4g

[21:50] <timotimo> ah, yes indeed

[21:50] <timotimo> Mouq: if you want, go ahead ;)

[21:51] <FROGGS_> broski: also, here is a nice collection: https://www.youtube.com/watch?v=YW75CXY-P3M&list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK

[21:51] *** donaldh joined
[21:52] * Mouq is still trying to figure out QRegex and repr AST :P

[21:52] <timotimo> "repr AST"?

[21:52] <Mouq> s/AST/NFA

[21:52] <timotimo> oh, hehe.

[21:52] <Mouq> Too many acronyms man

[21:52] <timotimo> TMAM

[21:52] <Mouq> :9

[21:53] <timotimo> well, as long as you don't invent new types or subtypes for regexes, you don't need to do anything with the NFA generator/runner 

[21:53] <broski> those are great resources, thanks, they are bookmarked

[21:53] <broski> ^^ FROGGS_:

[21:53] <FROGGS_> :o)

[21:54] <donaldh> In NQP, is it possible for a role's method to call the method it replaces on the class the role gets applied to?

[21:54] <Mouq> timotimo: I do think it would be much less misleading if we called QRegex::NFA QRegex::NFAGenerator or the like

[21:55] <Mouq> org.perl6.nqp.qregex.nfa.factory

[21:55] <donaldh> Specifically, QAST::Children.shallow_clone replaces QAST::Node.shallow_clone and I'd like to call the original.

[21:56] <timotimo> that's in nqp?

[21:57] <donaldh> yep

[21:57] <timotimo> i know in perl6 you can specify precisely by putting the name of the class you want into the method name part

[21:57] <timotimo> not 100% sure what it looks like, haven't ever used it so far

[21:59] <Mouq> foo.Class::bar, isn't it?

[22:00] <donaldh> so maybe self.QAST::Node::shallow_clone() ?

[22:00] <timotimo> that's what i thought

[22:03] *** raiph joined
[22:04] *** lue left
[22:05] *** kurahaupo joined
[22:08] <dalek> rakudo/nom: 04ce883 | lizmat++ | src/core/Str.pm:

[22:08] <dalek> rakudo/nom: Make Int ~~ "a" silent and faster

[22:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/04ce883ce5

[22:08] *** berekuk joined
[22:11] *** jack_rabbit joined
[22:12] <dalek> rakudo/newio: 574192c | ab5tract++ | src/core/set_operators.pm:

[22:12] <dalek> rakudo/newio: on our way to first class hashes

[22:12] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/574192c4c3

[22:12] <dalek> rakudo/newio: a5a1832 | ab5tract++ | src/core/set_operators.pm:

[22:12] <dalek> rakudo/newio: baggy handling of ops now takes mixes into account

[22:12] *** dalek left
[22:13] <lizmat> sorry dalel

[22:13] <lizmat> *dalek

[22:13] *** dalek joined
[22:13] *** ChanServ sets mode: +v dalek

[22:14] <dalek> specs/newio: 0e734c4 | lizmat++ | S32-setting-library/IO.pod:

[22:14] <dalek> specs/newio: Got as far as mkdir()

[22:14] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/0e734c4d55

[22:18] *** lue joined
[22:18] <FROGGS_> donaldh: in nqp you'd do: nqp::findmethod(...)(args)

[22:18] <FROGGS_> donaldh: grep for that

[22:19] <timotimo> good point

[22:19] <FROGGS_> the foo.class::routine doesn't work in nqp AFAIK

[22:20] <donaldh> no it doesn't :)

[22:20] <FROGGS_> and using findmethod you can provide an object and a type

[22:22] *** virtualsue joined
[22:24] *** kurahaupo left
[22:24] <donaldh> Hmm. findmethod only takes an object and a method name

[22:25] <timotimo> does findmethod return the invocable object or just the "slot number" or something?

[22:31] *** colomon left
[22:31] *** jbotz joined
[22:32] <donaldh> I suspect I am discovering why the code is the way it is.

[22:32] <jbotz> hello...

[22:32] <jbotz> newbie here...

[22:32] <masak> welcome.

[22:33] <jbotz> i'm studying, and I'm curious about something...

[22:33] <jbotz> what should be the value of a for statement?

[22:33] <masak> depends a little.

[22:33] <jbotz> i.e. should "say for 1..5" output anything?

[22:34] <masak> that doesn't mean what you think it means

[22:34] <jbotz> I don't think anything...

[22:34] <lizmat> good night, #perl6!

[22:34] <jbotz> but I saw this in the perl docs...

[22:34] <timotimo> correct, this is a case of an "after statement" for loop

[22:35] <jbotz> sub divisors (Int $n) { $_ if $n %% $_ for 1..$n }

[22:35] <brrt> good night lizmat

[22:35] <timotimo> so it'll just do "say" the 5 times

[22:35] <masak> except it's disallowed :/

[22:35] <jbotz> oh, got it

[22:35] <timotimo> usually the result of a for loop is the list of what the last statement inside the for loop's block gives you

[22:36] *** kjs_ joined
[22:36] <jbotz> ok, but the sub divisors doesn't work in rakudo

[22:36] <masak> no, it doesn't

[22:36] <masak> need parens around that statement

[22:36] <masak> used to work

[22:36] <masak> spec changed

[22:36] <timotimo> good to know

[22:37] <jbotz> ok, got it... with parens it works!

[22:37] <timotimo> please provide a link to where you found that so we can fix it

[22:37] <raiph> m: for Array.new(1,2), Buf.new(1,2) { say .WHAT } # rakudobug? specbug?

[22:37] <camelia> rakudo-moar 04ce88: OUTPUT«(Int)␤(Int)␤(Buf)␤»

[22:37] <timotimo> m: say Array ~~ Iterable; say Buf ~~ Iterable

[22:37] <camelia> rakudo-moar 04ce88: OUTPUT«True␤False␤»

[22:38] <timotimo> m: say Array ~~ Positional; say Buf ~~ Positional

[22:38] <camelia> rakudo-moar 04ce88: OUTPUT«True␤True␤»

[22:38] <raiph> a Buf is a role, whereas an Array is a class

[22:38] <timotimo> so ... ?

[22:38] <masak> raiph: for all I know it's correct

[22:38] <jbotz> timotimo: http://doc.perl6.org/type/Signature

[22:39] <jbotz> the part about type constraints

[22:39] <masak> jbotz++

[22:39] <timotimo> heh. in a totally unrelated chapter of the docs it b0rks :\

[22:40] <timotimo> it's hard to keep all the docs up to date to every change :(

[22:40] <timotimo> anyway, it's bedtime for me now

[22:40] <timotimo> good night :)

[22:41] <raiph> timotimo: I was asking why Array does Positional as I'd expect but Buf doesn't, even though it `does Blob` which `does Positional`

[22:41] *** kjs_ left
[22:44] *** BenGoldberg left
[22:54] *** kurahaupo joined
[22:54] <brrt> TimToady's talk has been moved to sunday?

[22:56] *** BenGoldberg joined
[22:56] <masak> 'night, #perl6

[23:00] <b2gills> jbotz: `.say for 1..5` is another way of writing `for 1..5 { .say }` ( copied from Perl5 )

[23:00] <b2gills> The `.say` is short for `$_.say`

[23:01] <b2gills> or `say $_`

[23:02] *** brrt left
[23:05] <b2gills> jbotz: That sub could have been written: `sub divisors (Int $n){ (1..$n).grep( {$n %% $_} ) }`

[23:19] <broski> just read about junctions

[23:20] <broski> m: sqrt(4|9|16).say

[23:20] <camelia> rakudo-moar 04ce88: OUTPUT«any(2, 3, 4)␤»

[23:20] <broski> nice

[23:21] *** telex left
[23:22] *** telex joined
[23:28] <broski> I have a question!

[23:33] *** spider-mario left
[23:34] *** broski left
[23:43] <FROGGS_> broski: just ask... someone will reply, even when not immediately

[23:50] *** jbotz left
[23:53] *** Ugator left
[23:58] *** denis_boyun_ left
