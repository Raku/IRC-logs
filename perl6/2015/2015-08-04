[00:00] <Zoffix> Sounds scary :)

[00:02] <timotimo> lucasb: maybe the combinations method should flat-out throw an exception if it gets an Index instance? :P

[00:03] <TimToady> m: say <a b c>.combinations("0").perl

[00:03] <camelia> rakudo-moar a38b59: OUTPUT«Cannot call combinations(Str: Str, Str, Str); none of these signatures match:␤    (List $: Int $of, *%_)␤    (List $: Range $ofrange = { ... }, *%_)␤  in block <unit> at /tmp/JxchiHTiyJ:1␤␤»

[00:03] <timotimo> as it makes no sense to get as many items in the combinations as the position of something in some string is ...

[00:03] <lucasb> In the specific case of .combinations, the simple fix would be a line like "return ((),) if $k == 0"

[00:04] <lucasb> timotimo: I know my example was contrived :)

[00:05] <lucasb> but maybe there are other places that accepts a Int and tests it with 'if $n' or 'unless $n' ...

[00:05] <Sgeo> Maybe 0 should just be truthy

[00:05] <TimToady> I was leaning toward ifdef/whiledef until I realized whiledef doesn't help much, since whiledef "abc".index('a',$pos) -> $pos {...} doesn't actually work

[00:05] <Sgeo> Or maybe there should be an if-defined function that passes to a pointy block the result

[00:05] <timotimo> Sgeo: not in general, no

[00:06] <timotimo> if-defined doesn't help, i don't think

[00:06] <timotimo> er, wait, yeah it does

[00:06] <timotimo> time for me to get some rest

[00:06] <b2gills> If combinations coerced to Int it would work as is

[00:06] <TimToady> ifdef index "abc",index('a') -> $pos {...} is okay

[00:06] <TimToady> er

[00:07] <TimToady> ifdef "abc".index('a') -> $pos {...} is okay

[00:07] <Sgeo> Maybe if could be flexible in some way that allows both transforming into something for a truthy test and keeping the original

[00:07] <TimToady> since you're not trying to feed $pos back into the index

[00:07] <b2gills> m: say "abc".index('a').Int.^name

[00:07] <camelia> rakudo-moar a38b59: OUTPUT«Int␤»

[00:08] <timotimo> schwartzian conditional

[00:08] <Sgeo> Actually sounds a bit like when if it wasn't too overly elaborate to do the given or $_ assign

[00:08] <b2gills> m: my $i = "abc".index('a'); say so $i; say so $i.Int

[00:08] <camelia> rakudo-moar a38b59: OUTPUT«True␤False␤»

[00:09] <TimToady> really, we should just have a version of index that returns all the entries as a list, and not try to use explicit pos for that

[00:10] <TimToady> then it's just: for "abc".indices('a') {...}

[00:10] <dha> So. If I were to change the -M section in 5to6.pod, should I do it directly to the main repo, or fork and put in a pull request for someone else to review and change?

[00:11] <TimToady> forgiveness > permission

[00:11] *** laouji joined
[00:12] <dha> All right, then. :-)

[00:12] <TimToady> the only downside is you have to be prepared to be forgiven :)

[00:14] <timotimo> good night everybody!

[00:14] <dha> night timotimo 

[00:16] *** mohij left
[00:16] <tony-o> how do we get blog posts up in p6 weekly/?

[00:19] <flussence> step 1: get noticed, step 2: ???

[00:20] <tony-o> cool

[00:20] <tony-o> super cool

[00:21] <flussence> that's about it, I've been mentioned there without any interaction

[00:21] <dha> step 3: Profit!

[00:21] <ShimmerFairy> TimToady: I think I like the sound of indices, and testing its size to see if anything's found (and maaaaybe get rid of index in favor of specifying from which direction with first-/last-index ?)

[00:21] <b2gills> There is a question about "How to get start with Perl6?" on StackOverflow if someone wants to add anything https://stackoverflow.com/q/31791362/1337 No account necessary, unless you want those sweet rep points

[00:27] *** BenGoldberg joined
[00:28] <TimToady> ShimmerFairy: I run with t/spec linked into roast

[00:29] <TimToady> works fine

[00:29] <ShimmerFairy> TimToady: I set that up, I just have to be careful about git clean -dfx now :)

[00:30] <TimToady> yeah, I never do that

[00:30] * TimToady leaves too much tmp stuff sitting around for that

[00:33] <ShimmerFairy> btw, it seems first-index is broken:

[00:33] <ShimmerFairy> m: say "abc".first-index("a"); say "abc".index("a")

[00:33] <camelia> rakudo-moar a38b59: OUTPUT«Nil␤0␤»

[00:33] <dha> I have a note here that you can still "no" a pragma in Perl 6, but not a module. Is that, in fact, correct?

[00:34] <TimToady> yes, we generally rely on lexical scoping for limiting the scope now

[00:34] <TimToady> since imports are lexical

[00:34] <dha> *nod* thanks.

[00:36] <dalek> doc: 8c725bf | (David H. Adler)++ | lib/Language/5to6.pod:

[00:36] <dalek> doc: Changed 5to6.pod to reflect the actual status of -M/-m

[00:36] <dalek> doc: review: https://github.com/perl6/doc/commit/8c725bf579

[00:36] <ShimmerFairy> I almost want pragmas to have a different syntax from modules, unless pragmas are supposed to be vaguely module-esque (as I understand it, currently pragmas just flip switches in P6's grammar)

[00:36] *** lucasb left
[00:37] <b2gills> pragmas in Perl 5 are modules

[00:37] * skids wonders if a camelia directive could be spun up with jnthn++s GLR code loaded.

[00:37] <ShimmerFairy> .oO(  no warnings; ... { yes warnings; ... }  )

[00:39] *** laouji left
[00:40] *** laouji joined
[00:40] <ShimmerFairy> Unless Perl 6 is still planned to allow pragmas written by external sources in the form of modules, I think it'd be nice if pragmas looked a bit different from modules in usage.

[00:42] *** laouji left
[00:42] *** laouji joined
[00:51] <Sgeo> m: if 0 -> $x { say "o.O"; } else { say $x; }

[00:51] <camelia> rakudo-moar a38b59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/GtXcNRyoHh␤Variable '$x' is not declared␤at /tmp/GtXcNRyoHh:1␤------> 3if 0 -> $x { say "o.O"; } else { say 7⏏5$x; }␤»

[00:51] <Sgeo> m: if 0 -> $x { say "o.O"; } else -> $x { say $x; }

[00:51] <camelia> rakudo-moar a38b59: OUTPUT«0␤»

[00:51] <Sgeo> :)

[00:51] <ShimmerFairy> m: if (42 but False) -> $x { say "o.O"; } else -> $x { say $x; }

[00:51] <camelia> rakudo-moar a38b59: OUTPUT«42␤»

[00:51] <ShimmerFairy> huh, didn't expect that to work :)

[00:52] <ShimmerFairy> m: if (42 but False) -> $x { say "o.O"; } elsif (21 but False) { say "still o.O" } else -> $x { say $x; }

[00:52] <camelia> rakudo-moar a38b59: OUTPUT«21␤»

[00:53] <ShimmerFairy> looks like 'else' gets passed the last branch's test. Not sure if that's a bug or not though :)

[00:55] *** llfourn joined
[01:01] *** llfourn left
[01:02] <Sgeo> Maybe the first way is best, if if is going to stay magic

[01:03] <Sgeo> So you could get each test's value in later tests

[01:03] <Sgeo> But then you lose the idea of pointy blocks for if

[01:04] <TimToady> we will never scope a variable to outside its block like that

[01:04] <TimToady> the only exception is signature declarations like that

[01:04] <TimToady> but P5's mysterious extra scopes are not gonna happen in P6

[01:04] <ShimmerFairy> so else getting a previous test value is a bug, I take it?

[01:05] <Sgeo> else getting a previous test value can be useful though, e.g. if you're testing for valuable or failure

[01:05] <Sgeo> But getting only the previous one seems limiting

[01:09] <TimToady> the main use case does not care about elsif

[01:09] <TimToady> ShimmerFairy: not a bug, since you pass it explicitly

[01:09] *** yeahnoob joined
[01:11] <Sgeo> m: if Mu but True { say "Mu but True"; } else { say "Mu but True is falsey?"; }

[01:11] <camelia> rakudo-moar a38b59: OUTPUT«Mu but True␤»

[01:12] <Sgeo> Does that make a new Mu or a shim around Mu or something?

[01:13] <ShimmerFairy> My random guess as to what's happening is that, since the if/elsif/else construction is taken as one expression, said construction keeps around just one 'condtional' value across the branches, writing it with whatever the latest result is.

[01:14] <geekosaur> http://design.perl6.org/S12.html#Anonymous_Mixin_Roles_using_but_or_does

[01:14] <[Coke]> m: (Mu but True).perl.say

[01:14] <camelia> rakudo-moar a38b59: OUTPUT«Mu+{<anon>}␤»

[01:14] * geekosaur should probably use the Snn:ll syntax but looked it up in the html, not the text

[01:14] <geekosaur> anyway it's an anonymous mixin

[01:18] *** dha left
[01:18] *** dayangkun joined
[01:19] *** dha joined
[01:24] *** rmgk_ joined
[01:24] *** rmgk is now known as Guest93505

[01:24] *** Guest93505 left
[01:24] *** rmgk_ is now known as rmgk

[01:27] *** dha left
[01:34] <tony-o> m: say "hello".^can('something');

[01:34] <camelia> rakudo-moar a38b59: OUTPUT«␤»

[01:34] <tony-o> m: say "hello".^can('something'); say 'hello'.^can('something').DEFINED;

[01:34] <camelia> rakudo-moar a38b59: OUTPUT«␤Method 'DEFINED' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/oH9eGctttL:1␤␤»

[01:34] <tony-o> m: say "hello".^can('something'); say 'hello'.^can('something').DEFINITE;

[01:34] <camelia> rakudo-moar a38b59: OUTPUT«␤True␤»

[01:35] <japhb> m: say "hello".^can('something').WHAT;

[01:35] <yoleaux> 2 Aug 2015 07:47Z <azawawi> japhb: re your discussion with timotimo++ about Electron. It is basically chrome + nodejs + API which we are accessing via JSON::RPC. We're setting up a nodejs jsonrpc server and using it via JSON::RPC and wrapping all into lovely p6 classes :)

[01:35] <camelia> rakudo-moar a38b59: OUTPUT«(Parcel)␤»

[01:35] <yoleaux> 2 Aug 2015 07:48Z <azawawi> japhb: examples are found here https://github.com/azawawi/perl6-atom-electron/tree/master/examples

[01:36] <japhb> tony-o: ^^ That's why, .^can is returning all matches, so always a list-like thing (a Parcel, pre-GLR)

[01:36] <tony-o> i'm more trying to figure out what .DEFINITE does

[01:37] <japhb> tony-o: If it's an instance, not a type object.

[01:37] <tony-o> i saw it somewhere that i thought was getting false positives

[01:37] <japhb> This is faster than .defined, and also not overridden by adding a 'method defined'

[01:38] <japhb> .tell azawawi Ah, thank you for the Electron info!

[01:38] <yoleaux> japhb: I'll pass your message to azawawi.

[01:39] <tony-o> makes sense why with a parcel it gets True where I'd not suspect it

[01:39] <tony-o> then, thanks japhb 

[01:39] <japhb> yw!

[01:46] *** colomon left
[01:47] *** colomon joined
[01:49] <Sgeo> Can .DEFINITE be overridden?

[01:56] <Sgeo> "X::ControlFlow

[01:56] <Sgeo> Thrown when a control flow construct (such as next or redo) is called outside the dynamic scope of an enclosing construct that is supposed to catch them."

[01:56] <Sgeo> next is dynamically scoped?

[01:56] <TimToady> no, .DEFINITE is quite primitive

[01:57] <Sgeo> m: sub foo() { next; }; for 1, 2 { foo(); say "Did foo()"; }

[01:57] <camelia> rakudo-moar a38b59: ( no output )

[01:57] <Sgeo> m: sub foo() { }; for 1, 2 { foo(); say "Did foo()"; }

[01:57] <camelia> rakudo-moar a38b59: OUTPUT«Did foo()␤Did foo()␤»

[01:58] <TimToady> default next is dynamic, with lable, lexotic

[01:58] <TimToady> *label

[01:59] <TimToady> (a bit distracted)

[01:59] *** yqt left
[02:02] *** roguelazer left
[02:02] *** roguelazer joined
[02:03] <Sgeo> "No compiler compiler available for language '$.lang'";

[02:06] *** EINVAL joined
[02:14] *** EINVAL left
[02:16] <Sgeo> m: say &lol

[02:16] <camelia> rakudo-moar a38b59: OUTPUT«sub lol (*@l) { #`(Sub|60094288) ... }␤»

[02:23] <labster> m: lol lol lol lol &lol

[02:23] <camelia> rakudo-moar a38b59: ( no output )

[02:30] *** gfldex joined
[02:38] *** BenGoldberg left
[02:40] *** llfourn joined
[02:45] *** noganex_ joined
[02:47] *** noganex left
[03:28] *** nys left
[03:42] *** khw joined
[03:44] *** kaare_ joined
[03:50] <rangerprice> so

[03:51] <skids> sooo....?

[03:52] *** gfldex left
[03:59] *** cognominal left
[03:59] <labster> m: say so .WHAT

[03:59] <camelia> rakudo-moar a38b59: OUTPUT«False␤»

[04:17] <rangerprice> so i love Perl

[04:19] <Sgeo> So, when does @foo expand in an argument list and when does it not? Does it only expand when it's where a slurpy is?

[04:22] *** gfldex joined
[04:25] *** khw left
[04:27] <Sgeo> m: {$_}.WHAT

[04:27] <camelia> rakudo-moar a38b59: ( no output )

[04:27] <Sgeo> m: say {$_}.WHAT

[04:27] <camelia> rakudo-moar a38b59: OUTPUT«(Block)␤»

[04:31] *** davido__ left
[04:33] *** davido__ joined
[04:33] <Sgeo> Hrm, there are a lot of identity-like functions :/

[04:34] *** davido__ left
[04:36] *** davido__ joined
[04:41] *** ChoHag joined
[04:49] *** beastd left
[04:58] <skids> Sgeo: post-GLR flattening behavior was first described here: http://pmthium.com/2014/10/apw2014/ then modified slightly here: https://github.com/perl6/specs/blob/master/S07-glr-draft.pod and jnthn++s gist today is showing the first bits of an implementation prototype: https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[04:59] <Sgeo> ty

[05:05] <rangerprice> Bye ! 

[05:07] <Sgeo>     Seq is not Positional, thus cannot be bound to array variables.

[05:07] *** rangerprice left
[05:07] <Sgeo> That's different from current behavior with := lazy stuff, right?

[05:13] <TimToady> yes, but we have to get better control of which types cache values

[05:14] <Sgeo> Will slips have syntax sugar?

[05:14] <TimToady> we might be able to unify them with |

[05:14] <Sgeo> I think I can imagine if slips were the only things that got flattened

[05:14] <Sgeo> or... flattened's the wrong word there, but if we have slips do we need flattening?

[05:15] <TimToady> slip is one level, flattening is recursive

[05:18] *** skids left
[05:51] *** nightfrog left
[05:53] *** llfourn left
[06:13] *** llfourn joined
[06:25] <ChoHag> Perl#s running out of symbols.

[06:28] <ChoHag> ⌤

[06:36] *** nightfrog joined
[06:37] <moritz> jnthn++ # https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9

[06:42] <moritz> eeks

[06:42] <moritz> moritz@pat:~$ dig www.bitcard.org +short

[06:42] <moritz> moritz@pat:~$ 

[06:42] <moritz> so, no bitcard login to rt.perl.org :(

[06:43] *** FROGGS joined
[06:46] * moritz wanted to reject https://rt.perl.org/Public/Bug/Display.html?id=125745

[06:47] <FROGGS> "You shall implement an ACCEPTS method"

[06:48] <ChoHag> Well now you'll have to fix it than.

[06:49] *** azawawi joined
[06:49] <moritz> ok, answered by email; I hope to be able to log in later

[06:49] *** TEttinger left
[06:50] <moritz> (asking the authorotative DNS server gives an answer for www.bitcard.org, so I guess it's only a caching issue right now)

[06:51] <moritz> ok, DNS works again

[06:57] <ChoHag> How can I have class Foo in Foo.pm and class Bar in Bar.pm where they both depend on each other?

[06:57] <ChoHag> If they were in the same file I could stub one and it'd be fine, but use-ing the files falls over.

[06:58] <FROGGS> you cant

[06:59] <ChoHag> That's not the sort of thing I expect to hear in relation to perl.

[06:59] <FROGGS> you can stub Foo in Bar.pm, declare Bar and use Foo, but Foo won't know about Bar

[07:00] <FROGGS> the thing is that we have compilation units

[07:00] <FROGGS> and when you compile Foo, all the symbols it knows about must be resolved

[07:00] <FROGGS> so, the only way is to put both in the same compilation unit (file)

[07:09] *** rurban_ joined
[07:10] *** rurban joined
[07:17] *** telex left
[07:17] *** llfourn left
[07:18] *** telex joined
[07:19] *** darutoko joined
[07:22] *** llfourn joined
[07:24] *** brrt joined
[07:25] <nine> .tell dha please merge your 5-to-6 docs into docs.perl6.org. Yesterday I would have had a use for it but couldn't find it. 

[07:25] <yoleaux> nine: I'll pass your message to dha.

[07:26] *** RabidGravy joined
[07:26] *** zakharyas joined
[07:27] <azawawi> hi

[07:27] <yoleaux> 01:38Z <japhb> azawawi: Ah, thank you for the Electron info!

[07:27] <azawawi> how do i .can('sub') on a module?

[07:27] <RabidGravy> marnin!

[07:29] *** simcop2387 joined
[07:29] <azawawi> i.e. test whether subs exist in a module or not. Any example?

[07:30] <labster> moritz: I rejected your rejection.  If there aren't any uses of declaring a new infix:<~~> that will ever work, I think we need a warning message.

[07:34] <RabidGravy> azawawi, something like this perhaps?

[07:34] <RabidGravy> m: module B { our sub c() {} }; say &B::c.defined'

[07:34] <camelia> rakudo-moar a38b59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LEWYcVTr2o␤Two terms in a row␤at /tmp/LEWYcVTr2o:1␤------> 3 B { our sub c() {} }; say &B::c.defined7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»

[07:34] <RabidGravy> m: module B { our sub c() {} }; say &B::c.defined

[07:34] <camelia> rakudo-moar a38b59: OUTPUT«True␤»

[07:34] <nine> m: module B { our sub c() {} }; say &B::d.defined

[07:34] <camelia> rakudo-moar a38b59: OUTPUT«False␤»

[07:35] <RabidGravy> has to be an "our" tjough

[07:36] <nine> Which is only logical. Why should you be able to test existence of a function you are not supposed to see?

[07:36] <RabidGravy> oh yeah

[07:41] <azawawi> RabidGravy: thx

[07:54] *** azawawi left
[08:04] *** pdcawley joined
[08:10] *** zakharyas left
[08:11] *** llfourn left
[08:12] *** rurban left
[08:13] *** zakharyas joined
[08:16] *** zakharyas left
[08:16] *** zakharyas joined
[08:18] *** rurban joined
[08:34] *** mr-foobar left
[08:35] *** ponbiki_ left
[08:35] *** oha left
[08:35] *** SHODAN left
[08:35] *** Ulti left
[08:35] *** Sgeo left
[08:35] *** [Coke] left
[08:35] *** Util left
[08:37] *** ponbiki_ joined
[08:37] *** oha joined
[08:37] *** Ulti joined
[08:37] *** SHODAN joined
[08:37] *** Sgeo joined
[08:37] *** [Coke] joined
[08:37] *** Util joined
[08:37] *** agentzh joined
[08:37] *** Possum joined
[08:37] *** shmibs joined
[08:37] *** Celelibi joined
[08:37] *** bloonix joined
[08:37] *** ilbelkyr joined
[08:37] *** garu joined
[08:37] *** japhb joined
[08:37] *** sjn joined
[08:37] *** ruoso joined
[08:40] <jnthn> I don't think we should confuse flattening into a caller argument list with slip construction comfortably

[08:40] <jnthn> uh, could ... comfortably

[08:48] *** Mhoram left
[08:49] *** Mhoram joined
[08:56] *** vytas`` joined
[08:56] *** vytas`` left
[09:01] <ChoHag> Can you have a private and public method of the same name & signature, such that calls from within the class call the private and external code the public?

[09:09] <jnthn> Sure

[09:10] <jnthn> Note the syntax for calling a private is different

[09:10] <jnthn> So there's no ambiguity

[09:20] *** brrt left
[09:30] <Woodi> hi #perl6 :)

[09:31] <Woodi> do slip needs to be some data structure ? flat isn't...

[09:32] *** Abc333 joined
[09:33] *** laouji left
[09:33] <Woodi> and realy do not know why  @a = [1,2], [3,4] # 4 elems  is big deal. on how many levels it is bad or something ?

[09:34] * Woodi checked what Perl5 is doing in  = @b, @c  case and it slipped into WHAT IT IS DOING ?? ;)

[09:36] *** |Tux| joined
[09:36] <jnthn> Actually I think flat will return a Slip

[09:38] <jnthn> I don't think looking at "what does Perl 5 do here" is very useful. We've already very well established through the nearly-double-digit previous number of list implementations that we don't want those kinds of implicit flattening semantics.

[09:40] *** virtualsue joined
[09:41] <ChoHag> To be honest what perl 5 does with lists isn't all that useful in itself.

[09:43] <ChoHag> I've thought "I've got to disrupt the flow and pass and then unwrap a bloody reference again" far more than "Oh how useful - I never wanted a discrete variable anyway"

[09:43] <Woodi> umm, think I just wrote it wasn't helpful :)  Perl5 just consumed @c...

[09:43] <Woodi> but "To concatenate two lists/arrays use flat" is weird...

[09:44] <ChoHag> "Flatten two adjacent lists into one" isn't that weird.

[09:45] <jdv79> tony-o: what is wrong with the existing grammar tut?

[09:45] <Woodi> and I'm not talking about eg. @b bying [1,[2,3]] but just [1,2,3]... maybe this is problem ?

[09:45] <ChoHag> And having a distinction between "append this list onto that list" and "append the contents of this list onto that list" is useful and also non-weird.

[09:45] *** rindolf joined
[09:46] <Woodi> also there was a problem with Nil elements in lists in some cases. probably "slip them" was orginal recipe...

[09:47] <jnthn> The new implementation doesn't take any interest in Nil 

[09:47] <jnthn> The only thing that'll vanish is an empty Slip

[09:47] <Woodi> if you saying that's OK then it's OK :)

[09:48] <jnthn> Well, once Nil was designed to vanish in lists, but then it was decided this wasn't desirable

[09:49] *** yeahnoob left
[09:51] <Woodi> anyway @a = @b, @c # 2 elems is deadly logical :)

[09:52] *** mr-foobar joined
[09:52] <ChoHag> Funny that logic and programming should coincide...

[09:52] <DrForr> So rare nowadays.

[09:52] <ChoHag> (Something about kids and lawns)

[09:53] <huf> plant some kids on my lawn!

[09:54] <DrForr> My brother keeps raving about how with JS nobody needs a server anymore, I keep explaining I want an *interesting* language to work with.

[09:55] <ChoHag> Yeah who wants an internet anyway?

[09:56] <DrForr> Apparently it's node.js all the way down.

[09:59] <DrForr> As I sit here applying "don't repeat yourself" to codebase after codebase.

[10:01] *** mr-foobar left
[10:03] *** mr-foobar joined
[10:03] *** espadrine joined
[10:06] <itz> "You can't adverb that" <=- surely you can't verb an adverb in the error message either?

[10:07] <jnthn> lol

[10:07] <jnthn> But that's verbing a noun

[10:08] <jnthn> Which is well established as productive in English, even is prescriptivists hate it. :)

[10:08] <ChoHag> Winding up language purists is a laudable goal.

[10:08] *** llfourn joined
[10:08] <itz> I can't actually think of a better, short replacement anyway :/

[10:08] <nwc10> or is this a bug report that the error message is LTA because it doesn't mangae to verb an adverb, and acchieve sentience (or something equally terrible)

[10:10] <virtualsue>  i'd say it's not explicable to what i assume is your target audience, e.g. people who are able to write programs and understand english reasonably well :-)

[10:10] <virtualsue> ETOOCUTE

[10:11] <nwc10> I think you're right, and you've expressed it better than me

[10:11] <nwc10> in particular, is it possible to replace "that" in the message with the token that triggered the problem?

[10:12] <virtualsue> that would probably be helpful

[10:12] <jnthn> Uh

[10:12] <jnthn> I'm pretty sure right below that message is a pretty red/yellow/green thingy with an eject system showing exactly where we got confused.

[10:13] <jnthn> *symbol

[10:13] *** llfourn left
[10:13] <nwc10> sorry, fail on my part. I failed to ask "or is it pointing at the offending thingy"?

[10:13] <jnthn> m: say [1, 2, 3]:hmm 

[10:13] <camelia> rakudo-moar a38b59: OUTPUT«Unexpected named parameter 'hmm' passed␤  in block <unit> at /tmp/kj_P8RUVWW:1␤␤»

[10:13] <jnthn> gah :)

[10:13] <jnthn> How do I actually trigger the error...

[10:13] <jnthn> m: class Foo { } :bar

[10:13] <camelia> rakudo-moar a38b59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gm5uh2ic5m␤You can't adverb that␤at /tmp/gm5uh2ic5m:1␤------> 3class Foo { } :bar7⏏5<EOL>␤    expecting any of:␤        pair value␤»

[10:14] <virtualsue> well sorry, i saw that message and it was not helpful

[10:14] <virtualsue> i'm not saying it needs to be fixed ASAP or that it's even a blocker

[10:14] <virtualsue> to anything ever ;-)

[10:15] <jnthn> virtualsue: Was the primary problem not knowing what it meant by "adverb", or that you weren't sure what it thought you were trying to adverb, ooc?

[10:15] <nwc10> I think it would be clearer as "You can't use "bar" as an adverb"

[10:16] <jnthn> If the former we could maybe do "You can't use adverb ':bar' here"

[10:16] <nwc10> (with the usual way of doing quotes, that I don't know how to manage

[10:16] <nwc10> yes, how you said it

[10:16] <virtualsue> i know what adverbs are in english. it wasn't immediately obvious to me what the message meant in the context of the code

[10:16] <jnthn> nwc10: :bar is a perfectly fine adverb; it's the place it's being used that's at issue.

[10:16] <jnthn> I think we could probably include the adverb itself in the error 'cus it's likely short

[10:17] <jnthn> But if we include the entire term the parser took it as applying to, it could be something rather long...

[10:17] <nwc10> the adverb is enough, I think

[10:18] <virtualsue> i'm barely a dabbler in perl6. i'm just possibly about to start learning the new required lingo

[10:18] <ChoHag> With the :.

[10:25] <ChoHag> How do you get construction logic into a role?

[10:26] <ChoHag> Multiple roles' submethod BUILDs conflict with each other.

[10:27] <lizmat> good *, #perl6!

[10:27] <lizmat> ShimmerFairy: re http://irclog.perlgeek.de/perl6/2015-08-04#i_10998537 , first-index takes a list

[10:27] <ChoHag> Can it even be done without the consuming class taking a hand in the resolution?

[10:27] <lizmat> m: "foo".first-index("foo").say

[10:27] <camelia> rakudo-moar a38b59: OUTPUT«0␤»

[10:28] <lizmat> ShimmerFairy: and "foo" is a 1 elem lust

[10:28] <lizmat> *list

[10:28] <lizmat> and then whatever you specify, is smartmatched with each element

[10:28] <lizmat> m: "foo".first-index("bar").say

[10:28] <camelia> rakudo-moar a38b59: OUTPUT«Nil␤»

[10:28] <itz> what about "You can't adverb that - you may need to move your colon" :)

[10:28] <jnthn> ChoHag: We've been discussing submethods role-compose such that you end up with all of them being called

[10:28] <lizmat> m: say "foo" ~~ "bar"

[10:28] <camelia> rakudo-moar a38b59: OUTPUT«False␤»

[10:30] <ChoHag> What's come of the discussions so far?

[10:33] <jnthn> ChoHag: No code :(

[10:34] <jnthn> ChoHag: It's pretty much at the point where we need to try to implement it

[10:34] <ChoHag> What's 'it' then? Each role may have a BUILD submethod which is called in order or something more exotic?

[10:36] <jnthn> ChoHag: I think it's about that.

[10:36] <jnthn> ChoHag: Basically, arranging that find_method ends up containing something that invokes the lot

[10:36] <jnthn> uh, *retruning* something

[10:37] <jnthn> And installs in the method cache

[10:37] <jnthn> Which is how it'll work out most of the time

[10:37] <jnthn> It'll want some care, so we don't break .^lookup (which should probably just go on returning the direct declaration of BUILD in the class, if any)

[10:38] <jnthn> Maybe submethod_table will need breaking up into submethod_table and submethod_invokee_table or so

[10:39] <ChoHag> ... implementation details I grok only by inference.

[10:40] <RabidGravy> in the meantime there is probably some kind of hack you can perform but it's not immediately clear to me

[10:40] <jnthn> ChoHag: These are the names of things that actually show up in the code, which I mention in case anyone wants to grep for them, get to know the code in question, and have a go at it :)

[10:42] <ChoHag> I'd like to have a look (really!) but it's hard enough to do my own thing - which I understand - when I can only code in 5 minute snatches.

[10:42] <ChoHag> I need a lock on my door...

[10:43] <RabidGravy> my intuition is that it would probably involve making a specific trait_mod:<does> for the role itself which creates the method before applying the role

[10:43] <jnthn> RabidGravy: Noh, it'd want handling entirely in the MOP code

[10:44] <jnthn> RabidGravy: In RoleToRoleApplier/RoleToMethodApplier, and then tweaking find_method and publish_method_cache

[10:44] <ChoHag> I think he's talking about the hacky workaround I'm considering whether to avoid writing.

[10:44] <jnthn> Oh... :)

[10:44] <jnthn> Anyway, I can look into it, but first I need to get the GLR stuff sorted-er

[10:45] <RabidGravy> yeah, by way of answering the original question with what is avaulable now ;-)

[10:45] <jnthn> And then want to get the new supply stuff in shape

[10:46] *** sergot_ is now known as sergot

[10:49] *** colomon_ joined
[10:50] *** colomon left
[10:50] *** colomon_ is now known as colomon

[10:50] <jnthn> TimToady: Interestingly it turns out very naturally that flat won't go overly deep on [...] after all. [[1, 2], [3, 4]] actually works out as [$[1, 2], $[3, 4]] because an Array is a set of Scalar containers. So my @a = [1, 2], [3, 4]; my @b = [4, 5], [6, 7]; my @c = flat @a, @b; will end up with @c having 4 elems. Which seems good. :)

[10:51] <jnthn> TimToady: Note that since [[1, 2], [3, 4]] is equivalent to [$[1, 2], $[3, 4]] we can of course .perl to the pretty thing without $$$ everywhere. :) 

[10:53] <ChoHag> Can you ensure that role A is never composed alongside role B?

[10:53] *** colomon left
[10:53] *** colomon joined
[10:58] *** colomon left
[10:58] <jnthn> Hm, I guess...

[10:58] <jnthn> m: role A { }; role B { die 'no!' if any(::?CLASS.^roles_to_compose) ~~ A }; class C does B { }

[10:58] <camelia> rakudo-moar a38b59: ( no output )

[10:58] <jnthn> m: role A { }; role B { die 'no!' if any(::?CLASS.^roles_to_compose) ~~ A }; class C does A does B { }

[10:58] <camelia> rakudo-moar a38b59: OUTPUT«===SORRY!===␤Cannot find method 'role_typecheck_list'␤»

[10:58] <jnthn> Somehow the exception is swallowed and it gets upset

[10:58] <jnthn> But it successfully ensures it :P

[10:59] <ChoHag> heh

[11:00] <jdv79> jnthn++ # concrete glr stuffs

[11:00] *** zakharyas left
[11:00] <jdv79> though the benchs for 1/2 of those were the same or slightly worse here

[11:00] <jdv79> *benches?

[11:00] <jnthn> benchmarks :)

[11:01] <jdv79> yes, those

[11:01] <jnthn> I see one that is worse

[11:01] <jnthn> And a couple of others are a small win

[11:01] <jnthn> And a couple are big wins

[11:01] <jnthn> What they hide is that some of them also involve a notable memory usage decrease.

[11:02] <jnthn> On the one that is worse, I fed it to the profiler. It's suffering mostly out of some sucky code-gen on a hot path.

[11:02] <jdv79> no doubt.  but memory is still cheaper than time:)  probably always will be.

[11:02] <ChoHag> Could/should memore usage not be benchmarked?

[11:03] <jdv79> oh nice

[11:03] <jnthn> ChoHag: Probably, but I'm not going yak shaving...

[11:06] <jnthn> jdv79: I'm not going optimizing particularly hard yet, though. I want to optimize the correct semantics. If we're winning all but one benchmark before optimization, and some of them by a factor of 5-10 or so, then we're not doing bad. :)

[11:07] <timotimo> \o/

[11:07] <timotimo> is the code-gen you've seen Perl6::Optimizer-level stuff?

[11:08] <jnthn> timotimo: More QAST -> MAST level

[11:08] *** llfourn joined
[11:08] <jnthn> timotimo: And not seeing spesh doing the inlining I'd hope

[11:09] <nwc10> jnthn: are you planning to merge after the August release?

[11:09] <jnthn> nwc10: Not sure yet.

[11:09] <jnthn> nwc10: We need to understand how painful the disruption will be.

[11:09] <|Tux|> test             50000    42.285    42.195

[11:09] <|Tux|> test-t           50000    41.911    41.821

[11:10] <|Tux|> jnthn, at least NO slowdown! (even a bit better, but within noise)

[11:10] <jnthn> |Tux|: Nice. Though I don't think I committed anything since you last checked, given I'm working out of repo on the GLR stuff for the moment :)

[11:11] <ChoHag> Oh while I remember, can I test changes to files in src/core or src/Perl6 other than by a full recompile?

[11:11] <jnthn> ChoHag: "make" will compile as little as is actually needed.

[11:11] <jnthn> ChoHag: Which is still an amount

[11:12] <jnthn> ChoHag: For changes to src/core stuff I often find a way to try them out of there first

[11:12] *** rurban left
[11:12] <ChoHag> What way is that?

[11:13] <jnthn> ChoHag: If it's a new sub/method I just try it in a normal code file, or augment the class I would add it to, for example.

[11:13] <ChoHag> Note that I haven't even tried looking yet, so apologies if it's obvious.

[11:13] *** llfourn left
[11:16] *** Psyche^ joined
[11:16] <sergot> hi #perl6 \o

[11:20] *** Psyche^_ left
[11:23] <lizmat> sergot o/

[11:23] <lizmat> long time no see ?

[11:23] <timotimo> jnthn: the QAST -> MAST part isn't what i've been working on recently, right? but maybe it's something you could roughly instruct me to look at?

[11:31] *** rurban joined
[11:31] <sergot> lizmat: \o yeah... I'm not ok with this.

[11:31] *** pdcawley left
[11:31] <sergot> lizmat: I want to come back to you people :)

[11:32] <jnthn> timotimo: Well, looking at the code geneated for pull-one in the map iterator implementation would be a good starting point

[11:32] <timotimo> i'll have a look later

[11:33] <jnthn> The profiler output is telling too

[11:33] <lizmat> sergot: welcome again  :-)

[11:33] <jnthn> You may also play with inlining thresholds

[11:33] <timotimo> right now i'm a bit weirded out by a grammar apparently matching, but then returning (Any) :|

[11:33] <jnthn> Of note, trying to get the size of code post-specialization to be checked against the threshold too

[11:34] *** pdcawley joined
[11:34] <sergot> lizmat: thanks :)

[11:34] <jnthn> 'cus spesh tosses so many checks in a method prelude...

[11:35] *** pdcawley left
[11:35] *** dayangkun left
[11:36] *** rurban left
[11:37] <timotimo> oooh

[11:37] <timotimo> it must be because my custom <ws> wants a \s at the end of the document ... but it's EOF instead

[11:37] <timotimo> yes, that was it

[11:42] <jnthn> Darn. If flat returns a Slip then it's going to have to remember stuff as it flattens.

[11:42] <jnthn> Maybe we don't need it to return a Slip.

[11:43] * jnthn tries it with a Seq, and guesses we'll see if that hurts at some point

[11:45] *** espadrine left
[11:52] *** pdcawley joined
[11:53] *** ttt_ joined
[11:53] *** ttt_ left
[11:57] *** espadrine joined
[11:58] <jnthn> So far so good. Seems I've itemization and flattening working out. :)

[11:59] <jnthn> Lunch time...bbiab

[12:06] *** yqt joined
[12:07] *** xnrand left
[12:08] *** xnrand joined
[12:11] <tony-o> jdv79: nothing is wrong with the existing grammar tutorial, itd be nice to have more than one and something that expands on it and maybe touches on actions..even something trivial like building a hash

[12:12] *** brrt joined
[12:12] <DrForr> Sounds interesting... lunch, then I might settle in for some reading :)

[12:14] *** pdcawley left
[12:22] *** lucasb joined
[12:27] *** xinming_ joined
[12:28] <lucasb> .combinations returns the concatenation of all the 0,1,2..N combinations together. What is your opinion about moving this behavior to .combinations(*) with a Whatever argument? This way, the no-arg error would give a hint to the user that the method accepts a argument, since more commonly he would want a combination of a specific number of 2, 3, etc. elements at a time.

[12:28] *** rurban joined
[12:30] <brrt> seems... perl6-ish

[12:30] <brrt> m: my @a = 1,2,3; say @a.combinations;

[12:30] <camelia> rakudo-moar a38b59: OUTPUT« 1 2 3 1 2 1 3 2 3 1 2 3␤»

[12:30] *** xinming left
[12:30] <timotimo> m: my @a = 1,2,3; say @a.combinations.perl

[12:30] <camelia> rakudo-moar a38b59: OUTPUT«((), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3))␤»

[12:30] <brrt> yeah, that's better :-)

[12:31] <DrForr> That's getting dangerously close to a powerset :)

[12:31] <nine> ChoHag: regarding your Role initializer question. jnthn++ suggested using attribute default setters. And maybe this helps you: https://github.com/niner/Inline-Perl5/blob/master/lib/Inline/Perl5.pm6#L875

[12:32] <brrt> m: my @a = qw(a b c); say @a.combinations(2).perl

[12:32] <camelia> rakudo-moar a38b59: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jhc0AmsMlw␤Undeclared routines:␤    a used at line 1␤    b used at line 1␤    c used at line 1␤    qw used at line 1␤␤»

[12:32] <brrt> how to do qw in perl6?

[12:32] <DrForr> say <a b c>

[12:32] <DrForr> m: say <a b c>

[12:32] <camelia> rakudo-moar a38b59: OUTPUT«a b c␤»

[12:32] <lucasb> qw/.../ or qw (...) (with a space between)

[12:33] <brrt> ah

[12:33] <brrt> m: my @a = <a b c>; say @a.combinations(2).perl;

[12:33] <camelia> rakudo-moar a38b59: OUTPUT«(("a", "b"), ("a", "c"), ("b", "c"))␤»

[12:33] <brrt> cool

[12:33] <DrForr> Oh, yeah, qw() doesn't work without the whitespace, the interpreter gets confused with a nonexistent qw() function :)

[12:34] <timotimo> mst: simsalabim bamba saladu saladim!

[12:35] <DrForr> o/' Para bailar la bamba, se necesita una poca de gracia o/'

[12:40] *** cschwenz joined
[12:42] *** leont left
[12:51] *** pdcawley joined
[12:51] *** llfourn joined
[13:01] *** llfourn left
[13:02] *** dsm left
[13:08] *** leont joined
[13:16] *** skids joined
[13:18] <timotimo> Grammar::Tracer says: match ALL the whitespace!

[13:23] *** pdcawley left
[13:25] *** llfourn joined
[13:25] *** zakharyas joined
[13:26] <lizmat> .tell TimToady if you're serious about ifdef, we should probably revert the existence of Index before the next release

[13:26] <yoleaux> lizmat: I'll pass your message to TimToady.

[13:26] <lizmat> .tell TimToady or do you think they both have a reason of existence?  (as in TIMTOWTDI)

[13:26] <yoleaux> lizmat: I'll pass your message to TimToady.

[13:33] *** rurban_ left
[13:47] *** rindolf left
[13:52] <dalek> doc: 0190858 | smls++ | lib/Language/subscripts.pod:

[13:52] <dalek> doc: subscripts: minor expansion and tweaks to the "Basics" section

[13:52] <dalek> doc: review: https://github.com/perl6/doc/commit/0190858bb0

[13:52] <FROGGS> hmpf

[13:52] * FROGGS hates pcre in php sooo much

[13:55] *** zakharyas left
[13:56] <timotimo> i'm too dumb to parse some C code right now :|

[13:56] *** zakharyas joined
[13:57] <FROGGS> O.o

[13:57] <FROGGS> timotimo: too hot?

[13:58] <timotimo> it's not hot in here at least

[13:58] <timotimo> i'm just not seeing what's broken

[13:59] *** smls joined
[13:59] <timotimo> would you like to take a quick look?

[13:59] <FROGGS> sure

[13:59] <smls> I was wondering: Why are from-the-end indices numbered  *-1, *-2, ...  instead of  *-0, *-1, ...

[14:00] <smls> In Perl 5, they *have* to start with -1, because -0 cannot be differentiated from 0

[14:00] <lizmat> smls: because * stands for .elems in that case

[14:00] <smls> but with the whatevercode notation, that wouldn't have been a problem right?

[14:00] <smls> lizmat: but it *could 

[14:00] <smls> * have been made to stand for .end instead

[14:00] <timotimo> FROGGS: find it in MoarVM's tools/parse_jitgraph.c, you'll likely need to run tools/update_ops.p6, too to get MAST::Ops in p6

[14:01] <timotimo> and it'll want you to have Grammar::Tracer available

[14:01] <timotimo> it seems like the problem is best explained by the ws rule causing MATCH "\n                /* atpos_i             w(int64)"

[14:02] <timotimo> after /*, it's supposed to match everything up to and including */

[14:02] <lizmat> smls: it could, but it feels incompatible with other * uses

[14:02] <smls> like what?

[14:04] <PerlJam> smls: you'd lose symmetry-around-0 --  ..., *-3, *-2, *-1, 0, 1, 2, 3, ... 

[14:04] <lizmat> also:

[14:04] *** ponbiki_ is now known as ponbiki

[14:04] <lizmat> m: my @a = ^10; say @a[*]

[14:04] <camelia> rakudo-moar a38b59: OUTPUT«0 1 2 3 4 5 6 7 8 9␤»

[14:04] <smls> PerlJam: Why *should* there be symmetry around the first element?

[14:05] <timotimo> or * div 2 to find the right element for the median

[14:05] <dalek> rakudo/nom: 045c148 | lizmat++ | src/core/Cool.pm:

[14:05] <dalek> rakudo/nom: Naively implement Cool.indices

[14:05] <dalek> rakudo/nom: 

[14:05] <dalek> rakudo/nom: As discussed at http://irclog.perlgeek.de/perl6/2015-08-04#i_10998495

[14:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/045c148b3f

[14:05] *** spider-mario joined
[14:06] <smls> PerlJam: If "wrapping" indices are deemed desirable, why have the * notation at all instead of simply allowing negative indices like other languages?

[14:06] <smls> timotimo: Ok, I see that's a practical benefit.

[14:06] *** dsm joined
[14:07] <smls> though having to write [(* / 2).ceiling] would not be the end of the world either

[14:07] <smls> or [(* + 1) div 2]

[14:08] <timotimo> what about ^*?

[14:08] <smls> what is that useful for in this context?

[14:08] <PerlJam> smls: a) aesthetics :)  b) because "whatever" is a more general mechanism and allowing negative indices would allow for accidental indexing in some cases

[14:09] <timotimo> nothing, it just fits

[14:09] <PerlJam> smls: and your "find the middle" versions require more cognitive load than  * div 2

[14:10] <smls> I dunno, I think "mirror" symmetry would have been more approriate than "wrapping-around" symmetry.

[14:12] <FROGGS> timotimo: eww, I've got problems here to get modules installed...

[14:12] <timotimo> oh

[14:13] <timotimo> i think i may just need a little break

[14:14] * lizmat will refrain from writing tests for Cool.indices until we have consensus on implementation

[14:14] <lizmat> "fooo".indices("oo")   # should that be (1,2) or just (1,)

[14:15] *** jonathan_ joined
[14:15] *** zakharyas left
[14:15] *** jonathan_ is now known as YvargDibar

[14:16] *** Abc333 left
[14:16] <timotimo> oh, oof, overlapping, too?

[14:16] <timotimo> good question

[14:16] *** RabidGravy left
[14:16] *** YvargDibar is now known as RabidGravy

[14:17] *** mr-foobar left
[14:17] <smls> lizmat: Shouldn't that be  index("oo", :g)  or  index("oo", :all)  like .match?

[14:18] <PerlJam> Why not just use .match at that poitn?

[14:18] <lizmat> I refer you to: http://irclog.perlgeek.de/perl6/2015-08-04#i_10998495

[14:19] <smls> I meant that it would be controlled by a modifier like .match is, not that it would do what match does.

[14:20] <PerlJam> FWIW, I tend to favor the default being overlapping matches.  (I don't have a real reason other than I think that one would be more useful)

[14:21] <PerlJam> i.e. "fooo".indices("oo") returns (1,2)

[14:22] <lizmat> smls: afaik, indices was to return *all* matches

[14:22] <smls> PerlJam: re. from-the-right indexing: There are good reasons why all modern langauges start indices with 0 rather than 1, aren't there? Why should those reasons suddenly no longer apply just because we're indexing from the right rather than the left?

[14:22] <lizmat> PerlJam: my thinking exactly and that's how I implemented it

[14:22] <smls> lizmat: So like :ex/:exhaustive on regexes?

[14:24] <smls> lizmat: The lack of clarity about which of :glibal/:exhaustive it should do, is imo another indication that it should be explicitly controlled by adverbs (rather than just picking one behavior). And at that point one could as well reuse the existing .index name for it.

[14:25] <smls> I wonder if TimToady considered that option 

[14:26] *** rurban left
[14:26] <lizmat> well, "indices" is plural of "index", so I guess it's implicit in the name

[14:26] <lizmat> afk for a bit

[14:27] <smls> alternatively, have .indices with an :ov/:overlap adverb.

[14:28] <TimToady> I think people will expect non-overlap by default

[14:28] <yoleaux> 13:26Z <lizmat> TimToady: if you're serious about ifdef, we should probably revert the existence of Index before the next release

[14:28] <yoleaux> 13:26Z <lizmat> TimToady: or do you think they both have a reason of existence?  (as in TIMTOWTDI)

[14:28] *** census joined
[14:30] <TimToady> I suspect ifdef is a nice general feature, while Index is kind of a specific feature that may doesn't pull it's weight

[14:33] <jdv79> tony-o: the existing tut does have actions

[14:33] <skids> Well, beyond array indices, it does offer a general thing for people who want 0 but True cleanly integrated into abuiltin I guess.

[14:35] <hoelzro> o/ #perl6

[14:35] <TimToady> hard to know whether people would prefer clean Ints and a forced ifdef, or a weird Ints that work with if counterintuitively

[14:36] <skids> I guess it could ease transcriptions from languages that have 0 but True... which are...?

[14:37] <TimToady> I think ifdef/Int is a lighter-weight solution

[14:39] <TimToady> I agree we can use adverbs on indices to indicate overlap

[14:39] <TimToady> but I still think index is good for when only one is wanted, since you don't have to set up a lazy pipeline for that

[14:40] <nine> I guess it depends on if we find another construct besides if $foo.index('x') -> $pos { ... } where the 0 but True solution would help.

[14:41] <PerlJam> re ifdef: I dunno  ... ifdef/Int is a lighter-weight solution, but it adds to the overall cognitive load of the language ("wait, there's *another* form of if statement?") whereas Index only adds cognitive load in one specific spot (or few spots)

[14:43] <skids> Well, there are bound to be some NativeCall libraries that have to map a "-1 if failure, 0+ is a handle"

[14:43] *** llfourn left
[14:43] *** nys joined
[14:44] <lucasb> Testing only the booleanness of some value and then assuming it is equal or not equal zero can turn out to be wrong-ish because you can't antecipate the crazy values other users will feed to your code. If the programmer wants the code to be strict, he should explicit test things with ($n == 0), ($s eq ''), @a.elems == 0, shouldn't he? If he justs tests booleanness, the he must be aware of the existence of ob

[14:44] <lucasb> jects that overrides .Bool/.defined and things like '0 but True'.

[14:44] <skids> lucasb: or constrain his types.

[14:44] <skids> m: say Index ~~ Int

[14:44] <camelia> rakudo-moar 045c14: OUTPUT«True␤»

[14:45] <skids> Hrm.

[14:47] * skids would not want to see sub a (::T Int $i where { not T.new(0) }) everywhere.

[14:48] <skids> But I guess that's beyond the blame of just Index since anyone can make one.

[14:49] <lucasb> sorry, what I said was only tangentially related to what were being discussed :)

[14:50] <lucasb> but it is the specific case of .combinations

[14:50] <lucasb> m: say (@).combinations(0).perl

[14:50] <camelia> rakudo-moar 045c14: OUTPUT«((),)␤»

[14:50] <dalek> rakudo/nom: d11c710 | lizmat++ | src/core/Cool.pm:

[14:50] <dalek> rakudo/nom: Implement Cool.indices(:overlap)

[14:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d11c7102a0

[14:50] <lucasb> m: say (@).combinations('a'.index('a')).perl

[14:50] <camelia> rakudo-moar 045c14: OUTPUT«()␤»

[14:50] <lizmat> commute to Amsterdam.pm meeting &

[14:50] *** lizmat left
[14:51] *** brrt left
[14:51] <lucasb> and again, I know this .combinations/.index example is contrived :)

[14:51] <skids> m: sub a ( Int(Int) $i) { say so $i }; a( "a".index("a"));

[14:51] <camelia> rakudo-moar 045c14: OUTPUT«True␤»

[14:52] * skids wonders if that coerce should strip the "0 but True"

[14:53] <TimToady> that's the problem with 0 but True, it has indeterminate scoping issues

[14:54] <lucasb> m: sub f(Int() $x) { say $x.WHAT }; f('a'.index('a'))

[14:54] <camelia> rakudo-moar 045c14: OUTPUT«(Index)␤»

[14:54] <TimToady> I really think ifdef is cleaner, and we'll end up encouraging people to think more about defined/undefined (I almost typed underfed)

[14:54] <lucasb> Interesting that Int() doesn't coerce to Int, because Index already is a Int

[14:54] <lucasb> so, it is different that $index.Int

[14:54] <lucasb> *than

[14:56] <skids> The Int(Int) question stands with or without Index, though.

[14:56] <nwc10> when I am dictator of the Universe (TM) all paper in all of Google's offices will be A4.

[14:57] <TimToady> you should have thought about that before you let us invent Google before you

[14:59] <nwc10> oh, well, once I have a time machine I'll also pop round to Sun and fix their printers too.

[15:03] <nebuchadnezzar> nwc10: you should travel far away and invent the metric system before any others ;-)

[15:04] <TimToady> actually, if you go far enough away, the metric system might be in base 8, if the majority number of fingers in the galaxy is 4 instead of 5

[15:08] *** lizmat joined
[15:09] *** rindolf joined
[15:10] <moritz> [^citation needed]

[15:10] <PerlJam> speculations need no citations

[15:11] <moritz> [^citation needed] :-)

[15:11] <PerlJam> :)

[15:12] <TimToady> ET cites moritz for driving with 5 fingers instead of 4.

[15:13] <PerlJam> Does the JVM backend have some problem with gather/take?  I notice in Baggy.pm there's some #?if jvm (use map)  #?if !jvm (use gather)

[15:13] *** raiph joined
[15:14] <jnthn> PerlJam: Yes, and it involves continuations and control exceptions, and guess how mnay people are up for debugging those things...

[15:14] <lizmat> m: sub a(Int(Index) $a) { say $a.WHAT }; a 42.Index   # would consider this to be a bug

[15:14] <camelia> rakudo-moar 045c14: OUTPUT«(Index)␤»

[15:15] *** khw joined
[15:15] <jnthn> lizmat: Missing warning about useless use of coercion type?

[15:15] <jnthn> lizmat: If you expect anything else then you're not getting it.

[15:15] <lizmat> no, the fact that it doesn't coerce to an Int

[15:15] <jnthn> It IS AN INT.

[15:15] <jnthn> That's how types work!

[15:17] <lizmat> well, fwiw, I always interpreted the coercion sugar Foo(Bar) $a as, call $a.Foo if $a.WHAT === Bar

[15:17] <moritz> that's not what it does

[15:17] <jnthn> I think we even docuemnt .WHAT === as being an anti-pattern.

[15:17] <moritz> it does $a.Foo unless $a ~~ Foo

[15:17] <lizmat> I understand that now

[15:17] <jnthn> Yeah but

[15:17] <masak> .WHAT is only for debugging

[15:18] <jnthn> I'd be surprised if .Int on Index didn't return identity too if it's a true coercion method.

[15:18] <masak> I don't even use it for that anymore -- I prefer .^name

[15:18] <masak> (hi #perl6)

[15:18] <lizmat> m: say 42.Index.Int.WHAT

[15:18] <camelia> rakudo-moar 045c14: OUTPUT«(Int)␤»

[15:19] <lizmat> I implemented it that way specifically so that you could remove the "0 but True" magic from an Index

[15:19] <tony-o> jdv79: one tutorial doesn't mean more tutorials or more in depth tutorials isn't a good idea

[15:19] <lizmat> .oO( I guess that's just one more nail in the Index's coffin )

[15:20] <lizmat> although I do think this points to a more general problem wrt to subclassing and coercion

[15:21] <lizmat> what would be against removing the check in the coercion logic altogether?

[15:21] *** muraiki joined
[15:21] <lizmat> sub a(Foo(Bar) $a) {   # always call .Foo on what is being passed before putting it in $a

[15:22] <jnthn> The contract of a coercion is that it's identity if the thing already matches the type to coerce to

[15:23] <masak> lizmat: even if you did that, wouldn't the fact that Index ~~ Int mean that you either did no cast, or the .Int method breaks the contract of casting?

[15:23] <TimToady> yes, coercion is only "make sure this can act like one"

[15:23] <jnthn> I think the problem is in your understanding of subclasses, not in Rakudo.

[15:24] <masak> m: say 42.Index.Int.WHAT

[15:24] <camelia> rakudo-moar d11c71: OUTPUT«(Int)␤»

[15:24] <masak> well, and in Rakudo ;)

[15:24] <jnthn> Darn it :P

[15:24] <moritz> there's nothing wrong with .Int returning an Int

[15:25] <lizmat> masak jnthn : that's just how I implemented it

[15:25] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 # latest GLR work, now with itemization and flat

[15:25] <masak> m: say [].List.^name

[15:25] <camelia> rakudo-moar d11c71: OUTPUT«Array␤»

[15:25] <masak> moritz: at the very least, it's inconsistent.

[15:25] <moritz> aye

[15:26] <moritz> if anybody on hack is consuming big amounts of memory, please kill your processes now

[15:26] <lizmat> TimToady: so if I have an Index, what would be the best way to make it an Int again ?

[15:26] <moritz> otherwise the OOM killer will do so, randomly

[15:26] <lizmat> m: say +(42.Index).WHAT

[15:26] <camelia> rakudo-moar d11c71: OUTPUT«Use of uninitialized value of type Index in numeric context  in block <unit> at /tmp/qc0324zEOG:1␤0␤»

[15:26] <lizmat> m: say (+(42.Index)).WHAT

[15:26] <camelia> rakudo-moar d11c71: OUTPUT«(Index)␤»

[15:27] <jnthn> TimToady: I currently have my @a = @b, @c; coming out as 2 elements, matching [@a, @b] also doing so. Unfortunately, there's a bit of a discontinuity...

[15:28] <jnthn> TimToady: my @a = @b; is fine; my @a = flat @b, @c; is also fine (flat applies to both of course, just a normal listop). my @a = 1..10; is fine as Range is Iterable. But [1..10] is a single element...

[15:28] <masak> lizmat: I've been telling people asking that on the channel ("how can I get `$thing` back if I did `$thing but $other`?") that they ought just hold on to `$thing` in the first place and not let it go out of scope or be replaced.

[15:28] <TimToady> why?

[15:28] <tony-o> jdv79: a single tutorial doesn't lend itself to the timtowtdi way of thinking..

[15:29] <jnthn> TimToady: I can of coures make [1..10] be [1, 2, 3, ...] provided [@a] means [@a[0], @a[1], ...]

[15:29] <jnthn> ]

[15:29] <jnthn> oops

[15:29] <jnthn> But given [...] doesn't itemize any more that means it's basically a copying no-op

[15:29] <TimToady> why wouldn't it just follow the same single-arg rule as everywhere else?

[15:29] <masak> lizmat: in the case of the `but` happening inside of an API call, that's not really an option though. which is why I keep hoping that doesn't happen to .index

[15:29] <jnthn> TimToady: I...hm. It probably can :)

[15:30] <jnthn> TimToady: OK, let's do that. Thanks. :)

[15:30] <TimToady> that's how I was prototyping it in glrish

[15:30] <lizmat> masak: the "but" is only conceptual, Index is a subclass of Int with "method Bool { self.defined }" mixed in

[15:30] <jnthn> Yeah, it makes sense. Something bugged me about it, I can't remember what.

[15:30] <timotimo> "how to get the opposite to work"?

[15:30] <jnthn> I'll do that and add it to my collection of tests.

[15:31] <jnthn> TimToady: BTW, things are fitting together quite pleasantly so far.

[15:31] <TimToady> I see that

[15:31] <jnthn> I've missed out a bunch of the iterator fast-path overrides for now.

[15:31] <masak> lizmat: then I'd argue it's already breaking Liskov substitutability. Int has a 0 value which boolifies to False.

[15:32] <jnthn> It occurs to me that if we can get a VM-level memcpy style thing we'll be able to go even faster.

[15:32] <TimToady> as long as you know where they go eventually

[15:32] <jnthn> *nod*

[15:32] <jnthn> Yeah, I've been feeling out the Iterator API

[15:32] <masak> lizmat: if you have a 0 value in your type which does not boolify to False, you're not an Int.

[15:32] <TimToady> will be interesting to see how fast the sad path is

[15:33] <jnthn> Yeah

[15:33] <lizmat> masak: so you're saying Index should not inherit from Int, but it should have all of the functionality of an Int (except boolification?)

[15:33] <masak> lizmat: no, I am not arguing in favor of Index at all.

[15:34] <masak> lizmat: also, I'm completely not backlogged. last time I was active (last week), this discussion was about Pos.

[15:34] <jnthn> TimToady: For Array, .flat basically is a no-op *if* it really is a bunch of Scalar containers. Trouble is, somebody could in theory bind an Iterable directly to one of the slots.

[15:34] <diakopter> *fatally unbackloggable

[15:35] <jnthn> TimToady: Should we (a) consider that erroneous, speed FTW!, or (b) actually care about that possibility?

[15:35] <jnthn> (or (c) refuse to let you bind Iterable directly :P)

[15:35] <TimToady> I vote for a, I think

[15:36] <jnthn> OK, wfm

[15:38] <nine> (1 GLR, 2 GLR, 3).GLRmap({ GLRslip($_, 3 * $_) }) # I'm no longer sure if the GLR is such a good thing. It seems to be so much more typing work.

[15:38] * nine ducks and runs

[15:38] *** captain-adequate joined
[15:39] <jnthn> Of course, it really stands for Gets Longer, REALLY!

[15:39] <timotimo> nine: actually, it's "GLR( GLR1 GLR, GLR2 GLR, GLR3 GLR) GLR. GLRmap({ GLRslip( GLRDollarUnderscore, GLR3 GLR* GLRDollarUnderscore) })

[15:39] <timotimo> "

[15:40] <nine> jnthn: do you already have caps lock bound to "GLR"? ;)

[15:40] <TimToady> we're also going to go to all caps everywhere, for greater consistency

[15:41] <timotimo> m: say "we're also going to go to all caps everywhere, for greater consistency".uc

[15:41] <camelia> rakudo-moar d11c71: OUTPUT«WE'RE ALSO GOING TO GO TO ALL CAPS EVERYWHERE, FOR GREATER CONSISTENCY␤»

[15:41] <TimToady> wow, that's so much nicer in all caps

[15:41] <nine> Maybe we could sell keyboards with GLR keys to Perl GLR6 developers and fund GLR development that way.

[15:42] <TimToady> the VT05 had one of them allcaps keyboards...

[15:42] <TimToady> not to mention the ASR-33

[15:42] * PerlJam glrs at nine 

[15:43] <lizmat> driving&

[15:43] *** lizmat left
[15:43] *** coffee` joined
[15:45] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 updated again with the [...] single item fix

[15:45] <lucasb> You people should have chosen an acronym that was easier to make puns about

[15:46] <jnthn> The trouble is, if it goes badly, it'll be forever known as the Great List Refuctor...

[15:47] *** FROGGS left
[15:47] <ugexe> i think it should forever be known as that anyway

[15:48] <smls> I just realized that splice() could be turned into a subscript adverb...

[15:48] <smls> When someone brought up the idea before I though it wasn't possible for subscripts to select zero-length slices like splice() can, but that could be made to work using end-exclusive ranges:

[15:48] <smls> my @a = 0, 10, 40; @a[1^..^2]:splice = 20, 30

[15:49] <smls> @a would be 0, 10, 20, 30, 40 now

[15:50] <TimToady> 1..0 is shorter

[15:52] <TimToady> [()] is even shorter than that

[15:52] <smls> but it wouldn't carry information about the position of the zero-length slice

[15:52] <TimToady> 2..1 is fine for that

[15:52] <smls> which would be needed for :splice to know where to put assigned values

[15:52] <smls> m: dd 2..1

[15:52] <camelia> rakudo-moar d11c71: OUTPUT«2..1␤»

[15:52] <TimToady> except that the flattening might occur too soon

[15:53] <jnthn> Darn, making '@a = @a' work on infinite things needs some careful thinking...

[15:53] * jnthn takes a few moment's break

[15:54] <jnthn> &

[15:54] <JimmyZ>  any reason that some GLRIterationBuffer.CREATE with BEGIN? some not?

[15:56] <timotimo> so that the object created by , can share its empty GLRIB with all others

[15:56] <timotimo> no need to have multiple of those, since they aren't modified ever

[15:57] *** telex left
[15:58] *** telex joined
[16:01] <smls> One problem with a :splice adverb would be to decide what to with non-consecutive (i.e. list rather than range) slices.

[16:01] <smls> @[2, 6, 7]:splice;  could simply remove those elements, byt what would   @[2, 6, 7]:splice = 1, 2, 3, 4;  do?

[16:01] *** sftp joined
[16:01] <smls> maybe it would need to be restricted to Range subscripts.

[16:02] <TimToady> splices are unusual enough (and inefficient enough) that I'm not much inclined to overload subscripting with it

[16:03] <smls> although there's a subset of what splice does - namely removing individual elements - that is not so unusual

[16:04] *** dg joined
[16:04] <smls> And having to go through splice() for that feels suboptimal.

[16:05] <smls> Its one of those functions that scare newbies, and requires even experienced programmers to look up what each argument was supposed to mean again.

[16:05] *** leont left
[16:05] <TimToady> the replacement seems just as scary

[16:05] <smls> as a subscript adverb, at least the simple/common cases would be friendly  @a[5]:splice;

[16:06] <Woodi> lizmat: I think you discovered natural born Monad situation...  looks .index want to return 2 things, search status and result like  struct Index { Bool found; @pos }

[16:07] <TimToady> maybe "ifdef" should be spelled "maybe"

[16:08] <TimToady> maybe "abc".index('a') -> $pos {...} else {...}

[16:09] <Woodi> is -> $pos part needed ?

[16:09] <TimToady> it is if you want to use the position

[16:09] <TimToady> or I suppose we could bind to $_ in that case

[16:10] <Woodi> right, $_ was for loops...

[16:10] <b2gills> If it weren't for the `-> $pos` part it would just be `if defined ...`

[16:10] <timotimo> if you don't need the -> $pos at all, you can just as well use "if defined"

[16:10] <timotimo> yeah

[16:10] <TimToady> except it can't default to binding $_

[16:11] <timotimo> ifdef could, but if defined can't, right?

[16:11] <b2gills> m: if defined 0 -> $_ { .say }

[16:11] <camelia> rakudo-moar d11c71: OUTPUT«True␤»

[16:11] <smls> "ifdef" will confuse C people :P

[16:11] <TimToady> I suppose it could be viewed also as a form of given that also tests definedness

[16:12] <TimToady> so, like given, ifdef could be used as a modifier

[16:12] <b2gills> I don't think it should be if it has "if" in the name

[16:12] <smls> would a longer name like "ifdefined", "if-def" or "if-defined" be so bad?

[16:12] <TimToady> we try to avoid - in keywords

[16:13] <smls> after all, the method is also called .defined and not .def

[16:13] <smls> "ifdefined" then?

[16:13] <b2gills> `maybe 0 { .say}` is fine but `ifdef 0 { .say }` isn't

[16:13] <TimToady> b2gills: how so?

[16:14] <b2gills> it would be a common source of confusion, which I don't think is worth it

[16:14] <smls> 'maybe' doesn't read quite right in this context imo.

[16:14] <TimToady> and worse as a modifier

[16:14] <b2gills> of course find a better word

[16:15] <Woodi> how Haskell _use_ monads after they are returned ?

[16:15] <geekosaur> ?

[16:15] <smls> if/for/while are all named so that the keyword refers to the condition

[16:15] <ugexe> too bad .so is taken

[16:16] <smls> but maybe would refer to "maybe this block", not "maybe this conditional expression"

[16:16] <timotimo> so .WHAT

[16:16] <b2gills> .oO( do we really need `.so` when we have `.Bool`? )

[16:17] <smls> "ifdefined" would immediately remind people of "if".

[16:17] <timotimo> how about "defined?" :P

[16:17] <TimToady> the keyword wants to have more of a topicalizer flavor, but with "guarantee" as part of the connotation

[16:17] <TimToady> provided maybe

[16:18] <timotimo> that.s not so bad

[16:18] <TimToady> works is modifier too

[16:18] <timotimo> assuming is already taken

[16:18] <smls> .oO( onconditionthat ... { ... } )

[16:18] <lucasb> Is there a shortcut for things like '$x but Defined', '$x but Undefined' ?

[16:19] <lucasb> Wouldn't it be easier if a role/enum existed for that?

[16:19] <TimToady> why would we want to make that easier?

[16:19] <TimToady> 'but' is already smelly enough

[16:20] <lucasb> well, so I can create the same confusion to the new ifdef :)

[16:20] <timotimo> .o( a smelly but )

[16:20] <b2gills> lol

[16:20] <b2gills> ... literally

[16:23] *** rurban_ joined
[16:28] *** leont joined
[16:30] *** bhavikdbavishi joined
[16:31] <bhavikdbavishi> p6: say 3;

[16:31] <camelia> rakudo-moar d11c71: OUTPUT«3␤»

[16:31] *** bhavikdbavishi left
[16:31] <timotimo> i wonder how good thunderbird's irc client is

[16:32] *** revdiablo joined
[16:32] <TimToady> actaully, maybe we could finally use "with", which is just about the right length, and has both topicalizer and conditional connotations

[16:32] <TimToady> and works either before or after

[16:33] <diakopter> withdef

[16:34] <hoelzro> submethods aren't necessarily tied to object lifecycle, are they? BUILD and DESTROY just happen to be submethods

[16:34] <timotimo> may i suggest "whif" please?

[16:34] <timotimo> because "with" doesn't seem conditional to me at all

[16:34] <timotimo> maybe i haven't been conditioned to see the connotation yet

[16:35] <TimToady> with permission, he proceeded to the gate

[16:35] <timotimo> hm

[16:35] <TimToady> with a ticket, you can get in

[16:36] <b2gills> "with" in other languages are similar to "given" in Perl 6

[16:36] <timotimo> i'm with b2gills on this one

[16:36] <[Coke]> b2gills++

[16:37] <TimToady> well, all topicalizers tend to have conditional overtones in natural languages

[16:38] <TimToady> and I just have a gut-level feel that, since we designed Maybe into our type system fundamentally, distinguishing maybeness might well warrant one of the rare topicalizers

[16:39] <b2gills> .oO( Perhaps there is word that is conditional on being alive )

[16:39] <diakopter> whiff

[16:39] <diakopter> timotimo: for if and only if

[16:39] <timotimo> %)

[16:40] <diakopter> TimToady: waxually, iff?

[16:40] <diakopter> or

[16:40] <diakopter> really

[16:41] <diakopter> forrealz

[16:41] <TimToady> not a topicalizer, really

[16:43] *** mr-foobar joined
[16:43] *** yqt left
[16:44] <b2gills> Since it's main purpose is to allow a topicalizer, I agree it should probably be one. I just think it needs to be a fairly unique word among other programming languages because it is fairly unique feature.

[16:46] *** rurban joined
[16:47] <hoelzro> I ask about sumethods because it seems that $.variable is disallowed in *all* submethods, but wouldn't it make sense to allow $.variable in non BUILD|DESTROY submethods?

[16:49] <hoelzro> m: for lines() -> { .say }

[16:49] <camelia> rakudo-moar d11c71: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/t8lE4FpTmH:1␤␤»

[16:50] <hoelzro> shouldn't $_ be the implicit argument for the block there?

[16:50] <b2gills> You explicitly stated that the block takes no arguments

[16:50] <TimToady> if you leave out the ->

[16:50] <TimToady> you gave it an explicit sig of ()

[16:51] <b2gills> I'm looking at synonyms of "consider"

[16:55] <hoelzro> ah duh

[16:55] <hoelzro> thanks b2gills

[16:56] <hoelzro> and TimToady!

[16:56] * TimToady should learn to microbacklog

[16:57] <smls> which built-in types which throw an "index out of bounds" error when subscripting a nonexistent index?

[16:58] <smls> m: 4[1];

[16:58] <camelia> rakudo-moar d11c71: OUTPUT«Index out of range. Is: 1, should be in 0..0␤  in block <unit> at /tmp/pUbRAb1zXh:1␤␤Actually thrown at:␤  in block <unit> at /tmp/pUbRAb1zXh:1␤␤»

[16:58] <smls> ^^ other than that

[16:58] <smls> do we have fix-sized arrays yet?

[16:58] <smls> or other collection types which do that?

[16:58] <TimToady> grep for the error

[16:59] <b2gills> TimToady: closest word I have is "granted"

[17:03] *** brisby joined
[17:03] *** lizmat joined
[17:06] *** yqt joined
[17:07] <smls> Can anyone think of an example where it makes sense to pass a proper code block (rather than whatever-currying) to a subscript?

[17:08] <smls> I already have these example for non-standard code expressions:

[17:08] <smls>     @array[* div 2]; # select the middlemost element

[17:08] <smls>     @array[$i % *];  # wrap around indices ("modular arithmetic")

[17:09] <smls> Would like to show an example of the form   @array[{...}]  or  @array[-> $n {...}]  as well to drive how the point of how generic it is

[17:09] <smls> but can;t think of an example that would actually make sense in practice.

[17:09] <smls> (this is for p6doc btw)

[17:10] *** brisby left
[17:10] <TimToady> a rotor subscript based on sqrt $n, maybe?

[17:10] <timotimo> sampling points based on a chevvychev distribution

[17:11] <smls> I'm afraid I don't understand either of those suggestions :P

[17:11] <smls> (but will google)

[17:15] <TimToady> how 'bout calculating an inversion slice from the size of a matrix

[17:16] <timotimo> numpy has this cool thing where you can some_matrix[some_matrix == 5] = 6

[17:17] <b2gills> @array[ {␤$_ / 3,␤$_ / 2,␤$_ * 2 / 3␤} ]

[17:18] <timotimo> indeed

[17:18] <timotimo> but that can be @array[ * / 3, * / 2, * * 2 / 3 ], too

[17:21] <b2gills> .oO( If "given" was spelled "with" then we could have used "given" instead of "ifdef" )

[17:21] <lizmat> m: my @a = ^100; say @a[ { (^$^a).grep: *.is-prime } ]    # smls   contrived, but yeah

[17:21] <camelia> rakudo-moar d11c71: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97␤»

[17:22] <smls> thanks, I think I'll go with that for now :P

[17:23] <smls> I didn't know the code was allowed to return multiple indices

[17:23] <lizmat> ah, yeah  :-)

[17:23] <smls> m: say (0, 10, 20, 30)[{1, 2}]

[17:23] <camelia> rakudo-moar d11c71: OUTPUT«10 20␤»

[17:23] <smls> m: say (0, 10, 20, 30)[0..{1, 2}]

[17:23] <camelia> rakudo-moar d11c71: OUTPUT«Cannot call Real(Block: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/3hytDrrAhD:1␤␤»

[17:23] <smls> m: say (0, 10, 20, 30)[0..*-1]

[17:23] <camelia> rakudo-moar d11c71: OUTPUT«0 10 20 30␤»

[17:24] <smls> ah so in the range case, only WhateverCode is allowed?

[17:27] <lizmat> smls: lemme check

[17:28] <lizmat> m: "abc".indices("").perl.say   # meanwhile, what should this say?

[17:28] <camelia> rakudo-moar d11c71: OUTPUT«(0, 1, 2, 3)␤»

[17:28] <lizmat> I would argue: either (0,1,2) or ()

[17:28] <moritz> m: say 'abc'.rindex('')

[17:28] <camelia> rakudo-moar d11c71: OUTPUT«3␤»

[17:28] <moritz> m: say 'abc'.index('')

[17:28] <camelia> rakudo-moar d11c71: OUTPUT«0␤»

[17:28] <moritz> I'd argue (0, 1, 2, 3) is correct.

[17:29] <lizmat> moritz: ok

[17:30] *** raiph left
[17:36] <b2gills> m: say (0, 10, 20, 30)[0..Whatever]

[17:36] <camelia> rakudo-moar d11c71: OUTPUT«0 10 20 30␤»

[17:49] *** FROGGS joined
[17:50] <dalek> rakudo/nom: 45f2924 | lizmat++ | src/core/Cool.pm:

[17:50] <dalek> rakudo/nom: Add indices() as a sub

[17:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45f292419a

[17:50] <dalek> rakudo/nom: 47654fa | lizmat++ | t/spectest.data:

[17:50] <dalek> rakudo/nom: Add tests for indices()/.indices

[17:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/47654faff3

[17:51] <dalek> roast: cdbf63e | lizmat++ | S32-str/indices.t:

[17:51] <dalek> roast: Add tests for indices

[17:51] <dalek> roast: review: https://github.com/perl6/roast/commit/cdbf63efa7

[17:51] <jnthn> JimmyZ: As timotimo said, basically because in some cases we can share a single empty bit of storage due to immutability, but in others we can't

[17:51] <lizmat> dinner&

[17:51] *** lizmat left
[17:58] *** [particle]1 left
[17:59] *** kurahaupo joined
[18:02] *** rurban left
[18:03] *** cognominal joined
[18:03] *** yqt left
[18:05] <[Coke]> so what's the current proposed change to replace Index?

[18:06] <moritz> dunno, Int?

[18:07] <moritz> http://collect.p6c.org/cgi-bin/collection.modified.cgi?action=show_graph;plugin=memory;type=memory;host=hack.p6c.org;timespan=hour;start=12:21%20Aug%204%202015;end=18:06%20Aug%204%202015;=undefined;&format=SVG something seems to hog memory, and then dies, and tries again

[18:08] <moritz> if anybody has an idea what process that is, please tell me (and make sure to memory-limit it)

[18:08] <jdv79> [Coke]: what do you propose?

[18:10] <timotimo> moritz: maybe look through user's mail boxes for failure reports from cron?

[18:11] *** colomon joined
[18:11] <[Coke]> jdv79: I don't.

[18:12] <[Coke]> but it seemed like there was discussion earlier about a generic mechanism with a name to be bikeshedded.

[18:12] <timotimo> moritz: what coke means is not the class that'll replace Index, it's more about the name of ifdef/given/with/...

[18:12] <[Coke]> moritz: so we have 1) Keep Index, 2) Kill Index, 3) Kill index & also provide some new thing.

[18:13] *** cognominal left
[18:15] <jdv79> where else would this new thing be applicable 

[18:16] <RabidGravy> next time someone's in there wanna merge this one character PR https://github.com/rakudo/rakudo/pull/486 ;-)

[18:17] <[Coke]> jdv79: that's why I'm asking if there's a proposal or something.

[18:17] <dalek> rakudo/nom: ddee95d | RabidGravy++ | lib/Test.pm:

[18:17] <dalek> rakudo/nom: skip-rest has the wrong name in the error message

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ddee95df03

[18:17] <dalek> rakudo/nom: 172b87c | (Will Coleda)++ | lib/Test.pm:

[18:17] <dalek> rakudo/nom: Merge pull request #486 from jonathanstowe/test-errors

[18:18] <dalek> rakudo/nom: 

[18:18] <dalek> rakudo/nom: skip-rest has the wrong name in the error message

[18:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/172b87c35f

[18:18] *** census left
[18:18] * [Coke] smacks dalek and or github for screwing up his karma.

[18:20] <flussence> .oO( if:defined $str.index('foo') -> $pos )

[18:21] <moritz> my $idx = $str.index('foo'); if defined $idx { ... }; # come on, there are cases where two statements are OK!

[18:22] <RabidGravy> [Coke]++ # fix the karma

[18:23] <flussence> I wasn't all that serious there, it's a pretty ugly suggestion :)

[18:23] <[Coke]> IWBNI if someone turned  http://blogs.perl.org/users/aaron_baugher/2015/08/minor-issue-with-perl-6-install-on-centos-6.html into a ticket

[18:25] * moritz now asked http://serverfault.com/questions/710847/how-to-apply-memory-limits-to-all-cron-jobs

[18:26] <flussence> my first thought would be "cgroups"

[18:26] <flussence> I've never actually done such a thing myself though so I've no idea how much of a PITA it'd be

[18:27] <moritz> flussence: the problem is that cron runs in its own cgroup, not in the users' cgroup

[18:27] <flussence> hm, that makes it a bit awkward

[18:27] <moritz> flussence: if there is no better solution, I'll limit global cron's memory usage, but I'd *really* like it per user

[18:27] *** mohij joined
[18:29] <jdv79> is there a Maybe type?

[18:30] <moritz> all of our types are Maybe types, because you can usually pass the type object too

[18:30] <moritz> m: sub f(Int $x) { say $x }; f 3; f Int

[18:30] <camelia> rakudo-moar 47654f: OUTPUT«3␤(Int)␤»

[18:30] <moritz> m: sub f(Int:D $x) { say $x }; f 3; f Int

[18:30] <camelia> rakudo-moar 47654f: OUTPUT«3␤Parameter '$x' requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in sub f at /tmp/Dae7Kc455s:1␤  in block <unit> at /tmp/Dae7Kc455s:1␤␤»

[18:31] *** espadrine left
[18:32] <dalek> doc: efdfaee | smls++ | lib/Language/subscripts.pod:

[18:32] <dalek> doc: subscripts#Basics: some rewording to improve clarity

[18:32] <dalek> doc: review: https://github.com/perl6/doc/commit/efdfaee76a

[18:32] <dalek> doc: f837812 | smls++ | lib/Language/subscripts.pod:

[18:32] <dalek> doc: subscripts: Fill in section "From the end"

[18:32] <dalek> doc: review: https://github.com/perl6/doc/commit/f83781247e

[18:33] <jdv79> ah

[18:34] <flussence> moritz: there's also the option of tweaking the overcommit sysctls (making runaway processes OOM early), but I know from experience the JVM really doesn't like it when you do that

[18:34] <moritz> flussence: and the OOM killer has the not-so-nice property that it sometimes kills innocent bystander processes

[18:35] <flussence> that too :(

[18:35] <flussence> (iirc the setting that screws up the JVM is the one where it returns -ENOMEM correctly...)

[18:36] *** rurban joined
[18:36] *** rurban left
[18:38] <RabidGravy> in Test.pm there is a tiny bit of pod, but only has the one function throws-like documented, would it be add the rest of the public interface to the pod or make it a separate document?

[18:39] <RabidGravy> I'm up for adding it to the pod so that "p6doc Test" works nicely

[18:39] *** rurban joined
[18:40] <moritz> RabidGravy: no; it's documented already in p6/doc

[18:40] <moritz> and we don't have the bandwidth to maintain documentation twice

[18:41] <RabidGravy> right, so it's take the pod there is in there out and check the other one is up to date

[18:41] *** lizmat joined
[18:42] <jnthn> [Coke]-- # bot violence ;)

[18:42] <jnthn> [Coke]++ for applying the PR though 

[18:42] <jnthn> Not to mention [Coke]++ for all the other things...

[18:42] <[Coke]> jnthn: heh; haven't been doing much lately.

[18:43] <jnthn> Shhh, I might -- you again for that :P

[18:43] <jdv79> whats wrong with if:def?

[18:44] <moritz> 1) it's ugly 2) it'd be the only keyword that contains a non-alpha

[18:45] <jdv79> not muuch uglier than ifdef and its clearer that it's a modified if

[18:46] <jdv79> but i can see the distaste

[18:46] <jnthn> ifdef may not be pretty, but sticking a colon in makes it butt-ugly... :P

[18:47] <moritz> note that it should also work in the 'elsif' case

[18:47] <jdv79> elsifdef elsif:def

[18:47] <jdv79> both meh

[18:48] <moritz> and since there doesn't seem to be a good solution, I'd just leave it as is

[18:48] <jdv79> if:D :)

[18:49] <jdv79> yeah, i also don't get all the attention this is getting

[18:49] <jdv79> how valuable is this feature in totality

[18:50] <jnthn> Yeah, but commenting on this is FAR easier than reading my GLR gist, understanding it, and discussing that :P

[18:51] <moritz> jnthn: I did the first part, at least :-)

[18:51] <jnthn> moritz++

[18:52] <TimToady> it's not about index, it's about testing for success/failure

[18:52] <nine> jnthn: well I've read your gist far enough to notice all those GLR this GLR, GLR that ;)

[18:52] <moritz> jnthn: the only thing I don't like about it is that the question of whether we flatten something is still (partially) determined by types, not solely by operators

[18:52] <jdv79> i know

[18:52] <TimToady> as I see it, we'll have with/without as the control forms of "andthen"

[18:53] <jdv79> where else is that applicable is what i meant

[18:53] <TimToady> to go with the if/and

[18:54] <jnthn> moritz: How would you solve the "how to write .kv" problem?

[18:54] *** EINVAL joined
[18:55] *** nys left
[18:55] <jnthn> moritz: 'cus Slip is basically for taking on the "map/loop/whatever that wants to return some number of items other than one"

[18:55] <TimToady> slip is an implementation type, so not in the same league as the autoslipping that Range and Array currently do

[18:55] <TimToady> it's abstracting all the evil out into one place

[18:55] <jnthn> I don't expect many folks to write slip(...) in actual code, but to explicitly do flat.

[18:56] *** nys joined
[18:56] <TimToady> jnthn: I suspect we can probably unify | with slip at some point, depending on context

[18:56] <jnthn> TimToady: I don't really see it; return |($key, $value) is clearly an argument to return

[18:57] <jnthn> That should flatten into the argument list

[18:57] <TimToady> probably the return type wants to be Slip in that case

[18:57] <jnthn> Which is different from return slip($key, $value);

[18:58] <TimToady> and possibly we make return notice when there's a single | there

[18:58] <jnthn> Also, if Slip is an implementation type and we don't expect to see it often, why do we need any kind of sugar for it?

[18:58] <TimToady> that flipside of the one-arg rule, as it were

[18:58] *** g4 left
[18:59] <smls> simply rename the current prefix | (argument interpolation) to prefix ||, then you can use | for flattening or slipping :P

[18:59] <TimToady> my @foo = |@foo, |@bar

[18:59] <jnthn> That's a 2 char saving over my @foo = flat @foo, @bar;

[18:59] <smls> the specs already mention || as a special form or argument interpolation anyway

[18:59] <TimToady> if you don't want to flat everything for some reason

[18:59] <smls> *form of

[19:00] <TimToady> basically | would be taking on the role that * does in Ruby

[19:00] <moritz> and a separate list concatenation operator is still out of favor?

[19:00] <TimToady> jnthn: do you have any objection other than the "return is trying to pretend to be a real function" argument?

[19:01] <jnthn> TimToady: Oh, I just picked return as an easy example of a function :)

[19:01] <jnthn> TimToady: My broader point was that I don't want to confuse two different things

[19:01] <TimToady> my broader point is they might be the same thing

[19:01] <moritz> I agree with jnthn here

[19:02] <moritz> TimToady: why do you think they might be the same thing?

[19:03] <TimToady> because they both remove the outer objectness of a list, it's just one goes into a capture rather than a normal list

[19:03] <moritz> I see a difference between interpreting a list of elements as a signature (|) and passing a flat list to a single parameter (slip)

[19:04] <jnthn> I'm not sure I can see how they are. Consider |c, where c is a Capture. Or |%h, where it's a Hash.

[19:04] <jnthn> In both cases there's named things to interpolate

[19:04] <jnthn> Not to mention that a slip stops evaluating at the first potentially eager thing

[19:04] <jnthn> But argument list interpolation forces eagerness

[19:05] <TimToady> well, but those are mutually exclusive contexts

[19:05] <jnthn> So you're saying you'd make anywhere that | is an error now create a slip?

[19:05] <TimToady> it's an "interpolate this" in either case

[19:05] <TimToady> yes

[19:07] <jnthn> Well, if that's all it is then it's trivial to implement, though it's certainly a unification at a high level rather than at an implementation level.

[19:07] <smls> m:  my Int @array; say @array[10];  say ( Array[Int].new )[10]

[19:07] <camelia> rakudo-moar 172b87: OUTPUT«(Int)␤(Any)␤»

[19:07] <smls> ^^ why are these different?

[19:07] <TimToady> I think it will do a better job of hiding the Slip type as well

[19:08] *** colomon left
[19:08] <smls> m: my Int @array; say @array.of;    say (Array[Int].new).of

[19:08] <camelia> rakudo-moar 172b87: OUTPUT«(Int)␤(Int)␤»

[19:08] <TimToady> and I picked the | operator in the first place because it looks like a slit into which you slip something

[19:09] *** colomon joined
[19:11] <jnthn> TimToady: We can try it; I've a feeling it may bite somebody somewhere

[19:11] <jnthn> Though we can't try it in my prototype 'cus it needs compiler changes

[19:11] <TimToady> sure

[19:12] <TimToady> you don't want to end up with God Branch

[19:13] <TimToady> darn it, I haven't even backlogged up to the point I went to bed last night, and it's already lunchtime...

[19:13] <jnthn> I'm going to finish up the things I wrote in comments that I should write test for

[19:13] <TimToady> looks like real good progress

[19:13] <jnthn> Then I'll perhaps have a go at while lazy loop/while/until will work out

[19:13] <jnthn> uh

[19:13] <jnthn> at *how* lazy

[19:14] <jnthn> what on earth, brain...

[19:14] <jnthn> Then perhaps start digging through CORE.setting to see what bits of lists it depends on

[19:14] *** g5 joined
[19:15] <TimToady> funzies

[19:15] <jnthn> You're fine with a Seq passed to an @foo calling .list on the Seq and binding the result, yes?

[19:16] <jnthn> So foo(@bar.map(...)) works out?

[19:16] <TimToady> yup

[19:16] <jnthn> OK, good. And the memoization of the .list result made sense to you also?

[19:17] <jnthn> It's there in part because things like callsame(...) pass the original Capture

[19:18] <jnthn> So we'd like subsequent .list calls to just return what was produced before

[19:18] <jnthn> And since List is immutable that's harmless

[19:18] <TimToady> yes, as you say, it's immutable, or sup...

[19:18] <TimToady> yeah

[19:18] *** smls is now known as smls_

[19:18] <moritz> did I get this right that signature binding allows a wee bit of coercion?

[19:18] <jnthn> OK, good.

[19:18] <TimToady> moritz: yes, the @ now implies caching

[19:18] <jnthn> moritz: A...wee bit in this place, yes

[19:18] <moritz> if so, we could use that to make passing of typed arrays less awkward

[19:18] <TimToady> give him an inch...

[19:18] <jnthn> hah :P

[19:18] <moritz> (though maybe that's a post-GLR topic)

[19:19] <jnthn> Damn, I walked right into that trap :P

[19:19] <jnthn> moritz: It is, though it's a good point.

[19:20] <moritz> does the @ in a *@slurpy also imply caching?

[19:20] <jnthn> Indirectly

[19:20] <TimToady> you can do |rest if you need to

[19:21] <TimToady> but maybe there's something inbetween, like *\rest

[19:22] <TimToady> if we end up with some coercion semantics on positional @, then maybe some of that will carry over to *@

[19:22] <dalek> rakudo/nom: f625b9b | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[19:22] <dalek> rakudo/nom: Bring Scalar creation on in line with JVM.

[19:22] <dalek> rakudo/nom: 

[19:22] <dalek> rakudo/nom: Which also makes it usefuller for GLR.

[19:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f625b9b95f

[19:22] <dalek> rakudo/nom: 65915b7 | jnthn++ | src/Perl6/Actions.nqp:

[19:22] <dalek> rakudo/nom: An nqp::op action micro-optimization.

[19:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/65915b7956

[19:24] <jnthn> Ah, I guess actually we will need to look through the Capture for Seqs when binding *@foo

[19:24] <jnthn> TimToady: Oh...question I thought up

[19:24] <jnthn> What type is (1,2;3,4) now?

[19:24] <hoelzro> anyone have any thoughts on what I said about submethods above? I was experimenting with a library that makes submethod PRE/POST into invariants for a class, and I found it surprising I couldn't use $.variable in PRE/POST

[19:24] <TimToady> jnthn: lemme think about that over lunch

[19:25] <jnthn> TimToady: OK, np :)

[19:25] <jnthn> ohhh...and I was meant to go to the corner shop before it closes...

[19:25] <jnthn> Still time; bbi10 &

[19:25] <PerlJam> jnthn++ TimToady++  I've only been vaguely paying attention today, but it feels like a watershed day for the GLR from here.

[19:30] *** [particle] joined
[19:31] *** colomon left
[19:34] <lizmat> PerlJam: I would agree with that assessment  :-)

[19:34] *** ChoHag left
[19:38] *** colomon joined
[19:39] <lucasb> so... that gist will be merged into rakudo with all those GLR prefixes removed?

[19:39] * itz is 29 today!

[19:40] <TimToady> we might merge in with the prefixes if we want to use the old stuff as scaffolding while we transform things, but that would be a temporary expedient if we did

[19:40] <virtualsue> . o O ( :20<29> )

[19:41] *** EINVAL left
[19:41] * TimToady fondly remembers the days when he was running a version that contained both the P4 and P5 interpreters, and converted instructions one at a time from the P4 engine to the P5 engine

[19:41] <PerlJam> itz: happy birthday!

[19:41] <itz> :)

[19:41] <moritz> its++ # 30 now :-)

[19:42] <nine> itz is lucky moritz typoed that ;)

[19:42] <jnthn> yowser, warm corner shop was warm...

[19:42] * jnthn dumps one of the beers into the freezer so it'll be a nice temperature by the time he wants it

[19:42] <moritz> erm, itz++ :-)

[19:43] <itz> I need to write Acme::Birthday::Flattering::Base :)

[19:43] *** FROGGS left
[19:44] <smls_> whats the easiest way to get a Date for the current date again?

[19:44] *** yqt joined
[19:44] <jnthn> m: say Date.today # total guess

[19:44] <camelia> rakudo-moar 172b87: OUTPUT«2015-08-04␤»

[19:44] <jnthn> win1

[19:44] <smls_> thanks

[19:44] <itz> http://examples.perl6.org/categories/cookbook/03dates-and-times/03-01-todays-date.html

[19:44] <TimToady> the easiest way to get a date for the current date is to already have an SO :P

[19:44] *** colomon left
[19:45] <jnthn> Doesn't help when SO is the other side of the visa application process :(

[19:45] <moritz> :(

[19:45] <TimToady> troo :(

[19:45] <TimToady> sorry, wasn't thinking

[19:46] <moritz> (political borders)--

[19:46] <[Coke]> Is it too late to complain that the default for a new Date isn't today? ;)

[19:47] * jnthn is still hopeful we might get it tied up so she can enjoy the trip to Olten and Granada. :)

[19:47] <moritz> [Coke]: it's never too late for complaints

[19:47] <RabidGravy> itz, yoof!

[19:47] <lucasb> yeah, Date.new should be the same as Date.today :)

[19:47] <moritz> debian-WTF of the day: [ ok ] Reloading web server config: apache2 not running.

[19:48] <moritz> all I could think of was "WHAT? web server down?"

[19:48] <moritz> turns out it's running all right

[19:48] <TimToady> apache2 not running YET!

[19:49] *** colomon joined
[19:49] * moritz still like the Date.new christmas egg, but guesses he'll lose it in the long run

[19:50] <PerlJam> moritz: you're meant to lose in the long run. :)

[19:50] <TimToady> not such a long run for me anymore... :)

[19:51] <dalek> doc: 15174dd | smls++ | lib/Language/subscripts.pod:

[19:51] <dalek> doc: Some rewording; make "Nonexistent elements" a separate section

[19:51] <dalek> doc: review: https://github.com/perl6/doc/commit/15174dd288

[19:52] *** mohij_ joined
[19:52] *** domidumont joined
[19:53] *** mohij left
[19:54] <skids> .oO("ifdef" could be generalized to some sort of leapfrog topicalizer.  Because .defined is not the only thing one might want to do.)

[19:54] <TimToady> maybe it should default to tomorrow: "a new Date is dawning"

[19:55] <RabidGravy> o/ maybe tomorrw, maybe some day ... o/

[19:56] <TimToady> maybe it should be like jam, and randomly pick yesterday or tomorrow, just to keep people honest

[19:56] <nine> No boom today. Boom tomorrow. There's always a boom tomorrow.

[19:57] <geekosaur> .oO { that would be a Date-um }

[19:57] <smls_> skids: It would need to accept three arguments though (topic expression; truthiness checking expression; block)

[19:58] <[Coke]> nine++

[19:58] <smls_> skids: So how would that even look like?

[19:58] <timotimo> TimToady: return a junction of yesterday and tomorrow "at the same time"

[19:59] <skids> smls_: I dunno, I'm thinking about it.  Whatever might play a role.

[20:00] <PerlJam> smls_: conditionally *.defined $thing { say "wha?" }   # maybe shortend that to "cond"  ;)

[20:00] <smls_> so much TTIAR... :P

[20:01] <smls_> maybe 'if' could accept traismods like sub definitions do?

[20:01] <smls_>     if $str.index($needle) id bood(*.defined) -> $index { ... }

[20:01] <smls_> s/id bood/is bool/

[20:02] <TimToady> yes, I thought about those a lot, but they're awfully unweildy, expecially in the case of .defined

[20:03] <TimToady> and you have to special-case the 'if' anyway

[20:04] <smls_> 'while' could support it too :)

[20:04] <TimToady> but doing that with while doesn't help index

[20:04] <smls_> right

[20:05] <TimToady> do you have any use cases for methods that are not .so or .defined?

[20:05] <TimToady> they seem pretty rare to me

[20:06] <smls_> you're probably right, .defined does seem to be where I usually hit that problem.

[20:06] <PerlJam> .elems perhaps?

[20:06] <lizmat> it occurs to me it works like a sort of grep

[20:06] <TimToady> PerlJam: .so works there

[20:07] <TimToady> we really don't have the problem with lists because you can just use 'for' instead of while and actually use grep

[20:08] <TimToady> but we don't have scalar control analogs to andthen, as we do with and

[20:08] <TimToady> which, as I say, are largely about determining success

[20:08] <nine> m: sub str-index(Str $str, Str $find) { my $i = $str.index($find); return False unless defined $i; return True, $i; }; if str-index("foobar", "foo") -> [$found, $i] { say "found at $i!" }

[20:08] <camelia> rakudo-moar 65915b: OUTPUT«found at 0!␤»

[20:09] <tony-o> thats cool

[20:10] <TimToady> shades of Go

[20:10] <nine> exactly

[20:10] *** domidumont left
[20:10] <TimToady> good reaso to avoid it :)

[20:10] <TimToady> *son

[20:10] <lucasb> m: say &defined; say &defined ~~ Callable

[20:10] <camelia> rakudo-moar 65915b: OUTPUT«Sub+{<anon>}.new␤False␤»

[20:10] <nine> I'm just wondering if all the fuss about such a tiny little use case is actually worth it

[20:11] <TimToady> I repeat, it's not about index, it's about measuring success

[20:11] <TimToady> (shades of Icon)

[20:11] <lucasb> &defined didn't bound in a &c param in my sub. it doesn't know it is a callable?

[20:12] <[Coke]> we just need to decide if Index is going out in the next release or if we kill it.

[20:12] <TimToady> m: say &defined ~~ Callable

[20:12] <camelia> rakudo-moar 65915b: OUTPUT«False␤»

[20:12] <TimToady> huh

[20:12] <lucasb> m: sub f($x,$c,&d) { $c($x) and &d($x) }; f(0,&defined,&say)

[20:12] <camelia> rakudo-moar 65915b: OUTPUT«0␤»

[20:12] <lucasb> ^^ anyway, I wanted to do this

[20:12] <TimToady> m: say defined 42

[20:12] <camelia> rakudo-moar 65915b: OUTPUT«True␤»

[20:13] <TimToady> m: say &prefix:<defined> ~~ Callble

[20:13] <camelia> rakudo-moar 65915b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/aY486OlzZC␤Undeclared name:␤    Callble used at line 1. Did you mean 'Callable'?␤Undeclared routine:␤    &prefix:<defined> used at line 1␤␤»

[20:13] <TimToady> m: say &prefix:<defined> ~~ Callable

[20:13] <camelia> rakudo-moar 65915b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lQApjTlKBd␤Undeclared routine:␤    &prefix:<defined> used at line 1␤␤»

[20:13] <TimToady> m: say defined.^mro

[20:13] <camelia> rakudo-moar 65915b: OUTPUT«5===SORRY!5===␤Argument to "defined" seems to be malformed␤at /tmp/916F3dNr6H:1␤------> 3say defined7⏏5.^mro␤Other potential difficulties:␤    Unsupported use of bare "defined"; in Perl 6 please use .defined if you meant $_, or use an e…»

[20:13] <TimToady> m: say &defined.^mro

[20:13] <camelia> rakudo-moar 65915b: OUTPUT«(Sub+{<anon>}) (Sub) (Routine) (Block) (Code) (Any) (Mu)␤»

[20:13] <TimToady> obviously a bug, if it's not Callable

[20:14] <lucasb> TimToady++, thank you

[20:14] <ShimmerFairy> I think 'ifdef' would work fine as a keyword, though admittedly I'd like it if we managed to find an actual word for it :) . I though 'with' was another decent choice  (perhaps  with $x { ... } orwith $y { ... } else { ... }  ?)

[20:15] *** zakharyas joined
[20:15] <TimToady> we also have "without" as the unless/or analog

[20:15] <TimToady> so it fits rather nicely

[20:16] <TimToady> lucasb: you can probably use *.defined there instead

[20:16] <ShimmerFairy> true, that's a nice bonus :)

[20:17] *** darutoko left
[20:17] <tony-o> when $x { }

[20:17] <TimToady> taken

[20:17] <tony-o> ah yea

[20:18] <tony-o> with $x { } orwith $y { } without { }

[20:19] <TimToady> we don't use "unless" to mean "else" though

[20:19] <ShimmerFairy> Also another point for having another topicalizer: we do have a defined version of || in // , so it's clear that we've already decided defined-ness was important enough to get its own symbol in some places :)

[20:19] <tony-o> our would without be when $x isn't defined

[20:19] *** mohij_ left
[20:20] <ShimmerFairy> without $x { } -> unless $x.defined { } , is the current thinking

[20:20] <TimToady> but you've got both an $x and $y

[20:21] *** mohij joined
[20:21] <TimToady> anyway, else can work fine there, methinks

[20:21] <ShimmerFairy> my 'orwith' idea could be called 'elswith' to fit with both my usage of 'else' in that hypothetical statement, as well as correlate with 'elsif'

[20:21] * TimToady thought of elswith earlier in the day, but I kinda like orwith better

[20:22] <ShimmerFairy> .oO(we could always go with 'otherwise' if we really want 'else' to stay with just one construct :P)

[20:23] <ShimmerFairy> TimToady: my only concern with 'orwith' is that it's a bit similar to 'orelse' , but I don't think that'd be too much of a problem in reality.

[20:23] <tony-o> i like 'without' 

[20:23] <TimToady> me either

[20:24] <TimToady> you don't want to have a 'without' continuer if there's also a 'without' statement control; it'd be terribly ambigous

[20:24] <TimToady> *guous

[20:24] <tony-o> ambigiguous

[20:25] <TimToady> I suppose you could only get an ambigibous moon on a planet with two suns

[20:26] <TimToady> or is that amphigibous...

[20:26] <tony-o> lol

[20:28] * skids ponders how much semantic difference there really is between Int $a where {...} and "take this value if the same value -> $_ {...}"

[20:29] <skids> So like, if $a where *.defined -> $a { }

[20:29] <ShimmerFairy> TimToady: that might actually read more naturally than some uses of 'unless' I can imagine there are currently:  sub foo($fname? is copy) { $fname = "default.txt" without $fname; ... }  (ignoring the fact that this example should really be setting a default in the signature :P)

[20:29] <TimToady> jnthn: I really don't know what to do with (1,2;3,4) yet, I do know that .[1,2;3,4] needs to treat the 1st dimension as non-lazy/non-flattening and the 2nd dimension as lazy/flattening, just as a normal .[1,3,5..7] needs slices to flatten when there's no ;

[20:30] <TimToady> or maybe there's a ; implied in a subscript

[20:31] <TimToady> ShimmerFairy: and ignoring the fact you'd just use //= there :P

[20:33] <TimToady> skids: seems kinda backwards, insofar as the 'if' isn't testing $a

[20:33] <TimToady> and it's still a special case

[20:34] <TimToady> (or a 'but'-like cheat of some sort)

[20:37] *** leont left
[20:39] <dalek> rakudo/nom: 5da3237 | lizmat++ | src/core/control.pm:

[20:39] <dalek> rakudo/nom: Implement leave() placeholder sub

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5da3237cb8

[20:39] *** virtualsue left
[20:41] *** lucasb left
[20:41] <skids> waitasec... we already have this.

[20:41] <skids> m: do { say $_ } if .defined given 0 but True

[20:41] <camelia> rakudo-moar 65915b: OUTPUT«0␤»

[20:42] <TimToady> we have it in spots, but it's not handy

[20:43] <TimToady> and, as I said, you either have to rely on a special case or a cheat

[20:43] <TimToady> here you're relying on a cheat

[20:44] <ShimmerFairy> TimToady: btw, yesterday you said flattening was recursive, but jnthn's gist has  my @e = flat @a, @b;      # 5 elements [1, 2, 3, $[1, 2], $[3, 4]]  in the comments. Am I misunderstanding 'flat' here, or...?

[20:44] <TimToady> remember that arrays itemize each element

[20:44] <ShimmerFairy> m: do { say $_ } if .defined given 0  # don't need the 'but True' in this case

[20:44] <camelia> rakudo-moar 65915b: OUTPUT«0␤»

[20:44] <TimToady> and flat still respects Scalar

[20:45] <jnthn> What TimToady++ said. flat (1, (2, (3, 4), 5)) is 5 elements

[20:45] <ShimmerFairy> Ah, so in what context would 'flat' be recursive as opposed to Slip (which is just one level)? List of Lists or Array of Arrays?

[20:46] *** lizmat left
[20:49] <TimToady> jnthn: so I guess in glr terms I'm thinking (stuff; and; nonsense) is a List[Seq] (assuming List is a punnable role here)

[20:49] *** virtualsue joined
[20:56] <TimToady> (where the Seq in question is really the flattener, which could obviousl be optimized away in simple cases)

[20:58] <jnthn> ShimmerFairy: only lists of lists

[20:58] <jnthn> TimToady: Hm, will have to ponder that a bit

[20:58] *** zakharyas left
[21:00] <ShimmerFairy> thanks, that'll be good to remember :)

[21:05] <jnthn> Gee, that refactor took some doing...

[21:06] *** skids left
[21:06] * jnthn has slayed the "assigning an infinite array to itself" issue

[21:06] <TimToady> slayed...how...

[21:06] *** lucasb joined
[21:06] <jnthn> TimToady: Every problem can be solved by another level of indirection... :)

[21:07] <jnthn> TimToady: It's basically just making sure that the version of things the iterator is reifying doesn't get confused with the current version of things in the array

[21:08] <jnthn> It also let me move some methods out of public API on List that I really didn't think should be there

[21:08] <jnthn> So, all win, I think.

[21:08] *** pochi joined
[21:09] <TimToady> just so we can defining the Hamming sequence in terms of itself someday...

[21:09] *** virtualsue left
[21:09] <timotimo> that'd be swell

[21:10] <TimToady> probably entails avoiding List and doing it all with Seq somehow

[21:11] <jnthn> m: my @a = 42 xx *; @a = @a; say @a[^10] # curious

[21:11] <camelia> rakudo-moar 65915b: OUTPUT«This type does not support positional operations␤  in block <unit> at /tmp/aYNHS3Ehov:1␤␤»

[21:11] <jnthn> yowser 

[21:11] *** mohij_ joined
[21:11] <jnthn> That one works with what I have locally :)

[21:11] <TimToady> segoi

[21:11] *** mohij left
[21:13] *** rurban left
[21:13] *** rurban_ left
[21:13] <timotimo> lisuto desu ka

[21:14] <lucasb> m: say $_ ~~ Callable for &defined, &item, &elems

[21:14] <camelia> rakudo-moar 65915b: OUTPUT«False␤False␤False␤»

[21:14] <lucasb> ^^ What these functions have in common is that they all have traits, further than this I don't know, but I think maybe this is those kind of issues that only happen in core, because of bootstrapping problems

[21:16] <TimToady> m: &defined does Callable; say &defined ~~ Callable

[21:16] <camelia> rakudo-moar 65915b: OUTPUT«True␤»

[21:16] <TimToady> looks like an easy fix :)

[21:16] <RabidGravy> :-O

[21:16] <jnthn> m: my @a = 42 xx *; @a = @a.map(* + 10); say @a[^10] # curious

[21:16] <TimToady> we don't advertise the 'does' operator very much...

[21:17] <camelia> rakudo-moar 65915b: OUTPUT«(timeout)»

[21:17] <jnthn> This is probably in "getting too cute" territory, but I have that one working too :P

[21:17] <TimToady> well, that one works in P5, except for the infiniteness

[21:17] *** muraiki left
[21:17] <ShimmerFairy> The more you can use infinite lists where you're not explicitly reaching for the last element (or all elements) the better, I say :)

[21:18] <jnthn> m: my @a = 42, 43, 44; @a = @a.map(* + 10); say @a[^3] # pretty sure it works in Perl 6 already if you're not infinite :P

[21:18] <camelia> rakudo-moar 65915b: OUTPUT«52 53 54␤»

[21:18] <jnthn> It's easy to get right for finite things.

[21:18] <tony-o> what happened to froggs?

[21:18] <TimToady> P5 actually optimizes away the copy if the LHS and RHS share no identifiers

[21:19] <TimToady> but I suppose there could be aliasing

[21:19] <RabidGravy> TimToady, I thought it was in the http://docs.perl6.org/language/objects but apparently not, will do tomorrow :)

[21:20] <timotimo> m: class Test { }; multi sub infix:<~~>(Test $a, Test $b) { say "oh lord!" }; say Test.new ~~ Test.new

[21:20] <camelia> rakudo-moar 65915b: OUTPUT«False␤»

[21:21] <jnthn> ~~ is too special for that

[21:21] *** mohij joined
[21:21] <jnthn> https://gist.github.com/jnthn/aa370f8b32ef98e4e7c9 # latest GLR stuff with assignment to infinite self fixes

[21:21] <timotimo> i just wanted to make sure it doesn't accidentally actually work and the error message in that PR we just got could be wrong

[21:22] <jnthn> lemme glanc ethe pr

[21:22] *** mohij_ left
[21:22] <tony-o> the p6er formally known as froggs

[21:22] <jnthn> I love the name of that hash...and yes, patch looks good

[21:23] <jnthn> tony-o: Last I heard from FROGGS++, life is busy with $other-things

[21:23] <jnthn> tony-o: I'm sure I saw him come/go on IRC earlier today at least...

[21:23] <tony-o> what is a life without perl6

[21:23] <tony-o> and broken bones

[21:23] <bartolin_> jnthn++ # GLR, nice hash names ... *

[21:24] *** kaare_ left
[21:24] <jnthn> tony-o: Any of us who've been working on it for a while have needed to take breaks now and then. :)

[21:24] * jnthn certainly has

[21:24] <tony-o> i have too :-), and i'm only hacking away on modules

[21:25] <tony-o> i broke some bones while on rest month

[21:25] <RabidGravy> I have to take a break from all forms of software every now and then

[21:25] <tony-o> well, separated them

[21:25] <jnthn> Ouch :(

[21:26] *** rindolf left
[21:26] <tony-o> now i need to figure out which ones of my modules are dead or dying

[21:26] <RabidGravy> I'm quite astonished that I reached a 71 day streak on gh

[21:26] <tony-o> nice

[21:27] <tony-o> ugexe also does that

[21:27] <jnthn> Think I'm doing GLR hacking for today

[21:27] <tony-o> oh god, everything is broken

[21:27] <RabidGravy> 100 will conveniently come a few days before we go to Ibiza ;-)

[21:27] <jnthn> Will do the GLR'd gather/take tomorrow

[21:28] <tony-o> HTTP::Server::Async is being brought back up to snuff, writing a blog about it during the process is painful

[21:28] <TimToady> ++jnthn with jnthn++

[21:28] <tony-o> http://ugexe.com/refactoring-httpserverasync/

[21:28] <tony-o> TimToady: lol

[21:28] *** mohij_ joined
[21:29] *** mohij left
[21:29] <[TuxCM]> http://blog.plover.com/prog/monad-search-2.html <= something for perl6?

[21:30] *** jjido joined
[21:31] <RabidGravy> I'm actually wondering whether roles could do with a whole page in the docs of their own, there is whole swathes of stuff not touched at present - as TimToady pointed out runtime application, but also parameters and so fort

[21:31] <smls_>  /me still doesn't get why mutable Array needs to support infinitness/laziness in the first place. i.e. what it gains us that can't be done with   List + scalar vars   or   List + array vars + binding

[21:33] <RabidGravy> will look in the morning

[21:33] <jnthn> smls_: Mostly that normal people tend to like assignment 

[21:33] <tony-o> did normals

[21:33] <jjido> smls_: do you think that should be limited to non-mutable array?

[21:33] <smls_> mutable List's, yeah

[21:33] <tony-o> oops, did panda break today?

[21:34] <smls_> immutable, I mean

[21:34] <jnthn> smls_: Also, we basically get it for free, given Array ~~ List

[21:34] <jnthn> smls_: At this point it'd actually be more difficult/more code to lose the capability

[21:35] <jjido> what is the logic of having a "*" in $*PID?

[21:35] <smls_> jnthn: Even counting any future work needed to make Array as fast as in Perl 5? :P

[21:37] <TimToady> jjido: all globals are accessed via the dynamic variable system, unless you want to say $PROCESS::PID instead

[21:37] <TimToady> but for most of these, it's beneficial to occasionally allow lying to yourself in a particular dynamic scope

[21:38] <RabidGravy> TimToady++ beat me to it

[21:38] <jjido> there is a dynamic variable system?

[21:39] <TimToady> well, yes, or I wouldn'ta mentioned it...

[21:39] <jnthn> smls_: I'm not convinced Array potentially supporting laziness is where the performance challenge is.

[21:39] *** khw left
[21:40] <RabidGravy> well you might just be making shit up in the expectation that someone will make it work before it gets tested

[21:40] <jjido> TimToady: all right I will find the relevant doc myself...

[21:40] <TimToady> RabidGravy: but that would make me a retardo :)

[21:41] <jnthn> smls_: I mean, "are we assigning to a not-yet-reified lazy area of the array" probably JITs into a a few machine instructions

[21:41] <smls_> jnthn: As for "people tend to like assignment": I, for one, like certainty. An assignment that magically happens to work now but can be caused to hang indefinitely through action at a distance (e.g. input no longer considered "known infinite"), seems kinda scary to me.

[21:41] <jnthn> smls_: And for access it's just part of the bounds check.

[21:41] <TimToady> smls_: then don't poke infinite lists into Arrays :P

[21:41] <RabidGravy> TimToady :-O

[21:41] <smls_> TimToady: So why support it?

[21:42] <TimToady> because it's nice when you need it

[21:42] <jnthn> fwiw, the .infinite handling should be a decent bit more transitive

[21:42] <smls_> especially scary since it doesn't seem to be very precisely defined when Perl 6 should consider something "known infinite".

[21:43] <smls_> If there will be competing implementations besides Rakudo, will an array assignment that works in one hang indefinitely in the other?

[21:43] <TimToady> there's always hope

[21:43] <jnthn> Just 'cus it hasn't so far been precisely defined doesn't mean it can't be.

[21:43] <timotimo> m: say do while (^3.pick) { print "." }

[21:43] <jnthn> I suspect it's not been written down 'cus we know the current answers there haven't been good enough.

[21:43] <camelia> rakudo-moar 5da323: OUTPUT«(timeout)Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at /tmp/eo9Bap3ghO:1␤    ------> 3say do while (^37⏏5.pick) { print "." }␤...............................................................…»

[21:44] <timotimo> oh, hehehe

[21:44] <TimToady> timotimo: prec

[21:44] <timotimo> m: say do while ((^3).pick) { print "." }

[21:44] <camelia> rakudo-moar 5da323: OUTPUT«.0␤»

[21:44] <timotimo> m: say do while (!(^2).pick) { print "." }

[21:44] <camelia> rakudo-moar 5da323: OUTPUT«False␤»

[21:44] <jnthn> With the GLR, .infinite moves into Iterator rather than being on List

[21:44] <jjido> dynamic scoping ew

[21:44] <timotimo> are you all fine with me throwing out the return value of the while loop to be the argument evaled to decide to stop?

[21:45] <timotimo> we'll change the return value of while during the GLR anyway

[21:45] <jnthn> timotimo: I think Rakudo already emits while loops with a Nil afterwards anyway

[21:46] <timotimo> doesn't seem so, look at my eval results up there

[21:47] <jnthn> timotimo: ergh

[21:47] <jnthn> timotimo: That's REALLY wrong though

[21:47] <timotimo> :)

[21:47] <jnthn> We're meant to return the list of things in that context

[21:47] <timotimo> yeah

[21:47] <TimToady> we never return conditionals in P6; that's P5-think

[21:48] <timotimo> well, "nqp::while" was implemented that way so far

[21:48] <jnthn> TimToady: Yeah, the code-gen somehow ended up that way.

[21:48] <timotimo> and so we ended up p6sink-ing all the flags to while loops all over the world

[21:48] <TimToady> it seemed like a good idea at the time...

[21:50] <Sgeo> Instead of working now, maybe known-infinite stuff should crash

[21:50] <Sgeo> So that known-infinite = crash and infinite loop = hang, they're still both failing

[21:50] <jnthn> Sgeo: You misunderstood "known infinite"

[21:51] <Sgeo> ?

[21:51] <jnthn> It means "we know this thing is infinite, be sure not to try and reify all of it"

[21:51] <TimToady> it's more like known arbitrarily long

[21:51] <Sgeo> jnthn, I think that shouldn't be a success though, it should indicate failure or be indistinguishable from hanging, ala Haskell

[21:52] <Sgeo> HAskell's undefined causes a crash if used, but infinite loops can cause a hang if used, they're considered the same sort of thing (bottom)

[21:52] <jnthn> Sgeo: I don't follow, but I don't think you grok what we're talking about well enough.

[21:52] <TimToady> Haskell certainly allows infinite lists in the sense we're discussing

[21:53] <Sgeo> But if you try to find the length of one, it loops infinitely

[21:53] <TimToady> m: say (1..*).elems

[21:53] <camelia> rakudo-moar 5da323: OUTPUT«Inf␤»

[21:54] <jnthn> This is about how my @b = 1..10; my @a = @b; @b[0]++; say @a; doesn't end up with 2 because we were too lazy, while my @a = 1..*; can work too

[21:54] <Sgeo> TimToady, if 1..* was not known infinite (but actually infinite), would it hang, or eventually output something?

[21:54] <RabidGravy> all sorts of things have "infinite" lists in the sense there is no known upper bound when asked

[21:55] <TimToady> yes, then you'd might have troubles, but we're not so interested in catching that at compile time

[21:55] <TimToady> that failure mode is usually quite obvious at run time :)

[21:55] <Sgeo> TimToady, what if it's only obvious in one implementation but another it works and returns Inf?

[21:56] *** mohij_ left
[21:56] <TimToady> then our tests are not testing very well

[21:57] <ShimmerFairy> jnthn: about ~~ being too special; I reported a bug on your own multi infix:<~~> not working while investigating the fact that ~~ doesn't chain, and they both appear to arise from ~~ being handled specially.

[21:58] <ShimmerFairy> Also, is there a provision for not being able to override ~~ in the spec? It was my understanding that operators were generally override-able.

[21:58] <jnthn> ShimmerFairy: We've already patched it to disallow defining a multi infix:<~~>

[21:58] <jnthn> So you don't get surprised.

[21:58] *** TEttinger joined
[21:58] <jnthn> No, not all of them

[21:58] <jnthn> := and = are two other examples of oens that aren't

[21:58] <TimToady> Sgeo: note also that it's pretty easy to mark a list as infinite just by putting something infinite at the end

[21:59] <jnthn> ~~ can't actually be implemented just as a multi sub 'cus it needs to set $_ to the RHS while it evaluates the LHS

[21:59] <ShimmerFairy> jnthn: yeah, I saw them in the %specials hash, along with the flipflop ops and so on :)  Unfortunately, I don't know how to make ~~ and !~~ chain like they're supposed to (trying to change the custom QAST so it calls chain caused the optimizer to crash IIRC)

[22:00] <Sgeo> What is the scope of flip-flops? Same as state variables?

[22:00] <jnthn> I think if you got that through the optimizer it'd still be problematic at code-gen...

[22:00] <jnthn> Sgeo: Yes

[22:00] <ShimmerFairy> (and removing ~~ and !~~ from the %specials hash predictably didn't work either, causing memory usage to climb until I had to kill it)

[22:00] <jnthn> ShimmerFairy: Things aren't in the specials hash just for the fun of it ;)

[22:01] <ShimmerFairy> jnthn: if it's too hard to make ~~ chain, and there wasn't a need for it, I wonder if it would be alright to make it the one non-chaining op at its precedence level.

[22:01] <jnthn> ShimmerFairy: I'm not sure it's too hard...I just find it really hard to even think about what it means :)

[22:01] <jnthn> Given the thingy that goes on with $_

[22:01] <TimToady> perhaps we could notice a ~~ in a chain and just call .ACCEPTS without topicalizing

[22:02] <ShimmerFairy> jnthn: basically,  1 ~~ 2 ~~ 3 -> (1 ~~ 2) && (2 ~~ 3) , like with the other chaining ops :)

[22:02] <TimToady> since chains are for values, not fancy drancy RHSs

[22:02] <jnthn> ShimmerFairy: Yeah, but chain makes sure to only evaluate the 2 once there

[22:03] <timotimo> super helpful! :)

[22:04] <ShimmerFairy> jnthn: ah, I see. (I looked at the code for nqp::chain , but only understood enough to see that it probably wasn't the problem in making ~~ potentially chain :P)

[22:04] <smls_> m: say ("aa123456bb" ~~ /\d+/) ~~ /3./   # left-associative would be more useful

[22:04] <camelia> rakudo-moar 5da323: OUTPUT«｢34｣␤»

[22:04] <ShimmerFairy> timotimo: I imagine something like  0 < $x ~~ Int  being a nice shorthand for "non-zero positive integer"

[22:06] <ShimmerFairy> jnthn: I think the worst case would be defining a custom 'smartmatch_chain' variant of chain for the precedence parser to use, perhaps (not that I know much about the uglier side of compiler writing ☺)

[22:08] <TimToady> I think we should simply have a default non-topicalizing implementation of infix:<~~> and then treat the bare binary as a special syntactic case that also topicalizes

[22:08] <jnthn> That works for me

[22:09] <TimToady> then you just have to be careful to use @list X~~ *.method rather than .method

[22:11] <smls_> Why remove topicalization altogether? Does   ~~ /regex/   need it somehow? 

[22:11] <ShimmerFairy> btw, am I right in thinking that the infix:<~~> in Mu.pm doesn't get picked up as an operator, just like custom multis?

[22:11] <ShimmerFairy> smls_: yes, regexes match against $_ (try a bare /regex/ in a for loop ☺)

[22:11] <ShimmerFairy> m: for <foo bar baz> { say /^b/ }

[22:11] <camelia> rakudo-moar 5da323: OUTPUT«/^b/␤/^b/␤/^b/␤»

[22:12] <ShimmerFairy> m: for <foo bar baz> { /^b/; say $/ }

[22:12] <camelia> rakudo-moar 5da323: OUTPUT«Nil␤｢b｣␤｢b｣␤»

[22:12] <jnthn> ShimmerFairy: I suspect it is used for meta-ops

[22:12] <smls_> ShimmerFairy: But they also have an .ACCEPTS, don't they?

[22:12] <jnthn> Z~~ and so on

[22:12] <ShimmerFairy> smls_: I believe so

[22:12] <smls_> So would still work without $_

[22:13] <ShimmerFairy> m: class Foo { }; multi sub infix:<~~>(Foo $a, Foo $b) { 42.6 }; say Foo ~~ Foo; say Foo R~~ Foo;

[22:13] <camelia> rakudo-moar 5da323: OUTPUT«True␤42.6␤»

[22:13] <ShimmerFairy> jnthn: ^ I think you're right :)

[22:13] <jnthn> smls_: 'foo' ~~ m/xxx/ needs it though, iirc

[22:14] <smls_> Ah

[22:14] <jnthn> I need to get some rest :)

[22:14] <smls_> s/// to then probably

[22:14] <smls_> *too

[22:14] <jnthn> 'night, #perl6

[22:14] <TimToady> o/

[22:14] <ShimmerFairy> ♞, jnthn o/

[22:14] <RabidGravy> toodlepip

[22:15] <lucasb> Is '$x ~~ .method' supposed to call $x.method?

[22:15] <timotimo> no

[22:15] <timotimo> er

[22:15] <timotimo> yes

[22:15] <lucasb> yes or no? :D

[22:16] <timotimo> yes.

[22:16] <lucasb> ok then :)

[22:16] <lucasb> m: say 65 ~~ .chr

[22:16] <camelia> rakudo-moar 5da323: OUTPUT«False␤»

[22:16] <lucasb> m: say 65 ~~ *.chr

[22:16] <camelia> rakudo-moar 5da323: OUTPUT«A␤»

[22:17] <lucasb> What should the return value of '65 ~~ .chr' be?

[22:17] <TimToady> False

[22:18] <TimToady> it calls "A".ACCEPTS(65)

[22:18] <ShimmerFairy> m: say 65 ~~ .Str

[22:18] <camelia> rakudo-moar 5da323: OUTPUT«True␤»

[22:18] <TimToady> "65".ACCEPTS(65) is True, yes

[22:21] <lucasb> oh, thanks; I guess my brain is tired

[22:28] * TimToady --> nap &

[22:28] *** spider-mario left
[22:28] <timotimo> TimToady ~~ .nap

[22:29] <dalek> nqp: 1b257a1 | timotimo++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[22:29] <dalek> nqp: a slightly more verbose error message for localref

[22:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1b257a13ca

[22:29] <dalek> nqp: 808ce0f | timotimo++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[22:29] <dalek> nqp: throw out nqp::while return value

[22:29] <dalek> nqp: 

[22:29] <dalek> nqp: it used to return the value of the condition, but that

[22:29] <dalek> nqp: doesn't help rakudo with its semantics. instead, it caused

[22:29] <dalek> nqp: every condition of a while loop to have .sink attempted

[22:29] <dalek> nqp: on it, even in cases where we know it doesn't make sense.

[22:29] <dalek> nqp: 

[22:29] <dalek> nqp: so now we either have the register be an object that's null'd

[22:29] <dalek> nqp: or set the return kind to void.

[22:29] <dalek> nqp: 

[22:29] <dalek> nqp: Also, remove fossilized IMM_ARG mention.

[22:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/808ce0fcb5

[22:31] *** smls joined
[22:31] *** smls_ left
[22:34] *** lucasb left
[22:47] *** skids joined
[22:56] <RabidGravy> right bed

[22:56] <RabidGravy> turrah

[22:59] *** jjido left
[22:59] *** kurahaupo left
[23:01] *** RabidGravy left
[23:09] *** lizmat joined
[23:11] *** baest left
[23:13] <dalek> rakudo/nom: 4332300 | usev6++ | src/Perl6/Grammar.nqp:

[23:13] <dalek> rakudo/nom: Complain when trying to override smartmach operator

[23:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/433230052f

[23:13] <dalek> rakudo/nom: b6f6c1f | lizmat++ | src/Perl6/Grammar.nqp:

[23:13] <dalek> rakudo/nom: Merge pull request #487 from usev6/rt125745

[23:13] <dalek> rakudo/nom: 

[23:13] <dalek> rakudo/nom: Complain when trying to override smartmach operator

[23:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6f6c1f5ff

[23:16] *** virtualsue joined
[23:17] *** telex left
[23:17] <dalek> rakudo-star-daily: ebe7644 | coke++ | log/ (9 files):

[23:17] <dalek> rakudo-star-daily: today (automated commit)

[23:17] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ebe764463d

[23:17] <dalek> perl6-roast-data: a1e4669 | coke++ | / (9 files):

[23:17] <dalek> perl6-roast-data: today (automated commit)

[23:17] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/a1e466975c

[23:18] *** telex joined
[23:23] *** baest joined
[23:24] *** EINVAL joined
[23:27] <dalek> rakudo/nom: 2f7ab34 | lizmat++ | src/core/Distro.pm:

[23:27] <dalek> rakudo/nom: Don't let absence of lsb_release spoil things

[23:27] <dalek> rakudo/nom: 

[23:27] <dalek> rakudo/nom: See: http://blogs.perl.org/users/aaron_baugher/2015/08/minor-issue-with-perl-6-install-on-centos-6.html

[23:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f7ab34b8d

[23:28] <lizmat> good night, #perl6!

[23:29] *** smls left
[23:30] <EINVAL> Night lizmat

[23:30] *** baest left
[23:31] * timotimo goes to sleep, too

[23:42] *** Zoffix left
[23:47] *** Zoffix joined
[23:48] <[Coke]> ~~

[23:49] *** baest joined
[23:51] *** EINVAL left
[23:52] *** Zoffix left
[23:53] *** captain-adequate left
[23:55] <[Coke]> r: (0, {last if $^a==$^b; (1..5).pick} ... *).perl.say

[23:55] <camelia> rakudo-{moar,jvm} 2f7ab3: OUTPUT«(ListIter.new,)␤»

[23:55] *** Zoffix joined
[23:56] *** baest_ joined
[23:57] *** baest left
