[00:04] *** virtualsue left
[00:10] <J-L> I gotta go now, but thanks to everyone for all your help!  Perl6 is looking like it's gonna be a great language!

[00:11] <timotimo> big parts of it already are <3

[00:14] *** adu left
[00:15] *** vendethiel left
[00:16] <dalek> rakudo/nom: 976eeaf | jnthn++ | src/core/ (2 files):

[00:16] <dalek> rakudo/nom: Switch Array/Hash to use method ^parameterize.

[00:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/976eeafb77

[00:16] <dalek> rakudo/nom: b7dc805 | jnthn++ | src/core/ (2 files):

[00:16] <dalek> rakudo/nom: Switch a few places to use .^parameterize.

[00:16] *** dalek left
[00:16] <jnthn> That was the merge of parameterize-cleanup

[00:17] *** dalek joined
[00:17] *** ChanServ sets mode: +v dalek

[00:18] <Mouq> jnthn++

[00:19] <jnthn> Tomorrow, native arrays.

[00:19] <jnthn> :)

[00:19] <Mouq> jnthn: Does that have preformance implications?

[00:19] <Mouq> *per

[00:19] <jnthn> Mouq: Not especially

[00:19] <jnthn> Mouq: It certainly shouldn't hurt.

[00:19] <jnthn> Mouq: It removes a level of indirection, but not on a hot path

[00:19] <Mouq> jnthn: Right :)

[00:20] *** vendethiel joined
[00:20] <jnthn> It's more a design fix, removing an icky meta-level/non-meta-level confusion.

[00:24] <Mouq> m: my sub foo (@a[$,$]) {}

[00:24] <camelia> rakudo-moar 9411a7: OUTPUT«5===SORRY!5===␤Shape declaration is not yet implemented; please use whitespace if you meant a subsignature for unpacking␤at /tmp/lw_ieHh0vp:1␤------> 3my sub foo (@a7⏏5[$,$]) {}␤Unsupported use of $] variable; in Perl 6 please use $*PERL.…»

[00:24] <Mouq> That seems too easy to mistake for @a [$,$] once we get shapes

[00:25] <Mouq> Would it be a terrible idea just to restrict subsig definitions to (@a :($, $)) ? (after a deprecation cycle)

[00:26] *** laouji joined
[00:26] <Mouq> m: my sub foo (@a:($,$)) {}

[00:26] <camelia> rakudo-moar 9411a7: ( no output )

[00:26] <Mouq> m: my sub foo (@a:($,$)) {}([1,2,3])

[00:26] <camelia> rakudo-moar 9411a7: OUTPUT«Too many positionals passed; expected 2 arguments but got 3 in sub-signature of parameter @a:␤  in sub foo at /tmp/JM0pxGvNtG:1␤  in block <unit> at /tmp/JM0pxGvNtG:1␤␤»

[00:27] <Mouq> m: my sub foo (@a :($,$)) {}([1,2,3])

[00:27] <camelia> rakudo-moar 9411a7: OUTPUT«===SORRY!===␤Cannot invoke this object (REPR: P6opaque, cs = 0)␤»

[00:27] <Mouq> I dunno what that's about

[00:28] <jnthn> Well, the reason we have the [...] form is that it implies Positional

[00:28] <jnthn> So you can write

[00:28] <jnthn> sub foo([$head, *@tail]) { }

[00:28] <Mouq> Also the ->$a{} vs ->$a {} keeps biting me in one-liners

[00:28] <jnthn> And it will only accept a Positional argument.

[00:29] <Mouq> jnthn: @:(…) should already work, and I don't see a problem with :[…]

[00:30] <Mouq> m: sub foo(@:($head, *@tail)) {say @tail.perl}([4,5,6,7])

[00:30] <camelia> rakudo-moar 9411a7: OUTPUT«Array.new(5, 6, 7)␤»

[00:30] *** pecastro joined
[00:31] <jnthn> It ain't as pretty, though... :)

[00:31] <Mouq> m: my (@a :($b, $c)) = [1, 2]; say @a; say $b; say $c

[00:31] <camelia> rakudo-moar 9411a7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/cUknIvn7Kz␤Variable '$b' is not declared␤at /tmp/cUknIvn7Kz:1␤------> 3 (@a :($b, $c)) = [1, 2]; say @a; say $b7⏏5; say $c␤    expecting any of:␤        postfix␤»

[00:31] <Mouq> jnthn: Yeah…

[00:32] <jnthn> Time for some sleep :)

[00:32] <Mouq> I don't think sub foo(:[$head, *@tail]) { } is too bad, but it's not quite as "homoiconic", to misuse a word

[00:32] <Mouq> 'night jnthn :)

[00:32] <jnthn> 'night

[00:33] <Mouq> We could still recognize ([…]) as a sub-sig long as there's no variable there…

[00:33] <Mouq> s/variable/parameter

[00:39] *** laouji left
[00:40] *** laouji joined
[00:42] *** laouji left
[00:50] *** laouji joined
[00:58] *** dayangkun joined
[01:08] *** yeahnoob joined
[01:16] *** fhelmberger joined
[01:17] *** raiph joined
[01:20] *** fhelmberger left
[01:23] <timotimo> who knows where i find the place nqp-moar puts types into the hll config?

[01:24] *** espadrine left
[01:27] <timotimo> oh, it lives inside moarvm in 6model/bootstrap, probably

[01:43] *** madmuid left
[02:03] *** kaare_ left
[02:07] *** adu joined
[02:08] *** colomon left
[02:09] *** colomon joined
[02:14] *** agentzh joined
[02:14] *** agentzh left
[02:14] *** agentzh joined
[02:14] *** bayprogrammer left
[02:14] <agentzh> I've put together my benchmark programs for various perl 5/perl 6 top-down parsing libraries (or builtins): https://github.com/agentzh/perl-parsing-library-benchmark

[02:14] <yoleaux> 3 Mar 2015 00:40Z <japhb> agentzh: https://gist.github.com/agentzh/c5108a959309f015c4f6 looks like a very nice benchmark; can you create a PR for https://github.com/japhb/perl6-bench adding this as one of the minibenchmarks?

[02:14] <agentzh> perl 5's Pegex is a clear winner in this test.

[02:15] <agentzh> yoleaux: perl6-bench is an ambitious project. but i'd like to keep my scripts in a separate repos :)

[02:17] <japhb> agentzh: Honest question: why the hesitation?  Feel like you can't iterate fast enough?  Having trouble understanding what you need to do to add tests to perl6-bench?  Not getting what you want from it?

[02:18] <japhb> I'm trying to understand because I find I'm having trouble convincing people in general to put tests in perl6-bench and not just as one-offs, and I don't understand why.

[02:18] <agentzh> japhb: well, just want to have a focus :)

[02:18] <japhb> Did you know that perl6-bench allows tests to be tagged and filtered, so you can run and analyze only the tests you care about?

[02:19] <agentzh> japhb: and don't want to distract too much. no offense to the perl6-bench project :)

[02:19] <japhb> I wasn't at all offended.  I'm just trying to figure out what I need to do to make it more attractive.

[02:20] <agentzh> japhb: feel free to grab whatever in my benchmark scripts into perl6-bench :)

[02:20] <japhb> The value of perl6-bench to the community is strongly correlated with how well it includes the tests people really care about.

[02:20] *** chenryn joined
[02:20] <japhb> agentzh: Oh, so you don't mind having a snapshot included in the perl6-bench collection?

[02:20] <agentzh> japhb: i admit i lack enough energy and motivation to do that myself :)

[02:21] <japhb> Ah, hmmm.  I need to find a way to lower that barrier considerably, methinks.

[02:21] * japhb at bus-stop, bbiab.

[02:24] <agentzh> in this little benchmark, rakudo is the slowest. it'll be great if you guys can help reviewing the benchmark scripts for me because I may do something stupid that messes up the results :) I'm still learning Perl 6.

[02:25] <agentzh> oh, one caveat is that the numbers include the startup time.

[02:39] *** kaare_ joined
[02:41] *** cognominal joined
[02:49] *** grondilu joined
[02:49] *** agentzh left
[03:12] <adu> hi all

[03:13] <adu> how goes?

[03:13] <japhb> It goes quietly at this time of night.  :-)

[03:15] *** agentzh joined
[03:16] *** skids left
[03:18] *** Psyche^ joined
[03:20] *** vendethiel left
[03:21] *** skids joined
[03:21] <adu> japhb: oh, right

[03:22] *** noganex_ joined
[03:22] *** Patterner left
[03:23] *** vendethiel joined
[03:25] *** noganex left
[03:27] *** cognominal left
[03:32] *** HelloWorld joined
[03:33] *** grondilu left
[03:35] *** mr-foobar left
[03:40] *** HelloWorld left
[03:46] *** vendethiel left
[03:47] *** vendethiel joined
[03:53] * Mouq tried making agentzh++'s Perl 6 bench a little more idiomatic, but it was no help :|

[04:02] <adu> Mouq: did it make it slower?

[04:04] <Mouq> No

[04:04] <Mouq> But I could easily make it slower… for example changing some for loops into reduces

[04:04] <Mouq> But I was trying to match the Pegex versoin

[04:07] *** lichtkind left
[04:10] *** vendethiel left
[04:12] *** agentzh left
[04:18] *** vendethiel joined
[04:32] *** chenryn left
[04:34] <raydiak> good evening, #perl6

[04:41] *** vendethiel left
[04:43] *** dj_goku joined
[04:54] *** yeahnoob left
[04:55] *** laouji left
[04:59] *** jdv79 left
[04:59] *** chenryn joined
[05:03] *** vendethiel joined
[05:06] *** adu left
[05:12] *** st_iron joined
[05:13] *** agentzh joined
[05:17] *** mr-foobar joined
[05:19] *** jdv79 joined
[05:21] *** madmuid joined
[05:25] *** vendethiel left
[05:30] *** telex left
[05:30] *** vendethiel joined
[05:31] *** laouji joined
[05:32] *** telex joined
[05:43] *** agentzh left
[05:48] *** st_iron left
[05:49] *** diana_olhovik_ joined
[06:10] *** agentzh joined
[06:13] *** cognominal joined
[06:16] <TimToady> I'm fine with '0' being true, as long as IntStr 0 is false

[06:20] *** st_iron joined
[06:22] *** diana_olhovik_ left
[06:23] *** agentzh left
[07:01] *** diana_olhovik joined
[07:04] *** prime left
[07:10] *** prime joined
[07:18] *** wicope joined
[07:19] *** gfldex joined
[07:21] <[Tux]> why can push not handle Inf?

[07:21] <[Tux]> m: (1,4..7,9..Inf).perl.say

[07:21] <camelia> rakudo-moar 076da8: OUTPUT«(1, 4..7, 9..Inf)␤»

[07:21] <[Tux]> m: my@x=1;my$x=4;@x.push($x..7);$x=9;@x.pus  ($x..Inf);@x.perl.say

[07:21] <camelia> rakudo-moar 076da8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/FXMQ4BbEKm␤Two terms in a row␤at /tmp/FXMQ4BbEKm:1␤------> 3my@x=1;my$x=4;@x.push($x..7);$x=9;@x.pus7⏏5  ($x..Inf);@x.perl.say␤    expecting any of:␤        infix stopper␤        infix or meta…»

[07:21] <[Tux]> m: my@x=1;my$x=4;@x.push($x..7);$x=9;@x.push($x..Inf);@x.perl.say

[07:21] <camelia> rakudo-moar 076da8: OUTPUT«Cannot .push an infinite list␤  in block <unit> at /tmp/plGAjLg7vX:1␤␤»

[07:22] <[Tux]> can I *dynamically* put an $x .. Inf entry in @x?

[07:23] <TimToady> use .plan instead of .push

[07:23] <[Tux]> top!

[07:23] <TimToady> .push is eager

[07:23] <dalek> rakudo/nom: 0a8bdf2 | lizmat++ | src/core/Deprecations.pm:

[07:23] <dalek> rakudo/nom: Kebab-case RAKUDO_NO_DEPRECATIONS

[07:23] <dalek> rakudo/nom: 

[07:23] <dalek> rakudo/nom: There is no point in adding a deprecation cycle here, as adding it would

[07:23] <dalek> rakudo/nom: inhibit seeing that particular deprecation message.  Since hardly anybody

[07:23] <dalek> rakudo/nom: is using this feature, I tought it'd be safe to kebab-case immediately.

[07:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0a8bdf23f5

[07:23] <[Tux]> m: my@x=1;my$x=4;@x.plan($x..7);$x=9;@x.plan($x..Inf);@x.perl.say

[07:23] <[Tux]> that hangs

[07:24] <camelia> rakudo-moar 076da8: OUTPUT«(timeout)»

[07:24] <TimToady> well, it's supposed to work...

[07:24] <[Tux]> RT?

[07:24] <TimToady> though I think current implementation only allows one plan at a time

[07:25] *** FROGGS joined
[07:25] <TimToady> but that doesn't look like the problem here

[07:26] <TimToady> m: my @x = 1,2,3; @x.plan('a'..*); say @x

[07:26] <camelia> rakudo-moar 076da8: OUTPUT«1 2 3 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn …»

[07:26] <TimToady> well, maybe it is

[07:26] <[Tux]> I'll RT

[07:26] <TimToady> m: my @x = 1,2,3; @x.plan(7,8,9); @x.plan('a'..*); say @x

[07:26] <camelia> rakudo-moar 076da8: OUTPUT«1 2 3 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl …»

[07:27] <TimToady> yeah, better RT that

[07:27] <FROGGS> o/

[07:28] *** TryOut6 joined
[07:28] <TryOut6> m: infix<+>(42,43)

[07:28] <camelia> rakudo-moar 076da8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1lYp9uDINf␤Undeclared routine:␤    infix used at line 1. Did you mean 'index', 'indir'?␤␤»

[07:28] <TryOut6> m: infix+(42,43)

[07:28] <camelia> rakudo-moar 076da8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/2fM0pefff8␤Undeclared routine:␤    infix used at line 1. Did you mean 'index', 'indir'?␤␤»

[07:29] <TimToady> m: infix:<+>(42,43)

[07:29] <camelia> rakudo-moar 076da8: ( no output )

[07:29] <TimToady> m: infix:<+>(42,43).say

[07:29] <camelia> rakudo-moar 076da8: OUTPUT«85␤»

[07:29] <TimToady> need the colon

[07:29] <TryOut6> m: infix:<+>(42,43)

[07:29] <camelia> rakudo-moar 076da8: ( no output )

[07:29] <TimToady> and the say

[07:30] <FROGGS> or print...

[07:30] <TryOut6> Hi, Larry I am trying out the stuff that you showed me yesteday. :-)

[07:30] <TryOut6> I see now. :-)

[07:30] <TimToady> I recognized it :)

[07:30] <TryOut6> m: infix:<+>(42,43).say

[07:30] <camelia> rakudo-moar 076da8: OUTPUT«85␤»

[07:31] <TimToady> m: say infix:<+>(42,43)

[07:31] <camelia> rakudo-moar 076da8: OUTPUT«85␤»

[07:31] <TimToady> can go out front too

[07:31] <TryOut6> m: infix:<max>().say

[07:31] <camelia> rakudo-moar 076da8: OUTPUT«-Inf␤»

[07:31] <TimToady> FP vs OO in a nutshell :)

[07:31] <TryOut6> Yes It has -Infintiy :-)

[07:31] <TimToady> m: [max].say

[07:31] <camelia> rakudo-moar 076da8: OUTPUT«-Inf␤»

[07:31] <TryOut6> m: infix:<min>().say

[07:31] <camelia> rakudo-moar 076da8: OUTPUT«Inf␤»

[07:32] <TryOut6> (-Infinity, Infinity) Wowowowowowowoowowowowowowo :-)

[07:32] <TimToady> say 42 ~~ -Inf..Inf

[07:32] <TimToady> m: say 42 ~~ -Inf..Inf

[07:32] <camelia> rakudo-moar 076da8: OUTPUT«True␤»

[07:33] <TimToady> m: say -Inf ~~ 42..Inf

[07:33] <camelia> rakudo-moar 076da8: OUTPUT«False␤»

[07:33] <TryOut6> :-)

[07:33] <TryOut6> Now let me try the Swartian tranasorm. :-)

[07:34] <TryOut6> (10,11,23,14,26,78,7,8).sort()

[07:34] <TryOut6> M: (10,11,23,14,26,78,7,8).sort()

[07:34] <TryOut6> m: (10,11,23,14,26,78,7,8).sort()

[07:34] <camelia> rakudo-moar 076da8: ( no output )

[07:34] <lizmat> m: (10,11,23,14,26,78,7,8).sort().say

[07:34] <camelia> rakudo-moar 076da8: OUTPUT«7 8 10 11 14 23 26 78␤»

[07:35] <TryOut6> Ih, yes I am forgeting the say... :-)

[07:35] <dalek> doc: 0d07d54 | (Justin DeVuyst)++ | lib/Language/ (5 files):

[07:35] <dalek> doc: Fix some bad links.

[07:35] <dalek> doc: review: https://github.com/perl6/doc/commit/0d07d54149

[07:35] <dalek> doc: 8f5d6b3 | (Justin DeVuyst)++ | lib/Language/5to6.pod:

[07:35] <dalek> doc: Fix a mis-spelling.

[07:35] <dalek> doc: review: https://github.com/perl6/doc/commit/8f5d6b325c

[07:35] <dalek> doc: 0951d69 | FROGGS++ | lib/Language/ (6 files):

[07:35] <dalek> doc: Merge pull request #60 from jdv/master

[07:35] <dalek> doc: 

[07:35] <dalek> doc: typo fixes

[07:35] <dalek> doc: review: https://github.com/perl6/doc/commit/0951d694d3

[07:35] <TryOut6> m: (10,11,23,14,26,78,7,8).sort().say

[07:35] <camelia> rakudo-moar 076da8: OUTPUT«7 8 10 11 14 23 26 78␤»

[07:35] <TryOut6> m: (10,11,23,14,26,78,7,8).sort(~).say

[07:35] <camelia> rakudo-moar 076da8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Dbthiz0gm6␤Prefix ~ requires an argument, but no valid term found␤at /tmp/Dbthiz0gm6:1␤------> 3(10,11,23,14,26,78,7,8).sort(~7⏏5).say␤    expecting any of:␤        prefix or meta-prefix␤»

[07:36] *** mr-foobar left
[07:36] <FROGGS> m: (10,11,23,14,26,78,7,8).sort( :by(* leg *) ).say

[07:36] <camelia> rakudo-moar 076da8: OUTPUT«7 8 10 11 14 23 26 78␤»

[07:36] <lizmat> m: (10,11,23,14,26,78,7,8).sort(*.Str).say

[07:36] <camelia> rakudo-moar 076da8: OUTPUT«10 11 14 23 26 7 78 8␤»

[07:36] <FROGGS> ahh

[07:36] <TryOut6> m: (10,11,23,14,26,78,7,8).sort(*.Str).say

[07:36] <camelia> rakudo-moar 076da8: OUTPUT«10 11 14 23 26 7 78 8␤»

[07:37] <FROGGS> m: (10,11,23,14,26,78,7,8).sort(* leg *).say

[07:37] <camelia> rakudo-moar 076da8: OUTPUT«10 11 14 23 26 7 78 8␤»

[07:37] <FROGGS> it is a positional not a named... need to adjust my memory

[07:37] <lizmat> FROGGS: arity 1 in the the block, makes a schwartzian transform, arity 2 doesn't

[07:37] <TryOut6> Well, yeah, however yesterday Larry showed me a trick with just one character.

[07:37] <lizmat> do tell!

[07:38] <TryOut6> I do not rememeber... :-(

[07:38] <Mouq> m: say &[+](1,2) # this?

[07:38] <camelia> rakudo-moar 076da8: OUTPUT«3␤»

[07:38] <TimToady> m: (10,11,23,14,26,78,7,8).sort(+*)

[07:38] <camelia> rakudo-moar 076da8: ( no output )

[07:38] <TimToady> m: (10,11,23,14,26,78,7,8).sort(+*).say

[07:38] <camelia> rakudo-moar 076da8: OUTPUT«7 8 10 11 14 23 26 78␤»

[07:38] <TimToady> m: (10,11,23,14,26,78,7,8).sort(~*).say

[07:38] <camelia> rakudo-moar 076da8: OUTPUT«10 11 14 23 26 7 78 8␤»

[07:38] <FROGGS> ahh

[07:39] <TryOut6> Yeah that was it. :-)

[07:39] <TryOut6> m: (10,11,23,14,26,78,7,8).sort(~*).say

[07:39] <camelia> rakudo-moar 076da8: OUTPUT«10 11 14 23 26 7 78 8␤»

[07:39] <TryOut6> :-)

[07:39] <lizmat> TimToady: looks like .plan will gimme(*) any existing nextiter and blow up if it was infinite

[07:39] <lizmat> so I'm not sure what the problem is

[07:40] <TimToady> but in the RT'd one the first .plan wasn't infinite

[07:40] <TryOut6> Oh, Boy, this so much fun. Now Larry if you are in Budapest that I would like to recomend to you the Spas that are available. :-)

[07:40] <Mouq> m: (1..*).plan(42)

[07:40] <camelia> rakudo-moar 076da8: OUTPUT«No such method 'plan' for invocant of type 'Range'␤  in block <unit> at /tmp/cQU9KNoRJg:1␤␤»

[07:40] <TimToady> was at one already

[07:40] <Mouq> m: (1..*).list.plan(42)

[07:40] <camelia> rakudo-moar 076da8: OUTPUT«Unhandled exception: Cannot add plan to an infinite list␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:15248  (/home/camelia/rakudo-inst-1/languages/perl6/runt…»

[07:40] <Mouq> ^^

[07:41] <lizmat> [Tux]: I don't think there is a problem with .plan

[07:41] <TryOut6> Okie. Probabley you went to Sechenyi...

[07:41] <TryOut6> Szechenyi. :-)

[07:41] <lizmat> it's the .perl that is trying to generate a string representing an infinite list, on which it is hanging

[07:41] <TimToady> it's the open air one

[07:42] <TryOut6> Byt the others are fun too. :-)

[07:42] <TryOut6> http://www.spasbudapest.com/

[07:42] <lizmat> m: my@x=1;my$x=4;@x.plan($x..7);$x=9;@x.plan($x..Inf);@x.say     # implicitely use .gist, which *does* stop

[07:42] <camelia> rakudo-moar 0a8bdf: OUTPUT«1 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 9…»

[07:42] <TryOut6> I also like the Rudas, and the Lukacs. :-)

[07:42] <TryOut6> They are smaller, but fun. :-)

[07:42] <TimToady> but not as much fun if I have to be in a different area from Gloria

[07:43] <Mouq> lizmat: No, .plan does .gimme(*)

[07:43] <TryOut6> And the Gellert has his atmosphere. :-)

[07:43] <Mouq> That's the problem

[07:43] <TryOut6> I see.

[07:43] <Mouq> synopses say "Adds the list to the end of @array lazily as a kind of "lazy push""

[07:43] <TryOut6> Then ignore the Rudas, go to Lukacs that is coeducated. :-)

[07:44] <TryOut6> And be sure to pay for the sauna world. ;-)

[07:44] <lizmat> Mouq: yes, it *does* generate all elements before the .plan, yes...

[07:44] <lizmat> not sure whether that is a bug or not

[07:44] <TryOut6> Other thing that you might want to try out are the ruin pubs. :-)

[07:44] <TryOut6> Try it out in the evenings or at night. :-)

[07:45] <lizmat> .oO( read that as "are to ruin pubs )

[07:45] <TryOut6> Nooo... :)

[07:46] <TryOut6> They will not ruin you, there are inside of ruin houses. :-)

[07:46] <TryOut6> One of the most famous is the Szimpla Kert, but there are others too. :-)

[07:47] <[Tux]> lizmat, what, in your opinion, is the correct way to dynamically build (1, 4..7, 9..Inf)?

[07:48] *** raiph left
[07:48] <lizmat> m: my @x = 1; @x.plan(4..7); @x.plan(9..Inf); say @x[^10]

[07:48] <camelia> rakudo-moar 0a8bdf: OUTPUT«1 4 5 6 7 9 10 11 12 13␤»

[07:48] *** Ven joined
[07:48] <[Tux]> but I want to use @x as a subscript in @y[@x]

[07:50] <lizmat> m: my @y = ^20; my @x = 1; @x.plan(4..7); @x.plan(9..Inf); say @y[@x]  # not seeing the problem

[07:50] <camelia> rakudo-moar 0a8bdf: OUTPUT«1 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19␤»

[07:50] <[Tux]> hmm, so only using .perl on that is something to rather not do

[07:51] <TryOut6> Okie guys this was so fun, but I need to goo back to work. :-)

[07:51] <TryOut6> Bye. Now. :-)

[07:51] <lizmat> bye TryOut6 

[07:52] <TryOut6> By lizmat. :-)

[07:52] <lizmat> [Tux]: yes, because .perl is by definition eager

[07:52] *** TryOut6 left
[07:54] <lizmat> I guess we could make .push smarter about pushing an infinite list onto an finite list

[07:54] *** darutoko joined
[07:54] <lizmat> it would be more DWIM in a way, but perhaps also a WAT

[07:54] <lizmat> perhaps TimToady has some thoughts ?

[07:55] <TimToady> push is supposed to be eager

[07:55] <lizmat> it's just that you may not know what you're pushing onto a list

[07:56] <lizmat> making .push to a .plan for you, when it can, seems DWIM to me

[07:56] <lizmat> *to do

[07:56] <CurtisOvidPoe> m: sub f($n is rw) {$n=$n+1; say $n};f(3)

[07:56] <camelia> rakudo-moar 0a8bdf: OUTPUT«Cannot assign to an immutable value␤  in sub f at /tmp/WfatAVYfks:1␤  in block <unit> at /tmp/WfatAVYfks:1␤␤»

[07:57] <CurtisOvidPoe> I though declaring the argument as “is rw” means it’s no longer immutable?

[07:57] <moritz> it should actually fail at dispatch time

[07:57] <moritz> an 'is rw' param shouldn't even bind to a non-container

[07:58] <CurtisOvidPoe> I don’t know what this means: “shouldn’t even bind to a non-container”

[07:58] <CurtisOvidPoe> Ah, it’s a constant!

[07:59] <CurtisOvidPoe> So “is rw” creates an alias instead of a copy?

[07:59] <lizmat> m: sub f($n is rw) {say $n; $n=$n+1};f(3)  # the "say" shouldn't even be done, is what moritz means

[07:59] <camelia> rakudo-moar 0a8bdf: OUTPUT«3␤Cannot assign to an immutable value␤  in sub f at /tmp/p1zVHLjHSi:1␤  in block <unit> at /tmp/p1zVHLjHSi:1␤␤»

[07:59] <moritz> yes

[07:59] <moritz> sub f($x is rw) { }; f 1; # should die

[07:59] <moritz> sub f($x is rw) { }; f my $ = 1; # should live

[07:59] <lizmat> CurtisOvidPoe: maybe you want "is copy" ?

[08:00] <CurtisOvidPoe> lizmat++

[08:05] * Mouq tries to do a one-liner implementation of .plan in terms of .List::gimme but fails

[08:05] <Mouq> (to make it that short, that is :P)

[08:07] <TimToady> commuting to CityBank gig &

[08:08] <lizmat> plan is currently speculated to be: Adds the list to the end of C<@array> lazily as a kind of "lazy push".

[08:08] <lizmat> (That is, the reified part of the array is not modified, but the list

[08:08] <lizmat> is appended to the not-yet-reified specifications for how to

[08:08] <lizmat> extend the array on demand, if it is subscripted or shifted beyond the

[08:08] <lizmat> currently reified elements.)  Returns the modified array.

[08:09] <lizmat> I guess the current implementation is in violation of the "the reified part of the array is not modified" part

[08:09] <moritz> sounds like a push to $!nextiter

[08:10] <moritz> oh wait, $!nextiter isn't an array, right?

[08:10] <lizmat> nope

[08:10] <lizmat> that's the problem

[08:10] <lizmat> but since the GLR is going to touch this most likely

[08:10] <lizmat> I'm not going to touch it now

[08:10] <moritz> so the implementation with the current semantics would be more like: if $!nextiter isn't set, set it to the argument

[08:11] <lizmat> (although this little investigation has been enlighting to me )

[08:11] <moritz> otherwise, recursie into $!nextiter

[08:11] <lizmat> current logiv:

[08:11] <lizmat>         my $elems = self.gimme(*);

[08:11] <lizmat>         fail 'Cannot add plan to an infinite list' if $!nextiter.defined;

[08:12] <moritz> so basically just   if $!nexiter.DEFINITE { $!nextiter.plan(newstuff) } else { $!nextiter := newstuff }

[08:12] <lizmat> so it doesn't recurse per se, it just reifies all until then

[08:12] <lizmat> an ListIter can do that ?

[08:13] <lizmat> ListIter doesn't have a .plan method

[08:13] <moritz> eeks, I forgot that $!nextiter isn't just a List again

[08:13] <Mouq> It's an iterator, so it probably should be able to

[08:13] <lizmat> yeah, different turtles all the way down  :-)

[08:14] <Mouq> My idea was to have a $!planned attribute, but really that's what $!nextiter is for

[08:14] <lizmat> again, not touching until there's clarity about its state wrt GLR

[08:14] <moritz> turtles and elefants all the way down

[08:14] <moritz> lizmat: +1

[08:14] <lizmat> Terry++  # may he RIP

[08:15] <lizmat> afk for a bit&

[08:19] <[Tux]> lizmat, if .perl is always eager, pls explain

[08:19] <[Tux]> m: (1,4..7,9..Inf).perl.say;

[08:19] <camelia> rakudo-moar 0a8bdf: OUTPUT«(1, 4..7, 9..Inf)␤»

[08:21] *** agentzh joined
[08:26] *** agentzh left
[08:26] * [Tux] => $work

[08:26] *** MadcapJake left
[08:27] <Mouq> m: (1,4..7,9..Inf).flat.perl.say; # [Tux] 

[08:27] <camelia> rakudo-moar 0a8bdf: OUTPUT«(1, 4, 5, 6, 7, ListIter.new()).list␤»

[08:27] <Mouq> Er

[08:27] *** rurban joined
[08:27] *** espadrine joined
[08:27] <Mouq> Something :P

[08:27] * Mouq needs to go to bed

[08:29] <dalek> roast: cf04ac0 | usev6++ | S32-str/substr.t:

[08:29] <dalek> roast: Add test for RT #123602

[08:29] <dalek> roast: (fudged 'todo' for MoarVM)

[08:29] <dalek> roast: review: https://github.com/perl6/roast/commit/cf04ac010e

[08:29] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123602

[08:34] *** zakharyas joined
[08:55] *** smls joined
[08:56] *** spider-mario joined
[08:56] *** Ven left
[08:56] <masak> good morning, Earthlings

[08:56] <masak> er, I mean #perl6. good morning, #perl6

[08:57] <bartolin> o/

[08:57] <CurtisOvidPoe> Good correction, masak. Referring to people in this channel as “Earthlings” is specist and offensive.

[08:57] <CurtisOvidPoe> :)

[08:58] *** Ven joined
[08:58] <moritz> many of us are actually bots from outer space

[08:58] <CurtisOvidPoe> And still don’t pass the Turing test …

[08:58] *** Rounin joined
[09:01] <masak> moritz: ssssssh!

[09:01] * masak glances around, wildly

[09:02] *** rindolf joined
[09:03] <masak> CurtisOvidPoe: the *Turing test* is speciesist and offensive. heh, like we'd want to aspire to be like you hum... uh... it's setting "being human" as a goal for "being able to think", which is a really weird standard.

[09:04] <masak> some bots have told me in private that they think entirely different from human persons.

[09:05] * moritz wonders when/if "humanist" will have a negative connotation

[09:05] * Ven would certainly prefer not to infinite loop... so is definitely okay with being nonturing complete :)

[09:06] * moritz would love to have the infinite memory capacity that turing completeness requires/implies

[09:07] * Ven thinks that'd be too boring :)

[09:08] * moritz recently read that memory access is at best O(sqrt(n))

[09:08] <masak> moritz: huh. where does the sqrt come from, I wonder?

[09:08] <moritz> in time

[09:08] <moritz> masak: from geometry, mostly

[09:08] <masak> moritz: I mean, if you'd said O(log(n)), I'd've gotten a mental image of a branching lookup.

[09:09] <moritz> masak: you only have a finite memory density

[09:09] <masak> but I have no such mental image from sqrt(n)

[09:09] <moritz> masak: so if your memory is big enough, big parts of it are further away from you

[09:09] <moritz> masak: and so speed of light limits access time

[09:09] *** cognominal left
[09:09] <moritz> so in an ideal world it would be n**(1/3)

[09:10] * masak .oO( unless you can also store it in the TIME DIMENSION ) o.O

[09:10] <moritz> but typical architectures and requirements like heat dissipation mean that practically, you have n**(1/2)

[09:10] <masak> *nod*

[09:11] <moritz> masak: http://www.ilikebigbits.com/blog/2014/4/21/the-myth-of-ram-part-i

[09:14] *** espadrine left
[09:15] *** Ugator joined
[09:16] *** kjs_ joined
[09:21] *** Ven left
[09:22] <timotimo> o/

[09:23] <moritz> timotimo/

[09:24] <Mouq> masak: "unless you can also store it in the TIME DIMENSION" That's what lazy lists are for ;)

[09:27] <jnthn> morning o/

[09:27] *** eli-se joined
[09:27] <timotimo> top of the morning to you, jnthn!

[09:27] <eli-se> hi

[09:28] <moritz> \o jnthn, eli-se 

[09:28] * moritz idly wonders if eli-se becomes eli-no if she moves a bit to the west

[09:29] <eli-se> I'd become English.

[09:29] <eli-se> Or a citizen of Zealand, although I'd rather move to New Zealand.

[09:30] <nwc10> they have a better cricket team.

[09:32] *** eli-se left
[09:33] <smls> Does  "myfile".IO.words.map:...  read the file lazily like  "myfile".IO.lines.map:...  ?

[09:34] <Ulti> moritz that article is a bit silly though a better way to think about it is your levels of RAM are arranged in a circle around the CPU so its constant time to look up any segment in that circle because they are equidistant from the CPU... that some circles that are bigger are also further away doesn't really change that you just pick the constant to the circle that fits your program

[09:35] <Ulti> thats kind of the point of asymptotic analysis you can make those sorts of simplifications and they are still meaningful

[09:36] <moritz> Ulti: but if they are further away, speed of light limits access time

[09:36] <Ulti> so

[09:36] <Ulti> speed of light was a constant last I checked

[09:36] <moritz> yes

[09:36] <Ulti> so if I need the edge of the universe to have a surface big enough to arrange the bits of my program its still a constant to access them just mega slow

[09:36] <moritz> Ulti: but the RAM isn't arranged as one circle

[09:36] <moritz> Ulti: it's arranged as a ring of concentric circles

[09:37] <moritz> Ulti: with inner caches being the caches, and outer circles the actual ram and/or disc arrays

[09:37] <moritz> which is why you can access small amounts of memory faster, and large amounts slower

[09:37] <Ulti> yeah so that just means its happily faster than the worst case some of the time, asymptotically you worry about the slow constant 

[09:37] <moritz> of course you could make everything slow, by putting it all into the outer-most ring, but that'd be silly

[09:38] <Ulti> people who want to optimise for the special cases then worry about the details

[09:38] <moritz> Ulti: that's about the same approach as saying that most algorithms are O(exp(N))

[09:38] <Ulti> hence when you do alter your program to deal with cache lookup its way faster, its not even as simple as the levels of cache but also the CPU rules for staying in cache

[09:38] <moritz> they are, because E(exp(N)) is just an upper bounday

[09:38] <moritz> *boundary

[09:39] *** st_iron left
[09:39] <moritz> but it's not a *useful* boundary

[09:39] <Ulti> yeah apart from a computer isn't infinite

[09:39] <Ulti> I dont have swap so system memory is my constant

[09:39] <Ulti> in a literal sense

[09:40] <nwc10> Ulti: speed of light *in a vacuum* is constant (and accurately known)

[09:40] <Ulti> but time is a dimension that goes on for a while 

[09:40] <Ulti> you can fit quite a few complexity classes in there

[09:40] <nwc10> (which is what you meant, but you weren't clear)

[09:40] <moritz> Ulti: so, your argument is that you can give a constant upper boundary for a constant amount of RAM

[09:40] <moritz> Ulti: that doesn't contract the article in any way

[09:41] <Ulti> nwc10 I was talking about a computer which is computing at the level of the known universe I think its safe to make any assumptions you like :P

[09:41] <Mouq> Ulti: He addresses this in the FAQ

[09:41] <Mouq> "I only care about stuff that fits in RAM, and I want to ignore cache effects "

[09:42] <nwc10> Ulti: ah OK.

[09:42] <nwc10> can I assume that it's Friday? :-)

[09:42] <Ulti> cache effects are cache effects they are not asymptotic behaviour if I change to a CPU that doesnt have cache now what?

[09:42] <Ulti> the point of using this form of analysis is to make simplifications

[09:43] *** Ven joined
[09:43] <Mouq> Ulti: His point is that as your memory increases, access time increases

[09:43] <Ulti> though I like the idea of dealing with real physical limits

[09:43] <Ulti> as in just the density of memory with time possible in the limits of what is physically possible

[09:43] <Ulti> I guess it would end up being quite similar

[09:44] <Mouq> Ulti: If you just say "well, it's a constant", that's beside the point of the article :P

[09:44] <Ulti> but that sounds a lot more like quantum information theory than asymptotic analysis of an algorithm

[09:47] *** kjs_ left
[09:50] *** Ven left
[09:51] *** kjs_ joined
[09:53] *** fhelmberger joined
[09:54] *** brrt joined
[09:54] <lizmat> m: (1,4..7,9..Inf).list.perl.say   # .perl doesn't flatten, a .list does

[09:54] <camelia> rakudo-moar 0a8bdf: OUTPUT«(1, 4, 5, 6, 7, ListIter.new()).list␤»

[09:55] <lizmat> hmm....

[09:55] <lizmat> m: (1,4..7,9..Inf).WHAT.say

[09:55] <camelia> rakudo-moar 0a8bdf: OUTPUT«(Parcel)␤»

[09:55] <lizmat> m: (1,4..7,9..Inf).list.WHAT.say

[09:55] <camelia> rakudo-moar 0a8bdf: OUTPUT«(List)␤»

[09:56] <lizmat> m: my @a = (1,4..7,9..Inf); say @a.perl

[09:56] <lizmat> m: my @a = (1,4..7,9..Inf)

[09:56] <camelia> rakudo-moar 0a8bdf: OUTPUT«(timeout)»

[09:56] <camelia> rakudo-moar 0a8bdf: ( no output )

[09:57] <lizmat> m: my @a = (1,4..7,9..Inf); say @a

[09:57] <camelia> rakudo-moar 0a8bdf: OUTPUT«1 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 9…»

[09:58] <Mouq> m: say (1,4..7,9..Inf).flat.gist

[09:58] <camelia> rakudo-moar 0a8bdf: OUTPUT«1 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 9…»

[10:01] <Ulti> Mouq imagine on the graphs of that article if I had 256GB of system RAM and the same cache sizes... would you still fit that line?

[10:01] * smls has simply accepted that pre-GLR Perl 6 flattening behavior is weird and not worth memorizing

[10:01] <lizmat> smls: "file".IO.words should be lazy

[10:01] * smls hopes there will be GLR progress soon

[10:02] <smls> lizmat: cool, thanks

[10:02] <lizmat> unless you specify words(:eager)

[10:02] <lizmat> which is a pre-GLR hack

[10:03] <Ulti> we are now in a post-GLR economy?

[10:04] <lizmat> alas, not yet  :-(

[10:04] <lizmat> pmichaud is still harvesting tuits, I'm afraid

[10:07] *** laouji left
[10:07] *** Sir_Ragnarok left
[10:09] * Ulti imagines a tuit hog used to find tuits since they are quite rare and usually buried

[10:10] <timotimo> :D

[10:11] *** espadrine joined
[10:12] *** Sir_Ragnarok joined
[10:21] <ab5tract> does anyone have any non-core examples of Proxy?

[10:22] <ab5tract> I was having a pretty terrible time at it yesterday, which resulted in a fresh rakudobug

[10:24] <masak> ab5tract: maybe search moritz++' new pan-ecosystem repo?

[10:24] <ab5tract> ah, that sounds promising

[10:24] <masak> http://perlgeek.de/blog-en/perl-6/2015-all-modules-in-a-box.html

[10:25] <jnthn> .oO( It's my mod in a box )

[10:25] <moritz> /p6/perl6-all-modules (master)$ git grep Proxy|wc -l

[10:25] <moritz> 73

[10:25] <masak> moritz++ is le faster

[10:25] <masak> I was still on git clone

[10:25] <moritz> some of them are false positives

[10:26] <smls> this has lots of Proxy use: https://github.com/avuserow/perl6-audio-taglib-simple/blob/master/lib/Audio/Taglib/Simple.pm

[10:26] <masak> today is a Perl 6 day! \o/

[10:26] <masak> my stated goals are to (a) get the custom-ops branch of 007 merge-ready, and (b) blog about 007

[10:26] <lizmat> https://github.com/rubygems/rubygems/pull/1188   # wonder if this could be of interest wrt to lists and reification

[10:31] *** brrt left
[10:37] <lizmat> jnthn: I just found out that Supply.on-demand is not speculated, and not tested

[10:38] <lizmat> I figured something like: Supply.on-demand( { state $x = 1; say $x; $x++ });

[10:38] *** cschwenz joined
[10:38] <lizmat> would be functionally the same as:

[10:38] <lizmat> Supply.from-list 1..10);

[10:38] <masak> pro warning: if you start liking nested subs and nested lexical classes a lot in your code, your subroutines can start being ~150 lines long without you noticing.

[10:38] <lizmat> Supply.from-list( 1..10);

[10:38] <lizmat> but it isn't

[10:39] <jnthn> lizmat: That isn't how Supply.on-demand works :)

[10:39] <lizmat> I figured that, but am unsure how it is supposed to 

[10:40] <jnthn> Supply.on-demand(-> $obs { state $x = 0; $obs.emit($x++) }) iirc

[10:40] <lizmat> ah, the code needs to take a Supply

[10:40] <jnthn> Though you can write such a simple one as

[10:41] <jnthn> Supply.on-demand({ .emit(++state $) }) or so

[10:41] *** xfix joined
[10:42] <lizmat> alas, no go...

[10:42] <lizmat> only gets one value  :-(

[10:42] <jnthn> Oh

[10:42] <jnthn> Yes, you need a loop in there yourself.

[10:43] <lizmat> ok

[10:44] <jnthn> m: my $ten = Supply.on-demand(-> $s { for ^10 { $s.emit($_) }; $s.done; }); $ten.tap(&say); $ten.tap(&say);

[10:44] <camelia> rakudo-moar 0a8bdf: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[10:44] <lizmat> is the $s.done necessary ?

[10:44] <jnthn> Yes

[10:44] <jnthn> Well, in this case you'd get away with it I guess

[10:45] <lizmat> yeah

[10:45] <lizmat> gotcha

[10:45] <jnthn> But if doc'ing it, we should guide folks to use it to indicate that their finite supplies are over

[10:45] <jnthn> Otherwise things don't work out so well once you start to zip, await the last value, etc.

[10:45] <lizmat> not doccing, just writing test atm

[10:45] <jnthn> OK :)

[10:46] <lizmat> and speculating  :-)

[10:46] <dalek> rakudo/nom: 7fd909a | jnthn++ | src/core/ (2 files):

[10:46] <dalek> rakudo/nom: Use .^ in ^parameterize methods now it's safe.

[10:46] <dalek> rakudo/nom: 

[10:46] <dalek> rakudo/nom: There used to be some issues with how .^ worked, but they're long

[10:46] <dalek> rakudo/nom: fixed. Thus we can have much neater code here.

[10:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7fd909a36b

[10:47] <lizmat> jnthn: does that apply to *all* .HOW.method cases  in the settings?

[10:47] <jnthn> Good question

[10:47] * jnthn greps through some

[10:47] <lizmat> there's quite a lot of them

[10:47] <masak> moritz: I'm curious -- are you using a script to make all the commits in https://github.com/moritz/perl6-all-modules/commits/master ?

[10:48] <jnthn> lizmat: Looks like it to me.

[10:48] <lizmat> ok, will take that on

[10:48] <jnthn> Yay, more cleanup :)

[10:49] <jnthn> We got the one above 'cus I'm working on native arrays, so looking at how typed arrays already work :)

[10:49] *** kjs_ left
[10:49] *** eli-se joined
[10:50] <eli-se> hi

[10:50] *** coffee` joined
[10:50] *** eli-se left
[10:50] <jnthn> bye...

[10:51] <masak> eli-se seems to be using an IRC client with a non-stick interface...

[10:51] <lizmat> jnthn: when does the :closing code get called ?

[10:51] *** kjs_ joined
[10:52] <jnthn> lizmat: When a tap is closed, which should then recursively close up the chain

[10:52] *** MadcapJake joined
[10:52] <jnthn> lizmat: It's there to allow cleanup

[10:52] <lizmat> ok, gotcha

[10:53] <jnthn> lizmat: Such as Supply.interval being able to toss the timer

[10:53] *** eli-se joined
[10:56] *** eli-se left
[10:57] <dalek> roast: 22ae2c8 | lizmat++ | S17-supply/on-demand.t:

[10:57] <dalek> roast: Basic Supply.on-demand test

[10:57] <dalek> roast: review: https://github.com/perl6/roast/commit/22ae2c866b

[10:59] <dalek> rakudo/nom: 6ffd9bd | lizmat++ | t/spectest.data:

[10:59] <dalek> rakudo/nom: Add basic Supply.on-demand test

[10:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6ffd9bd2e5

[11:00] *** laouji joined
[11:03] *** risou is now known as risou_awy

[11:04] *** risou_awy is now known as risou

[11:04] *** risou is now known as risou_awy

[11:04] <rurban> moritz: do you have a good google=>github userlist?

[11:04] *** risou_awy is now known as risou

[11:05] *** dayangkun left
[11:06] <rurban> Mine is this but I'm missing a couple: http://pastebin.com/nWQqdtBr

[11:09] *** agentzh joined
[11:10] <lizmat> jnthn: I guess I should leave something like: obj.HOW.mixin(obj.clone(), $role) untouched?

[11:10] <moritz> rurban: not really. You can add moritz.lenz => moritz

[11:10] *** kjs_ left
[11:12] <jnthn> lizmat: Yes

[11:12] <jnthn> lizmat: Well, actually

[11:12] <lizmat> jnthn: also, there is no ^^name, right, for this case: attr.type.HOW.^name

[11:12] <jnthn> lizmat: You cna write it obj.clone.^mixin($role)

[11:12] <lizmat> ok

[11:12] *** kjs_ joined
[11:12] <jnthn> lizmat: No, there's no ^^ :)

[11:12] <jnthn> lizmat: Thankfully, meta-meta-programming is not so common :)

[11:13] <lizmat> hehe  :-)

[11:13] *** Ven joined
[11:13] <rurban> my users: https://gist.github.com/rurban/5aa89bcc8443259fc3b1

[11:13] *** agentzh left
[11:26] *** grondilu joined
[11:31] *** vendethiel left
[11:32] <lizmat> jnthn: https://gist.github.com/lizmat/a04b8cb10c6e3eb2e5f6  is a diff with all the foo.HOW.bar(foo,..) -> foo.^bar(...)

[11:33] <lizmat> alas, it hangs on tests like t/spec/S02-names-vars/perl.t

[11:33] <lizmat> afk for a bit&

[11:34] *** vendethiel joined
[11:36] <ab5tract> okay, so i resolved at least some of the mystery

[11:39] <ab5tract> the signatures for the Proxy keys on a method are working when FETCH => sub ($) and STORE => sub ($, Str $s)

[11:39] <ab5tract> https://gist.github.com/ab5tract/1ee13c094f0ccc34a180

[11:40] <ab5tract> this is awkwardly _not_ required in the test files

[11:42] <ab5tract> and when using perl6-debug-m, it spends an a weird number of steps in what seems to be the same place

[11:43] *** Vlavv left
[11:43] *** skids left
[11:50] <masak> tips for people who find themselves having to loop over a list of things *as stuff gets added and removed form the list*:

[11:51] <jnthn> Don't.

[11:51] <jnthn> ;)

[11:51] <masak> jnthn: note: "having to"

[11:51] <masak> I have an actual use case for it.

[11:51] <masak> (a) loop on indices. `for 0..Inf -> $i` and then `last` when you run out of elements.

[11:51] <masak> (b) push new elements to the end.

[11:52] <masak> (c) don't actually remove elements -- that screws up the indices. instead, just keep an array or a hash with "marked as deleted" information.

[11:53] <masak> if you do all this, it's actually quite sane.

[11:53] <Ven> (which we can resume as: end :P)

[11:53] <Ven> I'd say b) is a bad choice if you don't promise the order of elements will stay the same

[11:53] <Ven> s/end/don't/ duh

[11:54] <masak> troo. (b) and (c) really are for the same reason: don't screw up the indices.

[11:55] <smls> but, manually decremention/incrementing indexes based on complicated conditions, is fun!!

[11:55] <smls> :P

[11:56] <smls> (I actually did something like that years ago in Perl. It was a mess. Later I refactored the script to remove the need to modifying the array while iterating it.)

[11:57] *** CurtisOvidPoe left
[11:58] *** cognominal joined
[11:58] <ab5tract> so in the case of requiring FETCH sub ($) { ... }

[11:58] *** brrt joined
[11:58] <ab5tract> i assume the ($) is for self?

[11:59] <jnthn> Well, really the container

[11:59] <jnthn> (the Proxy instance)

[11:59] <jnthn> You can think of it as self I guess

[12:00] <ab5tract> hmm... self of the Proxy then?

[12:00] <smls> m: say "a".lines.DUMP

[12:00] <camelia> rakudo-moar 6ffd9b: OUTPUT«(signal SEGV)use of uninitialized value <element> of type Any in string context  in sub DUMP at /home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:1␤␤use of uninitialized value <element> of type Any in string context  in sub DUMP a…»

[12:01] <smls> ^^ nice way to get Rakudo to hang for several seconds, spew some warnings, and then segfault :P

[12:01] <ab5tract> this is pretty twisty stuff.. is the rule that this signature will always be required? and why do the test cases do it differently and work fine? I'm not enjoying this part of the rabbit hole very much :(

[12:17] *** grondilu left
[12:22] *** chenryn left
[12:22] *** chenryn joined
[12:23] <jnthn> 50 passing tests for native arrays so far

[12:23] <jnthn> lunch &

[12:27] *** chenryn left
[12:36] *** abraxxa left
[12:37] *** kjs_ left
[12:37] *** diana_olhovik left
[12:37] *** diana_olhovik joined
[12:39] *** eli-se joined
[12:39] <eli-se> hi

[12:39] <masak> hi \o

[12:39] <masak> eli-se: you keep dropping out on us! :)

[12:39] <eli-se> I went for lunch.

[12:39] <eli-se> kebab

[12:39] <masak> ah.

[12:41] *** laouji left
[12:42] <eli-se> m: sub infix:<< o >>(&f, &g) { sub ($a) { g(f($a)) } }; ({.abs} o {.sqrt})(-9).say

[12:42] <camelia> rakudo-moar 6ffd9b: OUTPUT«3␤»

[12:42] <eli-se> woo function composition

[12:43] <masak> better yet, you can reduce over it, with `[o]`

[12:43] <masak> woo, foldl'd function composition!

[12:43] <eli-se> Then I should define the nullary infix:<< o >>

[12:43] <eli-se> to return the identity function

[12:43] <masak> yes :)

[12:44] <moritz> sub infix:<< o >>(&f, &g) { sub ($a) { g(f($a)) } }; say (&abs o &sqrt)(-9)

[12:44] <moritz> m: sub infix:<< o >>(&f, &g) { sub ($a) { g(f($a)) } }; say (&abs o &sqrt)(-9)

[12:44] <camelia> rakudo-moar 6ffd9b: OUTPUT«3␤»

[12:45] <Ven> why "<< >>"?

[12:45] <eli-se> moritz: cool

[12:45] <moritz> no need to wrap the subs in anon blocks

[12:45] <moritz> Ven: no need

[12:45] <eli-se> I tried abs and sqrt at first and I got an error because I forgot the sigils. :P

[12:45] <masak> eli-se: verb/noun distinction

[12:45] <masak> eli-se: the default mode of a function in Perl 6 is to be called

[12:46] <eli-se> I know.

[12:46] <masak> if you don't want that, you have to add more syntax :)

[12:49] *** bjz joined
[13:00] *** spider-mario left
[13:02] *** eli-se left
[13:03] *** eli-se joined
[13:07] *** skids joined
[13:07] <smls> Python makes the verb/noun distinction by requiring parens for function calls

[13:07] * smls prefers the Perl 6 way

[13:08] * eli-se doesn't

[13:10] *** Ven left
[13:10] <arnsholt> The Python way is nuts for methods

[13:10] <dalek> rakudo-star-daily: c41513b | coke++ | log/ (9 files):

[13:10] <dalek> rakudo-star-daily: today (automated commit)

[13:10] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/c41513b262

[13:10] <eli-se> no, it's good and constistent

[13:10] <arnsholt> The semantics are a bit odd

[13:11] <arnsholt> With functions being special objects that have different look-up semantics, depending on whether they are looked up from an instance or a type object

[13:11] <[Coke]>  -> (09:08) From Sue D. Nymme, to Strider, perl:

[13:11] <[Coke]>  - "Ia! Ia! Cthulhu lwall $+[$_]!"

[13:12] <eli-se> arnsholt: no

[13:13] <eli-se> methods are special

[13:13] <eli-se> functions assigned to attributes don't bind self when used with .

[13:13] <brrt> 'a bit odd' - talk about understating

[13:13] <brrt> which is precisely what is so odd about it all (imho at least)

[13:13] <arnsholt> eli-se: That's because the special behaviour only triggers if the look-up is from the type-object

[13:14] <brrt> arnsholt - is the difference created at lookup time or at installation time?

[13:14] <arnsholt> In Python "foo.bar(arg)" compiles to first a fetch operation, then a call operation on the result of the look-up

[13:14] <eli-se> http://ideone.com/KbSg60

[13:14] <arnsholt> brrt: It's handled by functions implementing a special API (descriptors) which is invoked at run-time

[13:14] <eli-se> I think this is very reasonable, and line 10 is useful.

[13:15] <eli-se> you can do map(str.toupper, xs) instead of map(lambda x: x.toupper(), xs)

[13:15] <brrt> descriptors! omg i can't even

[13:15] <arnsholt> eli-se: The thing is that you can assign any random function to the type object, and then it'll be a method

[13:16] <arnsholt> Bound methods are nice, I agree. But the way it works under the hood is pretty odd

[13:16] <brrt> talk about odd magic

[13:16] <eli-se> Oh, I don't know.

[13:16] <eli-se> I never assign things to attributes of type objects.

[13:17] <arnsholt> That's what def in a class block is though. Assign this callable to that name in the type object

[13:17] <arnsholt> def is actually an assignment in Python

[13:17] <eli-se> http://ideone.com/ZqWzFP

[13:18] <eli-se> it doesn't pass self to f

[13:23] *** kjs_ joined
[13:23] <eli-se> doing it anyway would introduce a horrible special case making it impossible to write any generic code

[13:24] <smls> eli-se: That example looks like something that would be better served by a dedicated generics/template syntax, or failing that a meta-object protocol

[13:26] <arnsholt> There's a Python MOP. Haven't gotten around to looking at how it works yet, though

[13:27] <smls> In any case, regarding the verb/noun distinction, the Perl 6 way fits right in with the whole "variables have sigils" thing (as &foo basically treats a subroutine as a variable)

[13:27] <eli-se> Python is pointlessly dynamic though.

[13:27] <smls> Also, I won't let anyone pry my nice paren-less function calls from me :P

[13:28] <eli-se> Haskell!

[13:29] *** eli-se left
[13:29] <arnsholt> Haskell is actually pretty awesome. Though the lazyness does weird things

[13:31] <masak> did anyone ever invent a non-lazy Haskell?

[13:31] <arnsholt> Standard ML sort of is, I guess?

[13:33] <masak> yeah, I suppose so.

[13:33] <skids> m: my @a = (rx/0/, rx/$<a>=(1)(2) { make $1 }/); "12" ~~ / (<foo=@a>) { $/.gist.say } /;  # is there a way to get the full $/ from the interpolated rx to graft it into the Match/AST?

[13:33] <camelia> rakudo-moar 6ffd9b: OUTPUT«｢12｣␤ 0 => ｢12｣␤  foo => ｢12｣␤»

[13:34] <TimToady> m: say lines

[13:34] <camelia> rakudo-moar 6ffd9b: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll; Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí I mo dhiaidh bhí gleanntáin ghlas’ Ghaoth …»

[13:35] <Mouq> skids: NYI, I think

[13:35] *** eli-se joined
[13:36] <TimToady> m: $*IN.read().WHAT.say

[13:36] <camelia> rakudo-moar 6ffd9b: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in method read at src/gen/m-CORE.setting:17267␤  in block <unit> at /tmp/5bKm7gc2kJ:1␤␤»

[13:36] <skids> Or even specced I think.

[13:36] <TimToady> m: $*IN.read(10000).WHAT.say

[13:36] <camelia> rakudo-moar 6ffd9b: OUTPUT«(Buf[uint8])␤»

[13:36] <TimToady> m: $*IN.read(10000).decode('utf8').WHAT.say

[13:36] <camelia> rakudo-moar 6ffd9b: OUTPUT«(Str)␤»

[13:37] <TimToady> hi guys, I'm live at Sophos now :)

[13:37] <eli-se> What is Sophos?

[13:37] <nwc10> that's not-a-Bank

[13:37] <nwc10> but also in Budapest?

[13:37] <TimToady> they bought ActiveState

[13:37] <eli-se> > Antivirus software package targeted at business customers.

[13:37] <TimToady> yes, also here

[13:38] <masak> m: say "TimToady is live! \\o/ commence the silly evals!"

[13:38] <camelia> rakudo-moar 6ffd9b: OUTPUT«TimToady is live! \o/ commence the silly evals!␤»

[13:38] <nwc10> grand tour of Budapest?

[13:38] <masak> m: say "What happens when an unstoppable \c[COMET] meets an immovable \c[SNOWMAN]?"

[13:38] <camelia> rakudo-moar 6ffd9b: OUTPUT«What happens when an unstoppable ☄ meets an immovable ☃?␤»

[13:38] <masak> \o/

[13:39] <eli-se> in C++ you can do that

[13:40] <eli-se> struct T { T(T&&) = delete; T& operator=(T&&) = delete; }; throw T(); // throw is unstoppable, yet meets an immovable object

[13:40] <eli-se> terrible joke

[13:40] <eli-se> I should leave.

[13:42] <Mouq> lol

[13:42] * masak hugs eli-se :)

[13:44] <eli-se> perhaps I should make my compiler warn when people don't use the result of an equality comparison expression, since = means comparison and := means assignment

[13:47] <Mouq> m: say [»~«] [<g mo So>], [<oo rn ph>], [<d ing os>]

[13:47] <camelia> rakudo-moar 6ffd9b: OUTPUT«good morning Sophos␤»

[13:49] <eli-se> that's a sophosticated snippet of perl code

[13:50] <masak> just business as usual at the Perl 6 factory

[13:50] <masak> ...not really. :) Mouq++ :)

[13:51] <Mouq> m: say [~] «i "s t" hi "s be" tter ?»

[13:51] <camelia> rakudo-moar 6ffd9b: OUTPUT«is this better?␤»

[13:52] *** eli-se left
[13:53] <moritz> m: 1 == 2; say 42

[13:53] <camelia> rakudo-moar 6ffd9b: OUTPUT«WARNINGS:␤Useless use of "==" in expression "1 == 2" in sink context (line 1)␤42␤»

[13:53] *** vendethiel left
[13:54] *** eli-se joined
[13:54] <timotimo> m: my $hello-wordl = "hi sophos!"; say $hello-world

[13:54] <camelia> rakudo-moar 6ffd9b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NtvMWAbSLn␤Variable '$hello-world' is not declared. Did you mean '$hello-wordl'?␤at /tmp/NtvMWAbSLn:1␤------> 3o-wordl = "hi sophos!"; say $hello-world7⏏5<EOL>␤    expecting any of:␤        post…»

[13:54] *** vendethiel joined
[13:57] *** eli-se left
[14:02] *** tbrowder joined
[14:02] *** dalek left
[14:07] *** Ven joined
[14:09] *** fhelmberger left
[14:10] *** cognominal left
[14:13] *** eli-se joined
[14:13] <eli-se> Can you encode loop invariants in Perl 6?

[14:14] <eli-se> Similar to PRE and POST for subroutines.

[14:22] *** danstone1 is now known as danstoner

[14:22] <timotimo> hm, i don't see why PRE and POST wouldn't be a good candidate for that

[14:25] <[Coke]> m: sub mad(){POST {say "d"};PRE {say "m"};say "a"}; mad

[14:25] <camelia> rakudo-moar 6ffd9b: OUTPUT«m␤a␤d␤»

[14:25] <[Coke]> ^^?

[14:26] <eli-se> requires duplciation

[14:27] <[Coke]> I still don't undertand what you're asking for. :)

[14:27] <masak> eli-se: you can use PRE and POST directly in a loop body.

[14:27] <masak> eli-se: or in any block's body.

[14:28] <eli-se> yeah but loop invariant is the same for PRE and POST

[14:29] *** rindolf left
[14:30] <masak> oh, I see what you mean.

[14:31] * masak .oO( macro INVARIANT )

[14:31] * masak adds this to his growing list of use cases

[14:32] <masak> I think this would be a good place for a macro.

[14:32] <masak> since it's about hiding/reducing boilerplate/duplication.

[14:33] <[Coke]> masak: ... what is the issue?

[14:34] <masak> [Coke]: a loop invariant should be checked both at PRE-time and at POST-time of an iteration

[14:34] <masak> [Coke]: the only way to do that now is to have both PRE and POST, with exactly the same check

[14:35] <masak> (or the POST check slightly modified to take into account that we're not in the next iteration yet, I guess)

[14:35] *** Hor|zon left
[14:35] <masak> if you skip the POST, you don't get your last check.

[14:36] <eli-se> I just wrote a sorting function that only works for inputs that are already sorted.

[14:37] <masak> very narrow utility

[14:37] <eli-se> sub sort($xs) { PRE { is-sorted($xs) }; xs }; sort([1, 2, 3, 4]).say :P

[14:38] <eli-se> I guess INVARIANT shouldn't be loop-specific.

[14:38] *** chenryn joined
[14:38] <eli-se> but work on any block

[14:40] <nine_> Oh, seek is inocent. open(:rw) is simply NYI

[14:40] *** chenryn left
[14:40] <timotimo> we can't open :rw?

[14:40] <timotimo> :\

[14:41] <nine_> we pretend to, but the mode is not properly passed on to nqp::open

[14:41] <timotimo> :o

[14:41] *** chenryn joined
[14:42] <eli-se> naughty!

[14:42] <nine_> my $mode := $w ?? 'w' !! ($a ?? 'wa' !! 'r');

[14:43] <timotimo> wa !! r... wa !! r never changes ...

[14:44] *** kaare_ left
[14:44] *** FROGGS left
[14:45] <nine_> And MoarVM does not support and 'rw' mode

[14:45] <nine_> Only supports "r", "w" and "wa"

[14:45] *** cschwenz left
[14:45] *** cschwenz joined
[14:45] <timotimo> well, wa is kind of rw, no? or is that wa+? or a+?

[14:46] *** chenryn left
[14:46] <nine_> "wa" is O_CREAT | O_WRONLY | O_APPEND

[14:46] <timotimo> ah, hm

[14:46] <timotimo> gotta run! :P

[14:46] <Ven> nine_: I think I'm to blame for open(:rw)

[14:47] <Ven> I'm fairly sure I tested it and it worked then at least :o)

[14:47] *** agentzh joined
[14:47] <nine_> Ven: maybe on Parrot?

[14:47] *** Rounin left
[14:48] <eli-se> I deny the existence of Parrot.

[14:48] <Ven> nine_: I have been doing perl6 for no more than a year ;) (+ half a month now)

[14:49] <nine_> I cannot find any code supporting :rw except for the argument declaration :)

[14:51] *** agentzh left
[14:54] <Ven> nine_: https://github.com/rakudo/rakudo/commit/88a084ebbdc14920957f4729ca435bcc5cbcc541

[14:56] *** rmgk_ joined
[14:56] *** rmgk left
[14:56] *** rmgk_ is now known as rmgk

[15:00] *** perl6_newbee joined
[15:01] <Mouq> Ven: Pretty sure you're not to blame :)

[15:01] <Ven> alright

[15:01] *** raiph joined
[15:02] <Mouq> The only use of the $r and $rw vars in open() is the line "$r = $w = True if $rw;"

[15:03] <Mouq> (Even in at the commit you linked, that is)

[15:04] *** vendethiel left
[15:06] *** vendethiel joined
[15:07] <Mouq> Ven: Oh, I misread your comment

[15:07] <Mouq> Ven: Carry on

[15:07] <Mouq> :P

[15:08] <Ven> Mouq: ... carry on blaming myself? :P

[15:09] <jnthn> m: my @a = 1,2,3; @a.pop = 4; say @a;

[15:09] <camelia> rakudo-moar 2a9de6: OUTPUT«1 2␤»

[15:09] <jnthn> Hm :)

[15:09] <jnthn> Yeah, I think that behavior ain't happening on native arrays...

[15:10] <masak> no big loss :)

[15:10] *** kjs_ left
[15:11] *** chenryn joined
[15:12] *** chenryn left
[15:15] *** grondilu joined
[15:18] *** FROGGS joined
[15:20] <raydiak> g'mornin #perl6

[15:20] <Ven> huh.

[15:20] * Ven is still puzzled somehow

[15:20] <Ven> hi raydiak 

[15:21] *** telex left
[15:21] <raydiak> heya Ven 

[15:22] *** telex joined
[15:24] * [Coke] wonders if we should be able to say PRE POST { stuff }. (right now it fails)

[15:29] <psch> [Coke]: i wondered the same, but PRE/POST seems to be the only useful case that i can see off hand

[15:29] *** vendethiel left
[15:31] *** virtualsue joined
[15:31] *** Hor|zon joined
[15:32] <jnthn> Pro-tip: nqp::push_i is not very useful for implementing unshift...

[15:33] <ugexe> is there a way to see if test reports are being received by p6c.org? i dont know if i have something misconfigured, or if testers just isnt generating recent reports atm

[15:35] <[Coke]> sub mom(){ sub m { say "m" }; PRE m;POST m;say "o"}; mom

[15:35] <[Coke]> even that's verbose, though, sure.

[15:36] <timotimo> you need to pass in the arguments pre and post get, too, though

[15:36] <timotimo> well, the $_ i suppose

[15:36] <timotimo> so it'd want to be .&m

[15:37] <moritz> ugexe: I guess FROGGS[mobile]++ would need to debug that

[15:37] *** Hor|zon left
[15:39] <FROGGS> ugexe: lemme check

[15:39] <FROGGS> err

[15:39] <FROGGS> hack itself has problems

[15:40] <FROGGS> it takes ages to log in

[15:40] <FROGGS> (still waiting)

[15:40] * psch can log in ok

[15:40] <psch> but things like tab completion hang the shell

[15:41] <FROGGS> O.o

[15:41] <psch> similarly git status

[15:41] <moritz> so, IO is slow?

[15:41] <FROGGS> so the disk is busy?

[15:41] <moritz> what does 'uptime' say?

[15:41] * moritz tries to log in

[15:41] <psch> i don't know, "echo foo > test" is fine

[15:41] *** eli-se left
[15:41] <psch>  15:41:33 up 1 day,  5:28, 11 users,  load average: 419.80, 402.71, 359.88

[15:41] <FROGGS> perhaps there is a panda running that creates more and more .panda-work dirs...

[15:41] <FROGGS> wow

[15:42] <moritz> that's a pretty high load :(

[15:42] <timotimo> shouldn't be that high :(

[15:43] <FROGGS> ugexe: your client might okay :o)

[15:44] *** vendethiel joined
[15:44] <moritz> there seem to be an awful lot of cron processes running

[15:44] *** lichtkind joined
[15:44] <FROGGS> :S

[15:45] *** alini joined
[15:45] <moritz> not cron, CRON

[15:45] * FROGGS tries to look innocent

[15:45] *** eli-se joined
[15:46] <eli-se> so

[15:46] *** sqirrel joined
[15:49] * brrt afk

[15:49] *** brrt left
[15:49] *** Hor|zon joined
[15:49] *** masak left
[15:49] *** chenryn joined
[15:49] *** PerlJam left
[15:50] *** sergot left
[15:50] *** Util left
[15:50] *** avuserow left
[15:50] *** chenryn left
[15:50] *** psch left
[15:50] *** Mouq left
[15:50] *** [Coke] left
[15:51] <moritz> now I lost console connection to hack :(

[15:53] *** dalek joined
[15:53] *** ChanServ sets mode: +v dalek

[15:53] <moritz> reboot completed

[15:54] <moritz> sorry everybody

[15:55] <moritz> if somebody feels inclined to debug this (and this would be very much appreciated), my first step would be to set up collectd to gather some stats about the host

[15:59] *** masak joined
[16:00] * masak shrugs off the reboot in all directions, like droplets off a hairy dog

[16:00] *** psch joined
[16:00] *** kjs_ joined
[16:01] <masak> I should at least make a list of the channels I like, somewhere...

[16:01] <moritz> masak: /save

[16:01] <masak> ooh

[16:01] <masak> moritz++

[16:02] <ugexe> i only use bespoke artisinal handcrafted configs

[16:03] <psch> m: "aa" ~~ /(.)+/; say @0 # wondered about this while looking at #72820

[16:03] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=72820

[16:03] <camelia> rakudo-moar 17b096: OUTPUT«｢a｣ ｢a｣␤»

[16:03] <timotimo> i also recommend trying weechat :P

[16:03] <psch> m: "a" ~~ /(.)/; say &0 # what that ticket is about

[16:03] <camelia> rakudo-moar 17b096: OUTPUT«｢a｣␤»

[16:03] <timotimo> if your irssi gets booted off the 'net evrey once in a while anyway

[16:03] <hoelzro> timotimo: ('weechat' > 'irssi').WHY

[16:03] <hoelzro> er, gt

[16:03] <hoelzro> *

[16:04] *** [Coke] joined
[16:04] <masak> m: say 'weechat' gt 'irssi' # because :)

[16:04] <camelia> rakudo-moar 17b096: OUTPUT«True␤»

[16:04] <psch> the obvious fix for &0 breaks @0, but i'm not sure if @0 is sensible or spec'd, anyway

[16:05] <psch> if @() is @($/), would @0 be be @($0)?

[16:05] <[Coke]> sorry, read the backlog, but i didn't get what happend to hack.

[16:05] <hoelzro> I've been curious to try weechat, but I have such a heavily customized irssi config, I need a compelling reason =)

[16:06] <timotimo> it just seems more sensible "by default" than irssi

[16:06] <timotimo> but i have a hard time coming up with things i've missed from irssi; i sort of never looked back since i switched ;)

[16:06] <hoelzro> interesting

[16:06] <timotimo> it has a smart filter for quits and joins

[16:06] <hoelzro> how is it "smart"?

[16:07] <timotimo> i usually have that turned on all the time; it only shows a join if the person wrote something shortly after and only shows a part if the person spoke shortly before that

[16:07] <hoelzro> oh, that's kinda neat

[16:07] <timotimo> and since i always tabcomplete nicknames anyway before i write a response, i'll notice soon enough if the person had disappeared in the mean time

[16:07] <timotimo> turning it off is just alt=

[16:08] <timotimo> alt-k and then a key combination will give you exactly what you can type into the binding config to bind something to that combination

[16:08] <timotimo> or alternatively what's currently bound to it

[16:08] <timotimo> meta-k /input grab_key_command

[16:08] <timotimo> meta-r /input delete_line

[16:08] *** vendethiel left
[16:09] <smls> m: say "étêté" ~~ /:ignoremark e/

[16:09] <camelia> rakudo-moar 17b096: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4f5ohE_4wG␤Unrecognized regex modifier :ignoremark e/␤at /tmp/4f5ohE_4wG:1␤------> 3say "étêté" ~~ /:ignoremark e/7⏏5<EOL>␤»

[16:09] <smls> :(

[16:09] <timotimo> instead of /last that clobbers your screen you can ctrl-R /input search_text to search through the history

[16:10] <hoelzro> that's a bonus

[16:10] <retupmoca> ooh, weechat has remote clients

[16:11] <hoelzro> hmm

[16:11] <hoelzro> that's pretty compelling

[16:11] <timotimo> it does, "glowing bear" is a good one

[16:13] *** vendethiel joined
[16:15] <smls> m: say "dkzkwjeraeiz" ~~ / <[aeiou]>**3 /

[16:15] <camelia> rakudo-moar 17b096: OUTPUT«｢aei｣␤»

[16:15] <smls> ^^ is there any downside or side-effect to using the ** regex quantifier without surrounding spaces like that?

[16:17] <masak> smls: no, not outside of :sigspace

[16:17] <smls> ok

[16:18] <masak> smls: if :sigspace is explicitly on, or you're in a rule, it matters

[16:18] *** dwarring left
[16:18] <masak> also, in those cases `<foo>*` vs `<foo> *` also matters.

[16:18] <masak> as I learned the other week.

[16:19] <masak> errand &

[16:20] <Ven> masak: huh?

[16:25] *** cognominal joined
[16:26] <psch> m: say "a b" ~~ token { \w * }; say "a b" ~~ rule { \w * };

[16:26] <camelia> rakudo-moar 17b096: OUTPUT«｢a｣␤｢a b｣␤»

[16:28] *** mr-foobar joined
[16:30] <psch> Ven: S05:380

[16:30] <synopsebot> Link: http://design.perl6.org/S05.html#line_380

[16:30] <Ven> ah, thanks psch 

[16:35] *** eli-se left
[16:36] <psch> m: $_ = "aa"; m/(a)+/; .say for @0

[16:36] <camelia> rakudo-moar 17b096: OUTPUT«｢a｣␤｢a｣␤»

[16:36] *** agentzh joined
[16:36] * psch .oO( and that's how i realized it already works like that... )

[16:37] *** raiph left
[16:37] <dalek> nqp/mast_localref: 154998c | timotimo++ | / (2 files):

[16:37] <dalek> nqp/mast_localref: initial implementation of localref X local access

[16:37] <dalek> nqp/mast_localref: 

[16:37] <dalek> nqp/mast_localref: as well as three simple failing tests

[16:37] <dalek> nqp/mast_localref: review: https://github.com/perl6/nqp/commit/154998c37a

[16:40] *** retupmoca left
[16:40] *** agentzh left
[16:42] *** alini left
[16:44] *** retupmoca joined
[16:45] *** Util joined
[16:45] *** btyler_ left
[16:45] *** anocelot left
[16:45] *** perl6_newbee left
[16:45] *** btyler joined
[16:45] *** anocelot joined
[16:46] <psch> huh, a flapping test in S14-roles/parameterized-type.t

[16:46] <psch> failed with make spectest, worked with make $filename

[16:49] *** Possum left
[16:52] *** Ven left
[16:54] <psch> std: &0 # still not sure why std doesn't complain here

[16:54] <camelia> std 28329a7: OUTPUT«ok 00:00 137m␤»

[16:55] <FROGGS> std: &-1

[16:55] <camelia> std 28329a7: OUTPUT«ok 00:00 139m␤»

[16:55] <FROGGS> std: &-1e3

[16:55] <camelia> std 28329a7: OUTPUT«ok 00:00 139m␤»

[16:55] <psch> std: &bar

[16:55] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Undeclared routine:␤     'bar' used at line 1␤Check failed␤FAILED 00:00 138m␤»

[16:55] <psch> std: my &1 = { 1 }

[16:55] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Cannot declare a numeric variable at /tmp/ahH0SPgIdC line 1:␤------> 3my &17⏏5 = { 1 }␤Parse failed␤FAILED 00:00 137m␤»

[16:55] <psch> so, no way to get a &1 anyway

[16:56] <psch> m: MY::<&1> = { 1 }

[16:56] <camelia> rakudo-moar 17b096: OUTPUT«Cannot modify an immutable Any␤  in method ASSIGN-KEY at src/gen/m-CORE.setting:2229␤  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:3647␤  in block <unit> at /tmp/FP8iSVy_p6:1␤␤»

[16:57] <psch> that makes me wonder, if disallowing &\d+ in rakudo should be backported to std :s

[16:59] *** rindolf joined
[17:11] *** sqirrel left
[17:12] *** smls left
[17:20] *** cschwenz left
[17:22] *** tgt joined
[17:24] *** Vlavv_ joined
[17:25] *** espadrine left
[17:29] *** kjs_ left
[17:33] *** zby_home joined
[17:40] *** zakharyas left
[17:46] *** alini joined
[17:46] <dalek> rakudo/nom: bdbb656 | lizmat++ | / (13 files):

[17:46] <dalek> rakudo/nom: Replace foo.HOW.method(foo,...) with foo.^method(...)

[17:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bdbb65613c

[17:48] <jnthn> lizmat: You found out what hung? :)

[17:48] <lizmat> yeah, thinko on my part

[17:49] <jnthn> ah, not .^ bug. OK :)

[17:50] <lizmat> no, not bug  :-)  well, not in your code :-)

[17:51] <lizmat> however, if in a block there are multiple .^foo calls on the same object

[17:51] <[Coke]> m: say sqrt(sqrt(9**2+19**2/22))

[17:51] <camelia> rakudo-moar 17b096: OUTPUT«3.14159265258265␤»

[17:51] <lizmat> it may make sense to create a temp HOW and work from there?

[17:51] <jnthn> lizmat: Unlikely

[17:51] <jnthn> lizmat: .HOW is a very cheap thing.

[17:52] <lizmat> ok

[17:52] <jnthn> lizmat: JITs to a couple of machine instructions, iirc

[17:52] <lizmat> from a runtime point of view, my change didn't do anything, right ?

[17:52] <lizmat> just better readability, no?

[17:53] *** cognominal left
[17:53] <jnthn> It may have produced a bit better code to

[17:53] <jnthn> $a.HOW.name($a) # two lexical lookups

[17:54] <jnthn> $a.^name # one lexical lookup put in a temporary and re-used

[17:54] <jnthn> But lexical lookups are really cheap too. :)

[17:54] <lizmat> ah, ok...lemme try that :-)

[17:54] <jnthn> So you're unlikely to be able to measure it.

[17:55] <dalek> rakudo/nom: fe77d28 | lizmat++ | src/core/Variable.pm:

[17:55] <dalek> rakudo/nom: Remove reference to PARAMETERIZE

[17:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe77d28b73

[17:59] <nwc10> jnthn: with any hammer smaller than cachegrind?

[17:59] <lizmat> yeah, within noise levels, however with a ever so slight tendency towards $foo.^name being *slower*

[18:00] *** _4d47 joined
[18:00] *** hkatz joined
[18:01] <hkatz> Hey there can anyone answer a question?

[18:02] <psch> the answer to that on is "you don't have to ask to ask", i think :)

[18:02] <nwc10> and the answer to your initial question is "it depends what the question is"

[18:03] <hkatz> lol, anyways I'm writing a script in p5 and I want to show off a bit of p6 by compaing and contrasting the implementations

[18:03] <hkatz> in the p5 script I use a Setup.pm package to parse the command line, get the variables and options, validate them, then make them all globally available to the application

[18:03] <hkatz> for p6, would I use a class for this? Role? module?

[18:03] <psch> i'd probably use &MAIN

[18:04] <psch> depending on what your constraints are

[18:04] <hkatz> I can't seem to find a parallel way without putting the logic in MAIN methods in the main script

[18:04] <hkatz> but I feel that pollutes the main script

[18:04] <psch> what are the constraints?

[18:04] <hkatz> constraints?

[18:04] <psch> for the arguments to the script

[18:04] <psch> how do you have to validate them

[18:04] <hkatz> it's a simple script that just takes in some options and 1 arg from Getopts::Long

[18:05] <hkatz> one sec I'll gist it

[18:05] <hkatz> https://gist.github.com/hjkatz/42c801677efd611085ef

[18:05] <hkatz> there's the GetOptions definition

[18:05] <hkatz> should give you a basic idea

[18:06] <psch> &parse_arg is probably the most interesting one, the rest you can already achieve with required nameds

[18:06] <hkatz> oh! I already know that that's why I picked this specific example for a demonstration of p6

[18:06] <hkatz> I'm asking about a way to NOT pollute the main script

[18:07] <hkatz> I would prefer the main script offload most of the work to keep the logic simple

[18:07] <psch> the logic in the signature of MAIN is just the signature

[18:07] <hkatz> however, I'm not aware of a package in p6 being able to do the MAIN method

[18:07] <hkatz> I think I could call a MAIN method in the main script and then immediatly pass that to my package with the same definitions

[18:07] <psch> e.g. «sub MAIN(Str :$targets-file!) { }» makes your script require "--targets-file=$file" or print usage

[18:07] <hkatz> but that seems silly

[18:08] <ugexe> %*ARGS or whatever stores the arguments doesnt it

[18:08] <hkatz> psch, even better is <<subset File of Str where *.IO.e;>>

[18:09] <ugexe> or just pass *%_ from MAIN

[18:09] <hkatz> think that'll work?

[18:09] <jnthn> hkatz: To me, the script is the right place to define the command line interface, not pollution. :) But you should be able to write MAIN methods in a module and put "is export" on them

[18:09] <psch> http://doc.perl6.org/language/5to6#Getopt%3A%3ALong

[18:09] <psch> hkatz: yes, that would guarantee you get a file

[18:09] <hkatz> jnthn thank you, I'll take a look into that. The only reason I was moving it to another file is because it's a Setup.pm

[18:09] <psch> i'm with jnthn++ here, arguments should be validated by the main entry point

[18:10] <hkatz> basically to get all the globals, settings, etc up and ready

[18:10] <psch> fwiw, i'd rather put all the not-setup logic into the module

[18:10] *** _4d47 left
[18:12] *** virtualsue left
[18:14] *** Rounin joined
[18:14] *** _4d47 joined
[18:23] <hkatz> in a package in p6 how would you emulate or replicate the functionality of Exporter() with global subs and variables?

[18:23] <hkatz> just add "is export" after them?

[18:23] <nine_> hkatz: basically, yes

[18:23] <hkatz> lol basically ;)

[18:24] <hkatz> everything about perl is basically*                             *not actually basic

[18:24] <nine_> hkatz: there is more functionality available, but "is export" is all you need most of the time

[18:25] <psch> beyond the basically there's «is export(:DEFAULT)» or «is export(:MANDATORY)» or «is export(:rarely-used)»

[18:25] * FROGGS is relieved that the perl6-j+Digest bug is not a precomp one

[18:25] <psch> where the capital ones are special, as i understand

[18:28] <hkatz> can I export multiple variables at once? or only at definition?

[18:28] <hkatz> in p5: <<use vars qw( ... ); >>

[18:28] <hkatz> in p6?

[18:29] *** kjs_ joined
[18:29] <hkatz> I gtg, I'll ask again later :P

[18:32] *** sqirrel joined
[18:33] *** _4d47 left
[18:38] *** _4d47 joined
[18:40] *** lizmat_ joined
[18:40] *** kjs_ left
[18:41] <nine_> Why can I not use my normal rt.perl.org user for Perl 6 bugs?

[18:41] <[Coke]> define "use"

[18:42] <[Coke]> there's a separate privs list. p5 bugadmins aren't p6 bugadmins

[18:42] <dalek> rakudo/nom: fc178b7 | (Geoffrey Broadwell)++ | src/core/IO/Path.pm:

[18:42] <dalek> rakudo/nom: Now that nqp-j supports nqp::readlink, enable IO::Path.resolve for any backend

[18:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc178b7929

[18:42] <dalek> specs: 11b888d | lizmat++ | S32-setting-library/Exception.pod:

[18:42] <dalek> specs: Speculate about kebab-casing hidden_from_backtrace

[18:42] <dalek> specs: review: https://github.com/perl6/specs/commit/11b888d30c

[18:43] *** lizmat left
[18:49] <FROGGS> jnthn / psch: that's the jvm+Digest bug: https://gist.github.com/FROGGS/e2093d1bdcef95700b9c

[18:49] <FROGGS> quite weird...

[18:50] <dalek> roast: a0ea667 | jnthn++ | S09-typed-arrays/native.t:

[18:50] <dalek> roast: Add some basic tests for native int/num arrays.

[18:50] <dalek> roast: review: https://github.com/perl6/roast/commit/a0ea667b43

[18:51] <jnthn> FROGGS: Very.

[18:52] <FROGGS> okay, can be simplified to:

[18:52] <FROGGS> $ perl6-j -e 'my $a = (42 for ^2).flat; say $a[0]'

[18:52] <FROGGS> Nil

[18:53] <nine_> [Coke]: coming from the perl 6 ticket list I can only login using Bitcard or use the public interface. Coming from a CPAN module's ticket I can use the login for CPAN authors

[18:55] <FROGGS> perl6-j -e 'my $a = (42 for ^2).flat; say $a.WHAT, " ", $a.elems' # (List) 0

[18:55] <[Coke]> rt.cpan.org is special.

[18:55] <[Coke]> would be my guess.

[18:55] <[Coke]> (I think those were merged at some point but started out separate)

[19:00] <vendethiel> m: say %(do for <<"foo: a=b c=d" "bar: 1=2">> { my ($pre, $post) = .split(/':' <.ws>/); $pre => $post.split(/<[= \s]>+/); })

[19:00] <yoleaux> 12 Mar 2015 23:44Z <eli-se> vendethiel: I also disallow mixed | and & without parens

[19:00] <camelia> rakudo-moar fe77d2: OUTPUT«bar => 1 2, foo => a b c d␤»

[19:00] <vendethiel> m: say %(do for <<"foo: a=b c=d" "bar: 1=2">> { my ($pre, $post) = .split(/':' <.ws>/); $pre => $post.split(/<[= \s]>+/); }).perl

[19:00] <camelia> rakudo-moar fe77d2: OUTPUT«("bar" => ("1", "2").list.item, "foo" => ("a", "b", "c", "d").list.item).hash␤»

[19:00] <vendethiel> m: say %(do for <<"foo: a=b c=d" "bar: 1=2">> { my ($pre, $post) = .split(/':' <.ws>/); $pre => $post.split(/<[= \s]>+/).hash; }).perl

[19:00] <camelia> rakudo-moar fe77d2: OUTPUT«("foo" => {"c" => "d", "a" => "b"}, "bar" => {"1" => "2"}).hash␤»

[19:00] <vendethiel> hehehehe

[19:00] <nine_> Ok, I now got myself a bitcard account and used that to login but am still not able to add information to my ticket

[19:01] <nine_> To the contrary, I cannot even look at the Perl 6 ticket list when logged in?!

[19:04] *** diana_olhovik left
[19:05] <dalek> perl6-examples: a5e2753 | paultcochrane++ | / (2 files):

[19:05] <dalek> perl6-examples: Example() now takes a pod-content field

[19:05] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/a5e275392d

[19:05] <dalek> perl6-examples: 73832bb | paultcochrane++ | categories/best-of-rosettacode/100-doors.pl:

[19:05] <dalek> perl6-examples: [rosettacode] merge pod blocks; add AUTHOR

[19:05] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/73832bbd34

[19:05] <dalek> perl6-examples: 9379274 | paultcochrane++ | README.md:

[19:05] <dalek> perl6-examples: Document how to run examples in README

[19:05] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/9379274860

[19:05] <itz> nine_: I've had that problem .. I had less access logged into RT than anonymous ... I had to create another accn 

[19:05] *** _4d47 left
[19:07] <dalek> perl6-examples: 43d3193 | paultcochrane++ | README.md:

[19:07] <dalek> perl6-examples: Stop the #perl6 channel from being a heading

[19:07] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/43d3193e33

[19:08] <timotimo> hehe

[19:08] <bartolin> Fr

[19:08] <bartolin> er

[19:08] <nine_> itz: but I just registered this account? Why would yet another account work any better?

[19:10] <bartolin> FROGGS: is that JVM+Digest bug in RT as RT #123506 ?

[19:10] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123506

[19:11] <psch> FROGGS: there's quite a bit weird there, yes

[19:11] <FROGGS> bartolin: yes, exactly!

[19:11] <psch> $ ./perl6-j -e'my method flats($list:) { $list.flattens ?? $list !! nqp::p6list(nqp::list($list), List, Bool::True) }; say flats (1 for 1)'

[19:11] <psch> 1

[19:11] <FROGGS> look at that:

[19:11] <psch> but!

[19:11] <FROGGS> $ perl6-j -e 'my $a = (do 42 for ^2).flat; say $a.WHAT, " ", $a.elems' # (List) 2

[19:11] <FROGGS> $ perl6-j -e 'my $a = (   42 for ^2).flat; say $a.WHAT, " ", $a.elems' # (List) 0

[19:11] <bartolin> FROGGS: ahh, thanks!

[19:11] <psch> $ ./perl6-j -e'my method flats($list:) { $list.flattens ?? $list !! nqp::p6list(nqp::list($list), List, Bool::True) }; say (1 for 1).&flats'

[19:11] <psch> Nil

[19:11] <FROGGS> bartolin: thank you for the reference :o)

[19:11] <nine_> Is there some RT administrator in this channel?

[19:12] <FROGGS> nine_: ask [Coke]++

[19:12] <FROGGS> psch: hmmm

[19:12] <psch> &flats in my examples is identical to List.flat, fwiw

[19:12] <FROGGS> hmmm

[19:13] <nine_> [Coke]: could you please give my account at least as much priviledge as anonymous? Or even better the ability to contribute information? User name is nine

[19:13] <FROGGS> "user name is nine" - "nein"

[19:13] <[Coke]> I can only make you a bugadmin.

[19:13] *** xinming left
[19:14] <FROGGS> psch: that's highly interesting (and weird)

[19:14] *** xinming joined
[19:14] <nine_> [Coke]: if that allows me to post additional information, I'll gladly take that ;)

[19:14] <[Coke]> nine_: "couldn't find that principal"

[19:14] <[Coke]> are you sure it's "nine", no special characters, on rt.perl.org ?

[19:15] <nine_> [Coke]: yes? Email is [email@hidden.address]
[19:15] <[Coke]> found the email. added.

[19:15] <psch> FROGGS: i don't get the implementation of p6list on moar, so i can't really compare it to jvm, but that's where i'd look...

[19:16] *** rindolf left
[19:16] <psch> FROGGS: aside from that it could maybe be some kind of wonkiness with in IndyBootstrap, differences between methcall_noa and subcall_noa, but that's pretty much a blind guess

[19:16] <dalek> rakudo/nom: 44f46ac | lizmat++ | / (18 files):

[19:16] <dalek> rakudo/nom: "hidden_from_backtrace" -> "hidden-from-backtrace"

[19:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/44f46aca4f

[19:17] <nine_> [Coke]: many thanks!

[19:17] <psch> s/with //

[19:18] <masak> usev6++ # RT ticket wrangling

[19:19] <dalek> Inline-Perl5: 54e5c05 | (Stefan Seifert)++ | / (3 files):

[19:19] <dalek> Inline-Perl5: Support READLINE on file handles passed from P6 to P5

[19:19] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/54e5c050e2

[19:20] <[Coke]> nine_: of course. thanks.

[19:27] <dalek> rakudo/nom: d4eb903 | lizmat++ | src/core/ (2 files):

[19:27] <dalek> rakudo/nom: "is hidden_from_USAGE" -> "is hidden-from-USAGE"

[19:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4eb903ebe

[19:28] *** vagabondo joined
[19:29] <nine_> .seen [Tux] 

[19:29] <yoleaux> I saw [Tux] 08:26Z in #perl6: * [Tux] => $work

[19:29] <nine_> .seen |Tux| 

[19:29] <yoleaux> I saw |Tux| 11 Mar 2015 14:53Z in #perl6: <|Tux|> no

[19:29] <masak> famous last words

[19:30] <jdv79> what's with the s/_/-/ stuff?  is there a non-subjective reason?

[19:30] <psch> jdv79: consistency is the main reason

[19:30] <nine_> .tell [Tux] Text::CSV_XS can now read from Perl 6 file handles :) Just be sure to open the file with chomp => False.

[19:30] <yoleaux> nine_: I'll pass your message to [Tux].

[19:30] <masak> jdv79: it's the War On Underscores

[19:30] <psch> jdv79: and kebab-case won, Because We Can™

[19:31] <dalek> doc: 3e81edc | moritz++ | lib/Type/ (3 files):

[19:31] <dalek> doc: track hidden_from_backtrace rename

[19:31] <dalek> doc: review: https://github.com/perl6/doc/commit/3e81edc250

[19:31] <nine_> Still feels like difference for the sake of difference to me

[19:31] <lizmat_> moritz++

[19:31] *** lizmat_ is now known as lizmat

[19:32] <psch> fwiw, i disagree with kebab-casing CAPS-ONLY names, if only because it's inconvenient to type

[19:32] <psch> but i'm not going to argue about that

[19:33] <nine_> psch: ONE-OF-THE-FEW-GOOD-USES-FOR-CAPS-LOCK

[19:33] <nine_> psch: but I guess you're as little used to using caps lock as I am ;)

[19:33] <lizmat> psch: fwiw, kebab-casing ALL-CAPS is intended to make it inconvenient to type  :-)  

[19:33] *** virtualsue joined
[19:33] <psch> nine_: my caps lock is compose :)

[19:33] <lizmat> it's a bit like the QWERTY layout  :-)

[19:34] <psch> lizmat: i guess that makes sense, and is as good as a reason as any for me

[19:34] <lizmat> psch: how often *will* you type something like AT-KEY anyway ?

[19:36] <psch> lizmat: as i said, i won't argue the point, especially as i hadn't considered that the places where we want all caps *should* be inconvenient, which only makes it work better

[19:36] <psch> case in point: MONKEY_TYPING vs MONKEY-TYPING

[19:37] *** hkatz left
[19:37] <psch> (where i actually typoed twice in the kebab-caps version)

[19:37] <jdv79> i was just curious, partly because p5 tends to favor snake case and partly because it seems a little petty but i'm all for consistency.

[19:37] <psch> which does add sufficient gravitas

[19:37] <timotimo> I-DONT-FIND-IT-HARD-TO-TYPE-KEBABCAPS

[19:38] <[Coke]> ME-EITHER-AND-I-DON'T-EVEN-HAVE-A-CAPSLOCK.

[19:39] *** madmuid1 joined
[19:39] <timotimo> I-CAN-GET-CAPSLOCK-BY-PRESSING-BOTH-SHIFT-KEYS-AT-THE-SAME-TIME

[19:39] <timotimo> AND-THEN-THE-DASH-IS-ON-CAPSLOCK-AND-T

[19:40] *** madmuid left
[19:41] * psch .oO( that aside, i have this hud for storing muscle-powered vehicles, and i'm wondering about the color... )

[19:42] <japhb> FROGGS: I could have sworn once seeing a discussion that the difference between 'a for b' and 'do a for b' was intentional: for doesn't return its iterated results unless you 'do for'

[19:42] <japhb> Maybe that was only temporarily the case and r-j never caught up?

[19:42] <psch> oh, i remember that

[19:43] <timotimo> you store muscle-powered vehicles inside a heads up display?

[19:43] <psch> timotimo: no, in my heads up display i store reminders for typos that ruin silly jokes :/

[19:44] <timotimo> :)

[19:45] *** spider-mario joined
[19:46] *** sqirrel left
[19:47] *** aborazmeh joined
[19:47] *** aborazmeh left
[19:47] *** aborazmeh joined
[19:48] *** espadrine joined
[19:48] *** hobbs left
[19:51] *** hobbs joined
[19:52] <psch> japhb: the parens aren't superstitious

[19:52] <psch> m: my $x = 1 for ^2; say $x; $x = (1 for ^2); say $x

[19:52] <camelia> rakudo-moar d4eb90: OUTPUT«1␤1 1␤»

[19:52] <dalek> rakudo/nom: 80f5c8d | lizmat++ | / (3 files):

[19:52] <dalek> rakudo/nom: "use MONKEY_TYPING" -> "use MONKEY-TYPING"

[19:52] <dalek> rakudo/nom: 

[19:52] <dalek> rakudo/nom: Alas, no deprecation message for MONKEY_TYPING just yet, as this exceeds

[19:52] <dalek> rakudo/nom: my rakudo-nqp capabilities.

[19:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/80f5c8d576

[19:53] <psch> m: my $x = do 1 for ^2; say $x # and this

[19:53] <camelia> rakudo-moar d4eb90: OUTPUT«1 1␤»

[19:53] *** diana_olhovik joined
[19:54] <moritz> moritz@pat:~/p6/all>git grep MONKEY_TYPING|wc -l

[19:54] <moritz> 16

[19:54] <moritz> 7 of those are in p6/doc

[19:54] <masak> heh.

[19:55] <jnthn> Monkey see, monkey doc..

[19:55] *** vagabondo left
[19:58] <dalek> doc: 0fe9413 | moritz++ | lib/Type/X/ (4 files):

[19:58] <dalek> doc: s/MONKEY_TYPING/MONKEY-TYPING/

[19:58] <dalek> doc: review: https://github.com/perl6/doc/commit/0fe9413d10

[19:58] <lizmat> moritz++

[20:02] <dalek> roast: 5b8dbb5 | lizmat++ | / (18 files):

[20:02] <dalek> roast: "use MONKEY_TYPING" -> "use MONKEY-TYPING"

[20:02] <dalek> roast: review: https://github.com/perl6/roast/commit/5b8dbb5baf

[20:03] <FROGGS> O.o

[20:03] <lizmat> ??

[20:03] <lizmat> too soon ?

[20:03] <FROGGS> why are we changing that at all?

[20:03] <lizmat> in roast?  or in core?

[20:03] <FROGGS> in both

[20:03] <lizmat> consistency ?

[20:04] <FROGGS> foo-bar makes sense to be because you dont have to press shift for the dash/underscore..

[20:04] <FROGGS> but for FOO-BAR I have to release shift, which is a keystroke too many

[20:05] <FROGGS> that's why I thought we go for 'foo-bar' and 'FOO_BAR'

[20:05] <psch> FROGGS: but the CAPS-ONLY things we have are supposed to be inconvenient

[20:05] <psch> like EVAL, or MONKEY-TYPING

[20:05] <FROGGS> psch: they have to stick out, that's all

[20:05] <FROGGS> like method BUILD

[20:05] <lizmat> FROGGS: eh, why didn't you speak up when I did AT-KEY and friends?

[20:06] <FROGGS> "I do something special/weird here, look"

[20:06] <FROGGS> lizmat: because I dunno :/

[20:06] <FROGGS> arnt these internal only?

[20:06] <lizmat> alas, no, they are part of the rakudo implementation

[20:06] <FROGGS> japhb: I know about the distinction of a statement level 'for' and the opposite... but the handling of that happens in Perl6::Action...

[20:06] <lizmat> and they allow you to create custom classes that allow you to do [] and {}

[20:07] <FROGGS> japhb: I dont think there VM specific bits

[20:07] <jnthn> lizmat: Part of Perl 6, surely...

[20:07] <FROGGS> japhb: (at least I hope so)

[20:07] <FROGGS> lizmat: hmmm

[20:07] <jnthn> lizmat: Otherwise, there's no way to implement a custom collection type 

[20:07] <FROGGS> lizmat: I'd like to here TimToady's opinion on that

[20:07] <lizmat> jnthn: nothing about AT-KEY and friends is speculated about

[20:08] <FROGGS> just if it should be AT-KEY or AT_KEY

[20:08] <lizmat> therefore I put tests for AT-KEY and friends in "make test"

[20:08] <grondilu> having to press shift is maybe a good thing for something you want to dissuade the user to type.

[20:08] <FROGGS> because at least on my keyboard AT_KEY is easier to type

[20:08] *** vagabondo joined
[20:09] <masak> also, '_' reads more like a space between words than '-'

[20:09] <jnthn> lizmat: Wait, you removed tests for those from spectest?

[20:09] <grondilu> the underscore has a look that suits more the "experimental" aspect of the pragma.

[20:09] <lizmat> yes, there weren't many, only in Set/Bag/Mix mostly

[20:09] <jnthn> lizmat: Removing stuff from spectest because they aren't mentioned in the design docs is an odd choice, given the spectests are primary...

[20:10] <jnthn> Or at least, that's how I consider them.

[20:10] <FROGGS> grondilu: that does not look anywhere near 'experimental' to me :o)

[20:10] <masak> I don't mind underscores in ALL_CAPS things, and I will probably continue to use them in my programs. but I don't have a hyena in this race. if the powers-that-be want to upheav all of the ecosystem to get rid of underscores, then please go ahead. :)

[20:11] <lizmat> jnthn: note: these were tests for AT-KEY (at_key) specifically, not for [] or {}

[20:11] <masak> upheave*

[20:11] *** vagabondo left
[20:11] <jnthn> lizmat: In my view, [AT|ASSIGN|BIND|EXISTS|DELETE]-[POS|KEY] should get decent spectest coverage, *especially* tests covering using them for implementing custom types.

[20:12] <lizmat> I agree they must be tested

[20:12] <lizmat> but I think they belong in the sanity test (make test) rather than in roast (make spectest)

[20:12] <jnthn> But they're a public-facing part of the language!

[20:12] <lizmat> as other implementation of Perl6 might not use this name *or* that type of implementation

[20:13] <lizmat> jnthn: I was under the impression that it was a public-facing part of an *implementation* of the language

[20:13] <FROGGS> lizmat: if it is in roast it has to be supported by Perl 6 compilers

[20:14] <moritz> lizmat: I think they should be documented in the design docs

[20:14] <lizmat> well, by all means, I'll move the tests  :-)

[20:14] <FROGGS> lizmat++

[20:14] <lizmat> does niecza have at_key as well ?

[20:14] <jnthn> lizmat++

[20:15] <lizmat> does pugs ?

[20:15] <jnthn> I suspect niecza may well do so

[20:15] <jnthn> Pugs is probably too long ago to be relevant. But we've had the at_pos/at_key thing for O(years) now.

[20:16] *** FROGGS[mobile] left
[20:16] <lizmat> well, if we all agree it's part of Perl 6 as a language, and not of the rakudo implementation, that's fine by me  :-)

[20:16] <jnthn> Perl 6 as a language needs a mechanism for doing this stuff.

[20:17] *** yqt joined
[20:17] <lizmat> in any case, at_key and friends were grossly undertested

[20:18] * jnthn can quite imagine

[20:18] <lizmat> the removal of the tests is in 33d5415548 in roast

[20:18] <lizmat> most of those I had put in myself

[20:19] <lizmat> suggestion fot location in roast for t/01sanity/22-KEY.t ?

[20:20] <lizmat> S02-primitives ?

[20:20] <lizmat> (new directory)

[20:20] <jnthn> S32-container maybe?

[20:21] *** aborazmeh left
[20:21] <[Coke]> irc--

[20:21] <FROGGS> [Coke]: be nice, IRC could be your father :P

[20:22] <lizmat> [Coke]: ??

[20:22] <[Coke]> that is… highly doubtful

[20:23] <[Coke]> permissions. remembering channels you've subbed to. lack of built in logging.

[20:23] *** bayprogrammer joined
[20:24] <lizmat> jnthn: would you be against a new dir S02-primitives ??  Feels to me AT-KEY and friends need to be speculated about in S02, no?

[20:25] <lizmat> or perhaps S32-setting-library/Basics.pod ?

[20:27] <FROGGS> psch: it is more about statement level for I guess, or method vs. sub: perl6-j -e 'my method flats($list:) { say $list }; (1 for 1).&flats' # Nil

[20:28] <jnthn> lizmat: I guess S02 does talk a decent bit about container stuff too

[20:28] <jnthn> lizmat: So it'd fit there I guess

[20:28] *** darutoko left
[20:28] <lizmat> but I guess it's more general in S02, and more specific in S32-basics

[20:29] <lizmat> so we might well keep AT-KEY and friends in S32-basics as to not make S02 even heavier than it already is

[20:30] <dalek> roast: c828560 | lizmat++ | S32-basics/xxKEY.t:

[20:30] <dalek> roast: Move sanity AT-KEY and friends tests to roast

[20:30] <dalek> roast: review: https://github.com/perl6/roast/commit/c8285607ec

[20:30] <lizmat> we can always move it later  :-)

[20:31] <dalek> rakudo/nom: e07ef9d | lizmat++ | t/ (2 files):

[20:31] <dalek> rakudo/nom: Move sanity AT-KEY and friends tests to roast

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e07ef9de97

[20:31] *** virtualsue_ joined
[20:32] *** virtualsue left
[20:32] *** virtualsue_ is now known as virtualsue

[20:33] *** molaf joined
[20:34] <lizmat> jnthn: BTW, I asked a question a few days ago about the reason for ASSIGN-KEY and AT-KEY being rw

[20:35] <lizmat> looks to me either AT-KEY could be made *not* is rw, or we don't need an ASSIGN-KEY primitive

[20:38] <jnthn> We don't *need* ASSIGN-KEY, but it makes very common case assignments dramatically faster.

[20:38] <jnthn> In a way that we will struggle to match with other optimizations.

[20:39] *** beastd joined
[20:39] <jnthn> There was some discussion about it between myself and TimToady around the time it went in, which can probably be dug up from the ir clogs.

[20:39] <masak> m: sub foo(@bar) { @bar = 1, 2, 3; say @bar }; my @x = 4, 5, 6; foo(@x)

[20:39] <camelia> rakudo-moar 80f5c8: OUTPUT«1 2 3␤»

[20:40] <masak> so... 'is rw' is not needed on container types?

[20:40] <masak> m: sub foo(@bar) { @bar = 1, 2, 3; say @bar }; my @x = 4, 5, 6; foo(@x); say @x

[20:40] <camelia> rakudo-moar 80f5c8: OUTPUT«1 2 3␤1 2 3␤»

[20:40] <jnthn> masak: It's only interesting on scalars.

[20:40] <masak> I see.

[20:40] <jnthn> masak: Well, and on slurpyes.

[20:41] <masak> S02 contains two examples of an array parameter being marked 'is rw'

[20:41] <jnthn> It's another case of the "has @.foo is rw" kettle of fish.

[20:42] <FROGGS> masak: the intend probably was to disallow messing with its slots by default

[20:42] <FROGGS> masak: but it proves to be difficult

[20:43] <masak> I know.

[20:43] <FROGGS> m: say (42 for 1)

[20:43] <camelia> rakudo-moar e07ef9: OUTPUT«42␤»

[20:43] <FROGGS> jnthn: is that a statement level for?

[20:44] <masak> I seems to recall me some wording in the sp^Wdoc about the default readonlyness being applicable "one level down" (that is, to the array's elements, too)

[20:44] <masak> this, too, I believe, is difficult to enforce

[20:45] <jnthn> FROGGS: I think the interesting ones are statementlist level, no?

[20:45] <masak> m: sub foo(@bar is copy) { @bar = 1, 2, 3; say @bar }; my @x = 4, 5, 6; foo(@x); say @x

[20:45] <camelia> rakudo-moar e07ef9: OUTPUT«1 2 3␤4 5 6␤»

[20:45] <masak> ah, good.

[20:45] <jnthn> FROGGS: That one doesn't count as having the eager semantics.

[20:45] <masak> this is what I needed.

[20:47] <psch> $ ./perl6-j -e'say (eager (1 for ^2)).flat'

[20:47] <psch> 1 1

[20:47] * psch shrugs

[20:47] <FROGGS> jnthn: by statementlist level you basically mean thruthness of $*statement_level, right?

[20:47] <psch> this is a point where i don't know what behavior should be correct

[20:47] <FROGGS> when looking at rakudo/src/Perl6/Grammar.nqp:1275:    rule statementlist($*statement_level = 0) {

[20:48] <psch> if «say (42 for 1)» isn't eager and r-m print something but jvm doesn't...?

[20:48] <psch> i suppose &say should cause eager evaluation

[20:48] <psch> or at least some kind of evaluation?

[20:48] <FROGGS> well, I hope so

[20:49] <jnthn> FROGGS: yes

[20:49] <psch> but it breaks on assignment too, doesn't it?  which means there's a spot where r-j doesn't realize it has to evaluate

[20:49] <psch> which is List.flat

[20:49] <FROGGS> btw, for that example $*statement_level is trueish but $ast.ann('statement_level') is falsish

[20:50] <FROGGS> on moar

[20:55] <ugexe> FROGGS: i dont see any of my recent test reports showing up, although I see your URI report popped up. is testers working fine or are my test enviroments likely borked?

[20:58] *** MadcapJake left
[20:59] <dalek> rakudo/nom: 26b7eb1 | lizmat++ | src/core/SetHash.pm:

[20:59] <dalek> rakudo/nom: Make SetHash<a> = True about 5% faster

[20:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/26b7eb121e

[21:00] * raydiak notices that KEY and POS have been converted to uppercase but not invoke

[21:01] <dalek> Heuristic branch merge: pushed 30 commits to rakudo/newio by lizmat

[21:01] <lizmat> raydiak: I was under the impression that the jury was till out on that

[21:01] <lizmat> specifically which UPPERCASE name to be used instead of invoke()

[21:01] <raydiak> ah...haven't been keeping a close eye for a few days, wasn't sure if it was intentional or not

[21:01] <raydiak> what's wrong with INVOKE?

[21:02] <lizmat> I'm not sure either  :-)

[21:02] <lizmat> perhaps it is ok to change, but I missed it somehow while backlogging

[21:02] * psch &

[21:03] <raydiak> figured I'd ask since it's the one stopping Inline::Lua from matching the other Inline:: APIs

[21:04] <FROGGS> ugexe: we had a blackout from 12th midnight to were my URI reports were received

[21:04] <ugexe> FROGGS: yeah, i *should* have had tests submitting for the last hour from at least 1 machine

[21:05] <ugexe> unless `PANDA_SUBMIT_TESTREPORTS=1 && panda smoke` not work the same as `PANDA_SUBMIT_TESTREPORTS=1 panda smoke` (thats all ive changed since)

[21:05] <lizmat> raydiak: looking at http://irclog.perlgeek.de/perl6/2015-03-07#i_10238687

[21:06] <FROGGS> ugexe: wrong

[21:06] <FROGGS> the && is to blame

[21:07] <FROGGS> ugexe: try that: PANDA_SUBMIT_TESTREPORTS=1 panda install URI

[21:07] <lizmat> raydiak: http://irclog.perlgeek.de/perl6/2015-03-07#i_10240527

[21:08] <FROGGS> ugexe: and then: perl6-m -e 'say "%*CUSTOM_LIB<site>/panda/reports.$*PERL.compiler.version()".IO.lines'

[21:09] <lizmat> lizmat: guess I missed http://irclog.perlgeek.de/perl6/2015-03-07#i_10240635

[21:09] <FROGGS> ugexe: this should print: URI		v0.1.0	True	True	moar

[21:10] <FROGGS> ugexe: if it is in that reports file, it was sent

[21:10] <japhb> FROGGS: Any chance for the S11 branch(es) to make it in for 2015.03?

[21:10] <FROGGS> japhb: no chance

[21:11] <ugexe> FROGGS: it appears to have sent then. let me try with the && and see if that makes it not work

[21:11] <japhb> OK, too bad.

[21:11] <FROGGS> japhb: ohh wait... the eleven branch only exists in panda anymore

[21:11] <raydiak> lizmat: heh cute; not sure that CALL-ME would be my first choice though I don't much care as long as it's more obscure and different-looking than lowercase "invoke"

[21:11] <japhb> Oh?  I didn't realize it was only there now!

[21:11] <FROGGS> ugexe: then try another module, the reports file is used to only send a report once per module/result

[21:13] <lizmat> raydiak: getting tired now, will look at invoke() -> CALL-ME tomorrow

[21:13] <lizmat> raydiak: feels like it's too easy to make mistakes there  :-)

[21:13] <hoelzro> two threads can safely read from a single channel, right?

[21:13] <lizmat> yes, that's the idea, afaik

[21:13] <hoelzro> ok, I may have found a bug...

[21:13] *** agentzh joined
[21:13] *** agentzh left
[21:13] *** agentzh joined
[21:14] <raydiak> lizmat: probably true...thank you again for working on this (and like a million other things)

[21:14] <hoelzro> going to dig a bit

[21:14] <lizmat> hoelzro: S17:259

[21:14] <synopsebot> Link: http://design.perl6.org/S17.html#line_259

[21:14] <lizmat> raydiak: yw  :-)

[21:14] <hoelzro> thanks lizmat 

[21:17] <dalek> rakudo/newio: 6506a31 | lizmat++ | docs/ChangeLog:

[21:17] <dalek> rakudo/newio: Mention some more deprecations

[21:17] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/6506a31b49

[21:17] <dalek> nqp: f3bd3c5 | jnthn++ | src/vm/moar/HLL/Backend.nqp:

[21:17] <dalek> nqp: Fix "cannot dump Str" profile report bug.

[21:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f3bd3c5f71

[21:17] <lizmat> [Tux]  ^^^^

[21:17] <ugexe> FROGGS: it was the &&. must have to do with how panda handles resetting that ENV (or what i think i remember from panda from months ago)

[21:17] <jnthn> .tell |Tux| latest NQP has a fix for the profile dump bug

[21:17] <yoleaux> jnthn: I'll pass your message to |Tux|.

[21:18] <lizmat> jnthn: shall I bump NQP_REV ?

[21:19] <FROGGS> ugexe: the && just lets your bash not pass it to panda...

[21:19] <ugexe> i thought panda just read it from ENV?

[21:19] <jnthn> lizmat: No

[21:19] <dalek> rakudo/nom: 95ef453 | lizmat++ | docs/ChangeLog:

[21:19] <dalek> rakudo/nom: Mention some more deprecations (in right branch)

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/95ef453ca4

[21:19] <jnthn> lizmat: I've a MoarVM dump to do also, 

[21:19] <lizmat> jnthn: okidoki

[21:19] <jnthn> lizmat: I'll bump it soon.

[21:20] <lizmat> ok

[21:20] <lizmat> I know [Tux]  is eager to see that fix  :-)

[21:21] <lizmat> hoelzro: if you can reproduce a Channel bug, could you please put the test in t/spec/S17-channel/ ?

[21:21] <hoelzro> lizmat: you got it

[21:21] <hoelzro> I'll probably paste it here first, to check my sanity

[21:21] <dalek> nqp: caa6a98 | jnthn++ | tools/build/MOAR_REVISION:

[21:21] <dalek> nqp: Bump MOAR_REVISION for bindpos_n JIT fix.

[21:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/caa6a98929

[21:21] <lizmat> sure

[21:22] <FROGGS> ugexe: yes, and I was under the impression that FOO=42 && /my/program would be a noop regarding to the env...

[21:22] <jnthn> Hm, even before optimization work, native arrays come out faster

[21:22] <lizmat> cool!

[21:22] <japhb> Excellent!

[21:22] <FROGGS> I like the word faster!

[21:23] <japhb> .oO( Party on, Wayne! )

[21:24] <masak> I like the *concept* faster! :D

[21:24] <lizmat> .oO( even more concepter! )

[21:24] *** skids left
[21:24] * masak .oO( in Swedish, the word "faster" means "father's sister" -- "aunt" )

[21:25] *** Ugator1 joined
[21:25] <masak> we have very compelling/logical names for relatives in Swedish. the rest of the world should copy us.

[21:25] <lizmat> :q

[21:25] * hugme hugs lizmat, good vi(m) user!

[21:25] <lizmat> hehe

[21:25] *** Ugator left
[21:25] <masak> hugme: do you ever hug Emacs users?

[21:26] <masak> ^X^S

[21:26] <masak> apparently not.

[21:29] <dalek> roast: b129356 | jnthn++ | S09-typed-arrays/native-decl.t:

[21:29] <dalek> roast: Tests for "my int @x" and "my num @x".

[21:29] <dalek> roast: 

[21:29] <dalek> roast: These focus on the declaration syntax; native.t is left to focus on

[21:29] <dalek> roast: the native array type itself.

[21:29] <dalek> roast: review: https://github.com/perl6/roast/commit/b129356c99

[21:29] <ugexe> whats the least amount of RAM someone has heard of jvm rakudo installing succesfully?

[21:30] <vendethiel> masak: only if they have evil-mode installed ;-)

[21:30] <FROGGS> that's sooo weird:

[21:30] <FROGGS> perl6-m -e 'say my $a = (42 for ^2)' # 42 42

[21:30] <FROGGS> perl6-j -e 'say my $a = (42 for ^2)' # Nil

[21:30] <FROGGS> perl6-j -e 'say         (42 for ^2)' # 42 42

[21:30] <vendethiel> I need to look at how I can make evil-mode behave like I want it...

[21:30] <jnthn> FROGGS: Any notable diffs if you --target=ast and --target=optimize ?

[21:30] <lizmat> ugexe: I've heard 1G and up

[21:31] <FROGGS> jnthn: the ast diff shows that the jvm uses p6bindsig where moar does a bunch of lowered_param thingies

[21:31] <ugexe> i havent had success with 1G yet :(

[21:31] * vendethiel uses ";" instead of ":" on vim because one less keypress

[21:31] <ugexe> def havent had success with 350 lol

[21:32] <FROGGS> same for optimize

[21:32] <hoelzro> oooo, I got my concurrent implementation to segfault

[21:32] <FROGGS> hoelzro++

[21:32] <hoelzro> non-deterministicly, of course =(

[21:32] <FROGGS> :/

[21:33] <lizmat> yeah, that happens, there's quite a lot of skipped tests in S17*

[21:33] <lizmat> that do that still  :-(

[21:33] <hoelzro> =(

[21:33] <hoelzro> the S17 stuff is exactly why I reached for P6 for this tool

[21:34] <lizmat> please gist it anyway, perhaps it will give us the info we need to kill off the non-deterministici;kjljgzjxgj

[21:34] <dalek> rakudo/nom: 439c40c | jnthn++ | tools/build/NQP_REVISION:

[21:34] <dalek> rakudo/nom: Bump NQP_REVISION for Moar JIT + profiler fixes.

[21:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/439c40c5e8

[21:34] <retupmoca> I'd really like to use P6 threads, but I've been holding off; they aren't yet stable

[21:35] <vendethiel> ^ 

[21:36] <lizmat> m: multi a () {}; multi a(*%_) {}; a()   # how can I make a MMD that matches on () in this case??

[21:36] <camelia> rakudo-moar 26b7eb: OUTPUT«Ambiguous call to 'a'; these signatures all match:␤:()␤:(*%_)␤  in sub a at /tmp/RAGGuyxlJv:1␤  in block <unit> at /tmp/RAGGuyxlJv:1␤␤»

[21:37] *** zby_home left
[21:38] <lizmat> I guess you can't  :-(

[21:38] <jnthn> I don't think you can.

[21:40] <jnthn> On the threading/concurrency stuff: yes, it needs work. It's on my todo list, after native arrays and NFG.

[21:45] <dalek> rakudo/nom: 1cc426d | jnthn++ | / (2 files):

[21:45] <dalek> rakudo/nom: Add a partial array[T], usable for native int/num.

[21:45] <dalek> rakudo/nom: 

[21:45] <dalek> rakudo/nom: This still has a number of pieces missing that are needed for full

[21:45] <dalek> rakudo/nom: functionality (for example, .perl and .gist are to come), not to

[21:45] <dalek> rakudo/nom: mention many missing optimizations. However, it is enough to pass

[21:45] <dalek> rakudo/nom: the initial ~200 native array tests.

[21:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1cc426d69f

[21:45] <dalek> rakudo/nom: fc1e6c2 | jnthn++ | src/Perl6/World.nqp:

[21:45] <dalek> rakudo/nom: Make "my int @a" and "my num @a" use array[T].

[21:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc1e6c2168

[21:45] <dalek> rakudo/nom: 6c78f03 | jnthn++ | t/spectest.data:

[21:45] <dalek> rakudo/nom: Run new native array test files.

[21:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c78f03701

[21:45] <lizmat> jnthn

[21:45] <lizmat> ++

[21:45] <masak> when I make typos in my code, Levenshtein taunts me about them :P

[21:45] *** telex left
[21:46] *** telex joined
[21:46] <jnthn> masak: Learn to tpye proper :P

[21:46] <geekosaur> porper?

[21:47] <jnthn> That's the one

[21:47] <lizmat> porperly ?

[21:47] <geekosaur> and porpoisely

[21:48] <masak> porpoisefully

[21:48] <jnthn> dolphinately

[21:49] <masak> meh... orca...

[21:49] <jnthn> :D

[21:53] *** muraiki left
[21:55] *** yqt left
[21:55] *** cognominal joined
[22:02] <lizmat> jnthn: for:

[22:02] <lizmat>        multi method ASSIGN-POS(array:D: Int $idx, $value) {

[22:02] <lizmat>             nqp::bindpos_i(self, $idx, $value)

[22:02] <lizmat>         }

[22:02] <lizmat> isn't there a coercer for $value missing ?

[22:03] <lizmat> otherwise, what's the difference with:

[22:03] <lizmat>         multi method ASSIGN-POS(array:D: Int $idx, int $value) {

[22:03] <lizmat>             nqp::bindpos_i(self, $idx, $value)

[22:03] <lizmat>         }

[22:06] <lizmat> same for the numarray role, BTW

[22:06] *** bayprogrammer left
[22:07] *** adu joined
[22:08] <lizmat> sleep&

[22:14] *** xfix left
[22:15] *** bjz left
[22:15] <FROGGS> hmmm, since 'say (42 for ^2)' works, but 'say my $a = (42 for ^2)' does not I guess it is about:

[22:15] <FROGGS> rakudo/src/vm/jvm/runtime/org/perl6/rakudo/RakudoContainerSpec.java:33:    public void store(

[22:17] *** zby_home_ joined
[22:18] *** bjz joined
[22:21] *** diana_olhovik left
[22:24] <jnthn> lizmat: The one taking a lowercase int is to avoid boxing a native value

[22:24] <[Tux]>   jnthn++

[22:24] <yoleaux> 19:30Z <nine_> [Tux]: Text::CSV_XS can now read from Perl 6 file handles :) Just be sure to open the file with chomp => False.

[22:24] <[Tux]> nine++

[22:24] <jnthn> lizmat: The other one will try to unbox (the code-gen takes care of that) and explode if not, thus serving as the type check.

[22:25] <[Tux]> things to play with this weekend :)

[22:27] *** kaare_ joined
[22:28] *** kst` joined
[22:29] *** kst left
[22:35] *** spider-mario left
[22:41] *** dolmen joined
[22:42] *** adu left
[22:53] *** iv left
[22:54] *** Rounin left
[22:57] <dalek> rakudo/nom: 61ec592 | jnthn++ | t/spectest.data:

[22:57] <dalek> rakudo/nom: Re-enable accidentally disabled spectests.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/61ec5926c5

[23:03] *** tgt left
[23:05] *** pecastro left
[23:13] *** iv joined
[23:14] *** gfldex left
[23:18] *** lea left
[23:19] *** donaldh joined
[23:23] <donaldh> jnthn: I think I've isolated the cause of UnwindException escapes

[23:24] <FROGGS> do tell

[23:25] <jnthn> donaldh: oh? :)

[23:25] <donaldh> runtime exceptions throw sttraight past the 'handle' try/catch block that would be the UnwindException target.

[23:26] <donaldh> So I have hacked up a fix that wraps a handle block in an extra try/catch for Throwable.

[23:26] <donaldh> https://gist.github.com/donaldh/6d1a12182b49fb5947e5

[23:26] <donaldh> If this looks right ish, then I'll clean it up.

[23:28] <donaldh> There may be an altogether better way of dealing with this but I think it would require a bigger dig into QAST/Compiler.nqp

[23:29] <jnthn> donaldh: It seems sane to me, at first glance

[23:30] *** cognominal left
[23:30] <donaldh> So the generated code for a 'handle' op is now try { try { ... } catch (Throwable) { rethrow ControlException or dieInternal(Throwable) } } catch (ControlException) { ... }

[23:30] <donaldh> I'll clean up the names to make it clearer what the inner and outer catches are.

[23:32] <jnthn> It seems like a general fix rather than a hack for a specific problem, so I think it's the right direction.

[23:32] <donaldh> Yes, it's definitely a general problem with the way the 'handle' op generates try/catch code.

[23:34] * donaldh is trying not to get alarmed by the volume of bytecode we generate for simple perl code :-/

[23:38] <jnthn> yay, between the compiler and spesh, "my int @a; my int $i = 0; while $i < 1000000 { @a[$i] = 1; $i = $i + 1; };"

[23:38] <jnthn> ends up fully inlined

[23:39] <donaldh> \o/

[23:39] <jnthn> And JIT compiled

[23:39] <jnthn> Now we "just" need to improve the code quality :)

[23:39] <jnthn> (lots of room for that)

[23:41] *** virtualsue_ joined
[23:42] *** virtualsue left
[23:42] *** virtualsue_ is now known as virtualsue

[23:43] <FROGGS> btw, for the 'my $foo = (42 for ^2)' issue on jvm, RakudoContainerSpec.store gets Nil as the value to store

[23:44] <FROGGS> so it is not store as I thought earlier

[23:46] <jnthn> Yay, and now the thing I pasted above also does zero GCs.

[23:46] <FROGGS> wow

[23:46] <jnthn> profiler++ # telling me useful stuff

[23:47] <donaldh> jnthn++

[23:47] <FROGGS> what's the timing compared to before? do you know?

[23:47] <jnthn> haha... "In total, 204 call frames were entered and exited by the profiled code. Inlining eliminated the need to create 999894 call frames (that's 99.98%)."

[23:47] <FROGGS> hehe

[23:48] *** virtualsue left
[23:48] <jnthn> my int @a; my int $i = 0; while $i < 1000000 { @a[$i] = 1; $i = $i + 1; }; # 0.69s inc startup

[23:48] <jnthn> my @a; my int $i = 0; while $i < 1000000 { @a[$i] = 1; $i = $i + 1; }; # 1.42s inc startup

[23:48] *** espadrine left
[23:49] <jnthn> If you pre-size the array you get 0.39s vs 1.17s fwiw.

[23:50] <FROGGS> ohh, yeah

[23:50] <FROGGS> jnthn++

[23:50] <FROGGS> :o)

[23:50] <FROGGS> btw, we do not presize bufs, so appending a single element is quite costly

[23:51] <FROGGS> I was thinking we should allocate always in 2**n, like we do for other stuff in moar

[23:51] <jnthn> But a Buf is a VMArray underneath, which does the power-of-2?

[23:52] <FROGGS> hmmm, strange

[23:52] <FROGGS> I try to come up with an example this weekend

[23:54] <jnthn> ooh

[23:55] <jnthn> timecmd perl -E "use integer; my @a; $a[9999999] = 0; my $i = 0; while ($i < 10000000) { $a[$i] = 1; $i = $i + 1; }; say scalar(@a)"

[23:55] <jnthn> command took 0:0:1.94 (1.94s total)

[23:55] <jnthn> C:\consulting\rakudo>timecmd perl6-m -e "my int @a; @a[9999999] = 0; my int $i = 0; while $i < 10000000 { @a[$i] = 1; $i = $i + 1; }; say @a.elems"

[23:55] <jnthn> command took 0:0:1.23 (1.23s total)

[23:55] <FROGGS> \o/

[23:56] *** dolmen left
[23:56] <FROGGS> now I can dream of something fast :o)

[23:57] <FROGGS> gnight

[23:57] *** FROGGS left
[23:57] <jnthn> o/

