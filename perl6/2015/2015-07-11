[00:04] <AlexDaniel> STD: loop (my $i = 0; $i <= 5; $i++ {;) { say }

[00:05] <AlexDaniel> std: loop (my $i = 0; $i <= 5; $i++ {;) { say }

[00:05] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/safSS5UdoF line 1:␤------> 3loop (my $i = 0; $i <= 5; $i++ 7⏏5{;) { say }␤    expecting infix or meta-infix␤Parse failed␤F…»

[00:05] *** amurf joined
[00:06] <AlexDaniel> just wondered :)

[00:10] *** amurf left
[00:12] <AlexDaniel> m: loop { last if; }

[00:12] <camelia> rakudo-moar 97ebe4: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'if'␤at /tmp/WSn69KnIQg:1␤------> 3loop { last if7⏏5; }␤Whitespace required after keyword 'if'␤at /tmp/WSn69KnIQg:1␤------> 3loop { last if7⏏5; }␤Whitespace required after keywo…»

[00:13] <AlexDaniel> well, the full error message is here: https://gist.github.com/AlexDaniel/e796877f2f9121f00e3d

[00:13] <AlexDaniel> why does it repeat the same thing four times...

[00:13] <AlexDaniel> and then what, missing semicolon??

[00:15] <AlexDaniel> m: last if;

[00:15] <camelia> rakudo-moar 97ebe4: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'if'␤at /tmp/9QKHPgdooe:1␤------> 3last if7⏏5;␤Whitespace required after keyword 'if'␤at /tmp/9QKHPgdooe:1␤------> 3last if7⏏5;␤Whitespace required after keyword 'if'␤at /tmp/…»

[00:16] <skids> std: loop { last if; }

[00:16] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Confused at /tmp/KVMIRjBWql line 1:␤------> 3loop { last 7⏏5if; }␤    expecting feed_separator␤Parse failed␤FAILED 00:00 136m␤»

[00:17] <AlexDaniel> std: last if;

[00:17] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Confused at /tmp/i3YZNRwtf6 line 1:␤------> 3last 7⏏5if;␤    expecting feed_separator␤Parse failed␤FAILED 00:00 135m␤»

[00:18] <AlexDaniel> again, "confused" is better than "whitespace required" x 4 and "missing semicolon" :)

[00:19] *** vendethiel left
[00:20] <AlexDaniel> another similar issue is this:

[00:20] <AlexDaniel> m: repeat { } while;

[00:20] <camelia> rakudo-moar 97ebe4: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'repeat { } while'␤at /tmp/Eanj3eUe7b:1␤------> 3repeat { } while7⏏5;␤Missing "while" or "until"␤at /tmp/Eanj3eUe7b:1␤------> 3repeat { } while7⏏5;␤    expecting any of:␤     …»

[00:20] <AlexDaniel> or maybe it's not similar, I have no idea

[00:29] <AlexDaniel> it actually says "confused" with "unless"! :)

[00:30] <AlexDaniel> m: say 1 unless;

[00:30] <camelia> rakudo-moar 97ebe4: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'unless'␤at /tmp/wbCz3kvXsp:1␤------> 3say 1 unless7⏏5;␤Whitespace required after keyword 'unless'␤at /tmp/wbCz3kvXsp:1␤------> 3say 1 unless7⏏5;␤Whitespace required after keywo…»

[00:33] <AlexDaniel> std: my $x = 2; if ($x == (2|4|5|"hello"|42|3.14)) { say 1}

[00:33] <camelia> std 28329a7: OUTPUT«ok 00:00 142m␤»

[00:33] <AlexDaniel> m: my $x = 2; if ($x == (2|4|5|"hello"|42|3.14)) { say 1}

[00:33] <camelia> rakudo-moar 97ebe4: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏hello' (indicated by ⏏)␤  in block <unit> at /tmp/zOK68D06z7:1␤␤»

[00:33] <AlexDaniel> well, ok, it makes sense

[00:33] <AlexDaniel> but one of the examples here is wrong: https://en.wikibooks.org/wiki/Perl_6_Programming/Junctions

[00:34] <AlexDaniel> and I'm not sure how to fix that because it seems like the author meant this to work

[00:37] <AlexDaniel> OH, it seems like it talks about perl5

[00:37] <AlexDaniel> ok then

[00:41] <skids> Hrm. Well.  I think it would be better to rewrite it with a different operator because it is not obvious whether that is 5 or 6.

[00:44] <AlexDaniel> skids: or maybe just put a comment. Because, yeah, it confused me a little bit.

[00:44] <AlexDaniel> skids: will you do that?

[00:46] *** leont left
[00:55] *** vendethiel joined
[01:13] <AlexDaniel> m: my %test; %test<> = 25;

[01:13] <camelia> rakudo-moar 97ebe4: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/sfpaumGDdU:1␤␤»

[01:14] <AlexDaniel> what does it mean?

[01:15] *** muraiki left
[01:15] <AlexDaniel> I thought it would be equivalent to %test{''}. It's okay if it's not, but what is this "odd number of elements" thing?

[01:16] <skids> m: %test<>.perl.say

[01:16] <camelia> rakudo-moar 97ebe4: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DOwgomKmgc␤Variable '%test' is not declared␤at /tmp/DOwgomKmgc:1␤------> 3<BOL>7⏏5%test<>.perl.say␤»

[01:16] *** rmgk_ joined
[01:16] *** rmgk is now known as Guest69446

[01:16] *** Guest69446 left
[01:16] *** rmgk_ is now known as rmgk

[01:17] <skids> m: my %test; %test<>.perl.say

[01:17] <camelia> rakudo-moar 97ebe4: OUTPUT«{}<>␤»

[01:17] *** vendethiel left
[01:17] <skids> That might be a GLR problem.

[01:17] <skids> Oh.

[01:18] <AlexDaniel> oh?

[01:18] <skids> m: my %test; %test<> = :a(3);

[01:18] <camelia> rakudo-moar 97ebe4: ( no output )

[01:18] <ShimmerFairy> m: my %a = 1,2,3,4; say %a.perl

[01:18] <camelia> rakudo-moar 97ebe4: OUTPUT«{"1" => 2, "3" => 4}<>␤»

[01:18] *** Hor|zon joined
[01:18] <ShimmerFairy> m: my %a = 1,2,3; say %a.perl

[01:18] <camelia> rakudo-moar 97ebe4: OUTPUT«Odd number of elements found where hash initializer expected␤  in block <unit> at /tmp/bzFbdOIg46:1␤␤»

[01:18] <skids> That empty <> syntax will be going away IIRC.

[01:18] <ShimmerFairy> ^ that's where you usually see that error

[01:19] <AlexDaniel> skids: ok then

[01:22] <skids> but... the error is there for %test{} as well.  Probably should not be, rather behave however () = 25 is supposed to behave.

[01:23] *** Hor|zon left
[01:23] <skids> It is not the same as %test{""} in ether case.

[01:26] <AlexDaniel> m: my %test; %test{} = :a(3); say %test<a>;

[01:26] <camelia> rakudo-moar 97ebe4: OUTPUT«3␤»

[01:26] <AlexDaniel> it looks like it is a feature, not a bug

[01:28] <AlexDaniel> or not

[01:29] <TimToady> a Zen slice just returns the hash, so it's as if it weren't there

[01:29] <skids> Shouldn't a zen slice return the hash *values*?

[01:30] <japhb> m: my $a = 0; my $b := Proxy.new(FETCH => { say "FETCH"; $a }, STORE => -> $, $v { say "STORE"; $a = $v }); $b++;  # Can this FETCH-heaviness be improved?

[01:30] <camelia> rakudo-moar 97ebe4: OUTPUT«FETCH␤FETCH␤FETCH␤FETCH␤FETCH␤FETCH␤FETCH␤FETCH␤STORE␤»

[01:31] <japhb> m: my $a = 0; my $b := Proxy.new(FETCH => { say "fetch"; $a }, STORE => -> $, $v { say "STORE"; $a = $v }); $b++;  # Can this FETCH-heaviness be improved?  # Just for readability

[01:31] <camelia> rakudo-moar 97ebe4: OUTPUT«fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤fetch␤STORE␤»

[01:31] <skids> ISTR it was worse a one point, so maybe?

[01:32] <japhb> skids: Well, I suppose that's promising, but 8:1 is kinda brutal

[01:33] *** atroxaper joined
[01:33] *** bin_005_v left
[01:33] <japhb> This combined with having a Proxy in front of an event-sourced object makes for a LOT of event replays.

[01:34] *** bin_005_v joined
[01:37] *** atroxaper left
[01:38] <TimToady> no, slicing with * returns all the values, whereas a Zen slice is essentially 0-dimensional, not 1-dimensional

[01:54] *** bin_005_v left
[01:55] *** amurf joined
[01:59] *** amurf left
[02:06] *** Exodist left
[02:07] *** gfldex left
[02:09] *** Exodist joined
[02:14] *** noganex_ joined
[02:16] *** adu joined
[02:18] *** noganex left
[02:26] *** nebuchadnezzar left
[02:26] *** nebuchadnezzar joined
[02:26] *** kanl joined
[02:27] *** vike left
[02:27] *** aborazmeh joined
[02:27] *** aborazmeh left
[02:27] *** aborazmeh joined
[02:28] *** vike joined
[02:31] *** tinyblak joined
[03:03] *** colomon left
[03:07] *** Hor|zon joined
[03:12] *** Hor|zon left
[03:16] *** aborazmeh left
[03:28] *** pecastro left
[03:33] *** AlexDaniel left
[03:41] *** nys left
[04:09] *** tinyblak left
[04:23] *** khw left
[04:35] *** vendethiel joined
[04:56] *** Hor|zon joined
[04:58] *** tinyblak joined
[04:59] *** vendethiel left
[04:59] *** tinyblak_ joined
[04:59] *** tinyblak left
[05:00] *** Hor|zon left
[05:06] *** atroxaper joined
[05:11] *** atroxaper left
[05:12] *** raiph left
[05:12] *** bjz joined
[05:18] *** kaare_ joined
[05:26] *** lolisa joined
[05:32] *** amurf joined
[05:37] *** amurf left
[05:43] *** Psyche^_ joined
[05:47] *** Psyche^ left
[05:54] *** Alina-malina joined
[05:57] *** Peter_R left
[05:59] *** Peter_R joined
[06:11] *** firefish5000 joined
[06:14] *** aindilis left
[06:14] *** rurban joined
[06:15] *** rurban1 joined
[06:32] *** adu left
[06:42] *** rurban left
[06:45] *** Hor|zon joined
[06:47] *** isBEKaml joined
[06:48] *** RabidGravy joined
[06:48] <RabidGravy> marnin!

[06:50] *** Hor|zon left
[06:50] *** rurban joined
[06:53] <kanl> m: ( 3 <=> 5 ) but False

[06:53] <camelia> rakudo-moar 97ebe4: OUTPUT«Method 'mixin' not found for invocant of class 'Perl6::Metamodel::EnumHOW'␤  in block <unit> at /tmp/Y6qkSTxCrf:1␤␤»

[06:53] <kanl> m: +( 3 <=> 5 ) but False

[06:53] <camelia> rakudo-moar 97ebe4: ( no output )

[06:55] *** rurban left
[07:01] <dalek> rakudo-star-daily: f136d62 | coke++ | log/ (9 files):

[07:01] <dalek> rakudo-star-daily: today (automated commit)

[07:01] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/f136d62d0a

[07:01] <dalek> perl6-roast-data: fa45248 | coke++ | / (9 files):

[07:01] <dalek> perl6-roast-data: today (automated commit)

[07:01] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fa45248a41

[07:02] *** rurban joined
[07:07] <[Coke]> back up to 1028 tickts

[07:07] *** rurban left
[07:07] <[Coke]> m: my @a = 42; try { @a.clone }; say "alive"

[07:07] <camelia> rakudo-moar 97ebe4: OUTPUT«This type does not support elems␤  in block <unit> at /tmp/GLcvuSsdXl:1␤␤»

[07:08] <[Coke]> m: my @a = 42; try { @a.clone; CATCH { default {} } }; say "alive"

[07:08] <camelia> rakudo-moar 97ebe4: OUTPUT«alive␤»

[07:08] *** skids left
[07:09] <[Coke]> cd t/spec

[07:15] *** rurban joined
[07:15] *** darutoko joined
[07:15] <[Coke]> m: my $σ0;

[07:15] <camelia> rakudo-moar 97ebe4: ( no output )

[07:18] *** daxim left
[07:29] <dalek> rakudo/nom: 5a6a672 | moritz++ | lib/Pod/To/Text.pm:

[07:29] <dalek> rakudo/nom: Pod::To::Text: Avoid concatenationg Nils

[07:29] <dalek> rakudo/nom: 

[07:29] <dalek> rakudo/nom: see https://github.com/perl6/doc/issues/92, kmetcalf++

[07:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a6a67237f

[07:37] *** virtualsue joined
[07:44] *** daxim joined
[07:44] *** ely-se joined
[07:44] <ely-se> hi

[07:45] <moritz> hi ely-se 

[07:46] <ely-se> haven't done anything with Perl 6 since ages :p

[07:46] *** Hor|zon joined
[07:48] <moritz> time to start again

[07:48] <ely-se> yes!

[07:51] *** Hor|zon left
[07:52] *** lizmat left
[07:52] <ely-se> p6: (1, 2, 3, (4, 5, 6)).map(*.perl).perl.say

[07:52] <camelia> rakudo-moar 5a6a67: OUTPUT«("1", "2", "3", "(4, 5, 6)")␤»

[07:52] <ely-se> p6: .perl.say for (1, 2, 3, (4, 5, 6))

[07:52] <camelia> rakudo-moar 5a6a67: OUTPUT«1␤2␤3␤(4, 5, 6)␤»

[07:52] <ely-se> I can love Perl 6 again! :D

[07:52] *** lizmat joined
[08:01] *** ShimmerFairy left
[08:06] *** virtualsue_ joined
[08:06] *** virtualsue left
[08:06] *** virtualsue_ is now known as virtualsue

[08:10] *** atroxaper joined
[08:15] *** atroxaper left
[08:15] *** ShimmerFairy joined
[08:16] *** vendethiel joined
[08:25] *** virtualsue left
[08:25] *** virtualsue joined
[08:26] *** diana_olhovik_ joined
[08:27] *** lolisa left
[08:44] *** RabidGravy left
[08:55] *** FROGGS joined
[08:57] <FROGGS> o/

[09:01] *** ely-se left
[09:05] <masak> antenoon, #perl6

[09:09] <mst> moin

[09:09] <vendethiel> \o

[09:10] *** amurf joined
[09:13] <dalek> rakudo/nom: 200c544 | lizmat++ | src/core/List.pm:

[09:13] <dalek> rakudo/nom: Handle :SINK properly

[09:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/200c5446fb

[09:13] *** diana_olhovik_ left
[09:14] <dalek> roast: ae69ea0 | lizmat++ | S32-array/splice.t:

[09:14] <dalek> roast: Add some more natives and :SINK testing

[09:14] <dalek> roast: review: https://github.com/perl6/roast/commit/ae69ea001e

[09:14] *** amurf left
[09:16] *** breinbaa1 joined
[09:16] <lizmat> good *, #perl6!

[09:16] <yoleaux> 10 Jul 2015 23:02Z <skids> lizmat: proceed resumes matching when clauses.  Also that code is temporary and we'll just throw those once .assuming has burned it wrt ecosystem falout.

[09:18] *** ely-se joined
[09:19] <lizmat> afk again&

[09:20] *** rurban1 left
[09:21] *** mudguts joined
[09:21] <mudguts> Good whatever, perl6

[09:21] <[TuxCM]> 45.7/45.0

[09:22] *** rurban1 joined
[09:23] <mudguts> I was tinkering a bit with jnthn++'s nqp guts course and have a minor ops question...

[09:23] *** rurban left
[09:24] <mudguts> I'm sure the problem is not the code per se... (this is for exercises 4 & % (white basic php echo and friends)

[09:25] <mudguts> ..as it works whenever I use the REPL loop

[09:26] <mudguts> whenever i want the thing to run on a file, I get Too many positionals passed; expected 0 arguments but got 1    at e3.php:1  (<ephemeral file>::0)

[09:26] <mudguts> code is here: https://github.com/edumentab/rakudo-and-nqp-internals-course/blob/master/solutions/exercise-4.nqp

[09:27] <mudguts> I'm trying this command: nqp-m php_ex5.nqp test3.php

[09:28] <mudguts> If someone could simply download the code from that link and try the command and confirm the problem is not local to me, I would be grateful

[09:30] <mudguts> test3.php has: echo "hello world"   in it

[09:30] <ely-se> needs semicolon

[09:31] <moritz> mudguts: please try to run it with nqp-m --ll-exception

[09:31] <ely-se> echo statements in PHP must be terminated by semicolons. also needs <?php otherwise the text will be printed

[09:33] <mudguts> thanks ely-se but no cigar - this isn't real php: just playin... the grammar allows optional semi on last statement

[09:33] <ely-se> ok :p

[09:33] <ely-se> I don't smoke anyway so I don't mind.

[09:33] <mudguts> moritz: no diff with $ nqp-m phpv5.nqp --ll-exception e3.php           Too many positionals passed; expected 0 arguments but got 1    at e3.php:1  (<ephemeral file>::0)

[09:34] <mudguts> hang on...

[09:35] *** Hor|zon joined
[09:35] <mudguts> nope:  nqp-m --ll-exception phpv5.nqp e3.php

[09:36] <mudguts> (same error) does it work everywhere else?

[09:40] <mudguts> Anyone willing to try it?  Simple: Download into file (say "php_ish.nqp") from this link: https://github.com/edumentab/rakudo-and-nqp-internals-course/raw/master/solutions/exercise-4.nqp

[09:40] *** Hor|zon left
[09:41] <mudguts> then:  echo 'echo "hello world"' > ex3.php  (to create a 1 line php program)

[09:42] <mudguts> asumming you have rakudobrew, then:  nqp-m php_ish.nqp e3.php

[09:42] *** mtj_- joined
[09:42] <mudguts> where as "cat e3.php | nqp-m php_ish.nqp"  will work fine

[09:43] <masak> "we in the JavaScript world have a higher tolerance for nonsense and dreck." -- "Discoverability is often cited as npm’s biggest flaw." -- https://medium.com/@Rich_Harris/small-modules-it-s-not-quite-that-simple-3ca532d65de4 -- sounds to me exactly like what people say about CPAN.

[09:43] <masak> metacpan++ has really helped there, I think. but discoverability *is* really hard.

[09:43] <mudguts> :-)

[09:43] <masak> and 90% of everything truly is crap.

[09:44] <ely-se> npm is wonderful except for one single thing which is that packages are all in the same namespace.

[09:44] <ely-se> other than that it's absolutely the best package manager I've ever used

[09:44] *** TEttinger left
[09:45] <mudguts> .oO Did I typo nqp/npm ??

[09:46] <masak> no, I was just talking about something else entirely.

[09:46] *** shmibs_ joined
[09:47] <ely-se> I'd rate Maven №1 if it were faster

[09:48] <masak> that's the first good thing I've heard anyone say of Maven, I think.

[09:49] *** shmibs left
[09:49] * moritz could never get npm to work on Debian (with the pre-packaged npm, that is)

[09:50] <masak> apparently you're supposed to install it using something called `nvm` these days. I don't even.

[09:51] <kanl> m: sub foo { my $a = 'FOO'; return( +$a andthen $a orelse Nil ) }

[09:51] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NaelvaRnVC␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/NaelvaRnVC:1␤------> 3sub foo { my $a = 'FOO'; return( +$a7⏏5 andthen $a orelse Nil ) }␤    expecting any o…»

[09:51] <kanl> m: sub foo { my $a = 'FOO'; return ( +$a andthen $a orelse Nil ) }

[09:51] <camelia> rakudo-moar 200c54: ( no output )

[09:52] <kanl> why is the whitespace necessary?

[09:52] *** spider-mario joined
[09:53] <masak> kanl: because without the space there, the inside of the parens parses as an argument list.

[09:54] <masak> kanl: and `+` does not parse in argument lists.

[09:55] *** mudguts left
[09:55] <ShimmerFairy> masak: 1) I thought it was because lack of whitespace made return look like a function call, and 2) seriously? How have I not run into that before? O_o

[09:56] <masak> ShimmerFairy: return is a function call.

[09:56] <ShimmerFairy> Huh, I thought it was just a keyword

[09:57] <masak> m: sub foo { return("OH HAI") }; say foo

[09:57] <camelia> rakudo-moar 200c54: OUTPUT«OH HAI␤»

[09:57] <masak> nope. function.

[09:57] <kanl> m: sub foo { my $a = '2'; return( +$a ) }

[09:57] <camelia> rakudo-moar 200c54: ( no output )

[09:57] <masak> m: say &return ~~ Callable

[09:57] <camelia> rakudo-moar 200c54: OUTPUT«True␤»

[09:57] <kanl> m: sub foo { my $a = '2'; return( +$a, +$a, +$a ) }

[09:57] <camelia> rakudo-moar 200c54: ( no output )

[09:58] <ShimmerFairy> masak: you should explain better, because what you said makes it sound like stuff like foobar(+@list) shouldn't work, which is obviously false.

[09:58] *** rindolf joined
[09:58] <masak> kanl: oh, sorry. it's not the '+' that's unparseable, apparently.

[09:58] <masak> kanl: it's that `andthen` is so loose it can't work inside an argument list.

[09:59] <ely-se> IMO such shenanigans indicate a flaw in the language design.

[09:59] <masak> uh? `andthen` has precendence looser than comma. how do you envision that working inside an arglist, then?

[10:01] <ShimmerFairy> Still feels like a design flaw for  foobar($a andthen $b)  to be treated as something that can't possibly have a correct interpretation

[10:01] <moritz> why not use foobar($a && $b) ?

[10:02] <masak> well, `andthen` *does* have slightly different semantics.

[10:02] <masak> but it's still something I would never be tempted to use inside of an arglist.

[10:03] <kanl> moritz:  because +'FOO' produces a (Failure), so && won't work.

[10:03] <masak> actually, I'll widen that and say I'm generally not tempted to use `andthen` inside an expression. that's not how I think of it, or how Perl 6 expected you to think of it.

[10:03] <ShimmerFairy> moritz: yeah, I was thinking && and || would be better choices in this case, at a glance (or ?? !! , since I think that's what's being attempted)

[10:03] <ely-se> what's the diff between && and andthen? is the former strict and the latter lazy like in Erlang?

[10:03] <masak> kanl: sounds like `//` is for you, then.

[10:03] <masak> ely-se: besides `andthen` being much looser in precedence, it also sets $_ to the lhs

[10:03] <masak> ely-se: (NYI)

[10:04] <ShimmerFairy> masak: sure, and I still don't understand andthen or orelse well enough to argue, I'm just saying  foobar($a andthen $b)  *looks* like it shouldn't fail the parser :)

[10:04] <ely-se> masak: oh ok

[10:04] <ShimmerFairy> the looser version of && is 'and', || -> or, and so on, IIRC

[10:05] <kanl> moritz: that didn't occur to me, thanks :)

[10:06] <ely-se> sometimes I think Perl 6 is feature creep and will collapse under its own weight

[10:06] *** leont joined
[10:07] <masak> ely-se: Perl 6 doesn't try to be minimal, for sure.

[10:10] <ab5tract_> m: sub foo { my @a = '2' xx 6; return( +@a, +@a, +@a ) }; say foo; # this isn't supposed to work? why?

[10:10] <camelia> rakudo-moar 200c54: OUTPUT«6 6 6␤»

[10:10] *** bjz left
[10:11] *** tgt joined
[10:11] <masak> ab5tract_: no, I was wrong about that.

[10:11] <ab5tract_> masak: phew :)

[10:11] <masak> ab5tract_: it's `andthen` that fails, not `+`

[10:11] *** gfldex joined
[10:13] *** colomon joined
[10:15] <ab5tract_> m: constant BIGGENER = * * * * *; sub f(*@x) { ::BIGGENER(@x) }; say f(3,3,3)

[10:15] <camelia> rakudo-moar 200c54: OUTPUT«Too few positionals passed; expected 3 arguments but got 1␤  in whatevercode  at /tmp/_IRRCbWsU7:1␤  in sub f at /tmp/_IRRCbWsU7:1␤␤»

[10:16] <masak> |

[10:16] <ab5tract_> no combination of 'flat @x', or [email@hidden.address] or anything else I have tried will make that work

[10:16] <masak> m: constant BIGGENER = * * * * *; sub f(*@x) { BIGGENER(|@x) }; say f(3,3,3)

[10:16] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VXZHAJuVIL␤Variable '&BIGGENER' is not declared␤at /tmp/VXZHAJuVIL:1␤------> 3tant BIGGENER = * * * * *; sub f(*@x) { 7⏏5BIGGENER(|@x) }; say f(3,3,3)␤»

[10:16] <ab5tract_> masak: oooo

[10:16] <masak> m: constant BIGGENER = * * * * *; sub f(*@x) { ::BIGGENER(|@x) }; say f(3,3,3)

[10:16] <camelia> rakudo-moar 200c54: OUTPUT«27␤»

[10:16] <ab5tract_> that works, thanks

[10:16] <masak> m: constant &BIGGENER = * * * * *; sub f(*@x) { BIGGENER(|@x) }; say f(3,3,3)

[10:16] <camelia> rakudo-moar 200c54: OUTPUT«27␤»

[10:17] *** bjz joined
[10:17] <ab5tract_> but after the GLR, the @x will flatten automatically?

[10:18] <masak> pshwaughml.

[10:18] <ab5tract_> masak: ah, nice! I should have realized that declaring the constant as a sub would be one way to obviate the compile-order issue

[10:19] <masak> & means 'Callable', but yes.

[10:20] <ab5tract_> in fact, I hope not.. It would be great to pass @x around discretely. Otherwise we are kind of back in the same situation as p5, where you will need to itemize (in p5, reference) all your args anyway

[10:20] <ab5tract_> masak: ah yes, an important distinction, it's true

[10:20] <masak> m: constant &BIGGENER = * * * * *; say &BIGGENER ~~ Sub; say &BIGGENER.^name

[10:20] <camelia> rakudo-moar 200c54: OUTPUT«False␤WhateverCode␤»

[10:21] <ab5tract_> yuo'

[10:21] <ab5tract_> yup

[10:21] <ab5tract_> but declaring it as Callable means that the compiler can parse the sub declaration even though BIGGENER hasn't gotten "fleshened" into a Callable yet

[10:22] <ab5tract_> or, that's the way my hangover is leading me to see it, anyway ;)

[10:22] *** geekosaur left
[10:22] *** bjz left
[10:23] <masak> it's more about namespaces. putting a & in the declaration means you can use the `ident()` syntax wihtout the &

[10:23] *** geekosaur joined
[10:23] <masak> not putting a & means you have to go look for it in the package, so ::

[10:23] *** bjz joined
[10:23] <masak> one way to understand that is to say that `ident()` is really syntactic sugar for `&ident()`

[10:26] <ab5tract_> masak: interesting, thanks

[10:26] *** tgt left
[10:27] <ab5tract_> yeah, it's clear after poking that this is not WhateverCode specific :)

[10:32] <dalek> specs: 29284f1 | (Stéphane Payrard)++ | S99-glossary.pod:

[10:32] <dalek> specs: PEG (as seen in S05)

[10:32] <dalek> specs: review: https://github.com/perl6/specs/commit/29284f1a27

[10:43] *** virtualsue_ joined
[10:45] *** virtualsue left
[10:45] *** virtualsue_ is now known as virtualsue

[10:47] *** telex left
[10:48] *** telex joined
[10:54] *** FROGGS left
[10:55] *** FROGGS joined
[11:02] *** tinyblak joined
[11:04] *** ely-se left
[11:05] *** diana_olhovik_ joined
[11:05] *** tinyblak_ left
[11:08] *** ely-se joined
[11:17] *** Psyche^ joined
[11:19] *** Psyche^_ left
[11:21] *** Hor|zon joined
[11:23] *** virtualsue left
[11:26] *** Hor|zon left
[11:29] *** TimToady left
[11:30] *** TimToady joined
[11:45] *** diana_olhovik_ left
[11:46] *** atroxaper joined
[11:51] *** atroxaper left
[11:55] <timotimo> .tell skids moritz is keeping https://github.com/moritz/perl6-all-modules

[11:55] <yoleaux> timotimo: I'll pass your message to skids.

[12:09] *** Ven joined
[12:15] *** pecastro joined
[12:23] *** rindolf left
[12:29] *** nys joined
[12:33] <ely-se> botsnack

[12:36] *** brrt joined
[12:37] *** Hor|zon joined
[12:40] <moritz> .botsnack

[12:40] <yoleaux> :D

[12:41] *** Hor|zon left
[12:43] <ely-se> :(

[12:47] *** amurf joined
[12:52] *** amurf left
[12:55] *** lucasb joined
[13:05] *** espadrine_ joined
[13:05] <cognominal> reading sources I wonder what is a typevar scope. Probably a scope for a type?

[13:07] <cognominal> seems related to genericity

[13:07] *** bjz left
[13:10] *** bjz joined
[13:16] <[TuxCM]> «self.foo(|%hash)» to invoke «method foo (*@f is copy) {» does not seem to work (anymore)

[13:16] <[TuxCM]> do I need a map with .kv or some such?

[13:16] *** AlexDaniel joined
[13:17] <moritz> [TuxCM]: self.foo(|%hash) interpolates %hash as named arguments

[13:17] <moritz> |%hash.list should work

[13:18] <moritz> m: my %h = a => 1; sub f(*@pos, *%named) { say @pos.perl, %named.perl }; f |%h; f |%h.list;

[13:18] <camelia> rakudo-moar 200c54: OUTPUT«[]<>{:a(1)}<>␤[:a(1)]<>{}<>␤»

[13:18] * moritz hates the []<> notation

[13:19] <lucasb> m: < ><><><><><><><><><><>  # :D

[13:19] <camelia> rakudo-moar 200c54: ( no output )

[13:22] <cognominal> lucasb: is this intended as proof of Perl 6 seminality?

[13:23] <lucasb> cognominal: just kidding :)

[13:23] *** aborazmeh joined
[13:23] *** aborazmeh left
[13:23] *** aborazmeh joined
[13:35] *** brrt left
[13:38] *** mohij joined
[13:42] *** tinyblak left
[13:42] *** aborazmeh left
[13:42] *** raiph joined
[13:52] <timotimo> cognominal: typevars are scoped to roles, for example

[13:52] <timotimo> if you have role Foo[T] { ... } then inside { } the T is scoped

[13:55] <cognominal> that now makes sense to me, timotimo++

[13:55] <timotimo> it's an optimization; it can be treated as if it were lexical

[13:57] <lucasb> An interesting thing to me is that, iirc, Python and Ruby use * and ** both to pack and unpack arrays/hashs in method definitions/calls and assignments. P6 uses *@a and *%h in sub definitions to "pack" the incoming args, but uses prefix:<|> to unpack them in sub calls. But differently, it also uses (|c) to capture a Capture in sub definitions.

[13:57] <lucasb> I'm just saying how I currently understand things, please correct if I'm wrong. Any plans in the future for prefix:<|> also work outside arglists? I guess this relates very strongly with the flattening/non-flattening contexts, after all the "|" operator can be seen as flattening thing, can't it?

[14:01] *** firefish5000 left
[14:07] <[TuxCM]> is there *any* way that I can check if a method is called in void context?

[14:08] *** ely-se left
[14:08] <timotimo> you can see if the value you return gets .sink called on it

[14:09] <[TuxCM]> how?

[14:09] <[TuxCM]> the method can return a lot of different things

[14:10] <timotimo> you can mix in a role for that

[14:10] <timotimo> return $value but role { method sink { say "aha! void context!" } }

[14:12] <[TuxCM]> that wont, work for me, as I need to change something halfway the method if called in void context

[14:13] <[TuxCM]> method foo () { my $x = 0; ...... ; if (void) { $x++; } ... ; return something; }

[14:14] <timotimo> i don't think it's possible. we have a few places in core where we've changed the code-gen to supply SINK => True, but strictly only for optimizations

[14:15] *** silug left
[14:15] <vendethiel> [TuxCM]: sorry, but: "why?"

[14:16] *** rindolf joined
[14:16] <[TuxCM]> the default  for the $out attribute of this method is depending on the combination of all other attributes

[14:17] <[TuxCM]> and in two cases, the default should be to use $*OUT instead of returning a value

[14:17] <[TuxCM]> and those two cases are only true in void context

[14:17] <vendethiel> [TuxCM]: sounds like DWIM gone awry to me :(

[14:18] <[TuxCM]> so «foo (...., out =>$*OUT);» can be written as «foo (...);»

[14:18] <vendethiel> m: my $*foo = 1; say :$*foo;

[14:18] <camelia> rakudo-moar 200c54: OUTPUT«Unexpected named parameter 'foo' passed␤  in block <unit> at /tmp/JJnsa6KSBu:1␤␤»

[14:18] <vendethiel> m: my $*foo = 1; say (:$*foo);

[14:18] <camelia> rakudo-moar 200c54: OUTPUT«foo => 1␤»

[14:18] <[TuxCM]> whereas «my $foo = self.foo (..., out => $*OUT);» makes no sense

[14:18] *** tinyblak joined
[14:19] <vendethiel> [TuxCM]: well, first off, you can write that foo(:$*OUT); :P (but you'll need to be careful at that OUT/out, I guess :(.)

[14:19] <[TuxCM]> out can be a filename or a supply

[14:20] <[TuxCM]> or Hash (return content as Hash) or Array (return content as Array)

[14:22] *** khw joined
[14:22] *** grondilu joined
[14:22] <grondilu> I'm wrinting P5 code and I miss so many things.

[14:23] <grondilu> (from P6 I mean)

[14:23] <grondilu> for instance I'm wondering what's the best equivalent of a Pair in P5

[14:24] <grondilu> I could use [$pair, $value] but meh

[14:24] *** rurban1 left
[14:24] <[TuxCM]> pack

[14:24] <grondilu> earlier I meant [$key, $value] of course

[14:25] *** firefish5000 joined
[14:26] *** Hor|zon joined
[14:27] <[TuxCM]> sub foo (Int $i) { $i - 1; }; $class.bar (foo => &foo); # works great

[14:28] <[TuxCM]> $class.bar (foo => sub (Int $i) { $i - 1; }); # Unable to parse expression in argument list; couldn't find final ')'

[14:28] <[TuxCM]> can I pass an anonymous sub with a signature?

[14:29] *** silug joined
[14:31] *** Hor|zon left
[14:31] <vendethiel> [TuxCM]: the issue is "$class.bar"

[14:31] <vendethiel> bar 1; is okay, but for methods, it's $class.bar: 1;

[14:32] * [TuxCM] doesn't get it

[14:33] <moritz> m: class A { method bar(:&foo) { foo 42 } }; A.bar( foo => sub (Int $i ) { $i - 1 } );

[14:33] <camelia> rakudo-moar 200c54: ( no output )

[14:33] <vendethiel> m: class A{ method f($n) { $n }}; my A $a .= new; $a.f 1; # doesn't parse

[14:33] <moritz> works fine.

[14:33] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/BA5FEYNVQv␤Two terms in a row␤at /tmp/BA5FEYNVQv:1␤------> 3thod f($n) { $n }}; my A $a .= new; $a.f7⏏5 1; # doesn't parse␤    expecting any of:␤        infix␤        infix stopper␤        s…»

[14:33] <[TuxCM]> https://gist.github.com/Tux/d7f5afd66fea7eecc686

[14:33] <vendethiel> m: class A{ method f($n) { $n }}; my A $a .= new; $a.f: 1; # with the colon, does parse

[14:33] <camelia> rakudo-moar 200c54: ( no output )

[14:34] <moritz> $r<legs > 70;

[14:34] <vendethiel> [TuxCM]: ^

[14:34] <moritz> looks wrong

[14:34] <moritz> $r.legs > 70?

[14:34] <moritz> or $r<leg> > 70 ?

[14:35] <[TuxCM]> $r<legs> > 70

[14:35] <moritz> also, when debugging syntax errors, try without Slang::Tuxic

[14:35] <[TuxCM]> but that doesn't change

[14:35] <[TuxCM]> and with or without the lone $ it keeps failing to parse

[14:36] <vendethiel> m: sub $ ($){};#wut lone $ as a name?

[14:36] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/MyefbDuP2e␤Missing block␤at /tmp/MyefbDuP2e:1␤------> 3sub7⏏5 $ ($){};#wut lone $ as a name?␤    expecting any of:␤        new name to be defined␤»

[14:36] <vendethiel> [TuxCM]: I think you should fix those two (the "sub $" and the $<legs >")

[14:36] <moritz> m: sub ($) { }; # should work

[14:36] <camelia> rakudo-moar 200c54: ( no output )

[14:37] <vendethiel> moritz: "     filter  => sub $ (CSV::Row $r) {"

[14:37] <moritz> vendethiel: yes

[14:37] *** amurf joined
[14:37] <vendethiel> that's obviously wrong

[14:38] <[TuxCM]> I fixed both (I think) : https://gist.github.com/Tux/0e429983a6dd84f87ef3

[14:39] *** skids joined
[14:39] <vendethiel> m: sub f(&){}; f (x => sub (Int $){$<foo> > 5;})

[14:39] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NtTtVlbThl␤Calling f(Pair) will never work with declared signature (&)␤at /tmp/NtTtVlbThl:1␤------> 3sub f(&){}; 7⏏5f (x => sub (Int $){$<foo> > 5;})␤»

[14:39] <vendethiel> m: sub f(Pair){}; f (x => sub (Int $){$<foo> > 5;})

[14:39] <camelia> rakudo-moar 200c54: ( no output )

[14:40] <vendethiel> m: module A {class B {}}; sub f(Pair){}; f (x => sub (A::B $){5;})

[14:40] <camelia> rakudo-moar 200c54: ( no output )

[14:40] <lizmat> good *, #perl6!

[14:40] <vendethiel> o/, lizmat!

[14:40] <[TuxCM]> o/ lizmat 

[14:41] <lizmat> m: my $s = Supply.new; $s.emit($_) for ^10; .print for gather $s.act: { take $_ }   # how does the gather know that the supply is done?

[14:41] <camelia> rakudo-moar 200c54: OUTPUT«0123456789»

[14:41] <lizmat> I would expect this to hang, or not print anything

[14:41] <vendethiel> m: module A {class W {}}; sub f(Pair){}; f (x => sub (A::W $r){5;})

[14:41] <camelia> rakudo-moar 200c54: ( no output )

[14:41] *** amurf left
[14:42] <vendethiel> m: module CSV {class Row {}}; sub csv(*%){}; csv (in      => "legs.csv", out     => $*OUT, headers => "auto", filter  => sub (CSV::Row $r) { $r<legs> > 70; });

[14:42] <camelia> rakudo-moar 200c54: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub csv at /tmp/FKpit4EAge:1␤  in block <unit> at /tmp/FKpit4EAge:1␤␤»

[14:42] <vendethiel> m: module CSV {class Row {}}; sub csv(@){}; csv (in      => "legs.csv", out     => $*OUT, headers => "auto", filter  => sub (CSV::Row $r) { $r<legs> > 70; });

[14:42] <camelia> rakudo-moar 200c54: ( no output )

[14:43] <vendethiel> I might blame Slang::Tuxic :)

[14:43] <lizmat> hmmm... I figured it out, I think

[14:43] <[TuxCM]> damn. that didn't even spring to mind as a possibility

[14:44] <lizmat> it's the buffering before first tap :-(

[14:45] <[TuxCM]> vendethiel, «     filter  => sub f (CSV::Row $r) { » works fine

[14:45] <[TuxCM]> (add the singe f)

[14:45] <vendethiel> [TuxCM]: I guess you can use "sub ::"

[14:46] <moritz> or 'anon sub f'

[14:46] * vendethiel doesn't like to name anonymous things :)

[14:47] <moritz> very handy for when you introspect the anon thing

[14:47] <[TuxCM]> both alternatives work fine! (anon sub f and sub ::)

[14:47] *** isBEKaml left
[14:48] <vendethiel> oooh, I get it.

[14:48] <vendethiel> m: sub();

[14:48] <camelia> rakudo-moar 200c54: OUTPUT«5===SORRY!5=== Error while compiling /tmp/O0KBg8Zcq1␤Undeclared routine:␤    sub used at line 1␤␤»

[14:48] <vendethiel> right. and here, slang::tuxic sees the space and thinks "hey, I'm right here to handle that call!"

[14:50] <vendethiel> FROGGS: ^. I think that's the only perl6 construct that goes "(){}"?

[14:55] <lucasb> use Slang::Tuxic; sub (Int $x) {}  #=> Unable to parse expression in argument list; couldn't find final ')'

[14:55] <vendethiel> found the culprit! :P

[14:58] <[TuxCM]> and now the fix :)

[15:21] *** skids left
[15:22] *** atroxaper joined
[15:27] *** atroxaper left
[15:30] *** RabidGravy joined
[16:06] <FROGGS> we just need to specialcase 'sub'

[16:07] <TimToady> .oO(lists of exceptions, where have I heard that before...)

[16:08] <FROGGS> ohh, we do not specialcase keywords at all yet :/

[16:08] <FROGGS> TimToady: :P

[16:08] <FROGGS> I'm only the maker, not a user of Slang::Tuxic :o)

[16:10] <TimToady> it's officially okay to extend Perl 6 into a non-extensible language :P

[16:11] *** domidumont joined
[16:12] *** Hor|zon joined
[16:12] <FROGGS> every modification to Perl 6 in user space if of course one step in the direction of non-perfectness :o)

[16:13] <jnthn> i can haz messages?

[16:13] <jnthn> ...nope!

[16:13] <FROGGS> :P

[16:14] <jnthn> From backlog: I think we need some kind of type representing strings from the file system, environment, etc.

[16:14] <FROGGS> O.o

[16:15] <FROGGS> what should it do? guess the encoding?

[16:15] <FROGGS> (I've not backlogged)

[16:15] <jnthn> Be byte-based and preserve the exact value, and offer coercion to Str that could guess...

[16:15] <FROGGS> ahh

[16:16] <FROGGS> yeah

[16:16] <jnthn> But I guess it might have to be viral

[16:16] *** domidumont left
[16:16] *** domidumont joined
[16:16] <jnthn> Since if you do $str-from-file-system ~ '.bak' then we know the '.bak' bit is safe, but the other bit may not be

[16:16] *** Hor|zon left
[16:17] <jnthn> Anyway, guess it needs some pondering/prototyping

[16:20] <TimToady> kinda related to the notion of tainting as well

[16:21] <TimToady> and possibly to detecting DoS attacks on NFG

[16:22] <TimToady> assuming the viral strings track their source

[16:23] <vendethiel> jnthn: maybe tainting as well?

[16:23] <vendethiel> oh my... whoops...

[16:23] <TimToady> :)

[16:23] <TimToady> at least you highlit him

[16:23] <vendethiel> .oO( Look at me, I can backlog! Wait, there's more? )

[16:24] <jnthn> Has taining been an actual success story in Perl 5? I don't really see/hear about it much.

[16:25] <jnthn> It was certainly in the "stuff I was figuring could go to module space"...

[16:25] * vendethiel only learned about tainting from his perl book

[16:25] <TimToady> well, people tend not to blame the language when there's an injection attack, even if they should

[16:26] <jnthn> True, though I'd have thought providing quoting slangs that can follow the target language's syntax rules might be a more promising approach...

[16:27] <vendethiel> say no to string programming :P

[16:27] <ShimmerFairy> .oO(Then why do I keep hearing complaints about PHP? :P)

[16:27] <vendethiel> oh, fglock has been adding java support to perlito5. interesting

[16:28] <vendethiel> .oO( "Java is not the enemy" - said someone from the Perl community around year 2000 )

[16:29] <leont> Tainting is a secutity-in-depth feature

[16:29] <leont> security even

[16:29] <leont> If you need it you already have a bug, but it can often prevent those bugs

[16:30] <leont> It would probably be better if you could specify what to protect against, the environmental protections (e.g having to explicitly set PATH to run system) don't make sense on a webserver, for example

[16:31] *** smls joined
[16:31] <smls> o/

[16:32] *** dustinm` left
[16:34] *** dustinm` joined
[16:39] <smls> Remind me: What do I have to write instead of :16<ff> if I have "ff" in a variable?

[16:39] <smls> perl -E 'say hex("ff")'  # can only remember the Perl 5 version

[16:40] <smls> :16«$n» and :16($n) don't work

[16:41] <TimToady> m: my $n = "ff"; say :16($n)

[16:41] <camelia> rakudo-moar 200c54: OUTPUT«255␤»

[16:41] <TimToady> in what sense does that not work?

[16:41] <smls> huh

[16:42] <smls> in the sense that I must have made a mistake when testing it :P

[16:42] * TimToady guesses you tryied passing 0xff instead

[16:42] <TimToady> *tried

[16:42] <TimToady> m: my $n = 0xff; say :16($n)

[16:42] <camelia> rakudo-moar 200c54: OUTPUT«You have confused the number 255 with the textual representation "255";␤if you wanted to render the number in the given base, use $number.base($radix)␤  in block <unit> at /tmp/0o6cHIELj7:1␤␤»

[16:42] <smls> m: say :16(20)  # ah, it doesn't work with literals

[16:42] <camelia> rakudo-moar 200c54: OUTPUT«You have confused the number 20 with the textual representation "20";␤if you wanted to render the number in the given base, use $number.base($radix)␤  in block <unit> at /tmp/eQ72q5oiCm:1␤␤»

[16:43] <TimToady> those error messsage aren't quite awesome yet

[16:44] <smls> and it only accept strings, not numbers

[16:44] <TimToady> in the first case, there is no textual representation "255"

[16:44] <TimToady> in the second, it guesses the wrong desired semantics

[16:52] *** firefish5000 left
[17:19] <dalek> rakudo/nom: 58a5edf | TimToady++ | src/core/ (2 files):

[17:19] <dalek> rakudo/nom: improve message for :16($number) et al.

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/58a5edfd22

[17:25] *** haroldwu left
[17:27] *** haroldwu joined
[17:28] *** tinyblak left
[17:33] *** domidumont left
[17:42] <dalek> roast: 6dd7403 | TimToady++ | S02-literals/radix.t:

[17:42] <dalek> roast: X::Numeric::Confused object changes

[17:42] <dalek> roast: review: https://github.com/perl6/roast/commit/6dd7403ba9

[17:51] <TimToady> m: my $n = 0xff; say :16($n)

[17:51] <camelia> rakudo-moar 58a5ed: OUTPUT«This call only converts base-16 strings to numbers; value 255 is of type Int, so cannot be converted!␤(If you really wanted to convert 255 to a base-16 string, use 255.base(16) instead.)␤  in block <unit> at /tmp/s6os10TUWD:1␤␤»

[17:54] *** diana_olhovik_ joined
[17:59] <[TuxCM]> FROGGS, remember that without Slang::Tuxic I would not have been able to get you all my bugs :P

[18:01] *** Hor|zon joined
[18:05] *** Hor|zon left
[18:11] *** smls_ joined
[18:12] *** smls left
[18:14] *** amurf joined
[18:15] *** smls_ left
[18:19] *** amurf left
[18:21] *** diana_olhovik_ left
[18:25] <FROGGS> [TuxCM]: I do not deny that it solves some needs, I'm just saying that it introduces tradeoffs where clean rules are in place :o)

[18:25] <[TuxCM]> FWIW, in this case leaving the space *out* when not using S::T, it also fails:

[18:25] <[TuxCM]> $ p6 -MText::CSV -e'csv(in=>"legs.csv",out=>$*OUT,headers=>"auto",filter=>sub($r){$r<legs> >6})'

[18:25] <[TuxCM]> ===SORRY!=== Error while compiling -e

[18:25] <[TuxCM]> Undeclared routine:

[18:25] <[TuxCM]>     sub used at line 1

[18:25] <[TuxCM]> $ p6 -MText::CSV -e'csv(in=>"legs.csv",out=>$*OUT,headers=>"auto",filter=>sub ($r){$r<legs> >6})'

[18:26] <[TuxCM]> works as expected

[18:26] <FROGGS> which is correct in both cases

[18:27] <[TuxCM]> this is why I want Slang::Tuxic. NO confusion anymore for me!

[18:27] <FROGGS> now I remember... I tried special casing some keywords... and failed

[18:28] <FROGGS> https://github.com/FROGGS/p6-Slang-Tuxic/commit/a4b160294d8de8c104a633fc2ade7a39b5f7e1dc

[18:29] *** tinyblak joined
[18:31] <[TuxCM]> now I also remember

[18:33] *** berekuk joined
[18:33] *** berekuk left
[18:33] *** tinyblak left
[18:36] *** kurahaupo joined
[18:42] *** domidumont joined
[18:49] <FROGGS> [TuxCM]: can you try latest Slang::Tuxic when you get the chance?

[18:49] <masak> [TuxCM]++ # knowing what he wants

[18:49] <masak> FROGGS++ # being helpful and accommodating

[18:49] <[TuxCM]> FROGS++

[18:50] <vendethiel> FROGGS++ :)

[18:50] <[TuxCM]> (all p6 folk)++

[18:50] <FROGGS> :o)

[18:50] <[TuxCM]> never giving up on me :)

[18:50] <FROGGS> hehe

[18:51] <masak> [TuxCM]: I remember half a handful of discussions with you acress the years about whitespace. I'm really happy they turned into Slang::Tuxic

[18:53] <[TuxCM]> FROGGS, Text::CSV still passes

[18:55] <FROGGS> \o/

[18:57] <cognominal> https://github.com/rakudo/rakudo/pull/466  A pull request

[18:57] <[TuxCM]>      filter  => sub (CSV::Row $r) {

[18:57] <[TuxCM]> also works

[18:58] <[TuxCM]> FROGGS++; # just for good measure

[18:58] <[TuxCM]> (talk slide adjusted)

[18:58] <masak> waitwait, so the conclusion is that even Slang::Tuxic requires whitespace after `sub` ?

[18:59] <cognominal> *++ # Whoever for good measure

[18:59] *** atroxaper joined
[19:03] *** atroxaper left
[19:04] *** ShimmerFairy left
[19:04] <lucasb> I would appreciate if someone could take a look at why $/ is not getting bound in the replacement side of s/// inside for. Thanks.

[19:04] <lucasb> m: 'a'.subst(/a/, { say $/.WHAT })

[19:04] <camelia> rakudo-moar 58a5ed: OUTPUT«(Match)␤»

[19:05] <lucasb> m: for 1 { 'a'.subst(/a/, { say $/.WHAT }) }

[19:05] <camelia> rakudo-moar 58a5ed: OUTPUT«Nil␤»

[19:05] *** ShimmerFairy joined
[19:05] <lucasb> Same thing happens inside gather too; idk what's the interaction between for/gather and .subst

[19:06] *** davido__ left
[19:06] <masak> m: say $/.WHAT

[19:06] <camelia> rakudo-moar 58a5ed: OUTPUT«Nil␤»

[19:06] <masak> m: 'a'.subst(/a/, -> $/ { say $/.WHAT })

[19:06] <camelia> rakudo-moar 58a5ed: OUTPUT«(Match)␤»

[19:07] <masak> m: for 1 { 'a'.subst(/a/, -> $/ { say $/.WHAT }) }

[19:07] <camelia> rakudo-moar 58a5ed: OUTPUT«(Match)␤»

[19:07] *** davido__ joined
[19:07] <dalek> roast: 4c85334 | TimToady++ | S02-literals/radix.t:

[19:07] <dalek> roast: tests for colon-form radix overrides

[19:07] <dalek> roast: review: https://github.com/perl6/roast/commit/4c85334660

[19:07] <masak> lucasb: you have to pass $/ as aparameter to the block.

[19:07] <dalek> rakudo/nom: 24030f9 | TimToady++ | src/core/Str.pm:

[19:07] <dalek> rakudo/nom: allow :16(':8<377>') and such

[19:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24030f986b

[19:08] <masak> lucasb: I don't know why `'a'.subst(/a/, { say $/.WHAT })` (your first eval) still works.

[19:08] <lucasb> masak++, thanks

[19:09] <lucasb> thing is, I found this trying something like s/(\d+)/$0/

[19:09] <masak> that oughta work.

[19:09] <lucasb> It doesn't :(

[19:11] <masak> m: $_ = "OH 819"; s:g/(\d)/{chr(64 + $0)}/; .say

[19:11] <camelia> rakudo-moar 58a5ed: OUTPUT«OH HAI␤»

[19:11] <masak> worksforme

[19:11] <japhb> m: role A { method !foo { say "success!" } }; role B { method bar { self!foo } }; class C does A does B { }; C.

[19:11] <camelia> rakudo-moar 58a5ed: OUTPUT«5===SORRY!5=== Error while compiling /tmp/HApnTj8iPB␤Confused␤at /tmp/HApnTj8iPB:1␤------> 3f!foo } }; class C does A does B { }; C.7⏏5<EOL>␤»

[19:11] <japhb> m: role A { method !foo { say "success!" } }; role B { method bar { self!foo } }; class C does A does B { }; C.new.bar();

[19:11] <camelia> rakudo-moar 58a5ed: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EYwA0Na4Nq␤No such private method 'foo' for invocant of type 'B'␤at /tmp/EYwA0Na4Nq:1␤------> 3ccess!" } }; role B { method bar { self!7⏏5foo } }; class C does A does B { }; C.ne␤»

[19:12] <japhb> m: role A { method !foo { say "success!" } }; role B { method !foo { ... }; method bar { self!foo } }; class C does A does B { }; C.new.bar();

[19:12] <camelia> rakudo-moar 58a5ed: OUTPUT«===SORRY!===␤Private method 'foo' must be resolved by class C because it exists in multiple roles (B, A)␤»

[19:12] <japhb> Is there any reason that one of the two above can't be made to work?

[19:12] <japhb> (Personally I think the last one should DWIM.)

[19:13] <masak> japhb: I guess it comes down to how private methods from a role compose into a class.

[19:13] <lucasb> m: my $x = 'a1'; $x ~~ s/(\d+)/<$0>/; say $x

[19:13] <camelia> rakudo-moar 58a5ed: OUTPUT«a<1>␤»

[19:13] <lucasb> m: for 1 { my $x = 'a1'; $x ~~ s/(\d+)/<$0>/; say $x }

[19:13] <camelia> rakudo-moar 58a5ed: OUTPUT«Use of Nil in string context  in code  at /tmp/SOTPBUyxHF:1␤a<>␤»

[19:14] * masak submits rakudobug

[19:14] <masak> lucasb: clearly that should work. thanks for finding it.

[19:14] <japhb> masak: Sure ... but methinks a role ought to be able to specify that it requires definition of a private method, since the private methods are collapsed into the class.

[19:14] <TimToady> various supply tests are randomly hanging for me when run in parallel

[19:15] <japhb> TimToady: Any opinion on the roles-requiring-private-methods thing I posted above?

[19:16] <masak> m: for 1 { $_ = "OH 819"; s:g/(\d)/{chr(64 + $0)}/; .say }

[19:16] <camelia> rakudo-moar 58a5ed: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/i9vL27ky5d:1␤␤»

[19:17] <masak> m: my $s = "OH 819"; for $s { s:g/(\d)/{chr(64 + $0)}/; .say }

[19:17] <camelia> rakudo-moar 58a5ed: OUTPUT«Use of Nil in numeric context  in block  at /tmp/4I0l1xSFeV:1␤Use of Nil in numeric context  in block  at /tmp/4I0l1xSFeV:1␤Use of Nil in numeric context  in block  at /tmp/4I0l1xSFeV:1␤OH @@@␤»

[19:17] <masak> m: my $s = "OH 819"; $s ~~ s:g/(\d)/{chr(64 + $0)}/; say $s

[19:17] <camelia> rakudo-moar 58a5ed: OUTPUT«OH HAI␤»

[19:18] *** bin_005 joined
[19:19] <dalek> rakudo/nom: fff5f55 | (Stéphane Payrard)++ | src/Perl6/Actions.nqp:

[19:19] <dalek> rakudo/nom: simplify convolutated code with duplicate statement

[19:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fff5f5565a

[19:19] <dalek> rakudo/nom: 81d1738 | lizmat++ | src/Perl6/Actions.nqp:

[19:19] <dalek> rakudo/nom: Merge pull request #466 from cognominal/variable_declarator

[19:19] <dalek> rakudo/nom: 

[19:19] <dalek> rakudo/nom: simplify convoluted code with duplicate statement

[19:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/81d17387ab

[19:20] <lizmat> TimToady: I've seen that happen, but it only happens on "bad" builds

[19:21] <lizmat> without clarity what makes a build "bad" or "good"

[19:21] <TimToady> m: my $n = ':8<377>'; say :16($n)

[19:21] <camelia> rakudo-moar 24030f: OUTPUT«255␤»

[19:21] <cognominal> sometimes I use "convolutated" adjectives :(

[19:22] <TimToady> this is after a make clean; trying again without TEST_JOBS to see if it's just the test harness (individual tests run fine)

[19:22] <cognominal> lizmat++ for merging cosmetic patches

[19:23] <lizmat> TimToady: make clean doesn't make a difference to me *if* it is a "bad" build

[19:23] <lizmat> cognominal++  # those are the easiest ones to merge  :-)

[19:23] <[TuxCM]> http://tux.nl/Talks/CSV6/hooks6.html :)

[19:25] <lucasb> I see that Str.APPLY-MATCHES has this line: noargs ?? $replacement() !! $replacement($m)

[19:26] <lucasb> So using $/ as a parameter helped. I was justing expecting $/ to be bound automatically

[19:27] <lucasb> thanks for submitting the rakudobug, masak++

[19:28] <masak> my pleasure.

[19:30] *** domidumont left
[19:31] *** diana_olhovik joined
[19:31] <TimToady> japhb: I suspect both submethods and !methods should be considered private to the role, though with different linkage to the class

[19:32] <TimToady> submethods like BUILD should automatically be called along with the class's BUILD, while private methods should probably require explicit qualification if there's more than one

[19:33] <TimToady> but we'd need to get jnthn's opionion wrt feasibility

[19:33] <TimToady> opi-onions, yum!

[19:34] <FROGGS> opiumions?

[19:35] <TimToady> on supply hangs, got one without TEST_JOBS too

[19:35] <japhb> Hmmm, I didn't actually test the case of explicitly specifying the source role ....

[19:35] <japhb> m: role A { method !foo { say "success!" } }; role B { method bar { self!A::foo } }; class C does A does B { }; C.new.bar();

[19:35] <camelia> rakudo-moar 24030f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/n0d8A7PJKM␤Cannot call private method 'foo' on package A because it does not trust B␤at /tmp/n0d8A7PJKM:1␤------> 3" } }; role B { method bar { self!A::foo7⏏5 } }; class C does A does B { }; C.new.b…»

[19:36] <japhb> Hmmm, methinks roles composed in the same class should trust each other.

[19:37] <japhb> Although this way lies tighter linkage between roles than making it work to just require that a private method exists.

[19:37] <masak> by the way, http://xkcd.com/1542/ was an autopun

[19:38] <japhb> I think I'd rather have the require-a-private-method technique.  Because I'd like a role to depend on *some* other role that matches a given interface, not *one particular* role.

[19:39] <japhb> And it doesn't feel right to make a method (or attribute) public *just* to allow roles to work together that way.

[19:39] <FROGGS> [TuxCM]: in latest Slang::Tuxic you can declare that hook as "sub(){}"

[19:40] <masak> japhb: an argument could also be made that since private attrs compose, private methods ought also.

[19:40] <masak> FROGGS++

[19:40] <japhb> masak: Yes, that.

[19:40] <lizmat> [TuxCM]: https://gist.github.com/lizmat/b794f31b9d5978e76886

[19:40] <[TuxCM]> OMG

[19:41] <[TuxCM]> what is $^ex?

[19:41] <masak> implicit parameter

[19:41] <lizmat> { $^a } is the same as -> $a { $a }

[19:41] <masak> same as -> $ex { c.quit($ex) }

[19:42] <lizmat> another way to create signatures

[19:42] <masak> implicit parameters are nifty. they declare themselves implicitly in Unicode sorting order.

[19:42] *** raiph left
[19:43] <masak> m: my $b = { say "$^second $^first" }; $b("HAI", "OH")

[19:43] <camelia> rakudo-moar 24030f: OUTPUT«OH HAI␤»

[19:43] <[TuxCM]> now that I made a (big) step into actually doing the filter callbacks right, I might find motivation to do more

[19:43] <masak> m: { say "$^second $^first" }("HAI", "OH")

[19:43] <camelia> rakudo-moar 24030f: OUTPUT«OH HAI␤»

[19:43] <[TuxCM]> my YAPC::EU talk made me jump the hurdle

[19:44] <lizmat> [TuxCM]: especially when creating callbacks, implicit parameters make things a lot easier to specify

[19:44] <lizmat> -> $a, $b, $c { $a * $b * $c } becomes { $^a * $^b * $^c }

[19:44] <[TuxCM]> filter => sub { $^r<legs> > 3 }

[19:44] <lizmat> yup

[19:45] <[TuxCM]> I get it. I like it

[19:45] <lizmat> even without the sub

[19:45] <lizmat> filter => { $^r<legs> > 3 }

[19:45] <[TuxCM]> WHAT? awesome!

[19:45] * [TuxCM] changes the slide again

[19:45] <masak> if you remove `sub`, you can't say `return` inside, though.

[19:45] <lizmat> you can only "leave", but that is NYI indeed

[19:46] <masak> I thought about `leave` the other day, and why it's still NYI. should we be concerned about that?

[19:46] <masak> it's a fairly central feature.

[19:46] <masak> ISTR Niecza implements it.

[19:46] <lizmat> well, if it's easily circumventable by adding "sub" and use return

[19:46] <masak> not always.

[19:46] <lizmat> I'm not quite sure why we need it, tbh

[19:47] <[TuxCM]> http://tux.nl/Talks/CSV6/hooks6.html :)

[19:47] <masak> what if I actually have a block with a label, then a lot of deep nesting, and then `leave LABEL;` far inside.

[19:48] <lizmat> ah, isn't that just goto LABEL though ?

[19:48] *** bin_005_j joined
[19:48] *** ][Sno][ joined
[19:48] <masak> it is goto something after the end of that block, yes.

[19:48] <[TuxCM]> Hmm. I have to support it though, as => { … } is neither Routine nor Sub

[19:49] <lizmat> [TuxCM]: it's a Callable

[19:49] <masak> lizmat: another thing that `goto` does not emulate is the fact that `leave` (like `return`) can pass a value.

[19:49] <lizmat> ah, true, but how would the leave LABLE process the value then?

[19:50] <lizmat> *LABEL

[19:50] <FROGGS> masak: without that 'value' it should not even be that hard to implement I think

[19:50] *** Hor|zon joined
[19:50] *** [Sno] left
[19:50] <[TuxCM]> thanks, Callable works

[19:50] <masak> FROGGS: that's what confuses/worries me. why don't we have it already?

[19:50] <FROGGS> lizmat: it would be part of the thrown control exception

[19:50] <FROGGS> masak: I dunno... time?

[19:50] <lizmat> it needs work at the nqp level, afaik

[19:51] <lizmat> or even VM level?

[19:51] *** bin_005 left
[19:51] * masak .oO( it needs to work on the level of the physical substrate ) o.O

[19:52] <[TuxCM]> I'll stop, before it will turn into a late night :)

[19:52] <[TuxCM]> Thanks all for all the valuable feedback today!

[19:52] <FROGGS> gnight [TuxCM] 

[19:52] <masak> [TuxCM]: 'night

[19:55] *** Hor|zon left
[19:55] <lizmat> gnight [TuxCM] 

[19:56] <lizmat> .tell [TuxCM] the semicolon in $^r<legs> < 8;  is not needed

[19:56] <yoleaux> lizmat: I'll pass your message to [TuxCM].

[20:02] *** firefish5000 joined
[20:07] *** telex left
[20:08] *** telex joined
[20:11] *** kurahaupo left
[20:25] *** everym4n joined
[20:25] *** kurahaupo joined
[20:27] *** virtualsue joined
[20:27] *** kaare_ left
[20:30] *** kurahaupo left
[20:31] *** darutoko left
[20:32] *** kurahaupo joined
[20:35] *** diana_olhovik left
[20:37] *** Ven left
[20:40] *** kurahaupo left
[20:42] *** everym4n left
[20:44] *** haroldwu left
[20:46] *** dylanwh left
[20:47] <TimToady> lizmat++, forcing a recompile of MoarVM and nqp seems to have cleared the hangs

[20:49] <AlexDaniel> FROGGS: Hi! Have you thought about this "run" vs "qqx//" problem?

[20:50] <AlexDaniel> $output = run(«echo $test», :out).out.get;

[20:50] <AlexDaniel> $output = qqx/echo $test/;

[20:50] <FROGGS> AlexDaniel: what was it? seems I forgot

[20:50] <AlexDaniel> Huffmanly speaking qqx is better, but it should not be

[20:50] <FROGGS> ahh, that one

[20:51] <AlexDaniel> yea

[20:51] <FROGGS> had thought about it the other day, but had no idea how to improve it

[20:51] *** haroldwu joined
[20:52] <FROGGS> hmmm

[20:53] <AlexDaniel> I think that it is important to fix it. Maybe someone else can suggest something?

[20:53] * FROGGS .oO( sub echo (*@) is system-command { * }; echo $test )

[20:53] <FROGGS> surely, everybody can suggest something

[20:54] <AlexDaniel> it is a bit too extreme, but maybe getting rid of qqx would help...

[20:55] <AlexDaniel> I mean, sure you can have it, but why is it so short

[20:57] <masak> wait, why get rid of it because it's short?

[20:58] <AlexDaniel> masak: well, if it is so short, then everybody is going to use it because it "looks right" unlike "run"

[20:59] <masak> AlexDaniel: I use `run` when I want the side effect and `qqx` when I want the output.

[20:59] <AlexDaniel> masak: but then you get all sorts of the problems because you pass stuff to the shell, which should be avoided

[20:59] <AlexDaniel> masak: well, you've just confirmed the problem

[21:00] <masak> I'm sorry, I still don't see the problem. "all sorts of the problems" doesn't quite do it for me as an explanation.

[21:00] <masak> I've successfully used `qqx` a bunch of times.

[21:00] <AlexDaniel> masak: ok, well, when you pass stuff to the shell you have to quote parameters

[21:00] <AlexDaniel> masak: but why bother with that when you can just skip the shell?

[21:01] <AlexDaniel> especially when you don't need it

[21:01] *** dylanwh joined
[21:01] <AlexDaniel> there was another discussion on that topic: http://irclog.perlgeek.de/perl6/2015-06-27#i_10813919 but it started with a wrong question

[21:01] <masak> I think I could track down all my uses of qqx ever, and prove formally that they don't have shell quoting problems.

[21:02] <masak> even if they did, those problems did not manifest for me when I ran the stuff.

[21:02] <AlexDaniel> masak: good for you, but not that good for the language itself

[21:02] <japhb> .ask jnthn What are your thoughts on http://irclog.perlgeek.de/perl6/2015-07-11#i_10881267 and http://irclog.perlgeek.de/perl6/2015-07-11#i_10881334 ?  Having no good resolution kinda gets in the way of a nice refactoring (for now, I'm copying the required private methods into each role that would want to consume them, and then changing the names to not collide between the roles which is ... blech.)

[21:02] <yoleaux> japhb: I'll pass your message to jnthn.

[21:03] <AlexDaniel> masak: well, you know, most people don't quote their variables in bash because "it works"

[21:03] <masak> *nod*

[21:03] <masak> I'm usually not on this side of arguments like these :>

[21:03] <AlexDaniel> and then you pass a filename with a space or some other special stuff and the whole thing just breaks

[21:03] <masak> I like works-always as a principle too.

[21:04] <masak> it *does* feel a little bit like the SQL quoting slangs we've been talking about now and then.

[21:04] <AlexDaniel> yea

[21:04] <masak> that is, you just want to interpolate the variable in some nice slang, and it quotes things for you automatically and in the right way.

[21:04] *** dylanwh left
[21:05] <FROGGS> masak: we dont have to quote things at all when we use run()

[21:05] <AlexDaniel> and if I get it right, that's what this Huffman coding thing is about - correct stuff should be easier than other insecure ways

[21:06] <masak> FROGGS: oh right, `run()` already does this

[21:06] <AlexDaniel> nope

[21:06] <AlexDaniel> it does not quote anything, if I get it right

[21:06] <FROGGS> correct, it stays an array

[21:06] <masak> I think someone prototyping this slang in module-space would be awesome. then we could discuss how core it should be, and whether it should replace `qqx`

[21:07] *** rindolf left
[21:08] <AlexDaniel> well, look: $output = run(«echo $test», :out).out.get;

[21:08] <AlexDaniel> it is already there, just a bit too hard to type and remember...

[21:10] <AlexDaniel> I really think that running stuff in shell should be discouraged. At first I thought "but how do you pipe stuff then?" but then I read this: http://doc.perl6.org/type/Proc

[21:11] <japhb> AlexDaniel, masak, FROGGS: Why not just have something (just slightly more complex than) 'multi sub QX($cmd, @*args) { run($cmd, |@args, :out).out.get }' and call it a day?

[21:12] <japhb> (Apologies if someone already said this, I've only been skimming today.)

[21:13] <lucasb> ftr, iiuc, .get only gets the first line; if someone wants the whole shebang, he would have to type even more: .slurp-rest :)

[21:13] <AlexDaniel> japhb: ok, then what would be the replacement for qqx// ? In other words, to run a string in shell and get the output

[21:13] <AlexDaniel> lucasb: oh noes!

[21:13] <masak> lucasb: just .slurp should work, too

[21:13] <japhb> lucasb: Point taken.

[21:13] <lucasb> masak: hmm?

[21:14] <lucasb> .slurp-rest from IO::Handle

[21:14] <masak> well, .slurp-rest is for when you've already started reading something and want to read the remainder.

[21:14] <masak> if you're still at the beginning of the something, you can .slurp

[21:16] <japhb> AlexDaniel: Since qqx// is IIRC implemented in terms of QX, I suspect something could be arranged; perhaps a named argument to QX that chooses the shell-ish behavior.  Thats why I said "just slightly more complex than".  It's all about the layers of sugar.

[21:16] <AlexDaniel> uhh

[21:16] *** bin_005_j_j joined
[21:16] <masak> japhb: problem is that once you've flattened everything into a string, it's too late

[21:17] *** virtualsue_ joined
[21:17] *** bin_005_j left
[21:17] <japhb> masak: This is perhaps the place where skimming is biting me.  Why would you *want* to invoke the shell, if you don't want shellish behavior?

[21:17] <FROGGS> gnight #perl6 (will backlog tomorrow)

[21:17] *** FROGGS left
[21:18] <AlexDaniel> japhb: because nobody wants shellish behavior

[21:18] <AlexDaniel> most of the time people just want to run the command

[21:18] <lucasb> masak: .slurp from IO::Handle is deprecated; one has to use .slurp-rest even for the first time reading

[21:18] <AlexDaniel> without all that shell stuff

[21:18] <masak> japhb: the trap AlexDaniel wants to avoid is a single interpolated variable expanding into multiple shell args.

[21:18] <masak> japhb: which is at best an annoyance and at worst a security issue.

[21:18] <japhb> This is what I'm confused by: 14:13 < AlexDaniel> japhb: ok, then what would be the replacement for qqx// ? In other words, to run a string in shell and get the output

[21:18] *** virtualsue__ joined
[21:18] <japhb> masak: I know that.

[21:19] <AlexDaniel> masak: not only. Imagine a filename like "$(rm -rf *)".

[21:19] <masak> AlexDaniel: ah, good point.

[21:19] <AlexDaniel> or just "*"

[21:19] <lizmat> masak: .slurp works on a path, .slurp-rest on an opened handle

[21:19] <masak> I can't claim I see the whole picture here either.

[21:19] <masak> lizmat: ah.

[21:19] *** virtualsue left
[21:19] <lucasb> Which leads me to another question: Why did you people renamed IO::Handle.slurp to .slurp-rest? Just so that it doesn't conflict with IO::Path? Isn't that two separate namespaces?

[21:19] <lizmat> .slurp-rest doesn't close the handle, .slurp does

[21:20] *** virtualsue__ is now known as virtualsue

[21:20] <japhb> To possibly short circuit things: qqx(<< foo bar $baz "qu ux" >>) ought to do the right thing, IMHO, and that does not involve the shell.

[21:20] *** dylanwh joined
[21:20] <lizmat> should or should not .slurp close the handle when called on an opened handle ?

[21:20] <masak> qqx is not a function, it's a quoting construct.

[21:21] <lizmat> masak:: underneath it is, but yeah

[21:21] <masak> m: say qq(foo bar)

[21:21] <camelia> rakudo-moar 81d173: OUTPUT«5===SORRY!5=== Error while compiling /tmp/EXRZqyanx2␤Undeclared routines:␤    bar used at line 1. Did you mean 'bag'?␤    foo used at line 1␤    qq used at line 1␤␤»

[21:21] <japhb> masak: Not if it's got 'qqx(...)'.  Function interpretation should win.

[21:21] <masak> oh, apparently not.

[21:21] <masak> japhb: yes, just realized.

[21:21] *** virtualsue_ left
[21:22] <lucasb> lizmat: I guess this has already been discussed. I was not here, but my opinion is that .slurp on a handle should not close, after all the handle was alread open

[21:22] <AlexDaniel> well, the problem is that qqx invokes the shell but it should not. There is no way to fix this other than just stop using the shell, that's what geekosaur pointed out in the previous discussion

[21:23] <japhb> AlexDaniel: qqx// or qx// invokes the shell, because it doesn't have a choice.  But qx() need not.

[21:23] <japhb> One is a quoting construct, the other is just a function call.

[21:23] <lizmat> lucasb: but .slurp on an IO::Path should, right ?

[21:23] <lucasb> lizmat: I would say yes :)

[21:23] <japhb> Or are you arguing that a quoting construct ought to try to do some magic parsing?

[21:24] <lizmat> lucasb: and on $something.slurp ?   should it close $something or not ?

[21:24] <AlexDaniel> you can split the thing into parameters correctly, but that's not enough. You can quote the parameters, but it's not that easy because how would you know the rules of the underlying shell?

[21:25] <japhb> AlexDaniel: Are you talking about my qqx(<< foo bar $baz "qu ux" >>) example?

[21:25] <AlexDaniel> japhb: I don't really understand why qx and qqx should do things differently

[21:25] <lucasb> Is $something an IO::Path or an IO::Handle? that distinction says what to do

[21:25] <japhb> You don't care about the quoting rules of the underlying shell ... << ... >> has (very smart) quoting rules already.

[21:25] <AlexDaniel> japhb: any example involving 'x'

[21:26] <AlexDaniel> japhb: how << >> quote $( ) ?

[21:26] <japhb> AlexDaniel: it's not qqx v. qx.  It's q// v. q().  

[21:26] <AlexDaniel> oh

[21:26] <japhb> AlexDaniel: However Perl 6 would interpret it.  << ... >> is a quoting slang.

[21:26] <japhb> That is very smart about quoting and interpolation.

[21:27] <lizmat> lucasb: so that's interface consistency: when you call .slurp on something, you don't know whether that will close something or not

[21:27] <japhb> Lemme see if I can find the spec reference

[21:27] <masak> m: my $s = '$(rm -rf)'; say <<echo $s>>.perl

[21:27] <camelia> rakudo-moar 81d173: OUTPUT«("echo", ("\$(rm", "-rf)"))␤»

[21:27] <lizmat> rather than adding a :close parameter to .slurp, it felt better to add a .slurp-rest

[21:27] <AlexDaniel> my $s = '`rm -rf`'; say <<echo $s>>.perl

[21:28] <AlexDaniel> m: my $s = '`rm -rf`'; say <<echo $s>>.perl

[21:28] <camelia> rakudo-moar 81d173: OUTPUT«("echo", ("`rm", "-rf`"))␤»

[21:28] <lizmat> but, as many things with things backported from the newio branch, it can still change

[21:28] <lizmat> if consensus wants slurp-rest dead, and a :close parameter added to .slurp, I can also live with that

[21:28] <AlexDaniel> m: my $s = '`shutdown`'; say <<echo $s>>.perl

[21:28] <camelia> rakudo-moar 81d173: OUTPUT«("echo", "`shutdown`")␤»

[21:28] <lucasb> lizmat: to me that's polymorphism; different classes do different things with the messages they receive. :)

[21:29] <AlexDaniel> so it does not work, right?

[21:29] <japhb> AlexDaniel: S02:3591

[21:30] <dalek> Heuristic branch merge: pushed 66 commits to rakudo/newio by lizmat

[21:31] <japhb> AlexDaniel: I don't understand what you mean by "does not work" here.  What are you pointing out?

[21:32] <japhb> AlexDaniel: I'm guess you're pointing out that the '`rm -rf`' is getting split one extra time ... in which case that's just a bug, not a spec failure.

[21:32] <AlexDaniel> japhb: Shell injection. If you can manipulate $s then run any command. In this example I ran "shutdown": my $s = '`shutdown`'; say <<echo $s>>.perl

[21:32] <AlexDaniel> japhb: please correct me if I'm wrong

[21:32] <japhb> AlexDaniel: OK, you're wrong.  :-0

[21:33] <AlexDaniel> japhb: could be, why?

[21:34] <japhb> AlexDaniel: executing qx(<<echo `shutdown`>>) would be the same as qx(['echo', '`shutdown`']<>), and if qx() does not involve the shell, then no problem.

[21:35] <AlexDaniel> yea, right

[21:35] <japhb> I wonder if there's namespace confusion here ... quoting constructs and callables are in separate namespaces.  No need for the quoting construct and the function to *both* be shellish.

[21:36] <masak> as long as there's a consistent rule in there somewhere.

[21:36] <japhb> Would it help if I called qx() something like my-qx-func() instead?  :-)

[21:36] <AlexDaniel> so qx() would be a shortcut for run(..., :out).out.slurp-rest ?

[21:37] *** caymanboy joined
[21:37] <caymanboy> Caymanboy in da house

[21:37] <japhb> masak: My thinking is that a quoting construct flattens to a single string (or the moral equivalent, like a Cat), and thus *must* use the shell if there is a space in the string.  Whereas the function form should always *NOT* use the shell.

[21:37] <japhb> AlexDaniel: Yes!  :-)

[21:38] <masak> caymanboy: mi casa es su da house

[21:38] <caymanboy> Had a perl8 burger at www.xqs.ky, it was awesome.   Just had to wait a while

[21:38] <caymanboy> <cough>

[21:38] <caymanboy> err 6

[21:38] <AlexDaniel> japhb: then what about giving it a distinguishable name? Like, um, "echo" ?

[21:39] <ugexe> QX is shell, not a process

[21:39] *** Hor|zon joined
[21:39] <caymanboy> nothing worse that fing up a funny

[21:40] <masak> caymanboy: "awesome, just had to wait a while" is our inofficial slogan. :)

[21:40] <japhb> ugexe: I know, I had been talking about multi behavior ... but let's leave QX out of it for now.  AlexDaniel and I are having enough trouble without that confusion (which yes, I brought on myself).

[21:40] <caymanboy> new mascot, the hour glass

[21:40] <AlexDaniel> ugexe: well, I guess that you have to scroll up a bit :)

[21:41] <japhb> caymanboy: "OMG, what will you call it?" ... "The Aristocats!" ... DAMMIT!

[21:41] <caymanboy> I will be coding p6 in pergatory

[21:42] <japhb> ... and you will feel like you made it to heaven.

[21:42] * masak .oO( more like "15 year-glass" , ammarite? ) :P

[21:43] <caymanboy> fyi: I sent slickedit.com whether they will be supporting p6 in their new releaase.  they said if its just syntax , we will includes it in the bext release....

[21:43] *** Hor|zon left
[21:43] <caymanboy> i jupmed the gun a bit

[21:44] <caymanboy> note to self.  dont irc on chardonnay

[21:45] <AlexDaniel> japhb: last time I jokingly suggested backticks for that http://irclog.perlgeek.de/perl6/2015-06-27#i_10814033

[21:45] * masak was wondering what exactly it was on

[21:45] <AlexDaniel> japhb: as stupid as it sounds, but it is shorter that qqx// or any other variant

[21:45] <AlexDaniel> japhb: and kinda familiar

[21:45] <AlexDaniel> than*

[21:46] <masak> AlexDaniel: backticks are "reserved" as custom circumfix operators for module space.

[21:46] <japhb> AlexDaniel: Sure.  I think `...` is currently reserved in Perl 6 for module-space use (or in general, non-core uses).

[21:46] <caymanboy> listen, you guys need to get cracking, I told all my cayman friends Perl6 was the python killer

[21:47] <masak> caymanboy: we don't kill snakes, we convert them.

[21:47] <caymanboy> I prefer consuming

[21:47] <masak> caymanboy: Python is just a really odd way to write Perl 6.

[21:47] <nys> "perl 6 burger"

[21:47] <nys> the perl 6 burger subsumes all other burgers

[21:48] <caymanboy> I joined up a company that is making me code in python.  this is why I'm here

[21:48] <caymanboy> do something

[21:48] <masak> caymanboy: :)

[21:48] <japhb> caymanboy: It happens to the best of us.  Well, OK, it happens to many of us.  ;-)

[21:48] <masak> caymanboy: I teach Python. more market demand than Perl right now. but my heart is with Perl 6.

[21:49] <caymanboy> perl6 is glorious.  I love whats hapening w

[21:50] <masak> Python is an OK language. I love how far they get on basically being sane and conservative. but I also see that that only gets you so far.

[21:50] *** caymanboy left
[21:50] <AlexDaniel> I can't really see any solution though. qqx// is so short, it is really hard to beat it. Especially considering that you will probably have to use << >> which is 4 or 2 characters longer...

[21:50] *** zakharyas joined
[21:51] * ab5tract_ likes qq:x{...}

[21:52] *** amurf joined
[21:53] <AlexDaniel> is :x a shortened form? Is there any longer variant?

[21:53] <ab5tract_> it feels nice and explicit, but I recognize that other people prefer to keep these sorts of things as absolutely short, character-wise, as possible

[21:54] <AlexDaniel> ab5tract_: qq:run_in_shell_nonsecure{} is a bit more informative though

[21:54] *** caymanboy joined
[21:54] <caymanboy> I apologize for that rude interruption

[21:54] <ab5tract_> s/_/-/

[21:54] <ab5tract_> :)

[21:54] <caymanboy> cayman inet isn't exactly fios

[21:55] <caymanboy> anyways

[21:55] <caymanboy> I need a date

[21:55] <masak> caymanboy: oh, so you're actually from the Cayman islands?

[21:55] <ab5tract_> AlexDaniel: it seems to me that most people would expect such a feature to "shell out"

[21:56] <caymanboy> how long will YOU make me suffer coding python

[21:56] <caymanboy> masak: yes

[21:56] <masak> caymanboy: I've been using Perl 6 in production since 2010.

[21:56] *** amurf left
[21:56] <caymanboy> hmmm rakudo?

[21:56] <ab5tract_> and most people know that shelling out is as insecure as the shell and the commands passed to it

[21:56] <masak> caymanboy: it's mostly a question of your pain threshold and idealism.

[21:57] <masak> caymanboy: yes, Rakudo. first on Parrot, nowadays on Moar.

[21:57] <caymanboy> yes, very confusing

[21:57] <AlexDaniel> ab5tract_: hah, I like that

[21:57] <caymanboy> I thought parrot what the ultimate vm

[21:57] <masak> caymanboy: confusing, but ultimately good for the users.

[21:57] <japhb> AlexDaniel: I still think the non-Texas version of qx(<< ... >>) is pretty reasonable.   # Sorry, Unicode is a *pain* to enter into this terminal emulator.

[21:58] <masak> caymanboy: it's good that Perl 6 *can* run on many VMs.

[21:58] <AlexDaniel> japhb: it is still longer than qqx//, isn't it?

[21:58] <caymanboy> thats awesome.  it does'nt help the fact that they are making me code python

[21:59] <caymanboy> you have a marketing problem

[21:59] <masak> caymanboy: no argument there.

[21:59] <caymanboy> guess what, that's what I'm good at

[21:59] <masak> caymanboy: another inofficial slogan is "we suck at marketing". it's actually from the Perl 5 community, but it still applies.

[21:59] <caymanboy> no shit

[22:00] <caymanboy> p6 in my limited view blows away python 2 and 3

[22:00] <masak> yeah; it's nice

[22:01] <caymanboy> but i have to code in python because.... NOT that it does anything more or better

[22:01] <caymanboy> because it "easier" and more "popular"

[22:02] <masak> caymanboy: don't know if it helps you, but... I find there's a lot of small, non-user-facing problems I can still solve in p6, even when I'm coding in something else

[22:02] <AlexDaniel> masak: yes

[22:03] <ab5tract_> caymanboy: well, it's also well ahead of p6 in terms of tooling and ecosystem

[22:03] <ab5tract_> and programmers :)

[22:03] <AlexDaniel> ab5tract_: and maturity, in some sense.

[22:04] <masak> we're trying to learn from the failings and setbacks of py3k as much as we can here.

[22:04] <AlexDaniel> because the chance of some bug jumping right into your face is pretty high at the moment :)

[22:04] <caymanboy> intermission my rude cayman friends are interrupting me

[22:04] <caymanboy> apologies

[22:05] <masak> the "funny" thing is that py3k was pretty determined to learn from the failings and setbacks of p6...

[22:05] <masak> guess everyone has to invent and make their own mistakes.

[22:06] <caymanboy> www.xws.ky loves perl6

[22:07] <caymanboy> www.xqs.ky

[22:07] <caymanboy> im a really bad tuper

[22:08] <AlexDaniel> masak: I'm not sure if they were trying to learn anything, actually. http://www.artima.com/weblogs/viewpost.jsp?thread=98196

[22:10] <masak> AlexDaniel: I've seen that one, yes.

[22:11] *** zakharyas left
[22:11] <ab5tract_> masmas

[22:11] *** ohb left
[22:11] <caymanboy> ok perl people, I would love to make a great intellectual contribution, however i'm one chardonnay above that sitiation.  Perl6 for life baby.  you have support in Cayman baby!

[22:11] *** ohb joined
[22:11] <caymanboy> word

[22:11] *** caymanboy left
[22:12] * masak feels comforted to have support in Cayman

[22:13] <nys> cayman's always the swing vote

[22:19] <masak> oh, south of Cuba. I see.

[22:21] <RabidGravy> you'll be glad of the connection when you want to save some tax on your millions

[22:21] <itz__> donote with some of those offshore tax avoidance $$$

[22:22] * japhb valiantly fights the urge to defenestrate his computer

[22:22] <RabidGravy> do it! do it!

[22:23] <japhb> RabidGravy: I think I'm going to go get some pizza instead.  Pizza makes everything better.

[22:24] <RabidGravy> beer, beer makes everything better. Pizza just helps ;-)

[22:24] <RabidGravy> I haven't had pizza in more than a year mind

[22:26] *** lucasb left
[22:27] *** spider-mario left
[22:27] <lizmat> preparing and commute to PDX&

[22:27] *** lizmat left
[22:28] *** espadrine_ left
[22:28] *** TEttinger joined
[22:35] *** atroxaper joined
[22:39] *** atroxaper left
[22:40] <masak> 'night, #perl6

[22:43] <virtualsue> pizza++

[22:47] *** mudguts joined
[22:51] *** mudguts left
[22:53] *** raiph joined
[23:11] *** leont left
[23:14] *** RabidGravy left
[23:14] *** dj_goku left
[23:15] *** dj_goku joined
[23:15] *** raiph left
[23:27] *** ][Sno][ left
[23:28] *** [Sno] joined
[23:28] *** Hor|zon joined
[23:32] *** Hor|zon left
[23:40] * ab5tract_ finally cracked the overlaps-with logic :D

[23:40] <AlexDaniel> is there any way to precompile a file so that it executes faster?

[23:42] *** amurf joined
[23:44] <ab5tract_> AlexDaniel: yup. there are have been issues with pre-comp though. the order of pre-compilation matters (or has mattered)

[23:44] <AlexDaniel> ab5tract_: ok, how?

[23:44] <ab5tract_> right, I haven't bothered much because of the issues

[23:46] *** BenGoldberg joined
[23:46] <ab5tract_> so I can't tell you off-hand

[23:46] <japhb> AlexDaniel: The easiest way is to install it with panda.

[23:46] *** amurf left
[23:47] <AlexDaniel> japhb: it – what? My code?

[23:48] <japhb> Funnily enough, I just managed to improve run time in my current project that it is now dominated by module loading.  methinks I will need to take my own advice soon.

[23:49] <japhb> AlexDaniel: Yes.  You can say 'panda install .' (assuming you have the metadata file, META.json IIRC), and it will compile all the modules and put them into your CURLI, so they load *much* faster.

[23:49] <japhb> Of course, that then needs to be part of your development iteration ...

[23:50] <japhb> ISTR ufo can do this as well, with slightly different workflow.

[23:52] <ab5tract_> AlexDaniel: you got me curious, so I started chasing

[23:53] <ab5tract_> the gory bits, including how to get proper compilation order, are in Panda::Builder

[23:53] <ab5tract_> you can quickly get at the source code by invoking: panda look panda

[23:53] <ab5tract_> the vim lib/Panda/Builder.pm, once you are in the chroot

[23:55] <ab5tract_> actually, I'm not sure whether it is a chroot or just a new shell, but anyway...

[23:57] <AlexDaniel> uhh!

