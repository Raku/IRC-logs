[00:00] *** pierrot left
[00:04] <_itz_> m: my @s = 1,2,3,4; my $foo = @s[0..1, 2..3].join; warn $foo.perl;

[00:04] <GLRelia> rakudo-moar 7f8a19: OUTPUT«"1 23 4"  in block <unit> at /tmp/k4K4FZAEj1:1␤»

[00:04] <camelia> rakudo-moar edffe0: OUTPUT«"1234"  in block <unit> at /tmp/uwwM3j7RRX:1␤»

[00:16] <TimToady> hmm, I thought slice lists flattened

[00:16] <yoleaux> 22 Aug 2015 14:12Z <nine> TimToady: should the single arg rule really extend to Hashes just because they do Iterable? my @a = {:a(1), :b(2)}; gives [:a(1), :b(2)] and the same happens for sub calls. for %hash {...} and %hash.map iterating over the pairs does asolutely make sense, but when passing a hash to a sub or method, one really expects it to stay a hash.

[00:16] *** AlexDani` left
[00:16] <cwDYKARN>  hmm nudles greencurry flavor, with choccolate, and BBQ-sticks.... thoughts? ^.-

[00:18] <TimToady> .tell nine I don't think the case of initializing an array with a single hash will arise all that often, so I'm willing to leave it as a DIHWIDT for simplicity

[00:18] <yoleaux> TimToady: I'll pass your message to nine.

[00:25] *** aborazmeh joined
[00:25] *** aborazmeh left
[00:25] *** aborazmeh joined
[00:26] *** geekosaur left
[00:26] *** virtualsue joined
[00:27] *** slavik joined
[00:29] *** geekosaur joined
[00:40] *** virtualsue left
[00:46] *** llfourn joined
[00:51] *** llfourn left
[01:14] <lizmat> m: say (start 42) == (start 42) 

[01:14] <GLRelia> rakudo-moar 7f8a19: OUTPUT«Cannot call Numeric(Promise: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/iKIQTilqUz:1␤␤»

[01:14] <camelia> rakudo-moar edffe0: OUTPUT«Cannot call Numeric(Promise: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/158FSYl4qJ:1␤␤»

[01:15] *** llfourn joined
[01:15] <lizmat> I wonder whether Promises should coerce to .result.Numeric, so that the above *would* DWIM

[01:15] <lizmat> m: say (start 42).result == (start 42).result

[01:15] <GLRelia> rakudo-moar 7f8a19: OUTPUT«True␤»

[01:15] <camelia> rakudo-moar edffe0: OUTPUT«True␤»

[01:17] *** colomon left
[01:19] *** llfourn left
[01:34] <ugexe> from-json() gives error 'method ast not found for invocant Str' on glr now when trying to read the ecosystem projects.json

[01:34] <ugexe> from-json("projects.json".IO.slurp)

[01:45] *** BenGoldberg joined
[01:46] *** colomon joined
[01:49] *** vendethiel joined
[01:49] <ugexe> m: my $json = q|[{"depends":["a"]}]|; say from-json($json)

[01:49] <GLRelia> rakudo-moar 7f8a19: OUTPUT«Method 'ast' not found for invocant of class 'Array'␤  in block <unit> at /tmp/7BmKUjYQ81:1␤␤»

[01:49] <camelia> rakudo-moar edffe0: OUTPUT«depends => a␤»

[01:50] *** skids joined
[01:52] <dalek> rakudo/nom: ac34880 | lizmat++ | src/core/Promise.pm:

[01:52] <dalek> rakudo/nom: Make == eq eqv DWIM on Promises

[01:52] <dalek> rakudo/nom: 

[01:52] <dalek> rakudo/nom: With the emphasis on "I" :-)   Inspired by the first Promises slide in

[01:52] <dalek> rakudo/nom: jnthn++ last presentation:

[01:52] <dalek> rakudo/nom:   http://jnthn.net/papers/2015-yapcasia-concurrency.pdf

[01:52] <dalek> rakudo/nom: 

[01:52] <dalek> rakudo/nom: It occurred to me that the whole slide could be reduced to:

[01:52] <dalek> rakudo/nom: 

[01:52] <dalek> rakudo/nom:   sub MAIN($file1, $file2) {

[01:52] <dalek> rakudo/nom:       say (start from-json(slurp($file1)) eqv (start from-json(slurp($file2)))

[01:52] <dalek> rakudo/nom:         ?? 'Files contain identical JSON'

[01:52] <dalek> rakudo/nom:         !! 'Files contain different JSON';

[01:52] <dalek> rakudo/nom:   }

[01:52] <dalek> rakudo/nom: 

[01:52] <dalek> rakudo/nom: with these changes.

[01:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac348801ab

[02:08] <ugexe> m: say from-json(q|{"a": 1}|); say from-json(q|[{"a": 1}]|);

[02:08] <camelia> rakudo-moar edffe0: OUTPUT«a => 1␤a => 1␤»

[02:08] <GLRelia> rakudo-moar 7f8a19: OUTPUT«a => 1␤Method 'ast' not found for invocant of class 'Int'␤  in block <unit> at /tmp/3CyHckx9GH:1␤␤»

[02:08] *** llfourn joined
[02:13] *** yqt left
[02:23] *** noganex_ joined
[02:26] *** noganex left
[02:29] *** mjgardner left
[02:35] *** mjgardner joined
[02:44] *** amurf joined
[02:49] *** amurf left
[03:08] *** aborazmeh left
[03:37] *** aborazmeh joined
[03:37] *** aborazmeh left
[03:37] *** aborazmeh joined
[03:42] *** abaugher is now known as CailCorishev

[03:50] *** mjgardner left
[03:52] *** MadcapJake left
[04:10] *** mjgardner joined
[04:20] <dalek> roast/glr: d507a7d | (David Warring [email@hidden.address] | integration/advent2012-day1 (2 files):

[04:20] <dalek> roast/glr: further GLR mods for 2012 advent days 13 & 14

[04:20] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/d507a7dc22

[04:27] *** CailCorishev is now known as Cail

[04:32] <dalek> rakudo/glr: a959024 | moritz++ | src/core/JSON/Pretty.pm:

[04:32] <dalek> rakudo/glr: Fix from-json(q|[{"a": 1}]|)

[04:32] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a959024465

[04:44] <rangerprice> Goodbye, a go to sleep

[04:44] <rangerprice> i go*

[04:44] *** rangerprice left
[04:45] *** khw left
[04:47] *** aborazmeh left
[04:47] <dalek> roast/glr: ee49119 | skids++ | S (7 files):

[04:47] <dalek> roast/glr: GLR/non-fatal adjustments to some tests.

[04:47] <dalek> roast/glr: 

[04:47] <dalek> roast/glr: GLRify parts of tests which are not relevant to tested feature.

[04:47] <dalek> roast/glr: In some cases the test still fails, but now for right reasons.

[04:47] <dalek> roast/glr: Place code inside try statements which was causing whole-file aborts.

[04:48] <dalek> roast/glr: Add an XXX GLR note to write specific tests for a known issue.

[04:48] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/ee49119c70

[04:55] <moritz> m: multi f($x) { uc $x }; say <a b c>.map(&f)' │

[04:55] <GLRelia> rakudo-moar a95902: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gBSB0r4N92␤Two terms in a row␤at /tmp/gBSB0r4N92:1␤------> 3lti f($x) { uc $x }; say <a b c>.map(&f)7⏏5' │␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤     …»

[04:55] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/FHQDFdQfw2␤Two terms in a row␤at /tmp/FHQDFdQfw2:1␤------> 3lti f($x) { uc $x }; say <a b c>.map(&f)7⏏5' │␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤     …»

[04:55] <moritz> m: multi f($x) { uc $x }; say <a b c>.map(&f)' 

[04:55] <GLRelia> rakudo-moar a95902: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8a3iH3J1Vc␤Two terms in a row␤at /tmp/8a3iH3J1Vc:1␤------> 3lti f($x) { uc $x }; say <a b c>.map(&f)7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»

[04:55] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Dk2D9zsMAE␤Two terms in a row␤at /tmp/Dk2D9zsMAE:1␤------> 3lti f($x) { uc $x }; say <a b c>.map(&f)7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»

[04:55] <moritz> m: multi f($x) { uc $x }; say <a b c>.map(&f)

[04:55] <GLRelia> rakudo-moar a95902: OUTPUT«Cannot call f(...); none of these signatures match:␤    ($x)␤  in block <unit> at /tmp/XfwB0_61hS:1␤␤»

[04:55] <camelia> rakudo-moar ac3488: OUTPUT«A B C␤»

[05:00] <JimmyZ> post GLR? so, we must write [[]] as [[],]?

[05:01] <dalek> rakudo/glr: 212d8f4 | moritz++ | src/core/Any-iterable-methods.pm:

[05:01] <dalek> rakudo/glr: map: make it work for multis

[05:01] <dalek> rakudo/glr: 

[05:01] <dalek> rakudo/glr: applies that same heuristic as nom:

[05:01] <dalek> rakudo/glr: $count = 1 if $count == Inf || $count == 0;

[05:01] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/212d8f407f

[05:03] <skids> moritz: That sould do the trick.  I wonder if any of the other listy functions are n-ary but not just calling .map.

[05:05] <skids> JimmyZ: seems to be the case.

[05:08] <ShimmerFairy> JimmyZ: as of now, yes (think of Parcels in pre-GLR, where  (1,)  made a one-elem Parcel), but I haven't heard from jnthn or anyone if that's the intention

[05:09] *** BenGoldberg left
[05:11] <JimmyZ> I dont know why [[]] is OK pre-GRL, but know has to be [[],]

[05:11] <JimmyZ> *now

[05:12] <skids> Both for technical reasons, and because the theory is that the single-item-rule will move some ugliness away from common cases to less common cases.

[05:14] <ShimmerFairy> skids: do you know if single-arg is supposed to be applied recursively? (that is, [[[...]]] -> [[...]] -> [...] -> ...)

[05:14] <skids> yes, as far as I can tell.

[05:15] <JimmyZ> I think it is no, since we want less flatten

[05:16] <skids> I'm pretty sure it is yes -- that is not considered "flattenning" but more like item collapse.

[05:16] <skids> flattenning is when inner parens are removed from ((),())-like constructs.

[05:17] <skids> And $ protects against flattenning, but not against collapse.

[05:18] <skids> The only thing that protects against collapse is a listy thing made by a comma (and if you do not supply a brace type for that, () is implied)

[05:21] <ShimmerFairy> I can kinda see the rationale for recursive single-arg; single-arg basically goes for the first thing that can definitely be a list, going into a 1-elem list when there's a chance you didn't mean for it to be wrapped in a list

[05:21] <skids> right and anything inside braces itself is an ergument, to the braces.

[05:21] <skids> *argument

[05:23] *** jack_rabbit joined
[05:24] <ShimmerFairy> skids: so if I have this right, the thinking is that [[1,2],[3,4]] is clearly an array of arrays, while [[1,2]] could be a one-elem aoa _or_ just one array that's in an extra [] by quirk of execution. Single-arg prefers to think the extra [] is a quirk in that case, if I got it right.

[05:25] <ShimmerFairy> I imagine that problem could more likely come up with a 1-elem (stuff), since () is used both for Lists and for grouping parts of expressions.

[05:28] <skids> ShimmerFairy: I think on one level that is considered a possible advantage, but its one candidate of a multi-reason :-)

[05:30] <ShimmerFairy> I bet recursive one-arg would probably be best demo'd with something like    @a = (gen-a-List())    ; is that surrounding pair of () meant to group the call (perhaps it used to be needed in that statement), or is it meant to make a 1-elem List? Perl 6 thinks you probably didn't mean an outer List there.

[05:30] *** kaare_ joined
[05:32] * skids greps perl6-all-modules for [[[^[]*]] -- 100 lines almost all of which are not perl6 syntax, in test files, [something[[something]something]], or in rx.

[05:33] <ShimmerFairy> _another_ way to phrase it would be that P6 assumes you were using list brackets just for grouping purposes unless it's got a literal list inside :P

[05:34] <ShimmerFairy> m: say [5 + 6] * 2    # I wonder...

[05:34] <GLRelia> rakudo-moar 212d8f: OUTPUT«2␤»

[05:34] <camelia> rakudo-moar ac3488: OUTPUT«2␤»

[05:35] *** mjgardner left
[05:45] <jdv79> m: say .uniname for "(", ")", "[", "]", "\{", "}"

[05:45] <GLRelia> rakudo-moar 212d8f: OUTPUT«LEFT PARENTHESIS␤RIGHT PARENTHESIS␤LEFT SQUARE BRACKET␤RIGHT SQUARE BRACKET␤LEFT CURLY BRACKET␤RIGHT CURLY BRACKET␤»

[05:45] <camelia> rakudo-moar ac3488: OUTPUT«LEFT PARENTHESIS␤RIGHT PARENTHESIS␤LEFT SQUARE BRACKET␤RIGHT SQUARE BRACKET␤LEFT CURLY BRACKET␤RIGHT CURLY BRACKET␤»

[05:46] <jdv79> do you guys mean parenthesis when you say list bracket or brace?

[05:49] *** xinming_ is now known as xinming

[05:51] <ShimmerFairy> yeah, I'm using "bracket" in the general sense unless I specify "square bracket"

[05:53] <jdv79> wonder why they aren't just called parenthesis, bracket, and brace?  guess unicode doesn't believe is terseness.

[05:56] <ShimmerFairy> m: say "<".uniname

[05:56] <GLRelia> rakudo-moar 212d8f: OUTPUT«LESS-THAN SIGN␤»

[05:56] <camelia> rakudo-moar ac3488: OUTPUT«LESS-THAN SIGN␤»

[05:58] *** xfix joined
[05:58] <ShimmerFairy> m: say "〈".uniname

[05:58] <GLRelia> rakudo-moar 212d8f: OUTPUT«LEFT ANGLE BRACKET␤»

[05:58] <camelia> rakudo-moar ac3488: OUTPUT«LEFT ANGLE BRACKET␤»

[05:59] <ShimmerFairy> jdv79: there are lots of BRACKETs in unicode, it's just by chance that () can be called parens and that {} can be called braces, and that most programmers mean [] when they say "brackets" :)

[06:01] <jdv79> oh right

[06:22] *** amurf joined
[06:26] <dalek> roast/glr: 000d49b | jdv79++ | S04-statements/if.t:

[06:26] <dalek> roast/glr: Un-todos for if return - went from Empty to () post-glr.  Fixes RT #124577.

[06:26] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/000d49ba67

[06:26] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124577

[06:27] *** amurf left
[06:29] <moritz> m: my @a = 1, 2, 3; @a»++

[06:29] <GLRelia> rakudo-moar 212d8f: ( no output )

[06:29] <camelia> rakudo-moar ac3488: ( no output )

[06:29] <moritz> m: my @a = 1, 2, 3; @a»++; say @a

[06:29] <GLRelia> rakudo-moar 212d8f: OUTPUT«1 2 3␤»

[06:29] <camelia> rakudo-moar ac3488: OUTPUT«2 3 4␤»

[06:29] <moritz> nine: ^^ another hyper thingy you might want to investigate

[06:30] <moritz> nine: makes S02-lexical-conventions/unspace.t fail

[06:33] <skids> Also has discrete tests in S03-metaops/hyper.t already, good.

[06:42] * moritz will be travelling most of the day, without Rakudo access :/

[06:55] *** xinming left
[07:03] *** leont joined
[07:17] <nine> .tell TimToady @a = %h is a mere nuisance. This is the real issue: sub foo(*@a) { say @a.perl }; foo({:a(1), :b(2)}); prints: [:a(1), :b(2)]. This is hurting in real code, e.g. Inline::Perl5.

[07:17] <yoleaux> 00:18Z <TimToady> nine: I don't think the case of initializing an array with a single hash will arise all that often, so I'm willing to leave it as a DIHWIDT for simplicity

[07:17] <yoleaux> nine: I'll pass your message to TimToady.

[07:18] *** laben joined
[07:19] <ShimmerFairy> doesn't **@a prevent flattening?

[07:19] <laben> hello p6'ers

[07:21] <ShimmerFairy> m: sub foo(**@a) { say @a.perl }; foo({a=>1, b=>2})

[07:21] <GLRelia> rakudo-moar 212d8f: OUTPUT«[${:a(1), :b(2)}]␤»

[07:21] <camelia> rakudo-moar ac3488: OUTPUT«(:a(1), :b(2))␤»

[07:21] <ShimmerFairy> nine: ^ that would work, if {} ends up still flattening because it's Iterable

[07:23] <laben> m: sub foo(**%a) { %a }; dd foo({ 'a' => 1, 'b' => 2})

[07:23] <GLRelia> rakudo-moar 212d8f: OUTPUT«% = {:a(1), :b(2)}␤»

[07:23] <camelia> rakudo-moar ac3488: OUTPUT«% = {:a(1), :b(2)}<>␤»

[07:23] <laben> m: sub foo(*%a) { %a }; dd foo({ 'a' => 1, 'b' => 2})

[07:23] <GLRelia> rakudo-moar 212d8f: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/HKxiH2wT3q:1␤  in block <unit> at /tmp/HKxiH2wT3q:1␤␤»

[07:23] <camelia> rakudo-moar ac3488: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/RZ2qRG0x3z:1␤  in block <unit> at /tmp/RZ2qRG0x3z:1␤␤»

[07:23] <moritz> travel&

[07:24] <laben> wait, why doesnt *% work there?

[07:25] <ShimmerFairy> *% is for named arguments, not positionals

[07:25] <laben> m: sub foo(*%a) { %a }; dd foo('a' => 1, 'b' => 2)

[07:25] <GLRelia> rakudo-moar 212d8f: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub foo at /tmp/qfSlzgGbx_:1␤  in block <unit> at /tmp/qfSlzgGbx_:1␤␤»

[07:25] <camelia> rakudo-moar ac3488: OUTPUT«Too many positionals passed; expected 0 arguments but got 2␤  in sub foo at /tmp/kzmWHleGOd:1␤  in block <unit> at /tmp/kzmWHleGOd:1␤␤»

[07:26] <laben> m: sub foo(*%a) { %a }; dd foo(:a(1), :b(2))

[07:26] <GLRelia> rakudo-moar 212d8f: OUTPUT«{:a(1), :b(2)}␤»

[07:26] <camelia> rakudo-moar ac3488: OUTPUT«{:a(1), :b(2)}<>␤»

[07:28] <masak> morning, #perl6

[07:29] *** bin_005 left
[07:29] *** bin_005 joined
[07:32] <skids> just in time for me to say goodnight, masak :-)

[07:35] *** skids left
[07:35] <masak> goodnight, skids :)

[07:36] *** xinming joined
[07:37] <ShimmerFairy> masak: I was wondering, could a macro like  macro startup { quasi { my $*ABC; my @*DEF; } }  ever be used to 'install' variables in a certain location? The idea is that a role or module or something could install the appropriate contextuals (in this example) for the user. (e.g. a role providing extra functions for a grammar could provide  <.startup>  instead of requiring the user to do :my $*ABC; etc.)

[07:38] *** darutoko joined
[07:39] <masak> it's a good question.

[07:39] <masak> let's pretend you asked it with ordinary lexicals instead of contextuals; it's easier :)

[07:39] <nine> ShimmerFairy: oh, yes, **@a could work for me. Still I'd say it's highly surprising to silently get a hash converted to an array

[07:40] <ShimmerFairy> nine: sure, but in case it doesn't get changed that workaround wouldn't be too annoying (just an extra *)  :)

[07:40] <masak> the answer is something like "yes, you can install things. but if you do it by name, you have to accept the consequences of being unhygienic."

[07:40] <nine> Amazing work people! While I slept we went down to 132 :)

[07:41] <ShimmerFairy> masak: I specifically ran into this by way of writing my own "role STD" for Perl 6 grammars, that is the worry/sorry/panic stuff. It'd be nice if the person doing my role didn't need to declare @*WORRIES and so on.

[07:41] *** kanl left
[07:42] *** kanl joined
[07:42] <ShimmerFairy> of course, the role could (or even should?) use role attributes instead of dynamics, but for now I'm fine with just having a kinda-copy of STD's stuff since it's not the main project I'm working on :)

[07:43] <masak> ShimmerFairy: if the quasi leaves its own block behind in the mainline (as it currently does), then contextuals are going to be a bit meaningless, because they'll be scoped to that block.

[07:44] <nine> m: my @a = 1, 2, 3; @a.map(*++); say @a;

[07:44] <GLRelia> rakudo-moar 212d8f: OUTPUT«2 3 4␤»

[07:44] <camelia> rakudo-moar ac3488: OUTPUT«2 3 4␤»

[07:44] <nine> m: my @a = 1, 2, 3; @a.map({$_++}); say @a;

[07:44] <GLRelia> rakudo-moar 212d8f: OUTPUT«2 3 4␤»

[07:44] <camelia> rakudo-moar ac3488: OUTPUT«2 3 4␤»

[07:44] <nine> m: my @a = 1, 2, 3; @a.map(++*); say @a;

[07:44] <GLRelia> rakudo-moar 212d8f: OUTPUT«2 3 4␤»

[07:44] <camelia> rakudo-moar ac3488: OUTPUT«2 3 4␤»

[07:44] <ShimmerFairy> masak: that's specifically why I tried seeing if macros could do it, since I know a more typical sub/method won't cut it :)

[07:46] <masak> ShimmerFairy: I'm not 100% clear yet how we'll do unhygiene. the answer to your question will be part of figuring that out.

[07:48] <ShimmerFairy> masak: yeah, it's admittedly not a very common case. I wonder how often there will be extra roles/classes for a grammar+actions setup that would be best served with grammar-level contextuals anyhow :P

[07:48] <masak> we'll see :)

[07:48] <masak> you ought to be able to do unconventional stuff with macros. that's the idea.

[07:49] <ShimmerFairy> masak: in a way, my example is asking for specific globals in the user's code, and then also offering a macro that declares them for the user :P

[07:51] <masak> aye

[08:09] *** rindolf joined
[08:10] *** RabidGravy joined
[08:11] *** amurf joined
[08:12] *** domidumont joined
[08:13] *** virtualsue joined
[08:15] <masak> I know of CPAN modules for `slurp`, but is there one for `spurt`?

[08:16] <masak> (Perl 5 modules, that is.)

[08:16] <nine> masak: File::Slurp has a write_file function

[08:16] *** amurf left
[08:16] <laben> http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html

[08:16] <nine> its slurp may be spelled read_file (which is what I use)

[08:17] *** domidumont left
[08:18] <masak> oki

[08:18] *** domidumont joined
[08:19] <nine> laben: thanks! I immediately forwarded this to my team

[08:19] <laben> you should thank leont++

[08:19] <labster> "If your needs are average (which is the case for most people), I'd recommend Path::Tiny."  heh.

[08:19] <nine> leont++ # indeed!

[08:19] <leont> :-)

[08:20] *** espadrine joined
[08:20] <laben> i found myself satisfied with leont's File::Sluper, but IO::All is amazing when needed

[08:23] <dalek> rakudo/glr: 93ade89 | (Stefan Seifert)++ | src/core/metaops.pm:

[08:23] <dalek> rakudo/glr: Fix my @a = 1, 2, 3; @a>>++; say @a;

[08:23] <dalek> rakudo/glr: 

[08:23] <dalek> rakudo/glr: We need to make unary hyper operators eager. Otherwise code with side effects

[08:23] <dalek> rakudo/glr: (like increment or decrement operators) may never actually execute if the

[08:23] <dalek> rakudo/glr: resulting List is not further processed.

[08:23] <dalek> rakudo/glr: 

[08:23] <dalek> rakudo/glr: Thanks to moritz++ for golfing this bug!

[08:23] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/93ade89ce5

[08:23] <nine> 130/1047 spec test files failing

[08:24] <vendethiel> .oO( nine++ will overflow at this rate )

[08:25] <nine> Well, that's probably my whole contribution for the day. Since I didn't actually go flying yesterday, I really have to take my chance today. May be the last for this year :/

[08:25] <laben> nine: good work! Happy flying and be safe :)

[08:25] <nine> laben: thanks :)

[08:26] <labster> m: Date.new('15555-05-05').say

[08:26] <GLRelia> rakudo-moar 212d8f: OUTPUT«Invalid Date string '15555-05-05'; use yyyy-mm-dd instead␤  in block <unit> at /tmp/7VlBQxJ4D5:1␤␤»

[08:26] <camelia> rakudo-moar ac3488: OUTPUT«Invalid Date string '15555-05-05'; use yyyy-mm-dd instead␤  in block <unit> at /tmp/ynwvif7aJK:1␤␤»

[08:26] <labster> m: Date.new('5555-05-05').later(years => 10000).say

[08:26] <GLRelia> rakudo-moar 212d8f: OUTPUT«15555-05-05␤»

[08:26] <camelia> rakudo-moar ac3488: OUTPUT«15555-05-05␤»

[08:27] <labster> I'm somewhat unimpressed with this.

[08:28] <nine> laben: may be, but let's face it: this will catch a whole lot of bugs while very few people are going to need to input dates 10000 years hence

[08:28] <laben> ?

[08:29] *** KCL_ joined
[08:29] <laben> from wiki page of ISO 8601: To represent years before 0000 or after 9999, the standard also permits the expansion of the year representation but only by prior agreement between the sender and the receiver.

[08:29] <vendethiel> .oO( Perl 6 received your date and isn't happy with it )

[08:29] <nine> Well the receiver doesn't agree in this case :)

[08:29] <nine> Because in most cases, such dates are the results of bugs

[08:30] <laben> labster: i dont think it would be a problem to reject > 9999 years in the constructor, given that there is still a way to construct them afterwards

[08:31] <nine> laben: oh, sorry for the confusion, tab completion error. I meant labster :)

[08:31] <laben> maybe we could say that the error is LTA and it could make a reference to ISO 8601 in that case

[08:31] <ShimmerFairy> Well, the error tells you exactly how to fix the problem (they 'yyyy-mm-dd' part) :)

[08:32] <laben> nine: no problem :)

[08:32] *** KCL left
[08:32] <laben> ShimmerFairy: yes but we could say why it is invalid

[08:33] <labster> m: Date.new(15555, 5, 5).say

[08:33] <GLRelia> rakudo-moar 93ade8: OUTPUT«15555-05-05␤»

[08:33] <camelia> rakudo-moar ac3488: OUTPUT«15555-05-05␤»

[08:33] <laben> O.o could it be there is no checking... oh well

[08:33] <labster> I think it's the output the bothers me more than the input.

[08:34] <laben> you mean you would like formatted output by default?

[08:34] <labster> The input there isn't an ISO 8601 string, so it should be valid (depending on if we have a day of leap seconds or not by then)

[08:34] <ShimmerFairy> labster: ? the last example you ran wasn't an ISO 8601 string and was gladly accepted

[08:35] *** domidumont left
[08:35] <labster> m: Date.new(15555, 5, 5).print

[08:35] <GLRelia> rakudo-moar 93ade8: OUTPUT«15555-05-05»

[08:35] <camelia> rakudo-moar ac3488: OUTPUT«15555-05-05»

[08:35] <labster> Well, the output looks 8601, but isn't necessarily.

[08:37] <ShimmerFairy> the output still counts under 8601, under the "permits expansion of the year representation"

[08:37] <labster> No it doesn't.  No sign.

[08:37] <ShimmerFairy> What sign?

[08:37] <labster> Exactly!

[08:38] <labster> An expanded year representation [±YYYYY] must ... be prefixed with a + or − sign

[08:39] <ShimmerFairy> Ah, so the output should be a bit better in that regard. Though by that rule your string-input with the expanded year was rightfully unaccepted :)

[08:47] <laben> still, it's quite a nuisance that i cannot freely read that standard. i almost prefer IETF RFC 3339 just for that reason

[08:53] <ShimmerFairy> laben: agreed, it's one of my biggest gripes with certain standards bodies. Haven't heard of 3339 though, I'll check it out.

[08:53] <labster> That is the nice thing about standards, so many to choose from.

[08:54] <nine> m: my @a = (1, 2, 3); my @b = map { hash("v" => $_, "d" => $_ * 2) }, @a; say @b.perl;

[08:54] <GLRelia> rakudo-moar 93ade8: OUTPUT«[${:d(2), :v(1)}, ${:d(4), :v(2)}, ${:d(6), :v(3)}]␤»

[08:54] <camelia> rakudo-moar ac3488: OUTPUT«[:d(2), :v(1), :d(4), :v(2), :d(6), :v(3)]<>␤»

[08:54] <laben> it's basically the equivalent but from IETF and free to read

[08:54] *** cognominal left
[08:55] <nine> m: my @a = (1, 2, 3); my @b = map { {"v" => $_, "d" => $_ * 2} }, @a; say @b.perl;

[08:55] <GLRelia> rakudo-moar 93ade8: OUTPUT«[$(:v(1), :d(2)), $(:v(2), :d(4)), $(:v(3), :d(6))]␤»

[08:55] <camelia> rakudo-moar ac3488: OUTPUT«[:v(1), :d(2), :v(2), :d(4), :v(3), :d(6)]<>␤»

[08:56] <ShimmerFairy> laben: yeah, I'll look over RFC 3339 and might consider having Perl 6 officially follow that instead of ISO 8601, on the basis of not letting private standards get precedence :P

[08:56] <laben> m: my @a = (1, 2, 3); my @b = map { %("v" => $_, "d" => $_ * 2) }, @a; say @b.perl;

[08:56] <camelia> rakudo-moar ac3488: OUTPUT«[:d(2), :v(1), :d(4), :v(2), :d(6), :v(3)]<>␤»

[08:56] <GLRelia> rakudo-moar 93ade8: OUTPUT«[${:d(2), :v(1)}, ${:d(4), :v(2)}, ${:d(6), :v(3)}]␤»

[08:56] <ShimmerFairy> .oO(If a standards body produces a standard, but no-one's allowed to view it, does it make a standard?)

[08:56] <laben> ShimmerFairy: you're allowed, but need to pay

[08:57] <ShimmerFairy> s/view/freely view/ would've been clearer :)

[08:57] <labster> I'm not sure why ISO 8601 isn't on the Pirate Bay, everything is supposed to be there :P

[08:57] <ShimmerFairy> (but would've messed with the meter of the original saying)

[08:57] <nine> For many ISO standards one can find drafts online for free. Helped me tremendously when I wrote my master's thesis :)

[08:58] <ShimmerFairy> labster: I recall poking around and finding the floating point standard somewhere once :)

[08:58] <laben> whatevs is needed to get out of the annoying imperial mm/dd/yyyy date format

[08:59] <labster> ah yes, we American imperialists want to take over your dates.

[08:59] <ShimmerFairy> I use 23 August 2015 myself :)

[08:59] <laben> O.o is it not called imperial while the other is metric?

[09:00] <ShimmerFairy> laben: yes, the opposite of the metric system is imperial, but datetime formats don't count for that :)

[09:00] <ShimmerFairy> Just "US" and "European" and so on :)

[09:01] <laben> ShimmerFairy: oh, ok. i thought it was somehow linked to the inch/pound system

[09:01] <laben> i did not mean to offend anyone, forgive me

[09:01] <ShimmerFairy> nah, it's just formatting when it comes to datetimes :)

[09:03] <labster> I give laben an inch, and laben takes the whole meter stick.

[09:04] <laben> o.o that came out a bit... wrong

[09:05] <labster> Anyway, according to RFC 3339, one can use lowercase t and z in ISO 8601.  Interesting, didn't know that, and now apparently a bug we have.

[09:07] <jdv79> theres no need for those variances

[09:07] <jdv79> is T and Z a hardship?

[09:08] <TimToady> ugly and visually hard to spot

[09:08] <yoleaux> 07:17Z <nine> TimToady: @a = %h is a mere nuisance. This is the real issue: sub foo(*@a) { say @a.perl }; foo({:a(1), :b(2)}); prints: [:a(1), :b(2)]. This is hurting in real code, e.g. Inline::Perl5.

[09:08] * labster didn't write the standard.

[09:08] <TimToady> t would help since it's a shorter letter

[09:10] <jdv79> i find uppercase more visually attention grabbing since morst text is not butok

[09:10] <jdv79> *most

[09:12] *** telex left
[09:14] *** telex joined
[09:14] <labster> Anyway, I'm starting to think that Perl 6 should just make a "prior agreement" with the programmer to accept >4 digit dates and represent everything on the proleptic Gregorian calendar, because it makes no sense to be liberal in what we emit and conservative in what we accept.  (Do we have a EULA?)

[09:15] <labster> with a sign required in that case

[09:17] <ShimmerFairy> I can see why the RFC would allow for lowercase letters, since they would be easier to see amongst the "uppercase" digits we use :)

[09:18] <jdv79> sure.  but aren't most date acceptors in the world using 8601

[09:19] <jdv79> if we emit non-8601 by default that might cause unfortunate issues

[09:19] <ShimmerFairy> I have a feeling most things accept varying subsets of 8601 by chance, but I'm not sure the percentage of things that specifically set out for 8601 :)

[09:19] <ShimmerFairy> (we don't even accept Duration strings, IIRC)

[09:19] <jdv79> i have written a few date handlers and they only accept T and Z

[09:20] <labster> jdv79: Then you have only implemented a subset of ISO 8601.

[09:23] <masak> please submit a rakudobug about t and z

[09:24] <labster> Well, there's a reasonable solution on output, though.  Just have a method that checks that the date can produce strict 8601 values (4 digit year, non-fractional time zones), maybe .as-iso-8601, where print and gist are more permissive.

[09:24] *** araujo left
[09:24] <ShimmerFairy> Note that you can give DateTime your own date formatter if needed :)

[09:25] <labster> masak: will do.

[09:26] <jdv79> oh oww

[09:26] *** araujo joined
[09:26] <jdv79> *wow

[09:26] *** araujo left
[09:27] *** araujo joined
[09:27] <jdv79> i like how the lowercase t and z are not indicated on the wikipedia page or the ISO8601 derived ABNF in rfc3339

[09:27] * jdv79 also abhors non-free standards

[09:28] <ShimmerFairy> I know it's a minor thing, but I think I'd prefer if Perl 6's default was a standard anyone can read (RFC 3339) instead of one you have to pay for or hope wikipedia's got it right (ISO 8601)

[09:28] <jdv79> yeah yeah, that's fine

[09:29] <jdv79> i have very little love for 8601 in general.  its too mushy and varied and doesn't cover some cases well.

[09:30] <jdv79> kinda like oauth 2.  too many cooks in the kitchen; some lacking the wisdom to be allowed in the kitchen

[09:31] <laben> you consider it minor just because date-time parsing is not an usual use-case. if you had the same situation in parsing a file or something like that, an army of pitchforks would be out

[09:31] <ShimmerFairy> taking a quick peek at the ABNF, I still say BNF syntax is ugly and hard to read, and that P6 regexes and grammars are much better :P

[09:32] <labster> ShimmerFairy: I'm not opposed to RFC 3339, I just would like to support dates outside of 0000 .. 9999

[09:32] <vendethiel> jnthn: isn't there a race condition in http://jnthn.net/papers/2015-yapcasia-concurrency.pdf slide 59 for the "unless"?

[09:32] <ShimmerFairy> sure, I don't see why not (since you can pass years larger/smaller than that to the non-string-parsing versions)

[09:33] <ShimmerFairy> jdv79: note though that the ABNF in the RFC is specifically an attempt to create a grammar for 8601, not necessarily whatever extensions the RFC provides (e.g. 't' and 'z') :)

[09:34] <labster> Actually it's the grammar providing the extensions.

[09:35] <jdv79> huh

[09:35] <jdv79> "Appendix A contains an attempt to translate the complete syntax of ISO 8601 into ABNF"

[09:36] <jdv79> i guess "attempt" gives a hint

[09:36] <jdv79> though complete is a rather specific word:)

[09:36] <vendethiel> .ask jnthn isn't there a race condition in http://jnthn.net/papers/2015-yapcasia-concurrency.pdf slide 59 for the "unless"?

[09:36] <yoleaux> vendethiel: I'll pass your message to jnthn.

[09:36] <jdv79> haha

[09:36] *** leont left
[09:36] <jdv79> lame all around

[09:37] <ShimmerFairy> jdv79: actually, it appears that ABNF grammars tend to prefer case insensitivity, so just imagine :i adverbs on all the rules :P

[09:40] *** cognominal joined
[09:41] <jdv79> oh. look at that.  that explains a few things i've noticed with them.

[09:42] * jdv79 should read the whole standard

[09:43] *** diana_olhovik_ joined
[09:43] <ShimmerFairy> me too, then I'll be able to comment more effectively on whether we should use it :)

[09:43] <laben> how do we differentiate lazy-but-finite and lazy-and-infinite in Seq/List/Array etc?

[09:44] <jdv79> that's an unfortunate aspect though.  when i see "asdf" in a doc i think "asdf" not "[aA][sS][dD][fF]"

[09:44] <ShimmerFairy> There's a value in making you specify :i  :)

[09:45] <jdv79> laben: what does that even mean?

[09:45] <laben> jdv79: .map on a finite list produces a Seq, which is lazy but will be finite anyway

[09:45] <ShimmerFairy> $file.lines()  vs.  1..*  , for example

[09:46] <laben> jdv79: instead .map on a infinite list produces a Seq but it will be infinite

[09:46] <jdv79> what i meant to ask was why is that distinction necessary.  sorry.

[09:47] *** cognominal left
[09:47] <laben> it is IMO for hypers which are eager -> cannot work well with infinites but still do work on lazy-finite

[09:48] <laben> being eager, they pull everything, which is too much if Inf, but not too much if finite, wheter lazy or not

[09:49] *** bin_005 left
[09:50] *** Begi joined
[09:51] <labster> ok, good night everyone

[09:53] <Begi> Is the HTTP::Client module doesn't support the https protocol ? What can I use ?

[09:54] <laben> Begi: did you try LWP::Simple?

[09:54] <Begi> laben : not yet, I'll take a look

[09:54] *** domidumont joined
[09:55] <jdv79> HTTP::UserAgent may work

[09:56] <jdv79> install IO::Socket::SSL too though

[09:57] *** bin_005 joined
[09:58] *** cognominal joined
[09:59] *** domidumont left
[10:02] <Begi> jdv79: currently , it works with Lwp :: Simple

[10:02] <jdv79> nice

[10:04] *** xinming left
[10:05] *** xinming joined
[10:27] *** salva joined
[10:29] *** Begi left
[10:37] *** bin_005 left
[10:37] <jdv79> m: my @a = 1, (if 0 {2}), 3;@a.perl.say; # seems legit on glr

[10:37] <GLRelia> rakudo-moar 93ade8: OUTPUT«[1, 3]␤»

[10:37] <camelia> rakudo-moar ac3488: OUTPUT«[1, 3]<>␤»

[10:38] <jdv79> m: my @a = 1, (0 ?? 2 !! ()), 3;@a.perl.say; # what now?

[10:38] <GLRelia> rakudo-moar 93ade8: OUTPUT«[1, $(), 3]␤»

[10:38] <camelia> rakudo-moar ac3488: OUTPUT«[1, 3]<>␤»

[10:38] <jdv79> shouldn't that be the same as the if example?

[10:40] <ShimmerFairy> nope, you returned an empty List in the second one

[10:41] <jdv79> so what is if returning then?

[10:42] <ShimmerFairy> m: say (if 0 {2}).perl

[10:42] <GLRelia> rakudo-moar 93ade8: OUTPUT«()␤»

[10:42] <camelia> rakudo-moar ac3488: OUTPUT«Empty␤»

[10:42] *** diana_olhovik_ left
[10:42] <laben> m: (if 0 {2}).WHAT.say

[10:42] <camelia> rakudo-moar ac3488: OUTPUT«Empty␤»

[10:42] <GLRelia> rakudo-moar 93ade8: OUTPUT«(Slip)␤»

[10:42] <jdv79> is the () from the if or the visible () there?

[10:43] <jdv79> ah

[10:43] <laben> m: (do if 0 {2}).WHAT.say

[10:43] <GLRelia> rakudo-moar 93ade8: OUTPUT«(Slip)␤»

[10:43] <camelia> rakudo-moar ac3488: OUTPUT«Empty␤»

[10:44] <ShimmerFairy> m: say (0 ?? 2 !! ()).WHAT

[10:44] <GLRelia> rakudo-moar 93ade8: OUTPUT«(List)␤»

[10:44] <camelia> rakudo-moar ac3488: OUTPUT«(Parcel)␤»

[10:44] <ShimmerFairy> Slip could use a better .gist methinks :)

[10:44] <laben> m: say (0 ?? 2).WHAT

[10:44] <GLRelia> rakudo-moar 93ade8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/h8tux4t3Z7␤Unexpected closing bracket␤at /tmp/h8tux4t3Z7:1␤------> 3say (0 ?? 27⏏5).WHAT␤»

[10:44] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/1YKCr1pGzE␤Unexpected closing bracket␤at /tmp/1YKCr1pGzE:1␤------> 3say (0 ?? 27⏏5).WHAT␤»

[10:44] <jdv79> so those are correct?  if so i'll just fix up the relevant test files.

[10:44] <laben> dumb me, that's the ternary op

[10:44] <jdv79> seems close enough

[10:45] <laben> pre-glr the empty list got flattened away, now it doesnt

[10:45] <laben> m: say (0 ?? 2 !! slip()).WHAT

[10:45] <GLRelia> rakudo-moar 93ade8: OUTPUT«(Slip)␤»

[10:45] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/rDpVj6hO7n␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[10:46] <ShimmerFairy> jdv79: for the ternary, you should write  (0 ?? 2 !! ().Slip)  (or |() ) to get the same behavior

[10:46] <laben> m: my @a = 1, (0 ?? 2 !! slip()), 3;@a.perl.say; # what now?

[10:46] <jdv79> cool

[10:46] <GLRelia> rakudo-moar 93ade8: OUTPUT«[1, 3]␤»

[10:46] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/La8dmXeYgk␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[10:54] <dalek> roast/glr: 5b958fe | jdv79++ | S04-statement-modifiers/if.t:

[10:54] <dalek> roast/glr: Adjust for glr by returning slip() instead of ().

[10:54] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/5b958fe5eb

[10:55] <jdv79> ugh, pause is a rabbithole.  i was hoping to catch a break.  seems it'll be a slog.

[10:55] <jdv79> but lunch&

[11:11] <vendethiel> jnthn++ # nice talk

[11:19] *** virtualsue left
[11:25] *** brrt joined
[11:32] *** BenGoldberg joined
[11:33] *** [Sno] left
[11:33] <brrt> yes, jnthn++ for an awesome and inspiring talk

[11:38] *** FROGGS_ joined
[11:40] *** [Sno] joined
[11:41] *** cognominal left
[11:42] *** FROGGS left
[11:42] *** rindolf left
[11:49] *** amurf joined
[11:50] *** Cail left
[11:50] *** Cail joined
[11:52] *** [Sno] left
[11:53] *** amurf left
[12:07] *** rindolf joined
[12:10] *** TEttinger left
[12:14] <masak> vendethiel, brrt: waitwait, neither of you are in YAPC::Asia. is there a video somewhere?

[12:15] <brrt> slides

[12:15] <brrt> not sure if a video is online

[12:15] <brrt> but the slides themselves are quite isnpiring :-)

[12:15] <brrt> in the sense of 'wait, perl6 is *cool*'

[12:16] <masak> http://jnthn.net/papers/2015-yapcasia-concurrency.pdf ?

[12:16] <brrt> aye

[12:17] <masak> "You get one goto a month!" :P

[12:18] <brrt> we use them sparingly

[12:19] <brrt> actually, i get as many gotos as i like, but my case is special

[12:19] <brrt> and they're generated goto's, not hand-written

[12:20] <masak> can you `start` something in one thread and `await` it in another?

[12:21] <masak> brrt: in a way, `if`s and `while`s are also generated `goto`s.

[12:21] <brrt> masak: i think you can

[12:22] <brrt> yeah, of course. it's just i'm doing the generating and seeing them in action

[12:25] *** liztormato joined
[12:26] *** Cail left
[12:26] *** Cail joined
[12:27] *** Cail left
[12:27] <liztormato> m: say ( 0 ?? 42 !! |() ).WHAT

[12:27] <GLRelia> rakudo-moar 93ade8: OUTPUT«(Slip)␤»

[12:27] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5dkdQwboQr␤Arg-flattening | is only valid in an argument list␤at /tmp/5dkdQwboQr:1␤------> 3say ( 0 ?? 42 !! |7⏏5() ).WHAT␤»

[12:28] <liztormato> 1m: say ( 0 ?? 42 !! |() ).perl

[12:29] <liztormato> 1m: say ( 0 ?? 42 !! |() ).perl

[12:30] <ShimmerFairy> m: say "that you're both still alive"

[12:30] <GLRelia> rakudo-moar 93ade8: OUTPUT«that you're both still alive␤»

[12:30] <camelia> rakudo-moar ac3488: OUTPUT«that you're both still alive␤»

[12:30] <ShimmerFairy> weird

[12:31] <laben> m: say (0?? 42 !! slip()).perl

[12:31] <GLRelia> rakudo-moar 93ade8: OUTPUT«()␤»

[12:31] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PBtQO5AZQI␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[12:31] <laben> m: say (0?? 42 !! |()).perl

[12:31] <GLRelia> rakudo-moar 93ade8: OUTPUT«()␤»

[12:31] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CsgClx8c12␤Arg-flattening | is only valid in an argument list␤at /tmp/CsgClx8c12:1␤------> 3say (0?? 42 !! |7⏏5()).perl␤»

[12:32] <vendethiel> masak: I'm sure you didn't mean me there ;-)

[12:32] <liztormato> masak: I have shot a video but it's currently HD and 5G

[12:32] <vendethiel> masak: actually I misread. Well, I just found it in the clog (like you did)

[12:33] <brrt> liztormato: if you can upload it somewhere, there's probably a volunteer ready to transcode it

[12:33] <liztormato> Need to post process to something downloadable

[12:33] <brrt> ffmpeg? :-)

[12:33] <liztormato> Yeah.

[12:34] <liztormato> Never used the ffmpeg CLI before, but I guess I can find out about arguments online

[12:35] <ShimmerFairy> Interesting, I've only ever used ffmpeg on commandline :)

[12:36] <brrt> i'm quite familiar with the ffmpeg command line

[12:36] <brrt> if you have it installed i can guide you through

[12:36] <masak> liztormato: 's ok. I'm currently enjoying the slides. :)

[12:38] *** Timbus joined
[12:39] <vendethiel> ShimmerFairy: you never used VLC? :P

[12:40] <liztormato> Should be able to do it in 36 hours or so

[12:40] <laben> mpv for the win

[12:40] <ShimmerFairy> vendethiel: when I say 'ffmpeg', I'm specifically referring to the converter, not ffplay or whatever uses FFMPEG to _play_ things :)

[12:40] <vendethiel> *g*

[12:41] <masak> how implemented is `whenever`?

[12:41] <masak> m: supply { whenever {} }

[12:41] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5===␤Expression needs parens to avoid gobbling block␤at /tmp/uvg0IRJUMx:1␤------> 3supply { whenever {}7⏏5 }␤Missing block (apparently taken by expression)␤at /tmp/uvg0IRJUMx:1␤------> 3supply { whenever {} 7⏏5}␤␤»

[12:41] <GLRelia> rakudo-moar 93ade8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yk37Wb0mBo␤Undeclared routines:␤    supply used at line 1␤    whenever used at line 1␤␤»

[12:41] <masak> aha. thought I had missed something big there :)

[12:42] <masak> jnthn doesn't show NYI stuff all that often, so I was willing to assume it had been implemented already :)

[12:42] <BenGoldberg> m: (|()).perl.say

[12:42] <GLRelia> rakudo-moar 93ade8: OUTPUT«()␤»

[12:42] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KI_B68xy1D␤Arg-flattening | is only valid in an argument list␤at /tmp/KI_B68xy1D:1␤------> 3(|7⏏5()).perl.say␤»

[12:42] <ShimmerFairy> masak: if a concurrency talk wasn't out-of-order with the implementation, I'

[12:42] <ShimmerFairy> d have some serious questions :P

[12:43] <masak> "Passengers checking in for a flight at the same time must not be able to choose the same seat!" # jnthn and I have joked about trying this many times, but never really got around to it

[12:43] <masak> ShimmerFairy: you know it's not *mandated* for a talk to confuse use and mention, right? :P

[12:45] <masak> jnthn++ # http://jnthn.net/papers/2015-yapcasia-concurrency.pdf

[12:49] <liztormato> masak: whenever lives in nom afaik. . .race lives in glr

[12:49] <ShimmerFairy> m: use nqp; my @a := nqp::list()

[12:49] <GLRelia> rakudo-moar 93ade8: OUTPUT«Type check failed in binding; expected 'Positional' but got 'List'␤  in block <unit> at /tmp/6i_tBE3ilw:1␤␤»

[12:49] <camelia> rakudo-moar ac3488: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Parcel'␤  in block <unit> at /tmp/gWryi2ag_v:1␤␤»

[12:49] <ShimmerFairy> m: use nqp; my token T { :my @a := nqp::list(); }

[12:49] <GLRelia> rakudo-moar 93ade8: ( no output )

[12:49] <camelia> rakudo-moar ac3488: ( no output )

[12:49] <ShimmerFairy> I'm guessing it works in a grammar because the regex code lives in NQP? :)

[12:56] *** diana_olhovik_ joined
[12:56] <masak> m: my @a = 1, 2, 3; my $s = supply { whenever @a -> $n { emit $n } }; $s.tap({ say "It's $^n!" })

[12:56] <GLRelia> rakudo-moar 93ade8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/I5_lFX28Ri␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/I5_lFX28Ri:1␤------> 3 = 1, 2, 3; my $s = supply { whenever @a7⏏5 -> $n { emit $n } }; $s…»

[12:56] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/V25ei2Od6n␤Undeclared routine:␤    emit used at line 1. Did you mean 'exit'?␤␤»

[12:57] <masak> hm.

[12:57] <masak> m: my @a = 1, 2, 3; my $s = supply { whenever @a -> $n { say "It's $n!" } }

[12:57] <GLRelia> rakudo-moar 93ade8: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CIIKrBA9iT␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/CIIKrBA9iT:1␤------> 3 = 1, 2, 3; my $s = supply { whenever @a7⏏5 -> $n { say "It's $n!" …»

[12:57] <camelia> rakudo-moar ac3488: ( no output )

[13:09] *** khw joined
[13:14] *** rmgk_ joined
[13:14] *** rmgk left
[13:14] *** rmgk_ is now known as rmgk

[13:21] *** brrt left
[13:23] *** yqt joined
[13:25] *** liztormato left
[13:31] *** aborazmeh joined
[13:31] *** aborazmeh left
[13:31] *** aborazmeh joined
[13:48] *** Ven joined
[13:54] *** zakharyas joined
[13:55] <masak> m: say Date.new(2015, 1, 31).later(:1month)

[13:55] <GLRelia> rakudo-moar 93ade8: OUTPUT«day of 2015/2 out of range. Is: 31, should be in 1..28␤  in block <unit> at /tmp/3PKIjbTajg:1␤␤»

[13:55] <camelia> rakudo-moar ac3488: OUTPUT«day of 2015/2 out of range. Is: 31, should be in 1..28␤  in block <unit> at /tmp/LVnRjh9E9X:1␤␤»

[13:55] <masak> do we want this to work?

[13:57] <laben> probably, but how do you define "a month later"?

[13:57] <masak> one possible definition is: start of next month + current number of days in.

[13:57] <masak> mostly asking: do we want that?

[13:58] <masak> m: say Date.new(2015, 2, 3).later(:1month)

[13:58] <camelia> rakudo-moar ac3488: OUTPUT«2015-03-03␤»

[13:58] <GLRelia> rakudo-moar 93ade8: OUTPUT«2015-03-03␤»

[13:58] <Zoffix> The ambiguity on the definition would likely cause problems

[13:58] <laben> maybe it's better for consistency to not provide a month option and only days

[13:58] <masak> presumably, there'd be some overlap, and Date.new(2015, 1, 31).later(:1month) would come out to the same as the above.

[13:58] <masak> laben: I think a month option is quite nice (and natural) to have.

[13:59] <masak> laben: but the question is how we handle "month skew"

[13:59] <masak> what's Least Surprise here? and what's least likely to burn people and least likely to have them hate us? :)

[13:59] <ShimmerFairy> masak: I could see your definition, but I also think "one month later" or "three months later" is not a granular phrase in English, so one might expect the day value be clamped as needed.

[14:00] <ShimmerFairy> *are not granular phrases

[14:00] <masak> here's another possibility: if we ever overflow (like we did above), just place us on the 1st of the next month.

[14:00] <laben> checking what other languages do? like python. let's see if it makes sense

[14:01] <masak> remember, .later and .earlier are already a "fix" or improvement on CPAN's DateTime::Duration

[14:01] <ShimmerFairy> how so?

[14:01] <masak> which has some bad failure modes. notably, it adds the components of the duration in an unexpected order.

[14:01] <masak> and there's not really a "right" order when one starts to think about it.

[14:01] <masak> and so .later and .earlier forces you to consider the order yourself, in your program.

[14:02] <masak> all you can do with them is add individual components.

[14:03] <masak> I think I don't like the current error, because "one month later" doesn't feel like an operation that should fail :/

[14:03] <ShimmerFairy> masak: I personally think the :month adverb on .later and .earlier should probably mimic the non-granularity of the equivalent phrases in English; that is, get the month right, fudge the day if needed :)

[14:03] <masak> anyone against us making "one month later than Jan 31st" Mar 1st?

[14:03] <masak> ShimmerFairy: right, agree.

[14:04] <masak> ShimmerFairy: we basically "round up" until we get a valid date again.

[14:04] <ShimmerFairy> masak: After all, even on my birthday I would probably mean February if I said "next month". And my birthday is 31 Jan  :)

[14:04] <masak> "next month" isn't exactly the same thing as "one month later". but point taken. :)

[14:04] <masak> let me run spectests and attempt the change.

[14:05] <masak> are people committing to nom currently? I know there's a glr thing going on...

[14:05] <laben> as far as python goes, timedelta (the object  they use for durations) goes up to weeks, but no months

[14:05] <ShimmerFairy> masak: I would personally adjust the month appropriately, and then clamp the day value to the new month's range. Feels most natural to me.

[14:05] <ShimmerFairy> masak: I'm doing my work against nom, since I'm not doing GLR-related things. But there's definitely more activity on glr these days :)

[14:06] <masak> laben: aw, they don't do years?

[14:06] <laben> masak: nope

[14:06] <masak> ShimmerFairy: more activity, but no ban against committing on nom?

[14:06] <laben> just checked for py2 and py3

[14:06] <ShimmerFairy> masak: To be fair, everything after weeks is, strictly speaking, irregular :P

[14:06] * moritz back home after three weeks travel

[14:06] <ShimmerFairy> No, certainly no policy against committing to nom

[14:06] <masak> moritz! \o/

[14:07] <masak> ShimmerFairy: years are irregular, but easlier to count with than months :)

[14:07] <laben> bah, they could have added years just as easily. i think they didnt to not highlight the missing month option

[14:07] <laben> or maybe they have some trudgery going on with leap years

[14:07] <masak> well, theirs is the "safe" option, for sure.

[14:08] <laben> yeah, i guess you wouldnt really be faulted if the core Date object was as "safe" and maybe provide the rest with a module

[14:09] <laben> either way, just need to mkae sure it's documented and understandable

[14:09] <laben> make*

[14:10] <ShimmerFairy> masak: btw, in case you missed it, there was talk of making Perl 6 technically follow RFC 3339 as opposed to ISO 8601, for the sake of using a standard you don't need to pay money to read :)

[14:14] <moritz> how different are RFC 3339 and ISO 8601

[14:14] <moritz> ?

[14:15] *** FROGGS_ is now known as FROGGS

[14:15] <FROGGS> o/

[14:15] <moritz> FR\OGGS

[14:15] <ShimmerFairy> Not very, AFAIK. You can use lowercase letters instead, for example (2015-12-25t00:00:00z for example)

[14:16] <ShimmerFairy> It also allows -00:00 as an offset meaning "timezone unknown/unimportant", where ISO 8601 forbids "-00:00" as an offset.

[14:17] <ShimmerFairy> link to rfc: https://tools.ietf.org/html/rfc3339

[14:19] <dalek> roast/glr: 3a4034c | moritz++ | rosettacode/sierpinski_triangle.t:

[14:19] <dalek> roast/glr: Explicitly flatten in Sierpinski triangle

[14:19] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/3a4034cfdd

[14:20] *** virtualsue joined
[14:22] *** aborazmeh left
[14:22] <laben> =.= in a way ietf is similar to w3c, they like recursion and eating dog food. they have an rfc (2026) to describe how to do rfc (and other docs)

[14:25] <dalek> roast/glr: 7516075 | moritz++ | integration/advent2012-day10.t:

[14:25] <dalek> roast/glr: Avoid a test erroring out

[14:25] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/75160753eb

[14:26] *** virtualsue left
[14:34] *** aborazmeh joined
[14:34] *** aborazmeh left
[14:34] *** aborazmeh joined
[14:38] <moritz> m: say map { $_ * 2 }, ^4

[14:38] <GLRelia> rakudo-moar 93ade8: OUTPUT«0 2 4 6␤»

[14:38] <camelia> rakudo-moar ac3488: OUTPUT«0 2 4 6␤»

[14:39] *** virtualsue joined
[14:39] *** virtualsue left
[14:39] <moritz> m: my %r=(^8)>>.fmt("%03b") Z (0,1,1,1,1,0,0,0);; say %r.perl

[14:39] <GLRelia> rakudo-moar 93ade8: OUTPUT«{"000 0" => $("001", 1), "010 1" => $("011", 1), "100 1" => $("101", 0), "110 0" => $("111", 0)}␤»

[14:39] <camelia> rakudo-moar ac3488: OUTPUT«{"000" => 0, "001" => 1, "010" => 1, "011" => 1, "100" => 1, "101" => 0, "110" => 0, "111" => 0}<>␤»

[14:39] <FROGGS> m: say grep-index(Int, 2, [], 4, [], 5)

[14:39] <GLRelia> rakudo-moar 93ade8: OUTPUT«0 1 2␤»

[14:39] <camelia> rakudo-moar ac3488: OUTPUT«0 2 4␤»

[14:40] <moritz> m: my %r=(^8)>>.fmt("%03b") Z=> (0,1,1,1,1,0,0,0);; say %r.perl

[14:40] <camelia> rakudo-moar ac3488: OUTPUT«{"000" => 0, "001" => 1, "010" => 1, "011" => 1, "100" => 1, "101" => 0, "110" => 0, "111" => 0}<>␤»

[14:40] <GLRelia> rakudo-moar 93ade8: OUTPUT«{"000" => 0, "001" => 1, "010" => 1, "011" => 1, "100" => 1, "101" => 0, "110" => 0, "111" => 0}␤»

[14:41] <FROGGS> m: sub foo(*@v) { say @v.perl }; foo(1, [], 2, [])

[14:41] <GLRelia> rakudo-moar 93ade8: OUTPUT«[1, 2]␤»

[14:41] <camelia> rakudo-moar ac3488: OUTPUT«[1, [], 2, []]<>␤»

[14:41] <FROGGS> m: sub foo(**@v) { say @v.perl }; foo(1, [], 2, [])

[14:41] <GLRelia> rakudo-moar 93ade8: OUTPUT«[1, $[], 2, $[]]␤»

[14:41] <camelia> rakudo-moar ac3488: OUTPUT«(1; ; 2; )␤»

[14:42] *** aborazmeh left
[14:42] <dalek> roast/glr: bdb37bb | moritz++ | integration/advent2009-day23.t:

[14:42] <dalek> roast/glr: Fix Christmas Tree

[14:42] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/bdb37bbd89

[14:42] *** aborazmeh joined
[14:42] *** aborazmeh left
[14:42] *** aborazmeh joined
[14:42] *** rindolf left
[14:44] <laben> moritz: in the dwimmy hyper code, it checks if the last elem of a list is a Whatever. i couldnt find it in the S03, what does it mean?

[14:44] <moritz> laben: iirc it's for auto-extending that list somehow

[14:45] <laben> but isn't that done with the dwimmy pointing of the hyper?

[14:45] <laben> i mean, the difference between >>op<< and >>op>>

[14:45] <moritz> S03 says "For any kind of zip or dwimmy hyper operator, any list ending with * is assumed to be infinitely extensible by taking its final element and replicating it:"

[14:45] *** Ven left
[14:45] *** rindolf joined
[14:45] <laben> moritz: which line is it? couldn find it

[14:46] <moritz> laben: dunno, I used the website :-)

[14:46] <laben> ok i found it, thanks

[14:47] <laben> it was the last paragraph, which i unwittingly skipped

[14:49] <FROGGS> m: say grep-index(Int, 2, [], 4, [], 5) # moritz: can you tell me which one is correct?

[14:49] <GLRelia> rakudo-moar 93ade8: OUTPUT«0 1 2␤»

[14:49] <camelia> rakudo-moar ac3488: OUTPUT«0 2 4␤»

[14:49] <FROGGS> I really dunno what to expect nowadays

[14:50] *** cwDYKARN left
[14:51] <moritz> m: say [Int, 2, [], 4, [], 5].perl

[14:51] <camelia> rakudo-moar ac3488: OUTPUT«[Int, 2, [], 4, [], 5]␤»

[14:51] <GLRelia> rakudo-moar 93ade8: OUTPUT«[Int, 2, $[], 4, $[], 5]␤»

[14:51] <moritz> m: for Int, 2, [], 4, [], 5 { say .perl }

[14:51] <GLRelia> rakudo-moar 93ade8: OUTPUT«Int␤2␤[]␤4␤[]␤5␤»

[14:51] <camelia> rakudo-moar ac3488: OUTPUT«Int␤2␤[]␤4␤[]␤5␤»

[14:51] <FROGGS> so the old code?

[14:51] <moritz> FROGGS: looks like it to me

[14:51] <FROGGS> kthx

[14:51] <moritz> FROGGS: but I'm not entirely sure either :(

[14:55] *** aborazmeh left
[14:56] *** colomon left
[14:58] <dalek> rakudo/glr: 59dc4ae | FROGGS++ | src/core/Any-iterable-methods.pm:

[14:58] <dalek> rakudo/glr: make sub grep-index not swallow empty arrays

[14:58] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/59dc4ae251

[14:58] *** aborazmeh joined
[14:58] *** aborazmeh left
[14:58] *** aborazmeh joined
[14:59] *** colomon joined
[15:02] <lizmat> FROGGS: shouldn't that also be done for the other subs like first?

[15:03] <lizmat> FROGGS++ by the way  :-)

[15:03] <lizmat> anyway, I'll test that

[15:03] <FROGGS> lizmat: well, I just look at the test fallout...

[15:04] *** colomon left
[15:05] <b2gills> .tell jnthn I think there could be a way to ask a sequence generator how many items it would produce if fully iterated ( remove `.infinite` ) ｢(1..1000).will-produce == 1000｣ ｢(gather {...}).will-produce === Int | Mu｣ ｢(gather {...} :will-produce(100)).will-produce == 100｣ (that last one will work without a grammar change, as it already does work for :infinite ) There should be no guarantees that the value will always be accurat

[15:05] <yoleaux> b2gills: I'll pass your message to jnthn.

[15:05] <JimmyZ> moritz: I think https://github.com/perl6/roast/commit/75160753eb is wrong

[15:06] <JimmyZ> moritz: lizmat++ it has another deep problem

[15:06] <JimmyZ> s/it/said/

[15:06] <JimmyZ> *said it

[15:08] <JimmyZ> moritz: http://irclog.perlgeek.de/perl6/2015-08-20#i_11086121

[15:10] <b2gills> I think there is a problem here: https://github.com/rakudo/rakudo/commit/05e46f5774 ｢$!i <= $!e｣ should probably use ｢!after｣ instead of ｢<=｣ because Range is used for strings as well as numbers ( just checked is still a problem on latest ) String ranges should be their own class really

[15:10] <lizmat> m: ("a".."z").slip.say

[15:10] <GLRelia> rakudo-moar 59dc4a: OUTPUT«Method 'slip' not found for invocant of class 'Range'␤  in block <unit> at /tmp/_YKluDFwe5:1␤␤»

[15:10] <camelia> rakudo-moar ac3488: OUTPUT«Method 'slip' not found for invocant of class 'Range'␤  in block <unit> at /tmp/csgO61TyQW:1␤␤»

[15:10] <laben> m: dd 'a'..'c'

[15:11] <GLRelia> rakudo-moar 59dc4a: OUTPUT«"a".."c"␤»

[15:11] <camelia> rakudo-moar ac3488: OUTPUT«"a".."c"␤»

[15:11] <lizmat> m: ("a".."z").Slip.say

[15:11] <camelia> rakudo-moar ac3488: OUTPUT«Method 'Slip' not found for invocant of class 'Range'␤  in block <unit> at /tmp/PDVJ8wOSVn:1␤␤»

[15:11] <GLRelia> rakudo-moar 59dc4a: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[15:11] <laben> m: dd ['a'..'c']

[15:11] <camelia> rakudo-moar ac3488: OUTPUT«$ = ["a", "b", "c"]␤»

[15:11] <GLRelia> rakudo-moar 59dc4a: OUTPUT«["a", "b", "c"]␤»

[15:11] <lizmat> b2gills: yet it seems to work, or is another candidate taking care of this?

[15:12] <laben> m: dd slip('a'..'d')

[15:12] <GLRelia> rakudo-moar 59dc4a: OUTPUT«("a".."d")␤»

[15:12] <camelia> rakudo-moar ac3488: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Lftv8h0vZP␤Undeclared routine:␤    slip used at line 1. Did you mean 'flip'?␤␤»

[15:12] <laben> m: dd ('a'..'d').Slip

[15:12] <GLRelia> rakudo-moar 59dc4a: OUTPUT«("a", "b", "c", "d")␤»

[15:12] <camelia> rakudo-moar ac3488: OUTPUT«Method 'Slip' not found for invocant of class 'Range'␤  in block <unit> at /tmp/xrLIlZbgHx:1␤␤»

[15:14] <b2gills> I'm backlogging, I was helping my brother demolish a kitchen which he is renovating so I was definitely AFK.

[15:23] <moritz> lizmat, JimmyZ: I find .lines returning Seq very intuitive

[15:24] <FROGGS> should .FOR still exists?

[15:25] <JimmyZ> moritz: http://irclog.perlgeek.de/perl6/2015-08-20#i_11086136

[15:26] <moritz> JimmyZ: I don't see how that relates to .lines returning a Seq

[15:26] <JimmyZ> moritz: split the $input and @result to two 'my'  won't return a Seq

[15:27] <moritz> JimmyZ: even then I *still* don't see what's wrong with my spectest patch

[15:27] *** yqt left
[15:28] <JimmyZ> moritz: https://gist.github.com/zhuomingliang/1129236b3fe5a96306b4 # this patch make the test pass, but hide the problem

[15:30] <moritz> JimmyZ: let me get this straight...

[15:30] <masak> ShimmerFairy: I did miss that. thank you for bringing it to my attention.

[15:30] <moritz> JimmyZ: you're saying neither your nor my patch should be needed; assigning a Seq to an @array variable should automatically coerce and thus memoize the sequence

[15:31] <masak> ShimmerFairy: to the extent those two standards are not wildly different (e.g. upper-case vs lower-case is OK), I'm fine with it and think it could be a good idea. open standards FTW.

[15:31] <moritz> JimmyZ: and it works right now for direct assignment, but not for the my ($thing, @array) = ... case

[15:31] <moritz> JimmyZ: correct?

[15:31] <JimmyZ> moritz: yeah

[15:31] <moritz> JimmyZ: ok. Then I think we should have a dedicated test for that with an appropriate description

[15:31] <ShimmerFairy> masak: yeah, on a skim of the standard, the only thing the RFC _disallows_ is an hour of '24', limiting the range to 00..23 to avoid potential issues of confusion.

[15:32] <moritz> JimmyZ: and I'll ad done later if I can remember, and have the mental capacity

[15:32] <moritz> *add

[15:32] <laben> m: my \a = (1,2,3).map(*.Str); a.WHAT.say; my @b = a; @b.WHAT.say

[15:32] <GLRelia> rakudo-moar 59dc4a: OUTPUT«(Seq)␤(Array)␤»

[15:32] <camelia> rakudo-moar ac3488: OUTPUT«(List)␤(Array)␤»

[15:32] <ShimmerFairy> masak: and for the :1month thing, there could always be a :precisely adverb that doesn't toss any overflow :)

[15:32] <laben> m: my \a = (1,2,3).map(*.Str); a.WHAT.say; dd a; my @b = a; @b.WHAT.say; dd @b

[15:32] <GLRelia> rakudo-moar 59dc4a: OUTPUT«(Seq)␤("1", "2", "3").iterator␤This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/iv6NUPGHma:1␤␤»

[15:32] <camelia> rakudo-moar ac3488: OUTPUT«(List)␤("1", "2", "3")␤(Array)␤@b = ["1", "2", "3"]<>␤»

[15:33] *** [Sno] joined
[15:33] <laben> oh, gosh. again with .perl consuming the Seq

[15:34] <JimmyZ> moritz: http://irclog.perlgeek.de/perl6/2015-08-20#i_11086139  #there was one , I just don't know where it should be

[15:37] <moritz> S32-list/seq.t

[15:38] *** aborazmeh left
[15:39] *** aborazmeh joined
[15:40] *** aborazmeh left
[15:40] *** aborazmeh joined
[15:43] <masak> ShimmerFairy: installing a named parameter there feels a bit like the let's-make-it-configurable trap.

[15:44] <masak> ShimmerFairy: put differently, I don't really see a use case. people tend to usually mean "roughly one month later" and not think about the implications so much.

[15:44] <masak> spectesting a patch now.

[15:44] <ShimmerFairy> fair enough. The only other place I can see that being useful would be February 29th with :year[s]  :)

[15:47] *** aborazmeh left
[15:49] *** aborazmeh joined
[15:49] *** aborazmeh left
[15:49] *** aborazmeh joined
[15:50] <masak> ShimmerFairy: February 29th either is a valid date in the year, or it isn't. no adverb will change that. :)

[15:51] <ShimmerFairy> masak: I mean  (Feb 29).later(:1year)  . Does that go precisely go 365 days later, or stay in February? :)

[15:52] <b2gills> (Feb 29).later(:400year)

[15:52] *** ChoHag joined
[15:54] <ChoHag> My brain's having a good old fart. How do you determine whether a class is or inherits from a class name held in a Str?

[15:54] *** Psyche^ left
[15:54] <ChoHag> Or consumes the Str as a role.

[15:54] <arnsholt> Isn't that the ::($name) syntax?

[15:54] <moritz> ~~ ::($typename)

[15:54] <moritz> yes

[15:55] <b2gills> m: my $class = 'Int'; say 5 ~~ ::($class)

[15:55] <camelia> rakudo-moar ac3488: OUTPUT«True␤»

[15:55] <GLRelia> rakudo-moar 59dc4a: OUTPUT«True␤»

[15:55] <arnsholt> I remembered a thing. Yay! =)

[15:55] *** Psyche^ joined
[15:56] <ChoHag> Hmm. I don't remember seeing that before.

[15:56] <ChoHag> Maybe it wasn't a fart after all.

[15:56] <ChoHag> How's the GLR going btw?

[15:57] <moritz> it's progressing.

[15:57] <dalek> roast/glr: 4345b0b | (Jimmy Zhuo)++ | S32-list/seq.t:

[15:57] <dalek> roast/glr: new test seq.t

[15:57] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/4345b0be41

[15:57] <moritz> ChoHag: down to ~140 or so failing test files

[15:57] <ChoHag> <Management> How complete is it as a percentage?

[15:58] <JimmyZ> moritz: it'd be nice to add seq.t to spectest.data :)

[15:58] <ChoHag> Cod I hate people asking me that...

[15:59] <dalek> rakudo/glr: ef66690 | moritz++ | t/spectest.data:

[15:59] <dalek> rakudo/glr: Run new test file seq.t, JimmyZ++

[15:59] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/ef66690089

[15:59] <moritz> "we're well into the first 80%"

[16:00] *** aborazmeh left
[16:01] *** aborazmeh joined
[16:02] *** ggoebel left
[16:03] *** aborazmeh left
[16:03] *** aborazmeh joined
[16:05] <b2gills> Unfortunately the last 20% usually takes 80% of the time.

[16:06] <moritz> that's why they are called the second 80%

[16:08] <ChoHag> And that'n when it's handed over to ops for the 3rd 80%.

[16:10] <dalek> roast/glr: 87b55ac | (Jimmy Zhuo)++ | S32-list/seq.t:

[16:10] <dalek> roast/glr: s/is/is-deeply/

[16:10] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/87b55acc2e

[16:11] <ChoHag> I want to be able to use a named regex in a when clause a la 'when Foo::Bar.thing { ... }', which I've achieved by having a method thing in class Foo::Bar which returns rx/.../.

[16:11] <ChoHag> Is there a more sensible way to do that?

[16:12] <masak> I think so.

[16:12] <timotimo> m: class Foobar { regex Test is export { ... } }; say Foobar::Test.WHAT

[16:12] <GLRelia> rakudo-moar ef6669: OUTPUT«Could not find symbol '&Test'␤  in block <unit> at /tmp/NzmpTVinbT:1␤␤Actually thrown at:␤  in block <unit> at /tmp/NzmpTVinbT:1␤␤»

[16:12] <camelia> rakudo-moar ac3488: OUTPUT«Could not find symbol '&Test'␤  in block <unit> at /tmp/RbvZpwPfEt:1␤␤Actually thrown at:␤  in block <unit> at /tmp/RbvZpwPfEt:1␤␤»

[16:13] <timotimo> oh, that's not what i meant

[16:13] <timotimo> m: class Foobar { our regex Test { ... } }; say Foobar::Test.WHAT

[16:13] <GLRelia> rakudo-moar ef6669: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in regex Test at /tmp/lUqMlCTXDy:1␤  in block <unit> at /tmp/lUqMlCTXDy:1␤␤»

[16:13] <camelia> rakudo-moar ac3488: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in regex Test at /tmp/YU9N6ow8ZD:1␤  in block <unit> at /tmp/YU9N6ow8ZD:1␤␤»

[16:13] <moritz> m: class My::Grammar { our regex number { ^ \d+ $ } }; sub f($x where My::Grammar::number) { say 42 }

[16:13] <camelia> rakudo-moar ac3488: ( no output )

[16:13] <GLRelia> rakudo-moar ef6669: ( no output )

[16:13] <moritz> m: class My::Grammar { our regex number { ^ \d+ $ } }; sub f($x where My::Grammar::number) { say 42 }; f 42

[16:13] <GLRelia> rakudo-moar ef6669: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in regex number at /tmp/rlQ3vcxwGa:1␤  in sub f at /tmp/rlQ3vcxwGa:1␤  in block <unit> at /tmp/rlQ3vcxwGa:1␤␤»

[16:13] <camelia> rakudo-moar ac3488: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in regex number at /tmp/Nek4dXjN8Y:1␤  in sub f at /tmp/Nek4dXjN8Y:1␤  in block <unit> at /tmp/Nek4dXjN8Y:1␤␤»

[16:13] <timotimo> so that's a call, not a mention

[16:13] <masak> m: class Foo::Bar { my $.thing = /HAI$/ }; given "OH HAI" { when Foo::Bar.thing { .say } }

[16:13] <camelia> rakudo-moar ac3488: OUTPUT«OH HAI␤»

[16:13] <GLRelia> rakudo-moar ef6669: OUTPUT«OH HAI␤»

[16:13] <moritz> m: class My::Grammar { our regex number { ^ \d+ $ } }; sub f($x where &My::Grammar::number) { say 42 }; f 42

[16:13] <GLRelia> rakudo-moar ef6669: OUTPUT«42␤»

[16:13] <camelia> rakudo-moar ac3488: OUTPUT«42␤»

[16:13] <moritz> m: class My::Grammar { our regex number { ^ \d+ $ } }; sub f($x where &My::Grammar::number) { say 42 }; f 'not a number'

[16:13] <GLRelia> rakudo-moar ef6669: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub f at /tmp/mGqtvI0sru:1␤  in block <unit> at /tmp/mGqtvI0sru:1␤␤»

[16:13] <camelia> rakudo-moar ac3488: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub f at /tmp/ZtBmJ6bt5Q:1␤  in block <unit> at /tmp/ZtBmJ6bt5Q:1␤␤»

[16:14] <masak> nice, I was the only one who went for `my $.thing` :)

[16:14] <moritz> ok, that works

[16:14] <masak> adhering to ChoHag's dot requirement

[16:14] <ChoHag> Meh it doesn't have to be a dot.

[16:14] <masak> I agree that `::` and `our` might be more sixish.

[16:14] *** AlexDani` joined
[16:14] <moritz> masak: I adhered to the "something like" requirement :-)

[16:14] *** AlexDani` is now known as AlexDaniel

[16:14] <masak> ChoHag: no, but I liked that I could make it work :>

[16:15] <ChoHag> :)

[16:15] <dalek> roast: 66a389d | (Carl Masak)++ | S32-temporal/Date (2 files):

[16:15] <dalek> roast: tests to not die a month from Jan 31st

[16:15] <dalek> roast: review: https://github.com/perl6/roast/commit/66a389de6f

[16:16] <dalek> rakudo/nom: 4288450 | (Carl Masak)++ | src/core/Temporal.pm:

[16:16] <dalek> rakudo/nom: make .later not die on day-of-month overflow

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4288450889

[16:16] <masak> spectested an everything. :)

[16:16] <masak> and*

[16:18] <ShimmerFairy> masak: good, except I don't agree with clamping to the first of the next month (I'd rather clamp to the last day of the expected month)

[16:18] <AlexDaniel> Just 130 tests? Wow! nine++

[16:18] <yoleaux> 21 Aug 2015 08:14Z <FROGGS> AlexDaniel: the qx//|run|shell issue is not a very big one on my list btw... there are more important issues we need to address

[16:19] *** colomon joined
[16:20] <ShimmerFairy> masak: aka 31 Jan + 1 month -> 28/29 Feb. Mar 1 feels like an off-by-one kind of error to me, in addition to not returning the expected month :)

[16:22] *** diana_olhovik_ left
[16:23] <ShimmerFairy> anyway, night #perl6 o/ :)

[16:23] <colomon> \o

[16:23] <AlexDaniel> .tell FROGGS As far as I can see, qx// issue will require some deprecation, that's why I'd really like to see it being reworked before any major release. But I do understand that there are other issues. Thanks anyway.

[16:23] <yoleaux> AlexDaniel: I'll pass your message to FROGGS.

[16:23] <JimmyZ> ShimmerFairy: good night

[16:24] * colomon is waiting at the airport, starting first leg of trip to Switzerland…

[16:26] *** xinming left
[16:27] *** xinming joined
[16:29] *** zakharyas left
[16:30] <masak> ShimmerFairy: I could also accept clamping to the end of the month. IMO, it's all about where to introduce the discontinuity/overlap.

[16:33] *** aborazmeh left
[16:35] *** skids joined
[16:37] *** mr-foobar left
[16:38] <b2gills> .oO( I know there are MMX SSE or SIMD ops that don't overflow, instead they stick to the min or max value )

[16:38] *** census joined
[16:38] *** lichtkind joined
[16:39] <census> since when is there a slap option?

[16:39] <census> i'd like to slap some #perl people

[16:45] <masak> census: hey

[16:45] <masak> census: don't slap anyone. come in here and cool off for a while :)

[16:45] <census> hi masak!

[16:45] <census> hahahahah

[16:45] <census> yea i wasn't planning on it

[16:45] <masak> ShimmerFairy: ok, you've convinced me. makes the logic simpler, too :)

[16:48] <lizmat> ShimmerFairy masak : perhaps internally it *should* be 31 Feb, just in stringifying / looking at attributes it shojld say 28/29 Feb

[16:48] <lizmat> then you can still move on another month on that object, and get a sane thing

[16:49] <lizmat> similar to when you're in an editor, the cursor remembers the column where you were when you're moving up or down past shorter lines

[16:49] <lichtkind> is the pure sub trait gone?

[16:49] *** amirite joined
[16:49] <lizmat> m: sub a() is pure {}

[16:49] <GLRelia> rakudo-moar ef6669: ( no output )

[16:49] <camelia> rakudo-moar ac3488: ( no output )

[16:49] <lizmat> looks like it is still there

[16:49] <masak> lizmat: I don't like the idea of even being able to create dates that don't exist.

[16:49] <masak> lizmat: that's why we throw an exception on creating that kind of date.

[16:51] <lichtkind> lizmat: thank but i currently could find in syn

[16:51] <lizmat> lichtkind: that's entirely possible

[16:51] <lizmat> masak: well, just throwing in my 2c

[16:51] <ChoHag> Is the date class able to distinguish between 'the 31st of the month' and 'the last day of the month'?

[16:51] <lizmat> good night, #perl6!

[16:52] <skids> jdv79: (backlogging) strings in ABNF are case insensitive.  You have to use hex rules to specify case.

[16:53] <ChoHag> Because if I did something with someone on Jan 31st and they said 'same time next month?' I'd be confused (ie. throw a tantrum^Wexception) and ask them to clarify *unless* we had done the thing on that day in January because there was already a last-day-of-the-month agreement in place.

[16:57] <ChoHag> Maybe it's happening on the 31st because it happens to be the last Thursday?

[16:58] *** MilkmanDan joined
[16:58] <ChoHag> Then plus one month would be Feb 28 and plus two would be Mar 28 or 27 in a leap year.

[16:59] <ChoHag> To put it simply, you can't put it simply. If you've used the word simple in anything to do with date handling, you're wrong.

[16:59] *** zacts joined
[17:00] <ChoHag> It's that simple.

[17:02] <laben> i may have a sorta kinda impl of (non) dwimmy hypers, how do i check the hypers tests?

[17:04] *** araujo left
[17:04] *** colomon left
[17:05] *** domidumont joined
[17:09] <masak> ChoHag: I agree with everything you jsut said.

[17:09] <masak> ChoHag: I would also like for .later not to throw an exception.

[17:11] <masak> lizmat: I wish I could explain my intuition there a bit better. part of the "responsibility" of Date/DateTime is delineating what's even a legal date.

[17:11] <masak> and choking at construction if the inputs are illegal.

[17:12] <masak> allowing chameleon dates which look like one thing but contain hidden information about another thing, and can be printed to look like an illegal date, eats into that responsibility and makes date/datetime worse at their job.

[17:14] <zacts> hello

[17:14] <skids> o/

[17:14] *** pink_mist joined
[17:17] <ChoHag> What does the regex class 'ident' mean?

[17:17] <ChoHag> Specifically.

[17:19] <masak> ChoHag: "identifier" (as defined by Perl 6)

[17:19] <dalek> rakudo/nom: d6bf551 | (Carl Masak)++ | src/core/Temporal.pm:

[17:19] <dalek> rakudo/nom: clip to end of month instead of overflow to next

[17:19] <dalek> rakudo/nom: 

[17:19] <dalek> rakudo/nom: ShimmerFairy++ for the suggestion. This simplifies the logic a bit.

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d6bf551d23

[17:19] *** census left
[17:20] *** llfourn left
[17:20] <ChoHag> Really? Code looks like it's the other way around.

[17:20] <ChoHag> token identifier { <.ident> [ <.apostrophe> <.ident> ]* }

[17:22] <skids> Yeah ISTR that.  ident is the peice of identifiers that's valid for things that don't take apostrophe names.

[17:25] <moritz> ident is a typical identifier in other programming languages

[17:26] <ChoHag> What would the p5 regex equivalent look like?

[17:28] <moritz> my $ident = qr/\pL\w*/; my $identifier = qr/$ident (?: ['-] $ident )* /x

[17:32] *** cognominal joined
[17:38] *** zakharyas joined
[17:38] *** mjgardner joined
[17:42] *** mjgardner left
[17:43] <dalek> rakudo-star-daily: dfdacea | coke++ | log/ (10 files):

[17:43] <dalek> rakudo-star-daily: today (automated commit)

[17:43] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/dfdacead01

[17:43] <dalek> perl6-roast-data: bc1df84 | coke++ | / (10 files):

[17:43] <dalek> perl6-roast-data: today (automated commit)

[17:43] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/bc1df8479e

[17:43] <dalek> perl6-roast-data: e2fddff | coke++ | / (9 files):

[17:43] <dalek> perl6-roast-data: today (automated commit)

[17:43] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e2fddff30d

[17:45] *** mjgardner joined
[17:49] *** zakharyas left
[17:49] <ChoHag> How can I use the tokens in Perl6::Grammar in my own regexen?

[17:52] *** diana_olhovik joined
[17:53] <masak> ChoHag: if you find out, let me know. :/

[17:54] <ChoHag> Not the answer I was hoping for...

[17:54] <masak> I think someone did that recently. was it ShimmerFairy?

[17:54] <ChoHag> ... Who's gone to bed.

[17:54] <masak> ChoHag: it *is* a very reasonable/desirable use case. it's just traditionally been Hard To Do.

[17:55] <masak> I mean, if you hack your way down to the NQP level, sooner or later you're going to find Perl6::Grammar.

[17:55] <masak> but it should be super-easy to do, and it isn't, yet.

[17:55] <ChoHag> I was a little surprised when I found that Perl6::Grammar was unknown.

[17:55] <masak> aye.

[17:56] <masak> that's because it's defined in the substrate used by the compiler.

[17:56] <masak> you're in the runtime; that's a different process with different namespaces.

[18:03] <ChoHag> ISTR reading about a means of matching 'something in brackets', ie. open-brackets, thing-except-close-brackets-unless-preceeded-by-open-brackets, close-same-type-of-brackets.

[18:03] <masak> are you thinking of `'(' ~ ')' <inside>` ?

[18:04] <ChoHag> I don't know.

[18:04] <ChoHag> Am I?

[18:04] <masak> think so.

[18:04] *** pmurias joined
[18:05] <pmurias> hi

[18:05] <masak> don't expect too much from that construct. <inside> has to give back control to its callee for the ')' to match. and ')' can match in <inside>, no problem.

[18:05] <masak> pmurias: \o

[18:05] <masak> pmurias: happy to see you've picked up JS again :)

[18:05] <ChoHag> Nothing is ever as simple as originally planned.

[18:05] <masak> ChoHag: well, it's working as designed.

[18:05] <masak> ChoHag: it just takes a while to get used to.

[18:06] <ChoHag> I mean what I'm doing.

[18:06] <ChoHag> "Match a thing followed optionally by its name in brackets"

[18:07] <ChoHag> When I decided to do that, in my head it was just '\w+(\[\w+\])?'. When I get to actually writing the code, that's woefully inadequate.

[18:08] <ChoHag> Every step is like that. It's a lesson I never seem to learn.

[18:08] <ChoHag> "That'll be easy. Let's leave it for later and concentrate on the meat. ... Oh..."

[18:10] <ugexe> $<some-identifier>=['{' | '[] .*? 

[18:10] <ugexe> $<some-identifier>=['{' | '['] .*? <before $<some-identifier>> something like this can work

[18:10] <skids> really would be nice to have a ~-like regex op that automatically tends to nesting like everyone expects ~ to.

[18:11] <ugexe> oh nm that doesnt work for brackets. just quotes

[18:11] <ChoHag> I rest my case.

[18:13] *** cognominal left
[18:15] <ugexe> i would just write the 2 additional simple rules

[18:15] <ugexe> token optional { '{' <whatever. '}' | '[' <whatever> ']' }

[18:16] <ChoHag> Well honestly I have to rething the whole naming part anyway.

[18:17] *** yqt joined
[18:18] * jnthn made it home in one piece from YAPC::Asia

[18:18] <yoleaux> 22 Aug 2015 16:46Z <japhb> jnthn: It's looking now like the limiting factor for the awesomeness of your parallelism/asynchrony/concurrency talks is *the length of the talk*.  I think we need to get you longer speaking slots.  ;-)

[18:18] <yoleaux> 09:36Z <vendethiel> jnthn: isn't there a race condition in http://jnthn.net/papers/2015-yapcasia-concurrency.pdf slide 59 for the "unless"?

[18:18] <yoleaux> 15:05Z <b2gills> jnthn: I think there could be a way to ask a sequence generator how many items it would produce if fully iterated ( remove `.infinite` ) ｢(1..1000).will-produce == 1000｣ ｢(gather {...}).will-produce === Int | Mu｣ ｢(gather {...} :will-produce(100)).will-produce == 100｣ (that last one will work without a grammar change, as it already does work for :infinite ) There should be no guarantees that the value will always be

[18:18] <yoleaux>  accurat

[18:18] <jnthn> Darn that was not a fun journey at all...

[18:21] <jnthn> .tell vendethiel the text right above explains why it's not ;) We don't let any of the code in a given supply/react instance be running on multiple threads, so there can never be two threads racing to read/write any state enclosed in the supply/react block

[18:21] <yoleaux> jnthn: I'll pass your message to vendethiel.

[18:22] <vendethiel> computer?

[18:22] <yoleaux> 18:21Z <jnthn> vendethiel: the text right above explains why it's not ;) We don't let any of the code in a given supply/react instance be running on multiple threads, so there can never be two threads racing to read/write any state enclosed in the supply/react block

[18:22] <vendethiel> jnthn: thanks. I didn't understand it that way :)

[18:23] <jnthn> vendethiel: Yeah, the supply/react stuff deserves a talk of its own really, but making things like that example work correctly was one of my explicit goals with it from the start :)

[18:23] *** cschwenz joined
[18:23] <vendethiel> jnthn: yes, it feels like you want to explore more monitor and/or actor in the talk, but left it "for some later talk"(well, or previous!). but it's still great!

[18:24] <jnthn> .tell b2gills While I agree there could be such a thing, I'd like to see more concrete use cases :)

[18:24] <yoleaux> jnthn: I'll pass your message to b2gills.

[18:24] <jnthn> vendethiel: Yeah, this talk is in part "I did a bunch of parallel/concurrent/async talks before, let me now try and show when the various pieces apply" :)

[18:25] <jnthn> .tell b2gills Not least because I was very glad to kill off the whole .infinite thing

[18:25] <yoleaux> jnthn: I'll pass your message to b2gills.

[18:27] <masak> jnthn! \o/

[18:28] <timotimo> what the ... hell? my script causes an internal error in stage parse ... World::install_lexical_container tries to call .value on the $var and it says it can't find it ...

[18:28] *** Ven joined
[18:30] <jnthn> About [[1]] needing to be [[1],] in GLR - yes, I know. :) But if I understood the result of the grep-all-the-modules, it's not like it's common to do [[0]] style things for one. And for two, it's the same thing that makes [1..10] give you an array of 10 items.

[18:30] <jnthn> It's one of those "you can't win" situations - at least, if you want to kill of the amount of auto-flattening we used to do.

[18:30] *** mjgardner left
[18:30] <jnthn> (And I think we generally *do*)

[18:31] <jnthn> Anyway, I chose not to win the [[0]] battle during the glr war.

[18:31] <timotimo> failed to find a variable by the name of $_ in the block stack

[18:31] *** TEttinger joined
[18:31] <timotimo> oh, block stack isn't actually right

[18:32] <timotimo> potentially a swallowed error for redeclaring $_

[18:32] <timotimo> m: my @test; while @test { my $_ = 1 }

[18:32] <GLRelia> rakudo-moar ef6669: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[18:32] <camelia> rakudo-moar d6bf55: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[18:32] <pmurias> jnthn: are there docs on how  subrule rxtype works?

[18:32] <timotimo> m: my @test; while @test { $_ = 1 }

[18:33] <GLRelia> rakudo-moar ef6669: ( no output )

[18:33] <camelia> rakudo-moar d6bf55: ( no output )

[18:33] <timotimo> so "my $_" is supposed to give a compile-time error there?

[18:33] <jnthn> pmurias: Not that I know of

[18:33] <jnthn> timotimo: ooc, is that an error with --optimize=off or so?

[18:33] <timotimo> it happens in stage parse

[18:33] <timotimo> so it can't make a difference

[18:34] <pmurias> jnthn: I'm doing a bit of guessing on how the subtypes work, but it would be much better if I had a description of them instead of just hacking things till the tests pass ;)

[18:35] <jnthn> timotimo: ah, interesting

[18:35] <jnthn> timotimo: But yeah, certainly a bug

[18:35] <jnthn> timotimo: I don't have the energy to look at it now

[18:35] <jnthn> pmurias: I already ported it twice that way successfully :P

[18:35] <timotimo> no problem

[18:39] <masak> timotimo: want me to rakudobug the `my $_` thing?

[18:39] <masak> m: while 0 { my $_ }

[18:39] <GLRelia> rakudo-moar ef6669: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[18:39] <camelia> rakudo-moar d6bf55: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[18:39] <timotimo> masak: sure, go ahead :)

[18:39] <masak> m: { my $_ }

[18:39] <GLRelia> rakudo-moar ef6669: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/_33E8YSEeR:1␤    ------> 3{ my $_ 7⏏5}␤»

[18:39] <camelia> rakudo-moar d6bf55: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/fQEBMAwxS3:1␤    ------> 3{ my $_ 7⏏5}␤»

[18:39] <timotimo> thank you

[18:39] * masak submits rakudobug

[18:39] <masak> no problem. been a while since I submitted anything ;)

[18:41] *** Ven left
[18:41] <masak> m: for 0 { my $_ }

[18:41] <GLRelia> rakudo-moar ef6669: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/lFFtgEOjYq:1␤    ------> 3for 0 { my $_ 7⏏5}␤»

[18:41] <camelia> rakudo-moar d6bf55: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/e743xnFISm:1␤    ------> 3for 0 { my $_ 7⏏5}␤»

[18:41] <masak> only while loops. innerestin'.

[18:42] <timotimo> possibly some optimization (not in the optimizer) not being careful enough

[18:42] <jnthn> Should go rest...bodies are not designed to do long-haul travel on close to zero sleep... :/

[18:42] <jnthn> o/

[18:43] <pmurias> jnthn: I'll mangage to do it that way too, would be great if it got documented at some point

[18:44] <masak> jnthn: rest well.

[18:44] *** mjgardner joined
[18:48] <FROGGS> .

[18:48] <yoleaux> 16:23Z <AlexDaniel> FROGGS: As far as I can see, qx// issue will require some deprecation, that's why I'd really like to see it being reworked before any major release. But I do understand that there are other issues. Thanks anyway.

[18:50] *** Ven joined
[18:51] <Ven> I'm trying to look at the GLR stuff (trying to fix S02-names-vars/list_array_perl) but I don't understand the behavior. 

[18:51] <Ven> m: my @foo = ([-1, -2], -3); say @foo.perl; # why the $[] ?

[18:51] <GLRelia> rakudo-moar ef6669: OUTPUT«[$[-1, -2], -3]␤»

[18:51] <camelia> rakudo-moar d6bf55: OUTPUT«[[-1, -2], -3]<>␤»

[18:51] <Ven> I thought [] didn't itemize anymore? or is that there to prevnt @ = from flattening?

[18:54] <masak> m: my @foo = [-1, -2]; say @foo.perl

[18:54] <GLRelia> rakudo-moar ef6669: OUTPUT«[-1, -2]␤»

[18:54] <camelia> rakudo-moar d6bf55: OUTPUT«[[-1, -2]]<>␤»

[18:54] <masak> ooh :)

[18:54] *** amirite left
[18:55] <timotimo> [] doesn't itemize, but assigning to an array puts everything into a scalar container, does that seem right?

[18:55] <Ven> that's what I'm asking before doing anything to this test :)

[19:02] *** Ven left
[19:03] <nine> .tell laben Of lists we know if they are lazy or not. Of lazy lists we may know that they are infinite or may be infinite. For example, what makes you think, that .lines is finite? It could be a stream of a webserver log that for all intents and purposes _is_ infinite.

[19:03] <yoleaux> nine: I'll pass your message to laben.

[19:05] *** diana_olhovik left
[19:05] *** Ven joined
[19:06] *** ChoHag left
[19:07] <dalek> roast: 7e0c2b0 | FROGGS++ | S02-types/declare.t:

[19:07] <dalek> roast: adjust expectation when assigning big bigint to native

[19:07] <dalek> roast: review: https://github.com/perl6/roast/commit/7e0c2b0cd0

[19:11] *** Ven_ joined
[19:11] *** Ven left
[19:12] *** domidumont left
[19:12] * BenGoldberg ponders whether there are any currently-existing perl6 processes started by ineted.

[19:14] <FROGGS> jnthn: what do you think about .int* methods on Cool?

[19:14] <Ven_> FROGGS: that should probably be .tell :)

[19:15] <FROGGS> good point :o)

[19:15] <Ven_> m: my $i; $i++ for (1, 2, 3).item; say $i; # is that expected? if "for" is *just .map*, it should probably be 3 and I should fix the test

[19:15] <GLRelia> rakudo-moar ef6669: OUTPUT«3␤»

[19:15] <camelia> rakudo-moar d6bf55: OUTPUT«1␤»

[19:15] <FROGGS> I'll do later if I donot come to a conclusion on my own

[19:16] *** brrt joined
[19:16] * Ven_ would like ShimmerFairy or nine's opinion, which are far more knowledgeable wrt glr and might still be able :)

[19:16] *** llfourn joined
[19:19] <Ven_> I guess I should check RT#63350 and RT#78284

[19:19] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=63350

[19:21] <Ven_> this RT is from 2009, and I'm not sure moritz++ saw GLR coming then :)

[19:21] *** llfourn left
[19:25] *** brrt left
[19:27] <masak> m: my $i; $i++ for (1, 2, 3); say $i

[19:27] <GLRelia> rakudo-moar ef6669: OUTPUT«3␤»

[19:27] <camelia> rakudo-moar d6bf55: OUTPUT«3␤»

[19:27] <masak> Ven_: so, you're saying the .item there makes no difference?

[19:27] *** brrt joined
[19:27] <masak> (which may well be true -- I'm just trying to understand)

[19:28] <Ven_> masak: yes. because in glr, "for" is literally just .map, as I've understood it

[19:29] *** rindolf left
[19:29] <FROGGS> m: my $i; $i++ for (1, 2, 3).item, 42; say $i;

[19:29] <GLRelia> rakudo-moar ef6669: OUTPUT«2␤»

[19:29] <camelia> rakudo-moar d6bf55: OUTPUT«2␤»

[19:29] <Ven_> FROGGS: because then, you're calling .for on ($[1, 2, 3], 42) :P

[19:30] <FROGGS> Ven_: I think that counts as the "One Element Rule™"

[19:30] <Ven_> FROGGS: sorry? :)

[19:30] <masak> Ven_: ok, I agree with that conclusion, then.

[19:31] <FROGGS> Ven_: no, I'm not :o)

[19:31] <Ven_> FROGGS: I mean -- what's the one element rule?

[19:31] *** rindolf joined
[19:32] <FROGGS> if you are iterating over one element, and this is Positional or Iterable (I dunno), then you iterate over its elems

[19:33] <Ven_> FROGGS: right. seems consistent to you? the discussion in the ticket is interesting, but glr changed a lot of things

[19:33] *** cschwenz left
[19:34] <FROGGS> Ven_: I am not sure if it is consistent or sane... really

[19:35] <FROGGS> I need to get used to it and play with more GLR aspects to get a feeling

[19:36] *** darutoko left
[19:36] <rindolf> FROGGS: hi, sup?

[19:37] <FROGGS> hi rindolf 

[19:37] <jdv79> is it a one arg rule of a one arg exception to the rule?

[19:40] *** espadrine left
[19:47] <Ven_> jdv79: sorry?

[19:47] * Ven_ feels confused by all this :)

[19:47] <Ven_> it seems that "for 1 {}" working (iterating once) works because perl6 doesn't differentiate between "a" and "a,"

[19:48] <Ven_> (which means a[0][0][0][0][0][0][0][0] =:= a, if a isn't Positional)

[19:50] *** ggoebel joined
[19:55] *** Ven_ left
[19:56] *** jack_rabbit left
[19:56] *** cognominal joined
[20:03] *** Ven joined
[20:04] <masak> I think Python for loops have something resembling a one element rule.

[20:04] *** yqt left
[20:06] <brrt> what kind of one-element rule do you mean?

[20:06] *** zakharyas joined
[20:08] <masak> m: for [1, 2, 3] { .say }

[20:08] <GLRelia> rakudo-moar ef6669: OUTPUT«1␤2␤3␤»

[20:08] <camelia> rakudo-moar d6bf55: OUTPUT«1 2 3␤»

[20:08] *** Ven left
[20:08] <masak> brrt: the one that holds in GLR but not cam.

[20:08] <brrt> i'm not super-familiar with all that has been done on GLR

[20:08] <masak> no, but you can see the difference in the above eval :)

[20:08] <brrt> although most things look really decent to me

[20:09] <masak> brrt: more specifically, in Python you always pass a single thing to a for loop. so there has to be a one-element rule.

[20:09] <jdv79> what's the fail count now?

[20:09] <brrt> oh, right, there is a newline between each of the numbers

[20:09] *** Ven joined
[20:09] <jdv79> btw, does anyone else see a non-spec native call test failing?

[20:09] <vendethiel> what I used to do to explain is "imagine there are parentheses around the for's head": for 1, 2, 3 maps on (1, 2, 3), for @a maps on (@a) so @a)

[20:10] <vendethiel> that's an oversimplification, obviously :)

[20:10] <brrt> jdv79: i do, yes

[20:11] <masak> vendethiel: I'm still not too clear on what parentheses mean in GLR :)

[20:13] *** xfix left
[20:15] *** brrt left
[20:16] *** brrt joined
[20:16] *** llfourn joined
[20:19] *** Ven left
[20:19] <skids> masak: my take on it is parenthesis mean "don't change the default return type of infix[,] (which is List)" and also of course, to override the chaining , precedence.

[20:20] *** zakharyas left
[20:20] <masak> ok... I'll try to digest that.

[20:20] <masak> it sounds like what someone who has understood more than I have about GLR might say :P

[20:21] *** llfourn left
[20:23] <skids> :)

[20:27] *** telex left
[20:28] *** telex joined
[20:29] *** KCL joined
[20:32] *** KCL_ left
[20:32] <moritz> m: say ().^name

[20:32] <GLRelia> rakudo-moar ef6669: OUTPUT«List␤»

[20:32] <camelia> rakudo-moar d6bf55: OUTPUT«Parcel␤»

[20:32] <moritz> there's always that special case

[20:33] <moritz> otherwise the statement about () not changing the type returned by infix:<,> is true both pre and post GLR

[20:39] <masak> m: say ().^name.substr(*-2)

[20:39] <GLRelia> rakudo-moar ef6669: OUTPUT«st␤»

[20:39] <camelia> rakudo-moar d6bf55: OUTPUT«el␤»

[20:39] <masak> I honestly don't know why I did that.

[20:39] <FROGGS> *g*

[20:46] <vendethiel> *g*

[20:46] <vendethiel> .oO( show me your true colors, substr )

[20:48] <masak> m: say "Superman's birth name, Kal-", ().^name.substr(*-2)

[20:48] <GLRelia> rakudo-moar ef6669: OUTPUT«Superman's birth name, Kal-st␤»

[20:48] <camelia> rakudo-moar d6bf55: OUTPUT«Superman's birth name, Kal-el␤»

[20:48] <masak> obviously, cam is right on that one.

[20:52] <dalek> rakudo-star-daily: d8b1d48 | coke++ | log/ (8 files):

[20:52] <dalek> rakudo-star-daily: today (automated commit)

[20:52] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d8b1d48bc2

[20:52] *** kaare_ left
[20:53] *** mjgardner left
[20:53] <dalek> perl6-roast-data: fde07ab | coke++ | / (2 files):

[20:53] <dalek> perl6-roast-data: one more glr run today

[20:53] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fde07ab678

[20:54] <[Coke]> jdv79: (test failures) coke/perl6-roast-data has daily runs on linux for all the backends (and glr0

[20:54] <[Coke]> (on github)

[21:02] <BenGoldberg> m: say [R,] 1..4;

[21:02] <GLRelia> rakudo-moar ef6669: OUTPUT«4 3 2 1␤»

[21:02] <camelia> rakudo-moar d6bf55: OUTPUT«4 3 2 1␤»

[21:04] <BenGoldberg> m: my @a = (1, 2, 3); @a.perl.say;

[21:04] <GLRelia> rakudo-moar ef6669: OUTPUT«[1, 2, 3]␤»

[21:04] <camelia> rakudo-moar d6bf55: OUTPUT«[1, 2, 3]<>␤»

[21:05] <BenGoldberg> m: my $goal = "Just another sorting hacker,"; my @b = 'a'..'z';push @b, 'A'..'Z'; my $a = @b[^ $goal.chars].join; srand 1; my $scram = $a.comb.pick(*).join; my $pre = $a.trans( $scram => $goal ); srand 1; $pre.comb.pick(*).join.say

[21:05] <camelia> rakudo-moar d6bf55: OUTPUT«Just another sorting hacker,␤»

[21:05] <GLRelia> rakudo-moar ef6669: OUTPUT«Just another sorting hacker,␤»

[21:06] <BenGoldberg> m: say( 1 R, 2 R, 3 R, 4 )l

[21:06] <GLRelia> rakudo-moar ef6669: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xJSvIFzPkY␤Two terms in a row␤at /tmp/xJSvIFzPkY:1␤------> 3say( 1 R, 2 R, 3 R, 4 )7⏏5l␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement mo…»

[21:06] <camelia> rakudo-moar d6bf55: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ewpuGzLo5A␤Two terms in a row␤at /tmp/ewpuGzLo5A:1␤------> 3say( 1 R, 2 R, 3 R, 4 )7⏏5l␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement mo…»

[21:06] <BenGoldberg> m: say( 1 R, 2 R, 3 R, 4 );

[21:06] <GLRelia> rakudo-moar ef6669: OUTPUT«2 1␤»

[21:06] <camelia> rakudo-moar d6bf55: OUTPUT«2 1␤»

[21:12] <BenGoldberg> m: my $pi = (pi*1e99).Int / (1e99.Int); say $pi;

[21:12] <GLRelia> rakudo-moar ef6669: OUTPUT«3.14159265358979295␤»

[21:12] <camelia> rakudo-moar d6bf55: OUTPUT«3.14159265358979295␤»

[21:13] <BenGoldberg> m: my $pi = (pi*1e99).Int / (1e99.Int); say $pi.base-repeating(10);

[21:13] <GLRelia> rakudo-moar ef6669: OUTPUT«(timeout)»

[21:13] <camelia> rakudo-moar d6bf55: OUTPUT«(timeout)»

[21:16] <masak> shameless plug: my YAPC::EU talk will be about code I have in production. some of that will be Perl 6 scripts I have in my ~/bin directory. I just pushed those to https://github.com/masak/tilde-bin -- feel free to have a look :)

[21:17] <masak> and with that, I've only spoiled like 20% of my talk, so you should still come to the talk :>

[21:19] *** brrt left
[21:19] <vendethiel> .oO( don't link your talk too much around)

[21:19] *** brrt1 joined
[21:20] <masak> don't worry, I won't link to the *talk*, as it's currently (hastily) being written.

[21:22] * brrt1 is also writing a talk

[21:24] <masak> what an unlikely coincidence.

[21:25] <brrt1> :-)

[21:27] <brrt1> i'm trying not to ramble about arcane compilation details

[21:29] * vendethiel hopes his next talk can be about macros :)

[21:29] <vendethiel> ..or a different language altogether

[21:30] <masak> vendethiel: is that... a veiled threat? :P

[21:30] <vendethiel> no! I mean something like lisp or smalltalk "in context" :)

[21:30] <masak> :P

[21:31] <masak> then I hope so too.

[21:31] <masak> let's make Perl 6 macros awesome.

[21:31] <masak> I know they're in there somewhere <3

[21:32] *** philh left
[21:34] *** yqt joined
[21:34] <timotimo> m: my %test; say %test{"hello"}

[21:34] <GLRelia> rakudo-moar ef6669: OUTPUT«(Any)␤»

[21:34] <camelia> rakudo-moar d6bf55: OUTPUT«(Any)␤»

[21:34] <timotimo> m: my %test; say %test{"hello"} ~ "hi"

[21:34] <GLRelia> rakudo-moar ef6669: OUTPUT«Use of uninitialized value %test of type Any in string context  in block <unit> at /tmp/8iIr8NZ2q8:1␤hi␤»

[21:34] <camelia> rakudo-moar d6bf55: OUTPUT«Use of uninitialized value %test of type Any in string context  in block <unit> at /tmp/uEAacd1liA:1␤hi␤»

[21:34] <timotimo> ^- the "value %test" is kinda anti-helpful here

[21:34] <vendethiel> masak :https://github.com/masak/tilde-bin/blob/master/month#L15 can't get them from the lang?

[21:35] <masak> vendethiel: (a) you'll notice that's Swedish.

[21:36] <masak> vendethiel: (b) when we spec'd Temporal, I/we decided to make it language-agnostic. not even English.

[21:36] <masak> vendethiel: aka "let the module ecosystem handle that"

[21:36] <masak> as far as I know, there is no such module (yet).

[21:36] <masak> if/when there is, I'll happily use it.

[21:37] <labster> m: Date.new('20150823')

[21:37] <GLRelia> rakudo-moar ef6669: OUTPUT«Invalid Date string '20150823'; use yyyy-mm-dd instead␤  in block <unit> at /tmp/95J9q1FMQ3:1␤␤»

[21:37] <camelia> rakudo-moar d6bf55: OUTPUT«Invalid Date string '20150823'; use yyyy-mm-dd instead␤  in block <unit> at /tmp/DGfzFYs5eV:1␤␤»

[21:37] <labster> apparently that's supposed to be valid ISO 8601 too.

[21:38] *** brrt1 left
[21:41] <jdv79> 860tried to make everyone happy, right?

[21:42] <vendethiel> masak: I noticed it was swedish :)

[21:42] <jdv79> *8601

[21:44] <masak> labster: I... I think even as I read through ISO 8601 the first time, I made some judicious selections from it. :)

[21:44] <masak> labster: no need to be ambiguous when there's a nicer form with dashes.

[21:44] <masak> er, hyphens. whatever.

[21:45] <vendethiel> masak: I still write all my scripts in perl6, obviously :P https://github.com/vendethiel/deepgitstatus/blob/master/deepgitstatus

[21:45] <labster> masak: and that nicer form is standardized as RFC 3339.

[21:45] <vendethiel> (yes, that's a global variable)

[21:45] <masak> vendethiel: nice! :)

[21:46] <vendethiel> masak: perl6 can look very awk-ish! https://github.com/vendethiel/psmemparse/blob/master/psmemparse.p6

[21:46] <vendethiel> (I stopped working on this script because "next if $*ARGFILES.line == 1;" didn't quite exist, and I couldn't think or a reliable way to get per-file line number, so... but yeah)

[21:47] <vendethiel> masak: several people I "introduced" to perl6 told me they now do the same.. I should tell them to open-source it :)

[21:47] <masak> :)

[21:47] <vendethiel> well, it or them

[21:47] <masak> it probably needs to start this way

[21:47] <masak> Perl 6 from the ground up. from scripts through programs to applications.

[21:47] <masak> I know people are writing applications already, but...

[21:48] <masak> only lately does it feel like Perl 6 is getting established in people's ~/bin directories, for some reason.

[21:48] <masak> maybe a reason called "stability".

[21:48] <labster> and a reason named "speed"

[21:49] <masak> aye

[21:49] <vendethiel> whichever it is..:)

[21:49] <[Coke]> FROGGS: https://github.com/perl6/roast/commit/7e0c2b0c fails on os x.

[21:50] <masak> one of the scripts in my ~/bin directory runs each time I open a new terminal session -- and it *doesn't make me drum my fingers against the table*

[21:50] <vendethiel> (who's next to write a blog engine in perl6? I already am.. :P)

[21:50] <vendethiel> anyway -- good night, #perl6!

[21:51] <masak> 'night, ven

[21:51] <labster> I remember drumming my fingers against the table after typing the first command in a REPL session.

[21:51] <labster> night

[21:56] *** stux|away joined
[22:00] *** cognominal left
[22:01] *** cschwenz joined
[22:01] <timotimo> https://gist.github.com/timo/afb0413f1aead980a275 - a perl6 script automated converting a bunch of C code into an expression tree format for brrt's new jit

[22:02] <cschwenz> Is there a SQLite module for Perl6?

[22:03] <masak> cschwenz: DBIish supports SQLite.

[22:03] <timotimo> yup

[22:03] <cschwenz> \o/  thanks!

[22:03] <masak> https://github.com/perl6/DBIish/

[22:03] <cschwenz> *really* didn't want to go down the route of rolling my own.  :-)

[22:03] * [Coke] misses having a working repl by default.

[22:03] <masak> by the way, can we remove the "Search" text box at the top of http://modules.perl6.org/ ?

[22:04] <masak> it's no significant improvement on Ctrl+F in the browser.

[22:08] <jdv79> its not the same

[22:08] <timotimo> what bothers me about ctrl-f is that i can't then just hit return to activate a link i've selected via the search

[22:09] <timotimo> or at least tab from the search result to the next visible link or somethign

[22:09] <jdv79> plus modules.perl6.org may be nearing EOL anyway, no?

[22:10] <timotimo> maybe not as quickly as you think?

[22:10] <jdv79> probably

[22:12] *** espadrine joined
[22:13] *** cschwenz left
[22:13] *** vendethiel left
[22:16] <masak> timotimo: either Esc followed by Return, or Ctrl-Return works in that situation.

[22:17] <timotimo> oh?

[22:17] <timotimo> i didn't realize, i shall try that

[22:17] <masak> the former takes you out of search mode

[22:17] *** llfourn joined
[22:17] <masak> the latter follows the link despite you being in search mode :) # hat-tip to a tadzik++ tweet

[22:18] <masak> I repeat my case. Ctrl+F is already quite powerful. we're not adding anything by having a search box in-page.

[22:18] <masak> 'night, #perl6

[22:19] <timotimo> gnite masak!

[22:20] *** rindolf left
[22:21] *** jack_rabbit joined
[22:22] *** llfourn left
[22:24] <laben> getting late here, i'm off to bed. stay happy #perl6

[22:24] <yoleaux> 19:03Z <nine> laben: Of lists we know if they are lazy or not. Of lazy lists we may know that they are infinite or may be infinite. For example, what makes you think, that .lines is finite? It could be a stream of a webserver log that for all intents and purposes _is_ infinite.

[22:24] *** laben left
[22:26] *** espadrine left
[22:26] *** jack_rabbit left
[22:35] *** RabidGravy left
[22:37] *** geekosaur left
[22:39] *** geekosaur joined
[22:40] *** geekosaur left
[22:40] *** geekosaur joined
[22:42] *** amurf joined
[22:43] *** salva left
[22:47] *** amurf left
[22:53] <lizmat> packing and decommute&

[22:53] <skids> m: join("", $["a", "b", "c"])

[22:53] <GLRelia> rakudo-moar ef6669: ( no output )

[22:53] <camelia> rakudo-moar d6bf55: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/TVzG6okBFY:1␤␤Actually thrown at:␤  in block <unit> at /tmp/TVzG6okBFY:1␤␤»

[22:55] <timotimo> m: say $["a", "b", "c"]

[22:55] <GLRelia> rakudo-moar ef6669: OUTPUT«a b c␤»

[22:55] <camelia> rakudo-moar d6bf55: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/GVopRPnZgm:1␤␤Actually thrown at:␤  in block <unit> at /tmp/GVopRPnZgm:1␤␤»

[22:57] <skids> I'm actually becoming less sure about whether $ is supposed to protect against single-item-rule or not.  I'm supposed to be becoming more sure about things :-)

[22:59] <skids> Also, whether join is supposed to be one of the "this flattens in sub form" ones.

[23:01] *** BenGoldberg left
[23:02] * skids wonders if the camelia "problem" is someone turning on GC because those Failures are generated/caught in the num-stringifiction code.

[23:02] *** BenGoldberg joined
[23:02] <skids> m: join("", $["a", "b", "c"]); END { "done".say };

[23:02] <GLRelia> rakudo-moar ef6669: OUTPUT«done␤»

[23:02] <camelia> rakudo-moar d6bf55: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/5VNbQ4l8dP:1␤␤Actually thrown at:␤  in block <unit> at /tmp/5VNbQ4l8dP:1␤␤done␤»

[23:03] <skids> m: join("", $["a", "b", "c"]); "done".say;

[23:03] <GLRelia> rakudo-moar ef6669: OUTPUT«done␤»

[23:03] <camelia> rakudo-moar d6bf55: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in block <unit> at /tmp/JK3Enb04jn:1␤␤Actually thrown at:␤  in block <unit> at /tmp/JK3Enb04jn:1␤␤»

[23:03] <skids> Though wait why would it even...

[23:05] <jdv79> FROGGS: what is b7035eb77588792e in pause all about?

[23:05] <jdv79> seems like a bandaid or a misunderstanding maybe?

[23:06] *** lizmat left
[23:10] *** colomon joined
[23:11] <colomon> o/

[23:15] <colomon> Anyone out there?

[23:16] *** amurf joined
[23:17] <skids> o/

[23:18] *** pmurias left
[23:18] *** colomon left
[23:24] <timotimo> i'm here

[23:32] *** dayangkun joined
[23:34] *** cbk1090 left
[23:46] *** cbk1090 joined
[23:48] <ugexe> CURLI bin wrappers are broke on GLR today

[23:48] <ugexe> m: my @installations = @*INC.grep( { .starts-with("inst#") } ).map: { CompUnitRepo::Local::Installation.new(PARSE-INCLUDE-SPEC($_).[*-1]) }; say @installations>>.files("foo");

[23:48] <camelia> rakudo-moar d6bf55: OUTPUT«   ␤»

[23:48] <GLRelia> rakudo-moar ef6669: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/y27osPy3Am:1␤␤»

[23:49] *** davercc left
[23:51] <skids> ugexe: grep's slurpy was changed to **@.  But I think that missed some necessary accompanyi changes.

[23:56] <ugexe> i figured, noticed some extra emptys ala [$[], $[], $[what i wanted]] that weren't there before.

[23:56] <skids> I'm working on seeing what happens if we change more slurpies, but am seeing conflicting ideas of what the single item rule does WRT containers.

