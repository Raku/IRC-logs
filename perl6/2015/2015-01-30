[00:02] *** ggherdov left
[00:05] <raydiak> so I defined a submethod DESTROY for my class, but it doesn't ever get called, that I can tell...say, die, etc should do something in there, right?

[00:05] *** ggherdov joined
[00:07] <raydiak> m: class Foo { submethod DESTROY { say "oh noes" } }; Foo.new # idk how DESTROY should interact with the evalbot, but this doesn't work locally either

[00:07] <camelia> rakudo-moar ac7ee6: ( no output )

[00:07] <ab5tract> .tell Kristien reading the backlog i notice it sounded like i was saying i prefer a syntax choice over an optimal solution -- that's only in golfing, if then :) this was just an example from the article i linked to in the comment. i thought it was cool that it's been stable syntax since 2009

[00:07] <yoleaux> ab5tract: I'll pass your message to Kristien.

[00:08] <ab5tract> (if not well before 2009)

[00:11] <ab5tract> japhb: one heck of a golf indeed! i have a feeling that the ::Sci namespace in Perl 6 is going to be one very interesting realm of compunits

[00:15] *** madcapJake joined
[00:20] *** kurahaupo1 joined
[00:22] *** pmurias left
[00:34] <masak> pro tip: if you max= on a bunch of values and they all come out as '9', it's probably because they're strings from a SQL database and not numbers as you assumed.

[00:36] *** muraiki_ joined
[00:38] <vendethiel> *g*

[00:40] *** yeahnoob joined
[00:41] *** adu left
[00:42] *** kurahaupo2 joined
[00:42] *** kurahaupo1 left
[00:43] <raydiak> idk if anyone actually tries using this stuff yet, but App::Pray and Image::PNG::Portable no longer segfault

[00:44] *** BenGoldberg joined
[00:54] *** raiph joined
[00:54] *** BenGoldberg left
[00:54] *** BenGoldberg joined
[00:56] *** prime left
[01:04] <masak> "You might actually not have that much time to try Perl6 [...] before it is declared production ready and becomes mainstream." -- http://programming.tudorconstantin.com/2015/01/shock-and-terror-perl-is-readable.html

[01:28] <BenGoldberg> Love the pic on that page :)

[01:40] *** yeahnoob left
[01:53] <japhb> .oO( Where's *my* jet-powered camel? )

[01:55] <masak> 'night, #perl6

[01:55] *** kurahaupo2 is now known as kurahaupo

[01:58] <japhb> o/ masak

[02:00] *** espadrine left
[02:00] <skids> I like the method in those slides.  Show ugly, then "fix" it to what most people find acceptible, then surprise then by fixing it even more.

[02:11] *** docdurdee joined
[02:12] <docdurdee> p6: say 3

[02:12] <camelia> rakudo-{parrot,moar} ac7ee6: OUTPUT«3␤»

[02:12] <docdurdee> p6: say $_ for (0 .. 100)

[02:12] <camelia> rakudo-{parrot,moar} ac7ee6: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51…»

[02:13] <skids> o/

[02:17] *** docdurdee left
[02:31] *** chenryn joined
[02:34] <muraiki_> meow

[02:34] *** muraiki_ left
[02:37] *** IllvilJa left
[02:38] *** fwilson left
[02:44] *** fwilson joined
[03:10] *** kurahaupo left
[03:11] *** telex left
[03:12] *** telex joined
[03:17] *** dj_goku joined
[03:23] <colomon> raydiak: Lastfm, eh?

[03:24] <raydiak> colomon: more of a digitally imported/radiotunes guy myself

[03:25] <raydiak> but maybe you meant https://github.com/avuserow/perl6-webservice-lastfm/ :)

[03:25] <colomon> THere’s a http://www.last.fm/user/colomon

[03:25] <raydiak> oh I see

[03:25] <colomon> yes, that’s what I meant

[03:25] <raydiak> do I have an account on there?

[03:25] <colomon> wait, you’re totally right.  how did I get confused and think it was by you?

[03:26] <raydiak> lotta new modules lately :)

[03:26] <colomon> oh, it was right next to Image::PNG::Portable in the smoke output.  

[03:26] <colomon> simple off-by-one reading error.  :)

[03:27] <raydiak> maybe not as engaging as music, but I am excited to be able to output PNGs from Pray soon

[03:29] *** raiph left
[03:31] <colomon> heck, that’s more exciting than last.fm!

[03:31] <FROGGS_> so, that's happening here at night :o)

[03:31] <FROGGS_> morning

[03:31] <raydiak> \o FROGGS_ 

[03:32] * FROGGS_ yawns into his coffee

[03:33] <raydiak> it's pretty thin in terms of features atm, but it works, and I'm testing a patch to moar right now so CArrays are zero-filled by default and I can get all the malloc/memset/free garbage out of my module too :)

[03:34] *** BenGoldberg left
[03:35] <raydiak> though I have to see if there's some way I can package a precompiled zlib.dll with my module and point compress::zlib at it for the windows folks, I guess

[03:35] <raydiak> haven't actually tried windows yet but it's one of the main goals of course given the name

[03:37] <colomon> o/ night

[03:37] <FROGGS_> gnight colomon 

[03:37] <raydiak> \o colomon 

[03:37] <FROGGS_> raydiak: I also thought about shipping dll's to windows boxes...

[03:38] <FROGGS_> (my libxml2 bindings)

[03:38] *** kurahaupo1 joined
[03:39] <raydiak> it'd be awesome if it became a common practice for nativecall modules, imo

[03:39] *** vendethiel left
[03:40] <FROGGS_> aye

[03:42] <FROGGS_> gtg

[03:42] *** FROGGS_ left
[03:43] <raydiak> \o/ my first moar patch ever (or even C, for that matter) seems to work on the first try!

[03:43] *** IllvilJa joined
[03:49] *** noganex_ joined
[03:50] <skids> star: use NativeCall; my @f := CArray[int].new; @f[0] = 1; @f[1] = 2; @f.elems.say; @f[0].say; @f[1].say; @f[].say; @f[0,1].say

[03:50] <camelia> star-{m,p} 2014.12: OUTPUT«1␤1␤2␤␤0␤»

[03:52] *** noganex left
[03:58] <skids> Those used to work I am pretty sure.

[04:11] *** oetiker left
[04:22] *** chenryn left
[04:27] *** araujo left
[04:28] *** araujo joined
[04:38] *** adu joined
[04:50] *** araujo left
[04:51] *** FROGGS[mobile] joined
[04:52] <FROGGS[mobile]> does somebody need more air? I'm at an air port...

[04:58] <FROGGS[mobile]> does somebody know if it is as cheap and easy in Belgium to bye mobile broadband cards like it was in Austria?

[05:00] *** mr-foobar left
[05:08] *** chenryn joined
[05:08] *** vendethiel joined
[05:23] *** fil_ joined
[05:24] <fil_> hey

[05:24] <fil_> quick question

[05:24] <fil_> any1 here?

[05:24] <raydiak> nope :)

[05:24] <moritz> that *was* a quick question

[05:24] <fil_> yay!

[05:24] * TimToady ain't here neither

[05:24] <moritz> another satisfied customer. NEXT!

[05:24] <fil_> so I've got a grammar going

[05:25] <fil_> I can't find good docs for how to work with Match objects

[05:25] <fil_> I figured out how to get what I want

[05:25] <fil_> but it looks messy

[05:25] <fil_> 	my $parsed = QFXXML.parse($xml); 	for @($parsed<itm>) -> $itm { 		my $pair = $itm.list().[0].caps().[0];

[05:25] <moritz> fil_: http://doc.perl6.org/type/Match

[05:25] <fil_> Is there a shorter way to get at the $pair I'm interested in?

[05:25] <fil_> yes I found that doc

[05:26] <fil_> but it wasn't that helpful

[05:26] <moritz> fil_: show the grammar please

[05:26] <fil_> grammar QFXXML { 	token TOP { ^ <itm>+ $ } 	token itm { ( <doctype> | <closetag> | <opentag> | <cdata> ) } 	token doctype { \< \? <-[>]>+ \> } 	token closetag { \< \/ <-[>]>+ \> } 	token opentag { \< <-[>]>+ \> } 	token cdata { <-[<>]>+ } }

[05:26] <fil_> I'm iterating over items

[05:26] <fil_> it all works

[05:27] <fil_> it's just that this part feels messy: my $pair = $itm.list().[0].caps().[0];

[05:27] <FROGGS[mobile]> an action class might be more elegant 

[05:27] <fil_> is there a clearer / shorter way to get at what I'm after?

[05:28] <fil_> the code after it looks pretty

[05:28] <fil_> given $pair.key { 			when <opentag> {

[05:28] <fil_> ...

[05:28] <fil_> I just don't like my $pair = $itm.list().[0].caps().[0];

[05:29] <fil_> it feels like a common scenario that there should be helper functions for this sort of thing

[05:29] <FROGGS[mobile]> hmmm, that really sounds like you want an action class 

[05:29] <fil_> can you point me to a doc?

[05:29] <fil_> they work with grammars?

[05:29] <FROGGS[mobile]> not from my phone

[05:30] <moritz> fil_: https://github.com/rakudo/star/blob/master/docs/UsingPerl6-draft.pdf?raw=true the chapter on grammars also talks about action methods

[05:31] <moritz>  / action classes

[05:31] <raydiak> if you didn't want to write a whole actions class, could you put "{ make .list().[0].caps().[0] }" in token TOP or something along those lines?

[05:31] <raydiak> s/in/at the end of/

[05:31] <FROGGS[mobile]> m: grammar G { token foo { a +% b} }; class A { method foo($/) { say $/} }; G.parse( 'ababa', :actions(A))

[05:31] <camelia> rakudo-moar ac7ee6: OUTPUT«No such method 'TOP' for invocant of type 'G'␤  in method parse at src/gen/m-CORE.setting:15013␤  in block <unit> at /tmp/PHFDBpQc8o:1␤␤»

[05:32] <fil_> ok

[05:32] <FROGGS[mobile]> my..parse method wants a :rule('foo')

[05:32] <fil_> I will study actions

[05:32] <fil_> thanks for the pointer

[05:33] <fil_> I agree it sounds like Actions is what I'm looking for

[05:33] <FROGGS[mobile]> and I cant copy+paste here

[05:33] <fil_> I knew I must be doing something wrong when I had to type my $pair = $itm.list().[0].caps().[0];

[05:33] *** vendethiel left
[05:33] <fil_> thanks for the help!

[05:33] <moritz> fil_: which token from the grammra do you want to extract?

[05:34] <FROGGS[mobile]> and then you reinspect it, just after parsing its tokens :o)

[05:34] *** fil_ left
[05:35] <raydiak> yes if you don't use an actions class, you do get a real mess: https://github.com/raydiak/Math-Symbolic/blob/master/lib/Math/Symbolic.pm6#L918

[05:36] <FROGGS[mobile]> messy like my P5 code often looks

[05:36] <raydiak> wow yer right...it looks a lot like my P5 code did; never noticed before

[05:41] <FROGGS[mobile]> :o)

[05:52] *** adu left
[05:57] <raydiak> working on C code feels like reaching my hand into muddy opaque crocodile-inhabited waters compared to P6

[05:59] *** FROGGS[mobile] left
[06:00] *** baest left
[06:19] *** xfix joined
[06:42] *** Rounin joined
[06:46] *** tinyblak joined
[07:07] *** jack_rabbit joined
[07:15] *** noganex joined
[07:18] *** espadrine joined
[07:18] *** noganex_ left
[07:20] <tadzik> to me it always feels like chopping wood with my bare hands

[07:24] <raydiak> I like that; seems more thoroughly accurate

[07:25] <raydiak> (mainly because sticking your hand in muddy water isn't very rewarding most of the time)

[07:27] *** kurahaupo1 left
[07:31] *** rurban_ joined
[07:34] *** kaleem joined
[07:34] *** sqirrel joined
[07:48] *** jack_rabbit left
[07:55] *** mvuets joined
[08:00] *** yeahnoob joined
[08:08] <jnthn> Not to mention if you bring your axe down off the end of the log, you chop your foot off... :)

[08:08] <yoleaux> 29 Jan 2015 23:49Z <raydiak> jnthn: #123700

[08:08] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=123700

[08:08] <jnthn> raydiak++

[08:10] *** bjz joined
[08:11] *** virtualsue joined
[08:12] *** darutoko joined
[08:14] * jnthn wanders off to the airport, for le FOSDEM trip &

[08:15] *** bjz left
[08:15] *** chenryn left
[08:18] *** bjz joined
[08:19] *** chenryn joined
[08:19] *** IllvilJa left
[08:25] *** Kristien joined
[08:26] *** petercommand left
[08:26] *** BigBear joined
[08:27] *** petercommand joined
[08:28] *** IllvilJa joined
[08:31] *** bjz left
[08:38] <pmichaud> bonjour, #perl6

[08:41] <lizmat> pmichaud: good morning

[08:42] <lizmat> .tell raydiak re DESTROY not working: that is exactly why I think it is a bad name

[08:42] <yoleaux> lizmat: I'll pass your message to raydiak.

[08:42] <lizmat> .tell raydiak because atm DESTROY only gets called on GC cleanups

[08:42] <yoleaux> lizmat: I'll pass your message to raydiak.

[08:43] <lizmat> .tell raydiak and if there isn't one, then it just won't get called

[08:43] <yoleaux> lizmat: I'll pass your message to raydiak.

[08:43] <pmichaud> maybe "GOODBYE" instead of "DESTROY"?  ;-)

[08:44] <raydiak> ah, so there is *no* reliable way to do that?

[08:44] <yoleaux> 08:42Z <lizmat> raydiak: re DESTROY not working: that is exactly why I think it is a bad name

[08:44] <yoleaux> 08:42Z <lizmat> raydiak: because atm DESTROY only gets called on GC cleanups

[08:44] <yoleaux> 08:43Z <lizmat> raydiak: and if there isn't one, then it just won't get called

[08:44] <lizmat> raydiak: there is, with phasers

[08:44] <lizmat> but not in the class itself

[08:44] <lizmat> now, I think we need a way to export a phaser to a caller

[08:45] <raydiak> hrm

[08:45] <lizmat> but on the other hand, that might be too much action at a distance

[08:45] <lizmat> you could for instance do a:

[08:45] <raydiak> why not just always call DESTROYALL?

[08:45] <lizmat> LEAVE $dbh.?disconnect

[08:46] <lizmat> you mean at program exit ?

[08:47] <raydiak> aye

[08:47] <pmichaud> Wait, I know!  The DESTROY method should be called STAY-PUFT

[08:47] <lizmat> probably because in most of the case you don't need it

[08:47] <lizmat> there was a discussion recently on p5p where it was shown that the teardown of a Perl process in a forked environment

[08:48] <pmichaud> that's the form of the destructor as named in Ghostbusters  :)

[08:48] <lizmat> can be really slow because the teardown dirties COW pages in the OS

[08:48] *** fhelmberger joined
[08:48] <raydiak> so performance reasons...hm

[08:48] <lizmat> so, again, why I think DESTROY is a very bad name for the functionality being offered in Perl 6

[08:49] <raydiak> well it does exactly what we need except for not being reliable, and much more cleanly than putting the onus of cleaning up my mess on the caller

[08:49] <lizmat> raydiak: but what is it that you need to clean up?

[08:49] <raydiak> so maybe we need a copy of it called something else which *is* reliable

[08:49] <lizmat> memory?

[08:49] <lizmat> database connections?

[08:50] <raydiak> memory

[08:50] <lizmat> but why would you care?

[08:50] <lizmat> the system should be able to do that for you

[08:50] <lizmat> the GC of the system  :-)

[08:50] <raydiak> b/c I nativecall malloc'd it

[08:50] <raydiak> and so need to free it

[08:50] <lizmat> so we would need to somehow inform the GC that it needs to free it when it need it

[08:51] <lizmat> *needs to

[08:51] *** bjz joined
[08:51] <raydiak> maybe by giving it something to hook into...like a DESTROY method but called something else?

[08:51] <lizmat> too bad jnthn is travelling atm, he could chime in on this

[08:51] *** jack_rabbit joined
[08:52] <lizmat> well, in this case, I would more think along a special malloc that hooks into the GC somehow

[08:52] <pmichaud> that sounds special-case-y to me

[08:52] <raydiak> but I think saying "you don't ever need to reliably call something at exit" feels very wrongish

[08:53] *** kjs_ joined
[08:53] <pmichaud> I think there ought to be a generalized "you're about to be destroyed" method that lets an object take care of any cleanup it needs done

[08:54] <lizmat> pmichaud: there Is: it's called DESTROY

[08:54] <lizmat> but the timing of it, and whether it really runs, are unclear

[08:55] *** Otterpocket joined
[08:55] <pmichaud> well, for most objects there probably doesn't need to be a DESTROY

[08:55] <pmichaud> I could see it being a role... something like Destroyable

[08:55] <raydiak> in my specific case, I'm hacking around a series of limitations which are all temporary, but it has revealed a more serious limitation, imo...we really need to be able to do this in a composable way, which phasers don't seem to be, on this axis

[08:55] <pmichaud> so, objects that don't have the Destroyable role don't bother with a DESTROY call on destruction

[08:56] *** abraxxa joined
[08:56] <raydiak> I like it

[08:56] <pmichaud> that way the check for whether or not to invoke DESTROY could be made quicker

[08:56] <arnsholt> I've some thoughts on how to handle the whole "should this memory be freed on GC" problem in NativeCall, but nothing very implementable just yet

[08:56] <lizmat> m: my $d; class A { method DESTROY { $d++ } }; for ^10000 { A.new }; say "seen $d DESTROYs"

[08:56] <camelia> rakudo-moar ac7ee6: OUTPUT«seen 6566 DESTROYs␤»

[08:57] <lizmat> pmichaud: afaik, the existence of a DESTROY method at compose time, already sets such a flag

[08:57] <lizmat> m: my $d; class A { method DESTROY { $d++ } }; for ^10000 { A.new }; say "seen $d DESTROYs"

[08:57] <camelia> rakudo-moar ac7ee6: OUTPUT«seen 6566 DESTROYs␤»

[08:58] <pmichaud> okay, that can work also, but somehow I think it might be better exposed as a role

[08:58] <pmichaud> timely destruction is something we abandoned/postponed long ago

[08:58] <lizmat> fwiw, I think the existence of the method, is flag enough

[08:58] <JimmyZ> 200~m: my $d; class A { method FINALIZE { $d++ } }; for ^10000 { A.new }; say "seen $d DESTROYs"

[08:58] <mathw> morning

[08:58] <JimmyZ> m: my $d; class A { method FINALIZE { $d++ } }; for ^10000 { A.new }; say "seen $d DESTROYs"

[08:58] <camelia> rakudo-moar ac7ee6: OUTPUT«use of uninitialized value $d of type Any in string context␤seen  DESTROYs␤»

[08:59] <moritz> pmichaud: I've even tried to document it: http://doc.perl6.org/type/Metamodel%3A%3AFinalization

[08:59] <JimmyZ> m: my $d; class A { method FINALIZE { state $++ } }; for ^10000 { A.new }; say "seen $d DESTROYs"

[08:59] <camelia> rakudo-moar ac7ee6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/q29k1_jXpb␤Preceding context expects a term, but found infix + instead␤at /tmp/q29k1_jXpb:1␤------> [32m; class A { method FINALIZE { state $++ [33m⏏[31m} }; for ^10000 { A.new }; say "se…»

[08:59] <raydiak> good morning mathw 

[08:59] <arnsholt> pmichaud: Yeah, timely destruction (and guaranteed order) restricts the options for GC strategy quite a bit, no?

[09:00] <moritz> well, for timely we have LEAVE block

[09:00] <tadzik> yeah, I was wondering if guaranteed order is still something to aim for

[09:00] <lizmat> arnsholt: I think the order follows out of the reachability constraint that is there for getting finalized anyway

[09:00] <pmichaud> somewhere very long ago... almost back to pugs days I think ... it was decided that Perl 6 wouldn't bother with timely destruction (for now?)

[09:00] <mathw> Whenever destruction comes up in the context of a language with GC I suddenly find myself wanting to be a C++ programmer again.

[09:00] *** jack_rabbit left
[09:01] <lizmat> moritz: or the specced (and half implemented) "will leave" clause on variables

[09:01] *** sqirrel left
[09:01] <moritz> lizmat: right

[09:01] <lizmat> my $dbh will leave { .disconnect };

[09:01] <pmichaud> I'm afk for a bit

[09:01] <mathw> lizmat: that is very cool. I like that.

[09:01] <moritz> python has  with dbh = connect():  do stuff

[09:02] <raydiak> often you don't care about any of that, just that you know for sure it will get called exactly once unless something *really* catastrophic happens

[09:02] <mathw> C# has using() blocks that call Dispose on things when they go out of scope

[09:02] <mathw> Which alleviates most of the pain

[09:03] <lizmat> mathw: how is that different from LEAVE ?

[09:03] <Kristien> mathw: F# has use variables, which I like better since they don't require a new scope

[09:03] <yoleaux> 00:07Z <ab5tract> Kristien: reading the backlog i notice it sounded like i was saying i prefer a syntax choice over an optimal solution -- that's only in golfing, if then :) this was just an example from the article i linked to in the comment. i thought it was cool that it's been stable syntax since 2009

[09:03] <moritz> lizmat: it's the same semantic, just different presentation

[09:03] <Kristien> for example:

[09:04] <Kristien> use $foo = Bar.new;

[09:04] <raydiak> I guess I'm wondering what DESTROY *is* meant to be useful for

[09:04] <Kristien> it would also be useful if this were possible for attributes

[09:04] *** mvuets left
[09:04] <moritz> raydiak: avoiding resource leaks in the long run

[09:04] <mathw> lizmat: it's nowhere near as flexible and it has an annoying syntax.

[09:05] <mathw> Kristien: yes, F#'s version is preferable to me as well, but I have yet to convince my colleagues of the value of the language as a whole.

[09:05] <mathw> Many of them think C# is the cutting edge

[09:05] <raydiak> moritz: how is it useful for that if it's not reliable?

[09:06] <raydiak> except as a "mitigate the damage enough to make it bearable" kinda measure :/

[09:06] <moritz> raydiak: in your exmaple, the program terminated before all of them were DESTROYed

[09:06] *** zakharyas joined
[09:06] <mathw> But I do like the idea that 'will leave' gives you of providing the cleanup code right there where you do the thing that needs cleaning up later, so it's all together. Phasers are a concept I'm growing to like more the more Perl 6 I've been writing lately.

[09:07] <moritz> raydiak: and when a program terminates quickly, it can't leak resources

[09:07] <moritz> raydiak: if it ran longer, all of them would be collected.

[09:07] <lizmat> to give you a datapoint:

[09:07] <raydiak> even if it doesn't free memory, it won't leak?

[09:07] <moritz> raydiak: which care are you talking about?

[09:07] <lizmat> in mod_perl, there is a special setting that will tear down a child process *without* running any of the normal Perl (5) teardown

[09:08] <moritz> raydiak: program exit frees all memory

[09:08] <lizmat> at former $work, I've seen this make the difference between being able to run the site and not

[09:08] <raydiak> yes perhaps I'm getting things tangled...tis 1 AM here

[09:08] <lizmat> because the normal teardown of a process was in the ~20 seconds range (yes, twenty whole seconds)

[09:08] <Kristien> mathw, I thought it was about Perl 6

[09:09] <lizmat> taking 100% of CPU during the teardown, as it was all CPU bound

[09:10] <Kristien> I should give Boehm GC a try.

[09:10] *** jack_rabbit joined
[09:12] *** kjs_ left
[09:12] <lizmat> In a way, the timely / unknown when discussion about finalization, reminds me of the discussion of driving a stick shift or an automatic

[09:13] <lizmat> driving a car with a stick shift, may make you feel more in control

[09:13] <lizmat> but whichever way you look at it, it is a hack around the fact that a petrol engine cannot give enough power at some rotational speeds

[09:14] <moritz> and these days, even Formula 1 pilots drive with automatic

[09:14] <moritz> (iirc)

[09:14] <lizmat> let's say that Perl 6 is an automatic, and Perl 5 has a stick shift  :-)

[09:14] <raydiak> so perhaps make it harder or at least more weird-looking to do, but are you really trying to tell me that it's not important to let people do that reliably, at all, for any reason ever, in a module instead of the code using the module?

[09:15] <lizmat> indeed, yes, generally you shouldn't care

[09:15] <lizmat> although Perl 6 is not a CVT, it's still an automatic

[09:15] <tadzik> hehe, the way I always look at it is similar to a "should I write my web crawler in C or Perl". Of course the one in C will be faster, but it's just a web crawler, and Perl tools will do better what I'd do wrong in C

[09:15] <tadzik> so why would I drive to the supermarket with manual? :)

[09:15] <tadzik> I'm not a racecar drivre

[09:16] <lizmat> In about an hour, we'll be picking up a van for moving a lot of stuff to FOSDEM

[09:16] <lizmat> the van has a nice "feature"

[09:16] <lizmat> it shows a light on the dashboard when you're supposed to shift up or down a gear

[09:17] <lizmat> to me, that it just stupid: if the car knows it should have a higher/lower gear, why doesn't it switch itself?

[09:17] <moritz> and my reaction to that would be "why don't you f$#$#ing do it yourself, smarta$$?" :-)

[09:17] <lizmat> indeed

[09:18] <Kristien> tadzik, the first rule of C is that you should never use C for anything

[09:19] <raydiak> given that my problem only exists because I've already gone a bit off-road with nativecall mallocing stuff I only half understand to get around problems which won't exist, and I don't have a good counter example off the top of my head...I'll concede the point for now and meditate on this wisdom :)

[09:19] <lizmat> :-)

[09:21] *** kjs_ joined
[09:21] <raydiak> but so even in C, if you don't free stuff, the OS reliably reclaims your memory when the program exits? I am fuzzy on these sorts of things

[09:21] <lizmat> yes, the OS is expected to

[09:21] <Kristien> that's language-agnostic

[09:21] <lizmat> the only exception to that, are unclaimed zombies, afaik

[09:22] <lizmat> but it has been a while since I've seen any of those

[09:22] <Kristien> no

[09:22] <Kristien> zombie processes have their memory freed

[09:23] <mathw> Memory leaks are only an issue if your process stays alive.

[09:23] <Kristien> their only overhead is an entry in the process table that contains their PID, exit status and a few flags

[09:23] <raydiak> hm so I should just use DESTROY then and not worry if it doesn't get called, like how I was going to :P

[09:24] *** kjs_ left
[09:25] <Kristien> and wait() deletes the entry by violating CQS

[09:26] <TuxCM> http://www.xs4all.nl/~hmbrand/t.pl <= what is the perl6 syntax to do self!$m($x); (and will self!can($m) work as I want)

[09:27] <raydiak> this all makes sense I would have noticed "magical diasappearing memory" as a user...I guess jumping in to C just reminds me of that "don't assume ANYTHING" feeling

[09:27] *** kjs_ joined
[09:28] <Kristien> it means you jump into the realm of unnecessary bugs like heartbleed

[09:29] <TuxCM> ! => . → Cannot find method 'postcircumfix:<( )>'

[09:30] <moritz> TuxCM: you want to call a private method with a variable name?

[09:30] <moritz> TuxCM: that would be self!"$name"(arguments), I think

[09:30] <TuxCM> I want to call a public/private method *named* $m with variable $v

[09:31] <moritz> m: class A { method call() { my $name = "priv"; self!"$name"(42) }; method !priv($x) { say 42 } }; A.new.call

[09:31] <camelia> rakudo-moar ac7ee6: OUTPUT«42␤»

[09:31] <Kristien> raydiak: the only real reason to use C for anything is because you have to maintain something written in C. for anything else you should always use higher-level tools that give stronger guarantees and require less effort to get stuff to work

[09:31] <TuxCM>             if (self.can ($m)) {

[09:31] <TuxCM>                 self."$m"(%init{$attr});

[09:32] <TuxCM> *that* works

[09:32] <TuxCM> message to FROGGS: «self."$m" (%init{$attr});» does not work under Tuxic

[09:33] <moritz> TuxCM: fwiw without the quotes, it would try to use $m as a code object

[09:33] *** molaf__ joined
[09:33] <moritz> TuxCM: no whitespace allowed before the opening paren

[09:33] <moritz> m: 42.&say()

[09:33] <camelia> rakudo-moar ac7ee6: OUTPUT«42␤»

[09:33] <TuxCM> whitespace is allowed under Slang::Tuxic

[09:33] <moritz> oh

[09:33] *** Kristien left
[09:33] <TuxCM> That is why I am active in perl6 again

[09:34] *** espadrine left
[09:35] * moritz didn't know

[09:36] *** alpha- joined
[09:36] *** molaf_ left
[09:37] <raydiak> good night, #perl6

[09:38] *** sqirrel joined
[09:42] <moritz> good night, raydiak. Dream of timely destruction!

[09:45] *** chenryn left
[09:48] *** Kristien joined
[09:48] *** pnu left
[09:48] *** pnu joined
[09:50] <tadzik> hehe, out of context that sounds pretty grim :P

[09:51] <moritz> uhm, right, I wasn't aware of that :-)

[09:57] <jnthn> The rules on DESTROY are that it's called at most once, upon the GC deciding the object is unreachable (with the exception of it being on the queue of things that need a DESTROY call)

[09:58] <jnthn> If you never reach the point of GCing the object, the call will never happen.

[09:58] <jnthn> We don't attempt to go and GC the world at shutdown, because it's a huge waste of time. The OS can clean up stuff way faster than we can.

[09:59] <jnthn> And if your DESTROY makes the object reachable again, then you won't get your DESTROY called a second time when it becomes unreachable. 

[09:59] <jnthn> "You only live twice"

[09:59] *** rindolf joined
[09:59] <moritz> jnthn++

[10:01] <nwc10> jnthn++

[10:01] <TuxCM> how does p5 «my $v = "x"; my $w = "x${v}x"» translate to p6? ${v} is obviously not the correct syntax

[10:02] <TuxCM> I know I can use "x"~$v~"x"

[10:02] <TuxCM> but I wonder about interpolation syntax

[10:03] <moritz> "x{$v}y"

[10:03] <moritz> code blocks in general interpolate

[10:03] <moritz> so you could also write "x{ $v }y" and get the same result

[10:03] <lizmat> class A { method foo { say "foo" } }; my $a = A.new; $a.can("foo")[0]($a)  # use the result of .can directly, like in P5

[10:03] <TuxCM> Top, I'll try to remember. It does have a lot of logic

[10:03] <lizmat> m: class A { method foo { say "foo" } }; my $a = A.new; $a.can("foo")[0]($a)  # use the result of .can directly, like in P5

[10:03] <camelia> rakudo-moar ac7ee6: OUTPUT«foo␤»

[10:04] <jnthn> Looks like it's nearly boarding time :)

[10:04] <jnthn> See some of you in Brussels :)

[10:04] <lizmat> have a safe flight!

[10:04] <TuxCM> safe flight, see you

[10:04] <moritz> good journey!

[10:05] *** espadrine joined
[10:06] <lizmat> m: class A { method foo { say "foo" } }; my $a = A.new; .($a) for $a.can("foo")   # more correct use of .can

[10:06] <camelia> rakudo-moar ac7ee6: OUTPUT«foo␤»

[10:07] <TuxCM> lizmat, Type check failed in binding <anon>; expected 'Text::CSV' but got 'Bool'

[10:07] *** labster left
[10:07] *** labster_ joined
[10:07] <TuxCM>             my @can = self.can ($m);

[10:07] <TuxCM>             if (@can.elems > 0) {

[10:07] <TuxCM>                 @can[0](%init{$attr}); # space before ( not (yet) allowed under Tuxic

[10:07] <TuxCM>                 next;

[10:08] <lizmat> that code seems wrong to me

[10:08] <lizmat> why check for more than 1 elem, and then only do the first ?

[10:09] <TuxCM>             my @can = self.can ($m);

[10:09] <TuxCM>             if (@can.elems > 0) {

[10:09] <TuxCM>                 .(%init{$attr}) for @can; # space before ( not (yet) allowed under Tuxic

[10:09] <TuxCM>                 next;

[10:09] <TuxCM> even longer error messgae starts with

[10:09] <TuxCM> Type check failed in binding <anon>; expected 'Text::CSV' but got 'Bool'

[10:10] <TuxCM> wait, ($a) passes self, not a variable

[10:10] <lizmat> ah, yes

[10:10] <lizmat> that's the problem

[10:11] <lizmat> you need to pass the object as the first parameter

[10:11] <lizmat> in that sense, P6 is just the same as P5  :-)

[10:11] <TuxCM>             if (@can.elems > 0) {

[10:11] <TuxCM>                 .(self, %init{$attr}) for @can; # space before ( not (yet) allowed

[10:11] <lizmat> .(self,%init{$attr})

[10:11] <TuxCM> ok, nice enough. tests pass

[10:12] <masak> good antenoon, #perl6

[10:13] <lizmat> m: class A { method foo { say "foo" } }; my $a = A.new; $a.$_() for $a.can("foo")   # aaah, you *can* use the code object as a method  :-)

[10:13] <camelia> rakudo-moar ac7ee6: OUTPUT«foo␤»

[10:16] <TuxCM> both «$_.($v) for @can» and «$_!($v) for @can» fail though

[10:16] *** yeahnoob left
[10:17] <TuxCM> «.(self, %init{$attr}) for @can;» is good nuf for me

[10:17] *** FROGGS[mobile] joined
[10:17] <FROGGS[mobile]> hotel /o/

[10:18] <FROGGS[mobile]> nwc10: is that you in that little room?

[10:18] *** thilp left
[10:20] <nwc10> no, I'm in Vienna

[10:21] <FROGGS[mobile]> nwc10: must be your lost twin then O.o

[10:21] <TimToady> there are no little rooms in Vienna?

[10:21] *** pecastro joined
[10:22] <nwc10> I've seen at least one, but I was guessing that it wasn't "that" little room

[10:22] <nwc10> amd right now I seem to be the only person in a room with 8 desks

[10:23] <FROGGS[mobile]> that room here has one table but eight ppl

[10:24] *** espadrine_ joined
[10:25] *** espadrine left
[10:30] *** kjs_ left
[10:30] *** jack_rabbit left
[10:30] *** espadrine_ is now known as espadrine

[10:33] *** Kristien left
[10:34] *** mvuets joined
[10:35] *** FROGGS joined
[10:36] *** FROGGS[mobile] left
[10:40] *** vendethiel joined
[10:44] <timotimo> t/spec/S02-types/multi_dimensional_array.rakudo.moar .......... Dubious, test returned 255 (wstat 65280, 0xff00)

[10:44] <timotimo> am i perhpas on an outdated rakudo?

[10:45] <moritz> timotimo: I think I saw that problem yesterday too

[10:45] <moritz> timotimo: I was working on a (fresh) branch, so I wasn't sure if maybe the branch was to blame

[10:46] <timotimo> 'k

[10:46] <lizmat> I think it's Mouq's recent LoL patches that are to blame

[10:46] * timotimo has some things to look at here and there to pass him some time

[10:47] <lizmat> either 5275eb90c15cd35 or 166cd3c5ed3cf9d8

[10:49] *** abraxxa left
[10:50] *** andreoss joined
[10:55] *** spider-mario left
[10:56] <lizmat> afk fior a bit&

[10:57] <dalek> rakudo/nom: e4883a5 | timotimo++ | src/core/Cursor.pm:

[10:57] <dalek> rakudo/nom: eqat is nicer than substr + eq.

[10:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e4883a57fe

[10:58] <TuxCM> can I check the context of the caller in a method like perl5's caller? I'd likke to check if I am Void/Int|Num/Str/List|Array/Hash

[11:00] <nwc10> timotimo++

[11:00] <nwc10> timotimo: git grep 'substr.*\beq\b'

[11:00] <nwc10> two more to get in src/Perl6/Actions.nqp ?

[11:00] <FROGGS> m: class Foo { method Numeric { say "I'm called in Num context!"; 42 } }; say 1 + Foo.new

[11:00] <camelia> rakudo-moar ac7ee6: OUTPUT«I'm called in Num context!␤43␤»

[11:01] *** tinyblak left
[11:01] <FROGGS> TuxCM: that's how context works in Perl 6

[11:01] *** tinyblak joined
[11:02] <FROGGS> timotimo / nwc10: I intentionally left some substr's untouched... I think eqat does not queck bounds, so that can cause trouble

[11:04] *** tinyblak left
[11:04] *** tinyblak joined
[11:05] <FROGGS> hmmm, seems I am wrong

[11:10] <TuxCM> FROGGS, does code explain better? http://www.xs4all.nl/~hmbrand/t.pl

[11:10] <timotimo> nqp: my $hs = "hello world"; my $ndl = "world"; say(nqp::eqat($hs, $ndl, 6)) 

[11:10] <camelia> nqp-jvm: OUTPUT«(signal ABRT)*** Error in `java': double free or corruption (!prev): 0x00007f230401a8d0 ***␤*** Error in `java': double free or corruption (!prev): 0x00007f230401a8d0 ***␤#␤»

[11:10] <camelia> ..nqp-parrot: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " \"hello wo"␤current instr.: 'panic' pc 15755 (gen/parrot/stage2/NQPHLL.pir:5751) (gen/parrot/stage2/NQPHLL.nqp:425)␤»

[11:10] <camelia> ..nqp-moarvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " \"hello wo"␤   at gen/moar/stage2/NQPHLL.nqp:485  (/home/camelia/rakudo-inst-1/languages/nqp/lib/NQPHLL.moarvm:panic:105)␤ from <unknown>:1  (/home/camelia/rakudo-inst-1/languages/nqp/li…»

[11:10] <timotimo> nqp: my $hs := "hello world"; my $ndl := "world"; say(nqp::eqat($hs, $ndl, 6)) 

[11:10] <camelia> nqp-jvm: OUTPUT«(signal ABRT)*** Error in `java': free(): invalid pointer: 0x00007f1cc801d750 ***␤#␤# There is insufficient memory for the Java Runtime Environment to continue.␤»

[11:10] <camelia> ..nqp-{moarvm,parrot}: OUTPUT«1␤»

[11:10] <timotimo> nqp: my $hs := "hello worl"; my $ndl := "world"; say(nqp::eqat($hs, $ndl, 6)) 

[11:10] <camelia> nqp-jvm: OUTPUT«(signal ABRT)#␤*** Error in `java': double free or corruption (fasttop): 0x00007f7d30013450 ***␤# There is insufficient memory for the Java Runtime Environment to continue.␤*** Error in `java': double free or corruption (fasttop): 0x00007f7d3001d160 ***␤# ***…»

[11:10] <camelia> ..nqp-{moarvm,parrot}: OUTPUT«0␤»

[11:11] <moritz> TuxCM: try 'list' instead of 'Array', 'sink' instead of 'Void', 'hash' instead of 'Hash'

[11:11] <moritz> though .keys doesn't trigger hash context

[11:11] <moritz> m: say <a b c>.keys

[11:11] <camelia> rakudo-moar ac7ee6: OUTPUT«0 1 2␤»

[11:11] <FROGGS> moritz / TuxCM: though, it wont flatten... you cannot iterate over it just like that

[11:12] *** virtualsue left
[11:12] <FROGGS> m: class Foo { method list { say "I'm called in Array context!"; 42, 43 } }; .say for Foo.new

[11:12] <camelia> rakudo-moar ac7ee6: OUTPUT«Foo.new()␤»

[11:13] <TuxCM> FROGGS, that is list for the *class* in context

[11:13] <TuxCM> what about the context of a *method*

[11:13] <moritz> TuxCM: methods aren't called in contexts

[11:13] <TuxCM> method Numeric foo () {} is invalid

[11:13] <timotimo> only return values are evaluated in contexts

[11:14] <moritz> TuxCM: context doens't flow inwards like in perl 5

[11:14] <timotimo> so you'd return an object that'd have methods for the contexts you're interested in handling differently

[11:14] <TuxCM> Tue is PM, I'll ask Liz to do some explaining

[11:15] <FROGGS> what we call contexts in Perl 6 is what you might have done with 'use overload' in Perl 5

[11:21] <TuxCM> http://www.xs4all.nl/~hmbrand/t.pl <= like this? Why do String and list do not what I expect?

[11:21] <TuxCM> (the rest does)

[11:21] <timotimo> you want .Str or .Stringy

[11:21] <timotimo> but not .String

[11:22] <TuxCM> top!

[11:22] <TuxCM> and list?

[11:22] <timotimo> may want to have "is Iterable" or "does Positional" or something similar?

[11:22] <timotimo> i'm not experienced in making listy objects, but there was an advent calendar post on that exact topic

[11:25] *** sqirrel left
[11:40] *** abraxxa joined
[11:42] * colomon is completely baffled by TuxCM’s code

[11:43] <TuxCM> :)

[11:43] <TuxCM> can a class inside a class access the private variables of the surrounding class?

[11:45] <TuxCM> m: class Foo { has Int $!x = 0; class Bar { method Numeric { return $.x; }}; method bar { return Bar.new; }; say 0 + Foo.new.bar;

[11:45] <camelia> rakudo-moar e4883a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/_ekcmJ33gg␤Unable to parse expression in block; couldn't find final '}' ␤at /tmp/_ekcmJ33gg:1␤------> [32m return Bar.new; }; say 0 + Foo.new.bar;[33m⏏[31m<EOL>[0m␤»

[11:45] <tadzik> what was this opcode to force a GC run?

[11:45] <colomon> TuxCM: pretty sure that has to be return $!x

[11:46] <TuxCM> no, as that would be the $!x of Bar

[11:46] <masak> TuxCM: no, you can't reach the `self` of an outer class.

[11:46] <TuxCM> that much I understand of OO :)

[11:46] <TuxCM> damn

[11:47] <masak> TuxCM: my workaround tends to be to pass (an instance of) outer class as a parameter (or drop it in a contextual)

[11:47] <tadzik> ah, nqp::force_gc that is

[11:47] <TuxCM> my current thought are to pass all that is needed to fullfill my context wish to the subclass

[11:47] <masak> but there's no analogue of Java's OuterClass::self, for example.

[11:48] <masak> heh, if that were indeed the way Java wrote it ;)

[11:48] <masak> they write OuterClass.this

[11:49] <timotimo> yo japhb what's your status?

[11:49] <timotimo> i suspect "sleeping" or "at work" or something ,so i'll .tell

[11:50] <colomon> TuxCM: Stringy certainly works where you had String before

[11:50] <timotimo> .tell japhb i'd like to have an integrated tool for perl6-bench that can build a version of a compiler and the version before it, or alternatively you could pass a little patchset and it'd build the things with and without the patchset, time all things and immediately spit out a comparison graph file that might even contain the diff

[11:50] <yoleaux> timotimo: I'll pass your message to japhb.

[11:51] *** BigBear left
[11:53] *** kaleem left
[11:54] <TuxCM> got it working as I want. /me collects the hoops that were not caught in this circus act

[11:55] *** abraxxa left
[11:55] *** abraxxa joined
[11:55] <TuxCM> colomon, in what way baffled?

[11:55] <colomon> TuxCM: I was able to get the list case working with class Error::Diag is Iterable and method iterator { return [1, 2, 3].iterator;         }

[11:56] <colomon> TuxCM: didn’t understand what you were trying to do

[11:56] <colomon> have it working on my machine now.

[11:56] * colomon just woke up...

[11:56] <TuxCM> one moment, I'll push

[11:56] <timotimo> do you actually need to return ....iterator?

[11:58] *** rindolf left
[11:58] <colomon> timotimo: I didn’t try it the other way, but my naive assumption is that the iterator method should return an iterator and not just an Iterable

[11:59] <TuxCM> doesn't work here with or without .iterator

[12:01] <TuxCM> colomon, https://github.com/Tux/CSV test-t.pl + t/10_base.t should show what I want

[12:01] <TuxCM> make test

[12:04] <colomon> ah, yes, that makes more sense now

[12:06] <colomon> though I’m not sure I see the logic of having list and hash options there.  wouldn’t it be easiest / more idiomatic to skip the list interface altogether, and make the hash names correspond to the actual attribute names and then not have the hash interface either?

[12:09] *** kjs_ joined
[12:10] <TuxCM> the iterator doe not work on $csv.error_diag[2]

[12:10] *** andreoss left
[12:11] *** BigBear joined
[12:11] <TuxCM> nor on ($csv.error_diag)[2]

[12:11] *** chenryn joined
[12:12] <TuxCM> it does however on my @ed = $csv.error_diag; is (@ed[2], ...

[12:13] <colomon> TuxCM: right, you’d need does Positional and at_key (or is it at-key now?) for ($csv.error_diag)[2]

[12:14] <moritz> (but please tell me you want to return an object from .error_diag...)

[12:14] <colomon> but again, why would you ever want to do that?  wouldn’t $csv.error_diag.pos be 100% clearer always

[12:14] <colomon> ?

[12:14] <moritz> aye, the positional interface looks funny to me

[12:15] <moritz> like "objects are weird and expensive" in p5 :-)

[12:15] <TuxCM> I want that TOO

[12:15] * moritz listens to Queen: "I want it TOO" 

[12:15] <TuxCM> but I first want to create an interface that would make the transition from Text::CSV_XS as transparent as possible

[12:16] *** chenryn left
[12:16] *** kjs_ left
[12:19] <colomon> ah, compatiability with crappy old interfaces is a valid design concern.  :)

[12:21] <moritz> fwiw, in p5 I might have done the interface similarly

[12:21] *** kjs_ joined
[12:28] *** molaf__ left
[12:35] *** telex left
[12:36] *** telex joined
[12:38] *** rmgk_ joined
[12:38] *** rmgk left
[12:38] *** rmgk_ is now known as rmgk

[12:39] *** Kristien joined
[12:40] <Kristien> I want to make a Perl 6 backend for IPython.

[12:41] *** kjs_ left
[12:45] <ab5tract> Kristien: i've been thinking along those lines as well... have you made any progress hacking on the REPL? i seem to remember you saying that you had a few ideas along those lines

[12:48] <Kristien> No.

[12:48] <Kristien> But REPLs that can show graphics and offer syntax highlighting are very useful.

[12:49] <Kristien> and with re-evaluation and such

[12:50] <arnsholt> IIRC timotimo++ experimented with a Perl 6 IPython kernel a while back

[12:50] <Kristien> I often make errors in REPL sessions, and it's annoying when I cannot undo them

[12:50] *** skids left
[12:50] <Kristien> especially when I plan to archive the REPL session later

[12:53] <timotimo> aye

[12:53] <timotimo> i had trouble finishing it up because we didn't have multithreading at that point

[12:53] <timotimo> and i was a tiny bit reluctant to implement the ipython protocol, as it has some crypto to it

[12:54] <timotimo> https://github.com/timo/iperl6kernel

[12:55] <timotimo> the iperl6kernel.nqp approach to implementing it isn't super nice either

[12:56] <Kristien> cool

[12:58] *** IllvilJa left
[12:59] *** [Sno] left
[12:59] <vendethiel> m: nqp::::get_interp__P()

[12:59] <camelia> rakudo-moar e4883a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ABtDeFkuoe␤Name component may not be null␤at /tmp/ABtDeFkuoe:1␤------> [32mnqp::[33m⏏[31m::get_interp__P()[0m␤»

[12:59] * vendethiel misread

[13:01] <moritz> quad colon is a bit exaggerated, IMHO :-)

[13:01] <timotimo> get_interp? do you perhaps want getcomp?

[13:02] <moritz> iirc in PIR it's getinterp or something like that

[13:03] <timotimo> ah

[13:03] *** rurban_ left
[13:03] <timotimo> but why would you want a pir op on moarvm?

[13:04] * vendethiel was just trying to get a parse :)

[13:05] <timotimo> http://t.h8.lv/p6bench/2015-01-30-six_months_rakudo.html - random benchmark results

[13:05] <timotimo> http://t.h8.lv/p6bench/2015-01-30-six_months_nqp.html - for nqp as well

[13:06] <moritz> while_int2str_concat is funny

[13:07] <moritz> on moar it's faster to do 100k iterations than 50k?

[13:08] *** abraxxa left
[13:09] <timotimo> not guaranteeing my desktop at home is 100% noise-free ...

[13:10] <moritz> it's just.. a logarithmic scale, right?

[13:10] <moritz> and it's a factor 2 faster two do twice as many iterations

[13:10] *** IllvilJa joined
[13:10] <timotimo> i hadn't realized rakudo-moar was this far ahead on many of our microbenchmarks

[13:10] <moritz> and it shows a trend that's also confirmed in the _native

[13:11] <moritz> that doesn't look like random noise to me

[13:11] <moritz> does it start a new process for for each number of iteration?

[13:12] <timotimo> aye

[13:12] <timotimo> and it runs each benchmark 4 times

[13:12] <moritz> then it's not the JIT warming up

[13:13] <timotimo> i suppose some part of the benchmarks begins to dominate the algorithmic complexity at some tipping point?

[13:13] <moritz> oh wait, number of seconds per iteration

[13:13] <moritz> that means it divides by the number of iterations that's on the x axis

[13:13] <moritz> that means if the second 50k iterations are basically free (because the JIT kicks in), that's what we'd see

[13:14] <moritz> all those 2d plots basically measure the startup time of a benchmark vs. the actual run time

[13:14] <moritz> if the startup time is low, you get a flat line

[13:15] <moritz> if it's high, you get a straight line with slope 1

[13:16] <timotimo> we subtract startup time, though

[13:16] <moritz> well, I don't mean the compiler startup time

[13:17] <moritz> rather the one-time overhead of the benchmark code

[13:17] <moritz> if you have   sub bench-for($x) { 1 for ^$x } you have a one-time cost for calling, returning, and creating the range (for example)

[13:17] <moritz> if that dominates the actual benchmark, you get a line with slope close to 1

[13:18] <moritz> like, if the call costs 5ms and the iteration is 1ms, you get 6ms for 1 iteration

[13:18] <moritz> erm

[13:18] <lizmat> commute to Brussels&

[13:18] <moritz> and then 7ms for 2 iterations

[13:19] *** lizmat left
[13:19] <moritz> which whould be 3.5ms for 1 iteration

[13:19] <moritz> ... and slope close to -1

[13:19] <moritz> moritz-- # can't do math anymore

[13:19] <colomon> Is it just me, or did rakudo-moar’s progress in the last six months force the system to add a line or two to the top of most of these graphs?

[13:20] *** kaleem joined
[13:21] *** BigBear left
[13:22] <timotimo> moritz: actually, bench calculates the start-up time for each benchmark separately based on what happens when you pass a workload of 0

[13:25] <moritz> clever

[13:26] <timotimo> that's japhb for you :)

[13:26] <moritz> japhb++

[13:31] *** kjs_ joined
[13:33] *** rurban_ joined
[13:34] *** BigBear joined
[13:43] *** brrt joined
[13:44] *** Kristien left
[13:44] *** kaleem left
[14:03] *** brrt left
[14:04] *** woolfy1 left
[14:09] *** Kristien joined
[14:20] *** Kristien left
[14:26] *** rindolf joined
[14:35] *** tinyblak left
[14:35] *** skids joined
[14:36] *** tinyblak joined
[14:38] <TuxCM> $ perl6 --profile test-x.pl </tmp/hello.csv

[14:38] <TuxCM> 50000

[14:38] <TuxCM> ===SORRY!===

[14:38] <TuxCM> Don't know how to dump a Str

[14:38] <TuxCM> that 50000 is the last line of my script «$sum.say»

[14:39] <TuxCM> is profiling broken?

[14:39] * masak makes a wild guess that some string or something is too large

[14:44] *** raiph joined
[14:45] *** rurban_ left
[14:46] *** rurban_ joined
[14:47] <masak> m: repeat -> $n { say $n } while (^5).roll

[14:47] <camelia> rakudo-moar e4883a: OUTPUT«(Mu)␤1␤1␤3␤4␤»

[14:47] <masak> weird :)

[14:47] * masak is reading S04

[14:48] <masak> m: repeat -> $n { say $n }␤while (^5).roll

[14:48] <camelia> rakudo-moar e4883a: OUTPUT«(Mu)␤1␤3␤3␤3␤2␤3␤4␤1␤2␤1␤1␤3␤2␤4␤1␤»

[14:48] <masak> I was curious whether that worked. it does. because the while/until is required, so the '}\n' can't end the statement just yet.

[14:52] *** rurban joined
[14:58] *** fwilson left
[14:59] <pmichaud> bon après-midi, #perl6

[14:59] * mst waves from brussels

[14:59] <vendethiel> bonjour, pmichaud!

[15:00] * jnthn is also in Brussels by now :)

[15:16] <JimmyZ> \o/

[15:19] *** fhelmberger left
[15:22] *** tinyblak left
[15:23] *** tinyblak joined
[15:26] <TuxCM>  /pro/3gl/CPAN/rakudobrew/bin/perl6: line 2: 27389 Segmentation fault

[15:26] <TuxCM> is that something you want to analyse?

[15:27] *** Mouq joined
[15:27] <colomon> TuxCM: how did you get the segmentation fault?

[15:28] <TuxCM> perl6 -I. t/55_combi.t

[15:28] *** tinyblak left
[15:28] <TuxCM> many tests to FAIL, that is what I am trying to fix

[15:29] <Mouq> TuxCM: Re class Foo { method list { }} not working: That's by design. Iterating with `for` or `map` shouldn't be calling .list on each of its arguments. For this reason, if you want to make sure it's treated like a list, the way to get that is @$foo or $foo.list

[15:29] <Mouq> Same with .hash

[15:30] *** fhelmberger joined
[15:30] <TuxCM> at_pos and at_key are my frieds, right?

[15:31] *** alinbsp joined
[15:31] <Mouq> The same thing happens with, e.g., $0, $<foo>, etc. Trying `for $<foo> { … }` should just run the loop once. Doing `for @<foo> { … }` will do what's intended

[15:31] *** brrt joined
[15:31] <TuxCM> lists are still surprising me

[15:31] <Mouq> TuxCM: I believe those work regardless, yeah

[15:32] <PerlJam> TuxCM: you may have to wait for the GLR before lists are less surprising

[15:32] <TuxCM> «@foo = (1, "foo", 3, Str); for @foo -> $foo {}» ok, but «for (1, "foo", 2, Str) -> $foo {}» is not

[15:33] <Mouq> Even after the GLR, $ => item, @ => list, % => hash :P

[15:33] *** Rounin left
[15:33] <Mouq> m: for (1, "foo", 2, Str) -> $foo { say $foo.perl }

[15:33] <camelia> rakudo-moar e4883a: OUTPUT«1␤"foo"␤2␤Str␤»

[15:34] <Mouq> TuxCM: What's the problem?

[15:34] <TuxCM> m: for (1, "foo", 3.14, Str) -> $fo { .say; }

[15:34] <camelia> rakudo-moar e4883a: OUTPUT«Nil␤Nil␤Nil␤Nil␤»

[15:34] <Mouq> Or are you expecting $foo to be (1, "foo", 2, Str) ?

[15:34] <TuxCM> m: for (1, "foo", 3.14, Str) -> $fo { $fo.say; }

[15:34] <camelia> rakudo-moar e4883a: OUTPUT«1␤foo␤3.14␤(Str)␤»

[15:34] * TuxCM tries again

[15:34] <Mouq> m: for $(1, "foo", 2, Str) -> $foo { say $foo.perl }

[15:34] <camelia> rakudo-moar e4883a: OUTPUT«$(1, "foo", 2, Str)␤»

[15:35] <Mouq> m: for [1, "foo", 2, Str] -> $foo { say $foo.perl }

[15:35] <camelia> rakudo-moar e4883a: OUTPUT«[1, "foo", 2, Str]␤»

[15:36] <TuxCM> must have been another error (too) that blurred my view

[15:38] *** tinyblak joined
[15:39] *** tinyblak_ joined
[15:41] *** Alina-malina left
[15:42] <TuxCM> ok (my @ret = $csv.fields, "fields"); <= that surprised me. "fields" was pushed to @ret too

[15:42] *** tinyblak left
[15:43] <pmichaud> TuxCM: what would you have expected there?

[15:43] *** Alina-malina joined
[15:43] *** fhelmberger left
[15:43] <TuxCM> ok ((my @ret = $csv.fields), "fields");

[15:44] <pmichaud> so, list assignment shouldn't take a list on the rhs?  ;-)

[15:44] <El_Che> if someone is still looking for a room for @fosdem:  Olivier Mengué @omengue  ·  14m 14 minutes ago

[15:44] <El_Che> .@FOSDEM I still have a bed available for saturday in my twin-beds room at Hotel Beau Site. Your price: 34 €, including breakfast.

[15:45] <TuxCM> it should :)  but it still surprised me. .fields is now a list of objects, and  "fields" caused the next line to barf on an attempted object call

[15:45] <PerlJam> TuxCM: that's less of a listy problem and more of a P6 v. P5 problem  (i.e. you're still thinking in P5)

[15:45] * TuxCM is *fighting* to separate those :)

[15:46] <gtodd> nine: did you do your talk about Inline::Perl5 yet?

[15:48] <gtodd> I meant did you finish the slides ;-)

[15:50] *** darthg0d joined
[15:51] *** kaleem joined
[15:52] <Woodi_> hallo #perl6 :)

[15:53] <Woodi_> I think discussions about finalizations needs some decompozition... or maybe I just misunderstand something

[15:54] *** andreoss joined
[15:54] <gtodd> nine: can't recall if it was you or PLICEASE  (author of numerous perl5 FFI modules) that mentioned there was an ongoing effort to standardize/document the description of functions available in foreign libs in an an "easy to digest" "X-Platform and/or X-Language" way (in JSON or YAML errm maybe not XML!)  so that someone writing an FFI back module to work with errm libopencv.so would create a JSON file that could be used

[15:56] <gtodd> nine: oh ... errm it *was* G. Ollis https://metacpan.org/pod/FFI::Platypus#DESCRIPTION  

[15:56] <Woodi_> first programmer want to declare .disconnect be called when $dbConnection is last seen. and he realy do not care about memory at the moment. but in discussions this nice to have "domain" feature is forgotten and slips into gc don't wanting to make a run...

[15:58] <gtodd> nine:  "a goal of [ FFI::Platypus ] is to reduce common interface specifications to a common format like JSON that could be shared between different languages."

[15:58] *** jluis joined
[15:58] *** brrt left
[15:59] <PerlJam> Woodi_: what do you mean by "when $dbConnection is last seen"?   When it goes out of scope?

[16:00] <Woodi_> but actually finalization is perfect hint for gc - that object do not need to be dragged by all generations... just quick call to $gc->flag($dbconnection, READY_TO_FREE) and $dbc do not need to be looked for while traversing...

[16:00] *** araujo joined
[16:00] *** araujo left
[16:00] *** araujo joined
[16:00] <Woodi_> PerlJam: depends on finalization implementation... scope is nice

[16:00] *** darthg0d left
[16:01] <Woodi_> or gc prefer to personally find all objects to be freed ? :)

[16:01] *** dayangkun joined
[16:02] *** gfldex joined
[16:03] <jnthn> Woodi_: You're conflating memory management and resource management I think, when in Perl 6 - any *many* other languages - those two have been taken apart.

[16:05] <Woodi_> jnthn: I get impression that all finalization discusions I ever seen do that...

[16:06] <moritz> that doesn't quite make it better

[16:06] <Woodi_> and $gc-> flag is just "marker", not "GC do free NOW!"

[16:07] <Woodi_> domain objects like handles want actions to be done, for consistency.

[16:09] *** lizmat joined
[16:09] * lizmat has arrived in Brussels

[16:10] *** dagurval_ left
[16:10] <jnthn> lizmat: Welcome :)

[16:12] <Woodi_> and that flag (memory menagement) is for free, just happens to be consequence of freeing resources.

[16:16] <Woodi_> as for cars with auto gear changing :) : new cars with auto feature tends to introduce some manual settings like sportmode or ecomode :) and computer in car do not see that corner is comming (yet)... some nice description of stick using feature :)  http://www.motivemag.com/pub/feature/drivers_ed/Driver_s_Ed_The_Scandinavian_Flick.shtml

[16:19] *** nige joined
[16:20] <FROGGS> jnthn / pmichaud / lizmat: breakfast will start at 7 if you want (not at 8am as described)

[16:20] <nige> can't make FOSDEM - but just wanted to wish everyone well in spreading the "Joy of Six"  go for it! ;-)

[16:20] <yoleaux> 20 Dec 2014 08:56Z <moritz> nige: I've published your advent post (scheduled for tomorrow, 21st) today already, because today's post isn't written yet

[16:21] <nige> thanks moritz++

[16:22] <FROGGS> nige: you have to pop in more often :o)

[16:22] <lizmat> FROGGS jnthn pmichaud : already arranged for breakfast at 7:15

[16:23] <jnthn> 7:15???!!

[16:23] *** woolfy joined
[16:23] <FROGGS> jnthn: only if you want to be at the fosdem at 8am, to prepare the booth and stuff

[16:24] <FROGGS> so, since I wanna help, I will break fast and early

[16:24] *** mr-foobar joined
[16:25] *** rindolf left
[16:25] <nige> yes - Froggs - kids, work and building a new start up - make it tricky

[16:25] <nige> am a keen follower of the weblogs however 

[16:26] <nige> - speaking of start ups I've got a cool idea for a Perl6 app to aid adoption

[16:26] <FROGGS> do tell

[16:26] <nige> :-)

[16:27] <nige> can't go into too much detail ;-) ... but it will need a Mojo style engine

[16:27] <nige> or some web app engine

[16:27] <FROGGS> we've got Template::Mojo and Bailador

[16:28] <nige> yes - will look again at these

[16:29] <nige> have been enjoying using Mojolicious in Perl5 - and would defn use a Perl6 version

[16:29] *** andreoss left
[16:29] <FROGGS> both need better docs (or docs at all), but they work

[16:29] <nige> cool - that's good to know

[16:30] <FROGGS> could be faster of course, but I think it is usable

[16:32] <El_Che> that's great news

[16:33] *** mvuets left
[16:34] <FROGGS> the testers.perl6.org uses it (both Template::Mojo and Bailador), and it is only slow for the reason that it fetches thousands of rows out of its database every time 

[16:36] <dalek> perl6-roast-data: b37fb34 | coke++ | / (5 files):

[16:36] <dalek> perl6-roast-data: today (automated commit)

[16:36] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b37fb3483e

[16:37] *** kaleem left
[16:38] <woolfy> El_Che: lizmat and I arrived in our hotel, good parking place for the truck, checked my mail (now 59 people for dinner on Saturday, 31 for Sunday), and on my way to Delirium for some drinks.  lizmat is not joining me, she will hack with Perl6-ers (ah well, Perl 6, lovely)

[16:39] <El_Che> woolfy++

[16:39] *** alinbsp left
[16:39] <El_Che> woolfy: is 70 a max, or does the resto accept an overflow?

[16:39] <El_Che> hackers overflow

[16:40] <woolfy> 70 is the max for Saturday, 50 for Sunday

[16:40] <El_Che> so, not a lot space left

[16:40] <woolfy> El_Che: No overflow allowed or possible, 70 is just the max

[16:40] <El_Che> maybe keep an small % open for people that say they come but bail?

[16:41] <woolfy> El_Che: already 2 people bailing out for Saturday, and their seats were taken the same 15 minutes

[16:42] <El_Che> those are the *nice* people telling you they bail out

[16:42] <El_Che> anyway, 59 is pretty greay

[16:42] <El_Che> great

[16:42] <woolfy> indeed

[16:42] <woolfy> Now I am going to Delirium

[16:42] <woolfy> Byebye

[16:43] <El_Che> 100% chance of filling the 70 places

[16:43] <El_Che> ok bye

[16:43] *** woolfy left
[16:43] <jnthn> Wow, so dinner!

[16:43] *** dayangkun left
[16:43] *** sjn left
[16:43] <El_Che> jnthn: are you better?

[16:46] <nwc10> so dinner, many conversation, nom

[16:46] <jnthn> El_Che: Largely. Still not at 100% strength, but nothing to worry about wrt my talk (except I've some of the slides still to write...doing that now ;))

[16:47] <El_Che> jnthn++

[16:47] *** pecastro left
[16:51] <vendethiel> xfix: doing some coffeescript :)?

[16:54] *** Mouq left
[16:55] *** adu joined
[16:56] <FROGGS> and again I wonder how well my talk fits in 50 minutes :/

[16:57] <pmichaud> I figure if my talk gets to 50 minutes, I'll just stop.  :)

[16:57] <FROGGS> :P

[16:57] <vendethiel> "and now, for the interesting part... Oh wait, it's been 50 minutes. have a nice day!"

[16:57] <pmichaud> vendethiel: Exactly.

[16:57] <vendethiel> *g*

[16:57] <FROGGS> my problem is that when I am nervous I start to talk faster... I mean, I did the v5 talk in 11min instead of 20 :o(

[16:57] <pmichaud> followed by:  "Be sure to come see my next talk ."

[16:59] <jnthn> FROGGS: You could do a practice run...

[16:59] <FROGGS> so, if one wants to support me and I finish early, then please ask simple but enlighting questions :o)

[16:59] <FROGGS> jnthn: will do that

[17:00] <jnthn> FROGGS: And put a horror movie on while you practice so you're nervous, or something, to make it realistic... :P

[17:00] <FROGGS> jnthn: so if you hear mumbling at night, it is your own fault :P

[17:00] <pmichaud> I watched r0ml (Robert Lefkowitz, fantastic speaker) do something similar with some of his talks.  He would start out his talk noting that before he could talk about what he had written for the schedule, he needed to first cover the material that he ran out of time for in his previous talk.  So he would do that, then upon getting to the end of his alloted time he'd say "Oh, sorry, I didn't get to what I was supposed to talk about today.  You'll just have

[17:00] <FROGGS> hehe

[17:00] <jnthn> FROGGS: Hmm, I know enough about nativecall to ask some questions... :)

[17:00] <FROGGS> jnthn++

[17:01] <FROGGS> pmichaud: limits all the way down :o)

[17:02] <El_Che> well, if someone wants me to give a subtle sign to slow down, please tell me so

[17:02] <El_Che> anyway, after the time is up, I'll remove you from the stage manu militari :)

[17:02] <pmichaud> How about a not so subtle sign?  ;-)

[17:04] <FROGGS> weird images are now popping up in my head 

[17:04] *** xinming left
[17:04] <pmichaud> For once I don't expect to be using my entire time allotment.  That rarely happens for me.  :)

[17:05] <jnthn> pmichaud: I'll believe that when I see it :D

[17:06] * jnthn has never been to a Pm talk that ran short of stuff :)

[17:06] <pmichaud> I actually had several presentations last year that went exactly on time, or 10 minutes under.

[17:06] <pmichaud> which, considering they were 3-hour presentations, I thought was pretty good.  :)

[17:07] <pmichaud> also, I'm the talk that is right at the lunch hour, so I figure I should err on the side of running short rather than long :)

[17:08] *** zakharyas left
[17:15] *** kjs_ left
[17:16] *** rurban left
[17:16] *** vendethiel left
[17:23] *** rurban joined
[17:24] *** sqirrel joined
[17:25] *** rurban left
[17:26] *** konsolebox joined
[17:27] <FROGGS> .tell fil_ soon meant 7 hours later :o) (I had no idea when I would get around to it, and what it would involve... happily it is just about setting a flag to true)

[17:27] <yoleaux> FROGGS: I'll pass your message to fil_.

[17:30] *** Kristien joined
[17:31] <Kristien> hi

[17:32] *** Otterpocket left
[17:33] <FROGGS> hi Kristien 

[17:36] *** silug left
[17:40] <japhb> .botsnack

[17:40] <yoleaux> 11:50Z <timotimo> japhb: i'd like to have an integrated tool for perl6-bench that can build a version of a compiler and the version before it, or alternatively you could pass a little patchset and it'd build the things with and without the patchset, time all things and immediately spit out a comparison graph file that might even contain the diff

[17:40] <yoleaux> :D

[17:42] <japhb> .tell timotimo That sounds eminently doable and a very good idea.  GitHub Issue it and I'll try to get to it next time I'm not slammed by $day-job?

[17:42] <yoleaux> japhb: I'll pass your message to timotimo.

[17:45] <pyrimidine> Re: DESTROY, was the main issue re: conflating it vs. use of DESTROY in p5?

[17:45] <dalek> doc: 3b4a118 | paultcochrane++ | lib/Type/Blob.pod:

[17:45] <dalek> doc: Use consistent capitalisation in template letter table

[17:45] <dalek> doc: review: https://github.com/perl6/doc/commit/3b4a11859c

[17:45] <dalek> doc: 760cd53 | paultcochrane++ | lib/Type/Blob.pod:

[17:45] <dalek> doc: Minor sentence flow improvements in update() docs

[17:45] <dalek> doc: review: https://github.com/perl6/doc/commit/760cd53d36

[17:45] <pyrimidine> e.g. needing to rename it?

[17:45] *** xinming joined
[17:46] <moritz> \o/ more doc contributions

[17:47] <jnthn> \o/

[17:47] <jnthn> .oO( Ship more patches to the doc dock! )

[17:48] <[ptc]> moritz: is htmlify working for you with current rakudo (moarvm) HEAD?

[17:49] <moritz> [ptc]: dunno, I'll give it a try

[17:49] *** nige left
[17:49] *** slavik left
[17:50] <[ptc]> moritz: thanks.  It doesn't run for me atm, and I'm just wondering if I have a case of PEBCAK

[17:50] <moritz> [ptc]: the cron job that rebuilds doc.perl6.org runs moarvm 2014.01.1

[17:50] <moritz> ... but it's good to catch any errors in the tool chain early

[17:51] * [ptc] nods

[17:51] <pyrimidine> nm Re: DESTROY, just caught this in backlog # moritz++ for IRC logs 

[17:53] <moritz> fwiw I only use htmlify.p6 with rakudo-m; I'm fine with it using r-m specific features

[17:54] <[ptc]> ah ok.  Nice to know :-)

[17:54] *** rurban_ left
[17:54] <[ptc]> I've written something to document pack(), however have just realised that Blob.pod could be the wrong place

[17:54] <[ptc]> maybe in Buf.pod?

[17:55] <[ptc]> since the sub is defined in Buf.pm?

[17:55] <moritz> [ptc]: no, Blob.pod is correct

[17:55] <moritz> [ptc]: that's a historical accident

[17:55] <[ptc]> ok.

[17:55] *** silug joined
[17:55] <moritz> (we used to have only Buf, not Blob)

[17:55] <[ptc]> ah, was just about to ask why

[17:56] <dalek> doc: e4a91e7 | moritz++ | README.md:

[17:56] <dalek> doc: README: adjust vision statement

[17:56] <dalek> doc: 

[17:56] <dalek> doc: explicitly include language features, not just built-in types and routines

[17:56] <dalek> doc: review: https://github.com/perl6/doc/commit/e4a91e7956

[17:57] <moritz> now running htmlify...

[17:57] <moritz> [ptc]: does it hang for you?

[17:57] <dalek> doc/add_pack_doc: a208c53 | paultcochrane++ | lib/Type/Blob.pod:

[17:57] <dalek> doc/add_pack_doc: Document the pack() sub

[17:57] <dalek> doc/add_pack_doc: review: https://github.com/perl6/doc/commit/a208c5312a

[17:57] <pyrimidine> So, if the main need for DESTROY is to run garbage collection, why not use a name like TRASH?

[17:57] <[ptc]> moritz: I had it hanging (at Regexp)

[17:57] <muraiki> I prefer ANNIHILATE

[17:57] <moritz> [ptc]: yes, I have that too

[17:58] <[ptc]> then I thought I had a problem with my rakudo, so I rebuilt it (make realclean; perl Configure....; make install)

[17:58] <moritz> [ptc]: and I recently patched regexes.pod, that might be why

[17:59] *** Kristien left
[17:59] <[ptc]> and then I get this: Missing or wrong version of dependency 'src/gen/m-CORE.setting'

[17:59] <jnthn> pyrimidine: The point isn't the run GC; the point is it's a callback if GC detects that all references to the object are now gone and, were it not in the list of things with a DESTROY method, it'd have been freed already

[17:59] <jnthn> *to run

[17:59] <[ptc]> moritz: now, I'm running the full rakudo test suite (just in case), and it runs again (gah!)

[18:00] <[ptc]> moritz: however, still hangs on regexp.pod

[18:00] <FROGGS> [ptc]: that means you have to rebootstrap panda: "Missing or wrong version of dependency 'src/gen/m-CORE.setting'"

[18:00] <[ptc]> FROGGS: ah, that'll be it :-)  Thanks!

[18:01] *** Mouq joined
[18:01] <[Coke]>  m: my $foo = qw‘bar’;

[18:01] <camelia> rakudo-moar e4883a: ( no output )

[18:01] * FROGGS .oO( caches, you can't live with and without them )

[18:01] <[ptc]> I'd tried to run perl6-debug-m, however Debugger::UI::CommandLine was missing, hence I rebootstrapped panda...

[18:01] <[ptc]> he

[18:02] <Mouq> [ptc]: Just note, if you haven't run it before, that htmlify currently takes a really long time to run. O(minutes)

[18:03] <[ptc]> Mouq: yeah, I know.  I guess that's why people want to parallelise it

[18:03] *** slavik joined
[18:04] <[ptc]> however atm it's hanging on regexes.pod and just burning cpu

[18:04] <moritz> but that won't help with a genuine hang :-)

[18:04] <moritz> [ptc]: Debugger::UI::CommandLine is a user-space module and must be installed with panda

[18:04] <moritz> ok, rakudo itself hangs when presented with regexes.pod

[18:04] <moritz> so, rakudobug

[18:04] *** madcapJake left
[18:05] *** pyrimidine left
[18:05] *** madcapJake joined
[18:05] *** pyrimidine joined
[18:06] <pyrimidine> jnthn: ok, makes sense. I'm so used to having an explicit cleanup step with some classes.  

[18:06] <[ptc]> moritz: just a quick heads up: I added the pack docs in the "add_pack_doc" branch.  Could you let me know if it looks up to standard?  TIA!

[18:06] *** espadrine left
[18:07] *** ivan`` left
[18:07] <moritz> [ptc]: looks good

[18:07] <[Coke]>  m: my $foo = ‘bar’;

[18:07] <camelia> rakudo-moar e4883a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/rigR999ZRG␤Malformed initializer␤at /tmp/rigR999ZRG:1␤------> [32mmy $foo = [33m⏏[31m‘bar’;[0m␤    expecting any of:␤        prefix or term␤        prefix or meta-prefix␤»

[18:08] <[ptc]> moritz: thanks :-)

[18:08] <moritz> [ptc]: though I don't think the 1:1 correspondence to unpack is quite correct

[18:08] <moritz> but better to have it in that form that not at all

[18:08] <dalek> doc: a208c53 | paultcochrane++ | lib/Type/Blob.pod:

[18:08] <dalek> doc: Document the pack() sub

[18:08] <dalek> doc: review: https://github.com/perl6/doc/commit/a208c5312a

[18:08] <dalek> doc: 400bdf2 | paultcochrane++ | README.md:

[18:08] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[18:08] <dalek> doc: review: https://github.com/perl6/doc/commit/400bdf2e93

[18:08] *** Maddingue left
[18:08] *** djanatyn left
[18:08] *** epochbel1 left
[18:08] *** Maddingue joined
[18:09] *** btyler left
[18:09] *** retupmoc1 left
[18:09] *** ingy left
[18:09] *** Bucciarati left
[18:09] *** revdiablo left
[18:09] *** mathw left
[18:09] *** masak left
[18:09] *** dylanwh left
[18:09] *** cxreg left
[18:09] *** rjbs left
[18:09] *** awwaiid left
[18:09] *** epochbell joined
[18:09] <moritz> ok, 09867b7eb092d6eabfd305df931a35b548fa1b30 in perl6/doc causes rakudo to hang on regexes.pod

[18:09] *** retupmoca joined
[18:09] *** mathw joined
[18:09] *** pmichaud left
[18:09] *** revdiablo joined
[18:09] *** btyler joined
[18:09] *** masak joined
[18:10] *** awwaiid joined
[18:10] *** cxreg joined
[18:10] *** rjbs joined
[18:10] *** masak is now known as Guest27290

[18:10] *** pmichaud joined
[18:10] <dalek> doc: 08b2628 | moritz++ | lib/Language/regexes.pod:

[18:10] <dalek> doc: Revert "Regexes: document :overlap and :exhaustive"

[18:10] <dalek> doc: 

[18:10] <dalek> doc: This reverts commit 09867b7eb092d6eabfd305df931a35b548fa1b30.

[18:10] <dalek> doc: 

[18:10] <dalek> doc: It causes rakudo to hang on regexes.pod. TODO: reduce to minimal

[18:10] <dalek> doc: example, file rakudo bug, restore the commit once fixed (or work around it)

[18:10] <dalek> doc: review: https://github.com/perl6/doc/commit/08b2628e70

[18:12] <[ptc]> moritz: thanks for the help, I appreciate it.  In time I should be able to do more stuff with less supervision (I hope!)

[18:12] <Mouq> moritz: It still shouldn't hang, but what you reverted has an "=begin code" with no "=end code"

[18:12] <Mouq> I'm pretty sure that normally errors out..

[18:12] <Mouq> m: =begin code

[18:12] <camelia> rakudo-moar e4883a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/8s40WVOB7i␤Preceding context expects a term, but found infix = instead␤at /tmp/8s40WVOB7i:1␤------> [32m=begin [33m⏏[31mcode[0m␤»

[18:12] *** konsolebox left
[18:12] <Mouq> m: ␤=begin code␤

[18:13] <camelia> rakudo-moar e4883a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/n1bOuTfuYy␤'=begin' not terminated by matching '=end code'␤at /tmp/n1bOuTfuYy:2␤------> [32m<BOL>[33m⏏[31m<EOL>[0m␤»

[18:13] <moritz> [ptc]: fwiw I'm fine with you (or anybody else) pushing to master directly and asking for review later

[18:13] *** BigBear left
[18:13] <FROGGS> jnthn: btw, would be nice if we could have 'has MyFooEnum $.foo' in CStructs... should be fairly doable I think

[18:13] <moritz> [ptc]: in general, bad docs are better than no docs. And forgiveness > permission

[18:14] <pyrimidine> jnthn: re: DESTROY, I recall someone (Peter_R maybe) who brought this up in the past (some explicit way of defining cleanup upon GC).  May have to backlog to see if anything came about from that

[18:14] <moritz> Mouq: sounds like a very probable hypthesis

[18:14] *** Bucciarati joined
[18:16] <pyrimidine> moritz: re: pod and code documentation, would you suggest keeping it separate from code for now? e.g. separate .pod file?

[18:17] <moritz> pyrimidine: I don't have a recommendation for you

[18:17] <moritz> the reasons for keeping them separate for core stuff don't apply to user-space modules

[18:19] <PerlJam> pyrimidine: I'd keep them together were I you.

[18:19] <pyrimidine> moritz: np. just checking whether it makes much of a difference; would rather keep ...

[18:19] *** ivan`` joined
[18:19] <pyrimidine> what PerlJam++ said

[18:20] *** djanatyn joined
[18:20] *** sqirrel left
[18:21] *** dylanwh joined
[18:21] *** ingy joined
[18:22] <Mouq> pyrimidine: And you can also attach documentation to the things you're documenting in your code ( hoelzro++ ). We don't have much functionality to expose this into generated documentation, but I'm sure that'll be a thing eventually

[18:23] <moritz> Mouq: it might be not a "genuine" hang, but a very, very slow backtracking to death

[18:23] <Mouq> m: #| my sub rocks␤sub foo ( $a, #= This parameter does stuff␤ $b, #= So does this one␤){ 42 }␤say &foo.WHY

[18:23] <camelia> rakudo-moar e4883a: OUTPUT«my sub rocks␤This parameter does stuff␤»

[18:26] <pyrimidine> Mouq: will have to check into that, thx!

[18:26] <Mouq> moritz: Oh, hm.. is it allowed to backtrack like that?

[18:26] <Mouq> Oh

[18:26] <Mouq>           || '=end' \h+ 'code' [ <pod_newline> | $ ]           || <pod_string>**0..1 <pod_newline>              <delimited_code_content($spaces)>

[18:27] *** Kristien joined
[18:27] <Mouq> The formatting's weird, but that means that the thing that parses the code content builds up a giant callstack

[18:27] <Mouq> Which then has to get unwound

[18:27] <Mouq> Or, not unwound, but failed over

[18:28] <moritz> my current plan is to eat dinner, and then submit a bug report

[18:29] <PerlJam> food++

[18:29] <PerlJam> happy noms moritz!  :)

[18:29] <Mouq> moritz: Sounds good

[18:31] * Mouq tests a fix

[18:33] *** Guest27290 is now known as masak_grr

[18:35] *** telex left
[18:36] *** telex joined
[18:39] *** abraxxa joined
[18:40] *** sqirrel joined
[18:48] * FROGGS goes down to the lobby to meet other lobsters

[18:48] <PerlJam> Was there a desire to move from RT to github issues?  I seem to recall a general lean in that direction.  Anyway,  I just saw http://www.dagolden.com/index.php/2397/moving-cpan-rt-tickets-to-github-now-improved/  which has some nice helpful software if that's desired.

[18:49] *** FROGGS[mobile] joined
[18:50] <pmichaud> I was pushing for a move from RT to github in 2013.

[18:50] <pmichaud> Since I've been less active, I've been less pushy, though.  :)

[18:51] <pmichaud> I know that when I went to work on bugs in 2013, I felt like the RT interface was an impediment

[18:52] <pmichaud> masak++ was the chief proponent of keeping the existing rt bugset, if only because he had tools and mental reference points built up over a period of time that enabled him to be an effective historian

[18:52] <pmichaud> at yapc::na 2013 we left it as an agreement that I'd investigate the difficulty of migration and we'd revisit again

[18:53] <nwc10> pmichaud: is there a plan for handling security tickets? ie CVE-level pain?

[18:53] <pmichaud> plan?!

[18:54] <PerlJam> pmichaud; Is your attendance at fosdem symbolic of your return to activity?  :)

[18:54] <hoelzro> (GitHub tickets)++

[18:54] <nwc10> ie stuff that should be private until fixed

[18:54] <avuserow> colomon, raydiak: I'm gradually working on converting an old Perl5 project to Perl6, which was a network jukebox, hence many of my libraries being audio-related.

[18:54] <pmichaud> nwc10: I'm not aware of a plan as yet, no.  We can develop one.

[18:54] <nwc10> pmichaud: "plan", as in, "I love it when a ... comes together" :-)

[18:54] <avuserow> Also it's a good way for me to try things out, see what's missing or broken

[18:54] <pmichaud> PerlJam: my attendance at FOSDEM is best interpreted as a strong intent to return to activity.  :)

[18:55] <pmichaud> I'm still robotic-competition-bound through Feb 14, at least.

[18:55] <pyrimidine> pmichaud: I've look at RT -> Github migration for our project, but we have a handful of RT tickets.  I could see migrating perl6 tickets being a bit more... painful

[18:55] <nwc10> pmichaud: in that, I think to make a private issue queue on github, @you would need to pay them.

[18:55] <pmichaud> (two robotics teams at their respective regional championships)

[18:55] <pmichaud> nwc10: I have no problem with paying github.

[18:56] <moritz> nwc10: if this is their consumer prices (and not their enterprise offers), I'm sure we'll find a solution.

[18:56] <nwc10> pmichaud: I also have no problem with github getting money. But it's an open-ended requirement to keep paying them (a small amount of money)

[18:56] <pyrimidine> nwc10: GitHub is pretty nice about requests from open-source projects.  Doesn't hurt to ask

[18:56] <nwc10> whereas on perl.org RT, private queues are just as free (or costly) as public queues

[18:56] <PerlJam> what pyrimidine said

[18:57] <pmichaud> at any rate, I'd rather choose based on capability than (likely low) expense.

[18:58] <pmichaud> pyrimidine: I agree that migrating perl6 tickets may end up being painful.  But I'm guessing it's same O(pain) as it was for me to use RT to try to categorize and resolve them.

[18:58] <nwc10> I think that's a sane rational.

[18:58] <pyrimidine> pmichaud, nwc10: note they are *very* helpful about open science: https://github.com/blog/1840-improving-github-for-science

[18:58] <nwc10> having dealt with (I think) two CVEs, I'm just mindful that the project needs to be ready for them.

[18:59] *** espadrine joined
[18:59] <nwc10> sorry, having done the work and release @pain for at least one.

[18:59] <pyrimidine> pmichaud: the link that PerlJam posted from dagolden: seems like it would tremendously for this

[18:59] <pmichaud> time for dinner for me -- bbl

[18:59] <nwc10> I tend to block it out. It's not fun

[18:59] <nwc10> hence why I can't remember if was one, or two

[18:59] <pyrimidine> * would be tremendously useful

[18:59] <jnthn> eek, yes, dinner!

[18:59] <jnthn> &

[19:05] <dalek> rakudo/nom: 99021cf | Mouq++ | src/Perl6/ (2 files):

[19:05] <dalek> rakudo/nom: [Pod] Eliminate recursion in delimited_code_content

[19:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99021cf974

[19:05] <dalek> rakudo/nom: 7fd2f64 | Mouq++ | src/core/Cursor.pm:

[19:05] <dalek> rakudo/nom: Merge branch 'nom' of http://github.com/rakudo/rakudo into nom

[19:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7fd2f64ab5

[19:08] <moritz> Mouq: part of the problem seems to be that the code doesn't stop looking when reaching EOF

[19:08] <moritz> Mouq: and instead backtracks

[19:08] *** FROGGS[mobile] left
[19:08] <Mouq> moritz: The above patch fixes it for me

[19:09] <moritz> Mouq: could you please run https://gist.github.com/moritz/8ceacf454fb1f5af9461 ?

[19:09] <moritz> it nicely illustrates the timing :-)

[19:10] <Mouq> moritz: Awesome! And even awesomer: https://gist.github.com/Mouq/e1a1aba877724259d5ce

[19:11] <moritz> Mouq++ indeed

[19:11] * moritz doesn't even have to write up his bug report

[19:13] <raydiak> g'mornin #perl6

[19:13] <masak_grr> good antipode, raydiak 

[19:13] *** masak_grr is now known as masak

[19:14] *** sqirrel left
[19:14] <raydiak> \o masak...thanks for enduring the darkness for a while every day so that I can have a turn with the sun :)

[19:15] <masak> you're welcome.

[19:15] <hoelzro> on a side note, I've been learning Octave for a machine learning course on Coursera, and I'm pleased to see that many powerful features from Octave are also present in Perl 6 =)

[19:15] <hoelzro> o/ raydiak 

[19:15] <raydiak> heya hoelzro 

[19:15] <moritz> where octave implements mostly the same language as matlab

[19:16] <hoelzro> mhmm

[19:16] <hoelzro> interestingly enough, I remember *hating* Matlab in college

[19:17] <hoelzro> I think I had to stop worrying and learn to love the matrix

[19:17] <dalek> doc: c2be389 | moritz++ | lib/Language/regexes.pod:

[19:17] <dalek> doc: Revert "Revert "Regexes: document :overlap and :exhaustive""

[19:17] <dalek> doc: 

[19:17] <dalek> doc: This reverts commit 08b2628e7023c02710f1ac9daef556f6e7b36f1f,

[19:17] <dalek> doc: and thus re-instates commit 09867b7eb092d6eabfd305df931a35b548fa1b30,

[19:17] <dalek> doc: while also fixing broken pod. Mouq++ and [ptc]++ for reporting

[19:17] <dalek> doc: and diagnosing/fixing

[19:17] <dalek> doc: review: https://github.com/perl6/doc/commit/c2be3891de

[19:17] <moritz> what I really don't like about matlab/octave is that the compiler don't catch undeclared names at compile time

[19:17] <moritz> that's really disappoing when you're used to Perl 6 :-)

[19:18] <masak> yes, that's the thing. when you know it *can* be done, anything short of it just feels a bit... cheap.

[19:18] <hoelzro> heh

[19:25] <moritz> aye

[19:27] *** kjs_ joined
[19:27] <gtodd> maybe something like Inline::Matlab could help ;-)

[19:28] <moritz> to be fair, if you use matlab with the IDE, you get some nearly-real time linting

[19:29] <gtodd> perl5 is to duct tape as perl6 is to ....

[19:31] <moritz> duct concrete?

[19:31] <nwc10> several rolls of duct tape at the same time, with O(1) emojii.

[19:31] <nwc10> oh, wait, no, that makes no sense :-)

[19:32] <[Coke]> Having lived through a migration process: I would vote against migrating unless the benefits of the new system are INCREDIBLY compeling.

[19:32] <gtodd> flame resistant waterproof double-sided nanotech enhanced super glue coated duct tape with teflon coating and kevlar fibre reinforcement

[19:33] <masak> the O(1) emoji depicts a cyclops devouring a ruler?

[19:35] <gtodd> lol

[19:35] <gtodd> while lying down

[19:35] *** abraxxa left
[19:36] * gtodd can't wait to see/hear nine's Inline::P5 talk 

[19:36] *** colomon left
[19:37] <nwc10> yes, exactly - they're adding it in Unicode א.0 :-)

[19:37] <nwc10> (and I discover that as I typed that it, I'll be confusing Left to Right or Right to Left)

[19:41] <jdv79> i guess they'll announce the streaming urls "later"?

[19:41] *** Mouq left
[19:42] <gtodd> some talks will end up on youtube ... liz will probably post links in p6weekly ;-)

[19:43] <gtodd> aka lizmat 

[19:44] <jdv79> i thought they were going to try to stream

[19:44] <gtodd> oh probably that too

[19:45] <masak> tell them that the stream is only good if they tell us in advance :P

[19:46] <gtodd> there's  ... time travel 

[19:46] <jdv79> i guess i'll only know after i wake up at 3am EST...

[19:46] *** colomon joined
[19:47] *** espadrine left
[19:50] <colomon> avuserow++

[20:00] *** raiph left
[20:00] *** raiph joined
[20:09] <raydiak> do we have weak references?

[20:09] <masak> not to my knowledge.

[20:10] <masak> I've heard the need for them called a "design smell" on this channel.

[20:10] *** spider-mario joined
[20:10] <TimToady> well, something like that can be useful for caching, I suppose

[20:11] <TimToady> but it would take the connivance of the GC to manage it

[20:12] <raydiak> blast....and END phaser would solve my DESTROY problem, but if I can't keep a list of the objects without interefing with GC, that seems counterproductive

[20:12] <masak> right. it's not pure user space.

[20:13] *** kjs_ left
[20:15] <raydiak> fwiw I don't really have a problem any more, I'm just kinda wondering about the corner I stumbled in to...what does a person do if they want something like DESTROY but reliably always called?

[20:16] *** darutoko left
[20:17] <raydiak> but yeah I guess mostly what I've heard is design smell and YAGNI

[20:21] *** retupmoca left
[20:26] <moritz> raydiak: for me, the question is really: what kind of cleanup would DESTROY do that can't be done by the OS cleaning up after the process?

[20:29] *** raiph left
[20:29] <geekosaur> I can imagine e.g. a database client implementation (think berkeleydb, not postgres) that write-behind buffers some things, and needs to flush the buffer

[20:29] <moritz> if there are good examples of such cases, it would be much easier to make a good point for global destruction

[20:29] *** raiph joined
[20:29] <moritz> geekosaur: well, but that has to be able to deal with the not-flushed case anyway, in case of power loss or a kill -9

[20:29] <geekosaur> also, releasing resources when the application requires some ordering on it

[20:29] <PerlJam> geekosaur: that sounds more like the timing of the destruction is what's really important

[20:30] <geekosaur> moritz: that does not mean (a) that the normal exit should be just like a panic abort, (b) that the user should have to explicitly manage state (what is this, C?)

[20:31] <bartolin> moritz: a few days ago you made ObjAt.new(str) work (and thereby fixed RT #122094). I wonder where to place a test for that -- do you think it would make sense to add a new test file S02-types/built-in.t?

[20:31] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122094

[20:33] *** retupmoca joined
[20:37] <raydiak> I find it odd that I am the only one who finds it odd that we give people a plethora of ways to say most things, even the stuff you really *shouldn't* be doing, but I want to say something which seems like a fairly natural way to think, but most answers are just "we don't let you say that"

[20:38] <raydiak> I guess I think a better question is why *shouldn't* we have a few decent options for doing this?

[20:38] <PerlJam> If we had a phaser that fired just before an object was about to go out of scope (let's call it CLEANUP), would that satisfy people's need for "destruction'?

[20:39] <masak> PerlJam: go out of lexical scope?

[20:39] <PerlJam> aye

[20:39] <masak> PerlJam: because that's LEAVE.

[20:39] <raydiak> but I can't, from my own module, install a LEAVE in whatever is *using* my module, afaik

[20:40] <masak> and I think moritz raised a good point earlier: given that the GC is what it is, and given whe have LEAVE and `will leave`... are there any good uses left for DESTROY?

[20:40] <raydiak> lizmat++ had the passing thought of exporting phasers, which is kinnda interesting

[20:41] <raydiak> but really something that works exactly like DESTROY but if there are any left at exit they get called, would work too

[20:41] <raydiak> there are a few subtly (but fiendishly) different things people might want in this area

[20:42] <raydiak> wrt to timing and ordering guarantees, for one

[20:42] *** adu left
[20:43] <PerlJam> masak: not quite.  LEAVE approaches the problem from the wrong end  (the routine rather than the object)

[20:43] *** raiph left
[20:43] <raydiak> so I understand that using this stuff if it existed would make things slower on exit, but it shouldn't be very concequential unless you're doing heavy stuff in there, just like it would be if you do heavy stuff in a LEAVE

[20:43] <PerlJam> raydiak: "exactly like DESTROY" isn't well-defined.  Different people have different ideas of what DESTROY is for (IMHO)

[20:43] *** Mouq joined
[20:43] *** raiph joined
[20:44] <raydiak> PerlJam: I mean working precisely as it does now in rakudo, except with the reliability bit

[20:44] <masak> sometimes I feel in the discussions about DESTROY that people desperately want it to work like it does in Perl 5... but that world is gone. timely destruction simply doesn't exist, and can't coexist with the other tradeoffs we've made, mostly GC-related, but also related to threading.

[20:44] <raydiak> okay so throw out the timely part

[20:45] <PerlJam> raydiak: if you do that, then I don't see a problem.

[20:45] <masak> if you throw out the timely part, *it may not fire at all*

[20:45] <masak> because the process may end.

[20:45] <PerlJam> or (statistically unlikely) the GC may never fire.  :)

[20:46] <masak> or may fire, but not for your object.

[20:46] <masak> (even though it could)

[20:46] *** adu joined
[20:46] <raydiak> if it gets killed or something, that's one thing, but I don't see why it's so hard to just make a copy of DESTROY which also gets called on any controlled exit if it hasn't already

[20:46] <masak> jnthn already answered that.

[20:46] <masak> because it's expensive, and nothing the OS can't do.

[20:47] <moritz> raydiak: then propose a patch

[20:47] <masak> +1

[20:47] <moritz> and if it doesn't slow down those programs that don't need it, and isn't overly complicated, I'm sure it'll be accepted

[20:48] <masak> on the face of it, it might incur an O(n) slowdown for n allocated objects.

[20:48] <raydiak> someone said we already have a flag that gets set when you declare a DESTROY

[20:49] <raydiak> so if we copy that, and people use it, they get the slowdown cuz they asked for it...otherwise shouldn't be hardly any

[20:49] * PerlJam still thinks that DESTROY should be renamed to CLEANUP or something with less conceptual baggage 

[20:49] <moritz> raydiak: yes, the meta object stores it

[20:49] <moritz> raydiak: http://doc.perl6.org/type/Metamodel%3A%3AFinalization

[20:49] <masak> PerlJam: there's a very strong symmetry between BUILD and DESTROY

[20:49] <ab5tract> PerlJam: i think today's discussions bear out the wisdom in that position

[20:49] <ab5tract> UNBUILD>

[20:49] <raydiak> yes note I'm not necessarily talking about changing DESTROY itself and don't have a proposed name because there are too many for my brain to consider atm

[20:49] <ab5tract> ?

[20:50] <PerlJam> masak: that only exacerbates the problem as far as I'm concerned.

[20:50] <raydiak> DISMANTLE?

[20:51] <masak> PerlJam: my point is, the resource things you would allocate or initialize in BUILD, you would deallocate or tear down in DESTROY.

[20:51] <raydiak> (it's even uncomfortable to type, which would be good imo)

[20:51] * masak watches in mild despair as the discussion once again morphs into a bike shedding

[20:52] *** raiph left
[20:53] *** raiph joined
[20:53] <raydiak> I think it's a natural way to think about objects, so letting people write code that way...is it a bad idea? we allow it with phasers, they just don't handle this case I'm look at very well and wish there was a way to do so, for the same reasons that the related phasers are cool to have

[20:56] * raydiak wishes TimToady were around

[20:57] * PerlJam notices that DESTROY is under-specced

[20:58] <raydiak> yeah I don't think the commit that meant to put it back, put everything back that I thought I saw about it before

[20:58] <ab5tract> masak: is balancing your BUILD with a DESTROY a suggestion or a requirement? what's the practical consequence of not writing a DESTROY to parallel your BUILD? i don't have any horses in this race, i only ask out of curiousity.

[20:59] <ab5tract> in discussions about perl 6 with people smarter than me, the existence of BUILD itself has come up as a question mark

[21:00] <PerlJam> ab5tract: Just like BUILD is only need *if* you need to do something special when you create your objects, DESTROY is only needed *if* you need to do somethign special when they go away.

[21:01] <masak> ab5tract: what PerlJam said. I'm likely to write a hundred BUILDs for every DESTROY I'll need to write.

[21:01] <masak> ab5tract: while they could go together and do opposite tasks, one can exist without the other.

[21:01] <ab5tract> these are comforting sentences to read

[21:02] *** Bucciarati left
[21:02] <masak> what I was addressing was changing a name that's already pretty optimal in its connotations to something else just because people feel that the Perl 5 meaning interferes too much with the Perl 6 meaning.

[21:02] <moritz> .oO( either can live while the ohters survive ... )

[21:02] <masak> moritz: IN THE SAME VULD

[21:03] <moritz> oh, right, I forgot about multi world theories

[21:03] <[Coke]> perljam: "LEAVE approaches the problem from the wrong end" - I disagree. can you show me an example where dealing with this in a LEAVE block doesn't work?

[21:04] <raydiak> people want me to give examples of what it'd be useful for, but I wonder what examples there are of things DESTROY is useful for as it exists now

[21:04] <masak> raydiak: me too.

[21:05] <geekosaur> LEAVE is lexical. I may well intend that my object survive my lexical scope, so that the caller can use it to do things and then it cleans up when it goes out of dynamic scope

[21:05] <raydiak> [Coke]: but I can't, from my own module, install a LEAVE in whatever is *using* my module, afaik

[21:05] <masak> it'd have to be something that "would be nice" if it ran at object GC, but not absolutely essential.

[21:05] <moritz> closing a TCP connection is a classical example

[21:05] <moritz> if you don't close it, it'll time out

[21:06] <moritz> but you're a nicer team player if you close it sooner

[21:06] <raydiak> yeah just something that is guaranteed to be called exactly once, at or after the last ref goes away, and at or before the program is terminated

[21:06] <[Coke]> and if you know you're done with it, you can close it yourself.

[21:06] <masak> moritz: was gonna say. close it explicitly in code.

[21:06] <masak> moritz: can probably be done with LEAVE in most cases.

[21:06] <geekosaur> my thinking is again that caching/buffering thing. where you need to update two different parts of the file when you flush, so the standard buffering isn't sufficient

[21:06] <PerlJam> Coke: IT does work, it's just potentially cumbersome.  To do something to a particular type of object every time it goes out of scope requires that I have a LEAVE in each of those scopes.   I'd rather have defined a CLEANUP method that gets called for me automatically.

[21:07] <moritz> masak: right. It's more of a fallback when somebody forgets it

[21:07] <masak> raydiak: it's not guaranteed to be called exactly once. it's guaranteed to be called at most once.

[21:07] <raydiak> masak: as it is now, yes...that's my problem

[21:07] *** Bucciarati joined
[21:07] <masak> raydiak: not even Perl 5 guarantees "exactly once".

[21:08] <geekosaur> also, think about this one, how is buffered file I/O currently implemented? does LEAVE work to do the final buffer flush if you're passing a file handle around?

[21:08] <moritz> and in p5, when you're in global destruction, all bets are off

[21:08] <[Coke]> perljam: so, LEAVE { $myObj.CLEANUP }, but where we automatically inspect all myobj's for a CLEANUP method on block close?

[21:08] <masak> raydiak: if that's your problem, then you have a pretty problem with a pretty fundamental part of memory/threading design in Perl 6.

[21:08] <geekosaur> (p5 gets away with this by handling it internally)

[21:08] <moritz> some of your attributes can be undfined

[21:08] <raydiak> masak: I am not thinking anywhere in the P5 region of my brain when I am talking about what I think we should have

[21:08] <masak> s/pretty//

[21:08] <[Coke]> that seems expensive.

[21:08] <timotimo> when do i start watching fosdem streams so that i don't miss anything perl6y?

[21:08] <yoleaux> 17:42Z <japhb> timotimo: That sounds eminently doable and a very good idea.  GitHub Issue it and I'll try to get to it next time I'm not slammed by $day-job?

[21:08] <[Coke]> s/all myobjs/vars/

[21:08] <PerlJam> Coke: aye and aye  (I'm just spit-balling hoping to find something better)

[21:09] <[Coke]> what if you've got a bound object that you then cleanup, making it useless for wherever else it's bound?

[21:09] <PerlJam> Coke: also, I think if there were something like that, it would satisfy what people think they want DESTROY to really do.

[21:10] <[Coke]> Is there any prior art in Java we can look at?

[21:10] <ab5tract> timotimo: there's perl 6 sprinkled all the way through the perl devroom tomorrow :)

[21:10] <[Coke]> at least there, it's been GC all the time, so there's no "java5" expectations. :)

[21:10] <PerlJam> Coke: that seems like a DIHWIDT situation

[21:11] <masak> ab5tract: I think you may have misunderstood timotimo's question...

[21:11] <timotimo> tomorrow, yeah?

[21:11] <masak> ab5tract: oh, nope. I misunderstood the question. :)

[21:11] <ab5tract> masak: :)

[21:11] <masak> ('when', not 'where')

[21:11] <masak> do we know where the streams are yet?

[21:12] * masak .oO( all I know so far is not to cross 'em )

[21:12] <retupmoca> The current DESTROY is very useful in NativeCall code, as a way to handle the C-side memory management (when this object is cleaned up, free this C struct / call this library cleanup function)

[21:12] <retupmoca> I haven't had any other use for it yet

[21:13] *** denis_boyun joined
[21:13] * retupmoca only caught the last half or so of the conversation

[21:14] <japhb> WRT to the timely destruction thing -- do we still have an NQP op to force a GC run?  If you use that, does DESTROY become reliable?

[21:14] <japhb> Basically, so that you can say "As of now, I want all pending DESTROY to happen.  I'm ready and willing to wait."

[21:14] <ab5tract> if that 

[21:14] *** denis_boyun left
[21:14] <masak> japhb: arrgh

[21:14] <[Coke]> what type is a nativecall object?

[21:14] <ab5tract> if that GC run could be scoped in any way, it could be useful

[21:14] <PerlJam> japhb: does a GC run guarantee that all objects waiting to be freed actually are?

[21:15] *** denis_boyun joined
[21:15] <japhb> masak: Why are you arrgh'ing me?

[21:15] <masak> japhb: (more)

[21:15] <japhb> PerlJam: Well, in our current implementation, I'm not sure if 1 would, but I believe 2 will.  :-)

[21:16] *** raiph left
[21:16] * japhb is mentally playing the Jeopardy final question music

[21:16] <ab5tract> raydiak: do i recall correctly that the impetus of your DESTROY desires also come from NativeCall?

[21:17] <raydiak> ab5tract: yeah that's where the thoughts came from originally

[21:17] <masak> japhb: because I think forcing GC is definitely a design smell.

[21:17] *** raiph joined
[21:17] <PerlJam> masak: I agree.

[21:18] <masak> japhb: and it's just another layer of failing to acknowledge the GC model we have, incurring overhead for wishful thinking

[21:18] <japhb> masak: I agree with you in almost all cases.  The exception is soft-real-time, e.g. games.

[21:18] <japhb> I disagree with that.  I believe it is intentionally breaking an abstraction to deal with a 1% case, when the GC is tuned for the 99% cases.

[21:19] <japhb> That's why I was asking about an NQP op, not saying Perl 6 feature.

[21:19] <PerlJam> japhb: and I agree with that  :)

[21:19] <japhb> And it was a *question*, not a suggestion, to boot.

[21:19] <raydiak> I'm not even necessarily talking about a change that has to be tied to GC at all, the only implementation hurdle I can see is knowing if anything is left that uses a metaclass with that DESTROY flag set at END time

[21:19] <masak> ok :) sorry for overreacting

[21:20] <japhb> hugme: hug masak

[21:20] * hugme hugs masak

[21:20] * moritz hugs masak and japhb without bot involvement

[21:20] <japhb> heh

[21:20] <masak> :)

[21:20] <El_Che> http://live.fosdem.org/

[21:20] *** colomon left
[21:20] <masak> \o/

[21:20] <El_Che> live stream

[21:20] <PerlJam> El_Che++

[21:21] <El_Che> http://live.fosdem.org/watch.php?room=K.3.401

[21:21] <El_Che> (if Perl is your thing :) )

[21:21] <El_Che> and on sunday, this is Larry's room: http://live.fosdem.org/watch.php?room=Janson

[21:22] <japhb> El_Che: I missed where you pointed to how (and when) we'll see the videos if we're on the other side of the planet.  YouTube, I'm guessing?

[21:22] *** raiph left
[21:22] <raydiak> perhaps I'm just being thick-headed...will re-read the backlog and reflect later, maybe look at what that patch would look like...afk for now

[21:22] <El_Che> japhb: no, you can livestream from the url I posted

[21:22] <El_Che> later the videos will also be available at the fosdem site

[21:23] <El_Che> starts tomorrow at 10:30 CET

[21:23] <japhb> El_Che: There's enough buffering to start it the night before and rewind it the next day?

[21:23] *** FROGGS left
[21:23] *** colomon joined
[21:23] *** denis_boyun left
[21:23] <El_Che> well; depending on where you are you can just watch the raw video

[21:23] <El_Che> that will be online soon

[21:23] *** diana_ joined
[21:23] * japhb is in America/Los_Angeles timezone (AKA PST)

[21:23] *** raiph joined
[21:24] <japhb> -08:00

[21:24] <El_Che> I'll post more info on the channel if I know more 

[21:24] <japhb> ok

[21:24] *** pecastro joined
[21:24] <El_Che> going to bed now (had to get up today at 4 am :() 

[21:25] <El_Che> and tomorrow will be early as well :)

[21:25] <El_Che> bye

[21:25] <japhb> o/

[21:25] *** diana_ left
[21:25] *** FROGGS joined
[21:25] *** colomon left
[21:25] *** diana_olhovik joined
[21:26] *** colomon joined
[21:26] <moritz> \o

[21:26] <retupmoca> CET is +0100 ?

[21:26] *** krunen left
[21:26] <japhb> .ask andreoss How is the perl6-bench pull request coming?

[21:26] <yoleaux> japhb: I'll pass your message to andreoss.

[21:27] <japhb> .tell timotimo Don't forget to GH-issue your perl6-bench feature request

[21:27] <yoleaux> japhb: I'll pass your message to timotimo.

[21:27] <ab5tract> i wasn't able to follow the whole conversation today, but if the main (only?) trouble spot with DESTROY is related to smoothing over the memory management of *another language*, then a) perl 6 is doing great, and b)  NativeCall is probably the layer we should be focusing on

[21:28] *** colomon left
[21:28] *** colomon joined
[21:29] <timotimo> aye

[21:29] <yoleaux> 21:27Z <japhb> timotimo: Don't forget to GH-issue your perl6-bench feature request

[21:30] * japhb wonders if we can bodge together an only-one-reference-ever object, the way some languages can ensure stray references can't be created, so whoever holds the one reference is guaranteed to be the one responsible for destroying it

[21:31] <masak> japhb: that would be interesting!

[21:31] <masak> (but hard)

[21:31] <japhb> Seems like once in a while, that guarantee is exactly what you need to retain sanity -- and be sure that if you have the reference, it is safe for you to create a LEAVE handler to destroy it, because no one else could possibly care about it.

[21:32] <moritz> isn't that exactly what rust is offering?

[21:32] <masak> it is

[21:33] <ab5tract> .tell El_Che streams!! much excite, many popcorn. thanks for all the hard work!

[21:33] <yoleaux> ab5tract: I'll pass your message to El_Che.

[21:33] <moritz> but they only achieve it by anchoring it very deep in their type system

[21:33] * japhb doesn't know rust, but has seen it in C++, and knew of some Microsoft research that supported it for other languages (though they had gone a bit farther with the idea than just that)

[21:34] <masak> the theory is called affine algebra, IIRC

[21:34] <japhb> ISTR they had the ability to define "islands" in an object graph that have only one inbound reference

[21:34] <japhb> (But possibly many objects within that island that reference each other)

[21:34] <masak> japhb: I remember that paper

[21:34] <masak> very aggregates

[21:37] *** raiph left
[21:39] *** yoleaux left
[21:39] *** kjs_ joined
[21:40] *** FROGGS[mobile] joined
[21:41] *** colomon left
[21:43] <moritz> such DDD :-)

[21:43] *** colomon joined
[21:44] *** Mouq left
[21:45] <ab5tract> solving it at that layer would be even better :D

[21:47] <ab5tract> i'm signing off for the night. i'm excited for this weekend! i feel a bit like a bum for being near-but-not-at fosdem, but there's streams! and i will hopefully be releasing my first p6 module before the bell of monday tolls.

[21:48] <ab5tract> good night and many thanks for all the insightful discussion :)

[21:48] <ab5tract> hugme: #perl6

[21:48] *** FROGGS[mobile] left
[21:48] <FROGGS> gnight ab5tract 

[21:48] *** pecastro left
[21:49] <ab5tract> (i guess hugme prefers legitimate nicks)

[21:49] <moritz> sleeping is a good idea

[21:49] <FROGGS> hugme: hug #perl6

[21:49] * hugme hugs #perl6

[21:49] *** pecastro joined
[21:49] <FROGGS> sleep well moritz :o)

[21:50] <ab5tract> o O ( hugme knows how to do other things? )

[21:51] *** diana_olhovik left
[21:51] <PerlJam> ab5tract: hugme has the important but all-too-overlooked task of hugging others.   It doesn't need to do other things :)

[21:52] <ab5tract> :)

[21:52] *** ab5tract left
[21:54] <japhb> It used to also hand out commitbits, IIRC

[21:55] <japhb> hugme: help

[21:55] <hugme> japhb: (add $who to $project | list projects | show $project | hug $nickname | tweet $twittername $message )

[21:55] <japhb> Functionality appears to still be there, though I dunno if it has the right credentials still

[21:55] <japhb> hugme: list projects

[21:55] <PerlJam> hugme: list projects

[21:55] <hugme> PerlJam: I know about Math-Model, Math-RungeKutta, MiniDBI, bench-scripts, book, gge, hugme, ilbot, java2perl6, json, modules.perl6.org, november, nqp-rx, nqpbook, perl6, perl6-examples, perl6-wtop, proto, rakudo, star, svg-matchdumper, svg-plot, tardis, try.rakudo.org, tufte, ufo, web, yapsi

[21:55] <hugme> japhb: I know about Math-Model, Math-RungeKutta, MiniDBI, bench-scripts, book, gge, hugme, ilbot, java2perl6, json, modules.perl6.org, november, nqp-rx, nqpbook, perl6, perl6-examples, perl6-wtop, proto, rakudo, star, svg-matchdumper, svg-plot, tardis, try.rakudo.org, tufte, ufo, web, yapsi

[21:55] <PerlJam> heh

[21:56] <japhb> Great minds.  ;-)

[21:56] <japhb> hugme: show hugme

[21:56] <hugme> japhb: the following people have power over 'hugme': P⁣erlJam, T⁣imToady, [⁣particle], c⁣olomon, j⁣nthn, m⁣asak, m⁣berends, m⁣oritz_, p⁣michaud. URL: http://github.com/moritz/hugme/

[21:56] <japhb> nice

[21:59] *** xfix left
[22:00] <PerlJam> Everybody at FOSDEM have an excellent time!

[22:00] * PerlJam is headed out

[22:03] *** kjs_ left
[22:04] <raydiak> heh and if yer really lonely...

[22:04] <raydiak> hugme: cuddle me

[22:04] * hugme cuddles raydiak

[22:04] <japhb> 'hugme: help' patch clearly needed.  :-)

[22:05] <tadzik> oh, I didn't know it can cuddle :)

[22:06] <raydiak> looks like it'll blush and hand out karma once in a while too

[22:08] <FROGGS> hugme++

[22:08] <japhb> .karma hugme

[22:08] <japhb> oh well

[22:09] <raydiak> I thought maybe the help omission was intentional...some people might object to being cuddled without consent :)

[22:09] <japhb> Does it allow cuddling anyone, or just 'cuddle me'?

[22:09] <tadzik> hugme: cuddle japhb 

[22:09] * hugme cuddles japhb

[22:09] <tadzik> ha

[22:09] <tadzik> a proxy :D

[22:11] *** raiph joined
[22:11] *** alinbsp joined
[22:11] *** rurban joined
[22:12] *** colomon left
[22:12] * japhb imagines hugme looks like Big Hero 6

[22:13] *** rurban left
[22:13] <masak> :D

[22:14] *** raiph left
[22:14] <raydiak> hugme: hug strings with spaces

[22:14] * hugme hugs strings

[22:14] *** raiph joined
[22:15] <masak> hugme: hug strings with non-breaking spaces

[22:15] * hugme hugs strings with non-breaking spaces

[22:16] *** pecastro left
[22:18] *** colomon joined
[22:23] <raydiak> retupmoca: would you consider packaging a zlib dll with compress::zlib::raw to make it more windows-friendly?

[22:23] <skids> .oO(sheesh selinux is one big festering DRY violation.  Yay.  Now I can go home.)

[22:24] *** raiph left
[22:25] *** raiph joined
[22:28] *** skids left
[22:33] *** vendethiel joined
[22:34] *** raiph left
[22:34] *** raiph joined
[22:35] *** raiph left
[22:35] *** raiph joined
[22:38] *** espadrine joined
[22:43] *** raiph left
[22:44] *** raiph joined
[22:47] *** raiph left
[22:48] *** raiph joined
[22:52] *** raiph left
[22:52] *** raiph joined
[22:57] *** [Sno] joined
[22:57] <Kristien> I want to learn Fortran.

[22:58] <FROGGS> why?

[22:58] <masak> Kristien: lesson one: it's spelled 'FORTRAN'

[22:58] <masak> :P

[22:59] <Kristien> No, not that old crap. :(

[23:00] <masak> oh, you're right. they seem to have ameliorated that. https://en.wikipedia.org/wiki/Fortran

[23:00] <masak> since Fortran 90.

[23:01] <vendethiel> Kristien: we do have a lot in common, :P

[23:01] *** IllvilJa left
[23:04] *** jimmy joined
[23:06] *** jimmy left
[23:12] *** raiph left
[23:13] *** raiph joined
[23:13] <timotimo> .tell japhb i think https://github.com/japhb/perl6-bench/issues/13 should be fixed by the automatic timeout detection stuff we have

[23:18] *** raiph left
[23:18] *** raiph joined
[23:20] <sergot> m: say 1 andthen say 2;

[23:20] <camelia> rakudo-moar 7fd2f6: OUTPUT«1␤2␤»

[23:22] *** raiph left
[23:22] *** raiph joined
[23:23] *** adu left
[23:28] *** raiph left
[23:29] *** raiph joined
[23:34] *** pecastro joined
[23:34] <Kristien> m: 42.numerator.say

[23:34] <camelia> rakudo-moar 7fd2f6: OUTPUT«No such method 'numerator' for invocant of type 'Int'␤  in block <unit> at /tmp/nKus3bDaHC:1␤␤»

[23:34] <Kristien> :(

[23:34] <Kristien> Why does Int not do Rational?

[23:37] <masak> because Perl 6 doesn't have a numerical tower based on subtyping, as you seem to assume.

[23:37] <japhb> .tell timotimo Thank you!  I've commented and closed it.

[23:37] <masak> both Int and Rat are Real and Numeric, though.

[23:39] * japhb chuckles: All remaining open issues for perl6-bench were opened by timotimo++

[23:39] <japhb> Wait, my .tell didn't work.  What happened to yoleaux?

[23:39] <Kristien> yoleaux is dead

[23:40] <masak> long live yoleaux

[23:40] <japhb> Someone hit it with the paddles ... or a resurrection spell, your choice of genre solutions

[23:41] <japhb> MHF (Medium Hanging Fruit) for the interested: Get Proc::Async working on r-j

[23:45] <vendethiel> .oO( not long live the yoleaux ! )

[23:47] *** woolfy joined
[23:50] *** kjs_ joined
[23:54] *** kjs_ left
[23:59] *** adu joined
