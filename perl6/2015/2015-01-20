[00:02] <jnthn> sleep; 'night, #perl6

[00:03] *** fwilson left
[00:04] *** fwilson joined
[00:04] *** fwilson is now known as Guest97975

[00:05] *** Guest97975 left
[00:05] *** Guest97975 joined
[00:05] *** Guest97975 is now known as fwilson

[00:19] *** BenGoldberg joined
[00:19] <masak> 'night, #perl6

[00:22] *** mr-foobar left
[00:22] *** mr-fooba_ joined
[00:41] *** mr-fooba_ left
[00:41] *** mr-foobar joined
[00:47] *** dayangkun joined
[00:54] *** araujo left
[00:54] *** araujo joined
[00:59] *** dayangkun left
[01:14] *** yeahnoob joined
[02:10] *** chenryn joined
[02:17] <[Coke]> that failure jnthn says:

[02:17] <[Coke]> # expected: [1, 1]

[02:17] <[Coke]> #      got: [1, 1]

[02:22] <skids> [Coke]: https://gist.github.com/skids/645c4a83d8c3f0c0b42e

[02:24] *** vendethiel left
[02:28] *** tinyblak_ joined
[02:30] *** tinyblak left
[02:38] *** mr-foobar left
[02:44] *** ilbot3 left
[02:45] *** vendethiel joined
[02:46] *** ilbot3 joined
[02:47] *** chenryn left
[02:47] <TimToady> lizmat: S03-operators/range.t is dying on jvm, is that related to what you were doing with ranges?

[02:48] <adu> dying?!?

[02:49] <TimToady> fails to compile something in there

[02:50] *** chenryn joined
[02:50] <adu> this is why I believe that compilers and runtimes should be designed by a single super-coder after drinkinging 42 cases of redbull, instead of thousands of community members with lots of different ideas

[02:52] <timotimo> it's easier to ask for an energy drink than for permission

[02:52] <TimToady> it's the final test

[02:54] <TimToady> j: *.perl for ^2

[02:54] <camelia> rakudo-jvm d78c67: OUTPUT¬´Can't open perl script "/home/camelia/jvm-rakudo/eval-client.pl": No such file or directory‚ê§¬ª

[02:55] <TimToady> well, that's what it's blowing up on

[02:56] <TimToady> any range on the right blows it up, not just 0-based

[02:58] <TimToady> *.say also blows up, so not related to .perl; changing it to ... fixes it

[02:59] <TimToady> so definitely something of interest to the Range Safety Officer

[02:59] *** chenryn_ joined
[03:01] *** chenryn left
[03:03] *** BenGoldberg left
[03:05] <adu> can I be the grammar actions compatibility officer?

[03:06] *** vendethiel left
[03:06] *** mr-foobar joined
[03:20] *** tinyblak_ left
[03:20] *** tinyblak joined
[03:21] *** Exodist joined
[03:25] *** chenryn_ left
[03:25] *** tinyblak left
[03:27] *** chenryn_ joined
[03:46] *** tinyblak joined
[03:48] *** leont left
[03:55] *** noganex_ joined
[03:59] *** noganex left
[04:01] *** chenryn_ left
[04:47] *** chenryn_ joined
[04:56] *** tinyblak left
[04:57] *** tinyblak joined
[05:02] *** tinyblak left
[05:18] *** chenryn_ left
[05:22] *** chenryn_ joined
[05:27] <dalek> rakudo-star-daily: d6dafaa | coke++ | bin/star.sh:

[05:27] <dalek> rakudo-star-daily: don't clobber imple-version,

[05:27] <dalek> rakudo-star-daily: also openjdk has different cli options

[05:27] <dalek> rakudo-star-daily: 

[05:27] <dalek> rakudo-star-daily: skids++

[05:27] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d6dafaa337

[05:29] *** mr-foobar left
[05:32] *** Pleiades` left
[05:33] *** JeffS joined
[05:35] *** Pleiades` joined
[05:36] <dalek> mojo6: 94c24c6 | hoelzro++ | lib/Mojo/DOM/CSS.pm:

[05:36] <dalek> mojo6: Use CSS::Module::CSS3::Selectors for CSS parsing

[05:36] <dalek> mojo6: 

[05:36] <dalek> mojo6: This includes some newer selectors

[05:36] <dalek> mojo6: review: https://github.com/coke/mojo6/commit/94c24c6ce6

[05:36] *** dalek left
[05:37] *** dalek joined
[05:37] *** ChanServ sets mode: +v dalek

[05:40] *** vendethiel joined
[05:51] *** mr-foobar joined
[06:03] *** vendethiel left
[06:05] *** mr-foobar left
[06:09] * [Coke] chuckles at http://boingboing.net/2015/01/19/people-in-northern-sweden-say.html

[06:12] *** vendethiel joined
[06:17] *** FROGGS left
[06:27] *** tinyblak joined
[06:33] *** vendethiel left
[06:42] *** Rounin joined
[06:47] *** dayangkun joined
[06:47] *** dayangkun left
[06:52] *** xfix joined
[06:54] *** MilkmanDan left
[06:59] *** FROGGS joined
[07:01] *** vendethiel joined
[07:03] *** kaleem joined
[07:19] *** anaeem1 joined
[07:21] *** booly-yam-6137 left
[07:22] *** denis_boyun joined
[07:22] *** vendethiel left
[07:24] *** darutoko joined
[07:24] *** JeffS left
[07:26] *** gfldex joined
[07:27] *** adu left
[07:28] *** denis_boyun left
[07:36] *** anaeem1__ joined
[07:39] *** anaeem1__ left
[07:39] *** anaeem1 left
[07:41] *** chenryn_ left
[07:42] *** anaeem1 joined
[07:45] *** chenryn_ joined
[07:51] *** rurban joined
[07:52] *** vendethiel joined
[07:56] *** abraxxa joined
[07:56] *** gfldex left
[08:05] *** prime left
[08:06] *** dayangkun joined
[08:12] *** zakharyas joined
[08:13] *** vendethiel left
[08:16] *** chenryn_ left
[08:17] *** prime joined
[08:18] *** [Sno] left
[08:19] *** dayangkun left
[08:20] *** chenryn_ joined
[08:22] *** booly-yam-6137 joined
[08:27] *** rurban left
[08:36] *** Mso150 joined
[08:38] *** virtualsue joined
[08:39] *** Akagi201_ left
[08:42] *** vendethiel joined
[08:48] *** Mso150 left
[08:51] *** chenryn_ left
[08:54] *** MilkmanDan joined
[08:54] <[Tux]> Unable to parse expression in block; couldn't find final '}' <= why does the error message not show the line number of the '{' ??

[08:57] *** chenryn_ joined
[08:58] <FROGGS> hmmm

[09:00] *** gtodd left
[09:00] *** gtodd joined
[09:01] *** tinyblak left
[09:01] *** tinyblak joined
[09:01] *** tinyblak left
[09:02] *** anaeem1 left
[09:03] *** anaeem1_ joined
[09:05] *** vendethiel left
[09:06] <FROGGS> m: {‚ê§‚ê§‚ê§‚ê§say 42;‚ê§‚ê§‚ê§

[09:06] <camelia> rakudo-moar d78c67: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/gIfoi76lPg‚ê§Unable to parse expression in block; couldn't find final '}' ‚ê§at /tmp/gIfoi76lPg:8‚ê§------> [32m<BOL>[33m‚èè[31m<EOL>[0m‚ê§¬ª

[09:06] <FROGGS> [Tux]: we can easily do that

[09:07] <FROGGS> std: {‚ê§‚ê§‚ê§‚ê§say 42;‚ê§‚ê§‚ê§

[09:07] <camelia> std f9b7f55: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse block at /tmp/cdT0Vim6rH line 1:‚ê§------> [32m<BOL>[33m‚èè[31m{[0m‚ê§Couldn't find final '}'; gave up at /tmp/cdT0Vim6rH line 7 (EOF):‚ê§------> [32m<BOL>[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 1‚Ä¶¬ª

[09:07] <FROGGS> std++

[09:13] <FROGGS> hmmm, not so easy at it seems :/

[09:14] *** yeahnoob left
[09:14] *** yeahnoob joined
[09:14] <FROGGS> we've to tweak FAILGOAL and nqp/src/QRegex/P6Regex/Actions.nqp:297    method metachar:sym<~>($/) {

[09:22] *** donaldh joined
[09:22] * moritz is very much in favor of reporting that

[09:24] *** anaeem1_ left
[09:24] *** [Sno] joined
[09:24] *** vendethiel joined
[09:24] <FROGGS> moritz: me too

[09:26] *** chenryn_ left
[09:27] *** molaf_ joined
[09:28] *** chenryn_ joined
[09:29] *** telex left
[09:30] *** molaf left
[09:30] *** telex joined
[09:35] *** tinyblak joined
[09:35] *** tinyblak left
[09:36] *** tinyblak joined
[09:36] *** tinyblak left
[09:36] *** tinyblak joined
[09:41] *** yeahnoob left
[09:45] *** Woodi_ left
[09:45] *** Woodi joined
[09:46] <donaldh> It would be good if camelia could run rakudo with RAKUDO_ERROR_COLOR=0 to get rid of escape sequences.

[09:46] *** vendethiel left
[09:46] <FROGGS> donaldh: why? I see the colors in my irc client, and it looks nice :o9

[09:46] <FROGGS> :o)

[09:47] <moritz> there was a time when the IRC logs showed the colors too :-)

[09:47] <donaldh> Ah, term based client?

[09:47] <donaldh> Well that was my other suggestion ;-)

[09:47] <FROGGS> donaldh: XChat

[09:48] <moritz> donaldh: patch it around https://github.com/perl6/evalbot/blob/master/evalbot.pl#L128 ?

[09:48] <FROGGS> and I'm using a xchat script: ansi_color-0.2.pl

[09:49] *** mvuets joined
[09:51] *** chenryn__ joined
[09:52] *** kjs_ joined
[09:52] *** anaeem1 joined
[09:53] *** chenryn_ left
[09:58] <donaldh> r: say '

[09:58] <camelia> rakudo-{parrot,moar} d78c67: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Unable to parse expression in single quotes; couldn't find final "'" ‚ê§at /tmp/tmpfile:1‚ê§------> [32msay '[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        argument lis‚Ä¶¬ª

[10:02] *** chenryn__ left
[10:08] <donaldh> moritz: Hmm, you do have code for it in ilbot https://github.com/moritz/ilbot/blob/595523b74505e5ae988076042f4fcd15309825d5/lib/Ilbot/Frontend/TextFilter.pm#L37

[10:09] *** chenryn__ joined
[10:09] <moritz> donaldh: yes, but that's very fragile

[10:10] <moritz> donaldh: the IRC library tries to decode the whole string as UTF-8 first

[10:10] <moritz> donaldh: and that can already fail with ansi color codes, and leat to mojibake

[10:11] *** pecastro joined
[10:18] <donaldh> what fun

[10:23] <jnthn> o/ #perl6

[10:23] <JimmyZ> \o

[10:35] *** Ven joined
[10:40] *** yeahnoob joined
[10:41] *** Ven left
[10:41] *** vendethiel joined
[10:41] *** virtualsue left
[10:46] <jnthn> Naming suggestions time! (What could possibly go wrong...)

[10:46] <nwc10> Brussels

[10:47] <nwc10> (I believe that it's unused)

[10:47] <jnthn> No, not for *that*!

[10:47] <nwc10> "beer"

[10:47] <moritz> "mojibake"

[10:47] <jnthn> Coercion types look like Str(Any), where Str is the type we will end up with after coercion, and Any is the type we will accept and coerce.

[10:47] <jnthn> I'm looking for names for the two types involved.

[10:47] <moritz> constraint type and target type

[10:47] <jnthn> I'd had target in mind :)

[10:48] <jnthn> I quite like constraint too

[10:48] <timotimo> product type and educt type

[10:48] <jnthn> No. :P

[10:48] <timotimo> parenthesized type and preparenthesis type

[10:48] <timotimo> ah, i've got it!

[10:49] <timotimo> Left Type and Right Type!

[10:49] <jnthn> Or Right Type and Wrong Type :P

[10:49] <timotimo> œÑ type and œá type

[10:49] <jnthn> moritz++ is winning so far... :)

[10:50] <timotimo> inner type, outer type

[10:50] <timotimo> (i really like this one)

[10:50] <jnthn> Well, it follows how a coercion type *looks* but doesn't really explain the role of the two types involved.

[10:51] <timotimo> unless you look at it in the context of a call

[10:51] <timotimo> ... in which case inner and outer are actually reversed :\

[10:51] <timotimo> but it'd be "the type th ething ends up having on the inside of the routine" and "the type the thing had outside of the routine"

[10:52] <timotimo> but since both explanations are similarly plausible, it'd be better to throw this one out completely :\

[10:52] <timotimo> m: say (5/1).WHAT; say (5/1).narrow.WHAT

[10:52] <camelia> rakudo-moar d78c67: OUTPUT¬´(Rat)‚ê§(Int)‚ê§¬ª

[10:52] <jnthn> Yeah, and while I'm only going to implement it on parameters for now, in the long run you'll be able to use it as a return type, variable type, attribute type, etc.

[10:52] <timotimo> i kind of like the idea of having a "narrow(Numeric)" "coercive type"

[10:54] <jnthn> Basic coercion type support lets me continue gently flexing the 6pe muscle, as well as allowing us to give people an alternative to the "as Type" trait which is long-despuc.

[10:56] <timotimo> gotta go again

[10:56] <timotimo> o/

[10:58] *** rindolf joined
[11:01] *** booly-yam-6137 left
[11:06] *** anaeem1 left
[11:08] <lizmat> the RSO is looking into the range related failure on the JVM

[11:11] *** anaeem1 joined
[11:15] *** tinyblak left
[11:15] *** tinyblak joined
[11:19] * jnthn must be working as the cleaner this week, 'cus all he does is MOP...

[11:21] *** grondilu joined
[11:21] <lizmat> jnthn: could it be that a try with a thunk in NQP fails on the JVM ?

[11:24] <jnthn> lizmat: As in, with the curlies missing?

[11:24] <jnthn> It's *possible* I guess...though I thought the NQP test suite covered it.

[11:25] <donaldh> lizmat: do you have an example?

[11:26] <lizmat> not yet

[11:26] *** virtualsue joined
[11:26] <lizmat> ok, confirmed: my reinstate of the ^1000 -> while opt, breaks the JVM in b76f601a1c146a7c0990398cf55c4c7a23504163

[11:28] *** chenryn__ left
[11:28] *** tinyblak_ joined
[11:29] <lizmat> trying with try {} to see if that makes a difference

[11:29] <lizmat> it just takes longer on the JVM  :-(

[11:30] <lizmat> nope, that's not it :-(

[11:32] *** tinyblak left
[11:32] <lizmat> jnthn donaldh: does this ring any bell?  https://gist.github.com/lizmat/a4564fd632196a551018

[11:33] <donaldh> that's been lurking a while IIRC

[11:34] <jnthn> That's one of those "should never happen" things...

[11:35] <jnthn> Means we got an exception, tried to unwind the stack, but the target unwind point was missed.

[11:35] *** denis_boyun joined
[11:35] <lizmat> and who know where the exception happened...  :-(

[11:37] * donaldh will try to reproduce in debugger

[11:37] *** booly-yam-6137 joined
[11:37] <jnthn> lizmat: Try setting the NQP_VERBOSE_EXCEPTIONS environment variable

[11:39] *** jluis left
[11:40] <lizmat> I've established it happens inside optimize_for_range 

[11:40] <masak> good afternoon, #perl6

[11:42] *** leont joined
[11:44] *** kaleem left
[11:45] <lizmat> No such attribute '$!phasers' for this object

[11:46] <lizmat> jnthn donaldh: seems like the try around that is not catching this exception?

[11:48] * donaldh is just rebuilding rakudo

[11:50] *** virtualsue left
[11:56] *** FROGGS left
[11:57] *** jluis joined
[11:58] * jnthn doesn't see any try

[11:58] <jnthn> Oh...but I'm in a branch.

[11:59] <jnthn> Hmm...it's odd that the .count call would work but the thing not have a $!phasers...

[12:00] <jnthn> lizmat: If you turn it into a try { ... } instead, does it help?

[12:00] <lizmat> tried that already (no pun intended)

[12:00] <dalek> rakudo/6pe-mop: 22636e8 | jnthn++ | / (5 files):

[12:00] <dalek> rakudo/6pe-mop: Add and set up a basic CoercionHOW.

[12:00] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/22636e8420

[12:00] <lizmat> testing a fix now

[12:01] <lizmat> jnthn: the problem is that there isn't a block available

[12:01] <jnthn> lizmat: I don't understand?

[12:02] <lizmat> $!symbols.Block is null

[12:02] <jnthn> wtf

[12:02] <jnthn> That's really weird.

[12:03] *** dwarring left
[12:09] *** chenryn__ joined
[12:14] <donaldh> This golfs down to perl -e '.perl for ^2' # good

[12:14] <donaldh> perl -e '*.perl for ^2' # bad

[12:14] <masak> `perl6`, surely?

[12:14] <donaldh> yes,sorry

[12:15] <lizmat> donaldh already lives in the future  :-)

[12:15] <donaldh> not cut and pasto across machines

[12:15] <donaldh> error in swivel chair

[12:16] <jnthn> m: say WhateverCode

[12:16] <camelia> rakudo-moar d78c67: OUTPUT¬´(WhateverCode)‚ê§¬ª

[12:16] <jnthn> m: say WhateverCode ~~ Block

[12:16] <camelia> rakudo-moar d78c67: OUTPUT¬´False‚ê§¬ª

[12:16] <jnthn> Ah

[12:18] <masak> well, a whatever code isn't a block :P

[12:19] <donaldh> so no $!phasers

[12:19] <donaldh> are we helping :P

[12:20] <jnthn> Well, it explains why the .count call worked out and the $!phasers did not

[12:21] <donaldh> lunch&

[12:21] <lizmat> jnthn: if I treat the absence of a block as no phasers, I get test failures about phasers not being run

[12:23] <jnthn> Well, you could do 

[12:23] <jnthn> my $phasers := nqp::istype($code, $block) ?? nqp::getattr($code, $block, '$!phasers') !! nqp::null();

[12:23] *** rurban joined
[12:24] * lizmat tries

[12:25] <dalek> rakudo/6pe-mop: f27f57f | jnthn++ | src/core/EXPORTHOW.pm:

[12:25] <dalek> rakudo/6pe-mop: Add coercion types to EXPORTHOW of CORE.setting.

[12:25] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/f27f57ffd8

[12:25] <dalek> rakudo/6pe-mop: fc3cd42 | jnthn++ | src/Perl6/Actions.nqp:

[12:25] <dalek> rakudo/6pe-mop: Report full type name in an error, not part of it.

[12:25] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/fc3cd42ce1

[12:30] *** chenryn__ left
[12:30] *** kaare_ left
[12:30] *** kaare_ joined
[12:33] <dalek> rakudo/6pe-mop: 37cb0c6 | jnthn++ | src/Perl6/ (2 files):

[12:33] <dalek> rakudo/6pe-mop: Start constructing coercion types from syntax.

[12:33] <dalek> rakudo/6pe-mop: 

[12:33] <dalek> rakudo/6pe-mop: They're not useful for anything yet, however.

[12:33] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/37cb0c6447

[12:35] <dalek> rakudo/6pe-mop: 0bda6cf | jnthn++ | src/Perl6/ (2 files):

[12:35] <dalek> rakudo/6pe-mop: Handle coercion types on parameters.

[12:35] <dalek> rakudo/6pe-mop: 

[12:35] <dalek> rakudo/6pe-mop: This deconstructs them and re-uses the existing implementation of

[12:35] <dalek> rakudo/6pe-mop: coercion types built for the 'as' keyword. This is probably a sane

[12:35] <dalek> rakudo/6pe-mop: long-term approach.

[12:35] <dalek> rakudo/6pe-mop: review: https://github.com/rakudo/rakudo/commit/0bda6cf198

[12:36] <jnthn> > sub foo(Str(Any) $x) { say $x.WHAT }; foo(42)

[12:36] <jnthn> (Str)

[12:36] <jnthn> :)

[12:36] <moritz> \o/

[12:37] <jnthn> So, 2015.02 can ship with this working (the branch won't land for 2015.01), and then we'll be able to deprecate the now-not-spec "as" trait.

[12:37] *** chenryn__ joined
[12:38] <JimmyZ> \o/ nicie

[12:39] <JimmyZ> *nice

[12:39] <dalek> rakudo/nom: f9cb170 | lizmat++ | src/Perl6/Optimizer.nqp:

[12:39] <dalek> rakudo/nom: Fix optimizer breakage on JVM, jnthn++ for suggestion

[12:39] <dalek> rakudo/nom: 

[12:39] <dalek> rakudo/nom: Apparently the "try" was not enough to keep it from exploding.

[12:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9cb17097c

[12:39] <moritz> jnthn: what does   say Str(Any).^name  say?

[12:39] *** fhelmberger joined
[12:39] *** skids left
[12:39] <jnthn> moritz: Somehow that parses not with the typename rule... :(

[12:40] <jnthn> But if it worked out, you'd see Str(Any)

[12:40] <JimmyZ> $x as Str?

[12:40] <jnthn> > Metamodel::CoercionHOW.new_type(Str, Any).^name

[12:40] <jnthn> Str(Any)

[12:41] <jnthn> JimmyZ: $x as Str becomes Str(Any) $x, yes.

[12:42] * moritz has a few ideas on how to try to break it

[12:42] <JimmyZ> great

[12:42] <moritz> ... by writing unit tests, of course :-)

[12:42] <jnthn> moritz: If you'd like to write some tests, that'd be helpful :)

[12:43] <jnthn> For now I've just implemented it far enough that it should work for everything the "as" trait did, but also the MOP stuff should be on a sound enough footing now that we'll be able to handle more cases of it later.

[12:43] <moritz> jnthn: I'll see if I can get around to it later in the underground

[12:44] <CurtisOvidPoe> Is it fair to say that ‚Äúmulti fibonacci(0) {0}‚Äù uses t ype inference to assume the argument must be an Int with a value of 0?

[12:44] *** kaare_ left
[12:44] <lizmat> m: say 0.WHAT

[12:44] <camelia> rakudo-moar d78c67: OUTPUT¬´(Int)‚ê§¬ª

[12:44] <jnthn> CurtisOvidPoe: Yes.

[12:44] <moritz> it's a very simple kind of type inference, though :-)

[12:44] <jnthn> CurtisOvidPoe: Well, it just takes the constant and does .WHAT on it and uses it as the type constraint.

[12:45] <lizmat> and adds a where * == 0, right ?

[12:45] <CurtisOvidPoe> It‚Äôs simple, but later it sets up subset PointLimit where -10.0 .. 10.0;

[12:45] *** kaare_ joined
[12:45] <jnthn> lizmat: Well, "where 0" more literally, since we smart-match the thing on the RHS of where.

[12:46] <jnthn> So multi fib(0) { 0 } compiles just like multi fib(Int $ where 0) { }

[12:46] <jnthn> uh, with the 0 in the block :)

[12:47] *** kjs_ left
[12:48] *** leont left
[12:48] *** kjs_ joined
[12:49] <CurtisOvidPoe> Damn it. If this language doesn‚Äôt get released, I‚Äôm going to be seriously disappointed in all of you ;)

[12:50] *** kjs_ left
[12:51] <jnthn> Working on it... :P

[12:51] <jnthn> (And going to have a lot more time during 2015 to work on it than during 2014. :))

[12:52] <CurtisOvidPoe> Lose your job? 

[12:55] <CurtisOvidPoe> (er, that was meant as a joke. If it was true and hit home, my apologies)

[12:55] <lizmat> CurtisOvidPoe: I think a better description would be "reevaluating priorities"

[12:56] <jnthn> Hah, no; more like "a little life/work refactoring" :)

[12:56] <CurtisOvidPoe> That sound great. And selfishly, it makes me happy if it means p6 is our sooner :)

[12:56] *** kaleem joined
[12:57] <lizmat> .oO( it is ours already, just not done  :-)

[12:57] * CurtisOvidPoe typed ‚Äúour‚Äù? Sigh ...

[12:59] <lizmat> I thought it was cute  :-)

[13:00] *** virtualsue joined
[13:07] <CurtisOvidPoe> Another question for my talk: Perl 6 tries to determine types at at compile time, but if it can‚Äôt, it determines types at runtime? Is that true?

[13:08] <CurtisOvidPoe> Er, yeah, that seems pretty correct, but are there examples of compile-time failures that result from that?

[13:09] *** chenryn__ left
[13:10] <lizmat> m: sub a(Int $a) { ... }; a("foo")

[13:10] <camelia> rakudo-moar d78c67: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/_nM069uLnS‚ê§Calling 'a' will never work with argument types (str)‚ê§    Expected: :(Int $a)‚ê§at /tmp/_nM069uLnS:1‚ê§------> [32msub a(Int $a) { ... }; [33m‚èè[31ma("foo")[0m‚ê§¬ª

[13:10] <lizmat> CurtisOvidPoe: is that what you mean ?

[13:10] <CurtisOvidPoe> Perfect! Thank you :)

[13:12] <jnthn> That kind of thing is pretty much what I'm going to talk about at FOSDEM :)

[13:12] <sergot> hi \o

[13:13] <jnthn> o/ sergot 

[13:15] <sergot> I will be at FOSDEM \o/ can't wait :)

[13:16] <jnthn> Cool!

[13:16] <jnthn> So many 6folk \o/

[13:16] <sergot> \o/

[13:17] <CurtisOvidPoe> Don‚Äôt worry, jnthn, I won‚Äôt steal too much of your thunder :) (because I can‚Äôt, in this case)

[13:17] *** FROGGS joined
[13:17] <sergot> jnthn: do you have any ideas what we can do during GSoC for MoarVM?

[13:18] <psch> \o

[13:18] <psch> the Grammar::Profiler::Simple failure on jvm seems to happen because .orig gets lost

[13:18] <tadzik> sergot: pls bundling

[13:19] <psch> between TOP and line, that is

[13:19] <tadzik> moar fakexecutables

[13:19] *** mattp_ left
[13:20] <psch> re: gsoc&moar, istr that at least one distro has trouble packaging because of hardcoded lib paths or something like that?

[13:20] <JimmyZ> moar fakeexecuatable? there is a patch by nwc10++

[13:20] <sergot> tadzik: write it there please: https://github.com/perl6/mu/blob/master/misc/gsoc-2015/ideas.md

[13:20] <jnthn> sergot: Well, last years project was on JIT stuff, and there's more work that can be done there.

[13:20] *** mattp_ joined
[13:20] <psch> although i don't know if that's big enough for gsoc

[13:20] <JimmyZ> and spesh!

[13:21] <jnthn> Given there already exist patches for the moar fakeexecutable that, once I review them, will likely make it in, I think that's probably a "we'll have it by gsoc" thing.

[13:21] <jnthn> There are various opportunities to work with dynamic optimization (spesh) stuff.

[13:21] <sergot> if you have any ideas, please update the file https://github.com/perl6/mu/blob/master/misc/gsoc-2015/ideas.md :))

[13:22] <dalek> mu: 250680e | tadzik++ | misc/gsoc-2015/ideas.md:

[13:22] <dalek> mu: Add a MoarVM fakexecutable tool for GSoC 2015

[13:22] <dalek> mu: review: https://github.com/perl6/mu/commit/250680ec42

[13:22] <tadzik> erm, tool idea

[13:23] <jnthn> tadzik: ah, you're after much more general bundling than just the fakeexecutable stuff. That *is* a bigger (and interesting) project :)

[13:24] <lizmat> afk&

[13:24] <tadzik> jnthn: oh, yes :) I mean fakexecutables of Perl 6 programs, not Moar itself

[13:25] <FROGGS> tadzik: that's what it is about...

[13:25] <tadzik> so I'm confused

[13:26] <FROGGS> such an exe is a moarvm binary with some moarvm bytecode, that gets run

[13:27] <FROGGS> like: perl6-m --target=mbc --output=mygame.moarvm mygame.pl && perl6-m -I. -Mmygame -e1

[13:27] <FROGGS> (just in one binary)

[13:28] <FROGGS> I also have made moarvm+nqp+rakudo branches that can pack bytecode into binaries, and run them...

[13:28] <FROGGS> though, the binaries that were created still needed a -e1 :/

[13:29] <jnthn> I guess tadzik is intersted in having dependent modules packaged in there too.

[13:29] <FROGGS> so you had a mygame.exe, but you'd get a REPL when you just exec it... but it started your game with -e1

[13:29] <jnthn> Though maybe you already did that :)

[13:30] <FROGGS> jnthn: yes, my branch allows to include other modules, and packs these CUs in the binary too

[13:30] <tadzik> ok, so what are missing, what's a blocker?

[13:30] <FROGGS> though, you'd had to supply the deps in load order :o)

[13:30] <FROGGS> tadzik: the -e problem and polishing

[13:30] <FROGGS> tadzik: but since you are Polish :P

[13:30] <FROGGS> ...

[13:30] <tadzik> :P

[13:32] <FROGGS> https://github.com/MoarVM/MoarVM/compare/execname#diff-2

[13:33] <FROGGS> https://github.com/perl6/nqp/compare/execname

[13:34] <tadzik> hmm could you not add the -e1 into raw_clargs?

[13:36] *** kaare_ left
[13:36] <FROGGS> I tried something like that...

[13:37] <FROGGS> ahh, we'd have to buindle the setting and the module loader, and make sure they get registered as "was already loaded"

[13:37] <FROGGS> which might be tricky because we're checking a hash in the moduleloader if it contains a key

[13:39] <JimmyZ> FROGGS: didn't you have branch to review? looks like you never pust it?

[13:39] <JimmyZ> *push

[13:39] *** kjs_ joined
[13:40] <jnthn> *pusht :)

[13:42] * masak .oO( –ø—É—à )

[13:44] <jnthn> .oO( When I need to send my commits a really long way, I use a git –ø—É—à–∫–∞ )

[13:45] <yakudza> .oO( –ø–µ—Ä–ª )

[13:46] * masak .oO( –ø–µ—Ä–ª -—ç )

[13:47] *** spider-mario joined
[13:48] <tadzik> masak: you might enjoy http://www.reddit.com/r/keming/top/ :)

[13:49] <FROGGS> JimmyZ: this is up for review/discussion: https://github.com/MoarVM/MoarVM/compare/sepsh

[13:49] <masak> fsvo "enjoy", yes :)

[13:49] <moritz> jnthn: fwiw sub f(Str(Any) $x) { say $x.WHAT }; f 42  say (Str), but   sub f(Str(Any) $x) { $x }; say f(42).WHAT  says (Int)

[13:49] <FROGGS> JimmyZ: but I have no brain left over for that these days :o)

[13:49] *** grondilu left
[13:49] * masak .oO( some people are BOM )

[13:50] <jnthn> moritz: Ooh, put it in a test!!

[13:50] <moritz> jnthn: upcoming!

[13:50] <jnthn> m: sub f(Any $x as Str) { $x }; say f(42).WHAT

[13:50] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Int)‚ê§¬ª

[13:51] <jnthn> There's nothing new under the sun... :)

[13:51] <jnthn> That'll be the optimizer deciding to inline and not noticing the coercion, I'll bet

[13:51] <dalek> roast: 7d87341 | moritz++ | S12-coercion/coercion-types.t:

[13:51] <dalek> roast: Add basic tests for coercion types

[13:51] <dalek> roast: review: https://github.com/perl6/roast/commit/7d87341769

[13:51] <moritz> jnthn: there you go, 15 tests for your convenience

[13:51] <jnthn> moritz++

[13:52] <moritz> including coercing to an enum, and coercing the invocant of a method to a subclass

[13:52] <moritz> and checks for coercion methods that don't return what they are supposed to 

[13:53] *** bjz joined
[13:55] * moritz felt particularly evil

[13:58] *** Rounin left
[13:59] * FROGGS .oO( MUHAHHAHAA! )

[14:04] <psch> hrm, this is confusing :/

[14:05] <psch> the test case with the empty string in Grammar::Profiler::Simple causes the next case to lose .orig when going from TOP to line

[14:06] *** anaeem1 left
[14:06] *** anaeem1 joined
[14:11] *** anaeem1 left
[14:11] *** anaeem1 joined
[14:12] *** kaleem left
[14:13] *** anaeem1 left
[14:13] <FROGGS> weird

[14:13] *** anaeem1 joined
[14:15] *** dayangkun joined
[14:16] *** dayangkun left
[14:18] *** anaeem1 left
[14:30] *** skids joined
[14:31] <gtodd> wow people really lay on the madness in those HN threads <boggle> ... 8-|

[14:33] <gtodd> perl5's brand  is "well established" I guess :-P 

[14:35] <gtodd> for p6 though do comments like these: http://pmthium.com/2014/10/apw2014/#comment-1033040  merit a response ?

[14:37] *** adu joined
[14:39] <gtodd> those comments suggest that the way perl5 flattens things is a pain point that causes people to "recoil in horror" :-\ ...

[14:40] *** |Tux| joined
[14:40] *** TuxCM left
[14:40] <moritz> well, it's a valid point to ask whether the new rules are still too complicated, or full of surprise

[14:43] <gtodd> true .... I don't know enough about other languages to understand the debate ... I generally like how perl5 takes care of it  and expect p6 will do consistent magic too :-) 

[14:44] <gtodd> ... not being able or having to call @array.flatten($INT_FOR_SOME_LEVEL) on as in ruby doesn't seem like a deal breaker but ...

[14:47] <FROGGS> gtodd: what moritz said; it is a very good comment, and the points he/she made are valid

[14:47] <lizmat> jnthn: how would you describe  what's being done in the 6pe branch?

[14:47] <FROGGS> what *I* take from this comment is: the rules when something does (not) flatten should be simple and clear in the end

[14:48] <adu> gtodd: I think the concept of an iterator makes so much more sense than "flattening"

[14:48] <FROGGS> and making things flatten (or not) should be fairly easy, but that might be already try-ish

[14:50] <gtodd> ++ to consistent rules ... but yes some things should always be flat and some errm not 

[14:50] <jnthn> lizmat: 6pe = 6model parametric extensions. It's a small extension to the 6model primitives (that all of our type and OO support is built using) that support parameterized types, including interning of them across compilation units; our inability to do so to date has led to various issues with typed arrays/hashes especially in a pre-compilation setting.

[14:50] <gtodd> I guess I'm mixing in the perl5 criticism from HN :-D ...

[14:51] *** jluis left
[14:51] <jnthn> lizmat: The 6pe branches in MoarVM and NQP focus around providing the handful of new nqp::ops that expose this, along with the serialization improvements to go with it.

[14:51] <lizmat> jnthn++  # making writing the P6W a lot easier

[14:52] <jnthn> lizmat: Meanwhile, the 6pe-mop branch in Rakudo is about exploiting these new things to get nice Perl 6 improvements; so far, mixin interning and coercion types, soon typed data structures, and a little later native arrays.

[14:52] <adu> what's P6W?

[14:53] <donaldh> perl 6 weekly

[14:53] <donaldh> https://p6weekly.wordpress.com/

[14:53] <jnthn> lizmat: Mostly, I'm happy that with one mechanism I seem to be on the path to solving a bunch of long-standing implementation weaknesses.

[14:54] <PerlJam> jnthn++

[14:55] *** rurban left
[14:55] *** [Sno] left
[14:57] <gtodd> donaldh: lizmat:  the last p6weekly headline was fun ... delayed already :-D  

[14:58] *** jluis joined
[14:59] <moritz> what's "mixin interning"?

[14:59] *** kaleem joined
[15:01] <jnthn> moritz: Given $obj is C, "$obj does SomeRole" would compute a new type C+{SomeRole} on every mixin (which would later be subject to GC)

[15:01] <PerlJam> .oO(  mixins get training over the summer before they become full-fledged?  )

[15:01] <jnthn> moritz: Now we generate such a type once and re-use it.

[15:02] *** brrt joined
[15:02] <jnthn> Before that was a bit fraught because it could interact badly with serialization stuff.

[15:03] <moritz> jnthn: so now it's serialized, and when multiple precompiled compunits have the same thing, they somehow get merged or identified as being identical?

[15:03] <jnthn> moritz: Yes, that's the idea.

[15:03] <brrt> \o #perl6

[15:03] <brrt> wrt to the gsoc-ideas thingy, i second that more spesh / jit work would be good

[15:03] <jnthn> This is also meant to deal with the "expected Array[Str] but got Array[Str]" horrors we sometimes see.

[15:04] <brrt> i'm still hoping someone more competent than myself will show up

[15:04] <brrt> there is still a *lot* to do, for instance - trace (JIT) compilation

[15:04] <jnthn> brrt: I'm hoping you will show up, since your competence last year proved pretty great :)

[15:05] <brrt> actually, in our context, that would be trace spesh compilation

[15:05] <gtodd> lizmat: you've probably already mentioned this in a P6W or it has appeared elsewhere ... but sillymoose (?)  made a nice neat summary intro on [How to create a grammar in Perl 6]( http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6 )

[15:05] <jnthn> I'm not sure that's a good GSoC project, but yeah...

[15:05] <brrt> while flattered, i'd also argue that I can't believe nobody *more* competent could  show up

[15:06] <lizmat> gtodd: had missed that, thanks!

[15:06] <jnthn> One very cool thing we'll be in a place to do come GSoC is building the stuff to JIT @native-int-a >>+<< @native-int-b into SIMD ops; similar for native num stuff.

[15:06] <gtodd> sort of a quicker beginner version of the talks on grammars by masak jnth etc etc

[15:07] <jnthn> Which could make a cute GSoC project.

[15:07] *** silug left
[15:07] <jnthn> And it's quite self-contained, though rather stack-spanning.

[15:07] <Woodi> hallo today :)

[15:08] *** tinyblak_ left
[15:09] <Woodi> if 6.0 is comming then having NativeCall working for all cases would be nice or even required...

[15:12] <psch> https://gist.github.com/peschwa/79a3922f40f3f6343165 # this patch makes Grammar::Profiler::Simple work on jvm

[15:14] <psch> apparently there's a difference how the invocant for find_method and the found method is handled on moar and jvm

[15:14] <psch> *in

[15:14] <brrt> hmmm 

[15:14] <FROGGS> Woodi: join the party! /o/ - https://fosdem.org/2015/schedule/event/c_bindings_a_journey/

[15:14] <brrt> jnthn: that would be a very interesting one indeed

[15:15] <brrt> how do we implement this currently?

[15:15] *** kurahaupo left
[15:15] <FROGGS> brrt: you mean hyper ops in general?

[15:16] <brrt> yes

[15:16] <brrt> hmmm

[15:16] <FROGGS> brrt: look at rakudo/src/core/metaops.pm

[15:17] <FROGGS> rakudo/src/core/metaops.pm:221:sub METAOP_HYPER(\op, *%opt) {

[15:17] <Woodi> FROGGS: you mean NC is perfectly working now ?

[15:18] <FROGGS> Woodi: it works good enough to bind libxml2 for example

[15:18] <brrt> interesting :-)

[15:19] <FROGGS> Woodi: so it works in >90% of the cases I'd say...

[15:19] <jnthn> We'll want to do something more interesting on the native arrays, I think :)

[15:19] <psch> updated the gist, i'm not sure what that could mean... :)

[15:19] <Woodi> then I MUST give it some try again :)

[15:19] <jnthn> psch: I'm not sure what it means either, off hand :(

[15:19] <FROGGS> jnthn: and we want .malloc and .free on CPointers! :P

[15:20] <Woodi> CMS in Perl6 ? :)

[15:20] <lizmat> P6W: https://p6weekly.wordpress.com/?p=319&shareadraft=54be7220be90f   # please let me know of any comments, suggestions, omissions, errors

[15:21] <brrt> yeah.... can you multi on native arrays?

[15:21] <FROGGS> Woodi: look: https://github.com/FROGGS/p6-XML-LibXML/blob/master/lib/XML/LibXML/CStructs.pm and https://github.com/FROGGS/p6-XML-LibXML/blob/master/lib/XML/LibXML/Document.pm 

[15:21] <skids> Being able to pass Buf[uint8] or equivalent in/out of NC would be huge for me, personally.

[15:21] <FROGGS> Woodi: also we don't need setters: https://github.com/FROGGS/p6-XML-LibXML/blob/master/t/03doc.t#L33

[15:22] <brrt> the most interesting possibility, imho, would be some form of loop-to-vector transformation in spesh, 

[15:22] <brrt> but also the hardest (by far) 

[15:24] <Woodi> FROGGS: for sure I will use this as modern NC cheat sheet :)

[15:24] *** FROGGS[mobile] joined
[15:24] <FROGGS> :o)

[15:24] *** FROGGS left
[15:24] <jnthn> lizmat: "spotted that there was no method version of substr-rw"

[15:24] <jnthn> lizmat: Seems the name of whoever did it is missing

[15:24] <lizmat> ah

[15:25] <brrt> (people are going to love the subtle distinction between hashes and object hashes)

[15:25] <lizmat> jnthn: fixed

[15:25] <lizmat> brrt: there shouldn't be any

[15:25] <lizmat> but we must atm because of performance

[15:26] <jnthn> lizmat: Another benefit 2015.02 will get is 10x faster mixins, and another MB off CORE.setting size, and further memory savings.

[15:26] <jnthn> (from my work)

[15:26] <jnthn> lizmat: Also don't forget donaldh++'s awesome patch that got another chunk off CORE.setting and thus a bit more startup time and memory saved :)

[15:26] <brrt> jnthn, 6pe ops, are they implemented at moarvm level? and if so do they need jitting?

[15:27] <brrt> i assume the answer to both is 'yes'

[15:27] <jnthn> brrt: Yes, no. (more)

[15:27] <jnthn> Well, sort of

[15:27] <brrt> :-)

[15:27] <jnthn> 3 of the 5 will spesh into spesh slots or constants.

[15:27] <psch> i think the result in my gist means either 1) WHICH is somewhat unreliable on jvm or 2) jvm creates new Cursors where moar doesn't

[15:28] <jnthn> So they don't ever reach the JIT

[15:28] <jnthn> The other 2 can JIT into C function calls; they're not hot path.

[15:28] *** kurahaupo joined
[15:28] <brrt> very well

[15:28] <brrt> this is why a weekly is awesome. lizmat++

[15:30] <psch> lizmat++ # p6w

[15:30] <psch> lizmat: "between about 3 times faster"

[15:31] <donaldh> lizmat: made it between about 3 times as fast # doesn't need 'between'

[15:31] <donaldh> touche

[15:32] <jnthn> lizmat: Furtermore => Furthermore

[15:32] <jnthn> .oO( is an even longer saussage frankfurther? )

[15:33] <lizmat> :-)  donaldh++ jnthn++   # proofreading and finding mistakes

[15:34] *** kaleem left
[15:34] <donaldh> lizmat: this optimization (...), this change

[15:35] <donaldh> you could maybe drop "this optimization" and the parens

[15:35] <donaldh> or , this change

[15:36] <lizmat> changed it a bit

[15:37] *** booly-yam-6137 left
[15:38] <donaldh> lizmat: nasty bold glitch in last para

[15:39] <lizmat> fixed

[15:39] <donaldh> for ^1000 para now looks great

[15:40] * donaldh also shaved 180k off CORE.setting.class by optimizing bytecodes for integer constants 0..5

[15:41] <jnthn> :D

[15:41] <jnthn> That's...a lot more than I'd have guessed.

[15:42] <donaldh> presumably a performance improvement to but too small to measure reliably

[15:42] * jnthn wonders if Moar should get iconst64_0, iconst64_1, etc. :)

[15:42] *** yeahnoob left
[15:43] *** booly-yam-6137 joined
[15:44] <donaldh> I noticed a lot of them in the init code. getCallSites alone dropped from 17333  to 14696 codez

[15:44] <jnthn> Ah

[15:44] <jnthn> Yeah, we don't have that kind of init code in Moar, but get to store it statically instead.

[15:45] *** mr-foobar joined
[15:47] <lizmat> https://p6weekly.wordpress.com/2015/01/20/2015-03-gathering-up-steam-again/  # it's published

[15:47] <jnthn> lizmat++

[15:48] <donaldh> lizmat++

[15:49] <lizmat> afk&

[15:50] *** [Sno] joined
[15:51] *** rurban joined
[15:55] <JimmyZ> I saw a weird codegen: my str $s = 'arg'; nqp:say('hello' ~ $s ~ 'world');   the first  '~' gens concat_s and second '~' calls &infix:<~>'

[15:56] <JimmyZ> s/str/Str/ or nqp:say("hello $s world") is different codegens also.

[15:56] * JimmyZ saw it in rakudo

[15:57] *** adu left
[15:59] *** booly-yam-6137 left
[16:00] *** anaeem1 joined
[16:04] *** anaeem1 left
[16:04] *** dakkar joined
[16:08] *** gfldex joined
[16:11] *** risou left
[16:17] *** jluis left
[16:18] *** treehug88 joined
[16:28] <flussence> morning, *

[16:28] <dalek> roast: 8583f15 | (Anthony Parsons)++ | S12-coercion/coercion-types.t:

[16:28] <dalek> roast: Fix a 1-char typo

[16:28] <dalek> roast: review: https://github.com/perl6/roast/commit/8583f155d4

[16:33] *** brrt left
[16:35] *** zakharyas left
[16:35] <moritz> \o flussence 

[16:36] *** Rounin joined
[16:42] <dalek> nqp: 936b383 | (ugexe (Nick Logan))++ | docs/ops.markdown:

[16:42] <dalek> nqp: documents nqp::push return value not defined

[16:42] <dalek> nqp: 

[16:42] <dalek> nqp: In the quest for documenting the return value for moarvm nqp::push some

[16:42] <dalek> nqp: discrepancies are discovered:

[16:42] <dalek> nqp: TimToady> I guess moar is just returning the 2

[16:42] <dalek> nqp: > which is kinda not what I'd expect

[16:42] <dalek> nqp: > I don't see anywhere in nqp where the value is used, actually

[16:42] <dalek> nqp: > er, in nom/src I should say

[16:42] <dalek> nqp: > might be best to say the return value is currently undefined

[16:42] <dalek> nqp: 

[16:42] <dalek> nqp: Also: $typos--

[16:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/936b38358c

[16:42] <dalek> nqp: e9fef5b | moritz++ | docs/ops.markdown:

[16:42] <dalek> nqp: Merge pull request #202 from ugexe/ugexe-docs

[16:42] <dalek> nqp: 

[16:42] <dalek> nqp: documents nqp::push return value not defined

[16:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e9fef5b060

[16:43] *** Mso150 joined
[16:46] *** kaleem joined
[16:46] *** kaleem left
[16:52] *** FROGGS joined
[16:53] *** anaeem1 joined
[16:54] *** donaldh left
[16:58] *** mvuets left
[17:00] *** eternaleye joined
[17:00] *** booly-yam-6137 joined
[17:01] *** jluis_ joined
[17:01] *** kjs_ left
[17:05] <dalek> mu: 9cdd634 | timotimo++ | misc/gsoc-2015/ideas.md:

[17:05] <dalek> mu: propose two nativecall based projects: gobject and OpenGL

[17:05] <dalek> mu: review: https://github.com/perl6/mu/commit/9cdd634c51

[17:09] <dalek> mu: 886c5e0 | jnthn++ | misc/gsoc-2015/ideas.md:

[17:09] <dalek> mu: Suggest JIT of native calls project

[17:09] <dalek> mu: review: https://github.com/perl6/mu/commit/886c5e0cc4

[17:14] *** denis_boyun left
[17:17] <pyrimidine> lizmat++ #p6weekly

[17:18] <pyrimidine> nice way of keeping up to date (w/o having to backlog :)

[17:18] <jdv79> lizmat++ #ditto. very nice.

[17:21] *** Otterpocket joined
[17:22] <Otterpocket> Hello, How do you list available  methods for an Object?

[17:23] <moritz> Otterpocket: with .^methods. Compare http://doc.perl6.org/routine/methods

[17:23] *** telex left
[17:24] *** abraxxa left
[17:24] *** telex joined
[17:25] <timotimo> oh yes, jitting native calls

[17:25] <Otterpocket> moritz: Thaks

[17:25] *** FROGGS[mobile] left
[17:25] <Otterpocket> s/Thaks/Thanks

[17:26] <timotimo> jnthn: is 6pe going to be an important piece in the nativecall jitting puzzle?

[17:26] <jnthn> timotimo: No, seems mostly orthogonal to me.

[17:27] <flussence> hm, we have a :(), and now a :{}... is there :[] too?

[17:28] <TimToady> gotta hold something in reserve :[]

[17:28] <timotimo> well, we.ll need at least some way to have the values that are inside the MVMNativeCall object available at jit time ...

[17:29] <moritz> :[] would be an array literal that infers its type from the contents

[17:29] <moritz> s/would/could/

[17:30] <moritz> :[1, 2, 3] ~~ Array[Int]

[17:30] <timotimo> strong/static typers want the colon. timtoady gets the colon.

[17:30] <PerlJam> moritz: :[ 1, "foo" ] ~~ Array[Any]  ?

[17:31] <moritz> PerlJam: Array[Cool]

[17:31] <moritz> PerlJam: since that's the tightes common subtype of all elements

[17:31] <PerlJam> that inference sounds expensive

[17:32] <moritz> not so much

[17:32] <moritz> you simply start from $array[0].WHAT

[17:32] <TimToady> if everything generating values returns Int, you don't have to check anything

[17:32] <TimToady> except at compile time

[17:32] <moritz> and if an alement doesn't type-check against that, you follow the chain of parent types until you find something that matches

[17:33] <jnthn> But then somebody will ask for it to check roles too... :)

[17:33] *** kjs_ joined
[17:33] <moritz> :-)

[17:34] <jnthn> Back in an hour or so... :)

[17:34] <timotimo> bon appetit, jnthn 

[17:35] *** Otterpocket left
[17:38] *** PerlJam left
[17:43] *** rmgk_ joined
[17:43] *** rmgk is now known as Guest55723

[17:43] *** rmgk_ is now known as rmgk

[17:43] *** Kristien joined
[17:46] <arnsholt> I guess :[] as type-inferring list isn't too parallel to :{} as more general hash

[17:46] *** PerlJam joined
[17:46] <arnsholt> It's an alluring thing to do, but perhaps not quite wise. Especially since the type-inference rabbit hole is kinda deep

[17:47] *** Guest55723 left
[17:49] *** dwarring joined
[17:49] <moritz> arnsholt: I agree

[17:50] <TimToady> perhaps, as with hypers, we just want to make an easy way to hint it explicitly

[17:52] <Kristien> Do subsets allow arbitrary predicates?

[17:52] <TimToady> yes

[17:52] <TimToady> at least, semantically

[17:53] <TimToady> it's just smartmatching, which allows closures, which allow anything

[17:54] <TimToady> though the brush-teeth predicate might be a bit of a stretch

[17:54] <Kristien> subset A of Int where * > 1; subset B of Int where * > 2;

[17:54] <Kristien> I was thinking of that, but then B isn't a subtype of A right?

[17:54] <Kristien> That'd require solving the halting problem.

[17:54] <TimToady> no, halting

[17:54] <TimToady> yeha

[17:55] <TimToady> *yeah, even

[17:55] <TimToady> "yeha" sounds like a cowboy...

[17:55] <Kristien> Ah, ok. :) Just wondering. I've seen a similar feature in F* but in that language you're restricted to the operations you can perform.

[17:55] <TimToady> of course, the halting is only non-solvable in general; lots of specific cases can be solved

[17:56] <TimToady> *problem

[17:56] <TimToady> but then you're into the sort of inferencing that requires the programmer to be just about as smart as the inferencer

[17:56] <Kristien> yeah :P

[17:57] <TimToady> any default type inferencer we put into Perl 6 will not require everyone to be a genius

[17:57] <TimToady> though of course if you declare at the top that you are genius, then bombs away

[17:58] <TimToady> I guess that would be a mad, evil genius in that case

[17:58] <Kristien> I'm kinda in the world of language design and I've been thinking about this specific problem for weeks.

[17:59] *** dakkar left
[17:59] * TimToady recommends the Bear of Very Little Brain approach hereabouts

[18:00] * Kristien should give Perl 6 a try.

[18:01] <TimToady> rosettacode.org might be a good entrypoint if you're into comparative linguistics

[18:01] <TimToady> though arguably some of the RC examples are a bit on the show-offy side more than the show-howy side

[18:02] <TimToady> but folks here will be glad to answer questions

[18:02] <TimToady> 'course if you have language design neurons, you can probably read the design docs too...

[18:02] <TimToady> some of 'em make some amount of sense

[18:09] *** zakharyas joined
[18:12] <Kristien> Rosetta Code is always fun to read.

[18:13] * sjn has looked a little at rosettacode.org

[18:13] *** Hor|zon left
[18:13] <sjn> is there a "best of rosettacode.org" page anywhere?

[18:13] *** pecastro left
[18:14] * sjn wouldn't mind a #perl6 version of that

[18:14] <TimToady> if you want it badly enough, it'll happen :)

[18:15] <sjn> yay! :)

[18:15] *** virtualsue left
[18:16] *** jluis_ left
[18:21] <TimToady> errands &

[18:22] <Kristien> Well, I'm off. Thanks for the help!

[18:22] *** Kristien left
[18:25] *** kjs_ left
[18:27] *** kjs_ joined
[18:33] *** FROGGS_ joined
[18:36] *** FROGGS left
[18:39] *** jluis_ joined
[18:46] *** Kristien joined
[18:48] *** jluis_ left
[18:49] *** jluis_ joined
[18:50] *** Mso150_n joined
[18:51] *** Mso150 left
[18:55] *** adu joined
[19:02] *** booly-yam-6137 left
[19:04] *** tgt joined
[19:10] *** Hor|zon joined
[19:14] *** Hor|zon left
[19:15] <dalek> features: 5d95652 | moritz++ | features.json:

[19:15] <dalek> features: Point synopses links to design.perl6.org

[19:15] <dalek> features: review: https://github.com/perl6/features/commit/5d956520b8

[19:19] *** rindolf left
[19:22] <dalek> mu: 829a6a1 | moritz++ | util/Text-SmartLinks/lib/Text/SmartLinks.pm:

[19:22] <dalek> mu: Fix / remove some links

[19:22] <dalek> mu: review: https://github.com/perl6/mu/commit/829a6a13f5

[19:25] <dalek> perl6.org: 2fd2e2b | moritz++ | source/archive/doc/design/syn/S (13 files):

[19:25] <dalek> perl6.org: Fix link texts in archive

[19:25] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/2fd2e2b3db

[19:26] <dalek> doc: 7f6e215 | moritz++ | lib/Language/modules.pod:

[19:26] <dalek> doc: Move perlcabal.org links to design.perl6.org

[19:26] <dalek> doc: review: https://github.com/perl6/doc/commit/7f6e2150f9

[19:27] *** Hor|zon joined
[19:29] <dalek> tablets: 1e7c1d5 | moritz++ | docs/index.txt:

[19:29] <dalek> tablets: Move perlcabal.org links to design.perl6.org

[19:29] <dalek> tablets: review: https://github.com/perl6/tablets/commit/1e7c1d55ea

[19:39] *** Kristien left
[19:46] *** rurban left
[19:48] <FROGGS_> m: say q:to'EOX';‚ê§<?xml version="1.0" encoding="iso-8859-1"?>‚ê§<a><b/></a>‚ê§EOX‚ê§# what am I doing wrong?

[19:48] <camelia> rakudo-moar f9cb17: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized adverb: :to'EOX‚ê§at /tmp/Jeaaha5KQO:1‚ê§------> [32msay q:to'EOX[33m‚èè[31m';[0m‚ê§Couldn't find terminator '‚ê§at /tmp/Jeaaha5KQO:5‚ê§------> [32m# what am I doing wrong?[33m‚èè[31m<EOL>[0m‚ê§‚ê§¬ª

[19:48] <FROGGS_> ohh, the single quotes... (works with slashes)

[19:50] <geekosaur> doesn't t need to ... that, yes

[19:50] <geekosaur> or <>

[19:50] <geekosaur> it's pair syntax, isn't it?

[19:51] <FROGGS_> m: say (:foo/bar/)

[19:51] <camelia> rakudo-moar f9cb17: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BoWZdgubuk‚ê§Bogus statement‚ê§at /tmp/BoWZdgubuk:1‚ê§------> [32msay (:foo/bar/[33m‚èè[31m)[0m‚ê§    expecting any of:‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§¬ª

[19:51] <FROGGS_> no, that's not quite pair syntax

[19:51] <psch> it's adverb syntax, isn't it

[19:51] * psch .oO( that's what you get for wanting all those colons... )

[19:51] <FROGGS_> I thought that that would be the same

[19:51] <geekosaur> right, adverb syntax

[19:52] <geekosaur> I am now remembering it's not *quite* pair syntax

[19:52] <FROGGS_> because... an adverb is a pair basically

[19:53] *** Rounin left
[19:53] <psch> yeah, i think an adverb is a colonpair, but with a predefined set of possible keys..?

[19:54] <FROGGS_> and with different delims

[19:54] <moritz> not a predefined set of possible keys

[19:54] <FROGGS_> right, you can pass anything

[19:54] <psch> m: say { a => 1 } :exists<False>

[19:54] <camelia> rakudo-moar f9cb17: OUTPUT¬´Unexpected named parameter 'exists' passed‚ê§  in sub circumfix:<{ }> at src/gen/m-CORE.setting:11045‚ê§  in block <unit> at /tmp/85BJfv85yy:1‚ê§‚ê§¬ª

[19:54] <psch> m: say { a => 1 }:exists<False>

[19:54] <camelia> rakudo-moar f9cb17: OUTPUT¬´Unexpected named parameter 'exists' passed‚ê§  in sub circumfix:<{ }> at src/gen/m-CORE.setting:11045‚ê§  in block <unit> at /tmp/ypVwNxJPF5:1‚ê§‚ê§¬ª

[19:54] <moritz> m: sub infix:<+>($a, $b, *%a) { say %a.perl; $a + $b }; say 1 + 2 :flurb

[19:54] <psch> m: say ({ a => 1 }:exists<False>)

[19:55] <psch> :s

[19:55] <FROGGS_> BOOM

[19:55] <camelia> rakudo-moar f9cb17: OUTPUT¬´(timeout)("flurb" => Bool::True).hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().hash‚ê§().has‚Ä¶¬ª

[19:55] <camelia> rakudo-moar f9cb17: OUTPUT¬´Unexpected named parameter 'exists' passed‚ê§  in sub circumfix:<{ }> at src/gen/m-CORE.setting:11045‚ê§  in block <unit> at /tmp/3xlg0IByOw:1‚ê§‚ê§¬ª

[19:55] <moritz> m: sub infix:<+>($a, $b, *%a) { say %a.perl; 42 }; say 1 + 2 :flurb

[19:55] <camelia> rakudo-moar f9cb17: OUTPUT¬´("flurb" => Bool::True).hash‚ê§42‚ê§¬ª

[19:55] *** kjs_ left
[19:55] <psch> oh, so the anon hash doesn't have :exists?

[19:55] <FROGGS_> psch: just because something complains about an unexpected param it is still an adverb or pair

[19:55] <psch> m: my %h = a => 1; say %h:exists<False>

[19:55] <camelia> rakudo-moar f9cb17: OUTPUT¬´a => 1‚ê§¬ª

[19:56] <psch> m: my %h = a => 1; say %h:exists<b>

[19:56] <camelia> rakudo-moar f9cb17: OUTPUT¬´a => 1‚ê§¬ª

[19:56] <psch> so every adverb is a pair

[19:56] <moritz> http://design.perl6.org/S02.html#Adverbial_Pair_forms

[19:57] <psch> and adverbs to function are actually named parameters

[19:57] <FROGGS_> m: say q:to/foo/‚ê§so why is that allowed then?‚ê§foo‚ê§

[19:57] <camelia> rakudo-moar f9cb17: OUTPUT¬´so why is that allowed then?‚ê§‚ê§¬ª

[19:57] *** fhelmberger left
[19:57] <psch> say q to => 1/foo/‚ê§and this is isn't?‚ê§foo‚ê§

[19:58] <psch> i have a hunch, but that's mostly "it looks really wierd"

[19:58] <psch> *weird

[19:58] <geekosaur> try a m: prefix :p

[19:59] <FROGGS_> no, I understand that q is not a subroutine, but allowing slashes there to make it look less like an adverb/pair is weird

[19:59] <psch> oh right, q isn't a sub

[20:01] * geekosaur wonders if that is parsed as :to without a parameter, then /foo/ is parsed the same as in q/foo/, then ???

[20:01] * FROGGS_ now renames xmlDoc.parse-str to xmlDoc.parse... the -str does not make sense in the year 2015

[20:01] *** Kristien joined
[20:02] <FROGGS_> geekosaur: no, then it would not parse the text as a text

[20:02] <FROGGS_> or string, even

[20:06] *** zakharyas left
[20:07] *** kjs_ joined
[20:14] * TimToady points out that :exists<False> is equivalent to :exists('False'), not :exists(False)

[20:15] <TimToady> m: say so :exists<False>.value

[20:15] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§¬ª

[20:15] <jnthn> That was a long hour. :)

[20:16] *** Mso150_n_s joined
[20:16] <TimToady> is it twice as long as an hour, or twice as long as a short hour?

[20:16] *** Mso150_n left
[20:16] <TimToady> and do you support long long hours?

[20:17] <geekosaur> long double hour;

[20:17] <psch> right, < > stringifies

[20:17] <psch> also :exists works differently than i used it anyway, doesn't it..?

[20:17] <psch> m: my %h = a => 1; say %h<a>:exists, %h<b>:exists

[20:17] <camelia> rakudo-moar f9cb17: OUTPUT¬´TrueFalse‚ê§¬ª

[20:18] <psch> m: my %h = a => 1; say %h<a>:exists(False), %h<b>:exists

[20:18] <camelia> rakudo-moar f9cb17: OUTPUT¬´FalseFalse‚ê§¬ª

[20:18] <psch> and :exists(False) is :!exists

[20:18] <psch> i think that's making sense again... :)

[20:19] *** darutoko left
[20:19] <psch> re: Grammar::Profiler::Simple, i've noticed that jvm uses !cursor_start_all and moar uses !cursor_start and !shared

[20:19] *** jluis_ left
[20:19] <psch> i've also found out that $!restart in !cursor_start_all on jvm is always set

[20:20] <psch> er, defined that is.  i probably should also have output the value...

[20:20] <psch> the different methods are probably an implementation detail, and i don't think i've learned anything significant that can point at where this all goes wrong

[20:21] <dalek> roast: b676ed8 | usev6++ | S12-class/basic.t:

[20:21] <dalek> roast: Add test for RT #72338

[20:21] <dalek> roast: review: https://github.com/perl6/roast/commit/b676ed8106

[20:21] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=72338

[20:25] <FROGGS_> m: say v1.2 < v2.3 # I still don't like it

[20:25] <camelia> rakudo-moar f9cb17: OUTPUT¬´Cannot call 'Real'; none of these signatures match:‚ê§:(Mu:U \v: *%_)‚ê§  in sub infix:<<> at src/gen/m-CORE.setting:4746‚ê§  in block <unit> at /tmp/VWw1rYRXyh:1‚ê§‚ê§¬ª

[20:26] *** bjz_ joined
[20:26] <TimToady> that shouldn't be getting anywhere near Real

[20:26] <FROGGS_> that's not very human friendly: if XML::LibXML.parser-version cmp v2.6.20 == Less {

[20:26] <TimToady> oh, wait...

[20:27] <TimToady> m: say v1.2 before v2.3

[20:27] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§¬ª

[20:27] <FROGGS_> hmmm

[20:27] <TimToady> < forces numeric context

[20:27] <FROGGS_> okay

[20:27] <FROGGS_> I can live with that

[20:27] <TimToady> but it could perhaps be more awesomely blowuppy

[20:27] <FROGGS_> that even reads well: if XML::LibXML.parser-version before v2.6.20 {

[20:28] <Kristien> neat

[20:28] <moritz> one could suspect a linguist was involved :-)

[20:28] <TimToady> cmp linguistics is fun

[20:29] <FROGGS_> that's more or less a joke, isnt it?

[20:29] *** bjz left
[20:29] <TimToady> it's the same as a joke

[20:30] <TimToady> sorry for pulling your leg

[20:30] <FROGGS_> dang, now the puns increase again

[20:30] <TimToady> <=> .oO(drat that boy)

[20:31] <FROGGS_> for the greater good?

[20:31] <TimToady> this object is fully functional

[20:32] <TimToady> but they all lived happily ever after

[20:35] <TimToady> hopefully the new trilogy will explore the More side of the quality scale, unlike the prequels, which explored the Less side

[20:36] <Kristien> 1 & 2 & 3 < 4 & 5 & 6

[20:36] <TimToady> m: say so 1 & 2 & 3 < 4 & 5 & 6

[20:36] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§¬ª

[20:36] <Kristien> Half-Life 3 confirmed.

[20:37] *** smls_ joined
[20:39] <smls_> TimToady: Did you consider using  {: ... }  instead of  :{ ... }  for object hash literals?

[20:39] <smls_> For symmetry with the semicolon trick for forcing braces to be parsed as a block:

[20:39] <smls_> m: say .WHAT for { a => 1 }, {; a => 1 }

[20:39] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[20:39] <TimToady> which I despise

[20:39] <smls_> oh?

[20:39] <PerlJam> also sounds like a typo waiting to confuse

[20:39] <moritz> well, everybody wanted the bracket :-)

[20:41] <TimToady> and then how would you parse {::foo} ?

[20:41] <smls_> well, the space after  {:  could be mandatory...

[20:41] <TimToady> m: say .WHAT for { a => 1 }, { a => 1; }

[20:41] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Hash)‚ê§¬ª

[20:41] <TimToady> to my mind, that's a bug

[20:42] <gtodd> can I introspect and find out if something "is Iterable"?  (which is a sort of "role"?)  or do I just get back a type to check

[20:42] <TimToady> m: say .WHAT for { a => 1 }, { return a => 1; }  # much clearer

[20:42] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[20:42] <TimToady> well, except you can't use returnthere

[20:42] <TimToady> m: say .WHAT for { a => 1 }, { leave a => 1; }  # much clearer

[20:42] <camelia> rakudo-moar f9cb17: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CJV7G0dk7o‚ê§Undeclared routine:‚ê§    leave used at line 1‚ê§‚ê§¬ª

[20:42] <TimToady> and leave is NYI

[20:42] <gtodd> m:  if  <q w e r t y> ~~ Parcel { say "whee"}

[20:42] <camelia> rakudo-moar f9cb17: OUTPUT¬´whee‚ê§¬ª

[20:42] <TimToady> m: say .WHAT for { a => 1 }, { do a => 1; }  # much clearer

[20:42] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[20:43] <gtodd> m: if  [<q w e r t y>] ~~ Array { say "not a Parcel but still whee"}

[20:43] <camelia> rakudo-moar f9cb17: OUTPUT¬´not a Parcel but still whee‚ê§¬ª

[20:46] *** brrt joined
[20:46] <smls_> TimToady: If  { a => 1; }  would create a Block, then maybe  { a => $_ }  could be allowed to create a Hash?

[20:46] <smls_> Since it would be easy to disambuguate the block version

[20:46] <TimToady> nah, still too useful for map

[20:47] <moritz> but it would also violate the rule that final semicolons are optional

[20:47] <TimToady> m: say .WHAT for { a => 1 }, { (a => 1) }

[20:47] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[20:47] <TimToady> that works too

[20:47] <TimToady> but a leading null statement is just smelly to me

[20:48] <smls_> What's the best way to create a hash that reference the outside $_, in the current design?

[20:48] <TimToady> declare a different variable

[20:49] <TimToady> or use $OUTER::_

[20:50] <TimToady> or OUTER::<$_> if you prefer

[20:50] <TimToady> or go back in a time machine and put more brackets into ASCII

[20:51] <smls_> m: say { a => OUTER::<$_> }.WHAT

[20:51] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§¬ª

[20:51] <smls_> Hm, it works, though not exactly short/pretty.

[20:51] <TimToady> someones gotta lose the huffman war :)

[20:51] <jnthn> I'd really just arrange for the thing I want to not be in $_ :)

[20:51] <TimToady> that was my first solution :)

[20:52] <TimToady> or use %()

[20:53] <smls_> $%()  actually, if you want the equivalent thing

[20:53] <smls_> which has a dangerously high punctuation density... ;)

[20:53] <TimToady> really, there's no way, other than a time machine, to remove this WAT without installing the opposite but not equal WAT

[20:53] *** bjz_ left
[20:54] <PerlJam> The universe has some sort of conservations of WATs?

[20:54] <moritz> I fear it has

[20:54] <moritz> every DWIM comes with a WAT

[20:54] <moritz> as masak++ puts it

[20:55] <TimToady> but you can store many of them in a hazmat site

[20:56] * masak .oO( as hazmat++ puts it )

[20:56] <masak> m: say .WHAT for { a => 1; }

[20:56] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§¬ª

[20:56] <masak> TimToady: is bug, you say?

[20:56] <moritz> and then you forget them, and your grand children stumble over them and dig it up

[20:56] * masak submits rakudobug

[20:56] <smls_> I don't think "A block which contains nothing but a comma-separated list of Pair literals is parsed as a Hash" would be so bas as far as exceptions-to-the rules go

[20:57] <smls_> imo less surprising and difficult to remember than special-casing $_ in the parser

[20:57] *** zakharyas joined
[20:57] <skids> Also less likely to be accidentally done.

[20:57] <TimToady> disagree on the likelihodd

[20:57] <TimToady> *hood

[20:58] <TimToady> we were answering that faq all the time when it was the other way

[20:58] <TimToady> people run into the issume much less often these days

[20:58] <masak> yes, definitely.

[20:58] <TimToady> *issue, gah

[20:59] <TimToady> it's also not the sort of thing that propagates very far in your program before you catch it

[20:59] <smls_> I find that the current   "{} is parsed as a Block, unless the parser sees a $_ or ; etc"  trips me up on multiple levels

[20:59] * masak .oO( "issume" makes an iss of u an me )

[21:00] <smls_> For one thing, I'm not sure what counts as "sees a $_" exactly.

[21:00] <smls_> (As TimToady demonstrated, OUTER::<$_> does not count, for example.)

[21:00] <Kristien> sounds like a refactoring nightmare

[21:00] <smls_> Also, what the "etc" entails, and where ; must appear to make it a block, etc.

[21:00] <smls_> It doesn't seem like a single, consisten rule to me

[21:00] <masak> I will include this in the rakudobug, but if you're requesting a spec change, that really should go on github -- someone else is welcome to file that one.

[21:00] *** pecastro joined
[21:00] <smls_> But may it just needs to be explained better?

[21:02] *** kjs_ left
[21:02] <flussence> IMO a definition there that concentrates on "a block with a list of pairs as its only statement" would be the right direction... I *really* don't want Significant Trailing Semicolons to become a thing.

[21:03] * jnthn is also a bit surprised we want to make the trailing semi significant... :)

[21:03] <PerlJam> flussence: what about significant leading semicolons?

[21:03] <FROGGS_> star-m: use NativeCall; my CArray[Str] $foo.=new; $foo[0] = "bar"

[21:03] <camelia> star-m 2014.12: ( no output )

[21:03] <FROGGS_> star-m: use NativeCall; my CArray[Str] $foo.=new; $foo[0] = Str # jnthn?

[21:03] <camelia> star-m 2014.12: OUTPUT¬´(signal SEGV)¬ª

[21:03] *** Mso150_n_s left
[21:03] <flussence> does p5 make use of those? My memory's foggy there...

[21:03] <FROGGS_> jnthn: is that supposed to do that?

[21:04] <jnthn> FROGGS_: Uh, no...looks like a missing IS_CONCRETE somewhere in Moar. File a MoarVM bug on it, if you've a moemtn to do it.

[21:04] <masak> TimToady: S04:1687 is the go-to list for finding out whether something is a block or a hash. I don't find your case there with a single pair followed by a semicolon. nor do I find anything similar in the surrounding discussion.

[21:04] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1687

[21:04] <flussence> (I'm somewhat more okay with leading semicolons, because it's slightly more obvious something odd is going on)

[21:04] <jnthn> flussence: Leading means you're ending an (empty) statement and then the block doesn't have a single statement... :)

[21:05] <TimToady> well, we can leave the trailing semicolon out; I agree that you want something at the front

[21:05] <TimToady> but it should be 'leave' or 'do' or 'list'

[21:05] <masak> oh, ok. so, no rakudobug?

[21:05] <TimToady> nodnod

[21:05] * masak stands down

[21:06] <TimToady> m: say .WHAT for { a => 1 }, { Here-be-pairs: a => 1 }

[21:06] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[21:07] <TimToady> m: say .WHAT for { a => 1 }, { list a => 1 }

[21:07] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[21:07] <TimToady> m: say .WHAT for { a => 1 }, { item a => 1 }

[21:07] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[21:08] <PerlJam> too bad  &{ } has such baggage as it seems like it would make a good "this is code" disambiguator

[21:08] <TimToady> m: say .WHAT for { a => 1 }, { do a => 1 }

[21:08] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[21:08] *** zakharyas1 joined
[21:08] <FROGGS_> jnthn: I am attempting a fix first I guess

[21:08] <TimToady> that's probably the shortest practical one

[21:08] <FROGGS_> (because I need that working anyway)

[21:09] *** zakharyas left
[21:09] <jnthn> FROGGS_: OK; I'd look in CArray.c around where it marshals on bind_pos

[21:09] <TimToady> m: say .WHAT for { a => 1 }, { 1 R=> 'a' }

[21:09] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Hash)‚ê§(Block)‚ê§¬ª

[21:10] <FROGGS_> #3  0x00007ffff79bec51 in bind_pos (tc=0x603690, st=<optimized out>, root=0x7ffff6898c08, data=0x7ffff6898c20, index=0, value=..., kind=8) at src/6model/reprs/CArray.c:342

[21:11] <jnthn> hah :)

[21:11] *** kaare_ joined
[21:11] *** treehug88 left
[21:11] *** smls_ left
[21:11] <TimToady> cool!

[21:11] <TimToady> now that's a bug, I daresay

[21:11] <skids> .oO(ohnoes timtoady broke out the R again.  always trouble.)

[21:11] <flussence> .oO( I wonder if there's some obvious-in-hindsight way to make Block-Hashification rules be consistent with Str-Numification ones... so we can later point new people to it as a good example :)

[21:12] *** treehug88 joined
[21:13] <moritz> flussence: invent more brackets?

[21:13] *** kjs_ joined
[21:15] <flussence> aack, my altgr key is overused enough already!

[21:15] <TimToady> ¬ª√∂¬´ .oO(drat that boy)

[21:15] <timotimo> may i recommend something like neo-layout.org ?

[21:16] *** bjz joined
[21:19] * masak submits R=> rakudobug

[21:19] <TimToady> m: say 1 R=> 2

[21:19] <camelia> rakudo-moar f9cb17: OUTPUT¬´2 => 1‚ê§¬ª

[21:19] <TimToady> m: say { 1 R=> 2 }()

[21:19] <camelia> rakudo-moar f9cb17: OUTPUT¬´2 => 1‚ê§¬ª

[21:20] <jnthn> TimToady: How does the R=> ruling generalize? Z=> and X=> count too?

[21:20] *** [Sno] left
[21:20] <CurtisOvidPoe> m: my @primes := grep { .is-prime }, 1 .. Inf; say @primes[^10];

[21:20] <camelia> rakudo-moar f9cb17: OUTPUT¬´2 3 5 7 11 13 17 19 23 29‚ê§¬ª

[21:20] <CurtisOvidPoe> m: my @fib = 0, 1, * + * ... Inf; say @fib[^10];

[21:20] <camelia> rakudo-moar f9cb17: OUTPUT¬´0 1 1 2 3 5 8 13 21 34‚ê§¬ª

[21:20] <TimToady> m: say { 1 R=> 2 }.WHAT

[21:20] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Block)‚ê§¬ª

[21:20] *** [Sno] joined
[21:20] <arnsholt> star-p: use NativeCall; my CArray[Str] $foo.=new; $foo[0] = Str

[21:20] *** xfix left
[21:20] <camelia> star-p 2014.12: ( no output )

[21:20] <TimToady> m: say { 1 R=> 'a' }.WHAT

[21:20] <camelia> rakudo-moar f9cb17: OUTPUT¬´(Block)‚ê§¬ª

[21:20] <CurtisOvidPoe> Why does the first example require the binding operator, but the Fibonacci sequence doesn‚Äôt?

[21:21] <masak> waitwait, how come the error was reported by FROGGS, not camelia?

[21:21] <masak> I'm confused :)

[21:21] <arnsholt> FROGGS_: For the NativeCall SEGV thing, you should be able to compare with the Parrot equivalent code as well, since it works

[21:21] <masak> oh, FROGGS' error has nothing to do with R=>, I see.

[21:21] <TimToady> CurtisOvidPoe: grep isn't smart enough to notice its right side is infinite and convey that to its return value

[21:22] <FROGGS_> arnsholt: good point... though, I got a patch already

[21:22] <TimToady> that should get fixed in the GLR

[21:22] <arnsholt> FROGGS_: Cool. Just figured I'd point it out in case it wasn't obvious where the bug was

[21:22] <CurtisOvidPoe> TimToady: ‚Äúthe should get fixed in the GLR‚Äù. That was about the grep comment?

[21:22] <arnsholt> (Also, I wanted to make sure Parrot wasn't broken as well)

[21:23] <TimToady> CurtisOvidPoe: yes

[21:23] <CurtisOvidPoe> Cheers :)

[21:23] <TimToady> usually we use * on the end of .. or ... to indicate arbitrary size, also counted as 'infinite'

[21:23] <CurtisOvidPoe> * is preferred to Inf? got it. I‚Äôll change my slides.

[21:23] <TimToady> but in some sense it's more accurate, since computers are finite, so going to 'whatever' makes more sense

[21:24] <FROGGS_> star-p: use NativeCall; my CArray[Str] $foo.=new; $foo[0] = Str

[21:24] <camelia> star-p 2014.12: ( no output )

[21:24] <FROGGS_> hmmm, I don't spot that nqp-p catches that...

[21:24] <jnthn> FROGGS_: It might somehow get lucky

[21:24] <TimToady> m: constant @primes = grep { .is-prime }, 1..*; sy @primes[10]

[21:24] <camelia> rakudo-moar f9cb17: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/09Dz_O3cP8‚ê§Undeclared routine:‚ê§    sy used at line 1‚ê§‚ê§¬ª

[21:24] <TimToady> m: constant @primes = grep { .is-prime }, 1..*; say @primes[10]

[21:24] <camelia> rakudo-moar f9cb17: OUTPUT¬´31‚ê§¬ª

[21:25] <TimToady> CurtisOvidPoe: ^^^ note that constant initializtion is also binding really

[21:25] <CurtisOvidPoe> Ooohhhh!! Much nicer :)

[21:25] <TimToady> and we don't mind calling a lazily generated constant a constant

[21:26] <FROGGS_> jnthn: either ->get_str or Parrot_str_to_encoded_cstring, aye

[21:26] <TimToady> also, the sigil is optional then

[21:26] <TimToady> m: constant primes = grep { .is-prime }, 1..*; say primes[10]

[21:26] <camelia> rakudo-moar f9cb17: OUTPUT¬´31‚ê§¬ª

[21:26] *** Kristien left
[21:27] <TimToady> since people often like their constants to not look...variable...

[21:28] <TimToady> my \alias = expression serves a similar role, though expression can be recalculated each time through

[21:28] <TimToady> constant really has to be constant over the life of the program, since it's calculated (conceptually at least) at compile time

[21:30] *** bjz left
[21:31] *** Kristien joined
[21:33] <CurtisOvidPoe> Thanks. This is going in the bonus slides, but when I offer questions or bonus slides, they always take the bonus slides :)

[21:34] <FROGGS_> more to muse about, aye

[21:34] <timotimo> rather muse than abuse, i say

[21:37] *** zakharyas1 left
[21:39] *** mvuets joined
[21:41] * TimToady has too many notes, and wonders what the FOSDEM folk would really want to hear from me (that would also be true)

[21:41] *** virtualsue joined
[21:42] <masak> TimToady: what's the best-of-worlds outcume/effect of your FOSDEM talk, in your view?

[21:44] <TimToady> we get a few more good devs, and naysayers decide maybe to go off and naysay something else instead

[21:44] <TimToady> not really interested in too much success too soon though

[21:45] <PerlJam> (naysers naysaying something else)++

[21:45] <TimToady> if I can also draw some lessons for other communities to learn from, that'd be nice too

[21:46] * PerlJam sometimes hopes that former naysayers will recant their position on P6 too

[21:46] * TimToady doesn't expect that

[21:47] <TimToady> naysayers are almost never nayunsayers

[21:47] <PerlJam> still, I irrationally hope  :)

[21:47] <TimToady> realistically, I expect the song to change to "too little, too late"

[21:48] *** virtualsue left
[21:49] *** virtualsue joined
[21:50] <arnsholt> TimToady: Encouragingly (I suppose?), that's something I think has started to show up in places like HN

[21:50] <PerlJam> TimToady: "too little, too late" for this particular generation of devs is okay, because there are way more of them in the future  

[21:50] <TimToady> we're definitely in the later stages of 'then they fight you', I think

[21:51] <Kristien> About the subset types. I don't think it's too surprising they're not subtypes of each other since they're named, and differently named types don't share subtyping relationships with each other in nominal type systems unless explicitly specified.

[21:51] <TimToady> we could, perhaps support some ordering, if you say subset Foo of Bar where...

[21:51] <Kristien> I never thought about refinements that way, only in the structural typing sense, in which you would want Int where * > 1 to be a supertype of Int where * > 2.

[21:51] <PerlJam> Kristien: magical type inference figuring out that they are subtypes of each other is left as an execise for module authors  :)

[21:51] <TimToady> then Foo has to be subtype of Foo

[21:52] <Kristien> But in a nominal type system it shouldn't be an issue.

[21:52] <TimToady> er, Bar

[21:52] <TimToady> yes, we try to use nominals for their strenghts; the constraints are really more of an escape hatch

[21:53] <TimToady> they're there to make hard things possible, not so much easy things easy

[21:55] <TimToady> of course, simple constraints can potentially be useful to the optimizer, but we're not gonna grind any theoretical axes there

[21:55] <CurtisOvidPoe> TimToady: Have you have a chance to read https://github.com/perl6/specs/issues/80? In particular, the comment after the wall ‚Äòo text shows simple roles being order dependent.

[21:55] <Kristien> OK, cool.

[21:56] <CurtisOvidPoe> Er, the ‚Äúfirst‚Äù comment I made (in response to a request from jnthn)

[21:56] <TimToady> roles are more than just traits, they're also our means to generics

[21:56] <TimToady> and with generics, order tends to matter more

[21:56] <CurtisOvidPoe> The docs say that order of composition doesn‚Äôt matter.

[21:57] <jnthn> Note you can make a subset type that depends on another subset type:

[21:57] <jnthn> m: subset A where * > 0; subset B of A where * %% 3; say 6 ~~ B; say B ~~ A

[21:57] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§True‚ê§¬ª

[21:57] <jnthn> m: subset A where * > 0; subset B of A where * %% 3; say 3 ~~ B

[21:57] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§¬ª

[21:57] <jnthn> m: subset A where * > 0; subset B of A where * %% 3; say -3 ~~ B

[21:57] <camelia> rakudo-moar f9cb17: OUTPUT¬´False‚ê§¬ª

[21:57] <CurtisOvidPoe> I‚Äôm also concerned that one of the biggest issues with inheritance and mixins is ordering and now we‚Äôve replicated that in roles.

[21:57] <TimToady> CurtisOvidPoe: it should probably say "with respect to method names"

[21:58] <dalek> perl6-roast-data: c02ea61 | coke++ | / (5 files):

[21:58] <dalek> perl6-roast-data: today (automated commit)

[21:58] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c02ea61a49

[21:58] <dalek> rakudo-star-daily: 8e06cb4 | coke++ | log/ (9 files):

[21:58] <dalek> rakudo-star-daily: today (automated commit)

[21:58] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/8e06cb4a3a

[21:58] <CurtisOvidPoe> I don‚Äôt understand :) In my example, how does the consuming class (which hasn‚Äôt changed and still has the same roles) have a chance to discover that its behavior has been silently altered?

[21:59] <CurtisOvidPoe> (Sorry for the dumb question. This looks to me like action at a distance writ large)

[22:00] <PerlJam> CurtisOvidPoe: the issue is only with multis, right?  Or do I need to relook at your text?

[22:00] <CurtisOvidPoe> @PerlJam: No. The first comment I made on that was an example without multis.

[22:00] <jnthn> No, forget the multi/subset thing. The comment - https://github.com/perl6/specs/issues/80#issuecomment-70076440 - is the interesting one.

[22:01] * PerlJam looks

[22:01] <CurtisOvidPoe> This sort of thing bit me hard when I worked at the BBC and I fear that others with large-scale systems might face the same issue.

[22:03] *** spider-mario left
[22:04] <TimToady> I don't think when a role uses another role that it can override; I thought only the class was allowed to override, according to the traits paper

[22:05] <TimToady> if a role is acting like a class in that regard, it seems wrongish to me

[22:06] <TimToady> the composition should simply blow up, because the class isn't making the distinction, if I read it right

[22:07] *** skids left
[22:07] <TimToady> in other words, there is no pecking order among roles, with respect to methods anyway

[22:07] <TimToady> so I'd just call it a bug

[22:07] <CurtisOvidPoe> Both of the papers I linked to should be read to help. If Role A consumes Role B and they both have the same method, in the traits paper, that must be explcitly resolved and not deferred to the consuming class.

[22:08] <jnthn> CurtisOvidPoe: That is, resolution can be done by a role?

[22:08] <CurtisOvidPoe> That‚Äôs not the case in Perl 6 roles. If Role A consumes Role B and the both have the same method, Role A wins. Reverse the order of consumption and Role B wins.

[22:08] <CurtisOvidPoe> Yes, resolution can be done by a role.

[22:08] <mst> common usage over in M*-land is to have it so

[22:08] <TimToady> neither should win, by the original traits paper

[22:08] <jnthn> Well, must it seems.

[22:08] <mst> with 'A', 'B'; produces an error

[22:09] <TimToady> did they change their minds about this?

[22:09] <mst> but you can explicitly do

[22:09] <mst> with 'A'; with 'B';

[22:09] <CurtisOvidPoe> TimToady: you‚Äôre correct, neither should win.

[22:09] <mst> to specify an ordering

[22:09] <mst> the latter is, occasionally, extremely useful

[22:09] <mst> but it's not a good default

[22:09] <PerlJam> mst: can you give an example of how the latter is useful?

[22:11] <mst> PerlJam: partial optimisations for collection classes

[22:11] <mst> with 'SomeSetOfOptimsations'; with 'ProvidesGenericDefaultVersions';

[22:11] <jnthn> m: role A { method m() { } }; role B { method m() { } }; role C does A does B { }; class Foo does C { }

[22:11] <camelia> rakudo-moar f9cb17: OUTPUT¬´===SORRY!===‚ê§Method 'm' must be resolved by class Foo because it exists in multiple roles (A, B)‚ê§¬ª

[22:12] <jnthn> m: role A { method m() { } }; role B { method m() { } }; role C does A does B { }; class Foo does C { method m() { } } 

[22:12] <camelia> rakudo-moar f9cb17: ( no output )

[22:12] <jnthn> m: role A { method m() { } }; role B { method m() { } }; role C does A does B { method m() { } }; class Foo does C { } 

[22:12] <camelia> rakudo-moar f9cb17: ( no output )

[22:13] <Kristien> mst: can ProvidesGenericDefaultVersions also call the SomeSetOfOptimsations implementation in that case?

[22:13] <jnthn> CurtisOvidPoe: Do you expect either of the final 2 to complain?

[22:13] *** anaeem1 left
[22:13] <CurtisOvidPoe> Checking.

[22:13] <mst> Kristien: $self->thing_provided_by_the_optimised version will do what you'd hope, even if the method came in from somewhere else

[22:13] *** anaeem1 joined
[22:14] <TimToady> jnthn: I don't think role C is allowed to override the other roles like that

[22:15] *** anaeem1 left
[22:15] <CurtisOvidPoe> jnthn: per my discussions with them, the first (where class Foo has method m() ) should signal in some way to the developer that the class is overriding the role methods. The second (where class Foo doesn‚Äôt have that method) would be a compile time failure because there‚Äôs no way to know which m() you want.

[22:15] <TimToady> A, B, and C all come in on equal terms

[22:15] <TimToady> (into the class)

[22:15] <CurtisOvidPoe> TimToady: agreed.

[22:16] <TimToady> in P6 we can fudge it some by type-punning A and B,  then bringing them in as inherited instead, which would demote to after the roles

[22:16] <Kristien> mst: I think I mean using nextsame

[22:16] <TimToady> but that's not necessarily recommended :)

[22:17] <mst> Kristien: in the design I'm thinking of, that wouldn't make any sense

[22:17] <CurtisOvidPoe> One thought: they authors explained that if the ‚Äúconflicting‚Äù method reduces to the same byte code, it can be considered ‚Äúnot a conflict‚Äù. Don‚Äôt know if that would be easy to implement.

[22:17] <Kristien> OK.

[22:17] *** brrt left
[22:17] <TimToady> CurtisOvidPoe: a lot like the systems that allow you to redeclare a signature as long as it's "the same"

[22:18] *** [Sno] left
[22:18] * TimToady isn't sure what the use of such a redeclared but identical method would be

[22:19] <TimToady> a small helper function maybe?

[22:19] <CurtisOvidPoe> It helps to avoid the diamond problem. If role A consumes B and C, which each consume D, B and C are each providing D‚Äôs methods to A, but there‚Äôs no conflict.

[22:19] <jnthn> CurtisOvidPoe: How does "resolution can be done by a role" fit with them all coming in equal, and TimToady's "I don't think role C is allowed to override"?

[22:19] <TimToady> CurtisOvidPoe: but you don't need that anyway

[22:19] <mst> the diamond problem is, I suspect, better solved by knowing it's the same one from D

[22:19] <mst> and then there's no conflict to check byte code on in the first place

[22:19] <TimToady> C is composed only once, as far as method names go

[22:20] <TimToady> er, D, yeah

[22:20] *** ugexe left
[22:21] <TimToady> a role never provides another role's methods as its own, but it can provide another role along with itself, with dup removal

[22:21] <PerlJam> I feel like I need some vocabulary differentiation.   roles are "composed" into classes, and "consumed" into other roles?  Or. ... what happens when role C does B does A  ?

[22:21] *** ugexe joined
[22:21] <mst> class A does B does C

[22:21] <TimToady> they aren't consumed, is my point, they merely hitch a ride

[22:21] <mst> creates, effectively, a composed role B+C

[22:21] <mst> that composed role is then consumed by A

[22:22] <PerlJam> do B and A just get added to a list so that when C is eventually composed into a class, they can be checked for conflict/

[22:22] <PerlJam> ?

[22:22] <CurtisOvidPoe> jnthn: well, a role isn‚Äôt identified by its name. It‚Äôs identified by the name and the methods it provides. So if a Role A consumes B, but excludes B‚Äôs foo() method, then Role B isn‚Äôt the same role any more. And the combined A|B-foo() still has all roles being treated equally.

[22:23] <jnthn> CurtisOvidPoe: Yes, the problem is that talking about "excludes" isn't helpful when there's no exclusion syntax spec'd...

[22:23] <CurtisOvidPoe> Yeah. The class exclusion syntax won‚Äôt work for roles.

[22:23] <TimToady> which in our case resolves down to 'the class decides everything' right now

[22:24] <mst> I don't really remember ever seeing a case where 'excludes' helped anything except as a bandaid while I found time to un-break the design

[22:24] <jnthn> CurtisOvidPoe: *what* class exclusion syntax?

[22:24] <TimToady> it's really against the spirit of Liskov, insofar as her spirit presides here :)

[22:24] <CurtisOvidPoe> excludes is useful when the role is from a third-party.

[22:25] <mst> in that case, I'd argue you're effectively using it to monkey-patch

[22:25] <CurtisOvidPoe> jnthn: sorry, I was unclear. I meant the class resolution by overriding the role method by providing your own and calling the fully-qualified role method yourself.

[22:25] <mst> hence considering it a bandaid

[22:25] <mst> note: I've been in that situation. but it was still a hack.

[22:26] <PerlJam> If all you've got is some bytecode, you may need that hack

[22:26] <CurtisOvidPoe> mst: agreed, but it doesn‚Äôt change the fact that sometimes it‚Äôs needed. I hand you a role to define an interface to my API and I‚Äôve given that to a bunch of otthers: I‚Äôm not going to change my role for you when a bunch of others are happily using ut.

[22:27] <jnthn> CurtisOvidPoe: OK, and given you resolve the conflict by writing a method in the class with a matching name, how does that tie in with the suggestion of "issue a warning when one class/role is going to override a method provided by a role and allow the programmer to manually resolve the issue"?

[22:28] <CurtisOvidPoe> jnthn: I don‚Äôt think it does. I‚Äôm used to the eplicitness of aliasing and excluding (though I use them very rarely).

[22:28] <CurtisOvidPoe> So, I guess I‚Äôm kind of stuck on that.

[22:28] <mst> right, which just isn't how most role users seem to do it, IME

[22:28] <mst> I would be ok with something like

[22:29] <mst> does A { method m() };

[22:29] <CurtisOvidPoe> mst: again, I rarely do it, but I also rarely touch the symbol table. 

[22:29] <mst> but 'excludes' is a terrible way to get that, I think

[22:29] <mst> some explicit 'replaces' would be better

[22:29] <mst> then you don't have to repeat the method name twice

[22:30] <mst> that or have 'does A excluding m' turn the lack of m() into a requires

[22:30] <CurtisOvidPoe> mst: ‚Äòdoes A { method m() }‚Äô gets back to the original problem identified: that leads to mysterious action at a distance where the poor dev doesn‚Äôt realize they‚Äôve overridden a method.

[22:30] <mst> CurtisOvidPoe: the whole point of that syntactic handwave is that block being associated with the 'does' so that it's explicit

[22:30] <mst> class Foo { does A { method m() } method other() }

[22:30] <CurtisOvidPoe> mst: gotcha.

[22:31] <mst> note: not actually a concrete proposition

[22:31] <jnthn> CurtisOvidPoe: To be clear, we're agreeing that "warn if the class overrides the method" is incompatible with "the class resolves role conflicts by overriding the method"? Or is it more that a method in the class that overrides something that doesn't conflict warns, and a method in a class that deals with a conflict is legit?

[22:31] <mst> but, I have to head off

[22:32] <CurtisOvidPoe> I agree with the first part, but not the second.

[22:32] <CurtisOvidPoe> I don‚Äôt want the *silent* action at a distance.

[22:32] <CurtisOvidPoe> It wasn‚Äôt intended in the original traits paper, but they assumed a Smalltalk audience.

[22:33] <CurtisOvidPoe> What about an adverb? class A does B:excludes(mu()) { ‚Ä¶ }?

[22:34] <masak> I'd rather declare overriding than exclusion, for some reason.

[22:34] <CurtisOvidPoe> Or ‚Äúreplaces‚Äù, as mst suggested? 

[22:34] <TimToady> I thought we were talking about overriding in a role, not overriding in a class

[22:34] <CurtisOvidPoe> Actually, if you have roles B and C which both have mu(), but class A does not, then: class A does B:excludes(mu()) does C { ‚Ä¶ }

[22:35] <TimToady> that this one should fail, but doesn't:

[22:35] <TimToady> m: role A { method m() { } }; role B { method m() { } }; role C does A does B { method m() { } }; class Foo does C { }

[22:35] <camelia> rakudo-moar f9cb17: ( no output )

[22:36] <TimToady> or have we decided that that one's just a bug, and moved on?

[22:36] <jnthn> TimToady: It's not clear to me if it if "roles are able to resolve conflicts also".

[22:36] <CurtisOvidPoe> TimToady: I think we‚Äôre talking about both. The :excludes adverb should allow roles to safely compose other roles and classes to safely compose those roles. It also fits with the original intent.

[22:36] <jnthn> *to me it is if... 

[22:36] <jnthn> So many i-words...

[22:37] <CurtisOvidPoe> jnthn: a role needs to be able to resolve conflicts because it knows the other roles it‚Äôs composing and should be the authority on the behavior it provides. 

[22:37] <TimToady> but only by set theory, not by dispatch

[22:38] <jnthn> Yes, and if we take what CurtisOvidPoe says along with the Perl 6 spec's "you write a method with a matching name to resolve a conflict", the logical result is...what we have.

[22:38] <jnthn> TimToady: Dispatch is done on the flattened result.

[22:38] <jnthn> If you mean method lookup...

[22:38] <PerlJam> jnthn: except for using excludes to tell the compiler that you really and truly did mean to override that method.

[22:39] <TimToady> but that doesn't explain the lack of error in the example above, which is simply wrong according to traits paper

[22:39] <jnthn> PerlJam: There *is* no excludes in S14.

[22:39] <PerlJam> jnthn: oh, aye, I was taking that as part of "what CurtisOvidPoe says"

[22:39] <CurtisOvidPoe> It‚Äôs even worse in Moose. In Moose, if a role providing method M consumes one other role which also provides method M, we have a conflict. However, if the role consumes two or more other roles which provide the same method, we don't have a conflict:

[22:39] <PerlJam> i.e. he's proposing such a thing

[22:39] <jnthn> TimToady: If we make that an error, then how does a role perform conflict resolution?

[22:40] <CurtisOvidPoe> role A does B:excludes(mu())

[22:40] <CurtisOvidPoe> Sorry to harp on about the adverb. It just seems easy :)

[22:40] <TimToady> jnthn: we'd have to make an explicit override/replaces or some such to clarify intent

[22:41] <CurtisOvidPoe> role A { method m() { } }; role B { method m() { } }; role C does A:excludes(m()) does B:excludes(m()) { method m() { } }; class Foo does C { }

[22:41] <jnthn> TimToady: OK, if you're open to adding something like *that* then I think we're good.

[22:41] <TimToady> or excludes, if we care about knocking something out without replacing it

[22:41] <TimToady> but I'm not sure about the use case of that one

[22:42] <CurtisOvidPoe> Don‚Äôt forget that any method a role provides is also required, so if we knock something out, *something* still has to provide it.

[22:42] <TimToady> it's a little to much like "cancellation" in some card games

[22:42] <CurtisOvidPoe> Otherwise, $class.does(foo) is no longer a guarantee that the methods you want are there.

[22:42] <TimToady> oh, I also played a Queen, so neither of the count :)

[22:42] <TimToady> *them

[22:42] <jnthn> CurtisOvidPoe: Yes, that makes sense.

[22:43] <TimToady> well, we can show a missing method with ...

[22:43] <TimToady> even if we only provide a 'replace' marker

[22:43] <jnthn> Hm, true

[22:43] <TimToady> .oO(thanks for nothing!)

[22:43] <CurtisOvidPoe> This makes my head hurt :)

[22:45] <TimToady> posit a declarator, 'replace', in which case replace method m() { ... } with literal ... means exclude m

[22:45] <CurtisOvidPoe> It should be noted that if a method is excluded, sometimes you still might want that behavior, thus meaning that the aliasing the method is still potentially desirable. If we have two serialization roles for YAML and JSON and both have a serialize() method, we might want both.

[22:45] *** Kristien left
[22:45] <TimToady> or if you wanted to replace just one of the incoming role's method m's, you'd just do a redirect instead

[22:46] <jnthn> TimToady: What syntactic category would replace be in?

[22:46] <jnthn> A kind of method declarator?

[22:46] <TimToady> we could make it as simple as an explicit 'has method'

[22:47] <TimToady> though that might not be entirely clear

[22:47] <jnthn> Hmm

[22:47] <jnthn> Yeah, I don't like that so much

[22:47] <jnthn> It's not obvious enough it's replacing..

[22:47] <TimToady> there's there's multi methods...

[22:49] <jnthn> eeks

[22:50] *** BenGoldberg joined
[22:50] <TimToady> well, leave those out of it for now, we're probably just talking onlys here

[22:50] <TimToady> the multis might just fall out of it naturally if we generate a proto in the right spot at the right time :)

[22:51] <TimToady> claim method m() { ... }

[22:51] <CurtisOvidPoe> Night all. It‚Äôs just about midnight and I need my ‚Äúage before beauty‚Äù sleep. :)

[22:51] <TimToady> o/

[22:51] <TimToady> thanks

[22:52] <CurtisOvidPoe> You‚Äôre welcome.

[22:52] <masak> 'night, Ovid

[22:52] <jnthn> 'night, CurtisOvidPoe++

[22:53] <TimToady> I kinda like 'claim', about the right length, about the right level of aggression...

[22:53] <TimToady> overtones of immmiment domain and such

[22:54] <TimToady> *imminent

[22:54] <geekosaur> eminent?

[22:54] <TimToady> that too

[22:54] <TimToady> confiscate method m() { ... }   # :-)

[22:55] <masak> +1 for 'claim'

[22:57] <jnthn> So it does in as a scope declarator?

[22:57] <jnthn> *goes

[22:57] <TimToady> so basically, it doesn't prevent the eventual class from seeing the other methods if they come in by a different route, but "you didn't hear it from me" sez the claiming role

[22:57] <TimToady> yes, scope decl

[22:58] <TimToady> a has variant, really

[22:58] *** leont joined
[22:58] <TimToady> unless we want a 'shadow' thing that also works in classes

[22:59] <TimToady> which people have argued from from time to time

[22:59] <TimToady> and if we do that, maybe it should be reused here

[22:59] <TimToady> *for

[23:00] <TimToady> otoh, we haven't actually gone for the 'override' idea yet

[23:01] * jnthn wonders if he should break out the beer and music and see if he can pull together a prototype of claim in a branch :)

[23:01] <TimToady> that's your role :)

[23:02] <TimToady> so all you have to do is claim you did it :)

[23:02] * vendethiel backlogs Kristien's stuff about subsets

[23:02] * vendethiel doesn't think structural typing could apply to * > 1 and * > 2 :-)

[23:02] <TimToady> not without help of 'subset A of B'

[23:03] <TimToady> was what we said

[23:03] <TimToady> not that I think we treat that as :> right now

[23:04] <TimToady> m: subset A where * > 1; subset B of A where * > 2; my B $b; say $b ~~ A;

[23:04] <camelia> rakudo-moar f9cb17: OUTPUT¬´True‚ê§¬ª

[23:04] <TimToady> maybe we do

[23:04] <jnthn> Yeah, we do

[23:05] <jnthn> If you declare it.

[23:05] <TimToady> like I just did, yeah

[23:05] <TimToady> errand &

[23:05] <jnthn> m: subset A where * > 1; subset B of A where * > 2; multi m(A) { 'A' }; multi m(B) { 'B' }; say m($_) for ^3; # curious

[23:05] <camelia> rakudo-moar f9cb17: OUTPUT¬´Cannot call 'm'; none of these signatures match:‚ê§:(Any $ where { ... })‚ê§:(Any $ where { ... })‚ê§  in sub m at /tmp/OkX5_JorUz:1‚ê§  in block <unit> at /tmp/OkX5_JorUz:1‚ê§‚ê§¬ª

[23:06] <jnthn> duh :)

[23:06] <jnthn> m: subset A where * > 1; subset B of A where * > 2; multi m(A) { 'A' }; multi m(B) { 'B' }; say m($_) for 2..4; # curious

[23:06] <camelia> rakudo-moar f9cb17: OUTPUT¬´A‚ê§A‚ê§A‚ê§¬ª

[23:06] * sjn is very happy that arnsholt will be doing a NativeCall workshop in Oslo in two weeks :D http://meetu.ps/2G3LL9

[23:07] <jnthn> They don't include multi candidate sorting, since that still is only interested in the real nominal type at the base of the constraint chain.

[23:07] <jnthn> But it does apply the constraints from both.

[23:07] *** rurban joined
[23:13] *** [Sno] joined
[23:15] *** kjs_ left
[23:16] <vendethiel> TimToady: I mean, even if it could

[23:17] <vendethiel> jnthn: how could it decide which one to choose? The first one will always be the one, that seems logical

[23:18] <vendethiel> it's sorted as "Any where Callable" for both, right?

[23:18] <jnthn> vendethiel: I wasn't really saying it should, just saying it didn't :)

[23:18] <jnthn> (So the behavior it had - pick first - is what I expected.)

[23:29] <dalek> rakudo/claim-prototype: 542161e | jnthn++ | src/Perl6/ (2 files):

[23:29] <dalek> rakudo/claim-prototype: Add claim scope decl, map it to (NYI) MOP calls.

[23:29] <dalek> rakudo/claim-prototype: review: https://github.com/rakudo/rakudo/commit/542161ea3b

[23:31] *** kjs_ joined
[23:32] *** virtualsue left
[23:32] *** adu left
[23:38] *** skids joined
[23:40] *** kjs_ left
[23:46] *** mvuets left
[23:47] <dalek> rakudo/claim-prototype: 771b27a | jnthn++ | / (4 files):

[23:47] <dalek> rakudo/claim-prototype: Collect claims in classes and roles.

[23:47] <dalek> rakudo/claim-prototype: 

[23:47] <dalek> rakudo/claim-prototype: With this, claim method foo() { } works. However, this just keeps

[23:47] <dalek> rakudo/claim-prototype: track of what was claimed; the information isn't yet used.

[23:47] <dalek> rakudo/claim-prototype: review: https://github.com/rakudo/rakudo/commit/771b27a86c

[23:48] *** telex left
[23:50] *** telex joined
[23:51] *** tgt left
[23:58] *** rurban left
[23:58] *** tgt joined
