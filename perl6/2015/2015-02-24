[00:00] <grondilu> std: infix:«->»

[00:00] <camelia> std efd2de0: OUTPUT«5===SORRY!5===␤Undeclared routine:␤     'infix:«->»' used at line 1␤Check failed␤FAILED 00:00 134m␤»

[00:00] <grondilu> std: &infix:«->»

[00:00] <camelia> std efd2de0: OUTPUT«5===SORRY!5===␤Undeclared routine:␤     'infix:«->»' used at line 1␤Check failed␤FAILED 00:00 138m␤»

[00:01] <grondilu> lol we could even define C's -> operator.  That'd be cool.

[00:01] <grondilu> something like &infix:«->»(Pointer $, Capture $) {...}

[00:03] * grondilu realizes that'd be actually more complicated.

[00:14] *** vendethiel left
[00:19] *** vendethiel joined
[00:19] <masak> grondilu: wouldn't &prefix:<*> collide with term:<*> ?

[00:20] <grondilu> m: sub &prefix:<*>($) { "ok" }; say *pi, *;

[00:20] <camelia> rakudo-moar 4659f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/prurxBo_4N␤Missing block␤at /tmp/prurxBo_4N:1␤------> 3sub 7⏏5&prefix:<*>($) { "ok" }; say *pi, *;␤    expecting any of:␤        new name to be defined␤»

[00:20] *** dolmen left
[00:20] <grondilu> m: sub prefix:<*>($) { "ok" }; say *pi, *;

[00:20] <camelia> rakudo-moar 4659f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/np1fRgb9I2␤Preceding context expects a term, but found infix * instead␤at /tmp/np1fRgb9I2:1␤------> 3sub prefix:<*>($) { "ok" }; say *pi, *7⏏5;␤»

[00:21] <grondilu> m: sub prefix:<*>($) { "ok" }; say *pi;

[00:21] <camelia> rakudo-moar 4659f3: OUTPUT«ok␤»

[00:21] <grondilu> m: sub prefix:<*>($) { "ok" }; say *pi; say *;

[00:21] <camelia> rakudo-moar 4659f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/kPPU9RDdXz␤Preceding context expects a term, but found infix * instead␤at /tmp/kPPU9RDdXz:1␤------> 3b prefix:<*>($) { "ok" }; say *pi; say *7⏏5;␤»

[00:22] <grondilu> hum

[00:22] <grondilu> apprently it does collide.

[00:23] <grondilu> I'm not sure it should, frankly.  Yet I vaguely remember having already talked about that and TimToady gave an explanation as why it should collide indeed.

[00:24] *** muraiki_ left
[00:24] <masak> they collide.

[00:24] <masak> the only reason I asked is that it's very clear to me that they do. ;)

[00:24] <grondilu> unfortunatly I'm unconvinced.  if we see * and no term after it, then we're talking about the term, not the prefix, don't we?

[00:25] <masak> you're not allowed to reason like that.

[00:25] <masak> that's the problem.

[00:25] <grondilu> :/

[00:25] <masak> the parser reasons based on information it has in the now, not information from the future.

[00:25] <grondilu> oh yeah, no backtracing, right?

[00:25] <masak> we tend to flaunt most conventions, but we take time travel seriously.

[00:25] <grondilu> indeed that's the reason TimToady gave, I remember now.

[00:26] <grondilu> as S02 puts it: « To the extent allowed by sublanguages' parsers, Perl is parsed using a one-pass, predictive parser.  That is, lookahead of more than one "longest token" is discouraged.

[00:26] <grondilu> »

[00:27] <grondilu> it's a bit of a bummer, though.  IMHO

[00:27] <masak> there are four types of things. terms, prefixes, infixes, and postfixes. term: (T -> O), prefix: (T -> T), infix: (O -> T), postfix: (O -> O). since term and prefix both happen in a T state, they collide.

[00:28] <masak> (Perl 6 also talks about circumfixes and postcircumfixes. but these are simply fancy terms and postfixes, respectively.)

[00:28] <masak> I got a better appreciation for all this while developing 007.

[00:30] <grondilu> well, I guess we could use a unicode character that looks like *

[00:30] * masak .oO( now you have two problems. )

[00:31] <grondilu> ?

[00:32] <grondilu> m: say \u{BLACK STAR}

[00:32] <camelia> rakudo-moar 4659f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QcgzxshMbZ␤Undeclared names:␤    BLACK used at line 1␤    STAR used at line 1␤Undeclared routine:␤    u used at line 1␤␤»

[00:32] *** grettir joined
[00:32] <grondilu> ah I never remember the syntax for named characters

[00:33] <grondilu> m: say "\c[BLACK STAR]"

[00:33] <camelia> rakudo-moar 4659f3: OUTPUT«★␤»

[00:33] <masak> as long as you pick something distinct enough, you should be fine.

[00:34] <grondilu> I'm not sure why it has to be distinct and not just different.  A human will always tell the difference.

[00:35] <grondilu> (humans are not restricted to this "no time travel" rule)

[00:36] <masak> maybe.

[00:36] <grondilu> I really think an operator would be nice because "deref" is eeek

[00:38] *** Hor|zon joined
[00:38] <grondilu> m: print "there is also: \c[ASTERISK OPERATOR]"

[00:38] <camelia> rakudo-moar 4659f3: OUTPUT«there is also: ∗»

[00:39] <grondilu> m: say "\c[ASTERISK OPERATOR] * \c[BLACK STAR]  (just looking them all next to one another)"

[00:39] <camelia> rakudo-moar 4659f3: OUTPUT«∗ * ★  (just looking them all next to one another)␤»

[00:40] * grondilu likes the asterisk

[00:43] *** Hor|zon left
[00:44] *** echowuhao left
[00:44] <grondilu> m: sub prefix:<∗>($) { 1 }; say pi * ∗4;

[00:44] <camelia> rakudo-moar 4659f3: OUTPUT«3.14159265358979␤»

[00:46] * grondilu really likes it:  it looks a hell lot like the C operator and yet it's clearly different than infix:<*> so that it's hard to confuse it.

[00:47] *** skids joined
[00:47] <masak> well, as long as you're happy. :)

[00:48] <grondilu> module Asterix { multi prefix:<∗>(Pointer $p) is export { deref $p } }; 

[00:52] <grondilu> now instead of defining a pointer to an int as 'my Pointer[int] $n' we could even consider write it 'my int ∗$n;'

[00:52] <grondilu> I think that would be cool, but I suspect you guys will not agree.

[00:52] <masak> :)

[00:53] <masak> if you can make it work, knock yourself out.

[00:53] <masak> but it's starting to sound slang-y to me.

[00:53] <grondilu> I'm a user, not an implementator :)

[00:54] <grondilu> class int∗ is Pointer[int] {}  # wouldn't that do the job, though?

[00:55] <masak> can't have non-alnums in an identifier like that.

[00:55] <grondilu> std: class foo∗ {}

[00:55] <camelia> std efd2de0: OUTPUT«5===SORRY!5===␤Unable to parse class definition at /tmp/t3rKvonhpj line 1:␤------> 3class foo7⏏5∗ {}␤    expecting any of:␤ name␤   trait␤Parse failed␤FAILED 00:00 134m␤»

[00:55] <grondilu> oh ok

[00:55] <masak> also, that's not how you wrote it.

[00:55] <masak> you had a space in between.

[00:56] <grondilu> in C it would be accepted.

[00:56] <masak> then maybe you should write it in C instead ;)

[00:56] <ShimmerFairy> While I can see the appeal in having the syntax match C, I feel I should point out that Perl 6 specifically *isn't* C. :)

[00:57] <grondilu> but since the native types are so close to their C meanings, it makes sense to use the same notations for them.

[00:59] <grondilu> I mean, translating (*p)[0] into (deref $p)[0] would be a bit dull.

[01:00] <grondilu> 'deref' is so much more verbose than '*'

[01:00] <ShimmerFairy> I think I actually prefer "deref", since it's more descriptive.

[01:01] <dalek> mojo6/mojolicish: b221c9b | hoelzro++ | TODO.md:

[01:01] <dalek> mojo6/mojolicish: Add Mojolicish TODO

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/b221c9bb9c

[01:01] <dalek> mojo6/mojolicish: c14d0ca | hoelzro++ | mojo-tests/ (172 files):

[01:01] <dalek> mojo6/mojolicish: Add tests from Mojolicious 5.79

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/c14d0cae54

[01:01] <dalek> mojo6/mojolicish: 628ffd9 | hoelzro++ | TODO.md:

[01:01] <dalek> mojo6/mojolicish: Start documenting differences from P5 Mojolicious

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/628ffd9dc8

[01:01] <dalek> mojo6/mojolicish: 2a32a76 | hoelzro++ | t/mojolicious/lite_app.t:

[01:01] <dalek> mojo6/mojolicish: Start on Mojolicious tests

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/2a32a7606c

[01:01] <dalek> mojo6/mojolicish: a3b5467 | hoelzro++ | lib/Mojolicious/Lite.pm:

[01:01] <dalek> mojo6/mojolicish: Stub Mojolicious::Lite bits

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/a3b5467433

[01:01] <dalek> mojo6/mojolicish: bc7d48d | hoelzro++ | lib/ (3 files):

[01:01] <dalek> mojo6/mojolicish: More stubbing

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/bc7d48d7b2

[01:01] <dalek> mojo6/mojolicish: 1213487 | hoelzro++ | lib/Mojolicious.pm:

[01:01] <dalek> mojo6/mojolicish: Implement defaults method

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/1213487b7e

[01:01] <dalek> mojo6/mojolicish: ecc922b | hoelzro++ | lib/Mojo (3 files):

[01:01] <dalek> mojo6/mojolicish: Add logging stuff

[01:01] <dalek> mojo6/mojolicish: review: https://github.com/coke/mojo6/commit/ecc922b368

[01:02] *** vendethiel left
[01:02] <ShimmerFairy> grondilu: like I said, I don't have a problem with C-like notation, but I'm not convinced it needs to be in standard Perl 6.

[01:03] *** vendethiel joined
[01:03] <grondilu> well, NativeCall is not exactly standard Perl 6 (otherwise we would not have to specify 'use NativeCall')

[01:03] <TimToady> well, that's also negotiable :)

[01:04] <TimToady> but we can't have something that is both a term and a prefix

[01:04] <ShimmerFairy> IIRC NativeCall was just an implementation of something in the spec.

[01:05] <TimToady> it would actually be easier to have a * postfix, but I wouldn't recommend that either

[01:06] <grondilu> TimToady: you don't like my suggestion of using the asterix symbol (unicode 0x2217)?

[01:06] <TimToady> too confusing

[01:07] <TimToady> in any case, it's probably a much more p6y thing to define a postfix for deref

[01:08] <ShimmerFairy> $pointer.deref seems like an obvious candidate (though it's not exactly a postfix, of course)

[01:09] * grondilu wonder if $$pointer would make sense

[01:09] <dalek> rakudo-star-daily: 8c29e41 | coke++ | log/ (11 files):

[01:09] <dalek> rakudo-star-daily: today (automated commit)

[01:09] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/8c29e41851

[01:10] <ShimmerFairy> r: my $a = 5; say $$a;

[01:10] <camelia> rakudo-moar 4659f3: OUTPUT«5␤»

[01:10] <TimToady> r: my $a = 5; say $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$a

[01:10] <camelia> rakudo-moar 4659f3: OUTPUT«5␤»

[01:10] <grondilu> it does nothing special for normal variables, but could it have a special mening for natives?

[01:10] <TimToady> possibly

[01:11] <TimToady> but if "pointer" gets complicated, better to have a postfix

[01:11] *** raiph left
[01:11] *** jschulz left
[01:12] <ShimmerFairy> we could have a $ postfix :P

[01:12] <grondilu> I got to admit I'm a bit frustrated by not being able to convince you about the asterix, for I'd love to write 'my int ∗$p;'

[01:12] <raydiak> yay slangs :)

[01:12] <TimToady> never gonna happen

[01:12] <grondilu> :(

[01:12] <ShimmerFairy> Not only is it too similar to the ASCII asterisk, but standard Perl 6 also likes having texas variants of Unicode things.

[01:12] <TimToady> it's formally ambiguous

[01:13] *** raiph joined
[01:13] <TimToady> oh, you mean the unicode one

[01:13] <TimToady> but that also proves my point that you confused me :)

[01:13] <grondilu> yes, that's the unicode I typed.

[01:13] <grondilu> my int *$wrong; my int ∗$ok

[01:14] <grondilu> it does not matter if they look the same, as long as they are different for the parser.

[01:14] <TimToady> the reader matters every now an again too

[01:14] <TimToady> we are not completely autistic

[01:14] <grondilu> the reader will know what it's about.

[01:15] <masak> this is an interesting discussion. I agree with TimToady, but I feel for grondilu, who wants to turn his Perl 6 into C.

[01:15] <TimToady> but certainly you can define your own prefix if you like, as long as it's not ambiguous

[01:16] <grondilu> 'my int ∗$ok' would require more than a prefix definition, unfortunately.

[01:16] <TimToady> we've had a firm policy of not turning Perl 6 into any particular language, though we've been accused of it from time to time :)

[01:16] * TimToady thinks the inside-out declarations of C can stay in C

[01:16] <masak> grondilu: that's why I said it looks slang-y.

[01:16] <grondilu> I don't want to turn Perl 6 into C, just the part that uses natives.

[01:17] <grondilu> 'my Int ∗$p' would be a compile error, for instance.

[01:18] * masak .oO( I don't want to turn you all into lizards, just your brains and your tails )

[01:18] <grondilu> 'my ∗$p' would actually mean:  'my Pointer[void] $p'

[01:18] * TimToady would trot out a slippery slope argument here if he believed in slippery slope arguments :)

[01:18] <masak> TimToady: problem is, once you start believing in one slipperly slope argument... :P

[01:19] <geekosaur> I could imagine a slang for interfacing with C that looked more like C... in a module

[01:19] <grondilu> .oO( use C-style; )

[01:19] <grondilu> I'd be fine with that, if slangs can deliver.

[01:21] <grondilu> a better name would just be asterix, I guess.  'use asterix; my ∗$p;'

[01:23] <TimToady> that's my grandson you're talking about

[01:23] * geekosaur wonders what obelix does

[01:24] <TimToady> who doesn't want me typing right now, since I'm holding him

[01:25] <grondilu> ouch, asterisk indeed.

[01:26] <grondilu> come on, don't you think 'my ∗$p;' would be more elegant than 'my Pointer[void] $p;'?

[01:27] <ShimmerFairy> In Perl 6, I think we should have type names look like type names.

[01:28] <grondilu> m: my $x; say $x.WHAT 

[01:28] <camelia> rakudo-moar 4659f3: OUTPUT«(Any)␤»

[01:28] <grondilu> yet we don't write my Any $x

[01:30] <geekosaur> m: my Int $x;

[01:30] <camelia> rakudo-moar 4659f3: ( no output )

[01:31] <masak> grondilu: I think 'my Pointer[void] $p;' looks a whole lot clearer than 'my ∗$p;'

[01:33] <grondilu> what about 'my void ∗$p;'?

[01:33] <grondilu> it looks a lot like the C code, so it would make a C-programmer feel at home.

[01:33] <masak> it feels like you're conflating operators (which belong in expressions) and type declarations.

[01:34] <grondilu> it feels both perlish and C-ish.

[01:34] <grondilu> I began with talking with operators, which made me think of declarations.

[01:35] <masak> C does that -- conflate them.

[01:35] <masak> I don't necessarily feel that's a good thing.

[01:35] <grondilu> well in perl 6 we would not have to.

[01:36] <grondilu> oh wait, I see what you mean.

[01:36] <grondilu> that's an issue indeed.

[01:38] <grondilu> but again, that kind of syntax would only be used for native types, so that should help.

[01:38] <grondilu> (hopefully)

[01:38] <ShimmerFairy> Not to repeat myself, but Perl 6 isn't C. It's OK if the syntax between the two languages don't match (they don't match in plenty of places already ☺)

[01:40] <masak> the extent to which I agree with ShimmerFairy is that the rationale for a syntax should come from within the language itself. not from within some other language the reader is expected to feel comfortable with.

[01:40] <grondilu> ok, good point.

[01:41] <masak> 'my ∗$p;' does not make sense from a Perl 6 perspective. maybe it could be made to work with sufficiently advanced slang, and maybe some C programmers would appreciate the thought.

[01:41] <masak> but it would be departing from Perl 6 syntax and probably from Perl 6 ideals, too.

[01:42] <raydiak> not that I think we *should*, but you'd probably have more success allowing * as a postfix on native typenames; then you at least get 'my void* $p', easy to type, and isn't likely to be used in ambiguous contexts off the top of my head

[01:43] <grondilu> can you define an operator to act on Types?

[01:43] <masak> operators occur in expressions.

[01:43] <masak> that's not an expression.

[01:43] <raydiak> idk if that'd be an operator or something more slangish

[01:44] <raydiak> and now I do :)

[01:45] <grondilu> could it be the kind of things that could be done with a macro?

[01:45] * raydiak regards the * in C more as part of the type than the name anyway

[01:45] <masak> grondilu: not as the macro spec stands today.

[01:52] <grondilu> well, I hope I did not bother you too much with those heretic ideas ;)  off to bed for me now.

[01:52] *** grondilu left
[01:53] <masak> grondilu++ # heresy

[02:10] <masak> 'night, #perl6

[02:19] *** fhelmberger joined
[02:19] <alpha-> nn

[02:20] *** telex left
[02:22] *** telex joined
[02:23] *** fhelmberger left
[02:26] *** laouji joined
[02:27] *** Hor|zon joined
[02:31] *** laouji left
[02:32] *** Hor|zon left
[02:40] <timotimo> nn

[02:45] *** ilbot3 left
[02:47] *** ilbot3 joined
[02:52] *** grettir left
[03:01] *** fernand__ left
[03:06] *** fernand__ joined
[03:07] *** fernand__ left
[03:08] *** noganex_ joined
[03:11] *** noganex left
[03:18] *** Patterner joined
[03:22] *** Psyche^ left
[03:37] <raydiak> dunno if anyone is around, but...in spite of the docs claim that "    lua_createtable $L, 0, 0;

[03:37] <raydiak> heh

[03:37] <raydiak> Capture doesn't do Positional or Associative

[03:37] <raydiak> why?

[03:43] <raydiak> I'd ask why subscripting things which don't implement those roles is even valid, but I guess the answer is probably autovivification

[03:43] *** leont left
[03:44] <TimToady> m: say “I'm ”, ‘“client-friendly”.’

[03:44] <camelia> rakudo-moar 4659f3: OUTPUT«I'm “client-friendly”.␤»

[03:45] <raydiak> TimToady++

[03:51] <flussence> m: say ”foo“

[03:51] <camelia> rakudo-moar 4659f3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/6hZOITsTiK␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument␤at /tmp/6hZOITsTiK:1␤------> 3say 7⏏5”foo“␤    expecting any of:␤…»

[03:51] <flussence> neat

[03:51] <flussence> well, weird error but I expected one there.

[04:07] *** davido___ left
[04:08] *** davido___ joined
[04:09] *** FROGGS left
[04:09] *** davido___ left
[04:09] *** FROGGS joined
[04:11] *** davido___ joined
[04:16] *** Hor|zon joined
[04:20] *** Hor|zon left
[04:30] *** echowuhao joined
[04:32] *** rmgk_ joined
[04:32] *** rmgk is now known as Guest77697

[04:32] *** Guest77697 left
[04:32] *** rmgk_ is now known as rmgk

[05:19] *** davido___ left
[05:21] *** davido___ joined
[05:22] <raydiak> \o/ the Inline breakage is indeed gone, at least 3 more modules should work again; FROGGS++

[05:27] <TimToady> std: say ”foo“

[05:27] <camelia> std efd2de0: OUTPUT«5===SORRY!5===␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/da4WBZWPFz line 1:␤------> 3say7⏏5 ”foo“␤Confused at /tmp/da4WBZWPFz line 1:␤------> 3say 7⏏5”foo…»

[05:28] <TimToady> huh, I guess it's my fault

[05:28] <TimToady> should probably say "Bogus term" or so

[06:03] *** laouji joined
[06:04] *** Hor|zon joined
[06:08] *** laouji left
[06:09] *** Hor|zon left
[06:18] *** mr-foobar left
[06:21] *** bjz joined
[06:22] <dalek> roast: 9394e7e | TimToady++ | S02-lexical-conventions/one-pass-parsing.t:

[06:22] <dalek> roast: don't be overspecific on parsefail error

[06:22] <dalek> roast: review: https://github.com/perl6/roast/commit/9394e7e563

[06:24] <dalek> rakudo/nom: 629f5a4 | TimToady++ | src/Perl6/Grammar.nqp:

[06:24] <dalek> rakudo/nom: bare say now complains about no valid arg

[06:24] <dalek> rakudo/nom: 

[06:24] <dalek> rakudo/nom: (since it might be an invalid arg rather than a missing arg).

[06:24] <dalek> rakudo/nom: The help message for bare say et al. is demoted to a worry.

[06:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/629f5a4b3b

[06:27] <dalek> doc: 99e560d | moritz++ | lib/Type/Cool.pod:

[06:27] <dalek> doc: fix output example, pippo++

[06:27] <dalek> doc: review: https://github.com/perl6/doc/commit/99e560d634

[06:28] *** bjz left
[06:33] *** gfldex joined
[06:37] <dalek> std: 28329a7 | TimToady++ | STD.pm6:

[06:37] <dalek> std: demote bare say message in case of bogus term

[06:37] <dalek> std: review: https://github.com/perl6/std/commit/28329a7738

[06:38] *** risou is now known as risou_awy

[06:38] *** risou_awy is now known as risou

[06:42] *** FROGGS[mobile] left
[06:50] *** bjz joined
[06:53] *** BenGoldberg left
[06:59] <dalek> rakudo/nom: f84e536 | TimToady++ | src/Perl6/World.nqp:

[06:59] <dalek> rakudo/nom: don't claim TTIAR if 2nd term failed to parse

[06:59] <dalek> rakudo/nom: 

[06:59] <dalek> rakudo/nom: It's just a bogus term if it can't parse it...

[06:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f84e536383

[06:59] <dalek> rakudo/nom: 546000b | TimToady++ | src/Perl6/Grammar.nqp:

[06:59] <dalek> rakudo/nom: don't panic, just be sorry (on bare say etc.)

[06:59] <dalek> rakudo/nom: 

[06:59] <dalek> rakudo/nom: This allows the new bogus term message to show when appropriate.

[06:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/546000b908

[07:02] *** wicope joined
[07:06] <dalek> roast: d39c6dc | TimToady++ | S32-exceptions/misc.t:

[07:06] <dalek> roast: don't overspecify error message on bare ord

[07:06] <dalek> roast: review: https://github.com/perl6/roast/commit/d39c6dc161

[07:08] <TimToady> m: list `

[07:08] <camelia> rakudo-moar 629f5a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/sbO3EbvOFN␤Two terms in a row␤at /tmp/sbO3EbvOFN:1␤------> 3list 7⏏5`␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤        postfix␤   …»

[07:08] <TimToady> if it was expecting a prefix or term there, you can't call it a term...

[07:09] <TimToady> so that situation now produces "Bogus term" instead

[07:12] *** rindolf joined
[07:12] *** ribasushi left
[07:13] *** diana_olhovik joined
[07:18] *** FROGGS left
[07:20] <nine_> .tell moritz the No such method '' for invocant of type 'Foo' is not new. I've seen it appear in Inline::Perl5 as well but ever since I wanted to invest time into it, I've been unable to reproduce it.

[07:20] <yoleaux> nine_: I'll pass your message to moritz.

[07:20] *** ribasushi joined
[07:21] *** echowuhao left
[07:23] <TimToady> m: list `

[07:23] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Yk99bluLvg␤Bogus term␤at /tmp/Yk99bluLvg:1␤------> 3list 7⏏5`␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤        postfix␤        inf…»

[07:23] <TimToady> m: say;

[07:23] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5===␤No valid term seen where one is required␤at /tmp/QOg0H5T28K:1␤------> 3say7⏏5;␤    expecting any of:␤        argument list␤Other potential difficulties:␤    Unsupported use of bare 'say'; in Perl 6 please use .say if …»

[07:24] <TimToady> m: say ”foo“  # reversed quotes

[07:24] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5===␤No valid term seen where one is required␤at /tmp/1lkeHrxvBB:1␤------> 3say 7⏏5”foo“  # reversed quotes␤Bogus term␤at /tmp/1lkeHrxvBB:1␤------> 3say 7⏏5”foo“  # reversed quotes␤    expecting any of:␤   …»

[07:29] <raydiak> nine_++: thanks for all your work on the Inline modules...they inspired Inline::Lua

[07:34] *** gfldex left
[07:39] <nine_> raydiak: :)

[07:40] *** Rounin joined
[07:43] *** tengignick joined
[07:43] *** tengignick left
[07:46] *** tengignick joined
[07:50] *** anaeem1 joined
[07:51] *** anaeem1 left
[07:51] *** anaeem1_ joined
[07:52] <TimToady> m: say “foo"  # mismatched quotes

[07:52] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YBRwruT0eE␤Unable to parse expression in smart double quotes; couldn't find final '”' ␤at /tmp/YBRwruT0eE:1␤------> 3say “foo"  # mismatched quotes7⏏5<EOL>␤    expecting any of:␤        argu…»

[07:53] *** laouji joined
[07:53] *** Hor|zon joined
[07:55] <raydiak> nine_: that native(&sub) trick lets you detect and switch libraries at runtime?

[07:57] *** laouji left
[07:58] *** Hor|zon left
[07:58] *** FROGGS joined
[08:04] *** prime left
[08:12] <TimToady> m: my $href = { A => 98, Q => 99 };

[08:12] <camelia> rakudo-moar 546000: ( no output )

[08:14] *** prime joined
[08:14] *** darutoko joined
[08:14] *** zakharyas joined
[08:15] <FROGGS> m: my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee]

[08:16] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/wGsglBIVwd␤Undeclared name:␤    Pointer used at line 1␤␤»

[08:16] <FROGGS> m: use NativeCall; my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee]

[08:16] <camelia> rakudo-moar 546000: OUTPUT«(TypedPointer[Coffee])␤»

[08:16] *** larion left
[08:16] <FROGGS> m: use NativeCall; my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee].new

[08:16] <camelia> rakudo-moar 546000: OUTPUT«TypedPointer[Coffee]<NULL>␤»

[08:16] <FROGGS> m: use NativeCall; my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee].new.deref

[08:16] <camelia> rakudo-moar 546000: OUTPUT«(Coffee)␤»

[08:16] <FROGGS> m: use NativeCall; my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee].new.of

[08:16] <camelia> rakudo-moar 546000: OUTPUT«(Coffee)␤»

[08:16] <FROGGS> m: use NativeCall; my class Coffee is repr<CStruct> { has uint8 $.milk }; say Pointer[Coffee].of

[08:16] <camelia> rakudo-moar 546000: OUTPUT«(Coffee)␤»

[08:16] <FROGGS> :o)

[08:18] <FROGGS> the 'TypedPointer' will be shown as 'Pointer' once the ^how-method support get merged from native-ref

[08:18] <FROGGS> so it can .perl.EVAL nicely

[08:19] <raydiak> FROGGS++ :)

[08:19] <FROGGS> :o)

[08:20] <FROGGS> the native stuff really is fun to implement

[08:20] <FROGGS> and the reason for that is that Perl 6 is that powerful... everything is potentially fine grained typed, which helps a lot to create a nice api

[08:21] *** _mg_ joined
[08:23] <raydiak> the idea came up earlier about a Slang::Cish or something which could allow e.g. 'int*' as sugar for 'Pointer[int]'

[08:23] <FROGGS> that should be doable

[08:24] <FROGGS> I mean, I made this: https://github.com/FROGGS/p6-Slang-Piersing

[08:24] <FROGGS> which allows identifiers to end with <[?!]>

[08:24] <raydiak> I saw, it's neat :)

[08:25] <FROGGS> so, int* (or better int32*) could be implemented in about 50 loc

[08:29] <raydiak> could maybe do some other neat nativecall sugars in ::Cish too, if someone wanted to make a project out of it...grondilu++ seemed excited about his * idea

[08:29] <dalek> doc: 88bfdf0 | TimToady++ | lib/Language/5to6.pod:

[08:29] <dalek> doc: mention Zen slice, need for parens in P5's list x

[08:29] <dalek> doc: review: https://github.com/perl6/doc/commit/88bfdf072f

[08:32] <dalek> doc: baf99a8 | TimToady++ | lib/Language/5to6.pod:

[08:32] <dalek> doc: -> should be <->

[08:32] <dalek> doc: review: https://github.com/perl6/doc/commit/baf99a8c6c

[08:34] <TimToady> actually, ending identifiers with ! interferes with a factorial operator, and it's easy enough to define a postfix:<?> that passes through a boolean

[08:34] <TimToady> if you really want one

[08:34] <TimToady> and the ! is not necessary because mutating methods are used with .= generally

[08:35] <TimToady> @array.=sort;

[08:35] <TimToady> "All things are possible, but not all things are expedient." --St Paul

[08:37] <FROGGS> I was just asked to allow said identifiers, I do not know why masak want to have that...

[08:37] <FROGGS> I just thought: hey, I can release that within 15 minutes! :o)

[08:40] *** anaeem1_ left
[08:40] *** anaeem1 joined
[08:41] <moritz> TimToady: not all mutators can be exposed as returning a modified copy instead

[08:41] <yoleaux> 07:20Z <nine_> moritz: the No such method '' for invocant of type 'Foo' is not new. I've seen it appear in Inline::Perl5 as well but ever since I wanted to invest time into it, I've been unable to reproduce it.

[08:41] <TimToady> masak doesn't particularly want it, it was grondilu that was hankering for C syntax

[08:42] <moritz> also there's the slight question of performance

[08:43] <TimToady> sure, but ! is a low-luminance feature, as far as I'm concerned

[08:43] <moritz> fwiw I'm of two minds here

[08:43] <moritz> I kinda like the explicitness of !

[08:43] <TimToady> rather have a general way of turning normal methods into mutators, and then optimize from there

[08:43] *** tengignick left
[08:43] <moritz> otho it always looks like angry code for me :-)

[08:43] <TimToady> you really wanna put ! on every push

[08:43] <TimToady> ?

[08:44] <moritz> not sure; I'd have to try it

[08:44] <TimToady> anyway, this was definitely one feature we decided not to borrow from ruby

[08:44] *** _mg_ left
[08:45] *** tengignick joined
[08:45] * TimToady should probably go to bed before he gets grouchy :)

[08:47] <moritz> good night, TimToady, and dream of unpoisoned identifiers

[08:54] *** Hor|zon joined
[08:57] *** Ven joined
[09:04] *** vukcrni left
[09:05] *** Rounin left
[09:05] *** bolangi left
[09:10] *** virtualsue joined
[09:15] *** virtualsue left
[09:16] *** tengignick left
[09:16] <dalek> doc: f741837 | moritz++ | util/update-and-sync:

[09:16] <dalek> doc: Enable Inline::Python again

[09:16] <dalek> doc: 

[09:16] <dalek> doc: I have installed a version of Inline::Python that nine++ fixed

[09:16] <dalek> doc: review: https://github.com/perl6/doc/commit/f741837394

[09:17] *** kjs_ joined
[09:18] *** tengignick joined
[09:18] <jnthn> morning, #perl6

[09:19] <raydiak> good morning jnthn 

[09:20] *** tengignick left
[09:21] <moritz> \o *

[09:21] <raydiak> hi moritz 

[09:22] *** Ven left
[09:26] *** dakkar joined
[09:36] *** larion joined
[09:40] *** rurban joined
[09:43] <[ptc]> o/ moritz 

[09:50] *** espadrine joined
[09:51] *** coffee` joined
[10:00] *** larion_ joined
[10:01] *** larion_ left
[10:06] <raydiak> good night, morning people o/

[10:11] *** _mg_ joined
[10:11] *** _mg_ left
[10:12] <masak> good antenoon, #perl6

[10:12] *** _mg_ joined
[10:13] <masak> I think mandating ! on every mutator will ultimately fail, because we don't have a solid model for restricting writes to the "insides" of objects, arrays/hashes, etc.

[10:14] <masak> that's why this works, for example:

[10:14] <masak> m: sub foo(@a) { @a.push(5) }; my @b = 1, 2, 3; foo(@b); say @b.perl

[10:14] <camelia> rakudo-moar 546000: OUTPUT«Array.new(1, 2, 3, 5)␤»

[10:14] <masak> note that I didn't mark `@a` as `is rw`.

[10:15] <masak> also note that the spec stubbornly forbids this kind of behavior -- it's just that reality refuses to listen.

[10:15] *** diana_olhovik left
[10:15] *** virtualsue joined
[10:16] *** diana_olhovik joined
[10:20] * FROGGS .oO( Lalalala I can't hear you! -- rakudo )

[10:21] <tadzik> /o\ LALALALA

[10:24] <masak> more generally, I'm not convinced that it's possible to build a consistent model of what contains what, without doing something drastic like splitting `has` up into `has` (containment) and `knows` (inter-object link) or something.

[10:25] <masak> and I've been over in those parts, and I haven't seen a local optimum there either.

[10:25] <sergot> hi #perl6

[10:25] <tadzik> hello sergot 

[10:26] <tadzik> moritz: huh, I think the move to subtrees broke 'git pull' in panda :|

[10:37] <dalek> perl6-examples: 4783208 | paultcochrane++ | euler/prob029-gerdr.pl:

[10:37] <dalek> perl6-examples: Add sigils to prob029-gerdr.pl

[10:37] <dalek> perl6-examples: 

[10:37] <dalek> perl6-examples: Maybe this code only used to work in pugs?  Anyway, it runs again now and

[10:37] <dalek> perl6-examples: its result matches the expected Euler project answer.

[10:37] *** dalek left
[10:38] *** dalek joined
[10:38] *** ChanServ sets mode: +v dalek

[10:47] *** kjs_ left
[10:51] <dalek> rakudo/cpp: 80a5135 | lizmat++ | src/core/Str.pm:

[10:51] <dalek> rakudo/cpp: Make substr() a lot faster, make substr-rw() work

[10:51] <dalek> rakudo/cpp: 

[10:51] <dalek> rakudo/cpp: Highlights:

[10:51] <dalek> rakudo/cpp: - substr("foo",1)       2.5x faster

[10:51] *** dalek left
[10:52] *** dalek joined
[10:52] *** ChanServ sets mode: +v dalek

[10:53] <dalek> doc: e3c8333 | (Salve J. Nilsen)++ | lib/Language/functions.pod:

[10:53] <dalek> doc: Remove superfluous 'for' in example

[10:53] <dalek> doc: review: https://github.com/perl6/doc/commit/e3c8333a89

[10:53] *** virtualsue left
[10:54] *** _mg_ left
[10:58] <sjn> \o

[10:59] *** tengignick joined
[11:02] <tadzik> o/

[11:02] <tadzik> sjn++ # deserved karma

[11:02] <sjn> oh?

[11:02] <jnthn> ooh, an sjn!

[11:02] <tadzik> A wild sjn appears!

[11:03] <tadzik> sjn: yeah, some (Salve J. Nilsen)++ stole your karma for doc commit

[11:03] <sjn> tadzik: ah, how do I fix that?

[11:03] *** baest left
[11:03] <tadzik> I don't know anymore :D

[11:03] <jnthn> Yes. And a wild jnthn will appear in Oslo and be free on evening of 9th and/or 10th March

[11:03] <tadzik> at some point it involved being in parrot's CREDITS file

[11:03] * sjn assumes that comes from the user.name setting in git-config

[11:03] <sjn> jnthn: oh, cool!

[11:04] <sjn> jnthn: you're missing Damian by a week though! :-(

[11:04] *** virtualsue joined
[11:04] <jnthn> sjn: Aww!

[11:04] <sjn> oh well

[11:04] <jnthn> sjn: Anyway, I'll be about if anybody wants to go take a beer one of those evenings.

[11:04] * sjn would love that

[11:05] <sjn> We can invite to an emergency beer rescue or something :)

[11:05] <jnthn> .oO( Much better than an emergency bear rescue )

[11:06] <sjn> hehe

[11:12] *** MadcapJake left
[11:12] *** MadcapJake joined
[11:18] *** laouji joined
[11:22] *** kjs_ joined
[11:23] *** raiph left
[11:24] *** larion left
[11:25] *** grondilu joined
[11:26] *** adu left
[11:26] <dalek> doc: 5b60067 | paultcochrane++ | lib/Language/5to6.pod:

[11:26] <dalek> doc: Add vim coda to 5to6.pod

[11:26] <dalek> doc: 

[11:26] <dalek> doc: Now vim knows how to highlight and indent the file

[11:26] <dalek> doc: review: https://github.com/perl6/doc/commit/5b60067797

[11:26] <dalek> doc: 77d2a9c | paultcochrane++ | lib/Language/5to6.pod:

[11:26] <dalek> doc: Mention :delete and :exists on hashes in 5to6

[11:26] <dalek> doc: review: https://github.com/perl6/doc/commit/77d2a9c392

[11:27] *** laouji_ joined
[11:28] *** virtualsue left
[11:31] *** laouji_ left
[11:35] *** Kristien joined
[11:35] <sjn> jnthn: hey, about your Oslo trip... would you be up for showing off some cool Perl 6 stuff at Hackeriet (a hackerspace I'm involved with) on that tuesday evening?

[11:36] <sjn> (just a crazy idea, but I think there are a lot of clever people there, and it's nice to get outside of the "usual" Perl bubble now and then :)

[11:38] <jnthn> sjn: Perhaps so. I'm not goig to have a lot of free time to prepare something, otoh I can improvise quite easily... :)

[11:38] <sjn> jnthn: also, http://2015.flatmap.no/ (a conference about functional programming on the JVM, with focus on Scala; CfP is now)

[11:38] *** tengignick left
[11:38] <sjn> jnthn: a tour-de-force of Cool Stuff would be quite sufficient :D

[11:40] <btyler> ls

[11:40] <jnthn> sjn: 'fraid I'm taken in April

[11:40] <jnthn> sjn: So won't be able to make flatMap

[11:40] <jnthn> sjn: I've kept the OSDC.no dates in May free, however :)

[11:41] <sjn> ok, cool

[11:43] <sjn> btyler: No such file or directory

[11:45] <btyler> doh

[11:45] *** tengignick joined
[11:45] * btyler closes the window

[11:46] <tadzik> fun idea: have an irc bot that detects when someone enters a shell command, and then for the rest of the day it replies to that person evaling everything they say

[11:46] *** virtualsue joined
[11:46] *** tengignick left
[11:46] <tadzik> perhaps until they write 'exit' or so :D

[11:47] <moritz> annoybot

[11:48] *** tengignick joined
[11:48] *** tengignick left
[11:49] *** baest_ is now known as baest

[11:53] *** Kristien left
[11:55] <FROGGS> m: use NativeCall; class Foo is repr<CStruct> { }; Foo.new

[11:55] <camelia> rakudo-moar 546000: OUTPUT«(signal SEGV)»

[11:55] <FROGGS> sergot: it even happens for CStructs :o)

[11:55] <FROGGS> sergot: and it is a LHF to fix that actually

[11:57] <FROGGS> sergot: I guess something in here has to be tweaked:

[11:57] <FROGGS> MoarVM/src/6model/reprs/CStruct.c:303:static void compose(...

[11:57] <FROGGS> sergot: err, no, I think initialize is to blame, not compose

[11:57] <FROGGS> but yeah, gdb will know

[12:03] <sergot> FROGGS++

[12:03] <sergot> :)

[12:04] <FROGGS> no, ++sergot

[12:04] <FROGGS> :P

[12:08] <[ptc]> tadzik: you mean like eliza?

[12:08] <tadzik> [ptc]: is that how eliza works? :)

[12:09] <[ptc]> tadzik: basically eliza takes everything you say, turns it around and makes a question out of it

[12:09] <[ptc]> tadzik: but it's been *years* since I've played with it

[12:09] *** larion joined
[12:09] * [ptc] believes it was still in the 90's

[12:10] <tadzik> heheh

[12:12] <moritz> is that how Eliezer works? :-)

[12:13] * colomon remembers reading Eliza source code in Creative Computing in the early 80s…

[12:17] <colomon> http://www.manifestation.com/neurotoys/eliza.php3

[12:17] <colomon> (not what I read then)

[12:17] <[ptc]> omg!  in PHP!

[12:19] *** Ven joined
[12:20] <colomon> javascript, I think

[12:21] <[ptc]> colomon: yup, you're right

[12:21] * [ptc] needs to stop typing faster than he thinks

[12:32] *** kjs_ left
[12:33] *** telex left
[12:34] *** telex joined
[12:34] *** leont joined
[12:38] *** Ven left
[12:40] *** kaare_ joined
[12:43] *** Sysaxed joined
[12:44] *** diana_olhovik left
[12:44] *** diana_olhovik joined
[12:44] *** skids left
[12:45] <Sysaxed> I've just read this https://pypi.python.org/pypi/regex and found out that it kinda supports fuzzy matching (search for "fuzzy" on that page). Is there something like this in perl 6?

[12:46] *** larion left
[12:46] *** larion joined
[12:47] <moritz> not built-in

[12:48] <DrForr_> Someone had a lot of time on their hands.

[12:48] <moritz> and I think it would be pretty hard to do

[12:48] <moritz> since perl 6 regexes are much more geared towards parsing

[12:48] <moritz> though of course you can always write your own regex engine :-)

[12:49] <nine_> raydiak: it's not been my idea, but yes.

[12:51] <Sysaxed> moritz: well, but why cannot it be speced first? The implementation will come some day, even if it takes 15 years, you know :)

[12:52] *** larion left
[12:52] <Sysaxed> not seeing any fuzziness in perl 6 sounds like there is a deeper reason behind it

[12:52] <moritz> Sysaxed: some things are better done exactly :-)

[12:53] <moritz> Sysaxed: and some things are better prototyped/implemented first, and later specified

[12:53] *** larion joined
[12:53] <moritz> most of them, in fact

[12:54] <jnthn> On the page, I only see it being applied to literals

[12:54] <jnthn> oh no

[12:54] <jnthn> Alternations of literals too

[12:54] * jnthn wonders exactly how it's implemented

[12:55] <jnthn> Quite possibly do-able as a module, with sufficient amounts of cunning/evil :)

[12:58] <nwc10> shell out to one of these? :-)

[12:58] <nwc10> http://en.wikipedia.org/wiki/Agrep

[13:00] *** pecastro left
[13:02] * lizmat just hacked something together: https://gist.github.com/lizmat/c54a35f3002ff0eee070

[13:02] <lizmat> the idea is that substr-fields gives you positional access to fields in a string

[13:02] <lizmat> sort of like a substr-rw on steroids

[13:02] *** Ven joined
[13:02] <lizmat> comments / suggestions ?

[13:03] <lizmat> should this live in core, or in a module ?

[13:04] <Ven> "Videos are being processed at the moment. They are added here as they are approved."

[13:04] <Ven> (for fosdem)

[13:07] *** anaeem1 left
[13:08] <DrForr_> Nothing for perl yet, but a few directories are getting populated.

[13:09] *** kjs_ joined
[13:10] *** pecastro joined
[13:11] <nine_> lizmat: can this be then aliased to an object property? So I could parse a config file into an object tree and instead of strings, the properties are substr-fields and I can transparently and non-destructively edit the original configuration through the object tree?

[13:12] *** Ven left
[13:13] <lizmat> if the configuration is a single string, and you can identify the necessary fields by offset / original length, then yes

[13:13] <lizmat> no object tree involved, though

[13:13] <lizmat> internally, it just splits out the parts that are not in a field

[13:13] <lizmat> keeps them in a list, interspersed with the fields

[13:14] <lizmat> you update a field, and the string is recreated by joining all elements of the list

[13:14] <lizmat> the fixed parts are on even elements in the internal list

[13:14] <nine_> lizmat: Match objects to contain the start/end pos. So when making the object tree, instead of assigning the Match object's fields to object attributes, I could assign substr-fields.

[13:14] <lizmat> the variable parts (fields) are on the odd elements of the list

[13:15] <lizmat> sure, I guess that could be another candidate, that takes a Match object ?

[13:16] <jnthn> lizmat: It's a cool idea; feels more module like to me

[13:17] <lizmat> I've also considered making it named fields

[13:18] <lizmat> but getting a Str to listen to postcircumfix{} is a bit more tricky  :-)

[13:18] <Ovid__> A Pythonista who’s been working with Perl for 2 years wrote a blog post about Perl 6: http://ceronman.com/2015/02/23/perl-6-giving-with-one-hand-and-taking-with-the-other/

[13:18] <lizmat> anyway, I put it out here so if anybody wants to run with it, that's fine by me  :-)

[13:20] *** Ven joined
[13:27] *** Ven left
[13:29] <btyler> re Ovid__'s link: ab5tract and I had pretty similar reactions to the context stuff. we're both pretty familiar with perl 5, and both excited about/have written some perl 6, and the context stuff bit us repeatedly in surprising ways over the course of ~6 hours of tandem p6 hacking

[13:30] <btyler> more than once somebody muttered "hopefully that just stops being so surprising after the GLR"

[13:30] <jnthn> Well, the GLR simplifies flattening rules a good bit

[13:31] <Ovid__> I hope so. They mystify me (not that this is a hard thing to do) :)

[13:31] <nine_> +1 for simplifying flattening rules

[13:32] <jnthn> Also Parcel and List get unified

[13:32] *** laouji left
[13:32] <nine_> \o/

[13:32] <btyler> a lot of our surprise had to do with flattening (or not flattening) of things in sub signatures. we didn't really grok destructuring, so it was surprising when (for example) tossing some []s around a sub argument suddenly got us the flattening behavior we were expecting to receive based on the sigil

[13:33] <dalek> rakudo/cpp: 5057b18 | sergot++ | / (3 files):

[13:33] <dalek> rakudo/cpp: add mangling tests

[13:33] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/5057b1844e

[13:34] <tadzik> sergot++

[13:35] <dalek> doc: 928c6c5 | paultcochrane++ | lib/Language/5to6.pod:

[13:35] <dalek> doc: Purge trailing whitespace in 5to6.pod

[13:35] <dalek> doc: review: https://github.com/perl6/doc/commit/928c6c518b

[13:35] <dalek> doc: 92d7bd5 | paultcochrane++ | lib/Language/5to6.pod:

[13:35] <dalek> doc: Move :exists and :delete to new Data Structures section

[13:35] <dalek> doc: review: https://github.com/perl6/doc/commit/92d7bd5ace

[13:39] <dalek> doc: 7aff36d | paultcochrane++ | lib/Language/5to6.pod:

[13:39] <dalek> doc: Wrap overly-long lines to aid readability

[13:39] <dalek> doc: review: https://github.com/perl6/doc/commit/7aff36d95c

[13:41] <FROGGS> sergot++

[13:42] *** dj_goku left
[13:43] *** _mg_ joined
[13:43] *** Ven joined
[13:44] *** _mg_ left
[13:49] *** diana_olhovik left
[13:50] *** diana_olhovik joined
[13:57] <Ven> DrForr_, thanks

[13:59] <DrForr_> Nod. Being at least half responsible for the videos I have some interest in when they go up.

[14:00] <rjbs> I should re-read what I read about the GLR.

[14:00] <rjbs> To me, it looked like it didn't go far enough.

[14:00] <rjbs> but I'm still a bit of an outsider

[14:05] <[Coke]> anyone seen pmichaud?

[14:05] <rjbs> I saw him three weeks ago.  Does that help??

[14:07] <moritz> [Coke]: last on Feb 21st

[14:07] *** andreoss joined
[14:10] <[Coke]> just tried to build nqp-js, got this error:

[14:10] <[Coke]> https://gist.github.com/coke/d1c3d4926d0159972381

[14:11] <[Coke]> looks like a bug in the moarvm build?

[14:12] <[Coke]> oh. Might have just stepped on my own toes.

[14:12] <jnthn> ...wat...

[14:12] <[Coke]> what are the odds that I would run the nqp.js build -while the cron job was running-

[14:13] *** laouji joined
[14:14] <[Coke]> so that's what the build fail looks like when you remove the entire build dir out from under yourself. :)

[14:15] <[Coke]> pmurias++ # nqp.js now included in the daily runs.

[14:16] <[Coke]> hoelzro: any idea why "make js-test" still has building left to do?

[14:16] <jnthn> [Coke]: haha...and phew :)

[14:16] <[Coke]> (did a "make -j all" before that, but "make js-test" is still building things.

[14:17] *** laouji left
[14:19] *** _mg_ joined
[14:20] *** xfix joined
[14:20] *** _mg_ left
[14:20] *** _mg_ joined
[14:22] *** Ven left
[14:22] <hoelzro> [Coke]: I'm not really sure, but I've noticed that too

[14:22] <hoelzro> I just haven't been bugged by it enough to fix it =)

[14:25] <[Coke]> well, it's now going to show up in the daily test output, if that matters> :)

[14:26] <hoelzro> not to me!

[14:27] *** Ven joined
[14:28] *** _mg_ left
[14:30] <moritz> [Coke]: don't use -j for nqp-js

[14:30] <moritz> [Coke]: I think its Makefile is still too immature for that

[14:32] *** lizmat left
[14:32] *** anaeem1_ joined
[14:35] *** skids joined
[14:40] <[Coke]> well, the 'make js-test' catches anything it missed. might be nice to leave it as a canary?

[14:43] *** fhelmberger joined
[14:44] <timotimo> o/

[14:44] *** lizmat joined
[14:44] <timotimo> https://p6weekly.wordpress.com/2015/02/17/2015-07-i-like-trains-fast-trains-that-is/comment-page-1/#comment-293 - someone found a nice little benchmark for us

[14:45] * timotimo looks into how <wb> is implemented

[14:46] <jnthn> timotimo: May be worth timing it with just ".say" also

[14:47] <[Coke]> or say ~$0

[14:47] <timotimo> ah, to find out how slow we iterate over the file?

[14:48] *** andreoss left
[14:52] <timotimo> our -n implementation should possibly pass :eager to the lines() method?

[14:52] * timotimo is just checking out how much faster that ends up being

[14:53] <timotimo> hm, except that may not at all be what the user wants

[14:53] <lizmat> yeah...  :-(

[14:53] <timotimo> also, i was thinking we could perhaps do something quite like boyer-moore if we see something like \w**5

[14:53] <timotimo> but that can also be bad for performance depending on the input data

[14:54] <timotimo> so in order to be worth anything at all, that'd require some self-tuning code

[14:54] <lizmat> have you tried \w\w\w\w\w to see whether that makes a difference 

[14:54] <jnthn> Well, it's not sinking properly, watching the memory use.

[14:54] <timotimo> not yet

[14:54] <timotimo> that's true also, jnthn 

[14:54] <tadzik> jnthn: you have a T430, right?

[14:55] <lizmat> fwiw, I think we need to remember this one and visit post-GLR

[14:55] <dalek> rakudo/cpp: dd53c36 | sergot++ | / (3 files):

[14:55] <dalek> rakudo/cpp: repair mangling tests and add one

[14:55] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/dd53c36344

[14:55] <jnthn> tadzik: T430s

[14:56] <tadzik> jnthn: okay. The funny symbols on F-keys, the lock, moon etc, what colour are they on yours?

[14:56] <jnthn> Um, blue iirc

[14:56] <tadzik> cos I just bought my 3rd replacement keyboard for T430, and each of them has different colour: first had blue, second had black, this new one has white

[14:56] <jnthn> Oh!

[14:56] <tadzik> I wonder how many more variants there are :D

[14:56] <jnthn> :D

[14:56] <FROGGS> time perl6 -n -e 'say $0 if m/(<!>)/' perl6-debug-p.c       # real	0m4.063s

[14:56] <FROGGS> time perl6 -n -e 'say $0 if m/(<<\w**5>>)/' perl6-debug-p.c # real	0m4.528s

[14:56] <jnthn> You've had to replace the keyboard?

[14:57] <tadzik> yeah, I poured water over the one with black labels

[14:57] <muraiki> does the latest rakudo include nativecall, or has that not yet gone into master? I looked at the release notes and didn't see mention of it

[14:57] <tadzik> as for the first one, with blue.... have you seen the way I type? :D

[14:57] <FROGGS> time perl6 -n -e 'say $0 if m/<!>/' perl6-debug-p.c # real	0m2.971s

[14:57] <tadzik> I wrecked the scissors in it

[14:58] <jnthn> muraiki: Yes; it was mentioned in the announce

[14:58] <lizmat> muraiki: the 2015.02 compiler release states:

[14:58] <lizmat> + The NativeCall module (for incorporating external libraries as Perl 6

[14:58] <lizmat>   subs) is now part of the compiler distribution.  To activate it, one

[14:58] <lizmat>   must still do a "use NativeCall", but it does *not* have to be installed

[14:58] <lizmat>   with panda anymore.  If you are a module developer, you can now remove

[14:58] <lizmat>   NativeCall as a prerequisite from the meta information of your distribution.

[14:58] <muraiki> this announce? http://rakudo.org/2015/02/21/announce-rakudo-star-release-2015-02/

[14:59] <FROGGS> muraiki: seems the compiler release states it but not the star release

[14:59] <muraiki> oh, that explains things :)

[14:59] <moritz> it intentionally doesn't

[14:59] <muraiki> sorry, I should have checked that too

[14:59] <jnthn> muraiki: Star always came with NativeCall anyway

[14:59] <moritz> if you use star, you have NativeCall

[14:59] <timotimo> masak: can you explain the "octopus mayor (?)" thing in that tweet you RT'd?

[14:59] <moritz> and you don't have to care where it comes from

[15:00] <jnthn> FROGGS: What's the difference between that last timing and the first one you posted?

[15:00] <tadzik> IO::Socket::SSL still fails tests for me, hrm

[15:01] <FROGGS> jnthn: it does not capture

[15:01] <masak> timotimo: it's just a hilarious situation.

[15:01] <timotimo> jnthn: i suppose it just shows that the iteration itself is taking the biggest chunk of time?

[15:01] <jnthn> FROGGS: Ah

[15:01] <masak> timotimo: the "octopus mayor" thing doesn't quite measure up to the first thing he wrote.

[15:02] <jnthn> timotimo: Seems so

[15:02] <timotimo> at first i thought it said /(<|>)/ because of my somewhat poor font and/or size and i was wondering "what the heck is that regex" %)

[15:02] <jnthn> timotimo: I guess lines() will be a LoopIter after GLR

[15:02] <timotimo> yeah

[15:02] <timotimo> or maybe even use LinesAsync

[15:03] <timotimo> so i just tested :eager vs no :eager

[15:03] <timotimo> and the time difference is

[15:03] <FROGGS> let's add that microbenchmark to pmichaud's ticket

[15:03] <timotimo> m: say (152 + 5) / (162 + 6)

[15:03] <camelia> rakudo-moar 546000: OUTPUT«0.934524␤»

[15:03] <timotimo> 7%

[15:03] <timotimo> the loop itself is just doing print "."

[15:04] *** [Sno] left
[15:05] <lizmat> wonder how much of the real time delay is caused by just printing...

[15:06] * timotimo lets the loop do nothing instead

[15:06] <timotimo> this is a 50mb file, btw

[15:08] <jnthn> lizmat: Well, at the moment say isn't the most efficient thing

[15:08] <jnthn> lizmat: Though that's fixable.

[15:09] *** larion left
[15:14] <timotimo> yeah, the overhead say has seems to be pretty severe

[15:15] <timotimo> with "1 + 1 for lines()" vs "1 + 1 for lines() :eager" i don't get a noticable difference at all

[15:15] <timotimo> but now it takes only 117 seconds rather than 160

[15:20] *** laouji joined
[15:28] *** Ven left
[15:32] <dalek> rakudo/newio: 4659f32 | lizmat++ | t/04-nativecall/01-argless.c:

[15:32] <dalek> rakudo/newio: Fix compiler warnings on OS X / JVM backend

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/4659f32c70

[15:32] <dalek> rakudo/newio: 9b00cce | lizmat++ | /:

[15:32] <dalek> rakudo/newio: Merge branch 'nom' into newio

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/9b00ccea6c

[15:32] <dalek> rakudo/newio: 629f5a4 | TimToady++ | src/Perl6/Grammar.nqp:

[15:32] <dalek> rakudo/newio: bare say now complains about no valid arg

[15:32] <dalek> rakudo/newio: 

[15:32] <dalek> rakudo/newio: (since it might be an invalid arg rather than a missing arg).

[15:32] <dalek> rakudo/newio: The help message for bare say et al. is demoted to a worry.

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/629f5a4b3b

[15:32] <dalek> rakudo/newio: f84e536 | TimToady++ | src/Perl6/World.nqp:

[15:32] <dalek> rakudo/newio: don't claim TTIAR if 2nd term failed to parse

[15:32] <dalek> rakudo/newio: 

[15:32] <dalek> rakudo/newio: It's just a bogus term if it can't parse it...

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/f84e536383

[15:32] <dalek> rakudo/newio: 546000b | TimToady++ | src/Perl6/Grammar.nqp:

[15:32] <dalek> rakudo/newio: don't panic, just be sorry (on bare say etc.)

[15:32] <dalek> rakudo/newio: 

[15:32] <dalek> rakudo/newio: This allows the new bogus term message to show when appropriate.

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/546000b908

[15:32] <dalek> rakudo/newio: 6ea2a6f | lizmat++ | src/Perl6/ (2 files):

[15:32] <dalek> rakudo/newio: Merge branch 'nom' into newio

[15:32] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/6ea2a6fbaf

[15:36] *** Ven joined
[15:39] <lizmat> commute to NR.pm meeting&

[15:39] *** lizmat left
[15:43] *** FROGGS left
[15:47] *** [Sno] joined
[15:48] *** mr-foobar joined
[15:49] <dalek> doc: a646a74 | paultcochrane++ | lib/Type/IO.pod:

[15:49] <dalek> doc: Link run, shell subs to non-internal location

[15:49] <dalek> doc: 

[15:49] <dalek> doc: This is because when viewing the per-routine file (e.g. run.html), the

[15:49] <dalek> doc: location of the "sub shell" link doesn't exist.  By linking to the full

[15:49] <dalek> doc: location one is always able to reach the linked documentation.

[15:49] <dalek> doc: review: https://github.com/perl6/doc/commit/a646a748dc

[15:56] *** Ven left
[15:57] *** Ven joined
[16:05] *** gfldex joined
[16:05] <[ptc]> did spurt-ing to an open IO::Handle only become deprecated recently?

[16:06] <timotimo> like three months ago or something?

[16:06] <timotimo> maybe two

[16:06] <[ptc]> it's just I'm getting deprecation warnings with (documented0 code which worked a couple of weeks ago

[16:06] <[ptc]> hrm

[16:06] * [ptc] wonders why he didn't see that before

[16:06] <[ptc]> timotimo: thanks.  I'll update the docs where necessary

[16:07] <timotimo> thank you, i'll find the appropriate commit in the mean time

[16:07] <timotimo> * | | | | | | 9a6501a - Deprecate IO::Handle.spurt (5 months ago) <Elizabeth Mattijsen>

[16:07] <timotimo> that should be it, right?

[16:08] <moritz> when you have a handle, you can just .print to it, no?

[16:08] <[ptc]> timotimo: that's weird!  I tried out the code I documented (in IO.pod) and didn't get this warning until starting to work with it again today

[16:09] <[ptc]> moritz: that was going to be my next question :-)

[16:09] <[ptc]> I'm just really confused as to why I didn't see this before...

[16:09] <timotimo> did you try it in the REPL perhaps? :)

[16:10] <[ptc]> timotimo: that's probably it

[16:10] <[ptc]> do the warnings not appear in the REPL?

[16:10] <timotimo> they appear when the program exits

[16:10] <[ptc]> ah

[16:11] <timotimo> we want them to not disturb programs that are running

[16:11] *** FROGGS joined
[16:11] <PerlJam> S32/IO:201 needs to be updated looks like

[16:11] <synopsebot> Link: http://design.perl6.org/S32/IO.html#line_201

[16:12] <[ptc]> moritz: should one .print to an IO::Handle, or .write to it?

[16:12] <[ptc]> moritz: I don't find .print in the IO::Handle docs

[16:13] <moritz> [ptc]: .write would be for Blob/Buf, iirc

[16:13] <moritz> [ptc]: and .print for Str

[16:13] *** Ven left
[16:13] *** Ven joined
[16:13] <[ptc]> moritz: k, thanks :-)

[16:14] <PerlJam> oh, that's the spurt function, not the method.

[16:15] *** Ven left
[16:16] *** Ven joined
[16:21] <muraiki> I'm trying to install Inline::Perl5 via panda, but when tests are run I repeatedly get: "Cannot locate native library '/usr/home/staff/muraiki/.panda-work/1424794724_2/blib/lib/Inline/p5helper.so'"

[16:21] <muraiki> sorry if this isn't the right place to ask about this... but I figure it's related to nativecall?

[16:21] *** laouji left
[16:22] <timotimo> LibraryMake is supposed to compile that for you

[16:22] <muraiki> hrm

[16:22] <timotimo> maybe you lack a perl-dev package?

[16:22] <dalek> doc: ec25269 | paultcochrane++ | lib/ (2 files):

[16:22] <dalek> doc: Replace spurt with print when writing to an IO::Handle

[16:22] <dalek> doc: review: https://github.com/perl6/doc/commit/ec25269fcd

[16:22] <dalek> doc: 2a0049a | paultcochrane++ | lib/Type/IO/ (2 files):

[16:22] <dalek> doc: Mention print method in IO::Handle

[16:22] <dalek> doc: review: https://github.com/perl6/doc/commit/2a0049a3f1

[16:25] *** lucas__ joined
[16:25] <lucas__> Hey there o/

[16:26] <timotimo> hi lucas

[16:26] <lucas__> So, a "my" declaration acts like the same thing as a subroutine signature, right?

[16:27] <timotimo> you mean in terms of "unpacking" aka "destructuring"?

[16:27] <lucas__> I mean in terms of allows values in addition to variables, so that it can pattern match

[16:27] <lucas__> Since signatures allow this, my declarations too:

[16:28] <lucas__> m: my (True, False); say 'alive'

[16:28] <camelia> rakudo-moar 546000: OUTPUT«alive␤»

[16:28] <muraiki> timotimo: ah, looks like my p5 version is too old :(

[16:28] <lucas__> but using just one value instead of a list, it gives an error:

[16:28] <lucas__> m: my (True) = 42; say 'alive'

[16:28] <camelia> rakudo-moar 546000: OUTPUT«alive␤»

[16:28] <lucas__> m: my True = 42; say 'alive'

[16:28] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5===␤Type 'True' is not declared␤at /tmp/PDaBLTD9D6:1␤------> 3my True 7⏏5= 42; say 'alive'␤Malformed my␤at /tmp/PDaBLTD9D6:1␤------> 3my True 7⏏5= 42; say 'alive'␤␤»

[16:29] *** mjreed joined
[16:29] *** prammer joined
[16:30] <lucas__> I've already brought this up some weeks ago

[16:31] <lucas__> Is there any chances that things like this can become an error?

[16:31] <lucas__> m: my (True $x, False $y, Inf, NaN) = 1,2,3; say 'alive'

[16:31] <camelia> rakudo-moar 546000: OUTPUT«alive␤»

[16:31] <timotimo> ouch

[16:31] <timotimo> that's a bit weird

[16:32] <mjreed> trying to destructure in a pointy block and getting an error; what am I doing wrong with the syntax? 

[16:32] <mjreed> m: [1,2,3].kv.grep(-> ([$k,$v]) { $v%2 })

[16:32] <camelia> rakudo-moar 546000: OUTPUT«Unhandled exception: Too few positionals passed; expected 1 argument but got 0 in sub-signature␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/nqp/lib/Perl6/BOOTSTRAP.moarvm:bind_sig:4294967295)␤ from /tmp/MFsbXAn8Ku:1  (<ephemeral file>::12…»

[16:34] *** zakharyas left
[16:35] <japhb> m: [1,2,3].pairs.grep(-> (:$key, :$value) { $value%2 })

[16:35] <camelia> rakudo-moar 546000: ( no output )

[16:35] <timotimo> oh

[16:35] <japhb> m: [1,2,3].pairs.grep(-> (:$key, :$value) { $value%2 }).say

[16:35] <camelia> rakudo-moar 546000: OUTPUT«0 => 1 2 => 3␤»

[16:35] <timotimo> it must be because grep doesn't know how many arguments to pass

[16:35] <japhb> mjreed: ^^

[16:36] <skids> Is that a bug, should grep sense arity?

[16:36] <mjreed> should it need to?

[16:36] <timotimo> grep is supposed to sense arity, like map and for and such

[16:36] <japhb> skids: If it did, which argument would it return?

[16:36] <mjreed> kv produces an array of pairs

[16:36] <skids> japhb: both

[16:36] <mjreed> so the block should get an array of two elements

[16:36] <mjreed> I just want to pull them into separate vars

[16:36] <japhb> skids: Are you sure that DWIMs?

[16:37] <timotimo> so ... unexpected flattening?

[16:37] <skids> Well, obviously the current way doesn't do anything useful.

[16:37] <japhb> m: [1,2,3].kv.grep(-> ($key, $value) { $value%2 }).say

[16:37] <camelia> rakudo-moar 546000: OUTPUT«Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at /tmp/dHpkLXwDSG:1␤␤»

[16:37] <mjreed> if grep sensed arity, then { -> $k, $v } would work.  But I’m fine with having to destructure.  I just need to know how to make that work. :)

[16:37] <japhb> m: [1,2,3].kv.grep(-> $ ($key, $value) { $value%2 }).say

[16:37] <camelia> rakudo-moar 546000: OUTPUT«Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at /tmp/0CDE3sQPkg:1␤␤»

[16:38] <japhb> m: [1,2,3].kv.grep(-> $key, $value { $value%2 }).say

[16:38] <camelia> rakudo-moar 546000: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/FudGXhudM0:1␤␤»

[16:38] <japhb> Hmmm

[16:38] <skids> mjreed: the .kv produces a list of k,v,k,v so grep is run once on each k and once on each v

[16:38] <mjreed> oh, kv flattens

[16:38] <japhb> mjreed: Yes

[16:38] <mjreed> ?

[16:38] <skids> So to destructure you need to use .pairs.

[16:39] <mjreed> doens’t look like it

[16:39] <flussence> m: [1,2,3].pairs.grep(-> :(:$key, :$value) { $value%2 }).say #?

[16:39] <camelia> rakudo-moar 546000: OUTPUT«Too many positionals passed; expected 0 arguments but got 1␤  in block <unit> at /tmp/bSj4w3w4Ng:1␤␤»

[16:39] <japhb> ... which is what I showed at the top

[16:39] <mjreed> m: [1,2,3].kv[0]

[16:39] <camelia> rakudo-moar 546000: ( no output )

[16:39] <mjreed> 0 1

[16:39] <japhb> m: [1,2,3].kv[0].say

[16:39] <camelia> rakudo-moar 546000: OUTPUT«0 1␤»

[16:39] <japhb> m: [1,2,3].kv[2].say

[16:39] <camelia> rakudo-moar 546000: OUTPUT«2 3␤»

[16:40] <PerlJam> mjreed: the error you got was probably from grep running off the end of your list

[16:40] <japhb> That's ... not what I expected

[16:40] <timotimo> .kv is a way to get the value that you've calculated inside the [ ] back

[16:41] <japhb> m: {a => 12, b => 42}.kv.perl.say

[16:41] <camelia> rakudo-moar 546000: OUTPUT«("a", 12, "b", 42).list␤»

[16:41] <japhb> m: [1,2,3].kv.perl.say

[16:41] <camelia> rakudo-moar 546000: OUTPUT«((0, 1), (1, 2), (2, 3)).list␤»

[16:41] <japhb> OK, that's just confusing

[16:41] <skids> OK so it must be grep that's flatenning?

[16:41] <mjreed> my understanding is that .kv produces ( [k,v], [k,v], [k,v] ) as an array, while .pairs produces ( k => v, k => v, k => v ) as a hash.

[16:42] <timotimo> not as a hash

[16:42] <[Coke]> rakudo moar and moar-jit failing differently.

[16:42] <[Coke]> (in daily spectest run)

[16:42] <flussence> m: [7,4,9,1].pairs.grep(-> (:$key, :$value) { $value%2 }).say # looks correct to me

[16:42] <camelia> rakudo-moar 546000: OUTPUT«0 => 7 2 => 9 3 => 1␤»

[16:42] <dalek> perl6-roast-data: ad86ae6 | coke++ | / (9 files):

[16:42] <dalek> perl6-roast-data: today (automated commit)

[16:42] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ad86ae6b4f

[16:43] <japhb> I always saw .kv as producing (k, v, k, v), but clearly Array.kv disagrees

[16:43] <japhb> But whatever it does, it really ought to produce the same structure for both Associative and Positional objects

[16:44] *** diana_olhovik left
[16:45] <mjreed> m: (*.kv, *.pairs).map( { [1,2,3].$_.WHAT.say } )

[16:45] <camelia> rakudo-moar 546000: OUTPUT«(List)␤(List)␤»

[16:45] <mjreed> m: (*.kv, *.pairs).map( { [1,2,3].$_[0].WHAT.say } )

[16:45] <camelia> rakudo-moar 546000: OUTPUT«(Parcel)␤(Pair)␤»

[16:48] <mjreed> anyway,  ran across this while trying to solve this more general problem: what’s the perl6ish way to find the indexes of all array elements matching a condition?

[16:48] <PerlJam> mjreed: grep-index?

[16:49] <mjreed> oh.

[16:49] <mjreed> well, that’s far too easy.

[16:50] <TimToady> grep-index may go away in favor of grep with a :k modifier

[16:50] <PerlJam> (though, personally, I don't like any of the *-index routines)

[16:50] <[ptc]> moritz: have analysed how many lines of documentation have been added to the doc repo over time: roughly 10000 lines since this time last year!

[16:50] <[ptc]> moritz: the trend is also exponential :-)

[16:51] <PerlJam> TimToady: I assume the same for first, last, and map?

[16:51] <timotimo> TimToady: that'd also mean we coul dhave a :kv and :pairs modifiers

[16:51] <TimToady> probably not map

[16:52] <PerlJam> (yeah, maybe the hobgolbin of foolish consistency got me there :)

[16:56] <PerlJam> TimToady: when we get user-defined indices, will grep :k give the user-defined indices or the "real" indices?  (and how would you specify which you want?)

[16:57] <PerlJam> (or is that post 6.0 enough to not think too much about yet)

[16:57] <TimToady> for arrays that take both [] and {}, it could well depend on which of those you choose

[16:57] <TimToady> that doesn't help grep

[16:58] <TimToady> it's also not entirely clear which way the user would want as default

[16:58] *** Ven left
[17:00] <PerlJam> I would guess that if the user went through the trouble to create their own indices, they did so because they want to use them "by default"

[17:01] <TimToady> that's my gut feel too, but it's also still possible that user-defined indices are more trouble than they'll be worth

[17:01] <PerlJam> (i.e. it helps in thinking about the problem domain in terms of itself)

[17:01] <TimToady> we'll have to prototype 'em after we get the S

[17:02] <TimToady> and they can be post 6.0 if we're not sure

[17:02] *** perl6_newbee joined
[17:05] <timotimo> the S?

[17:05] <TimToady> of NSA

[17:06] <timotimo> ah

[17:06] <timotimo> of course

[17:06] <raydiak> strings? :)

[17:08] <TimToady> shapes

[17:09] <TimToady> there's a problem with our declarative syntax for user-defined indices though

[17:09] <TimToady> it only works at the top level of @foo{@keys}

[17:10] <TimToady> what if you want your second-level of @foo[3,*] to have user-defined keys?

[17:10] <TimToady> we'll have to ponder that

[17:10] * jnthn wonders if user-defined keys really need to be in 6.0

[17:10] <TimToady> we do have the notion of @foo[3]{@keys}, but that would only make a hash, not an array with hash aliases

[17:11] <TimToady> we just said that :)

[17:11] <PerlJam> jnthn: I don't think they do.

[17:11] <TimToady> just don't want to mess up our declarative syntax in advance

[17:11] <jnthn> Good point. :)

[17:12] <jnthn> I'm focusing on the N for now. Then will likely focus on NFG. Then come to the S :)

[17:12] <PerlJam> Right now, I get a general feeling similar to P5's $[ or BASIC's option base  ... it seems like a good feature until you start to use it  :)

[17:12] <jnthn> By the way, the answer to "does the order of codepoints matter" has an interesting answer. 

[17:12] <jnthn> Order of combining ones, that is.

[17:13] <jnthn> The Unicode spec actually defines a sorting algo.

[17:13] <TimToady> you sure that's not just for collation?

[17:14] <TimToady> 'cause certainly within certain categories, order will matter for stacking

[17:14] <jnthn> It's described in the normalization docs.

[17:14] <jnthn> For how is NFC formed

[17:15] <jnthn> http://www.unicode.org/reports/tr15/tr15-41.html#Canon_Compat_Equivalence

[17:15] <leont> What's the name of the principle of putting the most important bits of a line at the start (in code or prose)?

[17:15] <TimToady> end-weight is close to right

[17:16] <TimToady> except the "heavy" end is kinda wrong

[17:16] <TimToady> I don't think we have a name for that one really

[17:17] <PerlJam> TimToady: "perspective"  :)

[17:17] <flussence> call it "semantic centre of gravity" if you want to sound smart

[17:17] <TimToady> Important Words First--Argh!

[17:18] <TimToady> "I have to tell you who the murderer is...<bang>"

[17:18] <TimToady> (courtesy of Connie Willis)

[17:18] <japhb> .oO( "This isn't that kind of movie." )

[17:18] <TimToady> as opposed to "Steve done it! <bang>"

[17:19] *** Kristien joined
[17:19] *** _mg_ joined
[17:19] <TimToady> or we could think of it as marginalization of the less important stuff to the right

[17:20] <Kristien> hi

[17:20] <TimToady> \o

[17:21] *** lizmat joined
[17:22] *** laouji joined
[17:22] <Kristien> What do you think of significant newlines?

[17:23] <PerlJam> Kristien: you just want to elide some trailing semicolons?

[17:24] <Kristien> For example.

[17:24] <PerlJam> sounds like we lose a synchronization point

[17:24] <PerlJam> (or there's just more guessing involved)

[17:25] <timotimo> a synchronization point many "modern" languages have decided against, fwiw

[17:25] <timotimo> i haven't forgotten a semicolon in a loooong time, though

[17:25] <Kristien> I guess the argument is similar as the one for significant indentation: you do it anyway (newlines and indents).

[17:26] *** _mg_ left
[17:26] <Kristien> I've been thinking of an alternative to S-expressions which depends on significant newlines.

[17:26] <Kristien> A superset.

[17:26] *** laouji left
[17:27] <TimToady> .oO(now you have two problems)

[17:27] <PerlJam> timotimo: many modern languages don't have or require the moral equivalent to "my" either  :)

[17:27] <TimToady> human languages need redundancy

[17:28] <TimToady> a language without redundancy forces the user to think like a computer

[17:28] *** raiph joined
[17:28] <timotimo> hehe

[17:28] <TimToady> some people don't mind thinking like computers, of course

[17:28] <Kristien> my introduces a declaration, which is good.

[17:28] <PerlJam> yeah, but it also has to balance against DRY.   Language design is a fiddly business.

[17:29] <TimToady> so you make the repetitive bits Very Short

[17:29] <TimToady> like "my"

[17:29] <TimToady> or {}

[17:29] <TimToady> or ;

[17:29] <Kristien> As much as possible must be specified in code, including parameter and return types, preconditions, postconditions and throwable exceptions.

[17:29] <huf> eh, my isnt repetitive or something you do _for_ the compiler

[17:29] <TimToady> that's why I don't like begin/end

[17:29] <timotimo> Actually the difference between those two is that the “list assignment” version of = has looser precedence that the comma operator, while the “scalar assignment” version of = has tighter precedence than the comma operator.

[17:29] <timotimo> i don't understand this -^

[17:30] <TimToady> when I first saw C, I said to meself, "They get these lovely tiny begin and end brackets, and then they ruin it all by making them *optional* on single statements?"

[17:31] <TimToady> which is why they're not optional on if/else in Perl

[17:31] <huf> TimToady: but they'd need an elseif keyword then!

[17:31] <huf> if the {} were mandatory

[17:31] *** _mg_ joined
[17:31] <TimToady> not really

[17:31] <TimToady> but I'm glad we never made them optional, because it's the () that wanted to be optional all along

[17:31] <huf> what, you'd put a space in the middle of a keyword?

[17:31] <PerlJam> TimToady: amen!

[17:32] <huf> yeah, they already had ?: if you wanted to drop the {} :)

[17:34] <Kristien> huf just like SQL!

[17:35] <huf> sorry, i cant just like sql

[17:36] <timotimo> i can't. just like sql.

[17:36] <TimToady> timotimo: the difference in precedence is mainly so you can say loop (my $i = 1, my $j = 'a'; $i; $i++, $j++) {}

[17:36] <alpha-> sql is good

[17:36] <Kristien> Go solves that problem by defining else clause as: 'else' <compound-stmt> | 'else' <if-stmt>

[17:36] <huf> alpha-: sql is pretty neat yeah, except for the language :)

[17:36] <Kristien> Although I find else–if incredibly ugly (conditions don't line up), and I want cond/switch true instead.

[17:36] <alpha-> huf I love writing sql

[17:37] <alpha-> so much I won't ever touch any ORM stuff

[17:37] <Kristien> SQL is shit. You need coalesce everywhere you use sum, because sum returns null instead of 0 for the empty sum.

[17:38] <TimToady> some designers don't understand the need for well-behaved degenerate cases...

[17:38] <Kristien> Introducing arbitrary special cases is a bad idea.

[17:38] <PerlJam> Kristien: that's what Date and Codd said about NULL  :)

[17:38] <Kristien> I've seen people return null instead of the empty array for functions like fetchAllProducts() when there are no products :(

[17:38] <TimToady> they don't think of it as special, they think of it as nobody in their right mind would do that, so make it illegal

[17:38] <timotimo> fair enough, i guess

[17:40] *** rurban left
[17:40] <raydiak> m: my @list = 1, my $scalar = 2, 3; say $scalar; say @list # precedence of = vs =

[17:40] <camelia> rakudo-moar 546000: OUTPUT«2␤1 2 3␤»

[17:40] <xfix> Kristien: You would think that it's because aggregates in SQL work like that, but...

[17:40] <xfix> SELECT count(*) FROM empty_table; -- returns 0, properly

[17:40] <xfix> Like, I don't understand why aggregates other than count cannot do this properly.

[17:41] <xfix> But I guess the idea was that if there are no elements, then there is no data.

[17:41] <TimToady> well, nobody expects consistency from a committee, or if they do, they shouldn't...

[17:41] <lizmat> let's put that to a vote :-)

[17:42] *** amaliapomian joined
[17:43] <xfix> In SQL, NULL means "unknown". It has confusing name, but SQL uses it pretty consistently.

[17:44] <Kristien> SQL shouldn't have null. It should've had an option type constructor.

[17:44] <mjreed> Hasql

[17:44] <Kristien> And it should have been much more modeled like set theory and relational algebra.

[17:44] <xfix> I may agree here, because NULL introduces open world assumption into closed world assumption.

[17:45] <Kristien> aggregates can just be functions that take bags and return values

[17:46] <Kristien> and you could call them like sum(map(user => age(user.birthday), users))

[17:46] *** kjs_ left
[17:46] <Kristien> that's the kind of SQL I'd like

[17:46] <xfix> Although, compared to alternatives, SQL is not bad. It does what it meant to do.

[17:47] <Kristien> (lol, summing the age of all users)

[17:48] *** adu joined
[17:48] <xfix> SELECT sum(age) FROM users WHERE favorite_language = 'Perl 7' -- we don't know... uhm... return NULL?

[17:48] <xfix> I guess this is sort of insanity that convinced them that aggregates of nothing should return NULL.

[17:50] <Kristien> even in PHP array_sum([]) returns 0 :P

[17:50] <xfix> Even if it doesn't make sense. If you work under open world assumption, you may as well return NULL everytime, because you don't have enough data.

[17:52] *** lucas__ left
[17:53] <TimToady> maybe we should talk about lists as natural, flat, or sharp

[17:53] <TimToady> a natural list is what any method gets as its invocant after GLR

[17:54] *** grettir joined
[17:54] <TimToady> functions can decide what kind of list they get

[17:55] <TimToady> and we need to do a better job of explaining why context is lazy, unlike in Perl 5

[17:56] <TimToady> .oO( but I'm too lazy to explain now :)

[17:58] <perl6_newbee> hi guys

[17:59] <perl6_newbee> sorry for silly newbee questions: But why are the variadic parameter shown at the end of the USAGE message? Bug?

[17:59] <perl6_newbee> Usage: pdms.p6 [--file=<Str>] [--category=<Str>] [--tags=<Str>] [--date=<Str>] add

[18:00] <mjreed> so what would constitute a ♭ or ♯ list?

[18:01] *** dakkar left
[18:02] *** Quom is now known as Mouq

[18:04] *** _mg_ left
[18:06] <Sysaxed> TimToady: Hi! I have asked this question a bit earlier today, but got something like "nah it's too hard" as an answer. Have you thought about fuzziness in perl 6 rules? There is something like that in python "regex" module, so it shouldn't be too hard, I guess. I'm just curious if there are any other fundamental reasons not to have fuzziness

[18:06] <jnthn> perl6_newbee: I think it's by design rather than a bug

[18:07] <PerlJam> .oO( bug by design? )

[18:07] <perl6_newbee> lol

[18:07] <jnthn> PerlJam: Possibly :P

[18:07] <perl6_newbee> I don't like the design :-) and hoped it wis a bug

[18:07] <Sysaxed> TimToady: the python thing I am talking about is here https://pypi.python.org/pypi/regex

[18:08] <jnthn> Better put: I think Rakudo implements the current design correctly in this regard. I also know folks wanting to do subcommand-y interfaces find this a pain.

[18:08] *** fernand__ joined
[18:10] *** virtualsue left
[18:10] <PerlJam> Sysaxed: That seems an odd fit for regex to me (as part of the language proper).  But we *can* execute arbitrary perl code, so the fuzzy match could happen there if needed.

[18:12] <timotimo> hoelzro has been working on a module named "subcommander"

[18:12] * hoelzro needs to finish that module

[18:12] <hoelzro> hell, /me needs to pick one thing to help with and stick with it.

[18:12] *** fernand__ left
[18:13] <skids> Something akin to "partial" match feature listed at that URL is also something I'd like to see in an rx enhancement module.  For parsing un-tab-completed cli input where you know the tab-completion rules (e.g. cisco config snippets)

[18:14] *** kjs_ joined
[18:16] *** diana_olhovik_ joined
[18:19] *** locsmif left
[18:19] *** mjreed left
[18:20] *** raiph left
[18:22] * TimToady -> pick up his 90yo mom from ferry to show off her great-grandkid

[18:22] <colomon> TimToady++

[18:22] <dalek> roast/newio: caf44a2 | lizmat++ | S32-io/chdir.t:

[18:22] <dalek> roast/newio: Get chdir() test up to (newio) spec

[18:22] <dalek> roast/newio: review: https://github.com/perl6/roast/commit/caf44a23a0

[18:23] *** laouji joined
[18:28] *** laouji left
[18:28] *** Rounin joined
[18:29] * Kristien can't bear children :v

[18:29] *** wicope left
[18:29] *** Kristien left
[18:32] *** wicope joined
[18:38] *** larion joined
[18:39] *** jluis joined
[18:44] <Mouq> moritz++ # lots of stuff

[18:48] *** geekosaur left
[18:50] *** geekosaur joined
[18:52] *** mohij joined
[18:52] *** telex left
[18:54] *** telex joined
[18:58] *** dolmen joined
[18:59] *** espadrine left
[19:00] *** perl6_newbee left
[19:13] *** echowuhao joined
[19:18] *** _mg_ joined
[19:23] *** ilbot3 left
[19:23] *** ilbot3 joined
[19:28] *** dwarring joined
[19:29] *** xfix_ joined
[19:29] *** xfix left
[19:29] *** xfix_ is now known as xfix

[19:31] *** colomon left
[19:32] *** pecastro left
[19:32] *** rurban joined
[19:32] *** dolmen left
[19:32] *** espadrine joined
[19:35] *** Sir_Ragnarok left
[19:35] *** Kristien joined
[19:36] <Kristien> hi there

[19:36] <raydiak> hello

[19:37] <Kristien> I have yet to find a Freenode channel with people as kind as the ones in this one.

[19:38] <Kristien> <3

[19:38] *** Sir_Ragnarok joined
[19:39] <raydiak> #perl6++ :)

[19:41] * moritz updated https://www.openhub.net/p/p6doc a bit

[19:43] <Kristien> people in #scala and #clojure tend to be muh functional 31337zor :[

[19:43] <Kristien> moritz: nice

[19:43] <moritz> Kristien: I've heard good things about the Haskell community too

[19:43] <Kristien> I know nothing about it. :P

[19:46] *** colomon joined
[19:48] <timotimo> trolling people on #haskell seems to have no side-effects

[19:48] *** __zug__ joined
[19:49] <Sysaxed> :))

[19:49] <timotimo> SCNR

[19:49] <Kristien> timotimo: I have a solution for that

[19:50] *** Pleiades` left
[19:50] <jnthn> .oO( You can safely complain on #haskell under a moanad... )

[19:51] <Kristien> id $! unsafePerformIO troll

[19:51] <Kristien> unsafePerformIO is impure!

[19:52] <raydiak> if only more dev communities understood the value of humanity...attitude in #perl was one of my primary motivations for coming to #perl6 and adopting Perl 6...if that isn't shooting yourself in the foot, idk what is :)

[19:52] <vendethiel> #perl6++ :P

[19:53] <Kristien> that's a comment

[19:53] <Kristien> the increment is ignored

[19:53] <vendethiel> nope, in this land, identifiers are allowed to contain pounds

[19:53] <vendethiel> IT'S PERL6, WHACHUGONNADO :P. 

[19:53] <Kristien> that's sharp

[19:54] <vendethiel> .oO( not scream, to start with )

[19:55] *** Pleiades` joined
[19:57] *** raiph joined
[19:58] <moritz> in #perl6, nobody can hear you SCREAM

[20:04] <timotimo> in #perl6 nobody can hear you MONKEY_TYPING

[20:06] <Kristien> fun fact: in Scala, List(1, 2, 3).toSet() returns false

[20:07] *** diana_olhovik_ left
[20:09] <Kristien> Since .toSet is a parameterless method, this is actually parsed as (List(1, 2, 3).toSet).apply(())

[20:09] <Kristien> where () is the instance of Unit, and apply on a Set[T] returns whether the set contains the argument (hence false)

[20:09] <Kristien> since () is a different type than Int, the set is upcast to Set[Any] and then the element is looked up, that’s why it’s not a type error

[20:10] <Kristien> s/()/Unit/

[20:11] <hobbs> joy?

[20:13] <Kristien> It's a nice thing to confuse newcomers with. :)

[20:13] <geekosaur> scala's scary

[20:14] <vendethiel> *g*

[20:15] <dalek> doc: 559c22c | moritz++ | CONTRIBUTING.md:

[20:15] <dalek> doc: start file CONTRIBUTING.md

[20:15] <dalek> doc: 

[20:15] <dalek> doc: inpired by #51

[20:15] <dalek> doc: review: https://github.com/perl6/doc/commit/559c22c838

[20:15] *** kjs_ left
[20:17] <vendethiel> Kristien: auto-tupling is terrible :)=

[20:17] <Kristien> vendethiel: fun fact: in Scala, { for (Seq(x, y, z) <- xs) yield x + y + z } and { xs map { case Seq(x, y, z) => x + y + z } } can have different results, even though for uses map internally. :)

[20:17] <vendethiel> flatMap

[20:17] <vendethiel> isn't it?

[20:18] <Kristien> for ignores match errors, but map doesn't, so the former skips Seqs that aren't of length 3 and the second one will throw a match error

[20:20] *** echowuhao left
[20:20] <vendethiel> Kristien: through typelevel/Scala fixed that :)

[20:21] <japhb> .tell perl6_newbee I implemented (the first version of) the MAIN parser and USAGE generator, as close as I could manage to spec at the time.  I am also one of the people that thinks we really should natively support subcommand interfaces, since I think that's actually what people expect now.  I was overruled.

[20:21] <yoleaux> japhb: I'll pass your message to perl6_newbee.

[20:22] *** virtualsue joined
[20:26] *** darutoko left
[20:27] *** bjz left
[20:27] <Kristien> m: sub singleton($x) } 

[20:27] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JfjiRvW7hq␤Missing block␤at /tmp/JfjiRvW7hq:1␤------> 3sub singleton($x) 7⏏5}␤    expecting any of:␤        new name to be defined␤»

[20:27] <Kristien> stupid keyboard

[20:27] *** fhelmberger left
[20:27] <vendethiel> *g* .oO( always blame the keyboard )

[20:28] <Kristien> m: sub singleton($x) { my \U = $x.WHAT; subset T of U where * === $x }

[20:28] <camelia> rakudo-moar 546000: OUTPUT«===SORRY!===␤No compile-time value for U␤»

[20:28] <Kristien> :(

[20:29] <vendethiel> Kristien: :(

[20:29] <vendethiel> subsets are BEGIN-time

[20:30] <Kristien> can you create them dynamically?

[20:30] <vendethiel> m: sub singleton($x) { my \U = $x.WHAT; my \T = subset of U where * === $x }

[20:30] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0_974imfBW␤Two terms in a row␤at /tmp/0_974imfBW:1␤------> 3x) { my \U = $x.WHAT; my \T = subset of 7⏏5U where * === $x }␤    expecting any of:␤        postfix␤        infix stopper␤        …»

[20:31] <vendethiel> m: sub singleton($x) { my \U = $x.WHAT; my $sig = :(U where * === $x); }

[20:31] <camelia> rakudo-moar 546000: OUTPUT«===SORRY!===␤No compile-time value for U␤»

[20:31] <vendethiel> uhm.

[20:31] *** _mg_ left
[20:31] <jnthn> Probably using Metamodel::SubsetHOW somehow.

[20:34] *** kjs_ joined
[20:41] <jnthn> hoelzro: ping

[20:42] <hoelzro> jnthn: pong

[20:42] <jnthn> hoelzro: Was it you who worked a lot on the declarator-attaching leading/trailing doc stuff?

[20:43] <jnthn> Or am I mis-remembering?

[20:43] <hoelzro> no, you're correct

[20:43] <hoelzro> that was me

[20:43] <jnthn> OK, cool

[20:43] <hoelzro> what'd I break?

[20:43] <hoelzro> =P

[20:43] <jnthn> Well, it's more that I'm breaking something... :P

[20:44] <jnthn> Previously, we've constructed signature objects after we've parsed the whole body of a routine/method/block

[20:44] <jnthn> That isn't working too well over in the land of native-ref, where it's really helpful to know as we build AST if we're looking at readonly native lexical or a rw one.

[20:45] <jnthn> So, I've started switching over to constructing sig objects and sorting out all the param info ahead of parsing the block

[20:45] <hoelzro> ah ha

[20:45] <jnthn> I've changed it for routine_def already, and all is well...except I now fail a load of POD decl doc tests.

[20:46] <jnthn> And then I see a bunch of %*PARAM_INFO<dummy> :)

[20:46] <jnthn> And start wondering if that was a needed "hack" because our timing was off before...

[20:46] <hoelzro> iirc, I think so

[20:46] <jnthn> OK

[20:47] <hoelzro> I believe params were the biggest pain when it came to S26

[20:47] <jnthn> Is this something you'd have any interest at all in looking into at some point in the next week or so? ;)

[20:47] <jnthn> I don't mind fixing it if you'll not have time/interest.

[20:48] <hoelzro> I can try, but I'll have to get up to speed on the native ref stuff

[20:48] <jnthn> But figure you may be able to figure it out faster than me :)

[20:48] <jnthn> Well, the refactors related to where we make sig objects are fairly decoupled from the rest of the work.

[20:49] <jnthn> So you don't need to grok native refs especially. :)

[20:49] <jnthn> It's just that the timing of when we build sig objects has moved earlier.

[20:49] <hoelzro> ok, cool

[20:49] <hoelzro> I'll see if I can take a look tonight

[20:50] <jnthn> OK, cool. native-ref branch in rakudo/rakudo already shows it

[20:50] <hoelzro> I'll let you know if I can and if I find something

[20:50] <jnthn> *but* I only updated stuff for routine_def

[20:50] <jnthn> I'm working on method_def and pblock at the moment

[20:50] <hoelzro> I believe that methods/subs were more sane in their implementation

[20:50] <jnthn> But if you look at it before I'm done changing those it may be a case of "fix it for routines, bust it for methods"

[20:51] *** amaliapomian left
[20:53] <hoelzro> jnthn: I probably won't be able to look at it until at least 00:00 your time

[20:53] <hoelzro> (assuming it's about 22:00 there)

[20:53] <jnthn> hoelzro: I might have broken parameters on methods and pblocks by then :)

[20:53] <jnthn> But really no hurry; this branch won't be ready to merge for a week or so yet on other issues.

[20:53] <jnthn> Not least that it currently represents a serious performance regression.

[20:54] <hoelzro> do I have to clone a special copy of nqp/moar to build rakudo for this? or will --gen-moar be fine?

[20:54] <jnthn> Moar, no.

[20:54] <jnthn> Just master

[20:54] <jnthn> Then native-ref branches of NQP and Rakudo.

[20:54] <hoelzro> ah, ok

[20:54] <jnthn> Normal repos, jsut different branches.

[20:54] <hoelzro> understood

[20:55] *** jluis left
[20:55] <jnthn> hoelzro++

[20:56] <jnthn> (For those reading and worrying about the perf reg: it's nothing to be concerned about, simply that the way certain things are code-gen'd has changed and optimizers/JIT haven't caught up yet; I'll get there pre-merge)

[21:02] <masak> m: sub bar($a, $b) {}; bar(1)

[21:02] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Sk1tdf3xOC␤Calling 'bar' will never work with argument types (int)␤    Expected: :(Any $a, Any $b)␤at /tmp/Sk1tdf3xOC:1␤------> 3sub bar($a, $b) {}; 7⏏5bar(1)␤»

[21:02] <masak> m: sub bar($a, $b) {}; my $x = 1; bar($x)

[21:02] <camelia> rakudo-moar 546000: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in sub bar at /tmp/NiNrvboWqB:1␤  in block <unit> at /tmp/NiNrvboWqB:1␤␤»

[21:02] <masak> why is the first a compile-time error and the second a runtime error?

[21:03] <PerlJam> at a guess, because 1 is a compile-time constant and $x isn't.

[21:03] <jnthn> What PerlJam said, basically.

[21:03] <vendethiel> no

[21:03] <jnthn> The errors fall out of inlining efforts.

[21:03] <vendethiel> it's about the number of arguments here

[21:03] <Kristien> because the flattening semantics are so complicated even the compiler doesn't understand them

[21:03] <vendethiel> Kristien: calls arguments aren't flattened :)

[21:03] <vendethiel> call*

[21:03] <jnthn> And the inlining stuff cares a bunch about types.

[21:03] <masak> is there any situation where `bar($x)` can mean anything other than "pass one argument"?

[21:03] * FROGGS really hates IIS

[21:03] <jnthn> No

[21:04] <jnthn> It's not that we can't catch that one at compile time

[21:04] <jnthn> It's simply that we catch them as a side-effect of optimization, and in this case we're apparently not trying to optimize.

[21:04] <Kristien> ew

[21:05] <jnthn> The promise is "runtime at latest, compile time preferable"

[21:05] <vendethiel> *g*

[21:05] <masak> right.

[21:05] <masak> so it's not a *bug* in the sense that it's failing to do something we promised...

[21:05] <jnthn> Correct, but it's disappointing still. :)

[21:05] <masak> it's more of an LTA because it's a case where we could be more awesome, but aren't at present.

[21:06] * masak submits LTA rakudobug :)

[21:06] <jnthn> Key thing to understand here is that the static inliner laregly exists to make sure we generate nice code for native operators.

[21:06] <PerlJam> masak++ (I was just about to encourage you to do that :)

[21:06] <jnthn> Anything beyond that is, so far, as bonus.

[21:07] <jnthn> Again, we'll get better at it.

[21:07] <jnthn> And yes, I'm fine with an LTA ticket.

[21:07] *** echowuhao joined
[21:07] <jnthn> May even look at it soonish, as I need to pay a visit to the optimizer while dealing with native refs.

[21:08] <masak> \o/

[21:09] *** kjs_ left
[21:09] <masak> I think the architecture we have is great, so don't take this the wrong way: we shouldn't be limited by an argument such as "there's no compile-time error here about this impossible situation, because we're not attempting to inline it"

[21:11] <jnthn> True, though we shouldn't duplicately implement tricky logic either

[21:12] <jnthn> I think the place we're doing the analysis is right, but we probably shouldn't give up trying so easily

[21:12] <masak> ok, fairy nuff.

[21:14] *** rindolf left
[21:16] <masak> https://rt.perl.org/Ticket/Display.html?id=123919

[21:18] *** xfix left
[21:18] *** dolmen joined
[21:26] <raydiak> m: say Capture ~~ Positional|Associative # Why?

[21:26] <camelia> rakudo-moar 546000: OUTPUT«False␤»

[21:27] <masak> good question.

[21:27] <masak> if you can index into it, it probably should be.

[21:28] <raydiak> I'd ask why you even can without an error, but I figured it was autovivification-related

[21:30] *** kjs_ joined
[21:36] <raydiak> seems you can index most anything and it turns into a 1-elem list if it doesn't do something else instead...so it just works as-is because it defines a .list and .hash I guess

[21:36] *** dolmen left
[21:36] <raydiak> m: my $a = class{}.new; say $a{}.perl; say $a[].perl;

[21:36] <camelia> rakudo-moar 546000: OUTPUT«<anon>.new()␤(<anon>.new(),).list␤»

[21:36] <raydiak> that first one is cute :)

[21:37] <dalek> perl6-examples: e3395b5 | paultcochrane++ | bin/run-examples.pl:

[21:37] <dalek> perl6-examples: Search for .p6 files as well as .pl

[21:37] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/e3395b531e

[21:37] <dalek> perl6-examples: e302aa2 | paultcochrane++ | bin/run-examples.pl:

[21:37] <dalek> perl6-examples: Ignore games/ dir since they are interactive

[21:37] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/e302aa2bce

[21:37] <dalek> perl6-examples: cf8595c | paultcochrane++ | games/connect4.p6:

[21:37] <dalek> perl6-examples: Make games/connect4.p6 work again

[21:37] <dalek> perl6-examples: 

[21:37] <dalek> perl6-examples: A few hacks to work around lack of certain features in the past could be

[21:37] <dalek> perl6-examples: removed such that the game now works again as expected.

[21:37] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/cf8595cd8c

[21:37] <dalek> rakudo/native-ref: 830108d | jnthn++ | src/Perl6/ (2 files):

[21:37] <dalek> rakudo/native-ref: Move invocant adding into sig-object builder.

[21:37] <dalek> rakudo/native-ref: 

[21:37] <dalek> rakudo/native-ref: A small step to prepare for lifting signature creation for method-ish

[21:37] <dalek> rakudo/native-ref: things earlier.

[21:37] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/830108df05

[21:37] <dalek> rakudo/native-ref: 7b41e74 | jnthn++ | src/Perl6/Actions.nqp:

[21:37] <dalek> rakudo/native-ref: Lift signature creation out of methodize_block.

[21:37] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/7b41e74735

[21:39] <mohij> Hey! I'm just starting to write my first serious pl6 program, a parser. During parsing I'd like to save some state to reuse later on in the parser. I'd like to have that state *not* survive backtracking (i.e. I'd like the state to revert to its previous state when backtracking over the action that created/modfied it). Is there a canonical way of doing something like that?

[21:40] <dalek> doc: 1091feb | paultcochrane++ | lib/Language/io.pod:

[21:40] <dalek> doc: Mention IO::Handle.say() as alternative to .print

[21:40] <dalek> doc: review: https://github.com/perl6/doc/commit/1091feb2ad

[21:40] <dalek> doc: 1ae7413 | paultcochrane++ | CONTRIBUTING.md:

[21:40] <dalek> doc: Merge branch 'master' of github.com:perl6/doc

[21:40] <dalek> doc: review: https://github.com/perl6/doc/commit/1ae7413fe8

[21:40] <dalek> doc: ad48c53 | paultcochrane++ | CONTRIBUTING.md:

[21:40] <dalek> doc: Correct minor typos

[21:40] <dalek> doc: review: https://github.com/perl6/doc/commit/ad48c537ee

[21:40] <dalek> rakudo/native-ref: 4dd6ccb | jnthn++ | src/Perl6/ (2 files):

[21:40] <dalek> rakudo/native-ref: Build method signature before parsing body.

[21:40] <dalek> rakudo/native-ref: 

[21:40] <dalek> rakudo/native-ref: This means we also code-gen native lexical readonly parameters better

[21:40] <dalek> rakudo/native-ref: and get errors at compile time for trying to assign to them.

[21:40] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/4dd6ccbefd

[21:40] <dalek> rakudo/native-ref: 304300f | jnthn++ | src/Perl6/Grammar.nqp:

[21:40] <dalek> rakudo/native-ref: Tweak routine_def for consistency with method_def.

[21:40] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/304300ff15

[21:40] <jnthn> mohij: In the Perl 6 grammar we use dynamically scoped variables for those kinds of cases

[21:42] <jnthn> I suspect there there may be smaller examples in some module somewhere, though I can't think of one off-hand. Maybe someone else here has a handy example. :)

[21:42] <dalek> rakudo-star-daily: 3cc1541 | coke++ | log/ (11 files):

[21:42] <dalek> rakudo-star-daily: today (automated commit)

[21:42] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/3cc1541590

[21:43] <lizmat> commute home&

[21:43] *** lizmat left
[21:43] <masak> mohij, jnthn: module example: http://strangelyconsistent.org/blog/parsing-indented-text

[21:44] <dalek> rakudo-star-daily: 04ebc4c | coke++ | bin/star.sh:

[21:44] <dalek> rakudo-star-daily: Suspend running parrot backend

[21:44] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/04ebc4c87a

[21:45] <raydiak> I'll just "[BUG] attempting to index into objects without defined postcircumfixes doesn't fail" if nobody else chimes in eventually

[21:45] <mohij> jnthn: Thank you! That looks like what I need.

[21:46] <hoelzro> raydiak: ah, that behavior bugs me too

[21:46] <raydiak> hoelzro: so it's known? is it reported? is it even a bug?

[21:47] <hoelzro> iirc, it's intended behavior

[21:47] * hoelzro looks through logs for when he reported it

[21:47] <raydiak> :/

[21:47] <mohij> wait, masak that was your link, so kudos to you (too) :-)

[21:49] <masak> enjoy :)

[21:49] <hoelzro> raydiak: http://irclog.perlgeek.de/perl6/2014-12-18#i_9825061

[21:49] <raydiak> hoelzro: thanks :)

[21:49] <hoelzro> np

[21:51] <raydiak> m: class Foo {}; my $foo = Foo.new; say $foo{}.perl;

[21:51] <camelia> rakudo-moar 546000: OUTPUT«Foo.new()␤»

[21:52] <raydiak> that is just weird

[21:52] <hoelzro> raydiak: I agree

[21:52] <raydiak> also weird that {} returns a single scalar, while [] returns a single-element list

[21:53] <raydiak> m: class Foo {}; my $foo = Foo.new; say $foo{}.perl; say $foo[].perl;

[21:53] <camelia> rakudo-moar 546000: OUTPUT«Foo.new()␤(Foo.new(),).list␤»

[21:53] *** dolmen joined
[21:54] <raydiak> m: class Foo {}; my $foo = Foo.new; say $foo[].elems; say $foo{}.elems;

[21:54] <camelia> rakudo-moar 546000: OUTPUT«1␤1␤»

[21:54] <raydiak> m: class Foo {}; my $foo = Foo.new; say $foo.hash

[21:54] <camelia> rakudo-moar 546000: OUTPUT«Odd number of elements found where hash initializer expected␤  in method STORE at src/gen/m-CORE.setting:11138␤  in method hash at src/gen/m-CORE.setting:1656␤  in block <unit> at /tmp/184BvGebSo:1␤␤»

[21:55] *** kjs_ left
[21:56] <dalek> rakudo/native-ref: 9276140 | jnthn++ | src/Perl6/ (2 files):

[21:56] <dalek> rakudo/native-ref: Bring pblock signature building before body parse.

[21:56] <dalek> rakudo/native-ref: 

[21:56] <dalek> rakudo/native-ref: Means that -> int $x { $x = 42 } is now also a compile-time error, and

[21:56] <dalek> rakudo/native-ref: native lexical access code-gen is better for pointy block args also.

[21:56] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/9276140c98

[21:58] <vendethiel> jnthn++

[21:58] <dalek> rakudo/cpp: 5bc251b | FROGGS++ | t/04-nativecall/13-cpp-mangling. (2 files):

[21:58] <dalek> rakudo/cpp: add tests about mangling of typed pointers

[21:58] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/5bc251bb17

[21:58] <FROGGS> ohh, nice

[21:59] *** anaeem1_ left
[22:00] *** laouji joined
[22:02] *** [Sno] left
[22:05] *** laouji left
[22:08] <masak> 'night, #perl6

[22:08] <dalek> rakudo/cpp: 15f8a05 | FROGGS++ | / (2 files):

[22:08] <dalek> rakudo/cpp: handle and test Bool as argument to C++ subs

[22:08] <dalek> rakudo/cpp: review: https://github.com/rakudo/rakudo/commit/15f8a05db6

[22:10] <raydiak> good night masak 

[22:14] *** geekosaur left
[22:15] *** geekosaur joined
[22:15] <vendethiel> 'night :)

[22:15] *** skids left
[22:17] <FROGGS> lol, void __cdecl abc<def<int>,void*>::xyz(void); is mangled in VC++ as: ?xyz@?$abc@V?$def@H@@PAX@@YAXXZ

[22:17] <vendethiel> nice.

[22:17] <FROGGS> yeah :o)

[22:18] <FROGGS> http://en.wikipedia.org/wiki/Visual_C%2B%2B_name_mangling

[22:18] <FROGGS> a nice guide

[22:18] <FROGGS> I hope I can get the basics done by the end of the week

[22:22] <FROGGS> some of the mangled codes look like klingon: $Jx'y'z $Qa

[22:22] *** Rounin left
[22:23] <geekosaur> that might explain a few things...

[22:23] <Kristien> sometimes mangled names are more readable than C++ declarations: http://stackoverflow.com/a/6755760/1804599

[22:24] <geekosaur> exactly

[22:24] <Kristien> doesn't make C++ any less awesome :D

[22:25] <FROGGS> :D

[22:29] <FROGGS> ohh, I got a lot to read: http://mentorembedded.github.io/cxx-abi/abi.html#vtable

[22:31] *** kjs_ joined
[22:31] *** saurabh joined
[22:31] <Kristien> don't do C++ ABI interop

[22:32] <saurabh> Hi

[22:32] <Kristien> it will break

[22:32] *** saurabh is now known as Guest18648

[22:32] <FROGGS> Kristien: the valuable information for me there are the rules about when a vtable pointer is present

[22:32] <Guest18648> Hello there, I want to contribute to perl 6 developement, Am I at the right place ?? 

[22:33] <FROGGS> so I can autodetect that, and get the struct size right

[22:33] <FROGGS> Guest18648: you are

[22:33] <Kristien> FROGGS: note that there can be multiple vptrs

[22:33] <jercos> Guest18648: close as they come :)

[22:33] <Kristien> in case of multiple inheritance

[22:33] <FROGGS> Guest18648: welcome

[22:33] <Guest18648> Thank You!

[22:33] <Guest18648> How to get started? I can write perl 5 modules. :P 

[22:34] <FROGGS> Kristien: yes, though we do not support that for CStructs/CPPStruct atm

[22:34] <Kristien> Guest18648: use v5; :D

[22:34] <Guest18648> Any suggetions ??

[22:34] <FROGGS> Guest18648: you could try to port a module over :o)

[22:34] <Guest18648> Allright.

[22:34] <FROGGS> Guest18648: that's a good way to get your hands dirty

[22:34] <Kristien> FROGGS: you also have to be careful about the unspecified order in case of access specifiers

[22:35] <Kristien> field order in memory

[22:35] <FROGGS> Kristien: of attributes?

[22:35] <Kristien> struct t { int a; int b; } // b will follow a in memory, guaranteed

[22:35] <FROGGS> aye

[22:35] <Kristien> struct t { int a; private: int b; } // no such guarantee

[22:35] <FROGGS> aha

[22:36] <FROGGS> that's a problem

[22:36] <Kristien> I'd go the lazy and safe way and query libclang for all the details, although it has no stable API.

[22:36] *** rurban left
[22:36] <FROGGS> but, that has to wait :o)

[22:36] <FROGGS> perhaps

[22:36] <FROGGS> gnight :o)

[22:36] <Kristien> goodbye

[22:37] <Kristien> C++ is immensely complicated. You have to be careful with lots of stuff regarding multiple inheritance, public/private, __attribute__((packed)), bitfields, alignas(T), etc…

[22:38] <Guest18648> yes

[22:38] <Guest18648> I don't get it, How can i chat with so many people at once.

[22:38] <Guest18648> How to reply...

[22:39] <Kristien> I'm in eight parallel chat sessions.

[22:39] <Guest18648> Are you a bot? :P

[22:39] <Kristien> no :P

[22:40] <Kristien> FROGGS: also have fun with union members!

[22:40] <Guest18648> Help me, How to start: just give me a hint , I will follow.

[22:41] <raydiak> Guest18648: other than learning Perl 6, http://doc.perl6.org/language/modules contains most of what you need to know to author modules

[22:41] <Guest18648> Should I get Rakudo ?

[22:42] <jnthn> Yes

[22:42] <raydiak> well, yes

[22:42] <Guest18648> okay, I will get started.

[22:42] <Ulti> also pick a nickname so when you come back we know it's you ;P

[22:42] <Guest18648> allright..

[22:43] <Ulti>  /nick yourname

[22:43] <Ulti> ^type that without the leading space

[22:43] <Guest18648> ^saurabh

[22:43] <Kristien> lol

[22:43] <Ulti> wow

[22:43] <vendethiel> well.

[22:43] <ashleydev> and when you are in a conversation with someone while other people are chatting you often preface your coments with "<nickname>: ..."

[22:43] <Kristien> let's try the hunter2 test on them

[22:43] <jnthn> Guest18648: Try /nick saurabh

[22:44] <jnthn> Kristien: Be nice. :P

[22:44] *** wicope left
[22:44] <Guest18648> It's okay

[22:44] <Ulti> saurabh the chat understands commands that start with a /

[22:44] *** Vlavv_ left
[22:44] <Kristien> technically it depends on the IRC client

[22:45] <vendethiel> sigh.

[22:45] <vendethiel> it doesn't, really.

[22:45] <jnthn> hoelzro: So, I did the pblock and method_def switch-over, and of course busted more leading/trailing decl Pod tests too. ;) But at least things should be consistently broken now and so consistently fixable.

[22:46] <hoelzro> jnthn: thanks for the heads-up.  I'll probably just start from the first break, try to fix it, and see if I can apply the fix to other breakages

[22:46] <jnthn> hoelzro: *nod*

[22:46] <Guest18648> I tried [backslash]nick __NickName__ , Didn't work.

[22:47] *** dolmen left
[22:47] *** Guest18648 left
[22:47] <jnthn> hoelzro: Though I suspect it's broken quite consistently, such that there'll be a neat fix (maybe a simplification) for the lot.

[22:47] *** kjs_ left
[22:47] <hoelzro> that would be nice =)

[22:48] <vendethiel> Guest83546: it's slash, not backslash

[22:48] <jnthn> hoelzro: Bonus points if the <dummy> thing goes away :)

[22:48] <Kristien> lol, Go documentation: "Given a set of identifiers, an identifier is called unique if it is different from every other in the set."

[22:48] *** tgt joined
[22:48] <hoelzro> I'll do what I can =)

[22:48] <Kristien> But sets contain only unique elements!

[22:48] <vendethiel> hence they're all uniques

[22:48] <jnthn> I'm president of the tautology club!

[22:48] <vendethiel> .oO( it's like a meet-lattice !)

[22:49] *** [Sno] joined
[22:50] <vendethiel> (actually not. sorry)

[22:51] <rjbs> Please fact-check me:

[22:51] <rjbs> It's: sub xyz ($x) is cached { ... }   --and not-- sub xyz is cached ($xyz) { .. }

[22:52] <hoelzro> m: sub f($x) is cached { say "here for $x"; return $x } ; f(1); f(2)

[22:52] <camelia> rakudo-moar 546000: OUTPUT«here for 1␤here for 2␤»

[22:52] <hoelzro> m: sub f($x) is cached { say "here for $x"; return $x } ; f(1); f(1)

[22:52] <camelia> rakudo-moar 546000: OUTPUT«here for 1␤»

[22:52] <hoelzro> rjbs: looks sane to me!

[22:52] *** tgt left
[22:52] <rjbs> m: sub f is cache ($x) { say "here for $x"; return $x } ; f(1)

[22:52] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TaJFHFz38y␤Missing block␤at /tmp/TaJFHFz38y:1␤------> 3sub f is cache 7⏏5($x) { say "here for $x"; return $x } ; ␤    expecting any of:␤        new name to be defined␤»

[22:52] <rjbs> m: sub f is cached ($x) { say "here for $x"; return $x } ; f(1)

[22:53] <camelia> rakudo-moar 546000: OUTPUT«5===SORRY!5=== Error while compiling /tmp/oYwVambI4r␤Missing block␤at /tmp/oYwVambI4r:1␤------> 3sub f is cached 7⏏5($x) { say "here for $x"; return $x } ; ␤    expecting any of:␤        new name to be defined␤»

[22:53] <rjbs> Thanks.

[22:53] <rjbs> (This is relevant to a current p5p thread.)

[22:56] *** Vlavv_ joined
[22:57] <hoelzro> happy to help!

[23:03] <rjbs> specifically, http://www.nntp.perl.org/group/perl.perl5.porters/2015/02/msg226103.html

[23:03] <rjbs> Once I'm back on wall power, I will build rakudo anew!

[23:08] <raydiak> is it intentional that an EXPORT sub inside a package/module/class/etc doesn't work?

[23:08] *** jbotz joined
[23:09] <jbotz> hello

[23:09] <jnthn> raydiak: Yes; the importer looks for it as a lexical in UNIT

[23:09] <jbotz> just tried to upgrade to latest rakudo using rakudobrew and it broke...

[23:10] <jbotz> Unhandled exception: While looking for 'ModuleLoader.moarvm': no such file or directory

[23:10] <jbotz>    at <unknown>:1  (src/vm/moar/stage0/nqp.moarvm:<dependencies+deserialize>:6)

[23:10] <jbotz> Makefile:218: recipe for target 'gen/moar/stage1/nqpmo.moarvm' failed

[23:11] <raydiak> jnthn: thank you...I see the part I was missing in S11 now

[23:12] <jnthn> jbotz: First time I've seen this reported; any chance you can nopaste/gist the full build log?

[23:13] *** adu left
[23:13] *** kjs_ joined
[23:13] <jbotz> how to 'nopaste'..?

[23:15] *** espadrine left
[23:15] <jbotz> nopasted: http://nopaste.linux-dev.org/?443276. 

[23:18] <jnthn> jbotz: Not sure what's going on; I'm not especially familiar with rakudobrew. But the uninitialized var warnings near the top look suspect...

[23:18] <jnthn> As does the "no --prefix supplied"

[23:19] * raydiak noticed same warnings yesterday

[23:19] <jbotz> raydiak: but did your build fail?

[23:20] *** kjs_ left
[23:20] <raydiak> jbotz: no

[23:23] <raydiak> now that I look, even just "rakudobrew build" (no 2nd arg) gives me the same warnings, and dies with an error before printing the suggestion list

[23:25] <dalek> roast: 9dd8a31 | jnthn++ | S06-traits/native-is-rw.t:

[23:25] <dalek> roast: Add test file for native is rw parameters.

[23:25] <dalek> roast: review: https://github.com/perl6/roast/commit/9dd8a31c09

[23:26] <dalek> rakudo/native-ref: bea708f | jnthn++ | src/ (2 files):

[23:26] <dalek> rakudo/native-ref: Typed exception for assigning to ro native param.

[23:26] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/bea708fccd

[23:26] <dalek> rakudo/native-ref: b576197 | jnthn++ | t/spectest.data:

[23:26] <dalek> rakudo/native-ref: Run S06-traits/native-is-rw.t.

[23:26] <dalek> rakudo/native-ref: review: https://github.com/rakudo/rakudo/commit/b576197596

[23:28] *** gfldex left
[23:29] *** dolmen joined
[23:29] <jnthn> Enough for today...should have a good Perl 6 tuit supply tomorrow :)

[23:29] <jnthn> o/

[23:31] <raydiak> \o jnthn 

[23:35] *** larion left
[23:36] *** adu joined
[23:43] * Kristien is gonna fork Python and actually implement from __future__ import braces.

[23:44] *** virtualsue left
[23:48] <jbotz> jnthn, raydiak: did "rakudobrew build moar 2015.02" instead of just "rakudobrew build moar" and it worked.

[23:48] <jbotz> so I guess whatever broke is in the head ;-)

[23:49] <raydiak> heh :)

[23:50] *** laouji joined
[23:53] *** Alina-malina left
[23:53] *** Alina-malina joined
[23:54] *** laouji left
[23:55] *** mohij left
