[00:00] *** telex left
[00:01] <RabidGravy> right enough of this, nighty night people

[00:02] *** telex joined
[00:03] *** llfourn left
[00:05] <dalek> rakudo-star-daily: 9f688a2 | coke++ | log/ (9 files):

[00:05] <dalek> rakudo-star-daily: today (automated commit)

[00:05] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/9f688a2a13

[00:05] <dalek> perl6-roast-data: 182ff9f | coke++ | / (10 files):

[00:05] <dalek> perl6-roast-data: today (automated commit)

[00:05] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/182ff9fd5b

[00:05] *** RabidGravy left
[00:06] *** yqt left
[00:34] *** lizmat joined
[00:34] <lizmat> good * from YAPC::Asia

[00:36] *** mjgardner left
[00:41] *** cibs_ joined
[00:43] *** mjgardner joined
[00:47] <jdv79> ok

[00:47] *** vendethiel left
[00:52] *** mjgardner left
[00:54] *** mjgardner joined
[00:56] <lizmat> Larry just began...

[00:58] *** colomon left
[01:00] <AlexDaniel> at least there will be a video, right?

[01:00] <yoleaux> 20 Aug 2015 10:01Z <FROGGS> AlexDaniel: I think timotimo meant the state we already had when we spoke last time

[01:00] <AlexDaniel> because I was a little bit disappointed because of fosdem…

[01:02] <AlexDaniel> and I am a bit unhappy because of qx//

[01:02] <AlexDaniel> :)

[01:03] <lizmat> trying to make a video right now  :-)

[01:04] *** colomon joined
[01:15] *** jkva joined
[01:15] *** colomon left
[01:15] *** colomon joined
[01:17] *** aborazmeh left
[01:19] *** jkva left
[01:20] *** cibs joined
[01:22] *** khw joined
[01:24] *** cibs_ left
[01:25] *** aborazmeh joined
[01:25] *** aborazmeh left
[01:25] *** aborazmeh joined
[01:35] *** aborazmeh left
[01:37] *** dayangkun joined
[01:41] *** hryk joined
[01:42] *** hryk left
[01:54] *** aborazmeh joined
[01:54] *** lizmat left
[01:54] *** aborazmeh left
[01:54] *** aborazmeh joined
[01:56] *** lizmat joined
[01:57] <lizmat> argh...  camera kicks out every 20 mins or so, stupid EU regulations

[01:57] <lizmat> so missed a few seconds twice

[01:57] <lizmat> not sure how good the audio is

[01:57] <lizmat> it *was* an audience recording :-)

[01:58] <colomon> EU regulations?

[01:58] <lizmat> video cameras are taxed much higher than still cameras

[01:58] <colomon> :(

[01:58] <lizmat> so you buy a still camera with a video feature

[01:59] <lizmat> it is only allowed to record 20 mins max

[01:59] <lizmat> or it will be taxed as a video camera

[01:59] <lizmat> and become 20% more expensive

[01:59] *** llfourn joined
[02:00] <colomon> yow!

[02:00] <lizmat> yeah

[02:00] <lizmat> they *are* hacks to change the firmware to allow longer recording

[02:01] <lizmat> but I just never bothered  :-(

[02:02] <colomon> should just buy a camera next time you’re in the states.  ;)

[02:04] <lizmat> come to think of it, this camera *was* bought in the States

[02:04] <lizmat> maybe there are similar regulations?

[02:04] <colomon> huh  not that I know of?

[02:06] <colomon> http://www.tested.com/tech/photography/44445-why-digital-cameras-have-a-30-minute-video-recording-limit/

[02:06] <colomon> not really a good explanation

[02:07] <colomon> honoring the EU regs just because it’s convenient for them?

[02:08] <colomon> http://photo.stackexchange.com/questions/14563/why-is-there-a-limit-restriction-to-the-1080p-film-video-recording-time-duration

[02:08] *** lizmat left
[02:09] *** lizmat joined
[02:09] <lizmat> well, that was a hard crash. 2nd time this week :-(

[02:14] <timotimo> I had a rather hard crash today too...

[02:16] *** mjgardner left
[02:26] *** noganex_ joined
[02:28] *** noganex left
[02:34] *** vendethiel joined
[02:35] *** inokenty joined
[02:35] *** mr-foobar left
[02:40] <dalek> rakudo/glr: a49eb3d | lizmat++ | tools/build/makeSLICE.pl6:

[02:40] <dalek> rakudo/glr: Fix deprecation when generating new slice code

[02:40] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a49eb3d355

[02:47] <cognominal> colomon, the media industry seems to make the law in Europe. At least, with a pirate deputy with a very conservative proposal in the european parlement, one can  see in action with their proposed amendments.

[02:48] *** aborazmeh left
[02:50] <lizmat> looking at why multi-element hash slices don't work in GLR

[02:51] <lizmat> it looks like the $more value is containerized one level too many

[02:51] <lizmat> $ 6 'my %h = a => [1,2,3], b => 42; say (%h<a b>:delete).perl'

[02:51] <lizmat> $more = \(("a", "b"))

[02:51] <lizmat> $ 6 'my @a = [1,2,3],42; say (@a[0,1]:delete).perl'

[02:51] <lizmat> $more = $(0, 1)

[02:54] <lizmat> adding a $more = $more[0] in the hash case gives me:

[02:54] <lizmat> $ 6 'my %h = a => [1,2,3], b => 42; say (%h<a b>:delete).perl'

[02:54] <lizmat> ($[1, 2, 3], 42)

[02:54] <lizmat> as expected

[02:55] <lizmat> since the postcircumfix is just passing on \key

[02:56] <lizmat> hmmm...

[02:57] <lizmat> argh, looks like we had a typo there for a *long* time that was hidden by excessive flattening

[03:00] <dalek> rakudo/glr: fa0c50c | lizmat++ | src/core/hash_slice.pm:

[03:00] <dalek> rakudo/glr: Fix an old thinko that was uncovered by GLR

[03:00] <dalek> rakudo/glr: 

[03:00] <dalek> rakudo/glr: This should fix all has slices (at least for now)

[03:00] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/fa0c50cea5

[03:00] <lizmat> *hash

[03:03] *** vendethiel left
[03:04] *** kaare_ joined
[03:05] *** mr-foobar joined
[03:07] *** AlexDaniel left
[03:08] <dalek> rakudo/glr: 7f6f85d | lizmat++ | src/core/hash_slice.pm:

[03:08] <dalek> rakudo/glr: Fix (for now) hash zen/whatever slices

[03:08] <dalek> rakudo/glr: 

[03:08] <dalek> rakudo/glr: Perhaps we should do this in SLICE_MORE_HASH, not sure yet

[03:08] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/7f6f85d632

[03:09] <ShimmerFairy> I personally love when fixing things uncovers bugs that managed to slip by :)

[03:10] <lizmat> yeah, and the extra Capture creation / flattening that was done, was not good for performance  :-)

[03:10] *** aborazmeh joined
[03:10] *** aborazmeh left
[03:10] *** aborazmeh joined
[03:13] <ShimmerFairy> lizmat: looking at that thinko, would a warning on using \var for declared sigil-less vars be useful or too superfluous? (e.g. warn on the second \a in  my \a = 42; say \a  )

[03:13] *** lizmat left
[03:13] *** CQ_ joined
[03:15] <ShimmerFairy> On the one hand it seems like it would be silly to add a warning for that, but on the other hand I do get the feeling that a lot of people could trip up on thinking \ was just another sigil there.

[03:15] *** CQ left
[03:15] *** CQ_ is now known as CQ

[03:19] *** BenGoldberg joined
[03:19] *** BenGoldberg left
[03:35] *** fling joined
[03:43] *** cantaberry joined
[03:49] * skids thinks we need an opt-in category of warnings, and it should go there.

[03:51] <skids> btw this needs error to be demoted similarly:

[03:51] <skids> m: my $a = {}; $a.perl.say; {}.perl.say; EVAL '${}';

[03:51] <GLRelia> rakudo-moar 7f6f85: OUTPUT«${}␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${}; in Perl 6 please use $()␤at EVAL_0:1␤------> 3${}7⏏5<EOL>␤»

[03:51] <camelia> rakudo-moar 815fff: OUTPUT«{}␤{}␤5===SORRY!5=== Error while compiling EVAL_0␤Unsupported use of ${}; in Perl 6 please use $()␤at EVAL_0:1␤------> 3${}7⏏5<EOL>␤»

[03:59] <ShimmerFairy> skids: I think everything that's disallowed on the basis of me expecting P5 behavior should be removable, since I don't know that :)

[03:59] <ShimmerFairy> skids: I frequently think that 'use/no warnings' should be given options based on category, like gcc's -W flags

[04:00] *** lizmat joined
[04:00] <japhb> ShimmerFairy: Would you accept the idea of disallowing P5 behavior for 6.Christmas, and then allowing reuse in 6.Future?

[04:01] <ShimmerFairy> e.g.  'no warnings :Perl5' or  'yes warnings :sigilless'   (I know that my use of 'yes' should be 'use', but I think it reads nicer in this particular example)

[04:01] <japhb> I ask because it seems like a windmill you tilt at with some regularity.

[04:02] <skids> ShimmerFairy: figuring out where to hold the line between "use warnings" and what belongs some sort of Log:: module is the problem.

[04:02] <ShimmerFairy> japhb: To be clear, I'm fine with P5 warnings, errors, and paranoid protections being on by default. I don't run into those warnings/errors often, admittedly, but it is a little LTA that stuff causes noisy warnings, or is paranoid-ly disallowed just because it's P5 syntax even though it'd make sense here, can't be turned off yet.

[04:03] <ShimmerFairy> m: say qw//.perl

[04:03] <GLRelia> rakudo-moar 7f6f85: OUTPUT«()␤»

[04:03] <camelia> rakudo-moar 815fff: OUTPUT«()␤»

[04:03] <ShimmerFairy> m: say <>.perl

[04:03] <GLRelia> rakudo-moar 7f6f85: OUTPUT«5===SORRY!5=== Error while compiling /tmp/KZTDCaHL1R␤Unsupported use of <>; in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list␤at /tmp/KZTDCaHL1R:1␤------> 3say <7⏏5>.perl␤»

[04:03] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/9ohlp4HVM9␤Unsupported use of <>; in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list␤at /tmp/9ohlp4HVM9:1␤------> 3say <7⏏5>.perl␤»

[04:04] <lizmat> once we get async stuff sufficiently stable, I would like to see warnings issued on a supply

[04:04] <ShimmerFairy> ^ simple example. I think it's pretty clear that the <> should be eqv. to qw[] (i.e. an empty list), but you can't do it. I'm fine with dieing on it by default, but some kind of way to disable it would be nice

[04:05] <ShimmerFairy> lizmat: I was thinking, maybe we don't want to call it warnings (except for 'warn' keywords used in P6), but worries/sorrows/panicks(?) for the compiler-related pragmas.

[04:06] <lizmat> perhaps.... in any case, for production you would like to have warnings accumulated for a request / or a run

[04:06] *** skids left
[04:06] <lizmat> and issued somewhere else then in a log, presumably

[04:07] <ShimmerFairy> lizmat: yeah, I think some kind of concurrency attached to warnings and/or errors would be nice. Would be nice to provide something more featureful than  2>my.log  for putting warnings elsewhere, for instance :)

[04:07] <lizmat> indeed, like deprecation warnings are handled now

[04:08] <ShimmerFairy> I also think that enabling pragmas should use 'yes' as a keyword instead of 'use', since (to my P6 eyes), pragmas aren't like modules at all. Unless perhaps you are still supposed to be able to write your pragmas, like I heard you can in P5.

[04:09] <ShimmerFairy> but that's mostly a "would be nice" kind of thing for me :)

[04:09] <lizmat> well, I would be in favour of "yes" for pragma's

[04:10] *** khw left
[04:10] <lizmat> as the "no" functionality of *modules* from P5 won't ever work in P6

[04:10] <lizmat> because the import happens at compile time already

[04:10] <lizmat> and cannot be undone, afaik

[04:10] <ShimmerFairy> it also reads better for what pragmas do, I think:  no warnings; ... { yes warnings :P5; ... }

[04:10] <ShimmerFairy> oh, there's a "no" usage for modules there? huh.

[04:11] <lizmat> not in P6, I don't think

[04:11] <ShimmerFairy> I know, I meant in P5. Sorry for not clarifying :)

[04:11] <lizmat> calling the "unimport" methods on a class...not sure what that would mean in P6 context

[04:14] <ShimmerFairy> looking at the breakdown of use in S11, I'm not sure which part is the "import" equivalent, and thus would need to be reversed

[04:15] *** Loren_ joined
[04:16] <ShimmerFairy> lizmat: if we even needed an opposite to 'use', I'd be tempted to say it should be called 'disuse' or some other verb more indicative of what it means (and then disuse -> unimport + needn't , hypothetically)

[04:17] <lizmat> somehow I feel this discussion has happened before... so maybe we should wait until TimToady chimes in (if he has an opinion about this, of course)

[04:18] <ShimmerFairy> lizmat: I certainly mentioned 'yes' as a possible alternate keyword before, but I don't think it led to a discussion. Not sure if it's been discussed otherwise :)

[04:19] <lizmat> m: say [<a b c>].perl   # fine!

[04:19] <GLRelia> rakudo-moar 7f6f85: OUTPUT«["a", "b", "c"]␤»

[04:19] <camelia> rakudo-moar 815fff: OUTPUT«["a", "b", "c"]␤»

[04:19] <lizmat> m: say [<a b c>,42].perl   # how do I get the <a b c> to flatten ???

[04:19] <camelia> rakudo-moar 815fff: OUTPUT«["a", "b", "c", 42]␤»

[04:19] <GLRelia> rakudo-moar 7f6f85: OUTPUT«[$("a", "b", "c"), 42]␤»

[04:20] <ShimmerFairy> lizmat: looking at perldoc, "A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl", I immediately thought "we can do that with slangs and macros from modules, we don't need pragmas the way P5 calls 'em"

[04:20] <ShimmerFairy> m: say [<a b c>.Slip,42].perl

[04:20] <GLRelia> rakudo-moar 7f6f85: OUTPUT«["a", "b", "c", 42]␤»

[04:20] <camelia> rakudo-moar 815fff: OUTPUT«Method 'Slip' not found for invocant of class 'Parcel'␤  in block <unit> at /tmp/GPXjGDXIRU:1␤␤»

[04:20] <lizmat> ShimmerFairy++   # it had Slipped my mind

[04:20] <ShimmerFairy> it needs to be a Slip in order to "slip" into the list :)

[04:23] <lizmat> wonder if we could make a prefix = act as a slip

[04:23] <ShimmerFairy> lizmat: my initial guess is that, if we have user-made pragmas in P6, they would be based on slangs, and would not involve import/unimport. And I still say a keyword separation between modules and pragmas ('use' vs. 'yes'/'no') would be helpful :)

[04:23] <lizmat> I agree....

[04:24] <moritz> \o

[04:25] <lizmat> moritz o/

[04:25] <ShimmerFairy> The only place where I wouldn't want the 'yes' keyword is  'use nqp;'  , since I imagine an 'nqp' module in that case, which rakudo happens to provide integrated for free.

[04:25] <ShimmerFairy> o/

[04:25] <lizmat> yes MONKEY-TYPING

[04:25] <ShimmerFairy> (but if that's not the intended view of 'use nqp', then nevermind :P)

[04:25] <lizmat> well, that's not what it's doing, it's just allowing nqp:: in userland code

[04:26] <lizmat> so "yes nqp" would make sense to me

[04:26] *** xinming left
[04:26] *** xinming joined
[04:26] <lizmat> m: use nqp; nqp::say("foo"); no nqp; nqp::print("bar")

[04:26] <GLRelia> rakudo-moar 7f6f85: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[04:26] <camelia> rakudo-moar 815fff: OUTPUT«===============================================================================␤The use of nqp::operations has been deprecated for non-CORE code.  Please␤change your code to not use these non-portable functions.  If you really want␤to keep using nqp:…»

[04:26] <ShimmerFairy> lizmat: in my imagination non-rakudo Perl6s could theoretically want to provide an nqp module for 'use nqp'. Though then again it could just as easily support the pragma form too.

[04:27] <lizmat> m: use nqp; nqp::say("foo")

[04:27] <GLRelia> rakudo-moar 7f6f85: OUTPUT«foo␤»

[04:27] <camelia> rakudo-moar 815fff: OUTPUT«foo␤»

[04:28] <lizmat> m: my $x = 42; my $y = 666; ($x,$y) = ($y,$x); dd $x, $y   # this is known to be an issue, right ?

[04:28] <GLRelia> rakudo-moar 7f6f85: OUTPUT«$x = 666␤$y = 666␤»

[04:28] <camelia> rakudo-moar 815fff: OUTPUT«$x = 666␤$y = 42␤»

[04:29] <ShimmerFairy> I remember that being provided as a simple example of something a few days back, but not sure

[04:29] <moritz> m: say List.new.eager.^name

[04:29] <GLRelia> rakudo-moar 7f6f85: OUTPUT«Seq␤»

[04:29] <camelia> rakudo-moar 815fff: OUTPUT«List␤»

[04:32] <ShimmerFairy> I remember that being provided as a simple example of something a few days back, but not sure

[04:32] <ShimmerFairy> woops :P

[04:34] <moritz> lizmat: I know it to be an issue, because I saw the test failing :-)

[04:34] *** shinobi-cl joined
[04:34] <lizmat> I seem to recall jnthn finding out STORE had to be 2-pass because of this

[04:35] <lizmat> but maybe he just didn't do that yet...  or is waiting to put in the compile time magic to only do 2-pass if really needed

[04:36] <lizmat> m: (1,2,3).map({ $_ xx 3 }).perl   # not, not saying anything, just .perling

[04:36] <GLRelia> rakudo-moar 7f6f85: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/yRtSIYCmBD:1␤␤»

[04:36] <camelia> rakudo-moar 815fff: ( no output )

[04:36] <lizmat> m: say (1,2,3).map({ $_ xx 3 })   # now saying it

[04:36] <GLRelia> rakudo-moar 7f6f85: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/uz9LDUaJff:1␤␤»

[04:36] <camelia> rakudo-moar 815fff: OUTPUT«1 1 1 2 2 2 3 3 3␤»

[04:38] <lizmat> m: (1,2,3).map({ $_ if $_ > 5 }).perl.say   # glad to see this still sorta works

[04:38] <GLRelia> rakudo-moar 7f6f85: OUTPUT«().iterator␤»

[04:38] <camelia> rakudo-moar 815fff: OUTPUT«()␤»

[04:39] <lizmat> m: (1,2,3).map({ next if $_ > 5; $_ }).perl.say   # glad to see this still sorta works

[04:39] <GLRelia> rakudo-moar 7f6f85: OUTPUT«(1, 2, 3).iterator␤»

[04:39] <camelia> rakudo-moar 815fff: OUTPUT«(1, 2, 3)␤»

[04:39] <lizmat> m: (1,2,3).map({ next if $_ > 5; $_ }).perl.say   # so we don't need to use next

[04:39] <GLRelia> rakudo-moar 7f6f85: OUTPUT«(1, 2, 3).iterator␤»

[04:39] <camelia> rakudo-moar 815fff: OUTPUT«(1, 2, 3)␤»

[04:39] <lizmat> m: (1,2,3).map({ next if $_ <= 5; $_ }).perl.say   # what I actually meant

[04:39] <GLRelia> rakudo-moar 7f6f85: OUTPUT«().iterator␤»

[04:39] <camelia> rakudo-moar 815fff: OUTPUT«()␤»

[04:41] <dalek> roast/glr: fc4fb81 | lizmat++ | integration/advent2011-day23.t:

[04:41] <dalek> roast/glr: Fix a test by slipping it

[04:41] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/fc4fb81b9d

[04:45] <lizmat> m: <a b c>[0].say

[04:45] <GLRelia> rakudo-moar 7f6f85: OUTPUT«a␤»

[04:45] <camelia> rakudo-moar 815fff: OUTPUT«a␤»

[04:45] *** jkva joined
[04:45] <lizmat> m: <a b c>[0] = 42

[04:45] <GLRelia> rakudo-moar 7f6f85: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/Uk0AqENVRf:1␤␤»

[04:45] <camelia> rakudo-moar 815fff: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/yDP8d2YQ0D:1␤␤»

[04:46] <lizmat> m: say <a b c> === <a b c>

[04:46] <GLRelia> rakudo-moar 7f6f85: OUTPUT«False␤»

[04:46] <camelia> rakudo-moar 815fff: OUTPUT«True␤»

[04:46] <lizmat> I would posit that Lists generated with <a b c> should actually be a subclass of List that would be a value type

[04:47] <lizmat> the immutability is already handled at the nqp level

[04:48] <ShimmerFairy> considering you can't interpolate anything mutable into a qw[] (afaik), that sounds fair to me.

[04:49] *** jkva left
[04:53] <dalek> rakudo/glr: a1c19d8 | moritz++ | src/core/Range.pm:

[04:53] <dalek> rakudo/glr: Implement a basic Range.elems

[04:53] <dalek> rakudo/glr: 

[04:53] <dalek> rakudo/glr: special-cases infinite lists, and optimizes for the Int..Int case

[04:53] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/a1c19d839d

[04:53] <lizmat> m: my $a = 42; say <$a b c>   # doesn't work

[04:53] <GLRelia> rakudo-moar 7f6f85: OUTPUT«$a b c␤»

[04:53] <camelia> rakudo-moar 815fff: OUTPUT«$a b c␤»

[04:54] <moritz> m: my $a = 42; <<$a b c>>[0] = 23; say $a

[04:54] <GLRelia> rakudo-moar 7f6f85: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/ptuMLMhiC7:1␤␤»

[04:54] <camelia> rakudo-moar 815fff: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/D17TEnonFk:1␤␤»

[04:54] <lizmat> m: (1..Inf).max.WHAT.say

[04:54] <GLRelia> rakudo-moar 7f6f85: OUTPUT«(Num)␤»

[04:54] <camelia> rakudo-moar 815fff: OUTPUT«(Num)␤»

[04:55] <lizmat> m: (1..Inf).max.say

[04:55] <GLRelia> rakudo-moar 7f6f85: OUTPUT«Inf␤»

[04:55] <camelia> rakudo-moar 815fff: OUTPUT«Inf␤»

[04:55] <lizmat> m: (1..*).max.say

[04:55] <GLRelia> rakudo-moar 7f6f85: OUTPUT«Inf␤»

[04:55] <camelia> rakudo-moar 815fff: OUTPUT«Inf␤»

[04:55] <lizmat> moritz: * is not stored in $!min or $!max

[04:55] <lizmat> it's either -Inf or Inf

[04:56] <lizmat> moritz: so I think the first 2 checks are unnecessary

[04:56] *** rangerprice left
[04:58] <moritz> lizmat: ok; there's another check for nqp::istype($!max, Whatever) in Range.pm; I'll kill that too

[04:58] *** mr-foobar left
[04:58] <lizmat> :-)

[05:00] *** cgfbee joined
[05:02] *** cognominal left
[05:05] <dalek> rakudo/glr: 45c62e2 | moritz++ | src/core/Range.pm:

[05:05] <dalek> rakudo/glr: Remove redundant Whatever checks for Range endpoints, lizmat++

[05:05] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/45c62e202e

[05:08] <lizmat> m: my $a = (101..104); say 1 + $a.max - $a.min - $a.excludes-min - $a.excludes-max  # moritz

[05:08] <GLRelia> rakudo-moar a1c19d: OUTPUT«4␤»

[05:08] <camelia> rakudo-moar 815fff: OUTPUT«4␤»

[05:15] <dalek> specs: 1d9fd64 | lizmat++ | S22-package-format.pod:

[05:15] <dalek> specs: Mention CUR.uninstall

[05:15] <dalek> specs: review: https://github.com/perl6/specs/commit/1d9fd64c70

[05:15] <dalek> specs: b4d76e3 | lizmat++ | S (2 files):

[05:15] <dalek> specs: Merge branch 'master' of https://github.com/perl6/specs

[05:15] <dalek> specs: review: https://github.com/perl6/specs/commit/b4d76e33b2

[05:18] *** lizmat left
[05:20] <ugexe> typo my $removed = $repo.install( $dist );

[05:21] <ugexe> install also takes :$dist... if its supposed to be that

[05:23] *** lizmat joined
[05:26] *** lizmat_ joined
[05:27] *** lizmat left
[05:28] *** lizmat joined
[05:29] *** lizmat_ left
[05:30] <dalek> specs: e2a4087 | lizmat++ | S22-package-format.pod:

[05:30] <dalek> specs: Fix type, ugexe++

[05:30] <dalek> specs: review: https://github.com/perl6/specs/commit/e2a4087cda

[05:31] <lizmat> ugexe: re :$dist, I don't think the current impl is up to spec

[05:31] <lizmat> hope to have this resolved after the SPW

[05:34] *** KCL left
[05:39] *** xinming left
[05:40] <dalek> roast/glr: ca092df | lizmat++ | integration/advent2012-day20.t:

[05:40] <dalek> roast/glr: Fix a test by slipping and itemizing

[05:40] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/ca092df7f9

[05:41] *** xinming joined
[05:43] <dalek> roast/glr: 9320d1d | lizmat++ | integration/advent2012-day20.t:

[05:43] <dalek> roast/glr: Fix another test by slipping and itemizing

[05:43] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/9320d1d35a

[05:45] *** xinming left
[05:46] *** xinming joined
[05:50] *** jkva joined
[05:53] *** vendethiel joined
[05:54] *** vendethiel left
[05:57] <masak> morning, #perl6

[05:59] <moritz> good morning, masak 

[05:59] <dalek> roast/glr: f8c114f | moritz++ | S12-methods/defer-call.t:

[05:59] <dalek> roast/glr: Add explicit flat() to defer-call.t

[05:59] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/f8c114fcf5

[06:00] <lizmat> m: Set.grep(Set)  # do we expect this to work ?

[06:00] <GLRelia> rakudo-moar 45c62e: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/vmKoBokcv0:1␤␤»

[06:00] <camelia> rakudo-moar 815fff: ( no output )

[06:00] <lizmat> m: Set.grep(Set).say

[06:00] <GLRelia> rakudo-moar 45c62e: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/BoZbFL3YQR:1␤␤»

[06:00] <camelia> rakudo-moar 815fff: OUTPUT«(Set)␤»

[06:00] *** rurban joined
[06:00] <lizmat> m: set().grep(Set).say

[06:00] <GLRelia> rakudo-moar 45c62e: OUTPUT«␤»

[06:00] <camelia> rakudo-moar 815fff: OUTPUT«␤»

[06:00] <lizmat> m: set(1,2,3).grep(Set).say

[06:00] <GLRelia> rakudo-moar 45c62e: OUTPUT«␤»

[06:00] <camelia> rakudo-moar 815fff: OUTPUT«␤»

[06:01] <moritz> S32-list/map.t expects thing.map(*) to be a no-op

[06:01] <moritz> why? is that specced? Is it useful?

[06:02] <ShimmerFairy> I can't think of a case where you want to do  thing.map($a)  and be able to assign $a a Whatever to make the .map do nothing

[06:02] <moritz> but why call .map in the first place if you don't want to even potentially transform anything?

[06:03] *** jkva left
[06:03] <moritz> ah well, maybe it doesn't hurt to have a neutral element

[06:03] <lizmat> moritz: it was intended to create an infinite list afaicr

[06:03] <ShimmerFairy> moritz: exactly :)  I don't see why you'd do a literal .map(*) , so I can only see  thing.map($a) where $a = Whatever.new

[06:04] <lizmat> I think it can go actually now

[06:04] *** aborazmeh left
[06:04] <ShimmerFairy> and I don't see why you wouldn't have another indicator beforehand, like  if $want-transform { ... }  or even    @a.map($_) with $transform-func

[06:06] *** jkva joined
[06:07] <dalek> roast/glr: 2a492d2 | lizmat++ | integration/advent2012-day13.t:

[06:07] <dalek> roast/glr: Fix 2 tests by Slipping

[06:07] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/2a492d2986

[06:07] <dalek> roast/glr: 6c6edcc | lizmat++ | integration/advent2012-day13.t:

[06:07] <dalek> roast/glr: DeTAB and whitespace alignment

[06:07] <dalek> roast/glr: 

[06:07] <dalek> roast/glr: No functional change

[06:07] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/6c6edcccc5

[06:08] <dalek> roast/glr: 8d5f2a4 | moritz++ | S32-list/map.t:

[06:08] <dalek> roast/glr: Remove .map(*) tests

[06:08] <dalek> roast/glr: 

[06:08] <dalek> roast/glr: consensus on #perl6 was that it is not really needed

[06:08] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/8d5f2a46e9

[06:08] <masak> I could maybe see .map($tfn) being useful, and then $tfn is sometimes *

[06:08] <moritz> though {$_} would do too, no?

[06:09] <masak> but frankly, if I did something like that, I'd do .map(&tfn), and then have &tfn = sub id { $^x };

[06:09] <masak> moritz: yes, of course. but {$_} is longer than *

[06:09] <masak> moritz: I think the design "wants" to find and support all the cases where * means {$_}

[06:10] <masak> even though * is more general than that, and can sometimes mean Inf, etc

[06:10] <moritz> let's see how much of the ecosystem breaks when .map(*) doesn't work anymore

[06:10] <masak> :)

[06:10] <moritz> and if the fallout is significant, re-add it

[06:10] *** freeze joined
[06:10] <moritz> (it's a one-liner)

[06:10] <moritz> I posit that "somebody might find it useful" isn't a strong enough reason to keep a feature anymore

[06:12] *** diana_olhovik joined
[06:12] *** jkva left
[06:15] <ShimmerFairy> masak: {$_} may be longer, but not by much, and it more clearly says "identity function" :)

[06:18] *** freeze left
[06:18] *** domidumont joined
[06:19] *** freeze joined
[06:20] <dalek> rakudo/glr: 6b907ab | lizmat++ | src/core/ (2 files):

[06:20] <dalek> rakudo/glr: Add some signatures that we need in GLR

[06:20] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6b907ab954

[06:20] <lizmat> this makes integration/advent2012-day13.t at lest pas now

[06:20] <lizmat> *least

[06:22] *** domidumont left
[06:25] *** domidumont joined
[06:25] <lizmat> m: say *.map({42.rand})

[06:25] <GLRelia> rakudo-moar 45c62e: OUTPUT«WhateverCode.new␤»

[06:25] <camelia> rakudo-moar 815fff: OUTPUT«WhateverCode.new␤»

[06:26] <masak> my argument wasn't "somebody might find it useful".

[06:26] <lizmat> so not a way to create an infinite list of random numbers

[06:26] <masak> but I have noticed that people reach for * meaning {$_} now and then because they expect it to work due to consistency.

[06:26] <lizmat> m: my @a = *.map({42.rand}); say @a

[06:26] <camelia> rakudo-moar 815fff: OUTPUT«WhateverCode.new␤»

[06:26] <GLRelia> rakudo-moar 45c62e: OUTPUT«WhateverCode.new␤»

[06:26] <masak> like, they are likely to go from *-1 or */2 to just *

[06:27] <masak> m: my @a = 1, 2, 3; say @a[*-1]; say @a[*]

[06:27] <GLRelia> rakudo-moar 6b907a: OUTPUT«3␤1 2 3␤»

[06:27] <camelia> rakudo-moar 815fff: OUTPUT«3␤1 2 3␤»

[06:27] <masak> ...which isn't always a reasonable assumption :)

[06:27] <masak> anyway, I'm fine with removing support for .map(*)

[06:27] <lizmat> Files=1036, Tests=41628, 200 wallclock secs (11.02 usr  3.28 sys + 1195.67 cusr 90.63 csys = 1300.60 CPU)

[06:28] <masak> I didn't even know we had it :)

[06:29] <lizmat> I think we're seeing the efficiency improvements of the GLR starting to shine through in the spectest wallclock and CPU usage

[06:29] <ShimmerFairy> can it be seen in CORE compilation yet?

[06:31] <lizmat> not really, not much P6 lazy listing going on while compiling core I don't think

[06:32] *** espadrine joined
[06:38] <dalek> rakudo/glr: 46290dc | lizmat++ | src/core/Mu.pm:

[06:38] <dalek> rakudo/glr: Add .munch canary for now

[06:38] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/46290dc187

[06:38] <lizmat> advent2010-day11.t was testing with it

[06:45] <masak> we can't do heredocs in src/core ?

[06:47] <lizmat> well, not sure anymore: they didn't use to work in core at one point

[06:48] <TimToady> hasn't someone been working with electron here?

[06:49] <lizmat> yes, but I can't find it in the ecosystem  :-(

[06:49] <ShimmerFairy> yes, azawawi IIRC

[06:50] <lizmat> https://github.com/azawawi/perl6-electron

[06:51] *** Ven joined
[06:52] *** amurf joined
[06:54] <lizmat> for ^9 {take <. X>[@i=map {%r{@i[($_-1)%19,$_,($_+1)%19].join}},^19].join};   # perl 6 line noise

[06:55] <lizmat> and something's wrong in there...  :-(

[06:55] * lizmat goes to another test file

[06:56] <ShimmerFairy> first thing I notice is that $_ isn't being %19'd in the middle term

[06:56] *** lizmat left
[06:56] *** amurf left
[06:58] <masak> lizmat: I knew it! Perl 6 is just as unmaintainable as Perl 5 -- this one line you pasted proves it. :P

[06:59] * masak .oO( "is observation bias common?" -- "yes! I see it everywhere!" )

[07:02] *** cognominal joined
[07:06] *** shinobi-cl left
[07:08] *** domidumont left
[07:08] *** Ven left
[07:16] *** darutoko joined
[07:22] *** zakharyas joined
[07:28] *** Possum left
[07:37] *** davercc`` left
[07:47] *** dg_subrata joined
[07:47] <dg_subrata> In our project log rotating is done via perl script. All cout and cerr prints of a C++ server are piped to a perl script which then rotate the log. But this is creating some problem. Most of the time logs are not coming instantly in the log file. Seems perl is doing some amount of buffering. How can I overcome this issue.  

[07:47] *** Ven joined
[07:49] *** telex left
[07:49] *** notch left
[07:50] *** cognominal left
[07:50] *** telex joined
[07:51] <nine> dg_subrata: man perlvar, look for autoflush. Also this is #perl6, you're probably looking for #perl :)

[07:52] <nine> Woah, we're down to 177/1047 spec test files failing :)

[07:53] <nine> .tell lizmat re commit 6b907ab9540de63941959252b3880fc6f67836c7, I'd be interested in _why_ we need those signatures now?

[07:53] <yoleaux> nine: I'll pass your message to lizmat.

[07:53] *** leont joined
[07:55] *** Ven left
[07:56] <dalek> rakudo/glr: 979d2d4 | (Stefan Seifert)++ | src/core/Hash.pm:

[07:56] <dalek> rakudo/glr: Fix Hash.perl creating code that throws an error when EVALing

[07:56] <dalek> rakudo/glr: 

[07:56] <dalek> rakudo/glr: .perl on an empty, itemized hash generated ${} which throws an error about

[07:56] <dalek> rakudo/glr: ${} no longer being the correct syntax and using $() instead.

[07:56] <dalek> rakudo/glr: {}.item means the same and is EVALable

[07:56] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/979d2d41b9

[07:57] *** Ven joined
[08:03] * leont is still looking for a roommate for YAPC::EU, if interested please mail me at leont@cpan 

[08:06] <nine> m: say (<a b c>).perl;

[08:06] <GLRelia> rakudo-moar 979d2d: OUTPUT«("a", "b", "c")␤»

[08:06] <camelia> rakudo-moar 815fff: OUTPUT«("a", "b", "c")␤»

[08:06] <nine> m: say (42, <a b c>).perl;

[08:06] <GLRelia> rakudo-moar 979d2d: OUTPUT«(42, ("a", "b", "c"))␤»

[08:06] <camelia> rakudo-moar 815fff: OUTPUT«(42, ("a", "b", "c"))␤»

[08:07] <nine> m: my @a = (42, <a b c>); for @a -> $o { say $o.perl; }

[08:07] <GLRelia> rakudo-moar 979d2d: OUTPUT«42␤$("a", "b", "c")␤»

[08:07] <camelia> rakudo-moar 815fff: OUTPUT«42␤"a"␤"b"␤"c"␤»

[08:07] <nine> Ah, another decade old bug in a spec test uncovered by GLR!

[08:11] <dalek> roast/glr: 14ba91b | (Stefan Seifert)++ | S02-names-vars/perl.t:

[08:11] <dalek> roast/glr: Update S02-names-vars/perl.t to this decade

[08:11] <dalek> roast/glr: 

[08:11] <dalek> roast/glr: We don't have references anymore in Perl 6. Test captures instead of

[08:11] <dalek> roast/glr: non-existing scalar refs. Fixes the deprecation warnings.

[08:11] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/14ba91b0ed

[08:11] <dalek> roast/glr: a1a1468 | (Stefan Seifert)++ | S02-names-vars/perl.t:

[08:11] <dalek> roast/glr: Fix wrong test count in S02-names-vars/perl.t

[08:11] <dalek> roast/glr: 

[08:11] <dalek> roast/glr: The test count has been wrong since forever since the <a b c> got flattened and

[08:11] <dalek> roast/glr: the list never tested. Instead we tested three single character strings. Now

[08:11] <dalek> roast/glr: with the sane flattening semantics, we actually test test the list and thus

[08:11] <dalek> roast/glr: run 4 fewer tests. Verified by manual test count.

[08:11] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/a1a1468f9b

[08:12] <FROGGS> Guten Morgen

[08:14] <FROGGS> .tell AlexDaniel the qx//|run|shell issue is not a very big one on my list btw... there are more important issues we need to address

[08:14] <yoleaux> FROGGS: I'll pass your message to AlexDaniel.

[08:21] <ShimmerFairy> FROGGS: did you see my qwx// as a quoting version of 'run' suggestion the other day?

[08:22] *** Ven left
[08:23] <masak> morning, FROGGS

[08:23] *** Ven joined
[08:24] <FROGGS> ShimmerFairy: no, I didn't

[08:24] <FROGGS> hi masak 

[08:24] <FROGGS> ShimmerFairy: why qWx ooc?

[08:24] <ShimmerFairy> FROGGS: basically, if we really _need_ a shorter version of run for Huffman or something, qwx and qqwx would be my suggestions for run

[08:25] <FROGGS> and how does such a call look like?

[08:25] <DrForr> That smells like cdaddr...

[08:25] <ShimmerFairy> FROGGS: because run is supplied a list of arguments, and one of the examples given in the complaint was run(«echo stuff»), which only goes to support the 'quotewords' thinking  :)

[08:25] *** cwDYKARN joined
[08:26] <ShimmerFairy> FROGGS: basically, in my mind, qx/qqx is to shell like qwx/qqwx is to run

[08:26] <ShimmerFairy> (though I'm still of the opinion that there's nothing that needs to be changed in the language, fwiw)

[08:26] <FROGGS> hmmm

[08:26] *** cognominal joined
[08:27] <FROGGS> brb

[08:27] *** FROGGS left
[08:27] <ShimmerFairy> Waitaminute

[08:27] <ShimmerFairy> m: my $b = 3; say «1 $b»

[08:27] <GLRelia> rakudo-moar 979d2d: OUTPUT«13␤»

[08:27] <camelia> rakudo-moar 815fff: OUTPUT«13␤»

[08:27] <ShimmerFairy> m: my $b = 3; say qww/1 $b/

[08:27] <GLRelia> rakudo-moar 979d2d: OUTPUT«1$b␤»

[08:27] <camelia> rakudo-moar 815fff: OUTPUT«1$b␤»

[08:27] <ShimmerFairy> m: my $b = 3; say qqw/1 $b/

[08:27] <GLRelia> rakudo-moar 979d2d: OUTPUT«1 3␤»

[08:27] <camelia> rakudo-moar 815fff: OUTPUT«1 3␤»

[08:27] <ShimmerFairy> ok, so it is qqw :)

[08:28] <dalek> roast/glr: 7a9e0c3 | (Stefan Seifert)++ | S02-names-vars/perl.t:

[08:28] <dalek> roast/glr: Fix comparison of a Seq with a list in S02-names-vars/perl.t

[08:28] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/7a9e0c3939

[08:28] <nine> And another file passing :)

[08:28] <ShimmerFairy> or not, I didn't notice the space in qqw

[08:29] *** FROGGS joined
[08:30] <ShimmerFairy> S02 doesn't list a name for «», like <> has with qw// O_o (only says that «» is eqv. to qq:ww:v/.../)

[08:31] <ShimmerFairy> m: my $b = 3; say qqww/1 $b/

[08:31] <GLRelia> rakudo-moar 979d2d: OUTPUT«13␤»

[08:31] <camelia> rakudo-moar 815fff: OUTPUT«13␤»

[08:31] <ShimmerFairy> ah, so I guess technically it should be qx//, qqx//, qwx//, and qqwwx// :)

[08:32] <FROGGS> quotewords style parsing occurred to me as well... but I'd probably favour qxs// and qx// over qwx

[08:33] *** RabidGravy joined
[08:33] <FROGGS> where qxs invokes the shell and is therefore one char longer

[08:33] <FROGGS> I think we should experiment with this idea...

[08:33] <masak> is qww a new thing?

[08:33] <FROGGS> qx// would then default to qx:out// perhaps...

[08:35] <ShimmerFairy> masak: no, apparently you can remove the colon with a short-form adverb

[08:35] <nine> m: my $f = ("f fo foo" ~~ m:nth(0)/fo+/)

[08:35] <GLRelia> rakudo-moar 979d2d: OUTPUT«Attempt to retrieve before :1st match -- :nth(0)␤  in block <unit> at /tmp/YwVWWiEo9p:1␤␤Actually thrown at:␤  in block <unit> at /tmp/YwVWWiEo9p:1␤␤»

[08:35] <camelia> rakudo-moar 815fff: ( no output )

[08:35] <ShimmerFairy> m: say Qb"Hello\n$World"

[08:35] <GLRelia> rakudo-moar 979d2d: OUTPUT«Hello␤$World␤»

[08:35] <camelia> rakudo-moar 815fff: OUTPUT«Hello␤$World␤»

[08:35] <nine> Why isn't this failing on nom?

[08:35] <nine> m: my $f = ("f fo foo" ~~ m:nth(0)/fo+/); say $f.WHAT;

[08:35] <camelia> rakudo-moar 815fff: OUTPUT«(Bool)␤»

[08:35] <GLRelia> rakudo-moar 979d2d: OUTPUT«Attempt to retrieve before :1st match -- :nth(0)␤  in block <unit> at /tmp/MkDMSE_QrY:1␤␤Actually thrown at:␤  in block <unit> at /tmp/MkDMSE_QrY:1␤␤»

[08:36] <nine> m: my $f = ("f fo foo" ~~ m:nth(0)/fo+/); say $f;

[08:36] <GLRelia> rakudo-moar 979d2d: OUTPUT«Attempt to retrieve before :1st match -- :nth(0)␤  in block <unit> at /tmp/EMUo5So3N8:1␤␤Actually thrown at:␤  in block <unit> at /tmp/EMUo5So3N8:1␤␤»

[08:36] <camelia> rakudo-moar 815fff: OUTPUT«False␤»

[08:37] <ShimmerFairy> FROGGS: I'd prefer not clobbering the qx// and qqx// meanings (of being like shell() ), since it's of little value and so close to the RC and christmas.

[08:38] <FROGGS> wow, only 175 test files left

[08:39] <FROGGS> ShimmerFairy: we could still experiment with it in a branch, is all

[08:40] <FROGGS> I'm not saying it is urgent... :o)

[08:41] <ShimmerFairy> FROGGS: like I said, I think it's a non-issue in the first place, at least as far as language design is concerned :)

[08:42] <FROGGS> yeah, I tend to agree

[08:42] <FROGGS> m: say 'xxy'.index( 'y', -1e35 )

[08:42] <GLRelia> rakudo-moar 979d2d: OUTPUT«2␤»

[08:42] <camelia> rakudo-moar 815fff: OUTPUT«Nil␤»

[08:42] <FROGGS> m: say 'xxy'.index( 'y', -1e34 )

[08:42] <GLRelia> rakudo-moar 979d2d: OUTPUT«Nil␤»

[08:42] <camelia> rakudo-moar 815fff: OUTPUT«Nil␤»

[08:43] <FROGGS> m: say 'xxy'.index( 'y', -1e36 )

[08:43] <GLRelia> rakudo-moar 979d2d: OUTPUT«2␤»

[08:43] <camelia> rakudo-moar 815fff: OUTPUT«Nil␤»

[08:44] *** domidumont joined
[08:45] *** kanl joined
[08:46] <kanl> dg_subrata: if your project runs on linux/unix, djb's daemontools + multilog may be preferable to your perl script solution. check out http://cr.yp.to if you're interested.

[08:49] <kanl> dg_subrata: daemontools is basically djb's replacement for xinetd. while your c++ server is guarded by daemontools, its stdour/stderr is hooked to multilog and rotated according to configuartion (by size, number of logs to keep etc..)

[08:50] <nine> kanl: aren't daemontools obsoleted by systemd now?

[08:51] <ShimmerFairy> only if you use systemd, I'd imagine :)

[08:51] <kanl> also true, i have a bunch of legacy systems..

[08:52] <kanl> for compatibility i just deploy daemontools, which works just fine.

[08:53] <ShimmerFairy> I don't use systemd, but only because there's no incentive to actually doing the switching over for me.

[08:53] <RabidGravy> coo do people still use djb-ware?  real blast from the past there.

[08:54] <dalek> rakudo/glr: c292e13 | moritz++ | src/core/operators.pm:

[08:54] <dalek> rakudo/glr: Fix infix:<does> with several roles at once

[08:54] <dalek> rakudo/glr: 

[08:54] <dalek> rakudo/glr: Makes S14-roles/mixin.t pass

[08:54] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/c292e13265

[08:54] *** luiz_lha joined
[08:55] *** luiz_lha is now known as Guest2181

[08:55] <kanl> RabidGravy: we have about 20K servers running centos 5.4 in production :)

[08:56] <FROGGS> m: use nqp; say nqp::unbox_i(-1e35)

[08:56] <GLRelia> rakudo-moar 979d2d: OUTPUT«(signal SEGV)»

[08:56] <camelia> rakudo-moar 815fff: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/QvhU7ZhEvH:1␤␤»

[08:56] <FROGGS> ups

[08:57] <RabidGravy> that'll do it to you every time :)

[08:57] <moritz> m: my $latin-chars = [~] chr(0)..chr(0xFF); say  $latin-chars.comb(/<space>/)>>.ord.join(",")

[08:57] <GLRelia> rakudo-moar c292e1: OUTPUT«9,10,11,12,13,32,133,160␤»

[08:57] <camelia> rakudo-moar 815fff: OUTPUT«9,10,11,12,13,32,133,160␤»

[08:58] <dalek> roast/glr: 0893808 | moritz++ | S05-mass/charsets.t:

[08:58] <dalek> roast/glr: Enforce range interpolation

[08:58] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/0893808c5a

[08:58] <FROGGS> sad, locally I don't get a segfault

[08:59] <FROGGS> m: use nqp; say nqp::unbox_i(-1e35)

[08:59] <GLRelia> rakudo-moar c292e1: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/OVR8FJtZPA:1␤␤»

[08:59] <camelia> rakudo-moar 815fff: OUTPUT«This type cannot unbox to a native integer␤  in block <unit> at /tmp/8iOTB0nXUr:1␤␤»

[08:59] <FROGGS> ahh :/

[08:59] <FROGGS> that was either the commit before or during rebuild

[09:00] <El_Che> kanl: I don't know what's more impressive. Having 20k server or still running centos 5.4 ;)

[09:00] <dalek> roast/glr: e6ab8ae | moritz++ | S05-mass/properties-general.t:

[09:00] <dalek> roast/glr: Enforce range interpolation

[09:00] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/e6ab8ae5fb

[09:01] <nine> moritz: what would be the difference between "my \real-roles = eager @roles.map" and "my \real-roles := eager @roles.map"?

[09:02] <kanl> El_Che: 20k is modest deployment scale for a search engine. and 5.4 is the stablest system if you rely on XFS ..

[09:02] <moritz> nine: uhm, nothing; should probably be = in both cases

[09:02] <nine> moritz: oh, interesting. I've mostly seen (and thus used) := for assignment to sigilless vars

[09:03] <El_Che> On the other hand I used --/me puts his old white beard on-- to run a huge solaris 8 farm almost single-hadled (my collegues back then where just escaping the mainframe) :)

[09:03] <moritz> nine: since sigilless vars can't be re-asssigned (or re-bound), and don't force a container, I don't think there's much practical difference anyway

[09:04] <El_Che> perl5 helped me keep my sane state (it was before the configuration management time) :)

[09:04] <El_Che> kanl: ddg?

[09:04] <nine> moritz: that they don't have a container makes it more logical to me to only bind them. But probably the compiler is smart enough to just do the same on assignment :)

[09:06] <TEttinger> kanl: yandex?

[09:07] <kanl> El_Che,TEttinger: no, but i have friends that work there :)

[09:13] <dalek> rakudo/glr: 9f58110 | lizmat++ | src/core/Cool.pm:

[09:13] <dalek> rakudo/glr: Handle out-of-bounds pos in index/rindex better

[09:13] <dalek> rakudo/glr: 

[09:13] <dalek> rakudo/glr: Fixes #125784

[09:13] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/9f581101ad

[09:14] *** leont left
[09:31] *** abraxxa joined
[09:34] *** Ven left
[09:34] *** espadrine left
[09:34] <JimmyZ> :q

[09:34] *** Guest2181 is now known as luiz_lha

[09:36] *** pflanze joined
[09:45] <JimmyZ> FROGGS: re 9f581101ad, we seems to already do the check in MoarVM

[09:45] <FROGGS> JimmyZ: and there we throw probably?

[09:46] <JimmyZ> I cant follow you ..

[09:47] <JimmyZ> MoarVM returns -1  alreay

[09:47] <JimmyZ> *already

[09:47] <FROGGS> hmmm, I dont think so

[09:47] <FROGGS> m: use nqp; my int $i = nqp::index(nqp::unbox_s("abc"),nqp::unbox_s("c"),nqp::unbox_i((-1e35).Int)); say $i

[09:47] <GLRelia> rakudo-moar 9f5811: OUTPUT«2␤»

[09:47] <camelia> rakudo-moar 815fff: OUTPUT«2␤»

[09:49] <JimmyZ> m: use nqp; my int $i = nqp::index(nqp::unbox_s("abc"),nqp::unbox_s("c"),nqp::unbox_i((-nqp::pow(2,65)).Int)); say $i

[09:49] <GLRelia> rakudo-moar 9f5811: OUTPUT«===SORRY!===␤No registered operation handler for 'pow'␤»

[09:49] <camelia> rakudo-moar 815fff: OUTPUT«===SORRY!===␤No registered operation handler for 'pow'␤»

[09:50] <JimmyZ> m: use nqp; my int $i = nqp::index(nqp::unbox_s("abc"),nqp::unbox_s("c"),nqp::unbox_i((-nqp::pow_I(2,65)).Int)); say $i

[09:51] <GLRelia> rakudo-moar 9f5811: OUTPUT«===SORRY!===␤Arg count 2 doesn't equal required operand count 5 for op 'pow_I'␤»

[09:51] <camelia> rakudo-moar 815fff: OUTPUT«===SORRY!===␤Arg count 2 doesn't equal required operand count 5 for op 'pow_I'␤»

[09:51] *** cwDYKARN_ joined
[09:52] *** leont joined
[09:53] *** espadrine joined
[09:53] *** cwDYKARN_ left
[10:01] <RabidGravy> m: class Foo { subset Format of uint16 where * < 3; }; my Foo::Format $a = 0

[10:01] <GLRelia> rakudo-moar 9f5811: OUTPUT«Type check failed in assignment to '$a'; expected 'Format' but got 'Int'␤  in block <unit> at /tmp/kKcTG6AIJ7:1␤␤»

[10:01] <camelia> rakudo-moar 815fff: OUTPUT«Type check failed in assignment to '$a'; expected 'Format' but got 'Int'␤  in block <unit> at /tmp/nQNlh4TUt8:1␤␤»

[10:02] <RabidGravy> m: say uint16 ~~ Int

[10:02] <GLRelia> rakudo-moar 9f5811: OUTPUT«True␤»

[10:02] <camelia> rakudo-moar 815fff: OUTPUT«True␤»

[10:02] *** xinming left
[10:02] <RabidGravy> this confuses me

[10:03] <JimmyZ> m: use nqp; say nqp::unbox_i(-1e35.Int);

[10:03] <GLRelia> rakudo-moar 9f5811: OUTPUT«0␤»

[10:03] *** cwDYKARN_ joined
[10:03] <camelia> rakudo-moar 815fff: OUTPUT«0␤»

[10:03] <JimmyZ> m: use nqp; say nqp::unbox_i(-1e34.Int);

[10:03] <GLRelia> rakudo-moar 9f5811: OUTPUT«-3458764513820540928␤»

[10:03] <camelia> rakudo-moar 815fff: OUTPUT«-3458764513820540928␤»

[10:03] *** xinming joined
[10:05] *** cwDYKARN_ left
[10:07] *** rindolf joined
[10:09] *** cwDYKARN_ joined
[10:10] <JimmyZ> .tell jnthn looks like we have pow_i in MoarVM, but it never be used in nqp/rakudo

[10:10] <yoleaux> JimmyZ: I'll pass your message to jnthn.

[10:13] <ShimmerFairy> JimmyZ: not surprised about rakudo (tends to use _I bigint ops instead), but nqp not using it anywhere is interesting.

[10:15] *** pmurias joined
[10:16] <JimmyZ> well , since nqp is a compiler ..

[10:21] <pmurias> JimmyZ: ?

[10:22] <nine> I guess you don't need pow that often in a compiler ;)

[10:24] *** leont left
[10:24] <ShimmerFairy> Right now I'm working on getting $¢ working properly (because I found I'm typing $/.CURSOR a bit too much atm). Enabling it in nqp was scarily easy, but it's proving quite a bit harder in rakudo, at least outside of regex/token/rule decls :P

[10:26] *** domidumont left
[10:28] *** xfix joined
[10:29] *** virtualsue joined
[10:29] *** virtualsue left
[10:29] *** amurf joined
[10:30] *** TEttinger left
[10:32] <FROGGS> ShimmerFairy: can't you just make it a term:sym<¢> and let the actions turn it into $/.CURSOR?

[10:33] <ShimmerFairy> Well, $¢ is what's spec'd, and I can easily enable it in NQP and in token foo { } regexes. It's the inline ~~ // stuff in P6 that's acting weird.

[10:33] <ShimmerFairy> oh, you mean in my own code :)

[10:33] <RabidGravy> time for either more coffee, find my glasses or use a bigger font.  I can barely tell the difference between $c and $¢

[10:33] *** amurf left
[10:34] *** Ven joined
[10:34] <ShimmerFairy> FROGGS: I of course could (though defining a term:sym<> didn't occur to me), but 1) I don't know how that would conflict with the ¢ sigil, if that ever makes a miraculous comeback, and 2) might as well put in support for the spec'd thing if I'm going to do anything :)

[10:36] <FROGGS> ShimmerFairy: it would not conflict with a sigil, because of LTM

[10:42] *** Possum joined
[10:50] *** zakharyas left
[10:55] <dalek> rakudo/glr: f9e6df2 | FROGGS++ | src/core/Str.pm:

[10:55] <dalek> rakudo/glr: fix Str.split and Str.match wrt GLR

[10:55] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/f9e6df2112

[10:58] <moritz> m: map { 2 * $_ } 2..5

[10:58] <GLRelia> rakudo-moar f9e6df: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3rvpuZTUAg␤Missing comma after block argument to map␤at /tmp/3rvpuZTUAg:1␤------> 3map { 2 * $_ }7⏏5 2..5␤    expecting any of:␤        infix␤        infix stopper␤»

[10:58] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/S8XWjtIOt1␤Missing comma after block argument to map␤at /tmp/S8XWjtIOt1:1␤------> 3map { 2 * $_ }7⏏5 2..5␤    expecting any of:␤        infix␤        infix stopper␤»

[10:58] <moritz> m: say map { 2 * $_ }, 2..5

[10:58] <GLRelia> rakudo-moar f9e6df: OUTPUT«4 6 8 10␤»

[10:58] <camelia> rakudo-moar 815fff: OUTPUT«4 6 8 10␤»

[10:58] <moritz> m: say [+] 1, map { 2 * $_ }, 2..5

[10:58] <GLRelia> rakudo-moar f9e6df: OUTPUT«5␤»

[10:58] <camelia> rakudo-moar 815fff: OUTPUT«29␤»

[10:59] <nine> m: say [+] flat 1, map { 2 * $_ }, 2..5

[10:59] <GLRelia> rakudo-moar f9e6df: OUTPUT«29␤»

[10:59] <camelia> rakudo-moar 815fff: OUTPUT«29␤»

[11:01] <nine> I'd really love to see | as flattening operator

[11:01] <moritz> or a separate operator for list concatenation

[11:01] <nine> m: say [+] 1, | map { 2 * $_ }, 2..5

[11:01] <GLRelia> rakudo-moar f9e6df: OUTPUT«29␤»

[11:01] <camelia> rakudo-moar 815fff: OUTPUT«29␤»

[11:01] <dalek> nqp: 9d35d8d | (Jimmy Zhuo)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[11:01] <dalek> nqp: map pow_i opcode

[11:01] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9d35d8d78a

[11:01] <nine> Which in this case it even is

[11:02] * moritz loves "! [rejected]" during git push; it means other folk were busy!

[11:02] <dalek> rakudo/glr: 8d70a3a | moritz++ | src/core/Temporal.pm:

[11:02] <dalek> rakudo/glr: Fix Datish.day-of-year

[11:02] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/8d70a3aa40

[11:03] *** abraxxa left
[11:04] *** zakharyas joined
[11:12] *** dayangkun left
[11:13] <moritz> TimToady: do we need List.tree post-GLR? the original intent (making inner lists not flatten) is the default now, and the stuffed-on extra functionality doesn't seem to fit the method name anymore

[11:13] <nine> Does anyone have an idea why LoL had to go?

[11:14] <nine> moritz: seems like we're investigating the same case :)

[11:14] * moritz never understood the point of LoL, except if it was to disable flattening of sublists

[11:14] <nine> Ok for that we can just use List now

[11:14] <moritz> nine: no, I was looking at S32-lists/tree.t, which predates implementation of LoL

[11:15] <nine> But then what's the point of having the (1;2;3) syntax?

[11:15] <moritz> no idea

[11:15] <moritz> maybe compact storage?

[11:16] <nine> moritz: you probably mean S02-lists/tree.t and I was indeed investigating the same

[11:17] <moritz> nine: ok; looking at reduce next

[11:21] *** smls joined
[11:21] <nine> I wonder what code would trigger Array.ASSIGN-POS

[11:21] <ShimmerFairy> oh, another thing about choosing to implement $¢ instead of a local solution: I don't imagine the difference is that great, but I imagine $¢.MATCH.CURSOR is probably less optimal than $¢ :)

[11:22] <moritz> nine: my @a = 42; @a[0] = 2

[11:22] <ShimmerFairy> (since $/ is just $¢.MATCH, if I understand the existing code correctly)

[11:22] <nine> moritz: how can that be? Array.ASSIGN-POS is commented out in GLR

[11:22] <moritz> nine: there might be a fallback if ASSGIN-POS does not exist

[11:23] <smls> there is

[11:23] <smls> it uses AT-POS then

[11:23] <smls> (which is expected to return an rw container)

[11:23] <moritz> m: class A { method ASSIGN-POS($idx, \val) { say val } }; A.new[0] = 42

[11:23] <GLRelia> rakudo-moar 8d70a3: OUTPUT«42␤»

[11:23] <camelia> rakudo-moar 815fff: OUTPUT«42␤»

[11:24] <moritz> ASSIGN-POS is both an implementation convenience and an optimization

[11:24] <nine> ok

[11:24] *** domidumont joined
[11:25] <nine> Looks like ASSIGN-POS will be very much like AT-POS. I'll just go for it :)

[11:26] <smls> documented at http://doc.perl6.org/language/subscripts#Methods_to_implement_for_positional_subscripting  btw, though it does not yet document the multi-dim extension that jnthn was working on.

[11:31] <moritz> m: my $a = [1, 2, 3]; my @b = $a; say @b.items

[11:31] <GLRelia> rakudo-moar 8d70a3: OUTPUT«Method 'items' not found for invocant of class 'Array'␤  in block <unit> at /tmp/N62vXUR7fI:1␤␤»

[11:31] <camelia> rakudo-moar 815fff: OUTPUT«Method 'items' not found for invocant of class 'Array'␤  in block <unit> at /tmp/wfLjvp10uK:1␤␤»

[11:31] <moritz> m: my $a = [1, 2, 3]; my @b = $a; say @b.elems

[11:31] <GLRelia> rakudo-moar 8d70a3: OUTPUT«1␤»

[11:31] <camelia> rakudo-moar 815fff: OUTPUT«1␤»

[11:31] *** Ven left
[11:32] *** RabidGravy left
[11:32] *** Ven joined
[11:38] *** FROGGS_ joined
[11:40] *** dayangkun joined
[11:42] *** FROGGS left
[11:43] *** rurban left
[11:48] *** smls left
[11:48] *** smls joined
[11:54] <rarara> smls: 'multi-dim extension', are you planning fortran style arrays (many indices) in perl 6?

[11:55] <smls> yeah, one index per dimension

[11:55] <smls> like @a[1; 1; 1]

[11:55] <smls> by default it will just be sugar for nested indexing, i.e.  @a[1;1;1]  would become  @a[1][1][1]

[11:56] <smls> *but* if the object supports it, it may handle all dimensions directly

[11:56] <smls> and compact native arrays support that, for example

[11:56] <rarara> ah that's amazing! So there could also be a compact Matrix object

[11:57] <nine> exactly

[11:57] <rarara> and maybe even some easy to use sparse matrix library

[11:57] <smls> in fact I thing it already partially works

[11:58] <smls> rarara: Yeah, it's been designed with PDL-like usecases in mind

[12:01] <dalek> rakudo/glr: 6a86a67 | (Stefan Seifert)++ | src/core/Array.pm:

[12:01] <dalek> rakudo/glr: Implement Array.ASSIGN-POS

[12:01] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6a86a6716e

[12:01] <nine> That was quite pain free :)

[12:02] <nine> We're now at 169/1047 btw.

[12:02] <Ven> nine++

[12:06] *** rurban joined
[12:14] <arnsholt> nine: 169 failing test files?

[12:14] <nine> arnsholt: yes

[12:14] *** dayangkun left
[12:16] *** rindolf left
[12:19] *** amurf joined
[12:20] <timotimo> o/

[12:20] *** dg_subrata left
[12:20] <timotimo> good news: after catapulting my thinkpad off a table, the only things broken are: a bit of plastic has exploded off of the side, and the plug of the power adapter is a tiny bit slanted now

[12:21] <nine> Thinkpads++

[12:21] <timotimo> yeah. i opened it up and was amazed - not for the first time - at how well it's built

[12:22] <ShimmerFairy> .oO(bad news: there wasn't any downside to make this setup work right)

[12:22] <timotimo> ShimmerFairy: the bad news is that if i had had a macbook, i wouldn't have been able to pull it off of the table via its power cord

[12:23] <ShimmerFairy> timotimo: true, though I suppose you could turn that around and say "Macbooks have flimsy plug connectors" :P

[12:23] *** amurf left
[12:23] <timotimo> i think that'd be dishonest

[12:24] <timotimo> on the other hand, i'm pretty sure a macbook would have taken a bit more damage than my thinkpad

[12:24] <timotimo> actually

[12:24] <timotimo> i'm not sure at all

[12:24] <ShimmerFairy> timotimo: it's Marketing Honest™, which is good enough in some circles :)

[12:24] <timotimo> argh :)

[12:26] <ShimmerFairy> timotimo: I can say that I got two old powerbooks from a teacher years ago, and the difference between the G3 and G4 laptops in terms of take-apart-ability was significant (and interesting)

[12:26] <timotimo> i've heard many things are fastened via glue rather than screws or latches

[12:27] <timotimo> but that's probably not for old powerbooks, just for the newer models?

[12:27] <ShimmerFairy> probably

[12:28] <nine> timotimo: that reminds me of the PQAH where the Apple magnetic power plug was quite flimsy and wouldn't connect right most of the time.

[12:28] <timotimo> perl quality assurance hackathon?

[12:28] <nine> timotimo: I rather have a sturdy laptop that survives a fall, whatever the reason.

[12:28] <nine> timotimo: yes

[12:28] <ShimmerFairy> The shiny one (G4) had early signs of the signature Apple Don't-Open-This design style, but the black G3 had it where the keyboard could easily be pulled out via two tabs on the top (there was a lock to prevent that, but amusingly it was broken :P)

[12:29] <timotimo> mhm

[12:30] * timotimo remembers a horrible photograph of a macbook that had been bent out of shape to reveal the hard drive

[12:30] <timotimo> with the flavor text "this is not how you replace a hard drive" or something

[12:30] <dalek> rakudo/glr: 6b3930e | moritz++ | src/core/ (2 files):

[12:30] <dalek> rakudo/glr: Restore some .reduce functionality

[12:30] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6b3930e927

[12:33] *** dnmfarrell joined
[12:35] <dnmfarrell> Hi all. Is there a way to loop through a match objects sub-matches in the order they were match? The docs say .list() but it is empty for me https://github.com/dnmfarrell/Pod-Perl5/blob/replace_buffer_with_make/lib/Pod/Perl5/ToHTML.pm#L47

[12:35] <moritz> dnmfarrell: .caps

[12:36] <timotimo> .list probably only gives you positional submatches, not named ones

[12:36] <timotimo> right?

[12:36] <moritz> right

[12:36] <moritz> .caps gives you both, order by .from

[12:36] <moritz> *ordered

[12:37] <ShimmerFairy> m: say "ABC" ~~ /<alpha>+/; for @($/) { say $_ }

[12:37] <GLRelia> rakudo-moar 6b3930: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤»

[12:37] <camelia> rakudo-moar 815fff: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤»

[12:37] <ShimmerFairy> m: say "ABC" ~~ /(\w)+/; for @($/) { say $_ }

[12:37] <GLRelia> rakudo-moar 6b3930: OUTPUT«｢ABC｣␤ 0 => ｢A｣␤ 0 => ｢B｣␤ 0 => ｢C｣␤｢A｣ ｢B｣ ｢C｣␤»

[12:37] <camelia> rakudo-moar 815fff: OUTPUT«｢ABC｣␤ 0 => ｢A｣␤ 0 => ｢B｣␤ 0 => ｢C｣␤｢A｣ ｢B｣ ｢C｣␤»

[12:37] <dnmfarrell> ahh thanks :)

[12:37] <ShimmerFairy> seems to work OK

[12:38] <moritz> m: say "ABC" ~~ /<alpha>+/; say .git for $/.caps

[12:38] <GLRelia> rakudo-moar 6b3930: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤Method 'git' not found for invocant of class 'Pair'␤  in block <unit> at /tmp/f_csbQvMlj:1␤␤»

[12:38] <camelia> rakudo-moar 815fff: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤Method 'git' not found for invocant of class 'Pair'␤  in block <unit> at /tmp/3HHomSGbSf:1␤␤»

[12:38] <moritz> m: say "ABC" ~~ /<alpha>+/; say .Str for $/.caps

[12:38] <GLRelia> rakudo-moar 6b3930: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤alpha        A␤alpha B␤alpha C␤»

[12:38] <camelia> rakudo-moar 815fff: OUTPUT«｢ABC｣␤ alpha => ｢A｣␤ alpha => ｢B｣␤ alpha => ｢C｣␤alpha        A␤alpha B␤alpha C␤»

[12:38] <moritz> m: "ABC" ~~ /<alpha>+/; say .Str for $/.caps

[12:38] <GLRelia> rakudo-moar 6b3930: OUTPUT«alpha        A␤alpha B␤alpha C␤»

[12:38] <camelia> rakudo-moar 815fff: OUTPUT«alpha        A␤alpha B␤alpha C␤»

[12:38] <moritz> m: "ABC" ~~ /<alpha>+/; say .value.Str for $/.caps

[12:38] <GLRelia> rakudo-moar 6b3930: OUTPUT«A␤B␤C␤»

[12:38] <camelia> rakudo-moar 815fff: OUTPUT«A␤B␤C␤»

[12:39] *** pnu left
[12:39] *** hobbs joined
[12:40] <dnmfarrell> moritz: it works ! :D 

[12:40] *** rurban_ joined
[12:41] <dalek> nqp: b6c791b | (Jimmy Zhuo)++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[12:41] <dalek> nqp: add pow_i to jvm backend

[12:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b6c791bfe5

[12:44] *** Ven left
[12:44] *** rindolf joined
[12:44] <dalek> nqp: ebfd308 | (Jimmy Zhuo)++ | src/vm/jvm/QAST/Compiler.nqp:

[12:44] <dalek> nqp: map pow_i opcode to jvm backend

[12:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ebfd3082ed

[12:44] *** Ven joined
[12:45] *** lizmat joined
[12:48] *** FatalNIX joined
[12:48] *** pnu joined
[12:55] <JimmyZ> .tell jnthn ignore it, I make it being used now.

[12:55] <yoleaux> JimmyZ: I'll pass your message to jnthn.

[12:55] <timotimo> ignore what?

[12:55] <JimmyZ> timotimo: pow_i

[12:55] <timotimo> ah, ok

[12:56] <JimmyZ> it'd be nice someone merge my pr and bump nqp version :)

[12:58] <masak> jnthn: I saw your "Inf ~~ Int will never happen" in the backlog. I'd like to talk about that sometime. I remember vividly how TimToady (perhaps a year or so ago) provided a way forward on that.

[12:59] <masak> jnthn: it wasn't so much an *exact* implementation plan as it was an assurance that it could be done.

[12:59] <masak> jnthn: I remember it because it convinced me.

[12:59] <masak> jnthn: and I was wondering whether you've seen it, and whether it convinced you.

[13:03] *** skids joined
[13:04] <masak> fwiw, I just had a MAIN sub where I wanted to write `Int $max = Inf`...

[13:04] <jnthn> masak: I'm basically burned out with the topic and wish it'd go away.

[13:04] <yoleaux> 20 Aug 2015 16:51Z <japhb> jnthn: I am seriously loving https://gist.github.com/anonymous/6607717a5d201a9acf82 ... I'm using it for language bragging rights with various friends.  Can't wait to be using the finished API.  :-)

[13:04] <yoleaux> 10:10Z <JimmyZ> jnthn: looks like we have pow_i in MoarVM, but it never be used in nqp/rakudo

[13:04] <yoleaux> 12:55Z <JimmyZ> jnthn: ignore it, I make it being used now.

[13:04] <masak> jnthn: ok.

[13:05] <jnthn> masak: I'm beyond the point of being interested in being convinced.

[13:05] <jnthn> masak: If anything's going to happen, then it's SEP.

[13:05] <dalek> rakudo/glr: 55b3264 | (Stefan Seifert)++ | src/core/native_array.pm:

[13:05] <dalek> rakudo/glr: Implement native array iterators

[13:05] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/55b3264e47

[13:05] <masak> sad to hear that, but that's an acceptable response.

[13:05] <jnthn> (I won't get in the way of somebody else working on it, of course.)

[13:05] <nine> Those were so simple, I wonder why noone has picked this LHF before :)

[13:06] <masak> I'm mostly interested in us resolving it one way or another.

[13:06] <masak> either eradicating the dream from the spec, or implementing the dream.

[13:06] <moritz> masak: one problem is that whatever you do, you have to create a layer of indirection to prevent us from passing Inf to the underlying bigint lib (which doesn't support Inf)

[13:07] <masak> aye.

[13:07] <masak> guess there are some operations that should simply die, even post-Inf~~Int

[13:07] <masak> but I think jnthn is right, that the most central problem is "what type?"

[13:08] <moritz> down to 166 spectest file fail (before nine++'s patch)

[13:08] <masak> if we want to support Inf for Int/Num/Str, for example, that suggests that the type must be `Int & Num & Str`

[13:08] <nine> jnthn: I wasted several hours yesterday trying to make hllization of nqp::list bind the list as IterationBuffer to $!reified, since almost all list code is expecting that. Can you tell me why that's a stupid idea?

[13:09] <masak> or is that `Int | Num | Str`? whatever makes Inf (and -Inf) assignable to each of those types.

[13:09] <jnthn> nine: afaik it only cares that it is an IterationBuffer if the List has unreified parts

[13:10] <jnthn> nine: And when we hllize things they're never lazy

[13:10] <moritz> class InfOrMinusInf is Num is Int is Str { }

[13:10] <jnthn> nine: So I figured it'd be no problem to bind an NQP array directly to $!reified

[13:11] *** dnmfarrell left
[13:11] <jnthn> nine: Does it turn out to be a problem somewhere? :)

[13:11] <skids> The issue raised in PR#502 may bear on that matter, depending on the decision made there.

[13:11] * lizmat wonders whether she has messages

[13:11] <yoleaux> 07:53Z <nine> lizmat: re commit 6b907ab9540de63941959252b3880fc6f67836c7, I'd be interested in _why_ we need those signatures now?

[13:11] <nine> jnthn: I wanted to use FLATTENABLE-LIST there: https://github.com/rakudo/rakudo/blob/glr/src/core/metaops.pm#L488 which failed because in line 495 we then call nqp::elems on a List instead of a VMArray

[13:12] <lizmat> nine: Set.grep(Set) was calling the Set.list, which had no restrictor on the object

[13:12] <ShimmerFairy> masak: as I understand it, the problem is that Inf and NaN are literally just names for the IEEE values, so of course they'd only work with Num :)

[13:12] <lizmat> this caused "cannot use attributes on a type object" error

[13:12] <lizmat> adding the signature, caused it to be not selected but instead the generic .list

[13:12] <nine> lizmat: ah, thanks

[13:13] <ShimmerFairy> (and when you think about it like that, I'm tempted to say it shouldn't work on non-Num, since they're clearly Num values)

[13:13] <lizmat> I'm not sure why that wasn't a problem pre-GLR

[13:13] <lizmat> m: say Set.grep(Set)

[13:13] <GLRelia> rakudo-moar 55b326: OUTPUT«␤»

[13:13] <camelia> rakudo-moar 815fff: OUTPUT«(Set)␤»

[13:13] <jnthn> nine: The trouble is that calling a method automatically does hllize on whatever it returns

[13:13] <nine> lizmat: several things worked mysteriously pre-GLR

[13:13] *** rmgk is now known as Guest26049

[13:13] *** rmgk_ joined
[13:13] *** Guest26049 left
[13:13] *** rmgk_ is now known as rmgk

[13:13] <hoelzro> good perl6, #morning!

[13:13] <lizmat> m: say [Set].grep(Set)

[13:13] <GLRelia> rakudo-moar 55b326: OUTPUT«(Set)␤»

[13:13] <camelia> rakudo-moar 815fff: OUTPUT«(Set)␤»

[13:14] <jnthn> nine: FLATTENABLE_LIST is only used for |@foo style things, and since the compiler emits the call it can avoid thta hllize

[13:14] <nine> jnthn: that's what I figured. Hence I tried to hllize the nqp::list to an IterationBuffer before assigning to $!reified of the List object. I patched MoarVM to allow rebless on VMArray and nqp to allow is repr on a stub but then ran into a nightmare of debugging

[13:15] <jnthn> eww

[13:15] <jnthn> No, users should never normally see IterationBuffer

[13:15] <jnthn> nqp::list should hllize to List

[13:15] <jnthn> If you want the $!reified from List then you should just getattr it

[13:15] <masak> ShimmerFairy: just because IEEE 754 defines Inf doesn't mean it has exclusive rights to it.

[13:15] <nine> jnthn: it would. I just reblessed $!reified to IterationBuffer

[13:15] <jnthn> nine: But why do you need to dothat?

[13:16] <masak> ShimmerFairy: also there's no doubt that (a) there's a use case here, nor that (b) Inf makes sense as "extreme comparison values" for a lot of comparable types. even user-defined types could theoretically get in on the game.

[13:16] <ShimmerFairy> masak: sure, I'm just saying that when you think of Inf as a name for the IEEE value (which it currently is), then of course it shouldn't work. :)

[13:16] <nine> jnthn: so the List code can be sure it will be an IterationBuffer (it already assumes in countless places) regardless of where the List is coming from.

[13:16] <JimmyZ> stupid questiond: re IterationEnd, is there a reason we can't s/IterationEnd/Nil/?

[13:16] <masak> ShimmerFairy: well, it isn't only that, by spec.

[13:16] <jnthn> JimmyZ: Yes

[13:16] <moritz> jnthn: the problem is/was that $!refified of a normal List (contstructed via List.new) is an IterationBuffer, but, but hllize create a List where $!refied was an NQP-level array

[13:17] <jnthn> moritz: I'm aware, but when I implemented List the ONLY places that relied on it being an IterationBuffer were code-paths where the List had a $!todo

[13:17] <jnthn> And that's *never* true for hllize'd things.

[13:17] <nine> So @a>>.say would work, but @a.^methods>>.say would fail

[13:17] <moritz> ok

[13:17] <ShimmerFairy> masak: my thinking is that Inf would have to be something like Nil or Empty, and I'm not sure if that's desired.

[13:18] <moritz> jnthn: maybe that assumption was broken somewhere along the way

[13:18] <jnthn> nine: If so, then >>.say is probably assuming the thing it gets is an IterationBuffer, not just any old VMArray

[13:18] *** woolfy joined
[13:18] <jnthn> moritz: Yes, I'm guessing so...I think I'd prefer to unbreak it :)

[13:18] <ShimmerFairy> (and btw, I definitely don't think NaN has much (if any) utility beyond floating point. It is, after all, not a number in the first place ☺)

[13:19] <jnthn> JimmyZ: Of note, Nil can actually exist in a List 'cus it does not vanish inside of them

[13:19] <moritz> ShimmerFairy: NaN as an integer would serve mostly the same function as the Int type object

[13:19] <nine> jnthn: yes, that was just me trying to be clever and use FLATTENABLE-LIST which looked like a perfect match for what I did

[13:19] <nine> On the bright side: we're at 167/1047 failing spec test files :)

[13:19] <jnthn> nine: Ah. Yeah, I'd probably not do that :)

[13:19] <JimmyZ> jnthn: thanks :)

[13:19] <jnthn> Wow...that's really nie progress :)

[13:19] <skids> Well, wouldn't a .plan be able to add a $!todo to a List gotten via hllization?

[13:19] <jnthn> *nice

[13:19] *** rindolf left
[13:20] <ShimmerFairy> moritz: exactly my thinking. we have plenty of not-numbers already, NaN is just useful for floating point because it's a real thing we can get out of floating-point.

[13:20] <jnthn> skids: .plan is a method on Array, not List

[13:20] <skids> Ah.

[13:20] <jnthn> skids: List is immutable, you can't .plan

[13:20] <jnthn> (That also ties quite strongly into my hllize assumption :))

[13:20] <skids> Anyway, any inclination as to what to do about the Failure transparency issue?

[13:21] <jnthn> skids: I need to look at it when I've got more brain

[13:21] <jnthn> (My body is not doing at all well with the jet lag :()

[13:21] <skids> :-) well, good luck crusing for brainnnz :-)

[13:22] <masak> ShimmerFairy: agree on NaN not being useful outside of floating-point.

[13:22] <ShimmerFairy> masak: of course, what we really need is  role HyperReal does Real { ... }  :P

[13:22] <moritz> for some values of "really"

[13:22] <masak> ShimmerFairy: no, not really.

[13:24] <masak> anyway, I think TimToady's helpful handwave was also something like what you're saying, ShimmerFairy.

[13:24] <masak> that Inf was a kind of "bottom type" for certain comparable types.

[13:24] <ShimmerFairy> the HyperReal was a joke, btw

[13:25] * hoelzro finally understands the difference between "das gleiche" and "das selbe" due to 'eqv' and '==='

[13:25] <nine> jnthn: if you find any time at all for some glr hacking it would be great if you could have a look at t/spec/S02-types/flattening.t. Would be enough if you review the tests, then we can fix the implementation. I'm just still too unsure about the wanted semantics :/

[13:25] <FROGGS_> 167 test files left...

[13:26] <smls> ShimmerFairy: 'Surreal' would be an even better name than "HyperReal'... :P

[13:26] <FROGGS_> (on 2015.07.1-399-g6b3930e at least)

[13:26] <ShimmerFairy> smls: not if you just want to support infinity and infinitesimal. Counting nesting would be horrendous :P

[13:26] *** FROGGS_ is now known as FROGGS

[13:27] <jnthn> nine: OK, will see if I've any energy left after finishing slides

[13:28] <nine> jnthn: thanks :) And no worry, there's still some plain old implementation tasks to do before we have to figure that out

[13:31] <masak> ShimmerFairy: if you really wanted to implement hyperreals, it feels like that wouldn't be all that hard with a (user-defined) class wrapping around Num, adding infinitesimals

[13:31] <nine> jnthn: btw. I really internalized the iterator based approach over the last week of hacking. I just love how we're now both much lazier than before and have saner and simpler semantics at the same time.

[13:31] <ShimmerFairy> Yeah, I don't really think it's the right solution to the problem with Inf, though :)

[13:32] <moritz> yes, the iterators are really nice

[13:32] <smls> yeah

[13:33] <jnthn> nine: Yeah, I worked at "simple but powerful enough" :)

[13:33] <moritz> and simple enough to use directly

[13:33] <jnthn> Glad it's working out as hoped :)

[13:33] <jnthn> moritz: That was also very much a goal

[13:34] <smls> btw, I wonder what English word we should use to casually refer to Seq objects in p6doc - "generator"? "sequence"? "lazy sequence"

[13:35] <jnthn> smls: "one-shot" might be good to get in there more than lazy

[13:35] <smls> good point

[13:36] <jnthn> I think generator may be a bit too loaded from other languages

[13:36] <jnthn> I did use the word a bit here once and found it was already quite overloaded.

[13:36] <jnthn> And haven't done so again :P

[13:36] *** rurban left
[13:37] <timotimo> since my python involvement, "generator" means "coroutine" to me

[13:37] <nine> Why do I get a "Cannot auto-generate a proto method for 'Int' in the setting" when trying to add a multi method Int to array?

[13:38] <timotimo> you may want to just put a "proto method Int" in there?

[13:38] <jnthn> timotimo: Yeah, and while a gather/take *does* give a Seq, Seq is more general than that

[13:38] <timotimo> aye

[13:38] <nine> timotimo: none of the other classes needs it?

[13:39] <nine> But of course the other classes are not repr('VMArray')

[13:39] <jnthn> nine: Should it not be inherited from List?

[13:39] <lizmat> nine: the core settings do not auto proto

[13:39] <[Coke]> . # messages

[13:39] <yoleaux> 20 Aug 2015 22:51Z <lizmat> [Coke]: re https://github.com/perl6/roast/commit/04520b26ec4c5eda97a53140d3c1105bf2e7f183  I have *no* idea, I just reran the generate script

[13:39] <yoleaux> 20 Aug 2015 22:51Z <lizmat> [Coke]: I assumed it to be a hash ordering thing

[13:39] <nine> jnthn: native array?

[13:39] <jnthn> nine: Ooh

[13:39] *** aborazmeh joined
[13:39] *** aborazmeh left
[13:39] *** aborazmeh joined
[13:40] <nine> Ah, just adding the darn proto helped :)

[13:40] *** muraiki joined
[13:40] <jnthn> nine: I'd guess because it inherits from something that doesn't provide a multi, but rather an only

[13:41] <dalek> rakudo/glr: 481a5ad | (Stefan Seifert)++ | src/core/native_array.pm:

[13:41] <dalek> rakudo/glr: Add an Int method to native array

[13:41] <dalek> rakudo/glr: 

[13:41] <dalek> rakudo/glr: Pre-GLR we inherited it from class Iterable

[13:41] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/481a5ad600

[13:42] <moritz> wait, native arrays aren't Iterable anymore?

[13:42] <hoelzro> in GLR-land, $[...] is equivalent to [...].item, right?

[13:42] <nine> m: say (1,2) === (1,2)

[13:42] <GLRelia> rakudo-moar 55b326: OUTPUT«False␤»

[13:42] <camelia> rakudo-moar 815fff: OUTPUT«True␤»

[13:42] <nine> jnthn: oh, since you're here. Is that ^^^ expected?

[13:43] <jnthn> moritz: Yes, but the Iterable role doesn't imply that you can ask for the number of elements

[13:43] <jnthn> hoelzro: yes

[13:43] <moritz> ah, good

[13:43] <jnthn> nine: I think TimToady said that should be True also in glr

[13:44] <nine> jnthn: that's...going to be interesting. Not even the slightest idea how to fix that :)

[13:44] <masak> they need to produce the same .WHICH

[13:44] <masak> no?

[13:44] <lizmat> masak: they need to be value types, .WHICH is an implementation detail  :-)

[13:44] <moritz> the case where .is-lazy is False is easy, no?

[13:45] <hoelzro> so for [1, 2, 3] { ... } should run 3 iterations, and for $[1, 2, 3] { ... } should run 1? (along with $([1, 2, 3]) and [1, 2, 3].item)

[13:45] <lizmat> moritz: not so

[13:45] <lizmat> m: [my $, my $, my $][0] = 42

[13:45] <GLRelia> rakudo-moar 55b326: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g_s8aft9KI␤Unsupported use of $] variable; in Perl 6 please use $*PERL.version or $*PERL.compiler.version␤at /tmp/g_s8aft9KI:1␤------> 3[my $, my $, my $]7⏏5[0] = 42␤»

[13:45] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/M0hhCiBPqE␤Unsupported use of $] variable; in Perl 6 please use $*PERL.version or $*PERL.compiler.version␤at /tmp/M0hhCiBPqE:1␤------> 3[my $, my $, my $]7⏏5[0] = 42␤»

[13:45] <lizmat> m: [my $, my $, my $ ][0] = 42

[13:45] <GLRelia> rakudo-moar 55b326: ( no output )

[13:45] <camelia> rakudo-moar 815fff: ( no output )

[13:46] <lizmat> m: say [my $, my $, my $ ][0] = 42

[13:46] <GLRelia> rakudo-moar 55b326: OUTPUT«42␤»

[13:46] <camelia> rakudo-moar 815fff: OUTPUT«42␤»

[13:46] <lizmat> so [...] can be mutable inside

[13:46] <moritz> lizmat: so it needs to respect the .WHICH of the container, if there's a container, right?

[13:46] <lizmat> only if all elements are immutable, do we have a value type

[13:47] <nine> ok @arr.list  === @arr, "$t array .list returns identity"; # I'm not sure how we can keep this up. .list does now a List.from-iterator(self.iterator) to keep e.g. Str.join from looping infinitely

[13:47] <lizmat> personally, I think we need to deal with it at compile time

[13:47] <lizmat> in the case of (1,2,3), the code gen should create a immutable subclass of Int that has a custom .WHICH

[13:47] <lizmat> (well, that would be my approach)

[13:47] <ShimmerFairy> subclass of List, you mean?

[13:48] <lizmat> ShimmerFairy: correct: s/Int/List/

[13:48] <lizmat> :-)

[13:48] <moritz> lizmat: or have a WHICH that includes the WHICH of the container elements

[13:48] <moritz> that way even   my $a; ($a, 1) === ($a, 1) will return True

[13:48] <lizmat> m: my $a = 42; say $a.WHICH

[13:48] <camelia> rakudo-moar 815fff: OUTPUT«Int|42␤»

[13:48] <GLRelia> rakudo-moar 481a5a: OUTPUT«Int|42␤»

[13:48] <moritz> which isn't bad, IMHO

[13:48] <ShimmerFairy> I wouldn't mind an immutable  class Tuple  , fwiw

[13:48] <lizmat> m: my $a = 42; say $a.VAR.WHICH

[13:48] <GLRelia> rakudo-moar 481a5a: OUTPUT«Scalar|68089432␤»

[13:48] <camelia> rakudo-moar 815fff: OUTPUT«Scalar|58390160␤»

[13:48] <ShimmerFairy> (which is what TimToady was talking about the other day)

[13:48] <moritz> m: say 42.VAR.WHICH

[13:48] <GLRelia> rakudo-moar 481a5a: OUTPUT«Int|42␤»

[13:48] <camelia> rakudo-moar 815fff: OUTPUT«Int|42␤»

[13:49] <nine> ShimmerFairy: where's the difference to a List where all items are bound to containerless values?

[13:49] <lizmat> so yeah, that could work at runtime

[13:49] <ShimmerFairy> nine: apparently List isn't immutable, so there's the difference :)

[13:50] <jnthn> nine: I think .list on @arr really should return identity; I'd see if we can't fix the join thing another way...

[13:50] <nine> ShimmerFairy: List _is_ immutable. It's the items that are not if they are containers

[13:50] <jnthn> nine: Why *is* join a problem? )

[13:50] <nine> jnthn: 15:50 < jnthn> nine: Why *is* join a problem? )

[13:50] <ShimmerFairy> nine: well, List isn't currently a value type, so as far as P6 is concerned, it's not immutable :)

[13:50] <nine> jnthn: I get a weird endless recurion of .list if method list(array:D:) { self }

[13:51] <jnthn> nine: Oh, you're on native arrays here rather than Array?

[13:52] <nine> jnthn: yes

[13:57] <nine> That's basically the only native tests still failing.

[13:58] <dalek> roast/glr: 0bdfd2e | (Stefan Seifert)++ | S09-typed-arrays/native- (2 files):

[13:58] <dalek> roast/glr: Need to flatten manually now in list assignment

[13:58] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/0bdfd2e5d1

[13:59] <lizmat> jnthn: re making [ |<a b c> ] work

[13:59] <FROGGS> jnthn: btw, I made Seq Cool, are you okay with that?

[14:00] <nine> FROGGS: you really should have asked if jnthn is cool with that :)

[14:00] <FROGGS> ;o)

[14:00] *** aborazmeh left
[14:00] <lizmat> jnthn: I basically removed the sorry from prefix:sym<|>   { <sym>  <O('%symbolic_unary')> }

[14:01] <lizmat> but am at a loss where to continue to get this to work

[14:01] <lizmat> I don't see anything with prefix:sym<|> in Actions

[14:02] <FROGGS> m: say "forty-two".comb() ~~ Positional; say "forty-two".comb().WHAT

[14:02] <camelia> rakudo-moar 815fff: OUTPUT«True␤(List)␤»

[14:02] <GLRelia> rakudo-moar 481a5a: OUTPUT«False␤(Seq)␤»

[14:02] * [Coke] will get an updated daily glr report with all these lovely fixes as soon as the JVM run finishes. Oi.

[14:02] <jnthn> lizmat: You don't need anything in actions

[14:02] <jnthn> FROGGS: Think I'm gool with it

[14:02] <jnthn> *cool

[14:02] <jnthn> damn, that ruined the pun

[14:02] <FROGGS> :D

[14:02] <nine> Everybody be cool

[14:02] <jnthn> lizmat: You just write sub prefix:<|)(\x) { x.Slip } in CORE.setting somewhere

[14:02] <jnthn> lizmat: That should do it

[14:03] <lizmat> ok, will do

[14:03] <ugexe> it seems like MAIN($arg, :@args) { } used to accept `--args="x" pos1`, but im seeing now it only works if i do `--args=x --args=x2 pos1`. (in moar-nom). is there a different way to do this, or is it just bugged right now? 

[14:03] <FROGGS> jnthn: now you're looking like a ghul in pyjamas

[14:04] *** rindolf joined
[14:05] <ugexe> as in, for MAIN arguments Positional needs more than 1 element. i just thought it was weird because it happens on nom

[14:06] <moritz> ugexe: should probably coercive in MAIN

[14:06] <ugexe> so just use :$args in the signature?

[14:06] <JimmyZ> lizmat: I think prefix | need to be in src/core/precedence.pm too

[14:06] <[Coke]> jnthn's al ghul.

[14:07] <lizmat> JimmyZ: good point

[14:08] <nine> Oh, of course! array inherits Any's join which does self.list.join. Since self.list returns self we get a nice endless recursion ;)

[14:09] <dalek> roast/glr: b7b35ef | FROGGS++ | S32-str/comb.t:

[14:09] <dalek> roast/glr: check that .comb() returns something Iterable

[14:09] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/b7b35efd2b

[14:13] <nine> m: my int @a = 1, 2, 3; @a.Supply();

[14:13] <GLRelia> rakudo-moar 481a5a: ( no output )

[14:13] <camelia> rakudo-moar 815fff: OUTPUT«Memory allocation failed; could not allocate 61792 bytes␤»

[14:13] <nine> There, same endless recursion in nom ^^^

[14:14] <nine> It's just that on nom much fewer of Any's methods did self.list.foo

[14:14] <nine> m: my int @a = 1, 2, 3; @a.Parcel();

[14:14] <GLRelia> rakudo-moar 481a5a: OUTPUT«Method 'Parcel' not found for invocant of class 'array[int]'␤  in block <unit> at /tmp/q6WKrcrfcV:1␤␤»

[14:14] <camelia> rakudo-moar 815fff: OUTPUT«Memory allocation failed; could not allocate 61792 bytes␤»

[14:14] <[Coke]> I need to rewrite roast's test_summary in perl6 so I can more easily run the tests in parallel and report on them in the original order.

[14:14] <nine> jnthn: ^^^ good enough reason to just kill the array.list returns identity test?

[14:15] <nine> [Coke]: I think few people will try to stop you from doing that ;)

[14:17] <moritz> [Coke]: +1

[14:18] <moritz> [Coke]: it'll make it much easier to diff the outputs

[14:19] <jnthn> nine: Hmm...well, might well be

[14:19] <jnthn> nine: Makes me a little confomrtable, somehow, but I can't put my finger on why

[14:19] <skids> nine: I rememeber stubbing my toe on that .join problem before too

[14:20] * [Coke] will see about doing that on the incredibly long day on the way to Olten. :)

[14:20] <[Coke]> .seen pmichaud

[14:20] <yoleaux> I saw pmichaud 14 Aug 2015 18:03Z in #perl6: <pmichaud> r: (12,24,13,97,11,10,100).pick(7).say

[14:20] <nine> jnthn: the alternative would be to add implementations of all of Any's methods that do the self.list.foo trick

[14:20] <jnthn> nine: Aye...that is probably not too expedient

[14:20] <nine> jnthn: I can do either. I just don't see a real good reason to require .list to return identity

[14:21] <jnthn> nine: Though we may want some of them for performance.

[14:21] <dalek> rakudo/glr: 0b1722b | lizmat++ | src/ (3 files):

[14:21] <dalek> rakudo/glr: Enable | as a generic flattener

[14:21] <dalek> rakudo/glr: 

[14:21] <dalek> rakudo/glr: $ 6 'say [|<a b c>,|<d e>].perl'

[14:21] <dalek> rakudo/glr: ["a", "b", "c", "d", "e"]

[14:21] <dalek> rakudo/glr: 

[14:21] <dalek> rakudo/glr: jnthn++, JimmyZ++ for support

[14:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/0b1722b40e

[14:21] <jnthn> lizmat++

[14:21] <jnthn> Glad it was as easy as hoped :)

[14:21] <nine> lizmat++ # I've wished for that for a week :)

[14:21] <lizmat> yup, it was *much* easier

[14:22] <lizmat> nine: yeah, wished for it today as well.. :-)

[14:22] <jnthn> Glad you slipped it in :)

[14:24] <skids> Oh yay, glad to see that won't be a wart in the end.

[14:26] *** mr-foobar joined
[14:26] <dalek> roast/glr: ebda77c | (Stefan Seifert)++ | S09-typed-arrays/native- (2 files):

[14:26] <dalek> roast/glr: Remove dubious test for native array's list method

[14:26] <dalek> roast/glr: 

[14:26] <dalek> roast/glr: I see no good reason for requiring native array's list method to return the

[14:26] <dalek> roast/glr: native array (it isn't a List after all). Implementing it this way would

[14:26] <dalek> roast/glr: generate endless recursions in all of Any's methods that follow the

[14:26] <dalek> roast/glr: method foo() { self.list.foo } pattern. There were a few of those pre-GLR

[14:26] <dalek> roast/glr: and many more now.

[14:26] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/ebda77cfd5

[14:26] <nine> I decided to just go for forgiveness ;)

[14:29] <smls> m: say [1, 2, 3].list.WHAT

[14:29] <GLRelia> rakudo-moar 0b1722: OUTPUT«(Array)␤»

[14:29] <camelia> rakudo-moar 815fff: OUTPUT«(Array)␤»

[14:30] <smls> nine: Will this ^^ change?

[14:30] <dalek> roast/glr: 09cf434 | lizmat++ | integration/advent201 (3 files):

[14:30] <dalek> roast/glr: Use | to slip instead of .Slip

[14:30] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/09cf43495c

[14:30] <nine> smls: no, that's no native array (my int @native_array;)

[14:30] <jnthn> smls: No, Array ~~ List

[14:30] <jnthn> array ain't though

[14:31] <smls> ah, ok

[14:31] * [Coke] likes |<c a m e l i a>

[14:32] <[Coke]> examples is again chewing a lot of CPU - one process, 2.5 cpus, 3CPU-hours.

[14:32] <[Coke]> not sure if this is expected or not.

[14:33] *** cognominal left
[14:34] * [Coke] nices it.

[14:35] <moritz> [Coke]: it's a "panda install" process

[14:35] <moritz> it surely shouldn't take that long

[14:35] * moritz kills it

[14:36] <[Coke]> that's 2 days in a row it's gone crazy, I think.

[14:39] <dalek> perl6-examples: 7e850ef | moritz++ | util/update-and-sync:

[14:39] <dalek> perl6-examples: Set memory and CPU limit in util/update-and-sync

[14:39] <dalek> perl6-examples: 

[14:39] <dalek> perl6-examples: this script has been running wild on hack two days in a row,

[14:39] <dalek> perl6-examples: so better stop it from doing that again

[14:39] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/7e850ef5a9

[14:41] <[Coke]> moritz++

[14:42] <moritz> .tell [ptc] I've set some ulimits in perl6-examples' update-and-sync, and updated the checkout on hack; that was in a detached HEAD previously. If master sounds wrong to you, please use "git reflog" to restore the old state (and fix the issue otherwise)

[14:42] <yoleaux> moritz: I'll pass your message to [ptc].

[14:43] <moritz> ah, I see now it that it operates in detached head state by default; no trouble

[14:43] * [Coke] sees a copy of vim taking 75% of cpu sustained on hack. weird.

[14:43] <[Coke]> ... 100%

[14:43] <[Coke]> stmuk?

[14:44] <moritz> [Coke]: probably one doing syntax hilighting through Text::VimColor

[14:44] <[Coke]> gentle reminder, everyone's automated stuff on hack should probably be nice'd.

[14:44] <moritz> and CPU time limited

[14:45] *** RabidGravy joined
[14:46] <timotimo> your syntax highlighter doesn't need to spend more than two days of cpu time per document!

[14:47] <dalek> roast/glr: a72e84e | (Stefan Seifert)++ | S09-typed-arrays/native- (2 files):

[14:47] <dalek> roast/glr: Update test counts after killing .list identity tests

[14:47] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/a72e84e979

[14:47] *** woolfy left
[14:47] <jnthn> OK, slides done, I'm going to relax

[14:48] <jnthn> Who knows, maybe I'll be lucky enough to sleep...

[14:48] <jnthn> o/

[14:48] <[Coke]> jnthn++

[14:48] <nine> jnthn: wish you luck :)

[14:48] <jnthn> Thanks :)

[14:48] <timotimo> good luck, jnthn!

[14:48] <dalek> nqp/js: 3b7c094 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[14:48] <dalek> nqp/js: Fix bug

[14:48] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/3b7c094bfa

[14:48] <dalek> nqp/js: 5814760 | (Pawel Murias)++ | src/vm/js/nqp-runtime/reprs.js:

[14:48] <dalek> nqp/js: WIP P6int deserialization

[14:48] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/5814760512

[14:48] <dalek> nqp/js: b6021ce | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[14:48] <dalek> nqp/js: Compile subcapture rxtype

[14:48] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/b6021cea3b

[14:48] <dalek> nqp/js: 1a24561 | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[14:48] <dalek> nqp/js: Add passing test 50

[14:48] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/1a24561d80

[14:48] <[Coke]> pmurias++

[14:49] <nine> pmurias++ indeed :)

[14:51] <[Coke]> pmurias: https://github.com/coke/perl6-roast-data/blob/master/log/nqp.js_summary.out shows an npm failure on the last run. haven't bisected to figure out when that started happening.

[14:51] <pmurias> checking that...

[14:51] <dalek> ecosystem: 800afdc | Carlin++ | META.list:

[14:51] <dalek> ecosystem: add FCGI; FastCGI module using NativeCall

[14:51] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/800afdc185

[14:52] *** FatalNIX left
[14:53] <pmurias> [Coke]: that sort of error is caused by debian renaming the node.js executable

[14:54] *** rurban joined
[14:55] * lizmat also calls it a day

[14:55] <lizmat> good night, #perl6!

[14:55] <pmurias> [Coke]: there seems to be a nodejs-legacy to solve that

[14:55] <nine> lizmat: good night :)

[14:56] <dalek> infrastructure-doc: 9521e13 | moritz++ | hosts/hack.p6c.org.pod:

[14:56] <dalek> infrastructure-doc: Add instructions for running automated jobs

[14:56] <dalek> infrastructure-doc: review: https://github.com/perl6/infrastructure-doc/commit/9521e13644

[14:57] <moritz> [Coke], [ptc], FROGGS, others: https://github.com/perl6/infrastructure-doc/commit/9521e13644feff3810402b4c6cd10ba49fcd7b4d

[14:58] <[Coke]> pmurias: it worked until August 1st.

[14:58] <[Coke]> possibly someone mucked with node.js on hack that day.

[14:58] *** luiz_lha left
[14:58] <masak> congratulations to everyone for prefix:<|> in GLR \o/

[14:59] <[Coke]> moritz++ thanks.

[14:59] <moritz> colomon: you have a smoker job running that's already used up 32 CPU hours. Is that intentional? If not, please CPU-limit your cron jobs (compare https://github.com/perl6/infrastructure-doc/commit/9521e13644feff3810402b4c6cd10ba49fcd7b4d)

[14:59] <pmurias> [Coke]: I have no control over that in nqp-js

[15:01] <moritz> [Coke], pmurias: should I install nodejs-legacy on hack?

[15:02] <pmurias> moritz: yes

[15:02] <pmurias> assuming when don't do any amature radio on hack

[15:03] *** diana_olhovik left
[15:04] <dalek> nqp/js: 88d6626 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[15:04] <dalek> nqp/js: Fix bug

[15:04] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/88d6626c0f

[15:04] <dalek> nqp/js: 9d8900e | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[15:04] <dalek> nqp/js: Run passing test 34

[15:04] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/9d8900e184

[15:05] <lizmat> now that we have | for flattening, I wonder whether we need the one arg rule still   # jnthn TimToady

[15:05] <colomon> moritz: not intentional, but I thought we set limits on smoke processes last month?  looking now

[15:06] <lizmat> m: my @a = (1,2,3); say @a.perl

[15:06] <GLRelia> rakudo-moar 0b1722: OUTPUT«[1, 2, 3]␤»

[15:06] <camelia> rakudo-moar 815fff: OUTPUT«[1, 2, 3]<>␤»

[15:06] <lizmat> m: my @a = |(1,2,3); say @a.perl   # not much worse

[15:06] <GLRelia> rakudo-moar 0b1722: OUTPUT«[1, 2, 3]␤»

[15:06] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/I46fPk1bgh␤Arg-flattening | is only valid in an argument list␤at /tmp/I46fPk1bgh:1␤------> 3my @a = |7⏏5(1,2,3); say @a.perl   # not much worse␤»

[15:07] <lizmat> my @a = |(1,2,3)   # feels completely consistent to me

[15:08] <[Coke]> moritz: maybe add "nice" to the list ?

[15:08] <lizmat> really afk&

[15:08] <[Coke]> lizmat: ~~

[15:08] <colomon> did hack just go down?  I suddenly cannot reach it.  :\

[15:09] <ShimmerFairy> It looks like unnecessary noise to me. prefix:<|> feels more like it's meant for places where single-arg doesn't kick in for you

[15:09] <[Coke]> colomon: I'm on hack.

[15:09] <[Coke]> (my irc client is there)

[15:09] <colomon> ssh hack.p6c.org

[15:09] <colomon> ssh: connect to host hack.p6c.org port 22: No route to host

[15:10] <[Coke]> still able to open new connections from my local box, also.

[15:10] <colomon> and the ssh login I had died.

[15:10] <colomon> weird

[15:10] <colomon> obviously I’ve still got some sort of connectivity here...

[15:10] <timotimo> did the host key for hack.p6c.org recently change?

[15:10] * [Coke] tries some hot tea with lime instead of lemon.

[15:14] <[Coke]> Hey, I've just been roped into doing a Q&A with TimToady at SPW. Feel free to privmsg or email me questions you'd like to see to see answered.

[15:16] <moritz> timotimo: I hope not :-)

[15:17] <moritz> timotimo: my client verifies the ECDA host key, and that didn't change

[15:17] <timotimo> ECDSA key fingerprint is SHA256:zcE9BYoYGXmc2tm+g1eB/SYtHpiFcU+7KMBEVgNDY10.

[15:17] <timotimo> does that seem right?

[15:18] <timotimo> also, it's surprisingly difficult to verify fingerprints sometimes

[15:18] <timotimo> i tried to ssh to a friend's computer and we had a really tough time to get the same format of fingerprint shown on both machines

[15:19] <moritz> timotimo: ssh -v says: "debug1: Server host key: ECDSA 99:47:b8:06:bb:ea:5c:35:37:9b:64:d6:e5:2d:9b:da

[15:19] <moritz> debug1: Host 'hack.p6c.org' is known and matches the ECDSA host key.

[15:19] <moritz> "

[15:21] <timotimo> debug1: Server host key: ecdsa-sha2-nistp256 SHA256:zcE9BYoYGXmc2tm+g1eB/SYtHpiFcU+7KMBEVgNDY10

[15:21] <timotimo> this is what i get instead

[15:21] <timotimo> see what i mean with regards to fingerprint format? :D

[15:21] <dalek> rakudo/glr: 05e46f5 | (Stefan Seifert)++ | src/core/Range.pm:

[15:21] <dalek> rakudo/glr: Implement general Range iterator using .pred and .succ

[15:21] <dalek> rakudo/glr: 

[15:21] <dalek> rakudo/glr: Spec says the Range iterator should just the .succ method to get the next

[15:21] <dalek> rakudo/glr: element. So that is what we do if we have no specialized iterator.

[15:21] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/05e46f5774

[15:22] *** khw joined
[15:32] *** Ven left
[15:33] <nine> How can I prevent infix:<minmax>(*@args) from flattening its arguments and thus prevent is (1..100000000000000000 minmax 2..999999999999999999).gist, (1..999999999999999999).gist from hanging?

[15:34] <JimmyZ> nine: how about **args is rw

[15:34] <JimmyZ> **@args is rw

[15:36] <JimmyZ> nine: http://irclog.perlgeek.de/perl6/2015-08-13#i_11051703 # if you missed it

[15:36] <nine> JimmyZ: brilliant! Many thanks!

[15:42] *** abuck05 joined
[15:43] *** Loren_ left
[15:46] *** pmurias left
[15:47] *** Ven joined
[15:48] <dalek> rakudo/glr: b11bd66 | (Stefan Seifert)++ | src/core/Any-iterable-methods.pm:

[15:48] <dalek> rakudo/glr: Fix almost endless loop on 1..1000000000000 minmax 2..9999999999999

[15:48] <dalek> rakudo/glr: 

[15:48] <dalek> rakudo/glr: minmax should not flatten its arguments.

[15:48] <dalek> rakudo/glr: Many thanks to JimmyZ++ for pointing out the correct fix.

[15:48] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/b11bd66a34

[15:48] <nine> 163 to go

[15:50] * Ven puts down his talk and clones the glr branch

[15:51] *** carlin joined
[15:52] <carlin> timotimo: the incantation you want is: ssh -oFingerprintHash=md5

[15:52] <timotimo> thank you!

[15:52] <timotimo> that's magical!

[15:53] <timotimo> also, can you consider giving your fcgi module a different name? there's already a fastcgi module and perhaps yours could be FastCGI::NativeCall or FastCGI::C ?

[15:53] <carlin> that sounds reasonable

[15:54] <carlin> I called it FCGI because it uses the same C library and a similar interface as Perl 5's FCGI module but I'm not attached to the name at all

[15:54] *** abuck05 left
[15:55] *** telex left
[15:56] <JimmyZ> m: (1..100000000000000000 minmax 2..999999999999999999).gist

[15:56] <GLRelia> rakudo-moar b11bd6: ( no output )

[15:56] <camelia> rakudo-moar 815fff: ( no output )

[15:56] *** amurf joined
[15:56] *** telex joined
[15:56] <JimmyZ> m: say (1..100000000000000000 min 2..999999999999999999).gist

[15:56] <GLRelia> rakudo-moar b11bd6: OUTPUT«1..100000000000000000␤»

[15:56] <camelia> rakudo-moar 815fff: OUTPUT«1..100000000000000000␤»

[15:56] <JimmyZ> m: say (1..100000000000000000 max 2..999999999999999999).gist

[15:56] <GLRelia> rakudo-moar b11bd6: OUTPUT«2..999999999999999999␤»

[15:56] <camelia> rakudo-moar 815fff: OUTPUT«2..999999999999999999␤»

[15:57] <JimmyZ> m: say (1..100000000000000000 minmax 2..999999999999999999).gist

[15:57] <GLRelia> rakudo-moar b11bd6: OUTPUT«1..999999999999999999␤»

[15:57] <camelia> rakudo-moar 815fff: OUTPUT«1..999999999999999999␤»

[15:58] <tony-o> it broke

[15:59] <nine> did it?

[15:59] *** KCL_ joined
[16:00] *** amurf left
[16:01] <dalek> rakudo/glr: 6d1d307 | (Stefan Seifert)++ | src/core/Range.pm:

[16:01] <dalek> rakudo/glr: Fix "Can't elems a lazy list" on (1e0..3e0).elems

[16:01] <dalek> rakudo/glr: 

[16:01] <dalek> rakudo/glr: Lazy in general means that we can't know how many elements it will be.

[16:01] <dalek> rakudo/glr: In this case we do.

[16:01] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6d1d307844

[16:02] <JimmyZ> nine: I think min/max needs 'is rw' too.

[16:02] *** raiph joined
[16:03] <nine> 162 to go

[16:05] <nine> JimmyZ: you're probably right. Do you know some tests that would fix?

[16:05] <raiph> <moritz> sigilless vars ... don't force a container .... <nine> that they don't have a container ... nine: moritz is right you've gone too far (sigilless vars *can* be bound to a container)

[16:06] <raiph> m: my \array = @; array[3] = 1; say array

[16:06] <GLRelia> rakudo-moar b11bd6: OUTPUT«(Any) (Any) (Any) 1␤»

[16:06] <camelia> rakudo-moar 815fff: OUTPUT«(Any) (Any) (Any) 1␤»

[16:06] *** Ven left
[16:07] <raiph> m: my \array =@= [1,2,3,4]; array[3] = 1; say array

[16:07] <GLRelia> rakudo-moar 6d1d30: OUTPUT«1 2 3 1␤»

[16:07] <camelia> rakudo-moar 815fff: OUTPUT«1 2 3 4 (Any) (Any) 1␤»

[16:07] <JimmyZ> I don't, but it seems that using List always uses a bit less memory when we don't need array.

[16:07] <JimmyZ> nine: ^^

[16:08] *** ab6tract joined
[16:09] <raiph> m: my \array =@= 1,2,3,4; array[3] = 1; say array

[16:09] <GLRelia> rakudo-moar 6d1d30: OUTPUT«1 2 3 1␤»

[16:09] <camelia> rakudo-moar 815fff: OUTPUT«1 2 3 1␤»

[16:09] <JimmyZ> m: (1e0..*).elems 

[16:09] <GLRelia> rakudo-moar 6d1d30: ( no output )

[16:09] <camelia> rakudo-moar 815fff: ( no output )

[16:09] <JimmyZ> m:say  (1 ..*).elems 

[16:10] <JimmyZ> m:(1 ..*).elems 

[16:11] <moritz> m: say (1..*).elems

[16:11] <GLRelia> rakudo-moar 6d1d30: OUTPUT«Inf␤»

[16:11] <camelia> rakudo-moar 815fff: OUTPUT«Inf␤»

[16:11] <PerlJam> heh

[16:12] <PerlJam> JimmyZ: "m: " is significant :)

[16:12] <JimmyZ> :)

[16:12] <moritz> yes, the whitespace is necessary, otherwise nqp::op would trigger the "nqp:" target

[16:13] <ab6tract> lizmat: https://github.com/perl6/roast/commit/ca092df7f9  <---- that explicit itemization makes me sad

[16:14] <PerlJam> wait ... that's needed for glr?

[16:15] <ab6tract> is that going to be permanent going forward?

[16:15] <ab6tract> PerlJam: I hope not :(

[16:15] *** domidumont left
[16:15] *** laben joined
[16:16] <laben> hello p6'ers

[16:16] <ab6tract> but probably so.. Array will flatten if it is a single arg? 

[16:16] <timotimo> huh!

[16:16] <timotimo> m: say ("circle" => ["a" => 1, "b" => 2, "c" => 3]).perl

[16:16] <GLRelia> rakudo-moar 6d1d30: OUTPUT«:circle($[:a(1), :b(2), :c(3)])␤»

[16:16] <camelia> rakudo-moar 815fff: OUTPUT«:circle([:a(1), :b(2), :c(3)])␤»

[16:16] <timotimo> seems like it already gets itemized there

[16:16] <PerlJam> that's what I thought

[16:18] * ab6tract exhales deeply

[16:18] <ab6tract> timotimo++   # a better approach to the question than holding one's breath

[16:20] <laben> nine++ still glr-ing out there?

[16:20] <hoelzro> in post-GLR, does my @a := $[1, 2, 3] make sense? does it result in @a having 1, 2, and 3 as its elements?

[16:21] <laben> m: dd $[1, 2, 3]

[16:21] <GLRelia> rakudo-moar 6d1d30: OUTPUT«$[1, 2, 3]␤»

[16:21] <camelia> rakudo-moar 815fff: OUTPUT«(Any, Any, Any)␤»

[16:21] <laben> m: my @a = $[1, 2, 3]; dd @a

[16:21] <GLRelia> rakudo-moar 6d1d30: OUTPUT«@a = [$[1, 2, 3]]␤»

[16:21] <camelia> rakudo-moar 815fff: OUTPUT«@a = [Any, Any, Any]<>␤»

[16:21] <nine> ab6tract: especially since [] itemizes its items. So I really don't see how the $[] should be necessary

[16:21] <laben> m: my @a := $[1, 2, 3]; dd @a

[16:21] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[1, 2, 3]␤»

[16:21] <camelia> rakudo-moar 815fff: OUTPUT«(Any, Any, Any)␤»

[16:22] <nine> laben: well I should shift my focus on making dinner now, before the shops close :)

[16:22] <ab6tract> m: my @a := [1,2,3]; dd @a

[16:22] <camelia> rakudo-moar 815fff: OUTPUT«[1, 2, 3]<>␤»

[16:22] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[1, 2, 3]␤»

[16:22] <laben> m: my @a = [1, 2, 3]; dd @a

[16:22] <camelia> rakudo-moar 815fff: OUTPUT«@a = [[1, 2, 3]]<>␤»

[16:22] <GLRelia> rakudo-moar 6d1d30: OUTPUT«@a = [1, 2, 3]␤»

[16:22] <ab6tract> nine: thank you for confirming that. I was close to losing faith there for a second

[16:23] * ab6tract spins up a blank presentation template. time to prepare for SPW and YAPC::EU!

[16:23] <nine> Oh yes, that's still a big TODO for this weekend :(

[16:24] <hoelzro> I'm just wondering with my @a := $[1, 2, 3]; my @b = @a, 4, 5; if @a would flatten in @b's initialization

[16:24] <nine> it shouldn't

[16:25] <nine> m: my @a := $[1, 2, 3]; my @b = @a, 4, 5; say @b.perl;

[16:25] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[$[1, 2, 3], 4, 5]␤»

[16:25] <camelia> rakudo-moar 815fff: OUTPUT«[Any, Any, Any, 4, 5]<>␤»

[16:25] <nine> m: my @a := $[1, 2, 3]; my @b = |@a, 4, 5; say @b.perl;

[16:25] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[1, 2, 3, 4, 5]␤»

[16:25] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/80T__LT92V␤Arg-flattening | is only valid in an argument list␤at /tmp/80T__LT92V:1␤------> 3my @a := $[1, 2, 3]; my @b = |7⏏5@a, 4, 5; say @b.perl;␤»

[16:25] <nine> Explicit flattening FTW

[16:25] <hoelzro> so the "flattening-ness" of $[...] is attached the object? it's not just sugar for [...].item?

[16:25] <PerlJam> glr++

[16:25] <timotimo> what's wrong with rakudo/nom in there?

[16:25] <timotimo> why do things turn into Any there?

[16:25] <nine> m: my @a := [1, 2, 3]; my @b = @a, 4, 5; say @b.perl;

[16:25] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[$[1, 2, 3], 4, 5]␤»

[16:25] <camelia> rakudo-moar 815fff: OUTPUT«[1, 2, 3, 4, 5]<>␤»

[16:25] <nine> m: my @a = [1, 2, 3]; my @b = @a, 4, 5; say @b.perl;

[16:25] <GLRelia> rakudo-moar 6d1d30: OUTPUT«[$[1, 2, 3], 4, 5]␤»

[16:25] <camelia> rakudo-moar 815fff: OUTPUT«[[1, 2, 3], 4, 5]<>␤»

[16:25] <nine> all the same

[16:26] <nine> timotimo: I have no idea...and I don't particularly care ;) I'm really just focusing on GLR

[16:27] <laben> File::Find problem is golfed down to this thing m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b>>.pred

[16:27] <laben> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b>>.pred

[16:27] <GLRelia> rakudo-moar 6d1d30: OUTPUT«True True True␤»

[16:27] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:27] <laben> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b.map(*.pred)

[16:27] <GLRelia> rakudo-moar 6d1d30: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/tf1eS5jF_8:1␤␤»

[16:27] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:27] <laben> nine: is this expected?

[16:27] <ab6tract> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b.list.map(*.pred)

[16:27] <GLRelia> rakudo-moar 6d1d30: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/KElQqvaDeP:1␤␤»

[16:27] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:28] <ab6tract> laben: that's an interesting corner case indeed

[16:28] <nine> laben: I'm inclined to say yes. That would be one of those cases where you have to store the list yourself.

[16:29] <laben> but @b is an Array, why would i expect it to become a Seq after .map?

[16:29] <ab6tract> m: my @a = 1..3; my @b = (2..4)>>.pred; say @a >>~~<< @b

[16:29] <GLRelia> rakudo-moar 6d1d30: OUTPUT«True True True␤»

[16:29] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:29] <nine> laben: in other words: being explicit about wanting that list to be stored. A big reason for the GLR was that we stored always, even when in most cases we never reused the produced values. This cost a lot of performance.

[16:29] <tony-o> m: say 'hello'.split('').perl

[16:29] <camelia> rakudo-moar 815fff: OUTPUT«("", "h", "e", "l", "l", "o", "")␤»

[16:29] <GLRelia> rakudo-moar 6d1d30: OUTPUT«("", "h", "e", "l", "l", "o", "").iterator␤»

[16:30] <hoelzro> in https://github.com/perl6/roast/commit/ca092df7f954841d9ed84322e67706dc4ea2424f, is the new $ prefix on the circle value necessary?

[16:30] <tony-o> should there be empty '' in there?..

[16:30] <hoelzro> sorry for the all the questions, I'm just trying to familiarize myself with the GLR

[16:30] <hoelzro> on the off chance I have time to work on it this weekend, but also for the WS next week

[16:30] <nine> m: my @a = 1..3; my @b = (2..4)>>.pred; say @a >>~~<< @b.map(*.pred).List

[16:30] <camelia> rakudo-moar 815fff: OUTPUT«False False False␤»

[16:30] <GLRelia> rakudo-moar 6d1d30: OUTPUT«False False False␤»

[16:31] <laben> nine: why doesn't >> create a Seq too, then?

[16:31] <PerlJam> tony-o: yes.  hold on a sec, let me find where TimToady said as much.

[16:31] <timotimo> hyperops are eagerer than eager

[16:31] <timotimo> people - including me - seem to forget this quite often :)

[16:31] <laben> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b.map(*.pred).List

[16:31] <GLRelia> rakudo-moar 6d1d30: OUTPUT«True True True␤»

[16:31] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:33] <timotimo> hm, though a bunch of hyperops chained don't really need to store stuff on every step of the way

[16:33] <nine> I'd say it's mostly a matter of finding the time to refactor them.

[16:33] <nine> First priority for me is to get stuff working

[16:33] <laben> i understand eager and lazy, but the problem here is that somehow the Seq is iterated multiple times even though i would expect only once...

[16:34] <PerlJam> tony-o: RT#112868

[16:34] <PerlJam> https://rt.perl.org/Ticket/Display.html?id=112868

[16:34] <nine> laben: feel free to investigate further :) There could still be a bug or five somewhere in there.

[16:34] * PerlJam plays the part of the bot for a second

[16:35] <tony-o>  PerlJam thank you 

[16:36] <nine> laben: 10 days ago I knew pretty much nothing about the GLR or hyper operators (just learned about the >> << thing two days ago) or much else. So I would be very surprised if everything I did in the mean time was even vaguely correct.

[16:36] *** carlin left
[16:36] <laben> nine: a hint to know where to look for >>~~<< op?

[16:37] *** synbot6 joined
[16:38] <nine> laben: src/core/metaops.pm line 384

[16:38] <ab6tract> m: (1,*,2).WHAT.perl.say

[16:38] <camelia> rakudo-moar 815fff: OUTPUT«Parcel␤»

[16:38] <GLRelia> rakudo-moar 6d1d30: OUTPUT«List␤»

[16:40] *** lucasb joined
[16:40] <ab6tract> hoelzro: that same thing just about gave me a heart attack! but no, the explicit itemization should not be necessary. not sure what lizmat ran into that led her to add it

[16:41] <ab6tract> m: say ('circle' => [<k v r>]).perl

[16:41] <GLRelia> rakudo-moar 6d1d30: OUTPUT«:circle($["k", "v", "r"])␤»

[16:41] <camelia> rakudo-moar 815fff: OUTPUT«:circle(["k", "v", "r"])␤»

[16:41] <PerlJam> laben: When you List-ify the Seq, you can iterate any number of times.

[16:42] <PerlJam> ab6tract: probably the first attempt to fix was to add explicit itemization, and then when that didn't work, she added the .Slip and since that *did* work ... commit!

[16:42] <ab6tract> laben: afaict it's that the hyper is trying to consume the map'd Seq, which explodes

[16:42] <ab6tract> m: my @a = 1..3; my @b = 2..4; say @a >>~~<< @b.map(*.pred).list

[16:42] <GLRelia> rakudo-moar 6d1d30: OUTPUT«True True True␤»

[16:42] <camelia> rakudo-moar 815fff: OUTPUT«True True True␤»

[16:43] <ab6tract> (I tried something similar earlier, but put the list-ify in the wrong place)

[16:43] <nine> m: my @a = 1..3; my @b = (2..4)>>.pred; say (@a >>~~<< @b).map(*.pred)

[16:43] <GLRelia> rakudo-moar 6d1d30: OUTPUT«False False False␤»

[16:43] <camelia> rakudo-moar 815fff: OUTPUT«False False False␤»

[16:43] <nine> m: my @a = 1..3; my @b = (2..4)>>.pred; say @a >>~~<< (@b.map(*.pred))

[16:43] <GLRelia> rakudo-moar 6d1d30: OUTPUT«This Seq has already been iterated, and its values consumed␤  in block <unit> at /tmp/43KpsbDp8d:1␤␤»

[16:43] <camelia> rakudo-moar 815fff: OUTPUT«False False False␤»

[16:43] <FROGGS> o/

[16:43] <ab6tract> m: my @a = 1..3; my @b = (2..4)>>.pred; say @a >>~~<< (my @c = @b.map(*.pred))

[16:43] <GLRelia> rakudo-moar 6d1d30: OUTPUT«False False False␤»

[16:43] <camelia> rakudo-moar 815fff: OUTPUT«False False False␤»

[16:43] <ab6tract> :)

[16:44] <ab6tract> m: my @a = 1..3; my @b = (2..4)>>.pred; say @a >>~~<< my @c = @b.map(*.pred)

[16:44] <GLRelia> rakudo-moar 6d1d30: OUTPUT«False False False␤»

[16:44] <camelia> rakudo-moar 815fff: OUTPUT«False False False␤»

[16:44] <ab6tract> (overly cautious parens)

[16:46] <ab6tract> though stylistically I would include them for clarity's sake

[16:48] <lucasb> i'm newbie in IRC, so do you know if there is a way to put both GLRelia and camelia in the same /query window?

[16:49] *** rurban left
[16:49] *** zakharyas left
[16:51] <PerlJam> lucasb: I think you can do "/msg nick1,nick2 foo", but it's not something I've ever done.

[16:54] <dalek> roast/glr: 3ee1cd0 | PerlJam++ | integration/advent2012-day20.t:

[16:54] <dalek> roast/glr: Remove unneeded explicit itemization

[16:54] <dalek> roast/glr: review: https://github.com/perl6/roast/commit/3ee1cd0d39

[16:54] <hoelzro> ab6tract: alright, thanks for confirming!

[16:55] <hoelzro> nine++ and PerlJam++ are just killing it lately on the GLR stuff

[16:55] <hoelzro> (jnthn++ too!)

[16:56] <PerlJam> hoelzro: I just want to know who's going to pull the trigger on merging GLR into nom  (and master for roast).

[16:56] <[Coke]> FFFFFFFFFFFFFFUUUUUUUUUU

[16:56] <PerlJam> (might also be a good time to rename nom to master if that's in the cards)

[16:57] * [Coke] has to rerun the daily run today because he's an idiot.

[16:57] <ab6tract> PerlJam: I don't think there will be a merge, but rather s/glr/master

[16:57] <ab6tract> that's as I understood it

[16:57] <ShimmerFairy> ab6tract: that was just a jocular suggestion once, that's not likely to happen

[16:58] <PerlJam> ab6tract: oh.  whichever ... I'm waiting on the release until it happens.  And if its put off until Sunday, someone else may have to do the release.

[16:58] <ab6tract> ShimmerFairy: no, afaik TimToady and jnthn both want 'glr' to become 'master'

[16:59] <ShimmerFairy> I was there when jnthn made the suggestion in jest, and I don't recall TimToady saying anything.

[16:59] *** mjgardner joined
[16:59] <PerlJam> ShimmerFairy: how do you know it was in jest? ;)

[16:59] <ab6tract> ShimmerFairy: I was there too, and remember it differently :)

[16:59] <ShimmerFairy> PerlJam: because I was pointing out how having a years-old "_new_ object model" branch was kinda silly :P

[16:59] <ab6tract> but not enough time to dig through the backlog

[17:00] <ab6tract> it has been mentioned more than once, to be sure

[17:00] <dalek> perl6-roast-data: e094bf2 | coke++ | perl6_pass_rates.csv:

[17:00] <dalek> perl6-roast-data: Remove run from yesterday with bad nqp req.

[17:00] <dalek> perl6-roast-data: 

[17:00] <dalek> perl6-roast-data: Did another run after that.

[17:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e094bf2f18

[17:00] <ShimmerFairy> there were later clarifications that it was unlikely, as well

[17:00] <ab6tract> does anyone have exciting examples of Whatever (but not WhateverCode) outside of Range?

[17:00] <PerlJam> ShimmerFairy: everyone I know in Baton Rouge Louisian calls the I-10 bridge over the Mississippi River the "new bridge".  that bridge has got to be 50+ years old.  :)

[17:00] <ab6tract> ShimmerFairy: okay, maybe I missed those

[17:01] <RabidGravy> are the details important? except by way of someone knowing from what to make a release?

[17:01] <ShimmerFairy> PerlJam: yeah, I still remember TimToady's(?) example from Oxford :)

[17:01] <smls> ab6tract: array slicing

[17:01] <PerlJam> exactly :)

[17:01] <ab6tract> smls: thanks

[17:02] <[Coke]> I would recommend combinging "merging glr to mainline" with "making master mainline"

[17:02] <ShimmerFairy> RabidGravy: as long as the divergent work between nom and glr come together in the end, not really :)

[17:02] <[Coke]> ugh.

[17:02] <[Coke]> I would recommend NOT combinging "merging glr to mainline" with "making master mainline"

[17:02] <[Coke]> *combining

[17:02] <[Coke]> because we still don't have a clear picture of the git repo layout post christmas.

[17:03] <smls> ab6tract: also, list repetition ($foo xx *)

[17:03] * [Coke] kicks off YA daily run, arglebargles.

[17:04] <tony-o> is there a way to anonymous sub a >>

[17:04] <tony-o> m: 'hello'.index('e')>>.&(sub ($pos) { $pos.say; });

[17:04] <GLRelia> rakudo-moar 6d1d30: OUTPUT«1␤»

[17:04] <camelia> rakudo-moar 815fff: OUTPUT«1␤»

[17:04] <tony-o> guess so

[17:05] <tony-o> full blown perl6 

[17:06] <ab6tract> smls: any thoughts on when such a list repetition would be useful? ;)

[17:06] <PerlJam> tony-o: it's weird that you used >> on index instead of indices   :)

[17:07] <PerlJam> ab6tract: it's used in the implementation of .rotor()

[17:07] <lucasb> PerlJam: thanks. /msg works but not the exact way I wanted

[17:08] *** espadrine left
[17:08] <PerlJam> :q

[17:08] <PerlJam> oops

[17:08] <smls> m: my @rnd := rand xx *;  say @rnd[0..5];  # ab6tract

[17:08] <camelia> rakudo-moar 815fff: OUTPUT«0.562594830679797 0.589118153674792 0.210635966825477 0.678320062315838 0.931913591991977 0.340109058192961␤»

[17:08] <GLRelia> rakudo-moar 6d1d30: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Seq'␤  in block <unit> at /tmp/Pd5KeKJjhU:1␤␤»

[17:09] *** rurban joined
[17:09] <ab6tract> smls, PerlJam: thanks!

[17:09] <ab6tract> m:  my @a = [[50..55],[1..5]],[[60..66],[1..6]],[[70..77],[1..7]]; dd @a[*][0]

[17:09] <camelia> rakudo-moar 815fff: OUTPUT«@a = [[50, 51, 52, 53, 54, 55], [1, 2, 3, 4, 5]]␤»

[17:09] <GLRelia> rakudo-moar 6d1d30: OUTPUT«@a = $[$[50, 51, 52, 53, 54, 55], $[1, 2, 3, 4, 5]]␤»

[17:10] <tony-o> PerlJam: always curious of different ways to do some of this stuff..i kind of like that more than the if $str.index -> $pos { } syntax

[17:11] <dalek> rakudo/glr: 1fdc7a8 | (Jimmy Zhuo)++ | src/core/Any-iterable-methods.pm:

[17:11] <dalek> rakudo/glr: Added sub min/max args with 'is rw'

[17:11] <dalek> rakudo/glr: 

[17:11] <dalek> rakudo/glr: We don't need Array here, List is enough, which is the same as sub minmax()

[17:11] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/1fdc7a83ed

[17:11] <dalek> rakudo/glr: 5873e1a | niner++ | src/core/Any-iterable-methods.pm:

[17:11] <dalek> rakudo/glr: Merge pull request #507 from zhuomingliang/patch-5

[17:11] <dalek> rakudo/glr: 

[17:11] <dalek> rakudo/glr: Added sub min/max args with 'is rw'

[17:11] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/5873e1ae83

[17:12] <ab6tract> m:  my @a = [50..55],[60..66],[70..77]; dd @a[*][1]    # I would have expected 51,61,71 ....

[17:12] <GLRelia> rakudo-moar 6d1d30: OUTPUT«@a = $[60, 61, 62, 63, 64, 65, 66]␤»

[17:12] <camelia> rakudo-moar 815fff: OUTPUT«@a = [60, 61, 62, 63, 64, 65, 66]␤»

[17:13] <tony-o> m: 'hello'.index('e')>>.&({ .say; });

[17:13] <GLRelia> rakudo-moar 6d1d30: OUTPUT«1␤»

[17:13] <camelia> rakudo-moar 815fff: OUTPUT«1␤»

[17:14] <smls> m: my @a = [50..55],[60..66],[70..77]; dd @a[*]»[1]  # ab6tract

[17:14] <camelia> rakudo-moar 815fff: OUTPUT«(51, 61, 71)␤»

[17:14] <GLRelia> rakudo-moar 6d1d30: OUTPUT«(51, 61, 71)␤»

[17:15] <smls> m: my @a = [50..55],[60..66],[70..77]; dd @a[*;1]  # ab6tract

[17:15] <GLRelia> rakudo-moar 6d1d30: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <unit> at /tmp/IHxwjGJyoN:1␤␤»

[17:15] <camelia> rakudo-moar 815fff: OUTPUT«(51, 61, 71)␤»

[17:15] <PerlJam> tony-o: just don't rely on side-effects if you really need to use >> like that.

[17:15] <PerlJam> tony-o: for instance ...

[17:15] <PerlJam> m: 'hello cruel world'.indices('l')>>.&({ .say });

[17:15] <GLRelia> rakudo-moar 6d1d30: OUTPUT«15␤3␤10␤2␤»

[17:15] <camelia> rakudo-moar 815fff: OUTPUT«15␤3␤10␤2␤»

[17:15] <timotimo> really, you want to use the multi-dimensional slice syntax for that, as smls has shown

[17:15] <ab6tract> ahh....! [][] is not equivalent to [;]

[17:15] <timotimo> very muhc not

[17:15] <timotimo> much not*

[17:16] <tony-o> PerlJam++

[17:16] *** LitterallyTriggr joined
[17:17] <LitterallyTriggr> Hi

[17:17] <LitterallyTriggr> has the perl6 performance been fixed for debian

[17:17] <LitterallyTriggr> and other linux distros

[17:17] <PerlJam> lucasb: define "fixed" :)

[17:17] <ab6tract> so in my earlier broken example, the first [*] is just ignored, and it takes the [1] of the array

[17:17] <PerlJam> er, LitterallyTriggr 

[17:17] <ab6tract> which explains why I could add as many of them as I wanted and nothing would change :)

[17:17] <tony-o> m: my $str = 'hello literally'; $str.index('l')>>.&({ .say; $str.index('l', $_+1)>>.&?BLOCK; });

[17:17] <GLRelia> rakudo-moar 5873e1: OUTPUT«2␤3␤6␤12␤13␤␤The 'gimme' method was an internal method used by rakudo before the Great␤List Refactor.  The fact that you are seeing this message, means that you␤have code that was using that unsupported rakudo internal API.␤␤Please refa…»

[17:17] <camelia> rakudo-moar 815fff: OUTPUT«2␤3␤6␤12␤13␤»

[17:17] <LitterallyTriggr> Slow compiling and execution times

[17:18] <tony-o> PerlJam: i know there is indices :-), just interesting

[17:18] <raiph> LitterallyTriggr: what's your perl6 -v ?

[17:18] <LitterallyTriggr> tony-o: BLOCK literal 

[17:18] <tony-o> LitterallyTriggr: huh?

[17:18] <LitterallyTriggr> This is perl6 version 2014.07 built on parrot 6.6.0 revision 0

[17:18] <PerlJam> LitterallyTriggr: I understand the problem, I don't know what you mean by "fixed".   The compilation and execution times are getting better.  They are adequate for most of my purposes

[17:18] <PerlJam> LitterallyTriggr: yikes!

[17:18] <LitterallyTriggr> they're horrendous.

[17:19] <tony-o> you might want to build p6 with rakudobrew LitterallyTriggr 

[17:19] <LitterallyTriggr> Let me guess. I'm severely out of date?

[17:19] <ab6tract> LitterallyTriggr: indeed. Parrot was deprecated earlier this year, and has not been a preferred vm fro much longer than that

[17:19] <tony-o> by over a year now LitterallyTriggr 

[17:19] <tony-o> LitterallyTriggr: https://github.com/tadzik/rakudobrew

[17:20] <LitterallyTriggr> I might hold out for now

[17:21] <LitterallyTriggr> Wait for perl6 to get more adoption

[17:21] <tony-o> you can parse json with perl6 already, what more adoption do you need, really?

[17:21] <PerlJam> LitterallyTriggr: it's fun to play with in the mean time :)

[17:21] <LitterallyTriggr> tony-o: I rather use Javascript with Node.js

[17:21] <raiph> LitterallyTriggr: a current rakudo will be a fundamentally different experience

[17:21] <PerlJam> LitterallyTriggr: Do you use Perl 5 or Python?

[17:22] <LitterallyTriggr> both

[17:22] <LitterallyTriggr> I prefer Java to them all.

[17:22] <tony-o> sadist

[17:22] <PerlJam> LitterallyTriggr: You can use Perl 5 and/or Python from within Perl 6 with the Inline::Perl5 and Inline::Python modules.  Quite handy that.

[17:22] <LitterallyTriggr> p6: def hi(){say("hi");} my $v = &hi; $v();

[17:22] <GLRelia> rakudo-moar 5873e1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Strange text after block (missing semicolon or comma?)␤at /tmp/tmpfile:1␤------> 3def hi(){say("hi");}7⏏5 my $v = &hi; $v();␤    expecting any of:␤        infix␤        infix stopper…»

[17:22] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Strange text after block (missing semicolon or comma?)␤at /tmp/tmpfile:1␤------> 3def hi(){say("hi");}7⏏5 my $v = &hi; $v();␤    expecting any of:␤        infix␤        infix stopper…»

[17:23] <ab6tract> m: sub hi(){say("hi");} my $v = &hi; $v()

[17:23] <GLRelia> rakudo-moar 5873e1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/z3e1Xuoynn␤Strange text after block (missing semicolon or comma?)␤at /tmp/z3e1Xuoynn:1␤------> 3sub hi(){say("hi");}7⏏5 my $v = &hi; $v()␤    expecting any of:␤        infix␤        infix stop…»

[17:23] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/h90S6Et_oP␤Strange text after block (missing semicolon or comma?)␤at /tmp/h90S6Et_oP:1␤------> 3sub hi(){say("hi");}7⏏5 my $v = &hi; $v()␤    expecting any of:␤        infix␤        infix stop…»

[17:23] <raiph> LitterallyTriggr: if your interest is as a user, not contributor, waiting makes sense too because it continually improves

[17:23] <LitterallyTriggr> ^

[17:23] <tony-o> and the syntax changes week to week

[17:23] <LitterallyTriggr> What's wrong with my syntax

[17:24] <LitterallyTriggr> p6: def hi(){say("hi");} my $v = &hi(); $v();

[17:24] <GLRelia> rakudo-moar 5873e1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Strange text after block (missing semicolon or comma?)␤at /tmp/tmpfile:1␤------> 3def hi(){say("hi");}7⏏5 my $v = &hi(); $v();␤    expecting any of:␤        infix␤        infix stopper…»

[17:24] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Strange text after block (missing semicolon or comma?)␤at /tmp/tmpfile:1␤------> 3def hi(){say("hi");}7⏏5 my $v = &hi(); $v();␤    expecting any of:␤        infix␤        infix stopper…»

[17:24] <lucasb> "def"? So you *do* like Python :)

[17:24] <tony-o> need a ; after the block end for the one liners LitterallyTriggr 

[17:24] *** rurban_ left
[17:24] <LitterallyTriggr> p6: def hi(){say("hi");}; my $v = &hi; $v();

[17:24] <GLRelia> rakudo-moar 5873e1: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Undeclared routines:␤    &hi used at line 1␤    def used at line 1␤    hi used at line 1␤␤»

[17:24] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Undeclared routines:␤    &hi used at line 1␤    def used at line 1␤    hi used at line 1␤␤»

[17:24] <tony-o> m: sub hi { 'hi'.say; }; my $v = &hi; $v();

[17:24] <camelia> rakudo-moar 815fff: OUTPUT«hi␤»

[17:24] <GLRelia> rakudo-moar 5873e1: OUTPUT«hi␤»

[17:24] <LitterallyTriggr> That is what I do like about Perl6

[17:25] <LitterallyTriggr> Assigning functions to variables

[17:25] <PerlJam> .oO( which you can do in loads of other languages too)

[17:25] *** llfourn left
[17:25] <LitterallyTriggr> I can dynamically reassign a variable to a new function on the fly to make a more cryptic program that is harder to understand

[17:25] <LitterallyTriggr> PerlJam: Java?

[17:25] <LitterallyTriggr> ;)

[17:25] <LitterallyTriggr> (No reflectionP)

[17:25] *** xinming left
[17:25] <PerlJam> and you *like* Java?

[17:25] <raiph> LiterallyTriggr: if you get an error message, the ⏏ tries to point to the exact location

[17:26] <[Coke]> j: say "hi" # from rakudo running on the JVM.

[17:26] <GLRelia> rakudo-jvm 5873e1: OUTPUT«Can't open perl script "/home/steve/rakudo-inst/bin/eval-client.pl": No such file or directory␤»

[17:26] <camelia> rakudo-jvm 815fff: OUTPUT«hi␤»

[17:26] <[Coke]> GLRelia, maybe you could ignore things you can't run. :P

[17:26] <LitterallyTriggr> Java is a nice language.

[17:26] <tony-o> lol

[17:26] <LitterallyTriggr> Reflection is a bit confusing but I'm learning it.

[17:27] <LitterallyTriggr> p6: sub hi(){say("hi");}; my $v = &hi; $v(); sub bye(){say("bye");};  $v = &bye; $v();

[17:27] <GLRelia> rakudo-moar 5873e1: OUTPUT«hi␤bye␤»

[17:27] <camelia> rakudo-moar 815fff: OUTPUT«hi␤bye␤»

[17:27] <LitterallyTriggr> Perl6 can finally be used to write an emulator.

[17:27] <LitterallyTriggr> No more switch cases. Use a noun with an array instead.

[17:27] *** xinming joined
[17:28] <PerlJam> "finally"?  You're not even hitting a feature that's changed much since close to the first functional implementations.

[17:28] <LitterallyTriggr> Perl6 performance pickups are great enough to do it.

[17:28] <LitterallyTriggr> Perl5 wasn't fast enough.

[17:29] <LitterallyTriggr> It's simply a change from a custom interpreter to using the JVM / a propper VM

[17:29] <LitterallyTriggr> You could write one in BrainFuck but it would have massive timing issues

[17:30] <LitterallyTriggr> Does Perl6 have OpenGL bindings yet?

[17:30] <LitterallyTriggr> I know ACME is being ported over.

[17:31] <LitterallyTriggr> Found it: POGL

[17:31] <lucasb> Wouldn't it look better if "*@a" were non-flattening and "**@a" were flattening? That would give the impression that "**" is "one step further". What do you think?

[17:32] <ab6tract> lucasb: is it currently the other way around?

[17:32] <lucasb> ab6tract: just a second, let me double check :)

[17:33] *** xinming left
[17:33] <smls> lucas: I guess it's a matter of making the more common one shorter

[17:33] <LitterallyTriggr> I'm going to ask the stupid question of the year. Can Perl6 generate custom packets / packet payloads and send them over standard sockets?

[17:33] <LitterallyTriggr> IE things like generating SYN, ACK, ARP

[17:34] *** xinming joined
[17:34] <LitterallyTriggr> Specifically without external libraries

[17:34] <lucasb> ab6tract: yes, it is the other way around

[17:34] *** Ven joined
[17:35] <RabidGravy> LitterallyTriggr, no not at the present

[17:35] <LitterallyTriggr> RabidGravy: is there plans to support that?

[17:35] <LitterallyTriggr> It would open Perl6 up to SDN uses

[17:36] <RabidGravy> to be honest unlikey because it is something that would have to be provided by a VM and some of the targetted VMs will never support that

[17:36] <RabidGravy> making a library to do it wouldn't be too hard though

[17:36] <LitterallyTriggr> At that point you might aswell drop Perl6 then

[17:37] <RabidGravy> fair enough

[17:37] <raiph> m: say -> *@a {@a.perl}(1,[2,3,[4,5]]); say -> **@a {@a.perl}(1,[2,3,[4,5]]);

[17:37] <GLRelia> rakudo-moar 5873e1: OUTPUT«[1, 2, 3, $[4, 5]]␤[1, $[2, 3, $[4, 5]]]␤»

[17:37] <camelia> rakudo-moar 815fff: OUTPUT«[1, [2, 3, [4, 5]]]<>␤(1; 2, 3, [4, 5])␤»

[17:38] <LitterallyTriggr> I do admit I am liking how Perl6 is turning out

[17:38] * ab6tract notes the absence of []<> syntax in GLR and rejoices

[17:39] *** domidumont joined
[17:40] <ab6tract> m: my $b = EVAL (* xx 9) # damn, the evil can only go so far... but, a good example of how WhateverCode's are compiler transforms

[17:40] <GLRelia> rakudo-moar 5873e1: OUTPUT«5===SORRY!5=== Error while compiling EVAL_0␤Two terms in a row␤at EVAL_0:1␤------> 3Whatever<140087682768992>7⏏5 Whatever<140087682768992> Whatever<1400␤    expecting any of:␤        infix␤        infix stopper␤        statement end…»

[17:40] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling EVAL_0␤Two terms in a row␤at EVAL_0:1␤------> 3Whatever<140103699014488>7⏏5 Whatever<140103699014488> Whatever<1401␤    expecting any of:␤        infix␤        infix stopper␤        statement end…»

[17:41] <ab6tract> wait, forgot the question mark at the end of that statement

[17:41] <LitterallyTriggr> loil

[17:43] <FROGGS> huh

[17:43] <FROGGS> a Seq with zero elems is Trueish?

[17:44] <FROGGS> m: say so Seq.new

[17:44] <GLRelia> rakudo-moar 5873e1: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/VF0BWq1jRV:1␤␤»

[17:44] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5=== Error while compiling /tmp/OH_gQnZcqg␤Undeclared name:␤    Seq used at line 1. Did you mean 'Set'?␤␤»

[17:45] *** LitterallyTriggr left
[17:45] *** amurf joined
[17:45] <ab6tract> m: my $b = * * * * *; say $b( 3 xx 3 )

[17:45] <GLRelia> rakudo-moar 5873e1: OUTPUT«Too few positionals passed; expected 3 arguments but got 1␤  in block <unit> at /tmp/v8l0T3JBJJ:1␤␤»

[17:45] <camelia> rakudo-moar 815fff: OUTPUT«Too few positionals passed; expected 3 arguments but got 1␤  in block <unit> at /tmp/tpokhQbDpu:1␤␤»

[17:46] <ab6tract> so it still needs a | in GLR

[17:48] <FROGGS> nine / jnthn: Seq is missing a .Bool, right?

[17:50] *** amurf left
[17:52] <FROGGS> nine / jnthn: either that or grep shouldn't return a Seq...

[17:53] <FROGGS> m: say so (^42).List

[17:53] <GLRelia> rakudo-moar 5873e1: OUTPUT«1␤»

[17:53] <camelia> rakudo-moar 815fff: OUTPUT«True␤»

[17:53] <moritz> huh, &so should never return 1

[17:53] <moritz> FROGGS: would need to be self.list.Bool

[17:54] <FROGGS> moritz: I can fix the List.Bool easily...

[17:54] <FROGGS> moritz: the other comment was about Seq.Bool?

[17:55] <moritz> FROGGS: Seq.Bool would need to return self.list.Bool

[17:55] <FROGGS> mkay

[17:55] <FROGGS> testing this now

[17:55] <ab6tract> moritz: ooc, why .list and not .List ?

[17:56] <ab6tract> I'm not sure what the distinction between coercer and constructor are in this context

[17:56] <ab6tract> s/are/si

[17:56] * ab6tract wonders why he even bothers .. ;)

[17:57] <moritz> ab6tract: .list is cached

[17:57] <hoelzro> this ticket (https://rt.perl.org/Ticket/Display.html?id=63350) no longer applies for GLR, right?

[17:57] <ab6tract> ah. cached on the Seq object?

[17:57] <moritz> ab6tract: yes

[17:57] *** jack_rabbit_ joined
[17:57] <hoelzro> .say for (1, 2, 3).item should now print 3 lines?

[17:57] *** jack_rabbit_ left
[17:58] <smls> I the language of the design docs, .list is neither a coercer nor a composer, but a "contextualizer".

[17:58] *** muraiki left
[17:58] *** Ven left
[17:58] <ab6tract> smls: intriguing

[17:59] <smls> m: say [1, 2, 3].list.WHAT

[17:59] <GLRelia> rakudo-moar 5873e1: OUTPUT«(Array)␤»

[17:59] <camelia> rakudo-moar 815fff: OUTPUT«(Array)␤»

[17:59] <smls> probably because of that ^^

[18:00] <smls> m: my @a = 1, 2, 3; @a.list»++; say @a

[18:00] <GLRelia> rakudo-moar 5873e1: OUTPUT«2 3 4␤»

[18:00] <camelia> rakudo-moar 815fff: OUTPUT«2 3 4␤»

[18:00] <smls> i.e. it may return the object itself, if it is already sufficiently list'y

[18:02] <smls> "Note that, since these are coercions to roles, they are allowed to return any actual type that does the role in question." -- http://design.perl6.org/S03#line_2476

[18:02] <ab6tract> yowch! I had no idea the hotel options in Olten were so darn expensive :(

[18:05] <ab6tract> hopefully that won't affect my expensing of said hotel!

[18:09] <ab6tract> btw, where are the cool kids staying in Granada?

[18:11] *** ChoHag joined
[18:16] *** rangerprice joined
[18:19] <ab6tract> m: my $b = * + *; say $b; # I could have sworn that recently I was seeing the actual transformed block via .gist

[18:19] <GLRelia> rakudo-moar 5873e1: OUTPUT«WhateverCode.new␤»

[18:19] <camelia> rakudo-moar 815fff: OUTPUT«WhateverCode.new␤»

[18:19] <ChoHag> Does a subclass have direct access to its parent's attributes?

[18:19] <moritz> no

[18:19] <moritz> otherwise subclass would break encapsulation

[18:19] <moritz> *subclassing

[18:20] <ab6tract> is there a mechanism for getting the actual block?

[18:20] <moritz> m: say { $^a + $^b }.perl

[18:20] <GLRelia> rakudo-moar 5873e1: OUTPUT«-> $a, $b { #`(Block|60784936) ... }␤»

[18:20] <camelia> rakudo-moar 815fff: OUTPUT«-> $a, $b { #`(Block|58246464) ... }␤»

[18:20] <moritz> m: say { $^a + $^b }.gist

[18:20] <GLRelia> rakudo-moar 5873e1: OUTPUT«-> $a, $b { #`(Block|47227176) ... }␤»

[18:20] <camelia> rakudo-moar 815fff: OUTPUT«-> $a, $b { #`(Block|48548768) ... }␤»

[18:20] <moritz> ab6tract: I think that only works for regexes

[18:21] *** xinming left
[18:21] <ab6tract> moritz: okay, that must be what I was thinking of... so no means for getting the transformed block back from a whatevercode currently

[18:22] <ab6tract> (and you are totally right! I wasn't expecting the actual code in the block, but rather the signature plus the #`(Block|stuff) 

[18:23] *** xinming joined
[18:23] <ab6tract> thanks for helping moritz :)

[18:24] <ChoHag> Do you need a method to do so if the parent trusts the subclass, or does trust give access to the attributes?

[18:24] <rangerprice> Hi

[18:25] <rangerprice> How about low level and system programming in perl ?

[18:27] *** ab6tract left
[18:29] <masak> rangerprice: I don't see why not.

[18:30] <rangerprice> Hi masak, how are you ? :)

[18:32] *** brrt joined
[18:36] <laben> .tell nine is it intented for .elems to consume a Seq? if it is, the code in src/core/metaops.pm line 388-389 will need to change. i dont think it's right for hypers to consume Seq multiple times

[18:36] <yoleaux> laben: I'll pass your message to nine.

[18:41] *** nowan left
[18:43] <dalek> rakudo/glr: 6f9ce0b | FROGGS++ | src/core/List.pm:

[18:43] <dalek> rakudo/glr: make List.Bool return a boolean, not a number

[18:43] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/6f9ce0b0d1

[18:44] <dalek> rakudo/glr: d6049e4 | FROGGS++ | src/core/Seq.pm:

[18:44] <dalek> rakudo/glr: add Seq.Bool, so we can boolify the result of e.g. grep

[18:44] <dalek> rakudo/glr: 

[18:44] <dalek> rakudo/glr: moritz++

[18:44] <dalek> rakudo/glr: review: https://github.com/rakudo/rakudo/commit/d6049e443e

[18:46] *** nowan joined
[18:48] *** zakharyas joined
[18:58] *** cognominal joined
[19:00] <FROGGS> we are down to 155 failing test files now

[19:00] <brrt> \o/

[19:02] <[Coke]> jeez, I'm still trying to get one daily run collected. :)

[19:04] <raiph> ChoHag: afaict trust is only for providing access to private methods, not attributes; so you can set up a private accessor and share that only with trusted classes

[19:07] <nine> FROGGS++ # epic!

[19:07] <yoleaux> 18:36Z <laben> nine: is it intented for .elems to consume a Seq? if it is, the code in src/core/metaops.pm line 388-389 will need to change. i dont think it's right for hypers to consume Seq multiple times

[19:09] *** pullphinger15 joined
[19:11] *** brrt left
[19:13] *** pullphinger15 left
[19:17] <nine> laben: indeed. I think the whole sub could use a rework to make better use of the iterators

[19:18] <nine> Seq.Bool could be optimized as well, since we should only need to pull-one to know the result. No changes after that.

[19:18] *** dwarring joined
[19:18] *** pullphinger joined
[19:18] *** pullphinger left
[19:19] *** pullphinger joined
[19:19] *** pullphinger left
[19:19] <nine> Ok, back to my girlfriend on the terrace now ;)

[19:20] <FROGGS> m: my $foo = "FOO"; my $bar = "BAR"; my $gorch = "foo bar"; say «$foo $gorch $bar»

[19:20] <GLRelia> rakudo-moar d6049e: OUTPUT«FOOfoobarBAR␤»

[19:20] <camelia> rakudo-moar 815fff: OUTPUT«FOOfoo barBAR␤»

[19:20] <FROGGS> m: my $foo = "FOO"; my $bar = "BAR"; my $gorch = "foo bar"; say «$foo $gorch $bar».perl

[19:20] <GLRelia> rakudo-moar d6049e: OUTPUT«("FOO", ("foo", "bar"), "BAR")␤»

[19:20] <camelia> rakudo-moar 815fff: OUTPUT«("FOO", ("foo", "bar"), "BAR")␤»

[19:20] <FROGGS> m: my $foo = "FOO"; my $bar = "BAR"; my $gorch = "foo bar"; say «$foo $gorch $bar».elems

[19:20] <camelia> rakudo-moar 815fff: OUTPUT«3␤»

[19:20] <GLRelia> rakudo-moar d6049e: OUTPUT«3␤»

[19:21] <FROGGS> m: my $foo = "FOO"; my $bar = "BAR"; my $gorch = "foo bar"; say (@ = «$foo $gorch $bar»).elems

[19:21] <GLRelia> rakudo-moar d6049e: OUTPUT«3␤»

[19:21] <camelia> rakudo-moar 815fff: OUTPUT«4␤»

[19:21] <FROGGS> m: my $foo = "FOO"; my $bar = "BAR"; my $gorch = "foo bar"; say (@ = «$foo $gorch $bar»).perl

[19:21] <GLRelia> rakudo-moar d6049e: OUTPUT«["FOO", $("foo", "bar"), "BAR"]␤»

[19:21] <camelia> rakudo-moar 815fff: OUTPUT«["FOO", "foo", "bar", "BAR"]<>␤»

[19:24] *** domidumont left
[19:25] <laben> .tell nine both map and grep return Seq, but couldn't the generated Seq already know its number of elems? after all .map applies to every item while .grep knows wheter an item passes the test and then gets included or not

[19:25] <yoleaux> laben: I'll pass your message to nine.

[19:29] *** lucasb left
[19:33] <nine> laben: what makes you think that .map and .grep know how many elements they will process before they are done?

[19:33] <yoleaux> 19:25Z <laben> nine: both map and grep return Seq, but couldn't the generated Seq already know its number of elems? after all .map applies to every item while .grep knows wheter an item passes the test and then gets included or not

[19:35] <nine> laben: both do not return lists but Seq, i.e. an iterator. Only when some consumer (like HYPER) pulls values out of the iterator, the acutal mapping and grepping is performed

[19:35] <nine> And all of this can happen on lazy or infinite lists.

[19:37] *** zakharyas left
[19:37] <nine> FROGGS: both me an moritz++ have looked at the $gorch issue. Sadly none of us has a good answer to what the most useful behavior should be.

[19:38] <FROGGS> ahh

[19:38] <FROGGS> I am about making it act like on nom

[19:41] <laben> nine: then the HYPER needs to begin the operations and only while running check the elem numbers / send the exceptions

[19:42] *** ab6tract joined
[19:46] <nine> laben: exactly! That's what I'm thinking when talking about refactoring. Sadly, we will have to save the elements of both lists to an IterationBuffer unless we know one or both to be lazy. 

[19:48] *** ChoHag left
[19:49] *** muraiki joined
[19:50] <skids> I do think using .elems to reify should be discouraged somehow, as later on we could have things find out .elems from chained Seqs which are not lazy, before work is performed.

[19:53] <skids> But if that information is to be useful to optimizers, it might mean Seqs need to have introspection as to whether they are going to emit any Slips.

[19:54] <skids> anyway, random thoughts I'll shut up now.

[19:59] <dalek> perl6-roast-data: 8269141 | coke++ | / (10 files):

[19:59] <dalek> perl6-roast-data: today (automated commit)

[19:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/82691410f6

[20:00] <[Coke]> not sure why rakudo.jvm isn't running anywhere near as many tests as rakudo.moar

[20:00] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv

[20:00] * colomon is suspicious that if you’re sending a Seq to hyper, something is already messed up. 

[20:01] <[Coke]> rakudo.moar-glr has 2463 failing tests out of 116528.

[20:03] * ab6tract notes that http://design.perl6.org/S02.html#The_Whatever_Object says that 'currying' is not the right way to talk about Whatever, but that seems to be how it is generally discussed

[20:05] *** darutoko left
[20:06] *** pullphinger joined
[20:06] *** pullphinger left
[20:08] <raiph> ab6tract: Here's how I might put it. Whatever is a completely generic "whatever". Even if a bunch of folk talked about the tasty curries they eat as "whatevers" doesn't mean other folk have to think "whatever" means a curry.

[20:08] * ab6tract also notes with some despair that 'orwith' is smashcased

[20:09] *** bartolin joined
[20:09] <ab6tract> raiph: I like it :D

[20:09] <raiph> :)

[20:10] *** pullphinger joined
[20:10] *** pullphinger left
[20:10] *** pullphinger joined
[20:10] *** pullphinger left
[20:11] <raiph> ab6tract: orwith is not the same as "or with", right?

[20:12] <ab6tract> raiph: indeed. however, I would have hoped for 'or-with', I guess. But then, matching 'elsif' makes some sense there. 

[20:12] <jdv79> how does one pay for spw

[20:13] <jdv79> i didn't but it says i ddid

[20:13] *** zakharyas joined
[20:13] <ab6tract> I'm not sure that my fear of ending up with PHP-like degrees of inconsistency in the core setting is universally shared

[20:14] <[Coke]> I have concerns about consistency, ab6tract.

[20:14] <ab6tract> [Coke]: glad to hear it ain't just me :)

[20:15] <jdv79> they can be changed an deprecated later maybe

[20:15] <jdv79> bike shedding wastes a lot of time

[20:16] <ab6tract> jdv79: it would be nice to have that part wrapped before 6.0.0. bike shedding is not necessary if there is a simple rule to follow: kebab case, no abbreviations

[20:16] <ab6tract> otherwise, yes, it's all bike shedding

[20:17] <ab6tract> though no one wants to see min/max become minimum/maximum, I expect

[20:17] *** xfix left
[20:19] <bartolin> [Coke]: I think rakudo.moar runs a lot of NFG tests from S15-nfg which are not run on rakudo.jvm

[20:19] <[Coke]> bartolin: oh, right. Thanks.

[20:21] * [Coke] commutes

[20:22] <raiph> ab6tract: as I understand it the key is http://irclog.perlgeek.de/perl6/2015-03-25#i_10339632

[20:24] *** zakharyas left
[20:27] <raiph> ab6tract: because the point is to enable technically unconstrained evolution

[20:29] *** KCL joined
[20:29] <raiph> ab6tract: and not worry about getting it exactly right before you ship

[20:31] *** KCL_ left
[20:34] *** rindolf left
[20:34] <raiph> (otoh, I've not seen anyone else say that, which is a tad disconcerting ;))

[20:36] <skids> I for one am a bit sick of dealing with released-too-early products at $DAYJOB, so I find it hard to jump on that bandwagon.

[20:37] <raiph> s/exactly right before you ship/permanently linguistically "right"/

[20:37] <skids> Sure, there are degrees to that.

[20:39] <skids> I think the proposed doc/rationale should be done pre-release to get people on the same page and as a hedge against any unnoticed glaring PAEs.

[20:40] <skids> (and if we had that now I'd have less stupid questions for jnthn/TimToady)

[20:41] <raiph> skids: do you mean Larry's "identity, identity, identity" thing?

[20:41] <skids> No, there was a proposal for rearranging doc a bit and one of the new pages was "why some things are the way they are"

[20:44] <skids> The design docs do go into some things pretty well, but you have to fish around in them.

[20:45] <raiph> Ah. I was thinking of "why it matters a whole lot less than one might think that things are the way they are now", but I agree that's not helpful to those just trying to use what is available at any given time without interest in things improving

[20:47] <skids> Well, from a user's standpoint (the non-naive user) you try to get a feel for the stability of a feature before using it, and if something has a good reason to be that way, it helps improve confidence.

[20:48] * skids very glad GLR is now on track.

[20:48] <raiph> skids: well, consider whether orwith is spelled or-with or not; will that decision, or any other, get baked in to Perl 6 once 1.0 ships?

[20:50] <raiph> afaict the entire language is spectacularly malleable and that's perhaps its #1 long-term killer feature

[20:50] <skids> I think the current spelling is correct, personally, both because I actually don't like kebab case and because I do not think else-if would be at all popular.  But to the question, thos features that get use out of the gate are likely to get frozen that way.

[20:50] *** silug joined
[20:51] <ab6tract> inertia is inevitable, it's true

[20:53] <PerlJam> I don't think anything will ever be "frozen".  But there's a bit of pressure to get it right early-ish so that you don't have to carry so much backwards compatibility baggage with you into the future.

[20:55] <timotimo> i wonder why literallytriggr suggested to give perl6 something built-in for constructing packets like tcp

[20:55] <raiph> PerlJam: Agreed. Afaict the identity aspects of Perl 6 are designed to minimize the weight of decisions.

[20:56] <ab6tract> and we should also be aware of the fact that "early-ish" is already "15 years in", as the outside world will perceive it

[20:56] <timotimo> when other languages have sophisticated libraries to do that kind of thing

[20:57] <ab6tract> there is a *lot* of pressure to have 6.0.0 as-right-as-possible. if we launch with all manner of smash,snake,and kebab case, some abbreviations here and other full names there....

[20:57] <ab6tract> people will (rightfully, imo) have the opinion that the language is still half baked

[20:58] <ab6tract> (rightfully to perceive it, not rightfully considerable as half baked)

[20:58] <skids> (Also, FWIW, despite the fact that kebab case got the nod (I'll have to deal) it is good that there is a convention, however, I do not think applying a convention like that to a foreign API is ever a good idea.  For example, remapping all your C constants to kebab-case in a NativeCall mod would be silly.)

[20:58] <ab6tract> skids: indeed. but that's not core, right?

[20:58] <skids> Right, just a sidenote.

[21:00] <RabidGravy> the thing is can you write software with it

[21:00] <RabidGravy> well

[21:02] <ab6tract> RabidGravy: is that the thing? because I don't need Perl 6 to write software. and no one else will buy that as a justification for using a language that after 15 years of development can manage to feel inconsistent

[21:03] <ab6tract> and that's the ultimate rub! the language is unbelievably consistent

[21:03] <ab6tract> it would only be a surface level, completely superficial naming convention level of inconsistency

[21:03] <skids> Consistency does not have to be monolithic, just segmented and logically arranged.

[21:05] <ab6tract> sure, but where is the rhyme or reason for why .uniq became .unique, but .substr isn't .substring ? 

[21:06] <skids> "Stuff we stole from C you already knew how to spell"

[21:06] <RabidGravy> You've lost me. You're going into microscopic detail there. If you don't wamt people to make software using the language then fine.  I'd go with stabilise.

[21:06] <ab6tract> orwith/elsif has a stronger argument, to be sure

[21:07] <ab6tract> RabidGravy: my point is that Perl in general, and Perl 6 in particular, face an up hill battle in convincing programmers that they offer something significantly better

[21:07] <skids> At least then, people can know that, hey, I'm picking up a bit of C when I learn this, too.

[21:07] <skids> anyway, decommute.

[21:07] *** skids left
[21:07] <ab6tract> it's like making sure you comb your hair and wear shoes to a job interview

[21:08] <RabidGravy> er

[21:08] <ab6tract> or don't, but you can't be shocked when they laugh you out of the room

[21:09] <ab6tract> considering you had a decade and a half to get dressed

[21:09] <RabidGravy> I've been doing that for thirty years

[21:09] *** yqt joined
[21:10] <ab6tract> I'm really not sure what we are discussing any more. Perl 6 has a chance to make a first impression. Why would we let surface level cosmetic issues get any traction in discussion, if we can avoid it?

[21:13] *** diana_olhovik_ joined
[21:14] <RabidGravy> that's lost me too

[21:14] *** pmurias joined
[21:15] <pmurias> We should have consistently named core methods/subs.

[21:15] <pmurias> Having inconsistent names has no real benefit.

[21:16] *** mr-foobar left
[21:18] <RabidGravy> I'm going to say this only once, but Perl 6 has taken 15 years because no-one took it and ran with it in the first couple of years leaving open a space fore every next generation of CS graduate and bikeshedder to have their say.  This is being fixed this year.

[21:18] <rangerprice> RabidGravy: yes

[21:21] <ab6tract> RabidGravy: well, inconsistent naming conventions sure will deliver the confidence that it is not a hodge podge of bike shedding... 

[21:21] <ab6tract> (sarcasm)

[21:22] <RabidGravy> fix it then :)

[21:23] *** amurf joined
[21:25] <ab6tract> RabidGravy: I've had my fill of sweeping PRs that go nowhere, thanks

[21:25] <rangerprice> Is LWP module only available for Perl ?

[21:27] *** amurf left
[21:27] <RabidGravy> well we're working up HTTP::UserAgent to fill its boots but you know, contributions help

[21:27] <ab6tract> I would gladly put in the work if it were commissioned in advance, but it's too much trouble to approach it without any certainty that it would get merged

[21:27] <ab6tract> anyway, I'm out for now

[21:27] <ab6tract> good *, all

[21:27] *** ab6tract left
[21:28] <RabidGravy> grumpy

[21:30] <RabidGravy> what's the telll bot?

[21:32] <raiph> .tell RabidGravy ...

[21:32] <yoleaux> raiph: I'll pass your message to RabidGravy.

[21:34] <RabidGravy> .tell ab6tract the touchstone of any language is whether you can write great software in it not whether the language is perfect. It's going to be great

[21:34] <yoleaux> 21:32Z <raiph> RabidGravy: ...

[21:34] <yoleaux> RabidGravy: I'll pass your message to ab6tract.

[21:34] <RabidGravy> raiph, cheers :)

[21:36] *** muraiki left
[21:37] <RabidGravy> see also PHP

[21:38] *** diana_olhovik_ left
[21:40] <pmurias> RabidGravy: you can write great software in really crappy languages

[21:41] <pmurias> RabidGravy: you may have to suffer a lot to do it though

[21:42] <RabidGravy> yes see PHP

[21:44] <RabidGravy> but Perl 6 is a good language now, there's no point worrying to much in detail unless people fail to write good software with it :)

[21:45] *** simcop2387 left
[21:45] <raiph> .tell ab6tract I share your passion to get things right. If I upset you, that was the opposite of my intent and I apologize.

[21:45] <yoleaux> raiph: I'll pass your message to ab6tract.

[21:45] *** simcop2387 joined
[21:46] <laben> .tell nine good that there is a plan forward for that, i guessed it would be something like that :)

[21:46] <yoleaux> laben: I'll pass your message to nine.

[21:47] <laben> good night|work #perl6

[21:47] *** laben left
[21:47] <rangerprice> i hope that Perl 6 don't lose the simplicity of Perl 5

[21:48] <RabidGravy> It has all the simplicity and more consistency

[21:55] *** cwDYKARN left
[21:55] *** cwDYKARN_ left
[21:57] <RabidGravy> sorry if I came over a bit humphy there but I think the aim is to make a language that you want to use, not necessarily one your CS professor would wet herself over

[22:00] <pmurias> Perl 5 doesn't have that much simplicity

[22:00] <pmurias> it has ease of use, but the language itself is pretty complex (with all the weird special cases)

[22:01] *** lucasb joined
[22:02] <RabidGravy> then it's broken and no one should use it ;-P

[22:02] <dalek> nqp/js: f33f56a | (Pawel Murias)++ | src/vm/js/ (2 files):

[22:02] <dalek> nqp/js: Pass test 34.

[22:02] <dalek> nqp/js: 

[22:02] <dalek> nqp/js: Implement rxtype qastnode.

[22:02] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/f33f56a8be

[22:02] <dalek> nqp/js: 2a7d1d8 | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[22:02] <dalek> nqp/js: Add passing test 62 to run_tests.

[22:02] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/2a7d1d8dcf

[22:03] *** nowan left
[22:03] <RabidGravy> ;-P

[22:03] <pmurias> RabidGravy: isn't that a pretty common opinion?

[22:04] <pmurias> not in Perl 6 land

[22:05] <dwarring> m: say $_ for ^3

[22:05] <GLRelia> rakudo-moar d6049e: OUTPUT«0␤1␤2␤»

[22:05] <camelia> rakudo-moar 815fff: OUTPUT«0␤1␤2␤»

[22:05] <dwarring> m: say $_ for ^3.0

[22:05] <GLRelia> rakudo-moar d6049e: OUTPUT«1␤2␤»

[22:05] <camelia> rakudo-moar 815fff: OUTPUT«0␤1␤2␤»

[22:05] * dwarring noticed that in advent2009-day17.t

[22:06] *** nowan joined
[22:06] <timotimo> oh, whoops

[22:06] <timotimo> that's interesting to say the least

[22:06] <timotimo> probably a very simple thing to fix

[22:07] <timotimo> want me to look at it, or want to do it yourself? :)

[22:07] <timotimo> probably using .succ too early?

[22:07] <timotimo> m: say $_ for "a".."f"

[22:07] <GLRelia> rakudo-moar d6049e: OUTPUT«a␤b␤c␤d␤e␤f␤»

[22:07] <camelia> rakudo-moar 815fff: OUTPUT«a␤b␤c␤d␤e␤f␤»

[22:07] <timotimo> here it works though

[22:07] <dwarring> timotimo: have a look

[22:07] <dwarring> just seems to be Rats

[22:08] <timotimo> m: say $_ for ^3.0e1

[22:08] <GLRelia> rakudo-moar d6049e: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤»

[22:08] <camelia> rakudo-moar 815fff: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤»

[22:08] <timotimo> Nums as well

[22:08] <lucasb> m: say @ = 1.0^..3

[22:08] <GLRelia> rakudo-moar d6049e: OUTPUT«3␤»

[22:08] <camelia> rakudo-moar 815fff: OUTPUT«2 3␤»

[22:09] <dwarring> erm and  Nums

[22:09] <lucasb> dwarring++  # funny bug

[22:09] <rangerprice> Where can i find good reference to a book that explain how to create a programming language ? 

[22:11] *** mjgardner left
[22:12] <pmurias> rangerprice: design a programming language or create an interpreter/compiler for one?

[22:12] *** mjgardner joined
[22:12] <rangerprice> pmurias: design a programming language

[22:16] *** kaare_ left
[22:18] <pmurias> I'm not aware of any such book

[22:19] <hoelzro> if I have a sub foo, and I do my @a = 1, 2, foo(); does the return value from foo() flatten out into @a post-GLR?

[22:19] <timotimo> grrrr

[22:20] *** mr-foobar joined
[22:20] <timotimo> i make changes to the optimizer and it causes rakudo to build a core setting that asplodes immediately after starting up

[22:22] *** TEttinger joined
[22:25] <lizmat> good *, #perl6

[22:25] <lizmat> down to 154 failing test files, woot!

[22:25] <lizmat> (for the glr of course)

[22:25] * [Coke] has travel booked most of the way to SPW now. whee.

[22:27] * colomon right still has to get train tickets.  :)

[22:28] <colomon> s/right//

[22:30] <pmurias> lizmat: re replacing use with yes/no for pragmas isn't the idea that pragmas are just modules with lower case names?

[22:31] <lizmat> that's P5, why does P6 have to be that way ?  :-)

[22:32] *** smls_ joined
[22:32] *** smls left
[22:32] <pmurias> lizmat: what do we gain from it not being that way?

[22:33] <lizmat> less IO during compilation

[22:34] *** mjgardner left
[22:35] <lizmat> the other thing is, that pragma's, I think, are typically versionless (or at least, hooked to a version of the system)

[22:37] *** gagalicious joined
[22:37] <pmurias> you mean the version of the pragma is determined by the the version of the language we use?

[22:38] <lizmat> I would say so, yes

[22:38] <lizmat> for the pragmas provided for by the system

[22:40] <dalek> rakudo/nom: 28faf19 | lizmat++ | src/core/IO/Path.pm:

[22:40] <dalek> rakudo/nom: Allow 0 as a valid file name in .IO

[22:40] <dalek> rakudo/nom: 

[22:40] <dalek> rakudo/nom: Re-imagined PR #508 by ugexe++

[22:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/28faf19180

[22:40] <pmurias> lizmat: for me the module/pragma distinction seem really arbitrary

[22:42] <lizmat> perhaps it is...   we will figure it out  :-)

[22:43] <ugexe> for me it would be useful because i may want to turn off all pragmas without knowing what they are, ala `no pragmas` or something

[22:45] <pmurias> ugexe: what would be the use of something like that?

[22:46] *** skids joined
[22:47] <labster> lizmat++ I was thinking of doing that last commit, but you beat me to it.

[22:48] <ugexe> off the top of my head? i dunno, but it would be the same as anywhere you would use `no warnings` `no strict` in p5 except you dont have to remember them all

[22:50] <RabidGravy> no

[22:51] <RabidGravy> those things are only present in 5 because people don't fix their code

[22:51] <RabidGravy> we don't have that burden

[22:52] <ugexe> ive had plenty of valid reasons in perl5 to turn off warnings or strict or fatal. especially if you are testing things

[22:54] <RabidGravy> oh I have, but let's say you can't to that in 6

[22:54] *** leont joined
[22:56] <timotimo> we have "no strict"

[22:56] <timotimo> ... or maybe i don't understand what you mean?

[22:57] <ugexe> right. we have no strict, no fatal etc already. i was just suggesting a `no pragmas` to turn them all off

[22:57] <timotimo> "no fatal" is the default outside of "try", isn't it?

[22:58] <RabidGravy> but it's still compeled to crap out on type not found or my Int $a = "foo"

[22:58] <RabidGravy> pointless

[22:59] <timotimo> "crap out on type not found"?

[23:00] <RabidGravy> m: my Foo $a;

[23:00] <camelia> rakudo-moar 815fff: OUTPUT«5===SORRY!5===␤Type 'Foo' is not declared␤at /tmp/0WI4IaKrb2:1␤------> 3my Foo7⏏5 $a;␤Malformed my␤at /tmp/0WI4IaKrb2:1␤------> 3my7⏏5 Foo $a;␤␤»

[23:00] <GLRelia> rakudo-moar d6049e: OUTPUT«5===SORRY!5===␤Type 'Foo' is not declared␤at /tmp/nVlHbSQBn7:1␤------> 3my Foo7⏏5 $a;␤Malformed my␤at /tmp/nVlHbSQBn7:1␤------> 3my7⏏5 Foo $a;␤␤»

[23:00] <timotimo> yeah, but that's not "crapping out"

[23:00] <timotimo> that's a compile-time error

[23:00] <RabidGravy> pedant

[23:01] <timotimo> are you playing devil's advocate right now or something?

[23:02] * timotimo is confused

[23:02] <RabidGravy> possibly

[23:02] *** yqt left
[23:03] <ugexe> m: BEGIN no fatal;

[23:03] <GLRelia> rakudo-moar d6049e: OUTPUT«===SORRY!===␤Cannot find method 'ann'␤»

[23:03] <camelia> rakudo-moar 815fff: OUTPUT«===SORRY!===␤Cannot find method 'ann'␤»

[23:03] <RabidGravy> "strictness" is within the coontrol of the programmer

[23:04] <RabidGravy> what?

[23:05] <timotimo> that's very redundant, as pragmas are *already* compile-time ... but the error is definitely LTA

[23:07] <lucasb> m: BEGIN { no fatal }

[23:07] <GLRelia> rakudo-moar d6049e: ( no output )

[23:07] <camelia> rakudo-moar 815fff: ( no output )

[23:08] <ugexe> if you want to control order better you can do tricks like that though

[23:08] <ugexe> im not sure if that ordering works with pragmas though. i do it for modules at least

[23:09] *** rurban left
[23:11] <pmurias> ugexe: turning of a one specific pragma makes sense

[23:11] <pmurias> ugexe: turning them all off with "no pragmas" makes zero sense to me

[23:11] <pmurias> ugexe: if you don't remember what you are turning off you shouldn't do it

[23:12] <pmurias> should we have a "use pragmas" that would turn all the pragmas on?

[23:15] *** RabidGravy left
[23:17] <timotimo> let's have a "use modules" that imports all modules the user has installed

[23:17] <arnsholt> Heh. What could possibly go wrong!? =D

[23:20] <dalek> nqp/js: fb0e205 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[23:20] <dalek> nqp/js: Add a Chunk.void helper method for more concise definition of chunks that don't return a value.

[23:20] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/fb0e205f00

[23:20] <dalek> nqp/js: e365704 | (Pawel Murias)++ | src/vm/js/QAST/Compiler.nqp:

[23:20] <dalek> nqp/js: Avoid using ~ to concatenate Chunks

[23:20] <dalek> nqp/js: review: https://github.com/perl6/nqp/commit/e36570472d

[23:21] <timotimo> arnsholt: something different and exciting for every day of the week!

[23:21] <timotimo> also "panda install Whatever" to install a random module

[23:22] <ugexe> perl6 -M"no pragmas" some-script.pl6

[23:23] <ugexe> that doesn't do anything, just demonstrates a use case

[23:24] <timotimo> heh, a use case.

[23:25] *** mjgardner joined
[23:25] <ugexe> heh yea i clearly do not know what that means. i mean to say it is an example that makes sense to me

[23:26] <timotimo> hm

[23:26] <timotimo> do we have (or will we have) a use statement with multiple things to be used on the RHS?

[23:28] *** lucasb left
[23:29] <timotimo> having just seen a python script with an "import foo, bar, baz, quux, ..., ..., ..., ..., ..., ..., ..., ..., ..." line in it ...

[23:31] <ugexe> use lib <a b c>; 

[23:31] <ugexe> cheating

[23:31] <timotimo> that's not the right thing

[23:31] <TimToady> well, where do you put the import list then?

[23:31] <timotimo> TimToady: embrace the TTIAR fully :P

[23:32] <timotimo> otherwise, a list of pairs could do

[23:33] <TimToady> it seems to have more of a use case for classes than for modules, so it's easier to have 'need' take a list, since classes don't usually import

[23:36] <japhb> TimToady: What day(s) are you and jnthn (and any other #perl6'ers) doing your talks?

[23:37] <TimToady> I did my talk yesterday

[23:37] <TimToady> jnthn is today

[23:38] <TimToady> yesterday there was a talk by someone who tried rakudo/jvm, and was pleasantly surprised at all it could do, except for start up fast :)

[23:38] <timotimo> oh, neato

[23:38] <lizmat> 14:20 local time, 5:20 GMT if I'm not mistaken

[23:38] <lizmat> I haven't seen any streams yet :-)

[23:39] * japhb can't wait for slide decks and recordings

[23:40] <japhb> Anyone happen to know what Matz is going to talk about?  I saw him on the talks list and did a double take.

[23:40] <TimToady> already talked about yesterday

[23:40] <timotimo> japhb: "error while compiling. undeclared routine: wait"

[23:40] <TimToady> something called 'streem' I gather

[23:41] <japhb> Oh yeah, saw that on his github page with a bazillion stars

[23:47] *** telex left
[23:48] *** telex joined
[23:49] *** leont left
[23:59] *** davercc joined
