[00:00] <psch> m: my @a = <you got mail man mailman manners>; say "yougotmailmanners" ~~ m:ov/@a/ # :g doesn't matter, fwiw

[00:00] <camelia> rakudo-moar : OUTPUT«(｢you｣ ｢got｣ ｢mailman｣ ｢manners｣)␤»

[00:03] <psch> m: my @a = <you got mail man mailman manners>; say "yougotmailmanners" ~~ m:!r:ex/@a/ 

[00:03] <camelia> rakudo-moar : OUTPUT«(｢you｣ ｢got｣ ｢mailman｣ ｢manners｣)␤»

[00:04] <psch> well, that's the blog post, isn't it?  albeit without the debug...

[00:06] <psch> oh, no, it isn't cause mailman is the longer token :/

[00:09] *** geraud joined
[00:20] *** polettix left
[00:20] *** newbie1 joined
[00:23] *** yqt left
[00:25] *** Sqirrel joined
[00:30] *** pdcawley left
[00:32] *** tokuhiro_ joined
[00:34] *** raiph left
[00:34] *** raiph joined
[00:35] *** raiph left
[00:36] *** tokuhiro_ left
[00:36] *** raiph joined
[00:40] *** sprocket joined
[00:41] *** Sqirrel left
[00:49] *** snarkyboojum left
[00:52] *** dayangkun_ joined
[00:53] *** dayangkun left
[01:06] <Zoffix> heh. replicating something ingy and mauke cooked together? :) I fear my mind would melt if I tried :P

[01:10] *** geraud left
[01:11] *** yeahnoob joined
[01:19] *** geraud joined
[01:20] *** newbie1 left
[01:21] *** yeahnoob left
[01:21] *** yqt joined
[01:24] <zengargoyle> i'd probably try to use Algorithm::Trie::libdatrie :)  load up /usr/share/dict/words and go through the string char by chare walking down the Trie until hitting a terminal node, then push the words + remaining chars onto a stack and recurse/repeat

[01:27] <zengargoyle> sounds suspiciously like a /r/dailyprogrammer challenge.

[01:28] *** Zoffix left
[01:33] *** yeahnoob joined
[01:34] *** sprocket left
[01:37] <psch> m: my @a = <a b bc c cd>; say "abcd" ~~ m/^[ $(@a[0]) | $(@a[1]) | $(@a[2]) | $(@a[3]) | $(@a[4])]*?$/; say "abcd" ~~ m/^[@a]*?$/ # should be equivalent according to S05..?

[01:37] <camelia> rakudo-moar : OUTPUT«｢abcd｣␤False␤»

[01:38] <psch> http://design.perl6.org/S05.html#Variable_(non-)interpolation plus a bit: "An interpolated array..."

[01:39] <gfldex> my proposal for an advent entry. Pointers at mistakes are welcome. https://gist.github.com/gfldex/f4e724a76baa1b85ab03

[01:40] *** sprocket joined
[01:40] *** sprocket left
[01:40] *** geraud left
[01:41] <psch> gfldex: line 139 reads a bit weird, i'd replace the first "what" with "which"

[01:42] <psch> gfldex: also "is sayed" should probably be "it says" 

[01:45] <gfldex> updated with 2 fixes

[01:45] <gfldex> who is compiling the calendar this year?

[01:46] <psch> i'd assume it works the same as last year.  people put themselves on the list when they want to publish, get author privs for the wordpress (from moritz or PerlJam iirc), type their article there and schedule the publishing for their day

[01:47] <psch> s/when they want to publish/for the day they want to publish on/

[01:47] <psch> https://github.com/perl6/mu/blob/master/misc/perl6advent-2015/schedule is the schedule

[01:47] *** metasin left
[01:48] *** nowan left
[01:48] <gfldex> i will poke moritz++ tomorrow

[01:49] *** nowan joined
[01:50] *** Zoffix joined
[01:50] <AlexDaniel> m: BEGIN ENTER {}

[01:50] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/MJEFdIOBNM␤An exception occurred while evaluating a BEGIN␤at /tmp/MJEFdIOBNM:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot reference undeclared local 'enter_result__1'␤  at :␤»

[01:50] <Zoffix> How exactly do you use hyper? I kinda expected this to return in one second:

[01:50] <Zoffix> m :say now; sleep 1 for ^3 .hyper; say now;

[01:51] <Zoffix> :m say now; sleep 1 for ^3 .hyper; say now;

[01:51] <Zoffix> m: say now; sleep 1 for ^3 .hyper; say now;

[01:51] <camelia> rakudo-moar : OUTPUT«Instant:1448243506.123744␤Instant:1448243509.133396␤»

[01:54] <AlexDaniel> m: BEGIN CHECK INIT END LEAVE do sink try quietly say 'hello';

[01:54] <camelia> rakudo-moar : OUTPUT«hello␤»

[01:58] <AlexDaniel> m: say quietly 'hello';

[01:58] <camelia> rakudo-moar : OUTPUT«hello␤»

[02:05] <Zoffix> m: my $hype = (1..3).race; say now; sleep 1 for $hype; say now;

[02:05] <camelia> rakudo-moar : OUTPUT«Instant:1448244376.374433␤Instant:1448244379.383784␤»

[02:06] *** geraud joined
[02:06] <Zoffix> m: my $hype = (1..3).race( degree => 4 ); say now; sleep 1 for $hype; say now;

[02:06] <camelia> rakudo-moar : OUTPUT«Instant:1448244414.796154␤Instant:1448244417.805252␤»

[02:06] <Zoffix> -_-

[02:08] <jdv79> m: say now;(^3).hyper(:batch(1)).map({sleep 1;say $_});say now;

[02:08] <camelia> rakudo-moar : OUTPUT«Instant:1448244542.394773␤0␤2␤1␤Instant:1448244543.404745␤»

[02:09] <jdv79> checkout batch and degree params

[02:09] <Zoffix> Aha. 

[02:09] <Zoffix> jdv79++ thanks

[02:14] *** AlexDaniel left
[02:21] *** metasin joined
[02:22] *** telex left
[02:23] *** metasin is now known as opalfrog

[02:24] *** telex joined
[02:28] *** zacts left
[02:30] *** xpen joined
[02:30] <dalek> doc: ae72b70 | (Zoffix Znet)++ | doc/Type/Promise.pod:

[02:30] <dalek> doc: Extend example for clarity

[02:30] <dalek> doc: review: https://github.com/perl6/doc/commit/ae72b70dda

[02:33] *** tokuhiro_ joined
[02:33] *** kaare_ joined
[02:35] *** xpen left
[02:35] <Zoffix> my $p = start { sleep 2; say 42; $p.keep(42) }; say $p.result;

[02:35] <Zoffix> m: my $p = start { sleep 2; say 42; $p.keep(42) }; say $p.result;

[02:35] <camelia> rakudo-moar : OUTPUT«42␤Access denied to keep/break this Promise; already vowed␤  in block <unit> at /tmp/wScvnWvIYw:1␤␤»

[02:35] <Zoffix> No way to return the result in this case?

[02:36] *** xpen_ joined
[02:36] <Zoffix> m: my $p = start { sleep 2; 42 }; say $p.result;

[02:36] <camelia> rakudo-moar : OUTPUT«42␤»

[02:36] <Zoffix> I see. Threw me off when I tried to `return` but was denied

[02:38] *** tokuhiro_ left
[02:43] <ingy> Zoffix: did someone figure out the word-parse.p6?

[02:43] <Zoffix> ingy, dunno. I've seen just one comment: "i'd probably try to use Algorithm::Trie::libdatrie :)  load up /usr/share/dict/words and go through the string char by chare walking down the Trie until hitting a terminal node, then push the words + remaining chars onto a stack and recurse/repeat"

[02:45] <psch> well, it should just work with array interpolation and backtracking non-greedy kleene star, i think

[02:45] <psch> but that doesn't fit what the code does

[02:45] <psch> m: my @a = <a b bc c cd>; say "abcd" ~~ m/^[ $(@a[0]) | $(@a[1]) | $(@a[2]) | $(@a[3]) | $(@a[4])]*?$/; say "abcd" ~~ m/^[@a]*?$/ # should be equivalent according to S05..?

[02:45] <camelia> rakudo-moar : OUTPUT«｢abcd｣␤False␤»

[02:45] *** ilbot3 left
[02:45] <Zoffix> The docs for await aren't clear: http://doc.perl6.org/type/Promise#sub_await

[02:45] <Zoffix> "Waits until one or more promises are all fulfilled"... well, does it mean if I give it 3 promises that it'll wait for ALL of them?

[02:45] <psch> (that's minus the debug message for every tried word)

[02:46] *** molaf_ joined
[02:46] <Zoffix> or until one of them completes

[02:47] <psch> as in, $concated-word ~~ /^[@words]*?$/ should already match correctly, but doesn't because of (what i percieve as) a bug in array interpolation

[02:47] <psch> not sure if it really is a bug or i'm misunderstanding S05 somewhere, though

[02:48] *** ilbot3 joined
[02:49] *** molaf left
[02:50] <Zoffix> Oh, ok. /me missed the "are all full.."

[02:51] <Zoffix> Why is it still dying tho? I'm trying to move on:

[02:51] <Zoffix> m: my $r = await start { sleep 3; die "42" }; say $r.result; say $r.cause; say now;

[02:51] <camelia> rakudo-moar : OUTPUT«42␤  in block <unit> at /tmp/I7pjeZLDVr:1␤␤»

[02:53] *** kid51 left
[02:56] <Zoffix> m: my $r = await Promise.allof(start { sleep 3; say 42 }, start { sleep 2; die 43 }); 

[02:56] <camelia> rakudo-moar : OUTPUT«43␤  in block <unit> at /tmp/_ElEZ2Zqdn:1␤␤»

[02:57] *** yqt left
[02:59] <Zoffix> m: try { my $r = await Promise.allof(start { sleep 3; say 42 }, start { sleep 2; die 43 }); CATCH { say "wut" }}

[02:59] <camelia> rakudo-moar : OUTPUT«wut␤43␤  in block <unit> at /tmp/08aMJ3i5LK:1␤␤»

[02:59] <Zoffix> I don't get why it's still dying

[03:00] <diakopter> catch needs to be inside the thing that dies

[03:00] <Zoffix> :S

[03:00] <psch> nah, doesn't

[03:00] <Zoffix> So how do I handle broken promises without my program crashing and burning?

[03:00] <diakopter> try it :p

[03:00] <psch> CATCH needs at least a default to not sink the Exception

[03:01] <Zoffix> m: try { my $r = await Promise.allof(start { sleep 3; say 42 }, start { sleep 2; die 43 }); CATCH {default{ say "wut" }}}

[03:01] <psch> m: try { my $r = await Promise.allof(start { sleep 3; say 42 }, start { sleep 2; die 43 }); CATCH { default { say "wut" } }}

[03:01] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/wGEeK2uQn0␤Whitespace required after keyword 'default'␤at /tmp/wGEeK2uQn0:1␤------> 3art { sleep 2; die 43 }); CATCH {default7⏏5{ say "wut" }}}␤»

[03:01] <camelia> rakudo-moar : OUTPUT«wut␤»

[03:01] <Zoffix> This is messy

[03:01] <psch> m: my $r = await Promise.allof(start { sleep 3; say 42 }, start { sleep 2; die 43 }); CATCH { default { say "wut" } }

[03:01] <camelia> rakudo-moar : OUTPUT«wut␤»

[03:01] <Zoffix> Oh

[03:01] <psch> i missed the try at first, that should silence it equivalent to the CATCH { default {} }

[03:02] <psch> m: my $r = try await start { die "foo" };

[03:02] <camelia> rakudo-moar : ( no output )

[03:02] <psch> like that i suppose

[03:02] <Zoffix> m: my $r = try await start { die "foo" }; say $r.WHAT

[03:02] <camelia> rakudo-moar : OUTPUT«(Any)␤»

[03:02] <Zoffix> m: my $r = try await start { "foo" }; say $r.WHAT

[03:02] <camelia> rakudo-moar : OUTPUT«(Str)␤»

[03:02] <Zoffix> psch++ thanks

[03:04] *** allen joined
[03:04] *** allen is now known as coetry

[03:04] <coetry> How do we increment strings in Perl6?

[03:04] <psch> .succ

[03:04] <coetry> like a range of unicode characters?

[03:04] <psch> m: say "foo".succ.succ

[03:04] <camelia> rakudo-moar : OUTPUT«foq␤»

[03:05] <coetry> "\x0980" .. "\x09FF"

[03:05] <psch> i don't think that goes over unicode characters though

[03:05] <coetry> why not?

[03:05] <Zoffix> m: say "Δ".succ

[03:05] <camelia> rakudo-moar : OUTPUT«Ε␤»

[03:05] <Zoffix> m: say "Δ".succ.succ

[03:05] <camelia> rakudo-moar : OUTPUT«Ζ␤»

[03:05] <Zoffix> m: say "Δ".succ.succ.succ

[03:05] <camelia> rakudo-moar : OUTPUT«Η␤»

[03:06] <coetry> how do you specific how many times you want to call that method

[03:06] <coetry> can you change the syntax like .succ for "\x0980" .. "\x09FF"

[03:06] <Zoffix> The docs say "String increment is Unicode-aware, and generally works for scripts where a character can be uniquely classified as belonging to one range of characters."

[03:07] <psch> m: say  "\x0980" ... "\x09FF" # range works, in any case

[03:07] <camelia> rakudo-moar : OUTPUT«(ঀ ঁ ং ঃ ঄ অ আ ই ঈ উ ঊ ঋ ঌ ঍ ঎ এ ঐ ঑ ঒ ও ঔ ক খ গ ঘ ঙ চ ছ জ ঝ ঞ ট ঠ ড ঢ ণ ত থ দ ধ ন ঩ প ফ ব ভ ম য র ঱ ল ঳ ঴ ঵ শ ষ স হ ঺ ঻ ় ঽ া ি ী…»

[03:07] <psch> well, Sequence

[03:07] <psch> not Range

[03:07] <psch> 'cause 3 dots, not 2 

[03:07] <coetry> ahhh, that's cool 

[03:07] <psch> m: say  "\x0980" .. "\x09FF" # ..?

[03:07] <camelia> rakudo-moar : OUTPUT«"ঀ".."৿"␤»

[03:07] <psch> m: say eager "\x0980" .. "\x09FF" # ..?

[03:07] <camelia> rakudo-moar : OUTPUT«(ঀ ঁ ং ঃ ঄ অ আ ই ঈ উ ঊ ঋ ঌ ঍ ঎ এ ঐ ঑ ঒ ও ঔ ক খ গ ঘ ঙ চ ছ জ ঝ ঞ ট ঠ ড ঢ ণ ত থ দ ধ ন ঩ প ফ ব ভ ম য র ঱ ল ঳ ঴ ঵ শ ষ স হ ঺ ঻ ় ঽ া ি ী…»

[03:07] <psch> eh, or that

[03:07] <psch> vOv

[03:07] <Zoffix> m: say "খ".succ

[03:07] <camelia> rakudo-moar : OUTPUT«খ␤»

[03:08] <coetry> Zoffix, can you send me a link to that part of the documentation?

[03:08] <Zoffix> coetry, the very last sentence on the page: http://doc.perl6.org/routine/succ

[03:08] <coetry> thanks

[03:09] <coetry> i feel that this can use a macro

[03:09] <coetry> .succ chained seems so tedius

[03:09] <Zoffix> just do a for?

[03:09] <Zoffix> m: my $x = "a"; $x.succ for ^4; say $x

[03:09] <camelia> rakudo-moar : OUTPUT«a␤»

[03:09] <Zoffix> hm

[03:10] <Zoffix> There are probably syntax trickery to make it nicer :P

[03:10] <coetry> yeah

[03:10] <psch> m: my $x = "a"; $x.=succ for ^4; say $x

[03:10] <camelia> rakudo-moar : OUTPUT«e␤»

[03:10] <gfldex> m: my $a = 'A'; $a.=succ for [^6]; say $a;

[03:10] *** raiph left
[03:10] <camelia> rakudo-moar : OUTPUT«G␤»

[03:12] <Zoffix> wtf? Why is there no output:

[03:12] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 };\ my ( $r1, $r2 ) = await $p1, $p2; CATCH { default { } }; say [ $r1, $r2, 'huh' ];

[03:12] <camelia> rakudo-moar : ( no output )

[03:13] <psch> m: die "foo"; CATCH { default { say "died" } }; say "alive"

[03:13] <camelia> rakudo-moar : OUTPUT«died␤»

[03:13] <gfldex> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 };\ my ( $r1, $r2 ) = await $p1, $p2; CATCH { default { say $_.Str } }; say [ $r1, $r2, 'huh' ];

[03:13] <camelia> rakudo-moar : OUTPUT«43␤»

[03:13] <Zoffix> m: try { die "foo"; CATCH { default { say "died" } } }; say "alive"

[03:13] <camelia> rakudo-moar : OUTPUT«died␤alive␤»

[03:13] <psch> m: { my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 };\ my ( $r1, $r2 ) = await $p1, $p2; CATCH { default { } } }; say [ $r1, $r2, 'huh' ];

[03:13] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/q6aJG9VOzn␤Variable '$r1' is not declared␤at /tmp/q6aJG9VOzn:1␤------> 3p1, $p2; CATCH { default { } } }; say [ 7⏏5$r1, $r2, 'huh' ];␤»

[03:14] <Zoffix> Damn, the three closing braces per each exception handling will drive me nuts :/

[03:14] <Zoffix> m: try { die "foo"; }; say "alive"

[03:14] <camelia> rakudo-moar : OUTPUT«alive␤»

[03:14] <Zoffix> Oh, that works

[03:14] * Zoffix is confused again about the exception catching business

[03:14] <psch> Zoffix: try is mostly the same as CATCH { default { } }

[03:15] <psch> being useable on a statement-level is one difference, and i think there's others, but i don't recall any right now...

[03:16] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; my ( $r1, $r2 ) = try { await $p1, $p2 }; 

[03:16] <psch> well, having to wrap the block instead of being a phaser *in* the block is another, obviously

[03:16] <camelia> rakudo-moar : OUTPUT«43␤  in block <unit> at /tmp/yhFnj2Hs0k:1␤␤»

[03:16] <Zoffix> *sigh*

[03:16] <Zoffix> I don't get what `await` is doing.

[03:16] <Zoffix> This is really confusing behaviour that try { die "foo"; } lives but try { await ... ; } dies

[03:17] <psch> m: try await start { die }

[03:17] <camelia> rakudo-moar : ( no output )

[03:17] <psch> m: my $p1 = start { sleep 3; 42 }; my $p2 = try start { die 43 }; my ( $r1, $r2 ) = await $p1, $p2;

[03:17] <camelia> rakudo-moar : OUTPUT«43␤  in block <unit> at /tmp/b48y6HnBIi:1␤␤»

[03:17] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; my ( $r1, $r2 ) = try await $p1, $p2; say 42;

[03:17] <camelia> rakudo-moar : OUTPUT«43␤  in block <unit> at /tmp/r2RYOx8vJC:1␤␤»

[03:18] <psch> async is weird :P

[03:18] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; my ( $r1, $r2 ) = try { await $p1, $p2; CATCH{ default {}}}; say 42;

[03:18] <camelia> rakudo-moar : OUTPUT«42␤»

[03:18] <Zoffix> From where I'm sitting, this looks like a bug in try

[03:19] <psch> hmm, we had one there...

[03:19] <psch> m: my $x = try 5 + "foo"; say $x

[03:19] <camelia> rakudo-moar : OUTPUT«(Any)␤»

[03:19] <psch> that for example used to not work

[03:19] <psch> or something similar...

[03:19] <psch> so yeah, maybe RT that

[03:19] <dalek> doc: 9be6234 | (Zoffix Znet)++ | doc/Type/Promise.pod:

[03:19] <dalek> doc: Clarify await

[03:19] <dalek> doc: review: https://github.com/perl6/doc/commit/9be62345a8

[03:20] <psch> m: my @a = < a bc b c cd >; say "abcd" ~~ m/^(@a)*?$/ # array interpolation uses | alternation semantics

[03:20] <Zoffix> RT#42

[03:20] <camelia> rakudo-moar : OUTPUT«False␤»

[03:20] <Zoffix> Hm... How do I get to the RT tracker? Where's it at?

[03:20] <psch> m: my @a = < a b c d bc cd >; say "abcd" ~~ m/^(@a)*?$/ # or does it

[03:20] <camelia> rakudo-moar : OUTPUT«｢abcd｣␤ 0 => ｢a｣␤ 0 => ｢bc｣␤ 0 => ｢d｣␤»

[03:20] <psch> Zoffix: rt.perl.org

[03:20] *** noganex_ joined
[03:21] <psch> ...i'll have to poke someone who actually knows regex if that's right :/

[03:21] <psch> ah duh, there's a mistake

[03:21] <psch> ...and it's LTM again

[03:21] <psch> hrm

[03:22] <psch> the second example has a 'd' alone, which lets it match

[03:22] <psch> but the first doesn't, so 'bc' matches over 'b' and thus 'cd' can't match 

[03:22] <psch> so we don't backtrack back over previous matches of the same capture group there...

[03:22] <Zoffix> m: m: try await start { die }; say "alive"

[03:22] <camelia> rakudo-moar : OUTPUT«alive␤»

[03:22] *** kaare_ left
[03:23] <Ben_Goldberg> m: m: say try await start { die }; say "alive"

[03:23] <camelia> rakudo-moar : OUTPUT«Nil␤alive␤»

[03:23] <psch> m: my @a = <a b bc c cd>; say "abcd" ~~ m/^[ $(@a[0]) | $(@a[1]) | $(@a[2]) | $(@a[3]) | $(@a[4])]*?$/; # yet this works

[03:23] <camelia> rakudo-moar : OUTPUT«｢abcd｣␤»

[03:24] <psch> m: my @a = < a bc b c cd >; say "abcd" ~~ m/^([@a])*?$/ 

[03:24] <camelia> rakudo-moar : OUTPUT«False␤»

[03:24] *** noganex left
[03:24] <psch> well, yeah.  i don't know the why of it, but i'm pretty confident that's not quite right behavior...

[03:25] *** llfourn left
[03:42] *** Ben_Goldberg left
[03:54] *** Ben_Goldberg joined
[04:00] *** llfourn joined
[04:06] *** bbarker` joined
[04:06] *** bbarker left
[04:13] *** ed__ joined
[04:13] *** ed__ left
[04:17] *** coetry left
[04:33] *** vendethiel joined
[04:35] *** tokuhiro_ joined
[04:39] *** tokuhiro_ left
[04:47] *** Ben_Goldberg is now known as BenGoldberg

[05:09] *** geraud left
[05:13] *** geraud joined
[05:15] *** vendethiel left
[05:18] *** molaf_ left
[05:21] *** abaugher left
[05:21] *** somoso joined
[05:22] <somoso> My version of perl 6 seems too old

[05:22] *** abaugher joined
[05:22] <somoso> This is perl6 version 2013.12 built on parrot 5.9.0 revision 0

[05:22] <somoso> but it's the latest one I installed just now.

[05:23] <somoso> How can I install a newer one?

[05:23] <somoso> $ perl6 -v

[05:23] <somoso> This is perl6 version 2013.12 built on parrot 5.9.0 revision 0

[05:24] *** molaf joined
[05:24] *** skids left
[05:26] <somoso> anyone?

[05:31] *** molaf left
[05:36] <somoso> should I use rakudobrew at all? i'm on Linux. in the repo of rakudobrew it says that "rakudobrew" itself is buggy.

[05:37] *** eliasr left
[05:41] <bartolin> somoso: I usually compile from git, but I think using rakudobrew makes lives easy. I haven't heard complaints about it being buggy here on #perl6

[05:41] <somoso> thx

[05:44] *** zacts joined
[05:45] <bartolin> yw. in case you hit some problems with rakudobrew, don't hesistate to ask again. at this hour the channel is a bit quite, but there are a lot of people around who use rakudobrew (I think)

[05:46] *** zacts left
[05:57] <somoso> I've installed rakudobrew, but "panda" isn't found when I type "type panda". Is it supposed to be installed with rakudobrew?

[05:58] *** doublec left
[05:58] *** xiaomiao left
[05:59] *** xiaomiao joined
[06:00] *** doublec joined
[06:03] *** sno left
[06:04] *** xfix joined
[06:10] *** sprocket joined
[06:12] *** BenGoldberg left
[06:12] *** Sqirrel joined
[06:15] *** sprocket left
[06:16] *** somoso left
[06:19] *** somoso joined
[06:20] *** somoso left
[06:34] *** polettix joined
[06:36] *** tokuhiro_ joined
[06:41] *** tokuhiro_ left
[06:57] *** geraud left
[06:57] *** FROGGS joined
[06:58] *** rindolf joined
[07:02] *** flaviusb left
[07:03] *** domidumont joined
[07:07] *** domidumont left
[07:08] *** pdcawley joined
[07:08] *** domidumont joined
[07:22] *** rigsby joined
[07:23] *** khw left
[07:26] *** tokuhiro_ joined
[07:28] *** flaviusb joined
[07:28] *** doublec left
[07:29] *** doublec joined
[07:29] *** xinming left
[07:30] *** tokuhiro_ left
[07:34] *** CIAvash joined
[07:36] *** rurban joined
[07:48] *** rigsby left
[07:48] <[ptc]> somoso: panda isn't installed with rakudobrew.  You have to run `rakudobrew build-panda`

[07:50] *** xfix left
[07:55] *** RabidGravy joined
[07:55] * moritz would like an option 'rakudobrew autoinstall=panda,zef' and then it'd automatically install those two for me for each new rakudo

[07:56] *** sno joined
[07:57] <nine> Why doesn't it install panda automatically in default settings?

[07:58] <[Tux]> test             50000    21.112    20.998

[07:58] <[Tux]> test-t           50000    18.055    17.940

[07:58] <[Tux]> csv-parser       50000    28.288    28.173

[07:59] <El_Che> moritz: installing 2 competing implementation for something fundamental will cause a world of confusion, imho

[08:00] <nine> El_Che: he wants this to be optional, not to be default

[08:01] <El_Che> nine: true, although people copy pasting won't get that :)

[08:03] *** espadrine_ joined
[08:04] *** espadrine_ is now known as espadrine

[08:06] <nine> I've never even looked at zef yet I wonder if going forward, we are gonna keep both installers. Panda looks like a good base. What reasons are there for having an alternative?

[08:07] <moritz> El_Che: the normal usage would be to autoinstall just one of them

[08:07] <moritz> El_Che: and if only that was supported, that'd still be great

[08:07] *** darutoko joined
[08:08] <moritz> nine: currently, panda doesn't precompile modules; zef also works in parallel

[08:08] <moritz> nine: I see lots of room for experimenting with package managers

[08:12] <El_Che> I have only used panda and I haven't looked unde the hood. What does "[zef] Works in parallel" mean? They put the modules somewhere else? The use the same way to check if something is installed?

[08:13] <El_Che> cpanm uses packlists to remove modules. Would this be a future conflict?

[08:13] <moritz> El_Che: it means that if a module has two dependencies, zef will install those two dependent modules in parallel

[08:14] <FROGGS> which might be nice when you install e.g. Task::Star

[08:15] *** domidumont left
[08:15] *** doublec left
[08:16] <El_Che> moritz: ah ok. I was thinking of conflicts (or not) when using panda and zef on the same installation

[08:16] *** doublec joined
[08:21] *** pdcawley left
[08:22] *** zakharyas joined
[08:22] *** domidumont joined
[08:24] *** Ven joined
[08:25] *** g4 joined
[08:26] *** ollej_ left
[08:28] *** maddingu1 is now known as maddingue

[08:29] *** polettix left
[08:30] <Ven> o/

[08:31] *** polettix joined
[08:31] *** tokuhiro_ joined
[08:31] *** pdcawley joined
[08:32] *** abraxxa joined
[08:34] *** Ven left
[08:36] *** tokuhiro_ left
[08:36] <DrForr> \o

[08:39] *** jonas2 joined
[08:40] *** espadrine left
[08:41] *** pdcawley left
[08:43] *** pdcawley joined
[08:48] *** Ven joined
[08:49] *** doublec left
[08:50] *** Ven left
[08:50] *** polettix left
[08:51] *** doublec joined
[08:52] <[ptc]> o/

[08:54] <masak> mornin'

[08:57] *** xinming joined
[08:58] <cognominal> m: my ($a, [$b] ) = 42, [666]; say $a.perl, $b.perl

[08:58] <camelia> rakudo-moar : OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/OYD735wn7W:1␤␤»

[08:59] <cognominal> m: my :($a, [$b] ) = 42, [666]; say $a.perl, $b.perl

[08:59] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/gGoNLw1mB0␤Malformed my␤at /tmp/gGoNLw1mB0:1␤------> 3my7⏏5 :($a, [$b] ) = 42, [666]; say $a.perl, ␤»

[08:59] <cognominal> is it possible to do destructuring without calling a function ?

[09:01] <cognominal> not sure what the first expression really does btw.

[09:07] *** znpy joined
[09:11] *** doublec_ joined
[09:11] <masak> cognominal: if that's not in RT, please put it there.

[09:11] <cognominal> m: my ($a, [$b] ) = 42, [666]; say $a, $b

[09:11] <camelia> rakudo-moar : OUTPUT«42(Mu)␤»

[09:11] *** dakkar joined
[09:13] *** doublec left
[09:15] *** xinming_ joined
[09:16] <masak> cognominal: and no, the synopses don't mention that kind of destructuring assignment at all.

[09:16] <masak> only destructuring through subsignatures.

[09:18] <cognominal> m: sub fun($a, [$b] ){ say $a, $b }; fun( 42, [666]); 

[09:18] <camelia> rakudo-moar : OUTPUT«42666␤»

[09:20] <masak> m: sub fun($a, [$b] ){ say $a.perl; say $b.perl }; fun( 42, [666]);

[09:20] <camelia> rakudo-moar : OUTPUT«42␤666␤»

[09:22] <cognominal> masak, I filed it. Seems to me it is a must have. And the cost of implementation should be negligible being already done within function calls.

[09:23] <masak> not sure about "it is a must have" :)

[09:23] <masak> but the "null object" error sounds like no-one's put a story there.

[09:24] *** vytas left
[09:24] <cognominal> RT 126712

[09:24] *** abaugher left
[09:25] <cognominal> masak: it seems to me that list assignment is just a degenerate case of destructuring

[09:25] *** abaugher joined
[09:26] <moritz> at parse time, list assignment also has a different precedence

[09:26] <cognominal> And my example parses. I just have no idea what it is supposed to do in the current implementation.

[09:26] *** vytas joined
[09:27] *** mady joined
[09:27] * mady slaps avar around a bit with a large fishbot

[09:27] *** mady left
[09:28] <masak> NOBODY expects the large fishbot!

[09:31] <cognominal> moritz: yes, that's why I wrote ... = 42, [666] without the parentheses

[09:32] *** tokuhiro_ joined
[09:35] *** Ulti joined
[09:36] *** tokuhiro_ left
[09:38] <masak> m: class C { has $.value; method foo { $value } }

[09:38] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/XW9Zvq077m␤Variable '$value' is not declared. Did you mean any of these?␤    &values␤    $!value␤␤at /tmp/XW9Zvq077m:1␤------> 3class C { has $.value; method foo { 7⏏5$value } }␤»

[09:38] <masak> Levenshtein is great -- I love Levenshtein, we all love Levenshtein.

[09:38] <masak> should we consider giving `$.value` as the alternative there, rather than `$!value`? or maybe both?

[09:39] *** Ven joined
[09:39] <cognominal> I agree

[09:43] *** ely-se joined
[09:46] <jnthn> I think you more often inside a class would want $!value

[09:46] <yoleaux> 22 Nov 2015 01:00Z <diakopter> jnthn: shaved 8% off CORE compilation by writing the idx after looking it up in interp.c http://i.imgur.com/WX35mFe.png

[09:46] <yoleaux> 22 Nov 2015 19:29Z <mj41> jnthn: https://github.com/rakudo/star/blob/master/docs/2015-spw-perl6-course.pdf slide 23 s/# (Int)/# (Str)/

[09:46] <jnthn> morning, #perl6

[09:49] <BooK> I had a discussion with a colleague who likes Erlang very much, and he said that one issue he has with Perl 6 is that it does not support an actor model, or rather, that one is still working within a process

[09:49] *** kjs_ joined
[09:52] <BooK> (not sure I explain it correctly... but what I understood is that in Erlang, you don't really ever need to know how the stuff is going to be run. it could be one process on one box, or many processes across many machines all over the network)

[09:52] *** doublec joined
[09:52] <BooK> is that something perl 6 can eventually provide?

[09:54] *** doublec_ left
[09:54] <jnthn> Sure; there's been plenty of examples of languages less flexible than Perl 6 providing popular Actor implementations in module space rather than in the language.

[09:54] <jnthn> (Akka probably being the most notable at present)

[09:57] <BooK> so, patches welcome? ;-)

[09:58] *** yeahnoob left
[10:00] *** cognominal left
[10:01] *** cognominal joined
[10:02] *** eliasr joined
[10:05] <jnthn> Well, "modules welcome". It's an interesting area, but I've so many other things on my plate right now... :)

[10:05] *** zakharyas1 joined
[10:06] *** ely-se left
[10:06] *** dams joined
[10:07] <dams> BooK: ping.

[10:07] *** zakharyas left
[10:07] <BooK> dams: pong

[10:08] *** espadrine joined
[10:08] <BooK> I invited the troll to join the conversation ;-)

[10:08] <BooK> dams: hope you like the introduction

[10:08] <jnthn> :-)

[10:08] <dams> hey hi :)

[10:09] <jnthn> Hi!

[10:09] <dams> jnthn: my point was that : Erlang implements concurrency and parallelism (via threads internally), but offers to the developer only the Actor model API

[10:09] <dams> it seems to me that Perl6 also implements concurrency and parallelism (via threads internally), but offers to the developer only the "thread" model API

[10:10] <dams> so it seems to me that the Perl6 culture is towards the thread models, instead of either being agnostoc (no model by default), or acto oriented

[10:10] <masak> there's something to that

[10:10] <masak> but see also the new supply keyword

[10:11] <dams> saying that "actor model can always be implemented in module", but at the same time having the thread model API exposed by default

[10:11] <dams> means that the thread model is heavily put forward. Which I'm not a big fan of. Which is OK, most people like the thread API

[10:11] <dams> but I thought that it would have been cool to not provide *any* API by default, and let them be implemented as modules, both thread/actor models

[10:12] <dams> just my 2 cents :)

[10:12] * dams searchgin for the supply keyword

[10:13] *** Ven left
[10:14] *** larion joined
[10:14] <jnthn> While you can get at threads directly if you want, most of the constructs we have and expect people to work with are of the "don't have to care what thread you're running on" kind. The supply blocks masak just mentioned are very much of that nature: plenty of threads may push messages through a supply block's logic over its lifetime, but only one thread at a time will ever be in there.

[10:15] <dams> looks like a pubsub version of golan Channels ? or am I misreading ?

[10:15] <jnthn> golan*g*? :)

[10:16] <dams> golang yes

[10:16] <jnthn> More inspired by Rx

[10:16] <dams> ah, ok, don't know anythong about Rx :(

[10:16] <dams> can you easily have one of your supply endpoint be on a different host ?

[10:16] <jnthn> But pubsub is close, given Rx is all about the observer pattern.

[10:17] <dams> and totally different question: does have Perl6 something similar than supervisors ?

[10:17] <dams> s/than/to/

[10:19] *** TEttinger left
[10:20] <jnthn> Well, supplies are how we expose our async sockets API, so "kind of" :) I think folks have done stuff like having supplies of incoming messages from a message queue too.

[10:21] <jnthn> The current best way to IPC tends to move fairly fast, so I'm wary about building too much in at the language level.

[10:21] <jdv79> iirc some of the early design docs hinted at, if not outright talked about, different forms of concurrency under the covers

[10:25] <RabidGravy> yeah, Net::AMQP exposes the messages via a supply

[10:26] <dams> I think I understand. So there is no concept of "process" like in Erlang

[10:27] <dams> thanks for the info, I'll stop trolling now :)

[10:27] <jdv79> no, i mean the runtime, or the user, could choose forks over threads over something else potentially to back the primitives

[10:27] <jnthn> dams: If only all "trolling" was so polite/educated... :)

[10:28] <dams> hehe I can throw some insults if you insists :)

[10:28] <jdv79> which sounds like the same thing dams is looking for

[10:28] <dams> jnthn: the context is that I really like the minimal approach of Erlang/Elixir, few concepts, high efficiency, and not claiming to be a generic language

[10:29] <dams> I'm wondering if I could use a subset of Perl6 to mimic the approach

[10:29] * jnthn did start on an OO::Actors module, which gave an "actor" keyword and enforced one-at-a-time processing in coming calls, but didn't yet have time to get to the supervisor bit, let alone the network bit...so it's pretty much not really actors at all yet... :(

[10:29] <dams> jdv79: yes that is more or less what I'm looking for. Is that possible or would it be possible ?

[10:31] <dams> jnthn: nice, if that OO::Actors ever flies at some point, I'll try it out :) 

[10:31] <jnthn> dams: Perl has "there's more than one way to do it" as a motto. But opinionated subsets that removes some features and adds others are certainly a "way to do it".

[10:32] <dams> from the outside world, Perl6 sometimes like "TIMTOWTDI, so we've included *all* ways to do it" :)

[10:32] <dams> which is scary

[10:32] <El_Che> dams is a crappy troll. Try "I want Inline::Erlang NOW"

[10:33] <El_Che> :)

[10:34] <jnthn> Not *all*. But yes, Perl 6's opinionated points aren't really language-feature centric.

[10:34] <BooK> dams: actually, all the ways are possible, we just need some volunteers to plug them in :-)

[10:35] <jnthn> They're more about concepts like consistent scoping rules, extensible syntax, early-bound/late-bound distinction, etc.

[10:35] <dams> immutability ? :P

[10:36] <btyler_> Inline::Erlang++ :D

[10:36] <btyler_> well, probably writing a port driver

[10:38] <dams> btyler_: yo'ure everywhere :)

[10:38] <masak> dams: not a lot of immutability, no. not compared to something like Haskell.

[10:38] <masak> dams: though I could imagine someone exploring "immutable Perl 6" in module space.

[10:39] <El_Che> so dams, these question are a prelude for porting dancer2 or perl6? :)

[10:39] <El_Che> s/or/to

[10:40] <cognominal> dams: or write immutable structures, like rrb trees, made available thru the representation layer

[10:40] <dams> El_Che: there is already a perl6 port afaik

[10:41] <dams> cognominal: the trick is really about immutabile variables

[10:41] <jnthn> Perl 6 *is* rather strong at list processing functional style

[10:41] <jnthn> You also have the my \foo = ... single static assignment form

[10:41] <jnthn> m: my \foo = 42; foo = 100 # can't assign this

[10:41] <camelia> rakudo-moar : OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/Iqr6szQRKY:1␤␤»

[10:42] <dams> ah nice

[10:44] <dalek> roast/bool_enum: a4f8e29 | (Stefan Seifert)++ | S02-types/bool.t:

[10:44] <dalek> roast/bool_enum: Bool is now an enum with base type Int

[10:44] <dalek> roast/bool_enum: 

[10:44] <dalek> roast/bool_enum: Fixes RT #72580

[10:44] <dalek> roast/bool_enum: review: https://github.com/perl6/roast/commit/a4f8e29d41

[10:44] <dalek> roast/bool_enum: 56a570d | (Stefan Seifert)++ | S32-exceptions/misc.t:

[10:44] <dalek> roast/bool_enum: Enums are now augmentable

[10:44] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=72580

[10:44] <dalek> roast/bool_enum: 

[10:44] <dalek> roast/bool_enum: I see no reason why an enum should not be augmentable. Indeed there are tests

[10:44] <dalek> roast/bool_enum: for augmenting Bool which is an enum by spec. So remove the bogus test.

[10:44] <dalek> roast/bool_enum: review: https://github.com/perl6/roast/commit/56a570db4a

[10:44] <dalek> roast/bool_enum: 51698fd | (Stefan Seifert)++ | S03-operators/relational.t:

[10:44] <dalek> roast/bool_enum: TODOs for chaining !before and !after now pass

[10:44] <dalek> roast/bool_enum: 

[10:44] <dalek> roast/bool_enum: Don't know why though?

[10:44] <dalek> roast/bool_enum: review: https://github.com/perl6/roast/commit/51698fd581

[10:44] <dalek> roast/bool_enum: 4efef8c | jnthn++ | S02-types/ (6 files):

[10:44] <dalek> roast/bool_enum: Update tests for Bool ~~ Int becoming true.

[10:44] <dalek> roast/bool_enum: 

[10:44] <dalek> roast/bool_enum: As part of the upcoming change to make Bool a real enumeration.

[10:44] <dalek> roast/bool_enum: review: https://github.com/perl6/roast/commit/4efef8c3c6

[10:44] *** rindolf left
[10:45] *** AlexDaniel joined
[10:45] <AlexDaniel> .u ̆

[10:45] <yoleaux> U+0306 COMBINING BREVE [Mn] (◌̆)

[10:46] *** polettix joined
[10:46] <jnthn> nine: re 56a570d did you actually make enums augmentable in the end?

[10:46] <jnthn> Because various other tests fail 'cus they ain't

[10:46] *** Skarsnik joined
[10:49] <cognominal> dams:  http://docs.perl6.org/language/containers

[10:54] *** xpen_ left
[10:56] *** xpen joined
[10:58] *** Juerd left
[11:02] *** rindolf joined
[11:04] *** xinming left
[11:04] *** xinming_ left
[11:05] *** polettix left
[11:06] *** xinming joined
[11:06] *** polettix joined
[11:06] *** edehont joined
[11:07] *** xinming_ joined
[11:13] *** s_kilk joined
[11:14] *** Juerd joined
[11:16] *** rindolf left
[11:17] *** kjs_ left
[11:20] <dalek> rakudo/nom: a06069b | (Stefan Seifert)++ | src/ (3 files):

[11:20] <dalek> rakudo/nom: Turn Bool into a proper enum

[11:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a06069b1d7

[11:20] <dalek> rakudo/nom: 5105894 | (Stefan Seifert)++ | src/core/operators.pm:

[11:20] <dalek> rakudo/nom: Fix SEQUENCE not expecting Bool ~~ Real to be true

[11:20] *** dalek left
[11:21] <jnthn> .tell nine I fixed the final issues and merged bool_enum :)

[11:21] <yoleaux> jnthn: I'll pass your message to nine.

[11:21] *** dalek joined
[11:21] *** ChanServ sets mode: +v dalek

[11:21] *** dalek left
[11:22] *** dalek joined
[11:22] *** ChanServ sets mode: +v dalek

[11:22] *** s_kilk left
[11:25] *** nowan left
[11:25] *** nowan joined
[11:27] *** s_kilk joined
[11:28] <zengargoyle>  m: my (($a, [$b] )) = 42, [666]; say $a, $b

[11:28] <camelia> rakudo-moar : OUTPUT«(Mu)(Mu)␤»

[11:30] <zengargoyle>  m: my ($a, @ [$b] ) = 42, [666]; say $a, $b

[11:30] <camelia> rakudo-moar : OUTPUT«42(Mu)␤»

[11:30] *** AlexDaniel left
[11:34] *** tokuhiro_ joined
[11:35] *** polettix left
[11:36] <jnthn> Need := for getting unpacking/signature binding semantics

[11:38] <zengargoyle> ah, i knew i had seen it work somehow

[11:38] *** tokuhiro_ left
[11:39] <psch> m: say "abcd" ~~ /^(a | b | bc | cd)*?$/; my @a = < a b bc cd >; say "abcd" ~~ /^(@a)*?$/

[11:39] <camelia> rakudo-moar : OUTPUT«｢abcd｣␤ 0 => ｢a｣␤ 0 => ｢b｣␤ 0 => ｢cd｣␤Nil␤»

[11:40] <psch> jnthn: am i misunderstanding array interpolation or should those two be equivalent?

[11:40] <jdv79> jnthn: http://irclog.perlgeek.de/perl6/2015-11-22#i_11581875

[11:41] <jdv79> should i bug that?

[11:41] *** andreoss joined
[11:42] *** Upasaka left
[11:43] <jnthn> jsimonet: Yes, something looks a bit off there

[11:44] <jnthn> oops 

[11:44] <jnthn> jdv79: ^^ :)

[11:44] <Zoffix> Is everyone piling on jnthn with questions about whether something is a bug?

[11:44] * Zoffix joins in

[11:45] <Zoffix> m: try await start { die }; say "alive"

[11:45] <camelia> rakudo-moar : OUTPUT«alive␤»

[11:45] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; my ( $r1, $r2 ) = try await $p1, $p2; say 42;

[11:45] <camelia> rakudo-moar : OUTPUT«43␤  in block <unit> at /tmp/HxfkqznXGk:1␤␤»

[11:45] <jdv79> k

[11:45] <Zoffix> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; my ( $r1, $r2 ) = try { await $p1, $p2; CATCH{ default {}}}; say 42;

[11:45] <camelia> rakudo-moar : OUTPUT«42␤»

[11:45] *** Ven joined
[11:46] *** Upasaka joined
[11:46] <jnthn> psch: I don't see why those two wouldn't work out the same.

[11:47] <jnthn> There may be a reason, but it ain't obvious to me at first glance.

[11:48] <psch> jnthn: right, i'll RT it then

[11:48] <jnthn> m: my $p1 = start { sleep 3; 42 }; my $p2 = start { die 43 }; try my ( $r1, $r2 ) = await $p1, $p2; say 42;

[11:48] <camelia> rakudo-moar : OUTPUT«42␤»

[11:48] <jnthn> Zoffix: ^^

[11:48] <jnthn> Zoffix: With multiple awaitables you get back a lazy list

[11:48] <Zoffix> jnthn, Ohhhh.

[11:48] <Zoffix> jnthn, thanks. I'll close the RT ticket

[11:48] <jnthn> m: my @a = try (1, 2, 3).map({ die })

[11:48] <camelia> rakudo-moar : OUTPUT«Died␤  in block <unit> at /tmp/W_00QYTIEa:1␤␤»

[11:49] <jnthn> That is a much simpler example of the same thing :)

[11:49] <nine> jnthn: thanks for taking bool_enum off my TODO list :)

[11:49] <yoleaux> 11:21Z <jnthn> nine: I fixed the final issues and merged bool_enum :)

[11:49] <nine> \o/

[11:49] <jnthn> nine: You took precomp management off mine, so I think I came out ahead. ;-)

[11:50] <nine> And everybody wins :)

[11:50] <jnthn> \o/

[11:50] * jnthn is working on RT #74900

[11:50] <jnthn> synbot6: You lazy!

[11:51] <cognominal> m: my ($a, [$b] ) = 42, [666]; say ($al, $b)

[11:51] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/DvK1knNLeM␤Variable '$al' is not declared␤at /tmp/DvK1knNLeM:1␤------> 3my ($a, [$b] ) = 42, [666]; say (7⏏5$al, $b)␤»

[11:51] <cognominal> m: my ($a, [$b] ) := 42, [666]; say ($al, $b)

[11:51] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/BwqFf9AYkE␤Variable '$al' is not declared␤at /tmp/BwqFf9AYkE:1␤------> 3my ($a, [$b] ) := 42, [666]; say (7⏏5$al, $b)␤»

[11:51] <cognominal> oops

[11:51] <cognominal> m: my ($a, [$b] ) := 42, [666]; say ($a, $b)

[11:51] <camelia> rakudo-moar : OUTPUT«(42 (Mu))␤»

[11:52] <cognominal> m: my ($a, [$b] ) := (42, [666]); say ($a, $b)

[11:52] <camelia> rakudo-moar : OUTPUT«(42 (Mu))␤»

[11:52] <zengargoyle> m: my ($a, @ [$b] ) := 42, [666]; say ($a, $b)

[11:52] <camelia> rakudo-moar : OUTPUT«(42 (Mu))␤»

[11:52] <jnthn> m: my ($a, [$b] ) := \(42, [666]); say ($a, $b) # maybe this?

[11:52] <camelia> rakudo-moar : OUTPUT«(42 (Mu))␤»

[11:52] <zengargoyle> m: my ($a, @ [$b] ) := 42, [666]; say $a, $b

[11:52] <camelia> rakudo-moar : OUTPUT«42(Mu)␤»

[11:52] <jnthn> Hm

[11:53] <zengargoyle> hrm indeed, that actually worked for local install.

[11:53] <jnthn> ooh

[11:53] <jnthn> Bad optimizer, no cookie

[11:54] <jnthn> Works fine with --optimize=off

[11:54] <cognominal> same here, works locally

[11:54] <jnthn> I think it's the same issue as: 

[11:54] <cognominal> optimize is off by default?

[11:54] <jnthn> m: my (\a, \b) := 1, 2; say a; say b;

[11:54] <camelia> rakudo-moar : OUTPUT«(Any)␤(Any)␤»

[11:55] <jnthn> oh, no...apparently not

[11:55] <jnthn> cognominal: No, on level 2 by default

[11:56] <cognominal> jnthn, so why does it work locally and not with camelia?

[11:57] <cognominal> I mean, destructuring

[11:58] <cognominal> closing my ticket. jnthn++

[11:59] <dalek> rakudo/nom: 99e23c3 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[11:59] <dalek> rakudo/nom: An exact arity match beats slurpy/optional.

[11:59] <dalek> rakudo/nom: 

[11:59] <dalek> rakudo/nom: This means that a zero-arity candidate along with two 1-arg candidates

[11:59] <dalek> rakudo/nom: taking optional parameters will end up winning, instead of coming out

[11:59] <dalek> rakudo/nom: ambiguous.

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99e23c39bd

[12:00] <jnthn> cognominal: What version do you have locally?

[12:00] <zengargoyle> btw, http://doc.perl6.org/type/Signature makes it sound like the bind isn't needed.  but only gives one example of « my ($a, @b) = 5,(6,7,8) » and calls the my part a signature.  sorta implying no bind.

[12:01] <dalek> roast: cdd533a | jnthn++ | S06-multi/syntax.t:

[12:01] <dalek> roast: Tests for RT #74900.

[12:01] <dalek> roast: review: https://github.com/perl6/roast/commit/cdd533a05c

[12:01] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=74900

[12:02] <arnsholt> Is the "HAS $.foo" syntax for inlined stuff Rakudo-specific, or intended to be general Perl 6 thing?

[12:02] <jnthn> It...exists?

[12:02] * jnthn didn't realize that actually got implemented :P

[12:04] <cognominal> jnthn, 2015.11-33-gfa3ce11

[12:04] <jnthn> Bend-47-g99e23c3 here

[12:04] <arnsholt> So mostly a Rakudo-thing, then, I guess? =)

[12:04] *** kjs_ joined
[12:05] <arnsholt> Oh, wait. Looks like it's actually a *NativeCall* thing

[12:05] <jnthn> ooh :)

[12:06] * jnthn ain't sure

[12:06] <jnthn> NativeCall is one of the things that I (co-)started and other people picked up and ran with really well, so I don't follow it too closely any more. :)

[12:08] <jnthn> Down to 36 xmas RTs. Think I can nail at least one more today. But first, lunch. :)

[12:08] *** xpen left
[12:09] *** s_kilk left
[12:13] *** Upasaka_ joined
[12:13] *** Upasaka left
[12:16] *** sufrostico joined
[12:23] *** rurban left
[12:24] <Skarsnik> yes HAS is only on NC x)

[12:24] <Skarsnik> and hello there

[12:26] *** lucasb joined
[12:26] *** dayangkun_ left
[12:26] *** xinming left
[12:27] *** n0xff joined
[12:27] *** xinming_ is now known as xinming

[12:28] <abraxxa> jnthn++

[12:29] *** kjs_ left
[12:30] *** loren joined
[12:32] *** Ven_ joined
[12:34] *** kid51 joined
[12:35] *** Ven left
[12:35] <dams> +win close

[12:35] *** dams left
[12:37] *** kaare_ joined
[12:38] *** polettix joined
[12:42] *** kid51 left
[12:45] *** kjs_ joined
[12:47] *** CIAvash left
[12:56] <cognominal> m: my ( $a => $b ) := :b  # probably asking for the moon, but (some) composers should eventually work as deconstuctors

[12:56] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/Se8e_43tCc␤Preceding context expects a term, but found infix > instead␤at /tmp/Se8e_43tCc:1␤------> 3my ( $a =>7⏏5 $b ) := :b  # probably asking for the m␤»

[13:03] *** sprocket joined
[13:04] <jnthn> m: my (:$b) := :b; say $b;

[13:04] <camelia> rakudo-moar : OUTPUT«2 unexpected named arguments passed (key,value)␤  in block <unit> at /tmp/NI148UE4VB:1␤␤»

[13:04] <jnthn> ah, yeah :)

[13:04] <jnthn> Can see $a => $b maybe being doable in sigs...maybe...

[13:04] <cognominal> yea, pairs are special with named arguments

[13:05] <jnthn> Don't immediately see a syntactic ambiguity

[13:05] <cognominal> I should not distract jnthn :(

[13:05] <andreoss> m: my ($a,$b) := :b; say $a;

[13:05] <camelia> rakudo-moar : OUTPUT«Too few positionals passed; expected 2 arguments but got 0␤  in block <unit> at /tmp/AgFg1bKJC9:1␤␤»

[13:07] *** ely-se joined
[13:07] *** sprocket left
[13:14] *** ZoffixW joined
[13:14] *** Skarsnik_ joined
[13:15] <ZoffixW> What would be a good way to await several promises then print the results of all that were kept? I've tried multiple things and all look extremely messy or exceptions are thrown: http://fpaste.scsys.co.uk/501802

[13:17] <ZoffixW> m: my $p1 = start die "I'm dead"; my $p2 = start "I'm alive"; try eager await $p1, $p2; say .result for grep { .status ~~ 'Kept'}, $p1, $p2;

[13:17] <camelia> rakudo-moar : OUTPUT«I'm alive␤»

[13:17] <ZoffixW> This isn't too bad, I guess. Using "eager" was key.

[13:17] *** zengargoyle left
[13:18] <jnthn> await Promise.allof($p1, $p2) # should do it, but seems allof throws if one of the promises fails

[13:18] <jnthn> Which it ain't really meant to

[13:18] *** zengargoyle joined
[13:18] <jnthn> Though probably my fault that it does...

[13:18] *** Skarsnik left
[13:19] <ZoffixW> Yeah, I'm kinda confused about the need for .allof() since await awaits for allof them anyway

[13:20] *** Skarsnik_ is now known as Skarsnik

[13:20] <jnthn> Well, the point of allof is more so you can talk about all of them having reached completin independent of whether there was success or not.

[13:21] * jnthn is looking at concurrency stuff this week, so will address that one

[13:21] <ZoffixW> jnthn++ sweet

[13:22] *** brrt joined
[13:27] *** ZoffixW left
[13:33] *** CurtisOvidPoe joined
[13:33] *** zakharyas1 left
[13:34] <CurtisOvidPoe> Hi folks. Writing up an OSCON proposal and was curious about the deadline for the Perl 6 release?

[13:34] <yoleaux> 25 Oct 2015 23:17Z <lizmat> CurtisOvidPoe: maybe the awaiterator is something for you ?

[13:34] *** zakharyas joined
[13:35] *** tokuhiro_ joined
[13:35] <jnthn> CurtisOvidPoe: Still aiming at ~1 month from now :)

[13:35] <CurtisOvidPoe> Awesome :)

[13:38] *** rurban joined
[13:39] <CurtisOvidPoe> @masak: are you here?

[13:40] *** tokuhiro_ left
[13:53] *** hankache joined
[13:56] *** Upasaka_ left
[13:57] *** zengargoylew joined
[13:59] *** Upasaka joined
[14:00] *** domidumont left
[14:04] *** domidumont joined
[14:06] <hankache> hello perl 6

[14:10] *** loren left
[14:12] *** telex left
[14:13] *** skids joined
[14:14] *** telex joined
[14:14] *** sprocket joined
[14:15] *** edehont left
[14:16] *** ely-se left
[14:19] <brrt> hi hankache

[14:21] <Ven_> o/ hankache 

[14:29] *** zact joined
[14:31] *** dgl is now known as dg

[14:31] *** Upasaka left
[14:34] *** Ven_ left
[14:37] *** tokuhiro_ joined
[14:38] <masak> ahoy hankache 

[14:39] *** coetry joined
[14:40] <timotimo> ahoi-hoi

[14:41] *** iH2O joined
[14:41] *** tokuhiro_ left
[14:45] *** Upasaka joined
[14:45] *** coetry left
[14:47] *** eliasr left
[14:47] *** zact is now known as zacts

[14:49] *** Ven joined
[14:51] *** iH2O left
[14:57] *** zacts left
[14:58] <masak> m: constant foo = foo

[14:58] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/HYFp4RxYmz␤An exception occurred while evaluating a constant␤at /tmp/HYFp4RxYmz:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot invoke this object␤  at :␤»

[14:58] <masak> does anyone remember if this one is in RT? (probably, right?)

[14:58] <timotimo> i seem to recall we had a better error for that case at some point; could be for something similar, though

[14:59] <jnthn> It's better than it was; it at least tells you now it was trying to evaluate a constant :)

[14:59] *** cognominal left
[15:01] *** cognominal joined
[15:02] *** xpen joined
[15:02] *** Ven left
[15:03] *** sftp left
[15:04] *** jonas2 left
[15:06] *** sftp joined
[15:08] <hoelzro> .tell cygx I noticed your logic for detecting the libc DLL name on Windows in Native::LibC; the MSVC variant only seems to work for VS 2011 =/

[15:08] <yoleaux> hoelzro: I'll pass your message to cygx.

[15:10] *** muraiki joined
[15:13] <muraiki> building panda is broken currently due to failing tests in JSON::Fast: https://github.com/tadzik/panda/issues/247

[15:13] *** Upasaka left
[15:14] *** Upasaka joined
[15:16] *** lucasb left
[15:16] <timotimo> muraiki: please see my latest commit in json_fast

[15:17] <muraiki> timotimo: thanks! I just responded

[15:18] <timotimo> *something* is putting False in there

[15:18] <timotimo> that's invalid, but i can't reproduce it locally :(

[15:18] <timotimo> i mean ... yeah, there's a False in it, but i think the code is supposed to turn that into false instead

[15:19] <timotimo> muraiki: can you put a bit of debug code into to-json inside lib/JSON/Fast.pm?

[15:19] <muraiki> sure

[15:19] <timotimo> line 15 should do the bool thing right

[15:19] <muraiki> yes

[15:19] *** CIAvash joined
[15:20] *** [particle]1 left
[15:21] <timotimo> m: say True ~~ Bool

[15:21] <camelia> rakudo-moar : OUTPUT«1␤»

[15:21] *** [particle] joined
[15:21] *** s_kilk joined
[15:22] <muraiki> should that return True?

[15:23] <timotimo> i think so, but i don't think that's the problem here

[15:23] <muraiki> roger

[15:23] *** eyck joined
[15:23] <timotimo> i do get True locally

[15:23] *** eyck left
[15:23] <timotimo> so that must be the "make bools into real objects, for real" branch?

[15:23] <timotimo> that recently got merged

[15:23] <muraiki> I get 1 locally

[15:23] <jnthn> m: say Bool ~~ Int

[15:23] <camelia> rakudo-moar : OUTPUT«True␤»

[15:23] <jnthn> timotimo: That changed

[15:24] <timotimo> oh?

[15:24] <timotimo> ah!

[15:24] <timotimo> yes!

[15:24] <timotimo> so these two lines have to be switched

[15:24] *** eyck joined
[15:25] <timotimo> muraiki: pushed commits, please try

[15:25] <muraiki> roger

[15:25] <timotimo> if they work, i can incorporate these commits into panda, too, i think

[15:26] <muraiki> still fails :(

[15:27] <muraiki> # Failed test 'Array of Num'

[15:27] <muraiki> # at t/04-roundtrip.t line 38

[15:27] <muraiki> # expected: $[1.3, 2.8, 32323423.4, 4.0]

[15:27] <muraiki> #      got: $[1.3, 2.8, 32323423.4, 4]

[15:27] *** cdg joined
[15:27] <timotimo> that test is todo'd, though, isn't it?

[15:27] <muraiki> oh, yes: not ok 10 - Array of Num# TODO known type mismatches

[15:27] <timotimo> :)

[15:27] <timotimo> if you want to, you can try to fix that :P

[15:28] <muraiki> heh, unfortunately I have a problem in production that I need to fix... but I first needed to update rakudo there

[15:29] <muraiki> I have a long-running p6 script that creates a bunch of IO watchers and schedules one block to run every 10 min, and for some reason it becomes unresponsive without actually crashing after some period of time

[15:29] <muraiki> but the first step is to not use a rakudo from july

[15:29] <muraiki> :)

[15:30] *** eyck left
[15:31] *** eyck joined
[15:31] *** rurban left
[15:33] *** eyck left
[15:33] *** zacts joined
[15:34] *** eyck joined
[15:35] *** eyck left
[15:35] *** yqt joined
[15:36] *** s_kilk left
[15:37] <timotimo> oh, very yes. july is SO LONG AGO

[15:37] *** FROGGS left
[15:37] <timotimo> there were data races and such fixed in the latest months

[15:37] *** eyck joined
[15:38] *** s_kilk joined
[15:39] <timotimo> muraiki: i pushed a subtree update to panda

[15:39] <dalek> modules.perl6.org/new-db-builder: aa44e08 | (Zoffix Znet)++ | t/01-models/03-site-tips.t:

[15:39] <dalek> modules.perl6.org/new-db-builder: Iterate test fewer times so coverage evaluation does not take forever to run

[15:39] <dalek> modules.perl6.org/new-db-builder: review: https://github.com/perl6/modules.perl6.org/commit/aa44e0847a

[15:39] <tadzik> muraiki, timotimo: so did json::fast broke on a recent rakudo or what?

[15:39] *** Upasaka left
[15:39] <timotimo> yes

[15:39] <tadzik> ah, fair enough

[15:39] <timotimo> panda's already updated :)

[15:39] *** Upasaka joined
[15:39] <tadzik> I thought panda is installing some bleeding-edge json-fast by accident :)

[15:39] <tadzik> so all goodnow?

[15:40] <timotimo> i think so

[15:40] *** s_kilk left
[15:40] <muraiki> building now

[15:40] <muraiki> yup, it's good! thanks so much

[15:41] <tadzik> thanks for reporting it :)

[15:41] <timotimo> yes, thanks a lot, muraiki!

[15:43] *** ely-se joined
[15:44] <muraiki> someone else reported it first, but I figured it was critical enough to bother #perl6 about :)

[15:45] <zengargoylew> does Damian Conway ever show up here? is he still involved much in Perl 6 or is that mostly history. 

[15:46] <dalek> modules.perl6.org/new-db-builder: df1f196 | (Zoffix Znet)++ | t/02-db-builder/02-github-source.t:

[15:46] <dalek> modules.perl6.org/new-db-builder: Improve output on test failures

[15:46] <dalek> modules.perl6.org/new-db-builder: 

[15:46] <dalek> modules.perl6.org/new-db-builder: Fatal log errors kill our tests, but the actual messages (like missing GitHub token) do not show up in the TAP. Fix that.

[15:46] <dalek> modules.perl6.org/new-db-builder: review: https://github.com/perl6/modules.perl6.org/commit/df1f196a15

[15:46] <ely-se> Damian Conway's Game of Life

[15:47] <timotimo> IIUC damian isn't an IRC person

[15:47] <tadzik> ya

[15:47] <tadzik> he responds to emails quite actively though

[15:47] <tadzik> at least that's what I remember when was emailing him like 5 years ago :D

[15:47] <zengargoylew> wondering mostly because he's listed as AUTHOR of S26

[15:47] <tadzik> S26 is quite old fwiw :)

[15:49] <zengargoylew> yeah, hard to tell if parts are still relevant, or so far into future as to be more pipe-dream-ish.

[15:52] *** g4 left
[15:52] *** kjs_ left
[15:59] *** ely-se left
[16:00] *** pippo joined
[16:02] *** kjs_ joined
[16:02] *** xpen_ joined
[16:03] <dalek> modules.perl6.org/new-db-builder: 4cef3fc | (Zoffix Znet)++ | / (2 files):

[16:03] <dalek> modules.perl6.org/new-db-builder: Improve test/pod coverage for ModulesPerl6::Controller::Root to 100%

[16:03] <dalek> modules.perl6.org/new-db-builder: review: https://github.com/perl6/modules.perl6.org/commit/4cef3fc838

[16:04] *** xpen left
[16:07] <dalek> modules.perl6.org/new-db-builder: 8f447b6 | (Zoffix Znet)++ | lib/ModulesPerl6/Model/SiteTips.pm:

[16:07] <dalek> modules.perl6.org/new-db-builder: Additional docs for ModulesPerl6::Model::SiteTips

[16:07] <dalek> modules.perl6.org/new-db-builder: review: https://github.com/perl6/modules.perl6.org/commit/8f447b6079

[16:08] <awwaiid> Hello. Can anyone provide examples of single-quote as a name separator ala kabob case in actual code? I want to advocate for removal of single-quote as an option for this, but am trying to keep an open mind.

[16:08] *** molaf joined
[16:08] <awwaiid> m: my $cat's-meow = "fish" ; say $cat's-meow

[16:08] <camelia> rakudo-moar : OUTPUT«fish␤»

[16:12] *** ZoffixW joined
[16:12] <ZoffixW> awwaiid, wouldn't what you showed be real-world example enough? :)

[16:12] <ZoffixW> my $bob's-password = 's3cr3t';

[16:14] <Juerd> don't { die };

[16:14] <dalek> modules.perl6.org/new-db-builder: 8f82c1c | (Zoffix Znet)++ | t/01-models/03-site-tips.t:

[16:14] <dalek> modules.perl6.org/new-db-builder: Improve test/pod coverage for ModulesPerl6::Model::SiteTips to 100%

[16:14] <dalek> modules.perl6.org/new-db-builder: review: https://github.com/perl6/modules.perl6.org/commit/8f82c1c731

[16:15] <masak> muraiki++ # http://irclog.perlgeek.de/perl6/2015-11-02#i_11471391

[16:15] <masak> (I'm late to the game; backlogging here) :)

[16:16] *** xpen_ left
[16:16] <zengargoylew> class SilentDog is Dog doesn't Bark { ... }

[16:17] <masak> ;)

[16:17] <masak> also, check out https://github.com/trizen/sidef

[16:17] <ZoffixW> masak, yeah, you're pretty late to the party :) That quote actually ended up being the title of the Weekly: https://p6weekly.wordpress.com/2015/11/09/2015-46-production-today/

[16:17] <masak> ZoffixW: that's how I found it, yes. I noticed I had an unread weekly. :)

[16:17] <ZoffixW> Ah heh :)

[16:18] <masak> speaking of which, check out https://github.com/trizen/sidef

[16:18] <masak> I was surprised how complete this language seems.

[16:18] <masak> it might very well be the most complete Perl 6-derived language out there. (Perl 6 is a major influence, but not the only one.)

[16:19] <masak> I'm fascinated as much by the features it copies wholesale as by the features it "distorts" along the way.

[16:19] *** dwarring left
[16:20] *** vendethiel joined
[16:22] * ZoffixW is too burnt out to learn yet another new language :)

[16:22] <ZoffixW> or even "check it out" :)

[16:23] <masak> ok -- I respect that.

[16:23] <masak> I was addressing #perl6 in general, though :)

[16:24] <awwaiid> ok, so "doesn't" interesting

[16:24] <Skarsnik> doesn't eist? x)

[16:24] <Skarsnik> *exist

[16:25] <jnthn> Somebody dropped the regular "what if somebody floods us with LOADS of synthetic codepoints" question in my blog, so there's an answer here if anyone is looking for one at some point: https://6guts.wordpress.com/2015/11/21/what-one-christmas-elf-has-been-up-to/#comment-2252

[16:25] <awwaiid> I guess. I've been working on the docs and this rule kinda feels icky for just a few edge case uses

[16:25] <masak> jnthn++

[16:28] <jnthn> Also, if somebody fancies an afteroon writing a GC patch... ;)

[16:30] <diakopter> (me?)

[16:31] <diakopter> (do I have to wait until afternoon?)

[16:31] *** espadrine left
[16:32] *** espadrine joined
[16:32] *** AlexDaniel joined
[16:33] <masak> m: constant afternoon = "morning"; say afternoon # diakopter: for small values of "afternoon"

[16:33] <camelia> rakudo-moar : OUTPUT«morning␤»

[16:34] *** zakharyas left
[16:36] *** zakharyas joined
[16:38] <El_Che> a call for papers for Perl6 at Oscon in case someone can make it: http://blogs.perl.org/users/shadowcat_mdk/2015/11/oscon-call-for-papers.html

[16:38] *** tokuhiro_ joined
[16:38] <El_Che> "We have a very good chance of getting a main room spot if we talk about Perl6 especially since O’Reilly have been pushing known Perl authors on the idea of a Perl6 book"

[16:39] *** brrt left
[16:41] * geekosaur still needs to put together something sensible about NativeCall vs. shared library APIs :/

[16:42] <ZoffixW> El_Che, I believe CurtisOvidPoe and DrForr are both submitting papers

[16:42] *** tokuhiro_ left
[16:42] *** Actualeyes left
[16:43] <mspo> camel6

[16:44] *** n0tjack joined
[16:45] *** xfix joined
[16:45] *** khw joined
[16:45] <Skarsnik> NC vs shared lib?

[16:46] *** ibo2perl6 joined
[16:46] <El_Che> ZoffixW: thx for the info

[16:49] *** zakharyas left
[16:49] <awwaiid> so nobody else wants to get rid of single-quote as a separator, eh? oh well.

[16:50] <mspo> what is the original justification for it?

[16:50] <ZoffixW> awwaiid, I'm not bothered by it, unless removing it would enable a more useful feature to be implemented.

[16:50] <ZoffixW> mspo, don't { say "know"; } :)

[16:51] <awwaiid> haha

[16:52] <awwaiid> I feel like it is just showing off how awesome the parser is, but could make my code less nice

[16:52] <xenu> awwaiid: perl5 has it too and it's a disaster imho

[16:52] <awwaiid> perl5 has it as an older alternative to :: iirc, which I would only use in obfuscation contests

[16:52] *** molaf_ joined
[16:52] <xenu> yes, but it's still has the same problem

[16:52] <ilmari> at least in perl6 it's a part of the identifier, not a synonym for the package separator

[16:52] <xenu> it's extremely unintuitive

[16:53] <ilmari> and makes syntax highlighting harder

[16:53] <xenu> s/it's/it/

[16:53] <ZoffixW> But the only reason it's unintuitive is because you can't use it in most other langs.

[16:53] <xenu> and makes eye-parsing real hard

[16:53] <ZoffixW> Same argument can be made for "-" in kebab case.

[16:54] *** molaf left
[16:54] <ibo2perl6> I'm experimenting with promises here my example: https://gist.github.com/ibo2go/8287f0d0fee118f63ff5 but using promises slows my script down. 

[16:54] <awwaiid> - is at least a traditional compound-word-separator. single-quote is more of a conjunction'r

[16:54] <xenu> ZoffixW: it's true, but do we really want to be *that* different than the rest? 

[16:54] <xenu> what we will gain?

[16:54] <ilmari> ZoffixW: kebab-case is more widespread in other languages (particularly lisps)

[16:54] <awwaiid> I'm also plenty used ot kabob world from lisp :)

[16:54] <xenu> - makes more sense imho

[16:55] <ilmari> do any other languages use '?

[16:55] <awwaiid> ilmari: no, don't be silly of coures they don't

[16:55] <awwaiid> well

[16:55] <awwaiid> I use it in ocaml as "prime"

[16:55] <awwaiid> like f'(x)

[16:55] * ilmari would have thought it would be a nice wart to shed from perl5

[16:55] *** edehont joined
[16:55] <awwaiid> but you aren't allowed to use it at the end in perl6

[16:55] <xenu> there are features that are made just to be used in japh programs and it's one of them

[16:55] <ilmari> yeah, ' and - have to be between two \w chars

[16:55] <xenu> i hate it

[16:55] *** rurban joined
[16:56] <ilmari> even foo--bar is illegal

[16:56] <ilmari> m: my $foo--bar

[16:56] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/Nzd4cNvH_B␤Two terms in a row␤at /tmp/Nzd4cNvH_B:1␤------> 3my $foo--7⏏5bar␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        s…»

[16:56] <ZoffixW> xenu, I'll put your question on its head: what do we gain by removing support for ' ? :)

[16:58] *** ab6tract joined
[16:58] <ZoffixW> m: my \Δ'Δ = 'What identifier?';   say Δ'Δ

[16:58] <camelia> rakudo-moar : OUTPUT«What identifier?␤»

[16:58] <ab6tract> i would like to second the "kill single quotes in names"

[16:58] <ZoffixW> heh

[16:58] <ZoffixW> ab6tract, what is the reasoning?

[16:58] <ab6tract> it's one of those things that happens so rarely, you forget it exists

[16:59] <ZoffixW> ab6tract, but so does the Δ and any other Unicode char that works for an identifier

[16:59] <xenu> ZoffixW: easier coloring, easier eye parsing, avoiding perl 5 "success" with many obscure unknown features

[16:59] <ugexe> is there a convention behind lib/NativeCall/Test having extension .pm and lib/lib and lib/newline having .pm6?

[16:59] *** zom6 joined
[16:59] <ab6tract> ZoffixW:a  pure, unadulterated sense of foreboding

[16:59] <ab6tract> but it probably won't happen

[16:59] <jnthn> ugexe: No; I'd be happy for them to all become .pm6

[16:59] <xenu> i mean as a die-hard perl coder i have ' hardwired as string operator in my brain

[16:59] <xenu> nothing else

[16:59] <xenu> - is much more tolerable

[17:00] <ZoffixW> xenu, but it is hardwired to be the minus!

[17:00] <ab6tract> it's more just like ... do we really need that? what do we expect people's reactions to be when they learn that?

[17:00] <xenu> apart from being perl programmer i'm also natural language speaker

[17:00] <xenu> and that's what makes - more tolerable

[17:01] <xenu> (and also lisp)

[17:01] *** raiph joined
[17:01] <ab6tract> to me it seems like one of those "ah, there you go making a language full of a bunch of cute corner cases" with the result of distrust to the language

[17:01] <xenu> sounds like c++ to me

[17:01] <xenu> or p5 sadly

[17:01] <ZoffixW> xenu, that's an argument against your position. Apostrophe in words is way common in natural languages.

[17:01] <ab6tract> than "omg i have always wanted to be able to have english style conjugation in my var names!!"

[17:01] <ZoffixW> xenu, more common than a minus, I'd imagine.

[17:02] <xenu> ZoffixW: as a name of something?

[17:02] <xenu> - is just a little bit different than _, and it doesn't cause coloring confusion

[17:02] <xenu> there are lots of simple text editors that don't have real parse

[17:02] <xenu> and will go bonkers on that

[17:02] <xenu> parser*

[17:03] <ab6tract> the bikeshed was painted long ago and probably no one who can authorize would agree

[17:03] <zom6> Can I write this one-liner shorter? :   .say  for |<file1>.IO.lines[*-3 .. *],  |<file2>.IO.lines,  |<file3>.IO.lines[*-5 .. *]

[17:03] <ZoffixW> xenu, in my experience that applies to much of Perl 6. 

[17:03] <xenu> some coloring failures are more tolerable, some less

[17:03] <ab6tract> but if someone were to file a ticket for this, and it was my responsibility to triage, i would definitely put a "NOT A BUG - WON'T FIX"

[17:03] <RabidGravy> except for old Perl hands ' within an identifier is a package separator

[17:03] <ab6tract> on that

[17:03] <xenu> when something is taken as string then it's the worst case possible

[17:04] <RabidGravy> so for that reason I'd prefer it was just not allowed in identifiers

[17:04] <ab6tract> (on a hypothetical ticket asking for single quotes in names)

[17:04] <ugexe> i thought the motto was torture the text highlighter implementor on behalf of the compiler implementor 

[17:04] <ZoffixW> xenu, but how often will you see ' in identifiers that colouring on poorly-made editors will become a problem?

[17:04] <AlexDaniel> has anybody ever seen such ｢'｣ usage in perl6 code?

[17:04] <AlexDaniel> or perhaps used?

[17:04] <ab6tract> ZoffixW: probably almost never! which  is why we don't need

[17:04] <ab6tract> it

[17:04] <xenu> ZoffixW: so if nobody is going to use it frequently then why complicate our lives?

[17:04] <ZoffixW> xenu, again, the same same argument can be made for Unicode chars that are valid in identifiers

[17:04] <ab6tract> AlexDaniel: exactly

[17:05] <ZoffixW> xenu, how are lives complicated?

[17:05] <xenu> by existance of unintuitive corner cases

[17:05] <xenu> also unicode identifiers are different story because they usually can't be confused with

[17:05] <xenu> traditional perl constructs

[17:05] *** hankache left
[17:06] <zengargoylew> my $a, $a's-parent, $b, $b's-parent; ...

[17:06] <ab6tract> ZoffixW: maybe we could argue this the other way

[17:06] <ZoffixW> xenu, ab6tract, let's ditch ζ too then. How often will that be used? Why complicate our lives?

[17:06] <ZoffixW> m: my $ζ = 42; say $ζ

[17:06] <camelia> rakudo-moar : OUTPUT«42␤»

[17:06] <ab6tract> could you explain a single circumstance where they would b e necessary?

[17:06] <ab6tract> no, that's not the point at all ZoffixW 

[17:06] <AlexDaniel> .oO( ban '' and ""! Let's force everybody to use ‘’ and “”! This is so much easier to parse! )

[17:06] <ZoffixW> ab6tract, don't-let-the-user-in();

[17:07] <AlexDaniel> do-not-let-the-user-in();

[17:07] <ZoffixW> ab6tract, well, the case where they provide clarity. Nothing's necessary

[17:07] <ab6tract> completely unconvinvcing

[17:07] <ab6tract> but like i said

[17:07] <xenu> they remove clarity

[17:07] <ab6tract> the shed is painted, and it's your colour

[17:07] <ZoffixW> AlexDaniel, hey, write that as do_not_let_the_user_in() and let's get rid of -. Remove for clarity

[17:07] <geekosaur> of all the things that complicate Haskell for users, I think ' in identifiers is the least of them

[17:07] <CIAvash> this might be a little relevant: https://stackoverflow.com/questions/5673916/apostrophe-in-identifiers-in-haskell

[17:08] <ZoffixW> ab6tract, it's as unconvincing that you're fine with ζ but not with ' :)

[17:08] <ab6tract> ZoffixW: look, underbar and hyphen are not in the same class as single quote

[17:08] <CIAvash> https://stackoverflow.com/questions/10363206/what-does-apostrophe-means-in-haskell

[17:08] <ab6tract> you can't make that argument

[17:08] <AlexDaniel> ZoffixW: yeah, that's an interesing idea…

[17:08] <ZoffixW> ab6tract, sure I can if we're arguing about making a character invalid because it's rarely used and makes syntax highlights difficult :)

[17:09] <ZoffixW> Anyway....

[17:09] * ZoffixW looks at the bikeshed painted in their colour :)

[17:09] <AlexDaniel> m: my \x = 5; my \x' = 0; say x; say x'

[17:09] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/b7ZDQNqNa2␤Redeclaration of symbol x␤at /tmp/b7ZDQNqNa2:1␤------> 3my \x = 5; my \x7⏏5' = 0; say x; say x'␤    expecting any of:␤        new term to be defined␤»

[17:09] <ab6tract> no it is not. one is a unicode character that represents a number. the other is a punctuation character (generally disallowed in names)

[17:09] <AlexDaniel> hm, what's wrong with this?

[17:09] <ZoffixW> AlexDaniel, you can't have ' as last char

[17:09] <ab6tract> yay! edge case for the edge case!

[17:09] <AlexDaniel> ZoffixW: bummer

[17:10] *** ConSi joined
[17:10] <ab6tract> but of course you can write a postfix op using it

[17:10] <xenu> ZoffixW: do you *really* don't see difference between random unicode chars and '?

[17:10] <AlexDaniel> xenu: because ' is not a random unicode char, perhaps?

[17:11] <ZoffixW> ab6tract, disallowed? D'Juan who lives in Coeur d'Alene, ID

[17:11] <ZoffixW> xenu, not in the context of "it's rarely used and makes eye parsing confusing"

[17:12] <ZoffixW> ab6tract, moreover, it's not only names. It's actions too, since I presume you can have apostrophes in method/sub names. 

[17:12] *** zacts left
[17:12] * ZoffixW is tired of discussion

[17:12] *** ZoffixW left
[17:12] <xenu> ZoffixW: how is character you used as example before complicating parsing?

[17:12] <AlexDaniel> m: my \x = 2; my \y = 5; say x+y;

[17:12] <camelia> rakudo-moar : OUTPUT«7␤»

[17:12] <AlexDaniel> m: my \x = 2; my \y = 5; say x-y;

[17:12] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/HJtG2Q03et␤Undeclared routine:␤    x-y used at line 1␤␤»

[17:13] <AlexDaniel> :/

[17:13] <xenu> well, to each his own, i guess 

[17:13] <Skarsnik> lol

[17:14] <SmokeMachine_> Hi there! I was playing with perl6 and tried to implement "optional types" (like swift) and I'd like to know if is there a better way to do it:

[17:14] *** ir2ivps4 joined
[17:14] *** ab6tract left
[17:14] <Skarsnik> optionnal types?

[17:14] <SmokeMachine_> https://www.irccloud.com/pastebin/TY9qyRud/

[17:14] *** ConSi left
[17:16] <SmokeMachine_> Skarsnik: yes, like this: http://www.appcoda.com/beginners-guide-optionals-swift/

[17:16] *** espadrine left
[17:17] <AlexDaniel> SmokeMachine_: oh, you mean :D for definedness?

[17:17] <AlexDaniel> SmokeMachine_: or maybe I got that wrong

[17:17] <SmokeMachine_> AlexDaniel: yes, I think that's it!

[17:18] <Skarsnik> I don't get the use of it. everything is 'optionnal' by default perl6 never force you to assign something to a variable x)

[17:18] <muraiki> if I create a IO::Notification.watch-path() but don't assign it to a variable, is it reasonable to expect that it will never be garbage collected?

[17:18] *** abraxxa left
[17:19] <muraiki> I mean, I've had these watchers continue to exist for some time... but sometimes it's as if they just stop watching

[17:19] <SmokeMachine_> Skarsnik: but I'll have to (in my example): if $test != Nil and my $p = $test.x {...} (ok, Point was not a good example...)

[17:21] <AlexDaniel> m: my Int:D $x = 25; $x = Nil; say $x

[17:21] <camelia> rakudo-moar : OUTPUT«Method 'shortname' not found for invocant of class 'Perl6::Metamodel::DefiniteHOW'␤  in block <unit> at /tmp/8AgN48WvXf:1␤␤»

[17:21] <jnthn> muraiki: I don't think the supply would ever get GC'd, since it will be kept alive by the async event loop wanting to push new notifications

[17:21] <AlexDaniel> m: my Int $x = 25; $x = Nil; say $x

[17:21] <camelia> rakudo-moar : OUTPUT«(Int)␤»

[17:21] <AlexDaniel> what's up with this error message?

[17:21] <SmokeMachine_> Skarsnik: instead of ($test != Nil and my $p = $test.x) I can only use (my $p = $test?.x)

[17:21] <awwaiid> I'd be more ok with ' if it was allowed as the last char (like digits)

[17:21] <jnthn> muraiki: So I'd suspect something other than GC is wrong

[17:22] <muraiki> jnthn: thanks. I'm having a heck of a time figuring out why my supplies which normally work stop working... I don't think any exceptions are being thrown and not-caught, because the program should terminate in that case, right?

[17:22] <jnthn> muraiki: How easily can you reproduce the hang?

[17:22] <jnthn> Is it just a case of "have a long-running program watching files"?

[17:22] <muraiki> jnthn: it generally seems like it starts to happen once the process has been running for a few days, but earlier today it happened immediately

[17:22] <muraiki> yeah

[17:22] <cognominal> m: class A { has $.hi = 'hi' }; A.bless(:hi<hello>).hi.say; A.new.hi.say

[17:22] <camelia> rakudo-moar : OUTPUT«hello␤hi␤»

[17:22] <jnthn> muraiki: OK, I may be able to recreate it

[17:23] <muraiki> jnthn: wow, thanks!

[17:23] <Skarsnik> SmokeMachine_, I think there is an operator that affect if something is defined?

[17:23] <SmokeMachine_> AlexDaniel: nothing is wrong, but I'd like to? $x?.say just do nothing...

[17:23] <arnsholt> jnthn: I've got a hang with raw Threads that looks like it happens 100% of the time, if that might be useful

[17:23] <cognominal> SmokeMachine_, A cursory reading make me think optional are attribute with a default value

[17:23] <awwaiid> alright. well thank y'all for arguing my points for me. Meta question: how do I bring up questions like "should we ditch single-quote separator" in a constructive way that can be considered by like TimToady?

[17:23] <AlexDaniel> SmokeMachine_: so you don't want it to fail, you just want it to do nothing?

[17:23] <arnsholt> But with NativeCall, on the downside

[17:23] <jnthn> arnsholt: Yes

[17:23] <SmokeMachine_> yes...

[17:23] <SmokeMachine_> AlexDaniel: ^^

[17:24] <arnsholt> jnthn: I'll try to write up a minimal case this evening in that case!

[17:24] <jnthn> There's one reported Moar issue where after a while it seems to get into a hang in the GC; it may or may not be related.

[17:24] <jnthn> arnsholt: Thanks

[17:24] <awwaiid> (the hope being that while yes, it was considered and explicitly added long ago, maybe 10 years later minds have changed)

[17:24] <arnsholt> jnthn: Yeah, when I loaded it up in gdb and interrupted it when it hanged I think it was in the GC

[17:24] <AlexDaniel> SmokeMachine_: let's see

[17:24] <jnthn> awwaiid: I think I was around when - and ' became supported, so it will have been less than 10 years. :-)

[17:24] <SmokeMachine_> AlexDaniel: if I have chained methods calls with a ?, it will do nothing after the ? if it's value is Nil...

[17:25] <AlexDaniel> SmokeMachine_: yeah, okay, now it's clear!

[17:25] <cognominal> SmokeMachine_, sorry, seems more than that :(

[17:25] <jnthn> awwaiid: I'm quite sure most of the counter-arguments around syntax highlighters and similar were considered by TimToady++

[17:26] <jnthn> arnsholt: OK. If we're lucky, it may be the same thing muraiki runs into, except faster to reproduce. :)

[17:26] <SmokeMachine_> AlexDaniel: my sample code isn't 100%... but its going that way...

[17:26] <muraiki> woo hoo

[17:26] <SmokeMachine_> cognominal: sorry, I didn't get it...

[17:26] <zengargoylew> wouldn't syntax highlighting just boil down to... use Perl 6 to do the highlighting! :)

[17:27] <dalek> nqp: 82e4fef | jnthn++ | tools/build/MOAR_REVISION:

[17:27] <dalek> nqp: Get MoarVM with nqp::ctx caller capturing.

[17:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/82e4fefdc3

[17:27] <SmokeMachine_> zengargoylew: sorry, was that about my snippet?

[17:28] <zengargoylew> SmokeMachine_: no that's about the ' in identifiers.

[17:28] <Skarsnik> zengargoyle, enjoy 0.1 fps syntax hightlighting x)

[17:29] <arnsholt> jnthn: Definitely. What's the Moar issue number? Then I'll just attach my testcase there

[17:29] <zengargoylew> *cough* seems syntax highlighting already gets that slow sometimes...

[17:29] <cognominal> SmokeMachine_,   is supposed  $x?.say    to mean something like  $x ?? $x.say !! Nil

[17:29] <dalek> rakudo/nom: eb9421b | jnthn++ | tools/build/NQP_REVISION:

[17:29] <dalek> rakudo/nom: Bump NQP_REVISION to get updated Moar.

[17:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb9421b434

[17:29] <dalek> rakudo/nom: bedf2a7 | jnthn++ | src/core/ (2 files):

[17:29] <dalek> rakudo/nom: Code in start blocks see dynamics of starter.

[17:29] <dalek> rakudo/nom: 

[17:29] <dalek> rakudo/nom: So `my $*E = 42; say await start $*E;` now gives 42, not an exception.

[17:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bedf2a7073

[17:30] <dalek> roast: b1b91b8 | jnthn++ | S17-promise/start.t:

[17:30] <dalek> roast: Test for RT #125196.

[17:30] <dalek> roast: review: https://github.com/perl6/roast/commit/b1b91b8e29

[17:30] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125196

[17:30] <SmokeMachine_> cognominal: yes, something like that!

[17:30] <cognominal> SmokeMachine_, my first answer was irrelevant, forget it.

[17:30] <zengargoylew> maybe a laxer grammar with no need for much by way of actions plus an async capable editor ...

[17:31] <AlexDaniel> SmokeMachine_: that's an interesting question, actually. I'm trying to find a way to do that with custom postfix perhaps

[17:31] <cognominal> SmokeMachine_, I think this conditionnal chaining is lacking from Perl 6

[17:31] <AlexDaniel> cognominal: what if we define it?

[17:31] <SmokeMachine_> cognominal: but it can be bigger: $ad?.buyer.name?.last_name for example

[17:31] <cognominal> SmokeMachine_, to bad because it is used with sucess in many languages

[17:31] *** tokuhiro_ joined
[17:32] <SmokeMachine_> AlexDaniel: my snippet just do that... I use 2 ? postfixes...

[17:32] <cognominal> m: hi.?say  # this is different

[17:32] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/ujXjI_J0RI␤Undeclared routine:␤    hi used at line 1␤␤»

[17:32] <zengargoylew> m: my $x; $x andthen .say;

[17:32] <camelia> rakudo-moar : ( no output )

[17:32] <zengargoylew> m: my $x = 42; $x andthen .say;

[17:32] <camelia> rakudo-moar : OUTPUT«42␤»

[17:33] <SmokeMachine_> zengargoylew: that looks like what I want...

[17:33] <AlexDaniel> zengargoylew: right?

[17:34] <AlexDaniel> s/?/!

[17:34] <cognominal> andthen is too verbose :(

[17:34] <zengargoylew> there

[17:34] <cognominal> m: 'hi'.?say  # this is different

[17:34] <camelia> rakudo-moar : OUTPUT«hi␤»

[17:35] <zengargoylew> doh, there's andthen and orelse, don't know if there's operatorish versions.

[17:35] <cognominal> this one test the existence of the method, not the definedmess of the invocant. I find it less useful

[17:35] <cognominal> ... compare to andhten, we don't huffmanize here

[17:35] <zengargoylew> but a Nil wouldn't have the method...

[17:35] *** rurban left
[17:36] <cognominal> m: 'hi'.?dit-le

[17:36] <camelia> rakudo-moar : ( no output )

[17:36] *** tokuhiro_ left
[17:36] <cognominal> m: say 'hi'.?dit-le.perl

[17:36] <camelia> rakudo-moar : OUTPUT«Nil␤»

[17:36] <zengargoylew> so close

[17:36] <tony-o> jnthn++ #RT125196

[17:37] *** n0tjack left
[17:38] *** n0tjack joined
[17:42] *** jme- joined
[17:43] <ilmari> would it be possible to write a postfix operator that inteprets xⁿ as x ** n for all sequences n of superscript digits?

[17:43] <ilmari> or would that require a slang?

[17:43] <AlexDaniel> ilmari: oh, there is a clog for you!

[17:43] <AlexDaniel> let me find it

[17:43] <ilmari> hardcoding it for any particular sequence is easy

[17:43] <jnthn> ilmari: Think it'd need a slang

[17:43] *** jme- left
[17:43] <psch> ilmari: it needs a slang or macro.  categoricals can only be defined with stringy bits

[17:43] <ilmari> m: postfix:<¹²> (Num $x) { $x ** 12 }; say 2¹²

[17:43] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/enQTsCaSiF␤Two terms in a row␤at /tmp/enQTsCaSiF:1␤------> 3postfix:<¹²> (Num7⏏5 $x) { $x ** 12 }; say 2¹²␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤   …»

[17:44] <ilmari> m: sub postfix:<¹²> (Num $x) { $x ** 12 }; say 2¹²

[17:44] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/pe9EoCirUY␤Calling postfix:<¹²>(Int) will never work with declared signature (Num $x)␤at /tmp/pe9EoCirUY:1␤------> 3ostfix:<¹²> (Num $x) { $x ** 12 }; say 27⏏5¹²␤»

[17:44] <ilmari> m: sub postfix:<¹²> (Numeric $x) { $x ** 12 }; say 2¹²

[17:44] <camelia> rakudo-moar : OUTPUT«4096␤»

[17:45] <ilmari> thanks to LTM that works even if ther is a postfix:<¹> as well

[17:45] <AlexDaniel> ilmari: http://irclog.perlgeek.de/perl6/2015-11-20#i_11575591

[17:46] *** jme` joined
[17:46] <n0tjack> m: sub postfix:<¹> (Numeric $x) {$x ** 1}; sub postfix:<²> (Numeric $x) {$x ** 2};  sub postfix:<¹²> (Numeric $x) { $x ** 12 }; say 2¹²;

[17:46] *** dha joined
[17:46] <camelia> rakudo-moar : OUTPUT«4096␤»

[17:46] <n0tjack> interesting

[17:46] <n0tjack> m: sub postfix:<¹> (Numeric $x) {$x ** 1}; sub postfix:<²> (Numeric $x) {$x ** 2};  sub postfix:<¹²> (Numeric $x) { $x ** 12 }; say 2¹ ²;

[17:46] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/UIKxfBHH_S␤Confused␤at /tmp/UIKxfBHH_S:1␤------> 3x:<¹²> (Numeric $x) { $x ** 12 }; say 2¹7⏏5 ²;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement e…»

[17:47] <psch> m: say  1+ +

[17:47] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/BzYadKIm54␤Prefix + requires an argument, but no valid term found␤at /tmp/BzYadKIm54:1␤------> 3say  1+ +7⏏5<EOL>␤    expecting any of:␤        prefix␤»

[17:50] <awwaiid> jnthn: yeah. I'm probably barking up the wrong tree

[17:50] *** black_ant joined
[17:50] <psch> SmokeMachine_: your ?. dotty op would stop invoking the next method if it found a Nil on the LHS i gather?

[17:51] <zom6> Can I write this one-liner shorter??->   .say  for |<file1>.IO.lines[*-3 .. *],  |<file2>.IO.lines,  |<file3>.IO.lines[*-5 .. *]

[17:51] <AlexDaniel> psch: yes

[17:51] <pink_mist> isn't that what a Failure is for?

[17:52] *** black_ant left
[17:53] <psch> i'd probably do that with a FALLBACK on Nil that returns Nil and a scoped postfix which is &infix:<//>.assuming(*, Nil)

[17:53] <jnthn> zom6: Don't immediately see a way; you could write "for flat" instead of the |s

[17:53] *** sprocket left
[17:54] <AlexDaniel> psch: yeah, but andthen already does that

[17:54] <psch> m: use MONKEY-TYPING; augment Nil { method FALLBACK { Nil } }; Nil.^compose; my &postfix:<?'> = &infix:<//>.assuming(*, Nil); class A { method foo { Nil }; method bar { "bar" } }; A.new.foo?'.say; A.new.bar?'.say

[17:54] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/44HwEiMvUT␤Malformed augment␤at /tmp/44HwEiMvUT:1␤------> 3use MONKEY-TYPING; augment Nil7⏏5 { method FALLBACK { Nil } }; Nil.^compo␤»

[17:54] <psch> eh

[17:54] <psch> oh, Nil has a FALLBACK, is that already Nil? :S

[17:55] <psch> yeah, it is..

[17:55] <psch> m: my &postfix:<?'> = &infix:<//>.assuming(*, Nil); class A { method foo { Nil }; method bar { "bar" } }; A.new.foo?'.say; A.new.bar?'.say

[17:55] <camelia> rakudo-moar : OUTPUT«(Any)␤bar␤»

[17:55] <psch> .say is obviously treacherous here

[17:55] <jnthn> zom6: Unless you do something like .say for flat (<file1 file2 file3> Z (*-3, *, *-5).map({ $^f.IO.lines[$^s .. *] }) or so

[17:56] <psch> AlexDaniel: yeah, andthen does that, but as you said huffmanizes longer

[17:56] <jnthn> Didn't count the chars to see if it's actually shorter; it's just a bit less repetitive :)

[17:56] <AlexDaniel> psch: somebody else said that, I think. But hey, is there any way to make a custom operator that works like andthen?

[17:56] <jnthn> dinner; bbl &

[17:56] *** kjs_ left
[17:57] <AlexDaniel> psch: andthen simply sets $_ as far as I can see

[17:57] <psch> AlexDaniel: well, &lhs andthen &rhs is kinda like with &lhs { &rhs }

[17:57] <psch> AlexDaniel: the problem is, with a custom operator you'd have to leave the statement early

[17:57] <psch> AlexDaniel: i think that's macro-space

[17:58] <psch> well, unless the example postfix:<?'> up there fits your use-case...

[17:58] *** sprocket joined
[17:59] <psch> it probably could be postfix:<?>, i don't think there's anything there yet...

[17:59] *** FROGGS joined
[18:00] *** rindolf joined
[18:02] *** dakkar left
[18:02] <AlexDaniel> m: Any notandthen .say;

[18:02] <camelia> rakudo-moar : OUTPUT«(Any)␤»

[18:03] <AlexDaniel> notandthen!

[18:03] <diakopter> noanthe for short

[18:04] <FROGGS> we could call the short form 'nat' :o)

[18:05] <timotimo> alternativelythen?

[18:06] <AlexDaniel> FROGGS: aha, and we can call andthen ‘?’

[18:06] <zengargoylew> [&andthen] $x, .foo, .bar, .baz, ... :S

[18:06] *** ZoffixW joined
[18:06] <ZoffixW> m: https://gist.github.com/zoffixznet/87ad068ee92e934ec71c

[18:06] *** P6 joined
[18:06] <P6> Now is Instant:1448302047.207318

[18:06] <ZoffixW> Haw

[18:07] *** P6 left
[18:07] <camelia> rakudo-moar : OUTPUT«(timeout):orwell.freenode.net NOTICE * :*** Looking up your hostname...

[18:07] <diakopter> erm lol

[18:07] <AlexDaniel> haha

[18:07] <ZoffixW> How come it doesn't re-announce the instant? I'm setting a new promise here: https://gist.github.com/zoffixznet/87ad068ee92e934ec71c#file-irc-test-p6-L11

[18:08] <diakopter> maybe timed out just before it

[18:08] <ZoffixW> No, I don't get it rethrown locally either

[18:08] <ZoffixW> Even if I wait

[18:08] <ZoffixW> re-reacted to I guess I should say

[18:09] <diakopter> maybe the socket gets closed first

[18:09] <TimToady> so...why do the drains always plug up right about at Thanksgiving?...at least it did it before the hordes arrive this time...

[18:09] <yoleaux> 22 Nov 2015 08:37Z <hankache> TimToady: re - and ' noted. thank you for going through the doc

[18:09] *** pdcawley left
[18:10] <diakopter> ZoffixW: oh, you missed a say

[18:10] <ZoffixW> diakopter, where?

[18:10] <TimToady> at least I can backlog while waiting for the drain cleaner to (probably not) work

[18:11] <diakopter> well you didn't bind the whenever to the new timer object

[18:11] <ZoffixW> Hmmm

[18:11] <diakopter> I guess you'd have to assign to a different variable?

[18:11] <diakopter> I dunno

[18:11] <TimToady> going to borrow a snake just in case &

[18:12] <ZoffixW> I want to react every 5 seconds (at least for this test). 

[18:12] <diakopter> well I don't think assigning to teh same $timer variable will work

[18:13] * ZoffixW looks at the docs for Supply

[18:14] <diakopter> ZoffixW: do .then on the same $timer

[18:14] *** andreoss left
[18:14] *** sprocket left
[18:15] <SmokeMachine_> psch: I had implemented just the ?, but if implement the ?. it shouldn't call the next method if its Nil...

[18:16] *** P6 joined
[18:16] <P6> Now is Instant:1448302902.110440

[18:16] *** P6 left
[18:16] <ZoffixW> Ooops. Wrong server :P

[18:16] <FROGGS> *g*

[18:16] <diakopter> lol that was me I think

[18:17] <ZoffixW> No, it was me :)

[18:17] *** Oatmeal joined
[18:17] <ZoffixW> diakopter, that didn't do anything. I think .then just returns a new promise

[18:17] <arnsholt> jnthn: https://gist.github.com/arnsholt/26d4e5fed6062917c643 # Reproduces the hang issue for me every time. May of course be caused by NativeCall shenanigans though

[18:17] *** P6 joined
[18:17] <P6>  diakopter Now is Instant:1448302703.104126

[18:18] <ZoffixW> Now that is someone else :P

[18:18] *** P6 left
[18:18] <diakopter> XD

[18:18] <diakopter> we're gonna get that IP banned

[18:18] <diakopter> :o

[18:19] <ZoffixW> That's your IP lol :)

[18:20] <ZoffixW> I think I found the right-sized hammer for this: http://docs.perl6.org/type/Supply#method_interval

[18:20] *** diakopter___ joined
[18:21] <diakopter___> No, I was privmsg camelia

[18:21] <ZoffixW> Ah

[18:23] *** AlexDaniel left
[18:26] *** jme` left
[18:27] <ZoffixW> m: https://gist.github.com/zoffixznet/0975882676a427bcb35d

[18:27] <ZoffixW> This one does the trick methinks

[18:27] *** P6 joined
[18:27] <camelia> rakudo-moar : OUTPUT«(timeout):rajaniemi.freenode.net NOTICE * :*** Looking up your hostname...

[18:27] *** P6 left
[18:28] <ZoffixW> hehe. Well, it works locally :) I'm guessing Freenode was just slow to send the :End of NAMES list message

[18:28] *** domidumont left
[18:28] *** jme` joined
[18:29] *** jme` left
[18:30] *** jme` joined
[18:34] *** diakopter___ left
[18:34] <dalek> perl6-roast-data: d51825a | coke++ | / (9 files):

[18:34] <dalek> perl6-roast-data: today (automated commit)

[18:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d51825a128

[18:35] <[Coke]> .botsnack

[18:35] <yoleaux> 22 Nov 2015 22:52Z <bartolin> [Coke]: the spectest for JVM should be nearly clean by now. the three failures in S05-mass/properties-general.t (596-598) seem to happen because we test unicode characters not supported by Java 7 (the tests pass with JDK 1.8)

[18:35] <synbot6> om nom nom

[18:35] <yoleaux> :D

[18:35] *** xiaomiao left
[18:35] <[Coke]> bartolin: thanks. We should probably consider coming up with a jvm fudge that works based on the java version.

[18:36] *** black_ant joined
[18:36] *** xiaomiao joined
[18:36] *** ZoffixW left
[18:36] *** black_ant left
[18:42] <dalek> Heuristic branch merge: pushed 114 commits to roast/curli by niner

[18:43] *** kjs_ joined
[18:46] <SmokeMachine_> psch: I did return with self but False because I can $blah?.ble.bli and can't execute able neither bli

[18:46] *** [particle] left
[18:51] *** polettix left
[18:52] <masak> people who kvetch in the backlog about the apostrophe in identifier names guess right; that won't change :)

[18:53] <masak> also, "what might [newcomers] think" and "think of [other parsers]!" also count as non-arguments agains the backdrop of Perl 6 culture

[18:53] <masak> against*

[18:53] <masak> I know, I've been on that (losing) side occasionally :)

[18:54] <FROGGS> nine: how can I tell that "use lib 'foo'" is about a CULRI or a CULRF?

[18:54] <cognominal> $that-won't-change++

[18:54] *** domidumont joined
[18:56] <FROGGS> nine: use lib "inst:foo" ?

[18:57] <jdv79> can't there be an option with an adverb or something and default it maybe

[18:57] <FROGGS> nine: nvm, use lib "inst#foo" does the trick

[18:58] <jdv79> the weird CUR string formats are weird - yeah, those.  is it inst# and file#?

[18:58] <SmokeMachine_> Does this make sense? why is it saying that does not exists Point? https://www.irccloud.com/pastebin/uYLW4MdL/

[18:58] *** hankache joined
[19:00] <FROGGS> jdv79: I think I'm also in favour of an adverb, but we'll see what happens

[19:08] <dalek> rakudo/curli: efd685c | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[19:08] <dalek> rakudo/curli: Add repo-id to CompUnit

[19:08] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/efd685c8de

[19:08] <SmokeMachine_> m: sub f{return Int}; my f $i = 42; $i.say

[19:08] <camelia> rakudo-moar : OUTPUT«5===SORRY!5===␤Type 'f' is not declared␤at /tmp/vhIVoyFnEb:1␤------> 3sub f{return Int}; my f7⏏5 $i = 42; $i.say␤Malformed my␤at /tmp/vhIVoyFnEb:1␤------> 3sub f{return Int}; my7⏏5 f $i = 42; $i.say␤␤»

[19:09] <SmokeMachine_> m: sub f{return Int}; my f() $i = 42; $i.say

[19:09] <camelia> rakudo-moar : OUTPUT«5===SORRY!5===␤Type 'f' is not declared␤at /tmp/xPu4fXBxDR:1␤------> 3sub f{return Int}; my f7⏏5() $i = 42; $i.say␤Malformed my␤at /tmp/xPu4fXBxDR:1␤------> 3sub f{return Int}; my7⏏5 f() $i = 42; $i.say␤␤»

[19:09] <SmokeMachine_> is there any way to do that?

[19:09] <SmokeMachine_> m: sub f(--> Int:U){return Int}; my f() $i = 42; $i.say

[19:09] <camelia> rakudo-moar : OUTPUT«5===SORRY!5===␤Type 'f' is not declared␤at /tmp/iHb4hSDQer:1␤------> 3sub f(--> Int:U){return Int}; my f7⏏5() $i = 42; $i.say␤Malformed my␤at /tmp/iHb4hSDQer:1␤------> 3sub f(--> Int:U){return Int}; my7⏏5 f() $i = 42; $i.say␤␤»

[19:10] <RabidGravy> m: constant f = Int; my f $i = 42;

[19:10] <camelia> rakudo-moar : ( no output )

[19:11] <FROGGS> nine: I just started writing tests for curli

[19:12] <SmokeMachine_> so, there's no way to my Int? $bla = 42;  works, right?

[19:13] <SmokeMachine_> only: my $bla = Point?.new()

[19:14] *** AlexDaniel joined
[19:15] <nine> FROGGS: yeah :)

[19:16] <timotimo> nine: want to give me a little "executive summary" for the curli branch that i can put (verbatim or reworded) into the weekly?

[19:18] *** ibo2perl6 left
[19:20] *** zom6 left
[19:21] *** CIAvash left
[19:21] <nine> The curli branch will bring robust precompilation-management with automatic precompilation. In addition we will get full support for :auth and :ver adverbs when loading module while keeping startup time independent of the number of installed dists.

[19:22] *** leont joined
[19:22] <dalek> rakudo/curli: c8eaab3 | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[19:22] <dalek> rakudo/curli: Rename CompUnit.name to short-name to match DependencySpecification

[19:22] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/c8eaab3609

[19:23] <dalek> rakudo/curli: 21cd2c8 | (Stefan Seifert)++ | tools/build/Makefile- (2 files):

[19:23] <dalek> rakudo/curli: Remove manual precompilation from the build process.

[19:23] <dalek> rakudo/curli: 

[19:23] <dalek> rakudo/curli: This is handled by installing the CORE dist containing those modules.

[19:23] <dalek> rakudo/curli: This rids us of the sha hash output during the build.

[19:23] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/21cd2c85a5

[19:25] *** zakharyas joined
[19:25] <hankache> evening everyone

[19:26] <vendethiel> o/

[19:26] <masak> hankache: ahoy

[19:26] *** diakopter___ joined
[19:27] *** diakopter___ left
[19:27] <masak> funny: I don't recall tactically type-annotating parameters and attributes before in order to trigger type errors earlier (as part of a refactor)

[19:27] <masak> doin' it now.

[19:27] <zengargoylew> nine:  can the :auth and :ver be picked up from META6.json or only from inside the module itself?

[19:27] <hankache> is this statement right? Perl 6 belongs to the C-family languages.

[19:27] <masak> hankache: syntactically, yes.

[19:28] <masak> hankache: but it's also right to say that both Perl 6 and C belong to the Algol-family of languages, syntactically.

[19:28] <Skarsnik> I was wondering, would it be a good idea for modules that use an external lib (like a binding) to put this information in the Meta file? Could probably make distrib package life easier and allow panda/whatever to display information for the admin that it will need something else

[19:28] * geekosaur considers Algol more of a superfamily

[19:28] <hankache> masak thanks. i wrote it and was having 2nd thoughts

[19:28] <nine> zengargoylew: they are in fact picked up from the META6.json only for now

[19:29] *** eliasr joined
[19:29] <hankache> what is algol ?! ;)

[19:29] *** [particle] joined
[19:30] <masak> hankache: https://en.wikipedia.org/wiki/ALGOL

[19:30] *** diakopter___ joined
[19:30] <nine> zengargoylew: and I don't see how they could be otherwise. We're dealing with CompUnits here, which means ~~ file. A file may contain 0 or more packages (modules, roles, grammars or classes or ...) with different auth and versions

[19:30] *** zakharyas left
[19:30] <geekosaur> a language that a number of current languages could learn from (ob http://cowlark.com/2009-11-15-go/)

[19:30] <masak> hankache: it doesn't have '{' and '}' like C does, it has 'begin' and 'end'. but the general ideal (of code as nested blocks) is there, and C is very much based on it.

[19:31] <zengargoylew> cool i can see that being problematic, multiple things in a file..

[19:31] <masak> hankache: if you find a timeline with which languages influenced which ones, Algol is right there near the root of an influential subtree containing both Perl and C; that's my point.

[19:32] <AlexDaniel> “A special kind of type is Any . Every type is a subtype of Any . This is also true for the builtin type object” – does not sound very pythonic, right? :)

[19:33] <TimToady> Mu is not a subtype of Any

[19:33] *** edehont left
[19:33] *** tokuhiro_ joined
[19:33] <TimToady> nor is Junction

[19:34] <hankache> masak thanks

[19:34] <AlexDaniel> (from https://www.python.org/dev/peps/pep-0484/)

[19:34] <TimToady> ah

[19:35] * TimToady still distracted by drains...

[19:35] *** [particle] left
[19:37] *** edehont joined
[19:37] <AlexDaniel> TimToady: by the way, what about qx// thing? I was a bit busy so did not pay any attention. Any progress?

[19:37] <TimToady> nobody's done anything with it yet

[19:37] <hankache> A special kind of type is Any . Every type is a subtype of Any . This is also true for the builtin type object . However, to the static type checker these are completely different.

[19:38] <hankache> ^^ The dark side awakens :D

[19:38] *** tokuhiro_ left
[19:39] *** yubimusubi left
[19:40] * timotimo will have dinner, then later do the weekly

[19:40] <AlexDaniel> TimToady: okay, but to me it is a bit unclear what should be done. You said that qx// should use run() underneath, yet the details are missing (e.g. what if I want to pipe something?). So, in other words, if I really want to get this thing moving, what should I do?

[19:40] <timotimo> nine: i was thinking more along the lines of "how far along is it, what's missing, could it potentially be merged this week?" rather than "what does it do" :)

[19:40] <timotimo> but yeah, i worded none of that properly

[19:41] *** Possum joined
[19:41] *** edehont left
[19:45] <nine> Ok, how was that phrased? We've gotten the first 80 % done and are well into the second 80 % ;)

[19:45] <AlexDaniel> nine: the third part is also important

[19:46] <AlexDaniel> “unless there are another 80%”

[19:46] <FROGGS> AlexDaniel: is that the one after the rewrite? :o)

[19:46] <AlexDaniel> FROGGS: not necessarily

[19:47] *** diakopter___ left
[19:47] <nine> timotimo: The implementation is fast approaching mergability. Now that FROGGS++ has started on the tests what's most missing is probably some review and testing.

[19:48] <nine> Not everything that's in jnthn++'s gist is implemented, like $?REPO, but we can add that after the merge as well.

[19:49] <FROGGS> nine: btw, I think CURLI.install is still using the old api

[19:49] <FROGGS> or rather exposing the old api

[19:50] <nine> FROGGS: It's actually CURI now ;) But yes, the install method still has the same signature. Should fix that soon.

[19:50] <FROGGS> ohh, CURI, I see :o)

[19:51] <nine> We also still need to find a new home for what's left in CompUnitRepo.pm

[19:51] <FROGGS> I can do the install method change

[19:52] <nine> That'd be great :)

[19:52] <nine> Should simplify install's code somewhat

[19:54] <dalek> rakudo/curli: 3ae40a9 | (Stefan Seifert)++ | src/core/CompUnit (2 files):

[19:54] <dalek> rakudo/curli: Add .version and .auth attributes to CompUnit

[19:54] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/3ae40a9490

[19:54] *** diakopter___ joined
[20:01] <tadzik> hey, #perl6!

[20:01] <dalek> rakudo/curli: 91533ff | (Stefan Seifert)++ | src/core/CompUnit (2 files):

[20:01] <dalek> rakudo/curli: Add a $.distribution attribute to CompUnit

[20:01] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/91533ff185

[20:01] <tadzik> Look what came in the mail today

[20:01] <tadzik> http://i.imgur.com/UhiM6Rs.jpg

[20:01] *** zakharyas joined
[20:01] *** sprocket joined
[20:02] <n0tjack> does czesc mean "hello"?

[20:02] <n0tjack> or "want some"?

[20:03] <nine> tadzik: cooool!

[20:05] <hankache> tadzik: nice!

[20:05] <lizmat> good *, #perl6!

[20:05] <FROGGS> tadzik: cool!

[20:05] <FROGGS> hi lizmat 

[20:05] <lizmat> FROGGS o/

[20:05] <tadzik> n0tjack: that's "hello", yes

[20:05] <tadzik> and the title is funny 'cos it rhymes :)

[20:05] * lizmat is recovering from vacation and jetlag

[20:06] *** petercommand left
[20:06] <FROGGS> szzszsszs Perl sszzszszzs

[20:06] *** mtj_ left
[20:06] <FROGGS> sure it rhymes :P

[20:06] <masak> m: class X::Test is Exception { method message { $.x } }; die X::Test.new

[20:06] <camelia> rakudo-moar : OUTPUT«X::Test exception produced no message␤  in block <unit> at /tmp/SEE2J2wy7K:1␤␤»

[20:06] <tadzik> :D

[20:06] <masak> ^^ is a bit suboptimal

[20:06] *** sunnavy_ left
[20:06] <tadzik> 6 is "sześć"

[20:07] <tadzik> so it even looks like it rhymes :P

[20:07] <FROGGS> aye

[20:07] <n0tjack> heh

[20:07] <masak> if the message method fails for whatever reason, the exception "produced no message"

[20:09] <masak> tadzik++ sergot++ # article

[20:10] *** zakharyas left
[20:11] *** geraud joined
[20:11] *** diakopter___ left
[20:11] <masak> m: class X::Test is Exception { method message { $.x } }; X::Test.new.message

[20:11] <camelia> rakudo-moar : OUTPUT«Method 'x' not found for invocant of class 'X::Test'␤  in method message at /tmp/wg7Xpc6XLU:1␤  in block <unit> at /tmp/wg7Xpc6XLU:1␤␤»

[20:13] <AlexDaniel> m: sub foo (--> Int, Str) { }

[20:13] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/TAn1QzdmUS␤Type 'Int' is not declared. Did you mean 'int'?␤at /tmp/TAn1QzdmUS:1␤------> 3sub foo (--> Int7⏏5, Str) { }␤»

[20:13] <dalek> rakudo/curli: 13d37b8 | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[20:13] <dalek> rakudo/curli: Add $.precompiled attribute to CompUnit

[20:13] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/13d37b8ae1

[20:13] <nine> Ok, CompUnit is now complete

[20:15] *** darutoko left
[20:17] <RabidGravy> harr!

[20:19] *** aindilis left
[20:19] *** rurban joined
[20:20] <FROGGS> nine++

[20:21] <stmuk_> . o ( ten? )

[20:21] *** geraud left
[20:23] <masak> stmuk_: unsurprisingly, you are not the first one to think of that one :P

[20:23] *** geraud joined
[20:25] <AlexDaniel> m: my \nine = 9; say nine++

[20:25] <camelia> rakudo-moar : OUTPUT«Cannot call postfix:<++>(Int); none of these signatures match:␤    (Mu:D $a is rw)␤    (Mu:U $a is rw)␤    (Int:D $a is rw)␤    (int $a is rw)␤    (Bool:U $a is rw)␤    (Bool:D $a is rw)␤    (Num:D $a is rw)␤    (Num:U $a is rw)␤    (num $a is …»

[20:25] <stmuk_> m: my \nine = 0; say nice.succ

[20:25] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/dir86_vnbp␤Undeclared routine:␤    nice used at line 1␤␤»

[20:25] <stmuk_> m: my \nine = 0; say nine.succ

[20:25] <camelia> rakudo-moar : OUTPUT«1␤»

[20:26] <stmuk_> m: my \nine = 9; say nine.succ

[20:26] <camelia> rakudo-moar : OUTPUT«10␤»

[20:26] <AlexDaniel> stmuk_: actually, I expected nine++ to be 9. ++nine should be 10

[20:27] <stmuk_> m: say "nine".succ

[20:27] <camelia> rakudo-moar : OUTPUT«ninf␤»

[20:27] <AlexDaniel> o_o

[20:28] <dalek> rakudo/curli: a7b8dfd | (Stefan Seifert)++ | src/core/CompUnit/Repository/FileSystem.pm:

[20:28] <dalek> rakudo/curli: Fixup: expected CompUnit::Handle but got Bool

[20:28] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/a7b8dfdfe3

[20:29] <nine> Type-annotations++

[20:30] *** dha left
[20:30] *** sno left
[20:31] <RabidGravy> m: enum F (:nine(9), :ten(10)); say nine.succ

[20:31] <camelia> rakudo-moar : OUTPUT«10␤»

[20:31] *** dha joined
[20:32] *** domidumont left
[20:32] *** MadcapJake joined
[20:32] *** MadcapJake left
[20:32] <n0tjack> m: enum O (:1st, :2nd, :3rd, :4th); say rd.succ;

[20:32] <camelia> rakudo-moar : OUTPUT«4␤»

[20:33] *** MadcapJake joined
[20:33] *** MadcapJake left
[20:35] <AlexDaniel> m: sub circumfix:<START END>(*@e) { }; START START 'hello' END;

[20:35] <camelia> rakudo-moar : OUTPUT«5===SORRY!5=== Error while compiling /tmp/taF14JZEXw␤Unable to parse expression in circumfix:sym<START END>; couldn't find final $stopper ␤at /tmp/taF14JZEXw:1␤------> 3 END>(*@e) { }; START START 'hello' END;7⏏5<EOL>␤»

[20:35] <AlexDaniel> is it meant to say “$stopper”?

[20:37] <FROGGS> AlexDaniel: no

[20:38] *** zengargoylew left
[20:39] <AlexDaniel> :my $stub := %*LANG<MAIN> := nqp::getlex('$¢').unbalanced($stopper);

[20:39] <AlexDaniel> if that's the right one, I wonder how does it get through…

[20:39] *** hankache left
[20:40] *** diakopter___ joined
[20:41] <dalek> rakudo/nom: 8d1b7d4 | lizmat++ | / (6 files):

[20:41] <dalek> rakudo/nom: Remove placeholder files of the newio branch

[20:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d1b7d4b61

[20:41] <masak> m: enum F (:nine(10), :ten(9)); say nine.succ

[20:41] <camelia> rakudo-moar : OUTPUT«11␤»

[20:41] <masak> :P

[20:42] <lizmat> m: say True.succ

[20:42] <camelia> rakudo-moar : OUTPUT«True␤»

[20:42] <arnsholt> .tell jnthn https://gist.github.com/arnsholt/26d4e5fed6062917c643 # Reproduces the hang issue for me every time. May of course be caused by NativeCall shenanigans though

[20:42] <yoleaux> arnsholt: I'll pass your message to jnthn.

[20:42] <lizmat> m: say False.succ

[20:42] <camelia> rakudo-moar : OUTPUT«True␤»

[20:42] <lizmat> m: say False.pred

[20:42] <camelia> rakudo-moar : OUTPUT«False␤»

[20:42] *** mtj_ joined
[20:42] <lizmat> m: say True.pred

[20:42] <camelia> rakudo-moar : OUTPUT«False␤»

[20:42] <AlexDaniel> m: say True.pred

[20:42] <camelia> rakudo-moar : OUTPUT«False␤»

[20:43] <lizmat> .oO( the joys of Bool being an Enum now )

[20:43] *** petercommand joined
[20:43] <AlexDaniel> m: say True++

[20:43] <camelia> rakudo-moar : OUTPUT«Cannot call postfix:<++>(Bool); none of these signatures match:␤    (Mu:D $a is rw)␤    (Mu:U $a is rw)␤    (Int:D $a is rw)␤    (int $a is rw)␤    (Bool:U $a is rw)␤    (Bool:D $a is rw)␤    (Num:D $a is rw)␤    (Num:U $a is rw)␤    (num $a is…»

[20:43] <AlexDaniel> m: say True + 1

[20:43] <camelia> rakudo-moar : OUTPUT«2␤»

[20:43] *** sunnavy joined
[20:43] <AlexDaniel> m: say False + 1

[20:43] <camelia> rakudo-moar : OUTPUT«1␤»

[20:44] <FROGGS> that was working before

[20:44] <AlexDaniel> m: say False ** False

[20:44] <camelia> rakudo-moar : OUTPUT«1␤»

[20:45] <AlexDaniel> m: sin(True)

[20:45] <camelia> rakudo-moar : OUTPUT«WARNINGS:␤Useless use of "sin(True)" in expression "sin(True)" in sink context (line 1)␤»

[20:45] <lizmat> FROGGS: you mean True++ ??

[20:45] <AlexDaniel> m: sin(True).say

[20:45] <camelia> rakudo-moar : OUTPUT«0.841470984807897␤»

[20:45] <FROGGS> lizmat: no, infix:<+>

[20:46] <AlexDaniel> m: say True ~ False

[20:46] <camelia> rakudo-moar : OUTPUT«TrueFalse␤»

[20:46] *** MadcapJake joined
[20:46] <AlexDaniel> that's fun

[20:46] *** MadcapJake left
[20:46] <jdv79> how does lines() handle line endings?

[20:46] <AlexDaniel> m: say True[False]

[20:46] <camelia> rakudo-moar : OUTPUT«True␤»

[20:46] <jdv79> and did that change recently?

[20:48] *** MadcapJake joined
[20:48] *** MadcapJake left
[20:50] <masak> m: say "the rain in Spain stays mainly in the plain"[False]

[20:50] <camelia> rakudo-moar : OUTPUT«the rain in Spain stays mainly in the plain␤»

[20:50] <masak> m: say False[False[False]][False]

[20:50] <camelia> rakudo-moar : OUTPUT«False␤»

[20:50] *** MadcapJake_ joined
[20:50] <masak> m: say [False ** False][False]

[20:50] <camelia> rakudo-moar : OUTPUT«1␤»

[20:50] <masak> m: say so [False ** False][False]

[20:50] <camelia> rakudo-moar : OUTPUT«True␤»

[20:51] <jnthn> jdv79: chomps them off by default, and yes, it used to fail to chomp if the line ending was anything but \n or \r\n, and that got fixed

[20:51] <yoleaux> 20:42Z <arnsholt> jnthn: https://gist.github.com/arnsholt/26d4e5fed6062917c643 # Reproduces the hang issue for me every time. May of course be caused by NativeCall shenanigans though

[20:51] <AlexDaniel> m: say False + True * i # notes for perl 6 obfuscation contest

[20:51] <camelia> rakudo-moar : OUTPUT«0+1i␤»

[20:52] <jdv79> just wondering what broke my irc bot...  it seems to be delayed in receving somehow .

[20:52] <jdv79> almost as if the next line pushes the stalled line through

[20:52] <jnthn> jdv79: Do you set a separator on the socket?

[20:52] <jdv79> it used to workk 

[20:53] <jdv79> not explicitly

[20:53] <jnthn> OK, then it should be using the default (which is ["\n", "\r\n"])

[20:54] *** diakopter___ left
[20:55] <DrForr> What's the name of the perl6 info site? (not perl6info.com, I checked)

[20:55] <jdv79> maybe its something else then

[20:55] <DrForr> (and not perl6.org...)

[20:55] <stmuk_> do you mean http://perl6intro.com/?

[20:55] <DrForr> intro, thanks.

[20:56] *** sno joined
[20:57] *** kaare_ left
[20:57] <jdv79> no, its lines somehow:(

[20:58] * lizmat looks

[20:59] <lizmat> jdv79: which currently means its .get, no?

[20:59] <jdv79> i don't know the io stuff at all

[20:59] <lizmat> jdv79: could you check whether switching off chomping makes a difference ?

[21:02] <jdv79> doesn't seem to help.  wish i knew a quick way to golf this.

[21:02] <jdv79> inserting a map to add a nl char gets the lines through on time but with extra blank lines...

[21:04] *** MadcapJake_ is now known as MadcapJake

[21:08] <lizmat> jdv79: IO::Handle.lines currently returns a Seq which has a pull-one that only does a .get

[21:08] <jdv79> hold on i golfed it if you want to play

[21:08] <lizmat> jdv79: .get only basically does an nqp::readlinechompfh($!PIO)

[21:09] <lizmat> so I don't see much possibility of it being a HLL issue  :-(

[21:09] <jdv79> huh

[21:09] <arnsholt> jnthn: Oh, and a possibly relevant datapoint on my repro gist is that it only triggers the bug with the loop summing numbers in there. If there's no summing, it works fine. Which would agree with your thought that it's GC-related

[21:11] <jnthn> It could be something deeper down issuing a bogus extra read, but I'm not sure why that'd happen

[21:11] <jdv79> https://gist.github.com/anonymous/bccff00141467fad0acb

[21:12] <lizmat> jdv79: why the map first before doing .lines ???

[21:12] <jdv79> if your run that note C GOT sees the last line of the join command "something about end of /NAMES" whereas GOT does not

[21:12] <jdv79> juts to see it

[21:12] <jdv79> if you remove te map it'll just hide the last line waiting

[21:13] <jdv79> wireshark confirms the last line comes over the socket - its being blocked somewhere

[21:13] <lizmat> but chars-supply does not provide lines, it provides chunks of chars, afaik

[21:13] <jdv79> and a new line coming in pushes it through but itself gets stuck in that limbo situ:(

[21:14] <jdv79> is that the wrong way to do a line based protocol?  it worked on a rakudo about a month old or so

[21:14] <jnthn> Ah, so it's Supply.lines?

[21:14] * jnthn notes that Supply.lines fails tests on Windows

[21:14] <jnthn> Didn't manage to figure those out yet despite a couple of attempts :/

[21:14] *** zakharyas joined
[21:14] * lizmat starts looking there

[21:14] <jdv79> good times

[21:17] <lizmat> jdv79: hmm... good be a result of the CRLF -> 1 synthetic changes

[21:17] <lizmat> s/good/could

[21:18] <jdv79> the responses are crlf ended

[21:18] <jnthn> Ah

[21:18] <jnthn> Then quite possibly

[21:20] <lizmat> yeah, and there was extra code to handle the case where CR was the last codepoint of a chunk

[21:20] <jnthn> Did it use ord?

[21:20] <jnthn> *does

[21:20] <lizmat> not anymore

[21:20] <jnthn> :)

[21:21] <DrForr> Gah, choosing a headshot for OSCON. Makes me feel like I'm on a reality TV show...

[21:22] <sno> moritz: around?

[21:24] <lizmat> jnthn: sanity check, if a chunk would end in a CR, and the next chunk starts with LF, then concatting them *would* create the synthetic, right ?

[21:24] <jnthn> lizmat: Correct

[21:24] <jnthn> lizmat: Meaning that the index that was \r before will be the \r\n synthetic after

[21:24] <jnthn> m: say "\r" ~ "\n" .chars

[21:24] <camelia> rakudo-moar : OUTPUT«

[21:25] <jnthn> oops :)

[21:25] <jnthn> m: say ("\r" ~ "\n") .chars

[21:25] <camelia> rakudo-moar : OUTPUT«1␤»

[21:25] <lizmat> ok, so I guess I *would* need to introduce the check for CR

[21:25] <jnthn> .oO( it's not *that* low prec! )

[21:25] <lizmat> because that's what's blocking it

[21:25] <jnthn> aha

[21:26] <lizmat> jdv79: I think I found the logic error

[21:26] *** diana_olhovik joined
[21:26] <jdv79> incredible

[21:26] *** brrt joined
[21:27] <jdv79> may have taken me a day to fail and then ask.  this is much better:)

[21:27] <lizmat> :-)

[21:27] <lizmat> jdv79: if you could write a test-case for this, that would be brill  :-)

[21:28] <sno> .tell moritz I didn't prove whether my fix don't break the intended new feature - will prove tomorrow and ping on success / update on error

[21:28] <yoleaux> sno: I'll pass your message to moritz.

[21:29] <jdv79> i could probably manage that eventually

[21:30] *** frobisher joined
[21:31] *** dha left
[21:31] *** frobisher is now known as dha

[21:32] *** tudorconstantin left
[21:33] *** diana_olhovik left
[21:35] *** tokuhiro_ joined
[21:38] <lizmat> jdv79: I'm running test program with patches now, could you take care of some traffic there ?

[21:39] *** tokuhiro_ left
[21:40] <jdv79> what sort of traffic?

[21:40] <lizmat> ah, found the channel... :)

[21:40] <lizmat> alas, no success yet  :-(

[21:40] <jdv79> i'm still poking around the supply tests.  ok.

[21:41] <jdv79> so its not the split cr lf?

[21:41] <dha> I guess I'll ask this again, as it continues to bug me...

[21:42] *** brrt left
[21:42] <dha> 5to6-nutshell refers to "item" variables. I have not found that term anywhere else, and it uses it where a Perl 5 programmer would expect to find the word "scalar" instead.

[21:42] <dha> Is there a reason for this?

[21:42] <Hotkeys> strange because we also call them scalars in p6 don't we?

[21:43] *** AlexDaniel left
[21:43] <pink_mist> Hotkeys: but it's not a keyword in p6, is it?

[21:43] <dha> That's what I thought. As I say, the term does not appear to be anywhere else in the docs.

[21:43] <jdv79> isn't it items vs list context?

[21:43] <jdv79> *item

[21:44] <dha> pink_mist -  in this context, it's just a word in the docs, rather than a keyword.

[21:44] <pink_mist> dha: yes, but in perl5 it's a keyword, and it's used in a certain way

[21:45] *** TEttinger joined
[21:45] <dha> this is true. but it doesn't really address the issue at hand. And even in P5 the term "scalar variable" needn't have anything to do with the keyword "scalar"

[21:45] <dha> For reference, it turns up here: http://doc.perl6.org/language/5to6-nutshell#%24_Scalar

[21:46] *** colomon left
[21:46] <dha> And in the following sections on arrays and hashes, it refers to "array" variables and "hash" variables.

[21:47] <dha> So this seems confusing and possibly inconsistent.

[21:47] <dha> And even more confusing being in a 5to6 document.

[21:47] <jnthn> I tend to call $foo a scalar variable

[21:47] <jdv79> seems a but unsure of itself

[21:47] <dha> As would I

[21:48] <jnthn> We certainly talk about item *context* in Perl 6

[21:48] <lizmat> jnthn: ok,I guess we're being bitten by the fact that ord doesn't tell us whether it is a synthetic CRLF or a bare CR  :-(

[21:48] <jnthn> lizmat: Right

[21:48] <jnthn> lizmat: ord is usually a bad idea

[21:48] <pink_mist> yeah, I'd replace the `"item"` with just scalar in that section, dha

[21:48] <dha> It might be one thing if this term was used anywhere else, but it isn't.

[21:48] <jnthn> lizmat: nqp::eqat will do the right thing

[21:48] <jnthn> lizmat: And not allocate, just like ord

[21:48] *** Zoffix left
[21:48] <dha> ok, I'll change it and put in a pull request.

[21:48] <jdv79> dha: http://design.perl6.org/S02.html#Sigils uses scalar so why not 

[21:49] <dha> *nod*

[21:50] *** Zoffix joined
[21:51] <jdv79> that whole blurb confuses me

[21:52] <jdv79> what does it even mean?!

[21:53] <jdv79> no longer used for indexing...that is you will still use... what?

[21:53] <dha> Hm. yeah, it probably should explain what "you will still use $x[1] and $x{"foo"}, but you use them on $x, not @x or %x." actually means.

[21:53] *** sunnavy left
[21:53] <jdv79> its contradictory in a sense 

[21:53] *** petercommand left
[21:54] *** mtj_ left
[21:54] <dha> well, $x can contain an array. Which you can index.

[21:54] <pink_mist> not for a perl5er imo ... it clearly tells someone who understand perl5 that doing $x[1] will no longer index @x

[21:54] <dalek> rakudo/nom: 97b93c3 | lizmat++ | src/core/Supply.pm:

[21:54] <dalek> rakudo/nom: Fix delayed line issue, found by jdv79++

[21:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/97b93c3878

[21:54] <dha> m: my $x = [1, 2, 3, 4];say $x[1];

[21:54] <camelia> rakudo-moar : OUTPUT«2␤»

[21:54] <lizmat> jdv79: ^^^

[21:54] <jdv79> yes, then how is the "no lgoer used for indexing" part true?

[21:55] <dha> pink_mist -  yeah, but it's kind of unclear what it *does* do.

[21:55] <pink_mist> dha: yeah, that could be further elucidated, it's true

[21:55] <masak> maybe it's best to explain in terms of lack of sigil variance.

[21:55] *** Sqirrel left
[21:55] <dha> maybe change "no longer for array indexing and Hash indexing" to "no longer for indexing array and hash variables"

[21:55] <masak> that is, `$x[$i]` indexes into `$x`, not `@x`

[21:57] <pink_mist> you know, as a perl5er, that kindof makes me wonder what the point of @x and %x is if you can just $x = []...

[21:57] <pink_mist> I mean, you could that in perl5 too, but then it was clear it was a reference

[21:57] <pink_mist> I don't yet find the same clarity in p6

[21:58] <pink_mist> but I should really learn it better

[22:00] <timotimo> @foo = 1234, 1234; and $foo = 1234, 1234; behave differently at the very least

[22:00] <dha> timotimo -  how so?

[22:00] <timotimo> and $foo = hi => 1, goodbye => 2; vs @foo = hi => 1, goodbye => 2; vs %foo = hi => 1, goodbye => 2;

[22:00] <timotimo> m: my @foo = 1234, 1234; say @foo.perl

[22:00] <camelia> rakudo-moar : OUTPUT«[1234, 1234]␤»

[22:00] <timotimo> m: my $foo = 1234, 1234; say $foo.perl

[22:00] <camelia> rakudo-moar : OUTPUT«WARNINGS:␤Useless use of constant integer 1234 in sink context (line 1)␤1234␤»

[22:00] <masak> pink_mist: you can, yes. but I still find that @ and % are much clearer and "nicer to look at".

[22:00] <jdv79> lizmat: what does that fix do?  accept a bare \r instead of \r\n?

[22:00] <FROGGS> nine: I think I got it

[22:00] *** telex left
[22:01] <masak> pink_mist: tastes vary. as for me, I find even in Perl 5 that people over-use arrayrefs and hashrefs compared to my style.

[22:01] <pink_mist> masak: =)

[22:01] <lizmat> jdv79: the fix makes sure that if a chunk ends in a CR

[22:01] *** xfix left
[22:01] <timotimo> my $foo = hi => 1, goodbye => 2; my @foo = hi => 1, goodbye => 2; my %foo = hi => 1, goodbye => 2; say "dollar: $foo;   array: @foo[];   hash: %foo{}"

[22:01] <dha> timotimo -  ok, so you need different syntax to create the variables, but do they act differently once created?

[22:01] <timotimo> m: my $foo = hi => 1, goodbye => 2; my @foo = hi => 1, goodbye => 2; my %foo = hi => 1, goodbye => 2; say "dollar: $foo;   array: @foo[];   hash: %foo{}"

[22:01] <camelia> rakudo-moar : OUTPUT«dollar: hi 1;   array: hi  1 goodbye       2;   hash: goodbye      2␤hi    1␤»

[22:01] <nine> FROGGS: :)

[22:01] <lizmat> it will wait for the next chunk to arrive (because it *can* be a part of a CRLF)

[22:01] <timotimo> m: my $foo = hi => 1, goodbye => 2; my @foo = hi => 1, goodbye => 2; my %foo = hi => 1, goodbye => 2; say "dollar: $foo.perl;   array: @foo.perl();   hash: %foo.perl()"

[22:01] <camelia> rakudo-moar : OUTPUT«dollar: hi 1.perl;   array: [:hi(1), :goodbye(2)];   hash: {:goodbye(2), :hi(1)}␤»

[22:01] <timotimo> m: my $foo = hi => 1, goodbye => 2; my @foo = hi => 1, goodbye => 2; my %foo = hi => 1, goodbye => 2; say "dollar: $foo.perl();   array: @foo.perl();   hash: %foo.perl()"

[22:01] <camelia> rakudo-moar : OUTPUT«dollar: :hi(1);   array: [:hi(1), :goodbye(2)];   hash: {:goodbye(2), :hi(1)}␤»

[22:02] <lizmat> in all other cases, it will pass on the line immediately

[22:02] <timotimo> dha: it's about assignment, not just when creating with "my"

[22:02] <masak> pink_mist: as someone said recently, @ and % are Perl's very core "Hungarian notation"; they're there to signal array (ish) and hash (ish). opting out of them means missing out.

[22:02] *** telex joined
[22:02] <lizmat> jdv79: hope that makes sense ?

[22:02] <pink_mist> masak: good point =)

[22:02] <jdv79> oh so it was the original idea

[22:02] <masak> pink_mist: in Perl 6, this is made more powerful, because you could still use % with (say) a userland "ordered hash"

[22:02] <lizmat> yea, but now implemented correctly

[22:02] <jdv79> the idea does - the code i'm still looking into.  tahnks.

[22:03] <lizmat> jdv79: you're welcome

[22:03] <dha> To be fair, the fact that you can put an array into a scalar doesn't bother me overmuch.

[22:03] <lizmat> brb

[22:04] <jdv79> it nice when you want somethign that can be a Positional and/or an Associative thing

[22:04] *** zakharyas left
[22:06] *** skids left
[22:07] *** petercommand joined
[22:09] <dalek> rakudo/curli: 20dc95d | (Stefan Seifert)++ | src/core/ (3 files):

[22:09] <dalek> rakudo/curli: Throw typed exceptions when unable to load a module

[22:09] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/20dc95dc28

[22:10] * FROGGS spectests

[22:10] <nine> FROGGS: not much left to implement from jnthn++'s gist once you push your change :)

[22:10] *** Zoffix left
[22:11] *** pmurias joined
[22:13] <dalek> doc: a8a952a | (David H. Adler)++ | doc/Language/5to6-nutshell.pod:

[22:13] <dalek> doc: Changed "item" to "scalar" in section on scalar sigils

[22:13] <dalek> doc: review: https://github.com/perl6/doc/commit/a8a952ac9c

[22:13] <dalek> doc: 6b614df | (Zoffix Znet)++ | doc/Language/5to6-nutshell.pod:

[22:13] <dalek> doc: Merge pull request #210 from dha/master

[22:13] <dalek> doc: 

[22:13] <dalek> doc: Changed "item" to "scalar" in section on scalar sigils

[22:13] <dalek> doc: review: https://github.com/perl6/doc/commit/6b614dfe51

[22:13] *** sunnavy joined
[22:13] <dha> thanks.

[22:15] *** n0tjack left
[22:15] *** colomon joined
[22:15] *** pmurias left
[22:16] *** pmurias_ joined
[22:16] <dalek> rakudo-star-daily: cc49308 | coke++ | log/ (2 files):

[22:16] <dalek> rakudo-star-daily: today (automated commit)

[22:16] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/cc4930872c

[22:17] <dalek> nqp: c77898e | (Pawel Murias)++ | src/vm/js/ (2 files):

[22:17] <dalek> nqp: [js] Implement type parameterization.

[22:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c77898ebcc

[22:18] <jnthn> 'night, #perl6

[22:18] <timotimo> gnite jnthn :)

[22:19] <grondilu> m: say my unit32 $ = 2**32 - 1

[22:19] <camelia> rakudo-moar : OUTPUT«5===SORRY!5===␤Type 'unit32' is not declared. Did you mean any of these?␤    uint32␤    uint2␤    int32␤␤at /tmp/zg8AKTZOoo:1␤------> 3say my unit327⏏5 $ = 2**32 - 1␤Malformed my␤at /tmp/zg8AKTZOoo:1␤------> 3say my7⏏5 unit32 $…»

[22:19] <grondilu> m: say my uint32 $ = 2**32 - 1

[22:19] <camelia> rakudo-moar : OUTPUT«4294967295␤»

[22:20] *** pmurias_ left
[22:20] <grondilu> m: my uint32 $n = 2**32 - 1; say $n

[22:20] <camelia> rakudo-moar : OUTPUT«-1␤»

[22:21] *** pmurias joined
[22:21] *** muraiki left
[22:22] *** pmurias left
[22:22] *** mtj_ joined
[22:23] *** dwarring joined
[22:23] <dha> Does this read any better to people? "That is, you can still use $x[1] and $x{"foo"}, but it will act on $x, with no effect on the similarly named @x or %x."

[22:25] <dalek> rakudo/curli: a9b1b7a | FROGGS++ | / (3 files):

[22:25] <dalek> rakudo/curli: align CURI.install to new API

[22:25] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/a9b1b7a4f2

[22:26] *** pmurias joined
[22:26] <timotimo> dha: i'd add another short sentence to show @a[1] and/or %x{"foo"}

[22:26] <FROGGS> also about CURI.install: https://github.com/tadzik/panda/commit/67deeed54ce396b10bfd7c1a58540ee7972b06ef

[22:27] <ugexe> should the %scripts really get -j wrappers if there is no perl6-j?

[22:27] <dha> "That is, you can still use $x[1] and $x{"foo"}, but it will act on $x, with no effect on the similarly named @x or %x. Those would now be accessed wit

[22:27] <dha> h @x[1] and %x{"foo"}."

[22:27] <dha> like that?

[22:28] <timotimo> yeah

[22:28] <FROGGS> ugexe: dunno

[22:28] <timotimo> hm, maybe i'd say "on a similarly named @x or %x"

[22:28] <FROGGS> ugexe: I just made it so because it was the easiest

[22:28] <timotimo> instead of "the similarly named ..."

[22:28] <nine> Maybe the user installs a perl6-j later on

[22:28] <dha> I have no problem with that.

[22:29] *** Zoffix joined
[22:29] <ugexe> if the user installs a separate perl6-j via rakudobrew then it just messes that up

[22:29] *** geraud left
[22:29] <FROGGS> ugexe: we also have to consider apt and friends

[22:30] <FROGGS> so maybe a perl6-j gets just unpacked later on, or enabled in some way

[22:30] <FROGGS> but I'd be also happy with only installing for existing compilers

[22:30] <nine> The generated wrapper is very independent of the rakudo or even Perl 6 version.

[22:30] <FROGGS> s/installing/creating wrappers/

[22:31] <FROGGS> gnight

[22:31] <nine> Good night!

[22:32] <Zoffix> Is there something special require ::("$m"); where $m is a module name? I'm trying to debug this code and on another box this module is installed with panda and require succeeds, but now I just -Ipath/to/repo/checkout/lib my script and require fails: https://github.com/tony-o/perl6-pluggable/blob/master/lib/Pluggable.pm6#L16

[22:32] <Zoffix> m: require ::("foobar")

[22:32] <camelia> rakudo-moar : OUTPUT«Could not find foobar in any of:␤  file#/home/camelia/.perl6/2015.11-51-g97b93c3/lib␤  inst#/home/camelia/.perl6/2015.11-51-g97b93c3␤  file#/home/camelia/rakudo-m-inst-1/share/perl6/lib␤  file#/home/camelia/rakudo-m-inst-1/share/perl6/vendor/lib␤  file…»

[22:32] <Zoffix> And strangely, the CATCH doesn't catch any errors... It just fails to make the .push on the next line

[22:32] <Zoffix> Oh wait. I'm catching in the wrong place

[22:32] *** geraud joined
[22:33] <dha> ok. added that bit to the scalar sigil doc.

[22:33] <Zoffix> dha, do you have perms to make commits?

[22:34] <dha> I do. but after the usage statement hubbub, I've  been a bit gunshy about committing directly. :-)

[22:34] <timotimo> i'd actually be annoyed to have binaries on my system that do nothing but say "not installed"

[22:34] <Zoffix> dha, what usage statement hubbub? :)

[22:35] <Zoffix> Never mind my issue. Turns out I'm missing unrelated modules.

[22:35] <dha> That time I talked about adding P5 style usage statements and a bunch of people said "yeah, do that" and then after a week of actually doing so a different bunch of people said "That's a terrible ides. stop doing that." :-)

[22:35] <Zoffix> :P

[22:35] <timotimo> p5 style?

[22:36] <ugexe> say i have perl6-j and perl6-m as separate installations and a module FOO with a bin script. if i install FOO to perl6-j it generates the wrappers perl6-j and perl6-m and puts them into whatever /bin directory. now if i install FOO to moar it again installs perl6-j and perl6-m, but now the perl6-j for the moar install is shadowing the jvm wrapper

[22:36] *** diakopter___ joined
[22:36] <dha> Feel free to look at my efforts. When I was urged to stop doing it, It was also suggested that I not bother backing it all out at this time.

[22:37] <dha> For instance, you can see them in doc/Type/Int.pod (and a bunch of other documents as well).

[22:40] <dha> E. g. in the P5 perlfunc you get stuff like this: split /PATTERN/,EXPR,LIMIT

[22:41] <dha> With various suggestions, I turned that into "split( DELIMITER,  STRING [,LIMIT] [,:v] [,:k] [,:kv] [,:p] [,:skip-empty] )" for P6.

[22:41] <DrForr> 2 proposals sent for OSCON, doing the 3rd tomorrow.

[22:41] *** n0tjack joined
[22:41] <dha> The idea was that these would be something people could look at that would make the actual use of functions clearer than just having the signatures in there.

[22:42] <ugexe> its not a matter of the wrapper being right. its how do you have 2 binscript-j (one for a moar install, one for a jvm install) available in path without the useless one shadowing the other

[22:42] <[Coke]> dha: I don't recall saying it was a terrible idea, just that I didn't think it was worth it. If you still feel strongly about it, go ahead.

[22:42] <dha> This was, alternately, well received and not well received

[22:42] <dha> [Coke] -  sorry, I was being a little hyperbolic. :-)

[22:43] <dha> I'm a lot more relaxed about it now. :-)

[22:43] <[Coke]> I still don't think it helps, but I am willing to believe it'll help someone.

[22:43] <dha> Actually, the suggestion that, instead of the usage statements, we should just put in sufficient examples is not a bad idea.

[22:44] <dha> I think one of the problems with what I was doing is that, in trying to be consistent by giving everything a usage statement, I was putting in a lot of usage statements that weren't all that helpful.

[22:44] <timotimo> dha: oh, i remember the usage thing!

[22:44] <timotimo> the beginning was interesting, but it was also kinda weird for someone like me who never perl5'd before

[22:45] <[Coke]> I would concur that targetted usage statements would be more useful.

[22:45] <dha> timotimo -  yeah, it's kind of a hard line to walk. It actually grew out of my asking around about what people thought made the P5 documentation so successful, and that was the one thing that really stood out.

[22:45] <[Coke]> (concur) been watching too much Voyager this week.

[22:45] *** kjs_ left
[22:46] <dha> [Coke] -  what do you mean by "targeted usage statements"?

[22:47] <dha> Do you mean putting in usage statements selectively rather than consistently, i. e. for things that may not be immediately clear?

[22:47] *** colomon left
[22:48] <[Coke]> yes.

[22:49] <grondilu> m: say +^my uint32 $ = 2**32 - 1

[22:49] <camelia> rakudo-moar : OUTPUT«-4294967296␤»

[22:49] <grondilu> m: my uint32 $n = 2**32 - 1; say $n == +^+^$n

[22:49] <camelia> rakudo-moar : OUTPUT«False␤»

[22:50] <dha> I am wholly not opposed to that. I think I was sticking too hard to the idea of consistency.

[22:50] <dalek> doc: 37d3c3f | (David H. Adler)++ | doc/Language/5to6-nutshell.pod:

[22:50] <dalek> doc: Rewrote section on scalar sigil for clarity

[22:50] <dalek> doc: review: https://github.com/perl6/doc/commit/37d3c3f980

[22:50] <dalek> doc: 3dddbad | RabidGravy++ | doc/Language/5to6-nutshell.pod:

[22:50] <dalek> doc: Merge pull request #211 from dha/master

[22:50] <dalek> doc: 

[22:50] <dalek> doc: Rewrote section on scalar sigil for clarity

[22:50] <dalek> doc: review: https://github.com/perl6/doc/commit/3dddbadf2e

[22:51] <dha> Zoffix -  back to your original question about my committing ability. Should I be just committing these kinds of minor tweaks?

[22:51] <dha> Instead of, you know, changing the entire structure of the docs... :-)

[22:55] <Zoffix> dha, sure.

[22:55] <dha> Ok.

[22:55] <Zoffix> dha, not that I'm in any way an authoritative source on what and who should be committing.

[22:56] <Zoffix> But I'd commit those small changes :) If there's a problem it's very easy to undo them.

[22:56] <dha> Right. But since we don't really *have* an authoritative source...

[22:57] * Zoffix storms the vacant palace and forms a government

[22:57] <Zoffix> dha, Ye shall make committeth!

[22:57] *** timbunce left
[22:57] <dha> Has a moistened bint lobbed a scimitar at you? :-)

[22:58] <dha> And, yessir!

[22:59] *** AlexDaniel joined
[23:01] <dwarring> m: class MyClass {}; role MyRole is MyClass {}; True does MyRole

[23:01] <camelia> rakudo-moar : OUTPUT«Base type has already been set for Bool+{MyRole}␤  in any set_base_type at gen/moar/m-Metamodel.nqp:877␤  in any add_parent at gen/moar/m-Metamodel.nqp:3320␤  in any apply at gen/moar/m-Metamodel.nqp:2724␤  in any compose at gen/moar/m-Metamodel.nqp:3362…»

[23:02] <dwarring> howdy perl6

[23:02] <dwarring> ^^ that's started happening in the last couple of days

[23:02] <lizmat> dwarring: probably related to the fact that Bool is now an Enum (it wasn't before)

[23:03] <dwarring> m: class MyClass {}; role MyRole is MyClass {}; 42 does MyRole

[23:03] <camelia> rakudo-moar : ( no output )

[23:03] <timotimo> dwarring: can you actually is a class when you're a role?

[23:03] <dwarring> i was :-)

[23:04] <dha> Just for the record, I'm still a bit concerned about the issue of scalar variables that contain non-scalar things in the 5to6 docs being potentially confusing. Not sure what to do about it, thougg.

[23:04] <Zoffix> 1) Wait for someone to get confused; 2) Ask them to propose a patch to the docs :)

[23:05] <dha> Yeah, I guess that's the way to go.

[23:06] <timotimo> 3) repeat

[23:06] <dwarring> timotimo: I'm only doing that in one spot

[23:06] <dwarring> can avoid it

[23:06] <Zoffix> Oh gee. Finally found the cause of my bug! took about 40 minutes:

[23:06] <Zoffix> m: use lib 'lib'; use lib 'lib'; use lib 'lib';  say @*INC.grep(* eq 'file#lib').elems

[23:06] <camelia> rakudo-moar : OUTPUT«3␤»

[23:07] <Zoffix> And I had use lib 'lib' in code as well as -Ilib to perl -_-

[23:07] <timotimo> %)

[23:07] <Zoffix> ^ that IMO a bug.

[23:07] <dwarring> lizmat: that doesn't look valid?

[23:07] <Zoffix> At least from the perspective of a Perl 5 coder. In P5 use lib's feature is exactly that it does not create dupes

[23:08] <dwarring> lta, if nothing else

[23:08] <lizmat> dwarring: confused now, what doesn't look valid ?

[23:08] <masak> 'night, #perl6

[23:08] <hoelzro> night masak 

[23:08] <Zoffix> night

[23:08] <Skarsnik> 'night #perl6 x)

[23:09] <dwarring> m: class MyClass {}; role MyRole is MyClass {}; True does MyRole

[23:09] <camelia> rakudo-moar : OUTPUT«Base type has already been set for Bool+{MyRole}␤  in any set_base_type at gen/moar/m-Metamodel.nqp:877␤  in any add_parent at gen/moar/m-Metamodel.nqp:3320␤  in any apply at gen/moar/m-Metamodel.nqp:2724␤  in any compose at gen/moar/m-Metamodel.nqp:3362…»

[23:09] <dwarring> now that Bool is an Enum

[23:10] <dwarring> i might just refactor that bit of code

[23:10] * dha wonders if some info on how assignments are now done should be added to 5to6-nutshell, possibly in the scalar/array/hash entries under Sigils.

[23:11] <lizmat> dwarring: that looks wise to me

[23:11] <Zoffix> dwarring, I think maybe that roles can't "is" classes. Looking at the docs: non-multi methods cause compile conflicts and classes have some predefined methods: http://doc.perl6.org/language/objects#Role_Application

[23:12] *** vendethiel left
[23:12] * Zoffix tries to recall the MOP-fu to inspect what method class/role provide

[23:13] <Zoffix> m: class Foo { method bar {} }; role Bar is Foo {}; say Foo.^methods, Bar.^methods

[23:13] <camelia> rakudo-moar : OUTPUT«(bar)()␤»

[23:13] <Zoffix> ¯\_(ツ)_/¯

[23:13] <lizmat> m: for ^100000 { my $a = 42; my $b = 666 }; say now - INIT now

[23:13] <camelia> rakudo-moar : OUTPUT«0.0573191␤»

[23:13] <lizmat> m: for ^100000 { my ($a,$b) = (42,666) }; say now - INIT now

[23:13] <camelia> rakudo-moar : OUTPUT«2.0419858␤»

[23:13] <Zoffix> 0.o

[23:13] <lizmat> m: say 2.04 / 0.06

[23:13] <camelia> rakudo-moar : OUTPUT«34␤»

[23:13] * dwarring refactors

[23:13] <dwarring> thanks all

[23:14] <lizmat> dwarring: yw

[23:14] *** RabidGravy left
[23:16] *** colomon joined
[23:17] <Zoffix> Created a ticket for the use lib stuff: https://rt.perl.org/Ticket/Display.html?id=126718

[23:18] * Zoffix spots a typo.

[23:18] <lizmat> m: for ^100000 { my $a = (42,66)[0]; my $b = (42,666)[1] }; say now - INIT now

[23:18] <camelia> rakudo-moar : OUTPUT«0.3442081␤»

[23:18] <Zoffix> Dang no edit button. I hate RT :P

[23:18] <lizmat> m: say 2.04 / 0.34

[23:18] <camelia> rakudo-moar : OUTPUT«6␤»

[23:19] <Skarsnik> Zoffix, yes it's annoying x)

[23:19] <Zoffix> m: for ^100000 { my ( $a, $b ); }; say now - INIT now

[23:19] <camelia> rakudo-moar : OUTPUT«0.19931335␤»

[23:19] <Zoffix> m: for ^100000 { my $a; my $b; }; say now - INIT now

[23:19] <camelia> rakudo-moar : OUTPUT«0.04149988␤»

[23:19] <Zoffix> m: say 0.19931335 / 0.04149988

[23:19] <camelia> rakudo-moar : OUTPUT«4.80274521␤»

[23:19] <lizmat> Zoffix: yeah, eliminating all those cases from code now

[23:20] <dha> In 5to6-nutshell, the doc for the string/list repeat operator uses the phrases "In scalar content" and "In list content". I'm guessing those should actually read "context"?

[23:21] <pink_mist> yep

[23:21] <timotimo> ugh, i'm procrastinating writing that weekly blog post

[23:21] <Zoffix> dha, yes

[23:21] *** sprocket left
[23:21] <dha> *nod* fixing.

[23:21] * Zoffix threateningly shows timotimo a whip

[23:22] <Zoffix> You still haven't told me what sort of "link-to-modules maker" you wanted 

[23:22] <dalek> doc: 7127f00 | (David H. Adler)++ | doc/Language/5to6-nutshell.pod:

[23:22] <dalek> doc: Changed instances of "content" to "context" in string/list repeat op doc

[23:22] <dalek> doc: review: https://github.com/perl6/doc/commit/7127f004ec

[23:25] <dha> Ugh. a search for "..." pops up "Routine: ...", but when you try to go to the relevant doc, you get a 404

[23:25] <Zoffix> There's a whole bunch of those (there should be an issue)

[23:26] <Zoffix> .+ is one of them, IIRC

[23:26] <dha> bleh.

[23:26] *** dha left
[23:26] <timotimo> Zoffix: did you read my last weekly blog post?

[23:28] <Zoffix> timotimo, I skimmed through it

[23:29] <Zoffix> Why? :)

[23:29] *** kid51 joined
[23:30] *** pmurias left
[23:30] <Zoffix> timotimo, "I’ve got two [edit: three] little tasks that outsiders could reasonably easily pick up if they want to get into Perl 6 development"

[23:30] <Zoffix> Curious what those are :)

[23:30] <Zoffix> Or are they done already? :)

[23:32] <dalek> rakudo/nom: f37ba17 | lizmat++ | src/core/ (5 files):

[23:32] <dalek> rakudo/nom: Prevent use of my (...) where possible

[23:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f37ba171f7

[23:32] <timotimo> Zoffix: those three tasks are described directly below that ...

[23:33] <timotimo> Zoffix: also, ideally, the whatever thing would let me specify a start and end date (defaulting to today and today - 7 days) and list new things in the ecosystem inside a contentseditable div or something with properly working links

[23:33] <timotimo> so i can just copy-paste the stuff over into the wordpress wysiwyg editor and write the descriptions there

[23:34] <Zoffix> That stuff looks hard.

[23:34] <Zoffix> I mean the "lowhanging fruit" stuff

[23:34] <Zoffix> timotimo, k, I'll take a look into that.

[23:35] *** Oatmeal left
[23:36] <timotimo> neato :)

[23:36] <timotimo> oh, is that how you meant that

[23:37] *** tokuhiro_ joined
[23:37] <Zoffix> timotimo, how I meant what?

[23:38] <jdv79> oh, did parse stage times go down?

[23:39] <diakopter___> with a patch currently pending in a branch

[23:39] <jdv79> i just got 63s.  think it was up tp 75s or so a couple monts ago

[23:40] <diakopter___> in that branch it's 46s for me XD

[23:40] *** skids joined
[23:40] <timotimo> a couple months ago?!?

[23:40] <timotimo> ;)

[23:40] *** havenn joined
[23:40] <dalek> roast: b727ecc | jdv79++ | S17-supply/lines.t:

[23:40] <dalek> roast: Add specific test for chunked CRLF.  See 97b93c3.

[23:40] <dalek> roast: review: https://github.com/perl6/roast/commit/b727ecc1a3

[23:40] <diakopter___> also, spectest times reduced from 256 seconds to 227 seconds (TEST_JOBS=9 on 8 cores)

[23:41] <jdv79> nice

[23:41] <SmokeMachine_> if I augment the Any type, isn't it reflected on every Any child?

[23:41] *** tokuhiro_ left
[23:43] <timotimo> Zoffix: i welcome you to suggest another "low hanging fruit" thingie for the next post!

[23:44] <Zoffix> timotimo, find the "date when added to ecosystem" for all 460 modules in https://github.com/perl6/ecosystem/blob/master/META.list

[23:44] <Zoffix> timotimo, much preferably with some automated script :)

[23:45] <SmokeMachine_> this is my new solution for that Optional Type discuss... but when I augment the Any type, it's not being reflected on the Int type... https://www.irccloud.com/pastebin/NwcmKKWA/

[23:45] <Zoffix> I'm guessing that would involve taking the part of URL after the author and rewinding git history back to see when that URL starts showing up or something

[23:46] *** Skarsnik left
[23:46] *** havenn left
[23:46] *** havenwood left
[23:47] *** havenwood joined
[23:47] <lizmat> SmokeMachine_: afaik, that's a long standing bug

[23:47] <lizmat> in rakudo, children know about their parents, but parents don't know about their children

[23:47] <lizmat> unless that change like in the past 10 days or so

[23:47] <lizmat> *changed

[23:47] <timotimo> i don't think it changed, no

[23:47] *** Oatmeal joined
[23:48] *** grondilu left
[23:49] *** ribasushi left
[23:52] <raiph> SmokeMachine_: https://rt.perl.org/Ticket/Display.html?id=116613

[23:52] <raiph> note especially http://irclog.perlgeek.de/perl6/2015-10-15#i_11379856 and jnthn's response

[23:56] <dalek> rakudo/nom: 6bd4006 | lizmat++ | src/core/Str.pm:

[23:56] <dalek> rakudo/nom: Make Str.lines 1.5x - 2x as fast

[23:56] <dalek> rakudo/nom: 

[23:56] <dalek> rakudo/nom: Thanks to further simplification now that CRLF is a single (synthetic) codepoint

[23:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6bd4006499

