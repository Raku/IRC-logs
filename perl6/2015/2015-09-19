[00:00] <masak> at least that's the way it feels, deep down in my intuition.

[00:05] <masak> but yes, I see the deviation from consistency in what an integer literal *is* in the language.

[00:05] <masak> suddently it's one thing inside of literals, and another thing outside of them.

[00:06] <masak> I wonder if there's a middle way somehow, a way to allow prefix:<-> without corrupting what "literal" means.

[00:06] <masak> 'night, #perl6

[00:11] *** BenGoldberg joined
[00:18] <vendethiel> o/ masak

[00:21] *** Juerd joined
[00:22] *** telex left
[00:24] *** telex joined
[00:25] *** Juerd left
[00:25] *** Juerd joined
[00:26] *** ugexe left
[00:28] *** mprelude left
[00:29] *** mprelude joined
[00:41] *** Skarsnik left
[00:45] *** telex left
[00:46] *** telex joined
[00:55] *** telex left
[00:55] *** mr_ron left
[00:56] *** telex joined
[01:08] <ShimmerFairy> TimToady: my suspicion is that more people see -1 where the - is a literal part of the int (like '.' in 3.0, or 'e' in 5e2), and don't see it so much as  &prefix:<->(1)

[01:08] <ShimmerFairy> TimToady: but I don't know if actually making the change to reflect is a good idea at this point.

[01:08] *** telex left
[01:09] *** aborazmeh joined
[01:09] *** aborazmeh left
[01:09] *** aborazmeh joined
[01:09] * ShimmerFairy notes that S03 shows ** has its own precedence level all by itself, most likely just to make -1 ** 2 mathematically right

[01:10] *** telex joined
[01:16] <dalek> rakudo/nom: ea2d21c | TimToady++ | src/Perl6/ (2 files):

[01:16] <dalek> rakudo/nom: allow negative integers as parameters

[01:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea2d21ce37

[01:16] <dalek> roast: 08154ac | TimToady++ | S06-multi/value-based.t:

[01:16] <dalek> roast: test negative parameter values

[01:16] <dalek> roast: review: https://github.com/perl6/roast/commit/08154ac298

[01:17] <BenGoldberg> m: say -1 ** 0.5

[01:17] <camelia> rakudo-moar 6252fc: OUTPUT«-1␤»

[01:17] <BenGoldberg> m: sqrt(-1)

[01:17] <camelia> rakudo-moar 6252fc: OUTPUT«WARNINGS:␤Useless use of "sqrt(-1)" in expression "sqrt(-1)" in sink context (line 1)␤»

[01:17] <BenGoldberg> m: sqrt(-1).say

[01:17] <camelia> rakudo-moar 6252fc: OUTPUT«NaN␤»

[01:18] <BenGoldberg> m: sqrt(-1 + 0i).say

[01:18] <camelia> rakudo-moar 6252fc: OUTPUT«6.12323399573677e-17+1i␤»

[01:18] <BenGoldberg> m: ((-1 + 0i) ** .5 ).say

[01:18] <camelia> rakudo-moar 6252fc: OUTPUT«6.12323399573677e-17+1i␤»

[01:18] <BenGoldberg> m: ((-1) ** .5 ).say

[01:18] <camelia> rakudo-moar 6252fc: OUTPUT«NaN␤»

[01:18] <BenGoldberg> m: (-1 ** .5 ).say

[01:18] <camelia> rakudo-moar 6252fc: OUTPUT«-1␤»

[01:21] <ShimmerFairy> m: use Test; is-approx i, <-1+0i> ** .5, 1e-6

[01:21] <camelia> rakudo-moar 6252fc: OUTPUT«ok 1 - ␤»

[01:21] <ShimmerFairy> close enough though :P

[01:21] <ShimmerFairy> (for some reason not specifying 1e-6 is broken with Test, even though that's the default)

[01:21] <BenGoldberg> m: (<-1> ** .5 ).say

[01:21] <camelia> rakudo-moar 6252fc: OUTPUT«NaN␤»

[01:21] <BenGoldberg> m: my $x = 2; my $y = 3; say ($x.$y); # imagine if this printed '2.3' ?

[01:21] <camelia> rakudo-moar 6252fc: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in block <unit> at /tmp/bzNQcKrh0m:1␤␤»

[01:22] <BenGoldberg> m: my $x = 2; my $y = 3; say($x.$y); # imagine if this printed '2.3' ?

[01:22] <camelia> rakudo-moar 6252fc: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in block <unit> at /tmp/X6TQ3o0npr:1␤␤»

[01:24] <ShimmerFairy> BenGoldberg: yeah, that's the one thing that makes me hesitant about making    -1    literal; it'd make '-' the only thing that's part of a literal *and* available as an operator :)

[01:25] <ShimmerFairy> say (<-1+0i> ** .5).reals».Rat.map({$^a + $^b\i})

[01:25] <ShimmerFairy> m: say (<-1+0i> ** .5).reals».Rat.map({$^a + $^b\i})

[01:25] <camelia> rakudo-moar 6252fc: OUTPUT«(0+1i)␤»

[01:25] <ShimmerFairy> BenGoldberg: for the record, piping the pieces of the Complex number through Rat happens to eliminate floating-point oddities ^^^ :)

[01:26] *** vendethiel left
[01:33] *** telex left
[01:34] *** telex joined
[01:35] <BenGoldberg> m: say (<-1+0i> ** .5).reals

[01:35] <camelia> rakudo-moar 6252fc: OUTPUT«(6.12323399573677e-17 1)␤»

[01:35] <BenGoldberg> m: say (<-1+0i> ** .5).reals>>.Rat

[01:35] <camelia> rakudo-moar 6252fc: OUTPUT«(0 1)␤»

[01:38] *** larion left
[01:39] <ShimmerFairy> BenGoldberg: I can't guarantee that Num->Rat will always do that, but in this case it happened to :)

[01:39] *** telex left
[01:40] *** telex joined
[01:40] <ShimmerFairy> ("that" being "remove some of the oddities that can appear in binary-based floating point numbers")

[01:41] *** telex left
[01:42] *** telex joined
[01:45] *** ilbot3 left
[01:45] *** colomon joined
[01:47] *** ilbot3 joined
[01:47] <BenGoldberg> m: Rat(1,1).say

[01:47] <camelia> rakudo-moar 6252fc: OUTPUT«2␤»

[01:47] <BenGoldberg> m: Rat(1,-1).say

[01:47] <camelia> rakudo-moar 6252fc: OUTPUT«2␤»

[01:48] <BenGoldberg> m: Rat(1).say

[01:48] <camelia> rakudo-moar 6252fc: OUTPUT«1␤»

[01:48] <BenGoldberg> m: Rat(-1).sqrt.say

[01:48] <camelia> rakudo-moar 6252fc: OUTPUT«NaN␤»

[01:53] *** dha joined
[02:00] *** mprelude left
[02:03] <dha> docs for C<while> and C<until> added.

[02:03] *** rangerprice joined
[02:04] <dha> You *can* git from an airplane!

[02:09] *** colomon left
[02:10] *** colomon joined
[02:13] <geekosaur> network no longer costs more than the plane tickets?

[02:13] <dalek> specs: bdbe964 | ShimmerFairy++ | S03-operators.pod:

[02:13] <dalek> specs: Add postfix:<i> to S03

[02:13] <dalek> specs: 

[02:13] <dalek> specs: It wasn't mentioned at all before, and since it's at the methodcall

[02:13] <dalek> specs: level in rakudo, which may not be expected at first, I figured it was

[02:13] <dalek> specs: worth mentioning. It also makes postfix:<i> the only operator at that

[02:13] <dalek> specs: level to not start with a dot, which seems like another noteworthy

[02:13] <dalek> specs: detail.

[02:13] <dalek> specs: review: https://github.com/perl6/specs/commit/bdbe9647f7

[02:20] *** telex left
[02:20] *** larion joined
[02:20] *** telex joined
[02:24] *** colomon left
[02:24] *** colomon joined
[02:31] *** telex left
[02:32] *** telex joined
[02:35] *** dha left
[02:37] *** colomon left
[02:48] *** noganex joined
[02:51] *** colomon joined
[02:52] *** noganex_ left
[02:59] *** dust_ joined
[03:11] *** telex left
[03:11] *** telex joined
[03:12] *** telex left
[03:14] *** telex joined
[03:15] *** rangerprice left
[03:17] *** colomon left
[03:22] *** telex left
[03:23] *** telex joined
[03:23] *** telex left
[03:24] *** telex joined
[03:27] <zostay> m: sub foo(Str() $s) { say $s }; foo(4)

[03:27] <yoleaux> 14 Sep 2015 19:40Z <jdv79> zostay: IO::Socket::INET seems a bit too specific

[03:27] <camelia> rakudo-moar ea2d21: OUTPUT«4␤»

[03:30] <zostay> !tell jv79 IO::Socket::INET is too specific, but using the Raw IO is completely the wrong solution always and the alternative is to be implementation-specific, which might as well not even be in the standard

[03:31] <dalek> nqp: 17b6555 | hoelzro++ | src/vm/js/nqp-runtime/deserialization.js:

[03:31] <dalek> nqp: Remove comments from JS backend

[03:31] <dalek> nqp: 

[03:31] <dalek> nqp: These are notes I was taking during my merge of the JS branch

[03:31] <dalek> nqp: that I forgot to remove

[03:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/17b6555833

[03:32] <zostay> .tell jdv79 IO::Socket::INET is too specific, but using the Raw IO is completely the wrong solution always and the alternative is to be implementation-specific, which might as well not even be in the standard

[03:32] <yoleaux> zostay: I'll pass your message to jdv79.

[03:36] *** larion left
[03:36] *** travis-ci joined
[03:36] <travis-ci> NQP build failed. Rob Hoelz 'Remove comments from JS backend

[03:36] <travis-ci> https://travis-ci.org/perl6/nqp/builds/81121244 https://github.com/perl6/nqp/compare/a2c05500a1f0...17b6555833df

[03:36] *** travis-ci left
[03:37] *** mr-foobar left
[03:48] <Zoffix> TigerDirect-- # 20 minutes between my call and "I dunno. OK. BAI!" EVGA++ # 20 minutes between "Fix my card. Dunno what you want" and "K. Send it here. We'll fix it" 

[03:52] *** Loren joined
[03:53] *** rurban joined
[04:01] *** telex left
[04:02] *** telex joined
[04:03] *** rurban left
[04:08] *** telex left
[04:08] *** telex joined
[04:09] *** telex left
[04:10] *** telex joined
[04:12] <TEttinger> Zoffix: good to know. I never know what companies have good customer service before it's too late

[04:16] *** frodwith left
[04:17] *** Peter_R left
[04:21] *** khw left
[04:26] *** rmgk is now known as Guest37138

[04:26] *** rmgk_ joined
[04:26] *** Guest37138 left
[04:26] *** rmgk_ is now known as rmgk

[04:31] *** vendethiel joined
[04:33] *** xinming_ joined
[04:36] *** xinming left
[04:37] *** BenGoldberg left
[04:37] *** telex left
[04:37] *** telex joined
[04:38] *** telex left
[04:40] *** telex joined
[04:47] *** Loren_ joined
[04:50] *** quester joined
[04:50] *** Loren left
[04:50] *** quester is now known as Guest63960

[04:53] *** Guest63960 left
[04:53] *** Guest63960 joined
[04:56] *** Guest63960 left
[04:56] *** vendethiel left
[04:57] *** quester joined
[04:57] *** quester is now known as Guest59677

[05:00] <dalek> roast: 3fdcdae | ShimmerFairy++ | S02-literals/allomorphic.t:

[05:00] <dalek> roast: Fix tests for GLR

[05:00] <dalek> roast: 

[05:00] <dalek> roast: This test file was forgotten in the merging mess surrounding allomorphs,

[05:00] <dalek> roast: so it took a while for this to show up.

[05:00] <dalek> roast: review: https://github.com/perl6/roast/commit/3fdcdae360

[05:01] *** Guest59677 left
[05:06] *** lolisa joined
[05:06] *** quester-temp joined
[05:07] *** quester-temp left
[05:08] *** quester joined
[05:08] *** telex left
[05:08] *** telex joined
[05:08] *** telex left
[05:10] *** telex joined
[05:11] *** perl6_newbee joined
[05:14] *** TEttinger left
[05:16] *** dustinm` joined
[05:17] <dalek> roast: 41fa6e7 | ShimmerFairy++ | S02-literals/allomorphic.t:

[05:17] <dalek> roast: Change complex number val() tests.

[05:17] <dalek> roast: 

[05:17] <dalek> roast: On second thought, it seems that stacking signs like was being tested

[05:17] <dalek> roast: isn't all that useful, so the tests in question have been changed to

[05:17] <dalek> roast: testing a different kind of complex number (one using Inf in the

[05:17] <dalek> roast: imaginary part).

[05:17] <dalek> roast: review: https://github.com/perl6/roast/commit/41fa6e7579

[05:18] *** telex left
[05:20] *** telex joined
[05:32] *** Sgeo left
[05:32] *** CurtisPoe left
[05:33] *** Sgeo joined
[05:33] <dalek> roast: 12fe957 | ShimmerFairy++ | S02-types/ (3 files):

[05:33] <dalek> roast: Fix plans in a few test files

[05:33] <dalek> roast: 

[05:33] <dalek> roast: These were forgotten about when various duplicate tests were removed.

[05:33] <dalek> roast: review: https://github.com/perl6/roast/commit/12fe957fb1

[05:43] <bartolin> could it be that eval-dies-ok and eval-lives-ok from Test.pm is busted (and has been for some time)? it seems that symbols from the surrounding scope are not known:

[05:44] <bartolin> m: use Test; my $a = 1; eval-dies-ok( '$a = 7' )

[05:44] <camelia> rakudo-moar ea2d21: OUTPUT«ok 1 - ␤»

[05:44] <bartolin> m: use Test; my $a = 1; eval-lives-ok( '$a = 7' )

[05:44] <camelia> rakudo-moar ea2d21: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/EAYzorI5Ow line 1␤# Error: Variable '$a' is not declared␤»

[05:44] <bartolin> star-m: use Test; my $a = 1; eval-dies-ok( '$a = 7' )

[05:44] <camelia> star-m 2015.03: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lcbJJuG6xn␤Undeclared routine:␤    eval-dies-ok used at line 1. Did you mean 'eval_dies_ok', 'eval_lives_ok'?␤␤»

[05:44] <bartolin> star-m: use Test; my $a = 1; eval_dies_ok( '$a = 7' )

[05:44] <camelia> star-m 2015.03: OUTPUT«ok 1 - ␤»

[05:45] <bartolin> star-m: use Test; my $a = 1; throws-like '$a = 7', Exception  # works for throws-like

[05:45] <camelia> star-m 2015.03: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5NDOMQiyA1␤Undeclared routine:␤    throws-like used at line 1. Did you mean 'throws_like'?␤␤»

[05:46] <bartolin> m: use Test; my $a = 1; throws-like '$a = 7', Exception  # works for throws-like

[05:46] <camelia> rakudo-moar ea2d21: OUTPUT«    1..2␤    not ok 1 - '$a = 7' died␤    ␤# Failed test ''$a = 7' died'␤# at /tmp/CPXtcpXSwR line 1␤    ok 2 - # SKIP Code did not die, can not check exception␤    # Looks like you failed 1 test of 2␤not ok 1 - did we throws-like Exception?…»

[05:47] *** skids left
[05:56] <bartolin> hmm, adding 'context => CALLER::CALLER::CALLER::' to the EVAL in eval_exception (Test.pm:484) seems to fix that.

[06:01] *** skids joined
[06:02] *** domidumont joined
[06:05] *** telex left
[06:06] <dalek> rakudo/nom: 9856a43 | TimToady++ | src/core/ (2 files):

[06:06] <dalek> rakudo/nom: change list associative reductions to onearg

[06:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9856a438b4

[06:06] *** telex joined
[06:06] *** laouji joined
[06:07] *** domidumont left
[06:08] *** domidumont joined
[06:16] *** telex left
[06:17] *** skids left
[06:18] *** telex joined
[06:27] <bartolin> with that change to Test.pm there are about a dozen spectest failures. (maybe wrong tests)

[06:29] *** pnu left
[06:30] *** pnu joined
[06:30] *** FROGGS left
[06:37] *** telex left
[06:37] *** telex joined
[06:37] *** telex left
[06:38] *** telex joined
[06:45] *** perl6_newbee left
[07:24] *** telex left
[07:26] *** telex joined
[07:28] <dalek> ecosystem: 133a138 | ugexe++ | META.list:

[07:28] <dalek> ecosystem: Update META.list

[07:28] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/133a1387d8

[07:28] *** hoelzro left
[07:28] *** hoelzro joined
[07:33] *** rindolf joined
[07:37] *** telex left
[07:38] *** telex joined
[07:39] *** leont joined
[07:47] <garu_> hi everyone! quick question: what's the most idiomatic way to fetch the last element of an array? Like $array[-1] in Perl 5

[07:50] *** CIAvash joined
[07:50] <ShimmerFairy> garu_: @array[*-1] (the * in this case means "number of elements")

[07:51] <mst> every time I see *, I think "and I thought $_ meant lots of things"

[07:51] <garu_> heh

[07:51] <mst> then again also every time I see *, I think "ooooh shiny"

[07:51] <mst> "this sword is double edged, what a surprise"

[07:52] <dalek> specs: 3bf2eb9 | (Stefan Seifert)++ | S07-lists.pod:

[07:52] <dalek> specs: Fix syntax error and add clarification in S07-lists

[07:52] <dalek> specs: review: https://github.com/perl6/specs/commit/3bf2eb9734

[07:52] <garu_> ShimmerFairy: thanks! Now that you mentioned it, I see it right there on the error message :)

[07:53] <ShimmerFairy> np :)

[07:54] *** telex left
[07:55] *** araujo joined
[07:55] *** araujo left
[07:55] *** araujo joined
[07:56] *** telex joined
[08:02] <lizmat> technically, *-1 creates a code object that takes a single parameter

[08:03] <lizmat> the slicing logic will call that with the number of elements

[08:03] <lizmat> but you can really do anything with this

[08:04] <lizmat> m: my @a = ^10; @a[ { say "got $^a" } ]

[08:04] <camelia> rakudo-moar 9856a4: OUTPUT«got 10␤»

[08:11] *** aborazmeh left
[08:12] *** darutoko joined
[08:16] *** Loren_ left
[08:18] *** telex left
[08:20] *** telex joined
[08:21] *** diana_olhovik_ joined
[08:28] *** TEttinger joined
[08:40] <nine> Should I rebase gmr onto nom before merging or merge nom into gmr?

[08:43] <timotimo> personally, i prefer rebasing

[08:47] <psch> hi #perl6 o/

[08:48] <psch> rebase both ways

[08:48] <timotimo> ohai psch

[08:48] <psch> always rebase everything!

[08:48] <timotimo> yeah, rebase nom onte gmr!

[08:48] <psch> and then back!

[08:48] <timotimo> draw a pretty picture in the history graph

[08:48] <ShimmerFairy> GitTurtle programming language

[08:59] <dalek> roast: b88cb33 | (Stefan Seifert)++ | S (3 files):

[08:59] <dalek> roast: Rename EnumMap to Map

[08:59] <dalek> roast: review: https://github.com/perl6/roast/commit/b88cb3356b

[08:59] <dalek> roast: 473e246 | (Stefan Seifert)++ | S (7 files):

[08:59] <dalek> roast: Merge Enum into Pair

[08:59] *** dalek left
[08:59] *** dalek joined
[08:59] *** ChanServ sets mode: +v dalek

[09:00] <timotimo> in the past i've tended to build "new" branches with "_2", "_3", .. whenever i've rebased things i expect others would already have played with

[09:00] <timotimo> but if you're going to merge the stuff into nom anyway, there's no need for that

[09:00] <nine> https://github.com/rakudo/rakudo/commit/7ee6ef9 Remove PairMap - its use case is unclear and it's untested

[09:00] <nine> https://github.com/rakudo/rakudo/commit/0d40e00 Fix return 1, :a(2)

[09:00] <nine> https://github.com/rakudo/rakudo/commit/0f699bb Make %hash.pairs .value writable

[09:00] <nine> https://github.com/rakudo/rakudo/commit/0e0495e Fix passing adverbs to 'import' and 'no' statements

[09:00] <nine> https://github.com/rakudo/rakudo/commit/5256ed6 Fix {:a(1) :b(2)} dieing due to missing value arg to Pair.new

[09:01] <nine> https://github.com/rakudo/rakudo/commit/86536d2 Fix (:a(1) :b(2)) dieing due to missing value arg to Pair.new

[09:01] <nine> https://github.com/rakudo/rakudo/commit/de907e5 Fix use Foo :whatever<1> losing the adverb's value

[09:01] <nine> https://github.com/rakudo/rakudo/commit/4023a33 Make :a($i) and a => $i mutable like 'a' => $i

[09:01] <nine> https://github.com/rakudo/rakudo/commit/2232157 Merge Enum into Pair

[09:01] <pink_mist> nine++

[09:01] <ShimmerFairy> The advice I've seen (and agree with): rebase unless/until you've pushed the stuff-to-rebase somewhere, at which point it saves everyone grief to just merge

[09:03] <nine> Makes sense, yes.

[09:03] <ShimmerFairy> Even then, I don't think merging is as bad as some people would like to make it out to be :)

[09:05] <ShimmerFairy> (merging feels more natural as a way of saying "I am taking this feature I've been working on, and moving it into the mainline" to me, for example, and unlike rebasing explains the time warping you'll see in commit timestamps ☺)

[09:05] *** vendethiel joined
[09:06] <nine> Well you have to merge the feature branch into the mainline even after rebasing it. I should have used --no-ff though to get a proper merge commit. OTOH half of gmr's commits were fixes that would have been good to have even without the gmr.

[09:06] *** diana_olhovik_ left
[09:06] <nine> So it wouldn't have made as much sense to revert the whole merge

[09:09] *** diana_olhovik joined
[09:09] <nine> And 2 tickets closed by the gmr :)

[09:10] <psch> huh, IntStr has a P6OpaqueDelegateInstance in field_0 during construction..?  

[09:10] <psch> does that make sense..? :/

[09:11] *** telex left
[09:12] *** telex joined
[09:15] <timotimo> daleninek?

[09:21] <psch> ...and P6bigint.c isn't really helpful :/

[09:21] <psch> the thing that i'm kind of hung up on right now is

[09:21] <timotimo> you may want to look into P6Opaque instead?

[09:22] <timotimo> to find out how these things work?

[09:22] <psch> yesterday i had a case where REPRData.unboxIntSlot had the right hint for the field the bigint should go in

[09:22] <timotimo> that should be the common case, no?

[09:22] <psch> but i forgot the exact case, and the one i use now doesn't have it

[09:23] <psch> i'm guessing &val and <0> do it differently somehow, still

[09:23] <psch> but even if that hint is there it's still wonky, cause we want to bind_native

[09:24] <psch> but IntStr has a P6opaque in field_1 that has the BigInteger in field_0

[09:24] <psch> or "had", rather, in cases where it worked

[09:24] <psch> but Int has a BigInteger in field_0

[09:25] <psch> which i guess is not-quite-right composition

[09:25] <psch> and composition being wonky would also explain why we get a delegateInstance in field_0 - and not in .delegate

[09:26] <psch> well, excepting the (reasonable) explanation "psch doesn't really get it, it's fine" :P

[09:29] <timotimo> huh

[09:29] * timotimo doesn't knows

[09:30] <psch> P6opaque.c looks like i'd expect it - it checks unbox_int_slot and gets the bigint from there

[09:30] <timotimo> yeah

[09:32] <psch> which means the IntStr type doesn't get the right hints on jvm, but does on moar

[09:34] <timotimo> OK, that may be a good hint perhaps

[09:36] <psch> it's puzzling, cause seeing the fitting unboxIntSlot in the debugger is what made me rewrite my impl from "iterate the reflected fields and check their type" to "check for the slot in the REPRData"

[09:37] <timotimo> we're supposed to have only one slot for every kind of unboxing operation, so that'd make sense

[09:37] <timotimo> at least that's how moar does it, as you've figured out for yourself, too

[09:39] <psch> i mean, all unbox*Slot are -1, so none get set apparently

[09:39] <psch> that's with &val and <0>, so potential differences in object construction there aren't it :s

[09:39] <timotimo> very strange

[09:39] *** [Sno] left
[09:40] *** [Sno] joined
[09:42] *** spider-mario joined
[09:43] <ShimmerFairy> psch: have you tried seeing what happens with the older version of IntStr construction? It won't work when you want bigger-than-native integers, but does a construction process mirroring the other allomorphs still cause problems?

[09:44] <psch> ShimmerFairy: oh, you mean without the add_I workaround?  i expect that to not hit the same code path at all

[09:45] <psch> ShimmerFairy: but the getBI/makeBI bits are what's wonky in the first place

[09:46] <ShimmerFairy> psch: yes, that's what I mean. I also wonder what would happen if IntStr did nqp::create like the other types, but still did add_I to actually set the Int part.

[09:46] <ShimmerFairy> psch: OK. I've gotten the feeling that it's the VM's fault, but admittedly the IntStr is being constructed a bit weirdly :)

[09:46] <psch> ShimmerFairy: well, it's not the VM, it's our bigint handling :)

[09:47] <psch> ShimmerFairy: nqp::create would only add another (unused) allocation, makeBI allocates as well

[09:47] <ShimmerFairy> psch: it's the VM's fault for not making bigints easier at first implementation :P

[09:52] <psch> ShimmerFairy: idk, the first implementation was really easy and worked :P

[09:53] <psch> well, until we had IntStr that is

[09:53] *** cognominal joined
[09:54] <timotimo> i'm glad you're doing it, psch 

[09:54] <timotimo> i mean, working on fixing the JVM port of rakudo

[09:54] <moritz> psch: just wait for intInt, the new type with a native int and a bigint slot, hold separate values 50% of the time

[09:54] <moritz> :-)

[09:55] *** mprelude joined
[09:58] <timotimo> and also the AtAt class that represents objects that have two locations in physical memory

[09:59] <psch> and ObjAtAt that points at the ObjAt

[09:59] <timotimo> and, of course, AtSt which points at an object's STable's memory location

[10:00] <_itz> I assume GMR fallout might be less pain than GLR?

[10:00] <psch> oh right

[10:00] <timotimo> much, much, much less

[10:00] <timotimo> probably not noticable

[10:00] <_itz> :D

[10:01] <psch> and then we can implement polymorphic objects that use an algorithm adapted from C3MRO to find their REPRs, and call them C3PO right

[10:01] <timotimo> yes.

[10:03] *** telex left
[10:03] <erxeto> moritz: thsnka for the patch on DBIish. Now Task::Star installation completes without issues.

[10:03] <erxeto> thanks*

[10:03] <timotimo> sweet

[10:04] *** telex joined
[10:11] <moritz> erxeto: you're welcome

[10:14] <dalek> star/panda-bootstrap: 7b2465c | moritz++ | tools/star/release-guide.pod:

[10:14] <dalek> star/panda-bootstrap: Wee correction in the release guide

[10:14] <dalek> star/panda-bootstrap: 

[10:14] <dalek> star/panda-bootstrap: since there is no more PARROT_VERSION to adjust, there are only three lines

[10:14] <dalek> star/panda-bootstrap: to change

[10:14] <dalek> star/panda-bootstrap: review: https://github.com/rakudo/star/commit/7b2465c7a2

[10:18] <dalek> star: 06f75c4 | moritz++ | tools/build/panda-state.p6:

[10:18] <dalek> star: Socket.send is now .print

[10:18] <dalek> star: review: https://github.com/rakudo/star/commit/06f75c42eb

[10:19] *** leont left
[10:20] *** telex left
[10:20] *** telex joined
[10:20] *** telex left
[10:22] *** telex joined
[10:22] <dalek> rakudo/nom: a3962b0 | (Stefan Seifert)++ | src/core/IO/Handle.pm:

[10:22] <dalek> rakudo/nom: Fix IO::Handle not correctly limiting lines in batch processing

[10:22] <dalek> rakudo/nom: 

[10:22] <dalek> rakudo/nom: The iterator's push-all did not actually stop iteration when $!todo got down

[10:22] <dalek> rakudo/nom: to 0. Also it did not close the file handle on reaching eof despite being asked

[10:22] <dalek> rakudo/nom: to do so.

[10:22] <dalek> rakudo/nom: 

[10:22] <dalek> rakudo/nom: Fixes regression in S16-filehandles/io.t

[10:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a3962b0548

[10:23] <moritz> isn't it wonderful that we have tests? :-)

[10:24] <ShimmerFairy> moritz: and so many! :)

[10:27] <nine> If only we could have more of them.

[10:28] *** telex left
[10:28] <nine> The closing the file handle part is not covered by any test

[10:28] *** telex joined
[10:28] *** telex left
[10:30] *** telex joined
[10:40] *** domidumont left
[10:40] *** vendethiel left
[10:43] <cognominal> Where is the S[] = ...    with the upper case S documented in the synopses?

[10:43] <timotimo> that's just the "sequential" metaop

[10:43] <timotimo> right?

[10:43] <timotimo> but i haven't seen it used in that way yet

[10:44] <ShimmerFairy> timotimo: perhaps the S/// non-mutating substitution

[10:44] <psch> S03:Sequential_Operators

[10:44] <cognominal> I see it alright in the grammar and actions  https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L6803  but not in roast or the spec. I probably don't know where to look

[10:44] <psch> vOv

[10:44] <psch> http://design.perl6.org/S03.html#Sequential_operators

[10:44] <psch> but there's also S///, as ShimmerFairy says

[10:44] <timotimo> oh, of course

[10:45] <timotimo> in that case it's the non-mutating substitution

[10:45] <psch> m: $_ = "foo"; say S[o] = "O"

[10:45] <camelia> rakudo-moar 7ee6ef: OUTPUT«fOo␤»

[10:46] <psch> m: $_ = "foo"; say S[o] = "O"; .say

[10:46] <camelia> rakudo-moar 7ee6ef: OUTPUT«fOo␤foo␤»

[10:46] <cognominal> m: $_ = "foo"; say s[o] = "O"; .say

[10:46] <camelia> rakudo-moar 7ee6ef: OUTPUT«｢o｣␤fOo␤»

[10:47] <psch> S/// is .subst, s/// is .subst-mutate

[10:47] <cognominal> ok

[10:50] *** perl6_newbee joined
[10:50] <masak> right, it's what the /r flag does in Perl 5.

[10:55] *** TEttinger left
[10:56] *** telex left
[10:58] *** telex joined
[11:01] <moritz> ARGL, why do we have both Term::ANSIColor and Terminal::ANSIColor in the ecosystem?

[11:02] <moritz> of course this makes a star relase harder :(

[11:03] *** fling joined
[11:03] *** fling left
[11:03] *** fling joined
[11:04] <ShimmerFairy> moritz: because it was suddenly a bad thing for "Term" to be a name in modules. Somehow.

[11:05] <moritz> though  Term::ColorText,  Term::ProgressBar and Term::termios don't seem to be particularly bad

[11:06] <dalek> star: 4051620 | moritz++ | / (3 files):

[11:06] <dalek> star: Bump some versions

[11:06] <dalek> star: review: https://github.com/rakudo/star/commit/405162034b

[11:06] <dalek> star: 9c32c32 | moritz++ | modules/ (27 files):

[11:06] <dalek> star: Update submodules

[11:06] <dalek> star: review: https://github.com/rakudo/star/commit/9c32c326eb

[11:06] <ShimmerFairy> moritz: yep, IIRC the reason was this "but there's a name called 'term' in the grammar!!!" or something along those lines, which I don't buy at all.

[11:07] <ShimmerFairy> (Term::ColorText is mine, and damned if I rename it)

[11:08] *** jack_rabbit_ joined
[11:10] <dalek> star: 8b1cb9f | moritz++ | / (4 files):

[11:10] <dalek> star: Use Terminal::ANSIColor instead of Term::ANSIColor

[11:10] <dalek> star: 

[11:10] <dalek> star: Grammar::Debugger has changed its dependency. Because reasons.

[11:10] <dalek> star: review: https://github.com/rakudo/star/commit/8b1cb9fb0e

[11:13] <moritz> Testing modules/p6-file-directory-tree with /home/moritz/p6/star/install/bin/perl6-m...

[11:13] <moritz> done without supply or react in block <unit> at t/basic.t:26  

[11:14] <moritz> .tell labster any chance you could merge https://github.com/labster/p6-file-directory-tree/pull/5 soonish? It would help with the Rakudo Star release

[11:14] <yoleaux> moritz: I'll pass your message to labster.

[11:16] <moritz> panda and Template::Mustache use JSON::Fast, while jsonrpc still uses JSON::Tiny

[11:16] <moritz> I guess for now star will have to ship both :(

[11:16] <moritz> (unless we drop jsonrpc)

[11:26] *** larion joined
[11:31] *** telex left
[11:32] *** telex joined
[11:45] * jnthn wondered why the Term/Terminal bikeshed pointlessness

[11:46] <jnthn> I only accepted the PR to stop my module give people a warning, not 'cus I thought the name change made sense.

[11:52] *** z448 joined
[11:53] *** kid51 joined
[11:54] *** Marius joined
[11:54] *** Marius is now known as Guest19613

[11:54] <Guest19613> Marius1984

[11:55] <Guest19613> Identificar Marius1984

[11:55] <timotimo> you change your nickname by typing /nick Marius1984

[11:56] <DrForr> Or more pertinently /msg nickserv help

[11:56] *** Guest19613 left
[11:57] *** rindolf left
[11:58] <z448> p6: say something

[11:58] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Undeclared routine:␤    something used at line 1␤␤»

[11:58] <z448> p6: say 'something';

[11:58] <camelia> rakudo-moar a3962b: OUTPUT«something␤»

[11:59] * psch /o\

[12:00] *** CIAvash left
[12:01] <ShimmerFairy> jnthn: that was what I recall btw. I can't fathom why 'Term' and 'term' could ever be a problem, esp. since we're not a case-insensitive language :)

[12:05] *** z448 left
[12:07] <timotimo> i didn't even know we changed the name; i thought someone came up with a distinct Terminal::ANSIColor

[12:08] *** rindolf joined
[12:08] <ShimmerFairy> nah, it's just the result of pointless bikeshedding :)

[12:09] <timotimo> this is the perfect opportunity to model and implement "provides"

[12:09] <timotimo> Terminal::ANSIColor provides Term::ANSIColor

[12:14] <jnthn> &

[12:15] *** colomon joined
[12:16] *** kanishka joined
[12:16] *** vendethiel joined
[12:25] *** telex left
[12:26] *** telex joined
[12:35] <tadzik> timotimo: the idea to change the name is that Term is a thing in perl 6

[12:36] <tadzik> as in term 'self' or so

[12:36] <timotimo> oh

[12:36] *** Andrie joined
[12:36] <timotimo> that sounds kind of sensible

[12:36] * timotimo puts down pitchfork and torch

[12:37] *** Andrie left
[12:37] <ShimmerFairy> tadzik: still not convincing for me. 'Term' is not a thing in standard P6, and I don't buy that someone will mistake Term::ANSIColor for implementing a term, for example.

[12:37] <tadzik> so we might have eventually Operator::plusminus and Term::thyself or so

[12:38] <tadzik> ShimmerFairy: it's not a matter of mistaking it's that Term may become useful for us in module space, and I think it's good to disambiguate Terminal

[12:38] <ShimmerFairy> But it already is useful, as meaning Term[inal] :)

[12:38] <tadzik> heh :)

[12:39] *** larion left
[12:39] <tadzik> maybe we should use some unicode monospace characters that read Term

[12:39] <ShimmerFairy> (and there's no law saying we have to make sure a part of a longname has an entirely, 100% unique and singular meaning)

[12:39] <timotimo> why don't we have a version of Term::ANSIColor that exports the colors as terms? :P

[12:39] <tadzik> timotimo: that... is brilliant

[12:39] <timotimo> Termi, termn, Terma, terml?

[12:40] <tadzik> Term::inator

[12:40] <tadzik> that'd be a module for terming

[12:40] *** vendethiel left
[12:40] *** mr_ron joined
[12:40] *** Goblin_ joined
[12:41] <Goblin_> How to convert string into array of chars?

[12:41] <tadzik> .comb should work

[12:41] <tadzik> m: "foobar".comb.perl.say

[12:41] <camelia> rakudo-moar a3962b: OUTPUT«("f", "o", "o", "b", "a", "r").Seq␤»

[12:41] <tadzik> fsvo array

[12:42] <timotimo> well, if you assign it to a @foo, you'll get a proper array

[12:42] <timotimo> but oftentimes you don't need that

[12:42] *** tomboh joined
[12:43] <colomon> m: my @a = “foobar”.comb; dd @a

[12:43] <camelia> rakudo-moar a3962b: OUTPUT«Array @a = ["f", "o", "o", "b", "a", "r"]␤»

[12:43] <colomon> indeed.  :)

[12:43] <_itz>  maybe contraversial but 

[12:43] <_itz> https://github.com/rakudo/star/pull/50

[12:43] <tomboh> I have installed rakudo and moarvm on freebsd, and I'm seeing t/04-nativecall/16-rt125408.t fail - is this a known problem?

[12:44] <timotimo> i'm not against that

[12:44] <tomboh> I don't see anything in RT but I thought I'd ask here before submitting a new bug report

[12:44] <colomon> _itz: I don’t think there’d be anything contraversial at all if you just added the SPW slides.  (Presuming we have jnthn++’s permission.)

[12:45] <_itz> good point we should at least ask :)

[12:46] *** Marius joined
[12:46] *** Marius is now known as Guest95184

[12:46] <Guest95184> Hack bank BPI whit Marius1984 

[12:47] <psch> tomboh: the filename is a ticket number, RT #125408

[12:47] <psch> tomboh: it's closed though, and i'm not sure if you can request reopen on RT directly

[12:47] <psch> (https://rt.perl.org/Public/Bug/Display.html?id=125408)

[12:48] <_itz> jnthn: can we use your SWP slides as a replacement (for the time being) for the draft book pdf in star please?

[12:48] <_itz> ^ SPW

[12:48] <tomboh> psch: sure, I gather the test is a regression test to ensure the fix for rt#125408 doesn't break - and I'm seeing it fail

[12:50] *** Psyche^_ joined
[12:51] <tomboh> oh, but that was only fixed on Thursday - I'll do a fresh "git pull" and retest

[12:53] *** telex left
[12:53] <tomboh> psch: thank you, "All tests successful." :)

[12:55] *** telex joined
[12:55] *** telex left
[12:56] *** telex joined
[12:57] *** Guest95184 left
[12:59] *** pmurias joined
[12:59] <pmurias> (Term::ANSIColor rename)--

[13:00] *** vendethiel joined
[13:03] <pmurias> there is already Term::Curses 

[13:06] <pmurias> there is always Lang::Term:: for linguistic usage

[13:08] <timotimo> mhm

[13:08] *** larion joined
[13:10] <dalek> star: e933fca | moritz++ | / (3 files):

[13:10] <dalek> star: Ship JSON::Fast with Star

[13:10] <dalek> star: 

[13:10] <dalek> star: panda and Template::Mustache (included from Bailador) depend on it

[13:10] <dalek> star: review: https://github.com/rakudo/star/commit/e933fcacca

[13:16] *** frodwith joined
[13:16] *** pmurias left
[13:19] *** telex left
[13:20] *** telex joined
[13:28] *** mr_ron left
[13:31] *** diana_olhovik left
[13:40] *** Goblin_ left
[13:41] *** laouji left
[13:44] *** Goblin_ joined
[13:44] <Goblin_> How to generate all possible permutations of characters with a given minimum and maximum length?

[13:45] *** nuc joined
[13:48] *** Marius joined
[13:48] *** Marius is now known as Guest55267

[13:50] <colomon> Goblin_: of a given set of characters?

[13:50] <Goblin_> yes

[13:51] <colomon> Goblin_: http://doc.perl6.org/routine/combinations

[13:52] <colomon> m: say (‘a’ .. ‘f’).combinations(3..4).perl

[13:52] <camelia> rakudo-moar a3962b: OUTPUT«(("a", "b", "c"), ("a", "b", "d"), ("a", "b", "e"), ("a", "b", "f"), ("a", "c", "d"), ("a", "c", "e"), ("a", "c", "f"), ("a", "d", "e"), ("a", "d", "f"), ("a", "e", "f"), ("b", "c", "d"), ("b", "c", "e"), ("b", "c", "f"), ("b", "d", "e"), ("b", "d", "f"), …»

[13:52] <colomon> oh, wait, you want permutations.

[13:52] <colomon> m: say (‘a’ .. ‘f’).permutations(3..4).perl

[13:52] <camelia> rakudo-moar a3962b: OUTPUT«Cannot call permutations(List: Range); none of these signatures match:␤    (List $: *%_)␤  in block <unit> at /tmp/KUHFfrwMSI:1␤␤»

[13:52] <colomon> m: say (‘a’ .. ‘f’).permutations(3).perl

[13:52] <camelia> rakudo-moar a3962b: OUTPUT«Cannot call permutations(List: Int); none of these signatures match:␤    (List $: *%_)␤  in block <unit> at /tmp/ID80shav9d:1␤␤»

[13:53] <psch> m: say (‘a’ .. ‘f’).permutations().perl

[13:53] <camelia> rakudo-moar a3962b: OUTPUT«(("a", "b", "c", "d", "e", "f"), ("a", "b", "c", "d", "f", "e"), ("a", "b", "c", "e", "d", "f"), ("a", "b", "c", "e", "f", "d"), ("a", "b", "c", "f", "d", "e"), ("a", "b", "c", "f", "e", "d"), ("a", "b", "d", "c", "e", "f"), ("a", "b", "d", "c", "f", "e"),…»

[13:53] <colomon> m: say (‘a’ .. ‘f’).permutations().perl

[13:53] <camelia> rakudo-moar a3962b: OUTPUT«(("a", "b", "c", "d", "e", "f"), ("a", "b", "c", "d", "f", "e"), ("a", "b", "c", "e", "d", "f"), ("a", "b", "c", "e", "f", "d"), ("a", "b", "c", "f", "d", "e"), ("a", "b", "c", "f", "e", "d"), ("a", "b", "d", "c", "e", "f"), ("a", "b", "d", "c", "f", "e"),…»

[13:53] *** laouji joined
[13:54] <colomon> hmmm… may have to play around a bit to get a combination of those two things….

[13:54] <timotimo> no, i think he does want combinations, not permutations

[13:54] <timotimo> otherwise "minimum and maximum length" don't make sense

[13:55] <timotimo> oh, but maybe no repetition is wanted?

[13:55] <DrForr> I'd guess 'aaa', 'aab'..'fffe','ffff' for password generation?

[13:55] <Goblin_> yes

[13:58] *** laouji left
[13:58] <timotimo> ah

[13:58] <timotimo> well, that's just 'aaa'..'zzzzz' in that case

[13:59] <timotimo> m: say ("aa".."zzz").perl

[13:59] <camelia> rakudo-moar a3962b: OUTPUT«"aa".."zzz"␤»

[13:59] <timotimo> m: say ("aa".."zzz").list.perl

[13:59] <moritz> m: say join '', ('a'..'z').roll((3..5).pick)

[13:59] <camelia> rakudo-moar a3962b: OUTPUT«("aa", "ab", "ac", "ad", "ae", "af", "ag", "ah", "ai", "aj", "ak", "al", "am", "an", "ao", "ap", "aq", "ar", "as", "at", "au", "av", "aw", "ax", "ay", "az", "ba", "bb", "bc", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bk", "bl", "bm", "bn", "bo", "bp", "bq…»

[13:59] <camelia> rakudo-moar a3962b: OUTPUT«uiiq␤»

[13:59] <timotimo> ah, there you can't really see it get longer

[13:59] <moritz> huh

[13:59] <timotimo> m: say ("aa".."ccc").list.perl

[13:59] <camelia> rakudo-moar a3962b: OUTPUT«("aa", "ab", "ac", "ad", "ae", "af", "ag", "ah", "ai", "aj", "ak", "al", "am", "an", "ao", "ap", "aq", "ar", "as", "at", "au", "av", "aw", "ax", "ay", "az", "ba", "bb", "bc", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bk", "bl", "bm", "bn", "bo", "bp", "bq…»

[13:59] <timotimo> oh, and there it does a-z, too

[14:00] *** cognominal left
[14:00] *** dust_ left
[14:00] *** cognominal joined
[14:02] *** telex left
[14:02] <psch> m: say join '', ('a'..'z').roll((3..5).pick(5))

[14:02] <camelia> rakudo-moar a3962b: OUTPUT«gqh␤»

[14:02] <psch> oh right

[14:02] <psch> m: say join '', ('a'..'z').roll((3..5).pick)[^5]

[14:02] <camelia> rakudo-moar a3962b: OUTPUT«quk␤»

[14:02] <psch> m: say ('a'..'z').roll((3..5).pick)[^5]

[14:02] <camelia> rakudo-moar a3962b: OUTPUT«(c b t t)␤»

[14:02] <psch> m: say ('a'..'zzzz').roll((3..5).pick)[^5]

[14:03] <psch> timeout \o/

[14:03] *** Goblin_ left
[14:03] <camelia> rakudo-moar a3962b: OUTPUT«(timeout)»

[14:03] <psch> well, yeah, to be expected...

[14:04] *** telex joined
[14:12] *** mr_ron joined
[14:12] *** Sqirrel_ left
[14:19] <moritz> it needs to generate the whole list to even know the propability to pick one

[14:21] <DrForr> Isn't there an old interview question showing how to get around that? Something like "Choose an item from an arbitrarily long list with equal probability to each entry?" Something like the equivalent of for(@x){rand(1/$.) and return $_} (though $. doesn't work for arrays, and it's perl5.)

[14:24] <lucs> DrForr: I believe you need to know when you've reached the end of that arbitrarily long list for that technique to work.

[14:24] *** laouji joined
[14:25] <DrForr> Entirely possible, it's been a long time since I've had to deal with that interview question.

[14:28] <dalek> star: f86f204 | (Steve Mynott)++ | docs/ (2 files):

[14:28] <dalek> star: Replace draft book (not currently actively maintained) by jnthn's Swiss

[14:28] <dalek> star: Perl Workshop Perl 6 slides (which is much more up to date).

[14:28] <dalek> star: review: https://github.com/rakudo/star/commit/f86f204717

[14:28] <dalek> star: a738fc9 | moritz++ | docs/ (2 files):

[14:28] <dalek> star: Merge pull request #50 from stmuk/master

[14:28] <dalek> star: 

[14:28] <dalek> star: Replace draft book by SWP slides

[14:28] <dalek> star: review: https://github.com/rakudo/star/commit/a738fc9f2b

[14:52] *** telex left
[14:52] *** zakharyas joined
[14:54] *** telex joined
[14:55] <moritz> anyone want to write a release announcment for the 2015.09 star release?

[14:58] *** Skarsnik joined
[15:05] <Skarsnik> Hello. How do I get the type of an attribute? (getting it from MyClass.^attributes) $attr.WHAT give me.. Attribute

[15:06] <moritz> Skarsnik: it seems that's not exposed yet

[15:07] <psch> m: class A { has Int $!foo }; A.^attributes[0].type.say

[15:07] <camelia> rakudo-moar a3962b: OUTPUT«(Int)␤»

[15:07] <moritz> m: say Atribute.^can('type')

[15:07] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/PyptEZTlbG␤Undeclared name:␤    Atribute used at line 1. Did you mean 'Attribute'?␤␤»

[15:07] <moritz> m: say Attribute.^can('type')

[15:07] <camelia> rakudo-moar a3962b: OUTPUT«(<anon>)␤»

[15:07] <Skarsnik> oh there is a .type?

[15:07] <moritz> seems like it

[15:07] <moritz> m: say Int.^attributes[0].type

[15:07] <camelia> rakudo-moar a3962b: OUTPUT«Method 'gist' not found for invocant of class 'bigint'␤  in block <unit> at /tmp/IAxlHLc7NV:1␤␤»

[15:08] *** khw joined
[15:08] <moritz> ah, bootstrapping

[15:08] <psch> yeah, that's bigint $!value

[15:08] <masak> some 'gist' methods still missing.

[15:08] <moritz> m: say Enum[C.^attributes[0].type

[15:08] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5QL6R9_krV␤Bogus postfix␤at /tmp/5QL6R9_krV:1␤------> 3say Enum7⏏5.^attributes[0].type␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤   …»

[15:08] <moritz> m: say Enum.^attributes[0].type

[15:08] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/gleQBHt7Ye␤Undeclared name:␤    Enum used at line 1. Did you mean 'num'?␤␤»

[15:08] <masak> m: say Int.^attributes[0].type.^name

[15:08] <camelia> rakudo-moar a3962b: OUTPUT«bigint␤»

[15:10] <psch> m: say Int.^attributes[0].^attributes[2].type.^name

[15:10] <camelia> rakudo-moar a3962b: OUTPUT«Mu␤»

[15:10] <psch> that's $!descriptor, iirc :P

[15:10] <psch> m: say Int.^attributes[0].^attributes[2].name

[15:10] <camelia> rakudo-moar a3962b: OUTPUT«$!box_target␤»

[15:10] <psch> ah, now

[15:10] <psch> -w

[15:10] <psch> m: say Int.^attributes[0].^attributes>>.name

[15:10] <camelia> rakudo-moar a3962b: OUTPUT«($!name $!type $!box_target $!package $!inlined)␤»

[15:11] * psch shrugs

[15:11] <moritz> m: say Attribute.^methods(:local)>>.name

[15:11] <camelia> rakudo-moar a3962b: OUTPUT«(<anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> <anon> compose apply_handles get_value set_value container has-accessor readonly package inlined WHY set_why Str gist)␤»

[15:12] <Skarsnik> I got a weird error too: I have sub plain_attr(Hash $opt, Attribute @tab). If I write plain_attr({}, MyClass.^attributes) I got a type check error, but if I write the Attribute @tab=  MyClass.^attributes and call the sub with the @tab it work

[15:13] <dalek> doc: 99aef50 | moritz++ | lib/Type/Attribute.pod:

[15:13] <dalek> doc: Document Attribute.type

[15:13] <dalek> doc: review: https://github.com/perl6/doc/commit/99aef50e03

[15:13] <moritz> Skarsnik: I'll have to write an FAQ entry for that one, I fear :(

[15:13] <psch> m: my Attribute @foo; say Int.^attributes.WHAT; say @foo.WHAT 

[15:13] <camelia> rakudo-moar a3962b: OUTPUT«(List)␤(Array[Attribute])␤»

[15:14] *** Guest55267 left
[15:14] <psch> m: say List ~~ Array[Attribute].new 

[15:14] <camelia> rakudo-moar a3962b: OUTPUT«False␤»

[15:14] <psch> m: say Array[Attribute].new ~~ List

[15:14] <camelia> rakudo-moar a3962b: OUTPUT«True␤»

[15:14] <moritz> Skarsnik: if you have a paramter typed 'Attribute @thing', then it'll only accept arguments of type Positional[Attribute] (or subtypes thereof, such as List[Attribute]

[15:15] <Skarsnik> Type check failed in binding @tab; expected 'Positional[Attribute]' but got 'Parcel'

[15:15] <psch> makes me wonder if we want CORE to return narrowly typed lists...

[15:15] <moritz> Skarsnik: the difference is that *assignment* to an array is coercive, so it doesn't matter what the right-hand side is typed

[15:15] <psch> probably not, even ignoring performance

[15:15] <moritz> Skarsnik: oh, and your rakudo is too old

[15:15] *** mr_ron left
[15:16] *** zakharyas left
[15:16] <Skarsnik> I don't know. I install perl6 with a script from perl6.org like 2 month ago ~~

[15:17] <psch> hm, is parameterized type coercion design..?

[15:17] <moritz> psch: no

[15:17] <psch> m: Array[Int](@(1, 2, 3)) # somewhat like this

[15:17] <camelia> rakudo-moar a3962b: OUTPUT«Type check failed in assignment to ''; expected 'Int' but got 'List'␤  in block <unit> at /tmp/Nt3naZeWF6:1␤␤»

[15:17] <moritz> psch: see http://www.nntp.perl.org/group/perl.perl6.users/2015/07/msg2155.html for my rant

[15:18] <Skarsnik> it's pretty... unatural? unexpected? x)

[15:19] <moritz> Skarsnik: I know; assignment to arrays is coercive, so people are surprised with (signature-)binding to arrays isn't

[15:21] <Skarsnik> It's more for me an Array is an ..Array. why would it be weird subtype that I have to pay attention?

[15:21] <psch> Skarsnik: a (workable but clumsy) comparison is Java generics

[15:22] <psch> Skarsnik: an ArrayList<Object> can be assigned an ArrayList<Integer>, but an ArrayList<Integer> can't be assigned an ArrayList<Object>

[15:23] <psch> Skarsnik: and any literal array in perl6 is pretty much an Array[Any]

[15:24] <psch> moritz: i think i had read your rant once already... i have to admit the approach mused about seems tempting, but i can't see the bits of the Binder i know work good with it - not to speak of those i don't...

[15:25] <psch> so, yeah, "if you want to have typed arrays in your signatures, declare the arrays you want to pass as typed as well"

[15:25] <psch> m: sub f(Int @a) { say [+] @a }; my Int @b = 1, 2, 3; f @b

[15:25] <camelia> rakudo-moar a3962b: OUTPUT«6␤»

[15:25] <psch> m: sub f(Int @a) { say [+] @a }; my  @b = 1, 2, 3; f @b

[15:25] <camelia> rakudo-moar a3962b: OUTPUT«Type check failed in binding @a; expected 'Positional[Int]' but got 'Array'␤  in sub f at /tmp/fkBHZ2t0_L:1␤  in block <unit> at /tmp/fkBHZ2t0_L:1␤␤»

[15:26] <Skarsnik> but if the core class does not give typed thing. It make the whole type stuff useless

[15:26] <psch> m: sub f(@a where all(@a) ~~ Int) { say [+] @a }; my  @b = 1, 2, 3; f @b

[15:26] <camelia> rakudo-moar a3962b: OUTPUT«6␤»

[15:28] <psch> Skarsnik: i don't agree that it makes "the whole type stuff" useless

[15:28] <moritz> psch: I wrote that before I knew that the PositionalBindFailover trick was possible

[15:28] <Skarsnik> it make it a struggle

[15:29] <moritz> Skarsnik: only if you overdo it

[15:29] <TimToady> by putting the type on the receiving end and not the sending end, you're just violating postel's law

[15:29] <moritz> Skarsnik: it takes some time to find the sweet spot between too much and too little type-constraining

[15:30] <Skarsnik> but it's the core fault if ^attributes is not typed, no mine

[15:30] <moritz> Skarsnik: it's not documented to return a typed list, so there is no fault.

[15:30] <psch> Skarsnik: i think postel's law is bad advice

[15:30] <psch> oh

[15:30] <psch> err

[15:31] <psch> TimToady then :P

[15:31] <psch> i guess that should read as "we don't type the list, so you're breaking things if you want it constrained"?

[15:34] *** skids joined
[15:34] <Skarsnik> The issue is: Ok perl6 offer type. let's type some stuff to have the compilator be able to do some check for us and avoid writing error. but it does not really work like this at all. or when it's work you have to learn weird subtility that make sens if you know most of the internal (That how It feel for me using type)

[15:36] <moritz> Skarsnik: you don't need to know any internals to know when to expect a typed list; reading the docs is enough

[15:37] <masak> I agree with Skarsnik's sentiment, if not his rationale.

[15:37] <masak> to the point where I've concluded for the time being that typed arrays are not of interest to me.

[15:37] *** telex left
[15:38] <TimToady> well, we probably need a couple of things we don't have: 1) an easy way to narrow a list, and 2) and easy way to type the values of a list

[15:38] <masak> well, hm. not really that extreme.

[15:38] <masak> I did end up liking typed array attributes.

[15:38] <masak> like `has Item @.items`

[15:38] *** telex joined
[15:38] <masak> that's probably thanks to lizmat++, who implemented it so that they actually typecheck stuff.

[15:40] <gfldex> r: my @a = [Mu]; @a.perl.say; for @a -> $i:D {}

[15:40] <camelia> rakudo-jvm a3962b: OUTPUT«===SORRY!===␤Can not invoke this object␤»

[15:40] <camelia> ..rakudo-moar a3962b: OUTPUT«===SORRY!===␤Cannot invoke this object␤»

[15:41] <gfldex> r: my @a = [Mu]; for @a -> $i:D {}

[15:41] * moritz doesn't even know how -> $i:D { } parses

[15:41] <camelia> rakudo-jvm a3962b: OUTPUT«===SORRY!===␤Can not invoke this object␤»

[15:41] <camelia> ..rakudo-moar a3962b: OUTPUT«===SORRY!===␤Cannot invoke this object␤»

[15:41] <gfldex> std: for @a -> $i:D {}

[15:41] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Variable @a is not predeclared at /tmp/wsIb5I8jdj line 1:␤------> 3for 7⏏5@a -> $i:D {}␤Potential difficulties:␤  $i is declared but not used at /tmp/wsIb5I8jdj line 1:␤------> 3for @a -> 7⏏5$i:D {}␤Check failed␤FAILED…»

[15:41] <gfldex> std: my @a; for @a -> $i:D {}

[15:41] <camelia> std 28329a7: OUTPUT«Potential difficulties:␤  $i is declared but not used at /tmp/cADPaJUhBO line 1:␤------> 3my @a; for @a -> 7⏏5$i:D {}␤ok 00:00 140m␤»

[15:42] <gfldex> std: my @a; for @a -> $i:D { $i.say }

[15:42] <camelia> std 28329a7: OUTPUT«ok 00:00 140m␤»

[15:43] <gfldex> even if what I do is silly, I still feel entitled to a proper error message :)

[15:43] <pink_mist> what's the differences between std:, p6:, m:, r:, and whatever others there are?

[15:43] <moritz> pink_mist: they run the code through different compilers

[15:43] <moritz> pink_mist: std is the standard grammar, which only does syntax checks

[15:43] <psch> m: my @a = [Mu]; for @a -> :($i:D) {}

[15:43] <camelia> rakudo-moar a3962b: OUTPUT«===SORRY!===␤Cannot invoke this object␤»

[15:43] <gfldex> m: - rakudo on moarvm (without jvm), r: rukudo with both moarvm and jvm (two outputs)

[15:43] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/a7DxspFEgl␤Missing block (taken by some undeclared routine?)␤at /tmp/a7DxspFEgl:1␤------> 3- rakudo on moarvm (without jvm7⏏5), r: rukudo with both moarvm and jvm (t␤    expecting any of:␤      …»

[15:44] <moritz> pink_mist: m is rakudo with the moarvm backend

[15:44] <moritz> pink_mist: j is rakudo with the jvm backend

[15:44] *** JimmyZ_ joined
[15:44] <moritz> pink_mist: p6 runs both j and m

[15:44] <JimmyZ_> https://github.com/rakudo/rakudo/blob/nom/docs/announce/2015.09.md

[15:44] <pink_mist> moritz: ah, thanks! =)

[15:44] <psch> p6 probably would run other implementations, if some come up again

[15:44] <JimmyZ_> Stefan Seifert is niner

[15:44] <pink_mist> so p6 is the same as r?

[15:45] <JimmyZ_> they are the same one😊

[15:45] * psch idly wonders what happened to the Perl 6 compiler in C++ that was hinted at some time ago...

[15:45] <TimToady> p6 used to run niecza too till it monorotted

[15:45] <psch> or was is C99, i forget

[15:46] <TimToady> nothing surprising :)

[15:46] <vendethiel> psch: arakne? ded

[15:46] <vendethiel> oops, arane. https://github.com/BizarreCake/Arane

[15:47] <moritz> perlito: say 42

[15:49] *** JimmyZ_ left
[15:49] *** telex left
[15:49] *** telex joined
[15:50] *** telex left
[15:52] *** telex joined
[15:52] <psch> yeah, it seemed somewhat ambitious at the time already... :)

[15:53] <jnthn> masak: Your finding that typed arrays work most nicely for you on attributes is a nice reflection of the fact that types are most naturally used in Perl 6 when you are trying to keep your own things internally consistent, rather than trying to export a strongly typed view to a language where people mostly expect to easily plug things together without much regard for such things.

[15:53] * moritz is always skeptical when announcements are made before working code is there

[15:54] <moritz> jnthn: which is contrary to the common opinions that interfaces/APIs are the place where APIs matter most

[15:54] <jnthn> We've seen across the industry that when a language tries to make all interfaces strongly typed, people end up reaching for dynamically typed things to loosen coupling ("let's use web services between these two Java things!")

[15:55] <jnthn> moritz: APIs are where APIs matter most? :)

[15:55] <jnthn> Oh...was one of those meant to be types?

[15:55] <moritz> s:last/APIs/types/

[15:56] *** zacts joined
[15:58] <TimToady> m: sub foo(Rat() *@rats) { say @rats }; foo 1,2,3

[15:58] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ldl7JjnzYi␤Slurpy positionals with type constraints are not supported.␤at /tmp/ldl7JjnzYi:1␤------> 3sub foo(Rat() *@rats7⏏5) { say @rats }; foo 1,2,3␤    expecting any of:␤        constraint␤»

[15:58] * jnthn suspects that one should work eventually

[15:58] *** telex left
[15:58] <Skarsnik> hm, how I can test if soemthing is an Array? (or more exactly something that act like an Array) since a Array attribute is a Positional

[15:58] *** telex joined
[15:59] <TimToady> why do you want to know?

[15:59] <moritz> Skarsnik: fwiw the @ sigil type-checks against Positional

[15:59] *** telex left
[15:59] <TimToady> introspection is usually a code smell

[16:00] <moritz> (and type checking is usually done with ~~, so "if $thing ~~ Positional { ... }")

[16:00] *** telex joined
[16:00] *** colomon left
[16:04] <nine> m: class Bar::Foo { has $.foo-hoo; has $.bar; }; sub foo() { my @arr = 1, 2, 3; return Bar::Foo.new(bar => "2", foo-hoo => @arr); }; say foo().foo-hoo;

[16:04] <camelia> rakudo-moar a3962b: OUTPUT«[1 2 3]␤»

[16:05] <nine> Does anyone have an idea why this works flawlessly, while a simple return Panda::Ecosystem.new(statefile    => "$pandadir/state", projectsfile => "$pandadir/projects.json", extra-statefiles => @extra-statefiles); fails with "Default constructor for 'Panda::Ecosystem' only takes named arguments"?

[16:05] <Skarsnik> I can't find a concret example, but if I write soemthing stupid like print_stuff($a) {say 'fancyint' if $a ~~ Int; say 'fancyarray' if $a ~~ Array;} and pass it an array attribute from a class, does it fell back to Array?

[16:05] <dalek> roast: f55aa8d | jnthn++ | S17-supply/syntax.t:

[16:05] <dalek> roast: Tests for RT #126089.

[16:05] <dalek> roast: review: https://github.com/perl6/roast/commit/f55aa8d5ef

[16:08] <psch> m: sub f($a) { say $a.perl }; my $b = "foo"; my @c = ^5; f $b; f @c

[16:08] <camelia> rakudo-moar a3962b: OUTPUT«"foo"␤[0, 1, 2, 3, 4]␤»

[16:08] <psch> m: sub f($a) { say $a ~~ Positional }; my $b = "foo"; my @c = ^5; f $b; f @c

[16:08] <camelia> rakudo-moar a3962b: OUTPUT«False␤True␤»

[16:09] <nine> Oh, setting MVM_SPESH_DISABLE=1 or MVM_JIT_DISABLE=1 fixes the panda problem!

[16:10] <moritz> oh, a JIT bug

[16:11] <vendethiel> psch: well, if not ambitious, at least bound to be caught cheating "early on"

[16:13] <nine> moritz: do you think it's an actual JIT bug or rather just something that has to be changed in the JIT, too after changing Perl6::Actions?

[16:15] <jnthn> Anyone know why method Capture() {...} in List doing something other than just making a Capture whose positional bits are the List?

[16:15] <jnthn> Well, the list elements

[16:15] <jnthn> It's trying to do something with named args which I'm sure isn't how it's meant to work, and is also causing a bug.

[16:15] *** mr_ron joined
[16:16] <jnthn> m: (0 => 1, 2 => 3).Capture

[16:16] <camelia> rakudo-moar a3962b: OUTPUT«This type cannot unbox to a native string␤  in block <unit> at /tmp/_ZcSpt6bLK:1␤␤»

[16:16] <jnthn> That of note

[16:16] <jnthn> m: (a => 1, b => 3).Capture.perl.say

[16:16] <camelia> rakudo-moar a3962b: OUTPUT«\(:a(1), :b(3))␤»

[16:16] <jnthn> m: (a => 1, b => 3).Capture.list.say

[16:16] <camelia> rakudo-moar a3962b: OUTPUT«()␤»

[16:17] <nine> jnthn: List.Capture is a weird mix of old List's .Capture and Parcel's

[16:17] <jnthn> nine: Ah, OK

[16:17] <jnthn> That explains something, thanks. 

[16:17] <jnthn> I think it wants to be a good bit simpler. I'm not sure what it'll break :)

[16:17] <nine> jnthn: the named args handling is for "Fix binding a List to a Signature not recognizing Pairs as named args"

[16:18] <jnthn> I don't know that it should...

[16:18] <jnthn> What wanted it to, ooc?

[16:18] <nine> Fixes :(:t($t), :m($m)) := (t => 1, m => 'a');

[16:19] <jnthn> I *thought* you'd have to write that one \(t => 1, m => 'a')

[16:19] <nine> In the next life I'm gonna add info about the fixed spec tests to every commit message but right now I'm glad that I spent as much time writing them as I did :)

[16:19] <jnthn> That is, with a Capture literal

[16:19] *** perl6_newbee left
[16:19] *** raiph joined
[16:20] <jnthn> m: my Any $a is default(3)

[16:20] <camelia> rakudo-moar a3962b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/9OPR5WiAl0␤Default value '3' will never bind to a parameter of type Any␤at /tmp/9OPR5WiAl0:1␤------> 3my Any $a is default(3)7⏏5<EOL>␤    expecting any of:␤        constraint␤»

[16:20] * jnthn has a fix for that one

[16:20] <moritz> also note that it says "parmater" in the error message

[16:21] <TimToady> m: https://gist.github.com/TimToady/003e9c5c953de6014864

[16:21] <camelia> rakudo-moar a3962b: OUTPUT«1..8␤1..4␤1..8␤»

[16:21] <jnthn> moritz: Yeah, I noticed that too...

[16:21] <TimToady> so...why does the middle one produce 1..4, and the last one 1..8?

[16:22] <jnthn> TimToady: Probably something overlooked when implementing +

[16:22] <jnthn> TimToady: Try with --optimize=off 

[16:22] <nine> m: sub foo() { return :a(1), :b(2); }; my ($a, $b); :(:b($b), :a($a)) := foo(); say $a, $b;

[16:22] <camelia> rakudo-moar a3962b: OUTPUT«12␤»

[16:23] <TimToady> simply adding a statement shouldn't change the value of args

[16:23] <TimToady> yup, it's the optimizer

[16:24] *** rangerprice joined
[16:24] <jnthn> TimToady: Well, the big tip-off is we only consider single statement things in the static inliner

[16:24] <jnthn> TimToady: I'll bet the compile-time bind analyzer was never taught about +

[16:24] <jnthn> TimToady: So it thinks it's looking at a totally ordinary positional arg

[16:24] <TimToady> I did some stuff in there, but maybe not enuff

[16:24] *** telex left
[16:25] <jnthn> Apparently... :)

[16:25] *** telex joined
[16:25] *** telex left
[16:26] <jnthn> m: use Test; lives-ok { EVAL 'my Any $a is default(3)' };

[16:26] <camelia> rakudo-moar a3962b: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/iZbk4tcPUk line 1␤# Default value '3' will never bind to a parameter of type Any␤»

[16:26] *** telex joined
[16:27] <vendethiel> jnthn: should the static inliner be taught that unused values can be removed?

[16:27] <vendethiel> m: 1; # like this warning already knows

[16:27] <camelia> rakudo-moar a3962b: OUTPUT«WARNINGS:␤Useless use of constant integer 1 in sink context (line 1)␤»

[16:27] <moritz> that's not a variable :-)

[16:27] *** colomon joined
[16:27] <vendethiel> variable?

[16:28] <jnthn> vendethiel: I thought it already was

[16:28] <moritz> vendethiel: oh, I misread

[16:28] <vendethiel> ;)

[16:28] <psch> https://gist.github.com/peschwa/30639506d16f937f393d # help o.o

[16:28] <vendethiel> jnthn: maybe there's a discount today, and you uncovered two bugs instead of one

[16:30] <dalek> rakudo/nom: a5ef61e | jnthn++ | src/core/Variable.pm:

[16:30] <dalek> rakudo/nom: Fix inverted type test in `is default(...)`.

[16:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a5ef61eae8

[16:30] <dalek> roast: fbd627c | jnthn++ | S02-names/is_default.t:

[16:30] <dalek> roast: Test for RT #126104.

[16:30] <dalek> roast: review: https://github.com/perl6/roast/commit/fbd627c9a6

[16:31] *** skids left
[16:32] <jnthn> 16 to go before we knock a page off RT :)

[16:33] <moritz> the R* release I'm preparing... is this our Christmas Preview?

[16:33] <jnthn> Note that RT #126108 is about the bad error, so we can address it wiht that.

[16:35] <jnthn> zefram++ files well-formed/analyzed bug reports

[16:36] *** laouji left
[16:36] <bartolin> yeah, zefram++  ( but there are so many of them /o\ )

[16:38] <mprelude> Anyone using AnyEvent::Twitter::Stream? If so, what Twitter lib do you use for... tweeting, rting, etc? Net::Twitter?

[16:38] <mprelude> Wrong chan :D

[16:38] *** laouji joined
[16:40] *** Sqirrel joined
[16:43] *** laouji left
[16:43] <jnthn> m: sub MAIN() { map { say 'hi' }, ^2 }

[16:43] <camelia> rakudo-moar a3962b: ( no output )

[16:44] <moritz> jnthn: I'm looking into that one right now

[16:45] <dalek> rakudo/nom: f7c2a72 | moritz++ | src/core/Main.pm:

[16:45] <dalek> rakudo/nom: RT #126029: sink MAIN (and USAGE)

[16:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7c2a72206

[16:45] <jnthn> I have a patch locally

[16:46] <jnthn> oh, damm

[16:46] <moritz> sorry :(

[16:46] *** telex left
[16:46] <jnthn> Well, I have a test? :)

[16:46] <moritz> jnthn: push that, then :-)

[16:47] *** colomon left
[16:48] <dalek> roast: a1d59e2 | jnthn++ | S06-other/main.t:

[16:48] <dalek> roast: Test for RT #126029.

[16:48] <dalek> roast: review: https://github.com/perl6/roast/commit/a1d59e24ed

[16:48] *** itsme_ joined
[16:48] *** colomon joined
[16:48] *** telex joined
[16:48] <jnthn> Went for a test that didn't end up needing to sleep :)

[16:48] <jnthn> Your patch looks like mine except I didn't think of USAGE

[16:49] <moritz> jnthn: ok, so it wasn't totally sunk (sic) effort :-)

[16:49] <jnthn> ;P

[16:52] *** itsme_ left
[16:53] *** frodwith left
[16:54] <dalek> roast: 1db8547 | usev6++ | S03-feeds/basic.t:

[16:54] <dalek> roast: Remove dubious test

[16:54] <dalek> roast: 

[16:54] <dalek> roast: S06 currently says:

[16:54] <dalek> roast: 

[16:54] <dalek> roast:   Because feeds are defined as lazy pipes, a chain of

[16:54] <dalek> roast:   feeds may not begin and end with the same array without

[16:54] <dalek> roast:   some kind of eager sequence point. That is, this isn't

[16:54] <dalek> roast:   guaranteed to work:

[16:54] <dalek> roast: 

[16:54] <dalek> roast:     @data <== grep { $_ % 2 } <== @data;

[16:54] <dalek> roast: 

[16:54] <dalek> roast:   [...]

[16:54] <dalek> roast: 

[16:54] <dalek> roast:   Conjecture: if the cloning process eagerly duplicates @data,

[16:54] <dalek> roast:   it could be forced to work. Not clear if this is desirable,

[16:54] <dalek> roast:   since ordinary clones just clone the container, not the value.

[16:54] <dalek> roast: 

[16:54] <dalek> roast: 'Is not guaranteed to work' sounds rather weak and does not

[16:54] <dalek> roast: justify to test for the code given to die.

[16:54] <dalek> roast: 

[16:54] <dalek> roast: Also, the code currently lives and the test only succeeded

[16:54] <dalek> roast: because @data wasn't visible within 'eval-dies-ok'.

[16:54] <dalek> roast: review: https://github.com/perl6/roast/commit/1db8547fbf

[16:54] <vendethiel> rip dalek?

[16:55] <bartolin> oops. but it looks like he survived. dalek++

[16:55] <vendethiel> dalek++ :D

[16:55] * vendethiel is always happy to see MAIN fixes

[16:57] <jnthn> m: while 0 { my $_ }

[16:57] <camelia> rakudo-moar a5ef61: OUTPUT«===SORRY!===␤Cannot find method 'value'␤»

[16:57] * jnthn has figured that one out

[16:59] <moritz> what should an empty block return? ()?

[17:00] *** larion left
[17:00] <jnthn> moritz: I'd assumed Empty (which is the empty Slip)

[17:01] <vendethiel> m: my \a = ().Slip; say (1, \a, 2);

[17:01] <camelia> rakudo-moar a5ef61: OUTPUT«(1 \(()) 2)␤»

[17:02] <dalek> rakudo/nom: a328aab | jnthn++ | src/Perl6/Actions.nqp:

[17:02] <dalek> rakudo/nom: Fix compiler explosion in `while 0 { my $_ }`.

[17:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a328aab7ac

[17:03] <dalek> roast: 406c27b | jnthn++ | S04-statements/while.t:

[17:03] <dalek> roast: Test for RT #125876.

[17:03] <dalek> roast: review: https://github.com/perl6/roast/commit/406c27b35e

[17:04] *** telex left
[17:04] *** telex joined
[17:05] <dalek> specs: 3f0277c | moritz++ | S04-control.pod:

[17:05] <dalek> specs: S04: Fix pre-GLR-ism

[17:05] <dalek> specs: 

[17:05] <dalek> specs: isn't it wonderful how much simpler this passage becomes through the GLR?

[17:05] <dalek> specs: review: https://github.com/perl6/specs/commit/3f0277cff7

[17:05] *** colomon left
[17:06] <xinming_> Anyone here knows what is the best template engine for perl6 for now?

[17:06] <xinming_> Or, if there is a template engine that is is mostly close to perl6 language itself.

[17:06] <xinming_> That'll be good.

[17:06] <jnthn> Well, there's a few Saturday patches. Should probably get back to resting myself from the busy last few days... :)

[17:07] * jnthn also needs to blog soon... :)

[17:07] <jnthn> o/

[17:08] *** colomon joined
[17:12] *** xinming_ is now known as xinming

[17:23] <dalek> roast: 05eed96 | usev6++ | S02-types/subset.t:

[17:23] <dalek> roast: Replace test using 'eval-lives-ok' with more specific test

[17:23] <dalek> roast: 

[17:23] <dalek> roast: Also avoid conflict with other subsets used in test file.

[17:23] <dalek> roast: review: https://github.com/perl6/roast/commit/05eed96fcc

[17:24] *** laouji joined
[17:24] <moritz> m: say (EVAL ().Slip.perl).^name

[17:24] <camelia> rakudo-moar a328aa: OUTPUT«List␤»

[17:24] <moritz> Slip.perl is RONG

[17:25] <moritz> if I change empty blocks to return Empty instead of Nil, surprisingly few spectests fail

[17:28] *** laouji left
[17:34] *** zakharyas joined
[17:39] *** laouji joined
[17:43] *** laouji left
[17:47] *** telex left
[17:48] *** telex joined
[17:49] *** xinming left
[17:51] *** xinming joined
[17:56] *** rangerprice left
[18:04] *** kaare_ left
[18:09] *** laouji joined
[18:12] *** telex left
[18:12] *** telex joined
[18:12] *** telex left
[18:13] *** laouji left
[18:14] <dalek> roast: c48ef39 | usev6++ | S04-phasers/end.t:

[18:14] <dalek> roast: Unfudge/rewrite some tests for END phaser

[18:14] <dalek> roast: 

[18:14] <dalek> roast: * use 'lives-ok' with EVAL instead of 'eval-lives-ok'

[18:14] <dalek> roast: * one 'todo' test only failed because $a was not visible within 'eval-lives-ok'

[18:14] <dalek> roast: * the second 'todo' test needed a rewrite with 'is_run'

[18:14] <dalek> roast: review: https://github.com/perl6/roast/commit/c48ef39ea4

[18:14] *** telex joined
[18:16] *** zakharyas left
[18:26] *** telex left
[18:28] *** telex joined
[18:34] *** Peter_R joined
[18:46] <lizmat> nine: thanks for a3962b05480453c36fc4897a , specifically the thinko in line 413

[18:46] * DrForr waves to lizmat.

[18:46] <lizmat> however, I don't think the fix in line 416 is correct

[18:46] * lizmat waves back to DrForr!

[18:47] <DrForr> Must be getting better, back on IRC :)

[18:47] <lizmat> nine: as we've done all lines that we wanted, we indicated the handle should be closed, so even if there are more lines in the file, we don't want them (ever) I would think

[18:47] <lizmat> :close to lines means: close when you're done

[18:48] <lizmat> DrForr: good to see you online again, you *must* be getting better!  :-)

[18:48] <lizmat> or you have some contraption that allows you to type / see your screen while laying down  :-)

[18:48] <lizmat> either way, an improvement over before  :-)

[18:49] <DrForr> Both :)

[18:50] * moritz imagines a transparent mattress with a screen under it

[18:53] *** leont joined
[18:54] *** woolfy joined
[18:54] <moritz> m: say slip().perl

[18:54] <camelia> rakudo-moar a328aa: OUTPUT«()␤»

[18:55] *** woolfy left
[18:55] <moritz> locally I've added multi method perl(Slip:D: |) { callsame() ~ '.Slip' }

[18:55] <moritz> and now I get ().Slip.Slip as the answer :/

[18:57] <moritz> that's a bit too slip(er)y for me

[18:59] <moritz> same when I change it to  self.List::perl(|c) ~ '.Slip';

[18:59] <dalek> rakudo/nom: 032dd7f | TimToady++ | src/Perl6/Actions.nqp:

[18:59] <dalek> rakudo/nom: suppress bogus inlining of +args

[18:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/032dd7f78d

[19:00] <TimToady> jnthn: took all morning, but I found the bug

[19:00] <TimToady> it wasn't something I neglected to do, but something I just did rwong

[19:02] <ShimmerFairy> TimToady: I can't place my finger on it, but something about that return statement seems almost... repetitive. :P

[19:05] <TimToady> yeah, well, it's nqp

[19:08] *** telex left
[19:10] *** telex joined
[19:12] <grondilu> nqp: say([||] 1, 0);

[19:13] <pink_mist> that seems to have worked less than well

[19:13] <grondilu> no reduce metaoperator in nqp anyway.  Nvm 

[19:13] *** camelia joined
[19:15] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say([||] 1"␤   at gen/moar/stage2/NQPHLL.nqp:519  (/home/camelia/rakudo-inst-2/share/nqp/lib/NQPHLL.moarvm:panic:105)␤ from gen/moar/stage2/NQP.nqp:921  (/home/camelia/rakudo-inst-2/share/nqp/lib/nqp.moarvm:comp_unit:872)␤ from gen/…»

[19:15] <camelia> ..nqp-parrot: OUTPUT«Can't exec "./rakudo-inst/bin/nqp-p": No such file or directory at lib/EvalbotExecuter.pm line 193.␤exec (./rakudo-inst/bin/nqp-p /tmp/tmpfile) failed: No such file or directory␤Server error occurred! Closing Link: ns1.niner.name (Quit: camelia)␤Lost connect…»

[19:15] <camelia> ..nqp-jvm: OUTPUT«#␤# There is insufficient memory for the Java Runtime Environment to continue.␤# pthread_getattr_np␤# An error report file with more information is saved as:␤# /tmp/jvm-13006/hs_error.log␤»

[19:15] *** ChanServ sets mode: +v camelia

[19:16] *** kaare_ joined
[19:16] <pink_mist> so jvm ran out of memory from that? 0_o

[19:19] *** braintwist joined
[19:20] <ShimmerFairy> nah, it's because nqp-p is still something the bot tries to do that it left for a moment.

[19:25] *** LonelyGM joined
[19:27] <psch> nqp-j: say("hi") 

[19:27] <camelia> nqp-jvm: OUTPUT«(signal ABRT)#␤# There is insufficient memory for the Java Runtime Environment to continue.␤# pthread_getattr_np␤# An error report file with more information is saved as:␤# /tmp/jvm-17024/hs_error.log␤»

[19:27] <psch> nqp-j is always out of memory... :)

[19:29] <ShimmerFairy> ah. nqp-p didn't help though :P

[19:29] *** telex left
[19:30] *** telex joined
[19:30] *** LonelyGM left
[19:32] <lizmat> hmmm... S04-phasers/pre-post.t fails for me with "Lexical '$_' already declared" at compile time

[19:35] *** mr_ron left
[19:36] <TimToady> always fakes me out, I think my test run is done because my fan spools down, but it's just all the S17 stuff twiddling its thumbs

[19:38] *** colomon left
[19:39] <ShimmerFairy> I've noticed some tests with memory allocation problems on my machine, I'll go report them against MVM now that I'm reminded.

[19:39] <lizmat> perhaps not running the spectest alphabetically could work ?

[19:39] <lizmat> TimToady: ^^^

[19:39] *** nebuchad` joined
[19:40] *** nebuchad` is now known as nebuchadnezzar

[19:43] <lizmat> is there a reason why Str doesn't have a 'spurt' method ?

[19:43] <lizmat> "foo".spurt($filename)  # for easy writing a string to a file ?

[19:44] *** [Sno] left
[19:44] <pink_mist> good idea

[19:44] <ShimmerFairy> lizmat: give IO back the slurp method, and I think there's more argument for it :P

[19:44] <timotimo> well, it could go at the end of a long chain of methods

[19:44] <timotimo> those are kinda common

[19:44] <lizmat> "t/spectest.data".IO.lines(:!chomp).pick(*).join.spurt("wop")   # my use case

[19:44] <jdv79> isn't spurt more related to the IO thing than the content

[19:44] <yoleaux> 03:32Z <zostay> jdv79: IO::Socket::INET is too specific, but using the Raw IO is completely the wrong solution always and the alternative is to be implementation-specific, which might as well not even be in the standard

[19:45] <dalek> rakudo/nom: 039de8f | TimToady++ | src/core/Any-iterable-methods.pm:

[19:45] <dalek> rakudo/nom: minmax now one-arg

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/039de8fa95

[19:45] <dalek> rakudo/nom: 83d7248 | TimToady++ | src/core/metaops.pm:

[19:45] <dalek> rakudo/nom: reductions now one-arg

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/83d7248c2b

[19:45] *** [Sno] joined
[19:45] <dalek> roast: 8cd1edb | TimToady++ | / (2 files):

[19:45] <dalek> roast: reductions are now under one-arg rule

[19:45] <dalek> roast: review: https://github.com/perl6/roast/commit/8cd1edbc46

[19:45] <jdv79> zostay: not sure i agree but ok

[19:45] <ShimmerFairy> I never _really_ understood the rename of slurp to slurp-rest for the method form, and it still feels like a bad thing to have happened.

[19:46] <dalek> rakudo/nom: eeed6bb | lizmat++ | src/core/IO/Handle.pm:

[19:46] <dalek> rakudo/nom: lines(:close) means close the handle, always

[19:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eeed6bb161

[19:46] <jdv79> uh, what is slurp-rest?

[19:47] <TimToady> read-to-end

[19:47] <TimToady> but don't close

[19:48] <TimToady> slurp implies closing

[19:48] <jdv79> so slurp still exists?

[19:48] <jdv79> i haven't updated in a while

[19:49] <ShimmerFairy> TimToady: while I do understand slurp-rest being "from current point to end" (and apparently the not-closing thing), it felt like an inconsistency was made when .slurp was renamed, and &slurp was left alone

[19:49] <ShimmerFairy> (even though they do behave different, AIUI)

[19:49] <TimToady> it's a foolish inconsistency

[19:49] <TimToady> er, however you say that...

[19:50] <TimToady> very bikesheddy, as far as I am concerned

[19:50] <jdv79> "rest" doesn't jump out at me as not closing.  and as for from cur pos to end - that's the sort of thing that's implied with a lot of IO operations, no?

[19:50] <jdv79> seems wonky but ok

[19:50] <jdv79> why not paramaterize that sort of stuff more clearly

[19:50] <ShimmerFairy> TimToady: yeah, admittedly it's not that bad, I just still see it from when the change was made, and it felt odd to not be able to do  $string.slurp  like you could  slurp($string)  anymore

[19:50] <TimToady> if you want to be consistent, rename .slurp to .slurp-all-and-close, but that's a bit long

[19:51] <lizmat> well, since I've given up anything IO related design wise, I have not much interest in participating in further bikeshedding this

[19:51] <lizmat> so whatever you guys decide, is fine by me

[19:52] * TimToady has bigger fish to fry

[19:52] <timotimo> bon appetit

[19:52] <TimToady> like whether listop map should be onearg instead of flattening

[19:52] *** kaare_ left
[19:52] <jdv79> lizmat: so newio is dead in the water?

[19:53] <ShimmerFairy> lizmat: you may be able to do .&spurt at the end of that method call chain (depends on how the args are ordered)

[19:53] <lizmat> jdv79: am afraid so: at some point I may revisit the branch and see if I can salvage some from it

[19:53] <timotimo> m: say &spurt.^signature

[19:53] <camelia> rakudo-moar 032dd7: OUTPUT«Method 'signature' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at /tmp/kXnsaZpflO:1␤␤»

[19:54] <timotimo> m: say &spurt.signature

[19:54] <camelia> rakudo-moar 032dd7: OUTPUT«(|)␤»

[19:54] <lizmat> but I've gotten so much flak from it, that I got completely de-funned there

[19:54] <timotimo> m: say &spurt.candidates

[19:54] <camelia> rakudo-moar 032dd7: OUTPUT«(sub spurt (|) { #`(Sub|57331736) ... })␤»

[19:54] <timotimo> hum.

[19:54] <ShimmerFairy> lizmat: does the newio branch of specs give a good overview of what your goals were? I wasn't around when you were working on it, so I don't know anything about it.

[19:54] <jdv79> can we not muster a new torch bearer to bring it home?!

[19:54] <lizmat> newio turned out to be -NoFun to me

[19:54] <ShimmerFairy> timotimo: if 'sub spurt' has a first argument of the Str to spurt, then you'd be able to use $string.&spurt(...)

[19:55] <timotimo> aye

[19:55] <lizmat> &spurt has the filename as the first param

[19:55] <jdv79> lizmat: is it worth completing at this point?

[19:55] <timotimo> i wanted to find out

[19:55] <timotimo> obviously we'll need a &trups for this

[19:56] <lizmat> ShimmerFairy: there's also a newio branch in specs

[19:56] <lizmat> in which I described what I wanted to achieve / largely achieved

[19:56] <ShimmerFairy> lizmat: that's the branch I asked about :) . I'll be sure to check that out when I have the chance.

[19:57] *** lichtkind joined
[20:00] *** laouji joined
[20:01] *** telex left
[20:01] <dalek> roast: 8e7418f | TimToady++ | S03-metaops/reduce.t:

[20:01] <dalek> roast: untodo [=:=] et al. that now work after onearg

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/8e7418f11e

[20:02] *** telex joined
[20:04] <TimToady> multi sub map(&code, Whatever) { (1..Inf).map(&code) }   <-- who ordered that?

[20:04] <TimToady> and why 1-based?

[20:05] <ShimmerFairy> TimToady: I think we decided that  @list.map(*)  was useless not too long ago, the sub form should probably go too :)

[20:05] <ShimmerFairy> oh, that's not quite the same thing. But still.

[20:06] <ShimmerFairy> m: say *.map({say $_ })

[20:06] <camelia> rakudo-moar 032dd7: OUTPUT«WhateverCode.new␤»

[20:06] <ShimmerFairy> ^ should do that, as far as I'm concerned

[20:07] <TimToady> m: say map * + 0, *

[20:07] <camelia> rakudo-moar 032dd7: OUTPUT«(...)␤»

[20:07] <TimToady> m: .say for map * + 0, *

[20:07] <camelia> rakudo-moar 032dd7: OUTPUT«(timeout)1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤5…»

[20:08] <TimToady> that's just kinda bizarre

[20:08] <ShimmerFairy> I agree. I don't see why map should have a shortcut for what's basically an infinite loop.

[20:09] *** diana_olhovik_ joined
[20:10] <TimToady> seems like it would be much more straightforward to say 1..Inf when you mean that

[20:11] *** telex left
[20:12] <TimToady> doubtless it will come back around to being my fault somehow :)

[20:12] <lizmat> TimToady: if anybody's to blame for that one, that would be me

[20:12] *** telex joined
[20:12] <lizmat> and as to why 1-based, I would not know the answer to that  :-(

[20:13] <lizmat> I think it dates from a time where a gather loop {} did not work in the settings (is what I vaguely remember)

[20:13] <lizmat> afaics, it can be killed with fire...

[20:14] <jdv79> where can i find out more about this quote "as usual, the presence of a named option is a design smell"

[20:14] <lizmat> .oO( who switched on the zefram bot? :-)

[20:16] *** mr_ron joined
[20:17] *** rindolf left
[20:17] * timotimo downloaded more zefRAM

[20:18] *** rindolf joined
[20:19] *** laouji left
[20:19] <jdv79> i don't understand that quote

[20:19] <lizmat> jdv79: fwiw, I would like to see an explanation of that quote as well  :-)

[20:22] <labster> moritz: I merged the File::Directory::Tree change.

[20:22] <yoleaux> 11:14Z <moritz> labster: any chance you could merge https://github.com/labster/p6-file-directory-tree/pull/5 soonish? It would help with the Rakudo Star release

[20:23] *** kanishka left
[20:23] *** laouji joined
[20:24] *** darutoko left
[20:26] <jdv79> esp since slurp-rest has adverbs or named options or whatever you want to call them for other stuff.  wut.

[20:27] <jdv79> i am starting to imagine why newio was unfun.  i glossed over it while it was going on so didn't notice.

[20:28] *** laouji left
[20:32] <ShimmerFairy> jdv79: where did you get that quote from?

[20:34] <dalek> rakudo/nom: a98ce40 | TimToady++ | src/core/Mu.pm:

[20:34] <dalek> rakudo/nom: Add .self as an identity method

[20:34] <dalek> rakudo/nom: 

[20:34] <dalek> rakudo/nom: So people aren't so tempted to hardwire * as an identity map function.

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a98ce40233

[20:34] <dalek> rakudo/nom: d9c21e9 | TimToady++ | src/core/Any-iterable-methods.pm:

[20:34] <dalek> rakudo/nom: simplify listop map dispatch to a single one-arg

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9c21e99f5

[20:34] <dalek> rakudo/nom: 244b7b4 | TimToady++ | src/core/Str.pm:

[20:34] <dalek> rakudo/nom: listop map no longer flattens

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/244b7b4458

[20:35] <btyler_> hi folks. in the category of "evil but useful tricks", can a perl6 role add methods to the consuming class/object in a dynamic way? here's an example in perl 5: https://gist.github.com/kanatohodets/aff43baf1f6c2564b916#file-foobar-gigarole-pm

[20:35] <btyler_> that is, run code to generate a bunch of methods

[20:37] <jdv79> i dug into the slurp-rest hits from irc log

[20:38] <masak> jdv79: trying to understand the quote, I think it's about over-configuring, and I also think I have an example.

[20:38] <jdv79> ShimmerFairy: http://irclog.perlgeek.de/perl6/2014-11-07#i_9622385

[20:39] <ShimmerFairy> jdv79: in my experience, it's only a big problem if it ends up a poor reimplementation of the type system; that's why we ended up with NFC, NFD, etc. types for normalization, instead of :nfc adverbs on everything :)

[20:39] *** diakopter left
[20:40] <ShimmerFairy> (though that's surely not the only time it's an issue to use nameds, just the only time I've personally encountered it being problematic)

[20:41] <TimToady> we had a long history of trying to customize operators like range using adverbs, and it almost always meant there was some other better way to do it

[20:41] <masak> jdv79: .roll used to be .pick(:replace)

[20:41] <masak> jdv79: but having it as a separate method is clearly better

[20:42] <masak> jdv79: as an example of operators with adverbs, there's :by on infix:<..> -- but it turned out to be vastly better to have that kind of stepping magic as a separate operator infix:<...>

[20:42] <TimToady> in linguistic terms, having options often means you're trying to stretch a metaphor too far

[20:44] *** telex left
[20:46] *** telex joined
[20:47] *** rurban joined
[20:47] *** diakopter joined
[20:54] <jdv79> tahnks

[20:54] <jdv79> *thanks ^H

[20:58] *** TEttinger joined
[21:01] *** laouji joined
[21:01] <jdv79> I'll just restate a bit and then drop it.  As someone who just learned of slurp-rest i was immediately confused by the name and needed docs.  if it was just slurp with a close param with sensible default(s) I probably would not need to look it up.  but i'm guessing i'm missing some things that would make that rename make more sense.

[21:06] <masak> jdv79: all I remember is that at some point we got more discriminating, and started considering a full-file slurp to be different from a slurp on a filehandle that had already been partially consumed.

[21:06] <masak> jdv79: implementing the latter as a flag/named may or may not have been considered, I don't know.

[21:07] *** laouji left
[21:09] * lizmat vaguely remembers it being considered, but that may be confabulation

[21:13] *** AlexDaniel joined
[21:14] <masak> the one I *would* sign up on as being a definitely design/code smell, is when the API ends up looking like :!someflag

[21:15] <masak> that is, if the default of the named is True, and you have to pass in False to override the default

[21:15] *** dnmfarrell joined
[21:15] <lizmat> lines(:!chomp) anyone ?

[21:17] <dalek> roast/return_outside_routine: 38fdf08 | usev6++ | S04-statements/return.t:

[21:17] <dalek> roast/return_outside_routine: Use 'run' to test for returning outside of routine

[21:17] <dalek> roast/return_outside_routine: 

[21:17] <dalek> roast/return_outside_routine: We can't test for 'Attempt to return outside of any Routine'

[21:17] <dalek> roast/return_outside_routine: with our toolchain from Test.pm or Test::Util.

[21:17] <dalek> roast/return_outside_routine: review: https://github.com/perl6/roast/commit/38fdf0819b

[21:17] <lizmat> masak: would you consider lines(:!chomp) a code smell ?

[21:17] <masak> lizmat: yes.

[21:17] <TimToady> lines(:pristine)

[21:18] <masak> keep in mind, though, that "code smell" does not mean "destroy! destroy!"

[21:18] <masak> it means we should keep on the lookout for a nicer factoring

[21:18] <lizmat> I guess it came from hysterical raisins

[21:18] *** rindolf left
[21:18] <lizmat> I mean, in p5 you would almost *always* do a .chomp on whatever you got

[21:18] <masak> yes, that's what I thought when you just showed it, that the term 'chomp' is historical

[21:19] <lizmat> lines(:no-chomp) ?

[21:19] <masak> it just moves the bump around the waterbed :)

[21:19] <lizmat> I mean, that would just change the spelling  :-)

[21:19] <masak> yep

[21:20] <jdv79> no, its a much larger bump cause now you have the possibilitiy of a double negative which can be highly confusing

[21:21] <masak> TimToady++ is on the right track with :pristine, but 'pristine' doesn't immediately ring true/simple/fitting

[21:21] <jnthn> btyler_: Didn't see anyone answer your roles question, so: yes, any code you write in the role body will run at role composition time, and you can use the generic ::?CLASS to at stuff

[21:21] <jnthn> *add

[21:21] <btyler_> oh, yay. so ::?CLASS.^add_method presumably

[21:21] <leont> The nice thing about chomp is that it will actually well "does it do this action"

[21:21] <btyler_> I'll give that a shot, thanks!

[21:21] <leont> :pristine is its own kind of negative, by meaning "don't do some action")

[21:21] <masak> m: role B { say "run at role composition time: {::?CLASS}" }; class C does B {}; class D does B {}

[21:21] <camelia> rakudo-moar 244b7b: OUTPUT«===SORRY!===␤Cannot find method 'collisions'␤»

[21:22] *** diakopter left
[21:22] <masak> ...hm.

[21:22] <btyler_> yeah, I was getting that error and assuming it was just me doing something silly

[21:22] <jnthn> m: role R { ::?CLASS.^add_method(<foo bar baz>.pick, method () { }) }; class C1 does R { }; class C2 does R { }; say C1.^methods; say C2.^methods;

[21:22] <camelia> rakudo-moar 244b7b: OUTPUT«(<anon>)␤(<anon>)␤»

[21:22] <jnthn> hah :)

[21:22] <masak> jnthn: are we doing something silly?

[21:22] *** silug joined
[21:22] <jnthn> m: role R { ::?CLASS.^add_method(<foo bar baz>.pick, method () { }) }; class C1 does R { }; class C2 does R { }; say C1.^method_table; say C2.^method_table;

[21:22] <camelia> rakudo-moar 244b7b: OUTPUT«foo => <anon>␤baz => <anon>␤»

[21:22] <jnthn> m: role R { ::?CLASS.^add_method(<foo bar baz>.pick, method () { }) }; class C1 does R { }; class C2 does R { }; say C1.^method_table; say C2.^method_table;

[21:22] <camelia> rakudo-moar 244b7b: OUTPUT«foo => <anon>␤foo => <anon>␤»

[21:22] <jnthn> There you go :)

[21:22] <masak> jnthn: what about the 'collisions' thing above?

[21:23] <jnthn> masak: Expecting .gist to work before the target class is composed, then running onto the bug already in RT where somehow instead of reporting an error correctly we complain about collisions.

[21:23] <masak> aha.

[21:23] * TimToady wonders, looking at sort, why signature (&cmp, +values) is not considered a better match than (+values)

[21:24] <jnthn> m: multi m($a, *@b) { say 1 }; multi m(*@b) { say 2 }; m(1); m(1, 2);

[21:24] <camelia> rakudo-moar 244b7b: OUTPUT«Ambiguous call to 'm'; these signatures all match:␤:($a, *@b)␤:(*@b)␤  in block <unit> at /tmp/lvM0TEeofx:1␤␤»

[21:24] <jnthn> TimToady: You want the first to win in that case?

[21:25] <TimToady> if it doesn't break something else or slow things down, seems like a good idea

[21:25] <jnthn> I can't tell you if it'll break anything because I already surpassed the point where I can understand the arity-based sorting rules in multi-dispatch. :/

[21:25] <TimToady> in some sense the first parameter is binding tighter by definition

[21:26] <jnthn> Probably 'cus I made a bunch of reasonable-sounding reqeusts work and now I don't understand the result. :)

[21:26] <TimToady> me too :P

[21:27] *** BenGoldberg joined
[21:27] *** telex left
[21:27] <jnthn> We probably need to simplify things a bit :)

[21:28] <jnthn> My gut feeling is "yeah, that should work", but given my following my gut already got us the current impl... :)

[21:28] *** diakopter joined
[21:28] *** telex joined
[21:28] <dalek> rakudo/nom: c1af489 | lizmat++ | src/core/Iterator.pm:

[21:28] <dalek> rakudo/nom: count-only doesn't take any params

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c1af489439

[21:28] <dalek> rakudo/nom: 8158cb5 | lizmat++ | src/core/IO/Handle.pm:

[21:28] <dalek> rakudo/nom: Re-implement lines(:count) using iter.count-only

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8158cb5dd0

[21:28] <dalek> rakudo/nom: c5407d2 | lizmat++ | src/core/Seq.pm:

[21:28] <dalek> rakudo/nom: Make Seq.elems call iterator.count-only

[21:28] <dalek> rakudo/nom: 

[21:28] <dalek> rakudo/nom: Provide a shortcut when we want an iterator to just find out the number

[21:28] <dalek> rakudo/nom: of elems and nothing else (think "words".IO.lines.elems)

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5407d2486

[21:28] <dalek> rakudo/nom: ffa8ea2 | lizmat++ | src/core/array_slice.pm:

[21:28] <dalek> rakudo/nom: Prevent [*-1] from consuming the iterator too soon

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ffa8ea2833

[21:30] <dalek> rakudo/nom: 8c3980f | TimToady++ | src/core/Any-iterable-methods.pm:

[21:30] <dalek> rakudo/nom: attempt to de-flatten sort

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c3980f4ec

[21:30] <lizmat> jnthn: you may want to look at c5407d2 and ffa8ea2

[21:30] <jnthn> ffa8ea2 concerns me a little, yeah

[21:31] <jnthn> Like, I don't get why it's needed

[21:31] <lizmat> jnthn: it used to do the .cache inside Seq.elems before

[21:31] <jnthn> ah

[21:31] <jnthn> oh, it's AT-POS we forward, we don't have an alternative set of postcircumfix candidates

[21:31] <lizmat> otherwise the .elems will consume the iterator before we can get at the underlying seq

[21:31] <jnthn> Yeah

[21:32] <jnthn> OK, now I understand why it's needed

[21:32] <lizmat> but it should allow for all other iterators to provide a fast shortcut for just counting

[21:32] <lizmat> it makes "words".IO.lines.elems about 2.5 times as fast

[21:33] <TimToady> only about 167 more *@ and **@ slurpies to audit in the core, sigh...

[21:33] <lizmat> jnthn: and no spectest breakage  

[21:35] <TimToady> plus the places with hand-rolled one-arg that could use +args instead

[21:36] <BenGoldberg> TimToady, on that sort patch, why not let the dispatcher do the work?  Something like: multi sub sort(Callable \cmp, +values) { values.sort(cmp) }; multi sub sort(+values) { values.sort };

[21:37] <jnthn> lizmat: I'm fine with it for now, I think :)

[21:37] <mattp__> is there any 6guts / p6weekly coming any time soon? its been a while :)

[21:38] <jnthn> mattp__: 6guts updates will resume shortly; I wasn't too well for a while :(

[21:39] <jnthn> (and spent what energies I had on getting stuff done rather than blogging)

[21:39] <TimToady> BenGoldberg: doesn't work; that's what jnthn++ and I were just discussing

[21:41] *** rurban left
[21:43] * BenGoldberg reads the irclog...

[21:43] <BenGoldberg> What about some sort of: multi sub sort(AnyThingOtherThan(Callable) \not_a_cmp, +values) { ... }?

[21:44] <mattp__> jnthn: given the past tense glad youre feeling better atleast :) 

[21:44] <jnthn> mattp__: Well, better in the "improved" sense than the "totally well" sense, but it's progress. :)

[21:45] * jnthn wants to get back to writing weekly reports, anyways.

[21:46] *** dnmfarrell left
[21:48] <lizmat> mattp__: writing a P6W has become a daunting task

[21:48] <lizmat> timotimo seems to have worked on it: not sure of the status right now

[21:53] <timotimo> oh

[21:53] <timotimo> that's right

[21:53] *** spider-mario left
[21:53] <timotimo> last status:

[21:54] <timotimo> wordpress was like "blogpost, OM NOM NOM GONE!"

[21:54] <timotimo> timo was like: *flips table*

[21:54] <BenGoldberg> Speaking of things I'm seeing in the irc log before I joined today... IIRC, p5 started with a chop operator, which removed and returned the last byte of a string, regardless of what that byte was.  The idea of chopping off the end of string kinda makes english-language sense.  chomp was added shortly after, to remove only the current input record separator; unlike chop, it was idempotent; but since it's task was so similar, it was 

[21:54] <BenGoldberg> given a similar-but-cuter name.

[21:55] <lizmat> FWIW, I think chomp logic should really live in the VM

[21:55] <lizmat> as an attribute of the PIO

[21:55] <lizmat> and it should be able to handle other line-endings as well  :-)

[21:56] *** telex left
[21:56] <BenGoldberg> To super-super-summarize, I think maybe p6's version of chomp should be $:retain-record-separator or $:remove-record-separator

[21:56] <lizmat> but I'm pretty sure jnthn agrees and has it somewhere down on his list  :-)

[21:57] <jdv79> timotimo: you trust a browser as a text editor?

[21:57] * jnthn suspects once he's done the multi-dim array stuff, I/O related bits will be on his plate

[21:57] * lizmat wishes jnthn much strength

[21:57] * lizmat feels we need a bit of a GIOR

[21:58] *** telex joined
[21:59] <jnthn> IO is one of those things I've continually hoped someone more experienced than me would take on...

[21:59] <timotimo> jdv79: it has a recovery function

[21:59] <jnthn> Concurrency and NFG both used to be in that category, though :P

[22:00] <pink_mist> jnthn: maybe those more experienced than you are experienced enough that they hope the same thing :P

[22:00] <jnthn> pink_mist: Probably, yeah. It's a thorny area. :)

[22:01] <jnthn> Thankfully, it's 2015, and the list of platforms you have to care about supporting to achieve >99% market penetration is really short :)

[22:01] <jnthn> uh, market penetration ain't the phrase I wanted...but anwyays :)

[22:04] <lizmat> well, if someone would actually look at what I wrote in the newio branch of specs

[22:04] <lizmat> and we could reach some consensus about that, then maybe I could be convinced to take it up again

[22:04] <TimToady> gee, when I take flatttening off the any/or/one/none, the flattening tests flunk, who'd'a thunk?

[22:05] * lizmat gets a thunking feeling

[22:05] <jnthn> lizmat: I think there's a bunch of lower-level things too

[22:05] <lizmat> well, yes, like input-line-sep and output-line-sep

[22:05] <jnthn> lizmat: But yeah, looking at what you did in newio would certainly be part of what I want to do.

[22:06] <lizmat> most important thing was really getting rid of IO::Spec, I think

[22:06] <lizmat> and $*SPEC

[22:06] <lizmat> using / as a dir separator basically works everywhere

[22:07] <lizmat> I don't see Perl 6 running on VMS / EBCDIC any time soon

[22:07] <lizmat> as long as open can take a "raw" argument for opening files, I think any exotic file systems can export their own logic where needed

[22:08] <geekosaur> <USR.LOCAL.BIN>PERL6.EXE :p (tops20 4 lyfe)

[22:09] <TimToady> so, how much code actually depends on junction listops flattening, ka na...

[22:09] <geekosaur> well, probably more like SYS:<USR.LOCAL.BIN>PERL6.EXE

[22:11] <leont> Windows sometimes cares about the directory separator, but not that often

[22:12] <timotimo> did we get somewhere with regards to the action class/instance not residing in a dynamic variable?

[22:12] <masak> 'night, #perl6

[22:12] <timotimo> gnite masak

[22:13] *** Skarsnik left
[22:14] <timotimo> or did we get an approximate measurement of how that'd improve things?

[22:20] *** mr_ron left
[22:22] <TimToady> I don't think anyone has worked on that

[22:23] <TimToady> we'd probably get a bigger performance win from a better dynvar cache in general; getting rid of $*ACTIONS is more of a correctness thing to my mind

[22:23] <jnthn> It's one of those things on my "stuff to do it I want something fun to do" :)

[22:23] <TimToady> for my part, I'm concentrating on language definition right now, not performance

[22:24] <timotimo> oh, when we call into "foreign" grammars, the ACTIONS may wrongly be "derived"?

[22:24] <TimToady> the current language should be completely encapsulated in the cursor, because then it's portable outside the current dynamic scope

[22:25] <timotimo> mhm

[22:25] <jdv79> is Pod::To::HTML failing tests on install for anyone else?

[22:26] <TimToady> currently I'm trying to bias our listops more toward one-arg instead of flattening, except when a good argument can be made for flattening by default

[22:27] <TimToady> right now, it's kinda 50/50 whether something flattens or not; I'd rather have the exception list be all on one side

[22:28] * lizmat takes a long nap

[22:31] <TimToady> so at the moment, junctional listops are on the block

[22:33] <_itz>  	

[22:34] <timotimo>       

[22:34] <_itz> Always Winter, Never Christmas </cslewis> :P

[22:35] <BenGoldberg> Unless you're in the southern hemisphere ;)

[22:36] *** jack_rabbit_ left
[22:36] *** pdcawley joined
[22:37] *** Mans joined
[22:37] <Mans> Tress

[22:37] *** colomon joined
[22:37] *** leont left
[22:38] <Mans> Title hack

[22:38] <Mans> Titulo hack01

[22:38] *** Mans left
[22:41] <jnthn> On the "defining what will 6.christmas be" effort, I decided to make a list of things in the design docs that I'm pretty sure we're *not* going to have in 6.christmas. https://gist.github.com/jnthn/040f4502899d39b2cbb4

[22:41] *** colomon left
[22:41] *** espadrine joined
[22:43] <jnthn> (Partly so if TimToady++ feels we really must explore one or more of these sooner rather than later, I know to have it in mind.)

[22:45] *** telex left
[22:45] <jnthn> Time for some sleep o/

[22:46] *** telex joined
[22:47] <TimToady> o/

[22:49] <dalek> rakudo/nom: f8ee5f6 | TimToady++ | src/core/Junction.pm:

[22:49] <dalek> rakudo/nom: onearg any/all/one/none listops

[22:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f8ee5f69d1

[22:49] <dalek> roast: 445fb73 | TimToady++ | S03-junctions/ (2 files):

[22:49] <dalek> roast: onearg any/all/one/none

[22:49] <dalek> roast: review: https://github.com/perl6/roast/commit/445fb7304e

[22:50] *** mprelude left
[22:51] *** dj_goku left
[22:53] *** mr_ron joined
[22:53] *** colomon joined
[22:55] <_itz> sue-- # activating zefram bug finding bit

[22:55] <_itz> ^ bot

[22:57] * geekosaur makes note not to start using p6 actively...

[22:57] <geekosaur> <-- human fuzzer

[23:04] *** diana_olhovik_ left
[23:07] *** cognominal left
[23:07] *** jack_rabbit_ joined
[23:10] <vendethiel> m: say so any (1, 2) eqv any($[1, 2])

[23:10] <camelia> rakudo-moar 8c3980: OUTPUT«False␤»

[23:11] <vendethiel> TimToady: shouldn't there be such a test, with only one itemized arg?

[23:26] <mst> geekosaur: pretty sure I'll end up doing the same thing ;)

[23:26] <TimToady> m: say so any (1, 2) eqv any(1,2))

[23:26] <camelia> rakudo-moar f8ee5f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/if1wmkRaWf␤Unexpected closing bracket␤at /tmp/if1wmkRaWf:1␤------> 3say so any (1, 2) eqv any(1,2)7⏏5)␤»

[23:26] <TimToady> m: say so any (1, 2) eqv any(1,2)

[23:26] <camelia> rakudo-moar f8ee5f: OUTPUT«False␤»

[23:26] <TimToady> m: say so any (1, 2) eqv 2

[23:26] <camelia> rakudo-moar f8ee5f: OUTPUT«False␤»

[23:27] <TimToady> m: say any (1,2)

[23:27] <camelia> rakudo-moar f8ee5f: OUTPUT«any(1, 2)␤»

[23:28] <TimToady> m: say so any (1, 2) == 2

[23:28] <camelia> rakudo-moar f8ee5f: OUTPUT«True␤»

[23:28] <TimToady> m: say so any (1, 2) === 2

[23:28] <camelia> rakudo-moar f8ee5f: OUTPUT«False␤»

[23:28] <TimToady> gah, looks like someone borked === and eqv on junctions :(

[23:31] *** telex left
[23:32] *** telex joined
[23:33] <TimToady> m: say so any(1, 2) === 2

[23:33] <camelia> rakudo-moar f8ee5f: OUTPUT«True␤»

[23:33] <TimToady> or...not...hmm...

[23:40] *** telex left
[23:42] *** telex joined
[23:44] <dalek> rakudo-star-daily: 0b00557 | coke++ | log/ (2 files):

[23:44] <dalek> rakudo-star-daily: today (automated commit)

[23:44] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0b00557197

[23:44] <dalek> rakudo-star-daily: 87e5547 | coke++ | log/ (10 files):

[23:44] <dalek> rakudo-star-daily: today (automated commit)

[23:44] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/87e5547269

[23:44] <dalek> perl6-roast-data: 2ef68c2 | coke++ | / (9 files):

[23:44] <dalek> perl6-roast-data: today (automated commit)

[23:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/2ef68c26b7

[23:46] * [Coke] waves from the highway and starts backlogging.

[23:49] <[Coke]> I agree with Ovid; We already make allowances for sloppy types with IntStr. Why not a RatInt. 

[23:49] <[Coke]> (Sorry, with CurtisPoe++)

[23:50] <geekosaur> yes, that's part of my cognitive dissonance with that issue

[23:51] *** mr_ron left
[23:58] *** geekosaur is now known as eviltwin_b

[23:58] *** eviltwin_b is now known as allbery_b

[23:58] *** allbery_b is now known as geekosaur

[23:59] <labster> m: my role foo { }; say foo.new()

[23:59] <camelia> rakudo-moar f8ee5f: OUTPUT«foo.new␤»

[23:59] <labster> roles can have instances?

