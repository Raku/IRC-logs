[00:11] *** rurban left
[00:16] <raydiak> .tell retupmoca https://github.com/retupmoca/P6-Compress-Zlib/pull/7

[00:16] <yoleaux> raydiak: I'll pass your message to retupmoca.

[00:17] <raydiak> .tell cosimo https://github.com/cosimo/perl6-string-crc32/pull/5

[00:17] <yoleaux> raydiak: I'll pass your message to cosimo.

[00:17] *** airdisa left
[00:20] *** cognominal left
[00:29] *** BenGoldberg left
[00:29] *** BenGoldberg joined
[00:47] <flussence> silly idea: most of the profiler json is a huge nested tree of callframe info, and a lot of that is just the same hash key strings repeated over and over. Maybe it'd be more sensible to use an array... could even put the keys at the beginning of the data so it's still self-describing.

[00:47] * flussence goes to experiment

[00:51] *** dayangkun joined
[00:52] *** muraiki joined
[00:54] *** laouji joined
[01:16] *** koo6 left
[01:26] *** Zoffix joined
[01:30] <flussence> m: say 2949462 #`{ redundant hash keys and punctuation } / 5228772 #`{ total json filesize }

[01:30] <camelia> rakudo-moar d09e62: OUTPUT«0.5640831␤»

[01:31] <flussence> yeah that's... quite a lot.

[01:38] *** aborazmeh joined
[01:38] *** aborazmeh left
[01:38] *** aborazmeh joined
[01:50] *** dayangkun left
[01:54] *** raiph joined
[02:01] *** pierrot left
[02:01] *** pierrot joined
[02:17] *** dsm joined
[02:21] *** noganex_ joined
[02:24] *** noganex left
[02:24] *** rmgk_ joined
[02:24] *** rmgk left
[02:24] *** rmgk_ is now known as rmgk

[02:33] *** tinyblak left
[02:45] *** mr-foobar left
[02:47] *** colomon left
[02:48] *** colomon joined
[02:51] *** perlvim joined
[02:51] *** vendethiel joined
[02:52] *** adu joined
[02:54] <perlvim> p6: 'string'.&'say'

[02:54] <camelia> rakudo-moar d09e62: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Name must begin with alphabetic character␤at /tmp/tmpfile:1␤------> 3'string'.&7⏏5'say'␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        stat…»

[02:58] <TimToady_> m: 'string'.$('say')

[02:58] <camelia> rakudo-moar d09e62: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in block <unit> at /tmp/0rKbKUt59L:1␤␤»

[02:58] <TimToady_> m: 'string'.$::('say')

[02:58] <camelia> rakudo-moar d09e62: OUTPUT«===SORRY!===␤No such symbol '$::say'␤»

[02:58] *** thou left
[02:59] <TimToady_> m: 'string'.&say

[02:59] <camelia> rakudo-moar d09e62: OUTPUT«string␤»

[02:59] <TimToady_> m: 'string'.&::('say')

[02:59] <camelia> rakudo-moar d09e62: OUTPUT«string␤»

[03:00] <TimToady_> there you go

[03:00] <TimToady_> we intentionally make symbolic refs harder than, er, hard refs

[03:01] *** dsm left
[03:05] *** dayangkun joined
[03:06] *** konsolebox left
[03:06] <perlvim> Thanks TimToday_

[03:06] *** konsolebox joined
[03:07] <TimToady_> hmm, I grew a tail...

[03:07] *** TimToady_ is now known as TimToady

[03:07] *** TimToady left
[03:07] *** TimToady joined
[03:11] *** dsm joined
[03:16] *** dayangkun left
[03:17] <perlvim> TimToady: if the method is not exported to CORE::, how to call it dynamically with name?

[03:17] *** gfldex left
[03:17] <TimToady> import to your current lexical scope

[03:18] <TimToady> CORE is not special that way, it's just an outer lexical scope

[03:20] <perlvim> TimToday: I see, import the symbols of object.^methods to MY::, then could call it with object.&::('name') 

[03:21] <TimToady> well, but if you have object methods to begin with, and you merely wish to call a method of arbitrary name, just use object."say"()

[03:21] <TimToady> m: 'string'."say"()

[03:21] <camelia> rakudo-moar d09e62: OUTPUT«string␤»

[03:22] <perlvim> yes, it is my want

[03:24] *** jack_rabbit left
[03:27] *** muraiki left
[03:28] *** jack_rabbit joined
[03:30] *** BenGoldberg left
[03:33] *** tinyblak joined
[03:38] *** tinyblak left
[03:50] *** araujo joined
[03:50] *** araujo left
[03:52] *** araujo joined
[03:56] *** raiph left
[04:02] *** pierrot left
[04:03] *** pierrot joined
[04:07] *** vendethiel left
[04:20] *** laouji left
[04:21] *** laouji joined
[04:29] *** dayangkun joined
[04:36] *** laouji left
[04:36] *** perlvim left
[04:36] *** laouji joined
[04:36] *** haroldwu joined
[04:39] *** laouji left
[04:40] *** konsolebox left
[04:41] *** haroldwu left
[04:41] *** haroldwu joined
[04:44] *** adu left
[04:45] *** laouji joined
[04:46] *** konsolebox joined
[04:51] *** perlvim joined
[04:55] *** kaare__ joined
[05:09] <skids> .tell tadzik I sent you a pull request to Grammar::BNF that adds ABNF (popular in modern RFCs)

[05:09] <yoleaux> skids: I'll pass your message to tadzik.

[05:11] *** perlvim left
[05:14] *** vendethiel joined
[05:38] *** vendethiel left
[05:59] *** skids left
[06:06] *** dayangkun left
[06:10] *** labster left
[06:15] *** aborazmeh left
[06:21] *** Ven joined
[06:21] *** diana_olhovik_ joined
[06:26] *** labster joined
[06:28] *** quester joined
[06:29] *** hobbs left
[06:29] *** hobbs joined
[06:30] *** laouji left
[06:32] <[Tux]> still no Inline::Perl5

[06:35] *** laouji joined
[06:41] <quester> Tux... are you still getting the same "No exception handler located for warn"?  I just installed Inline::Perl5 on Rakudo Star 2015.03 at $work today and it was an... interesting... install, but I haven't seen that particular error.

[06:41] <[Tux]> i run from git, not from star

[06:41] <[Tux]> (rakudobrew)

[06:45] *** Alina-malina left
[06:48] <quester> I see... I build from git at home (not rakudobrew, but the using the a script with the manual installation commands from rakudo.org/how-to-get-rakudo/.

[06:51] *** vendethiel joined
[06:51] <quester> Using a week old Rakudo, panda install Inline::Perl5 runs okay.  (Specifically, perl6 version 2015.04-106-g59b8935 built on MoarVM version 2015.04-24-g6ef0f8f).  Let me fetch the latest Rakudo... perhaps the problem is there.  Or in MoarVM...

[06:52] <quester> s/week old Rakudo/two day old Rakudo/

[06:53] *** hobbs left
[06:55] *** brrt joined
[06:55] <brrt> \o

[06:55] *** hobbs joined
[06:55] <brrt> uhm, let me ask it here. is there any way in which ASSIGN and DECONT can be overriden by user code

[06:55] <[Tux]> fail started yesterday (01:00 AM MET)

[06:56] <[Tux]> time is a guess

[06:56] <dalek> rakudo/nom: c578247 | TimToady++ | src/core/ (2 files):

[06:56] <dalek> rakudo/nom: fooled myself, don't need nodal on multis

[06:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c578247ffc

[07:00] *** tinyblak joined
[07:14] *** Foxcool joined
[07:16] *** vendethiel left
[07:37] *** alini joined
[07:47] *** zakharyas joined
[08:08] *** virtualsue joined
[08:09] *** virtualsue_ joined
[08:12] *** virtualsue left
[08:12] *** virtualsue_ is now known as virtualsue

[08:13] <quester> m: say Any.^methods>>.gist;

[08:13] <camelia> rakudo-moar c57824: OUTPUT«invoke Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<…»

[08:13] *** zakharyas left
[08:14] *** darutoko joined
[08:14] *** zakharyas joined
[08:18] <quester> The reason that Inline::Perl5 blows up during initialization is that it tries to create many methods named "Method+{<anon>}.new".  The second one blows up.

[08:20] *** spider-mario joined
[08:22] *** diana_olhovik_ left
[08:23] *** domidumont joined
[08:24] *** Foxcool_ joined
[08:27] *** Foxcool left
[08:27] *** domidumont left
[08:27] *** Ven left
[08:28] *** domidumont joined
[08:31] *** pierrot left
[08:31] *** pierrot joined
[08:37] *** Ven joined
[08:44] *** mr-foobar joined
[08:45] *** vendethiel joined
[08:46] <lizmat> quester: |Tux| :I think TimToady's latest patch (revert actually) might fix that

[08:46] <lizmat> rebootstrapping now

[08:46] <lizmat> and good *, #perl6!

[08:47] *** Rounin joined
[08:48] <lizmat> alas   :-(

[08:49] <jnthn> morning o/

[08:49] <lizmat> jnthn o/

[08:50] <jnthn> m: say Any.^methods

[08:50] <camelia> rakudo-moar c57824: OUTPUT«invoke Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<anon>}.new Method+{<…»

[08:50] *** koo6 joined
[08:50] <lizmat> I thought this was the "is nodal" change, but apparently it isn't

[08:51] <jnthn> It still looks bust

[08:51] <lizmat> yeah

[08:51] <jnthn> m: say Any.^methods.map(*.name)

[08:51] <camelia> rakudo-moar c57824: OUTPUT«invoke exists_key EXISTS-KEY delete_key DELETE-KEY delete_pos DELETE-POS list flat eager hash Hash Parcel List elems end keys kv values pairs antipairs invert pairup squish rotor reverse sort reduce combinations permutations unique uniq pick roll classify …»

[08:51] <jnthn> A method should always gist to its name

[08:51] <quester> As a quick workaround, panda look Inline::Perl5; ./configure.pl6; mv lib/Inline ~/rakudo/install/share/perl6/lib; vim rakudo/install/share/perl6/lib/Inline/Perl5.pm6.  Near line 17, change the declaration of $path...

[08:52] <quester> ... to include the absolute patch to p5helper.so, something like  state Str $path = "/home/ira/rakudo/install/share/perl6/lib/Inline/p5helper.so";   ...then...

[08:52] *** dolmen joined
[08:52] *** rurban joined
[08:52] <lizmat> jnthn: oddly enough, that's the only thing that src/core/Method.pm

[08:52] <lizmat> does

[08:52] <jnthn> Yeah

[08:53] *** rindolf joined
[08:54] <jnthn> I think the trait that gets shoved on many methods now mixes in to them before the Method class is fully defined, and then we get the usual method cache problems.

[08:54] <quester> ... about line 747, after for Any.^methods>>.gist -> $name { ... add a new line... next if $name ~~ / 'Method+{<anon>}.new' /;

[08:54] <lizmat> jnthn: yeah, confirmed, it doesn't call the Method.name method

[08:55] <lizmat> jnthn: what trait is that anyway and where does it get shoved ?

[08:55] <jnthn> lizmat: I suspect it's the "is nodal" but we had the same issue with "is hidden-from-backtrace

[08:55] <jnthn> lizmat: It's a related problem to the augment + subclass issue.

[08:55] <quester> At that point it should be usable.  The first patch works around the .files method of CompUnitRepo::Local::File apparently not returning anything.  The second one works around the extra method names.

[08:55] <lizmat> but "is nodal" was just removed ?

[08:56] <jnthn> lizmat: from multis, but you never get multis from .^methods

[08:56] <lizmat> aha 

[08:56] <lizmat> ok

[08:56] <lizmat> :-(

[08:56] <lizmat> TimToady's comment was "don't need is nodal on multis", still I see a lot of multis with "is nodal"

[08:57] <quester> .oO( are we having O(fun) yet? )

[08:57] <lizmat> specifically in array_slice

[08:57] <jnthn> Guess I should bump the augment/cache issue a little further up my priority list :)

[08:58] * lizmat tries to remove them from array_slice multis

[08:58] <lizmat> hmmm.. hash_slice actuallt

[08:58] <lizmat> *y

[08:59] <jnthn> bbi30; got some erands to do before I can get on with Perl 6 things for the rest of the day

[08:59] <jnthn> Apparently my body decided I needed a lot of sleep last night too...

[09:03] *** telex left
[09:04] *** telex joined
[09:04] *** jack_rabbit left
[09:06] <quester> Jnthn:  Thanks for looking at that.  I guess my second patch should have been to change line 747 from    for Any.^methods>>.gist    to    for Any.^methods>>.name

[09:06] <dalek> rakudo/nom: a073f5d | lizmat++ | src/core/hash_slice.pm:

[09:06] <dalek> rakudo/nom: Remove some more "is nodal" from multis

[09:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a073f5d178

[09:07] <lizmat> quester: that feels like a valid work around

[09:07] *** dolmen left
[09:07] <lizmat> afk for a bit

[09:09] <quester> .tell [Tux] I have just posted a fairly awkward workaround if you are in a hurry, but it looks like jnthn and lizmat are looking into at least one of the underlying problems, so there is light at the end of the tunnel.

[09:09] <yoleaux> quester: I'll pass your message to [Tux].

[09:10] <quester> ... and to *.all a good night.

[09:12] *** Ven left
[09:12] *** Ven joined
[09:12] *** quester left
[09:14] *** RabidGravy joined
[09:15] *** fhelmberger joined
[09:16] *** tinyblak left
[09:18] *** tinyblak joined
[09:19] *** fhelmberger left
[09:21] *** Ven left
[09:21] *** pierrot left
[09:21] *** pierrot joined
[09:30] *** Akagi201_ left
[09:30] *** vendethiel left
[09:32] *** laouji left
[09:33] *** araujo left
[09:48] *** brrt left
[09:49] *** brrt joined
[09:54] <RabidGravy> morning

[09:55] <masak> good noon, RabidGravy 

[09:59] *** pierrot left
[09:59] *** laouji joined
[10:00] *** lolisa joined
[10:06] *** pierrot joined
[10:10] *** cdc left
[10:10] *** pecastro_ left
[10:13] * |Tux| is not in a hurry

[10:20] *** brrt left
[10:28] *** Ven joined
[10:35] *** hobbs left
[10:35] *** tinyblak left
[10:35] <Ven> m: multi f(Ijnt){}; multi f(Str){}; subset MultiSub of Sub where *.candidates.elems > 1; say &f ~~ MultiSub;

[10:35] <camelia> rakudo-moar a073f5: OUTPUT«5===SORRY!5=== Error while compiling /tmp/V9gBhNDmQI␤Invalid typename 'Ijnt' in parameter declaration. Did you mean 'Int'?␤at /tmp/V9gBhNDmQI:1␤------> 3multi f(Ijnt7⏏5){}; multi f(Str){}; subset MultiSub of ␤»

[10:35] <Ven> m: multi f(Int){}; multi f(Str){}; subset MultiSub of Sub where *.candidates.elems > 1; say &f ~~ MultiSub;

[10:35] <camelia> rakudo-moar a073f5: OUTPUT«True␤»

[10:35] *** tinyblak joined
[10:36] <Ven> m: multi f(Int){}; multi f(Str){}; subset MultiSub of Sub where *.candidates.elems > 1; multi c(MultiSub $f) { say $f("hey"); } c(&f);

[10:36] <camelia> rakudo-moar a073f5: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ZDh45N2tIL␤Strange text after block (missing semicolon or comma?)␤at /tmp/ZDh45N2tIL:1␤------> 3 multi c(MultiSub $f) { say $f("hey"); }7⏏5 c(&f);␤    expecting any of:␤        infix␤        i…»

[10:36] <Ven> m: multi f(Int){}; multi f(Str){}; subset MultiSub of Sub where *.candidates.elems > 1; multi c(MultiSub $f) { say $f("hey"); }; c(&f); # sigh

[10:36] <camelia> rakudo-moar a073f5: OUTPUT«Cannot look up attributes in a type object␤  in sub c at /tmp/uzOV2Y68Ga:1␤  in sub c at /tmp/uzOV2Y68Ga:1␤  in block <unit> at /tmp/uzOV2Y68Ga:1␤␤»

[10:37] *** hobbs joined
[10:40] *** tinyblak left
[10:41] <jnthn> Ven: *.is_dispatcher maybe

[10:41] <Ven> m: multi f(Int){}; multi f(Str){}; subset MultiSub of Sub where *.is_dispatcher; multi c(MultiSub $f) { say $f("hey"); }; c(&f); # sigh

[10:41] <camelia> rakudo-moar a073f5: OUTPUT«Cannot look up attributes in a type object␤  in sub c at /tmp/7JKZ7xuxx7:1␤  in sub c at /tmp/7JKZ7xuxx7:1␤  in block <unit> at /tmp/7JKZ7xuxx7:1␤␤»

[10:42] <jnthn> Odd...

[10:42] <jnthn> oh, wait

[10:42] <jnthn> That's a double-closure thing

[10:42] <jnthn> where already adds a layer of closure

[10:43] <masak> say what?

[10:43] <masak> I'm sure I've seen a {} block after `where`

[10:43] <jnthn> Oh, though it should still work there I guess

[10:43] <jnthn> masak: yes, in that case it doesn't have to

[10:44] <jnthn> It still seems to get upset without the * though. I don't know why.

[10:46] <lizmat> .tell nine would it be possible for me to get an Inline::Perl5 commit bit ?

[10:46] <yoleaux> lizmat: I'll pass your message to nine.

[10:46] <lizmat> I just tried to push quester's workaround for the Inline::Perl5 is nodal breakage

[10:49] *** rindolf left
[11:04] *** gfldex joined
[11:08] *** pippo joined
[11:09] <pippo> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]"; say $str;

[11:09] <camelia> rakudo-moar a073f5: OUTPUT«Ḍ␤»

[11:09] <pippo> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "D"; say $str;

[11:09] <camelia> rakudo-moar a073f5: OUTPUT«Ḍ̇␤»

[11:10] <pippo> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "DD"; say $str;

[11:10] <camelia> rakudo-moar a073f5: OUTPUT«Ḍ̇D␤»

[11:12] <pippo> ^^ bug?

[11:12] *** pippo left
[11:12] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]"; say $str.codes

[11:12] <camelia> rakudo-moar a073f5: OUTPUT«2␤»

[11:12] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]\"; say $str.codes

[11:12] <camelia> rakudo-moar a073f5: OUTPUT«5===SORRY!5=== Error while compiling /tmp/9tgKI6t_Rg␤Unable to parse expression in double quotes; couldn't find final '"' ␤at /tmp/9tgKI6t_Rg:1␤------> 3c[COMBINING DOT ABOVE]\"; say $str.codes7⏏5<EOL>␤    expecting any of:␤        meth…»

[11:12] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]"; say $str.codes

[11:12] <camelia> rakudo-moar a073f5: OUTPUT«1␤»

[11:13] <lizmat> so it really appears its not combining the 2nd combining dot

[11:13] <lizmat> I would say, bug indeed

[11:14] <jnthn> I think .codes may still be wrong

[11:14] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]"; say $str.NFD   # where this the D go?

[11:14] <camelia> rakudo-moar a073f5: OUTPUT«NFD:0x<0044 0307>␤»

[11:15] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]"; say $str.NFD

[11:15] <camelia> rakudo-moar a073f5: OUTPUT«NFD:0x<0044 0323 0307>␤»

[11:15] <lizmat> hmm... NFD seems to be correct

[11:15] <jnthn> .codes is about NFC though

[11:15] <jnthn> On a Str anyway

[11:15] <lizmat> ah, ok... 

[11:16] <jnthn> But yeah, it's correct on Moar; I already did that

[11:16] <jnthn> I think the concatenation thing is separate

[11:16] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]"; say $str.graphs

[11:16] <camelia> rakudo-moar a073f5: OUTPUT«Method 'graphs' not found for invocant of class 'Str'␤  in block <unit> at /tmp/P8MI0R9pgn:1␤␤»

[11:16] <jnthn> I think we also decided .graphs will go away as it's just a .chars synonym so there's not much point.

[11:16] <lizmat> ok

[11:17] <lizmat> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]"; say $str.chars  # 2 would be incorrect then?

[11:17] <camelia> rakudo-moar a073f5: OUTPUT«1␤»

[11:17] <lizmat> good thing it is 1 then  :-)

[11:17] <jnthn> 1 is the right answer for .chars there, yes

[11:17] <jnthn> 2 is the right answer for .codes

[11:17] <jnthn> If you want to know how many codes in NFD then you need to say .NFD.codes

[11:18] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.chars;

[11:18] <camelia> rakudo-moar a073f5: OUTPUT«2␤»

[11:18] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str;

[11:18] <camelia> rakudo-moar a073f5: OUTPUT«Ḍ̇␤»

[11:18] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.codes;

[11:18] <camelia> rakudo-moar a073f5: OUTPUT«3␤»

[11:18] <jnthn> Odd, the .chars and .codes are right there but something odd goes on at output

[11:18] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.NFD;

[11:18] <camelia> rakudo-moar a073f5: OUTPUT«NFD:0x<0044 0323 0307 0044>␤»

[11:18] <jnthn> That's correct too

[11:18] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.NFC;

[11:18] <camelia> rakudo-moar a073f5: OUTPUT«NFC:0x<1e0c 0307 0044>␤»

[11:18] <jnthn> As is that

[11:19] <lizmat> yeah, it's only on output

[11:19] *** WABSIAX joined
[11:19] <lizmat> conversion to utf-8 maybe ?

[11:19] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.encode('utf-');

[11:19] <camelia> rakudo-moar a073f5: OUTPUT«Unknown string encoding: 'utf-'␤  in block <unit> at /tmp/8m4lPRb9wN:1␤␤»

[11:19] <jnthn> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]D"; say $str.encode('utf-8');

[11:19] <camelia> rakudo-moar a073f5: OUTPUT«utf8:0x<e1 b8 8c cc 87>␤»

[11:19] <jnthn> m: say chr(87)

[11:19] <camelia> rakudo-moar a073f5: OUTPUT«W␤»

[11:19] <jnthn> Hmm

[11:20] <lizmat> does chr() take hex ?

[11:20] <jnthn> oops

[11:20] <lizmat> m: say chr(0x87)

[11:20] <camelia> rakudo-moar a073f5: OUTPUT«␤»

[11:20] <jnthn> And yeah, thinko :)

[11:20] <jnthn> Something is wrong in that utf-8 encoded output

[11:21] <jnthn> I'll investigate/fix/add test for it after lunch...which means shopping... At least I got my admin tasks done. :)

[11:22] <lizmat> :-)

[11:34] *** vendethiel joined
[11:48] *** Ven left
[11:48] *** RabidGravy left
[11:58] *** vendethiel left
[11:59] *** cdc joined
[11:59] *** rurban left
[11:59] <masak> I found this a fascinating read: http://boundvariable.org/press/tr-06-163.pdf

[12:00] <masak> (and I'm guessing anyone connected with p6cc somehow will, too)

[12:00] <masak> so, today's mini-challenge: implement the Universal Machine from Figure 2 in Perl 6 :)

[12:01] * DrForr pricks up his ear.

[12:03] *** vendethiel joined
[12:04] <masak> I like the "(c) 19106" on the first page. I wonder if it's some kind of deliberate humor, or just a Y2K bug in the software that generated that string.

[12:06] *** jlbhshluekg joined
[12:06] *** muraiki joined
[12:06] *** jlbhshluekg left
[12:06] *** jlbhshluekg joined
[12:06] *** jlbhshluekg left
[12:08] <rarara> there is one thing which stumble me on this construct: my @fib := 1, 1, { $^a + $^b } ... *; why $^a and $^b? Wouldn't have been more general to pass the whole @fib (the calculated part) in an array?

[12:08] <masak> rarara: the block takes two parameters, so you get the last two values from the sequence.

[12:09] <masak> rarara: note that there's a difference between the *sequence* you're binding into the array, and the array itself.

[12:09] <rarara> masak ok but if I wanted tribonacci instead of fibonacci I would have to add $^c ?

[12:09] <masak> rarara: yes.

[12:09] <masak> rarara: I usually find it problematic (even with binding, as used here) to talk of the array that's being constructed. usually leads to infinite looping.

[12:10] <rarara> @seq[n] := "The sum of all number from 0 to n?

[12:10] <rarara> what about this?

[12:10] <masak> m: say [\+] 0..10

[12:10] <camelia> rakudo-moar a073f5: OUTPUT«0 1 3 6 10 15 21 28 36 45 55␤»

[12:10] <rarara> this is nice of course; but not the same construct

[12:10] * masak realizes he is not solving the problem on rarara's terms

[12:10] <masak> but that's part of my point: don't do it that way :)

[12:11] <rarara> Ok, would have been nice if it was possble: could have been used for things like convolutions / integrations

[12:11] <rarara> which fine can be made in other ways

[12:11] <masak> not saying it's impossible.

[12:11] <masak> saying it's not as wise an idea as you might think.

[12:12] *** mr-foobar left
[12:14] *** Guest3343 is now known as felher

[12:16] *** pecastro joined
[12:16] *** cschwenz joined
[12:21] <jnthn> I've rejected RT #116525 and RT #117109; they wanted .reverse and .pick to flatten, but we decided in the GLR on a non-flattening policy.

[12:21] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=116525

[12:21] <jnthn> synbot6: Hey, you lazy git! Give *both* links!

[12:22] * masak submits a pull request for that

[12:23] <masak> hm, where's synbot6's repo?

[12:23] <masak> oh, it's still https://github.com/tadzik/synopsebot

[12:23] *** brrt joined
[12:23] <btyler> is there any way to serialize a sub + environment at runtime? I was thinking of a goofy project to hack up a thread scheduler that schedules things on remote boxes instead of threads.

[12:23] <brrt> m: my @a = qw[a b c]; if any @a eq 'b' { say "YAY"; } else { say "NOES"; }

[12:23] <camelia> rakudo-moar a073f5: OUTPUT«NOES␤»

[12:24] <btyler> just for kicks, mind you

[12:24] <brrt> m: my @a = qw[a b c]; if any(@a) eq 'b' { say "YAY"; } else { say

[12:24] <brrt>        "NOES"; }

[12:24] <camelia> rakudo-moar a073f5: OUTPUT«5===SORRY!5===␤Argument to "say" seems to be malformed␤at /tmp/LdMvyhyXMV:1␤------> 3any(@a) eq 'b' { say "YAY"; } else { say7⏏5<EOL>␤Missing block␤at /tmp/LdMvyhyXMV:1␤------> 3any(@a) eq 'b' { say "YAY"; } else { say7⏏5<EOL>…»

[12:24] <brrt> m: my @a = qw[a b c]; if any @a eq 'b' { say "YAY"; } else { say "NOES"; }

[12:24] <camelia> rakudo-moar a073f5: OUTPUT«NOES␤»

[12:24] <brrt> m: my @a = qw[a b c]; if any(@a) eq 'b' { say "YAY"; } else { say "NOES"; }

[12:24] <camelia> rakudo-moar a073f5: OUTPUT«YAY␤»

[12:24] <brrt> parsing thingy

[12:25] <brrt> is this intended?

[12:25] <jnthn> Not a bug.

[12:25] <brrt> right :-)

[12:25] <jnthn> Yes, list ops drop precedence pretty low :)

[12:25] <brrt> hmm

[12:25] <brrt> m: my @a = qw[a b c]; say @a.any eq 'b';

[12:25] <camelia> rakudo-moar a073f5: OUTPUT«any(False, True, False)␤»

[12:25] <brrt> hence the preference for method calls i guess

[12:26] <masak> speak for yourself

[12:26] <masak> in this case, coulda solved it with `if 'b' eq any @a`

[12:26] <brrt> i speak for... i don't... :-(

[12:26] <brrt> yeah

[12:26] <masak> just need to keep in mind that listops have one of them Haskell `$` invisibly attached to them

[12:27] <masak> like an invisible starting paren, with the ending paren coming at the end of the expr

[12:30] *** mj41 joined
[12:30] <DrForr> Test::is_deeply() would be more useful with some way to point out where the difference starts. /me makes a note for later.

[12:30] *** cognominal joined
[12:31] <mj41> mls: say "abc{Uni.new(0x1E0C, 0x0307).Str}abc"

[12:31] <yoleaux> 3 Apr 2015 23:45Z <hoelzro> mj41: the docker folk have added an official repo for rakudo-star

[12:31] * masak just did something that made him go "oh, I've got to blog about this"

[12:31] <jnthn> haha...

[12:31] <jnthn> char * MVM_string_utf8_encode_substr(MVMThreadContext *tc,

[12:31] <jnthn>         MVMString *str, MVMuint64 *output_size, MVMint64 start, MVMint64 length) {

[12:32] <jnthn>     /* XXX This is terribly wrong when we get to doing NFG properly too. One graph may

[12:32] <jnthn>      * expand to loads of codepoints and overflow the buffer. */

[12:32] <jnthn> Except the code is too robust to actually overflow the buffe

[12:32] <jnthn> So it doesn't, it just drops the codepoints instead :P

[12:32] <masak> darn you, robust code.

[12:32] * jnthn fixes it :)

[12:33] <jepeway> m: use Test; my $s = sub {}; is $s, sub {}, "sub"; # what's the right way to do this?

[12:33] <camelia> rakudo-moar a073f5: OUTPUT«Code object coerced to string (please use .gist or .perl to do that)  in sub is at lib/Test.pm:135␤␤Code object coerced to string (please use .gist or .perl to do that)  in sub is at lib/Test.pm:135␤␤ok 1 - sub␤»

[12:33] <mj41> mls: say "abc{Uni.new(0x1E0C, 0x0307).Str}abc"

[12:33] <moritz> jepeway: what are you trying to do?

[12:33] <jnthn> mj41: Did you mean "m:" :)

[12:34] <moritz> m: use Test; cmp_ok sub { }, &[===], sub { }

[12:34] <camelia> rakudo-moar a073f5: OUTPUT«not ok 1 - ␤␤# Failed test at /tmp/LBBXtpGtq6 line 1␤Code object coerced to string (please use .gist or .perl to do that)  in sub cmp-ok at lib/Test.pm:202␤␤# expected: ''␤Code object coerced to string (please use .gist or .perl to do that)  in…»

[12:34] <mj41> yes, but don't know how it become mls

[12:34] <jnthn> mj41: Tab completion? :)

[12:34] <moritz> mj41: by tab completion :-)

[12:34] <jepeway> test that two "subs" are the "same"

[12:34] <moritz> jepeway: use === (or !===) for that

[12:34] <moritz> m: use Test; cmp_ok sub { }, &[!===], sub { }

[12:34] <camelia> rakudo-moar a073f5: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DpSkWc2gc1␤Variable '&infix:<!===>' is not declared. Did you mean any of these?␤    &infix:<===>␤    &infix:<=:=>␤␤at /tmp/DpSkWc2gc1:1␤------> 3use Test; cmp_ok sub { }, &[!===]7⏏5, sub { }…»

[12:35] <moritz> m: use Test; cmp_ok sub { }, { $^a !=== $^b }, sub { }

[12:35] <camelia> rakudo-moar a073f5: OUTPUT«ok 1 - ␤»

[12:35] <mj41> yes, but I do not use <tab> ... probably some xchat bug

[12:35] <mj41> mls: say 'ok'

[12:36] <moritz> muhaha

[12:36] *** rindolf joined
[12:36] <jepeway> ok. er...moritz: ok, gotcha.

[12:37] <mj41> m: say "abc{Uni.new(0x1E0C, 0x0307).Str}abc"

[12:37] <camelia> rakudo-moar a073f5: OUTPUT«abcḌ̇ab␤»

[12:37] <mj41> fixed, google++

[12:38] <jnthn> mj41: Yes, that's another case of the utf-8 encoder "I dunno NFG enough yet" thing I'm fixing at the moment :)

[12:38] <jepeway> moritz: should &is be smarter? or is it meant to do simple things, and cmp_ok with a comparator is where you're s'posed to go for trickier tests?

[12:38] <mj41> xchat: Preferences - Input box -> Automatic nick completion (without TAB key)

[12:39] *** laouji left
[12:39] <moritz> jepeway: the latter

[12:39] <mj41> thanks, jnthn++

[12:40] <moritz> jepeway: &is is supposed to do string comparisons, though recently we've made it a bit smarter when comparing to type objects

[12:40] <moritz> but it shouldn't become too smart, to be able to stay predictable

[12:41] <jepeway> moritz: understood.

[12:41] <timotimo> o/

[12:42] <jepeway> moritz: thankee, btw.

[12:43] <moritz> jepeway: you're welcome

[12:44] *** domidumont left
[12:44] <jepeway> gone.

[12:46] *** muraiki left
[12:49] *** pippo joined
[12:50] <masak> > I've rejected RT #116525 and botsnack and RT #117109;

[12:50] <masak> ]]] Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=116525

[12:50] <synbot6> om nom nom

[12:50] <masak> ]]] om nom nom

[12:50] <masak> ]]] Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=117109

[12:50] <masak> hehe

[12:50] <masak> jnthn: ^^^

[12:50] <masak> submitting pull request now.

[12:53] <jnthn> :)

[12:53] <jnthn> masak++

[12:58] <masak> tadzik: https://github.com/tadzik/synopsebot/pull/6

[12:59] <masak> the "oh, I've got to blog about this" thing I did was, before I wrote this patch, I set up a small 11-line REPL that instrumented Synopsebot and with which I could debug it as I wrote the solution.

[13:00] <masak> could also have written tests in much the same way, but that felt a little overengineered in this case.

[13:01] *** lucasb joined
[13:02] <lucasb> good friday to you o/

[13:02] <masak> \o

[13:02] <lucasb> m: Failure.new(Exception.new)

[13:02] <camelia> rakudo-moar a073f5: OUTPUT«No exception handler located for catch␤   at <unknown>:1  (/home/camelia/rakudo-inst-2/share/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:16475  (/home/camelia/rakudo-inst-2/share/perl6/runtime/CORE.setting.moarvm:si…»

[13:03] <lucasb> m: Failure.new(Exception.new); 1

[13:03] <camelia> rakudo-moar a073f5: OUTPUT«(signal SEGV)»

[13:04] <lucasb> I don't know why the last statement is special for rakudo...

[13:04] <moritz> it's not evaluated in sink context

[13:04] <lucasb> In "2;3;4", only 2 and 3 get warnings for useless use

[13:04] <moritz> which is kinda a bug

[13:04] <lucasb> moritz: oh, thanks

[13:05] <moritz> in the general case, when you have code inside a block, the last statement is returned

[13:05] <moritz> hence it's not in sink context

[13:05] <moritz> and we haven't fixed that for the mainline

[13:05] <moritz> m: sub f { 2; 3; 4 }; say f()

[13:05] <camelia> rakudo-moar a073f5: OUTPUT«4␤»

[13:05] <moritz> it doesn't warn inside subs either :(

[13:06] <jnthn> For the mainline, we didn't fix it 'cus the REPL wants it that way also...

[13:06] <moritz> right

[13:08] <lucasb> Maybe this is helping hide some bugs, because I have to put one at the end "...; 1"

[13:09] <lucasb> I thought maybe "sink Failure.new(Exception.new)" would give the same segfault, but maybe I don't know how to use sink

[13:10] * jnthn will investigate the SEGV

[13:10] <lucasb> jnthn: thanks!

[13:10] <moritz> m: Failure.new(Exception.new).sink

[13:10] <camelia> rakudo-moar a073f5: OUTPUT«(signal SEGV)»

[13:10] <moritz> there ya go

[13:10] <lucasb> moritz++

[13:10] * masak submits rakudobug

[13:12] * jnthn largely re-did the UTF-8 encoder to it'll handle NFG and use less memory in the common case

[13:12] <jnthn> Currently spectesting.

[13:12] <timotimo> wow, that's ...

[13:14] <moritz> Exception.new leaves $!ex and $!bt undefined

[13:14] <pippo> jnthn++

[13:14] <moritz> but the rest of the code assumes that they are set

[13:14] *** skids joined
[13:15] <moritz> and it's the catching/throwing code that generates a new exception and binds $!ex and $!bt into them

[13:15] <jnthn> moritz: Still shouldn't SEGV either way...

[13:15] <hoelzro> o/ #perl6

[13:15] <jnthn> moritz: I'll fix the SEGV at Moar level and leave somebody else to figure out what it should actually do

[13:15] <moritz> m: Failure.CREATE.sink

[13:15] <camelia> rakudo-moar a073f5: OUTPUT«Method 'throw' not found for invocant of class 'Any'␤  in block <unit> at /tmp/zypTeglcI2:1␤␤»

[13:16] <masak> https://rt.perl.org/Ticket/Display.html?id=124434

[13:17] <lucasb> masak++, thanks

[13:28] <cognominal> if you want to segfault moarvm rakudo :  use rule :s

[13:29] <cognominal> unimplemented pragma should not have license to segfault :)

[13:30] *** rurban joined
[13:31] <hoelzro> my @values{1..*} creates a 1-indexed array, right?

[13:31] <cognominal> probably use could use some expertise.

[13:31] <masak> cognominal: is this something you can reproduce on camelia?

[13:32] <masak> walk &

[13:33] *** kaare__ left
[13:33] <cognominal> maybe I don't want to segfault camelia. What happens then

[13:33] *** xfix joined
[13:33] *** xfix left
[13:33] *** xfix joined
[13:36] <jnthn> cognominal: It creates a separate Rakudo process, so camelia is unharmed.

[13:36] <cognominal> it happens on the Perl 6 shell

[13:36] <cognominal> m: use rule :s

[13:36] <camelia> rakudo-moar a073f5: OUTPUT«===SORRY!===␤Could not find rule in any of: /home/camelia/.perl6/2015.04-130-ga073f5d/lib, /home/camelia/.perl6/2015.04-130-ga073f5d, /home/camelia/rakudo-inst-2/share/perl6/lib, /home/camelia/rakudo-inst-2/share/perl6/vendor/lib, /home/camelia/rakudo-in…»

[13:37] <cognominal> So it's Perl 6 shell specific

[13:38] <timotimo> perl6 shell?

[13:39] <timotimo> oh, the REPL

[13:39] <timotimo> the REPL has some ... problems

[13:39] <timotimo> hoelzro: i don't think that's implemented yet

[13:39] <cognominal> and it happens even if ones launch it as:  perl6 --target=parse

[13:40] *** thou joined
[13:41] *** skids left
[13:41] <cognominal> timotimo: that's too bad because that's should be the best way for people to dip their toes in the Perl 6 ocean to test its water.

[13:42] <timotimo> that's true ;(

[13:42] <cognominal> if that clips their toes they will not come back.

[13:44] <cognominal> I can't understand why that behavior is REPL specific

[13:45] <btyler> cognominal: that doesn't occur for me. think you could bisect the issue?

[13:46] <btyler> I get the same output in my REPL as camelia gives

[13:48] <hoelzro> timotimo: doesn't seem like it =/

[13:49] *** raiph joined
[13:51] *** adu joined
[13:51] <timotimo> funny. just earlier today i thought about arrays that have enum indices

[13:51] *** airdisa joined
[13:52] <timotimo> cognominal: fwiw, the repl just recently learned to cope with binding better, that makes a gigantic difference because you use binding so often to keep lists lazy

[13:53] <cognominal> nice

[13:55] <cognominal> btyle what version of rakudo do you use on what platform?

[13:56] <cognominal> btyler what version of rakudo do you use on what platform?

[13:56] <btyler> I'm updating to HEAD on moar/nqp/rakudo and rebuilding at the moment, osx 10.10

[13:57] *** koo6 left
[13:58] *** adu left
[13:58] <cognominal> that's about time I learn about git bisect

[14:01] <DrForr> Better than hashes with enum indices :)

[14:06] <jnthn> masak: Mebbe you have a moment to review https://rt.perl.org/Ticket/Display.html?id=117307 and see if current sequence semantics either do what you want, or if the ticket is otherwise no longer needed?

[14:12] <dalek> nqp: 861faf7 | jnthn++ | tools/build/MOAR_REVISION:

[14:12] <dalek> nqp: Get various MoarVM string-related fixes.

[14:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/861faf751b

[14:12] <dalek> rakudo/nom: 8a7e9c4 | jnthn++ | tools/build/NQP_REVISION:

[14:12] <dalek> rakudo/nom: Bump NQP_REVISION for MoarVM with string fixes.

[14:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a7e9c4c12

[14:13] <dalek> roast: fa3bfee | jnthn++ | S15-nfg/from-buf.t:

[14:13] <dalek> roast: Test round-trip of synthetics with encode/decode.

[14:13] <dalek> roast: review: https://github.com/perl6/roast/commit/fa3bfee2a7

[14:13] <dalek> roast: bf3811c | jnthn++ | S04-exceptions/fail.t:

[14:13] <dalek> roast: Test for RT #118785 (use fatal semantics).

[14:13] <dalek> roast: review: https://github.com/perl6/roast/commit/bf3811c336

[14:13] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=118785

[14:13] <cognominal> oops, when compiling the version tagged Vladivostok, I get No registered operation handler for 'readlineintfh'  :(

[14:15] <cognominal> I am probably doint it wrong :(

[14:17] *** adu joined
[14:17] <cognominal> indeed it uses an already installed nqp-m :(

[14:20] *** koo6 joined
[14:24] *** pecastro left
[14:25] *** raiph left
[14:27] *** raiph joined
[14:29] *** alini left
[14:29] *** tinyblak joined
[14:31] *** brrt left
[14:32] <timotimo> right; we have "need at least this version for new-enough ops", but not "must not use this newer version with an op removed"

[14:34] <cognominal> :)

[14:35] <cognominal> need some rest :(

[14:37] *** alini joined
[14:40] *** adu left
[14:52] *** RabidGravy joined
[14:53] *** rindolf left
[14:57] *** diana_olhovik joined
[14:59] <notjack> m: say.WHAT

[14:59] <camelia> rakudo-moar 8a7e9c: OUTPUT«5===SORRY!5===␤Argument to "say" seems to be malformed␤at /tmp/ih2PWknpI1:1␤------> 3say7⏏5.WHAT␤Other potential difficulties:␤    Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or …»

[14:59] <notjack> I wonder how many common emoticons have legitimate interpretations in p6

[15:01] <hoelzro> does the fact that @*INC is now @?INC mean that one can't manipulate the module search path at runtime?

[15:01] <notjack> m: say(.WHAT);

[15:01] <camelia> rakudo-moar 8a7e9c: OUTPUT«(Any)␤»

[15:03] <hoelzro> also, is there a generic equivalent to <=? like before= or something?

[15:05] <dalek> rakudo/nom: ea8c01a | jnthn++ | src/Perl6/Actions.nqp:

[15:05] <dalek> rakudo/nom: Make { 1 R=> 'a' } and { %*h } construst hashes.

[15:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea8c01ad75

[15:07] <dalek> roast: 9854a68 | jnthn++ | S05-mass/named-chars.t:

[15:07] <dalek> roast: Unfudge tests unbusted after Moar NFG fix.

[15:07] <dalek> roast: review: https://github.com/perl6/roast/commit/9854a68587

[15:07] <dalek> roast: 9fad51e | jnthn++ | S06-other/anon-hashes-vs-blocks.t:

[15:07] <dalek> roast: Tests for RT #114966 and RT #123641.

[15:07] <dalek> roast: review: https://github.com/perl6/roast/commit/9fad51ea12

[15:07] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=114966

[15:11] *** Vlavv left
[15:12] *** pecastro joined
[15:14] <dalek> roast: 7ad6596 | jnthn++ | S14-roles/mixin.t:

[15:14] <dalek> roast: Tests for RT #122756 and RT #114668.

[15:14] <dalek> roast: 

[15:14] <dalek> roast: Two already-fixed-in-Rakudo mixin bugs.

[15:14] <dalek> roast: review: https://github.com/perl6/roast/commit/7ad6596780

[15:14] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=122756

[15:14] <jnthn> Was expecting to fix those, then found I already had at some point :)

[15:18] *** kaare__ joined
[15:22] *** ugexe_ is now known as ugexe

[15:22] *** cschwenz left
[15:23] *** Vlavv joined
[15:31] <lizmat> m: %*ENV<RAKUDO_VERBOSE_STACKFRAME>=1; sub a { die }; a

[15:31] <camelia> rakudo-moar ea8c01: OUTPUT«Died␤  in sub a at /tmp/QSq6CQ0Sre:1␤    1 *%*ENV<RAKUDO_VERBOSE_STACKFRAME>=1; sub a { die }; a␤␤  in block <unit> at /tmp/QSq6CQ0Sre:1␤    1 *%*ENV<RAKUDO_VERBOSE_STACKFRAME>=1; sub a { die }; a␤␤␤»

[15:32] <lizmat> m: %*ENV<RAKUDO_VERBOSE_STACKFRAME>=1;␤sub a { die };␤a

[15:32] <camelia> rakudo-moar ea8c01: OUTPUT«Died␤  in sub a at /tmp/ioBp0ggUiH:2␤    1  %*ENV<RAKUDO_VERBOSE_STACKFRAME>=1;␤    2 *sub a { die };␤    3  a␤␤  in block <unit> at /tmp/ioBp0ggUiH:3␤    2  sub a { die };␤    3 *a␤␤␤»

[15:32] <lizmat> :)

[15:33] <arnsholt> hoelzro: That's infix:<le>

[15:33] <hoelzro> arnsholt: le isn't Str-specific?

[15:33] <RabidGravy> jnthn, you have been dobbed in as the design authority of channels and I want to clarify the way that earliest is intended to work before I document it further ;-)

[15:33] <arnsholt> Oh, right. For some reason I though those were generic

[15:34] <jnthn> RabidGravy: Trouble is, I didn't design much of the way things are now... :S

[15:34] <RabidGravy> ah, 

[15:35] <jnthn> There was no syntax sugar at first. By now, we have syntax sugar I don't actually understand either...

[15:36] <RabidGravy> my specific question was is the behaviour that if there are any channel specific more statements, then the more * are totally ignored deliberate or just "lets just do it"

[15:37] <lizmat> hmmm... if it isn't jnthn, it must have been me?

[15:37] <lizmat> must have slipped my mind  :-(

[15:37] <jnthn> I think several people worked on the construct

[15:37] <jnthn> Not just you, lizmat 

[15:37] <lizmat> *phew*   :-)

[15:38] <jnthn> So I don't think it's just bad memory on your part ;P

[15:38] <lizmat> well, old geezesses tend to lose their memory  :-(

[15:39] <RabidGravy> my expectation (which I think might be what most people would think) is that is there is a  "earliest @channels { more $channel {} more * {} } that the "more *" would get called on all the other channels that aren't $channel

[15:39] <dalek> rakudo/nom: 0e30f48 | lizmat++ | src/Perl6/World.nqp:

[15:39] <dalek> rakudo/nom: Don't force the default SHORT-ID here

[15:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e30f48988

[15:39] <RabidGravy> this seems to be entirely opposite to the case that is coded

[15:39] <jnthn> RabidGravy: That seems a reasonable enough expectation...

[15:40] <RabidGravy> right now if there are any channel specific more or done blocks then the wildcard ones don't get used at all

[15:41] *** airdisa left
[15:41] <RabidGravy> the spec on this is somewhat handwavey

[15:42] <RabidGravy> in src/core/asyncops.pm for anyone who may be playing along at home

[15:46] <dalek> rakudo/nom: 6887699 | lizmat++ | src/core/Backtrace.pm:

[15:46] <dalek> rakudo/nom: Move emphasis to line number

[15:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68876990b2

[15:46] *** airdisa joined
[15:49] *** zakharyas left
[15:49] <RabidGravy> the change is quite small really but I'd like to get the opinion of the person who wrote the EARLIEST there because their understanding of the spec might be completely different

[15:51] <lizmat> RabidGravy: we're all pretty much handwavy there

[15:51] <lizmat> if it makes sense to jnthn and you, that's good enough for me  :-)

[15:52] *** khisanth_ joined
[15:54] <lizmat> meanwhile, I'm looking at a weird action-at-a-distance bug

[15:54] <DrForr> Okay, I'm now scared. I just added 3 AST keys to the ANTLR4 rules, added the tests, and it worked the first time.

[15:54] <lizmat> working on CompUnitRepo, I break set tests: the file only does a "use Test"  :-(

[15:55] *** Khisanth left
[15:55] *** pierrot left
[15:55] *** pierrot joined
[15:56] <dalek> nqp: 6ac09e8 | jnthn++ | t/qregex/ (2 files):

[15:56] <dalek> nqp: Unbitrot and run goal tests.

[15:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ac09e8e29

[15:56] <dalek> nqp: 413aa65 | jnthn++ | t/qregex/rx_goal:

[15:56] <dalek> nqp: Tests for /a ~ (c) (b)/ capture order issue.

[15:56] <dalek> nqp: 

[15:56] <dalek> nqp: Todo'd until I get it fixed.

[15:56] <lizmat> well, it also broke panda, so it must be unit loading specific

[15:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/413aa65282

[15:58] *** diana_olhovik left
[16:03] <ugexe> is there a better way to write: if once {1} || $some-cond { ... }

[16:04] *** araujo joined
[16:04] *** lucasb left
[16:05] *** araujo left
[16:05] *** araujo joined
[16:05] *** araujo left
[16:08] <raydiak> ugexe: since the once {1} will run the {1} once but return the 1 every time, the easier way to write it is "if True { ... }" which collapses to "..." :)

[16:10] <timotimo> how about

[16:10] <timotimo> my $do-it; once { $do-it = 1 }; if $some-cond || $do-it { ... }?

[16:11] *** cygx joined
[16:12] <raydiak> I'd probably end up doing my $first = True; if $first || $something-else { $first = False; ... }

[16:13] <raydiak> you could put the $first = False; in a once { } if you wanted to optimize prematurely :)

[16:14] *** muraiki joined
[16:18] *** rindolf joined
[16:18] <cygx> so, S19, S28 and Rakudo do not agree on what goes into $*PROGRAM, $*PROGRAM_NAME, $*EXECUTABLE, $*SHEBANG, $?COMPILER

[16:18] <timotimo> maybe you really want a state variable instead?

[16:18] *** eli-se joined
[16:19] <eli-se> hi

[16:20] <dalek> rakudo/nom: 5fa3ffb | lizmat++ | src/Perl6/Actions.nqp:

[16:20] <dalek> rakudo/nom: Make $?RAKUDO_MODULE_DEBUG a proper constant

[16:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5fa3ffb5f0

[16:20] <ugexe> state variables didn't seem to work the way i needed with taps

[16:21] <dalek> nqp: 5b57c74 | jnthn++ | src/ (4 files):

[16:21] <dalek> nqp: Fix /a ~ (c) (b)/ capture order bug.

[16:21] <dalek> nqp: 

[16:21] <dalek> nqp: Introduce a new node type that desugars, but lets us easily get the

[16:21] <dalek> nqp: capture order straightened out.

[16:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5b57c74231

[16:21] <dalek> nqp: 3d7bdf2 | jnthn++ | t/qregex/rx_goal:

[16:21] <dalek> nqp: Untodo tests for /(a) ~ (c) (b)/.

[16:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3d7bdf2c42

[16:21] *** vendethiel left
[16:23] <lizmat> ugexe: a once block is mothing more than a piece of code that gets run depending on a (hidden) state variable

[16:23] <lizmat> *nothin

[16:24] *** Ven_ joined
[16:25] <timotimo> state variables get "cloned" when a closure of the block they're defined in gets taken

[16:25] <lizmat> ah, perhaps the one of a once block doesn't get cloned, which would explain the different behaviour?

[16:26] *** vendethiel joined
[16:26] <lizmat> afk for dinner&

[16:26] <timotimo> dunno

[16:26] <timotimo> i don't work with once blocks often enough

[16:27] <dalek> rakudo/nom: 676c250 | jnthn++ | tools/build/NQP_REVISION:

[16:27] <dalek> rakudo/nom: Bump NQP_REVISION for ~/capture regex fixes.

[16:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/676c2506f1

[16:27] <dalek> roast: e3fb0a3 | jnthn++ | S05-metachars/tilde.t:

[16:27] <dalek> roast: Unfudge RT #77616 test (~/capture interaction).

[16:27] <dalek> roast: review: https://github.com/perl6/roast/commit/e3fb0a3c05

[16:27] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=77616

[16:28] <jnthn> 5 tickets to go until we've a page less of RTs :)

[16:28] <cygx> oO( time to submit new tickets )

[16:29] <timotimo> sure

[16:29] <jnthn> cygx: That's happening too :)

[16:29] <jnthn> There's 4 new and unresolved ones from within the last week.

[16:30] <jnthn> Just that for the moment we seem to be eating them faster than others are feeding new ones in. :)

[16:31] <cygx> m: class Foo { has int $.bar; submethod BUILD(:$!bar) {} }; Foo.new(:bar(42))

[16:31] <camelia> rakudo-moar 688769: OUTPUT«Cannot modify an immutable int␤  in submethod BUILD at /tmp/tv8r9sdpwt:1␤  in block <unit> at /tmp/tv8r9sdpwt:1␤␤»

[16:31] <cygx> ^known?

[16:31] <jnthn> Yes, that one's already in RT :)

[16:31] <cygx> ;)

[16:31] <timotimo> the up and down is what makes perl6 better

[16:32] <jnthn> Oh, for sure. One of the fun things about fixing RTs is knowing that somebody won't get bitten in *that* particular way again. :)

[16:33] <cygx> m: my uint $i = 2 ** 63; say $i

[16:33] <camelia> rakudo-moar 688769: OUTPUT«-9223372036854775808␤»

[16:34] <cygx> that was the 2nd one I encountered recently

[16:35] <jnthn> Yeah, unsinged ints are only partially implemented (in native arrays, and in nativecall)

[16:37] *** rurban left
[16:37] <jnthn> Time for a break and some dinner :) bbl

[16:37] <RabidGravy> right, lizmat, jnthn , <anyone else who cares> I'll change the implementation of EARLIEST as I described about, alter the S17 such that it is more specific about the behaviour and add the one test (which is where all this started) to the roast. Then document it in the concurrency doc as I had planned to :-)

[16:38] <RabidGravy> seem like a plan?

[16:40] <RabidGravy> (I won't get to this until Monday being Beltaine and a big piss-up and all)

[16:46] * colomon spent 45 minutes this morning playing music for elementary kids to dance around a Maypole

[16:47] *** fhelmberger joined
[16:48] *** wtw left
[16:49] *** eternaleye left
[16:50] *** konsolebox left
[16:53] * moritz made a big rhubarb crumble, and served it with ice cream

[16:53] *** domidumont joined
[16:53] *** eternaleye joined
[16:54] <RabidGravy> colomon++ # playing music

[16:56] *** cognominal left
[16:58] <timotimo> RabidGravy: thank you very much

[17:05] <RabidGravy> I haven't done it yet ;-)

[17:05] <timotimo> ++RabidGravy

[17:06] *** telex left
[17:07] *** Ven_ left
[17:08] *** telex joined
[17:10] <RabidGravy> :-)

[17:15] *** tinyblak left
[17:25] *** kaare__ left
[17:26] *** kaare__ joined
[17:35] *** eli-se left
[17:38] <TimToady> hoelzro: there's just !before and !after currently

[17:41] *** airdisa left
[17:45] <cygx> TimToady: is $*EXECUTABLE going to stay, or will it be replaced by S28 $*SHEBANG?

[17:45] *** cognominal joined
[17:45] <cygx> TimToady: Also, what about the S19 examples (eg parrot perl6.pbc) where a single IO::Path object doesn't make much sense?

[17:45] * TimToady doesn't recollect ever seeing $*SHEBANG

[17:46] *** eli-se joined
[17:47] <cygx> S28 talks about $?COMPILER and $*SHEBANG to get at compiler and interpreter, respectively

[17:47] * TimToady doesn't really count himself among the IO experts these days...

[17:48] <TimToady> $*SHEBANG is cute, but ultimately misleading

[17:49] *** koo6 left
[17:49] <TimToady> especially since the interpreter is often started without a shebang at all

[17:52] * TimToady investigates whether there are any nodal tests...

[17:54] *** rindolf left
[17:54] *** rindolf joined
[17:58] *** airdisa joined
[17:58] *** nbdsp joined
[17:58] <cygx> currently, there does not appear too be a way to re-execute the interpreter if --execname is not passed to the moarvm binary

[17:59] <cygx> I wonder if something should be done about that...

[18:00] *** vendethiel left
[18:02] *** vendethiel joined
[18:05] *** liztormato joined
[18:06] <liztormato> cygx: check the code of CompUnit.precomp. It does just that

[18:08] *** spider-mario left
[18:08] <masak> jnthn: https://rt.perl.org/Ticket/Display.html?id=117307 looks closable to me.

[18:08] <masak> m: say .[*-1] given "perl" ... { 3 == ++state $ }

[18:08] <camelia> rakudo-moar 676c25: OUTPUT«pern␤»

[18:09] *** liztormato left
[18:10] <TimToady> m: say .[*-1] given "perl" ... { 3 == ++$ }

[18:10] <camelia> rakudo-moar 676c25: OUTPUT«pern␤»

[18:10] <hoelzro> TimToady: thanks!

[18:11] <masak> if the compiler is found through $?COMPILER, maybe the interpreter should be found through $*INTERPRETER ?

[18:11] <masak> m: say ++$

[18:11] <camelia> rakudo-moar 676c25: OUTPUT«1␤»

[18:11] <masak> m: say ++$; say ++$

[18:11] <camelia> rakudo-moar 676c25: OUTPUT«1␤1␤»

[18:11] *** eli-se left
[18:11] <TimToady> .oO(you think that's obvious today...)

[18:12] <TimToady> (re $*INTERPRETER)

[18:12] <cygx> lizmat: thanks

[18:13] <cygx> lizmat: it goes through $*EXECUTABLE (ie moarvm --execname) as well, though...

[18:17] *** rindolf left
[18:19] *** koo6 joined
[18:24] *** vendethiel left
[18:28] *** airdisa left
[18:30] <jnthn> RabidGravy: Seems like a reasonable plan to me.

[18:31] *** vendethiel joined
[18:31] <jnthn> masak: What'd it take to actually close it? :)

[18:37] *** domidumont left
[18:38] <jnthn> TimToady: I'm looking at RT #75586 and RT #77564, which are about quantified things that make no progress

[18:38] <synbot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=75586

[18:38] <jnthn> TimToady: At the moment we retry them forever, so e.g. <.ws>* is a hang.

[18:39] <jnthn> TimToady: Do we declare that the behavior we want and such constructs erroneous, or do we do the little bit of work to keep track of it?

[18:40] <jnthn> (And thus be able to not keep matching)

[18:40] <jnthn> Uh, move on to the next atom, really.

[18:40] *** eli-se joined
[18:43] <TimToady> we can probably catch some of low-hanging fruit there without compromising :ex and such

[18:44] <TimToady> in the absence of :ex we can bump the start like P5 does, I suppose

[18:47] <jnthn> TimToady: Can you give an example of what :ex thing we don't want to break? I'm not quite seeing it...

[18:49] *** dwarring joined
[18:49] <TimToady> anything starting with .*? might appear to make no progress in that atom until subsequent atoms progress, so you can't just look at the first atom, is all

[18:50] <TimToady> lunch &

[18:52] <hoelzro> does anyone else get bitten by passing invalid keyword args to methods like I do?

[18:52] <hoelzro> I know that methods accept any kwargs for the purposes of passing them to other methods in the inheritance/role chain, but I feel like there's got to be a better solution

[18:56] <labster> like a way of declaring a kwargs whitelist?

[18:56] <PerlJam> hoelzro: All you have to do is invent the appropriate stricture pragma for it ...  ;)

[18:57] <hoelzro> heh

[18:57] <hoelzro> labster: I'm not really sure

[18:57] <hoelzro> I just know that I was trying [ ... ].min(:by(&func)), and was puzzled why &func wasn't being called

[18:57] <hoelzro> maybe I'm the only one with this problem

[18:58] <labster> The compiler goes out of its way to warn you about most typos, but kwargs typos are silently accepted.

[18:58] <geekosaur> it would be nice if some e.g. debug/warning mode would report that some kwarg was never inspected

[18:59] <labster> It would especially be nice at compile time, though that's not always possible.

[19:02] <raiph> TimToady on the topic: http://irclog.perlgeek.de/perl6/2015-03-01#i_10199490

[19:02] *** nbdsp left
[19:04] <labster> PerlJam might have the right idea here.  Or something like method foo( $a, :$name :nomorekwargspls ) { ... }

[19:05] <raiph> (above was TimToady on the topic of unused kwargs)

[19:05] <hoelzro> ah, thanks raiph 

[19:21] *** kaare__ left
[19:29] *** airdisa joined
[19:30] *** airdisa_ joined
[19:34] *** airdisa left
[19:34] *** cygx left
[19:35] *** notjack left
[19:37] *** airdisa joined
[19:37] *** airdisa_ left
[19:39] *** fhelmberger left
[19:39] *** fhelmberger joined
[19:44] *** fhelmberger left
[19:44] *** ahuegyua joined
[19:45] *** ahuegyua left
[19:47] *** mj41 left
[19:47] *** diana_olhovik joined
[19:52] *** diana_olhovik left
[19:58] *** airdisa left
[19:59] *** Vlavv left
[19:59] *** cognominal left
[20:01] *** vendethiel left
[20:04] <masak> "kwargs" is so Python. :) we typically call them "named parameters" (on the callee side).

[20:06] *** xfix left
[20:06] *** dolmen joined
[20:07] <moritz> **kwargs

[20:08] <masak> I see you're all starry-eyed about kwargs.

[20:08] <lizmat> .oO( I prefer quargs )

[20:10] <hoelzro> masak: I use kwargs as a term because it's easy to type =)

[20:12] <geekosaur> qwarks?

[20:12] *** Vlavv joined
[20:12] *** diana_olhovik_ joined
[20:12] <hoelzro> I like lizmat's term, though =)

[20:13] <masak> clearly "quargs" are arguments to a quantum processor.

[20:13] <masak> lizmat is a bit ahead of the curve here.

[20:13] <lizmat> .oO( shiny! )

[20:13] *** avalenn left
[20:15] *** domidumont joined
[20:15] *** domidumont left
[20:15] *** domidumont joined
[20:17] <moritz> and you interpolate quargs with /\quargs, right?

[20:17] *** diana_olhovik_ left
[20:20] <lizmat> actually, you put them in a closed cone shaped container, and generate a force from that  :-)

[20:26] * moritz puts himself into a rectangular container

[20:26] <moritz> 'night folks

[20:27] <jnthn> 'night, moritz 

[20:27] <lizmat> good night, moritz 

[20:28] <masak> 'night, moritz 

[20:29] <PerlJam> moritz: sleep well and awaken refreshed :)

[20:30] <masak> that's an order!

[20:32] *** domidumont left
[20:33] <PerlJam> Are .ast and .made going to remain synonymous or will .ast eventually disappear?

[20:33] *** domidumont joined
[20:36] * masak kinda hopes the former

[20:36] <masak> to me, .ast is way more evocative than .made

[20:37] <masak> I also cannot think of another case where we have a pair of things similar to the `make`/`.made` pair

[20:37] <PerlJam> I have no feelings one way or the other except that make/made seem more naturally dual than make/ast

[20:37] <masak> I believe that's why .made was introduced

[20:37] <masak> it didn't make me switch over, though :)

[20:38] <masak> but I'm just one data point. maybe the rest of the world is crazy about .made

[20:38] <jnthn> I've no objections to .ast continuing to exit.

[20:38] <jnthn> *exist

[20:38] <PerlJam> I would have liked to see make turn into something that feels more ASTy, but I didn't and don't have any ideas on that.

[20:38] <masak> .ast is a noun. .made is the past form of a verb

[20:39] <masak> my biggest beef with `make` is that it is kind of invisibly coupled with the $/ variable in the caller's scope.

[20:39] *** domidumont left
[20:39] <masak> I don't find that very elegant, but the fact is that it's good enough for most uses.

[20:40] <jnthn> masak: You can use $other-match.make(...)

[20:41] <PerlJam> What would be elegant?

[20:41] <masak> jnthn: oh, that's nicer.

[20:41] <masak> but also obviously longer and less convenient.

[20:41] <jnthn> We have various things ($0, $<foo>...) that work against $/

[20:41] <jnthn> But none of these things are the only way to do it, just convenient in the common case.

[20:42] <masak> yeah. also neither of those are calls.

[20:42] <pippo> m: my $str = "\c[COMBINING DOT BELOW]D\c[COMBINING DOT ABOVE]"; $str ~= "D"; say $str;

[20:42] <camelia> rakudo-moar 676c25: OUTPUT«̣ḊD␤»

[20:42] <lizmat> fwiw, I sorta envisioned a future where .ast would actually check whether it generated an AST or not

[20:43] <masak> m: my $str = "\c[COMBINING DOT BELOW]D\c[COMBINING DOT ABOVE]"; say $str.chars

[20:43] <camelia> rakudo-moar 676c25: OUTPUT«2␤»

[20:43] <lizmat> so .ast would be stricter in "typing" than .made

[20:43] <jnthn> 2 is right there, the first acts as...gah, does the Unicode spec call them solitary or isolated...I forgot :)

[20:44] * masak .oO( bachelor code points )

[20:44] <jnthn> I'd have remembered it if they called them something that colorful :P

[20:44] *** darutoko left
[20:50] *** rurban joined
[20:56] <pippo> my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "D"; say $str;

[20:56] <pippo> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "D"; say $str;

[20:56] <camelia> rakudo-moar 676c25: OUTPUT«Ḍ̇D␤»

[20:57] <jnthn> pippo: If you're seeing something different from ^^ locally it's 'cus there was a UTF-8 encoder bug

[20:57] *** vendethiel joined
[20:58] <pippo> ^^ should'nt the dot above the second D be on the first?

[20:59] <jnthn> pippo: Here the two dots are on both.

[20:59] <jnthn> uh

[20:59] <jnthn> The two dots are on the *first*

[20:59] *** airdisa joined
[21:00] <PerlJam> huh.  I see only a dot below the first D

[21:00] <pippo> on my box I have same result as camelia. One on the first and the second (dot) on the second.

[21:00] <jnthn> That is, I see a D with a dot rendered above and below it, though a little awkwardly...

[21:01] <jnthn> I'm suspecting you're seeing rendering issues rather than issues with anything Rakudo is doing.

[21:01] <geekosaur> fwiw my slightly insane IRC client put the dot below on the first D

[21:01] <jnthn> geekosaur: And the dot above too?

[21:01] <geekosaur> the dot above is over the left guillemet

[21:01] <geekosaur> (!)

[21:02] * masak .oO( the dress is blue and black! no, it's white and gold! )

[21:02] <Zoffix> On mine, the dot below is on the first D

[21:02] <PerlJam> heh

[21:02] <Zoffix> http://i.imgur.com/kx52ivw.png

[21:03] <pippo> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "D"; say $str;

[21:03] <camelia> rakudo-moar 676c25: OUTPUT«Ḍ̇D␤»

[21:03] <pippo> ^^ what do you see here ?

[21:03] <Zoffix> Same thing! :O

[21:03] <pippo> I see one dot below the first D and one above the second D

[21:03] <Zoffix> http://i.imgur.com/KLHUVj0.png

[21:04] <Zoffix> But why are there 2 'D's now?

[21:04] <pippo> $str ~= "D";

[21:04] *** alexghacker joined
[21:04] <PerlJam> he appended a second D

[21:05] <jnthn> Here I have http://jnthn.net/tmp/d.pn

[21:05] <jnthn> Here I have http://jnthn.net/tmp/d.png even

[21:05] <Zoffix> Ah, then it's all fine. I didn't know ~= was appending in Perl 6.

[21:05] <geekosaur> http://i.imgur.com/vocaox1.png

[21:05] *** alexghacker left
[21:05] <PerlJam> mine looks like geekosaur's

[21:05] <pippo> jnthn: You are seeing it correct!!

[21:06] <jnthn> Apparently, Windows + PuTTY + irssi FTW :)

[21:06] <pippo> What happened windows became superior ?? :-))

[21:06] <geekosaur> xchat/hexchat known buggy about this

[21:06] <jnthn> Well, the irssi is running on Linux

[21:06] * geekosaur is procrastinating moving to textual which has some chance of being saner

[21:06] *** colomon left
[21:07] <lizmat> geekosaur: Textual is actually saner  :-)

[21:07] <pippo> I have also irssi on linux. But does not render correctly. Same on mozilla firefox.

[21:07] <geekosaur> irssi is terminal based so the rendering has less to do with irssi than the terminal program

[21:08] *** colomon joined
[21:08] <geekosaur> if said terminal uses pango, like mozilla does, then it probably gets it wrong

[21:08] <lizmat> any good place to upload an image quickly ?

[21:09] <PerlJam> imgur

[21:09] <pippo> geekosaur: sigh! :-((

[21:11] <pippo> here is firefox: https://imgur.com/kq7PfXj

[21:13] <geekosaur> hm, gets it differently wrong

[21:13] <geekosaur> suppose it depends on settings

[21:13] <geekosaur> I am told pango can actually do it right but it takes very careful programming

[21:13] <geekosaur> (and I have yet to see it actually do so)

[21:17] *** espadrine joined
[21:17] *** espadrine left
[21:17] *** espadrine joined
[21:19] *** vendethiel left
[21:24] *** colomon left
[21:26] *** muraiki left
[21:28] *** colomon joined
[21:30] *** colomon left
[21:31] *** yqt joined
[21:31] <pippo> FYI: the ipad of my wife renders it correctly.

[21:33] *** P1RATEZ joined
[21:33] *** eli-se left
[21:33] <P1RATEZ> p6: say 'hi';

[21:33] <camelia> rakudo-moar 676c25: OUTPUT«hi␤»

[21:33] *** thou left
[21:34] *** Zoffix left
[21:34] <PerlJam> with a nick like that, I would have expected something more like ...

[21:34] <PerlJam> m: say "ARRRR!"

[21:34] <camelia> rakudo-moar 676c25: OUTPUT«ARRRR!␤»

[21:38] <masak> m: say <rum grog ships>.join(" and "), "!"

[21:38] <camelia> rakudo-moar 676c25: OUTPUT«rum and grog and ships!␤»

[21:40] *** Ven_ joined
[21:40] <masak> m: say <rum grog ships>.pick(*).join(" and "), "!" for ^3

[21:40] <camelia> rakudo-moar 676c25: OUTPUT«grog and ships and rum!␤grog and ships and rum!␤rum and ships and grog!␤»

[21:40] <masak> m: say <rum grog ships>.roll(*).join(" and "), "!" for ^3

[21:41] <masak> oh, oops.

[21:41] <masak> m: say <rum grog ships>.roll(3).join(" and "), "!" for ^3

[21:41] <camelia> rakudo-moar 676c25: OUTPUT«(timeout)»

[21:41] <camelia> rakudo-moar 676c25: OUTPUT«ships and grog and grog!␤ships and rum and rum!␤ships and ships and rum!␤»

[21:41] <flussence> huh, my irclog for that D shows it wrong, but the actual data is:

[21:41] <flussence> 00000240: 3235 3a20 4f55 5450 5554 c2ab e1b8 8ccc  25: OUTPUT......

[21:41] <flussence> 00000250: 8744 e290 a4c2 bb0a 3232 3a30 333a 3234  .D......22:03:24

[21:41] <masak> 'night, #perl6

[21:42] <PerlJam> flussence: I think we all know why unicode is hard by now  ;)

[21:42] <PerlJam> good night masak!  

[21:42] *** pippo left
[21:42] <flussence> the cc at the end of the first line and 87 at the start of the second are the \c[COMBINING DOT ABOVE], but shouldn't that be *after* the D?

[21:42] * PerlJam didn't get much sleep last night and feels like napping right now himself

[21:42] *** pippo joined
[21:43] <PerlJam> (though bed time is 6+ hours away for me)

[21:43] *** colomon joined
[21:43] <flussence> m: my $str = "D\c[COMBINING DOT ABOVE]\c[COMBINING DOT BELOW]";  $str ~= "D"; say $str.encode('utf-8');

[21:43] <camelia> rakudo-moar 676c25: OUTPUT«utf8:0x<e1 b8 8c cc 87 44>␤»

[21:44] *** pippo left
[21:46] <flussence> oh wait, I'm getting confused. Completely missed the append there...

[21:46] <flussence> m: say utf8.new(0xe1, 0xb8, 0x8c).decode

[21:46] <camelia> rakudo-moar 676c25: OUTPUT«Ḍ␤»

[21:48] *** raiph left
[21:48] <flussence> now that I'm paying attention, it does render correct for me. irssi/tmux/urxvt here.

[21:48] *** Ven_ left
[21:49] *** pippo joined
[21:50] <flussence> doesn't work in perl -e though, guess I need to update that :)

[21:56] *** BenGoldberg joined
[22:06] *** captain-adequate left
[22:06] *** colomon left
[22:07] *** colomon joined
[22:10] *** yqt left
[22:10] *** colomon left
[22:15] <pippo> o/

[22:15] *** pippo left
[22:19] *** dolmen left
[22:22] <lizmat> good night, #perl6!

[22:23] <japhb> o/ lizmat

[22:23] *** virtualsue left
[22:32] *** Foxcool_ left
[22:33] *** colomon joined
[22:43] *** koo6 left
[22:44] *** hobbs left
[22:49] *** hobbs joined
[22:56] *** airdisa left
[22:58] *** RabidGravy left
[23:02] *** Vlavv left
[23:06] <labster> m: say q(')

[23:06] <camelia> rakudo-moar 676c25: OUTPUT«5===SORRY!5=== Error while compiling /tmp/01dmazliS7␤Unable to parse expression in single quotes; couldn't find final "'" ␤at /tmp/01dmazliS7:1␤------> 3say q(')7⏏5<EOL>␤    expecting any of:␤        argument list␤        single quote…»

[23:07] <labster> m: say q/'/

[23:07] <camelia> rakudo-moar 676c25: OUTPUT«'␤»

[23:09] <labster> std: say q(')

[23:09] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Unable to parse single quotes at /tmp/zETV6b9RIe line 1:␤------> 3say q(7⏏5')␤Couldn't find final "'"; gave up at /tmp/zETV6b9RIe line 1 (EOF):␤------> 3say q(')7⏏5<EOL>␤Parse failed␤FAILED 00:00 135m␤»

[23:09] <labster> am I doing something wrong here?

[23:10] *** rurban left
[23:11] <jnthn> labster: foo() is always a function call

[23:11] <labster> ah, got it

[23:12] <labster> m: say q (')

[23:12] <camelia> rakudo-moar 676c25: OUTPUT«'␤»

[23:14] *** Vlavv joined
[23:15] <jnthn> sleep time...'night o/

[23:15] *** khisanth__ joined
[23:16] *** khisanth_ left
[23:16] *** P1RATEZ left
[23:17] *** cognominal joined
[23:24] *** alini left
[23:32] *** espadrine left
[23:36] <b2gills> m: #`[ is there a way to mark a `gather` block as infinite ] say Bool.roll(*).infinite;

[23:36] <camelia> rakudo-moar 676c25: OUTPUT«False␤»

[23:38] *** pecastro left
[23:44] *** Rounin left
[23:49] *** telex left
[23:49] <tony-o> b2gills: you're looking for that to keep rolling?

[23:49] *** airdisa joined
[23:49] *** erdic left
[23:51] *** erdic joined
[23:52] *** telex joined
[23:52] *** telex left
[23:52] <tony-o> m: print "$_ " for (True,False).roll(*);

[23:53] <camelia> rakudo-moar 676c25: OUTPUT«(timeout)True True False True True False True True True False False True False True True False True False False False False False True True False False False True True True True False True True False False False True True True False False True False True F…»

[23:54] *** telex joined
