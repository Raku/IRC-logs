[00:00] *** jack_rabbit joined
[00:19] <TimToady> .tell jnthn I think it would be sanest if submethods do not compose like methods, but have some mechanism for getting themselves all called at the same time as the corresponding class submethod in either build-ish or destroy-ish order as pseudo-parents located between this class and its actuall parents

[00:19] <yoleaux> TimToady: I'll pass your message to jnthn.

[00:36] *** Akagi201 joined
[00:36] *** Akagi201 left
[00:36] *** Akagi201 joined
[00:39] *** AlexDaniel left
[00:41] *** aborazmeh joined
[00:41] *** aborazmeh left
[00:41] *** aborazmeh joined
[00:44] *** beastd left
[00:45] *** laouji joined
[00:58] *** aborazmeh left
[01:21] *** BenGoldberg joined
[01:40] <ugexe> my $proc = Proc::Async.new("echo","foo","bar"); $proc.stdout.tap(-> $v { print "Output: $v" }); say "Starting..."; my $promise = $proc.start; await $promise; say "Done";

[01:41] *** smls left
[01:41] <ugexe> a recent change appears to make that stuck in await 

[01:42] <ugexe> in the last 24-36 hours i would guess

[01:43] <zostay> is there a way to interrupt a thread in P6? say to cause a long running operation to timeout?

[01:44] <zostay> as you might do with a SIGALRM in P5

[01:45] <TimToady> ugexe: Proc::Async has been unstable for a long time, but a recent change to avoid spinlocks has exposed some failure modes

[01:47] <ugexe> ah. im not sure what a failure mode is, but it looks like the Promise just stays as Planned

[01:48] <TimToady> zostay: we don't actually deal directly with threads much in P6; work gets assigned to worker threads as needed; if you want to interrupt the execution of a promise, you can interrogate a supply (such as the Signal supply) for async events

[01:48] <TimToady> well, "interrogate" is the wrong word...

[01:50] <TimToady> ugexe: otoh, the restart-concurrent test seems to be hanging consistently now, so maybe you're onto something...

[01:50] <zostay> ok... i think what i want to know is if i can cause a blocking read to exit with EINTR

[01:51] <TimToady> dinner &

[01:51] <zostay> (or blocking write or whatever system like call)

[01:53] *** Sqirrel left
[02:07] *** llfourn joined
[02:08] <gagalicious> hi i'm a hard core perl5 programmer. is there anything i u guys would like to tell me what i am missing here on perl6 which i cant do on perl5?

[02:12] <skids> gagalicious: are you a Moo/Moose user in P5?

[02:12] <gagalicious> nope

[02:12] <gagalicious> what's that?

[02:13] <skids> It's a module that adds a lot of OO niceness.

[02:13] <skids> So you are mostly a perl5 core user, then, right?

[02:13] <TimToady> what kind of data do you deal with, mostly?

[02:14] <TimToady> certain kinds of math are a lot nicer in P6

[02:14] <TimToady> m: say 1, 1, *+* ... *

[02:14] <camelia> rakudo-moar c2a57e: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 70140873…»

[02:14] <TimToady> like there's a fibonacci series

[02:15] <TimToady> m: say [*] 1..10

[02:15] <camelia> rakudo-moar c2a57e: OUTPUT«3628800␤»

[02:15] <TimToady> there's 10 factorial

[02:15] *** yqt left
[02:15] <TimToady> p6 arguably has better Unicode support now, if you're into text processing

[02:16] <skids> There are better control structures and loop handling.

[02:16] <gagalicious> yeah perl5 me

[02:16] <TimToady> there's more "everything is an object", if you're into OO, and if you're not into OO, you can still pretend numbers aren't objects :)

[02:17] <TimToady> it's also easier to do functional programming, if you're into that

[02:17] <gagalicious> better unicode? i havent come across any major issues in perl5

[02:18] <gagalicious> i dont really like the reliance on object too much.. not everything for sure.

[02:18] *** vendethiel joined
[02:18] <TimToady> well, the main thing is the runtime is never confused about whether a string is text or binary in p6

[02:18] *** jack_rabbit left
[02:18] <TimToady> whereas p5 can get confused about that

[02:19] <TimToady> but p6 also has better support for languages that use lots of diacritics

[02:19] <TimToady> this shows up more outside the typical latin-1 langauges though

[02:20] <skids> m:  for flat ^5 Z "a".."d" -> $a, $b { "$a $b".say }; # multiple loop control variables are easy

[02:20] <camelia> rakudo-moar c2a57e: OUTPUT«0 a␤1 b␤2 c␤3 d␤»

[02:20] <TimToady> and most USians say "What's with these fancy accents? Why can't people just ASCII like normal people?"

[02:20] <TimToady> *use ASCII

[02:21] <TimToady> so we wouldn't tend to notice the internationalization support

[02:22] <TimToady> gagalicious: you also don't have to memorize so many things, like which functions take $_ for a default

[02:23] <skids> m: say gather while (++$ < 4) { "HERE".say; take 42; "THERE".say }; # You can take results from the middle of loops like this

[02:23] <camelia> rakudo-moar c2a57e: OUTPUT«HERE␤THERE␤HERE␤THERE␤HERE␤THERE␤42 42 42␤»

[02:23] <TimToady> p5 has 15 or so magical symbols like STDOUT that span all packages

[02:24] <TimToady> in p6 global symbols are specially marked

[02:24] <TimToady> $*OUT instead of STDOUT

[02:24] <TimToady> so that's another list you don't have to remember

[02:24] *** kurahaupo joined
[02:25] <TimToady> p6 also tends to have better error messages, generally

[02:25] *** [Sno] joined
[02:25] <raydiak> don't forget the way more awesomer regexes

[02:25] <skids> m: say <jack queen king> X~ "of" X~ <diamonds hearts> # it is very easy to generate all sorts of things

[02:25] <camelia> rakudo-moar c2a57e: OUTPUT«jackofdiamonds jackofhearts queenofdiamonds queenofhearts kingofdiamonds kingofhearts␤»

[02:25] *** ][Sno][ left
[02:25] <TimToady> raydiak: that too :)

[02:25] <raydiak> and grammars

[02:26] <TimToady> p6 has better extensibility

[02:27] <TimToady> m: sub postfix:<!>($x) { [*] 2..$x }; say 42!

[02:27] <camelia> rakudo-moar c2a57e: OUTPUT«1405006117752879898543142606244511569936384000000000␤»

[02:27] <TimToady> so it's easy to write your own operators, like factorial there

[02:27] <TimToady> and you'll notice the precision doesn't max out at 32 or 64 bits

[02:28] <TimToady> decommute &

[02:32] <skids> m: multi sub f ( $x where * > 5 ) { "LOTS".say }; multi sub f ($x where 1 < *) { $x.say }; f(6); f(4); f(0); # you can separate up those subs that do different things based on input, and also get good error messages for out-of-domain arguments

[02:32] <camelia> rakudo-moar c2a57e: OUTPUT«LOTS␤4␤Cannot call f(0); none of these signatures match:␤    (Any $x where { ... })␤    (Any $x where { ... })␤  in block <unit> at /tmp/5vQilEsxZS:1␤␤»

[02:33] <skids> gagalicious: you can use as much or as little type-checking as you want for you particular purpose

[02:35] *** rmgk_ joined
[02:35] *** rmgk left
[02:35] *** rmgk_ is now known as rmgk

[02:35] <gagalicious> i thought type check is supposed to speed up an app... but i heard perl6 is slower than perl5. is that right/

[02:36] <gagalicious> i like perl5 coz there's no type checking in the first place... if only perl6 built in a type check optimizer.. that'll make it better.

[02:38] <skids> gagalicious: Currently perl6 is slower than perl5 but faster mostly than perl5+Moose so it depends what features you need.  P6 is much faster than it was a month ago and keeps getting faster.  Some of that is because the type-checking optimizations are starting to get impleented.

[02:38] *** noganex_ joined
[02:40] <skids> gagalicious: one of the first things new P6 users notice is much better error messages that help you correct mistakes faster.

[02:41] <skids> m: sub foobar { 1 }; fooobar();

[02:41] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ZCULqCYlKQ␤Undeclared routine:␤    fooobar used at line 1. Did you mean 'foobar'?␤␤»

[02:41] *** noganex left
[02:41] *** kaare_ joined
[02:42] *** vendethiel left
[02:44] <skids> And you can use type checking to help you find errors before the code is actually run, if you like.

[02:44] <skids> m: sub do_dangerous_thing( Int $x ) { say "DANGER!" }; do_dangerous_thing("foo");

[02:44] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/C1YqEaP_Od␤Calling do_dangerous_thing(str) will never work with declared signature (Int $x)␤at /tmp/C1YqEaP_Od:1␤------> 3rous_thing( Int $x ) { say "DANGER!" }; 7⏏5do_dangerous_thing("foo");␤»

[02:47] <tony-o_> is that color stuff new?

[02:48] <skids> Not super-new, did you change terminals/irc clients?

[02:49] *** flaviusb joined
[02:51] *** xargs joined
[03:14] *** kurahaupo left
[03:16] *** bin_005 joined
[03:16] *** xargs left
[03:26] <zostay> m: Buf.new(0x31 .. 0x34) ~~ /2/

[03:26] <camelia> rakudo-moar c2a57e: OUTPUT«Cannot use a Buf as a string, but you called the Str method on it␤  in block <unit> at /tmp/pM4HwHFEjs:1␤␤»

[03:28] *** skids left
[03:28] *** skids joined
[03:37] *** spider-mario left
[03:38] *** spider-mario joined
[03:43] <zostay> m: Buf.new(0x31 .. 0x34).decode('ascii') ~~ /2/

[03:43] <camelia> rakudo-moar c2a57e: ( no output )

[03:43] <zostay> m: (Buf.new(0x31 .. 0x34).decode('ascii') ~~ /2/).perl.say

[03:43] <camelia> rakudo-moar c2a57e: OUTPUT«Match.new(ast => Any, list => (), hash => EnumMap.new(), orig => "1234", to => 2, from => 1)␤»

[03:54] *** laouji left
[03:54] *** bin_005 left
[03:56] *** laouji joined
[04:40] *** kurahaupo1 joined
[04:44] *** flaviusb left
[04:54] *** kurahaupo1 left
[05:01] *** atweiden left
[05:07] *** Sqirrel joined
[05:13] *** kst` joined
[05:15] *** kst left
[05:15] *** kst` is now known as kst

[05:16] *** _mg_ joined
[05:22] *** jack_rabbit joined
[05:29] *** jack_rabbit left
[05:31] *** eiro joined
[05:33] *** sebm3 left
[05:36] *** telex left
[05:38] *** telex joined
[05:41] *** gfldex joined
[05:46] *** Psyche^ joined
[05:50] *** Patterner left
[05:59] *** Ben_Goldberg joined
[06:02] *** BenGoldberg left
[06:10] *** diana_olhovik joined
[06:17] *** _mg_ left
[06:19] *** meis joined
[06:23] *** _mg_ joined
[06:23] <masak> morning, #perl6

[06:23] *** Ben_Goldberg left
[06:26] *** domidumont joined
[06:26] <itz> https://www.youtube.com/watch?v=T4sZYSiXSgI

[06:27] <itz> hi

[06:28] *** aborazmeh joined
[06:28] *** aborazmeh left
[06:28] *** aborazmeh joined
[06:29] *** flaviusb joined
[06:30] <masak> m: my $n = 1e0; $n /= 2 for ^1075; say $n

[06:30] <camelia> rakudo-moar c2a57e: OUTPUT«0␤»

[06:30] <masak> m: my $n = -1e0; $n /= 2 for ^1075; say $n

[06:30] <camelia> rakudo-moar c2a57e: OUTPUT«-0␤»

[06:30] *** skids left
[06:30] <masak> underflow. this is a good way to explain why -0e0 can be useful.

[06:34] <masak> m: my $x = 0e0; my $y = 0e0; say -($x - $y); say $y - $x # cannot assume -($x - $y)can be optimized to $y - $x, because of -0e0

[06:34] <camelia> rakudo-moar c2a57e: OUTPUT«-0␤0␤»

[06:35] <masak> m: say sqrt -0e0

[06:35] <camelia> rakudo-moar c2a57e: OUTPUT«-0␤»

[06:38] <meis> hum, morning :)

[06:38] *** brrt joined
[06:38] <masak> \o

[06:38] <meis> do you guys know how to generate a .class for jvm from perl6 in rakudo?

[06:38] <meis> i'm feeling silly, but I can't figure out how to do it..

[06:42] *** RabidGravy joined
[06:42] <masak> m: say sign NaN

[06:42] <camelia> rakudo-moar c2a57e: OUTPUT«1␤»

[06:42] * masak submits rakudobug

[06:42] <masak> things you find from playing around :P

[06:44] *** FROGGS joined
[06:44] *** zengargoyle left
[06:53] *** Woodi joined
[06:58] *** brrt left
[07:04] *** zengargoyle joined
[07:09] *** domidumont left
[07:12] <FROGGS> meis: are you talking about a .class file?

[07:14] <meis> FROGGS: yes, sorry, a .class file

[07:14] <FROGGS> meis: perl6-j --target=jar --output=foo.jar foo.pm

[07:14] <FROGGS> though, it's a .jar then :o)

[07:14] <meis> oh

[07:14] <meis> a jart works nice for me

[07:14] <meis> :D

[07:15] <meis> thank you, I'll try later!

[07:15] <FROGGS> meis: if you need more information about Java interop please look at the tests in rakudo/t/03-jvm or ask psch

[07:16] <meis> I'll do, thanks for the tip

[07:16] *** domidumont joined
[07:17] <FROGGS> rjbs: s/so maybe of of those/so maybe one of those/

[07:18] <[Tux]> Inline::Perl5 IO is now broken (it worked yesterday):

[07:18] <[Tux]> csv-ip5xsio Cannot invoke null object

[07:18] <[Tux]>   in method invoke at lib/Inline/Perl5.pm6:479

[07:18] <[Tux]>   in method invoke at lib/Inline/Perl5.pm6:471

[07:18] <[Tux]>   in block  at lib/Inline/Perl5.pm6:753

[07:18] *** AlexDaniel joined
[07:22] <FROGGS> rjbs++ # very good post

[07:23] *** brrt joined
[07:24] *** aborazmeh left
[07:24] <FROGGS> [Tux]: what exactly do you mean by IO?

[07:24] <[Tux]> pass an IO object to perl5

[07:24] <FROGGS> ahh

[07:24] *** Ven joined
[07:26] *** dayangkun joined
[07:28] *** salva joined
[07:34] <RabidGravy> morning

[07:35] <Ven> \o

[07:40] *** amurf left
[07:40] <FROGGS> morning

[07:42] *** zakharyas joined
[07:43] <brrt> morning

[07:43] <dalek> snake: ed35790 | arnsholt++ | t/def.t:

[07:43] <dalek> snake: Add test exercising default arguments.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/ed3579025d

[07:43] <dalek> snake: ff21ab1 | arnsholt++ | t/def.t:

[07:43] <dalek> snake: Improve slurpy args test a bit.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/ff21ab1117

[07:43] <dalek> snake: c66b97e | arnsholt++ | / (3 files):

[07:43] <dalek> snake: Implement list comprehensions.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/c66b97e600

[07:43] <dalek> snake: 8c1f4cf | arnsholt++ | src/Snake/Grammar.nqp:

[07:43] <dalek> snake: Comments have zero or more characters after #, not one or more.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/8c1f4cf47a

[07:43] <dalek> snake: 8d2ef71 | arnsholt++ | src/ (4 files):

[07:43] <dalek> snake: The great object model refactor.

[07:43] <dalek> snake: 

[07:43] <dalek> snake: This should bring us a lot closer to the correct way of handling classes and

[07:43] <dalek> snake: objects than we previously had. I've mostly kept unrelated stuff (like named

[07:43] <dalek> snake: arguments for nqp::ops) in separate commits, but some unrelated things may

[07:43] <dalek> snake: have snuck in.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/8d2ef71818

[07:43] <dalek> snake: 1c66c8f | arnsholt++ | src/Snake/ (2 files):

[07:43] <dalek> snake: Some comment cleanup.

[07:43] <dalek> snake: review: https://github.com/arnsholt/snake/commit/1c66c8fb02

[07:49] *** darutoko joined
[07:53] *** aborazmeh joined
[07:53] *** aborazmeh left
[07:53] *** aborazmeh joined
[07:58] *** gfldex left
[08:01] *** SevenWolf left
[08:05] *** lizmat joined
[08:11] *** lizmat left
[08:12] *** lizmat joined
[08:18] *** xinming_ left
[08:20] *** cschwenz joined
[08:21] *** Ven left
[08:26] *** larion joined
[08:26] <itz> CFT++ # perl6 hacking

[08:26] *** rba_ left
[08:27] *** spider-mario left
[08:29] *** fhelmberger joined
[08:33] <lizmat> good *, #perl6!

[08:33] <lizmat> hmmm... see some serious breakage in S17 related tests after MoarVM upgrade

[08:33] <lizmat> was MoarVM ready to be upgraded for nqp / rakudo?

[08:34] <nwc10> lizmat: there's a bug in MoarVM HEAD to do with async stuff that jnthn is aware of but hasn't fixe yet

[08:34] <nwc10> he was busy with something over the weekend, as I understand it.

[08:34] <nwc10> (have seen a picture)

[08:35] *** laouji left
[08:35] <lizmat> :-)

[08:35] <lizmat> yeah, I was aware of his whereabouts last weekend

[08:35] <nwc10> verified in person, as I understand it.

[08:36] <lizmat> yes  :-)

[08:37] <dalek> rakudo/nom: d5d93ad | lizmat++ | src/core/Numeric.pm:

[08:37] <dalek> rakudo/nom: Make sign(NaN) return NaN

[08:37] <dalek> rakudo/nom: 

[08:37] <dalek> rakudo/nom: Fixes RT's #124813 and #125317

[08:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d5d93adcc3

[08:37] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=124813

[08:38] *** itz is now known as _itz

[08:38] *** rindolf joined
[08:38] *** itz2 joined
[08:38] *** itz2 is now known as itz

[08:39] <dalek> roast: de33725 | lizmat++ | S32-num/sign.t:

[08:39] <dalek> roast: Unfudge now passing test

[08:39] <dalek> roast: review: https://github.com/perl6/roast/commit/de3372559d

[08:41] <FROGGS> lizmat: eww, I did not know that MoarVM HEAD would cause breakage :o(

[08:41] <lizmat> yes, quite serious

[08:41] <lizmat> with hangs and zombies

[08:42] <nwc10> test early, test often?

[08:42] *** xinming joined
[08:44] *** espadrine joined
[08:45] <moritz> you could always revert the faulty commit(s), and move them to a branch

[08:45] <dalek> nqp: d195a71 | FROGGS++ | tools/build/MOAR_REVISION:

[08:45] <dalek> nqp: Revert "bump moar (win build fix and nativecall fix)"

[08:45] <dalek> nqp: 

[08:45] <dalek> nqp: MoarVM HEAD introduces problems in S17... rolling back.

[08:45] <dalek> nqp: This reverts commit 07a9dc105e682a14651551fa25e7af11d03faea8.

[08:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d195a7105a

[08:46] <dalek> rakudo/nom: 5e72201 | FROGGS++ | tools/build/NQP_REVISION:

[08:46] <dalek> rakudo/nom: require newer nqp that uses older MoarVM

[08:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5e722013e7

[08:46] <lizmat> pulling, building and testing

[08:50] *** Ven joined
[08:50] *** RabidGravy left
[08:52] *** Alina-malina left
[08:54] <lizmat> hmmm... looks like it needs a nuke of the install dir  :-(

[08:54] <lizmat> elevensies&

[08:58] *** bin_005 joined
[09:00] <FROGGS> ohh yeah, nqp wont downgrade moar

[09:00] *** cognominal joined
[09:01] <FROGGS> deleting the moar executable would work too

[09:01] <FROGGS> (and then reconfigure and rebuild)

[09:01] *** bin_005 left
[09:02] *** bin_005 joined
[09:02] <moritz> .u カスタ

[09:02] <yoleaux> U+30AB KATAKANA LETTER KA [Lo] (カ)

[09:02] <yoleaux> U+30B9 KATAKANA LETTER SU [Lo] (ス)

[09:02] <yoleaux> U+30BF KATAKANA LETTER TA [Lo] (タ)

[09:02] *** Ven left
[09:08] *** xinming left
[09:09] *** xinming joined
[09:09] *** kurahaupo1 joined
[09:12] *** rindolf left
[09:17] <brrt> uhm, hey, anything terrifyingly wrong with moar that we should fix?

[09:17] <lizmat> yes  :-)

[09:17] <brrt> ok, what is

[09:18] <brrt> anything to do with /me merging the throwops

[09:18] <brrt> since when did all go wrong :-)

[09:19] <lizmat> no, afaik it's half finished work of jnthn wrt not using 100% CPU in a thread for timer related functions

[09:19] <lizmat> hmmm... nuking install dir didn't fix it  :-(

[09:20] <FROGGS> lizmat: what is your moar --version?

[09:21] <lizmat> nothing anymore, I just nuked nqp dir

[09:21] <FROGGS> k

[09:21] <brrt> hmm ok. i can see how that is painful

[09:24] *** laouji joined
[09:24] *** kurahaupo1 left
[09:24] *** laouji left
[09:25] *** laouji joined
[09:26] *** kurahaupo1 joined
[09:27] <lizmat> hmmm... still breakage ???

[09:28] *** Alina-malina joined
[09:28] *** amurf joined
[09:29] <lizmat> $ install/bin/moar --version

[09:29] <lizmat> This is MoarVM version 2015.05-8-g41b5dd2 built with JIT support

[09:29] <FROGGS> that's correct

[09:30] <lizmat> $ install/bin/nqp-m --version

[09:30] <lizmat> This is nqp version 2015.05-4-gd195a71 built on MoarVM version 2015.05-8-g41b5dd2

[09:30] <FROGGS> yes, this is what you basically had yesterday

[09:31] <FROGGS> except the nqp revision, which was 2015.05

[09:31] <FROGGS> but there is nothing in the nqp commits that could hurt

[09:32] <FROGGS> ohh wait...

[09:32] <FROGGS> maybe the offending patches were in moar 2015.05 .. 2015.05-8-g41b5dd2 ?

[09:32] *** amurf left
[09:33] <lizmat> ah, yes, the problem was *not* caused by your changes

[09:33] <lizmat> just by changes that came along with your bump, afaik

[09:33] <FROGGS> excatly

[09:33] <lizmat> so maybe we need to revert Moar to 2015.05 ?

[09:33] <FROGGS> yes, I think so

[09:33] <FROGGS> hold on

[09:34] <lizmat> I think 58226af4aad0d365 in Moar is the problem, really

[09:34] <dalek> nqp: afc10c9 | FROGGS++ | tools/build/MOAR_REVISION:

[09:34] <dalek> nqp: roll back to MoarVM 2015.05

[09:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/afc10c9bcb

[09:35] <dalek> rakudo/nom: 317d054 | FROGGS++ | tools/build/NQP_REVISION:

[09:35] <dalek> rakudo/nom: require newer nqp that uses older MoarVM

[09:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/317d054b3b

[09:36] <FROGGS> lizmat: can yuo now pull, unlink your nqp-m, and reconfigure+rebuild?

[09:36] <lizmat> will do

[09:36] <FROGGS> or nuke install if you prefer that

[09:36] <lizmat> trying your way first  :-)

[09:37] <FROGGS> :o)

[09:37] <lizmat> $ install/bin/moar --version

[09:37] <lizmat> This is MoarVM version 2015.05-8-g41b5dd2 built with JIT support

[09:37] <lizmat> :-(

[09:38] <FROGGS> :o(

[09:38] <FROGGS> I guess it wont reconfigure nqp this way...

[09:38] <lizmat> I unlinked moar as well now

[09:38] <lizmat> trying again

[09:39] <FROGGS> gladly it does not take 10+ minutes as it used to take when you had to build parrot

[09:39] <lizmat> $ install/bin/moar --version

[09:39] <lizmat> This is MoarVM version 2015.05 built with JIT support

[09:39] <lizmat> :-)

[09:40] <FROGGS> ohh, good to know

[09:40] <brrt> i'm a bit sorry about this discussion since i had hoped the jit throw ops merge to get some more exposure

[09:41] <brrt> possible suggestion

[09:41] <lizmat> brrt: afaik, it's only 58226af4aad0d365 that is causing the problem

[09:42] <FROGGS> we can also move that commit to a branch in MoarVM

[09:42] <lizmat> brrt: maybe reverting that for now, will allow us to move forward ?

[09:42] <brrt> we revert said commit on master, cherry-pick it onto a separate branch, and continue tracking moar master with nqp and rakudo

[09:42] <brrt> aye

[09:42] <brrt> consider it done

[09:42] <brrt> in five minutes, at least ;-)

[09:42] <FROGGS> brrt++

[09:43] <FROGGS> this will also help others, since you cannot downgrade moarvm using MOAR_REVISION

[09:43] <FROGGS> as it happily accepts newer moars

[09:44] *** aborazmeh left
[09:44] <lizmat> spectest confirmed clean now

[09:45] <lizmat> afk for a bit&

[09:45] <brrt> tis done

[09:46] <FROGGS> I'll update nqp and rakudo (again :o)

[09:47] <brrt> :-)

[09:47] <dalek> nqp: 4344303 | FROGGS++ | tools/build/MOAR_REVISION:

[09:47] <dalek> nqp: bump moar for fixing async stability

[09:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4344303b10

[09:47] <dalek> rakudo/nom: d39fe1c | FROGGS++ | tools/build/NQP_REVISION:

[09:47] <dalek> rakudo/nom: bump nqp/moar for fixing async stability

[09:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d39fe1c332

[09:48] <FROGGS> now this should solve problems for all the ppl out there

[09:48] * brrt hopes it does

[09:50] *** domidumont left
[09:53] <jnthn> Note that the patch didn't actually cause problems, it fixed one problem that turned out to make a bunch of others less likely.

[09:53] <yoleaux> 00:19Z <TimToady> jnthn: I think it would be sanest if submethods do not compose like methods, but have some mechanism for getting themselves all called at the same time as the corresponding class submethod in either build-ish or destroy-ish order as pseudo-parents located between this class and its actuall parents

[09:54] <jnthn> The things that showed up with it are all possible to produce without it.

[09:55] <brrt> yeah, that's very much true :-)

[09:55] <brrt> the 'problem' - for me at least - was hanging spectests, by the way

[09:56] *** salva left
[09:57] <jnthn> Yes, agree it created a nuisance.

[09:57] <lizmat> jnthn o/

[09:57] <jnthn> I'll try and work on a real fix today

[09:58] <lizmat> jnthn: I would suggest you take it easy for a bit more...

[09:58] <lizmat> it's safely stashed away in a branch now  :-)

[09:58] <lizmat> we've been living with 100% CPU on a thread for quite some time now, a little more wouldn't hurt

[09:59] <lizmat> fwiw, spectest confirmed clean on This is MoarVM version 2015.05-35-gc4c7ebd built with JIT support

[10:00] <lizmat> really afk for a bit now&

[10:01] <brrt> spectest burns the top of this imac

[10:01] <brrt> :-)

[10:05] *** bin_005 left
[10:06] *** Akagi201 left
[10:08] *** Ven joined
[10:13] *** aborazmeh joined
[10:13] *** aborazmeh left
[10:13] *** aborazmeh joined
[10:15] *** rindolf joined
[10:16] *** rarara joined
[10:18] *** Emeric joined
[10:20] <Emeric> Hello World !

[10:20] <brrt> hi Emeric

[10:23] <brrt> anything we can help you with :-)

[10:24] *** rba_ joined
[10:24] *** Emeric left
[10:26] *** Emeric joined
[10:27] <Emeric> Did you use Perl6 for web projects ?

[10:28] <DrForr> Not sure how much of perl6.org is done in perl6 yet :)

[10:29] *** rindolf left
[10:30] <brrt> web is kind of broad these days. it used to be 'CGI scripts', today it may mean 'i want something like rails' or 'i want something like flask/sinatra', or even 'something like php'

[10:30] <brrt> as far as i know, not a lot of people are using perl6 in any of these capacities yet

[10:30] <moritz> {doc,modules}.perl6.org is statically generated pages, and generated by Perl 6 scripts

[10:30] <brrt> what people are doing is creating static site generators using perl6

[10:30] <moritz> as is strangelyconsistent.org

[10:31] * brrt points out that the first real 'blogging engine' (movable type) in widespread use would now be called a static site generator with a web interface

[10:31] <brrt> anyway, lunch &

[10:31] *** brrt left
[10:32] *** dayangkun left
[10:32] *** laouji left
[10:32] <Emeric> Thanks for the answer

[10:33] *** itz left
[10:34] *** _mg_ left
[10:38] *** itz joined
[10:40] *** itz left
[10:41] *** smls_ joined
[10:41] *** rindolf joined
[10:42] *** itz joined
[10:43] *** rba_ left
[10:45] *** rba_ joined
[10:47] <Emeric> Sorry, I've may questions... :S Did you often use the OOP with Perl 6 ?

[10:47] <DrForr> Using it right now as it happens.

[10:47] <hahainternet> Emeric: can i ask why you're asking these questions? they seem like a survey question more than a practical one

[10:47] <moritz> Emeric: Perl 6 is an OO language at its very core

[10:48] <moritz> ever non-trivial piece of Perl 6 code that I write is OO

[10:48] <DrForr> And no need to use the past tense, it's very much alive.

[10:48] *** laouji joined
[10:48] *** rindolf left
[10:50] <Emeric> I'm just trying to inform me about what is done with Perl. And sorry, I'dont speak english very well...

[10:50] <DrForr> Plenty of stuff, though if you're looking for large-scale implementation and huge websites, look at perl5.

[10:50] <Emeric> And I hope it's still alive !

[10:51] <DrForr> At least for the moment :)

[10:51] <hahainternet> Emeric: in my uninformed opinion, Perl 6 currently occupies roughly the niche that Perl 5 does, but it is slowly expanding to support every relatively high-level niche i know of

[10:51] <DrForr> Incidentally the perl6 ANTLR -> Perl6 converter is almost done.

[10:52] <hahainternet> DrForr: fancy, there's EBNF too isn't there

[10:52] <hahainternet> that blew my mind

[10:52] <DrForr> EBNF, ABNF, C++, Java...

[10:52] * hahainternet 's head explodes

[10:53] <DrForr> It mostly won't run without tweaking because ANTLR4 and Perl6 aren't an exact match, but it'll handle most of the constructs.

[10:54] <hahainternet> oh? i don't know the difference, haven't had much p6 time and no ANTLR time

[10:55] <DrForr> ANTLR4 is closer to yacc in that it lets you do code that messes with the parsing stack inline.

[10:55] <smls_> Is there a way to get the function object &foo from the string "foo" without EVAL?

[10:56] *** smls_ is now known as smls

[10:56] <moritz> smls: &::('foo')

[10:56] <smls> oh, right.

[10:56] <DrForr> But it'll work well enough that you can take an ANTLR C# grammar, convert it and get something that looks like perl6 without faffing about.

[10:56] <smls> does it work with operators too?

[10:57] <smls> m: say &::("infix:<~>")

[10:57] <camelia> rakudo-moar c2a57e: OUTPUT«sub infix:<~> (Any |) { #`(Sub+{<anon>}+{Precedence}|50302512) ... }␤»

[10:57] <smls> neat

[11:04] *** rarara left
[11:05] <smls> is .WHY supposed to say something for built-ins?

[11:05] <smls> m: say &say.WHY

[11:05] <camelia> rakudo-moar c2a57e: OUTPUT«(Any)␤»

[11:07] <moritz> smls: it would be neat the pod from doc.perl6.org could be made available from the setting somehow

[11:07] <moritz> smls: though including it in the source text of the setting is a no-go

[11:08] *** domidumont joined
[11:09] *** g4 joined
[11:09] *** g4 left
[11:09] *** g4 joined
[11:21] <rjbs> FROGGS: glad you liked it :)

[11:21] <FROGGS> rjbs: yes, please keep posting here when you blog

[11:23] <rjbs> Well, that post is five years old.   I better start posing the rest of my backlog... :-)

[11:24] <FROGGS> it ... is?

[11:24] <FROGGS> wow

[11:29] <rjbs> FROGGS: the follow-up was http://rjbs.manxome.org/rubric/entry/1865

[11:30] <FROGGS> thanks

[11:32] *** aborazmeh left
[11:35] *** yqt joined
[11:36] <timotimo> o/

[11:37] <Ven> \o timotimo 

[11:37] <timotimo> FROGGS: the dresden.pm video recording of your talk ... the audio recording is ... ...

[11:39] *** domidumont left
[11:40] *** smls_ joined
[11:40] <AlexDaniel> is it possible to define a subroutine that will be visible from the outside? Like: if True { sub Test { say 'hello' } }; Test();

[11:40] *** smls left
[11:40] <dalek> snake: 71b4bd1 | arnsholt++ | src/Snake/Metamodel/ClassHOW.nqp:

[11:40] <dalek> snake: Better stringification logic.

[11:40] <dalek> snake: review: https://github.com/arnsholt/snake/commit/71b4bd16c3

[11:40] <dalek> snake: a729dc1 | arnsholt++ | src/setting/builtins.py:

[11:40] <dalek> snake: Set correct type cache on `type` object.

[11:40] <dalek> snake: review: https://github.com/arnsholt/snake/commit/a729dc1381

[11:40] <dalek> snake: d8f82f8 | arnsholt++ | src/setting/builtins.py:

[11:40] <dalek> snake: Fix braino in MRO passed to ClassHOW.new_type from type().

[11:40] <dalek> snake: review: https://github.com/arnsholt/snake/commit/d8f82f8081

[11:40] *** _mg_ joined
[11:40] <moritz> AlexDaniel: sub Test is export { ... }

[11:41] <moritz> oh wait, then you still have to import it

[11:41] *** domidumont joined
[11:41] <moritz> AlexDaniel: my &Test; if True { &Test := anon sub Test { say 'hello' } }

[11:42] <moritz> the "anon sub Test" construct is a subroutine that isn't automatically installed in the surrounding lexical scope ("anon"), but still knows its own name when introspected

[11:43] <AlexDaniel> m:  my &Test; if True { &Test := anon sub Test { say 'hello' } }

[11:43] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/H3OlSeCCKe␤Cannot use bind operator with this left-hand side␤at /tmp/H3OlSeCCKe:1␤------> 3 &Test := anon sub Test { say 'hello' } 7⏏5}␤»

[11:44] <AlexDaniel> moritz: how can I solve that error?

[11:44] <AlexDaniel> I don't really get it

[11:44] *** domidumont left
[11:45] *** domidumont joined
[11:46] <moritz> hm

[11:46] <moritz> m:  my &Test; if True { &Test = anon sub Test { say 'hello' } }

[11:46] <camelia> rakudo-moar c2a57e: ( no output )

[11:46] <moritz> m:  my &Test; if True { &Test = anon sub Test { say 'hello' } }; Test()

[11:46] <camelia> rakudo-moar c2a57e: OUTPUT«hello␤»

[11:46] <moritz> AlexDaniel: ok, use assignment instead

[11:46] <moritz> though the error looks a bit fishy to me. Why shouldn't you be able to bind here?

[11:47] <moritz> (if there's no extra container level, it should be assignment that's forbidden, not binding)

[11:48] <AlexDaniel> moritz: well, if you think that it's an error than you should probably report it yourself, I don't think that I can phrase what is going on here :)

[11:48] <moritz> AlexDaniel: I probably should

[11:54] <AlexDaniel> this is fun, but it does not satisfy my original crazy intent. I'm trying to change the grammar in run-time (have no idea if that is even possible), depending on something that is not available in compile-time. I have no useful intent but I'm just trying to see what is possible, so I took a simple example of sub postfix:<!> { [*] 1..$^n }; and tried placing it into some block after "if", but it seems like it is lexically scoped so it

[11:54] <AlexDaniel> does not really do what I want it to do. That anon thing, obviously, is not going to work, as far as I can see. Any ideas?

[11:55] *** Ven left
[11:55] *** ][Sno][ joined
[11:56] <FROGGS> timotimo: do you have a link?

[11:56] *** [Sno] left
[11:57] <AlexDaniel> I'm looking here, for example; https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6, but I wonder if there is any simpler example

[11:57] <FROGGS> timotimo: nvm, found it

[11:58] *** itz left
[11:59] <FROGGS> bbl

[12:00] *** FROGGS left
[12:01] <moritz> AlexDaniel: you could try something like: module Foo { multi infix:<!>($x) { [*] 1..$x } }; BEGIN import Foo if True;

[12:01] <moritz> be careful not to introduce a new scope, of course :-)

[12:04] *** Emeric left
[12:06] *** xfix joined
[12:06] *** xfix left
[12:06] *** xfix joined
[12:19] <dalek> rakudo-star-daily: 14b6f06 | coke++ | log/ (2 files):

[12:19] <dalek> rakudo-star-daily: today (automated commit)

[12:19] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/14b6f066d5

[12:20] <AlexDaniel> moritz: does not really work, hm

[12:20] <AlexDaniel> m: module Foo { sub postfix:<!> { [*] 1..$^n }; }; BEGIN import Foo; say 5!;

[12:20] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/s7c_T4CbPU␤Negation metaoperator not followed by valid infix␤at /tmp/s7c_T4CbPU:1␤------> 3*] 1..$^n }; }; BEGIN import Foo; say 5!7⏏5;␤    expecting any of:␤        infix␤        infix stoppe…»

[12:27] <dalek> rakudo/nom: 0f627ce | lizmat++ | lib/Test.pm:

[12:27] <dalek> rakudo/nom: Fix #125319

[12:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f627ce947

[12:27] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125319

[12:32] <[Coke]> good morning, everyone.

[12:37] <lizmat> [Coke] o/

[12:39] *** rindolf joined
[12:49] <dalek> rakudo/nom: 276964e | lizmat++ | docs/ChangeLog:

[12:49] <dalek> rakudo/nom: Add some more entries

[12:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/276964ef9f

[12:50] *** xfix left
[12:50] <jnthn> import is already BEGIN time

[12:50] <jnthn> But the sub needs marking "is export" for it to work

[12:52] *** laouji left
[12:53] <lizmat> Looking at making start { } take a blorst, but failing: https://gist.github.com/lizmat/3ad7ce1f0174013ec2eb

[12:53] <lizmat> I guess I'm being too KISS :-)    suggestions anyone?

[12:56] *** yqt left
[12:58] <jnthn> lizmat: Got 15 mins more of errands to do, then I can take a look. But I was going to do it by calling Promise.start and getting rid of the start function entirely

[12:58] <lizmat> that was my plan also

[12:58] <lizmat> I just called it START in the interim, so I could compare start and START  :-)

[13:04] <hoelzro> morning #perl6

[13:06] *** amurf joined
[13:06] <AlexDaniel> m: module Foo { sub postfix:<!> is export { [*] 1..$^n } }; BEGIN import Foo if True; say 5!;

[13:06] <camelia> rakudo-moar c2a57e: OUTPUT«120␤»

[13:06] <AlexDaniel> m: module Foo { sub postfix:<!> is export { [*] 1..$^n } }; BEGIN import Foo if False; say 5!;

[13:06] <camelia> rakudo-moar c2a57e: OUTPUT«120␤»

[13:06] <AlexDaniel> module Foo { sub postfix:<!> is export { [*] 1..$^n } }; import Foo if True; say 5!;

[13:07] <AlexDaniel> umm

[13:07] <AlexDaniel> ah

[13:07] <AlexDaniel> m: module Foo { sub postfix:<!> is export { [*] 1..$^n } }; import Foo if True; say 5!;

[13:07] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/4bBna1C9Cs␤Missing semicolon␤at /tmp/4bBna1C9Cs:1␤------> 3 export { [*] 1..$^n } }; import Foo if 7⏏5True; say 5!;␤»

[13:08] <smls_> Is there an equivalent of  &::($sub-name)  for classes and roles?

[13:08] <smls_> i.e. look up a type from a string holding its name

[13:09] <dalek> perl6-examples: 0c93c1a | paultcochrane++ | t/categories/cookbook/ (2 files):

[13:09] <dalek> perl6-examples: [cookbook] remove temporary files created from scripts

[13:09] <dalek> perl6-examples: 

[13:09] <dalek> perl6-examples: Some scripts generate temporary files that shouldn't be cleaned up in the

[13:09] <dalek> perl6-examples: script themselves (it wouldn't make sense in the context of the example).

[13:09] <dalek> perl6-examples: Nevertheless, this leaves temporary files lying around on the filesystem

[13:09] <dalek> perl6-examples: after running the test suite, thus the tests now clean these files up.

[13:09] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/0c93c1ab4a

[13:09] <dalek> perl6-examples: 713281b | paultcochrane++ | categories/euler/prob032-andreoss.pl:

[13:09] <dalek> perl6-examples: Purge trailing whitespace

[13:09] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/713281b571

[13:09] <timotimo> m: ::('Hash').new.say

[13:09] <camelia> rakudo-moar c2a57e: OUTPUT«␤»

[13:09] <dalek> perl6-examples: 7911bc8 | paultcochrane++ | categories/euler/prob03 (3 files):

[13:09] <dalek> perl6-examples: Add missing vim coda

[13:09] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/7911bc8258

[13:09] <timotimo> m: ::('Hash').new.perl.say

[13:09] <camelia> rakudo-moar c2a57e: OUTPUT«{}<>␤»

[13:09] <timotimo> m: ::('Array').new.perl.say

[13:09] <camelia> rakudo-moar c2a57e: OUTPUT«[]<>␤»

[13:09] <smls_> ok, thanks

[13:11] *** amurf left
[13:12] <hoelzro> I'm trying to get RolePunning.find_method to return a Method object that invokes the target method on the pun, rather than an anonymous function that does that.  Any ideas on how I could force an invocant for a method?

[13:12] *** FROGGS joined
[13:12] <lizmat> passing it as the first parameter ?

[13:15] <moritz> hoelzro: I'm pretty sure it does that on purpose, and if you want to change that, you should talk to jnthn++ first

[13:16] <moritz> (unless you already did that)

[13:16] * jnthn is a bit dubious about such a change too

[13:16] <jnthn> We made the find_method vs. lookup distinction for exactly this kind of reason

[13:17] <jnthn> find_method just has to return something invokable that handles the message

[13:17] <jnthn> lookup should return something the user actually declared

[13:17] <jnthn> So the current implementation of find_method is fine

[13:20] <smls_> I don't suppose it's possible to use the MOP to find out which of all the built-in types can do a method with a given name?

[13:21] <timotimo> m: say ::.keys

[13:21] <camelia> rakudo-moar c2a57e: OUTPUT«$=pod $! $_ EXPORT !UNIT_MARKER GLOBALish ::?PACKAGE @?INC $/ $?PACKAGE␤»

[13:21] <timotimo> m: say SETTING::.keys

[13:21] <camelia> rakudo-moar c2a57e: OUTPUT«&pipe &symlink RESTRICTED-CLASS $=pod $! $_ EXPORT &rmdir &MAKE-DIR &SYMLINK-PATH &UNLINK-PATH !UNIT_MARKER &chmod &CHANGE-DIRECTORY PIO GLOBALish ::?PACKAGE &link &rename &COPY-FILE NativeCall @?INC &shell $/ &copy &spurt &unlink &CHMOD-PATH &REMOVE-DIR &…»

[13:21] <timotimo> m: for SETTING::.values -> $t { .say if $t.HOW === ClassHOW }

[13:21] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bsnyBfVR3n␤Undeclared name:␤    ClassHOW used at line 1␤␤»

[13:21] <timotimo> m: for SETTING::.values -> $t { .say if $t.HOW === Metamodel::ClassHOW }

[13:21] <camelia> rakudo-moar c2a57e: ( no output )

[13:21] <timotimo> oh?

[13:22] <timotimo> m: say unique(SETTING::.values>>.HOW)

[13:22] <camelia> rakudo-moar c2a57e: OUTPUT«Perl6::Metamodel::ClassHOW.new␤»

[13:22] <timotimo> m: for SETTING::.values -> $t { .say if $t.HOW ~~ Metamodel::ClassHOW }

[13:22] <camelia> rakudo-moar c2a57e: OUTPUT«(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤…»

[13:22] <timotimo> m: for SETTING::.values -> $t { .WHAT.say if $t.HOW ~~ Metamodel::ClassHOW }

[13:22] <camelia> rakudo-moar c2a57e: OUTPUT«(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤…»

[13:22] <timotimo> that's weird :)

[13:22] * timotimo takes it to the repl

[13:23] <timotimo> aaah, i have $t instead of $_

[13:24] <timotimo> ClassHOW isn't the right way to go

[13:28] <moritz> why not just test .can (or .^can)?

[13:30] <lizmat> m: say Int.can("Numeric").perl

[13:30] <camelia> rakudo-moar c2a57e: OUTPUT«(method Numeric ($: Any |) { #`(Method|42412184) ... }, method Numeric ($: Any |) { #`(Method|41929128) ... })␤»

[13:30] <lizmat> m: say Int.can("Numerik").perl

[13:30] <camelia> rakudo-moar c2a57e: OUTPUT«()␤»

[13:32] <hoelzro> moritz: I haven't, but I know he's sort of busy lately

[13:33] <hoelzro> ah ha

[13:33] <hoelzro> I didn't realize there was that distinction

[13:33] <hoelzro> so if a user wants a method (from a role or otherwise) they should do $something.^lookup($meth-name)?

[13:34] <hoelzro> and $something.can($meth-name) works in terms of lookup rather than find_method?

[13:34] <hoelzro> jnthn: if you're around and able to answer questions ^

[13:35] <lizmat> $something.can is just short for $something.^can, which is short for $something.HOW.can

[13:36] <moritz> ... short for $something.HOW.can($something)

[13:37] <lizmat> moritz: touché   :-)

[13:37] <jnthn> hoelzro: Well, it depends what they want it for. If they want to look up the declared thing in the role, then lookup.

[13:37] <lizmat> I always seem to forget that

[13:37] *** itz joined
[13:38] <jnthn> lizmat: .^ exists 'cus folks were good at forgetting it ;)

[13:38] *** cschwenz left
[13:38] <hoelzro> jnthn: ok, thanks for the input (and moritz and lizmat too!)

[13:39] <jnthn> hoelzro: Whta is your use-case ooc?

[13:40] *** kaare_ left
[13:41] <lizmat> m: my Int @a = (1,2,3,Nil,4)   # do we have a ticket for this?

[13:41] <camelia> rakudo-moar c2a57e: OUTPUT«Unhandled exception: Type check failed in assignment to '@a'; expected 'Int' but got 'Any'␤   at <unknown>:1  (/home/camelia/rakudo-inst-2/share/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting:16606  (/home/camelia/raku…»

[13:41] <hoelzro> jnthn: I'm looking at fixing S26-documentation/block-leading.t (RT #125304)

[13:41] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125304

[13:42] *** kaare_ joined
[13:43] <hoelzro> which apparently just requires .subst(/find_method/, 'lookup') =)

[13:44] <jnthn> Yes, that's what I was about to say after reading the ticket :)

[13:45] <dalek> roast: e9f12db | hoelzro++ | S26-documentation/block- (2 files):

[13:45] <dalek> roast: Stop skipping role method tests for S26

[13:45] <dalek> roast: 

[13:45] <dalek> roast: We just needed to switch out find_method for lookup; find_method

[13:45] <dalek> roast: only returns something you can invoke, but lookup returns something

[13:45] <dalek> roast: you can inspect

[13:45] <dalek> roast: review: https://github.com/perl6/roast/commit/e9f12db093

[13:45] *** yqt joined
[13:52] *** smls_ left
[13:58] <jnthn> lizmat: Problem is you're missing a QAST::WVal node containing Promise (looked up with $*W.find_symbol) as the first child of the callmethod op, so it tries to call .start on the code object

[14:00] *** cschwenz joined
[14:00] *** cschwenz left
[14:02] *** telex left
[14:02] <lizmat> jnthn: ok, I can work with that (I think(

[14:02] <lizmat> )

[14:03] <geekosaur> (you have a Lisp?)

[14:03] <PerlJam> geekosaur: heh, I was thinking the same thing :)

[14:04] <lizmat> :-

[14:04] *** cognominal left
[14:04] *** telex joined
[14:08] *** cognominal joined
[14:10] *** cognominal left
[14:11] *** andreoss joined
[14:16] <lizmat> jnthn: so I added QAST::Wval.new( :value($*W.find_symbol(['Promise'])) ), before the $<blorst>.ast

[14:16] <lizmat> but it still fails the same way in the optimizer

[14:17] <lizmat> is there some annotation missing maybe ?

[14:18] <timotimo> you want WVal, not Wval

[14:18] <timotimo> a typo like that gives you an NQPMu object where you least expect it :(

[14:18] <lizmat> argh

[14:18] <timotimo> i agree.

[14:18] <timotimo> i think i want a fatal error to happen in that case

[14:18] <timotimo> i may implement that

[14:20] <lizmat> made it a WVal, still same failure in the optimizer  :-(

[14:21] <timotimo> :(

[14:21] <timotimo> where do i have to look to find your code?

[14:21] <lizmat> I mean, the problem is *before* it ever executes

[14:21] <lizmat> https://gist.github.com/lizmat/3ad7ce1f0174013ec2eb

[14:21] * [Tux] sends belated congrats to jnthn !!!  💒 💒 💒

[14:22] <timotimo> thanks

[14:22] <jnthn> [Tux]: Thanks! :)

[14:22] *** smls joined
[14:23] <timotimo> hm, my intuition says: dump $<blorst>.ast

[14:23] <timotimo> see what it ends up being

[14:24] <jnthn> lizmat: Missing "make"

[14:24] <lizmat> ??

[14:24] <lizmat> it says : make QAST::Op.new(

[14:24] <lizmat> ?

[14:24] <jnthn> https://gist.github.com/lizmat/3ad7ce1f0174013ec2eb doesn't

[14:25] *** flaviusb left
[14:25] <timotimo> ooooh

[14:25] <jnthn> +    method statement_prefix:sym<START>($/) {

[14:25] <jnthn> +        QAST::Op.new(

[14:25] <lizmat> argh

[14:25] <lizmat> looking at the wrong code, indeed make missing :-)

[14:26] <timotimo> this stuff is so fiddly, i'd really +1 having a branch flying around that you could rebase at will - or maybe a piece of code that you can uncomment - that gives earlier, more helpful error messages regarding the compilation stage

[14:26] <timotimo> most importantly: without affecting performance too negatively

[14:27] <lizmat> $ 6l '(START 42 + 1).result.say'

[14:27] <lizmat> 43

[14:27] <PerlJam> timotimo: or maybe simple substitution macros?

[14:27] <lizmat> yes!

[14:27] *** skids joined
[14:27] <[Coke]> is https://github.com/cosimo/perl6-lwp-simple/issues/37 a problem for anyone but me?

[14:28] * smls still doesn't get the difference between .^find_method, .^lookup and .^can - where is this explained?

[14:28] <moritz> probably just in here :(

[14:28] <[Coke]> er, I really meant https://github.com/tadzik/panda/issues/96, but it's both the same thing. :)

[14:29] *** andreoss` joined
[14:29] <itz> panda has worked with http_proxy I'm sure

[14:29] <moritz> the difference between find_method and can is mostly that can returns a list of methods, if several are matching

[14:29] *** rindolf left
[14:30] <moritz> find_method is rather more low-level, and only ever returns the best match

[14:30] <moritz> the difference between find_method and lookup is what happens with roles

[14:30] *** andreoss left
[14:30] <moritz> roles can be parameterized, and the parameterized candidates may or may not have the method you're looking for

[14:31] <moritz> but the type name of the role refers to the whole group of role candidates

[14:31] * PerlJam wonders what "best match" means

[14:31] <moritz> so a MyRole.^find_method cannot do its thing reliably, because it doesn't know which parameterization to do

[14:31] <moritz> PerlJam: first in MRO

[14:31] <jnthn> It's not just roles. If you used something like Grammar::Tracer, .^find_method will give you something that traces and invokes the original, while lookup is the declared Method

[14:32] <PerlJam> moritz: good, because that's what I thought :)

[14:33] <itz> hmm the panda proxy code has been refactored since I added and tested it

[14:33] *** zakharyas left
[14:33] *** zakharyas joined
[14:35] *** vendethiel joined
[14:35] <dalek> rakudo/nom: 211d7a1 | lizmat++ | src/ (3 files):

[14:35] <dalek> rakudo/nom: Make start take a blorst, fixes RT #125312

[14:35] <dalek> rakudo/nom: 

[14:35] <dalek> rakudo/nom: With support by jnthn++ and timotimo++

[14:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/211d7a1a1e

[14:35] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125312

[14:37] <dalek> roast: d089d04 | lizmat++ | S17- (2 files):

[14:37] <dalek> roast: Remove () now that start is no longer a sub

[14:37] <dalek> roast: review: https://github.com/perl6/roast/commit/d089d045ac

[14:37] <smls> m: .say for Str.^can("words")>>.candidates>>.perl>>.match(/\d+/)>>.Str

[14:37] <camelia> rakudo-moar c2a57e: OUTPUT«46268608␤46268760␤46268912␤46269064␤46269216␤46269368␤46269520␤46268608␤»

[14:37] <smls> ^^ why does this return the same candidate twice? (first and last)

[14:37] *** yqt left
[14:37] *** lolisa joined
[14:38] *** lolisa left
[14:38] <smls> m: .say for Str.^find_method("words")>>.candidates>>.perl>>.match(/\d+/)>>.Str

[14:38] <camelia> rakudo-moar c2a57e: OUTPUT«57155888␤57156040␤57156192␤57156344␤57156496␤57156648␤57156800␤»

[14:38] *** lolisa joined
[14:38] <smls> ^^does .find_method + .candidates return all methods, or skip some?

[14:39] *** rindolf joined
[14:40] *** domidumont left
[14:43] *** fhelmberger left
[14:44] *** fhelmberger joined
[14:46] *** Sqirrel left
[14:48] *** Sqirrel joined
[14:48] *** fhelmberger left
[14:49] <smls> moritz: Can you give an example of a built-in role where .^lookup vs .^find_method makes a difference?

[14:50] <PerlJam> smls: are you writing docs for the next person?  :)

[14:50] <moritz> m: say Rational.^find_method('nude')

[14:50] <camelia> rakudo-moar c2a57e: OUTPUT«No appropriate parametric role variant available for 'Rational'␤  in any specialize at src/gen/m-Metamodel.nqp:2437␤  in any compose at src/gen/m-Metamodel.nqp:2747␤  in any make_pun at src/gen/m-Metamodel.nqp:1608␤  in any find_method at src/gen/m…»

[14:50] <moritz> m: say Rational.^lookup('nude')

[14:50] <camelia> rakudo-moar c2a57e: OUTPUT«nude␤»

[14:50] <moritz> smls: ^^

[14:50] <smls> thanks

[14:51] *** RabidGravy joined
[14:51] *** yqt joined
[14:52] <dalek> rakudo/nom: 71ebbb0 | lizmat++ | / (2 files):

[14:52] <dalek> rakudo/nom: Re-introduce sub start as a deprecation

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71ebbb0556

[14:56] *** smls_ joined
[14:56] *** smls left
[14:58] *** vendethiel left
[15:06] *** lolisa left
[15:07] *** lolisa joined
[15:08] *** _mg_ left
[15:09] *** _mg_ joined
[15:11] *** kurahaupo1 left
[15:12] *** smls joined
[15:12] *** smls_ left
[15:17] *** diana_olhovik left
[15:21] *** _mg_ left
[15:21] <lizmat> afk again&

[15:25] *** kurahaupo1 joined
[15:27] *** larion left
[15:28] *** smls_ joined
[15:28] *** smls left
[15:29] *** vendethiel joined
[15:35] *** smls_ left
[15:35] *** smls_ joined
[15:40] *** smls joined
[15:41] *** smls_ left
[15:47] *** smls left
[15:48] *** muraiki joined
[15:53] <japhb> .tell lizmat re: rakudo 0f627ce, this reminds me: Seems like every Perl code base I touch, I add something like this: sub _s($count, $plural='s', $singular='') { $count == 1 ?? $singular !! $plural }; .say for "tree{_s($plants)}", "box{_s($container, 'es')}", "{_s($birds, 'geese', 'goose')}";

[15:53] <yoleaux> japhb: I'll pass your message to lizmat.

[15:55] * japhb wonders how hard it would be to support other languages' count agreement rules without totally losing the simplicity

[15:56] <timotimo> pretty hard, i imagine

[15:56] <timotimo> don't some languages have three forms?

[15:57] <TimToady> Indo-European used to have a dual

[15:57] <TimToady> "oxen" used to mean two oxes

[15:58] <jnthn> In some Slavic languages, things like 21, 31, etc. behave as a singular, and/or 22..24, 32..34 etc. things lead to different pluralization than 25..30, 35..40, etc. :)

[15:58] <japhb> .ask lizmat Shouldn't the deprecation introduced in rakudo 71ebbb0 recommend Promise.start if the user needs :&catch?

[15:58] <yoleaux> japhb: I'll pass your message to lizmat.

[15:59] *** andreoss` left
[15:59] <jnthn> Slovene does in theory have the dual, but my attempt to use it to order two beers was met with confusion. :P

[15:59] <japhb> jnthn: That's actually pretty cool.  OTOH, you have given me yet more appreciation for the Tower of Babel problem.

[16:00] <japhb> Heh

[16:00] <jnthn> (The bar girl corrected it to the normal plural, then poured my beers. :))

[16:01] *** zakharyas left
[16:01] <japhb> .oO( The assumption is that no one really stops at two beers, you're just partially ordering three or more ... )

[16:01] *** diana_olhovik_ joined
[16:01] <geekosaur> Semitic languages have duals. worse, at least some of them apply it only to things that have pairs *and* those pairs are relevant: "shnei yadim" and "yadayim" have different implications

[16:02] <geekosaur> I think I matched that wrong for the first one... not commonly used at all!

[16:02] <geekosaur> two unrelated hands

[16:03] <masak> I remember reading a great essay in a CPAN module about this. the conclusion was, turn the i18n thing into a function.

[16:03] *** meis left
[16:03] <masak> because functions are general enough to handle anything you throw at them.

[16:03] <masak> can't seem to find that module again, unfortunately.

[16:03] <TimToady> something with Inflect?

[16:04] <japhb> .oO( Google Translate chose a probabilistic function )

[16:08] *** hypnotoad joined
[16:08] *** hypnotoad left
[16:08] <masak> mebbe something with Gettext... but I can't seem to find it...

[16:09] <masak> the essay kind of took the developer through a hypothetical situation, bringing in more and more languages into the mix.

[16:14] <dalek> rakudo/nom: f4e4de2 | TimToady++ | src/Perl6/ (2 files):

[16:14] <dalek> rakudo/nom: try out S/// form to return new string

[16:14] <dalek> rakudo/nom: 

[16:14] <dalek> rakudo/nom: Adding this more as a "to play with" feature.  (Note that use with ~~

[16:14] <dalek> rakudo/nom: will be very surprising for now, unless you expect False on success and True

[16:14] <dalek> rakudo/nom: on failure.)

[16:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4e4de2e99

[16:21] *** pecastro left
[16:21] <TimToady> the rationale for use of uppercase is that it is a rawer form, much like Q// is a raw quote

[16:22] <[Coke]> my grammar sense is tingling.

[16:24] *** pecastro joined
[16:25] <hoelzro> Perl 6 on MoarVM doesn't restrict you from updating a single variable from separate threads in any way, does it?

[16:25] *** smls joined
[16:26] <TimToady> I don't believe it attempts to prevent you from shooting yourself in the foot that way

[16:27] <hoelzro> alright

[16:27] <hoelzro> I was just thinking about RolePunning.nqp and how it creates a $!pun if it hasn't already

[16:27] <hoelzro> and how that might behave with a multithreaded application

[16:29] <TimToady> well, if it's idempotent, then doing it duplicately shouldn't matter, unless the updates can destroy each other somehow due to lack of atomicity

[16:29] *** sjn_phone joined
[16:29] <TimToady> well, other than wasted CPU, I mean

[16:30] *** smls left
[16:31] <TimToady> if it's not, well, then we have bigger problems

[16:31] <TimToady> .oO(Global Meta-Interpreter Lock)

[16:31] <japhb> But then you could end up returning two different puns that don't === each other but are in some sense the "same"

[16:32] *** smls joined
[16:33] <timotimo> i think behind the pun creation lies a moarvm-backed thing that interlocks

[16:33] <TimToady> yeah, which was always the case before we cached it...

[16:33] <japhb> Only one of which is now saved as the pun that will be returned in the future

[16:33] <timotimo> i might be wrong, though

[16:33] <japhb> TimToady: Oh agreed, I just meant there is a real race there; whether we care is a different question.

[16:34] <TimToady> I suspect we care :)

[16:34] <japhb> (My personal vote is that we should, on general principle.)

[16:35] * japhb grumbles about having to write project requirements docs

[16:35] <japhb> I don't mind API docs, but PR docs just feel like something to trudge through

[16:36] <TimToady> because they're too general, or too specific?

[16:39] <japhb> Because they don't feel any more valuable than the outline of notes (or bug hotlist) that is my real captured requirements -- it's just converting into long winded prose for the benefit of people that don't think in that kind of mental shorthand.

[16:39] <japhb> I can see the value to some, but for me, it's just lost time.  :-(

[16:40] <japhb> Whereas API docs (for instance) have obvious intrinsic value to both my future self and others that have to deal with whatever abomination I've brought forth.  :-)

[16:41] <japhb> Sadly, grumbling doesn't make it any less necessary ...

[16:41] * japhb trundles off to stare at a blank document, punctuated by meetings and lunch

[16:43] <itz> lunch++

[16:44] *** amurf joined
[16:46] *** smls left
[16:47] *** spider-mario joined
[16:48] *** smls joined
[16:48] *** amurf left
[16:49] *** brrt joined
[16:49] *** itz left
[16:50] *** liztormato joined
[16:52] <liztormato> japhb: re start deprecation. To my knowledge is the catch param to start() not documented

[16:52] <jnthn> We do locking to protect certain MOP operations, but yeah, the role punning is not, though as TimToady++ mentioned the race to create the pun isn't automatically a problem.

[16:53] *** smls left
[16:54] *** smls joined
[16:55] *** [Sno] joined
[16:55] *** yqt left
[16:55] *** rba_ left
[16:55] <japhb> liztormato: Fair enough, though might be worth pointing out anyway for those that used the source, Luke.

[16:55] *** ][Sno][ left
[16:56] *** sjn_phone_ joined
[16:58] <vendethiel> o/, #perl6

[16:58] *** smls_ joined
[16:58] *** brrt left
[16:59] *** sjn_phone left
[16:59] *** smls left
[17:02] *** smls joined
[17:03] *** smls_ left
[17:03] *** smls left
[17:07] *** smls joined
[17:08] <smls> I made a little helper tool: http://i.imgur.com/COmy8Z2.png

[17:08] <smls> source code: https://github.com/smls/undef/blob/master/scripts/p6routine

[17:13] <moritz> smls++

[17:14] *** domidumont joined
[17:20] <TimToady> smls: a coercer in the parameter list can insert two entries into the candidate list

[17:20] <smls> can you give an example?

[17:21] <TimToady> well, I suspect .words is an example, since that's what you were testing :)

[17:21] <smls> oh, that's what you mean

[17:23] <vendethiel> what's a blorst :o?

[17:23] <TimToady> except looking at method words, I don't see a coercer

[17:23] <TimToady> block or statement

[17:23] <vendethiel> TimToady: S/// looks awesum :)

[17:24] *** _mg_ joined
[17:25] <timotimo> smls: you know you can get the filename + line number for code objects?

[17:25] <smls> didn't know that, no

[17:26] <TimToady> m: say S/foo/bar/ given "food"

[17:26] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/c3o3FDcdK3␤Undeclared name:␤    S used at line 1␤Undeclared routines:␤    bar used at line 1. Did you mean 'bag'?␤    foo used at line 1␤    given used at line 1␤␤»

[17:26] <TimToady> doesn't look awesum yet...

[17:26] <PerlJam> smls++

[17:26] <TimToady> in fact, kinda looks like recompilation is busted

[17:26] <TimToady> (of camelia)

[17:28] <TimToady> in fact, it appears to be running a version from May 26

[17:28] <PerlJam> smls: The comment at the top of your code says "A tool for looking up Perl 6 built-in subroutines/..."  but it could also be used for non-built-in stuff as well if you happen to load the right module like:  perl6 -MFoo p6routine foo

[17:28] <smls> I suppose so :)

[17:29] <TimToady> moritz: ^^^

[17:29] <moritz> nine: rakudo rebuild on camelia complains: "fatal: Unable to look up github.com (port 9418) (Name or service not known)"

[17:29] <moritz> EOUTSIDEOFMYCONTROL :-)

[17:30] <TimToady> ESOMETHINGISWRONGONTHEINTERNET!!!

[17:31] <smls> Damn, p6routine still exhibits this weird "WARNING: unhandled Failure detected in DESTROY" bug for many operators

[17:32] <TimToady> well, that means there's a Failure leak somewhere, which we need to plug

[17:32] *** yqt joined
[17:32] <smls> Can a failure somehow sneak trough a   .map({(try ... ) or next})  ?

[17:32] <TimToady> may well indicate that some construct is not sunk properly

[17:33] <TimToady> try should catch any failure going through it

[17:33] <smls> e.g. run   p6routine '+^'  to see it in action (with newest r-m)

[17:33] <TimToady> maybe we aren't setting a failure as "handled" when we throw it?

[17:34] <TimToady> s/it/its exception/

[17:34] <smls> The bug kept coming and going for different inputs as wrote that script; apparently never going for all of them.

[17:34] <TimToady> if a failure did sneak out of try, the 'or' should mark it handled

[17:35] <smls> And is seemingly affected by making changes to completely different parts of the script :o

[17:35] <TimToady> we did change the inside of try to 'use fatal', so maybe something in that mechanism isn't quite right

[17:35] *** llfourn left
[17:36] <TimToady> but we're no longer using a dynamic variable for fatalizing, so the lazy dynamic scope of the map shouldn't matter, I'd think

[17:38] <TimToady> in any case, the solution is not just to turn off the warning :)

[17:38] *** molaf joined
[17:38] <TimToady> that would be of a defense industry solution...

[17:38] <smls> ;)

[17:39] <TimToady> which kinda explains the 95% failure rate on recent TSA intrusion tests

[17:39] <TimToady> well, I guess that would be 95% success rate, looking at it from the intrusion end :)

[17:45] *** smls left
[17:46] *** smls joined
[17:47] *** atweiden joined
[17:47] *** liztormato left
[17:49] *** _mg_ left
[17:50] *** smls left
[17:55] *** vendethiel left
[17:56] *** vendethiel joined
[17:57] *** espadrine left
[17:58] <TimToady> hmm, server can't find github.com: REFUSED

[18:00] <TimToady> camelia and its DNS server don't appear to e on speaking terms currently

[18:04] <atweiden> i have a MyApp.pm:

[18:04] <atweiden> unit class MyApp; class MyApp::Config is export { class MyApp::Config::SubDataType { has $.count; } has MyApp::Config::SubDataType $.mydata; } has MyApp::Config $.conf;

[18:04] <atweiden> but when i try to access MyApp::Config from a separate file with `use MyApp::Config`, i get `Could not find MyApp::Config in any of:...`

[18:04] <atweiden> is it necessary to keep MyApp::Config in its own unit in a separate file?

[18:06] <atweiden> had tried combining multiple units, because wanted better type checking but was getting `Circular module loading detected involving module...`

[18:10] <tony-o_> you probably don't need to 'use' MyApp::Config

[18:13] <tony-o_> you don't need to use the MyApp::Config as long as you've 'use MyApp' in your other file

[18:14] <tony-o_> atweiden: https://gist.github.com/tony-o/286bd818ecc712e0d862

[18:16] <timotimo> you don't need to - or rather: you cannot

[18:16] <timotimo> "use" is about "compunits", which maps somewhat directly to "files"

[18:17] <timotimo> so with "use MyApp" you get all the stuff from that file in one "package"

[18:18] <atweiden> so the `is export` is not needed?

[18:18] <tony-o_> correct

[18:26] *** bin_005 joined
[18:29] *** _mg_ joined
[18:35] *** SevenWolf joined
[18:41] <timotimo> classes are "our" scoped by default, aren't they?

[18:41] *** larion joined
[18:41] <timotimo> inside classes at least?

[18:41] *** muraiki left
[18:42] <FROGGS> always

[18:48] *** rindolf left
[18:50] *** brrt joined
[18:50] <TimToady> nearly anything declares a term defaults to 'our'

[18:51] *** yqt left
[18:51] <TimToady> including subsets, enums, and constants

[18:51] <lizmat> computer: messages please

[18:51] <yoleaux> 15:53Z <japhb> lizmat: re: rakudo 0f627ce, this reminds me: Seems like every Perl code base I touch, I add something like this: sub _s($count, $plural='s', $singular='') { $count == 1 ?? $singular !! $plural }; .say for "tree{_s($plants)}", "box{_s($container, 'es')}", "{_s($birds, 'geese', 'goose')}";

[18:51] <yoleaux> 15:58Z <japhb> lizmat: Shouldn't the deprecation introduced in rakudo 71ebbb0 recommend Promise.start if the user needs :&catch?

[18:52] <TimToady> m: { subset MyInt of Int; }; say OUR::MyInt

[18:52] <camelia> rakudo-moar c2a57e: OUTPUT«(MyInt)␤»

[18:52] <TimToady> m: { subset MyInt of Int; }; say MyInt

[18:52] <camelia> rakudo-moar c2a57e: OUTPUT«(MyInt)␤»

[18:52] <TimToady> I guess it looks it up in OUR anyway

[18:52] * FROGGS .oO( OurInt )

[18:53] <TimToady> m: { our sub foo { say "FOO" } }; foo;  # in contrast, subs don't

[18:53] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3Sf4pRUVZy␤Undeclared routine:␤    foo used at line 1␤␤»

[18:53] <TimToady> my view of constants has always been that they're basically very narrow types :)

[18:53] <FROGGS> m: unit class Flubber; { subset MyInt of Int; }; say MyInt

[18:53] <camelia> rakudo-moar c2a57e: OUTPUT«5===SORRY!5=== Error while compiling /tmp/3Ujutn20em␤Undeclared name:␤    MyInt used at line 1␤␤»

[18:54] <TimToady> hmm

[18:54] <FROGGS> m: unit class Flubber; { subset MyInt of Int; }; say OUR::MyInt

[18:54] <camelia> rakudo-moar c2a57e: OUTPUT«(MyInt)␤»

[18:54] <FROGGS> it probably looks at GLOBAL

[18:54] <TimToady> I guess it just looks in yeah...

[18:55] <TimToady> which makes sense, since it has to start in GLOBAL to find anything in any package

[18:55] *** _mg_ left
[18:55] *** bin_005 left
[18:56] *** bin_005 joined
[19:02] *** Peter_R joined
[19:04] <dalek> rakudo/nom: da586e3 | lizmat++ | / (3 files):

[19:04] <dalek> rakudo/nom: Introduce Int.s, for those pesky s's

[19:04] <dalek> rakudo/nom: 

[19:04] <dalek> rakudo/nom: Inspired by japhb++ , it returns '' if the Int == 1, else it returns 's'

[19:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/da586e3e11

[19:05] <nwc10> but what if I need an es? And can I have .d for duals? :-)

[19:06] <lizmat> I could use this at 4 locations in the core, so at least internally it made sense

[19:07] <nwc10> yes, thinking about it, there is an itch here that can be scratched

[19:07] <nwc10> I thought of duals first (to sort of satirise the English-specific bit, and the potential complexity slippery slope)

[19:08] <nwc10> but the es question is a bit more pertinent, because even English will hit it maybe 1/26th of the time. But I don't have a good answer

[19:09] *** rindolf joined
[19:09] *** kurahaupo1 left
[19:09] <raydiak> .oO( what we need are localized error messages in rakudo... )

[19:09] *** larion left
[19:10] <hoelzro> seems like there should be a module that provides pluralize($word, $count, :en)

[19:10] <lizmat> raydiak: that is a different issue that can be handled by mixing in .message methods in the exception classes for the desired language

[19:10] <DrForr> Don't we usually put that in a Lingua:: module?

[19:11] <hoelzro> DrForr: in P5 land, yeah

[19:12] <lizmat> nwc10: something like this?

[19:12] <lizmat> $ 6 'my $c = 1; say "$c child$c.s(q/ren/)"'

[19:12] <lizmat> 1 child

[19:12] <lizmat> $ 6 'my $c = 2; say "$c child$c.s(q/ren/)"'

[19:12] <lizmat> 2 children

[19:12] <DrForr> I know we're in a new venue, but pluralization is more complex than just picking a language ID :)

[19:12] <nwc10> yes. I think that will get everything apart from pedants with >1 ox.

[19:13] <lizmat> DrForr: I'm well aware of that, thinking back at former $wiork where they now have to support 40+ languages

[19:13] <lizmat> $work

[19:14] <moritz> that's tough.

[19:14] <DrForr> I imagine you knew the complications, just thinking of other people that haven't worked there :)

[19:14] <lizmat> gettext just doesn't cut it

[19:15] *** yqt joined
[19:15] *** yqt left
[19:16] *** yqt joined
[19:16] <dalek> rakudo/nom: fa76a98 | lizmat++ | src/core/Int.pm:

[19:16] <dalek> rakudo/nom: Allow setting the multi extension

[19:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fa76a98766

[19:19] *** llfourn joined
[19:23] *** domidumont left
[19:24] *** llfourn left
[19:26] *** telex left
[19:27] <PerlJam> hoelzro: https://github.com/rails/rails/blob/master/actionview/lib/action_view/helpers/text_helper.rb#L220   :-)

[19:27] *** khisanth_ joined
[19:28] *** telex joined
[19:28] <zostay> m: my $b = Buf.new(1, 2); $b ~= Buf.new(3, 4);

[19:28] <camelia> rakudo-moar c2a57e: ( no output )

[19:30] *** Khisanth left
[19:30] *** sjn_phone joined
[19:33] *** sjn_phone_ left
[19:37] *** rindolf left
[19:38] <japhb> lizmat: The signature ending in "$plural='s', $singular=''" was quite intentional.  You will end up wanting the singular case as well at some point for e.g. $birds.s(|< geese goose >)  ;-)

[19:38] <lizmat> well, this is good enough for internal core usage

[19:39] <lizmat> and we don't do geese in the core

[19:39] * japhb resists the urge to fowl things up

[19:40] *** brrt left
[19:40] * lizmat looks forward to some chickun

[19:47] <lizmat> aka some faux chicken at http://verticaldiner.com

[19:48] *** FROGGS left
[19:50] <japhb> The YAPC vegan meetups, I'm guessing?

[19:50] *** espadrine joined
[19:50] <lizmat> yeah, autarch is looking forward to it, which is always a good sign  :-)

[19:53] <dalek> roast: 08b7bd4 | lizmat++ | S17-promise/start.t:

[19:53] <dalek> roast: Check for start taking a blorst

[19:53] <dalek> roast: review: https://github.com/perl6/roast/commit/08b7bd4ec4

[19:53] *** pecastro left
[20:00] * PerlJam remembers having vegan ice cream (for the first time ever) with autarch in Austin

[20:01] *** darutoko left
[20:01] * lizmat remembers the same, but in Madison  :-)

[20:03] *** colomon left
[20:04] <japhb> jnthn: Got a couple minutes to answer questions about Evject?

[20:04] <jnthn> japhb: Sure

[20:05] *** brrt joined
[20:07] <japhb> So ... the design seems difficult to use for heavy or often-mutated objects, which would have a current state built up from a great number of events, because it looks like you'd get O(N**2) performance, as each new mutation takes longer

[20:07] *** smls joined
[20:07] <japhb> How is this actually addressed in production code, since I assume that could have been a simplification just to teach the concept?

[20:08] <lizmat> https://gist.github.com/lizmat/5ae61833fe735865f1fa   # trying to implement $=finish

[20:08] <japhb> (Come to think of it, you could get O(N**3) performance if the object contains arrays that get copied each time.)

[20:08] <japhb> jnthn: ^^

[20:10] <smls> lizmat: Are you sure having an .s method for pluralization is a good idea? It'll be very easy to confuse it with the file test method of the same name.

[20:10] <PerlJam> japhb: What's Evject?

[20:10] <jnthn> japhb: Whether that's actually a problem is highly domain-specific. I've applied this technique in the context of domain driven design, and I've found in many cases the aggregates only have so many events over their lifetime.

[20:10] <lizmat> smls: good point

[20:11] <jnthn> japhb: There's an easy optimization available when needed, though, typically called snapshotting: you every so often store a serialized copy of the state at a particular version.

[20:11] <jnthn> japhb: From a functional programming point of view, that's completely safe: applying events is just a fold, and the snapshot is simply memoization.

[20:11] <lizmat> smls: suggestion for different name, or perhaps I should just revert the Int.s related commits as it has descended on a slippery slope already

[20:11] <jnthn> japhb: Just need to make sure that a representation change invalidates the snapshot.

[20:12] <japhb> jnthn: So instead of building up from a new object, you build up from the last snapshot, bounding the longest time to rebuild the object, hmmm, yes.

[20:12] <jnthn> japhb: Yeah

[20:12] <japhb> jnthn: Explain that last bit?

[20:12] <smls> IMO the problem of pluralizing user output is quite context-dependent and can be approched in different ways, which suggests to me that it is best left to module space.

[20:12] <japhb> PerlJam: It's the framework jnthn++ created for the last section of his objects intersect concurrency talk.

[20:13] <smls> though if we do have something in core, it might make sense to borrow the PL naming scheme of perl5's lingua modules

[20:13] <japhb> PerlJam: https://gist.github.com/jnthn/da27ded3fbf06df7c54a

[20:13] <jnthn> japhb: The benefit of event sourcing is that you get a persistence strategy that doesn't break the object's encapsulation and doesn't lead to schema duplication, as seen in the ORM approach.

[20:13] <japhb> smls: General pluralization shouldn't be in core.  :-)

[20:13] <jnthn> japhb: This gives freedom to refactor the innards of the object 

[20:14] <brrt> oh, i have one more for that

[20:14] <jnthn> japhb: And then deploy a new version, and the new state is built up from the event history

[20:14] <japhb> jnthn: Ah!  Meaning you have to make sure a refactoring doesn't make your snapshot unusable

[20:14] <jnthn> japhb: However, if you cache the state, you need to...right :)

[20:14] <brrt> the benefit of event sourcing (and CQRS) is that you sidestep the inherent conflict between readers and writers

[20:14] <jnthn> japhb: Note that event sourcing + actors have also been mixed happily, which gives you another interesting point in the field.

[20:15] <brrt> readers want a consistent, valid value

[20:15] <jnthn> japhb: See Akka.Persistence for an example of that.

[20:15] <brrt> writers just want to stuff their data and have you deal with it

[20:16] <brrt> in an RDBMS you typically optimize for readers (if you have lots of constraints and checks)

[20:16] <brrt> which makes your application difficult to interface with

[20:17] <brrt> if you use event sourcing, you decouple write operations from the 'read result'

[20:17] * japhb is planning to try this with some really quite heavy objects, which will have quite long event histories, so it will be interesting to see when Rakudo's performance profile makes me want to start snapshotting

[20:17] <brrt> hence you can explicitly balance between the two demands

[20:18] <japhb> brrt: hmmm

[20:18] <brrt> i like that answer :-)

[20:18] *** _mg_ joined
[20:19] <jnthn> japhb: One interesting thing is that "just serialize it quick somehow" is often awkward for objects 'cus then you have refactoring pain (the serialized representation doesn't just deserialize to the right thing), but if that's only serving as cache then you're fine. :)

[20:20] <japhb> :-)

[20:20] <dalek> rakudo/nom: eebebb7 | lizmat++ | / (3 files):

[20:20] <dalek> rakudo/nom: Undo pluralization hack, it was too slippery

[20:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eebebb7a45

[20:20] * japhb chuckles at that commit message

[20:21] <brrt> that does then imply that your events need to be serialised in a refactoring-independent way

[20:21] <jnthn> To date, I think ES is the best way I've seen to persist highly behavioral objects.

[20:21] <japhb> ES?

[20:21] <jnthn> Event Sourcing

[20:21] <japhb> Oh, I see, I thought you were talking about a particular framework or so.

[20:22] <japhb> Yeah, my biggest fear is that I'm going to lose the clarity that came with being able to see the procedural code all in a line.

[20:22] <jnthn> brrt: Events are immutable; if you introduce a new version of an event then you still support applying the previous one, or just do a mapping to the new version.

[20:22] <brrt> ok, i can see how that works out

[20:26] *** rba_ joined
[20:27] *** brrt left
[20:27] *** brrt joined
[20:31] *** _mg_ left
[20:33] <dalek> rakudo-star-daily: ea5a544 | coke++ | log/ (2 files):

[20:33] <dalek> rakudo-star-daily: today (automated commit)

[20:33] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ea5a5446de

[20:33] <dalek> perl6-roast-data: fa46400 | coke++ | / (9 files):

[20:33] <dalek> perl6-roast-data: today (automated commit)

[20:33] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fa464000be

[20:34] <[Coke]> http://ecosystem-api.p6c.org/ probably needs an index.html if it's going to get past corporate site classification for http proxies.

[20:34] *** colomon joined
[20:34] <[Coke]> -1 on adding .s to Int

[20:35] <[Coke]> (if it it's private to the core, that's fine, but I don't want it as part of the exposed API)

[20:36] <[Coke]> ... and now I'm caught up with backscroll. Thanks. :)

[20:39] <lizmat> [Coke]: people who used the Source would have found out and abused it

[20:40] *** molaf left
[20:43] <japhb> That brings up the general problem of helper routines that are merely meant to reduce duplicated code across the setting but which we don't want to support generally for user code ... how do we want to do that?

[20:43] *** zakharyas joined
[20:44] * jnthn had thought of putting them in a Rakudo::Internal:: package

[20:49] <[Coke]> hoelzro: ooh, you got those two S26 tests running?

[20:49] <hoelzro> I did!

[20:49] <hoelzro> thanks to jnthn, moritz, and lizmat's assistance

[20:50] *** telex left
[20:50] <nwc10> jnthn: Rakudo::S3kr1t would be less typing

[20:51] <nwc10> remember, #define private public

[20:51] <nwc10> (people will always try stuff you would rather that they didn't)

[20:51] <japhb> nwc10: Why stop at obfuscated ASCII?  Let's go full Unicode on this bikeshed!

[20:51] <nwc10> make sure it's outside the base plane, to confuse inferior implementations

[20:52] <[Coke]> hoelzro++

[20:52] <lizmat> couldn't we have something like find_symbol work differently inside the core (including Rakudo::Internal) and outside ?

[20:53] <[Coke]> .u private

[20:53] <yoleaux> U+0091 PRIVATE USE ONE [Cc] (<control>)

[20:53] <yoleaux> U+0092 PRIVATE USE TWO [Cc] (<control>)

[20:53] <yoleaux> U+2F1B KANGXI RADICAL PRIVATE [So] (⼛)

[20:53] <[Coke]> .u secret

[20:53] <yoleaux> U+3299 CIRCLED IDEOGRAPH SECRET [So] (㊙)

[20:53] <[Coke]> m: unit package Rakudo::㊙;

[20:53] <camelia> rakudo-moar c2a57e: OUTPUT«===SORRY!===␤Name Rakudo:: ends with '::' and cannot be used as a package name␤»

[20:53] <[Coke]> *sniff*

[20:53] <jnthn> lizmat: I'd rather not; Perl 6 has sufficient introspective power that I'm very wary of such tricks ;)

[20:54] *** telex joined
[20:54] <jnthn> lizmat: Further, I think it's OK for things like the debugger UI to use such things.

[20:54] <jnthn> lizmat: Or custom settings. Most important is that it's very explicit what you're dong

[20:54] <jnthn> dong

[20:54] <jnthn> doing!

[20:54] <lizmat> then, by definition, it is ok for other users

[20:54] <lizmat> ding dong ?

[20:55] <japhb> Well, we don't actually need to keep people from using these helpers; we merely need to make it clear that it's not part of the public API.

[20:55] <jnthn> lizmat: Sure, as are nqp:: ops if you pre-decl...

[20:55] <lizmat> use Rakudo::Internals

[20:55] <japhb> .oO( use Rakudo::Internals; )

[20:55] <japhb> jinx!

[20:55] <lizmat> hehe great minds  :-)

[20:56] <jnthn> What japhb++ said though; we don't tend to outright ban stuff you likely oughtn't do in Perl, just strongly hint you probably might want something else... :)

[20:58] <[Coke]> we should definitely have stuff that we can change without fear of breaking users.

[20:59] <jnthn> Indeed, so long as it's clear to said users that's what they're getting themselves into.

[21:00] <dalek> rakudo/nom: 277fcc1 | lizmat++ | src/Perl6/ (3 files):

[21:00] <dalek> rakudo/nom: Implement $=finish

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/277fcc186e

[21:00] <jnthn> .oO( Are you finish? )

[21:00] <hoelzro> during my talk last Thursday, Joel Berger mentioned niecza.  I tried building it this morning, but no luck with Mono 4.  Has anyone here built it succesfully recently?

[21:00] <hoelzro> lizmat++

[21:01] <lizmat> $ 6 '.say for $=finish.words;

[21:01] <lizmat> > =finish

[21:01] <lizmat> > Hello World

[21:01] <lizmat> > '

[21:01] <lizmat> Hello

[21:01] <lizmat> World

[21:01] *** colomon left
[21:01] <vendethiel> lizmat++ :)

[21:01] <vendethiel> hoelzro: don't think so

[21:02] <[Coke]> hoelzro: https://github.com/coke/perl6-roast-data/blob/master/log/niecza_summary.out - not for nine months.

[21:02] <[Coke]> (at least)

[21:02] <hoelzro> ouch

[21:03] <[Coke]> I'd be happy to add it back, but it got to the point where maintaining roast to be fudged properly was too hard given no one was updating the code.

[21:04] *** colomon joined
[21:04] <[Coke]> (esp. once new builds started failing.)

[21:04] <[Coke]> Ditto pugs.

[21:04] <dalek> rakudo/nom: fbe0b4e | lizmat++ | docs/ChangeLog:

[21:04] <dalek> rakudo/nom: Mention $=finish

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fbe0b4ec4c

[21:05] * japhb wishes we still had lambdacamels about.  I miss them.

[21:05] *** skarn left
[21:05] *** bin_005_b joined
[21:05] *** bin_005 left
[21:05] <hoelzro> [Coke]: yeah, and with a build that's currently failing, it makes it that much harder for anyone to pick it back up =(

[21:11] *** skids left
[21:12] <grondilu> https://github.com/grondilu/openssl/pull/4/files  # what is this C<unit> keyword before a module declaration?

[21:12] <[Coke]> I tried to squawk loudly when it happened, fwiw.

[21:12] <[Coke]> But I have no problem with A) focusing on rakudo, and B) focusing primarily on one backend.

[21:13] <smls> What's a lambdacamel?

[21:13] <[Coke]> I suspect rakudo-on-.net will happen before niecza is resurrected.

[21:13] <[Coke]> smls: a haskel programmer who does perl 6 (pugs developers)

[21:14] <dalek> roast: 5aa29ab | lizmat++ | S02-lexical-conventions/begin_end_pod.t:

[21:14] <dalek> roast: Add basic test for $=finish

[21:14] <dalek> roast: review: https://github.com/perl6/roast/commit/5aa29ab582

[21:15] <hoelzro> [Coke]: agreed

[21:15] *** colomon left
[21:16] <hoelzro> grondilu: it's a new keyword that's required before unit-level declarations that use the "module/grammar/whatever Name;" form

[21:16] <dalek> specs/newio: 77a0785 | lizmat++ | S99-glossary.pod:

[21:16] <dalek> specs/newio: Add blorst lemma

[21:16] <dalek> specs/newio: review: https://github.com/perl6/specs/commit/77a0785a93

[21:17] <vendethiel> lizmat++ # lemmas!

[21:19] <dalek> specs: 0b3d1f4 | lizmat++ | S99-glossary.pod:

[21:19] <dalek> specs: Add blorst lemma (in right branch this time)

[21:19] <dalek> specs: review: https://github.com/perl6/specs/commit/0b3d1f42b7

[21:19] <japhb> smls: As well as working on Pugs, lambdacamels tended to be really excellent sources of deep CS knowledge, due to the particular mental type that wants to sit at the intersection of Haskell and Perl 6.

[21:19] <smls> i can imagine

[21:19] <japhb> (Audrey Tang)++   # The ultimate lambdacamel

[21:19] * grondilu guess he'll have to read S11 again now

[21:20] <lizmat> she would need to indeed

[21:21] *** skarn joined
[21:21] *** zakharyas left
[21:21] *** larion joined
[21:34] *** bin_005_b_m joined
[21:34] *** bin_005_b left
[21:36] *** colomon joined
[21:38] <lizmat> std: __END__

[21:38] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Undeclared name:␤        '__END__' used at line 1␤Check failed␤FAILED 00:00 134m␤»

[21:39] <lizmat> TimToady: thinking about adding a more useful error mentioning $=finish / =finish

[21:39] *** bin_005_b_m left
[21:39] <lizmat> TimToady: any suggestions as to where to do that?

[21:39] *** bin_005_b_m_c joined
[21:39] <lizmat> TimToady: jnthn suggested doing a token term:sym<p5end> { ^^ __END__ $$ <.obs: ...> }, but that feels like overkill

[21:44] <grondilu> (yeah Martin Fink is speaking now!)

[21:45] <jnthn> Sleep time; 'night o/

[21:46] <lizmat> good night, jnthn : sweet dreams in your new apartment!

[21:53] <brrt> sleep well jnthn and the rest

[21:53] *** brrt left
[21:56] *** bin_005_b_m_c left
[21:57] *** bin_005 joined
[21:58] <RabidGravy> is applying role that supplies a CALL-ME the best way of implementing a method trait that provides the entire implementation of the method? (like NativeCall does)

[21:59] <lizmat> good question

[22:00] <RabidGravy> it appears to work

[22:02] <RabidGravy> eg.

[22:02] <RabidGravy> m: role Foo { method CALL-ME(*@args) { say @args[0].boot; } }; multi trait_mod:<is>(Routine $r, :$foo!) { $r does Foo; }; class Bar { has $.boot = "ghhggh"; method boom() is foo {}; }; Bar.new.boom;

[22:02] <camelia> rakudo-moar c2a57e: OUTPUT«ghhggh␤»

[22:02] <dalek> rakudo/nom: 2f1960c | lizmat++ | src/Perl6/Grammar.nqp:

[22:02] <dalek> rakudo/nom: Give meaningful feedback on __END__/__DATA__

[22:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f1960c7e9

[22:03] *** bin_005 left
[22:04] *** bin_005 joined
[22:04] <lizmat> .tell TimToady could you check https://github.com/rakudo/rakudo/commit/2f1960c7e9 for sanity ?

[22:04] <yoleaux> lizmat: I'll pass your message to TimToady.

[22:06] *** kaare_ left
[22:08] <RabidGravy> nighty night

[22:08] <lizmat> good night, RabidGravy 

[22:09] * lizmat also calls it a night

[22:11] <dalek> rakudo/nom: 7023a52 | lizmat++ | docs/ChangeLog:

[22:11] <dalek> rakudo/nom: Mention __END__/__DATA__ obsoleteness

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7023a52137

[22:11] <lizmat> good night, #perl6!

[22:12] *** diana_olhovik_ left
[22:13] *** RabidGravy left
[22:20] *** llfourn joined
[22:23] *** bin_005 left
[22:25] *** llfourn left
[22:50] *** smls left
[22:56] *** skids joined
[23:07] *** adu joined
[23:09] *** larion left
[23:26] *** dolmen joined
[23:31] *** [Sno] left
[23:31] *** [Sno] joined
[23:33] *** lolisa left
[23:34] *** pecastro joined
[23:36] *** telex left
[23:38] *** telex joined
[23:41] *** amurf joined
[23:46] *** mr-fooba_ left
[23:47] *** mr-foobar joined
[23:48] *** dolmen left
[23:54] *** diegok joined
[23:58] *** flaviusb joined
