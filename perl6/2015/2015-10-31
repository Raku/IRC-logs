[00:05] *** kjs1 joined
[00:09] *** softmoth joined
[00:09] *** rabie joined
[00:10] *** rabie left
[00:12] *** kjs1 left
[00:13] <cognominal_> m: say prefix:<-«>(2,3,4,)

[00:13] <camelia> rakudo-moar 36c4c6: OUTPUT«5===SORRY!5=== Error while compiling /tmp/T6w0zpkrtQ␤Undeclared routine:␤    prefix:<-«> used at line 1. Did you mean 'prefix:<->', 'prefix:<-->', 'prefix:<~>', 'prefix:<so>'?␤␤»

[00:14] *** softmoth left
[00:14] <cognominal_> here, it says : Cannot find method 'is_dispatcher'

[00:15] *** leont left
[00:21] *** BenGoldberg left
[00:22] *** BenGoldberg joined
[00:22] *** RabidGravy left
[00:23] *** BenGoldberg left
[00:23] *** BenGoldberg joined
[00:30] *** spider-mario left
[00:30] <TimToady> currently it requires the &

[00:31] *** lichtkind left
[00:33] <cognominal_> m: say &prefix:<-«>(2,3,4,)

[00:33] <camelia> rakudo-moar 36c4c6: OUTPUT«Too many positionals passed; expected 1 argument but got 3␤  in block <unit> at /tmp/9OXQ6KsDu6:1␤␤»

[00:33] <TimToady> and currently it requires exactly one argument, but may be able to relax both of those

[00:35] <cognominal_> ok, I was just experimenting

[00:35] <TimToady> I had it working with multiple for prefixes, but had trouble with postfixes for some reason, but maybe I'm past that

[00:41] *** xdoctor joined
[00:42] *** dayangkun joined
[00:48] <TimToady> nope, still gets upset, so we'll continue to restrict unaries to, like, one argument :)

[00:48] *** cygx left
[00:48] *** raiph joined
[00:49] *** pmurias left
[01:00] *** tokuhirom_h joined
[01:12] <zengargoyle> is there a hash like thing that takes a list/array/not-string as key?

[01:13] *** tokuhirom_h left
[01:13] <zengargoyle> m: my $i = 1,2,3; my %h = $i => 'foo'; say %h{$i};

[01:13] <camelia> rakudo-moar 36c4c6: OUTPUT«WARNINGS:␤Useless use of constant integer 2 in sink context (line 1)␤Useless use of constant integer 3 in sink context (line 1)␤foo␤»

[01:15] <zengargoyle> m: my $i = 1,2,3; my %h; %h{$i} = 'foo'; say %h{$i};

[01:15] <camelia> rakudo-moar 36c4c6: OUTPUT«WARNINGS:␤Useless use of constant integer 2 in sink context (line 1)␤Useless use of constant integer 3 in sink context (line 1)␤foo␤»

[01:16] <zengargoyle> m: my $i = (1,2,3); my %h; %h{$i} = 'foo'; say %h{$i};

[01:16] <camelia> rakudo-moar 36c4c6: OUTPUT«foo␤»

[01:16] <zengargoyle> m: my $i = (1,2,3); my %h; %h{$i} = 'foo'; say %h{$i}:exits;

[01:16] <camelia> rakudo-moar 36c4c6: OUTPUT«Unexpected named parameter 'exits' passed␤  in block <unit> at /tmp/y01kgnyyER:1␤␤»

[01:16] <zengargoyle> m: my $i = (1,2,3); my %h; %h{$i} = 'foo'; say %h{$i}:exists;

[01:16] <camelia> rakudo-moar 36c4c6: OUTPUT«(False False False)␤»

[01:16] <flussence> m: say :{ [1,2,3] => 'foo' }.perl;

[01:16] <camelia> rakudo-moar 36c4c6: OUTPUT«:{[1, 2, 3] => "foo"}␤»

[01:17] *** ilbot3 left
[01:17] <zengargoyle> what's the : there?

[01:17] <flussence> m: my %h{Array} = [1,2,3] => "foo"; say %h{[1,2,3]};

[01:17] <camelia> rakudo-moar 36c4c6: OUTPUT«Type check failed in binding key; expected Array but got Int␤  in block <unit> at /tmp/duz4BOA0AS:1␤␤»

[01:18] <flussence> the : means "don't coerce keys to Str by default"

[01:18] <flussence> m: my %h{Array} = [1,2,3] => "foo"; say %h{$[1,2,3]};

[01:18] <camelia> rakudo-moar 36c4c6: OUTPUT«(Any)␤»

[01:18] <flussence> m: my %h{Array} = [1,2,3] => "foo"; say %h{[1,2,3].item};

[01:18] <camelia> rakudo-moar 36c4c6: OUTPUT«(Any)␤»

[01:18] <flussence> m: my %h{Array} = [1,2,3] => "foo"; say %h.perl;

[01:18] <camelia> rakudo-moar 36c4c6: OUTPUT«(my Any %{Array} = [1, 2, 3] => "foo")␤»

[01:19] <flussence> m: my %h{Array} = [1,2,3] => "foo"; say %h{%h.keys[0]};

[01:19] <camelia> rakudo-moar 36c4c6: OUTPUT«Type check failed in binding key; expected Array but got Int␤  in block <unit> at /tmp/qS7TuNMzTE:1␤␤»

[01:19] <flussence> well that's awkward...

[01:20] <zengargoyle> how would : work in general like %h:{$something} ?

[01:20] <psch> zengargoyle: no, :{} is the shorthand for %{Any}

[01:20] <zengargoyle> ah

[01:20] <flussence> if you want to use a named hash var, just do "my %h{Any}".

[01:21] <zengargoyle> m: my $i = (1,2,3); my %h{Any}; %h{$i} = 'foo'; say %h{$i}:exists;

[01:21] <camelia> rakudo-moar 36c4c6: OUTPUT«(False False False)␤»

[01:21] <psch> (where '%{Any}' is actually somewhat distractingly shortened)

[01:21] <zengargoyle> how do i keep $i from turning into a slice with :exists?

[01:21] <psch> m: (my %{Any} = { &infix:<+> => 1 }).keys[0].WHAT.say

[01:22] <camelia> rakudo-moar 36c4c6: OUTPUT«Potential difficulties:␤    Useless use of hash composer on right side of hash assignment; did you mean := instead?␤    at /tmp/hSpvsrzbnb:1␤    ------> 3(my %{Any} = { &infix:<+> => 1 }7⏏5).keys[0].WHAT.say␤Sub+{<anon|57909456>}+{Precedence}…»

[01:22] <psch> m: (my %(){Any} = { &infix:<+> => 1 }).keys[0].WHAT.say

[01:22] <camelia> rakudo-moar 36c4c6: OUTPUT«5===SORRY!5===␤The () shape syntax in hash declarations is reserved␤at /tmp/pVCmFNy1JV:1␤------> 3(my %(7⏏5){Any} = { &infix:<+> => 1 }).keys[0].WH␤Other potential difficulties:␤    Useless use of hash composer on right side of hash ass…»

[01:22] <psch> yeah, it doesn't work like that...

[01:22] *** finanalyst joined
[01:22] <zengargoyle> i was fine with it stringifying, but then it sliced...

[01:22] *** ilbot3 joined
[01:23] <psch> zengargoyle: i'd say report this

[01:23] <psch> m: my $i = (1,2,3); my %h{Any}; %h{$i} = 'foo'; say %h.EXISTS-KEY($i) # this works

[01:23] <camelia> rakudo-moar 36c4c6: OUTPUT«True␤»

[01:23] <zengargoyle> ended up doing something like %hash{"$i"}

[01:23] <psch> and %h{$key} should be equivalent, barring any design concerns

[01:23] <psch> zengargoyle: to clarify, please open an RT ticket

[01:23] <zengargoyle> also seems to behave differently than %h<<$i>>

[01:23] <BenGoldberg> m: (my % {Any} = ( &infix:<+> => 1 )).keys[0].WHAT.say

[01:23] <camelia> rakudo-moar 36c4c6: OUTPUT«5===SORRY!5=== Error while compiling /tmp/m_vtOg4f1t␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/m_vtOg4f1t:1␤------> 3(my %7⏏5 {Any} = ( &infix:<+> => 1 )).keys[0].WH␤    expecting a…»

[01:24] <BenGoldberg> m: (my % = ( &infix:<+> => 1 )).keys[0].WHAT.say

[01:24] <camelia> rakudo-moar 36c4c6: OUTPUT«Sub+{<anon|57909456>}+{Precedence} object coerced to string (please use .gist or .perl to do that)  in block <unit> at /tmp/HgttH4iHj8:1␤(Str)␤»

[01:24] <zengargoyle> psch: will do in a bit after coming up with a test case of some sort.

[01:25] <psch> zengargoyle: fwiw, the bit you're tried with camelia seems sufficient to showcase the WAT

[01:25] <psch> zengargoyle: as in, assigning to the key $i works, but fetching it doesn't

[01:25] *** aborazmeh joined
[01:25] *** aborazmeh left
[01:25] *** aborazmeh joined
[01:25] <zengargoyle> cool, i still take it the %h{Any} part is important as well.

[01:26] <psch> just stuff everything into the ticket :P

[01:26] <zengargoyle> :)

[01:40] <zengargoyle> heh, test case breaks Test

[01:40] *** mike` joined
[01:41] *** tokuhirom joined
[01:46] *** tokuhirom left
[01:57] *** aborazmeh left
[01:58] *** softmoth joined
[02:02] *** softmoth left
[02:12] <zengargoyle> rakudobug filed.

[02:14] <konobi> pmurias: oh sorry... I'm generally available during PST.

[02:15] <konobi> pmurias: assuming we can get a 1-on-1 chat... i think we can get the node stuff cleared... I know how it all works.

[02:21] *** shinobi-cl joined
[02:22] <masak> good morning, #perl6

[02:23] <konobi> where is jnthn these days?

[02:23] <masak> you mean, like, geographically?

[02:23] * masak .oO( physical location! how quaint! )

[02:24] <konobi> masak: more TZ wise

[02:24] <konobi> =0P

[02:24] <masak> oh. he's in CET, still.

[02:25] <masak> which is UTC+1 in the winter.

[02:25] <konobi> rgr

[02:28] <masak> I had a random thought about typecasting. so, I'm reading this book on algebra, and it said something like "in a legalistic sense, the real number c ∈ ℝ is a different mathematical object than the constant polynomial c ∈ ℝ[X] -- but we're not going to be sticklers so you'll see the former sometimes when it's clear that the latter is intended"

[02:29] <masak> and I just thought, hm, that has happened to me too.

[02:29] <masak> in programming.

[02:29] <masak> so -- this is wildly conjectural, and may be a really bad and silly idea for reasons that I don't see right now. caveat emptor.

[02:30] <masak> but, let's say we had a phenomenon called "type subsumption" (NB: masak's made up name. maybe this exists and is called something better)

[02:30] <masak> I'll give two examples:

[02:31] <masak> (a) in 007, we often end up creating identifiers out of strings. it looks like this: Q::Identifier("foo"). there's a strong natural temptation to just use "foo" where Q::Identifier("foo") was expected. type subsumption would notice the "have Str, want Q::Identifier" situation, and automatically type-cast (in this case, wrap) the Str into a Q::Identifier

[02:32] *** raiph left
[02:33] <masak> (b) the Perl 6 FAQ of people wanting to `my Rat $r = 7` (Int ~~> Rat) and `my Num $n = 5/2` (Rat ~~> Num) is a type subsumption situation. people's intuition yell at them that it's *one* number line and those types may not be subclasses of each other in the OO sense, but they sure are subsumable in the ways shown.

[02:35] <masak> I can see jnthn's objection already -- that this would be an epicycle and Yet Another Exception on the type system, degrading it further. and I agree, I think.

[02:36] <masak> but maybe it should be a pragma? or a module in the ecosystem. something that allows you to predeclare "I'm willing to take a performance hit on typechecking so that I don't have to cast these things manually"

[02:38] *** xdoctor left
[02:39] *** raiph joined
[02:40] <AlexDaniel> m: my Num $n = (5/2).Num; say $n; # a bit annoying indeed, but not much

[02:40] <camelia> rakudo-moar 36c4c6: OUTPUT«2.5␤»

[02:41] <masak> I'm fully aware of the "it's not hard to do the explicit cast" argument.

[02:41] <masak> there seems to be a vocal contingent that isn't satisfied with that, though. and I kind of understand them.

[02:42] <masak> it does somehow feel like stopping short of the expected levels of excellence and DWIM.

[02:42] <AlexDaniel> I think that it is more “annoying” than “not much”, so I pretty much agree

[02:42] <psch> .u ℝ

[02:42] <yoleaux> U+211D DOUBLE-STRUCK CAPITAL R [Lu] (ℝ)

[02:43] <psch> i don't know what |R[X] is supposed to mean

[02:43] <psch> (where |R is ℝ)

[02:43] <masak> psch: it's the ring of polynomials over ℝ in one unknown X

[02:44] <psch> ah, my ring intuition is underdeveloped, i might read up on that tomorrow

[02:44] <psch> oh wait

[02:44] *** ilbot3 left
[02:44] <psch> is that just any polynomial that has one unknown

[02:44] <masak> yes

[02:44] <masak> with real coefficients

[02:44] <psch> hmm

[02:45] <masak> and "ring" here just means "you can + and *, and it works like you'd hope"

[02:45] <psch> yeah, i know algebraic rings

[02:45] <masak> then you've arrived already :)

[02:45] <psch> still, i'll have to think about it :P

[02:46] <psch> i'll be back with potential insight tomorrow o/

[02:46] <masak> well, do you agree that 5 and Polynomial([5]) are incompatible types on the face of it?

[02:46] <psch> i reserve the right to agree or not agree tomorrow, i need rest :)

[02:46] <masak> sure thing

[02:46] <ugexe> io::socket::async with a sync wrapper + io::socket::ssl, but i can't figure out a better way to handle a byte count request greater than what is left to still be read other than to read 1 byte at a time (and its crushing performance) https://gist.github.com/ugexe/71d82eb4bb5653125bd8

[02:46] *** ilbot3 joined
[02:50] *** raiph left
[02:52] *** Oatmeal left
[02:52] *** raiph joined
[02:54] *** vendethiel joined
[02:59] *** Oatmeal joined
[03:10] *** shinobi-cl left
[03:14] <masak> the test file t/spec/S17-scheduler/at.rakudo.moar aborts here after 'ok 15': "Method 'cancel' not found for invocant of class 'Any'"

[03:15] <masak> similarly, t/spec/S32-array/pop.rakudo.moar aborts after 'not ok 34': "Method 'Int' not found for invocant of class 'Any'"

[03:16] <masak> apart from that, my spectest run today is clean.

[03:16] *** weihan joined
[03:18] *** vendethiel left
[03:22] <masak> "It’d be nice, to eventually see the day where JavaScript is able to precisely compute decimal arithmetic as well as able to represent large integers safely." -- heh. sounds familiar somehow. :P -- https://ponyfoo.com/articles/es6-number-improvements-in-depth

[03:23] *** raiph left
[03:43] *** tokuhirom joined
[03:46] *** softmoth joined
[03:46] *** telex left
[03:47] *** tokuhirom left
[03:47] *** BenGoldberg left
[03:48] *** telex joined
[03:50] *** softmoth left
[03:50] *** mike` left
[04:00] *** raiph joined
[04:05] *** llfourn joined
[04:14] *** bjz_ left
[04:22] *** raiph left
[04:33] *** raiph joined
[04:38] *** abaugher left
[04:40] *** abaugher joined
[04:41] *** skarn joined
[04:42] *** riatre joined
[05:01] *** atweiden joined
[05:03] *** gtodd left
[05:04] <atweiden> i'm getting unexpected results when passing a regex with a closure: https://gist.github.com/atweiden/ce8aa39e506ebb969898

[05:04] *** gtodd joined
[05:06] *** Sgeo_ joined
[05:06] <atweiden> is this the correct way to grep where $name is of type Regex? @people.grep({ .name ~~ $name })

[05:09] <TimToady> that should work

[05:09] <masak> looks fine, yes

[05:14] *** kaare_ joined
[05:19] *** Sgeo_ left
[05:20] *** Sgeo joined
[05:34] *** softmoth joined
[05:38] *** softmoth left
[05:43] *** tokuhirom joined
[05:48] *** tokuhirom left
[06:00] *** WizJin joined
[06:00] *** WizJin left
[06:06] *** cognominal_ left
[06:11] *** weihan left
[06:12] *** [BNC]WizJin joined
[06:12] *** [BNC]WizJin left
[06:13] *** adhoc left
[06:13] *** bjz joined
[06:20] *** skids left
[06:24] *** AlexDaniel left
[06:25] *** tokuhirom joined
[06:25] *** raiph left
[06:29] *** tokuhirom left
[06:45] *** atweiden left
[06:45] *** mr-foobar left
[06:56] *** mr-foobar joined
[07:06] *** kmel joined
[07:18] *** kmel left
[07:18] *** kmel joined
[07:18] <kmel> hello

[07:19] <masak> ahoj, kmel 

[07:19] <kmel> hiya masak

[07:20] <kmel> this piece of code is not returning any value:

[07:20] <kmel> class Human { has $!name; method name { self.name; } }; my $john = Human.new(name => 'John'); say $john.name;

[07:21] <kmel> i know the . twigil will automatically declare an accessor for me, but i was trying to see what happens if i declare one myself.

[07:21] <dalek> rakudo/nom: 40de1a0 | TimToady++ | src/Perl6/Grammar.nqp:

[07:21] <dalek> rakudo/nom: support autogen on sigilless and &[] forms too

[07:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40de1a05cb

[07:21] <dalek> roast: e348d4f | TimToady++ | S03-metaops/ (6 files):

[07:21] <dalek> roast: test autogen on sigilless and &[] forms

[07:21] <dalek> roast: review: https://github.com/perl6/roast/commit/e348d4fbc6

[07:21] <masak> kmel: it's an infinite loop

[07:22] <kmel> the above code goes into infinite loop

[07:22] <masak> kmel: `self.name` means "call the method name"

[07:22] <masak> kmel: the method that statement is in, that is

[07:22] <masak> kmel: you probably meant `$!name`, not `self.name`

[07:22] *** softmoth joined
[07:22] <masak> kmel: another, shorter way of doing what you want is `has $.name;` with a dot

[07:23] <masak> then you don't need to write the getter method yourself -- Perl 6 does it for you

[07:23] <TimToady> you can still override if you declare with .

[07:23] <masak> also, if you use ! in the attr declaration, then you cannot pass it into (the default) .new the way you do now

[07:23] <masak> m: say <a b c> >>~>> "foo"

[07:23] <camelia> rakudo-moar 36c4c6: OUTPUT«(afoo bfoo cfoo)␤»

[07:24] <masak> m: say (:a, :b, :c) >>~>> "foo"

[07:24] <camelia> rakudo-moar 36c4c6: OUTPUT«Cannot modify an immutable Pair␤  in block <unit> at /tmp/6Y7aczZpV1:1␤␤»

[07:24] <masak> I don't understand this error -- could someone enlighten me?

[07:24] <masak> m: say :a ~ "foo"

[07:24] <camelia> rakudo-moar 36c4c6: OUTPUT«a    Truefoo␤»

[07:25] <kmel> m: class Human { has $!name; method name { $!name; } }; my $john = Human.new(name => 'John'); say $john.name;

[07:25] <camelia> rakudo-moar 36c4c6: OUTPUT«(Any)␤»

[07:25] <Hotkeys> m: say [~] (:a, "foo")

[07:25] <camelia> rakudo-moar 36c4c6: OUTPUT«a    Truefoo␤»

[07:25] <kmel> m: class Human { has $.name; method name { $!name; } }; my $john = Human.new(name => 'John'); say $john.name;

[07:25] <camelia> rakudo-moar 36c4c6: OUTPUT«John␤»

[07:26] <kmel> thanks masak and TimToady

[07:26] <Hotkeys> m: say (:a, :b, :c) >>~>> ("foo", "foo", "foo")

[07:26] <camelia> rakudo-moar 36c4c6: OUTPUT«Cannot modify an immutable Pair␤  in block <unit> at /tmp/yxKlVUI6eQ:1␤␤»

[07:26] <masak> kmel: the above method overriding works, but it's redundant because Perl 6 already gives you that

[07:27] <masak> m: class Human { has $.name }; my $john = Human.new(name => 'John'); say $john.name

[07:27] <camelia> rakudo-moar 36c4c6: OUTPUT«John␤»

[07:27] <TimToady> m: say (:a, :b, :c) X~ "foo"

[07:27] <camelia> rakudo-moar 36c4c6: OUTPUT«(a   Truefoo b       Truefoo c       Truefoo)␤»

[07:27] *** softmoth left
[07:27] <TimToady> seems specific to hypers

[07:27] <kmel> yes masak but the one above doesn't work

[07:27] <kmel> m: class Human { has $!name; method name { $!name; } }; my $john = Human.new(name => 'John'); say $john.name;

[07:27] <camelia> rakudo-moar 36c4c6: OUTPUT«(Any)␤»

[07:27] <kmel> it seems i have to declare it with the . twigil and then override it

[07:28] <TimToady> yes, he just said you need a . to initialize in new

[07:29] <masak> I did say that :)

[07:29] <ShimmerFairy> kmel: you actually don't need to define that 'method name' for a $.name declaration

[07:30] <TimToady> kmel said that too :)

[07:30] * masak submits >>~>> rakudobug

[07:31] <kmel> yes ShimmerFairy I was trying to define it myself (the rationale being a case where i need to override accessors)

[07:32] <ShimmerFairy> kmel: sure, nothing wrong with providing different accessors, just mentioning that the specific example shown here is redundant :)

[07:33] <kmel> ShimmerFairy oh yes definetly! 

[07:34] * masak .oO( not only redundant, but redundant! )

[07:36] <Hotkeys> oops I forgot to run the rakudobrew build in the magical visual studio prompt

[07:36] <kmel> m: say 'kmel is too lazy to provide a comprehensible example so he just wrote a redundant method';

[07:36] <camelia> rakudo-moar 36c4c6: OUTPUT«kmel is too lazy to provide a comprehensible example so he just wrote a redundant method␤»

[07:36] <kmel> I hear laziness is a good thing?

[07:38] <masak> depends on the laziness ;)

[07:38] <Hotkeys> meanwhile on my vps

[07:38] <Hotkeys> Makefile:427: recipe for target 'CORE.setting.moarvm' failed

[07:38] <kmel> masak ;)

[07:40] <Hotkeys> my computer got through that stage though

[07:40] <Hotkeys> wonder why my vps is getting angry

[07:42] <kmel> what is considered more idiomatic

[07:42] <kmel> this: class Human { has $.age; method assess-eligibility {if $!age < 21 {'No'} else {'Yes'}}}

[07:42] <kmel> or this: class Human { has $.age; method assess-eligibility {if self.age < 21 {'No'} else {'Yes'}}}

[07:43] * TimToady --> zzz &

[07:45] <Hotkeys> I want to say the former, but I'm no expert

[07:48] <masak> I find myself using either more or less interchangeably.

[07:49] <masak> they *do* have a semantic difference: if you subclass Human and provide an overridden method `age`, the second variant will pick up the overridden method.

[07:49] <kmel> indeed

[07:49] <masak> so in a sense it depends what you want to happen in that case. but I find that most of the time I don't prepare classes for being overridden like that, although maybe I should.

[07:49] <Hotkeys> would using a ternary instead of an if be less idiomatic?

[07:49] * Hotkeys likes ternaries

[07:50] <kmel> Hotkeys ternary?

[07:50] <masak> from a Smalltalk "late-bind all the things" point of view, you ought to use the method form

[07:50] <Hotkeys> class Human { has $.age; method assess-eligibility { $!age < 21 ?? 'Yes' !! 'No' }}

[07:50] <masak> I'd do the ternary there

[07:50] <masak> I always do when it's about a returned value

[07:50] <Hotkeys> plus you get to get rid of a few curlies

[07:51] <masak> oh, and another variant is `$.age` -- which means the same as `self.age`

[07:51] <Hotkeys> so that would get picked up on an override?

[07:52] <masak> yes

[07:52] <masak> because `self.age` and `$.age` are interchangeable, modulo some itemization, maybe

[07:52] <kmel> i like the ternary thing

[07:53] <Hotkeys> yeah nice and clean and generally readable unless you chain them like a madman

[07:54] <masak> easiest to think of ?? !! as an if statement but for expressions

[07:54] <masak> if you start chaining, then probably what you want is a small given/when

[07:55] <Hotkeys> doing some stackoverflow codegolf and happy to report you can still make gross looking code in perl 6

[07:55] <Hotkeys> @*ARGS[0].trans(/\d/=>{[~](0..$/)},/<:L>/=>{[~] samecase("a",~$/)..~$/}).say

[07:56] <Hotkeys> what a beauty

[07:56] *** adhoc joined
[07:57] <kmel> Hotkeys are you trying to scare me with this code ^

[07:57] <kmel> because i am :(

[07:57] <Hotkeys> it's really not super complicated

[07:57] <Hotkeys> just looks like it in one line

[07:57] <masak> kmel: the thing to know is that "golf" is for people who like to compress code to as few characters as possible.

[07:58] <nine> Is it true that I cannot use a custom .new of a Perl 6 object from NQP?

[07:58] <masak> kmel: the above code can certainly be written more clearly if that is the goal.

[07:58] <Woodi> hallo #perl6 :)

[07:59] *** mr-foobar left
[07:59] <kmel> masak: i see

[07:59] <kmel> thanks for the explanation

[07:59] <Hotkeys> here it is expanded out a bit http://pastebin.com/38TBK0fj

[08:00] <Hotkeys> basically it replaces all digits in the string with 0..digit

[08:00] <Hotkeys> and all letters with a..letter, in the same case

[08:01] <Hotkeys> I'm sure someone more savvy might be able to save a few characters somewhere in there

[08:01] <Hotkeys> but that's the best i could do

[08:02] <Hotkeys> I actually was able to get it to that size because I saw someone talking about the samecase function in here just before I did it

[08:02] <Hotkeys> otherwise I would've just matched each case separately

[08:02] *** FROGGS joined
[08:03] <Woodi> masak: about [something like] subsumptions & just my subjective impresion: pre GLR lists features was tangled with sugared syntax, now we have more clear "rules", etc but I somehow think sugar syntaxes aka user-friendly-DWIMs are implicitly prohibited...

[08:03] <kmel> i still have a lot to learn. 

[08:03] <Hotkeys> anyone know why I'm getting this error building rakudo w/ rakudobrew

[08:03] <Hotkeys> Makefile:427: recipe for target 'CORE.setting.moarvm' failed

[08:03] <Hotkeys> on Ubuntu 15.04

[08:04] <nine> Hotkeys: can you paste the full rakudobrew output on gist.github.com?

[08:04] <Woodi> masak: so, i think "sugar" syntax should be allowed on top of the language, somehow. and obviously proverbial jnthn++ is right about language but sugar coating users want is from other "layer"...

[08:04] <Hotkeys> the whole thing or just the relevant section

[08:05] <nine> Hotkeys: can't hurt to have the whole thing

[08:08] <Hotkeys> alright one minute

[08:11] <masak> Woodi: it's weird to me to think of this as "sugar" (because it actually changes semantics, not syntax) -- but I think I see your point.

[08:15] *** darutoko joined
[08:17] *** diana_olhovik_ joined
[08:21] *** rindolf joined
[08:22] *** xfix joined
[08:22] *** firstdayonthejob joined
[08:25] *** tokuhirom joined
[08:27] *** protium left
[08:30] *** tokuhirom left
[08:31] *** diana_olhovik_ left
[08:32] <Woodi> also I think i realy hate "casting". probably becouse a) I don't know/learn where to put it;  b) it's SO UGLY in any language I seen so far...

[08:34] <Woodi> when moust-common-case is well known then some DWIM could be handy instead of "use cast, always"...

[08:35] <Hotkeys> nine: https://gist.github.com/johnspurr/934c87ecac2f799dc49e

[08:35] *** RabidGravy joined
[08:36] <masak> Woodi: arguing the other side, though; there is a clear sense in which every implicit casting degrades the ability of the type system to flag up type errors.

[08:37] <Woodi> masak: yes and no

[08:37] <Hotkeys> It gets a little bit angry in a few places

[08:37] <Hotkeys> But it only gets really angry at the end

[08:38] <Woodi> yes - what you said;  no - becouse sugar layer should be "invisible" for language layer 

[08:38] <llfourn> Woodi: isn't that what coercions like Int() is for?

[08:38] <masak> Woodi: I'm not sure what you mean.

[08:39] <Woodi> llfourn: we thinking about not using implicit casting here :)

[08:39] <nine> Hotkeys: This is strange: "Stage parse      : Killed"

[08:40] <nine> Hotkeys: could it be that it runs into some resource limit? Maybe it uses too much memory?

[08:40] <Woodi> masak: i understans "sugar" as something what is automatically un-golfed as it is parsed into proper language. so that sugar do not degrade anything

[08:40] <masak> I wasn't talking about implicit casting at all. subsumption would likely be governed by the target type declaring some method or other, like `method subsume(Int $n) { $n.Rat }`

[08:40] <nine> Hotkeys: stage parse can eat a GB or two of RAM

[08:40] <masak> Woodi: right, "sugar" is a syntactic thing. the subsumption we're talking about is not.

[08:40] <Hotkeys> Oh

[08:41] *** diana_olhovik_ joined
[08:41] <Woodi> even ingy Hotkeys last gist there are many warning in MoarVM compilation becouse someone do not put casting :)

[08:41] <Hotkeys> It *is* only a baby vpa

[08:41] <Hotkeys> Vps

[08:41] <Hotkeys> Maybe it is running out mem

[08:41] <Woodi> masak: probably, I just thinked it is similiar thing :)

[08:41] *** ShimmerFairy left
[08:42] <Hotkeys> Cab I compile it for Ubuntu on my windows machine

[08:42] <nine> Hotkeys: I don't think so, no.

[08:43] <Hotkeys> Darn

[08:43] <nine> Hotkeys: maybe you can add some swap on your Vps?

[08:44] <Hotkeys> I suppose I could 

[08:44] <nine> Ok, how can I get at CompUnit::Handle from nqp? I get the impression that gethllsym finds only symbols that were added from nqp with bindhllsym.

[08:44] <Hotkeys> I'll do it tomorrow

[08:45] <Hotkeys> Because I'm in bed and can't be bothered to set up ssh keys with my phone right now

[08:45] *** protium joined
[08:45] <nine> Hotkeys: or today and let it compile over night. Using swap for this will probably make it extremely slow ;)

[08:46] <Hotkeys> Having perl 6 on my vps isn't time sensitive :p

[08:46] <Hotkeys> Just wanted it for fiddling around

[08:46] <Hotkeys> Maybe making an irc bot for funsies

[08:49] *** xyf joined
[08:55] *** diana_olhovik_ left
[08:58] <Woodi> m: my Rat $a = 7

[08:58] <camelia> rakudo-moar 40de1a: OUTPUT«Type check failed in assignment to $a; expected Rat but got Int␤  in block <unit> at /tmp/ZcbOWJJHUy:1␤␤»

[08:58] <Woodi> for me at declaration time it should just work...

[09:00] <masak> Woodi: I think the word you're looking for is "convenience", not "sugar"

[09:00] <masak> Woodi: "at declaration time"? what about `my $n1 = 7; my Rat $n2 = $n1` ?

[09:02] <Woodi> masak: 'my Rat .+' is just better&complete notation for cast then: my Rat = (Rat) $n1 :)

[09:03] <Woodi> masak: yes, ATM I do not see difference between sugar and convenience...

[09:03] <Woodi> *then my Rat $n2 = $n1

[09:04] <Woodi> grr...

[09:05] <masak> "sugar" is when there's a short/nice form of some feature, and the longer form works just the same. I guess you could argue that the *lack of typecasting* (i.e. the empty) string counts as a kind of sugar, but I don't like to think of it as that.

[09:06] <masak> Woodi: `my Rat $n2` means this: "I want the compiler and runtime to flag up an error whenever someone puts a value in $n2 that is not a Rat". that's what type-checking is.

[09:07] <masak> this is what needs to be understood in order to understand why auto-casting stuff degrades the type-checking.

[09:10] *** softmoth joined
[09:10] <Woodi> masak: ok, so let's: my Rat $a = <Int>+;  work as lazy users want and:  = $b  as failure :)

[09:10] <kmel> what is the use of class variables?

[09:11] <kmel> in practice

[09:11] <Hotkeys> Gives your classes something to hold

[09:12] <masak> Woodi: I think that would be easier to arrange, yes. I'm still not sure that's a good solution, though. or if people would just become annoyed at new inconsistency, and that'd become a new FAQ.

[09:12] <masak> kmel: "class variables"?

[09:13] <kmel> masak: class attributes

[09:15] <masak> kmel: not much of a use case in well-designed OO, I'd say. thing is, the world is full of real-world compromises.

[09:15] *** softmoth left
[09:16] <masak> Woodi: also, for which pairs of types would this be made to work? Int ~~> Rat and Rat ~~> Num, for sure. what about Real ~~> Complex? what about Bool ~~> Int? Int ~~> Bool? Str ~~> Numeric?

[09:16] <kmel> http://doc.perl6.org/language/classtut#Static_fields%3F

[09:16] <masak> there's some kind of slippery slipe there.

[09:16] <masak> kmel: hm, "fields" is not a Perl OO term. that should probably be changed in the classtut.

[09:17] <masak> we call them "attributes", like you did above.

[09:17] <masak> "fields" from a Perl perspective sounds like something in a column in a record you read from a file :)

[09:20] <kmel> well since you will be changing the classtut can you provide a more straightforward example for class attributes?

[09:21] <kmel> as someone who is new to Perl 6, i didn't really understand the example

[09:21] <masak> what non-contrived example would you suggest? :)

[09:22] * masak hasn't looked at the current example

[09:23] <Woodi> masak: Int -> Rat -> Num should work.  declaration: my [Int|Rat|Num] $a  is realy clear, IMO

[09:23] <kmel> hehe, i don't know something a la java

[09:24] <kmel> an attribute that holds how many objects of that class were created

[09:25] <kmel> each time you call new() it gets incremented

[09:25] <Woodi> masak: Str into number and  Number into Bool is probably language design.

[09:26] <nine> Finally! my $CompUnitHandle := nqp::who($*W.find_symbol(["CompUnit"])).AT-KEY('Handle');

[09:27] <Woodi> nine: but weekend just started ;)

[09:29] <nine> Woodi: my plan is not to spend all of the weekend on this ;)

[09:29] *** Psyche^ left
[09:30] *** Psyche^ joined
[09:34] *** xinming_ joined
[09:35] *** spider-mario joined
[09:41] <Woodi> btw. it is crazy that automating casting do not work like it do in human brain...

[09:42] *** xyf left
[09:44] *** mj41 joined
[09:45] <Woodi> U: Cortana, how many thieves goes through that window ? C: Errr... I don't realy know what to say...  U: WHAT ??  C: You see, first was two but one left with something and there was only one... So my co-procesor send me 1.5 but I have humans as Int type... 

[09:51] <lizmat> good *, #perl6!

[09:51] <dalek> rakudo/curli: 4ddc391 | (Stefan Seifert)++ | src/ (3 files):

[09:51] <dalek> rakudo/curli: Have load_module return a CompUnit::Handle istead of a bare Stash

[09:51] <dalek> rakudo/curli: 

[09:51] <dalek> rakudo/curli: This is a step towards moving more functionality into CompUnit::Handle.

[09:51] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/4ddc391812

[09:51] *** vendethiel joined
[09:51] <lizmat> m: dd Pair.new

[09:51] <camelia> rakudo-moar 40de1a: OUTPUT«Pair $var = Mu => Mu␤»

[09:52] *** firstdayonthejob left
[09:52] <lizmat> masak: ^^^ is the source of #126510

[09:52] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126510

[09:53] <lizmat> I'm not sure what a Pair.new would need to do without having been specifified a key or value

[09:55] *** xyf joined
[09:58] <nine> Ah, even easier: $*W.find_symbol(["CompUnit", "Handle"]);

[10:01] *** Alina-malina left
[10:02] <RabidGravy> tadzik, I've done another PR for JSON::Unmarshal https://github.com/tadzik/JSON-Unmarshal/pull/6 when you have a moment :)

[10:03] <masak> kmel: your class attribute musings reminded me of http://strangelyconsistent.org/blog/i-can-haz-constant

[10:04] <kmel> masak: i am reading it

[10:04] <masak> kmel: notably, "When I learned about `static` fields in Java, even the examples were contrived."

[10:04] <masak> (and then the example you suggested above, which I can't recall needing in practice.)

[10:05] *** dayangkun left
[10:05] <masak> m: class Car { my $.cars-produced; submethod BUILD { $!cars-produced++ } }; Car.new xx 3; say Car.cars-produced

[10:05] <camelia> rakudo-moar 40de1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TAvDBBaLhV␤Attribute $!cars-produced not declared in class Car␤at /tmp/TAvDBBaLhV:1␤------> 3 submethod BUILD { $!cars-produced++ } }7⏏5; Car.new xx 3; say Car.cars-produced␤    expecting any of:…»

[10:06] <masak> hm.

[10:06] <kmel> m: class Human {has $.name;my $.counter = 0;method new($name) {self.bless(:$name);Human.counter++;}}my $a = Human.new('a');my $b = Human.new('b');say Human.counter;

[10:06] <camelia> rakudo-moar 40de1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ByT5NCxJij␤Strange text after block (missing semicolon or comma?)␤at /tmp/ByT5NCxJij:1␤------> 3) {self.bless(:$name);Human.counter++;}}7⏏5my $a = Human.new('a');my $b = Human.new␤    expecting an…»

[10:07] <masak> m: class Car { my $cars-produced; submethod BUILD { $cars-produced++ }; method cars-produced { $cars-produced } }; Car.new xx 3; say Car.cars-produced

[10:07] <camelia> rakudo-moar 40de1a: OUTPUT«3␤»

[10:07] <masak> ...I thought I distinctly remembered `my $.cars-produced` giving me both the `my` variable and the accessor.

[10:07] <kmel> m: class Human {has $.name; my $.counter = 0; method new($name) { self.bless(:$name); Human.counter++; } }; my $a = Human.new('a'); my $b = Human.new('b'); say Human.counter;

[10:07] <camelia> rakudo-moar 40de1a: OUTPUT«2␤»

[10:08] *** kjs_ joined
[10:09] <kmel> masak: this is the only example i learned while taking a java course. I don't know if it can be used in practice or not. I'll take your world for it. 

[10:09] <lizmat> masak: re #126510 , I think the problem is really that the hyper expects something Iterable, and a Pair is not

[10:09] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126510

[10:09] <masak> kmel: I think the thing to understand about class-level variables is that they are morally indistinguishable from globals.

[10:10] <masak> kmel: and thus have all the pitfalls and anti-patterns globals have.

[10:10] <masak> kmel: I once thought I had a great use, until I wanted to test that code base. then it all broke down and turned out to be a really bad idea.

[10:10] <masak> kmel: I remember mst materializing after I said that here on channel, muttering "I could have told you that" :P

[10:12] <masak> lizmat: huh. I know I haven't been following along with all the "nodal" shenanigans lately, but (a) I'm not trying to iterate inside the pairs, and (b) it's talking about mutating the pair, which also I'm not.

[10:12] <kmel> masak: ok then, class attributes are the devil :)

[10:12] <masak> lizmat: note that it does work as advertized with X~, as TimToady showed.

[10:12] <masak> lizmat: and this is from code in a production code base that used to work.

[10:12] <kmel> masak: thanks for your explanation

[10:12] <lizmat> masak: basically it's doing $type.new and then try to assign the result into that

[10:13] *** isBEKaml joined
[10:13] *** Alina-malina joined
[10:13] <masak> lizmat: even after your explanation above, I still kind of expect it to work (and I'm confused as to why mutation needs to happen)

[10:14] <lizmat>     my $type = left.WHAT;

[10:14] <lizmat>     my \result := $type.new;

[10:14] <lizmat>     result = @keys Z=> HYPER(&op, left{@keys}, right, :$dwim-left, :$dwim-right);

[10:15] <vendethiel> RabidGravy: second-class multi dispatch (as in, pattern matching :P) is also pretty great

[10:17] <moritz> maybe coercion could make it work?

[10:17] <isBEKaml> OHHAI, folks -- been a while, it's good to see all that activity around bugsquashing on RT :-)

[10:17] <moritz> (left.WHAT)(@keys Z=> HYPER(&op, left{@keys})

[10:18] <lizmat> perhaps the problem is caused by Pair being Associative ?

[10:18] <Woodi> about globals: do function + global varible [+ programming discipline] is equivalent to closure ?

[10:19] <moritz> Woodi: no

[10:19] <moritz> Woodi: with a global variable you only ever get one instance of a cosure

[10:19] <Woodi> moritz: ah, right

[10:20] <isBEKaml> There used to be a --with-moar option on nqp's configure script, right? Or am I not remembering correctly?

[10:21] <masak> isBEKaml: --gen-moar ?

[10:21] <isBEKaml> masak: no, I have a locally built moar. I was asking about pointing nqp's configure script to the local one.

[10:22] <masak> isBEKaml: ah. that one I don't know.

[10:22] <moritz> isBEKaml: iirc you can specify a --prefix. If it finds a bin/moar in $prefix, it takes that

[10:22] <isBEKaml> masak: or is that --prefix and configure would detect it?

[10:22] <isBEKaml> moritz: ah, thank you

[10:22] *** Begi1115 joined
[10:31] *** ^elyse^ joined
[10:34] *** ^elyse^ left
[10:34] * flussence wonders how much fallout there'd be if untyped scalars in strict mode behaved like C's "auto" keyword, taking the type of the first thing assigned to them.

[10:34] *** isBEKaml left
[10:35] <lizmat> flussence: there is no such thing as an untyped scalar

[10:35] *** ShimmerFairy joined
[10:35] <lizmat> the default type is Any

[10:36] <flussence> fine, un*declared*-type scalar then :)

[10:36] <lizmat> that would make Any special in the handling of assignments

[10:37] <lizmat> I'm not seeing that happening easily    :-(

[10:38] <flussence> yeah, seems awkward.

[10:38] *** mr-foobar joined
[10:39] *** leont joined
[10:39] <flussence> I can see something like "auto" being useful, but I'm not sure where it'd fit in what we currently have. my ::T $a maybe?

[10:41] <tadzik> RabidGravy: hah, I see them accumulating as october is ending :D

[10:41] <tadzik> RabidGravy: do you have some project where I could help with two things? :D

[10:42] <ShimmerFairy> flussence: I could only see that being sane if it only happened in a declaration, i.e.  my $a = 42;  but not  my $a; $a = 42; . Even then I get the feeling it'd cause quite a few problems :)

[10:42] <RabidGravy> tadzik, write more stuff! :)

[10:43] <ShimmerFairy> At the very least, it definitely shouldn't be part of the "strict" pragma. Probably an ecosystem pragma would be my choice :)   .oO( use type-inference; )

[10:43] <tadzik> RabidGravy: that's my problem! I'm writing stuff, instead of fixing other people's stuff :P

[10:43] <flussence> I guess what I described was more Haskell-y than C-y...

[10:44] <leont> Or C++11-y

[10:44] <RabidGravy> the reason for the fixorification of JSON::Unmarshal is that I want to round trip JSON data through classes and I want that for the META6 parser which is in itself a test of sorts for some bigger things

[10:44] <RabidGravy> :)

[10:44] <ShimmerFairy> flussence: perhaps, I just came up with the phrase "type inference" when trying to figure out what you'd call the pragma :)

[10:47] <RabidGravy> I'm having brane fade.  How do I what I want to do with something like:

[10:47] <RabidGravy> m: multi sub foo(Any $type) { say "any Any" }; multi sub foo(Any $type where { $_ =:= Any }) { say "reeally any" }; foo(Int); foo(Any);

[10:47] <camelia> rakudo-moar 40de1a: OUTPUT«any Any␤any Any␤»

[10:47] <RabidGravy> which doesn't actually work as I thought

[10:48] <lizmat> m: multi sub foo(Any $type) { say "any Any" }; multi sub foo(Any $type where { $_ === Any }) { say "reeally any" }; foo(Int); foo(Any);

[10:48] <camelia> rakudo-moar 40de1a: OUTPUT«any Any␤reeally any␤»

[10:48] <flussence> m: multi sub foo(Any $type) { say "any Any" }; multi sub foo(Any $type where { .^mro[0] =:= Any }) { say "reeally any" }; foo(Int); foo(Any);

[10:48] <camelia> rakudo-moar 40de1a: OUTPUT«any Any␤reeally any␤»

[10:49] <ShimmerFairy> =:= isn't unless you want the exact same object, as in basically comparing pointers :)

[10:50] <RabidGravy> cool cheers all

[10:50] <moritz>  =:= compares containers, and only falls back to object pointers when there are no containers

[10:51] <RabidGravy> the === and =:= somewhat confuse my stupid brane

[10:51] <ShimmerFairy> =:= only comes up if you mean very precisely this exact object. I've only ever seen it use with IterationEnd in rakudo, and haven't used it myself :)

[10:53] <moritz> PSA: perl6.org has been accepted for the "let's encrypt" public beta. I'm trying it out now.

[10:54] <moritz> short downtime of the website is possible

[10:58] *** softmoth joined
[11:00] *** vendethiel left
[11:00] *** weihan joined
[11:01] *** kmel left
[11:02] <tadzik> yay!

[11:03] *** softmoth left
[11:04] <dalek> ecosystem: 7cde0fd | RabidGravy++ | META.list:

[11:04] <dalek> ecosystem: That's META.info not README.md - me--

[11:04] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/7cde0fdc63

[11:05] <Woodi> madness! C have alloca() ;)

[11:06] <Woodi> flussence: in C auto varibles "takes type of assigned thing" ?

[11:12] <[Tux]> test             50000    37.756    37.642

[11:12] <[Tux]> test-t           50000    38.745    38.631

[11:12] *** ^elyse^ joined
[11:15] <moritz> https://perl6.org/ # works!

[11:16] <lizmat> and the certificate is considered valid (well, until 29 Jan 2016 )

[11:20] <moritz> and according to https://www.ssllabs.com/ssltest/analyze.html?d=perl6.org&hideResults=on quite good

[11:21] <RabidGravy> where does module.perl6.org put the errors generating the big list of modules?

[11:22] <moritz> RabidGravy: http://modules.perl6.org/log/

[11:23] <RabidGravy> cheers

[11:28] *** Actualeyes joined
[11:32] *** diana_olhovik joined
[11:34] *** FROGGS_ joined
[11:34] <RabidGravy> "Invalid json found at: https://raw.githubusercontent.com/szabgab/Perl6-Maven/master/META.info" - is odd as I just fed the file through json_xs and it didn't complain

[11:35] *** FROGGS left
[11:38] <moritz> HTTP request sent, awaiting response... 404 Not Found

[11:39] <moritz> that's what I get from that URL

[11:39] <moritz> maybe it doesn't catch the 404, but has an empty (or error message) response that isn't valid json?

[11:39] <RabidGravy> that's odd

[11:40] <moritz> that's because the default branch is "main", not "master"

[11:40] <moritz> in that repo

[11:41] <RabidGravy> yeah, just noticed that

[11:41] <dalek> ecosystem: ed2eb49 | moritz++ | META.list:

[11:41] <dalek> ecosystem: Fix URL to Perl6-Maven META.info

[11:41] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/ed2eb49a40

[11:42] <RabidGravy> beat me to it

[11:42] <moritz> RabidGravy++ # investigating

[11:43] <RabidGravy> tony-o, I just sent PR to fix the META.info for HTML::Parser :)

[11:43] <RabidGravy> and with that no errors

[11:43] <moritz> anyway, Let's Encrypt is awesome. The tools are still a bit fragile, but all in all it works and produces good results

[11:44] <ShimmerFairy> moritz: took a quick look and I think I'd agree. It's nice to see the ol' "spend actual money for encryption" thing wearing down :)

[11:45] *** firstdayonthejob joined
[11:51] <lizmat> hmmmm..  looks like TimToady's 40de1a05cbe786f7b3e81ae broke S03-operators/equality.t

[11:51] <lizmat> happens in the optimizer: Cannot find method 'is_dispatcher'

[11:52] <lizmat> in report_inevitable_dispatch_failure

[11:54] * lizmat hopes someone will be able to pick that up

[11:54] *** arcwest1 joined
[11:55] *** arcwest1 left
[11:56] *** ^elyse^ left
[11:58] <psch> .tell masak the mathy quote seems like type unification, if anything.  as in, "assume the narrower type given the wider, because of the established context"

[11:58] <yoleaux> psch: I'll pass your message to masak.

[11:59] <psch> .tell masak the equivalent would be if 'my Any $x = 5; $x.VAR.of.say' printed (Int)

[11:59] <yoleaux> psch: I'll pass your message to masak.

[12:00] <psch> .tell masak as for the other direction, which is the interesting case, what i'd think workable there was a pragma that gave the user a lexical Any+{Numeric}, (or maybe a NumIntRat), which could be thought as subsuming the type, but it would also mean making all of Int, Num, Rat equivalent behind the scenes

[12:00] <yoleaux> psch: I'll pass your message to masak.

[12:01] <psch> .tell masak as in, any var declared as Num, Int or Rat actually has a .VAR.of of (IntNumRat) behind the scenes, which is polymorph with exactly those types

[12:01] <yoleaux> psch: I'll pass your message to masak.

[12:02] <psch> .tell masak s/has/would have given this pragma/

[12:02] <yoleaux> psch: I'll pass your message to masak.

[12:02] *** firstdayonthejob left
[12:02] <RabidGravy> tadzik, J::U also has trouble with Rat attributes, I'll probably send "one multi for each numeric type" later :)

[12:06] <psch> .tekk masak, actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X]

[12:06] <psch> .tell masak, actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X]

[12:06] <yoleaux> psch: What kind of a name is "masak,"?!

[12:06] <psch> .tell masak actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X]

[12:06] <yoleaux> ...

[12:06] <psch> :P

[12:06] <psch> gosh yoleaux 

[12:08] <RabidGravy> right off out for a bit

[12:09] <moritz> fwiw the "Cannot find method 'is_dispatcher'" errors comes from %opts<signature> being NQPMu

[12:10] *** eliasr joined
[12:10] <moritz> ah no, I checked the wrong variable :(

[12:11] <psch> m: say infix:<!=>(False)

[12:11] <camelia> rakudo-moar 40de1a: OUTPUT«===SORRY!===␤Cannot find method 'is_dispatcher'␤»

[12:11] <psch> autogen of meta ops isn't working right apparently

[12:12] <psch> .tell masak actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X], which throws some of my argument out of the window... more thinking :)

[12:12] <yoleaux> ...

[12:12] <psch> ah, so it means 5 tells per target

[12:12] <moritz> ah, it calls is_dispatcher on a Block

[12:12] <moritz> and I guess it used to be a Routine

[12:13] *** RabidGravy left
[12:13] <psch> m: Routine.^can('is_dispatcher').say

[12:13] <camelia> rakudo-moar 40de1a: OUTPUT«(<anon>)␤»

[12:13] <psch> m: Block.^can('is_dispatcher').say

[12:13] <camelia> rakudo-moar 40de1a: OUTPUT«()␤»

[12:13] <moritz> problem is, I don't understand the code that TimToady++ touched

[12:14] <moritz> I can try to make the optimizer robuster, and only call .is_dispatcher if it exists

[12:15] <moritz> or I can give Block an is_dispatcher method that returns False

[12:15] <psch> m: say &infix:<!=>.WHAT

[12:15] <camelia> rakudo-moar 40de1a: OUTPUT«(Sub+{<anon|38966432>}+{Precedence})␤»

[12:15] <moritz> but it feels like fixing the problem at the wrong end

[12:15] <psch> m: my $a = 5; say &infix:<+=>($a, 2); say $a

[12:15] <camelia> rakudo-moar 40de1a: OUTPUT«7␤7␤»

[12:15] <psch> m: my $a = 5; say infix:<+=>($a, 2); say $a

[12:15] <camelia> rakudo-moar 40de1a: OUTPUT«7␤7␤»

[12:18] <dalek> rakudo/nom: 8b9124e | moritz++ | src/Perl6/Optimizer.nqp:

[12:18] <dalek> rakudo/nom: Make optimizer more robust

[12:18] <dalek> rakudo/nom: 

[12:18] <dalek> rakudo/nom: Block has no method is_dispatcher, but it seems we now report

[12:18] <dalek> rakudo/nom: "will never work" errors on blocks too.

[12:18] <dalek> rakudo/nom: 

[12:18] <dalek> rakudo/nom: Maybe this is the wrong approach, and the codegen should be changed

[12:18] <dalek> rakudo/nom: to produce routines where blocks appear now; if so, somebody else

[12:18] <dalek> rakudo/nom: must do that :-/

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b9124e545

[12:18] <moritz> ===SORRY!===

[12:18] <moritz> Calling (Bool) will never work with declared signature (\a, \b)

[12:18] <moritz> at t/spec/S03-operators/equality.t:47

[12:19] <moritz> so the actual problem isn't fixed yet; it's just the error reporting for the actual problem that was fixed

[12:19] *** kmel joined
[12:20] <kmel> m: class Human { has $.name; }; my $john = Human.new(name =>'John',age => 23,); say $john;

[12:20] <camelia> rakudo-moar 40de1a: OUTPUT«Human.new(name => "John")␤»

[12:20] *** ^elyse^ joined
[12:20] <kmel> is it normal that this ^ doesn't give an error?

[12:20] <moritz> kmel: yes; it makes subclassing much easier

[12:23] <kmel> moritz: by subclassing you mean inheritance?  

[12:25] <moritz> kmel: yes

[12:25] <psch> m: say METAOP_NEGATE(&infix:<=>)

[12:25] <camelia> rakudo-moar 40de1a: OUTPUT«-> \a, \b { #`(Block|80989192) ... }␤»

[12:25] <psch> that's the Block that has no dispatcher

[12:26] <moritz> I figured it doesn't hurt if the optimizer is more robust

[12:26] <psch> m: say METAOP_NEGATE(&infix:<==>)

[12:26] <camelia> rakudo-moar 40de1a: OUTPUT«-> \a, \b { #`(Block|80186616) ... }␤»

[12:27] <psch> m: say METAOP_REDUCE_LEFT(&infix:<==>)

[12:27] <camelia> rakudo-moar 40de1a: OUTPUT«sub (+ is raw) { #`(Sub|73972768) ... }␤»

[12:27] <psch> m: say METAOP_REDUCE_LEFT(&infix:<==>)()

[12:27] <camelia> rakudo-moar 40de1a: OUTPUT«True␤»

[12:27] *** tokuhirom joined
[12:27] <psch> m: say METAOP_NEGATE(&infix:<==>)()

[12:27] <camelia> rakudo-moar 40de1a: OUTPUT«Too few positionals passed; expected 2 arguments but got 0␤  in block <unit> at /tmp/ODFsE4vjWQ:1␤␤»

[12:27] <psch> moritz: yeah, i agree

[12:29] <ShimmerFairy> Assuming it wouldn't break everything, I'd suggest an is_dispatcher method on all Callable things, since any one of them could potentially be queried about dispatching, methinks :)

[12:31] *** tokuhirom left
[12:34] <psch> ohh

[12:34] *** pink_mist left
[12:37] *** cognominal_ joined
[12:38] *** TEttinger left
[12:40] <psch> well, what happens is that we parse infix:<!=> via the add_mystery, which auto-generates a call to METAOP_NEGATE(&infix:<=>)

[12:40] <kmel> moritz: thanks

[12:40] <psch> but on one hand that's bogus in this specific case, because we actually mean METAOP_NEGATE(&infix:<==>)

[12:41] <psch> and on the other hand we actually mean &infix:<!=>($?) from Numeric.pm

[12:44] <ShimmerFairy> psch: could METAOP_NEGATE benefit generally from an error message concerning &infix:<=>, by any chance? I don't know how likely it would happen outside of core, but I figure it might be nice to explain weird misinterpretations of != :)

[12:45] <ShimmerFairy> ("use either &infix:<!=> or negate &infix:<==> instead" ?)

[12:45] *** kjs_ left
[12:47] *** softmoth joined
[12:47] <psch> ShimmerFairy: the normal way of producing METAOP_NEGATE(&infix:<=>) already complains, and whoever actually uses literal METAOP_NEGATE in their code gets a DIHWIDT, at least from me

[12:47] <psch> m: my $a ![=] False; # this is the complaint

[12:47] <camelia> rakudo-moar 40de1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UYGqwLbG1r␤Cannot negate = because list assignment operators are too fiddly␤at /tmp/UYGqwLbG1r:1␤------> 3my $a ![=]7⏏5 False; # this is the complaint␤»

[12:49] <dalek> roast: 7e90f63 | lizmat++ | S32-list/repeated.t:

[12:49] <dalek> roast: Add tests for "repeated"

[12:49] <dalek> roast: review: https://github.com/perl6/roast/commit/7e90f633ca

[12:49] <dalek> rakudo/nom: 920bffa | lizmat++ | src/core/Str.pm:

[12:49] <dalek> rakudo/nom: Remove superfluous return

[12:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/920bffa07d

[12:49] <dalek> rakudo/nom: 51886a4 | lizmat++ | src/core/Any-iterable-methods.pm:

[12:49] <dalek> rakudo/nom: Add sub version of "repeated"

[12:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/51886a4740

[12:50] <ShimmerFairy> psch: why's it called "list" assignment, though?

[12:51] *** softmoth left
[12:54] <psch> m: my ($a, $b) = 1, 2; say $a,$b # because it is

[12:54] <camelia> rakudo-moar 40de1a: OUTPUT«12␤»

[12:54] <psch> m: my $a; say infix:<++>($a) 

[12:54] <camelia> rakudo-moar 40de1a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jbWf01vwM5␤Undeclared routine:␤    infix:<++> used at line 1. Did you mean 'infix:<+|>', 'infix:<∖>', 'infix:<lt>', 'infix:<eq>'?␤␤»

[12:54] <ShimmerFairy> not necessarily, though, so I think it's LTA to be specific there :)

[12:54] <psch> ShimmerFairy: feel free to open a ticket

[12:55] <moritz> ... with an example of better wording

[12:55] <psch> the infix:<++> actually makes me think that infix:<!=> shouldn't be legal

[12:55] <psch> 'cause that's what causes not finding the candidate from Numeric.pm, which is why we autogen something that can't work

[12:56] <psch> eh, well maybe just "doesn't" instead of "can't"

[12:56] <psch> std: infix:<X+>

[12:56] <camelia> std 28329a7: OUTPUT«5===SORRY!5===␤Undeclared routine:␤     'infix:<X+>' used at line 1␤Check failed␤FAILED 00:00 134m␤»

[12:56] <ShimmerFairy> moritz: it's just be to remove the "list" part; I've honestly never heard to &infix:<=> referred to as anything but "the assignment operator", no qualification. The use of the word "list" makes me think you're trying ([=] 1,2,3) or something, that's how unusual it is :)

[12:57] *** cognominal_ left
[12:57] <moritz> ShimmerFairy: the problem is that = comes in two different flavors and precedences

[12:57] <ShimmerFairy> moritz: is there any harm in the error messaging generalizing to cover either assign op, though?

[12:58] <moritz> ShimmerFairy: there an item assignment with tighter precedence than the = list item assignment

[12:58] <moritz> ShimmerFairy: the error message just contains the name of the precedence category; we can't have both precedence categories be called just "assignment" without causing ambiguous messages

[12:59] <ShimmerFairy> moritz: Ah, it pulls the name from somewhere, that explains it :) . I thought it was just part of a larger constant string.

[13:01] *** cognominal joined
[13:02] <dalek> rakudo/nom: eb0f0c3 | lizmat++ | t/spectest.data:

[13:02] <dalek> rakudo/nom: Run S32-list/repeated.t tests

[13:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb0f0c321a

[13:02] <dalek> rakudo/nom: 447069b | lizmat++ | src/core/Any-iterable-methods.pm:

[13:02] <dalek> rakudo/nom: Make reduce/produce multi's

[13:02] <dalek> rakudo/nom: 

[13:02] <dalek> rakudo/nom: To allow for easier extensibility, no functional change

[13:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/447069b998

[13:12] *** AlexDaniel joined
[13:17] <dalek> doc: f65e122 | lizmat++ | doc/Type/List.pod:

[13:17] <dalek> doc: Document :with on List.unique

[13:17] <dalek> doc: review: https://github.com/perl6/doc/commit/f65e12258e

[13:20] *** kjs_ joined
[13:23] <jdv79> is there any way to check for a priv method besides catching the exception on not found?

[13:24] <dalek> doc: 1bcaafd | lizmat++ | doc/Type/List.pod:

[13:24] <dalek> doc: Add documentation for List.repeated

[13:24] <dalek> doc: review: https://github.com/perl6/doc/commit/1bcaafd17e

[13:24] <lizmat> wasn't there a ^private_methods ?

[13:24] <jdv79> obj!?meth and obj.can('!meth') don't seem to work - perhaps they should though

[13:24] <jdv79> lizmat: i don't see it

[13:26] *** raiph joined
[13:26] <lizmat> m: class A { method !a {} }; say A.^private_method_table.values

[13:26] <camelia> rakudo-moar 447069: OUTPUT«(a)␤»

[13:26] *** weihan left
[13:26] <lizmat> I guess we could add it to Perl6::Metamodel::PrivateMethodContainer

[13:33] <ShimmerFairy> jdv79: actually, '!meth' would mean a method literally called that. Check out all the cases in rakudo where Cursors are called with methods like $cur.'!foo_cursor'() as an example (because the Cursor stuff is almost entirely NQP's version, and apparently NQP doesn't do private methods like P6)  :)

[13:33] <jdv79> ew

[13:36] <ShimmerFairy> m: class Foo { method ::('!bar') { say "HI!" } }; Foo.'!bar'()  # how to accomplish the same in P6 :P

[13:36] <camelia> rakudo-moar 447069: OUTPUT«HI!␤»

[13:38] *** RabidGravy joined
[13:40] *** isBEKaml joined
[13:41] <RabidGravy> boom!

[13:46] *** firstdayonthejob joined
[13:50] <nine> New mission objective: eliminate stash_hash

[13:51] <nine> Those differences between NQP modules and Perl 6 modules cost me far too much time.

[13:54] <dalek> roast: 69d0c5e | lizmat++ | S32-list/head.t:

[13:54] <dalek> roast: Add tests for List.head

[13:54] <dalek> roast: review: https://github.com/perl6/roast/commit/69d0c5e9ae

[13:54] <lizmat> nine++

[13:55] *** firstdayonthejob left
[14:01] <dalek> rakudo/nom: 734b239 | lizmat++ | src/core/Any-iterable-methods.pm:

[14:01] <dalek> rakudo/nom: Fix some issues with List.head/tail

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/734b239676

[14:01] <dalek> rakudo/nom: 0f155be | lizmat++ | t/spectest.data:

[14:01] <dalek> rakudo/nom: Run tests for List.head

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f155bef2f

[14:06] *** diana_olhovik left
[14:11] <masak> computer; messages

[14:11] <yoleaux> 11:58Z <psch> masak: the mathy quote seems like type unification, if anything.  as in, "assume the narrower type given the wider, because of the established context"

[14:11] <yoleaux> 11:59Z <psch> masak: the equivalent would be if 'my Any $x = 5; $x.VAR.of.say' printed (Int)

[14:11] <yoleaux> 12:00Z <psch> masak: as for the other direction, which is the interesting case, what i'd think workable there was a pragma that gave the user a lexical Any+{Numeric}, (or maybe a NumIntRat), which could be thought as subsuming the type, but it would also mean making all of Int, Num, Rat equivalent behind the scenes

[14:11] <yoleaux> 12:01Z <psch> masak: as in, any var declared as Num, Int or Rat actually has a .VAR.of of (IntNumRat) behind the scenes, which is polymorph with exactly those types

[14:11] <yoleaux> 12:02Z <psch> masak: s/has/would have given this pragma/

[14:11] <yoleaux> 12:06Z <psch> masak: actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X]

[14:11] <yoleaux> 12:12Z <psch> masak: actually, i'm wrong about the relationship between c ∈ ℝ and p ∈ ℝ[X], which throws some of my argument out of the window... more thinking :)

[14:11] <masak> yeah.

[14:12] <masak> the more I think about subsumption, the less enthralled I am by the whole notion. :/

[14:20] <psch> oh, yoleaux just says "..." after the 5th...

[14:21] *** skids joined
[14:22] *** khw joined
[14:24] <psch> http://www.ale.cs.toronto.edu/docs/man/ale_trale_man/ale_trale_man-node21.html say the conjectural IntNumRat would be a unified type...

[14:24] <dalek> roast: 35abb70 | lizmat++ | S32-list/head.t:

[14:24] <dalek> roast: Add test for infinite range (lazy list)

[14:24] <dalek> roast: review: https://github.com/perl6/roast/commit/35abb70208

[14:24] <dalek> roast: 6dcad7e | lizmat++ | S32-list/tail.t:

[14:24] <dalek> roast: Add tests for List.tail

[14:24] <dalek> roast: review: https://github.com/perl6/roast/commit/6dcad7ec94

[14:24] <psch> (indirectly, of course :P )

[14:25] <psch> in any case, i don't think that it would make sense on a type level

[14:25] <psch> as in, unifying all the Numeric types is probably the WAT-iest we could do

[14:25] <ShimmerFairy> If this is about the dreaded Inf, then I'm half-expecting we'll "give up" at some point and just make it a special keyword :P

[14:26] <psch> my Int $a = 5; my Rat $b = 7 # both $a and $b would be .VAR.of IntRatNum...

[14:26] *** espadrine joined
[14:27] <psch> ShimmerFairy: no, it's about e.g. Rat $b = 7

[14:27] <psch> ShimmerFairy: although Inf would fall under there as well, potentially

[14:28] *** tokuhirom joined
[14:29] <ShimmerFairy> Hm... well, what if we had  .narrow  and  .widen  methods on the numeric types?  (If it were actually possible, then  multi sub infix:<=>(Rat $a is rw, Int $b) { ... }  would be another choice)

[14:31] <ShimmerFairy> There could also perhaps be some kind of literal form that said "whatever kind of datatype can handle this number", like say my Rat $b = {{{{7}}}}   (finally unquotes aren't the ugliest thing :P)

[14:32] <dalek> rakudo/nom: c539156 | lizmat++ | src/core/Any-iterable-methods.pm:

[14:32] <dalek> rakudo/nom: Fix some fails spotted during test construction

[14:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5391568de

[14:32] <dalek> rakudo/nom: 3f2546e | lizmat++ | t/spectest.data:

[14:32] <dalek> rakudo/nom: Run List.tail tests

[14:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3f2546e419

[14:32] <psch> ShimmerFairy: what's the return type of Rat.narrow, Num or Int?  the first that's possible?

[14:32] *** tokuhirom left
[14:33] *** kanishka joined
[14:34] <psch> hm, if anything that would have to be .widen($target-type) i guess

[14:34] <psch> or .narrow($target-type), even

[14:34] <ShimmerFairy> psch: I imagine it'd be kinda recursive in nature, perhaps  class Complex { method narrow(:$recursing) { self.Real.narrow(:recursing) // ($recursing ?? Complex !! self) } }  at first glance

[14:35] *** softmoth joined
[14:35] <ShimmerFairy> psch: basically, "Complex is narrowed to a Real type and then tries to narrow that (and so on), returning the last successful conversion"

[14:36] <psch> ShimmerFairy: but there are Rats than can only be narrowed to one of Int and Num

[14:37] <psch> ShimmerFairy: so we'd have to branch there, and give up on a linear narrowing path

[14:37] <ShimmerFairy> psch: wouldn't Rat.Num.Int handle the to-Int case? Or is the precision issue non-negligible

[14:37] *** kmel left
[14:39] <ShimmerFairy> psch: my only concrete idea is that each narrow method just narrows down just one step, and then calls the new object's narrow to handle the rest, to avoid reinventing the whole wheel in every class :)

[14:39] *** softmoth left
[14:41] <ShimmerFairy> (though various types could of course short-circuit where it's clearly better than a bunch of nesting calls on likely temporary objects ☺)

[14:41] <masak>  

[14:41] <psch> m: my $rat = ((2**53)+15/1); say $rat.Num.Int; say $rat.Int; 

[14:41] <camelia> rakudo-moar 0f155b: OUTPUT«9007199254741008␤9007199254741007␤»

[14:41] <psch> m: my $rat = ((2**53)+1/1); say $rat.Num.Int; say $rat.Int;  # actual first integer this happens at

[14:41] <camelia> rakudo-moar 0f155b: OUTPUT«9007199254740992␤9007199254740993␤»

[14:42] <psch> ShimmerFairy: so if that goes Rat => Num => Int we lose something

[14:42] <ShimmerFairy> I had a feeling that was the case.

[14:42] <psch> biab &

[14:44] <dalek> doc: 80f4023 | lizmat++ | doc/Type/List.pod:

[14:44] <dalek> doc: Document grep :k,:kv,:p,:v, remove grep-index

[14:44] <dalek> doc: review: https://github.com/perl6/doc/commit/80f40238de

[14:45] *** risou left
[14:54] *** Actualeyes left
[14:58] <dalek> doc: 90ea0cd | lizmat++ | doc/Type/List.pod:

[14:58] <dalek> doc: Document List.first :k,:kv,:p,:end

[14:58] <dalek> doc: 

[14:58] <dalek> doc: And remove documentation for first-index / last-index

[14:58] <dalek> doc: review: https://github.com/perl6/doc/commit/90ea0cda55

[14:59] <dalek> rakudo/curli: 3062530 | (Stefan Seifert)++ | src/ (4 files):

[14:59] <dalek> rakudo/curli: CompUnit::Handle export-sub and export-package

[14:59] <dalek> rakudo/curli: 

[14:59] <dalek> rakudo/curli: We need to handle NQP and Perl 6 modules. So far we have standardized on he low

[14:59] <dalek> rakudo/curli: level way of NQP modules. The new architecture goes in the other direction and

[14:59] <dalek> rakudo/curli: tries to use high level objects as much as possible.

[14:59] <dalek> rakudo/curli: 

[14:59] <dalek> rakudo/curli: Loading the BOOTSTRAP is now done by separate code, since CompUnit::Handle is

[14:59] <dalek> rakudo/curli: not yet available there. But there we don't need most of the features do_import

[14:59] <dalek> rakudo/curli: provides, so code duplication can be kept quite minimal.

[14:59] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/3062530876

[14:59] *** risou joined
[15:00] <lizmat> nine++

[15:02] *** isBEKaml left
[15:03] *** apotheon left
[15:06] <dalek> doc: f0ce101 | lizmat++ | doc/Type/List.pod:

[15:06] <dalek> doc: Provide documentation for List.head/tail

[15:06] <dalek> doc: review: https://github.com/perl6/doc/commit/f0ce1016a5

[15:08] *** kjs_ left
[15:09] *** risou left
[15:11] <RabidGravy> tadzik, sent another PR to fix JSON::Unmarshal for Rat attributes

[15:11] *** perl joined
[15:12] <perl> We need to organise PerlCon just like python community

[15:13] <tadzik> there's tons of YAPCs all around :)

[15:13] <RabidGravy> not to mention, more frequent local workshops

[15:14] <perl> But I did not find hands on course on perl like python on the conference.

[15:15] *** pmurias joined
[15:15] <lizmat> http://www.yapcna.org/yn2015/event/1707   # YAPC::NA this year

[15:17] <lizmat> http://act.perl-workshop.ch/spw2015/event/1739   # SPW this year

[15:19] *** firstdayonthejob joined
[15:21] *** kjs_ joined
[15:25] *** risou joined
[15:29] <nine> How can I iterate over a Perl 6 List in NQP?

[15:31] <FROGGS_> nine: you can call methods as usual

[15:31] *** risou left
[15:32] <nine> So I just do $EXPORTHOW.pairs.map(-> { ... });?

[15:33] <lizmat> nine: fwiw, if you need Perl 6 objects in NQP, feels to me that code should live in Perl 6   :-)

[15:34] <nine> lizmat: one step at a time :) But I admit, you may be onto something there.

[15:41] <perl> far from being general purpose language, is perl 6 planning to be data centric too like python :-)

[15:42] <nine> perl: in which way is Python data centric?

[15:42] *** skids left
[15:43] <perl> nine with the packages like pandas, numpy,scipy, matplotlib, seaborn, bokeh, pytables

[15:44] *** risou joined
[15:44] <TimToady> Perl 6 is planning to be everything-centric.

[15:45] <RabidGravy> perl, that's a narrow, domain specific,  view of  "data-centric"

[15:47] <perl> TimToady My requirements fulfilled if I can read, manipulate, visualise and analyse data with perl 6 in blazing speed. Currently I use R (https://www.r-project.org/).

[15:48] <perl> RabidGravy may be yeah as i data analyst.

[15:48] <TimToady> we plan to do that well, in addition to everything else :)

[15:49] <jdv79> sounds like a pitch in an infomercial ..."and it even does julian fries"

[15:49] <TimToady> .oO(gregorian fries)

[15:50] *** softmoth joined
[15:50] * lizmat imagines monks in boiling fat

[15:51] <nine> lizmat: come on, we haven't had dinner yet :)

[15:52] * lizmat must have been listening to heavy metal too much today  :-)

[15:52] <flussence> @perl: perl6 is planning to be data-centric like perl5, by having the good parts of PDL built in.

[15:54] <flussence> (kinda ironic that python has a dozen different ways to do it but Perl has one clear winner...)

[15:55] <RabidGravy> I'd go a FFT library if anyone gets bored by the way

[15:55] <TimToady> lizmat: Nil is primarily a singleton undef object, not a type, so I don't really want to see parens around it

[15:56] <lizmat> TimToady: ok, then I will revert that and the associated tests

[15:56] <TimToady> thanks

[15:56] <dalek> rakudo/nom: aa2e51f | lizmat++ | src/core/IO/Handle.pm:

[15:56] <dalek> rakudo/nom: Fix infiniloop on IO::Handle.split.elems

[15:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa2e51ff1c

[15:59] <dalek> roast: c051708 | lizmat++ | S0 (4 files):

[15:59] <dalek> roast: Revert "Fix fallout of Nil.gist change"

[15:59] <dalek> roast: 

[15:59] <dalek> roast: This reverts commit 4cfd97480f9c95073fb141c0f7b7b68d4c29c4a1.

[15:59] <dalek> roast: review: https://github.com/perl6/roast/commit/c0517084bb

[16:02] <dalek> roast: e829bdc | lizmat++ | S02-types/WHICH.t:

[16:02] <dalek> roast: Test Nil completely separately

[16:02] <dalek> roast: review: https://github.com/perl6/roast/commit/e829bdc9ef

[16:03] <dalek> doc: 2fc4ce7 | lizmat++ | doc/Type/List.pod:

[16:03] <dalek> doc: Adjust for (Nil) to Nil change

[16:03] <dalek> doc: review: https://github.com/perl6/doc/commit/2fc4ce75d4

[16:04] *** vendethiel joined
[16:06] *** ^elyse^ left
[16:06] <dalek> rakudo/nom: e25a857 | lizmat++ | src/core/Nil.pm:

[16:06] <dalek> rakudo/nom: Re-instate special status of Nil wrt .gist

[16:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e25a8571c0

[16:07] <lizmat> TimToady: I think I've covered all the necessary changes now

[16:07] <TimToady> yeah, Nil has to have a type, so it kind of acts as its own type, but it's really more in the category of True and False

[16:07] *** finanalyst left
[16:08] <lizmat> maybe Nil should be a Bool:U ?

[16:08] <TimToady> maybe not

[16:08] <lizmat> ah, no, that would break too much, I'd think

[16:08] <lizmat> :-)

[16:09] <TimToady> there is nothing else in the language that represents simply the concept of "missing value", which is why we have it

[16:10] <dalek> rakudo/curli: 7441aa3 | (Stefan Seifert)++ | src/ (2 files):

[16:10] <dalek> rakudo/curli: Move some EXPORTHOW handling into CompUnit::Handle

[16:10] <dalek> rakudo/curli: 

[16:10] <dalek> rakudo/curli: CompUnit::Handle is now complete.

[16:10] <dalek> rakudo/curli: Loading the BOOTSTRAP is completely separated from loading normal modules.

[16:10] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/7441aa30c6

[16:11] <lizmat> nine++  # can't be said enough

[16:11] <nine> Ok, back to the "what is the next logical step" problem ;)

[16:15] *** grondilu joined
[16:16] *** grondilu left
[16:16] <dalek> rakudo/curli: 4295edd | (Stefan Seifert)++ | / (4 files):

[16:16] <dalek> rakudo/curli: Add the CompUnit::Repository::Installable role

[16:16] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/4295edd9be

[16:17] *** eliasr left
[16:18] *** cygx joined
[16:18] <cygx> o/

[16:19] <cygx> m: role Foo { say $?CLASS }; class Bar does Foo {}

[16:19] <camelia> rakudo-moar 3f2546: OUTPUT«===SORRY!===␤Cannot find method 'collisions'␤»

[16:19] <ugexe> theoretically should io::socket::async be considered an io::socket?

[16:19] <cygx> what's the proper way to get at the clas a role is mixed into?

[16:19] <cygx> *class

[16:20] <FROGGS_> m: role Foo { say ::?CLASS }; class Bar does Foo {}

[16:20] <camelia> rakudo-moar 3f2546: OUTPUT«===SORRY!===␤Cannot find method 'collisions'␤»

[16:20] <ugexe> m: class Foo { }; role Bar { say $?CLASS; }; my $x = Foo.new but Bar;

[16:20] <camelia> rakudo-moar 3f2546: OUTPUT«(Foo+{Bar})␤»

[16:20] <ugexe> hmm

[16:21] <timotimo> i don't really have enough energy to backlog right now :|

[16:21] <timotimo> but i think my next project will be an awesome error message for this case:

[16:21] <timotimo> m: my Rat $foo = 5;

[16:21] <camelia> rakudo-moar 3f2546: OUTPUT«Type check failed in assignment to $foo; expected Rat but got Int␤  in block <unit> at /tmp/6rLicQmPJR:1␤␤»

[16:22] *** raiph left
[16:22] <nine> timotimo: is the for -> while optimization actually back already?

[16:23] <timotimo> not yet

[16:23] <timotimo> the patch i currently have breaks do for ^10 { $_ } and friends

[16:23] <timotimo> and i'm not sure how to detect we'll want a sunk for loop instead of a non-sunk one

[16:23] <timotimo> do you have an idea for that?

[16:24] <timotimo> until now, we'd been checking against Range.map.sink

[16:24] <timotimo> but the sink has disappeared into the p6for and seems to be unconditional (but it still works?)

[16:24] *** tokuhirom joined
[16:24] <RabidGravy> ugexe, the touchstone would be whether the ::Async is a superset of the socket interface

[16:25] <dalek> roast: 130fb95 | lizmat++ | S16-io/split.t:

[16:25] <dalek> roast: Add tests for IO::Handle.split

[16:25] <dalek> roast: review: https://github.com/perl6/roast/commit/130fb95cee

[16:26] <zostay> is there test file that camelia can read from?

[16:26] <timotimo> camelia will refuse open() straight-out

[16:26] <timotimo> but it has something that gets passed to stdin

[16:27] <zostay> mkay... well, let's see if it works then...

[16:27] <timotimo> m: .lines.say

[16:27] <camelia> rakudo-moar e25a85: OUTPUT«Method 'lines' not found for invocant of class 'Any'␤  in block <unit> at /tmp/fsitPKurU0:1␤␤»

[16:27] <timotimo> er

[16:27] <timotimo> m: lines.say

[16:27] <camelia> rakudo-moar e25a85: OUTPUT«(Céad slán ag sléibhte maorga Chontae Dhún na nGall Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll; Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí I mo dhiaidh bhí gleanntáin ghlas’ Ghaoth…»

[16:28] <TimToady> -1 for unimaginative use of accents

[16:28] * zengargoyle goes ARRGGHH again, minor change and... This Seq has already been iterated, and its values consumed

[16:28] <zostay> m: react { whenever $*STDIN.Supply(:bin) -> $v { $v.chars.say; LAST { say "done" } } }

[16:28] <camelia> rakudo-moar e25a85: OUTPUT«Dynamic variable $*STDIN not found␤  in block <unit> at /tmp/lZwbp1Bd2B:1␤␤»

[16:28] <timotimo> .u combining

[16:28] <yoleaux> U+0300 COMBINING GRAVE ACCENT [Mn] (◌̀)

[16:29] <yoleaux> U+0301 COMBINING ACUTE ACCENT [Mn] (◌́)

[16:29] <yoleaux> U+0302 COMBINING CIRCUMFLEX ACCENT [Mn] (◌̂)

[16:29] <timotimo> m: say lines[0].comb X~ (<\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]>.roll(*)

[16:29] <camelia> rakudo-moar e25a85: OUTPUT«5===SORRY!5=== Error while compiling /tmp/teQJK_jfjy␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/teQJK_jfjy:1␤------> 3\c[COMBINING CIRCUMFLEX ACCENT]>.roll(*)7⏏5<EOL>␤    expecting any of:␤ …»

[16:30] <TimToady> m: say 'o⃝'.chars

[16:30] <camelia> rakudo-moar e25a85: OUTPUT«1␤»

[16:30] <timotimo> m: say lines[0].comb X~ (<\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]>.roll(*))

[16:30] <camelia> rakudo-moar e25a85: OUTPUT«(...)␤»

[16:30] <timotimo> m: .say for lines[0].comb X~ (<\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]>.roll(*))

[16:30] <timotimo> oooh, not x

[16:30] <timotimo> m: .say for lines[0].comb Z~ (<\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]>.roll(*))

[16:30] <timotimo> sorry camelia

[16:30] <camelia> rakudo-moar e25a85: OUTPUT«(timeout)CCIRCUMFLEX␤CACCENT]␤CCIRCUMFLEX␤C\c[COMBINING␤CACCENT]␤CACUTE␤C\c[COMBINING␤CACUTE␤CACCENT]␤CACUTE␤CCIRCUMFLEX␤C\c[COMBINING␤CGRAVE␤C\c[COMBINING␤CCIRCUMFLEX␤CACCENT]␤CACCENT]␤CACCENT]␤CCIRCUMFLEX␤CACCENT]␤…»

[16:30] <camelia> rakudo-moar e25a85: OUTPUT«CCIRCUMFLEX␤éGRAVE␤aACUTE␤d\c[COMBINING␤ ACCENT]␤sCIRCUMFLEX␤l\c[COMBINING␤áACUTE␤n\c[COMBINING␤ \c[COMBINING␤aACUTE␤gGRAVE␤ ACCENT]␤s\c[COMBINING␤lACCENT]␤éACCENT]␤i\c[COMBINING␤b\c[COMBINING␤h\c[COMBINING␤t\c[COMB…»

[16:31] *** tokuhirom left
[16:31] <[Tux]> Ŝȫ ṁṹċḧ ƒüṇ ṡėèĩǹģ ƥėơƥļȇ ƥļăỹɨṋḡ ŵíťḩ Ūȵǐĉȫďe čḫărąƈʈḝṟş ☺

[16:31] <timotimo> m: .say for lines[0].comb Z~ («\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]».roll(*))

[16:31] <camelia> rakudo-moar e25a85: OUTPUT«C̀␤é̀␤à␤d̀␤ ̀␤s̀␤l̀␤á̀␤ǹ␤ ̀␤à␤g̀␤ ̀␤s̀␤l̀␤é̀␤ì␤b̀␤h̀␤t̀␤è␤ ̀␤m̀␤à␤ò␤r̀␤g̀␤à␤ ̀␤C̀␤h̀␤ò␤ǹ␤t̀␤à␤è␤ ̀␤D̀␤h̀␤ú̀␤ǹ␤ ̀␤ǹ␤à␤ ̀…»

[16:31] <timotimo> m: .print for lines[0].comb Z~ («\c[COMBINING GRAVE ACCENT] \c[COMBINING ACUTE ACCENT] \c[COMBINING CIRCUMFLEX ACCENT]».roll(*))

[16:31] <camelia> rakudo-moar e25a85: OUTPUT«C̀é̀àd̀ ̀s̀l̀á̀ǹ ̀àg̀ ̀s̀l̀é̀ìb̀h̀t̀è ̀m̀àòr̀g̀à ̀C̀h̀òǹt̀àè ̀D̀h̀ú̀ǹ ̀ǹà ̀ǹG̀àl̀l̀»

[16:31] <ugexe> RabidGravy: its just missing a recv/read method. that part i did myself but getting OpenSSL to accept it as IO::Socket doesn't work because its loaded first and thus seems to ignore my `my role IO::Socket { }`

[16:33] <zostay> m: react { while my $b = read(10) { $b.bytes.say }; say "done" };

[16:33] <camelia> rakudo-moar e25a85: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lx_0MD7FYf␤Undeclared routine:␤    read used at line 1␤␤»

[16:34] <ugexe> also it would be nice to have a way to get x number of bytes from an async interface, although thats probably some antipattern

[16:34] <dalek> rakudo/nom: a05867b | lizmat++ | t/spectest.data:

[16:34] <dalek> rakudo/nom: Run the IO::Handle.split tests

[16:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a05867b2e9

[16:34] <zostay> ugexe: $handle.Supply(42, :bin) should read 42 bytes at a time async

[16:35] <ugexe> https://gist.github.com/ugexe/71d82eb4bb5653125bd8

[16:35] <ugexe> sockets

[16:35] <dalek> rakudo/curli: 54ed37b | (Stefan Seifert)++ | / (5 files):

[16:35] <dalek> rakudo/curli: CompUnitRepo::Local::File -> CompUnit::Repository::FileSystem

[16:35] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/54ed37b426

[16:35] <cygx> m: https://gist.github.com/cygx/bf35c7a258bbfbe8965d

[16:35] <camelia> rakudo-moar e25a85: OUTPUT«===SORRY!===␤While looking for 'NQP.moarvm': no such file or directory␤»

[16:35] <lizmat> zostay: that would be :size(42)

[16:36] <FROGGS_> cygx: there is no NQP package

[16:36] <FROGGS_> cygx: but a NQPHLL or so

[16:37] <zostay> lizmat: thx

[16:37] *** risou left
[16:38] <cygx> FROGGS_: it works locally

[16:39] <timotimo> nine: i should just put the patch up on a branch so you can have a closer look, eh? gimme a minute

[16:39] * timotimo boots up laptop

[16:40] <dalek> rakudo/optimize_for_again: 61d40a9 | timotimo++ | src/Perl6/Optimizer.nqp:

[16:40] <dalek> rakudo/optimize_for_again: WIP for -> loop; doesn't handle value-returning for yet

[16:40] <dalek> rakudo/optimize_for_again: review: https://github.com/rakudo/rakudo/commit/61d40a9bd1

[16:41] *** avalenn_ joined
[16:42] *** BinGOs joined
[16:42] *** integral joined
[16:43] <ugexe> but im not using a regular socket as a supply, im making an async socket into a sync'd one with a recv

[16:43] <vendethiel> https://github.com/rakudo/rakudo/commit/61d40a9bd1#diff-c6d4338f0fe083856631860c53453281R1060 how does this handles redefined .map?

[16:43] <ugexe> whenever $!socket.bytes-supply.Supply(:size($bytes), :bin) for instance doesn't give me :$size bytes

[16:45] <lizmat> ugexe: bytes-supply is a Supply, not an IO::Handle

[16:46] *** geekosaur joined
[16:47] <dalek> rakudo-star-daily: 2926b0a | coke++ | log/ (9 files):

[16:47] <dalek> rakudo-star-daily: today (automated commit)

[16:47] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/2926b0a14d

[16:47] <dalek> perl6-roast-data: 4147c3f | coke++ | / (9 files):

[16:47] <dalek> perl6-roast-data: today (automated commit)

[16:47] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/4147c3f855

[16:47] <ugexe> right. bytes-supply is to imply its not a regular socket with handle

[16:47] <lizmat> ugexe: I guess we don't have a way to buffer bytes in a Supply chain yet

[16:48] <timotimo> nine: perhaps it's a super simple tweak, but i'm not seeing it yet, and my brane is still clouded from my illness >_<

[16:49] <dalek> roast: 355384b | lizmat++ | S16-io/split.t:

[16:49] <dalek> roast: Add some tests for splitting on ""

[16:49] <dalek> roast: review: https://github.com/perl6/roast/commit/355384b25a

[16:49] <lizmat> ugexe: I guess we want something like Supply.buffer

[16:50] *** raiph joined
[16:50] *** telex left
[16:50] <ugexe> that would be nice

[16:51] <zostay> ugexe: i'm working on something similar right now trying to make a parser that emits HTTP request frames from an HTTP socket, but i'm having trouble receiving done when the socket closes/test file ends

[16:52] <ugexe> zostay: the gist above closes the socket when its done. with openssl it also requires only reading 1 byte at a time

[16:52] *** telex joined
[16:54] <timotimo> https://twitter.com/BobRossGameDev - this is pretty good

[16:54] *** perl left
[16:54] <timotimo> "Don’t forget to comment your code. It’s important to let imagination guide you, but the comments are there to help you find your way home."

[16:55] *** risou joined
[16:55] <zostay> well regardless of number of bytes read, my program is halting in the react block for some reason

[16:55] *** kjs_ left
[16:55] *** pmurias left
[16:56] <zostay> s/halting/hanging/

[16:56] <ugexe> i had that problem too, i had to add an extra done() outside the whenever with the size comparison

[16:58] <timotimo> oooh! perl6.org now has letsencrypt! sweet!

[16:59] <timotimo> moritz++

[16:59] <zostay> interesting... my Supply should be emitting done, i'm trying to catch it with a LAST { } block, but it never does execute the code just before my Supply calls done never seems to be reached

[16:59] <zostay> it's not a an exception either, afaict, i'm trying to catch and print anything but getting nothing so far

[17:01] <leont> async is hard to get to work properly :-/

[17:01] <ugexe> m: my $s = (1,2,3,4).Supply; $s.tap: {.say; LAST { say "DONE"; }; }; $s.done

[17:01] <camelia> rakudo-moar a05867: OUTPUT«1␤2␤3␤4␤»

[17:02] <lizmat> ugexe: I don't think that's supposed to work like that

[17:03] <lizmat> m: my $s = (1,2,3,4).Supply; $s.tap: {.say }, :done({ say "DONE" }) }; $s.done

[17:03] <camelia> rakudo-moar a05867: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jJoXluT9Qr␤Unexpected closing bracket␤at /tmp/jJoXluT9Qr:1␤------> 3 $s.tap: {.say }, :done({ say "DONE" }) 7⏏5}; $s.done␤»

[17:03] <lizmat> m: my $s = (1,2,3,4).Supply; $s.tap: {.say }, :done({ say "DONE" }); $s.done

[17:03] <camelia> rakudo-moar a05867: OUTPUT«1␤2␤3␤4␤DONE␤DONE␤»

[17:03] <ugexe> i dont neccesarily think so either, its just narrowing the scope of zostay's problem

[17:03] <lizmat> intresting

[17:03] <zostay> right, you don't have to emit the extra done, Supply.from-list does that alreay

[17:04] <zostay> it feels like my issue is specifically related to I/O, but i could be wrong about that

[17:04] <zostay> i don't know why it would be, just that it feels like it

[17:05] <zostay> but i'm learning lots about it in the meantime ;)

[17:05] <zostay> "Experience is that which you get when you don't get what you want."

[17:05] <timotimo> what if you want to get experience?

[17:06] <RabidGravy> take a bunch of acid and try and debug php cde

[17:07] <timotimo> someone ported CDE to php?

[17:07] <RabidGravy> the crap desktop environment

[17:07] <leont> zostay: given that IME experience Proc::Async is also buggy around done()s, I'm not surprised

[17:07] <dalek> doc: b852f37 | lizmat++ | doc/Type/IO/Handle.pod:

[17:07] <dalek> doc: Add minimal explanation about IO::Handle.split

[17:07] <dalek> doc: review: https://github.com/perl6/doc/commit/b852f37b38

[17:08] <leont> Though the issue I'm hitting there is very different

[17:09] <zostay> nah, i'm doing something wrong... just wrote a super simple program and it all worked fine... i'll find it ;)

[17:09] <zostay> perl6 -e 'my $h = "t/data/http-1.0-dumb.txt".IO.open(:r); my $s = supply { while my $buf = $h.read(100) { emit($buf); }; done }; react { whenever $s { .bytes.say; LAST { say "DONE" } } }'

[17:10] <zostay> that program works exactly as expected, so something about my parsing layer must be bugging it up

[17:12] <TimToady> psch: btw, we already have a .narrow method

[17:12] <TimToady> m: say 4.2.narrow.WHAT

[17:12] <camelia> rakudo-moar a05867: OUTPUT«(Rat)␤»

[17:12] <TimToady> m: say 4.0.narrow.WHAT

[17:12] <camelia> rakudo-moar a05867: OUTPUT«(Int)␤»

[17:13] <TimToady> m: say <1+0i>.narrow.WHAT

[17:13] <camelia> rakudo-moar a05867: OUTPUT«(Int)␤»

[17:15] <AlexDaniel> TimToady: any news on qx issue? :)

[17:16] * TimToady thinks qx// should default to run semantics (that is, it should split words before running), and is still trying to decide whether it's okay to have a corresponding qx routine that means what you mean by runout

[17:17] *** Taller1 joined
[17:17] <TimToady> even though it's not really a quote

[17:18] <TimToady> or we could use something different like sys()

[17:18] <AlexDaniel> TimToady: if it's not, then why have it?

[17:19] <TimToady> to have a non-ugly name for runout

[17:19] * zengargoyle has discovered %hash{Any} doesn't do what i thought it did

[17:20] <lizmat> zengargoyle: what did you think it should do ?

[17:20] <TimToady> from the user point of view, they just want to call something in the system and get its results, like a function call

[17:20] <TimToady> all this IO rigamarole is just clutter to such a user

[17:20] <AlexDaniel> TimToady: yes!

[17:21] <dalek> rakudo/nom: 078d0be | lizmat++ | src/core/IO/Handle.pm:

[17:21] <dalek> rakudo/nom: Fix IO::Handle.comb("x") thinko

[17:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/078d0bec80

[17:22] <zengargoyle> m: my %i{Any}; my $x = (1,2,3); my $y = (1,2,3); %i{$x} = $x; say %i{$y};

[17:22] <camelia> rakudo-moar a05867: OUTPUT«(Any)␤»

[17:23] <zengargoyle> like use eqv for lookup

[17:23] <lizmat> m: say (1,2,3).WHICH, (1,2,3).WHICH    # the reason

[17:23] <camelia> rakudo-moar a05867: OUTPUT«List|71203312List|71203368␤»

[17:23] <zengargoyle> yeah, i sorta grokked that

[17:23] <lizmat> my %i{Any}; my $x = set(1,2,3); my $y = set(1,2,3); %i{$x} = $x; say %i{$y};

[17:24] <lizmat> m: my %i{Any}; my $x = set(1,2,3); my $y = set(1,2,3); %i{$x} = $x; say %i{$y};

[17:24] <camelia> rakudo-moar a05867: OUTPUT«set(3, 1, 2)␤»

[17:24] <AlexDaniel> I think that I don't mind if it is called differently. Although I kinda liked the way runout can be switched to run when you start needing IO stuff (and same with shellout/shell)

[17:24] <zengargoyle> (1,2,3) is more point-like in this case

[17:25] <AlexDaniel> TimToady: but if qx// should default to run semantics, I don't really understand how could perl6 split it into separate arguments

[17:25] <AlexDaniel> like, once you've put it into one string, it is pretty hard to untangle it back

[17:26] <AlexDaniel> and solve it by using quotes, but in reality it only adds more pitfalls…

[17:26] <AlexDaniel> shells solve it*

[17:27] *** TimToady left
[17:27] <zengargoyle> and in the end ~$x as the key is probably as good as any other uniqification, just feels icky to go from List to Str to List

[17:27] <zostay> it is a hash, you can always define your own Map with a different key lookup

[17:28] <zostay> hash kind of implies linearization of the keys so you can bucket them

[17:28] <zengargoyle> yeah

[17:28] *** kanishka left
[17:29] *** TimToady joined
[17:31] <TimToady> use program <ls>; my $x = ls('-l');  # another approach

[17:31] <AlexDaniel> that's kinda interesting

[17:31] <AlexDaniel> but you still have to separate your arguments somehow

[17:33] <zostay> ls(<-l -a /tmp/*>);

[17:33] * AlexDaniel was going to suggest rout and sout, but then figured that “rout” is a bad idea as well…

[17:33] <AlexDaniel> ruout, shout?…

[17:33] <TimToady> no "out"

[17:33] <TimToady> it's just a "return value"

[17:34] <TimToady> I was thinking qx// form would imply « » parsing

[17:35] *** Alina-malina left
[17:35] <AlexDaniel> TimToady: yeah, but it breaks if you forget quotes. Although it is pretty “shelly”, I was hoping that there's a way to avoid it

[17:36] <TimToady> well, shell breaks if you forget quotes too, but the stakes are higher

[17:36] <AlexDaniel> in that sense “run” is perfect. Either you put commas or it will not compile

[17:37] <AlexDaniel> and if you don't want to put commas, OK, there's « »

[17:37] <TimToady> well, and qr// is just run(« », :out)

[17:37] <TimToady> er, qx

[17:38] * TimToady though qr// would be nice assocition with run, till he remembered that P5 has a completely different qr that would be confusing

[17:39] <TimToady> *ciation

[17:39] <AlexDaniel> TimToady: uhm, yeah, but nobody in their sane mind will type that :out).out.slurp-rest thing…

[17:39] <TimToady> *thought

[17:39] <TimToady> gah

[17:40] <TimToady> anyway, we want to optimize for the common case here, and getting the output of a command is one of the easy things that should be easy, not just one of the hard things that should be possible

[17:40] * AlexDaniel nods

[17:40] <TimToady> so I think a qr that is relatively safe but mostly dwims is a good compromise

[17:40] <TimToady> gah, qx

[17:41] <[Coke]> r: sub foo($a) { sub bar {} }; my $a=foo(1);

[17:41] <camelia> rakudo-moar a05867: ( no output )

[17:41] <camelia> ..rakudo-jvm a05867: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/tmpfile:1␤␤»

[17:42] <lizmat> [Coke]: that is a known issue, several places in the core work around that

[17:42] <lizmat> r: sub foo($a) { my $ = sub bar {} }; my $a=foo(1);

[17:42] <camelia> rakudo-{moar,jvm} a05867: ( no output )

[17:42] <lizmat> [Coke]  ^^^

[17:42] <lizmat> it needs a container on JVM somehwo

[17:43] *** Alina-malina joined
[17:49] <AlexDaniel> TimToady: but I'm thinking, what if you want to do something beyond that? Like, ok, here you have some code that runs a command and gets its output, great. Now you just want to specify the input, and boom, the whole thing just balloons more that you'd expect it to. That's ok in other languages, but perl always felt very concise to me, I'm not sure if I will like to see it other way in this case.

[17:50] <AlexDaniel> but qx// that does run(«…», :out).out.slurp-rest is great until you need something more advanced, yes.

[17:52] <zengargoyle> heh $input ==> qx/.../ ==> $output ?

[17:52] *** pmurias joined
[17:52] <AlexDaniel> zengargoyle: that's actually an interesting idea

[17:52] <TimToady> that's another possibility

[17:53] * zengargoyle is the ==> thing real?  i've never actually tried to use it or know how to. :P

[17:53] <TimToady> maybe for the line-oriented output

[17:53] <[Coke]> lizmat: there's code in roast that expects it to work, so the work around needs to be fixed.

[17:53] *** protium left
[17:53] <AlexDaniel> zengargoyle: yeah, in fact <== is there too :)

[17:54] <AlexDaniel> $input ==> qx/…/ ==> grep /…/ ==> map … ==> qx/…/ …

[17:54] <AlexDaniel> hmmm

[17:54] <lizmat> [Coke]: totally agree, but my JVM foo is very limited

[17:55] <lizmat> [Coke]: not sure if there's a ticket for it

[17:55] <dalek> rakudo/curli: 22f7412 | (Stefan Seifert)++ | / (5 files):

[17:55] <dalek> rakudo/curli: CompUnitRepo::Local::Installation -> CompUnit::Repository::Installation

[17:55] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/22f7412262

[17:57] *** Taller1 is now known as Taller2

[17:57] *** Taller2 is now known as Taller1

[17:58] <dalek> roast: e80cb40 | coke++ | S02-magicals/sub.t:

[17:58] <dalek> roast: use new ticket ID (RT #126517), fudge more

[17:58] <dalek> roast: review: https://github.com/perl6/roast/commit/e80cb4067e

[17:58] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126517

[17:59] <[Coke]> lizmat: ^^

[18:00] *** Alina-malina left
[18:01] <[Coke]> r: my $foo =  [42 ]; $foo[1] = $foo; say $foo.perl;

[18:01] <camelia> rakudo-moar 078d0b: OUTPUT«(my \Array_140697060236336 = $[42, Array_140697060236336])␤»

[18:01] <camelia> ..rakudo-jvm 078d0b: OUTPUT«(my \Array_229292020 = $[42, Array_229292020])␤»

[18:02] <[Coke]> r: my $foo =  [42 ]; $foo[1] = $foo; say $foo.perl; say $foo.perl.EVAL

[18:02] <camelia> rakudo-jvm 078d0b: OUTPUT«(my \Array_897186540 = $[42, Array_897186540])␤java.lang.NullPointerException␤  in block <unit> at EVAL_0:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[18:02] <camelia> ..rakudo-moar 078d0b: OUTPUT«(my \Array_140538609984720 = $[42, Array_140538609984720])␤[42 (Mu)]␤»

[18:02] *** Alina-malina joined
[18:03] <lizmat> [Coke]++

[18:03] <lizmat> brb

[18:04] *** vendethiel left
[18:04] *** vendethiel joined
[18:05] <dalek> roast: 0dc483b | coke++ | S02-names-vars/list_array_perl.t:

[18:05] <dalek> roast: Fudge for RT #126518

[18:05] <dalek> roast: review: https://github.com/perl6/roast/commit/0dc483b57e

[18:05] <synbot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126518

[18:08] *** dwarring joined
[18:08] <pmurias> konobi: ping

[18:09] <dalek> roast: 5116515 | coke++ | S02-names-vars/names.t:

[18:09] <dalek> roast: Reopen and fudge for JVM, dying there.

[18:09] <dalek> roast: review: https://github.com/perl6/roast/commit/5116515788

[18:10] <zostay> yep, tracked down my react block issues

[18:10] <zostay> i was trying to execute two whenever blocks concurrently, but react {} ensures all the whenevers within run on a single thread

[18:12] *** kjs_ joined
[18:17] *** espadrine left
[18:17] <lizmat> off to see a spectre of bond&

[18:19] <zostay> start { } block to the rescue... \o/

[18:21] <timotimo> zostay: why don't you just use supply instead of react?

[18:21] *** kjs_ left
[18:22] <timotimo> then you can await both supplies to finish afterwards

[18:23] <dalek> rakudo/curli: 24af750 | (Stefan Seifert)++ | src/core/CompUnit (3 files):

[18:23] <dalek> rakudo/curli: Move loading a module from a file name to Repository::FileSystem

[18:23] <dalek> rakudo/curli: 

[18:23] <dalek> rakudo/curli: This moves the first code out of the candidates method and out of

[18:23] <dalek> rakudo/curli: CompUnitRepo::Locally for better separation between loading from a given

[18:23] <dalek> rakudo/curli: path and loading a DependencySpecification.

[18:23] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/24af75083c

[18:26] <dalek> rakudo/nom: 6abf2bf | TimToady++ | src/ (2 files):

[18:26] <dalek> rakudo/nom: handle autogen of inequalities better

[18:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6abf2bf624

[18:26] <dalek> roast: d62254b | TimToady++ | S03-operators/equality.t:

[18:26] <dalek> roast: test all variants of == and != for 0 and 1-ary

[18:26] <dalek> roast: review: https://github.com/perl6/roast/commit/d62254b57a

[18:27] *** tokuhirom joined
[18:28] <psch> TimToady: why is &-less form for autogen'd operators legal, but not for declared ones?

[18:28] <TimToady> example?

[18:29] <psch> m: say infix:<+>(1, 2)

[18:29] <camelia> rakudo-moar 078d0b: OUTPUT«3␤»

[18:29] <psch> huh

[18:29] <psch> well well

[18:29] <psch> what did i do wrong then earlier

[18:29] <psch> ah, nevermind, it probably was not-an-infix then

[18:30] <psch> yeah, i did a stupid earlier today and remember that just now

[18:30] <psch> so, yeah, nevermind

[18:30] * TimToady is not good at minding at the best of times

[18:31] *** tokuhirom left
[18:34] <TimToady> lunch, then halloween decor &

[18:37] *** softmoth left
[18:40] <zostay> timotimo: in this case, i'm chaining the supplies react <- supply <- supply... and it was hanging on the emit of the innermost supply/on the emit of the out supply/whenever of the react while it waited for the innermost to contine processing/emitting input read from a socket/file

[18:40] *** Alina-malina left
[18:41] <zostay> in this case, i just need to restructure the chaining so that it doesn't require a separate thread

[18:41] <dalek> rakudo/curli: b372417 | (Stefan Seifert)++ | src/core/CompUnit (4 files):

[18:41] <dalek> rakudo/curli: Rename $!IO to $.prefix in CompUnitRepo::Locally

[18:41] <dalek> rakudo/curli: 

[18:41] <dalek> rakudo/curli: "prefix" is more descriptive, since in the case of Repository::Installation

[18:41] <dalek> rakudo/curli: there will be quite a few sub directories in there.

[18:41] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/b372417e49

[18:41] *** Alina-malina joined
[18:44] *** nowan joined
[18:45] *** cygx left
[18:45] *** nowan left
[18:46] *** nowan joined
[18:46] <dalek> doc: c22caba | (Lloyd Fournier)++ | doc/Type/PairMap.pod:

[18:46] <dalek> doc: remove PairMap for now

[18:46] <dalek> doc: 

[18:46] <dalek> doc: It's been removed from Rakudo for a while

[18:46] <dalek> doc: review: https://github.com/perl6/doc/commit/c22caba4eb

[18:46] <dalek> doc: 6b64034 | moritz++ | doc/Type/PairMap.pod:

[18:46] <dalek> doc: Merge pull request #182 from LLFourn/master

[18:46] <dalek> doc: 

[18:46] <dalek> doc: remove PairMap for now

[18:46] <dalek> doc: review: https://github.com/perl6/doc/commit/6b64034d90

[18:48] <timotimo> zostay: oh my

[18:52] *** cygx joined
[18:53] <dalek> roast: caa5704 | coke++ | S02-names-vars/perl.t:

[18:53] <dalek> roast: These all pass on rakudo-moar

[18:53] <dalek> roast: 

[18:53] <dalek> roast: Remove an old questionable test

[18:53] <dalek> roast: review: https://github.com/perl6/roast/commit/caa5704e02

[18:55] <dalek> rakudo/curli: fe2f9eb | (Stefan Seifert)++ | src/core/CompUnit (2 files):

[18:55] <dalek> rakudo/curli: Migrate Repository::Installation::candidates code into need

[18:55] <dalek> rakudo/curli: review: https://github.com/rakudo/rakudo/commit/fe2f9eb350

[18:57] *** cygx left
[18:57] *** cygx joined
[18:59] *** Alina-malina left
[19:00] *** jsimonet joined
[19:01] *** tokuhirom_h joined
[19:02] *** raiph left
[19:02] <konobi> pmurias: howdy

[19:02] *** cygx left
[19:02] <dalek> roast: 5d96b33 | coke++ | S02-names-vars/perl.t:

[19:02] <dalek> roast: skip, use related RT#

[19:02] <dalek> roast: review: https://github.com/perl6/roast/commit/5d96b33e44

[19:04] <konobi> pmurias: so... stick all the JS files in a "lib" directory... you can just use `require('./foo')` to access them

[19:06] *** tokuhirom_h left
[19:06] <[Coke]> r: use Test; throws-like 'my int $a is default(42)', X::Comp::Trait::NotOnNative,type    => 'is',subtype => 'default';

[19:06] <camelia> rakudo-moar 6abf2b: OUTPUT«    1..4␤    ok 1 - 'my int $a is default(42)' died␤    ok 2 - right exception type (X::Comp::Trait::NotOnNative)␤    ok 3 - .subtype matches default␤    ok 4 - .type matches is␤ok 1 - did we throws-like X::Comp::Trait::NotOnNative?␤»

[19:06] <camelia> ..rakudo-jvm 6abf2b: OUTPUT«    1..4␤    not ok 1 - 'my int $a is default(42)' died␤    ␤# Failed test ''my int $a is default(42)' died'␤# at /tmp/tmpfile line 1␤    ok 2 - # SKIP Code did not die, can not check exception␤    ok 3 - # SKIP Code did not die, can not check e…»

[19:07] *** cygx joined
[19:09] <dalek> roast: a7cd851 | coke++ | S02-names/is_default.t:

[19:09] <dalek> roast: fudge for rakudo.jvm

[19:09] <dalek> roast: review: https://github.com/perl6/roast/commit/a7cd851074

[19:19] *** cygx left
[19:26] <timotimo> i'm not sure how to figure out how exactly a variable is declared from inside the optimizer :\

[19:27] *** raiph joined
[19:31] <timotimo> with twitch's delay between chat and video, it'll be very problematic to actually succeed

[19:31] <timotimo> er, ww

[19:31] <timotimo> (this is about "twitch installs archlinux")

[19:31] <timotimo> (which will start in about 30 minutes)

[19:34] *** cygx joined
[19:34] *** Alina-malina joined
[19:35] *** cygx left
[19:39] <timotimo> ah, it's just in the block's "symbol" thing

[19:41] *** vendethiel left
[19:45] *** ChoHag left
[19:46] *** nowan left
[19:47] *** yqt joined
[19:53] *** nowan joined
[19:54] *** vendethiel joined
[19:54] <RabidGravy> tadzik,  I rebased those two other PRs into https://github.com/tadzik/JSON-Unmarshal/pull/9 and closed them.  With those the https://github.com/jonathanstowe/JSON-Class/blob/master/t/030-roundtrip.t passes :)

[20:04] *** kjs_ joined
[20:11] <nine> timotimo: I'll probably have a look at optimize_for_again tomorrow

[20:12] <vendethiel> timotimo: off we go! 'tis gonna be a fun install :)

[20:13] <psch> .tell jnthn checking $cur_candidate<rwness> in Routine.analyze_dispatch seems to fail the parameter binding too early to still throw Parameter::RW, so i'm not sure where this check should happen

[20:13] <yoleaux> psch: I'll pass your message to jnthn.

[20:15] <timotimo> vendethiel: except the screen is black

[20:15] <vendethiel> :[

[20:15] <timotimo> actually, it just shows the "stream is offline" picture

[20:20] *** BenGoldberg joined
[20:23] *** Alina-malina left
[20:25] *** mr_ron joined
[20:28] *** kjs_ left
[20:29] <pmurias> konobi: hi

[20:30] *** darutoko left
[20:34] *** Alina-malina joined
[20:34] <pmurias> konobi: if I want to run the .js file a .p6 file is compiled to how should I require it's dependencies?

[20:35] *** mr_ron left
[20:38] <konobi> from within the js file

[20:39] <pmurias> you mean I should to my own resolving and then just load th js file with an absolute path?

[20:39] <konobi> well, your dependencies should still work the same way

[20:40] <pmurias> same as other rakudo backends to them?

[20:41] *** rindolf left
[20:41] <konobi> you can require nqp-js

[20:42] <pmurias> and for something like NQPCORE.setting I should call require("nqp-js/NQPCORE.setting")?

[20:43] <konobi> no

[20:43] <konobi> you probably want it to be a property of the module exports

[20:44] <konobi> var nqpjs = require('nqp-js'); console.log(nqpjs.NQPCORE.setting

[20:46] <konobi> so that'll probably want to exist in lib/index.js

[20:47] <pmurias> you mean require('nqp-js') should always load the NQPCORE.setting?

[20:48] <pmurias> or I should do require(nqpjs["NQPCORE.setting"])

[20:50] <pmurias> konobi: and what about a user defined modules. like if someone does a 'use Foo'

[20:51] <pmurias> I could mangle the module names by turning that into require('nqp-js-Foo')

[20:51] <konobi> within nqp-js you'll require those NQPCORE style things and addthem to module.exports

[20:54] <pmurias> konobi: I can't do that with user written modules

[20:55] <konobi> sure, but that's seperate to how nqp-js is used

[20:56] <pmurias> not really, you can use your own custom setting

[20:57] <konobi> mmm...

[20:57] <konobi> well, i suppose that's DI with a known default

[20:58] <pmurias> DI = dependency injection?

[20:58] <konobi> yup

[20:59] <konobi> `var njs = require('nqp-js'); var foo = new njs({ setting: ... });`

[21:01] <pmurias> so if I want to use the MyCustomSetting where should it be searched for?

[21:01] <konobi> well, it's going to be generated along with the initial script, right?

[21:02] <pmurias> as a harcoded absolute path?

[21:02] <konobi> relative

[21:03] *** ChoHag joined
[21:03] <konobi> require('./modules/MyCustomSetting')

[21:04] <konobi> pmurias: are you hoping generate the p6 script as a package?

[21:05] <konobi> (with nqp-js itself being a dependency for that package?)

[21:05] <pmurias> konobi: not sure yet

[21:06] <pmurias> currently I'm considering two options: either try to integrate with npm or just do the path resolution myself and pass an absolute path to require

[21:06] <konobi> pmurias: how require works is pretty simple

[21:07] <konobi> pmurias: https://nodejs.org/api/modules.html explains it all

[21:09] <pmurias> konobi: I have seen it

[21:11] <pmurias> what I'm not sure about is how making Perl 6 modules interact with other hand written javascript code should look like

[21:11] <pmurias> should I aim towards generating packages usable by npm

[21:12] <konobi> I think so

[21:12] <konobi> that way you could have perl6 modules as dependencies

[21:13] <vendethiel> you don't think everything should go through 6pan?

[21:13] <konobi> this is for the js backend

[21:13] <vendethiel> I know

[21:14] <konobi> pmurias: and from there... you can browserify the packages to use it in browser space

[21:15] <vendethiel> i.e. scalajs only uses sbt

[21:15] <vendethiel> well, it uses webjars as well..

[21:15] <pmurias> konobi: I used webpack before as browserify seems to suck and insisted on parsing the generated javascript files

[21:15] <RabidGravy> if it's going to run on node it should be packaged for npm, the poor dears wuldn't be able to install it otherwise ;-)

[21:16] <konobi> yeah, either of those should be fine

[21:16] <vendethiel> yeah, browserify does parse the js files

[21:16] <Hotkeys> alrighty

[21:16] <Hotkeys> put some swap on my vps

[21:16] <konobi> yeah, it needs to so that can bundle in the right core module interfaces

[21:16] *** Gardner left
[21:16] <Hotkeys> lets see if I can build now

[21:17] <Hotkeys> oh dang

[21:17] <Hotkeys> rip those 4

[21:18] <RabidGravy> :-\

[21:19] <pmurias> vendethiel: doesn't 6pan not exist yet?

[21:21] *** Gardner joined
[21:21] *** hobbs joined
[21:21] <pmurias> vendethiel: one option would be to avoid using the npm at all

[21:22] *** dylanwh_ joined
[21:22] <RabidGravy> zombies!

[21:25] <pmurias> vendethiel: the other option would be to try to make 6pan modules installable using npm

[21:25] <konobi> pmurias: yeah... thankfully the node package model is well known now and can be used in a bunch of places

[21:27] <pmurias> where besides the browser/node.js? just asking so I can tell my friends how nqp-js/rakudo-js will be useful

[21:28] <konobi> there's many apps that have the ability to extend their functionality using javascript... atom, komodo, even Photoshop

[21:29] <konobi> also things like cordova for use on cell phones

[21:29] <RabidGravy> CouchDB query engine

[21:29] <konobi> postgres

[21:30] <dalek> rakudo/nom: fc8bda9 | lizmat++ | src/core/IO/Handle.pm:

[21:30] <dalek> rakudo/nom: Fix IO::Handle.comb thinko

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc8bda90a5

[21:31] *** kaare_ left
[21:34] <konobi> pmurias: and don't forget minecraft!

[21:34] *** cygx joined
[21:36] <cygx> m: https://gist.github.com/cygx/29dab71ed8f046511750

[21:36] <camelia> rakudo-moar 6abf2b: OUTPUT«42␤»

[21:36] <pmurias> konobi: having Perl 6 run in minecraft sounds like something for a really cool (lighting) talk

[21:37] *** TEttinger joined
[21:37] <cygx> not sure if that works by design, coincidence or a combination of both

[21:37] <konobi> yeah, there's a server plugin called scriptcraft

[21:41] <uruwi> Why is .roll slow?

[21:41] <pmurias> konobi: when packaging a Rakudo/NQP module does adding a p6- prefix seem sane?

[21:41] <dalek> roast: 25f283f | lizmat++ | S16-io/comb.t:

[21:41] <dalek> roast: Add tests for IO::Handle.comb

[21:41] <dalek> roast: review: https://github.com/perl6/roast/commit/25f283feef

[21:42] <lizmat> uruwi: .roll on what ?

[21:42] <uruwi> An array

[21:42] <konobi> pmurias: yup, i'd think so

[21:42] <pmurias> so Foo will be installed in node_modules as p6-Foo

[21:42] <lizmat> uruwi: just .roll without params ?

[21:42] <uruwi> Yes

[21:42] <uruwi> A few minutes

[21:43] <lizmat> what?

[21:43] <TimToady> is it an infinite array?

[21:43] <pmurias> konobi: is everything assumed to be part of a package in node.js land?

[21:43] <uruwi> Oh, I was using $things.roll, not @things.roll

[21:43] <lizmat> it should fail with X::Cannot::Lazy on anything lazy

[21:43] <uruwi> Never mind

[21:44] <konobi> pmurias: how do you mean?

[21:44] <uruwi> Or, I'd rather say, ab5tract was doing that

[21:44] <lizmat> .oO( Emily Litella lives )

[21:45] <konobi> pmurias: like tests, scripts, etc?

[21:46] <uruwi> ab5tract_ *

[21:46] <uruwi> Follow this one weird trick to improve performance!

[21:47] *** kjs_ joined
[21:48] <pmurias> konobi: yes

[21:49] <pmurias> konobi: tests naturally seem to be a part of the package

[21:49] <pmurias> konobi: but how are scripts with dependencies handled?

[21:50] <konobi> you can add a scripts directory to the package.json

[21:51] <konobi> then you can use `npm run ...` to execute the script

[21:51] <konobi> but yeah, usually just in a scripts or bin folder

[21:53] <pmurias> I'm not sure how make js-test should work

[21:53] <konobi> you can configure `npm test`

[21:53] <konobi> thankfully we have tap

[21:55] *** kjs_ left
[21:57] <pmurias> the problem is that we will have the setting turned into a "node.js package", then ./nqp-js --target=js foo.t will spit out js from the test file

[21:57] <pmurias> how is the the compiled test file supposed to know where do load the setting/runtime from?

[21:58] <konobi> using require()

[21:58] <pmurias> should I generate a test suit package that depends on the runtime and the compiled-setting-package?

[21:59] <konobi> nah, i think it should just load from the lib dir

[22:00] <dalek> rakudo/nom: 79efbb1 | lizmat++ | t/spectest.data:

[22:00] <dalek> rakudo/nom: Run the IO::Handle.comb tests

[22:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/79efbb1dac

[22:02] <pmurias> konobi: by making ./nqp-js emit the tests with a special path?

[22:03] *** rarara_ joined
[22:03] <rarara_> m: my $a=(1,2,3); my $b=(4,5,6); $a=($a,); say $a; $a=($b,); say $a;

[22:03] <camelia> rakudo-moar fc8bda: OUTPUT«(\List_139899985755472 = (List_139899985755472))␤((4 5 6))␤»

[22:03] <konobi> pmurias: mmm... not sure. maybe it's best to take baby steps... perhaps a solution will make itself apparent

[22:04] <rarara_> m: my $a=(1,2,3); my $b=(4,5,6); $a=($a,); say $a; $a=($b,); say $a; $b=($a,); $a=$b; say $a;

[22:04] <camelia> rakudo-moar fc8bda: OUTPUT«(\List_140565209029464 = (List_140565209029464))␤((4 5 6))␤(\List_140565209184944 = (List_140565209184944))␤»

[22:04] <dalek> doc: 19a8c52 | lizmat++ | doc/Type/IO/Handle.pod:

[22:04] <dalek> doc: Add minimal explanation about IO::Handle.comb

[22:04] <dalek> doc: review: https://github.com/perl6/doc/commit/19a8c52406

[22:04] <rarara_> m: my $a=(1,2,3); my $b=(4,5,6); $a=($a,); say $a; $a=($b,); say $a; $a=$b; say $a;

[22:04] <camelia> rakudo-moar fc8bda: OUTPUT«(\List_140640873540360 = (List_140640873540360))␤((4 5 6))␤(4 5 6)␤»

[22:04] <rarara_> m: my $a=(1,2,3); my $b=(4,5,6); $a=($a,); say $a; $a=($b,); say $a; $a=($b,); say $a;

[22:04] <camelia> rakudo-moar fc8bda: OUTPUT«(\List_140725917427328 = (List_140725917427328))␤((4 5 6))␤((4 5 6))␤»

[22:05] <vendethiel> pmurias: http://www.webjars.org/ is what's using in sbt

[22:05] <vendethiel> (for scalajs)

[22:06] *** Oatmeal left
[22:06] <timotimo> (for science)

[22:06] <pmurias> vendethiel: have you used it?

[22:06] <vendethiel> pmurias: yeah

[22:06] <cygx> FOR PONY!

[22:07] <vendethiel> I mean, never uploaded to it, but i've used scalajs extensively, and I've never had any problems with it. But 've not actually packaged any module.

[22:08] <konobi> npm seems a lot simplier to me

[22:10] <dalek> roast: 109f31f | coke++ | S02-names/pseudo.t:

[22:10] <dalek> roast: refudge for rakudo, open RTs

[22:10] <dalek> roast: review: https://github.com/perl6/roast/commit/109f31fdeb

[22:10] <BenGoldberg> rarara_, Are you expecting perl to be confused by self-referential data structures? :)

[22:11] <cygx> stage parse for CORE.setting seems to have doubled - is that a fluke on my machine or does anyone else see that?

[22:12] <[Coke]> cygx: doubled since when?

[22:12] *** Oatmeal joined
[22:12] <[Coke]> BenGoldberg: like https://rt.perl.org/Ticket/Display.html?id=126518 ? :(

[22:13] <rarara_> BenGoldberg I had to play with this thing while I was trying to get a list as a single element of a list

[22:14] <dalek> rakudo/nom: 4c1f09d | lizmat++ | src/core/IO/Handle.pm:

[22:14] <dalek> rakudo/nom: Make IO::Handle.readchars a full fledged method

[22:14] <dalek> rakudo/nom: 

[22:14] <dalek> rakudo/nom: All part of a cunning plan  :-)

[22:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4c1f09d08b

[22:16] <pmurias> vendethiel: I should propably checkout some other languages that compile to js to steal ideas

[22:16] <RabidGravy> cygx, the size has crept up somewhat but not doubled

[22:16] <vendethiel> pmurias: yeah, stealing good ideas is always good

[22:16] <pmurias> vendethiel: anything other than scalajs that I should check out?

[22:17] <vendethiel> for the module system part, or for the alt-js in general?

[22:17] <pmurias> alt-js

[22:17] <timotimo> whoa

[22:17] <RabidGravy> neigh!

[22:18] *** mj41 left
[22:18] <pmurias> timotimo: that's an actual language?

[22:18] <timotimo> oh

[22:18] <timotimo> the whoa was for liz' commit

[22:19] <konobi> pmurias: there's asmjs

[22:19] <vendethiel> ok. so, scalaJS is pretty good at using scala stuff, since it's just a compiler backend, much like nqp-js. languages like coffeescript because they "just are js". Opal is also pretty interesting, because it's incredibly dynamic (i.e., + and .map/.each being actual calls *or* primitives if you enable a compiler switch)

[22:20] <vendethiel> ghcjs is interesting, because of the difficulty of implementation of haskell in js (ugh, thunks. PureScript went the "easy" way, and is strict. but its module system sucks)

[22:21] <pmurias> coffeescript and it's offspring are in the low price/little gain niche we will not be able to compete in

[22:21] <lizmat> timotimo:  whoa why ?

[22:22] <cygx> [Coke], RabidGravy: might be something wrong with my local setup...

[22:22] <konobi> coffeescript is a disaster anyway

[22:22] <vendethiel> now that's harsh :(.

[22:22] <timotimo> a cunning plan!

[22:22] <konobi> it's true though

[22:23] <BenGoldberg> m: my \foo = (\foo,); foo.perl.say;

[22:23] <camelia> rakudo-moar fc8bda: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/r6i7IaAHEO:1␤␤»

[22:23] <timotimo> coffeescript is another of those languages that would be better off if they had an explicit "my"-like

[22:23] <BenGoldberg> m: my \foo = (\foo,); foo.say;

[22:23] <camelia> rakudo-moar fc8bda: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/h7TAJ5LJSb:1␤␤»

[22:23] <vendethiel> konobi: well, as a contributor it makes me sad

[22:23] *** Begi1115 left
[22:23] <BenGoldberg> m: my $foo = ($foo,42,); $foo.say;

[22:23] <camelia> rakudo-moar fc8bda: OUTPUT«5===SORRY!5=== Error while compiling /tmp/NWeUBXgNlm␤Cannot use variable $foo in declaration to initialize itself␤at /tmp/NWeUBXgNlm:1␤------> 3my $foo = ($7⏏5foo,42,); $foo.say;␤    expecting any of:␤        term␤»

[22:23] <vendethiel> the my-like is definitely true, and you're far from being the only one to think that, even between contributors. but oh well

[22:23] <BenGoldberg> m: my \foo = (\foo,42,); foo.say;

[22:23] <camelia> rakudo-moar fc8bda: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/Kye9Ton8yn:1␤␤»

[22:24] <BenGoldberg> m: my \foo = (\foo,42,); say foo;

[22:24] <camelia> rakudo-moar fc8bda: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/Wl88btGLSG:1␤␤»

[22:24] <BenGoldberg> m: my \foo = (41,\foo,42,); say foo;

[22:24] <camelia> rakudo-moar fc8bda: OUTPUT«Cannot call method 'perl' on a null object␤  in block <unit> at /tmp/y4qJAf3h2A:1␤␤»

[22:24] <BenGoldberg> m: my \foo = (41,\foo,42,); say defined foo;

[22:24] <camelia> rakudo-moar fc8bda: OUTPUT«True␤»

[22:24] <lizmat> timotimo: yeah, which will fix various issues with IO::ArgFiles

[22:24] <BenGoldberg> p6: my \foo = (41,\foo,42,); say defined foo;

[22:24] <camelia> rakudo-moar fc8bda: OUTPUT«True␤»

[22:24] <timotimo> nice!

[22:24] <timotimo> yeah, ArgFiles has always been a bit weak

[22:24] <konobi> vendethiel: better options these days anyway

[22:24] <vendethiel> konobi: like?

[22:24] <konobi> typescript

[22:25] <timotimo> Kotlin

[22:25] <vendethiel> kotlin is not stable (and brings a huge baggage). typescript is unsound... someone have them fix that, please :[

[22:25] <timotimo> livescript?

[22:26] <pmurias> wasn't google trying to make it sound

[22:26] <dalek> roast: e3f1811 | coke++ | S02-types/WHICH.t:

[22:26] <dalek> roast: Convert list to manual strings.

[22:26] <dalek> roast: 

[22:26] <dalek> roast: Needed so we can do some slightly tricky fudging.

[22:26] <dalek> roast: review: https://github.com/perl6/roast/commit/e3f181175f

[22:26] <dalek> roast: 2824a98 | coke++ | S02-types/WHICH.t:

[22:26] <dalek> roast: Fudge for jvm, open ticket.

[22:26] <dalek> roast: review: https://github.com/perl6/roast/commit/2824a9880a

[22:26] <vendethiel> livescript is pretty much dead (and I don't want to keep on being the only one trying to make stuff change)

[22:26] <konobi> having an actual spec helps a lot

[22:26] *** zakharyas joined
[22:27] <TEttinger> https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS

[22:27] <TEttinger> take your pick

[22:27] <vendethiel> most of them aren't interesting.

[22:27] <timotimo> what about the "closure compiler" google made?

[22:27] <vendethiel> or not interesting in this case. say sweet.js, interesting for masak++, not so much for pmurias++ :)

[22:27] <BenGoldberg> p6: my \foo = []; push foo, foo, ; my $bar = foo.perl; say $bar; my \baz = $bar.EVAL; baz.perl.say; # Bug?

[22:27] <camelia> rakudo-moar 79efbb: OUTPUT«(my \Array_140514291409024 = [Array_140514291409024,])␤[Mu]␤»

[22:28] <lizmat> [Coke]: you realize there was a list of Moar only classes already >>

[22:29] <[Coke]> lizmat: Not until I had already fudged it, no. and now we have specific markers for specific  NYI things.

[22:29] *** tokuhirom joined
[22:29] <[Coke]> if you want, I can switch it back.

[22:29] <konobi> huh, didn't notice perlito before

[22:29] <lizmat> well, I went through a lot of trouble not having to put quotes around them

[22:29] <[Coke]> ok. it just means we can't use fudge markers like we do everywhere else.

[22:30] <[Coke]> Changing it back.

[22:30] <timotimo> bob ross is so relaxing

[22:30] <lizmat> [Coke]: just mention both tickets on the the moar only loop

[22:30] <pmurias> vendethiel: most of them are in the "thin mostly syntactic layer on top of js"

[22:30] <konobi> pmurias: any idea how perlito does the bundling?

[22:30] <vendethiel> pmurias: no, scalaJS and ghcjs aren't

[22:31] <TEttinger> vendethiel: I'm slowly approaching your record streak, btw. 505 days

[22:31] <lizmat> [Coke]++

[22:31] <vendethiel> TEttinger: please don't burn like I did.

[22:31] <timotimo> timo@schmetterling ~ [1]> perl6 -e 'my Rat $foo = 10'

[22:31] <timotimo> Assigning a literal Integer to a Rat-typed variable won't work. You can try 10.Rat instead

[22:31] <timotimo> Type check failed in assignment to $foo; expected Rat but got Int

[22:31] <vendethiel> ended up not touching a single line of code for around 2 months after that

[22:31] <timotimo> ^- like?

[22:31] <TEttinger> I actually am right this moment working on a non-code-related project

[22:32] <pmurias> vendethiel: I meant the ones on the huge list

[22:32] <vendethiel> pmurias: oh! yep. I didn't link that list, btw

[22:33] <pmurias> vendethiel: opal could be useful for stealing ideas

[22:33] <pmurias> and having opal interop could be fun

[22:33] <vendethiel> pmurias: they face much of the performance concerns you might have, btw

[22:33] <konobi> pmurias: https://github.com/fglock/Perlito

[22:33] *** tokuhirom left
[22:35] <vendethiel> pmurias: although as timotimo++ said, you might be interested in ceylon/kotlin as they're both jvm-and-js. I prefer ceylon because it "does more", but both are good

[22:35] <dalek> roast: aaec9c4 | coke++ | S02-types/WHICH.t:

[22:35] <dalek> roast: Consolidate non-moar classes into one section

[22:35] <dalek> roast: review: https://github.com/perl6/roast/commit/aaec9c4a50

[22:35] <dalek> roast: 7a060c8 | coke++ | S02-types/WHICH.t:

[22:35] <dalek> roast: Convert back to pretty list

[22:35] <dalek> roast: 

[22:35] <dalek> roast: lizmat++

[22:35] <dalek> roast: review: https://github.com/perl6/roast/commit/7a060c89d3

[22:35] <pmurias> vendethiel: I should start working on speeding up nqp-js soon, I feel most of the horrible performance at the moment is caused by things that could be easily fixed

[22:36] <vendethiel> pmurias: and lastly, maybe take a look at clojurescript, because it has a great ecosystem, a great way of doing things, and a way to specify whether code should run on the jvm or on the JS side

[22:36] <vendethiel> (also, you can just access to any js thing with "js" namespace. ie `(js/alert "hey")`)

[22:37] <konobi> pmurias: you can use node-webkit-agent to do profiling via node

[22:37] *** xfix left
[22:37] <pmurias> vendethiel: like emitting nqp.wval($long_sc_descriptor, $idx) instead of wval_303

[22:38] <vendethiel> yeah, that kind of stuff...

[22:38] <vendethiel> but you're going to have a very "fun" time for control exceptions,say.. ugh

[22:39] *** zakharyas left
[22:40] *** Oatmeal left
[22:40] <pmurias> vendethiel: the closer we will want to get full js performance the crazier and more cunning the compiler will need to be

[22:41] <vendethiel> :)

[22:41] <vendethiel> "good luck" or something... hahaha..

[22:42] <pmurias> things like getting @foo[123] to be compiled to just array access seem more difficult that control exceptions

[22:42] <vendethiel> it's lexically scoped, so it might actually be feasible

[22:43] <pmurias> sub foo(@who-knows-what-we-get-here) {...}

[22:43] <pmurias> dart.js uses type checks and two versions of a routine

[22:43] <vendethiel> yep. every single containers has a cost

[22:44] <vendethiel> pmurias: dart.js specializes every sub per type?!!

[22:45] <pmurias> I haven't looked at the implementation closely just watched a talk on youtube how it works

[22:45] *** kjs_ joined
[22:45] <konobi> could always use es6 proxies

[22:45] <pmurias> vendethiel: I think they just guess a type and check on it

[22:45] <vendethiel> es6 proxies are very slow, though :(

[22:46] <konobi> i think it's pretty reasonable in v8

[22:46] <pmurias> konobi: hacking around things is not generally a problem

[22:46] <vendethiel> unless it has gotten crazy improvements... dynamic dispatch is always incredibly costly

[22:46] <pmurias> hacking around things and having things run fast is what's the problem

[22:47] *** Oatmeal joined
[22:47] *** kjs_ left
[22:48] <pmurias> fetching food&

[22:49] *** BenGoldberg left
[22:49] *** Ben_Goldberg joined
[22:52] <[Coke]> r: (1..*).Capture

[22:52] <camelia> rakudo-{moar,jvm} 79efbb: ( no output )

[22:52] <[Coke]> r: (1..*).Capture.perl

[22:52] <camelia> rakudo-moar 79efbb: ( no output )

[22:52] <camelia> ..rakudo-jvm 79efbb: OUTPUT«java.lang.NullPointerException␤  in block <unit> at /tmp/tmpfile:1␤␤»

[22:55] <dalek> rakudo/nom: 1cc3825 | lizmat++ | src/core/List.pm:

[22:55] <dalek> rakudo/nom: Simplify List.keys

[22:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1cc382505d

[22:55] <dalek> rakudo/nom: 938b1bd | lizmat++ | src/core/ (4 files):

[22:55] <dalek> rakudo/nom: Move NOT_ALL_DEFINED_TYPE to Rakudo::Internals

[22:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/938b1bda88

[22:55] <timotimo> haha

[22:55] <timotimo> not all defined types!

[22:55] *** bjz left
[22:57] <dalek> roast: ea2bca8 | coke++ | S02-types/capture.t:

[22:57] <dalek> roast: fudge, refer to new ticket

[22:57] <dalek> roast: review: https://github.com/perl6/roast/commit/ea2bca872e

[22:59] <timotimo> so ...

[22:59] <timotimo> you know this error?

[22:59] <timotimo> m: my Num $foo = 10;

[22:59] <camelia> rakudo-moar 4c1f09: OUTPUT«Type check failed in assignment to $foo; expected Num but got Int␤  in block <unit> at /tmp/SapZMXQkME:1␤␤»

[23:00] <timotimo> wouldn't you much rather have it be:

[23:00] <timotimo> ===SORRY!=== Error while compiling -e

[23:00] <timotimo> Can't assign a Int literal (10) to a Num variable. You can try 10e0 instead or use Real

[23:01] <timotimo> at -e:1

[23:01] <timotimo> ------> my Num $foo = ⏏10

[23:02] <dalek> rakudo/nom: 16d96fc | timotimo++ | src/ (2 files):

[23:02] <dalek> rakudo/nom: complain at optimize-time about my Num $foo = 10

[23:02] <dalek> rakudo/nom: 

[23:02] <dalek> rakudo/nom: instead of at run-time. also works for Rat, Int and Complex and for

[23:02] <dalek> rakudo/nom: numeric constants, too.

[23:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16d96fcde5

[23:05] <timotimo> i desire praise

[23:05] *** mattp_ left
[23:05] *** mattp_ joined
[23:06] <vendethiel> timotimo: the code is hard to read! :P

[23:06] <vendethiel> timotimo++

[23:08] <timotimo> feel free to improve the whitespace there

[23:09] <timotimo> thank you for the praise, though :)

[23:10] <Praise> you desire me, timotimo?

[23:10] <vendethiel> *g*

[23:10] <cygx> https://github.com/rakudo/rakudo/pull/568/files # teach EVAL about nqp

[23:12] * vendethiel left a comment

[23:13] <timotimo> Praise: from the bottom of my heart

[23:14] <cygx> vendethiel: I'd vote for changing the Perl5 signature - it looks cleaner with the :$lang!

[23:14] <lizmat> timotimo++

[23:14] <vendethiel> cygx: agreed :)

[23:17] <RabidGravy> right, beddy byes I think

[23:18] <lizmat> gnight RabidGravy 

[23:18] <RabidGravy> :)

[23:22] *** RabidGravy left
[23:25] <timotimo> m: my Num $foo = 0;

[23:25] <camelia> rakudo-moar 16d96f: OUTPUT«5===SORRY!5=== Error while compiling /tmp/CVDFsegRlJ␤Can't assign a Int literal (0) to a Num variable. You can try 0e0 instead or use Real␤at /tmp/CVDFsegRlJ:1␤------> 3my Num $foo = 7⏏050;␤»

[23:25] <timotimo> <3

[23:25] <cygx> timotimo: btw, congratulations on having the second-oldest still open pull request in the rakudo repository (2013-07-19)

[23:26] *** bjz joined
[23:26] <[Coke]> timotimo++

[23:28] <timotimo> cygx: sorry!!

[23:28] <[Coke]> r: my int $namcu; $namcu = 2**100

[23:28] <camelia> rakudo-jvm 16d96f: ( no output )

[23:28] <camelia> ..rakudo-moar 16d96f: OUTPUT«Cannot unbox 101 bit wide bigint into native integer␤  in block <unit> at /tmp/tmpfile:1␤␤»

[23:28] <timotimo> that one's still waiting on a design decision, cygx :)

[23:29] <lizmat> FWIW, I've heard some cryptologist express their hope native int overflows would be silent

[23:30] <timotimo> they are

[23:30] <timotimo> i have no intent on changing that

[23:31] <FROGGS_> jnthn intends to change it

[23:31] <timotimo> oh?

[23:32] <FROGGS_> aye

[23:32] <timotimo> can we at least put that behind a pragma?

[23:32] <dalek> roast: 55e2406 | coke++ | S02-types/declare.t:

[23:32] <dalek> roast: fudge for JVM, new ticket

[23:32] <dalek> roast: review: https://github.com/perl6/roast/commit/55e2406b15

[23:32] <FROGGS_> probably

[23:33] <timotimo> it'll probably want to be supported by the backend and there ought to be a difference in code-gen?

[23:34] *** bjz left
[23:35] *** bjz joined
[23:42] <pmurias> what will native int overflows do?

[23:45] <timotimo> throw an exception, probably?

[23:46] <timotimo> that's the only "not silent" way i can imagine

[23:47] <pmurias> timotimo: the spec seems to imply that they will return a boxed value if there is an overflow

[23:47] *** mr_ron joined
[23:47] <pmurias> well, would be as they would avoid it

[23:48] *** mattp__ joined
[23:48] *** mattp_ left
[23:50] <pmurias> timotimo: if the boxed value is stored in a native place, the optimizer can turn the whole operation into a "fast one"

[23:51] <mr_ron> m: https://gist.github.com/ronaldxs/9d5bf980ef9c3d1cd0ce

[23:51] <camelia> rakudo-moar 16d96f: OUTPUT«99 bottles of beer on the wall, 99 bottles of beer.take one down, 98 bottles of beer on the wall.␤[("99 bottles", "take one down", "98 bottles"), ("98 bottles", "take one down", "97 bottles")]␤Too few positionals passed; expected 3 arguments but got 2…»

[23:53] <timotimo> pmurias: but operations on native vars is already just operating on registers

[23:54] <mr_ron> I just noticed the 99 bottles of beer - https://github.com/perl6/perl6-examples/blob/master/categories/other/bottles.pl - example seems to be broken

[23:55] <mr_ron> same error as my gist

[23:56] <dalek> rakudo/nom: dbb2022 | lizmat++ | src/core/List.pm:

[23:56] <dalek> rakudo/nom: Revert "Simplify List.keys"

[23:56] <dalek> rakudo/nom: 

[23:56] <dalek> rakudo/nom: This reverts commit 1cc382505d6ebc7063fc65f0ad1d097c4ac2b54a.

[23:56] <dalek> rakudo/nom: 

[23:56] <dalek> rakudo/nom: Because now the list of keys isn't bounded like the actual list.

[23:56] <dalek> rakudo/nom: The commit did not cause any spectest failures, it probably should have.

[23:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbb2022a47

[23:56] <dalek> rakudo/nom: d98dc80 | lizmat++ | src/core/List.pm:

[23:56] <dalek> rakudo/nom: Make List.kv between 1.5x and 6x faster

[23:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d98dc80288

[23:57] <lizmat> good night, #perl6!

[23:57] <timotimo> neato

[23:58] *** mattp__ left
[23:59] *** mattp__ joined
